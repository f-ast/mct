package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import java.util.ArrayList;

import java.util.Iterator;

import java.util.List;

import org.eclipse.draw2d.AbsoluteBendpoint;

import org.eclipse.draw2d.AnchorListener;

import org.eclipse.draw2d.Bendpoint;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.ConnectionAnchor;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.LayoutManager;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.draw2d.graph.Path;

import org.eclipse.draw2d.graph.ShortestPathRouter;

import org.eclipse.gmf.runtime.draw2d.ui.figures.IBorderItemLocator;

import org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

public class BorderItemRectilinearRouter extends RectilinearRouter {
    private static int OFFSET = 15;

    protected PointList calculateBendPoints (Connection conn) {
        IFigure source = conn.getSourceAnchor ().getOwner ();
        IFigure target = conn.getTargetAnchor ().getOwner ();
        if (source == null || target == null || isAvoidingObstructions (conn) || isClosestDistance (conn)) {
            return super.calculateBendPoints (conn);
        }
        int sourcePosition = getBorderFigurePosition (source);
        int targetPosition = getBorderFigurePosition (target);
        PolylineConnectionEx fakeConnection = new PolylineConnectionEx () {

            public void validate () {
            }

            public void paintFigure (Graphics graphics) {
            }

        }

        ;
        Rectangle sourceParentRect = getObstacle (source, conn, (sourcePosition != PositionConstants.NONE));
        Rectangle targetParentRect = getObstacle (target, conn, (targetPosition != PositionConstants.NONE));
        if (sourceParentRect.contains (targetParentRect)) {
            sourcePosition = reversePosition (sourcePosition);
        } else if (targetParentRect.contains (sourceParentRect)) {
            targetPosition = reversePosition (targetPosition);
        }

        fakeConnection.setSourceAnchor (new BorderItemConnectionAnchor (conn.getSourceAnchor (), sourcePosition, OFFSET));
        fakeConnection.setTargetAnchor (new BorderItemConnectionAnchor (conn.getTargetAnchor (), targetPosition, OFFSET));
        fakeConnection.setConnectionRouter (conn.getConnectionRouter ());
        List originalbendpoints = (ArrayList) conn.getConnectionRouter ().getConstraint (conn);
        if (originalbendpoints == null) {
            return super.calculateBendPoints (conn);
        }
        fakeConnection.setParent (conn.getParent ());
        if (conn instanceof PolylineConnectionEx) {
            PolylineConnectionEx connection = (PolylineConnectionEx) conn;
            fakeConnection.setRoutingStyles (connection.isClosestDistanceRouting (), connection.isAvoidObstacleRouting ());
        }
        List constraint = new ArrayList ();
        for (Iterator itr = originalbendpoints.iterator ();
        itr.hasNext ();) {
            Bendpoint bp = (Bendpoint) itr.next ();
            constraint.add (new AbsoluteBendpoint (bp.getLocation ()));
        }
        AbsoluteBendpoint startPoint = (AbsoluteBendpoint) constraint.get (0);
        if (sourcePosition != PositionConstants.NONE) {
            BorderItemConnectionAnchor anchor = (BorderItemConnectionAnchor) fakeConnection.getSourceAnchor ();
            Point startBendpoint = anchor.getReferencePoint ();
            conn.translateToRelative (startBendpoint);
            constraint.remove (0);
            startPoint = new AbsoluteBendpoint (startBendpoint);
            constraint.add (0, startPoint);
        }
        AbsoluteBendpoint endPoint = (AbsoluteBendpoint) constraint.get (constraint.size () - 1);
        if (targetPosition != PositionConstants.NONE) {
            BorderItemConnectionAnchor anchor = (BorderItemConnectionAnchor) fakeConnection.getTargetAnchor ();
            Point endBendpoint = anchor.getReferencePoint ();
            conn.translateToRelative (endBendpoint);
            constraint.remove (constraint.size () - 1);
            endPoint = new AbsoluteBendpoint (endBendpoint);
            constraint.add (endPoint);
        }
        avoidOverlappingWithParent (startPoint, endPoint, sourceParentRect, targetParentRect, constraint, conn);
        fakeConnection.setRoutingConstraint (constraint);
        PointList points = super.calculateBendPoints (fakeConnection);
        if (sourcePosition != PositionConstants.NONE) {
            BorderItemConnectionAnchor anchor = (BorderItemConnectionAnchor) fakeConnection.getSourceAnchor ();
            Point startPoint1 = anchor.getAnchorPoint ();
            conn.translateToRelative (startPoint1);
            points.insertPoint (startPoint1, 0);
        }
        if (targetPosition != PositionConstants.NONE) {
            BorderItemConnectionAnchor anchor = (BorderItemConnectionAnchor) fakeConnection.getTargetAnchor ();
            Point endPoint1 = anchor.getAnchorPoint ();
            conn.translateToRelative (endPoint1);
            points.addPoint (endPoint1);
        }
        fakeConnection.setParent (null);
        return points;
    }

    private int reversePosition (int position) {
        int newPosition = position;
        if (position == PositionConstants.SOUTH) newPosition = PositionConstants.NORTH;
        else if (position == PositionConstants.NORTH) newPosition = PositionConstants.SOUTH;
        else if (position == PositionConstants.WEST) newPosition = PositionConstants.EAST;
        else if (position == PositionConstants.EAST) newPosition = PositionConstants.WEST;

        return newPosition;
    }

    private class BorderItemConnectionAnchor implements ConnectionAnchor {
        private ConnectionAnchor anchor;
        private int position;
        private int offset;

        public BorderItemConnectionAnchor (ConnectionAnchor anchor, int position, int offset) {
            this.anchor = anchor;
            this.position = position;
            this.offset = offset;
        }

        public void setPosition (int position) {
            this.position = position;
        }

        public Point getReferencePoint () {
            Point referencePoint = getAnchorPoint ();
            if (position == PositionConstants.SOUTH) referencePoint.y += offset;
            else if (position == PositionConstants.NORTH) referencePoint.y -= offset;
            else if (position == PositionConstants.WEST) referencePoint.x -= offset;
            else if (position == PositionConstants.EAST) referencePoint.x += offset;

            return referencePoint;
        }

        public Point getAnchorPoint () {
            Rectangle ownerBounds = getOwner ().getBounds ().getCopy ();
            getOwner ().translateToAbsolute (ownerBounds);
            if (position == PositionConstants.SOUTH) return ownerBounds.getBottom ();
            else if (position == PositionConstants.NORTH) return ownerBounds.getTop ();
            else if (position == PositionConstants.WEST) return ownerBounds.getLeft ();
            else if (position == PositionConstants.EAST) return ownerBounds.getRight ();

            return ownerBounds.getCenter ();
        }

        public void addAnchorListener (AnchorListener listener) {
        }

        public Point getLocation (Point reference) {
            return reference;
        }

        public IFigure getOwner () {
            return anchor.getOwner ();
        }

        public void removeAnchorListener (AnchorListener listener) {
        }

        public ConnectionAnchor getAnchor () {
            return anchor;
        }

    }

    protected int getBorderFigurePosition (IFigure borderFigure) {
        IFigure child = borderFigure;
        IFigure parent = borderFigure.getParent ();
        if (parent != null && parent.getLayoutManager () != null) {
            LayoutManager layoutManager = parent.getLayoutManager ();
            Object layoutConstraint = layoutManager.getConstraint (child);
            if (layoutConstraint instanceof IBorderItemLocator) {
                return ((IBorderItemLocator) layoutConstraint).getCurrentSideOfParent ();
            }
        }
        return PositionConstants.NONE;
    }

    private void avoidOverlappingWithParent (AbsoluteBendpoint startPoint, AbsoluteBendpoint endPoint, Rectangle sourceParentRect, Rectangle targetParentRect, List constraint, Connection conn) {
        if (sourceParentRect.intersects (targetParentRect)) {
            return;
        }
        IMapMode mapMode = MapModeUtil.getMapMode (conn);
        int logicalOffset = mapMode.DPtoLP (OFFSET);
        ShortestPathRouter router = new ShortestPathRouter ();
        Path path = new Path (startPoint, endPoint);
        router.addPath (path);
        router.addObstacle (sourceParentRect);
        router.addObstacle (targetParentRect);
        router.setSpacing (logicalOffset);
        router.solve ();
        PointList points = path.getPoints ();
        points.removePoint (0);
        points.removePoint (points.size () - 1);
        if (points.size () > 0) {
            Point refrencePoint = points.getFirstPoint ();
            AbsoluteBendpoint startPointGuidePoint = new AbsoluteBendpoint (startPoint);
            adjustPointUsingReferencePointAndObstacle (startPointGuidePoint, refrencePoint, sourceParentRect, logicalOffset);
            constraint.add (1, startPointGuidePoint);
            points.removePoint (0);
            if (points.size () == 0) {
                AbsoluteBendpoint endPointGuidePoint = new AbsoluteBendpoint (endPoint);
                adjustPointUsingReferencePointAndObstacle (endPointGuidePoint, refrencePoint, targetParentRect, logicalOffset);
                if (endPointGuidePoint.y == endPoint.y) endPointGuidePoint.x = startPointGuidePoint.x;
                else endPointGuidePoint.y = startPointGuidePoint.y;

                constraint.add (2, endPointGuidePoint);
            }
        }
        if (points.size () > 0) {
            Point referencePoint = points.getLastPoint ();
            AbsoluteBendpoint endPointGuidePoint = new AbsoluteBendpoint (endPoint);
            adjustPointUsingReferencePointAndObstacle (endPointGuidePoint, referencePoint, targetParentRect, logicalOffset);
            constraint.add (constraint.size () - 1, endPointGuidePoint);
        }
    }

    private void adjustPointUsingReferencePointAndObstacle (AbsoluteBendpoint guidePoint, Point referencePoint, Rectangle obstacle, int offSet) {
        boolean changeY = (guidePoint.y >= obstacle.y && guidePoint.y <= (obstacle.y + obstacle.height));
        if (changeY) {
            if (referencePoint.y < guidePoint.y) guidePoint.y = obstacle.y - offSet;
            else guidePoint.y = obstacle.y + obstacle.height + offSet;

        } else {
            if (referencePoint.x < guidePoint.x) guidePoint.x = obstacle.x - offSet;
            else guidePoint.x = obstacle.x + obstacle.width + offSet;

        }
    }

    protected Rectangle getObstacle (IFigure figure, Connection conn, boolean isBorderItem) {
        IFigure parent = null;
        if (isBorderItem) parent = getBorderItemParent (figure);
        else parent = figure;

        Rectangle rect = parent.getBounds ().getCopy ();
        parent.translateToAbsolute (rect);
        conn.translateToRelative (rect);
        return rect;
    }

    protected IFigure getBorderItemParent (IFigure figure) {
        return figure.getParent ().getParent ();
    }

}

