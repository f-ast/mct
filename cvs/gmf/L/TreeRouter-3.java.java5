package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import java.util.ArrayList;

import java.util.List;

import java.util.ListIterator;

import org.eclipse.draw2d.AbsoluteBendpoint;

import org.eclipse.draw2d.Bendpoint;

import org.eclipse.draw2d.BendpointConnectionRouter;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dDebugOptions;

import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dPlugin;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;

public class TreeRouter extends BendpointConnectionRouter implements OrthogonalRouter {
    private BranchRouter branchRouter = new BranchRouter (this);
    private ArrayList connectionList = new ArrayList ();
    private Dimension trunkVertex;
    private Orientation trunkOrientation;
    private boolean updatingPeers = false;
    static private class Orientation {

        private Orientation () {
        }

        static public Orientation TOP = new Orientation ();
        static public Orientation BOTTOM = new Orientation ();
        static public Orientation RIGHT = new Orientation ();
        static public Orientation LEFT = new Orientation ();

        public Point getEdge (Rectangle bounds) {
            if (this == TOP) return bounds.getTop ();
            else if (this == BOTTOM) return bounds.getBottom ();
            else if (this == RIGHT) return bounds.getRight ();

            return bounds.getLeft ();
        }

    }

    public TreeRouter () {
        super ();
    }

    public void invalidate (Connection conn) {
        if (conn.getSourceAnchor () == null || conn.getSourceAnchor ().getOwner () == null || conn.getTargetAnchor () == null || conn.getTargetAnchor ().getOwner () == null) return;

        ListIterator li = connectionList.listIterator ();
        while (li.hasNext ()) {
            Connection connNext = (Connection) li.next ();
            if (! trunkVertexEqual (connNext, conn)) {
                updateConstraint (connNext);
            }
        }
    }

    private boolean trunkVertexEqual (Connection connMaster, Connection connSlave) {
        PointList cmPts = connMaster.getPoints ();
        PointList csPts = connSlave.getPoints ();
        if (cmPts.size () > 2 && csPts.size () > 2) return cmPts.getPoint (2).equals (csPts.getPoint (2));

        return false;
    }

    public Point getTrunkLocation (Connection conn) {
        Dimension vertex = getTrunkVertex ();
        Point target = getTrunkOrientation ().getEdge (conn.getTargetAnchor ().getOwner ().getBounds ());
        Point ptTrunkLoc = new Point (vertex.width, vertex.height);
        ptTrunkLoc = ptTrunkLoc.getTranslated (target);
        return ptTrunkLoc;
    }

    public void setTrunkLocation (Connection conn, Point ptTrunkLoc) {
        Point ptRelTrunkLoc = new Point (ptTrunkLoc);
        if (isTopDown (conn)) {
            if (ptTrunkLoc.y < conn.getTargetAnchor ().getOwner ().getBounds ().getCenter ().y) setTrunkOrientation (Orientation.TOP);
            else setTrunkOrientation (Orientation.BOTTOM);

        } else {
            if (ptTrunkLoc.x < conn.getTargetAnchor ().getOwner ().getBounds ().getCenter ().x) setTrunkOrientation (Orientation.LEFT);
            else setTrunkOrientation (Orientation.RIGHT);

        }
        Point target = getTrunkOrientation ().getEdge (conn.getTargetAnchor ().getOwner ().getBounds ());
        Dimension currentVertex = ptRelTrunkLoc.getDifference (target);
        setTrunkVertex (currentVertex);
    }

    protected void updateConstraint (Connection conn) {
        if (isUpdatingPeers ()) return;

        List bendpoints = (List) conn.getRoutingConstraint ();
        if (bendpoints == null) bendpoints = new ArrayList (conn.getPoints ().size ());

        if (bendpoints != null) {
            Point sourceRefPoint = conn.getSourceAnchor ().getReferencePoint ();
            conn.translateToRelative (sourceRefPoint);
            Point targetRefPoint = conn.getTargetAnchor ().getReferencePoint ();
            conn.translateToRelative (targetRefPoint);
            Point ptTrunk = getTrunkLocation (conn);
            Point ptSource = getBranchRouter ().getSourceLocation (conn, ptTrunk);
            bendpoints.clear ();
            PointList pts = getBranchRouter ().recreateBranch (conn, ptSource, ptTrunk);
            for (int i = 0;
            i < pts.size (); i ++) {
                Bendpoint bp = new AbsoluteBendpoint (pts.getPoint (i));
                bendpoints.add (bp);
            }
        }
        setUpdatingPeers (true);
        try {
            setConstraint (conn, bendpoints);
            conn.invalidate ();
            conn.validate ();
        } catch (Exception e) {
            Trace.catching (Draw2dPlugin.getInstance (), Draw2dDebugOptions.EXCEPTIONS_CATCHING, TreeRouter.class, "updateConstraint", e);
        } finally {
            setUpdatingPeers (false);
        }
    }

    public PointList getPointsFromConstraint (Connection conn) {
        List bendpoints = (List) conn.getRoutingConstraint ();
        if (bendpoints == null) return new PointList ();

        PointList points = new PointList (bendpoints.size ());
        for (int i = 0;
        i < bendpoints.size (); i ++) {
            Bendpoint bp = (Bendpoint) bendpoints.get (i);
            points.addPoint (bp.getLocation ());
        }
        straightenPoints (points, MapMode.DPtoLP (3));
        return points;
    }

    static protected void straightenPoints (PointList newLine, int tolerance) {
        for (int i = 0;
        i < newLine.size () - 1; i ++) {
            Point ptCurrent = newLine.getPoint (i);
            Point ptNext = newLine.getPoint (i + 1);
            int xDelta = Math.abs (ptNext.x - ptCurrent.x);
            int yDelta = Math.abs (ptNext.y - ptCurrent.y);
            if (xDelta < yDelta) {
                if (xDelta > tolerance) return;

                ptNext.x = ptCurrent.x;
            } else {
                if (yDelta > tolerance) return;

                ptNext.y = ptCurrent.y;
            }
            newLine.setPoint (ptNext, i + 1);
        }
    }

    protected BranchRouter getBranchRouter () {
        return branchRouter;
    }

    public void remove (Connection conn) {
        if (conn.getSourceAnchor () == null || conn.getTargetAnchor () == null) return;

        int index = connectionList.indexOf (conn);
        connectionList.remove (conn);
        for (int i = index + 1;
        i < connectionList.size (); i ++) ((Connection) connectionList.get (i)).revalidate ();

        getBranchRouter ().remove (conn);
    }

    public boolean isTopDown (Connection conn) {
        boolean vertical = true;
        if (conn instanceof ITreeConnection) {
            vertical = ((ITreeConnection) conn).getOrientation ().equals (ITreeConnection.Orientation.VERTICAL) ? vertical = true : false;
        }
        return vertical;
    }

    private int DEFAULT_TRUNK_HEIGHT = 32;

    private void checkTrunkVertex (Connection conn) {
        if (getTrunkVertex () == null) {
            Rectangle sourceRect = conn.getSourceAnchor ().getOwner ().getBounds ();
            Rectangle targetRect = conn.getTargetAnchor ().getOwner ().getBounds ();
            Dimension default_trunk = new Dimension (0, DEFAULT_TRUNK_HEIGHT);
            conn.translateToRelative (default_trunk);
            if (isTopDown (conn)) {
                if (sourceRect.getCenter ().y < targetRect.getCenter ().y) {
                    setTrunkVertex (new Dimension (0, - default_trunk.height));
                    setTrunkOrientation (Orientation.TOP);
                } else {
                    setTrunkVertex (new Dimension (0, default_trunk.height));
                    setTrunkOrientation (Orientation.BOTTOM);
                }
            } else {
                if (sourceRect.getCenter ().x < targetRect.getCenter ().x) {
                    setTrunkVertex (new Dimension (- default_trunk.height, 0));
                    setTrunkOrientation (Orientation.LEFT);
                } else {
                    setTrunkVertex (new Dimension (default_trunk.height, 0));
                    setTrunkOrientation (Orientation.RIGHT);
                }
            }
        }
    }

    public void route (Connection conn) {
        if (conn.getSourceAnchor () == null || conn.getSourceAnchor ().getOwner () == null || conn.getTargetAnchor () == null || conn.getTargetAnchor ().getOwner () == null) {
            super.route (conn);
            return;
        }
        if (! connectionList.contains (conn)) {
            connectionList.add (conn);
        }
        checkTrunkVertex (conn);
        getBranchRouter ().route (conn);
        invalidate (conn);
    }

    protected Dimension getTrunkVertex () {
        return trunkVertex;
    }

    protected void setTrunkVertex (Dimension trunkVertex) {
        this.trunkVertex = trunkVertex;
    }

    protected Orientation getTrunkOrientation () {
        return trunkOrientation;
    }

    protected void setTrunkOrientation (Orientation trunkOrientation) {
        this.trunkOrientation = trunkOrientation;
    }

    public boolean isOrthogonalTreeBranch (Connection conn, PointList points) {
        if (isTreeBranch (conn, points)) {
            LineSeg branch = new LineSeg (points.getPoint (0), points.getPoint (1));
            LineSeg trunkShoulder = new LineSeg (points.getPoint (1), points.getPoint (2));
            LineSeg trunk = new LineSeg (points.getPoint (2), points.getPoint (3));
            if (isTopDown (conn)) return branch.isVertical () && trunkShoulder.isHorizontal () && trunk.isVertical ();
            else return branch.isHorizontal () && trunkShoulder.isVertical () && trunk.isHorizontal ();

        }
        return false;
    }

    public boolean isTreeBranch (Connection conn, PointList points) {
        if (points.size () == 4) {
            Rectangle targetBounds = conn.getTargetAnchor ().getOwner ().getBounds ();
            Rectangle sourceBounds = conn.getSourceAnchor ().getOwner ().getBounds ();
            if (isTopDown (conn)) {
                return (points.getPoint (0).x > sourceBounds.x && points.getPoint (0).x < sourceBounds.x + sourceBounds.width) && (points.getPoint (3).x > targetBounds.x && points.getPoint (3).x < targetBounds.x + targetBounds.width);
            } else {
                return (points.getPoint (0).y > sourceBounds.y && points.getPoint (0).y < sourceBounds.y + sourceBounds.height) && (points.getPoint (3).y > targetBounds.y && points.getPoint (3).y < targetBounds.y + targetBounds.height);
            }
        }
        return false;
    }

    public List getConnectionList () {
        return (List) connectionList.clone ();
    }

    protected boolean isUpdatingPeers () {
        return updatingPeers;
    }

    protected void setUpdatingPeers (boolean updatingPeers) {
        this.updatingPeers = updatingPeers;
    }

}

