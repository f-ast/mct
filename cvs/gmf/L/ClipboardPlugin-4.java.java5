package org.eclipse.gmf.runtime.emf.clipboard.core.internal;

import java.util.HashMap;

import java.util.Map;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.Platform;

import org.eclipse.core.runtime.Status;

import org.eclipse.emf.common.EMFPlugin;

import org.eclipse.emf.common.util.ResourceLocator;

import org.osgi.framework.BundleContext;

public class ClipboardPlugin extends EMFPlugin {
    protected static final String PARENTHESIS_OPEN = "(";
    protected static final String PARENTHESIS_CLOSE = ")";
    protected static final String PREFIX_CHANGING = "CHANGING ";
    protected static final String PREFIX_CATCHING = "CAUGHT ";
    protected static final String PREFIX_THROWING = "THROWN ";
    protected static final String PREFIX_ENTERING = "ENTERING ";
    protected static final String PREFIX_EXITING = "EXITING ";
    protected static final String SEPARATOR_METHOD = "#";
    protected static final String SEPARATOR_PARAMETER = ", ";
    protected static final String SEPARATOR_RETURN = ":";
    protected static final String SEPARATOR_SPACE = " ";
    protected static final String LABEL_OLD_VALUE = "old=";
    protected static final String LABEL_NEW_VALUE = "new=";
    public static final ClipboardPlugin INSTANCE = new ClipboardPlugin ();
    private static Implementation plugin;
    public static final String EXTPT_CLIPBOARDSUPPORT = "clipboardSupport";

    public ClipboardPlugin () {
        super (new ResourceLocator [] {});
    }

    public ResourceLocator getPluginResourceLocator () {
        return plugin;
    }

    public static Implementation getPlugin () {
        return plugin;
    }

    public static class Implementation extends EclipsePlugin {

        public Implementation () {
            super ();
            plugin = this;
        }

        public void start (BundleContext context) throws Exception {
            super.start (context);
            configureClipboardSupport ();
        }

        private void configureClipboardSupport () {
            ClipboardSupportManager.configureExtensions (Platform.getExtensionRegistry ().getConfigurationElementsFor (ClipboardSupportManager.EP_CLIPBOARD_SUPPORT));
        }

    }

    public static class Tracing {
        private static final Map cachedOptions = new HashMap ();

        protected static boolean shouldTrace () {
            return plugin.isDebugging ();
        }

        public static boolean shouldTrace (String option) {
            if (shouldTrace ()) {
                Boolean value = null;
                synchronized (cachedOptions) {
                    value = (Boolean) cachedOptions.get (option);
                    if (null == value) {
                        value = new Boolean (Boolean.TRUE.toString ().equalsIgnoreCase (org.eclipse.core.runtime.Platform.getDebugOption (option)));
                        cachedOptions.put (option, value);
                    }
                }
                return value.booleanValue ();
            }
            return false;
        }

        protected static String getArgumentString (Object argument) {
            return String.valueOf (argument);
        }

        protected static String getArgumentsString (Object [] arguments) {
            StringBuffer buffer = new StringBuffer ();
            for (int i = 0;
            i < arguments.length; i ++) {
                buffer.append (getArgumentString (arguments [i]));
                if (i < arguments.length - 1) {
                    buffer.append (SEPARATOR_PARAMETER);
                }
            }
            return buffer.toString ();
        }

        public static void trace (String message) {
            if (shouldTrace ()) {
                System.out.println (message);
            }
        }

        public static void trace (String option, String message) {
            if (shouldTrace (option)) {
                trace (message);
            }
        }

        public static void changing (String option, String valueDescription, Object oldValue, Object newValue) {
            if (shouldTrace (option)) {
                trace (PREFIX_CHANGING + valueDescription + SEPARATOR_SPACE + LABEL_OLD_VALUE + getArgumentString (oldValue) + SEPARATOR_PARAMETER + LABEL_NEW_VALUE + getArgumentString (newValue));
            }
        }

        public static void changing (String option, Class clazz, String methodName, String valueDescription, Object oldValue, Object newValue) {
            if (shouldTrace (option)) {
                trace (PREFIX_CHANGING + valueDescription + SEPARATOR_SPACE + LABEL_OLD_VALUE + getArgumentString (oldValue) + SEPARATOR_PARAMETER + LABEL_NEW_VALUE + getArgumentString (newValue) + SEPARATOR_SPACE + PARENTHESIS_OPEN + clazz.getName () + SEPARATOR_METHOD + methodName + PARENTHESIS_CLOSE);
            }
        }

        public static void catching (String option, Class clazz, String methodName, Throwable throwable) {
            if (shouldTrace (option)) {
                trace (PREFIX_CATCHING + throwable.getMessage () + SEPARATOR_SPACE + PARENTHESIS_OPEN + clazz.getName () + SEPARATOR_METHOD + methodName + PARENTHESIS_CLOSE);
                throwable.printStackTrace (System.err);
            }
        }

        public static void throwing (String option, Class clazz, String methodName, Throwable throwable) {
            if (shouldTrace (option)) {
                trace (PREFIX_THROWING + throwable.getMessage () + SEPARATOR_SPACE + PARENTHESIS_OPEN + clazz.getName () + SEPARATOR_METHOD + methodName + PARENTHESIS_CLOSE);
                throwable.printStackTrace (System.err);
            }
        }

        public static void entering (String option, Class clazz, String methodName) {
            if (shouldTrace (option)) {
                trace (PREFIX_ENTERING + clazz.getName () + SEPARATOR_METHOD + methodName);
            }
        }

        public static void entering (String option, Class clazz, String methodName, Object parameter) {
            if (shouldTrace (option)) {
                trace (PREFIX_ENTERING + clazz.getName () + SEPARATOR_METHOD + methodName + PARENTHESIS_OPEN + getArgumentString (parameter) + PARENTHESIS_CLOSE);
            }
        }

        public static void entering (String option, Class clazz, String methodName, Object [] parameters) {
            if (shouldTrace (option)) {
                trace (PREFIX_ENTERING + clazz.getName () + SEPARATOR_METHOD + methodName + PARENTHESIS_OPEN + getArgumentsString (parameters) + PARENTHESIS_CLOSE);
            }
        }

        public static void exiting (String option, Class clazz, String methodName) {
            if (shouldTrace (option)) {
                trace (PREFIX_EXITING + clazz.getName () + SEPARATOR_METHOD + methodName);
            }
        }

        public static void exiting (String option, Class clazz, String methodName, Object returnValue) {
            if (shouldTrace (option)) {
                trace (PREFIX_EXITING + clazz.getName () + SEPARATOR_METHOD + methodName + SEPARATOR_RETURN + getArgumentString (returnValue));
            }
        }

    }

    public static void catching (Class class1, String functionName, Throwable exception) {
        Tracing.catching (ClipboardDebugOptions.EXCEPTIONS_CATCHING, class1, functionName, exception);
    }

    public static void throwing (Class class1, String functionName, Throwable exception) {
        Tracing.throwing (ClipboardDebugOptions.EXCEPTIONS_THROWING, class1, functionName, exception);
    }

    public static void log (int code, String message, Throwable exception) {
        Status s = new Status (IStatus.INFO, plugin.getSymbolicName (), code, message != null ? message : "", exception);
        getPlugin ().log (s);
    }

    public static void warning (int code, String message, Throwable exception) {
        Status s = new Status (IStatus.WARNING, plugin.getSymbolicName (), code, message != null ? message : "", exception);
        getPlugin ().log (s);
    }

}

