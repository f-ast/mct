package org.eclipse.gmf.internal.common.codegen;

import java.io.IOException;

import java.io.StringReader;

import java.text.MessageFormat;

import java.util.ArrayList;

import java.util.HashMap;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import java.util.SortedMap;

import java.util.TreeMap;

import javax.xml.parsers.ParserConfigurationException;

import javax.xml.parsers.SAXParserFactory;

import org.eclipse.gmf.internal.common.Activator;

import org.xml.sax.Attributes;

import org.xml.sax.InputSource;

import org.xml.sax.SAXException;

import org.xml.sax.helpers.DefaultHandler;

public class PluginXMLTextMerger {
    private static final String ATTR_POINT = "point";
    private static final String ELEM_EXTENSION = "extension";
    private static final String ELEM_EXTENSION_START = "<" + ELEM_EXTENSION;
    private static final String ELEM_EXTENSION_END = "</" + ELEM_EXTENSION + ">";
    private static final String ELEM_PLUGIN = "plugin";
    private static final String ELEM_PLUGIN_END = "</" + ELEM_PLUGIN + ">";
    private static final String COMMENT_START = "<!--";
    private static final String COMMENT_END = "-->";
    private final String myPITag;
    private SAXParserFactory factory;

    public PluginXMLTextMerger (String piTarget, String piAttrName, String piAttrValue) {
        this.myPITag = MessageFormat.format ("<?{0} {1}=\"{2}\"?>", piTarget, piAttrName, piAttrValue);
    }

    public boolean isRecognizedDocument (String xml) {
        try {
            return parseDocument (xml) != null;
        } catch (Exception ex) {
            return false;
        }
    }

    public String process (String oldXML, String newXML) {
        ParsedPluginXML newDoc;
        try {
            newDoc = parseDocument (newXML);
        } catch (Exception e) {
            logException ("Generated plugin.xml is invalid. Existing plugin.xml will be kept", e);
            return oldXML;
        }
        ParsedPluginXML oldDoc;
        try {
            oldDoc = parseDocument (oldXML);
        } catch (Exception e) {
            logException ("Existing plugin.xml is invalid and will be replaced with generated one", e);
            return newXML;
        }
        String result = mergeDocuments (oldDoc, newDoc);
        try {
            parseDocument (result);
        } catch (Exception e) {
            logException ("Merged plugin.xml is invalid and will be replaced with generated one", e);
            return newXML;
        }
        return result;
    }

    private ParsedPluginXML parseDocument (String xml) throws SAXException, ParserConfigurationException, IOException {
        ParsedPluginXML pluginXML = new ParsedPluginXML (xml, myPITag);
        InputSource is = new InputSource (new StringReader (xml));
        getParserFactory ().newSAXParser ().parse (is, pluginXML);
        return pluginXML;
    }

    private SAXParserFactory getParserFactory () {
        if (factory == null) {
            factory = SAXParserFactory.newInstance ();
        }
        return factory;
    }

    private String mergeDocuments (ParsedPluginXML oldDoc, ParsedPluginXML newDoc) {
        StringBuilder result = new StringBuilder ();
        int currentPosition = oldDoc.getExtensionsStart () - 1;
        final String oldXML = oldDoc.getXML ();
        result.append (oldXML.substring (0, currentPosition));
        final int length = oldXML.length ();
        while (currentPosition < length) {
            int key = currentPosition;
            ExtensionDescriptor oldED = oldDoc.getExtensionByStart (key);
            if (oldED == null) {
                result.append (oldXML.charAt (currentPosition));
                currentPosition ++;
            } else {
                List < ExtensionDescriptor > newEDs = newDoc.getExtensionsByPoint (oldED.pointName);
                if (oldED.generated) {
                    if (newEDs == null) {
                        currentPosition = oldED.endLine;
                        oldED.remove ();
                    } else {
                        ExtensionDescriptor newED = newEDs.get (0);
                        result.append (newED.getText ());
                        currentPosition = oldED.endLine;
                        oldED.remove ();
                        newED.remove ();
                    }
                } else {
                    result.append (oldED.getText ());
                    currentPosition += oldED.getTextLength ();
                    oldED.remove ();
                    if (newEDs != null && ! oldDoc.hasGeneratedExtension (oldED.pointName)) {
                        ExtensionDescriptor newED = newEDs.get (0);
                        newED.remove ();
                    }
                }
            }
            if (oldDoc.getExtensions ().isEmpty () && ! newDoc.getExtensions ().isEmpty ()) {
                boolean sameStartEnd = oldDoc.getExtensionsStart () == oldDoc.getExtensionsEnd ();
                boolean afterStart = currentPosition >= oldDoc.getExtensionsStart ();
                if (afterStart && (sameStartEnd || currentPosition < oldDoc.getExtensionsEnd ())) {
                    List < ExtensionDescriptor > newEDs = newDoc.getExtensions ();
                    for (Iterator iter = newEDs.iterator ();
                    iter.hasNext ();) {
                        ExtensionDescriptor newED = (ExtensionDescriptor) iter.next ();
                        result.append (newED.getText ());
                        newED.remove ();
                        result.append (getPlatformNewLine ());
                    }
                }
            }
        }
        return result.toString ();
    }

    protected void logException (String message, Exception e) {
        Activator.logError (message, e);
    }

    private static String getPlatformNewLine () {
        return System.getProperties ().getProperty ("line.separator");
    }

    private static class ParsedPluginXML extends DefaultHandler {
        private final String myXML;
        private String myGeneratedToken;
        private int myPluginEnd;
        private final Map < String, List < ExtensionDescriptor > > myPoint2ExtensionsMap;
        private final SortedMap < Integer, ExtensionDescriptor > myStart2ExtensionMap;
        private Iterator < ExtensionDescriptor > myIterator;
        private final int myCachedExtStart;

        ParsedPluginXML (String xml, String generatedToken) {
            this.myXML = xml;
            this.myGeneratedToken = generatedToken;
            this.myPoint2ExtensionsMap = new HashMap < String, List < ExtensionDescriptor > > ();
            this.myStart2ExtensionMap = new TreeMap < Integer, ExtensionDescriptor > ();
            parse (xml);
            myCachedExtStart = myStart2ExtensionMap.size () > 0 ? myStart2ExtensionMap.firstKey () : myPluginEnd;
        }

        private void parse (String xml) {
            int currentIndex = 0;
            final int length = xml.length ();
            this.myPluginEnd = xml.lastIndexOf (ELEM_PLUGIN_END);
            while (currentIndex < length) {
                int extensionStart = getStartIndex (xml, ELEM_EXTENSION_START, currentIndex);
                if (extensionStart == length - 1) {
                    break;
                }
                if (isInsideComment (xml, extensionStart)) {
                    currentIndex = extensionStart + ELEM_EXTENSION_START.length ();
                    continue;
                }
                if (! Character.isWhitespace (xml.charAt (extensionStart + ELEM_EXTENSION_START.length ()))) {
                    currentIndex = extensionStart + ELEM_EXTENSION_START.length ();
                    continue;
                }
                currentIndex = processExtensonBlock (xml, extensionStart);
            }
        }

        private int processExtensonBlock (String xml, int fromIndex) {
            int extensionStart = fromIndex;
            int extensionEnd = getStartIndex (xml, ELEM_EXTENSION_END, fromIndex) + ELEM_EXTENSION_END.length ();
            while (isInsideComment (xml, extensionEnd)) {
                extensionEnd = getStartIndex (xml, ELEM_EXTENSION_END, extensionEnd) + ELEM_EXTENSION_END.length ();
            }
            boolean isGenerated = isGenerated (xml, extensionStart, extensionEnd);
            ExtensionDescriptor ed = new ExtensionDescriptor (this, extensionStart, extensionEnd, isGenerated);
            myStart2ExtensionMap.put (ed.startLine, ed);
            return extensionEnd;
        }

        private boolean isGenerated (String xml, int extensionStart, int extensionEnd) {
            int genStart = getStartIndex (xml, myGeneratedToken, extensionStart);
            while (genStart < extensionEnd) {
                if (! isInsideComment (xml, genStart)) {
                    return true;
                }
                genStart = getStartIndex (xml, myGeneratedToken, genStart + myGeneratedToken.length ());
            }
            return false;
        }

        private int getStartIndex (String xml, String token, int fromIndex) {
            int commentStart = xml.indexOf (token, fromIndex);
            return (commentStart < 0) ? xml.length () - 1 : commentStart;
        }

        private boolean isInsideComment (String xml, int fromIndex) {
            int lastOpened = xml.lastIndexOf (COMMENT_START, fromIndex);
            if (lastOpened < 0) {
                return false;
            }
            int lastClosed = xml.lastIndexOf (COMMENT_END, fromIndex);
            if (lastClosed > lastOpened && lastClosed < fromIndex) {
                return false;
            }
            return true;
        }

        List < ExtensionDescriptor > getExtensionsByPoint (String point) {
            List < ExtensionDescriptor > list = myPoint2ExtensionsMap.get (point);
            return list;
        }

        ExtensionDescriptor getExtensionByStart (int start) {
            return myStart2ExtensionMap.get (start);
        }

        void removeExtension (ExtensionDescriptor ed) {
            myStart2ExtensionMap.remove (ed.startLine);
            List < ExtensionDescriptor > list = getExtensionsByPoint (ed.pointName);
            if (list != null) {
                list.remove (ed);
                if (list.size () == 0) {
                    myPoint2ExtensionsMap.remove (ed.pointName);
                }
            }
        }

        boolean hasGeneratedExtension (String point) {
            List < ExtensionDescriptor > list = getExtensionsByPoint (point);
            if (list != null && list.size () > 0) {
                for (Iterator iter = list.iterator ();
                iter.hasNext ();) {
                    ExtensionDescriptor ed = (ExtensionDescriptor) iter.next ();
                    if (ed.generated) {
                        return true;
                    }
                }
            }
            return false;
        }

        List < ExtensionDescriptor > getExtensions () {
            return new ArrayList < ExtensionDescriptor > (myStart2ExtensionMap.values ());
        }

        int getExtensionsStart () {
            if (myStart2ExtensionMap.size () > 0) {
                return myStart2ExtensionMap.firstKey ();
            }
            return myCachedExtStart;
        }

        int getExtensionsEnd () {
            if (myStart2ExtensionMap.size () > 0) {
                ExtensionDescriptor ed = myStart2ExtensionMap.get (myStart2ExtensionMap.lastKey ());
                return ed.endLine;
            }
            return myPluginEnd;
        }

        String getXML () {
            return this.myXML;
        }

        @Override
        public void startDocument () throws SAXException {
            myIterator = myStart2ExtensionMap.values ().iterator ();
        }

        @Override
        public void startElement (String uri, String localName, String qName, Attributes attributes) throws SAXException {
            if (ELEM_EXTENSION.equals (qName)) {
                String pointName = attributes.getValue (ATTR_POINT);
                if (pointName != null) {
                    if (myIterator != null && myIterator.hasNext ()) {
                        ExtensionDescriptor ed = myIterator.next ();
                        ed.pointName = pointName;
                        List < ExtensionDescriptor > list = getExtensionsByPoint (ed.pointName);
                        if (list == null) {
                            list = new ArrayList < ExtensionDescriptor > ();
                            myPoint2ExtensionsMap.put (ed.pointName, list);
                        }
                        list.add (ed);
                    }
                }
            }
        }

        @Override
        public void endDocument () throws SAXException {
            myIterator = null;
        }

    }

    private static class ExtensionDescriptor {
        private final ParsedPluginXML parsedDoc;
        String pointName;
        final boolean generated;
        private final int startLine;
        private final int endLine;

        ExtensionDescriptor (ParsedPluginXML parsedPluginXml, int start, int end, boolean isGenerated) {
            parsedDoc = parsedPluginXml;
            startLine = start;
            endLine = end;
            generated = isGenerated;
        }

        String getText () {
            return parsedDoc.getXML ().substring (startLine, endLine);
        }

        int getTextLength () {
            return endLine - startLine;
        }

        void remove () {
            parsedDoc.removeExtension (this);
        }

    }

}

