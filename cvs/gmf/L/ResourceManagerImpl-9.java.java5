package org.eclipse.gmf.internal.xpand.util;

import java.io.FileNotFoundException;

import java.io.IOException;

import java.io.Reader;

import java.util.Map;

import java.util.TreeMap;

import org.eclipse.gmf.internal.xpand.Activator;

import org.eclipse.gmf.internal.xpand.ResourceManager;

import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;

import org.eclipse.gmf.internal.xpand.model.XpandResource;

import org.eclipse.gmf.internal.xpand.xtend.ast.XtendResource;

public abstract class ResourceManagerImpl implements ResourceManager {
    private final Map < String, XtendResource > cachedXtend = new TreeMap < String, XtendResource > ();
    private final Map < String, XpandResource > cachedXpand = new TreeMap < String, XpandResource > ();

    public XtendResource loadXtendResource (String fullyQualifiedName) {
        try {
            return loadXtendThroughCache (fullyQualifiedName);
        } catch (FileNotFoundException ex) {
            return null;
        } catch (IOException ex) {
            Activator.logError (ex);
        } catch (ParserException ex) {
            handleParserException (ex);
        }
        return null;
    }

    protected XtendResource loadXtendThroughCache (String qualifiedName) throws IOException, ParserException {
        if (hasCachedXtend (qualifiedName)) {
            return cachedXtend.get (qualifiedName);
        }
        final XtendResource loaded = doLoadXtendResource (qualifiedName);
        assert loaded != null;
        if (shouldCache ()) {
            cachedXtend.put (qualifiedName, loaded);
        }
        return loaded;
    }

    private XtendResource doLoadXtendResource (String fullyQualifiedName) throws IOException, ParserException {
        Reader [] rs = resolveMultiple (fullyQualifiedName, XtendResource.FILE_EXTENSION);
        assert rs != null && rs.length > 0;
        XtendResource [] result = loadXtendResources (rs, fullyQualifiedName);
        if (result.length == 1) {
            return result [0];
        }
        return new CompositeXtendResource (this, result);
    }

    public XpandResource loadXpandResource (String fullyQualifiedName) {
        try {
            return loadXpandThroughCache (fullyQualifiedName);
        } catch (FileNotFoundException ex) {
            return null;
        } catch (IOException ex) {
            Activator.logWarn (ex.getMessage ());
        } catch (ParserException ex) {
            handleParserException (ex);
        }
        return null;
    }

    protected XpandResource loadXpandThroughCache (String qualifiedName) throws IOException, ParserException {
        if (hasCachedXpand (qualifiedName)) {
            return cachedXpand.get (qualifiedName);
        }
        final XpandResource loaded = doLoadXpandResource (qualifiedName);
        if (shouldCache ()) {
            cachedXpand.put (qualifiedName, loaded);
        }
        return loaded;
    }

    private XpandResource doLoadXpandResource (String fullyQualifiedName) throws IOException, ParserException {
        Reader [] rs1 = resolveMultiple (fullyQualifiedName, XpandResource.TEMPLATE_EXTENSION);
        assert rs1 != null && rs1.length > 0;
        XpandResource [] unadvised = loadXpandResources (rs1, fullyQualifiedName);
        XpandResource [] advices = null;
        try {
            String aspectsTemplateName = getAspectsTemplateName (fullyQualifiedName);
            Reader [] rs2 = resolveMultiple (aspectsTemplateName, XpandResource.TEMPLATE_EXTENSION);
            advices = loadXpandResources (rs2, aspectsTemplateName);
        } catch (FileNotFoundException e) {
        } catch (IOException ex) {
            Activator.logWarn (ex.getMessage ());
        } catch (ParserException ex) {
            handleParserException (ex);
        }
        if (advices == null && unadvised.length == 1) {
            return unadvised [0];
        }
        return new CompositeXpandResource (this, unadvised, advices);
    }

    protected String getAspectsTemplateName (String fullyQualifiedName) {
        return ASPECT_PREFIX + fullyQualifiedName;
    }

    protected String getNonAspectsTemplateName (String possiblyAspectedFullyQualifiedName) {
        if (possiblyAspectedFullyQualifiedName == null) {
            return null;
        }
        if (possiblyAspectedFullyQualifiedName.startsWith (ASPECT_PREFIX)) {
            return possiblyAspectedFullyQualifiedName.substring (ASPECT_PREFIX.length ());
        }
        return possiblyAspectedFullyQualifiedName;
    }

    protected abstract void handleParserException (ParserException ex);

    protected abstract Reader [] resolveMultiple (String fullyQualifiedName, String extension) throws IOException;

    protected XtendResource [] loadXtendResources (Reader [] readers, String fullyQualifiedName) throws IOException, ParserException {
        XtendResource [] result = new XtendResource [readers.length];
        for (int i = 0;
        i < readers.length; i ++) {
            assert readers [i] != null;
            try {
                result [i] = new XtendResourceParser ().parse (readers [i], fullyQualifiedName);
                assert result [i] != null;
            } finally {
                try {
                    readers [i].close ();
                } catch (Exception ex) {
                }
            }
        }
        return result;
    }

    protected XpandResource [] loadXpandResources (Reader [] readers, String fullyQualifiedName) throws IOException, ParserException {
        XpandResource [] result = new XpandResource [readers.length];
        for (int i = 0;
        i < readers.length; i ++) {
            assert readers [i] != null;
            try {
                result [i] = new XpandResourceParser ().parse (readers [i], fullyQualifiedName);
                assert result [i] != null;
            } finally {
                try {
                    readers [i].close ();
                } catch (Exception ex) {
                }
            }
        }
        return result;
    }

    protected abstract boolean shouldCache ();

    protected final boolean hasCachedXpand (String fullyQualifiedName) {
        return shouldCache () && cachedXpand.containsKey (fullyQualifiedName);
    }

    protected final boolean hasCachedXtend (String fullyQualifiedName) {
        return shouldCache () && cachedXtend.containsKey (fullyQualifiedName);
    }

    protected final void forgetCachedXpand (String fullyQualifiedName) {
        cachedXpand.remove (fullyQualifiedName);
    }

    protected final void forgetCachedXtend (String fullyQualifiedName) {
        cachedXtend.remove (fullyQualifiedName);
    }

    protected final void forgetAll () {
        cachedXpand.clear ();
        cachedXtend.clear ();
    }

    private static final String ASPECT_PREFIX = "aspects" + SyntaxConstants.NS_DELIM;
}

