package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import java.util.HashMap;

import java.util.Iterator;

import java.util.Map;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.Locator;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.gef.GraphicalEditPart;

import org.eclipse.jface.util.Assert;

import org.eclipse.swt.graphics.Image;

import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.decorator.Decoration;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.decorator.DecoratorService;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.decorator.IDecoratorTargetBase.Direction;

import org.eclipse.gmf.runtime.diagram.ui.services.decorator.IDecoration;

import org.eclipse.gmf.runtime.diagram.ui.services.decorator.IDecorator;

import org.eclipse.gmf.runtime.diagram.ui.services.decorator.IDecoratorTarget;

import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.ImageFigureEx;

import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.OnConnectionLocator;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;

import org.eclipse.gmf.runtime.gef.ui.internal.editpolicies.GraphicalEditPolicyEx;

import org.eclipse.gmf.runtime.gef.ui.internal.figures.RelativeToBorderLocator;

public class DecorationEditPolicy extends GraphicalEditPolicyEx {
    public class DecoratorTarget implements IDecoratorTarget {

        public void installDecorator (Object key, IDecorator decorator) {
            Assert.isNotNull (key, "Decorators must be installed with keys");
            decorators.put (key, decorator);
        }

        public Object getAdapter (Class adapter) {
            return getHost ().getAdapter (adapter);
        }

        public IDecoration addShapeDecoration (Image image, Direction direction, int margin, boolean isVolatile) {
            ImageFigureEx figure = new ImageFigureEx ();
            figure.setImage (image);
            figure.setSize (MapMode.DPtoLP (image.getBounds ().width), MapMode.DPtoLP (image.getBounds ().height));
            return addShapeDecoration (figure, direction, margin, isVolatile);
        }

        public IDecoration addConnectionDecoration (Image image, int percentageFromSource, boolean isVolatile) {
            ImageFigureEx figure = new ImageFigureEx ();
            figure.setImage (image);
            figure.setSize (MapMode.DPtoLP (image.getBounds ().width), MapMode.DPtoLP (image.getBounds ().height));
            return addConnectionDecoration (figure, percentageFromSource, isVolatile);
        }

        public void removeDecoration (IDecoration decoration) {
            if (decoration instanceof IFigure) {
                ((IFigure) decoration).getParent ().remove ((IFigure) decoration);
            }
        }

        public IDecoration addShapeDecoration (IFigure figure, Direction direction, int margin, boolean isVolatile) {
            return addDecoration (figure, new RelativeToBorderLocator (((GraphicalEditPart) getAdapter (GraphicalEditPart.class)).getFigure (), getPositionConstant (direction), margin), isVolatile);
        }

        public IDecoration addConnectionDecoration (IFigure figure, int percentageFromSource, boolean isVolatile) {
            IFigure hostFigure = ((GraphicalEditPart) getAdapter (GraphicalEditPart.class)).getFigure ();
            Assert.isTrue (hostFigure instanceof Connection);
            return addDecoration (figure, new OnConnectionLocator ((Connection) hostFigure, percentageFromSource), isVolatile);
        }

        public IDecoration addDecoration (IFigure figure, Locator locator, boolean isVolatile) {
            Decoration decoration = new Decoration ();
            decoration.add (figure);
            decoration.setSize (figure.getSize ());
            decoration.setOwnerFigure (((GraphicalEditPart) getAdapter (GraphicalEditPart.class)).getFigure ());
            decoration.setLocator (locator);
            IFigure pane = getLayer (isVolatile ? DiagramRootEditPart.DECORATION_UNPRINTABLE_LAYER : DiagramRootEditPart.DECORATION_PRINTABLE_LAYER);
            pane.add (decoration);
            return decoration;
        }

    }

    protected Map decorators;

    public void refresh () {
        if (decorators == null) {
            decorators = new HashMap ();
            DecoratorService.getInstance ().createDecorators (new DecoratorTarget ());
        }
        for (Iterator iter = decorators.values ().iterator ();
        iter.hasNext ();) {
            IDecorator decorator = (IDecorator) iter.next ();
            decorator.refresh ();
        }
    }

    public void activate () {
        if (decorators == null) {
            decorators = new HashMap ();
            DecoratorService.getInstance ().createDecorators (new DecoratorTarget ());
        }
        if (decorators != null) {
            for (Iterator iter = decorators.values ().iterator ();
            iter.hasNext ();) {
                IDecorator decorator = (IDecorator) iter.next ();
                decorator.activate ();
            }
        }
    }

    public void deactivate () {
        if (decorators != null) {
            for (Iterator iter = decorators.values ().iterator ();
            iter.hasNext ();) {
                IDecorator decorator = (IDecorator) iter.next ();
                decorator.deactivate ();
            }
        }
    }

    protected final Map getDecorators () {
        return this.decorators;
    }

    protected final void setDecorators (Map decorators) {
        this.decorators = decorators;
    }

    public int getPositionConstant (Direction direction) {
        if (direction == Direction.CENTER) {
            return PositionConstants.CENTER;
        } else if (direction == Direction.NORTH) {
            return PositionConstants.NORTH;
        } else if (direction == Direction.SOUTH) {
            return PositionConstants.SOUTH;
        } else if (direction == Direction.WEST) {
            return PositionConstants.WEST;
        } else if (direction == Direction.EAST) {
            return PositionConstants.EAST;
        } else if (direction == Direction.NORTH_EAST) {
            return PositionConstants.NORTH_EAST;
        } else if (direction == Direction.NORTH_WEST) {
            return PositionConstants.NORTH_WEST;
        } else if (direction == Direction.SOUTH_EAST) {
            return PositionConstants.SOUTH_EAST;
        } else if (direction == Direction.SOUTH_WEST) {
            return PositionConstants.SOUTH_WEST;
        }

        return PositionConstants.CENTER;
    }

}

