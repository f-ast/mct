package org.eclipse.gmf.runtime.common.core.service;

import java.lang.ref.WeakReference;

import java.lang.reflect.Method;

import java.util.ArrayList;

import java.util.Collections;

import java.util.HashMap;

import java.util.HashSet;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import java.util.Set;

import org.eclipse.core.runtime.IAdaptable;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.core.runtime.Platform;

import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;

import org.eclipse.gmf.runtime.common.core.internal.CommonCoreStatusCodes;

import org.eclipse.gmf.runtime.common.core.util.Log;

import org.osgi.framework.Bundle;

import com.ibm.icu.util.StringTokenizer;

public class AbstractProviderConfiguration {
    protected static final String OBJECT = "object";
    protected static final String ID = "id";
    protected static final String CLASS = "class";
    protected static final String METHOD = "method";
    protected static final String STATIC_METHOD = "staticMethod";
    protected static final String NAME = "name";
    protected static final String VALUE = "value";
    protected static final String NOT_VALUE = "notValue";
    protected static final String NULL = "null";
    protected static final String contextParam = "%Context";
    private static Map isAssignableTable = new HashMap ();
    private static Map isNotAssignableTable = new HashMap ();
    private static ClassToMethodSignaturesSetMap passiveClasses = new ClassToMethodSignaturesSetMap ();
    private static class ClassToMethodSignaturesSetMap {
        Map classToMethodSignaturesSetMap = new HashMap ();

        public void addMethod (Class clazz, String signature) {
            Set signatures = (Set) classToMethodSignaturesSetMap.get (clazz);
            if (signatures == null) {
                signatures = new HashSet ();
                classToMethodSignaturesSetMap.put (clazz, signatures);
            }
            signatures.add (signature);
        }

        public boolean contains (Class clazz, String signature) {
            Set signatures = (Set) classToMethodSignaturesSetMap.get (clazz);
            if (signatures == null) return false;

            return signatures.contains (signature);
        }

    }

    private static class ClassToMethodSignatureToMethodCach {
        Map classToMethodSignatureToMethod = new HashMap ();

        public void addMethod (Class clazz, String methodSignature, Method method) {
            Map signatureToMethodMap = (Map) classToMethodSignatureToMethod.get (clazz);
            if (signatureToMethodMap == null) {
                signatureToMethodMap = new HashMap ();
                classToMethodSignatureToMethod.put (clazz, signatureToMethodMap);
            }
            signatureToMethodMap.put (methodSignature, method);
        }

        public Method getMethod (Class clazz, String methodSignature) {
            Map signatureToMethodMap = (Map) classToMethodSignatureToMethod.get (clazz);
            if (signatureToMethodMap != null) {
                return (Method) signatureToMethodMap.get (methodSignature);
            }
            return null;
        }

    }

    private static ClassToMethodSignatureToMethodCach classToMethodSignatureToMethodCach = new ClassToMethodSignatureToMethodCach ();

    static String getClassName (Object object) {
        String cn = object.getClass ().getName ();
        return cn.substring (cn.lastIndexOf ('.') + 1);
    }

    public static class ObjectDescriptor {
        private String contextClassName;
        private String contextClassPlugin;
        private boolean syntaxError;
        private final List methods;
        private final List staticMethods;

        public ObjectDescriptor (IConfigurationElement configElement) {
            this (configElement, CLASS);
        }

        public ObjectDescriptor (IConfigurationElement configElement, String classNameTag) {
            String s = configElement.getAttribute (classNameTag);
            if (s != null) {
                int start = s.indexOf ("(");
                if (start != - 1) {
                    contextClassName = s.substring (0, start).trim ();
                    int end = s.indexOf (")");
                    if (end != - 1 && end > start + 1) contextClassPlugin = s.substring (start + 1, end);

                } else contextClassName = s.trim ();

            }
            IConfigurationElement [] methodConfigs = configElement.getChildren (METHOD);
            IConfigurationElement [] staticMethodConfigs = configElement.getChildren (STATIC_METHOD);
            if (methodConfigs.length != 0) {
                methods = new ArrayList (methodConfigs.length);
                for (int i = 0;
                i < methodConfigs.length; i ++) {
                    String name = methodConfigs [i].getAttribute (NAME);
                    if (name != null) {
                        try {
                            MethodDescriptor methodDescriptor = new MethodDescriptor (name);
                            methodDescriptor.setCall (name.intern ());
                            ValueDescriptor value = new ValueDescriptor (methodConfigs [i]);
                            if (value != null) methods.add (new MethodValueEntry (methodDescriptor, value));

                        } catch (Exception e) {
                            syntaxError = true;
                            Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.SERVICE_FAILURE, configElement.getDeclaringExtension ().getContributor ().getName () + ".plugin.xml extension [" + configElement.getDeclaringExtension ().getExtensionPointUniqueIdentifier () + "]: invalid syntax for method [" + name + "]");
                        }
                    } else {
                        syntaxError = true;
                        Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.SERVICE_FAILURE, configElement.getDeclaringExtension ().getContributor ().getName () + ".plugin.xml extension [" + configElement.getDeclaringExtension ().getExtensionPointUniqueIdentifier () + "] : missing method name");
                    }
                }
            } else methods = Collections.EMPTY_LIST;

            if (staticMethodConfigs.length != 0) {
                staticMethods = new ArrayList (staticMethodConfigs.length);
                for (int i = 0;
                i < staticMethodConfigs.length; i ++) {
                    String name = staticMethodConfigs [i].getAttribute (NAME);
                    if (name != null) {
                        try {
                            StaticMethodDescriptor methodDescriptor = new StaticMethodDescriptor (name);
                            methodDescriptor.setCall (name.intern ());
                            ValueDescriptor value = new ValueDescriptor (staticMethodConfigs [i]);
                            if (value != null) staticMethods.add (new MethodValueEntry (methodDescriptor, value));

                        } catch (Exception e) {
                            syntaxError = true;
                            Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.SERVICE_FAILURE, configElement.getDeclaringExtension ().getContributor ().getName () + ".plugin.xml extension [" + configElement.getDeclaringExtension ().getExtensionPointUniqueIdentifier () + "]: invalid syntax for method [" + name + "]");
                        }
                    } else {
                        syntaxError = true;
                        Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.SERVICE_FAILURE, configElement.getDeclaringExtension ().getContributor ().getName () + ".plugin.xml extension [" + configElement.getDeclaringExtension ().getExtensionPointUniqueIdentifier () + "] : missing method name");
                    }
                }
            } else staticMethods = Collections.EMPTY_LIST;

            if (contextClassName != null) contextClassName = contextClassName.intern ();

            if (contextClassPlugin != null) contextClassPlugin = contextClassPlugin.intern ();

        }

        public boolean sameAs (Object object) {
            if (syntaxError) return false;

            Object targetObject = object;
            if (contextClassName != null) {
                if (! isAssignableTo (object.getClass (), contextClassName)) {
                    targetObject = getAdapter (object, contextClassName, contextClassPlugin);
                    if (targetObject == null) return false;

                }
            }
            for (Iterator iter = methods.iterator ();
            iter.hasNext ();) {
                MethodValueEntry entry = (MethodValueEntry) iter.next ();
                Object methodValue = invokeMethod (entry.method, targetObject);
                if (methodValue == null || ! entry.value.sameAs (methodValue)) return false;

            }
            for (Iterator iter = staticMethods.iterator ();
            iter.hasNext ();) {
                MethodValueEntry entry = (MethodValueEntry) iter.next ();
                Object methodValue = invokeStaticMethod ((StaticMethodDescriptor) entry.method, targetObject);
                if (methodValue == null || ! entry.value.sameAs (methodValue)) return false;

            }
            return true;
        }

    }

    private static class MethodDescriptor {
        private String call;
        private String name;
        private Object parameterObjects [];
        private Class parameterTypes [];
        private MethodDescriptor next;
        private List parameters;
        private String signature = null;

        protected MethodDescriptor () {
        }

        public MethodDescriptor (String string) {
            string = parseName (string.trim ());
            string = parseParameterList (string.trim ());
            if (parameters != null && ! parameters.isEmpty ()) {
                Collections.reverse (parameters);
                parameterObjects = parameters.toArray ();
                parameterTypes = new Class [parameterObjects.length];
                for (int i = 0;
                i < parameterObjects.length; i ++) {
                    String p = (String) parameterObjects [i];
                    int objIndex = p.indexOf ("[object]");
                    boolean isObject = objIndex >= 0;
                    int parseAsIndex = p.indexOf (":::");
                    try {
                        if (isObject && (parseAsIndex >= 0)) assert (objIndex < parseAsIndex);

                        if (parseAsIndex >= 0) {
                            String parseAs = p.substring ((isObject ? 8 : 0), parseAsIndex);
                            String value = p.substring (parseAsIndex + 3, p.length ());
                            if (parseAs.equalsIgnoreCase ("int")) {
                                parameterTypes [i] = Integer.class;
                                parameterObjects [i] = Integer.decode (value);
                            } else if (parseAs.equalsIgnoreCase ("bool")) {
                                parameterTypes [i] = Boolean.class;
                                parameterObjects [i] = Boolean.valueOf (value);
                            } else if (parseAs.equalsIgnoreCase ("double")) {
                                parameterTypes [i] = Double.class;
                                parameterObjects [i] = Double.valueOf (value);
                            }

                            if (isObject) parameterTypes [i] = Object.class;

                        } else if (isObject) {
                            String value = p.substring (8, p.length ());
                            parameterTypes [i] = Object.class;
                            parameterObjects [i] = value;
                        } else parameterTypes [i] = String.class;

                    } catch (Exception e) {
                        String value = p.substring (((parseAsIndex >= 0) ? parseAsIndex + 3 : 0), p.length ());
                        parameterObjects [i] = value;
                        parameterTypes [i] = String.class;
                    }
                }
            }
            parameters = null;
            if (string.length () != 0) {
                if (string.charAt (0) != '.') throw new IllegalArgumentException ();

                next = new MethodDescriptor (string.substring (1).trim ());
            }
            if (this.name != null) name = name.intern ();

        }

        protected String parseName (String string) {
            int index = string.indexOf ('(');
            if (index == - 1) throw new IllegalArgumentException ();

            name = string.substring (0, index).trim ();
            return string.substring (index + 1);
        }

        protected String parseParameterList (String string) {
            int index = - 1;
            String paramStr = null;
            while (paramStr == null) {
                index = string.indexOf (')', index + 1);
                if (index == - 1) throw new IllegalArgumentException ();

                if (index == 0 || string.charAt (index - 1) != '\\') paramStr = string.substring (0, index);

            }
            if (paramStr.length () != 0) {
                parameters = new ArrayList ();
                parseParameters (paramStr.trim ());
            }
            return string.substring (index + 1);
        }

        private void parseParameters (String string) {
            int index = string.indexOf (',');
            if (index != - 1 && string.charAt (index - 1) != '\\') {
                parseParameters (string.substring (index + 1).trim ());
                parameters.add (string.substring (0, index));
            } else parameters.add (string);

        }

        public String getName () {
            return name;
        }

        public void setName (String name) {
            this.name = name;
        }

        public Object [] getParameters () {
            return parameterObjects;
        }

        public Class [] getParameterTypes () {
            return parameterTypes;
        }

        protected void setParameters (Object [] paramters) {
            parameterObjects = paramters;
        }

        public void setParameterTypes (Class [] paramterTypes) {
            this.parameterTypes = paramterTypes;
        }

        public MethodDescriptor getNext () {
            return next;
        }

        protected void setNext (MethodDescriptor next) {
            this.next = next;
        }

        public String getCall () {
            return call;
        }

        public void setCall (String call) {
            this.call = call;
        }

        protected List getParamtersList () {
            return parameters;
        }

        protected void setParamtersList (List parameters1) {
            this.parameters = parameters1;
        }

        public String getSignature () {
            if (this.signature == null) {
                StringBuffer sb = new StringBuffer ();
                sb.append (name);
                sb.append ('(');
                if (parameterTypes != null) for (int index = 0;
                index < parameterTypes.length; index ++) {
                    Class clazz = parameterTypes [index];
                    sb.append (clazz.getName ());
                    if (index < parameterTypes.length - 1) sb.append (',');

                }

                sb.append (')');
                signature = sb.toString ();
            }
            return signature;
        }

    }

    private static class StaticMethodDescriptor extends MethodDescriptor {
        private String pluginID;
        private String className;

        public StaticMethodDescriptor (String string) {
            string = parsePluginID (string.trim ());
            string = parseClassName (string.trim ());
            string = parseName (string.trim ());
            string = parseParameterList (string.trim ());
            List parameters = getParamtersList ();
            if (parameters != null && ! parameters.isEmpty ()) {
                Collections.reverse (parameters);
                Object [] parameterObjects = parameters.toArray ();
                Class [] parameterTypes = new Class [parameterObjects.length];
                for (int i = 0;
                i < parameterObjects.length; i ++) {
                    String p = (String) parameterObjects [i];
                    int objIndex = p.indexOf ("[object]");
                    boolean isObject = objIndex >= 0;
                    int parseAsIndex = p.indexOf (":::");
                    try {
                        if (isObject && (parseAsIndex >= 0)) assert (objIndex < parseAsIndex);

                        if (parseAsIndex >= 0) {
                            String parseAs = p.substring ((isObject ? 8 : 0), parseAsIndex);
                            String value = p.substring (parseAsIndex + 3, p.length ());
                            if (parseAs.equalsIgnoreCase ("int")) {
                                parameterTypes [i] = Integer.class;
                                parameterObjects [i] = Integer.decode (value);
                            } else if (parseAs.equalsIgnoreCase ("bool")) {
                                parameterTypes [i] = Boolean.class;
                                parameterObjects [i] = Boolean.valueOf (value);
                            } else if (parseAs.equalsIgnoreCase ("double")) {
                                parameterTypes [i] = Double.class;
                                parameterObjects [i] = Double.valueOf (value);
                            }

                            if (isObject) parameterTypes [i] = Object.class;

                        } else if (isObject) {
                            String value = p.substring (8, p.length ());
                            parameterTypes [i] = Object.class;
                            parameterObjects [i] = value;
                        } else if (p.startsWith (contextParam)) {
                            parameterTypes [i] = getParameterType (p);
                            parameterObjects [i] = "%Context";
                        } else parameterTypes [i] = String.class;

                    } catch (Exception e) {
                        String value = p.substring (((parseAsIndex >= 0) ? parseAsIndex + 3 : 0), p.length ());
                        parameterObjects [i] = value;
                        parameterTypes [i] = String.class;
                    }
                }
                setParameters (parameterObjects);
                setParameterTypes (parameterTypes);
            }
            parameters = null;
            if (string.length () != 0) {
                if (string.charAt (0) != '.') throw new IllegalArgumentException ();

                setNext (new MethodDescriptor (string.substring (1).trim ()));
            }
            if (getName () != null) setName (getName ().intern ());

        }

        private Class getParameterType (String parameter) {
            int startIndex = parameter.indexOf ("[");
            int endIndex = parameter.indexOf ("]");
            if (startIndex == - 1 || endIndex == - 1) throw new IllegalArgumentException ();

            String parameterTypeString = parameter.substring (startIndex + 1, endIndex).trim ();
            endIndex = parameterTypeString.indexOf ('/');
            if (endIndex == - 1 || endIndex == parameterTypeString.length () - 1) throw new IllegalArgumentException ();

            String parameterPluginID = parameterTypeString.substring (0, endIndex).trim ();
            String parameterClassName = parameterTypeString.substring (endIndex + 1);
            Class clazz = loadClass (parameterClassName, parameterPluginID);
            if (clazz == null) clazz = Object.class;

            return clazz;
        }

        private String parsePluginID (String string) {
            int index = string.indexOf ('/');
            if (index == - 1) throw new IllegalArgumentException ();

            pluginID = string.substring (0, index).trim ();
            return string.substring (index + 1);
        }

        private String parseClassName (String string) {
            int index = string.indexOf ('(');
            if (index == - 1) throw new IllegalArgumentException ();

            index = string.lastIndexOf ('.', index);
            if (index == - 1) throw new IllegalArgumentException ();

            className = string.substring (0, index).trim ();
            return string.substring (index + 1);
        }

        public String getPluginID () {
            return pluginID;
        }

        public String getClassName () {
            return className;
        }

    }

    private static class ValueDescriptor {
        private Set valueLiterals;
        private Set notValueLiterals;
        private List valueObjects;
        private List notValueObjects;

        public ValueDescriptor (IConfigurationElement configElement) {
            valueLiterals = new HashSet ();
            String s = configElement.getAttribute (VALUE);
            if (s != null) parseValueLiteralString (s, valueLiterals);

            notValueLiterals = new HashSet ();
            s = configElement.getAttribute (NOT_VALUE);
            if (s != null) parseValueLiteralString (s, notValueLiterals);

            IConfigurationElement [] valueConfigs = configElement.getChildren (VALUE);
            valueObjects = new ArrayList (valueConfigs.length);
            for (int i = 0;
            i < valueConfigs.length; i ++) valueObjects.add (new ObjectDescriptor (valueConfigs [i]));

            IConfigurationElement [] notValueConfigs = configElement.getChildren (NOT_VALUE);
            notValueObjects = new ArrayList (notValueConfigs.length);
            for (int i = 0;
            i < notValueConfigs.length; i ++) notValueObjects.add (new ObjectDescriptor (notValueConfigs [i]));

        }

        private void parseValueLiteralString (String s, Set list) {
            int start = 0;
            int end = s.indexOf (',');
            while (end != - 1) {
                if (s.charAt (end - 1) == '\\') {
                    s = s.substring (0, end - 1) + s.substring (end);
                    end = s.indexOf (',', end);
                    continue;
                }
                list.add (s.substring (start, end).trim ().intern ());
                start = end + 1;
                end = s.indexOf (',', start);
            }
            list.add (s.substring (start).trim ().intern ());
        }

        public boolean sameAs (Object object) {
            if (! valueLiterals.isEmpty ()) {
                if (! valueLiterals.contains (object.toString ())) return false;

            }
            if (! notValueLiterals.isEmpty ()) {
                if (notValueLiterals.contains (object.toString ())) return false;

            }
            if (! valueObjects.isEmpty ()) {
                if (! isObjectinList (object, valueObjects)) return false;

            }
            if (! notValueObjects.isEmpty ()) {
                if (isObjectinList (object, notValueObjects)) return false;

            }
            return true;
        }

        private boolean isObjectinList (Object object, List list) {
            Iterator i = list.iterator ();
            while (i.hasNext ()) {
                if (((ObjectDescriptor) i.next ()).sameAs (object)) return true;

            }
            return false;
        }

    }

    private static class MethodValueEntry {
        public MethodDescriptor method;
        public ValueDescriptor value;

        public MethodValueEntry (MethodDescriptor method, ValueDescriptor value) {
            super ();
            this.method = method;
            this.value = value;
        }

    }

    protected static List getObjectList (String objectsIds, Map objectMap, IConfigurationElement configElement) {
        if (objectsIds == null) return null;

        StringTokenizer ids = new StringTokenizer (objectsIds.trim (), ",");
        if (! ids.hasMoreTokens ()) return null;

        List objectList = new ArrayList ();
        while (ids.hasMoreTokens ()) {
            String objectId = ids.nextToken ().trim ();
            Object objectVal = objectMap.get (objectId);
            if (objectVal != null) objectList.add (objectVal);
            else {
                Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.SERVICE_FAILURE, configElement.getDeclaringExtension ().getContributor ().getName () + ".plugin.xml extension [" + configElement.getDeclaringExtension ().getExtensionPointUniqueIdentifier () + "]: object id (" + objectId + ") is not in the list " + objectMap.keySet ());
            }
        }
        return objectList;
    }

    protected static Set getStrings (String s) {
        if (s == null) return null;

        Set stringList = new HashSet ();
        StringTokenizer ids = new StringTokenizer (s.trim (), ",");
        while (ids.hasMoreTokens ()) {
            stringList.add (ids.nextToken ().trim ());
        }
        return stringList.isEmpty () ? null : stringList;
    }

    protected static boolean objectMatches (Object object, List objects) {
        if (object != null) {
            for (Iterator i = objects.iterator ();
            i.hasNext ();) {
                ObjectDescriptor desc = (ObjectDescriptor) i.next ();
                if (desc.sameAs (object)) return true;

            }
        }
        return false;
    }

    protected static Class loadClass (String className, String pluginId) {
        StringBuffer keyStringBuf = new StringBuffer (className.length () + pluginId.length () + 2);
        keyStringBuf.append (pluginId);
        keyStringBuf.append ('.');
        keyStringBuf.append (className);
        String keyString = keyStringBuf.toString ();
        WeakReference ref = (WeakReference) successLookupTable.get (keyString);
        Class found = (ref != null) ? (Class) ref.get () : null;
        if (found == null) {
            if (ref != null) successLookupTable.remove (keyString);

            if (! failureLookupTable.contains (keyString)) {
                try {
                    Bundle bundle = getPluginBundle (pluginId);
                    if (bundle != null) {
                        found = bundle.loadClass (className);
                        successLookupTable.put (keyString, new WeakReference (found));
                    } else {
                        failureLookupTable.add (keyString);
                    }
                } catch (ClassNotFoundException e) {
                    failureLookupTable.add (keyString);
                }
            }
        }
        return found;
    }

    protected static Bundle getPluginBundle (String pluginId) {
        Bundle bundle = Platform.getBundle (pluginId);
        if (null != bundle && bundle.getState () == org.osgi.framework.Bundle.ACTIVE) return bundle;

        return null;
    }

    protected static boolean isAssignableTo (Class clazz, String className) {
        if (clazz == null) return false;

        if (contains (isNotAssignableTable, clazz, className)) {
            return false;
        }
        if (contains (isAssignableTable, clazz, className)) {
            return true;
        }
        boolean result = isAssignableToNoCache (clazz, className);
        if (result) {
            add (isAssignableTable, clazz, className);
        } else {
            add (isNotAssignableTable, clazz, className);
        }
        return result;
    }

    private static boolean isAssignableToNoCache (Class clazz, String className) {
        if (clazz.getName ().equals (className)) return true;

        Class [] interfaces = clazz.getInterfaces ();
        for (int i = 0;
        i < interfaces.length; i ++) {
            if (checkInterfaceHierarchy (interfaces [i], className)) return true;

        }
        return isAssignableTo (clazz.getSuperclass (), className);
    }

    private static Map successLookupTable = new HashMap ();
    private static Set failureLookupTable = new HashSet ();

    protected static Object getAdapter (Object object, String className, String pluginId) {
        if (! (object instanceof IAdaptable)) return null;

        if (pluginId != null) {
            Class theClass = loadClass (className, pluginId);
            return theClass != null ? ((IAdaptable) object).getAdapter (theClass) : null;
        }
        return null;
    }

    protected static Object invokeMethod (MethodDescriptor methodDescriptor, Object object) {
        String methodSignature = null;
        Class clazz = null;
        try {
            if (methodDescriptor == null || object == null) return null;

            methodSignature = methodDescriptor.getSignature ();
            clazz = object.getClass ();
            if (passiveClasses.contains (clazz, methodSignature)) return null;

            Method method = classToMethodSignatureToMethodCach.getMethod (clazz, methodSignature);
            if (method == null) {
                method = clazz.getMethod (methodDescriptor.getName (), methodDescriptor.getParameterTypes ());
                classToMethodSignatureToMethodCach.addMethod (clazz, methodSignature, method);
            }
            Object valueObj = method.invoke (object, methodDescriptor.getParameters ());
            if (methodDescriptor.getNext () == null) return valueObj == null ? NULL : valueObj;

            return invokeMethod (methodDescriptor.getNext (), valueObj);
        } catch (Exception e) {
            passiveClasses.addMethod (clazz, methodSignature);
            return null;
        }
    }

    protected static Object invokeStaticMethod (StaticMethodDescriptor methodDescriptor, Object object) {
        try {
            if (methodDescriptor == null) return null;

            Object [] valuesCopy = null;
            if (methodDescriptor.getParameters () != null) {
                valuesCopy = (Object []) methodDescriptor.getParameters ().clone ();
                for (int i = 0;
                i < valuesCopy.length; i ++) {
                    if (valuesCopy [i].equals (contextParam)) {
                        valuesCopy [i] = object;
                    }
                }
            }
            Method method = getStaticMethod (methodDescriptor);
            Object valueObj = method.invoke (object, valuesCopy);
            if (methodDescriptor.getNext () == null) return valueObj == null ? NULL : valueObj;

            return invokeMethod (methodDescriptor.getNext (), valueObj);
        } catch (Exception e) {
            return null;
        }
    }

    private static Method getStaticMethod (StaticMethodDescriptor staticMethodDescriptor) {
        Class theClass = loadClass (staticMethodDescriptor.getClassName (), staticMethodDescriptor.getPluginID ());
        if (theClass == null) return null;

        Method theMethod = null;
        try {
            String methodSignature = staticMethodDescriptor.getSignature ();
            theMethod = classToMethodSignatureToMethodCach.getMethod (theClass, methodSignature);
            if (theMethod == null) {
                theMethod = theClass.getMethod (staticMethodDescriptor.getName (), staticMethodDescriptor.getParameterTypes ());
                classToMethodSignatureToMethodCach.addMethod (theClass, methodSignature, theMethod);
            }
        } catch (SecurityException e) {
        } catch (NoSuchMethodException e) {
        }
        return theMethod;
    }

    private static boolean checkInterfaceHierarchy (Class interfaceToCheck, String className) {
        if (contains (isNotAssignableTable, interfaceToCheck, className)) {
            return false;
        }
        if (contains (isAssignableTable, interfaceToCheck, className)) {
            return true;
        }
        boolean result = checkInterfaceHierarchyNoCache (interfaceToCheck, className);
        if (result) {
            add (isAssignableTable, interfaceToCheck, className);
        } else {
            add (isNotAssignableTable, interfaceToCheck, className);
        }
        return result;
    }

    private static boolean checkInterfaceHierarchyNoCache (Class interfaceToCheck, String className) {
        if (interfaceToCheck.getName ().equals (className)) return true;

        Class [] superInterfaces = interfaceToCheck.getInterfaces ();
        for (int i = 0;
        i < superInterfaces.length; i ++) {
            if (checkInterfaceHierarchy (superInterfaces [i], className)) return true;

        }
        return false;
    }

    private static boolean contains (Map map, Object key, String value) {
        boolean result = false;
        Object val = map.get (key);
        if (val != null) {
            Set values = (Set) val;
            result = values.contains (value);
        }
        return result;
    }

    private static void add (Map map, Object key, String value) {
        Set values = (Set) map.get (key);
        if (values == null) {
            values = new HashSet ();
            map.put (key, values);
        }
        values.add (value);
    }

}

