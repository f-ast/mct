package org.eclipse.gmf.internal.graphdef.codegen.ui;

import java.io.IOException;

import java.util.ArrayList;

import java.util.Iterator;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.Status;

import org.eclipse.emf.common.util.TreeIterator;

import org.eclipse.emf.common.util.URI;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.resource.Resource;

import org.eclipse.emf.ecore.resource.ResourceSet;

import org.eclipse.gmf.gmfgraph.Canvas;

import org.eclipse.gmf.gmfgraph.FigureGallery;

import org.eclipse.gmf.gmfgraph.GMFGraphPackage;

import org.eclipse.gmf.graphdef.codegen.StandaloneGenerator.Processor;

import org.eclipse.gmf.internal.graphdef.codegen.CanvasProcessor;

import org.eclipse.gmf.internal.graphdef.codegen.GalleryMirrorProcessor;

import org.eclipse.gmf.internal.graphdef.codegen.GalleryProcessor;

class ConverterOutcome {
    private final ConverterOptions myOptions;
    private Processor myProcessor;
    private final Resource [] myInput;

    public ConverterOutcome (ConverterOptions options, Resource [] input) {
        myOptions = options;
        myInput = input;
    }

    public IStatus checkInputAgainstOptions () {
        if (myOptions.needMirroredCanvas) {
            Canvas [] c = findCanvases (myInput);
            if (c.length == 0) {
                return newError ("Need canvas instance", null);
            } else if (c.length > 1) {
                return newError ("Need exactly one canvas instance", null);
            }

        } else if (myOptions.needMirroredGalleries) {
            FigureGallery [] figures = findFigures (myInput);
            if (figures.length == 0) {
                return newError ("Need at least one figure gallery", null);
            }
        }

        return Status.OK_STATUS;
    }

    public Processor getProcessor () {
        if (myProcessor == null) {
            myProcessor = createProcessor ();
        }
        return myProcessor;
    }

    private Processor createProcessor () {
        if (myOptions.needMirroredCanvas) {
            return new CanvasProcessor (inputAsCanvas ());
        } else if (myOptions.needMirroredGalleries) {
            return new GalleryMirrorProcessor (inputAsGalleries ());
        } else {
            return new GalleryProcessor (inputAsGalleries ());
        }

    }

    private FigureGallery [] inputAsGalleries () {
        return null;
    }

    private Canvas inputAsCanvas () {
        return (Canvas) myInput [0].getContents ().get (0);
    }

    public IStatus createResources (ResourceSet rs, URI galleryResourceURI, URI mirroredCanvasURI) {
        assert rs != null && galleryResourceURI != null && mirroredCanvasURI != null;
        Resource canvasResource = null;
        Resource galleryResource = null;
        if (myOptions.needMirroredCanvas) {
            Canvas mirror = ((CanvasProcessor) getProcessor ()).getOutcome ();
            canvasResource = rs.createResource (mirroredCanvasURI);
            canvasResource.getContents ().add (mirror);
            if (myOptions.needMirroredGalleries && myOptions.separateMirrorFiles) {
                galleryResource = rs.createResource (galleryResourceURI);
                galleryResource.getContents ().addAll (mirror.getFigures ());
            }
        } else if (myOptions.needMirroredGalleries) {
            galleryResource = rs.createResource (galleryResourceURI);
            GalleryMirrorProcessor processor = (GalleryMirrorProcessor) getProcessor ();
            galleryResource.getContents ().add (processor.convertFigureGallery ());
        }

        try {
            if (galleryResource != null) {
                galleryResource.save (null);
            }
            if (canvasResource != null) {
                canvasResource.save (null);
            }
        } catch (IOException ex) {
            return newError (ex.getMessage (), ex);
        }
        return Status.OK_STATUS;
    }

    private static Status newError (String message, Exception ex) {
        return new Status (IStatus.ERROR, "org.eclipse.gmf.graphdef.codegen.ui", 0, message, ex);
    }

    private static FigureGallery [] findFigures (Resource [] resources) {
        ArrayList < FigureGallery > rv = new ArrayList < FigureGallery > ();
        for (int i = 0;
        i < resources.length; i ++) {
            for (TreeIterator it = resources [i].getAllContents ();
            it.hasNext ();) {
                EObject next = (EObject) it.next ();
                if (next.eClass ().getClassifierID () == GMFGraphPackage.FIGURE_GALLERY) {
                    rv.add ((FigureGallery) next);
                    it.prune ();
                } else if (next.eClass ().getClassifierID () != GMFGraphPackage.CANVAS) {
                    it.prune ();
                }

            }
        }
        return rv.toArray (new FigureGallery [rv.size ()]);
    }

    private static Canvas [] findCanvases (Resource [] resources) {
        ArrayList < Canvas > rv = new ArrayList < Canvas > ();
        for (int i = 0;
        i < resources.length; i ++) {
            for (Iterator it = resources [i].getContents ().iterator ();
            it.hasNext ();) {
                EObject next = (EObject) it.next ();
                if (next.eClass ().getClassifierID () == GMFGraphPackage.CANVAS) {
                    rv.add ((Canvas) next);
                }
            }
        }
        return rv.toArray (new Canvas [rv.size ()]);
    }

}

