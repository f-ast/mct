package org.eclipse.gmf.runtime.diagram.ui.printing.internal.util;

import java.util.Collection;

import java.util.Iterator;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.SWTGraphics;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gef.LayerConstants;

import org.eclipse.gef.RootEditPart;

import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;

import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;

import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;

import org.eclipse.gmf.runtime.diagram.ui.editparts.IDiagramPreferenceSupport;

import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.PageBreakEditPart;

import org.eclipse.gmf.runtime.diagram.ui.internal.figures.PageBreaksFigure;

import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper;

import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper.PageMargins;

import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;

import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;

import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.MapModeGraphics;

import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.PrinterGraphics;

import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.gmf.runtime.notation.Diagram;

import org.eclipse.jface.preference.IPreferenceStore;

import org.eclipse.jface.resource.JFaceResources;

import org.eclipse.jface.util.Assert;

import org.eclipse.swt.SWT;

import org.eclipse.swt.graphics.Font;

import org.eclipse.swt.graphics.FontData;

import org.eclipse.swt.graphics.GC;

import org.eclipse.swt.graphics.Image;

import org.eclipse.swt.graphics.Point;

import org.eclipse.swt.printing.Printer;

import org.eclipse.swt.widgets.Display;

import org.eclipse.ui.PlatformUI;

public class DiagramPrinter implements Runnable {
    protected Printer printer;
    private Point display_dpi;
    private boolean isScaledPercent = false;
    private int rows = 1;
    private int columns = 1;
    private boolean printRangePageSelection = false;
    private int pageFrom = 1, pageTo = 1;
    private GC gc;
    private Graphics swtGraphics;
    private Graphics graphics;
    private PrinterGraphics printerGraphics;
    protected Point printerOffset;
    protected Rectangle logicalClientArea;
    private float userScale;
    protected Collection diagrams;
    private Point translated = null;
    private PreferencesHint preferencesHint;
    private IMapMode mm;

    public DiagramPrinter (PreferencesHint preferencesHint, IMapMode mm) {
        super ();
        this.preferencesHint = preferencesHint;
        this.mm = mm;
    }

    public DiagramPrinter (PreferencesHint preferencesHint) {
        this (preferencesHint, MapModeUtil.getMapMode ());
    }

    protected IMapMode getMapMode () {
        return mm;
    }

    public void setColumns (int columns) {
        this.columns = columns;
    }

    public void setDiagrams (Collection diagrams) {
        this.diagrams = diagrams;
    }

    public void setDisplayDPI (Point display_dpi) {
        this.display_dpi = new Point (display_dpi.x, display_dpi.y);
    }

    public void setPrinter (Printer printer) {
        this.printer = printer;
    }

    public void setPrintRangePageSelection (boolean isPrintRangePageSelected) {
        this.printRangePageSelection = isPrintRangePageSelected;
    }

    public void setPrintRangePages (int pageFrom, int pageTo) {
        assert pageFrom > 0 : "From page in print range page selection must be bigger than zero.";
        assert (pageTo > 0 && pageTo >= pageFrom) : "To page in print range page selection must be bigger than zero and from page.";
        this.pageFrom = pageFrom;
        this.pageTo = pageTo;
    }

    public void setRows (int rows) {
        this.rows = rows;
    }

    public void setScaledPercent (int scalePercent) {
        this.isScaledPercent = true;
        this.userScale = (scalePercent) / 100.0f;
    }

    public void run () {
        assert null != printer : "printer must be set";
        if (! (printer.startJob ("Printing"))) {
            return;
        }
        assert diagrams != null;
        Iterator it = diagrams.iterator ();
        while (it.hasNext ()) {
            Object obj = it.next ();
            Assert.isTrue (obj instanceof Diagram);
            DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart ((Diagram) obj, null);
            RootEditPart rep = dgrmEP.getRoot ();
            if (rep instanceof DiagramRootEditPart) this.mm = ((DiagramRootEditPart) rep).getMapMode ();

            if (rep instanceof IDiagramPreferenceSupport) this.preferencesHint = ((IDiagramPreferenceSupport) rep).getPreferencesHint ();

            initialize ();
            boolean loadedPreferences = PrintHelper.initializePreferences (dgrmEP, preferencesHint);
            IPreferenceStore pref = null;
            assert dgrmEP.getViewer () instanceof DiagramGraphicalViewer;
            pref = ((DiagramGraphicalViewer) dgrmEP.getViewer ()).getWorkspaceViewerPreferenceStore ();
            if (pref.getBoolean (WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS)) {
                if (dgrmEP.getDiagramPreferencesHint ().getPreferenceStore () != null) pref = (IPreferenceStore) dgrmEP.getDiagramPreferencesHint ().getPreferenceStore ();

            }
            doPrintDiagram (dgrmEP, loadedPreferences, pref);
            dispose ();
        }
        printer.endJob ();
    }

    private int calculateRowFromPage (int pageNum, int totalNumColumns) {
        int row = pageNum / totalNumColumns;
        if (pageNum % totalNumColumns != 0) row ++;

        return row;
    }

    private int calculateColumnFromPage (int pageNum, int totalNumColumns, int cRow) {
        int col = pageNum - ((cRow - 1) * totalNumColumns);
        return col;
    }

    private org.eclipse.draw2d.geometry.Point getPageCount (DiagramEditPart dgrmEP, Rectangle figureBounds, org.eclipse.draw2d.geometry.Point pageSize, boolean applyUserScale) {
        RootEditPart rootEditPart = dgrmEP.getRoot ();
        if (rootEditPart instanceof DiagramRootEditPart) {
            DiagramRootEditPart diagramRootEditPart = (DiagramRootEditPart) rootEditPart;
            PageBreakEditPart pageBreakEditPart = diagramRootEditPart.getPageBreakEditPart ();
            float fNumCols = ((PageBreaksFigure) pageBreakEditPart.getFigure ()).getPageCount ().y * (applyUserScale ? userScale : 1);
            float fNumRows = ((PageBreaksFigure) pageBreakEditPart.getFigure ()).getPageCount ().x * (applyUserScale ? userScale : 1);
            int numCols = (int) Math.ceil (fNumCols);
            int numRows = (int) Math.ceil (fNumRows);
            return new org.eclipse.draw2d.geometry.Point (numCols, numRows);
        } else {
            float fNumRows = (figureBounds.height * (applyUserScale ? userScale : 1)) / pageSize.y;
            int numRows = (int) Math.ceil (fNumRows);
            float fNumCols = (figureBounds.width * (applyUserScale ? userScale : 1)) / pageSize.x;
            int numCols = (int) Math.ceil (fNumCols);
            return new org.eclipse.draw2d.geometry.Point (numCols, numRows);
        }
    }

    private void doPrintDiagram (DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {
        this.graphics.pushState ();
        if (isScaledPercent) {
            printToScale (dgrmEP, loadedPreferences, fPreferences);
        } else {
            printToPages (dgrmEP, loadedPreferences, fPreferences);
        }
        this.graphics.popState ();
    }

    private void initialize () {
        assert null != printer : "printer must be set";
        int style = PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getShell ().getStyle ();
        if ((style & SWT.MIRRORED) != 0) this.gc = new GC (printer, SWT.RIGHT_TO_LEFT);
        else this.gc = new GC (printer);

        gc.setXORMode (false);
        this.swtGraphics = new SWTGraphics (gc);
        this.printerGraphics = createPrinterGraphics (swtGraphics);
        this.graphics = createMapModeGraphics (printerGraphics);
        this.graphics.scale (computePrinterDisplayScale ());
        this.logicalClientArea = this.graphics.getClip (new Rectangle (this.printer.getClientArea ()));
    }

    protected Point getPrinterOffset () {
        if (printerOffset == null) {
            int offsetX = this.printer.getBounds ().width - this.printer.getClientArea ().width;
            int offsetY = this.printer.getBounds ().height - this.printer.getClientArea ().height;
            offsetX = (int) (getMapMode ().DPtoLP ((int) (offsetX / 2.0f * display_dpi.x / printer.getDPI ().x)) / userScale);
            offsetY = (int) (getMapMode ().DPtoLP ((int) (offsetY / 2.0f * display_dpi.y / printer.getDPI ().y)) / userScale);
            printerOffset = new Point (offsetX, offsetY);
        }
        return printerOffset;
    }

    protected void printToScale (DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {
        assert null != printer : "printer must be set";
        Rectangle figureBounds = PrintHelper.getPageBreakBounds (dgrmEP, loadedPreferences);
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize (fPreferences, false, getMapMode ());
        translated = new Point ((int) (- figureBounds.x * userScale), (int) (- figureBounds.y * userScale));
        int numRows = 0, numCols = 0;
        PageMargins margins = PageInfoHelper.getPageMargins (fPreferences, getMapMode ());
        adjustMargins (margins, userScale, getPrinterOffset ());
        GC gc_ = new GC (Display.getDefault (), this.gc.getStyle ());
        gc_.setAntialias (this.gc.getAntialias ());
        FontData fontData = JFaceResources.getDefaultFont ().getFontData () [0];
        Font font = new Font (printer, fontData);
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount (dgrmEP, figureBounds, pageSize, true);
        numCols = pageCount.x;
        numRows = pageCount.y;
        int row = 1, col = 1, finalRow = 0, finalColumn = 0;
        if (this.printRangePageSelection) {
            row = calculateRowFromPage (this.pageFrom, numCols);
            col = calculateColumnFromPage (this.pageFrom, numCols, row);
            finalRow = calculateRowFromPage (this.pageTo, numCols);
            finalColumn = calculateColumnFromPage (this.pageTo, numCols, finalRow);
        }
        try {
            for (; row <= numRows; row ++) {
                for (; col <= numCols; col ++) {
                    printer.startPage ();
                    drawPage (gc_, dgrmEP, fPreferences, figureBounds, margins, font, row, col);
                    printer.endPage ();
                    if (row == finalRow && col == finalColumn && this.printRangePageSelection == true) break;

                }
                if (row == finalRow && col == finalColumn && this.printRangePageSelection == true) break;

                col = 1;
            }
        } finally {
            font.dispose ();
            gc_.dispose ();
        }
    }

    protected void drawHeaderAndFooter (GC gc_, DiagramEditPart dgrmEP, Rectangle figureBounds, Font font, int rowIndex, int colIndex) {
        int width = this.logicalClientArea.width;
        int height = this.logicalClientArea.height;
        this.graphics.pushState ();
        this.graphics.setFont (font);
        this.graphics.scale (1.0f / userScale);
        this.graphics.translate (- translated.x, - translated.y);
        String headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString (WorkspaceViewerProperties.HEADER_PREFIX, rowIndex, colIndex, dgrmEP);
        this.graphics.drawText (headerOrFooter, getMapMode ().DPtoLP (HeaderAndFooterHelper.LEFT_MARGIN_DP) + (width - getMapMode ().DPtoLP (gc_.textExtent (headerOrFooter).x)) / 2, getMapMode ().DPtoLP (HeaderAndFooterHelper.TOP_MARGIN_DP));
        headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString (WorkspaceViewerProperties.FOOTER_PREFIX, rowIndex, colIndex, dgrmEP);
        this.graphics.drawText (headerOrFooter, getMapMode ().DPtoLP (HeaderAndFooterHelper.LEFT_MARGIN_DP) + (width - getMapMode ().DPtoLP (gc_.textExtent (headerOrFooter).x)) / 2, height - getMapMode ().DPtoLP (HeaderAndFooterHelper.BOTTOM_MARGIN_DP));
        this.graphics.popState ();
    }

    protected void drawPage (GC gc_, DiagramEditPart dgrmEP, IPreferenceStore fPreferences, Rectangle figureBounds, PageMargins margins, Font font, int rowIndex, int colIndex) {
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize (fPreferences, false, getMapMode ());
        boolean rtlEnabled = ((this.gc.getStyle () & SWT.MIRRORED) != 0);
        int width = pageSize.x, height = pageSize.y;
        Image image = new Image (Display.getDefault (), getMapMode ().LPtoDP (pageSize.x), getMapMode ().LPtoDP (pageSize.y));
        GC imgGC = new GC (image, (rtlEnabled) ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT);
        imgGC.setXORMode (false);
        SWTGraphics sg = new SWTGraphics (imgGC);
        ScaledGraphics g1 = new ScaledGraphics (sg);
        MapModeGraphics mmg = createMapModeGraphics (g1);
        imgGC.setFont (mmg.getFont ());
        mmg.translate (translated.x, translated.y);
        mmg.scale (userScale);
        mmg.pushState ();
        int translateX = - (width * (colIndex - 1));
        int translateY = - (height * (rowIndex - 1));
        int scaledTranslateX = (int) (translateX / userScale);
        int scaledTranslateY = (int) (translateY / userScale);
        int scaledWidth = (int) (width / userScale);
        int scaledHeight = (int) (height / userScale);
        if (rtlEnabled) {
            scaledTranslateX += (margins.left * (colIndex - 1)) + (margins.right * (colIndex));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        } else {
            scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        }
        mmg.translate (scaledTranslateX, scaledTranslateY);
        Rectangle clip = new Rectangle ((scaledWidth - margins.left - margins.right) * (colIndex - 1) + figureBounds.x, (scaledHeight - margins.bottom - margins.top) * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right - margins.left, scaledHeight - margins.top - margins.bottom);
        mmg.clipRect (clip);
        dgrmEP.getLayer (LayerConstants.PRINTABLE_LAYERS).paint (mmg);
        mmg.popState ();
        this.graphics.pushState ();
        this.graphics.drawImage (image, 0, 0);
        this.graphics.popState ();
        drawHeaderAndFooter (gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
        disposeImageVars (imgGC, image, sg, g1, mmg);
    }

    protected void printToPages (DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {
        assert null != printer : "printer must be set";
        Rectangle figureBounds = PrintHelper.getPageBreakBounds (dgrmEP, loadedPreferences);
        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper.getPageSize (fPreferences, getMapMode ());
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize (fPreferences, false, getMapMode ());
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount (dgrmEP, figureBounds, pageSize, false);
        int numCols = pageCount.x;
        int numRows = pageCount.y;
        Rectangle translate = new Rectangle (Math.min (0, figureBounds.x), Math.min (0, figureBounds.y), Math.max (pageBounds.x, numCols * pageSize.x), Math.max (pageBounds.y, numRows * pageSize.y));
        int totalHeight = (this.rows * pageSize.y);
        int totalWidth = (this.columns * pageSize.x);
        float vScale = ((float) totalHeight) / ((float) (numRows * pageSize.y));
        float hScale = ((float) totalWidth) / ((float) (numCols * pageSize.x));
        this.userScale = Math.min (hScale, vScale);
        translated = new Point ((int) (- translate.x * userScale), (int) (- translate.y * userScale));
        PageMargins margins = PageInfoHelper.getPageMargins (fPreferences, getMapMode ());
        adjustMargins (margins, userScale, getPrinterOffset ());
        GC gc_ = new GC (Display.getDefault ());
        FontData fontData = JFaceResources.getDefaultFont ().getFontData () [0];
        Font font = new Font (printer, fontData);
        int row = 1, col = 1, finalRow = 0, finalColumn = 0;
        if (this.printRangePageSelection) {
            row = calculateRowFromPage (this.pageFrom, this.columns);
            col = calculateColumnFromPage (this.pageFrom, this.columns, row);
            finalRow = calculateRowFromPage (this.pageTo, this.columns);
            finalColumn = calculateColumnFromPage (this.pageTo, this.columns, finalRow);
        }
        try {
            for (; row <= rows; row ++) {
                for (; col <= columns; col ++) {
                    printer.startPage ();
                    drawPage (gc_, dgrmEP, fPreferences, translate, margins, font, row, col);
                    printer.endPage ();
                    if (row == finalRow && col == finalColumn && this.printRangePageSelection == true) break;

                }
                if (row == finalRow && col == finalColumn && this.printRangePageSelection == true) break;

                col = 1;
            }
        } finally {
            font.dispose ();
            gc_.dispose ();
        }
    }

    private float computePrinterDisplayScale () {
        assert null != printer : "printer must be set";
        assert null != display_dpi : "display_dpi must be set";
        Point dpi = printer.getDPI ();
        float scale = dpi.x / (float) display_dpi.x;
        return scale;
    }

    private void dispose () {
        if (this.graphics != null) {
            try {
                this.graphics.dispose ();
            } catch (NullPointerException e) {
            } finally {
                this.graphics = null;
            }
        }
        if (this.printerGraphics != null) {
            try {
                this.printerGraphics.dispose ();
            } catch (NullPointerException e) {
            } finally {
                this.printerGraphics = null;
            }
        }
        if (this.swtGraphics != null) {
            try {
                this.swtGraphics.dispose ();
            } catch (NullPointerException e) {
            } finally {
                this.swtGraphics = null;
            }
        }
        if (this.gc != null) {
            try {
                this.gc.dispose ();
            } catch (NullPointerException e) {
            } finally {
                this.gc = null;
            }
        }
        printerOffset = null;
    }

    private void disposeImageVars (GC imgGC, Image image, SWTGraphics sg, ScaledGraphics g1, MapModeGraphics mmg) {
        if (mmg != null) {
            try {
                mmg.dispose ();
            } catch (NullPointerException e) {
            } finally {
                mmg = null;
            }
        }
        if (g1 != null) {
            try {
                g1.dispose ();
            } catch (NullPointerException e) {
            } finally {
                g1 = null;
            }
        }
        if (sg != null) {
            try {
                sg.dispose ();
            } catch (NullPointerException e) {
            } finally {
                sg = null;
            }
        }
        if (imgGC != null) {
            try {
                imgGC.dispose ();
            } catch (NullPointerException e) {
            } finally {
                imgGC = null;
            }
        }
        if (image != null) {
            try {
                image.dispose ();
            } catch (NullPointerException e) {
            } finally {
                image = null;
            }
        }
    }

    protected MapModeGraphics createMapModeGraphics (Graphics theGraphics) {
        return new MapModeGraphics (theGraphics, getMapMode ());
    }

    protected PrinterGraphics createPrinterGraphics (Graphics theGraphics) {
        return new PrinterGraphics (theGraphics, printer, true);
    }

    protected PreferencesHint getPreferencesHint () {
        return preferencesHint;
    }

    protected void adjustMargins (PageMargins margins, float scale, Point offset) {
        margins.left /= scale;
        margins.top /= scale;
        margins.right /= scale;
        margins.bottom /= scale;
        margins.left -= offset.x;
        margins.right += offset.x;
        margins.top -= offset.y;
        margins.bottom += offset.y;
        if (margins.left < 0) margins.left = 0;

        if (margins.right < 0) margins.right = 0;

        if (margins.top < 0) margins.top = 0;

        if (margins.bottom < 0) margins.bottom = 0;

    }

}

