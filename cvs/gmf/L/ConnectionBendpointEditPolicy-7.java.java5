package org.eclipse.gmf.runtime.gef.ui.internal.editpolicies;

import java.beans.PropertyChangeEvent;

import java.beans.PropertyChangeListener;

import java.util.ArrayList;

import java.util.List;

import org.eclipse.core.runtime.Assert;

import org.eclipse.draw2d.AbsoluteBendpoint;

import org.eclipse.draw2d.AutomaticRouter;

import org.eclipse.draw2d.Bendpoint;

import org.eclipse.draw2d.BendpointLocator;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.ConnectionAnchor;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.PrecisionPoint;

import org.eclipse.draw2d.geometry.PrecisionRectangle;

import org.eclipse.gef.AccessibleHandleProvider;

import org.eclipse.gef.ConnectionEditPart;

import org.eclipse.gef.EditPart;

import org.eclipse.gef.Request;

import org.eclipse.gef.commands.Command;

import org.eclipse.gef.editpolicies.SelectionHandlesEditPolicy;

import org.eclipse.gef.handles.BendpointCreationHandle;

import org.eclipse.gef.handles.BendpointMoveHandle;

import org.eclipse.gef.requests.BendpointRequest;

import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.FeedbackConnection;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.gmf.runtime.gef.ui.internal.handles.BendpointCreationInvisibleHandle;

import org.eclipse.gmf.runtime.gef.ui.internal.handles.BendpointMoveHandleEx;

import org.eclipse.gmf.runtime.gef.ui.internal.handles.LineSegMoveInvisibleHandle;

abstract public class ConnectionBendpointEditPolicy extends SelectionHandlesEditPolicy implements PropertyChangeListener {
    private static List NULL_CONSTRAINT = new ArrayList ();
    private static final int STICKY_TOLERANCE_DP = 6;
    private LineMode lineSegMode = LineMode.OBLIQUE;
    static private class FeedbackState {
        public List originalConstraint;
        public Point ref1 = new Point ();
        public Point ref2 = new Point ();
        public boolean isDeleting = false;
        public boolean isOutsideSource = false;
        public boolean isOutsideTarget = false;
        public boolean init = false;
    }

    private FeedbackState feedbackState = null;

    private FeedbackState getFeedbackState () {
        if (feedbackState == null) {
            feedbackState = new FeedbackState ();
        }
        return feedbackState;
    }

    private boolean useRealtimeFeedback () {
        return false;
    }

    public ConnectionBendpointEditPolicy (LineMode lineSegMode) {
        super ();
        this.lineSegMode = lineSegMode;
    }

    public LineMode getLineSegMode () {
        return lineSegMode;
    }

    public void activate () {
        super.activate ();
        getConnection ().addPropertyChangeListener (Connection.PROPERTY_POINTS, this);
    }

    protected Connection createDragSourceFeedbackConnection () {
        if (useRealtimeFeedback ()) {
            return getConnection ();
        } else {
            FeedbackConnection r = new FeedbackConnection (getConnection ());
            addFeedback (r);
            return r;
        }
    }

    protected void addSelectionHandles () {
        if (handles == null) super.addSelectionHandles ();
        else {
            int count = handles.size ();
            int points = getConnection ().getPoints ().size ();
            if (count != points * 2 - 3) super.addSelectionHandles ();

        }
    }

    protected List createManualHandles () {
        List list = new ArrayList ();
        ConnectionEditPart connEP = (ConnectionEditPart) getHost ();
        PointList points = getConnection ().getPoints ();
        for (int i = 1;
        i < points.size () - 1; i ++) {
            addInvisibleCreationHandle (list, connEP, i - 1);
            list.add (new BendpointMoveHandleEx (connEP, i, new BendpointLocator (getConnection (), i)));
        }
        addInvisibleCreationHandle (list, connEP, points.size () - 2);
        return list;
    }

    protected void addInvisibleCreationHandle (List list, ConnectionEditPart connEP, int i) {
        if (getLineSegMode () != LineMode.OBLIQUE) {
            list.add (new LineSegMoveInvisibleHandle (connEP, i));
        } else {
            list.add (new BendpointCreationInvisibleHandle (connEP, i));
        }
    }

    protected List createSelectionHandles () {
        List list = new ArrayList ();
        list = createManualHandles ();
        return list;
    }

    public void deactivate () {
        getConnection ().removePropertyChangeListener (Connection.PROPERTY_POINTS, this);
        super.deactivate ();
    }

    protected void eraseConnectionFeedback (BendpointRequest request, boolean removeFeedbackFigure) {
        restoreOriginalConstraint ();
        getFeedbackState ().originalConstraint = null;
        if (removeFeedbackFigure) feedbackState = null;

    }

    public void eraseSourceFeedback (Request request) {
        if (REQ_MOVE_BENDPOINT.equals (request.getType ()) || REQ_CREATE_BENDPOINT.equals (request.getType ())) eraseConnectionFeedback ((BendpointRequest) request, true);

    }

    public Command getCommand (Request request) {
        if (REQ_MOVE_BENDPOINT.equals (request.getType ())) {
            if (getLineSegMode () != LineMode.OBLIQUE) {
                return getMoveLineSegCommand ((BendpointRequest) request);
            } else {
                if (getFeedbackState ().isDeleting) return getDeleteBendpointCommand ((BendpointRequest) request);

                return getMoveBendpointCommand ((BendpointRequest) request);
            }
        }
        if (REQ_CREATE_BENDPOINT.equals (request.getType ())) return getCreateBendpointCommand ((BendpointRequest) request);

        return null;
    }

    protected Connection getConnection () {
        return (Connection) ((ConnectionEditPart) getHost ()).getFigure ();
    }

    private Point getFirstReferencePoint () {
        return getFeedbackState ().ref1;
    }

    private Point getSecondReferencePoint () {
        return getFeedbackState ().ref2;
    }

    private boolean lineContainsPoint (Point p1, Point p2, Point p) {
        LineSeg line = new LineSeg (p1, p2);
        return line.containsPoint (p, getStickyTolerance () / 3);
    }

    public void propertyChange (PropertyChangeEvent evt) {
        if (getHost ().getSelected () != EditPart.SELECTED_NONE) {
            addSelectionHandles ();
        }
    }

    protected void restoreOriginalConstraint () {
        if (getFeedbackState ().originalConstraint != null) {
            Assert.isTrue (getFeedbackState ().originalConstraint.size () >= 2);
            getConnection ().setRoutingConstraint (getFeedbackState ().originalConstraint);
        }
    }

    protected void saveOriginalConstraint () {
        getFeedbackState ().originalConstraint = (List) getConnection ().getRoutingConstraint ();
        if (getFeedbackState ().originalConstraint == null) getFeedbackState ().originalConstraint = NULL_CONSTRAINT;

        if (getLineSegMode () != LineMode.OBLIQUE && ! getFeedbackState ().init) {
            List newConstraint = new ArrayList (getFeedbackState ().originalConstraint.size ());
            PointList pts = PointListUtilities.copyPoints (getConnection ().getPoints ());
            for (int i = 0;
            i < pts.size (); i ++) {
                Bendpoint abp = new AbsoluteBendpoint (pts.getPoint (i));
                newConstraint.add (abp);
            }
            Assert.isTrue (getFeedbackState ().originalConstraint.size () >= 2);
            getConnection ().setRoutingConstraint (newConstraint);
            getFeedbackState ().isOutsideSource = false;
            getFeedbackState ().isOutsideTarget = false;
        } else {
            int nConstraintSize = getFeedbackState ().originalConstraint.size ();
            PointList pts = getConnection ().getPoints ();
            int nPointSize = pts.size ();
            if (! getFeedbackState ().init && nConstraintSize != nPointSize) {
                while (getFeedbackState ().originalConstraint.size () > 0) {
                    getFeedbackState ().originalConstraint.remove (0);
                }
                for (int i = 0;
                i < pts.size (); i ++) {
                    Bendpoint bpNew = new AbsoluteBendpoint (pts.getPoint (i));
                    getFeedbackState ().originalConstraint.add (i, bpNew);
                }
            }
            Assert.isTrue (getFeedbackState ().originalConstraint.size () >= 2);
            getConnection ().setRoutingConstraint (new ArrayList (getFeedbackState ().originalConstraint));
        }
        getFeedbackState ().init = true;
    }

    private void setReferencePoints (BendpointRequest request) {
        if (getFeedbackState ().originalConstraint == null) {
            saveOriginalConstraint ();
        }
        List constraint = (List) getConnection ().getRoutingConstraint ();
        Bendpoint bp = (Bendpoint) constraint.get (Math.max (0, request.getIndex () - 1));
        getFeedbackState ().ref1 = bp.getLocation ();
        bp = (Bendpoint) constraint.get (Math.min (request.getIndex () + 1, constraint.size () - 1));
        getFeedbackState ().ref2 = bp.getLocation ();
    }

    private void setNewFeedbackConstraint (List constraint) {
        Assert.isTrue (constraint.size () >= 2);
        getConnection ().setRoutingConstraint (constraint);
    }

    protected void showCreateBendpointFeedback (BendpointRequest request) {
        Point p = new Point (request.getLocation ());
        List constraint;
        getConnection ().translateToRelative (p);
        Bendpoint bp = new AbsoluteBendpoint (p);
        if (getFeedbackState ().originalConstraint == null) {
            saveOriginalConstraint ();
            constraint = (List) getConnection ().getRoutingConstraint ();
            constraint.add (request.getIndex () + 1, bp);
        } else {
            constraint = (List) getConnection ().getRoutingConstraint ();
        }
        stickyStraightLineFeedback (constraint, request.getIndex () + 1, bp);
        setNewFeedbackConstraint (constraint);
    }

    protected void showDeleteBendpointFeedback (BendpointRequest request) {
        if (getFeedbackState ().originalConstraint == null) {
            saveOriginalConstraint ();
            List constraint = (List) getConnection ().getRoutingConstraint ();
            constraint.remove (request.getIndex ());
            setNewFeedbackConstraint (constraint);
        }
    }

    protected void showMoveBendpointFeedback (BendpointRequest request) {
        Point p = new Point (request.getLocation ());
        if (! getFeedbackState ().isDeleting) {
            setReferencePoints (request);
        }
        getConnection ().translateToRelative (p);
        Bendpoint bp = new AbsoluteBendpoint (p);
        if (getFeedbackState ().originalConstraint == null) {
            saveOriginalConstraint ();
        }
        if (lineContainsPoint (getFirstReferencePoint (), getSecondReferencePoint (), p)) {
            if (! getFeedbackState ().isDeleting) {
                getFeedbackState ().isDeleting = true;
                eraseConnectionFeedback (request, false);
                showDeleteBendpointFeedback (request);
            }
            return;
        }
        if (getFeedbackState ().isDeleting) {
            getFeedbackState ().isDeleting = false;
            eraseConnectionFeedback (request, false);
        }
        List constraint = (List) getConnection ().getRoutingConstraint ();
        stickyStraightLineFeedback (constraint, request.getIndex (), bp);
        setNewFeedbackConstraint (constraint);
    }

    protected void stickyStraightLineFeedback (List constraint, int nIndex, Bendpoint bp) {
        Point ptLoc = new Point (bp.getLocation ());
        int sticky_tolerance = getStickyTolerance ();
        if (nIndex > 0) {
            Point ptPrev;
            if ((nIndex - 1) == 0) {
                ptPrev = getConnection ().getSourceAnchor ().getReferencePoint ();
                getConnection ().translateToRelative (ptPrev);
            } else ptPrev = ((Bendpoint) constraint.get (nIndex - 1)).getLocation ();

            if (Math.abs (ptPrev.x - ptLoc.x) < sticky_tolerance) ptLoc.x = ptPrev.x;

            if (Math.abs (ptPrev.y - ptLoc.y) < sticky_tolerance) ptLoc.y = ptPrev.y;

        }
        if (nIndex < constraint.size () - 1) {
            Point ptNext;
            if ((nIndex + 1) == (constraint.size () - 1)) {
                ptNext = getConnection ().getTargetAnchor ().getReferencePoint ();
                getConnection ().translateToRelative (ptNext);
            } else ptNext = ((Bendpoint) constraint.get (nIndex + 1)).getLocation ();

            if (Math.abs (ptNext.x - ptLoc.x) < sticky_tolerance) ptLoc.x = ptNext.x;

            if (Math.abs (ptNext.y - ptLoc.y) < sticky_tolerance) ptLoc.y = ptNext.y;

        }
        if (! ptLoc.equals (bp.getLocation ())) {
            Bendpoint bpNew = new AbsoluteBendpoint (ptLoc);
            constraint.set (nIndex, bpNew);
        } else {
            constraint.set (nIndex, bp);
        }
    }

    private int getStickyTolerance () {
        int sticky_tolerance = MapModeUtil.getMapMode (getConnection ()).DPtoLP (STICKY_TOLERANCE_DP);
        return sticky_tolerance;
    }

    public void showSourceFeedback (Request request) {
        if (getLineSegMode () != LineMode.OBLIQUE) {
            if (REQ_CREATE_BENDPOINT.equals (request.getType ())) {
                showMoveLineSegFeedback ((BendpointRequest) request);
            } else if (REQ_MOVE_BENDPOINT.equals (request.getType ())) {
                showMoveOrthogonalBenspointFeedback ((BendpointRequest) request);
            }

        } else {
            if (REQ_MOVE_BENDPOINT.equals (request.getType ())) showMoveBendpointFeedback ((BendpointRequest) request);
            else if (REQ_CREATE_BENDPOINT.equals (request.getType ())) showCreateBendpointFeedback ((BendpointRequest) request);

        }
        super.showSourceFeedback (request);
    }

    abstract protected Command getBendpointsChangedCommand (BendpointRequest request);

    protected Command getCreateBendpointCommand (BendpointRequest request) {
        return getBendpointsChangedCommand (request);
    }

    protected Command getMoveBendpointCommand (BendpointRequest request) {
        return getBendpointsChangedCommand (request);
    }

    protected Command getDeleteBendpointCommand (BendpointRequest request) {
        return getBendpointsChangedCommand (request);
    }

    protected final LineSeg getLineSeg (List bendPoints, int nIndex) {
        Point pt1 = new Point (((Bendpoint) bendPoints.get (nIndex - 1)).getLocation ());
        Point pt2 = new Point (((Bendpoint) bendPoints.get (nIndex)).getLocation ());
        return new LineSeg (pt1, pt2);
    }

    protected void setLineSeg (List bendPoints, int nIndex, LineSeg newLine) {
        Bendpoint bp1 = new AbsoluteBendpoint (newLine.getOrigin ());
        Bendpoint bp2 = new AbsoluteBendpoint (newLine.getTerminus ());
        bendPoints.set (nIndex - 1, bp1);
        bendPoints.set (nIndex, bp2);
    }

    protected Command getMoveLineSegCommand (BendpointRequest request) {
        return getBendpointsChangedCommand (request);
    }

    protected boolean lineOutsideSource (LineSeg line) {
        PrecisionRectangle startRect = new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (getConnection ().getSourceAnchor ().getOwner ()));
        getConnection ().getSourceAnchor ().getOwner ().translateToAbsolute (startRect);
        if (getLineSegMode ().equals (LineMode.ORTHOGONAL_CONSTRAINED)) {
            if (line.isHorizontal ()) {
                startRect.shrink (0, 2);
            } else {
                startRect.shrink (2, 0);
            }
        }
        getConnection ().translateToRelative (startRect);
        if (! startRect.expand (0.000001, 0.000001).contains (new PrecisionPoint (line.getOrigin ()))) {
            return true;
        }
        return false;
    }

    protected boolean lineOutsideTarget (LineSeg line) {
        PrecisionRectangle endRect = new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (getConnection ().getTargetAnchor ().getOwner ()));
        getConnection ().getTargetAnchor ().getOwner ().translateToAbsolute (endRect);
        if (getLineSegMode ().equals (LineMode.ORTHOGONAL_CONSTRAINED)) {
            if (line.isHorizontal ()) {
                endRect.shrink (0, 2);
            } else {
                endRect.shrink (2, 0);
            }
        }
        getConnection ().translateToRelative (endRect);
        if (! endRect.expand (0.00001, 0.00001).contains (new PrecisionPoint (line.getTerminus ()))) {
            return true;
        }
        return false;
    }

    protected void removeOutsideSourceFeedback (List constraint) {
        constraint.remove (0);
    }

    protected void removeOutsideTargetFeedback (List constraint) {
        constraint.remove (constraint.size () - 1);
    }

    private void showMoveOrthogonalBenspointFeedback (BendpointRequest request) {
        if (getFeedbackState ().originalConstraint == null) {
            saveOriginalConstraint ();
        }
        Point ptLoc = new Point (request.getLocation ());
        List constraint = (List) getConnection ().getRoutingConstraint ();
        getConnection ().translateToRelative (ptLoc);
        int index = getFeedbackState ().isOutsideSource ? request.getIndex () + 1 : request.getIndex ();
        Point previous = ((Bendpoint) constraint.get (index - 1)).getLocation ();
        Point moving = ((Bendpoint) constraint.get (index)).getLocation ();
        Point next = ((Bendpoint) constraint.get (index + 1)).getLocation ();
        LineSeg originalFirst = new LineSeg (previous.getCopy (), moving.getCopy ());
        LineSeg originalSecond = new LineSeg (moving.getCopy (), next.getCopy ());
        Dimension diff = ptLoc.getDifference (moving);
        if (originalFirst.isHorizontal ()) {
            previous.y += diff.height;
            next.x += diff.width;
        } else {
            previous.x += diff.width;
            next.y += diff.height;
        }
        LineSeg movedFirst = new LineSeg (previous, ptLoc.getCopy ());
        LineSeg movedSecond = new LineSeg (ptLoc.getCopy (), next);
        index = adjustOutsideBoundsLineFeedback (movedFirst, index - 1, constraint, originalFirst);
        constraint.set (index, new AbsoluteBendpoint (movedFirst.getOrigin ()));
        constraint.set (index + 1, new AbsoluteBendpoint (movedFirst.getTerminus ()));
        index = adjustOutsideBoundsLineFeedback (movedSecond, index + 1, constraint, originalSecond);
        constraint.set (index + 1, new AbsoluteBendpoint (movedSecond.getTerminus ()));
        getConnection ().setRoutingConstraint (constraint);
    }

    protected void showMoveLineSegFeedback (BendpointRequest request) {
        if (getFeedbackState ().originalConstraint == null) {
            saveOriginalConstraint ();
        }
        Point ptLoc = new Point (request.getLocation ());
        List constraint = (List) getConnection ().getRoutingConstraint ();
        getConnection ().translateToRelative (ptLoc);
        int index = getFeedbackState ().isOutsideSource ? request.getIndex () + 1 : request.getIndex ();
        LineSeg moveLine = getLineSeg (constraint, index + 1);
        LineSeg newLine = moveLine.getParallelLineSegThroughPoint (ptLoc);
        index = adjustOutsideBoundsLineFeedback (newLine, index, constraint, moveLine);
        setLineSeg (constraint, index + 1, newLine);
        getConnection ().setRoutingConstraint (constraint);
    }

    private int adjustOutsideBoundsLineFeedback (LineSeg newLine, int index, List constraint, LineSeg moveLine) {
        if (getLineSegMode ().equals (LineMode.ORTHOGONAL_CONSTRAINED)) {
            if ((index == 0 && lineOutsideSource (newLine)) || ((index + 1 == constraint.size () - 1) && lineOutsideTarget (newLine))) {
                newLine.setOrigin (moveLine.getOrigin ());
                newLine.setTerminus (moveLine.getTerminus ());
            }
            return index;
        }
        boolean bRemoveSource = false;
        boolean bRemoveTarget = false;
        boolean bSetNewSource = false;
        boolean bSetNewTarget = false;
        if (index == 0 && lineOutsideSource (newLine)) {
            if (! getFeedbackState ().isOutsideSource) {
                getFeedbackState ().isOutsideSource = true;
                bSetNewSource = true;
            }
        } else if (index == 1 && getFeedbackState ().isOutsideSource && ! lineOutsideSource (newLine)) {
            getFeedbackState ().isOutsideSource = false;
            bRemoveSource = true;
        }

        int checkTargetIndex = index + 1 + (getFeedbackState ().isOutsideTarget ? 1 : 0);
        if ((checkTargetIndex == constraint.size () - 1) && lineOutsideTarget (newLine)) {
            if (! getFeedbackState ().isOutsideTarget) {
                getFeedbackState ().isOutsideTarget = true;
                bSetNewTarget = true;
            }
        } else if (checkTargetIndex == constraint.size () - 2 && getFeedbackState ().isOutsideTarget && ! lineOutsideTarget (newLine)) {
            getFeedbackState ().isOutsideTarget = false;
            bRemoveTarget = true;
        }

        if (bRemoveSource) {
            removeOutsideSourceFeedback (constraint);
            index --;
        }
        if (bRemoveTarget) {
            removeOutsideTargetFeedback (constraint);
        }
        if (bSetNewSource) {
            showOutsideSourceFeedback (newLine, moveLine, constraint);
            index ++;
        }
        if (bSetNewTarget) {
            showOutsideTargetFeedback (newLine, moveLine, constraint);
        }
        return index;
    }

    private void showOutsideSourceFeedback (LineSeg newLine, LineSeg moveLine, List constraint) {
        Connection conn = (Connection) getHostFigure ();
        ConnectionAnchor anchor = conn.getSourceAnchor ();
        PrecisionPoint startPoint = new PrecisionPoint (anchor.getOwner ().getBounds ().getCenter ());
        anchor.getOwner ().translateToAbsolute (startPoint);
        conn.translateToRelative (startPoint);
        PrecisionRectangle bounds = new PrecisionRectangle (anchor.getOwner ().getBounds ());
        anchor.getOwner ().translateToAbsolute (bounds);
        conn.translateToRelative (bounds);
        Point origin = new Point (newLine.getOrigin ());
        if (moveLine.isHorizontal ()) {
            origin.x = startPoint.x;
        } else {
            origin.y = startPoint.y;
        }
        newLine.setOrigin (origin);
        constraint.add (0, new AbsoluteBendpoint (startPoint));
    }

    private void showOutsideTargetFeedback (LineSeg newLine, LineSeg moveLine, List constraint) {
        Connection conn = (Connection) getHostFigure ();
        ConnectionAnchor anchor = conn.getTargetAnchor ();
        PrecisionPoint endPoint = new PrecisionPoint (anchor.getOwner ().getBounds ().getCenter ());
        anchor.getOwner ().translateToAbsolute (endPoint);
        conn.translateToRelative (endPoint);
        PrecisionRectangle bounds = new PrecisionRectangle (anchor.getOwner ().getBounds ());
        anchor.getOwner ().translateToAbsolute (bounds);
        conn.translateToRelative (bounds);
        Point terminus = new Point (newLine.getTerminus ());
        if (moveLine.isHorizontal ()) {
            terminus.x = endPoint.x;
        } else {
            terminus.y = endPoint.y;
        }
        newLine.setTerminus (terminus);
        constraint.add (new AbsoluteBendpoint (endPoint));
    }

    public Object getAdapter (Class key) {
        if (key == AccessibleHandleProvider.class) if (handles == null) {
            return null;
        }

        return super.getAdapter (key);
    }

}

