package org.eclipse.gmf.runtime.emf.type.core.internal.descriptors;

import java.util.ArrayList;

import java.util.Iterator;

import java.util.List;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.EClassifier;

import org.eclipse.emf.ecore.EPackage;

import org.eclipse.emf.ecore.EReference;

import org.eclipse.emf.ecore.EStructuralFeature;

import org.eclipse.gmf.runtime.common.core.util.Log;

import org.eclipse.gmf.runtime.common.core.util.StringStatics;

import org.eclipse.gmf.runtime.emf.type.core.IContainerDescriptor;

import org.eclipse.gmf.runtime.emf.type.core.IElementMatcher;

import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePlugin;

import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePluginStatusCodes;

import org.eclipse.gmf.runtime.emf.type.core.internal.impl.XMLExpressionMatcher;

import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.ResourceManager;

class ContainerDescriptor implements IContainerDescriptor {
    private String matcherClassName;
    private IElementMatcher matcher;
    private IConfigurationElement matcherConfig;
    private EReference [] containmentFeatures;
    private List featureNames = new ArrayList ();
    private final MetamodelDescriptor metamodelDescriptor;

    public ContainerDescriptor (IConfigurationElement config, MetamodelDescriptor metamodelDescriptor, String id) throws CoreException {
        this.metamodelDescriptor = metamodelDescriptor;
        IConfigurationElement [] featureConfigs = config.getChildren (ElementTypeXmlConfig.E_ECONTAINMENT_FEATURE);
        if (featureConfigs.length > 0 && metamodelDescriptor == null) {
            throw EMFTypePluginStatusCodes.getInitException (id, ResourceManager.getMessage (EMFTypePluginStatusCodes.CONTAINMENT_FEATURE_NO_METAMODEL_KEY, new Object [] {featureConfigs [0]}), null);
        }
        for (int i = 0;
        i < featureConfigs.length; i ++) {
            IConfigurationElement nextFeatureConfig = featureConfigs [i];
            String qname = nextFeatureConfig.getAttribute (ElementTypeXmlConfig.A_QNAME);
            if (qname == null) {
                throw EMFTypePluginStatusCodes.getInitException (id, EMFTypePluginStatusCodes.CONTAINMENT_FEATURE_NO_QNAME_KEY, null);
            }
            featureNames.add (qname);
        }
        IConfigurationElement [] enablementConfigs = config.getChildren (ElementTypeXmlConfig.E_ENABLEMENT);
        if (enablementConfigs.length > 0) {
            matcher = new XMLExpressionMatcher (enablementConfigs [0], id);
        }
        if (matcher == null) {
            IConfigurationElement [] matcherConfigs = config.getChildren (ElementTypeXmlConfig.E_MATCHER);
            if (matcherConfigs.length > 0) {
                matcherClassName = matcherConfigs [0].getAttribute (ElementTypeXmlConfig.A_CLASS);
                if (matcherClassName == null) {
                    throw EMFTypePluginStatusCodes.getInitException (id, EMFTypePluginStatusCodes.MATCHER_NO_CLASS_KEY, null);
                }
                matcherConfig = matcherConfigs [0];
            }
        }
    }

    public IElementMatcher getMatcher () {
        if (matcher == null && matcherClassName != null && matcherConfig != null) {
            try {
                matcher = (IElementMatcher) matcherConfig.createExecutableExtension (ElementTypeXmlConfig.A_CLASS);
            } catch (CoreException e) {
                Log.error (EMFTypePlugin.getPlugin (), EMFTypePluginStatusCodes.MATCHER_CLASS_NOT_FOUND, ResourceManager.getMessage (EMFTypePluginStatusCodes.MATCHER_CLASS_NOT_FOUND_KEY, new Object [] {matcherClassName}), e);
                matcherClassName = null;
            }
        }
        return matcher;
    }

    public EReference [] getContainmentFeatures () {
        if (containmentFeatures == null && ! featureNames.isEmpty ()) {
            List references = new ArrayList ();
            if (metamodelDescriptor != null) {
                for (Iterator i = featureNames.iterator ();
                i.hasNext ();) {
                    String nextFeatureName = (String) i.next ();
                    EPackage ePackage = metamodelDescriptor.getEPackage ();
                    int featureIndex = nextFeatureName.lastIndexOf (StringStatics.PERIOD);
                    String classifierName = nextFeatureName.substring (0, featureIndex);
                    EClassifier classifier = ePackage.getEClassifier (classifierName);
                    if ((featureIndex < nextFeatureName.length () - 1) && classifier instanceof EClass) {
                        String featureName = nextFeatureName.substring (featureIndex + 1);
                        EStructuralFeature feature = ((EClass) classifier).getEStructuralFeature (featureName);
                        if (feature instanceof EReference) {
                            references.add (feature);
                        } else {
                            Log.error (EMFTypePlugin.getPlugin (), EMFTypePluginStatusCodes.CONTAINMENT_FEATURE_NOT_REFERENCE_FEATURE, ResourceManager.getMessage (EMFTypePluginStatusCodes.CONTAINMENT_FEATURE_NOT_REFERENCE_FEATURE_KEY, new Object [] {nextFeatureName}), null);
                        }
                    } else {
                        Log.error (EMFTypePlugin.getPlugin (), EMFTypePluginStatusCodes.CONTAINMENT_FEATURE_NO_SUCH_FEATURE, ResourceManager.getMessage (EMFTypePluginStatusCodes.CONTAINMENT_FEATURE_NO_SUCH_FEATURE_KEY, new Object [] {nextFeatureName}), null);
                    }
                }
            }
            containmentFeatures = (EReference []) references.toArray (new EReference [] {});
        }
        return containmentFeatures;
    }

}

