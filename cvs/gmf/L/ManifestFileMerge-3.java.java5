package org.eclipse.gmf.internal.common.codegen;

import java.io.ByteArrayInputStream;

import java.io.IOException;

import java.util.Arrays;

import java.util.Iterator;

import java.util.LinkedHashMap;

import java.util.LinkedList;

import java.util.Map;

import org.eclipse.gmf.internal.common.Activator;

import org.eclipse.osgi.util.ManifestElement;

import org.osgi.framework.BundleException;

public class ManifestFileMerge {
    private static final String IGNORE_MERGE_HEADER = "GMF-IgnoreMerge";
    private String [] myIgnoredHeaders;
    private final String myLineSeparator;

    public ManifestFileMerge () {
        this (System.getProperties ().getProperty ("line.separator"));
    }

    public ManifestFileMerge (String lineSeparator) {
        assert lineSeparator != null;
        myLineSeparator = lineSeparator;
    }

    public String process (String oldText, String newText) {
        try {
            cleanIgnoredHeaders ();
            LinkedHashMap < String, String > oldHeaders = new LinkedHashMap < String, String > ();
            ManifestElement.parseBundleManifest (new ByteArrayInputStream (oldText.getBytes ("UTF8")), oldHeaders);
            LinkedHashMap < String, String > newHeaders = new LinkedHashMap < String, String > ();
            ManifestElement.parseBundleManifest (new ByteArrayInputStream (newText.getBytes ("UTF8")), newHeaders);
            initializeIgnoredHeaders (oldHeaders);
            for (String newHeader : newHeaders.keySet ()) {
                if (! isIgnoredHeader (newHeader)) {
                    if (oldHeaders.containsKey (newHeader)) {
                        String oldValue = oldHeaders.get (newHeader);
                        String newValue = newHeaders.get (newHeader);
                        if (isMultivalued (oldValue) || isMultivalued (newValue)) {
                            oldHeaders.put (newHeader, mergeMultivalued (newHeader, oldValue, newValue));
                        } else {
                            oldHeaders.put (newHeader, newValue);
                        }
                    } else {
                        oldHeaders.put (newHeader, newHeaders.get (newHeader));
                    }
                }
            }
            return format (oldHeaders);
        } catch (IOException ex) {
            return newText;
        } catch (BundleException ex) {
            Activator.logError ("Error merging MANIFEST.MF", ex);
            return newText;
        }
    }

    protected String format (Map < String, String > oldHeaders) {
        StringBuilder sb = new StringBuilder ();
        for (Map.Entry < String, String > e : oldHeaders.entrySet ()) {
            sb.append (e.getKey ());
            sb.append (':');
            sb.append (' ');
            sb.append (formatValue (e.getValue ()));
            sb.append (myLineSeparator);
        }
        return sb.toString ();
    }

    protected CharSequence formatValue (String value) {
        if (! isMultivalued (value)) {
            return value;
        }
        String [] values = ManifestElement.getArrayFromList (value);
        assert values.length > 0;
        StringBuilder sb = new StringBuilder ();
        sb.append (values [0]);
        for (int i = 1;
        i < values.length; i ++) {
            sb.append (',');
            sb.append (myLineSeparator);
            sb.append (' ');
            sb.append (values [i]);
        }
        return sb;
    }

    private boolean isIgnoredHeader (String header) {
        assert myIgnoredHeaders != null;
        return Arrays.binarySearch (myIgnoredHeaders, header) >= 0;
    }

    private void initializeIgnoredHeaders (LinkedHashMap < String, String > oldHeaders) throws BundleException {
        if (! oldHeaders.containsKey (IGNORE_MERGE_HEADER)) {
            myIgnoredHeaders = new String [0];
            return;
        }
        ManifestElement [] values = ManifestElement.parseHeader (IGNORE_MERGE_HEADER, oldHeaders.get (IGNORE_MERGE_HEADER));
        if (values == null) {
            myIgnoredHeaders = new String [0];
            return;
        }
        myIgnoredHeaders = new String [values.length];
        for (int i = 0;
        i < values.length; i ++) {
            myIgnoredHeaders [i] = values [i].getValue ();
        }
        Arrays.sort (myIgnoredHeaders);
    }

    private void cleanIgnoredHeaders () {
        myIgnoredHeaders = null;
    }

    private boolean isMultivalued (String value) {
        return value.indexOf (',') > 0;
    }

    private String mergeMultivalued (String header, String oldValue, String newValue) throws BundleException {
        String [] oldValues = ManifestElement.getArrayFromList (oldValue);
        LinkedList < String > returnValue = new LinkedList < String > ();
        String [] lookupValues = new String [oldValues.length];
        for (int i = 0;
        i < oldValues.length; i ++) {
            returnValue.add (oldValues [i]);
            ManifestElement [] parsed = ManifestElement.parseHeader (header, oldValues [i]);
            assert parsed != null && parsed.length > 0;
            lookupValues [i] = parsed.length == 1 ? parsed [0].getValue () : oldValues [i];
        }
        Arrays.sort (lookupValues);
        for (String n : ManifestElement.getArrayFromList (newValue)) {
            ManifestElement [] parsed = ManifestElement.parseHeader (header, n);
            assert parsed != null && parsed.length > 0;
            String toLookUp;
            if (parsed.length == 1) {
                toLookUp = parsed [0].getValue ();
            } else {
                toLookUp = n;
            }
            if (Arrays.binarySearch (lookupValues, toLookUp) < 0) {
                returnValue.add (n);
            }
        }
        StringBuilder sb = new StringBuilder ();
        for (Iterator < String > it = returnValue.iterator ();
        it.hasNext ();) {
            sb.append (it.next ());
            if (it.hasNext ()) {
                sb.append (',');
            }
        }
        return sb.toString ();
    }

}

