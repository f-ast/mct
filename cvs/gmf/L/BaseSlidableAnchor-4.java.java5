package org.eclipse.gmf.runtime.draw2d.ui.figures;

import org.eclipse.draw2d.AbstractConnectionAnchor;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.PrecisionPoint;

import org.eclipse.draw2d.geometry.PrecisionRectangle;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.common.core.util.StringStatics;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

public class BaseSlidableAnchor extends AbstractConnectionAnchor {
    final private static char TERMINAL_START_CHAR = '(';
    final private static char TERMINAL_DELIMITER_CHAR = ',';
    final private static char TERMINAL_END_CHAR = ')';
    private PrecisionPoint relativeReference;

    public BaseSlidableAnchor () {
    }

    public BaseSlidableAnchor (IFigure f) {
        super (f);
    }

    public BaseSlidableAnchor (IFigure f, PrecisionPoint p) {
        super (f);
        this.relativeReference = new PrecisionPoint (p.preciseX, p.preciseY);
    }

    public String getTerminal () {
        if (isDefaultAnchor ()) return StringStatics.BLANK;

        return composeTerminalString (relativeReference);
    }

    public Point getReferencePoint () {
        return getAnchorPosition ();
    }

    private String composeTerminalString (PrecisionPoint p) {
        StringBuffer s = new StringBuffer (24);
        s.append (TERMINAL_START_CHAR);
        s.append ((float) p.preciseX);
        s.append (TERMINAL_DELIMITER_CHAR);
        s.append ((float) p.preciseY);
        s.append (TERMINAL_END_CHAR);
        return s.toString ();
    }

    private Point getAnchorPosition () {
        Rectangle rBox = getBox ();
        if (isDefaultAnchor ()) return rBox.getCenter ();

        return new Point (Math.round (relativeReference.preciseX * rBox.width + rBox.x), Math.round (relativeReference.preciseY * rBox.height + rBox.y));
    }

    protected Point getLocation (Point ownReference, Point foreignReference) {
        PointList intersections = getIntersectionPoints (ownReference, foreignReference);
        if (intersections != null && intersections.size () != 0) {
            Point location = PointListUtilities.pickClosestPoint (intersections, foreignReference);
            return location;
        }
        return null;
    }

    static private int STRAIGHT_LINE_TOLERANCE = 10;

    public Point getLocation (Point reference) {
        Point foreignReference = reference.getCopy ();
        Point ownReference = getReferencePoint ().getCopy ();
        ownReference = normalizeToStraightlineTolerance (foreignReference, ownReference, STRAIGHT_LINE_TOLERANCE);
        Point location = getLocation (ownReference, foreignReference);
        if (location == null || getBox ().expand (1, 1).contains (foreignReference) && ! getBox ().shrink (1, 1).contains (foreignReference)) location = getLocation (getBox ().getCenter (), foreignReference);

        if (location == null) {
            location = getBox ().getCenter ();
        }
        return location;
    }

    protected Point normalizeToStraightlineTolerance (Point foreignReference, Point ownReference, int tolerance) {
        Point normalizedReference = ownReference.getCopy ();
        if (Math.abs (foreignReference.x - ownReference.x) < tolerance || Math.abs (foreignReference.y - ownReference.y) < tolerance) {
            LineSeg lineSeg = new LineSeg (ownReference, foreignReference);
            normalizedReference = lineSeg.perpIntersect (ownReference.x, ownReference.y);
            if (Math.abs (normalizedReference.x - foreignReference.x) < Math.abs (normalizedReference.y - foreignReference.y)) normalizedReference.x = foreignReference.x;
            else normalizedReference.y = foreignReference.y;

        }
        return normalizedReference;
    }

    protected PointList getIntersectionPoints (Point ownReference, Point foreignReference) {
        final PointList polygon = getPolygonPoints ();
        return (new LineSeg (ownReference, foreignReference)).getLineIntersectionsWithLineSegs (polygon);
    }

    protected PointList getPolygonPoints () {
        if (getOwner () instanceof IPolygonAnchorableFigure) {
            PointList polyList = ((IPolygonAnchorableFigure) getOwner ()).getPolygonPoints ();
            getOwner ().translateToAbsolute (polyList);
            return polyList;
        }
        Rectangle rBox = getBox ();
        PointList ptList = new PointList ();
        ptList.addPoint (rBox.getTopLeft ());
        ptList.addPoint (rBox.getTopRight ());
        ptList.addPoint (rBox.getBottomRight ());
        ptList.addPoint (rBox.getBottomLeft ());
        ptList.addPoint (rBox.getTopLeft ());
        return ptList;
    }

    static public PrecisionPoint getAnchorRelativeLocation (Point p, Rectangle bounds) {
        PrecisionPoint relLocation;
        Point temp = new Point (p);
        if (p.x < bounds.x || p.x > bounds.x + bounds.width || p.y < bounds.y || p.y > bounds.y + bounds.height) {
            if (p.x < bounds.x || p.x > bounds.x + bounds.width) {
                temp.x = p.x < bounds.x ? bounds.x : bounds.x + bounds.width;
            }
            if (p.y < bounds.y || p.y > bounds.y + bounds.height) {
                temp.y = p.y < bounds.y ? bounds.y : bounds.y + bounds.height;
            }
            relLocation = new PrecisionPoint ((double) (temp.x - bounds.x) / bounds.width, (double) (temp.y - bounds.y) / bounds.height);
        } else {
            relLocation = new PrecisionPoint ((double) (temp.x - bounds.x) / bounds.width, (double) (temp.y - bounds.y) / bounds.height);
        }
        return relLocation;
    }

    protected Rectangle getBox () {
        Rectangle rBox = (getOwner () instanceof Connection) ? ((Connection) getOwner ()).getPoints ().getBounds ().getCopy () : getOwner ().getBounds ().getCopy ();
        PrecisionRectangle box = new PrecisionRectangle (rBox);
        getOwner ().translateToAbsolute (box);
        return box;
    }

    public boolean isDefaultAnchor () {
        return relativeReference == null;
    }

    public static PrecisionPoint parseTerminalString (String terminal) {
        try {
            return new PrecisionPoint (Float.parseFloat (terminal.substring (terminal.indexOf (BaseSlidableAnchor.TERMINAL_START_CHAR) + 1, terminal.indexOf (BaseSlidableAnchor.TERMINAL_DELIMITER_CHAR))), Float.parseFloat (terminal.substring (terminal.indexOf (BaseSlidableAnchor.TERMINAL_DELIMITER_CHAR) + 1, terminal.indexOf (BaseSlidableAnchor.TERMINAL_END_CHAR))));
        } catch (Exception e) {
            return null;
        }
    }

}

