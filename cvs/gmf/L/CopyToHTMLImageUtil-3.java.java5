package org.eclipse.gmf.runtime.diagram.ui.render.util;

import java.io.BufferedWriter;

import java.io.FileWriter;

import java.io.IOException;

import java.util.ArrayList;

import java.util.Collections;

import java.util.Comparator;

import java.util.HashMap;

import java.util.HashSet;

import java.util.Iterator;

import java.util.LinkedList;

import java.util.List;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.resources.IResource;

import org.eclipse.core.resources.ResourcesPlugin;

import org.eclipse.core.runtime.Assert;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.IPath;

import org.eclipse.core.runtime.IProgressMonitor;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.Path;

import org.eclipse.core.runtime.Status;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.common.core.command.FileModificationValidator;

import org.eclipse.gmf.runtime.common.core.util.StringStatics;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;

import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;

import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;

import org.eclipse.gmf.runtime.diagram.ui.image.ImageFileFormat;

import org.eclipse.gmf.runtime.diagram.ui.image.PartPositionInfo;

import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;

import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;

import org.eclipse.gmf.runtime.diagram.ui.render.clipboard.DiagramGenerator;

import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderPlugin;

import org.eclipse.gmf.runtime.diagram.ui.util.DiagramEditorUtil;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;

import org.eclipse.gmf.runtime.notation.Diagram;

import org.eclipse.swt.widgets.Shell;

public class CopyToHTMLImageUtil extends CopyToImageUtil {
    private HashMap < ImageFileFormat, Dimension > imageFormatToTileSizeMap = null;
    private String tileImageFileNameIndexDelimiter = StringStatics.UNDER_SCORE;

    {
        imageFormatToTileSizeMap = new HashMap < ImageFileFormat, Dimension > (ImageFileFormat.VALUES.length);
        imageFormatToTileSizeMap.put (ImageFileFormat.GIF, new Dimension (3000, 3000));
        imageFormatToTileSizeMap.put (ImageFileFormat.BMP, new Dimension (3000, 3000));
        imageFormatToTileSizeMap.put (ImageFileFormat.JPG, new Dimension (3000, 3000));
        imageFormatToTileSizeMap.put (ImageFileFormat.JPEG, new Dimension (3000, 3000));
        imageFormatToTileSizeMap.put (ImageFileFormat.PNG, new Dimension (3000, 3000));
        imageFormatToTileSizeMap.put (ImageFileFormat.SVG, new Dimension (0, 0));
    }

    public DiagramGenerator copyToImage (DiagramEditPart diagramEP, IPath destination, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
        ExportInfo exportInfo = copyToImageAndReturnInfo (diagramEP, diagramEP.getPrimaryEditParts (), destination, format, monitor);
        createHTMLFileForTiledImage (destination, exportInfo.commonTileFileName, format.getName ().toLowerCase (), exportInfo.tiles.y, exportInfo.tiles.x);
        return exportInfo.diagramGenerator;
    }

    public void copyToImage (DiagramEditPart diagramEP, List selection, IPath destination, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
        ExportInfo exportInfo = copyToImageAndReturnInfo (diagramEP, selection, destination, format, monitor);
        createHTMLFileForTiledImage (destination, exportInfo.commonTileFileName, format.getName ().toLowerCase (), exportInfo.tiles.y, exportInfo.tiles.x);
    }

    private Point exportImage (DiagramGenerator gen, List editParts, IPath destinationFolder, String fileName, ImageFileFormat imageFormat, int logTileWidth, int logTileHeight, IProgressMonitor monitor) throws Error, CoreException {
        org.eclipse.swt.graphics.Rectangle diagramArea = gen.calculateImageRectangle (editParts);
        int rows = 1, columns = 1;
        columns = (int) Math.ceil (diagramArea.width / ((double) logTileWidth));
        rows = (int) Math.ceil (diagramArea.height / ((double) logTileHeight));
        int jobsToDo = 6 * columns * rows + 1;
        monitor.beginTask (DiagramUIMessages.CopyToHTMLImageTask_exportingToHTML, jobsToDo);
        for (int i = 0;
        i < rows; i ++) {
            int sourceY = i * logTileHeight + diagramArea.y;
            int sourceHeight = Math.min (logTileHeight, diagramArea.height - logTileHeight * i);
            for (int j = 0;
            j < columns; j ++) {
                int sourceX = diagramArea.x + j * logTileWidth;
                int sourceWidth = Math.min (logTileWidth, diagramArea.width - logTileWidth * j);
                String tileFileName = fileName + getTileImageFileNameIndexDelimiter () + i + getTileImageFileNameIndexDelimiter () + j + StringStatics.PERIOD + imageFormat.getName ().toLowerCase ();
                IPath tilePath = new Path (destinationFolder.toOSString ()).append (tileFileName);
                monitor.subTask (DiagramUIMessages.CopyToHTMLImageTask_generateImageFile + tilePath);
                copyToImage (gen, editParts, new org.eclipse.swt.graphics.Rectangle (sourceX, sourceY, sourceWidth, sourceHeight), tilePath, imageFormat, monitor);
            }
        }
        return new Point (columns, rows);
    }

    private IStatus createHTMLFileForTiledImage (IPath htmlFileLocation, String fileName, String fileExtension, int numRows, int numColumns) {
        try {
            BufferedWriter out = new BufferedWriter (new FileWriter (htmlFileLocation.toOSString ()));
            out.write ("<html>\n<body>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" align=\"RIGHT\">\n");
            for (int i = 0;
            i < numRows; i ++) {
                out.write ("<tr>\n");
                for (int j = 0;
                j < numColumns; j ++) {
                    out.write ("\t<td><img src=\"");
                    out.write (fileName + getTileImageFileNameIndexDelimiter () + i + getTileImageFileNameIndexDelimiter () + j + StringStatics.PERIOD + fileExtension);
                    out.write ("\"></td>\n");
                }
                out.write ("</tr>\n");
            }
            out.write ("</table>\n</body>\n</html>");
            out.close ();
            IFile file = ResourcesPlugin.getWorkspace ().getRoot ().getFileForLocation (htmlFileLocation);
            if (file != null) {
                file.refreshLocal (IResource.DEPTH_ZERO, null);
                return FileModificationValidator.approveFileModification (new IFile [] {file});
            }
        } catch (IOException e) {
            return Status.CANCEL_STATUS;
        } catch (CoreException e) {
            return Status.CANCEL_STATUS;
        }
        return Status.OK_STATUS;
    }

    public String getTileImageFileNameIndexDelimiter () {
        return tileImageFileNameIndexDelimiter;
    }

    public void setTileImageFileNameIndexDelimiter (String tileImageFileNameIndexDelimiter) {
        if (tileImageFileNameIndexDelimiter == null || tileImageFileNameIndexDelimiter.length () == 0) throw new IllegalArgumentException ();

        this.tileImageFileNameIndexDelimiter = tileImageFileNameIndexDelimiter;
    }

    public HashMap < ImageFileFormat, Dimension > getImageFormatToTileSizeMap () {
        return imageFormatToTileSizeMap;
    }

    private class ExportInfo {
        DiagramGenerator diagramGenerator;
        Point tiles;
        String commonTileFileName;

        ExportInfo (DiagramGenerator diagramGenerator, Point tiles, String commonTileFileName) {
            this.diagramGenerator = diagramGenerator;
            this.tiles = tiles;
            this.commonTileFileName = commonTileFileName;
        }

    }

    private ExportInfo copyToImageAndReturnInfo (DiagramEditPart diagramEP, List selection, IPath destination, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
        DiagramGenerator gen = getDiagramGenerator (diagramEP, format);
        Dimension dimension = (Dimension) MapModeUtil.getMapMode (diagramEP.getFigure ()).DPtoLP (imageFormatToTileSizeMap.get (format).getCopy ());
        IPath destinationFolder = destination.removeLastSegments (1);
        String fileName = destination.removeFileExtension ().lastSegment ();
        Point tiles = exportImage (gen, selection, destinationFolder, fileName, format, dimension.width, dimension.height, monitor);
        return new ExportInfo (gen, tiles, fileName);
    }

    public List copyToImage (Diagram diagram, IPath destination, ImageFileFormat format, IProgressMonitor monitor, PreferencesHint preferencesHint) throws CoreException {
        Trace.trace (DiagramUIRenderPlugin.getInstance (), "Copy diagram to Image " + destination + " as " + format);
        ExportInfo exportInfo = null;
        List partsInfo = Collections.EMPTY_LIST;
        DiagramEditor openedDiagramEditor = DiagramEditorUtil.findOpenedDiagramEditorForID (ViewUtil.getIdStr (diagram));
        if (openedDiagramEditor != null) {
            DiagramEditPart diagramEditPart = openedDiagramEditor.getDiagramEditPart ();
            exportInfo = copyToImageAndReturnInfo (diagramEditPart, diagramEditPart.getPrimaryEditParts (), destination, format, monitor);
            partsInfo = exportInfo.diagramGenerator.getDiagramPartInfo (diagramEditPart);
        } else {
            Shell shell = new Shell ();
            try {
                DiagramEditPart diagramEditPart = createDiagramEditPart (diagram, shell, preferencesHint);
                Assert.isNotNull (diagramEditPart);
                exportInfo = copyToImageAndReturnInfo (diagramEditPart, diagramEditPart.getPrimaryEditParts (), destination, format, monitor);
                partsInfo = exportInfo.diagramGenerator.getDiagramPartInfo (diagramEditPart);
            } finally {
                shell.dispose ();
            }
        }
        return createTilesPartsInfoList (exportInfo, partsInfo, format);
    }

    private List < List < List < PartPositionInfo > > > createTilesPartsInfoList (ExportInfo exportInfo, List partsInfo, ImageFileFormat format) {
        List < List < List < PartPositionInfo > > > tilesPartsInfoList = Collections.EMPTY_LIST;
        if (exportInfo.diagramGenerator != null && exportInfo.tiles.x > 0 && exportInfo.tiles.y > 0 && partsInfo != null) {
            tilesPartsInfoList = initializeTilesPartsInfoList (exportInfo.tiles.y, exportInfo.tiles.x);
            if (exportInfo.tiles.x == 1 && exportInfo.tiles.y == 1) {
                tilesPartsInfoList.get (0).set (0, partsInfo);
            } else {
                Dimension tileSize = imageFormatToTileSizeMap.get (format);
                Rectangle defaultTile = new Rectangle (new Point (), tileSize);
                for (Iterator itr = partsInfo.iterator ();
                itr.hasNext ();) {
                    PartPositionInfo info = (PartPositionInfo) itr.next ();
                    if (info.getPolyline () == null) {
                        Point startCell = new Point ();
                        startCell.x = info.getPartX () / tileSize.width;
                        startCell.y = info.getPartY () / tileSize.height;
                        Point endCell = new Point ();
                        endCell.x = (info.getPartX () + info.getPartWidth ()) / tileSize.width;
                        endCell.y = (info.getPartY () + info.getPartHeight ()) / tileSize.height;
                        for (int i = startCell.y;
                        i <= endCell.y; i ++) {
                            for (int j = startCell.x;
                            j <= endCell.x; j ++) {
                                Rectangle shapeRect = new Rectangle (info.getPartX (), info.getPartY (), info.getPartWidth (), info.getPartHeight ());
                                shapeRect.translate (- j * tileSize.width, - i * tileSize.height);
                                Rectangle intersection = shapeRect.intersect (defaultTile);
                                PartPositionInfo newInfo = new PartPositionInfo ();
                                newInfo.setSemanticElement (info.getSemanticElement ());
                                newInfo.setPartHeight (intersection.height);
                                newInfo.setPartWidth (intersection.width);
                                newInfo.setPartX (intersection.x);
                                newInfo.setPartY (intersection.y);
                                tilesPartsInfoList.get (i).get (j).add (newInfo);
                            }
                        }
                    } else {
                        for (int i = 1;
                        i <= info.getPolyline ().size () / 2; i += 2) {
                            Point upperStartPt = info.getPolyline ().get (i - 1);
                            Point upperEndPt = info.getPolyline ().get (i);
                            Point lowerEndPt = info.getPolyline ().get (info.getPolyline ().size () - 1 - i);
                            Point lowerStartPt = info.getPolyline ().get (info.getPolyline ().size () - 1 - (i + 1));
                            HashSet < Point > cells = new HashSet < Point > ();
                            HashMap < Point, LineSeg > upperLineSegs = getMapOfLineSegments (upperStartPt, upperEndPt, tileSize, cells);
                            HashMap < Point, LineSeg > lowerLineSegs = getMapOfLineSegments (lowerStartPt, lowerEndPt, tileSize, cells);
                            HashMap < Point, LineSeg > upperToLowerLineSegs = getMapOfLineSegments (upperEndPt, lowerStartPt, tileSize, cells);
                            HashMap < Point, LineSeg > lowerToUpperLineSegs = getMapOfLineSegments (lowerEndPt, upperStartPt, tileSize, cells);
                            for (Iterator < Point > ptItr = cells.iterator ();
                            ptItr.hasNext ();) {
                                Point cell = ptItr.next ();
                                LineSeg upperSeg = upperLineSegs.get (cell);
                                LineSeg lowerSeg = lowerLineSegs.get (cell);
                                LineSeg upperToLowerSeg = upperToLowerLineSegs.get (cell);
                                LineSeg lowerToUpperSeg = lowerToUpperLineSegs.get (cell);
                                List < LineSeg > cwListOfLineSegs = new ArrayList < LineSeg > (4);
                                if (upperSeg != null) {
                                    cwListOfLineSegs.add (upperSeg);
                                }
                                if (upperToLowerSeg != null) {
                                    cwListOfLineSegs.add (upperToLowerSeg);
                                }
                                if (lowerSeg != null) {
                                    cwListOfLineSegs.add (lowerSeg);
                                }
                                if (lowerToUpperSeg != null) {
                                    cwListOfLineSegs.add (lowerToUpperSeg);
                                }
                                PartPositionInfo newInfo = new PartPositionInfo ();
                                newInfo.setSemanticElement (info.getSemanticElement ());
                                newInfo.setPolyline (createCellPolyline (tileSize, cwListOfLineSegs));
                                tilesPartsInfoList.get (cell.y).get (cell.x).add (newInfo);
                            }
                        }
                    }
                }
            }
        }
        return tilesPartsInfoList;
    }

    private List < List < List < PartPositionInfo > > > initializeTilesPartsInfoList (int rows, int columns) {
        List < List < List < PartPositionInfo > > > tilesPartsInfoList = new ArrayList < List < List < PartPositionInfo > > > (rows);
        for (int i = 0;
        i < rows; i ++) {
            List < List < PartPositionInfo > > row = new ArrayList < List < PartPositionInfo > > (columns);
            for (int j = 0;
            j < columns; j ++) {
                row.add (new LinkedList < PartPositionInfo > ());
            }
            tilesPartsInfoList.add (row);
        }
        return tilesPartsInfoList;
    }

    private class LineSegmentPointsComparator implements Comparator < Point > {
        private Point segmentOrigin;

        public LineSegmentPointsComparator (Point segmentOrigin) {
            this.segmentOrigin = segmentOrigin;
        }

        public int compare (Point p1, Point p2) {
            if (p1.x == p2.x) {
                return Math.abs (p1.y - segmentOrigin.y) - Math.abs (p2.y - segmentOrigin.y);
            }
            return Math.abs (p1.x - segmentOrigin.x) - Math.abs (p2.x - segmentOrigin.x);
        }

    }

    private HashMap < Point, LineSeg > getMapOfLineSegments (Point startPoint, Point endPoint, Dimension tileSize, HashSet < Point > cells) {
        HashMap < Point, LineSeg > map = new HashMap < Point, LineSeg > ();
        Point startCell = new Point ();
        startCell.x = startPoint.x / tileSize.width;
        startCell.y = startPoint.y / tileSize.height;
        Point endCell = new Point ();
        endCell.x = endPoint.x / tileSize.width;
        endCell.y = endPoint.y / tileSize.height;
        if (startCell.equals (endCell)) {
            map.put (startCell, new LineSeg (startPoint.getCopy ().translate (- startCell.x * tileSize.width, - startCell.y * tileSize.height), endPoint.getCopy ().translate (- startCell.x * tileSize.width, - startCell.y * tileSize.height)));
            cells.add (startCell);
        } else {
            double [] equation = LineSeg.getLineEquation (startPoint.x, startPoint.y, endPoint.x, endPoint.y);
            List < Point > linePoints = new ArrayList < Point > (2 + Math.abs (startCell.x - endCell.x) + Math.abs (startCell.y - endCell.y));
            if (equation [1] != 0) {
                for (int x = tileSize.width * (Math.min (startCell.x, endCell.x) + 1);
                x <= tileSize.width * Math.max (startCell.x, endCell.x); x += tileSize.width) {
                    linePoints.add (new Point (x, Math.round ((equation [2] - equation [0] * x) / equation [1])));
                }
            }
            if (equation [0] != 0) {
                for (int y = tileSize.height * (Math.min (startCell.y, endCell.y) + 1);
                y <= tileSize.height * Math.max (startCell.y, endCell.y); y += tileSize.height) {
                    linePoints.add (new Point (Math.round ((equation [2] - equation [1] * y) / equation [0]), y));
                }
            }
            Collections.sort (linePoints, new LineSegmentPointsComparator (startPoint));
            linePoints.add (0, startPoint.getCopy ());
            linePoints.add (endPoint.getCopy ());
            Point currentCell = startCell;
            Iterator < Point > pointsItr = linePoints.iterator ();
            Point originPoint = pointsItr.next ();
            for (; pointsItr.hasNext ();) {
                Point terminusPoint = pointsItr.next ();
                Point translatedOrigin = originPoint.getCopy ().translate (- currentCell.x * tileSize.width, - currentCell.y * tileSize.height);
                Point translatedTerminus = terminusPoint.getCopy ().translate (- currentCell.x * tileSize.width, - currentCell.y * tileSize.height);
                map.put (currentCell.getCopy (), new LineSeg (translatedOrigin, translatedTerminus));
                cells.add (currentCell.getCopy ());
                if (translatedTerminus.x == 0) {
                    currentCell.x --;
                }
                if (translatedTerminus.y == 0) {
                    currentCell.y --;
                }
                if (translatedTerminus.x == tileSize.width) {
                    currentCell.x ++;
                }
                if (translatedTerminus.y == tileSize.height) {
                    currentCell.y ++;
                }
                originPoint = terminusPoint;
            }
        }
        return map;
    }

    private List < Point > createCellPolyline (Dimension cellSize, List < LineSeg > segments) {
        List < Point > result = new LinkedList < Point > ();
        if (segments.size () > 0) {
            LineSeg currentSegment = segments.get (0);
            for (int i = 0;
            i < segments.size (); i ++) {
                LineSeg nextSegment = segments.get ((i + 1) % segments.size ());
                result.add (currentSegment.getTerminus ());
                if (! currentSegment.getTerminus ().equals (nextSegment.getOrigin ())) {
                    List < Point > connectingPoints = connectLineSegmentsEndsViaCellEdges (cellSize, currentSegment, nextSegment);
                    for (Iterator < Point > itr = connectingPoints.iterator ();
                    itr.hasNext ();) {
                        result.add (itr.next ());
                    }
                    result.add (nextSegment.getOrigin ());
                }
                currentSegment = nextSegment;
            }
            result.add (result.get (0));
        }
        return result;
    }

    private List < Point > connectLineSegmentsEndsViaCellEdges (Dimension cellSize, LineSeg lineSeg1, LineSeg lineSeg2) {
        Point current = lineSeg1.getTerminus ();
        Point next = lineSeg2.getOrigin ();
        List < Point > result = new LinkedList < Point > ();
        List < Point > cwCellVertices = createClockwiseListOfCellVertices (cellSize);
        int currentIdx = indexOfCellEdgePointClockwise (cellSize, current);
        int nextIdx = indexOfCellEdgePointClockwise (cellSize, next);
        for (int i = currentIdx;
        i != nextIdx;) {
            result.add (cwCellVertices.get (i));
            i = (i + 1) % cwCellVertices.size ();
        }
        return result;
    }

    private List < Point > createClockwiseListOfCellVertices (Dimension cellSize) {
        List < Point > cellVertices = new ArrayList < Point > (4);
        cellVertices.add (new Point ());
        cellVertices.add (new Point (cellSize.width, 0));
        cellVertices.add (new Point (cellSize.width, cellSize.height));
        cellVertices.add (new Point (0, cellSize.height));
        return cellVertices;
    }

    private int indexOfCellEdgePointClockwise (Dimension cellSize, Point pt) {
        if (pt.x == 0) {
            return 0;
        } else if (pt.y == 0) {
            return 1;
        } else if (pt.x == cellSize.width) {
            return 2;
        } else if (pt.y == cellSize.height) {
            return 3;
        }

        return 0;
    }

}

