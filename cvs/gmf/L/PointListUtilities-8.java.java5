package org.eclipse.gmf.runtime.draw2d.ui.geometry;

import java.util.ArrayList;

import java.util.List;

import java.util.ListIterator;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.Ray;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.draw2d.geometry.Transform;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dDebugOptions;

import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dPlugin;

public class PointListUtilities {

    static boolean flattenSegments (PointList points, int straightLineTolerance) {
        boolean changed = false;
        for (int i = 0;
        i < points.size () - 1; i ++) {
            Point ptStart = points.getPoint (i);
            Point ptTerm = null;
            if (i + 1 < points.size ()) ptTerm = points.getPoint (i + 1);

            Point ptNext = null;
            if (i + 2 < points.size ()) ptNext = points.getPoint (i + 2);

            if (points.size () <= 2 || ptTerm == null || ptNext == null) return changed;

            if (sameOrientation (ptStart, ptTerm, ptNext, straightLineTolerance)) {
                removePoint (points, i + 1);
                Ray seg = new Ray (ptStart, ptTerm);
                if (seg.y < straightLineTolerance) {
                    points.setPoint (new Point (ptNext.x, ptStart.y), i + 1);
                } else if (seg.x < straightLineTolerance) {
                    points.setPoint (new Point (ptStart.x, ptNext.y), i + 1);
                }

                changed = true;
            }
        }
        return changed;
    }

    static private Point removePoint (PointList points, int index) {
        Point removedPt = points.getPoint (index);
        for (int i = index;
        i < points.size () - 1; i ++) {
            points.setPoint (points.getPoint (i + 1), i);
        }
        points.setSize (points.size () - 1);
        return removedPt;
    }

    static public boolean normalizeSegments (PointList points) {
        return normalizeSegments (points, 0);
    }

    static public boolean normalizeSegments (PointList points, int straightLineTolerance) {
        boolean hasChanged = false;
        for (int i = 1;
        i < points.size () - 1; i ++) {
            Ray nextVector = new Ray (points.getPoint (i), points.getPoint (i - 1));
            int nextLength = (int) nextVector.length ();
            if (nextLength <= straightLineTolerance) {
                points.removePoint (i);
                hasChanged = true;
            }
        }
        hasChanged |= flattenSegments (points, straightLineTolerance);
        if (hasChanged) normalizeSegments (points, straightLineTolerance);

        return hasChanged;
    }

    static public Point getPointsSupremum (PointList points) {
        Point theSupremum = points.getFirstPoint ();
        for (int i = 1;
        i < points.size (); i ++) {
            Point other = points.getPoint (i);
            theSupremum = new Point (Math.max (theSupremum.x, other.x), Math.max (theSupremum.y, other.y));
        }
        return theSupremum;
    }

    static public Point getPointsInfimum (PointList points) {
        Point theInfimum = points.getFirstPoint ();
        for (int i = 1;
        i < points.size (); i ++) {
            Point other = points.getPoint (i);
            theInfimum = new Point (Math.min (theInfimum.x, other.x), Math.min (theInfimum.y, other.y));
        }
        return theInfimum;
    }

    static public PointList createPointsFromRect (Rectangle rBox) {
        PointList points = new PointList (5);
        Point pt = new Point (rBox.getLeft ().x, rBox.getTop ().y);
        points.addPoint (pt);
        pt = new Point (rBox.getRight ().x, rBox.getTop ().y);
        points.addPoint (pt);
        pt = new Point (rBox.getRight ().x, rBox.getBottom ().y);
        points.addPoint (pt);
        pt = new Point (rBox.getLeft ().x, rBox.getBottom ().y);
        points.addPoint (pt);
        pt = new Point (rBox.getLeft ().x, rBox.getTop ().y);
        points.addPoint (pt);
        return points;
    }

    static private void reAdjustBoxSize (List boxSegs, Point containedPoint) {
        assert boxSegs.size () == 4;
        LineSeg seg = getNearestSegment (boxSegs, containedPoint.x, containedPoint.y);
        LineSeg newSeg = seg.getParallelLineSegThroughPoint (containedPoint);
        ListIterator li = boxSegs.listIterator ();
        LineSeg prev = null;
        LineSeg next = null;
        LineSeg current = null;
        if (li.hasNext ()) current = (LineSeg) li.next ();

        while (current != null) {
            if (li.hasNext ()) next = (LineSeg) li.next ();
            else next = null;

            if (current.equals (seg)) {
                if (prev != null) {
                    prev.setTerminus (newSeg.getOrigin ());
                }
                current.setOrigin (newSeg.getOrigin ());
                current.setTerminus (newSeg.getTerminus ());
                if (next != null) {
                    next.setOrigin (newSeg.getTerminus ());
                }
            }
            current = next;
        }
    }

    static public PointList routeAroundRect (PointList points, final Rectangle rBox, int nSmoothFactor, final boolean bIncludeIntersectionPoints, final int nBuffer) {
        Point infimumPoint = getPointsInfimum (points);
        Point supremumPoint = getPointsSupremum (points);
        Ray diameter = new Ray (infimumPoint, supremumPoint);
        Rectangle rPoly = new Rectangle (infimumPoint.x, infimumPoint.y, diameter.x, diameter.y);
        rPoly.expand (1, 1);
        if (rPoly.intersects (rBox)) {
            PointList rBoxPoly = createPointsFromRect (rBox);
            Point firstPoint = points.getFirstPoint ();
            Point lastPoint = points.getLastPoint ();
            boolean bFPContained = rBox.contains (firstPoint);
            boolean bLPContained = rBox.contains (lastPoint);
            if (bFPContained || bLPContained) {
                List boxSegs = getLineSegments (rBoxPoly);
                if (bFPContained) {
                    reAdjustBoxSize (boxSegs, firstPoint);
                }
                if (bLPContained) {
                    reAdjustBoxSize (boxSegs, lastPoint);
                }
                rBoxPoly.removeAllPoints ();
                ListIterator li = boxSegs.listIterator ();
                while (li.hasNext ()) {
                    LineSeg seg = (LineSeg) li.next ();
                    rBoxPoly.addPoint (seg.getOrigin ());
                    if (! li.hasNext ()) rBoxPoly.addPoint (seg.getTerminus ());

                }
            }
            return routeAroundPoly (points, rBoxPoly, nSmoothFactor, true, bIncludeIntersectionPoints, nBuffer);
        }
        return null;
    }

    public static List getLineSegments (PointList points) {
        if (points.size () <= 1) return new ArrayList (0);

        ArrayList lines = new ArrayList (points.size () - 1);
        for (int i = 0;
        i < points.size () - 1; i ++) {
            lines.add (new LineSeg (points.getPoint (i), points.getPoint (i + 1)));
        }
        return lines;
    }

    final static int INTERSECT_TOLERANCE = 1;
    final static int MIN_LINE_LENGTH = 5;
    public final static int DEFAULT_BEZIERLINES = 16;
    final static int MAX_BEZIERLINES = 32;

    static public PointList routeAroundPoly (PointList points, final PointList poly, int nSmoothFactor, boolean bShortestDistance, final boolean bIncludeIntersectionPoints, final int nBuffer) {
        LineSeg pCurBoxSeg = null;
        Point ptIntersect = new Point ();
        PointList rPolyPoints = new PointList (points.size () * 2);
        List rBoxSegments = getLineSegments (poly);
        Point ptIntersect1 = null;
        Point ptPrevIntersect = new Point (- 100, - 100);
        int nPointsSinceFirstIntersection = 0;
        int nCurrentLength1 = 0;
        int nCurrentLength = 0;
        List mySegments = getLineSegments (points);
        ListIterator listIter = mySegments.listIterator ();
        while (listIter.hasNext ()) {
            LineSeg pSegment = (LineSeg) listIter.next ();
            boolean bFoundIntersects = false;
            ListIterator boxIter = rBoxSegments.listIterator ();
            while (boxIter.hasNext ()) {
                LineSeg pBoxSegment = (LineSeg) boxIter.next ();
                ptIntersect = pSegment.intersect (pBoxSegment, INTERSECT_TOLERANCE);
                if (ptIntersect != null) {
                    if (Math.abs (ptPrevIntersect.x - ptIntersect.x) > (INTERSECT_TOLERANCE * 2) || Math.abs (ptPrevIntersect.y - ptIntersect.y) > (INTERSECT_TOLERANCE * 2)) {
                        if (ptIntersect1 != null) {
                            Point ptIntersect2 = null;
                            LineSeg pCurBoxSeg2;
                            PointList newRoutePoints = new PointList ();
                            int nCurrentLength2 = nCurrentLength + (int) (pSegment.distanceAlong (ptIntersect) * pSegment.length ());
                            if (nCurrentLength1 < nCurrentLength2) {
                                ptIntersect2 = new Point (ptIntersect);
                                pCurBoxSeg2 = pBoxSegment;
                            } else {
                                ptIntersect2 = new Point (ptIntersect1);
                                pCurBoxSeg2 = pCurBoxSeg;
                                ptIntersect1 = new Point (ptIntersect);
                                pCurBoxSeg = pBoxSegment;
                            }
                            getRoutedPoints (points, newRoutePoints, ptIntersect1, ptIntersect2, rPolyPoints.getLastPoint (), pSegment.getTerminus (), pCurBoxSeg, pCurBoxSeg2, poly, nSmoothFactor, bShortestDistance, bIncludeIntersectionPoints, nBuffer);
                            while (nPointsSinceFirstIntersection > 0) {
                                rPolyPoints.removePoint (rPolyPoints.size () - 1);
                                nPointsSinceFirstIntersection --;
                            }
                            for (int i = 0;
                            i < newRoutePoints.size (); i ++) rPolyPoints.addPoint (newRoutePoints.getPoint (i));

                            rPolyPoints.addPoint (new Point (pSegment.getTerminus ()));
                            ptIntersect1 = null;
                            bFoundIntersects = true;
                            break;
                        } else {
                            ptIntersect1 = new Point (ptIntersect);
                            pCurBoxSeg = pBoxSegment;
                            rPolyPoints.addPoint (new Point (pSegment.getOrigin ()));
                            nPointsSinceFirstIntersection = 0;
                            nCurrentLength1 = nCurrentLength + (int) (pSegment.distanceAlong (ptIntersect) * pSegment.length ());
                        }
                    }
                    ptPrevIntersect = new Point (ptIntersect);
                }
            }
            nCurrentLength += pSegment.length ();
            if (! bFoundIntersects) {
                rPolyPoints.addPoint (new Point (pSegment.getOrigin ()));
                if (ptIntersect1 != null) nPointsSinceFirstIntersection ++;

                if (! listIter.hasNext ()) rPolyPoints.addPoint (new Point (pSegment.getTerminus ()));

            }
        }
        if (points.size () != rPolyPoints.size ()) {
            return rPolyPoints;
        }
        return null;
    }

    static public PointList copyPoints (PointList pointsFrom) {
        PointList points = new PointList (pointsFrom.size ());
        copyFrom (points, pointsFrom);
        return points;
    }

    static private void copyFrom (PointList pointsTo, PointList pointsFrom) {
        pointsTo.removeAllPoints ();
        for (int i = 0;
        i < pointsFrom.size (); i ++) pointsTo.addPoint (pointsFrom.getPoint (i));

    }

    static private int addRoutedPoints (PointList routePoints, LineSeg pCurBoxSeg1, LineSeg pCurBoxSeg2, final PointList routePoly, final boolean bForward, final int nBuffer) {
        Point pNewPoint = null;
        float fOffset = 0;
        int nDistance = 0;
        List rBoxSegments = getLineSegments (routePoly);
        ListIterator boxIter = bForward ? rBoxSegments.listIterator () : rBoxSegments.listIterator (rBoxSegments.size ());
        while (bForward ? boxIter.hasNext () : boxIter.hasPrevious ()) {
            LineSeg seg = bForward ? (LineSeg) boxIter.next () : (LineSeg) boxIter.previous ();
            if (seg.equals (pCurBoxSeg1)) break;

        }
        do {
            fOffset = nBuffer / (float) pCurBoxSeg1.length ();
            Point ptEnd;
            if (bForward) {
                fOffset += 1.0;
                ptEnd = pCurBoxSeg1.getTerminus ();
            } else {
                fOffset *= - 1.0;
                ptEnd = pCurBoxSeg1.getOrigin ();
            }
            if (routePoints.size () > 0) nDistance += routePoints.getLastPoint ().getDistance (ptEnd);

            if (nBuffer > 0) pNewPoint = new Point (pCurBoxSeg1.locatePoint (fOffset, nBuffer, LineSeg.Sign.POSITIVE));
            else pNewPoint = new Point (ptEnd);

            routePoints.addPoint (pNewPoint);
            if (! pCurBoxSeg1.equals (pCurBoxSeg2)) {
                if (bForward) {
                    if (! boxIter.hasNext ()) boxIter = rBoxSegments.listIterator ();

                    pCurBoxSeg1 = (LineSeg) boxIter.next ();
                } else {
                    if (! boxIter.hasPrevious ()) boxIter = rBoxSegments.listIterator (rBoxSegments.size ());

                    pCurBoxSeg1 = (LineSeg) boxIter.previous ();
                }
            }
        } while (! pCurBoxSeg1.equals (pCurBoxSeg2));
        return nDistance;
    }

    static private void getRoutedPoints (PointList points, PointList newRoutePoints, final Point ptIntersect1, final Point ptIntersect2, final Point ptPrev, final Point ptNext, LineSeg pCurBoxSeg1, LineSeg pCurBoxSeg2, final PointList routePoly, int nSmoothFactor, boolean bShortestDistance, final boolean bIncludeIntersectionPoints, final int nBuffer) {
        PointList newRoutePoints1 = new PointList ();
        PointList newRoutePoints2 = new PointList ();
        Point ptAbove = new Point (ptIntersect1);
        if (nBuffer > 0) {
            float dDistance = pCurBoxSeg1.distanceAlong (ptIntersect1);
            ptAbove = pCurBoxSeg1.locatePoint (dDistance, nBuffer, LineSeg.Sign.POSITIVE);
        }
        newRoutePoints1.addPoint (new Point (ptAbove));
        newRoutePoints2.addPoint (new Point (ptAbove));
        int nDistance1 = 0;
        int nDistance2 = 0;
        LineSeg pCurSeg = pCurBoxSeg1;
        nDistance1 += addRoutedPoints (newRoutePoints1, pCurSeg, pCurBoxSeg2, routePoly, true, nBuffer);
        nDistance1 += newRoutePoints1.getLastPoint ().getDistance (ptIntersect2);
        pCurSeg = pCurBoxSeg1;
        nDistance2 += addRoutedPoints (newRoutePoints2, pCurSeg, pCurBoxSeg2, routePoly, false, nBuffer);
        nDistance2 += newRoutePoints2.getLastPoint ().getDistance (ptIntersect2);
        ptAbove = new Point (ptIntersect2);
        if (nBuffer > 0) {
            float dDistance = pCurBoxSeg2.distanceAlong (ptIntersect2);
            ptAbove = pCurBoxSeg2.locatePoint (dDistance, nBuffer, LineSeg.Sign.POSITIVE);
        }
        newRoutePoints1.addPoint (new Point (ptAbove));
        newRoutePoints2.addPoint (new Point (ptAbove));
        if ((nDistance1 < nDistance2 && bShortestDistance) || (nDistance1 > nDistance2 && ! bShortestDistance)) {
            copyFrom (newRoutePoints, newRoutePoints1);
        } else {
            copyFrom (newRoutePoints, newRoutePoints2);
        }
        if (! bIncludeIntersectionPoints && newRoutePoints.size () >= 3) {
            PointList checkPoints = new PointList (newRoutePoints.size () + 2);
            checkPoints.addPoint (new Point (ptPrev));
            for (int i = 0;
            i < newRoutePoints.size (); i ++) checkPoints.addPoint (new Point (newRoutePoints.getPoint (i)));

            checkPoints.addPoint (new Point (ptNext));
            int nIndex = 0;
            Point ptStart = checkPoints.getPoint (nIndex ++);
            Point ptCheckSkip = checkPoints.getPoint (nIndex ++);
            Point ptEnd = checkPoints.getPoint (nIndex ++);
            List polySegments = getLineSegments (routePoly);
            newRoutePoints.removeAllPoints ();
            while (ptEnd != null) {
                LineSeg tempSeg = new LineSeg (ptStart, ptEnd);
                Point ptIntersect = new Point ();
                boolean bAddPoint = false;
                ListIterator segIter = polySegments.listIterator ();
                while (segIter.hasNext ()) {
                    LineSeg pPolySegment = (LineSeg) segIter.next ();
                    ptIntersect = tempSeg.intersect (pPolySegment, INTERSECT_TOLERANCE);
                    if (ptIntersect != null) {
                        bAddPoint = true;
                        break;
                    }
                }
                if (bAddPoint) {
                    newRoutePoints.addPoint (new Point (ptCheckSkip));
                    ptStart = new Point (ptCheckSkip);
                }
                ptCheckSkip = new Point (ptEnd);
                if (nIndex < checkPoints.size ()) ptEnd = checkPoints.getPoint (nIndex ++);
                else ptEnd = null;

            }
        }
        if (nSmoothFactor > 0) {
            PointList tempPoly = calcSmoothPolyline (newRoutePoints, nSmoothFactor, DEFAULT_BEZIERLINES);
            copyFrom (newRoutePoints, tempPoly);
        }
    }

    static public final PointList calcSmoothPolyline (PointList points, int nSmoothFactor, int nBezierSteps) {
        PointList theBezierPoints = calcBezier (points, nSmoothFactor, 0, points.size () - 1);
        return calcApproxPolylineFromBezier (theBezierPoints, nBezierSteps);
    }

    static public PointList calcSmoothPolyline (PointList points, int nSmoothFactor, int nBezierSteps, int nStartIndex, int nEndIndex) {
        PointList theBezierPoints = calcBezier (points, nSmoothFactor, nStartIndex, nEndIndex);
        return calcApproxPolylineFromBezier (theBezierPoints, nBezierSteps);
    }

    static private PointList calcBezier (final PointList points, int nSmoothFactor, int nStartIndex, int nEndIndex) {
        Point ptPrevControl = null;
        PointList theBezierPoints = new PointList (points.size () * 2);
        List theSegments = getLineSegments (points);
        for (int i = 0;
        i < theSegments.size (); i ++) {
            LineSeg pLineSeg = (LineSeg) theSegments.get (i);
            double dLineLength = pLineSeg.length ();
            double dControlLength = dLineLength * nSmoothFactor / 100;
            boolean bAddToBezier = false;
            if (i >= nStartIndex && i <= nEndIndex) bAddToBezier = true;
            else if (i > nEndIndex) return theBezierPoints;

            if (dLineLength > MIN_LINE_LENGTH) {
                Point ptStartControl = new Point ();
                Point ptTerminusControl = new Point ();
                Point ptStart = new Point (pLineSeg.getOrigin ());
                Point ptTerminus = new Point (pLineSeg.getTerminus ());
                if (theBezierPoints.size () == 0) {
                    if (bAddToBezier) theBezierPoints.addPoint (ptStart);

                }
                if (ptPrevControl != null) {
                    LineSeg prevControlSeg = new LineSeg (ptPrevControl, ptStart);
                    ptStartControl = new Point ();
                    prevControlSeg.pointOn ((int) Math.round (prevControlSeg.length () + dControlLength), LineSeg.KeyPoint.ORIGIN, ptStartControl);
                } else {
                    ptStartControl = new Point ();
                    pLineSeg.pointOn ((int) Math.round (dControlLength), LineSeg.KeyPoint.ORIGIN, ptStartControl);
                }
                if (bAddToBezier) theBezierPoints.addPoint (ptStartControl);

                LineSeg pNextSeg = null;
                if (i + 1 < theSegments.size ()) {
                    pNextSeg = (LineSeg) theSegments.get (i + 1);
                    while (pNextSeg != null && pNextSeg.length () < MIN_LINE_LENGTH) {
                        i ++;
                        if (i + 1 < theSegments.size ()) pNextSeg = (LineSeg) theSegments.get (i + 1);
                        else pNextSeg = null;

                    }
                }
                if (pNextSeg != null) {
                    Ray ptVector1 = new Ray (pLineSeg.getOrigin (), pLineSeg.getTerminus ());
                    Ray ptVector2 = new Ray (pNextSeg.getOrigin (), pNextSeg.getTerminus ());
                    double dNewAngle = 0.0;
                    LineSeg.TrigValues val = pLineSeg.getTrigValues (ptVector2);
                    dNewAngle = Math.atan2 (- val.sinTheta, - val.cosTheta);
                    if (dNewAngle > 0) dNewAngle = (Math.PI - dNewAngle) / - 2;
                    else dNewAngle = (- Math.PI - dNewAngle) / - 2;

                    Transform trans = new Transform ();
                    trans.setRotation (dNewAngle);
                    Point ptVector1Prime = trans.getTransformed (new Point (ptVector1.x, ptVector1.y));
                    LineSeg nextControlSeg = new LineSeg (new Point (0, 0), new Point (ptVector1Prime.x, ptVector1Prime.y));
                    Point ptProjection = new Point ();
                    nextControlSeg.pointOn ((int) Math.round (dControlLength), LineSeg.KeyPoint.ORIGIN, ptProjection);
                    ptTerminusControl = new Point (pLineSeg.getTerminus ().x - ptProjection.x, pLineSeg.getTerminus ().y - ptProjection.y);
                } else {
                    pLineSeg.pointOn ((int) Math.round (dLineLength - dControlLength), LineSeg.KeyPoint.ORIGIN, ptTerminusControl);
                }
                ptPrevControl = new Point (ptTerminusControl);
                if (bAddToBezier) {
                    theBezierPoints.addPoint (ptTerminusControl);
                    theBezierPoints.addPoint (ptTerminus);
                }
            }
        }
        return theBezierPoints;
    }

    static private PointList calcApproxPolylineFromBezier (final PointList points, int nBezierSteps) {
        PointList thePolyPoints = new PointList (points.size () * nBezierSteps + 2);
        Point ptCtl1, ptCtl2, ptCtl3, ptCtl4;
        boolean bStart = true;
        if (points.size () < 4) return thePolyPoints;

        ptCtl1 = new Point ();
        for (int i = 0;
        i < points.size () - 3; i = i + 3) {
            if (bStart) {
                ptCtl1 = new Point (points.getPoint (i));
                bStart = false;
            } else {
                thePolyPoints.removePoint (thePolyPoints.size () - 1);
            }
            ptCtl2 = new Point (points.getPoint (i + 1));
            ptCtl3 = new Point (points.getPoint (i + 2));
            ptCtl4 = new Point (points.getPoint (i + 3));
            if (! BezierToLines (thePolyPoints, ptCtl1, ptCtl2, ptCtl3, ptCtl4, nBezierSteps)) return null;

            ptCtl1 = new Point (ptCtl4);
        }
        thePolyPoints.setPoint (points.getPoint (0), 0);
        thePolyPoints.setPoint (points.getPoint (points.size () - 1), thePolyPoints.size () - 1);
        return thePolyPoints;
    }

    private static boolean BezierToLines (PointList thePolyPoints, Point ptCtl1, Point ptCtl2, Point ptCtl3, Point ptCtl4, int nSteps) {
        boolean bRC = true;
        int nTotalPoints;
        int nLinePoints;
        double [] lpWorkX;
        double [] lpWorkY;
        int i, j;
        nSteps = Math.min (MAX_BEZIERLINES, nSteps);
        lpWorkX = new double [3 * nSteps + 2];
        lpWorkY = new double [3 * nSteps + 2];
        lpWorkX [0] = ptCtl1.x;
        lpWorkX [1] = ptCtl2.x;
        lpWorkX [2] = ptCtl3.x;
        lpWorkX [3] = ptCtl4.x;
        lpWorkY [0] = ptCtl1.y;
        lpWorkY [1] = ptCtl2.y;
        lpWorkY [2] = ptCtl3.y;
        lpWorkY [3] = ptCtl4.y;
        nLinePoints = 2;
        nTotalPoints = 4;
        while (nLinePoints <= nSteps) {
            for (i = nTotalPoints - 1; i > 0; i --) {
                lpWorkX [2 * i] = lpWorkX [i];
                lpWorkY [2 * i] = lpWorkY [i];
            }
            nTotalPoints = (2 * nTotalPoints) - 1;
            for (i = nTotalPoints - 2; i > 0; i -= 2) {
                lpWorkX [i] = (lpWorkX [i - 1] + lpWorkX [i + 1]) / 2;
                lpWorkY [i] = (lpWorkY [i - 1] + lpWorkY [i + 1]) / 2;
            }
            for (i = nTotalPoints - 3; i > 0; i -= 2) {
                if ((i % 6) != 0) {
                    lpWorkX [i] = (lpWorkX [i - 1] + lpWorkX [i + 1]) / 2;
                    lpWorkY [i] = (lpWorkY [i - 1] + lpWorkY [i + 1]) / 2;
                }
            }
            for (i = nTotalPoints - 4; i > 0; i -= 6) {
                lpWorkX [i] = (lpWorkX [i - 1] + lpWorkX [i + 1]) / 2;
                lpWorkY [i] = (lpWorkY [i - 1] + lpWorkY [i + 1]) / 2;
            }
            nLinePoints = (nTotalPoints / 3) + 1;
        }
        for (i = 0; i < nSteps; i ++) {
            Point ptTemp = new Point ();
            j = (3 * i);
            ptTemp.x = (int) Math.round (lpWorkX [j]);
            ptTemp.y = (int) Math.round (lpWorkY [j]);
            thePolyPoints.addPoint (ptTemp);
        }
        return (bRC);
    }

    static public Point pointOn (PointList points, final long theDistance, final LineSeg.KeyPoint fromKeyPoint, Point ptResult) {
        List mySegments = getLineSegments (points);
        return pointOn (mySegments, theDistance, fromKeyPoint, ptResult);
    }

    public static long getPointsLength (PointList points) {
        List segs = getLineSegments (points);
        return length (segs);
    }

    protected static long length (List mySegments) {
        long theLength = 0;
        ListIterator lineIter = mySegments.listIterator ();
        while (lineIter.hasNext ()) {
            LineSeg aSegment = (LineSeg) lineIter.next ();
            theLength += Math.round (aSegment.length ());
        }
        return theLength;
    }

    private final static int BIGDISTANCE = 32766;

    public static LineSeg getNearestSegment (List mySegments, final int xCoord, final int yCoord) {
        long minDistance = BIGDISTANCE;
        long nextDistance = 0;
        LineSeg closeSegment = null;
        LineSeg firstSegment = mySegments.isEmpty () ? null : (LineSeg) mySegments.get (0);
        ListIterator lineIter = mySegments.listIterator ();
        while (lineIter.hasNext ()) {
            LineSeg aSegment = (LineSeg) lineIter.next ();
            nextDistance = aSegment.distanceToPoint (xCoord, yCoord);
            if (nextDistance < minDistance) {
                closeSegment = aSegment;
                minDistance = nextDistance;
            }
        }
        if (closeSegment != null) return closeSegment;

        return firstSegment;
    }

    protected static Point pointOn (List mySegments, final long theDistance, final LineSeg.KeyPoint fromKeyPoint, Point ptResult) {
        long thisLength = length (mySegments);
        long halfLength = thisLength / 2;
        if (theDistance >= thisLength) {
            if (fromKeyPoint == LineSeg.KeyPoint.ORIGIN) {
                ((LineSeg) mySegments.get (mySegments.size () - 1)).pointOn (theDistance - thisLength, LineSeg.KeyPoint.TERMINUS, ptResult);
                return ptResult;
            } else if (fromKeyPoint == LineSeg.KeyPoint.MIDPOINT) {
                ((LineSeg) mySegments.get (mySegments.size () - 1)).pointOn (theDistance - halfLength, LineSeg.KeyPoint.TERMINUS, ptResult);
                return ptResult;
            } else if (fromKeyPoint == LineSeg.KeyPoint.TERMINUS) {
                ((LineSeg) mySegments.get (mySegments.size () - 1)).pointOn (theDistance, LineSeg.KeyPoint.TERMINUS, ptResult);
                return ptResult;
            } else {
                IllegalArgumentException iae = new IllegalArgumentException ();
                Trace.throwing (Draw2dPlugin.getInstance (), Draw2dDebugOptions.EXCEPTIONS_THROWING, PointListUtilities.class, "pointOn()", iae);
                throw iae;
            }

        } else if (theDistance < 0) {
            if (fromKeyPoint == LineSeg.KeyPoint.ORIGIN) {
                ((LineSeg) mySegments.get (0)).pointOn (theDistance, fromKeyPoint, ptResult);
                return ptResult;
            } else if (fromKeyPoint == LineSeg.KeyPoint.MIDPOINT) {
                return pointOn (mySegments, halfLength + theDistance, LineSeg.KeyPoint.ORIGIN, ptResult);
            } else if (fromKeyPoint == LineSeg.KeyPoint.TERMINUS) {
                ((LineSeg) mySegments.get (mySegments.size () - 1)).pointOn (theDistance, fromKeyPoint, ptResult);
                return ptResult;
            } else {
                IllegalArgumentException iae = new IllegalArgumentException ();
                Trace.throwing (Draw2dPlugin.getInstance (), Draw2dDebugOptions.EXCEPTIONS_THROWING, PointListUtilities.class, "pointOn()", iae);
                throw iae;
            }

        } else {
            LocateInfo locateInfo = new LocateInfo ();
            if (! locateSegment (mySegments, ((double) theDistance) / ((double) thisLength), fromKeyPoint, locateInfo)) return null;

            locateInfo.theSegment.pointOn (locateInfo.remainingDist, (fromKeyPoint == LineSeg.KeyPoint.MIDPOINT ? LineSeg.KeyPoint.ORIGIN : fromKeyPoint), ptResult);
            return ptResult;
        }

    }

    static private class LocateInfo {
        public long remainingDist;
        public LineSeg theSegment;
    }

    private static boolean locateSegment (List mySegments, final double pctDist, final LineSeg.KeyPoint fromKeyPoint, LocateInfo locateInfo) {
        double thePctDist = pctDist;
        if (pctDist < 0.0) {
            thePctDist = 0.0;
        } else if (1.0 < pctDist) {
            thePctDist = 1.0;
        }

        final long theLength = length (mySegments);
        long remainingLength = Math.round (thePctDist * theLength);
        long nextLength = 0;
        locateInfo.theSegment = null;
        if (fromKeyPoint == LineSeg.KeyPoint.MIDPOINT || fromKeyPoint == LineSeg.KeyPoint.ORIGIN) {
            if (fromKeyPoint == LineSeg.KeyPoint.MIDPOINT) {
                remainingLength += theLength / 2;
            }
            ListIterator lineIter = mySegments.listIterator ();
            while (lineIter.hasNext ()) {
                LineSeg aSegment = (LineSeg) lineIter.next ();
                nextLength = Math.round (aSegment.length ());
                if (nextLength >= remainingLength) {
                    locateInfo.theSegment = aSegment;
                    break;
                } else {
                    remainingLength -= nextLength;
                }
            }
        } else if (fromKeyPoint == LineSeg.KeyPoint.TERMINUS) {
            ListIterator lineIter = mySegments.listIterator (mySegments.size ());
            while (lineIter.hasPrevious ()) {
                LineSeg aSegment = (LineSeg) lineIter.previous ();
                nextLength = Math.round (aSegment.length ());
                if (nextLength >= remainingLength) {
                    locateInfo.theSegment = aSegment;
                    break;
                } else {
                    remainingLength -= nextLength;
                }
            }
        } else {
            IllegalArgumentException iae = new IllegalArgumentException ();
            Trace.throwing (Draw2dPlugin.getInstance (), Draw2dDebugOptions.EXCEPTIONS_THROWING, PointListUtilities.class, "pointOn()", iae);
            throw iae;
        }

        locateInfo.remainingDist = remainingLength;
        return true;
    }

    protected static double distanceAlong (List mySegments, final Point aPoint) {
        LineSeg theSegment = getNearestSegment (mySegments, aPoint.x, aPoint.y);
        double linePct = segmentDistance (mySegments, theSegment, LineSeg.KeyPoint.ORIGIN);
        double segmentPct = theSegment.distanceAlong (aPoint);
        if (0.0 <= segmentPct && segmentPct <= 1.0) {
            long polyLength = length (mySegments);
            if (polyLength != 0) {
                linePct += (segmentPct * (theSegment.length () / polyLength));
            }
            return linePct;
        } else {
            return segmentPct;
        }
    }

    protected static double segmentDistance (List mySegments, LineSeg theSegment, final LineSeg.KeyPoint uptoKeyPoint) {
        long accumulatedLength = 0;
        ListIterator lineIter = mySegments.listIterator ();
        while (lineIter.hasNext ()) {
            LineSeg aSegment = (LineSeg) lineIter.next ();
            if (theSegment.equals (aSegment)) {
                if (uptoKeyPoint == LineSeg.KeyPoint.ORIGIN) {
                } else if (uptoKeyPoint == LineSeg.KeyPoint.MIDPOINT) {
                    accumulatedLength += aSegment.length () / 2;
                } else if (uptoKeyPoint == LineSeg.KeyPoint.TERMINUS) {
                    accumulatedLength += aSegment.length ();
                } else {
                    IllegalArgumentException iae = new IllegalArgumentException ();
                    Trace.throwing (Draw2dPlugin.getInstance (), Draw2dDebugOptions.EXCEPTIONS_THROWING, PointListUtilities.class, "pointOn()", iae);
                    throw iae;
                }

                long polyLength = length (mySegments);
                if (polyLength != 0) {
                    return ((double) accumulatedLength / (double) polyLength);
                } else {
                    return 0.0;
                }
            } else {
                accumulatedLength += aSegment.length ();
            }
        }
        return 0.0;
    }

    static public PointList routeAroundPoint (PointList points, final Point ptCenter, int nHeight, int nWidth, int nSmoothFactor, int nInclineOffset, boolean bTop) {
        List mySegments = getLineSegments (points);
        long nPolyLength = length (mySegments);
        long nCenterDistance = Math.round (distanceAlong (mySegments, ptCenter) * nPolyLength);
        Point ptMidStart = new Point ();
        pointOn (mySegments, nCenterDistance - (nWidth / 2), LineSeg.KeyPoint.ORIGIN, ptMidStart);
        Point ptMidEnd = new Point ();
        pointOn (mySegments, nCenterDistance + (nWidth / 2), LineSeg.KeyPoint.ORIGIN, ptMidEnd);
        LineSeg lineNew = new LineSeg (ptMidStart, ptMidEnd);
        Point ptStart = new Point ();
        lineNew.pointOn (nInclineOffset, LineSeg.KeyPoint.ORIGIN, ptStart);
        LocateInfo locateInfo = new LocateInfo ();
        if (! locateSegment (mySegments, (nCenterDistance - ((long) nWidth / 2)) / (double) nPolyLength, LineSeg.KeyPoint.ORIGIN, locateInfo)) return null;

        LineSeg pStartSeg = locateInfo.theSegment;
        Point ptEnd = new Point ();
        lineNew.pointOn (nInclineOffset, LineSeg.KeyPoint.TERMINUS, ptEnd);
        if (! locateSegment (mySegments, (nCenterDistance + ((long) nWidth / 2)) / (double) nPolyLength, LineSeg.KeyPoint.ORIGIN, locateInfo)) return null;

        LineSeg pEndSeg = locateInfo.theSegment;
        float fSlope = lineNew.slope ();
        int nDir = 1;
        if ((bTop && fSlope <= 0) || (! bTop && fSlope > 0)) nDir *= - 1;

        LineSeg lineStart = new LineSeg (LineSeg.KeyPoint.ORIGIN, ptStart.x, ptStart.y, lineNew.perpSlope (), nHeight, nDir);
        LineSeg lineEnd = new LineSeg (LineSeg.KeyPoint.ORIGIN, ptEnd.x, ptEnd.y, lineNew.perpSlope (), nHeight, nDir);
        PointList rRotatedBox = new PointList ();
        rRotatedBox.addPoint (new Point (ptMidStart));
        rRotatedBox.addPoint (new Point (lineStart.getTerminus ()));
        rRotatedBox.addPoint (new Point (lineEnd.getTerminus ()));
        rRotatedBox.addPoint (new Point (ptMidEnd));
        rRotatedBox.addPoint (new Point (ptMidStart));
        PointList rPolyPoints = new PointList (rRotatedBox.size () * MAX_BEZIERLINES + points.size ());
        boolean bFoundStart = false;
        boolean bFoundEnd = false;
        int nPointsSinceStart = 0;
        List boxSegments = getLineSegments (rRotatedBox);
        ListIterator lineIter = mySegments.listIterator ();
        while (lineIter.hasNext ()) {
            LineSeg pSegment = (LineSeg) lineIter.next ();
            if (pSegment.equals (pStartSeg)) {
                rPolyPoints.addPoint (new Point (pSegment.getOrigin ()));
                bFoundStart = true;
            }
            if (pSegment == pEndSeg) {
                PointList newRoutePoints = new PointList (rRotatedBox.size () * MAX_BEZIERLINES);
                LineSeg pCurSeg1 = (LineSeg) boxSegments.get (0);
                LineSeg pCurSeg2 = (LineSeg) boxSegments.get (boxSegments.size () - 1);
                getRoutedPoints (points, newRoutePoints, ptMidStart, ptMidEnd, ptMidStart, ptMidEnd, pCurSeg1, pCurSeg2, rRotatedBox, nSmoothFactor, false, true, 0);
                while (nPointsSinceStart > 0) {
                    rPolyPoints.removePoint (rPolyPoints.size () - 1);
                    nPointsSinceStart --;
                }
                for (int i = 0;
                i < newRoutePoints.size (); i ++) rPolyPoints.addPoint (new Point (newRoutePoints.getPoint (i)));

                rPolyPoints.addPoint (new Point (pSegment.getTerminus ()));
                bFoundEnd = true;
            } else {
                rPolyPoints.addPoint (new Point (pSegment.getOrigin ()));
                if (bFoundStart) nPointsSinceStart ++;

                if (! lineIter.hasNext ()) rPolyPoints.addPoint (new Point (pSegment.getTerminus ()));

            }
        }
        if (bFoundEnd) return rPolyPoints;

        return null;
    }

    static public int findNearestLineSegIndexOfPoint (PointList points, final Point ptCoord) {
        List mySegments = getLineSegments (points);
        ListIterator lineIter = mySegments.listIterator ();
        int nNextIndex = 0;
        int nMinIndex = 0;
        long minDistance = BIGDISTANCE;
        long nextDistance = 0;
        while (lineIter.hasNext ()) {
            LineSeg aSegment = (LineSeg) lineIter.next ();
            nNextIndex ++;
            nextDistance = aSegment.distanceToPoint (ptCoord.x, ptCoord.y);
            if (nextDistance < minDistance) {
                minDistance = nextDistance;
                nMinIndex = nNextIndex;
            }
        }
        return nMinIndex;
    }

    static public boolean findIntersections (PointList points, final PointList poly, PointList intersections, PointList distances) {
        List polySegments = getLineSegments (poly);
        List mySegments = getLineSegments (points);
        Point pLastIntersect = null;
        double dCurrentLength = 0;
        ListIterator segIter = mySegments.listIterator ();
        while (segIter.hasNext ()) {
            LineSeg pSegment = (LineSeg) segIter.next ();
            double dSegLength = pSegment.length ();
            ListIterator polyIter = polySegments.listIterator ();
            while (polyIter.hasNext ()) {
                LineSeg pPolySegment = (LineSeg) polyIter.next ();
                Point ptIntersect = pSegment.intersect (pPolySegment, INTERSECT_TOLERANCE);
                if (ptIntersect != null) {
                    boolean bAddIntersect = true;
                    if (pLastIntersect != null) {
                        if (Math.abs (pLastIntersect.x - ptIntersect.x) < (INTERSECT_TOLERANCE * 2) && Math.abs (pLastIntersect.y - ptIntersect.y) < (INTERSECT_TOLERANCE * 2)) bAddIntersect = false;

                    }
                    if (bAddIntersect) {
                        pLastIntersect = new Point (ptIntersect);
                        intersections.addPoint (pLastIntersect);
                        Point ptDistance = new Point (0, 0);
                        ptDistance.x = (int) Math.round (dCurrentLength + pSegment.distanceAlong (ptIntersect) * dSegLength);
                        distances.addPoint (ptDistance);
                    }
                }
            }
            dCurrentLength += dSegLength;
        }
        return intersections.size () > 0;
    }

    public static Point calculatePointRelativeToLine (PointList pointList, int fromLine, int fromEnd, boolean isPercentage) {
        double fractionDistance = 0;
        if (isPercentage) {
            fractionDistance = fromEnd / 100.0;
        } else {
            fractionDistance = (double) fromEnd / (double) pointList.size ();
        }
        LocateInfo locateInfo = new LocateInfo ();
        if (locateSegment (getLineSegments (pointList), fractionDistance, LineSeg.KeyPoint.ORIGIN, locateInfo)) {
            double inSegPercDist = 0;
            LineSeg seg = locateInfo.theSegment;
            if (seg.length () > 0) inSegPercDist = locateInfo.remainingDist / seg.length ();

            Point location = seg.locatePoint (inSegPercDist, Math.abs (fromLine), (fromLine > 0 ? LineSeg.Sign.POSITIVE : LineSeg.Sign.NEGATIVE));
            return location;
        }
        return null;
    }

    public static Point pickClosestPoint (PointList points, Point p) {
        Point result = points.getFirstPoint ();
        for (int i = 1;
        i < points.size (); i ++) {
            Point temp = points.getPoint (i);
            if (Math.abs (temp.x - p.x) < Math.abs (result.x - p.x)) result = temp;
            else if (Math.abs (temp.y - p.y) < Math.abs (result.y - p.y)) result = temp;

        }
        return result;
    }

    public static Point pickFarestPoint (PointList points, Point p) {
        Point result = points.getFirstPoint ();
        for (int i = 1;
        i < points.size (); i ++) {
            Point temp = points.getPoint (i);
            if (Math.abs (temp.x - p.x) > Math.abs (result.x - p.x)) result = temp;
            else if (Math.abs (temp.y - p.y) > Math.abs (result.y - p.y)) result = temp;

        }
        return result;
    }

    static boolean sameOrientation (Point pt1, Point pt2, Point pt3, int straightLineTolerance) {
        LineSeg line = new LineSeg (pt1, pt3);
        Point pt = line.perpIntersect (pt2.x, pt2.y);
        return Math.round (pt.getDistance (new Point (pt2.x, pt2.y))) < straightLineTolerance;
    }

    public static boolean containsPoint (PointList points, Point point) {
        boolean isOdd = false;
        int [] pointsxy = points.toIntArray ();
        int n = pointsxy.length;
        if (n > 3) {
            int x1, y1;
            int x0 = pointsxy [n - 2];
            int y0 = pointsxy [n - 1];
            for (int i = 0;
            i < n; x0 = x1, y0 = y1) {
                x1 = pointsxy [i ++];
                y1 = pointsxy [i ++];
                if (y0 <= point.y && point.y < y1 && crossProduct (x1, y1, x0, y0, point.x, point.y) > 0) isOdd = ! isOdd;

                if (y1 <= point.y && point.y < y0 && crossProduct (x0, y0, x1, y1, point.x, point.y) > 0) isOdd = ! isOdd;

            }
            if (isOdd) return true;

        }
        return false;
    }

    static private int crossProduct (int ax, int ay, int bx, int by, int cx, int cy) {
        return (ax - cx) * (by - cy) - (ay - cy) * (bx - cx);
    }

}

