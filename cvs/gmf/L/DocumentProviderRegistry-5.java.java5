package org.eclipse.gmf.runtime.diagram.ui.resources.editor.document;

import java.util.ArrayList;

import java.util.Collection;

import java.util.HashMap;

import java.util.HashSet;

import java.util.Hashtable;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import java.util.Set;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.core.runtime.IExtensionPoint;

import org.eclipse.core.runtime.ILog;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.Platform;

import org.eclipse.core.runtime.Status;

import org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.EditorPlugin;

import org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.l10n.EditorMessages;

import org.eclipse.osgi.util.NLS;

import org.eclipse.ui.IEditorInput;

import org.eclipse.ui.PlatformUI;

import org.osgi.framework.Bundle;

import com.ibm.icu.util.StringTokenizer;

public class DocumentProviderRegistry {
    public interface IDocumentProviderSelector {

        public boolean select (String documentType);

    }

    private static DocumentProviderRegistry fgRegistry;

    public static DocumentProviderRegistry getDefault () {
        if (fgRegistry == null) fgRegistry = new DocumentProviderRegistry ();

        return fgRegistry;
    }

    public Map fExtensionMapping = new HashMap ();
    public Map fInputTypeMapping = new HashMap ();
    private Map fInstances = new HashMap ();

    private DocumentProviderRegistry () {
        initialize ();
    }

    private void read (Map map, IConfigurationElement element, String attributeName) {
        String value = element.getAttribute (attributeName);
        if (value != null) {
            StringTokenizer tokenizer = new StringTokenizer (value, ",");
            while (tokenizer.hasMoreTokens ()) {
                String token = tokenizer.nextToken ().trim ();
                Set s = (Set) map.get (token);
                if (s == null) {
                    s = new HashSet ();
                    map.put (token, s);
                }
                s.add (element);
            }
        }
    }

    private void initialize () {
        IExtensionPoint extensionPoint;
        extensionPoint = Platform.getExtensionRegistry ().getExtensionPoint (EditorPlugin.getPluginId (), "documentProviders");
        if (extensionPoint == null) {
            String msg = NLS.bind (EditorMessages.DocumentProviderRegistry_error_extension_point_not_found, PlatformUI.PLUGIN_ID);
            Bundle bundle = Platform.getBundle (EditorPlugin.getPluginId ());
            ILog log = Platform.getLog (bundle);
            log.log (new Status (IStatus.ERROR, PlatformUI.PLUGIN_ID, 0, msg, null));
            return;
        }
        IConfigurationElement [] elements = extensionPoint.getConfigurationElements ();
        for (int i = 0;
        i < elements.length; i ++) {
            read (fExtensionMapping, elements [i], "extensions");
            read (fInputTypeMapping, elements [i], "inputTypes");
        }
    }

    private IDocumentProvider getDocumentProvider (IConfigurationElement entry) {
        IDocumentProvider provider = (IDocumentProvider) fInstances.get (entry);
        if (provider == null) {
            try {
                provider = (IDocumentProvider) entry.createExecutableExtension ("class");
                fInstances.put (entry, provider);
            } catch (CoreException x) {
            }
        }
        return provider;
    }

    private IConfigurationElement selectConfigurationElement (Collection set, IDocumentProviderSelector selector) {
        if (set != null && ! set.isEmpty ()) {
            Iterator e = set.iterator ();
            while (e.hasNext ()) {
                IConfigurationElement element = (IConfigurationElement) e.next ();
                String docTypeClass = element.getAttribute ("documentType");
                if (selector.select (docTypeClass)) return element;

            }
        }
        return null;
    }

    public IDocumentProvider getDocumentProvider (String extension, IDocumentProviderSelector selector) {
        Set set = (Set) fExtensionMapping.get (extension);
        if (set != null) {
            IConfigurationElement entry = selectConfigurationElement (set, selector);
            if (entry != null) return getDocumentProvider (entry);

        }
        return null;
    }

    private List computeClassList (Class type) {
        List result = new ArrayList ();
        Class c = type;
        while (c != null) {
            result.add (c);
            c = c.getSuperclass ();
        }
        return result;
    }

    private List computeInterfaceList (List classes) {
        List result = new ArrayList (4);
        Hashtable visited = new Hashtable (4);
        Iterator e = classes.iterator ();
        while (e.hasNext ()) {
            Class c = (Class) e.next ();
            computeInterfaceList (c.getInterfaces (), result, visited);
        }
        return result;
    }

    private void computeInterfaceList (Class [] interfaces, List result, Hashtable visited) {
        List toBeVisited = new ArrayList (interfaces.length);
        for (int i = 0;
        i < interfaces.length; i ++) {
            Class iface = interfaces [i];
            if (visited.get (iface) == null) {
                visited.put (iface, iface);
                result.add (iface);
                toBeVisited.add (iface);
            }
        }
        Iterator e = toBeVisited.iterator ();
        while (e.hasNext ()) {
            Class iface = (Class) e.next ();
            computeInterfaceList (iface.getInterfaces (), result, visited);
        }
    }

    private Set getFirstInputTypeMapping (List classes) {
        Iterator e = classes.iterator ();
        while (e.hasNext ()) {
            Class c = (Class) e.next ();
            Set mapping = (Set) fInputTypeMapping.get (c.getName ());
            if (mapping != null) return mapping;

        }
        return null;
    }

    private List getInputTypeMappings (List classes) {
        List mappings = new ArrayList ();
        Iterator e = classes.iterator ();
        while (e.hasNext ()) {
            Class c = (Class) e.next ();
            Set mapping = (Set) fInputTypeMapping.get (c.getName ());
            if (mapping != null) mappings.addAll (mapping);

        }
        return mappings;
    }

    protected Set findInputTypeMapping (Class type) {
        if (type == null) return null;

        Set mapping = (Set) fInputTypeMapping.get (type.getName ());
        if (mapping != null) return mapping;

        List classList = computeClassList (type);
        mapping = getFirstInputTypeMapping (classList);
        if (mapping != null) return mapping;

        return getFirstInputTypeMapping (computeInterfaceList (classList));
    }

    private List findInputTypeMappings (Class type) {
        List inputTypeMappings = new ArrayList ();
        if (type == null) return null;

        Set mapping = (Set) fInputTypeMapping.get (type.getName ());
        if (mapping != null) inputTypeMappings.addAll (mapping);

        List classList = computeClassList (type);
        List clsMapping = getInputTypeMappings (classList);
        if (clsMapping != null) inputTypeMappings.addAll (clsMapping);

        inputTypeMappings.addAll (getInputTypeMappings (computeInterfaceList (classList)));
        return inputTypeMappings;
    }

    public IDocumentProvider getDocumentProvider (IEditorInput editorInput, IDocumentProviderSelector selector) {
        IDocumentProvider provider = null;
        IFile file = (IFile) editorInput.getAdapter (IFile.class);
        if (file != null) provider = getDocumentProvider (file.getFileExtension (), selector);

        if (provider == null) {
            List inputTypeMappings = findInputTypeMappings (editorInput.getClass ());
            if (inputTypeMappings != null) {
                IConfigurationElement entry = selectConfigurationElement (inputTypeMappings, selector);
                if (entry != null) provider = getDocumentProvider (entry);

            }
        }
        return provider;
    }

}

