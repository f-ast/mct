package org.eclipse.gmf.runtime.draw2d.ui.internal.graphics;

import java.util.ArrayList;

import java.util.HashMap;

import java.util.List;

import java.util.Map;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.draw2d.FigureUtilities;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.common.core.util.Log;

import org.eclipse.gmf.runtime.draw2d.ui.graphics.GCUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dPlugin;

import org.eclipse.jface.window.Window;

import org.eclipse.swt.SWT;

import org.eclipse.swt.graphics.Color;

import org.eclipse.swt.graphics.Font;

import org.eclipse.swt.graphics.FontData;

import org.eclipse.swt.graphics.FontMetrics;

import org.eclipse.swt.graphics.Image;

import org.eclipse.swt.graphics.TextLayout;

import org.eclipse.swt.graphics.TextStyle;

import org.eclipse.swt.widgets.Display;

public class ScaledGraphics extends Graphics {
    private static class FontHeightCache {
        Font font;
        int height;
    }

    static class FontKey {
        Font font;
        int height;

        protected FontKey () {
        }

        protected FontKey (Font font, int height) {
            this.font = font;
            this.height = height;
        }

        public boolean equals (Object obj) {
            return (((FontKey) obj).font.equals (font) && ((FontKey) obj).height == height);
        }

        public int hashCode () {
            return font.hashCode () ^ height;
        }

        protected void setValues (Font font, int height) {
            this.font = font;
            this.height = height;
        }

    }

    protected static class State {
        private double appliedX;
        private double appliedY;
        private Font font;
        private int lineWidth;
        private double zoom;

        protected State () {
        }

        protected State (double zoom, double x, double y, Font font, int lineWidth) {
            this.zoom = zoom;
            this.appliedX = x;
            this.appliedY = y;
            this.font = font;
            this.lineWidth = lineWidth;
        }

        protected void setValues (double zoom, double x, double y, Font font, int lineWidth) {
            this.zoom = zoom;
            this.appliedX = x;
            this.appliedY = y;
            this.font = font;
            this.lineWidth = lineWidth;
        }

    }

    static private boolean advancedGraphicsWarningLogged = false;
    private static int [] [] intArrayCache = new int [8] [];
    private final Rectangle tempRECT = new Rectangle ();

    static {
        for (int i = 0;
        i < intArrayCache.length; i ++) intArrayCache [i] = new int [i + 1];

    }

    private boolean allowText = true;
    private Map fontDataCache = new HashMap ();
    private FontKey fontKey = new FontKey ();
    private double fractionalX;
    private double fractionalY;
    private Graphics graphics;
    private FontHeightCache localCache = new FontHeightCache ();
    private Font localFont;
    private int localLineWidth;
    private List stack = new ArrayList ();
    private int stackPointer = 0;
    private FontHeightCache targetCache = new FontHeightCache ();
    double zoom = 1.0;

    public ScaledGraphics (Graphics g) {
        graphics = g;
        localFont = g.getFont ();
        localLineWidth = g.getLineWidth ();
    }

    public void clipRect (Rectangle r) {
        graphics.clipRect (zoomClipRect (r));
    }

    Font createFont (FontData data) {
        return new Font (Display.getCurrent (), data);
    }

    public void dispose () {
        while (stackPointer > 0) {
            popState ();
        }
    }

    public void drawArc (int x, int y, int w, int h, int offset, int sweep) {
        Rectangle z = zoomRect (x, y, w, h);
        if (z.isEmpty () || sweep == 0) return;

        graphics.drawArc (z, offset, sweep);
    }

    public void drawFocus (int x, int y, int w, int h) {
        graphics.drawFocus (zoomRect (x, y, w, h));
    }

    public void drawImage (Image srcImage, int x, int y) {
        org.eclipse.swt.graphics.Rectangle size = srcImage.getBounds ();
        Dimension sizeLPDim = new Dimension (size.width, size.height);
        if (graphics instanceof MapModeGraphics) {
            ((MapModeGraphics) graphics).getMapMode ().DPtoLP (sizeLPDim);
        }
        Rectangle z = new Rectangle ((int) (Math.floor ((x * zoom + fractionalX))), (int) (Math.floor ((y * zoom + fractionalY))), (int) (Math.floor ((sizeLPDim.width * zoom + fractionalX))), (int) (Math.floor ((sizeLPDim.height * zoom + fractionalY))));
        graphics.drawImage (srcImage, 0, 0, size.width, size.height, z.x, z.y, z.width, z.height);
    }

    public void drawImage (Image srcImage, int sx, int sy, int sw, int sh, int tx, int ty, int tw, int th) {
        Rectangle t = zoomRect (tx, ty, tw, th);
        if (! t.isEmpty ()) graphics.drawImage (srcImage, sx, sy, sw, sh, t.x, t.y, t.width, t.height);

    }

    public void drawLine (int x1, int y1, int x2, int y2) {
        graphics.drawLine ((int) (Math.floor ((x1 * zoom + fractionalX))), (int) (Math.floor ((y1 * zoom + fractionalY))), (int) (Math.floor ((x2 * zoom + fractionalX))), (int) (Math.floor ((y2 * zoom + fractionalY))));
    }

    public void drawOval (int x, int y, int w, int h) {
        graphics.drawOval (zoomRect (x, y, w, h));
    }

    public void drawPoint (int x, int y) {
        graphics.drawPoint ((int) Math.floor (x * zoom + fractionalX), (int) Math.floor (y * zoom + fractionalY));
    }

    public void drawPolygon (int [] points) {
        graphics.drawPolygon (zoomPointList (points));
    }

    public void drawPolygon (PointList points) {
        graphics.drawPolygon (zoomPointList (points.toIntArray ()));
    }

    public void drawPolyline (int [] points) {
        graphics.drawPolyline (zoomPointList (points));
    }

    public void drawPolyline (PointList points) {
        graphics.drawPolyline (zoomPointList (points.toIntArray ()));
    }

    public void drawRectangle (int x, int y, int w, int h) {
        graphics.drawRectangle (zoomRect (x, y, w, h));
    }

    public void drawRoundRectangle (Rectangle r, int arcWidth, int arcHeight) {
        graphics.drawRoundRectangle (zoomRect (r.x, r.y, r.width, r.height), (int) (arcWidth * zoom), (int) (arcHeight * zoom));
    }

    public void drawString (String s, int x, int y) {
        if (allowText) graphics.drawString (s, zoomTextPoint (x, y));

    }

    public void drawText (String s, int x, int y) {
        if (allowText) graphics.drawText (s, zoomTextPoint (x, y));

    }

    public void drawText (String s, int x, int y, int style) {
        if (allowText) graphics.drawText (s, zoomTextPoint (x, y), style);

    }

    public void drawTextLayout (TextLayout layout, int x, int y, int selectionStart, int selectionEnd, Color selectionForeground, Color selectionBackground) {
        TextLayout scaled = zoomTextLayout (layout);
        graphics.drawTextLayout (scaled, (int) Math.floor (x * zoom + fractionalX), (int) Math.floor (y * zoom + fractionalY), selectionStart, selectionEnd, selectionBackground, selectionForeground);
        scaled.dispose ();
    }

    public void fillArc (int x, int y, int w, int h, int offset, int sweep) {
        Rectangle z = zoomFillRect (x, y, w, h);
        if (z.isEmpty () || sweep == 0) return;

        graphics.fillArc (z, offset, sweep);
    }

    public void fillGradient (int x, int y, int w, int h, boolean vertical) {
        graphics.fillGradient (zoomFillRect (x, y, w, h), vertical);
    }

    public void fillOval (int x, int y, int w, int h) {
        graphics.fillOval (zoomFillRect (x, y, w, h));
    }

    public void fillPolygon (int [] points) {
        graphics.fillPolygon (zoomPointList (points));
    }

    public void fillPolygon (PointList points) {
        graphics.fillPolygon (zoomPointList (points.toIntArray ()));
    }

    public void fillRectangle (int x, int y, int w, int h) {
        graphics.fillRectangle (zoomFillRect (x, y, w, h));
    }

    public void fillRoundRectangle (Rectangle r, int arcWidth, int arcHeight) {
        graphics.fillRoundRectangle (zoomFillRect (r.x, r.y, r.width, r.height), (int) (arcWidth * zoom), (int) (arcHeight * zoom));
    }

    public void fillString (String s, int x, int y) {
        if (allowText) graphics.fillString (s, zoomTextPoint (x, y));

    }

    public void fillText (String s, int x, int y) {
        if (allowText) graphics.fillText (s, zoomTextPoint (x, y));

    }

    public double getAbsoluteScale () {
        return zoom * graphics.getAbsoluteScale ();
    }

    public int getAlpha () {
        return graphics.getAlpha ();
    }

    public int getAntialias () {
        return graphics.getAntialias ();
    }

    public Color getBackgroundColor () {
        return graphics.getBackgroundColor ();
    }

    Font getCachedFont (FontKey key) {
        FontData data = key.font.getFontData () [0];
        data.setHeight (key.height);
        return FontRegistry.getInstance ().getFont (Display.getCurrent (), data);
    }

    static public void resetFontCache () {
        FontRegistry.getInstance ().clearFontCache ();
    }

    FontData getCachedFontData (Font f) {
        FontData data = (FontData) fontDataCache.get (f);
        if (data != null) return data;

        data = getLocalFont ().getFontData () [0];
        fontDataCache.put (f, data);
        return data;
    }

    public Rectangle getClip (Rectangle rect) {
        graphics.getClip (rect);
        int x = (int) (rect.x / zoom);
        int y = (int) (rect.y / zoom);
        rect.width = (int) Math.ceil (rect.right () / zoom) - x;
        rect.height = (int) Math.ceil (rect.bottom () / zoom) - y;
        rect.x = x;
        rect.y = y;
        return rect;
    }

    public int getFillRule () {
        return graphics.getFillRule ();
    }

    public Font getFont () {
        return getLocalFont ();
    }

    public FontMetrics getFontMetrics () {
        return FigureUtilities.getFontMetrics (localFont);
    }

    public Color getForegroundColor () {
        return graphics.getForegroundColor ();
    }

    public int getInterpolation () {
        return graphics.getInterpolation ();
    }

    public int getLineCap () {
        return graphics.getLineCap ();
    }

    public int getLineJoin () {
        return graphics.getLineJoin ();
    }

    public int getLineStyle () {
        return graphics.getLineStyle ();
    }

    public int getLineWidth () {
        return getLocalLineWidth ();
    }

    private Font getLocalFont () {
        return localFont;
    }

    private int getLocalLineWidth () {
        return localLineWidth;
    }

    public int getTextAntialias () {
        return graphics.getTextAntialias ();
    }

    public boolean getXORMode () {
        return graphics.getXORMode ();
    }

    public void popState () {
        graphics.popState ();
        stackPointer --;
        restoreLocalState ((State) stack.get (stackPointer));
    }

    public void pushState () {
        State s;
        if (stack.size () > stackPointer) {
            s = (State) stack.get (stackPointer);
            s.setValues (zoom, fractionalX, fractionalY, getLocalFont (), localLineWidth);
        } else {
            stack.add (new State (zoom, fractionalX, fractionalY, getLocalFont (), localLineWidth));
        }
        stackPointer ++;
        graphics.pushState ();
    }

    private void restoreLocalState (State state) {
        this.fractionalX = state.appliedX;
        this.fractionalY = state.appliedY;
        setScale (state.zoom);
        setLocalFont (state.font);
        setLocalLineWidth (state.lineWidth);
    }

    public void restoreState () {
        graphics.restoreState ();
        restoreLocalState ((State) stack.get (stackPointer - 1));
    }

    public void scale (double amount) {
        setScale (zoom * amount);
    }

    public void setAlpha (int alpha) {
        if (! GCUtilities.supportsAdvancedGraphics ()) {
            logAdvancedGraphicsWarning ();
            return;
        }
        graphics.setAlpha (alpha);
    }

    public void setAntialias (int value) {
        if (! GCUtilities.supportsAdvancedGraphics ()) {
            logAdvancedGraphicsWarning ();
            return;
        }
        graphics.setAntialias (value);
    }

    public void setBackgroundColor (Color rgb) {
        graphics.setBackgroundColor (rgb);
    }

    public void setClip (Rectangle r) {
        graphics.setClip (zoomClipRect (r));
    }

    public void setFillRule (int rule) {
        graphics.setFillRule (rule);
    }

    public void setFont (Font f) {
        setLocalFont (f);
    }

    public void setForegroundColor (Color rgb) {
        graphics.setForegroundColor (rgb);
    }

    public void setInterpolation (int interpolation) {
        if (! GCUtilities.supportsAdvancedGraphics ()) {
            logAdvancedGraphicsWarning ();
            return;
        }
        graphics.setInterpolation (interpolation);
    }

    public void setLineCap (int cap) {
        graphics.setLineCap (cap);
    }

    public void setLineDash (int [] dash) {
        graphics.setLineDash (dash);
    }

    public void setLineJoin (int join) {
        graphics.setLineJoin (join);
    }

    public void setLineStyle (int style) {
        graphics.setLineStyle (style);
    }

    public void setLineWidth (int width) {
        setLocalLineWidth (width);
    }

    private void setLocalFont (Font f) {
        localFont = f;
        graphics.setFont (zoomFont (f));
    }

    private void setLocalLineWidth (int width) {
        localLineWidth = width;
        graphics.setLineWidth (zoomLineWidth (width));
    }

    void setScale (double value) {
        if (zoom == value) return;

        this.zoom = value;
        graphics.setFont (zoomFont (getLocalFont ()));
        graphics.setLineWidth (zoomLineWidth (localLineWidth));
    }

    public void setTextAntialias (int value) {
        if (! GCUtilities.supportsAdvancedGraphics ()) {
            logAdvancedGraphicsWarning ();
            return;
        }
        graphics.setTextAntialias (value);
    }

    public void setXORMode (boolean b) {
        graphics.setXORMode (b);
    }

    public void translate (int dx, int dy) {
        double dxFloat = dx * zoom + fractionalX;
        double dyFloat = dy * zoom + fractionalY;
        fractionalX = dxFloat - Math.floor (dxFloat);
        fractionalY = dyFloat - Math.floor (dyFloat);
        graphics.translate ((int) Math.floor (dxFloat), (int) Math.floor (dyFloat));
    }

    private Rectangle zoomClipRect (Rectangle r) {
        tempRECT.x = (int) (Math.floor (r.x * zoom + fractionalX));
        tempRECT.y = (int) (Math.floor (r.y * zoom + fractionalY));
        tempRECT.width = (int) (Math.ceil (((r.x + r.width) * zoom + fractionalX))) - tempRECT.x;
        tempRECT.height = (int) (Math.ceil (((r.y + r.height) * zoom + fractionalY))) - tempRECT.y;
        return tempRECT;
    }

    private Rectangle zoomFillRect (int x, int y, int w, int h) {
        tempRECT.x = (int) (Math.floor ((x * zoom + fractionalX)));
        tempRECT.y = (int) (Math.floor ((y * zoom + fractionalY)));
        tempRECT.width = (int) (Math.floor (((x + w - 1) * zoom + fractionalX))) - tempRECT.x + 1;
        tempRECT.height = (int) (Math.floor (((y + h - 1) * zoom + fractionalY))) - tempRECT.y + 1;
        return tempRECT;
    }

    Font zoomFont (Font f) {
        if (f == null) f = Display.getCurrent ().getSystemFont ();

        FontData data = getCachedFontData (f);
        int zoomedFontHeight = zoomFontHeight (data.getHeight ());
        allowText = zoomedFontHeight > 0;
        fontKey.setValues (f, zoomedFontHeight);
        return getCachedFont (fontKey);
    }

    int zoomFontHeight (int height) {
        return (int) (zoom * height);
    }

    int zoomLineWidth (int w) {
        if (zoom < 0.04 && w < 25) {
            return w;
        }
        return (int) ((zoom * w) + 0.1);
    }

    private int [] zoomPointList (int [] points) {
        int [] scaled = null;
        for (int i = 0;
        i < intArrayCache.length; i ++) {
            if (intArrayCache [i].length == points.length) {
                scaled = intArrayCache [i];
                if (i != 0) {
                    int [] temp = intArrayCache [i - 1];
                    intArrayCache [i - 1] = scaled;
                    intArrayCache [i] = temp;
                }
            }
        }
        if (scaled == null) {
            intArrayCache [intArrayCache.length - 1] = new int [points.length];
            scaled = intArrayCache [intArrayCache.length - 1];
        }
        for (int i = 0;
        (i + 1) < points.length; i += 2) {
            scaled [i] = (int) (Math.floor ((points [i] * zoom + fractionalX)));
            scaled [i + 1] = (int) (Math.floor ((points [i + 1] * zoom + fractionalY)));
        }
        return scaled;
    }

    protected Rectangle zoomRect (int x, int y, int w, int h) {
        tempRECT.x = (int) (Math.floor (x * zoom + fractionalX));
        tempRECT.y = (int) (Math.floor (y * zoom + fractionalY));
        tempRECT.width = (int) (Math.floor (((x + w) * zoom + fractionalX))) - tempRECT.x;
        tempRECT.height = (int) (Math.floor (((y + h) * zoom + fractionalY))) - tempRECT.y;
        return tempRECT;
    }

    private TextLayout zoomTextLayout (TextLayout layout) {
        TextLayout zoomed = new TextLayout (Display.getCurrent ());
        zoomed.setText (layout.getText ());
        int zoomWidth = - 1;
        if (layout.getWidth () != - 1) zoomWidth = ((int) (layout.getWidth () * zoom));

        if (zoomWidth < - 1 || zoomWidth == 0) return null;

        zoomed.setFont (zoomFont (layout.getFont ()));
        zoomed.setAlignment (layout.getAlignment ());
        zoomed.setAscent (layout.getAscent ());
        zoomed.setDescent (layout.getDescent ());
        zoomed.setOrientation (layout.getOrientation ());
        zoomed.setSegments (layout.getSegments ());
        zoomed.setSpacing (layout.getSpacing ());
        zoomed.setTabs (layout.getTabs ());
        zoomed.setWidth (zoomWidth);
        int length = layout.getText ().length ();
        if (length > 0) {
            int start = 0, offset = 1;
            TextStyle style = null, lastStyle = layout.getStyle (0);
            for (; offset <= length; offset ++) {
                if (offset != length && (style = layout.getStyle (offset)) == lastStyle) continue;

                int end = offset - 1;
                if (lastStyle != null) {
                    TextStyle zoomedStyle = new TextStyle (zoomFont (lastStyle.font), lastStyle.foreground, lastStyle.background);
                    zoomedStyle.metrics = lastStyle.metrics;
                    zoomedStyle.rise = lastStyle.rise;
                    zoomedStyle.strikeout = lastStyle.strikeout;
                    zoomedStyle.underline = lastStyle.underline;
                    zoomed.setStyle (zoomedStyle, start, end);
                }
                lastStyle = style;
                start = offset;
            }
        }
        return zoomed;
    }

    Point zoomTextPoint (int x, int y) {
        if (localCache.font != localFont) {
            FontMetrics metric = FigureUtilities.getFontMetrics (localFont);
            localCache.height = metric.getHeight () - metric.getDescent ();
            localCache.font = localFont;
        }
        if (targetCache.font != graphics.getFont ()) {
            FontMetrics metric = graphics.getFontMetrics ();
            targetCache.font = graphics.getFont ();
            targetCache.height = metric.getHeight () - metric.getDescent ();
        }
        return new Point (((int) (Math.floor ((x * zoom) + fractionalX))), (int) (Math.floor ((y + localCache.height - 1) * zoom - targetCache.height + 1 + fractionalY)));
    }

    protected Graphics getGraphics () {
        return graphics;
    }

    private void logAdvancedGraphicsWarning () {
        if (! advancedGraphicsWarningLogged) {
            if (Window.getDefaultOrientation () == SWT.RIGHT_TO_LEFT) {
                Log.warning (Draw2dPlugin.getInstance (), IStatus.WARNING, "Advanced graphics support is not available in right-to-left mode.  Diagrams might not look as nice as they could in left-to-right mode.");
            } else {
                Log.warning (Draw2dPlugin.getInstance (), IStatus.WARNING, "Unable to load advanced graphics library.  Diagrams might not look as nice as they could with an advanced graphics library installed (e.g. Cairo or GDI+)");
            }
            advancedGraphicsWarningLogged = true;
        }
    }

}

