package org.eclipse.gmf.runtime.diagram.ui.editparts;

import java.beans.PropertyChangeEvent;

import java.beans.PropertyChangeListener;

import java.util.ArrayList;

import java.util.Collections;

import java.util.HashSet;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import java.util.Set;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.ConnectionAnchor;

import org.eclipse.draw2d.FigureCanvas;

import org.eclipse.draw2d.FigureListener;

import org.eclipse.draw2d.FreeformLayout;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.LayoutAnimator;

import org.eclipse.draw2d.LayoutManager;

import org.eclipse.draw2d.RangeModel;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.gef.CompoundSnapToHelper;

import org.eclipse.gef.ConnectionEditPart;

import org.eclipse.gef.DragTracker;

import org.eclipse.gef.EditPart;

import org.eclipse.gef.EditPartListener;

import org.eclipse.gef.EditPartViewer;

import org.eclipse.gef.EditPolicy;

import org.eclipse.gef.Request;

import org.eclipse.gef.SnapToGeometry;

import org.eclipse.gef.SnapToGrid;

import org.eclipse.gef.SnapToGuides;

import org.eclipse.gef.SnapToHelper;

import org.eclipse.gef.editpolicies.SnapFeedbackPolicy;

import org.eclipse.gef.requests.SelectionRequest;

import org.eclipse.gef.rulers.RulerProvider;

import org.eclipse.gef.tools.DeselectAllTracker;

import org.eclipse.gmf.runtime.diagram.core.listener.NotificationUtil;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ContainerEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ContainerNodeEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CreationEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.PopupBarEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ShapeCompartmentDropEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.XYLayoutEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.figures.ShapeCompartmentFigure;

import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.ISurfaceEditPart;

import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.DiagramLinkDragDropEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.internal.tools.RubberbandDragTracker;

import org.eclipse.gmf.runtime.diagram.ui.layout.FreeFormLayoutEx;

import org.eclipse.gmf.runtime.notation.Diagram;

import org.eclipse.gmf.runtime.notation.Edge;

import org.eclipse.gmf.runtime.notation.NotationPackage;

import org.eclipse.gmf.runtime.notation.View;

import org.eclipse.swt.widgets.Display;

public abstract class ShapeCompartmentEditPart extends ResizableCompartmentEditPart implements ISurfaceEditPart, PropertyChangeListener {
    private ConnectionRefreshMgr _crMgr;
    private boolean _refreshQueued = false;
    private boolean isSupportingViewActions = false;
    private EditPartListener editpartListener = new EditPartListener.Stub () {
        private FigureListener childFigureListener = new FigureListener () {

            public void figureMoved (IFigure source) {
                refreshConnections ();
            }

        }

        ;

        public void childAdded (EditPart child, int index) {
            ((GraphicalEditPart) child).getFigure ().addFigureListener (childFigureListener);
        }

        public void removingChild (EditPart child, int index) {
            ((GraphicalEditPart) child).getFigure ().removeFigureListener (childFigureListener);
        }

    }

    ;
    public static class ConnectionRefreshMgr {

        protected void refreshConnections (ShapeCompartmentEditPart scep) {
            Iterator connectionNodes = getConnectionNodes (scep).iterator ();
            while (connectionNodes.hasNext ()) {
                ConnectionNodeEditPart cep = (ConnectionNodeEditPart) connectionNodes.next ();
                Connection connection = (Connection) cep.getFigure ();
                IGraphicalEditPart source = (IGraphicalEditPart) getSourceEditPart (cep);
                IGraphicalEditPart target = (IGraphicalEditPart) getTargetEditPart (cep);
                ShapeCompartmentEditPart sContainer = getOwningShapeCompartment (source);
                ShapeCompartmentEditPart tContainer = getOwningShapeCompartment (target);
                if (sContainer == null && tContainer == null) {
                    continue;
                }
                boolean sfVisible = source != null;
                boolean tfVisible = target != null;
                ConnectionAnchor sc = cep.getSourceConnectionAnchor ();
                ConnectionAnchor tc = cep.getTargetConnectionAnchor ();
                Point sLoc = sc.getLocation (tc.getReferencePoint ());
                Point tLoc = tc.getLocation (sc.getReferencePoint ());
                Diagram diagram = ((View) scep.getModel ()).getDiagram ();
                Map registry = scep.getViewer ().getEditPartRegistry ();
                IGraphicalEditPart dep = (IGraphicalEditPart) registry.get (diagram);
                IFigure stopFigure = dep == null ? null : dep.getContentPane ();
                boolean noSource = false;
                boolean noTarget = false;
                if (sContainer != null) {
                    ShapeCompartmentFigure fig = sContainer.getShapeCompartmentFigure ();
                    noSource = ! fig.isVisible ();
                    sfVisible = isFigureVisible (fig, sLoc, stopFigure);
                    if (! sfVisible) {
                        sfVisible = isBorderItem (sContainer, source);
                    }
                }
                if (tContainer != null) {
                    ShapeCompartmentFigure fig = tContainer.getShapeCompartmentFigure ();
                    noTarget = ! fig.isVisible ();
                    tfVisible = isFigureVisible (fig, tLoc, stopFigure);
                    if (! tfVisible) {
                        tfVisible = isBorderItem (tContainer, target);
                    }
                }
                if (noSource || noTarget) {
                    if (noSource && cep.getTarget () != null) cep.getTarget ().refresh ();

                    if (noTarget && cep.getSource () != null) cep.getSource ().refresh ();

                } else {
                    connection.setVisible (sfVisible && tfVisible);
                    refreshConnectionEnds (cep);
                }
            }
        }

        private void refreshConnectionEnds (ConnectionEditPart cEP) {
            EditPart srcEditPart = cEP.getSource ();
            EditPart trgEditPart = cEP.getTarget ();
            Object model = cEP.getModel ();
            if (model instanceof Edge) {
                Edge edge = (Edge) model;
                View source = edge.getSource ();
                View target = edge.getTarget ();
                if (srcEditPart == null) {
                    refreshEditPart (cEP.getViewer (), source);
                }
                if (trgEditPart == null) {
                    refreshEditPart (cEP.getViewer (), target);
                }
            }
        }

        private void refreshEditPart (EditPartViewer viewer, View view) {
            EditPart ep = (EditPart) viewer.getEditPartRegistry ().get (view);
            if (ep != null) {
                ep.refresh ();
            }
        }

        protected Set getConnectionNodes (ShapeCompartmentEditPart scep) {
            Set endPoints = new HashSet ();
            Object modelObject = scep.getModel ();
            if (scep.getViewer () == null || modelObject == null || ! (modelObject instanceof View)) {
                return endPoints;
            }
            if (((View) modelObject).getDiagram () == null) return endPoints;

            Diagram diagram = ((View) modelObject).getDiagram ();
            Map registry = scep.getViewer ().getEditPartRegistry ();
            List edges = diagram.getEdges ();
            Iterator edgesIterator = edges.iterator ();
            while (edgesIterator.hasNext ()) {
                Edge edge = (Edge) edgesIterator.next ();
                EditPart endPoint = (EditPart) registry.get (edge.getSource ());
                if (isChildOf (scep, endPoint)) {
                    Object cep = registry.get (edge);
                    if (cep != null) {
                        endPoints.add (cep);
                    }
                    continue;
                }
                endPoint = (EditPart) registry.get (edge.getTarget ());
                if (isChildOf (scep, endPoint)) {
                    Object cep = registry.get (edge);
                    if (cep != null) {
                        endPoints.add (cep);
                    }
                }
            }
            return endPoints;
        }

        protected boolean isChildOf (EditPart parent, EditPart child) {
            EditPart walker = child;
            while (walker != null && walker != parent) {
                walker = walker.getParent ();
            }
            return walker != null;
        }

        protected ShapeCompartmentEditPart getOwningShapeCompartment (EditPart ep) {
            EditPart walker = ep;
            while (walker != null && ! (walker instanceof ShapeCompartmentEditPart)) {
                walker = walker.getParent ();
            }
            return (ShapeCompartmentEditPart) walker;
        }

        protected boolean isBorderItem (ShapeCompartmentEditPart scep, IGraphicalEditPart itemEditPart) {
            return false;
        }

        protected EditPart getSourceEditPart (ConnectionEditPart connectionEditPart) {
            return connectionEditPart.getSource ();
        }

        protected EditPart getTargetEditPart (ConnectionEditPart connectionEditPart) {
            return connectionEditPart.getTarget ();
        }

        protected List getSourceConnections (IGraphicalEditPart editPart) {
            return editPart.getSourceConnections ();
        }

        protected List getTargetConnections (IGraphicalEditPart editPart) {
            return editPart.getTargetConnections ();
        }

        protected boolean isFigureVisible (final IFigure figure, final Point loc) {
            return isFigureVisible (figure, loc, null);
        }

        protected boolean isFigureVisible (final IFigure figure, final Point loc, final IFigure stopFigure) {
            if (! (figure.isVisible ())) {
                return false;
            } else {
                Rectangle bounds = figure.getBounds ().getCopy ();
                figure.translateToAbsolute (bounds);
                if (! (bounds.contains (loc))) {
                    return false;
                }
            }
            IFigure parent = figure.getParent ();
            while (parent != null && parent != stopFigure) {
                return isFigureVisible (parent, loc, stopFigure);
            }
            return true;
        }

    }

    public ShapeCompartmentEditPart (View view) {
        super (view);
    }

    protected final ConnectionRefreshMgr getConnectionRefreshMgr () {
        if (_crMgr == null) {
            _crMgr = createConnectionRefreshMgr ();
        }
        return _crMgr;
    }

    protected ConnectionRefreshMgr createConnectionRefreshMgr () {
        return new ConnectionRefreshMgr ();
    }

    protected LayoutManager getLayoutManager () {
        return new FreeFormLayoutEx ();
    }

    protected IFigure createFigure () {
        ShapeCompartmentFigure scf = new ShapeCompartmentFigure (getCompartmentName (), getMapMode ());
        scf.getContentPane ().setLayoutManager (getLayoutManager ());
        scf.getContentPane ().addLayoutListener (LayoutAnimator.getDefault ());
        return scf;
    }

    public ShapeCompartmentFigure getShapeCompartmentFigure () {
        return (ShapeCompartmentFigure) getCompartmentFigure ();
    }

    public IFigure getContentPane () {
        return getShapeCompartmentFigure ().getContentPane ();
    }

    protected void createDefaultEditPolicies () {
        super.createDefaultEditPolicies ();
        installEditPolicy (EditPolicyRoles.CREATION_ROLE, new CreationEditPolicy ());
        installEditPolicy (EditPolicy.LAYOUT_ROLE, new XYLayoutEditPolicy ());
        installEditPolicy (EditPolicy.CONTAINER_ROLE, new ContainerEditPolicy ());
        installEditPolicy (EditPolicyRoles.DRAG_DROP_ROLE, new DiagramLinkDragDropEditPolicy ());
        installEditPolicy (EditPolicy.GRAPHICAL_NODE_ROLE, new ContainerNodeEditPolicy ());
        installEditPolicy (EditPolicyRoles.SNAP_FEEDBACK_ROLE, new SnapFeedbackPolicy ());
        installEditPolicy (EditPolicyRoles.DRAG_DROP_ROLE, new ShapeCompartmentDropEditPolicy ());
        installEditPolicy (EditPolicyRoles.POPUPBAR_ROLE, new PopupBarEditPolicy ());
    }

    protected void handlePropertyChangeEvent (PropertyChangeEvent event) {
        String pName = event.getPropertyName ();
        if (RangeModel.PROPERTY_EXTENT.equals (pName) || RangeModel.PROPERTY_VALUE.equals (pName)) {
            refreshConnections ();
        }
    }

    protected void handleNotificationEvent (Notification event) {
        Object feature = event.getFeature ();
        if (NotationPackage.eINSTANCE.getSize_Width ().equals (feature) || NotationPackage.eINSTANCE.getSize_Height ().equals (feature)) {
            refreshConnections ();
        } else super.handleNotificationEvent (event);

        if (NotificationUtil.isElementAddedToSlot (event) || NotificationUtil.isElementRemovedFromSlot (event)) {
            refreshConnections ();
        }
    }

    protected void refreshConnections () {
        if (! _refreshQueued) {
            _refreshQueued = true;
            Display.getDefault ().asyncExec (new Runnable () {

                public void run () {
                    forceRefreshConnections ();
                }

            }

            );
        }
    }

    protected void forceRefreshConnections () {
        try {
            if (ShapeCompartmentEditPart.this.isActive ()) {
                getConnectionRefreshMgr ().refreshConnections (ShapeCompartmentEditPart.this);
            }
        } finally {
            ShapeCompartmentEditPart.this._refreshQueued = false;
        }
    }

    protected void unregister () {
        super.unregister ();
        getShapeCompartmentFigure ().removePropertyChangeListener (this);
        EditPartViewer viewer = getViewer ();
        if (viewer != null && viewer.getControl () instanceof FigureCanvas) {
            FigureCanvas figureCanvas = (FigureCanvas) viewer.getControl ();
            figureCanvas.getViewport ().getVerticalRangeModel ().removePropertyChangeListener (this);
            figureCanvas.getViewport ().getHorizontalRangeModel ().removePropertyChangeListener (this);
        }
    }

    protected void registerVisuals () {
        super.registerVisuals ();
        getShapeCompartmentFigure ().addPropertyChangeListener (this);
        EditPartViewer viewer = getViewer ();
        if (viewer != null && viewer.getControl () instanceof FigureCanvas) {
            FigureCanvas figureCanvas = (FigureCanvas) viewer.getControl ();
            figureCanvas.getViewport ().getVerticalRangeModel ().addPropertyChangeListener (this);
            figureCanvas.getViewport ().getHorizontalRangeModel ().addPropertyChangeListener (this);
        }
    }

    protected boolean supportsDragSelection () {
        return true;
    }

    public DragTracker getDragTracker (Request req) {
        if (! supportsDragSelection ()) return super.getDragTracker (req);

        if (req instanceof SelectionRequest && ((SelectionRequest) req).getLastButtonPressed () == 3) return new DeselectAllTracker (this) {

            protected boolean handleButtonDown (int button) {
                getCurrentViewer ().select (ShapeCompartmentEditPart.this);
                return true;
            }

        }

        ;

        return new RubberbandDragTracker () {

            protected void handleFinished () {
                if (getViewer ().getSelectedEditParts ().isEmpty ()) getViewer ().select (ShapeCompartmentEditPart.this);

            }

        }

        ;
    }

    public Object getAdapter (Class adapter) {
        if (adapter == SnapToHelper.class) {
            List snapStrategies = new ArrayList ();
            Boolean val = (Boolean) getViewer ().getProperty (RulerProvider.PROPERTY_RULER_VISIBILITY);
            if (val != null && val.booleanValue ()) snapStrategies.add (new SnapToGuides (this));

            val = (Boolean) getViewer ().getProperty (SnapToGeometry.PROPERTY_SNAP_ENABLED);
            if (val != null && val.booleanValue ()) snapStrategies.add (new SnapToGrid ((GraphicalEditPart) this.getParent ()));

            if (snapStrategies.size () == 0) return null;

            if (snapStrategies.size () == 1) return snapStrategies.get (0);

            SnapToHelper ss [] = new SnapToHelper [snapStrategies.size ()];
            for (int i = 0;
            i < snapStrategies.size (); i ++) ss [i] = (SnapToHelper) snapStrategies.get (i);

            return new CompoundSnapToHelper (ss);
        }
        return super.getAdapter (adapter);
    }

    protected void refreshVisibility () {
        super.refreshVisibility ();
        View view = getNotationView ();
        if (view != null && ! view.isVisible ()) forceRefreshConnections ();
        else refreshConnections ();

    }

    public boolean isSupportingViewActions () {
        return this.isSupportingViewActions;
    }

    public void setIsSupportingViewActions (boolean supportsViewActions) {
        this.isSupportingViewActions = supportsViewActions;
    }

    public final void propertyChange (PropertyChangeEvent event) {
        if (isActive ()) handlePropertyChangeEvent (event);

    }

    public List getPrimaryEditParts () {
        List connections = new ArrayList ();
        Object diagramEditPart = getViewer ().getEditPartRegistry ().get (getDiagramView ());
        List shapes = getChildren ();
        Set connectableEditParts = new HashSet (shapes);
        Iterator iter = shapes.iterator ();
        while (iter.hasNext ()) {
            getBorderItemEditParts ((EditPart) iter.next (), connectableEditParts);
        }
        if (diagramEditPart instanceof DiagramEditPart) {
            Iterator diagramConnections = ((DiagramEditPart) diagramEditPart).getConnections ().iterator ();
            while (diagramConnections.hasNext ()) {
                ConnectionEditPart connection = (ConnectionEditPart) diagramConnections.next ();
                if (connectableEditParts.contains (connection.getSource ()) || connectableEditParts.contains (connection.getTarget ())) connections.add (connection);

            }
        }
        if (connections.size () > 0 || shapes.size () > 0) {
            List primaryEditParts = new ArrayList ();
            primaryEditParts.addAll (shapes);
            primaryEditParts.addAll (connections);
            return primaryEditParts;
        }
        return Collections.EMPTY_LIST;
    }

    private void getBorderItemEditParts (EditPart parent, Set retval) {
        Iterator iter = parent.getChildren ().iterator ();
        while (iter.hasNext ()) {
            EditPart child = (EditPart) iter.next ();
            if (child instanceof IBorderItemEditPart) {
                retval.add (child);
                retval.addAll (child.getChildren ());
            }
            getBorderItemEditParts (child, retval);
        }
    }

    public void addNotify () {
        addEditPartListener (editpartListener);
        super.addNotify ();
    }

    public void removeNotify () {
        removeEditPartListener (editpartListener);
        super.removeNotify ();
    }

}

