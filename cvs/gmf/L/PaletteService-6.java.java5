package org.eclipse.gmf.runtime.diagram.ui.services.palette;

import java.util.HashMap;

import java.util.Iterator;

import java.util.List;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.gef.palette.PaletteContainer;

import org.eclipse.gef.palette.PaletteEntry;

import org.eclipse.gef.palette.PaletteRoot;

import org.eclipse.gef.palette.SelectionToolEntry;

import org.eclipse.gef.palette.ToolEntry;

import org.eclipse.gmf.runtime.common.core.service.ExecutionStrategy;

import org.eclipse.gmf.runtime.common.core.service.IOperation;

import org.eclipse.gmf.runtime.common.core.service.IProvider;

import org.eclipse.gmf.runtime.common.core.service.Service;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.common.ui.services.util.ActivityFilterProviderDescriptor;

import org.eclipse.gmf.runtime.diagram.ui.DiagramUIDebugOptions;

import org.eclipse.gmf.runtime.diagram.ui.DiagramUIPlugin;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.ContributeToPaletteOperation;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.IPaletteProvider;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.PaletteProviderConfiguration;

import org.eclipse.gmf.runtime.diagram.ui.internal.util.DiagramMEditingDomainGetter;

import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;

import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;

import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteGroup;

import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteSeparator;

import org.eclipse.jface.util.Assert;

import org.eclipse.ui.IEditorPart;

public class PaletteService extends Service implements IPaletteProvider {
    protected static class ProviderDescriptor extends ActivityFilterProviderDescriptor {
        private PaletteProviderConfiguration providerConfiguration;

        public ProviderDescriptor (IConfigurationElement element) {
            super (element);
            this.providerConfiguration = PaletteProviderConfiguration.parse (element);
            Assert.isNotNull (providerConfiguration);
        }

        public boolean provides (IOperation operation) {
            if (! super.provides (operation)) {
                return false;
            }
            if (getPolicy () != null) return getPolicy ().provides (operation);

            if (operation instanceof ContributeToPaletteOperation) {
                ContributeToPaletteOperation o = (ContributeToPaletteOperation) operation;
                return providerConfiguration.supports (o.getEditor (), o.getContent ());
            }
            return false;
        }

        public IProvider getProvider () {
            if (provider == null) {
                IProvider newProvider = super.getProvider ();
                if (provider instanceof IPaletteProvider) {
                    IPaletteProvider defaultProvider = (IPaletteProvider) newProvider;
                    defaultProvider.setContributions (getElement ());
                }
                return newProvider;
            }
            return super.getProvider ();
        }

    }

    public void setContributions (IConfigurationElement configElement) {
    }

    private final static PaletteService instance = new PaletteService ();

    static {
        instance.configureProviders (DiagramUIPlugin.getPluginId (), "paletteProviders");
    }

    public final static String GROUP_STANDARD = "standardGroup";
    public final static String SEPARATOR_STANDARD = "standardSeparator";
    public final static String TOOL_SELECTION = "selectionTool";

    protected PaletteService () {
        super ();
    }

    public static PaletteService getInstance () {
        return instance;
    }

    protected Service.ProviderDescriptor newProviderDescriptor (IConfigurationElement element) {
        return new ProviderDescriptor (element);
    }

    public void contributeToPalette (IEditorPart editor, Object content, PaletteRoot root) {
        PaletteGroup standardGroup = new PaletteGroup (GROUP_STANDARD, PresentationResourceManager.getI18NString ("StandardGroup.Label"));
        standardGroup.setDescription (PresentationResourceManager.getI18NString ("StandardGroup.Description"));
        root.add (standardGroup);
        PaletteSeparator standardSeparator = new PaletteSeparator (SEPARATOR_STANDARD);
        standardGroup.add (standardSeparator);
        ToolEntry selectTool = new SelectionToolEntry ();
        selectTool.setId (TOOL_SELECTION);
        standardGroup.add (selectTool);
        root.setDefaultEntry (selectTool);
        execute (new ContributeToPaletteOperation (editor, content, root));
    }

    private List execute (IOperation operation) {
        return execute (ExecutionStrategy.REVERSE, operation);
    }

    public PaletteRoot createPalette (final IEditorPart editor, final Object content) {
        final PaletteRoot root = new PaletteRoot ();
        try {
            DiagramMEditingDomainGetter.getMEditingDomain (editor).runAsRead (new MRunnable () {

                public Object run () {
                    contributeToPalette (editor, content, root);
                    return null;
                }

            }

            );
        } catch (Exception e) {
            Trace.catching (DiagramUIPlugin.getInstance (), DiagramUIDebugOptions.EXCEPTIONS_CATCHING, PaletteService.class, "createPalette()", e);
        }
        return root;
    }

    public void updatePalette (PaletteRoot existingRoot, final IEditorPart editor, final Object content) {
        PaletteRoot newRoot = createPalette (editor, content);
        updatePaletteContainerEntries (existingRoot, newRoot);
    }

    private void updatePaletteContainerEntries (PaletteContainer existingContainer, PaletteContainer newContainer) {
        HashMap existingEntryIds = new HashMap ();
        for (Iterator iter = existingContainer.getChildren ().iterator ();
        iter.hasNext ();) {
            PaletteEntry entry = (PaletteEntry) iter.next ();
            existingEntryIds.put (entry.getId (), entry);
        }
        int lastExistingEntryIndex = 0;
        for (Iterator iter = newContainer.getChildren ().iterator ();
        iter.hasNext ();) {
            PaletteEntry newEntry = (PaletteEntry) iter.next ();
            PaletteEntry existingEntry = (PaletteEntry) existingEntryIds.get (newEntry.getId ());
            if (existingEntry != null) {
                lastExistingEntryIndex = existingContainer.getChildren ().indexOf (existingEntry);
                existingEntryIds.remove (existingEntry.getId ());
                if (existingEntry instanceof PaletteContainer && newEntry instanceof PaletteContainer) {
                    updatePaletteContainerEntries ((PaletteContainer) existingEntry, (PaletteContainer) newEntry);
                }
            } else {
                existingContainer.add (++ lastExistingEntryIndex, newEntry);
            }
        }
        for (Iterator iter = existingEntryIds.values ().iterator ();
        iter.hasNext ();) {
            PaletteEntry entry = (PaletteEntry) iter.next ();
            existingContainer.remove (entry);
        }
    }

}

