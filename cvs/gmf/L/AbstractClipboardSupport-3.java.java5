package org.eclipse.gmf.runtime.emf.clipboard.core;

import java.util.Collection;

import java.util.Collections;

import java.util.Iterator;

import java.util.Map;

import java.util.Set;

import org.eclipse.emf.ecore.EAttribute;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.EReference;

import org.eclipse.emf.ecore.EStructuralFeature;

import org.eclipse.emf.ecore.EcorePackage;

import org.eclipse.emf.ecore.xmi.XMLResource;

public class AbstractClipboardSupport implements IClipboardSupport {
    private static final Object NULL_TOKEN = Boolean.FALSE;
    private final Map nameFeatureMap = new java.util.HashMap ();

    public AbstractClipboardSupport () {
        super ();
    }

    public PasteAction getPasteCollisionAction (EClass eClass) {
        return PasteAction.ADD;
    }

    public boolean hasPasteOption (EObject contextEObject, EStructuralFeature eStructuralFeature, PasteOption pasteOption) {
        if (pasteOption.equals (PasteOption.NORMAL)) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isCopyAlways (EObject context, EReference eReference, Object value) {
        if ((eReference.isTransient ()) || (eReference.isDerived ())) {
            return false;
        } else {
            return eReference.isContainment ();
        }
    }

    public boolean shouldOverrideChildPasteOperation (EObject parentElement, EObject childEObject) {
        return false;
    }

    public boolean shouldOverrideCopyOperation (Collection eObjects, Map hintMap) {
        return false;
    }

    public OverridePasteChildOperation getOverrideChildPasteOperation (PasteChildOperation overriddenChildPasteOperation) {
        return null;
    }

    public OverrideCopyOperation getOverrideCopyOperation (CopyOperation overriddenCopyOperation) {
        return null;
    }

    public Collection getExcludedCopyObjects (Set eObjects) {
        return Collections.EMPTY_SET;
    }

    public XMLResource getResource (EObject eObject) {
        return (XMLResource) eObject.eResource ();
    }

    public boolean shouldSaveContainmentFeature (EObject eObject) {
        if (EcorePackage.eINSTANCE == eObject.eClass ().getEPackage ()) {
            return false;
        }
        try {
            eObject.eResource ().getURIFragment (eObject);
        } catch (Exception ex) {
            return false;
        }
        return true;
    }

    public void performPostPasteProcessing (Set pastedEObjects) {
    }

    protected EAttribute getNameAttribute (EClass eClass) {
        EAttribute result = null;
        Object value = nameFeatureMap.get (eClass);
        if (value != NULL_TOKEN) {
            result = (EAttribute) value;
            if (result == null) {
                nameFeatureMap.put (eClass, NULL_TOKEN);
                for (Iterator iter = eClass.getEAllAttributes ().iterator ();
                iter.hasNext ();) {
                    EAttribute next = (EAttribute) iter.next ();
                    if ((next.getEType ().getInstanceClass () == String.class) && ! next.isMany () && "name".equalsIgnoreCase (next.getName ())) {
                        result = next;
                        nameFeatureMap.put (eClass, result);
                        break;
                    }
                }
            }
        }
        return result;
    }

    public boolean isNameable (EObject eObject) {
        return getNameAttribute (eObject.eClass ()) != null;
    }

    public String getName (EObject eObject) {
        EAttribute attr = getNameAttribute (eObject.eClass ());
        if (attr == null) {
            throw new IllegalArgumentException ("eObject not nameable");
        }
        return (String) eObject.eGet (attr);
    }

    public void setName (EObject eObject, String name) {
        EAttribute attr = getNameAttribute (eObject.eClass ());
        if (attr == null) {
            throw new IllegalArgumentException ("eObject not nameable");
        }
        eObject.eSet (attr, name);
    }

    public void destroy (EObject eObject) {
        EObject container = eObject.eContainer ();
        if (container != null) {
            EReference ref = eObject.eContainmentFeature ();
            if (ref != null) {
                if (ref.isMany ()) {
                    ((Collection) container.eGet (ref)).remove (eObject);
                } else {
                    container.eSet (ref, null);
                }
            }
        }
    }

    public void sendCreateNotification (EObject eObject) {
    }

    public boolean canContain (EObject container, EReference reference, EClass containedType) {
        return reference.getEContainingClass ().isSuperTypeOf (container.eClass ()) && reference.getEReferenceType ().isSuperTypeOf (containedType);
    }

}

