package org.eclipse.gmf.runtime.emf.clipboard.core.internal;

import java.io.ByteArrayInputStream;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.Collection;

import java.util.Collections;

import java.util.HashMap;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import org.eclipse.emf.common.util.TreeIterator;

import org.eclipse.emf.common.util.URI;

import org.eclipse.emf.ecore.EAnnotation;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.EReference;

import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.util.EObjectWithInverseEList;

import org.eclipse.emf.ecore.util.EcoreUtil;

import org.eclipse.emf.ecore.xmi.XMLResource;

import org.eclipse.gmf.runtime.emf.clipboard.core.BasePasteOperation;

import org.eclipse.gmf.runtime.emf.clipboard.core.ClipboardSupportUtil;

import org.eclipse.gmf.runtime.emf.clipboard.core.ClipboardUtil;

import org.eclipse.gmf.runtime.emf.clipboard.core.ObjectInfo;

import org.eclipse.gmf.runtime.emf.clipboard.core.PasteChildOperation;

import org.eclipse.gmf.runtime.emf.clipboard.core.PasteTarget;

import org.eclipse.gmf.runtime.emf.clipboard.core.internal.l10n.EMFClipboardCoreMessages;

public class PasteIntoParentOperation extends BasePasteOperation {
    private PasteTarget element;
    private LoadingEMFResource eLoadedResource;
    private Map childPasteProcessMap;
    private List originalChildObjectInfo;
    private XMLResource parentResource;
    private List containmentAnnotationReferences;
    private EAnnotation serializationAnnotation;
    private Map contentObject2ProxyMap;
    private Map hintsMap = Collections.EMPTY_MAP;

    public final XMLResource getParentResource () {
        if (parentResource == null) {
            if (element.isResource ()) {
                parentResource = (XMLResource) element.getObject ();
            } else {
                parentResource = getClipboardOperationHelper ().getResource (getEObject ());
            }
        }
        return parentResource;
    }

    final LoadingEMFResource getLoadedResource () {
        return eLoadedResource;
    }

    public EObject getLoadedEObject (String objId) {
        return (EObject) getLoadedResource ().getIDToEObjectMapCopy ().get (objId);
    }

    public String getLoadedEObjectID (EObject eObject) {
        return (String) getLoadedResource ().getEObjectToIDMapCopy ().get (eObject);
    }

    public Map getHintsMap () {
        return hintsMap;
    }

    public PasteIntoParentOperation (PasteOperation pasteProcess, PasteTarget element, Map hintsMap) throws Exception {
        super (pasteProcess);
        this.element = element;
        this.hintsMap = hintsMap;
        childPasteProcessMap = new HashMap ();
        eLoadedResource = loadEObjects ();
        if (getHintsMap ().containsKey (ClipboardUtil.IGNORE_RECYCLE_HINT_ID) == false) {
            Iterator childEObjectInfoIt = getOriginalChildObjectInfo ().iterator ();
            while (childEObjectInfoIt.hasNext ()) {
                ObjectInfo objectInfo = (ObjectInfo) childEObjectInfoIt.next ();
                if (objectInfo.hasHint (ClipboardUtil.RECYCLE_HINT_ID) && findDuplicateGUID (getLoadedEObject (objectInfo.objId))) {
                    throwException ("PasteIntoParentOperation", new IllegalArgumentException (EMFClipboardCoreMessages.copypaste_duplicateId));
                }
            }
        }
        getContentObject2ProxyMap ();
    }

    private PasteIntoParentOperation (PasteIntoParentOperation pasteIntoParentOperation, PasteTarget element) {
        super (pasteIntoParentOperation);
        this.element = element;
        this.hintsMap = pasteIntoParentOperation.getHintsMap ();
        childPasteProcessMap = pasteIntoParentOperation.childPasteProcessMap;
        eLoadedResource = pasteIntoParentOperation.getLoadedResource ();
        originalChildObjectInfo = pasteIntoParentOperation.getOriginalChildObjectInfo ();
        parentResource = pasteIntoParentOperation.getParentResource ();
        containmentAnnotationReferences = pasteIntoParentOperation.getContainmentAnnotationReferences ();
        serializationAnnotation = pasteIntoParentOperation.getSerializationAnnotation ();
        contentObject2ProxyMap = pasteIntoParentOperation.getContentObject2ProxyMap ();
    }

    private boolean findDuplicateGUID (EObject toPaste) {
        XMLResource parentRes = getParentResource ();
        EObject original = (EObject) getContentObject2ProxyMap ().get (toPaste);
        URI sourceUri = (original == null) ? null : EcoreUtil.getURI (original).trimFragment ();
        boolean result = false;
        if (! parentRes.getURI ().equals (sourceUri)) {
            Iterator iter = EcoreUtil.getAllContents (Collections.singleton (toPaste));
            while (! result && iter.hasNext ()) {
                result = parentRes.getEObject (getLoadedEObjectID ((EObject) iter.next ())) != null;
            }
        }
        return result;
    }

    public PasteIntoParentOperation clone (EObject newElement) {
        return new PasteIntoParentOperation (this, new PasteTarget (newElement));
    }

    private void performPostPasteOperations (List operations) throws Exception {
        if (operations.isEmpty () == false) {
            List postPasteOperations = new ArrayList ();
            Iterator it = operations.iterator ();
            while (it.hasNext ()) {
                getProgressMonitor ().worked (WORK_UNIT);
                if (isCancelled ()) {
                    throwCancelException ();
                }
                PasteChildOperation pasteOperation = (PasteChildOperation) it.next ();
                pasteOperation.paste ();
                PasteChildOperation postPasteOperation = pasteOperation.getPostPasteOperation ();
                if (postPasteOperation != null) {
                    postPasteOperations.add (postPasteOperation);
                }
            }
            performPostPasteOperations (postPasteOperations);
        }
    }

    private void resolveLocalProxies () {
        Iterator it = getLoadedResource ().getContents ().iterator ();
        while (it.hasNext ()) {
            EObject eObj = (EObject) it.next ();
            if ((eObj instanceof EAnnotation) == false) {
                resolveLocalProxies (eObj);
                Iterator contentIt = eObj.eAllContents ();
                while (contentIt.hasNext ()) {
                    resolveLocalProxies ((EObject) contentIt.next ());
                }
            }
        }
    }

    private void resolveLocalProxies (EObject eObject) {
        Iterator it = eObject.eClass ().getEAllReferences ().iterator ();
        EReference ref = null;
        while (it.hasNext ()) {
            ref = (EReference) it.next ();
            if ((ref.isContainment () == false) && ref.isChangeable ()) {
                Object value = eObject.eGet (ref, true);
                if (ref.isMany ()) {
                    Collection collection = (Collection) value;
                    boolean withInverseElist = (collection instanceof EObjectWithInverseEList);
                    Iterator valIt = new ArrayList (collection).iterator ();
                    while (valIt.hasNext ()) {
                        EObject eObj = (EObject) valIt.next ();
                        if (eObj.eIsProxy ()) {
                            EObject resolved = ClipboardSupportUtil.resolve (eObj, getLoadedResource ().getIDToEObjectMapCopy ());
                            if (resolved.eIsProxy () == false) {
                                if (collection.contains (resolved)) {
                                    collection.remove (eObj);
                                } else {
                                    EcoreUtil.replace (eObject, ref, eObj, resolved);
                                }
                            } else if (withInverseElist) {
                                collection.remove (eObj);
                            }

                        }
                    }
                } else if (value != null) {
                    EObject eObj = (EObject) value;
                    if (eObj.eIsProxy ()) {
                        EObject resolved = ClipboardSupportUtil.resolve (eObj, getLoadedResource ().getIDToEObjectMapCopy ());
                        if (resolved.eIsProxy () == false) {
                            EcoreUtil.replace (eObject, ref, eObj, resolved);
                        }
                    }
                }

            }
        }
    }

    public void paste () throws Exception {
        try {
            resolveLocalProxies ();
            Iterator childEObjectInfoIt = getOriginalChildObjectInfo ().iterator ();
            List postPasteOperations = new ArrayList ();
            while (childEObjectInfoIt.hasNext ()) {
                getProgressMonitor ().worked (WORK_UNIT);
                if (isCancelled ()) {
                    throwCancelException ();
                }
                ObjectInfo objectInfo = (ObjectInfo) childEObjectInfoIt.next ();
                PasteChildOperation childPasteProcess = getChildPasteProcess (objectInfo);
                childPasteProcess.paste ();
                PasteChildOperation postPasteOperation = childPasteProcess.getPostPasteOperation ();
                if (postPasteOperation != null) {
                    postPasteOperations.add (postPasteOperation);
                }
            }
            performPostPasteOperations (postPasteOperations);
            if (getPastedElementSet ().isEmpty () == false) {
                getProgressMonitor ().worked (WORK_UNIT);
                if (isCancelled ()) {
                    throwCancelException ();
                }
                resolveReferences ();
                if (getCriticalResolveFailuresSet ().isEmpty ()) {
                    recycleObjectIds ();
                }
                fireCreateEvents ();
            }
        } finally {
            if (getLoadedResource () != null) {
                getLoadedResource ().unload ();
            }
        }
    }

    private void fireCreateEvents () {
        List elements = new ArrayList ();
        Iterator it = EcoreUtil.getAllContents (getPastedElementSet ());
        while (it.hasNext ()) {
            elements.add (it.next ());
        }
        elements.removeAll (getPastedElementSet ());
        it = elements.iterator ();
        while (it.hasNext ()) {
            ClipboardSupportUtil.sendCreateEvent ((EObject) it.next ());
        }
    }

    private List getOriginalChildObjectInfo () {
        if (originalChildObjectInfo == null) {
            originalChildObjectInfo = getResourceInfo ().getObjectInfoTypes (ObjectCopyType.OBJ_COPY_TYPE_ORIGINAL);
            Collections.sort (originalChildObjectInfo, new ListIndexComparator (getLoadedResource ().getContents ()) {

                public int compare (Object obj_1, Object obj_2) {
                    return super.compare (getLoadedEObject (((ObjectInfo) obj_1).objId), getLoadedEObject (((ObjectInfo) obj_2).objId));
                }

            }

            );
        }
        return originalChildObjectInfo;
    }

    private void recycleObjectIds () {
        if (getHintsMap ().containsKey (ClipboardUtil.IGNORE_RECYCLE_HINT_ID)) {
            return;
        }
        Iterator childEObjectInfoIt = getOriginalChildObjectInfo ().iterator ();
        while (childEObjectInfoIt.hasNext ()) {
            ObjectInfo objectInfo = (ObjectInfo) childEObjectInfoIt.next ();
            if (objectInfo.hasHint (ClipboardUtil.RECYCLE_HINT_ID)) {
                EObject pastedChildElement = getChildPasteProcess (objectInfo).getPastedElement ();
                if (getPastedElementSet ().contains (pastedChildElement)) {
                    recycleObjectId (pastedChildElement);
                    TreeIterator contentIt = pastedChildElement.eAllContents ();
                    while (contentIt.hasNext ()) {
                        recycleObjectId ((EObject) contentIt.next ());
                    }
                }
            }
        }
    }

    private void recycleObjectId (EObject pastedEObject) {
        String newId = getParentResource ().getID (pastedEObject);
        if (newId != null) {
            String originalId = (String) getLoadedEObjectToIDMapCopy ().get (pastedEObject);
            getParentResource ().setID (pastedEObject, originalId);
        } else {
            getParentResource ().setID (pastedEObject, null);
        }
    }

    private LoadingEMFResource loadEObjects () throws Exception {
        ByteArrayInputStream inputStream = new ByteArrayInputStream (getResourceInfo ().data.getBytes (getResourceInfo ().encoding));
        LoadingEMFResource resource = new LoadingEMFResource (getParentResource ().getResourceSet (), getResourceInfo ().encoding, getLoadOptionsMap (), getClipboardOperationHelper ());
        resource.load (inputStream, null);
        return resource;
    }

    private PasteChildOperation getChildPasteProcess (ObjectInfo childEObjectInfo) {
        PasteChildOperation originalChildPasteProcess = (PasteChildOperation) childPasteProcessMap.get (childEObjectInfo);
        if (originalChildPasteProcess == null) {
            originalChildPasteProcess = new PasteChildOperation (this, childEObjectInfo);
            childPasteProcessMap.put (childEObjectInfo, originalChildPasteProcess);
        }
        return originalChildPasteProcess;
    }

    private void resolveReferences () {
        Iterator it = getPastedElementSet ().iterator ();
        EObject pastedEObject = null;
        while (it.hasNext ()) {
            pastedEObject = (EObject) it.next ();
            checkReferences (pastedEObject);
            TreeIterator contentIt = pastedEObject.eAllContents ();
            while (contentIt.hasNext ()) {
                checkReferences ((EObject) contentIt.next ());
            }
        }
    }

    private void checkReferences (EObject pastedEObject) {
        List references = pastedEObject.eClass ().getEAllReferences ();
        Iterator refIt = references.iterator ();
        EReference reference = null;
        while (refIt.hasNext ()) {
            reference = (EReference) refIt.next ();
            if (! reference.isContainment () && ! reference.isContainer () && reference.isChangeable ()) {
                if (reference.isMany ()) {
                    if (! pastedEObject.eIsSet (reference)) {
                        continue;
                    }
                    Collection currentList = (Collection) pastedEObject.eGet (reference);
                    if (currentList.isEmpty ()) {
                        continue;
                    }
                    Object [] currentValues = currentList.toArray ();
                    resolveProxyReferences (currentValues);
                    currentValues = removeNullEntries (currentValues);
                    checkMergedElements (currentValues);
                    List checkedList = Arrays.asList (currentValues);
                    if (currentList.equals (checkedList) == false) {
                        ClipboardSupportUtil.setEObjectList (pastedEObject, reference, checkedList);
                    }
                } else {
                    Object currentValue = pastedEObject.eGet (reference);
                    if (currentValue == null) {
                        continue;
                    }
                    Object [] currentValues = new Object [] {currentValue};
                    resolveProxyReferences (currentValues);
                    if (currentValues [0] == null) {
                        ClipboardSupportUtil.destroyEObject (pastedEObject, reference);
                    } else {
                        checkMergedElements (currentValues);
                        if (currentValues [0] != currentValue) {
                            ClipboardSupportUtil.setEObject (pastedEObject, reference, (EObject) currentValues [0]);
                        }
                    }
                }
            }
        }
    }

    private Object [] removeNullEntries (Object [] objects) {
        List newList = new ArrayList ();
        for (int i = 0;
        i < objects.length; ++ i) {
            if (objects [i] != null) {
                newList.add (objects [i]);
            }
        }
        return newList.toArray ();
    }

    private void resolveProxyReferences (Object [] currentValues) {
        EObject val = null;
        EObject resolvedVal = null;
        for (int i = 0;
        i < currentValues.length; ++ i) {
            boolean replaced = false;
            val = (EObject) currentValues [i];
            if (val.eResource () == getLoadedResource ()) {
                val = (EObject) getContentObject2ProxyMap ().get (val);
                replaced = true;
                if (val == null) {
                    currentValues [i] = null;
                    continue;
                }
            }
            if (val.eIsProxy ()) {
                resolvedVal = ClipboardSupportUtil.resolve (val, getParentResource ());
                if (resolvedVal.eIsProxy ()) {
                    resolvedVal = EcoreUtil.resolve (val, getParentResource ());
                }
                if (resolvedVal.eIsProxy () == false) {
                    currentValues [i] = resolvedVal;
                } else if (replaced) {
                    ((InternalEObject) currentValues [i]).eSetProxyURI (((InternalEObject) val).eProxyURI ());
                }

            }
        }
    }

    private void checkMergedElements (Object [] resolvedReferencedEObjects) {
        for (int i = 0;
        i < resolvedReferencedEObjects.length; ++ i) {
            if (getEObjectID ((EObject) resolvedReferencedEObjects [i]) == null) {
                MergedEObjectInfo info = (MergedEObjectInfo) getAllMergedElementsMap ().get (resolvedReferencedEObjects [i]);
                if (info != null) {
                    if (info.targetEObjects.size () == 1) {
                        resolvedReferencedEObjects [i] = info.targetEObjects.get (0);
                    } else if (info.targetEObjects.size () > 1) {
                        boolean found = false;
                        Iterator it = info.targetEObjects.iterator ();
                        while (it.hasNext ()) {
                            EObject mergeTarget = (EObject) it.next ();
                            if (isChild (mergeTarget)) {
                                resolvedReferencedEObjects [i] = mergeTarget;
                                found = true;
                                break;
                            }
                        }
                        if (found == false) {
                            resolvedReferencedEObjects [i] = info.targetEObjects.get (0);
                        }
                    }

                }
            }
        }
    }

    public final EObject getEObject () {
        if (! element.isResource ()) {
            return (EObject) element.getObject ();
        }
        return null;
    }

    public final PasteTarget getPasteTarget () {
        return element;
    }

    public Map getLoadedEObjectToIDMapCopy () {
        return getLoadedResource ().getEObjectToIDMapCopy ();
    }

    public Map getLoadedIDToEObjectMapCopy () {
        return getLoadedResource ().getIDToEObjectMapCopy ();
    }

    public EObject getEObject (String objId) {
        return getParentResource ().getEObject (objId);
    }

    public String getEObjectID (EObject eObject) {
        return getParentResource ().getID (eObject);
    }

    protected boolean isChild (EObject eObject) {
        return (eObject != null) ? ClipboardSupportUtil.isChild (getEObject (), eObject) : false;
    }

    public EReference getContainmentFeature (EObject eObject) {
        Iterator it = getContainmentAnnotationReferences ().iterator ();
        while (it.hasNext ()) {
            Object obj = it.next ();
            Object ref = it.next ();
            if (eObject.equals (obj)) {
                return (EReference) ref;
            }
        }
        return null;
    }

    private EAnnotation getSerializationAnnotation () {
        if (serializationAnnotation == null) {
            Iterator it = getLoadedResource ().getContents ().iterator ();
            while (it.hasNext ()) {
                Object obj = it.next ();
                if (obj instanceof EAnnotation) {
                    EAnnotation eAnnotation = ((EAnnotation) obj).getEAnnotation (SerializationEMFResource.SERIALIZATION_ANNOTATIONS);
                    if (eAnnotation != null) {
                        serializationAnnotation = eAnnotation;
                        break;
                    }
                }
            }
        }
        return serializationAnnotation;
    }

    private Map getContentObject2ProxyMap () {
        if (contentObject2ProxyMap == null) {
            contentObject2ProxyMap = new HashMap ();
            Iterator annotations = getSerializationAnnotation ().getEAnnotations ().iterator ();
            while (annotations.hasNext ()) {
                EAnnotation ref_obj_Annotation = (EAnnotation) annotations.next ();
                EObject proxy = (EObject) ref_obj_Annotation.getReferences ().get (0);
                EObject eObj = ClipboardSupportUtil.resolve (proxy, getLoadedIDToEObjectMapCopy ());
                assert proxy != eObj : "proxy is the same as eObj";
                contentObject2ProxyMap.put (eObj, proxy);
            }
        }
        return contentObject2ProxyMap;
    }

    protected List getContainmentAnnotationReferences () {
        if (containmentAnnotationReferences == null) {
            containmentAnnotationReferences = new ArrayList ();
            Iterator annotations = getSerializationAnnotation ().getEAnnotations ().iterator ();
            while (annotations.hasNext ()) {
                EAnnotation ref_obj_Annotation = (EAnnotation) annotations.next ();
                if (ref_obj_Annotation.getReferences ().size () >= 2) {
                    EObject eObj = ClipboardSupportUtil.resolve ((EObject) ref_obj_Annotation.getReferences ().get (0), getLoadedIDToEObjectMapCopy ());
                    containmentAnnotationReferences.add (eObj);
                    EObject eRef = EcoreUtil.resolve ((EObject) ref_obj_Annotation.getReferences ().get (1), getParentResource ());
                    containmentAnnotationReferences.add (eRef);
                }
            }
        }
        return containmentAnnotationReferences;
    }

}

