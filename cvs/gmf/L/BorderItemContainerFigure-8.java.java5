package org.eclipse.gmf.runtime.diagram.ui.internal.figures;

import java.util.Iterator;

import java.util.ListIterator;

import org.eclipse.draw2d.ColorConstants;

import org.eclipse.draw2d.Figure;

import org.eclipse.draw2d.FigureListener;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.ScalableFreeformLayeredPane;

import org.eclipse.draw2d.TreeSearch;

import org.eclipse.draw2d.Viewport;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.diagram.ui.figures.BorderItemsAwareFreeFormLayer;

import org.eclipse.gmf.runtime.diagram.ui.figures.BorderItemsUtil;

import org.eclipse.gmf.runtime.diagram.ui.figures.BorderedNodeFigure;

import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;

public class BorderItemContainerFigure extends NodeFigure {
    private Rectangle extendedBounds = new Rectangle ();
    private BorderItemContainerHelper helper = new BorderItemContainerHelper ();

    public BorderItemContainerFigure () {
        super ();
    }

    protected void paintClientArea (Graphics graphics) {
        if (getChildren ().isEmpty () || ! isVisible ()) return;

        Rectangle clip = getVisibleExtendedBounds ();
        graphics.setClip (clip);
        if (useLocalCoordinates ()) {
            graphics.translate (getBounds ().x + getInsets ().left, getBounds ().y + getInsets ().top);
        }
        graphics.pushState ();
        paintChildren (graphics);
        graphics.popState ();
        graphics.restoreState ();
    }

    public Rectangle getHandleBounds () {
        Rectangle handleRect = null;
        ListIterator listIterator = getChildren ().listIterator ();
        while (listIterator.hasNext ()) {
            Object object = listIterator.next ();
            if (object instanceof NodeFigure && ((NodeFigure) object).isVisible ()) {
                if (handleRect == null) {
                    handleRect = ((NodeFigure) object).getHandleBounds ().getCopy ();
                } else {
                    handleRect.union (((NodeFigure) object).getHandleBounds ().getCopy ());
                }
            }
        }
        return handleRect;
    }

    public boolean containsPoint (int x, int y) {
        if (useLocalCoordinates ()) {
            x = x - getBounds ().x - getInsets ().left;
            y = y - getBounds ().y - getInsets ().top;
        }
        for (int i = getChildren ().size ();
        i > 0;) {
            i --;
            IFigure fig = (IFigure) getChildren ().get (i);
            if (fig.containsPoint (x, y)) {
                return true;
            }
        }
        return false;
    }

    protected IFigure findDescendantAtExcluding (int x, int y, TreeSearch search) {
        Point pt = new Point (x, y);
        this.translateFromParent (pt);
        IFigure fig;
        for (int i = getChildren ().size ();
        i > 0;) {
            i --;
            fig = (IFigure) getChildren ().get (i);
            if (fig.isVisible ()) {
                fig = fig.findFigureAt (pt.x, pt.y, search);
                if (fig != null) return fig;

            }
        }
        return null;
    }

    public IFigure findFigureAt (int x, int y, TreeSearch search) {
        if (search.prune (this)) return null;

        IFigure child = findDescendantAtExcluding (x, y, search);
        if (child != null) return child;

        return null;
    }

    public IFigure findMouseEventTargetAt (int x, int y) {
        IFigure f = findMouseEventTargetInDescendantsAt (x, y);
        if (f != null) return f;

        if (isMouseEventTarget ()) return this;

        return null;
    }

    protected IFigure findMouseEventTargetInDescendantsAt (int x, int y) {
        Point pt = new Point (x, y);
        this.translateFromParent (pt);
        IFigure fig;
        for (int i = getChildren ().size ();
        i > 0;) {
            i --;
            fig = (IFigure) getChildren ().get (i);
            if (fig.isVisible () && fig.isEnabled ()) {
                if (fig.containsPoint (pt.x, pt.y)) {
                    fig = fig.findMouseEventTargetAt (pt.x, pt.y);
                    return fig;
                }
            }
        }
        return null;
    }

    public boolean intersects (Rectangle rect) {
        Rectangle rectangle = getExtendedBounds ();
        return rectangle.intersects (rect);
    }

    private Rectangle getVisibleExtendedBounds () {
        Rectangle extendedRect = getExtendedBounds ().getCopy ();
        translateToAbsolute (extendedRect);
        Rectangle parentRect = getViewportBounds ().getIntersection (extendedRect);
        translateToRelative (parentRect);
        return parentRect;
    }

    private Rectangle getViewportBounds () {
        Rectangle rect = getParent ().getParent ().getClientArea ().getCopy ();
        getParent ().getParent ().translateToParent (rect);
        getParent ().getParent ().translateToAbsolute (rect);
        IFigure port = getViewport ();
        if (port != null) {
            Rectangle portRect = port.getClientArea ().getCopy ();
            port.translateToParent (portRect);
            port.translateToAbsolute (portRect);
            if (portRect.height != 0 && portRect.width != 0) {
                rect = portRect;
            }
        }
        return rect;
    }

    public IFigure getMainFigure () {
        return ((BorderedNodeFigure) getParent ()).getMainFigure ();
    }

    private IFigure getViewport () {
        IFigure fig = getMainFigure ();
        while (fig != null) {
            if (fig instanceof Viewport || fig instanceof ScalableFreeformLayeredPane) return fig;

            fig = fig.getParent ();
            if (fig instanceof BorderItemContainerFigure) {
                fig = ((BorderItemContainerFigure) fig).getMainFigure ();
            }
        }
        return null;
    }

    public void erase () {
        if (getChildren ().isEmpty ()) {
            super.erase ();
        } else {
            if (getParent () == null || ! isVisible ()) return;

            repaint ();
        }
    }

    public void repaint () {
        if (getChildren ().isEmpty ()) {
            super.repaint ();
        } else {
            if (getParent () == null || ! isVisible ()) return;

            Rectangle rectBounds = getExtendedBounds ();
            getParent ().getParent ().repaint (rectBounds);
            if (getViewport () != null) {
                getViewport ().repaint (rectBounds);
            }
        }
    }

    public void invalidate () {
        extendedBounds = null;
        super.invalidate ();
        updateLayerExtents ();
    }

    public void validate () {
        extendedBounds = null;
        super.validate ();
    }

    public Rectangle getExtendedBounds () {
        if (extendedBounds == null) {
            extendedBounds = getParent ().getBounds ().getCopy ();
            Iterator iterator = getChildren ().iterator ();
            while (iterator.hasNext ()) {
                Figure childFigure = (Figure) iterator.next ();
                Rectangle childBounds = (childFigure instanceof IExpandableFigure) ? ((IExpandableFigure) childFigure).getExtendedBounds () : childFigure.getBounds ();
                if (useLocalCoordinates ()) {
                    childBounds = childBounds.getCopy ();
                    childBounds.translate (getLocation ());
                }
                extendedBounds.union (childBounds);
            }
        }
        return extendedBounds;
    }

    protected void fireFigureMoved () {
        super.fireFigureMoved ();
        extendedBounds = null;
        updateLayerExtents ();
    }

    private void updateLayerExtents () {
        BorderItemsAwareFreeFormLayer layer = BorderItemsUtil.getBorderItemLayer (this);
        if (layer != null) {
            layer.borderFigureMoved ();
        }
    }

    public void add (IFigure figure, Object constraint, int index) {
        super.add (figure, constraint, index);
        helper.hookChild (figure);
    }

    public void remove (IFigure figure) {
        helper.unhookChild (figure);
        super.remove (figure);
    }

    private class BorderItemContainerHelper {
        class ChildTracker implements FigureListener {

            public void figureMoved (IFigure source) {
                revalidate ();
            }

        }

        private FigureListener figureListener = new ChildTracker ();

        public void hookChild (IFigure child) {
            revalidate ();
            child.addFigureListener (figureListener);
        }

        public void unhookChild (IFigure child) {
            revalidate ();
            child.removeFigureListener (figureListener);
        }

    }

}

