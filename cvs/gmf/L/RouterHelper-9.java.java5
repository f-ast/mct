package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import java.util.Collections;

import java.util.HashSet;

import java.util.Iterator;

import java.util.LinkedList;

import java.util.List;

import java.util.ListIterator;

import java.util.Map;

import java.util.Set;

import java.util.WeakHashMap;

import org.eclipse.draw2d.Bendpoint;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.ConnectionAnchor;

import org.eclipse.draw2d.FigureUtilities;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.ShortestPathConnectionRouter;

import org.eclipse.draw2d.XYLayout;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.PrecisionPoint;

import org.eclipse.draw2d.geometry.Ray;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

class RouterHelper {
    static private RouterHelper sprm = new RouterHelper (false);

    static public RouterHelper getInstance () {
        return sprm;
    }

    private Map routers = new WeakHashMap ();
    private Map lastUsedRouter = new WeakHashMap ();
    private boolean useGEFRouter = false;

    private RouterHelper (boolean useGEFRouter) {
        super ();
        this.useGEFRouter = useGEFRouter;
    }

    public void setConstraint (Connection conn, Object constraint) {
        if (useGEFRouter) {
            ShortestPathConnectionRouter spcr = getRouter (conn);
            if (spcr != null) spcr.setConstraint (conn, constraint);

        }
    }

    public void remove (Connection conn) {
        if (useGEFRouter) {
            ShortestPathConnectionRouter spcr = getRouter (conn);
            if (spcr != null) spcr.remove (conn);

        }
    }

    public void invalidate (Connection conn) {
        if (useGEFRouter) {
            ShortestPathConnectionRouter spcr = getRouter (getSourceContainer (conn));
            if (spcr != null) spcr.invalidate (conn);

        }
    }

    public boolean isFeedback (Connection conn) {
        Dimension dim = new Dimension (100, 100);
        Dimension dimCheck = dim.getCopy ();
        conn.translateToRelative (dimCheck);
        return dim.equals (dimCheck);
    }

    public PointList routeFromConstraint (Connection conn) {
        List bendpoints = (List) conn.getConnectionRouter ().getConstraint (conn);
        if (bendpoints == null) bendpoints = Collections.EMPTY_LIST;

        PointList points = new PointList (bendpoints.size ());
        for (int i = 0;
        i < bendpoints.size (); i ++) {
            Bendpoint bp = (Bendpoint) bendpoints.get (i);
            points.addPoint (bp.getLocation ());
        }
        if (bendpoints.size () == 0) {
            Point r1 = conn.getSourceAnchor ().getReferencePoint ().getCopy ();
            conn.translateToRelative (r1);
            points.addPoint (r1);
            Point r2 = conn.getTargetAnchor ().getReferencePoint ().getCopy ();
            conn.translateToRelative (r2);
            points.addPoint (r2);
        }
        return points;
    }

    public PointList routeClosestDistance (Connection conn) {
        PointList newLine = routeFromConstraint (conn);
        Point ptOrig = new Point (newLine.getFirstPoint ());
        Point ptTerm = new Point (newLine.getLastPoint ());
        newLine.removeAllPoints ();
        newLine.addPoint (ptOrig);
        newLine.addPoint (ptTerm);
        return newLine;
    }

    public PointList routeAroundObstructions (Connection conn) {
        PointList newLine = null;
        if (useGEFRouter) {
            newLine = new PointList ();
            ShortestPathConnectionRouter spcr = RouterHelper.getInstance ().getRouter (conn);
            if (spcr == null) newLine = routeFromConstraint (conn);
            else {
                spcr.route (conn);
                newLine.removeAllPoints ();
                newLine.addAll (conn.getPoints ());
            }
        } else {
            newLine = routeClosestDistance (conn);
            Point infimumPoint = PointListUtilities.getPointsInfimum (newLine);
            Point supremumPoint = PointListUtilities.getPointsSupremum (newLine);
            Ray diameter = new Ray (infimumPoint, supremumPoint);
            Rectangle rPoly = new Rectangle (infimumPoint.x, infimumPoint.y, diameter.x, diameter.y);
            List collectObstructs = new LinkedList ();
            IFigure parent = getRouterContainerFigure (conn);
            if (parent == null) return routeFromConstraint (conn);

            Point ptRef = conn.getSourceAnchor ().getReferencePoint ();
            conn.translateToRelative (ptRef);
            newLine.setPoint (ptRef, 0);
            ptRef = conn.getTargetAnchor ().getReferencePoint ();
            conn.translateToRelative (ptRef);
            newLine.setPoint (ptRef, newLine.size () - 1);
            Rectangle rBoundingRect = new Rectangle (parent.getBounds ());
            parent.translateToAbsolute (rBoundingRect);
            conn.translateToRelative (rBoundingRect);
            if (rPoly.width > rPoly.height) {
                rPoly.y = rBoundingRect.y;
                rPoly.setSize (rPoly.width, rBoundingRect.height);
            } else {
                rPoly.x = rBoundingRect.x;
                rPoly.setSize (rBoundingRect.width, rPoly.height);
            }
            collectObstructions (conn, rPoly, collectObstructs);
            if (collectObstructs.size () > 0) {
                Dimension buffer = new Dimension (ROUTER_OBSTRUCTION_BUFFER + 1, 0);
                if (! isFeedback (conn)) buffer = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (buffer);

                final int inflate = buffer.width;
                List collapsedRects = collapseRects (collectObstructs, inflate);
                collectObstructs.clear ();
                boolean bRouted = true;
                while (bRouted && ! collapsedRects.isEmpty ()) {
                    ListIterator listIter = collapsedRects.listIterator ();
                    bRouted = false;
                    while (listIter.hasNext ()) {
                        Rectangle rObstruct = (Rectangle) listIter.next ();
                        PointList routedPoly = PointListUtilities.routeAroundRect (newLine, rObstruct, 0, false, inflate);
                        if (routedPoly != null) {
                            bRouted = true;
                            newLine.removeAllPoints ();
                            newLine.addAll (routedPoly);
                        } else collectObstructs.add (rObstruct);

                    }
                    List tempList = collapsedRects;
                    collapsedRects = collectObstructs;
                    tempList.clear ();
                    collectObstructs = tempList;
                    if (bRouted && ! collapsedRects.isEmpty ()) resetEndPointsToEdge (conn, newLine);

                }
            }
        }
        return newLine;
    }

    protected void collectObstructions (Connection connection, Rectangle connectionRect, List obstructionsToReturn) {
        Set containerFiguresToSearch = new HashSet ();
        Set figuresToExclude = new HashSet ();
        IFigure figure = connection.getSourceAnchor ().getOwner ();
        figuresToExclude.add (figure);
        figure = figure.getParent ();
        while (figure != null) {
            if (figure.getLayoutManager () instanceof XYLayout) {
                containerFiguresToSearch.add (figure);
            }
            figuresToExclude.add (figure);
            figure = figure.getParent ();
        }
        figure = connection.getTargetAnchor ().getOwner ();
        figuresToExclude.add (figure);
        figure = figure.getParent ();
        while (figure != null) {
            if (figure.getLayoutManager () instanceof XYLayout) {
                containerFiguresToSearch.add (figure);
            }
            figuresToExclude.add (figure);
            figure = figure.getParent ();
        }
        for (Iterator iter = containerFiguresToSearch.iterator ();
        iter.hasNext ();) {
            IFigure containerFigure = (IFigure) iter.next ();
            for (Iterator iterator = containerFigure.getChildren ().iterator ();
            iterator.hasNext ();) {
                IFigure childFigure = (IFigure) iterator.next ();
                if (! figuresToExclude.contains (childFigure)) {
                    Rectangle rObstruct = new Rectangle (childFigure.getBounds ());
                    childFigure.translateToAbsolute (rObstruct);
                    connection.translateToRelative (rObstruct);
                    rObstruct.expand (1, 1);
                    if (connectionRect.intersects (rObstruct)) {
                        obstructionsToReturn.add (rObstruct);
                    }
                }
            }
        }
    }

    public void resetEndPointsToEdge (Connection conn, PointList newLine) {
        if (newLine.size () < 2) {
            newLine.addPoint (0, 0);
            newLine.insertPoint (new Point (), 0);
        }
        PrecisionPoint sourceAnchorPoint, targetAnchorPoint;
        if (newLine.size () > 2) {
            PrecisionPoint sourceReference = new PrecisionPoint (newLine.getPoint (1));
            PrecisionPoint targetReference = new PrecisionPoint (newLine.getPoint (newLine.size () - 2));
            conn.translateToAbsolute (sourceReference);
            conn.translateToAbsolute (targetReference);
            sourceAnchorPoint = getAnchorLocation (conn.getSourceAnchor (), sourceReference);
            targetAnchorPoint = getAnchorLocation (conn.getTargetAnchor (), targetReference);
        } else {
            PrecisionPoint sourceReference = getAnchorReference (conn.getTargetAnchor ());
            sourceAnchorPoint = getAnchorLocation (conn.getSourceAnchor (), sourceReference);
            targetAnchorPoint = getAnchorLocation (conn.getTargetAnchor (), sourceAnchorPoint);
        }
        conn.translateToRelative (sourceAnchorPoint);
        conn.translateToRelative (targetAnchorPoint);
        newLine.setPoint (new Point (Math.round (sourceAnchorPoint.preciseX), Math.round (sourceAnchorPoint.preciseY)), 0);
        newLine.setPoint (new Point (Math.round (targetAnchorPoint.preciseX), Math.round (targetAnchorPoint.preciseY)), newLine.size () - 1);
    }

    private final static int ROUTER_OBSTRUCTION_BUFFER = 12;

    private List collapseRects (List collectRect, int inflate) {
        if (collectRect.size () == 0) return new LinkedList ();

        Rectangle rCompare = new Rectangle ((Rectangle) collectRect.remove (0));
        List collapsedRects = collapseRects (rCompare, collectRect, inflate);
        collapsedRects.add (rCompare);
        return collapsedRects;
    }

    private List collapseRects (Rectangle rCompare, List collectRect, int inflate) {
        List newCollect = new LinkedList ();
        Rectangle rCompare1 = new Rectangle (rCompare);
        boolean intersectionOccurred = false;
        ListIterator listIter = collectRect.listIterator ();
        while (listIter.hasNext ()) {
            Rectangle rCompare2 = new Rectangle ((Rectangle) listIter.next ());
            Rectangle rExpandRect1 = new Rectangle (rCompare1);
            Rectangle rExpandRect2 = new Rectangle (rCompare2);
            rExpandRect1.expand (inflate, inflate);
            rExpandRect2.expand (inflate, inflate);
            if (rExpandRect1.intersects (rExpandRect2)) {
                rCompare1.union (rCompare2);
                intersectionOccurred = true;
            } else {
                newCollect.add (rCompare2);
            }
        }
        rCompare.setBounds (rCompare1);
        if (newCollect.size () > 0) {
            if (intersectionOccurred) {
                return collapseRects (rCompare, newCollect, inflate);
            } else {
                Rectangle rFirst = new Rectangle ((Rectangle) newCollect.remove (0));
                List finalCollapse = collapseRects (rFirst, newCollect, inflate);
                finalCollapse.add (rFirst);
                return finalCollapse;
            }
        } else {
            return newCollect;
        }
    }

    private IFigure getRouterContainerFigure (Connection conn) {
        IFigure sourcefigContainer = getSourceContainer (conn);
        IFigure targetfigContainer = getTargetContainer (conn);
        IFigure commonFig = FigureUtilities.findCommonAncestor (sourcefigContainer, targetfigContainer);
        IFigure routerContainer = null;
        if (sourcefigContainer == null || targetfigContainer == null) return null;

        if (sourcefigContainer == targetfigContainer) {
            routerContainer = sourcefigContainer;
        } else if (commonFig != sourcefigContainer && commonFig != targetfigContainer) {
            routerContainer = commonFig;
        } else {
            IFigure checkFig = sourcefigContainer;
            if (commonFig == sourcefigContainer) checkFig = targetfigContainer;

            Rectangle checkRect = checkFig.getBounds ().getCopy ();
            checkFig.translateToAbsolute (checkRect);
            conn.translateToRelative (checkRect);
            int sourceDistance = findDistanceToEndRect (conn.getPoints (), checkRect);
            int targetDistance = (int) PointListUtilities.getPointsLength (conn.getPoints ()) - sourceDistance;
            if (sourceDistance > targetDistance) routerContainer = sourcefigContainer;
            else routerContainer = targetfigContainer;

        }

        return routerContainer;
    }

    private ShortestPathConnectionRouter getRouter (Connection conn) {
        IFigure container = getRouterContainerFigure (conn);
        if (container == null) return null;

        ShortestPathConnectionRouter spcr = getRouter (container);
        ShortestPathConnectionRouter lur = (ShortestPathConnectionRouter) lastUsedRouter.get (conn);
        if (lur != spcr) {
            if (lur != null) lur.remove (conn);

            spcr.setConstraint (conn, conn.getRoutingConstraint ());
        }
        lastUsedRouter.put (conn, spcr);
        return spcr;
    }

    private IFigure getSourceContainer (Connection conn) {
        if (conn.getSourceAnchor () != null) return findContainerFigure (conn.getSourceAnchor ().getOwner ());

        return null;
    }

    private IFigure getTargetContainer (Connection conn) {
        if (conn.getTargetAnchor () != null) return findContainerFigure (conn.getTargetAnchor ().getOwner ());

        return null;
    }

    private IFigure findContainerFigure (IFigure fig) {
        if (fig == null) return null;

        if (fig.getLayoutManager () instanceof XYLayout) return fig;

        return findContainerFigure (fig.getParent ());
    }

    private int findDistanceToEndRect (PointList points, Rectangle endRect) {
        PointList intersections = new PointList ();
        PointList distances = new PointList ();
        boolean foundSourceDistance = PointListUtilities.findIntersections (points, PointListUtilities.createPointsFromRect (endRect), intersections, distances);
        int sourceDistance = foundSourceDistance ? distances.getFirstPoint ().x : 0;
        return sourceDistance;
    }

    private ShortestPathConnectionRouter getRouter (IFigure figContainer) {
        ShortestPathConnectionRouter shortestPathRouter = (ShortestPathConnectionRouter) routers.get (figContainer);
        if (shortestPathRouter == null) {
            shortestPathRouter = new ShortestPathConnectionRouter (figContainer);
            shortestPathRouter.setSpacing (MapModeUtil.getMapMode (figContainer).DPtoLP (10));
            routers.put (figContainer, shortestPathRouter);
        }
        return shortestPathRouter;
    }

    private PrecisionPoint getAnchorLocation (ConnectionAnchor anchor, Point reference) {
        return new PrecisionPoint (anchor.getLocation (reference));
    }

    private PrecisionPoint getAnchorReference (ConnectionAnchor anchor) {
        return new PrecisionPoint (anchor.getReferencePoint ());
    }

}

