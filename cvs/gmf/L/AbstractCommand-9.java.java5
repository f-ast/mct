package org.eclipse.gmf.runtime.common.core.command;

import java.util.ArrayList;

import java.util.List;

import org.eclipse.core.commands.ExecutionException;

import org.eclipse.core.commands.operations.AbstractOperation;

import org.eclipse.core.commands.operations.IOperationApprover;

import org.eclipse.core.commands.operations.IUndoContext;

import org.eclipse.core.commands.operations.IUndoableOperation;

import org.eclipse.core.commands.operations.OperationHistoryFactory;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.runtime.IAdaptable;

import org.eclipse.core.runtime.IProgressMonitor;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.NullProgressMonitor;

import org.eclipse.core.runtime.Status;

import org.eclipse.gmf.runtime.common.core.internal.command.ICommandWithSettableResult;

public abstract class AbstractCommand extends AbstractOperation implements ICommand, ICommandWithSettableResult {
    private final List affectedFiles;
    private CommandResult commandResult;

    public AbstractCommand (String label) {
        this (label, null);
    }

    public AbstractCommand (String label, List affectedFiles) {
        super (label);
        if (affectedFiles == null) {
            this.affectedFiles = new ArrayList (2);
        } else {
            this.affectedFiles = affectedFiles;
        }
    }

    public List getAffectedFiles () {
        return affectedFiles;
    }

    public CommandResult getCommandResult () {
        return commandResult;
    }

    protected final void setResult (CommandResult result) {
        this.commandResult = result;
    }

    public ICommand compose (IUndoableOperation operation) {
        if (operation != null) {
            return new CompositeCommand (getLabel ()).compose (this).compose (operation);
        }
        return this;
    }

    public ICommand reduce () {
        return this;
    }

    public IStatus execute (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        IProgressMonitor monitor = progressMonitor != null ? progressMonitor : new NullProgressMonitor ();
        CommandResult result = doExecuteWithResult (monitor, info);
        setResult (result);
        return result != null ? result.getStatus () : Status.OK_STATUS;
    }

    protected abstract CommandResult doExecuteWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException;

    public IStatus redo (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        IProgressMonitor monitor = progressMonitor != null ? progressMonitor : new NullProgressMonitor ();
        CommandResult result = doRedoWithResult (monitor, info);
        setResult (result);
        return result != null ? result.getStatus () : Status.OK_STATUS;
    }

    protected abstract CommandResult doRedoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException;

    public IStatus undo (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        IProgressMonitor monitor = progressMonitor != null ? progressMonitor : new NullProgressMonitor ();
        CommandResult result = doUndoWithResult (monitor, info);
        setResult (result);
        return result != null ? result.getStatus () : Status.OK_STATUS;
    }

    protected abstract CommandResult doUndoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException;

    public void dispose () {
        super.dispose ();
        IUndoContext [] contexts = getContexts ();
        for (int i = 0;
        i < contexts.length; i ++) {
            removeContext (contexts [i]);
        }
    }

    public void internalSetResult (CommandResult result) {
        this.commandResult = result;
    }

}

