package org.eclipse.gmf.runtime.emf.core.internal.resources;

import java.io.File;

import java.io.IOException;

import java.net.URL;

import java.util.Collection;

import java.util.Collections;

import java.util.HashMap;

import java.util.HashSet;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import java.util.Set;

import java.util.StringTokenizer;

import java.util.WeakHashMap;

import java.util.Map.Entry;

import org.eclipse.core.resources.IContainer;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.resources.IPathVariableChangeEvent;

import org.eclipse.core.resources.IPathVariableChangeListener;

import org.eclipse.core.resources.IPathVariableManager;

import org.eclipse.core.resources.ResourcesPlugin;

import org.eclipse.core.runtime.FileLocator;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.core.runtime.IPath;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.Platform;

import org.eclipse.core.runtime.Status;

import org.eclipse.core.runtime.preferences.IEclipsePreferences;

import org.eclipse.core.runtime.preferences.IScopeContext;

import org.eclipse.core.runtime.preferences.InstanceScope;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.common.notify.Notifier;

import org.eclipse.emf.common.notify.impl.AdapterImpl;

import org.eclipse.emf.common.util.URI;

import org.eclipse.emf.ecore.resource.Resource;

import org.eclipse.emf.ecore.resource.ResourceSet;

import org.eclipse.emf.ecore.resource.URIConverter;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCoreDebugOptions;

import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCorePlugin;

import org.eclipse.gmf.runtime.emf.core.internal.util.EMFCoreConstants;

import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;

import org.osgi.framework.Bundle;

import org.osgi.service.prefs.BackingStoreException;

public class PathmapManager extends AdapterImpl {
    private static final String NAME = "name";
    private static final String PLUGIN = "plugin";
    private static final String PATH = "path";
    private static final String NODE_QUALIFIER = EMFCorePlugin.getDefault ().getBundle ().getSymbolicName ();
    private static final String PREFERENCE_KEY = "referenced.path.variables";
    private static final Map PATH_MAP = Collections.synchronizedMap (configure ());
    private static final Map instances = Collections.synchronizedMap (new WeakHashMap ());
    private static Set referencedPathVariablesList;
    private static IEclipsePreferences preferenceStore = null;

    static {
        IPathVariableManager pathManager = ResourcesPlugin.getWorkspace ().getPathVariableManager ();
        IEclipsePreferences preferences = getPreferenceStore ();
        String referencedPathVariables = preferences.get (PREFERENCE_KEY, "");
        StringTokenizer tokenizer = new StringTokenizer (referencedPathVariables, " ");
        referencedPathVariablesList = new HashSet (tokenizer.countTokens ());
        for (; tokenizer.hasMoreTokens ();) {
            String pathVariable = tokenizer.nextToken ();
            addPathVariableReference (pathVariable);
        }
        updatePreferenceStore ();
        pathManager.addChangeListener (new IPathVariableChangeListener () {

            public void pathVariableChanged (IPathVariableChangeEvent event) {
                switch (event.getType ()) {
                    case IPathVariableChangeEvent.VARIABLE_DELETED :
                        removePathVariableReference (event.getVariableName ());
                        updatePreferenceStore ();
                        break;
                    case IPathVariableChangeEvent.VARIABLE_CHANGED :
                        if (referencedPathVariablesList.contains (event.getVariableName ())) {
                            if (! isDirectory (event.getValue ())) {
                                removePathVariableReference (event.getVariableName ());
                            } else {
                                setPathVariable (event.getVariableName (), URI.createFileURI (event.getValue ().toString ()).toString ());
                            }
                            updatePreferenceStore ();
                        }
                        break;
                }
            }

        }

        );
    }

    private static IEclipsePreferences getPreferenceStore () {
        if (preferenceStore == null) {
            IScopeContext ctx = new InstanceScope ();
            preferenceStore = ctx.getNode (NODE_QUALIFIER);
        }
        return preferenceStore;
    }

    public static void addPathVariableReference (String pathVariable) {
        if (referencedPathVariablesList.contains (pathVariable)) {
            return;
        }
        if (! isCompatiblePathVariable (pathVariable)) {
            return;
        }
        IPathVariableManager pathManager = ResourcesPlugin.getWorkspace ().getPathVariableManager ();
        IPath value = pathManager.getValue (pathVariable);
        if (value != null) {
            referencedPathVariablesList.add (pathVariable);
            setPathVariable (pathVariable, URI.createFileURI (value.toString ()).toString ());
        }
    }

    public static void updatePreferenceStore () {
        StringBuffer referencedPathVariables = new StringBuffer ();
        for (Iterator i = referencedPathVariablesList.iterator ();
        i.hasNext ();) {
            referencedPathVariables.append ((String) i.next ());
            referencedPathVariables.append (' ');
        }
        getPreferenceStore ().put (PREFERENCE_KEY, referencedPathVariables.toString ());
        try {
            getPreferenceStore ().flush ();
        } catch (BackingStoreException e) {
            EMFCorePlugin.getDefault ().getLog ().log (new Status (IStatus.ERROR, EMFCorePlugin.getPluginId (), IStatus.ERROR, e.getMessage (), e));
        }
    }

    public static void removePathVariableReference (String pathVariable) {
        if (referencedPathVariablesList.contains (pathVariable)) {
            referencedPathVariablesList.remove (pathVariable);
            removePathVariable (pathVariable);
        }
    }

    public static Set getPathVariableReferences () {
        return Collections.unmodifiableSet (referencedPathVariablesList);
    }

    public static boolean isCompatiblePathVariable (String variable) {
        if (referencedPathVariablesList.contains (variable)) {
            return true;
        }
        IPathVariableManager pathManager = ResourcesPlugin.getWorkspace ().getPathVariableManager ();
        IPath value = pathManager.getValue (variable);
        if (value == null) return false;

        return isDirectory (value);
    }

    private static boolean isDirectory (IPath value) {
        File f = new File (value.toString ());
        return (f.isDirectory ());
    }

    public PathmapManager () {
        super ();
        instances.put (this, Boolean.TRUE);
    }

    private static Set allInstances () {
        return instances.keySet ();
    }

    public static PathmapManager getExistingPathmapManager (ResourceSet rset) {
        PathmapManager result = null;
        List adapters = rset.eAdapters ();
        for (int i = 0, size = adapters.size ();
        (result == null) && (i < size); i ++) {
            Object next = adapters.get (i);
            if (next instanceof PathmapManager) {
                result = (PathmapManager) next;
            }
        }
        return result;
    }

    public static void setPathVariable (String var, String val) {
        java.net.URI valURI = java.net.URI.create (val);
        IContainer [] containers = ResourcesPlugin.getWorkspace ().getRoot ().findContainersForLocationURI (valURI);
        if (containers.length == 1) {
            val = URI.createPlatformResourceURI (containers [0].getFullPath ().toString (), true).toString ();
        }
        IFile [] files = ResourcesPlugin.getWorkspace ().getRoot ().findFilesForLocationURI (valURI);
        if (files.length == 1) {
            val = URI.createPlatformResourceURI (files [0].getFullPath ().toString (), true).toString ();
        }
        PATH_MAP.put (var, val);
        for (Iterator i = allInstances ().iterator ();
        i.hasNext ();) {
            ((PathmapManager) i.next ()).resyncEntries (true);
        }
    }

    public static void removePathVariable (String var) {
        PATH_MAP.remove (var);
        for (Iterator i = allInstances ().iterator ();
        i.hasNext ();) {
            ((PathmapManager) i.next ()).resyncEntries (true);
        }
    }

    private ResourceSet getResourceSet () {
        return (ResourceSet) getTarget ();
    }

    public String getPathVariable (String var) {
        URI varURI = makeURI (var);
        if (varURI != null) {
            URI valURI = (URI) getURIMap ().get (varURI);
            if (valURI != null) {
                String val = valURI.toString ();
                if (val != null) {
                    int len = val.length ();
                    if (len != 0) {
                        if (val.charAt (len - 1) == EMFCoreConstants.PATH_SEPARATOR) val = val.substring (0, len - 1);

                        return val;
                    }
                }
            }
        }
        return EMFCoreConstants.EMPTY_STRING;
    }

    private static Map configure () {
        Map paths = new HashMap ();
        IConfigurationElement [] configs = Platform.getExtensionRegistry ().getExtensionPoint (EMFCorePlugin.getPluginId (), "Pathmaps").getConfigurationElements ();
        for (int i = 0;
        i < configs.length; ++ i) {
            IConfigurationElement element = configs [i];
            String var = element.getAttribute (NAME);
            if ((var == null) || (var.length () == 0)) continue;

            String path = element.getAttribute (PATH);
            if (path == null) path = EMFCoreConstants.EMPTY_STRING;

            String plugin = element.getAttribute (PLUGIN);
            if ((plugin == null) || (plugin.length () == 0)) plugin = element.getDeclaringExtension ().getNamespaceIdentifier ();

            Bundle bundle = Platform.getBundle (plugin);
            if (bundle == null) continue;

            URL url = bundle.getEntry (path);
            if (url == null) continue;

            try {
                url = FileLocator.resolve (url);
                if (url == null) continue;

                paths.put (var, url.toString ());
            } catch (IOException e) {
                Trace.catching (EMFCorePlugin.getDefault (), EMFCoreDebugOptions.EXCEPTIONS_CATCHING, PathmapManager.class, "configure", e);
            }
        }
        return paths;
    }

    public void notifyChanged (Notification msg) {
        if (msg.getFeatureID (ResourceSet.class) == ResourceSet.RESOURCE_SET__RESOURCES) {
            switch (msg.getEventType ()) {
                case Notification.ADD :
                    denormalize ((Resource) msg.getNewValue (), getResourceSet ().getURIConverter ());
                    break;
                case Notification.ADD_MANY :
                    for (Iterator i = ((List) msg.getNewValue ()).iterator ();
                    i.hasNext ();) {
                        denormalize ((Resource) msg.getNewValue (), getResourceSet ().getURIConverter ());
                    }
                    break;
                case Notification.REMOVE :
                    normalize ((Resource) msg.getOldValue (), getResourceSet ().getURIConverter ());
                    break;
                case Notification.REMOVE_MANY :
                    for (Iterator i = ((List) msg.getNewValue ()).iterator ();
                    i.hasNext ();) {
                        normalize ((Resource) msg.getNewValue (), getResourceSet ().getURIConverter ());
                    }
                    break;
            }
        }
    }

    public void setTarget (Notifier newTarget) {
        ResourceSet rset = getResourceSet ();
        if (rset != null) {
            resyncEntries (false);
        }
        super.setTarget (newTarget);
        rset = getResourceSet ();
        if (rset != null) {
            resyncEntries (true);
        }
    }

    private void resyncEntries (boolean resync) {
        Map savedURIs = new HashMap ();
        ResourceSet rset = getResourceSet ();
        if (rset == null) return;

        for (Iterator i = rset.getResources ().iterator ();
        i.hasNext ();) {
            Resource resource = (Resource) i.next ();
            URI uri = resource.getURI ();
            savedURIs.put (resource, uri);
        }
        normalizeAll ();
        Map uriMap = getURIMap ();
        Map savedURIMap = new HashMap ();
        for (Iterator i = uriMap.keySet ().iterator ();
        i.hasNext ();) {
            URI key = (URI) i.next ();
            if ((key != null) && (! EMFCoreConstants.PATH_MAP_SCHEME.equals (key.scheme ()))) savedURIMap.put (key, uriMap.get (key));

        }
        getURIMap ().clear ();
        if (resync) {
            synchronized (PATH_MAP) {
                for (Iterator i = PATH_MAP.entrySet ().iterator ();
                i.hasNext ();) {
                    Map.Entry entry = (Entry) i.next ();
                    addEntry ((String) entry.getKey (), (String) entry.getValue ());
                }
            }
        }
        for (Iterator i = savedURIMap.keySet ().iterator ();
        i.hasNext ();) {
            URI key = (URI) i.next ();
            if (key != null) uriMap.put (key, savedURIMap.get (key));

        }
        if (resync) {
            denormalizeAll ();
        }
        for (Iterator i = rset.getResources ().iterator ();
        i.hasNext ();) {
            Resource resource = (Resource) i.next ();
            URI uri = resource.getURI ();
            URI savedURI = (URI) savedURIs.get (resource);
            if (uri != savedURI) {
                if ((uri != null) && (! uri.equals (savedURI))) {
                    Collection exports = EMFCoreUtil.getExports (resource);
                    for (Iterator j = exports.iterator ();
                    j.hasNext ();) {
                        Resource export = (Resource) j.next ();
                        if (! export.isModified ()) export.setModified (true);

                    }
                }
            }
        }
    }

    private void addEntry (String var, String val) {
        URI varURI = makeURI (var);
        if (varURI != null) {
            int len = val.length ();
            if (len == 0) return;

            StringBuffer uri = new StringBuffer ();
            uri.append (val);
            if (val.charAt (len - 1) != EMFCoreConstants.PATH_SEPARATOR) uri.append (EMFCoreConstants.PATH_SEPARATOR);

            URI valURI = URI.createURI (uri.toString ());
            getURIMap ().put (varURI, valURI);
        }
    }

    private void normalizeAll () {
        ResourceSet rset = getResourceSet ();
        URIConverter converter = rset.getURIConverter ();
        if (converter != null) {
            for (Iterator i = rset.getResources ().iterator ();
            i.hasNext ();) {
                Resource resource = (Resource) i.next ();
                normalize (resource, converter);
            }
        }
    }

    private void normalize (Resource resource, URIConverter converter) {
        URI uri = resource.getURI ();
        if (uri == null) return;

        if ((EMFCoreConstants.PATH_MAP_SCHEME.equals (uri.scheme ())) && (resource instanceof GMFResource)) {
            ((GMFResource) resource).setRawURI (converter.normalize (uri));
        }
    }

    private void denormalizeAll () {
        ResourceSet rset = getResourceSet ();
        URIConverter converter = rset.getURIConverter ();
        if (converter != null) {
            for (Iterator i = rset.getResources ().iterator ();
            i.hasNext ();) {
                Resource resource = (Resource) i.next ();
                denormalize (resource, converter);
            }
        }
    }

    private void denormalize (Resource resource, URIConverter converter) {
        URI uri = resource.getURI ();
        if (uri == null) return;

        if (resource instanceof GMFResource) ((GMFResource) resource).setURI (converter.normalize (uri));

    }

    private static URI makeURI (String var) {
        int len = var.length ();
        if (len == 0) return null;

        StringBuffer uri = new StringBuffer ();
        uri.append (EMFCoreConstants.PATH_MAP_SCHEME);
        uri.append (EMFCoreConstants.SCHEME_SEPARATOR);
        uri.append (EMFCoreConstants.PATH_SEPARATOR);
        uri.append (EMFCoreConstants.PATH_SEPARATOR);
        uri.append (var);
        if (var.charAt (len - 1) != EMFCoreConstants.PATH_SEPARATOR) uri.append (EMFCoreConstants.PATH_SEPARATOR);

        return URI.createURI (uri.toString ());
    }

    private Map getURIMap () {
        return getResourceSet ().getURIConverter ().getURIMap ();
    }

    public static URI denormalizeURI (URI uri) {
        if (! uri.isFile ()) {
            if (! uri.scheme ().equals ("platform")) {
                return uri;
            } else if (! uri.segment (0).equals ("resource")) {
                return uri;
            }

        }
        String uriAsString = uri.toString ();
        String maxValueString = null;
        String maxKey = null;
        synchronized (PATH_MAP) {
            for (Iterator i = PATH_MAP.entrySet ().iterator ();
            i.hasNext ();) {
                Map.Entry entry = (Map.Entry) i.next ();
                String valueString = (String) entry.getValue ();
                if (valueString.endsWith ("/")) {
                    valueString = valueString.substring (0, valueString.length () - 1);
                }
                if (uriAsString.startsWith (valueString) && (maxValueString == null || maxValueString.length () < valueString.length ())) {
                    maxValueString = valueString;
                    maxKey = (String) entry.getKey ();
                }
            }
        }
        if (maxKey != null) {
            URI valueURI = URI.createURI (maxValueString);
            URI pathmapURI = makeURI (maxKey);
            int segmentStart = valueURI.segmentCount ();
            int segmentCount = uri.segmentCount ();
            for (int j = segmentStart;
            j < segmentCount; j ++) {
                pathmapURI = pathmapURI.appendSegment (uri.segment (j));
            }
            return pathmapURI;
        }
        return uri;
    }

}

