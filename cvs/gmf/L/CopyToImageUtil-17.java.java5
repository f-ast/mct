package org.eclipse.gmf.runtime.diagram.ui.render.util;

import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;

import java.io.ByteArrayOutputStream;

import java.io.File;

import java.io.FileOutputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.OutputStream;

import java.util.Collections;

import java.util.List;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.resources.IResource;

import org.eclipse.core.resources.ResourcesPlugin;

import org.eclipse.core.runtime.Assert;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.IPath;

import org.eclipse.core.runtime.IProgressMonitor;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.Status;

import org.eclipse.gmf.runtime.common.core.command.FileModificationValidator;

import org.eclipse.gmf.runtime.common.core.util.Log;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;

import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;

import org.eclipse.gmf.runtime.diagram.ui.OffscreenEditPartFactory;

import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;

import org.eclipse.gmf.runtime.diagram.ui.image.ImageFileFormat;

import org.eclipse.gmf.runtime.diagram.ui.image.PartPositionInfo;

import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;

import org.eclipse.gmf.runtime.diagram.ui.render.clipboard.DiagramGenerator;

import org.eclipse.gmf.runtime.diagram.ui.render.clipboard.DiagramImageGenerator;

import org.eclipse.gmf.runtime.diagram.ui.render.clipboard.DiagramSVGGenerator;

import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderPlugin;

import org.eclipse.gmf.runtime.diagram.ui.util.DiagramEditorUtil;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.Draw2dRenderPlugin;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.image.ImageExporter;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.SVGImage;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.SVGImageConverter;

import org.eclipse.gmf.runtime.notation.Diagram;

import org.eclipse.swt.graphics.Image;

import org.eclipse.swt.graphics.ImageData;

import org.eclipse.swt.graphics.ImageLoader;

import org.eclipse.swt.graphics.PaletteData;

import org.eclipse.swt.graphics.RGB;

import org.eclipse.swt.widgets.Shell;

public class CopyToImageUtil {

    public DiagramEditPart createDiagramEditPart (Diagram diagram, Shell shell, PreferencesHint preferencesHint) {
        return OffscreenEditPartFactory.getInstance ().createDiagramEditPart (diagram, shell, preferencesHint);
    }

    public List copyToImage (Diagram diagram, IPath destination, ImageFileFormat format, IProgressMonitor monitor, PreferencesHint preferencesHint) throws CoreException {
        Trace.trace (DiagramUIRenderPlugin.getInstance (), "Copy diagram to Image " + destination + " as " + format);
        List partInfo = Collections.EMPTY_LIST;
        DiagramEditor openedDiagramEditor = DiagramEditorUtil.findOpenedDiagramEditorForID (ViewUtil.getIdStr (diagram));
        if (openedDiagramEditor != null) {
            DiagramGenerator generator = copyToImage (openedDiagramEditor.getDiagramEditPart (), destination, format, monitor);
            partInfo = generator.getDiagramPartInfo (openedDiagramEditor.getDiagramEditPart ());
        } else {
            Shell shell = new Shell ();
            try {
                DiagramEditPart diagramEditPart = createDiagramEditPart (diagram, shell, preferencesHint);
                Assert.isNotNull (diagramEditPart);
                DiagramGenerator generator = copyToImage (diagramEditPart, destination, format, monitor);
                partInfo = generator.getDiagramPartInfo (diagramEditPart);
            } finally {
                shell.dispose ();
            }
        }
        return partInfo;
    }

    public byte [] copyToImageByteArray (Diagram diagram, int maxWidth, int maxHeight, ImageFileFormat format, IProgressMonitor monitor, PreferencesHint preferencesHint, boolean useMargins) throws CoreException {
        DiagramEditor openedDiagramEditor = DiagramEditorUtil.findOpenedDiagramEditorForID (ViewUtil.getIdStr (diagram));
        if (openedDiagramEditor != null) {
            return copyToImageByteArray (openedDiagramEditor.getDiagramEditPart (), null, maxWidth, maxHeight, format, monitor, useMargins);
        } else {
            Shell shell = new Shell ();
            try {
                DiagramEditPart diagramEditPart = createDiagramEditPart (diagram, shell, preferencesHint);
                Assert.isNotNull (diagramEditPart);
                return copyToImageByteArray (diagramEditPart, null, maxWidth, maxHeight, format, monitor, useMargins);
            } finally {
                shell.dispose ();
            }
        }
    }

    public byte [] copyToImageByteArray (DiagramEditPart diagramEP, List editParts, int maxWidth, int maxHeight, ImageFileFormat format, IProgressMonitor monitor, boolean useMargins) throws CoreException {
        Assert.isNotNull (diagramEP);
        ByteArrayOutputStream stream = new ByteArrayOutputStream ();
        DiagramGenerator gen = getDiagramGenerator (diagramEP, format);
        if (editParts == null || editParts.isEmpty ()) {
            editParts = diagramEP.getPrimaryEditParts ();
        }
        if (format.equals (ImageFileFormat.SVG) || format.equals (ImageFileFormat.PDF)) {
            gen.createConstrainedSWTImageDecriptorForParts (editParts, maxWidth, maxHeight, useMargins);
            monitor.worked (1);
            saveToOutputStream (stream, (DiagramSVGGenerator) gen, format, monitor);
        } else {
            Image image = gen.createConstrainedSWTImageDecriptorForParts (editParts, maxWidth, maxHeight, useMargins).createImage ();
            monitor.worked (1);
            saveToOutputStream (stream, image, format, monitor);
            ;
            image.dispose ();
        }
        monitor.worked (1);
        return stream.toByteArray ();
    }

    public DiagramGenerator copyToImage (DiagramEditPart diagramEP, IPath destination, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
        DiagramGenerator gen = getDiagramGenerator (diagramEP, format);
        List editParts = diagramEP.getPrimaryEditParts ();
        copyToImage (gen, editParts, gen.calculateImageRectangle (editParts), destination, format, monitor);
        monitor.worked (1);
        return gen;
    }

    public void copyToImage (DiagramEditPart diagramEP, List selection, IPath destination, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
        DiagramGenerator gen = getDiagramGenerator (diagramEP, format);
        copyToImage (gen, selection, gen.calculateImageRectangle (selection), destination, format, monitor);
        monitor.worked (1);
    }

    protected DiagramGenerator getDiagramGenerator (DiagramEditPart diagramEP, ImageFileFormat format) {
        if (format.equals (ImageFileFormat.SVG) || format.equals (ImageFileFormat.PDF)) {
            return new DiagramSVGGenerator (diagramEP);
        } else {
            return new DiagramImageGenerator (diagramEP);
        }
    }

    protected void copyToImage (DiagramGenerator gen, List editParts, org.eclipse.swt.graphics.Rectangle imageRect, IPath destination, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
        boolean found = false;
        if (format.equals (ImageFileFormat.SVG) || format.equals (ImageFileFormat.PDF)) {
            gen.createSWTImageDescriptorForParts (editParts, imageRect);
            monitor.worked (1);
            saveToFile (destination, (DiagramSVGGenerator) gen, format, monitor);
            found = true;
        } else if (format.equals (ImageFileFormat.JPEG) || format.equals (ImageFileFormat.PNG)) {
            String exportFormat = ImageExporter.JPEG_FILE;
            if (format.equals (ImageFileFormat.PNG)) exportFormat = ImageExporter.PNG_FILE;

            java.awt.Image image = gen.createAWTImageForParts (editParts, imageRect);
            monitor.worked (1);
            if (image instanceof BufferedImage) {
                ImageExporter.exportToFile (destination, (BufferedImage) image, exportFormat, monitor);
                found = true;
            }
        }

        if (! found) {
            Image image = gen.createSWTImageDescriptorForParts (editParts, imageRect).createImage ();
            monitor.worked (1);
            saveToFile (destination, image, format, monitor);
            image.dispose ();
        }
    }

    protected void saveToFile (IPath destination, Image image, ImageFileFormat imageFormat, IProgressMonitor monitor) throws CoreException {
        IStatus fileModificationStatus = createFile (destination);
        if (! fileModificationStatus.isOK ()) {
            return;
        }
        try {
            FileOutputStream stream = new FileOutputStream (destination.toOSString ());
            saveToOutputStream (stream, image, imageFormat, monitor);
            stream.close ();
        } catch (Exception e) {
            Log.error (Draw2dRenderPlugin.getInstance (), IStatus.ERROR, e.getMessage (), e);
            IStatus status = new Status (IStatus.ERROR, "exportToFile", IStatus.OK, e.getMessage (), null);
            throw new CoreException (status);
        }
        refreshLocal (destination);
    }

    private void saveToOutputStream (OutputStream stream, Image image, ImageFileFormat imageFormat, IProgressMonitor monitor) {
        monitor.worked (1);
        ImageData imageData = image.getImageData ();
        if (imageFormat.equals (ImageFileFormat.GIF) || imageFormat.equals (ImageFileFormat.BMP)) imageData = createImageData (image);

        monitor.worked (1);
        ImageLoader imageLoader = new ImageLoader ();
        imageLoader.data = new ImageData [] {imageData};
        imageLoader.logicalScreenHeight = image.getBounds ().width;
        imageLoader.logicalScreenHeight = image.getBounds ().height;
        imageLoader.save (stream, imageFormat.getOrdinal ());
        monitor.worked (1);
    }

    protected void saveSVGToFile (IPath destination, DiagramSVGGenerator generator, IProgressMonitor monitor) throws CoreException {
        saveToFile (destination, generator, ImageFileFormat.SVG, monitor);
    }

    protected void saveToFile (IPath destination, DiagramSVGGenerator generator, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
        IStatus fileModificationStatus = createFile (destination);
        if (! fileModificationStatus.isOK ()) {
            return;
        }
        monitor.worked (1);
        try {
            FileOutputStream os = new FileOutputStream (destination.toOSString ());
            monitor.worked (1);
            saveToOutputStream (os, generator, format, monitor);
            os.close ();
            monitor.worked (1);
            refreshLocal (destination);
        } catch (IOException ex) {
            Log.error (DiagramUIRenderPlugin.getInstance (), IStatus.ERROR, ex.getMessage (), ex);
            IStatus status = new Status (IStatus.ERROR, "exportToFile", IStatus.OK, ex.getMessage (), null);
            throw new CoreException (status);
        }
    }

    private void saveToOutputStream (OutputStream stream, DiagramSVGGenerator generator, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
        if (format == ImageFileFormat.PDF) {
            SVGImageConverter.exportToPDF ((SVGImage) generator.getRenderedImage (), stream);
        } else if (format == ImageFileFormat.SVG) {
            generator.stream (stream);
        } else {
            throw new IllegalArgumentException ("Unexpected format: " + format.getName ());
        }

        monitor.worked (1);
    }

    private IStatus createFile (IPath destination) throws CoreException {
        IFile file = ResourcesPlugin.getWorkspace ().getRoot ().getFileForLocation (destination);
        if (file != null && ! file.exists ()) {
            File osFile = new File (destination.toOSString ());
            if (osFile.exists ()) {
                file.refreshLocal (IResource.DEPTH_ZERO, null);
            } else {
                ResourcesPlugin.getWorkspace ().getRoot ().refreshLocal (IResource.DEPTH_INFINITE, null);
                InputStream input = new ByteArrayInputStream (new byte [0]);
                file.create (input, false, null);
            }
        }
        if (file != null) {
            return FileModificationValidator.approveFileModification (new IFile [] {file});
        }
        return Status.OK_STATUS;
    }

    private void refreshLocal (IPath destination) throws CoreException {
        IFile file = ResourcesPlugin.getWorkspace ().getRoot ().getFileForLocation (destination);
        if (file != null) {
            file.refreshLocal (IResource.DEPTH_ZERO, null);
        }
    }

    private ImageData createImageData (Image image) {
        ImageData imageData = image.getImageData ();
        if (imageData.depth <= 8) {
            return imageData;
        }
        ImageData newImageData = get8BitPaletteImageData (imageData);
        if (newImageData == null) {
            newImageData = getWebSafePalletteImageData (imageData);
        }
        return newImageData;
    }

    private ImageData get8BitPaletteImageData (ImageData imageData) {
        PaletteData palette = imageData.palette;
        RGB colours [] = new RGB [256];
        PaletteData newPaletteData = new PaletteData (colours);
        ImageData newImageData = new ImageData (imageData.width, imageData.height, 8, newPaletteData);
        int lastPixel = - 1;
        int newPixel = - 1;
        for (int i = 0;
        i < imageData.width; ++ i) {
            for (int j = 0;
            j < imageData.height; ++ j) {
                int pixel = imageData.getPixel (i, j);
                if (pixel != lastPixel) {
                    lastPixel = pixel;
                    RGB colour = palette.getRGB (pixel);
                    for (newPixel = 0; newPixel < 256; ++ newPixel) {
                        if (colours [newPixel] == null) {
                            colours [newPixel] = colour;
                            break;
                        }
                        if (colours [newPixel].equals (colour)) break;

                    }
                    if (newPixel >= 256) {
                        return null;
                    }
                }
                newImageData.setPixel (i, j, newPixel);
            }
        }
        RGB colour = new RGB (0, 0, 0);
        for (int k = 0;
        k < 256; ++ k) {
            if (colours [k] == null) colours [k] = colour;

        }
        return newImageData;
    }

    private ImageData getWebSafePalletteImageData (ImageData imageData) {
        PaletteData palette = imageData.palette;
        RGB [] webSafePallette = getWebSafePallette ();
        PaletteData newPaletteData = new PaletteData (webSafePallette);
        ImageData newImageData = new ImageData (imageData.width, imageData.height, 8, newPaletteData);
        int lastPixel = - 1;
        int newPixel = - 1;
        for (int i = 0;
        i < imageData.width; ++ i) {
            for (int j = 0;
            j < imageData.height; ++ j) {
                int pixel = imageData.getPixel (i, j);
                if (pixel != lastPixel) {
                    lastPixel = pixel;
                    RGB colour = palette.getRGB (pixel);
                    RGB webSafeColour = getWebSafeColour (colour);
                    for (newPixel = 0; newPixel < 256; ++ newPixel) {
                        if (webSafePallette [newPixel].equals (webSafeColour)) break;

                    }
                    Assert.isTrue (newPixel < 216);
                }
                newImageData.setPixel (i, j, newPixel);
            }
        }
        return newImageData;
    }

    private RGB getWebSafeColour (RGB colour) {
        int red = Math.round ((colour.red + 25) / 51) * 51;
        int green = Math.round ((colour.green + 25) / 51) * 51;
        int blue = Math.round ((colour.blue + 25) / 51) * 51;
        return new RGB (red, green, blue);
    }

    private RGB [] getWebSafePallette () {
        RGB [] colours = new RGB [256];
        int i = 0;
        for (int red = 0;
        red <= 255; red = red + 51) {
            for (int green = 0;
            green <= 255; green = green + 51) {
                for (int blue = 0;
                blue <= 255; blue = blue + 51) {
                    RGB colour = new RGB (red, green, blue);
                    colours [i ++] = colour;
                }
            }
        }
        RGB colour = new RGB (0, 0, 0);
        for (int k = 0;
        k < 256; ++ k) {
            if (colours [k] == null) colours [k] = colour;

        }
        return colours;
    }

}

