package org.eclipse.gmf.runtime.diagram.ui.providers;

import java.net.MalformedURLException;

import java.net.URL;

import java.util.ArrayList;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.FileLocator;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.core.runtime.Path;

import org.eclipse.core.runtime.Platform;

import org.eclipse.gef.Tool;

import org.eclipse.gef.palette.PaletteContainer;

import org.eclipse.gef.palette.PaletteEntry;

import org.eclipse.gef.palette.PaletteRoot;

import org.eclipse.gmf.runtime.common.core.service.AbstractProvider;

import org.eclipse.gmf.runtime.common.core.service.IOperation;

import org.eclipse.gmf.runtime.common.core.service.AbstractProviderConfiguration.ObjectDescriptor;

import org.eclipse.gmf.runtime.common.core.util.Log;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.common.ui.util.ActivityUtil;

import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;

import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;

import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.PaletteTemplateEntry;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.PaletteToolEntry;

import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;

import org.eclipse.gmf.runtime.diagram.ui.providers.internal.DiagramProvidersPlugin;

import org.eclipse.gmf.runtime.diagram.ui.providers.internal.DiagramProvidersStatusCodes;

import org.eclipse.gmf.runtime.diagram.ui.services.palette.IPaletteProvider;

import org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteFactory;

import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteDrawer;

import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteSeparator;

import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteStack;

import org.eclipse.jface.resource.ImageDescriptor;

import org.eclipse.ui.IEditorPart;

import org.osgi.framework.Bundle;

import com.ibm.icu.util.StringTokenizer;

public class DefaultPaletteProvider extends AbstractProvider implements IPaletteProvider {
    private static final String CONTRIBUTION = "contribution";
    private static final String FACTORY_CLASS = "factoryClass";
    private static final String ENTRY = "entry";
    private static final String KIND = "kind";
    private static final String ID = "id";
    private static final String PATH = "path";
    private static final String LABEL = "label";
    private static final String DESCRIPTION = "description";
    private static final String SMALL_ICON = "small_icon";
    private static final String LARGE_ICON = "large_icon";
    private static final String EXPAND = "expand";
    private static final String FORCE = "force";
    private static final String CONTENT = "content";
    private static final String DEFINE_ONLY = "defineOnly";
    private static final String PREDEFINED_ENTRY = "predefinedEntry";
    private static final String REMOVE = "remove";
    private static final String DRAWER = "drawer";
    private static final String STACK = "stack";
    private static final String SEPARATOR = "separator";
    private static final String TEMPLATE = "template";
    private static final String TOOL = "tool";
    private static final int ENUM_DRAWER = 0;
    private static final int ENUM_STACK = 1;
    private static final int ENUM_SEPARATOR = 2;
    private static final int ENUM_TEMPLATE = 3;
    private static final int ENUM_TOOL = 4;
    private static final String NONE = "None";
    private static final String HIDEONLY = "HideOnly";
    private static final String LIMITED = "limited";
    private static final String FULL = "full";
    private static class ContributionDescriptor {
        private PaletteFactoryProxy paletteFactory;
        private List entries = new ArrayList ();

        public ContributionDescriptor (IConfigurationElement configElement) {
            paletteFactory = new PaletteFactoryProxy (configElement);
            IConfigurationElement configChildren [] = configElement.getChildren (ENTRY);
            for (int i = 0;
            i < configChildren.length; i ++) {
                entries.add (new EntryDescriptor (configChildren [i]));
            }
            configChildren = configElement.getChildren (PREDEFINED_ENTRY);
            for (int i = 0;
            i < configChildren.length; i ++) {
                entries.add (new PredefinedEntryDescriptor (configChildren [i]));
            }
        }

        public void contribute (Object content, PaletteRoot root, Map predefinedEntries, String pluginID) {
            Iterator iter = entries.iterator ();
            while (iter.hasNext ()) {
                IEntryDescriptor descriptor = (IEntryDescriptor) iter.next ();
                if (ActivityUtil.isEnabled (descriptor.getID (), pluginID)) {
                    descriptor.contribute (content, root, paletteFactory, predefinedEntries);
                }
            }
        }

    }

    private static interface IEntryDescriptor {

        public void contribute (Object content, PaletteRoot root, PaletteFactoryProxy paletteFactory, Map predefinedEntries);

        public String getID ();

    }

    private static class EntryDescriptor implements IEntryDescriptor {
        private Integer kind;
        private String id;
        private String path;
        private String label;
        private String description;
        private Integer permission;
        private ImageDescriptor small_icon;
        private ImageDescriptor large_icon;
        private DrawerExpandHelper expandHelper;
        private boolean defineOnly;

        public EntryDescriptor (IConfigurationElement configElement) {
            String kindStr = configElement.getAttribute (KIND);
            if (DRAWER.equals (kindStr)) kind = new Integer (ENUM_DRAWER);
            else if (STACK.equals (kindStr)) kind = new Integer (ENUM_STACK);
            else if (SEPARATOR.equals (kindStr)) kind = new Integer (ENUM_SEPARATOR);
            else if (TEMPLATE.equals (kindStr)) kind = new Integer (ENUM_TEMPLATE);
            else if (TOOL.equals (kindStr)) kind = new Integer (ENUM_TOOL);
            else Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided");

            id = configElement.getAttribute (ID);
            if (id == null) Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided");

            defineOnly = Boolean.valueOf (configElement.getAttribute (DEFINE_ONLY)).booleanValue ();
            path = configElement.getAttribute (PATH);
            if (path == null && ! defineOnly) Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "Path must be provided when contributing a palette entry");

            label = configElement.getAttribute (LABEL);
            if (label == null) label = DiagramUIMessages.PaletteEntry_DefaultLabel;

            description = configElement.getAttribute (DESCRIPTION);
            if (NONE.equals (kindStr)) permission = new Integer (PaletteEntry.PERMISSION_NO_MODIFICATION);

            if (HIDEONLY.equals (kindStr)) permission = new Integer (PaletteEntry.PERMISSION_HIDE_ONLY);

            if (LIMITED.equals (kindStr)) permission = new Integer (PaletteEntry.PERMISSION_LIMITED_MODIFICATION);

            if (FULL.equals (kindStr)) permission = new Integer (PaletteEntry.PERMISSION_FULL_MODIFICATION);

            String smallIconPath = configElement.getAttribute (SMALL_ICON);
            small_icon = findIconImageDescriptor (configElement, smallIconPath);
            String largeIconPath = configElement.getAttribute (LARGE_ICON);
            large_icon = findIconImageDescriptor (configElement, largeIconPath);
            if (kind.intValue () == ENUM_DRAWER) {
                IConfigurationElement [] configChildren = configElement.getChildren (EXPAND);
                if (configChildren.length > 0) expandHelper = new DrawerExpandHelper (configChildren [0]);
                else expandHelper = new DrawerExpandHelper (Boolean.FALSE);

            }
        }

        private ImageDescriptor findIconImageDescriptor (IConfigurationElement configElement, String iconPath) {
            String pluginId = configElement.getDeclaringExtension ().getNamespaceIdentifier ();
            Bundle bundle = Platform.getBundle (pluginId);
            try {
                if (iconPath != null) {
                    URL fullPathString = FileLocator.find (bundle, new Path (iconPath), null);
                    fullPathString = fullPathString != null ? fullPathString : new URL (iconPath);
                    if (fullPathString != null) {
                        return ImageDescriptor.createFromURL (fullPathString);
                    }
                }
            } catch (MalformedURLException e) {
                Trace.catching (DiagramUIPlugin.getInstance (), DiagramUIDebugOptions.EXCEPTIONS_CATCHING, DefaultPaletteProvider.class, e.getLocalizedMessage (), e);
                Log.error (DiagramUIPlugin.getInstance (), DiagramUIStatusCodes.RESOURCE_FAILURE, e.getMessage (), e);
            }
            return null;
        }

        public void contribute (Object content, PaletteRoot root, PaletteFactoryProxy paletteFactory, Map predefinedEntries) {
            if (kind == null || id == null || label == null) return;

            PaletteEntry paletteEntry = null;
            switch (kind.intValue ()) {
                case ENUM_DRAWER :
                    PaletteDrawer drawer = new PaletteDrawer (id, label);
                    if (expandHelper.expand (content)) drawer.setInitialState (PaletteDrawer.INITIAL_STATE_OPEN);

                    paletteEntry = drawer;
                    break;
                case ENUM_STACK :
                    paletteEntry = new PaletteStack (id, label, description, small_icon);
                    break;
                case ENUM_SEPARATOR :
                    paletteEntry = new PaletteSeparator (id);
                    break;
                case ENUM_TEMPLATE :
                    paletteEntry = new PaletteTemplateEntry (id, label, paletteFactory);
                    break;
                case ENUM_TOOL :
                    paletteEntry = new PaletteToolEntry (id, label, paletteFactory);
                    break;
            }
            if (paletteEntry != null) {
                paletteEntry.setDescription (description);
                paletteEntry.setSmallIcon (small_icon);
                paletteEntry.setLargeIcon (large_icon);
                if (permission != null) paletteEntry.setUserModificationPermission (permission.intValue ());

                if (defineOnly) {
                    predefinedEntries.put (id, paletteEntry);
                } else {
                    appendPaletteEntry (root, predefinedEntries, path, paletteEntry);
                }
            }
        }

        public String getID () {
            return id;
        }

    }

    private static class PredefinedEntryDescriptor implements IEntryDescriptor {
        private String id;
        private String path;
        private DrawerExpandHelper expandHelper;
        private boolean remove;

        public PredefinedEntryDescriptor (IConfigurationElement configElement) {
            id = configElement.getAttribute (ID);
            if (id == null) {
                Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No ID provided");
            }
            path = configElement.getAttribute (PATH);
            IConfigurationElement [] configChildren = configElement.getChildren (EXPAND);
            if (configChildren.length > 0) expandHelper = new DrawerExpandHelper (configChildren [0]);
            else expandHelper = new DrawerExpandHelper (Boolean.FALSE);

            remove = Boolean.valueOf (configElement.getAttribute (REMOVE)).booleanValue ();
        }

        public void contribute (Object content, PaletteRoot root, PaletteFactoryProxy paletteFactory, Map predefinedEntries) {
            if (id == null) return;

            PaletteEntry paletteEntry = findPaletteEntry (root, id);
            if (paletteEntry != null) {
                if (remove) {
                    paletteEntry.getParent ().remove (paletteEntry);
                    return;
                }
                if (paletteEntry instanceof PaletteDrawer && expandHelper.expand (content)) {
                    ((PaletteDrawer) paletteEntry).setInitialState (PaletteDrawer.INITIAL_STATE_OPEN);
                }
            }
            if (paletteEntry == null) {
                paletteEntry = findPredefinedEntry (predefinedEntries, id);
            }
            if (paletteEntry != null) {
                if (path != null) {
                    appendPaletteEntry (root, predefinedEntries, path, paletteEntry);
                    if (paletteEntry instanceof PaletteDrawer && expandHelper.expand (content)) {
                        ((PaletteDrawer) paletteEntry).setInitialState (PaletteDrawer.INITIAL_STATE_OPEN);
                    }
                }
            }
        }

        public String getID () {
            return id;
        }

    }

    private static PaletteEntry findPredefinedEntry (Map predefinedEntries, String path) {
        StringTokenizer tokens = new StringTokenizer (path, "/");
        PaletteEntry root = (PaletteEntry) predefinedEntries.get (tokens.nextToken ());
        while (tokens.hasMoreElements ()) {
            if (root instanceof PaletteContainer) root = findChildPaletteEntry ((PaletteContainer) root, tokens.nextToken ());
            else return null;

        }
        return root;
    }

    private static PaletteEntry findPaletteEntry (PaletteEntry root, String aPath) {
        StringTokenizer tokens = new StringTokenizer (aPath, "/");
        while (tokens.hasMoreElements ()) {
            if (root instanceof PaletteContainer) root = findChildPaletteEntry ((PaletteContainer) root, tokens.nextToken ());
            else return null;

        }
        return root;
    }

    private static PaletteEntry findChildPaletteEntry (PaletteContainer container, String childId) {
        Iterator entries = container.getChildren ().iterator ();
        while (entries.hasNext ()) {
            PaletteEntry entry = (PaletteEntry) entries.next ();
            if (entry.getId ().equals (childId)) return entry;

        }
        return null;
    }

    private static void appendPaletteEntry (PaletteRoot root, Map predefinedEntries, String path, PaletteEntry paletteEntry) {
        PaletteEntry fEntry = findPaletteEntry (root, path);
        if (fEntry == null) {
            fEntry = findPredefinedEntry (predefinedEntries, path);
        }
        if (fEntry == null) Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "Invalid palette entry path");
        else if (fEntry instanceof PaletteContainer) ((PaletteContainer) fEntry).add (paletteEntry);
        else if (fEntry instanceof PaletteSeparator) appendTo ((PaletteSeparator) fEntry, paletteEntry);
        else fEntry.getParent ().add (fEntry.getParent ().getChildren ().indexOf (fEntry) + 1, paletteEntry);

    }

    private static void appendTo (PaletteSeparator separator, PaletteEntry entry) {
        List children = separator.getParent ().getChildren ();
        int index = children.indexOf (separator);
        for (index ++; index < children.size (); index ++) {
            if (children.get (index) instanceof PaletteSeparator) break;

        }
        separator.getParent ().add (index, entry);
    }

    private static class PaletteFactoryProxy extends PaletteFactory.Adapter {
        private IConfigurationElement configElement;
        private PaletteFactory factory;

        public PaletteFactoryProxy (IConfigurationElement configElement) {
            this.configElement = configElement;
        }

        public Object getTemplate (String templateId) {
            if (factory == null) {
                try {
                    Object ext = configElement.createExecutableExtension (FACTORY_CLASS);
                    factory = (PaletteFactory) ext;
                } catch (CoreException e) {
                    Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided");
                }
            }
            if (factory != null) {
                Object template = factory.getTemplate (templateId);
                if (template == null) Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided");

                return template;
            }
            return null;
        }

        public Tool createTool (String toolId) {
            if (factory == null) {
                try {
                    Object ext = configElement.createExecutableExtension (FACTORY_CLASS);
                    factory = (PaletteFactory) ext;
                } catch (CoreException e) {
                    Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided");
                }
            }
            if (factory != null) {
                Tool tool = factory.createTool (toolId);
                if (tool == null) Log.info (DiagramProvidersPlugin.getInstance (), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided");

                return tool;
            }
            return null;
        }

    }

    private static class DrawerExpandHelper {
        private Boolean force;
        private ObjectDescriptor content;

        public DrawerExpandHelper (Boolean force) {
            this.force = force;
        }

        public DrawerExpandHelper (IConfigurationElement configElement) {
            String forceStr = configElement.getAttribute (FORCE);
            force = forceStr == null ? Boolean.FALSE : Boolean.valueOf (forceStr);
            IConfigurationElement [] configChildren = configElement.getChildren (CONTENT);
            if (configChildren.length > 0) content = new ObjectDescriptor (configChildren [0]);

        }

        public boolean expand (Object targetContent) {
            if (force == Boolean.TRUE) return true;

            if (content != null && content.sameAs (targetContent)) return true;

            return false;
        }

    }

    private List contributions = new ArrayList ();
    private String pluginID;

    public void setContributions (IConfigurationElement configElement) {
        pluginID = configElement.getContributor ().getName ();
        IConfigurationElement configChildren [] = configElement.getChildren (CONTRIBUTION);
        for (int i = 0;
        i < configChildren.length; i ++) {
            contributions.add (new ContributionDescriptor (configChildren [i]));
        }
    }

    public void contributeToPalette (IEditorPart editor, Object content, PaletteRoot root, Map predefinedEntries) {
        Iterator iter = contributions.iterator ();
        while (iter.hasNext ()) {
            ((ContributionDescriptor) iter.next ()).contribute (content, root, predefinedEntries, pluginID);
        }
    }

    public boolean provides (IOperation operation) {
        return false;
    }

}

