package org.eclipse.gmf.runtime.emf.type.core.internal.impl;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.Collection;

import java.util.Collections;

import java.util.HashMap;

import java.util.HashSet;

import java.util.Iterator;

import java.util.LinkedHashSet;

import java.util.List;

import java.util.Map;

import java.util.Set;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.EReference;

import org.eclipse.gmf.runtime.common.core.util.Log;

import org.eclipse.gmf.runtime.emf.type.core.IContainerDescriptor;

import org.eclipse.gmf.runtime.emf.type.core.IElementMatcher;

import org.eclipse.gmf.runtime.emf.type.core.IElementType;

import org.eclipse.gmf.runtime.emf.type.core.IMetamodelType;

import org.eclipse.gmf.runtime.emf.type.core.ISpecializationType;

import org.eclipse.gmf.runtime.emf.type.core.edithelper.IEditHelperAdvice;

import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePlugin;

import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePluginStatusCodes;

import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.AdviceBindingDescriptor;

import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.AdviceBindingInheritance;

import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.ElementTypeDescriptor;

import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.IEditHelperAdviceDescriptor;

import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.MetamodelDescriptor;

import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.MetamodelTypeDescriptor;

import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.SpecializationTypeDescriptor;

import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.EMFTypeCoreMessages;

public class SpecializationTypeRegistry {
    private final static Set ALL = Collections.singleton (AdviceBindingInheritance.ALL);
    private final static Set ALL_NONE = new HashSet (Arrays.asList (new AdviceBindingInheritance [] {AdviceBindingInheritance.NONE, AdviceBindingInheritance.ALL}));
    private final Map specializationTypeDescriptors;
    private final Map specializationsForTypeId;
    private final Map adviceBindings;

    public SpecializationTypeRegistry () {
        super ();
        specializationTypeDescriptors = new HashMap ();
        specializationsForTypeId = new HashMap ();
        adviceBindings = new HashMap ();
    }

    public boolean registerSpecializationType (ISpecializationType specializationType) {
        if (specializationType == null || specializationTypeDescriptors.containsKey (specializationType.getId ())) {
            return false;
        }
        SpecializationTypeDescriptor descriptor = new SpecializationTypeDescriptor (specializationType);
        return registerSpecializationType (descriptor);
    }

    public SpecializationTypeDescriptor registerSpecializationType (IConfigurationElement configElement, MetamodelDescriptor metamodelDescriptor) throws CoreException {
        SpecializationTypeDescriptor descriptor = new SpecializationTypeDescriptor (configElement, metamodelDescriptor);
        boolean wasRegistered = registerSpecializationType (descriptor);
        return wasRegistered ? descriptor : null;
    }

    private boolean registerSpecializationType (SpecializationTypeDescriptor descriptor) {
        if (checkForDuplicate (descriptor)) {
            return false;
        }
        specializationTypeDescriptors.put (descriptor.getId (), descriptor);
        IEditHelperAdviceDescriptor editHelperAdvice = descriptor.getEditHelperAdviceDescriptor ();
        if (editHelperAdvice != null) {
            register (editHelperAdvice);
        }
        String [] specializedTypes = descriptor.getSpecializationTypeIds ();
        for (int i = 0;
        i < specializedTypes.length; i ++) {
            Set specializations = (Set) specializationsForTypeId.get (specializedTypes [i]);
            if (specializations == null) {
                specializations = new HashSet ();
                specializationsForTypeId.put (specializedTypes [i], specializations);
            }
            specializations.add (descriptor);
        }
        return true;
    }

    public void registerAdviceBinding (IConfigurationElement configElement, MetamodelDescriptor metamodelDescriptor) throws CoreException {
        IEditHelperAdviceDescriptor descriptor = new AdviceBindingDescriptor (configElement, metamodelDescriptor);
        register (descriptor);
    }

    private void register (IEditHelperAdviceDescriptor descriptor) {
        String targetId = descriptor.getTypeId ();
        Set bindings = (Set) adviceBindings.get (targetId);
        if (bindings == null) {
            bindings = new HashSet ();
            adviceBindings.put (targetId, bindings);
        }
        bindings.add (descriptor);
    }

    public void removeSpecializationType (SpecializationTypeDescriptor specializationTypeDescriptor) {
        specializationTypeDescriptors.remove (specializationTypeDescriptor.getId ());
        String [] specializedTypes = specializationTypeDescriptor.getSpecializationTypeIds ();
        for (int j = 0;
        j < specializedTypes.length; j ++) {
            Set specializations = (Set) specializationsForTypeId.get (specializedTypes [j]);
            specializations.remove (specializationTypeDescriptor);
        }
    }

    private List getImmediateSpecializationTypeDescriptors (ElementTypeDescriptor type) {
        return getSpecializationTypeDescriptors (type, false);
    }

    private List getAllSpecializationTypeDescriptors (ElementTypeDescriptor type) {
        return getSpecializationTypeDescriptors (type, true);
    }

    private List getSpecializationTypeDescriptors (ElementTypeDescriptor type, boolean deep) {
        LinkedHashSet result = new LinkedHashSet ();
        Set specializationDescriptors = (Set) specializationsForTypeId.get (type.getId ());
        if (specializationDescriptors != null) {
            Set specializations = new HashSet ();
            for (Iterator i = specializationDescriptors.iterator ();
            i.hasNext ();) {
                SpecializationTypeDescriptor nextDescriptor = (SpecializationTypeDescriptor) i.next ();
                if (nextDescriptor != null) {
                    specializations.add (nextDescriptor);
                    if (deep) {
                        result.addAll (getSpecializationTypeDescriptors (nextDescriptor, deep));
                    }
                }
            }
            result.addAll (specializations);
        }
        return new ArrayList (result);
    }

    public List getSpecializationDescriptorsMatching (EObject eObject, MetamodelTypeDescriptor metamodelTypeDescriptor) {
        List result = new ArrayList ();
        List specializations = getAllSpecializationTypeDescriptors (metamodelTypeDescriptor);
        for (Iterator i = specializations.iterator ();
        i.hasNext ();) {
            SpecializationTypeDescriptor nextDescriptor = (SpecializationTypeDescriptor) i.next ();
            IEditHelperAdviceDescriptor adviceDescriptor = nextDescriptor.getEditHelperAdviceDescriptor ();
            if (adviceDescriptor != null) {
                List matchingAdvice = getAdviceMatching (eObject, Collections.singletonList (adviceDescriptor));
                if (! matchingAdvice.isEmpty ()) {
                    result.add (nextDescriptor);
                }
            } else {
                result.add (nextDescriptor);
            }
        }
        return result;
    }

    public List getMatchingSpecializations (ElementTypeDescriptor type, EObject eContainer, EReference reference) {
        List result = new ArrayList ();
        List matchingSpecializations = getSpecializationDescriptorsMatching (type, eContainer, reference);
        result.addAll (matchingSpecializations);
        for (Iterator i = matchingSpecializations.iterator ();
        i.hasNext ();) {
            result.addAll (getMatchingSpecializations ((ElementTypeDescriptor) i.next (), eContainer, reference));
        }
        return result;
    }

    private List getAdviceMatching (EObject eObject, Collection editHelperAdviceDescriptors) {
        List result = new ArrayList ();
        EReference containmentFeature = eObject.eContainmentFeature ();
        for (Iterator i = editHelperAdviceDescriptors.iterator ();
        i.hasNext ();) {
            IEditHelperAdviceDescriptor nextAdviceDescriptor = (IEditHelperAdviceDescriptor) i.next ();
            IContainerDescriptor container = nextAdviceDescriptor.getContainerDescriptor ();
            if (container != null) {
                IElementMatcher containerMatcher = container.getMatcher ();
                if (containerMatcher != null && ! containerMatcher.matches (eObject.eContainer ())) {
                    continue;
                }
            }
            EReference [] features = null;
            if (container != null) {
                features = container.getContainmentFeatures ();
            }
            if (features == null || features.length < 1) {
                IElementMatcher matcher = nextAdviceDescriptor.getMatcher ();
                if (matcher == null || (matcher != null && matcher.matches (eObject))) {
                    result.add (nextAdviceDescriptor);
                }
            } else {
                for (int j = 0;
                j < features.length; j ++) {
                    if (features [j] == containmentFeature) {
                        IElementMatcher matcher = nextAdviceDescriptor.getMatcher ();
                        if (matcher == null) {
                            result.add (nextAdviceDescriptor);
                        } else if (matcher.matches (eObject)) {
                            result.add (nextAdviceDescriptor);
                        }

                    }
                }
            }
        }
        return result;
    }

    private List getSpecializationDescriptorsMatching (ElementTypeDescriptor typeDescriptor, EObject eContainer, EReference feature) {
        List result = new ArrayList ();
        Collection specializationDescriptors = getImmediateSpecializationTypeDescriptors (typeDescriptor);
        for (Iterator i = specializationDescriptors.iterator ();
        i.hasNext ();) {
            SpecializationTypeDescriptor nextDescriptor = (SpecializationTypeDescriptor) i.next ();
            IContainerDescriptor container = nextDescriptor.getContainerDescriptor ();
            IElementMatcher containerMatcher = container != null ? container.getMatcher () : null;
            if (containerMatcher != null && ! containerMatcher.matches (eContainer)) {
                continue;
            }
            EReference [] features = container != null ? container.getContainmentFeatures () : null;
            if (features == null || features.length < 1) {
                EClass specializedType = nextDescriptor.getElementType ().getEClass ();
                if (canContain (eContainer.eClass (), feature, specializedType)) {
                    result.add (nextDescriptor);
                    continue;
                }
            } else {
                for (int j = 0;
                j < features.length; j ++) {
                    if (features [j] == feature) {
                        result.add (nextDescriptor);
                        break;
                    }
                }
            }
        }
        return result;
    }

    private boolean canContain (EClass container, EReference reference, EClass contained) {
        if ((reference.isContainment ()) && (container.getEAllReferences ().contains (reference))) {
            EClass eType = (EClass) reference.getEType ();
            if ((eType.equals (contained)) || (eType.isSuperTypeOf (contained))) {
                return true;
            }
        }
        return false;
    }

    public List getEditHelperAdvice (EObject eObject, MetamodelTypeDescriptor metamodelTypeDescriptor) {
        List result = new ArrayList ();
        IElementType [] metamodelSupertypes = metamodelTypeDescriptor.getElementType ().getAllSuperTypes ();
        for (int i = 0;
        i < metamodelSupertypes.length; i ++) {
            IElementType nextSupertype = metamodelSupertypes [i];
            result.addAll (getMatchingAdvice (nextSupertype.getId (), eObject, ALL));
        }
        result.addAll (getMatchingAdvice (metamodelTypeDescriptor.getId (), eObject, ALL_NONE));
        List specializationDescriptors = getSpecializationDescriptorsMatching (eObject, metamodelTypeDescriptor);
        Collections.reverse (specializationDescriptors);
        for (Iterator i = specializationDescriptors.iterator ();
        i.hasNext ();) {
            SpecializationTypeDescriptor nextSpecialization = (SpecializationTypeDescriptor) i.next ();
            result.addAll (getMatchingAdvice (nextSpecialization.getId (), eObject, ALL_NONE));
        }
        return result;
    }

    public List getEditHelperAdvice (IElementType elementType, MetamodelTypeDescriptor metamodelTypeDescriptor) {
        LinkedHashSet result = new LinkedHashSet ();
        String metamodelTypeId = (metamodelTypeDescriptor != null) ? metamodelTypeDescriptor.getId () : null;
        IElementType [] metamodelSupertypes = elementType.getAllSuperTypes ();
        for (int i = 0;
        i < metamodelSupertypes.length; i ++) {
            IElementType nextSupertype = metamodelSupertypes [i];
            if (nextSupertype instanceof ISpecializationType || nextSupertype.getId ().equals (metamodelTypeId)) {
                result.addAll (getMatchingAdvice (nextSupertype.getId (), ALL_NONE));
            } else if (nextSupertype instanceof IMetamodelType) {
                result.addAll (getMatchingAdvice (nextSupertype.getId (), ALL));
            }

        }
        result.addAll (getMatchingAdvice (elementType.getId (), ALL_NONE));
        return new ArrayList (result);
    }

    private List getMatchingAdvice (String elementTypeId, EObject eObject, Set adviceInheritanceToConsider) {
        List result = new ArrayList ();
        Set adviceDescriptors = (Set) adviceBindings.get (elementTypeId);
        if (adviceDescriptors != null) {
            List matchingAdviceDescriptors = getAdviceMatching (eObject, adviceDescriptors);
            for (Iterator j = matchingAdviceDescriptors.iterator ();
            j.hasNext ();) {
                IEditHelperAdviceDescriptor nextAdviceDescriptor = (IEditHelperAdviceDescriptor) j.next ();
                if (adviceInheritanceToConsider.contains (nextAdviceDescriptor.getInheritance ())) {
                    IEditHelperAdvice nextAdvice = nextAdviceDescriptor.getEditHelperAdvice ();
                    if (nextAdvice != null) {
                        result.add (nextAdvice);
                    }
                }
            }
        }
        return result;
    }

    private List getMatchingAdvice (String elementTypeId, Set adviceInheritanceToConsider) {
        List result = new ArrayList ();
        Set adviceDescriptors = (Set) adviceBindings.get (elementTypeId);
        if (adviceDescriptors != null) {
            for (Iterator j = adviceDescriptors.iterator ();
            j.hasNext ();) {
                IEditHelperAdviceDescriptor nextAdviceDescriptor = (IEditHelperAdviceDescriptor) j.next ();
                if (adviceInheritanceToConsider.contains (nextAdviceDescriptor.getInheritance ())) {
                    IEditHelperAdvice nextAdvice = nextAdviceDescriptor.getEditHelperAdvice ();
                    if (nextAdvice != null) {
                        result.add (nextAdvice);
                    }
                }
            }
        }
        return result;
    }

    public SpecializationTypeDescriptor getSpecializationTypeDescriptor (String id) {
        return (SpecializationTypeDescriptor) specializationTypeDescriptors.get (id);
    }

    public Collection getSpecializationTypeDescriptors () {
        return specializationTypeDescriptors.values ();
    }

    private boolean checkForDuplicate (ElementTypeDescriptor typeDescriptor) {
        if (specializationTypeDescriptors.containsKey (typeDescriptor.getId ())) {
            Log.error (EMFTypePlugin.getPlugin (), EMFTypePluginStatusCodes.TYPE_NOT_INITED, EMFTypeCoreMessages.bind (EMFTypeCoreMessages.type_not_init_WARN_, typeDescriptor.getId (), EMFTypeCoreMessages.type_reason_duplicate_id_WARN_));
            return true;
        }
        return false;
    }

}

