package org.eclipse.gmf.runtime.notation.impl;

import java.util.ArrayList;

import java.util.Iterator;

import java.util.LinkedHashMap;

import java.util.List;

import java.util.Map;

import java.util.StringTokenizer;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.EDataType;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.EPackage;

import org.eclipse.emf.ecore.impl.EFactoryImpl;

import org.eclipse.emf.ecore.plugin.EcorePlugin;

import org.eclipse.gmf.runtime.notation.Alignment;

import org.eclipse.gmf.runtime.notation.Bounds;

import org.eclipse.gmf.runtime.notation.CanonicalStyle;

import org.eclipse.gmf.runtime.notation.ConnectorStyle;

import org.eclipse.gmf.runtime.notation.DescriptionStyle;

import org.eclipse.gmf.runtime.notation.Diagram;

import org.eclipse.gmf.runtime.notation.DiagramStyle;

import org.eclipse.gmf.runtime.notation.DrawerStyle;

import org.eclipse.gmf.runtime.notation.Edge;

import org.eclipse.gmf.runtime.notation.FillStyle;

import org.eclipse.gmf.runtime.notation.Filtering;

import org.eclipse.gmf.runtime.notation.FilteringStyle;

import org.eclipse.gmf.runtime.notation.FontStyle;

import org.eclipse.gmf.runtime.notation.Guide;

import org.eclipse.gmf.runtime.notation.GuideStyle;

import org.eclipse.gmf.runtime.notation.IdentityAnchor;

import org.eclipse.gmf.runtime.notation.Image;

import org.eclipse.gmf.runtime.notation.ImageBufferStyle;

import org.eclipse.gmf.runtime.notation.ImageStyle;

import org.eclipse.gmf.runtime.notation.JumpLinkStatus;

import org.eclipse.gmf.runtime.notation.JumpLinkType;

import org.eclipse.gmf.runtime.notation.LineStyle;

import org.eclipse.gmf.runtime.notation.Location;

import org.eclipse.gmf.runtime.notation.MeasurementUnit;

import org.eclipse.gmf.runtime.notation.Node;

import org.eclipse.gmf.runtime.notation.NotationFactory;

import org.eclipse.gmf.runtime.notation.NotationPackage;

import org.eclipse.gmf.runtime.notation.PageStyle;

import org.eclipse.gmf.runtime.notation.Ratio;

import org.eclipse.gmf.runtime.notation.RelativeBendpoints;

import org.eclipse.gmf.runtime.notation.Routing;

import org.eclipse.gmf.runtime.notation.RoutingStyle;

import org.eclipse.gmf.runtime.notation.ShapeStyle;

import org.eclipse.gmf.runtime.notation.Size;

import org.eclipse.gmf.runtime.notation.Smoothness;

import org.eclipse.gmf.runtime.notation.Sorting;

import org.eclipse.gmf.runtime.notation.SortingDirection;

import org.eclipse.gmf.runtime.notation.SortingStyle;

import org.eclipse.gmf.runtime.notation.TitleStyle;

import org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint;

public class NotationFactoryImpl extends EFactoryImpl implements NotationFactory {

    public static NotationFactory init () {
        try {
            NotationFactory theNotationFactory = (NotationFactory) EPackage.Registry.INSTANCE.getEFactory ("http://www.eclipse.org/gmf/runtime/1.0.0/notation");
            if (theNotationFactory != null) {
                return theNotationFactory;
            }
        } catch (Exception exception) {
            EcorePlugin.INSTANCE.log (exception);
        }
        return new NotationFactoryImpl ();
    }

    public NotationFactoryImpl () {
        super ();
    }

    public EObject create (EClass eClass) {
        switch (eClass.getClassifierID ()) {
            case NotationPackage.EDGE :
                return createEdge ();
            case NotationPackage.NODE :
                return createNode ();
            case NotationPackage.FILL_STYLE :
                return createFillStyle ();
            case NotationPackage.LINE_STYLE :
                return createLineStyle ();
            case NotationPackage.FONT_STYLE :
                return createFontStyle ();
            case NotationPackage.TITLE_STYLE :
                return createTitleStyle ();
            case NotationPackage.SORTING_STYLE :
                return createSortingStyle ();
            case NotationPackage.DESCRIPTION_STYLE :
                return createDescriptionStyle ();
            case NotationPackage.SIZE :
                return createSize ();
            case NotationPackage.LOCATION :
                return createLocation ();
            case NotationPackage.BOUNDS :
                return createBounds ();
            case NotationPackage.RATIO :
                return createRatio ();
            case NotationPackage.IDENTITY_ANCHOR :
                return createIdentityAnchor ();
            case NotationPackage.ROUTING_STYLE :
                return createRoutingStyle ();
            case NotationPackage.RELATIVE_BENDPOINTS :
                return createRelativeBendpoints ();
            case NotationPackage.DIAGRAM :
                return createDiagram ();
            case NotationPackage.IMAGE :
                return createImage ();
            case NotationPackage.CANONICAL_STYLE :
                return createCanonicalStyle ();
            case NotationPackage.SHAPE_STYLE :
                return createShapeStyle ();
            case NotationPackage.CONNECTOR_STYLE :
                return createConnectorStyle ();
            case NotationPackage.PAGE_STYLE :
                return createPageStyle ();
            case NotationPackage.DRAWER_STYLE :
                return createDrawerStyle ();
            case NotationPackage.GUIDE_STYLE :
                return createGuideStyle ();
            case NotationPackage.GUIDE :
                return createGuide ();
            case NotationPackage.NODE_ENTRY :
                return (EObject) createNodeEntry ();
            case NotationPackage.FILTERING_STYLE :
                return createFilteringStyle ();
            case NotationPackage.DIAGRAM_STYLE :
                return createDiagramStyle ();
            case NotationPackage.IMAGE_STYLE :
                return createImageStyle ();
            case NotationPackage.IMAGE_BUFFER_STYLE :
                return createImageBufferStyle ();
            default :
                throw new IllegalArgumentException ("The class '" + eClass.getName () + "' is not a valid classifier");
        }
    }

    public Object createFromString (EDataType eDataType, String initialValue) {
        switch (eDataType.getClassifierID ()) {
            case NotationPackage.SORTING :
                return createSortingFromString (eDataType, initialValue);
            case NotationPackage.FILTERING :
                return createFilteringFromString (eDataType, initialValue);
            case NotationPackage.ROUTING :
                return createRoutingFromString (eDataType, initialValue);
            case NotationPackage.SMOOTHNESS :
                return createSmoothnessFromString (eDataType, initialValue);
            case NotationPackage.JUMP_LINK_STATUS :
                return createJumpLinkStatusFromString (eDataType, initialValue);
            case NotationPackage.JUMP_LINK_TYPE :
                return createJumpLinkTypeFromString (eDataType, initialValue);
            case NotationPackage.ALIGNMENT :
                return createAlignmentFromString (eDataType, initialValue);
            case NotationPackage.SORTING_DIRECTION :
                return createSortingDirectionFromString (eDataType, initialValue);
            case NotationPackage.MEASUREMENT_UNIT :
                return createMeasurementUnitFromString (eDataType, initialValue);
            case NotationPackage.RELATIVE_BENDPOINT_LIST :
                return createRelativeBendpointListFromString (eDataType, initialValue);
            case NotationPackage.FILTER_KEY_LIST :
                return createFilterKeyListFromString (eDataType, initialValue);
            case NotationPackage.SORT_KEY_MAP :
                return createSortKeyMapFromString (eDataType, initialValue);
            default :
                throw new IllegalArgumentException ("The datatype '" + eDataType.getName () + "' is not a valid classifier");
        }
    }

    public String convertToString (EDataType eDataType, Object instanceValue) {
        switch (eDataType.getClassifierID ()) {
            case NotationPackage.SORTING :
                return convertSortingToString (eDataType, instanceValue);
            case NotationPackage.FILTERING :
                return convertFilteringToString (eDataType, instanceValue);
            case NotationPackage.ROUTING :
                return convertRoutingToString (eDataType, instanceValue);
            case NotationPackage.SMOOTHNESS :
                return convertSmoothnessToString (eDataType, instanceValue);
            case NotationPackage.JUMP_LINK_STATUS :
                return convertJumpLinkStatusToString (eDataType, instanceValue);
            case NotationPackage.JUMP_LINK_TYPE :
                return convertJumpLinkTypeToString (eDataType, instanceValue);
            case NotationPackage.ALIGNMENT :
                return convertAlignmentToString (eDataType, instanceValue);
            case NotationPackage.SORTING_DIRECTION :
                return convertSortingDirectionToString (eDataType, instanceValue);
            case NotationPackage.MEASUREMENT_UNIT :
                return convertMeasurementUnitToString (eDataType, instanceValue);
            case NotationPackage.RELATIVE_BENDPOINT_LIST :
                return convertRelativeBendpointListToString (eDataType, instanceValue);
            case NotationPackage.FILTER_KEY_LIST :
                return convertFilterKeyListToString (eDataType, instanceValue);
            case NotationPackage.SORT_KEY_MAP :
                return convertSortKeyMapToString (eDataType, instanceValue);
            default :
                throw new IllegalArgumentException ("The datatype '" + eDataType.getName () + "' is not a valid classifier");
        }
    }

    public Edge createEdge () {
        EdgeImpl edge = new EdgeImpl ();
        return edge;
    }

    public Node createNode () {
        NodeImpl node = new NodeImpl ();
        return node;
    }

    public FillStyle createFillStyle () {
        FillStyleImpl fillStyle = new FillStyleImpl ();
        return fillStyle;
    }

    public LineStyle createLineStyle () {
        LineStyleImpl lineStyle = new LineStyleImpl ();
        return lineStyle;
    }

    public FontStyle createFontStyle () {
        FontStyleImpl fontStyle = new FontStyleImpl ();
        return fontStyle;
    }

    public TitleStyle createTitleStyle () {
        TitleStyleImpl titleStyle = new TitleStyleImpl ();
        return titleStyle;
    }

    public SortingStyle createSortingStyle () {
        SortingStyleImpl sortingStyle = new SortingStyleImpl ();
        return sortingStyle;
    }

    public DescriptionStyle createDescriptionStyle () {
        DescriptionStyleImpl descriptionStyle = new DescriptionStyleImpl ();
        return descriptionStyle;
    }

    public Size createSize () {
        SizeImpl size = new SizeImpl ();
        return size;
    }

    public Location createLocation () {
        LocationImpl location = new LocationImpl ();
        return location;
    }

    public Bounds createBounds () {
        BoundsImpl bounds = new BoundsImpl ();
        return bounds;
    }

    public Ratio createRatio () {
        RatioImpl ratio = new RatioImpl ();
        return ratio;
    }

    public IdentityAnchor createIdentityAnchor () {
        IdentityAnchorImpl identityAnchor = new IdentityAnchorImpl ();
        return identityAnchor;
    }

    public RoutingStyle createRoutingStyle () {
        RoutingStyleImpl routingStyle = new RoutingStyleImpl ();
        return routingStyle;
    }

    public RelativeBendpoints createRelativeBendpoints () {
        RelativeBendpointsImpl relativeBendpoints = new RelativeBendpointsImpl ();
        return relativeBendpoints;
    }

    public CanonicalStyle createCanonicalStyle () {
        CanonicalStyleImpl canonicalStyle = new CanonicalStyleImpl ();
        return canonicalStyle;
    }

    public ShapeStyle createShapeStyle () {
        ShapeStyleImpl shapeStyle = new ShapeStyleImpl ();
        return shapeStyle;
    }

    public ConnectorStyle createConnectorStyle () {
        ConnectorStyleImpl connectorStyle = new ConnectorStyleImpl ();
        return connectorStyle;
    }

    public Diagram createDiagram () {
        DiagramImpl diagram = new DiagramImpl ();
        return diagram;
    }

    public Image createImage () {
        ImageImpl image = new ImageImpl ();
        return image;
    }

    public PageStyle createPageStyle () {
        PageStyleImpl pageStyle = new PageStyleImpl ();
        return pageStyle;
    }

    public DrawerStyle createDrawerStyle () {
        DrawerStyleImpl drawerStyle = new DrawerStyleImpl ();
        return drawerStyle;
    }

    public GuideStyle createGuideStyle () {
        GuideStyleImpl guideStyle = new GuideStyleImpl ();
        return guideStyle;
    }

    public Guide createGuide () {
        GuideImpl guide = new GuideImpl ();
        return guide;
    }

    public Map.Entry createNodeEntry () {
        NodeEntryImpl nodeEntry = new NodeEntryImpl ();
        return nodeEntry;
    }

    public FilteringStyle createFilteringStyle () {
        FilteringStyleImpl filteringStyle = new FilteringStyleImpl ();
        return filteringStyle;
    }

    public DiagramStyle createDiagramStyle () {
        DiagramStyleImpl diagramStyle = new DiagramStyleImpl ();
        return diagramStyle;
    }

    public ImageStyle createImageStyle () {
        ImageStyleImpl imageStyle = new ImageStyleImpl ();
        return imageStyle;
    }

    public ImageBufferStyle createImageBufferStyle () {
        ImageBufferStyleImpl imageBufferStyle = new ImageBufferStyleImpl ();
        return imageBufferStyle;
    }

    public Sorting createSortingFromString (EDataType eDataType, String initialValue) {
        Sorting result = Sorting.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertSortingToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public Filtering createFilteringFromString (EDataType eDataType, String initialValue) {
        Filtering result = Filtering.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertFilteringToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public Routing createRoutingFromString (EDataType eDataType, String initialValue) {
        Routing result = Routing.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertRoutingToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public Smoothness createSmoothnessFromString (EDataType eDataType, String initialValue) {
        Smoothness result = Smoothness.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertSmoothnessToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public JumpLinkStatus createJumpLinkStatusFromString (EDataType eDataType, String initialValue) {
        JumpLinkStatus result = JumpLinkStatus.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertJumpLinkStatusToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public JumpLinkType createJumpLinkTypeFromString (EDataType eDataType, String initialValue) {
        JumpLinkType result = JumpLinkType.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertJumpLinkTypeToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public Alignment createAlignmentFromString (EDataType eDataType, String initialValue) {
        Alignment result = Alignment.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertAlignmentToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public SortingDirection createSortingDirectionFromString (EDataType eDataType, String initialValue) {
        SortingDirection result = SortingDirection.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertSortingDirectionToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public MeasurementUnit createMeasurementUnitFromString (EDataType eDataType, String initialValue) {
        MeasurementUnit result = MeasurementUnit.get (initialValue);
        if (result == null) throw new IllegalArgumentException ("The value '" + initialValue + "' is not a valid enumerator of '" + eDataType.getName () + "'");

        return result;
    }

    public String convertMeasurementUnitToString (EDataType eDataType, Object instanceValue) {
        return instanceValue == null ? null : instanceValue.toString ();
    }

    public List createRelativeBendpointListFromString (EDataType eDataType, String initialValue) {
        StringTokenizer st = new StringTokenizer (initialValue, "$");
        List newList = new ArrayList (st.countTokens ());
        while (st.hasMoreTokens ()) newList.add (new RelativeBendpoint (st.nextToken ().trim ()));

        return newList;
    }

    public String convertRelativeBendpointListToString (EDataType eDataType, Object instanceValue) {
        StringBuffer sb = new StringBuffer ();
        for (Iterator i = ((List) instanceValue).iterator ();
        i.hasNext ();) {
            RelativeBendpoint point = (RelativeBendpoint) i.next ();
            if (sb.length () != 0) sb.append ('$');

            sb.append (point.convertToString ());
        }
        return sb.toString ();
    }

    public List createFilterKeyListFromString (EDataType eDataType, String initialValue) {
        StringTokenizer st = new StringTokenizer (initialValue, ",");
        List newList = new ArrayList (st.countTokens ());
        while (st.hasMoreTokens ()) newList.add (st.nextToken ().trim ());

        return newList;
    }

    public String convertFilterKeyListToString (EDataType eDataType, Object instanceValue) {
        StringBuffer sb = new StringBuffer ();
        for (Iterator i = ((List) instanceValue).iterator ();
        i.hasNext ();) {
            String key = (String) i.next ();
            if (sb.length () != 0) sb.append (',');

            sb.append (key);
        }
        return sb.toString ();
    }

    public Map createSortKeyMapFromString (EDataType eDataType, String initialValue) {
        StringTokenizer st = new StringTokenizer (initialValue, ",");
        Map newMap = new LinkedHashMap (st.countTokens ());
        String s;
        int i;
        while (st.hasMoreTokens ()) {
            s = st.nextToken ().trim ();
            i = s.indexOf (':');
            newMap.put (s.substring (0, i).trim (), SortingDirection.get (s.substring (i + 1).trim ()));
        }
        return newMap;
    }

    public String convertSortKeyMapToString (EDataType eDataType, Object instanceValue) {
        StringBuffer sb = new StringBuffer ();
        Map keyMap = (Map) instanceValue;
        for (Iterator i = keyMap.keySet ().iterator ();
        i.hasNext ();) {
            String key = (String) i.next ();
            SortingDirection direction = (SortingDirection) keyMap.get (key);
            if (sb.length () != 0) sb.append (',');

            sb.append (key + ":" + direction.getName ());
        }
        return sb.toString ();
    }

    public NotationPackage getNotationPackage () {
        return (NotationPackage) getEPackage ();
    }

    public static NotationPackage getPackage () {
        return NotationPackage.eINSTANCE;
    }

}

