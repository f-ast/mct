package org.eclipse.gmf.runtime.emf.commands.core.command;

import java.util.ArrayList;

import java.util.Collection;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import org.eclipse.core.commands.operations.IOperationApprover;

import org.eclipse.core.commands.operations.IUndoableOperation;

import org.eclipse.core.commands.operations.OperationHistoryFactory;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.emf.transaction.TransactionalEditingDomain;

import org.eclipse.emf.workspace.AbstractEMFOperation;

import org.eclipse.emf.workspace.CompositeEMFOperation;

import org.eclipse.gmf.runtime.common.core.command.CommandResult;

import org.eclipse.gmf.runtime.common.core.command.ICommand;

import org.eclipse.gmf.runtime.common.core.command.ICompositeCommand;

public class CompositeTransactionalCommand extends CompositeEMFOperation implements ICompositeCommand {
    private CommandResult commandResult;

    public CompositeTransactionalCommand (TransactionalEditingDomain domain, String label) {
        super (domain, label);
    }

    public CompositeTransactionalCommand (TransactionalEditingDomain domain, String label, Map options) {
        super (domain, label, options);
    }

    public CompositeTransactionalCommand (TransactionalEditingDomain domain, String label, List children) {
        super (domain, label, children);
    }

    public CompositeTransactionalCommand (TransactionalEditingDomain domain, String label, List children, Map options) {
        super (domain, label, children, options);
    }

    public List getAffectedFiles () {
        List result = new ArrayList ();
        for (Iterator i = iterator ();
        i.hasNext ();) {
            IUndoableOperation nextOperation = (IUndoableOperation) i.next ();
            if (nextOperation instanceof ICommand) {
                List nextAffected = ((ICommand) nextOperation).getAffectedFiles ();
                if (nextAffected != null) {
                    result.addAll (nextAffected);
                }
            }
        }
        return result;
    }

    public CommandResult getCommandResult () {
        return commandResult;
    }

    protected void setResult (CommandResult result) {
        this.commandResult = result;
    }

    protected List getReturnValues () {
        List returnValues = new ArrayList ();
        for (Iterator i = iterator ();
        i.hasNext ();) {
            IUndoableOperation operation = (IUndoableOperation) i.next ();
            if (operation instanceof ICommand) {
                ICommand command = (ICommand) operation;
                CommandResult result = command.getCommandResult ();
                if (result != null) {
                    Object returnValue = result.getReturnValue ();
                    if (returnValue != null) {
                        if (getClass ().isInstance (command)) {
                            if (returnValue != null && returnValue instanceof Collection) {
                                returnValues.addAll ((Collection) returnValue);
                            } else {
                                returnValues.add (returnValue);
                            }
                        } else {
                            returnValues.add (returnValue);
                        }
                    }
                }
            }
        }
        return returnValues;
    }

    protected IStatus aggregateStatuses (List statuses) {
        IStatus aggregate = super.aggregateStatuses (statuses);
        setResult (new CommandResult (aggregate, getReturnValues ()));
        return aggregate;
    }

    public final ICommand compose (IUndoableOperation operation) {
        if (operation != null) {
            add (operation);
        }
        return this;
    }

    public ICommand reduce () {
        switch (size ()) {
            case 1 :
                IUndoableOperation child = (IUndoableOperation) iterator ().next ();
                if (child instanceof ICommand && (child instanceof CompositeEMFOperation || child instanceof AbstractEMFOperation)) {
                    return ((ICommand) child).reduce ();
                }
        }
        return this;
    }

    public final boolean isEmpty () {
        return size () < 1;
    }

    public boolean canExecute () {
        return ! isEmpty () && super.canExecute ();
    }

    public boolean canRedo () {
        return ! isEmpty () && super.canRedo ();
    }

    public boolean canUndo () {
        return ! isEmpty () && super.canUndo ();
    }

}

