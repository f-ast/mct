package org.eclipse.gmf.runtime.diagram.ui.commands;

import org.eclipse.core.commands.ExecutionException;

import org.eclipse.core.resources.ICommand;

import org.eclipse.core.runtime.Assert;

import org.eclipse.core.runtime.IAdaptable;

import org.eclipse.core.runtime.IProgressMonitor;

import org.eclipse.gef.commands.Command;

import org.eclipse.gmf.runtime.common.core.command.AbstractCommand;

import org.eclipse.gmf.runtime.common.core.command.CommandResult;

public class CommandProxy extends AbstractCommand {
    private Command command;

    public CommandProxy (Command command) {
        super ((command.getLabel () == null) ? "" : command.getLabel (), null);
        Assert.isNotNull (command);
        this.command = command;
    }

    protected CommandResult doExecuteWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        command.execute ();
        return CommandResult.newOKCommandResult ();
    }

    protected CommandResult doRedoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        command.redo ();
        return CommandResult.newOKCommandResult ();
    }

    protected CommandResult doUndoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        command.undo ();
        return CommandResult.newOKCommandResult ();
    }

    public Command getCommand () {
        return command;
    }

    public boolean canUndo () {
        return command.canUndo ();
    }

    public boolean canRedo () {
        return CommandUtilities.canRedo (command);
    }

    public boolean canExecute () {
        return command.canExecute ();
    }

    public void dispose () {
        super.dispose ();
        command.dispose ();
    }

}

