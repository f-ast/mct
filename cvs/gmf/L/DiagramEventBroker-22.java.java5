package org.eclipse.gmf.runtime.diagram.core.listener;

import java.lang.ref.WeakReference;

import java.util.ArrayList;

import java.util.Collection;

import java.util.Collections;

import java.util.HashMap;

import java.util.HashSet;

import java.util.Iterator;

import java.util.LinkedHashMap;

import java.util.LinkedHashSet;

import java.util.List;

import java.util.Map;

import java.util.Set;

import java.util.WeakHashMap;

import org.eclipse.emf.common.command.Command;

import org.eclipse.emf.common.command.CompoundCommand;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EAnnotation;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.EStructuralFeature;

import org.eclipse.emf.transaction.NotificationFilter;

import org.eclipse.emf.transaction.ResourceSetChangeEvent;

import org.eclipse.emf.transaction.ResourceSetListenerImpl;

import org.eclipse.emf.transaction.TransactionalEditingDomain;

import org.eclipse.emf.workspace.EMFOperationCommand;

import org.eclipse.gmf.runtime.diagram.core.internal.commands.PersistViewsCommand;

import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;

import org.eclipse.gmf.runtime.notation.NotationPackage;

import org.eclipse.gmf.runtime.notation.View;

public class DiagramEventBroker extends ResourceSetListenerImpl {
    private static String LISTEN_TO_ALL_FEATURES = "*";
    private final NotifierToKeyToListenersSetMap preListeners = new NotifierToKeyToListenersSetMap ();
    private final NotifierToKeyToListenersSetMap postListeners = new NotifierToKeyToListenersSetMap ();
    private static final Map instanceMap = new WeakHashMap ();
    private WeakReference editingDomainRef;
    private final class NotifierToKeyToListenersSetMap {
        private final Map listenersMap = new WeakHashMap ();

        public void addListener (EObject notifier, Object key, Object listener) {
            Map keys = (Map) listenersMap.get (notifier);
            if (keys == null) {
                keys = new HashMap (4);
                listenersMap.put (notifier, keys);
            }
            Map listenersSet = (Map) keys.get (key);
            if (listenersSet == null) {
                listenersSet = new LinkedHashMap (4);
                keys.put (key, listenersSet);
            }
            listenersSet.put (listener, null);
        }

        public void addListener (EObject notifier, Object listener) {
            addListener (notifier, LISTEN_TO_ALL_FEATURES, listener);
        }

        public void removeListener (EObject notifier, Object key, Object listener) {
            Map keys = (Map) listenersMap.get (notifier);
            if (keys != null) {
                Map listenersSet = (Map) keys.get (key);
                if (listenersSet != null) {
                    listenersSet.remove (listener);
                    if (listenersSet.isEmpty ()) {
                        keys.remove (key);
                    }
                }
                if (keys.isEmpty ()) listenersMap.remove (notifier);

            }
        }

        public Set getListeners (Object notifier, Object key) {
            Map keys = (Map) listenersMap.get (notifier);
            if (keys != null) {
                Map listenersSet = (Map) keys.get (key);
                if (listenersSet != null) {
                    return listenersSet.keySet ();
                }
            }
            return Collections.EMPTY_SET;
        }

        public Set getAllListeners (Object notifier) {
            Map keys = (Map) listenersMap.get (notifier);
            if (keys == null || keys.isEmpty ()) {
                return Collections.EMPTY_SET;
            }
            Set listenersCollection = new LinkedHashSet ();
            Set enteries = keys.entrySet ();
            for (Iterator iter = enteries.iterator ();
            iter.hasNext ();) {
                Map.Entry entry = (Map.Entry) iter.next ();
                Map listenersSet = (Map) entry.getValue ();
                if (listenersSet != null && ! listenersSet.isEmpty ()) listenersCollection.addAll (listenersSet.keySet ());

            }
            return listenersCollection;
        }

        public boolean isEmpty () {
            return listenersMap.isEmpty ();
        }

    }

    protected DiagramEventBroker () {
        super (NotificationFilter.createNotifierTypeFilter (EObject.class));
    }

    public static DiagramEventBroker getInstance (TransactionalEditingDomain editingDomain) {
        return initializeDiagramEventBroker (editingDomain);
    }

    public static void startListening (TransactionalEditingDomain editingDomain) {
        initializeDiagramEventBroker (editingDomain);
    }

    private static DiagramEventBroker initializeDiagramEventBroker (TransactionalEditingDomain editingDomain) {
        WeakReference reference = (WeakReference) instanceMap.get (editingDomain);
        if (reference == null) {
            DiagramEventBroker diagramEventBroker = debFactory.createDiagramEventBroker (editingDomain);
            if (diagramEventBroker.editingDomainRef == null) {
                diagramEventBroker.editingDomainRef = new WeakReference (editingDomain);
            }
            editingDomain.addResourceSetListener (diagramEventBroker);
            reference = new WeakReference (diagramEventBroker);
            instanceMap.put (editingDomain, reference);
        }
        return (DiagramEventBroker) reference.get ();
    }

    public static interface DiagramEventBrokerFactory {

        public DiagramEventBroker createDiagramEventBroker (TransactionalEditingDomain editingDomain);

    }

    private static class DiagramEventBrokerFactoryImpl implements DiagramEventBrokerFactory {

        public DiagramEventBroker createDiagramEventBroker (TransactionalEditingDomain editingDomain) {
            DiagramEventBroker diagramEventBroker = new DiagramEventBroker ();
            diagramEventBroker.editingDomainRef = new WeakReference (editingDomain);
            return diagramEventBroker;
        }

    }

    private static DiagramEventBrokerFactory debFactory = new DiagramEventBrokerFactoryImpl ();

    public static void registerDiagramEventBrokerFactory (DiagramEventBrokerFactory newDebFactory) {
        debFactory = newDebFactory;
    }

    public static void stopListening (TransactionalEditingDomain editingDomain) {
        DiagramEventBroker diagramEventBroker = getInstance (editingDomain);
        if (diagramEventBroker != null) {
            editingDomain.removeResourceSetListener (diagramEventBroker);
            instanceMap.remove (editingDomain);
        }
    }

    public Command transactionAboutToCommit (ResourceSetChangeEvent event) {
        Set deletedObjects = NotificationUtil.getDeletedObjects (event);
        Set existingObjects = new HashSet ();
        Set elementsInPersistQueue = new LinkedHashSet ();
        CompoundCommand cc = new CompoundCommand ();
        TransactionalEditingDomain editingDomain = (TransactionalEditingDomain) editingDomainRef.get ();
        boolean hasPreListeners = (preListeners.isEmpty () == false);
        List viewsToPersistList = new ArrayList ();
        boolean deleteElementCheckRequired = ! deletedObjects.isEmpty ();
        for (Iterator i = event.getNotifications ().iterator ();
        i.hasNext ();) {
            final Notification notification = (Notification) i.next ();
            if (shouldIgnoreNotification (notification)) continue;

            Object notifier = notification.getNotifier ();
            if (notifier instanceof EObject) {
                boolean deleted = false;
                if (deleteElementCheckRequired) {
                    deleted = ! existingObjects.contains (notifier);
                    if (deleted) {
                        deleted = isDeleted (deletedObjects, (EObject) notifier);
                        if (! deleted) existingObjects.add (notifier);

                    }
                }
                if (deleted) {
                    continue;
                }
                if (editingDomain != null) {
                    View viewToPersist = getViewToPersist (notification, elementsInPersistQueue);
                    if (viewToPersist != null) {
                        viewsToPersistList.add (viewToPersist);
                    }
                }
                if (hasPreListeners) {
                    Command cmd = fireTransactionAboutToCommit (notification);
                    if (cmd != null) {
                        cc.append (cmd);
                    }
                }
            }
        }
        if (viewsToPersistList.isEmpty () == false) {
            PersistViewsCommand persistCmd = new PersistViewsCommand (editingDomain, viewsToPersistList);
            cc.append (new EMFOperationCommand (editingDomain, persistCmd));
        }
        return cc.isEmpty () ? null : cc;
    }

    public void resourceSetChanged (ResourceSetChangeEvent event) {
        if (postListeners.isEmpty ()) {
            return;
        }
        Set deletedObjects = NotificationUtil.getDeletedObjects (event);
        Set existingObjects = new HashSet ();
        boolean deleteElementCheckRequired = ! deletedObjects.isEmpty ();
        for (Iterator i = event.getNotifications ().iterator ();
        i.hasNext ();) {
            final Notification notification = (Notification) i.next ();
            boolean customNotification = NotificationUtil.isCustomNotification (notification);
            if (! customNotification && shouldIgnoreNotification (notification)) continue;

            Object notifier = notification.getNotifier ();
            if (notifier instanceof EObject) {
                boolean deleted = false;
                if (deleteElementCheckRequired && ! customNotification) {
                    deleted = ! existingObjects.contains (notifier);
                    if (deleted) {
                        deleted = isDeleted (deletedObjects, (EObject) notifier);
                        if (! deleted) existingObjects.add (notifier);

                    }
                }
                if (! customNotification && deleted) {
                    continue;
                }
                fireNotification (notification);
            }
        }
    }

    private boolean isDeleted (Set deletedObjects, EObject notifier) {
        EObject object = notifier;
        while (object != null) {
            if (deletedObjects.contains (object)) {
                if (object != notifier) {
                    addDeletedBranch (deletedObjects, notifier);
                }
                return true;
            }
            object = object.eContainer ();
        }
        return false;
    }

    private void addDeletedBranch (Set deletedObjects, EObject notifier) {
        EObject object = notifier;
        while (object != null) {
            if (! deletedObjects.add (object)) {
                break;
            }
            object = object.eContainer ();
        }
    }

    protected boolean shouldIgnoreNotification (Notification notification) {
        if ((notification.isTouch () && notification.getEventType () != Notification.RESOLVE) || NotationPackage.eINSTANCE.getView_Mutable ().equals (notification.getFeature ())) {
            return true;
        }
        return false;
    }

    private void fireNotification (Notification event) {
        Collection listenerList = getInterestedNotificationListeners (event, postListeners);
        if (! listenerList.isEmpty ()) {
            for (Iterator listenerIT = listenerList.iterator ();
            listenerIT.hasNext ();) {
                NotificationListener listener = (NotificationListener) listenerIT.next ();
                listener.notifyChanged (event);
            }
        }
    }

    private Command fireTransactionAboutToCommit (Notification event) {
        Collection listenerList = getInterestedNotificationListeners (event, preListeners);
        if (! listenerList.isEmpty ()) {
            CompoundCommand cc = new CompoundCommand ();
            for (Iterator listenerIT = listenerList.iterator ();
            listenerIT.hasNext ();) {
                NotificationPreCommitListener listener = (NotificationPreCommitListener) listenerIT.next ();
                Command cmd = listener.transactionAboutToCommit (event);
                if (cmd != null) {
                    cc.append (cmd);
                }
            }
            return cc.isEmpty () ? null : cc;
        }
        return null;
    }

    private View getViewToPersist (Notification event, Set elementsInPersistQueue) {
        if (! event.isTouch ()) {
            EObject elementToPersist = (EObject) event.getNotifier ();
            while (elementToPersist != null && ! (elementToPersist instanceof View)) {
                elementToPersist = elementToPersist.eContainer ();
            }
            if (elementToPersist != null && ! elementsInPersistQueue.contains (elementToPersist) && ViewUtil.isTransient (elementToPersist)) {
                if (! NotificationFilter.READ.matches (event)) {
                    elementsInPersistQueue.add (elementToPersist);
                    View view = (View) elementToPersist;
                    if (! view.isMutable ()) {
                        View viewToPersist = ViewUtil.getTopViewToPersist (view);
                        if (viewToPersist != null) {
                            elementsInPersistQueue.add (viewToPersist);
                            return viewToPersist;
                        }
                    }
                }
            }
        }
        return null;
    }

    public final void addNotificationListener (EObject target, NotificationPreCommitListener listener) {
        if (target != null) {
            preListeners.addListener (target, LISTEN_TO_ALL_FEATURES, listener);
        }
    }

    public final void addNotificationListener (EObject target, NotificationListener listener) {
        if (target != null) {
            postListeners.addListener (target, LISTEN_TO_ALL_FEATURES, listener);
        }
    }

    public final void addNotificationListener (EObject target, EStructuralFeature key, NotificationPreCommitListener listener) {
        if (target != null) {
            preListeners.addListener (target, key, listener);
        }
    }

    public final void addNotificationListener (EObject target, EStructuralFeature key, NotificationListener listener) {
        if (target != null) {
            postListeners.addListener (target, key, listener);
        }
    }

    public final void removeNotificationListener (EObject target, NotificationPreCommitListener listener) {
        if (target != null) {
            preListeners.removeListener (target, LISTEN_TO_ALL_FEATURES, listener);
        }
    }

    public final void removeNotificationListener (EObject target, NotificationListener listener) {
        if (target != null) {
            postListeners.removeListener (target, LISTEN_TO_ALL_FEATURES, listener);
        }
    }

    public final void removeNotificationListener (EObject target, Object key, NotificationPreCommitListener listener) {
        if (target != null) {
            preListeners.removeListener (target, key, listener);
        }
    }

    public final void removeNotificationListener (EObject target, Object key, NotificationListener listener) {
        if (target != null) {
            postListeners.removeListener (target, key, listener);
        }
    }

    private Set getNotificationListeners (Object notifier, NotifierToKeyToListenersSetMap listeners) {
        return listeners.getListeners (notifier, LISTEN_TO_ALL_FEATURES);
    }

    private Set getNotificationListeners (Object notifier, Object key, NotifierToKeyToListenersSetMap listeners) {
        if (key != null) {
            if (! key.equals (LISTEN_TO_ALL_FEATURES)) {
                Set listenersSet = new LinkedHashSet ();
                Collection c = listeners.getListeners (notifier, key);
                if (c != null && ! c.isEmpty ()) listenersSet.addAll (c);

                c = listeners.getListeners (notifier, LISTEN_TO_ALL_FEATURES);
                if (c != null && ! c.isEmpty ()) listenersSet.addAll (c);

                return listenersSet;
            } else if (key.equals (LISTEN_TO_ALL_FEATURES)) {
                return listeners.getAllListeners (notifier);
            }

        }
        return listeners.getAllListeners (notifier);
    }

    final protected Set getInterestedNotificationListeners (Notification event, NotifierToKeyToListenersSetMap listeners) {
        Set listenerSet = new LinkedHashSet ();
        Collection c = getNotificationListeners (event.getNotifier (), event.getFeature (), listeners);
        if (c != null) {
            listenerSet.addAll (c);
        }
        EObject notifier = (EObject) event.getNotifier ();
        if (NotationPackage.eINSTANCE.getView_Visible ().equals (event.getFeature ()) && notifier.eContainer () != null) {
            listenerSet.addAll (getNotificationListeners (notifier.eContainer (), listeners));
        } else if (notifier instanceof EAnnotation) {
            addListenersOfNotifier (listenerSet, notifier.eContainer (), event, listeners);
        } else if (! (notifier instanceof View)) {
            while (notifier != null && ! (notifier instanceof View)) {
                notifier = notifier.eContainer ();
            }
            addListenersOfNotifier (listenerSet, notifier, event, listeners);
        }

        return listenerSet;
    }

    public boolean isAggregatePrecommitListener () {
        return true;
    }

    private void addListenersOfNotifier (Set listenerSet, EObject notifier, Notification event, NotifierToKeyToListenersSetMap listeners) {
        if (notifier != null) {
            Collection c = getNotificationListeners (notifier, event.getFeature (), listeners);
            if (c != null) {
                if (listenerSet.isEmpty ()) listenerSet.addAll (c);
                else {
                    Iterator i = c.iterator ();
                    while (i.hasNext ()) {
                        Object o = i.next ();
                        listenerSet.add (o);
                    }
                }
            }
        }
    }

}

