package org.eclipse.gmf.runtime.draw2d.ui.figures;

import java.util.ArrayList;

import org.eclipse.draw2d.ColorConstants;

import org.eclipse.draw2d.Figure;

import org.eclipse.draw2d.FigureUtilities;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Insets;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.swt.graphics.Font;

import org.eclipse.swt.graphics.Image;

import com.ibm.icu.text.BreakIterator;

import com.ibm.icu.util.StringTokenizer;

public class WrapLabel extends Figure implements PositionConstants {
    private static String _ellipse = "...";
    private static final Dimension EMPTY_DIMENSION = new Dimension (0, 0);
    private static int FLAG_SELECTED = MAX_FLAG << 1;
    private static int FLAG_HASFOCUS = MAX_FLAG << 2;
    private static int FLAG_UNDERLINED = MAX_FLAG << 3;
    private static int FLAG_STRIKEDTHROUGH = MAX_FLAG << 4;
    private static int FLAG_WRAP = MAX_FLAG << 5;
    private static int FLAG_TEXT_ALIGN = MAX_FLAG << 6;
    private static int FLAG_WRAP_ALIGN = MAX_FLAG << 9;
    private static int FLAG_ICON_ALIGN = MAX_FLAG << 12;
    private static int FLAG_LABEL_ALIGN = MAX_FLAG << 15;
    private static int FLAG_TEXT_PLACEMENT = MAX_FLAG << 18;
    private String text = "";
    private String subStringText;
    private Dimension textSize;
    private Point textLocation;
    private Dimension cachedPrefSizeHint = new Dimension (- 1, - 1);
    private Dimension cachedTextSizeHint = new Dimension (- 1, - 1);
    private Point iconLocation;
    private class IconInfo {
        private ArrayList icons = new ArrayList ();
        private Dimension totalIconSize;

        public Image getIcon (int i) {
            if (i >= icons.size ()) return null;

            return (Image) icons.get (i);
        }

        public void setIcon (Image icon, int i) {
            if (i >= icons.size ()) {
                for (int j = icons.size ();
                j < i; j ++) icons.add (null);

                icons.add (icon);
                icons.trimToSize ();
            } else icons.set (i, icon);

        }

        public Dimension getIconSize (int i) {
            Image img = getIcon (i);
            if (img != null && ! img.isDisposed ()) {
                org.eclipse.swt.graphics.Rectangle imgBounds = img.getBounds ();
                return new Dimension (MapModeUtil.getMapMode (WrapLabel.this).DPtoLP (imgBounds.width), MapModeUtil.getMapMode (WrapLabel.this).DPtoLP (imgBounds.height));
            }
            return EMPTY_DIMENSION;
        }

        public int getNumberofIcons () {
            return icons.size ();
        }

        public Dimension getTotalIconSize () {
            if (totalIconSize != null) return totalIconSize;

            totalIconSize = new Dimension (0, 0);
            for (int i = 0;
            i < getNumberofIcons (); i ++) {
                Dimension iconSize = getIconSize (i);
                if (iconSize != null) {
                    totalIconSize.width += iconSize.width;
                    if (iconSize.height > totalIconSize.height) totalIconSize.height = iconSize.height;

                }
            }
            return totalIconSize;
        }

        public void invalidate () {
            totalIconSize = null;
        }

    }

    private IconInfo iconInfo = null;

    public WrapLabel () {
        setTextAlignment (CENTER);
        setIconAlignment (CENTER);
        setLabelAlignment (CENTER);
        setTextWrapAlignment (LEFT);
        setTextPlacement (EAST);
    }

    public WrapLabel (String s) {
        setText (s);
    }

    public WrapLabel (Image i) {
        setIcon (i);
    }

    public WrapLabel (String s, Image i) {
        setText (s);
        setIcon (i);
    }

    private void alignOnHeight (Point loc, Dimension size, int alignment) {
        Insets insets = getInsets ();
        switch (alignment) {
            case TOP :
                loc.y = insets.top;
                break;
            case BOTTOM :
                loc.y = bounds.height - size.height - insets.bottom;
                break;
            default :
                loc.y = (bounds.height - size.height) / 2;
        }
    }

    private void alignOnWidth (Point loc, Dimension size, int alignment) {
        Insets insets = getInsets ();
        switch (alignment) {
            case LEFT :
                loc.x = insets.left;
                break;
            case RIGHT :
                loc.x = bounds.width - size.width - insets.right;
                break;
            default :
                loc.x = (bounds.width - size.width) / 2;
        }
    }

    private void calculateAlignment () {
        Dimension iconSize = getTotalIconSize ();
        switch (getTextPlacement ()) {
            case EAST :
            case WEST :
                alignOnHeight (textLocation, getTextSize (), getTextAlignment ());
                alignOnHeight (getIconLocation (), iconSize, getIconAlignment ());
                break;
            case NORTH :
            case SOUTH :
                alignOnWidth (textLocation, getSubStringTextSize (), getTextAlignment ());
                alignOnWidth (getIconLocation (), iconSize, getIconAlignment ());
                break;
        }
    }

    protected Dimension calculateLabelSize (Dimension txtSize) {
        int gap = getIconTextGap ();
        if (! hasIcons () || getText ().equals ("")) gap = 0;

        Dimension d = new Dimension (0, 0);
        Dimension iconSize = getTotalIconSize ();
        if (getTextPlacement () == WEST || getTextPlacement () == EAST) {
            d.width = iconSize.width + gap + txtSize.width;
            d.height = Math.max (iconSize.height, txtSize.height);
        } else {
            d.width = Math.max (iconSize.width, txtSize.width);
            d.height = iconSize.height + gap + txtSize.height;
        }
        return d;
    }

    private void calculateLocations () {
        textLocation = new Point ();
        iconLocation = new Point ();
        calculatePlacement ();
        calculateAlignment ();
        Dimension offset = getSize ().getDifference (getPreferredSize (getSize ().width, getSize ().height));
        offset.width += getTextSize ().width - getSubStringTextSize ().width;
        switch (getLabelAlignment ()) {
            case CENTER :
                offset.scale (0.5f);
                break;
            case LEFT :
                offset.scale (0.0f);
                break;
            case RIGHT :
                offset.scale (1.0f);
                break;
            case TOP :
                offset.height = 0;
                offset.scale (0.5f);
                break;
            case BOTTOM :
                offset.height = offset.height * 2;
                offset.scale (0.5f);
                break;
            default :
                offset.scale (0.5f);
                break;
        }
        switch (getTextPlacement ()) {
            case EAST :
            case WEST :
                offset.height = 0;
                break;
            case NORTH :
            case SOUTH :
                offset.width = 0;
                break;
        }
        textLocation.translate (offset);
        iconLocation.translate (offset);
    }

    private void calculatePlacement () {
        int gap = getIconTextGap ();
        if (! hasIcons () || text.equals ("")) gap = 0;

        Insets insets = getInsets ();
        Dimension iconSize = getTotalIconSize ();
        switch (getTextPlacement ()) {
            case EAST :
                iconLocation.x = insets.left;
                textLocation.x = iconSize.width + gap + insets.left;
                break;
            case WEST :
                textLocation.x = insets.left;
                iconLocation.x = getSubStringTextSize ().width + gap + insets.left;
                break;
            case NORTH :
                textLocation.y = insets.top;
                iconLocation.y = getTextSize ().height + gap + insets.top;
                break;
            case SOUTH :
                textLocation.y = iconSize.height + gap + insets.top;
                iconLocation.y = insets.top;
        }
    }

    protected Dimension calculateSubStringTextSize () {
        return getTextExtents (getSubStringText (), getFont ());
    }

    protected Dimension calculateTextSize (int wHint, int hHint) {
        return getTextExtents (getWrappedText (wHint, hHint), getFont ());
    }

    private void clearLocations () {
        iconLocation = textLocation = null;
    }

    public Image getIcon () {
        return getIcon (0);
    }

    public Image getIcon (int index) {
        if (iconInfo == null) return null;

        return iconInfo.getIcon (index);
    }

    protected boolean hasIcons () {
        return ! Dimension.SINGLETON.equals (getTotalIconSize ());
    }

    public int getIconAlignment () {
        return getAlignment (FLAG_ICON_ALIGN);
    }

    public Rectangle getIconBounds () {
        return new Rectangle (getBounds ().getLocation ().translate (getIconLocation ()), getTotalIconSize ());
    }

    protected Point getIconLocation () {
        if (iconLocation == null) calculateLocations ();

        return iconLocation;
    }

    public int getIconTextGap () {
        return MapModeUtil.getMapMode (this).DPtoLP (3);
    }

    public Dimension getMinimumSize (int w, int h) {
        if (minSize != null) return minSize;

        minSize = new Dimension ();
        if (getLayoutManager () != null) minSize.setSize (getLayoutManager ().getMinimumSize (this, w, h));

        Dimension d = getTextExtents (getEllipse (), getFont ()).intersect (getTextExtents (getText (), getFont ()));
        Dimension labelSize = calculateLabelSize (d);
        Insets insets = getInsets ();
        labelSize.expand (insets.getWidth (), insets.getHeight ());
        minSize.union (labelSize);
        return minSize;
    }

    public Dimension getPreferredSize (int wHint, int hHint) {
        if (prefSize == null || wHint != cachedPrefSizeHint.width || hHint != cachedPrefSizeHint.height) {
            prefSize = calculateLabelSize (getTextSize (wHint, hHint));
            Insets insets = getInsets ();
            prefSize.expand (insets.getWidth (), insets.getHeight ());
            if (getLayoutManager () != null) prefSize.union (getLayoutManager ().getPreferredSize (this, wHint, hHint));

            prefSize.union (getMinimumSize (wHint, hHint));
            cachedPrefSizeHint.width = wHint;
            cachedPrefSizeHint.height = hHint;
        }
        return prefSize;
    }

    public Dimension getMaximumSize () {
        return prefSize;
    }

    public String getSubStringText () {
        if (subStringText != null) return subStringText;

        Dimension shrink = getPreferredSize (getSize ().width, getSize ().height).getDifference (getSize ());
        Dimension effectiveSize = getTextSize ().getExpanded (- shrink.width, - shrink.height);
        Font f = getFont ();
        int fontHeight = MapModeUtil.getMapMode (this).DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ());
        int maxLines = (int) (effectiveSize.height / (double) fontHeight);
        StringBuffer accumlatedText = new StringBuffer ();
        StringBuffer remainingText = new StringBuffer (getText ());
        int i = 0, j = 0;
        while (remainingText.length () > 0 && j ++ < maxLines) {
            i = getLineWrapPosition (remainingText.toString (), f, effectiveSize.width);
            if (accumlatedText.length () > 0) accumlatedText.append ("\n");

            if (i == 0 || (remainingText.length () > i && j == maxLines)) {
                int dotsWidth = getTextExtents (getEllipse (), f).width;
                i = getLargestSubstringConfinedTo (remainingText.toString (), f, Math.max (effectiveSize.width - dotsWidth, 0));
                accumlatedText.append (remainingText.substring (0, i));
                accumlatedText.append (getEllipse ());
            } else accumlatedText.append (remainingText.substring (0, i));

            remainingText.delete (0, i);
        }
        return subStringText = accumlatedText.toString ();
    }

    private String getWrappedText (int wHint, int hHint) {
        if (! isTextWrapped () || wHint == - 1) return getText ();

        Dimension iconSize = getTotalIconSize ();
        if (hasIcons ()) {
            switch (getTextPlacement ()) {
                case EAST :
                case WEST :
                    wHint -= iconSize.width + getIconTextGap ();
                    break;
                case NORTH :
                case SOUTH :
                    if (hHint != - 1) hHint -= iconSize.height + getIconTextGap ();

                    break;
            }
        }
        Font f = getFont ();
        int maxLines = Integer.MAX_VALUE;
        if (hHint != - 1) {
            int fontHeight = MapModeUtil.getMapMode (this).DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ());
            maxLines = (int) (hHint / (double) fontHeight);
        }
        StringBuffer accumlatedText = new StringBuffer ();
        StringBuffer remainingText = new StringBuffer (getText ());
        int i = 0, j = 0;
        while (remainingText.length () > 0 && j ++ < maxLines) {
            if ((i = getLineWrapPosition (remainingText.toString (), f, wHint)) == 0) break;

            if (accumlatedText.length () > 0) accumlatedText.append ("\n");

            accumlatedText.append (remainingText.substring (0, i));
            remainingText.delete (0, i);
        }
        return accumlatedText.toString ();
    }

    protected Dimension getSubStringTextSize () {
        return calculateSubStringTextSize ();
    }

    public String getText () {
        return text;
    }

    public int getTextAlignment () {
        return getAlignment (FLAG_TEXT_ALIGN);
    }

    private int getLabelAlignment () {
        return getAlignment (FLAG_LABEL_ALIGN);
    }

    public Rectangle getTextBounds () {
        return new Rectangle (getBounds ().getLocation ().translate (getTextLocation ()), getTextSize ());
    }

    protected Point getTextLocation () {
        if (textLocation != null) return textLocation;

        calculateLocations ();
        return textLocation;
    }

    public int getTextPlacement () {
        return getPlacement (FLAG_TEXT_PLACEMENT);
    }

    protected Dimension getTextSize (int wHint, int hHint) {
        if (textSize == null || wHint != cachedTextSizeHint.width || hHint != cachedTextSizeHint.height) {
            textSize = calculateTextSize (wHint, hHint);
            cachedTextSizeHint.width = wHint;
            cachedTextSizeHint.height = hHint;
        }
        return textSize;
    }

    private final Dimension getTextSize () {
        return getTextSize (getSize ().width, getSize ().height);
    }

    public void invalidate () {
        prefSize = null;
        minSize = null;
        clearLocations ();
        textSize = null;
        subStringText = null;
        if (iconInfo != null) iconInfo.invalidate ();

        super.invalidate ();
    }

    public boolean isTextTruncated () {
        return ! getSubStringTextSize ().equals (getTextSize ());
    }

    public void paintFigure (Graphics graphics) {
        if (isSelected ()) {
            graphics.pushState ();
            graphics.setBackgroundColor (ColorConstants.menuBackgroundSelected);
            graphics.fillRectangle (getSelectionRectangle ());
            graphics.popState ();
            graphics.setForegroundColor (ColorConstants.white);
        }
        if (hasFocus ()) {
            graphics.pushState ();
            graphics.setXORMode (true);
            graphics.setForegroundColor (ColorConstants.menuBackgroundSelected);
            graphics.setBackgroundColor (ColorConstants.white);
            graphics.drawFocus (getSelectionRectangle ().resize (- 1, - 1));
            graphics.popState ();
        }
        if (isOpaque ()) super.paintFigure (graphics);

        Rectangle figBounds = getBounds ();
        graphics.translate (figBounds.x, figBounds.y);
        if (hasIcons ()) paintIcons (graphics);

        if (! isEnabled ()) {
            graphics.translate (1, 1);
            graphics.setForegroundColor (ColorConstants.buttonLightest);
            paintText (graphics);
            graphics.translate (- 1, - 1);
            graphics.setForegroundColor (ColorConstants.buttonDarker);
        }
        paintText (graphics);
        graphics.translate (- figBounds.x, - figBounds.y);
    }

    private void paintText (Graphics graphics) {
        String subString = getSubStringText ();
        StringTokenizer tokenizer = new StringTokenizer (subString, "\n");
        Font f = getFont ();
        int fontHeight = MapModeUtil.getMapMode (this).DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ());
        int textWidth = getTextExtents (subString, f).width;
        int y = getTextLocation ().y;
        if (0 == FigureUtilities.getFontMetrics (f).getLeading ()) {
            int offset = MapModeUtil.getMapMode (this).DPtoLP (2);
            y += offset;
        }
        while (tokenizer.hasMoreTokens ()) {
            String token = tokenizer.nextToken ();
            int tokenWidth = getTextExtents (token, f).width;
            int x = getTextLocation ().x;
            switch (getTextWrapAlignment ()) {
                case CENTER :
                    x += (textWidth - tokenWidth) / 2;
                    break;
                case RIGHT :
                    x += textWidth - tokenWidth;
                    break;
            }
            Rectangle clipRect = new Rectangle ();
            graphics.getClip (clipRect);
            if (tokenWidth + x <= clipRect.getTopRight ().x) {
                Rectangle newClipRect = new Rectangle (clipRect);
                newClipRect.width += (tokenWidth / token.length ()) / 2;
                graphics.setClip (newClipRect);
            }
            graphics.drawText (token, x, y);
            graphics.setClip (clipRect);
            y += fontHeight;
            if (isTextUnderlined ()) graphics.drawLine (x, y - 1, x + tokenWidth, y - 1);

            if (isTextStrikedThrough ()) graphics.drawLine (x, y - fontHeight / 2 + 1, x + tokenWidth, y - fontHeight / 2 + 1);

        }
    }

    private void paintIcons (Graphics graphics) {
        Point p = Point.SINGLETON;
        p.setLocation (getIconLocation ());
        int num = getNumberofIcons ();
        for (int i = 0;
        i < num; i ++) {
            Image icon = getIcon (i);
            if (icon != null) {
                graphics.drawImage (icon, p);
                p.x += getIconSize (i).width;
            }
        }
    }

    public void setIcon (Image image) {
        setIcon (image, 0);
    }

    public void setIcon (Image image, int index) {
        if (iconInfo == null) iconInfo = new IconInfo ();

        if (iconInfo.getIcon (index) == image) return;

        iconInfo.setIcon (image, index);
        revalidate ();
        repaint ();
    }

    public void setIconAlignment (int align) {
        if (getIconAlignment () == align) return;

        setAlignmentFlags (align, FLAG_ICON_ALIGN);
        clearLocations ();
        repaint ();
    }

    protected Dimension getIconSize (int index) {
        if (iconInfo == null) return EMPTY_DIMENSION;

        return iconInfo.getIconSize (index);
    }

    protected int getNumberofIcons () {
        if (iconInfo == null) return 0;

        return iconInfo.getNumberofIcons ();
    }

    protected Dimension getTotalIconSize () {
        if (iconInfo == null) return EMPTY_DIMENSION;

        return iconInfo.getTotalIconSize ();
    }

    public void setLabelAlignment (int align) {
        if (getLabelAlignment () == align) return;

        setAlignmentFlags (align, FLAG_LABEL_ALIGN);
        clearLocations ();
        repaint ();
    }

    protected String getEllipse () {
        return _ellipse;
    }

    public void setText (String s) {
        if (s == null) s = "";

        if (text.equals (s)) return;

        text = s;
        revalidate ();
        repaint ();
    }

    public void setTextAlignment (int align) {
        if (getTextAlignment () == align) return;

        setAlignmentFlags (align, FLAG_TEXT_ALIGN);
        clearLocations ();
        repaint ();
    }

    public void setTextPlacement (int where) {
        if (getTextPlacement () == where) return;

        setPlacementFlags (where, FLAG_TEXT_PLACEMENT);
        revalidate ();
        repaint ();
    }

    public void setTextUnderline (boolean b) {
        if (isTextUnderlined () == b) return;

        setFlag (FLAG_UNDERLINED, b);
        repaint ();
    }

    public boolean isTextUnderlined () {
        return (flags & FLAG_UNDERLINED) != 0;
    }

    public void setTextStrikeThrough (boolean b) {
        if (isTextStrikedThrough () == b) return;

        setFlag (FLAG_STRIKEDTHROUGH, b);
        repaint ();
    }

    public boolean isTextStrikedThrough () {
        return (flags & FLAG_STRIKEDTHROUGH) != 0;
    }

    public void setTextWrap (boolean b) {
        if (isTextWrapped () == b) return;

        setFlag (FLAG_WRAP, b);
        revalidate ();
        repaint ();
    }

    public boolean isTextWrapped () {
        return (flags & FLAG_WRAP) != 0;
    }

    public void setTextWrapWidth (int i) {
    }

    public void setTextWrapAlignment (int i) {
        if (getTextWrapAlignment () == i) return;

        setAlignmentFlags (i, FLAG_WRAP_ALIGN);
        repaint ();
    }

    public int getTextWrapAlignment () {
        return getAlignment (FLAG_WRAP_ALIGN);
    }

    private void setPlacementFlags (int align, int flagOffset) {
        flags &= ~ (0x7 * flagOffset);
        switch (align) {
            case EAST :
                flags |= 0x1 * flagOffset;
                break;
            case WEST :
                flags |= 0x2 * flagOffset;
                break;
            case NORTH :
                flags |= 0x3 * flagOffset;
                break;
            case SOUTH :
                flags |= 0x4 * flagOffset;
                break;
        }
    }

    private int getPlacement (int flagOffset) {
        int wrapValue = flags & (0x7 * flagOffset);
        if (wrapValue == 0x1 * flagOffset) return EAST;
        else if (wrapValue == 0x2 * flagOffset) return WEST;
        else if (wrapValue == 0x3 * flagOffset) return NORTH;
        else if (wrapValue == 0x4 * flagOffset) return SOUTH;

        return EAST;
    }

    private void setAlignmentFlags (int align, int flagOffset) {
        flags &= ~ (0x7 * flagOffset);
        switch (align) {
            case CENTER :
                flags |= 0x1 * flagOffset;
                break;
            case TOP :
                flags |= 0x2 * flagOffset;
                break;
            case LEFT :
                flags |= 0x3 * flagOffset;
                break;
            case RIGHT :
                flags |= 0x4 * flagOffset;
                break;
            case BOTTOM :
                flags |= 0x5 * flagOffset;
                break;
        }
    }

    private int getAlignment (int flagOffset) {
        int wrapValue = flags & (0x7 * flagOffset);
        if (wrapValue == 0x1 * flagOffset) return CENTER;
        else if (wrapValue == 0x2 * flagOffset) return TOP;
        else if (wrapValue == 0x3 * flagOffset) return LEFT;
        else if (wrapValue == 0x4 * flagOffset) return RIGHT;
        else if (wrapValue == 0x5 * flagOffset) return BOTTOM;

        return CENTER;
    }

    public void setSelected (boolean b) {
        if (isSelected () == b) return;

        setFlag (FLAG_SELECTED, b);
        repaint ();
    }

    public boolean isSelected () {
        return (flags & FLAG_SELECTED) != 0;
    }

    public void setFocus (boolean b) {
        if (hasFocus () == b) return;

        setFlag (FLAG_HASFOCUS, b);
        repaint ();
    }

    public boolean hasFocus () {
        return (flags & FLAG_HASFOCUS) != 0;
    }

    private Rectangle getSelectionRectangle () {
        Rectangle figBounds = getTextBounds ();
        figBounds.expand (new Insets (MapModeUtil.getMapMode (this).DPtoLP (2), MapModeUtil.getMapMode (this).DPtoLP (2), 0, 0));
        translateToParent (figBounds);
        figBounds.intersect (getBounds ());
        return figBounds;
    }

    private int getLineWrapPosition (String s, Font f, int w) {
        BreakIterator iter = BreakIterator.getLineInstance ();
        iter.setText (s);
        int start = iter.first ();
        int end = iter.next ();
        if (getTextExtents (s.substring (start, end), f).width > w) {
            iter = BreakIterator.getCharacterInstance ();
            iter.setText (s);
            start = iter.first ();
        }
        do end = iter.next ();
        while (end != BreakIterator.DONE && getTextExtents (s.substring (start, end), f).width <= w);
        return (end == BreakIterator.DONE) ? iter.last () : iter.previous ();
    }

    private int getLargestSubstringConfinedTo (String s, Font f, int w) {
        int min, max;
        float avg = MapModeUtil.getMapMode (this).DPtoLP (FigureUtilities.getFontMetrics (f).getAverageCharWidth ());
        min = 0;
        max = s.length () + 1;
        int guess = 0, guessSize = 0;
        while ((max - min) > 1) {
            guess = guess + (int) ((w - guessSize) / avg);
            if (guess >= max) guess = max - 1;

            if (guess <= min) guess = min + 1;

            guessSize = getTextExtents (s.substring (0, guess), f).width;
            if (guessSize < w) min = guess;
            else max = guess;

        }
        return min;
    }

    private Dimension getTextExtents (String s, Font f) {
        Dimension d = FigureUtilities.getTextExtents (s, f);
        d.height = FigureUtilities.getFontMetrics (f).getHeight ();
        return new Dimension (MapModeUtil.getMapMode (this).DPtoLP (d.width), MapModeUtil.getMapMode (this).DPtoLP (d.height));
    }

}

