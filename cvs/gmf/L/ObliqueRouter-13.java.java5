package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import java.util.ArrayList;

import java.util.HashMap;

import org.eclipse.draw2d.BendpointConnectionRouter;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.ConnectionAnchor;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.PrecisionPoint;

import org.eclipse.draw2d.geometry.PrecisionRectangle;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.draw2d.ui.figures.IPolygonAnchorableFigure;

import org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dDebugOptions;

import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dPlugin;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

public class ObliqueRouter extends BendpointConnectionRouter {
    static public class ArrayListMap {
        private HashMap map = new HashMap ();

        public ArrayListMap () {
            super ();
        }

        public ArrayList get (Object key) {
            Object value = map.get (key);
            if (value == null) return null;

            if (value instanceof ArrayList) return (ArrayList) value;

            ArrayList v = new ArrayList (1);
            v.add (value);
            return v;
        }

        public void put (Object key, Object value) {
            Object arrayListObject = map.get (key);
            if (arrayListObject == null) {
                map.put (key, value);
                return;
            }
            if (arrayListObject instanceof ArrayList) {
                ArrayList arrayList = (ArrayList) arrayListObject;
                if (! arrayList.contains (value)) arrayList.add (value);

                return;
            }
            if (arrayListObject != value) {
                ArrayList arrayList = new ArrayList (2);
                arrayList.add (arrayListObject);
                arrayList.add (value);
                map.put (key, arrayList);
            }
        }

        public void remove (Object key, Object value) {
            Object arrayListObject = map.get (key);
            if (arrayListObject != null) {
                if (arrayListObject instanceof ArrayList) {
                    ArrayList arrayList = (ArrayList) arrayListObject;
                    arrayList.remove (value);
                    if (arrayList.isEmpty ()) map.remove (key);

                    return;
                }
                map.remove (key);
            }
        }

        public int size () {
            return map.size ();
        }

    }

    private ArrayListMap selfRelConnections = new ArrayListMap ();
    private ArrayListMap intersectingShapesConnections = new ArrayListMap ();
    private class ArrayListKey {
        private ConnectionAnchor connectAnchor1;
        private ConnectionAnchor connectAnchor2;

        ArrayListKey (Connection conn) {
            connectAnchor1 = conn.getSourceAnchor ();
            connectAnchor2 = conn.getTargetAnchor ();
        }

        public ConnectionAnchor getSourceAnchor () {
            return connectAnchor1;
        }

        public ConnectionAnchor getTargetAnchor () {
            return connectAnchor2;
        }

        public int hashCode () {
            return connectAnchor1.hashCode () ^ connectAnchor2.hashCode ();
        }

        public boolean equals (Object object) {
            boolean isEqual = false;
            ArrayListKey listKey;
            if (object instanceof ArrayListKey) {
                listKey = (ArrayListKey) object;
                ConnectionAnchor lk1 = listKey.getSourceAnchor ();
                ConnectionAnchor lk2 = listKey.getTargetAnchor ();
                isEqual = (lk1.equals (connectAnchor1) && lk2.equals (connectAnchor2)) || (lk1.equals (connectAnchor2) && lk2.equals (connectAnchor1));
            }
            return isEqual;
        }

    }

    public static final int ROUTER_FLAG_SKIPNORMALIZATION = 1;
    protected int routerFlags;

    public ObliqueRouter () {
        routerFlags = 0;
    }

    public boolean isAvoidingObstructions (Connection conn) {
        if (conn instanceof PolylineConnectionEx) {
            return ((PolylineConnectionEx) conn).isAvoidObstacleRouting ();
        }
        return false;
    }

    public boolean isClosestDistance (Connection conn) {
        if (conn instanceof PolylineConnectionEx) {
            return ((PolylineConnectionEx) conn).isClosestDistanceRouting ();
        }
        return false;
    }

    protected boolean isReorienting (Connection conn) {
        if (conn.getSourceAnchor ().getOwner () == null || conn.getTargetAnchor ().getOwner () == null) {
            return true;
        }
        return false;
    }

    final public void route (Connection conn) {
        if (conn.isVisible ()) routeBendpoints (conn);

    }

    public void routeBendpoints (Connection conn) {
        if ((conn.getSourceAnchor () == null) || (conn.getTargetAnchor () == null)) return;

        PointList points = calculateBendPoints (conn);
        routeLine (conn, 0, points);
        conn.setPoints (points);
    }

    protected PointList calculateBendPoints (Connection conn) {
        PointList points = new PointList ();
        if (isAvoidingObstructions (conn)) {
            points = RouterHelper.getInstance ().routeAroundObstructions (conn);
        } else if (isClosestDistance (conn)) {
            points = RouterHelper.getInstance ().routeClosestDistance (conn);
        } else {
            points = RouterHelper.getInstance ().routeFromConstraint (conn);
        }

        return points;
    }

    protected boolean removePointsInViews (Connection conn, PointList newLine) {
        boolean bChanged = false;
        if (conn == null || newLine == null) {
            IllegalArgumentException iae = new IllegalArgumentException ();
            Trace.throwing (Draw2dPlugin.getInstance (), Draw2dDebugOptions.EXCEPTIONS_THROWING, getClass (), "removePointsInViews()", iae);
            throw iae;
        }
        if (newLine.size () < 3) return false;

        IFigure sourceOwner = conn.getSourceAnchor ().getOwner ();
        IFigure targetOwner = conn.getTargetAnchor ().getOwner ();
        if (sourceOwner == null) return false;

        if (targetOwner == null) return false;

        PointList startPolygon = null;
        if (! (sourceOwner instanceof Connection)) {
            startPolygon = getFigurePolygon (sourceOwner, conn);
        }
        PointList endPolygon = null;
        if (! (targetOwner instanceof Connection)) {
            endPolygon = getFigurePolygon (targetOwner, conn);
        }
        PointList newPoints = new PointList (newLine.size ());
        for (int i = 0;
        i < newLine.size (); i ++) {
            Point pt = newLine.getPoint (i);
            if (i == 0 || i == newLine.size () - 1) newPoints.addPoint (pt);
            else if ((startPolygon == null || ! PointListUtilities.containsPoint (startPolygon, pt)) && (endPolygon == null || ! PointListUtilities.containsPoint (endPolygon, pt))) {
                newPoints.addPoint (pt);
            } else {
                bChanged = true;
            }

        }
        if (newPoints.size () != newLine.size ()) {
            newLine.removeAllPoints ();
            for (int i = 0;
            i < newPoints.size (); i ++) newLine.addPoint (new Point (newPoints.getPoint (i)));

        }
        return bChanged;
    }

    protected PointList getFigurePolygon (IFigure owner, Connection conn) {
        PointList polygon = new PointList ();
        if (owner instanceof IPolygonAnchorableFigure) {
            PointList points = ((IPolygonAnchorableFigure) owner).getPolygonPoints ();
            for (int index = 0;
            index < points.size (); index ++) {
                Point point = points.getPoint (index).getCopy ();
                owner.translateToAbsolute (point);
                conn.translateToRelative (point);
                polygon.addPoint (point);
            }
        } else {
            Rectangle rect = owner.getBounds ().getCopy ();
            owner.translateToAbsolute (rect);
            conn.translateToRelative (rect);
            polygon.addPoint (rect.getTopLeft ());
            polygon.addPoint (rect.getTopRight ());
            polygon.addPoint (rect.getBottomRight ());
            polygon.addPoint (rect.getBottomLeft ());
            polygon.addPoint (rect.getTopLeft ());
        }
        return polygon;
    }

    public void routeLine (Connection conn, int nestedRoutingDepth, PointList newLine) {
        if (! checkSelfRelConnection (conn, newLine) && ! checkShapesIntersect (conn, newLine)) {
            removePointsInViews (conn, newLine);
        }
        resetEndPointsToEdge (conn, newLine);
    }

    protected boolean checkShapesIntersect (Connection conn, PointList newLine) {
        if (conn.getSourceAnchor ().getOwner () == null || conn.getTargetAnchor ().getOwner () == null) return false;

        if (newLine.size () < 3) {
            PrecisionRectangle sourceBounds = new PrecisionRectangle (conn.getSourceAnchor ().getOwner ().getBounds ());
            PrecisionRectangle targetBounds = new PrecisionRectangle (conn.getTargetAnchor ().getOwner ().getBounds ());
            conn.getSourceAnchor ().getOwner ().translateToAbsolute (sourceBounds);
            conn.getTargetAnchor ().getOwner ().translateToAbsolute (targetBounds);
            if (sourceBounds.intersects (targetBounds) && ! sourceBounds.contains (targetBounds) && ! targetBounds.contains (sourceBounds) || sourceBounds.equals (targetBounds)) {
                getVerticesForIntersectingShapes (conn, newLine);
                return true;
            }
        } else {
            removeIntersectingShapesConnection (conn);
        }
        return false;
    }

    private int getSourcePositionFromConnectionRectangle (Rectangle connRectangle, Rectangle sourceRect, int position) {
        Dimension diff = null;
        switch (position) {
            case PositionConstants.NORTH_WEST :
                diff = connRectangle.getBottomRight ().getDifference (sourceRect.getTopLeft ());
                if (diff.width == 0) {
                    return PositionConstants.EAST;
                } else {
                    return PositionConstants.SOUTH;
                }
            case PositionConstants.NORTH_EAST :
                diff = connRectangle.getBottomLeft ().getDifference (sourceRect.getTopRight ());
                if (diff.width == 0) {
                    return PositionConstants.WEST;
                } else {
                    return PositionConstants.SOUTH;
                }
            case PositionConstants.SOUTH_EAST :
                diff = connRectangle.getTopLeft ().getDifference (sourceRect.getBottomRight ());
                if (diff.width == 0) {
                    return PositionConstants.WEST;
                } else {
                    return PositionConstants.NORTH;
                }
            case PositionConstants.SOUTH_WEST :
                diff = connRectangle.getTopRight ().getDifference (sourceRect.getBottomLeft ());
                if (diff.width == 0) {
                    return PositionConstants.EAST;
                } else {
                    return PositionConstants.NORTH;
                }
            case PositionConstants.NONE :
                diff = connRectangle.getCenter ().getDifference (sourceRect.getCenter ());
                if (diff.width == 0) {
                    return diff.height < 0 ? PositionConstants.SOUTH : PositionConstants.NORTH;
                } else {
                    return diff.width < 0 ? PositionConstants.EAST : PositionConstants.WEST;
                }
        }
        return PositionConstants.NONE;
    }

    private void getConnectionPoints (Rectangle connRect, int position, int sourcePosition, PointList line) {
        line.removeAllPoints ();
        switch (position) {
            case PositionConstants.NORTH_WEST :
                if (sourcePosition == PositionConstants.EAST) {
                    line.addPoint (connRect.getTopRight ());
                    line.addPoint (connRect.getTopLeft ());
                    line.addPoint (connRect.getBottomLeft ());
                } else {
                    line.addPoint (connRect.getBottomLeft ());
                    line.addPoint (connRect.getTopLeft ());
                    line.addPoint (connRect.getTopRight ());
                }
                break;
            case PositionConstants.NORTH_EAST :
                if (sourcePosition == PositionConstants.WEST) {
                    line.addPoint (connRect.getTopLeft ());
                    line.addPoint (connRect.getTopRight ());
                    line.addPoint (connRect.getBottomRight ());
                } else {
                    line.addPoint (connRect.getBottomRight ());
                    line.addPoint (connRect.getTopRight ());
                    line.addPoint (connRect.getTopLeft ());
                }
                break;
            case PositionConstants.SOUTH_EAST :
                if (sourcePosition == PositionConstants.WEST) {
                    line.addPoint (connRect.getBottomLeft ());
                    line.addPoint (connRect.getBottomRight ());
                    line.addPoint (connRect.getTopRight ());
                } else {
                    line.addPoint (connRect.getTopRight ());
                    line.addPoint (connRect.getBottomRight ());
                    line.addPoint (connRect.getBottomLeft ());
                }
                break;
            case PositionConstants.SOUTH_WEST :
                if (sourcePosition == PositionConstants.EAST) {
                    line.addPoint (connRect.getBottomRight ());
                    line.addPoint (connRect.getBottomLeft ());
                    line.addPoint (connRect.getTopLeft ());
                } else {
                    line.addPoint (connRect.getTopLeft ());
                    line.addPoint (connRect.getBottomLeft ());
                    line.addPoint (connRect.getBottomRight ());
                }
                break;
            case PositionConstants.NONE :
                if (sourcePosition == PositionConstants.NORTH) {
                    line.addPoint (connRect.getTopLeft ());
                    line.addPoint (connRect.getBottomLeft ());
                } else if (sourcePosition == PositionConstants.SOUTH) {
                    line.addPoint (connRect.getBottomLeft ());
                    line.addPoint (connRect.getTopLeft ());
                } else if (sourcePosition == PositionConstants.WEST) {
                    line.addPoint (connRect.getTopLeft ());
                    line.addPoint (connRect.getTopRight ());
                } else {
                    line.addPoint (connRect.getTopRight ());
                    line.addPoint (connRect.getTopLeft ());
                }

        }
    }

    private void absDimension (Dimension d) {
        d.width = Math.abs (d.width);
        d.height = Math.abs (d.height);
    }

    private void getVerticesForIntersectingShapes (Connection conn, PointList newLine) {
        Object key = getIntersectingShapesConnectionKey (conn);
        int nSelfIncr = 0;
        int nIndex = 0;
        ArrayList connectionList = intersectingShapesConnections.get (key);
        if (connectionList != null) {
            if (! connectionList.contains (conn)) {
                intersectingShapesConnections.put (key, conn);
                connectionList = intersectingShapesConnections.get (key);
            }
            nIndex = connectionList.indexOf (conn);
            assert nIndex >= 0;
        } else {
            intersectingShapesConnections.put (key, conn);
        }
        PrecisionPoint selfrelsizeincr = new PrecisionPoint (SELFRELSIZEINCR, 0);
        boolean isFeedbackConn = RouterHelper.getInstance ().isFeedback (conn);
        if (! isFeedbackConn) selfrelsizeincr = (PrecisionPoint) MapModeUtil.getMapMode (conn).DPtoLP (selfrelsizeincr);

        IFigure sourceFig = conn.getSourceAnchor ().getOwner ();
        PrecisionRectangle sourceRect = new PrecisionRectangle (sourceFig.getBounds ());
        sourceFig.translateToAbsolute (sourceRect);
        conn.translateToRelative (sourceRect);
        IFigure targetFig = conn.getTargetAnchor ().getOwner ();
        PrecisionRectangle targetRect = new PrecisionRectangle (targetFig.getBounds ());
        targetFig.translateToAbsolute (targetRect);
        conn.translateToRelative (targetRect);
        PrecisionRectangle union = sourceRect.getPreciseCopy ().union (targetRect);
        nSelfIncr = selfrelsizeincr.x * (nIndex);
        Rectangle intersection = sourceRect.getCopy ().intersect (targetRect);
        Rectangle connArea = new Rectangle ();
        int position = PositionConstants.NONE;
        int minArea = 0;
        Point unionTopLeft = union.getTopLeft ();
        Point unionTopRight = union.getTopRight ();
        Point unionBottomRight = union.getBottomRight ();
        Point unionBottomLeft = union.getBottomLeft ();
        if (! unionTopLeft.equals (sourceRect.getTopLeft ()) && ! unionTopLeft.equals (targetRect.getTopLeft ())) {
            Dimension diffVector = unionTopLeft.getDifference (intersection.getTopLeft ());
            absDimension (diffVector);
            int areaTopLeft = diffVector.getArea ();
            if (minArea == 0 || minArea > areaTopLeft) {
                position = PositionConstants.NORTH_WEST;
                connArea.setSize (diffVector);
                connArea.setLocation (unionTopLeft.x, unionTopLeft.y);
                minArea = areaTopLeft;
            }
        }
        if (! unionTopRight.equals (sourceRect.getTopRight ()) && ! unionTopRight.equals (targetRect.getTopRight ())) {
            Dimension diffVector = unionTopRight.getDifference (intersection.getTopRight ());
            absDimension (diffVector);
            int areaTopRight = diffVector.getArea ();
            if (minArea == 0 || minArea > areaTopRight) {
                position = PositionConstants.NORTH_EAST;
                connArea.setSize (diffVector);
                connArea.setLocation (unionTopRight.x - connArea.width, unionTopRight.y);
                minArea = areaTopRight;
            }
        }
        if (! unionBottomRight.equals (sourceRect.getBottomRight ()) && ! unionBottomRight.equals (targetRect.getBottomRight ())) {
            Dimension diffVector = unionBottomRight.getDifference (intersection.getBottomRight ());
            absDimension (diffVector);
            int areaBottomRight = diffVector.getArea ();
            if (minArea == 0 || minArea > areaBottomRight) {
                position = PositionConstants.SOUTH_EAST;
                connArea.setSize (diffVector);
                connArea.setLocation (unionBottomRight.x - connArea.width, unionBottomRight.y - connArea.height);
                minArea = areaBottomRight;
            }
        }
        if (! unionBottomLeft.equals (sourceRect.getBottomLeft ()) && ! unionBottomLeft.equals (targetRect.getBottomLeft ())) {
            Dimension diffVector = unionBottomLeft.getDifference (intersection.getBottomLeft ());
            absDimension (diffVector);
            int areaBottomLeft = diffVector.getArea ();
            if (minArea == 0 || minArea > areaBottomLeft) {
                position = PositionConstants.SOUTH_WEST;
                connArea.setSize (diffVector);
                connArea.setLocation (unionBottomLeft.x, unionBottomLeft.y - connArea.height);
                minArea = areaBottomLeft;
            }
        }
        if (position == PositionConstants.NONE) {
            connArea = intersection;
        }
        int sourcePosition = getSourcePositionFromConnectionRectangle (connArea, sourceRect, position);
        if (position != PositionConstants.NONE) {
            PrecisionPoint translateExpansion = new PrecisionPoint (Math.max (connArea.width, connArea.height), 0);
            if (! isFeedbackConn) {
                IMapMode mm = MapModeUtil.getMapMode (conn);
                translateExpansion = (PrecisionPoint) mm.LPtoDP (translateExpansion);
                translateExpansion.preciseX = Math.pow (translateExpansion.preciseX, 0.8);
                translateExpansion = (PrecisionPoint) mm.DPtoLP (translateExpansion);
            } else {
                translateExpansion.preciseX = Math.pow (translateExpansion.preciseX, 0.8);
            }
            translateExpansion.updateInts ();
            getPrimaryPreciseConnectionArea (connArea, translateExpansion.x, position);
        } else {
            connArea.expand (selfrelsizeincr.x << 1, selfrelsizeincr.x << 1);
        }
        connArea.expand (nSelfIncr, nSelfIncr);
        getConnectionPoints (connArea, position, sourcePosition, newLine);
        PrecisionPoint ptS2 = new PrecisionPoint (newLine.getPoint (0));
        PrecisionPoint ptS1 = new PrecisionPoint (conn.getSourceAnchor ().getReferencePoint ());
        conn.translateToRelative (ptS1);
        Point ptAbsS2 = new Point (ptS2);
        conn.translateToAbsolute (ptAbsS2);
        PrecisionPoint ptEdge = new PrecisionPoint (conn.getSourceAnchor ().getLocation (ptAbsS2));
        conn.translateToRelative (ptEdge);
        ptS1 = new PrecisionPoint (getStraightEdgePoint (ptEdge, ptS1, ptS2));
        PrecisionPoint ptE2 = new PrecisionPoint (newLine.getPoint (newLine.size () - 1));
        PrecisionPoint ptE1 = new PrecisionPoint (conn.getTargetAnchor ().getReferencePoint ());
        conn.translateToRelative (ptE1);
        PrecisionPoint ptAbsE2 = (PrecisionPoint) ptE2.getCopy ();
        conn.translateToAbsolute (ptAbsE2);
        ptEdge = new PrecisionPoint (conn.getTargetAnchor ().getLocation (ptAbsE2));
        conn.translateToRelative (ptEdge);
        ptE1 = new PrecisionPoint (getStraightEdgePoint (ptEdge, ptE1, ptE2));
        newLine.insertPoint (new Point (Math.round (ptS1.preciseX), Math.round (ptS1.preciseY)), 0);
        newLine.insertPoint (new Point (Math.round (ptE1.preciseX), Math.round (ptE1.preciseY)), newLine.size ());
    }

    private void getPrimaryPreciseConnectionArea (Rectangle r, int size, int positionOfConnArea) {
        r.expand (size, size);
        if (r.width < r.height) {
            r.height -= size;
            if ((positionOfConnArea & PositionConstants.SOUTH) != 0) {
                r.y += size;
            }
        } else {
            r.width -= size;
            if ((positionOfConnArea & PositionConstants.EAST) != 0) {
                r.x += size;
            }
        }
    }

    protected static Point getStraightEdgePoint (final Point ptEdge, final Point ptRef1, final Point ptRef2) {
        LineSeg lineSeg = new LineSeg (ptRef1, ptRef2);
        Point ptProj = lineSeg.perpIntersect (ptEdge.x, ptEdge.y);
        if (Math.abs (ptProj.x - ptRef2.x) < Math.abs (ptProj.y - ptRef2.y)) ptProj.x = ptRef2.x;
        else ptProj.y = ptRef2.y;

        return ptProj;
    }

    protected void resetEndPointsToEdge (Connection conn, PointList newLine) {
        RouterHelper.getInstance ().resetEndPointsToEdge (conn, newLine);
    }

    protected static final int SELFRELSIZEINIT = 62;
    protected static final int SELFRELSIZEINCR = 10;

    protected boolean checkSelfRelConnection (Connection conn, PointList newLine) {
        if ((conn.getSourceAnchor ().getOwner () == conn.getTargetAnchor ().getOwner ()) && newLine.size () < 4) {
            getSelfRelVertices (conn, newLine);
            return true;
        } else {
            removeSelfRelConnection (conn);
            return false;
        }
    }

    private void removeSelfRelConnection (Connection conn) {
        if (conn.getSourceAnchor () == null || conn.getTargetAnchor () == null || conn.getSourceAnchor ().getOwner () == null || conn.getTargetAnchor ().getOwner () == null) return;

        ArrayListKey connectionKey = new ArrayListKey (conn);
        ArrayList connectionList = selfRelConnections.get (connectionKey);
        if (connectionList != null) {
            int index = connectionList.indexOf (conn);
            if (index == - 1) return;

            selfRelConnections.remove (connectionKey, conn);
        }
    }

    private void removeIntersectingShapesConnection (Connection conn) {
        if (conn.getSourceAnchor () == null || conn.getTargetAnchor () == null || conn.getSourceAnchor ().getOwner () == null || conn.getTargetAnchor ().getOwner () == null) return;

        Object key = getIntersectingShapesConnectionKey (conn);
        ArrayList connectionList = intersectingShapesConnections.get (key);
        if (connectionList != null) {
            int index = connectionList.indexOf (conn);
            if (index == - 1) return;

            intersectingShapesConnections.remove (key, conn);
        }
    }

    private Object getIntersectingShapesConnectionKey (Connection conn) {
        return new Integer (conn.getSourceAnchor ().getOwner ().hashCode () ^ conn.getTargetAnchor ().getOwner ().hashCode ());
    }

    protected void getSelfRelVertices (Connection conn, PointList newLine) {
        if (conn.getSourceAnchor ().getOwner () == null) return;

        ArrayListKey connectionKey = new ArrayListKey (conn);
        int nSelfIncr = 0;
        int nIndex = 0;
        ArrayList connectionList = selfRelConnections.get (connectionKey);
        if (connectionList != null) {
            if (! connectionList.contains (conn)) {
                selfRelConnections.put (connectionKey, conn);
                connectionList = selfRelConnections.get (connectionKey);
            }
            nIndex = connectionList.indexOf (conn);
            assert nIndex >= 0;
        } else {
            selfRelConnections.put (connectionKey, conn);
        }
        Dimension selfrelsizeincr = new Dimension (SELFRELSIZEINCR, 0);
        if (! RouterHelper.getInstance ().isFeedback (conn)) selfrelsizeincr = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (selfrelsizeincr);

        IFigure owner = conn.getSourceAnchor ().getOwner ();
        Rectangle bBox = owner.getClientArea ();
        owner.translateToAbsolute (bBox);
        conn.translateToRelative (bBox);
        nSelfIncr = selfrelsizeincr.width * (nIndex / 8);
        newLine.removeAllPoints ();
        switch (nIndex % 8) {
            case 0 :
                getCornerSelfRelVertices (conn, bBox, newLine, nSelfIncr, 1, 1, bBox.getBottomRight ());
                break;
            case 1 :
                getVerticalSelfRelVertices (conn, bBox, newLine, nSelfIncr, 1, bBox.getBottom ());
                break;
            case 2 :
                getCornerSelfRelVertices (conn, bBox, newLine, nSelfIncr, - 1, 1, bBox.getBottomLeft ());
                break;
            case 3 :
                getHorizontalSelfRelVertices (conn, bBox, newLine, nSelfIncr, - 1, bBox.getLeft ());
                break;
            case 4 :
                getCornerSelfRelVertices (conn, bBox, newLine, nSelfIncr, - 1, - 1, bBox.getTopLeft ());
                break;
            case 5 :
                getVerticalSelfRelVertices (conn, bBox, newLine, nSelfIncr, - 1, bBox.getTop ());
                break;
            case 6 :
                getCornerSelfRelVertices (conn, bBox, newLine, nSelfIncr, 1, - 1, bBox.getTopRight ());
                break;
            case 7 :
                getHorizontalSelfRelVertices (conn, bBox, newLine, nSelfIncr, 1, bBox.getRight ());
                break;
        }
        Point ptS2 = newLine.getPoint (0);
        Point ptS1 = conn.getSourceAnchor ().getReferencePoint ();
        conn.translateToRelative (ptS1);
        Point ptAbsS2 = new Point (ptS2);
        conn.translateToAbsolute (ptAbsS2);
        Point ptEdge = conn.getSourceAnchor ().getLocation (ptAbsS2);
        conn.translateToRelative (ptEdge);
        ptS1 = getStraightEdgePoint (ptEdge, ptS1, ptS2);
        Point ptE2 = newLine.getPoint (newLine.size () - 1);
        Point ptE1 = conn.getTargetAnchor ().getReferencePoint ();
        conn.translateToRelative (ptE1);
        Point ptAbsE2 = new Point (ptE2);
        conn.translateToAbsolute (ptAbsE2);
        ptEdge = conn.getTargetAnchor ().getLocation (ptAbsE2);
        conn.translateToRelative (ptEdge);
        ptE1 = getStraightEdgePoint (ptEdge, ptE1, ptE2);
        newLine.setPoint (ptS1, 0);
        newLine.setPoint (ptE1, newLine.size () - 1);
    }

    private void getCornerSelfRelVertices (Connection conn, Rectangle bBox, PointList newLine, int nOffset, int nXDir, int nYDir, Point ptOrient) {
        int x = ptOrient.x;
        int y = bBox.getCenter ().y + (nYDir * bBox.height / 4);
        Point p1 = new Point (x, y);
        newLine.addPoint (p1);
        int xNew, yNew;
        Dimension selfrelsizeinit = new Dimension (SELFRELSIZEINIT, 0);
        if (! RouterHelper.getInstance ().isFeedback (conn)) selfrelsizeinit = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (selfrelsizeinit);

        xNew = x + (nXDir * (selfrelsizeinit.width + nOffset));
        Point p2 = new Point (xNew, y);
        newLine.addPoint (p2);
        yNew = ptOrient.y + (nYDir * (selfrelsizeinit.width + nOffset));
        Point p3 = new Point (xNew, yNew);
        newLine.addPoint (p3);
        xNew = ptOrient.x - (nXDir * bBox.width / 4);
        Point p4 = new Point (xNew, yNew);
        newLine.addPoint (p4);
        yNew = ptOrient.y;
        Point p5 = new Point (xNew, yNew);
        newLine.addPoint (p5);
    }

    private void getVerticalSelfRelVertices (Connection conn, Rectangle bBox, PointList newLine, int nOffset, int nDir, Point ptOrient) {
        int nWidth = bBox.width / 4;
        int x = ptOrient.x - nWidth / 2;
        int y = ptOrient.y;
        Point p1 = new Point (x, y);
        newLine.addPoint (p1);
        int xNew, yNew;
        Dimension selfrelsizeinit = new Dimension (SELFRELSIZEINIT, 0);
        if (! RouterHelper.getInstance ().isFeedback (conn)) selfrelsizeinit = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (selfrelsizeinit);

        yNew = y + (nDir * (selfrelsizeinit.width + nOffset));
        Point p2 = new Point (x, yNew);
        newLine.addPoint (p2);
        xNew = ptOrient.x + nWidth / 2;
        Point p3 = new Point (xNew, yNew);
        newLine.addPoint (p3);
        yNew = ptOrient.y;
        Point p4 = new Point (xNew, yNew);
        newLine.addPoint (p4);
    }

    private void getHorizontalSelfRelVertices (Connection conn, Rectangle bBox, PointList newLine, int nOffset, int nDir, Point ptOrient) {
        int nHeight = bBox.height / 4;
        int y = ptOrient.y - nHeight / 2;
        int x = ptOrient.x;
        Point p1 = new Point (x, y);
        newLine.addPoint (p1);
        int xNew, yNew;
        Dimension selfrelsizeinit = new Dimension (SELFRELSIZEINIT, 0);
        if (! RouterHelper.getInstance ().isFeedback (conn)) selfrelsizeinit = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (selfrelsizeinit);

        xNew = x + (nDir * (selfrelsizeinit.width + nOffset));
        Point p2 = new Point (xNew, y);
        newLine.addPoint (p2);
        yNew = ptOrient.y + nHeight / 2;
        Point p3 = new Point (xNew, yNew);
        newLine.addPoint (p3);
        xNew = ptOrient.x;
        Point p4 = new Point (xNew, yNew);
        newLine.addPoint (p4);
    }

    public void remove (Connection connection) {
        super.remove (connection);
        RouterHelper.getInstance ().remove (connection);
        removeSelfRelConnection (connection);
        removeIntersectingShapesConnection (connection);
    }

    public void invalidate (Connection connection) {
        super.invalidate (connection);
        RouterHelper.getInstance ().invalidate (connection);
    }

    public void setConstraint (Connection connection, Object constraint) {
        super.setConstraint (connection, constraint);
        RouterHelper.getInstance ().setConstraint (connection, constraint);
    }

}

