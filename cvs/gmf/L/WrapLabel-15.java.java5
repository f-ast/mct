package org.eclipse.gmf.runtime.draw2d.ui.figures;

import org.eclipse.draw2d.FigureUtilities;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;

import org.eclipse.swt.graphics.Font;

import org.eclipse.swt.graphics.FontMetrics;

import org.eclipse.swt.graphics.Image;

import com.ibm.icu.text.BreakIterator;

import com.ibm.icu.util.StringTokenizer;

public class WrapLabel extends WrappingLabel {
    private String subStringText;

    public WrapLabel () {
        super ();
    }

    public WrapLabel (String s) {
        super (s);
        setTextWrapAlignment (CENTER);
    }

    public WrapLabel (Image i) {
        super (i);
        setTextWrapAlignment (CENTER);
    }

    public WrapLabel (String s, Image i) {
        super (s, i);
        setTextWrapAlignment (CENTER);
    }

    protected Dimension calculateSubStringTextSize () {
        Font f = getFont ();
        return getTextExtents (getSubStringText (), f, getFigureMapMode ().DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ()));
    }

    protected Dimension calculateTextSize (int wHint, int hHint) {
        return getTextFlow ().getPreferredSize (wHint, hHint);
    }

    public Rectangle getIconBounds () {
        if (hasIcons ()) {
            return new Rectangle (getBounds ().getLocation ().translate (getIconLocation ()), getTotalIconSize ());
        }
        return new Rectangle (0, 0, 0, 0);
    }

    public String getSubStringText () {
        if (subStringText != null) return subStringText;

        String theText = getText ();
        int textLen = theText.length ();
        if (textLen == 0) {
            return subStringText = "";
        }
        Dimension size = getSize ();
        Dimension shrink = getPreferredSize (size.width, size.height).getDifference (size);
        Dimension effectiveSize = getTextSize ().getExpanded (- shrink.width, - shrink.height);
        if (effectiveSize.height == 0) {
            return subStringText = "";
        }
        Font f = getFont ();
        FontMetrics metrics = FigureUtilities.getFontMetrics (f);
        IMapMode mm = getFigureMapMode ();
        int fontHeight = mm.DPtoLP (metrics.getHeight ());
        int charAverageWidth = mm.DPtoLP (metrics.getAverageCharWidth ());
        int maxLines = (int) (effectiveSize.height / (double) fontHeight);
        if (maxLines == 0) {
            return subStringText = "";
        }
        StringBuffer accumlatedText = new StringBuffer ();
        StringBuffer remainingText = new StringBuffer (theText);
        int effectiveSizeWidth = effectiveSize.width;
        int widthHint = Math.max (effectiveSizeWidth - getTruncationStringSize ().width, 0);
        int i = 0, j = 0;
        while (remainingText.length () > 0 && j ++ < maxLines) {
            i = getLineWrapPosition (remainingText.toString (), f, effectiveSizeWidth, fontHeight);
            if (accumlatedText.length () > 0) accumlatedText.append ('\n');

            if (i == 0 || (remainingText.length () > i && j == maxLines)) {
                i = getLargestSubstringConfinedTo (remainingText.toString (), f, widthHint, fontHeight, charAverageWidth);
                accumlatedText.append (remainingText.substring (0, i));
                accumlatedText.append (getEllipse ());
            } else accumlatedText.append (remainingText.substring (0, i));

            remainingText.delete (0, i);
        }
        return subStringText = accumlatedText.toString ();
    }

    protected Dimension getSubStringTextSize () {
        return calculateSubStringTextSize ();
    }

    protected Point getTextLocation () {
        return getTextBounds ().getLocation ();
    }

    protected Dimension getTextSize (int wHint, int hHint) {
        return getTextFlow ().getPreferredSize (wHint, hHint);
    }

    private final Dimension getTextSize () {
        Rectangle r = getBounds ();
        return getTextSize (r.width, r.height);
    }

    public void invalidate () {
        subStringText = null;
        super.invalidate ();
    }

    public boolean isTextTruncated () {
        return ! getSubStringTextSize ().equals (getTextSize ());
    }

    protected String getEllipse () {
        return ELLIPSIS;
    }

    protected String getTruncationString () {
        if (getEllipse () != null) {
            return getEllipse ();
        }
        return ELLIPSIS;
    }

    public boolean isTextWrapped () {
        return isTextWrapOn ();
    }

    public void setTextWrapWidth (int i) {
    }

    public void setTextWrapAlignment (int i) {
        setTextJustification (i);
        switch (i) {
            case LEFT :
                setAlignment (TOP | LEFT);
                break;
            case CENTER :
                setAlignment (TOP);
                break;
            case RIGHT :
                setAlignment (TOP | RIGHT);
                break;
            default :
                break;
        }
    }

    public void setLabelAlignment (int alignment) {
    }

    public int getTextWrapAlignment () {
        return getTextJustification ();
    }

    private int getLineWrapPosition (String s, Font f, int w, int fontHeight) {
        if (getTextExtents (s, f, fontHeight).width <= w) {
            return s.length ();
        }
        BreakIterator iter = BreakIterator.getLineInstance ();
        iter.setText (s);
        int start = iter.first ();
        int end = iter.next ();
        if (getTextExtents (s.substring (start, end), f, fontHeight).width > w) {
            iter = BreakIterator.getCharacterInstance ();
            iter.setText (s);
            start = iter.first ();
        }
        do end = iter.next ();
        while (end != BreakIterator.DONE && getTextExtents (s.substring (start, end), f, fontHeight).width <= w);
        return (end == BreakIterator.DONE) ? iter.last () : iter.previous ();
    }

    private int getLargestSubstringConfinedTo (String s, Font f, int w, int fontHeight, int charAverageWidth) {
        float avg = charAverageWidth;
        int min = 0;
        int max = s.length () + 1;
        int guess = 0, guessSize = 0;
        while ((max - min) > 1) {
            guess = guess + (int) ((w - guessSize) / avg);
            if (guess >= max) guess = max - 1;

            if (guess <= min) guess = min + 1;

            guessSize = getTextExtents (s.substring (0, guess), f, fontHeight).width;
            if (guessSize < w) min = guess;
            else max = guess;

        }
        return min;
    }

    private Dimension getTextExtents (String s, Font f, int fontHeight) {
        if (s.length () == 0) {
            return getMapModeConstants ().dimension_nDPtoLP_0;
        } else {
            Dimension d = FigureUtilities.getTextExtents (s, f);
            IMapMode mapMode = getFigureMapMode ();
            d.width = mapMode.DPtoLP (d.width);
            d.height = fontHeight * new StringTokenizer (s, "\n").countTokens ();
            return d;
        }
    }

}

