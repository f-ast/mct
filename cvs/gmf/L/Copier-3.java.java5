package org.eclipse.gmf.internal.common.reconcile;

import java.util.Collection;

import java.util.Collections;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.EStructuralFeature;

import org.eclipse.emf.ecore.util.EcoreUtil;

public interface Copier {

    public EObject copyToCurrent (EObject currentParent, EObject old);

    public static final Copier NEVER_COPY = new Copier () {

        public EObject copyToCurrent (EObject currentParent, EObject old) {
            return null;
        }

    }

    ;
    public static final Copier COMPLETE_COPY = new Copier () {

        @SuppressWarnings("unchecked")
        public EObject copyToCurrent (EObject currentParent, EObject old) {
            safetyCheck (old);
            EClass currentParentEClass = currentParent.eClass ();
            EObject oldParent = old.eContainer ();
            EClass oldParentEClass = oldParent.eClass ();
            EObject currentCopy = null;
            if (currentParentEClass.equals (oldParentEClass)) {
                currentCopy = EcoreUtil.copy (old);
                EStructuralFeature containment = old.eContainingFeature ();
                Object currentValue = currentParent.eGet (containment);
                if (currentValue instanceof Collection) {
                    ((Collection) currentValue).add (currentCopy);
                } else {
                    currentParent.eSet (containment, currentCopy);
                }
            }
            return currentCopy;
        }

        private void safetyCheck (EObject old) {
            if (! EcoreUtil.CrossReferencer.find (Collections.singleton (old)).isEmpty ()) {
                throw new IllegalArgumentException ("I am not intended to copy elements woth cross references");
            }
        }

    }

    ;
}

