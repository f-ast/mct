package org.eclipse.gmf.runtime.diagram.ui.render.clipboard;

import java.awt.Image;

import java.util.ArrayList;

import java.util.Collection;

import java.util.HashSet;

import java.util.Iterator;

import java.util.LinkedList;

import java.util.List;

import java.util.ListIterator;

import java.util.Map;

import java.util.Stack;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.PolylineConnection;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.draw2d.geometry.Translatable;

import org.eclipse.gef.ConnectionEditPart;

import org.eclipse.gef.EditPart;

import org.eclipse.gef.GraphicalEditPart;

import org.eclipse.gef.LayerConstants;

import org.eclipse.gef.editparts.LayerManager;

import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;

import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;

import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;

import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;

import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeCompartmentEditPart;

import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;

import org.eclipse.gmf.runtime.diagram.ui.image.PartPositionInfo;

import org.eclipse.gmf.runtime.diagram.ui.internal.figures.IExpandableFigure;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.decorator.Decoration;

import org.eclipse.gmf.runtime.diagram.ui.l10n.SharedImages;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg.Sign;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.gmf.runtime.draw2d.ui.render.internal.graphics.RenderedMapModeGraphics;

import org.eclipse.gmf.runtime.notation.View;

import org.eclipse.jface.resource.ImageDescriptor;

import org.eclipse.swt.graphics.ImageData;

abstract public class DiagramGenerator {
    private int image_margin = 0;
    private DiagramEditPart _dgrmEP;

    public DiagramGenerator (DiagramEditPart dgrmEP) {
        this._dgrmEP = dgrmEP;
        image_margin = getMapMode ().DPtoLP (10);
    }

    protected DiagramEditPart getDiagramEditPart () {
        return this._dgrmEP;
    }

    abstract protected Graphics setUpGraphics (int width, int height);

    protected void disposeGraphics (Graphics g) {
        g.dispose ();
    }

    abstract protected ImageDescriptor getImageDescriptor (Graphics g);

    final public Image createAWTImageForDiagram () {
        List editparts = getDiagramEditPart ().getPrimaryEditParts ();
        return createAWTImageForParts (editparts);
    }

    public Image createAWTImageForParts (List editparts) {
        org.eclipse.swt.graphics.Rectangle diagramArea = calculateImageRectangle (editparts);
        return createAWTImageForParts (editparts, diagramArea);
    }

    final public ImageDescriptor createSWTImageDescriptorForDiagram () {
        List editparts = getDiagramEditPart ().getPrimaryEditParts ();
        return createSWTImageDescriptorForParts (editparts);
    }

    final public ImageDescriptor createSWTImageDescriptorForParts (List editparts) {
        org.eclipse.swt.graphics.Rectangle sourceRect = calculateImageRectangle (editparts);
        return createSWTImageDescriptorForParts (editparts, sourceRect);
    }

    protected IMapMode getMapMode () {
        IMapMode mm = MapModeUtil.getMapMode (getDiagramEditPart ().getFigure ());
        return mm;
    }

    final protected void renderToGraphics (Graphics graphics, Point translateOffset, List editparts) {
        List sortedEditparts = sortSelection (editparts);
        graphics.translate ((- translateOffset.x), (- translateOffset.y));
        graphics.pushState ();
        List < GraphicalEditPart > connectionsToPaint = new LinkedList < GraphicalEditPart > ();
        Map decorations = findDecorations (editparts);
        for (Iterator editPartsItr = editparts.listIterator ();
        editPartsItr.hasNext ();) {
            IGraphicalEditPart editPart = (IGraphicalEditPart) editPartsItr.next ();
            if (editPart instanceof ConnectionEditPart) {
                connectionsToPaint.add (editPart);
            } else {
                connectionsToPaint.addAll (findConnectionsToPaint (editPart));
                IFigure figure = editPart.getFigure ();
                paintFigure (graphics, figure);
                paintDecorations (graphics, figure, decorations);
            }
        }
        decorations = findDecorations (connectionsToPaint);
        for (Iterator < GraphicalEditPart > connItr = connectionsToPaint.iterator ();
        connItr.hasNext ();) {
            IFigure figure = connItr.next ().getFigure ();
            paintFigure (graphics, figure);
            paintDecorations (graphics, figure, decorations);
        }
    }

    private Collection < ConnectionEditPart > findConnectionsToPaint (IGraphicalEditPart editPart) {
        HashSet < GraphicalEditPart > editParts = new HashSet < GraphicalEditPart > ();
        HashSet < ConnectionEditPart > connectionEPs = new HashSet < ConnectionEditPart > ();
        HashSet < ConnectionEditPart > connectionsToPaint = new HashSet < ConnectionEditPart > ();
        getNestedEditParts (editPart, editParts);
        for (Iterator < GraphicalEditPart > editPartsItr = editParts.iterator ();
        editPartsItr.hasNext ();) {
            connectionEPs.addAll (getAllConnectionsFrom (editPartsItr.next ()));
        }
        while (! connectionEPs.isEmpty ()) {
            Stack < ConnectionEditPart > connectionsPath = new Stack < ConnectionEditPart > ();
            ConnectionEditPart conn = connectionEPs.iterator ().next ();
            connectionEPs.remove (conn);
            connectionsPath.add (conn);
            EditPart target = conn.getTarget ();
            while (connectionEPs.contains (target)) {
                ConnectionEditPart targetConn = (ConnectionEditPart) target;
                connectionEPs.remove (targetConn);
                connectionsPath.add (targetConn);
                target = targetConn.getTarget ();
            }
            if (editParts.contains (target) || connectionsToPaint.contains (target)) {
                connectionsToPaint.addAll (connectionsPath);
            }
        }
        return connectionsToPaint;
    }

    private List < ConnectionEditPart > getAllConnectionsFrom (GraphicalEditPart ep) {
        LinkedList < ConnectionEditPart > connections = new LinkedList < ConnectionEditPart > ();
        for (Iterator itr = ep.getSourceConnections ().iterator ();
        itr.hasNext ();) {
            ConnectionEditPart sourceConn = (ConnectionEditPart) itr.next ();
            connections.add (sourceConn);
            connections.addAll (getAllConnectionsFrom (sourceConn));
        }
        return connections;
    }

    private void paintFigure (Graphics graphics, IFigure figure) {
        if (! figure.isVisible ()) return;

        Rectangle relBounds = null;
        if (figure instanceof IExpandableFigure) relBounds = ((IExpandableFigure) figure).getExtendedBounds ().getCopy ();
        else relBounds = figure.getBounds ().getCopy ();

        Rectangle abBounds = relBounds.getCopy ();
        translateToPrintableLayer (figure, abBounds);
        int transX = abBounds.x - relBounds.x;
        int transY = abBounds.y - relBounds.y;
        graphics.pushState ();
        graphics.translate (transX, transY);
        figure.paint (graphics);
        graphics.popState ();
        graphics.restoreState ();
    }

    private Map findDecorations (Collection editparts) {
        Map figureMap = mapFiguresToEditParts (editparts);
        Map result = new java.util.HashMap ();
        if (! editparts.isEmpty ()) {
            IGraphicalEditPart first = (IGraphicalEditPart) editparts.iterator ().next ();
            IFigure decorationLayer = LayerManager.Helper.find (first).getLayer (DiagramRootEditPart.DECORATION_PRINTABLE_LAYER);
            if (decorationLayer != null) {
                List figures = new java.util.ArrayList (editparts);
                for (ListIterator iter = figures.listIterator ();
                iter.hasNext ();) {
                    iter.set (((IGraphicalEditPart) iter.next ()).getFigure ());
                }
                for (Iterator iter = decorationLayer.getChildren ().iterator ();
                iter.hasNext ();) {
                    Object next = iter.next ();
                    if (next instanceof Decoration) {
                        Decoration decoration = (Decoration) next;
                        IFigure owner = decoration.getOwnerFigure ();
                        while (owner != null) {
                            if (figureMap.containsKey (owner)) {
                                Object existing = result.get (owner);
                                if (existing == null) {
                                    result.put (owner, decoration);
                                } else if (existing instanceof Collection) {
                                    ((Collection) existing).add (decoration);
                                } else {
                                    Collection c = new java.util.ArrayList (2);
                                    c.add (existing);
                                    c.add (decoration);
                                    result.put (owner, c);
                                }

                                break;
                            } else {
                                owner = owner.getParent ();
                            }
                        }
                    }
                }
            }
        }
        return result;
    }

    private Map mapFiguresToEditParts (Collection editParts) {
        Map result = new java.util.HashMap ();
        for (Iterator iter = editParts.iterator ();
        iter.hasNext ();) {
            IGraphicalEditPart next = (IGraphicalEditPart) iter.next ();
            result.put (next.getFigure (), next);
        }
        return result;
    }

    private void paintDecorations (Graphics graphics, IFigure figure, Map decorations) {
        Object decoration = decorations.get (figure);
        if (decoration != null) {
            if (decoration instanceof Collection) {
                for (Iterator iter = ((Collection) decoration).iterator ();
                iter.hasNext ();) {
                    paintFigure (graphics, (IFigure) iter.next ());
                }
            } else {
                paintFigure (graphics, (IFigure) decoration);
            }
        }
    }

    private void sortSelection (GraphicalEditPart editPart, List open, List closed) {
        if (open.isEmpty ()) {
            return;
        }
        if (open.contains (editPart)) {
            closed.add (editPart);
            open.remove (editPart);
        }
        for (Iterator iter = editPart.getChildren ().iterator ();
        iter.hasNext ();) {
            GraphicalEditPart child = (GraphicalEditPart) iter.next ();
            sortSelection (child, open, closed);
        }
    }

    private List sortSelection (List toSort) {
        List closed = new ArrayList (toSort.size ());
        List open = new ArrayList (toSort.size ());
        open.addAll (toSort);
        sortSelection (getDiagramEditPart (), open, closed);
        if (! open.isEmpty ()) {
            closed.addAll (open);
        }
        return closed;
    }

    private void getNestedEditParts (IGraphicalEditPart childEditPart, Collection editParts) {
        for (Iterator iter = childEditPart.getChildren ().iterator ();
        iter.hasNext ();) {
            IGraphicalEditPart child = (IGraphicalEditPart) iter.next ();
            editParts.add (child);
            getNestedEditParts (child, editParts);
        }
    }

    public org.eclipse.swt.graphics.Rectangle calculateImageRectangle (List editparts) {
        int minX = 0;
        int maxX = 0;
        int minY = 0;
        int maxY = 0;
        IMapMode mm = getMapMode ();
        for (int i = 0;
        i < (editparts.size ()); i ++) {
            IGraphicalEditPart editPart = (IGraphicalEditPart) editparts.get (i);
            IFigure figure = editPart.getFigure ();
            Rectangle bounds = null;
            if (figure instanceof IExpandableFigure) bounds = ((IExpandableFigure) figure).getExtendedBounds ();
            else bounds = figure.getBounds ().getCopy ();

            translateToPrintableLayer (figure, bounds);
            bounds = bounds.getExpanded (getImageMargin (), getImageMargin ());
            if (i == 0) {
                minX = bounds.x;
                maxX = bounds.x + bounds.width;
                minY = bounds.y;
                maxY = bounds.y + bounds.height;
            } else {
                minX = Math.min (minX, bounds.x);
                maxX = Math.max (maxX, (bounds.x + bounds.width));
                minY = Math.min (minY, bounds.y);
                maxY = Math.max (maxY, (bounds.y + bounds.height));
            }
        }
        int width = (maxX - minX);
        int height = (maxY - minY);
        if (width <= 0) {
            width = mm.DPtoLP (100);
        }
        if (height <= 0) {
            height = mm.DPtoLP (100);
        }
        org.eclipse.swt.graphics.Rectangle imageRect = new org.eclipse.swt.graphics.Rectangle (minX, minY, width, height);
        return imageRect;
    }

    public List getDiagramPartInfo (DiagramEditPart diagramEditPart) {
        List result = new ArrayList ();
        List editParts = new ArrayList ();
        List children = diagramEditPart.getPrimaryEditParts ();
        IMapMode mm = getMapMode ();
        org.eclipse.swt.graphics.Rectangle imageRect = calculateImageRectangle (children);
        Iterator li = children.iterator ();
        while (li.hasNext ()) {
            IGraphicalEditPart part = (IGraphicalEditPart) li.next ();
            editParts.add (part);
            getNestedEditParts (part, editParts);
        }
        Iterator iter = editParts.iterator ();
        while (iter.hasNext ()) {
            IGraphicalEditPart part = (IGraphicalEditPart) iter.next ();
            IFigure figure = part.getFigure ();
            if (part instanceof ShapeEditPart || part instanceof ShapeCompartmentEditPart) {
                PartPositionInfo position = new PartPositionInfo ();
                position.setSemanticElement (ViewUtil.resolveSemanticElement ((View) part.getModel ()));
                Rectangle bounds = figure.getBounds ().getCopy ();
                translateToPrintableLayer (figure, bounds);
                bounds.translate (- imageRect.x, - imageRect.y);
                position.setPartHeight (mm.LPtoDP (bounds.height));
                position.setPartWidth (mm.LPtoDP (bounds.width));
                position.setPartX (mm.LPtoDP (bounds.x));
                position.setPartY (mm.LPtoDP (bounds.y));
                result.add (0, position);
            } else if (part instanceof ConnectionEditPart) {
                PartPositionInfo position = new PartPositionInfo ();
                position.setSemanticElement (ViewUtil.resolveSemanticElement ((View) part.getModel ()));
                if (figure instanceof PolylineConnection) {
                    PolylineConnection mainPoly = (PolylineConnection) figure;
                    PointList mainPts = mainPoly.getPoints ();
                    translateToPrintableLayer (figure, mainPts);
                    List envelopingPts = calculateEnvelopingPolyline (mainPts, new Point (imageRect.x, imageRect.y));
                    List transformedPts = convertPolylineUnits (envelopingPts);
                    position.setPolyline (transformedPts);
                    result.add (0, position);
                }
            }

        }
        return result;
    }

    private void translateToPrintableLayer (IFigure figure, Translatable translatable) {
        IFigure printableLayer = getDiagramEditPart ().getLayer (LayerConstants.PRINTABLE_LAYERS);
        if (figure == null || figure.equals (printableLayer)) {
            return;
        }
        figure.translateToParent (translatable);
        translateToPrintableLayer (figure.getParent (), translatable);
    }

    private List calculateEnvelopingPolyline (PointList polyPts, Point origin) {
        ArrayList result = new ArrayList ();
        List mainSegs = PointListUtilities.getLineSegments (polyPts);
        int mainSegsLength = mainSegs.size ();
        LineSeg segment = null;
        Point orthoPoint1 = null;
        Point orthoPoint2 = null;
        for (int i = 0;
        i < mainSegsLength; i ++) {
            segment = (LineSeg) mainSegs.get (i);
            orthoPoint1 = segment.locatePoint (0.0, getImageMargin (), Sign.POSITIVE);
            orthoPoint1.translate (- origin.x, - origin.y);
            orthoPoint2 = segment.locatePoint (1.0, getImageMargin (), Sign.POSITIVE);
            orthoPoint2.translate (- origin.x, - origin.y);
            result.add (orthoPoint1);
            result.add (orthoPoint2);
        }
        for (int i = mainSegsLength - 1;
        i >= 0; i --) {
            segment = (LineSeg) mainSegs.get (i);
            orthoPoint1 = segment.getTerminus ();
            orthoPoint1.translate (- origin.x, - origin.y);
            result.add (orthoPoint1);
            orthoPoint2 = segment.getOrigin ();
            orthoPoint2.translate (- origin.x, - origin.y);
            result.add (orthoPoint2);
        }
        Object first = result.get (0);
        result.add (first);
        return result;
    }

    private List convertPolylineUnits (List polyPts) {
        ArrayList result = new ArrayList ();
        Iterator iter = polyPts.iterator ();
        IMapMode mm = getMapMode ();
        while (iter.hasNext ()) {
            Point point = (Point) iter.next ();
            Point newPoint = new Point (mm.LPtoDP (point.x), mm.LPtoDP (point.y));
            result.add (newPoint);
        }
        return result;
    }

    protected int getImageMargin () {
        return image_margin;
    }

    public Image createAWTImageForParts (List editParts, org.eclipse.swt.graphics.Rectangle diagramArea) {
        return null;
    }

    final public ImageDescriptor createSWTImageDescriptorForParts (List editparts, org.eclipse.swt.graphics.Rectangle sourceRect) {
        ImageDescriptor imageDesc = new ImageDescriptor () {

            public ImageData getImageData () {
                return SharedImages.get (SharedImages.IMG_ERROR).getImageData ();
            }

        }

        ;
        Graphics graphics = null;
        try {
            IMapMode mm = getMapMode ();
            graphics = setUpGraphics (mm.LPtoDP (sourceRect.width), mm.LPtoDP (sourceRect.height));
            RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics (graphics, getMapMode ());
            renderToGraphics (mapModeGraphics, new Point (sourceRect.x, sourceRect.y), editparts);
            imageDesc = getImageDescriptor (graphics);
        } finally {
            if (graphics != null) disposeGraphics (graphics);

        }
        return imageDesc;
    }

}

