package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.ConnectionAnchor;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.PrecisionPoint;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.figures.OrthogonalConnectionAnchor;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

public class OrthogonalRouterUtilities {

    public static Point getAdjustedCenterPoint (final Rectangle rect, final Point ref) {
        Point ptNewCenter = new Point (rect.getCenter ());
        if (ref.x < rect.getRight ().x && ref.x > rect.getLeft ().x) {
            ptNewCenter.x = ref.x;
        } else if (ref.y < rect.getBottom ().y && ref.y > rect.getTop ().y) {
            ptNewCenter.y = ref.y;
        }

        return ptNewCenter;
    }

    public static void resetEndPointsToCenter (Connection conn, PointList newLine) {
        Rectangle startRect = getBounds (conn.getSourceAnchor ().getOwner ());
        conn.getSourceAnchor ().getOwner ().translateToAbsolute (startRect);
        Point ptStart = newLine.getPoint (1);
        conn.translateToAbsolute (ptStart);
        ptStart = getAdjustedCenterPoint (startRect, ptStart);
        conn.translateToRelative (ptStart);
        newLine.setPoint (ptStart, 0);
        Rectangle endRect = getBounds (conn.getTargetAnchor ().getOwner ());
        conn.getTargetAnchor ().getOwner ().translateToAbsolute (endRect);
        Point ptEnd = newLine.getPoint (newLine.size () - 2);
        conn.translateToAbsolute (ptEnd);
        ptEnd = getAdjustedCenterPoint (endRect, ptEnd);
        conn.translateToRelative (ptEnd);
        newLine.setPoint (ptEnd, newLine.size () - 1);
    }

    private static Point getEdgePoint (Connection conn, ConnectionAnchor anchor, Point ptRef) {
        Rectangle rect = getBounds (anchor.getOwner ());
        anchor.getOwner ().translateToAbsolute (rect);
        conn.translateToRelative (rect);
        Point ptRef2 = new Point (ptRef);
        Point ptRef1 = getAdjustedCenterPoint (rect, ptRef2);
        Point ptAbsRef2 = new Point (ptRef2);
        conn.translateToAbsolute (ptAbsRef2);
        Point ptEdge = anchor.getLocation (ptAbsRef2);
        conn.translateToRelative (ptEdge);
        LineSeg lineSeg = new LineSeg (ptRef1, ptRef2);
        Point ptProj = lineSeg.perpIntersect (ptEdge.x, ptEdge.y);
        if (Math.abs (ptProj.x - ptRef2.x) < Math.abs (ptProj.y - ptRef2.y)) ptProj.x = ptRef2.x;
        else ptProj.y = ptRef2.y;

        return ptProj;
    }

    public static LineSeg getOrthogonalLineSegToAnchorLoc (Connection conn, ConnectionAnchor anchor, Point ref) {
        assert anchor != null && anchor.getOwner () != null;
        if (anchor instanceof OrthogonalConnectionAnchor) {
            PrecisionPoint refAbs = new PrecisionPoint (ref);
            conn.translateToAbsolute (refAbs);
            PrecisionPoint anchorPoint = new PrecisionPoint (((OrthogonalConnectionAnchor) anchor).getOrthogonalLocation (refAbs));
            conn.translateToRelative (anchorPoint);
            return new LineSeg (anchorPoint, ref);
        }
        Point ptAbsRef = getEdgePoint (conn, anchor, ref);
        conn.translateToAbsolute (ptAbsRef);
        Point ptEdge = anchor.getLocation (ptAbsRef);
        conn.translateToRelative (ptEdge);
        LineSeg result = new LineSeg (ptEdge, ref);
        if (! result.isHorizontal () && ! result.isVertical ()) {
            if (Math.abs (result.getOrigin ().x - result.getTerminus ().x) < Math.abs (result.getOrigin ().y - result.getTerminus ().y)) {
                result.setTerminus (new Point (result.getOrigin ().x, result.getTerminus ().y));
            } else {
                result.setTerminus (new Point (result.getTerminus ().x, result.getOrigin ().y));
            }
        }
        return result;
    }

    private static Rectangle getBounds (IFigure figure) {
        return figure instanceof Connection ? ((Connection) figure).getPoints ().getBounds ().getCopy () : figure.getBounds ().getCopy ();
    }

    public static boolean isRectilinear (PointList points) {
        for (int i = 1;
        i < points.size (); i ++) {
            Point currentPt = points.getPoint (i);
            Point previousPt = points.getPoint (i - 1);
            if (currentPt.x != previousPt.x && currentPt.y != previousPt.y) {
                return false;
            }
        }
        return true;
    }

    public static void transformToOrthogonalPointList (PointList points, int offStartDirection, int offEndDirection) {
        if (points.size () > 1) {
            PointList startPoints = new PointList (points.size ());
            PointList endPoints = new PointList (points.size ());
            boolean isOffSourceDirectionSet = offStartDirection == PositionConstants.HORIZONTAL || offStartDirection == PositionConstants.VERTICAL;
            boolean isOffTargetDirectionSet = offEndDirection == PositionConstants.VERTICAL || offEndDirection == PositionConstants.HORIZONTAL;
            if (! isOffSourceDirectionSet && ! isOffTargetDirectionSet) {
                Point first = points.getPoint (0);
                Point second = points.getPoint (1);
                offStartDirection = Math.abs (first.x - second.x) < Math.abs (first.y - second.y) ? PositionConstants.HORIZONTAL : PositionConstants.VERTICAL;
                isOffSourceDirectionSet = true;
            }
            startPoints.addPoint (points.removePoint (0));
            endPoints.addPoint (points.removePoint (points.size () - 1));
            while (points.size () != 0) {
                if (isOffSourceDirectionSet) {
                    Point nextPt = points.removePoint (0);
                    Point lastStartPt = startPoints.getLastPoint ();
                    if (nextPt.x != lastStartPt.x && nextPt.y != lastStartPt.y) {
                        if (offStartDirection == PositionConstants.VERTICAL) {
                            startPoints.addPoint (new Point (lastStartPt.x, nextPt.y));
                            offStartDirection = PositionConstants.HORIZONTAL;
                        } else {
                            startPoints.addPoint (new Point (nextPt.x, lastStartPt.y));
                            offStartDirection = PositionConstants.VERTICAL;
                        }
                    } else {
                        offStartDirection = nextPt.x == lastStartPt.x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
                    }
                    startPoints.addPoint (nextPt);
                }
                if (isOffTargetDirectionSet && points.size () != 0) {
                    Point nextPt = points.removePoint (points.size () - 1);
                    Point firstEndPt = endPoints.getFirstPoint ();
                    if (nextPt.x != firstEndPt.x && nextPt.y != firstEndPt.y) {
                        if (offEndDirection == PositionConstants.VERTICAL) {
                            endPoints.insertPoint (new Point (firstEndPt.x, nextPt.y), 0);
                            offEndDirection = PositionConstants.HORIZONTAL;
                        } else {
                            endPoints.insertPoint (new Point (nextPt.x, firstEndPt.y), 0);
                            offEndDirection = PositionConstants.VERTICAL;
                        }
                    } else {
                        offEndDirection = nextPt.x == firstEndPt.x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
                    }
                    endPoints.insertPoint (nextPt, 0);
                }
            }
            Point lastStartPt = startPoints.getLastPoint ();
            Point firstEndPt = endPoints.getFirstPoint ();
            if (lastStartPt.x != firstEndPt.x && lastStartPt.y != firstEndPt.y) {
                if ((! isOffSourceDirectionSet && isOffTargetDirectionSet) || (isOffTargetDirectionSet && endPoints.size () < startPoints.size ())) {
                    if (offEndDirection == PositionConstants.VERTICAL) {
                        startPoints.addPoint (new Point (firstEndPt.x, lastStartPt.y));
                    } else {
                        startPoints.addPoint (new Point (lastStartPt.x, firstEndPt.y));
                    }
                } else if (offStartDirection == PositionConstants.VERTICAL) {
                    startPoints.addPoint (new Point (lastStartPt.x, firstEndPt.y));
                } else {
                    startPoints.addPoint (new Point (firstEndPt.x, lastStartPt.y));
                }

            }
            points.addAll (startPoints);
            points.addAll (endPoints);
        }
    }

}

