package org.eclipse.gmf.graphdef.editor.edit.parts;

import java.util.ArrayList;

import java.util.Collection;

import java.util.Collections;

import org.eclipse.core.commands.ExecutionException;

import org.eclipse.core.runtime.IAdaptable;

import org.eclipse.core.runtime.IProgressMonitor;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.NullProgressMonitor;

import org.eclipse.core.runtime.Status;

import org.eclipse.draw2d.CompoundBorder;

import org.eclipse.draw2d.FreeformLayout;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.LineBorder;

import org.eclipse.draw2d.MarginBorder;

import org.eclipse.draw2d.RoundedRectangle;

import org.eclipse.draw2d.StackLayout;

import org.eclipse.draw2d.XYLayout;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.emf.common.notify.Adapter;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.transaction.Transaction;

import org.eclipse.emf.workspace.AbstractEMFOperation;

import org.eclipse.gef.EditPolicy;

import org.eclipse.gef.editpolicies.LayoutEditPolicy;

import org.eclipse.gmf.gmfgraph.ColorConstants;

import org.eclipse.gmf.gmfgraph.ConstantColor;

import org.eclipse.gmf.gmfgraph.GMFGraphFactory;

import org.eclipse.gmf.gmfgraph.GMFGraphPackage;

import org.eclipse.gmf.gmfgraph.RGBColor;

import org.eclipse.gmf.gmfgraph.Shape;

import org.eclipse.gmf.graphdef.editor.edit.policies.RoundedRectangle3CanonicalEditPolicy;

import org.eclipse.gmf.graphdef.editor.edit.policies.RoundedRectangle3ItemSemanticEditPolicy;

import org.eclipse.gmf.graphdef.editor.edit.polocies.DomainBasedXYLayoutEditPolicy;

import org.eclipse.gmf.graphdef.editor.part.GMFGraphDiagramEditorPlugin;

import org.eclipse.gmf.graphdef.editor.sheet.AttachAdapter;

import org.eclipse.gmf.graphdef.editor.sheet.ChangeTracker;

import org.eclipse.gmf.graphdef.editor.sheet.FeatureTracker;

import org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CreationEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.DragDropEditPolicy;

import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;

import org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure;

import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;

import org.eclipse.gmf.runtime.notation.FillStyle;

import org.eclipse.gmf.runtime.notation.LineStyle;

import org.eclipse.gmf.runtime.notation.NotationPackage;

import org.eclipse.gmf.runtime.notation.View;

import org.eclipse.swt.SWT;

import org.eclipse.swt.widgets.Display;

public class RoundedRectangle3EditPart extends AbstractFigureEditPart {
    public static final int VISUAL_ID = 3020;
    protected IFigure contentPane;
    protected IFigure primaryShape;

    public RoundedRectangle3EditPart (View view) {
        super (view);
    }

    protected void createDefaultEditPolicies () {
        installEditPolicy (EditPolicyRoles.CREATION_ROLE, new CreationEditPolicy ());
        super.createDefaultEditPolicies ();
        installEditPolicy (EditPolicyRoles.SEMANTIC_ROLE, new RoundedRectangle3ItemSemanticEditPolicy ());
        installEditPolicy (EditPolicyRoles.DRAG_DROP_ROLE, new DragDropEditPolicy ());
        installEditPolicy (EditPolicyRoles.CANONICAL_ROLE, new RoundedRectangle3CanonicalEditPolicy ());
        installEditPolicy (EditPolicy.LAYOUT_ROLE, createLayoutEditPolicy ());
    }

    protected LayoutEditPolicy createLayoutEditPolicy () {
        return new DomainBasedXYLayoutEditPolicy (getMapMode ());
    }

    protected IFigure createNodeShape () {
        RoundedRectangleFigure figure = new RoundedRectangleFigure ();
        figure.setUseLocalCoordinates (true);
        myFigure = figure;
        return primaryShape = figure;
    }

    public RoundedRectangleFigure getPrimaryShape () {
        return (RoundedRectangleFigure) primaryShape;
    }

    protected NodeFigure createNodePlate () {
        DefaultSizeNodeFigure result = new DefaultSizeNodeFigure (getMapMode ().DPtoLP (0), getMapMode ().DPtoLP (0));
        LineBorder contourBorder = new LineBorder (Display.getDefault ().getSystemColor (SWT.COLOR_WIDGET_NORMAL_SHADOW));
        MarginBorder marginBorder = new MarginBorder (5);
        CompoundBorder compoundBorder = new CompoundBorder (contourBorder, marginBorder);
        result.setBorder (compoundBorder);
        return result;
    }

    protected NodeFigure createNodeFigure () {
        NodeFigure figure = createNodePlate ();
        figure.setLayoutManager (new StackLayout ());
        IFigure shape = createNodeShape ();
        figure.add (shape);
        contentPane = setupContentPane (shape);
        return figure;
    }

    protected IFigure setupContentPane (IFigure nodeShape) {
        if (nodeShape.getLayoutManager () == null) {
            nodeShape.setLayoutManager (new FreeformLayout () {

                public Object getConstraint (IFigure figure) {
                    Object result = constraints.get (figure);
                    if (result == null) {
                        result = new Rectangle (0, 0, - 1, - 1);
                    }
                    return result;
                }

            }

            );
        }
        return nodeShape;
    }

    public IFigure getContentPane () {
        if (contentPane != null) {
            return contentPane;
        }
        return super.getContentPane ();
    }

    public class RoundedRectangleFigure extends RoundedRectangle {

        public RoundedRectangleFigure () {
            this.setLayoutManager (new XYLayout ());
            this.setCornerDimensions (new Dimension (getMapMode ().DPtoLP (8), getMapMode ().DPtoLP (8)));
        }

        private boolean myUseLocalCoordinates = false;

        protected boolean useLocalCoordinates () {
            return myUseLocalCoordinates;
        }

        protected void setUseLocalCoordinates (boolean useLocalCoordinates) {
            myUseLocalCoordinates = useLocalCoordinates;
        }

    }

    private RoundedRectangleFigure myFigure;
    private Collection < Adapter > myDomainElementAdapters = new ArrayList < Adapter > ();

    private org.eclipse.gmf.gmfgraph.RoundedRectangle getModelFigureElement () {
        Shape shape = getShape ();
        if (shape instanceof org.eclipse.gmf.gmfgraph.RoundedRectangle) {
            org.eclipse.gmf.gmfgraph.RoundedRectangle modelFigureElement = (org.eclipse.gmf.gmfgraph.RoundedRectangle) shape;
            return modelFigureElement;
        }
        return null;
    }

    protected void removeSemanticListeners () {
        org.eclipse.gmf.gmfgraph.RoundedRectangle modelElement = (org.eclipse.gmf.gmfgraph.RoundedRectangle) getModelFigureElement ();
        if (modelElement != null) {
            modelElement.eAdapters ().removeAll (myDomainElementAdapters);
            myDomainElementAdapters.clear ();
        }
        super.removeSemanticListeners ();
    }

    protected void setFigure (IFigure figure) {
        super.setFigure (figure);
        org.eclipse.gmf.gmfgraph.RoundedRectangle modelElement = (org.eclipse.gmf.gmfgraph.RoundedRectangle) getModelFigureElement ();
        if (modelElement != null) {
            myFigure.setOutline (modelElement.isOutline ());
            myFigure.setFill (modelElement.isFill ());
            myFigure.setLineWidth (modelElement.getLineWidth ());
            myFigure.setLineStyle (getLineStyle (modelElement.getLineKind ()));
            myFigure.setFillXOR (modelElement.isXorFill ());
            myFigure.setOutlineXOR (modelElement.isXorOutline ());
            myFigure.setCornerDimensions (getCornerDimensions (modelElement.getCornerWidth (), modelElement.getCornerHeight ()));
            myFigure.setLayoutManager (getLayoutManager (modelElement.getLayout ()));
        }
    }

    public void activate () {
        if (isActive ()) {
            return;
        }
        final org.eclipse.gmf.gmfgraph.RoundedRectangle modelElement = (org.eclipse.gmf.gmfgraph.RoundedRectangle) getModelFigureElement ();
        if (modelElement == null) {
            super.activate ();
            return;
        }
        ChangeTracker outlineTracker = new ChangeTracker () {

            public void modelChanged (Notification msg) {
                myFigure.setOutline (modelElement.isOutline ());
            }

        }

        ;
        myDomainElementAdapters.add (new FeatureTracker (outlineTracker, GMFGraphPackage.eINSTANCE.getShape_Outline ()));
        ChangeTracker fillTracker = new ChangeTracker () {

            public void modelChanged (Notification msg) {
                myFigure.setFill (modelElement.isFill ());
            }

        }

        ;
        myDomainElementAdapters.add (new FeatureTracker (fillTracker, GMFGraphPackage.eINSTANCE.getShape_Fill ()));
        ChangeTracker lineWidthTracker = new ChangeTracker () {

            public void modelChanged (Notification msg) {
                myFigure.setLineWidth (modelElement.getLineWidth ());
            }

        }

        ;
        myDomainElementAdapters.add (new FeatureTracker (lineWidthTracker, GMFGraphPackage.eINSTANCE.getShape_LineWidth ()));
        ChangeTracker lineStyleTracker = new ChangeTracker () {

            public void modelChanged (Notification msg) {
                myFigure.setLineStyle (getLineStyle (modelElement.getLineKind ()));
            }

        }

        ;
        myDomainElementAdapters.add (new FeatureTracker (lineStyleTracker, GMFGraphPackage.eINSTANCE.getShape_LineKind ()));
        ChangeTracker fillXORTracker = new ChangeTracker () {

            public void modelChanged (Notification msg) {
                myFigure.setFillXOR (modelElement.isXorFill ());
            }

        }

        ;
        myDomainElementAdapters.add (new FeatureTracker (fillXORTracker, GMFGraphPackage.eINSTANCE.getShape_XorFill ()));
        ChangeTracker outlineXORTracker = new ChangeTracker () {

            public void modelChanged (Notification msg) {
                myFigure.setOutlineXOR (modelElement.isXorOutline ());
            }

        }

        ;
        myDomainElementAdapters.add (new FeatureTracker (outlineXORTracker, GMFGraphPackage.eINSTANCE.getShape_XorOutline ()));
        ChangeTracker cornerDimensionsTracker = new ChangeTracker () {

            public void modelChanged (Notification msg) {
                myFigure.setCornerDimensions (getCornerDimensions (modelElement.getCornerWidth (), modelElement.getCornerHeight ()));
            }

        }

        ;
        myDomainElementAdapters.add (new FeatureTracker (cornerDimensionsTracker, GMFGraphPackage.eINSTANCE.getRoundedRectangle_CornerWidth ()));
        myDomainElementAdapters.add (new FeatureTracker (cornerDimensionsTracker, GMFGraphPackage.eINSTANCE.getRoundedRectangle_CornerHeight ()));
        ChangeTracker layoutManagerTracker = new ChangeTracker () {

            public void modelChanged (Notification msg) {
                myFigure.setLayoutManager (getLayoutManager (modelElement.getLayout ()));
            }

        }

        ;
        myDomainElementAdapters.add (new AttachAdapter (GMFGraphPackage.eINSTANCE.getLayoutable_Layout (), layoutManagerTracker, new AttachAdapter (GMFGraphPackage.eINSTANCE.getBorderLayout_Spacing (), layoutManagerTracker, new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getDimension_Dx ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getDimension_Dy ())), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getFlowLayout_Vertical ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getFlowLayout_MatchMinorSize ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getFlowLayout_ForceSingleLine ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getFlowLayout_MajorAlignment ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getFlowLayout_MinorAlignment ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getFlowLayout_MajorSpacing ()), new
          FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getFlowLayout_MinorSpacing ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getGridLayout_NumColumns ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getGridLayout_EqualWidth ()), new AttachAdapter (GMFGraphPackage.eINSTANCE.getGridLayout_Margins (), layoutManagerTracker, new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getDimension_Dx ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getDimension_Dy ())), new AttachAdapter (GMFGraphPackage.eINSTANCE.getGridLayout_Spacing (), layoutManagerTracker, new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getDimension_Dx ()), new FeatureTracker (layoutManagerTracker, GMFGraphPackage.eINSTANCE.getDimension_Dy ()))));
        modelElement.eAdapters ().addAll (myDomainElementAdapters);
        View view = getNotationView ();
        final FillStyle theFillStyle = (FillStyle) view.getStyle (NotationPackage.eINSTANCE.getFillStyle ());
        if (modelElement.getBackgroundColor () != null) {
            final int rgbColor;
            if (modelElement.getBackgroundColor () instanceof RGBColor) {
                RGBColor modelColor = (RGBColor) modelElement.getBackgroundColor ();
                rgbColor = (modelColor.getRed () & 0xFF) | ((modelColor.getGreen () & 0xFF) << 8) | ((modelColor.getBlue () & 0xFF) << 16);
            } else {
                ConstantColor modelColor = (ConstantColor) modelElement.getBackgroundColor ();
                rgbColor = getRgbColor (modelColor);
            }
            if (rgbColor != - 1 && theFillStyle.getFillColor () != rgbColor) {
                AbstractEMFOperation setColorOperation = new AbstractEMFOperation (getEditingDomain (), "Synchronizing view Background color with the model", Collections.singletonMap (Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) {

                    protected IStatus doExecute (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
                        theFillStyle.setFillColor (rgbColor);
                        return Status.OK_STATUS;
                    }

                }

                ;
                try {
                    setColorOperation.execute (new NullProgressMonitor (), null);
                } catch (ExecutionException e) {
                    GMFGraphDiagramEditorPlugin.getInstance ().logError ("Unable to synchronize view Background color with the model", e);
                }
            }
        }
        final LineStyle theLineStyle = (LineStyle) view.getStyle (NotationPackage.eINSTANCE.getLineStyle ());
        if (modelElement.getForegroundColor () != null) {
            final int rgbColor;
            if (modelElement.getForegroundColor () instanceof RGBColor) {
                RGBColor modelColor = (RGBColor) modelElement.getForegroundColor ();
                rgbColor = (modelColor.getRed () & 0xFF) | ((modelColor.getGreen () & 0xFF) << 8) | ((modelColor.getBlue () & 0xFF) << 16);
            } else {
                ConstantColor modelColor = (ConstantColor) modelElement.getForegroundColor ();
                rgbColor = getRgbColor (modelColor);
            }
            if (rgbColor != - 1 && theLineStyle.getLineColor () != rgbColor) {
                AbstractEMFOperation setColorOperation = new AbstractEMFOperation (getEditingDomain (), "Synchronizing view Foreground color with the model", Collections.singletonMap (Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) {

                    protected IStatus doExecute (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
                        theLineStyle.setLineColor (rgbColor);
                        return Status.OK_STATUS;
                    }

                }

                ;
                try {
                    setColorOperation.execute (new NullProgressMonitor (), null);
                } catch (ExecutionException e) {
                    GMFGraphDiagramEditorPlugin.getInstance ().logError ("Unable to synchronize view Foreground color with the model", e);
                }
            }
        }
        final FillStyle theFillStyle1 = (FillStyle) view.getStyle (NotationPackage.eINSTANCE.getFillStyle ());
        addListenerFilter ("FillStyleListener", new NotificationListener () {

            public void notifyChanged (final Notification notification) {
                try {
                    new AbstractEMFOperation (getEditingDomain (), "Synchronizing model Background color with the view", Collections.singletonMap (Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) {

                        protected IStatus doExecute (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
                            FillStyle theFillStyle = (FillStyle) notification.getNotifier ();
                            if (notification.getFeatureID (FillStyle.class) == NotationPackage.FILL_STYLE__FILL_COLOR) {
                                int color = theFillStyle.getFillColor ();
                                RGBColor modelColor;
                                if (modelElement.getBackgroundColor () instanceof RGBColor) {
                                    modelColor = (RGBColor) modelElement.getBackgroundColor ();
                                } else {
                                    modelColor = GMFGraphFactory.eINSTANCE.createRGBColor ();
                                    modelElement.setBackgroundColor (modelColor);
                                }
                                if (modelColor.getRed () != (color & 0x000000FF) || modelColor.getGreen () != (color & 0x0000FF00)>> 8 || modelColor.getBlue () != (color & 0x00FF0000)>> 16) {
                                    modelColor.setRed (color & 0x000000FF);
                                    modelColor.setGreen ((color & 0x0000FF00)>> 8);
                                    modelColor.setBlue ((color & 0x00FF0000)>> 16);
                                }
                            }
                            return Status.OK_STATUS;
                        }

                    }

                    .execute (new NullProgressMonitor (), null);
                } catch (ExecutionException e) {
                    GMFGraphDiagramEditorPlugin.getInstance ().logError ("Unable to synchronize model Background color with the view", e);
                }
            }

        }

        , theFillStyle1);
        final LineStyle theLineStyle1 = (LineStyle) view.getStyle (NotationPackage.eINSTANCE.getLineStyle ());
        addListenerFilter ("LineStyleListener", new NotificationListener () {

            public void notifyChanged (final Notification notification) {
                try {
                    new AbstractEMFOperation (getEditingDomain (), "Synchronizing model Foreground color with the view", Collections.singletonMap (Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) {

                        protected IStatus doExecute (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
                            LineStyle theLineStyle = (LineStyle) notification.getNotifier ();
                            if (notification.getFeatureID (LineStyle.class) == NotationPackage.LINE_STYLE__LINE_COLOR) {
                                int color = theLineStyle.getLineColor ();
                                RGBColor modelColor;
                                if (modelElement.getForegroundColor () instanceof RGBColor) {
                                    modelColor = (RGBColor) modelElement.getForegroundColor ();
                                } else {
                                    modelColor = GMFGraphFactory.eINSTANCE.createRGBColor ();
                                    modelElement.setForegroundColor (modelColor);
                                }
                                if (modelColor.getRed () != (color & 0x000000FF) || modelColor.getGreen () != (color & 0x0000FF00)>> 8 || modelColor.getBlue () != (color & 0x00FF0000)>> 16) {
                                    modelColor.setRed (color & 0x000000FF);
                                    modelColor.setGreen ((color & 0x0000FF00)>> 8);
                                    modelColor.setBlue ((color & 0x00FF0000)>> 16);
                                }
                            }
                            return Status.OK_STATUS;
                        }

                    }

                    .execute (new NullProgressMonitor (), null);
                } catch (ExecutionException e) {
                    GMFGraphDiagramEditorPlugin.getInstance ().logError ("Unable to synchronize model Foreground color with the view", e);
                }
            }

        }

        , theLineStyle1);
        super.activate ();
    }

    public static int getRgbColor (ConstantColor modelColor) {
        final int rgbColor;
        switch (modelColor.getValue ().getValue ()) {
            case ColorConstants.WHITE :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.white.getRGB ().hashCode ();
                    break;
                } case ColorConstants.BLACK :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.black.getRGB ().hashCode ();
                    break;
                } case ColorConstants.LIGHT_GRAY :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.lightGray.getRGB ().hashCode ();
                    break;
                } case ColorConstants.GRAY :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.gray.getRGB ().hashCode ();
                    break;
                } case ColorConstants.DARK_GRAY :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.darkGray.getRGB ().hashCode ();
                    break;
                } case ColorConstants.RED :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.red.getRGB ().hashCode ();
                    break;
                } case ColorConstants.ORANGE :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.orange.getRGB ().hashCode ();
                    break;
                } case ColorConstants.YELLOW :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.yellow.getRGB ().hashCode ();
                    break;
                } case ColorConstants.GREEN :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.green.getRGB ().hashCode ();
                    break;
                } case ColorConstants.LIGHT_GREEN :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.lightGreen.getRGB ().hashCode ();
                    break;
                } case ColorConstants.DARK_GREEN :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.darkGreen.getRGB ().hashCode ();
                    break;
                } case ColorConstants.CYAN :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.cyan.getRGB ().hashCode ();
                    break;
                } case ColorConstants.LIGHT_BLUE :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.lightBlue.getRGB ().hashCode ();
                    break;
                } case ColorConstants.BLUE :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.blue.getRGB ().hashCode ();
                    break;
                } case ColorConstants.DARK_BLUE :
                {
                    rgbColor = org.eclipse.draw2d.ColorConstants.darkBlue.getRGB ().hashCode ();
                    break;
                } default :
                rgbColor = - 1;
        }
        return rgbColor;
    }

}

