package org.eclipse.gmf.runtime.diagram.ui.internal.tools;

import java.lang.ref.WeakReference;

import java.util.ArrayList;

import java.util.HashSet;

import java.util.Iterator;

import java.util.List;

import java.util.ListIterator;

import org.eclipse.draw2d.ColorConstants;

import org.eclipse.draw2d.Figure;

import org.eclipse.draw2d.FigureCanvas;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gef.EditPart;

import org.eclipse.gef.EditPartViewer;

import org.eclipse.gef.GraphicalEditPart;

import org.eclipse.gef.GraphicalViewer;

import org.eclipse.gef.KeyHandler;

import org.eclipse.gef.LayerConstants;

import org.eclipse.gef.Request;

import org.eclipse.gef.RequestConstants;

import org.eclipse.gef.SharedCursors;

import org.eclipse.gef.editparts.LayerManager;

import org.eclipse.gef.tools.AbstractTool;

import org.eclipse.jface.viewers.StructuredSelection;

import org.eclipse.swt.events.KeyEvent;

import org.eclipse.swt.widgets.Display;

import org.eclipse.gmf.runtime.diagram.ui.editparts.GateEditPart;

import org.eclipse.gmf.runtime.diagram.ui.util.SelectInDiagramHelper;

public class RubberbandSelectionTool extends AbstractTool {
    static final int TOGGLE_MODE = 1;
    static final int APPEND_MODE = 2;
    private int mode;
    private Figure marqueeRectangleFigure;
    private HashSet allChildren = new HashSet ();
    private List selectedEditParts;
    private Request targetRequest;
    private Point feedBackStartLocation = null;
    private WeakReference weakReference;
    private static final Request MARQUEE_REQUEST = new Request (RequestConstants.REQ_SELECTION);

    public RubberbandSelectionTool () {
        setDefaultCursor (SharedCursors.CROSS);
        setUnloadWhenFinished (false);
    }

    private List calculateNewSelection () {
        List newSelections = new ArrayList ();
        Iterator children = getAllChildren ().iterator ();
        while (children.hasNext ()) {
            EditPart child = (EditPart) children.next ();
            if (! child.isSelectable ()) continue;

            IFigure figure = ((GraphicalEditPart) child).getFigure ();
            Rectangle r = figure.getBounds ().getCopy ();
            figure.translateToAbsolute (r);
            Rectangle marqueeBounds = getMarqueeBounds ();
            getMarqueeFeedbackFigure ().translateToRelative (r);
            if (marqueeBounds.contains (r.getTopLeft ()) && marqueeBounds.contains (r.getBottomRight ()) && child.getTargetEditPart (MARQUEE_REQUEST) == child) {
                newSelections.add (child);
            }
        }
        return newSelections;
    }

    private Request createTargetRequest () {
        return MARQUEE_REQUEST;
    }

    public void deactivate () {
        if (isInState (STATE_DRAG_IN_PROGRESS)) {
            eraseMarqueeFeedback ();
            eraseTargetFeedback ();
        }
        super.deactivate ();
        allChildren = new HashSet ();
        setState (STATE_TERMINAL);
    }

    private void eraseMarqueeFeedback () {
        if (marqueeRectangleFigure != null) {
            removeFeedback (marqueeRectangleFigure);
            marqueeRectangleFigure = null;
        }
        feedBackStartLocation = null;
    }

    private void eraseTargetFeedback () {
        if (selectedEditParts == null) return;

        ListIterator oldEditParts = selectedEditParts.listIterator ();
        while (oldEditParts.hasNext ()) {
            EditPart editPart = (EditPart) oldEditParts.next ();
            editPart.eraseTargetFeedback (getTargetRequest ());
        }
    }

    private HashSet getAllChildren (EditPart editPart, HashSet allChildren1) {
        List children = editPart.getChildren ();
        for (int i = 0;
        i < children.size (); i ++) {
            GraphicalEditPart child = (GraphicalEditPart) children.get (i);
            if (! (child instanceof GateEditPart)) {
                allChildren1.add (child);
                getAllChildren (child, allChildren1);
            }
            allChildren1.addAll (child.getSourceConnections ());
            allChildren1.addAll (child.getTargetConnections ());
        }
        return allChildren1;
    }

    private HashSet getAllChildren () {
        if (allChildren.isEmpty ()) allChildren = getAllChildren (getCurrentViewer ().getRootEditPart (), new HashSet ());

        return allChildren;
    }

    protected String getCommandName () {
        return REQ_SELECTION;
    }

    protected String getDebugName () {
        return "Marquee Tool";
    }

    protected IFigure getMarqueeFeedbackFigure () {
        if (marqueeRectangleFigure == null) {
            marqueeRectangleFigure = new MarqueeRectangleFigure ();
            addFeedback (marqueeRectangleFigure);
        }
        return marqueeRectangleFigure;
    }

    protected Rectangle getMarqueeSelectionRectangle () {
        return new Rectangle (getStartLocation (), getLocation ());
    }

    private Rectangle getMarqueeBounds () {
        if (getMarqueeFeedbackFigure () == null) return new Rectangle ();

        Rectangle rect = new Rectangle ();
        if (feedBackStartLocation == null) {
            rect = getMarqueeSelectionRectangle ();
            getMarqueeFeedbackFigure ().translateToRelative (rect);
            feedBackStartLocation = rect.getLocation ();
            return rect;
        } else {
            Point location = getLocation ().getCopy ();
            getMarqueeFeedbackFigure ().translateToRelative (location);
            rect = new Rectangle (feedBackStartLocation, location);
            return rect;
        }
    }

    private int getSelectionMode () {
        return mode;
    }

    private Request getTargetRequest () {
        if (targetRequest == null) targetRequest = createTargetRequest ();

        return targetRequest;
    }

    protected boolean handleButtonDown (int button) {
        if (! isGraphicalViewer ()) return true;

        if (button != 1) {
            setState (STATE_INVALID);
            handleInvalidInput ();
        }
        if (stateTransition (STATE_INITIAL, STATE_DRAG_IN_PROGRESS)) {
            if (getCurrentInput ().isControlKeyDown ()) setSelectionMode (TOGGLE_MODE);
            else if (getCurrentInput ().isShiftKeyDown ()) setSelectionMode (APPEND_MODE);

            clearFocus ();
        }
        return true;
    }

    private void clearFocus () {
        EditPart focusPart = getCurrentViewer ().getFocusEditPart ();
        if (focusPart != null) {
            getCurrentViewer ().setFocus (getCurrentViewer ().getRootEditPart ());
        }
    }

    protected void handleFinished () {
        getCurrentViewer ().setFocus (null);
        super.handleFinished ();
    }

    protected boolean handleButtonUp (int button) {
        if (stateTransition (STATE_DRAG_IN_PROGRESS, STATE_TERMINAL)) {
            eraseTargetFeedback ();
            performMarqueeSelect ();
            eraseMarqueeFeedback ();
        }
        handleFinished ();
        return true;
    }

    protected boolean handleDragInProgress () {
        if (isInState (STATE_DRAG | STATE_DRAG_IN_PROGRESS)) {
            showMarqueeFeedback ();
            eraseTargetFeedback ();
            selectedEditParts = calculateNewSelection ();
            showTargetFeedback ();
            SelectInDiagramHelper.exposeLocation ((FigureCanvas) getCurrentViewer ().getControl (), getLocation ());
        }
        return true;
    }

    protected boolean handleFocusLost () {
        if (isInState (STATE_DRAG | STATE_DRAG_IN_PROGRESS)) {
            handleFinished ();
            return true;
        }
        return false;
    }

    protected boolean handleInvalidInput () {
        eraseTargetFeedback ();
        eraseMarqueeFeedback ();
        return true;
    }

    protected boolean handleKeyDown (KeyEvent e) {
        if (super.handleKeyDown (e)) return true;

        if (getCurrentViewer ().getKeyHandler () != null && getCurrentViewer ().getKeyHandler ().keyPressed (e)) return true;

        return false;
    }

    private boolean isGraphicalViewer () {
        return getCurrentViewer () instanceof GraphicalViewer;
    }

    protected void performMarqueeSelect () {
        EditPartViewer viewer = getCurrentViewer ();
        List newSelections = calculateNewSelection ();
        if (getSelectionMode () == APPEND_MODE) {
            for (int i = 0;
            i < newSelections.size (); i ++) {
                EditPart editPart = (EditPart) newSelections.get (i);
                viewer.appendSelection (editPart);
            }
        } else if (getSelectionMode () == TOGGLE_MODE) {
            List selected = new ArrayList (viewer.getSelectedEditParts ());
            for (int i = 0;
            i < newSelections.size (); i ++) {
                EditPart editPart = (EditPart) newSelections.get (i);
                if (editPart.getSelected () != EditPart.SELECTED_NONE) selected.remove (editPart);
                else selected.add (editPart);

            }
            viewer.setSelection (new StructuredSelection (selected));
        } else {
            viewer.setSelection (new StructuredSelection (newSelections));
        }

    }

    public void setViewer (EditPartViewer viewer) {
        if (viewer == getCurrentViewer ()) return;

        super.setViewer (viewer);
        if (viewer instanceof GraphicalViewer) setDefaultCursor (SharedCursors.CROSS);
        else setDefaultCursor (SharedCursors.NO);

        if (viewer != null) weakReference = new WeakReference (viewer);

    }

    private void setSelectionMode (int mode) {
        this.mode = mode;
    }

    private void showMarqueeFeedback () {
        getMarqueeFeedbackFigure ().setBounds (getMarqueeBounds ());
    }

    private void showTargetFeedback () {
        for (int i = 0;
        i < selectedEditParts.size (); i ++) {
            EditPart editPart = (EditPart) selectedEditParts.get (i);
            editPart.showTargetFeedback (getTargetRequest ());
        }
    }

    protected void removeFeedback (IFigure figure) {
        EditPartViewer viewer = getCurrentViewer ();
        if ((viewer == null) && (weakReference != null)) viewer = (EditPartViewer) weakReference.get ();

        if (viewer != null) {
            LayerManager lm = (LayerManager) viewer.getEditPartRegistry ().get (LayerManager.ID);
            if (lm == null) return;

            lm.getLayer (LayerConstants.FEEDBACK_LAYER).remove (figure);
        }
    }

    class MarqueeRectangleFigure extends Figure {
        private int offset = 0;
        private boolean schedulePaint = true;
        private static final int DELAY = 110;

        protected void paintFigure (Graphics graphics) {
            Rectangle bounds1 = getBounds ().getCopy ();
            graphics.translate (getLocation ());
            graphics.setXORMode (true);
            graphics.setForegroundColor (ColorConstants.white);
            graphics.setBackgroundColor (ColorConstants.black);
            graphics.setLineStyle (Graphics.LINE_DOT);
            int [] points = new int [6];
            points [0] = 0 + offset;
            points [1] = 0;
            points [2] = bounds1.width - 1;
            points [3] = 0;
            points [4] = bounds1.width - 1;
            points [5] = bounds1.height - 1;
            graphics.drawPolyline (points);
            points [0] = 0;
            points [1] = 0 + offset;
            points [2] = 0;
            points [3] = bounds1.height - 1;
            points [4] = bounds1.width - 1;
            points [5] = bounds1.height - 1;
            graphics.drawPolyline (points);
            graphics.translate (getLocation ().getNegated ());
            if (schedulePaint) {
                Display.getCurrent ().timerExec (DELAY, new Runnable () {

                    public void run () {
                        offset ++;
                        if (offset > 5) offset = 0;

                        schedulePaint = true;
                        repaint ();
                    }

                }

                );
            }
            schedulePaint = false;
        }

    }

}

