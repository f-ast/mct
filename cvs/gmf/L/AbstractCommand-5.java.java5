package org.eclipse.gmf.runtime.common.core.command;

import java.util.ArrayList;

import java.util.Collection;

import java.util.List;

import org.eclipse.core.commands.ExecutionException;

import org.eclipse.core.commands.operations.AbstractOperation;

import org.eclipse.core.commands.operations.IOperationApprover;

import org.eclipse.core.commands.operations.IUndoContext;

import org.eclipse.core.commands.operations.IUndoableOperation;

import org.eclipse.core.commands.operations.OperationHistoryFactory;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.runtime.IAdaptable;

import org.eclipse.core.runtime.IProgressMonitor;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.NullProgressMonitor;

import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;

import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;

import org.eclipse.gmf.runtime.common.core.util.Log;

import org.eclipse.gmf.runtime.common.core.util.Trace;

public abstract class AbstractCommand extends AbstractOperation implements ICommand {
    private final List affectedFiles;
    private CommandResult commandResult;

    public AbstractCommand (String label) {
        this (label, null);
    }

    public AbstractCommand (String label, List affectedFiles) {
        super (label);
        if (affectedFiles == null) {
            this.affectedFiles = new ArrayList ();
        } else {
            this.affectedFiles = affectedFiles;
        }
    }

    public List getAffectedFiles () {
        return affectedFiles;
    }

    public CommandResult getCommandResult () {
        return commandResult;
    }

    protected final void setResult (CommandResult result) {
        this.commandResult = result;
    }

    public ICommand compose (IUndoableOperation operation) {
        if (operation != null) {
            return new CompositeCommand (getLabel ()).compose (this).compose (operation);
        }
        return this;
    }

    public ICommand reduce () {
        return this;
    }

    public IStatus execute (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
        CommandResult result = doExecuteWithResult (monitor, info);
        setResult (result);
        return result.getStatus ();
    }

    protected abstract CommandResult doExecuteWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException;

    public IStatus redo (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
        CommandResult result = doRedoWithResult (monitor, info);
        setResult (result);
        return result.getStatus ();
    }

    protected abstract CommandResult doRedoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException;

    public IStatus undo (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
        CommandResult result = doUndoWithResult (monitor, info);
        setResult (result);
        return result.getStatus ();
    }

    protected abstract CommandResult doUndoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException;

    public void dispose () {
        super.dispose ();
        IUndoContext [] contexts = getContexts ();
        for (int i = 0;
        i < contexts.length; i ++) {
            removeContext (contexts [i]);
        }
    }

    public Collection getAffectedObjects () {
        return getAffectedFiles ();
    }

    public CMValidator getValidator () {
        return null;
    }

    public boolean involvesReadOnlyNonWorkSpaceFiles () {
        return false;
    }

    public boolean isExecutable () {
        return canExecute ();
    }

    public boolean isRedoable () {
        return canRedo ();
    }

    public boolean isUndoable () {
        return canUndo ();
    }

    public void execute (IProgressMonitor progressMonitor) {
        try {
            execute (progressMonitor, null);
        } catch (ExecutionException e) {
            handle (e);
        }
    }

    public void redo () {
        try {
            redo (new NullProgressMonitor (), null);
        } catch (ExecutionException e) {
            handle (e);
        }
    }

    public void undo () {
        try {
            undo (new NullProgressMonitor (), null);
        } catch (ExecutionException e) {
            handle (e);
        }
    }

    protected void handle (Exception exception) {
        Trace.catching (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.EXCEPTIONS_CATCHING, getClass (), "handle", exception);
        setResult (CommandResult.newErrorCommandResult (exception));
        Log.log (CommonCorePlugin.getDefault (), getCommandResult ().getStatus ());
    }

}

