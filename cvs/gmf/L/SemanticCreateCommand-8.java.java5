package org.eclipse.gmf.runtime.diagram.ui.commands;

import java.util.Collection;

import java.util.List;

import org.eclipse.core.commands.ExecutionException;

import org.eclipse.core.commands.operations.IUndoContext;

import org.eclipse.core.runtime.IAdaptable;

import org.eclipse.core.runtime.IProgressMonitor;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.gef.commands.Command;

import org.eclipse.gmf.runtime.common.core.command.AbstractCommand;

import org.eclipse.gmf.runtime.common.core.command.CommandResult;

import org.eclipse.gmf.runtime.common.core.command.ICommand;

import org.eclipse.gmf.runtime.diagram.core.edithelpers.CreateElementRequestAdapter;

import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramCommandStack;

import org.eclipse.jface.util.Assert;

public class SemanticCreateCommand extends AbstractCommand {
    CreateElementRequestAdapter requestAdapter;
    private ICommand realSemanticCommand;

    public SemanticCreateCommand (CreateElementRequestAdapter requestAdapter, Command realSemanticCommand) {
        super (realSemanticCommand.getLabel (), null);
        Assert.isNotNull (requestAdapter);
        Assert.isNotNull (realSemanticCommand);
        this.requestAdapter = requestAdapter;
        this.realSemanticCommand = DiagramCommandStack.getICommand (realSemanticCommand);
        recomputeContexts ();
    }

    protected CommandResult doExecuteWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        realSemanticCommand.execute (progressMonitor, info);
        CommandResult result = realSemanticCommand.getCommandResult ();
        if (result.getStatus ().isOK ()) {
            Object object = result.getReturnValue ();
            if (object instanceof Collection) {
                Collection col = (Collection) object;
                object = col.isEmpty () ? null : col.iterator ().next ();
            }
            if (object != null) {
                Assert.isTrue (object instanceof EObject, "Failed to get an IElement out of the semantic command returned value");
                EObject element = (EObject) object;
                requestAdapter.setNewElement (element);
            }
            result = CommandResult.newOKCommandResult (requestAdapter);
        }
        recomputeContexts ();
        return result;
    }

    protected CommandResult doRedoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        realSemanticCommand.redo (progressMonitor, info);
        CommandResult result = realSemanticCommand.getCommandResult ();
        recomputeContexts ();
        return result;
    }

    protected CommandResult doUndoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
        realSemanticCommand.undo (progressMonitor, info);
        CommandResult result = realSemanticCommand.getCommandResult ();
        recomputeContexts ();
        return result;
    }

    public boolean canExecute () {
        return realSemanticCommand.canExecute ();
    }

    public boolean canUndo () {
        return realSemanticCommand.canUndo ();
    }

    public boolean canRedo () {
        return realSemanticCommand.canRedo ();
    }

    public List getAffectedFiles () {
        return realSemanticCommand.getAffectedFiles ();
    }

    private void recomputeContexts () {
        IUndoContext [] realContexts = realSemanticCommand.getContexts ();
        IUndoContext [] myContexts = getContexts ();
        for (int i = 0;
        i < myContexts.length; i ++) {
            removeContext (myContexts [i]);
        }
        for (int i = 0;
        i < realContexts.length; i ++) {
            addContext (realContexts [i]);
        }
    }

    public void addContext (IUndoContext context) {
        super.addContext (context);
        realSemanticCommand.addContext (context);
    }

    public void removeContext (IUndoContext context) {
        super.removeContext (context);
        realSemanticCommand.removeContext (context);
    }

    public void dispose () {
        super.dispose ();
        realSemanticCommand.dispose ();
    }

}

