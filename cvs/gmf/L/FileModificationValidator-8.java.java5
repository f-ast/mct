package org.eclipse.gmf.runtime.common.ui.resources;

import java.io.File;

import java.sql.Timestamp;

import java.util.HashMap;

import java.util.HashSet;

import java.util.Iterator;

import java.util.Map;

import java.util.Set;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.resources.IFileModificationValidator;

import org.eclipse.core.resources.IResource;

import org.eclipse.core.resources.IWorkspace;

import org.eclipse.core.resources.ResourcesPlugin;

import org.eclipse.core.runtime.IPath;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.Status;

import org.eclipse.gmf.runtime.common.ui.internal.CommonUIPlugin;

import org.eclipse.gmf.runtime.common.ui.internal.l10n.CommonUIMessages;

import org.eclipse.jface.dialogs.MessageDialog;

import org.eclipse.osgi.util.NLS;

import org.eclipse.swt.widgets.Shell;

import org.eclipse.team.core.RepositoryProvider;

import org.eclipse.ui.PlatformUI;

public class FileModificationValidator {
    private static FileModificationValidator INSTANCE = new FileModificationValidator ();

    public static FileModificationValidator getInstance () {
        return INSTANCE;
    }

    private FileModificationValidator () {
        super ();
    }

    public boolean okToEdit (final IFile [] files, final String modificationReason) {
        return okToEdit (files, modificationReason, null);
    }

    public boolean okToEdit (final IFile [] files, final String modificationReason, final Shell shell) {
        final IStatus fileStatus = validateEdit (files, shell);
        if (! fileStatus.isOK ()) {
            if (shell != null) {
                PlatformUI.getWorkbench ().getDisplay ().asyncExec (new Runnable () {

                    public void run () {
                        MessageDialog.openError (shell, NLS.bind (CommonUIMessages.FileModificationValidator_EditProblemDialogTitle, modificationReason), NLS.bind (CommonUIMessages.FileModificationValidator_EditProblemDialogMessage, modificationReason, fileStatus.getMessage ()));
                    }

                }

                );
            }
            return false;
        }
        return true;
    }

    public boolean okToSave (IFile file) {
        IStatus status = null;
        RepositoryProvider provider = RepositoryProvider.getProvider (file.getProject ());
        IFileModificationValidator validator = null;
        if (provider != null) {
            validator = provider.getFileModificationValidator ();
        }
        if (validator == null) {
            status = getDefaultStatus (file);
        } else {
            status = validator.validateSave (file);
        }
        if (status.isOK ()) {
            return true;
        } else {
            MessageDialog.openError (PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getShell (), CommonUIMessages.FileModificationValidator_SaveProblemDialogTitle, NLS.bind (CommonUIMessages.FileModificationValidator_SaveProblemDialogMessage, status.getMessage (), status.getMessage ()));
            return false;
        }
    }

    private IStatus getDefaultStatus (IFile file) {
        if (file.isReadOnly ()) {
            String message = NLS.bind (CommonUIMessages.FileModificationValidator_FileIsReadOnlyErrorMessage, file.getFullPath ().toString ());
            return new Status (Status.ERROR, CommonUIPlugin.getPluginId (), Status.ERROR, message, null);
        } else {
            return new Status (Status.OK, CommonUIPlugin.getPluginId (), Status.OK, CommonUIMessages.FileModificationValidator_OK, null);
        }
    }

    public IStatus validateEdit (IFile [] files, Object shell) {
        IStatus status = Status.OK_STATUS;
        if (files == null || files.length == 0) {
            return status;
        }
        Set < IFile > unsynchedFiles = new HashSet < IFile > ();
        Map < IFile, ModificationStamp > filesToModificationStamps = new HashMap < IFile, ModificationStamp > ();
        for (int i = 0;
        i < files.length; i ++) {
            IFile file = files [i];
            filesToModificationStamps.put (file, new ModificationStamp (file));
            boolean inSync = file.isSynchronized (IResource.DEPTH_ZERO);
            if (! inSync) {
                unsynchedFiles.add (file);
            }
        }
        if (! unsynchedFiles.isEmpty ()) {
            status = buildOutOfSyncStatus (unsynchedFiles);
        }
        if (status.isOK ()) {
            status = ResourcesPlugin.getWorkspace ().validateEdit (files, shell);
            for (Map.Entry < IFile, ModificationStamp > entry : filesToModificationStamps.entrySet ()) {
                IFile file = entry.getKey ();
                ModificationStamp stamp = entry.getValue ();
                if (stamp.hasFileChanged ()) {
                    unsynchedFiles.add (file);
                }
            }
            if (! unsynchedFiles.isEmpty ()) {
                status = buildOutOfSyncStatus (unsynchedFiles);
            }
        }
        return status;
    }

    private IStatus buildOutOfSyncStatus (Set < IFile > unsynchedFiles) {
        StringBuffer buf = new StringBuffer (CommonUIMessages.FileModificationValidator_OutOfSyncMessage);
        buf.append ("\n");
        for (Iterator < IFile > unsynched = unsynchedFiles.iterator ();
        unsynched.hasNext ();) {
            IFile file = unsynched.next ();
            buf.append (file.getFullPath ().toString ());
            buf.append ("\n");
        }
        return new Status (IStatus.ERROR, CommonUIPlugin.getPluginId (), 0, buf.toString (), null);
    }

    private static class ModificationStamp {
        private IFile file;
        private Timestamp lastModified = null;
        private long fileLength = 0L;

        public ModificationStamp (IFile file) {
            assert file != null;
            this.file = file;
            IPath path = file.getLocation ();
            if (path != null) {
                File ioFile = path.toFile ();
                if (ioFile != null) {
                    lastModified = new Timestamp (ioFile.lastModified ());
                    lastModified.setNanos (0);
                    fileLength = ioFile.length ();
                } else {
                    lastModified = new Timestamp (file.getModificationStamp ());
                    lastModified.setNanos (0);
                }
            } else {
                lastModified = new Timestamp (file.getModificationStamp ());
                lastModified.setNanos (0);
            }
        }

        public Timestamp getLastModified () {
            return lastModified;
        }

        public long getFileLength () {
            return fileLength;
        }

        public IFile getFile () {
            return file;
        }

        public boolean equals (Object obj) {
            if (this == obj) {
                return true;
            } else if (obj instanceof ModificationStamp) {
                ModificationStamp stamp = (ModificationStamp) obj;
                return file.equals (stamp.getFile ()) && fileLength == stamp.getFileLength () && lastModified.equals (stamp.getLastModified ());
            }

            return false;
        }

        public int hashCode () {
            return file.hashCode () + lastModified.hashCode () + (int) (fileLength ^ (fileLength>>> 32));
        }

        public boolean hasFileChanged () {
            IPath path = file.getLocation ();
            if (path == null) {
                return false;
            }
            File ioFile = path.toFile ();
            if (ioFile == null) {
                return false;
            }
            Timestamp newTimestamp = new Timestamp (ioFile.lastModified ());
            newTimestamp.setNanos (0);
            return ! (lastModified.getTime () == newTimestamp.getTime () && fileLength == ioFile.length ());
        }

    }

}

