package org.eclipse.gmf.runtime.draw2d.ui.figures;

import java.lang.ref.WeakReference;

import java.util.ArrayList;

import java.util.Map;

import java.util.WeakHashMap;

import org.eclipse.draw2d.ColorConstants;

import org.eclipse.draw2d.Figure;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Insets;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.draw2d.text.FlowContext;

import org.eclipse.draw2d.text.FlowPage;

import org.eclipse.draw2d.text.ParagraphTextLayout;

import org.eclipse.draw2d.text.TextFlow;

import org.eclipse.draw2d.text.TextLayout;

import org.eclipse.gmf.runtime.draw2d.ui.internal.mapmode.IMapModeHolder;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.gmf.runtime.draw2d.ui.text.TextFlowEx;

import org.eclipse.gmf.runtime.draw2d.ui.text.TextUtilitiesEx;

import org.eclipse.gmf.runtime.draw2d.ui.text.TruncatedSingleLineTextLayout;

import org.eclipse.swt.graphics.Font;

import org.eclipse.swt.graphics.Image;

public class WrappingLabel extends Figure implements PositionConstants {
    static final String ELLIPSIS = "...";
    private static final Dimension EMPTY_DIMENSION = new Dimension (0, 0);
    private static final Map < IMapMode, MapModeConstants > mapModeConstantsMap = new WeakHashMap < IMapMode, MapModeConstants > ();
    static class MapModeConstants {
        private static final int MAX_IMAGE_INFO = 12;
        public final WeakReference < IMapMode > mapModeRef;
        public final int nDPtoLP_3;
        public final int nDPtoLP_2;
        public final int nDPtoLP_0;
        public final Dimension dimension_nDPtoLP_0;
        public final WeakHashMap < Font, Dimension > fontToEllipseTextSize = new WeakHashMap < Font, Dimension > ();
        public final SingleIconInfo [] singleIconInfos = new SingleIconInfo [MAX_IMAGE_INFO];

        public MapModeConstants (IMapMode mapMode) {
            this.mapModeRef = new WeakReference < IMapMode > (mapMode);
            nDPtoLP_2 = mapMode.DPtoLP (2);
            nDPtoLP_3 = mapMode.DPtoLP (3);
            nDPtoLP_0 = mapMode.DPtoLP (0);
            dimension_nDPtoLP_0 = new Dimension (nDPtoLP_0, nDPtoLP_0);
        }

        public Dimension getEllipseTextSize (Font f) {
            Dimension d = fontToEllipseTextSize.get (f);
            if (d == null) {
                IMapMode mapMode = mapModeRef.get ();
                d = FigureUtilities.getTextExtents (ELLIPSIS, f);
                d.height = FigureUtilities.getFontMetrics (f).getHeight ();
                d = new Dimension (mapMode.DPtoLP (d.width), mapMode.DPtoLP (d.height));
                fontToEllipseTextSize.put (f, d);
            }
            return d;
        }

        public SingleIconInfo getSingleIconInfo (Image image) {
            if (image == null) {
                return SingleIconInfo.NULL_INFO;
            }
            SingleIconInfo info;
            for (int i = 0;
            i < MAX_IMAGE_INFO; ++ i) {
                info = singleIconInfos [i];
                if (info == null) {
                    info = new SingleIconInfo (image);
                    singleIconInfos [i] = info;
                    return info;
                }
                if (info.icon == image) {
                    return info;
                }
            }
            int index = SingleIconInfo.count % MAX_IMAGE_INFO;
            info = new SingleIconInfo (image);
            singleIconInfos [index] = info;
            return info;
        }

    }

    private static int FLAG_SELECTED = Figure.MAX_FLAG << 1;
    private static int FLAG_HASFOCUS = Figure.MAX_FLAG << 2;
    private static int FLAG_TEXT_ALIGN = Figure.MAX_FLAG << 3;
    private static int FLAG_ICON_ALIGN = Figure.MAX_FLAG << 7;
    private static int FLAG_LABEL_ALIGN = Figure.MAX_FLAG << 11;
    private static int FLAG_TEXT_PLACEMENT = Figure.MAX_FLAG << 15;
    @SuppressWarnings("hiding")
    protected static final int MAX_FLAG = FLAG_TEXT_PLACEMENT;
    private static abstract class IconInfo {

        public abstract Image getIcon (int i);

        public abstract Dimension getIconSize (IMapMode mapMode, int i);

        public abstract int getNumberofIcons ();

        public abstract Dimension getTotalIconSize (IMapMode mapMode);

        public abstract void invalidate ();

        public abstract void setIcon (Image icon, int i);

        public abstract int getMaxIcons ();

    }

    private static class SingleIconInfo extends IconInfo {
        static int count;
        public static final SingleIconInfo NULL_INFO = new SingleIconInfo () {

            public int getNumberofIcons () {
                return 0;
            }

        }

        ;
        final Image icon;
        private Dimension totalIconSize;

        private SingleIconInfo () {
            icon = null;
        }

        public SingleIconInfo (Image icon) {
            this.icon = icon;
            ++ count;
        }

        public final int getMaxIcons () {
            return 1;
        }

        public Image getIcon (int i) {
            if (i == 0) {
                return icon;
            } else if (i > 0) {
                return null;
            }

            throw new IndexOutOfBoundsException ();
        }

        public void setIcon (Image img, int i) {
            throw new UnsupportedOperationException ();
        }

        public Dimension getIconSize (IMapMode mapMode, int i) {
            if (i == 0) {
                return getTotalIconSize (mapMode);
            }
            throw new IndexOutOfBoundsException ();
        }

        public int getNumberofIcons () {
            return 1;
        }

        public Dimension getTotalIconSize (IMapMode mapMode) {
            if (totalIconSize != null) return totalIconSize;

            if (icon != null && ! icon.isDisposed ()) {
                org.eclipse.swt.graphics.Rectangle imgBounds = icon.getBounds ();
                totalIconSize = new Dimension (mapMode.DPtoLP (imgBounds.width), mapMode.DPtoLP (imgBounds.height));
            } else {
                totalIconSize = EMPTY_DIMENSION;
            }
            return totalIconSize;
        }

        public void invalidate () {
            totalIconSize = null;
        }

    }

    private static class MultiIconInfo extends IconInfo {
        private ArrayList < Image > icons = new ArrayList < Image > (2);
        private Dimension totalIconSize;

        public MultiIconInfo () {
            super ();
        }

        public int getMaxIcons () {
            return - 1;
        }

        public Image getIcon (int i) {
            if (i >= icons.size ()) return null;

            return icons.get (i);
        }

        public void setIcon (Image icon, int i) {
            int size = icons.size ();
            if (i >= size) {
                for (int j = size;
                j < i; j ++) icons.add (null);

                icons.add (icon);
                icons.trimToSize ();
            } else icons.set (i, icon);

        }

        public Dimension getIconSize (IMapMode mapMode, int i) {
            Image img = getIcon (i);
            if (img != null && ! img.isDisposed ()) {
                org.eclipse.swt.graphics.Rectangle imgBounds = img.getBounds ();
                return new Dimension (mapMode.DPtoLP (imgBounds.width), mapMode.DPtoLP (imgBounds.height));
            }
            return EMPTY_DIMENSION;
        }

        public int getNumberofIcons () {
            return icons.size ();
        }

        public Dimension getTotalIconSize (IMapMode mapMode) {
            if (totalIconSize != null) return totalIconSize;

            int iconNum = getNumberofIcons ();
            if (iconNum == 0) {
                return totalIconSize = EMPTY_DIMENSION;
            }
            totalIconSize = new Dimension ();
            for (int i = 0;
            i < iconNum; i ++) {
                Dimension iconSize = getIconSize (mapMode, i);
                totalIconSize.width += iconSize.width;
                if (iconSize.height > totalIconSize.height) totalIconSize.height = iconSize.height;

            }
            return totalIconSize;
        }

        public void invalidate () {
            totalIconSize = null;
        }

    }

    private MapModeConstants mapModeConstants;
    private FlowPage flowPage;
    protected Dimension preferredTextSize;
    private Dimension truncationStringSize;
    private IconInfo iconInfo;
    private int cachedPrefSizeHint_width;
    private int cachedPrefSizeHint_height;
    private Point iconLocation;

    public WrappingLabel () {
        createTextFigures ();
        setText ("");
        setAlignmentFlags (CENTER, FLAG_TEXT_ALIGN);
        setAlignmentFlags (CENTER, FLAG_ICON_ALIGN);
        setAlignmentFlags (TOP | LEFT, FLAG_LABEL_ALIGN);
        setPlacementFlags (EAST, FLAG_TEXT_PLACEMENT);
        setTextJustification (LEFT);
        revalidate ();
    }

    public WrappingLabel (String text) {
        this ();
        if (text != null) {
            setText (text);
        } else {
            setText ("");
        }
    }

    public WrappingLabel (Image image) {
        this ();
        iconInfo = new SingleIconInfo (image);
    }

    public WrappingLabel (String text, Image image) {
        this (text);
        iconInfo = new SingleIconInfo (image);
    }

    private void createTextFigures () {
        TextFlowEx textFlow = new TextFlowEx ();
        flowPage = new FlowPage ();
        flowPage.add (textFlow);
        setLayoutManager (textFlow, false);
        add (flowPage);
    }

    public IFigure getTextFigure () {
        return flowPage;
    }

    private FlowPage getFlowPage () {
        return (FlowPage) getTextFigure ();
    }

    TextFlow getTextFlow () {
        return (TextFlow) flowPage.getChildren ().get (0);
    }

    IMapMode getFigureMapMode () {
        return getMapModeConstants ().mapModeRef.get ();
    }

    MapModeConstants getMapModeConstants () {
        if (mapModeConstants == null) {
            IMapMode mapMode = MapModeUtil.getMapMode (this);
            while (mapMode instanceof IMapModeHolder) {
                mapMode = ((IMapModeHolder) mapMode).getMapMode ();
            }
            mapModeConstants = mapModeConstantsMap.get (mapMode);
            if (mapModeConstants == null) {
                mapModeConstants = new MapModeConstants (mapMode);
                mapModeConstantsMap.put (mapMode, mapModeConstants);
            }
        }
        return mapModeConstants;
    }

    private void alignOnHeight (Rectangle area, Rectangle childBounds, int alignment) {
        switch (alignment) {
            case TOP :
                childBounds.y = area.y;
                childBounds.y = area.y;
                break;
            case BOTTOM :
                childBounds.y = area.getBottom ().y - childBounds.height;
                break;
            default :
                childBounds.y = area.y + (area.height - childBounds.height) / 2;
        }
    }

    private void alignOnWidth (Rectangle area, Rectangle childBounds, int alignment) {
        switch (alignment) {
            case LEFT :
                childBounds.x = area.x;
                break;
            case RIGHT :
                childBounds.x = area.getRight ().x - childBounds.width;
                break;
            default :
                childBounds.x = area.x + (area.width - childBounds.width) / 2;
        }
    }

    private void calculateAlignment (Rectangle textBounds, Rectangle iconBounds) {
        Rectangle areaUsed = textBounds.getUnion (iconBounds);
        areaUsed.x = getInsets ().left;
        areaUsed.y = getInsets ().top;
        switch (getTextPlacement ()) {
            case EAST :
            case WEST :
                alignOnHeight (areaUsed, textBounds, getTextAlignment ());
                alignOnHeight (areaUsed, iconBounds, getIconAlignment ());
                break;
            case NORTH :
            case SOUTH :
                alignOnWidth (areaUsed, textBounds, getTextAlignment ());
                alignOnWidth (areaUsed, iconBounds, getIconAlignment ());
                break;
        }
    }

    protected Dimension calculateLabelSize (Dimension txtSize) {
        Dimension iconSize = getTotalIconSize ();
        boolean isEmpty = (iconSize.width == 0 && iconSize.height == 0);
        int len = getText ().length ();
        if (len == 0 && isEmpty) {
            return new Dimension (txtSize.width, txtSize.height);
        }
        int gap = (len == 0 || isEmpty) ? 0 : getIconTextGap ();
        int placement = getTextPlacement ();
        if (placement == WEST || placement == EAST) {
            return new Dimension (iconSize.width + gap + txtSize.width, Math.max (iconSize.height, txtSize.height));
        } else {
            return new Dimension (Math.max (iconSize.width, txtSize.width), iconSize.height + gap + txtSize.height);
        }
    }

    public void layout () {
        Rectangle textBounds = new Rectangle ();
        Rectangle iconBounds = new Rectangle ();
        calculateSizes (textBounds, iconBounds);
        calculatePlacement (textBounds, iconBounds);
        calculateAlignment (textBounds, iconBounds);
        calculateLabelAlignment (textBounds, iconBounds);
        if (hasIcons ()) {
            setIconLocation (iconBounds.getLocation ());
        }
        getTextFigure ().setBounds (textBounds.getTranslated (getBounds ().getLocation ()));
    }

    private void calculateSizes (Rectangle textBounds, Rectangle iconBounds) {
        Rectangle area = getClientArea ();
        Dimension preferredSize = getPreferredSize (area.width, area.height);
        Dimension minimumSize = getMinimumSize (area.width, area.height);
        Dimension shrinkAmount = preferredSize.getDifference (getBounds ().getSize ().getUnioned (minimumSize));
        Dimension textSize = preferredTextSize.getCopy ();
        if (shrinkAmount.width > 0) {
            textSize.shrink (shrinkAmount.width, 0);
        }
        if (shrinkAmount.height > 0) {
            textSize.shrink (0, shrinkAmount.height);
        }
        if (getTextFlow ().isTextTruncated ()) {
            textBounds.setSize (textSize);
        } else {
            textBounds.setSize (getTextFlow ().getSize ().intersect (textSize));
        }
        iconBounds.setSize (getTotalIconSize ());
    }

    private void calculateLabelAlignment (Rectangle textBounds, Rectangle iconBounds) {
        Dimension offset = getClientArea ().getSize ().getDifference (textBounds.getUnion (iconBounds).getSize ());
        switch (getAlignment ()) {
            case TOP | LEFT :
                offset.height = 0;
                offset.width = 0;
                break;
            case TOP :
                offset.height = 0;
                offset.scale (0.5f);
                break;
            case TOP | RIGHT :
                offset.height = 0;
            case RIGHT :
                offset.width = offset.width * 2;
                offset.scale (0.5f);
                break;
            case BOTTOM | RIGHT :
                break;
            case BOTTOM :
                offset.height = offset.height * 2;
                offset.scale (0.5f);
                break;
            case BOTTOM | LEFT :
                offset.width = 0;
                break;
            case LEFT :
                offset.width = 0;
                offset.scale (0.5f);
                break;
            case CENTER :
                offset.scale (0.5f);
                break;
            default :
                offset.scale (0.5f);
                break;
        }
        textBounds.translate (offset.width, offset.height);
        iconBounds.translate (offset.width, offset.height);
    }

    private void calculatePlacement (Rectangle textBounds, Rectangle iconBounds) {
        int gap = (textBounds.isEmpty () || iconBounds.isEmpty ()) ? 0 : getIconTextGap ();
        Insets insets = getInsets ();
        switch (getTextPlacement ()) {
            case EAST :
                iconBounds.x = insets.left;
                textBounds.x = iconBounds.width + gap + insets.left;
                break;
            case WEST :
                textBounds.x = insets.left;
                iconBounds.x = textBounds.width + gap + insets.left;
                break;
            case NORTH :
                textBounds.y = insets.top;
                iconBounds.y = textBounds.height + gap + insets.top;
                break;
            case SOUTH :
                textBounds.y = iconBounds.height + gap + insets.top;
                iconBounds.y = insets.top;
        }
    }

    public Image getIcon () {
        return getIcon (0);
    }

    public Image getIcon (int index) {
        if (iconInfo == null) return null;

        return iconInfo.getIcon (index);
    }

    protected boolean hasIcons () {
        return (getNumberofIcons () > 0);
    }

    public int getIconAlignment () {
        return getAlignment (FLAG_ICON_ALIGN);
    }

    protected Point getIconLocation () {
        return iconLocation;
    }

    protected void setIconLocation (Point location) {
        iconLocation = location;
    }

    public int getIconTextGap () {
        return getMapModeConstants ().nDPtoLP_3;
    }

    public Dimension getMinimumSize (int w, int h) {
        if (minSize != null) return minSize;

        minSize = new Dimension ();
        Font currentFont = getFont ();
        Dimension ellipsisSize = getTruncationStringSize ();
        Dimension textSize = new TextUtilitiesEx (getFigureMapMode ()).getTextExtents (getText (), currentFont);
        textSize.intersect (ellipsisSize);
        Dimension labelSize = calculateLabelSize (textSize);
        Insets insets = getInsets ();
        labelSize.expand (insets.getWidth (), insets.getHeight ());
        minSize.union (labelSize);
        return minSize;
    }

    public Dimension getPreferredSize (int wHint, int hHint) {
        if (prefSize == null || wHint != cachedPrefSizeHint_width || hHint != cachedPrefSizeHint_height) {
            cachedPrefSizeHint_width = wHint;
            cachedPrefSizeHint_height = hHint;
            int minWHint = 0, minHHint = 0;
            if (wHint < 0) minWHint = - 1;

            if (hHint < 0) minHHint = - 1;

            if (hasIcons ()) {
                prefSize = getTotalIconSize ().getCopy ();
                switch (getTextPlacement ()) {
                    case EAST :
                    case WEST :
                        wHint = Math.max (minWHint, wHint - (prefSize.width + getIconTextGap ()));
                        preferredTextSize = getTextFigure ().getPreferredSize (wHint, hHint).getCopy ();
                        prefSize.width += preferredTextSize.width + getIconTextGap ();
                        prefSize.height = Math.max (prefSize.height, preferredTextSize.height);
                        break;
                    case NORTH :
                    case SOUTH :
                        hHint = Math.max (minHHint, hHint - (prefSize.height + getIconTextGap ()));
                        preferredTextSize = getTextFigure ().getPreferredSize (wHint, hHint).getCopy ();
                        prefSize.width = Math.max (prefSize.width, preferredTextSize.width);
                        prefSize.height += preferredTextSize.height + getIconTextGap ();
                        break;
                }
            } else {
                preferredTextSize = getTextFigure ().getPreferredSize (wHint, hHint).getCopy ();
                prefSize = preferredTextSize.getCopy ();
            }
            Insets insets = getInsets ();
            prefSize.expand (insets.getWidth (), insets.getHeight ());
        }
        return prefSize;
    }

    Dimension getTruncationStringSize () {
        if (truncationStringSize == null) {
            if (getTruncationString ().equals (ELLIPSIS)) {
                truncationStringSize = getMapModeConstants ().getEllipseTextSize (getFont ());
            } else {
                Font f = getFont ();
                IMapMode mapMode = getFigureMapMode ();
                truncationStringSize = FigureUtilities.getTextExtents (getTruncationString (), f);
                truncationStringSize.height = FigureUtilities.getFontMetrics (f).getHeight ();
                truncationStringSize = new Dimension (mapMode.DPtoLP (truncationStringSize.width), mapMode.DPtoLP (truncationStringSize.height));
            }
        }
        return truncationStringSize;
    }

    public String getText () {
        return getTextFlow ().getText ();
    }

    public int getTextAlignment () {
        return getAlignment (FLAG_TEXT_ALIGN);
    }

    public int getAlignment () {
        return getAlignment (FLAG_LABEL_ALIGN);
    }

    public Rectangle getTextBounds () {
        return new Rectangle (getFlowPage ().getBounds ().getLocation (), getTextFlow ().getBounds ().getSize ());
    }

    public int getTextPlacement () {
        return getPlacement (FLAG_TEXT_PLACEMENT);
    }

    public void invalidate () {
        prefSize = null;
        minSize = null;
        iconLocation = null;
        truncationStringSize = null;
        if (iconInfo != null) {
            iconInfo.invalidate ();
        }
        super.invalidate ();
    }

    public void paintFigure (Graphics graphics) {
        super.paintFigure (graphics);
        if (hasIcons ()) {
            paintIcons (graphics);
        }
    }

    protected void paintClientArea (Graphics graphics) {
        paintSelectionRectangle (graphics);
        paintFocusRectangle (graphics);
        super.paintClientArea (graphics);
    }

    private void paintSelectionRectangle (Graphics g) {
        if (isSelected ()) {
            g.pushState ();
            g.setBackgroundColor (ColorConstants.menuBackgroundSelected);
            g.fillRectangle (getVisibleTextBounds ());
            g.popState ();
            g.setForegroundColor (ColorConstants.white);
        }
    }

    private void paintFocusRectangle (Graphics g) {
        if (hasFocus ()) {
            g.pushState ();
            g.setXORMode (true);
            g.setForegroundColor (ColorConstants.menuBackgroundSelected);
            g.setBackgroundColor (ColorConstants.white);
            g.drawFocus (getVisibleTextBounds ());
            g.popState ();
        }
    }

    private Rectangle getVisibleTextBounds () {
        return getTextBounds ().getIntersection (getClientArea ());
    }

    private void paintIcons (Graphics graphics) {
        Point p = Point.SINGLETON;
        if (getIconLocation () != null) {
            p.setLocation (getIconLocation ());
            Rectangle figBounds = getBounds ();
            graphics.translate (figBounds.x, figBounds.y);
            int num = getNumberofIcons ();
            for (int i = 0;
            i < num; i ++) {
                Image icon = getIcon (i);
                if (icon != null) {
                    graphics.drawImage (icon, p);
                    p.x += getIconSize (i).width;
                }
            }
            graphics.translate (- figBounds.x, - figBounds.y);
        }
    }

    public void setIcon (Image image) {
        setIcon (image, 0);
    }

    public void setIcon (Image image, int index) {
        if (iconInfo == null) {
            if (index == 0) {
                iconInfo = getMapModeConstants ().getSingleIconInfo (image);
            } else {
                iconInfo = new MultiIconInfo ();
                iconInfo.setIcon (image, index);
            }
            revalidate ();
            repaint ();
        } else if (iconInfo.getIcon (index) != image) {
            if (iconInfo.getMaxIcons () == 1) {
                if (index == 0) {
                    iconInfo = getMapModeConstants ().getSingleIconInfo (image);
                    revalidate ();
                    repaint ();
                    return;
                }
                IconInfo oldIconInfo = iconInfo;
                iconInfo = new MultiIconInfo ();
                iconInfo.setIcon (oldIconInfo.getIcon (0), 0);
            }
            iconInfo.setIcon (image, index);
            revalidate ();
            repaint ();
        }

    }

    public void setIconAlignment (int alignment) {
        if (getIconAlignment () == alignment) return;

        setAlignmentFlags (alignment, FLAG_ICON_ALIGN);
        revalidate ();
        repaint ();
    }

    protected Dimension getIconSize (int index) {
        if (iconInfo == null) return EMPTY_DIMENSION;

        return iconInfo.getIconSize (getFigureMapMode (), index);
    }

    protected int getNumberofIcons () {
        if (iconInfo == null) return 0;

        return iconInfo.getNumberofIcons ();
    }

    protected Dimension getTotalIconSize () {
        if (iconInfo == null) return EMPTY_DIMENSION;

        return iconInfo.getTotalIconSize (getFigureMapMode ());
    }

    public void setAlignment (int alignment) {
        if (getAlignment () == alignment) return;

        setAlignmentFlags (alignment, FLAG_LABEL_ALIGN);
        revalidate ();
        repaint ();
    }

    protected String getTruncationString () {
        return ELLIPSIS;
    }

    public void setText (String text) {
        getTextFlow ().setText (text);
    }

    public void setTextAlignment (int alignment) {
        if (getTextAlignment () == alignment) return;

        setAlignmentFlags (alignment, FLAG_TEXT_ALIGN);
        revalidate ();
        repaint ();
    }

    public void setTextPlacement (int where) {
        if (getTextPlacement () == where) return;

        setPlacementFlags (where, FLAG_TEXT_PLACEMENT);
        revalidate ();
        repaint ();
    }

    public void setTextUnderline (boolean underline) {
        ((TextFlowEx) getTextFlow ()).setTextUnderline (underline);
    }

    public boolean isTextUnderlined () {
        return ((TextFlowEx) getTextFlow ()).isTextUnderlined ();
    }

    public void setTextStrikeThrough (boolean strikeThrough) {
        ((TextFlowEx) getTextFlow ()).setTextStrikeThrough (strikeThrough);
    }

    public boolean isTextStrikedThrough () {
        return ((TextFlowEx) getTextFlow ()).isTextStrikedThrough ();
    }

    public void setTextWrap (boolean textWrapOn) {
        if (textWrapOn != isTextWrapOn ()) {
            setLayoutManager (getTextFlow (), textWrapOn);
            revalidate ();
            repaint ();
        }
    }

    public boolean isTextWrapOn () {
        return getTextFlow ().getLayoutManager () instanceof ParagraphTextLayout;
    }

    public void setTextJustification (int justification) {
        getFlowPage ().setHorizontalAligment (justification);
    }

    public int getTextJustification () {
        return getFlowPage ().getHorizontalAligment ();
    }

    private void setPlacementFlags (int align, int flagOffset) {
        flags &= ~ (0x7 * flagOffset);
        switch (align) {
            case EAST :
                flags |= 0x1 * flagOffset;
                break;
            case WEST :
                flags |= 0x2 * flagOffset;
                break;
            case NORTH :
                flags |= 0x3 * flagOffset;
                break;
            case SOUTH :
                flags |= 0x4 * flagOffset;
                break;
        }
    }

    private int getPlacement (int flagOffset) {
        int wrapValue = flags & (0x7 * flagOffset);
        if (wrapValue == 0x1 * flagOffset) return EAST;
        else if (wrapValue == 0x2 * flagOffset) return WEST;
        else if (wrapValue == 0x3 * flagOffset) return NORTH;
        else if (wrapValue == 0x4 * flagOffset) return SOUTH;

        return EAST;
    }

    private void setAlignmentFlags (int alignment, int flagOffset) {
        flags &= ~ (0xF * flagOffset);
        switch (alignment) {
            case CENTER :
                flags |= 0x1 * flagOffset;
                break;
            case TOP :
                flags |= 0x2 * flagOffset;
                break;
            case LEFT :
                flags |= 0x3 * flagOffset;
                break;
            case RIGHT :
                flags |= 0x4 * flagOffset;
                break;
            case BOTTOM :
                flags |= 0x5 * flagOffset;
                break;
            case TOP | LEFT :
                flags |= 0x6 * flagOffset;
                break;
            case TOP | RIGHT :
                flags |= 0x7 * flagOffset;
                break;
            case BOTTOM | LEFT :
                flags |= 0x8 * flagOffset;
                break;
            case BOTTOM | RIGHT :
                flags |= 0x9 * flagOffset;
                break;
        }
    }

    private int getAlignment (int flagOffset) {
        int wrapValue = flags & (0xF * flagOffset);
        if (wrapValue == 0x1 * flagOffset) return CENTER;
        else if (wrapValue == 0x2 * flagOffset) return TOP;
        else if (wrapValue == 0x3 * flagOffset) return LEFT;
        else if (wrapValue == 0x4 * flagOffset) return RIGHT;
        else if (wrapValue == 0x5 * flagOffset) return BOTTOM;
        else if (wrapValue == 0x6 * flagOffset) return TOP | LEFT;
        else if (wrapValue == 0x7 * flagOffset) return TOP | RIGHT;
        else if (wrapValue == 0x8 * flagOffset) return BOTTOM | LEFT;
        else if (wrapValue == 0x9 * flagOffset) return BOTTOM | RIGHT;

        return CENTER;
    }

    public boolean hasFocus () {
        return (flags & FLAG_HASFOCUS) != 0;
    }

    public void setFocus (boolean focus) {
        if (hasFocus () == focus) return;

        setFlag (FLAG_HASFOCUS, focus);
        repaint ();
    }

    public boolean isSelected () {
        return (flags & FLAG_SELECTED) != 0;
    }

    public void setSelected (boolean selected) {
        if (isSelected () == selected) return;

        setFlag (FLAG_SELECTED, selected);
        repaint ();
    }

    public void setFont (Font f) {
        super.setFont (f);
        getTextFlow ().setFont (f);
    }

    private void setLayoutManager (TextFlow textFlow, boolean wrappingOn) {
        TextLayout layout;
        if (wrappingOn) {
            layout = new ParagraphTextLayout (textFlow, ParagraphTextLayout.WORD_WRAP_SOFT);
        } else {
            layout = new TruncatedSingleLineTextLayout ((TextFlowEx) textFlow, getTruncationString ());
        }
        layout.setFlowContext ((FlowContext) ((FlowPage) textFlow.getParent ()).getLayoutManager ());
        textFlow.setLayoutManager (layout);
    }

    public String toString () {
        return getText ();
    }

    public boolean isTextTruncated () {
        return getTextFlow ().isTextTruncated ();
    }

}

