package org.eclipse.gmf.internal.common.reconcile;

import java.util.Collection;

import java.util.Iterator;

import java.util.LinkedHashSet;

import java.util.LinkedList;

import java.util.List;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.resource.Resource;

public class Reconciler {
    private final ReconcilerConfig myConfig;
    private final MatchingSession myMatchingSession;

    public Reconciler (ReconcilerConfig config) {
        myConfig = config;
        myMatchingSession = new MatchingSession ();
    }

    protected void handleNotMatchedCurrent (EObject current) {
    }

    protected EObject handleNotMatchedOld (EObject currentParent, EObject notMatchedOld) {
        Copier copier = myConfig.getCopier (notMatchedOld.eClass ());
        return copier.copyToCurrent (currentParent, notMatchedOld);
    }

    public void reconcileResource (Resource current, Resource old) {
        reconcileContents (null, current.getContents (), old.getContents ());
    }

    public void reconcileTree (EObject currentRoot, EObject oldRoot) {
        reconcileVertex (currentRoot, oldRoot);
        reconcileContents (currentRoot, currentRoot.eContents (), oldRoot.eContents ());
    }

    private void reconcileVertex (EObject current, EObject old) {
        assert current.eClass ().equals (old.eClass ());
        DecisionMaker [] decisionMakers = myConfig.getDecisionMakers (current.eClass ());
        for (int i = 0;
        i < decisionMakers.length; i ++) {
            DecisionMaker next = decisionMakers [i];
            Decision decision = next.makeDecision (current, old);
            decision.apply (current, old, next.getFeature ());
        }
    }

    private void reconcileContents (EObject currentParent, Collection < EObject > allCurrents, Collection < EObject > allOlds) {
        if (allCurrents.isEmpty () && allOlds.isEmpty ()) {
            return;
        }
        final List < Pair > storage = new LinkedList < Pair > ();
        myMatchingSession.match (allCurrents, allOlds, storage);
        for (Pair next : storage) {
            EObject nextCurrent = next.current;
            EObject nextOld = next.old;
            assert (nextCurrent != null || nextOld != null);
            if (nextCurrent == null) {
                if (currentParent != null) {
                    nextCurrent = handleNotMatchedOld (currentParent, nextOld);
                }
            }
            if (nextCurrent != null && nextOld != null) {
                reconcileTree (nextCurrent, nextOld);
            } else if (nextOld == null) {
                handleNotMatchedCurrent (nextCurrent);
            }

        }
    }

    private static class Pair {
        public EObject current;
        public EObject old;
    }

    private class MatchingSession {
        private boolean myIsMatching;

        public MatchingSession () {
        }

        public void match (Collection < EObject > currents, Collection < EObject > olds, Collection < Pair > output) {
            assert ! myIsMatching;
            if (myIsMatching) {
                throw new IllegalStateException ("FIXME: remove me");
            }
            final Collection < EObject > myOlds;
            final Collection < EObject > myCurrents;
            try {
                myIsMatching = true;
                myOlds = new LinkedHashSet < EObject > (olds);
                myCurrents = new LinkedList < EObject > (currents);
                for (Iterator < EObject > currentContents = myCurrents.iterator ();
                ! myOlds.isEmpty () && currentContents.hasNext ();) {
                    EObject nextCurrent = currentContents.next ();
                    Pair nextPair = acquirePair ();
                    nextPair.current = nextCurrent;
                    nextPair.old = removeMatched (nextCurrent, myOlds);
                    output.add (nextPair);
                    currentContents.remove ();
                }
                for (Iterator < EObject > notMatchedOlds = myOlds.iterator ();
                notMatchedOlds.hasNext ();) {
                    Pair nextPair = acquirePair ();
                    nextPair.current = null;
                    nextPair.old = notMatchedOlds.next ();
                    output.add (nextPair);
                }
            } finally {
                myIsMatching = false;
            }
        }

        private EObject removeMatched (EObject current, Collection < EObject > allOld) {
            EClass eClass = current.eClass ();
            Matcher matcher = myConfig.getMatcher (eClass);
            EObject result = null;
            if (matcher != Matcher.FALSE) {
                for (Iterator < EObject > all = allOld.iterator ();
                all.hasNext ();) {
                    EObject next = all.next ();
                    if (eClass.equals (next.eClass ()) && matcher.match (current, next)) {
                        result = next;
                        all.remove ();
                        break;
                    }
                }
            }
            return result;
        }

        private Pair acquirePair () {
            return new Pair ();
        }

    }

}

