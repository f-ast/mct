package org.eclipse.gmf.runtime.diagram.ui.figures;

import java.util.ArrayList;

import java.util.List;

import java.util.ListIterator;

import java.util.Map;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

public class LayoutHelper {

    public LayoutHelper () {
    }

    public static final Rectangle UNDEFINED = new Rectangle (- 1, - 1, - 1, - 1);

    public void layoutUndefinedChildren (ICanonicalShapeCompartmentLayout mgr, IFigure parent, Map registry) {
        List children = getUnpositionedChildren (parent);
        if (! children.isEmpty ()) {
            for (int i = 0;
            i < children.size (); i ++) {
                IFigure child = (IFigure) children.get (i);
                Point loc = getReferencePosition (parent);
                loc = validatePosition (parent, new Rectangle (loc, child.getSize ()));
                child.setLocation (loc);
                parent.getLayoutManager ().setConstraint (child, child.getBounds ());
            }
        }
    }

    public final List getUnpositionedChildren (IFigure parent) {
        List children = parent.getChildren ();
        List retval = new ArrayList ();
        for (int i = 0;
        i < children.size (); i ++) {
            IFigure child = (IFigure) children.get (i);
            if (UNDEFINED.getLocation ().equals (child.getBounds ().getLocation ())) {
                retval.add (child);
            }
        }
        return retval;
    }

    public Point getReferencePosition (IFigure parent) {
        return parent.getBounds ().getCenter ().getCopy ();
    }

    public Point validatePosition (IFigure parent, Rectangle bounds) {
        Rectangle theBounds = bounds.getCopy ();
        IFigure clobber = findFigureIn (parent, bounds);
        if (clobber != null) {
            theBounds.setLocation (updateClobberedPosition (clobber, null));
            return validatePosition (parent, theBounds);
        }
        return theBounds.getLocation ();
    }

    public IFigure findFigureIn (IFigure parent, Rectangle bounds) {
        ListIterator listIterator = parent.getChildren ().listIterator ();
        final boolean useContainCheck = UNDEFINED.getSize ().equals (bounds.getSize ());
        while (listIterator.hasNext ()) {
            IFigure child = (IFigure) listIterator.next ();
            Rectangle cBounds = child.getBounds ();
            if (UNDEFINED.getLocation ().equals (cBounds.getLocation ())) {
                continue;
            }
            if (useContainCheck) {
                if (cBounds.contains (bounds.getLocation ())) {
                    return child;
                }
            } else if (cBounds.intersects (bounds)) {
                return child;
            }

        }
        return null;
    }

    public Point updateClobberedPosition (IFigure clobbered, IFigure newlyAddedChild) {
        return clobbered.getBounds ().getRight ().getCopy ().translate (MapModeUtil.getMapMode (newlyAddedChild).DPtoLP (30), 0);
    }

}

