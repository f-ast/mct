package org.eclipse.gmf.runtime.gef.ui.figures;

import org.eclipse.draw2d.AbstractConnectionAnchor;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.PrecisionPoint;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gef.handles.HandleBounds;

import org.eclipse.gmf.runtime.common.core.util.StringStatics;

import org.eclipse.gmf.runtime.draw2d.ui.figures.IPolygonAnchorableFigure;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

public class SlidableAnchor extends AbstractConnectionAnchor {
    final private static char TERMINAL_START_CHAR = '(';
    final private static char TERMINAL_DELIMITER_CHAR = ',';
    final private static char TERMINAL_END_CHAR = ')';
    private PrecisionPoint relativeReference;

    public SlidableAnchor () {
    }

    public SlidableAnchor (IFigure f) {
        super (f);
    }

    public SlidableAnchor (IFigure f, PrecisionPoint p) {
        super (f);
        this.relativeReference = new PrecisionPoint (p.preciseX, p.preciseY);
    }

    public String getTerminal () {
        if (isDefaultAnchor ()) return StringStatics.BLANK;

        return composeTerminalString (relativeReference);
    }

    public Point getReferencePoint () {
        Point p = new Point ();
        if (getOwner () instanceof NodeFigure) {
            p = getAnchorPosition ();
        }
        return p;
    }

    public static String composeTerminalString (PrecisionPoint p) {
        StringBuffer s = new StringBuffer (24);
        s.append (TERMINAL_START_CHAR);
        s.append ((float) p.preciseX);
        s.append (TERMINAL_DELIMITER_CHAR);
        s.append ((float) p.preciseY);
        s.append (TERMINAL_END_CHAR);
        return s.toString ();
    }

    private Point getAnchorPosition () {
        Rectangle rBox = getBox ();
        if (isDefaultAnchor ()) return rBox.getCenter ();

        return new Point (Math.round (relativeReference.preciseX * rBox.width + rBox.x), Math.round (relativeReference.preciseY * rBox.height + rBox.y));
    }

    protected Point getLocation (Point ownReference, Point foreignReference) {
        PointList intersections = getIntersectionPoints (ownReference, foreignReference);
        if (intersections != null && intersections.size () != 0) {
            Point location = PointListUtilities.pickClosestPoint (intersections, foreignReference);
            return location;
        }
        return null;
    }

    static private int STRAIGHT_LINE_TOLERANCE = 10;

    public Point getLocation (Point reference) {
        Point foreignReference = reference.getCopy ();
        Point ownReference = getReferencePoint ().getCopy ();
        ownReference = normalizeToStraightlineTolerance (foreignReference, ownReference, STRAIGHT_LINE_TOLERANCE);
        Point location = getLocation (ownReference, foreignReference);
        if (location == null) location = getLocation (getBox ().getCenter (), foreignReference);

        if (location == null) {
            location = getBox ().getCenter ();
        }
        return location;
    }

    protected Point normalizeToStraightlineTolerance (Point foreignReference, Point ownReference, int tolerance) {
        Point normalizedReference = ownReference.getCopy ();
        if (Math.abs (foreignReference.x - ownReference.x) < tolerance || Math.abs (foreignReference.y - ownReference.y) < tolerance) {
            LineSeg lineSeg = new LineSeg (ownReference, foreignReference);
            normalizedReference = lineSeg.perpIntersect (ownReference.x, ownReference.y);
            if (Math.abs (normalizedReference.x - foreignReference.x) < Math.abs (normalizedReference.y - foreignReference.y)) normalizedReference.x = foreignReference.x;
            else normalizedReference.y = foreignReference.y;

        }
        return normalizedReference;
    }

    protected PointList getIntersectionPoints (Point ownReference, Point foreignReference) {
        final PointList polygon = getPolygonPoints ();
        return (new LineSeg (ownReference, foreignReference)).getLineIntersectionsWithLineSegs (polygon);
    }

    protected PointList getPolygonPoints () {
        if (getOwner () instanceof IPolygonAnchorableFigure) {
            PointList polyList = ((IPolygonAnchorableFigure) getOwner ()).getPolygonPoints ();
            getOwner ().translateToAbsolute (polyList);
            return polyList;
        }
        Rectangle rBox = getBox ();
        PointList ptList = new PointList ();
        ptList.addPoint (rBox.getTopLeft ());
        ptList.addPoint (rBox.getTopRight ());
        ptList.addPoint (rBox.getBottomRight ());
        ptList.addPoint (rBox.getBottomLeft ());
        ptList.addPoint (rBox.getTopLeft ());
        return ptList;
    }

    protected Rectangle getBox () {
        Rectangle rBox = getOwner ().getBounds ().getCopy ();
        if (getOwner () instanceof HandleBounds) rBox = ((HandleBounds) getOwner ()).getHandleBounds ().getCopy ();

        getOwner ().translateToAbsolute (rBox);
        return rBox;
    }

    public boolean isDefaultAnchor () {
        return relativeReference == null;
    }

    public static PrecisionPoint parseTerminalString (String terminal) {
        try {
            return new PrecisionPoint (Float.parseFloat (terminal.substring (terminal.indexOf (SlidableAnchor.TERMINAL_START_CHAR) + 1, terminal.indexOf (SlidableAnchor.TERMINAL_DELIMITER_CHAR))), Float.parseFloat (terminal.substring (terminal.indexOf (SlidableAnchor.TERMINAL_DELIMITER_CHAR) + 1, terminal.indexOf (SlidableAnchor.TERMINAL_END_CHAR))));
        } catch (Exception e) {
            return null;
        }
    }

}

