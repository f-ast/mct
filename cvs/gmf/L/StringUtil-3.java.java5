package org.eclipse.gmf.runtime.common.core.util;

import java.io.UnsupportedEncodingException;

import java.net.URLEncoder;

import java.util.StringTokenizer;

import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;

import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;

import org.eclipse.gmf.runtime.common.core.internal.CommonCoreStatusCodes;

public class StringUtil {
    private static String delims = " !:;{}(),.?'\"\\\t\n\r";
    private static final String PROTOCOL_DELIMITER = "://";
    private static final int PROTOCOL_DELIMITER_LENGTH = PROTOCOL_DELIMITER.length ();
    private static final String URL_ENCODING = "UTF-8";
    private static final String ENCODED_PERCENT = "%25";

    private StringUtil () {
        super ();
    }

    private static String replaceFrom (String string, String source, String dest, boolean caseSensitive, int [] from) {
        if (source.compareTo (StringStatics.BLANK) == 0) return string;

        int stringLength = string.length (), sourceLength = source.length (), destLength = dest.length ();
        while (from [0] + sourceLength <= stringLength) {
            int compareResult;
            if (caseSensitive) compareResult = string.substring (from [0], from [0] + sourceLength).compareTo (source);
            else compareResult = string.substring (from [0], from [0] + sourceLength).compareToIgnoreCase (source);

            if (compareResult == 0) {
                int fromIndex = from [0];
                from [0] += destLength;
                return string.substring (0, fromIndex) + dest + string.substring (fromIndex + sourceLength, stringLength);
            }
            from [0] ++;
        }
        return string;
    }

    private static String replaceFrom (String string, String source, String dest, boolean caseSensitive, int from) {
        int fromArray [] = new int [1];
        fromArray [0] = from;
        return replaceFrom (string, source, dest, caseSensitive, fromArray);
    }

    public static String replace (String string, String source, String dest, boolean caseSensitive) {
        return replaceFrom (string, source, dest, caseSensitive, 0);
    }

    private static String replaceAll (String string, String source, String dest, boolean caseSensitive, int from) {
        int fromArray [] = new int [1];
        fromArray [0] = from;
        String newString = replaceFrom (string, source, dest, caseSensitive, fromArray);
        from = fromArray [0];
        if (newString.compareTo (string) == 0) {
            return newString;
        } else {
            return replaceAll (newString, source, dest, caseSensitive, from);
        }
    }

    public static String replaceAll (String string, String source, String dest, boolean caseSensitive) {
        return replaceAll (string, source, dest, caseSensitive, 0);
    }

    private static String replaceWholeWordsFrom (String string, String pattern, String dest, boolean caseSensitive, int [] fromArray) {
        boolean frontOK = false, backOK = false;
        int index = (caseSensitive) ? string.indexOf (pattern, fromArray [0]) : string.toUpperCase ().indexOf (pattern.toUpperCase (), fromArray [0]);
        if (index == 0) frontOK = true;
        else if (index > 0) {
            if (delims.indexOf (string.charAt (index - 1)) >= 0) {
                frontOK = true;
            }
        }

        if (frontOK) {
            if (index + pattern.length () >= string.length ()) backOK = true;
            else if (delims.indexOf (string.charAt ((index + pattern.length ()))) >= 0) backOK = true;

            if (backOK) {
                fromArray [0] = (index - 1 < 0) ? 0 : index + dest.length ();
                return string.substring (0, (index - 1 < 0) ? 0 : index) + dest + ((index + pattern.length () > string.length ()) ? StringStatics.BLANK : string.substring (index + pattern.length (), string.length ()));
            }
        }
        if (index >= 0 && index + 1 < string.length ()) {
            fromArray [0] = index + 1;
            return replaceWholeWordsFrom (string, pattern, dest, caseSensitive, fromArray);
        }
        return string;
    }

    public static String replaceWholeWords (String string, String source, String dest, boolean caseSensitive) {
        int fromArray [] = new int [] {0};
        return replaceWholeWordsFrom (string, source, dest, caseSensitive, fromArray);
    }

    public static String replaceAllWholeWords (String string, String source, String dest, boolean caseSensitive) {
        int fromArray [] = new int [] {0};
        String oldResult = null, result = replaceWholeWordsFrom (string, source, dest, caseSensitive, fromArray);
        while (oldResult == null || ! result.equals (oldResult)) {
            oldResult = result;
            result = replaceWholeWordsFrom (oldResult, source, dest, caseSensitive, fromArray);
        }
        return result;
    }

    public static boolean doesWordExist (String string, String source, boolean caseSensitive) {
        StringTokenizer st = new StringTokenizer (string);
        while (st.hasMoreTokens ()) {
            String token = st.nextToken ();
            if (((caseSensitive) && (token.compareTo (source) == 0)) || ((! caseSensitive) && (token.toUpperCase ().compareTo (source.toUpperCase ()) == 0))) {
                return true;
            }
        }
        return false;
    }

    public static boolean isValidPositiveInteger (String string) {
        for (int i = 0;
        i < string.length (); i ++) {
            if (string.charAt (i) < '0' || string.charAt (i) > '9') return false;

        }
        return true;
    }

    public static String encodeURL (String url) {
        int protocolIndex = url.indexOf (PROTOCOL_DELIMITER);
        if (protocolIndex > 0) {
            String start = url.substring (0, protocolIndex + PROTOCOL_DELIMITER_LENGTH);
            int slashIndex = url.indexOf ('/', protocolIndex + PROTOCOL_DELIMITER_LENGTH);
            if (slashIndex == - 1) {
                slashIndex = url.length ();
            }
            String domain = url.substring (protocolIndex + PROTOCOL_DELIMITER_LENGTH, slashIndex);
            String end = url.substring (slashIndex, url.length ());
            end = encodePercentage (end);
            end = encode (end);
            return start + domain + end;
        }
        return url;
    }

    private static String encodePercentage (String string) {
        for (int index = string.indexOf ('%');
        index != - 1;) {
            int length = string.length ();
            if (length > index + 2) {
                if (! isOKForHex (string.charAt (index + 1)) || ! isOKForHex (string.charAt (index + 2))) {
                    string = replace (string, index, ENCODED_PERCENT);
                }
            } else {
                string = replace (string, index, ENCODED_PERCENT);
            }
            index = string.indexOf ('%', index + 1);
        }
        return string;
    }

    private static boolean isOKForHex (char aChar) {
        if ((aChar >= '0') && (aChar <= '9')) {
            return true;
        }
        if ((aChar >= 'a') && (aChar <= 'f')) {
            return true;
        }
        if ((aChar >= 'A') && (aChar <= 'F')) {
            return true;
        }
        return false;
    }

    private static String replace (String original, int index, String newPart) {
        return original.substring (0, index) + newPart + original.substring (index + 1);
    }

    private static int findUnEncodeableCharacter (String string, int start) {
        if (start >= string.length ()) return - 1;

        int indices [] = new int [] {string.indexOf ('%', start), string.indexOf ('/', start), string.indexOf ('&', start), string.indexOf ('=', start), string.indexOf ('+', start), string.indexOf ('?', start)};
        int index = - 1;
        for (int i = 0;
        i < indices.length; i ++) {
            if (indices [i] != - 1 && indices [i] < index || index == - 1) {
                index = indices [i];
            }
        }
        return index;
    }

    private static String encode (String string) {
        int beginIndex = findUnEncodeableCharacter (string, 0);
        if (beginIndex == - 1) beginIndex = 0;

        while (beginIndex < string.length ()) {
            int endIndex = findUnEncodeableCharacter (string, beginIndex + 1);
            if (endIndex == - 1) endIndex = string.length ();

            String begin = string.substring (0, beginIndex + 1);
            String middle = string.substring (beginIndex + 1, endIndex);
            String end = string.substring (endIndex);
            try {
                middle = URLEncoder.encode (middle, URL_ENCODING);
            } catch (UnsupportedEncodingException e) {
                Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.ENCODING_FAILURE, URL_ENCODING + " unsupported.");
                Trace.catching (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.EXCEPTIONS_CATCHING, StringUtil.class, "encode", e);
            }
            beginIndex = begin.length () + middle.length ();
            string = begin + middle + end;
        }
        return string;
    }

}

