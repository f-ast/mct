package org.eclipse.gmf.runtime.gef.ui.figures;

import java.util.HashMap;

import java.util.Map;

import java.util.WeakHashMap;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.ImageFigure;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.PrecisionPoint;

import org.eclipse.draw2d.geometry.Ray;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.swt.graphics.Image;

import org.eclipse.swt.graphics.ImageData;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

public class SlidableImageAnchor extends SlidableAnchor {
    static private class ImageAnchorLocation {
        static private Map imageAnchorLocationMap = new WeakHashMap ();

        static ImageAnchorLocation getInstance (Image image) {
            ImageAnchorLocation imgAnchorLoc = (ImageAnchorLocation) imageAnchorLocationMap.get (image);
            if (imgAnchorLoc == null) {
                imgAnchorLoc = new ImageAnchorLocation (image);
                imageAnchorLocationMap.put (image, imgAnchorLoc);
            }
            return imgAnchorLoc;
        }

        private Map locationMap = new HashMap ();
        private ImageData imgData = null;
        private ImageData transMaskData = null;

        private ImageAnchorLocation (Image img) {
            imgData = img.getImageData ();
            transMaskData = imgData.getTransparencyMask ();
        }

        protected ImageData getImageData () {
            return imgData;
        }

        protected ImageData getTransparencyMaskData () {
            return transMaskData;
        }

        protected boolean isTransparentAt (int x, int y, boolean checkAdjacent) {
            if (x < 0 || x >= getImageData ().width || y < 0 || y >= getImageData ().height) return true;

            int transValue = 255;
            if (getTransparencyMaskData () != null) {
                transValue = getTransparencyMaskData ().getPixel (x, y) == 0 ? 0 : 255;
            }
            if (transValue != 0) {
                if (getImageData ().alphaData != null) {
                    transValue = getImageData ().getAlpha (x, y);
                }
            }
            boolean trans = false;
            if (transValue < 10) {
                trans = true;
                if (checkAdjacent) {
                    trans &= isTransparentAt (x + 1, y, false);
                    trans &= isTransparentAt (x + 1, y + 1, false);
                    trans &= isTransparentAt (x + 1, y - 1, false);
                    trans &= isTransparentAt (x - 1, y + 1, false);
                    trans &= isTransparentAt (x - 1, y, false);
                    trans &= isTransparentAt (x - 1, y - 1, false);
                    trans &= isTransparentAt (x, y + 1, false);
                    trans &= isTransparentAt (x, y - 1, false);
                }
            }
            return trans;
        }

        private Point getLocation (Point start, Point edge, Rectangle containerRect, boolean isDefaultAnchor) {
            int angle = calculateAngleOfEntry (start, edge);
            Point top = containerRect.getTopLeft ();
            Point ptIntersect = null;
            if (isDefaultAnchor) {
                ptIntersect = (Point) locationMap.get (new Integer (angle));
            }
            if (ptIntersect == null) {
                Dimension dim = edge.getDifference (top);
                Point edgeImg = new Point (Math.max (0, Math.min (dim.width, getImageData ().width - 1)), Math.max (0, Math.min (dim.height, getImageData ().height - 1)));
                Dimension startDim = start.getDifference (top);
                Point startImg = new Point (Math.max (0, Math.min (startDim.width, getImageData ().width - 1)), Math.max (0, Math.min (startDim.height, getImageData ().height - 1)));
                ptIntersect = calculateIntersection (startImg, edgeImg);
                if (ptIntersect == null) return null;

                if (isDefaultAnchor) {
                    locationMap.put (new Integer (angle), ptIntersect);
                }
            }
            return ptIntersect.getTranslated (top.x, top.y);
        }

        private int calculateAngleOfEntry (Point start, Point edge) {
            LineSeg lineSeg = new LineSeg (start, edge);
            Ray ray = new Ray (lineSeg.getOrigin (), new Point (lineSeg.getOrigin ().x + 1, lineSeg.getOrigin ().y));
            double angle = 0.0;
            LineSeg.TrigValues trig = lineSeg.getTrigValues (ray);
            if (trig != null) angle = Math.atan2 (- trig.sinTheta, - trig.cosTheta) + Math.PI;

            int keyAngle = (int) Math.round (angle * 360 / (Math.PI * 2));
            return keyAngle - (keyAngle % 10);
        }

        private Point calculateIntersection (Point start, Point edge) {
            Point opaque = new Point (edge);
            LineSeg line = new LineSeg (start, edge);
            long distance = Math.round (line.length ());
            while (opaque.x >= 0 && opaque.x < getImageData ().width && opaque.y >= 0 && opaque.y < getImageData ().height) {
                if (! isTransparentAt (opaque.x, opaque.y, true)) {
                    return opaque;
                }
                line.pointOn (distance, LineSeg.KeyPoint.ORIGIN, opaque);
                distance --;
            }
            return null;
        }

    }

    private ImageFigure imageFig;

    public SlidableImageAnchor () {
        super ();
    }

    public SlidableImageAnchor (IFigure f) {
        super (f);
    }

    public SlidableImageAnchor (IFigure container, ImageFigure imageFig) {
        super (container);
        this.imageFig = imageFig;
    }

    public SlidableImageAnchor (IFigure f, ImageFigure imageFig, PrecisionPoint p) {
        super (f, p);
        this.imageFig = imageFig;
    }

    protected Image getImage () {
        return imageFig.getImage ();
    }

    protected IFigure getContainer () {
        return getOwner ();
    }

    protected Point getLocation (Point ownReference, Point foreignReference) {
        Image image = getImage ();
        if (image == null) return super.getLocation (ownReference, foreignReference);

        Rectangle ownerRect = new Rectangle (getBox ());
        PointList intersections = getIntersectionPoints (ownReference, foreignReference);
        if (intersections != null && intersections.size () != 0) {
            Point ptRef = PointListUtilities.pickFarestPoint (intersections, foreignReference);
            Point ptEdge = PointListUtilities.pickClosestPoint (intersections, foreignReference);
            Point loc = ImageAnchorLocation.getInstance (getImage ()).getLocation (ptRef, ptEdge, ownerRect, isDefaultAnchor ());
            if (loc != null) loc = normalizeToStraightlineTolerance (foreignReference, loc, 3);

            return loc;
        }
        return null;
    }

}

