package org.eclipse.gmf.runtime.diagram.ui.figures;

import java.util.List;

import org.eclipse.core.runtime.Assert;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;

public class BorderItemLocator implements IBorderItemLocator {
    private IFigure parentFigure = null;
    private Rectangle constraint = new Rectangle (0, 0, 0, 0);
    private Dimension borderItemOffset = new Dimension (1, 1);
    private int preferredSide = PositionConstants.WEST;
    private int currentSide = PositionConstants.WEST;
    private int interval;

    protected Rectangle getConstraint () {
        return constraint;
    }

    public BorderItemLocator (int interval, IFigure parentFigure) {
        Assert.isTrue (interval > 0);
        Assert.isNotNull (parentFigure);
        this.parentFigure = parentFigure;
        this.interval = interval;
    }

    public BorderItemLocator (IFigure parentFigure) {
        this (MapModeUtil.getMapMode (parentFigure).DPtoLP (8), parentFigure);
    }

    public BorderItemLocator (IFigure parentFigure, int preferredSide) {
        this (parentFigure);
        this.preferredSide = preferredSide;
    }

    public BorderItemLocator (IFigure parentFigure, int preferredSide, int interval) {
        this (interval, parentFigure);
        this.preferredSide = preferredSide;
    }

    public BorderItemLocator (IFigure borderItem, IFigure parentFigure, Rectangle constraint) {
        this (parentFigure);
        setConstraint (constraint);
    }

    public BorderItemLocator (IFigure borderItem, IFigure parentFigure, Rectangle constraint, int interval) {
        this (interval, parentFigure);
        setConstraint (constraint);
    }

    public void setConstraint (Rectangle theConstraint) {
        this.constraint = theConstraint;
        if (theConstraint.getTopLeft ().x == 0 || theConstraint.getTopLeft ().y == 0) {
            setCurrentSideOfParent (getPreferredSideOfParent ());
        }
    }

    protected Point getPreferredLocation (IFigure borderItem) {
        Point constraintLocation = getConstraint ().getLocation ();
        Point ptAbsoluteLocation = this.getAbsoluteToBorder (constraintLocation);
        if (constraintLocation.x == 0 || constraintLocation.y == 0) {
            return getPreferredLocation (getPreferredSideOfParent (), borderItem);
        } else {
            return ptAbsoluteLocation;
        }
    }

    protected Rectangle getParentBorder () {
        Rectangle bounds = getParentFigure ().getBounds ().getCopy ();
        if (getParentFigure () instanceof NodeFigure) {
            bounds = ((NodeFigure) getParentFigure ()).getHandleBounds ().getCopy ();
        }
        return bounds;
    }

    protected Point getPreferredLocation (int side, IFigure borderItem) {
        Rectangle bounds = getParentBorder ();
        int parentFigureWidth = bounds.width;
        int parentFigureHeight = bounds.height;
        int parentFigureX = bounds.x;
        int parentFigureY = bounds.y;
        int x = parentFigureX;
        int y = parentFigureY;
        Dimension borderItemSize = getSize (borderItem);
        if (side == PositionConstants.WEST) {
            x = parentFigureX - borderItemSize.width + getBorderItemOffset ().width;
            y += parentFigureHeight / 2;
        } else if (side == PositionConstants.EAST) {
            x = parentFigureX + parentFigureWidth - getBorderItemOffset ().width;
            y += parentFigureHeight / 2;
        } else if (side == PositionConstants.NORTH) {
            y = parentFigureY - borderItemSize.height + getBorderItemOffset ().height;
            x += parentFigureWidth / 2;
        } else if (side == PositionConstants.SOUTH) {
            x += parentFigureWidth / 2;
            y = parentFigureY + parentFigureHeight - getBorderItemOffset ().height;
        }

        return new Point (x, y);
    }

    protected Point locateOnParent (Point suggestedLocation, int suggestedSide, IFigure borderItem) {
        Rectangle bounds = getParentBorder ();
        int parentFigureWidth = bounds.width;
        int parentFigureHeight = bounds.height;
        int parentFigureX = bounds.x;
        int parentFigureY = bounds.y;
        Dimension borderItemSize = getSize (borderItem);
        int newX = suggestedLocation.x;
        int newY = suggestedLocation.y;
        int westX = parentFigureX - borderItemSize.width + getBorderItemOffset ().width;
        int eastX = parentFigureX + parentFigureWidth - getBorderItemOffset ().width;
        int southY = parentFigureY + parentFigureHeight - getBorderItemOffset ().height;
        int northY = parentFigureY - borderItemSize.height + getBorderItemOffset ().height;
        if (suggestedSide == PositionConstants.WEST) {
            if (suggestedLocation.x != westX) {
                newX = westX;
            }
            if (suggestedLocation.y < bounds.getTopLeft ().y) {
                newY = northY + borderItemSize.height;
            } else if (suggestedLocation.y > bounds.getBottomLeft ().y - borderItemSize.height) {
                newY = southY - borderItemSize.height;
            }

        } else if (suggestedSide == PositionConstants.EAST) {
            if (suggestedLocation.x != eastX) {
                newX = eastX;
            }
            if (suggestedLocation.y < bounds.getTopLeft ().y) {
                newY = northY + borderItemSize.height;
            } else if (suggestedLocation.y > bounds.getBottomLeft ().y - borderItemSize.height) {
                newY = southY - borderItemSize.height;
            }

        } else if (suggestedSide == PositionConstants.SOUTH) {
            if (suggestedLocation.y != southY) {
                newY = southY;
            }
            if (suggestedLocation.x < bounds.getBottomLeft ().x) {
                newX = westX + borderItemSize.width;
            } else if (suggestedLocation.x > bounds.getBottomRight ().x - borderItemSize.width) {
                newX = eastX - borderItemSize.width;
            }

        } else {
            if (suggestedLocation.y != northY) {
                newY = northY;
            }
            if (suggestedLocation.x < bounds.getBottomLeft ().x) {
                newX = westX + borderItemSize.width;
            } else if (suggestedLocation.x > bounds.getBottomRight ().x - borderItemSize.width) {
                newX = eastX - borderItemSize.width;
            }

        }

        return new Point (newX, newY);
    }

    protected IFigure getConflictingBorderItemFigure (Point recommendedLocation, IFigure targetBorderItem) {
        Rectangle recommendedRect = new Rectangle (recommendedLocation, getSize (targetBorderItem));
        List borderItems = targetBorderItem.getParent ().getChildren ();
        int currentIndex = borderItems.indexOf (targetBorderItem);
        for (int i = 0;
        i < currentIndex; i ++) {
            IFigure borderItem = (IFigure) borderItems.get (i);
            if (borderItem.isVisible ()) {
                Rectangle rect = borderItem.getBounds ().getCopy ();
                if (rect.intersects (recommendedRect)) {
                    return borderItem;
                }
            }
        }
        return null;
    }

    protected Point locateOnBorder (Point suggestedLocation, int suggestedSide, int circuitCount, IFigure borderItem) {
        Point recommendedLocation = locateOnParent (suggestedLocation, suggestedSide, borderItem);
        Dimension borderItemSize = getSize (borderItem);
        IFigure conflictingBorderItem = getConflictingBorderItemFigure (recommendedLocation, borderItem);
        if (circuitCount < 4 && conflictingBorderItem != null) {
            if (suggestedSide == PositionConstants.WEST) {
                do {
                    calculateNextNonConflictingPosition (recommendedLocation, interval, suggestedSide, borderItem, conflictingBorderItem.getBounds ());
                    conflictingBorderItem = getConflictingBorderItemFigure (recommendedLocation, borderItem);
                } while (conflictingBorderItem != null);
                if (recommendedLocation.y > getParentBorder ().getBottomLeft ().y - borderItemSize.height) {
                    return locateOnBorder (recommendedLocation, PositionConstants.SOUTH, circuitCount + 1, borderItem);
                } else if (recommendedLocation.y < getParentBorder ().getTopLeft ().y - borderItemSize.height) {
                    return locateOnBorder (recommendedLocation, PositionConstants.NORTH, circuitCount + 1, borderItem);
                }

            } else if (suggestedSide == PositionConstants.SOUTH) {
                do {
                    calculateNextNonConflictingPosition (recommendedLocation, interval, suggestedSide, borderItem, conflictingBorderItem.getBounds ());
                    conflictingBorderItem = getConflictingBorderItemFigure (recommendedLocation, borderItem);
                } while (conflictingBorderItem != null);
                if (recommendedLocation.x > getParentBorder ().getBottomRight ().x - borderItemSize.width) {
                    return locateOnBorder (recommendedLocation, PositionConstants.EAST, circuitCount + 1, borderItem);
                } else if (recommendedLocation.x < getParentBorder ().getBottomLeft ().x - borderItemSize.width) {
                    return locateOnBorder (recommendedLocation, PositionConstants.WEST, circuitCount + 1, borderItem);
                }

            } else if (suggestedSide == PositionConstants.EAST) {
                do {
                    calculateNextNonConflictingPosition (recommendedLocation, interval, suggestedSide, borderItem, conflictingBorderItem.getBounds ());
                    conflictingBorderItem = getConflictingBorderItemFigure (recommendedLocation, borderItem);
                } while (conflictingBorderItem != null);
                if (recommendedLocation.y < getParentBorder ().getTopRight ().y) {
                    return locateOnBorder (recommendedLocation, PositionConstants.NORTH, circuitCount + 1, borderItem);
                } else if (recommendedLocation.y > getParentBorder ().getBottomRight ().y) {
                    return locateOnBorder (recommendedLocation, PositionConstants.SOUTH, circuitCount + 1, borderItem);
                }

            } else {
                do {
                    calculateNextNonConflictingPosition (recommendedLocation, interval, suggestedSide, borderItem, conflictingBorderItem.getBounds ());
                    conflictingBorderItem = getConflictingBorderItemFigure (recommendedLocation, borderItem);
                } while (conflictingBorderItem != null);
                if (recommendedLocation.x < getParentBorder ().getTopLeft ().x) {
                    return locateOnBorder (recommendedLocation, PositionConstants.WEST, circuitCount + 1, borderItem);
                } else if (recommendedLocation.x > getParentBorder ().getTopRight ().x) {
                    return locateOnBorder (recommendedLocation, PositionConstants.EAST, circuitCount + 1, borderItem);
                }

            }

        }
        return recommendedLocation;
    }

    protected void calculateNextNonConflictingPosition (Point currentLocation, int interval, int currentSide, IFigure borderItem, Rectangle obstacle) {
        switch (currentSide) {
            case PositionConstants.WEST :
                currentLocation.y = obstacle.getBottomLeft ().y + interval;
                break;
            case PositionConstants.SOUTH :
                currentLocation.x = obstacle.getBottomRight ().x + interval;
                break;
            case PositionConstants.EAST :
                currentLocation.y = obstacle.getTopRight ().y - interval - borderItem.getBounds ().height;
                break;
            case PositionConstants.NORTH :
                currentLocation.x = obstacle.getTopLeft ().x - interval - borderItem.getBounds ().width;
                break;
            default :
                throw new IllegalArgumentException ("Invalid side argument: " + currentSide + ". Should be the value from PositionConstants: WEST, EAST, NORTH or SOUTH");
        }
    }

    protected Point getAbsoluteToBorder (Point ptRelativeOffset) {
        Point parentOrigin = getParentBorder ().getTopLeft ();
        return parentOrigin.translate (ptRelativeOffset);
    }

    public Rectangle getValidLocation (Rectangle proposedLocation, IFigure borderItem) {
        Rectangle realLocation = new Rectangle (proposedLocation);
        int side = findClosestSideOfParent (proposedLocation, getParentBorder ());
        Point newTopLeft = locateOnBorder (realLocation.getTopLeft (), side, 0, borderItem);
        realLocation.setLocation (newTopLeft);
        return realLocation;
    }

    public static int findClosestSideOfParent (Rectangle proposedLocation, Rectangle parentBorder) {
        Point parentCenter = parentBorder.getCenter ();
        Point childCenter = proposedLocation.getCenter ();
        if (childCenter.x < parentCenter.x) {
            if (childCenter.y < parentCenter.y) {
                Point parentTopLeft = parentBorder.getTopLeft ();
                if ((childCenter.x - parentTopLeft.x) <= (childCenter.y - parentTopLeft.y)) {
                    return PositionConstants.WEST;
                } else {
                    return PositionConstants.NORTH;
                }
            } else {
                Point parentBottomLeft = parentBorder.getBottomLeft ();
                if ((childCenter.x - parentBottomLeft.x) <= (parentBottomLeft.y - childCenter.y)) {
                    return PositionConstants.WEST;
                } else {
                    return PositionConstants.SOUTH;
                }
            }
        } else {
            if (childCenter.y < parentCenter.y) {
                Point parentTopRight = parentBorder.getTopRight ();
                if ((parentTopRight.x - childCenter.x) <= (childCenter.y - parentTopRight.y)) {
                    return PositionConstants.EAST;
                } else {
                    return PositionConstants.NORTH;
                }
            } else {
                Point parentBottomRight = parentBorder.getBottomRight ();
                if ((parentBottomRight.x - childCenter.x) <= (parentBottomRight.y - childCenter.y)) {
                    return PositionConstants.EAST;
                } else {
                    return PositionConstants.SOUTH;
                }
            }
        }
    }

    public void relocate (IFigure borderItem) {
        Dimension size = getSize (borderItem);
        Rectangle rectSuggested = new Rectangle (getPreferredLocation (borderItem), size);
        int closestSide = findClosestSideOfParent (rectSuggested, getParentBorder ());
        setPreferredSideOfParent (closestSide);
        Point ptNewLocation = locateOnBorder (getPreferredLocation (borderItem), getPreferredSideOfParent (), 0, borderItem);
        borderItem.setBounds (new Rectangle (ptNewLocation, size));
        setCurrentSideOfParent (findClosestSideOfParent (new Rectangle (ptNewLocation, size), getParentBorder ()));
    }

    public IFigure getParentFigure () {
        return parentFigure;
    }

    public Dimension getBorderItemOffset () {
        return borderItemOffset;
    }

    public void setBorderItemOffset (Dimension borderItemOffset) {
        this.borderItemOffset = borderItemOffset;
    }

    public int getPreferredSideOfParent () {
        return preferredSide;
    }

    public void setPreferredSideOfParent (int preferredSide) {
        this.preferredSide = preferredSide;
        setCurrentSideOfParent (preferredSide);
    }

    public int getCurrentSideOfParent () {
        return currentSide;
    }

    public void setCurrentSideOfParent (int side) {
        this.currentSide = side;
    }

    protected final Dimension getSize (IFigure borderItem) {
        Dimension size = getConstraint ().getSize ();
        if (size.isEmpty ()) {
            size = borderItem.getPreferredSize ();
        }
        return size;
    }

}

