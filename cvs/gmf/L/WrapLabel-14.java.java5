package org.eclipse.gmf.runtime.draw2d.ui.figures;

import java.lang.ref.WeakReference;

import java.util.ArrayList;

import java.util.Map;

import java.util.WeakHashMap;

import org.eclipse.draw2d.ColorConstants;

import org.eclipse.draw2d.Figure;

import org.eclipse.draw2d.FigureUtilities;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.LayoutManager;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Insets;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.internal.mapmode.IMapModeHolder;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.swt.graphics.Font;

import org.eclipse.swt.graphics.FontMetrics;

import org.eclipse.swt.graphics.Image;

import com.ibm.icu.text.BreakIterator;

import com.ibm.icu.util.StringTokenizer;

public class WrapLabel extends Figure implements PositionConstants {
    private static final String _ellipse = "...";
    private static final Dimension EMPTY_DIMENSION = new Dimension (0, 0);
    private static final Map mapModeConstantsMap = new WeakHashMap ();
    private static class MapModeConstants {
        private static final int MAX_IMAGE_INFO = 12;
        public final WeakReference mapModeRef;
        public final int nDPtoLP_3;
        public final int nDPtoLP_2;
        public final int nDPtoLP_0;
        public final Dimension dimension_nDPtoLP_0;
        public final WeakHashMap fontToEllipseTextSize = new WeakHashMap ();
        public final SingleIconInfo [] singleIconInfos = new SingleIconInfo [MAX_IMAGE_INFO];

        public MapModeConstants (IMapMode mapMode) {
            this.mapModeRef = new WeakReference (mapMode);
            nDPtoLP_2 = mapMode.DPtoLP (2);
            nDPtoLP_3 = mapMode.DPtoLP (3);
            nDPtoLP_0 = mapMode.DPtoLP (0);
            dimension_nDPtoLP_0 = new Dimension (nDPtoLP_0, nDPtoLP_0);
        }

        public Dimension getEllipseTextSize (Font f) {
            Dimension d = (Dimension) fontToEllipseTextSize.get (f);
            if (d == null) {
                IMapMode mapMode = (IMapMode) mapModeRef.get ();
                d = FigureUtilities.getTextExtents (_ellipse, f);
                d.height = FigureUtilities.getFontMetrics (f).getHeight ();
                d = new Dimension (mapMode.DPtoLP (d.width), mapMode.DPtoLP (d.height));
                fontToEllipseTextSize.put (f, d);
            }
            return d;
        }

        public SingleIconInfo getSingleIconInfo (Image image) {
            if (image == null) {
                return SingleIconInfo.NULL_INFO;
            }
            SingleIconInfo info;
            for (int i = 0;
            i < MAX_IMAGE_INFO; ++ i) {
                info = singleIconInfos [i];
                if (info == null) {
                    info = new SingleIconInfo (image);
                    singleIconInfos [i] = info;
                    return info;
                }
                if (info.icon == image) {
                    return info;
                }
            }
            int index = SingleIconInfo.count % MAX_IMAGE_INFO;
            info = new SingleIconInfo (image);
            singleIconInfos [index] = info;
            return info;
        }

    }

    private static int FLAG_SELECTED = MAX_FLAG << 1;
    private static int FLAG_HASFOCUS = MAX_FLAG << 2;
    private static int FLAG_UNDERLINED = MAX_FLAG << 3;
    private static int FLAG_STRIKEDTHROUGH = MAX_FLAG << 4;
    private static int FLAG_WRAP = MAX_FLAG << 5;
    private static int FLAG_TEXT_ALIGN = MAX_FLAG << 6;
    private static int FLAG_WRAP_ALIGN = MAX_FLAG << 9;
    private static int FLAG_ICON_ALIGN = MAX_FLAG << 12;
    private static int FLAG_LABEL_ALIGN = MAX_FLAG << 15;
    private static int FLAG_TEXT_PLACEMENT = MAX_FLAG << 18;
    private MapModeConstants mapModeConstants;
    private String text;
    private String subStringText;
    private Dimension textSize;
    private Dimension ellipseTextSize;
    private Point textLocation;
    private int cachedPrefSizeHint_width;
    private int cachedPrefSizeHint_height;
    private Point iconLocation;
    private static abstract class IconInfo {

        public abstract Image getIcon (int i);

        public abstract Dimension getIconSize (IMapMode mapMode, int i);

        public abstract int getNumberofIcons ();

        public abstract Dimension getTotalIconSize (IMapMode mapMode);

        public abstract void invalidate ();

        public abstract void setIcon (Image icon, int i);

        public abstract int getMaxIcons ();

    }

    private static class SingleIconInfo extends IconInfo {
        static int count;
        public static final SingleIconInfo NULL_INFO = new SingleIconInfo () {

            public int getNumberofIcons () {
                return 0;
            }

        }

        ;
        final Image icon;
        private Dimension totalIconSize;

        private SingleIconInfo () {
            icon = null;
        }

        public SingleIconInfo (Image icon) {
            this.icon = icon;
            ++ count;
        }

        public final int getMaxIcons () {
            return 1;
        }

        public Image getIcon (int i) {
            if (i == 0) {
                return icon;
            } else if (i > 0) {
                return null;
            }

            throw new IndexOutOfBoundsException ();
        }

        public void setIcon (Image img, int i) {
            throw new UnsupportedOperationException ();
        }

        public Dimension getIconSize (IMapMode mapMode, int i) {
            if (i == 0) {
                return getTotalIconSize (mapMode);
            }
            throw new IndexOutOfBoundsException ();
        }

        public int getNumberofIcons () {
            return 1;
        }

        public Dimension getTotalIconSize (IMapMode mapMode) {
            if (totalIconSize != null) return totalIconSize;

            if (icon != null && ! icon.isDisposed ()) {
                org.eclipse.swt.graphics.Rectangle imgBounds = icon.getBounds ();
                totalIconSize = new Dimension (mapMode.DPtoLP (imgBounds.width), mapMode.DPtoLP (imgBounds.height));
            } else {
                totalIconSize = EMPTY_DIMENSION;
            }
            return totalIconSize;
        }

        public void invalidate () {
            totalIconSize = null;
        }

    }

    private static class MultiIconInfo extends IconInfo {
        private ArrayList icons = new ArrayList (2);
        private Dimension totalIconSize;

        public MultiIconInfo () {
            super ();
        }

        public int getMaxIcons () {
            return - 1;
        }

        public Image getIcon (int i) {
            if (i >= icons.size ()) return null;

            return (Image) icons.get (i);
        }

        public void setIcon (Image icon, int i) {
            int size = icons.size ();
            if (i >= size) {
                for (int j = size;
                j < i; j ++) icons.add (null);

                icons.add (icon);
                icons.trimToSize ();
            } else icons.set (i, icon);

        }

        public Dimension getIconSize (IMapMode mapMode, int i) {
            Image img = getIcon (i);
            if (img != null && ! img.isDisposed ()) {
                org.eclipse.swt.graphics.Rectangle imgBounds = img.getBounds ();
                return new Dimension (mapMode.DPtoLP (imgBounds.width), mapMode.DPtoLP (imgBounds.height));
            }
            return EMPTY_DIMENSION;
        }

        public int getNumberofIcons () {
            return icons.size ();
        }

        public Dimension getTotalIconSize (IMapMode mapMode) {
            if (totalIconSize != null) return totalIconSize;

            int iconNum = getNumberofIcons ();
            if (iconNum == 0) {
                return totalIconSize = EMPTY_DIMENSION;
            }
            totalIconSize = new Dimension ();
            for (int i = 0;
            i < iconNum; i ++) {
                Dimension iconSize = getIconSize (mapMode, i);
                totalIconSize.width += iconSize.width;
                if (iconSize.height > totalIconSize.height) totalIconSize.height = iconSize.height;

            }
            return totalIconSize;
        }

        public void invalidate () {
            totalIconSize = null;
        }

    }

    private IconInfo iconInfo;
    private int cachedTextSizeHint_width;
    private int cachedTextSizeHint_height;

    public WrapLabel () {
        text = "";
        setAlignmentFlags (CENTER, FLAG_TEXT_ALIGN);
        setAlignmentFlags (CENTER, FLAG_ICON_ALIGN);
        setAlignmentFlags (CENTER, FLAG_LABEL_ALIGN);
        setAlignmentFlags (LEFT, FLAG_WRAP_ALIGN);
        setPlacementFlags (EAST, FLAG_TEXT_PLACEMENT);
    }

    public WrapLabel (String s) {
        if (s != null) {
            text = s;
        } else {
            text = "";
        }
    }

    public WrapLabel (Image i) {
        text = "";
        iconInfo = new SingleIconInfo (i);
    }

    public WrapLabel (String s, Image i) {
        if (s != null) {
            text = s;
        } else {
            text = "";
        }
        iconInfo = new SingleIconInfo (i);
    }

    private IMapMode getFigureMapMode () {
        return (IMapMode) getMapModeConstants ().mapModeRef.get ();
    }

    private MapModeConstants getMapModeConstants () {
        if (mapModeConstants == null) {
            IMapMode mapMode = MapModeUtil.getMapMode (this);
            while (mapMode instanceof IMapModeHolder) {
                mapMode = ((IMapModeHolder) mapMode).getMapMode ();
            }
            mapModeConstants = (MapModeConstants) mapModeConstantsMap.get (mapMode);
            if (mapModeConstants == null) {
                mapModeConstants = new MapModeConstants (mapMode);
                mapModeConstantsMap.put (mapMode, mapModeConstants);
            }
        }
        return mapModeConstants;
    }

    private void alignOnHeight (Point loc, Dimension size, int alignment) {
        switch (alignment) {
            case TOP :
                loc.y = getInsets ().top;
                break;
            case BOTTOM :
                loc.y = bounds.height - size.height - getInsets ().bottom;
                break;
            default :
                loc.y = (bounds.height - size.height) / 2;
        }
    }

    private void alignOnWidth (Point loc, Dimension size, int alignment) {
        switch (alignment) {
            case LEFT :
                loc.x = getInsets ().left;
                break;
            case RIGHT :
                loc.x = bounds.width - size.width - getInsets ().right;
                break;
            default :
                loc.x = (bounds.width - size.width) / 2;
        }
    }

    private void calculateAlignment (Dimension iconSize, int textPlacement) {
        switch (textPlacement) {
            case EAST :
            case WEST :
                alignOnHeight (textLocation, getTextSize (), getTextAlignment ());
                alignOnHeight (getIconLocation (), iconSize, getIconAlignment ());
                break;
            case NORTH :
            case SOUTH :
                alignOnWidth (textLocation, getSubStringTextSize (), getTextAlignment ());
                alignOnWidth (getIconLocation (), iconSize, getIconAlignment ());
                break;
        }
    }

    protected Dimension calculateLabelSize (Dimension txtSize) {
        Dimension iconSize = getTotalIconSize ();
        boolean isEmpty = (iconSize.width == 0 && iconSize.height == 0);
        int len = getText ().length ();
        if (len == 0 && isEmpty) {
            return new Dimension (txtSize.width, txtSize.height);
        }
        int gap = (len == 0 || isEmpty) ? 0 : getIconTextGap ();
        int placement = getTextPlacement ();
        if (placement == WEST || placement == EAST) {
            return new Dimension (iconSize.width + gap + txtSize.width, Math.max (iconSize.height, txtSize.height));
        } else {
            return new Dimension (Math.max (iconSize.width, txtSize.width), iconSize.height + gap + txtSize.height);
        }
    }

    private void calculateLocations () {
        textLocation = new Point ();
        iconLocation = new Point ();
        Dimension iconSize = getTotalIconSize ();
        int textPlacement = getTextPlacement ();
        calculatePlacement (iconSize, textPlacement);
        calculateAlignment (iconSize, textPlacement);
        Rectangle r = getBounds ();
        Dimension ps = getPreferredSize (r.width, r.height);
        int w = (r.width - ps.width) + (getTextSize ().width - getSubStringTextSize ().width);
        int h = r.height - ps.height;
        if (w == 0 && h == 0) {
            return;
        }
        Dimension offset = new Dimension (w, h);
        switch (getLabelAlignment ()) {
            case CENTER :
                offset.scale (0.5f);
                break;
            case LEFT :
                offset.scale (0.0f);
                break;
            case RIGHT :
                offset.scale (1.0f);
                break;
            case TOP :
                offset.height = 0;
                offset.scale (0.5f);
                break;
            case BOTTOM :
                offset.height = offset.height * 2;
                offset.scale (0.5f);
                break;
            default :
                offset.scale (0.5f);
                break;
        }
        switch (textPlacement) {
            case EAST :
            case WEST :
                offset.height = 0;
                break;
            case NORTH :
            case SOUTH :
                offset.width = 0;
                break;
        }
        textLocation.translate (offset);
        iconLocation.translate (offset);
    }

    private void calculatePlacement (Dimension iconSize, int textPlacement) {
        int gap = (getText ().length () == 0 || (iconSize.width == 0 && iconSize.height == 0)) ? 0 : getIconTextGap ();
        Insets insets = getInsets ();
        switch (textPlacement) {
            case EAST :
                iconLocation.x = insets.left;
                textLocation.x = iconSize.width + gap + insets.left;
                break;
            case WEST :
                textLocation.x = insets.left;
                iconLocation.x = getSubStringTextSize ().width + gap + insets.left;
                break;
            case NORTH :
                textLocation.y = insets.top;
                iconLocation.y = getTextSize ().height + gap + insets.top;
                break;
            case SOUTH :
                textLocation.y = iconSize.height + gap + insets.top;
                iconLocation.y = insets.top;
        }
    }

    protected Dimension calculateSubStringTextSize () {
        Font f = getFont ();
        return getTextExtents (getSubStringText (), f, getFigureMapMode ().DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ()));
    }

    protected Dimension calculateTextSize (int wHint, int hHint) {
        Font f = getFont ();
        return getTextExtents (getWrappedText (wHint, hHint), f, getFigureMapMode ().DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ()));
    }

    private void clearLocations () {
        iconLocation = textLocation = null;
    }

    public Image getIcon () {
        return getIcon (0);
    }

    public Image getIcon (int index) {
        if (iconInfo == null) return null;

        return iconInfo.getIcon (index);
    }

    protected boolean hasIcons () {
        return (getNumberofIcons () > 0);
    }

    public int getIconAlignment () {
        return getAlignment (FLAG_ICON_ALIGN);
    }

    public Rectangle getIconBounds () {
        return new Rectangle (getBounds ().getLocation ().translate (getIconLocation ()), getTotalIconSize ());
    }

    protected Point getIconLocation () {
        if (iconLocation == null) calculateLocations ();

        return iconLocation;
    }

    public int getIconTextGap () {
        return getMapModeConstants ().nDPtoLP_3;
    }

    public Dimension getMinimumSize (int w, int h) {
        if (minSize != null) return minSize;

        minSize = new Dimension ();
        LayoutManager layoutManager = getLayoutManager ();
        if (layoutManager != null) minSize.setSize (layoutManager.getMinimumSize (this, w, h));

        Font f = getFont ();
        Dimension d = getEllipseTextSize ().getIntersected (getTextExtents (getText (), f, getFigureMapMode ().DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ())));
        Dimension labelSize = calculateLabelSize (d);
        Insets insets = getInsets ();
        labelSize.expand (insets.getWidth (), insets.getHeight ());
        minSize.union (labelSize);
        return minSize;
    }

    public Dimension getPreferredSize (int wHint, int hHint) {
        if (prefSize == null || wHint != cachedPrefSizeHint_width || hHint != cachedPrefSizeHint_height) {
            prefSize = calculateLabelSize (getTextSize (wHint, hHint));
            Insets insets = getInsets ();
            prefSize.expand (insets.getWidth (), insets.getHeight ());
            LayoutManager layoutManager = getLayoutManager ();
            if (layoutManager != null) {
                prefSize.union (layoutManager.getPreferredSize (this, wHint, hHint));
            }
            prefSize.union (getMinimumSize (wHint, hHint));
            cachedPrefSizeHint_width = wHint;
            cachedPrefSizeHint_height = hHint;
        }
        return prefSize;
    }

    public Dimension getMaximumSize () {
        return prefSize;
    }

    public String getSubStringText () {
        if (subStringText != null) return subStringText;

        String theText = getText ();
        int textLen = theText.length ();
        if (textLen == 0) {
            return subStringText = "";
        }
        Dimension size = getSize ();
        Dimension shrink = getPreferredSize (size.width, size.height).getDifference (size);
        Dimension effectiveSize = getTextSize ().getExpanded (- shrink.width, - shrink.height);
        if (effectiveSize.height == 0) {
            return subStringText = "";
        }
        Font f = getFont ();
        FontMetrics metrics = FigureUtilities.getFontMetrics (f);
        IMapMode mm = getFigureMapMode ();
        int fontHeight = mm.DPtoLP (metrics.getHeight ());
        int charAverageWidth = mm.DPtoLP (metrics.getAverageCharWidth ());
        int maxLines = (int) (effectiveSize.height / (double) fontHeight);
        if (maxLines == 0) {
            return subStringText = "";
        }
        StringBuffer accumlatedText = new StringBuffer ();
        StringBuffer remainingText = new StringBuffer (theText);
        int effectiveSizeWidth = effectiveSize.width;
        int widthHint = Math.max (effectiveSizeWidth - getEllipseTextSize ().width, 0);
        int i = 0, j = 0;
        while (remainingText.length () > 0 && j ++ < maxLines) {
            i = getLineWrapPosition (remainingText.toString (), f, effectiveSizeWidth, fontHeight);
            if (accumlatedText.length () > 0) accumlatedText.append ('\n');

            if (i == 0 || (remainingText.length () > i && j == maxLines)) {
                i = getLargestSubstringConfinedTo (remainingText.toString (), f, widthHint, fontHeight, charAverageWidth);
                accumlatedText.append (remainingText.substring (0, i));
                accumlatedText.append (getEllipse ());
            } else accumlatedText.append (remainingText.substring (0, i));

            remainingText.delete (0, i);
        }
        return subStringText = accumlatedText.toString ();
    }

    private String getWrappedText (int wHint, int hHint) {
        String theText = getText ();
        if (wHint == - 1 || theText.length () == 0 || ! isTextWrapped ()) return theText;

        Dimension iconSize = getTotalIconSize ();
        if (! (iconSize.width == 0 && iconSize.height == 0)) {
            switch (getTextPlacement ()) {
                case EAST :
                case WEST :
                    wHint -= iconSize.width + getIconTextGap ();
                    break;
                case NORTH :
                case SOUTH :
                    if (hHint != - 1) hHint -= iconSize.height + getIconTextGap ();

                    break;
            }
        }
        if ((hHint == 0) || (wHint == 0)) {
            return "";
        }
        Font f = getFont ();
        int fontHeight = getFigureMapMode ().DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ());
        int maxLines = Integer.MAX_VALUE;
        if (hHint != - 1) {
            maxLines = (int) (hHint / (double) fontHeight);
            if (maxLines == 0) {
                return "";
            }
        }
        StringBuffer accumlatedText = new StringBuffer ();
        StringBuffer remainingText = new StringBuffer (theText);
        int i = 0, j = 0;
        while (remainingText.length () > 0 && j ++ < maxLines) {
            if ((i = getLineWrapPosition (remainingText.toString (), f, wHint, fontHeight)) == 0) break;

            if (accumlatedText.length () > 0) accumlatedText.append ('\n');

            accumlatedText.append (remainingText.substring (0, i));
            remainingText.delete (0, i);
        }
        return accumlatedText.toString ();
    }

    protected Dimension getSubStringTextSize () {
        return calculateSubStringTextSize ();
    }

    private Dimension getEllipseTextSize () {
        if (ellipseTextSize == null) {
            ellipseTextSize = getMapModeConstants ().getEllipseTextSize (getFont ());
        }
        return ellipseTextSize;
    }

    public String getText () {
        return text;
    }

    public int getTextAlignment () {
        return getAlignment (FLAG_TEXT_ALIGN);
    }

    private int getLabelAlignment () {
        return getAlignment (FLAG_LABEL_ALIGN);
    }

    public Rectangle getTextBounds () {
        return new Rectangle (getBounds ().getLocation ().translate (getTextLocation ()), getTextSize ());
    }

    protected Point getTextLocation () {
        if (textLocation != null) return textLocation;

        calculateLocations ();
        return textLocation;
    }

    public int getTextPlacement () {
        return getPlacement (FLAG_TEXT_PLACEMENT);
    }

    protected Dimension getTextSize (int wHint, int hHint) {
        if (textSize == null || wHint != cachedTextSizeHint_width || hHint != cachedTextSizeHint_height) {
            textSize = calculateTextSize (wHint, hHint);
            cachedTextSizeHint_width = wHint;
            cachedTextSizeHint_height = hHint;
        }
        return textSize;
    }

    private final Dimension getTextSize () {
        Rectangle r = getBounds ();
        return getTextSize (r.width, r.height);
    }

    public void invalidate () {
        prefSize = null;
        minSize = null;
        clearLocations ();
        ellipseTextSize = null;
        textSize = null;
        subStringText = null;
        if (iconInfo != null) iconInfo.invalidate ();

        super.invalidate ();
    }

    public boolean isTextTruncated () {
        return ! getSubStringTextSize ().equals (getTextSize ());
    }

    public void paintFigure (Graphics graphics) {
        if (isSelected ()) {
            graphics.pushState ();
            graphics.setBackgroundColor (ColorConstants.menuBackgroundSelected);
            graphics.fillRectangle (getSelectionRectangle ());
            graphics.popState ();
            graphics.setForegroundColor (ColorConstants.white);
        }
        if (hasFocus ()) {
            graphics.pushState ();
            graphics.setXORMode (true);
            graphics.setForegroundColor (ColorConstants.menuBackgroundSelected);
            graphics.setBackgroundColor (ColorConstants.white);
            graphics.drawFocus (getSelectionRectangle ().resize (- 1, - 1));
            graphics.popState ();
        }
        if (isOpaque ()) super.paintFigure (graphics);

        Rectangle figBounds = getBounds ();
        graphics.translate (figBounds.x, figBounds.y);
        if (hasIcons ()) paintIcons (graphics);

        String subString = getSubStringText ();
        if (subString.length () > 0) {
            if (! isEnabled ()) {
                graphics.translate (1, 1);
                graphics.setForegroundColor (ColorConstants.buttonLightest);
                paintText (graphics, subString);
                graphics.translate (- 1, - 1);
                graphics.setForegroundColor (ColorConstants.buttonDarker);
            } else {
                paintText (graphics, subString);
            }
        }
        graphics.translate (- figBounds.x, - figBounds.y);
    }

    private void paintText (Graphics graphics, String subString) {
        StringTokenizer tokenizer = new StringTokenizer (subString, "\n");
        Font f = getFont ();
        FontMetrics fontMetrics = FigureUtilities.getFontMetrics (f);
        int fontHeight = getFigureMapMode ().DPtoLP (fontMetrics.getHeight ());
        int fontHeightHalf = fontHeight / 2;
        int textWidth = getTextExtents (subString, f, fontHeight).width;
        Point p = getTextLocation ();
        int y = p.y;
        int x = p.x;
        final int wrapAlignment = getTextWrapAlignment ();
        boolean isUnderlined = isTextUnderlined ();
        boolean isStrikedThrough = isTextStrikedThrough ();
        Rectangle clipRect = new Rectangle ();
        graphics.getClip (clipRect);
        int clipRectTopRight_x = clipRect.getTopRight ().x;
        if (0 == fontMetrics.getLeading ()) {
            y += getMapModeConstants ().nDPtoLP_2;
        }
        while (tokenizer.hasMoreTokens ()) {
            x = p.x;
            String token = tokenizer.nextToken ();
            int tokenWidth = getTextExtents (token, f, fontHeight).width;
            switch (wrapAlignment) {
                case CENTER :
                    x += (textWidth - tokenWidth) / 2;
                    break;
                case RIGHT :
                    x += textWidth - tokenWidth;
                    break;
            }
            if (tokenWidth + x <= clipRectTopRight_x) {
                Rectangle newClipRect = new Rectangle (clipRect);
                newClipRect.width += (tokenWidth / token.length ()) / 2;
                graphics.setClip (newClipRect);
            }
            graphics.drawText (token, x, y);
            graphics.setClip (clipRect);
            y += fontHeight;
            if (isUnderlined) graphics.drawLine (x, y - 1, x + tokenWidth, y - 1);

            if (isStrikedThrough) graphics.drawLine (x, y - fontHeightHalf + 1, x + tokenWidth, y - fontHeightHalf + 1);

        }
    }

    private void paintIcons (Graphics graphics) {
        Point p = Point.SINGLETON;
        p.setLocation (getIconLocation ());
        int num = getNumberofIcons ();
        for (int i = 0;
        i < num; i ++) {
            Image icon = getIcon (i);
            if (icon != null) {
                graphics.drawImage (icon, p);
                p.x += getIconSize (i).width;
            }
        }
    }

    public void setIcon (Image image) {
        setIcon (image, 0);
    }

    public void setIcon (Image image, int index) {
        if (iconInfo == null) {
            if (index == 0) {
                iconInfo = getMapModeConstants ().getSingleIconInfo (image);
            } else {
                iconInfo = new MultiIconInfo ();
                iconInfo.setIcon (image, index);
            }
            revalidate ();
            repaint ();
        } else if (iconInfo.getIcon (index) != image) {
            if (iconInfo.getMaxIcons () == 1) {
                if (index == 0) {
                    iconInfo = getMapModeConstants ().getSingleIconInfo (image);
                    revalidate ();
                    repaint ();
                    return;
                }
                IconInfo oldIconInfo = iconInfo;
                iconInfo = new MultiIconInfo ();
                iconInfo.setIcon (oldIconInfo.getIcon (0), 0);
            }
            iconInfo.setIcon (image, index);
            revalidate ();
            repaint ();
        }

    }

    public void setIconAlignment (int align) {
        if (getIconAlignment () == align) return;

        setAlignmentFlags (align, FLAG_ICON_ALIGN);
        clearLocations ();
        repaint ();
    }

    protected Dimension getIconSize (int index) {
        if (iconInfo == null) return EMPTY_DIMENSION;

        return iconInfo.getIconSize (getFigureMapMode (), index);
    }

    protected int getNumberofIcons () {
        if (iconInfo == null) return 0;

        return iconInfo.getNumberofIcons ();
    }

    protected Dimension getTotalIconSize () {
        if (iconInfo == null) return EMPTY_DIMENSION;

        return iconInfo.getTotalIconSize (getFigureMapMode ());
    }

    public void setLabelAlignment (int align) {
        if (getLabelAlignment () == align) return;

        setAlignmentFlags (align, FLAG_LABEL_ALIGN);
        clearLocations ();
        repaint ();
    }

    protected String getEllipse () {
        return _ellipse;
    }

    public void setText (String s) {
        if (s == null) s = "";

        if (text.equals (s)) return;

        text = s;
        revalidate ();
        repaint ();
    }

    public void setTextAlignment (int align) {
        if (getTextAlignment () == align) return;

        setAlignmentFlags (align, FLAG_TEXT_ALIGN);
        clearLocations ();
        repaint ();
    }

    public void setTextPlacement (int where) {
        if (getTextPlacement () == where) return;

        setPlacementFlags (where, FLAG_TEXT_PLACEMENT);
        revalidate ();
        repaint ();
    }

    public void setTextUnderline (boolean b) {
        if (isTextUnderlined () == b) return;

        setFlag (FLAG_UNDERLINED, b);
        repaint ();
    }

    public boolean isTextUnderlined () {
        return (flags & FLAG_UNDERLINED) != 0;
    }

    public void setTextStrikeThrough (boolean b) {
        if (isTextStrikedThrough () == b) return;

        setFlag (FLAG_STRIKEDTHROUGH, b);
        repaint ();
    }

    public boolean isTextStrikedThrough () {
        return (flags & FLAG_STRIKEDTHROUGH) != 0;
    }

    public void setTextWrap (boolean b) {
        if (isTextWrapped () == b) return;

        setFlag (FLAG_WRAP, b);
        revalidate ();
        repaint ();
    }

    public boolean isTextWrapped () {
        return (flags & FLAG_WRAP) != 0;
    }

    public void setTextWrapWidth (int i) {
    }

    public void setTextWrapAlignment (int i) {
        if (getTextWrapAlignment () == i) return;

        setAlignmentFlags (i, FLAG_WRAP_ALIGN);
        repaint ();
    }

    public int getTextWrapAlignment () {
        return getAlignment (FLAG_WRAP_ALIGN);
    }

    private void setPlacementFlags (int align, int flagOffset) {
        flags &= ~ (0x7 * flagOffset);
        switch (align) {
            case EAST :
                flags |= 0x1 * flagOffset;
                break;
            case WEST :
                flags |= 0x2 * flagOffset;
                break;
            case NORTH :
                flags |= 0x3 * flagOffset;
                break;
            case SOUTH :
                flags |= 0x4 * flagOffset;
                break;
        }
    }

    private int getPlacement (int flagOffset) {
        int wrapValue = flags & (0x7 * flagOffset);
        if (wrapValue == 0x1 * flagOffset) return EAST;
        else if (wrapValue == 0x2 * flagOffset) return WEST;
        else if (wrapValue == 0x3 * flagOffset) return NORTH;
        else if (wrapValue == 0x4 * flagOffset) return SOUTH;

        return EAST;
    }

    private void setAlignmentFlags (int align, int flagOffset) {
        flags &= ~ (0x7 * flagOffset);
        switch (align) {
            case CENTER :
                flags |= 0x1 * flagOffset;
                break;
            case TOP :
                flags |= 0x2 * flagOffset;
                break;
            case LEFT :
                flags |= 0x3 * flagOffset;
                break;
            case RIGHT :
                flags |= 0x4 * flagOffset;
                break;
            case BOTTOM :
                flags |= 0x5 * flagOffset;
                break;
        }
    }

    private int getAlignment (int flagOffset) {
        int wrapValue = flags & (0x7 * flagOffset);
        if (wrapValue == 0x1 * flagOffset) return CENTER;
        else if (wrapValue == 0x2 * flagOffset) return TOP;
        else if (wrapValue == 0x3 * flagOffset) return LEFT;
        else if (wrapValue == 0x4 * flagOffset) return RIGHT;
        else if (wrapValue == 0x5 * flagOffset) return BOTTOM;

        return CENTER;
    }

    public void setSelected (boolean b) {
        if (isSelected () == b) return;

        setFlag (FLAG_SELECTED, b);
        repaint ();
    }

    public boolean isSelected () {
        return (flags & FLAG_SELECTED) != 0;
    }

    public void setFocus (boolean b) {
        if (hasFocus () == b) return;

        setFlag (FLAG_HASFOCUS, b);
        repaint ();
    }

    public boolean hasFocus () {
        return (flags & FLAG_HASFOCUS) != 0;
    }

    private Rectangle getSelectionRectangle () {
        Rectangle figBounds = getTextBounds ();
        int expansion = getMapModeConstants ().nDPtoLP_2;
        figBounds.resize (expansion, expansion);
        translateToParent (figBounds);
        figBounds.intersect (getBounds ());
        return figBounds;
    }

    private int getLineWrapPosition (String s, Font f, int w, int fontHeight) {
        if (getTextExtents (s, f, fontHeight).width <= w) {
            return s.length ();
        }
        BreakIterator iter = BreakIterator.getLineInstance ();
        iter.setText (s);
        int start = iter.first ();
        int end = iter.next ();
        if (getTextExtents (s.substring (start, end), f, fontHeight).width > w) {
            iter = BreakIterator.getCharacterInstance ();
            iter.setText (s);
            start = iter.first ();
        }
        do end = iter.next ();
        while (end != BreakIterator.DONE && getTextExtents (s.substring (start, end), f, fontHeight).width <= w);
        return (end == BreakIterator.DONE) ? iter.last () : iter.previous ();
    }

    private int getLargestSubstringConfinedTo (String s, Font f, int w, int fontHeight, int charAverageWidth) {
        float avg = charAverageWidth;
        int min = 0;
        int max = s.length () + 1;
        int guess = 0, guessSize = 0;
        while ((max - min) > 1) {
            guess = guess + (int) ((w - guessSize) / avg);
            if (guess >= max) guess = max - 1;

            if (guess <= min) guess = min + 1;

            guessSize = getTextExtents (s.substring (0, guess), f, fontHeight).width;
            if (guessSize < w) min = guess;
            else max = guess;

        }
        return min;
    }

    private Dimension getTextExtents (String s, Font f, int fontHeight) {
        if (s.length () == 0) {
            return getMapModeConstants ().dimension_nDPtoLP_0;
        } else {
            Dimension d = FigureUtilities.getTextExtents (s, f);
            IMapMode mapMode = getFigureMapMode ();
            d.width = mapMode.DPtoLP (d.width);
            d.height = fontHeight * new StringTokenizer (s, "\n").countTokens ();
            return d;
        }
    }

}

