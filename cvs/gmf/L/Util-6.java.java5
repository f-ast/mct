package org.eclipse.gmf.runtime.emf.core.internal.util;

import java.util.Iterator;

import java.util.Set;

import org.eclipse.core.resources.IContainer;

import org.eclipse.core.resources.ResourcesPlugin;

import org.eclipse.emf.common.util.URI;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.EReference;

import org.eclipse.emf.ecore.resource.Resource;

import org.eclipse.emf.ecore.resource.ResourceSet;

import org.eclipse.emf.ecore.util.EcoreUtil;

import org.eclipse.emf.transaction.TransactionalEditingDomain;

import org.eclipse.gmf.runtime.emf.core.internal.resources.PathmapManager;

import org.eclipse.gmf.runtime.emf.core.resources.IResourceHelper;

import com.ibm.icu.util.StringTokenizer;

public class Util {
    private static final String pathDelimiter = String.valueOf (EMFCoreConstants.PATH_SEPARATOR);
    private static final String colonEscaped = "%3A";

    private Util () {
        super ();
    }

    public static IResourceHelper getHelper (Resource resource) {
        IResourceHelper result = null;
        if (resource != null) {
            result = (IResourceHelper) EcoreUtil.getExistingAdapter (resource, IResourceHelper.class);
        }
        return result;
    }

    public static String encodeQualifiedName (String qName) {
        return appendQualifiedName (new StringBuffer (), qName).toString ();
    }

    public static StringBuffer appendQualifiedName (StringBuffer buffer, String qName) {
        String [] segments = qName.split (EMFCoreConstants.QUALIFIED_NAME_SEPARATOR);
        for (int i = 0;
        i < segments.length; i ++) {
            String encodedSegment = URI.encodeSegment (segments [i], true);
            for (int j = 0, length = encodedSegment.length ();
            j < length; j ++) {
                char c = encodedSegment.charAt (j);
                if (':' == c) {
                    buffer.append (colonEscaped);
                } else {
                    buffer.append (c);
                }
            }
            if (i + 1 < segments.length) {
                buffer.append (EMFCoreConstants.PATH_SEPARATOR);
            }
        }
        return buffer;
    }

    public static String decodeQName (String qName) {
        StringBuffer buffer = new StringBuffer ();
        for (StringTokenizer st = new StringTokenizer (qName, pathDelimiter);
        st.hasMoreTokens ();) {
            buffer.append (URI.decode (st.nextToken ()));
            if (st.hasMoreTokens ()) buffer.append (EMFCoreConstants.QUALIFIED_NAME_SEPARATOR);

        }
        return buffer.toString ();
    }

    public static URI denormalizeURI (URI uri, ResourceSet rset) {
        URI denormalizedURI = uri;
        if ("file".equals (denormalizedURI.scheme ())) {
            IContainer [] containers = ResourcesPlugin.getWorkspace ().getRoot ().findContainersForLocationURI (java.net.URI.create (denormalizedURI.toString ()));
            if (containers.length == 1) {
                denormalizedURI = URI.createPlatformResourceURI (containers [0].getFullPath ().toString (), true);
            }
        }
        denormalizedURI = PathmapManager.denormalizeURI (denormalizedURI);
        return denormalizedURI;
    }

    public static String getProxyID (EObject proxy) {
        URI uri = EcoreUtil.getURI (proxy);
        String uriFragment = uri.fragment ();
        int index = uriFragment.indexOf (EMFCoreConstants.FRAGMENT_SEPARATOR);
        return index != - 1 ? uriFragment.substring (0, index) : uriFragment;
    }

    public static EObject resolve (TransactionalEditingDomain domain, EObject proxy) {
        EObject resolved = EcoreUtil.resolve (proxy, domain.getResourceSet ());
        return (resolved.eIsProxy () ? null : resolved);
    }

    public static boolean canContain (EClass class1, EClass class2, Set visited) {
        Iterator i = class1.getEAllReferences ().iterator ();
        while (i.hasNext ()) {
            EReference reference = (EReference) i.next ();
            if (reference.isContainment ()) {
                EClass eType = (EClass) reference.getEType ();
                if ((eType.equals (class2)) || (eType.isSuperTypeOf (class2))) {
                    return true;
                }
            }
        }
        if ((visited != null) && (! visited.contains (class1))) {
            visited.add (class1);
            i = class1.getEAllReferences ().iterator ();
            while (i.hasNext ()) {
                EReference reference = (EReference) i.next ();
                if (reference.isContainment ()) {
                    EClass eType = (EClass) reference.getEType ();
                    if (canContain (eType, class2, visited)) return true;

                }
            }
        }
        return false;
    }

}

