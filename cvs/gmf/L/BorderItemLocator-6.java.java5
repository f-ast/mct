package org.eclipse.gmf.runtime.diagram.ui.figures;

import java.util.List;

import java.util.ListIterator;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;

import org.eclipse.jface.util.Assert;

public class BorderItemLocator implements IBorderItemLocator {
    private IFigure parentFigure = null;
    private Rectangle constraint = new Rectangle (0, 0, 0, 0);
    private Dimension borderItemOffset = new Dimension (1, 1);
    private int preferredSide = PositionConstants.WEST;
    private int currentSide = PositionConstants.WEST;

    protected Rectangle getConstraint () {
        return constraint;
    }

    public BorderItemLocator (IFigure parentFigure) {
        Assert.isNotNull (parentFigure);
        this.parentFigure = parentFigure;
    }

    public BorderItemLocator (IFigure parentFigure, int preferredSide) {
        this (parentFigure);
        this.preferredSide = preferredSide;
    }

    public BorderItemLocator (IFigure borderItem, IFigure parentFigure, Rectangle constraint) {
        this (parentFigure);
        setConstraint (constraint);
    }

    public void setConstraint (Rectangle theConstraint) {
        this.constraint = theConstraint;
        if (theConstraint.getTopLeft ().x == 0 || theConstraint.getTopLeft ().y == 0) {
            setCurrentSideOfParent (getPreferredSideOfParent ());
        }
        getParentFigure ().revalidate ();
    }

    protected Point getPreferredLocation (IFigure borderItem) {
        Point constraintLocation = getConstraint ().getLocation ();
        Point ptAbsoluteLocation = this.getAbsoluteToBorder (constraintLocation);
        if (constraintLocation.x == 0 || constraintLocation.y == 0) {
            return getPreferredLocation (getPreferredSideOfParent (), borderItem);
        } else {
            return ptAbsoluteLocation;
        }
    }

    protected Rectangle getParentBorder () {
        Rectangle bounds = getParentFigure ().getBounds ().getCopy ();
        if (getParentFigure () instanceof NodeFigure) {
            bounds = ((NodeFigure) getParentFigure ()).getHandleBounds ().getCopy ();
        }
        return bounds;
    }

    protected Point getPreferredLocation (int side, IFigure borderItem) {
        Rectangle bounds = getParentBorder ();
        int parentFigureWidth = bounds.width;
        int parentFigureHeight = bounds.height;
        int parentFigureX = bounds.x;
        int parentFigureY = bounds.y;
        int x = parentFigureX;
        int y = parentFigureY;
        Dimension borderItemSize = getSize (borderItem);
        if (side == PositionConstants.WEST) {
            x = parentFigureX - borderItemSize.width + getBorderItemOffset ().width;
            y += parentFigureHeight / 2;
        } else if (side == PositionConstants.EAST) {
            x = parentFigureX + parentFigureWidth - getBorderItemOffset ().width;
            y += parentFigureHeight / 2;
        } else if (side == PositionConstants.NORTH) {
            y = parentFigureY - borderItemSize.height + getBorderItemOffset ().height;
            x += parentFigureWidth / 2;
        } else if (side == PositionConstants.SOUTH) {
            x += parentFigureWidth / 2;
            y = parentFigureY + parentFigureHeight - getBorderItemOffset ().height;
        }

        return new Point (x, y);
    }

    private Point locateOnParent (Point suggestedLocation, int suggestedSide, IFigure borderItem) {
        Rectangle bounds = getParentBorder ();
        int parentFigureWidth = bounds.width;
        int parentFigureHeight = bounds.height;
        int parentFigureX = bounds.x;
        int parentFigureY = bounds.y;
        Dimension borderItemSize = getSize (borderItem);
        int newX = suggestedLocation.x;
        int newY = suggestedLocation.y;
        int westX = parentFigureX - borderItemSize.width + getBorderItemOffset ().width;
        int eastX = parentFigureX + parentFigureWidth - getBorderItemOffset ().width;
        int southY = parentFigureY + parentFigureHeight - getBorderItemOffset ().height;
        int northY = parentFigureY - borderItemSize.height + getBorderItemOffset ().height;
        if (suggestedSide == PositionConstants.WEST) {
            if (suggestedLocation.x != westX) {
                newX = westX;
            }
            if (suggestedLocation.y < bounds.getTopLeft ().y) {
                newY = northY + borderItemSize.height;
            } else if (suggestedLocation.y > bounds.getBottomLeft ().y - borderItemSize.height) {
                newY = southY - borderItemSize.height;
            }

        } else if (suggestedSide == PositionConstants.EAST) {
            if (suggestedLocation.x != eastX) {
                newX = eastX;
            }
            if (suggestedLocation.y < bounds.getTopLeft ().y) {
                newY = northY + borderItemSize.height;
            } else if (suggestedLocation.y > bounds.getBottomLeft ().y - borderItemSize.height) {
                newY = southY - borderItemSize.height;
            }

        } else if (suggestedSide == PositionConstants.SOUTH) {
            if (suggestedLocation.y != southY) {
                newY = southY;
            }
            if (suggestedLocation.x < bounds.getBottomLeft ().x) {
                newX = westX + borderItemSize.width;
            } else if (suggestedLocation.x > bounds.getBottomRight ().x - borderItemSize.width) {
                newX = eastX - borderItemSize.width;
            }

        } else {
            if (suggestedLocation.y != northY) {
                newY = northY;
            }
            if (suggestedLocation.x < bounds.getBottomLeft ().x) {
                newX = westX + borderItemSize.width;
            } else if (suggestedLocation.x > bounds.getBottomRight ().x - borderItemSize.width) {
                newX = eastX - borderItemSize.width;
            }

        }

        return new Point (newX, newY);
    }

    private boolean conflicts (Point recommendedLocation, IFigure targetBorderItem) {
        Rectangle recommendedRect = new Rectangle (recommendedLocation, targetBorderItem.getSize ());
        List borderItems = targetBorderItem.getParent ().getChildren ();
        ListIterator iterator = borderItems.listIterator ();
        while (iterator.hasNext ()) {
            IFigure borderItem = (IFigure) iterator.next ();
            if (borderItem.isVisible ()) {
                Rectangle rect = borderItem.getBounds ().getCopy ();
                if (borderItem != targetBorderItem && rect.intersects (recommendedRect)) {
                    return true;
                }
            }
        }
        return false;
    }

    private Point locateOnBorder (Point suggestedLocation, int suggestedSide, int circuitCount, IFigure borderItem) {
        Point recommendedLocation = locateOnParent (suggestedLocation, suggestedSide, borderItem);
        int vertical_gap = MapModeUtil.getMapMode (getParentFigure ()).DPtoLP (8);
        int horizontal_gap = MapModeUtil.getMapMode (getParentFigure ()).DPtoLP (8);
        Dimension borderItemSize = getSize (borderItem);
        if (circuitCount < 4 && conflicts (recommendedLocation, borderItem)) {
            if (suggestedSide == PositionConstants.WEST) {
                do {
                    recommendedLocation.y += borderItemSize.height + vertical_gap;
                } while (conflicts (recommendedLocation, borderItem));
                if (recommendedLocation.y > getParentBorder ().getBottomLeft ().y - borderItemSize.height) {
                    return locateOnBorder (recommendedLocation, PositionConstants.SOUTH, circuitCount + 1, borderItem);
                }
            } else if (suggestedSide == PositionConstants.SOUTH) {
                do {
                    recommendedLocation.x += borderItemSize.width + horizontal_gap;
                } while (conflicts (recommendedLocation, borderItem));
                if (recommendedLocation.x > getParentBorder ().getBottomRight ().x - borderItemSize.width) {
                    return locateOnBorder (recommendedLocation, PositionConstants.EAST, circuitCount + 1, borderItem);
                }
            } else if (suggestedSide == PositionConstants.EAST) {
                do {
                    recommendedLocation.y -= (borderItemSize.height + vertical_gap);
                } while (conflicts (recommendedLocation, borderItem));
                if (recommendedLocation.y < getParentBorder ().getTopRight ().y) {
                    return locateOnBorder (recommendedLocation, PositionConstants.NORTH, circuitCount + 1, borderItem);
                }
            } else {
                do {
                    recommendedLocation.x -= (borderItemSize.width + horizontal_gap);
                } while (conflicts (recommendedLocation, borderItem));
                if (recommendedLocation.x < getParentBorder ().getTopLeft ().x) {
                    return locateOnBorder (recommendedLocation, PositionConstants.WEST, circuitCount + 1, borderItem);
                }
            }

        }
        return recommendedLocation;
    }

    protected Point getAbsoluteToBorder (Point ptRelativeOffset) {
        Point parentOrigin = getParentBorder ().getTopLeft ();
        return parentOrigin.translate (ptRelativeOffset);
    }

    public Rectangle getValidLocation (Rectangle proposedLocation, IFigure borderItem) {
        Rectangle realLocation = new Rectangle (proposedLocation);
        int side = findClosestSideOfParent (proposedLocation, getParentBorder ());
        Point newTopLeft = locateOnBorder (realLocation.getTopLeft (), side, 0, borderItem);
        realLocation.setLocation (newTopLeft);
        return realLocation;
    }

    public static int findClosestSideOfParent (Rectangle proposedLocation, Rectangle parentBorder) {
        Point parentCenter = parentBorder.getCenter ();
        Point childCenter = proposedLocation.getCenter ();
        if (childCenter.x < parentCenter.x) {
            if (childCenter.y < parentCenter.y) {
                Point parentTopLeft = parentBorder.getTopLeft ();
                if ((childCenter.x - parentTopLeft.x) <= (childCenter.y - parentTopLeft.y)) {
                    return PositionConstants.WEST;
                } else {
                    return PositionConstants.NORTH;
                }
            } else {
                Point parentBottomLeft = parentBorder.getBottomLeft ();
                if ((childCenter.x - parentBottomLeft.x) <= (parentBottomLeft.y - childCenter.y)) {
                    return PositionConstants.WEST;
                } else {
                    return PositionConstants.SOUTH;
                }
            }
        } else {
            if (childCenter.y < parentCenter.y) {
                Point parentTopRight = parentBorder.getTopRight ();
                if ((parentTopRight.x - childCenter.x) <= (childCenter.y - parentTopRight.y)) {
                    return PositionConstants.EAST;
                } else {
                    return PositionConstants.NORTH;
                }
            } else {
                Point parentBottomRight = parentBorder.getBottomRight ();
                if ((parentBottomRight.x - childCenter.x) <= (parentBottomRight.y - childCenter.y)) {
                    return PositionConstants.EAST;
                } else {
                    return PositionConstants.SOUTH;
                }
            }
        }
    }

    public void relocate (IFigure borderItem) {
        Dimension size = getSize (borderItem);
        Rectangle rectSuggested = new Rectangle (getPreferredLocation (borderItem), size);
        int closestSide = findClosestSideOfParent (rectSuggested, getParentBorder ());
        setPreferredSideOfParent (closestSide);
        Point ptNewLocation = locateOnBorder (getPreferredLocation (borderItem), getPreferredSideOfParent (), 0, borderItem);
        borderItem.setLocation (ptNewLocation);
        borderItem.setSize (size);
        setCurrentSideOfParent (findClosestSideOfParent (new Rectangle (ptNewLocation, size), getParentBorder ()));
    }

    public IFigure getParentFigure () {
        return parentFigure;
    }

    public Dimension getBorderItemOffset () {
        return borderItemOffset;
    }

    public void setBorderItemOffset (Dimension borderItemOffset) {
        this.borderItemOffset = borderItemOffset;
    }

    public int getPreferredSideOfParent () {
        return preferredSide;
    }

    public void setPreferredSideOfParent (int preferredSide) {
        this.preferredSide = preferredSide;
        setCurrentSideOfParent (preferredSide);
    }

    public int getCurrentSideOfParent () {
        return currentSide;
    }

    public void setCurrentSideOfParent (int side) {
        this.currentSide = side;
    }

    protected final Dimension getSize (IFigure borderItem) {
        Dimension size = getConstraint ().getSize ();
        if (LayoutHelper.UNDEFINED.getSize ().equals (size)) {
            size = borderItem.getPreferredSize ();
        }
        return size;
    }

}

