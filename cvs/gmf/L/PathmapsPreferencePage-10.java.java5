package org.eclipse.gmf.runtime.emf.ui.preferences;

import java.io.File;

import java.util.Arrays;

import java.util.HashMap;

import java.util.HashSet;

import java.util.Iterator;

import java.util.Map;

import java.util.Set;

import org.eclipse.core.resources.IPathVariableManager;

import org.eclipse.core.resources.ResourcesPlugin;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.IPath;

import org.eclipse.core.runtime.Path;

import org.eclipse.emf.common.util.URI;

import org.eclipse.gmf.runtime.emf.core.internal.resources.PathmapManager;

import org.eclipse.gmf.runtime.emf.ui.internal.MslUIPlugin;

import org.eclipse.gmf.runtime.emf.ui.internal.l10n.EMFUIMessages;

import org.eclipse.jface.dialogs.ErrorDialog;

import org.eclipse.jface.preference.PreferencePage;

import org.eclipse.jface.viewers.CheckStateChangedEvent;

import org.eclipse.jface.viewers.CheckboxTableViewer;

import org.eclipse.jface.viewers.ICheckStateListener;

import org.eclipse.jface.viewers.IColorProvider;

import org.eclipse.jface.viewers.ILabelProviderListener;

import org.eclipse.jface.viewers.ISelection;

import org.eclipse.jface.viewers.ISelectionChangedListener;

import org.eclipse.jface.viewers.IStructuredContentProvider;

import org.eclipse.jface.viewers.IStructuredSelection;

import org.eclipse.jface.viewers.ITableLabelProvider;

import org.eclipse.jface.viewers.SelectionChangedEvent;

import org.eclipse.jface.viewers.StructuredSelection;

import org.eclipse.jface.viewers.TableViewer;

import org.eclipse.jface.viewers.Viewer;

import org.eclipse.jface.viewers.ViewerComparator;

import org.eclipse.osgi.util.NLS;

import org.eclipse.osgi.util.TextProcessor;

import org.eclipse.swt.SWT;

import org.eclipse.swt.custom.ScrolledComposite;

import org.eclipse.swt.events.SelectionAdapter;

import org.eclipse.swt.events.SelectionEvent;

import org.eclipse.swt.graphics.Color;

import org.eclipse.swt.graphics.Image;

import org.eclipse.swt.layout.GridData;

import org.eclipse.swt.layout.GridLayout;

import org.eclipse.swt.widgets.Button;

import org.eclipse.swt.widgets.Composite;

import org.eclipse.swt.widgets.Control;

import org.eclipse.swt.widgets.Label;

import org.eclipse.ui.ISharedImages;

import org.eclipse.ui.IWorkbench;

import org.eclipse.ui.IWorkbenchPreferencePage;

import org.eclipse.ui.dialogs.PreferenceLinkArea;

import org.eclipse.ui.preferences.IWorkbenchPreferenceContainer;

public class PathmapsPreferencePage extends PreferencePage implements IWorkbenchPreferencePage {
    private static final String NAME_ATTRIBUTE = "name";
    private IPathVariableManager pathVariableManager = ResourcesPlugin.getWorkspace ().getPathVariableManager ();
    private ScrolledComposite pathVariablesScroll;
    private CheckboxTableViewer pathVariables;
    private PathVariableContentProvider pathVariablesContent;
    private Button newVariable;
    private Button editVariable;
    private Button removeVariable;
    private Map variableChanges = new HashMap ();
    private Object addedToken = new Object ();
    private Object changedToken = new Object ();
    private Object removedToken = new Object ();

    protected void initHelp () {
    }

    protected Control createContents (Composite parent) {
        GridData gridData = null;
        Composite composite = new Composite (parent, SWT.NONE);
        composite.setFont (parent.getFont ());
        composite.setLayout (new GridLayout (2, false));
        PreferenceLinkArea pathVariablesArea = new PreferenceLinkArea (composite, SWT.NONE, "org.eclipse.ui.preferencePages.LinkedResources", EMFUIMessages.PathmapsPreferencePage_mainDescription, (IWorkbenchPreferenceContainer) getContainer (), null);
        gridData = new GridData (GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
        gridData.grabExcessHorizontalSpace = true;
        gridData.grabExcessVerticalSpace = false;
        gridData.horizontalSpan = 2;
        pathVariablesArea.getControl ().setLayoutData (gridData);
        Label pathVariablesLabel = new Label (composite, SWT.LEFT);
        gridData = new GridData (GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
        gridData.grabExcessHorizontalSpace = true;
        gridData.grabExcessVerticalSpace = false;
        gridData.horizontalSpan = 2;
        gridData.verticalIndent = 20;
        pathVariablesLabel.setLayoutData (gridData);
        pathVariablesLabel.setText (EMFUIMessages.PathmapsPreferencePage_availablePathVariables);
        pathVariablesScroll = new ScrolledComposite (composite, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
        pathVariablesScroll.setExpandHorizontal (true);
        pathVariablesScroll.setExpandVertical (true);
        gridData = new GridData (GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
        gridData.grabExcessHorizontalSpace = true;
        gridData.grabExcessVerticalSpace = true;
        gridData.horizontalSpan = 1;
        pathVariablesScroll.setLayoutData (gridData);
        pathVariables = CheckboxTableViewer.newCheckList (pathVariablesScroll, SWT.MULTI);
        pathVariablesScroll.setContent (pathVariables.getTable ());
        pathVariablesContent = new PathVariableContentProvider ();
        pathVariables.setContentProvider (pathVariablesContent);
        pathVariables.setLabelProvider (new PathVariableLabelProvider ());
        pathVariables.setComparator (new PathVariableViewerComparator ());
        Composite buttonComposite = new Composite (composite, SWT.NONE);
        buttonComposite.setLayout (new GridLayout (1, false));
        gridData = new GridData (GridData.FILL_HORIZONTAL);
        gridData.grabExcessHorizontalSpace = false;
        gridData.grabExcessVerticalSpace = false;
        gridData.horizontalSpan = 1;
        gridData.verticalAlignment = GridData.BEGINNING;
        buttonComposite.setLayoutData (gridData);
        newVariable = new Button (buttonComposite, SWT.CENTER);
        newVariable.setText (EMFUIMessages.PathmapsPreferencePage_newVariable);
        setButtonLayoutData (newVariable);
        editVariable = new Button (buttonComposite, SWT.CENTER);
        editVariable.setText (EMFUIMessages.PathmapsPreferencePage_editVariable);
        setButtonLayoutData (editVariable);
        removeVariable = new Button (buttonComposite, SWT.CENTER);
        removeVariable.setText (EMFUIMessages.PathmapsPreferencePage_removeVariable);
        setButtonLayoutData (removeVariable);
        pathVariables.addSelectionChangedListener (new ISelectionChangedListener () {

            public void selectionChanged (SelectionChangedEvent event) {
                pathVariableSelected (event.getSelection ());
            }

        }

        );
        pathVariables.addCheckStateListener (new ICheckStateListener () {

            public void checkStateChanged (CheckStateChangedEvent event) {
                pathVariableChecked (event, (PathVariableEntry) event.getElement ());
            }

        }

        );
        newVariable.addSelectionListener (new SelectionAdapter () {

            public void widgetSelected (SelectionEvent e) {
                addPathVariable ();
            }

        }

        );
        editVariable.addSelectionListener (new SelectionAdapter () {

            public void widgetSelected (SelectionEvent e) {
                editPathVariable (pathVariables.getSelection ());
            }

        }

        );
        removeVariable.addSelectionListener (new SelectionAdapter () {

            public void widgetSelected (SelectionEvent e) {
                removePathVariable (pathVariables.getSelection ());
            }

        }

        );
        initializeContents ();
        applyDialogFont (composite);
        pathVariableSelected (pathVariables.getSelection ());
        return composite;
    }

    private void pathVariableChecked (CheckStateChangedEvent event, PathVariableEntry entry) {
        if (event.getChecked ()) {
            if (validateSelection (entry, false)) {
                entry.setSelected (true);
            } else {
                event.getCheckable ().setChecked (entry, false);
            }
        } else {
            if (validateDeselection (entry, false)) {
                entry.setSelected (false);
            } else {
                event.getCheckable ().setChecked (entry, true);
            }
        }
    }

    private void pathVariableSelected (ISelection selection) {
        IStructuredSelection ssel = (IStructuredSelection) selection;
        editVariable.setEnabled (validateEdit (ssel, false));
        removeVariable.setEnabled (validateRemove (ssel, false));
    }

    private void markAdded (String variableName) {
        Object currentChange = variableChanges.get (variableName);
        if (currentChange == removedToken) {
            variableChanges.put (variableName, changedToken);
        } else if (currentChange != changedToken) {
            variableChanges.put (variableName, addedToken);
        }

    }

    boolean isAdded (String variableName) {
        return variableChanges.get (variableName) == addedToken;
    }

    private void markRemoved (String variableName) {
        Object currentChange = variableChanges.get (variableName);
        if (currentChange == addedToken) {
            variableChanges.remove (variableName);
        } else {
            variableChanges.put (variableName, removedToken);
        }
    }

    boolean isRemoved (String variableName) {
        return variableChanges.get (variableName) == removedToken;
    }

    private void markChanged (String variableName) {
        Object currentChange = variableChanges.get (variableName);
        if (currentChange == addedToken) {
        } else {
            variableChanges.put (variableName, changedToken);
        }
    }

    boolean isChanged (String variableName) {
        return variableChanges.get (variableName) == changedToken;
    }

    boolean isLocationDefined (IPath location) {
        for (Iterator iter = pathVariablesContent.entries.iterator ();
        iter.hasNext ();) {
            if (location.equals (((PathVariableEntry) iter.next ()).getLocationPath ())) {
                return true;
            }
        }
        return false;
    }

    private void addPathVariable () {
        NewPathVariableDialog dlg = NewPathVariableDialog.openNew (this);
        if (dlg != null) {
            String name = dlg.getVariableName ();
            IPath location = dlg.getVariableLocation ();
            markAdded (name);
            PathVariableEntry entry = new PathVariableEntry (name, location);
            entry.setSelected (true);
            pathVariablesContent.add (entry);
            pathVariables.setChecked (entry, true);
            pathVariables.setSelection (new StructuredSelection (entry));
        }
    }

    private void editPathVariable (ISelection selection) {
        PathVariableEntry entry = null;
        if (selection instanceof IStructuredSelection) {
            IStructuredSelection ssel = (IStructuredSelection) selection;
            if (! ssel.isEmpty ()) {
                entry = (PathVariableEntry) ssel.getFirstElement ();
            }
        }
        if (entry != null) {
            String oldName = entry.getName ();
            NewPathVariableDialog dlg = NewPathVariableDialog.openEdit (this, oldName, entry.getLocation ());
            if (dlg != null) {
                String newName = dlg.getVariableName ();
                IPath newLocation = dlg.getVariableLocation ();
                boolean nameChanged = ! oldName.equals (newName);
                if (nameChanged) {
                    markAdded (newName);
                    markRemoved (oldName);
                } else {
                    markChanged (oldName);
                }
                entry.setName (newName);
                entry.setLocation (newLocation);
                pathVariables.update (entry, nameChanged ? new String [] {NAME_ATTRIBUTE} : null);
            }
        }
    }

    private void removePathVariable (ISelection selection) {
        Iterator entries = null;
        if (selection instanceof IStructuredSelection) {
            IStructuredSelection ssel = (IStructuredSelection) selection;
            if (! ssel.isEmpty ()) {
                entries = ssel.iterator ();
            }
        }
        if (entries != null) {
            while (entries.hasNext ()) {
                PathVariableEntry entry = (PathVariableEntry) entries.next ();
                String name = entry.getName ();
                markRemoved (name);
                pathVariablesContent.remove (entry);
            }
        }
    }

    private boolean validateSelection (PathVariableEntry entry, boolean showError) {
        String name = entry.getName ();
        if (! PathmapManager.isCompatiblePathVariable (name)) {
            if (showError) {
                setMessage (EMFUIMessages.PathmapsPreferencePage_incompatiblePathVariableErrorMessage, ERROR);
            }
            return false;
        }
        if (PathmapManager.isRegisteredPathVariable (name)) {
            if (showError) {
                setMessage (EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage, ERROR);
            }
            return false;
        }
        return true;
    }

    private boolean validateDeselection (PathVariableEntry entry, boolean showError) {
        if (entry.isRequired ()) {
            if (showError) {
                setMessage (EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage, ERROR);
            }
            return false;
        }
        return true;
    }

    private boolean validateEdit (IStructuredSelection selection, boolean showError) {
        if (selection.isEmpty () || (selection.size () > 1)) {
            return false;
        }
        String name = ((PathVariableEntry) selection.getFirstElement ()).getName ();
        if (PathmapManager.isRegisteredPathVariable (name)) {
            if (showError) {
                setMessage (EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage, ERROR);
            }
            return false;
        }
        return true;
    }

    private boolean validateRemove (IStructuredSelection selection, boolean showError) {
        if (selection.isEmpty ()) {
            return false;
        }
        for (Iterator iter = selection.iterator ();
        iter.hasNext ();) {
            String name = ((PathVariableEntry) iter.next ()).getName ();
            if (PathmapManager.isRegisteredPathVariable (name)) {
                if (showError) {
                    setMessage (EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage, ERROR);
                }
                return false;
            }
        }
        return true;
    }

    private void initializeContents () {
        setMessage (null);
        variableChanges.clear ();
        Set currentVariables = PathmapManager.getPathVariableReferences ();
        Set allVariables = new HashSet ();
        Set checkedVariables = new HashSet ();
        Set pathVariableNames = new HashSet ();
        pathVariableNames.addAll (Arrays.asList (pathVariableManager.getPathVariableNames ()));
        pathVariableNames.addAll (PathmapManager.getAllPathVariables ());
        for (Iterator iter = pathVariableNames.iterator ();
        iter.hasNext ();) {
            String name = (String) iter.next ();
            PathVariableEntry entry;
            if (PathmapManager.isRegisteredPathVariable (name)) {
                String value = PathmapManager.getRegisteredValue (name);
                try {
                    URI uri = URI.createURI (value);
                    if (uri.isFile ()) {
                        value = uri.toFileString ();
                    }
                } catch (RuntimeException e) {
                }
                entry = new PathVariableEntry (name, value);
                checkedVariables.add (entry);
                allVariables.add (entry);
            } else if (PathmapManager.isCompatiblePathVariable (name)) {
                entry = new PathVariableEntry (name, pathVariableManager.getValue (name));
                if (currentVariables.contains (entry.getName ())) {
                    checkedVariables.add (entry);
                    entry.setSelected (true);
                }
                allVariables.add (entry);
            }

        }
        pathVariables.setInput (allVariables);
        pathVariables.setCheckedElements (checkedVariables.toArray ());
    }

    public void init (IWorkbench workbench) {
    }

    protected void performDefaults () {
        initializeContents ();
        super.performDefaults ();
    }

    public boolean performOk () {
        Set currentVariables = PathmapManager.getPathVariableReferences ();
        try {
            for (Iterator iter = variableChanges.keySet ().iterator ();
            iter.hasNext ();) {
                String name = (String) iter.next ();
                if (isRemoved (name)) {
                    if (pathVariableManager.isDefined (name)) {
                        pathVariableManager.setValue (name, null);
                    }
                    PathmapManager.removePathVariableReference (name);
                    iter.remove ();
                }
            }
            Object [] variables = pathVariablesContent.getElements (null);
            for (int i = 0;
            i < variables.length; i ++) {
                PathVariableEntry entry = (PathVariableEntry) variables [i];
                String name = entry.getName ();
                if (isChanged (name) || isAdded (name) && ! pathVariableManager.isDefined (name)) {
                    pathVariableManager.setValue (name, new Path (entry.getLocation ()));
                    variableChanges.remove (name);
                }
                if (entry.isSelected () && ! currentVariables.contains (name)) {
                    PathmapManager.addPathVariableReference (name);
                } else if (! entry.isSelected () && currentVariables.contains (name)) {
                    PathmapManager.removePathVariableReference (name);
                }

            }
            PathmapManager.updatePreferenceStore ();
            return true;
        } catch (CoreException e) {
            ErrorDialog.openError (getShell (), EMFUIMessages.PathmapsPreferencePage_promptTitle, EMFUIMessages.PathmapsPreferencePage_updateFailed, e.getStatus ());
            return false;
        }
    }

    private static class PathVariableContentProvider implements IStructuredContentProvider {
        private Set entries;
        private TableViewer table;

        PathVariableContentProvider () {
            entries = new HashSet ();
        }

        void add (PathVariableEntry entry) {
            if (! entries.contains (entry)) {
                entries.add (entry);
                table.add (entry);
            }
        }

        void remove (PathVariableEntry entry) {
            if (entries.contains (entry)) {
                entries.remove (entry);
                table.remove (entry);
            }
        }

        public Object [] getElements (Object inputElement) {
            return entries.toArray ();
        }

        public void inputChanged (Viewer viewer, Object oldInput, Object newInput) {
            entries = (Set) newInput;
            table = (TableViewer) viewer;
        }

        public void dispose () {
        }

    }

    private static class PathVariableLabelProvider implements ITableLabelProvider, IColorProvider {
        private Image lockImage = null;

        PathVariableLabelProvider () {
            super ();
        }

        public Image getColumnImage (Object element, int columnIndex) {
            PathVariableEntry entry = (PathVariableEntry) element;
            String name = entry.getName ();
            if (PathmapManager.isRegisteredPathVariable (name)) {
                return getLockImage ();
            } else if (! isDirectory (entry.getLocation ())) {
                return MslUIPlugin.getDefault ().getWorkbench ().getSharedImages ().getImage (ISharedImages.IMG_OBJS_WARN_TSK);
            }

            return null;
        }

        private boolean isDirectory (String location) {
            File file = new File (location);
            return file.exists () && file.isDirectory ();
        }

        private Image getLockImage () {
            if (lockImage == null) {
                lockImage = MslUIPlugin.imageDescriptorFromPlugin (MslUIPlugin.getPluginId (), "/icons/full/lock.gif").createImage ();
            }
            return lockImage;
        }

        public String getColumnText (Object element, int columnIndex) {
            if (columnIndex != 0) {
                return null;
            }
            PathVariableEntry entry = (PathVariableEntry) element;
            String pathString = entry.isRequired () ? TextProcessor.process (entry.getLocation (), MslUIPlugin.URI_BIDI_SEPARATORS) : TextProcessor.process (entry.getLocation ());
            return NLS.bind (EMFUIMessages.PathmapsPreferencePage_variablePattern, entry.getName (), pathString);
        }

        public void dispose () {
            if (lockImage != null) {
                lockImage.dispose ();
                lockImage = null;
            }
        }

        public boolean isLabelProperty (Object element, String property) {
            return false;
        }

        public void addListener (ILabelProviderListener listener) {
        }

        public void removeListener (ILabelProviderListener listener) {
        }

        public Color getBackground (Object element) {
            return null;
        }

        public Color getForeground (Object element) {
            return null;
        }

    }

    private static class PathVariableViewerComparator extends ViewerComparator {

        PathVariableViewerComparator () {
            super ();
        }

        public boolean isSorterProperty (Object element, String property) {
            return NAME_ATTRIBUTE.equals (property);
        }

        public int category (Object element) {
            return PathmapManager.isRegisteredPathVariable (((PathVariableEntry) element).getName ()) ? 1 : 0;
        }

    }

    private static final class PathVariableEntry {
        private String name;
        private String location;
        private IPath locationPath;
        private final boolean required;
        private boolean selected;

        PathVariableEntry (String name, IPath location) {
            this (name, location.toPortableString (), false);
            this.locationPath = location;
        }

        PathVariableEntry (String name, String location) {
            this (name, location, true);
        }

        private PathVariableEntry (String name, String location, boolean required) {
            this.name = name;
            this.location = location;
            this.required = required;
            selected = required;
        }

        boolean isRequired () {
            return required;
        }

        String getName () {
            return name;
        }

        void setName (String name) {
            if (! isRequired ()) {
                this.name = name;
            }
        }

        String getLocation () {
            return location;
        }

        IPath getLocationPath () {
            return locationPath;
        }

        void setLocation (IPath location) {
            if (! isRequired ()) {
                this.locationPath = location;
                this.location = location.toPortableString ();
            }
        }

        boolean isSelected () {
            return selected;
        }

        void setSelected (boolean selected) {
            if (! isRequired ()) {
                this.selected = selected;
            }
        }

        public String toString () {
            return getName () + " - " + getLocation ();
        }

    }

}

