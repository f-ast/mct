package org.eclipse.gmf.internal.xpand.util;

import java.io.FileNotFoundException;

import java.io.IOException;

import java.io.Reader;

import java.util.Map;

import java.util.TreeMap;

import org.eclipse.gmf.internal.xpand.Activator;

import org.eclipse.gmf.internal.xpand.ResourceManager;

import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;

import org.eclipse.gmf.internal.xpand.model.XpandResource;

import org.eclipse.gmf.internal.xpand.xtend.ast.XtendResource;

public abstract class ResourceManagerImpl implements ResourceManager {
    private final Map < String, XtendResource > cachedXtend = new TreeMap < String, XtendResource > ();
    private final Map < String, XpandResource > cachedXpand = new TreeMap < String, XpandResource > ();

    public XtendResource loadXtendResource (String fullyQualifiedName) {
        if (hasCachedXtend (fullyQualifiedName)) {
            return cachedXtend.get (fullyQualifiedName);
        }
        try {
            final XtendResource loaded = doLoadXtendResource (fullyQualifiedName);
            assert loaded != null;
            if (shouldCache ()) {
                cachedXtend.put (fullyQualifiedName, loaded);
            }
            return loaded;
        } catch (FileNotFoundException ex) {
            return null;
        } catch (IOException ex) {
            Activator.logError (ex);
        } catch (ParserException ex) {
            handleParserException (fullyQualifiedName, ex);
        }
        return null;
    }

    private XtendResource doLoadXtendResource (String fullyQualifiedName) throws IOException, ParserException {
        Reader [] rs = resolveMultiple (fullyQualifiedName, XtendResource.FILE_EXTENSION);
        assert rs != null && rs.length > 0;
        XtendResource [] result = new XtendResource [rs.length];
        for (int i = 0;
        i < rs.length; i ++) {
            Reader r = rs [i];
            assert r != null;
            try {
                result [i] = loadXtendResource (r, fullyQualifiedName);
                assert result [i] != null;
            } finally {
                try {
                    r.close ();
                } catch (Exception ex) {
                }
            }
        }
        if (result.length == 1) {
            return result [0];
        }
        return new CompositeXtendResource (this, result);
    }

    public XpandResource loadXpandResource (String fullyQualifiedName) {
        if (hasCachedXpand (fullyQualifiedName)) {
            return cachedXpand.get (fullyQualifiedName);
        }
        try {
            final XpandResource loaded = doLoadXpandResource (fullyQualifiedName);
            if (shouldCache ()) {
                cachedXpand.put (fullyQualifiedName, loaded);
            }
            return loaded;
        } catch (FileNotFoundException ex) {
            return null;
        } catch (IOException ex) {
            Activator.logWarn (ex.getMessage ());
        } catch (ParserException ex) {
            handleParserException (fullyQualifiedName, ex);
        }
        return null;
    }

    private XpandResource doLoadXpandResource (String fullyQualifiedName) throws IOException, ParserException {
        XpandResource [] unadvised = internalLoadXpandResources (fullyQualifiedName);
        XpandResource [] advices = null;
        try {
            String aspectsTemplateName = getAspectsTemplateName (fullyQualifiedName);
            advices = internalLoadXpandResources (aspectsTemplateName);
        } catch (FileNotFoundException e) {
        } catch (IOException ex) {
            Activator.logWarn (ex.getMessage ());
        } catch (ParserException ex) {
            handleParserException (fullyQualifiedName, ex);
        }
        if (advices == null && unadvised.length == 1) {
            return unadvised [0];
        }
        return new CompositeXpandResource (this, unadvised, advices);
    }

    protected String getAspectsTemplateName (String fullyQualifiedName) {
        return ASPECT_PREFIX + fullyQualifiedName;
    }

    protected String getNonAspectsTemplateName (String possiblyAspectedFullyQualifiedName) {
        if (possiblyAspectedFullyQualifiedName == null) {
            return null;
        }
        if (possiblyAspectedFullyQualifiedName.startsWith (ASPECT_PREFIX)) {
            return possiblyAspectedFullyQualifiedName.substring (ASPECT_PREFIX.length ());
        }
        return possiblyAspectedFullyQualifiedName;
    }

    private XpandResource [] internalLoadXpandResources (String fullyQualifiedName) throws IOException, ParserException {
        Reader [] rs = resolveMultiple (fullyQualifiedName, XpandResource.TEMPLATE_EXTENSION);
        assert rs != null && rs.length > 0;
        XpandResource [] result = new XpandResource [rs.length];
        for (int i = 0;
        i < rs.length; i ++) {
            Reader r = rs [i];
            assert r != null;
            try {
                result [i] = loadXpandResource (r, fullyQualifiedName);
                assert result [i] != null;
            } finally {
                try {
                    r.close ();
                } catch (Exception ex) {
                }
            }
        }
        return result;
    }

    protected void handleParserException (String name, ParserException ex) {
        Activator.logWarn (name + ":" + ex.getClass ().getName ());
    }

    @Deprecated
    protected abstract Reader resolve (String fullyQualifiedName, String extension) throws IOException;

    protected Reader [] resolveMultiple (String fullyQualifiedName, String extension) throws IOException {
        return new Reader [] {resolve (fullyQualifiedName, extension)};
    }

    protected XtendResource loadXtendResource (Reader reader, String fullyQualifiedName) throws IOException, ParserException {
        return new XtendResourceParser ().parse (reader, fullyQualifiedName);
    }

    protected XpandResource loadXpandResource (Reader reader, String fullyQualifiedName) throws IOException, ParserException {
        return new XpandResourceParser ().parse (reader, fullyQualifiedName);
    }

    protected abstract boolean shouldCache ();

    protected final boolean hasCachedXpand (String fullyQualifiedName) {
        return shouldCache () && cachedXpand.containsKey (fullyQualifiedName);
    }

    protected final boolean hasCachedXtend (String fullyQualifiedName) {
        return shouldCache () && cachedXtend.containsKey (fullyQualifiedName);
    }

    protected final void forgetCachedXpand (String fullyQualifiedName) {
        cachedXpand.remove (fullyQualifiedName);
    }

    protected final void forgetCachedXtend (String fullyQualifiedName) {
        cachedXtend.remove (fullyQualifiedName);
    }

    protected final void forgetAll () {
        cachedXpand.clear ();
        cachedXtend.clear ();
    }

    private static final String ASPECT_PREFIX = "aspects" + SyntaxConstants.NS_DELIM;
}

