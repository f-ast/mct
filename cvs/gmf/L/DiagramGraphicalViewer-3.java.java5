package org.eclipse.gmf.runtime.diagram.ui.parts;

import java.util.List;

import org.eclipse.gef.EditPart;

import org.eclipse.gef.ui.parts.ScrollingGraphicalViewer;

import org.eclipse.jface.preference.IPreferenceStore;

import org.eclipse.jface.util.TransferDragSourceListener;

import org.eclipse.jface.util.TransferDropTargetListener;

import org.eclipse.jface.viewers.ISelection;

import org.eclipse.jface.viewers.ISelectionChangedListener;

import org.eclipse.jface.viewers.SelectionChangedEvent;

import org.eclipse.jface.viewers.StructuredSelection;

import org.eclipse.swt.widgets.Display;

import org.eclipse.gmf.runtime.diagram.ui.internal.parts.ElementToEditPartsMap;

public class DiagramGraphicalViewer extends ScrollingGraphicalViewer implements IDiagramGraphicalViewer {

    public DiagramGraphicalViewer () {
        super ();
    }

    private boolean selectionEventPending = false;
    private ElementToEditPartsMap elementToEditPartsMap = new ElementToEditPartsMap ();

    protected void hookControl () {
        super.hookControl ();
    }

    public void removeDragSourceListener (TransferDragSourceListener listener) {
        getDelegatingDragAdapter ().removeDragSourceListener (listener);
        refreshDragSourceAdapter ();
    }

    public void removeDropTargetListener (TransferDropTargetListener listener) {
        getDelegatingDropAdapter ().removeDropTargetListener (listener);
        refreshDropTargetAdapter ();
    }

    public void flush () {
        super.flush ();
        if (selectionEventPending) {
            flushSelectionEvents (getSelection ());
        }
    }

    protected void fireSelectionChanged () {
        if (selectionEventPending) return;

        selectionEventPending = true;
        Display display = Display.getCurrent ();
        if (display != null) {
            display.asyncExec (new Runnable () {

                public void run () {
                    flushSelectionEvents (getSelection ());
                }

            }

            );
        }
    }

    protected void flushSelectionEvents (ISelection sel) {
        selectionEventPending = false;
        SelectionChangedEvent event = new SelectionChangedEvent (this, sel);
        Object [] array = selectionListeners.toArray ();
        for (int i = 0;
        i < array.length; i ++) {
            ISelectionChangedListener l = (ISelectionChangedListener) array [i];
            if (selectionListeners.contains (l)) l.selectionChanged (event);

        }
    }

    private void fireEmptySelection () {
        if (selectionEventPending) return;

        selectionEventPending = true;
        Display display = Display.getCurrent ();
        if (display != null) {
            display.asyncExec (new Runnable () {

                public void run () {
                    flushSelectionEvents (getSelection ());
                    flushSelectionEvents (StructuredSelection.EMPTY);
                }

            }

            );
        }
    }

    public IDiagramEditDomain getDiagramEditDomain () {
        return (IDiagramEditDomain) getEditDomain ();
    }

    public List findEditPartsForElement (String elementIdStr, Class editPartClass) {
        return elementToEditPartsMap.findEditPartsForElement (elementIdStr, editPartClass);
    }

    public void registerEditPartForElement (String elementIdStr, EditPart ep) {
        elementToEditPartsMap.registerEditPartForElement (elementIdStr, ep);
    }

    public void unregisterEditPartForElement (String elementIdStr, EditPart ep) {
        elementToEditPartsMap.unregisterEditPartForElement (elementIdStr, ep);
    }

    private IPreferenceStore workspacePreferenceStore;

    public void hookWorkspacePreferenceStore (IPreferenceStore store) {
        this.workspacePreferenceStore = store;
    }

    public IPreferenceStore getWorkspaceViewerPreferenceStore () {
        return workspacePreferenceStore;
    }

    protected void unhookControl () {
        fireEmptySelection ();
        super.unhookControl ();
    }

}

