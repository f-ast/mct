package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.PositionConstants;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.PrecisionPoint;

import org.eclipse.draw2d.geometry.PrecisionRectangle;

import org.eclipse.draw2d.geometry.Ray;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.common.core.util.StringStatics;

import org.eclipse.gmf.runtime.draw2d.ui.figures.BaseSlidableAnchor;

import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.figures.OrthogonalConnectionAnchor;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

public class RectilinearRouter extends ObliqueRouter implements OrthogonalRouter {
    private static int maxNestedRoutingDepth = 1;

    public void routeLine (Connection conn, int nestedRoutingDepth, PointList newLine) {
        boolean skipNormalization = (routerFlags & ROUTER_FLAG_SKIPNORMALIZATION) != 0;
        if (isReorienting (conn)) {
            super.routeLine (conn, nestedRoutingDepth, newLine);
            return;
        }
        if (checkSelfRelConnection (conn, newLine) || checkShapesIntersect (conn, newLine)) {
            super.resetEndPointsToEdge (conn, newLine);
            OrthogonalRouterUtilities.transformToOrthogonalPointList (newLine, getOffShapeDirection (getAnchorOffRectangleDirection (newLine.getFirstPoint (), sourceBoundsRelativeToConnection (conn))), getOffShapeDirection (getAnchorOffRectangleDirection (newLine.getLastPoint (), targetBoundsRelativeToConnection (conn))));
            return;
        }
        Point lastStartAnchor = newLine.removePoint (0);
        Point lastEndAnchor = newLine.removePoint (newLine.size () - 1);
        if (! OrthogonalRouterUtilities.isRectilinear (newLine)) {
            OrthogonalRouterUtilities.transformToOrthogonalPointList (newLine, PositionConstants.NONE, PositionConstants.NONE);
        }
        removeRedundantPoints (newLine);
        removePointsInViews (conn, newLine, lastStartAnchor, lastEndAnchor);
        Dimension tolerance = new Dimension (3, 0);
        if (! RouterHelper.getInstance ().isFeedback (conn)) tolerance = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (tolerance);

        if (! skipNormalization) {
            if (PointListUtilities.normalizeSegments (newLine, tolerance.width)) {
                normalizeToStraightLineTolerance (newLine, tolerance.width);
            }
        }
        if (newLine.size () == 2) {
            Ray middleSeg = new Ray (newLine.getFirstPoint (), newLine.getLastPoint ());
            if (middleSeg.length () <= tolerance.width) {
                newLine.removePoint (0);
            }
        }
        resetEndPointsToEdge (conn, newLine);
        if (nestedRoutingDepth < maxNestedRoutingDepth && ! isValidRectilinearLine (conn, newLine)) {
            routeLine (conn, ++ nestedRoutingDepth, newLine);
        }
    }

    private boolean isValidRectilinearLine (Connection conn, PointList line) {
        if (! (conn.getSourceAnchor ().getOwner () instanceof Connection)) {
            Rectangle source = new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (conn.getSourceAnchor ().getOwner ()));
            conn.getSourceAnchor ().getOwner ().translateToAbsolute (source);
            conn.translateToRelative (source);
            if (source.contains (line.getPoint (1))) {
                return false;
            }
            int firstSegmentOrientation = line.getFirstPoint ().x == line.getPoint (1).x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
            if (getOutisePointOffRectanglePosition (line.getPoint (1), source) != getAnchorLocationBasedOnSegmentOrientation (line.getFirstPoint (), source, firstSegmentOrientation)) {
                return false;
            }
        }
        if (! (conn.getTargetAnchor ().getOwner () instanceof Connection)) {
            Rectangle target = new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (conn.getTargetAnchor ().getOwner ()));
            conn.getTargetAnchor ().getOwner ().translateToAbsolute (target);
            conn.translateToRelative (target);
            if (target.contains (line.getPoint (line.size () - 2))) {
                return false;
            }
            int lastSegmentOrientation = line.getLastPoint ().x == line.getPoint (line.size () - 2).x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
            if (getOutisePointOffRectanglePosition (line.getPoint (line.size () - 2), target) != getAnchorLocationBasedOnSegmentOrientation (line.getLastPoint (), target, lastSegmentOrientation)) {
                return false;
            }
        }
        return true;
    }

    private void removePointsInViews (Connection conn, PointList newLine, Point start, Point end) {
        PrecisionRectangle source = conn.getSourceAnchor ().getOwner () != null ? new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (conn.getSourceAnchor ().getOwner ())) : null;
        PrecisionRectangle target = conn.getTargetAnchor ().getOwner () != null ? new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (conn.getTargetAnchor ().getOwner ())) : null;
        if (source != null) {
            conn.getSourceAnchor ().getOwner ().translateToAbsolute (source);
            conn.translateToRelative (source);
        }
        if (target != null) {
            conn.getTargetAnchor ().getOwner ().translateToAbsolute (target);
            conn.translateToRelative (target);
        }
        Point lastRemovedFromSource = null;
        Point lastRemovedFromTarget = null;
        if (! (conn.getSourceAnchor ().getOwner () instanceof Connection) && newLine.size () != 0 && source.contains (new PrecisionPoint (newLine.getFirstPoint ()))) {
            lastRemovedFromSource = newLine.removePoint (0);
            for (int i = 0;
            i < newLine.size () && source.contains (new PrecisionPoint (newLine.getPoint (i))); i ++) {
                lastRemovedFromSource = newLine.removePoint (i --);
            }
        }
        if (! (conn.getTargetAnchor ().getOwner () instanceof Connection) && newLine.size () != 0 && target.contains (new PrecisionPoint (newLine.getLastPoint ()))) {
            lastRemovedFromTarget = newLine.removePoint (newLine.size () - 1);
            for (int i = newLine.size ();
            i > 0 && target.contains (new PrecisionPoint (newLine.getPoint (i - 1))); i --) {
                lastRemovedFromTarget = newLine.removePoint (i - 1);
            }
        }
        if (newLine.size () == 0) {
            Dimension tolerance = new Dimension (1, 0);
            if (! RouterHelper.getInstance ().isFeedback (conn)) tolerance = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (tolerance);

            int toleranceValue = tolerance.width;
            if (lastRemovedFromSource == null) {
                lastRemovedFromSource = start;
            }
            if (lastRemovedFromTarget == null) {
                lastRemovedFromTarget = end;
            }
            if (Math.abs (lastRemovedFromSource.x - lastRemovedFromTarget.x) < toleranceValue) {
                if (source.preciseY < target.preciseY) {
                    newLine.addPoint (lastRemovedFromSource.x, (source.getBottom ().y + target.getTop ().y) / 2);
                } else {
                    newLine.addPoint (lastRemovedFromSource.x, (source.getTop ().y + target.getBottom ().y) / 2);
                }
            } else if (Math.abs (lastRemovedFromSource.y - lastRemovedFromTarget.y) < toleranceValue) {
                if (source.preciseX < target.preciseX) {
                    newLine.addPoint ((source.getRight ().x + target.getLeft ().x) / 2, lastRemovedFromSource.y);
                } else {
                    newLine.addPoint ((source.getLeft ().x + target.getRight ().x) / 2, lastRemovedFromSource.y);
                }
            } else if ((conn.getSourceAnchor () instanceof BaseSlidableAnchor && StringStatics.BLANK.equals (((BaseSlidableAnchor) conn.getSourceAnchor ()).getTerminal ()) && (conn.getTargetAnchor () instanceof BaseSlidableAnchor && StringStatics.BLANK.equals (((BaseSlidableAnchor) conn.getTargetAnchor ()).getTerminal ())))) {
                double startX = Math.max (source.preciseX, target.preciseX);
                double endX = Math.min (source.preciseX + source.preciseWidth, target.preciseX + target.preciseWidth);
                double startY = Math.max (source.preciseY, target.preciseY);
                double endY = Math.min (source.preciseY + source.preciseHeight, target.preciseY + target.preciseHeight);
                if (startX < endX) {
                    if (source.preciseY < target.preciseY) {
                        newLine.addPoint ((int) Math.round ((startX + endX) / 2.0), (source.getBottom ().y + target.getTop ().y) / 2);
                    } else {
                        newLine.addPoint ((int) Math.round ((startX + endX) / 2.0), (source.getTop ().y + target.getBottom ().y) / 2);
                    }
                } else if (startY < endY) {
                    if (source.preciseX < target.preciseX) {
                        newLine.addPoint ((source.getRight ().x + target.getLeft ().x) / 2, (int) Math.round ((startY + endY) / 2.0));
                    } else {
                        newLine.addPoint ((source.getLeft ().x + target.getRight ().x) / 2, (int) Math.round ((startY + endY) / 2.0));
                    }
                }

            }

        }
    }

    private int getAnchorOffRectangleDirection (Point anchorPoint, Rectangle rect) {
        int position = PositionConstants.NORTH;
        int criteriaValue = Math.abs (anchorPoint.y - rect.y);
        int tempCriteria = Math.abs (anchorPoint.y - rect.y - rect.height);
        if (tempCriteria < criteriaValue) {
            criteriaValue = tempCriteria;
            position = PositionConstants.SOUTH;
        }
        tempCriteria = Math.abs (anchorPoint.x - rect.x);
        if (tempCriteria < criteriaValue) {
            criteriaValue = tempCriteria;
            position = PositionConstants.WEST;
        }
        tempCriteria = Math.abs (anchorPoint.x - rect.x - rect.width);
        if (tempCriteria < criteriaValue) {
            criteriaValue = tempCriteria;
            position = PositionConstants.EAST;
        }
        return position;
    }

    private Dimension getTranslationValue (int position, int xFactorValue, int yFactorValue) {
        Dimension translationDimension = new Dimension ();
        if (position == PositionConstants.EAST) {
            translationDimension.width = xFactorValue;
        } else if (position == PositionConstants.SOUTH) {
            translationDimension.height = yFactorValue;
        } else if (position == PositionConstants.WEST) {
            translationDimension.width = - xFactorValue;
        } else if (position == PositionConstants.NORTH) {
            translationDimension.height = - yFactorValue;
        }

        return translationDimension;
    }

    private int getOffShapeDirection (int anchorRelativeLocation) {
        if (anchorRelativeLocation == PositionConstants.EAST || anchorRelativeLocation == PositionConstants.WEST) {
            return PositionConstants.HORIZONTAL;
        } else if (anchorRelativeLocation == PositionConstants.NORTH || anchorRelativeLocation == PositionConstants.SOUTH) {
            return PositionConstants.VERTICAL;
        }

        return PositionConstants.NONE;
    }

    protected void resetEndPointsToEdge (Connection conn, PointList line) {
        if (isReorienting (conn)) {
            super.resetEndPointsToEdge (conn, line);
            return;
        }
        PrecisionRectangle source = sourceBoundsRelativeToConnection (conn);
        PrecisionRectangle target = targetBoundsRelativeToConnection (conn);
        int offSourceDirection = PositionConstants.NONE;
        int offTargetDirection = PositionConstants.NONE;
        int sourceAnchorRelativeLocation = PositionConstants.NONE;
        int targetAnchorRelativeLocation = PositionConstants.NONE;
        if (line.size () == 0) {
            line.addPoint (new Point ());
            line.addPoint (new Point ());
            super.resetEndPointsToEdge (conn, line);
            sourceAnchorRelativeLocation = getAnchorOffRectangleDirection (line.getFirstPoint (), source);
            targetAnchorRelativeLocation = getAnchorOffRectangleDirection (line.getLastPoint (), target);
            Point offStart = line.getFirstPoint ();
            Point offEnd = line.getLastPoint ();
            Dimension offsetDim = offStart.getDifference (offEnd).scale (0.5);
            offStart.translate (getTranslationValue (sourceAnchorRelativeLocation, Math.abs (offsetDim.width), Math.abs (offsetDim.height)));
            offEnd.translate (getTranslationValue (targetAnchorRelativeLocation, Math.abs (offsetDim.width), Math.abs (offsetDim.height)));
            line.insertPoint (offStart, 1);
            line.insertPoint (offEnd, 2);
            offSourceDirection = getOffShapeDirection (sourceAnchorRelativeLocation);
            offTargetDirection = getOffShapeDirection (targetAnchorRelativeLocation);
        } else {
            Point start = line.getFirstPoint ();
            Point end = line.getLastPoint ();
            if (conn.getSourceAnchor () instanceof OrthogonalConnectionAnchor) {
                line.insertPoint (OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc (conn, conn.getSourceAnchor (), start).getOrigin (), 0);
            } else {
                PrecisionPoint reference = new PrecisionPoint (start);
                conn.getSourceAnchor ().getOwner ().translateToAbsolute (reference);
                PrecisionPoint anchorLocation = new PrecisionPoint (conn.getSourceAnchor ().getLocation (reference));
                conn.translateToRelative (anchorLocation);
                line.insertPoint (anchorLocation, 0);
            }
            if (conn.getTargetAnchor () instanceof OrthogonalConnectionAnchor) {
                line.addPoint (OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc (conn, conn.getTargetAnchor (), end).getOrigin ());
            } else {
                PrecisionPoint reference = new PrecisionPoint (end);
                conn.getSourceAnchor ().getOwner ().translateToAbsolute (reference);
                PrecisionPoint anchorLocation = new PrecisionPoint (conn.getTargetAnchor ().getLocation (reference));
                conn.translateToRelative (anchorLocation);
                line.addPoint (anchorLocation);
            }
            sourceAnchorRelativeLocation = getAnchorOffRectangleDirection (line.getFirstPoint (), source);
            offSourceDirection = getOffShapeDirection (sourceAnchorRelativeLocation);
            targetAnchorRelativeLocation = getAnchorOffRectangleDirection (line.getLastPoint (), target);
            offTargetDirection = getOffShapeDirection (targetAnchorRelativeLocation);
        }
        OrthogonalRouterUtilities.transformToOrthogonalPointList (line, offSourceDirection, offTargetDirection);
        removeRedundantPoints (line);
    }

    private void normalizeToStraightLineTolerance (PointList line, int tolerance) {
        for (int i = 0;
        i < line.size () - 1; i ++) {
            Point pt1 = line.getPoint (i);
            Point pt2 = line.getPoint (i + 1);
            if (Math.abs (pt1.x - pt2.x) < tolerance) {
                line.setPoint (new Point (pt1.x, pt2.y), i + 1);
            } else if (Math.abs (pt1.y - pt2.y) < tolerance) {
                line.setPoint (new Point (pt2.x, pt1.y), i + 1);
            }

        }
    }

    private PrecisionRectangle sourceBoundsRelativeToConnection (Connection conn) {
        PrecisionRectangle source = new PrecisionRectangle (conn.getSourceAnchor ().getOwner ().getBounds ());
        conn.getSourceAnchor ().getOwner ().translateToAbsolute (source);
        conn.translateToRelative (source);
        return source;
    }

    private PrecisionRectangle targetBoundsRelativeToConnection (Connection conn) {
        PrecisionRectangle target = new PrecisionRectangle (conn.getTargetAnchor ().getOwner ().getBounds ());
        conn.getTargetAnchor ().getOwner ().translateToAbsolute (target);
        conn.translateToRelative (target);
        return target;
    }

    private int getOutisePointOffRectanglePosition (Point p, Rectangle r) {
        int position = PositionConstants.NONE;
        if (r.x > p.x) {
            position |= PositionConstants.WEST;
        } else if (r.x + r.width < p.x) {
            position |= PositionConstants.EAST;
        }

        if (r.y > p.y) {
            position |= PositionConstants.NORTH;
        } else if (r.y + r.height < p.y) {
            position |= PositionConstants.SOUTH;
        }

        return position;
    }

    private int getAnchorLocationBasedOnSegmentOrientation (Point anchorPoint, Rectangle rectangle, int segmentOrientation) {
        if (segmentOrientation == PositionConstants.VERTICAL) {
            if (Math.abs (anchorPoint.y - rectangle.y) < Math.abs (anchorPoint.y - rectangle.y - rectangle.height)) {
                return PositionConstants.NORTH;
            } else {
                return PositionConstants.SOUTH;
            }
        } else if (segmentOrientation == PositionConstants.HORIZONTAL) {
            if (Math.abs (anchorPoint.x - rectangle.x) < Math.abs (anchorPoint.x - rectangle.x - rectangle.width)) {
                return PositionConstants.WEST;
            } else {
                return PositionConstants.EAST;
            }
        }

        return PositionConstants.NONE;
    }

    private boolean removeRedundantPoints (PointList line) {
        int initialNumberOfPoints = line.size ();
        if (line.size () > 2) {
            PointList newLine = new PointList (line.size ());
            newLine.addPoint (line.removePoint (0));
            while (line.size () >= 2) {
                Point p0 = newLine.getLastPoint ();
                Point p1 = line.getPoint (0);
                Point p2 = line.getPoint (1);
                if (p0.x == p1.x && p0.x == p2.x) {
                    line.removePoint (0);
                } else if (p0.y == p1.y && p0.y == p2.y) {
                    line.removePoint (0);
                } else {
                    newLine.addPoint (line.removePoint (0));
                }

            }
            while (line.size () > 0) {
                newLine.addPoint (line.removePoint (0));
            }
            line.removeAllPoints ();
            line.addAll (newLine);
        }
        return line.size () != initialNumberOfPoints;
    }

}

