package org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document;

import java.io.ByteArrayInputStream;

import org.eclipse.core.filebuffers.manipulation.ContainerCreator;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.resources.IResource;

import org.eclipse.core.resources.IResourceChangeEvent;

import org.eclipse.core.resources.IResourceChangeListener;

import org.eclipse.core.resources.IResourceDelta;

import org.eclipse.core.resources.IResourceDeltaVisitor;

import org.eclipse.core.resources.IResourceRuleFactory;

import org.eclipse.core.resources.IResourceStatus;

import org.eclipse.core.resources.IWorkspace;

import org.eclipse.core.resources.ResourcesPlugin;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.IPath;

import org.eclipse.core.runtime.IProgressMonitor;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.OperationCanceledException;

import org.eclipse.core.runtime.Status;

import org.eclipse.core.runtime.SubProgressMonitor;

import org.eclipse.core.runtime.jobs.ISchedulingRule;

import org.eclipse.jface.operation.IRunnableContext;

import org.eclipse.swt.widgets.Display;

import org.eclipse.ui.IFileEditorInput;

import org.eclipse.ui.IWorkbench;

import org.eclipse.ui.IWorkbenchWindow;

import org.eclipse.ui.PlatformUI;

import org.eclipse.ui.part.FileEditorInput;

import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;

import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.internal.l10n.EditorMessages;

public abstract class FileDocumentProvider extends StorageDocumentProvider {
    private WorkspaceOperationRunner fOperationRunner;
    protected IResourceRuleFactory fResourceRuleFactory;
    protected class SafeChange implements Runnable {
        private IFileEditorInput fInput;

        public SafeChange (IFileEditorInput input) {
            fInput = input;
        }

        protected void execute (IFileEditorInput input) throws Exception {
        }

        public void run () {
            if (getElementInfo (fInput) == null) {
                fireElementStateChangeFailed (fInput);
                return;
            }
            try {
                execute (fInput);
            } catch (Exception e) {
                fireElementStateChangeFailed (fInput);
            }
        }

    }

    protected class FileSynchronizer implements IResourceChangeListener, IResourceDeltaVisitor {
        protected IFileEditorInput fFileEditorInput;
        protected boolean fIsInstalled = false;

        public FileSynchronizer (IFileEditorInput fileEditorInput) {
            fFileEditorInput = fileEditorInput;
        }

        protected IFile getFile () {
            return fFileEditorInput.getFile ();
        }

        public void install () {
            getFile ().getWorkspace ().addResourceChangeListener (this, IResourceChangeEvent.POST_CHANGE);
            fIsInstalled = true;
        }

        public void uninstall () {
            getFile ().getWorkspace ().removeResourceChangeListener (this);
            fIsInstalled = false;
        }

        public void resourceChanged (IResourceChangeEvent e) {
            IResourceDelta delta = e.getDelta ();
            try {
                if (delta != null && fIsInstalled) delta.accept (this);

            } catch (CoreException x) {
                handleCoreException (x, EditorMessages.FileDocumentProvider_resourceChanged);
            }
        }

        public boolean visit (IResourceDelta delta) throws CoreException {
            if (delta == null) return false;

            delta = delta.findMember (getFile ().getFullPath ());
            if (delta == null) return false;

            Runnable runnable = null;
            switch (delta.getKind ()) {
                case IResourceDelta.CHANGED :
                    FileInfo info = (FileInfo) getElementInfo (fFileEditorInput);
                    if (info == null || info.fCanBeSaved) break;

                    boolean isSynchronized = computeModificationStamp (getFile ()) == info.fModificationStamp;
                    if ((IResourceDelta.ENCODING & delta.getFlags ()) != 0 && isSynchronized) {
                        runnable = new SafeChange (fFileEditorInput) {

                            protected void execute (IFileEditorInput input) throws Exception {
                                handleElementContentChanged (input);
                            }

                        }

                        ;
                    }
                    if (runnable != null && (IResourceDelta.CONTENT & delta.getFlags ()) != 0 && ! isSynchronized) {
                        runnable = new SafeChange (fFileEditorInput) {

                            protected void execute (IFileEditorInput input) throws Exception {
                                handleElementContentChanged (input);
                            }

                        }

                        ;
                    }
                    break;
                case IResourceDelta.REMOVED :
                    if ((IResourceDelta.MOVED_TO & delta.getFlags ()) != 0) {
                        final IPath path = delta.getMovedToPath ();
                        runnable = new SafeChange (fFileEditorInput) {

                            protected void execute (IFileEditorInput input) throws Exception {
                                handleElementMoved (input, path);
                            }

                        }

                        ;
                    } else {
                        info = (FileInfo) getElementInfo (fFileEditorInput);
                        if (info != null && ! info.fCanBeSaved) {
                            runnable = new SafeChange (fFileEditorInput) {

                                protected void execute (IFileEditorInput input) throws Exception {
                                    handleElementDeleted (input);
                                }

                            }

                            ;
                        }
                    }
                    break;
            }
            if (runnable != null) update (runnable);

            return false;
        }

        protected void update (Runnable runnable) {
            if (runnable instanceof SafeChange) fireElementStateChanging (fFileEditorInput);

            IWorkbench workbench = PlatformUI.getWorkbench ();
            IWorkbenchWindow [] windows = workbench.getWorkbenchWindows ();
            if (windows != null && windows.length > 0) {
                Display display = windows [0].getShell ().getDisplay ();
                display.asyncExec (runnable);
            } else {
                runnable.run ();
            }
        }

    }

    protected class FileInfo extends StorageInfo {
        public FileSynchronizer fFileSynchronizer;
        public long fModificationStamp = IResource.NULL_STAMP;

        public FileInfo (IDocument document, FileSynchronizer fileSynchronizer) {
            super (document);
            fFileSynchronizer = fileSynchronizer;
        }

    }

    public FileDocumentProvider () {
        super ();
        fResourceRuleFactory = ResourcesPlugin.getWorkspace ().getRuleFactory ();
    }

    protected void checkSynchronizationState (long cachedModificationStamp, IResource resource) throws CoreException {
        if (cachedModificationStamp != computeModificationStamp (resource)) {
            Status status = new Status (IStatus.ERROR, PlatformUI.PLUGIN_ID, IResourceStatus.OUT_OF_SYNC_LOCAL, EditorMessages.FileDocumentProvider_error_out_of_sync, null);
            throw new CoreException (status);
        }
    }

    protected long computeModificationStamp (IResource resource) {
        long modificationStamp = resource.getModificationStamp ();
        IPath path = resource.getLocation ();
        if (path == null) return modificationStamp;

        modificationStamp = path.toFile ().lastModified ();
        return modificationStamp;
    }

    public long getModificationStamp (Object element) {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            return computeModificationStamp (input.getFile ());
        }
        return super.getModificationStamp (element);
    }

    public long getSynchronizationStamp (Object element) {
        if (element instanceof IFileEditorInput) {
            FileInfo info = (FileInfo) getElementInfo (element);
            if (info != null) return info.fModificationStamp;

        }
        return super.getSynchronizationStamp (element);
    }

    protected void doSynchronize (Object element, IProgressMonitor monitor) throws CoreException {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            FileInfo info = (FileInfo) getElementInfo (element);
            if (info != null) {
                if (info.fFileSynchronizer != null) {
                    info.fFileSynchronizer.uninstall ();
                    refreshFile (input.getFile (), monitor);
                    info.fFileSynchronizer.install ();
                } else {
                    refreshFile (input.getFile (), monitor);
                }
                handleElementContentChanged ((IFileEditorInput) element);
            }
            return;
        }
        super.doSynchronize (element, monitor);
    }

    public boolean isDeleted (Object element) {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            IPath path = input.getFile ().getLocation ();
            if (path == null) return true;

            return ! path.toFile ().exists ();
        }
        return super.isDeleted (element);
    }

    protected abstract void saveDocumentToFile (IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException;

    protected void doSaveDocument (IProgressMonitor monitor, Object element, IDocument document, boolean overwrite) throws CoreException {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            FileInfo info = (FileInfo) getElementInfo (element);
            IFile file = input.getFile ();
            if (file.exists ()) {
                if (info != null && ! overwrite) checkSynchronizationState (info.fModificationStamp, file);

                fireElementStateChanging (element);
                try {
                    saveDocumentToFile (document, file, overwrite, monitor);
                } catch (CoreException x) {
                    fireElementStateChangeFailed (element);
                    throw x;
                } catch (RuntimeException x) {
                    fireElementStateChangeFailed (element);
                    throw x;
                }
                if (info != null) {
                    info.fModificationStamp = computeModificationStamp (file);
                }
            } else {
                try {
                    monitor.beginTask (EditorMessages.FileDocumentProvider_task_saving, 3000);
                    ContainerCreator creator = new ContainerCreator (file.getWorkspace (), file.getParent ().getFullPath ());
                    creator.createContainer (new SubProgressMonitor (monitor, 1000));
                    file.create (new ByteArrayInputStream ("".getBytes ()), false, new SubProgressMonitor (monitor, 1000));
                    saveDocumentToFile (document, file, overwrite, new SubProgressMonitor (monitor, 1000));
                } finally {
                    monitor.done ();
                }
            }
        } else {
            super.doSaveDocument (monitor, element, document, overwrite);
        }
    }

    protected ElementInfo createElementInfo (Object element) throws CoreException {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            try {
                refreshFile (input.getFile ());
            } catch (CoreException x) {
                handleCoreException (x, EditorMessages.FileDocumentProvider_createElementInfo);
            }
            IDocument d = null;
            IStatus s = null;
            try {
                d = createDocument (element);
            } catch (CoreException x) {
                handleCoreException (x, EditorMessages.FileDocumentProvider_createElementInfo);
                s = x.getStatus ();
                d = createEmptyDocument ();
            }
            FileSynchronizer f = new FileSynchronizer (input);
            f.install ();
            FileInfo info = createFileInfo (d, f);
            info.fModificationStamp = computeModificationStamp (input.getFile ());
            info.fStatus = s;
            return info;
        }
        return super.createElementInfo (element);
    }

    protected FileInfo createFileInfo (IDocument document, FileSynchronizer synchronizer) {
        return new FileInfo (document, synchronizer);
    }

    protected void disposeElementInfo (Object element, ElementInfo info) {
        if (info instanceof FileInfo) {
            FileInfo fileInfo = (FileInfo) info;
            if (fileInfo.fFileSynchronizer != null) fileInfo.fFileSynchronizer.uninstall ();

        }
        super.disposeElementInfo (element, info);
    }

    protected void handleElementContentChanged (IFileEditorInput fileEditorInput) {
        FileInfo info = (FileInfo) getElementInfo (fileEditorInput);
        if (info == null) return;

        IDocument document = createEmptyDocument ();
        IStatus status = null;
        try {
            try {
                refreshFile (fileEditorInput.getFile ());
            } catch (CoreException x) {
                handleCoreException (x, EditorMessages.FileDocumentProvider_handleElementContentChanged);
            }
            setDocumentContent (document, fileEditorInput);
        } catch (CoreException x) {
            status = x.getStatus ();
        }
        Object newContent = document.getContent ();
        if (! newContent.equals (info.fDocument.getContent ())) {
            fireElementContentAboutToBeReplaced (fileEditorInput);
            removeUnchangedElementListeners (fileEditorInput, info);
            info.fDocument.removeDocumentListener (info);
            info.fDocument.setContent (newContent);
            info.fCanBeSaved = false;
            info.fModificationStamp = computeModificationStamp (fileEditorInput.getFile ());
            info.fStatus = status;
            addUnchangedElementListeners (fileEditorInput, info);
            fireElementContentReplaced (fileEditorInput);
        } else {
            removeUnchangedElementListeners (fileEditorInput, info);
            info.fCanBeSaved = false;
            info.fModificationStamp = computeModificationStamp (fileEditorInput.getFile ());
            info.fStatus = status;
            addUnchangedElementListeners (fileEditorInput, info);
            fireElementDirtyStateChanged (fileEditorInput, false);
        }
    }

    protected void setDocumentContent (IDocument document, Object content) throws CoreException {
        document.setContent (content);
    }

    protected void handleElementMoved (IFileEditorInput fileEditorInput, IPath path) {
        IWorkspace workspace = ResourcesPlugin.getWorkspace ();
        IFile newFile = workspace.getRoot ().getFile (path);
        fireElementMoved (fileEditorInput, newFile == null ? null : new FileEditorInput (newFile));
    }

    protected void handleElementDeleted (IFileEditorInput fileEditorInput) {
        fireElementDeleted (fileEditorInput);
    }

    protected ElementInfo getElementInfo (Object element) {
        return super.getElementInfo (element);
    }

    protected void doValidateState (Object element, Object computationContext) throws CoreException {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            FileInfo info = (FileInfo) getElementInfo (input);
            if (info != null) {
                IFile file = input.getFile ();
                if (file.isReadOnly ()) {
                    IWorkspace workspace = file.getWorkspace ();
                    workspace.validateEdit (new IFile [] {file}, computationContext);
                }
            }
        }
        super.doValidateState (element, computationContext);
    }

    public boolean isModifiable (Object element) {
        if (! isStateValidated (element)) {
            if (element instanceof IFileEditorInput) return true;

        }
        return super.isModifiable (element);
    }

    protected void doResetDocument (Object element, IProgressMonitor monitor) throws CoreException {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            try {
                refreshFile (input.getFile (), monitor);
            } catch (CoreException x) {
                handleCoreException (x, EditorMessages.FileDocumentProvider_resetDocument);
            }
        }
        super.doResetDocument (element, monitor);
    }

    protected void refreshFile (IFile file) throws CoreException {
        refreshFile (file, getProgressMonitor ());
    }

    protected void refreshFile (IFile file, IProgressMonitor monitor) throws CoreException {
        try {
            file.refreshLocal (IResource.DEPTH_INFINITE, monitor);
        } catch (OperationCanceledException x) {
        }
    }

    public boolean isSynchronized (Object element) {
        if (element instanceof IFileEditorInput) {
            FileInfo info = null;
            if ((info = (FileInfo) getElementInfo (element)) != null) {
                IFileEditorInput input = (IFileEditorInput) element;
                IResource resource = input.getFile ();
                return (info.fModificationStamp == computeModificationStamp (resource)) && resource.isSynchronized (IResource.DEPTH_ZERO);
            }
            return false;
        }
        return super.isSynchronized (element);
    }

    protected IRunnableContext getOperationRunner (IProgressMonitor monitor) {
        if (fOperationRunner == null) fOperationRunner = new WorkspaceOperationRunner ();

        fOperationRunner.setProgressMonitor (monitor);
        return fOperationRunner;
    }

    protected ISchedulingRule getResetRule (Object element) {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            return fResourceRuleFactory.modifyRule (input.getFile ());
        }
        return null;
    }

    protected ISchedulingRule getSaveRule (Object element) {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            return computeSchedulingRule (input.getFile ());
        }
        return null;
    }

    protected ISchedulingRule getSynchronizeRule (Object element) {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            return fResourceRuleFactory.refreshRule (input.getFile ());
        }
        return null;
    }

    protected ISchedulingRule getValidateStateRule (Object element) {
        if (element instanceof IFileEditorInput) {
            IFileEditorInput input = (IFileEditorInput) element;
            return fResourceRuleFactory.validateEditRule (new IResource [] {input.getFile ()});
        }
        return null;
    }

    private ISchedulingRule computeSchedulingRule (IResource toCreateOrModify) {
        if (toCreateOrModify.exists ()) return fResourceRuleFactory.modifyRule (toCreateOrModify);

        IResource parent = toCreateOrModify;
        do {
            toCreateOrModify = parent;
            parent = toCreateOrModify.getParent ();
        } while (parent != null && ! parent.exists ());
        return fResourceRuleFactory.createRule (toCreateOrModify);
    }

}

