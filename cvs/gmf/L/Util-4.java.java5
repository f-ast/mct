package org.eclipse.gmf.runtime.emf.core.internal.util;

import java.io.File;

import java.io.IOException;

import java.net.URL;

import java.util.Iterator;

import java.util.Map;

import java.util.Set;

import org.eclipse.core.resources.IFile;

import org.eclipse.core.resources.IProject;

import org.eclipse.core.resources.IWorkspace;

import org.eclipse.core.resources.IWorkspaceRoot;

import org.eclipse.core.resources.ResourcesPlugin;

import org.eclipse.core.runtime.FileLocator;

import org.eclipse.core.runtime.Path;

import org.eclipse.core.runtime.Platform;

import org.eclipse.emf.common.util.URI;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.EReference;

import org.eclipse.emf.ecore.resource.Resource;

import org.eclipse.emf.ecore.resource.ResourceSet;

import org.eclipse.emf.ecore.util.EcoreUtil;

import org.eclipse.emf.transaction.TransactionalEditingDomain;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCoreDebugOptions;

import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCorePlugin;

import org.eclipse.gmf.runtime.emf.core.resources.IResourceHelper;

import org.osgi.framework.Bundle;

import com.ibm.icu.util.StringTokenizer;

public class Util {
    private static final String pathDelimiter = String.valueOf (EMFCoreConstants.PATH_SEPARATOR);
    private static final String colonEscaped = "%3A";

    private Util () {
        super ();
    }

    public static IResourceHelper getHelper (Resource resource) {
        IResourceHelper result = null;
        if (resource != null) {
            result = (IResourceHelper) EcoreUtil.getExistingAdapter (resource, IResourceHelper.class);
        }
        return result;
    }

    public static String encodeQualifiedName (String qName) {
        return appendQualifiedName (new StringBuffer (), qName).toString ();
    }

    public static StringBuffer appendQualifiedName (StringBuffer buffer, String qName) {
        String [] segments = qName.split (EMFCoreConstants.QUALIFIED_NAME_SEPARATOR);
        for (int i = 0;
        i < segments.length; i ++) {
            String encodedSegment = URI.encodeSegment (segments [i], true);
            for (int j = 0, length = encodedSegment.length ();
            j < length; j ++) {
                char c = encodedSegment.charAt (j);
                if (':' == c) {
                    buffer.append (colonEscaped);
                } else {
                    buffer.append (c);
                }
            }
            if (i + 1 < segments.length) {
                buffer.append (EMFCoreConstants.PATH_SEPARATOR);
            }
        }
        return buffer;
    }

    public static String decodeQName (String qName) {
        StringBuffer buffer = new StringBuffer ();
        for (StringTokenizer st = new StringTokenizer (qName, pathDelimiter);
        st.hasMoreTokens ();) {
            buffer.append (URI.decode (st.nextToken ()));
            if (st.hasMoreTokens ()) buffer.append (EMFCoreConstants.QUALIFIED_NAME_SEPARATOR);

        }
        return buffer.toString ();
    }

    public static URI denormalizeURI (URI uri, ResourceSet rset) {
        URI resolvedURI = uri;
        if (EMFCoreConstants.PLATFORM_SCHEME.equals (resolvedURI.scheme ())) {
            String filePath = getFilePath (rset, resolvedURI);
            if ((filePath != null) && (filePath.length () > 0)) resolvedURI = URI.createFileURI (filePath);

        }
        if ((resolvedURI != null) && (resolvedURI.isFile ())) {
            String fileName = resolvedURI.lastSegment ();
            if (fileName != null) {
                URI prefix = resolvedURI.trimSegments (1);
                URI foundKeyURI = null;
                URI foundValURI = null;
                int minDiff = Integer.MAX_VALUE;
                Iterator i = rset.getURIConverter ().getURIMap ().entrySet ().iterator ();
                while (i.hasNext ()) {
                    Map.Entry entry = (Map.Entry) i.next ();
                    if (entry != null) {
                        URI keyURI = (URI) entry.getKey ();
                        URI valURI = (URI) entry.getValue ();
                        if ((keyURI.isHierarchical ()) && (EMFCoreConstants.PATH_MAP_SCHEME.equals (keyURI.scheme ())) && (valURI.isFile ())) {
                            int diff = computeDiff (valURI, prefix);
                            if ((diff >= 0) && (diff < minDiff)) {
                                minDiff = diff;
                                foundKeyURI = keyURI;
                                foundValURI = valURI;
                                if (minDiff == 0) break;

                            }
                        }
                    }
                }
                if ((foundKeyURI != null) && (foundValURI != null)) return resolvedURI.replacePrefix (foundValURI, foundKeyURI);

            }
            URI platformURI = getPlatformURI (uri);
            if (platformURI != null) return platformURI;

        }
        return uri;
    }

    private static String getFilePath (ResourceSet resourceSet, URI uri) {
        String filePath = null;
        if (uri == null) {
            filePath = EMFCoreConstants.EMPTY_STRING;
            return filePath;
        }
        if ((resourceSet != null) && (EMFCoreConstants.PATH_MAP_SCHEME.equals (uri.scheme ()))) uri = resourceSet.getURIConverter ().normalize (uri);

        if (uri.isFile ()) filePath = uri.toFileString ();
        else if (EMFCoreConstants.PLATFORM_SCHEME.equals (uri.scheme ())) {
            String [] segments = uri.segments ();
            if (segments.length > 2) {
                if (EMFCoreConstants.RESOURCE.equals (segments [0])) {
                    IProject project = null;
                    IWorkspace workspace = ResourcesPlugin.getWorkspace ();
                    if (workspace != null) {
                        IWorkspaceRoot root = workspace.getRoot ();
                        if (root != null) project = root.getProject (URI.decode (segments [1]));

                    }
                    if ((project != null) && (project.exists ())) {
                        StringBuffer path = new StringBuffer ();
                        path.append (project.getLocation ().toString ());
                        for (int i = 2;
                        i < segments.length; i ++) {
                            path.append (EMFCoreConstants.PATH_SEPARATOR);
                            path.append (URI.decode (segments [i]));
                        }
                        filePath = path.toString ();
                    }
                } else if (EMFCoreConstants.PLUGIN.equals (segments [0])) {
                    Bundle bundle = Platform.getBundle (URI.decode (segments [1]));
                    if (bundle != null) {
                        StringBuffer path = new StringBuffer ();
                        for (int i = 2;
                        i < segments.length; i ++) {
                            path.append (URI.decode (segments [i]));
                            path.append (EMFCoreConstants.PATH_SEPARATOR);
                        }
                        URL url = bundle.getEntry (path.toString ());
                        if (url != null) {
                            try {
                                url = FileLocator.resolve (url);
                                if (url != null) {
                                    if (EMFCoreConstants.FILE_SCHEME.equals (url.getProtocol ())) filePath = url.getPath ();

                                }
                            } catch (IOException e) {
                                Trace.catching (EMFCorePlugin.getDefault (), EMFCoreDebugOptions.EXCEPTIONS_CATCHING, Util.class, "getFilePath", e);
                            }
                        }
                    }
                }

            }
        }

        if (filePath == null) filePath = EMFCoreConstants.EMPTY_STRING;
        else {
            if (filePath.indexOf (EMFCoreConstants.INVALID_PATH) == - 1) {
                if (File.separatorChar != EMFCoreConstants.PATH_SEPARATOR) filePath = filePath.replace (EMFCoreConstants.PATH_SEPARATOR, File.separatorChar);

            } else filePath = EMFCoreConstants.EMPTY_STRING;

        }
        return filePath;
    }

    private static URI getPlatformURI (URI uri) {
        if (EMFCoreConstants.PLATFORM_SCHEME.equals (uri.scheme ())) return URI.createURI (uri.toString (), true);

        IFile file = findFileInWorkspace (uri);
        if (file != null) {
            IProject project = file.getProject ();
            if (project != null) {
                StringBuffer pathName = new StringBuffer (project.getName ());
                pathName.append (EMFCoreConstants.PATH_SEPARATOR);
                pathName.append (file.getProjectRelativePath ().toString ());
                return URI.createURI (URI.createPlatformResourceURI (pathName.toString (), true).toString (), true);
            }
        }
        return null;
    }

    private static IFile findFileInWorkspace (URI uri) {
        IWorkspace workspace = ResourcesPlugin.getWorkspace ();
        if (workspace != null) {
            IWorkspaceRoot root = workspace.getRoot ();
            if (root != null) {
                IFile [] files = root.findFilesForLocation (new Path (uri.toFileString ()));
                if (files != null) {
                    for (int i = 0;
                    i < files.length; i ++) {
                        IFile file = files [i];
                        IProject project = file.getProject ();
                        if (project != null) return file;

                    }
                }
            }
        }
        return null;
    }

    private static int computeDiff (URI subURI, URI containerURI) {
        int subSegmentCount = subURI.segmentCount ();
        int containerSegmentCount = containerURI.segmentCount ();
        if ((subSegmentCount > 0) && (subURI.segment (subSegmentCount - 1).equals (EMFCoreConstants.EMPTY_STRING))) {
            subURI = subURI.trimSegments (1);
            subSegmentCount --;
        }
        if ((containerSegmentCount > 0) && (containerURI.segment (containerSegmentCount - 1).equals (EMFCoreConstants.EMPTY_STRING))) {
            containerURI = containerURI.trimSegments (1);
            containerSegmentCount --;
        }
        int diff = containerSegmentCount - subSegmentCount;
        if (diff < 0) return - 1;
        else if (diff > 0) containerURI = containerURI.trimSegments (diff);

        if (! subURI.equals (containerURI)) return - 1;

        return diff;
    }

    public static String getProxyID (EObject proxy) {
        URI uri = EcoreUtil.getURI (proxy);
        String uriFragment = uri.fragment ();
        int index = uriFragment.indexOf (EMFCoreConstants.FRAGMENT_SEPARATOR);
        return index != - 1 ? uriFragment.substring (0, index) : uriFragment;
    }

    public static EObject resolve (TransactionalEditingDomain domain, EObject proxy) {
        EObject resolved = EcoreUtil.resolve (proxy, domain.getResourceSet ());
        return (resolved.eIsProxy () ? null : resolved);
    }

    public static boolean canContain (EClass class1, EClass class2, Set visited) {
        Iterator i = class1.getEAllReferences ().iterator ();
        while (i.hasNext ()) {
            EReference reference = (EReference) i.next ();
            if (reference.isContainment ()) {
                EClass eType = (EClass) reference.getEType ();
                if ((eType.equals (class2)) || (eType.isSuperTypeOf (class2))) {
                    return true;
                }
            }
        }
        if ((visited != null) && (! visited.contains (class1))) {
            visited.add (class1);
            i = class1.getEAllReferences ().iterator ();
            while (i.hasNext ()) {
                EReference reference = (EReference) i.next ();
                if (reference.isContainment ()) {
                    EClass eType = (EClass) reference.getEType ();
                    if (canContain (eType, class2, visited)) return true;

                }
            }
        }
        return false;
    }

}

