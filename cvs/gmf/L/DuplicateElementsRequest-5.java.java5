package org.eclipse.gmf.runtime.emf.type.core.requests;

import java.util.ArrayList;

import java.util.Collection;

import java.util.HashMap;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.transaction.TransactionalEditingDomain;

import org.eclipse.emf.transaction.util.TransactionUtil;

import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.EMFTypeCoreMessages;

public class DuplicateElementsRequest extends AbstractEditCommandRequest {
    private EObject commonContainer;
    private List elementsToDuplicate;
    private Map allDuplicatedElementsMap = new HashMap ();
    private EObject duplicate;

    public DuplicateElementsRequest (TransactionalEditingDomain editingDomain) {
        this (editingDomain, null);
    }

    public DuplicateElementsRequest (TransactionalEditingDomain editingDomain, List elementsToDuplicate) {
        super (editingDomain);
        this.elementsToDuplicate = elementsToDuplicate;
    }

    public DuplicateElementsRequest () {
        this (null, null);
    }

    public DuplicateElementsRequest (List elementsToDuplicate) {
        this (null, elementsToDuplicate);
    }

    public Map getAllDuplicatedElementsMap () {
        return allDuplicatedElementsMap;
    }

    public List getElementsToBeDuplicated () {
        return elementsToDuplicate;
    }

    public EObject getDuplicate () {
        return duplicate;
    }

    public void setAllDuplicatedElementsMap (Map duplicatedElementsMap) {
        this.allDuplicatedElementsMap = duplicatedElementsMap;
    }

    public void setElementsToBeDuplicated (List elements) {
        this.elementsToDuplicate = elements;
    }

    public List getElementsToEdit () {
        return elementsToDuplicate;
    }

    protected String getDefaultLabel () {
        return EMFTypeCoreMessages.Request_Label_Duplicate;
    }

    public Object getEditHelperContext () {
        if (commonContainer == null) {
            commonContainer = getLeastCommonContainer (getElementsToBeDuplicated ());
        }
        return commonContainer;
    }

    private static EObject getLeastCommonContainer (Collection objects) {
        EObject commonContainer = null;
        List prevContainers = new ArrayList ();
        for (Iterator i = objects.iterator ();
        i.hasNext ();) {
            EObject nextElement = (EObject) i.next ();
            boolean found = false;
            List containers = new ArrayList ();
            EObject container = nextElement;
            while (container != null) {
                containers.add (container);
                if (! found) {
                    if ((prevContainers.isEmpty ()) || (commonContainer == null)) {
                        commonContainer = container;
                        found = true;
                    } else if ((prevContainers.contains (container)) && (contains (container, commonContainer))) {
                        commonContainer = container;
                        found = true;
                    }

                }
                container = container.eContainer ();
            }
            if (! found) {
                return null;
            }
            prevContainers = containers;
        }
        return commonContainer;
    }

    private static boolean contains (EObject container, EObject eObject) {
        if (container == eObject) {
            return true;
        } else if ((container == null) || (eObject == null)) {
            return false;
        } else {
            return contains (container, eObject.eContainer ());
        }

    }

    public TransactionalEditingDomain getEditingDomain () {
        TransactionalEditingDomain result = super.getEditingDomain ();
        if (result == null) {
            EObject eObject = (EObject) ((getElementsToBeDuplicated ().size () > 0) ? getElementsToBeDuplicated ().get (0) : null);
            if (eObject != null) {
                result = TransactionUtil.getEditingDomain (eObject);
            }
        }
        return result;
    }

}

