package org.eclipse.gmf.runtime.common.core.service;

import java.util.ArrayList;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import java.util.WeakHashMap;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.core.runtime.IExtension;

import org.eclipse.core.runtime.IStatus;

import org.eclipse.core.runtime.Platform;

import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;

import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;

import org.eclipse.gmf.runtime.common.core.internal.CommonCoreStatusCodes;

import org.eclipse.gmf.runtime.common.core.util.Log;

import org.eclipse.gmf.runtime.common.core.util.Trace;

public abstract class Service extends AbstractProvider implements IProvider, IProviderChangeListener {
    public static class ProviderDescriptor extends AbstractProvider implements IProvider, IProviderChangeListener {
        protected static final String A_CLASS = "class";
        protected static final String A_PLUGIN = "plugin";
        protected static final String E_POLICY = "Policy";
        private final IConfigurationElement element;
        protected IProvider provider;
        protected IProviderPolicy policy;

        protected ProviderDescriptor (IConfigurationElement element) {
            super ();
            this.element = element;
        }

        protected final IConfigurationElement getElement () {
            return element;
        }

        public IProvider getProvider () {
            if (null == provider) {
                CommonCorePlugin corePlugin = CommonCorePlugin.getDefault ();
                try {
                    Log.info (corePlugin, CommonCoreStatusCodes.OK, "Activating provider '" + element.getAttribute (A_CLASS) + "'...");
                    provider = (IProvider) element.createExecutableExtension (A_CLASS);
                    provider.addProviderChangeListener (this);
                    Trace.trace (corePlugin, CommonCoreDebugOptions.SERVICES_ACTIVATE, "Provider '" + provider + "' activated.");
                } catch (CoreException ce) {
                    Trace.catching (corePlugin, CommonCoreDebugOptions.EXCEPTIONS_CATCHING, getClass (), "getProvider", ce);
                    IStatus status = ce.getStatus ();
                    Log.log (corePlugin, status.getSeverity (), CommonCoreStatusCodes.SERVICE_FAILURE, status.getMessage (), status.getException ());
                }
            }
            return provider;
        }

        protected IProviderPolicy getPolicy () {
            if (null == policy) {
                IConfigurationElement [] elements = element.getChildren (E_POLICY);
                working : {
                    if (elements.length == 0) break working;

                    CommonCorePlugin corePlugin = CommonCorePlugin.getDefault ();
                    try {
                        Log.info (corePlugin, CommonCoreStatusCodes.OK, "Activating provider policy '" + elements [0].getAttribute (A_CLASS) + "'...");
                        policy = (IProviderPolicy) element.createExecutableExtension (E_POLICY);
                        Trace.trace (corePlugin, CommonCoreDebugOptions.SERVICES_ACTIVATE, "Provider policy '" + policy + "' activated.");
                    } catch (CoreException ce) {
                        Trace.catching (corePlugin, CommonCoreDebugOptions.EXCEPTIONS_CATCHING, getClass (), "getPolicy", ce);
                        IStatus status = ce.getStatus ();
                        Log.log (corePlugin, status.getSeverity (), CommonCoreStatusCodes.SERVICE_FAILURE, status.getMessage (), status.getException ());
                    }
                }}
            return policy;
        }

        public boolean provides (IOperation operation) {
            IProviderPolicy thePolicy = getPolicy ();
            if (null != thePolicy) {
                try {
                    return thePolicy.provides (operation);
                } catch (Exception e) {
                    Log.log (CommonCorePlugin.getDefault (), IStatus.ERROR, CommonCoreStatusCodes.SERVICE_FAILURE, "Ignoring provider since policy " + thePolicy + " threw an exception in the provides() method", e);
                    return false;
                }
            }
            IProvider theProvider = getProvider ();
            return (theProvider != null) ? safeProvides (theProvider, operation) : false;
        }

        public void providerChanged (ProviderChangeEvent event) {
            fireProviderChange (event);
        }

    }

    protected static final String INVALID_ELEMENT_MESSAGE_PATTERN = "Invalid XML element ({0}).";
    private static final String A_NAME = "name";
    private static final String E_PRIORITY = "Priority";
    private static final int priorityCount;

    static {
        List priorities = ProviderPriority.HIGHEST.getValues ();
        int maxOrdinal = 0;
        for (Iterator i = priorities.iterator ();
        i.hasNext ();) {
            int ordinal = ((ProviderPriority) i.next ()).getOrdinal ();
            if (maxOrdinal < ordinal) maxOrdinal = ordinal;

        }
        priorityCount = maxOrdinal + 1;
    }

    private final Map [] cache;
    private final ArrayList [] providers;
    private final boolean optimistic;

    protected Service () {
        this (false);
    }

    protected Service (boolean optimized) {
        this (optimized, true);
    }

    protected Service (boolean optimized, boolean optimistic) {
        super ();
        if (optimized) {
            cache = new Map [priorityCount];
            for (int ordinal = priorityCount;
            -- ordinal >= 0;) {
                cache [ordinal] = createPriorityCache ();
            }
        } else {
            cache = null;
        }
        this.optimistic = optimistic;
        providers = new ArrayList [priorityCount];
        for (int ordinal = priorityCount;
        -- ordinal >= 0;) providers [ordinal] = new ArrayList (0);

    }

    protected Map createPriorityCache () {
        return new WeakHashMap ();
    }

    protected Object getCachingKey (IOperation operation) {
        return operation;
    }

    protected final boolean isOptimized () {
        return null != cache;
    }

    protected final boolean isOptimistic () {
        return optimistic;
    }

    protected final void clearCache () {
        if (null != cache) {
            for (int ordinal = priorityCount;
            -- ordinal >= 0;) {
                cache [ordinal].clear ();
            }
        }
    }

    final List getProviders (ProviderPriority priority) {
        return providers [priority.getOrdinal ()];
    }

    protected final List getProviders (ExecutionStrategy strategy, ProviderPriority priority, IOperation operation) {
        assert null != priority : "getProviders received null priority as argument";
        assert null != operation : "getproviders received null operation as argument";
        List providerList;
        if (null == cache) {
            providerList = strategy.getUncachedProviders (this, priority, operation);
        } else {
            Object cachingKey = getCachingKey (operation);
            Map map = cache [priority.getOrdinal ()];
            providerList = (List) map.get (cachingKey);
            if (null != providerList) {
                if (optimistic) return providerList;

                int n = providerList.size ();
                if (n != 0) {
                    for (int i = 0;
                    ;) {
                        IProvider provider = (IProvider) providerList.get (i);
                        if (! safeProvides (provider, operation)) break;

                        if (++ i == n) return providerList;

                    }
                }
            }
            providerList = strategy.getUncachedProviders (this, priority, operation);
            map.put (cachingKey, providerList);
        }
        return providerList;
    }

    protected final List getAllProviders () {
        int i;
        int n = priorityCount;
        int total;
        for (i = n, total = 0; -- i >= 0;) total += providers [i].size ();

        List allProviders = new ArrayList (total);
        for (i = 0; i < n; ++ i) allProviders.addAll (providers [i]);

        return allProviders;
    }

    protected final void addProvider (ProviderPriority priority, ProviderDescriptor provider) {
        assert null != priority : "null ProviderPriority";
        assert null != provider : "null ProviderDescriptor";
        int ordinal = priority.getOrdinal ();
        if (null != cache) {
            cache [ordinal].clear ();
        }
        providers [ordinal].add (provider);
        provider.addProviderChangeListener (this);
    }

    protected final void removeProvider (ProviderDescriptor provider) {
        assert null != provider : "null provider";
        for (int i = 0, n = priorityCount;
        i < n; ++ i) {
            if (providers [i].remove (provider)) {
                provider.removeProviderChangeListener (this);
                clearCache ();
                break;
            }
        }
    }

    protected final List execute (ExecutionStrategy strategy, IOperation operation) {
        assert null != strategy : "null strategy";
        assert null != operation : "null operation";
        List results = strategy.execute (this, operation);
        if (Trace.shouldTrace (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.SERVICES_EXECUTE)) {
            Trace.trace (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.SERVICES_EXECUTE, "Operation '" + operation + "' executed using strategy '" + strategy + "'.");
        }
        return results;
    }

    protected final Object executeUnique (ExecutionStrategy strategy, IOperation operation) {
        List results = execute (strategy, operation);
        return results.size () == 1 ? results.get (0) : null;
    }

    public final boolean provides (IOperation operation) {
        assert null != operation : "null operation passed to provides(IOperation)";
        for (int priority = 0, n = priorityCount;
        priority < n; ++ priority) {
            List providerList = providers [priority];
            int providerCount = providerList.size ();
            for (int provider = 0;
            provider < providerCount; ++ provider) if (safeProvides (((IProvider) providerList.get (provider)), operation)) return true;

        }
        return false;
    }

    protected final boolean provides (ExecutionStrategy strategy, IOperation operation) {
        assert null != strategy : "null strategy";
        assert null != operation : "null operation";
        for (int i = 0;
        i < ExecutionStrategy.PRIORITIES.length; ++ i) {
            ProviderPriority priority = ExecutionStrategy.PRIORITIES [i];
            List providerList = getProviders (strategy, priority, operation);
            int providerCount = providerList.size ();
            for (int provider = 0;
            provider < providerCount; ++ provider) if (safeProvides (((IProvider) providerList.get (provider)), operation)) return true;

        }
        return false;
    }

    public final void providerChanged (ProviderChangeEvent event) {
        assert null != event : "null event";
        event.setSource (this);
        fireProviderChange (event);
    }

    public final void configureProviders (String namespace, String extensionPointName) {
        configureProviders (Platform.getExtensionRegistry ().getExtensionPoint (namespace, extensionPointName).getConfigurationElements ());
    }

    public final void configureProviders (IConfigurationElement [] elements) {
        assert null != elements : "null elements";
        for (int i = 0;
        i < elements.length; ++ i) {
            IConfigurationElement element = elements [i];
            try {
                addProvider (ProviderPriority.parse (getPriority (element)), newProviderDescriptor (element));
            } finally {
                if (Trace.shouldTrace (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.SERVICES_CONFIG)) {
                    IExtension extension = element.getDeclaringExtension ();
                    String identifier = extension.getUniqueIdentifier ();
                    if (identifier == null) identifier = String.valueOf (extension.getNamespace ());

                    extension.getExtensionPointUniqueIdentifier ();
                    Trace.trace (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.SERVICES_CONFIG, "Provider of '" + extension.getExtensionPointUniqueIdentifier () + "' configured from extension '" + identifier + "'.");
                }
            }
        }
        for (int i = priorityCount;
        -- i >= 0;) providers [i].trimToSize ();

    }

    public String getPriority (IConfigurationElement element) {
        return element.getChildren (E_PRIORITY) [0].getAttribute (A_NAME);
    }

    protected ProviderDescriptor newProviderDescriptor (IConfigurationElement element) {
        return new ProviderDescriptor (element);
    }

    private static boolean safeProvides (IProvider provider, IOperation operation) {
        assert provider != null;
        try {
            return provider.provides (operation);
        } catch (Exception e) {
            Log.log (CommonCorePlugin.getDefault (), IStatus.ERROR, CommonCoreStatusCodes.SERVICE_FAILURE, "Ignoring provider " + provider + " since it threw an exception in the provides() method", e);
            return false;
        }
    }

}

