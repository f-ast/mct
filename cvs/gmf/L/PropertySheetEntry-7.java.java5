package org.eclipse.gmf.runtime.emf.ui.properties.sections;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.Collections;

import java.util.Comparator;

import java.util.HashMap;

import java.util.List;

import java.util.Locale;

import java.util.Map;

import org.eclipse.core.runtime.IAdaptable;

import org.eclipse.core.runtime.ListenerList;

import org.eclipse.jface.viewers.CellEditor;

import org.eclipse.jface.viewers.ICellEditorListener;

import org.eclipse.jface.viewers.ILabelProvider;

import org.eclipse.swt.graphics.Image;

import org.eclipse.swt.widgets.Composite;

import org.eclipse.ui.views.properties.IPropertyDescriptor;

import org.eclipse.ui.views.properties.IPropertySheetEntry;

import org.eclipse.ui.views.properties.IPropertySheetEntryListener;

import org.eclipse.ui.views.properties.IPropertySource;

import org.eclipse.ui.views.properties.IPropertySourceProvider;

import com.ibm.icu.text.Collator;

public class PropertySheetEntry implements IPropertySheetEntry, ICellEditorListener {
    protected Object [] values = new Object [0];
    private Map sources = new HashMap (0);
    protected Object editValue;
    protected PropertySheetEntry parent;
    private IPropertySourceProvider propertySourceProvider;
    protected IPropertyDescriptor descriptor;
    protected CellEditor editor;
    private String errorText;
    private PropertySheetEntry [] childEntries = null;
    private ListenerList listeners = new ListenerList ();

    public void editorValueChanged (boolean oldValidState, boolean newValidState) {
        if (! newValidState) setErrorText (editor.getErrorMessage ());
        else setErrorText (null);

    }

    public void cancelEditor () {
        setErrorText (null);
    }

    public void addPropertySheetEntryListener (IPropertySheetEntryListener listener) {
        listeners.add (listener);
    }

    public void applyEditorValue () {
        if (editor == null) return;

        if (! editor.isValueValid ()) {
            setErrorText (editor.getErrorMessage ());
            return;
        } else {
            setErrorText (null);
        }
        Object newValue = editor.getValue ();
        boolean changed = false;
        if (values.length > 1) {
            changed = true;
        } else if (editValue == null) {
            if (newValue != null) changed = true;

        } else if (! editValue.equals (newValue)) changed = true;

        if (changed) setValue (newValue);

    }

    protected List computeMergedPropertyDescriptors () {
        if (values.length == 0) return new ArrayList (0);

        Map [] propertyDescriptorMaps = new Map [values.length];
        for (int i = 0;
        i < values.length; i ++) {
            Object object = values [i];
            IPropertySource source = getPropertySource (object);
            if (source == null) {
                return new ArrayList (0);
            }
            propertyDescriptorMaps [i] = computePropertyDescriptorsFor (source);
        }
        Map intersection = propertyDescriptorMaps [0];
        for (int i = 1;
        i < propertyDescriptorMaps.length; i ++) {
            Object [] ids = intersection.keySet ().toArray ();
            for (int j = 0;
            j < ids.length; j ++) {
                Object object = propertyDescriptorMaps [i].get (ids [j]);
                if (object == null || ! ((IPropertyDescriptor) intersection.get (ids [j])).isCompatibleWith ((IPropertyDescriptor) object)) intersection.remove (ids [j]);

            }
        }
        List descriptors = new ArrayList (intersection.values ());
        Collections.sort (descriptors, new Comparator () {
            Collator coll = Collator.getInstance (Locale.getDefault ());

            public int compare (Object a, Object b) {
                IPropertyDescriptor d1, d2;
                String dname1, dname2;
                d1 = (IPropertyDescriptor) a;
                dname1 = d1.getDisplayName ();
                d2 = (IPropertyDescriptor) b;
                dname2 = d2.getDisplayName ();
                return coll.compare (dname1, dname2);
            }

        }

        );
        return descriptors;
    }

    protected Map computePropertyDescriptorsFor (IPropertySource source) {
        IPropertyDescriptor [] descriptors = source.getPropertyDescriptors ();
        Map result = new HashMap (descriptors.length * 2 + 1);
        for (int i = 0;
        i < descriptors.length; i ++) {
            result.put (descriptors [i].getId (), descriptors [i]);
        }
        return result;
    }

    protected void createChildEntries () {
        List descriptors = computeMergedPropertyDescriptors ();
        childEntries = createChildEntries (descriptors.size ());
        for (int i = 0;
        i < descriptors.size (); i ++) {
            IPropertyDescriptor d = (IPropertyDescriptor) descriptors.get (i);
            PropertySheetEntry entry = createChildEntry ();
            entry.setDescriptor (d);
            entry.setParent (this);
            entry.setPropertySourceProvider (propertySourceProvider);
            entry.refreshValues ();
            childEntries [i] = entry;
        }
    }

    protected PropertySheetEntry [] createChildEntries (int size) {
        return new PropertySheetEntry [size];
    }

    protected PropertySheetEntry createChildEntry () {
        return new PropertySheetEntry ();
    }

    public void dispose () {
        if (editor != null) {
            editor.dispose ();
            editor = null;
        }
        if (childEntries != null) for (int i = 0;
        i < childEntries.length; i ++) {
            if (childEntries [i] != null) childEntries [i].dispose ();

        }

    }

    private void fireChildEntriesChanged () {
        if (listeners == null) return;

        Object [] array = listeners.getListeners ();
        for (int i = 0;
        i < array.length; i ++) {
            IPropertySheetEntryListener listener = (IPropertySheetEntryListener) array [i];
            listener.childEntriesChanged (this);
        }
    }

    private void fireErrorMessageChanged () {
        if (listeners == null) return;

        Object [] array = listeners.getListeners ();
        for (int i = 0;
        i < array.length; i ++) {
            IPropertySheetEntryListener listener = (IPropertySheetEntryListener) array [i];
            listener.errorMessageChanged (this);
        }
    }

    private void fireValueChanged () {
        if (listeners == null) return;

        Object [] array = listeners.getListeners ();
        for (int i = 0;
        i < array.length; i ++) {
            IPropertySheetEntryListener listener = (IPropertySheetEntryListener) array [i];
            listener.valueChanged (this);
        }
    }

    public String getCategory () {
        return descriptor.getCategory ();
    }

    public IPropertySheetEntry [] getChildEntries () {
        if (childEntries == null) createChildEntries ();

        return childEntries;
    }

    public String getDescription () {
        return descriptor.getDescription ();
    }

    protected IPropertyDescriptor getDescriptor () {
        return descriptor;
    }

    public String getDisplayName () {
        return descriptor.getDisplayName ();
    }

    public CellEditor getEditor (Composite parentComposite) {
        if (editor == null) {
            editor = descriptor.createPropertyEditor (parentComposite);
            if (editor != null) {
                editor.addListener (this);
            }
        }
        if (editor != null) {
            editor.setValue (editValue);
            setErrorText (editor.getErrorMessage ());
        }
        return editor;
    }

    protected Object getEditValue (int index) {
        Object value = values [index];
        IPropertySource source = getPropertySource (value);
        if (source != null) {
            value = source.getEditableValue ();
        }
        return value;
    }

    public String getErrorText () {
        return errorText;
    }

    public String getFilters () [] {
        return descriptor.getFilterFlags ();
    }

    public Object getHelpContextIds () {
        return descriptor.getHelpContextIds ();
    }

    public Image getImage () {
        ILabelProvider provider = descriptor.getLabelProvider ();
        if (provider == null) return null;

        return provider.getImage (editValue);
    }

    protected IPropertySource getPropertySource (Object object) {
        if (sources.containsKey (object)) return (IPropertySource) sources.get (object);

        IPropertySource result = null;
        if (propertySourceProvider != null) result = propertySourceProvider.getPropertySource (object);
        else if (object instanceof IPropertySource) result = (IPropertySource) object;
        else if (object instanceof IAdaptable) result = (IPropertySource) ((IAdaptable) object).getAdapter (IPropertySource.class);

        sources.put (object, result);
        return result;
    }

    public String getValueAsString () {
        if (editValue == null) return "";

        ILabelProvider provider = descriptor.getLabelProvider ();
        if (provider == null) return editValue.toString ();

        return provider.getText (editValue);
    }

    protected Object [] getValues () {
        return values;
    }

    public boolean hasChildEntries () {
        if (detectCycle (editValue, parent)) {
            return false;
        }
        if (childEntries != null && childEntries.length > 0) return true;
        else return computeMergedPropertyDescriptors ().size () > 0;

    }

    private boolean detectCycle (Object value, PropertySheetEntry parentEntry) {
        if (value == null || parentEntry == null) {
            return false;
        }
        if (value.equals (parentEntry.editValue)) {
            return true;
        }
        return detectCycle (value, parentEntry.parent);
    }

    private void refreshChildEntries () {
        if (childEntries == null) return;

        List descriptors = computeMergedPropertyDescriptors ();
        Map entryCache = new HashMap (childEntries.length * 2 + 1);
        for (int i = 0;
        i < childEntries.length; i ++) {
            if (childEntries [i] != null && childEntries [i].getDescriptor () != null) {
                entryCache.put (childEntries [i].getDescriptor ().getId (), childEntries [i]);
            }
        }
        List entriesToDispose = new ArrayList (Arrays.asList (childEntries));
        childEntries = new PropertySheetEntry [descriptors.size ()];
        boolean entriesChanged = descriptors.size () != entryCache.size ();
        for (int i = 0;
        i < descriptors.size (); i ++) {
            IPropertyDescriptor d = (IPropertyDescriptor) descriptors.get (i);
            PropertySheetEntry entry = (PropertySheetEntry) entryCache.get (d.getId ());
            if (entry != null) {
                entry.setDescriptor (d);
                entriesToDispose.remove (entry);
            } else {
                entry = createChildEntry ();
                entry.setDescriptor (d);
                entry.setParent (this);
                entry.setPropertySourceProvider (propertySourceProvider);
                entriesChanged = true;
            }
            entry.refreshValues ();
            childEntries [i] = entry;
        }
        if (entriesChanged) fireChildEntriesChanged ();

        for (int i = 0;
        i < entriesToDispose.size (); i ++) {
            ((IPropertySheetEntry) entriesToDispose.get (i)).dispose ();
        }
    }

    void refreshFromRoot () {
        if (parent == null) refreshChildEntries ();
        else parent.refreshFromRoot ();

    }

    protected void refreshValues () {
        Object [] valueSources = parent.getValues ();
        Object [] newValues = new Object [valueSources.length];
        for (int i = 0;
        i < valueSources.length; i ++) {
            IPropertySource source = parent.getPropertySource (valueSources [i]);
            newValues [i] = source.getPropertyValue (descriptor.getId ());
        }
        setValues (newValues);
    }

    public void removePropertySheetEntryListener (IPropertySheetEntryListener listener) {
        listeners.remove (listener);
    }

    public void resetPropertyValue () {
        if (parent == null) return;

        boolean change = false;
        Object [] objects = parent.getValues ();
        for (int i = 0;
        i < objects.length; i ++) {
            IPropertySource source = getPropertySource (objects [i]);
            if (source.isPropertySet (descriptor.getId ())) {
                source.resetPropertyValue (descriptor.getId ());
                change = true;
            }
        }
        if (change) refreshFromRoot ();

    }

    private void setDescriptor (IPropertyDescriptor newDescriptor) {
        if (descriptor != newDescriptor && editor != null) {
            editor.dispose ();
            editor = null;
        }
        descriptor = newDescriptor;
    }

    protected void setErrorText (String newErrorText) {
        errorText = newErrorText;
        fireErrorMessageChanged ();
    }

    private void setParent (PropertySheetEntry p) {
        parent = p;
    }

    public void setPropertySourceProvider (IPropertySourceProvider provider) {
        propertySourceProvider = provider;
    }

    protected void setValue (Object newValue) {
        for (int i = 0;
        i < values.length; i ++) {
            values [i] = newValue;
        }
        parent.valueChanged (this);
        refreshFromRoot ();
    }

    public void setValues (Object [] objects) {
        values = objects;
        sources = new HashMap (values.length * 2 + 1);
        if (values.length == 0) editValue = null;
        else {
            Object newValue = values [0];
            IPropertySource source = getPropertySource (newValue);
            if (source != null) newValue = source.getEditableValue ();

            editValue = newValue;
        }
        refreshChildEntries ();
        fireValueChanged ();
    }

    protected void valueChanged (PropertySheetEntry child) {
        for (int i = 0;
        i < values.length; i ++) {
            IPropertySource source = getPropertySource (values [i]);
            source.setPropertyValue (child.getDescriptor ().getId (), child.getEditValue (i));
        }
        if (parent != null) parent.valueChanged (this);

    }

}

