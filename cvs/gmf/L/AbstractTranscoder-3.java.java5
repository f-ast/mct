package org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.metafile;

import java.awt.Dimension;

import java.awt.Graphics2D;

import java.io.BufferedInputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.OutputStream;

import java.io.OutputStreamWriter;

import java.io.Writer;

import org.apache.batik.dom.svg.SVGDOMImplementation;

import org.apache.batik.svggen.SVGGraphics2D;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.Draw2dRenderPlugin;

import org.eclipse.gmf.runtime.draw2d.ui.render.internal.Draw2dRenderDebugOptions;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.metafile.DeviceContext;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.metafile.IRenderToPath;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.metafile.IRenderableObject;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.metafile.ITraceMe;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.metafile.Record;

import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.metafile.TranscoderException;

import org.w3c.dom.DOMImplementation;

import org.w3c.dom.svg.SVGDocument;

public abstract class AbstractTranscoder {
    private static boolean m_gDebugMode = false;
    private Dimension m_size = new Dimension (100, 100);

    static void setDebugMode () {
        m_gDebugMode = true;
    }

    static void logMessage (String message) {
        if (m_gDebugMode) {
            System.out.println (message);
        } else {
            Trace.trace (Draw2dRenderPlugin.getInstance (), Draw2dRenderDebugOptions.DEBUG, message);
        }
    }

    public void setSize (Dimension size) {
        m_size = size;
    }

    public Dimension getSize () {
        return new Dimension (m_size);
    }

    public void transcode (InputStream input, OutputStream output) throws TranscoderException {
        if (input == null) {
            throw new IllegalArgumentException ("Parameter 'input' may not be null");
        } else if (output == null) {
            throw new IllegalArgumentException ("Parameter 'output' may not be null");
        }

        try {
            BufferedInputStream stream = new BufferedInputStream (input);
            DOMImplementation impl = SVGDOMImplementation.getDOMImplementation ();
            String svgNS = SVGDOMImplementation.SVG_NAMESPACE_URI;
            SVGDocument doc = (SVGDocument) impl.createDocument (svgNS, "svg", null);
            SVGGraphics2D svg = new SVGGraphics2D (doc);
            svg.getGeneratorContext ().setPrecision (3);
            iterateRecords (stream, svg);
            svg.setSVGCanvasSize (m_size);
            Writer writer = new OutputStreamWriter (output, "UTF-8");
            svg.stream (writer);
        } catch (IOException e) {
            throw new TranscoderException (e);
        }
    }

    private void iterateRecords (BufferedInputStream stream, Graphics2D g) throws TranscoderException, IOException {
        DeviceContext context = new DeviceContext ();
        int index = 0;
        Record rec;
        while ((rec = getNextRecord (stream, index)) != null) {
            index ++;
            try {
                String output = null;
                IRenderableObject svgConverter = getConverter (rec);
                if (svgConverter != null) {
                    if (context.getGdiPath ().isOpen () && svgConverter instanceof IRenderToPath) {
                        IRenderToPath pathRender = (IRenderToPath) svgConverter;
                        pathRender.render (context);
                        if (m_gDebugMode) {
                            output = buildOutput (rec, "IRenderToPath", index);
                        }
                    } else {
                        svgConverter.render (g, context);
                        if (m_gDebugMode) {
                            output = buildOutput (rec, "IRenderableObject", index);
                        }
                    }
                    if (m_gDebugMode && svgConverter instanceof ITraceMe) {
                        output += ' ' + svgConverter.toString ();
                    }
                } else {
                    output = buildOutput (rec, "Unhandled", index);
                }
                logMessage (output);
            } catch (org.apache.batik.transcoder.TranscoderException e) {
                throw new TranscoderException (e);
            } catch (TranscoderException e) {
                throw e;
            } catch (Exception e) {
                String output = buildOutput (rec, "Exception while processing", index) + ":\n" + e.toString ();
                logMessage (output);
                e.printStackTrace ();
            }
        }
    }

    private String _thisClassName = null;

    private String buildOutput (Record rec, String msg, int ix) {
        if (_thisClassName == null) {
            _thisClassName = getClass ().getName ();
            _thisClassName = _thisClassName.substring (_thisClassName.lastIndexOf ('.') + 1);
        }
        StringBuffer sb = new StringBuffer ();
        sb.append (_thisClassName);
        sb.append (", record " + ix + ' ');
        sb.append (msg + "  metafile record type ");
        sb.append (rec.getType () + " = " + getUserFriendlyName (rec.getType ()));
        return sb.toString ();
    }

    protected abstract Record getNextRecord (BufferedInputStream stream, int curRecord) throws IOException;

    protected abstract IRenderableObject getConverter (Record rec) throws TranscoderException;

    protected abstract String getUserFriendlyName (int recordType);

}

