package org.eclipse.gmf.internal.xpand.xtend.parser;

import lpg.lpgjavaruntime.*;

import java.util.LinkedList;

import java.util.List;

import java.util.regex.Matcher;

import java.util.regex.Pattern;

import org.eclipse.gmf.internal.xpand.util.ParserException.ErrorLocationInfo;

public class XtendLexer extends LpgLexStream implements XtendParsersym, XtendLexersym, RuleAction {
    private static ParseTable prs = new XtendLexerprs ();
    private PrsStream prsStream;
    private final LexParser lexParser = new LexParser (this, prs, this);

    public PrsStream getPrsStream () {
        return prsStream;
    }

    public int getToken (int i) {
        return lexParser.getToken (i);
    }

    public int getRhsFirstTokenIndex (int i) {
        return lexParser.getFirstToken (i);
    }

    public int getRhsLastTokenIndex (int i) {
        return lexParser.getLastToken (i);
    }

    public int getLeftSpan () {
        return lexParser.getFirstToken ();
    }

    public int getRightSpan () {
        return lexParser.getLastToken ();
    }

    public XtendLexer (String filename, int tab) throws java.io.IOException {
        super (filename, tab);
    }

    public XtendLexer (char [] input_chars, String filename, int tab) {
        super (input_chars, filename, tab);
    }

    public XtendLexer (char [] input_chars, String filename) {
        this (input_chars, filename, 1);
    }

    public XtendLexer () {
    }

    public String [] orderedExportedSymbols () {
        return XtendParsersym.orderedTerminalSymbols;
    }

    public LexStream getLexStream () {
        return (LexStream) this;
    }

    public void lexer (PrsStream prsStream) {
        lexer (null, prsStream);
    }

    public void lexer (Monitor monitor, PrsStream prsStream) {
        if (getInputChars () == null) {
            throw new NullPointerException ("LexStream was not initialized");
        }
        this.prsStream = prsStream;
        resetErrors ();
        prsStream.makeToken (0, 0, 0);
        lexParser.parseCharacters (monitor);
        int i = getStreamIndex ();
        prsStream.makeToken (i, i, TK_EOF_TOKEN);
        prsStream.setStreamLength (prsStream.getSize ());
        return;
    }

    public ErrorLocationInfo [] getErrors () {
        return errors.toArray (new ErrorLocationInfo [errors.size ()]);
    }

    private void resetErrors () {
        errors.clear ();
    }

    private final List < ErrorLocationInfo > errors = new LinkedList < ErrorLocationInfo > ();

    @Override
    public void reportError (int errorCode, String locationInfo, int leftToken, int rightToken, String tokenText) {
        final int leftTokenLine = getLine (leftToken);
        final int leftTokenColumn = getColumn (leftToken);
        final int rightTokenLine = getEndLine (rightToken);
        final int rightTokenColumn = getEndColumn (rightToken);
        final String msg = tokenText + errorMsgText [errorCode];
        errors.add (new ErrorLocationInfo (msg, leftTokenLine, leftTokenColumn, rightTokenLine, rightTokenColumn));
        super.reportError (errorCode, locationInfo, leftToken, rightToken, tokenText);
    }

    @Override
    public void reportError (int errorCode, String locationInfo, String tokenText) {
        try {
            Matcher m = Pattern.compile ("[^:]+:(\\d+):(\\d+):(\\d+):(\\d+):.*").matcher (locationInfo);
            boolean t = m.matches ();
            assert t;
            final int leftTokenLine = getLine (Integer.parseInt (m.group (1)));
            final int leftTokenColumn = getColumn (Integer.parseInt (m.group (2)));
            final int rightTokenLine = getEndLine (Integer.parseInt (m.group (3)));
            final int rightTokenColumn = getEndColumn (Integer.parseInt (m.group (4)));
            final String msg = tokenText + errorMsgText [errorCode];
            errors.add (new ErrorLocationInfo (msg, leftTokenLine, leftTokenColumn, rightTokenLine, rightTokenColumn));
        } catch (Exception ex) {
            errors.add (new ErrorLocationInfo (tokenText + errorMsgText [errorCode]));
        }
        super.reportError (errorCode, locationInfo, tokenText);
    }

    private XtendKWLexer kwLexer;
    private final static int ECLIPSE_TAB_VALUE = 4;

    public int [] getKeywordKinds () {
        return kwLexer.getKeywordKinds ();
    }

    public XtendLexer (String filename) throws java.io.IOException {
        this (filename, ECLIPSE_TAB_VALUE);
        this.kwLexer = new XtendKWLexer (getInputChars (), TK_IDENT);
    }

    public void initialize (char [] content, String filename) {
        super.initialize (content, filename);
        if (this.kwLexer == null) {
            this.kwLexer = new XtendKWLexer (getInputChars (), TK_IDENT);
        } else {
            this.kwLexer.setInputChars (getInputChars ());
        }
    }

    final void makeToken (int kind) {
        int startOffset = getLeftSpan (), endOffset = getRightSpan ();
        makeToken (startOffset, endOffset, kind);
    }

    final void makeComment (int kind) {
        int startOffset = getLeftSpan (), endOffset = getRightSpan ();
        super.getPrsStream ().makeAdjunct (startOffset, endOffset, kind);
    }

    final void skipToken () {
    }

    final void checkForKeyWord () {
        int startOffset = getLeftSpan (), endOffset = getRightSpan (), kwKind = kwLexer.lexer (startOffset, endOffset);
        makeToken (startOffset, endOffset, kwKind);
    }

    public final static int tokenKind [] = {Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_HT, Char_LF, Char_CtlCharNotWS, Char_FF, Char_CR, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_CtlCharNotWS, Char_Space, Char_Exclamation, Char_DoubleQuote, Char_Sharp, Char_DollarSign, Char_Percent, Char_Ampersand, Char_SingleQuote, Char_LeftParen, Char_RightParen, Char_Star, Char_Plus, Char_Comma, Char_Minus, Char_Dot, Char_Slash, Char_0, Char_1, Char_2, Char_3, Char_4, Char_5, Char_6, Char_7, Char_8, Char_9, Char_Colon, Char_SemiColon, Char_LessThan, Char_Equal, Char_GreaterThan, Char_QuestionMark, Char_AtSign,
      Char_A, Char_B, Char_C, Char_D, Char_E, Char_F, Char_G, Char_H, Char_I, Char_J, Char_K, Char_L, Char_M, Char_N, Char_O, Char_P, Char_Q, Char_R, Char_S, Char_T, Char_U, Char_V, Char_W, Char_X, Char_Y, Char_Z, Char_LeftBracket, Char_BackSlash, Char_RightBracket, Char_Caret, Char__, Char_BackQuote, Char_a, Char_b, Char_c, Char_d, Char_e, Char_f, Char_g, Char_h, Char_i, Char_j, Char_k, Char_l, Char_m, Char_n, Char_o, Char_p, Char_q, Char_r, Char_s, Char_t, Char_u, Char_v, Char_w, Char_x, Char_y, Char_z, Char_LeftBrace, Char_VerticalBar, Char_RightBrace, Char_Tilde, Char_AfterASCII, Char_EOF};

    public final int getKind (int i) {
        char c = (i >= getStreamLength () ? '\uffff' : getCharValue (i));
        return (c < 128 ? tokenKind [c] : c == '\uffff' ? Char_EOF : Char_AfterASCII);
    }

    public void ruleAction (int ruleNumber) {
        switch (ruleNumber) {
            case 1 :
                {
                    checkForKeyWord ();
                    break;
                } case 2 :
                {
                    makeToken (TK_STRING);
                    break;
                } case 3 :
                {
                    makeToken (TK_STRING);
                    break;
                } case 4 :
                {
                    makeToken (TK_INT_CONST);
                    break;
                } case 5 :
                {
                    makeToken (getRhsFirstTokenIndex (1), getRhsLastTokenIndex (1), TK_INT_CONST);
                    makeToken (getRhsFirstTokenIndex (2), getRhsLastTokenIndex (2), TK_DOT);
                    makeToken (getRhsFirstTokenIndex (3), getRhsLastTokenIndex (3), TK_IDENT);
                    break;
                } case 6 :
                {
                    makeToken (TK_REAL_CONST);
                    break;
                } case 7 :
                {
                    makeToken (TK_PLUS);
                    break;
                } case 8 :
                {
                    makeToken (TK_MINUS);
                    break;
                } case 9 :
                {
                    makeToken (TK_MULTI);
                    break;
                } case 10 :
                {
                    makeToken (TK_DIV);
                    break;
                } case 11 :
                {
                    makeToken (TK_AND);
                    break;
                } case 12 :
                {
                    makeToken (TK_OR);
                    break;
                } case 13 :
                {
                    makeToken (TK_NOT);
                    break;
                } case 14 :
                {
                    makeToken (TK_LPAREN);
                    break;
                } case 15 :
                {
                    makeToken (TK_RPAREN);
                    break;
                } case 16 :
                {
                    makeToken (TK_GT);
                    break;
                } case 17 :
                {
                    makeToken (TK_LT);
                    break;
                } case 18 :
                {
                    makeToken (TK_EQ);
                    break;
                } case 19 :
                {
                    makeToken (TK_GE);
                    break;
                } case 20 :
                {
                    makeToken (TK_LE);
                    break;
                } case 21 :
                {
                    makeToken (TK_NE);
                    break;
                } case 22 :
                {
                    makeToken (TK_LSQUARE);
                    break;
                } case 23 :
                {
                    makeToken (TK_RSQUARE);
                    break;
                } case 24 :
                {
                    makeToken (TK_LCURLY);
                    break;
                } case 25 :
                {
                    makeToken (TK_RCURLY);
                    break;
                } case 26 :
                {
                    makeToken (TK_ARROW);
                    break;
                } case 27 :
                {
                    makeToken (TK_BAR);
                    break;
                } case 28 :
                {
                    makeToken (TK_COMMA);
                    break;
                } case 29 :
                {
                    makeToken (TK_COLON);
                    break;
                } case 30 :
                {
                    makeToken (TK_DCOLON);
                    break;
                } case 31 :
                {
                    makeToken (TK_DOT);
                    break;
                } case 32 :
                {
                    makeToken (TK_ASSIGN);
                    break;
                } case 33 :
                {
                    makeToken (TK_QUESTION_MARK);
                    break;
                } case 34 :
                {
                    skipToken ();
                    break;
                } case 35 :
                {
                    skipToken ();
                    break;
                } case 36 :
                {
                    skipToken ();
                    break;
                } case 225 :
                {
                    makeToken (TK_SEMI);
                    break;
                } default :
                break;
        }
        return;
    }

}

