package org.eclipse.gmf.runtime.diagram.ui.services.palette;

import java.util.HashMap;

import java.util.Iterator;

import java.util.List;

import java.util.Map;

import org.eclipse.core.runtime.IConfigurationElement;

import org.eclipse.emf.edit.domain.EditingDomain;

import org.eclipse.emf.edit.domain.IEditingDomainProvider;

import org.eclipse.emf.transaction.TransactionalEditingDomain;

import org.eclipse.gef.palette.PaletteContainer;

import org.eclipse.gef.palette.PaletteEntry;

import org.eclipse.gef.palette.PaletteRoot;

import org.eclipse.gef.palette.SelectionToolEntry;

import org.eclipse.gef.palette.ToolEntry;

import org.eclipse.gmf.runtime.common.core.service.ExecutionStrategy;

import org.eclipse.gmf.runtime.common.core.service.IOperation;

import org.eclipse.gmf.runtime.common.core.service.IProvider;

import org.eclipse.gmf.runtime.common.core.service.Service;

import org.eclipse.gmf.runtime.common.core.util.Trace;

import org.eclipse.gmf.runtime.common.ui.services.util.ActivityFilterProviderDescriptor;

import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;

import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.ContributeToPaletteOperation;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.IPaletteProvider;

import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.PaletteProviderConfiguration;

import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;

import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteGroup;

import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteSeparator;

import org.eclipse.jface.util.Assert;

import org.eclipse.ui.IEditorPart;

public class PaletteService extends Service implements IPaletteProvider {
    protected static class ProviderDescriptor extends ActivityFilterProviderDescriptor {
        private PaletteProviderConfiguration providerConfiguration;

        public ProviderDescriptor (IConfigurationElement element) {
            super (element);
            this.providerConfiguration = PaletteProviderConfiguration.parse (element);
            Assert.isNotNull (providerConfiguration);
        }

        public boolean provides (IOperation operation) {
            if (! super.provides (operation)) {
                return false;
            }
            if (! policyInitialized) {
                policy = getPolicy ();
                policyInitialized = true;
            }
            if (policy != null) return policy.provides (operation);

            if (operation instanceof ContributeToPaletteOperation) {
                ContributeToPaletteOperation o = (ContributeToPaletteOperation) operation;
                return providerConfiguration.supports (o.getEditor (), o.getContent ());
            }
            return false;
        }

        public IProvider getProvider () {
            if (provider == null) {
                IProvider newProvider = super.getProvider ();
                if (provider instanceof IPaletteProvider) {
                    IPaletteProvider defaultProvider = (IPaletteProvider) newProvider;
                    defaultProvider.setContributions (getElement ());
                }
                return newProvider;
            }
            return super.getProvider ();
        }

    }

    public void setContributions (IConfigurationElement configElement) {
    }

    private final static PaletteService instance = new PaletteService ();

    static {
        instance.configureProviders (DiagramUIPlugin.getPluginId (), "paletteProviders");
    }

    public final static String GROUP_STANDARD = "standardGroup";
    public final static String SEPARATOR_STANDARD = "standardSeparator";
    public final static String TOOL_SELECTION = "selectionTool";

    protected PaletteService () {
        super ();
    }

    public static PaletteService getInstance () {
        return instance;
    }

    protected Service.ProviderDescriptor newProviderDescriptor (IConfigurationElement element) {
        return new ProviderDescriptor (element);
    }

    public void contributeToPalette (IEditorPart editor, Object content, PaletteRoot root, Map predefinedEntries) {
        PaletteGroup standardGroup = new PaletteGroup (GROUP_STANDARD, DiagramUIMessages.StandardGroup_Label);
        standardGroup.setDescription (DiagramUIMessages.StandardGroup_Description);
        root.add (standardGroup);
        PaletteSeparator standardSeparator = new PaletteSeparator (SEPARATOR_STANDARD);
        standardGroup.add (standardSeparator);
        ToolEntry selectTool = new SelectionToolEntry ();
        selectTool.setId (TOOL_SELECTION);
        standardGroup.add (selectTool);
        root.setDefaultEntry (selectTool);
        execute (new ContributeToPaletteOperation (editor, content, root, predefinedEntries));
    }

    private List execute (IOperation operation) {
        return execute (ExecutionStrategy.REVERSE, operation);
    }

    public PaletteRoot createPalette (final IEditorPart editor, final Object content) {
        final PaletteRoot root = new PaletteRoot ();
        try {
            IEditingDomainProvider provider = (IEditingDomainProvider) editor.getAdapter (IEditingDomainProvider.class);
            if (provider != null) {
                EditingDomain domain = provider.getEditingDomain ();
                if (domain instanceof TransactionalEditingDomain) {
                    ((TransactionalEditingDomain) domain).runExclusive (new Runnable () {

                        public void run () {
                            contributeToPalette (editor, content, root, new HashMap ());
                        }

                    }

                    );
                }
            }
        } catch (Exception e) {
            Trace.catching (DiagramUIPlugin.getInstance (), DiagramUIDebugOptions.EXCEPTIONS_CATCHING, PaletteService.class, "createPalette()", e);
        }
        return root;
    }

    public void updatePalette (PaletteRoot existingRoot, final IEditorPart editor, final Object content) {
        PaletteRoot newRoot = createPalette (editor, content);
        updatePaletteContainerEntries (existingRoot, newRoot);
    }

    private void updatePaletteContainerEntries (PaletteContainer existingContainer, PaletteContainer newContainer) {
        HashMap existingEntryIds = new HashMap ();
        for (Iterator iter = existingContainer.getChildren ().iterator ();
        iter.hasNext ();) {
            PaletteEntry entry = (PaletteEntry) iter.next ();
            existingEntryIds.put (entry.getId (), entry);
        }
        int lastExistingEntryIndex = 0;
        for (Iterator iter = newContainer.getChildren ().iterator ();
        iter.hasNext ();) {
            PaletteEntry newEntry = (PaletteEntry) iter.next ();
            PaletteEntry existingEntry = (PaletteEntry) existingEntryIds.get (newEntry.getId ());
            if (existingEntry != null) {
                lastExistingEntryIndex = existingContainer.getChildren ().indexOf (existingEntry);
                existingEntryIds.remove (existingEntry.getId ());
                if (existingEntry instanceof PaletteContainer && newEntry instanceof PaletteContainer) {
                    updatePaletteContainerEntries ((PaletteContainer) existingEntry, (PaletteContainer) newEntry);
                }
            } else {
                existingContainer.add (++ lastExistingEntryIndex, newEntry);
            }
        }
        for (Iterator iter = existingEntryIds.values ().iterator ();
        iter.hasNext ();) {
            PaletteEntry entry = (PaletteEntry) iter.next ();
            existingContainer.remove (entry);
        }
    }

}

