package org.eclipse.gmf.runtime.draw2d.ui.figures;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.Comparator;

import java.util.HashMap;

import java.util.Iterator;

import java.util.List;

import java.util.ListIterator;

import java.util.Map;

import org.eclipse.draw2d.ArrowLocator;

import org.eclipse.draw2d.Connection;

import org.eclipse.draw2d.ConnectionAnchor;

import org.eclipse.draw2d.ConnectionLocator;

import org.eclipse.draw2d.Graphics;

import org.eclipse.draw2d.IFigure;

import org.eclipse.draw2d.PolylineConnection;

import org.eclipse.draw2d.RotatableDecoration;

import org.eclipse.draw2d.geometry.Dimension;

import org.eclipse.draw2d.geometry.Point;

import org.eclipse.draw2d.geometry.PointList;

import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.ConnectionLayerEx;

import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.DelegatingLayout;

import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.PolylineAnchor;

import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

import org.eclipse.swt.SWT;

import org.eclipse.swt.graphics.Color;

public class PolylineConnectionEx extends PolylineConnection implements IPolygonAnchorableFigure {
    private RotatableDecoration startDecoration, endDecoration;
    private static Rectangle LINEBOUNDS = Rectangle.SINGLETON;
    private static int TOLERANCE = 3;
    public static final int SMOOTH_NONE = 0x0000;
    public static final int SMOOTH_LESS = 0x0010;
    public static final int SMOOTH_NORMAL = 0x0020;
    public static final int SMOOTH_MORE = 0x0040;
    public static final int JUMPLINK_FLAG_BELOW = 0x4000;
    public static final int JUMPLINK_FLAG_ABOVE = 0x8000;
    public static final int JUMPLINK_FLAG_ALL = JUMPLINK_FLAG_BELOW | JUMPLINK_FLAG_ABOVE;
    private static final int SMOOTH_FACTOR_LESS = 15;
    private static final int SMOOTH_FACTOR_NORMAL = 30;
    private static final int SMOOTH_FACTOR_MORE = 50;
    private static final int ROUTE_AVOID_OBSTACLE = 0x0100;
    private static final int ROUTE_CLOSEST_ROUTE = 0x0200;
    private static final int ROUTE_JUMP_LINKS = 0x0400;
    private static final int JUMPLINK_FLAG_SMOOTH = 0x0800;
    private static final int JUMPLINK_FLAG_ANGLEIN = 0x1000;
    private static final int JUMPLINK_FLAG_ONBOTTOM = 0x2000;
    private static final int JUMPLINK_DEFAULT_SMOOTHNESS = 30;
    private long styleBits;
    private JumpLinkSet jumpLinkSet;
    private Map connectionAnchors;
    static private final String szAnchor = "";
    private static final Dimension dimCheck = new Dimension (100, 100);

    private boolean isFeedbackLayer () {
        Dimension copied = dimCheck.getCopy ();
        translateToRelative (copied);
        return dimCheck.equals (copied);
    }

    public PolylineConnectionEx () {
        styleBits = JUMPLINK_FLAG_BELOW | JUMPLINK_FLAG_SMOOTH | JUMPLINK_FLAG_ANGLEIN;
        setLayoutManager (new DelegatingLayout ());
    }

    protected Map getConnectionAnchors () {
        if (connectionAnchors == null) connectionAnchors = new HashMap (1);

        return connectionAnchors;
    }

    public void refreshLine () {
        dirtyJumpLinks ();
        repaint ();
    }

    public void addPoint (Point pt) {
        super.addPoint (pt);
        refreshLine ();
    }

    private int calculateTolerance (boolean isFeedbackLayer) {
        Dimension absTol = new Dimension (TOLERANCE + lineWidth / 2, 0);
        if (! isFeedbackLayer) {
            MapModeUtil.getMapMode (this).DPtoLP (absTol);
        }
        return absTol.width;
    }

    public Rectangle getBounds () {
        if (bounds == null) {
            if (getSmoothFactor () != 0) {
                bounds = getSmoothPoints ().getBounds ();
                bounds.expand (lineWidth / 2, lineWidth / 2);
                for (int i = 0;
                i < getChildren ().size (); i ++) {
                    IFigure child = (IFigure) getChildren ().get (i);
                    bounds.union (child.getBounds ());
                }
            } else super.getBounds ();

            boolean isFeedbackLayer = isFeedbackLayer ();
            int calculatedTolerance = calculateTolerance (isFeedbackLayer);
            Dimension jumpLinkSize = calculateJumpLinkSize (isFeedbackLayer);
            bounds.expand (jumpLinkSize.height + calculatedTolerance, jumpLinkSize.height + calculatedTolerance);
        }
        return bounds;
    }

    public Rectangle getSimpleBounds () {
        Point s = getStart ();
        Point e = getEnd ();
        Point start = new Point (Math.min (s.x, e.x), Math.min (s.y, e.y));
        Dimension d = new Dimension (Math.abs (s.x - e.x), Math.abs (s.y - e.y));
        return new Rectangle (start.x, start.y, d.width, d.height);
    }

    public boolean containsPoint (int x, int y) {
        boolean isFeedbackLayer = isFeedbackLayer ();
        int calculatedTolerance = calculateTolerance (isFeedbackLayer);
        LINEBOUNDS.setBounds (getBounds ());
        LINEBOUNDS.expand (calculatedTolerance, calculatedTolerance);
        if (! LINEBOUNDS.contains (x, y)) return false;

        int ints [] = getSmoothPoints ().toIntArray ();
        for (int index = 0;
        index < ints.length - 3; index += 2) {
            if (lineContainsPoint (ints [index], ints [index + 1], ints [index + 2], ints [index + 3], x, y, isFeedbackLayer)) return true;

        }
        List children = getChildren ();
        for (int i = 0;
        i < children.size (); i ++) {
            if (((IFigure) children.get (i)).containsPoint (x, y)) return true;

        }
        return false;
    }

    private boolean lineContainsPoint (int x1, int y1, int x2, int y2, int px, int py, boolean isFeedbackLayer) {
        LINEBOUNDS.setSize (0, 0);
        LINEBOUNDS.setLocation (x1, y1);
        LINEBOUNDS.union (x2, y2);
        int calculatedTolerance = calculateTolerance (isFeedbackLayer);
        LINEBOUNDS.expand (calculatedTolerance, calculatedTolerance);
        if (! LINEBOUNDS.contains (px, py)) return false;

        double v1x, v1y, v2x, v2y;
        double numerator, denominator;
        double result = 0;
        if (x1 != x2 && y1 != y2) {
            v1x = (double) x2 - x1;
            v1y = (double) y2 - y1;
            v2x = (double) px - x1;
            v2y = (double) py - y1;
            numerator = v2x * v1y - v1x * v2y;
            denominator = v1x * v1x + v1y * v1y;
            result = (int) (numerator * numerator / denominator);
        }
        return result <= calculatedTolerance * calculatedTolerance;
    }

    public int findLineSegIndexOfPoint (int x, int y) {
        calculateTolerance (isFeedbackLayer ());
        return PointListUtilities.findNearestLineSegIndexOfPoint (getPoints (), new Point (x, y));
    }

    public PointList getSmoothPoints () {
        if (getSmoothFactor () > 0) {
            return PointListUtilities.calcSmoothPolyline (getPoints (), getSmoothFactor (), PointListUtilities.DEFAULT_BEZIERLINES);
        } else {
            return PointListUtilities.copyPoints (getPoints ());
        }
    }

    public void insertPoint (Point pt, int index) {
        super.insertPoint (pt, index);
        refreshLine ();
    }

    protected void outlineShape (Graphics g) {
        PointList displayPoints = getSmoothPoints ();
        int incline = calculateJumpLinkIncline (isFeedbackLayer ());
        if (shouldJumpLinks ()) {
            regenerateJumpLinks ();
            JumpLinkSet pJumpLinkSet = getJumpLinkSet ();
            if (pJumpLinkSet != null && pJumpLinkSet.m_pJumpLinks != null) {
                int nSmoothNess = 0;
                if (isJumpLinksSmooth ()) nSmoothNess = JUMPLINK_DEFAULT_SMOOTHNESS;

                boolean bOnBottom = isJumpLinksOnBottom ();
                ListIterator linkIter = pJumpLinkSet.m_pJumpLinks.listIterator ();
                while (linkIter.hasNext ()) {
                    JumpLink pJumpLink = (JumpLink) linkIter.next ();
                    PointList jumpLinkPoints = PointListUtilities.routeAroundPoint (displayPoints, pJumpLink.m_ptIntersect, pJumpLink.m_nHeight, pJumpLink.m_nWidth, nSmoothNess, incline, ! bOnBottom);
                    if (jumpLinkPoints != null) displayPoints = jumpLinkPoints;

                }
            }
        }
        g.drawPolyline (displayPoints);
    }

    public void setLineWidth (int w) {
        bounds = null;
        super.setLineWidth (w);
    }

    public void setPoint (Point pt, int index) {
        super.setPoint (pt, index);
        refreshLine ();
    }

    public void setPoints (PointList points) {
        super.setPoints (points);
        dirtyAllJumpLinks ();
        refreshLine ();
    }

    private static final int JUMPLINK_DEFAULT_WIDTH = 25;
    private static final int JUMPLINK_DEFAULT_HEIGHT = 10;

    private Dimension calculateJumpLinkSize (boolean isFeedbackLayer) {
        Dimension jumpDim = new Dimension (JUMPLINK_DEFAULT_WIDTH, JUMPLINK_DEFAULT_HEIGHT);
        if (! isFeedbackLayer) {
            MapModeUtil.getMapMode (this).DPtoLP (jumpDim);
        }
        return jumpDim;
    }

    private int calculateJumpLinkIncline (boolean isFeedbackLayer) {
        if (isJumpLinksAngledIn ()) return calculateJumpLinkSize (isFeedbackLayer).width / 5;

        return 0;
    }

    public void dirtyAllJumpLinks () {
        IFigure pParent = getParent ();
        if (pParent instanceof ConnectionLayerEx) ((ConnectionLayerEx) pParent).dirtyJumpLinks (getBounds ());

    }

    protected class JumpLink {
        public Point m_ptIntersect;
        public int m_nWidth;
        public int m_nHeight;
        public int m_nDistance;
    }

    protected class JumpLinkSet {

        public JumpLinkSet () {
            m_bDirty = true;
            m_pJumpLinks = null;
        }

        public boolean isDirty () {
            return m_bDirty;
        }

        protected void cleanJumpLinks (Connection connect) {
            m_bDirty = false;
            IFigure pParent = connect.getParent ();
            if (pParent instanceof ConnectionLayerEx) ((ConnectionLayerEx) pParent).cleanJumpLinks ();

        }

        public void dirtyJumpLinks () {
            m_bDirty = true;
        }

        public boolean regenerateJumpLinks (Connection connect) {
            if (isDirty ()) {
                calculateIntersections (connect);
                cleanJumpLinks (connect);
                return true;
            }
            return false;
        }

        private class CompareDistance implements Comparator {

            public int compare (Object obj1, Object obj2) {
                JumpLink j1 = (JumpLink) obj1;
                JumpLink j2 = (JumpLink) obj2;
                if (j1.m_nDistance < j2.m_nDistance) return - 1;
                else if (j1.m_nDistance > j2.m_nDistance) return 1;

                return 0;
            }

        }

        private void sortByDistance () {
            Object [] jumpArray = m_pJumpLinks.toArray ();
            Arrays.sort (jumpArray, new CompareDistance ());
            for (int i = 0;
            i < m_pJumpLinks.size (); i ++) m_pJumpLinks.set (i, jumpArray [i]);

        }

        private void calculateIntersections (Connection connect) {
            IFigure pParent = connect.getParent ();
            if (m_pJumpLinks != null) m_pJumpLinks = null;

            PointList tmpLine = getSmoothPoints ();
            long jumpType = (styleBits & JUMPLINK_FLAG_ALL);
            List children = pParent.getChildren ();
            int nIndex = children.indexOf (connect);
            ListIterator childIter = children.listIterator ();
            boolean bForwards = true;
            if (jumpType != JUMPLINK_FLAG_ALL) {
                childIter = children.listIterator (nIndex);
                if (jumpType == JUMPLINK_FLAG_BELOW) bForwards = false;

            }
            boolean isFeedbackLayer = isFeedbackLayer ();
            Dimension jumpLinkSize = calculateJumpLinkSize (isFeedbackLayer);
            while (bForwards ? childIter.hasNext () : childIter.hasPrevious ()) {
                IFigure figure = (IFigure) (bForwards ? childIter.next () : childIter.previous ());
                PointList checkLine = null;
                if (figure != connect) {
                    if (figure instanceof PolylineConnectionEx) checkLine = ((PolylineConnectionEx) figure).getSmoothPoints ();
                    else if (figure instanceof Connection) checkLine = PointListUtilities.copyPoints (((Connection) figure).getPoints ());

                    if (checkLine != null) {
                        PointList intersections = new PointList ();
                        PointList distances = new PointList ();
                        if (m_pJumpLinks == null) m_pJumpLinks = new ArrayList (intersections.size ());

                        if (PointListUtilities.findIntersections (tmpLine, checkLine, intersections, distances)) {
                            for (int i = 0;
                            i < intersections.size (); i ++) {
                                double dist1 = intersections.getPoint (i).getDistance (tmpLine.getFirstPoint ());
                                double dist2 = intersections.getPoint (i).getDistance (tmpLine.getLastPoint ());
                                double dist3 = intersections.getPoint (i).getDistance (checkLine.getFirstPoint ());
                                double dist4 = intersections.getPoint (i).getDistance (checkLine.getLastPoint ());
                                double minDist = Math.min (Math.min (dist1, dist2), Math.min (dist3, dist4));
                                if (minDist > jumpLinkSize.width / 2) {
                                    addJumpLink (intersections.getPoint (i), distances.getPoint (i).x, isFeedbackLayer);
                                }
                            }
                        }
                    }
                }
            }
            combineCloseLinks (tmpLine);
        }

        private void addJumpLink (Point ptIntersect, int nDistance, boolean isFeedbackLayer) {
            JumpLink pNewJumpLink = new JumpLink ();
            pNewJumpLink.m_ptIntersect = new Point (ptIntersect);
            Dimension jumpLinkSize = calculateJumpLinkSize (isFeedbackLayer);
            pNewJumpLink.m_nWidth = jumpLinkSize.width;
            pNewJumpLink.m_nHeight = jumpLinkSize.height;
            pNewJumpLink.m_nDistance = nDistance;
            m_pJumpLinks.add (pNewJumpLink);
        }

        private void combineCloseLinks (PointList tmpLine) {
            if (m_pJumpLinks == null || m_pJumpLinks.size () < 2) return;

            Dimension jumpLinkSize = calculateJumpLinkSize (isFeedbackLayer ());
            int nCurrentWidth = jumpLinkSize.width;
            ArrayList jumpLinks = new ArrayList (m_pJumpLinks.size ());
            sortByDistance ();
            jumpLinks.addAll (m_pJumpLinks);
            m_pJumpLinks.clear ();
            ListIterator linkIter = jumpLinks.listIterator ();
            JumpLink pLastJumpLink = (JumpLink) linkIter.next ();
            JumpLink pPrevJumpLink = null;
            final int nDeltaMin = jumpLinkSize.width * 4 / 3;
            while (pLastJumpLink != null) {
                JumpLink pJumpLink = null;
                int nDelta = 0;
                if (linkIter.hasNext ()) {
                    pJumpLink = (JumpLink) linkIter.next ();
                    nDelta = pJumpLink.m_nDistance - pLastJumpLink.m_nDistance;
                }
                if ((nDelta > nDeltaMin) || pJumpLink == null) {
                    JumpLink pNewJumpLink = new JumpLink ();
                    pNewJumpLink.m_nHeight = jumpLinkSize.height;
                    pNewJumpLink.m_nWidth = nCurrentWidth;
                    pNewJumpLink.m_nDistance = 0;
                    pNewJumpLink.m_ptIntersect = new Point (pLastJumpLink.m_ptIntersect);
                    if (pPrevJumpLink != null) {
                        long nNewDistance = pPrevJumpLink.m_nDistance + ((pLastJumpLink.m_nDistance - pPrevJumpLink.m_nDistance) / 2);
                        pNewJumpLink.m_ptIntersect = new Point ();
                        PointListUtilities.pointOn (tmpLine, nNewDistance, LineSeg.KeyPoint.ORIGIN, pNewJumpLink.m_ptIntersect);
                    }
                    m_pJumpLinks.add (pNewJumpLink);
                    nCurrentWidth = jumpLinkSize.width;
                    pPrevJumpLink = null;
                } else {
                    if (pPrevJumpLink == null) pPrevJumpLink = pLastJumpLink;

                    nCurrentWidth += jumpLinkSize.width - (nDeltaMin - nDelta);
                }
                pLastJumpLink = pJumpLink;
            }
        }

        private boolean m_bDirty;
        private List m_pJumpLinks;
    }

    private final int getSmoothFactor () {
        int smoothStyle = getSmoothness ();
        if (smoothStyle == SMOOTH_LESS) return SMOOTH_FACTOR_LESS;
        else if (smoothStyle == SMOOTH_NORMAL) return SMOOTH_FACTOR_NORMAL;
        else if (smoothStyle == SMOOTH_MORE) return SMOOTH_FACTOR_MORE;

        return 0;
    }

    public final void setSmoothness (int smooth) {
        styleBits &= ~ (SMOOTH_LESS | SMOOTH_NORMAL | SMOOTH_MORE);
        if (smooth == SMOOTH_LESS || smooth == SMOOTH_NORMAL || smooth == SMOOTH_MORE) {
            styleBits |= smooth;
        }
    }

    public final int getSmoothness () {
        if ((styleBits & SMOOTH_LESS) != 0) return SMOOTH_LESS;
        else if ((styleBits & SMOOTH_NORMAL) != 0) return SMOOTH_NORMAL;
        else if ((styleBits & SMOOTH_MORE) != 0) return SMOOTH_MORE;

        return 0;
    }

    public final boolean isClosestDistanceRouting () {
        return ((styleBits & ROUTE_CLOSEST_ROUTE) != 0);
    }

    public final boolean isAvoidObstacleRouting () {
        return ((styleBits & ROUTE_AVOID_OBSTACLE) != 0);
    }

    public void setRoutingStyles (final boolean closestDistance, final boolean avoidObstacles) {
        if (closestDistance) styleBits |= ROUTE_CLOSEST_ROUTE;
        else {
            styleBits &= ~ ROUTE_CLOSEST_ROUTE;
        }
        if (avoidObstacles) {
            if (! closestDistance) styleBits |= ROUTE_CLOSEST_ROUTE;

            styleBits |= ROUTE_AVOID_OBSTACLE;
        } else styleBits &= ~ ROUTE_AVOID_OBSTACLE;

    }

    public final boolean shouldJumpLinks () {
        if ((styleBits & ROUTE_JUMP_LINKS) != 0) {
            IFigure pParent = getParent ();
            if (pParent instanceof ConnectionLayerEx) return ConnectionLayerEx.shouldJumpLinks ();

            return true;
        }
        return false;
    }

    public void setJumpLinks (boolean on) {
        if (on) styleBits |= ROUTE_JUMP_LINKS;
        else styleBits &= ~ ROUTE_JUMP_LINKS;

    }

    public void setJumpLinksStyles (int jumpType, boolean curved, boolean angleIn, boolean onBottom) {
        styleBits &= ~ JUMPLINK_FLAG_ALL;
        styleBits |= jumpType;
        if (curved) styleBits |= JUMPLINK_FLAG_SMOOTH;
        else styleBits &= ~ JUMPLINK_FLAG_SMOOTH;

        if (angleIn) styleBits |= JUMPLINK_FLAG_ANGLEIN;
        else styleBits &= ~ JUMPLINK_FLAG_ANGLEIN;

        if (onBottom) styleBits |= JUMPLINK_FLAG_ONBOTTOM;
        else styleBits &= ~ JUMPLINK_FLAG_ONBOTTOM;

        dirtyJumpLinks ();
    }

    public final boolean isJumpLinksSmooth () {
        return ((styleBits & JUMPLINK_FLAG_SMOOTH) != 0);
    }

    public final boolean isJumpLinksAngledIn () {
        return ((styleBits & JUMPLINK_FLAG_ANGLEIN) != 0);
    }

    public final boolean isJumpLinksOnBottom () {
        return ((styleBits & JUMPLINK_FLAG_ONBOTTOM) != 0);
    }

    void dirtyJumpLinks () {
        JumpLinkSet pJumpLinkSet = getJumpLinkSet ();
        if (pJumpLinkSet != null) {
            pJumpLinkSet.dirtyJumpLinks ();
        }
    }

    private boolean regenerateJumpLinks () {
        JumpLinkSet pJumpLinkSet = getJumpLinkSet ();
        if (pJumpLinkSet != null) {
            return pJumpLinkSet.regenerateJumpLinks (this);
        }
        return false;
    }

    private JumpLinkSet getJumpLinkSet () {
        if (shouldJumpLinks ()) {
            if (jumpLinkSet == null) {
                jumpLinkSet = new JumpLinkSet ();
            }
        } else {
            jumpLinkSet = null;
        }
        return jumpLinkSet;
    }

    static public class PointInfo {
        public int fromLine;
        public int fromEnd;
        public boolean isPercentage = true;
        public double proj = 0.0;
    }

    private static boolean projIn (double proj) {
        return proj > 0 && proj < 1;
    }

    private static double projFactor (double proj) {
        if (proj < 0) return - proj;
        else if (proj > 1.0) return proj - 1.0;
        else return 0;

    }

    private boolean atLeastOneProjectionCovers (Point p) {
        boolean oneProjIn = false;
        List segments = PointListUtilities.getLineSegments (getPoints ());
        ListIterator segIter = segments.listIterator ();
        while (segIter.hasNext () && ! oneProjIn) {
            LineSeg segment = (LineSeg) segIter.next ();
            double proj = segment.projection (p.x, p.y);
            if (projIn (proj)) {
                oneProjIn = true;
            }
        }
        return oneProjIn;
    }

    private PointInfo getPointInfo (Point p) {
        PointInfo pointInfo = new PointInfo ();
        pointInfo.fromLine = Integer.MAX_VALUE;
        pointInfo.fromEnd = 0;
        pointInfo.proj = Double.NEGATIVE_INFINITY;
        List segments = PointListUtilities.getLineSegments (getPoints ());
        int accumulatedLength = 0;
        boolean isCovered = atLeastOneProjectionCovers (p);
        ListIterator segIter = segments.listIterator ();
        while (segIter.hasNext ()) {
            LineSeg segment = (LineSeg) segIter.next ();
            double proj = segment.projection (p.x, p.y);
            Point pt = segment.perpIntersect (p.x, p.y);
            int perpDist = (int) Math.round (p.getDistance (pt));
            if (isCovered) {
                if (perpDist < Math.abs (pointInfo.fromLine)) {
                    if (proj > 0 && proj < 1) {
                        pointInfo.fromLine = (segment.positionRelativeTo (p) == LineSeg.Sign.POSITIVE ? perpDist : - perpDist);
                        Point origin = segment.getOrigin ();
                        int inSegmentDistance = (int) Math.round (origin.getDistance (pt));
                        double fractionDistance = ((double) (accumulatedLength + inSegmentDistance)) / ((double) PointListUtilities.getPointsLength (getPoints ()));
                        pointInfo.fromEnd = (int) Math.round (100 * fractionDistance);
                    }
                }
            } else {
                if (projFactor (proj) < projFactor (pointInfo.proj)) {
                    pointInfo.fromLine = (segment.positionRelativeTo (p) == LineSeg.Sign.POSITIVE ? perpDist : - perpDist);
                    Point origin = segment.getOrigin ();
                    int inSegmentDistance = proj > 0 ? Math.min ((int) Math.round (origin.getDistance (pt)), (int) segment.length ()) : 0;
                    double fractionDistance = ((double) (accumulatedLength + inSegmentDistance)) / ((double) PointListUtilities.getPointsLength (getPoints ()));
                    pointInfo.fromEnd = (int) Math.round (100 * fractionDistance);
                    if (pointInfo.fromEnd > 0 && pointInfo.fromEnd < 100) pointInfo.fromEnd += ((inSegmentDistance == (int) segment.length ()) ? - 1 : 1);

                    pointInfo.proj = proj;
                }
            }
            accumulatedLength += segment.length ();
        }
        if (pointInfo.fromLine == Integer.MAX_VALUE) pointInfo.fromLine = 0;

        return pointInfo;
    }

    public PointList getPolygonPoints () {
        return getSmoothPoints ();
    }

    public ConnectionAnchor getConnectionAnchor (String terminal) {
        ConnectionAnchor connectionAnchor = (ConnectionAnchor) getConnectionAnchors ().get (terminal);
        if (connectionAnchor == null) connectionAnchor = new PolylineAnchor (this, terminal);

        return connectionAnchor;
    }

    public String getConnectionAnchorTerminal (ConnectionAnchor c) {
        if (getConnectionAnchors ().containsValue (c)) {
            Iterator iter = getConnectionAnchors ().keySet ().iterator ();
            String key;
            while (iter.hasNext ()) {
                key = (String) iter.next ();
                if (getConnectionAnchors ().get (key).equals (c)) return key;

            }
        }
        return null;
    }

    public ConnectionAnchor getSourceConnectionAnchorAt (Point p) {
        return createConnectionAnchor (p);
    }

    public ConnectionAnchor getTargetConnectionAnchorAt (Point p) {
        return createConnectionAnchor (p);
    }

    protected ConnectionAnchor createConnectionAnchor (Point p) {
        ConnectionAnchor connectionAnchor = null;
        int fromEnd = 0;
        if (p.x < 0) {
            connectionAnchor = new PolylineAnchor (this, fromEnd = 50);
        } else {
            PointInfo pInfo = getPointInfo (p);
            connectionAnchor = new PolylineAnchor (this, fromEnd = pInfo.fromEnd);
        }
        if (connectionAnchor != null) {
            String szKey = szAnchor + fromEnd;
            getConnectionAnchors ().put (szKey, connectionAnchor);
        }
        return connectionAnchor;
    }

    public void setForegroundColor (Color fg) {
        super.setForegroundColor (fg);
        if (getTargetDecoration () != null) {
            getTargetDecoration ().setForegroundColor (fg);
        }
        if (getSourceDecoration () != null) {
            getSourceDecoration ().setForegroundColor (fg);
        }
    }

    public void setSourceDecoration (RotatableDecoration dec, ConnectionLocator locator) {
        if (getSourceDecoration () != null) remove (getSourceDecoration ());

        startDecoration = dec;
        if (dec != null) {
            add (dec, locator);
        }
    }

    public void setTargetDecoration (RotatableDecoration dec, ConnectionLocator locator) {
        if (getTargetDecoration () != null) remove (getTargetDecoration ());

        endDecoration = dec;
        if (dec != null) {
            add (dec, locator);
        }
    }

    protected RotatableDecoration getTargetDecoration () {
        return endDecoration;
    }

    protected RotatableDecoration getSourceDecoration () {
        return startDecoration;
    }

    public void setTargetDecoration (RotatableDecoration dec) {
        if (getTargetDecoration () != null) remove (getTargetDecoration ());

        endDecoration = dec;
        if (dec != null) {
            add (dec, new ArrowLocator (this, ConnectionLocator.TARGET));
        }
    }

    public void setSourceDecoration (RotatableDecoration dec) {
        if (getSourceDecoration () != null) remove (getSourceDecoration ());

        startDecoration = dec;
        if (dec != null) {
            add (dec, new ArrowLocator (this, ConnectionLocator.SOURCE));
        }
    }

    private int [] dashes = null;

    public void setLineDash (int [] dashes) {
        if (dashes != null) {
            this.dashes = new int [dashes.length];
            for (int i = 0;
            i < dashes.length; i ++) {
                int dash = dashes [i];
                if (dash <= 0) SWT.error (SWT.ERROR_INVALID_ARGUMENT);

                this.dashes [i] = dash;
            }
        } else {
            this.dashes = null;
        }
    }

    public void paintFigure (Graphics graphics) {
        graphics.pushState ();
        if (dashes != null && getLineStyle () == SWT.LINE_CUSTOM) graphics.setLineDash (dashes);

        super.paintFigure (graphics);
        graphics.popState ();
    }

}

