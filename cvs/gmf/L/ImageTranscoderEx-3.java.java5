package org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg;

import java.awt.Color;

import java.awt.Graphics2D;

import java.awt.RenderingHints;

import java.awt.geom.AffineTransform;

import java.awt.geom.Dimension2D;

import java.awt.geom.Rectangle2D;

import java.awt.image.BufferedImage;

import java.net.MalformedURLException;

import java.net.URL;

import org.apache.batik.bridge.BaseScriptingEnvironment;

import org.apache.batik.bridge.BridgeContext;

import org.apache.batik.bridge.BridgeException;

import org.apache.batik.bridge.GVTBuilder;

import org.apache.batik.bridge.ViewBox;

import org.apache.batik.dom.svg.SVGDOMImplementation;

import org.apache.batik.dom.svg.SVGOMDocument;

import org.apache.batik.dom.util.DOMUtilities;

import org.apache.batik.ext.awt.image.GraphicsUtil;

import org.apache.batik.gvt.CanvasGraphicsNode;

import org.apache.batik.gvt.GraphicsNode;

import org.apache.batik.transcoder.TranscoderException;

import org.apache.batik.transcoder.TranscoderOutput;

import org.apache.batik.transcoder.TranscodingHints;

import org.apache.batik.transcoder.image.ImageTranscoder;

import org.apache.batik.transcoder.keys.BooleanKey;

import org.w3c.dom.DOMImplementation;

import org.w3c.dom.Document;

import org.w3c.dom.svg.SVGSVGElement;

public class ImageTranscoderEx extends ImageTranscoder {
    public class DimensionFloat extends Dimension2D {
        private float w;
        private float h;

        public DimensionFloat (float width, float height) {
            super ();
            this.w = width;
            this.h = height;
        }

        public double getWidth () {
            return w;
        }

        public double getHeight () {
            return h;
        }

        public void setSize (double width, double height) {
            this.w = (float) width;
            this.h = (float) height;
        }

    }

    public ImageTranscoderEx () {
    }

    public static final TranscodingHints.Key KEY_MAINTAIN_ASPECT_RATIO = new BooleanKey ();
    public static final TranscodingHints.Key KEY_FILL_COLOR = new ColorKey ();
    public static final TranscodingHints.Key KEY_OUTLINE_COLOR = new ColorKey ();
    public static final TranscodingHints.Key KEY_ANTI_ALIASING = new BooleanKey ();

    protected void initSVGDocument (SVGOMDocument svgDoc) {
        Color fillColor = null;
        Color outlineColor = null;
        if (hints.containsKey (KEY_FILL_COLOR)) {
            fillColor = (Color) hints.get (KEY_FILL_COLOR);
        }
        if (hints.containsKey (KEY_OUTLINE_COLOR)) {
            outlineColor = (Color) hints.get (KEY_OUTLINE_COLOR);
        }
        if (fillColor == null && outlineColor == null) return;

        SVGColorConverter.getInstance ().replaceDocumentColors (svgDoc, fillColor, outlineColor);
    }

    protected GraphicsNode buildGVTTree (SVGOMDocument svgDoc, BridgeContext context) throws TranscoderException {
        GVTBuilder gvtBuilder = new GVTBuilder ();
        GraphicsNode gvtRoot = null;
        try {
            gvtRoot = gvtBuilder.build (context, svgDoc);
        } catch (BridgeException ex) {
            throw new TranscoderException (ex);
        }
        return gvtRoot;
    }

    protected AffineTransform calculateSizeTransform (SVGSVGElement svgRoot, GraphicsNode gvtRoot, String uri, float docWidth, float docHeight, float newWidth, float newHeight) throws TranscoderException {
        AffineTransform Px;
        String ref = null;
        try {
            ref = new URL (uri == null ? "" : uri).getRef ();
        } catch (MalformedURLException ex) {
        }
        boolean maintainAspectRatio = true;
        if (hints.containsKey (KEY_MAINTAIN_ASPECT_RATIO)) {
            maintainAspectRatio = ((Boolean) hints.get (KEY_MAINTAIN_ASPECT_RATIO)).booleanValue ();
        }
        if (maintainAspectRatio) {
            try {
                Px = ViewBox.getViewTransform (ref, svgRoot, newWidth, newHeight);
            } catch (BridgeException ex) {
                throw new TranscoderException (ex);
            }
            if (Px.isIdentity () && (newWidth != docWidth || newHeight != docHeight)) {
                float d = Math.max (docWidth, docHeight);
                float dd = Math.max (newWidth, newHeight);
                float scale = dd / d;
                Px = AffineTransform.getScaleInstance (scale, scale);
            }
        } else {
            float xscale = newWidth / docWidth;
            float yscale = newHeight / docHeight;
            Px = AffineTransform.getScaleInstance (xscale, yscale);
        }
        if (hints.containsKey (KEY_AOI)) {
            Rectangle2D aoi = (Rectangle2D) hints.get (KEY_AOI);
            aoi = Px.createTransformedShape (aoi).getBounds2D ();
            AffineTransform Mx = new AffineTransform ();
            double sx = newWidth / aoi.getWidth ();
            double sy = newHeight / aoi.getHeight ();
            Mx.scale (sx, sy);
            double tx = - aoi.getX ();
            double ty = - aoi.getY ();
            Mx.translate (tx, ty);
            Px.preConcatenate (Mx);
        }
        CanvasGraphicsNode cgn = getCanvasGraphicsNode (gvtRoot);
        if (cgn != null) {
            cgn.setViewingTransform (Px);
            curTxf = new AffineTransform ();
        } else {
            curTxf = Px;
        }
        return curTxf;
    }

    private boolean shouldCopyDocument (Document document) {
        if (! (document.getImplementation () instanceof SVGDOMImplementation)) return true;

        if (hints.containsKey (KEY_FILL_COLOR) || hints.containsKey (KEY_OUTLINE_COLOR)) {
            return true;
        }
        return false;
    }

    protected void transcode (Document document, String uri, TranscoderOutput output) throws TranscoderException {
        if (shouldCopyDocument (document)) {
            DOMImplementation impl;
            impl = SVGDOMImplementation.getDOMImplementation ();
            document = DOMUtilities.deepCloneDocument (document, impl);
            if (uri != null) {
                try {
                    URL url = new URL (uri);
                    ((SVGOMDocument) document).setURLObject (url);
                } catch (MalformedURLException mue) {
                }
            }
        }
        ctx = new BridgeContext (userAgent);
        SVGOMDocument svgDoc = (SVGOMDocument) document;
        SVGSVGElement svgRoot = svgDoc.getRootElement ();
        builder = new GVTBuilder ();
        boolean isDynamic = (hints.containsKey (KEY_EXECUTE_ONLOAD) && ((Boolean) hints.get (KEY_EXECUTE_ONLOAD)).booleanValue () && BaseScriptingEnvironment.isDynamicDocument (ctx, svgDoc));
        if (isDynamic) ctx.setDynamicState (BridgeContext.DYNAMIC);

        initSVGDocument (svgDoc);
        GraphicsNode gvtRoot;
        try {
            gvtRoot = builder.build (ctx, svgDoc);
        } catch (BridgeException ex) {
            throw new TranscoderException (ex);
        }
        float docWidth = (float) ctx.getDocumentSize ().getWidth ();
        float docHeight = (float) ctx.getDocumentSize ().getHeight ();
        setImageSize (docWidth, docHeight);
        AffineTransform Px = calculateSizeTransform (svgRoot, gvtRoot, uri, docWidth, docHeight, width, height);
        gvtRoot = renderImage (output, gvtRoot, Px, (int) width, (int) height);
        this.root = gvtRoot;
    }

    private GraphicsNode renderImage (TranscoderOutput output, GraphicsNode gvtRoot, AffineTransform Px, int w, int h) throws TranscoderException {
        Graphics2D g2d = createGraphics (w, h);
        if (hints.containsKey (KEY_ANTI_ALIASING)) {
            boolean antialias = ((Boolean) hints.get (KEY_ANTI_ALIASING)).booleanValue ();
            g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, antialias ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
        } else {
            g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        }
        g2d.clip (new java.awt.Rectangle (0, 0, w, h));
        g2d.transform (Px);
        gvtRoot.paint (g2d);
        postRenderImage (g2d);
        return null;
    }

    protected Graphics2D createGraphics (int w, int h) {
        bufferedImage = createImage (w, h);
        Graphics2D g2d = GraphicsUtil.createGraphics (bufferedImage);
        return g2d;
    }

    protected void postRenderImage (Graphics2D g2d) {
        g2d.dispose ();
    }

    private BufferedImage bufferedImage = null;

    public BufferedImage getBufferedImage () {
        return bufferedImage;
    }

    public BufferedImage createImage (int w, int h) {
        return new BufferedImage (w, h, BufferedImage.TYPE_INT_ARGB);
    }

    public void writeImage (BufferedImage img, TranscoderOutput arg1) throws TranscoderException {
        bufferedImage = img;
    }

}

