head	1.10;
access;
symbols
	v20081020-0700:1.10
	v20080924-1925:1.10
	v20080917-1925:1.10
	v20080916-2008:1.9
	v20080911-1728:1.10
	v20080722-1827:1.9
	v20080716-1600:1.9
	v20080716-1642:1.9
	R2_1_maintenance:1.9.0.2
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080503-1740:1.9
	v20080425-1959:1.9
	v20080417-1610:1.8
	v20080407-2250:1.8
	v20080407-0930:1.8
	v20080404-1111:1.8
	v20080328-1605:1.8
	v20080222-1200:1.8
	v20080215-1500:1.8
	v20080201-2010:1.8
	v20080201-0201:1.8
	v20071130-1111:1.8
	v20071108-0000:1.8
	v20070903-0000:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.4
	R2_0:1.8
	R4_20:1.8
	v20070621-0000:1.8
	RC3_20:1.8
	v20070601-1400:1.8
	v20070518-1300:1.8
	bugzilla111892_group_support:1.8.0.2
	Root_bugzilla111892_group_support:1.8
	v20070504-1000:1.8
	v20070420-1000:1.8
	v20070413-1300:1.8
	v20070330-1300:1.8
	v20060316-0600:1.8
	v20070228-2000:1.8
	v20070221-1500:1.8
	v20070208-1800:1.8
	M4_20:1.8
	v20061218-1500:1.7.2.1
	v20061214-0000:1.8
	M3_20:1.8
	v20061013-1330:1.8
	v20060919-0800:1.7.2.1
	M1_20:1.7
	v20060803-1200:1.7
	v20060728-0500:1.7
	v20060721-1130:1.7
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060609-1400:1.6
	v20060531-1730:1.6
	v20060530-1930:1.6
	v20060519-0800:1.6
	I20060428-1300:1.6
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060202-1415:1.3
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051201-1800:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.1
	I20051106-0900:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.10
date	2008.09.11.21.29.13;	author aboyko;	state Exp;
branches;
next	1.9;
commitid	40cb48c98da84567;

1.9
date	2008.04.17.21.16.36;	author crevells;	state Exp;
branches;
next	1.8;
commitid	7fa04807be334567;

1.8
date	2006.10.03.15.03.01;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.14.18.40.06;	author ahunter;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.04.06.20.31.25;	author ldamus;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.28.02.31.15;	author cmahoney;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.13.19.10.50;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.01.20.17.41;	author mmostafa;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.17.22.15.51;	author cmahoney;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.02.23.30.53;	author sshaw;	state Exp;
branches;
next	;

1.7.2.1
date	2006.09.08.21.27.48;	author cmahoney;	state Exp;
branches;
next	;


desc
@@


1.10
log
@[236497] gmf_head lgrahek 080911 Cannot copy/paste a rectangle within a circuit (logic diagram example)
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.providers;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.emf.edit.domain.IEditingDomainProvider;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartViewer;
import org.eclipse.gef.Request;
import org.eclipse.gef.RequestConstants;
import org.eclipse.gef.RootEditPart;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CommandStack;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gef.requests.GroupRequest;
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.action.actions.global.ClipboardContentsHelper;
import org.eclipse.gmf.runtime.common.ui.action.actions.global.ClipboardManager;
import org.eclipse.gmf.runtime.common.ui.action.global.GlobalActionId;
import org.eclipse.gmf.runtime.common.ui.services.action.global.AbstractGlobalActionHandler;
import org.eclipse.gmf.runtime.common.ui.services.action.global.IGlobalActionContext;
import org.eclipse.gmf.runtime.common.ui.util.ICustomData;
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.INodeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.ClipboardCommand;
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.CopyCommand;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramCommandStack;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart;
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.DiagramProvidersDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.DiagramProvidersPlugin;
import org.eclipse.gmf.runtime.diagram.ui.requests.PasteViewRequest;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand;
import org.eclipse.gmf.runtime.emf.ui.properties.actions.PropertyPageViewAction;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchPart;

/**
 * Class that implements the <code>IGlobalActionHandler</code> interface.
 * Contains behaviour common to GMF diagrams.
 * 
 * @@author Vishy Ramaswamy
 */
public class DiagramGlobalActionHandler
	extends AbstractGlobalActionHandler {

	/** Remember the "open" commands associated with the selected edit parts. */
	private ICommand openCommand = null;

	/**
	 * Constructor for DiagramGlobalActionHandler.
	 */
	public DiagramGlobalActionHandler() {
		super();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.common.ui.services.action.global.IGlobalActionHandler#getCommand(org.eclipse.gmf.runtime.common.ui.services.action.global.IGlobalActionContext)
	 */
	public ICommand getCommand(IGlobalActionContext cntxt) {
		/* Check if the active part is a IDiagramWorkbenchPart */
		IWorkbenchPart part = cntxt.getActivePart();
		if (!(part instanceof IDiagramWorkbenchPart)) {
			return null;
		}

		/* Get the model operation context */
		IDiagramWorkbenchPart diagramPart = (IDiagramWorkbenchPart) part;

		/* Create a command */
		ICommand command = null;

		/* Check the action id */
		String actionId = cntxt.getActionId();
		if (actionId.equals(GlobalActionId.DELETE)) {
			CompoundCommand deleteCC = getDeleteCommand(diagramPart, cntxt);
			/* Set the command */
			if (deleteCC != null && deleteCC.canExecute())
				command = new CommandProxy(deleteCC);
		} else if (actionId.equals(GlobalActionId.COPY)) {
			command = getCopyCommand(cntxt, diagramPart, false);
		} else if (actionId.equals(GlobalActionId.CUT)) {
			command = getCutCommand(cntxt, diagramPart);
		} else if (actionId.equals(GlobalActionId.OPEN)) {
			// Open command: use the previously cached command.
			command = openCommand;
		} else if (actionId.equals(GlobalActionId.PASTE)) {

			PasteViewRequest pasteReq = createPasteViewRequest();

			/* Get the selected edit parts */
			Object[] objects = ((IStructuredSelection) cntxt.getSelection())
				.toArray();

			if (objects.length == 1) {
				/* Send the request to the target edit part of the paste command for the currently selected part */
				EditPart targetEP = ((EditPart) objects[0]).getTargetEditPart(pasteReq);
				Command paste = targetEP.getCommand(pasteReq);
				if (paste != null) {
					/* Set the command */
					CommandStack cs = diagramPart.getDiagramEditDomain()
						.getDiagramCommandStack();
					cs.execute(paste);
					diagramPart.getDiagramEditPart().getFigure().invalidate();
					diagramPart.getDiagramEditPart().getFigure().validate();
					selectAddedObject(diagramPart.getDiagramGraphicalViewer(),
						DiagramCommandStack.getReturnValues(paste));
					return null;
				}
			}
		} else if (actionId.equals(GlobalActionId.SAVE)) {
			part.getSite().getPage().saveEditor((IEditorPart) diagramPart,
				false);
		} else if (actionId.equals(GlobalActionId.PROPERTIES)) {
			new PropertyPageViewAction().run();
		}

		return command;
	}

	/**
	 * Returns a command to copy the context's selection to the clipboard.
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> from which the label
	 *            and selection are retrieved.
	 * @@param diagramPart
	 *            the <code>IDiagramWorkbenchPart</code> from which the
	 *            diagram is retrieved.
	 * @@param isUndoable
	 *            true if this command should be undoable/redoable; false
	 *            otherwise
	 * @@return the copy command
	 */
	protected ICommand getCopyCommand(IGlobalActionContext cntxt,
			IDiagramWorkbenchPart diagramPart, final boolean isUndoable) {

        TransactionalEditingDomain editingDomain = getEditingDomain(diagramPart);
        
        if (editingDomain == null) {
            return null;
        }
        
        return new CopyCommand(editingDomain, cntxt.getLabel(), diagramPart.getDiagram(),
			getSelectedViews(cntxt.getSelection())) {

			public boolean canUndo() {
				return isUndoable;
			}

			public boolean canRedo() {
				return isUndoable;
			}

		
            protected IStatus doUndo(IProgressMonitor monitor, IAdaptable info)
                throws ExecutionException {

                if (isUndoable) {
                    return Status.OK_STATUS;
			}
                return super.doUndo(monitor, info);
            }

			protected IStatus doRedo(IProgressMonitor monitor, IAdaptable info)
                throws ExecutionException {

                if (isUndoable) {
                    return Status.OK_STATUS;
			}
                return super.doRedo(monitor, info);
            }
		};
	}

	/**
	 * Returns a command to copy the context's selection to the clipboard and to
	 * delete it.
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> from which the label
	 *            and selection are retrieved.
	 * @@param diagramPart
	 *            the <code>IDiagramWorkbenchPart</code> from which the
	 *            diagram is retrieved.
	 * @@return the cut command
	 */
	protected ICommand getCutCommand(IGlobalActionContext cntxt,
			IDiagramWorkbenchPart diagramPart) {

        TransactionalEditingDomain editingDomain = getEditingDomain(diagramPart);

        if (editingDomain == null) {
            return null;
        }
        
        CompositeTransactionalCommand cut = new CompositeTransactionalCommand(editingDomain, cntxt
            .getLabel());

		// Add a copy command - the cut must be undoable/redoable
		cut.compose(getCopyCommand(cntxt, diagramPart, true));

		/* Get the selected edit parts */
		Object[] objects = ((IStructuredSelection) cntxt.getSelection())
			.toArray();
		for (int i = 0; i < objects.length; i++) {
			/* Get the next part */
			EditPart editPart = (EditPart) objects[i];

			/* Create the delete request */
			GroupRequest deleteReq = new GroupRequest(
				RequestConstants.REQ_DELETE);

			/* Send the request to the edit part */
			Command deleteCommand = editPart.getCommand(deleteReq);

			/* Add to the compound command */
			if (deleteCommand != null) {
				cut.compose(new CommandProxy(deleteCommand));
			}
		}

		if (!cut.isEmpty() && cut.canExecute())
			return cut;

		return null;
	}

	/**
	 * Creates and returns the appropriate <code>PasteViewRequest</code> that
	 * is to be used to get the appropriate paste <code>Command</code> from
	 * the <code>EditPart</code>. The returned <code>PasteViewRequest</code>
	 * contains data from the clipboard
	 * 
	 * @@return PasteViewRequest
	 */
	protected PasteViewRequest createPasteViewRequest() {
		PasteViewRequest pasteReq;
		ICustomData[] data = ClipboardManager.getInstance().getClipboardData(
			ClipboardCommand.DRAWING_SURFACE,
			ClipboardContentsHelper.getInstance());
		if (data == null) {
			data = ClipboardManager.getInstance().getClipboardData(
				ClipboardManager.COMMON_FORMAT,
				ClipboardContentsHelper.getInstance());
		}
		/* Create the paste request */
		pasteReq = new PasteViewRequest(data);
		return pasteReq;
	}

	/**
	 * Returns appropriate delete command for this context.
	 * 
     * @@param part the workbench part
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return CompoundCommand command
	 */
	private CompoundCommand getDeleteCommand(IDiagramWorkbenchPart part,
            IGlobalActionContext cntxt) {
		/* Create the delete request */
		GroupRequest deleteReq = new GroupRequest(RequestConstants.REQ_DELETE);

		CompoundCommand deleteCC = new CompoundCommand(cntxt.getLabel());

        TransactionalEditingDomain editingDomain = getEditingDomain(part);
        
        if (editingDomain == null) {
            return deleteCC;
        }

		CompositeTransactionalCommand compositeCommand = new CompositeTransactionalCommand(editingDomain, 
			cntxt.getLabel());
		/* Get the selected edit parts */
		Object[] objects = ((IStructuredSelection) cntxt.getSelection())
			.toArray();
		for (int i = 0; i < objects.length; i++) {
			/* Get the next part */
			EditPart editPart = (EditPart) objects[i];

			/* Send the request to the edit part */
			Command command = editPart.getCommand(deleteReq);
			if (command != null)
				compositeCommand.compose(new CommandProxy(command));
			// deleteCC.add(editPart.getCommand(deleteReq));
		}
		if (!compositeCommand.isEmpty()) {
			deleteCC.add(new ICommandProxy(compositeCommand));
		}

		return deleteCC;
	}

	private boolean isContainedInViews(List views, View view) {
		while (view != null) {
			if (views.contains(view)) {
				return true;
			}
			if (view.eContainer() instanceof View)
				view = (View) view.eContainer();
			else
				break;
		}
		return false;
	}

	/**
	 * Returns the selected <code>View</code> objects, only if the selection
	 * is an <code>IStructuredSelection</code>. and only the
	 * <code>View</code> object of an <code>INodeEditPart</code> or a
	 * <code>ShapeEditPart</code>
	 * 
	 * @@param sel
	 *            the selection from which to extract the View objects
	 * @@return List the selected View. Could be empty if the selection doesn't
	 *         contain proper edit parts, or, could be the original if the
	 *         selection is not an <code>IStructuredSelection</code>
	 */
	protected List getSelectedViews(ISelection sel) {
		final ArrayList views = new ArrayList();
		final ArrayList editParts = new ArrayList();

		/* Check if the selection is a structured selection */
		if (!(sel instanceof IStructuredSelection)) {
			return views;
		}

		/* Get the relevant Views */
		for (Iterator i = ((IStructuredSelection) sel).iterator(); i.hasNext();) {
			Object object = i.next();

			if (!((object instanceof INodeEditPart) || (object instanceof ShapeEditPart))) {
				continue;
			}

			View view = (object instanceof IAdaptable) ? (View) ((IAdaptable) object)
				.getAdapter(View.class)
				: null;

			/* Make sure that view is not deleted */
			if (view != null && view.eResource() != null) {
				views.add(view);
				editParts.add(object);
			}
		}

		/* Get rid of dangling connections */
		if (!views.isEmpty()) {
			try {
				TransactionUtil.getEditingDomain(views.get(0)).runExclusive(
					new Runnable() {
	
						public void run() {
							ArrayList objects = (ArrayList) views.clone();
							for (Iterator i = objects.iterator(); i.hasNext();) {
								Object object = i.next();
								if (object instanceof Edge) {
									Edge view = (Edge) object;
									View fromView = view.getSource();
									View toView = view.getTarget();
									if (fromView == null || toView == null
										|| !isContainedInViews(views, fromView)
										|| !isContainedInViews(views, toView)) {
										views.remove(view);
									}
								}
							}
						}
					});
			} catch (Exception e) {
				Trace.catching(DiagramProvidersPlugin.getInstance(),
					DiagramProvidersDebugOptions.EXCEPTIONS_CATCHING, getClass(),
					"getSelectedViews()", //$NON-NLS-1$
					e);
			}
		}

		/* Make sure that the selection contains atleast one IShapeView */
		boolean doesSelectionContainAShapeView = false;
		for (Iterator i = editParts.iterator(); i.hasNext();) {
			if (i.next() instanceof ShapeEditPart) {
				doesSelectionContainAShapeView = true;
				break;
			}
		}

		/* Clear the selection if no shape views are present */
		if (!doesSelectionContainAShapeView) {
			views.clear();
		}
		return views;
	}

	/**
	 * Checks to determine if the selected edit part can be opened.
	 * <p>
	 * In order to truly verify that the edit part can be opened, the
	 * corresponding "open" command must be obtained and tested for execution.
	 * This command can then be cached for the getCommand() method.
	 * <p>
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return boolean - indicates an "open" command exists and can be executed
	 */
	private boolean canOpen(IGlobalActionContext cntxt) {
		// Reset any information about the elements to be opened.
		boolean canOpenAll = true;
		openCommand = new CompositeCommand(cntxt.getLabel());

		// Since all edit parts are associated with the smae edit domain,
		// get the model operation context from the first selected edit part.
		Object[] objects = ((IStructuredSelection) cntxt.getSelection())
			.toArray();

		// For all of the selected objects until one cannot be opened
		for (int i = 0; canOpenAll && i < objects.length; i++) {
			if (objects[i] instanceof EditPart) {
				// Get the edit part's command for the "open" request.
				EditPart editPart = (EditPart) objects[i];
				Request request = new Request(RequestConstants.REQ_OPEN);
				Command cmd = editPart.getCommand(request);

				// If a command is not available or cannot be executed,
				if (cmd == null || !cmd.canExecute()) {
					// Do not allow any of the selected parts to be opened.
					canOpenAll = false;
				}

				// else add the command to the composite command.
				else {
					openCommand.compose(new CommandProxy(cmd));
				}
			}

		}

		if (!canOpenAll) {
			openCommand = null;
		}
		return canOpenAll;
	}

	/**
	 * Checks if the selected IViews can be deleted.
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return boolean indicating the enablement of the delete action
	 */
	private boolean canDelete(IGlobalActionContext cntxt) {

		// The selectedObjects are not in a container
		// that is set to canonical, so do a regular check that the
		// command is not null.
		return getCommand(cntxt) != null;
	}

	/**
	 * Checks if the selected IViews can be copied to the clipboard
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return boolean indicating the enablement of the copy action
	 */
	protected boolean canCopy(IGlobalActionContext cntxt) {
		List elements = getSelectedViews(cntxt.getSelection());
		/* Make sure the selection is not empty */
		if (elements.isEmpty()) {
			return false;
		}

		return true;
	}

	/**
	 * Checks if the selected IViews can be cut
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return boolean indicating the enablement of the cut action
	 */
	protected boolean canCut(IGlobalActionContext cntxt) {
		String actionId = cntxt.getActionId();
		if (actionId.equals(GlobalActionId.CUT)) {
			ICommand command = getCommand(cntxt);
			if (command != null && command.canExecute()) {
				return canCopy(cntxt);
			}
		}
		return false;
	}

	/**
	 * Checks if the paste can occur
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return boolean indicating the enablement of the paste action
	 */
	protected boolean canPaste(IGlobalActionContext cntxt) {
		/* Check if the clipboard has data for the drawing surface */
		return ClipboardManager.getInstance().doesClipboardHaveData(
			ClipboardCommand.DRAWING_SURFACE,
			ClipboardContentsHelper.getInstance())
			|| (ClipboardManager.getInstance().doesClipboardHaveData(
				ClipboardManager.COMMON_FORMAT, ClipboardContentsHelper
					.getInstance()));
	}

	/**
	 * Checks if the selected IElements will allow a print
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return boolean indicating the enablement of the print action
	 */
	private boolean canPrint() {
		return true;
	}

	/**
	 * Checks if the selected IElements will allow a save. Save should only be
	 * enabled when no shapes are selected to avoid clutter on the context menu
	 * and if the editor is dirty.
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return boolean indicating the enablement of the save action
	 */
	protected boolean canSave(IGlobalActionContext cntxt) {
		IWorkbenchPart part = cntxt.getActivePart();
		if (part instanceof IDiagramWorkbenchPart
			&& part instanceof IEditorPart && ((IEditorPart) part).isDirty()) {
			return true;
		}
		return false;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.common.ui.services.action.global.IGlobalActionHandler#canHandle(org.eclipse.gmf.runtime.common.ui.services.action.global.IGlobalActionContext)
	 */
	public boolean canHandle(final IGlobalActionContext cntxt) {
		boolean result = false;

		/* Check if the active part is a IDiagramWorkbenchPart */
		IWorkbenchPart part = cntxt.getActivePart();
		if (!(part instanceof IDiagramWorkbenchPart)) {
			return false;
		}

		/* Check if the selection is a structured selection */
		if (!(cntxt.getSelection() instanceof IStructuredSelection)) {
			return result;
		}

		/* Check the action id */
		String actionId = cntxt.getActionId();
		if (actionId.equals(GlobalActionId.DELETE)) {
			result = canDelete(cntxt);
		} else if (actionId.equals(GlobalActionId.COPY)) {
			result = canCopy(cntxt);
		} else if (actionId.equals(GlobalActionId.CUT)) {
			result = canCut(cntxt);
		} else if (actionId.equals(GlobalActionId.OPEN)) {
			result = canOpen(cntxt);
		} else if (actionId.equals(GlobalActionId.PASTE)) {
			result = canPaste(cntxt);
		} else if (actionId.equals(GlobalActionId.PRINT)) {
			result = canPrint();
		} else if (actionId.equals(GlobalActionId.SAVE)) {
			result = canSave(cntxt);
		} else if (actionId.equals(GlobalActionId.PROPERTIES)) {
			result = true;
		}

		return result;
	}

	/**
	 * Select the newly added shape view by default.
	 * 
	 * @@param viewer
	 *            the viewer owning the edit parts to be selected
	 * @@param objects
	 *            the collection of object from which to extract the
	 *            <code>EditPart</code> to select
	 */
	protected void selectAddedObject(EditPartViewer viewer, Collection objects) {
		final List editparts = new ArrayList();
		for (Iterator i = objects.iterator(); i.hasNext();) {
			EditPart editPart = getEditPart(viewer, i.next());
			if (editPart != null && editPart.isSelectable())
				editparts.add(editPart);
		}
		if (!editparts.isEmpty()) {
			viewer.setSelection(new StructuredSelection(editparts));
			viewer.reveal((EditPart) editparts.get(0));
		}
	}

	private EditPart getEditPart(EditPartViewer viewer, Object object) {
		if (object instanceof View) {
			return (EditPart) viewer.getEditPartRegistry().get(object);
		} else if (object instanceof IAdaptable) {
			return (EditPart) viewer.getEditPartRegistry().get(
				((IAdaptable) object).getAdapter(View.class));
		}
		return null;
	}

	/**
	 * Retrieve the <code>IMapMode</code> object from the
	 * <code>DiagramRootEditPart</code>
	 * 
	 * @@param cntxt
	 *            the <code>IGlobalActionContext</code> holding the necessary
	 *            information needed by this action handler
	 * @@return <code>IMapMode</code> object that performs coordinate mapping
	 *         from device to logical. Returns null if the context isn't valid.
	 */
	protected IMapMode getMapMode(IGlobalActionContext cntxt) {

		IWorkbenchPart part = cntxt.getActivePart();
		if (!(part instanceof IDiagramWorkbenchPart)) {
			RootEditPart rootEP = ((IDiagramWorkbenchPart) part)
				.getDiagramGraphicalViewer().getRootEditPart();
			if (rootEP instanceof DiagramRootEditPart) {
				return ((DiagramRootEditPart) part).getMapMode();
			}
		}

		return MapModeUtil.getMapMode();
	}
    
    /**
     * Gets the transactional editing domain associated with the workbench
     * <code>part</code>.
     * 
     * @@param part
     *            the diagram workbench part
     * @@return the editing domain, or <code>null</code> if there is none.
     */
    private TransactionalEditingDomain getEditingDomain(
            IDiagramWorkbenchPart part) {

        TransactionalEditingDomain result = null;

        IEditingDomainProvider provider = (IEditingDomainProvider) part
            .getAdapter(IEditingDomainProvider.class);

        if (provider != null) {
            EditingDomain domain = provider.getEditingDomain();

            if (domain != null && domain instanceof TransactionalEditingDomain) {
                result = (TransactionalEditingDomain) domain;
}        }

        return result;
    }
}@


1.9
log
@[227651] gmf_head crevells 080417 PasteViewRequest should be public
@
text
@d130 3
a132 2
				/* Send the request to the currently selected part */
				Command paste = ((EditPart) objects[0]).getCommand(pasteReq);
@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
a52 1
import org.eclipse.gmf.runtime.diagram.ui.internal.requests.PasteViewRequest;
d57 1
@


1.7
log
@[139856] gmf_head anthonyh 060614 EtoolsProxyCommand should be renamed to ICommandProxy
@
text
@d636 2
a637 2
			Object editPart = getEditPart(viewer, i.next());
			if (editPart != null)
@


1.7.2.1
log
@Bugzilla#155610 gmf_R1_0_maintenance cmahoney 060908 An edit part should not be edited if is is not selectable
@
text
@d636 2
a637 2
			EditPart editPart = getEditPart(viewer, i.next());
			if (editPart != null && editPart.isSelectable())
@


1.6
log
@[135386] gmf_head ldamus 060406 Runtime plugin dependencies must specify required plugin versions
@
text
@d47 1
a47 1
import org.eclipse.gmf.runtime.diagram.ui.commands.EtoolsProxyCommand;
d323 1
a323 1
			deleteCC.add(new EtoolsProxyCommand(compositeCommand));
@


1.5
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@a45 1
import org.eclipse.gmf.runtime.diagram.ui.actions.internal.DiagramActionsDebugOptions;
d56 1
d407 1
a407 1
					DiagramActionsDebugOptions.EXCEPTIONS_CATCHING, getClass(),
@


1.4
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d27 1
a45 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
a60 1
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
d194 1
a194 1
                }
d203 1
a203 1
                }
d223 1
a223 1
        
a308 1
        
d383 18
a400 16
		try {
			MEditingDomainGetter.getMEditingDomain(views).runAsRead(
				new MRunnable() {

					public Object run() {
						ArrayList objects = (ArrayList) views.clone();
						for (Iterator i = objects.iterator(); i.hasNext();) {
							Object object = i.next();
							if (object instanceof Edge) {
								Edge view = (Edge) object;
								View fromView = view.getSource();
								View toView = view.getTarget();
								if (fromView == null || toView == null
									|| !isContainedInViews(views, fromView)
									|| !isContainedInViews(views, toView)) {
									views.remove(view);
d404 7
a410 8
						return null;
					}
				});
		} catch (Exception e) {
			Trace.catching(DiagramProvidersPlugin.getInstance(),
				DiagramActionsDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"getSelectedViews()", //$NON-NLS-1$
				e);
d701 1
a701 2
            }
        }
@


1.3
log
@bugzilla 109923 gmf-head mmostafa 060201 Class names contain 'xtools'
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d19 1
d21 6
a35 1
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
d47 1
a48 1
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
d60 1
a60 1
import org.eclipse.gmf.runtime.emf.commands.core.command.CompositeModelCommand;
d111 1
a111 1
			CompoundCommand deleteCC = getDeleteCommand(cntxt);
d172 7
a178 1
		return new CopyCommand(cntxt.getLabel(), diagramPart.getDiagram(),
d181 1
a181 1
			public boolean isUndoable() {
d185 1
a185 1
			public boolean isRedoable() {
d189 18
a206 9
			protected CommandResult doUndo() {
				return isUndoable ? newOKCommandResult()
					: super.doUndo();
			}

			protected CommandResult doRedo() {
				return isUndoable ? newOKCommandResult()
					: super.doRedo();
			}
d224 9
a232 1
		CompositeModelCommand cut = new CompositeModelCommand(cntxt.getLabel());
d257 1
a257 1
		if (!cut.isEmpty() && cut.isExecutable())
d289 1
d295 2
a296 1
	private CompoundCommand getDeleteCommand(IGlobalActionContext cntxt) {
d302 7
a308 1
		CompositeModelCommand compositeCommand = new CompositeModelCommand(
d310 1
d324 1
a324 1
		if (compositeCommand.getCommands().size() > 0) {
d527 1
a527 1
			if (command != null && command.isExecutable()) {
d680 27
@


1.2
log
@Bugzilla#110848 gmf_head cmahoney 051117 Paste puts new shapes right on top of old shapes
@
text
@d42 1
a42 1
import org.eclipse.gmf.runtime.diagram.ui.commands.XtoolsProxyCommand;
d108 1
a108 1
				command = new XtoolsProxyCommand(deleteCC);
d224 1
a224 1
				cut.compose(new XtoolsProxyCommand(deleteCommand));
d283 1
a283 1
				compositeCommand.compose(new XtoolsProxyCommand(command));
d431 1
a431 1
					openCommand.compose(new XtoolsProxyCommand(cmd));
@


1.1
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d132 2
d605 1
@

