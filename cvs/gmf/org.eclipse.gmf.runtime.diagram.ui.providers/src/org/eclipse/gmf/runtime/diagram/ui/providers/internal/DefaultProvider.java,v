head	1.21;
access;
symbols
	v20081020-0700:1.21
	v20080924-1925:1.21
	v20080917-1925:1.21
	v20080916-2008:1.20.2.1
	v20080911-1728:1.21
	v20080722-1827:1.21
	v20080716-1600:1.20.2.1
	v20080716-1642:1.21
	R2_1_maintenance:1.20.0.2
	Root_R2_1_maintenance:1.20
	R2_1_0:1.20
	v20080503-1740:1.20
	v20080425-1959:1.20
	v20080417-1610:1.19
	v20080407-2250:1.18
	v20080407-0930:1.18
	v20080404-1111:1.18
	v20080328-1605:1.17
	v20080222-1200:1.17
	v20080215-1500:1.17
	v20080201-2010:1.16
	v20080201-0201:1.14
	v20071130-1111:1.14
	v20071108-0000:1.14
	v20070903-0000:1.14
	v20070809-0000:1.14
	R2_0_maintenance:1.14.0.4
	R2_0:1.14
	R4_20:1.14
	v20070621-0000:1.14
	RC3_20:1.14
	v20070601-1400:1.14
	v20070518-1300:1.14
	bugzilla111892_group_support:1.14.0.2
	Root_bugzilla111892_group_support:1.14
	v20070504-1000:1.14
	v20070420-1000:1.14
	v20070413-1300:1.14
	v20070330-1300:1.14
	v20060316-0600:1.14
	v20070228-2000:1.14
	v20070221-1500:1.14
	v20070208-1800:1.14
	M4_20:1.14
	v20061218-1500:1.13.2.2
	v20061214-0000:1.14
	M3_20:1.14
	v20061013-1330:1.14
	v20060919-0800:1.13.2.2
	M1_20:1.13
	v20060803-1200:1.13.2.1
	v20060728-0500:1.13.2.1
	v20060721-1130:1.13.2.1
	v20060713-1700:1.13.2.1
	R1_0_maintenance:1.13.0.2
	R1_0:1.13
	v20060627-1200:1.13
	v20060616-1200:1.13
	v20060609-1400:1.13
	v20060531-1730:1.12
	v20060530-1930:1.12
	v20060519-0800:1.12
	I20060428-1300:1.12
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.12
	I20060407-1200:1.12
	I20060331-1000:1.10
	I20060324-0300:1.10
	I20060317-1300:1.10
	I20060317-1200:1.10
	I20060316-1300:1.10
	I20060309-1300:1.10
	M5_10:1.10
	S20060303-1600:1.10
	I20060227-1730:1.10
	I20060216-1945:1.9
	I20060210-1715:1.8
	I20060209-1815:1.8
	I20060203-0830:1.7
	I20060202-1415:1.7
	I20060129-1145:1.7
	I20060127-0900:1.7
	I20060120-1530:1.7
	I20060113-1700:1.7
	M4_10:1.7
	I20060107-1100:1.7
	I20060105-1630:1.7
	I20051230-1230:1.7
	I20051223-1100:1.7
	I20051201-1800:1.7
	I20051124-2000:1.7
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.5
	I20051106-0900:1.5
	v20051030:1.3;
locks; strict;
comment	@# @;


1.21
date	2008.06.18.18.29.53;	author aboyko;	state Exp;
branches;
next	1.20;
commitid	1958485954204567;

1.20
date	2008.04.23.20.03.54;	author aboyko;	state Exp;
branches
	1.20.2.1;
next	1.19;
commitid	451480f96294567;

1.19
date	2008.04.17.00.04.46;	author aboyko;	state Exp;
branches;
next	1.18;
commitid	1504806941d4567;

1.18
date	2008.04.03.16.30.09;	author aboyko;	state Exp;
branches;
next	1.17;
commitid	3e0047f506114567;

1.17
date	2008.02.04.21.03.02;	author aboyko;	state Exp;
branches;
next	1.16;
commitid	50da47a77d854567;

1.16
date	2008.01.22.17.28.08;	author aboyko;	state Exp;
branches;
next	1.15;
commitid	4ed7479627a84567;

1.15
date	2008.01.14.20.43.04;	author crevells;	state Exp;
branches;
next	1.14;
commitid	49cf478bc9574567;

1.14
date	2006.10.03.15.03.01;	author ahunter;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2006.06.05.20.31.25;	author sshaw;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2006.04.06.20.31.25;	author ldamus;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.03.17.20.01;	author mmostafa;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.24.23.30.10;	author mmostafa;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.16.21.48.40;	author sshaw;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.07.15.19.01;	author mmostafa;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.24.22.20.58;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.21.17.01.19;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.04.21.28.09;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.02.23.30.53;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.26.25;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.03;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.44;	author sshaw;	state Exp;
branches;
next	;

1.13.2.1
date	2006.07.09.22.36.55;	author mmostafa;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2006.09.13.16.43.25;	author ahunter;	state Exp;
branches;
next	;

1.14.2.1
date	2007.05.18.17.36.40;	author crevells;	state Exp;
branches;
next	;
commitid	1863464de4274567;

1.20.2.1
date	2008.06.18.18.31.36;	author aboyko;	state Exp;
branches;
next	;
commitid	1aa6485954884567;


desc
@@


1.21
log
@[237329] gmf_head aboyko 080618 [Layout] BorderItems connection anchor points are incorrectly caliculated for CompositeLayoutProvider
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.providers.internal;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Insets;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionDimension;
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.PrecisionRectangle;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.draw2d.graph.DirectedGraph;
import org.eclipse.draw2d.graph.DirectedGraphLayout;
import org.eclipse.draw2d.graph.Edge;
import org.eclipse.draw2d.graph.EdgeList;
import org.eclipse.draw2d.graph.Node;
import org.eclipse.draw2d.graph.NodeList;
import org.eclipse.draw2d.graph.Subgraph;
import org.eclipse.gef.ConnectionEditPart;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPolicy;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.Request;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gef.editpolicies.NonResizableEditPolicy;
import org.eclipse.gef.requests.ChangeBoundsRequest;
import org.eclipse.gef.requests.ReconnectRequest;
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.service.IOperation;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.commands.SetConnectionAnchorsCommand;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderedShapeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ListItemEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.LayoutNodesOperation;
import org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants;
import org.eclipse.gmf.runtime.diagram.ui.requests.SetAllBendpointRequest;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutEditPartProvider;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutType;
import org.eclipse.gmf.runtime.draw2d.ui.figures.BaseSlidableAnchor;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PrecisionPointList;
import org.eclipse.gmf.runtime.draw2d.ui.graph.BorderNode;
import org.eclipse.gmf.runtime.draw2d.ui.graph.ConstantSizeNode;
import org.eclipse.gmf.runtime.draw2d.ui.graph.ConstrainedEdge;
import org.eclipse.gmf.runtime.draw2d.ui.graph.GMFDirectedGraphLayout;
import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.OrthogonalRouter;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.notation.View;

/**
 * Provider that creates a command for the DirectedGraph layout in GEF.
 * 
 * @@author sshaw
 * @@canBeSeenBy org.eclipse.gmf.runtime.diagram.ui.providers.*
 * 
 */
public abstract class DefaultProvider
    extends AbstractLayoutEditPartProvider {

    // Minimum sep between icon and bottommost horizontal arc
    protected int minX = -1;
    protected int minY = -1;
    protected int layoutDefaultMargin = 0;
    protected IMapMode mm;
    
    protected static final int NODE_PADDING = 30;
    protected static final int MIN_EDGE_PADDING = 15;
    protected static final int MAX_EDGE_PADDING = NODE_PADDING * 3;
    protected static final int MIN_EDGE_END_POINTS_PADDING = 5;
    

    
    /**
     * @@return the <code>IMapMode</code> that maps coordinates from
     * device to logical and vice-versa.
     */
    protected IMapMode getMapMode() {
        return mm;
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.common.core.service.IProvider#provides(org.eclipse.gmf.runtime.common.core.service.IOperation)
     */
    public boolean provides(IOperation operation) {
        Assert.isNotNull(operation);

        View cview = getContainer(operation);
        if (cview == null)
            return false;

        IAdaptable layoutHint = ((LayoutNodesOperation) operation)
            .getLayoutHint();
        String layoutType = (String) layoutHint.getAdapter(String.class);
        return LayoutType.DEFAULT.equals(layoutType);
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutEditPartProvider#layoutEditParts(org.eclipse.gef.GraphicalEditPart, org.eclipse.core.runtime.IAdaptable)
     */
    public Command layoutEditParts(GraphicalEditPart containerEditPart,
            IAdaptable layoutHint) {
        if (containerEditPart == null) {
            InvalidParameterException ipe = new InvalidParameterException();
            Trace.throwing(DiagramProvidersPlugin.getInstance(),
                DiagramProvidersDebugOptions.EXCEPTIONS_THROWING, getClass(),
                "layout()", //$NON-NLS-1$
                ipe);
            throw ipe;
        }
        mm = MapModeUtil.getMapMode(containerEditPart.getFigure());
        // setup graph
        DirectedGraph g = createGraph();
        build_graph(g, containerEditPart.getChildren());
        createGraphLayout().visit(g);
        // update the diagram based on the graph
        Command cmd = update_diagram(containerEditPart, g, false);
        
        // reset mm mapmode to avoid memory leak
        mm = null;
        return cmd;
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutEditPartProvider#layoutEditParts(java.util.List, org.eclipse.core.runtime.IAdaptable)
     */
    public Command layoutEditParts(List selectedObjects, IAdaptable layoutHint) {

        if (selectedObjects.size() == 0) {
            return null;
        }

        // get the container edit part for the children
        GraphicalEditPart editPart = (GraphicalEditPart) selectedObjects.get(0);
        GraphicalEditPart containerEditPart = (GraphicalEditPart) editPart
            .getParent();

        mm = MapModeUtil.getMapMode(containerEditPart.getFigure());
        
        DirectedGraph g = createGraph();
        build_graph(g, selectedObjects);
        createGraphLayout().visit(g);
        // update the diagram based on the graph
        Command cmd = update_diagram(containerEditPart, g, true);
        
        // reset mm mapmode to avoid memory leak
        mm = null;
        return cmd;
    }

    /**
     * layoutTopDown Utility function that is commonly subclasses by domain
     * specific layouts to determine whether a specific connection type is layed
     * out in a top down manner.
     * 
     * @@param poly
     *            <code>ConnectionEditPart</code> to determine whether it is to be layed
     *            out in a top-down fashion.
     * @@return true if connection is to be layed out top-down, false otherwise.
     */
    protected boolean layoutTopDown(ConnectionEditPart poly) {
        return false;
    }

    /**
     * build_nodes Method to build up the nodes in the temporary Graph structure
     * which the algorithm is executed on.
     * 
     * @@param selectedObjects
     *            List of selected objects to be layed out.
     * @@param editPartToNodeDict
     *            Map of editparts from the GEF to the temporary Nodes used for
     *            layout.
     * @@return NodeList list of Nodes that is passed to the graph structure.
     */
    protected NodeList build_nodes(List selectedObjects, Map editPartToNodeDict, Subgraph root) {
        ListIterator li = selectedObjects.listIterator();

        NodeList nodes = new NodeList();

        while (li.hasNext()) {

            IGraphicalEditPart gep = (IGraphicalEditPart) li.next();
            if (gep instanceof ShapeEditPart) {

                ShapeEditPart shapeEP = (ShapeEditPart) gep;

                Point position = shapeEP.getLocation();

                // determine topleft most point, layout of items will be placed
                // starting at topleft point
                if (minX == -1) {
                    minX = position.x;
                    minY = position.y;
                } else {
                    minX = Math.min(minX, position.x);
                    minY = Math.min(minY, position.y);
                }
                

                ConstantSizeNode n = new ConstantSizeNode(shapeEP);
                n.setPadding(new Insets(getMapMode().DPtoLP(NODE_PADDING)));
                n.setMinIncomingPadding(getMapMode().DPtoLP(MIN_EDGE_END_POINTS_PADDING));
                n.setMinOutgoingPadding(getMapMode().DPtoLP(MIN_EDGE_END_POINTS_PADDING));
                Dimension size = shapeEP.getSize();

                setNodeMetrics(n, new Rectangle(position.x, position.y,
                    size.width, size.height));

                editPartToNodeDict.put(shapeEP, n);
                nodes.add(n);
                
                build_borderNodes(shapeEP, n, editPartToNodeDict);
                
            }
        }

        return nodes;
    }
    
    /**
	 * Since an editpart may contain border items that may need be laid out,
	 * this is the place where border nodes can be created and added to the map
	 * of editparts to nodes. If border items locations don't have much
	 * semantical meaning and their locations are valubale notationally it's
	 * best that border nodes are created here in this method. The
	 * infrastructure for creating commands to move border items around is all
	 * in place already. Creates border nodes for an editpart.
	 * 
	 * @@param parentEP
	 *            the editopart
	 * @@param parentNode
	 *            the node for the editpart
	 * @@param editPartToNodeDict
	 *            the map of editparts to nodes
	 * @@since 2.1
	 */
    protected void build_borderNodes(GraphicalEditPart parentEP, ConstantSizeNode parentNode, Map editPartToNodeDict) {
    	if (!supportsBorderNodes()) {
    		return;
    	}
    	boolean borderNodesAdded = false;
    	Rectangle parentRect = new Rectangle(parentNode.x, parentNode.y, parentNode.width, parentNode.height);
    	Rectangle extendedRect = parentRect.getCopy();
    	for (Iterator itr = parentEP.getChildren().iterator(); itr.hasNext();) {
    		EditPart ep = (EditPart) itr.next();
    		if (ep instanceof IBorderItemEditPart && canCreateBorderNode((IBorderItemEditPart)ep)) {
    			IBorderItemEditPart bep = (IBorderItemEditPart) ep; 
    			BorderNode bn = new BorderNode(bep, parentNode);
    			setNodeMetrics(bn, bep.getFigure().getBounds());
    			/*
    			 * Border item bounding rectangle = b
    			 * Border item parent rectangle = p
    			 * outsideRatio = ( 1.0 - Area(Intersection(b, p))) / Area(p)
    			 */
    			bn.setOutsideRatio(1f - ((float) bep.getFigure().getBounds().getCopy().intersect(parentEP.getFigure().getBounds()).getSize().getArea()) / bep.getFigure().getSize().getArea());
    			editPartToNodeDict.put(bep, bn);
    			borderNodesAdded = true;
    			extendedRect.union(new Rectangle(bn.x, bn.y, bn.width, bn.height));
    			bn.setMinIncomingPadding(getMapMode().DPtoLP(MIN_EDGE_END_POINTS_PADDING));
    			bn.setMinOutgoingPadding(getMapMode().DPtoLP(MIN_EDGE_END_POINTS_PADDING));
    		}
    	}
    	if (borderNodesAdded) {
    		parentNode.getPadding().add(new Insets(Math.max(extendedRect.width - parentRect.width, extendedRect.height - parentRect.height)));
    	}
    }
    
    /**
     * Returns <code>true</code> if a border node for the given border item editpart needs to be created.
     * By default we just need to know if the border item is movable (can change its x,y coordinate), which
     * means that a non resizable edit policy have to be installed on the editpart. 
     * 
     * @@param ep the border item editpart
     * @@return <code>true</code> if border node needs to be created for the editpart
     */
    protected boolean canCreateBorderNode(IBorderItemEditPart ep) {
    	return ep.getEditPolicy(EditPolicy.PRIMARY_DRAG_ROLE) instanceof NonResizableEditPolicy;
    }
    
    /**
     * Returns <code>true</code> if the layout provider supports creation of border nodes.
     * The default behavior for the layout provider is not to support arranging border items.
     * Clients must override if this support is needed.
     * 
     * @@return <code>true</code> if border items layout is supported by the layout provider
     */
    protected boolean supportsBorderNodes() {
    	return false;
    }

    /**
     * setNodeMetrics Sets the extend and position into the node object. Defined
     * as abstract to allow subclasses to implement to perform a transformation
     * on the values stored in the node. i.e. support for Left-Right layout as
     * opposed to Top-Down.
     * 
     * @@param n
     *            Node that will receive the metrics values to be set.
     * @@param r
     *            Rectangle that represents the location and extend of the Node.
     */
    final protected void setNodeMetrics(Node n, Rectangle r) {
        Rectangle rectGraph = translateToGraph(r);
        n.x = rectGraph.x;
        n.y = rectGraph.y;
        n.width = rectGraph.width;
        n.height = rectGraph.height;
    }

    /**
     * getNodeMetrics Retrieves the node extend and position from the node
     * object. Defined as abstract to allow subclasses to implement to perform a
     * transformation on the values stored in the node. i.e. support for
     * Left-Right layout as opposed to Top-Down.
     * 
     * @@param n
     *            Node that has the metrics values to be retrieved.
     * @@return Rectangle that represents the location and extend of the Node.
     */
     protected Rectangle getNodeMetrics(Node n) {
        Rectangle rect = new Rectangle(n.x, n.y, n.width, n.height);
        PrecisionRectangle preciseRect = new PrecisionRectangle(rect);
        return translateFromGraph(preciseRect);
    }

    /**
     * Retrieves the extent and position from the given logical rectangle in 
     * GEF graph coordinates. Defined as abstract to allow subclasses to implement 
     * to perform a transformation on the values stored in the node. i.e. support for 
     * Left-Right layout as opposed to Top-Down.
     * 
     * @@param rect
     *            <code>Rectangle</code> that has the values to be translated in 
     *            logical (relative) coordinates.
     *      
     * @@return <code>Rectangle</code> in graph coordinates.
     */
    abstract protected Rectangle translateToGraph(Rectangle r);

    /**
     * Retrieves the logical extent and position from the given rectangle.
     * Defined as abstract to allow subclasses to implement to perform a
     * transformation on the values stored in the node. i.e. support for
     * Left-Right layout as opposed to Top-Down.
     * 
     * @@param rect
     *            <code>Rectangle</code> that has the values to be translated in
     *            graph (pixel) coordinates.
     * @@return <code>Rectangle</code> in logical coordinates.
     */
    abstract protected Rectangle translateFromGraph(Rectangle rect);
    
    /**
     * build_edges Method to build up the edges in the temporary Graph structure
     * which the algorithm is executed on.
     * 
     * selectedObjects List of selected objects to be layed out.
     * 
     * @@param editPartToNodeDict
     *            Map of editparts from the GEF to the temporary Nodes used for
     *            layout.
     * @@return EdgeList list of Edges that is passed to the graph structure.
     */
    protected EdgeList build_edges(List selectedObjects, Map editPartToNodeDict) {

        EdgeList edges = new EdgeList();

        // Do "topdown" relationships first. Since they traditionally
        // go upward on a diagram, they are reversed when placed in the graph
        // for
        // layout. Also, layout traverses the arcs from each node in the order
        // of their insertion when finding a spanning tree for its constructed
        // hierarchy. Therefore, arcs added early are less likely to be
        // reversed.
        // In fact, since there are no cycles in these arcs, adding
        // them to the graph first should guarantee that they are never
        // reversed,
        // i.e., the inheritance hierarchy is preserved graphically.
        ArrayList objects = new ArrayList();
        objects.addAll(selectedObjects);
        ListIterator li = objects.listIterator();
        ArrayList notTopDownEdges = new ArrayList();
        boolean shouldHandleListItems = shouldHandleConnectableListItems();
        while (li.hasNext()) {
            EditPart gep = (EditPart) li.next();
            if (gep instanceof ConnectionEditPart) {
                ConnectionEditPart poly = (ConnectionEditPart) gep;

                if (layoutTopDown(poly)) {
                    EditPart from = poly.getSource();
                    EditPart to = poly.getTarget();
                    if (from instanceof IBorderItemEditPart && !editPartToNodeDict.containsKey(from))
                        from = from.getParent();
                    else if (shouldHandleListItems && from instanceof ListItemEditPart)
                        from = getFirstAnscestorinNodesMap(from, editPartToNodeDict);
                    if (to instanceof IBorderItemEditPart && !editPartToNodeDict.containsKey(to))
                        to = to.getParent();
                    else if (shouldHandleListItems && to instanceof ListItemEditPart)
                        to = getFirstAnscestorinNodesMap(to, editPartToNodeDict);
                    Node fromNode = (Node) editPartToNodeDict.get(from);
                    Node toNode = (Node) editPartToNodeDict.get(to);
                    
                    if (fromNode != null && toNode != null
                        && !checkSelfEdge(from, to, editPartToNodeDict)) {
                        addEdge(edges, poly, toNode, fromNode);
                    }
                }else{
                    notTopDownEdges.add(poly);
                }
            }
        }

        // third pass for all other connections
        li = notTopDownEdges.listIterator();
        while (li.hasNext()) {
            ConnectionEditPart poly = (ConnectionEditPart) li.next();
            EditPart from = poly.getSource();
            EditPart to = poly.getTarget();
            if (from instanceof IBorderItemEditPart && !editPartToNodeDict.containsKey(from))
                from = from.getParent();
            else if (shouldHandleListItems && from instanceof ListItemEditPart)
                from = getFirstAnscestorinNodesMap(from, editPartToNodeDict);
            if (to instanceof IBorderItemEditPart && !editPartToNodeDict.containsKey(to))
                to = to.getParent();
            else if (shouldHandleListItems && to instanceof ListItemEditPart)
                to = getFirstAnscestorinNodesMap(to, editPartToNodeDict);
            Node fromNode = (Node) editPartToNodeDict.get(from);
            Node toNode = (Node) editPartToNodeDict.get(to);
            
            if (fromNode != null && toNode != null
                && !checkSelfEdge(from, to, editPartToNodeDict)) {
                addEdge(edges, poly, fromNode, toNode);
            }
        }
        return edges;
    }
    
    private boolean checkSelfEdge(EditPart from, EditPart to, Map dictionary) {
   		Node graphSource = from instanceof IBorderItemEditPart ? (Node) dictionary.get(from.getParent()) : (Node) dictionary.get(from); 
   		Node graphTarget = to instanceof IBorderItemEditPart ? (Node) dictionary.get(to.getParent()) : (Node) dictionary.get(to);
    	return graphSource != null && graphTarget != null && graphSource.equals(graphTarget);
    }
    
    /**
     * @@param edges
     * @@param gep
     * @@param fromNode
     * @@param toNode
     */
    private void addEdge(EdgeList edges, ConnectionEditPart connectionEP,
            Node fromNode, Node toNode) {
    	ConstrainedEdge edge = new ConstrainedEdge(connectionEP, fromNode, toNode);
        initializeEdge(connectionEP, edge);
        
        edges.add(edge);
    }

    /**
     * initializeEdge Method used as a hook to initialize the Edge layout
     * object. LayoutProvider subclasses may wish to initialize the edge
     * different to customize the layout for their diagram domain.
     * 
     * @@param connectionEP
     *            EditPart used as a seed to initialize the edge properties
     * @@param edge
     *            Edge to initialize with default values for the layout
     */
    protected void initializeEdge(ConnectionEditPart connectionEP, Edge edge) {
        List affectingChildren = getAffectingChildren(connectionEP);
        
        // set the padding based on the extent of the children.
        edge.setPadding(Math.max(edge.getPadding(), calculateEdgePadding(connectionEP, affectingChildren)));
        edge.setDelta(Math.max(edge.getDelta(), affectingChildren.size() / 2));
        if (edge instanceof ConstrainedEdge && ((Connection)connectionEP.getFigure()).getConnectionRouter() instanceof OrthogonalRouter) {
        	((ConstrainedEdge)edge).setStyle(ConstrainedEdge.ORTHOGONAL_ROUTING_STYLE);
        }
    }
        
    /**
     * Calculates the edge padding needed to initialize edge with.  Uses the number of children as a factor in
     * determine the dynamic padding value.
     */
    private int calculateEdgePadding(ConnectionEditPart connectionEP, List affectingChildren) {
        ListIterator li = affectingChildren.listIterator();
        
        int padding = 0;
        
        // union the children widths 
        while (li.hasNext()) {
            GraphicalEditPart gep = (GraphicalEditPart)li.next();
            
            padding = Math.max(padding, Math.max(gep.getFigure().getBounds().width, gep.getFigure().getBounds().height));
        }
        
        Rectangle.SINGLETON.x = 0;
        Rectangle.SINGLETON.y = 0;
        Rectangle.SINGLETON.width = padding;
        Rectangle.SINGLETON.height = padding;
        return Math.min(Math.max(Math.round(translateToGraph(Rectangle.SINGLETON).width * 1.5f), getMapMode().DPtoLP(MIN_EDGE_PADDING)), getMapMode().DPtoLP(MAX_EDGE_PADDING));
    }
    
    /**
     * Retrieve the associated children from the given connection editpart that will affect
     * the layout.
     * 
     * @@param conn the <code>ConnectionEditPart</code> to retrieve the children from
     * @@return a <code>List</code> that contains <code>GraphicalEditPart</code> objects
     */
    private List getAffectingChildren(ConnectionEditPart conn) {
        List children = conn.getChildren();
        ListIterator lli = children.listIterator();
        List affectingChildrenList = new ArrayList();
        while (lli.hasNext()) {
            Object obj = lli.next();
            if (obj instanceof GraphicalEditPart) {
                GraphicalEditPart lep = (GraphicalEditPart)obj;
                Rectangle lepBox = lep.getFigure().getBounds().getCopy();
                
                if (!lep.getFigure().isVisible() || 
                    lepBox.width == 0 || lepBox.height == 0)
                    continue;
                
                affectingChildrenList.add(lep);
            }
        }
        return affectingChildrenList;
    }
    
    /**
     * getRelevantConnections Given the editpart to Nodes Map this will
     * calculate the connections in the diagram that are important to the
     * layout.
     * 
     * @@param editPartToNodeDict
     *            Hashtable of editparts from the GEF to the temporary Nodes
     *            used for layout.
     * @@return List of ConnectionEditPart that are to be part of the layout
     *         routine.
     */
    protected List getRelevantConnections(Hashtable editPartToNodeDict) {
        Enumeration enumeration = editPartToNodeDict.keys();
        ArrayList connectionsToMove = new ArrayList();
        while (enumeration.hasMoreElements()) {
            Object e = enumeration.nextElement();
            GraphicalEditPart shapeEP = (GraphicalEditPart) e;
            Set sourceConnections = new HashSet(shapeEP.getSourceConnections());
            if (shapeEP instanceof IBorderedShapeEditPart){
                List borderItems = getBorderItemEditParts(shapeEP, editPartToNodeDict);
                for (Iterator iter = borderItems.iterator(); iter.hasNext();) {
                    GraphicalEditPart element = (GraphicalEditPart) iter.next();
                    sourceConnections.addAll(element.getSourceConnections());
                }
            }
            
            for (Iterator iter = sourceConnections.iterator();
                    iter.hasNext();) {
                ConnectionEditPart connectionEP = (ConnectionEditPart) iter.next();
                EditPart target = connectionEP.getTarget();
                // check to see if the toView is in the shapesDict, if yes,
                // the associated connectionView should be included on graph
                if (target instanceof IBorderItemEditPart)
                    target = target.getParent();
                Object o = editPartToNodeDict.get(target);
                if (o != null) {
                    connectionsToMove.add(connectionEP);
                }
            }
            
            if (shouldHandleConnectableListItems()){
                handleConnectableListItems(shapeEP,editPartToNodeDict,connectionsToMove);
            }
        }

        return connectionsToMove;
    }
    
    private void handleConnectableListItems(GraphicalEditPart shapeEP, Map editPartToNodeDict, ArrayList connectionsToMove) {
        List children = shapeEP.getChildren();
        for (Iterator iter = children.iterator(); iter.hasNext();) {
            EditPart ep = (EditPart) iter.next();
            if (ep instanceof ListCompartmentEditPart){
                List listItems = ep.getChildren();
                for (Iterator iterator = listItems.iterator(); iterator
                    .hasNext();) {
                    GraphicalEditPart listItem = (GraphicalEditPart) iterator.next();
                    List connections =listItem.getSourceConnections();
                    for (Iterator connectionIterator = connections.iterator(); connectionIterator
                        .hasNext();) {
                        ConnectionEditPart connectionEP = (ConnectionEditPart) connectionIterator.next();
                        EditPart ancestor = getFirstAnscestorinNodesMap(connectionEP.getTarget(),editPartToNodeDict);
                        if (ancestor!=null)
                            connectionsToMove.add(connectionEP);
                    }
                }
            }
            
        }
        
    }

    private EditPart getFirstAnscestorinNodesMap(EditPart editPart,Map editPartToNodeDict) {
        EditPart ancestor =  editPart;
        while (ancestor!=null){
            if (editPartToNodeDict.get(ancestor)!=null)
                return ancestor;
            ancestor = ancestor.getParent();
        }
        return null;
    }

    /**
     * This method searches an edit part for a child that is a border item edit part
     * @@param parent part needed to search
     * @@param set to be modified of border item edit parts that are direct children of the parent
     */
    private List getBorderItemEditParts(EditPart parent, Hashtable editPartToNodeDict ) {
        Iterator iter = parent.getChildren().iterator();
        List list = new ArrayList();
        while(iter.hasNext()) {
            EditPart child = (EditPart)iter.next();
            if (!editPartToNodeDict.containsKey(child) && child instanceof IBorderItemEditPart) {
                list.add(child);
            }
        }
        return list;
    }

    /**
     * Method build_graph. This method will build the proxy graph that the
     * layout is based on.
     * 
     * @@param g
     *            DirectedGraph structure that will be populated with Nodes and
     *            Edges in this method.
     * @@param selectedObjects
     *            List of editparts that the Nodes and Edges will be calculated
     *            from.
     */
    protected void build_graph(DirectedGraph g, List selectedObjects) {
        Hashtable editPartToNodeDict = new Hashtable(500);
        this.minX = -1;
        this.minY = -1;
        NodeList nodes = build_nodes(selectedObjects, editPartToNodeDict,null);

        // append edges that should be added to the graph
        ArrayList objects = new ArrayList();
        objects.addAll(selectedObjects);
        objects.addAll(getRelevantConnections(editPartToNodeDict));
        EdgeList edges = build_edges(objects, editPartToNodeDict);
        g.nodes = nodes;
        g.edges = edges;
        postProcessGraph(g,editPartToNodeDict);
        //printGraph(g);
     }
    
    protected void postProcessGraph(DirectedGraph g, Hashtable editPartToNodeDict) {
        //default do nothing
    }

    /**
     * reverse Utility function to reverse the order of points in a list.
     * 
     * @@param c
     *            PointList that is passed to the routine.
     * @@param rc
     *            PointList that is reversed.
     */
    private void reverse(PointList c, PointList rc) {
        rc.removeAllPoints();

        for (int i = c.size() - 1; i >= 0; i--) {
            rc.addPoint(c.getPoint(i));
        }
    }

    /**
     * Computes the command that will route the given connection editpart with the given points.
     */
    protected Command routeThrough(Edge edge, ConnectionEditPart connectEP, Node source, Node target, PointList points, Point diff) {

        if (connectEP == null)
            return null;

        PointList routePoints = points;
        if (source.data == connectEP.getTarget()) {
            routePoints = new PointList(points.size());
            reverse(points, routePoints);
            Node tmpNode = source;
            source = target;
            target = tmpNode;
        }
        
        double totalEdgeDiffX = diff.preciseX() ;
        double totalEdgeDiffY = diff.preciseY() ;
        
        PrecisionPointList allPoints = new PrecisionPointList(routePoints.size());
        for (int i = 0; i < routePoints.size(); i++) {
            allPoints.addPrecisionPoint(routePoints.getPoint(i).preciseX() + totalEdgeDiffX, routePoints
                .getPoint(i).preciseY()
                + totalEdgeDiffY);
        }

        CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
        
        LineSeg anchorReferencePoints = addAnchorsCommands(cc, allPoints.getFirstPoint(), allPoints.getLastPoint(), source, target, connectEP, diff);
        		
        SetAllBendpointRequest request = new SetAllBendpointRequest(
                RequestConstants.REQ_SET_ALL_BENDPOINT, allPoints,
                anchorReferencePoints.getOrigin(), anchorReferencePoints.getTerminus());

        Command cmd = connectEP.getCommand(request);
        if (cmd != null)
            cc.add(cmd);
        
        // set the snapback position for all children owned by the connection
        List affectingChildren = getAffectingChildren(connectEP);
        Request snapBackRequest = new Request(RequestConstants.REQ_SNAP_BACK);
        ListIterator li = affectingChildren.listIterator();
        while (li.hasNext()) {
            EditPart ep = (EditPart)li.next();
            cmd = ep.getCommand(snapBackRequest);
            if (cmd != null)
                cc.add(cmd);
        }
        
        if (cc.isEmpty())
            return null;
        return cc;
    }
    
    /**
	 * Creates source and target anchor commands and appends them to the
	 * compound command passed in. Returns a line segment ends of which are the
	 * new source and target anchor reference points for further use in the
	 * command setting the bend points.
	 * 
	 * @@param cc
	 *            command to add anchors commands to
	 * @@param sourceAnchorLocation
	 *            the source anchor location coordinates
	 * @@param targetAnchorLocation
	 *            the target anchor location coordinates
	 * @@param source
	 *            source node
	 * @@param target
	 *            target node
	 * @@param cep
	 *            connection editpart
	 * @@param diffX
	 *            x axis offset
	 * @@param diffY
	 *            y axis offset
	 * @@return <code>LineSeg</code> origin is the new source anchor reference
	 *         point and origin is the new target anchor reference point
	 */
	protected LineSeg addAnchorsCommands(CompoundCommand cc,
			Point sourceAnchorLocation, Point targetAnchorLocation,
			Node source, Node target, ConnectionEditPart cep, Point diff) {
		Rectangle sourceExt = getNodeMetrics(source);
		Rectangle targetExt = getNodeMetrics(target);
		sourceExt.translate(diff);
		targetExt.translate(diff);
		
		/*
		 * If source or target anchor command won't be created or will be non-executable,
		 * source or target reference point is assumed to be the geometric centre of a shape.
		 */
		Point resultantSourceAnchorReference = sourceExt.getCenter();
		Point resultantTargetAnchorReference = targetExt.getCenter();

		PrecisionPoint sourceRatio = new PrecisionPoint((sourceAnchorLocation
				.preciseX() - sourceExt.preciseX())
				/ sourceExt.preciseWidth(),
				(sourceAnchorLocation.preciseY() - sourceExt.preciseY())
						/ sourceExt.preciseHeight());
		PrecisionPoint targetRatio = new PrecisionPoint((targetAnchorLocation
				.preciseX() - targetExt.preciseX())
				/ targetExt.preciseWidth(),
				(targetAnchorLocation.preciseY() - targetExt.preciseY())
						/ targetExt.preciseHeight());
		
		/*
		 * Need to fake reconnection of the ends of the connection. Currently
		 * existing figure coordinates (old coordinates) needs to be used for
		 * this, since the reconnection location is passed in absolute
		 * coordinates.
		 */
		if (cep.getSource().equals(source.data)) {
			ReconnectRequest reconnectRequest = new ReconnectRequest(
					org.eclipse.gef.RequestConstants.REQ_RECONNECT_SOURCE);
			reconnectRequest.setConnectionEditPart(cep);
			reconnectRequest.setTargetEditPart(cep.getSource());
			IFigure sourceFig = ((GraphicalEditPart)cep.getSource()).getFigure();
			Point sourceAnchorReference = new PrecisionPoint(
					sourceFig.getBounds().preciseX() + sourceRatio.preciseX()
							* sourceFig.getBounds().preciseWidth(), sourceFig
							.getBounds().preciseY()
							+ sourceRatio.preciseY()
							* sourceFig.getBounds().preciseHeight());
			sourceFig.translateToAbsolute(sourceAnchorReference);
			reconnectRequest.setLocation(sourceAnchorReference);
			Command sourceAnchorCommand = cep.getSource()
					.getCommand(reconnectRequest);
			if (sourceAnchorCommand != null && sourceAnchorCommand.canExecute()) {
				cc.add(sourceAnchorCommand);
				if (((Connection)cep.getFigure()).getSourceAnchor() instanceof BaseSlidableAnchor) {
					if (sourceAnchorCommand instanceof ICommandProxy) {
						updateNewSlidingAnchorReferenceRatio((ICommandProxy) sourceAnchorCommand, true, sourceRatio);
					}
					resultantSourceAnchorReference = new PrecisionPoint(sourceExt
							.preciseWidth()
							* sourceRatio.preciseX() + sourceExt.preciseX(), sourceExt
							.preciseHeight()
							* sourceRatio.preciseY() + sourceExt.preciseY());
				}
			}
		} else {
			resultantSourceAnchorReference = getNewAnchorReferencePoint(source, sourceExt, ((Connection)cep.getFigure()).getSourceAnchor().getReferencePoint());
		}

		if (cep.getTarget().equals(target.data)) {
			ReconnectRequest reconnectRequest = new ReconnectRequest(
					org.eclipse.gef.RequestConstants.REQ_RECONNECT_TARGET);
			reconnectRequest.setConnectionEditPart(cep);
			reconnectRequest.setTargetEditPart(cep.getTarget());
			IFigure targetFig = ((GraphicalEditPart) cep.getTarget()).getFigure();
			Point targetAnchorReference = new PrecisionPoint(
					targetFig.getBounds().preciseX() + targetRatio.preciseX()
							* targetFig.getBounds().preciseWidth(), targetFig
							.getBounds().preciseY()
							+ targetRatio.preciseY()
							* targetFig.getBounds().preciseHeight());
			targetFig.translateToAbsolute(targetAnchorReference);
			reconnectRequest.setLocation(targetAnchorReference);
			Command targetAnchorCommand = cep.getTarget()
					.getCommand(reconnectRequest);
			if (targetAnchorCommand != null && targetAnchorCommand.canExecute()) {
				cc.add(targetAnchorCommand);
				if (((Connection)cep.getFigure()).getTargetAnchor() instanceof BaseSlidableAnchor) {
					if (targetAnchorCommand instanceof ICommandProxy) {
						updateNewSlidingAnchorReferenceRatio((ICommandProxy) targetAnchorCommand, false, targetRatio);
					}
					resultantTargetAnchorReference = new PrecisionPoint(targetExt
							.preciseWidth()
							* targetRatio.preciseX() + targetExt.preciseX(), targetExt
							.preciseHeight()
							* targetRatio.preciseY() + targetExt.preciseY());
				}
			}
		} else {
			resultantTargetAnchorReference = getNewAnchorReferencePoint(target, targetExt, ((Connection)cep.getFigure()).getTargetAnchor().getReferencePoint());
		}
		return new LineSeg(resultantSourceAnchorReference,
				resultantTargetAnchorReference);
	}
	
	private void updateNewSlidingAnchorReferenceRatio(ICommandProxy setAnchorCommand, boolean source, PrecisionPoint ratio) {
		/*
		 * Find the SetConnectionAnchorsCommand
		 */
		SetConnectionAnchorsCommand cmd = findSetConnectionAnchorsCommand(setAnchorCommand.getICommand());
		if (cmd != null) {
			PrecisionPoint newRatio = null;
			if (source) {
				newRatio = cmd.getNewSourceTerminal() == null ? new PrecisionPoint(0.5, 0.5) : BaseSlidableAnchor.parseTerminalString(cmd.getNewSourceTerminal());
			} else {
				newRatio = cmd.getNewTargetTerminal() == null ? new PrecisionPoint(0.5, 0.5) : BaseSlidableAnchor.parseTerminalString(cmd.getNewTargetTerminal());
			}
			if (newRatio != null) {
				ratio.preciseX = newRatio.preciseX;
				ratio.preciseY = newRatio.preciseY;
				ratio.updateInts();
			}
		}
	}
	
	private SetConnectionAnchorsCommand findSetConnectionAnchorsCommand(ICommand cmd) {
		if (cmd instanceof SetConnectionAnchorsCommand) {
			return (SetConnectionAnchorsCommand) cmd;
		} else if (cmd instanceof CompositeCommand) {
			for (Iterator itr = ((CompositeCommand)cmd).listIterator(); itr.hasNext();) {
				ICommand childCmd = (ICommand) itr.next();
				SetConnectionAnchorsCommand setAnchorsCmd = findSetConnectionAnchorsCommand(childCmd);
				if (setAnchorsCmd != null) {
					return setAnchorsCmd;
				}
			}
		}
		return null;
	}
	
	private Point getNewAnchorReferencePoint(Node node, Rectangle nodeBoundsOnDiagram, Point oldAbsReference) {
		GraphicalEditPart gep = (GraphicalEditPart)node.data;
		PrecisionPoint parentLocation = new PrecisionPoint(gep.getFigure().getBounds().getLocation());
		gep.getFigure().translateToAbsolute(parentLocation);
		PrecisionDimension diff = new PrecisionDimension(oldAbsReference.preciseX() - parentLocation.preciseX(), oldAbsReference.preciseY() - parentLocation.preciseY());
		getMapMode().DPtoLP(diff);
		return nodeBoundsOnDiagram.getLocation().translate(diff);
	}

    /**
     * Method update_diagram. Once the layout has been calculated with the GEF
     * graph structure, the new layout values need to be propogated into the
     * diagram. This is accomplished by creating a compound command that
     * contains sub commands to change shapes positions and connection bendpoints
     * positions. The command is subsequently executed by the calling action and
     * then through the command infrastructure is undoable and redoable.
     * 
     * @@param diagramEP
     *            IGraphicalEditPart container that is target for the commands.
     * @@param g
     *            DirectedGraph structure that contains the results of the
     *            layout operation.
     * @@param isLayoutForSelected
     *            boolean indicating that the layout is to be performed on
     *            selected objects only. At this stage this is relevant only to
     *            calculate the offset in the diagram where the layout will
     *            occur.
     * @@return Command usually a command command that will set the locations of
     *         nodes and bendpoints for connections.
     */
    protected Command update_diagram(GraphicalEditPart diagramEP, DirectedGraph g,
            boolean isLayoutForSelected) {
        
        CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$

        Point diff = getLayoutPositionDelta(g, isLayoutForSelected);
        Command cmd = createNodeChangeBoundCommands(g, diff);
        if (cmd != null)
            cc.add(cmd);
        
        cmd = createEdgesChangeBoundsCommands(g, diff);
        if (cmd != null)
            cc.add(cmd);
        
        return cc;
    }
    
    /*
     * Find all of the arcs and set their intermediate points. This
     * loop does not set the icon positions yet, because that causes
     * recalculation of the arc connection points. The intermediate
     * points of both outgoing and incomping arcs must be set before
     * recalculating connection points.
     */ 
    protected Command createEdgesChangeBoundsCommands(DirectedGraph g, Point diff) {
        
        CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
        PointList points = new PrecisionPointList(10);
        
        ListIterator vi = g.edges.listIterator();
        while (vi.hasNext()) {
            Edge edge = (Edge) vi.next();
            
            if (edge.data == null || edge.getPoints()==null)
                continue;
            
            points.removeAllPoints();

            ConnectionEditPart cep = null;
            Node source = null, target = null;
            
            collectPoints(points, edge);
            cep = (ConnectionEditPart)edge.data;
            source = edge.source;
            target = edge.target;
            
            if (cep != null) {
                PointListUtilities.normalizeSegments(points, MapModeUtil.getMapMode(cep.getFigure()).DPtoLP(3));
                    
                // Reset the points list
                Command cmd = routeThrough(edge, cep, source, target, points, diff);
                if (cmd != null)
                    cc.add(cmd);
            }
        }
        
        if (cc.isEmpty())
            return null;
        return cc;
    }
        
    private void collectPoints(PointList points, Edge edge) {
        PointList pointList = edge.getPoints();
        for (int i = 0; i < pointList.size(); i++) {
        	Rectangle pt = translateFromGraph(new Rectangle(pointList.getPoint(i), new Dimension()));
        	points.addPoint(pt.getLocation());
        }
    }

    protected Command createNodeChangeBoundCommands(DirectedGraph g, Point diff) {
        ListIterator vi = g.nodes.listIterator();
        CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
        createSubCommands(diff, vi, cc);
        if (cc.isEmpty())
            return null;
        return cc;
    }

    protected void createSubCommands(Point diff, ListIterator vi, CompoundCommand cc) {
        // Now set the position of the icons. This causes the
        // arc connection points to be recalculated
        while (vi.hasNext()) {
            Node node = (Node) vi.next();
            if (node.data instanceof ShapeEditPart) {
                IGraphicalEditPart gep = (IGraphicalEditPart)node.data;
                
                ChangeBoundsRequest request = new ChangeBoundsRequest(
                    RequestConstants.REQ_MOVE);
                Rectangle nodeExt = getNodeMetrics(node);
                Point ptLocation = new PrecisionPoint(nodeExt.preciseX() + diff.preciseX(), nodeExt.preciseY()
                    + diff.preciseY());

                PrecisionPoint ptOldLocation = new PrecisionPoint(gep.getFigure().getBounds().getLocation());
                gep.getFigure().translateToAbsolute(ptOldLocation);
                
                gep.getFigure().translateToAbsolute(ptLocation);
                PrecisionPoint delta = new PrecisionPoint(ptLocation.preciseX()
                    - ptOldLocation.preciseX(), ptLocation.preciseY()
                    - ptOldLocation.preciseY());

                request.setEditParts(gep);
                request.setMoveDelta(delta);
                request.setLocation(ptLocation);
                
                Command cmd = gep.getCommand(request);
                if (cmd != null && cmd.canExecute()) {
                    cc.add(cmd);
                }
            }
        	if (node instanceof ConstantSizeNode) {
        		ConstantSizeNode cn = (ConstantSizeNode) node;
        		for (Iterator<BorderNode> itr = cn.borderNodes.iterator(); itr.hasNext();) {
        			createBorderItemChangeBoundsCommand(itr.next(), cn, cc);
        		}
        	}
        }
    }
    
    private void createBorderItemChangeBoundsCommand(BorderNode bn, ConstantSizeNode parentNode, CompoundCommand cc) {
        ChangeBoundsRequest request = new ChangeBoundsRequest(
                RequestConstants.REQ_MOVE);
        Rectangle parentRect = getNodeMetrics(parentNode);
        Rectangle borderItemRect = getNodeMetrics(bn);
        Dimension offset = borderItemRect.getLocation().getDifference(parentRect.getLocation());
        
        IFigure parentFigure = ((GraphicalEditPart)parentNode.data).getFigure();
        IFigure borderItemFigure = ((GraphicalEditPart)bn.data).getFigure();
        
        PrecisionPoint oldParentLocation = new PrecisionPoint(parentFigure.getBounds().getLocation());
        PrecisionPoint oldBorderItemLocation = new PrecisionPoint(borderItemFigure.getBounds().getLocation());        
        PrecisionPoint newBorderItemLocation = new PrecisionPoint(oldParentLocation.preciseX() + offset.preciseWidth(), oldParentLocation.preciseY() + offset.preciseHeight());
        parentFigure.translateToAbsolute(oldParentLocation);
        parentFigure.translateToAbsolute(newBorderItemLocation);
        borderItemFigure.translateToAbsolute(oldBorderItemLocation);
        
        PrecisionPoint delta = new PrecisionPoint(newBorderItemLocation.preciseX() - oldBorderItemLocation.preciseX(), newBorderItemLocation.preciseY() - oldBorderItemLocation.preciseY());
        GraphicalEditPart gep = (GraphicalEditPart) bn.data;
        request.setEditParts(gep);
        request.setMoveDelta(delta);
        request.setLocation(newBorderItemLocation);
        
        Command cmd = gep.getCommand(request);
        if (cmd != null && cmd.canExecute()) {
            cc.add(cmd);
        }
    }

    private Point getLayoutPositionDelta(DirectedGraph g, boolean isLayoutForSelected) {
        // If laying out selected objects, use diff variables to
        // position objects at topleft corner of enclosing rectangle.
        if (isLayoutForSelected) {
            ListIterator vi;
            vi = g.nodes.listIterator();
            Point ptLayoutMin = new Point(-1, -1);
            while (vi.hasNext()) {
                Node node = (Node) vi.next();
                // ignore ghost node
                if (node.data != null) {
                    Rectangle nodeExt = getNodeMetrics(node);
                    if (ptLayoutMin.x == -1) {
                        ptLayoutMin.x = nodeExt.x;
                        ptLayoutMin.y = nodeExt.y;
                    } else {
                        ptLayoutMin.x = Math.min(ptLayoutMin.x, nodeExt.x);
                        ptLayoutMin.y = Math.min(ptLayoutMin.y, nodeExt.y);
                    }
                }
            }
    
            return new Point(this.minX - ptLayoutMin.x, this.minY - ptLayoutMin.y);
        }
        
        return new Point(layoutDefaultMargin, layoutDefaultMargin);
    }
    
    /**
     * Creates the graph that will be used by the layouy provider
     * Clients can override this method create different kind of graphs
     * This method is called by {@@link DefaultProvider#layoutEditParts(GraphicalEditPart, IAdaptable) } 
     * and {@@link DefaultProvider#layoutEditParts(List, IAdaptable)}  
     * @@return the Graph that will be used by the layout algorithm
     */
    protected DirectedGraph createGraph(){
        return new DirectedGraph();
    }
    
    /**
     * Creates the graph layout algorithm that will be used to layout the diagram
     * This method is called by {@@link DefaultProvider#layoutEditParts(GraphicalEditPart, IAdaptable) } 
     * and {@@link DefaultProvider#layoutEditParts(List, IAdaptable)}  
     * @@return the graph layout 
     */
    protected DirectedGraphLayout createGraphLayout() {
        return new GMFDirectedGraphLayout();
    }
    
    /**
     * Indicates if the provider will consider the connections between ListItems 
     * while doing the arrange action
     * @@return true or false
     */
    protected boolean shouldHandleConnectableListItems() {
        return false;
    }
    
   /* private void printGraph(DirectedGraph g){
        int depth = 0;
        if (g instanceof CompoundDirectedGraph){
            NodeList subGraphs = ((CompoundDirectedGraph)g).nodes;
            for (Iterator iter = subGraphs.iterator(); iter.hasNext();) {
                Node node = (Node)iter.next();
                if (node.getParent()!=null)
                    continue;
                if (node instanceof Subgraph){
                    printSubGraph((Subgraph)node,depth);
                }else {
                    printNode(node,depth);
                }
            }
        }
    }

    private void printNode(Node node, int depth) {
        StringBuffer buffer = new StringBuffer();
        for (int i =0 ; i<depth ; i++)
            buffer.append("\t");
        buffer.append("Node");
        System.out.println(buffer);
    }

    private void printSubGraph(Subgraph subgraph, int depth) {
        StringBuffer buffer = new StringBuffer();
        for (int i =0 ; i<depth ; i++)
            buffer.append("\t");
        buffer.append("SubGraph");
        if (!subgraph.members.isEmpty()){
            buffer.append(" : ");
            System.out.println(buffer);
            NodeList nodes = subgraph.members;
            depth++;
            for (Iterator iter = nodes.iterator(); iter.hasNext();) {
                Node element = (Node) iter.next();
                if (element instanceof Subgraph){
                    printSubGraph((Subgraph)element,depth);
                }else {
                    printNode(element,depth);
                }
            }
        }else {
            System.out.println(buffer);
        }
            
    }*/
}
@


1.20
log
@[228500] gmf_head aboyko 080423 [Layout] Border item layout support api improvement on DefaultProvider
@
text
@d852 1
a852 1
			resultantSourceAnchorReference = getNewAnchorReferencePoint(source, ((Connection)cep.getFigure()).getSourceAnchor().getReferencePoint());
d885 1
a885 1
			resultantTargetAnchorReference = getNewAnchorReferencePoint(target, ((Connection)cep.getFigure()).getTargetAnchor().getReferencePoint());
d926 1
a926 1
	private Point getNewAnchorReferencePoint(Node node, Point oldAbsReference) {
d932 1
a932 1
		return new Point(node.x, node.y).translate(diff);
@


1.20.2.1
log
@[237329] gmf_R2_1_maintenance aboyko 080618 [Layout] BorderItems connection anchor points are incorrectly caliculated for CompositeLayoutProvider
@
text
@d852 1
a852 1
			resultantSourceAnchorReference = getNewAnchorReferencePoint(source, sourceExt, ((Connection)cep.getFigure()).getSourceAnchor().getReferencePoint());
d885 1
a885 1
			resultantTargetAnchorReference = getNewAnchorReferencePoint(target, targetExt, ((Connection)cep.getFigure()).getTargetAnchor().getReferencePoint());
d926 1
a926 1
	private Point getNewAnchorReferencePoint(Node node, Rectangle nodeBoundsOnDiagram, Point oldAbsReference) {
d932 1
a932 1
		return nodeBoundsOnDiagram.getLocation().translate(diff);
@


1.19
log
@[226138] gmf_head aboyko 080416 [Layout] Layout issues
@
text
@d46 1
d51 1
d272 51
a322 1
    	// Clients are responsible for creating border nodes
@


1.18
log
@[225437] gmf_head aboyko 080403 Layout improvements
@
text
@d33 1
d52 2
d56 2
d386 1
a386 1
                        && !fromNode.equals(toNode)) {
d413 1
a413 1
                && !fromNode.equals(toNode)) {
d420 6
d770 28
a797 23
		ReconnectRequest reconnectRequest = new ReconnectRequest(
				org.eclipse.gef.RequestConstants.REQ_RECONNECT_SOURCE);
		reconnectRequest.setConnectionEditPart(cep);
		reconnectRequest.setTargetEditPart(cep.getSource());
		IFigure sourceFig = ((GraphicalEditPart)cep.getSource()).getFigure();
		Point sourceAnchorReference = new PrecisionPoint(
				sourceFig.getBounds().preciseX() + sourceRatio.preciseX()
						* sourceFig.getBounds().preciseWidth(), sourceFig
						.getBounds().preciseY()
						+ sourceRatio.preciseY()
						* sourceFig.getBounds().preciseHeight());
		sourceFig.translateToAbsolute(sourceAnchorReference);
		reconnectRequest.setLocation(sourceAnchorReference);
		Command sourceAnchorCommand = cep.getSource()
				.getCommand(reconnectRequest);
		if (sourceAnchorCommand != null && sourceAnchorCommand.canExecute()) {
			cc.add(sourceAnchorCommand);
			if (((Connection)cep.getFigure()).getSourceAnchor() instanceof BaseSlidableAnchor) {
				resultantSourceAnchorReference = new PrecisionPoint(sourceExt
						.preciseWidth()
						* sourceRatio.preciseX() + sourceExt.preciseX(), sourceExt
						.preciseHeight()
						* sourceRatio.preciseY() + sourceExt.preciseY());
d799 2
d803 28
a830 22
		reconnectRequest
				.setType(org.eclipse.gef.RequestConstants.REQ_RECONNECT_TARGET);
		reconnectRequest.setTargetEditPart(cep.getTarget());
		IFigure targetFig = ((GraphicalEditPart) cep.getTarget()).getFigure();
		Point targetAnchorReference = new PrecisionPoint(
				targetFig.getBounds().preciseX() + targetRatio.preciseX()
						* targetFig.getBounds().preciseWidth(), targetFig
						.getBounds().preciseY()
						+ targetRatio.preciseY()
						* targetFig.getBounds().preciseHeight());
		targetFig.translateToAbsolute(targetAnchorReference);
		reconnectRequest.setLocation(targetAnchorReference);
		Command targetAnchorCommand = cep.getTarget()
				.getCommand(reconnectRequest);
		if (targetAnchorCommand != null && targetAnchorCommand.canExecute()) {
			cc.add(targetAnchorCommand);
			if (((Connection)cep.getFigure()).getTargetAnchor() instanceof BaseSlidableAnchor) {
				resultantTargetAnchorReference = new PrecisionPoint(targetExt
						.preciseWidth()
						* targetRatio.preciseX() + targetExt.preciseX(), targetExt
						.preciseHeight()
						* targetRatio.preciseY() + targetExt.preciseY());
d832 2
d838 44
@


1.17
log
@[217749] gmf_head aboyko 080204 [Layout] Layout providers using Draw2D graph layout don't deliver the exact results to the diagram
@
text
@d27 1
d64 1
d68 5
d94 1
a94 1
    protected static final int MIN_EDGE_PADDING = 5;
d96 1
d225 1
d227 4
a230 2
                Node n = new Node(shapeEP);
                n.setPadding(new Insets(NODE_PADDING));
d238 3
d246 21
d369 1
a369 1
                    if (from instanceof IBorderItemEditPart)
d373 1
a373 1
                    if (to instanceof IBorderItemEditPart)
d379 1
a379 1

d396 1
a396 1
            if (from instanceof IBorderItemEditPart)
d400 1
a400 1
            if (to instanceof IBorderItemEditPart)
d414 1
a414 1

d423 1
a423 1
        Edge edge = new Edge(connectionEP, fromNode, toNode);
d445 3
d470 1
a470 1
        return Math.min(Math.max(Math.round(translateToGraph(Rectangle.SINGLETON).width * 1.5f), MIN_EDGE_PADDING), MAX_EDGE_PADDING);
d519 1
a519 1
                List borderItems = getBorderItemEditParts(shapeEP);
d587 1
a587 1
    private List getBorderItemEditParts(EditPart parent) {
d592 1
a592 1
            if( child instanceof IBorderItemEditPart ) {
d650 1
a650 1
    protected Command routeThrough(Edge edge, ConnectionEditPart connectEP, Node source, Node target, PointList points, int diffX, int diffY) {
d664 2
a665 2
        double totalEdgeDiffX = diffX ;
        double totalEdgeDiffY = diffY ;
d676 1
a676 1
        LineSeg anchorReferencePoints = addAnchorsCommands(cc, allPoints.getFirstPoint(), allPoints.getLastPoint(), source, target, connectEP, diffX, diffY);
d729 1
a729 2
			Node source, Node target, ConnectionEditPart cep, int diffX,
			int diffY) {
d732 2
a733 2
		sourceExt.performTranslate(diffX, diffY);
		targetExt.performTranslate(diffX, diffY);
d762 2
a763 2
		reconnectRequest.setTargetEditPart((EditPart) source.data);
		IFigure sourceFig = ((GraphicalEditPart) source.data).getFigure();
d772 1
a772 1
		Command sourceAnchorCommand = ((EditPart) source.data)
d776 7
a782 5
			resultantSourceAnchorReference = new PrecisionPoint(sourceExt
					.preciseWidth()
					* sourceRatio.preciseX() + sourceExt.preciseX(), sourceExt
					.preciseHeight()
					* sourceRatio.preciseY() + sourceExt.preciseY());
d787 2
a788 2
		reconnectRequest.setTargetEditPart((EditPart) target.data);
		IFigure targetFig = ((GraphicalEditPart) target.data).getFigure();
d797 1
a797 1
		Command targetAnchorCommand = ((EditPart) target.data)
d801 7
a807 5
			resultantTargetAnchorReference = new PrecisionPoint(targetExt
					.preciseWidth()
					* targetRatio.preciseX + targetExt.preciseX(), targetExt
					.preciseHeight()
					* targetRatio.preciseY() + targetExt.preciseY());
d884 1
a884 1
                Command cmd = routeThrough(edge, cep, source, target, points, diff.x, diff.y);
d894 1
a894 1

d939 1
a939 1
                if (cmd != null && cmd.canExecute())
d943 35
d979 1
d1027 1
a1027 1
        return new DirectedGraphLayout();
@


1.16
log
@[216010] gmf_head aboyko 080122 Arrange doesn't align connections correctly
@
text
@d263 1
a263 9
        Rectangle rect = null;
        Node parent = n.getParent();
        while (parent!=null &&!(parent.data instanceof IGraphicalEditPart))
            parent = parent.getParent();
        if (parent!=null){
            rect = new Rectangle(n.x - parent.x, n.y - parent.y, n.width, n.height);
        }
        else
            rect = new Rectangle(n.x, n.y, n.width, n.height);
d612 1
a612 1
    Command routeThrough(Edge edge, ConnectionEditPart connectEP, Node source, Node target, PointList points, int diffX, int diffY) {
a627 9
        Node parent=  null;
        parent = source.getParent();
        if (parent==null)
            parent = target.getParent();
        if (parent!=null){
            Rectangle targetExt = getNodeMetrics(parent);
            totalEdgeDiffX += targetExt.preciseX();
            totalEdgeDiffY += targetExt.preciseY();
        }
d697 1
a697 1

d715 1
a715 1

d741 1
a741 1
					* sourceRatio.preciseX() + sourceExt.preciseX(), targetExt
d856 3
a858 11
        Rectangle start = translateFromGraph(
            new Rectangle(pointList.getFirstPoint().x,
                          pointList.getFirstPoint().y, 0, 0));
        points.addPoint(start.getLocation());
        NodeList vnodes = edge.vNodes;
        if (vnodes != null) {
            for (int i = 0; i < vnodes.size(); i++) {
                Node vn = vnodes.getNode(i);
                Rectangle nodeExt = getNodeMetrics(vn);
                points.addPoint(nodeExt.getCenter());
            }
a859 3
        Rectangle end = translateFromGraph(new Rectangle(pointList.getLastPoint().x,
            pointList.getLastPoint().y, 0, 0));
        points.addPoint(end.getLocation());
d896 1
a896 1

d900 1
a902 1
    }
@


1.15
log
@[151214] gmf_head crevells 080114 [Layout] Arrange All should be a projection (P*P = P)
@
text
@d25 1
d27 1
a31 1
import org.eclipse.draw2d.geometry.PrecisionDimension;
d33 1
d49 1
d63 1
d65 1
a68 1
import org.eclipse.jface.util.Assert;
d272 2
a273 1
        return translateFromGraph(rect);
d634 2
a635 2
        int totalEdgeDiffX = diffX ;
        int totalEdgeDiffY = diffY ;
d642 2
a643 2
            totalEdgeDiffX += targetExt.x;
            totalEdgeDiffY += targetExt.y;
d646 1
a646 2
        
        PointList allPoints = new PointList(routePoints.size());
d648 2
a649 2
            allPoints.addPoint(routePoints.getPoint(i).x + totalEdgeDiffX, routePoints
                .getPoint(i).y
d653 1
a653 6
        Rectangle sourceExt = getNodeMetrics(source);
        Point ptSourceReference = sourceExt.getCenter().getTranslated(diffX,
            diffY);
        Rectangle targetExt = getNodeMetrics(target);
        Point ptTargetReference = targetExt.getCenter().getTranslated(diffX,
            diffY);
d655 2
d658 2
a659 2
            RequestConstants.REQ_SET_ALL_BENDPOINT, allPoints,
            ptSourceReference, ptTargetReference);
a660 1
        CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
d682 108
d837 1
a837 1
        PointList points = new PointList(10);
d876 1
a876 1
        points.addPoint(start.getTopLeft());
d882 1
a882 4
                int x = nodeExt.x;
                int y = nodeExt.y;

                points.addPoint(x + nodeExt.width / 2, y + nodeExt.height / 2);
d887 1
a887 1
        points.addPoint(end.getTopLeft());
d910 2
a911 2
                Point ptLocation = new Point(nodeExt.x + diff.x, nodeExt.y
                    + diff.y);
d917 3
a919 3
                PrecisionPoint delta = new PrecisionPoint(ptLocation.x
                    - ptOldLocation.preciseX, ptLocation.y
                    - ptOldLocation.preciseY);
@


1.14
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d30 2
a707 1
        layoutDefaultMargin = MapModeUtil.getMapMode(diagramEP.getFigure()).DPtoLP(25);
d808 1
a808 1
                Point ptOldLocation = gep.getFigure().getBounds().getLocation();
d812 3
a814 1
                Dimension delta = ptLocation.getDifference(ptOldLocation);
d817 1
a817 1
                request.setMoveDelta(new Point(delta.width, delta.height));
@


1.14.2.1
log
@[111892] gmf_head crevells 070518 First milestone of group/ungroup support (painting issues when grouping shapes with border items)
@
text
@a24 1
import org.eclipse.core.runtime.Assert;
a30 1
import org.eclipse.draw2d.graph.CompoundDirectedGraph;
a46 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.GroupEditPart;
d62 1
d202 9
a210 9
        // determine topleft most point, layout of items will be placed
        // starting at topleft point
        if (minX == -1) {
            minX = position.x;
            minY = position.y;
        } else {
            minX = Math.min(minX, position.x);
            minY = Math.min(minY, position.y);
        }
d213 1
a213 1
        n.setPadding(new Insets(NODE_PADDING));
d216 2
a217 2
        setNodeMetrics(n, new Rectangle(position.x, position.y,
            size.width, size.height));
d221 1
a221 1
    }
d343 2
d346 4
a349 1
                        addEdge(edges, poly, to, from, editPartToNodeDict);
d370 7
a376 1
            addEdge(edges, poly, from, to, editPartToNodeDict);
d388 5
a392 33
            EditPart fromEP, EditPart toEP, Map editPartToNodeDict) {

        Node fromNode = (Node) editPartToNodeDict.get(fromEP);
        Node toNode = (Node) editPartToNodeDict.get(toEP);

        if (fromNode != null && toNode != null && !fromNode.equals(toNode)) {

            Edge edge = new Edge(connectionEP, fromNode, toNode);
            initializeEdge(connectionEP, edge);
            edges.add(edge);

            // create edges to/from groups
            boolean foundGroup = false;
            if (fromEP.getParent() instanceof GroupEditPart) {
                fromEP = fromEP.getParent();
                foundGroup = true;
            }
            if (toEP.getParent() instanceof GroupEditPart) {
                toEP = toEP.getParent();
                foundGroup = true;
            }
            if (foundGroup) {
                fromNode = (Node) editPartToNodeDict.get(fromEP);
                toNode = (Node) editPartToNodeDict.get(toEP);

                if (fromNode != null && toNode != null
                    && !fromNode.equals(toNode)) {

                    edges.add(new Edge("ImpliedGroupConnection", fromNode, //$NON-NLS-1$
                        toNode));
                }
            }
        }
d743 3
d747 1
a747 5
            if (edge.data instanceof ConnectionEditPart) {
                cep = (ConnectionEditPart) edge.data;
                source = edge.source;
                target = edge.target;

d855 2
a856 2
     * This method is called by {@@link CopyOfDefaultProvider#layoutEditParts(GraphicalEditPart, IAdaptable) } 
     * and {@@link CopyOfDefaultProvider#layoutEditParts(List, IAdaptable)}  
d865 2
a866 2
     * This method is called by {@@link CopyOfDefaultProvider#layoutEditParts(GraphicalEditPart, IAdaptable) } 
     * and {@@link CopyOfDefaultProvider#layoutEditParts(List, IAdaptable)}  
@


1.13
log
@bugzilla 145363 gmf-head sshaw 060605 Layout not invoked during drag and drop operation
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2004 IBM Corporation and others.
d619 1
a619 1
        if (source.data != connectEP.getSource()) {
d627 13
d642 1
a642 1
            allPoints.addPoint(routePoints.getPoint(i).x + diffX, routePoints
d644 1
a644 1
                + diffY);
@


1.13.2.1
log
@ [147090] gmf_R1_0_maintenance mmostafa  060707 Problems in CompositeLeftRightProvider: unconnected nodes affect line routing of nodes in string
@
text
@d619 1
a619 1
        if (source.data == connectEP.getTarget()) {
a626 13
        int totalEdgeDiffX = diffX ;
        int totalEdgeDiffY = diffY ;
        Node parent=  null;
        parent = source.getParent();
        if (parent==null)
            parent = target.getParent();
        if (parent!=null){
            Rectangle targetExt = getNodeMetrics(parent);
            totalEdgeDiffX += targetExt.x;
            totalEdgeDiffY += targetExt.y;
        }
        
        
d629 1
a629 1
            allPoints.addPoint(routePoints.getPoint(i).x + totalEdgeDiffX, routePoints
d631 1
a631 1
                + totalEdgeDiffY);
@


1.13.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.12
log
@[135386] gmf_head ldamus 060406 Runtime plugin dependencies must specify required plugin versions
@
text
@d661 2
@


1.11
log
@gmf-head mmostafa 060403 adding support for the connected list items to the default layout provider
@
text
@a46 1
import org.eclipse.gmf.runtime.diagram.ui.actions.internal.DiagramActionsDebugOptions;
d118 1
a118 1
                DiagramActionsDebugOptions.EXCEPTIONS_THROWING, getClass(),
@


1.10
log
@bugzilla 110698 gmf-head mmostafa 060224 Auto-layout doesn't layout out connections between nested nodes and top level nodes
@
text
@d51 2
d73 1
a73 1
	extends AbstractLayoutEditPartProvider {
d75 3
a77 3
	// Minimum sep between icon and bottommost horizontal arc
	protected int minX = -1;
	protected int minY = -1;
d80 2
a81 2
	
	protected static final int NODE_PADDING = 30;
d86 30
a115 30
	
	/**
	 * @@return the <code>IMapMode</code> that maps coordinates from
	 * device to logical and vice-versa.
	 */
	protected IMapMode getMapMode() {
		return mm;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.service.IProvider#provides(org.eclipse.gmf.runtime.common.core.service.IOperation)
	 */
	public boolean provides(IOperation operation) {
		Assert.isNotNull(operation);

		View cview = getContainer(operation);
		if (cview == null)
			return false;

		IAdaptable layoutHint = ((LayoutNodesOperation) operation)
			.getLayoutHint();
		String layoutType = (String) layoutHint.getAdapter(String.class);
		return LayoutType.DEFAULT.equals(layoutType);
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutEditPartProvider#layoutEditParts(org.eclipse.gef.GraphicalEditPart, org.eclipse.core.runtime.IAdaptable)
	 */
	public Command layoutEditParts(GraphicalEditPart containerEditPart,
			IAdaptable layoutHint) {
d124 4
a127 31
		mm = MapModeUtil.getMapMode(containerEditPart.getFigure());
		// setup graph
		DirectedGraph g = createGraph();
		build_graph(g, containerEditPart.getChildren());
		createGraphLayout().visit(g);
		// update the diagram based on the graph
		Command cmd = update_diagram(containerEditPart, g, false);
		
		// reset mm mapmode to avoid memory leak
		mm = null;
		return cmd;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutEditPartProvider#layoutEditParts(java.util.List, org.eclipse.core.runtime.IAdaptable)
	 */
	public Command layoutEditParts(List selectedObjects, IAdaptable layoutHint) {

		if (selectedObjects.size() == 0) {
			return null;
		}

		// get the container edit part for the children
		GraphicalEditPart editPart = (GraphicalEditPart) selectedObjects.get(0);
		GraphicalEditPart containerEditPart = (GraphicalEditPart) editPart
			.getParent();

		mm = MapModeUtil.getMapMode(containerEditPart.getFigure());
		
		DirectedGraph g = createGraph();
		build_graph(g, selectedObjects);
d129 129
a257 102
		// update the diagram based on the graph
		Command cmd = update_diagram(containerEditPart, g, true);
		
		// reset mm mapmode to avoid memory leak
		mm = null;
		return cmd;
	}

	/**
	 * layoutTopDown Utility function that is commonly subclasses by domain
	 * specific layouts to determine whether a specific connection type is layed
	 * out in a top down manner.
	 * 
	 * @@param poly
	 *            <code>ConnectionEditPart</code> to determine whether it is to be layed
	 *            out in a top-down fashion.
	 * @@return true if connection is to be layed out top-down, false otherwise.
	 */
	protected boolean layoutTopDown(ConnectionEditPart poly) {
		return false;
	}

	/**
	 * build_nodes Method to build up the nodes in the temporary Graph structure
	 * which the algorithm is executed on.
	 * 
	 * @@param selectedObjects
	 *            List of selected objects to be layed out.
	 * @@param editPartToNodeDict
	 *            Map of editparts from the GEF to the temporary Nodes used for
	 *            layout.
	 * @@return NodeList list of Nodes that is passed to the graph structure.
	 */
	protected NodeList build_nodes(List selectedObjects, Map editPartToNodeDict, Subgraph root) {
		ListIterator li = selectedObjects.listIterator();

		NodeList nodes = new NodeList();

		while (li.hasNext()) {

			IGraphicalEditPart gep = (IGraphicalEditPart) li.next();
			if (gep instanceof ShapeEditPart) {

				ShapeEditPart shapeEP = (ShapeEditPart) gep;

				Point position = shapeEP.getLocation();

				// determine topleft most point, layout of items will be placed
				// starting at topleft point
				if (minX == -1) {
					minX = position.x;
					minY = position.y;
				} else {
					minX = Math.min(minX, position.x);
					minY = Math.min(minY, position.y);
				}

				Node n = new Node(shapeEP);
				n.setPadding(new Insets(NODE_PADDING));
				Dimension size = shapeEP.getSize();

				setNodeMetrics(n, new Rectangle(position.x, position.y,
					size.width, size.height));

				editPartToNodeDict.put(shapeEP, n);
				nodes.add(n);
			}
		}

		return nodes;
	}

	/**
	 * setNodeMetrics Sets the extend and position into the node object. Defined
	 * as abstract to allow subclasses to implement to perform a transformation
	 * on the values stored in the node. i.e. support for Left-Right layout as
	 * opposed to Top-Down.
	 * 
	 * @@param n
	 *            Node that will receive the metrics values to be set.
	 * @@param r
	 *            Rectangle that represents the location and extend of the Node.
	 */
	final protected void setNodeMetrics(Node n, Rectangle r) {
		Rectangle rectGraph = translateToGraph(r);
		n.x = rectGraph.x;
		n.y = rectGraph.y;
		n.width = rectGraph.width;
		n.height = rectGraph.height;
	}

	/**
	 * getNodeMetrics Retrieves the node extend and position from the node
	 * object. Defined as abstract to allow subclasses to implement to perform a
	 * transformation on the values stored in the node. i.e. support for
	 * Left-Right layout as opposed to Top-Down.
	 * 
	 * @@param n
	 *            Node that has the metrics values to be retrieved.
	 * @@return Rectangle that represents the location and extend of the Node.
	 */
	 protected Rectangle getNodeMetrics(Node n) {
d268 15
a282 1
	}
d284 42
a325 56
	/**
	 * Retrieves the extent and position from the given logical rectangle in 
	 * GEF graph coordinates. Defined as abstract to allow subclasses to implement 
	 * to perform a transformation on the values stored in the node. i.e. support for 
	 * Left-Right layout as opposed to Top-Down.
	 * 
	 * @@param rect
	 *            <code>Rectangle</code> that has the values to be translated in 
	 *            logical (relative) coordinates.
	 *      
	 * @@return <code>Rectangle</code> in graph coordinates.
	 */
	abstract protected Rectangle translateToGraph(Rectangle r);

	/**
	 * Retrieves the logical extent and position from the given rectangle.
	 * Defined as abstract to allow subclasses to implement to perform a
	 * transformation on the values stored in the node. i.e. support for
	 * Left-Right layout as opposed to Top-Down.
	 * 
	 * @@param rect
	 *            <code>Rectangle</code> that has the values to be translated in
	 *            graph (pixel) coordinates.
	 * @@return <code>Rectangle</code> in logical coordinates.
	 */
	abstract protected Rectangle translateFromGraph(Rectangle rect);
	
	/**
	 * build_edges Method to build up the edges in the temporary Graph structure
	 * which the algorithm is executed on.
	 * 
	 * selectedObjects List of selected objects to be layed out.
	 * 
	 * @@param editPartToNodeDict
	 *            Map of editparts from the GEF to the temporary Nodes used for
	 *            layout.
	 * @@return EdgeList list of Edges that is passed to the graph structure.
	 */
	protected EdgeList build_edges(List selectedObjects, Map editPartToNodeDict) {

		EdgeList edges = new EdgeList();

		// Do "topdown" relationships first. Since they traditionally
		// go upward on a diagram, they are reversed when placed in the graph
		// for
		// layout. Also, layout traverses the arcs from each node in the order
		// of their insertion when finding a spanning tree for its constructed
		// hierarchy. Therefore, arcs added early are less likely to be
		// reversed.
		// In fact, since there are no cycles in these arcs, adding
		// them to the graph first should guarantee that they are never
		// reversed,
		// i.e., the inheritance hierarchy is preserved graphically.
		ArrayList objects = new ArrayList();
		objects.addAll(selectedObjects);
		ListIterator li = objects.listIterator();
d327 10
a336 9
		while (li.hasNext()) {
			EditPart gep = (EditPart) li.next();
			if (gep instanceof ConnectionEditPart) {
				ConnectionEditPart poly = (ConnectionEditPart) gep;

				if (layoutTopDown(poly)) {
					EditPart from = poly.getSource();
					EditPart to = poly.getTarget();
					if (from instanceof IBorderItemEditPart)
d338 2
d342 14
a355 2
					Node fromNode = (Node) editPartToNodeDict.get(from);
					Node toNode = (Node) editPartToNodeDict.get(to);
d357 6
a362 16
					if (fromNode != null && toNode != null
						&& !fromNode.equals(toNode)) {
						addEdge(edges, poly, toNode, fromNode);
					}
				}else{
                    notTopDownEdges.add(poly);
				}
			}
		}

		// third pass for all other connections
		li = notTopDownEdges.listIterator();
		while (li.hasNext()) {
			ConnectionEditPart poly = (ConnectionEditPart) li.next();
			EditPart from = poly.getSource();
			EditPart to = poly.getTarget();
d365 2
d369 4
a372 2
			Node fromNode = (Node) editPartToNodeDict.get(from);
			Node toNode = (Node) editPartToNodeDict.get(to);
d374 107
a480 107
			if (fromNode != null && toNode != null
				&& !fromNode.equals(toNode)) {
				addEdge(edges, poly, fromNode, toNode);
			}
		}
		return edges;
	}

	/**
	 * @@param edges
	 * @@param gep
	 * @@param fromNode
	 * @@param toNode
	 */
	private void addEdge(EdgeList edges, ConnectionEditPart connectionEP,
			Node fromNode, Node toNode) {
		Edge edge = new Edge(connectionEP, fromNode, toNode);
		initializeEdge(connectionEP, edge);
		
		edges.add(edge);
	}

	/**
	 * initializeEdge Method used as a hook to initialize the Edge layout
	 * object. LayoutProvider subclasses may wish to initialize the edge
	 * different to customize the layout for their diagram domain.
	 * 
	 * @@param connectionEP
	 *            EditPart used as a seed to initialize the edge properties
	 * @@param edge
	 *            Edge to initialize with default values for the layout
	 */
	protected void initializeEdge(ConnectionEditPart connectionEP, Edge edge) {
		List affectingChildren = getAffectingChildren(connectionEP);
		
		// set the padding based on the extent of the children.
		edge.setPadding(Math.max(edge.getPadding(), calculateEdgePadding(connectionEP, affectingChildren)));
		edge.setDelta(Math.max(edge.getDelta(), affectingChildren.size() / 2));
	}
		
	/**
	 * Calculates the edge padding needed to initialize edge with.  Uses the number of children as a factor in
	 * determine the dynamic padding value.
	 */
	private int calculateEdgePadding(ConnectionEditPart connectionEP, List affectingChildren) {
		ListIterator li = affectingChildren.listIterator();
		
		int padding = 0;
		
		// union the children widths 
		while (li.hasNext()) {
			GraphicalEditPart gep = (GraphicalEditPart)li.next();
			
			padding = Math.max(padding, Math.max(gep.getFigure().getBounds().width, gep.getFigure().getBounds().height));
        }
        
		Rectangle.SINGLETON.x = 0;
		Rectangle.SINGLETON.y = 0;
		Rectangle.SINGLETON.width = padding;
		Rectangle.SINGLETON.height = padding;
		return Math.min(Math.max(Math.round(translateToGraph(Rectangle.SINGLETON).width * 1.5f), MIN_EDGE_PADDING), MAX_EDGE_PADDING);
	}
    
	/**
	 * Retrieve the associated children from the given connection editpart that will affect
	 * the layout.
	 * 
	 * @@param conn the <code>ConnectionEditPart</code> to retrieve the children from
	 * @@return a <code>List</code> that contains <code>GraphicalEditPart</code> objects
	 */
	private List getAffectingChildren(ConnectionEditPart conn) {
		List children = conn.getChildren();
		ListIterator lli = children.listIterator();
		List affectingChildrenList = new ArrayList();
		while (lli.hasNext()) {
			Object obj = lli.next();
			if (obj instanceof GraphicalEditPart) {
				GraphicalEditPart lep = (GraphicalEditPart)obj;
				Rectangle lepBox = lep.getFigure().getBounds().getCopy();
				
				if (!lep.getFigure().isVisible() || 
					lepBox.width == 0 || lepBox.height == 0)
					continue;
				
				affectingChildrenList.add(lep);
			}
		}
		return affectingChildrenList;
	}
	
	/**
	 * getRelevantConnections Given the editpart to Nodes Map this will
	 * calculate the connections in the diagram that are important to the
	 * layout.
	 * 
	 * @@param editPartToNodeDict
	 *            Hashtable of editparts from the GEF to the temporary Nodes
	 *            used for layout.
	 * @@return List of ConnectionEditPart that are to be part of the layout
	 *         routine.
	 */
	private List getRelevantConnections(Hashtable editPartToNodeDict) {
		Enumeration enumeration = editPartToNodeDict.keys();
		ArrayList connectionsToMove = new ArrayList();
		while (enumeration.hasMoreElements()) {
			Object e = enumeration.nextElement();
			GraphicalEditPart shapeEP = (GraphicalEditPart) e;
d490 1
a490 1
			for (Iterator iter = sourceConnections.iterator();
d492 5
a496 5
				ConnectionEditPart connectionEP = (ConnectionEditPart) iter.next();
				EditPart target = connectionEP.getTarget();
				// check to see if the toView is in the shapesDict, if yes,
				// the associated connectionView should be included on graph
				if (target instanceof IBorderItemEditPart)
d499 9
a507 5
				if (o != null) {
					connectionsToMove.add(connectionEP);
				}
			}
		}
d509 2
a510 2
		return connectionsToMove;
	}
d512 34
d563 15
a577 15
	/**
	 * Method build_graph. This method will build the proxy graph that the
	 * layout is based on.
	 * 
	 * @@param g
	 *            DirectedGraph structure that will be populated with Nodes and
	 *            Edges in this method.
	 * @@param selectedObjects
	 *            List of editparts that the Nodes and Edges will be calculated
	 *            from.
	 */
	protected void build_graph(DirectedGraph g, List selectedObjects) {
		Hashtable editPartToNodeDict = new Hashtable(500);
		this.minX = -1;
		this.minY = -1;
d580 5
a584 5
		// append edges that should be added to the graph
		ArrayList objects = new ArrayList();
		objects.addAll(selectedObjects);
		objects.addAll(getRelevantConnections(editPartToNodeDict));
		EdgeList edges = build_edges(objects, editPartToNodeDict);
d586 1
a586 1
		g.edges = edges;
d596 49
a644 151
	 * reverse Utility function to reverse the order of points in a list.
	 * 
	 * @@param c
	 *            PointList that is passed to the routine.
	 * @@param rc
	 *            PointList that is reversed.
	 */
	private void reverse(PointList c, PointList rc) {
		rc.removeAllPoints();

		for (int i = c.size() - 1; i >= 0; i--) {
			rc.addPoint(c.getPoint(i));
		}
	}

	/**
	 * Computes the command that will route the given connection editpart with the given points.
	 */
	Command routeThrough(Edge edge, ConnectionEditPart connectEP, Node source, Node target, PointList points, int diffX, int diffY) {

		if (connectEP == null)
			return null;

		PointList routePoints = points;
		if (source.data != connectEP.getSource()) {
			routePoints = new PointList(points.size());
			reverse(points, routePoints);
			Node tmpNode = source;
			source = target;
			target = tmpNode;
		}
		
		PointList allPoints = new PointList(routePoints.size());
		for (int i = 0; i < routePoints.size(); i++) {
			allPoints.addPoint(routePoints.getPoint(i).x + diffX, routePoints
				.getPoint(i).y
				+ diffY);
		}

		Rectangle sourceExt = getNodeMetrics(source);
		Point ptSourceReference = sourceExt.getCenter().getTranslated(diffX,
			diffY);
		Rectangle targetExt = getNodeMetrics(target);
		Point ptTargetReference = targetExt.getCenter().getTranslated(diffX,
			diffY);
		
		SetAllBendpointRequest request = new SetAllBendpointRequest(
			RequestConstants.REQ_SET_ALL_BENDPOINT, allPoints,
			ptSourceReference, ptTargetReference);

		CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
		Command cmd = connectEP.getCommand(request);
		if (cmd != null)
			cc.add(cmd);
		
		// set the snapback position for all children owned by the connection
		List affectingChildren = getAffectingChildren(connectEP);
		Request snapBackRequest = new Request(RequestConstants.REQ_SNAP_BACK);
		ListIterator li = affectingChildren.listIterator();
		while (li.hasNext()) {
			EditPart ep = (EditPart)li.next();
			cmd = ep.getCommand(snapBackRequest);
			if (cmd != null)
				cc.add(cmd);
		}
		
		return cc;
	}
	
	/**
	 * Method update_diagram. Once the layout has been calculated with the GEF
	 * graph structure, the new layout values need to be propogated into the
	 * diagram. This is accomplished by creating a compound command that
	 * contains sub commands to change shapes positions and connection bendpoints
	 * positions. The command is subsequently executed by the calling action and
	 * then through the command infrastructure is undoable and redoable.
	 * 
	 * @@param diagramEP
	 *            IGraphicalEditPart container that is target for the commands.
	 * @@param g
	 *            DirectedGraph structure that contains the results of the
	 *            layout operation.
	 * @@param isLayoutForSelected
	 *            boolean indicating that the layout is to be performed on
	 *            selected objects only. At this stage this is relevant only to
	 *            calculate the offset in the diagram where the layout will
	 *            occur.
	 * @@return Command usually a command command that will set the locations of
	 *         nodes and bendpoints for connections.
	 */
	protected Command update_diagram(GraphicalEditPart diagramEP, DirectedGraph g,
			boolean isLayoutForSelected) {
		
		CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$

		Point diff = getLayoutPositionDelta(g, isLayoutForSelected);
		layoutDefaultMargin = MapModeUtil.getMapMode(diagramEP.getFigure()).DPtoLP(25);
		Command cmd = createNodeChangeBoundCommands(g, diff);
		if (cmd != null)
			cc.add(cmd);
		
		cmd = createEdgesChangeBoundsCommands(g, diff);
		if (cmd != null)
			cc.add(cmd);
		
		return cc;
	}
	
	/*
	 * Find all of the arcs and set their intermediate points. This
	 * loop does not set the icon positions yet, because that causes
	 * recalculation of the arc connection points. The intermediate
	 * points of both outgoing and incomping arcs must be set before
	 * recalculating connection points.
	 */ 
	protected Command createEdgesChangeBoundsCommands(DirectedGraph g, Point diff) {
		
		CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
		PointList points = new PointList(10);
		
		ListIterator vi = g.edges.listIterator();
		while (vi.hasNext()) {
			Edge edge = (Edge) vi.next();
			
			if (edge.data == null || edge.getPoints()==null)
				continue;
			
			points.removeAllPoints();

			ConnectionEditPart cep = null;
			Node source = null, target = null;
			
			collectPoints(points, edge);
			cep = (ConnectionEditPart)edge.data;
			source = edge.source;
			target = edge.target;
			
			if (cep != null) {
				PointListUtilities.normalizeSegments(points, MapModeUtil.getMapMode(cep.getFigure()).DPtoLP(3));
					
				// Reset the points list
				Command cmd = routeThrough(edge, cep, source, target, points, diff.x, diff.y);
				if (cmd != null)
					cc.add(cmd);
			}
		}
		
		if (cc.isEmpty())
			return null;
		return cc;
	}
d646 103
a748 1
	private void collectPoints(PointList points, Edge edge) {
d770 2
a771 2
	protected Command createNodeChangeBoundCommands(DirectedGraph g, Point diff) {
		ListIterator vi = g.nodes.listIterator();
d773 5
a777 5
		createSubCommands(diff, vi, cc);
	    if (cc.isEmpty())
			return null;
		return cc;
	}
d781 56
a836 56
		// arc connection points to be recalculated
		while (vi.hasNext()) {
			Node node = (Node) vi.next();
			if (node.data instanceof ShapeEditPart) {
				IGraphicalEditPart gep = (IGraphicalEditPart)node.data;
				
				ChangeBoundsRequest request = new ChangeBoundsRequest(
					RequestConstants.REQ_MOVE);
				Rectangle nodeExt = getNodeMetrics(node);
				Point ptLocation = new Point(nodeExt.x + diff.x, nodeExt.y
					+ diff.y);

				Point ptOldLocation = gep.getFigure().getBounds().getLocation();
				gep.getFigure().translateToAbsolute(ptOldLocation);
				
				gep.getFigure().translateToAbsolute(ptLocation);
				Dimension delta = ptLocation.getDifference(ptOldLocation);

				request.setEditParts(gep);
				request.setMoveDelta(new Point(delta.width, delta.height));
				request.setLocation(ptLocation);

				Command cmd = gep.getCommand(request);
				if (cmd != null && cmd.canExecute())
					cc.add(cmd);
			}
		}
    }

	private Point getLayoutPositionDelta(DirectedGraph g, boolean isLayoutForSelected) {
		// If laying out selected objects, use diff variables to
		// position objects at topleft corner of enclosing rectangle.
		if (isLayoutForSelected) {
			ListIterator vi;
			vi = g.nodes.listIterator();
			Point ptLayoutMin = new Point(-1, -1);
			while (vi.hasNext()) {
				Node node = (Node) vi.next();
				// ignore ghost node
				if (node.data != null) {
					Rectangle nodeExt = getNodeMetrics(node);
					if (ptLayoutMin.x == -1) {
						ptLayoutMin.x = nodeExt.x;
						ptLayoutMin.y = nodeExt.y;
					} else {
						ptLayoutMin.x = Math.min(ptLayoutMin.x, nodeExt.x);
						ptLayoutMin.y = Math.min(ptLayoutMin.y, nodeExt.y);
					}
				}
			}
	
			return new Point(this.minX - ptLayoutMin.x, this.minY - ptLayoutMin.y);
		}
		
		return new Point(layoutDefaultMargin, layoutDefaultMargin);
	}
d859 9
@


1.9
log
@bugzilla 128282 gmf-head sshaw 060216 DefaultProvider uses internal GEF API BreakCycles
@
text
@d17 1
d19 1
d23 1
d37 1
d48 2
d76 2
a77 2
    private int layoutDefaultMargin = 0;
    private IMapMode mm;
d79 4
a82 3
	private static final int NODE_PADDING = 30;
	private static final int MIN_EDGE_PADDING = 5;
	private static final int MAX_EDGE_PADDING = NODE_PADDING * 3;
d114 8
a121 1

a122 9
		if (containerEditPart == null) {
			InvalidParameterException ipe = new InvalidParameterException();
			Trace.throwing(DiagramProvidersPlugin.getInstance(),
				DiagramActionsDebugOptions.EXCEPTIONS_THROWING, getClass(),
				"layout()", //$NON-NLS-1$
				ipe);
			throw ipe;
		}

d124 1
a124 1
		DirectedGraph g = new DirectedGraph();
d126 1
a126 1
		new DirectedGraphLayout().visit(g);
d151 1
a151 1
		DirectedGraph g = new DirectedGraph();
d153 1
a153 1
		new DirectedGraphLayout().visit(g);
d187 1
a187 1
	private NodeList build_nodes(List selectedObjects, Map editPartToNodeDict) {
d255 11
a265 2
	final protected Rectangle getNodeMetrics(Node n) {
		return translateFromGraph(new Rectangle(n.x, n.y, n.width, n.height));
d306 1
a306 1
	private EdgeList build_edges(List selectedObjects, Map editPartToNodeDict) {
d324 1
d333 4
a336 1

d344 2
d351 1
a351 1
		li = objects.listIterator();
d353 13
a365 16
			EditPart gep = (EditPart) li.next();
			if (gep instanceof ConnectionEditPart) {
				ConnectionEditPart poly = (ConnectionEditPart) gep;

				if (!layoutTopDown(poly)) {
					EditPart from = poly.getSource();
					EditPart to = poly.getTarget();

					Node fromNode = (Node) editPartToNodeDict.get(from);
					Node toNode = (Node) editPartToNodeDict.get(to);

					if (fromNode != null && toNode != null
						&& !fromNode.equals(toNode)) {
						addEdge(edges, poly, fromNode, toNode);
					}
				}
a367 1

d469 13
a481 5
			ShapeEditPart shapeEP = (ShapeEditPart) e;
			List sourceConnections = shapeEP.getSourceConnections();
			for (int i = 0; i < sourceConnections.size(); i++) {
				ConnectionEditPart connectionEP = (ConnectionEditPart) sourceConnections
					.get(i);
a482 1

d485 3
a487 1
				Object o = editPartToNodeDict.get(target);
d496 17
d525 1
a525 1
	private void build_graph(DirectedGraph g, List selectedObjects) {
a526 1

d529 1
a529 2

		NodeList nodes = build_nodes(selectedObjects, editPartToNodeDict);
a534 1

d536 1
a536 2

		g.nodes = nodes;
d538 7
d546 1
a546 8
		//new BreakCycles().visit(g);
				
		// this has to be called after - BreakCycles to ensure we are fully
		// connected.
		//connectNonConnectedSubgraphs(nodes, edges);
	}

	/**
d637 1
a637 1
	Command update_diagram(GraphicalEditPart diagramEP, DirectedGraph g,
d644 1
a644 1
		Command cmd = getShapesPositionCommand(g, diff);
d648 1
a648 1
		cmd = getConnectionPositionCommand(g, diff);
d662 1
a662 1
	private Command getConnectionPositionCommand(DirectedGraph g, Point diff) {
d671 1
a671 1
			if (edge.data == null)
d700 12
a711 11
		Point startpt = edge.getPoints().getFirstPoint();
		Rectangle start = translateFromGraph(new Rectangle(startpt.x, startpt.y, 0, 0));
		points.addPoint(start.getTopLeft());

		NodeList vnodes = edge.vNodes;
		if (vnodes != null) {
			for (int i = 0; i < vnodes.size(); i++) {
				Node vn = vnodes.getNode(i);
				Rectangle nodeExt = getNodeMetrics(vn);
				int x = nodeExt.x;
				int y = nodeExt.y;
d713 7
a719 3
				points.addPoint(x + nodeExt.width / 2, y + nodeExt.height / 2);
			}
		}
d721 7
a727 3
		Point endpt = edge.getPoints().getLastPoint();
		Rectangle end = translateFromGraph(new Rectangle(endpt.x, endpt.y, 0, 0));
		points.addPoint(end.getTopLeft());
d730 2
a731 6
	private Command getShapesPositionCommand(DirectedGraph g, Point diff) {
		ListIterator vi = g.nodes.listIterator();

		CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
		
		// Now set the position of the icons. This causes the
d755 1
a755 1
				if (cmd != null)
d759 1
a759 5
		
		if (cc.isEmpty())
			return null;
		return cc;
	}
d788 70
@


1.8
log
@bugzilla 117592 gmf-head mmostafa 060207 Eroneous references to xtools in diagram plugins
@
text
@a33 1
import org.eclipse.draw2d.internal.graph.BreakCycles;
d383 2
a384 2
		edge.padding = Math.max(edge.padding, calculateEdgePadding(connectionEP, affectingChildren));
		edge.delta = Math.max(edge.delta, affectingChildren.size() / 2);
a472 36
	 * connectNonConnectedSubgraphs Since the GEF algorithm only handles fully
	 * connected graphs, we have to simulate this when there are nodes that
	 * aren't connected. This routine will create a "ghost" node that serves as
	 * a parent for all nodes that don't have any incoming connections.
	 * 
	 * @@param nodes
	 *            List of Nodes that are to be contained in the graph.
	 * @@param edges
	 *            List of Edges that are to be contained in the graph.
	 */
	private void connectNonConnectedSubgraphs(List nodes, List edges) {
		Node ghostNode = new Node();
		ghostNode.width = 1;
		ghostNode.height = 1;
		ghostNode.setPadding(new Insets(0));

		nodes.add(ghostNode);

		ListIterator ni = nodes.listIterator();
		while (ni.hasNext()) {
			Node n = (Node) ni.next();

			if (n == ghostNode)
				continue;

			// if node has no incoming connections then assume it is
			// not-connected to the main graph.
			if (n.incoming.isEmpty()) {
				Edge e = new Edge(ghostNode, n);
				e.weight = 0;
				edges.add(e);
			}
		}
	}

	/**
d501 1
a501 1
		new BreakCycles().visit(g);
d505 1
a505 1
		connectNonConnectedSubgraphs(nodes, edges);
d662 2
a663 1
		Rectangle start = translateFromGraph(new Rectangle(edge.start.x, edge.start.y, 0, 0));
d678 2
a679 1
		Rectangle end = translateFromGraph(new Rectangle(edge.end.x, edge.end.y, 0, 0));
@


1.7
log
@bugzilla 116490 gmf-head sshaw 051124 LayoutService should be public
@
text
@d87 2
a88 2
	/**
	 * @@see com.ibm.xtools.common.service.IProvider#provides(IOperation)
@


1.6
log
@bugzilla 117324 gmf-head sshaw 051121 memory leak caused by the DefualtProvider
@
text
@d47 1
d50 1
a50 2
import org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutProvider;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutNodesOperation;
d66 1
a66 1
	extends AbstractLayoutProvider {
d103 2
a104 3
	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.ILayoutProvider#layout(org.eclipse.gef.GraphicalEditPart,
	 *      org.eclipse.core.runtime.IAdaptable)
d131 2
a132 3
	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.ILayoutProvider#layout(java.util.List,
	 *      org.eclipse.core.runtime.IAdaptable)
@


1.5
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d125 5
a129 1
		return update_diagram(containerEditPart, g, false);
d153 5
a157 2
		return update_diagram(containerEditPart, g, true);

@


1.4
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@a41 2
import org.eclipse.jface.util.Assert;

d53 2
a54 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d56 1
a69 1

d71 2
a72 2

	protected static final int LAYOUTDEFAULTMARGIN = MapMode.DPtoLP(25);
d78 9
d110 1
d143 2
d259 1
d637 1
a637 1

d679 1
a679 1
				PointListUtilities.normalizeSegments(points, MapMode.DPtoLP(3));
d777 1
a777 1
		return new Point(LAYOUTDEFAULTMARGIN, LAYOUTDEFAULTMARGIN);
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d440 1
a440 1
				ConnectionEditPart connectorEP = (ConnectionEditPart) sourceConnections
d442 1
a442 1
				EditPart target = connectorEP.getTarget();
d445 1
a445 1
				// the associated connectorView should be included on graph
d448 1
a448 1
					connectionsToMove.add(connectorEP);
d482 1
a482 1
			// if node has no incoming connectors then assume it is
d511 1
a511 1
		// append connectorViews that should be added to the graph
d584 1
a584 1
		// set the snapback position for all children owned by the connector
d602 1
a602 1
	 * contains sub commands to change shapes positions and connector bendpoints
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d54 1
a54 1
import com.ibm.xtools.notation.View;
@

