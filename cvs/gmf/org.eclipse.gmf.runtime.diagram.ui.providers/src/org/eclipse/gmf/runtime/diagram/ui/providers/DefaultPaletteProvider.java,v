head	1.15;
access;
symbols
	v20081020-0700:1.15
	v20080924-1925:1.15
	v20080917-1925:1.15
	v20080916-2008:1.15
	v20080911-1728:1.15
	v20080722-1827:1.15
	v20080716-1600:1.15
	v20080716-1642:1.15
	R2_1_maintenance:1.15.0.2
	Root_R2_1_maintenance:1.15
	R2_1_0:1.15
	v20080503-1740:1.15
	v20080425-1959:1.15
	v20080417-1610:1.15
	v20080407-2250:1.15
	v20080407-0930:1.15
	v20080404-1111:1.15
	v20080328-1605:1.15
	v20080222-1200:1.14
	v20080215-1500:1.14
	v20080201-2010:1.14
	v20080201-0201:1.13.4.1
	v20071130-1111:1.13
	v20071108-0000:1.13
	v20070903-0000:1.13
	v20070809-0000:1.13
	R2_0_maintenance:1.13.0.4
	R2_0:1.13
	R4_20:1.13
	v20070621-0000:1.13
	RC3_20:1.13
	v20070601-1400:1.13
	v20070518-1300:1.13
	bugzilla111892_group_support:1.13.0.2
	Root_bugzilla111892_group_support:1.13
	v20070504-1000:1.13
	v20070420-1000:1.12
	v20070413-1300:1.11
	v20070330-1300:1.11
	v20060316-0600:1.11
	v20070228-2000:1.10
	v20070221-1500:1.10
	v20070208-1800:1.10
	M4_20:1.8
	v20061218-1500:1.8
	v20061214-0000:1.8
	M3_20:1.8
	v20061013-1330:1.8
	v20060919-0800:1.8
	M1_20:1.8
	v20060803-1200:1.8
	v20060728-0500:1.8
	v20060721-1130:1.8
	v20060713-1700:1.8
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	v20060627-1200:1.8
	v20060616-1200:1.8
	v20060609-1400:1.8
	v20060531-1730:1.8
	v20060530-1930:1.8
	v20060519-0800:1.8
	I20060428-1300:1.8
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.7
	I20060331-1000:1.7
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.4
	I20060202-1415:1.4
	I20060129-1145:1.4
	I20060127-0900:1.4
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051201-1800:1.2
	I20051124-2000:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.15
date	2008.03.25.17.55.59;	author crevells;	state Exp;
branches;
next	1.14;
commitid	33c947e93cae4567;

1.14
date	2008.01.29.16.45.52;	author ahunter;	state Exp;
branches;
next	1.13;
commitid	6199479f583f4567;

1.13
date	2007.05.02.15.20.11;	author crevells;	state Exp;
branches
	1.13.4.1;
next	1.12;
commitid	2f8b4638ac2b4567;

1.12
date	2007.04.17.18.08.04;	author crevells;	state Exp;
branches;
next	1.11;
commitid	171e46250d044567;

1.11
date	2007.03.13.17.18.25;	author crevells;	state Exp;
branches;
next	1.10;
commitid	57a045f6dce14567;

1.10
date	2007.01.12.16.44.57;	author crevells;	state Exp;
branches;
next	1.9;
commitid	6a2845a7bb084567;

1.9
date	2007.01.10.15.15.52;	author crevells;	state Exp;
branches;
next	1.8;
commitid	5c5e45a503274567;

1.8
date	2006.04.11.14.01.04;	author cmahoney;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.29.22.04.31;	author cmahoney;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.27.17.46.21;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.07.15.19.01;	author mmostafa;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.26.15.37.17;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.20.22.10.14;	author cmahoney;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.25.19.37.44;	author cmahoney;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.21.15.45.16;	author cmahoney;	state Exp;
branches;
next	;

1.13.4.1
date	2008.01.29.16.48.18;	author ahunter;	state Exp;
branches;
next	;
commitid	34aa479f58d14567;


desc
@@


1.15
log
@[223919] gmf_head crevells 080325 Palette drawers should be able to have no icon
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.providers;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.gef.Tool;
import org.eclipse.gef.palette.PaletteContainer;
import org.eclipse.gef.palette.PaletteEntry;
import org.eclipse.gef.palette.PaletteRoot;
import org.eclipse.gmf.runtime.common.core.service.AbstractProvider;
import org.eclipse.gmf.runtime.common.core.service.IOperation;
import org.eclipse.gmf.runtime.common.core.service.AbstractProviderConfiguration.ObjectDescriptor;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.util.ActivityUtil;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.PaletteTemplateEntry;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.PaletteToolEntry;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.DiagramProvidersPlugin;
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.DiagramProvidersStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.services.palette.IPaletteProvider;
import org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteFactory;
import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteDrawer;
import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteSeparator;
import org.eclipse.gmf.runtime.gef.ui.internal.palette.PaletteStack;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.ui.IEditorPart;
import org.osgi.framework.Bundle;

import com.ibm.icu.util.StringTokenizer;

/**
 * The defaul palette provider. It reads XML palette contributions from the
 * provider's extension point and contributes them to an editor's palette
 * based on different contribution criteria
 * 
 * The provider class should not be subclassed since it does its contribution totally from XML
 * However, if programatic contribution is required, then the <code>IPaletteProvider</code>
 * interface should be implemented directly instead 
 * 
 * @@author melaasar
 * @@canBeSeenBy org.eclipse.gmf.runtime.diagram.ui.providers.*
 */
public class DefaultPaletteProvider
    extends AbstractProvider
    implements IPaletteProvider {

    /** constants corresponding to different symbols in the extention schema */
    private static final String CONTRIBUTION = "contribution"; //$NON-NLS-1$
    private static final String FACTORY_CLASS = "factoryClass"; //$NON-NLS-1$
    private static final String ENTRY = "entry"; //$NON-NLS-1$
    private static final String KIND = "kind"; //$NON-NLS-1$
    private static final String ID = "id"; //$NON-NLS-1$
    private static final String PATH = "path"; //$NON-NLS-1$
    private static final String LABEL = "label"; //$NON-NLS-1$
    private static final String DESCRIPTION = "description"; //$NON-NLS-1$
    private static final String SMALL_ICON = "small_icon"; //$NON-NLS-1$
    private static final String LARGE_ICON = "large_icon"; //$NON-NLS-1$
//  private static final String PERMISSION = "permission"; //$NON-NLS-1$
    private static final String EXPAND = "expand"; //$NON-NLS-1$
    private static final String FORCE = "force"; //$NON-NLS-1$
    private static final String CONTENT = "content"; //$NON-NLS-1$
    private static final String DEFINE_ONLY = "defineOnly"; //$NON-NLS-1$
    private static final String PREDEFINED_ENTRY = "predefinedEntry"; //$NON-NLS-1$
    private static final String REMOVE = "remove"; //$NON-NLS-1$

    /** palette entry kind enumeration */
    private static final String DRAWER = "drawer"; //$NON-NLS-1$
    private static final String STACK = "stack"; //$NON-NLS-1$
    private static final String SEPARATOR = "separator"; //$NON-NLS-1$
    private static final String TEMPLATE = "template"; //$NON-NLS-1$
    private static final String TOOL = "tool"; //$NON-NLS-1$
    private static final int ENUM_DRAWER = 0;
    private static final int ENUM_STACK = 1;
    private static final int ENUM_SEPARATOR = 2;
    private static final int ENUM_TEMPLATE = 3;
    private static final int ENUM_TOOL = 4;

    /** palette entry permission enumeration */
    private static final String NONE = "None"; //$NON-NLS-1$
    private static final String HIDEONLY = "HideOnly"; //$NON-NLS-1$
    private static final String LIMITED = "limited"; //$NON-NLS-1$
    private static final String FULL = "full"; //$NON-NLS-1$

    /**
     * A descriptor for XML-based palette contribution
     */
    private static class ContributionDescriptor {

        private PaletteFactoryProxy paletteFactory;
        private List entries = new ArrayList();

        /**
         * Reads XML entries for a contribution 
         * @@param configElement
         */
        public ContributionDescriptor(IConfigurationElement configElement) {
            paletteFactory = new PaletteFactoryProxy(configElement);

            // read the palette entries
            IConfigurationElement configChildren[] =
                configElement.getChildren(ENTRY);

            for (int i = 0; i < configChildren.length; i++) {
                entries.add(new EntryDescriptor(configChildren[i]));
            }
            
            configChildren =
                configElement.getChildren(PREDEFINED_ENTRY);

            for (int i = 0; i < configChildren.length; i++) {
                entries.add(new PredefinedEntryDescriptor(configChildren[i]));
            }
        }

        /**
         * Contributes to the given palette root based on the given editor's
         * content
         * 
         * @@param content
         * @@param root
         * @@param predefinedEntries
         *            map of predefined palette entries where the key is the
         *            palette entry id and the value is the palette entry
         */
        public void contribute(Object content, PaletteRoot root, Map predefinedEntries, String pluginID) {
            Iterator iter = entries.iterator();
            while (iter.hasNext()) {
                IEntryDescriptor descriptor = (IEntryDescriptor) iter.next();
                if (ActivityUtil.isEnabled(descriptor.getID(), pluginID)) {
                    descriptor.contribute(content, root, paletteFactory,
                        predefinedEntries);
                }
            }
        }
    }
    
    /**
     * An interface describing the types of palette entries in the schema.
     * 
     * @@author cmahoney
     */
    private static interface IEntryDescriptor {

        /**
         * Contributes the palette entry based on the given content, starting
         * from the given root and into the given path
         * 
         * @@param content
         * @@param root
         * @@param paletteFactory
         * @@param predefinedEntries
         *            map of predefined palette entries where the key is the
         *            palette entry id and the value is the palette entry
         */
        public void contribute(Object content, PaletteRoot root,
                PaletteFactoryProxy paletteFactory, Map predefinedEntries);
        
        /**
         * Gets the ID of this entry descriptor.
         * 
         * @@return the id
         */
        public String getID();
    }

    /**
     * A descriptor for an XML-based palette entry
     */
    private static class EntryDescriptor implements IEntryDescriptor {
        private Integer kind;
        private String id;
        private String path;
        private String label;
        private String description;
        private Integer permission;
        private ImageDescriptor small_icon;
        private ImageDescriptor large_icon;
        private boolean noIcon = false;
        private DrawerExpandHelper expandHelper;
        private boolean defineOnly;

        /**
         * Reads an XML palette entry and its attributes
         * @@param configElement
         */
        public EntryDescriptor(IConfigurationElement configElement) {
            String kindStr = configElement.getAttribute(KIND);
            if (DRAWER.equals(kindStr))
                kind = new Integer(ENUM_DRAWER);
            else if (STACK.equals(kindStr))
                kind = new Integer(ENUM_STACK);
            else if (SEPARATOR.equals(kindStr))
                kind = new Integer(ENUM_SEPARATOR);
            else if (TEMPLATE.equals(kindStr))
                kind = new Integer(ENUM_TEMPLATE);
            else if (TOOL.equals(kindStr))
                kind = new Integer(ENUM_TOOL);
            else
                Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$

            id = configElement.getAttribute(ID);
            if (id == null)
                Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$

            defineOnly = Boolean.valueOf(
                configElement.getAttribute(DEFINE_ONLY)).booleanValue();

            path = configElement.getAttribute(PATH);
            if (path == null && !defineOnly)
                Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "Path must be provided when contributing a palette entry"); //$NON-NLS-1$

            label = configElement.getAttribute(LABEL);
            if (label == null)
                label = DiagramUIMessages.PaletteEntry_DefaultLabel;

            description = configElement.getAttribute(DESCRIPTION);

            if (NONE.equals(kindStr))
                permission =
                    new Integer(PaletteEntry.PERMISSION_NO_MODIFICATION);
            if (HIDEONLY.equals(kindStr))
                permission = new Integer(PaletteEntry.PERMISSION_HIDE_ONLY);
            if (LIMITED.equals(kindStr))
                permission =
                    new Integer(PaletteEntry.PERMISSION_LIMITED_MODIFICATION);
            if (FULL.equals(kindStr))
                permission =
                    new Integer(PaletteEntry.PERMISSION_FULL_MODIFICATION);

            String smallIconPath = configElement.getAttribute(SMALL_ICON);
            if (NONE.equals(smallIconPath)) {
                noIcon = true;
            } else {
                small_icon = findIconImageDescriptor(configElement, smallIconPath);
            }
            
            String largeIconPath = configElement.getAttribute(LARGE_ICON);
            large_icon = findIconImageDescriptor(configElement, largeIconPath);

            if (kind.intValue() == ENUM_DRAWER) {
                IConfigurationElement[] configChildren =
                    configElement.getChildren(EXPAND);
                if (configChildren.length > 0)
                    expandHelper = new DrawerExpandHelper(configChildren[0]);
                else
                    expandHelper = new DrawerExpandHelper(Boolean.FALSE);
            }
        }

        /**
         * Finds the image descriptor that is associated with the icon path.
         * @@param configElement
         * @@param smallIconPath
         * @@return
         */
        private ImageDescriptor findIconImageDescriptor(IConfigurationElement configElement, String iconPath) {
            String pluginId = configElement.getDeclaringExtension().getNamespaceIdentifier();
            Bundle bundle = Platform.getBundle(pluginId);
            try
            {
                if (iconPath != null) {
                    URL fullPathString = FileLocator.find(bundle, new Path(iconPath), null);
                    fullPathString = fullPathString != null ? fullPathString : new URL(iconPath);
                    if (fullPathString != null) {
                        return ImageDescriptor.createFromURL(fullPathString);
                    }
                }
            }
            catch (MalformedURLException e)
            {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING,
                    DefaultPaletteProvider.class, e.getLocalizedMessage(), e); 
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.RESOURCE_FAILURE, e.getMessage(), e);
            }
            
            return null;
        }

        public void contribute(
            Object content,
            PaletteRoot root,
            PaletteFactoryProxy paletteFactory, Map predefinedEntries) {
            if (kind == null || id == null || label == null)
                return;

            PaletteEntry paletteEntry = null;

            switch (kind.intValue()) {
                case ENUM_DRAWER :
                    PaletteDrawer drawer = new PaletteDrawer(id, label);
                    if (expandHelper.expand(content)) {
                        drawer.setInitialState(
                            PaletteDrawer.INITIAL_STATE_OPEN);
                    }
                    if (noIcon) {
                        drawer.setShowDefaultIcon(false);
                    }
                    paletteEntry = drawer;
                    break;
                case ENUM_STACK:
                    paletteEntry = new PaletteStack(id, label, description,
                        small_icon);
                    break;
                case ENUM_SEPARATOR :
                    paletteEntry = new PaletteSeparator(id);
                    break;
                case ENUM_TEMPLATE :
                    paletteEntry =
                        new PaletteTemplateEntry(id, label, paletteFactory);
                    break;
                case ENUM_TOOL :
                    paletteEntry =
                        new PaletteToolEntry(id, label, paletteFactory);
                    break;
            }

            if (paletteEntry != null) {
                paletteEntry.setDescription(description);
                paletteEntry.setSmallIcon(small_icon);
                paletteEntry.setLargeIcon(large_icon);
                if (permission != null)
                    paletteEntry.setUserModificationPermission(
                        permission.intValue());

                if (defineOnly) {
                    predefinedEntries.put(id, paletteEntry);
                } else {
                    appendPaletteEntry(root, predefinedEntries, path, paletteEntry);
                }
            }
        }

        public String getID() {
            return id;
        }

    }

    /**
     * A descriptor for an XML-based predefined palette entry. 
     */
    private static class PredefinedEntryDescriptor
        implements IEntryDescriptor {

        private String id;
        private String path;
        private DrawerExpandHelper expandHelper;
        private boolean remove;

        /**
         * Reads an XML palette entry and its attributes
         * @@param configElement
         */
        public PredefinedEntryDescriptor(IConfigurationElement configElement) {
            id = configElement.getAttribute(ID);
            if (id == null) {
                Log.info(DiagramProvidersPlugin.getInstance(),
                    DiagramProvidersStatusCodes.SERVICE_FAILURE,
                    "No ID provided"); //$NON-NLS-1$
            }
 
            path = configElement.getAttribute(PATH);
 
            IConfigurationElement[] configChildren = configElement
                .getChildren(EXPAND);
            if (configChildren.length > 0)
                expandHelper = new DrawerExpandHelper(configChildren[0]);
            else
                expandHelper = new DrawerExpandHelper(Boolean.FALSE);
            
            remove = Boolean.valueOf(configElement.getAttribute(REMOVE))
                .booleanValue();
        }

        public void contribute(
            Object content,
            PaletteRoot root,
            PaletteFactoryProxy paletteFactory, Map predefinedEntries) {
            
            if (id == null)
                return;
            
            // first try to find it in the palette root
            PaletteEntry paletteEntry = findPaletteEntry(root, id);
            
            if (paletteEntry != null) {

                if (remove) {
                    paletteEntry.getParent().remove(paletteEntry);
                    return;
                }
                
                // Set expand state on drawers.
                if (paletteEntry instanceof PaletteDrawer
                    && expandHelper.expand(content)) {
                    ((PaletteDrawer) paletteEntry)
                        .setInitialState(PaletteDrawer.INITIAL_STATE_OPEN);
                }

            }
            
            // now check to see if it has been predefined only
            if (paletteEntry == null) {
                paletteEntry = findPredefinedEntry(predefinedEntries, id);
            }
            
            if (paletteEntry != null) {
                
                if (path != null) {
                    appendPaletteEntry(root, predefinedEntries, path,
                        paletteEntry);
                    
                    // Set expand state on drawers.
                    if (paletteEntry instanceof PaletteDrawer
                        && expandHelper.expand(content)) {
                        ((PaletteDrawer) paletteEntry)
                            .setInitialState(PaletteDrawer.INITIAL_STATE_OPEN);
                    }
                }
            }
        }

        public String getID() {
            return id;
        }
    }

    /**
     * Searches the predefined entries for a palette entry given the full path
     * as it was predefined.
     * 
     * @@param predefinedEntries
     *            map of predefined palette entries where the key is the palette
     *            entry id and the value is the palette entry
     * @@param path
     *            the path to the palette entry starting as it was predefined
     * @@return the palette entry if one exists; null otherwise.
     */
    private static PaletteEntry findPredefinedEntry(Map predefinedEntries,
            String path) {
        StringTokenizer tokens = new StringTokenizer(path, "/"); //$NON-NLS-1$

        PaletteEntry root = (PaletteEntry) predefinedEntries.get(tokens
            .nextToken());

        while (tokens.hasMoreElements()) {
            if (root instanceof PaletteContainer)
                root = findChildPaletteEntry((PaletteContainer) root, tokens
                    .nextToken());
            else
                return null;
        }
        return root;
    }
    
    /**
     * Finds a palette container starting from the given root and using the
     * given path
     * 
     * @@param root
     * @@param aPath
     * @@return the container or <code>null</code> if not found
     */
    private static PaletteEntry findPaletteEntry(PaletteEntry root, String aPath) {
        StringTokenizer tokens = new StringTokenizer(aPath, "/"); //$NON-NLS-1$
        while (tokens.hasMoreElements()) {
            if (root instanceof PaletteContainer)
                root =
                    findChildPaletteEntry(
                        (PaletteContainer) root,
                        tokens.nextToken());
            else
                return null;
        }
        return root;
    }

    /**
     * Finds a palette entry starting from the given container
     * and using the given path
     * @@param root
     * @@param path
     * @@return the entry or <code>null</code> if not found
     */
    private static PaletteEntry findChildPaletteEntry(
        PaletteContainer container,
        String childId) {
        Iterator entries = container.getChildren().iterator();
        while (entries.hasNext()) {
            PaletteEntry entry = (PaletteEntry) entries.next();
            if (entry.getId().equals(childId))
                return entry;
        }
        return null;
    }
    
    /**
     * Appends the given palette entry to the appropriate location in either a
     * predefined palette entry or the palette root.
     * 
     * @@param root
     * @@param predefinedEntries
     *            map of predefined palette entries where the key is the palette
     *            entry id and the value is the palette entry
     * @@param path
     * @@param paletteEntry
     */
    private static void appendPaletteEntry(PaletteRoot root,
            Map predefinedEntries, String path, PaletteEntry paletteEntry) {
        PaletteEntry fEntry = findPaletteEntry(root, path);
        if (fEntry == null) {
            fEntry = findPredefinedEntry(predefinedEntries, path);
        }
        if (fEntry == null) 
            Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "Invalid palette entry path"); //$NON-NLS-1$                
        else if (fEntry instanceof PaletteContainer)
             ((PaletteContainer) fEntry).add(paletteEntry);
        else if (fEntry instanceof PaletteSeparator)
            appendTo((PaletteSeparator) fEntry, paletteEntry);
        else
            fEntry.getParent().add(
                fEntry.getParent().getChildren().indexOf(fEntry) + 1,
                paletteEntry);
    }
    
    /**
     * Appends the given entry to the end of the group of the given separator.
     * 
     * @@param separator
     * @@param entry
     */
    private static void appendTo(PaletteSeparator separator, PaletteEntry entry) {
        List children = separator.getParent().getChildren();
        int index = children.indexOf(separator);
        for (index++; index < children.size(); index++) {
            if (children.get(index) instanceof PaletteSeparator)
                break;
        }
        separator.getParent().add(index, entry);
    }

    /**
     * A proxy for a palette factory that instantiates the real factory
     * on demand (when a palette entry is selcted)
     */
    private static class PaletteFactoryProxy extends PaletteFactory.Adapter {

        private IConfigurationElement configElement;
        private PaletteFactory factory;

        public PaletteFactoryProxy(IConfigurationElement configElement) {
            this.configElement = configElement;
        }

        /**
         * @@see org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteFactory#getTemplate(java.lang.String)
         */
        public Object getTemplate(String templateId) {
            if (factory == null) {
                try {
                    Object ext =
                        configElement.createExecutableExtension(FACTORY_CLASS);
                    factory = (PaletteFactory) ext;
                } catch (CoreException e) {
                    Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$                  
                }
            }
            if (factory != null) {
                Object template = factory.getTemplate(templateId);
                if (template == null)
                    Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
                return template;
            }
            return null;
        }

        /**
         * @@see org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteFactory#createTool(java.lang.String)
         */
        public Tool createTool(String toolId) {
            if (factory == null) {
                try {
                    Object ext =
                        configElement.createExecutableExtension(FACTORY_CLASS);
                    factory = (PaletteFactory) ext;
                } catch (CoreException e) {
                    Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$                  
                }
            }
            if (factory != null) {
                Tool tool = factory.createTool(toolId);
                if (tool == null)
                    Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
                return tool;
            }
            return null;
        }
    }

    /**
     * A helper class in expanding palette drawer. It reads
     * the relavent XML entries for that.
     */
    private static class DrawerExpandHelper {

        private Boolean force;
        private ObjectDescriptor content;

        /**
         * Initialize the helper with a foced value
         * @@param force
         */
        public DrawerExpandHelper(Boolean force) {
            this.force = force;
        }

        /**
         * Initialize the helper from the config element in the XML
         * @@param configElement
         */
        public DrawerExpandHelper(IConfigurationElement configElement) {
            String forceStr = configElement.getAttribute(FORCE);
            force =
                forceStr == null ? Boolean.FALSE : Boolean.valueOf(forceStr);

            IConfigurationElement[] configChildren =
                configElement.getChildren(CONTENT);
            if (configChildren.length > 0)
                content = new ObjectDescriptor(configChildren[0]);
        }

        /**
         * Determines whether to initially expand the palette drawer
         * @@param targetContent
         * @@return
         */
        public boolean expand(Object targetContent) {
            if (Boolean.TRUE.equals(force))
                return true;
            if (content != null && content.sameAs(targetContent))
                return true;
            return false;
        }
    }

    /**
     * The list of palette provider XML contributions
     */
    private List contributions = new ArrayList();
    
    /**
     * The pluginID of the XML contributions
     */
    private String pluginID;

    /**
     * 
     * Adds the configuration elements to the 
     * list of palette provider XML contributions 
     * 
     * @@param configElement
     */
    public void setContributions(IConfigurationElement configElement) {
        
        pluginID = configElement.getContributor().getName();
        IConfigurationElement configChildren[] =
            configElement.getChildren(CONTRIBUTION);

        for (int i = 0; i < configChildren.length; i++) {
            contributions.add(new ContributionDescriptor(configChildren[i]));
        }
    }

    /**
     * @@see org.eclipse.gmf.runtime.diagram.ui.services.palette.IPaletteProvider#contributeToPalette(org.eclipse.ui.IEditorPart, java.lang.Object)
     */
    public void contributeToPalette(
        IEditorPart editor,
        Object content,
        PaletteRoot root, Map predefinedEntries) {
        Iterator iter = contributions.iterator();
        while (iter.hasNext()) {
            ((ContributionDescriptor) iter.next()).contribute(content, root, predefinedEntries, pluginID);
        }
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.common.core.service.IProvider#provides(org.eclipse.gmf.runtime.common.core.service.IOperation)
     */
    public boolean provides(IOperation operation) {
        return false; // all logic is done in the service
    }
    
    
}
@


1.14
log
@[216931] gmf-head cdamus 080129 Erroneous dependencies on Boolean identity in transaction options
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2008 IBM Corporation and others.
d202 1
d255 5
a259 1
            small_icon = findIconImageDescriptor(configElement, smallIconPath);
d317 1
a317 1
                    if (expandHelper.expand(content))
d320 4
@


1.13
log
@[181934] gmf_head crevells 070502 ContributionItemService does not filter actions on submenus of the context menu
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d655 1
a655 1
            if (force == Boolean.TRUE)
@


1.13.4.1
log
@[216931] gmf-R2_0_aintenance cdamus 080129 Erroneous dependencies on Boolean identity in transaction options
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2008 IBM Corporation and others.
d655 1
a655 1
            if (Boolean.TRUE.equals(force))
@


1.12
log
@[181934] gmf_head crevells 070417 Ability for DiagramContributionItemService to filter out individual actions based on capability enablement
@
text
@d35 1
a50 5
import org.eclipse.ui.IPluginContribution;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.activities.IIdentifier;
import org.eclipse.ui.activities.IWorkbenchActivitySupport;
import org.eclipse.ui.activities.WorkbenchActivityHelper;
d153 1
a153 1
                if (areActivitiesEnabled(descriptor.getID(), pluginID)) {
a710 35
    /**
     * Checks if there are activities that have been matched to the plug-in or
     * id in which the item has been contributed and if at least one of those
     * matching activities are enabled.
     * 
     * @@return true if at least one matching activity is enabled
     */
    private static boolean areActivitiesEnabled(final String paletteEntryID, final String pluginID) {
        // Note: This is a duplicate of the areActivitiesEnabled() method in
        // org.eclipse.gmf.runtime.common.ui.services.util.ActivityFilterProviderDescriptor.
        
        if (!WorkbenchActivityHelper.isFiltering())
            return true;

        IWorkbenchActivitySupport workbenchActivitySupport = PlatformUI
            .getWorkbench().getActivitySupport();
        IIdentifier id = workbenchActivitySupport.getActivityManager()
            .getIdentifier(
                WorkbenchActivityHelper
                    .createUnifiedId(new IPluginContribution() {

                        public String getLocalId() {
                            return paletteEntryID;
                        }

                        public String getPluginId() {
                            return pluginID;
                        }
                    }));
        if (id != null && !id.isEnabled()) {
            return false;
        }

        return true;
    }
@


1.11
log
@[176751] gmf_head crevells 070313 Need ability to filter single palette entries based on enabled capabilities
@
text
@d716 3
a718 3
     * Checks if there are activities that have been matched to the plug-in in
     * which the provider has been contributed and if those activities are
     * enabled.  
d720 1
a720 1
     * @@return true if matching activities are enabled
@


1.10
log
@gmf_head crevells 061012 Updated year in copyright in missed files
@
text
@d50 5
d153 1
a153 1
        public void contribute(Object content, PaletteRoot root, Map predefinedEntries) {
d156 5
a160 4
                ((IEntryDescriptor) iter.next()).contribute(
                    content,
                    root,
                    paletteFactory, predefinedEntries);
d167 1
a167 1
     *
d185 7
d354 4
d443 4
d671 5
d685 2
d704 1
a704 1
            ((ContributionDescriptor) iter.next()).contribute(content, root, predefinedEntries);
d715 36
@


1.9
log
@[169871] gmf_head crevells 070110 Cannot contribute an existing palette entry to a new drawer
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003, 2006 IBM Corporation and others.
@


1.8
log
@Bugzilla#135692 gmf_head cmahoney 060411 Move IPaletteProvider interface in public api
@
text
@d67 2
a68 2
	extends AbstractProvider
	implements IPaletteProvider {
d70 15
a84 15
	/** constants corresponding to different symbols in the extention schema */
	private static final String CONTRIBUTION = "contribution"; //$NON-NLS-1$
	private static final String FACTORY_CLASS = "factoryClass"; //$NON-NLS-1$
	private static final String ENTRY = "entry"; //$NON-NLS-1$
	private static final String KIND = "kind"; //$NON-NLS-1$
	private static final String ID = "id"; //$NON-NLS-1$
	private static final String PATH = "path"; //$NON-NLS-1$
	private static final String LABEL = "label"; //$NON-NLS-1$
	private static final String DESCRIPTION = "description"; //$NON-NLS-1$
	private static final String SMALL_ICON = "small_icon"; //$NON-NLS-1$
	private static final String LARGE_ICON = "large_icon"; //$NON-NLS-1$
//	private static final String PERMISSION = "permission"; //$NON-NLS-1$
	private static final String EXPAND = "expand"; //$NON-NLS-1$
	private static final String FORCE = "force"; //$NON-NLS-1$
	private static final String CONTENT = "content"; //$NON-NLS-1$
d89 40
a128 40
	/** palette entry kind enumeration */
	private static final String DRAWER = "drawer"; //$NON-NLS-1$
	private static final String STACK = "stack"; //$NON-NLS-1$
	private static final String SEPARATOR = "separator"; //$NON-NLS-1$
	private static final String TEMPLATE = "template"; //$NON-NLS-1$
	private static final String TOOL = "tool"; //$NON-NLS-1$
	private static final int ENUM_DRAWER = 0;
	private static final int ENUM_STACK = 1;
	private static final int ENUM_SEPARATOR = 2;
	private static final int ENUM_TEMPLATE = 3;
	private static final int ENUM_TOOL = 4;

	/** palette entry permission enumeration */
	private static final String NONE = "None"; //$NON-NLS-1$
	private static final String HIDEONLY = "HideOnly"; //$NON-NLS-1$
	private static final String LIMITED = "limited"; //$NON-NLS-1$
	private static final String FULL = "full"; //$NON-NLS-1$

	/**
	 * A descriptor for XML-based palette contribution
	 */
	private static class ContributionDescriptor {

		private PaletteFactoryProxy paletteFactory;
		private List entries = new ArrayList();

		/**
		 * Reads XML entries for a contribution 
		 * @@param configElement
		 */
		public ContributionDescriptor(IConfigurationElement configElement) {
			paletteFactory = new PaletteFactoryProxy(configElement);

			// read the palette entries
			IConfigurationElement configChildren[] =
				configElement.getChildren(ENTRY);

			for (int i = 0; i < configChildren.length; i++) {
				entries.add(new EntryDescriptor(configChildren[i]));
			}
d136 1
a136 1
		}
d138 1
a138 1
		/**
d148 10
a157 10
		public void contribute(Object content, PaletteRoot root, Map predefinedEntries) {
			Iterator iter = entries.iterator();
			while (iter.hasNext()) {
				((IEntryDescriptor) iter.next()).contribute(
					content,
					root,
					paletteFactory, predefinedEntries);
			}
		}
	}
d181 1
a181 1
	/**
d184 10
a193 10
	private static class EntryDescriptor implements IEntryDescriptor {
		private Integer kind;
		private String id;
		private String path;
		private String label;
		private String description;
		private Integer permission;
		private ImageDescriptor small_icon;
		private ImageDescriptor large_icon;
		private DrawerExpandHelper expandHelper;
d196 22
a217 22
		/**
		 * Reads an XML palette entry and its attributes
		 * @@param configElement
		 */
		public EntryDescriptor(IConfigurationElement configElement) {
			String kindStr = configElement.getAttribute(KIND);
			if (DRAWER.equals(kindStr))
				kind = new Integer(ENUM_DRAWER);
			else if (STACK.equals(kindStr))
				kind = new Integer(ENUM_STACK);
			else if (SEPARATOR.equals(kindStr))
				kind = new Integer(ENUM_SEPARATOR);
			else if (TEMPLATE.equals(kindStr))
				kind = new Integer(ENUM_TEMPLATE);
			else if (TOOL.equals(kindStr))
				kind = new Integer(ENUM_TOOL);
			else
				Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$

			id = configElement.getAttribute(ID);
			if (id == null)
				Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
d222 21
a242 21
			path = configElement.getAttribute(PATH);
			if (path == null && !defineOnly)
				Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "Path must be provided when contributing a palette entry"); //$NON-NLS-1$

			label = configElement.getAttribute(LABEL);
			if (label == null)
				label = DiagramUIMessages.PaletteEntry_DefaultLabel;

			description = configElement.getAttribute(DESCRIPTION);

			if (NONE.equals(kindStr))
				permission =
					new Integer(PaletteEntry.PERMISSION_NO_MODIFICATION);
			if (HIDEONLY.equals(kindStr))
				permission = new Integer(PaletteEntry.PERMISSION_HIDE_ONLY);
			if (LIMITED.equals(kindStr))
				permission =
					new Integer(PaletteEntry.PERMISSION_LIMITED_MODIFICATION);
			if (FULL.equals(kindStr))
				permission =
					new Integer(PaletteEntry.PERMISSION_FULL_MODIFICATION);
d244 1
a244 1
			String smallIconPath = configElement.getAttribute(SMALL_ICON);
d250 9
a258 9
			if (kind.intValue() == ENUM_DRAWER) {
				IConfigurationElement[] configChildren =
					configElement.getChildren(EXPAND);
				if (configChildren.length > 0)
					expandHelper = new DrawerExpandHelper(configChildren[0]);
				else
					expandHelper = new DrawerExpandHelper(Boolean.FALSE);
			}
		}
d272 1
a272 1
                	URL fullPathString = FileLocator.find(bundle, new Path(iconPath), null);
d275 2
a276 2
                		return ImageDescriptor.createFromURL(fullPathString);
                	}
d291 8
a298 41
		public void contribute(
			Object content,
			PaletteRoot root,
			PaletteFactoryProxy paletteFactory, Map predefinedEntries) {
			if (kind == null || id == null || label == null)
				return;

			PaletteEntry paletteEntry = null;

			switch (kind.intValue()) {
				case ENUM_DRAWER :
					PaletteDrawer drawer = new PaletteDrawer(id, label);
					if (expandHelper.expand(content))
						drawer.setInitialState(
							PaletteDrawer.INITIAL_STATE_OPEN);
					paletteEntry = drawer;
					break;
				case ENUM_STACK:
					paletteEntry = new PaletteStack(id, label, description,
						small_icon);
					break;
				case ENUM_SEPARATOR :
					paletteEntry = new PaletteSeparator(id);
					break;
				case ENUM_TEMPLATE :
					paletteEntry =
						new PaletteTemplateEntry(id, label, paletteFactory);
					break;
				case ENUM_TOOL :
					paletteEntry =
						new PaletteToolEntry(id, label, paletteFactory);
					break;
			}

			if (paletteEntry != null) {
				paletteEntry.setDescription(description);
				paletteEntry.setSmallIcon(small_icon);
				paletteEntry.setLargeIcon(large_icon);
				if (permission != null)
					paletteEntry.setUserModificationPermission(
						permission.intValue());
d300 34
a333 1
				if (defineOnly) {
d336 1
a336 1
            		appendPaletteEntry(root, predefinedEntries, path, paletteEntry);
d338 2
a339 2
			}
		}
d341 1
a341 1
	}
d387 2
a388 1
            PaletteEntry paletteEntry = findPredefinedEntry(predefinedEntries, id);
d391 23
a413 3
                // this entry has been predefined but not contributed,
                // contributethis entry to the palette now
                if (path != null && !remove) {
d416 7
a423 7
            } else {
                paletteEntry = findPaletteEntry(root, id);
            }
            
            if (remove) {
                paletteEntry.getParent().remove(paletteEntry);
                return;
a424 7

            // Set expand state on drawers.
            if (paletteEntry instanceof PaletteDrawer
                && expandHelper.expand(content)) {
                ((PaletteDrawer) paletteEntry)
                    .setInitialState(PaletteDrawer.INITIAL_STATE_OPEN);
            }    
d542 144
a685 144
	/**
	 * A proxy for a palette factory that instantiates the real factory
	 * on demand (when a palette entry is selcted)
	 */
	private static class PaletteFactoryProxy extends PaletteFactory.Adapter {

		private IConfigurationElement configElement;
		private PaletteFactory factory;

		public PaletteFactoryProxy(IConfigurationElement configElement) {
			this.configElement = configElement;
		}

		/**
		 * @@see org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteFactory#getTemplate(java.lang.String)
		 */
		public Object getTemplate(String templateId) {
			if (factory == null) {
				try {
					Object ext =
						configElement.createExecutableExtension(FACTORY_CLASS);
					factory = (PaletteFactory) ext;
				} catch (CoreException e) {
					Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$					 
				}
			}
			if (factory != null) {
				Object template = factory.getTemplate(templateId);
				if (template == null)
					Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
				return template;
			}
			return null;
		}

		/**
		 * @@see org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteFactory#createTool(java.lang.String)
		 */
		public Tool createTool(String toolId) {
			if (factory == null) {
				try {
					Object ext =
						configElement.createExecutableExtension(FACTORY_CLASS);
					factory = (PaletteFactory) ext;
				} catch (CoreException e) {
					Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$					 
				}
			}
			if (factory != null) {
				Tool tool = factory.createTool(toolId);
				if (tool == null)
					Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
				return tool;
			}
			return null;
		}
	}

	/**
	 * A helper class in expanding palette drawer. It reads
	 * the relavent XML entries for that.
	 */
	private static class DrawerExpandHelper {

		private Boolean force;
		private ObjectDescriptor content;

		/**
		 * Initialize the helper with a foced value
		 * @@param force
		 */
		public DrawerExpandHelper(Boolean force) {
			this.force = force;
		}

		/**
		 * Initialize the helper from the config element in the XML
		 * @@param configElement
		 */
		public DrawerExpandHelper(IConfigurationElement configElement) {
			String forceStr = configElement.getAttribute(FORCE);
			force =
				forceStr == null ? Boolean.FALSE : Boolean.valueOf(forceStr);

			IConfigurationElement[] configChildren =
				configElement.getChildren(CONTENT);
			if (configChildren.length > 0)
				content = new ObjectDescriptor(configChildren[0]);
		}

		/**
		 * Determines whether to initially expand the palette drawer
		 * @@param targetContent
		 * @@return
		 */
		public boolean expand(Object targetContent) {
			if (force == Boolean.TRUE)
				return true;
			if (content != null && content.sameAs(targetContent))
				return true;
			return false;
		}
	}

	/**
	 * The list of palette provider XML contributions
	 */
	private List contributions = new ArrayList();

	/**
	 * 
	 * Adds the configuration elements to the 
	 * list of palette provider XML contributions 
	 * 
	 * @@param configElement
	 */
	public void setContributions(IConfigurationElement configElement) {
		IConfigurationElement configChildren[] =
			configElement.getChildren(CONTRIBUTION);

		for (int i = 0; i < configChildren.length; i++) {
			contributions.add(new ContributionDescriptor(configChildren[i]));
		}
	}

	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.palette.IPaletteProvider#contributeToPalette(org.eclipse.ui.IEditorPart, java.lang.Object)
	 */
	public void contributeToPalette(
		IEditorPart editor,
		Object content,
		PaletteRoot root, Map predefinedEntries) {
		Iterator iter = contributions.iterator();
		while (iter.hasNext()) {
			((ContributionDescriptor) iter.next()).contribute(content, root, predefinedEntries);
		}
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.service.IProvider#provides(org.eclipse.gmf.runtime.common.core.service.IOperation)
	 */
	public boolean provides(IOperation operation) {
		return false; // all logic is done in the service
	}
@


1.7
log
@Bugzilla#111907 gmf_head cmahoney 060329 Support Separation of Palette Definition and Contribution
@
text
@a37 1
import org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.IPaletteProvider;
d43 1
d654 1
a654 1
	 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.services.palette.IPaletteProvider#contributeToPalette(org.eclipse.ui.IEditorPart, java.lang.Object)
@


1.6
log
@bugzilla 129421 gmf-head sshaw 060227 URL in paletteProviders extension point are not getting resolved correctly
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
d19 1
d85 3
d129 7
d139 10
a148 5
		 * Contributes to the given palette root based on the given editor's content 
		 * @@param content
		 * @@param root
		 */
		public void contribute(Object content, PaletteRoot root) {
d151 1
a151 1
				((EntryDescriptor) iter.next()).contribute(
d154 1
a154 1
					paletteFactory);
d158 22
d182 3
a184 3
	 * A descriptor for an XML-based palette entry 
	 */
	private static class EntryDescriptor {
d194 1
d219 3
d223 2
a224 2
			if (path == null)
				Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
a290 7
		/**
		 * Contributes the palette entry based on the given content, starting
		 * from the given root and into the given path
		 * @@param content
		 * @@param root
		 * @@param paletteFactory
		 */
d294 2
a295 2
			PaletteFactoryProxy paletteFactory) {
			if (kind == null || id == null || path == null || label == null)
d333 5
a337 11
				PaletteEntry fEntry = findPaletteEntry(root, path);
				if (fEntry == null)
					Log.info(DiagramProvidersPlugin.getInstance(), DiagramProvidersStatusCodes.SERVICE_FAILURE, "Invalid palette entry path"); //$NON-NLS-1$				
				else if (fEntry instanceof PaletteContainer)
					 ((PaletteContainer) fEntry).add(paletteEntry);
				else if (fEntry instanceof PaletteSeparator)
					appendTo((PaletteSeparator) fEntry, paletteEntry);
				else
					fEntry.getParent().add(
						fEntry.getParent().getChildren().indexOf(fEntry) + 1,
						paletteEntry);
d341 72
a412 20
		/**
		 * Finds a palette container starting from the given root
		 * and using the given path
		 * @@param root
		 * @@param aPath
		 * @@return the container or <code>null</code> if not found
		 */
		private PaletteEntry findPaletteEntry(PaletteEntry root, String aPath) {
			StringTokenizer tokens = new StringTokenizer(aPath, "/"); //$NON-NLS-1$
			while (tokens.hasMoreElements()) {
				if (root instanceof PaletteContainer)
					root =
						findChildPaletteEntry(
							(PaletteContainer) root,
							tokens.nextToken());
				else
					return null;
			}
			return root;
		}
d414 49
a462 18
		/**
		 * Finds a palette entry starting from the given container
		 * and using the given path
		 * @@param root
		 * @@param path
		 * @@return the entry or <code>null</code> if not found
		 */
		private PaletteEntry findChildPaletteEntry(
			PaletteContainer container,
			String childId) {
			Iterator entries = container.getChildren().iterator();
			while (entries.hasNext()) {
				PaletteEntry entry = (PaletteEntry) entries.next();
				if (entry.getId().equals(childId))
					return entry;
			}
			return null;
		}
d464 63
a526 15
		/**
		 * Appends the given entry to the end of the group of the given separator
		 * @@param separator
		 * @@param entry
		 */
		private void appendTo(PaletteSeparator separator, PaletteEntry entry) {
			List children = separator.getParent().getChildren();
			int index = children.indexOf(separator);
			for (index++; index < children.size(); index++) {
				if (children.get(index) instanceof PaletteSeparator)
					break;
			}
			separator.getParent().add(index, entry);
		}
	}
d659 1
a659 1
		PaletteRoot root) {
d662 1
a662 1
			((ContributionDescriptor) iter.next()).contribute(content, root);
d672 1
a672 1

@


1.5
log
@bugzilla 117592 gmf-head mmostafa 060207 Eroneous references to xtools in diagram plugins
@
text
@d14 1
d21 1
d33 4
a189 1
//			String permissionStr = configElement.getAttribute(PERMISSION);
a201 3
			String pluginId = configElement.getDeclaringExtension().getNamespace();
			Bundle bundle = Platform.getBundle(pluginId);

d203 4
a206 16
			if (smallIconPath != null) {
				URL fullPathString =
					Platform.find(bundle, new Path(smallIconPath));
				if (fullPathString != null) {
					small_icon = ImageDescriptor.createFromURL(fullPathString);
				}
			}

			String largeIconPath = configElement.getAttribute(LARGE_ICON);
			if (largeIconPath != null) {
				URL fullPathString =
					Platform.find(bundle, new Path(largeIconPath));
				if (fullPathString != null) {
					large_icon = ImageDescriptor.createFromURL(fullPathString);
				}
			}
d218 31
@


1.4
log
@[112794] gmf_head etworkowska 060126 Adopt ICU4J as part of Eclipse 3.2
@
text
@d485 2
a486 2
	/**
	 * @@see com.ibm.xtools.common.service.IProvider#provides(IOperation)
@


1.3
log
@Bugzilla#123313 gmf_head cmahoney 060120 Making DiagramUIPlugin, DiagramUIStatusCodes, and DiagramUIDebugOptions internal
@
text
@a17 1
import java.util.StringTokenizer;
d45 2
@


1.2
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@a31 2
import org.eclipse.gmf.runtime.diagram.ui.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.DiagramUIStatusCodes;
d36 2
d167 1
a167 1
				Log.info(DiagramUIPlugin.getInstance(), DiagramUIStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
d171 1
a171 1
				Log.info(DiagramUIPlugin.getInstance(), DiagramUIStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
d175 1
a175 1
				Log.info(DiagramUIPlugin.getInstance(), DiagramUIStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
d278 1
a278 1
					Log.info(DiagramUIPlugin.getInstance(), DiagramUIStatusCodes.SERVICE_FAILURE, "Invalid palette entry path"); //$NON-NLS-1$				
d369 1
a369 1
					Log.info(DiagramUIPlugin.getInstance(), DiagramUIStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$					 
d375 1
a375 1
					Log.info(DiagramUIPlugin.getInstance(), DiagramUIStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
d391 1
a391 1
					Log.info(DiagramUIPlugin.getInstance(), DiagramUIStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$					 
d397 1
a397 1
					Log.info(DiagramUIPlugin.getInstance(), DiagramUIStatusCodes.SERVICE_FAILURE, "No factory class name is provided"); //$NON-NLS-1$
@


1.1
log
@Bugzilla#115827 gmf_head cmahoney 051121 DefaultPaletteProvider should be made public
@
text
@a27 4
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.ui.IEditorPart;
import org.osgi.framework.Bundle;

d37 1
a37 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d42 3
a95 3
	/** default palette entry label */
	private static final String DEFAULT_ENTRY_LABEL = "PaletteEntry.DefaultLabel"; //$NON-NLS-1$

d179 1
a179 1
				label = DiagramResourceManager.getI18NString(DEFAULT_ENTRY_LABEL);
@

