head	1.6;
access;
symbols
	v20081020-0700:1.6
	v20080924-1925:1.6
	v20080917-1925:1.6
	v20080916-2008:1.6
	v20080911-1728:1.6
	v20080722-1827:1.6
	v20080716-1600:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.6.0.2
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080503-1740:1.6
	v20080425-1959:1.6
	v20080417-1610:1.6
	v20080407-2250:1.6
	v20080407-0930:1.6
	v20080404-1111:1.6
	v20080328-1605:1.5
	v20080222-1200:1.5
	v20080215-1500:1.5
	v20080201-2010:1.4
	v20080201-0201:1.3
	v20071130-1111:1.4
	v20071108-0000:1.3
	v20070903-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.4
	R2_0:1.3
	R4_20:1.3
	v20070621-0000:1.3
	RC3_20:1.3
	v20070601-1400:1.3
	v20070518-1300:1.3
	bugzilla111892_group_support:1.3.0.2
	Root_bugzilla111892_group_support:1.3
	v20070504-1000:1.3
	v20070420-1000:1.3
	v20070413-1300:1.3
	v20070330-1300:1.3
	v20060316-0600:1.3
	v20070228-2000:1.3
	v20070221-1500:1.3
	v20070208-1800:1.3
	M4_20:1.3
	v20061218-1500:1.2.2.1
	v20061214-0000:1.3
	M3_20:1.3
	v20061013-1330:1.3
	v20060919-0800:1.2.2.1
	M1_20:1.2
	v20060803-1200:1.2.2.1
	v20060728-0500:1.2
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060530-1930:1.2
	v20060519-0800:1.2
	I20060428-1300:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1;
locks; strict;
comment	@# @;


1.6
date	2008.04.03.16.30.09;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	3e0047f506114567;

1.5
date	2008.02.04.21.03.02;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	50da47a77d854567;

1.4
date	2007.11.21.17.57.25;	author crevells;	state Exp;
branches;
next	1.3;
commitid	49d9474471844567;

1.3
date	2006.10.03.15.03.01;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.03.17.20.01;	author mmostafa;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.02.24.23.29.50;	author mmostafa;	state Exp;
branches;
next	;

1.2.2.1
date	2006.08.01.18.18.17;	author mmostafa;	state Exp;
branches;
next	;


desc
@@


1.6
log
@[225437] gmf_head aboyko 080403 Layout improvements
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.providers.internal;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Insets;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.draw2d.graph.CompoundDirectedGraph;
import org.eclipse.draw2d.graph.DirectedGraph;
import org.eclipse.draw2d.graph.DirectedGraphLayout;
import org.eclipse.draw2d.graph.Edge;
import org.eclipse.draw2d.graph.Node;
import org.eclipse.draw2d.graph.NodeList;
import org.eclipse.draw2d.graph.Subgraph;
import org.eclipse.gef.ConnectionEditPart;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gmf.runtime.diagram.ui.editparts.CompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GroupEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeCompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;
import org.eclipse.gmf.runtime.draw2d.ui.graph.ConstantSizeNode;
import org.eclipse.gmf.runtime.draw2d.ui.internal.graph.AdvancedSubGraph;
import org.eclipse.gmf.runtime.draw2d.ui.internal.graph.CompositeDirectedGraphLayout;
import org.eclipse.gmf.runtime.draw2d.ui.internal.graph.VirtualNode;
import org.eclipse.gmf.runtime.notation.LayoutConstraint;
import org.eclipse.gmf.runtime.notation.Size;
import org.eclipse.gmf.runtime.notation.View;

/**
 * Provider that creates a command for the CompoundDirectedGraph layout in GEF.
 * 
 * @@author mmostafa
 * @@canBeSeenBy org.eclipse.gmf.runtime.diagram.ui.providers.*
 * 
 */

public abstract class CompositeLayoutProvider
    extends DefaultProvider {
    
    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#build_nodes(java.util.List, java.util.Map, org.eclipse.draw2d.graph.Subgraph)
     */
    protected NodeList build_nodes(List selectedObjects,
            Map editPartToNodeDict, Subgraph rootGraph) {
        ListIterator li = selectedObjects.listIterator();
        NodeList nodes = new NodeList();
        while (li.hasNext()) {
            IGraphicalEditPart gep = (IGraphicalEditPart) li.next();
            boolean hasChildren = hasChildren(gep);
            if (!(gep instanceof IBorderItemEditPart)
                && (gep instanceof ShapeEditPart || gep instanceof ShapeCompartmentEditPart)) {
                GraphicalEditPart ep = (GraphicalEditPart) gep;
                Point position = ep.getFigure().getBounds().getLocation();
                if (minX == -1) {
                    minX = position.x;
                    minY = position.y;
                } else {
                    minX = Math.min(minX, position.x);
                    minY = Math.min(minY, position.y);
                }
                Node n = null;
                if (hasChildren && !(gep instanceof GroupEditPart)) {
                    AdvancedSubGraph subGraph = null;
                    if (rootGraph != null)
                        subGraph = new AdvancedSubGraph(ep, rootGraph);
                    else
                        subGraph = new AdvancedSubGraph(ep);
                    subGraph.setAutoSize(isAutoSizeOn(subGraph,ep));
                    if (gep instanceof CompartmentEditPart){
                        subGraph.setHasBufferedZone(true);
                    }
                    subGraph.setDirection(getLayoutDirection(ep));
                    n = subGraph;
                } else {
                    if (rootGraph != null)
                        n = new ConstantSizeNode(ep, rootGraph);
                    else
                        n = new ConstantSizeNode(ep);
                }
                adjustNodePadding(n, editPartToNodeDict);
                Dimension size = ep.getFigure().getBounds().getSize();
                setNodeMetrics(n, new Rectangle(position.x, position.y,
                    size.width, size.height));
                editPartToNodeDict.put(ep, n);
                nodes.add(n);
                if (hasChildren && !(gep instanceof GroupEditPart)) {
                    build_nodes(gep.getChildren(), editPartToNodeDict,
                        (Subgraph) n);
                }
                if (n instanceof ConstantSizeNode) {
                    build_borderNodes(gep, (ConstantSizeNode)n, editPartToNodeDict);                	
                }
            }
        }
        return nodes;
    }
    
    /**
     * Gets the layout direction for an editpart. Every editpart mapped to 
     * <code>AdvancedSubGraph</code> will be asked for its desired layout direction
     * such that children of the subgraph are laid out accordingly to that direction.
     * 
     * @@param ep the editpart
     */
    protected int getLayoutDirection(GraphicalEditPart ep) {
    	return PositionConstants.SOUTH;
    }

    private boolean isAutoSizeOn(AdvancedSubGraph subGraph, IGraphicalEditPart gEP) {
        if (gEP instanceof CompartmentEditPart && subGraph.getParent() instanceof AdvancedSubGraph){
            if (((AdvancedSubGraph)subGraph.getParent()).isAutoSize())
                return true;
        }else {
            View notationView = gEP.getNotationView();
            if (notationView !=null && notationView instanceof org.eclipse.gmf.runtime.notation.Node){
                org.eclipse.gmf.runtime.notation.Node node = (org.eclipse.gmf.runtime.notation.Node)notationView;
                LayoutConstraint contraint = node.getLayoutConstraint();
                if (contraint instanceof Size){
                    Size size = (Size)contraint;
                    if (size.getHeight() != -1 || size.getWidth()!=-1){
                        return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#createGraphLayout()
     */
    protected DirectedGraphLayout createGraphLayout() {
        return new CompositeDirectedGraphLayout();
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#createNodeChangeBoundCommands(org.eclipse.draw2d.graph.DirectedGraph, org.eclipse.draw2d.geometry.Point)
     */
    protected Command createNodeChangeBoundCommands(DirectedGraph g, Point diff) {
        CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
        NodeList list = new NodeList();
        NodeList subGraphs = ((CompoundDirectedGraph) g).nodes;
        list.addAll(subGraphs);
        for (Iterator iter = subGraphs.iterator(); iter.hasNext();) {
            Node element = (Node) iter.next();
            if (element instanceof Subgraph)
                list.addAll(getAllMembers((Subgraph) element));
        }
        createSubCommands(diff, list.listIterator(), cc);
        if (cc.isEmpty())
            return null;
        return cc;
    }

    private Collection getAllMembers(Subgraph element) {
        NodeList list = new NodeList();
        list.addAll(element.members);
        for (Iterator iter = element.members.iterator(); iter.hasNext();) {
            Node node = (Node) iter.next();
            if (node instanceof Subgraph)
                list.addAll(getAllMembers((Subgraph) node));
        }
        return list;
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#getNodeMetrics(org.eclipse.draw2d.graph.Node)
     */
    protected Rectangle getNodeMetrics(Node n) {
        Rectangle rect = null;
        if (n.getParent() instanceof VirtualNode) {
            Node parent = n.getParent();
            rect = new Rectangle(n.x + parent.x, n.y + parent.y, n.width,
                n.height);
        } else
            rect = new Rectangle(n.x, n.y, n.width, n.height);
        return translateFromGraph(rect);
    }
    
    protected void postProcessGraph(DirectedGraph g, Hashtable editPartToNodeDict) {
        //default do nothing
    }
    
    /**
     * @@param gep
     * @@return
     */
    protected boolean hasChildren(IGraphicalEditPart gep) {
        List children = gep.getChildren();
        boolean hasChildren = false;
        if (!children.isEmpty()){
            for (Iterator iter = children.iterator(); iter.hasNext() && !hasChildren;) {
                Object element = iter.next();
                if (!(element instanceof IBorderItemEditPart) &&
                        ( element instanceof ShapeEditPart ||
                          element instanceof ShapeCompartmentEditPart)){
                    hasChildren = true;
                }else
                    hasChildren = hasChildren((IGraphicalEditPart)element);
            }
        }
        return hasChildren;
    }
    
    /**
     * this method will adjust the passed node Padding; the default implementatio 
     * will use a fixed Padding then it will consider adding extra Padding if the 
     * node parent is not a direct parent
     * clients can override this method to change the behaviour
     * @@param node the node to adust the padding for
     */
    protected void adjustNodePadding(Node node,Map editPartToNodeDict) {
        Insets padding  = new Insets(getMapMode().DPtoLP(NODE_PADDING));
        GraphicalEditPart ep = (GraphicalEditPart)node.data;
        // check if the direct parent is added already to the graph
        GraphicalEditPart parent = (GraphicalEditPart)ep.getParent();
        if (parent != null &&
            node.getParent() != null &&
            editPartToNodeDict.get(parent)!=node.getParent()){
            // now the direct parent is not added to the graph so, we had 
            // to adjust the padding of the node to consider the parent
            IFigure thisFigure = parent.getFigure();
            IFigure parentFigure = ((GraphicalEditPart)node.getParent().data).getFigure();
            Point parentLocation = parentFigure.getBounds().getLocation();
            Point nodeLocation = thisFigure.getBounds().getLocation();
            thisFigure.translateToAbsolute(nodeLocation);
            parentFigure.translateToAbsolute(parentLocation);
            Dimension delta = nodeLocation.getDifference(parentLocation);
            Rectangle rect = translateToGraph(new Rectangle(delta.width , delta.height , 0 , 0));
            padding.top  += rect.y ;
            padding.left += rect.x;
        }
        node.setPadding(padding);
        if (node instanceof ConstantSizeNode) {
        	ConstantSizeNode cn = (ConstantSizeNode) node;
            cn.setMinIncomingPadding(getMapMode().DPtoLP(MIN_EDGE_END_POINTS_PADDING));
            cn.setMinOutgoingPadding(getMapMode().DPtoLP(MIN_EDGE_END_POINTS_PADDING));
        }
    }

    
    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#createGraph()
     */
    protected DirectedGraph createGraph(){
        return new CompoundDirectedGraph();
    }
    
    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#shouldHandleConnectableListItems()
     */
    protected boolean shouldHandleConnectableListItems() {
        return true;
    }

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#routeThrough(org.eclipse.draw2d.graph.Edge, org.eclipse.gef.ConnectionEditPart, org.eclipse.draw2d.graph.Node, org.eclipse.draw2d.graph.Node, org.eclipse.draw2d.geometry.PointList, org.eclipse.draw2d.geometry.Point)
	 */
	protected Command routeThrough(Edge edge, ConnectionEditPart connectEP,
			Node source, Node target, PointList points, Point diff) {
		Node parent = source.getParent();
		if (parent == null) {
			parent = target.getParent();
		}
		if (parent != null) {
			Point parentLocation = getNodeMetrics(parent).getLocation();
			points.translate(parentLocation.x, parentLocation.y);
		}
		return super
				.routeThrough(edge, connectEP, source, target, points, diff);
	}
	
}
@


1.5
log
@[217749] gmf_head aboyko 080204 [Layout] Layout providers using Draw2D graph layout don't deliver the exact results to the diagram
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
d22 1
d45 1
d96 1
d100 1
a100 1
                        n = new Node(ep, rootGraph);
d102 1
a102 1
                        n = new Node(ep);
d114 3
d121 11
d238 1
a238 1
        Insets padding  = new Insets(NODE_PADDING);
d259 5
d281 3
d285 1
a285 1
			Node source, Node target, PointList points, int diffX, int diffY) {
d295 1
a295 1
				.routeThrough(edge, connectEP, source, target, points, diffX, diffY);
d297 1
a297 1

@


1.4
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@d25 1
d30 1
d34 1
d259 14
a272 1
   
@


1.3
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
d36 1
d81 1
a81 1
                if (hasChildren) {
d104 1
a104 1
                if (hasChildren) {
@


1.2
log
@gmf-head mmostafa 060403 adding support for the connected list items to the default layout provider
@
text
@d34 1
d40 1
d43 3
d81 1
d83 1
a83 1
                        n = new Subgraph(ep, rootGraph);
d85 6
a90 1
                        n = new Subgraph(ep);
d112 21
@


1.2.2.1
log
@[130329] gmf_R1_0_maintenance mmostafa  060801 CompositeLayoutProvider: auto-sized containers new size doesn't get considered
@
text
@a33 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.CompartmentEditPart;
a38 1
import org.eclipse.gmf.runtime.draw2d.ui.internal.graph.AdvancedSubGraph;
a40 3
import org.eclipse.gmf.runtime.notation.LayoutConstraint;
import org.eclipse.gmf.runtime.notation.Size;
import org.eclipse.gmf.runtime.notation.View;
a75 1
                    AdvancedSubGraph subGraph = null;
d77 1
a77 1
                        subGraph = new AdvancedSubGraph(ep, rootGraph);
d79 1
a79 6
                        subGraph = new AdvancedSubGraph(ep);
                    subGraph.setAutoSize(isAutoSizeOn(subGraph,ep));
                    if (gep instanceof CompartmentEditPart){
                        subGraph.setHasBufferedZone(true);
                    }
                    n = subGraph;
a100 21
    private boolean isAutoSizeOn(AdvancedSubGraph subGraph, IGraphicalEditPart gEP) {
        if (gEP instanceof CompartmentEditPart && subGraph.getParent() instanceof AdvancedSubGraph){
            if (((AdvancedSubGraph)subGraph.getParent()).isAutoSize())
                return true;
        }else {
            View notationView = gEP.getNotationView();
            if (notationView !=null && notationView instanceof org.eclipse.gmf.runtime.notation.Node){
                org.eclipse.gmf.runtime.notation.Node node = (org.eclipse.gmf.runtime.notation.Node)notationView;
                LayoutConstraint contraint = node.getLayoutConstraint();
                if (contraint instanceof Size){
                    Size size = (Size)contraint;
                    if (size.getHeight() != -1 || size.getWidth()!=-1){
                        return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }

@


1.1
log
@bugzilla 110698 gmf-head mmostafa 060224 Auto-layout doesn't layout out connections between nested nodes and top level nodes
@
text
@d215 7
@

