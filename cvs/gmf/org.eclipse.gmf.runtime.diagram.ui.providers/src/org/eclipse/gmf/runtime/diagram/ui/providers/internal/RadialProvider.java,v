head	1.14;
access;
symbols
	v20081020-0700:1.14
	v20080924-1925:1.14
	v20080917-1925:1.14
	v20080916-2008:1.14
	v20080911-1728:1.14
	v20080722-1827:1.14
	v20080716-1600:1.14
	v20080716-1642:1.14
	R2_1_maintenance:1.14.0.2
	Root_R2_1_maintenance:1.14
	R2_1_0:1.14
	v20080503-1740:1.14
	v20080425-1959:1.14
	v20080417-1610:1.14
	v20080407-2250:1.14
	v20080407-0930:1.13
	v20080404-1111:1.13
	v20080328-1605:1.13
	v20080222-1200:1.13
	v20080215-1500:1.13
	v20080201-2010:1.13
	v20080201-0201:1.13
	v20071130-1111:1.13
	v20071108-0000:1.13
	v20070903-0000:1.13
	v20070809-0000:1.13
	R2_0_maintenance:1.13.0.6
	R2_0:1.13
	R4_20:1.13
	v20070621-0000:1.13
	RC3_20:1.13
	v20070601-1400:1.13
	v20070518-1300:1.13
	bugzilla111892_group_support:1.13.0.4
	Root_bugzilla111892_group_support:1.13
	v20070504-1000:1.13
	v20070420-1000:1.13
	v20070413-1300:1.13
	v20070330-1300:1.13
	v20060316-0600:1.13
	v20070228-2000:1.13
	v20070221-1500:1.13
	v20070208-1800:1.13
	M4_20:1.13
	v20061218-1500:1.13
	v20061214-0000:1.13
	M3_20:1.13
	v20061013-1330:1.13
	v20060919-0800:1.13
	M1_20:1.13
	v20060803-1200:1.13
	v20060728-0500:1.13
	v20060721-1130:1.13
	v20060713-1700:1.13
	R1_0_maintenance:1.13.0.2
	R1_0:1.13
	v20060627-1200:1.13
	v20060616-1200:1.13
	v20060609-1400:1.12
	v20060531-1730:1.12
	v20060530-1930:1.12
	v20060519-0800:1.12
	I20060428-1300:1.12
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.12
	I20060407-1200:1.12
	I20060331-1000:1.12
	I20060324-0300:1.12
	I20060317-1300:1.12
	I20060317-1200:1.12
	I20060316-1300:1.12
	I20060309-1300:1.12
	M5_10:1.12
	S20060303-1600:1.12
	I20060227-1730:1.12
	I20060216-1945:1.12
	I20060210-1715:1.11
	I20060209-1815:1.11
	I20060203-0830:1.10
	I20060202-1415:1.10
	I20060129-1145:1.10
	I20060127-0900:1.10
	I20060120-1530:1.10
	I20060113-1700:1.10
	M4_10:1.10
	I20060107-1100:1.10
	I20060105-1630:1.10
	I20051230-1230:1.10
	I20051223-1100:1.10
	I20051201-1800:1.10
	I20051124-2000:1.9
	M3_10:1.8
	I20051118-1245:1.8
	I20051111-1800:1.8
	I20051106-0900:1.8
	v20051030:1.6;
locks; strict;
comment	@# @;


1.14
date	2008.04.08.02.16.29;	author ahunter;	state Exp;
branches;
next	1.13;
commitid	4c9c47fad57b4567;

1.13
date	2006.06.14.18.40.06;	author ahunter;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.13.19.10.50;	author ldamus;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.07.15.19.01;	author mmostafa;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.25.19.37.44;	author cmahoney;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.24.22.20.58;	author sshaw;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.04.21.28.09;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.02.23.30.53;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.14.20.58.43;	author mmostafa;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.14.19.37.53;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.22.15.42.27;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.26.25;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.03;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.45;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.14
log
@[226065] gmf-head ahunter 080407 Fix warning: The type Assert is deprecated
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.providers.internal;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.Request;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.service.IOperation;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.internal.commands.IPropertyValueDeferred;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.actions.internal.DiagramActionsDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ConnectionNodeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
import org.eclipse.gmf.runtime.diagram.ui.internal.requests.ChangeBoundsDeferredRequest;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.LayoutNodesOperation;
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.l10n.DiagramUIProvidersMessages;
import org.eclipse.gmf.runtime.diagram.ui.requests.ArrangeRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.ChangePropertyValueRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants;
import org.eclipse.gmf.runtime.diagram.ui.requests.SetAllBendpointRequest;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutEditPartProvider;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutType;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand;
import org.eclipse.gmf.runtime.notation.FontStyle;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.View;

/**
 * @@author sshaw
 * @@canBeSeenBy org.eclipse.gmf.runtime.diagram.ui.providers.*
 * 
 * RadialProvider class that provides for LayoutType.RADIAL.
 */
public class RadialProvider
	extends AbstractLayoutEditPartProvider {

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.service.IProvider#provides(org.eclipse.gmf.runtime.common.core.service.IOperation)
	 */
	public boolean provides(IOperation operation) {
		Assert.isNotNull(operation);

		View cview = getContainer(operation);
		if (cview == null)
			return false;
		
		IAdaptable layoutHint = ((LayoutNodesOperation) operation).getLayoutHint(); 
		String layoutType = (String) layoutHint.getAdapter(String.class);
		return LayoutType.RADIAL.equals(layoutType);		
	} 

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutEditPartProvider#layoutEditParts(org.eclipse.gef.GraphicalEditPart, org.eclipse.core.runtime.IAdaptable)
	 */
	public Command layoutEditParts(
		GraphicalEditPart containerEP,
		IAdaptable layoutHint) {

		List children = containerEP.getChildren();
		return layout(containerEP, children, findRootView(children), layoutHint);
	}

	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutEditPartProvider#layoutEditParts(java.util.List, org.eclipse.core.runtime.IAdaptable)
	 */
	public Command layoutEditParts(
		List selectedObjects,
		IAdaptable layoutHint) {

		if (selectedObjects.size()== 0){
			return null;
		}
		
		GraphicalEditPart editPart = (GraphicalEditPart) selectedObjects.get(0);		
		GraphicalEditPart containerEditPart = (GraphicalEditPart) editPart.getParent();
		
		return layout(containerEditPart, selectedObjects, findRootView(selectedObjects), layoutHint);
	}

	/**
	 * Method layout.
	 * 
	 * @@param layoutType
	 * @@param containerEP
	 * @@param selectedObjects
	 * @@param rootEP
	 * @@return Command
	 * @@throws InvalidParameterException
	 *             if either parameter is null.
	 */
	public Command layout(
		GraphicalEditPart containerEP,
		List selectedObjects,
		ShapeEditPart rootEditPart,
		IAdaptable layoutHint) {

		if (containerEP == null || selectedObjects == null) {
			InvalidParameterException ipe = new InvalidParameterException();
			Trace.throwing(DiagramProvidersPlugin.getInstance(), DiagramActionsDebugOptions.EXCEPTIONS_THROWING, getClass(), "layout()", //$NON-NLS-1$
			ipe);
			throw ipe;
		}

		if (rootEditPart == null)
			rootEditPart = findRootView(selectedObjects);

		List parts = new ArrayList(selectedObjects.size());

		// Only add IShapeView to the master list
		ListIterator li = selectedObjects.listIterator();
		while (li.hasNext()) {
			EditPart ep = (EditPart) li.next();
			if (!ep.equals(rootEditPart)
				&& (ep instanceof ShapeEditPart
					|| ep instanceof ConnectionNodeEditPart)) {
				parts.add(ep);
			}
		}

		Command cmd = null;
		CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
		RadialLayout radialLayout =
			new RadialLayout(rootEditPart, parts, 0, Math.PI * 2, false);

		cmd = radialLayout.getPrelayoutCommand();
		if (cmd != null)
			cc.add(cmd);
		
		try {
			cmd = radialLayout.getCommand();
			parts.add(rootEditPart);
		} catch (LayoutEstheticsException e) {
			// since the Layout esthetics have been violated, use the default layout
			// instead.
			parts.add(rootEditPart);
			
			ArrangeRequest request = new ArrangeRequest(
				RequestConstants.REQ_ARRANGE_DEFERRED);
			request.setViewAdaptersToArrange(parts);
			cmd = containerEP.getCommand(request);
		}
		
		if (cmd != null)
			cc.add(cmd);
		
		Request req = new Request(RequestConstants.REQ_REFRESH);
		cmd = rootEditPart.getParent().getCommand(req);
		if (cmd != null)
			cc.add(cmd);
		
		// position the entire radial circle
		OffsetRadialPartsCommand orpc = new OffsetRadialPartsCommand(
            rootEditPart.getEditingDomain(), parts);
        cmd = new ICommandProxy(orpc);
		if (cmd != null)
			cc.add(cmd);
		
		return cc;
	}

	/**
	 * @@author sshaw
	 *
	 * Command to update the entire position of the Radial circle.
	 */
	static protected class OffsetRadialPartsCommand extends AbstractTransactionalCommand {
		private List editParts;
		private Rectangle origRect;
		
		/**
		 * @@param editParts
		 * @@param ptRoot
		 */
		public OffsetRadialPartsCommand(TransactionalEditingDomain editingDomain, List editParts) {
			super(editingDomain, "", null); //$NON-NLS-1$
			this.editParts = editParts;
			origRect = calcBoundBox();
		}
		
		protected CommandResult doExecuteWithResult(
                IProgressMonitor progressMonitor, IAdaptable info)
            throws ExecutionException {
            
			if (null == editParts)
				return CommandResult.newCancelledCommandResult();
			
			Rectangle radialRect = calcBoundBox();
			
			IGraphicalEditPart firstEP = (IGraphicalEditPart)editParts.get(0);
			IMapMode mm = MapModeUtil.getMapMode(firstEP.getFigure());
			
			// consider ideal location
			Rectangle newRadialRect = new Rectangle(radialRect);
			newRadialRect.translate( -radialRect.getTopLeft().x + mm.DPtoLP(50),
							 -radialRect.getTopLeft().y + mm.DPtoLP(50));
			
			if (origRect.x > newRadialRect.x && origRect.y > newRadialRect.y) {
				newRadialRect = new Rectangle( Math.max(newRadialRect.x, origRect.x - (radialRect.width / 2)), 
											   Math.max(newRadialRect.y, origRect.y - (radialRect.height / 2)), 
											radialRect.width, radialRect.height);
			}
			
			final Point translate = new Point(newRadialRect.getTopLeft().x - radialRect.getTopLeft().x,
										newRadialRect.getTopLeft().y - radialRect.getTopLeft().y);
			 
			ListIterator li = editParts.listIterator();
			while (li.hasNext()) {
				IGraphicalEditPart gep = (IGraphicalEditPart)li.next();
				View view = gep.getNotationView();
				if (view!=null){
					Integer pos = (Integer)ViewUtil.getStructuralFeatureValue(view,NotationPackage.eINSTANCE.getLocation_X());
					ViewUtil.setStructuralFeatureValue(view,NotationPackage.eINSTANCE.getLocation_X(), new Integer(pos.intValue() + translate.x));
					pos = (Integer)ViewUtil.getStructuralFeatureValue(view,NotationPackage.eINSTANCE.getLocation_Y());
					ViewUtil.setStructuralFeatureValue(view,NotationPackage.eINSTANCE.getLocation_Y(), new Integer(pos.intValue() + translate.y));
				}
			}
			
			// clear for garbage collection;
			editParts = null;
			return CommandResult.newOKCommandResult();
		}

		/**
		 * @@return
		 */
		private Rectangle calcBoundBox() {
			Rectangle radialRect = null;
			ListIterator li = editParts.listIterator();
			while (li.hasNext()) {
				IGraphicalEditPart gep = (IGraphicalEditPart)li.next();
				if (null == radialRect) {
					radialRect = new Rectangle(gep.getFigure().getBounds());
				}
				else {
					radialRect.union(gep.getFigure().getBounds());
				}
			}
			return null == radialRect ?  new Rectangle() : radialRect;
		}
	}
	
	/**
	 * Method findRootView. Given a list of views, calculate the root view that
	 * all other views are ultimately related to.
	 * 
	 * @@param views
	 *            List of editparts to determine the root view from.
	 * @@return ShapeEditPart shape editpart object that represents the root
	 *         view.
	 */
	protected ShapeEditPart findRootView(List editparts) {
		if (editparts == null)
			throw new InvalidParameterException();

		// TodoKit: I am sure we must find better ways to dig up the root of a
		// tree, for now I assume it to be
		// the first in the collection as I know it was the first view created.
		int count = editparts.size(); 
		if (count > 0) {
			EditPart ep = (EditPart) editparts.get(0);
			if (ep instanceof ShapeEditPart) {
				return (ShapeEditPart) editparts.remove(0);
			}
		}

		return null;
	}

	/**
	 * @@author sshaw
	 *
	 * Nested RuntimeException class thrown when the esthetics of the RadialLayout
	 * are violated.  i.e. when certain conditions are met that ensure that the RadialLayout
	 * will not look good.
	 */
	static protected class LayoutEstheticsException extends RuntimeException {
		
		/**
		 * 
		 */
		private static final long serialVersionUID = 3084395663087786098L;

		/**
		 * @@param message
		 */
		public LayoutEstheticsException(String message) {
			super(message);
		}
	}
	
	/**
	 * @@author sshaw
	 * 
	 * Helper class to build the radial layout based on a root editpart.
	 */
	static protected class RadialLayout {

		private ShapeEditPart rootEP;
		private List allEditparts = new ArrayList();
		private double startTheta;
		private double totalTheta;
		private boolean rootPositionLocked;

		public RadialLayout(
			ShapeEditPart rootEP,
			List shapeViews,
			double startTheta,
			double totalTheta,
			boolean rootPositionLocked) {
			this.rootEP = rootEP;
			this.allEditparts.addAll(shapeViews);
			this.startTheta = startTheta;
			this.totalTheta = totalTheta;
			this.rootPositionLocked = rootPositionLocked;
		}

		/**
		 * Method getRootEditPart.
		 * 
		 * @@return ShapeEditPart
		 */
		public ShapeEditPart getRootEditPart() {
			return rootEP;
		}

		/**
		 * Method getCommand.
		 * 
		 * @@return Command
		 */
		public Command getCommand() throws LayoutEstheticsException {
			CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
			Command cmd = null;
			List restViews = new ArrayList();
			
			List firstCircleParts = new ArrayList();
			
			int innerRingCount =
				findChildViews(rootEP, allEditparts, firstCircleParts, restViews);

			double theta = Math.PI;
			if (innerRingCount > 1) {
				theta = totalTheta / innerRingCount;
			} 
						
			// initialize the childAndSectionViewMap structure
			Map childAndSectionMap = new Hashtable(firstCircleParts.size());
			List circleSectionParts = null;
			List firstCircleShapes = new ArrayList(childAndSectionMap.keySet().size());
			
			for (int i = 0; i < firstCircleParts.size(); i++) {
				EditPart ep = (EditPart) firstCircleParts.get(i);
				if (ep instanceof ShapeEditPart) {
					ShapeEditPart shapeEP = (ShapeEditPart) ep;
					circleSectionParts =
						new ArrayList(firstCircleParts.size());

					List restRestViews = new ArrayList();
					findChildViews(
						shapeEP,
						restViews,
						circleSectionParts,
						restRestViews);

					firstCircleShapes.add(ep);
					childAndSectionMap.put(ep, circleSectionParts);
					childAndSectionMap.put(circleSectionParts, restRestViews);
				} 
			}
			
			CalculateRadialInfoCommand radialInfoCmd = 
				new CalculateRadialInfoCommand(rootEP, firstCircleShapes, theta);
			cc.add(radialInfoCmd);
			
			cmd = positionRings(firstCircleParts, childAndSectionMap, theta, radialInfoCmd);
			if (cmd != null)
				cc.add(cmd);
			
			// route any extra connection, restViews should only contain
			// connections by now, all other views has
			// better be placed already.
			cmd = routeConnection(firstCircleParts);
			if (cmd != null)
				cc.add(cmd);
			
			double increaseTheta = theta;
			cmd = positionNextRings(firstCircleParts, childAndSectionMap, increaseTheta );
			if (cmd != null)
				cc.add(cmd);
			
			return cc;
		}
		
		/**
		 * getPrelayoutCommand
		 * Initializes the set of shapes for the layout operation.
		 * @@return Cpmmand that will initialize the shapes for the layout operation.
		 */
		private Command getPrelayoutCommand() {
			List restViews = new ArrayList();
			List firstCircleParts = new ArrayList();
			
			findChildViews(rootEP, allEditparts, firstCircleParts, restViews);
			Command cmd = diminishCircle(firstCircleParts);
				
			int size = getFontSize(rootEP);
			int fontAdjust = size / 8;

			size -= fontAdjust;

			Command c2 = diminishCircle(restViews, size);
			if (c2 != null) {
				if (cmd != null)
					cmd.chain(c2);
				else
					cmd = c2;
			}

			Request req = new Request(RequestConstants.REQ_REFRESH);
			Command c3 = rootEP.getParent().getCommand(req);
			if (c3 != null) {
				if (cmd != null)
					cmd.chain(c3);
				else
					cmd = c3;
			}
			
			return cmd;
		}

		/**
		 * positionNextRings
		 * Method to handle the recursion of the RadialLayout.  
		 * 
		 * @@param firstCircleParts
		 * @@param childAndSectionMap
		 * @@param theta
		 * @@return
		 */
		private Command positionNextRings(List firstCircleParts, Map childAndSectionMap, double theta ) {
			CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
			int n = 0;
			
			for (int i = 0; i < firstCircleParts.size(); i++) {
				double totalThetaPrim = theta;
				EditPart part = (EditPart) firstCircleParts.get(i);
				if (part instanceof ShapeEditPart) {
					List parts = (List)childAndSectionMap.get(part);
					
					if (parts != null
						&& !parts.isEmpty()) {
						int posViewCount = 0;
						
						n = i;
						// check next in list to see if we can increase theta
						while (i + 1 < firstCircleParts.size()) {
							Object key = firstCircleParts.get(i+1);
							List nextViews = (List)childAndSectionMap.get(key);
							if (null != nextViews && nextViews.size() == 0) {
								totalThetaPrim = Math.min(Math.PI, totalThetaPrim + theta);
								i++;
							}
							else
								break;
						}
						
						// count the ShapeEditParts
						ListIterator li = parts.listIterator();
						while (li.hasNext()) {
							if (li.next() instanceof ShapeEditPart)
								posViewCount++;
						}

						double dTheta = startTheta + (n * theta);
						double thetaPrim = totalThetaPrim / posViewCount;
						double startThetaPrim;
						if (posViewCount < 2) {
							startThetaPrim = dTheta;
						} else {
							startThetaPrim = dTheta - totalThetaPrim / 2 + thetaPrim / 2;
						}

						List restRestViews = (List)childAndSectionMap.get(parts);
						parts.addAll(restRestViews);
						
						RadialLayout radialLayout =
							new RadialLayout((ShapeEditPart)part, parts, startThetaPrim, totalThetaPrim, true);
						Command cmd = radialLayout.getCommand();
						if (cmd != null)
							cc.add(cmd);
					}
				}
			}
			
			if (!cc.isEmpty())
				return cc;
			
			return null;
		}

		/**
		 * @@author sshaw
		 * 
		 * This class implements IAdaptable so that a deferred point can be
		 * calculated for an edit part.
		 */
		static protected class RadialPosition implements IAdaptable {

			private ShapeEditPart sep;
			private CalculateRadialInfoCommand radialInfo;
			private double theta;
			private boolean useDelta;
			private Point ptLocation = null;

			/**
			 * Method RadialPosition. Constructor for the inner ring elements.
			 * 
			 * @@param sep
			 * @@param innerIndex
			 */
			public RadialPosition(ShapeEditPart sep, double theta, CalculateRadialInfoCommand radialInfo, boolean useDelta) {
				this.sep = sep;
				this.theta = theta;
				this.radialInfo = radialInfo;
				this.useDelta = useDelta;
			}

			/**
			 * Method getAdapter.
			 * 
			 * @@param adapterType
			 * @@return Object
			 */
			public Object getAdapter(Class adapterType) {
				if (adapterType == IPropertyValueDeferred.class) {
					return getPosition();
				}

				return null;
			}

			/**
			 * Method getPosition. Calculates the point based on stored
			 * information about the radius and index of the edit part.
			 * 
			 * @@return Point
			 */
			public Point getPosition() {
				if (null == ptLocation) {
					ptLocation = new Point(0, 0);
					
					if (null != radialInfo) {
						ptLocation.x =
							Math.round(
								radialInfo.getRadius() * ((float) Math.cos(theta)) ); 
						ptLocation.y =
							Math.round(
								radialInfo.getRadius() * ((float) Math.sin(theta)) );
						
						if (useDelta)
							ptLocation.translate(radialInfo.getDelta());
					}
					
					ptLocation.translate(
							-sep.getSize().width / 2,
							-sep.getSize().height / 2);
					
					sep = null;
					radialInfo = null;
				}
				
				return ptLocation;
			}
		}

		/**
		 * Method findChildViews. This method finds all of the child views
		 * relative to a given root view and a set of views.
		 * 
		 * @@param rootEditPart
		 *            ShapeEditPart to be compared against. If a connection ends
		 *            on this root editpart the end must be related.
		 * @@param editparts
		 *            List of a editparts that are used to compare against the
		 *            root editpart.
		 * @@param childEPs
		 *            List that is passed in and populated by the method. It
		 *            will be populated the editparts that are related to the
		 *            rootView.
		 * @@param restEPs
		 *            List that is passed in and populated by the method. It
		 *            will be populated with the editparts are not related to
		 *            the rootView.
		 * @@return int number of related shape editparts in the childViews
		 *         list.
		 */
		protected int findChildViews(
			ShapeEditPart rootEditPart,
			List editparts,
			List childEPs,
			List restEPs) {
			if (rootEditPart == null)
				throw new InvalidParameterException();

			if (childEPs == null)
				throw new InvalidParameterException();

			if (restEPs == null)
				throw new InvalidParameterException();

			Set allSet = new HashSet(editparts.size());
			int posViewCount = 0;
			int count = editparts.size();
			for (int i = 0; i < count; i++) {
				EditPart ep = (EditPart) editparts.get(i);
				allSet.add(ep);
			}

			//get a list of the selected connections and the selected
			//shapes connections
			List connectionEPs = new ArrayList();
			for (int i = 0; i < count; i++) {
				EditPart ep = (EditPart) editparts.get(i);
				if (ep instanceof ShapeEditPart) {
					ShapeEditPart shapeEP = (ShapeEditPart) ep;
					connectionEPs.addAll(shapeEP.getSourceConnections());
					connectionEPs.addAll(shapeEP.getTargetConnections());
				} else if (ep instanceof ConnectionNodeEditPart) {
					connectionEPs.add(ep);
				}
			}

			for (int i = 0; i < connectionEPs.size(); i++) {
				EditPart ep = (EditPart) connectionEPs.get(i);
				if (ep instanceof ConnectionNodeEditPart) {
					ConnectionNodeEditPart connectionEP =
						(ConnectionNodeEditPart) ep;
					EditPart fromEP = connectionEP.getSource();
					EditPart toEP = connectionEP.getTarget();

					EditPart el = null;
					if (fromEP.equals(rootEditPart)) {
						el = toEP;
					} else if (toEP.equals(rootEditPart)) {
						el = fromEP;
					} 

					if (el != null && allSet.contains(el)) {
						childEPs.add(el);
						posViewCount++;
						childEPs.add(connectionEP);

						allSet.remove(el);
					}
				}

			}

			// If the rest collection was requested, pick out all views that
			// was not in the child collection.
			restEPs.addAll(allSet);

			return posViewCount;
		}

		/**
		 * Method getFontSize. Returns the size of the associated font with the
		 * viewEl,
		 * 
		 * @@param sep
		 *            ShapeEditPart element to retrieve the fontdata from.
		 * @@return int value of the font size (height).
		 */
		protected int getFontSize(ShapeEditPart sep) {
			if (sep == null)
				throw new InvalidParameterException();
			View view = sep.getNotationView();
			if (view!=null){
				FontStyle style = (FontStyle) view.getStyle(NotationPackage.eINSTANCE.getFontStyle());
				if (style != null)
					return style.getFontHeight();
			}
			return 9;
		}

		/**
		 * Method setFontSize. Sets the new font size for a given view element.
		 * This is a convenience wrapper. The same functionality can be
		 * achieved by using the setPropertyValue api.
		 * 
		 * @@param viewEl
		 *            IView element to retrieve and set the fontdata from.
		 * @@param size
		 *            value of the new font size (height).
		 * @@return Command
		 */
		protected Command setFontSize(ShapeEditPart sep, int size) {
			if (sep == null)
				throw new InvalidParameterException();

			ChangePropertyValueRequest cpvr = new ChangePropertyValueRequest(
				DiagramUIProvidersMessages.RadialProvider_changeFontRequest_label,
				Properties.ID_FONTSIZE, new Integer(size));
		
			return getCommand(sep, cpvr, true);
		}

		/**
		 * Method diminishInnerCircle. Given a list of views this method will
		 * parse through them and diminish their size by setting the font.
		 * 
		 * @@param editparts
		 *            List of editparts to diminish the size of.
		 * @@param fontSize
		 *            int value of the new font size.
		 * @@return Command
		 *  
		 */
		protected Command diminishCircle(List editparts) {
			if (editparts == null)
				throw new InvalidParameterException();

			int count = editparts.size();

			CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
			
			//diminish by collapsing all compartments and hiding
			// connection labels.
			for (int i = 0; i < count; i++) {
				EditPart editpart = (EditPart) editparts.get(i);
				ChangePropertyValueRequest request = null;

				if (editpart instanceof ShapeEditPart) {
					request = new ChangePropertyValueRequest(
						DiagramUIProvidersMessages.RadialProvider_changeVisibilityRequest_label,
						Properties.ID_ISVISIBLE, Boolean.FALSE);

					ShapeEditPart shapeEditPart = (ShapeEditPart) editpart;
					
					Iterator compartments = shapeEditPart
						.getResizableCompartments().iterator();
					while (compartments.hasNext()) {
						cc.add(((EditPart) compartments.next())
							.getCommand(request));
					}
					
					
				}
			}

			if (!cc.isEmpty())
				return cc;

			return null;
		}

		/**
		 * Method diminishCircle. Given a list of views this method will
		 * parse through them and diminish their size by setting the font and
		 * also by hiding all compartments.
		 * 
		 * @@param editparts
		 *            List of editparts to diminish the size of.
		 * @@param fontSize
		 *            int value of the new font size.
		 * @@return Command
		 *  
		 */
		protected Command diminishCircle(List editparts, int fontSize) {
			if (editparts == null)
				throw new InvalidParameterException();

			long count = editparts.size();

			CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$

			// diminish the same as the inner circle first.
			Command cmd = diminishCircle(editparts);
			if (cmd != null)
				cc.add(cmd);
			
			//diminish font for outer circle
			for (int i = 0; i < count; i++) {
				EditPart ep = (EditPart) editparts.get(i);
				if (ep instanceof ShapeEditPart) {
					cmd = setFontSize((ShapeEditPart) ep, fontSize);
					if (cmd != null)
						cc.add(cmd);
				}
			}

			if (!cc.isEmpty())
				return cc;

			return null;
		}

        /**
         * sortFirstCircleParts
         * Sort the circle views in a pattern such that the next iteration of radial 
         * views will be positioned evenly w.r.t. each other.
         * 
         * @@param firstCircleViews List of circle views
         * @@param childAndSectionViewMap Map of next level views.
         */
        protected void sortFirstCircleParts(List firstCircleParts, Map childAndSectionMap) {
        	List firstCircleShapeParts = new ArrayList(firstCircleParts.size());
        	List rest = new ArrayList(firstCircleParts.size());
        	ListIterator li = firstCircleParts.listIterator();
        	while (li.hasNext()) {
        		Object obj = li.next();
        		if (obj instanceof ShapeEditPart) {
        			firstCircleShapeParts.add(obj);
        		}
        		else
        			rest.add(obj);
        	}
        	
            // figure out how many empty 2nd line children there are
            List emptyNextCircleList = new ArrayList(firstCircleParts.size());
            List nextCircleList = new ArrayList(firstCircleParts.size());
            for (int i = 0; i < firstCircleShapeParts.size(); i++) {
            	List circleList = (List)childAndSectionMap.get(firstCircleShapeParts.get(i));
        		if (null != circleList && circleList.size() == 0)
        			emptyNextCircleList.add(firstCircleShapeParts.get(i));
        		else
        			nextCircleList.add(firstCircleShapeParts.get(i));
            }
            
            firstCircleParts.clear();
            if (nextCircleList.size() > 1) {
            	int addInc = firstCircleShapeParts.size() / nextCircleList.size();
	            int i = 0;
	            while (nextCircleList.size() > 0 || emptyNextCircleList.size() > 0) {
	            	if (i % addInc == 0 && nextCircleList.size() > 0) {
	            		firstCircleParts.add(nextCircleList.remove(0));
	            	}
	            	else {
	            		if (emptyNextCircleList.size() > 0)
	            			firstCircleParts.add(emptyNextCircleList.remove(0));
	            	}
	            	i++;
	            }
            }
            else
            	firstCircleParts.addAll(firstCircleShapeParts);
            
            firstCircleParts.addAll(rest);
        }
        
		/**
		 * Method positionRings. This method positions the view rings around
		 * the root view.
		 * 
		 * @@return Command
		 */
		protected Command positionRings(List firstCircleParts, Map childAndSectionMap, 
										double theta, CalculateRadialInfoCommand radialInfo) {
			int n = 0;
 
			if (theta < Math.PI / 32 && isRootPositionLocked())
				throw new LayoutEstheticsException("Angle is too small to resulting in very large radius");//$NON-NLS-1$
			
			CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
			List editParts = new ArrayList();
			editParts.add(rootEP);
			
			sortFirstCircleParts(firstCircleParts, childAndSectionMap);
			
			ListIterator li = firstCircleParts.listIterator();
			while (li.hasNext()) {
				EditPart editpart = (EditPart) li.next();

				if (editpart instanceof ShapeEditPart) {
					ShapeEditPart sep = (ShapeEditPart) editpart;
					editParts.add(sep);
					
					IAdaptable deferredPos = new RadialPosition(sep, startTheta + n * theta, radialInfo, isRootPositionLocked());

					ChangeBoundsDeferredRequest request =
						new ChangeBoundsDeferredRequest(deferredPos);
					
					Command cmd = sep.getCommand(request);
					
					if (cmd != null)
						cc.add(cmd);

					n++;
				}
			}
			
			if (!isRootPositionLocked()) {
				IAdaptable deferredRootPos = new RadialPosition(getRootEditPart(), 0, null, isRootPositionLocked());
				ChangeBoundsDeferredRequest request = new ChangeBoundsDeferredRequest(deferredRootPos);
				Command cmd = rootEP.getCommand(request);
				if (cmd != null)
					cc.add(cmd);
			}
			
			if (!cc.isEmpty())
				return cc;

			return null;
		}

		/**
		 * Method routeConnections.
		 * 
		 * @@param connections
		 *            List of connections that need to be routed.
		 * @@return Command
		 */
		protected Command routeConnection(List connections) {

			CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
			ListIterator li = connections.listIterator();

			while (li.hasNext()) {
				EditPart editpart = (EditPart) li.next();
				if (editpart instanceof ConnectionNodeEditPart) {
					Command cmd =
						routeConnection((ConnectionNodeEditPart) editpart);
					if (cmd != null)
						cc.add(cmd);
				}
			}

			if (!cc.isEmpty())
				return cc;

			return null;
		}

		/**
		 * Method routeConnection. Route the given connection accordingly to the
		 * layout algorithm. TBD utilize the "avoid obstructions" routing.
		 * 
		 * @@param connectionEP
		 *            ConnectionNodeEditPart connection to be routed.
		 * @@return Command
		 */
		protected Command routeConnection(ConnectionNodeEditPart connectionEP) {
			if (connectionEP == null)
				throw new InvalidParameterException();

			// reset connections

			Connection connection = connectionEP.getConnectionFigure();
			PointList newPoints = new PointList(2);
			newPoints.addPoint(connection.getPoints().getFirstPoint());
			newPoints.addPoint(connection.getPoints().getLastPoint());
			SetAllBendpointRequest request =
				new SetAllBendpointRequest(
					RequestConstants.REQ_SET_ALL_BENDPOINT,
					newPoints);

			// recurse through the children to get the compound command
			return connectionEP.getCommand(request);
		}

		/**
		 * Method getCommand. Utility function to optionally recurse through
		 * all child edit parts to send the request to.
		 * 
		 * @@param editpart
		 *            EditPart at the Top level to send the command request to.
		 * @@param request
		 *            Request that is sent to the EditPart and it's children.
		 * @@param bRecursive
		 *            boolean true if the method is to send the request to all
		 *            the children of the editpart as well, false otherwise.
		 * @@return Command that is the result of the request to be executed.
		 */
		protected Command getCommand(
			EditPart editpart,
			Request request,
			boolean bRecursive) {
			List children = editpart.getChildren();
			ListIterator li = children.listIterator();

			CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
			Command cmd = editpart.getCommand(request);
			
			if (cmd != null)
				cc.add(cmd);

			if (bRecursive) {
				while (li.hasNext()) {
					IGraphicalEditPart childEP = (IGraphicalEditPart) li.next();
					cmd = getCommand(childEP, request, bRecursive);
					if (cmd != null)
						cc.add(cmd);
				}
			}

			if (!cc.isEmpty())
				return cc;

			return null;
		}
		
		/**
		 * @@author sshaw
		 * 
		 * This will perform some interim calculation that depends on the
		 * previous command execution for setting the proper sizes for the view
		 * elements.
		 */
		static protected class CalculateRadialInfoCommand extends Command {

			//	deferred calculation values
			private int radius;
			private double theta;
			private ShapeEditPart rootEP;
			private List firstCircleViews;
			
			public CalculateRadialInfoCommand(ShapeEditPart rootEP, List firstCircleViews, double theta) {
				this.rootEP = rootEP;
				this.firstCircleViews = firstCircleViews;
				this.theta = theta;
			}
	        
			public void execute() {
				radius =
					calculateNeededRadius(firstCircleViews, firstCircleViews.size() * theta);

				// if innerradius is less than the 2 times the diagonal of the
				// RootView extend it some.
				double rootDiagonal = getViewWorstExtent(rootEP);
				if (2 * rootDiagonal > radius) {
					radius += rootDiagonal;
				}
				
				radius = Math.max(MapModeUtil.getMapMode(rootEP.getFigure()).DPtoLP(180), radius);
			}

			/**
			 * Method calculateNeededRadius. This method calculates the minimum
			 * radius needed to fully extent the given views away from a center
			 * point.
			 * 
			 * @@param circleEPs
			 *            List of editparts that the radius will be calculated
			 *            from.
			 * @@param sectionAngle
			 *            This is the angle in radians that the views will
			 *            extent around.
			 * @@return int value of the calculated radius.
			 */
			protected int calculateNeededRadius(
				List circleEPs,
				double sectionAngle) {
				if (circleEPs == null)
					throw new InvalidParameterException();

				double neededDiameter = 0;
				int count = circleEPs.size();
				double maxDiagonal = 0;

				for (int i = 0; i < count; i++) {

					EditPart ep = (EditPart) circleEPs.get(i);
					if (ep instanceof ShapeEditPart) {
						ShapeEditPart sep = (ShapeEditPart) ep;

						double diagonal = getViewWorstExtent(sep);

						neededDiameter += diagonal;

						if (diagonal > maxDiagonal)
							maxDiagonal = diagonal;
					}

				}

				double rad;

				rad = neededDiameter / sectionAngle;

				return (int) Math.round(rad);
			}

			/**
			 * Method getViewWorstExtent. Determines the worst case extent of a
			 * given view to ensure no intersection occurs. The diagonal of the
			 * view extent is used to for this value.
			 * 
			 * @@param sep
			 *            ShapeEditPart to calcualte to the worst case extent
			 *            from.
			 * @@return double value of the biggest extent where no intersection
			 *         will occur with the view.
			 */
			protected double getViewWorstExtent(ShapeEditPart sep) {
				if (sep == null)
					throw new InvalidParameterException();

				Dimension ext = sep.getSize();				
				return Math.sqrt( 
					(ext.width * ext.width) + (ext.height * ext.height)) * 0.80;
			}

			/**
			 * @@return Returns the radius.
			 */
			public int getRadius() {
				return radius;
			}

			/**
			 * @@return Returns the delta.
			 */
			public Point getDelta() {
				View view = rootEP.getNotationView();
				if (view!=null){
					Integer posX = (Integer)ViewUtil.getStructuralFeatureValue(view,NotationPackage.eINSTANCE.getLocation_X());
					Integer posY = (Integer)ViewUtil.getStructuralFeatureValue(view,NotationPackage.eINSTANCE.getLocation_Y());
					return new Point(posX.intValue(), posY.intValue());
				}
				return new Point(0,0);
			}
		}
		
		/**
		 * @@return Returns the rootPositionLocked.
		 */
		public boolean isRootPositionLocked() {
			return rootPositionLocked;
		}
	}
}
@


1.13
log
@[139856] gmf_head anthonyh 060614 EtoolsProxyCommand should be renamed to ICommandProxy
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d25 1
a64 1
import org.eclipse.jface.util.Assert;
@


1.12
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d44 1
a44 1
import org.eclipse.gmf.runtime.diagram.ui.commands.EtoolsProxyCommand;
d193 1
a193 1
        cmd = new EtoolsProxyCommand(orpc);
@


1.11
log
@bugzilla 117592 gmf-head mmostafa 060207 Eroneous references to xtools in diagram plugins
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2004 IBM Corporation and others.
d24 1
d32 1
d60 1
a60 1
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractModelCommand;
d191 3
a193 2
		OffsetRadialPartsCommand orpc = new OffsetRadialPartsCommand(parts); 
		cmd = new EtoolsProxyCommand(orpc);
d205 1
a205 1
	static protected class OffsetRadialPartsCommand extends AbstractModelCommand {
d213 2
a214 2
		public OffsetRadialPartsCommand(List editParts) {
			super("", null); //$NON-NLS-1$
d219 4
a222 4
		/* (non-Javadoc)
		 * @@see org.eclipse.gef.commands.Command#execute()
		 */
		protected CommandResult doExecute(IProgressMonitor progressMonitor) {
d224 1
a224 1
				return newCancelledCommandResult();
d259 1
a259 1
			return newOKCommandResult();
@


1.10
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d73 2
a74 2
	/**
	 * @@see com.ibm.xtools.common.service.IProvider#provides(IOperation)
@


1.9
log
@bugzilla 116490 gmf-head sshaw 051124 LayoutService should be public
@
text
@d49 1
a49 1
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.l10n.DiagramProvidersResourceManager;
d737 3
a739 1
			ChangePropertyValueRequest cpvr = new ChangePropertyValueRequest(DiagramProvidersResourceManager.getI18NString("RadialProvider.changeFontRequest.label"), Properties.ID_FONTSIZE, new Integer(size)); //$NON-NLS-1$
d771 2
a772 2
						DiagramProvidersResourceManager
							.getI18NString("RadialProvider.changeVisibilityRequest.label"), Properties.ID_ISVISIBLE, Boolean.FALSE); //$NON-NLS-1$
@


1.8
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d48 1
d54 1
a54 2
import org.eclipse.gmf.runtime.diagram.ui.services.layout.AbstractLayoutProvider;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutNodesOperation;
d71 1
a71 1
	extends AbstractLayoutProvider {
d88 2
a89 3
	
	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.ILayoutProvider#layout(org.eclipse.gef.GraphicalEditPart, org.eclipse.core.runtime.IAdaptable)
d100 2
a101 2
	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.ILayoutProvider#layout(java.util.List, org.eclipse.core.runtime.IAdaptable)
d315 5
@


1.7
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d56 2
a57 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d226 3
d231 2
a232 2
			newRadialRect.translate( -radialRect.getTopLeft().x + MapMode.DPtoLP(50),
							 -radialRect.getTopLeft().y + MapMode.DPtoLP(50));
d1064 1
a1064 1
				radius = Math.max(MapMode.DPtoLP(180), radius);
@


1.6
log
@bugzilla 110316 gmf-head mmostafa 051014 Compiler warning count should be 0 - runtime diagram layer components
@
text
@d407 2
a408 2
			// route any extra connector, restViews should only contain
			// connectors by now, all other views has
d410 1
a410 1
			cmd = routeConnectors(firstCircleParts);
d609 1
a609 1
		 *            ShapeEditPart to be compared against. If a connector ends
d647 3
a649 3
			//get a list of the selected connectors and the selected
			//shapes connectors
			List connectorEPs = new ArrayList();
d654 2
a655 2
					connectorEPs.addAll(shapeEP.getSourceConnections());
					connectorEPs.addAll(shapeEP.getTargetConnections());
d657 1
a657 1
					connectorEPs.add(ep);
d661 2
a662 2
			for (int i = 0; i < connectorEPs.size(); i++) {
				EditPart ep = (EditPart) connectorEPs.get(i);
d664 1
a664 1
					ConnectionNodeEditPart connectorEP =
d666 2
a667 2
					EditPart fromEP = connectorEP.getSource();
					EditPart toEP = connectorEP.getTarget();
d679 1
a679 1
						childEPs.add(connectorEP);
d754 1
a754 1
			// connector labels.
d933 1
a933 1
		 * Method routeConnectors.
d935 2
a936 2
		 * @@param connectors
		 *            List of connectors that need to be routed.
d939 1
a939 1
		protected Command routeConnectors(List connectors) {
d942 1
a942 1
			ListIterator li = connectors.listIterator();
d948 1
a948 1
						routeConnector((ConnectionNodeEditPart) editpart);
d961 1
a961 1
		 * Method routeConnector. Route the given connector accordingly to the
d964 2
a965 2
		 * @@param connectorEP
		 *            ConnectionNodeEditPart connector to be routed.
d968 2
a969 2
		protected Command routeConnector(ConnectionNodeEditPart connectorEP) {
			if (connectorEP == null)
d972 1
a972 1
			// reset connectors
d974 1
a974 1
			Connection connection = connectorEP.getConnectionFigure();
d984 1
a984 1
			return connectorEP.getCommand(request);
a1048 3
			/**
			 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.commands.AbstractPresentationCommand#doExecute()
			 */
@


1.5
log
@bugzilla 112685 gmf-head sshaw 051014 Sweep code for creation of Boolean objects
@
text
@a35 2
import org.eclipse.jface.util.Assert;

d40 1
a55 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d61 1
d244 4
a247 4
					Integer pos = (Integer)ViewUtil.getPropertyValue(view,Properties.ID_POSITIONX);
					ViewUtil.setPropertyValue(view,Properties.ID_POSITIONX, new Integer(pos.intValue() + translate.x));
					pos = (Integer)ViewUtil.getPropertyValue(view,Properties.ID_POSITIONY);
					ViewUtil.setPropertyValue(view,Properties.ID_POSITIONY, new Integer(pos.intValue() + translate.y));
d1145 2
a1146 2
					Integer posX = (Integer)ViewUtil.getPropertyValue(view,Properties.ID_POSITIONX);
					Integer posY = (Integer)ViewUtil.getPropertyValue(view,Properties.ID_POSITIONY);
@


1.4
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d763 1
a763 1
							.getI18NString("RadialProvider.changeVisibilityRequest.label"), Properties.ID_ISVISIBLE, new Boolean(false)); //$NON-NLS-1$
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d47 1
a48 1
import org.eclipse.gmf.runtime.diagram.ui.properties.Properties;
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d58 3
a60 3
import com.ibm.xtools.notation.FontStyle;
import com.ibm.xtools.notation.NotationPackage;
import com.ibm.xtools.notation.View;
@

