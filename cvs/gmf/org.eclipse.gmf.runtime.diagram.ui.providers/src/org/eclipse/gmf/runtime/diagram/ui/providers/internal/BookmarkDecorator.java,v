head	1.10;
access;
symbols
	v20081020-0700:1.10
	v20080924-1925:1.10
	v20080917-1925:1.10
	v20080916-2008:1.10
	v20080911-1728:1.10
	v20080722-1827:1.10
	v20080716-1600:1.10
	v20080716-1642:1.10
	R2_1_maintenance:1.10.0.2
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080503-1740:1.10
	v20080425-1959:1.10
	v20080417-1610:1.10
	v20080407-2250:1.10
	v20080407-0930:1.9
	v20080404-1111:1.9
	v20080328-1605:1.9
	v20080222-1200:1.9
	v20080215-1500:1.9
	v20080201-2010:1.9
	v20080201-0201:1.9
	v20071130-1111:1.9
	v20071108-0000:1.9
	v20070903-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.4
	R2_0:1.9
	R4_20:1.9
	v20070621-0000:1.9
	RC3_20:1.9
	v20070601-1400:1.9
	v20070518-1300:1.9
	bugzilla111892_group_support:1.9.0.2
	Root_bugzilla111892_group_support:1.9
	v20070504-1000:1.9
	v20070420-1000:1.9
	v20070413-1300:1.9
	v20070330-1300:1.9
	v20060316-0600:1.9
	v20070228-2000:1.9
	v20070221-1500:1.9
	v20070208-1800:1.9
	M4_20:1.9
	v20061218-1500:1.8.2.2
	v20061214-0000:1.9
	M3_20:1.9
	v20061013-1330:1.9
	v20060919-0800:1.8.2.2
	M1_20:1.8
	v20060803-1200:1.8.2.1
	v20060728-0500:1.8.2.1
	v20060721-1130:1.8
	v20060713-1700:1.8
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	v20060627-1200:1.8
	v20060616-1200:1.8
	v20060609-1400:1.8
	v20060531-1730:1.8
	v20060530-1930:1.8
	v20060519-0800:1.8
	I20060428-1300:1.8
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.8
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060202-1415:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051201-1800:1.5
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.3;
locks; strict;
comment	@# @;


1.10
date	2008.04.08.02.16.29;	author ahunter;	state Exp;
branches;
next	1.9;
commitid	4c9c47fad57b4567;

1.9
date	2006.10.03.15.03.01;	author ahunter;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.06.20.31.25;	author ldamus;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2006.04.05.21.01.48;	author ldamus;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.28.02.31.15;	author cmahoney;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.25.19.37.44;	author cmahoney;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.04.21.28.09;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.26.25;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.03;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.44;	author sshaw;	state Exp;
branches;
next	;

1.8.2.1
date	2006.07.26.20.06.10;	author ldamus;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2006.09.13.16.43.25;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.10
log
@[226065] gmf-head ahunter 080407 Fix warning: The type Assert is deprecated
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.providers.internal;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.gef.EditPart;
import org.eclipse.gmf.runtime.common.core.resources.IBookmark;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.resources.FileChangeManager;
import org.eclipse.gmf.runtime.common.ui.resources.IFileObserver;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IPrimaryEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.l10n.DiagramUIProvidersPluginImages;
import org.eclipse.gmf.runtime.diagram.ui.services.decorator.AbstractDecorator;
import org.eclipse.gmf.runtime.diagram.ui.services.decorator.IDecorator;
import org.eclipse.gmf.runtime.diagram.ui.services.decorator.IDecoratorTarget;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.ui.PlatformUI;


/**
 * Provides bookmark decorations for views 
 * 
 * @@author Michael Yee
 * @@canBeSeenBy org.eclipse.gmf.runtime.diagram.ui.providers.*
 */
public class BookmarkDecorator
	extends AbstractDecorator {

	/**
	 * Listner class for bookmark decorators
	 */
	public class BookmarkObserver
		implements IFileObserver {
		/**
		 * Map of id's and their list of decorators
		 */
		private HashMap mapOfIdsToDecorators = null;

		/**
		 * Flag to indicate if already registered with the file change manager
		 */
		private boolean isRegistered = false;
		
		/**
		 * Registers the specified decorator. Nothing happens if already
		 * registered. The decorator is registered against its view id
		 * 
		 * @@param decorator the input bookmark decorator
		 */
		private void registerDecorator(BookmarkDecorator decorator) {
			/* Return if invalid decorator */
			if ( decorator == null ) {
				return;
			}
			
			/* Initialize the map */
			if ( mapOfIdsToDecorators == null ) {
				mapOfIdsToDecorators = new HashMap();
			}			

			/* Return if the decorator has invalid view id */
			String decoratorViewId = decorator.getViewId();
			if ( decoratorViewId == null ) {
				return;
			}
			
			/* Add to the list */
			List list = (List)mapOfIdsToDecorators.get(decoratorViewId);
			if (list == null) {
				list = new ArrayList(2);
				list.add(decorator);
				mapOfIdsToDecorators.put(decoratorViewId, list);
			} else if (!list.contains(decorator)) {
				list.add(decorator);
			}
			
			/* Register with the file change manager */
			if ( !isRegistered() ) {
				FileChangeManager.getInstance().addFileObserver(this);
				isRegistered = true;
			}
		}

		/**
		 * Unregisters the specified decorator. Nothing happens if already
		 * unregistered.
		 * 
		 * @@param decorator the input bookmark decorator
		 */
		private void unregisterDecorator(BookmarkDecorator decorator) {
			/* Return if invalid decorator */
			if ( decorator == null ) {
				return;
			}
			
			/* Return if the decorator has invalid view id */
			String decoratorViewId = decorator.getViewId();
			if ( decoratorViewId == null ) {
				return;
			}
			
			if (mapOfIdsToDecorators != null) {
				List list = (List)mapOfIdsToDecorators.get(decoratorViewId);
				if ( list != null ) {
					list.remove(decorator);
					if ( list.isEmpty()) {
						mapOfIdsToDecorators.remove(decoratorViewId);
					}				
				}
				
				if ( mapOfIdsToDecorators.isEmpty() ) {
					mapOfIdsToDecorators = null;
				}			
			}
			
			if (mapOfIdsToDecorators == null) {
				/* Unregister with the file change manager */
				if ( isRegistered() ) {
					FileChangeManager.getInstance().removeFileObserver(this);
					isRegistered = false;
				}			
			}			
		}
		
		/*
		 * @@see org.eclipse.gmf.runtime.common.ui.resources.IFileObserver#handleFileRenamed(org.eclipse.core.resources.IFile, org.eclipse.core.resources.IFile)
		 */
		public void handleFileRenamed(IFile oldFile, IFile file) {
			//Empty Code
		}

		/*
		 * @@see org.eclipse.gmf.runtime.common.ui.resources.IFileObserver#handleFileMoved(org.eclipse.core.resources.IFile, org.eclipse.core.resources.IFile)
		 */
		public void handleFileMoved(IFile oldFile, IFile file) {
			//Empty Code
		}

		/*
		 * @@see org.eclipse.gmf.runtime.common.ui.resources.IFileObserver#handleFileDeleted(org.eclipse.core.resources.IFile)
		 */
		public void handleFileDeleted(IFile file) {
			//Empty Code
		}

		/*
		 * @@see org.eclipse.gmf.runtime.common.ui.resources.IFileObserver#handleFileChanged(org.eclipse.core.resources.IFile)
		 */
		public void handleFileChanged(IFile file) {
			//Empty Code
		}

		/*
		 * @@see org.eclipse.gmf.runtime.common.ui.resources.IFileObserver#handleMarkerAdded(org.eclipse.core.resources.IMarker)
		 */
		public void handleMarkerAdded(IMarker marker) {
			//Empty Code
		}

		/*
		 * @@see org.eclipse.gmf.runtime.common.ui.resources.IFileObserver#handleMarkerDeleted(org.eclipse.core.resources.IMarker, java.util.Map)
		 */
		public void handleMarkerDeleted(IMarker marker, final Map attributes) {
			if ( mapOfIdsToDecorators == null ) {
				return;
			}
			
			Assert.isTrue(!marker.exists());
			// Extract the element guid from the marker and retrieve
			// corresponding view
            String elementId = (String) attributes
            .get(IBookmark.ELEMENT_ID);
            List list = elementId != null ? (List)mapOfIdsToDecorators.get(elementId) : null;
            if ( list != null && !list.isEmpty() ) {
                refreshDecorators(list);
            }
		}

		/*
		 * @@see org.eclipse.gmf.runtime.common.ui.resources.IFileObserver#handleMarkerChanged(org.eclipse.core.resources.IMarker)
		 */
		public void handleMarkerChanged(final IMarker marker) {
			if ( mapOfIdsToDecorators == null ) {
				return;
			}
			
			Assert.isTrue(marker.exists());
			// Extract the element ID list from the marker and retrieve
			// corresponding view
            
            String elementId = marker.getAttribute(
                IBookmark.ELEMENT_ID, StringStatics.BLANK);
            List list = elementId != null ? (List)mapOfIdsToDecorators.get(elementId) : null;
            
            if ( list != null && !list.isEmpty() ) {
                refreshDecorators(list);
            }
		}
        
        /**
         * Refreshes decorators asynchronously on the UI thread (required
         * because GEF can only be used on the UI thread) so that getting a read
         * transaction won't contribute to deadlock while the workspace is
         * locked.
         * 
         * @@param decorators
         *            the decorators to be refreshed
         */
        private void refreshDecorators(final List decorators) {
            PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
                public void run() {
                    try {
                        TransactionUtil.getEditingDomain(
                            getDecoratorTarget().getAdapter(View.class)).runExclusive(
                            new Runnable() {
    
                            public void run() {
                                Iterator iter = decorators.iterator();
                                while (iter.hasNext()) {
                                    IDecorator decorator = (IDecorator)iter.next();
                                    if ( decorator != null ) {
                                        decorator.refresh();
                                    }
                                }
                            }
                        });
                    } catch (Exception e) {
                        Trace.catching(DiagramProvidersPlugin.getInstance(),
                            DiagramProvidersDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                            "refreshDecorators()", //$NON-NLS-1$
                            e);
                    }
                }
            });
        }
		
		/**
		 * Returns the flag if this observer is registered
		 * @@return the isRegistered.
		 */
		private boolean isRegistered() {
			return isRegistered;
		}
	}
	
	/**
	 * Resource listener for bookmark creation and removal 
	 */
	private static BookmarkObserver fileObserver = null;
	
	/**
	 * Attribute for the view id
	 */
	private String viewId = null;
	
	/**
	 * Creates a new <code>BookmarkDecorator</code>.
	 * @@param decoratorTarget
	 */
	public BookmarkDecorator(IDecoratorTarget decoratorTarget) {
		super(decoratorTarget);

		/* Set the id */		
		try {
			final View view = (View) getDecoratorTarget().getAdapter(View.class);
			TransactionUtil.getEditingDomain(view).runExclusive(new Runnable() {

				public void run() {

					BookmarkDecorator.this.viewId = view != null ? ViewUtil
						.getIdStr(view)
						: null;
				}
				});
		} catch (Exception e) {
			Trace.catching(DiagramProvidersPlugin.getInstance(),
				DiagramProvidersDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"BookmarkDecorator::Constructor", //$NON-NLS-1$
				e);
		}
	}

	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.decorator.IDecorator#refresh()
	 */
	public void refresh() {
		removeDecoration();

		View view = (View) getDecoratorTarget().getAdapter(View.class);
		EditPart editPart = (EditPart) getDecoratorTarget().getAdapter(
			EditPart.class);
		if (!(editPart instanceof IPrimaryEditPart) || view == null || view.eResource()==null) {
			return;
		}

		IResource resource = getResource(view);
		// make sure we have a resource and that it exists in an open project
		if (resource == null || !resource.exists()) {
			return;
		}

		// query for all the bookmarks of the current resource
		IMarker[] bookmarks = null;
		try {
			bookmarks = resource.findMarkers(IBookmark.TYPE, true,
				IResource.DEPTH_INFINITE);
		} catch (CoreException e) {
			Trace.catching(DiagramProvidersPlugin.getInstance(),
				DiagramProvidersDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"getDecorations", e); //$NON-NLS-1$
			Log.error(DiagramProvidersPlugin.getInstance(), IStatus.ERROR, e
				.getMessage());
		}
		if (bookmarks == null) {
			return;
		}

		// find the bookmark containing the element's GUID
		IMarker foundMarker = null;
		String elementId = ((XMLResource) view.eResource()).getID(view);
		if (elementId == null) {
			return;
		}
		
		for (Iterator i = Arrays.asList(bookmarks).iterator(); i.hasNext();) {
			IMarker marker = (IMarker) i.next();
			String attribute = marker.getAttribute(IBookmark.ELEMENT_ID,
				StringStatics.BLANK);
			if (attribute.equals(elementId)) {
				foundMarker = marker;
				break;
			}
		}
		if (foundMarker == null) {
			return;
		}

		// add the bookmark decoration
		if (editPart instanceof ShapeEditPart) {
			IMapMode mm = MapModeUtil.getMapMode(((ShapeEditPart)editPart).getFigure());
			setDecoration(getDecoratorTarget().addShapeDecoration(
				DiagramUIProvidersPluginImages.get(DiagramUIProvidersPluginImages.IMG_BOOKMARK),
				IDecoratorTarget.Direction.NORTH_EAST, mm.DPtoLP(-4), true));
		} else if (view instanceof Edge) {
			setDecoration(getDecoratorTarget().addConnectionDecoration(
				DiagramUIProvidersPluginImages.get(DiagramUIProvidersPluginImages.IMG_BOOKMARK), 50, true));
		}
	}

	/**
	 * Gets the underlying resource of the given view
	 * @@param view the given view
	 * @@return the view's resource, otherwise <code>null</code>
	 */
	private static IResource getResource(View view) {
		Resource model = view.eResource();
		if (model != null) {
           return WorkspaceSynchronizer.getFile(model);
		}
		return null;
	}

	/** 
	 * Starts listening to events on the decoratorTarget element's container.
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.decorator.IDecorator#activate()
	 */
	public void activate() {
		View view = (View) getDecoratorTarget().getAdapter(View.class);
		if (view == null) return;
		Diagram diagramView = view.getDiagram();
		if (diagramView == null) return;
		IFile file = WorkspaceSynchronizer.getFile(diagramView.eResource());
		// It does not make sense to add a file observer if the resource
		//  is not persisted or the uri is not in the form of file:///
		if (file != null) {
			if ( fileObserver == null ) {
				fileObserver = new BookmarkObserver();
			}

			fileObserver.registerDecorator(this);
		}
	}

	/**
	 * Stops the listener and removes the decoration if it is being displayed.
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.decorator.IDecorator#deactivate()
	 */
	public void deactivate() {
		if ( fileObserver != null ) {
			fileObserver.unregisterDecorator(this);
			if (!fileObserver.isRegistered()) {
				fileObserver = null;
			}
		}
	
		super.deactivate();
	}
	
	/**
	 * Returns the view id
	 * @@return the viewId.
	 */
	private String getViewId() {
		return viewId;
	}
}@


1.9
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d24 1
a49 1
import org.eclipse.jface.util.Assert;
@


1.8
log
@[135386] gmf_head ldamus 060406 Runtime plugin dependencies must specify required plugin versions
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
d31 1
a35 1
import org.eclipse.gmf.runtime.common.ui.resources.IBookmark;
@


1.8.2.1
log
@[151641] gmf_R1_0_maintenance ldamus 060726 org.eclipse.gmf.common.ui.resources.IMarker and subclasses should not be in a UI-dependent plugin
@
text
@a30 1
import org.eclipse.gmf.runtime.common.core.resources.IBookmark;
d35 1
@


1.8.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.7
log
@[134770] gmf_head ldamus 060405  BookmarkDecorator.BookmarkObserver participates in deadlock
@
text
@a37 1
import org.eclipse.gmf.runtime.diagram.ui.actions.internal.DiagramActionsDebugOptions;
d262 1
a262 1
                            DiagramActionsDebugOptions.EXCEPTIONS_CATCHING, getClass(),
d310 1
a310 1
				DiagramActionsDebugOptions.EXCEPTIONS_CATCHING, getClass(),
d342 1
a342 1
				DiagramActionsDebugOptions.EXCEPTIONS_CATCHING, getClass(),
@


1.6
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d51 1
d205 6
a210 26
			try {
				TransactionUtil.getEditingDomain(
					getDecoratorTarget().getAdapter(View.class)).runExclusive(
					new Runnable() {

					public void run() {
						String elementId = (String) attributes
							.get(IBookmark.ELEMENT_ID);
						List list = elementId != null ? (List)mapOfIdsToDecorators.get(elementId) : null;
						if ( list != null && !list.isEmpty() ) {
							Iterator iter = list.iterator();
							while (iter.hasNext()) {
								IDecorator decorator = (IDecorator)iter.next();
								if ( decorator != null ) {
									decorator.refresh();
								}
							}
						}
					}
				});
			} catch (Exception e) {
				Trace.catching(DiagramProvidersPlugin.getInstance(),
					DiagramActionsDebugOptions.EXCEPTIONS_CATCHING, getClass(),
					"handleMarkerDeleted()", //$NON-NLS-1$
					e);
			}
d224 46
a269 28
			try {
				
				TransactionUtil.getEditingDomain(
					getDecoratorTarget().getAdapter(View.class)).runExclusive(
					new Runnable() {

					public void run() {
						String elementId = marker.getAttribute(
							IBookmark.ELEMENT_ID, StringStatics.BLANK);
						List list = elementId != null ? (List)mapOfIdsToDecorators.get(elementId) : null;
						if ( list != null && !list.isEmpty() ) {
							Iterator iter = list.iterator();
							while (iter.hasNext()) {
								IDecorator decorator = (IDecorator)iter.next();
								if ( decorator != null ) {
									decorator.refresh();
								}
							}
						}
					}
				});
			} catch (Exception e) {
				Trace.catching(DiagramProvidersPlugin.getInstance(),
					DiagramActionsDebugOptions.EXCEPTIONS_CATCHING, getClass(),
					"handleMarkerChanged()", //$NON-NLS-1$
					e);
			}
		}
@


1.5
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@a23 1
import org.eclipse.core.resources.ResourcesPlugin;
a25 1
import org.eclipse.core.runtime.Path;
d27 3
a36 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
a46 3
import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
d205 3
a207 1
				MEditingDomainGetter.getMEditingDomain(getDecoratorTarget()).runAsRead(new MRunnable() {
d209 1
a209 1
					public Object run() {
a221 1
						return null;
d245 3
a247 1
				MEditingDomainGetter.getMEditingDomain(getDecoratorTarget()).runAsRead(new MRunnable() {
d249 1
a249 1
					public Object run() {
a261 1
						return null;
d300 2
a301 2
			MEditingDomainGetter.getMEditingDomain(decoratorTarget).runAsRead(
				new MRunnable() {
d303 6
a308 11
					/*
					 * @@see java.lang.Runnable#run()
					 */
					public Object run() {
						View view = (View) BookmarkDecorator.this
							.getDecoratorTarget().getAdapter(View.class);
						BookmarkDecorator.this.viewId = view != null ? ViewUtil
							.getIdStr(view)
							: null;
						return null;
					}
d355 1
a355 1
		String elementId = EObjectUtil.getID(view);
d393 1
a393 7
			MEditingDomain editingDomain = MEditingDomainGetter.getMEditingDomain(model);
			String filePath = editingDomain.getResourceFileName(model);
			if (filePath != null && filePath.length() != 0) {
				return ResourcesPlugin.getWorkspace().getRoot()
					.getFileForLocation(
						new Path(editingDomain.getResourceFileName(model)));
			}
d407 1
a407 1
		IFile file = EObjectUtil.getFile(diagramView);
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d41 1
a41 1
import org.eclipse.gmf.runtime.diagram.ui.providers.internal.l10n.DiagramProvidersResourceManager;
a286 2
	private static final String BOOKMARK = "bookmark.gif"; //$NON-NLS-1$

d383 1
a383 1
				DiagramProvidersResourceManager.getInstance().getImage(BOOKMARK),
d387 1
a387 2
				DiagramProvidersResourceManager.getInstance().getImage(
					BOOKMARK), 50, true));
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a29 2
import org.eclipse.jface.util.Assert;

d37 1
d45 2
a46 2
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d53 1
d383 1
d386 1
a386 1
				IDecoratorTarget.Direction.NORTH_EAST, MapMode.DPtoLP(-4), true));
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2003.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d49 3
a51 3
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.Edge;
import com.ibm.xtools.notation.View;
@

