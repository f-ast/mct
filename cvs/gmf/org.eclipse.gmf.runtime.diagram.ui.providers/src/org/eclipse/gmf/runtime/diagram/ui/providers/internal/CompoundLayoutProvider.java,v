head	1.2;
access;
symbols
	v20081020-0700:1.2
	v20080924-1925:1.2
	v20080917-1925:1.2
	v20080916-2008:1.2
	v20080911-1728:1.2
	v20080722-1827:1.2
	v20080716-1600:1.2
	v20080716-1642:1.2
	R2_1_maintenance:1.2.0.6
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080503-1740:1.2
	v20080425-1959:1.2
	v20080417-1610:1.2
	v20080407-2250:1.2
	v20080407-0930:1.2
	v20080404-1111:1.2
	v20080328-1605:1.2
	v20080222-1200:1.2
	v20080215-1500:1.2
	v20080201-2010:1.2
	v20080201-0201:1.2
	v20071130-1111:1.2
	v20071108-0000:1.2
	v20070903-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.4
	R2_0:1.2
	R4_20:1.2
	v20070621-0000:1.2
	RC3_20:1.2
	v20070601-1400:1.2
	v20070518-1300:1.2
	bugzilla111892_group_support:1.2.0.2
	Root_bugzilla111892_group_support:1.2
	v20070504-1000:1.1
	v20070420-1000:1.1
	v20070413-1300:1.1
	v20070330-1300:1.1
	v20060316-0600:1.1
	v20070228-2000:1.1
	v20070221-1500:1.1
	v20070208-1800:1.1
	M4_20:1.1
	v20061218-1500:1.1
	v20061214-0000:1.1
	M3_20:1.1
	v20061013-1330:1.1
	v20060919-0800:1.1
	M1_20:1.1
	v20060803-1200:1.1
	v20060728-0500:1.1
	v20060721-1130:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060616-1200:1.1
	v20060609-1400:1.1
	v20060531-1730:1.1
	v20060530-1930:1.1
	v20060519-0800:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1;
locks; strict;
comment	@# @;


1.2
date	2007.05.16.17.10.01;	author ahunter;	state Exp;
branches;
next	1.1;
commitid	4e6d464b3ae84567;

1.1
date	2006.02.24.23.29.50;	author mmostafa;	state Exp;
branches;
next	;


desc
@@


1.2
log
@gmf-head ahunter 070516 Add missing Copyright
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.providers.internal;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Insets;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.draw2d.graph.CompoundDirectedGraph;
import org.eclipse.draw2d.graph.CompoundDirectedGraphLayout;
import org.eclipse.draw2d.graph.DirectedGraph;
import org.eclipse.draw2d.graph.DirectedGraphLayout;
import org.eclipse.draw2d.graph.Edge;
import org.eclipse.draw2d.graph.EdgeList;
import org.eclipse.draw2d.graph.Node;
import org.eclipse.draw2d.graph.NodeList;
import org.eclipse.draw2d.graph.Subgraph;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeCompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;

public abstract class CompoundLayoutProvider
    extends CompositeLayoutProvider {
    
    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#provides(org.eclipse.gmf.runtime.common.core.service.IOperation)
     */
    /*public boolean provides(IOperation operation) {
      if (operation instanceof ILayoutNodeOperation) {
            Iterator nodes = ((ILayoutNodeOperation) operation)
                .getLayoutNodes().listIterator();
            if (nodes.hasNext()) {
                View node = ((ILayoutNode) nodes.next()).getNode();
                View container = (View) node.eContainer();
                if (!(container instanceof Diagram)
                    || !((Diagram) container).getType().equals("logic")) //$NON-NLS-1$
                    return false;
            }
        } else {
            return false;
        }
        IAdaptable layoutHint = ((ILayoutNodeOperation) operation)
            .getLayoutHint();
        String layoutType = (String) layoutHint.getAdapter(String.class);
        return LayoutType.DEFAULT.equals(layoutType);
    }*/

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#build_nodes(java.util.List, java.util.Map, org.eclipse.draw2d.graph.Subgraph)
     */
    protected NodeList build_nodes(List selectedObjects, Map editPartToNodeDict, Subgraph rootGraph) {
        ListIterator li = selectedObjects.listIterator();
        NodeList nodes = new NodeList();
        while (li.hasNext()) {
            IGraphicalEditPart gep = (IGraphicalEditPart) li.next();
            boolean hasChildren  = hasChildren(gep);
            if (!(gep instanceof IBorderItemEditPart) &&
                 ( gep instanceof ShapeEditPart ||
                   gep instanceof ShapeCompartmentEditPart)) {
                GraphicalEditPart ep = (GraphicalEditPart) gep;
                Point position = ep.getFigure().getBounds().getLocation();
                if (minX == -1) {
                    minX = position.x;
                    minY = position.y;
                } else {
                    minX = Math.min(minX, position.x);
                    minY = Math.min(minY, position.y);
                }
                Node n = null;
                if (hasChildren){
                    if (rootGraph!=null)
                        n = new Subgraph(ep,rootGraph);
                    else
                        n = new Subgraph(ep);
                }
                else{
                    if (rootGraph!=null)
                        n = new Node(ep,rootGraph);
                    else
                        n = new Node(ep);
                }
                adjustNodePadding(n,editPartToNodeDict);
                Dimension size = ep.getFigure().getBounds().getSize();
                setNodeMetrics(n, new Rectangle(position.x, position.y,
                    size.width, size.height));
                editPartToNodeDict.put(ep, n);
                nodes.add(n);
                if (hasChildren){
                    nodes.addAll(build_nodes(gep.getChildren(),editPartToNodeDict,(Subgraph)n));
                }
            }
        }
        return nodes;
    }

    

       /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#createGraphLayout()
     */
    protected DirectedGraphLayout createGraphLayout() {
        return new CompoundDirectedGraphLayout();
    }
    
    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.providers.internal.DefaultProvider#createChangeBoundsCommands(org.eclipse.draw2d.graph.DirectedGraph, org.eclipse.draw2d.geometry.Point)
     */
    protected Command createNodeChangeBoundCommands(DirectedGraph g, Point diff) {
        CompoundCommand cc = new CompoundCommand(""); //$NON-NLS-1$
        ListIterator vi = ((CompoundDirectedGraph)g).subgraphs.listIterator();
        createSubCommands(diff, vi, cc);
        vi = g.nodes.listIterator();
        createSubCommands(diff, vi, cc);
        if (cc.isEmpty())
            return null;
        return cc;
    }

    protected void postProcessGraph(DirectedGraph g, Hashtable editPartToNodeDict) {
        EdgeList edges = g.edges;
        NodeList nodes = g.nodes;
        virtualNodesToNodes virtualNodesNodes = new virtualNodesToNodes();
        for (Iterator edgeIter = edges.iterator(); edgeIter.hasNext();) {
            Edge element = (Edge) edgeIter.next();
            Node source = element.source;
            Node target = element.target;
            boolean sourceHandled = true;
            boolean targetHandled = true;
            Subgraph sg = virtualNodesNodes.getVirtualContainer(source);
            Subgraph sg1 = virtualNodesNodes.getVirtualContainer(target);
            if (sg==null){
                sourceHandled = false;
                sg = sg1;
            }
            if (sg1==null)
                targetHandled = false;
            if (sourceHandled == false && targetHandled==false){
                sg = new Subgraph(null,source.getParent());
                sg.setPadding(new Insets(0));
                nodes.add(sg);
            }
            if (!sourceHandled){
                addNode(sg, source);
                virtualNodesNodes.addNode(sg, source);
            }
            if (!targetHandled){
                addNode(sg, target);
                virtualNodesNodes.addNode(sg, target);
            }
        }
        
        for (Iterator iter = nodes.iterator(); iter.hasNext();) {
            Node element = (Node) iter.next();
            if (element.getParent() !=null &&
                element instanceof Subgraph &&
                element.data == null &&
                element.getParent().members.size()==1){
                Subgraph sg = (Subgraph)element;
                sg.getParent().members.remove(0);
                sg.getParent().members.addAll(sg.members);
                for (Iterator iterator = sg.getParent().members.iterator(); iterator
                    .hasNext();) {
                    Node node = (Node) iterator.next();
                    node.setParent(sg.getParent());
                }
                
                iter.remove();
            }
        }
    }
    
    private void addNode(Subgraph parent, Node node) {
        if (node.getParent()!=null){
            node.getParent().members.remove(node);
        }
        node.setParent(parent);
        parent.addMember(node);
    }
        
    private class virtualNodesToNodes extends HashMap{
        Set virtualNodes = new HashSet();
        public void addNode(Subgraph sg, Node node){
            virtualNodes.add(sg);
            put(node, sg);
        }
        
        public Subgraph getVirtualContainer(Node node){
            return (Subgraph)get(node);
        }
        
        public NodeList getVirtualNodes(){
            NodeList nodeList = new NodeList();
            nodeList.addAll(virtualNodes);
            return nodeList;
        }
    }
}
@


1.1
log
@bugzilla 110698 gmf-head mmostafa 060224 Auto-layout doesn't layout out connections between nested nodes and top level nodes
@
text
@d1 11
@

