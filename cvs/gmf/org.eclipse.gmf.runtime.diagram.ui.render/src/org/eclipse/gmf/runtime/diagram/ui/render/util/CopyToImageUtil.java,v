head	1.18;
access;
symbols
	v20081020-0700:1.18
	v20080903-1520:1.18
	v20080903-1510:1.16.2.2
	v20080722-1827:1.16
	R2_1_maintenance:1.16.0.2
	Root_R2_1_maintenance:1.16
	R2_1_0:1.16
	v20080603-1553:1.16
	v20080527-1255:1.16
	v20080512-1200:1.15
	v20080425-1959:1.15
	v20080328-1605:1.15
	v20080322-0000:1.14
	v20080222-1200:1.14
	v20080114-1111:1.14
	v20071124-0000:1.12
	v20071108-0000:1.14
	v20071003-0000:1.14
	v20070903-0000:1.13
	v20070809-0000:1.12
	R2_0_maintenance:1.12.0.2
	R2_0:1.12
	R4_20:1.12
	v20070621-0000:1.12
	RC3_20:1.12
	v20070614-1400:1.12
	v20070601-1400:1.11
	v20070518-1300:1.11
	v20070330-1300:1.11
	v20060316-0600:1.11
	v20070208-1800:1.11
	v20070202-0200:1.7.2.4
	v20070105-1200:1.7.2.4
	M4_20:1.11
	v20061218-1500:1.7.2.4
	v20061218-1200:1.11
	v20061214-0000:1.11
	M3_20:1.9
	v20061117-0800:1.9
	v20061020-1000:1.7.2.2
	v20061013-1330:1.8
	v20061012-1100:1.7.2.1
	v20060919-0800:1.7.2.1
	M1_20:1.7
	v20060721-1130:1.7
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060531-1730:1.7
	v20060519-0800:1.7
	I20060428-1300:1.7
	I20060424-0300:1.7
	M6_10:1.7
	I20060407-1200:1.7
	I20060331-1000:1.7
	I20060324-0300:1.7
	I20060317-1300:1.7
	I20060317-1200:1.7
	I20060316-1300:1.7
	I20060309-1300:1.7
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.6
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051208-2000:1.4
	I20051201-1800:1.4
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;


1.18
date	2008.08.27.20.35.15;	author aboyko;	state Exp;
branches;
next	1.17;
commitid	6ab148b5ba834567;

1.17
date	2008.08.27.20.25.22;	author aboyko;	state Exp;
branches;
next	1.16;
commitid	5aad48b5b8314567;

1.16
date	2008.05.23.03.17.36;	author aboyko;	state Exp;
branches
	1.16.2.1;
next	1.15;
commitid	499d4836374a4567;

1.15
date	2008.03.28.18.13.58;	author ahunter;	state Exp;
branches;
next	1.14;
commitid	175547ed35664567;

1.14
date	2007.09.21.15.39.45;	author aboyko;	state Exp;
branches;
next	1.13;
commitid	57b346f3e5c04567;

1.13
date	2007.07.31.18.31.07;	author aboyko;	state Exp;
branches;
next	1.12;
commitid	6b8646af7fe94567;

1.12
date	2007.06.11.20.44.58;	author aboyko;	state Exp;
branches;
next	1.11;
commitid	3008466db44a4567;

1.11
date	2006.11.22.12.55.19;	author ldamus;	state Exp;
branches;
next	1.10;
commitid	56f3456448b74567;

1.10
date	2006.11.20.22.06.18;	author crevells;	state Exp;
branches;
next	1.9;
commitid	27a7456226da4567;

1.9
date	2006.10.18.00.14.53;	author ahunter;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.03.15.04.50;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.07.19.38.00;	author cmahoney;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.02.21.16.07.12;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.12.16.49.25;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.08.16.02.18;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.29.16;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.12;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.55;	author sshaw;	state Exp;
branches;
next	;

1.7.2.1
date	2006.09.13.16.43.32;	author ahunter;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2006.10.18.00.09.41;	author ahunter;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2006.11.20.21.58.24;	author crevells;	state Exp;
branches;
next	1.7.2.4;
commitid	3002456225004567;

1.7.2.4
date	2006.11.22.12.35.48;	author ldamus;	state Exp;
branches;
next	;
commitid	4485456444244567;

1.16.2.1
date	2008.08.27.20.20.08;	author aboyko;	state Exp;
branches;
next	1.16.2.2;
commitid	579848b5b6f64567;

1.16.2.2
date	2008.08.27.20.34.30;	author aboyko;	state Exp;
branches;
next	;
commitid	694b48b5ba564567;


desc
@@


1.18
log
@Removed unnecessary import from the previous commit
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.render.util;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collections;
import java.util.List;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.gmf.runtime.common.core.command.FileModificationValidator;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.OffscreenEditPartFactory;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.image.ImageFileFormat;
import org.eclipse.gmf.runtime.diagram.ui.image.PartPositionInfo;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
import org.eclipse.gmf.runtime.diagram.ui.render.clipboard.DiagramGenerator;
import org.eclipse.gmf.runtime.diagram.ui.render.clipboard.DiagramImageGenerator;
import org.eclipse.gmf.runtime.diagram.ui.render.clipboard.DiagramSVGGenerator;
import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderPlugin;
import org.eclipse.gmf.runtime.diagram.ui.util.DiagramEditorUtil;
import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.Draw2dRenderPlugin;
import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.image.ImageExporter;
import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.SVGImage;
import org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.svg.SVGImageConverter;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
import org.eclipse.swt.graphics.ImageLoader;
import org.eclipse.swt.graphics.PaletteData;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.swt.widgets.Shell;

/**
 * Utility class to render a diagram to an image file.
 * 
 * @@author Anthony Hunter, cmahoney
 */
public class CopyToImageUtil {

    /**
     * Creates a <code>DiagramEditPart</code> given the <code>Diagram</code>
     * without opening an editor.
     * 
     * @@param diagram
     *            the <code>Diagram</code>
     * @@param shell
     *            An out parameter for the shell that must be disposed after the
     *            copy to image operation has completed.
     * @@param preferencesHint
     *            The preference hint that is to be used to find the appropriate
     *            preference store from which to retrieve diagram preference
     *            values. The preference hint is mapped to a preference store in
     *            the preference registry <@@link DiagramPreferencesRegistry>.
     * @@return the new populated <code>DiagramEditPart</code>
     */
    public DiagramEditPart createDiagramEditPart(Diagram diagram, Shell shell,
            PreferencesHint preferencesHint) {
    	return OffscreenEditPartFactory.getInstance().createDiagramEditPart(
                diagram, shell, preferencesHint);
    }

    /**
     * Copies the diagram to an image file in the specified format.
     * 
     * @@param diagram
     *            the diagram to be copied
     * @@param destination
     *            the destination file, including path and file name
     * @@param format
     *            the image file format
     * @@param monitor
     *            progress monitor.
     * @@param preferencesHint
     *            The preference hint that is to be used to find the appropriate
     *            preference store from which to retrieve diagram preference
     *            values. The preference hint is mapped to a preference store in
     *            the preference registry <@@link DiagramPreferencesRegistry>.
     * @@return A list of {@@link PartPositionInfo} objects with details regarding
     *         each top-level editpart on the diagram represented in the image.
     * @@exception CoreException
     *                if this method fails
     */
    public List copyToImage(Diagram diagram, IPath destination,
            ImageFileFormat format, IProgressMonitor monitor,
            PreferencesHint preferencesHint)
        throws CoreException {

        Trace.trace(DiagramUIRenderPlugin.getInstance(),
            "Copy diagram to Image " + destination + " as " + format); //$NON-NLS-1$ //$NON-NLS-2$
        
        List partInfo = Collections.EMPTY_LIST;
        
        DiagramEditor openedDiagramEditor = DiagramEditorUtil.findOpenedDiagramEditorForID(ViewUtil.getIdStr(diagram));
        if (openedDiagramEditor != null) {
            DiagramGenerator generator = copyToImage(openedDiagramEditor.getDiagramEditPart(),
                    destination, format, monitor);
                partInfo = generator.getDiagramPartInfo(openedDiagramEditor.getDiagramEditPart());
        } else {
	
	        Shell shell = new Shell();
	        try {
	            DiagramEditPart diagramEditPart = createDiagramEditPart(diagram,
	                shell, preferencesHint);
	            Assert.isNotNull(diagramEditPart);
	            DiagramGenerator generator = copyToImage(diagramEditPart,
	                destination, format, monitor);
	            partInfo = generator.getDiagramPartInfo(diagramEditPart);
	        } finally {
	            shell.dispose();
	        }
        }

        return partInfo;
    }
    
    /**
     * Creates an image of the diagram in the specified image file format. The diagram image is scaled to fit in
     * the maxWidth, maxHeight window. The image is returned as a byte array
     * 
     * @@param diagram diagram model
     * @@param maxWidth the max width of the image
     * @@param maxHeight the max height of the image
     * @@param format image format
     * @@param monitor progress monitor
     * @@param preferencesHint preference hint for the diagram
     * @@param useMargins true if a 10 pixel margin is required around the diagram
     * @@return the image as array of bytes
     * @@throws CoreException
     */
    public byte [] copyToImageByteArray(Diagram diagram, int maxWidth, int maxHeight, ImageFileFormat format, IProgressMonitor monitor, PreferencesHint preferencesHint, boolean useMargins) throws CoreException {
        DiagramEditor openedDiagramEditor = DiagramEditorUtil.findOpenedDiagramEditorForID(ViewUtil.getIdStr(diagram));
        if (openedDiagramEditor != null) {
            return copyToImageByteArray(openedDiagramEditor.getDiagramEditPart(), null, maxWidth, maxHeight, format, monitor, useMargins);
        } else {
	        Shell shell = new Shell();
	        try {
	            DiagramEditPart diagramEditPart = createDiagramEditPart(diagram,
	                shell, preferencesHint);
	            Assert.isNotNull(diagramEditPart);
	            return copyToImageByteArray(diagramEditPart, null, maxWidth, maxHeight, format, monitor, useMargins);
	        } finally {
	            shell.dispose();
	        }
        }
    }
    
    /**
     * Creates an image of the editparts in the specified image file format. The editparts image is scaled to fit in
     * the maxWidth, maxHeight window. The image is returned as a byte array
     * 
     * @@param diagramEP diagram editpart
     * @@param editParts editparts to draw on the image
     * @@param maxHeight the max height of the image
     * @@param format image format
     * @@param monitor progress monitor
     * @@param preferencesHint preference hint for the diagram
     * @@param useMargins true if a 10 pixel margin is required around the diagram
     * @@return the image as array of bytes
     * @@throws CoreException
     */
    public byte [] copyToImageByteArray(DiagramEditPart diagramEP, List editParts, int maxWidth, int maxHeight, ImageFileFormat format, IProgressMonitor monitor, boolean useMargins) throws CoreException {
        Assert.isNotNull(diagramEP);
    	ByteArrayOutputStream stream = new ByteArrayOutputStream();
        DiagramGenerator gen = getDiagramGenerator(diagramEP, format);
        if (editParts == null || editParts.isEmpty()) {
        	editParts = diagramEP.getPrimaryEditParts() ;
        }
		if (format.equals(ImageFileFormat.SVG)
				|| format.equals(ImageFileFormat.PDF)) {
			gen.createConstrainedSWTImageDecriptorForParts(editParts, maxWidth, maxHeight, useMargins);
			monitor.worked(1);
			saveToOutputStream(stream, (DiagramSVGGenerator)gen, format, monitor);
		} else {
			Image image = gen.createConstrainedSWTImageDecriptorForParts(editParts, maxWidth, maxHeight, useMargins).createImage();
			monitor.worked(1);
			saveToOutputStream(stream, image, format, monitor);;
			image.dispose();
		}
		monitor.worked(1);
    	return stream.toByteArray();
    }
    
    public List copyToConstrainedImage(Diagram diagram, IPath destination,
            ImageFileFormat format, int maxWidth, int maxHeight, IProgressMonitor monitor,
            PreferencesHint preferencesHint, boolean useMargins)
        throws CoreException {
    	
        List partInfo = Collections.EMPTY_LIST;
        
        DiagramEditor openedDiagramEditor = DiagramEditorUtil.findOpenedDiagramEditorForID(ViewUtil.getIdStr(diagram));
        if (openedDiagramEditor != null) {
        	DiagramEditPart diagramEP = openedDiagramEditor.getDiagramEditPart();
            DiagramGenerator generator = copyToConstrainedImage(diagramEP,
                    destination, diagramEP.getPrimaryEditParts(), format, maxWidth, maxHeight, monitor, useMargins);
            partInfo = generator.getConstrainedDiagramPartInfo(openedDiagramEditor.getDiagramEditPart(), maxWidth, maxHeight, useMargins);
        } else {
	
	        Shell shell = new Shell();
	        try {
	            DiagramEditPart diagramEP = createDiagramEditPart(diagram,
	                shell, preferencesHint);
	            Assert.isNotNull(diagramEP);
	            DiagramGenerator generator = copyToConstrainedImage(diagramEP,
	                destination, diagramEP.getPrimaryEditParts(), format, maxWidth, maxHeight, monitor, useMargins);
	            partInfo = generator.getConstrainedDiagramPartInfo(diagramEP, maxWidth, maxHeight, useMargins);
	        } finally {
	            shell.dispose();
	        }
        }

        return partInfo;
    }
    
    public DiagramGenerator copyToConstrainedImage(DiagramEditPart diagramEP, IPath destination, List editParts, ImageFileFormat format, int maxWidth, int maxHeight, IProgressMonitor monitor, boolean useMargins) throws CoreException {
    	DiagramGenerator gen = getDiagramGenerator(diagramEP, format);
    	copyToConstrainedImage(gen, editParts, destination, format, maxWidth, maxHeight, monitor, useMargins);
        monitor.worked(1);
        return gen;
    }
    
    private void copyToConstrainedImage(DiagramGenerator gen, List editParts,
			IPath destination, 
			ImageFileFormat format, int maxWidth, int maxHeight, IProgressMonitor monitor, boolean useMargins)
			throws CoreException {
		boolean found = false;
		if (format.equals(ImageFileFormat.SVG)
				|| format.equals(ImageFileFormat.PDF)) {
			gen.createConstrainedSWTImageDecriptorForParts(editParts, maxWidth, maxHeight, useMargins);
			monitor.worked(1);
			saveToFile(destination, (DiagramSVGGenerator) gen, format, monitor);
			found = true;
		} else if (format.equals(ImageFileFormat.JPEG)
				|| format.equals(ImageFileFormat.PNG)) {

			String exportFormat = ImageExporter.JPEG_FILE;
			if (format.equals(ImageFileFormat.PNG))
				exportFormat = ImageExporter.PNG_FILE;

			java.awt.Image image = gen.createConstrainedAWTImageForParts(editParts, maxWidth, maxHeight, useMargins);
			monitor.worked(1);
			if (image instanceof BufferedImage) {
				ImageExporter.exportToFile(destination, (BufferedImage) image,
						exportFormat, monitor);
				found = true;
			}
		}

		if (!found) {
			Image image = gen.createConstrainedSWTImageDecriptorForParts(editParts,
					maxWidth, maxHeight, useMargins).createImage();
			monitor.worked(1);
			saveToFile(destination, image, format, monitor);
			image.dispose();
		}
	}
    
    /**
     * Copies the diagram to an image file in the specified format.
     * 
     * @@param diagramEP
     *            the diagram editpart
     * @@param destination
     *            the destination file, including path and file name
     * @@param format
     *            the image format to create.
     * @@param monitor
     *            progress monitor.
     * @@return The diagram generator used to copy the image.
     * @@exception CoreException
     *                if this method fails
     */
    public DiagramGenerator copyToImage(DiagramEditPart diagramEP,
            IPath destination, ImageFileFormat format, IProgressMonitor monitor)
        throws CoreException {
        DiagramGenerator gen = getDiagramGenerator(diagramEP, format);
        List editParts = diagramEP.getPrimaryEditParts();
        copyToImage(gen, editParts, gen.calculateImageRectangle(editParts), destination, format, monitor);
        monitor.worked(1);
        return gen;
    }

    /**
     * Copies the diagram to an image file in the specified format.
     * 
     * @@param diagramEP
     *            the diagram edit part
     * @@param selection
     *            selected shapes in the diagram.
     * @@param destination
     *            the destination file, including path and file name
     * @@param format
     *            the image format to create.
     * @@param monitor
     *            progress monitor.
     * @@exception CoreException
     *                if this method fails
     */
    public void copyToImage(DiagramEditPart diagramEP, List selection,
            IPath destination, ImageFileFormat format, IProgressMonitor monitor)
        throws CoreException {    	
    	DiagramGenerator gen = getDiagramGenerator(diagramEP, format);
    	copyToImage(gen, selection, gen.calculateImageRectangle(selection), destination, format, monitor);
        monitor.worked(1);
    }
    
    /**
     * Creates the appropriate <code>DiagramGenerator</code> from <code>DiagramEditPart</code>
     * based on the supplied <code>ImageFileFormat</code>
     * 
     * @@param diagramEP diagram editpart
     * @@param format image file format
     * @@return appropriate diagram generator
     */
    protected DiagramGenerator getDiagramGenerator(DiagramEditPart diagramEP, ImageFileFormat format) {
        if (format.equals(ImageFileFormat.SVG) || format.equals(ImageFileFormat.PDF)) {
            return new DiagramSVGGenerator(diagramEP);
        } else {
        	return new DiagramImageGenerator(diagramEP);
        }
    }
    
    /**
	 * Generates image of editparts with on a given image rectangle and creates
	 * the specified image file containing this image. The image rectangle may
	 * be the limitation for the editparts displayed on the image
	 * 
	 * @@param gen
	 *            diagram generator
	 * @@param editParts
	 *            editparts to be present on the image
	 * @@param imageRect
	 *            clipping rectangle for the image
	 * @@param destination
	 *            image file path
	 * @@param format
	 *            image file format
	 * @@param monitor
	 *            progress monitor
	 * @@throws CoreException
	 */
    protected void copyToImage(DiagramGenerator gen, List editParts,
			org.eclipse.swt.graphics.Rectangle imageRect, IPath destination,
			ImageFileFormat format, IProgressMonitor monitor)
			throws CoreException {
		boolean found = false;
		if (format.equals(ImageFileFormat.SVG)
				|| format.equals(ImageFileFormat.PDF)) {
			gen.createSWTImageDescriptorForParts(editParts, imageRect);
			monitor.worked(1);
			saveToFile(destination, (DiagramSVGGenerator) gen, format, monitor);
			found = true;
		} else if (format.equals(ImageFileFormat.JPEG)
				|| format.equals(ImageFileFormat.PNG)) {

			String exportFormat = ImageExporter.JPEG_FILE;
			if (format.equals(ImageFileFormat.PNG))
				exportFormat = ImageExporter.PNG_FILE;

			java.awt.Image image = gen.createAWTImageForParts(editParts,
					imageRect);
			monitor.worked(1);
			if (image instanceof BufferedImage) {
				ImageExporter.exportToFile(destination, (BufferedImage) image,
						exportFormat, monitor);
				found = true;
			}
		}

		if (!found) {
			Image image = gen.createSWTImageDescriptorForParts(editParts,
					imageRect).createImage();
			monitor.worked(1);
			saveToFile(destination, image, format, monitor);
			image.dispose();
		}
	}

    /**
	 * Saves the image to a file.
	 * 
	 * @@param destination
	 *            the destination file, including path and file name
	 * @@param image
	 *            the SWT image
	 * @@param imageFormat
	 *            the selected image format
	 * @@param monitor
	 *            progress monitor
	 * @@exception CoreException
	 *                if this method fails
	 */
    protected void saveToFile(IPath destination, Image image,
            ImageFileFormat imageFormat, IProgressMonitor monitor)
        throws CoreException {

        IStatus fileModificationStatus = createFile(destination);
        if (!fileModificationStatus.isOK()) {
        	// can't write to the file
        	return;
        }
        
        try {
        	FileOutputStream stream = new FileOutputStream(destination.toOSString());
            saveToOutputStream(stream, image, imageFormat, monitor);
            stream.close();
        } catch (Exception e) {
            Log.error(Draw2dRenderPlugin.getInstance(), IStatus.ERROR, e
                    .getMessage(), e);
                IStatus status =
                    new Status(IStatus.ERROR, "exportToFile", IStatus.OK, //$NON-NLS-1$
                        e.getMessage(), null);
                throw new CoreException(status);
        }
        
        refreshLocal(destination);
    }
    
    private void saveToOutputStream(OutputStream stream, Image image, ImageFileFormat imageFormat, IProgressMonitor monitor) {
        monitor.worked(1);
        
        ImageData imageData = image.getImageData();
        
        if (imageFormat.equals(ImageFileFormat.GIF) ||
                imageFormat.equals(ImageFileFormat.BMP))
            imageData = createImageData(image); 

        monitor.worked(1);
        ImageLoader imageLoader = new ImageLoader();
        imageLoader.data = new ImageData[] {imageData};
        imageLoader.logicalScreenHeight = image.getBounds().width;
        imageLoader.logicalScreenHeight = image.getBounds().height;
        imageLoader.save(stream, imageFormat.getOrdinal());
        
        monitor.worked(1);
    }

    
    /**
     * Saves an SVG DOM to a file.
     * 
     * @@param destination
     *            the destination file, including path and file name
     * @@param generator
     *            the svg generator for a diagram, used to write
     * @@param monitor
     *            the progress monitor
     * @@exception CoreException
     *                if this method fails
     */
    protected void saveSVGToFile(IPath destination,
			DiagramSVGGenerator generator, IProgressMonitor monitor)
			throws CoreException {
		saveToFile(destination, generator, ImageFileFormat.SVG, monitor);
	}
        
    
    /**
	 * Saves an SVG or PDF files.
	 * 
	 * @@param destination
	 *            the destination file, including path and file name
	 * @@param generator
	 *            the svg generator for a diagram, used to write
	 * @@param format
	 *            currently supports SVG or PDF
	 * @@param monitor
	 *            the progress monitor
	 * @@exception CoreException
	 *                if this method fails
	 */
    protected void saveToFile(IPath destination,
            DiagramSVGGenerator generator, ImageFileFormat format, IProgressMonitor monitor)
        throws CoreException {

		IStatus fileModificationStatus = createFile(destination);
		if (!fileModificationStatus.isOK()) {
			// can't write to the file
			return;
		}
		monitor.worked(1);

		try {
			FileOutputStream os = new FileOutputStream(destination.toOSString());
			monitor.worked(1);
			saveToOutputStream(os, generator, format, monitor);
			os.close();
			monitor.worked(1);
			refreshLocal(destination);
		} catch (IOException ex) {
			Log.error(DiagramUIRenderPlugin.getInstance(), IStatus.ERROR, ex
					.getMessage(), ex);
			IStatus status = new Status(IStatus.ERROR,
					"exportToFile", IStatus.OK, //$NON-NLS-1$
					ex.getMessage(), null);
			throw new CoreException(status);
		}
	}
        
    private void saveToOutputStream(OutputStream stream, DiagramSVGGenerator generator, ImageFileFormat format, IProgressMonitor monitor) throws CoreException {
		if (format == ImageFileFormat.PDF) {
			SVGImageConverter.exportToPDF((SVGImage) generator.getRenderedImage(), stream);
		} else if (format == ImageFileFormat.SVG) {
			generator.stream(stream);
		} else {
			throw new IllegalArgumentException(
					"Unexpected format: " + format.getName()); //$NON-NLS-1$
		}
		monitor.worked(1);
    }
    

    /**
     * create a file in the workspace if the destination is in a project in the
     * workspace.
     * 
     * @@param destination
     *            the destination file.
     * @@return the status from validating the file for editing
     * @@exception CoreException
     *                if this method fails
     */
    private IStatus createFile(IPath destination)
        throws CoreException {
        IFile file = ResourcesPlugin.getWorkspace().getRoot()
            .getFileForLocation(destination);
        if (file != null && !file.exists()) {
            File osFile = new File(destination.toOSString());
            if (osFile.exists()) {
                file.refreshLocal(IResource.DEPTH_ZERO, null);
            } else {
                ResourcesPlugin.getWorkspace().getRoot().refreshLocal(
                    IResource.DEPTH_INFINITE, null);
                InputStream input = new ByteArrayInputStream(new byte[0]);
                file.create(input, false, null);
            }
        }

        if (file != null) {
        	return FileModificationValidator.approveFileModification(new IFile[] {file});
        }
        return Status.OK_STATUS;
    }

    /**
     * refresh the file in the workspace if the destination is in a project in
     * the workspace.
     * 
     * @@param destination
     *            the destination file.
     * @@exception CoreException
     *                if this method fails
     */
    private void refreshLocal(IPath destination)
        throws CoreException {
        IFile file = ResourcesPlugin.getWorkspace().getRoot()
            .getFileForLocation(destination);
        if (file != null) {
            file.refreshLocal(IResource.DEPTH_ZERO, null);
        }
    }

    /**
     * Retrieve the image data for the image, using a palette of at most 256
     * colours.
     * 
     * @@param image
     *            the SWT image.
     * @@return new image data.
     */
    private ImageData createImageData(Image image) {

        ImageData imageData = image.getImageData();

        /**
         * If the image depth is 8 bits or less, then we can use the existing
         * image data.
         */
        if (imageData.depth <= 8) {
            return imageData;
        }

        /**
         * get an 8 bit imageData for the image
         */
        ImageData newImageData = get8BitPaletteImageData(imageData);

        /**
         * if newImageData is null, it has more than 256 colours. Use the web
         * safe pallette to get an 8 bit image data for the image.
         */
        if (newImageData == null) {
            newImageData = getWebSafePalletteImageData(imageData);
        }

        return newImageData;
    }

    /**
     * Retrieve an image data with an 8 bit palette for an image. We assume that
     * the image has less than 256 colours.
     * 
     * @@param imageData
     *            the imageData for the image.
     * @@return the new 8 bit imageData or null if the image has more than 256
     *         colours.
     */
    private ImageData get8BitPaletteImageData(ImageData imageData) {
        PaletteData palette = imageData.palette;
        RGB colours[] = new RGB[256];
        PaletteData newPaletteData = new PaletteData(colours);
        ImageData newImageData = new ImageData(imageData.width,
            imageData.height, 8, newPaletteData);

        int lastPixel = -1;
        int newPixel = -1;
        for (int i = 0; i < imageData.width; ++i) {
            for (int j = 0; j < imageData.height; ++j) {
                int pixel = imageData.getPixel(i, j);

                if (pixel != lastPixel) {
                    lastPixel = pixel;

                    RGB colour = palette.getRGB(pixel);
                    for (newPixel = 0; newPixel < 256; ++newPixel) {
                        if (colours[newPixel] == null) {
                            colours[newPixel] = colour;
                            break;
                        }
                        if (colours[newPixel].equals(colour))
                            break;
                    }

                    if (newPixel >= 256) {
                        /**
                         * Diagram has more than 256 colors, return null
                         */
                        return null;
                    }
                }

                newImageData.setPixel(i, j, newPixel);
            }
        }

        RGB colour = new RGB(0, 0, 0);
        for (int k = 0; k < 256; ++k) {
            if (colours[k] == null)
                colours[k] = colour;
        }

        return newImageData;
    }

    /**
     * If the image has less than 256 colours, simply create a new 8 bit palette
     * and map the colours to the new palatte.
     */
    private ImageData getWebSafePalletteImageData(ImageData imageData) {
        PaletteData palette = imageData.palette;
        RGB[] webSafePallette = getWebSafePallette();
        PaletteData newPaletteData = new PaletteData(webSafePallette);
        ImageData newImageData = new ImageData(imageData.width,
            imageData.height, 8, newPaletteData);

        int lastPixel = -1;
        int newPixel = -1;
        for (int i = 0; i < imageData.width; ++i) {
            for (int j = 0; j < imageData.height; ++j) {
                int pixel = imageData.getPixel(i, j);

                if (pixel != lastPixel) {
                    lastPixel = pixel;

                    RGB colour = palette.getRGB(pixel);
                    RGB webSafeColour = getWebSafeColour(colour);
                    for (newPixel = 0; newPixel < 256; ++newPixel) {
                        if (webSafePallette[newPixel].equals(webSafeColour))
                            break;
                    }

                    Assert.isTrue(newPixel < 216);
                }
                newImageData.setPixel(i, j, newPixel);
            }
        }

        return newImageData;
    }

    /**
     * Retrieves a web safe colour that closely matches the provided colour.
     * 
     * @@param colour
     *            a colour.
     * @@return the web safe colour.
     */
    private RGB getWebSafeColour(RGB colour) {
        int red = Math.round((colour.red + 25) / 51) * 51;
        int green = Math.round((colour.green + 25) / 51) * 51;
        int blue = Math.round((colour.blue + 25) / 51) * 51;
        return new RGB(red, green, blue);
    }

    /**
     * Retrieves a web safe pallette. Our palette will be 216 web safe colours
     * and the remaining filled with white.
     * 
     * @@return array of 256 colours.
     */
    private RGB[] getWebSafePallette() {
        RGB[] colours = new RGB[256];
        int i = 0;
        for (int red = 0; red <= 255; red = red + 51) {
            for (int green = 0; green <= 255; green = green + 51) {
                for (int blue = 0; blue <= 255; blue = blue + 51) {
                    RGB colour = new RGB(red, green, blue);
                    colours[i++] = colour;
                }
            }
        }

        RGB colour = new RGB(0, 0, 0);
        for (int k = 0; k < 256; ++k) {
            if (colours[k] == null)
                colours[k] = colour;
        }

        return colours;
    }

}@


1.17
log
@[239653] gmf_head aboyko 080827 [ImageSupport] Support DiagramPartInfo API for exporting the scaled down diagram to image
@
text
@a58 1
import org.eclipse.swt.widgets.Display;
@


1.16
log
@[233585] gmf_head aboyko 080522 [ImageSupport] Diagram Image Export API additions to enable BIRT integration
@
text
@d59 1
d87 2
a88 2
        return OffscreenEditPartFactory.getInstance().createDiagramEditPart(
            diagram, shell, preferencesHint);
d212 73
a303 1

d329 1
a329 2
        throws CoreException {
    	
@


1.16.2.1
log
@[239653] gmf_R2_1_maintenance aboyko 080827 [ImageSupport] Support DiagramPartInfo API for exporting the scaled down diagram to image
@
text
@a58 1
import org.eclipse.swt.widgets.Display;
d86 2
a87 2
    	return OffscreenEditPartFactory.getInstance().createDiagramEditPart(
                diagram, shell, preferencesHint);
a210 73
    public List copyToConstrainedImage(Diagram diagram, IPath destination,
            ImageFileFormat format, int maxWidth, int maxHeight, IProgressMonitor monitor,
            PreferencesHint preferencesHint, boolean useMargins)
        throws CoreException {
    	
        List partInfo = Collections.EMPTY_LIST;
        
        DiagramEditor openedDiagramEditor = DiagramEditorUtil.findOpenedDiagramEditorForID(ViewUtil.getIdStr(diagram));
        if (openedDiagramEditor != null) {
        	DiagramEditPart diagramEP = openedDiagramEditor.getDiagramEditPart();
            DiagramGenerator generator = copyToConstrainedImage(diagramEP,
                    destination, diagramEP.getPrimaryEditParts(), format, maxWidth, maxHeight, monitor, useMargins);
            partInfo = generator.getConstrainedDiagramPartInfo(openedDiagramEditor.getDiagramEditPart(), maxWidth, maxHeight, useMargins);
        } else {
	
	        Shell shell = new Shell();
	        try {
	            DiagramEditPart diagramEP = createDiagramEditPart(diagram,
	                shell, preferencesHint);
	            Assert.isNotNull(diagramEP);
	            DiagramGenerator generator = copyToConstrainedImage(diagramEP,
	                destination, diagramEP.getPrimaryEditParts(), format, maxWidth, maxHeight, monitor, useMargins);
	            partInfo = generator.getConstrainedDiagramPartInfo(diagramEP, maxWidth, maxHeight, useMargins);
	        } finally {
	            shell.dispose();
	        }
        }

        return partInfo;
    }
    
    public DiagramGenerator copyToConstrainedImage(DiagramEditPart diagramEP, IPath destination, List editParts, ImageFileFormat format, int maxWidth, int maxHeight, IProgressMonitor monitor, boolean useMargins) throws CoreException {
    	DiagramGenerator gen = getDiagramGenerator(diagramEP, format);
    	copyToConstrainedImage(gen, editParts, destination, format, maxWidth, maxHeight, monitor, useMargins);
        monitor.worked(1);
        return gen;
    }
    
    private void copyToConstrainedImage(DiagramGenerator gen, List editParts,
			IPath destination, 
			ImageFileFormat format, int maxWidth, int maxHeight, IProgressMonitor monitor, boolean useMargins)
			throws CoreException {
		boolean found = false;
		if (format.equals(ImageFileFormat.SVG)
				|| format.equals(ImageFileFormat.PDF)) {
			gen.createConstrainedSWTImageDecriptorForParts(editParts, maxWidth, maxHeight, useMargins);
			monitor.worked(1);
			saveToFile(destination, (DiagramSVGGenerator) gen, format, monitor);
			found = true;
		} else if (format.equals(ImageFileFormat.JPEG)
				|| format.equals(ImageFileFormat.PNG)) {

			String exportFormat = ImageExporter.JPEG_FILE;
			if (format.equals(ImageFileFormat.PNG))
				exportFormat = ImageExporter.PNG_FILE;

			java.awt.Image image = gen.createConstrainedAWTImageForParts(editParts, maxWidth, maxHeight, useMargins);
			monitor.worked(1);
			if (image instanceof BufferedImage) {
				ImageExporter.exportToFile(destination, (BufferedImage) image,
						exportFormat, monitor);
				found = true;
			}
		}

		if (!found) {
			Image image = gen.createConstrainedSWTImageDecriptorForParts(editParts,
					maxWidth, maxHeight, useMargins).createImage();
			monitor.worked(1);
			saveToFile(destination, image, format, monitor);
			image.dispose();
		}
	}
d230 1
d256 2
a257 1
        throws CoreException {    	
@


1.16.2.2
log
@Removed unnecessary import from the previous commit
@
text
@d59 1
@


1.15
log
@[212024] gmf-head jbruck 080328 GMF should support PDF format when saving diagrams as image file
@
text
@d16 1
d21 1
d49 1
d145 68
a332 1
		monitor.worked(1);
d353 23
a384 8
        
        IStatus fileModificationStatus = createFile(destination);
        if (!fileModificationStatus.isOK()) {
        	// can't write to the file
        	return;
        }
        
        monitor.worked(1);
d389 2
a390 2
        imageLoader.save(destination.toOSString(), imageFormat.getOrdinal());

a391 1
        refreshLocal(destination);
d442 1
a442 11

			if (format == ImageFileFormat.PDF) {
				SVGImageConverter.exportToPDF((SVGImage) generator.getRenderedImage(), os);
			} else if (format == ImageFileFormat.SVG) {
				generator.stream(os);
			} else {
				throw new IllegalArgumentException(
						"Unexpected format: " + format.getName()); //$NON-NLS-1$
			}
			monitor.worked(1);

d456 11
a466 1
  
d633 1
a633 1
                    for (newPixel = 0; newPixel < 216; ++newPixel) {
@


1.14
log
@[160731] gmf_HEAD aboyko 070921 [Printing] Compartments are printed incorrectly
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2007 IBM Corporation and others.
d48 2
d201 1
a201 1
        if (format.equals(ImageFileFormat.SVG)) {
d232 2
a233 1
		if (format.equals(ImageFileFormat.SVG)) {
d236 1
a236 1
			saveSVGToFile(destination, (DiagramSVGGenerator) gen, monitor);
d310 1
d324 22
a345 1
            DiagramSVGGenerator generator, IProgressMonitor monitor)
d348 6
a353 7
        IStatus fileModificationStatus = createFile(destination);
        if (!fileModificationStatus.isOK()) {
        	// can't write to the file
        	return;
        }
        
        monitor.worked(1);
d355 3
a357 1
        try {
d359 9
a367 2
            FileOutputStream os = new FileOutputStream(destination.toOSString());
            monitor.worked(1);
d369 15
a383 15
            generator.stream(os);
            monitor.worked(1);

            os.close();
            monitor.worked(1);
            refreshLocal(destination);
        } catch (IOException ex) {
            Log.error(DiagramUIRenderPlugin.getInstance(), IStatus.ERROR, ex
                .getMessage(), ex);
            IStatus status =
                new Status(IStatus.ERROR, "exportToFile", IStatus.OK, //$NON-NLS-1$
                    ex.getMessage(), null);
            throw new CoreException(status);
        }
    }
@


1.13
log
@[160386] gmf_head aboyko 070731 [ImageSupport] Save as Image fails when saving large diagrams
@
text
@d36 1
d41 1
d46 1
d112 2
a113 3
            "Copy diagram to Image " + destination + " as " + format); //$NON-NLS-1$ //$NON-NLS-2$ 

        Shell shell = new Shell();
d115 19
a133 10

        try {
            DiagramEditPart diagramEditPart = createDiagramEditPart(diagram,
                shell, preferencesHint);
            Assert.isNotNull(diagramEditPart);
            DiagramGenerator generator = copyToImage(diagramEditPart,
                destination, format, monitor);
            partInfo = generator.getDiagramPartInfo(diagramEditPart);
        } finally {
            shell.dispose();
d138 1
a138 1

@


1.12
log
@[192037] gmf_head aboyko 070611 SVG Image tried to save in a read-only folder must give an error message
@
text
@d26 1
a45 1
import org.eclipse.jface.util.Assert;
d147 3
a149 38
        boolean found = false;
        DiagramGenerator gen = null;
        if (format.equals(ImageFileFormat.SVG)) {

            gen = new DiagramSVGGenerator(diagramEP);
            gen.createSWTImageDescriptorForDiagram();

            monitor.worked(1);

            saveSVGToFile(destination, (DiagramSVGGenerator) gen, monitor);
            return gen;
        } else if (format.equals(ImageFileFormat.JPEG)
                || format.equals(ImageFileFormat.PNG)) {

            String exportFormat = ImageExporter.JPEG_FILE;
            if (format.equals(ImageFileFormat.PNG))
                exportFormat = ImageExporter.PNG_FILE;

            gen = new DiagramImageGenerator(diagramEP);
            java.awt.Image image = gen.createAWTImageForDiagram();
            if (image instanceof BufferedImage) {
                ImageExporter.exportToFile(destination, (BufferedImage) image,
                    exportFormat, monitor);
                found = true;
            }
        }

        if (!found) {
            gen = new DiagramImageGenerator(diagramEP);
            Image image = gen.createSWTImageDescriptorForDiagram()
                .createImage();

            monitor.worked(1);

            saveToFile(destination, image, format, monitor);
            image.dispose();
        }

d173 3
a175 37

        boolean found = false;
        if (format.equals(ImageFileFormat.SVG)) {

            DiagramSVGGenerator gen = new DiagramSVGGenerator(diagramEP);
            gen.createSWTImageDescriptorForParts(selection);

            monitor.worked(1);

            saveSVGToFile(destination, gen, monitor);
            found = true;
        } else if (format.equals(ImageFileFormat.JPEG)
            || format.equals(ImageFileFormat.PNG)) {

            String exportFormat = ImageExporter.JPEG_FILE;
            if (format.equals(ImageFileFormat.PNG))
                exportFormat = ImageExporter.PNG_FILE;

            java.awt.Image image = new DiagramImageGenerator(diagramEP)
                .createAWTImageForParts(selection);
            if (image instanceof BufferedImage) {
                ImageExporter.exportToFile(destination, (BufferedImage) image,
                    exportFormat, monitor);
                found = true;
            }
        }

        if (!found) {
            Image image = new DiagramImageGenerator(diagramEP)
                .createSWTImageDescriptorForParts(selection).createImage();

            monitor.worked(1);

            saveToFile(destination, image, format, monitor);
            image.dispose();
        }

d178 1
a178 1

d180 2
a181 1
     * Saves the image to a file.
d183 3
a185 10
     * @@param destination
     *            the destination file, including path and file name
     * @@param image
     *            the SWT image
     * @@param imageFormat
     *            the selected image format
     * @@param monitor
     *            progress monitor
     * @@exception CoreException
     *                if this method fails
d187 78
@


1.11
log
@[157648] gmf_head ldamus 061122 Error if try to replace a diagram img file, checked in under source control
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
d331 4
@


1.10
log
@[163386] gmf_head crevells 061120 Incorrect colours show up in a File->Save As Image File->BMP Format
Contributed by: Alex Boyko
@
text
@d30 2
d275 7
a281 2
        createFile(destination);

d309 6
a314 1
        createFile(destination);
d340 1
d344 1
a344 1
    private void createFile(IPath destination)
d359 5
@


1.9
log
@[161131] gmf_head ahunter 061017 Merge 1.0.2 fix to HEAD
@
text
@d268 2
a269 1
        if (imageFormat.equals(ImageFileFormat.GIF))
@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d265 5
a269 1
        ImageData imageData = createImageData(image);
@


1.7
log
@Bugzilla#130770 gmf_head cmahoney 060307 CopyToImageUtil.createDiagramEditPart() does not set workspaces preferences or start the diagram event broker
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
@


1.7.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
@


1.7.2.2
log
@[161131] gmf_R1_0_maintenance syedatif 061017 CopyToImageUtil uses 8-bit palette for BMP and JPG
@
text
@d265 1
a265 5
        
        ImageData imageData = image.getImageData();
        
        if (imageFormat.equals(ImageFileFormat.GIF))
            imageData = createImageData(image); 
@


1.7.2.3
log
@[163386] gmf_R1_0_maintenance crevells 061120 Incorrect colours show up in a File->Save As Image File->BMP Format
Contributed by: Alex Boyko
@
text
@d268 1
a268 2
        if (imageFormat.equals(ImageFileFormat.GIF) ||
                imageFormat.equals(ImageFileFormat.BMP))
@


1.7.2.4
log
@[157648] gmf_R1_0_maintenance ldamus 061122 Error if try to replace a diagram img file, checked in under source control
@
text
@a29 2
import org.eclipse.core.runtime.Status;
import org.eclipse.gmf.runtime.common.core.command.FileModificationValidator;
d273 2
a274 7
        
        IStatus fileModificationStatus = createFile(destination);
        if (!fileModificationStatus.isOK()) {
        	// can't write to the file
        	return;
        }
        
d302 1
a302 6
        IStatus fileModificationStatus = createFile(destination);
        if (!fileModificationStatus.isOK()) {
        	// can't write to the file
        	return;
        }
        
a327 1
     * @@return the status from validating the file for editing
d331 1
a331 1
    private IStatus createFile(IPath destination)
a345 5

        if (file != null) {
        	return FileModificationValidator.approveFileModification(new IFile[] {file});
        }
        return Status.OK_STATUS;
@


1.6
log
@bugzilla 128743 gmf-head sshaw 060221 Support PNG as an export image file format
bugzilla 125478 gmf-head sshaw 060221 Improve rendering quality to external image bitmap format...
@
text
@a29 2
import org.eclipse.gef.GraphicalViewer;
import org.eclipse.gef.RootEditPart;
d33 1
a34 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.IDiagramPreferenceSupport;
a36 3
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramCommandStack;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditDomain;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
a40 1
import org.eclipse.gmf.runtime.diagram.ui.services.editpart.EditPartService;
d76 2
a77 23
        GraphicalViewer viewer = new DiagramGraphicalViewer();
        viewer.createControl(shell);

        DiagramEditDomain editDomain = new DiagramEditDomain(null);
        editDomain.setCommandStack(new DiagramCommandStack(editDomain));

        viewer.setEditDomain(editDomain);

        RootEditPart rootEP = EditPartService.getInstance().createRootEditPart(
            diagram);
        if (rootEP instanceof IDiagramPreferenceSupport) {
            ((IDiagramPreferenceSupport) rootEP)
                .setPreferencesHint(preferencesHint);
        }
        viewer.setRootEditPart(rootEP);

        viewer.setEditPartFactory(EditPartService.getInstance());

        viewer.setContents(diagram);
        viewer.flush();

        Assert.isTrue(viewer.getContents() instanceof DiagramEditPart);
        return (DiagramEditPart) viewer.getContents();
@


1.5
log
@bugzilla 110316 gmf-head 051212 Compiler warning count should be 0 - runtime diagram layer
@
text
@d14 1
d38 1
d47 1
d64 489
a552 450
	/**
	 * Creates a <code>DiagramEditPart</code> given the <code>Diagram</code>
	 * without opening an editor.
	 * 
	 * @@param diagram
	 *            the <code>Diagram</code>
	 * @@param shell
	 *            An out parameter for the shell that must be disposed after the
	 *            copy to image operation has completed.
	 * @@param preferencesHint
	 *            The preference hint that is to be used to find the appropriate
	 *            preference store from which to retrieve diagram preference
	 *            values. The preference hint is mapped to a preference store in
	 *            the preference registry <@@link DiagramPreferencesRegistry>.
	 * @@return the new populated <code>DiagramEditPart</code>
	 */
	public DiagramEditPart createDiagramEditPart(Diagram diagram, Shell shell, PreferencesHint preferencesHint) {
		GraphicalViewer viewer = new DiagramGraphicalViewer();
		viewer.createControl(shell);

		DiagramEditDomain editDomain = new DiagramEditDomain(null);
		editDomain.setCommandStack(new DiagramCommandStack(editDomain));

		viewer.setEditDomain(editDomain);

		RootEditPart rootEP = EditPartService.getInstance()
			.createRootEditPart(diagram);
		if (rootEP instanceof IDiagramPreferenceSupport) {
			((IDiagramPreferenceSupport) rootEP)
				.setPreferencesHint(preferencesHint);
		}
		viewer.setRootEditPart(rootEP);
		
		viewer.setEditPartFactory(EditPartService.getInstance());

		viewer.setContents(diagram);
		viewer.flush();

		Assert.isTrue(viewer.getContents() instanceof DiagramEditPart);
		return (DiagramEditPart) viewer.getContents();
	}

	/**
	 * Copies the diagram to an image file in the specified format.
	 * 
	 * @@param diagram
	 *            the diagram to be copied
	 * @@param destination
	 *            the destination file, including path and file name
	 * @@param format
	 *            the image file format
	 * @@param monitor
	 *            progress monitor.
	 * @@param preferencesHint
	 *            The preference hint that is to be used to find the appropriate
	 *            preference store from which to retrieve diagram preference
	 *            values. The preference hint is mapped to a preference store in
	 *            the preference registry <@@link DiagramPreferencesRegistry>.
	 * @@return A list of {@@link PartPositionInfo} objects with details regarding
	 *         each top-level editpart on the diagram represented in the image.
	 * @@exception CoreException if this method fails
	 */
	public List copyToImage(Diagram diagram, IPath destination,
			ImageFileFormat format, IProgressMonitor monitor, PreferencesHint preferencesHint)
		throws CoreException {

		Trace.trace(DiagramUIRenderPlugin.getInstance(),
			"Copy diagram to Image " + destination + " as " + format); //$NON-NLS-1$ //$NON-NLS-2$ 

		Shell shell = new Shell();
		List partInfo = Collections.EMPTY_LIST;

		try {
			DiagramEditPart diagramEditPart = createDiagramEditPart(diagram,
				shell, preferencesHint);
			Assert.isNotNull(diagramEditPart);
			DiagramGenerator generator = copyToImage(diagramEditPart,
				destination, format, monitor);
			partInfo = generator.getDiagramPartInfo(diagramEditPart);
		} finally {
			shell.dispose();
		}

		return partInfo;
	}


	/**
	 * Copies the diagram to an image file in the specified format.
	 * 
	 * @@param diagramEP
	 *            the diagram editpart
	 * @@param destination
	 *            the destination file, including path and file name
	 * @@param format
	 *            the image format to create.
	 * @@param monitor
	 *            progress monitor.
	 * @@return The diagram generator used to copy the image.
	 * @@exception CoreException if this method fails
	 */
	public DiagramGenerator copyToImage(DiagramEditPart diagramEP,
			IPath destination, ImageFileFormat format, IProgressMonitor monitor)
		throws CoreException {

		DiagramGenerator gen = null;
		if (format.equals(ImageFileFormat.SVG)) {

			gen = new DiagramSVGGenerator(diagramEP);
			gen.createSWTImageDescriptorForDiagram();

			monitor.worked(1);

			saveSVGToFile(destination, (DiagramSVGGenerator) gen, monitor);
			return gen;
		} else {

			gen = new DiagramImageGenerator(diagramEP);
			Image image = gen.createSWTImageDescriptorForDiagram()
				.createImage();

			monitor.worked(1);

			saveToFile(destination, image, format, monitor);
			image.dispose();
		}

		monitor.worked(1);
		return gen;
	}

	/**
	 * Copies the diagram to an image file in the specified format.
	 * 
	 * @@param diagramEP
	 *            the diagram edit part
	 * @@param selection
	 *            selected shapes in the diagram.
	 * @@param destination
	 *            the destination file, including path and file name
	 * @@param format
	 *            the image format to create.
	 * @@param monitor
	 *            progress monitor.
	 * @@exception CoreException if this method fails
	 */
	public void copyToImage(DiagramEditPart diagramEP, List selection,
			IPath destination, ImageFileFormat format, IProgressMonitor monitor)
		throws CoreException {

		if (format.equals(ImageFileFormat.SVG)) {

			DiagramSVGGenerator gen = new DiagramSVGGenerator(diagramEP);
			gen.createSWTImageDescriptorForParts(selection);

			monitor.worked(1);

			saveSVGToFile(destination, gen, monitor);

		} else {

			Image image = new DiagramImageGenerator(diagramEP)
				.createSWTImageDescriptorForParts(selection).createImage();

			monitor.worked(1);

			saveToFile(destination, image, format, monitor);
			image.dispose();
		}

		monitor.worked(1);
	}

	/**
	 * Saves the image to a file.
	 * 
	 * @@param destination
	 *            the destination file, including path and file name
	 * @@param image
	 *            the SWT image
	 * @@param imageFormat
	 *            the selected image format
	 * @@param monitor
	 *            progress monitor
	 * @@exception CoreException if this method fails
	 */
	protected void saveToFile(IPath destination, Image image,
			ImageFileFormat imageFormat, IProgressMonitor monitor)
		throws CoreException {

		monitor.worked(1);
		ImageData imageData = createImageData(image);

		monitor.worked(1);
		createFile(destination);

		monitor.worked(1);
		ImageLoader imageLoader = new ImageLoader();
		imageLoader.data = new ImageData[] {imageData};
		imageLoader.logicalScreenHeight = image.getBounds().width;
		imageLoader.logicalScreenHeight = image.getBounds().height;
		imageLoader.save(destination.toOSString(), imageFormat.getOrdinal());

		monitor.worked(1);
		refreshLocal(destination);
	}

	/**
	 * Saves an SVG DOM to a file.
	 * 
	 * @@param destination
	 *            the destination file, including path and file name
	 * @@param generator
	 * 			the svg generator for a diagram, used to write  
	 * @@param monitor
	 * the progress monitor
	 * @@exception CoreException if this method fails
	 */
	protected void saveSVGToFile(IPath destination,
			DiagramSVGGenerator generator, IProgressMonitor monitor)
		throws CoreException {

		createFile(destination);
		monitor.worked(1);

		try {

			FileOutputStream os = new FileOutputStream(destination.toOSString());
			monitor.worked(1);

			generator.stream(os);
			monitor.worked(1);

			os.close();
			monitor.worked(1);
			refreshLocal(destination);
		} catch (IOException ex) {
			Log.error(DiagramUIRenderPlugin.getInstance(), IStatus.ERROR, ex
				.getMessage(), ex);
		}
	}

	/**
	 * create a file in the workspace if the destination is in a project in the
	 * workspace.
	 * 
	 * @@param destination
	 *            the destination file.
	 * @@exception CoreException if this method fails
	 */
	private void createFile(IPath destination)
		throws CoreException {
		IFile file = ResourcesPlugin.getWorkspace().getRoot()
			.getFileForLocation(destination);
		if (file != null && !file.exists()) {
			File osFile = new File(destination.toOSString());
			if (osFile.exists()) {
				file.refreshLocal(IResource.DEPTH_ZERO, null);
			} else {
				ResourcesPlugin.getWorkspace().getRoot().refreshLocal(
					IResource.DEPTH_INFINITE, null);
				InputStream input = new ByteArrayInputStream(new byte[0]);
				file.create(input, false, null);
			}
		}
	}

	/**
	 * refresh the file in the workspace if the destination is in a project in
	 * the workspace.
	 * 
	 * @@param destination
	 *            the destination file.
	 * @@exception CoreException if this method fails
	 */
	private void refreshLocal(IPath destination)
		throws CoreException {
		IFile file = ResourcesPlugin.getWorkspace().getRoot()
			.getFileForLocation(destination);
		if (file != null) {
			file.refreshLocal(IResource.DEPTH_ZERO, null);
		}
	}

	/**
	 * Retrieve the image data for the image, using a palette of at most 256
	 * colours.
	 * 
	 * @@param image
	 *            the SWT image.
	 * @@return new image data.
	 */
	private ImageData createImageData(Image image)
 {

		ImageData imageData = image.getImageData();

		/**
		 * If the image depth is 8 bits or less, then we can use the existing
		 * image data.
		 */
		if (imageData.depth <= 8) {
			return imageData;
		}

		/**
		 * get an 8 bit imageData for the image
		 */
		ImageData newImageData = get8BitPaletteImageData(imageData);

		/**
		 * if newImageData is null, it has more than 256 colours. Use the web
		 * safe pallette to get an 8 bit image data for the image.
		 */
		if (newImageData == null) {
			newImageData = getWebSafePalletteImageData(imageData);
		}

		return newImageData;
	}

	/**
	 * Retrieve an image data with an 8 bit palette for an image. We assume that
	 * the image has less than 256 colours.
	 * 
	 * @@param imageData
	 *            the imageData for the image.
	 * @@return the new 8 bit imageData or null if the image has more than 256
	 *         colours.
	 */
	private ImageData get8BitPaletteImageData(ImageData imageData) {
		PaletteData palette = imageData.palette;
		RGB colours[] = new RGB[256];
		PaletteData newPaletteData = new PaletteData(colours);
		ImageData newImageData = new ImageData(imageData.width,
			imageData.height, 8, newPaletteData);

		int lastPixel = -1;
		int newPixel = -1;
		for (int i = 0; i < imageData.width; ++i) {
			for (int j = 0; j < imageData.height; ++j) {
				int pixel = imageData.getPixel(i, j);

				if (pixel != lastPixel) {
					lastPixel = pixel;

					RGB colour = palette.getRGB(pixel);
					for (newPixel = 0; newPixel < 256; ++newPixel) {
						if (colours[newPixel] == null) {
							colours[newPixel] = colour;
							break;
						}
						if (colours[newPixel].equals(colour))
							break;
					}

					if (newPixel >= 256) {
						/**
						 * Diagram has more than 256 colors, return null
						 */
						return null;
					}
				}

				newImageData.setPixel(i, j, newPixel);
			}
		}

		RGB colour = new RGB(0, 0, 0);
		for (int k = 0; k < 256; ++k) {
			if (colours[k] == null)
				colours[k] = colour;
		}

		return newImageData;
	}

	/**
	 * If the image has less than 256 colours, simply create a new 8 bit palette
	 * and map the colours to the new palatte.
	 */
	private ImageData getWebSafePalletteImageData(ImageData imageData) {
		PaletteData palette = imageData.palette;
		RGB[] webSafePallette = getWebSafePallette();
		PaletteData newPaletteData = new PaletteData(webSafePallette);
		ImageData newImageData = new ImageData(imageData.width,
			imageData.height, 8, newPaletteData);

		int lastPixel = -1;
		int newPixel = -1;
		for (int i = 0; i < imageData.width; ++i) {
			for (int j = 0; j < imageData.height; ++j) {
				int pixel = imageData.getPixel(i, j);

				if (pixel != lastPixel) {
					lastPixel = pixel;

					RGB colour = palette.getRGB(pixel);
					RGB webSafeColour = getWebSafeColour(colour);
					for (newPixel = 0; newPixel < 216; ++newPixel) {
						if (webSafePallette[newPixel].equals(webSafeColour))
							break;
					}

					Assert.isTrue(newPixel < 216);
				}
				newImageData.setPixel(i, j, newPixel);
			}
		}

		return newImageData;
	}

	/**
	 * Retrieves a web safe colour that closely matches the provided colour.
	 * 
	 * @@param colour
	 *            a colour.
	 * @@return the web safe colour.
	 */
	private RGB getWebSafeColour(RGB colour) {
		int red = Math.round((colour.red + 25) / 51) * 51;
		int green = Math.round((colour.green + 25) / 51) * 51;
		int blue = Math.round((colour.blue + 25) / 51) * 51;
		return new RGB(red, green, blue);
	}

	/**
	 * Retrieves a web safe pallette. Our palette will be 216 web safe colours
	 * and the remaining filled with white.
	 * 
	 * @@return array of 256 colours.
	 */
	private RGB[] getWebSafePallette() {
		RGB[] colours = new RGB[256];
		int i = 0;
		for (int red = 0; red <= 255; red = red + 51) {
			for (int green = 0; green <= 255; green = green + 51) {
				for (int blue = 0; blue <= 255; blue = blue + 51) {
					RGB colour = new RGB(red, green, blue);
					colours[i++] = colour;
				}
			}
		}

		RGB colour = new RGB(0, 0, 0);
		for (int k = 0; k < 256; ++k) {
			if (colours[k] == null)
				colours[k] = colour;
		}
d554 2
a555 2
		return colours;
	}
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051108 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@a36 1
import org.eclipse.gmf.runtime.diagram.ui.image.PartPositionInfo;
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a30 8
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
import org.eclipse.swt.graphics.ImageLoader;
import org.eclipse.swt.graphics.PaletteData;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.swt.widgets.Shell;

d47 7
d88 1
a88 1
			.createRootEditPart();
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.          	       |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d52 1
a52 1
import com.ibm.xtools.notation.Diagram;
@

