head	1.15;
access;
symbols
	v20081020-0700:1.15
	v20080903-1520:1.15
	v20080903-1510:1.14.2.1
	v20080722-1827:1.14
	R2_1_maintenance:1.14.0.2
	Root_R2_1_maintenance:1.14
	R2_1_0:1.14
	v20080603-1553:1.14
	v20080527-1255:1.14
	v20080512-1200:1.13
	v20080425-1959:1.12
	v20080328-1605:1.12
	v20080322-0000:1.12
	v20080222-1200:1.12
	v20080114-1111:1.12
	v20071124-0000:1.10
	v20071108-0000:1.11
	v20071003-0000:1.11
	v20070903-0000:1.11
	v20070809-0000:1.10
	R2_0_maintenance:1.10.0.2
	R2_0:1.10
	R4_20:1.10
	v20070621-0000:1.10
	RC3_20:1.10
	v20070614-1400:1.10
	v20070601-1400:1.10
	v20070518-1300:1.10
	v20070330-1300:1.10
	v20060316-0600:1.10
	v20070208-1800:1.10
	v20070202-0200:1.6.2.4
	v20070105-1200:1.6.2.3
	M4_20:1.9
	v20061218-1500:1.6.2.3
	v20061218-1200:1.9
	v20061214-0000:1.8
	M3_20:1.8
	v20061117-0800:1.8
	v20061020-1000:1.6.2.2
	v20061013-1330:1.8
	v20061012-1100:1.6.2.2
	v20060919-0800:1.6.2.1
	M1_20:1.6
	v20060721-1130:1.6.2.1
	v20060713-1700:1.6
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060616-1200:1.6
	v20060531-1730:1.6
	v20060519-0800:1.6
	I20060428-1300:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.6
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.6
	I20060129-1145:1.6
	I20060127-0900:1.6
	I20060120-1530:1.6
	I20060113-1700:1.6
	M4_10:1.6
	I20060107-1100:1.6
	I20060105-1630:1.6
	I20051230-1230:1.6
	I20051223-1100:1.6
	I20051217-0925:1.6
	I20051208-2000:1.6
	I20051201-1800:1.6
	I20051124-2000:1.5
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.5
	I20051106-0900:1.5
	v20051030:1.4;
locks; strict;
comment	@# @;


1.15
date	2008.08.27.20.25.22;	author aboyko;	state Exp;
branches;
next	1.14;
commitid	5aad48b5b8314567;

1.14
date	2008.05.23.03.17.36;	author aboyko;	state Exp;
branches
	1.14.2.1;
next	1.13;
commitid	499d4836374a4567;

1.13
date	2008.05.09.15.23.48;	author aboyko;	state Exp;
branches;
next	1.12;
commitid	144048246c844567;

1.12
date	2008.01.08.21.03.09;	author crevells;	state Exp;
branches;
next	1.11;
commitid	5c574783e50d4567;

1.11
date	2007.07.31.18.31.07;	author aboyko;	state Exp;
branches;
next	1.10;
commitid	6b8646af7fe94567;

1.10
date	2007.01.30.16.16.33;	author mmostafa;	state Exp;
branches;
next	1.9;
commitid	7c8a45bf6f614567;

1.9
date	2006.12.15.19.46.53;	author mmostafa;	state Exp;
branches;
next	1.8;
commitid	61e14582fbad4567;

1.8
date	2006.10.11.20.50.37;	author mmostafa;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.03.15.04.50;	author ahunter;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.25.19.37.45;	author cmahoney;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2005.11.02.23.30.24;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.28.14.29.39;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.29.16;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.12;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.55;	author sshaw;	state Exp;
branches;
next	;

1.6.2.1
date	2006.07.17.19.48.04;	author ahunter;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2006.10.11.20.46.06;	author mmostafa;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2006.12.15.19.47.16;	author mmostafa;	state Exp;
branches;
next	1.6.2.4;
commitid	2d0b4582fbc34567;

1.6.2.4
date	2007.01.30.16.16.00;	author mmostafa;	state Exp;
branches;
next	;
commitid	767245bf6f3f4567;

1.14.2.1
date	2008.08.27.20.20.07;	author aboyko;	state Exp;
branches;
next	;
commitid	579848b5b6f64567;


desc
@@


1.15
log
@[239653] gmf_head aboyko 080827 [ImageSupport] Support DiagramPartInfo API for exporting the scaled down diagram to image
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.render.clipboard;

import java.awt.Image;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Stack;

import org.eclipse.core.runtime.Assert;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PolylineConnection;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.PrecisionRectangle;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.draw2d.geometry.Translatable;
import org.eclipse.gef.ConnectionEditPart;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.LayerConstants;
import org.eclipse.gef.editparts.LayerManager;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeCompartmentEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.image.PartPositionInfo;
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.IExpandableFigure;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.decorator.Decoration;
import org.eclipse.gmf.runtime.diagram.ui.l10n.SharedImages;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg.Sign;
import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.graphics.RenderedMapModeGraphics;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.swt.graphics.ImageData;

/**
 * Provides the framework to generate SWT and AWT images of a diagram or a
 * subset of editparts on a diagram.
 * 
 * @@author sshaw
 * @@author Barys Dubauski
 */
abstract public class DiagramGenerator {

	private int image_margin = 0;

	private DiagramEditPart _dgrmEP;

	/**
	 * Creates a new instance.
	 * 
	 * @@param dgrmEP
	 *            the diagram editpart
	 */
	public DiagramGenerator(DiagramEditPart dgrmEP) {
		this._dgrmEP = dgrmEP;
		image_margin = getMapMode().DPtoLP(10);
	}

	/**
	 * @@return DiagramEditPart
	 */
	protected DiagramEditPart getDiagramEditPart() {
		return this._dgrmEP;
	}

	/**
	 * Allows hook for the creation of a <code>Graphics</code> object that is
	 * used for the rendering of the diagram.
	 * 
	 * @@param width
	 *            of the clipping area
	 * @@param height
	 *            of the clipping area
	 * @@return Graphics element that is the target for rendering.
	 */
	abstract protected Graphics setUpGraphics(int width, int height);

	/**
	 * Allows hook to dispose of any artifacts around the creation of the
	 * <code>Graphics</code> object used for rendering.
	 * 
	 * @@param g
	 *            Graphics element that is to be disposed.
	 */
	protected void disposeGraphics(Graphics g) {
		g.dispose();
	}

	/**
	 * Creates an image descriptor representing the image rendered from the
	 * diagram.
	 * 
	 * @@param g
	 *            Graphics object where information to form the image descriptor
	 *            can be retrieved from.
	 * @@return ImageDescriptor representing the image rendered from the diagram.
	 */
	abstract protected ImageDescriptor getImageDescriptor(Graphics g);

	/**
	 * Creates an AWT image for the contents of the diagram editpart.
	 * 
	 * @@return an image in AWT format
	 */
	final public Image createAWTImageForDiagram() {
		List editparts = getDiagramEditPart().getPrimaryEditParts();

		return createAWTImageForParts(editparts);
	}

	/**
	 * Creates an AWT image for the list of editparts passed in.
	 * 
	 * @@param editparts
	 *            the list of <code>IGraphicalEditParts</code> that will be
	 *            rendered to the Image
	 * @@return an image in AWT format
	 */
	public Image createAWTImageForParts(List editparts) {
		org.eclipse.swt.graphics.Rectangle diagramArea = calculateImageRectangle(editparts);
		return createAWTImageForParts(editparts, diagramArea);
	}

	/**
	 * Creates an SWT image descriptor for the contents of the diagram editpart.
	 * 
	 * @@return an image descriptor for an SWT image
	 */
	final public ImageDescriptor createSWTImageDescriptorForDiagram() {
		List editparts = getDiagramEditPart().getPrimaryEditParts();

		return createSWTImageDescriptorForParts(editparts);
	}

	/**
	 * Creates an SWT image descriptor for the list of editparts passed in.Any
	 * connections where both the source and target editparts are passed in are
	 * also drawn.
	 * 
	 * @@param editparts
	 *            the list of <code>IGraphicalEditParts</code> that will be
	 *            rendered to the Image
	 * @@return an image descriptor for an SWT image
	 */
	final public ImageDescriptor createSWTImageDescriptorForParts(List editparts) {
		org.eclipse.swt.graphics.Rectangle sourceRect = calculateImageRectangle(editparts);
		return createSWTImageDescriptorForParts(editparts, sourceRect);
	}

	/**
	 * @@return
	 */
	protected IMapMode getMapMode() {
		IMapMode mm = MapModeUtil.getMapMode(getDiagramEditPart().getFigure());
		return mm;
	}

	/**
	 * Renders the list of editparts to the graphics object. Any connections
	 * where both the source and target editparts are passed in are also drawn.
	 * 
	 * @@param graphics
	 *            the graphics object on which to draw
	 * @@param translateOffset
	 *            a <code>Point</code> that the value the
	 *            <code>graphics</code> object will be translated by in
	 *            relative coordinates.
	 * @@param editparts
	 *            the list of <code>IGraphicalEditParts</code> that will be
	 *            rendered to the graphics object
	 */
	final protected void renderToGraphics(Graphics graphics,
			Point translateOffset, List editparts) {

		List sortedEditparts = sortSelection(editparts);

		graphics.translate((-translateOffset.x), (-translateOffset.y));
		graphics.pushState();

		List<GraphicalEditPart> connectionsToPaint = new LinkedList<GraphicalEditPart>();

		Map decorations = findDecorations(editparts);

		for (Iterator editPartsItr = editparts.listIterator(); editPartsItr.hasNext();) {
			IGraphicalEditPart editPart = (IGraphicalEditPart) editPartsItr.next();

			// do not paint selected connection part
			if (editPart instanceof ConnectionEditPart) {
				connectionsToPaint.add(editPart);
			} else {				
				connectionsToPaint.addAll(findConnectionsToPaint(editPart));
				// paint shape figure
				IFigure figure = editPart.getFigure();
				paintFigure(graphics, figure);

				paintDecorations(graphics, figure, decorations);
			}
		}
		
		// paint the connection parts after shape parts paint
		decorations = findDecorations(connectionsToPaint);

		for (Iterator<GraphicalEditPart> connItr = connectionsToPaint.iterator(); connItr.hasNext();) {
			IFigure figure = connItr.next().getFigure();
			paintFigure(graphics, figure);
			paintDecorations(graphics, figure, decorations);
		}
	}
	
	/**
	 * Collects all connections contained within the given edit part
	 * 
	 * @@param editPart the container editpart
	 * @@return connections within it
	 */
	private Collection<ConnectionEditPart> findConnectionsToPaint(IGraphicalEditPart editPart) {
		/*
		 * Set of node editparts contained within the given editpart
		 */
		HashSet<GraphicalEditPart> editParts = new HashSet<GraphicalEditPart>();
		
		/*
		 * All connection editparts that have a source contained within the given editpart
		 */
		HashSet<ConnectionEditPart> connectionEPs = new HashSet<ConnectionEditPart>();
		
		/*
		 * Connections contained within the given editpart (or just the connections to paint
		 */
		HashSet<ConnectionEditPart> connectionsToPaint = new HashSet<ConnectionEditPart>();
		
		/*
		 * Populate the set of node editparts
		 */
		getNestedEditParts(editPart, editParts);
		
		/*
		 * Populate the set of connections whose source is within the given editpart
		 */
		for (Iterator<GraphicalEditPart> editPartsItr = editParts.iterator(); editPartsItr.hasNext();) {
			connectionEPs.addAll(getAllConnectionsFrom(editPartsItr.next()));
		}
		
		/*
		 * Create a set of connections constained within the given editpart
		 */
		while (!connectionEPs.isEmpty()) {
			/*
			 * Take the first connection and check whethe there is a path
			 * through that connection that leads to the target contained within
			 * the given editpart
			 */
			Stack<ConnectionEditPart> connectionsPath = new Stack<ConnectionEditPart>();
			ConnectionEditPart conn = connectionEPs.iterator().next();
			connectionEPs.remove(conn);
			connectionsPath.add(conn);
			
			/*
			 * Initialize the target for the current path
			 */
			EditPart target = conn.getTarget();
			while(connectionEPs.contains(target)) {
				/*
				 * If the target end is a connection, check if it's one of the
				 * connection's whose target is a connection and within the
				 * given editpart. Append it to the path if it is. Otherwise
				 * check if the target is within the actual connections or nodes
				 * contained within the given editpart
				 */
				ConnectionEditPart targetConn = (ConnectionEditPart) target;
				connectionEPs.remove(targetConn);
				connectionsPath.add(targetConn);
				
				/*
				 * Update the target for the new path
				 */
				target = targetConn.getTarget();
			}
			
			/*
			 * The path is built, check if it's target is a node or a connection
			 * contained within the given editpart
			 */
			if (editParts.contains(target) || connectionsToPaint.contains(target)) {
				connectionsToPaint.addAll(connectionsPath);
			}
		}
		return connectionsToPaint;
	}
	
	/**
	 * Returns all connections orginating from a given editpart. All means that
	 * connections originating from connections that have a source given
	 * editpart will be included
	 * 
	 * @@param ep the editpart 
	 * @@return all source connections
	 */
	private List<ConnectionEditPart> getAllConnectionsFrom(GraphicalEditPart ep) {
		LinkedList<ConnectionEditPart> connections = new LinkedList<ConnectionEditPart>();
		for (Iterator itr = ep.getSourceConnections().iterator(); itr.hasNext();) {
			ConnectionEditPart sourceConn = (ConnectionEditPart) itr.next();
			connections.add(sourceConn);
			connections.addAll(getAllConnectionsFrom(sourceConn));
		}
		return connections;
	}

	/**
	 * This method is used when a figure needs to be painted to the graphics.
	 * The figure will be translated based on its absolute positioning.
	 * 
	 * @@param graphics
	 *            Graphics object to render figure
	 * @@param figure
	 *            the figure to be rendered
	 */
	private void paintFigure(Graphics graphics, IFigure figure) {

		if (!figure.isVisible())
			return;

		// Calculate the Relative bounds and absolute bounds
		Rectangle relBounds = null;
		if (figure instanceof IExpandableFigure)
			relBounds = ((IExpandableFigure) figure).getExtendedBounds()
					.getCopy();
		else
			relBounds = figure.getBounds().getCopy();

		Rectangle abBounds = relBounds.getCopy();
		translateToPrintableLayer(figure, abBounds);

		// Calculate the difference
		int transX = abBounds.x - relBounds.x;
		int transY = abBounds.y - relBounds.y;

		// Paint the figure
		graphics.pushState();
		graphics.translate(transX, transY);
		figure.paint(graphics);
		graphics.popState();
		graphics.restoreState();
	}

	/**
	 * Find the decorations that adorn the specified <code>editParts</code>.
	 * 
	 * @@param editparts
	 *            the list of <code>IGraphicalEditParts</code> for which to
	 *            find decorations
	 * @@return a mapping of {@@link IFigure}to ({@@link Decoration}or
	 *         {@@link Collection}of decorations})
	 */
	private Map findDecorations(Collection editparts) {
		// create inverse mapping of figures to edit parts (need this to map
		// decorations to edit parts)
		Map figureMap = mapFiguresToEditParts(editparts);

		Map result = new java.util.HashMap();

		if (!editparts.isEmpty()) {
			IGraphicalEditPart first = (IGraphicalEditPart) editparts.iterator().next();

			IFigure decorationLayer = LayerManager.Helper.find(first).getLayer(
					DiagramRootEditPart.DECORATION_PRINTABLE_LAYER);

			if (decorationLayer != null) {
				// compute the figures of the shapes
				List figures = new java.util.ArrayList(editparts);
				for (ListIterator iter = figures.listIterator(); iter.hasNext();) {
					iter.set(((IGraphicalEditPart) iter.next()).getFigure());
				}

				// find the decorations on figures that were selected
				for (Iterator iter = decorationLayer.getChildren().iterator(); iter
						.hasNext();) {
					Object next = iter.next();

					if (next instanceof Decoration) {
						Decoration decoration = (Decoration) next;
						IFigure owner = decoration.getOwnerFigure();

						while (owner != null) {
    						if (figureMap.containsKey(owner)) {
    							Object existing = result.get(owner);
    
    							if (existing == null) {
    								result.put(owner, decoration);
    							} else if (existing instanceof Collection) {
    								((Collection) existing).add(decoration);
    							} else {
    								Collection c = new java.util.ArrayList(2);
    								c.add(existing);
    								c.add(decoration);
    								result.put(owner, c);
    							}
    							break;
    						} else {
    						    owner = owner.getParent();
    						}
						}
					}
				}
			}
		}

		return result;
	}

	/**
	 * Constructs a mapping of figures to their corresponding edit parts.
	 * 
	 * @@param editParts
	 *            a collection of <code>IGraphicalEditParts</code>
	 * @@return a mapping of {@@link IFigure}to {@@link IGraphicalEditPart}
	 */
	private Map mapFiguresToEditParts(Collection editParts) {
		Map result = new java.util.HashMap();

		for (Iterator iter = editParts.iterator(); iter.hasNext();) {
			IGraphicalEditPart next = (IGraphicalEditPart) iter.next();

			result.put(next.getFigure(), next);
		}

		return result;
	}

	/**
	 * Paints the decorations adorning the specified <code>figure</code>, if
	 * any.
	 * 
	 * @@param graphics
	 *            the graphics to paint on
	 * @@param figure
	 *            the figure
	 * @@param decorations
	 *            mapping of figures to decorations, in which we will find the
	 *            <code>figure</code>'s decorations
	 */
	private void paintDecorations(Graphics graphics, IFigure figure,
			Map decorations) {
		Object decoration = decorations.get(figure);

		if (decoration != null) {
			if (decoration instanceof Collection) {
				for (Iterator iter = ((Collection) decoration).iterator(); iter
						.hasNext();) {
					paintFigure(graphics, (IFigure) iter.next());
				}
			} else {
				paintFigure(graphics, (IFigure) decoration);
			}
		}
	}

	/**
	 * This is a recursive method that search a tree of edit parts looking for
	 * edit parts contained in the open list. If the edit part is found it is
	 * removed from the open list and placed in the closed list.
	 * 
	 * @@param editPart
	 * @@param open
	 * @@param closed
	 */
	private void sortSelection(GraphicalEditPart editPart, List open,
			List closed) {

		// Do nothing if the open list is empty
		if (open.isEmpty()) {
			return;
		}

		// IF the edit part is contained in the open list (we are searching for
		// it)
		if (open.contains(editPart)) {
			// Add the Edit Part to the closed list and remove it from
			// the open list
			closed.add(editPart);
			open.remove(editPart);
		}

		for (Iterator iter = editPart.getChildren().iterator(); iter.hasNext();) {
			GraphicalEditPart child = (GraphicalEditPart) iter.next();
			sortSelection(child, open, closed);
		}
	}

	private List sortSelection(List toSort) {
		List closed = new ArrayList(toSort.size());
		List open = new ArrayList(toSort.size());
		open.addAll(toSort);

		sortSelection(getDiagramEditPart(), open, closed);
		if (!open.isEmpty()) {
			closed.addAll(open);
		}

		return closed;
	}

	/**
	 * This method is used to obtain the list of child edit parts for shape
	 * compartments.
	 * 
	 * @@param childEditPart
	 *            base edit part to get the list of children editparts
	 * @@param editParts
	 *            list of nested shape edit parts
	 */
	private void getNestedEditParts(IGraphicalEditPart childEditPart,
			Collection editParts) {

		for (Iterator iter = childEditPart.getChildren().iterator(); iter
				.hasNext();) {

			IGraphicalEditPart child = (IGraphicalEditPart) iter.next();
			editParts.add(child);
			getNestedEditParts(child, editParts);
		}
	}

	/**
	 * Determine the minimal rectangle required to bound the list of editparts.
	 * A margin is used around each of the editpart's figures when calculating
	 * the size.
	 * 
	 * @@param editparts
	 *            the list of <code>IGraphicalEditParts</code> from which
	 *            their figure bounds will be used
	 * @@return Rectangle the minimal rectangle that can bound the figures of the
	 *         list of editparts
	 */
	public org.eclipse.swt.graphics.Rectangle calculateImageRectangle(
			List editparts) {
		int minX = 0;
		int maxX = 0;
		int minY = 0;
		int maxY = 0;

		IMapMode mm = getMapMode();

		for (int i = 0; i < (editparts.size()); i++) {
			IGraphicalEditPart editPart = (IGraphicalEditPart) editparts.get(i);

			IFigure figure = editPart.getFigure();
			Rectangle bounds = null;
			if (figure instanceof IExpandableFigure)
				bounds = ((IExpandableFigure) figure).getExtendedBounds();
			else
				bounds = figure.getBounds().getCopy();
			translateToPrintableLayer(figure, bounds);
			bounds = bounds.getExpanded(getImageMargin(), getImageMargin());

			if (i == 0) {
				minX = bounds.x;
				maxX = bounds.x + bounds.width;
				minY = bounds.y;
				maxY = bounds.y + bounds.height;
			} else {
				minX = Math.min(minX, bounds.x);
				maxX = Math.max(maxX, (bounds.x + bounds.width));
				minY = Math.min(minY, bounds.y);
				maxY = Math.max(maxY, (bounds.y + bounds.height));
			}
		}

		int width = (maxX - minX);
		int height = (maxY - minY);
		if (width <= 0) {
			width = mm.DPtoLP(100);
		}

		if (height <= 0) {
			height = mm.DPtoLP(100); // create an empty image if the
			// diagram does not contain child
		}
		org.eclipse.swt.graphics.Rectangle imageRect = new org.eclipse.swt.graphics.Rectangle(
				minX, minY, width, height);
		return imageRect;
	}
	
	/**
	 * Get the positional data and the semantic elements for each
	 * <code>ShapeEditPart</code>, <code>ShapeCompartmentEditPart</code>,
	 * and <code>ConnectionEditPart</code> on the diagram.
	 * 
	 * @@return A list of {@@link PartPositionInfo}objects with positional data
	 *         and the semantic element for the relevant editparts on the
	 *         diagram.
	 */
	public List getDiagramPartInfo() {
		Assert.isNotNull(_dgrmEP);
		return getDiagramPartInfo(_dgrmEP);
	}

	/**
	 * Get the positional data and the semantic elements for each
	 * <code>ShapeEditPart</code>, <code>ShapeCompartmentEditPart</code>,
	 * and <code>ConnectionEditPart</code> on the diagram.
	 * 
	 * @@param diagramEditPart
	 *            The diagram edit part.
	 * @@return A list of {@@link PartPositionInfo}objects with positional data
	 *         and the semantic element for the relevant editparts on the
	 *         diagram.
	 */
	public List getDiagramPartInfo(DiagramEditPart diagramEditPart) {
		List<PartPositionInfo> result = new ArrayList<PartPositionInfo>();
		List<IGraphicalEditPart> editParts = new ArrayList<IGraphicalEditPart>();

		List<IGraphicalEditPart> children = (List<IGraphicalEditPart>) diagramEditPart.getPrimaryEditParts();
		IMapMode mm = getMapMode();

		// We will use the diagram generate that was used to generate the image
		// to figure out the outer-bound rectangle so that we are calculating
		// the
		// image positions using the same box as was used to create the image.
		org.eclipse.swt.graphics.Rectangle imageRect = calculateImageRectangle(children);

		for (IGraphicalEditPart part : children) {
			editParts.add(part);
			getNestedEditParts(part, editParts);
		}

		for (IGraphicalEditPart part : editParts) {
			IFigure figure = part.getFigure();

			// RATLC00139941: Need to support any kind of shape edit part
			// and shape compartments, too, because these sometimes
			// correspond to distinct semantic elements
			if (part instanceof ShapeEditPart
					|| part instanceof ShapeCompartmentEditPart) {

				PartPositionInfo position = new PartPositionInfo();

				position.setSemanticElement(ViewUtil
						.resolveSemanticElement((View) part.getModel()));

				Rectangle bounds = figure.getBounds().getCopy();
				translateToPrintableLayer(figure, bounds);
				bounds.translate(-imageRect.x, -imageRect.y);

				position.setPartHeight(mm.LPtoDP(bounds.height));
				position.setPartWidth(mm.LPtoDP(bounds.width));
				position.setPartX(mm.LPtoDP(bounds.x));
				position.setPartY(mm.LPtoDP(bounds.y));
				result.add(0, position);
			} else if (part instanceof ConnectionEditPart) {
				// find a way to get (P1, P2, ... PN) for connection edit part
				// add MARGIN and calculate "stripe" for the polyline instead of
				// bounding box.
				PartPositionInfo position = new PartPositionInfo();

				position.setSemanticElement(ViewUtil
						.resolveSemanticElement((View) part.getModel()));

				if (figure instanceof PolylineConnection) {
					PolylineConnection mainPoly = (PolylineConnection) figure;
					PointList mainPts = mainPoly.getPoints();

					translateToPrintableLayer(figure, mainPts);
					List<Point> envelopingPts = calculateEnvelopingPolyline(mainPts,
							new Point(imageRect.x, imageRect.y));
					List<Point> transformedPts = convertPolylineUnits(envelopingPts);

					position.setPolyline(transformedPts);
					result.add(0, position);
				}
			}
		}
		return result;
	}
	
	public List<PartPositionInfo> getConstrainedDiagramPartInfo(int maxWidth, int maxHeight, boolean useMargins) {
		return getConstrainedDiagramPartInfo(_dgrmEP, maxWidth, maxHeight, useMargins);
	}
	
	public List<PartPositionInfo> getConstrainedDiagramPartInfo(DiagramEditPart diagramEditPart, int maxWidth, int maxHeight, boolean useMargins) {
		List<PartPositionInfo> result = new ArrayList<PartPositionInfo>();
		List<IGraphicalEditPart> editParts = new ArrayList<IGraphicalEditPart>();

		List<IGraphicalEditPart> children = (List<IGraphicalEditPart>) diagramEditPart.getPrimaryEditParts();
		IMapMode mm = getMapMode();

		// We will use the diagram generate that was used to generate the image
		// to figure out the outer-bound rectangle so that we are calculating
		// the
		// image positions using the same box as was used to create the image.
		ConstrainedImageRenderingData data = getConstrainedImageRenderingData(children, maxWidth, maxHeight, useMargins);
		Rectangle imageRect = data.imageOriginalBounds.getCopy();
		mm.DPtoLP(imageRect);
		if (useMargins) {
			imageRect.shrink(getImageMargin(), getImageMargin());
		}
		imageRect.performScale(data.scalingFactor);
		if (useMargins) {
			imageRect.expand(getImageMargin(), getImageMargin());
		}

		for (IGraphicalEditPart part : children) {
			editParts.add(part);
			getNestedEditParts(part, editParts);
		}

		for (IGraphicalEditPart part : editParts) {
			IFigure figure = part.getFigure();

			// RATLC00139941: Need to support any kind of shape edit part
			// and shape compartments, too, because these sometimes
			// correspond to distinct semantic elements
			if (part instanceof ShapeEditPart
					|| part instanceof ShapeCompartmentEditPart) {

				PartPositionInfo position = new PartPositionInfo();

				position.setSemanticElement(ViewUtil
						.resolveSemanticElement((View) part.getModel()));

				Rectangle bounds = figure.getBounds().getCopy();
				translateToPrintableLayer(figure, bounds);
				bounds.performScale(data.scalingFactor);
				bounds.translate(-imageRect.x, -imageRect.y);

				position.setPartHeight(mm.LPtoDP(bounds.height));
				position.setPartWidth(mm.LPtoDP(bounds.width));
				position.setPartX(mm.LPtoDP(bounds.x));
				position.setPartY(mm.LPtoDP(bounds.y));
				result.add(0, position);
			} else if (part instanceof ConnectionEditPart) {
				// find a way to get (P1, P2, ... PN) for connection edit part
				// add MARGIN and calculate "stripe" for the polyline instead of
				// bounding box.
				PartPositionInfo position = new PartPositionInfo();

				position.setSemanticElement(ViewUtil
						.resolveSemanticElement((View) part.getModel()));

				if (figure instanceof PolylineConnection) {
					PolylineConnection mainPoly = (PolylineConnection) figure;
					PointList mainPts = mainPoly.getPoints();
					mainPts.performScale(data.scalingFactor);

					translateToPrintableLayer(figure, mainPts);
					List<Point> envelopingPts = calculateEnvelopingPolyline(mainPts,
							new Point(imageRect.x, imageRect.y));
					List<Point> transformedPts = convertPolylineUnits(envelopingPts);

					position.setPolyline(transformedPts);
					result.add(0, position);
				}
			}
		}

		return result;
	}

	/**
	 * Recursively moves up the figure containment tree until it reaches the
	 * printable layer or the root.
	 * 
	 * @@param figure
	 *            the figure that the translatable is relative to
	 * @@param translatable
	 *            the object that needs to be translated
	 */
	private void translateToPrintableLayer(IFigure figure,
			Translatable translatable) {

		IFigure printableLayer = getDiagramEditPart().getLayer(
				LayerConstants.PRINTABLE_LAYERS);
		if (figure == null || figure.equals(printableLayer)) {
			return;
		}

		figure.translateToParent(translatable);
		translateToPrintableLayer(figure.getParent(), translatable);
	}

	/**
	 * Calculates enveloping polyline for a given polyline with margin MARGIN
	 * 
	 *   E1                  E2
	 *     +----------------+
	 *     |                |<------- MARGIN
	 *   A *----------------* B
	 *     |                |
	 *     +----------------+
	 *   E4                  E3
	 * 
	 * On the figure above: AB is a given polyline. E1E2E3E4 is enveloping
	 * polyline built around AB perimeter using margin MARGIN.
	 * 
	 * 
	 * @@param polyPts
	 * @@param origin
	 *            location of the main diagram bounding box used to shift
	 *            coordinates to be relative against diagram
	 * 
	 * @@return List of Point type objects (that carry X and Y coordinate pair)
	 *         representing the polyline
	 * @@author Barys Dubauski
	 */
	private List<Point> calculateEnvelopingPolyline(PointList polyPts, Point origin) {
		List<Point> result = new ArrayList<Point>();
		List<LineSeg> mainSegs = (List<LineSeg>) PointListUtilities.getLineSegments(polyPts);

		int mainSegsLength = mainSegs.size();

		LineSeg segment = null;
		Point orthoPoint1 = null;
		Point orthoPoint2 = null;

		// collect points clockwise
		for (int i = 0; i < mainSegsLength; i++) {
			segment = (LineSeg) mainSegs.get(i);
			orthoPoint1 = segment.locatePoint(0.0, getImageMargin(),
					Sign.POSITIVE);
			orthoPoint1.translate(-origin.x, -origin.y);
			orthoPoint2 = segment.locatePoint(1.0, getImageMargin(),
					Sign.POSITIVE);
			orthoPoint2.translate(-origin.x, -origin.y);

			result.add(orthoPoint1);
			result.add(orthoPoint2);
		}

		// now add the original poly
		for (int i = mainSegsLength - 1; i >= 0; i--) {
			segment = (LineSeg) mainSegs.get(i);
			orthoPoint1 = segment.getTerminus();
			orthoPoint1.translate(-origin.x, -origin.y);
			result.add(orthoPoint1);
			orthoPoint2 = segment.getOrigin();
			orthoPoint2.translate(-origin.x, -origin.y);
			result.add(orthoPoint2);
		}

		// add first point to close the polyline per "poly" area type HTML
		// requirements
		result.add(result.get(0));

		return result;
	}

	/**
	 * transforms coordinates of the polyline from logical units to device units
	 * 
	 * @@param polyPts
	 * @@return List of Point type objects (that carry X and Y coordinate pair)
	 *         representing the polyline
	 * @@author Barys Dubauski
	 */
	private List<Point> convertPolylineUnits(List<Point> polyPts) {
		List<Point> result = new ArrayList<Point>();
		IMapMode mm = getMapMode();
		for (Point point : polyPts) {
			Point newPoint = new Point(mm.LPtoDP(point.x), mm.LPtoDP(point.y));
			result.add(newPoint);
		}
		return result;
	}

	/**
	 * @@return <code>int</code> value that is the margin around the generated
	 *         image in logical coordinates.
	 */
	protected int getImageMargin() {
		return image_margin;
	}

	/**
	 * Generates AWT image of specified editparts on the specified rectangle.
	 * 
	 * @@param editParts editparts
	 * @@param diagramArea clipping rectangle
	 * @@return AWT image
	 */
	public Image createAWTImageForParts(List editParts,
			org.eclipse.swt.graphics.Rectangle diagramArea) {
		return null;
	}

	final public ImageDescriptor createSWTImageDescriptorForParts(
			List editparts, org.eclipse.swt.graphics.Rectangle sourceRect) {

		// initialize imageDesc to the error icon
		ImageDescriptor imageDesc = new ImageDescriptor() {

			/*
			 * (non-Javadoc)
			 * 
			 * @@see org.eclipse.jface.resource.ImageDescriptor#getImageData()
			 */
			public ImageData getImageData() {
				return SharedImages.get(SharedImages.IMG_ERROR).getImageData();
			}
		};

		Graphics graphics = null;
		try {
			IMapMode mm = getMapMode();

			// Create the graphics and wrap it with the HiMetric graphics object
			graphics = setUpGraphics(mm.LPtoDP(sourceRect.width), mm
					.LPtoDP(sourceRect.height));

			RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics(
					graphics, getMapMode());

			renderToGraphics(mapModeGraphics, new Point(sourceRect.x,
					sourceRect.y), editparts);
			imageDesc = getImageDescriptor(graphics);
		} finally {
			if (graphics != null)
				disposeGraphics(graphics);
		}

		return imageDesc;
	}
	
	/**
	 * Creates an SWT image descriptor for editparts. Editparts are scaled to fit in maxDeviceWidth and maxDeviceHeight
	 * frame
	 * 
	 * @@param editParts editparts
	 * @@param maxDeviceWidth max width for the image
	 * @@param maxDeviceHeight max height for the image
	 * @@param useMargins true if 10 pisels margins are required to bound the editparts image
	 * @@return the image descriptor
	 */
	final public ImageDescriptor createConstrainedSWTImageDecriptorForParts(List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
		ImageDescriptor imageDesc = new ImageDescriptor() {

			/*
			 * (non-Javadoc)
			 * 
			 * @@see org.eclipse.jface.resource.ImageDescriptor#getImageData()
			 */
			public ImageData getImageData() {
				return SharedImages.get(SharedImages.IMG_ERROR).getImageData();
			}
		};
		
		Graphics graphics = null;
		try {
			IMapMode mm = getMapMode();

			ConstrainedImageRenderingData data = getConstrainedImageRenderingData(editParts, maxDeviceWidth, maxDeviceHeight, useMargins);

			// Create the graphics and wrap it with the HiMetric graphics object
			graphics = setUpGraphics(data.imageWidth, data.imageHeight);

			ScaledGraphics scaledGraphics = new ScaledGraphics(graphics);
			
			RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics(
					scaledGraphics, getMapMode());
			
			graphics.translate(data.margin, data.margin);
			mapModeGraphics.scale(data.scalingFactor);

			Point location = new PrecisionPoint(data.imageOriginalBounds.preciseX(), data.imageOriginalBounds.preciseY());
			mm.DPtoLP(location);
			renderToGraphics(mapModeGraphics, location, editParts);
			imageDesc = getImageDescriptor(graphics);
		} finally {
			if (graphics != null)
				disposeGraphics(graphics);
		}

		return imageDesc;
	}
	
	class ConstrainedImageRenderingData {
		double scalingFactor;
		int imageWidth; // in pixels
		int imageHeight; // in pixels
		Rectangle imageOriginalBounds; // in pixels
		int margin; // margins size in pixels
	}
	
	ConstrainedImageRenderingData getConstrainedImageRenderingData(List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
		ConstrainedImageRenderingData data = new ConstrainedImageRenderingData();
		IMapMode mm = getMapMode();
		
		data.imageOriginalBounds = new PrecisionRectangle(new Rectangle(calculateImageRectangle(editParts)));
		mm.LPtoDP(data.imageOriginalBounds);
		
		int deviceMargins = mm.LPtoDP(getImageMargin());
		data.margin = useMargins ? deviceMargins : 0; 
		double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
		
		data.imageOriginalBounds.shrink(deviceMargins, deviceMargins);
		
		if (maxDeviceWidth > data.margin) {
			xScalingFactor = (maxDeviceWidth  - data.margin - data.margin)/ (data.imageOriginalBounds.preciseWidth());
		}
		if (maxDeviceHeight > data.margin) {
			yScalingFactor = (maxDeviceHeight - data.margin - data.margin) / (data.imageOriginalBounds.preciseHeight());
		}
		
		data.scalingFactor = Math.min(Math.min(xScalingFactor, yScalingFactor), 1);
		
		data.imageWidth = data.imageOriginalBounds.width + data.margin + data.margin;
		data.imageHeight = data.imageOriginalBounds.height + data.margin + data.margin;
				
		if (data.scalingFactor < 1) {
			data.imageWidth = (int) Math.round(data.imageOriginalBounds.preciseWidth() * data.scalingFactor) + data.margin + data.margin;
			data.imageHeight = (int) Math.round(data.imageOriginalBounds.preciseHeight() * data.scalingFactor) + data.margin + data.margin;
		} else {
			data.scalingFactor = 1;
		}
		return data;
	}
	
	/**
	 * Creates an AWT image for editparts. Editparts are scaled to fit in maxDeviceWidth and maxDeviceHeight
	 * frame
	 * 
	 * @@param editParts editparts
	 * @@param maxDeviceWidth max width for the image
	 * @@param maxDeviceHeight max height for the image
	 * @@param useMargins true if 10 pisels margins are required to bound the editparts image
	 * @@return the image
	 */
	public Image createConstrainedAWTImageForParts(List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
		return null;
	}

}@


1.14
log
@[233585] gmf_head aboyko 080522 [ImageSupport] Diagram Image Export API additions to enable BIRT integration
@
text
@d636 2
a637 2
		List result = new ArrayList();
		List editParts = new ArrayList();
d639 1
a639 1
		List children = diagramEditPart.getPrimaryEditParts();
d648 1
a648 3
		Iterator li = children.iterator();
		while (li.hasNext()) {
			IGraphicalEditPart part = (IGraphicalEditPart) li.next();
d653 1
a653 3
		Iterator iter = editParts.iterator();
		while (iter.hasNext()) {
			IGraphicalEditPart part = (IGraphicalEditPart) iter.next();
d690 1
a690 1
					List envelopingPts = calculateEnvelopingPolyline(mainPts,
d692 83
a774 1
					List transformedPts = convertPolylineUnits(envelopingPts);
d831 3
a833 3
	private List calculateEnvelopingPolyline(PointList polyPts, Point origin) {
		ArrayList result = new ArrayList();
		List mainSegs = PointListUtilities.getLineSegments(polyPts);
d868 1
a868 2
		Object first = result.get(0);
		result.add(first);
d881 2
a882 4
	private List convertPolylineUnits(List polyPts) {
		ArrayList result = new ArrayList();
		Iterator iter = polyPts.iterator();

d884 1
a884 3

		while (iter.hasNext()) {
			Point point = (Point) iter.next();
a887 1

d976 1
a976 26
			Rectangle originalBounds = new PrecisionRectangle(new Rectangle(calculateImageRectangle(editParts)));
			getMapMode().LPtoDP(originalBounds);
			
			int deviceMargins = mm.LPtoDP(getImageMargin());
			int threshold = useMargins ? deviceMargins : 0; 
			double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
			
			originalBounds.shrink(deviceMargins, deviceMargins);
			
			if (maxDeviceWidth > threshold) {
				xScalingFactor = (maxDeviceWidth  - threshold - threshold)/ (originalBounds.preciseWidth());
			}
			if (maxDeviceHeight > threshold) {
				yScalingFactor = (maxDeviceHeight - threshold - threshold) / (originalBounds.preciseHeight());
			}
			
			double scalingFactor = Math.min(Math.min(xScalingFactor, yScalingFactor), 1);
			
			int imageWidth = originalBounds.width + threshold + threshold;
			int imageHeight = originalBounds.height + threshold + threshold;
			
			if (scalingFactor < 1) {
				imageWidth = (int) Math.round(originalBounds.preciseWidth() * scalingFactor) + threshold + threshold;
				imageHeight = (int) Math.round(originalBounds.preciseHeight() * scalingFactor) + threshold + threshold;
			}
			
d979 1
a979 1
			graphics = setUpGraphics(imageWidth, imageHeight);
d986 2
a987 2
			graphics.translate(threshold, threshold);
			mapModeGraphics.scale(scalingFactor);
d989 1
a989 1
			Point location = new PrecisionPoint(originalBounds.preciseX(), originalBounds.preciseY());
d1001 42
@


1.14.2.1
log
@[239653] gmf_R2_1_maintenance aboyko 080827 [ImageSupport] Support DiagramPartInfo API for exporting the scaled down diagram to image
@
text
@d636 2
a637 2
		List<PartPositionInfo> result = new ArrayList<PartPositionInfo>();
		List<IGraphicalEditPart> editParts = new ArrayList<IGraphicalEditPart>();
d639 1
a639 1
		List<IGraphicalEditPart> children = (List<IGraphicalEditPart>) diagramEditPart.getPrimaryEditParts();
d648 3
a650 1
		for (IGraphicalEditPart part : children) {
d655 3
a657 1
		for (IGraphicalEditPart part : editParts) {
d694 1
a694 1
					List<Point> envelopingPts = calculateEnvelopingPolyline(mainPts,
d696 1
a696 83
					List<Point> transformedPts = convertPolylineUnits(envelopingPts);

					position.setPolyline(transformedPts);
					result.add(0, position);
				}
			}
		}
		return result;
	}
	
	public List<PartPositionInfo> getConstrainedDiagramPartInfo(int maxWidth, int maxHeight, boolean useMargins) {
		return getConstrainedDiagramPartInfo(_dgrmEP, maxWidth, maxHeight, useMargins);
	}
	
	public List<PartPositionInfo> getConstrainedDiagramPartInfo(DiagramEditPart diagramEditPart, int maxWidth, int maxHeight, boolean useMargins) {
		List<PartPositionInfo> result = new ArrayList<PartPositionInfo>();
		List<IGraphicalEditPart> editParts = new ArrayList<IGraphicalEditPart>();

		List<IGraphicalEditPart> children = (List<IGraphicalEditPart>) diagramEditPart.getPrimaryEditParts();
		IMapMode mm = getMapMode();

		// We will use the diagram generate that was used to generate the image
		// to figure out the outer-bound rectangle so that we are calculating
		// the
		// image positions using the same box as was used to create the image.
		ConstrainedImageRenderingData data = getConstrainedImageRenderingData(children, maxWidth, maxHeight, useMargins);
		Rectangle imageRect = data.imageOriginalBounds.getCopy();
		mm.DPtoLP(imageRect);
		if (useMargins) {
			imageRect.shrink(getImageMargin(), getImageMargin());
		}
		imageRect.performScale(data.scalingFactor);
		if (useMargins) {
			imageRect.expand(getImageMargin(), getImageMargin());
		}

		for (IGraphicalEditPart part : children) {
			editParts.add(part);
			getNestedEditParts(part, editParts);
		}

		for (IGraphicalEditPart part : editParts) {
			IFigure figure = part.getFigure();

			// RATLC00139941: Need to support any kind of shape edit part
			// and shape compartments, too, because these sometimes
			// correspond to distinct semantic elements
			if (part instanceof ShapeEditPart
					|| part instanceof ShapeCompartmentEditPart) {

				PartPositionInfo position = new PartPositionInfo();

				position.setSemanticElement(ViewUtil
						.resolveSemanticElement((View) part.getModel()));

				Rectangle bounds = figure.getBounds().getCopy();
				translateToPrintableLayer(figure, bounds);
				bounds.performScale(data.scalingFactor);
				bounds.translate(-imageRect.x, -imageRect.y);

				position.setPartHeight(mm.LPtoDP(bounds.height));
				position.setPartWidth(mm.LPtoDP(bounds.width));
				position.setPartX(mm.LPtoDP(bounds.x));
				position.setPartY(mm.LPtoDP(bounds.y));
				result.add(0, position);
			} else if (part instanceof ConnectionEditPart) {
				// find a way to get (P1, P2, ... PN) for connection edit part
				// add MARGIN and calculate "stripe" for the polyline instead of
				// bounding box.
				PartPositionInfo position = new PartPositionInfo();

				position.setSemanticElement(ViewUtil
						.resolveSemanticElement((View) part.getModel()));

				if (figure instanceof PolylineConnection) {
					PolylineConnection mainPoly = (PolylineConnection) figure;
					PointList mainPts = mainPoly.getPoints();
					mainPts.performScale(data.scalingFactor);

					translateToPrintableLayer(figure, mainPts);
					List<Point> envelopingPts = calculateEnvelopingPolyline(mainPts,
							new Point(imageRect.x, imageRect.y));
					List<Point> transformedPts = convertPolylineUnits(envelopingPts);
d753 3
a755 3
	private List<Point> calculateEnvelopingPolyline(PointList polyPts, Point origin) {
		List<Point> result = new ArrayList<Point>();
		List<LineSeg> mainSegs = (List<LineSeg>) PointListUtilities.getLineSegments(polyPts);
d790 2
a791 1
		result.add(result.get(0));
d804 4
a807 2
	private List<Point> convertPolylineUnits(List<Point> polyPts) {
		List<Point> result = new ArrayList<Point>();
d809 3
a811 1
		for (Point point : polyPts) {
d815 1
d904 26
a929 1
			ConstrainedImageRenderingData data = getConstrainedImageRenderingData(editParts, maxDeviceWidth, maxDeviceHeight, useMargins);
d932 1
a932 1
			graphics = setUpGraphics(data.imageWidth, data.imageHeight);
d939 2
a940 2
			graphics.translate(data.margin, data.margin);
			mapModeGraphics.scale(data.scalingFactor);
d942 1
a942 1
			Point location = new PrecisionPoint(data.imageOriginalBounds.preciseX(), data.imageOriginalBounds.preciseY());
a953 42
	class ConstrainedImageRenderingData {
		double scalingFactor;
		int imageWidth; // in pixels
		int imageHeight; // in pixels
		Rectangle imageOriginalBounds; // in pixels
		int margin; // margins size in pixels
	}
	
	ConstrainedImageRenderingData getConstrainedImageRenderingData(List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
		ConstrainedImageRenderingData data = new ConstrainedImageRenderingData();
		IMapMode mm = getMapMode();
		
		data.imageOriginalBounds = new PrecisionRectangle(new Rectangle(calculateImageRectangle(editParts)));
		mm.LPtoDP(data.imageOriginalBounds);
		
		int deviceMargins = mm.LPtoDP(getImageMargin());
		data.margin = useMargins ? deviceMargins : 0; 
		double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
		
		data.imageOriginalBounds.shrink(deviceMargins, deviceMargins);
		
		if (maxDeviceWidth > data.margin) {
			xScalingFactor = (maxDeviceWidth  - data.margin - data.margin)/ (data.imageOriginalBounds.preciseWidth());
		}
		if (maxDeviceHeight > data.margin) {
			yScalingFactor = (maxDeviceHeight - data.margin - data.margin) / (data.imageOriginalBounds.preciseHeight());
		}
		
		data.scalingFactor = Math.min(Math.min(xScalingFactor, yScalingFactor), 1);
		
		data.imageWidth = data.imageOriginalBounds.width + data.margin + data.margin;
		data.imageHeight = data.imageOriginalBounds.height + data.margin + data.margin;
				
		if (data.scalingFactor < 1) {
			data.imageWidth = (int) Math.round(data.imageOriginalBounds.preciseWidth() * data.scalingFactor) + data.margin + data.margin;
			data.imageHeight = (int) Math.round(data.imageOriginalBounds.preciseHeight() * data.scalingFactor) + data.margin + data.margin;
		} else {
			data.scalingFactor = 1;
		}
		return data;
	}
	
@


1.13
log
@[230998] gmf_head aboyko 080509 [ImageSupport] Connections between connections are not drawn on diagram exported to image file
@
text
@d25 1
d31 2
d53 1
d609 14
d876 92
@


1.12
log
@[214654] gmf_head crevells 080108 Non-volatile shape decorations are not copied when a container is selected and copied
@
text
@d17 1
d19 1
d23 1
d33 1
a33 1
import org.eclipse.gef.EditPartViewer;
a35 1
import org.eclipse.gef.editparts.AbstractEditPart;
a37 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.ConnectionNodeEditPart;
a52 1
import org.eclipse.gmf.runtime.notation.Edge;
d202 1
a202 1
		ArrayList connectionsToPaint = new ArrayList();
d206 2
a207 3
		for (int i = 0; i < editparts.size(); i++) {
			IGraphicalEditPart editPart = (IGraphicalEditPart) sortedEditparts
					.get(i);
d210 1
a210 1
			if (editPart instanceof ConnectionNodeEditPart) {
d212 2
a213 9
			} else {
				List editParts = new ArrayList();

				// Get the list of edit parts
				getNestedEditParts(editPart, editParts);

				// Find the connections to be painted
				findConnectionsToPaint(editParts, connectionsToPaint);

d221 1
a221 1

d225 2
a226 4
		for (int i = 0; i < connectionsToPaint.size(); i++) {
			IGraphicalEditPart editPart = (IGraphicalEditPart) connectionsToPaint
					.get(i);
			IFigure figure = editPart.getFigure();
a227 1

d231 99
d377 1
a377 1
	private Map findDecorations(List editparts) {
d385 1
a385 1
			IGraphicalEditPart first = (IGraphicalEditPart) editparts.get(0);
d535 1
a535 1
			List editParts) {
a546 46
	 * Given a selection of editParts determine which source connections have
	 * both the source and target selected.
	 * 
	 * @@param editParts
	 * @@param connectionsToPaint
	 *            the edit parts for connections will be appended to this list
	 */
	private void findConnectionsToPaint(List editParts, List connectionsToPaint) {

		EditPartViewer viewer = getDiagramEditPart().getRoot().getViewer();

		// For each edit part
		for (Iterator iter = editParts.iterator(); iter.hasNext();) {
			IGraphicalEditPart element = (IGraphicalEditPart) iter.next();

			// Get its view
			View view = (View) element.getModel();

			// If the view is a shape view...
			if (element instanceof ShapeEditPart) {
				// Get its connections source
				List sourceConnections = view.getSourceEdges();

				// For each source connection...
				for (int i = 0; i < sourceConnections.size(); i++) {
					Edge edge = (Edge) sourceConnections.get(i);

					// Get the connections target
					View toView = (edge).getTarget();

					AbstractEditPart toEditPart = (AbstractEditPart) viewer
							.getEditPartRegistry().get(toView);

					if (editParts.contains(toEditPart)) {

						ConnectionNodeEditPart connectionEditPart = (ConnectionNodeEditPart) viewer
								.getEditPartRegistry().get(edge);

						connectionsToPaint.add(connectionEditPart);
					}
				}
			}
		}
	}

	/**
a857 1

@


1.11
log
@[160386] gmf_head aboyko 070731 [ImageSupport] Save as Image fails when saving large diagrams
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d318 18
a335 13
						if (figureMap.containsKey(owner)) {
							Object existing = result.get(owner);

							if (existing == null) {
								result.put(owner, decoration);
							} else if (existing instanceof Collection) {
								((Collection) existing).add(decoration);
							} else {
								Collection c = new java.util.ArrayList(2);
								c.add(existing);
								c.add(decoration);
								result.put(owner, c);
							}
@


1.10
log
@[172052]  gmf_head mmostafa 070129 getDiagramPartInfo returns empty list (regression)
@
text
@a34 1
import org.eclipse.gmf.runtime.common.core.util.Trace;
a45 2
import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderPlugin;
d141 4
a144 1
	abstract public Image createAWTImageForParts(List editparts);
d169 1
a169 47

		// initialize imageDesc to the error icon
		ImageDescriptor imageDesc = new ImageDescriptor() {

			/*
			 * (non-Javadoc)
			 * 
			 * @@see org.eclipse.jface.resource.ImageDescriptor#getImageData()
			 */
			public ImageData getImageData() {
				return SharedImages.get(
					SharedImages.IMG_ERROR).getImageData();
			}
		};

		Graphics graphics = null;
		try {
			IMapMode mm = getMapMode();
			
			// Create the graphics and wrap it with the HiMetric graphics object
			graphics = setUpGraphics(mm.LPtoDP(sourceRect.width), mm
				.LPtoDP(sourceRect.height));

			RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics(
				graphics, getMapMode());

			renderToGraphics(mapModeGraphics, new Point(sourceRect.x, sourceRect.y), editparts);
			imageDesc = getImageDescriptor(graphics);
		} catch (Error e) {
			// log the Error but allow execution to continue
			Trace.catching(DiagramUIRenderPlugin.getInstance(),
				DiagramUIRenderDebugOptions.EXCEPTIONS_THROWING, getClass(),
				"createSWTImageDescriptorForParts() failed to generate image", //$NON-NLS-1$
				e);

		} catch (Exception ex) {
			// log the Exception but allow execution to continue
			Trace.catching(DiagramUIRenderPlugin.getInstance(),
				DiagramUIRenderDebugOptions.EXCEPTIONS_THROWING, getClass(),
				"createSWTImageDescriptorForParts() failed to generate image", //$NON-NLS-1$
				ex);
		}

		if (graphics != null)
			disposeGraphics(graphics);

		return imageDesc;
d186 4
a189 3
	 * @@param translateOffset 
	 * 			  a <code>Point</code> that the value the <code>graphics</code> object
	 * 		   	  will be translated by in relative coordinates.
d208 1
a208 1
				.get(i);
d235 1
a235 1
				.get(i);
d259 6
a264 5
        if (figure instanceof IExpandableFigure)
            relBounds = ((IExpandableFigure)figure).getExtendedBounds().getCopy();
        else
            relBounds = figure.getBounds().getCopy();
        
d300 1
a300 1
				DiagramRootEditPart.DECORATION_PRINTABLE_LAYER);
d311 1
a311 1
					.hasNext();) {
d378 1
a378 1
					.hasNext();) {
d445 1
a445 1
			.hasNext();) {
d485 1
a485 1
						.getEditPartRegistry().get(toView);
d490 1
a490 1
							.getEditPartRegistry().get(edge);
d510 1
a510 1
	protected org.eclipse.swt.graphics.Rectangle calculateImageRectangle(
d518 1
a518 1
		
d524 4
a527 4
            if (figure instanceof IExpandableFigure)
                bounds = ((IExpandableFigure)figure).getExtendedBounds();
            else
                bounds = figure.getBounds().getCopy();
d555 1
a555 1
			minX, minY, width, height);
d599 1
a599 1
				|| part instanceof ShapeCompartmentEditPart) {
d601 1
a601 1
				    PartPositionInfo position = new PartPositionInfo();
d603 1
a603 1
					position.setSemanticElement(ViewUtil
d606 10
a615 11
					Rectangle bounds = figure.getBounds().getCopy();
					translateToPrintableLayer( figure, bounds );
					bounds.translate( -imageRect.x, -imageRect.y );

					position.setPartHeight(mm.LPtoDP(bounds.height));
					position.setPartWidth(mm.LPtoDP(bounds.width));
					position.setPartX(mm.LPtoDP(bounds.x));
					position.setPartY(mm.LPtoDP(bounds.y));
					result.add(0, position);
			}
			else if (part instanceof ConnectionEditPart) {
d617 1
a617 1
				// add MARGIN and calculate "stripe" for the polyline instead of 
d619 1
a619 1
			    PartPositionInfo position = new PartPositionInfo();
d622 1
a622 1
					.resolveSemanticElement((View) part.getModel()));
d625 1
a625 1
					PolylineConnection mainPoly = (PolylineConnection)figure;
d627 4
a630 3
					
					translateToPrintableLayer( figure, mainPts );
					List envelopingPts = calculateEnvelopingPolyline(mainPts, new Point(imageRect.x, imageRect.y));
d632 1
a632 1
					
d638 1
a638 1
	
d655 1
a655 1
			LayerConstants.PRINTABLE_LAYERS);
d663 1
a663 1
	
d675 2
a676 2
	 * On the figure above: AB is a given polyline. E1E2E3E4 is enveloping polyline
	 * built around AB perimeter using margin MARGIN.
d680 3
a682 2
	 * @@param origin location of the main diagram bounding box used to shift coordinates 
	 * 				to be relative against diagram
d684 2
a685 1
	 * @@return List of Point type objects (that carry X and Y coordinate pair) representing the polyline
d691 1
a691 1
		
d693 1
a693 1
		
d697 1
a697 1
		
d701 6
a706 4
			orthoPoint1 = segment.locatePoint(0.0, getImageMargin(), Sign.POSITIVE);
			orthoPoint1.translate(-origin.x, -origin.y );
			orthoPoint2 = segment.locatePoint(1.0, getImageMargin(), Sign.POSITIVE);
			orthoPoint2.translate(-origin.x, -origin.y );
d711 1
a711 1
		
d716 1
a716 1
			orthoPoint1.translate(-origin.x, -origin.y );
d719 1
a719 1
			orthoPoint2.translate(-origin.x, -origin.y );
d722 3
a724 2
		
		// add first point to close the polyline per "poly" area type HTML requirements
d727 1
a727 1
		
d735 2
a736 1
	 * @@return List of Point type objects (that carry X and Y coordinate pair) representing the polyline
d742 1
a742 1
		
d744 1
a744 1
		
d750 1
a750 1
		
d753 1
a753 2
	
	
d755 2
a756 1
	 * @@return <code>int</code> value that is the margin around the generated image in logical coordinates.
d760 52
a811 1
}	
@


1.9
log
@[167136]  gmf_head mmostafa 061215 DiagramGenerator#findConnectionsToPaint() filters out connections to itself
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d630 1
@


1.8
log
@[160538] gmf_R1_0_maintenace mmostafa 061011  SaveAs Image broken
@
text
@a487 1
		editParts.add(childEditPart);
d492 1
d531 1
a531 2
					if (!element.equals(toEditPart)
						&& editParts.contains(toEditPart)) {
@


1.7
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d44 1
d303 6
a308 1
		Rectangle relBounds = figure.getBounds().getCopy();
d568 5
a572 1
			Rectangle bounds = figure.getBounds().getCopy();
@


1.6
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d2 1
a2 1
 * Copyright (c) 2002 - 2005 IBM Corporation and others.
@


1.6.2.1
log
@[150280] gmf_R1_0_maintenance ahunter 060717 Incorrect copyright in some GMF files
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
@


1.6.2.2
log
@[160538] gmf_head mmostafa 061011  SaveAs Image broken
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
a43 1
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.IExpandableFigure;
d302 1
a302 6
		Rectangle relBounds = null;
        if (figure instanceof IExpandableFigure)
            relBounds = ((IExpandableFigure)figure).getExtendedBounds().getCopy();
        else
            relBounds = figure.getBounds().getCopy();
        
d562 1
a562 5
			Rectangle bounds = null;
            if (figure instanceof IExpandableFigure)
                bounds = ((IExpandableFigure)figure).getExtendedBounds();
            else
                bounds = figure.getBounds().getCopy();
@


1.6.2.3
log
@[167136]  gmf_R1_0_maintenace  mmostafa 061215 DiagramGenerator#findConnectionsToPaint() filters out connections to itself
@
text
@d488 1
a492 1
			editParts.add(child);
d531 2
a532 1
					if (editParts.contains(toEditPart)) {
@


1.6.2.4
log
@[172052]  gmf__R1_0_maintenace mmostafa 070129 getDiagramPartInfo returns empty list (regression)
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
a629 1
            editParts.add(part);
@


1.5
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d45 1
a45 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d178 2
a179 2
				return DiagramResourceManager.getInstance().getImage(
					DiagramResourceManager.IMAGE_ERROR).getImageData();
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051029 API: Encapsulate MapMode / HiMetric coordinate system from clients

First phase delivery...
@
text
@d45 1
a45 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.Images;
d158 1
a158 1
	 * connectors where both the source and target editparts are passed in are
d178 2
a179 1
				return Images.ICON_ERROR.getImageData();
d226 1
a226 1
	 * Renders the list of editparts to the graphics object. Any connectors
d263 2
a264 2
				// Find the connectors to be painted
				findConnectorsToPaint(editParts, connectionsToPaint);
d499 1
a499 1
	private void findConnectorsToPaint(List editParts, List connectionsToPaint) {
d517 1
a517 1
					Edge connectorView = (Edge) sourceConnections.get(i);
d520 1
a520 1
					View toView = (connectorView).getTarget();
d528 2
a529 2
						ConnectionNodeEditPart connectorEditPart = (ConnectionNodeEditPart) viewer
							.getEditPartRegistry().get(connectorView);
d531 1
a531 1
						connectionsToPaint.add(connectorEditPart);
d611 1
a611 1
		
d781 1
a781 1

d788 1
a788 2
	}
	
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a34 3
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.swt.graphics.ImageData;

d36 1
a47 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d51 2
a52 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d56 2
d68 1
a68 1
	private static final int IMAGE_MARGIN = MapMode.DPtoLP(10);
d80 1
d184 2
d187 1
a187 1
			graphics = setUpGraphics(MapMode.LPtoDP(sourceRect.width), MapMode
d191 1
a191 1
				graphics);
d217 8
d555 2
d563 1
a563 1
			bounds = bounds.getExpanded(IMAGE_MARGIN, IMAGE_MARGIN);
d581 1
a581 1
			width = MapMode.DPtoLP(100);
d585 1
a585 1
			height = MapMode.DPtoLP(100); // create an empty image if the
d609 2
a610 1

d643 4
a646 4
					position.setPartHeight(MapMode.LPtoDP(bounds.height));
					position.setPartWidth(MapMode.LPtoDP(bounds.width));
					position.setPartX(MapMode.LPtoDP(bounds.x));
					position.setPartY(MapMode.LPtoDP(bounds.y));
d732 1
a732 1
			orthoPoint1 = segment.locatePoint(0.0, IMAGE_MARGIN, Sign.POSITIVE);
d734 1
a734 1
			orthoPoint2 = segment.locatePoint(1.0, IMAGE_MARGIN, Sign.POSITIVE);
d769 3
d774 1
a774 1
			Point newPoint = new Point(MapMode.LPtoDP(point.x), MapMode.LPtoDP(point.y));
d780 8
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002 - 2005.  All Rights Reserved.             |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d54 2
a55 2
import com.ibm.xtools.notation.Edge;
import com.ibm.xtools.notation.View;
@

