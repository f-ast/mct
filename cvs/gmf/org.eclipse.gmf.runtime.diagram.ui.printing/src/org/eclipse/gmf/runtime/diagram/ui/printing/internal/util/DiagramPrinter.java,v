head	1.16;
access;
symbols
	v20081020-0700:1.16
	v20080911-1728:1.16
	v20080911-1506:1.16
	v20080722-1827:1.16
	R2_1_maintenance:1.16.0.2
	Root_R2_1_maintenance:1.16
	R2_1_0:1.16
	v20080501-1739:1.16
	v20080425-1959:1.16
	v20080407-2250:1.15
	v20080407-0930:1.15
	v20080404-1111:1.15
	v20080328-1605:1.15
	v20080322-0000:1.15
	v20080222-1200:1.14
	v20071108-0000:1.14
	v20071003-0000:1.14
	v20070809-0000:1.13
	R2_0_maintenance:1.13.0.2
	R2_0:1.13
	R4_20:1.13
	v20070621-0000:1.13
	RC3_20:1.13
	v20070601-1400:1.13
	v20070330-1300:1.13
	v20060316-0600:1.13
	v20070208-1800:1.12
	v20070202-0200:1.7.2.7
	M4_20:1.11
	v20061218-1500:1.7.2.6
	v20061214-0000:1.11
	M3_20:1.9
	v20061117-0800:1.9
	v20061027-1200:1.7.2.4
	v20061020-1000:1.7.2.3
	v20061013-1330:1.8
	v20060919-0800:1.7.2.2
	M1_20:1.7
	v20060721-1130:1.7.2.2
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060531-1730:1.7
	I20060424-0500:1.7
	I20060424-0300:1.7
	M6_10:1.7
	I20060407-1200:1.7
	I20060331-1000:1.7
	I20060324-0300:1.7
	I20060317-1300:1.7
	I20060317-1200:1.7
	I20060316-1300:1.7
	I20060309-1300:1.7
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.6
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.6
	I20060129-1145:1.6
	I20060127-0900:1.6
	I20060120-1530:1.6
	I20060113-1700:1.6
	M4_10:1.6
	I20060107-1100:1.6
	I20060105-1630:1.6
	I20051230-1230:1.6
	I20051223-1100:1.6
	I20051201-1800:1.6
	I20051124-2000:1.6
	M3_10:1.6
	I20051118-1245:1.6
	I20051111-1800:1.6
	I20051106-0900:1.6
	v20051030:1.4;
locks; strict;
comment	@# @;


1.16
date	2008.04.24.14.45.39;	author ahunter;	state Exp;
branches;
next	1.15;
commitid	6ec548109d134567;

1.15
date	2008.03.07.16.51.34;	author ahunter;	state Exp;
branches;
next	1.14;
commitid	29ec47d172944567;

1.14
date	2007.09.21.15.39.47;	author aboyko;	state Exp;
branches;
next	1.13;
commitid	57d046f3e5c24567;

1.13
date	2007.03.13.17.43.54;	author crevells;	state Exp;
branches;
next	1.12;
commitid	58a45f6e2d94567;

1.12
date	2007.01.29.19.37.34;	author aboyko;	state Exp;
branches;
next	1.11;
commitid	40b945be4cfe4567;

1.11
date	2006.11.23.21.11.22;	author mmostafa;	state Exp;
branches;
next	1.10;
commitid	279845660e7a4567;

1.10
date	2006.11.23.14.45.12;	author crevells;	state Exp;
branches;
next	1.9;
commitid	6fb64565b3f84567;

1.9
date	2006.10.18.00.12.16;	author ahunter;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.03.15.03.03;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.08.19.52.57;	author sshaw;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2005.11.04.22.13.20;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.04.21.27.51;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.28.14.29.43;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.28.04;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.06;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.50;	author sshaw;	state Exp;
branches;
next	;

1.7.2.1
date	2006.07.17.19.47.19;	author cmahoney;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2006.07.17.19.50.21;	author ahunter;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2006.10.18.00.07.05;	author ahunter;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2006.10.26.15.17.35;	author mmostafa;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2006.11.22.22.39.29;	author crevells;	state Exp;
branches;
next	1.7.2.6;
commitid	74b74564d1a14567;

1.7.2.6
date	2006.11.23.21.10.33;	author mmostafa;	state Exp;
branches;
next	1.7.2.7;
commitid	215745660e494567;

1.7.2.7
date	2007.02.01.15.39.02;	author ahunter;	state Exp;
branches;
next	;
commitid	16dc45c209954567;


desc
@@


1.16
log
@[227373] gmf-head jbruck 080424 [Printing] Combined commit for Bug 228057 , Bug 227796 , Bug 227006 and Bug 227373
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.printing.internal.util;

import java.util.Collection;

import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.RootEditPart;
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.PageBreakEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.PageBreaksFigure;
import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.MapModeGraphics;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.swt.graphics.Point;


/**
 * Basic page calculation operations have been factored out into this class.
 * This class was derived from the previous DiagramPrinter.
 * 
 * @@author Wayne Diu, wdiu
 */
public abstract class DiagramPrinter implements Runnable {

	protected Point display_dpi;
	protected Collection<Diagram> diagrams;
	protected PreferencesHint preferencesHint;
	protected IMapMode mapMode;
	protected Point translated;

	protected float userScale;
	protected boolean isScaledPercent = false;
	protected boolean fitToPage = false;
	protected boolean printRangePageSelection = false;

	protected int pageFrom = 1, pageTo = 1;
	protected int rows = 1;

	protected int columns = 1;

	protected Graphics swtGraphics;
	protected Graphics graphics;

	public DiagramPrinter(PreferencesHint preferencesHint, IMapMode mm) {
		super();
		this.preferencesHint = preferencesHint;
		this.mapMode = mm;
	}

	/**
	 * Obtains the total number of pages that span columns and rows
	 * @@param dgrmEP
	 * @@return Point.x contains the total number of pages that span in a column
	 *         Point.y contains the total number of pages that span in a row
	 */
	protected org.eclipse.draw2d.geometry.Point getPageCount(
			DiagramEditPart dgrmEP, Rectangle figureBounds,
			org.eclipse.draw2d.geometry.Point pageSize, boolean applyUserScale) {
		RootEditPart rootEditPart = dgrmEP.getRoot();

		if (rootEditPart instanceof DiagramRootEditPart) {

			DiagramRootEditPart diagramRootEditPart = (DiagramRootEditPart) rootEditPart;
			PageBreakEditPart pageBreakEditPart = diagramRootEditPart
					.getPageBreakEditPart();

			float fNumCols = ((PageBreaksFigure) pageBreakEditPart.getFigure())
					.getPageCount().y
					* (applyUserScale ? userScale : 1);

			float fNumRows = ((PageBreaksFigure) pageBreakEditPart.getFigure())
					.getPageCount().x
					* (applyUserScale ? userScale : 1);

			int numCols = (int) Math.ceil(fNumCols);
			int numRows = (int) Math.ceil(fNumRows);

			return new org.eclipse.draw2d.geometry.Point(numCols, numRows);

		} else {

			float fNumRows = (figureBounds.height * (applyUserScale ? userScale
					: 1))
					/ pageSize.y;
			int numRows = (int) Math.ceil(fNumRows);

			float fNumCols = (figureBounds.width * (applyUserScale ? userScale
					: 1))
					/ pageSize.x;
			int numCols = (int) Math.ceil(fNumCols);

			return new org.eclipse.draw2d.geometry.Point(numCols, numRows);
		}
	}

	/**
	 * Calculates the row in a grid, given a page number.
	 * | 1 | 2 | 3 |
	 * | 4 | 5 | 6 |
	 * | 7 | 8 | 9 |
	 * 
	 * Given pageNum=5 and totalNumColumns=3, will return 2
	 * (2nd row).
	 * 
	 * @@param pageNum the page number in the grid.
	 * @@param totalNumColumns total number of columns of the grid.
	 * @@return row number corresponding to the page number.
	 */
	protected int calculateRowFromPage(int pageNum, int totalNumColumns) {
		int row = pageNum / totalNumColumns;
		if (pageNum % totalNumColumns != 0) {
			row++;
		}
		return row;
	}

	/**
	 * Calculates the column in a grid, given a page number.
	 * | 1 | 2 | 3 |
	 * | 4 | 5 | 6 |
	 * | 7 | 8 | 9 |
	 * 
	 * Given pageNum=5 and totalNumColumns=3, will return 2
	 * (2nd column).
	 *  
	 * @@param pageNum the page number in the grid.
	 * @@param totalNumColumns total number of columns of the grid.
	 * @@param cRow the corresponding row of the page number.
	 * @@return row number corresponding to the page number.
	 */
	protected int calculateColumnFromPage(int pageNum, int totalNumColumns,
			int cRow) {

		return (pageNum - ((cRow - 1) * totalNumColumns));
	}

	
	/**
	 * Disposes of the resources.
	 */
	protected void dispose() {
		if (this.graphics != null) {
			try {
				this.graphics.dispose();
			} catch (NullPointerException e) {
				//do nothing
			} finally {
				this.graphics = null;
			}
		}

		if (this.swtGraphics != null) {
			try {
				this.swtGraphics.dispose();
			} catch (NullPointerException e) {
				//do nothing
			} finally {
				this.swtGraphics = null;
			}
		}
	}

	/**
     * Creates the <code>MapModeGraphics</code>.
     * 
     * @@param theGraphics
     *            the <code>PrinterGraphics</code> object
     * @@return the new <code>MapModeGraphics</code>
     */
    protected MapModeGraphics createMapModeGraphics(Graphics theGraphics) {
        return new MapModeGraphics(theGraphics, getMapMode());
    }
    
	public void setPrintRangePages(int pageFrom, int pageTo) {
		assert pageFrom > 0 : "From page in print range page selection must be bigger than zero."; //$NON-NLS-1$
		assert (pageTo > 0 && pageTo >= pageFrom) : "To page in print range page selection must be bigger than zero and from page."; //$NON-NLS-1$
		this.pageFrom = pageFrom;
		this.pageTo = pageTo;
	}

	public Point getDisplayDPI() {
		return display_dpi;
	}

	public void setDisplayDPI(Point display_dpi) {
		this.display_dpi = display_dpi;
	}

	public PreferencesHint getPreferencesHint() {
		return preferencesHint;
	}

	public void setPreferencesHint(PreferencesHint preferencesHint) {
		this.preferencesHint = preferencesHint;
	}

	public IMapMode getMapMode() {
		return mapMode;
	}

	public void setMapMode(IMapMode mm) {
		this.mapMode = mm;
	}

	public Point getTranslated() {
		return translated;
	}

	public void setTranslated(Point translated) {
		this.translated = translated;
	}

	public float getUserScale() {
		return userScale;
	}

	public void setScaledPercent(int scalePercent) {
		this.isScaledPercent = true;
		this.userScale = (scalePercent) / 100.0f;
	}

	public void setScaledPercent(boolean isScaledPercent) {
		this.isScaledPercent = isScaledPercent;
	}

	public boolean isFitToPage() {
		return fitToPage;
	}

	public void setFitToPage(boolean fitToPage) {
		this.fitToPage = fitToPage;
	}

	public boolean isPrintRangePageSelection() {
		return printRangePageSelection;
	}

	public void setPrintRangePageSelection(boolean printRangePageSelection) {
		this.printRangePageSelection = printRangePageSelection;
	}

	public int getPageFrom() {
		return pageFrom;
	}

	public void setPageFrom(int pageFrom) {
		this.pageFrom = pageFrom;
	}

	public int getPageTo() {
		return pageTo;
	}

	public void setPageTo(int pageTo) {
		this.pageTo = pageTo;
	}

	public int getRows() {
		return rows;
	}

	public void setRows(int rows) {
		this.rows = rows;
	}

	public int getColumns() {
		return columns;
	}

	public void setColumns(int columns) {
		this.columns = columns;
	}

	public Graphics getSwtGraphics() {
		return swtGraphics;
	}

	public void setSwtGraphics(Graphics swtGraphics) {
		this.swtGraphics = swtGraphics;
	}

	public Graphics getGraphics() {
		return graphics;
	}

	public void setGraphics(Graphics graphics) {
		this.graphics = graphics;
	}

	public void setDiagrams(Collection<Diagram> diagrams) {
		this.diagrams = diagrams;
	}

	public Collection<Diagram> getDiagrams() {
		return diagrams;
	}

}
@


1.15
log
@[196834] gmf-head jbruck 080307 [Printing] Multi-platform Diagram Printing
@
text
@d34 1
a34 1
 * @@author James Bruck (jbruck)
@


1.14
log
@[160731] gmf_HEAD aboyko 070921 [Printing] Compartments are printed incorrectly
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
a14 1
import java.util.Iterator;
a15 1
import org.eclipse.core.runtime.Assert;
a16 1
import org.eclipse.draw2d.SWTGraphics;
a17 1
import org.eclipse.gef.LayerConstants;
a19 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
a23 6
import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper;
import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper.PageMargins;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.util.DiagramEditorUtil;
a24 2
import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.PrinterGraphics;
import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;
a25 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
a26 7
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.swt.graphics.GC;
import org.eclipse.swt.graphics.Image;
a27 4
import org.eclipse.swt.printing.Printer;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.PlatformUI;
d29 6
a34 2
/*
 * @@canBeSeenBy %level1
d36 1
a36 484
public class DiagramPrinter
    implements Runnable {

    protected Printer printer;

    private Point display_dpi;

    private boolean isScaledPercent = false;

    private int rows = 1;

    private int columns = 1;
    
    private boolean printRangePageSelection = false;
    
    private int pageFrom = 1, pageTo = 1;

    private GC gc;
    
    private Graphics swtGraphics;
    
    private Graphics graphics;
    
    private PrinterGraphics printerGraphics;
    
    protected Point printerOffset;

    protected Rectangle logicalClientArea;

    private float userScale;

    /**
     * Used when a Collection of Diagram objects are passed in instead of an
     * IEditorPart.
     */
    protected Collection diagrams;

    /**
     * The initial amount that the diagram should be translated, set by
     * printToScale or printToPages which calls drawToFitRowsColumns.
     */
    private Point translated = null;
    
    /**
     * The hint used to find the appropriate preference store from which general
     * diagramming preference values for properties of shapes, connections, and
     * diagrams can be retrieved. This hint is mapped to a preference store in
     * the {@@link DiagramPreferencesRegistry}.
     */
    private PreferencesHint preferencesHint;
    private IMapMode mm;
    
    private boolean fitToPage = false;
    
    /**
     * change the fit to page state
     * @@param fitToPage the new fit to page state
     */
    public void setFitToPage(boolean fitToPage){
        this.fitToPage = fitToPage;
    }

    /**
     * Creates a new instance. The following variables must be initialized
     * before calling <code>run()</code>:
     * <li><code>printer</code></li>
     * <li><code>display_dpi</code></li>
     * <li><code>diagrams</code></li>
     * @@param mm <code>IMapMode</code> to do the coordinate mapping
     */
    public DiagramPrinter(PreferencesHint preferencesHint, IMapMode mm) {
        super();
        this.preferencesHint = preferencesHint;
        this.mm = mm;
    }
    
    /**
     * Creates a new instance. The following variables must be initialized
     * before calling <code>run()</code>:
     * <li><code>printer</code></li>
     * <li><code>display_dpi</code></li>
     * <li><code>diagrams</code></li>
     * @@param mm <code>IMapMode</code> to do the coordinate mapping
     */
    public DiagramPrinter(PreferencesHint preferencesHint) {
        this(preferencesHint, MapModeUtil.getMapMode());
    }
    
    /**
     * @@return <code>IMapMode</code> to do the coordinate mapping
     */
    protected IMapMode getMapMode() {
        return mm;
    }
    
    /**
     * Sets the columns.
     * 
     * @@param columns
     *            The columns to set.
     */
    public void setColumns(int columns) {
        this.columns = columns;
    }

    /**
     * Sets the diagrams.
     * 
     * @@param diagrams
     *            a Collection of Diagram objects
     */
    public void setDiagrams(Collection diagrams) {
        this.diagrams = diagrams;
    }

    /**
     * Sets the display DPI.
     * 
     * @@param display_dpi
     *            The display_dpi to set.
     */
    public void setDisplayDPI(Point display_dpi) {
        this.display_dpi = new Point(display_dpi.x, display_dpi.y);
    }

    /**
     * Sets the printer.
     * 
     * @@param printer
     *            The printer to set.
     */
    public void setPrinter(Printer printer) {
        this.printer = printer;
    }
    
    public void setPrintRangePageSelection(boolean isPrintRangePageSelected) {
        this.printRangePageSelection = isPrintRangePageSelected;
    }
    
    public void setPrintRangePages(int pageFrom, int pageTo) {
        assert pageFrom > 0 : "From page in print range page selection must be bigger than zero."; //$NON-NLS-1$
        assert (pageTo > 0 && pageTo >= pageFrom) : "To page in print range page selection must be bigger than zero and from page.";  //$NON-NLS-1$
        this.pageFrom = pageFrom;
        this.pageTo = pageTo;
    }

    /**
     * Sets the rows.
     * 
     * @@param rows
     *            The rows to set.
     */
    public void setRows(int rows) {
        this.rows = rows;
    }

    /**
     * Sets the scaled percent.
     * 
     * @@param scalePercent
     */
    public void setScaledPercent(int scalePercent) {
        this.isScaledPercent = true;
        this.userScale = (scalePercent) / 100.0f;

    }

    /**
     * Prints the contents of the diagram editor part.
     */
    public void run() {
        assert null != printer : "printer must be set"; //$NON-NLS-1$
        if (!(printer.startJob("Printing"))) { //$NON-NLS-1$
          return;
        }
        
        assert diagrams != null;
        Iterator it = diagrams.iterator();

        Shell shell = new Shell();
        try {
            while (it.hasNext()) {
                Object obj = it.next();
                //the diagrams List is only supposed to have Diagram objects
                Assert.isTrue(obj instanceof Diagram);
                Diagram diagram = (Diagram)obj;
                DiagramEditor openedDiagramEditor = DiagramEditorUtil
						.findOpenedDiagramEditorForID(ViewUtil
								.getIdStr(diagram));
				DiagramEditPart dgrmEP = openedDiagramEditor == null ? PrintHelper
						.createDiagramEditPart(diagram, preferencesHint, shell)
						: openedDiagramEditor.getDiagramEditPart();
                
                boolean loadedPreferences = openedDiagramEditor != null || PrintHelper.initializePreferences(dgrmEP, preferencesHint);

                RootEditPart rep = dgrmEP.getRoot();
                if (rep instanceof DiagramRootEditPart) 
                    this.mm = ((DiagramRootEditPart)rep).getMapMode();
                
                initialize();
                
                
                IPreferenceStore pref = null;
                
                assert dgrmEP.getViewer() instanceof DiagramGraphicalViewer;
        
                pref = ((DiagramGraphicalViewer)dgrmEP.getViewer()).getWorkspaceViewerPreferenceStore();
                
                if (pref.getBoolean(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS)) {
                    
                    //get workspace settings...
                    if (dgrmEP.getDiagramPreferencesHint().getPreferenceStore() != null)
                        pref = (IPreferenceStore)dgrmEP.getDiagramPreferencesHint().getPreferenceStore(); 
                }
                
                doPrintDiagram(dgrmEP, loadedPreferences, pref);
                
                dispose();
            }
            printer.endJob();
        } finally {
            shell.dispose();
        }        
    }
    
    /**
     * Calculates the row in a grid, given a page number.
     * | 1 | 2 | 3 |
     * | 4 | 5 | 6 |
     * | 7 | 8 | 9 |
     * 
     * Given pageNum=5 and totalNumColumns=3, will return 2
     * (2nd row).
     * 
     * @@param pageNum the page number in the grid.
     * @@param totalNumColumns total number of columns of the grid.
     * @@return row number corresponding to the page number.
     */
    private int calculateRowFromPage(int pageNum, int totalNumColumns) {
        int row = pageNum / totalNumColumns;
        if (pageNum % totalNumColumns != 0)
            row++;
        return row;
    }
    
    /**
     * Calculates the column in a grid, given a page number.
     * | 1 | 2 | 3 |
     * | 4 | 5 | 6 |
     * | 7 | 8 | 9 |
     * 
     * Given pageNum=5 and totalNumColumns=3, will return 2
     * (2nd column).
     *  
     * @@param pageNum the page number in the grid.
     * @@param totalNumColumns total number of columns of the grid.
     * @@param cRow the corresponding row of the page number.
     * @@return row number corresponding to the page number.
     */
    private int calculateColumnFromPage(int pageNum, int totalNumColumns, int cRow) {
        int col = pageNum - ((cRow - 1) * totalNumColumns);
        return col;
    }
    
    /**
     * Obtains the total number of pages that span columns and rows
     * @@param dgrmEP
     * @@return Point.x contains the total number of pages that span in a column
     *         Point.y contains the total number of pages that span in a row
     */
    private org.eclipse.draw2d.geometry.Point getPageCount(DiagramEditPart dgrmEP, Rectangle figureBounds, org.eclipse.draw2d.geometry.Point pageSize, boolean applyUserScale) {
        RootEditPart rootEditPart = dgrmEP.getRoot();
        if (rootEditPart instanceof DiagramRootEditPart) {
            //this is the most accurate way to obtain total rows and columns...
            
            DiagramRootEditPart diagramRootEditPart = (DiagramRootEditPart) rootEditPart;
            PageBreakEditPart pageBreakEditPart = diagramRootEditPart
                .getPageBreakEditPart();
            float fNumCols = ((PageBreaksFigure)pageBreakEditPart.getFigure()).getPageCount().y * 
                (applyUserScale ? userScale : 1);
            float fNumRows = ((PageBreaksFigure)pageBreakEditPart.getFigure()).getPageCount().x * 
                (applyUserScale ? userScale : 1);
            
            int numCols = (int) Math.ceil(fNumCols);
            int numRows = (int) Math.ceil(fNumRows);
            
            return new org.eclipse.draw2d.geometry.Point(numCols,numRows);
        }
        else {
            //otherwise, calculate manually...
            
            float fNumRows = (figureBounds.height * (applyUserScale ? userScale : 1))
                / pageSize.y;
            int numRows = (int) Math.ceil(fNumRows);

            float fNumCols = (figureBounds.width * (applyUserScale ? userScale : 1))
                / pageSize.x;
            int numCols = (int) Math.ceil(fNumCols);
            
            return new org.eclipse.draw2d.geometry.Point(numCols, numRows);
        }
    }

    /**
     * Prints to scale or prints to rows x columns pages
     */
    private void doPrintDiagram(DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {
        this.graphics.pushState();
        if (isScaledPercent) {
            printToScale(dgrmEP, loadedPreferences, fPreferences);
        } else {
            printToPages(dgrmEP, loadedPreferences, fPreferences);
        }
        this.graphics.popState();
    }

    private void initialize() {

        assert null != printer : "printer must be set"; //$NON-NLS-1$
        
        //check for rtl orientation...
        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();
        if ((style & SWT.MIRRORED) != 0)
            this.gc = new GC(printer, SWT.RIGHT_TO_LEFT);
        else
            this.gc = new GC(printer);

        gc.setXORMode(false);

        this.swtGraphics = new SWTGraphics(gc);
        this.printerGraphics = createPrinterGraphics(swtGraphics);
        this.graphics = createMapModeGraphics(printerGraphics);
        this.graphics.scale(computePrinterDisplayScale());
        
        this.logicalClientArea = this.graphics.getClip(new Rectangle(
            this.printer.getClientArea()));
        
    }
    
    /**
     * Usually, the printable area is less than the page.
     * This method returns the offset for each x margin and each y margin.
     * x margins are left and right
     * y margins are top and bottom
     * 
     * We'll assume the left and right offsets are the same and the
     * top and bottom offsets are the same.
     * 
     * @@return Point with x and y offsets
     */
    protected Point getPrinterOffset() {
        if (printerOffset == null) {
            int offsetX = this.printer.getBounds().width
            - this.printer.getClientArea().width;
            int offsetY = this.printer.getBounds().height
            - this.printer.getClientArea().height;
        
            // assume half on each side
            offsetX = (int) (getMapMode()
                .DPtoLP((int) (offsetX / 2.0f * display_dpi.x / printer.getDPI().x)) / userScale);
            offsetY = (int) (getMapMode()
                .DPtoLP((int) (offsetY / 2.0f * display_dpi.y / printer.getDPI().y)) / userScale);
            
            printerOffset = new Point(offsetX, offsetY);
        }
        
        return printerOffset;
    }

    /**
     * Print the diagram figure using specified scale factor.
     * 
     * @@param dgrmEP the DiagramEditPart that will be printed
     * @@param loadedPreferences true if existing prefs could be loaded
     * successfully, false if not and defaults are being used.  This parameter
     * is important to obtain the correct page break bounds.
     * @@param fPreferences the preferenceStore that could either contain
     * existing preferences or defaults
     */
    protected void printToScale(DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {

        assert null != printer : "printer must be set"; //$NON-NLS-1$
        Rectangle figureBounds = PrintHelper.getPageBreakBounds(dgrmEP, loadedPreferences);
        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper.getPageSize(fPreferences, getMapMode());

        //translate to offset initial figure position
        translated = new Point((int) (-figureBounds.x * userScale), (int) (-figureBounds.y * userScale));
        
        //calculate the number of page rows and columns
        int numRows = 0, numCols = 0;
        
        PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
        adjustMargins(margins, userScale, getPrinterOffset());

        GC gc_ = new GC(Display.getDefault(),this.gc.getStyle());
        gc_.setAntialias(this.gc.getAntialias());

        FontData fontData = JFaceResources.getDefaultFont().getFontData()[0];
        Font font = new Font(printer, fontData);
        
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageBounds, true);
        numCols = pageCount.x;
        numRows = pageCount.y;

        //finalRow and finalColumn will be used if we are printing within a page range...
        int row = 1, col = 1, finalRow = 0, finalColumn = 0;
        
        if (this.printRangePageSelection) {
            //print only the pages specified in the page range...
            row = calculateRowFromPage(this.pageFrom, numCols);
            col = calculateColumnFromPage(this.pageFrom, numCols, row);
            
            finalRow = calculateRowFromPage(this.pageTo, numCols);
            finalColumn = calculateColumnFromPage(this.pageTo, numCols, finalRow);
        }
        
        try {
            //print the pages in row, column order
            for (; row <= numRows; row++) {
                for (; col <= numCols; col++) {
                    printer.startPage();
                    drawPage(gc_, dgrmEP, fPreferences, figureBounds, margins, font, row, col);
                    printer.endPage();
                    
                    if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
                        break;
                }
                
                if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
                    break;
                
                col = 1;
            }
        } finally {
            //must dispose resources
            font.dispose();
            gc_.dispose();
        }
    }

    /**
     * Draw the header and footer
     * 
     * @@param gc_,
     *            a graphics context that is not null which this method will use
     *            for figuring ouyt the font's extent
     * @@param figureBounds,
     *            Rectangle with the bounds of the figure
     * @@param rowIndex,
     *            int
     * @@param colIndex,
     *            int
     */
    protected void drawHeaderAndFooter(GC gc_, DiagramEditPart dgrmEP, Rectangle figureBounds,
            Font font, int rowIndex, int colIndex) {

        int width = this.logicalClientArea.width;
        int height = this.logicalClientArea.height;

        this.graphics.pushState(); //draw text, don't make it too small or big
        this.graphics.setFont(font);

        this.graphics.scale(1.0f / userScale);
        this.graphics.translate(-translated.x, -translated.y);

        String headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString(
            WorkspaceViewerProperties.HEADER_PREFIX, rowIndex, colIndex,
            dgrmEP);

        this.graphics.drawText(headerOrFooter,
            getMapMode().DPtoLP(HeaderAndFooterHelper.LEFT_MARGIN_DP)
                + (width - getMapMode().DPtoLP(gc_.textExtent(headerOrFooter).x))
                / 2, getMapMode().DPtoLP(HeaderAndFooterHelper.TOP_MARGIN_DP));

        headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString(
            WorkspaceViewerProperties.FOOTER_PREFIX, rowIndex, colIndex,
            dgrmEP);

        this.graphics.drawText(headerOrFooter,
            getMapMode().DPtoLP(HeaderAndFooterHelper.LEFT_MARGIN_DP)
                + (width - getMapMode().DPtoLP(gc_.textExtent(headerOrFooter).x))
                / 2, height - getMapMode().DPtoLP(HeaderAndFooterHelper.BOTTOM_MARGIN_DP));

        this.graphics.popState(); //for drawing the text
d38 137
a174 112
    }
    
    /**
     * This method paints a portion of the diagram. (The area painted
     * representing one page.)
     * 
     * @@param gc_ a graphics context that is not null which this method will use
     * for figuring out the font's extent
     * @@param dgrmEP the DiagramEditPart that will be printed
     * @@param fPreferences the preferenceStore that could either contain
     * existing preferences or defaults
     * @@param figureBounds the page break bounds we'll have to offset by
     * @@param font the Font to print the header or footer with
     * @@param rowIndex index of row we're printing
     * @@param colIndex index of column we're priniting
     * to check if it is the first time the method is getting called for the current
     * print.
     */
    protected void drawPage(GC gc_, DiagramEditPart dgrmEP,
            IPreferenceStore fPreferences, Rectangle figureBounds,
            PageMargins margins, Font font, int rowIndex, int colIndex) {

        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
            .getPageSize(fPreferences, false, getMapMode());
        boolean rtlEnabled = ((this.gc.getStyle() & SWT.MIRRORED) != 0);
        if (rtlEnabled) 
        {
            // draw everything on an offscreen image first and then draw that image
            // onto the printer gc...this takes care of certain drawing bugs.
            // This causes issues with printing resolution as it uses a display image
            // which is typically 72dpi
            // This code should be removed when a resolution to Bugzilla 162459 is found

            Image image = new Image(Display.getDefault(), getMapMode().LPtoDP(pageSize.x), getMapMode().LPtoDP(pageSize.y));

            GC imgGC = new GC(image, (rtlEnabled) ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT);
            imgGC.setXORMode(false);
      
            SWTGraphics sg = new SWTGraphics(imgGC);
              
            //for scaling
            ScaledGraphics g1 = new ScaledGraphics(sg);
          
            //for himetrics and svg
            MapModeGraphics mmg = createMapModeGraphics(g1);
              
            //if mmg's font is null, gc.setFont will use a default font
            imgGC.setFont(mmg.getFont());
              
            internalDrawPage(dgrmEP,figureBounds,fPreferences,margins,mmg,rowIndex, colIndex,true);
            
            this.graphics.pushState();
        
            this.graphics.drawImage(image, 0, 0);
              
            this.graphics.popState();

            //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
            drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
            disposeImageVars(imgGC, image, sg, g1, mmg);
        } else {
            internalDrawPage(dgrmEP,figureBounds,fPreferences,margins,this.graphics,rowIndex, colIndex,false);
            //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
            drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
        }
    }
    
    private void internalDrawPage(DiagramEditPart dgrmEP,
            Rectangle figureBounds, IPreferenceStore fPreferences,
            PageMargins margins, Graphics g, int rowIndex, int colIndex,
            boolean RTL_ENABLED) {
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
            .getPageSize(fPreferences, false, getMapMode());

        int width = pageSize.x, height = pageSize.y;

        g.pushState();

        g.translate(translated.x, translated.y);
        g.scale(userScale);

        int translateX = -(width * (colIndex - 1));
        int translateY = -(height * (rowIndex - 1));

        int scaledTranslateX = (int) (translateX / userScale);
        int scaledTranslateY = (int) (translateY / userScale);

        int scaledWidth = (int) (width / userScale);
        int scaledHeight = (int) (height / userScale);

        if (RTL_ENABLED) {
            scaledTranslateX += (margins.left * (colIndex - 1))
                + (margins.right * (colIndex));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        } else {
            scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        }

        g.translate(scaledTranslateX, scaledTranslateY);

        Rectangle clip = new Rectangle(
            (scaledWidth - margins.left - margins.right) * (colIndex - 1)
                + figureBounds.x, (scaledHeight - margins.bottom - margins.top)
                * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right
                - margins.left, scaledHeight - margins.top - margins.bottom);
        g.clipRect(clip);

        dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(g);

        g.popState();
    }
d176 1
a176 231
    /**
     * Print the diagram figure to fit the number and rows and columns
     * specified by the user.
     * 
     * @@param dgrmEP the DiagramEditPart that will be printed
     * @@param loadedPreferences true if existing prefs could be loaded
     * successfully, false if not and defaults are being used.  This parameter
     * is important to obtain the correct page break bounds.
     * @@param fPreferences the preferenceStore that could either contain
     * existing preferences or defaults
     */
    protected void printToPages(DiagramEditPart dgrmEP,
            boolean loadedPreferences, IPreferenceStore fPreferences) {
        assert null != printer : "printer must be set"; //$NON-NLS-1$

        Rectangle figureBounds = PrintHelper.getPageBreakBounds(dgrmEP,
            loadedPreferences);
        
        PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
        //do not include margins
        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper
            .getPageSize(fPreferences, getMapMode());
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageBounds, false);
        int numCols = pageCount.x;
        int numRows = pageCount.y;
        
        float actualWidth = 0;
        float actualHeight = 0;
        if (this.rows==1 && this.columns==1 && fitToPage){
        	figureBounds = dgrmEP.getChildrenBounds();
            actualWidth = figureBounds.width;
            actualHeight = figureBounds.height;
        }else {
            actualWidth = numCols * pageBounds.x;
            actualHeight = numRows * pageBounds.y;
        }

        int totalHeight = (this.rows * pageBounds.y);
        int totalWidth  = (this.columns * pageBounds.x);

        float vScale =  totalHeight / actualHeight;
        float hScale = totalWidth / actualWidth;

        this.userScale = Math.min(hScale, vScale);

        // translate to offset figure position
        translated = new Point((int) (-figureBounds.x * userScale),
            (int) (-figureBounds.y * userScale));

        adjustMargins(margins, userScale, getPrinterOffset());

        GC gc_ = new GC(Display.getDefault());

        FontData fontData = JFaceResources.getDefaultFont().getFontData()[0];
        Font font = new Font(printer, fontData);

        int row = 1, col = 1, finalRow = 0, finalColumn = 0;
        
        if (this.printRangePageSelection) {
            //print only the pages specified in the page range
            //this corresponds to the physical pages, not the print range of pages on one physical page.
            row = calculateRowFromPage(this.pageFrom, this.columns);
            col = calculateColumnFromPage(this.pageFrom, this.columns, row);
            
            finalRow = calculateRowFromPage(this.pageTo, this.columns);
            finalColumn = calculateColumnFromPage(this.pageTo, this.columns, finalRow);
        }
        
        try {
            // print the pages in row, column order
            for (; row <= rows; row++) {
                for (; col <= columns; col++) {
                    printer.startPage();
                    drawPage(gc_, dgrmEP, fPreferences, figureBounds, margins,
                        font, row, col);
                    printer.endPage();
                    
                    if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
                        break;
                }
                
                if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
                    break;
                
                col = 1;
            }
        } finally {
            // must dispose resources
            font.dispose();
            gc_.dispose();
        }
    }

    /**
     * Return scale factor between printer and display.
     * 
     * @@return float
     */
    private float computePrinterDisplayScale() {
        assert null != printer : "printer must be set"; //$NON-NLS-1$
        assert null != display_dpi : "display_dpi must be set"; //$NON-NLS-1$

        Point dpi = printer.getDPI();
        float scale = dpi.x / (float) display_dpi.x;
        
        return scale;
    }

    /**
     * Disposes of the resources.
     */
    private void dispose() {
        if (this.graphics != null) {
            try {
                this.graphics.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                this.graphics = null;                
            }
        }
        
        if (this.printerGraphics != null) {
            try {
                this.printerGraphics.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                this.printerGraphics = null;
            }
        }
        
        if (this.swtGraphics != null) {
            try {
                this.swtGraphics.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                this.swtGraphics = null;
            }
        }
        
        if (this.gc != null) {
            try {
                this.gc.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                this.gc = null;
            }
        }
        
        //reset the printer offset, just in case the next diagram to be printed 
        //uses a different map mode.
        printerOffset = null;
        
    }
    
    private void disposeImageVars(GC imgGC, Image image, SWTGraphics sg, 
            ScaledGraphics g1, MapModeGraphics mmg) {
        
        if (mmg != null) {
            try {
                mmg.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                mmg = null;                
            }
        }
        
        if (g1 != null) {
            try {
                g1.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                g1 = null;                
            }
        }
        
        if (sg != null) {
            try {
                sg.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                sg = null;                
            }
        }
        
        if (imgGC != null) {
            try {
                imgGC.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                imgGC = null;                
            }
        }
        
        if (image != null) {
            try {
                image.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                image = null;                
            }
        }
    }

    /**
d187 125
a311 54
    /**
     * Creates the <code>PrinterGraphics</code>.
     * 
     * @@param theGraphics
     *          the <code>Graphics</code> object
     * @@return the new <code>PrinterGraphics</code>
     */
    protected PrinterGraphics createPrinterGraphics(Graphics theGraphics) {
        return new PrinterGraphics(theGraphics, printer, true);
    }
    
    /**
     * Gets the preferences hint that is to be used to find the appropriate
     * preference store from which to retrieve diagram preference values. The
     * preference hint is mapped to a preference store in the preference
     * registry <@@link DiagramPreferencesRegistry>.
     * 
     * @@return the preferences hint
     */
    protected PreferencesHint getPreferencesHint() {
        return preferencesHint;
    }
    
    /**
     * Adjust the given PageMargins by the scale and offset
     * 
     * @@param margins PageMargins to adjust
     * @@param scale margins will be scaled by this amount
     * @@param offset to adjust margins by
     */
    protected void adjustMargins(PageMargins margins, float scale, Point offset) {
        //scale
        margins.left /= scale;
        margins.top /= scale;
        margins.right /= scale;
        margins.bottom /= scale;
        
        //offsets
        margins.left -= offset.x; 
        margins.right += offset.x;
        margins.top -= offset.y;
        margins.bottom += offset.y;
        
        // this is more readable than doing Math.min for all the above
        if (margins.left < 0)
            margins.left = 0;
        if (margins.right < 0)
            margins.right = 0;
        if (margins.top < 0)
            margins.top = 0;
        if (margins.bottom < 0)
            margins.bottom = 0;
    }
}@


1.13
log
@[170493] gmf_head crevells 070313 GMF Layout service getLayoutNode() does not dispose of off-screen shells
@
text
@d17 1
d24 1
d32 1
d34 1
a42 1
import org.eclipse.jface.util.Assert;
d242 7
a248 1
                DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart((Diagram) obj, preferencesHint, shell);
d250 2
a257 1
                boolean loadedPreferences = PrintHelper.initializePreferences(dgrmEP, preferencesHint);
@


1.12
log
@[171690] gmf_head aboyko 070129 Diagrams are printed incorrectly
@
text
@d48 1
d233 30
a262 21
        while (it.hasNext()) {
            Object obj = it.next();
            //the diagrams List is only supposed to have Diagram objects
            Assert.isTrue(obj instanceof Diagram);
            DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart((Diagram) obj, preferencesHint);
            
            RootEditPart rep = dgrmEP.getRoot();
            if (rep instanceof DiagramRootEditPart) 
                this.mm = ((DiagramRootEditPart)rep).getMapMode();
            
            initialize();
            
            boolean loadedPreferences = PrintHelper.initializePreferences(dgrmEP, preferencesHint);
            
            IPreferenceStore pref = null;
            
            assert dgrmEP.getViewer() instanceof DiagramGraphicalViewer;
    
            pref = ((DiagramGraphicalViewer)dgrmEP.getViewer()).getWorkspaceViewerPreferenceStore();
            
            if (pref.getBoolean(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS)) {
d264 1
a264 3
                //get workspace settings...
                if (dgrmEP.getDiagramPreferencesHint().getPreferenceStore() != null)
                    pref = (IPreferenceStore)dgrmEP.getDiagramPreferencesHint().getPreferenceStore(); 
d266 4
a269 7
            
            doPrintDiagram(dgrmEP, loadedPreferences, pref);
            
            dispose();
        }
        printer.endJob();
        
@


1.11
log
@[134767]  gmf_head mmostafa 061123 Printing: Fit to page makes the diagram too small
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d425 1
a425 1
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize(fPreferences, false, getMapMode());
d442 1
a442 1
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageSize, true);
d602 3
a607 2
        g.pushState();

d660 3
a662 3
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
            .getPageSize(fPreferences, false, getMapMode());
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageSize, false);
d669 1
a669 3
            Rectangle rectangle = dgrmEP.getChildrenBounds();
            figureBounds.width = rectangle.x + rectangle.width + (numCols)*margins.right + numCols*margins.left ;
            figureBounds.height = rectangle.y + rectangle.height + (numRows)*margins.top + numRows*margins.bottom;
d673 2
a674 2
            actualWidth = numCols * pageSize.x;
            actualHeight = numRows * pageSize.y;
d677 2
a678 12
        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper
            .getPageSize(fPreferences, getMapMode());
        

        
        Rectangle translate = new Rectangle(Math.min(0, figureBounds.x), Math
            .min(0, figureBounds.y),
            Math.max(pageBounds.x, numCols * pageSize.x), Math.max(pageBounds.y,
                numRows * pageSize.y));
        
        int totalHeight = (this.rows * pageSize.y);
        int totalWidth  = (this.columns * pageSize.x);
d686 2
a687 2
        translated = new Point((int) (-translate.x * userScale),
            (int) (-translate.y * userScale));
d713 1
a713 1
                    drawPage(gc_, dgrmEP, fPreferences, translate, margins,
@


1.10
log
@[162459] gmf_head crevells 061123 Printing font is low-resolution and does not shrink well
Contributed by: David Cummings
@
text
@d104 10
a550 1
        
a551 3
        
        int width = pageSize.x, height = pageSize.y;
        
d576 1
a576 29
            mmg.translate(translated.x,translated.y);
            mmg.scale(userScale);
            
            mmg.pushState();
            
            int translateX = -(width * (colIndex - 1));
            int translateY = -(height * (rowIndex - 1));
        
            int scaledTranslateX = (int) (translateX / userScale);
            int scaledTranslateY = (int) (translateY / userScale);
        
            int scaledWidth = (int) (width / userScale);
            int scaledHeight = (int) (height / userScale);
            
            scaledTranslateX += (margins.left * (colIndex - 1)) + (margins.right * (colIndex));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
           
            mmg.translate(scaledTranslateX, scaledTranslateY);
            
            Rectangle clip = new Rectangle((scaledWidth - margins.left - margins.right) 
                * (colIndex - 1) + figureBounds.x, (scaledHeight - margins.bottom - margins.top) 
                * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right - margins.left, 
                scaledHeight - margins.top - margins.bottom);
            
            mmg.clipRect(clip);
            
            dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(mmg);

            mmg.popState();
a585 1
          
d588 5
a592 5
        
            this.graphics.translate(translated.x,translated.y);
            this.graphics.scale(userScale);
            
            this.graphics.pushState();
d594 21
a614 25
            int translateX = -(width * (colIndex - 1));
            int translateY = -(height * (rowIndex - 1));
        
            int scaledTranslateX = (int) (translateX / userScale);
            int scaledTranslateY = (int) (translateY / userScale);
        
            int scaledWidth = (int) (width / userScale);
            int scaledHeight = (int) (height / userScale);
            
            if (rtlEnabled) {
                scaledTranslateX += (margins.left * (colIndex - 1)) + (margins.right * (colIndex));
                scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
            }
            else {
                scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
                scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
            }
                
            this.graphics.translate(scaledTranslateX, scaledTranslateY);
            
            Rectangle clip = new Rectangle((scaledWidth - margins.left - margins.right) 
                * (colIndex - 1) + figureBounds.x, (scaledHeight - margins.bottom - margins.top) 
                * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right - margins.left, 
                scaledHeight - margins.top - margins.bottom);
            this.graphics.clipRect(clip);
d616 7
a622 6
            dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(this.graphics);
    
            this.graphics.popState();
            
            //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
            drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
d624 13
a655 3

        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper
            .getPageSize(fPreferences, getMapMode());
d657 1
a660 1
         
d665 18
d691 2
a692 2
        float vScale = ((float) totalHeight) / ((float)(numRows * pageSize.y));
        float hScale = ((float) totalWidth) / ((float)(numCols * pageSize.x));
a699 1
        PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
@


1.9
log
@[161131] gmf_head ahunter 061017 Merge 1.0.2 fix to HEAD
@
text
@a24 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.IDiagramPreferenceSupport;
d546 31
a576 2
        //draw everything on an offscreen image first and then draw that image
        //onto the printer gc...this takes care of certain drawing bugs.
d578 2
a579 1
        Image image = new Image(Display.getDefault(), getMapMode().LPtoDP(pageSize.x), getMapMode().LPtoDP(pageSize.y));
d581 3
a583 29
        GC imgGC = new GC(image, (rtlEnabled) ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT);
        imgGC.setXORMode(false);

        SWTGraphics sg = new SWTGraphics(imgGC);
        
        //for scaling
        ScaledGraphics g1 = new ScaledGraphics(sg);
    
        //for himetrics and svg
        MapModeGraphics mmg = createMapModeGraphics(g1);
        
        //if mmg's font is null, gc.setFont will use a default font
        imgGC.setFont(mmg.getFont());
        
        mmg.translate(translated.x,translated.y);
        mmg.scale(userScale);
        
        mmg.pushState();
        
        int translateX = -(width * (colIndex - 1));
        int translateY = -(height * (rowIndex - 1));
    
        int scaledTranslateX = (int) (translateX / userScale);
        int scaledTranslateY = (int) (translateY / userScale);
    
        int scaledWidth = (int) (width / userScale);
        int scaledHeight = (int) (height / userScale);
        
        if (rtlEnabled) {
d586 13
a598 5
        }
        else {
            scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        }
d600 1
a600 1
        mmg.translate(scaledTranslateX, scaledTranslateY);
d602 9
a610 5
        Rectangle clip = new Rectangle((scaledWidth - margins.left - margins.right) 
            * (colIndex - 1) + figureBounds.x, (scaledHeight - margins.bottom - margins.top) 
            * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right - margins.left, 
            scaledHeight - margins.top - margins.bottom);
        mmg.clipRect(clip);
d612 7
a618 1
        dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(mmg);
d620 2
a621 1
        mmg.popState();
d623 19
a641 1
        this.graphics.pushState();
d643 7
a649 8
        this.graphics.drawImage(image, 0, 0);
        
        this.graphics.popState();
        
        //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
        drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
        
        disposeImageVars(imgGC, image, sg, g1, mmg);
@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d227 1
a227 1
            DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart((Diagram) obj, null);
a231 2
            if (rep instanceof IDiagramPreferenceSupport)
                this.preferencesHint = ((IDiagramPreferenceSupport)rep).getPreferencesHint();
@


1.7
log
@bugzilla 130969 gmf-head sshaw 060308 DiagramPrinter not disposing Graphics classes.
@
text
@d2 1
a2 1
 * Copyright (c) 2002 - 2005 IBM Corporation and others.
d21 1
d24 4
d34 1
d41 1
d45 1
d49 1
d55 1
a55 1
	implements Runnable {
d57 1
a57 1
	protected Printer printer;
d59 1
a59 1
	private Point display_dpi;
d61 1
a61 1
	private boolean isScaledPercent = false;
d63 1
a63 1
	private int rows = 1;
d65 5
a69 3
	private int columns = 1;

	private GC gc;
d71 2
d75 1
a75 1
	private Graphics graphics;
d78 4
a81 2
	
	protected Point printerOffset;
d83 1
a83 1
	protected Rectangle logicalClientArea;
d85 5
a89 1
	private float userScale;
d91 14
a104 163
	/**
	 * Used when a Collection of Diagram objects are passed in instead of an
	 * IEditorPart.
	 */
	protected Collection diagrams;

	/**
	 * The initial amount that the diagram should be translated, set by
	 * printToScale or printToPages which calls drawToFitRowsColumns.
	 */
	private Point translated = null;
	
	/**
	 * The hint used to find the appropriate preference store from which general
	 * diagramming preference values for properties of shapes, connections, and
	 * diagrams can be retrieved. This hint is mapped to a preference store in
	 * the {@@link DiagramPreferencesRegistry}.
	 */
	private PreferencesHint preferencesHint;
	private IMapMode mm;

	/**
	 * Creates a new instance. The following variables must be initialized
	 * before calling <code>run()</code>:
	 * <li><code>printer</code></li>
	 * <li><code>display_dpi</code></li>
	 * <li><code>diagrams</code></li>
	 * @@param mm <code>IMapMode</code> to do the coordinate mapping
	 */
	public DiagramPrinter(PreferencesHint preferencesHint, IMapMode mm) {
		super();
		this.preferencesHint = preferencesHint;
		this.mm = mm;
	}
	
	/**
	 * Creates a new instance. The following variables must be initialized
	 * before calling <code>run()</code>:
	 * <li><code>printer</code></li>
	 * <li><code>display_dpi</code></li>
	 * <li><code>diagrams</code></li>
	 * @@param mm <code>IMapMode</code> to do the coordinate mapping
	 */
	public DiagramPrinter(PreferencesHint preferencesHint) {
		this(preferencesHint, MapModeUtil.getMapMode());
	}
	
	/**
	 * @@return <code>IMapMode</code> to do the coordinate mapping
	 */
	protected IMapMode getMapMode() {
		return mm;
	}
	
	/**
	 * Sets the columns.
	 * 
	 * @@param columns
	 *            The columns to set.
	 */
	public void setColumns(int columns) {
		this.columns = columns;
	}

	/**
	 * Sets the diagrams.
	 * 
	 * @@param diagrams
	 *            a Collection of Diagram objects
	 */
	public void setDiagrams(Collection diagrams) {
		this.diagrams = diagrams;
	}

	/**
	 * Sets the display DPI.
	 * 
	 * @@param display_dpi
	 *            The display_dpi to set.
	 */
	public void setDisplayDPI(Point display_dpi) {
		this.display_dpi = new Point(display_dpi.x, display_dpi.y);
	}

	/**
	 * Sets the printer.
	 * 
	 * @@param printer
	 *            The printer to set.
	 */
	public void setPrinter(Printer printer) {
		this.printer = printer;
	}

	/**
	 * Sets the rows.
	 * 
	 * @@param rows
	 *            The rows to set.
	 */
	public void setRows(int rows) {
		this.rows = rows;
	}

	/**
	 * Sets the scaled percent.
	 * 
	 * @@param scalePercent
	 */
	public void setScaledPercent(int scalePercent) {
		this.isScaledPercent = true;
		this.userScale = (scalePercent) / 100.0f;

	}

	/**
	 * Prints the contents of the diagram editor part.
	 */
	public void run() {
		assert null != printer : "printer must be set"; //$NON-NLS-1$
		if (!(printer.startJob("Printing"))) { //$NON-NLS-1$
			return;
		}

		initialize();

		assert diagrams != null;
		Iterator it = diagrams.iterator();

		while (it.hasNext()) {
			Object obj = it.next();
			//the diagrams List is only supposed to have Diagram objects
			Assert.isTrue(obj instanceof Diagram);
			DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart((Diagram) obj, preferencesHint);
			boolean loadedPreferences = PrintHelper.initializePreferences(dgrmEP, preferencesHint);
			assert dgrmEP.getViewer() instanceof DiagramGraphicalViewer;
			IPreferenceStore fPreferences = ((DiagramGraphicalViewer)dgrmEP.getViewer()).getWorkspaceViewerPreferenceStore();
			doPrintDiagram(dgrmEP, loadedPreferences, fPreferences);
		}

		printer.endJob();
		dispose();
	}

	/**
	 * Prints to scale or prints to rows x columns pages
	 */
	private void doPrintDiagram(DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {
		this.graphics.pushState();
		if (isScaledPercent) {
			printToScale(dgrmEP, loadedPreferences, fPreferences);
		} else {
			printToPages(dgrmEP, loadedPreferences, fPreferences);
		}
		this.graphics.popState();
	}

	private void initialize() {

		assert null != printer : "printer must be set"; //$NON-NLS-1$
		
		this.gc = new GC(printer);
		gc.setXORMode(false);
d106 259
a364 1
		this.swtGraphics = new SWTGraphics(gc);
d366 487
a852 320
		this.graphics = createMapModeGraphics(printerGraphics);
		this.graphics.scale(computePrinterDisplayScale());
		
		this.logicalClientArea = this.graphics.getClip(new Rectangle(
			this.printer.getClientArea()));
		
	}

	/**
	 * Usually, the printable area is less than the page.
	 * This method returns the offset for each x margin and each y margin.
	 * x margins are left and right
	 * y margins are top and bottom
	 * 
	 * We'll assume the left and right offsets are the same and the
	 * top and bottom offsets are the same.
	 * 
	 * @@return Point with x and y offsets
	 */
	protected Point getPrinterOffset() {
		if (printerOffset == null) {
			int offsetX = this.printer.getBounds().width
			- this.printer.getClientArea().width;
			int offsetY = this.printer.getBounds().height
			- this.printer.getClientArea().height;
		
			// assume half on each side
			offsetX = (int) (getMapMode()
				.DPtoLP((int) (offsetX / 2.0f * display_dpi.x / printer.getDPI().x)) / userScale);
			offsetY = (int) (getMapMode()
				.DPtoLP((int) (offsetY / 2.0f * display_dpi.y / printer.getDPI().y)) / userScale);
			
			printerOffset = new Point(offsetX, offsetY);
		}
		
		return printerOffset;
	}

	/**
	 * Print the diagram figure using specified scale factor.
	 * 
	 * @@param dgrmEP the DiagramEditPart that will be printed
	 * @@param loadedPreferences true if existing prefs could be loaded
	 * successfully, false if not and defaults are being used.  This parameter
	 * is important to obtain the correct page break bounds.
	 * @@param fPreferences the preferenceStore that could either contain
	 * existing preferences or defaults
	 */
	protected void printToScale(DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {

		assert null != printer : "printer must be set"; //$NON-NLS-1$
		Rectangle figureBounds = PrintHelper.getPageBreakBounds(dgrmEP, loadedPreferences);

		//translate to offset initial figure position
		translated = new Point(-figureBounds.x, -figureBounds.y);
		this.graphics.translate(translated.x, translated.y);

		this.graphics.scale(userScale);

		//calculate the number of page rows and columns
		
		org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize(fPreferences, false, getMapMode());
		
		float fNumRows = (figureBounds.height * userScale)
			/ pageSize.y;
		int numRows = (int) Math.ceil(fNumRows);

		float fNumCols = (figureBounds.width * userScale)
			/ pageSize.x;
		int numCols = (int) Math.ceil(fNumCols);
		
		PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
		adjustMargins(margins, userScale, getPrinterOffset());

		GC gc_ = new GC(Display.getDefault());

		FontData fontData = JFaceResources.getDefaultFont().getFontData()[0];
		Font font = new Font(printer, fontData);

		try {
			//print the pages in row, column order
			for (int row = 1; row <= numRows; row++) {
				for (int col = 1; col <= numCols; col++) {
					printer.startPage();
					drawPage(gc_, dgrmEP, fPreferences, figureBounds, margins, font, row, col);
					printer.endPage();
				}
			}
		} finally {
			//must dispose resources
			font.dispose();
			gc_.dispose();
		}
	}

	/**
	 * Draw the header and footer
	 * 
	 * @@param gc_,
	 *            a graphics context that is not null which this method will use
	 *            for figuring ouyt the font's extent
	 * @@param figureBounds,
	 *            Rectangle with the bounds of the figure
	 * @@param rowIndex,
	 *            int
	 * @@param colIndex,
	 *            int
	 */
	protected void drawHeaderAndFooter(GC gc_, DiagramEditPart dgrmEP, Rectangle figureBounds,
			Font font, int rowIndex, int colIndex) {

		int width = this.logicalClientArea.width;
		int height = this.logicalClientArea.height;

		this.graphics.pushState(); //draw text, don't make it too small or big
		this.graphics.setFont(font);

		this.graphics.scale(1.0f / userScale);
		this.graphics.translate(-translated.x, -translated.y);

		String headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString(
			WorkspaceViewerProperties.HEADER_PREFIX, rowIndex, colIndex,
			dgrmEP);

		this.graphics.drawText(headerOrFooter,
			getMapMode().DPtoLP(HeaderAndFooterHelper.LEFT_MARGIN_DP)
				+ (width - getMapMode().DPtoLP(gc_.textExtent(headerOrFooter).x))
				/ 2, getMapMode().DPtoLP(HeaderAndFooterHelper.TOP_MARGIN_DP));

		headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString(
			WorkspaceViewerProperties.FOOTER_PREFIX, rowIndex, colIndex,
			dgrmEP);

		this.graphics.drawText(headerOrFooter,
			getMapMode().DPtoLP(HeaderAndFooterHelper.LEFT_MARGIN_DP)
				+ (width - getMapMode().DPtoLP(gc_.textExtent(headerOrFooter).x))
				/ 2, height - getMapMode().DPtoLP(HeaderAndFooterHelper.BOTTOM_MARGIN_DP));

		this.graphics.popState(); //for drawing the text

	}

	/**
	 * This method paints a portion of the diagram. (The area painted
	 * representing one page.)
	 * 
	 * @@param gc_ a graphics context that is not null which this method will use
	 * for figuring ouyt the font's extent
	 * @@param dgrmEP the DiagramEditPart that will be printed
	 * @@param fPreferences the preferenceStore that could either contain
	 * existing preferences or defaults
	 * @@param figureBounds the page break bounds we'll have to offset by
	 * @@param font the Font to print the header or footer with
	 * @@param rowIndex index of row we're printing
	 * @@param colIndex index of column we're priniting
	 */
	protected void drawPage(GC gc_, DiagramEditPart dgrmEP,
			IPreferenceStore fPreferences, Rectangle figureBounds,
			PageMargins margins, Font font, int rowIndex, int colIndex) {

		org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
			.getPageSize(fPreferences, false, getMapMode());
		int width = pageSize.x, height = pageSize.y;

		int translateX = -(width * (colIndex - 1));
		int translateY = -(height * (rowIndex - 1));

		int scaledTranslateX = (int) (translateX / userScale);
		int scaledTranslateY = (int) (translateY / userScale);

		int scaledWidth = (int) (width / userScale);
		int scaledHeight = (int) (height / userScale);

		scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
		scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));

		drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);

		this.graphics.pushState();

		this.graphics.translate(scaledTranslateX, scaledTranslateY);

		Rectangle r = new Rectangle((scaledWidth - margins.left - margins.right)
			* (colIndex - 1) + figureBounds.x, (scaledHeight - margins.top - margins.bottom)
			* (rowIndex - 1) + figureBounds.y, scaledWidth - margins.left - margins.right,
			scaledHeight - margins.top - margins.bottom);
		this.graphics.clipRect(r);

		dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(this.graphics);

		this.graphics.popState();
	}

	/**
	 * Print the diagram figure to fit the number and rows and columns
	 * specified by the user.
	 * 
	 * @@param dgrmEP the DiagramEditPart that will be printed
	 * @@param loadedPreferences true if existing prefs could be loaded
	 * successfully, false if not and defaults are being used.  This parameter
	 * is important to obtain the correct page break bounds.
	 * @@param fPreferences the preferenceStore that could either contain
	 * existing preferences or defaults
	 */
	protected void printToPages(DiagramEditPart dgrmEP,
			boolean loadedPreferences, IPreferenceStore fPreferences) {
		assert null != printer : "printer must be set"; //$NON-NLS-1$

		Rectangle figureBounds = PrintHelper.getPageBreakBounds(dgrmEP,
			loadedPreferences);

		org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper
			.getPageSize(fPreferences, getMapMode());

		Rectangle translate = new Rectangle(Math.min(0, figureBounds.x), Math
			.min(0, figureBounds.y),
			Math.max(pageBounds.x, figureBounds.width), Math.max(pageBounds.y,
				figureBounds.height));

		// do not include margins
		org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
			.getPageSize(fPreferences, true, getMapMode());

		// there's usually a difference between the total page area and the
		// actual printable area
		int offsetX = this.printer.getBounds().width
			- this.printer.getClientArea().width;
		int offsetY = this.printer.getBounds().height
			- this.printer.getClientArea().height;

		pageSize.x -= offsetX * columns;
		pageSize.y -= offsetY * rows;

		float vScale = ((float) (this.rows * pageSize.y)) / translate.height;
		float hScale = ((float) (this.columns * pageSize.x)) / translate.width;

		this.userScale = Math.min(hScale, vScale);

		// translate to offset figure position
		translated = new Point((int) (-translate.x * userScale),
			(int) (-translate.y * userScale));
		this.graphics.translate(translated.x, translated.y);

		this.graphics.scale(this.userScale);

		PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
		adjustMargins(margins, userScale, getPrinterOffset());

		GC gc_ = new GC(Display.getDefault());

		FontData fontData = JFaceResources.getDefaultFont().getFontData()[0];
		Font font = new Font(printer, fontData);

		try {
			// print the pages in row, column order
			for (int row = 1; row <= rows; row++) {
				for (int col = 1; col <= columns; col++) {
					printer.startPage();
					drawPage(gc_, dgrmEP, fPreferences, translate, margins,
						font, row, col);
					printer.endPage();
				}
			}
		} finally {
			// must dispose resources
			font.dispose();
			gc_.dispose();
		}
	}

	/**
	 * Return scale factor between printer and display.
	 * 
	 * @@return float
	 */
	private float computePrinterDisplayScale() {
		assert null != printer : "printer must be set"; //$NON-NLS-1$
		assert null != display_dpi : "display_dpi must be set"; //$NON-NLS-1$

		Point dpi = printer.getDPI();
		float scale = dpi.x / (float) display_dpi.x;
		
		return scale;
	}

	/**
	 * Disposes of the resources.
	 */
	private void dispose() {
	    if (graphics != null) {
	        graphics.dispose();
            graphics = null;
        }
        
        if (printerGraphics != null) {
            printerGraphics.dispose();
            printerGraphics = null;
        }
        
        if (swtGraphics != null) {
            swtGraphics.dispose();
            swtGraphics = null;
        }
        
		if (this.gc != null) {
			this.gc.dispose();
			this.gc = null;
		}
	}

	/**
	 * Creates the <code>MapModeGraphics</code>.
	 * 
	 * @@param theGraphics
	 *            the <code>PrinterGraphics</code> object
	 * @@return the new <code>MapModeGraphics</code>
	 */
	protected MapModeGraphics createMapModeGraphics(Graphics theGraphics) {
		return new MapModeGraphics(theGraphics, getMapMode());
	}
d864 43
a906 44
	
	/**
	 * Gets the preferences hint that is to be used to find the appropriate
	 * preference store from which to retrieve diagram preference values. The
	 * preference hint is mapped to a preference store in the preference
	 * registry <@@link DiagramPreferencesRegistry>.
	 * 
	 * @@return the preferences hint
	 */
	protected PreferencesHint getPreferencesHint() {
		return preferencesHint;
	}
	
	/**
	 * Adjust the given PageMargins by the scale and offset
	 * 
	 * @@param margins PageMargins to adjust
	 * @@param scale margins will be scaled by this amount
	 * @@param offset to adjust margins by
	 */
	protected void adjustMargins(PageMargins margins, float scale, Point offset) {
		//scale
		margins.left /= scale;
		margins.top /= scale;
		margins.right /= scale;
		margins.bottom /= scale;
		
		//offsets
		margins.left -= offset.x; 
		margins.right += offset.x;
		margins.top -= offset.y;
		margins.bottom += offset.y;
		
		// this is more readable than doing Math.min for all the above
		if (margins.left < 0)
			margins.left = 0;
		if (margins.right < 0)
			margins.right = 0;
		if (margins.top < 0)
			margins.top = 0;
		if (margins.bottom < 0)
			margins.bottom = 0;
	}

@


1.7.2.1
log
@Bugzilla#144771 gmf_R1_0_maintenance cmahoney 060717 Different diagrams do not appear in "Select Diagrams" list
Contributed by: Syed Atif Ali
@
text
@a20 1
import org.eclipse.gef.RootEditPart;
a22 4
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IDiagramPreferenceSupport;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.PageBreakEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.PageBreaksFigure;
a28 1
import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;
a34 1
import org.eclipse.swt.SWT;
a37 1
import org.eclipse.swt.graphics.Image;
a40 1
import org.eclipse.ui.PlatformUI;
d46 1
a46 1
    implements Runnable {
d48 1
a48 1
    protected Printer printer;
d50 1
a50 1
    private Point display_dpi;
d52 1
a52 1
    private boolean isScaledPercent = false;
d54 1
a54 1
    private int rows = 1;
d56 3
a58 5
    private int columns = 1;
    
    private boolean printRangePageSelection = false;
    
    private int pageFrom = 1, pageTo = 1;
a59 2
    private GC gc;
    
d62 1
a62 1
    private Graphics graphics;
d65 2
a66 4
    
    protected Point printerOffset;

    protected Rectangle logicalClientArea;
d68 1
a68 1
    private float userScale;
d70 1
a70 5
    /**
     * Used when a Collection of Diagram objects are passed in instead of an
     * IEditorPart.
     */
    protected Collection diagrams;
d72 163
a234 14
    /**
     * The initial amount that the diagram should be translated, set by
     * printToScale or printToPages which calls drawToFitRowsColumns.
     */
    private Point translated = null;
    
    /**
     * The hint used to find the appropriate preference store from which general
     * diagramming preference values for properties of shapes, connections, and
     * diagrams can be retrieved. This hint is mapped to a preference store in
     * the {@@link DiagramPreferencesRegistry}.
     */
    private PreferencesHint preferencesHint;
    private IMapMode mm;
d236 1
a236 259
    /**
     * Creates a new instance. The following variables must be initialized
     * before calling <code>run()</code>:
     * <li><code>printer</code></li>
     * <li><code>display_dpi</code></li>
     * <li><code>diagrams</code></li>
     * @@param mm <code>IMapMode</code> to do the coordinate mapping
     */
    public DiagramPrinter(PreferencesHint preferencesHint, IMapMode mm) {
        super();
        this.preferencesHint = preferencesHint;
        this.mm = mm;
    }
    
    /**
     * Creates a new instance. The following variables must be initialized
     * before calling <code>run()</code>:
     * <li><code>printer</code></li>
     * <li><code>display_dpi</code></li>
     * <li><code>diagrams</code></li>
     * @@param mm <code>IMapMode</code> to do the coordinate mapping
     */
    public DiagramPrinter(PreferencesHint preferencesHint) {
        this(preferencesHint, MapModeUtil.getMapMode());
    }
    
    /**
     * @@return <code>IMapMode</code> to do the coordinate mapping
     */
    protected IMapMode getMapMode() {
        return mm;
    }
    
    /**
     * Sets the columns.
     * 
     * @@param columns
     *            The columns to set.
     */
    public void setColumns(int columns) {
        this.columns = columns;
    }

    /**
     * Sets the diagrams.
     * 
     * @@param diagrams
     *            a Collection of Diagram objects
     */
    public void setDiagrams(Collection diagrams) {
        this.diagrams = diagrams;
    }

    /**
     * Sets the display DPI.
     * 
     * @@param display_dpi
     *            The display_dpi to set.
     */
    public void setDisplayDPI(Point display_dpi) {
        this.display_dpi = new Point(display_dpi.x, display_dpi.y);
    }

    /**
     * Sets the printer.
     * 
     * @@param printer
     *            The printer to set.
     */
    public void setPrinter(Printer printer) {
        this.printer = printer;
    }
    
    public void setPrintRangePageSelection(boolean isPrintRangePageSelected) {
        this.printRangePageSelection = isPrintRangePageSelected;
    }
    
    public void setPrintRangePages(int pageFrom, int pageTo) {
        assert pageFrom > 0 : "From page in print range page selection must be bigger than zero."; //$NON-NLS-1$
        assert (pageTo > 0 && pageTo >= pageFrom) : "To page in print range page selection must be bigger than zero and from page.";  //$NON-NLS-1$
        this.pageFrom = pageFrom;
        this.pageTo = pageTo;
    }

    /**
     * Sets the rows.
     * 
     * @@param rows
     *            The rows to set.
     */
    public void setRows(int rows) {
        this.rows = rows;
    }

    /**
     * Sets the scaled percent.
     * 
     * @@param scalePercent
     */
    public void setScaledPercent(int scalePercent) {
        this.isScaledPercent = true;
        this.userScale = (scalePercent) / 100.0f;

    }

    /**
     * Prints the contents of the diagram editor part.
     */
    public void run() {
        assert null != printer : "printer must be set"; //$NON-NLS-1$
        if (!(printer.startJob("Printing"))) { //$NON-NLS-1$
          return;
        }
        
        assert diagrams != null;
        Iterator it = diagrams.iterator();

        while (it.hasNext()) {
            Object obj = it.next();
            //the diagrams List is only supposed to have Diagram objects
            Assert.isTrue(obj instanceof Diagram);
            DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart((Diagram) obj, null);
            
            RootEditPart rep = dgrmEP.getRoot();
            if (rep instanceof DiagramRootEditPart) 
                this.mm = ((DiagramRootEditPart)rep).getMapMode();
            if (rep instanceof IDiagramPreferenceSupport)
                this.preferencesHint = ((IDiagramPreferenceSupport)rep).getPreferencesHint();
            
            initialize();
            
            boolean loadedPreferences = PrintHelper.initializePreferences(dgrmEP, preferencesHint);
            
            IPreferenceStore pref = null;
            
            assert dgrmEP.getViewer() instanceof DiagramGraphicalViewer;
    
            pref = ((DiagramGraphicalViewer)dgrmEP.getViewer()).getWorkspaceViewerPreferenceStore();
            
            if (pref.getBoolean(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS)) {
                
                //get workspace settings...
                if (dgrmEP.getDiagramPreferencesHint().getPreferenceStore() != null)
                    pref = (IPreferenceStore)dgrmEP.getDiagramPreferencesHint().getPreferenceStore(); 
            }
            
            doPrintDiagram(dgrmEP, loadedPreferences, pref);
            
            dispose();
        }
        printer.endJob();
        
    }
    
    /**
     * Calculates the row in a grid, given a page number.
     * | 1 | 2 | 3 |
     * | 4 | 5 | 6 |
     * | 7 | 8 | 9 |
     * 
     * Given pageNum=5 and totalNumColumns=3, will return 2
     * (2nd row).
     * 
     * @@param pageNum the page number in the grid.
     * @@param totalNumColumns total number of columns of the grid.
     * @@return row number corresponding to the page number.
     */
    private int calculateRowFromPage(int pageNum, int totalNumColumns) {
        int row = pageNum / totalNumColumns;
        if (pageNum % totalNumColumns != 0)
            row++;
        return row;
    }
    
    /**
     * Calculates the column in a grid, given a page number.
     * | 1 | 2 | 3 |
     * | 4 | 5 | 6 |
     * | 7 | 8 | 9 |
     * 
     * Given pageNum=5 and totalNumColumns=3, will return 2
     * (2nd column).
     *  
     * @@param pageNum the page number in the grid.
     * @@param totalNumColumns total number of columns of the grid.
     * @@param cRow the corresponding row of the page number.
     * @@return row number corresponding to the page number.
     */
    private int calculateColumnFromPage(int pageNum, int totalNumColumns, int cRow) {
        int col = pageNum - ((cRow - 1) * totalNumColumns);
        return col;
    }
    
    /**
     * Obtains the total number of pages that span columns and rows
     * @@param dgrmEP
     * @@return Point.x contains the total number of pages that span in a column
     *         Point.y contains the total number of pages that span in a row
     */
    private org.eclipse.draw2d.geometry.Point getPageCount(DiagramEditPart dgrmEP, Rectangle figureBounds, org.eclipse.draw2d.geometry.Point pageSize, boolean applyUserScale) {
        RootEditPart rootEditPart = dgrmEP.getRoot();
        if (rootEditPart instanceof DiagramRootEditPart) {
            //this is the most accurate way to obtain total rows and columns...
            
            DiagramRootEditPart diagramRootEditPart = (DiagramRootEditPart) rootEditPart;
            PageBreakEditPart pageBreakEditPart = diagramRootEditPart
                .getPageBreakEditPart();
            float fNumCols = ((PageBreaksFigure)pageBreakEditPart.getFigure()).getPageCount().y * 
                (applyUserScale ? userScale : 1);
            float fNumRows = ((PageBreaksFigure)pageBreakEditPart.getFigure()).getPageCount().x * 
                (applyUserScale ? userScale : 1);
            
            int numCols = (int) Math.ceil(fNumCols);
            int numRows = (int) Math.ceil(fNumRows);
            
            return new org.eclipse.draw2d.geometry.Point(numCols,numRows);
        }
        else {
            //otherwise, calculate manually...
            
            float fNumRows = (figureBounds.height * (applyUserScale ? userScale : 1))
                / pageSize.y;
            int numRows = (int) Math.ceil(fNumRows);

            float fNumCols = (figureBounds.width * (applyUserScale ? userScale : 1))
                / pageSize.x;
            int numCols = (int) Math.ceil(fNumCols);
            
            return new org.eclipse.draw2d.geometry.Point(numCols, numRows);
        }
    }

    /**
     * Prints to scale or prints to rows x columns pages
     */
    private void doPrintDiagram(DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {
        this.graphics.pushState();
        if (isScaledPercent) {
            printToScale(dgrmEP, loadedPreferences, fPreferences);
        } else {
            printToPages(dgrmEP, loadedPreferences, fPreferences);
        }
        this.graphics.popState();
    }

    private void initialize() {

        assert null != printer : "printer must be set"; //$NON-NLS-1$
        
        //check for rtl orientation...
        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();
        if ((style & SWT.MIRRORED) != 0)
            this.gc = new GC(printer, SWT.RIGHT_TO_LEFT);
        else
            this.gc = new GC(printer);

        gc.setXORMode(false);

        this.swtGraphics = new SWTGraphics(gc);
d238 320
a557 487
        this.graphics = createMapModeGraphics(printerGraphics);
        this.graphics.scale(computePrinterDisplayScale());
        
        this.logicalClientArea = this.graphics.getClip(new Rectangle(
            this.printer.getClientArea()));
        
    }
    
    /**
     * Usually, the printable area is less than the page.
     * This method returns the offset for each x margin and each y margin.
     * x margins are left and right
     * y margins are top and bottom
     * 
     * We'll assume the left and right offsets are the same and the
     * top and bottom offsets are the same.
     * 
     * @@return Point with x and y offsets
     */
    protected Point getPrinterOffset() {
        if (printerOffset == null) {
            int offsetX = this.printer.getBounds().width
            - this.printer.getClientArea().width;
            int offsetY = this.printer.getBounds().height
            - this.printer.getClientArea().height;
        
            // assume half on each side
            offsetX = (int) (getMapMode()
                .DPtoLP((int) (offsetX / 2.0f * display_dpi.x / printer.getDPI().x)) / userScale);
            offsetY = (int) (getMapMode()
                .DPtoLP((int) (offsetY / 2.0f * display_dpi.y / printer.getDPI().y)) / userScale);
            
            printerOffset = new Point(offsetX, offsetY);
        }
        
        return printerOffset;
    }

    /**
     * Print the diagram figure using specified scale factor.
     * 
     * @@param dgrmEP the DiagramEditPart that will be printed
     * @@param loadedPreferences true if existing prefs could be loaded
     * successfully, false if not and defaults are being used.  This parameter
     * is important to obtain the correct page break bounds.
     * @@param fPreferences the preferenceStore that could either contain
     * existing preferences or defaults
     */
    protected void printToScale(DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {

        assert null != printer : "printer must be set"; //$NON-NLS-1$
        Rectangle figureBounds = PrintHelper.getPageBreakBounds(dgrmEP, loadedPreferences);
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize(fPreferences, false, getMapMode());

        //translate to offset initial figure position
        translated = new Point((int) (-figureBounds.x * userScale), (int) (-figureBounds.y * userScale));
        
        //calculate the number of page rows and columns
        int numRows = 0, numCols = 0;
        
        PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
        adjustMargins(margins, userScale, getPrinterOffset());

        GC gc_ = new GC(Display.getDefault(),this.gc.getStyle());
        gc_.setAntialias(this.gc.getAntialias());

        FontData fontData = JFaceResources.getDefaultFont().getFontData()[0];
        Font font = new Font(printer, fontData);
        
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageSize, true);
        numCols = pageCount.x;
        numRows = pageCount.y;

        //finalRow and finalColumn will be used if we are printing within a page range...
        int row = 1, col = 1, finalRow = 0, finalColumn = 0;
        
        if (this.printRangePageSelection) {
            //print only the pages specified in the page range...
            row = calculateRowFromPage(this.pageFrom, numCols);
            col = calculateColumnFromPage(this.pageFrom, numCols, row);
            
            finalRow = calculateRowFromPage(this.pageTo, numCols);
            finalColumn = calculateColumnFromPage(this.pageTo, numCols, finalRow);
        }
        
        try {
            //print the pages in row, column order
            for (; row <= numRows; row++) {
                for (; col <= numCols; col++) {
                    printer.startPage();
                    drawPage(gc_, dgrmEP, fPreferences, figureBounds, margins, font, row, col);
                    printer.endPage();
                    
                    if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
                        break;
                }
                
                if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
                    break;
                
                col = 1;
            }
        } finally {
            //must dispose resources
            font.dispose();
            gc_.dispose();
        }
    }

    /**
     * Draw the header and footer
     * 
     * @@param gc_,
     *            a graphics context that is not null which this method will use
     *            for figuring ouyt the font's extent
     * @@param figureBounds,
     *            Rectangle with the bounds of the figure
     * @@param rowIndex,
     *            int
     * @@param colIndex,
     *            int
     */
    protected void drawHeaderAndFooter(GC gc_, DiagramEditPart dgrmEP, Rectangle figureBounds,
            Font font, int rowIndex, int colIndex) {

        int width = this.logicalClientArea.width;
        int height = this.logicalClientArea.height;

        this.graphics.pushState(); //draw text, don't make it too small or big
        this.graphics.setFont(font);

        this.graphics.scale(1.0f / userScale);
        this.graphics.translate(-translated.x, -translated.y);

        String headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString(
            WorkspaceViewerProperties.HEADER_PREFIX, rowIndex, colIndex,
            dgrmEP);

        this.graphics.drawText(headerOrFooter,
            getMapMode().DPtoLP(HeaderAndFooterHelper.LEFT_MARGIN_DP)
                + (width - getMapMode().DPtoLP(gc_.textExtent(headerOrFooter).x))
                / 2, getMapMode().DPtoLP(HeaderAndFooterHelper.TOP_MARGIN_DP));

        headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString(
            WorkspaceViewerProperties.FOOTER_PREFIX, rowIndex, colIndex,
            dgrmEP);

        this.graphics.drawText(headerOrFooter,
            getMapMode().DPtoLP(HeaderAndFooterHelper.LEFT_MARGIN_DP)
                + (width - getMapMode().DPtoLP(gc_.textExtent(headerOrFooter).x))
                / 2, height - getMapMode().DPtoLP(HeaderAndFooterHelper.BOTTOM_MARGIN_DP));

        this.graphics.popState(); //for drawing the text

    }
    
    /**
     * This method paints a portion of the diagram. (The area painted
     * representing one page.)
     * 
     * @@param gc_ a graphics context that is not null which this method will use
     * for figuring out the font's extent
     * @@param dgrmEP the DiagramEditPart that will be printed
     * @@param fPreferences the preferenceStore that could either contain
     * existing preferences or defaults
     * @@param figureBounds the page break bounds we'll have to offset by
     * @@param font the Font to print the header or footer with
     * @@param rowIndex index of row we're printing
     * @@param colIndex index of column we're priniting
     * to check if it is the first time the method is getting called for the current
     * print.
     */
    protected void drawPage(GC gc_, DiagramEditPart dgrmEP,
            IPreferenceStore fPreferences, Rectangle figureBounds,
            PageMargins margins, Font font, int rowIndex, int colIndex) {

        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
            .getPageSize(fPreferences, false, getMapMode());
        
        boolean rtlEnabled = ((this.gc.getStyle() & SWT.MIRRORED) != 0);
        
        int width = pageSize.x, height = pageSize.y;
        
        //draw everything on an offscreen image first and then draw that image
        //onto the printer gc...this takes care of certain drawing bugs.
        
        Image image = new Image(Display.getDefault(), getMapMode().LPtoDP(pageSize.x), getMapMode().LPtoDP(pageSize.y));
        
        GC imgGC = new GC(image, (rtlEnabled) ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT);
        imgGC.setXORMode(false);

        SWTGraphics sg = new SWTGraphics(imgGC);
        
        //for scaling
        ScaledGraphics g1 = new ScaledGraphics(sg);
    
        //for himetrics and svg
        MapModeGraphics mmg = createMapModeGraphics(g1);
        
        //if mmg's font is null, gc.setFont will use a default font
        imgGC.setFont(mmg.getFont());
        
        mmg.translate(translated.x,translated.y);
        mmg.scale(userScale);
        
        mmg.pushState();
        
        int translateX = -(width * (colIndex - 1));
        int translateY = -(height * (rowIndex - 1));
    
        int scaledTranslateX = (int) (translateX / userScale);
        int scaledTranslateY = (int) (translateY / userScale);
    
        int scaledWidth = (int) (width / userScale);
        int scaledHeight = (int) (height / userScale);
        
        if (rtlEnabled) {
            scaledTranslateX += (margins.left * (colIndex - 1)) + (margins.right * (colIndex));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        }
        else {
            scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        }
            
        mmg.translate(scaledTranslateX, scaledTranslateY);
        
        Rectangle clip = new Rectangle((scaledWidth - margins.left - margins.right) 
            * (colIndex - 1) + figureBounds.x, (scaledHeight - margins.bottom - margins.top) 
            * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right - margins.left, 
            scaledHeight - margins.top - margins.bottom);
        mmg.clipRect(clip);
        
        dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(mmg);
        
        mmg.popState();
        
        this.graphics.pushState();

        this.graphics.drawImage(image, 0, 0);
        
        this.graphics.popState();
        
        //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
        drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
        
        disposeImageVars(imgGC, image, sg, g1, mmg);
    }

    /**
     * Print the diagram figure to fit the number and rows and columns
     * specified by the user.
     * 
     * @@param dgrmEP the DiagramEditPart that will be printed
     * @@param loadedPreferences true if existing prefs could be loaded
     * successfully, false if not and defaults are being used.  This parameter
     * is important to obtain the correct page break bounds.
     * @@param fPreferences the preferenceStore that could either contain
     * existing preferences or defaults
     */
    protected void printToPages(DiagramEditPart dgrmEP,
            boolean loadedPreferences, IPreferenceStore fPreferences) {
        assert null != printer : "printer must be set"; //$NON-NLS-1$

        Rectangle figureBounds = PrintHelper.getPageBreakBounds(dgrmEP,
            loadedPreferences);

        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper
            .getPageSize(fPreferences, getMapMode());
        
        //do not include margins
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
            .getPageSize(fPreferences, false, getMapMode());
         
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageSize, false);
        int numCols = pageCount.x;
        int numRows = pageCount.y;
        
        Rectangle translate = new Rectangle(Math.min(0, figureBounds.x), Math
            .min(0, figureBounds.y),
            Math.max(pageBounds.x, numCols * pageSize.x), Math.max(pageBounds.y,
                numRows * pageSize.y));
        
        int totalHeight = (this.rows * pageSize.y);
        int totalWidth  = (this.columns * pageSize.x);

        float vScale = ((float) totalHeight) / ((float)(numRows * pageSize.y));
        float hScale = ((float) totalWidth) / ((float)(numCols * pageSize.x));

        this.userScale = Math.min(hScale, vScale);

        // translate to offset figure position
        translated = new Point((int) (-translate.x * userScale),
            (int) (-translate.y * userScale));

        PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
        adjustMargins(margins, userScale, getPrinterOffset());

        GC gc_ = new GC(Display.getDefault());

        FontData fontData = JFaceResources.getDefaultFont().getFontData()[0];
        Font font = new Font(printer, fontData);

        int row = 1, col = 1, finalRow = 0, finalColumn = 0;
        
        if (this.printRangePageSelection) {
            //print only the pages specified in the page range
            //this corresponds to the physical pages, not the print range of pages on one physical page.
            row = calculateRowFromPage(this.pageFrom, this.columns);
            col = calculateColumnFromPage(this.pageFrom, this.columns, row);
            
            finalRow = calculateRowFromPage(this.pageTo, this.columns);
            finalColumn = calculateColumnFromPage(this.pageTo, this.columns, finalRow);
        }
        
        try {
            // print the pages in row, column order
            for (; row <= rows; row++) {
                for (; col <= columns; col++) {
                    printer.startPage();
                    drawPage(gc_, dgrmEP, fPreferences, translate, margins,
                        font, row, col);
                    printer.endPage();
                    
                    if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
                        break;
                }
                
                if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
                    break;
                
                col = 1;
            }
        } finally {
            // must dispose resources
            font.dispose();
            gc_.dispose();
        }
    }

    /**
     * Return scale factor between printer and display.
     * 
     * @@return float
     */
    private float computePrinterDisplayScale() {
        assert null != printer : "printer must be set"; //$NON-NLS-1$
        assert null != display_dpi : "display_dpi must be set"; //$NON-NLS-1$

        Point dpi = printer.getDPI();
        float scale = dpi.x / (float) display_dpi.x;
        
        return scale;
    }

    /**
     * Disposes of the resources.
     */
    private void dispose() {
        if (this.graphics != null) {
            try {
                this.graphics.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                this.graphics = null;                
            }
        }
        
        if (this.printerGraphics != null) {
            try {
                this.printerGraphics.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                this.printerGraphics = null;
            }
        }
        
        if (this.swtGraphics != null) {
            try {
                this.swtGraphics.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                this.swtGraphics = null;
            }
        }
        
        if (this.gc != null) {
            try {
                this.gc.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                this.gc = null;
            }
        }
        
        //reset the printer offset, just in case the next diagram to be printed 
        //uses a different map mode.
        printerOffset = null;
        
    }
    
    private void disposeImageVars(GC imgGC, Image image, SWTGraphics sg, 
            ScaledGraphics g1, MapModeGraphics mmg) {
        
        if (mmg != null) {
            try {
                mmg.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                mmg = null;                
            }
        }
        
        if (g1 != null) {
            try {
                g1.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                g1 = null;                
            }
        }
        
        if (sg != null) {
            try {
                sg.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                sg = null;                
            }
        }
        
        if (imgGC != null) {
            try {
                imgGC.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                imgGC = null;                
            }
        }
        
        if (image != null) {
            try {
                image.dispose();
            }
            catch (NullPointerException e) {
                //do nothing
            }
            finally {
                image = null;                
            }
        }
    }

    /**
     * Creates the <code>MapModeGraphics</code>.
     * 
     * @@param theGraphics
     *            the <code>PrinterGraphics</code> object
     * @@return the new <code>MapModeGraphics</code>
     */
    protected MapModeGraphics createMapModeGraphics(Graphics theGraphics) {
        return new MapModeGraphics(theGraphics, getMapMode());
    }
d569 44
a612 43
    
    /**
     * Gets the preferences hint that is to be used to find the appropriate
     * preference store from which to retrieve diagram preference values. The
     * preference hint is mapped to a preference store in the preference
     * registry <@@link DiagramPreferencesRegistry>.
     * 
     * @@return the preferences hint
     */
    protected PreferencesHint getPreferencesHint() {
        return preferencesHint;
    }
    
    /**
     * Adjust the given PageMargins by the scale and offset
     * 
     * @@param margins PageMargins to adjust
     * @@param scale margins will be scaled by this amount
     * @@param offset to adjust margins by
     */
    protected void adjustMargins(PageMargins margins, float scale, Point offset) {
        //scale
        margins.left /= scale;
        margins.top /= scale;
        margins.right /= scale;
        margins.bottom /= scale;
        
        //offsets
        margins.left -= offset.x; 
        margins.right += offset.x;
        margins.top -= offset.y;
        margins.bottom += offset.y;
        
        // this is more readable than doing Math.min for all the above
        if (margins.left < 0)
            margins.left = 0;
        if (margins.right < 0)
            margins.right = 0;
        if (margins.top < 0)
            margins.top = 0;
        if (margins.bottom < 0)
            margins.bottom = 0;
    }
@


1.7.2.2
log
@[150280] gmf_R1_0_maintenance ahunter 060717 Incorrect copyright in some GMF files
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.7.2.3
log
@[160697] gmf_R1_0_maintenance syedatif 061017 Printed diagrams use default preferencesHint instead of their own.
@
text
@d227 1
a227 1
            DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart((Diagram) obj, preferencesHint);
d232 2
@


1.7.2.4
log
@[134767] gmf  gmf_R1_0_maintenace mmostafa 061026 Printing: Fit to page makes the diagram too small
@
text
@d25 1
a83 10
    
    private boolean fitToPage = false;
    
    /**
     * change the fit to page state
     * @@param fitToPage the new fit to page state
     */
    public void setFitToPage(boolean fitToPage){
        this.fitToPage = fitToPage;
    }
d546 1
d630 3
a633 1
        PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
d637 1
a641 18
        float actualWidth = 0;
        float actualHeight = 0;
        if (this.rows==1 && this.columns==1 && fitToPage){
            Rectangle rectangle = dgrmEP.getChildrenBounds();
            figureBounds.width = rectangle.x + rectangle.width + (numCols)*margins.right + numCols*margins.left ;
            figureBounds.height = rectangle.y + rectangle.height + (numRows)*margins.top + numRows*margins.bottom;
            actualWidth = figureBounds.width;
            actualHeight = figureBounds.height;
        }else {
            actualWidth = numCols * pageSize.x;
            actualHeight = numRows * pageSize.y;
        }

        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper
            .getPageSize(fPreferences, getMapMode());
        

        
d650 2
a651 2
        float vScale =  totalHeight / actualHeight;
        float hScale = totalWidth / actualWidth;
d659 1
@


1.7.2.5
log
@[162200] gmf_head gmf_R1_0_maintenance crevells 061122 CopyingResource blindly appends URI fragment queries
Contributed by: David Cummings
@
text
@d555 2
d558 20
a577 31
        if (rtlEnabled) 
        {
            // draw everything on an offscreen image first and then draw that image
            // onto the printer gc...this takes care of certain drawing bugs.
            // This causes issues with printing resolution as it uses a display image
            // which is typically 72dpi
            // This code should be removed when a resolution to Bugzilla 162459 is found

            Image image = new Image(Display.getDefault(), getMapMode().LPtoDP(pageSize.x), getMapMode().LPtoDP(pageSize.y));

            GC imgGC = new GC(image, (rtlEnabled) ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT);
            imgGC.setXORMode(false);
      
            SWTGraphics sg = new SWTGraphics(imgGC);
              
            //for scaling
            ScaledGraphics g1 = new ScaledGraphics(sg);
          
            //for himetrics and svg
            MapModeGraphics mmg = createMapModeGraphics(g1);
              
            //if mmg's font is null, gc.setFont will use a default font
            imgGC.setFont(mmg.getFont());
              
            mmg.translate(translated.x,translated.y);
            mmg.scale(userScale);
            
            mmg.pushState();
            
            int translateX = -(width * (colIndex - 1));
            int translateY = -(height * (rowIndex - 1));
d579 8
a586 2
            int scaledTranslateX = (int) (translateX / userScale);
            int scaledTranslateY = (int) (translateY / userScale);
d588 1
a588 3
            int scaledWidth = (int) (width / userScale);
            int scaledHeight = (int) (height / userScale);
            
d591 5
a595 7
           
            mmg.translate(scaledTranslateX, scaledTranslateY);
            
            Rectangle clip = new Rectangle((scaledWidth - margins.left - margins.right) 
                * (colIndex - 1) + figureBounds.x, (scaledHeight - margins.bottom - margins.top) 
                * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right - margins.left, 
                scaledHeight - margins.top - margins.bottom);
d597 1
a597 7
            mmg.clipRect(clip);
            
            dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(mmg);

            mmg.popState();
            
            this.graphics.pushState();
d599 5
a603 9
            this.graphics.drawImage(image, 0, 0);
              
            this.graphics.popState();

            //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
            drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
          
            disposeImageVars(imgGC, image, sg, g1, mmg);
        } else {
d605 1
a605 7
            this.graphics.translate(translated.x,translated.y);
            this.graphics.scale(userScale);
            
            this.graphics.pushState();
    
            int translateX = -(width * (colIndex - 1));
            int translateY = -(height * (rowIndex - 1));
d607 1
a607 2
            int scaledTranslateX = (int) (translateX / userScale);
            int scaledTranslateY = (int) (translateY / userScale);
d609 1
a609 19
            int scaledWidth = (int) (width / userScale);
            int scaledHeight = (int) (height / userScale);
            
            if (rtlEnabled) {
                scaledTranslateX += (margins.left * (colIndex - 1)) + (margins.right * (colIndex));
                scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
            }
            else {
                scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
                scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
            }
                
            this.graphics.translate(scaledTranslateX, scaledTranslateY);
            
            Rectangle clip = new Rectangle((scaledWidth - margins.left - margins.right) 
                * (colIndex - 1) + figureBounds.x, (scaledHeight - margins.bottom - margins.top) 
                * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right - margins.left, 
                scaledHeight - margins.top - margins.bottom);
            this.graphics.clipRect(clip);
d611 8
a618 7
            dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(this.graphics);
    
            this.graphics.popState();
            
            //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
            drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
        }
@


1.7.2.6
log
@ gmf_R1_0_maintenace mmostafa 061123 code clean up
@
text
@d580 29
a608 1
            internalDrawPage(dgrmEP,figureBounds,fPreferences,margins,mmg,rowIndex, colIndex,true);
d622 35
a656 1
            internalDrawPage(dgrmEP,figureBounds,fPreferences,margins,this.graphics,rowIndex, colIndex,false);
a660 45
    
    private void internalDrawPage(DiagramEditPart dgrmEP,
            Rectangle figureBounds, IPreferenceStore fPreferences,
            PageMargins margins, Graphics g, int rowIndex, int colIndex,
            boolean RTL_ENABLED) {
        org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
            .getPageSize(fPreferences, false, getMapMode());

        int width = pageSize.x, height = pageSize.y;
        g.translate(translated.x, translated.y);
        g.scale(userScale);

        g.pushState();

        int translateX = -(width * (colIndex - 1));
        int translateY = -(height * (rowIndex - 1));

        int scaledTranslateX = (int) (translateX / userScale);
        int scaledTranslateY = (int) (translateY / userScale);

        int scaledWidth = (int) (width / userScale);
        int scaledHeight = (int) (height / userScale);

        if (RTL_ENABLED) {
            scaledTranslateX += (margins.left * (colIndex - 1))
                + (margins.right * (colIndex));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        } else {
            scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
            scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
        }

        g.translate(scaledTranslateX, scaledTranslateY);

        Rectangle clip = new Rectangle(
            (scaledWidth - margins.left - margins.right) * (colIndex - 1)
                + figureBounds.x, (scaledHeight - margins.bottom - margins.top)
                * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right
                - margins.left, scaledHeight - margins.top - margins.bottom);
        g.clipRect(clip);

        dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(g);

        g.popState();
    }
@


1.7.2.7
log
@[171690] gmf_R1_0_maintenance aboyko 070129 Diagrams are printed incorrectly
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d83 10
a113 10
    
    private boolean fitToPage = false;
    
    /**
     * change the fit to page state
     * @@param fitToPage the new fit to page state
     */
    public void setFitToPage(boolean fitToPage){
        this.fitToPage = fitToPage;
    }
d425 1
a425 1
        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper.getPageSize(fPreferences, getMapMode());
d442 1
a442 1
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageBounds, true);
d551 1
d553 3
d590 1
d593 1
d608 2
a612 3
        g.translate(translated.x, translated.y);
        g.scale(userScale);

d665 3
a667 3
        org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper
            .getPageSize(fPreferences, getMapMode());
        org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageBounds, false);
d674 3
a676 1
        	figureBounds = dgrmEP.getChildrenBounds();
d680 2
a681 2
            actualWidth = numCols * pageBounds.x;
            actualHeight = numRows * pageBounds.y;
d684 12
a695 2
        int totalHeight = (this.rows * pageBounds.y);
        int totalWidth  = (this.columns * pageBounds.x);
d703 2
a704 2
        translated = new Point((int) (-figureBounds.x * userScale),
            (int) (-figureBounds.y * userScale));
d730 1
a730 1
                    drawPage(gc_, dgrmEP, fPreferences, figureBounds, margins,
@


1.6
log
@Bugzilla#113157 gmf_head cmahoney 051104 Updating tutorial guides and some comments with name changes
@
text
@d60 5
a64 1
	protected Graphics graphics;
d236 3
a238 2
		Graphics g = new SWTGraphics(gc);
		this.graphics = createMapModeGraphics(g);
d527 15
a541 1

d552 1
a552 1
	 *            the <code>Graphics</code> object
d556 1
a556 2
		return new MapModeGraphics(new PrinterGraphics(theGraphics, printer,
			true), getMapMode());
d558 11
@


1.5
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d82 1
a82 1
	 * diagramming preference values for properties of shapes, connectors, and
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051029 API: Encapsulate MapMode / HiMetric coordinate system from clients

First phase delivery...
@
text
@d294 1
a294 1
		org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize(fPreferences, false);
d304 1
a304 1
		PageMargins margins = PageInfoHelper.getPageMargins(fPreferences);
d358 1
a358 1
			HeaderAndFooterHelper.LEFT_MARGIN
d360 1
a360 1
				/ 2, HeaderAndFooterHelper.TOP_MARGIN);
d367 1
a367 1
			HeaderAndFooterHelper.LEFT_MARGIN
d369 1
a369 1
				/ 2, height - HeaderAndFooterHelper.BOTTOM_MARGIN);
d394 1
a394 1
			.getPageSize(fPreferences, false);
d445 1
a445 1
			.getPageSize(fPreferences);
d454 1
a454 1
			.getPageSize(fPreferences, true);
d478 1
a478 1
		PageMargins margins = PageInfoHelper.getPageMargins(fPreferences);
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d21 11
a41 11
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper;
import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper.PageMargins;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.MapModeGraphics;
import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.PrinterGraphics;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
import org.eclipse.gmf.runtime.notation.Diagram;

d87 1
d95 1
d97 1
a97 1
	public DiagramPrinter(PreferencesHint preferencesHint) {
d100 20
d260 1
a260 1
			offsetX = (int) (MapMode
d262 1
a262 1
			offsetY = (int) (MapMode
d359 1
a359 1
				+ (width - MapMode.DPtoLP(gc_.textExtent(headerOrFooter).x))
d368 1
a368 1
				+ (width - MapMode.DPtoLP(gc_.textExtent(headerOrFooter).x))
d538 1
a538 1
			true));
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002 - 2005.  All Rights Reserved.             |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d38 1
a38 1
import com.ibm.xtools.notation.Diagram;
@

