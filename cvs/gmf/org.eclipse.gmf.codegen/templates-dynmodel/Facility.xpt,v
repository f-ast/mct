head	1.7;
access;
symbols
	v20081022-1925:1.7
	v20081015-1925:1.7
	v20081008-1925:1.6
	v20081001-1925:1.6
	v20080930-1130:1.6
	v20080926-1245:1.6
	v20080924-1925:1.6
	v20080917-1925:1.6
	v20080911-1728:1.6
	v20080910-1520:1.6
	v20080903-1520:1.6
	v20080827-1520:1.6
	v20080813-1520:1.6
	v20080806-1520:1.6
	v20080722-1827:1.6
	v20080718-1731:1.6
	v20080716-1600:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.6.0.2
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080610-1132:1.6
	v20080603-1553:1.5
	v20080528-1052:1.5
	v20080521:1.5
	v20080516-1543:1.5
	v20080516-1143:1.5
	v20080512-1200:1.5
	v20080508-2000:1.5
	v20080507-1326:1.5
	v20080503-1740:1.4
	v20080501-1739:1.4
	v20080425-1959:1.4
	v20080417-1610:1.4
	v20080411-0411:1.4
	v20080404-1111:1.4
	v20080322-0000:1.4;
locks; strict;
comment	@# @;
expand	@k@;


1.7
date	2008.10.15.18.01.18;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	b45d48f62fed4567;

1.6
date	2008.06.05.11.42.19;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	242b4847d11a4567;

1.5
date	2008.05.07.13.56.02;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	39124821b4de4567;

1.4
date	2008.02.28.19.04.39;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	cd347c705c44567;

1.3
date	2008.02.28.14.21.42;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	47ed47c6c3744567;

1.2
date	2008.02.28.13.21.26;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	1f7447c6b5554567;

1.1
date	2008.02.27.17.30.20;	author atikhomirov;	state Exp;
branches;
next	;
commitid	22cf47c59e244567;


desc
@@


1.7
log
@[249301] Wrap use of assert  into dedicated template
@
text
@/*
 * Copyright (c) 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION Facility»

«DEFINE Main FOR DynamicModelAccess-»
package «packageName»;

public class «className» {

	«EXPAND field(this) FOREACH editorGen.getAllDomainGenPackages(false)-»

	«EXPAND xpt::Common::generatedMemberComment»
	private final org.eclipse.emf.ecore.EPackage ePackage;

	«EXPAND xpt::Common::generatedMemberComment»
	private «className»(org.eclipse.emf.ecore.EPackage ePackage) {
		this.ePackage = ePackage;
	}

	«EXPAND getMethod(this) FOREACH editorGen.getAllDomainGenPackages(false)-»

	«EXPAND getRegistryMethod»

	«EXPAND xpt::Common::generatedMemberComment»
	public boolean isInstance(Object obj, String metaClassName) {
		org.eclipse.emf.ecore.EClass metaClass = getEClass(metaClassName);
		return obj instanceof org.eclipse.emf.ecore.EObject && metaClass.isSuperTypeOf(((org.eclipse.emf.ecore.EObject) obj).eClass());
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EObject newInstance(String metaClassName) {
		return this.ePackage.getEFactoryInstance().create(getEClass(metaClassName));
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EClass getEClass(String metaClassName) {
		«EXPAND xpt::Common::assert("metaClassName != null")-»
		org.eclipse.emf.ecore.EClass metaClass = findMetaClass(metaClassName);
		assertMetaClass(metaClass, metaClassName);
		return metaClass;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EStructuralFeature getEFeature(String metaClassName, String metaFeatureName) {
		«EXPAND xpt::Common::assert("metaFeatureName != null")-»
		org.eclipse.emf.ecore.EClass metaClass = getEClass(metaClassName);
		org.eclipse.emf.ecore.EStructuralFeature f = metaClass.getEStructuralFeature(metaFeatureName);
		assertMetaFeature(f, metaClass, metaFeatureName);
		return f;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EAttribute getEAttribute(String metaClassName, String metaFeatureName) {
		return (org.eclipse.emf.ecore.EAttribute) getEFeature(metaClassName, metaFeatureName);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EReference getEReference(String metaClassName, String metaFeatureName) {
		return (org.eclipse.emf.ecore.EReference) getEFeature(metaClassName, metaFeatureName);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EDataType getEDataType(String metaClassName) {
		«EXPAND xpt::Common::assert("metaClassName != null")-»
		org.eclipse.emf.ecore.EClassifier c = this.ePackage.getEClassifier(metaClassName);
		if (false == c instanceof org.eclipse.emf.ecore.EDataType) {
			return null;
		}
		return (org.eclipse.emf.ecore.EDataType) c;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EEnum getEEnum(String metaClassName) {
		«EXPAND xpt::Common::assert("metaClassName != null")-»
		org.eclipse.emf.ecore.EClassifier c = this.ePackage.getEClassifier(metaClassName);
		if (false == c instanceof org.eclipse.emf.ecore.EEnum) {
			return null;
		}
		return (org.eclipse.emf.ecore.EEnum) c;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private org.eclipse.emf.ecore.EClass findMetaClass(String name) {
		org.eclipse.emf.ecore.EClassifier c = this.ePackage.getEClassifier(name);
		if (false == c instanceof org.eclipse.emf.ecore.EClass) {
			return null;
		}
		return (org.eclipse.emf.ecore.EClass) c;
	}

	«EXPAND xpt::Common::generatedMemberComment("Default implementation throws IllegalStateException if metaclass is null")»
	private void assertMetaClass(org.eclipse.emf.ecore.EClass metaClass, String metaClassName) {
		if (metaClass == null) {
			throw new IllegalStateException(java.text.MessageFormat.format("Can't find class {0} in the package {1}", new Object[] {metaClassName, this.ePackage.getName()}));
		}
	}

	«EXPAND xpt::Common::generatedMemberComment("Default implementation throws IllegalStateException if meta-feature is null")»
	private void assertMetaFeature(org.eclipse.emf.ecore.EStructuralFeature metaFeature, org.eclipse.emf.ecore.EClass metaClass, String featureName) {
		if (metaFeature == null) {
			throw new IllegalStateException(java.text.MessageFormat.format("Can't find feature {0} of class {1} in the package {2}", new Object[] {featureName, metaClass.getName(), this.ePackage.getName()}));
		}
	}

	«EXPAND initMethod FOREACH editorGen.getAllDomainGenPackages(false)-»
«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE additions FOR DynamicModelAccess»«ENDDEFINE»

«DEFINE field(DynamicModelAccess dma) FOR GenPackage-»
«EXPAND xpt::Common::generatedMemberComment»
private static «dma.className» «fieldName()»;
«ENDDEFINE»

«DEFINE getMethod(DynamicModelAccess dma) FOR GenPackage-»
	«EXPAND xpt::Common::generatedMemberComment("@@throws IllegalStateException if no EPackage with given URI is registered.")»
	public static «dma.className» get«getNameToken()»() {
		if («fieldName()» == null) {
			org.eclipse.emf.ecore.EPackage pkg = getRegistry().getEPackage("«ecorePackage.nsURI»");
			if (pkg == null) {
				throw new IllegalStateException("Package «ecorePackage.name»(«ecorePackage.nsURI») not found");
			}
			«fieldName()» = new «dma.className»(pkg);
			«fieldName()».init«getNameToken()»();
		}
		return «fieldName()»;
	}
«ENDDEFINE»

«DEFINE initMethod FOR GenPackage-»
	«EXPAND xpt::Common::generatedMemberComment»
	private void init«getNameToken()»() {
	}
«ENDDEFINE»

«DEFINE getRegistryMethod FOR DynamicModelAccess»
	«EXPAND xpt::Common::generatedMemberComment("Default implementation returns global registry, clients that need another may redefine.")»
	private static org.eclipse.emf.ecore.EPackage.Registry getRegistry() {
		return org.eclipse.emf.ecore.EPackage.Registry.INSTANCE;
	}
«ENDDEFINE»@


1.6
log
@[150177] Use dynamic EMF model instead of generated code - tests.
@
text
@d51 1
a51 1
		assert metaClassName != null;
d59 1
a59 1
		assert metaFeatureName != null;
d78 1
a78 1
		assert metaClassName != null;
d88 1
a88 1
		assert metaClassName != null;
@


1.5
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d24 1
a24 1
	«EXPAND field FOREACH editorGen.getAllDomainGenPackages(false)-»
d30 1
a30 1
	private MetaModelFacility(org.eclipse.emf.ecore.EPackage ePackage) {
d34 1
a34 1
	«EXPAND getMethod FOREACH editorGen.getAllDomainGenPackages(false)-»
d126 1
a126 1
«DEFINE field FOR GenPackage-»
d128 1
a128 1
private static MetaModelFacility «fieldName()»;
d131 1
a131 1
«DEFINE getMethod FOR GenPackage-»
d133 1
a133 1
	public static MetaModelFacility get«getNameToken()»() {
d139 1
a139 1
			«fieldName()» = new MetaModelFacility(pkg);
@


1.4
log
@[150177] phase II, access to metamodel through generated facility - deal with occasional plain Objects
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.3
log
@[150177] phase II, access to metamodel through generated facility - specific metaFeature types, mandatory casts for Object returned from eGet
@
text
@d39 1
a39 1
	public boolean isInstance(org.eclipse.emf.ecore.EObject obj, String metaClassName) {
d41 1
a41 1
		return obj != null && metaClass.isSuperTypeOf(obj.eClass());
@


1.2
log
@[150177] phase II, access to metamodel through generated facility
@
text
@d67 10
@


1.1
log
@[150177] phase II, generated facility to perform metamodel operations (like instanceof or metaclass accessors) with dynamic models, new gmfgen options to parameterize codegen.
@
text
@d58 29
d102 7
@

