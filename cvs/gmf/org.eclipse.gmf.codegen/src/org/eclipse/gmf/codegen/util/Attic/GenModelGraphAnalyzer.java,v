head	1.7;
access;
symbols
	v20081022-1925:1.7
	v20081015-1925:1.7
	v20081008-1925:1.7
	v20081001-1925:1.7
	v20080924-1925:1.7
	v20080917-1925:1.7
	v20080911-1728:1.7
	v20080910-1520:1.7
	v20080903-1520:1.7
	v20080827-1520:1.7
	v20080813-1520:1.7
	v20080806-1520:1.7
	v20070405-1100:1.6
	v20070403-1500:1.6
	v20070330-1300:1.6
	v20060330-1300:1.6
	v20070322-1100:1.6
	v20060316-0600:1.5
	v20070307-0700:1.4
	v20070301-1200:1.4
	v20070228-2000:1.4
	v20070221-1500:1.4
	v20070208-1800:1.4
	v20070103-0300:1.3
	M4_20:1.3
	v20061222-1800:1.2
	v20061218-1200:1.2
	v20061214-0000:1.2
	v20061120-1300:1.2
	M3_20:1.2
	v20061117-0800:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.7
date	2007.04.06.14.37.41;	author ashatalin;	state dead;
branches;
next	1.6;
commitid	5df46165b334567;

1.6
date	2007.03.20.20.15.02;	author ashatalin;	state Exp;
branches;
next	1.5;
commitid	1c03460040bd4567;

1.5
date	2007.03.14.14.39.36;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	444245f8090b4567;

1.4
date	2007.01.17.13.12.34;	author ashatalin;	state Exp;
branches;
next	1.3;
commitid	3d0045ae20c04567;

1.3
date	2006.12.28.19.45.50;	author ashatalin;	state Exp;
branches;
next	1.2;
commitid	13f545941eec4567;

1.2
date	2006.11.02.14.12.22;	author ashatalin;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.01.18.25.42;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Moving non-open API classes from org.eclipse.gmf.codegen.util to org.eclipse.gmf.internal.codegen.util package.
@
text
@/**
 * Copyright (c) 2006 Borland Software Corp.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
package org.eclipse.gmf.codegen.util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
import org.eclipse.gmf.codegen.gmfgen.GenContainerBase;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenNavigatorChildReference;
import org.eclipse.gmf.codegen.gmfgen.GenNavigatorReferenceType;
import org.eclipse.gmf.codegen.gmfgen.GenNode;

public class GenModelGraphAnalyzer {

	/**
	 * @@deprecated
	 */
	public GenModelGraphAnalyzer(GenDiagram diagram) {
	}

	public static List<List<GenCommonBase>> getConnectionPaths(GenNavigatorChildReference reference) {
		assert reference.getParent() != null;
		if (reference.getReferenceType() == GenNavigatorReferenceType.CHILDREN_LITERAL) {
			return getChildConnectionPaths(reference.getParent(), reference.getChild());
		} else if (reference.getReferenceType() == GenNavigatorReferenceType.IN_SOURCE_LITERAL) {
			return getInSourceLinkConnectionPaths(reference.getParent(), reference.getChild(), reference.getNavigator().getEditorGen().getDiagram());
		} else if (reference.getReferenceType() == GenNavigatorReferenceType.OUT_TARGET_LITERAL) {
			return getOutTargetLinkConnectionPaths(reference.getParent(), reference.getChild(), reference.getNavigator().getEditorGen().getDiagram());
		}
		return Collections.emptyList();
	}

	private static List<List<GenCommonBase>> getOutTargetLinkConnectionPaths(GenCommonBase source, GenCommonBase target, GenDiagram diagram) {
		return new LinkedConnectionFinder(diagram, true).findConnectionPaths(source, target);
	}

	private static List<List<GenCommonBase>> getInSourceLinkConnectionPaths(GenCommonBase source, GenCommonBase target, GenDiagram diagram) {
		return new LinkedConnectionFinder(diagram, false).findConnectionPaths(source, target);
	}

	private static List<List<GenCommonBase>> getChildConnectionPaths(GenCommonBase source, GenCommonBase target) {
		return new ChildConnectionFinder().findConnectionPaths(source, target);
	}

	private static abstract class AbstractConnectionFinder {

		private Set<GenCommonBase> myVisiting;

		public AbstractConnectionFinder() {
			myVisiting = new LinkedHashSet<GenCommonBase>();
		}

		protected abstract Collection<GenCommonBase> getConnectedNodes(GenCommonBase source);

		public List<List<GenCommonBase>> findConnectionPaths(GenCommonBase source, GenCommonBase target) {
			if (isConnectionFound(source, target)) {
				// Direct connection found
				List<GenCommonBase> path = new ArrayList<GenCommonBase>();
				path.add(target);
				List<List<GenCommonBase>> connections = new ArrayList<List<GenCommonBase>>();
				connections.add(path);
				return connections;
			}

			if (isVisiting(source)) {
				// Loop found
				return new ArrayList<List<GenCommonBase>>();
			}
			startVisiting(source);
			try {
				// Looking for indirect connection + extending connection with
				// current node
				Collection<GenCommonBase> connectedNodes = getConnectedNodes(source);
				List<List<GenCommonBase>> connections = new ArrayList<List<GenCommonBase>>();

				for (GenCommonBase nextConnectedNode : connectedNodes) {
					connections.addAll(findConnectionPaths(nextConnectedNode, target));
				}

				for (List<GenCommonBase> path : connections) {
					path.add(0, source);
				}
				return connections;
			} finally {
				stopVisiting(source);
			}
		}

		private boolean isVisiting(GenCommonBase node) {
			return myVisiting.contains(node);
		}

		private void startVisiting(GenCommonBase node) {
			myVisiting.add(node);
		}

		private void stopVisiting(GenCommonBase node) {
			myVisiting.remove(node);
		}

		protected Iterable<GenCommonBase> getPath() {
			return myVisiting;
		}

		/**
		 * myVisiting.size() > 0 checked return non-empty paths if source and
		 * target nodes are the same
		 */
		private boolean isConnectionFound(GenCommonBase source, GenCommonBase target) {
			return myVisiting.size() > 0 && source == target;
		}

	}

	private static class ChildConnectionFinder extends AbstractConnectionFinder {

		protected Collection<GenCommonBase> getConnectedNodes(GenCommonBase source) {
			Collection<GenCommonBase> children = new ArrayList<GenCommonBase>();
			if (source instanceof GenContainerBase) {
				children.addAll(((GenContainerBase) source).getContainedNodes());
			}
			if (source instanceof GenDiagram) {
				children.addAll(((GenDiagram) source).getLinks());
			}
			if (source instanceof GenNode) {
				children.addAll(((GenNode) source).getCompartments());
				children.addAll(((GenNode) source).getLabels());
			}
			if (source instanceof GenLink) {
				children.addAll(((GenLink) source).getLabels());
			}
			return children;
		}

	}

	private static class LinkedConnectionFinder extends AbstractConnectionFinder {

		private GenDiagram myDiagram;

		/**
		 * true: looking for the connection from source to target using all
		 * links in natural direction (outgoing links -> link target -> outgoing
		 * links...)
		 * 
		 * false: opposite direction (incomming links -> link source -> ..)
		 */
		private boolean myIsInLinkDirection;

		public LinkedConnectionFinder(GenDiagram diagram, boolean inLinkDirection) {
			myDiagram = diagram;
			myIsInLinkDirection = inLinkDirection;
		}

		protected Collection<GenCommonBase> getConnectedNodes(GenCommonBase source) {
			if (source instanceof GenNode) {
				return getPotentiallyConnectedLinks((GenNode) source);
			} else if (source instanceof GenLink) {
				return getPotentiallyConnectedNodes((GenLink) source);
			}
			return Collections.emptyList();
		}

		private Collection<GenCommonBase> getPotentiallyConnectedLinks(GenNode node) {
			for (GenCommonBase nextPathElement : getPath()) {
				if (nextPathElement instanceof GenLink) {
					// Only one link allowed in the path
					return Collections.emptyList();
				}
			}
			// TODO: this method could be moved to GenNode
			Collection<GenCommonBase> potentialLinks = new ArrayList<GenCommonBase>();
			for (GenLink nextLink : myDiagram.getLinks()) {
				if (nextLink.getModelFacet() == null) {
					potentialLinks.add(nextLink);
				} else {
					GenClass genClass = myIsInLinkDirection ? nextLink.getModelFacet().getSourceType() : nextLink.getModelFacet().getTargetType();
					if (genClass != null && genClass.getEcoreClass().isSuperTypeOf(node.getDomainMetaClass().getEcoreClass())) {
						potentialLinks.add(nextLink);
					}
				}
			}
			return potentialLinks;
		}

		// TODO: this method could be moved to GenLink
		private Collection<GenCommonBase> getPotentiallyConnectedNodes(GenLink link) {
			Collection<GenCommonBase> potentialNodes = new ArrayList<GenCommonBase>();
			if (link.getModelFacet() == null) {
				potentialNodes.addAll(myDiagram.getAllNodes());
			} else {
				GenClass genClass = myIsInLinkDirection ? link.getModelFacet().getTargetType() : link.getModelFacet().getSourceType();
				if (genClass != null) {
					for (GenNode nextNode : myDiagram.getAllNodes()) {
						if (genClass.getEcoreClass().isSuperTypeOf(nextNode.getDomainMetaClass().getEcoreClass())) {
							potentialNodes.add(nextNode);
						}
					}
				}
			}
			return potentialNodes;
		}

	}

}
@


1.6
log
@NavigatorReference type constant name corrected.
Generating wrapper for domain model navigator nodes to preserve navigator tree selection/expansion on model files reload.
@
text
@@


1.5
log
@Regenerated gmfgen model with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d44 1
a44 1
		} else if (reference.getReferenceType() == GenNavigatorReferenceType.OUT_TAGET_LITERAL) {
@


1.4
log
@NodeItemSemanticEditPolicy template reimplemented using xpand.
@
text
@a16 1
import java.util.Iterator;
d190 1
a190 2
			for (Iterator it = myDiagram.getLinks().iterator(); it.hasNext();) {
				GenLink nextLink = (GenLink) it.next();
d210 5
a214 4
				for (Iterator genNodes = myDiagram.getAllNodes().iterator(); genClass != null && genNodes.hasNext();) {
					GenNode nextNode = (GenNode) genNodes.next();
					if (genClass.getEcoreClass().isSuperTypeOf(nextNode.getDomainMetaClass().getEcoreClass())) {
						potentialNodes.add(nextNode);
@


1.3
log
@NavigatorContentProvider template reimplemented on xpand
@
text
@d196 3
a198 6
					Collection<GenClass> genClasses = myIsInLinkDirection ? nextLink.getModelFacet().getSourceTypes() : nextLink.getModelFacet().getTargetTypes();
					for (GenClass nextGenClass : genClasses) {
						if (nextGenClass.getEcoreClass().isSuperTypeOf(node.getDomainMetaClass().getEcoreClass())) {
							potentialLinks.add(nextLink);
							break;
						}
d211 2
a212 2
				Collection<GenClass> genClasses = myIsInLinkDirection ? link.getModelFacet().getTargetTypes() : link.getModelFacet().getSourceTypes();
				for (Iterator genNodes = myDiagram.getAllNodes().iterator(); genNodes.hasNext();) {
d214 2
a215 5
					for (GenClass genClass : genClasses) {
						if (genClass.getEcoreClass().isSuperTypeOf(nextNode.getDomainMetaClass().getEcoreClass())) {
							potentialNodes.add(nextNode);
							break;
						}
@


1.2
log
@Linked elements are leafs by default.
@
text
@d33 3
a35 2
	private GenDiagram myDiagram;

a36 1
		myDiagram = diagram;
d39 1
a39 1
	public List<List<GenCommonBase>> getConnectionPaths(GenNavigatorChildReference reference) {
d44 1
a44 1
			return getInSourceLinkConnectionPaths(reference.getParent(), reference.getChild());
d46 1
a46 1
			return getOutTargetLinkConnectionPaths(reference.getParent(), reference.getChild());
d51 2
a52 2
	private List<List<GenCommonBase>> getOutTargetLinkConnectionPaths(GenCommonBase source, GenCommonBase target) {
		return new LinkedConnectionFinder(myDiagram, true).findConnectionPaths(source, target);
d55 2
a56 2
	private List<List<GenCommonBase>> getInSourceLinkConnectionPaths(GenCommonBase source, GenCommonBase target) {
		return new LinkedConnectionFinder(myDiagram, false).findConnectionPaths(source, target);
d59 1
a59 1
	private List<List<GenCommonBase>> getChildConnectionPaths(GenCommonBase source, GenCommonBase target) {
d63 1
a63 1
	private abstract class AbstractConnectionFinder {
d133 1
a133 1
	private class ChildConnectionFinder extends AbstractConnectionFinder {
d155 1
a155 1
	private class LinkedConnectionFinder extends AbstractConnectionFinder {
@


1.1
log
@GenModelGraphAnalyzer added and used while generating navigator.
@
text
@d140 3
@

