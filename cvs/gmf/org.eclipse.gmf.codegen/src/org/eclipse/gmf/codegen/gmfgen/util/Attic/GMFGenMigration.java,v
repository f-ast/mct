head	1.13;
access;
symbols
	v20081022-1925:1.13
	v20081015-1925:1.13
	v20081008-1925:1.13
	v20081001-1925:1.13
	v20080924-1925:1.13
	v20080917-1925:1.13
	v20080911-1728:1.13
	v20080910-1520:1.13
	v20080903-1520:1.13
	v20080827-1520:1.13
	v20080813-1520:1.13
	v20080806-1520:1.13
	v20070518-1300:1.12
	v20070504-1000:1.11
	v20070427-0600:1.10
	v20070420-1000:1.10
	v20070413-1300:1.10
	v20070405-1100:1.9
	v20070403-1500:1.9
	v20070330-1300:1.9
	v20060330-1300:1.9
	v20070322-1100:1.9
	v20060316-0600:1.9
	v20070307-0700:1.9
	v20070301-1200:1.9
	v20070228-2000:1.9
	v20070221-1500:1.9
	v20070208-1800:1.9
	v20070103-0300:1.9
	M4_20:1.9
	v20061222-1800:1.8
	v20061218-1200:1.8
	v20061214-0000:1.7
	v20061120-1300:1.6
	M3_20:1.5
	v20061117-0800:1.5
	v20061013-1330:1.1;
locks; strict;
comment	@# @;


1.13
date	2007.05.18.20.39.19;	author atikhomirov;	state dead;
branches;
next	1.12;
commitid	5935464e0ef44567;

1.12
date	2007.05.10.13.55.26;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	153c4643244d4567;

1.11
date	2007.05.03.09.58.55;	author dstadnik;	state Exp;
branches;
next	1.10;
commitid	518a4639b24f4567;

1.10
date	2007.04.11.08.10.24;	author dstadnik;	state Exp;
branches;
next	1.9;
commitid	725b461c97d64567;

1.9
date	2006.12.28.13.40.13;	author dstadnik;	state Exp;
branches;
next	1.8;
commitid	422a4593c9344567;

1.8
date	2006.12.15.15.48.27;	author dstadnik;	state Exp;
branches;
next	1.7;
commitid	5de44582c3b54567;

1.7
date	2006.11.22.11.09.06;	author ashatalin;	state Exp;
branches;
next	1.6;
commitid	421945642fd14567;

1.6
date	2006.11.17.16.52.18;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	4282455de8ba4567;

1.5
date	2006.10.24.17.35.35;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.18.14.21.46;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.18.09.56.50;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.17.15.49.18;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.05.23.41.12;	author radvorak;	state Exp;
branches;
next	;


desc
@@


1.13
log
@[187811] akarjakina - Migration support refactored
@
text
@/*
 * Copyright (c) 2005, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors: Radek Dvorak (Borland) - initial API and implementation
 *               Anna Karjakina (Borland) - support GenAuditContainer migration
 */
package org.eclipse.gmf.codegen.gmfgen.util;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.gmf.codegen.gmfgen.FeatureLabelModelFacet;
import org.eclipse.gmf.codegen.gmfgen.GMFGenFactory;
import org.eclipse.gmf.codegen.gmfgen.GMFGenPackage;
import org.eclipse.gmf.codegen.gmfgen.GenAuditContainer;
import org.eclipse.gmf.codegen.gmfgen.GenAuditRoot;
import org.eclipse.gmf.codegen.gmfgen.GenAuditRule;
import org.eclipse.gmf.codegen.gmfgen.GenEditorGenerator;
import org.eclipse.gmf.internal.common.migrate.MigrationConfig;
import org.eclipse.gmf.internal.common.migrate.MigrationResource.MigrationHandler;

public class GMFGenMigration {

	private static final String eNS_URI_1_0 = "http://www.eclipse.org/gmf/2005/GenModel"; //$NON-NLS-1$ 

	public static final MigrationConfig.Descriptor CONFIG = new MigrationConfig.Descriptor() {

		public String getExtension() {
			return "gmfgen"; //$NON-NLS-1$
		}

		public MigrationConfig getConfig() {
			MigrationConfig config = new MigrationConfig(GMFGenPackage.eNS_URI, new String[] { eNS_URI_1_0 }) {
				private boolean isDefaultAuditCategoryAdded = false;
				private boolean isAuditMigrationApplied = false;

				@@Override
				protected void handleResourceLoaded(Resource resource, Map<EObject, Map<String, String>> ignoredAttributes) {
					if (!isAuditMigrationApplied) {
						return;
					}
					List<EObject> initialResourceContents = new ArrayList<EObject>(resource.getContents().size());
					initialResourceContents.addAll(resource.getContents());
					for (Iterator<EObject> it = initialResourceContents.iterator(); it.hasNext();) {
						EObject object = it.next();
						if (object instanceof GenAuditContainer) {
							GenAuditRoot root = GMFGenFactory.eINSTANCE.createGenAuditRoot();
							resource.getContents().add(root);
							GenAuditContainer nextContainer = (GenAuditContainer) object;
							root.getCategories().add(nextContainer);
							moveNestedCategoriesToTheRoot(nextContainer, root);
							nextContainer.getPath().clear();
						}
						if (object instanceof GenEditorGenerator) {
							GenEditorGenerator generator = (GenEditorGenerator) object;
							GenAuditRoot root = generator.getAudits();
							if (root != null && !root.getCategories().isEmpty()) {
								if (isDefaultAuditCategoryAdded) {
									GenAuditContainer defaultCategory = getDefaultAuditContainer(root);
									for (Iterator<GenAuditRule> toplevelRules = root.getRules().iterator(); toplevelRules.hasNext();) {
										GenAuditRule nextFirst = toplevelRules.next();
										nextFirst.setCategory(defaultCategory);
									}
									if (root.getCategories().size() > 1) {
										List<GenAuditContainer> containersList = new ArrayList<GenAuditContainer>(root.getCategories().size());
										containersList.addAll(root.getCategories());
										containersList.remove(defaultCategory);
										for (Iterator<GenAuditContainer> containers = containersList.iterator(); containers.hasNext();) {
											GenAuditContainer nextContainer = containers.next();
											moveNestedCategoriesToTheRoot(nextContainer, root);
											nextContainer.getPath().clear();
											nextContainer.getPath().add(defaultCategory);
										}
									}
								} else {
									List<GenAuditContainer> containersList = new ArrayList<GenAuditContainer>(root.getCategories().size());
									containersList.addAll(root.getCategories());
									for (Iterator<GenAuditContainer> containers = containersList.iterator(); containers.hasNext();) {
										GenAuditContainer nextContainer = containers.next();
										moveNestedCategoriesToTheRoot(nextContainer, root);
										nextContainer.getPath().clear();
									}
								}
							}
						}
					}
					isDefaultAuditCategoryAdded = false;
					isAuditMigrationApplied = false;
				}
				
				private void moveNestedCategoriesToTheRoot(GenAuditContainer nextContainer, GenAuditRoot root) {
					moveNestedAuditsToTheRoot(nextContainer, root);
					for (Iterator<GenAuditContainer> nestedContainers=nextContainer.getPath().iterator(); nestedContainers.hasNext();) {
						GenAuditContainer nextNestedContainer = nestedContainers.next();
						moveNestedCategoriesToTheRoot(nextNestedContainer, root);
						nestedContainers.remove();
						root.getCategories().add(nextNestedContainer);
						nextNestedContainer.getPath().clear();
						nextNestedContainer.getPath().add(nextContainer);
					}
				}

				private void moveNestedAuditsToTheRoot(GenAuditContainer nextContainer, GenAuditRoot root) {
					for (Iterator<GenAuditRule> nestedAudits = nextContainer.getAudits().iterator(); nestedAudits.hasNext();) {
						GenAuditRule nextNestedRule = nestedAudits.next();
						nextNestedRule.setCategory(nextContainer);
						root.getRules().add(nextNestedRule);
					}
				}

				@@Override
				public boolean setAttribValue(MigrationHandler handler, EObject peekObject, String name, String value) {
					if (peekObject instanceof GenAuditRoot) {
						if ("id".equals(name)) { //$NON-NLS-1$
							getDefaultAuditContainer((GenAuditRoot) peekObject).setId(value);
							isAuditMigrationApplied = true;
							return true;
						} else if ("name".equals(name)) { //$NON-NLS-1$
							getDefaultAuditContainer((GenAuditRoot) peekObject).setName(value);
							isAuditMigrationApplied = true;
							return true;
						} else if ("description".equals(name)) { //$NON-NLS-1$
							getDefaultAuditContainer((GenAuditRoot) peekObject).setDescription(value);
							isAuditMigrationApplied = true;
							return true;
						}
					}
					return super.setAttribValue(handler, peekObject, name, value);
				}
				
				private GenAuditContainer getDefaultAuditContainer(GenAuditRoot root) {
					/*
					 * As we are mapping first audit category right into audit root,
					 * we should create some instance for that default category parameters
					 * also
					 */
					if (root.getCategories().isEmpty()) {
						root.getCategories().add(0, GMFGenFactory.eINSTANCE.createGenAuditContainer());
						isDefaultAuditCategoryAdded = true;
					}
					return root.getCategories().get(0);
				}

				@@Override
				protected boolean handleFeature(MigrationHandler handler, String prefix, String name) {
					EObject object = handler.peekEObject();
					if ("metaFeature".equals(name) && object instanceof FeatureLabelModelFacet) { //$NON-NLS-1$
						name = "metaFeatures"; //$NON-NLS-1$
						handler.handleFeatureHook(prefix, name);
						return true;
					}
					if ("audits".equals(name) && object instanceof GenAuditRoot) { //$NON-NLS-1$
						name = "rules"; //$NON-NLS-1$
						handler.handleFeatureHook(prefix, name);
						isAuditMigrationApplied = true;
						return true;
					}
					if ("childContainers".equals(name) && object instanceof GenAuditRoot) { //$NON-NLS-1$
						name = "categories"; //$NON-NLS-1$
						handler.handleFeatureHook(prefix, name);
						isAuditMigrationApplied = true;
						return true;
					}
					if ("childContainers".equals(name) && object instanceof GenAuditContainer) { //$NON-NLS-1$
						name = "path"; //$NON-NLS-1$
						handler.handleFeatureHook(prefix, name);
						isAuditMigrationApplied = true;
						return true;
					}
					return false;
				}

				@@Override
				protected boolean handleCreateObject(MigrationHandler handler, EObject peekObject, EStructuralFeature feature) {
					if ("gmfgen:CompositeFeatureLabelModelFacet".equals(handler.getXSIType())) { //$NON-NLS-1$
						handler.createObjectFromTypeNameHook(peekObject, "gmfgen:FeatureLabelModelFacet", feature); //$NON-NLS-1$
						return true;
					}
					return false;
				}

			};
			initialize(config);
			return config;
		}
	};

	static void initialize(MigrationConfig config) {
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getEditorCandies(), "diagramFileCreatorClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getEditorCandies(), "preferenceInitializerClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getFeatureLabelModelFacet(), "metaFeature"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getProviderClassNames(), "abstractParserClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getProviderClassNames(), "structuralFeatureParserClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getProviderClassNames(), "structuralFeaturesParserClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getProviderClassNames(), "paletteProviderClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getProviderClassNames(), "paletteProviderPriority"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getProviderClassNames(), "propertyProviderClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getProviderClassNames(), "propertyProviderPriority"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getEditPartCandies(), "referenceConnectionEditPolicyClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getEditPartCandies(), "externalNodeLabelHostLayoutEditPolicyClassName"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getTypeLinkModelFacet(), "createCommandClassName"); //$NON-NLS-1$
		// https://bugs.eclipse.org/bugs/show_bug.cgi?id=138440
		config.addNarrowReferenceType(GMFGenPackage.eINSTANCE.getGenFeatureSeqInitializer_Initializers(), GMFGenPackage.eINSTANCE.getGenFeatureValueSpec());
	}
}
@


1.12
log
@[185372] akarjakina - Migration of gmfgen 1.0 models with GenAuditContainer and GenAuditRule structures
@
text
@@


1.11
log
@refactor message format parser; introduce editor pattern
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
d10 1
d14 5
d21 1
d23 1
d25 4
d44 109
d156 2
a157 1
					if ("metaFeature".equals(name) && handler.peekEObject() instanceof FeatureLabelModelFacet) { //$NON-NLS-1$
d162 18
d191 1
@


1.10
log
@[181778] Generate standalone creation commands for reference based links
@
text
@d61 3
@


1.9
log
@define pref initializer class name and qualified class name in template
@
text
@d67 1
@


1.8
log
@remove unused edit policy name; add custom primary drag edit policy name
@
text
@d59 1
@


1.7
log
@[152717] - Do not generate *ReferenceConnectionEditPolicy
@
text
@d65 1
@


1.6
log
@removed stale attributes from gmfgen model.
migration resource eagerly treats any resource with newest nsURI as potential candidate for missed attributes
@
text
@d64 1
@


1.5
log
@remove unused diagram file creator class name attribute
@
text
@d60 4
@


1.4
log
@#161380 simplify feature model facets
@
text
@d58 1
@


1.3
log
@#161380 move readOnly back to GenLabel
@
text
@d13 3
d18 1
d26 1
a26 1
		public String getExtension() { 	
d29 1
a29 1
		
d31 21
a51 1
			MigrationConfig config = new MigrationConfig(GMFGenPackage.eNS_URI, new String[] { eNS_URI_1_0 });			
d56 1
a56 1
	
d58 1
d60 1
a60 4
		config.addNarrowReferenceType(
			GMFGenPackage.eINSTANCE.getGenFeatureSeqInitializer_Initializers(),
			GMFGenPackage.eINSTANCE.getGenFeatureValueSpec()
		);
@


1.2
log
@#160894 support readOnly attribute migration
@
text
@a12 5
import java.util.Iterator;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
a13 2
import org.eclipse.gmf.codegen.gmfgen.GenChildLabelNode;
import org.eclipse.gmf.codegen.gmfgen.GenLabel;
d16 1
a17 1
public class GMFGenMigration {
d21 1
d27 1
a27 26
			MigrationConfig config = new MigrationConfig(GMFGenPackage.eNS_URI, new String[] { eNS_URI_1_0 }) {

				protected void handleIgnoredAttributes(Resource resource, Map<EObject, Map<String, String>> ignoredAttributes) {
					for (Iterator it = resource.getAllContents(); it.hasNext();) {
						EObject next = (EObject) it.next();
						Map<String, String> attrs = ignoredAttributes.get(next);
						if (attrs == null) {
							continue;
						}
						if (next instanceof GenLabel) {
							GenLabel genLabel = (GenLabel) next;
							boolean readOnly = Boolean.valueOf(attrs.get("readOnly")); //$NON-NLS-1$
							if (genLabel.getModelFacet() != null && readOnly) {
								genLabel.getModelFacet().setReadOnly(readOnly);
							}
						}
						if (next instanceof GenChildLabelNode) {
							GenChildLabelNode genLabel = (GenChildLabelNode) next;
							boolean readOnly = Boolean.valueOf(attrs.get("labelReadOnly")); //$NON-NLS-1$
							if (genLabel.getLabelModelFacet() != null && readOnly) {
								genLabel.getLabelModelFacet().setReadOnly(readOnly);
							}
						}
					}
				}
			};			
a33 2
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getGenLabel(), "readOnly"); //$NON-NLS-1$
		config.registerDeletedAttribute(GMFGenPackage.eINSTANCE.getGenChildLabelNode(), "labelReadOnly"); //$NON-NLS-1$
@


1.1
log
@#138440 Modify Feature Sequence initializer to support containment references to model elements
- updating gmfgen
@
text
@d13 5
d19 2
d33 26
a58 1
			MigrationConfig config = new MigrationConfig(GMFGenPackage.eNS_URI, new String[] { eNS_URI_1_0 });			
d65 2
@

