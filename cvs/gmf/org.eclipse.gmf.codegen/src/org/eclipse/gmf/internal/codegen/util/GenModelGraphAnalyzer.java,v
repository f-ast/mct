head	1.2;
access;
symbols
	v20081022-1925:1.2
	v20081015-1925:1.2
	v20081008-1925:1.2
	v20081001-1925:1.2
	v20080930-1130:1.2
	v20080926-1245:1.2
	v20080924-1925:1.2
	v20080917-1925:1.2
	v20080911-1728:1.2
	v20080910-1520:1.2
	v20080903-1520:1.2
	v20080827-1520:1.2
	v20080813-1520:1.2
	v20080806-1520:1.2
	v20080722-1827:1.2
	v20080718-1731:1.2
	v20080716-1600:1.2
	v20080716-1642:1.2
	R2_1_maintenance:1.2.0.4
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080610-1132:1.2
	v20080603-1553:1.2
	v20080528-1052:1.2
	v20080521:1.2
	v20080516-1543:1.2
	v20080516-1143:1.2
	v20080512-1200:1.2
	v20080508-2000:1.2
	v20080507-1326:1.2
	v20080503-1740:1.2
	v20080501-1739:1.2
	v20080425-1959:1.2
	v20080417-1610:1.2
	v20080411-0411:1.2
	v20080404-1111:1.2
	v20080322-0000:1.2
	v20080222-1200:1.2
	v20080215-1500:1.2
	v20080207-0207:1.2
	v20071222-1111:1.2
	v20071214-1111:1.2
	v20071130-1111:1.2
	v20071124-0000:1.2
	v20071112-0000:1.2
	v20071108-0000:1.2
	v20071003-0000:1.2
	v20070928-0000:1.2
	v20070921-0000:1.2
	v20070915-0000:1.2
	v20070903-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	v20070621-0000:1.2
	RC3_20:1.2
	v20070614-1400:1.2
	v20070608-1300:1.2
	v20070605-1400:1.1
	v20070601-1400:1.1
	v20070525-1500:1.1
	v20070520-1200:1.1
	v20070518-1300:1.1
	v20070504-1000:1.1
	v20070427-0600:1.1
	v20070420-1000:1.1
	v20070413-1300:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.2
date	2007.06.06.16.13.30;	author ashatalin;	state Exp;
branches;
next	1.1;
commitid	5d1a4666dd2a4567;

1.1
date	2007.04.06.14.37.41;	author ashatalin;	state Exp;
branches;
next	;
commitid	5df46165b334567;


desc
@@


1.2
log
@[173891] - Diagram Code Generation gets stuck at NavigatorContentProvider class
@
text
@/**
 * Copyright (c) 2006 Borland Software Corp.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.codegen.util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
import org.eclipse.gmf.codegen.gmfgen.GenContainerBase;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenNavigator;
import org.eclipse.gmf.codegen.gmfgen.GenNavigatorChildReference;
import org.eclipse.gmf.codegen.gmfgen.GenNavigatorReferenceType;
import org.eclipse.gmf.codegen.gmfgen.GenNode;

public class GenModelGraphAnalyzer {

	/**
	 * @@deprecated
	 */
	public GenModelGraphAnalyzer(GenDiagram diagram) {
	}

	public static List<List<GenCommonBase>> getConnectionPaths(GenNavigatorChildReference reference) {
		assert reference.getParent() != null;
		if (reference.getReferenceType() == GenNavigatorReferenceType.CHILDREN_LITERAL) {
			return getChildConnectionPaths(reference.getParent(), reference.getChild(), reference.getNavigator());
		} else if (reference.getReferenceType() == GenNavigatorReferenceType.IN_SOURCE_LITERAL) {
			return getInSourceLinkConnectionPaths(reference.getParent(), reference.getChild(), reference.getNavigator());
		} else if (reference.getReferenceType() == GenNavigatorReferenceType.OUT_TARGET_LITERAL) {
			return getOutTargetLinkConnectionPaths(reference.getParent(), reference.getChild(), reference.getNavigator());
		}
		return Collections.emptyList();
	}

	private static List<List<GenCommonBase>> getOutTargetLinkConnectionPaths(GenCommonBase source, GenCommonBase target, GenNavigator genNavigator) {
		return new LinkedConnectionFinder(genNavigator, true).findConnectionPaths(source, target);
	}

	private static List<List<GenCommonBase>> getInSourceLinkConnectionPaths(GenCommonBase source, GenCommonBase target, GenNavigator genNavigator) {
		return new LinkedConnectionFinder(genNavigator, false).findConnectionPaths(source, target);
	}

	private static List<List<GenCommonBase>> getChildConnectionPaths(GenCommonBase source, GenCommonBase target, GenNavigator genNavigator) {
		return new ChildConnectionFinder(genNavigator).findConnectionPaths(source, target);
	}

	private static abstract class AbstractConnectionFinder {

		private Set<GenCommonBase> myVisiting;
		
		private GenNavigator myNavigator;

		public AbstractConnectionFinder(GenNavigator genNavigator) {
			myVisiting = new LinkedHashSet<GenCommonBase>();
			myNavigator = genNavigator;
		}

		protected abstract Collection<GenCommonBase> getConnectedNodes(GenCommonBase source);

		public List<List<GenCommonBase>> findConnectionPaths(GenCommonBase source, GenCommonBase target) {
			if (isConnectionFound(source, target)) {
				// Direct connection found
				List<GenCommonBase> path = new ArrayList<GenCommonBase>();
				path.add(target);
				List<List<GenCommonBase>> connections = new ArrayList<List<GenCommonBase>>();
				connections.add(path);
				return connections;
			}

			if (isVisiting(source) || stopIterating(source)) {
				// Loop found
				return new ArrayList<List<GenCommonBase>>();
			}
			startVisiting(source);
			try {
				// Looking for indirect connection + extending connection with
				// current node
				Collection<GenCommonBase> connectedNodes = getConnectedNodes(source);
				List<List<GenCommonBase>> connections = new ArrayList<List<GenCommonBase>>();

				for (GenCommonBase nextConnectedNode : connectedNodes) {
					connections.addAll(findConnectionPaths(nextConnectedNode, target));
				}

				for (List<GenCommonBase> path : connections) {
					path.add(0, source);
				}
				return connections;
			} finally {
				stopVisiting(source);
			}
		}

		private boolean stopIterating(GenCommonBase source) {
			if (myVisiting.size() > 0) {
				for (GenNavigatorChildReference nextReference : myNavigator.getChildReferences()) {
					if (nextReference.getParent() == source) {
						return true;
					}
				}				
			} 
			return false;
		}

		private boolean isVisiting(GenCommonBase node) {
			return myVisiting.contains(node);
		}

		private void startVisiting(GenCommonBase node) {
			myVisiting.add(node);
		}

		private void stopVisiting(GenCommonBase node) {
			myVisiting.remove(node);
		}

		protected Iterable<GenCommonBase> getPath() {
			return myVisiting;
		}

		/**
		 * myVisiting.size() > 0 checked return non-empty paths if source and
		 * target nodes are the same
		 */
		private boolean isConnectionFound(GenCommonBase source, GenCommonBase target) {
			return myVisiting.size() > 0 && source == target;
		}

	}

	private static class ChildConnectionFinder extends AbstractConnectionFinder {

		public ChildConnectionFinder(GenNavigator genNavigator) {
			super(genNavigator);
		}

		protected Collection<GenCommonBase> getConnectedNodes(GenCommonBase source) {
			Collection<GenCommonBase> children = new ArrayList<GenCommonBase>();
			if (source instanceof GenContainerBase) {
				children.addAll(((GenContainerBase) source).getContainedNodes());
			}
			if (source instanceof GenDiagram) {
				children.addAll(((GenDiagram) source).getLinks());
			}
			if (source instanceof GenNode) {
				children.addAll(((GenNode) source).getCompartments());
				children.addAll(((GenNode) source).getLabels());
			}
			if (source instanceof GenLink) {
				children.addAll(((GenLink) source).getLabels());
			}
			return children;
		}

	}

	private static class LinkedConnectionFinder extends AbstractConnectionFinder {

		private GenDiagram myDiagram;

		/**
		 * true: looking for the connection from source to target using all
		 * links in natural direction (outgoing links -> link target -> outgoing
		 * links...)
		 * 
		 * false: opposite direction (incomming links -> link source -> ..)
		 */
		private boolean myIsInLinkDirection;

		public LinkedConnectionFinder(GenNavigator genNavigator, boolean inLinkDirection) {
			super(genNavigator);
			myDiagram = genNavigator.getEditorGen().getDiagram();
			myIsInLinkDirection = inLinkDirection;
		}

		protected Collection<GenCommonBase> getConnectedNodes(GenCommonBase source) {
			if (source instanceof GenNode) {
				return getPotentiallyConnectedLinks((GenNode) source);
			} else if (source instanceof GenLink) {
				return getPotentiallyConnectedNodes((GenLink) source);
			}
			return Collections.emptyList();
		}

		private Collection<GenCommonBase> getPotentiallyConnectedLinks(GenNode node) {
			for (GenCommonBase nextPathElement : getPath()) {
				if (nextPathElement instanceof GenLink) {
					// Only one link allowed in the path
					return Collections.emptyList();
				}
			}
			// TODO: this method could be moved to GenNode
			Collection<GenCommonBase> potentialLinks = new ArrayList<GenCommonBase>();
			for (GenLink nextLink : myDiagram.getLinks()) {
				if (nextLink.getModelFacet() == null) {
					potentialLinks.add(nextLink);
				} else {
					GenClass genClass = myIsInLinkDirection ? nextLink.getModelFacet().getSourceType() : nextLink.getModelFacet().getTargetType();
					if (genClass != null && genClass.getEcoreClass().isSuperTypeOf(node.getDomainMetaClass().getEcoreClass())) {
						potentialLinks.add(nextLink);
					}
				}
			}
			return potentialLinks;
		}

		// TODO: this method could be moved to GenLink
		private Collection<GenCommonBase> getPotentiallyConnectedNodes(GenLink link) {
			Collection<GenCommonBase> potentialNodes = new ArrayList<GenCommonBase>();
			if (link.getModelFacet() == null) {
				potentialNodes.addAll(myDiagram.getAllNodes());
			} else {
				GenClass genClass = myIsInLinkDirection ? link.getModelFacet().getTargetType() : link.getModelFacet().getSourceType();
				if (genClass != null) {
					for (GenNode nextNode : myDiagram.getAllNodes()) {
						if (genClass.getEcoreClass().isSuperTypeOf(nextNode.getDomainMetaClass().getEcoreClass())) {
							potentialNodes.add(nextNode);
						}
					}
				}
			}
			return potentialNodes;
		}

	}

}
@


1.1
log
@Moving non-open API classes from org.eclipse.gmf.codegen.util to org.eclipse.gmf.internal.codegen.util package.
@
text
@d26 1
d42 1
a42 1
			return getChildConnectionPaths(reference.getParent(), reference.getChild());
d44 1
a44 1
			return getInSourceLinkConnectionPaths(reference.getParent(), reference.getChild(), reference.getNavigator().getEditorGen().getDiagram());
d46 1
a46 1
			return getOutTargetLinkConnectionPaths(reference.getParent(), reference.getChild(), reference.getNavigator().getEditorGen().getDiagram());
d51 2
a52 2
	private static List<List<GenCommonBase>> getOutTargetLinkConnectionPaths(GenCommonBase source, GenCommonBase target, GenDiagram diagram) {
		return new LinkedConnectionFinder(diagram, true).findConnectionPaths(source, target);
d55 2
a56 2
	private static List<List<GenCommonBase>> getInSourceLinkConnectionPaths(GenCommonBase source, GenCommonBase target, GenDiagram diagram) {
		return new LinkedConnectionFinder(diagram, false).findConnectionPaths(source, target);
d59 2
a60 2
	private static List<List<GenCommonBase>> getChildConnectionPaths(GenCommonBase source, GenCommonBase target) {
		return new ChildConnectionFinder().findConnectionPaths(source, target);
d66 2
d69 1
a69 1
		public AbstractConnectionFinder() {
d71 1
d86 1
a86 1
			if (isVisiting(source)) {
d110 11
d149 4
d186 3
a188 2
		public LinkedConnectionFinder(GenDiagram diagram, boolean inLinkDirection) {
			myDiagram = diagram;
@

