head	1.27;
access;
symbols
	v20081022-1925:1.27
	v20081015-1925:1.27
	v20081008-1925:1.27
	v20081001-1925:1.27
	v20080924-1925:1.27
	v20080917-1925:1.27
	v20080911-1728:1.27
	v20080910-1520:1.27
	v20080903-1520:1.27
	v20080827-1520:1.27
	v20080813-1520:1.27
	v20080806-1520:1.27
	v20070427-0600:1.26
	v20070420-1000:1.26
	v20070413-1300:1.26
	v20070405-1100:1.26
	v20070403-1500:1.26
	v20070330-1300:1.26
	v20060330-1300:1.26
	v20070322-1100:1.26
	v20060316-0600:1.26
	v20070307-0700:1.26
	v20070301-1200:1.26
	v20070228-2000:1.26
	v20070221-1500:1.26
	v20070208-1800:1.26
	v20070202-0200:1.24
	v20070103-0300:1.26
	M4_20:1.26
	v20061222-1800:1.26
	v20061218-1200:1.26
	v20061214-0000:1.26
	v20061120-1300:1.26
	M3_20:1.26
	v20061117-0800:1.26
	v20061027-1200:1.24
	v20061020-1000:1.24
	v20061013-1330:1.25
	v20060919-0800:1.24
	v20060907-1100:1.24
	M1_20:1.24
	v20060904-1500:1.24
	v20060824-1600:1.24
	v20060817-1500:1.24
	v20060728-0500:1.24
	v20060713-1700:1.24
	R1_0_maintenance:1.24.0.2
	R1_0:1.24
	v20060627-1200:1.24
	v20060626-1420:1.24
	v20060620-0400:1.24
	v20060616-1400:1.24
	v20060616-1200:1.24
	v20060609-1400:1.24
	v20060531-1730:1.21
	v20060530-1930:1.21
	v20060526-1200:1.21
	v20060519-1300:1.21
	v20060519-0800:1.21
	v20060512-1000:1.19
	I20060512-1000:1.19
	I20060505-1400:1.18
	I20060428-1300:1.18
	I20060424-0500:1.18
	I20060424-0300:1.18
	M6_10:1.16
	I20060407-1200:1.14
	I20060331-1000:1.14
	I20060324-0300:1.14
	I20060317-1300:1.14
	I20060317-1200:1.14
	I20060316-1300:1.14
	I20060309-1300:1.14
	M5_10:1.12
	S20060303-1600:1.12
	I20060227-1730:1.11
	I20060216-1945:1.11
	I20060210-1715:1.9
	I20060209-1815:1.9
	I20060203-0830:1.2
	I20060202-1415:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.27
date	2007.04.27.11.00.33;	author dstadnik;	state dead;
branches;
next	1.26;
commitid	23d34631d7d04567;

1.26
date	2006.10.18.14.21.46;	author dstadnik;	state Exp;
branches;
next	1.25;

1.25
date	2006.09.22.17.45.46;	author atikhomirov;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.09.12.31.18;	author dstadnik;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.07.09.29.01;	author dstadnik;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.01.09.40.47;	author dstadnik;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.15.17.11.53;	author ashatalin;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.10.11.13.14;	author dstadnik;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.20.21.24.27;	author ashatalin;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.20.20.37.15;	author ashatalin;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.13.12.39.59;	author ashatalin;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.12.01.16.49;	author ashatalin;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.07.14.09.19;	author dstadnik;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.03.09.05.59;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.15.13.27.40;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.14.13.06.38;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.09.16.16.00;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.06.13.14.41;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.06.11.52.36;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.06.11.00.20;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.03.12.38.15;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.02.15.58.54;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.27
log
@rewrite ParserProvider in xpand
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.providers" class="ParserProviderGenerator"
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.gmf.runtime.common.core.service.AbstractProvider;
import org.eclipse.gmf.runtime.common.core.service.IOperation;
import org.eclipse.gmf.runtime.common.ui.services.parser.GetParserOperation;
import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;
import org.eclipse.gmf.runtime.common.ui.services.parser.IParserProvider;
import org.eclipse.gmf.runtime.notation.View;
<%importManager.markImportLocation(stringBuffer);%>

/**
 * @@generated
 */
public class <%=genDiagram.getParserProviderClassName()%> extends AbstractProvider implements IParserProvider {
<%
Map labelMethodNames = new LinkedHashMap(); // GenCommonBase -> String
for (Iterator contents = genDiagram.eAllContents(); contents.hasNext(); ) {
	Object next = contents.next();
	GenCommonBase genHost, genLabel;
	LabelModelFacet modelFacet;
	if (next instanceof GenLabel) {
		genLabel = (GenCommonBase) next;
		if (genLabel instanceof GenNodeLabel) {
			genHost = ((GenNodeLabel) genLabel).getNode();
		} else if (genLabel instanceof GenLinkLabel) {
			genHost = ((GenLinkLabel) genLabel).getLink();
		} else {
			throw new IllegalArgumentException("Unknown label type: " + genLabel);
		}
		modelFacet = ((GenLabel) genLabel).getModelFacet();
	} else if (next instanceof GenChildLabelNode) {
		genLabel = (GenCommonBase) next;
		genHost = genLabel;
		modelFacet = ((GenChildLabelNode) genLabel).getLabelModelFacet();
	} else {
		continue; // not a label
	}
	if (!(modelFacet instanceof FeatureLabelModelFacet)) {
		continue; // custom parser
	}
	String baseName = genLabel.getUniqueIdentifier();
	if (genHost.getClassNamePrefix() != null && genHost.getClassNamePrefix().length() > 0) {
		baseName = genHost.getClassNamePrefix() + baseName;
	}
	char c = baseName.charAt(0);
	baseName = baseName.substring(1) + "Parser";
	String fieldName = Character.toLowerCase(c) + baseName;
	String methodName = Character.toUpperCase(c) + baseName;
	labelMethodNames.put(genLabel, methodName);
%>

	/**
	 * @@generated
	 */
	private IParser <%=fieldName%>;

	/**
	 * @@generated
	 */
	private IParser get<%=methodName%>() {
		if (<%=fieldName%> == null) {
			<%=fieldName%> = create<%=methodName%>();
		}
		return <%=fieldName%>;
	}

	/**
	 * @@generated
	 */
	protected IParser create<%=methodName%>() {
<%
		String parserClassName;
		String viewPattern = ((FeatureLabelModelFacet) modelFacet).getViewPattern();
		String editPattern = ((FeatureLabelModelFacet) modelFacet).getEditPattern();
		List<GenFeature> features = ((FeatureLabelModelFacet) modelFacet).getMetaFeatures();
		if (features.size() == 1) {
			parserClassName = importManager.getImportedName(genDiagram.getStructuralFeatureParserQualifiedClassName());
			GenFeature genFeature = features.get(0);
			String semanticPackageInterfaceName = importManager.getImportedName(genFeature.getGenPackage().getQualifiedPackageInterfaceName());
%>
		<%=parserClassName%> parser = new <%=parserClassName%>(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genFeature.getFeatureAccessorName()%>());
<%
		} else {
			parserClassName = importManager.getImportedName(genDiagram.getStructuralFeaturesParserQualifiedClassName());
%>
		<%=importManager.getImportedName("java.util.List")%> features = new <%=importManager.getImportedName("java.util.ArrayList")%>(<%=features.size()%>);
<%
			for (GenFeature genFeature : features) {
				String semanticPackageInterfaceName = importManager.getImportedName(genFeature.getGenPackage().getQualifiedPackageInterfaceName());
%>
		features.add(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genFeature.getFeatureAccessorName()%>());
<%			}%>
		<%=parserClassName%> parser = new <%=parserClassName%>(features);
<%
		}
		if (viewPattern != null && viewPattern.length() != 0) {
%>
		parser.setViewPattern("<%=viewPattern%>");
<%
		}
		if (editPattern == null || editPattern.length() == 0) {
			editPattern = viewPattern;
		}
		if (editPattern != null && editPattern.length() != 0) {
%>
		parser.setEditPattern("<%=editPattern%>");
<%		}%>
		return parser;
	}
<%}%>

	/**
	 * @@generated
	 */
	protected IParser getParser(int visualID) {
		switch (visualID) {
<%
for (Iterator it = labelMethodNames.keySet().iterator(); it.hasNext(); ) {
	GenCommonBase genLabel = (GenCommonBase) it.next();
%>
			case <%=importManager.getImportedName(genLabel.getEditPartQualifiedClassName())%>.VISUAL_ID:
				return get<%=labelMethodNames.get(genLabel)%>();
<%}%>
		}
		return null;
	}

	/**
	 * @@generated
	 */
	public IParser getParser(IAdaptable hint) {
		String vid = (String) hint.getAdapter(String.class);
		if (vid != null) {
			return getParser(<%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getVisualID(vid));
		}
		View view = (View) hint.getAdapter(View.class);
		if (view != null) {
			return getParser(<%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getVisualID(view));
		}
		return null;
	}

	/**
	 * @@generated
	 */
	public boolean provides(IOperation operation) {
		if (operation instanceof GetParserOperation) {
			IAdaptable hint = ((GetParserOperation) operation).getHint();
			if (<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.getElement(hint) == null) {
				return false;
			}
			return getParser(hint) != null;
		}
		return false;
	}
}
<%importManager.emitSortedImports();%>
@


1.26
log
@#161380 simplify feature model facets
@
text
@@


1.25
log
@do not use strings to obtain meta features
@
text
@d46 1
a46 1
	if (modelFacet == null || modelFacet instanceof DesignLabelModelFacet) {
d81 4
a84 3
		String viewPattern;
		String editPattern;
		if (modelFacet instanceof FeatureLabelModelFacet) {
d86 1
a86 3
			GenFeature genFeature = ((FeatureLabelModelFacet) modelFacet).getMetaFeature();
			viewPattern = ((FeatureLabelModelFacet) modelFacet).getViewPattern();
			editPattern = ((FeatureLabelModelFacet) modelFacet).getEditPattern();
d91 1
a91 1
		} else if (modelFacet instanceof CompositeFeatureLabelModelFacet) {
a92 3
			List features = ((CompositeFeatureLabelModelFacet) modelFacet).getMetaFeatures();
			viewPattern = ((CompositeFeatureLabelModelFacet) modelFacet).getViewPattern();
			editPattern = ((CompositeFeatureLabelModelFacet) modelFacet).getEditPattern();
d96 1
a96 2
			for (java.util.Iterator it = features.iterator(); it.hasNext(); ) {
				GenFeature genFeature = (GenFeature) it.next();
a102 2
		} else {
			throw new IllegalArgumentException("Unknown label model facet: " + modelFacet);
@


1.24
log
@#144683 It should be possible to modify label value on pure design diagram
@
text
@d90 1
a90 1
		<%=parserClassName%> parser = new <%=parserClassName%>(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genFeature.getGenClass().getClassifierAccessorName()%>().getEStructuralFeature("<%=genFeature.getName()%>")); //$NON-NLS-1$
d104 1
a104 1
		features.add(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genFeature.getGenClass().getClassifierAccessorName()%>().getEStructuralFeature("<%=genFeature.getName()%>")); //$NON-NLS-1$
@


1.23
log
@provide Node/Link/Label/Diagram class prefix instead of Unknown for elements without model facet; add extra empty values checks
@
text
@d46 1
a46 1
	if (modelFacet == null) {
@


1.22
log
@fix some nls markers
@
text
@d49 4
a52 1
	String baseName = genHost.getClassNamePrefix() + genLabel.getUniqueIdentifier();
@


1.21
log
@use importAssistant to emit package statement instead of handcoding
@
text
@d87 1
a87 1
		<%=parserClassName%> parser = new <%=parserClassName%>(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genFeature.getGenClass().getClassifierAccessorName()%>().getEStructuralFeature("<%=genFeature.getName()%>"));
d101 1
a101 1
		features.add(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genFeature.getGenClass().getClassifierAccessorName()%>().getEStructuralFeature("<%=genFeature.getName()%>"));
@


1.20
log
@#139843 Unable to parse view type as a visualID number
@
text
@d3 4
a6 1
<%GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];%>
d8 1
a8 1
package <%=genDiagram.getProvidersPackageName()%>;
a9 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getProvidersPackageName());%>
@


1.19
log
@#133836 Creating a child node without a label causes error
@
text
@d158 5
a162 1
			return getParser(((GetParserOperation) operation).getHint()) != null;
@


1.18
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@a8 1
import org.eclipse.emf.ecore.EObject;
d14 1
a14 2
import org.eclipse.gmf.runtime.emf.type.core.ElementTypeRegistry;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
d22 1
a22 2
Map labels = new LinkedHashMap(); // Gen[Node|Link] -> List : GenLabel
Map labelMethodNames = new HashMap(); // GenLabel -> String
d25 2
d28 1
a28 2
		GenLabel genLabel = (GenLabel) next;
		GenCommonBase genHost;
d36 17
a52 16
		LabelModelFacet modelFacet = genLabel.getModelFacet();
		if (modelFacet == null) {
			continue; // custom parser
		}
		List labelsList = (List) labels.get(genHost);
		if (labelsList == null) {
			labelsList = new ArrayList();
			labels.put(genHost, labelsList);
		}
		labelsList.add(genLabel);
		String baseName = genHost.getClassNamePrefix() + genLabel.getUniqueIdentifier();
		char c = baseName.charAt(0);
		baseName = baseName.substring(1) + "Parser";
		String fieldName = Character.toLowerCase(c) + baseName;
		String methodName = Character.toUpperCase(c) + baseName;
		labelMethodNames.put(genLabel, methodName);
d120 1
a120 4
<%
	}
}
%>
d125 2
a126 1
	protected IParser getParser(IElementType type, int visualID) {
d128 4
a131 22
for (Iterator it1 = labels.keySet().iterator(); it1.hasNext(); ) {
	GenCommonBase genHost = (GenCommonBase) it1.next();
	List labelsList = (List) labels.get(genHost);
%>
		if (<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genHost.getUniqueIdentifier()%> == type) {
<%
	if (genHost instanceof GenChildNode && ((GenChildNode) genHost).isListContainerEntry()) {
		GenLabel genLabel = (GenLabel) labelsList.get(0);
%>
			return get<%=labelMethodNames.get(genLabel)%>();
<%	} else {%>
<%		boolean generateSwitch = labelsList.size() > 1;
		if (generateSwitch) {%>
			switch (visualID) {
<%		}
		for (Iterator it2 = labelsList.iterator(); it2.hasNext(); ) {
			GenLabel genLabel = (GenLabel) it2.next();
			if (generateSwitch) {%>
			case <%=importManager.getImportedName(genLabel.getEditPartQualifiedClassName())%>.VISUAL_ID: {
<%			} else {%>
			if (<%=importManager.getImportedName(genLabel.getEditPartQualifiedClassName())%>.VISUAL_ID == visualID) {
<%			}%>
d133 1
a133 6
			}
<%		}
		if (generateSwitch) {%>
			}
<%		}
	}%>
a134 1
<%}%>
d142 7
a148 5
		int visualID = <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getVisualID((String) hint.getAdapter(String.class));
		IElementType type = (IElementType) hint.getAdapter(IElementType.class);
		if (type == null) {
			EObject element = (EObject) hint.getAdapter(EObject.class);
			type = ElementTypeRegistry.getInstance().getElementType(element);
d150 1
a150 1
		return getParser(type, visualID);
@


1.17
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@d129 1
a129 1
	protected IParser getParser(IElementType type, String viewType) {
d141 5
a145 2
<%
	} else {
d148 5
a152 2
%>
			if (<%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getType(<%=importManager.getImportedName(genLabel.getEditPartQualifiedClassName())%>.VISUAL_ID).equals(viewType)) {
d155 5
a159 4
<%
		}
	}
%>
d169 1
a169 1
		String viewType = (String) hint.getAdapter(String.class);
d175 1
a175 1
		return getParser(type, viewType);
@


1.16
log
@#125900 Redundant annotations added to View in generated view factory

semantic hint class name plroperty removed from the model.
@
text
@d146 1
a146 1
			if (<%=importManager.getImportedName(genLabel.getEditPartQualifiedClassName())%>.VISUAL_ID.equals(viewType)) {
@


1.15
log
@#125900 Redundant annotations added to View in generated view factory

Visual ID used as a semantic hint for creation of all the diagram elements.
@
text
@d48 1
a48 1
		String baseName = genHost.getClassNamePrefix() + genLabel.getSemanticHintFieldName();
@


1.14
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d146 1
a146 1
			if (<%=importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName())%>.<%=genHost.getUniqueIdentifier()%>Labels.<%=genLabel.getSemanticHintFieldName()%>.equals(viewType)) {
@


1.13
log
@#130715 Use default label text defined in gmfgraph model
@
text
@d4 1
@


1.12
log
@Acquire GenClass accessor name from GenFeature instead of host element in genmodel
@
text
@d38 1
a38 1
		if (modelFacet == null || modelFacet instanceof TextLabelModelFacet) {
@


1.11
log
@get editing domain from eobject
@
text
@a29 1
		String accessorName;
a31 1
			accessorName = ((GenNode) genHost).getDomainMetaClass().getClassifierAccessorName();
a33 6
			LinkModelFacet linkModelFacet = ((GenLink) genHost).getModelFacet();
			if (linkModelFacet instanceof TypeLinkModelFacet) {
				accessorName = ((TypeLinkModelFacet) linkModelFacet).getMetaClass().getClassifierAccessorName();
			} else {
				accessorName = ((FeatureModelFacet) linkModelFacet).getMetaFeature().getGenClass().getClassifierAccessorName();
			}
d80 1
a80 1
			String featureName = ((FeatureLabelModelFacet) modelFacet).getMetaFeature().getName();
d83 1
a83 1
			String semanticPackageInterfaceName = importManager.getImportedName(((FeatureLabelModelFacet) modelFacet).getMetaFeature().getGenPackage().getQualifiedPackageInterfaceName());
d85 1
a85 1
		<%=parserClassName%> parser = new <%=parserClassName%>(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=accessorName%>().getEStructuralFeature("<%=featureName%>"));
d96 2
a97 3
				GenFeature nextGenFeature = (GenFeature) it.next(); 
				String featureName = nextGenFeature.getName();
				String semanticPackageInterfaceName = importManager.getImportedName(nextGenFeature.getGenPackage().getQualifiedPackageInterfaceName());
d99 1
a99 1
		features.add(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=accessorName%>().getEStructuralFeature("<%=featureName%>"));
@


1.10
log
@use new transactional emf api
@
text
@a6 3
import java.util.Map;
import java.util.WeakHashMap;

a8 1
import org.eclipse.emf.transaction.TransactionalEditingDomain;
d58 1
a58 1
		String fieldName = Character.toLowerCase(c) + baseName + 's';
d66 1
a66 1
	private Map <%=fieldName%>;
d71 1
a71 1
	private IParser get<%=methodName%>(TransactionalEditingDomain editingDomain) {
d73 1
a73 6
			<%=fieldName%> = new WeakHashMap();
		}
		IParser parser = (IParser) <%=fieldName%>.get(editingDomain);
		if (parser == null) {
			parser = create<%=methodName%>(editingDomain);
			<%=fieldName%>.put(editingDomain, parser);
d75 1
a75 1
		return parser;
d81 1
a81 1
	protected IParser create<%=methodName%>(TransactionalEditingDomain editingDomain) {
a126 1
		parser.setEditingDomain(editingDomain);
d137 1
a137 1
	protected IParser getParser(IElementType type, String viewType, TransactionalEditingDomain editingDomain) {
d148 1
a148 1
			return get<%=labelMethodNames.get(genLabel)%>(editingDomain);
d155 1
a155 1
				return get<%=labelMethodNames.get(genLabel)%>(editingDomain);
d176 1
a176 2
		TransactionalEditingDomain editingDomain = (TransactionalEditingDomain) hint.getAdapter(TransactionalEditingDomain.class);
		return getParser(type, viewType, editingDomain);
@


1.9
log
@Updating with new transaction API.
@
text
@d7 3
d12 1
d62 1
a62 1
		String fieldName = Character.toLowerCase(c) + baseName;
d70 1
a70 1
	private IParser <%=fieldName%>;
d75 1
a75 1
	private IParser get<%=methodName%>() {
d77 6
a82 1
			<%=fieldName%> = create<%=methodName%>();
d84 1
a84 1
		return <%=fieldName%>;
d90 1
a90 1
	protected IParser create<%=methodName%>() {
d136 1
d147 1
a147 1
	protected IParser getParser(IElementType type, String viewType) {
d158 1
a158 1
			return get<%=labelMethodNames.get(genLabel)%>();
d165 1
a165 1
				return get<%=labelMethodNames.get(genLabel)%>();
d186 2
a187 1
		return getParser(type, viewType);
d195 1
a195 8
			IAdaptable hint = ((GetParserOperation) operation).getHint();
			String viewType = (String) hint.getAdapter(String.class);
			IElementType type = (IElementType) hint.getAdapter(IElementType.class);
			if (type == null) {
				EObject element = (EObject) hint.getAdapter(EObject.class);
				type = ElementTypeRegistry.getInstance().getElementType(element);
			}
			return getParser(type, viewType) != null;
@


1.8
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d137 1
a137 2
	protected IParser getParser(EObject element, String viewType) {
		IElementType type = ElementTypeRegistry.getInstance().getElementType(element);
d171 6
a176 2
		EObject element = (EObject) hint.getAdapter(EObject.class);
		return getParser(element, viewType);
d186 6
a191 2
			EObject element = (EObject) hint.getAdapter(EObject.class);
			return getParser(element, viewType) != null;
@


1.7
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d3 1
a3 1
<%GenDiagram genDiagram = (GenDiagram) argument;%>
@


1.6
log
@#126541 Support features with enumeration-based types for label model facets
@
text
@a24 1
String semanticPackageInterfaceName = importManager.getImportedName(genDiagram.getDomainMetaModel().getQualifiedPackageInterfaceName());
d91 1
d104 3
a106 1
				String featureName = ((GenFeature) it.next()).getName();
@


1.5
log
@#126537
Possibility to visualize child-parent relachipchip as a link implemented
@
text
@d115 1
a115 1
		((<%=parserClassName%>) parser).setViewPattern("<%=viewPattern%>");
d123 1
a123 1
		((<%=parserClassName%>) parser).setEditPattern("<%=editPattern%>");
@


1.4
log
@#126533 It should be possible to specify a label with fixed text in gmfgen model
@
text
@a6 3
import java.util.ArrayList;
import java.util.List;

d97 1
a97 1
			java.util.List features = ((CompositeFeatureLabelModelFacet) modelFacet).getMetaFeatures();
@


1.3
log
@ImportManager moved to oeg.common
@
text
@d50 1
a50 1
		if (modelFacet == null) {
@


1.2
log
@refactor feature model facet; use distinct feature-based model facets for links and labels
@
text
@d2 1
a2 1
	imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
@


1.1
log
@#125828 Generated code is bypassing parser service...
@
text
@d47 1
a47 1
			continue;
d50 3
d88 3
a90 1
		if (modelFacet instanceof FeatureModelFacet) {
d92 3
a94 1
			String featureName = ((FeatureModelFacet) modelFacet).getMetaFeature().getName();
d98 1
a98 1
		} else if (modelFacet instanceof CompositeFeatureModelFacet) {
d100 3
a102 1
			java.util.List features = ((CompositeFeatureModelFacet) modelFacet).getMetaFeatures();
d114 1
a114 1
			throw new IllegalArgumentException();
d116 1
a116 1
		if (modelFacet.getViewPattern() != null && modelFacet.getViewPattern().length() != 0) {
d118 1
a118 1
		((<%=parserClassName%>) parser).setViewPattern("<%=modelFacet.getViewPattern()%>");
d121 4
a124 1
		if (modelFacet.getEditPattern() != null && modelFacet.getEditPattern().length() != 0) {
d126 1
a126 1
		((<%=parserClassName%>) parser).setEditPattern("<%=modelFacet.getEditPattern()%>");
@

