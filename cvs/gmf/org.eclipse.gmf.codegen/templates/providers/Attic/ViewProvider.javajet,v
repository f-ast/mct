head	1.52;
access;
symbols
	v20081022-1925:1.52
	v20081015-1925:1.52
	v20081008-1925:1.52
	v20081001-1925:1.52
	v20080924-1925:1.52
	v20080917-1925:1.52
	v20080911-1728:1.52
	v20080910-1520:1.52
	v20080903-1520:1.52
	v20080827-1520:1.52
	v20080813-1520:1.52
	v20080806-1520:1.52
	v20070525-1500:1.51
	v20070520-1200:1.51
	v20070518-1300:1.51
	v20070504-1000:1.51
	v20070427-0600:1.51
	v20070420-1000:1.51
	v20070413-1300:1.51
	v20070405-1100:1.51
	v20070403-1500:1.51
	v20070330-1300:1.51
	v20060330-1300:1.51
	v20070322-1100:1.51
	v20060316-0600:1.51
	v20070307-0700:1.51
	v20070301-1200:1.51
	v20070228-2000:1.51
	v20070221-1500:1.51
	v20070208-1800:1.51
	v20070202-0200:1.50
	v20070103-0300:1.51
	M4_20:1.51
	v20061222-1800:1.51
	v20061218-1200:1.51
	v20061214-0000:1.51
	v20061120-1300:1.51
	M3_20:1.51
	v20061117-0800:1.51
	v20061027-1200:1.50
	v20061020-1000:1.50
	v20061013-1330:1.50
	v20060919-0800:1.50
	v20060907-1100:1.50
	M1_20:1.50
	v20060904-1500:1.50
	v20060824-1600:1.50
	v20060817-1500:1.50
	v20060728-0500:1.50
	v20060713-1700:1.50
	R1_0_maintenance:1.50.0.2
	R1_0:1.50
	v20060627-1200:1.50
	v20060626-1420:1.50
	v20060620-0400:1.50
	v20060616-1400:1.50
	v20060616-1200:1.50
	v20060609-1400:1.50
	v20060531-1730:1.50
	v20060530-1930:1.50
	v20060526-1200:1.49
	v20060519-1300:1.47
	v20060519-0800:1.46
	v20060512-1000:1.44
	I20060512-1000:1.44
	I20060505-1400:1.43
	I20060428-1300:1.43
	I20060424-0500:1.42
	I20060424-0300:1.42
	M6_10:1.40
	I20060407-1200:1.39
	I20060331-1000:1.39
	I20060324-0300:1.39
	I20060317-1300:1.39
	I20060317-1200:1.39
	I20060316-1300:1.39
	I20060309-1300:1.38
	M5_10:1.37
	S20060303-1600:1.37
	I20060227-1730:1.35
	I20060216-1945:1.34
	I20060210-1715:1.34
	I20060209-1815:1.34
	I20060203-0830:1.30
	I20060202-1415:1.30
	I20060129-1145:1.30
	I20060127-0900:1.30
	I20060120-1530:1.29
	I20060113-1700:1.27
	M4_10:1.27
	I20060107-1100:1.25
	I20060105-1630:1.25
	I20051230-1230:1.25
	I20051223-1100:1.25
	I20051217-0925:1.24
	I20051208-2000:1.24
	I20051201-1800:1.24
	I20051124-2000:1.23
	M3_10:1.23
	I20051118-1245:1.23
	I20051111-1800:1.19
	I20051106-0900:1.18
	v20051030:1.15;
locks; strict;
comment	@# @;
expand	@k@;


1.52
date	2007.05.28.16.52.23;	author ashatalin;	state dead;
branches;
next	1.51;
commitid	51cb465b08c54567;

1.51
date	2006.10.18.14.21.46;	author dstadnik;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.30.10.30.30;	author ashatalin;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.25.10.17.10;	author dstadnik;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.25.09.35.12;	author dstadnik;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.19.13.30.31;	author dstadnik;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.15.17.11.53;	author ashatalin;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.10.11.13.14;	author dstadnik;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.26.11.00.56;	author ashatalin;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.21.17.11.59;	author ashatalin;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.20.20.37.15;	author ashatalin;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.13.22.22.22;	author ashatalin;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.13.11.02.29;	author dstadnik;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.03.13.22.36;	author dstadnik;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.02.12.52.48;	author dstadnik;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.17.12.31.43;	author ashatalin;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.33;

1.33
date	2006.02.08.12.28.12;	author atikhomirov;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.24.12.01.20;	author dstadnik;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.19.17.33.04;	author ashatalin;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.19.00.10.43;	author ashatalin;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.12.17.19.23;	author ashatalin;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.12.10.41.33;	author dstadnik;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.20.18.00.01;	author ashatalin;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.28.17.48.39;	author ashatalin;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.18.13.55.33;	author ashatalin;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.17.12.38.37;	author ashatalin;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.17.09.14.15;	author dstadnik;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.16.07.42.23;	author dstadnik;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.11.13.47.42;	author dstadnik;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.04.14.56.41;	author atikhomirov;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.04.13.28.37;	author atikhomirov;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.02.17.53.03;	author atikhomirov;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.27.16.12.20;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.24.14.58.45;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.21.13.31.56;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.19.13.19.22;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.18.11.09.13;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.14.12.17.18;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.13.14.21.40;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.13.12.45.56;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.11.12.50.57;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.10.12.57.39;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.07.13.28.03;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.06.16.03.15;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.04.13.18.07;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.30.19.16.05;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.29.09.49.41;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.52
log
@- ViewProvider is in xpand now.
- Separating semantic part of VisualIDRegistry from pure-notation.
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.providers" class="ViewProviderGenerator"
    imports="java.util.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
<%
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
List genLinks = genDiagram.getLinks();
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.gmf.runtime.diagram.core.providers.AbstractViewProvider;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
<%importManager.markImportLocation(stringBuffer);%>

/**
 * @@generated
 */
public class <%=genDiagram.getNotationViewProviderClassName()%> extends AbstractViewProvider {

	/**
	 * @@generated
	 */
	protected Class getDiagramViewClass(IAdaptable semanticAdapter, String diagramKind) {
<%if (genDiagram.getDomainDiagramElement() != null) {%>
		EObject semanticElement = getSemanticElement(semanticAdapter);
<%}%>
		if (<%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.MODEL_ID.equals(diagramKind)
<%if (genDiagram.getDomainDiagramElement() != null) {%>
				&& <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getDiagramVisualID(semanticElement) != -1
<%}%>
				) {
			return <%=importManager.getImportedName(genDiagram.getNotationViewFactoryQualifiedClassName())%>.class;
		}
		return null;
	}

	/**
	 * @@generated
	 */
	protected Class getNodeViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
		if (containerView == null) {
			return null;
		}
		IElementType elementType = getSemanticElementType(semanticAdapter);
		if (elementType != null && !<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.isKnownElementType(elementType)) {
			return null;
		}
		EClass semanticType = getSemanticEClass(semanticAdapter);
		EObject semanticElement = getSemanticElement(semanticAdapter);
		int nodeVID = <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getNodeVisualID(containerView, semanticElement, semanticType, semanticHint);
		switch (nodeVID) {
<%
for (Iterator containers = genDiagram.getAllChildContainers().iterator(); containers.hasNext();) {
	GenContainerBase container = (GenContainerBase) containers.next();
%>
		case <%=importManager.getImportedName(container.getEditPartQualifiedClassName())%>.VISUAL_ID:
			 return <%=importManager.getImportedName(container.getNotationViewFactoryQualifiedClassName())%>.class;
<%
	if (container instanceof GenNode) {
		GenNode node = (GenNode) container;
		for (Iterator labels = node.getLabels().iterator(); labels.hasNext();) {
			GenNodeLabel label = (GenNodeLabel) labels.next();
%>
		case <%=importManager.getImportedName(label.getEditPartQualifiedClassName())%>.VISUAL_ID:
			return <%=importManager.getImportedName(label.getNotationViewFactoryQualifiedClassName())%>.class;
<%
		}
	}
}
for (Iterator links = genLinks.iterator(); links.hasNext();) {
	GenLink link = (GenLink) links.next();
	for (Iterator linkLabels = link.getLabels().iterator(); linkLabels.hasNext();) {
		GenLinkLabel linkLabel = (GenLinkLabel) linkLabels.next();
%>
		case <%=importManager.getImportedName(linkLabel.getEditPartQualifiedClassName())%>.VISUAL_ID:
			return <%=importManager.getImportedName(linkLabel.getNotationViewFactoryQualifiedClassName())%>.class;
<%
	}
}
%>
		}
		return null;
	}

	/**
	 * @@generated
	 */
	protected Class getEdgeViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
		IElementType elementType = getSemanticElementType(semanticAdapter);
		if (elementType != null && !<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.isKnownElementType(elementType)) {
			return null;
		}
<%
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink.getModelFacet() instanceof FeatureLinkModelFacet || genLink.getModelFacet() == null) {
%>
		if (<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genLink.getUniqueIdentifier()%>.equals(elementType)) {
			return <%=importManager.getImportedName(genLink.getNotationViewFactoryQualifiedClassName())%>.class;
		}
<%
	}
}
%>
		EClass semanticType = getSemanticEClass(semanticAdapter);
		if (semanticType == null) {
			return null;
		}
		EObject semanticElement = getSemanticElement(semanticAdapter);
		int linkVID = <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getLinkWithClassVisualID(semanticElement, semanticType);
		switch (linkVID) {
<%
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
%>
		case <%=importManager.getImportedName(genLink.getEditPartQualifiedClassName())%>.VISUAL_ID:
			return <%=importManager.getImportedName(genLink.getNotationViewFactoryQualifiedClassName())%>.class;
<%
	}
}
%>
		}
		return getUnrecognizedConnectorViewClass(semanticAdapter, containerView, semanticHint);
	}

	/**
	 * @@generated
	 */
	private IElementType getSemanticElementType(IAdaptable semanticAdapter) {
		if (semanticAdapter == null) {
			return null;
		}
		return (IElementType) semanticAdapter.getAdapter(IElementType.class);
	}

	/**
	 * @@generated
	 */
	private Class getUnrecognizedConnectorViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
	 	// Handle unrecognized child node classes here
		return null;
	}
	
}
<%importManager.emitSortedImports();%>
@


1.51
log
@#161380 simplify feature model facets
@
text
@@


1.50
log
@Correcting ViewProvider to correctly wok with no ElementType passed (for example - while creating views from CanonicalEditPolicy)
@
text
@d100 1
a100 1
	if (genLink.getModelFacet() instanceof FeatureModelFacet || genLink.getModelFacet() == null) {
@


1.49
log
@check semantic adapter
@
text
@d49 1
a49 1
		if (semanticAdapter != null && !<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.isKnownElementType(elementType)) {
d94 1
a94 1
		if (semanticAdapter != null && !<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.isKnownElementType(elementType)) {
@


1.48
log
@#114175 enable links creation
@
text
@d94 1
a94 1
		if (!<%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.isKnownElementType(elementType)) {
@


1.47
log
@prevent NPE for pure design nodes
@
text
@d48 2
a49 1
		if (semanticAdapter != null && semanticAdapter.getAdapter(IElementType.class) != null && <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.getElement(semanticAdapter) == null) {
a51 1

a54 1

d93 2
a94 1
		if (semanticAdapter.getAdapter(IElementType.class) != null && <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.getElement(semanticAdapter) == null) {
a97 1
boolean elementTypeInitialized = false;
a100 6
		if (!elementTypeInitialized) {
			elementTypeInitialized = true;
%>
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%> elementType = getSemanticElementType(semanticAdapter);
<%
		}
a108 1

a113 1

a114 1
		
a129 1
<%if (elementTypeInitialized) {%>
d134 1
a134 1
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%> getSemanticElementType(IAdaptable semanticAdapter) {
d138 1
a138 1
		return (<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>) semanticAdapter.getAdapter(<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>.class);
d140 1
a140 2
<%}%>
	
@


1.46
log
@use importAssistant to emit package statement instead of handcoding
@
text
@d48 1
a48 1
		if (semanticAdapter.getAdapter(IElementType.class) != null && <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.getElement(semanticAdapter) == null) {
@


1.45
log
@#139843 Unable to parse view type as a visualID number
@
text
@d4 2
a5 1
GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
d9 1
a9 1
package <%=genDiagram.getProvidersPackageName()%>;
a10 1
<%ImportUtil importManager = new ImportUtil(genDiagram.getProvidersPackageName());%>
@


1.44
log
@#133836 Creating a child node without a label causes error
@
text
@d16 1
d48 3
d94 3
@


1.43
log
@#138574 NPE creating ship destination link in TaiPan sample
@
text
@d60 1
a60 1
	if (container instanceof GenNode && !((GenNode) container).isListContainerEntry()) {
@


1.42
log
@#137999 Generate pure static VisualIDRegisrty classes
@
text
@d111 3
@


1.41
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@d32 1
a32 1
				&& <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getDiagramVisualID(semanticElement) != -1
d50 1
a50 1
		int nodeVID = <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getNodeVisualID(containerView, semanticElement, semanticType, semanticHint);
d113 1
a113 1
		int linkVID = <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getLinkWithClassVisualID(semanticElement, semanticType);
@


1.40
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@d57 1
a57 1
		case <%=container.getVisualID()%>:
d65 1
a65 1
		case <%=label.getVisualID()%>:
d76 1
a76 1
		case <%=linkLabel.getVisualID()%>:
d121 1
a121 1
		case <%=genLink.getVisualID()%>:
@


1.39
log
@#129145 do not use intermediate TextCompartmentEditParts
@
text
@d30 1
a30 1
		if ("<%=genDiagram.getEditorGen().getModelID()%>".equals(diagramKind)
@


1.38
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@a63 12
			if (label instanceof ExternalLabel) {
				String semanticHintsClassName = importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName());
				String labelViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Labels." + ((ExternalLabel) label).getSemanticHintLabelFieldName();
%>
		case <%=label.getVisualID()%>:
			if (<%=labelViewId%>.equals(semanticHint)) {
				return <%=importManager.getImportedName(label.getNotationViewFactoryQualifiedClassName())%>.class;
			} else { 
				return <%=importManager.getImportedName(((ExternalLabel) label).getTextNotationViewFactoryQualifiedClassName())%>.class;
			}
<%
			} else {
a67 1
			}
a70 1

a72 1
	String semanticHintsClassName = importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName());
a74 1
		String labelViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + linkLabel.getSemanticHintLabelFieldName();
d77 1
a77 5
			if (<%=labelViewId%>.equals(semanticHint)) {
				return <%=importManager.getImportedName(linkLabel.getNotationViewFactoryQualifiedClassName())%>.class;
			} else { 
				return <%=importManager.getImportedName(linkLabel.getTextNotationViewFactoryQualifiedClassName())%>.class;
			}
@


1.37
log
@#114175 for links
@
text
@d7 1
@


1.36
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@d113 1
a113 1
	if (genLink.getModelFacet() instanceof FeatureModelFacet) {
@


1.35
log
@#128331 NPE in generate view provider when adding note...
+ updating with new templates.
@
text
@d26 1
d28 1
d30 4
a33 1
				&& <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getDiagramVisualID(semanticElement) != -1) { //$NON-NLS-1$
d38 1
a38 1
	
@


1.34
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d112 1
a112 1
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%> elementType = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>) semanticAdapter.getAdapter(<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>.class);
d144 12
d160 1
a160 1
	 private Class getUnrecognizedConnectorViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
d162 2
a163 2
	 	return null;
	 }
@


1.33
log
@constant used throughout templates to identify diagram (genModel.getModelName) was extracted as explicit attribute
packagePrefix added
@
text
@d4 1
a4 1
GenDiagram genDiagram = (GenDiagram) argument;
@


1.32
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d2 1
a2 1
    imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.*"%>
a4 1
GenModel genModel = genDiagram.getEditorGen().getDomainGenModel();
d27 1
a27 1
		if ("<%=genModel.getModelName()%>".equals(diagramKind)
@


1.31
log
@ImportManager moved to oeg.common
@
text
@d5 1
a5 1
GenModel genModel = genDiagram.getEMFGenModel();
@


1.30
log
@rename GenContainerEditPart -> GenContainerBase
@
text
@d2 1
a2 1
    imports="java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
@


1.29
log
@#124413
Cleaning up the gmfgen model
@
text
@d50 1
a50 1
	GenContainerEditPart container = (GenContainerEditPart) containers.next();
@


1.28
log
@#124413
Allowing infinite hierarchy of GenChildNodes
@
text
@d49 1
a49 1
for (Iterator containers = genDiagram.getAllContainers().iterator(); containers.hasNext();) {
@


1.27
log
@#114178
Create shortcut functionality added
@
text
@a6 1
Collection allContainers = AccessUtil.getAllContainers(genDiagram);
d49 2
a50 2
for (Iterator containers = allContainers.iterator(); containers.hasNext();) {
	GenChildContainer container = (GenChildContainer) containers.next();
d55 1
a55 1
	if (container instanceof GenChildNode ? !((GenChildNode) container).isListContainerEntry() : container instanceof GenNode) {
@


1.26
log
@#122054 support external node labels (partial fix)
@
text
@d35 1
a35 1

d43 1
a43 4
		if (!"<%=genModel.getModelName()%>".equals(containerView.getDiagram().getType())) {
			return null;
		}
		
d99 1
a99 1
		return getUnrecognizedNodeViewClass(semanticAdapter, containerView, semanticHint);
a100 8
	
	/**
	 * @@generated
	 */
	 private Class getUnrecognizedNodeViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
	 	// Handle unrecognized node classes here
	 	return null;
	 }
@


1.25
log
@#121581
Fields for the compartments are named unique.
@
text
@d63 12
d79 1
@


1.24
log
@#118256

Enabling links creation to/from sub-classes of corresponding metaclasses from model
@
text
@d76 1
a76 1
		String labelViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + AccessUtil.getLabelId(linkLabel);
@


1.23
log
@#117026
Generating Shape edit parts for inner elements if necessary.
@
text
@a15 1
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
d112 1
a112 1
		IElementType elementType = (IElementType) semanticAdapter.getAdapter(IElementType.class);
@


1.22
log
@#116655

Generating correct access for all the features.
@
text
@d60 1
a60 1
	if (container instanceof GenNode) {
@


1.21
log
@#116798 create distinct package for the view factories
@
text
@a104 1
		IElementType elementType = (IElementType) semanticAdapter.getAdapter(IElementType.class);
d106 1
d110 6
@


1.20
log
@#116031 avoid hardcoded class names in templates
@
text
@d23 1
a23 1
public class <%=genDiagram.getViewProviderClassName()%> extends AbstractViewProvider {
d30 3
a32 2
		if ("<%=genModel.getModelName()%>".equals(diagramKind) && <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getDiagramVisualID(semanticElement) != -1) { //$NON-NLS-1$
			return <%=genDiagram.getNotationViewFactoryClassName()%>.class;
d112 1
a112 1
			return <%=genLink.getNotationViewFactoryClassName()%>.class;
d131 1
a131 1
			return <%=genLink.getNotationViewFactoryClassName()%>.class;
@


1.19
log
@#115972 generate single class with semantic hints
@
text
@d30 1
a30 1
		if ("<%=genModel.getModelName()%>".equals(diagramKind) && <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getDiagramVisualID(semanticElement) != -1) { //$NON-NLS-1$
d49 1
a49 1
		int nodeVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getNodeVisualID(containerView, semanticElement, semanticType, semanticHint);
d110 1
a110 1
		if (ElementTypes.<%=genLink.getUniqueIdentifier()%>.equals(elementType)) {
d121 1
a121 1
		int linkVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getLinkWithClassVisualID(semanticElement, semanticType);
@


1.18
log
@[ashatalin] #115070 links were not working due to recent runtime changes
@
text
@d73 1
a73 2
	String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(link);
	String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d76 1
a76 1
		String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelId(linkLabel);
@


1.17
log
@clean unused code
@
text
@a15 1
import org.eclipse.gmf.runtime.diagram.ui.view.factories.*;
d104 1
a104 1
	protected Class getConnectorViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
@


1.16
log
@[ashatalin] #114750 annotate diagram runtime model elements with visual id to tell one from another during EP decision making
@
text
@a128 2
	String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genLink);
	String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
@


1.15
log
@[ashatalin] #113892 flexible compartment hierarchy
@
text
@d3 6
a8 2
<%GenDiagram genDiagram = (GenDiagram) argument;%>
<%GenModel genModel = genDiagram.getEMFGenModel();%>
a17 1
import org.eclipse.gmf.runtime.notation.Diagram;
d32 1
a32 1
			return DiagramViewFactory.class;
d41 2
a42 8
		Class linkLabelViewClass = getLinkLabelViewClass(semanticAdapter, containerView, semanticHint);
		if (linkLabelViewClass != null) {
			return linkLabelViewClass;
		}
		if (containerView instanceof Diagram || (semanticHint != null && semanticHint.length() > 0)) {
			return getTopLevelNodeViewClass(semanticAdapter, containerView, semanticHint);
		} else {
			return getChildNodeViewClass(semanticAdapter, containerView, semanticHint);
d44 1
a44 39
	}

	/**
	 * @@generated
	 */
	private Class getLinkLabelViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
<%
List genLinks = genDiagram.getLinks();
if (genLinks.size() != 0) {
%>
		EClass semanticType = getSemanticEClass(semanticAdapter);
		EObject semanticElement = getSemanticElement(semanticAdapter);
		int linkVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getLinkWithClassVisualID(semanticElement, semanticType);
		
		switch (linkVID) {
<%
	for (int i = 0; i < genLinks.size(); i++) {
		GenLink genLink = (GenLink) genLinks.get(i);
		String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genLink);
		String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
		if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
%>
		case <%=genLink.getVisualID()%>:
<%
			List labels = genLink.getLabels();
			for (int j = 0; j < labels.size(); j++) {
				GenLinkLabel label = (GenLinkLabel) labels.get(j);
				String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelId(label);
				String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelTextId(label);
%>
			if (<%=labelViewId%>.equals(semanticHint)) {
				return <%=importManager.getImportedName(label.getNotationViewFactoryQualifiedClassName())%>.class;
			}
			if (<%=labelTextViewId%>.equals(semanticHint)) {
				return BasicNodeViewFactory.class;
			}
<%
			}
%>
a45 1
<%			
d47 1
a47 12
	}
%>
			
		}
<%}%>
		return null;
	}

	/**
	 * @@generated
	 */
	private Class getTopLevelNodeViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
d50 2
a51 2
		int nodeVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getNodeVisualID(semanticElement, semanticType);
		
d54 2
a55 3
List genNodes = genDiagram.getNodes();
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
d57 2
a58 1
		case <%=genNode.getVisualID()%>:
d60 4
a63 6
	String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
	String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
	List labels = genNode.getLabels();
	for (int j = 0; j < labels.size(); j++) {
		GenNodeLabel label = (GenNodeLabel) labels.get(j);
		String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelTextId(label);
d65 2
a66 3
			if (<%=labelTextViewId%>.equals(semanticHint)) {
				return BasicNodeViewFactory.class;
			}
a67 12
	}
	List genCompartments = genNode.getCompartments();
	for (int j = 0; j < genCompartments.size(); j++) {
		GenCompartment genChildContainer = (GenCompartment) genCompartments.get(j);
		String compartmentId = semanticHintsClassName + ".Compartments." + AccessUtil.getCompartmentId(genChildContainer);
%>
			if (<%=compartmentId%>.equals(semanticHint)) {
				return ListCompartmentViewFactory.class;
			}
<%	}%>
			return <%=genNode.getNotationViewFactoryClassName()%>.class;
<%}%>
a68 1
		return getUnrecognizedTopLevelNodeViewClass(semanticAdapter, containerView, semanticHint);
d70 1
a70 8
	
	/**
	 * @@generated
	 */
	 private Class getUnrecognizedTopLevelNodeViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
	 	// Handle unrecognized node classes here
	 	return null;
	 }
d72 7
a78 15
	/**
	 * @@generated
	 */
	private Class getChildNodeViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
		EClass semanticType = getSemanticEClass(semanticAdapter);
		EObject semanticElement = getSemanticElement(semanticAdapter);
		int nodeVID = <%=importManager.getImportedName(genDiagram.getEditorPackageName() + ".VisualIDRegistry")%>.INSTANCE.getChildNodeVisualID(semanticElement, semanticType);
		
		switch (nodeVID) {
<%
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	List genChildNodes = AccessUtil.getAllChildNodes(genNode);
	for (int j = 0; j < genChildNodes.size(); j++) {
		GenChildNode genChildNode = (GenChildNode) genChildNodes.get(j);
d80 6
a85 2
		case <%=genChildNode.getVisualID()%>:
			return <%=genChildNode.getNotationViewFactoryClassName()%>.class;
d91 1
a91 1
		return getUnrecognizedChildNodeViewClass(semanticAdapter, containerView, semanticHint);
d97 2
a98 2
	 private Class getUnrecognizedChildNodeViewClass(IAdaptable semanticAdapter, View containerView, String semanticHint) {
	 	// Handle unrecognized child node classes here
a133 15
<%
		// disable creation of connector views for label links
		List labels = genLink.getLabels();
		for (int j = 0; j < labels.size(); j++) {
			GenLinkLabel label = (GenLinkLabel) labels.get(j);
			String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelId(label);
			String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelTextId(label);
%>
			if (<%=labelViewId%>.equals(semanticHint)) {
				return null;
			}
			if (<%=labelTextViewId%>.equals(semanticHint)) {
				return null;
			}
<%		}%>
@


1.14
log
@[dstadnik] #113525 Get rid of LinkWithClass/LinkWithReference, use parallel hierarchy of modelFacet instead
@
text
@d125 3
a127 3
	List genChildContainers = genNode.getChildContainers();
	for (int j = 0; j < genChildContainers.size(); j++) {
		GenChildContainer genChildContainer = (GenChildContainer) genChildContainers.get(j);
d160 1
a160 1
	List genChildNodes = genNode.getChildNodes();
@


1.13
log
@[dstadnik] #112195 multiple labels for the node, facets introduced, genmodel cleaned and refactored
@
text
@d67 1
a67 1
		if (genLink instanceof GenLinkWithClass) {
d190 1
a190 1
	if (genLink instanceof GenLinkReferenceOnly) {
d211 1
a211 1
	if (genLink instanceof GenLinkWithClass) {
@


1.12
log
@[dstadnik] #112900 metamodel support
@
text
@d73 3
a75 3
				LinkLabel label = (LinkLabel) labels.get(j);
				String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLinkLabelId(label);
				String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLinkLabelTextId(label);
d78 1
a78 1
				return <%=AccessUtil.getLinkLabelViewFactoryClassName(label)%>.class;
d115 4
a118 2
	if (genNode.hasNameToEdit()) {
		String semanticHint = semanticHintsClassName + '.' + AccessUtil.getNameSemanticHint(genNode);
d120 1
a120 1
			if (<%=semanticHint%>.equals(semanticHint)) {
d123 2
a124 1
<%	}
d218 3
a220 3
			LinkLabel label = (LinkLabel) labels.get(j);
			String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLinkLabelId(label);
			String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLinkLabelTextId(label);
@


1.11
log
@[dstadnik] #112174 and #112185 - constants for compartments and labels
@
text
@d21 1
a21 1
public class ViewProvider extends AbstractViewProvider {
@


1.10
log
@[dstadnik] #112176 support references w/o domain class
@
text
@a33 4
<%
GenPackage genPackage = genDiagram.getDomainMetaModel();
%>

d42 1
a42 3
		
		boolean isTopLevel = containerView instanceof Diagram || (semanticHint != null && semanticHint.length() > 0);
		if (isTopLevel) {
d65 2
d74 2
d77 1
a77 1
			if ("<%=AccessUtil.getLinkLabelViewName(label)%>".equals(semanticHint)) {
d80 1
a80 1
			if ("<%=AccessUtil.getLinkLabelTextViewName(label)%>".equals(semanticHint)) {
d93 1
a93 3
<%
}
%>
d96 1
a96 1
	
a109 2
	String semanticNodeInterfaceName = genNode.getDomainMetaClass().getClassifierAccessorName();
	String qualifiedInterfaceName = genNode.getDomainMetaClass().getQualifiedInterfaceName();
d113 2
d116 1
a116 2
		String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
		String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d118 1
a118 1
			if (<%=semanticHintsClassName%>.<%=AccessUtil.getNameSemanticHint(genNode)%>.equals(semanticHint)) {
d125 1
d127 1
a127 1
			if ("<%=genChildContainer.getGroupID()%>".equals(semanticHint)) {
d132 1
a132 3
<%
}
%>
d163 2
a164 1
<%	}
d206 2
d216 2
d219 1
a219 1
			if ("<%=AccessUtil.getLinkLabelViewName(label)%>".equals(semanticHint)) {
d222 1
a222 1
			if ("<%=AccessUtil.getLinkLabelTextViewName(label)%>".equals(semanticHint)) {
@


1.9
log
@[ashatalin] #112122 Action to initialize diagram for domain model.
 unique id introduced, refactoring to use it throughout the code
@
text
@d13 1
d188 14
d204 1
@


1.8
log
@[rdvorak] #112097 genmodel support to use expression evaluation to choose editpart (visual representation)
@
text
@d27 1
a27 1
		if ("<%=genModel.getModelName()%>".equals(diagramKind) && isDiagram<%=genDiagram.getDomainDiagramElement().getClassifierAccessorName()%>_<%=genDiagram.getVisualID()%>((<%=importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName())%>) semanticElement)) { //$NON-NLS-1$
a34 1
String semanticPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
d41 17
a57 2
		EClass semanticType = getSemanticEClass(semanticAdapter);
		EObject semanticElement = getSemanticElement(semanticAdapter);
d60 1
a60 6
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink instanceof GenLinkWithClass) {
		GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genLinkWithClass.getDomainMetaClass().getQualifiedInterfaceName();
d62 15
a76 5
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(semanticType) && isConnector<%=semanticLinkInterfaceName%>_<%=genLinkWithClass.getVisualID()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) semanticElement)) {
<%
		List labels = genLink.getLabels();
		for (int j = 0; j < labels.size(); j++) {
			LinkLabel label = (LinkLabel) labels.get(j);
d84 3
a86 1
<%		}%>
d88 5
a94 1
	}
d97 1
a97 6
		boolean isTopLevel = containerView instanceof Diagram || (semanticHint != null && semanticHint.length() > 0);
		if (isTopLevel) {
			return getTopLevelNodeViewClass(semanticAdapter, containerView, semanticHint);
		} else {
			return getChildNodeViewClass(semanticAdapter, containerView, semanticHint);
		}
d99 1
a99 1

d106 3
d116 1
a116 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticNodeInterfaceName%>().equals(semanticType) && isNode<%=semanticNodeInterfaceName%>_<%=genNode.getVisualID()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) semanticElement)) {
a134 1
		}
d138 1
d156 3
a164 2
		String semanticChildNodeInterfaceName = genChildNode.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genChildNode.getDomainMetaClass().getQualifiedInterfaceName();
d166 1
a166 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticChildNodeInterfaceName%>().equals(semanticType) && isChildNode<%=semanticChildNodeInterfaceName%>_<%=genChildNode.getVisualID()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) semanticElement)) {
a167 1
		}
d171 1
d189 3
a195 3
		GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genLinkWithClass.getDomainMetaClass().getQualifiedInterfaceName();
d197 1
a197 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(semanticType) && isConnector<%=semanticLinkInterfaceName%>_<%=genLinkWithClass.getVisualID()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) semanticElement)) {
a211 1
		}
d216 1
a227 57
	/**
	 * @@generated
	 */
	private boolean isDiagram<%=genDiagram.getDomainDiagramElement().getClassifierAccessorName()%>_<%=genDiagram.getVisualID()%>(<%=importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName())%> element) {
		return true;
	}
	
<%
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	String semanticNodeInterfaceName = genNode.getDomainMetaClass().getClassifierAccessorName();
	String qualifiedNodeInterfaceName = genNode.getDomainMetaClass().getQualifiedInterfaceName();
%>
	/**
	 * @@generated
	 */
	private boolean isNode<%=semanticNodeInterfaceName%>_<%=genNode.getVisualID()%>(<%=importManager.getImportedName(qualifiedNodeInterfaceName)%> element) {
		return element == null || <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genNode)%>(element);
	}

<%
	List genChildNodes = genNode.getChildNodes();
	for (int j = 0; j < genChildNodes.size(); j++) {
		GenChildNode genChildNode = (GenChildNode) genChildNodes.get(j);
		String semanticChildNodeInterfaceName = genChildNode.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedChildNodeInterfaceName = genChildNode.getDomainMetaClass().getQualifiedInterfaceName();
%>
	/**
	 * @@generated
	 */
	private boolean isChildNode<%=semanticChildNodeInterfaceName%>_<%=genChildNode.getVisualID()%>(<%=importManager.getImportedName(qualifiedChildNodeInterfaceName)%> element) {
		return element == null || <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genChildNode)%>(element);
	}

<%	}
}
%>
	
<%
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink instanceof GenLinkWithClass) {
		GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genLinkWithClass.getDomainMetaClass().getQualifiedInterfaceName();
%>
	/**
	 * @@generated
	 */
	private boolean isConnector<%=semanticLinkInterfaceName%>_<%=genLinkWithClass.getVisualID()%>(<%=importManager.getImportedName(qualifiedInterfaceName)%> element) {
		return element == null || <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genLinkWithClass)%>(element);
	}
<%
	}
}
%>
	
@


1.7
log
@[dstadnik] #112189 remove editProviders package attribute from genmodel
@
text
@d221 1
a221 1
		return true;
d235 1
a235 1
		return true;
d254 1
a254 1
		return true;
@


1.6
log
@[dstadnik]
#111780 Link labels with read-only flag and relative positioning
@
text
@a14 1
import <%=genDiagram.getEditProvidersPackageName()%>.*;
d96 1
a96 1
		String semanticHintsQualifiedClassName = genDiagram.getEditProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
@


1.5
log
@temp fix for inner elements
@
text
@d43 30
d80 1
a80 1
	
a166 1
List genLinks = genDiagram.getLinks();
d175 13
@


1.4
log
@[ashatalin]
#111773 Multiple views for single domain metaelement based on it's state
#111782 Support same metaelement both as top-level and inner diagram element
@
text
@d43 1
a43 1
		boolean isTopLevel = containerView instanceof Diagram;
@


1.3
log
@gmfgen ECore references were replaced with GenModel references to ease template coding and as alignment with overall "genmodel for GMF" concept
@
text
@d10 1
d13 1
d27 2
a28 1
		if ("<%=genModel.getModelName()%>".equals(diagramKind)) { //$NON-NLS-1$
d43 12
d56 1
d61 2
a62 1
	String semanticNodeInterfaceName = genNode.getDomainMetaClass().getName();
d64 1
a64 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticNodeInterfaceName%>().equals(semanticType)) {
d85 22
d110 2
a111 1
		String semanticChildNodeInterfaceName = genChildNode.getDomainMetaClass().getName();
d113 1
a113 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticChildNodeInterfaceName%>().equals(semanticType)) {
d119 1
a119 1
		return null;
d121 8
d135 1
d142 2
a143 1
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getName();
d145 1
a145 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(semanticType)) {
d152 64
a215 1
		return null;
d218 3
@


1.2
log
@[dstadnik] support for (a) connections (with associated domain class) and (b) compartments
@
text
@d4 1
a4 1
<%GenModel genModel = genDiagram.getEmfGenModel();%>
d32 1
a32 1
GenPackage genPackage = genDiagram.getEmfGenModel().findGenPackage(genDiagram.getDomainMetaModel());
@


1.1
log
@[dstadnik] Use Notation Model as runtime model
@
text
@d2 1
a2 1
    imports="org.eclipse.emf.common.util.EList org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.codegen.util.*"%>
d31 5
d42 1
a42 3
GenPackage genPackage = genDiagram.getEmfGenModel().findGenPackage(genDiagram.getDomainMetaModel());
String semanticPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
EList genNodes = genDiagram.getNodes();
d49 3
a51 3
		if (genNode.hasNameToEdit()) {
			String semanticHintsQualifiedClassName = genDiagram.getEditProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(genNode);
			String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d56 9
a64 1
<%		}%>
d67 12
a78 1
<%}%>
d86 16
@

