head	1.11;
access;
symbols
	v20081022-1925:1.11
	v20081015-1925:1.11
	v20081008-1925:1.11
	v20081001-1925:1.11
	v20080924-1925:1.11
	v20080917-1925:1.11
	v20080911-1728:1.11
	v20080910-1520:1.11
	v20080903-1520:1.11
	v20080827-1520:1.11
	v20080813-1520:1.11
	v20080806-1520:1.11
	R1_0_maintenance:1.11.0.2
	R1_0:1.11
	I20060309-1300:1.10
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.8
	I20060216-1945:1.8
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.3
	I20060202-1415:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2006.03.13.11.02.30;	author dstadnik;	state dead;
branches;
next	1.10;

1.10
date	2006.03.09.13.25.10;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.07.14.09.19;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.15.13.27.40;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.14.13.06.38;	author dstadnik;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.09.16.16.00;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.06.14.31.00;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.06.11.00.20;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.02.15.58.54;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.31.11.00.48;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.30.18.26.46;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.11
log
@#129145 do not use intermediate TextCompartmentEditParts
@
text
@
	/**
	 * @@generated
	 */
	private String defaultText;

	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.draw2d.IFigure")%> createFigure() {
		<%=importManager.getImportedName("org.eclipse.draw2d.IFigure")%> figure = super.createFigure();
		if (figure instanceof <%=importManager.getImportedName("org.eclipse.draw2d.Label")%>) {
			defaultText = ((<%=importManager.getImportedName("org.eclipse.draw2d.Label")%>) figure).getText();
		} else if (figure instanceof <%=importManager.getImportedName("org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel")%>) {
			defaultText = ((<%=importManager.getImportedName("org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel")%>) figure).getText();
		}
		return figure;
	}

	/**
	 * @@generated
	 */
	protected String getLabelText() {
		String text = super.getLabelText();
		if (text == null || text.length() == 0) {
			return defaultText;
		}
		return text;
	}

<%if (genLabel.isReadOnly()) {%>

	/**
	 * @@generated
	 */
	protected boolean isEditable() {
		return false;
	}
<%}%>

	/**
	 * @@generated
	 */
	public <%=importManager.getImportedName("org.eclipse.gmf.runtime.common.ui.services.parser.IParser")%> getParser() {
		if (parser == null) {
			String parserHint = ((View)getModel()).getType();
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> element = resolveSemanticElement();
			if (element != null) {
				<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.ui.services.parser.ParserHintAdapter")%> hintAdapter = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.ui.services.parser.ParserHintAdapter")%>(element, parserHint) {
					public Object getAdapter(Class adapter) {
						if (<%=importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType")%>.class.equals(adapter)) {
							return <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.<%=genHost.getUniqueIdentifier()%>;
						}
						return super.getAdapter(adapter);
					}
				};
				parser = <%=importManager.getImportedName("org.eclipse.gmf.runtime.common.ui.services.parser.ParserService")%>.getInstance().getParser(hintAdapter);
			}
		}
		return parser;
	}
@


1.10
log
@remove warnings
@
text
@@


1.9
log
@#130715 Use default label text defined in gmfgraph model
@
text
@a46 10
<%
GenCommonBase genHost;
if (genLabel instanceof GenNodeLabel) {
	genHost = ((GenNodeLabel) genLabel).getNode();
} else if (genLabel instanceof GenLinkLabel) {
	genHost = ((GenLinkLabel) genLabel).getLink();
} else {
	throw new IllegalArgumentException("Unknown label type: " + genLabel);
}
%>
@


1.8
log
@get editing domain from eobject
@
text
@a0 1
<%if (genLabel.isReadOnly() || genLabel.getModelFacet() instanceof TextLabelModelFacet) {%>
d5 1
a5 8
	protected boolean isEditable() {
		return false;
	}
<%
}
if (genLabel.getModelFacet() instanceof TextLabelModelFacet) {
	TextLabelModelFacet modelFacet = (TextLabelModelFacet) genLabel.getModelFacet();
%>
d10 8
a17 2
	protected String getLabelText() {
		return "<%=modelFacet.getText()%>";
a18 5
<%
} else if (genLabel.getModelFacet() instanceof FeatureLabelModelFacet) {
	String defaultText = ((FeatureLabelModelFacet) genLabel.getModelFacet()).getDefaultText();
	if (defaultText != null) {
%>
d26 1
a26 1
			return "<%=defaultText%>";
d30 8
a37 1
<%
d39 1
a39 2
}
%>
@


1.7
log
@use new transactional emf api
@
text
@a63 2
						} else if (<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%>.class.equals(adapter)) {
							return getEditingDomain();
@


1.6
log
@Updating with new transaction API.
@
text
@d64 2
@


1.5
log
@#111949 Provide a possibility to invoke inplace for inner elements with empty name
@
text
@d41 32
@


1.4
log
@#126533 It should be possible to specify a label with fixed text in gmfgen model
@
text
@d21 20
a40 1
<%}%>
@


1.3
log
@#125828 Generated code is bypassing parser service...
@
text
@d1 1
a1 1
<%if (genLabel.isReadOnly()) {%>
d9 12
@


1.2
log
@#125729 Support labels based on multiple structural features
@
text
@d1 1
a1 49
<%
{
	GenPackage genPackage = genDiagram.getDomainMetaModel();
	String semanticPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
	LabelModelFacet modelFacet = genLabel.getModelFacet();
%>

	/**
	 * @@generated
	 */
	public <%=importManager.getImportedName("org.eclipse.gmf.runtime.common.ui.services.parser.IParser")%> getParser() {
		if (parser == null) {
<%
	String parserClassName;
	if (modelFacet instanceof FeatureModelFacet) {
		parserClassName = importManager.getImportedName(genDiagram.getStructuralFeatureParserQualifiedClassName());
		String featureName = ((FeatureModelFacet) modelFacet).getMetaFeature().getName();
%>
			parser = new <%=parserClassName%>(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=accessorName%>().getEStructuralFeature("<%=featureName%>"));
<%
	} else if (modelFacet instanceof CompositeFeatureModelFacet) {
		parserClassName = importManager.getImportedName(genDiagram.getStructuralFeaturesParserQualifiedClassName());
		java.util.List features = ((CompositeFeatureModelFacet) modelFacet).getMetaFeatures();
%>
			<%=importManager.getImportedName("java.util.List")%> features = new <%=importManager.getImportedName("java.util.ArrayList")%>(<%=features.size()%>);
<%
		for (java.util.Iterator it = features.iterator(); it.hasNext(); ) {
			String featureName = ((GenFeature) it.next()).getName();
%>
			features.add(<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=accessorName%>().getEStructuralFeature("<%=featureName%>"));
<%		}%>
			parser = new <%=parserClassName%>(features);
<%
	} else {
		throw new IllegalArgumentException();
	}
%>			
<%	if (modelFacet.getViewPattern() != null && modelFacet.getViewPattern().length() != 0) {%>
			((<%=parserClassName%>) parser).setViewPattern("<%=modelFacet.getViewPattern()%>");
<%
	}
	if (modelFacet.getEditPattern() != null && modelFacet.getEditPattern().length() != 0) {
%>
			((<%=parserClassName%>) parser).setEditPattern("<%=modelFacet.getEditPattern()%>");
<%	}%>
		}
		return parser;
	}
<%	if (genLabel.isReadOnly()) {%>
d9 1
a9 4
<%
	}
}
%>
@


1.1
log
@#125729 Support labels based on multiple structural features
@
text
@d5 1
a5 3
	FeatureModelFacet modelFacet = (FeatureModelFacet) genLabel.getModelFacet();
	String featureName = modelFacet.getMetaFeature().getName();
	String parserClassName = importManager.getImportedName(genDiagram.getStructuralFeatureParserQualifiedClassName());
d13 6
d20 18
@

