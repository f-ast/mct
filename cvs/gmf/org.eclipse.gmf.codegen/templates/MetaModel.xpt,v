head	1.17;
access;
symbols
	v20081022-1925:1.17
	v20081015-1925:1.17
	v20081008-1925:1.17
	v20081001-1925:1.17
	v20080930-1130:1.17
	v20080926-1245:1.17
	v20080924-1925:1.17
	v20080917-1925:1.17
	v20080911-1728:1.17
	v20080910-1520:1.17
	v20080903-1520:1.17
	v20080827-1520:1.17
	v20080813-1520:1.17
	v20080806-1520:1.17
	v20080722-1827:1.17
	v20080718-1731:1.17
	v20080716-1600:1.16
	v20080716-1642:1.17
	R2_1_maintenance:1.16.0.2
	Root_R2_1_maintenance:1.16
	R2_1_0:1.16
	v20080610-1132:1.16
	v20080603-1553:1.16
	v20080528-1052:1.16
	v20080521:1.16
	v20080516-1543:1.16
	v20080516-1143:1.16
	v20080512-1200:1.16
	v20080508-2000:1.16
	v20080507-1326:1.16
	v20080503-1740:1.15
	v20080501-1739:1.15
	v20080425-1959:1.15
	v20080417-1610:1.15
	v20080411-0411:1.14
	v20080404-1111:1.14
	v20080322-0000:1.14;
locks; strict;
comment	@# @;
expand	@k@;


1.17
date	2008.07.01.18.48.54;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	4f11486a7c164567;

1.16
date	2008.05.07.13.56.02;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	39124821b4de4567;

1.15
date	2008.04.14.08.38.03;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	1b0e480317df4567;

1.14
date	2008.03.04.20.27.07;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	2ac447cdb09b4567;

1.13
date	2008.02.29.21.19.52;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	45a447c876f24567;

1.12
date	2008.02.28.19.04.40;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	cd347c705c44567;

1.11
date	2008.02.28.16.37.15;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	2cc347c6e33a4567;

1.10
date	2008.02.28.13.21.26;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	1f7447c6b5554567;

1.9
date	2008.02.27.17.30.21;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	22cf47c59e244567;

1.8
date	2008.02.27.12.30.00;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	1a2447c557c84567;

1.7
date	2008.02.26.22.50.30;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	405847c497b64567;

1.6
date	2008.02.26.13.53.52;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	19d047c419ed4567;

1.5
date	2008.02.22.20.26.05;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	38b747bf2fdd4567;

1.4
date	2008.02.22.20.24.44;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	377d47bf2f8a4567;

1.3
date	2008.02.21.21.28.45;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	68147bded0c4567;

1.2
date	2008.02.21.20.18.09;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	468b47bddc804567;

1.1
date	2008.02.21.18.35.58;	author atikhomirov;	state Exp;
branches;
next	;
commitid	6b4047bdc48d4567;


desc
@@


1.17
log
@refactored templates moving towards [188329] - Support Java 5.0 (would need to respect generic types when adding into collections) while trying to accomplish [227127]
@
text
@/*
 * Copyright (c) 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION MetaModel»

/*
 * Does instanceof check.
 */
«DEFINE IsInstance(String accessor) FOR GenClass-»
«accessor» instanceof «getQualifiedInterfaceName()»«ENDDEFINE»

// Shorthand, negates IsInstance - handy if you consider
// different approaches for generated and dynamic models: false == instanceof
// vs. !MetaModelFacility.isInstance
«DEFINE NotInstance(String accessor) FOR GenClass-»
false == «EXPAND IsInstance(accessor)»«ENDDEFINE»

/**
 * Special kind of instanceof check, that compares eContainer() of the object.
 * Since metaClass may be an external interface, eContainer() might need cast to EObject  
 */
«DEFINE IsContainerInstance(String object, GenClass metaClass) FOR GenClass-»
«EXPAND _getEObjectFeature(object, "eContainer()") FOR metaClass» instanceof «getQualifiedInterfaceName()»«ENDDEFINE»

«DEFINE _getEObjectFeature(String object, String feature) FOR GenClass-»
«IF isExternalInterface()»((org.eclipse.emf.ecore.EObject) «object»).«feature»«ELSE»«object».«feature»«ENDIF-»
«ENDDEFINE»

// Public/API-sort templates are named with first letter capitalized.
// FIXME getFeatureValue* and setFeatureValue start with lowercase to indicate pending refactoring

«DEFINE getFeatureValue(String containerVar, genmodel::GenClass containerClass) FOR genmodel::GenFeature-»
«IF isExternalInterface(containerClass)-»
((«EXPAND featureTargetType») ((org.eclipse.emf.ecore.EObject) «containerVar»).eGet(«EXPAND MetaFeature»))«-»
«ELSE-»
«containerVar».«getGetAccessor()»()«-»
«ENDIF-»
«ENDDEFINE»

«DEFINE featureTargetType FOR GenFeature»«IF isListType()»java.util.List«ELSE»«EXPAND QualifiedClassName FOR findGenClassifier(genClass.genPackage.genModel, ecoreFeature.eType)»«ENDIF»«ENDDEFINE»

/*
 * FIXME leave only one version of these two getFeatureValue
 *
 * A slightly more sophisticated version of getFeatureValue().
 * @@param containerName the name of the container
 * @@param feature the feature whose value is in interest
 * @@param containerMetaClass the <code>GenClass</code> of the container, or <code>null</code>, if the container is declared as an <code>org.eclipse.emf.ecore.EObject</code>.
 * @@param needsCastToResultType whether the cast to the result type is required (this parameter is only used if the <code>org.eclipse.emf.ecore.EClass</code> this feature belongs to is an external interface). 
 */
«DEFINE getFeatureValue(String containerVar, genmodel::GenClass container, boolean needsCastToResultType) FOR genmodel::GenFeature-»
«IF isExternalInterface(genClass)-»
«IF needsCastToResultType»((«EXPAND featureTargetType») «ENDIF»«containerVar.parenthesizedCast(container, null)».eGet(«EXPAND MetaFeature»)«IF needsCastToResultType»)«ENDIF-»
«ELSE-»
«containerVar.parenthesizedCast(container, genClass)».«getGetAccessor()»()«-»
«ENDIF-»
«ENDDEFINE»

«DEFINE modifyFeature(String targetVar, GenClass targetType, String value) FOR GenFeature-»
«IF isListType()-»
«EXPAND getFeatureValue(targetVar, targetType)».add(«value»);«-»
«ELSE-»
«EXPAND setFeatureValue(targetVar, targetType, value)»;«-»
«ENDIF-»
«ENDDEFINE»

«DEFINE replaceFeatureValue(String targetVar, GenClass targetType, String oldValue, String newValue) FOR GenFeature-»
«IF isListType()-»
	«EXPAND getFeatureValue(targetVar, targetType)».remove(«oldValue»);
«ENDIF-»
	«EXPAND modifyFeature(targetVar, targetType, newValue)-»
«ENDDEFINE»

«DEFINE moveFeatureValue(String oldTarget, String newTarget, GenClass targetType, String value) FOR GenFeature-»
«IF isListType()-»
	«EXPAND getFeatureValue(oldTarget, targetType)».remove(«value»);
«ELSE-»
	«EXPAND setFeatureValue(oldTarget, targetType, "null")»;
«ENDIF-»
	«EXPAND modifyFeature(newTarget, targetType, value)-»
«ENDDEFINE»

«DEFINE setFeatureValue(String targetVar, genmodel::GenClass targetType, String valueVar) FOR genmodel::GenFeature-»
«EXPAND setFeatureValue(targetVar, targetType, valueVar, false)»«ENDDEFINE»

// FIXME support list features as well, i.e. do .add() instead of eSet
«DEFINE setFeatureValue(String targetVar, genmodel::GenClass targetType, String valueVar, boolean isPlainObjectValue) FOR genmodel::GenFeature-»
«IF isExternalInterface(targetType)-»
((org.eclipse.emf.ecore.EObject) «targetVar»).eSet(«EXPAND MetaFeature», «valueVar»)«-»
«ELSE-»
«targetVar».set«getAccessorName(this)»(«IF !isPlainObjectValue»«valueVar»«ELSE»«IF isPrimitiveType()»«EXPAND _unwrapObjectToPrimitiveValue(valueVar)»«ELSE»(«EXPAND featureTargetType») «valueVar»«ENDIF»«ENDIF»)«-»
«ENDIF-»
«ENDDEFINE»

«DEFINE _unwrapObjectToPrimitiveValue(String valueVar) FOR GenFeature-»
((«EXPAND featureTargetType») «valueVar»).«ecoreFeature.eType.instanceClassName»Value()«ENDDEFINE»

«DEFINE MetaClass FOR genmodel::GenClassifier»«getQualifiedPackageInterfaceName(genPackage)».eINSTANCE.get«getClassifierAccessorName(this)»()«ENDDEFINE»

«DEFINE MetaFeature FOR genmodel::GenFeature»«getQualifiedPackageInterfaceName(genClass.genPackage)».eINSTANCE.get«getFeatureAccessorName(this)»()«ENDDEFINE»

// SomeFactory.eINSTANCE.createBlaBla();
//NB: for map entries, the resulting type is EObject, not the qualified interface name. If cast is needed, use (un)parenthesizedCast() extension.
//see GenClassImpl#hasFactoryInterfaceCreateMethod() for details why map entries should be treated differently
«DEFINE NewInstance FOR genmodel::GenClass-»
«IF isMapEntry()-»
«genPackage.getQualifiedFactoryInterfaceName()».«genPackage.getFactoryInstanceName()».create(«EXPAND MetaClass»)«ELSE-»
«genPackage.getQualifiedFactoryInterfaceName()».«genPackage.getFactoryInstanceName()».create«ecoreClass.name»()«ENDIF-»
«ENDDEFINE»

// XXX Need to take into account possible GenClass from generated and always available code
// e.g. Notation or Ecore 

«DEFINE NewInstance(String varName) FOR genmodel::GenClass-»
«getQualifiedInterfaceName()» «varName» = «IF isMapEntry()»(«getQualifiedInterfaceName()») «ENDIF»«EXPAND NewInstance»;
«ENDDEFINE»

/*
 * Ensures value is of type EObject, may be no-op if context GenClass is compatible with EObject.
 * Note, injected value is not surrounded with parenthesis, may need to introduce another
 * template to accomplish that if needed.
 */
«DEFINE DowncastToEObject(String value) FOR genmodel::GenClass»«IF isExternalInterface()»(org.eclipse.emf.ecore.EObject) «ENDIF»«value»«ENDDEFINE»

/*
 * Declares new variable of appropriate type and assigns casted value to it.
 */
«DEFINE DeclareAndAssign(String assignee, String value) FOR GenClass-»
«getQualifiedInterfaceName()» «assignee» = («getQualifiedInterfaceName()») «value»;«ENDDEFINE»

/*
 * third boolean parameter is to indicate the value is not EObject, so may
 * need extra cast in case dynamic model instances are in use.
 */
«DEFINE DeclareAndAssign(String assignee, String value, boolean isPlainObjectValue) FOR GenClass-»
«EXPAND DeclareAndAssign(assignee, value)»«ENDDEFINE»

«DEFINE DeclareAndAssign(String assignee, String value, boolean isPlainObjectValue) FOR GenClassifier-»
«getQualifiedClassName()» «assignee» = («getQualifiedClassName()») «value»;«ENDDEFINE»

// @@see IsContainerInstance
«DEFINE DeclareAndAssignContainer(String assignee, String object, GenClass metaClass) FOR GenClass-»
«getQualifiedInterfaceName()» «assignee» = («getQualifiedInterfaceName()») «EXPAND _getEObjectFeature(object, "eContainer()") FOR metaClass»;«ENDDEFINE»

/*
 * Declares new variable of context type and assignes a value obtained from 'src',
 * which is of type 'srcMetaClass', via 'srcFeature'
 *
 * XXX in certain scenarions may need extra cast of the feature value
 */
«DEFINE DeclareAndAssign(String assignee, String src, GenClass srcMetaClass, GenFeature srcFeature) FOR GenClass-»
«getQualifiedInterfaceName()» «assignee» = «EXPAND getFeatureValue(src, srcMetaClass) FOR srcFeature»;«ENDDEFINE»

/*
 * Same as DeclareAndAssign, with extra operation applied to source object
 */
«DEFINE DeclareAndAssign2(String assignee, String src, GenClass srcMetaClass, GenFeature srcFeature, String srcExt, boolean needCast) FOR GenClass-»
«getQualifiedInterfaceName()» «assignee» = «IF needCast»(«getQualifiedInterfaceName()») «ENDIF»«EXPAND getFeatureValue(src, srcMetaClass) FOR srcFeature».«srcExt»;«ENDDEFINE»

/*
 * Cast value of type EObject to specific type. Would be no-op with dynamic model instances,
 * therefore, the fact eObjectValue is actually EObject is essential
 */
«DEFINE CastEObject(String eObjectValue) FOR GenClass»(«getQualifiedInterfaceName()») «eObjectValue»«ENDDEFINE»

/**
 * Qualified interface name of the generated EClass, or EObject for dynamic models.
 * Use whenever class name is inevitable (e.g. method arguments)
 * SHOULD NEVER APPEAR in instanceof or any other similar comparison operation
 */
«DEFINE QualifiedClassName FOR GenClass»«getQualifiedInterfaceName()»«ENDDEFINE»
«DEFINE QualifiedClassName FOR GenClassifier»«getQualifiedClassName()»«ENDDEFINE»

«DEFINE PopulateItemProviderFactories(String factoryListVar) FOR GenEditorGenerator-»
«FOREACH getAllDomainGenPackages(true) AS genPackage-»
		«factoryListVar».add(new «genPackage.getQualifiedItemProviderAdapterFactoryClassName()»());
«ENDFOREACH-»
«ENDDEFINE»
@


1.16
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d72 26
a97 2
«DEFINE setFeatureValue(String containerVar, genmodel::GenClass containerGenClass, String valueVar) FOR genmodel::GenFeature-»
«EXPAND setFeatureValue(containerVar, containerGenClass, valueVar, false)»«ENDDEFINE»
d100 3
a102 3
«DEFINE setFeatureValue(String containerVar, genmodel::GenClass containerGenClass, String valueVar, boolean isPlainObjectValue) FOR genmodel::GenFeature-»
«IF isExternalInterface(containerGenClass)-»
((org.eclipse.emf.ecore.EObject) «containerVar»).eSet(«EXPAND MetaFeature», «valueVar»)«-»
d104 1
a104 1
«containerVar».set«getAccessorName(this)»(«IF !isPlainObjectValue»«valueVar»«ELSE»«IF isPrimitiveType()»«EXPAND _unwrapObjectToPrimitiveValue(valueVar)»«ELSE»(«EXPAND featureTargetType») «valueVar»«ENDIF»«ENDIF»)«-»
@


1.15
log
@[226149] Refactor Validation/Constraints: explicit context groupings instead of ID matching, unused IClientSelectors implementations are no longer generated, less custom code in the model, odd approach with map (semanticCtxIdMap) replaced with in-place VisualID check.
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.14
log
@[221347] refactor/simplify ElementInitializers. Step 1/2: make it simple and straightforward but do not touch existing facilities
@
text
@d72 3
d76 2
a77 2
«DEFINE setFeatureValue(String containerVar, genmodel::GenClass containerGenClass, String valueVar) FOR genmodel::GenFeature-»
	«IF isExternalInterface(containerGenClass)-»
d79 3
a81 3
	«ELSE-»
«containerVar».set«getAccessorName(this)»(«valueVar»)«-»
	«ENDIF-»
d84 3
d121 1
a121 1
 * third boolean parameter is to indicate the value is not EObject, si may
@


1.13
log
@[150177] phase IV, fix last use of qualified class names in ElementInitializers (via GMFGen genmodel java methods). Cleaned genmodel of methods no longer in use, few methods moved to ElementInitializer.ext (pending removal/refactoring)
@
text
@d72 1
@


1.12
log
@[150177] phase II, access to metamodel through generated facility - deal with occasional plain Objects
@
text
@d47 1
a47 1
((«getFeatureTargetType()») ((org.eclipse.emf.ecore.EObject) «containerVar»).eGet(«EXPAND MetaFeature»))«-»
d53 2
d66 1
a66 1
«IF needsCastToResultType»((«getFeatureTargetType()») «ENDIF»«containerVar.parenthesizedCast(container, null)».eGet(«EXPAND MetaFeature»)«IF needsCastToResultType»)«ENDIF-»
d120 3
d154 1
@


1.11
log
@refactor false == isInstance to NotInstance
@
text
@d111 7
@


1.10
log
@[150177] phase II, access to metamodel through generated facility
@
text
@d23 1
a23 4
«IF true /*useJavaModelCode*/-»
«accessor» instanceof «getQualifiedInterfaceName()»«ELSE-»
MetaModelFacility.getEClass("«ecoreClass.name»").isSuperTypeOf(«IF true /*isEObjectNotExternalInterface(genClass)*/»«accessor»«ELSE»((org.eclipse.emf.ecore.EObject) «accessor»«ENDIF».eClass())«ENDIF-»
«ENDDEFINE»
d25 5
a29 3
«DEFINE NotInstance FOR GenClass-»
// XXX shorthand: !(EXPAND IsInstance)
«ENDDEFINE»
@


1.9
log
@[150177] phase II, generated facility to perform metamodel operations (like instanceof or metaclass accessors) with dynamic models, new gmfgen options to parameterize codegen.
@
text
@d43 3
@


1.8
log
@clean out unused templates
@
text
@a145 35

«DEFINE Facility FOR GenEditorGenerator»
public class MetaModelFacility {

	private static MetaModelFacility instance;

	private MetaModelFacility(EPackage ePackage) {
	}

	private void doInit() {
	«FOREACH getAllDomainGenPackages(true) AS genPackage-»
	«ENDFOREACH»
	}

	public static MetaModelFacility get«"NameBasedOnMetaModelPackageName"»() {
		if (instance«"XX"» == null) {
			instance«"XX"» = new MetaModelFacility(«"load EPackage"»);
			instance«"XX"».doInit();
		}
		return instance«"XX"»;
	}

	public static isInstance(EObject obj, String metaClassName) {
		EClass eMetaClass = getInstance(metaModelName).findMetaClass(metaClassName);
		return obj != null && eMetaClass.isSuperTypeOf(obj.eClass());
	}

	public static EObject newInstance(String metaClassName) {
	}

	public static EClass getEClass(String metaClassName) {
		return instance.findMetaClass(metaClassName);
	}
}
«ENDDEFINE»@


1.7
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template, LiteRT version updated
@
text
@a95 7
«REM»
XXX looks like we don't use it any longer
«DEFINE NewEObjectInstance(String varName) FOR genmodel::GenClass-»
org.eclipse.emf.ecore.EObject «varName» = «IF !isMapEntry() && isExternalInterface()»(org.eclipse.emf.ecore.EObject) «ENDIF»«EXPAND NewInstance»;
«ENDDEFINE»
«ENDREM»

@


1.6
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d44 1
a44 1
	«IF isExternalInterface(containerClass)-»
d46 1
a46 1
	«ELSE-»
d48 18
a65 1
	«ENDIF-»
@


1.5
log
@minor doc comment
@
text
@d17 1
a17 1
«EXTENSION xpt::GenModelUtils»
d43 6
a48 1
«DEFINE NewInstance FOR GenClass-»
d51 6
a56 1
«DEFINE MetaClass FOR GenClass-»
d59 34
d110 1
a110 1
«getQualifiedInterfaceName()» «assignee» = «EXPAND xpt::Common::getFeatureValue(src, srcMetaClass) FOR srcFeature»;«ENDDEFINE»
d116 1
a116 1
«getQualifiedInterfaceName()» «assignee» = «IF needCast»(«getQualifiedInterfaceName()») «ENDIF»«EXPAND xpt::Common::getFeatureValue(src, srcMetaClass) FOR srcFeature».«srcExt»;«ENDDEFINE»
d131 7
a137 1
«DEFINE Facility FOR Object»
d146 2
@


1.4
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d75 2
a76 2
 * Cast value of type EObject to specific type. Would be no-op with dynamic model instances.
 
@


1.3
log
@[150177] phase I, refactor existing code: special alternatives for EObject.eContainer access; started extracting casts/qualified names when there's solid reason
@
text
@d62 2
d69 8
a76 1
 * Cast value of type EObject to specific type. Would be no-op with dynamic model instances.  
d82 1
@


1.2
log
@[150177] phase I, refactor existing code: better name (DeclareAndAssign instead of CastAndAssign), alternative method that uses feature accessor to get initial value
@
text
@d32 11
d55 4
d66 11
@


1.1
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d41 1
a41 1
«DEFINE CastAndAssign(String assignee, String value) FOR GenClass-»
d44 7
@

