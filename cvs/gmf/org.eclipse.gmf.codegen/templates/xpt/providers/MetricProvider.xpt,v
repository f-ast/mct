head	1.13;
access;
symbols
	v20081022-1925:1.13
	v20081015-1925:1.13
	v20081008-1925:1.12
	v20081001-1925:1.12
	v20080930-1130:1.12
	v20080926-1245:1.12
	v20080924-1925:1.12
	v20080917-1925:1.12
	v20080911-1728:1.12
	v20080910-1520:1.12
	v20080903-1520:1.12
	v20080827-1520:1.12
	v20080813-1520:1.12
	v20080806-1520:1.12
	v20080722-1827:1.12
	v20080718-1731:1.12
	v20080716-1600:1.12
	v20080716-1642:1.12
	R2_1_maintenance:1.12.0.2
	Root_R2_1_maintenance:1.12
	R2_1_0:1.12
	v20080610-1132:1.12
	v20080603-1553:1.12
	v20080528-1052:1.12
	v20080521:1.12
	v20080516-1543:1.11
	v20080516-1143:1.11
	v20080512-1200:1.11
	v20080508-2000:1.11
	v20080507-1326:1.11
	v20080503-1740:1.8
	v20080501-1739:1.7
	v20080425-1959:1.6
	v20080417-1610:1.6
	v20080411-0411:1.6
	v20080404-1111:1.6
	v20080322-0000:1.6
	v20080222-1200:1.2
	v20080215-1500:1.2
	v20080207-0207:1.1.2.1
	v20071222-1111:1.2
	v20071214-1111:1.2
	v20071130-1111:1.2
	v20071124-0000:1.1.2.1
	v20071112-0000:1.2
	v20071108-0000:1.2
	v20071003-0000:1.2
	v20070928-0000:1.1.2.1
	v20070921-0000:1.1.2.1
	v20070915-0000:1.1.2.1
	R2_0_maintenance:1.1.0.2;
locks; strict;
comment	@# @;


1.13
date	2008.10.15.18.01.18;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	b45d48f62fed4567;

1.12
date	2008.05.20.15.45.10;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	29294832f2054567;

1.11
date	2008.05.07.13.56.01;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	39124821b4de4567;

1.10
date	2008.05.05.21.06.41;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	4186481f76b14567;

1.9
date	2008.05.05.15.38.50;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	2fc9481f2a094567;

1.8
date	2008.05.02.18.38.51;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	bd7481b5fbb4567;

1.7
date	2008.04.30.21.03.00;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	8464818de844567;

1.6
date	2008.03.05.17.36.05;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	67ea47ceda044567;

1.5
date	2008.02.29.21.19.52;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	45a447c876f24567;

1.4
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	19d047c419ed4567;

1.3
date	2008.02.22.11.24.53;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	5c9347beb1044567;

1.2
date	2007.09.12.12.22.30;	author dstadnik;	state Exp;
branches;
next	1.1;
commitid	164a46e7da054567;

1.1
date	2007.09.12.12.20.49;	author dstadnik;	state dead;
branches
	1.1.2.1;
next	;
commitid	42c246e7d99f4567;

1.1.2.1
date	2007.09.12.12.20.49;	author dstadnik;	state Exp;
branches;
next	;
commitid	42c246e7d99f4567;


desc
@@


1.13
log
@[249301] Wrap use of assert  into dedicated template
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - refactoring (https://bugs.eclipse.org/230014)
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»

«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::EMFUtils»
«EXTENSION xpt::providers::Metrics»

«DEFINE MetricProvider FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «metricProviderClassName»
		extends org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.AbstractContributionItemProvider {

	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.jface.action.IAction createAction(String actionId,
			org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor partDescriptor) {
		if (MetricsAction.ACTION_KEY.equals(actionId)) {
			return new MetricsAction(partDescriptor);
		}
		return super.createAction(actionId, partDescriptor);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class MetricsAction extends org.eclipse.jface.action.Action {

		«EXPAND xpt::Common::generatedMemberComment»
		public static final String ACTION_KEY = "metricsAction"; //$NON-NLS-1$

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor workbenchPartDescriptor;

		«EXPAND xpt::Common::generatedMemberComment»
		public MetricsAction(org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor workbenchPartDescriptor) {
			setId(ACTION_KEY);
			setText("Metrics");
			this.workbenchPartDescriptor = workbenchPartDescriptor;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void run() {
			org.eclipse.ui.IWorkbenchPart workbenchPart = workbenchPartDescriptor.getPartPage().getActivePart();
			org.eclipse.ui.IViewPart metricsView = null;
			try {
				metricsView = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().findView(«EXPAND resultViewID»);
				if (metricsView == null) {
					metricsView = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(«EXPAND resultViewID»);
				} else {
					if (metricsView != null && workbenchPart instanceof org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart) {
						final org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart part = (org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart) workbenchPart;
						((ResultView) metricsView).setInput(part);
					}
					workbenchPart.getSite().getPage().activate(metricsView);
				}
			} catch (org.eclipse.ui.PartInitException e) {
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Diagram metric view failure", e); //$NON-NLS-1$
			}
		}
	}

«EXPAND calculateMetricsMethods-»

«EXPAND formatNotationElementNameMethod-»
«EXPAND formatSemanticElementNameMethod-»

«EXPAND metricsClasses»

«EXPAND keysAndToolTipsMethods FOR editorGen.metrics»

«EXPAND metricCalcField FOREACH editorGen.metrics.metrics.select(m | m.rule != null && m.target != null && m.target.getContext() != null)»
«EXPAND metricCalcMethod FOREACH editorGen.metrics.metrics.select(m | m.rule != null && m.target != null && m.target.getContext() != null)»

«EXPAND MetricsResultView::Class»

«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE resultViewQualifiedClassName FOR gmfgen::GenDiagram»«providersPackageName».«metricProviderClassName».«EXPAND MetricsResultView::className»«ENDDEFINE» 
«DEFINE resultViewID FOR gmfgen::GenDiagram»«EXPAND resultViewQualifiedClassName».VIEW_ID«ENDDEFINE» 


//////////////////////////////////////////////////////////////////////////

«DEFINE calculateMetricsMethods FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	static java.util.List calculateMetrics(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart diagramPart) {
		final org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart diagramEditPart = diagramPart.getDiagramEditPart();
		try {
			return (java.util.List) diagramPart.getDiagramEditPart().getEditingDomain().runExclusive(
				new org.eclipse.emf.transaction.RunnableWithResult.Impl() {

					public void run() {
						org.eclipse.gmf.runtime.notation.Diagram diagram = diagramEditPart.getDiagramView();
						java.util.ArrayList/*<ElementMetrics>*/ metrics = new java.util.ArrayList/*<ElementMetrics>*/(50);
«IF !getNotationMetrics(editorGen.metrics).isEmpty()-»
						calculateNotationElementMetrics(diagram, metrics);
«ENDIF-»
«IF !getDiagramMetrics(editorGen.metrics).isEmpty()-»
						calculateDiagramElementMetrics(diagram, metrics);
«ENDIF-»
«IF !getDomainMetrics(editorGen.metrics).isEmpty()-»
						calculateSemanticElementMetrics(diagramEditPart, metrics);
«ENDIF-»
						setResult(metrics);
					}
				});
		} catch (InterruptedException e) {
			return java.util.Collections.EMPTY_LIST;
		}
	}

«IF !getNotationMetrics(editorGen.metrics).isEmpty()»«EXPAND calcNotationMetricsMethod FOR editorGen»«ENDIF»
«IF !getDiagramMetrics(editorGen.metrics).isEmpty()»«EXPAND calcDiagramMetricsMethod FOR editorGen»«ENDIF»
«IF !getDomainMetrics(editorGen.metrics).isEmpty()»«EXPAND calcDomainMetricsMethod FOR editorGen»«ENDIF»
«ENDDEFINE»


«DEFINE metricsClasses FOR GenDiagram»
	«EXPAND xpt::Common::generatedMemberComment»
	private static class ElementMetrics {

		«EXPAND xpt::Common::generatedMemberComment»
		final Metric[] metrics;

		«EXPAND xpt::Common::generatedMemberComment»
		final String targetElementQName;

		«EXPAND xpt::Common::generatedMemberComment»
		final org.eclipse.swt.graphics.Image elementImage;

		«EXPAND xpt::Common::generatedMemberComment»
		String diagramElementID; «REM»FIXME add specific constructor for View elements, set diagramElementID from there«ENDREM»

		«EXPAND xpt::Common::generatedMemberComment»
		ElementMetrics(org.eclipse.emf.ecore.EObject target, String name, Metric[] metrics) {
			«EXPAND xpt::Common::assert("metrics.length > 0")-»
			«EXPAND xpt::Common::assert("name != null")-»
			this.metrics = metrics;	
			this.targetElementQName = name;
			org.eclipse.emf.ecore.EClass imageTarget = target.eClass();
			if (target instanceof org.eclipse.gmf.runtime.notation.View) {
				org.eclipse.gmf.runtime.notation.View viewTarget = (org.eclipse.gmf.runtime.notation.View) target;
				if ("".equals(viewTarget.getType()) && viewTarget.getElement() != null) {«EXPAND xpt::Common::nonNLS»
					imageTarget = viewTarget.getElement().eClass();
				}
			}
			this.elementImage = «EXPAND getImageAccessor("imageTarget")»;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		Metric getMetricByKey(String key) {
			for (int i = 0; i < metrics.length; i++) {
				if (metrics[i].key.equals(key)) {
					return metrics[i]; 
				}
			}
			return null;
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class Metric implements Comparable {

		«EXPAND xpt::Common::generatedMemberComment»
		final String key;

		«EXPAND xpt::Common::generatedMemberComment»
		final Double value;

		«EXPAND xpt::Common::generatedMemberComment»
		final Double lowLimit;

		«EXPAND xpt::Common::generatedMemberComment»
		final Double highLimit;

		«EXPAND xpt::Common::generatedMemberComment»
		final String displayValue;

		«EXPAND xpt::Common::generatedMemberComment»
		Metric(String key, Double value) {
			this(key, value, null, null);
		}

		«EXPAND xpt::Common::generatedMemberComment»
		Metric(String key, Double value, Double low, Double high) {
			«EXPAND xpt::Common::assert("key != null")-»
			this.key = key;
			this.value = value;
			this.lowLimit = low;
			this.highLimit = high;
			this.displayValue = (value != null) ? java.text.NumberFormat.getInstance().format(value) : "null"; //$NON-NLS-1$
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public int compareTo(Object other) {
			Metric otherMetric = (Metric) other;
			if (value != null && otherMetric.value != null) {
				return (value.longValue() < otherMetric.value.longValue()) ? -1
						: (value.longValue() == otherMetric.value.longValue() ? 0 : 1);
			}
			return (value == null && otherMetric.value == null) ? 0
					: (value == null) ? -1 : 1;
		}
	}
«ENDDEFINE»

«DEFINE getImageAccessor(String imageClassVar) FOR gmfgen::GenDiagram»«getElementTypesQualifiedClassName()».getImage(«imageClassVar»)«ENDDEFINE»

«DEFINE calcNotationMetricsMethod FOR GenEditorGenerator-»
	«EXPAND xpt::Common::generatedMemberComment»
	static void calculateNotationElementMetrics(org.eclipse.gmf.runtime.notation.Diagram diagram, java.util.List/*<ElementMetrics>*/ metricsList) {
		ElementMetrics row = null;
«LET getNotationMetrics(metrics).select(m | ((GenNotationElementTarget) m.target).element.ecoreClass.name == "Diagram") AS diagramMetrics-»
«IF !diagramMetrics.isEmpty()-»
		row = new ElementMetrics(diagram, formatViewName(diagram), new Metric[] {
«EXPAND metricResult("diagram", false) FOREACH diagramMetrics SEPARATOR ",\n"»
		});
		row.diagramElementID = diagram.eResource().getURIFragment(diagram);
		metricsList.add(row);
«ENDIF-»
«ENDLET-»
«LET getNotationMetrics(metrics).collect(m | ((GenNotationElementTarget) m.target).element).toSet() AS notationTargets»
		for (java.util.Iterator it = diagram.eAllContents(); it.hasNext(); ) {
			Object next = it.next();
«FOREACH notationTargets.typeSelect(GenClass) AS nt-»
			if («EXPAND MetaModel::IsInstance("next") FOR nt») {
				«EXPAND MetaModel::DeclareAndAssign("_" + nt.ecoreClass.name.toLowerCase(), "next", true) FOR nt»
				row = new ElementMetrics(«"_" + nt.ecoreClass.name.toLowerCase()», formatViewName(«"_" + nt.ecoreClass.name.toLowerCase()»), new Metric[] {«-»
				«FOREACH getNotationMetrics(metrics).select(m | ((GenNotationElementTarget) m.target).element == nt) AS m SEPARATOR ","»
					«EXPAND metricResult("_" + nt.ecoreClass.name.toLowerCase(), false) FOR m-»
				«ENDFOREACH»
				});
				row.diagramElementID = «"_" + nt.ecoreClass.name.toLowerCase()».eResource().getURIFragment(«"_" + nt.ecoreClass.name.toLowerCase()»);
				metricsList.add(row);
			}
«ENDFOREACH-»
		}
«ENDLET-»
	}
«ENDDEFINE»

«DEFINE calcDiagramMetricsMethod FOR GenEditorGenerator-»
	«EXPAND xpt::Common::generatedMemberComment»
	static void calculateDiagramElementMetrics(org.eclipse.gmf.runtime.notation.Diagram diagram, java.util.List/*<ElementMetrics>*/ metricsList) {
		org.eclipse.emf.ecore.EObject next = diagram;
		java.util.Iterator/*<EObject>*/ it = diagram.eAllContents();
		do {
			if (next instanceof org.eclipse.gmf.runtime.notation.View) {
				org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) next;
				final int vid = «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall FOR diagram»(view);
				java.util.ArrayList/*<Metric>*/ res = new java.util.ArrayList/*<Metric>*/(5);
				switch (vid) {
«FOREACH getDiagramMetrics(metrics).collect(m | ((GenDiagramElementTarget) m.target).element).flatten().toSet().typeSelect(GenCommonBase) AS cb-»
					case «EXPAND xpt::editor::VisualIDRegistry::visualID FOR cb» : {«-»
«FOREACH getDiagramMetrics(metrics).select(m | ((GenDiagramElementTarget) m.target).element.contains(cb)) AS m»
						res.add(«EXPAND metricResult("view", true) FOR m»);
«ENDFOREACH-»
						break;
					}
«ENDFOREACH-»
				}
				if (!res.isEmpty()) {
					ElementMetrics row = new ElementMetrics(view, formatViewName(view), (Metric[]) res.toArray(new Metric[res.size()]));
					row.diagramElementID = view.eResource().getURIFragment(view);
					metricsList.add(row);
				}
			}
			next = it.hasNext() ? (org.eclipse.emf.ecore.EObject) it.next() : null;
		} while (next != null);
	}
«ENDDEFINE»

/*
 * FIXME:
 * 		for now, keep approach from old implementation, i.e. iterate content
 *		of element associated with diagram. Smarter approach would be
 *		iteration over diagram elements, then accessing their respective
 *		semantic elements (if set), and collecting metrics for them.  
 */
«DEFINE calcDomainMetricsMethod FOR GenEditorGenerator»
	«EXPAND xpt::Common::generatedMemberComment("NOTE: metrics are being collected for domain elements contained in the semantic element associated with diagram view, actual diagram content (elements present there) is not taken into account.")»
	static void calculateSemanticElementMetrics(org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart diagramEditPart, java.util.List/*<ElementMetrics>*/ metricsList) {
		org.eclipse.gmf.runtime.notation.Diagram diagram = diagramEditPart.getDiagramView();
		org.eclipse.emf.ecore.EObject next = diagram.getElement();
		java.util.Iterator/*<EObject>*/ it = next != null ? next.eAllContents() : java.util.Collections.EMPTY_LIST.iterator();
		java.util.HashMap/*<EObject, ElementMetrics>*/ target2row = new java.util.HashMap/*<EObject, ElementMetrics>*/();
		while (next != null) {
			java.util.ArrayList/*<Metric>*/ res = new java.util.ArrayList/*<Metric>*/(5);
«FOREACH metrics.metrics.target.typeSelect(GenDomainElementTarget).element.purgeDups().typeSelect(GenClass) AS e-»
			if («EXPAND MetaModel::MetaClass FOR e».isInstance(next)) {
«FOREACH metrics.metrics.select(m | m.target.getContext() == e) AS m-»
				res.add(«EXPAND metricResult("next", true) FOR m»);
«ENDFOREACH-»
			}
«ENDFOREACH-»
			if (!res.isEmpty()) {
				ElementMetrics row = new ElementMetrics(next, formatElementName(next), (Metric[]) res.toArray(new Metric[res.size()]));
				metricsList.add(row);
				target2row.put(next, row);
			}
			next = it.hasNext() ? (org.eclipse.emf.ecore.EObject) it.next() : null;
		}
		if (!target2row.isEmpty()) { // list was modified, need to process only semantic metrics
			// bind semantic elements to notation
			«diagram.getDiagramEditorUtilQualifiedClassName()».LazyElement2ViewMap element2ViewMap = new «diagram.getDiagramEditorUtilQualifiedClassName()».LazyElement2ViewMap(diagram, target2row.keySet());
			for (java.util.Iterator it2 = target2row.entrySet().iterator(); it2.hasNext();) {
				java.util.Map.Entry entry = (java.util.Map.Entry) it2.next();
				org.eclipse.emf.ecore.EObject semanticElement = (org.eclipse.emf.ecore.EObject) entry.getKey();
				org.eclipse.gmf.runtime.notation.View targetView = «diagram.getDiagramEditorUtilQualifiedClassName()».findView(diagramEditPart, semanticElement, element2ViewMap);
				ElementMetrics elementMetrics = (ElementMetrics) entry.getValue();
				elementMetrics.diagramElementID = targetView.eResource().getURIFragment(targetView);
			}
		}
	}
«ENDDEFINE»

«DEFINE formatNotationElementNameMethod FOR GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static String formatViewName(org.eclipse.gmf.runtime.notation.View viewTarget) {
		StringBuffer notationQNameBuf = new StringBuffer();
		notationQNameBuf.append(formatElementName(viewTarget));
		if (viewTarget.getElement() != null) {
			notationQNameBuf.append("->").append(formatElementName(viewTarget.getElement()));	«EXPAND xpt::Common::nonNLS»
		}
		int visualID = «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall»(viewTarget);
		notationQNameBuf.append('[').append(visualID < 0 ? Integer.toString(System.identityHashCode(viewTarget)) : Integer.toString(visualID)).append(']');
		return notationQNameBuf.toString();
	}
«ENDDEFINE»

«DEFINE formatSemanticElementNameMethod FOR GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static String formatElementName(org.eclipse.emf.ecore.EObject object) {
		return org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(object, true);
	}
«ENDDEFINE»

«DEFINE metricCalcMethod FOR GenMetricRule»
	«EXPAND xpt::Common::generatedMemberComment»
	public static«REM»FIXME: (1) refactor to get rid of statics (2) 'public' only those referenced from audits«ENDREM» Double «calcMethodName()»(«EXPAND calcMethodArgs(this) FOR target») {
		«EXPAND calcMethodBody(this) FOR rule.provider-»
	}
«ENDDEFINE»

«DEFINE calcMethodArgs(GenMetricRule metric) FOR GenMeasurable»«ERROR "Unrecognized metric target: " + this»«ENDDEFINE»

«DEFINE calcMethodArgs(GenMetricRule metric) FOR GenDomainElementTarget»«EXPAND MetaModel::QualifiedClassName FOR element» target«ENDDEFINE»

«REM»
	We do check all elements to be of specific kind to provide most narrow type cast
	However, GenDiagramElementTargetImpl#getContext uses first element's notation class only
«ENDREM»
«DEFINE calcMethodArgs(GenMetricRule metric) FOR GenDiagramElementTarget-»
«IF element.typeSelect(GenNode).size() == element.size()»org.eclipse.gmf.runtime.notation.Node«-»
«ELSEIF element.typeSelect(GenLink).size() == element.size()»org.eclipse.gmf.runtime.notation.Edge«-»
«ELSEIF element.typeSelect(GenDiagram).size() == element.size()»org.eclipse.gmf.runtime.notation.Diagram«-»
«ELSE»org.eclipse.gmf.runtime.notation.View«ENDIF» target«ENDDEFINE»

«REM»Note, use of QualifiedClassName here assumes it always works the same for the notation model, regardless of 'dynamic model' use (i.e. always gives qName of oeg.runtime.notation.* Java class)«ENDREM»
«DEFINE calcMethodArgs(GenMetricRule metric) FOR GenNotationElementTarget»«EXPAND MetaModel::QualifiedClassName FOR element» target«ENDDEFINE»


«DEFINE calcMethodBody(GenMetricRule metric) FOR GenExpressionProviderBase»«ERROR "No idea how to calculate metric\'s value for " + this»«ENDDEFINE»

«DEFINE calcMethodBody(GenMetricRule metric) FOR GenExpressionInterpreter-»
	if («exprFieldName(metric)» == null) {
		«exprFieldName(metric)» = «EXPAND xpt::expressions::getExpression::getExpression(metric.rule, metric.target.getContext())»;
	}
	Object val = «exprFieldName(metric)».evaluate(target);
	if (val instanceof Number) {
		return val.getClass() == Double.class ? (Double) val : new Double(((Number) val).doubleValue());
	}
	return null;
«ENDDEFINE»

«DEFINE calcMethodBody(GenMetricRule metric) FOR GenJavaExpressionProvider-»
«IF injectExpressionBody && metric.rule.body != null && metric.rule.body.length() != 0-»
	«metric.rule.body»
«ELSEIF throwException || (injectExpressionBody && (metric.rule.body == null || metric.rule.body.length() == 0))-»
	// TODO: implement this method
	// Ensure that you remove @@generated or mark it @@generated NOT
	throw new java.lang.UnsupportedOperationException("No user java implementation provided");«EXPAND xpt::Common::nonNLS»
«ELSE-»
	return new Double(Double.NaN);
«ENDIF-»
«ENDDEFINE»

«DEFINE metricCalcField FOR GenMetricRule-»
«EXPAND metricCalcField(this) FOR rule.provider-»
«ENDDEFINE» 

«DEFINE metricCalcField(GenMetricRule metric) FOR GenExpressionProviderBase»«REM»NO-OP«ENDREM»«ENDDEFINE»
«DEFINE metricCalcField(GenMetricRule metric) FOR GenExpressionInterpreter-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static«REM»FIXME: refactor to get rid of static fields«ENDREM» «container.getAbstractExpressionQualifiedClassName()» «exprFieldName(metric)»;
«ENDDEFINE»

«DEFINE invokeCalcMethod(String accessor, boolean isSpecific) FOR GenMetricRule»
«container.editorGen.diagram.getMetricProviderQualifiedClassName()».«calcMethodName()»(«IF !isSpecific /*CastEObject would be better, however need GenClassifier*/»(«EXPAND MetaModel::QualifiedClassName FOR target.getContext()») «ENDIF»«accessor»)«ENDDEFINE»


/*
 * Next two methods should return arrays of identical length, hence are placed into a single template
 */
«DEFINE keysAndToolTipsMethods FOR GenMetricContainer»
	«EXPAND xpt::Common::generatedMemberComment»
	private static String[] getMetricKeys() {
		return new String[] {
			«FOREACH metrics AS m SEPARATOR ",\n"»«toStringLiteral(m.key)»«ENDFOREACH»
		};
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static String[] getMetricToolTips() {
		return new String[] {
			«FOREACH metrics AS m SEPARATOR ",\n"-»
«toStringLiteral(m.name == null ? m.key : m.name)»«IF m.description != null» + '\n' + «toStringLiteral(m.description)» + '\n'«ENDIF»«IF null != m.lowLimit» + «toStringLiteral("low: " + m.lowLimit)»«ENDIF»«IF null != m.highLimit» + «toStringLiteral("high: " + m.highLimit)»«ENDIF-»
			«ENDFOREACH»
		};
	} 
«ENDDEFINE»

«DEFINE metricResult(String targetAccessor, boolean isJustEObject) FOR GenMetricRule-»
new Metric(«toStringLiteral(key)», «calcMethodName()»(«IF isJustEObject && /*safe to assume it is GenClass, nevertheless check*/ !{ target.getContext() }.typeSelect(GenClass).isEmpty()»«EXPAND MetaModel::CastEObject(targetAccessor) FOR (GenClass) target.getContext()»«ELSE»«targetAccessor»«ENDIF»), «IF null == lowLimit»null«ELSE»new Double(«lowLimit»)«ENDIF», «IF null == highLimit»null«ELSE»new Double(«highLimit»)«ENDIF»)
«ENDDEFINE»



«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»@


1.12
log
@[228913], JavaProvider attributes: even if no body is set but throwsException is false, do not generate exception, rather respect throwException==false
@
text
@d152 2
a153 2
			assert metrics.length > 0;
			assert name != null;
d202 1
a202 1
			assert key != null;
@


1.11
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d395 1
a395 1
«ELSEIF throwException || metric.rule.body == null || metric.rule.body.length() == 0-»
@


1.10
log
@[228913] cleaned isCopy and java provider's getOperationName that are not in use any more; introduced fine-tuning options: use expressions body for java methods and whether to throw exception or fail silently (using reasonable/appropriate for the context default value), latter change obsoleted NoImplException and respective debug options
@
text
@d14 1
a14 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
d357 1
a357 1
		«EXPAND calcMethodBody(this) FOR container.editorGen.expressionProviders.getProvider(rule)-»
d405 1
a405 1
«EXPAND metricCalcField(this) FOR container.editorGen.expressionProviders.getProvider(rule)-»
@


1.9
log
@[230014] refactor MetricProvider.xpt
@
text
@d393 3
d398 4
a401 4
	/* Body of value expression:
	 * «metric.rule.body»
	 */«REM»XXX Why not UnsupportedOperationException???«ENDREM»
	throw new «container.getAbstractExpressionQualifiedClassName()».NoImplException("No user java implementation provided"); «EXPAND xpt::Common::nonNLS»
@


1.8
log
@[230014] refactor MetricProvider.xpt
@
text
@d11 1
a30 3
	private static int MAX_VISIBLE_KEY_CHAR_COUNT = 8;

	«EXPAND xpt::Common::generatedMemberComment»
d60 1
a60 1
				metricsView = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().findView(ResultView.VIEW_ID);
d62 1
a62 1
					metricsView = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(ResultView.VIEW_ID);
d65 1
a65 2
						final org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart part =
								(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart) workbenchPart;
d76 25
d131 1
a132 1
«EXPAND resultsViewClass»
d134 1
d151 1
a151 1
		ElementMetrics(org.eclipse.emf.ecore.EObject target, Metric[] metrics) {
d153 1
d155 1
d159 1
a159 5
				StringBuffer notationQNameBuf = new StringBuffer();
				notationQNameBuf.append(org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(viewTarget, true));
				if ("".equals(viewTarget.getType()) && viewTarget.getElement() != null) { //$NON-NLS-1$
					notationQNameBuf.append('-').append('>').append(
							org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(viewTarget.getElement(), true));
a161 7
				int visualID = «getVisualIDRegistryQualifiedClassName()».getVisualID(viewTarget);
				notationQNameBuf.append('[').append(visualID < 0
					? Integer.toString(System.identityHashCode(viewTarget))
					: Integer.toString(visualID)).append(']');
				this.targetElementQName = notationQNameBuf.toString();
			} else {
				this.targetElementQName = org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(target, true);
d163 1
a163 1
			this.elementImage = «getElementTypesQualifiedClassName()».getImage(imageTarget);
a220 8

«EXPAND keysAndToolTipsMethods FOR editorGen.metrics»

«EXPAND metricCalcField FOREACH editorGen.metrics.metrics.select(m | m.rule != null && m.target != null && m.target.getContext() != null)»
«EXPAND metricCalcMethod FOREACH editorGen.metrics.metrics.select(m | m.rule != null && m.target != null && m.target.getContext() != null)»

«EXPAND additions-»
}
d223 1
a223 3

//////////////////////////////////////////////////////////////////////////

d231 1
a231 1
		row = new ElementMetrics(diagram, new Metric[] {
d244 1
a244 1
				row = new ElementMetrics(«"_" + nt.ecoreClass.name.toLowerCase()», new Metric[] {«-»
d279 1
a279 1
					ElementMetrics row = new ElementMetrics(view, (Metric[]) res.toArray(new Metric[res.size()]));
d313 1
a313 1
				ElementMetrics row = new ElementMetrics(next, (Metric[]) res.toArray(new Metric[res.size()]));
d333 20
a441 213
////////////////////////////////
//					 ResultView
//
«DEFINE resultsViewClass FOR GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static class ResultView extends org.eclipse.ui.part.ViewPart {

		«EXPAND xpt::Common::generatedMemberComment»
		public static final String VIEW_ID = "«getMetricViewID()»"; //$NON-NLS-1$

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.jface.viewers.TableViewer viewer;

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.emf.ecore.resource.Resource diagramResource;

		«EXPAND xpt::Common::generatedMemberComment»
	    void setInput(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart diagramPart) {
			diagramResource = diagramPart.getDiagram().eResource();
			setTitleToolTip(diagramResource.getURI().path());
			java.util.List metrics = calculateMetrics(diagramPart);
	    	adjustLayout(metrics);
	    	viewer.setInput(metrics); 
	    }

		«EXPAND xpt::Common::generatedMemberComment»
	    private void adjustLayout(java.util.List metricResultList) {
	    	java.util.Map maxValStrMap = calcMetricMaxValueStrLenMap(metricResultList);
			org.eclipse.swt.widgets.Table table = viewer.getTable();
			org.eclipse.jface.viewers.TableLayout layout = new org.eclipse.jface.viewers.TableLayout();
			org.eclipse.swt.graphics.GC gc = new org.eclipse.swt.graphics.GC(table);
			gc.setFont(org.eclipse.jface.resource.JFaceResources.getDialogFont());
			int padding = gc.stringExtent("X").x * 2; //$NON-NLS-1$
			for (int i = 0; i < getMetricKeys().length; i++) {
				final String nextKey = getMetricKeys()[i];
				String valueStr = (String) maxValStrMap.get(nextKey);
				int minWidth = valueStr != null ? gc.stringExtent(valueStr).x + padding : 20;
				layout.addColumnData(new org.eclipse.jface.viewers.ColumnPixelData(minWidth, true));
			}
			gc.dispose();
			layout.addColumnData(new org.eclipse.jface.viewers.ColumnWeightData(1, 50, true));
			viewer.getTable().setLayout(layout);
			viewer.getTable().layout(true, true);
	    }

		«EXPAND xpt::Common::generatedMemberComment»
		public void createPartControl(org.eclipse.swt.widgets.Composite parent) {
			this.viewer = new org.eclipse.jface.viewers.TableViewer(parent, org.eclipse.swt.SWT.FULL_SELECTION);
			final org.eclipse.swt.widgets.Table table = viewer.getTable();
			table.setHeaderVisible(true);
			table.setLinesVisible(true);
			for (int i = 0; i < getMetricKeys().length; i++) {
				org.eclipse.swt.widgets.TableColumn column = new org.eclipse.swt.widgets.TableColumn(table, org.eclipse.swt.SWT.NONE);
				column.setAlignment(org.eclipse.swt.SWT.RIGHT);
				column.setMoveable(true);
				column.setText(getMetricKeys()[i]);
				column.setToolTipText(getMetricToolTips()[i]);
			}
			org.eclipse.swt.widgets.TableColumn objectColumn = new org.eclipse.swt.widgets.TableColumn(table, org.eclipse.swt.SWT.NONE);
			objectColumn.setText("Element");
			objectColumn.setToolTipText("Measurement element");
			viewer.setLabelProvider(new Labels());
			viewer.setContentProvider(new org.eclipse.jface.viewers.ArrayContentProvider());
			viewer.addOpenListener(new org.eclipse.jface.viewers.IOpenListener() {

				public void open(org.eclipse.jface.viewers.OpenEvent event) {
					handleOpen(event);
				}
			});
			org.eclipse.swt.events.SelectionListener headerSelListener = new org.eclipse.swt.events.SelectionListener() {

				public void widgetSelected(org.eclipse.swt.events.SelectionEvent e) {
					table.setSortColumn((org.eclipse.swt.widgets.TableColumn) e.getSource());  
					table.setSortDirection((table.getSortDirection() != org.eclipse.swt.SWT.DOWN) ? org.eclipse.swt.SWT.DOWN : org.eclipse.swt.SWT.UP);
					viewer.refresh();
				}

				public void widgetDefaultSelected(org.eclipse.swt.events.SelectionEvent e) {
				}
			};
			org.eclipse.swt.widgets.TableColumn[] columns = viewer.getTable().getColumns();
			for (int i = 0; i < columns.length; i++) {
				columns[i].addSelectionListener(headerSelListener);
			}
			viewer.setSorter(new org.eclipse.jface.viewers.ViewerSorter() {

				public int compare(org.eclipse.jface.viewers.Viewer viewer, Object e1, Object e2) {
					org.eclipse.swt.widgets.TableColumn c = table.getSortColumn();
					int result = 0;
					if (c != null) {
						Metric mc1 = ((ElementMetrics) e1).getMetricByKey(c.getText());
						Metric mc2 = ((ElementMetrics) e2).getMetricByKey(c.getText());
						result = (mc1 != null && mc2 != null) ?
							mc1.compareTo(mc2) : (mc1 == null ? -1 : 1);
					} else {
						result = ((ElementMetrics) e1).targetElementQName.compareTo(((ElementMetrics) e2).targetElementQName);
					}
					return table.getSortDirection() == org.eclipse.swt.SWT.DOWN ? result : -result;
				}
			});
	        org.eclipse.ui.IEditorPart editor = getSite().getPage().getActiveEditor();
	        if (editor != null && editor.getClass().equals(«editorGen.editor.getQualifiedClassName()».class)) {
				setInput((«editorGen.editor.getQualifiedClassName()») editor);
	        }
		}

		«EXPAND xpt::Common::generatedMemberComment»
		private void handleOpen(org.eclipse.jface.viewers.OpenEvent event) {
			try {
				org.eclipse.ui.IEditorPart editorPart = getSite().getPage().openEditor(
						new org.eclipse.ui.part.FileEditorInput(org.eclipse.emf.workspace.util.WorkspaceSynchronizer.getFile(diagramResource)),
						«editorGen.editor.getQualifiedClassName()».ID);
				if (editorPart == null) {
					return;
				}
				org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart diagramPart =
						(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart) editorPart.getAdapter(
								org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart.class);
				ElementMetrics selection = (ElementMetrics) ((org.eclipse.jface.viewers.IStructuredSelection) event.getSelection()).getFirstElement();
				String viewID = selection.diagramElementID;
				if (viewID != null) {
					org.eclipse.gmf.runtime.notation.View targetView =
							(org.eclipse.gmf.runtime.notation.View) diagramPart.getDiagram().eResource().getEObject(viewID);
					if (targetView != null) {
						org.eclipse.gef.EditPart targetEditPart =
								(org.eclipse.gef.EditPart) diagramPart.getDiagramGraphicalViewer().getEditPartRegistry().get(targetView);
						if (targetEditPart != null) {
							«getDiagramEditorUtilQualifiedClassName()».selectElementsInDiagram(
									diagramPart, java.util.Collections.singletonList(targetEditPart));
						}
					}
				}
			} catch (org.eclipse.ui.PartInitException e) {
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Can't open diagram editor", e); //$NON-NLS-1$
			}
		}

		«EXPAND xpt::Common::generatedMemberComment»
		private static java.util.Map calcMetricMaxValueStrLenMap(java.util.List allMetrics) {
			java.util.Map metric2MaxStrLen = new java.util.HashMap();
			for (int i = 0; i < getMetricKeys().length; i++) {
				String nextKey = getMetricKeys()[i]; 
				int trimPos = Math.min(nextKey.length(), MAX_VISIBLE_KEY_CHAR_COUNT);
				metric2MaxStrLen.put(nextKey, nextKey.substring(0, trimPos));
			}
			for (java.util.Iterator it = allMetrics.iterator(); it.hasNext();) {
				ElementMetrics elementMetrics = (ElementMetrics) it.next();
				for (int i = 0; i < elementMetrics.metrics.length; i++) {
					Metric metric = elementMetrics.metrics[i];
					String valueStr = (String) metric2MaxStrLen.get(metric.key);
					if (valueStr == null || metric.displayValue.length() > valueStr.length()) {
						metric2MaxStrLen.put(metric.key, metric.displayValue);	
					}
				}
			}
			return metric2MaxStrLen;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void setFocus() {
		}

		«EXPAND xpt::Common::generatedMemberComment»
		private class Labels extends org.eclipse.jface.viewers.LabelProvider
				implements org.eclipse.jface.viewers.ITableLabelProvider, org.eclipse.jface.viewers.ITableColorProvider {

			«EXPAND xpt::Common::generatedMemberComment»
			private boolean isElementColumn(int columnIndex) {
				return columnIndex >= getMetricKeys().length;
			}

			«EXPAND xpt::Common::generatedMemberComment»
			public org.eclipse.swt.graphics.Image getColumnImage(Object element, int columnIndex) {
				return isElementColumn(columnIndex) ? ((ElementMetrics) element).elementImage : null;
			}

			«EXPAND xpt::Common::generatedMemberComment»
			public String getColumnText(Object element, int columnIndex) {
				ElementMetrics elementMetrics = (ElementMetrics) element;
				if (columnIndex == getMetricKeys().length) {
					return elementMetrics.targetElementQName;
				}
				final String key = getMetricKeys()[columnIndex];
				Metric metric = elementMetrics.getMetricByKey(key);
				return (metric != null) ? metric.displayValue : "-"; //$NON-NLS-1$
			}

			«EXPAND xpt::Common::generatedMemberComment»
			public org.eclipse.swt.graphics.Color getBackground(Object element, int columnIndex) {
				return null; 
			}

			«EXPAND xpt::Common::generatedMemberComment»
			public org.eclipse.swt.graphics.Color getForeground(Object element, int columnIndex) {
				if (isElementColumn(columnIndex)) {
					return null;
				}
				ElementMetrics columnElement = (ElementMetrics) element;
				final String key = getMetricKeys()[columnIndex];
				Metric metric = columnElement.getMetricByKey(key);
				if (metric != null && metric.value != null) {
					if (metric.highLimit != null && metric.highLimit.longValue() < metric.value.longValue()) {
						return org.eclipse.draw2d.ColorConstants.red;
					} else if (metric.lowLimit != null && metric.lowLimit.longValue() > metric.value.longValue()) {
						return org.eclipse.draw2d.ColorConstants.blue;
					}
				}
				return null;
			}
		}		
	}
«ENDDEFINE»

@


1.7
log
@[228913] item #5: clean getExpression, refactor its use
@
text
@d15 2
d19 1
a29 9
	private static java.util.HashMap context2MetricsMap;

	«EXPAND xpt::Common::generatedMemberComment»
	private static java.util.List metricsRegistry;

	«EXPAND xpt::Common::generatedMemberComment»
	private static java.util.HashMap key2MetricMap;

	«EXPAND xpt::Common::generatedMemberComment»
d88 10
a97 18
						java.util.List metrics = calculateMetrics(diagram, new java.util.ArrayList(50));
						if (diagram.getElement() != null) {
							calculateMetrics(diagram.getElement(), metrics);
						}
						// detach from EObject and bind to viewID
						java.util.HashSet elements = new java.util.HashSet();
						for (java.util.Iterator it = metrics.iterator(); it.hasNext();) {
							ElementMetrics elementMetrics = (ElementMetrics) it.next();
							elements.add(elementMetrics.target);
						}
						«getDiagramEditorUtilQualifiedClassName()».LazyElement2ViewMap element2ViewMap =
								new «getDiagramEditorUtilQualifiedClassName()».LazyElement2ViewMap(diagram, elements);
						for (java.util.Iterator it = metrics.iterator(); it.hasNext();) {
							ElementMetrics elementMetrics = (ElementMetrics) it.next();
							org.eclipse.gmf.runtime.notation.View targetView = «getDiagramEditorUtilQualifiedClassName()».findView(diagramEditPart, elementMetrics.target, element2ViewMap);
							elementMetrics.target = null; // detach EObject
							elementMetrics.diagramElementID = targetView.eResource().getURIFragment(targetView);
						}
d106 6
d113 4
a116 3
	static java.util.List calculateMetrics(org.eclipse.emf.ecore.EObject target, java.util.List metricsList) {
		final org.eclipse.emf.ecore.EObject root = target;
		java.util.Iterator it = new java.util.Iterator() {
d118 2
a119 2
			java.util.Iterator contentsIt = root.eAllContents();
			boolean isInRoot = true;
d121 27
a147 2
			public boolean hasNext() {
				return isInRoot || contentsIt.hasNext();
d149 2
d152 5
a156 4
			public Object next() {
				if (isInRoot) {
					isInRoot = false;
					return root;
a157 1
				return contentsIt.next();
d159 57
d217 30
a246 2
			public void remove() {
				throw new UnsupportedOperationException();
d248 23
a270 18
		};
		java.util.ArrayList metricsPerContext = new java.util.ArrayList();
		while (it.hasNext()) {
			Object nextElement = it.next();
			if (nextElement instanceof org.eclipse.emf.ecore.EObject) {
				org.eclipse.emf.ecore.EObject nextEObj = (org.eclipse.emf.ecore.EObject) nextElement;
				org.eclipse.emf.ecore.EClass nextTarget = nextEObj.eClass();
				java.util.Iterator superTypeIt = nextTarget.getEAllSuperTypes().iterator();
				while (nextTarget != null) {
					java.util.List metricList = getMetricsForTarget(nextTarget);
					if (metricList != null) {
						for (java.util.Iterator metricIt = metricList.iterator(); metricIt.hasNext();) {
							MetricDef nextMetric = (MetricDef) metricIt.next();
							if (nextMetric.appliesTo(nextEObj)) {
								Metric metric = new Metric(nextMetric, nextEObj);
								metricsPerContext.add(metric);
							}
						}
d272 1
a272 1
					nextTarget = superTypeIt.hasNext() ? (org.eclipse.emf.ecore.EClass) superTypeIt.next() : null; 
d274 4
a277 3
				if (!metricsPerContext.isEmpty()) {
					metricsList.add(new ElementMetrics(nextEObj, (Metric[]) metricsPerContext.toArray(new Metric[metricsPerContext.size()])));
					metricsPerContext.clear();
d280 45
a325 1
		return metricsList;
d327 1
d329 93
d451 3
a453 3
			for (int i = 0; i < getMetrics().size(); i++) {
				MetricDef nextMetric = (MetricDef) getMetrics().get(i);
				String valueStr = (String) maxValStrMap.get(nextMetric.key);
d469 1
a469 2
			for (int i = 0; i < getMetrics().size(); i++) {
				MetricDef nextMetric = ((MetricDef) getMetrics().get(i));
d473 2
a474 2
				column.setText(nextMetric.key);
				column.setToolTipText(nextMetric.getToolTipText());
d558 2
a559 2
			for (int i = 0; i < getMetrics().size(); i++) {
				String nextKey = ((MetricDef) getMetrics().get(i)).key; 
d567 1
a567 1
					String valueStr = (String) metric2MaxStrLen.get(metric.def.key);
d569 1
a569 1
						metric2MaxStrLen.put(metric.def.key, metric.displayValue);	
d586 1
a586 1
				return columnIndex >= getMetrics().size();
d597 1
a597 1
				if (columnIndex == getMetrics().size()) {
d600 1
a600 1
				String key = ((MetricDef) getMetrics().get(columnIndex)).key;
d616 1
a616 1
				String key = ((MetricDef) getMetrics().get(columnIndex)).key;
d619 1
a619 1
					if (metric.def.highLimit != null && metric.def.highLimit.longValue() < metric.value.longValue()) {
d621 1
a621 1
					} else if (metric.def.lowLimit != null && metric.def.lowLimit.longValue() > metric.value.longValue()) {
a628 244

	«EXPAND xpt::Common::generatedMemberComment»
	private static class ElementMetrics {

		«EXPAND xpt::Common::generatedMemberComment»
		final Metric[] metrics;

		«EXPAND xpt::Common::generatedMemberComment»
		final String targetElementQName;

		«EXPAND xpt::Common::generatedMemberComment»
		final org.eclipse.swt.graphics.Image elementImage;

		«EXPAND xpt::Common::generatedMemberComment»
		String diagramElementID;

		«EXPAND xpt::Common::generatedMemberComment»
		org.eclipse.emf.ecore.EObject target;

		«EXPAND xpt::Common::generatedMemberComment»
		ElementMetrics(org.eclipse.emf.ecore.EObject target, Metric[] metrics) {
			this.metrics = metrics;	
			assert metrics.length > 0;
			this.target = target;
			org.eclipse.emf.ecore.EClass imageTarget = target.eClass();
			if (target instanceof org.eclipse.gmf.runtime.notation.View) {
				org.eclipse.gmf.runtime.notation.View viewTarget = (org.eclipse.gmf.runtime.notation.View) target;
				StringBuffer notationQNameBuf = new StringBuffer();
				notationQNameBuf.append(org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(viewTarget, true));
				if ("".equals(viewTarget.getType()) && viewTarget.getElement() != null) { //$NON-NLS-1$
					notationQNameBuf.append('-').append('>').append(
							org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(viewTarget.getElement(), true));
					imageTarget = viewTarget.getElement().eClass();
				}
				int visualID = «getVisualIDRegistryQualifiedClassName()».getVisualID(viewTarget);
				notationQNameBuf.append('[').append(visualID < 0
					? Integer.toString(System.identityHashCode(viewTarget))
					: Integer.toString(visualID)).append(']');
				this.targetElementQName = notationQNameBuf.toString();
			} else {
				this.targetElementQName = org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(target, true);
			}
			this.elementImage = «getElementTypesQualifiedClassName()».getImage(imageTarget);
		}

		«EXPAND xpt::Common::generatedMemberComment»
		Metric getMetricByKey(String key) {
			for (int i = 0; i < metrics.length; i++) {
				if (metrics[i].def.key.equals(key)) {
					return metrics[i]; 
				}
			}
			return null;
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class Metric implements Comparable {

		«EXPAND xpt::Common::generatedMemberComment»
		final MetricDef def;

		«EXPAND xpt::Common::generatedMemberComment»
		final Number value;

		«EXPAND xpt::Common::generatedMemberComment»
		final String displayValue;

		«EXPAND xpt::Common::generatedMemberComment»
		Metric(MetricDef def, org.eclipse.emf.ecore.EObject target) {
			this.def = def;
			value = def.calcMetric(target);
			this.displayValue = (value != null) ? java.text.NumberFormat.getInstance().format(value) : "null"; //$NON-NLS-1$
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public int compareTo(Object other) {
			Metric otherMetric = (Metric) other;
			if (value != null && otherMetric.value != null) {
				return (value.longValue() < otherMetric.value.longValue()) ? -1
						: (value.longValue() == otherMetric.value.longValue() ? 0 : 1);
			}
			return (value == null && otherMetric.value == null) ? 0
					: (value == null) ? -1 : 1;
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class MetricDef {

		«EXPAND xpt::Common::generatedMemberComment»
		final Double lowLimit;

		«EXPAND xpt::Common::generatedMemberComment»
		final Double highLimit;

		«EXPAND xpt::Common::generatedMemberComment»
		final String key;

		«EXPAND xpt::Common::generatedMemberComment»
		final «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression;

		«EXPAND xpt::Common::generatedMemberComment»
		final int[] semanticIDs;

		«EXPAND xpt::Common::generatedMemberComment»
		final String name;

		«EXPAND xpt::Common::generatedMemberComment»
		final String description;

		«EXPAND xpt::Common::generatedMemberComment»
		MetricDef(String key, «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression, int[] semanticIDs,
			Double low, Double high, String name, String description) {
			this.key = key;
			this.expression = expression;
			this.semanticIDs = semanticIDs;
			this.lowLimit = low;
			this.highLimit = high;
			this.name = name;
			this.description = description;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		Number calcMetric(Object contextInstance) {
			Object val = expression.evaluate(contextInstance);
			return (val instanceof Number) ? (Number) val : null;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		boolean appliesTo(org.eclipse.emf.ecore.EObject eObject) {
			if (eObject instanceof org.eclipse.gmf.runtime.notation.View && semanticIDs != null) {
				int eObjectID = «getVisualIDRegistryQualifiedClassName()».getVisualID((org.eclipse.gmf.runtime.notation.View) eObject); 
				for (int i = 0; i < semanticIDs.length; i++) {
					if (semanticIDs[i] == eObjectID) {
						return true;
					}
				}
				return false;
			}
			return eObject != null && (expression.context() instanceof org.eclipse.emf.ecore.EClass) &&
				((org.eclipse.emf.ecore.EClass) expression.context()).isSuperTypeOf(eObject.eClass());
		}

		«EXPAND xpt::Common::generatedMemberComment»
		String getToolTipText() {
			StringBuffer buf = new StringBuffer();
			if (name != null) {
				buf.append(name);
			}
			if (description != null) {
				buf.append('\n').append(description).append('\n');
			}
			if (lowLimit != null) {
				buf.append("low:").append(lowLimit);
			}
			if (highLimit != null) {
				buf.append(" high:").append(highLimit);
			}
			return buf.toString();
		}	
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static java.util.List/*MetricDef*/ getMetricsForTarget(org.eclipse.emf.ecore.EClass target) {
		if (context2MetricsMap == null) {
			initializeRegistry();
		}
		return (java.util.List) context2MetricsMap.get(target);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static java.util.List getMetrics() {
		if (metricsRegistry == null) {
			initializeRegistry();
		}
		return metricsRegistry;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static Number calculateMetric(String metricKey, Object contextInstance) {
		if (key2MetricMap == null) {
			initializeRegistry();
		}
		MetricDef metric = (MetricDef) key2MetricMap.get(metricKey);
		Number value = (metric != null) ? metric.calcMetric(contextInstance) : null;
		return (value != null && !(value instanceof Double)) ? new Double(value.doubleValue()) : value;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static void initializeRegistry() {
	«IF editorGen.expressionProviders != null-»
		if (context2MetricsMap != null) {
			return;
		}
		«FOREACH editorGen.metrics.metrics AS nextMetric-»
			«IF null != nextMetric.rule && null != nextMetric.target && null != nextMetric.target.getContext()-»
		register(new MetricDef(«toStringLiteral(nextMetric.key)»,
				«EXPAND initializerExpr(nextMetric.rule, nextMetric.target.getContext()) FOR editorGen.expressionProviders.getProvider(nextMetric.rule)»,
				«IF null == nextMetric.target»null«ELSE»«EXPAND ids FOR nextMetric.target»«ENDIF»,
				«IF null == nextMetric.lowLimit»null«ELSE»new Double(«nextMetric.lowLimit»)«ENDIF»,
				«IF null == nextMetric.highLimit»null«ELSE»new Double(«nextMetric.highLimit»)«ENDIF»,
				«toStringLiteral(nextMetric.name)»,
				«toStringLiteral(nextMetric.description)»));
			«ENDIF-»
		«ENDFOREACH-»
	«ENDIF-»
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static void register(MetricDef metric) {
		if (context2MetricsMap == null) {
			context2MetricsMap = new java.util.HashMap();
			metricsRegistry = new java.util.ArrayList();
			key2MetricMap = new java.util.HashMap();
		}
		java.util.List metrics = (java.util.List) context2MetricsMap.get(metric.expression.context());
		if (metrics == null) {
			metrics = new java.util.ArrayList();
			context2MetricsMap.put(metric.expression.context(), metrics);
		}
		metricsRegistry.add(metric);
		metrics.add(metric);
		key2MetricMap.put(metric.key, metric);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class JavaRules {
	«IF editorGen.expressionProviders != null-»
		«FOREACH editorGen.metrics.metrics AS nextMetric-»
			«IF null != nextMetric.rule && null != nextMetric.target && null != nextMetric.target.getContext()-»
				«EXPAND javaInitializer(nextMetric.rule, nextMetric.target.getContext(), null) FOR editorGen.expressionProviders.getProvider(nextMetric.rule)-»
			«ENDIF-»
		«ENDFOREACH-»
	«ENDIF-»
	}
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE ids FOR GenMeasurable-»
	null
d631 1
a631 30
«DEFINE ids FOR GenDiagramElementTarget-»
	new int[] {
	«FOREACH element AS element-»
		«element.getEditPartQualifiedClassName()».VISUAL_ID,
	«ENDFOREACH-»
	}
«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionProviderBase»«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionInterpreter-»
«EXPAND xpt::expressions::getExpression::getExpression(valueExpr, exprContext)-»
«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenJavaExpressionProvider-»
	new «container.getAbstractExpressionQualifiedClassName()»(«EXPAND MetaModel::MetaClass FOR exprContext») {

		protected Object doEvaluate(Object context, java.util.Map env) {
			«EXPAND MetaModel::DeclareAndAssign("self", "context", true) FOR exprContext»
			return JavaRules.«getOperationName(valueExpr)»(self);
		}
	}
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpr, context, oppositeEndContext)-»
«ENDDEFINE»
@


1.6
log
@do not enforce line breaks
@
text
@d635 1
a635 2
«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»
d638 1
a638 1
	«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», «EXPAND MetaModel::MetaClass FOR exprContext»)
@


1.5
log
@[150177] phase IV, fix last use of qualified class names in ElementInitializers (via GMFGen genmodel java methods). Cleaned genmodel of methods no longer in use, few methods moved to ElementInitializer.ext (pending removal/refactoring)
@
text
@d639 1
a639 2
	«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», //$NON-NLS-1$
		«EXPAND MetaModel::MetaClass FOR exprContext»)
@


1.4
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d647 1
a647 1
			«getQualifiedInstanceClassName(exprContext)» self = («getQualifiedInstanceClassName(exprContext)») context;
@


1.3
log
@[150177] phase I, refactor existing code: use same template for metainfo access
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d640 1
a640 1
		«EXPAND xpt::Common::metaClassAccessor FOR exprContext»)
d644 1
a644 1
	new «container.getAbstractExpressionQualifiedClassName()»(«EXPAND xpt::Common::metaClassAccessor FOR exprContext») {
@


1.2
log
@rewrite metric provider in xpand
@
text
@d640 1
a640 1
		«getQualifiedClassifierAccessor(exprContext)»())
d644 1
a644 1
	new «container.getAbstractExpressionQualifiedClassName()»(«getQualifiedClassifierAccessor(exprContext)»()) {
@


1.1
log
@file MetricProvider.xpt was initially added on branch R2_0_maintenance.
@
text
@d1 658
@


1.1.2.1
log
@rewrite metric provider in xpand
@
text
@a0 658
/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::EMFUtils»

«DEFINE MetricProvider FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «providersPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «metricProviderClassName»
		extends org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.AbstractContributionItemProvider {

	«EXPAND xpt::Common::generatedMemberComment»
	private static java.util.HashMap context2MetricsMap;

	«EXPAND xpt::Common::generatedMemberComment»
	private static java.util.List metricsRegistry;

	«EXPAND xpt::Common::generatedMemberComment»
	private static java.util.HashMap key2MetricMap;

	«EXPAND xpt::Common::generatedMemberComment»
	private static int MAX_VISIBLE_KEY_CHAR_COUNT = 8;

	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.jface.action.IAction createAction(String actionId,
			org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor partDescriptor) {
		if (MetricsAction.ACTION_KEY.equals(actionId)) {
			return new MetricsAction(partDescriptor);
		}
		return super.createAction(actionId, partDescriptor);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class MetricsAction extends org.eclipse.jface.action.Action {

		«EXPAND xpt::Common::generatedMemberComment»
		public static final String ACTION_KEY = "metricsAction"; //$NON-NLS-1$

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor workbenchPartDescriptor;

		«EXPAND xpt::Common::generatedMemberComment»
		public MetricsAction(org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor workbenchPartDescriptor) {
			setId(ACTION_KEY);
			setText("Metrics");
			this.workbenchPartDescriptor = workbenchPartDescriptor;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void run() {
			org.eclipse.ui.IWorkbenchPart workbenchPart = workbenchPartDescriptor.getPartPage().getActivePart();
			org.eclipse.ui.IViewPart metricsView = null;
			try {
				metricsView = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().findView(ResultView.VIEW_ID);
				if (metricsView == null) {
					metricsView = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(ResultView.VIEW_ID);
				} else {
					if (metricsView != null && workbenchPart instanceof org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart) {
						final org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart part =
								(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart) workbenchPart;
						((ResultView) metricsView).setInput(part);
					}
					workbenchPart.getSite().getPage().activate(metricsView);
				}
			} catch (org.eclipse.ui.PartInitException e) {
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Diagram metric view failure", e); //$NON-NLS-1$
			}
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	static java.util.List calculateMetrics(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart diagramPart) {
		final org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart diagramEditPart = diagramPart.getDiagramEditPart();
		try {
			return (java.util.List) diagramPart.getDiagramEditPart().getEditingDomain().runExclusive(
				new org.eclipse.emf.transaction.RunnableWithResult.Impl() {

					public void run() {
						org.eclipse.gmf.runtime.notation.Diagram diagram = diagramEditPart.getDiagramView();
						java.util.List metrics = calculateMetrics(diagram, new java.util.ArrayList(50));
						if (diagram.getElement() != null) {
							calculateMetrics(diagram.getElement(), metrics);
						}
						// detach from EObject and bind to viewID
						java.util.HashSet elements = new java.util.HashSet();
						for (java.util.Iterator it = metrics.iterator(); it.hasNext();) {
							ElementMetrics elementMetrics = (ElementMetrics) it.next();
							elements.add(elementMetrics.target);
						}
						«getDiagramEditorUtilQualifiedClassName()».LazyElement2ViewMap element2ViewMap =
								new «getDiagramEditorUtilQualifiedClassName()».LazyElement2ViewMap(diagram, elements);
						for (java.util.Iterator it = metrics.iterator(); it.hasNext();) {
							ElementMetrics elementMetrics = (ElementMetrics) it.next();
							org.eclipse.gmf.runtime.notation.View targetView = «getDiagramEditorUtilQualifiedClassName()».findView(diagramEditPart, elementMetrics.target, element2ViewMap);
							elementMetrics.target = null; // detach EObject
							elementMetrics.diagramElementID = targetView.eResource().getURIFragment(targetView);
						}
						setResult(metrics);
					}
				});
		} catch (InterruptedException e) {
			return java.util.Collections.EMPTY_LIST;
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	static java.util.List calculateMetrics(org.eclipse.emf.ecore.EObject target, java.util.List metricsList) {
		final org.eclipse.emf.ecore.EObject root = target;
		java.util.Iterator it = new java.util.Iterator() {

			java.util.Iterator contentsIt = root.eAllContents();
			boolean isInRoot = true;

			public boolean hasNext() {
				return isInRoot || contentsIt.hasNext();
			}

			public Object next() {
				if (isInRoot) {
					isInRoot = false;
					return root;
				}
				return contentsIt.next();
			}

			public void remove() {
				throw new UnsupportedOperationException();
			}
		};
		java.util.ArrayList metricsPerContext = new java.util.ArrayList();
		while (it.hasNext()) {
			Object nextElement = it.next();
			if (nextElement instanceof org.eclipse.emf.ecore.EObject) {
				org.eclipse.emf.ecore.EObject nextEObj = (org.eclipse.emf.ecore.EObject) nextElement;
				org.eclipse.emf.ecore.EClass nextTarget = nextEObj.eClass();
				java.util.Iterator superTypeIt = nextTarget.getEAllSuperTypes().iterator();
				while (nextTarget != null) {
					java.util.List metricList = getMetricsForTarget(nextTarget);
					if (metricList != null) {
						for (java.util.Iterator metricIt = metricList.iterator(); metricIt.hasNext();) {
							MetricDef nextMetric = (MetricDef) metricIt.next();
							if (nextMetric.appliesTo(nextEObj)) {
								Metric metric = new Metric(nextMetric, nextEObj);
								metricsPerContext.add(metric);
							}
						}
					}
					nextTarget = superTypeIt.hasNext() ? (org.eclipse.emf.ecore.EClass) superTypeIt.next() : null; 
				}
				if (!metricsPerContext.isEmpty()) {
					metricsList.add(new ElementMetrics(nextEObj, (Metric[]) metricsPerContext.toArray(new Metric[metricsPerContext.size()])));
					metricsPerContext.clear();
				}
			}
		}
		return metricsList;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static class ResultView extends org.eclipse.ui.part.ViewPart {

		«EXPAND xpt::Common::generatedMemberComment»
		public static final String VIEW_ID = "«getMetricViewID()»"; //$NON-NLS-1$

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.jface.viewers.TableViewer viewer;

		«EXPAND xpt::Common::generatedMemberComment»
		private org.eclipse.emf.ecore.resource.Resource diagramResource;

		«EXPAND xpt::Common::generatedMemberComment»
	    void setInput(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart diagramPart) {
			diagramResource = diagramPart.getDiagram().eResource();
			setTitleToolTip(diagramResource.getURI().path());
			java.util.List metrics = calculateMetrics(diagramPart);
	    	adjustLayout(metrics);
	    	viewer.setInput(metrics); 
	    }

		«EXPAND xpt::Common::generatedMemberComment»
	    private void adjustLayout(java.util.List metricResultList) {
	    	java.util.Map maxValStrMap = calcMetricMaxValueStrLenMap(metricResultList);
			org.eclipse.swt.widgets.Table table = viewer.getTable();
			org.eclipse.jface.viewers.TableLayout layout = new org.eclipse.jface.viewers.TableLayout();
			org.eclipse.swt.graphics.GC gc = new org.eclipse.swt.graphics.GC(table);
			gc.setFont(org.eclipse.jface.resource.JFaceResources.getDialogFont());
			int padding = gc.stringExtent("X").x * 2; //$NON-NLS-1$
			for (int i = 0; i < getMetrics().size(); i++) {
				MetricDef nextMetric = (MetricDef) getMetrics().get(i);
				String valueStr = (String) maxValStrMap.get(nextMetric.key);
				int minWidth = valueStr != null ? gc.stringExtent(valueStr).x + padding : 20;
				layout.addColumnData(new org.eclipse.jface.viewers.ColumnPixelData(minWidth, true));
			}
			gc.dispose();
			layout.addColumnData(new org.eclipse.jface.viewers.ColumnWeightData(1, 50, true));
			viewer.getTable().setLayout(layout);
			viewer.getTable().layout(true, true);
	    }

		«EXPAND xpt::Common::generatedMemberComment»
		public void createPartControl(org.eclipse.swt.widgets.Composite parent) {
			this.viewer = new org.eclipse.jface.viewers.TableViewer(parent, org.eclipse.swt.SWT.FULL_SELECTION);
			final org.eclipse.swt.widgets.Table table = viewer.getTable();
			table.setHeaderVisible(true);
			table.setLinesVisible(true);
			for (int i = 0; i < getMetrics().size(); i++) {
				MetricDef nextMetric = ((MetricDef) getMetrics().get(i));
				org.eclipse.swt.widgets.TableColumn column = new org.eclipse.swt.widgets.TableColumn(table, org.eclipse.swt.SWT.NONE);
				column.setAlignment(org.eclipse.swt.SWT.RIGHT);
				column.setMoveable(true);
				column.setText(nextMetric.key);
				column.setToolTipText(nextMetric.getToolTipText());
			}
			org.eclipse.swt.widgets.TableColumn objectColumn = new org.eclipse.swt.widgets.TableColumn(table, org.eclipse.swt.SWT.NONE);
			objectColumn.setText("Element");
			objectColumn.setToolTipText("Measurement element");
			viewer.setLabelProvider(new Labels());
			viewer.setContentProvider(new org.eclipse.jface.viewers.ArrayContentProvider());
			viewer.addOpenListener(new org.eclipse.jface.viewers.IOpenListener() {

				public void open(org.eclipse.jface.viewers.OpenEvent event) {
					handleOpen(event);
				}
			});
			org.eclipse.swt.events.SelectionListener headerSelListener = new org.eclipse.swt.events.SelectionListener() {

				public void widgetSelected(org.eclipse.swt.events.SelectionEvent e) {
					table.setSortColumn((org.eclipse.swt.widgets.TableColumn) e.getSource());  
					table.setSortDirection((table.getSortDirection() != org.eclipse.swt.SWT.DOWN) ? org.eclipse.swt.SWT.DOWN : org.eclipse.swt.SWT.UP);
					viewer.refresh();
				}

				public void widgetDefaultSelected(org.eclipse.swt.events.SelectionEvent e) {
				}
			};
			org.eclipse.swt.widgets.TableColumn[] columns = viewer.getTable().getColumns();
			for (int i = 0; i < columns.length; i++) {
				columns[i].addSelectionListener(headerSelListener);
			}
			viewer.setSorter(new org.eclipse.jface.viewers.ViewerSorter() {

				public int compare(org.eclipse.jface.viewers.Viewer viewer, Object e1, Object e2) {
					org.eclipse.swt.widgets.TableColumn c = table.getSortColumn();
					int result = 0;
					if (c != null) {
						Metric mc1 = ((ElementMetrics) e1).getMetricByKey(c.getText());
						Metric mc2 = ((ElementMetrics) e2).getMetricByKey(c.getText());
						result = (mc1 != null && mc2 != null) ?
							mc1.compareTo(mc2) : (mc1 == null ? -1 : 1);
					} else {
						result = ((ElementMetrics) e1).targetElementQName.compareTo(((ElementMetrics) e2).targetElementQName);
					}
					return table.getSortDirection() == org.eclipse.swt.SWT.DOWN ? result : -result;
				}
			});
	        org.eclipse.ui.IEditorPart editor = getSite().getPage().getActiveEditor();
	        if (editor != null && editor.getClass().equals(«editorGen.editor.getQualifiedClassName()».class)) {
				setInput((«editorGen.editor.getQualifiedClassName()») editor);
	        }
		}

		«EXPAND xpt::Common::generatedMemberComment»
		private void handleOpen(org.eclipse.jface.viewers.OpenEvent event) {
			try {
				org.eclipse.ui.IEditorPart editorPart = getSite().getPage().openEditor(
						new org.eclipse.ui.part.FileEditorInput(org.eclipse.emf.workspace.util.WorkspaceSynchronizer.getFile(diagramResource)),
						«editorGen.editor.getQualifiedClassName()».ID);
				if (editorPart == null) {
					return;
				}
				org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart diagramPart =
						(org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart) editorPart.getAdapter(
								org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart.class);
				ElementMetrics selection = (ElementMetrics) ((org.eclipse.jface.viewers.IStructuredSelection) event.getSelection()).getFirstElement();
				String viewID = selection.diagramElementID;
				if (viewID != null) {
					org.eclipse.gmf.runtime.notation.View targetView =
							(org.eclipse.gmf.runtime.notation.View) diagramPart.getDiagram().eResource().getEObject(viewID);
					if (targetView != null) {
						org.eclipse.gef.EditPart targetEditPart =
								(org.eclipse.gef.EditPart) diagramPart.getDiagramGraphicalViewer().getEditPartRegistry().get(targetView);
						if (targetEditPart != null) {
							«getDiagramEditorUtilQualifiedClassName()».selectElementsInDiagram(
									diagramPart, java.util.Collections.singletonList(targetEditPart));
						}
					}
				}
			} catch (org.eclipse.ui.PartInitException e) {
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Can't open diagram editor", e); //$NON-NLS-1$
			}
		}

		«EXPAND xpt::Common::generatedMemberComment»
		private static java.util.Map calcMetricMaxValueStrLenMap(java.util.List allMetrics) {
			java.util.Map metric2MaxStrLen = new java.util.HashMap();
			for (int i = 0; i < getMetrics().size(); i++) {
				String nextKey = ((MetricDef) getMetrics().get(i)).key; 
				int trimPos = Math.min(nextKey.length(), MAX_VISIBLE_KEY_CHAR_COUNT);
				metric2MaxStrLen.put(nextKey, nextKey.substring(0, trimPos));
			}
			for (java.util.Iterator it = allMetrics.iterator(); it.hasNext();) {
				ElementMetrics elementMetrics = (ElementMetrics) it.next();
				for (int i = 0; i < elementMetrics.metrics.length; i++) {
					Metric metric = elementMetrics.metrics[i];
					String valueStr = (String) metric2MaxStrLen.get(metric.def.key);
					if (valueStr == null || metric.displayValue.length() > valueStr.length()) {
						metric2MaxStrLen.put(metric.def.key, metric.displayValue);	
					}
				}
			}
			return metric2MaxStrLen;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public void setFocus() {
		}

		«EXPAND xpt::Common::generatedMemberComment»
		private class Labels extends org.eclipse.jface.viewers.LabelProvider
				implements org.eclipse.jface.viewers.ITableLabelProvider, org.eclipse.jface.viewers.ITableColorProvider {

			«EXPAND xpt::Common::generatedMemberComment»
			private boolean isElementColumn(int columnIndex) {
				return columnIndex >= getMetrics().size();
			}

			«EXPAND xpt::Common::generatedMemberComment»
			public org.eclipse.swt.graphics.Image getColumnImage(Object element, int columnIndex) {
				return isElementColumn(columnIndex) ? ((ElementMetrics) element).elementImage : null;
			}

			«EXPAND xpt::Common::generatedMemberComment»
			public String getColumnText(Object element, int columnIndex) {
				ElementMetrics elementMetrics = (ElementMetrics) element;
				if (columnIndex == getMetrics().size()) {
					return elementMetrics.targetElementQName;
				}
				String key = ((MetricDef) getMetrics().get(columnIndex)).key;
				Metric metric = elementMetrics.getMetricByKey(key);
				return (metric != null) ? metric.displayValue : "-"; //$NON-NLS-1$
			}

			«EXPAND xpt::Common::generatedMemberComment»
			public org.eclipse.swt.graphics.Color getBackground(Object element, int columnIndex) {
				return null; 
			}

			«EXPAND xpt::Common::generatedMemberComment»
			public org.eclipse.swt.graphics.Color getForeground(Object element, int columnIndex) {
				if (isElementColumn(columnIndex)) {
					return null;
				}
				ElementMetrics columnElement = (ElementMetrics) element;
				String key = ((MetricDef) getMetrics().get(columnIndex)).key;
				Metric metric = columnElement.getMetricByKey(key);
				if (metric != null && metric.value != null) {
					if (metric.def.highLimit != null && metric.def.highLimit.longValue() < metric.value.longValue()) {
						return org.eclipse.draw2d.ColorConstants.red;
					} else if (metric.def.lowLimit != null && metric.def.lowLimit.longValue() > metric.value.longValue()) {
						return org.eclipse.draw2d.ColorConstants.blue;
					}
				}
				return null;
			}
		}		
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class ElementMetrics {

		«EXPAND xpt::Common::generatedMemberComment»
		final Metric[] metrics;

		«EXPAND xpt::Common::generatedMemberComment»
		final String targetElementQName;

		«EXPAND xpt::Common::generatedMemberComment»
		final org.eclipse.swt.graphics.Image elementImage;

		«EXPAND xpt::Common::generatedMemberComment»
		String diagramElementID;

		«EXPAND xpt::Common::generatedMemberComment»
		org.eclipse.emf.ecore.EObject target;

		«EXPAND xpt::Common::generatedMemberComment»
		ElementMetrics(org.eclipse.emf.ecore.EObject target, Metric[] metrics) {
			this.metrics = metrics;	
			assert metrics.length > 0;
			this.target = target;
			org.eclipse.emf.ecore.EClass imageTarget = target.eClass();
			if (target instanceof org.eclipse.gmf.runtime.notation.View) {
				org.eclipse.gmf.runtime.notation.View viewTarget = (org.eclipse.gmf.runtime.notation.View) target;
				StringBuffer notationQNameBuf = new StringBuffer();
				notationQNameBuf.append(org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(viewTarget, true));
				if ("".equals(viewTarget.getType()) && viewTarget.getElement() != null) { //$NON-NLS-1$
					notationQNameBuf.append('-').append('>').append(
							org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(viewTarget.getElement(), true));
					imageTarget = viewTarget.getElement().eClass();
				}
				int visualID = «getVisualIDRegistryQualifiedClassName()».getVisualID(viewTarget);
				notationQNameBuf.append('[').append(visualID < 0
					? Integer.toString(System.identityHashCode(viewTarget))
					: Integer.toString(visualID)).append(']');
				this.targetElementQName = notationQNameBuf.toString();
			} else {
				this.targetElementQName = org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil.getQualifiedName(target, true);
			}
			this.elementImage = «getElementTypesQualifiedClassName()».getImage(imageTarget);
		}

		«EXPAND xpt::Common::generatedMemberComment»
		Metric getMetricByKey(String key) {
			for (int i = 0; i < metrics.length; i++) {
				if (metrics[i].def.key.equals(key)) {
					return metrics[i]; 
				}
			}
			return null;
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class Metric implements Comparable {

		«EXPAND xpt::Common::generatedMemberComment»
		final MetricDef def;

		«EXPAND xpt::Common::generatedMemberComment»
		final Number value;

		«EXPAND xpt::Common::generatedMemberComment»
		final String displayValue;

		«EXPAND xpt::Common::generatedMemberComment»
		Metric(MetricDef def, org.eclipse.emf.ecore.EObject target) {
			this.def = def;
			value = def.calcMetric(target);
			this.displayValue = (value != null) ? java.text.NumberFormat.getInstance().format(value) : "null"; //$NON-NLS-1$
		}

		«EXPAND xpt::Common::generatedMemberComment»
		public int compareTo(Object other) {
			Metric otherMetric = (Metric) other;
			if (value != null && otherMetric.value != null) {
				return (value.longValue() < otherMetric.value.longValue()) ? -1
						: (value.longValue() == otherMetric.value.longValue() ? 0 : 1);
			}
			return (value == null && otherMetric.value == null) ? 0
					: (value == null) ? -1 : 1;
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class MetricDef {

		«EXPAND xpt::Common::generatedMemberComment»
		final Double lowLimit;

		«EXPAND xpt::Common::generatedMemberComment»
		final Double highLimit;

		«EXPAND xpt::Common::generatedMemberComment»
		final String key;

		«EXPAND xpt::Common::generatedMemberComment»
		final «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression;

		«EXPAND xpt::Common::generatedMemberComment»
		final int[] semanticIDs;

		«EXPAND xpt::Common::generatedMemberComment»
		final String name;

		«EXPAND xpt::Common::generatedMemberComment»
		final String description;

		«EXPAND xpt::Common::generatedMemberComment»
		MetricDef(String key, «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression, int[] semanticIDs,
			Double low, Double high, String name, String description) {
			this.key = key;
			this.expression = expression;
			this.semanticIDs = semanticIDs;
			this.lowLimit = low;
			this.highLimit = high;
			this.name = name;
			this.description = description;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		Number calcMetric(Object contextInstance) {
			Object val = expression.evaluate(contextInstance);
			return (val instanceof Number) ? (Number) val : null;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		boolean appliesTo(org.eclipse.emf.ecore.EObject eObject) {
			if (eObject instanceof org.eclipse.gmf.runtime.notation.View && semanticIDs != null) {
				int eObjectID = «getVisualIDRegistryQualifiedClassName()».getVisualID((org.eclipse.gmf.runtime.notation.View) eObject); 
				for (int i = 0; i < semanticIDs.length; i++) {
					if (semanticIDs[i] == eObjectID) {
						return true;
					}
				}
				return false;
			}
			return eObject != null && (expression.context() instanceof org.eclipse.emf.ecore.EClass) &&
				((org.eclipse.emf.ecore.EClass) expression.context()).isSuperTypeOf(eObject.eClass());
		}

		«EXPAND xpt::Common::generatedMemberComment»
		String getToolTipText() {
			StringBuffer buf = new StringBuffer();
			if (name != null) {
				buf.append(name);
			}
			if (description != null) {
				buf.append('\n').append(description).append('\n');
			}
			if (lowLimit != null) {
				buf.append("low:").append(lowLimit);
			}
			if (highLimit != null) {
				buf.append(" high:").append(highLimit);
			}
			return buf.toString();
		}	
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static java.util.List/*MetricDef*/ getMetricsForTarget(org.eclipse.emf.ecore.EClass target) {
		if (context2MetricsMap == null) {
			initializeRegistry();
		}
		return (java.util.List) context2MetricsMap.get(target);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static java.util.List getMetrics() {
		if (metricsRegistry == null) {
			initializeRegistry();
		}
		return metricsRegistry;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static Number calculateMetric(String metricKey, Object contextInstance) {
		if (key2MetricMap == null) {
			initializeRegistry();
		}
		MetricDef metric = (MetricDef) key2MetricMap.get(metricKey);
		Number value = (metric != null) ? metric.calcMetric(contextInstance) : null;
		return (value != null && !(value instanceof Double)) ? new Double(value.doubleValue()) : value;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static void initializeRegistry() {
	«IF editorGen.expressionProviders != null-»
		if (context2MetricsMap != null) {
			return;
		}
		«FOREACH editorGen.metrics.metrics AS nextMetric-»
			«IF null != nextMetric.rule && null != nextMetric.target && null != nextMetric.target.getContext()-»
		register(new MetricDef(«toStringLiteral(nextMetric.key)»,
				«EXPAND initializerExpr(nextMetric.rule, nextMetric.target.getContext()) FOR editorGen.expressionProviders.getProvider(nextMetric.rule)»,
				«IF null == nextMetric.target»null«ELSE»«EXPAND ids FOR nextMetric.target»«ENDIF»,
				«IF null == nextMetric.lowLimit»null«ELSE»new Double(«nextMetric.lowLimit»)«ENDIF»,
				«IF null == nextMetric.highLimit»null«ELSE»new Double(«nextMetric.highLimit»)«ENDIF»,
				«toStringLiteral(nextMetric.name)»,
				«toStringLiteral(nextMetric.description)»));
			«ENDIF-»
		«ENDFOREACH-»
	«ENDIF-»
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static void register(MetricDef metric) {
		if (context2MetricsMap == null) {
			context2MetricsMap = new java.util.HashMap();
			metricsRegistry = new java.util.ArrayList();
			key2MetricMap = new java.util.HashMap();
		}
		java.util.List metrics = (java.util.List) context2MetricsMap.get(metric.expression.context());
		if (metrics == null) {
			metrics = new java.util.ArrayList();
			context2MetricsMap.put(metric.expression.context(), metrics);
		}
		metricsRegistry.add(metric);
		metrics.add(metric);
		key2MetricMap.put(metric.key, metric);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	private static class JavaRules {
	«IF editorGen.expressionProviders != null-»
		«FOREACH editorGen.metrics.metrics AS nextMetric-»
			«IF null != nextMetric.rule && null != nextMetric.target && null != nextMetric.target.getContext()-»
				«EXPAND javaInitializer(nextMetric.rule, nextMetric.target.getContext(), null) FOR editorGen.expressionProviders.getProvider(nextMetric.rule)-»
			«ENDIF-»
		«ENDFOREACH-»
	«ENDIF-»
	}
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE ids FOR GenMeasurable-»
	null
«ENDDEFINE»

«DEFINE ids FOR GenDiagramElementTarget-»
	new int[] {
	«FOREACH element AS element-»
		«element.getEditPartQualifiedClassName()».VISUAL_ID,
	«ENDFOREACH-»
	}
«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenExpressionInterpreter-»
	«getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», //$NON-NLS-1$
		«getQualifiedClassifierAccessor(exprContext)»())
«ENDDEFINE»

«DEFINE initializerExpr(ValueExpression valueExpr, GenClassifier exprContext) FOR GenJavaExpressionProvider-»
	new «container.getAbstractExpressionQualifiedClassName()»(«getQualifiedClassifierAccessor(exprContext)»()) {

		protected Object doEvaluate(Object context, java.util.Map env) {
			«getQualifiedInstanceClassName(exprContext)» self = («getQualifiedInstanceClassName(exprContext)») context;
			return JavaRules.«getOperationName(valueExpr)»(self);
		}
	}
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenExpressionProviderBase-»
«ENDDEFINE»

«DEFINE javaInitializer(gmfgen::ValueExpression valueExpr, genmodel::GenClassifier context, genmodel::GenClassifier oppositeEndContext) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpr, context, oppositeEndContext)-»
«ENDDEFINE»
@

