head	1.9;
access;
symbols
	v20081022-1925:1.9
	v20081015-1925:1.9
	v20081008-1925:1.9
	v20081001-1925:1.9
	v20080930-1130:1.9
	v20080926-1245:1.9
	v20080924-1925:1.9
	v20080917-1925:1.9
	v20080911-1728:1.9
	v20080910-1520:1.9
	v20080903-1520:1.9
	v20080827-1520:1.9
	v20080813-1520:1.9
	v20080806-1520:1.9
	v20080722-1827:1.9
	v20080718-1731:1.9
	v20080716-1600:1.8.2.1
	v20080716-1642:1.9
	R2_1_maintenance:1.8.0.2
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080610-1132:1.8
	v20080603-1553:1.8
	v20080528-1052:1.8
	v20080521:1.8
	v20080516-1543:1.7
	v20080516-1143:1.7
	v20080512-1200:1.7
	v20080508-2000:1.7
	v20080507-1326:1.7
	v20080503-1740:1.4
	v20080501-1739:1.4
	v20080425-1959:1.4
	v20080417-1610:1.4
	v20080411-0411:1.3
	v20080404-1111:1.3
	v20080322-0000:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.9
date	2008.06.27.14.32.04;	author ashatalin;	state Exp;
branches;
next	1.8;
commitid	1f994864f9e34567;

1.8
date	2008.05.20.17.10.11;	author atikhomirov;	state Exp;
branches
	1.8.2.1;
next	1.7;
commitid	30ed483305f34567;

1.7
date	2008.05.07.13.56.01;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	39124821b4de4567;

1.6
date	2008.05.05.18.20.18;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	446f481f4fe14567;

1.5
date	2008.05.05.11.25.50;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	3040481eeebe4567;

1.4
date	2008.04.14.08.31.34;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	bb3480316654567;

1.3
date	2008.03.05.17.13.14;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	2bbd47ced4aa4567;

1.2
date	2008.03.05.16.41.09;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	4c0b47cecd244567;

1.1
date	2008.02.29.21.19.51;	author atikhomirov;	state Exp;
branches;
next	;
commitid	45a447c876f24567;

1.8.2.1
date	2008.06.27.14.35.04;	author ashatalin;	state Exp;
branches;
next	;
commitid	22d84864fa974567;


desc
@@


1.9
log
@[238295] - Can't organize imports due to syntax errors in the compilation unit ElementInitializers.java, Counter overflow? 2.1 RC3
@
text
@/*
 * Copyright (c) 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */

import "http://www.eclipse.org/gmf/2008/GenModel";
import "http://www.eclipse.org/emf/2002/Ecore";
import "http://www.eclipse.org/emf/2002/GenModel";

extension xpt::GenModelUtils reexport;

boolean expressionResultNeedsCast(GenClassifier c) : false ;
boolean expressionResultNeedsCast(GenClass c) : false ;
boolean expressionResultNeedsCast(GenDataType c) : isNumberObject(c) || isPrimitiveNumberType(c) ;
boolean expressionResultNeedsCast(GenEnum c) : true ;

/*
 * Present approach may result in duplicated methods when same feature gets
 * initialized using java language inside single ElementInitializer hierarchy
 */
String javaMethodName(GenCommonBase de, GenFeatureValueSpec valueSpec) :
	valueSpec.feature.ecoreFeature.name + "_" + de.getUniqueIdentifier() 
;

List[GenFeatureValueSpec] recurseCollectValueSpec(GenFeatureSeqInitializer si) :
	si.initializers.typeSelect(GenFeatureValueSpec).union(
	si.initializers.typeSelect(GenReferenceNewElementSpec).newElementInitializers.recurseCollectValueSpec().flatten())
;

List[int] getSuffixes(int newSuffix) :
	{}.add(newSuffix).typeSelect(int)
;

List[int] getSuffixes(List[int] suffixes, int newSuffix) :
	{}.addAll(suffixes).add(newSuffix).typeSelect(int)
;

String getVariableName(String prefix, List[int] suffixes) :
	prefix + getSuffix(suffixes)
;

// privates

private boolean isNumberObject(genmodel::GenClassifier c) : false ;
private boolean isNumberObject(genmodel::GenClass c) : false ;
private boolean isNumberObject(genmodel::GenDataType c) : {"java.math.BigDecimal", "java.math.BigInteger", "java.lang.Byte", "java.lang.Double", "java.lang.Float", "java.lang.Integer", "java.lang.Long", "java.lang.Short"}.contains(c.ecoreDataType.instanceClassName) ;
private boolean isNumberObject(genmodel::GenEnum c) : false ;

private boolean isPrimitiveNumberType(genmodel::GenClassifier c) : false ;
private boolean isPrimitiveNumberType(genmodel::GenClass c) : false ;
private boolean isPrimitiveNumberType(genmodel::GenDataType c) : {"byte", "double", "float", "int", "long", "short"}.contains(c.ecoreDataType.instanceClassName) ;
private boolean isPrimitiveNumberType(genmodel::GenEnum c) : false ;

private String getSuffix(List[int] suffixes) :
	"_" + suffixes.first() + (suffixes.size() > 1 ? getSuffix(suffixes.withoutFirst().typeSelect(int)) : "")
;@


1.8
log
@[221347] comment 4: duplicated methods when there are more than one initializer for specific feature - tell them apart by diagram element.
@
text
@d37 12
d60 4
@


1.8.2.1
log
@[238295] - Can't organize imports due to syntax errors in the compilation unit ElementInitializers.java, Counter overflow? 2.1 RC3
@
text
@a36 12
List[int] getSuffixes(int newSuffix) :
	{}.add(newSuffix).typeSelect(int)
;

List[int] getSuffixes(List[int] suffixes, int newSuffix) :
	{}.addAll(suffixes).add(newSuffix).typeSelect(int)
;

String getVariableName(String prefix, List[int] suffixes) :
	prefix + getSuffix(suffixes)
;

a47 4

private String getSuffix(List[int] suffixes) :
	"_" + suffixes.first() + (suffixes.size() > 1 ? getSuffix(suffixes.withoutFirst().typeSelect(int)) : "")
;@


1.7
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d24 6
a29 2
String javaMethodName(GenFeatureValueSpec valueSpec) :
	"value_" + valueSpec.feature.ecoreFeature.name
d32 1
a32 19
List[GenFeatureValueSpec] getJavaValueSpecs(GenDiagram gd) :
	getJavaValueSpecs(allTypeModelFacets(gd), gd.editorGen.expressionProviders)
;

// privates

private List[TypeModelFacet] allTypeModelFacets(GenDiagram gd) :
	gd.topLevelNodes.modelFacet.union(gd.childNodes.modelFacet).union(gd.links.modelFacet).typeSelect(TypeModelFacet)
;

private List[GenFeatureValueSpec] getJavaValueSpecs(List[TypeModelFacet] modelFacets, GenExpressionProviderContainer c) :
	getJavaValueSpecs(modelFacets.modelElementInitializer.typeSelect(GenFeatureSeqInitializer), c.providers.typeSelect(GenJavaExpressionProvider).expressions)
;

private List[GenFeatureValueSpec] getJavaValueSpecs(List[GenFeatureSeqInitializer] elementInitializers, List[ValueExpression] allJavaExpressions) :
	elementInitializers.recurseCollectValueSpec().select(vs | allJavaExpressions.contains(vs.value))
;

private List[GenFeatureValueSpec] recurseCollectValueSpec(GenFeatureSeqInitializer si) :
d37 1
@


1.6
log
@[228913] item 4 - do not use expression body to create method name
@
text
@d13 1
a13 1
import "http://www.eclipse.org/gmf/2006/GenModel";
d24 2
a25 2
String javaMethodName(GenCommonBase diagramElement, GenFeatureValueSpec valueSpec) :
	"value_" + diagramElement.getClassNamePrefix() + "_" + valueSpec.featureSeqInitializer.elementClass.ecoreClass.name + "_" + valueSpec.feature.ecoreFeature.name
d28 2
a29 6
/*
	XXX instead of all these recursion may write javaInitializers template the same way performInit
	is written, i.e. re-dispatch from GenReferenceNewElementSpec
 */
List[GenFeatureValueSpec] getFeatureInitializers(GenFeatureSeqInitializer si, GenJavaExpressionProvider jp) :
	recurseCollectValueExpr(si).intersect(jp.expressions)
d32 15
a46 1
private List[ValueExpression] recurseCollectValueExpr(GenFeatureSeqInitializer si) :
d48 1
a48 1
	si.initializers.typeSelect(GenReferenceNewElementSpec).newElementInitializers.recurseCollectValueExpr().flatten())
@


1.5
log
@[226725] Refactor domain element initialization not to be duplicated in Lite RT
@
text
@d24 4
d41 1
@


1.4
log
@[221347] refactor ElementInitializers, 2/2: avoid reflective code if generation of specific code is possible.
@
text
@d24 4
@


1.3
log
@[221347] refactor/simplify ElementInitializers - I suspect duplicated ValueExpression were collected with the old approach, and there was recursion anyway, so I simplified the code to be explicit about its intentions
@
text
@d15 1
d17 6
d32 10
@


1.2
log
@[221347] refactor/simplify ElementInitializers - shorten path to initializers
@
text
@a16 5
//
// FIXME this odd code cries for meta-model refactoring/cleanup to simplify feature initialization
//


d18 1
a18 10
	si.initializers.typeSelect(GenFeatureValueSpec).select(x | jp.expressions.contains(x)).union(
	si.initializers.typeSelect(GenReferenceNewElementSpec).collect(x | getFeatureInitializers(x, jp)).flatten())
;

private List[GenFeatureValueSpec] getFeatureInitializers(GenReferenceNewElementSpec x, GenJavaExpressionProvider jp) :
	getNestedFeatureSeqInitializers(x).collect(y | getFeatureInitializers(y, jp)).flatten()
; 

private List[GenFeatureSeqInitializer] getAllFeatureSeqInitializers(GenFeatureSeqInitializer si) :
	{si}.union(si.initializers.typeSelect(GenReferenceNewElementSpec).getNestedFeatureSeqInitializers().flatten())
d21 3
a23 2
private List[GenFeatureSeqInitializer] getNestedFeatureSeqInitializers(GenReferenceNewElementSpec s) :
	s.newElementInitializers.getAllFeatureSeqInitializers().flatten()
@


1.1
log
@[150177] phase IV, fix last use of qualified class names in ElementInitializers (via GMFGen genmodel java methods). Cleaned genmodel of methods no longer in use, few methods moved to ElementInitializer.ext (pending removal/refactoring)
@
text
@d27 1
a27 1
List[GenFeatureValueSpec] getFeatureInitializers(GenReferenceNewElementSpec x, GenJavaExpressionProvider jp) :
@

