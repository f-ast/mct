head	1.20;
access;
symbols
	v20081022-1925:1.20
	v20081015-1925:1.20
	v20081008-1925:1.20
	v20081001-1925:1.20
	v20080930-1130:1.20
	v20080926-1245:1.20
	v20080924-1925:1.20
	v20080917-1925:1.20
	v20080911-1728:1.20
	v20080910-1520:1.20
	v20080903-1520:1.20
	v20080827-1520:1.20
	v20080813-1520:1.19
	v20080806-1520:1.19
	v20080722-1827:1.19
	v20080718-1731:1.19
	v20080716-1600:1.19
	v20080716-1642:1.19
	R2_1_maintenance:1.19.0.2
	Root_R2_1_maintenance:1.19
	R2_1_0:1.19
	v20080610-1132:1.19
	v20080603-1553:1.19
	v20080528-1052:1.19
	v20080521:1.19
	v20080516-1543:1.18
	v20080516-1143:1.18
	v20080512-1200:1.18
	v20080508-2000:1.18
	v20080507-1326:1.18
	v20080503-1740:1.16
	v20080501-1739:1.16
	v20080425-1959:1.15
	v20080417-1610:1.14
	v20080411-0411:1.14
	v20080404-1111:1.14
	v20080322-0000:1.14
	v20080222-1200:1.10
	v20080215-1500:1.10
	v20080207-0207:1.8.2.1
	v20071222-1111:1.10
	v20071214-1111:1.10
	v20071130-1111:1.10
	v20071124-0000:1.8.2.1
	v20071112-0000:1.10
	v20071108-0000:1.10
	v20071003-0000:1.10
	v20070928-0000:1.8.2.1
	v20070921-0000:1.8
	v20070915-0000:1.8
	v20070903-0000:1.9
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	v20070621-0000:1.8
	RC3_20:1.8
	v20070614-1400:1.8
	v20070608-1300:1.7
	v20070605-1400:1.7
	v20070601-1400:1.7
	v20070525-1500:1.4
	v20070520-1200:1.4
	v20070518-1300:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.20
date	2008.08.22.18.25.43;	author atikhomirov;	state Exp;
branches;
next	1.19;
commitid	5d5b48af049e4567;

1.19
date	2008.05.20.15.45.10;	author atikhomirov;	state Exp;
branches;
next	1.18;
commitid	29294832f2054567;

1.18
date	2008.05.07.13.56.00;	author atikhomirov;	state Exp;
branches;
next	1.17;
commitid	39124821b4de4567;

1.17
date	2008.05.05.21.06.41;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	4186481f76b14567;

1.16
date	2008.04.30.21.02.35;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	8194818de6a4567;

1.15
date	2008.04.25.19.57.58;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	699481237c64567;

1.14
date	2008.03.05.17.26.10;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	4acc47ced7b14567;

1.13
date	2008.02.29.21.19.53;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	45a447c876f24567;

1.12
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	19d047c419ed4567;

1.11
date	2008.02.22.20.24.43;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	377d47bf2f8a4567;

1.10
date	2007.09.24.09.54.48;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	6ce46f789684567;

1.9
date	2007.08.13.11.23.46;	author bblajer;	state Exp;
branches;
next	1.8;
commitid	5a2c46c03f424567;

1.8
date	2007.06.13.12.49.09;	author ashatalin;	state Exp;
branches
	1.8.2.1;
next	1.7;
commitid	55a1466fe7bb4567;

1.7
date	2007.05.31.17.09.35;	author bblajer;	state Exp;
branches;
next	1.6;
commitid	6341465f014e4567;

1.6
date	2007.05.29.14.53.58;	author bblajer;	state Exp;
branches;
next	1.5;
commitid	421f465c3e864567;

1.5
date	2007.05.28.16.52.23;	author ashatalin;	state Exp;
branches;
next	1.4;
commitid	51cb465b08c54567;

1.4
date	2007.05.18.21.17.18;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	2591464e17d14567;

1.3
date	2007.05.16.18.44.42;	author ashatalin;	state Exp;
branches;
next	1.2;
commitid	4320464b51194567;

1.2
date	2007.05.15.19.19.22;	author ashatalin;	state Exp;
branches;
next	1.1;
commitid	43d3464a07b84567;

1.1
date	2007.05.15.18.34.13;	author ashatalin;	state Exp;
branches;
next	;
commitid	25434649fd1f4567;

1.8.2.1
date	2007.09.24.10.14.55;	author ashatalin;	state Exp;
branches;
next	;
commitid	2ca346f78e1f4567;


desc
@@


1.20
log
@simplified visualId-to-viewType conversion helpers
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION xpt::editor::Utils»
«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::diagram::editpolicies::LinkUtils»
«EXTENSION xpt::expressions::ValueExpression»

«DEFINE VisualIDRegistry FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::copyright FOR getDiagram().editorGen-»
package «editorGen.editor.packageName»;

	«EXPAND xpt::Common::generatedClassComment(
		"This registry is used to determine which type of visual object should be\n" +
		"created for the corresponding Diagram, Node, ChildNode or Link represented\n" + 
		"by a domain model object.\n"	
	)»
public class «visualIDRegistryClassName» {

	«EXPAND attributes-»

	«EXPAND getViewVisualID-»
	
	«EXPAND getModelID-»
	
	«EXPAND getVisualID-»

	«EXPAND getType-»
	
	«EXPAND getDiagramVisualID-»
	
	«EXPAND getNodeVisualID-»
	
	«EXPAND canCreateNode-»
	
	«EXPAND getLinkWithClassVisualID-»
	
	«EXPAND isDiagram-»

	«EXPAND _constraintMethods-»

	«EXPAND additions-»	
}
«ENDDEFINE»

«REM»
	<Definitions of templates for outside usage>
«ENDREM»

«DEFINE visualID FOR gmfgen::GenCommonBase»«getEditPartQualifiedClassName()».VISUAL_ID«ENDDEFINE»

«DEFINE modelID FOR gmfgen::GenDiagram»«getEditPartQualifiedClassName()».MODEL_ID«ENDDEFINE»

«DEFINE getVisualIDMethodCall FOR gmfgen::GenDiagram»«getVisualIDRegistryQualifiedClassName()».«EXPAND getVisualIdMethodName»«ENDDEFINE»

«DEFINE getModelIDMethodCall FOR gmfgen::GenDiagram»«getVisualIDRegistryQualifiedClassName()».«EXPAND getModelIDMethodName»«ENDDEFINE»

«REM»
	XXX looks like these methods would produce incorrect result for visualID of GenDiagram itself - ask Vano if
	getType() method shouldn't be fixed similar to getVisualID, i.e. map diagram's visual id to MODEL_ID instead plain String.valueOf()
«ENDREM»
«DEFINE typeMethodCall(String visualIdVar) FOR gmfgen::GenCommonBase»«getDiagram().getVisualIDRegistryQualifiedClassName()».«EXPAND getTypeMethodName FOR getDiagram()»(«visualIdVar»)«ENDDEFINE»
«DEFINE typeMethodCall FOR gmfgen::GenCommonBase»«getDiagram().getVisualIDRegistryQualifiedClassName()».«EXPAND getTypeMethodName FOR getDiagram()»(«EXPAND visualID»)«ENDDEFINE»

«DEFINE getDiagramVisualIDMethodCall FOR gmfgen::GenDiagram»«getVisualIDRegistryQualifiedClassName()».«EXPAND getDiagramVisualIDMethodName»«ENDDEFINE»

«DEFINE getNodeVisualIDMethodCall FOR gmfgen::GenDiagram»«getVisualIDRegistryQualifiedClassName()».«EXPAND getNodeVisualIDMethodName»«ENDDEFINE»

«DEFINE canCreateNodeMethodCall FOR gmfgen::GenDiagram»«getVisualIDRegistryQualifiedClassName()».«EXPAND canCreateNodeMethodName»«ENDDEFINE»

«DEFINE getLinkWithClassVisualIDMethodCall FOR gmfgen::GenDiagram»«getVisualIDRegistryQualifiedClassName()».«EXPAND getLinkWithClassVisualIDMethodName»«ENDDEFINE»

«REM»
	</Definitions of templates for outside usage>
«ENDREM»

«DEFINE attributes FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static final String DEBUG_KEY = "«editorGen.plugin.iD»/debug/visualID"; «EXPAND xpt::Common::nonNLS»
«IF null != editorGen.expressionProviders-»
	«EXPAND _constraintField FOREACH topLevelNodes-»
	«EXPAND _constraintField FOREACH childNodes-»
	«EXPAND _constraintField FOREACH links-»
«ENDIF-»
«ENDDEFINE»

«DEFINE getViewVisualID FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static int «EXPAND getVisualIdMethodName»(org.eclipse.gmf.runtime.notation.View view) {
	if (view instanceof org.eclipse.gmf.runtime.notation.Diagram) {
		if («EXPAND modelID».equals(view.getType())) {
			return «EXPAND visualID»;
		} else {
			«EXPAND unrecognizedVID-»
		}
	}
	return «EXPAND getVisualIDMethodCall»(view.getType());
}
«ENDDEFINE»

«DEFINE getVisualIdMethodName FOR gmfgen::GenDiagram»getVisualID«ENDDEFINE»

«DEFINE getModelID FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static String «EXPAND getModelIDMethodName»(org.eclipse.gmf.runtime.notation.View view) {
	org.eclipse.gmf.runtime.notation.View diagram = view.getDiagram();
	while (view != diagram) {
		org.eclipse.emf.ecore.EAnnotation annotation = view.getEAnnotation("Shortcut"); «EXPAND xpt::Common::nonNLS»
		if (annotation != null) {
			return (String) annotation.getDetails().get("modelID"); «EXPAND xpt::Common::nonNLS»
		}
		view = (org.eclipse.gmf.runtime.notation.View) view.eContainer();
	}
	return diagram != null ? diagram.getType() : null;
}
«ENDDEFINE»

«DEFINE getModelIDMethodName FOR gmfgen::GenDiagram»getModelID«ENDDEFINE»

«DEFINE getVisualID FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static int «EXPAND getVisualIdMethodName»(String type) {
	try {
		return Integer.parseInt(type);
	} catch (NumberFormatException e) {
		if (Boolean.TRUE.toString().equalsIgnoreCase(org.eclipse.core.runtime.Platform.getDebugOption(DEBUG_KEY))) {
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to parse view type as a visualID number: " + type);
		}
	}
	«EXPAND unrecognizedVID-»
}
«ENDDEFINE»

«DEFINE getType FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static String «EXPAND getTypeMethodName»(int visualID) {
	return String.valueOf(visualID);
}
«ENDDEFINE»

«DEFINE getTypeMethodName FOR gmfgen::GenDiagram»getType«ENDDEFINE»

«DEFINE getDiagramVisualID FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static int «EXPAND getDiagramVisualIDMethodName»(org.eclipse.emf.ecore.EObject domainElement) {
	if (domainElement == null) {
		«EXPAND unrecognizedVID-»
	}
«IF null != domainDiagramElement-»
	«EXPAND returnVisualID-»
«ENDIF-»
	«EXPAND unrecognizedVID-»
}
«ENDDEFINE»

«DEFINE getDiagramVisualIDMethodName FOR gmfgen::GenDiagram»getDiagramVisualID«ENDDEFINE»

«DEFINE returnVisualID FOR gmfgen::GenCommonBase-»
if («EXPAND checkSemanticElement») {
	return «EXPAND visualID»;
}
«ENDDEFINE»

«DEFINE checkSemanticElement FOR gmfgen::GenCommonBase-»
	«ERROR "checkSemanticElement not supported for: " + this-»
«ENDDEFINE»

«DEFINE checkSemanticElement FOR gmfgen::GenDiagram»«EXPAND checkDomainElementMetaclass FOR domainDiagramElement» && isDiagram(«EXPAND MetaModel::CastEObject("domainElement") FOR domainDiagramElement»)«ENDDEFINE»
«DEFINE checkSemanticElement FOR gmfgen::GenNode»«EXPAND checkDomainElementMetaclass FOR modelFacet.metaClass»«EXPAND checkDomainElementConstraints(this) FOR modelFacet»«ENDDEFINE»
«DEFINE checkSemanticElement FOR gmfgen::GenLink»«EXPAND checkSemanticElement(this) FOR modelFacet»«ENDDEFINE»

«DEFINE checkDomainElementMetaclass FOR genmodel::GenClass»«EXPAND MetaModel::MetaClass».isSuperTypeOf(domainElement.eClass())«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase) FOR gmfgen::TypeModelFacet-»
«IF null != modelElementSelector» && «EXPAND _domainElementConstraintMethodName FOR commonBase»(«EXPAND MetaModel::CastEObject("domainElement") FOR metaClass»)«ENDIF-»
«ENDDEFINE»

«DEFINE checkSemanticElement(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet»«ERROR "checkSemanticElement is supported only for TypeLinkModelFacet: " + this»«ENDDEFINE»
«DEFINE checkSemanticElement(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet»«EXPAND checkDomainElementMetaclass FOR metaClass»«EXPAND checkDomainElementConstraints(genLink)»«ENDDEFINE»


«DEFINE getNodeVisualID FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static int «EXPAND getNodeVisualIDMethodName»(org.eclipse.gmf.runtime.notation.View containerView, org.eclipse.emf.ecore.EObject domainElement) {
	if (domainElement == null) {
		«EXPAND unrecognizedVID-»
	}
	String containerModelID = «EXPAND getModelIDMethodCall»(containerView);
	if (!«EXPAND modelID».equals(containerModelID)«EXPAND checkContainerModelID FOREACH shortcutsProvidedFor») { «EXPAND xpt::Common::nonNLS({}) FOREACH shortcutsProvidedFor SEPARATOR " "»
		«EXPAND unrecognizedVID-»
	}
	int containerVisualID;
	if («EXPAND modelID».equals(containerModelID)) {
		containerVisualID = «EXPAND getVisualIDMethodCall»(containerView);
	} else {
		if (containerView instanceof org.eclipse.gmf.runtime.notation.Diagram) {
			containerVisualID = «EXPAND visualID»;		
		} else {
			«EXPAND unrecognizedVID-»
		}
	}
	switch (containerVisualID) {
		«EXPAND caseDomainContainerVisualID FOREACH getAllContainers()-»
	}
	«EXPAND unrecognizedVID-»
}
«ENDDEFINE»

«DEFINE getNodeVisualIDMethodName FOR gmfgen::GenDiagram»getNodeVisualID«ENDDEFINE»

«DEFINE caseDomainContainerVisualID FOR gmfgen::GenContainerBase-»
	«IF getContainedSemanticNodes(this).size() > 0-»
«EXPAND xpt::Common::caseVisualID»
	«EXPAND returnVisualID FOREACH getContainedSemanticNodes(this)-»
	break;
	«ENDIF-»
«ENDDEFINE»


«DEFINE canCreateNode FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static boolean «EXPAND canCreateNodeMethodName»(org.eclipse.gmf.runtime.notation.View containerView, int nodeVisualID) {
	String containerModelID = «EXPAND getModelIDMethodCall»(containerView);
	if (!«EXPAND modelID».equals(containerModelID)«EXPAND checkContainerModelID FOREACH shortcutsProvidedFor») { «EXPAND xpt::Common::nonNLS({}) FOREACH shortcutsProvidedFor SEPARATOR " "»
		return false;
	}
	int containerVisualID;
	if («EXPAND modelID».equals(containerModelID)) {
		containerVisualID = «EXPAND getVisualIDMethodCall»(containerView);
	} else {
		if (containerView instanceof org.eclipse.gmf.runtime.notation.Diagram) {
			containerVisualID = «EXPAND visualID»;		
		} else {
			return false;
		}
	}
	switch (containerVisualID) {
		«EXPAND caseVisualID FOREACH getAllContainers().select(e| !e.getEssentialVisualChildren().isEmpty())-»
		«EXPAND caseVisualID FOREACH links.select(e| !e.getEssentialVisualChildren().isEmpty())-»
	}
	return false;
}
«ENDDEFINE»

«DEFINE canCreateNodeMethodName FOR gmfgen::GenDiagram»canCreateNode«ENDDEFINE»

«DEFINE checkContainerModelID FOR String» && !"«this»".equals(containerModelID)«ENDDEFINE»

«DEFINE caseVisualID FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::caseVisualID»
	«EXPAND checkEssentialChild FOREACH getEssentialVisualChildren()-»
	break;
«ENDDEFINE»

«DEFINE checkEssentialChild FOR gmfgen::GenCommonBase-»
if («EXPAND visualID» == nodeVisualID) {
	return true;
}
«ENDDEFINE»

«DEFINE getLinkWithClassVisualID FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static int «EXPAND getLinkWithClassVisualIDMethodName»(org.eclipse.emf.ecore.EObject domainElement) {
	if (domainElement == null) {
		«EXPAND unrecognizedVID-»
	}
	«EXPAND returnVisualID FOREACH links.select(link | isTypeLink(link))-»
	«EXPAND unrecognizedVID-»
}
«ENDDEFINE»

«DEFINE getLinkWithClassVisualIDMethodName FOR gmfgen::GenDiagram»getLinkWithClassVisualID«ENDDEFINE»


«DEFINE isDiagram FOR gmfgen::GenDiagram-»
	«IF null != domainDiagramElement-»
		«EXPAND xpt::Common::generatedMemberComment(
			"User can change implementation of this method to handle some specific\n" +
			"situations not covered by default logic.\n"
		)»
private static boolean isDiagram(«EXPAND MetaModel::QualifiedClassName FOR domainDiagramElement» element) {
	return true;
}
	«ENDIF-»
«ENDDEFINE»


«REM»

		Support for extra contstraints to check about model element.
		Includes expression fields for interpreted constrains (like ocl or regexp).
		For each model element that has an associated constraint, there's a method is<DomainElement>_<UID>()
		that performs extra specification as defined by value expression 

		FIXME don't use static fields, replace with instance/separate cache (e.g. accessible from Activator)
«ENDREM»

«DEFINE _constraintMethods FOR GenDiagram-»
«IF null != editorGen.expressionProviders-»
	«EXPAND _constraintMethod FOREACH topLevelNodes.select(n | n.modelFacet.modelElementSelector != null)-»
	«EXPAND _constraintMethod FOREACH childNodes.select(n | n.modelFacet.modelElementSelector != null)-»
	«FOREACH links AS l»«EXPAND _constraintMethod(l) FOR l.modelFacet»«ENDFOREACH»
«ENDIF-»
«ENDDEFINE»

«DEFINE _constraintMethod FOR GenNode-»
«EXPAND _domainElementConstraintMethod(this, modelFacet.modelElementSelector, modelFacet.metaClass) FOR modelFacet.modelElementSelector.provider»
«ENDDEFINE»

«DEFINE _constraintMethod(GenLink l) FOR LinkModelFacet»«ENDDEFINE» // no-op
«DEFINE _constraintMethod(GenLink l) FOR TypeLinkModelFacet-»
«IF modelElementSelector != null»«EXPAND _domainElementConstraintMethod(l, modelElementSelector, metaClass) FOR modelElementSelector.provider»«ENDIF-»
«ENDDEFINE»


«DEFINE _domainElementConstraintMethodName FOR GenCommonBase»is«getUniqueIdentifier()»«ENDDEFINE»

«DEFINE _domainElementConstraintMethod(GenCommonBase diagramElement, ValueExpression expression, GenClass context) FOR GenExpressionProviderBase»«ERROR "Constraint method is not supported for " + this»«ENDDEFINE»

«DEFINE _domainElementConstraintMethod(GenCommonBase diagramElement, ValueExpression expression, GenClass context) FOR GenJavaExpressionProvider-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static boolean «EXPAND _domainElementConstraintMethodName FOR diagramElement»(«EXPAND MetaModel::QualifiedClassName FOR context» domainElement) {
«IF injectExpressionBody && expression.body != null && expression.body.length() != 0-»
		«expression.body»
«ELSEIF throwException || (injectExpressionBody && (expression.body == null || expression.body.length() == 0))-»
		// FIXME: implement this method 
		// Ensure that you remove @@generated or mark it @@generated NOT
		throw new java.lang.UnsupportedOperationException("No java implementation provided in '«EXPAND _domainElementConstraintMethodName FOR diagramElement»' operation");«EXPAND xpt::Common::nonNLS»
«ELSE-»
		return false;
«ENDIF-»
	}
«ENDDEFINE»

«DEFINE _domainElementConstraintMethod(GenCommonBase diagramElement, ValueExpression expression, GenClass context) FOR GenExpressionInterpreter-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static boolean «EXPAND _domainElementConstraintMethodName FOR diagramElement»(«EXPAND MetaModel::QualifiedClassName FOR context» domainElement) {
		if («constraintFieldName(diagramElement)» == null) { // lazy initialization
			«constraintFieldName(diagramElement)» = «EXPAND xpt::expressions::getExpression::getExpression(expression, context)»; «EXPAND xpt::Common::nonNLS»
		}
		Object result = «constraintFieldName(diagramElement)».evaluate(domainElement);
		return result instanceof Boolean && ((Boolean)result).booleanValue();
	}			
«ENDDEFINE»


«DEFINE _constraintField FOR GenNode»«EXPAND _constraintField(this) FOR modelFacet»«ENDDEFINE»
«DEFINE _constraintField FOR GenLink»«EXPAND _constraintField(this) FOR modelFacet»«ENDDEFINE»

«DEFINE _constraintField(GenCommonBase diagramElement) FOR ModelFacet»«ENDDEFINE»
«DEFINE _constraintField(GenCommonBase diagramElement) FOR TypeModelFacet-»
«IF modelElementSelector != null»«EXPAND _constraintField(diagramElement) FOR modelElementSelector.provider»«ENDIF-»
«ENDDEFINE»

«DEFINE _constraintField(GenCommonBase diagramElement) FOR GenExpressionInterpreter»
	«EXPAND xpt::Common::generatedMemberComment»
	private static «container.getAbstractExpressionQualifiedClassName()» «constraintFieldName(diagramElement)»;
«ENDDEFINE»

«DEFINE _constraintField(GenCommonBase diagramElement) FOR GenExpressionProviderBase»«ERROR "Need to define approach to constraint fields for " + this»«ENDDEFINE»
«DEFINE _constraintField(GenCommonBase diagramElement) FOR GenJavaExpressionProvider»«ENDDEFINE»// IOW, no fields for Java

«REM»
		Constraints support end.
«ENDREM»


«DEFINE unrecognizedVID FOR gmfgen::GenDiagram-»
return -1;
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»@


1.19
log
@[228913], JavaProvider attributes: even if no body is set but throwsException is false, do not generate exception, rather respect throwException==false
@
text
@d71 6
a76 1
«DEFINE getTypeMethodCall FOR gmfgen::GenDiagram»«getVisualIDRegistryQualifiedClassName()».«EXPAND getTypeMethodName»«ENDDEFINE»
@


1.18
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d333 1
a333 1
«ELSEIF throwException || expression.body == null || expression.body.length() == 0-»
@


1.17
log
@[228913] cleaned isCopy and java provider's getOperationName that are not in use any more; introduced fine-tuning options: use expressions body for java methods and whether to throw exception or fail silently (using reasonable/appropriate for the context default value), latter change obsoleted NoImplException and respective debug options
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
d308 2
a309 2
	«EXPAND _constraintMethod(editorGen.expressionProviders) FOREACH topLevelNodes.select(n | n.modelFacet.modelElementSelector != null)-»
	«EXPAND _constraintMethod(editorGen.expressionProviders) FOREACH childNodes.select(n | n.modelFacet.modelElementSelector != null)-»
d314 2
a315 2
«DEFINE _constraintMethod(GenExpressionProviderContainer c) FOR GenNode-»
«EXPAND _domainElementConstraintMethod(this, modelFacet.modelElementSelector, modelFacet.metaClass) FOR c.getProvider(modelFacet.modelElementSelector)»
d320 1
a320 1
«IF modelElementSelector != null»«EXPAND _domainElementConstraintMethod(l, modelElementSelector, metaClass) FOR l.getDiagram().editorGen.expressionProviders.getProvider(modelElementSelector)»«ENDIF-»
d347 1
a347 1
			«constraintFieldName(diagramElement)» = «getQualifiedClassName()».«getExpressionAccessor(expression)»(«expression.getBodyString()», «EXPAND MetaModel::MetaClass FOR context»); «EXPAND xpt::Common::nonNLS»
d360 1
a360 1
«IF modelElementSelector != null»«EXPAND _constraintField(diagramElement) FOR diagramElement.getDiagram().editorGen.expressionProviders.getProvider(modelElementSelector)»«ENDIF-»
@


1.16
log
@[228913] item #5: clean getExpression, refactor its use
@
text
@d331 3
d336 4
a339 1
		throw new UnsupportedOperationException("No java implementation provided in '«EXPAND _domainElementConstraintMethodName FOR diagramElement»' operation"); «EXPAND xpt::Common::nonNLS»
@


1.15
log
@[228913] custom isXXX methods instead of generic evaluate() and useless nested JavaConstrainst collection of methods
@
text
@d20 1
d340 2
a341 2
		if («EXPAND _constraintFieldName FOR diagramElement» == null) { // lazy initialization
			«EXPAND _constraintFieldName FOR diagramElement» = «getQualifiedClassName()».«getExpressionAccessor(expression)»(«expression.getBodyString()», «EXPAND MetaModel::MetaClass FOR context»);
d343 1
a343 1
		Object result = «EXPAND _constraintFieldName FOR diagramElement».evaluate(domainElement);
a348 2
«DEFINE _constraintFieldName FOR GenCommonBase»«getUniqueIdentifier()»_Constraint«ENDDEFINE»

d359 1
a359 1
	private static «container.getAbstractExpressionQualifiedClassName()» «EXPAND _constraintFieldName FOR diagramElement»;
@


1.14
log
@make it slightly more similar to ElementInitializers that does almost the same
@
text
@d51 2
a52 2
	«EXPAND evaluateInterpreterExpression-»
	«EXPAND javaConstraints-»
d86 6
a91 5
private static final String DEBUG_KEY = «editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getBundle().getSymbolicName() + "/debug/visualID"; «EXPAND xpt::Common::nonNLS»
	«IF null != editorGen.expressionProviders-»
		«EXPAND xpt::expressions::getExpression::defineInterptererExpressionConstant FOREACH getAllNodes()-»
		«EXPAND xpt::expressions::getExpression::defineInterptererExpressionConstant FOREACH links-»
	«ENDIF-»
d176 2
d181 8
a225 13
«DEFINE checkSemanticElement FOR gmfgen::GenNode»«EXPAND checkDomainElementMetaclass FOR modelFacet.metaClass»«EXPAND checkDomainElementConstraints(this, getDiagram().editorGen.expressionProviders) FOR modelFacet»«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::GenExpressionProviderContainer providersContainer) FOR gmfgen::TypeModelFacet-»
«IF null != modelElementSelector && null != providersContainer» && «EXPAND checkDomainElementConstraints(commonBase, modelElementSelector, metaClass) FOR providersContainer.getProvider(modelElementSelector)»«ENDIF-»
«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass contextMetaclass) FOR gmfgen::GenExpressionProviderBase-»
	«ERROR "Unsupported expression provider: " + this-»
«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass contextMetaclass) FOR gmfgen::GenExpressionInterpreter»evaluate( «EXPAND xpt::expressions::getExpression::interptererExpressionConstantName FOR commonBase», domainElement)«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass contextMetaclass) FOR gmfgen::GenJavaExpressionProvider»«EXPAND javaConstraintContainerClassName FOR commonBase».«getOperationName(valueExpression)»(«EXPAND MetaModel::CastEObject("domainElement") FOR contextMetaclass»).booleanValue()«ENDDEFINE»
a280 9
«DEFINE checkSemanticElement FOR gmfgen::GenLink-»
	«EXPAND checkSemanticElement(this) FOR modelFacet-»
«ENDDEFINE»

«DEFINE checkSemanticElement(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet-»
	«ERROR "checkSemanticElement not supported only for TypeLinkModelFacet: " + this-»
«ENDDEFINE»

«DEFINE checkSemanticElement(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet»«EXPAND checkDomainElementMetaclass FOR metaClass»«EXPAND checkDomainElementConstraints(genLink, genLink.getDiagram().editorGen.expressionProviders)»«ENDDEFINE»
d295 20
a314 10
«REM»Can be moved to xpt::expressions::getExpression.xpt«ENDREM»
«DEFINE evaluateInterpreterExpression FOR gmfgen::GenDiagram-»
	«IF null != editorGen.expressionProviders && !editorGen.expressionProviders.providers.typeSelect(gmfgen::GenExpressionInterpreter).isEmpty()-»
	
	«EXPAND xpt::Common::generatedMemberComment»
private static boolean evaluate(«editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» expression, Object element) {
	Object result = expression.evaluate(element);
	return result instanceof Boolean && ((Boolean)result).booleanValue();			
}
	«ENDIF-»
d317 3
a319 10
«DEFINE javaConstraints FOR gmfgen::GenDiagram-»
«IF null != editorGen.expressionProviders && !editorGen.expressionProviders.providers.typeSelect(gmfgen::GenJavaExpressionProvider).isEmpty()-»
	
		«EXPAND xpt::Common::generatedClassComment»
private static class «EXPAND javaConstraintContainerClassName» {
	«EXPAND defineJavaConstraintOperation FOREACH getAllNodes()-»
	«EXPAND defineJavaConstraintOperation FOREACH links-»
	
}
«ENDIF-»
a321 2
«DEFINE defineJavaConstraintOperation FOR gmfgen::GenNode»«EXPAND defineJavaConstraintOperation(this) FOR modelFacet»«ENDDEFINE»
«DEFINE defineJavaConstraintOperation FOR gmfgen::GenLink»«EXPAND defineJavaConstraintOperation(this) FOR modelFacet»«ENDDEFINE»
d323 12
a334 1
«DEFINE defineJavaConstraintOperation(gmfgen::GenCommonBase commonBase) FOR gmfgen::ModelFacet»«ENDDEFINE»
d336 9
a344 4
«DEFINE defineJavaConstraintOperation(gmfgen::GenCommonBase commonBase) FOR gmfgen::TypeModelFacet-»
«IF null != modelElementSelector-»
	«EXPAND defineJavaConstraintOperation(modelElementSelector, metaClass) FOR commonBase.getDiagram().editorGen.expressionProviders.getProvider(modelElementSelector)-»
«ENDIF-»
a346 1
«DEFINE defineJavaConstraintOperation(gmfgen::ValueExpression valueExpression, genmodel::GenClass genClass) FOR gmfgen::GenExpressionProviderBase»«ENDDEFINE»
d348 8
a355 4
«DEFINE defineJavaConstraintOperation(gmfgen::ValueExpression valueExpression, genmodel::GenClass genClass) FOR gmfgen::GenJavaExpressionProvider-»
«IF !container.isCopy(valueExpression)-»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpression, genClass, null)-»
«ENDIF-»
d358 3
a360 2
«DEFINE unrecognizedVID FOR gmfgen::GenDiagram-»
return -1;
d363 2
a364 2
«REM»Can be moved to xpt::expressions::getExpression.xpt«ENDREM»
«DEFINE javaConstraintContainerClassName FOR gmfgen::GenCommonBase»JavaConstraints«ENDDEFINE»
d366 7
a372 2
«DEFINE constraintsNotSupported FOR gmfgen::GenCommonBase-»
	«ERROR "CheckConstraints method not supported for: " + this-»
@


1.13
log
@[150177] phase IV, fix last use of qualified class names in ElementInitializers (via GMFGen genmodel java methods). Cleaned genmodel of methods no longer in use, few methods moved to ElementInitializer.ext (pending removal/refactoring)
@
text
@d319 1
a319 1
	«IF null != editorGen.expressionProviders && !editorGen.expressionProviders.providers.typeSelect(gmfgen::GenJavaExpressionProvider).isEmpty()-»
d327 1
a327 1
	«ENDIF-»
d330 2
a331 7
«DEFINE defineJavaConstraintOperation FOR gmfgen::GenNode-»
	«EXPAND defineJavaConstraintOperation(this) FOR modelFacet-»
«ENDDEFINE»

«DEFINE defineJavaConstraintOperation FOR gmfgen::GenLink-»
	«EXPAND defineJavaConstraintOperation(modelFacet)-»
«ENDDEFINE»
d333 1
a333 5
«DEFINE defineJavaConstraintOperation(gmfgen::LinkModelFacet modelFacet) FOR gmfgen::GenLink»«ENDDEFINE»

«DEFINE defineJavaConstraintOperation(gmfgen::TypeLinkModelFacet typeModelFacet) FOR gmfgen::GenLink-»
	«EXPAND defineJavaConstraintOperation(this) FOR typeModelFacet-»
«ENDDEFINE»
d336 3
a338 3
	«IF null != modelElementSelector-»
		«EXPAND defineJavaConstraintOperation(modelElementSelector, metaClass) FOR commonBase.getDiagram().editorGen.expressionProviders.getProvider(modelElementSelector)-»
	«ENDIF-»
d344 3
a346 4
	«IF !container.isCopy(valueExpression)-»

		«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(valueExpression, genClass, null)-»
	«ENDIF-»
@


1.12
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d227 1
a227 1
«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass contextMetaclass) FOR gmfgen::GenJavaExpressionProvider»«EXPAND javaConstraintContainerClassName FOR commonBase».«getOperationName(valueExpression)»((«getQualifiedInstanceClassName(contextMetaclass)») domainElement).booleanValue()«ENDDEFINE»
@


1.11
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d176 1
a176 1
«DEFINE checkDomainElementMetaclass FOR genmodel::GenClass»«EXPAND xpt::Common::metaClassAccessor».isSuperTypeOf(domainElement.eClass())«ENDDEFINE»
@


1.10
log
@Removing FQName calls.
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d174 1
a174 1
«DEFINE checkSemanticElement FOR gmfgen::GenDiagram»«EXPAND checkDomainElementMetaclass FOR domainDiagramElement» && «EXPAND isDiagramMethodName»((«getQualifiedInterfaceName(domainDiagramElement)») domainElement)«ENDDEFINE»
d299 1
a299 1
private static boolean «EXPAND isDiagramMethodName»(«getQualifiedInterfaceName(domainDiagramElement)» element) {
a304 1
«DEFINE isDiagramMethodName FOR gmfgen::GenDiagram»isDiagram«ENDDEFINE»
@


1.9
log
@[194928]: Cannot create shortcut to a different model
@
text
@d180 1
a180 1
public static int «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodName»(org.eclipse.gmf.runtime.notation.View containerView, org.eclipse.emf.ecore.EObject domainElement) {
d182 1
a182 1
		«EXPAND xpt::editor::VisualIDRegistry::unrecognizedVID-»
d184 3
a186 3
	String containerModelID = «EXPAND xpt::editor::VisualIDRegistry::getModelIDMethodCall»(containerView);
	if (!«EXPAND xpt::editor::VisualIDRegistry::modelID».equals(containerModelID)«EXPAND xpt::editor::VisualIDRegistry::checkContainerModelID FOREACH shortcutsProvidedFor») { «EXPAND xpt::Common::nonNLS({}) FOREACH shortcutsProvidedFor SEPARATOR " "»
		«EXPAND xpt::editor::VisualIDRegistry::unrecognizedVID-»
d189 2
a190 2
	if («EXPAND xpt::editor::VisualIDRegistry::modelID».equals(containerModelID)) {
		containerVisualID = «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall»(containerView);
d193 1
a193 1
			containerVisualID = «EXPAND xpt::editor::VisualIDRegistry::visualID»;		
d195 1
a195 1
			«EXPAND xpt::editor::VisualIDRegistry::unrecognizedVID-»
d199 1
a199 1
		«EXPAND xpt::editor::VisualIDRegistry::caseDomainContainerVisualID FOREACH getAllContainers()-»
d201 1
a201 1
	«EXPAND xpt::editor::VisualIDRegistry::unrecognizedVID-»
@


1.8
log
@[191853] - Convert /editor/ElementChooser.javajet template to xpand
@
text
@d180 17
a196 3
public static int «EXPAND getNodeVisualIDMethodName»(org.eclipse.gmf.runtime.notation.View containerView, org.eclipse.emf.ecore.EObject domainElement) {
	if (domainElement == null || !«EXPAND modelID».equals(«EXPAND getModelIDMethodCall»(containerView))) {
		«EXPAND unrecognizedVID-»
d198 2
a199 2
	switch («EXPAND getVisualIDMethodCall»(containerView)) {
		«EXPAND caseDomainContainerVisualID FOREACH getAllContainers()-»
d201 1
a201 1
	«EXPAND unrecognizedVID-»
@


1.8.2.1
log
@[194928] - Cannot create shortcut to different model
Merging changes from head to branch.
@
text
@d181 1
a181 5
	if (domainElement == null) {
		«EXPAND unrecognizedVID-»
	}
	String containerModelID = «EXPAND getModelIDMethodCall»(containerView);
	if (!«EXPAND modelID».equals(containerModelID)«EXPAND checkContainerModelID FOREACH shortcutsProvidedFor») { «EXPAND xpt::Common::nonNLS({}) FOREACH shortcutsProvidedFor SEPARATOR " "»
d184 1
a184 11
	int containerVisualID;
	if («EXPAND modelID».equals(containerModelID)) {
		containerVisualID = «EXPAND getVisualIDMethodCall»(containerView);
	} else {
		if (containerView instanceof org.eclipse.gmf.runtime.notation.Diagram) {
			containerVisualID = «EXPAND visualID»;		
		} else {
			«EXPAND unrecognizedVID-»
		}
	}
	switch (containerVisualID) {
@


1.7
log
@The generated code should compile when getVisualID method is named differently because of aspect
@
text
@d219 1
a219 1
	if (!«EXPAND modelID».equals(containerModelID)«EXPAND checkContainerModelID FOREACH shortcutsProvidedFor») {«EXPAND xpt::Common::nonNLS({}) FOREACH shortcutsProvidedFor»
@


1.6
log
@Remove unused methods from xpt::editor::Utils.ext;
Simplify VisualIDRegisutry template (and do not generate code that does nothing)
@
text
@d103 1
a103 1
	return getVisualID(view.getType());
@


1.5
log
@- ViewProvider is in xpand now.
- Separating semantic part of VisualIDRegistry from pure-notation.
@
text
@d233 2
a234 2
		«EXPAND caseContainerVisualID FOREACH getAllContainers()-»
		«EXPAND caseLinkVisualID FOREACH links-»
d244 1
a244 1
«DEFINE caseContainerVisualID FOR gmfgen::GenContainerBase-»
d246 1
a246 2
	«EXPAND checkNodeEssentialChildren-»
	«EXPAND checkEssentialChild FOREACH containedNodes-»
a249 15
«DEFINE caseLinkVisualID FOR gmfgen::GenLink-»
	«IF !labels.isEmpty()-»
«EXPAND xpt::Common::caseVisualID»
	«EXPAND checkEssentialChild FOREACH labels-»
	break;
	«ENDIF-»
«ENDDEFINE»

«DEFINE checkNodeEssentialChildren FOR gmfgen::GenContainerBase»«ENDDEFINE»

«DEFINE checkNodeEssentialChildren FOR gmfgen::GenNode-»
	«EXPAND checkEssentialChild FOREACH labels-»
	«EXPAND checkEssentialChild FOREACH compartments-»
«ENDDEFINE»

@


1.4
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@d19 1
a43 2
	«EXPAND getDiagramVisualIDInternal-»
	
d46 1
a46 1
	«EXPAND getNodeVisualIDFull-»
a49 1
	«EXPAND getLinkWithClassVisualIDFull-»
a50 8
	
	«EXPAND getUnrecognizedIDMethod("org.eclipse.emf.ecore.EObject domainElement") FOR getUnrecognizedDiagramIDMethodName()-»
	
	«EXPAND getUnrecognizedIDMethod("org.eclipse.gmf.runtime.notation.View containerView, org.eclipse.emf.ecore.EObject domainElement") FOR getUnrecognizedNodeIDMethodName()-»
	
	«EXPAND getUnrecognizedIDMethod("org.eclipse.emf.ecore.EObject domainElement") FOR getUnrecognizedLinkWithClassIDMethodName()-»
	«EXPAND getUnrecognizedContainerChildIDMethod FOREACH getAllContainers()-»
	«EXPAND getUnrecognizedLinkLabelIDMethod FOREACH links.select(link | !link.labels.isEmpty())-»
d76 2
d100 1
a100 1
			return -1;
d136 1
a136 1
	return -1;
d153 1
a153 1
		return -1;
d155 4
a158 2
	org.eclipse.emf.ecore.EClass domainElementMetaclass = domainElement.eClass();
	return «EXPAND getDiagramVisualIDMethodName»(domainElement, domainElementMetaclass);
d164 3
a166 9
«DEFINE getDiagramVisualIDInternal FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
private static int «EXPAND getDiagramVisualIDMethodName»(org.eclipse.emf.ecore.EObject domainElement, org.eclipse.emf.ecore.EClass domainElementMetaclass) {
«IF null != domainDiagramElement-»
	if («EXPAND checkSemanticElement») {
		return «EXPAND visualID»;
	}
«ENDIF-»
	return «getUnrecognizedDiagramIDMethodName()»(domainElement);
d170 8
d181 5
a185 2
	if (domainElement == null) {
		return -1;
d187 1
a187 2
	org.eclipse.emf.ecore.EClass domainElementMetaclass = domainElement.eClass();
	return «EXPAND getNodeVisualIDMethodName»(containerView, domainElement, domainElementMetaclass, null);
d193 23
a215 1
«DEFINE getNodeVisualIDFull FOR gmfgen::GenDiagram-»
d217 1
a217 1
public static int «EXPAND getNodeVisualIDMethodName»(org.eclipse.gmf.runtime.notation.View containerView, org.eclipse.emf.ecore.EObject domainElement, org.eclipse.emf.ecore.EClass domainElementMetaclass, String semanticHint) {
d219 2
a220 2
	if (!«EXPAND modelID».equals(containerModelID)«EXPAND checkContainerModelID FOREACH shortcutsProvidedFor») {
		return -1;
d227 1
a227 1
			containerVisualID = «visualID»;		
d229 1
a229 1
			return -1;
a231 1
	int nodeVisualID = semanticHint != null ? «EXPAND getVisualIDMethodCall»(semanticHint) : -1;
d236 1
a236 1
	return «getUnrecognizedNodeIDMethodName()»(containerView, domainElement);
d240 2
d247 2
a248 2
	«EXPAND checkChildNode FOREACH containedNodes-»
	return «getUnrecognizedChildNodeIDMethodName(this)»(domainElement, semanticHint);
d255 1
a255 1
	return «getUnrecognizedLinkLabelIDMethodName(this)»(semanticHint);
d268 1
a268 1
	return «EXPAND visualID»;
a271 30
«DEFINE checkChildNode FOR gmfgen::GenNode-»
if ((semanticHint == null || «EXPAND visualID» == nodeVisualID)«EXPAND checkSemanticElement(this) FOR modelFacet») {
	return «EXPAND visualID»;
}
«ENDDEFINE»

«DEFINE checkSemanticElement FOR gmfgen::GenDiagram»«EXPAND checkDomainElementMetaclass FOR domainDiagramElement» && «EXPAND isDiagramMethodName»((«getQualifiedInterfaceName(domainDiagramElement)») domainElement)«ENDDEFINE»

«DEFINE checkSemanticElement(gmfgen::GenNode genNode) FOR gmfgen::TypeModelFacet-»
 && «EXPAND checkDomainElementMetaclass FOR metaClass»«EXPAND checkDomainElementConstraints(genNode, genNode.getDiagram().editorGen.expressionProviders)-»
«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::GenExpressionProviderContainer providersContainer) FOR gmfgen::TypeModelFacet-»
«IF null != modelElementSelector && null != providersContainer» && (domainElement == null || «EXPAND checkDomainElementConstraints(commonBase, modelElementSelector, metaClass) FOR providersContainer.getProvider(modelElementSelector)»)«ENDIF-»
«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass contextMetaclass) FOR gmfgen::GenExpressionProviderBase-»
	«ERROR "Unsupported expression provider: " + this-»
«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass contextMetaclass) FOR gmfgen::GenExpressionInterpreter»evaluate( «EXPAND xpt::expressions::getExpression::interptererExpressionConstantName FOR commonBase», domainElement)«ENDDEFINE»

«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass contextMetaclass) FOR gmfgen::GenJavaExpressionProvider»«EXPAND javaConstraintContainerClassName FOR commonBase».«getOperationName(valueExpression)»((«getQualifiedInstanceClassName(contextMetaclass)») domainElement).booleanValue()«ENDDEFINE»

«DEFINE checkSemanticElement(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
«EXPAND checkDomainElementMetaclass FOR metaClass»«EXPAND checkDomainElementConstraints(genLink, genLink.getDiagram().editorGen.expressionProviders)-»
«ENDDEFINE»

«DEFINE checkDomainElementMetaclass FOR genmodel::GenClass»«EXPAND xpt::Common::metaClassAccessor».isSuperTypeOf(domainElementMetaclass)«ENDDEFINE»

d276 1
a276 1
		return -1;
d278 2
a279 2
	org.eclipse.emf.ecore.EClass domainElementMetaclass = domainElement.eClass();
	return «EXPAND getLinkWithClassVisualIDMethodName»(domainElement, domainElementMetaclass);
d285 2
a286 6
«DEFINE getLinkWithClassVisualIDFull FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
public static int «EXPAND getLinkWithClassVisualIDMethodName»(org.eclipse.emf.ecore.EObject domainElement, org.eclipse.emf.ecore.EClass domainElementMetaclass) {
	«EXPAND checkLink FOREACH links-»
	return «getUnrecognizedLinkWithClassIDMethodName()»(domainElement);
}
d289 2
a290 2
«DEFINE checkLink FOR gmfgen::GenLink-»
	«EXPAND checkLink(this) FOR modelFacet-»
d293 1
a293 7
«DEFINE checkLink(gmfgen::GenLink genLink) FOR gmfgen::LinkModelFacet»«ENDDEFINE»

«DEFINE checkLink(gmfgen::GenLink genLink) FOR gmfgen::TypeLinkModelFacet-»
if («EXPAND checkSemanticElement(genLink)») {
	return «EXPAND visualID FOR genLink»;
}
«ENDDEFINE»
a308 20
«DEFINE getUnrecognizedContainerChildIDMethod FOR gmfgen::GenContainerBase-»
	
	«EXPAND getUnrecognizedIDMethod("org.eclipse.emf.ecore.EObject domainElement, String semanticHint") FOR getUnrecognizedChildNodeIDMethodName(this)-»
«ENDDEFINE»

«DEFINE getUnrecognizedLinkLabelIDMethod FOR gmfgen::GenLink-»

	«EXPAND getUnrecognizedIDMethod("String semanticHint") FOR getUnrecognizedLinkLabelIDMethodName(this)-»
«ENDDEFINE»

«DEFINE getUnrecognizedIDMethod(String parameters) FOR String-»
	«EXPAND xpt::Common::generatedMemberComment(
		"User can change implementation of this method to handle some specific\n" +
		"situations not covered by default logic.\n"
	)»
private static int «this»(«parameters») {
	return -1;
}
«ENDDEFINE»

d362 4
d370 1
a370 1
	«ERROR "CehckConstraints method not supported for: " + this-»
@


1.3
log
@Refactoring templates to store ExpressionInterpreter-based definition in the same file.
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
@


1.2
log
@Replacing static method calls with templates.
@
text
@d61 1
a61 1
	«EXPAND evaluateOCLExpression-»
d96 2
a97 2
		«EXPAND defineOCLConstraintVariable FOREACH getAllNodes()-»
		«EXPAND defineOCLConstraintVariable FOREACH links-»
a100 28
«DEFINE defineOCLConstraintVariable FOR gmfgen::GenNode-»
	«EXPAND defineOCLConstraintVariable(this) FOR modelFacet-»
«ENDDEFINE»

«DEFINE defineOCLConstraintVariable FOR gmfgen::GenLink-»
	«EXPAND defineOCLConstraintVariable(modelFacet)-»
«ENDDEFINE»

«DEFINE defineOCLConstraintVariable(gmfgen::LinkModelFacet modelFacet) FOR gmfgen::GenLink»«ENDDEFINE»

«DEFINE defineOCLConstraintVariable(gmfgen::TypeLinkModelFacet typeModelFacet) FOR gmfgen::GenLink-»
	«EXPAND defineOCLConstraintVariable(this) FOR typeModelFacet-»
«ENDDEFINE»

«DEFINE defineOCLConstraintVariable(gmfgen::GenCommonBase commonBase) FOR gmfgen::TypeModelFacet-»
	«IF null != modelElementSelector-»
		«EXPAND defineOCLConstraint(commonBase, modelElementSelector, metaClass) FOR commonBase.getDiagram().editorGen.expressionProviders.getProvider(modelElementSelector)-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE defineOCLConstraint(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass metaclass) FOR gmfgen::GenExpressionProviderBase»«ENDDEFINE»

«DEFINE defineOCLConstraint(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass metaclass) FOR gmfgen::GenExpressionInterpreter-»

	«EXPAND xpt::Common::generatedMemberComment»
private static final «container.editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» «EXPAND oclConstraintVariableName FOR commonBase» = «EXPAND xpt::expressions::getExpression::getExpression(valueExpression, metaclass)»;
«ENDDEFINE»

d271 1
a271 1
«DEFINE checkDomainElementConstraints(gmfgen::GenCommonBase commonBase, gmfgen::ValueExpression valueExpression, genmodel::GenClass contextMetaclass) FOR gmfgen::GenExpressionInterpreter»evaluate(«EXPAND oclConstraintVariableName FOR commonBase», domainElement)«ENDDEFINE»
d348 2
a349 1
«DEFINE evaluateOCLExpression FOR gmfgen::GenDiagram-»
d401 1
a401 2
«DEFINE oclConstraintVariableName FOR gmfgen::GenCommonBase»«getUniqueIdentifier()»_Constraint«ENDDEFINE»

@


1.1
log
@Generating VisualIDRegistry using XPAND.
@
text
@d74 2
a431 2
«DEFINE modelID FOR gmfgen::GenDiagram»«getEditPartQualifiedClassName()».MODEL_ID«ENDDEFINE»

@

