head	1.23;
access;
symbols
	v20081022-1925:1.23
	v20081015-1925:1.23
	v20081008-1925:1.23
	v20081001-1925:1.23
	v20080930-1130:1.23
	v20080926-1245:1.23
	v20080924-1925:1.23
	v20080917-1925:1.23
	v20080911-1728:1.23
	v20080910-1520:1.23
	v20080903-1520:1.23
	v20080827-1520:1.23
	v20080813-1520:1.23
	v20080806-1520:1.23
	v20080722-1827:1.23
	v20080718-1731:1.23
	v20080716-1600:1.22
	v20080716-1642:1.23
	R2_1_maintenance:1.22.0.2
	Root_R2_1_maintenance:1.22
	R2_1_0:1.22
	v20080610-1132:1.22
	v20080603-1553:1.22
	v20080528-1052:1.22
	v20080521:1.22
	v20080516-1543:1.22
	v20080516-1143:1.22
	v20080512-1200:1.22
	v20080508-2000:1.22
	v20080507-1326:1.22
	v20080503-1740:1.22
	v20080501-1739:1.22
	v20080425-1959:1.22
	v20080417-1610:1.22
	v20080411-0411:1.21
	v20080404-1111:1.21
	v20080322-0000:1.21
	v20080222-1200:1.15
	v20080215-1500:1.15
	v20080207-0207:1.14.2.1
	v20071222-1111:1.15
	v20071214-1111:1.15
	v20071130-1111:1.15
	v20071124-0000:1.14.2.1
	v20071112-0000:1.15
	v20071108-0000:1.15
	v20071003-0000:1.15
	v20070928-0000:1.14.2.1
	v20070921-0000:1.14.2.1
	v20070915-0000:1.14.2.1
	v20070903-0000:1.15
	v20070809-0000:1.14
	R2_0_maintenance:1.14.0.2
	R2_0:1.14
	R4_20:1.14
	v20070621-0000:1.14
	RC3_20:1.14
	v20070614-1400:1.14
	v20070608-1300:1.14
	v20070605-1400:1.13
	v20070601-1400:1.13
	v20070525-1500:1.13
	v20070520-1200:1.13
	v20070518-1300:1.13
	v20070504-1000:1.13
	v20070427-0600:1.12
	v20070420-1000:1.12
	v20070413-1300:1.12
	v20070405-1100:1.11
	v20070403-1500:1.9
	v20070330-1300:1.9
	v20060330-1300:1.9
	v20070322-1100:1.8
	v20060316-0600:1.8
	v20070307-0700:1.8
	v20070301-1200:1.8
	v20070228-2000:1.8
	v20070221-1500:1.7
	v20070208-1800:1.6
	v20070103-0300:1.2
	M4_20:1.2
	v20061222-1800:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.23
date	2008.07.03.12.30.06;	author atikhomirov;	state Exp;
branches;
next	1.22;
commitid	6ea4486cc64d4567;

1.22
date	2008.04.14.08.38.03;	author atikhomirov;	state Exp;
branches;
next	1.21;
commitid	1b0e480317df4567;

1.21
date	2008.03.05.14.56.39;	author atikhomirov;	state Exp;
branches;
next	1.20;
commitid	14ff47ceb4a74567;

1.20
date	2008.02.29.21.19.52;	author atikhomirov;	state Exp;
branches;
next	1.19;
commitid	45a447c876f24567;

1.19
date	2008.02.26.22.50.30;	author atikhomirov;	state Exp;
branches;
next	1.18;
commitid	405847c497b64567;

1.18
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.17;
commitid	19d047c419ed4567;

1.17
date	2008.02.22.11.56.45;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	6cf447beb87c4567;

1.16
date	2008.02.22.11.24.53;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	5c9347beb1044567;

1.15
date	2007.07.04.13.22.06;	author bblajer;	state Exp;
branches;
next	1.14;
commitid	3eb4468b9efc4567;

1.14
date	2007.06.07.16.26.10;	author dstadnik;	state Exp;
branches
	1.14.2.1;
next	1.13;
commitid	1db7466831a14567;

1.13
date	2007.05.04.10.50.01;	author dstadnik;	state Exp;
branches;
next	1.12;
commitid	29e4463b0fd84567;

1.12
date	2007.04.06.14.37.41;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	5df46165b334567;

1.11
date	2007.04.04.11.05.04;	author bblajer;	state Exp;
branches;
next	1.10;
commitid	18d94613865e4567;

1.10
date	2007.04.03.19.28.21;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	24744612aad14567;

1.9
date	2007.03.23.09.27.29;	author dstadnik;	state Exp;
branches;
next	1.8;
commitid	6f4346039d7f4567;

1.8
date	2007.02.26.14.30.20;	author bblajer;	state Exp;
branches;
next	1.7;
commitid	766a45e2eefb4567;

1.7
date	2007.02.14.13.42.18;	author bblajer;	state Exp;
branches;
next	1.6;
commitid	75b545d311ba4567;

1.6
date	2007.02.02.19.45.10;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	1a2145c394c34567;

1.5
date	2007.02.02.17.14.37;	author bblajer;	state Exp;
branches;
next	1.4;
commitid	78ec45c3717d4567;

1.4
date	2007.01.25.16.57.54;	author ashatalin;	state Exp;
branches;
next	1.3;
commitid	271945b8e1904567;

1.3
date	2007.01.17.13.12.34;	author ashatalin;	state Exp;
branches;
next	1.2;
commitid	3d0045ae20c04567;

1.2
date	2006.12.20.15.44.42;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	609545895a6a4567;

1.1
date	2006.12.20.02.16.53;	author dstadnik;	state Exp;
branches;
next	;
commitid	1ea745889d114567;

1.14.2.1
date	2007.09.12.12.20.48;	author dstadnik;	state Exp;
branches;
next	;
commitid	42c246e7d99f4567;


desc
@@


1.23
log
@[183812] respect constraints for EReference#eOpposite during link creation
@
text
@/*
 * Copyright (c) 2006, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

import "http://www.eclipse.org/emf/2002/GenModel";
import "http://www.eclipse.org/emf/2002/Ecore";

/*
 * GenModel functionality unrelated to EMF generated code
 * or metamodel access only.
 */


// GenPackage#getDocumentRoot
genmodel::GenClass getDocumentRoot(genmodel::GenPackage gp) :
JAVA org.eclipse.gmf.internal.codegen.util.GenModelUtils.getDocumentRoot(org.eclipse.emf.codegen.ecore.genmodel.GenPackage)
;

// GenModel#findGenClassifier()
genmodel::GenClassifier findGenClassifier(genmodel::GenModel genModel, ecore::EClassifier eClassifier) :
JAVA org.eclipse.gmf.internal.codegen.util.GenModelUtils.findGenClassifier(org.eclipse.emf.codegen.ecore.genmodel.GenModel, org.eclipse.emf.ecore.EClassifier)
;

//GenFeature#getReverse
genmodel::GenFeature getReverse(genmodel::GenFeature feature) :
	isReferenceType(feature) ?
		(let eReverseFeature = ((ecore::EReference) feature.ecoreFeature).eOpposite : 
			eReverseFeature != null ? 
				(let genClass = (genmodel::GenClass) findGenClassifier(feature.genClass.genPackage.genModel, eReverseFeature.eContainingClass) :
					genClass != null ? 
						genClass.genFeatures.select(e|e.ecoreFeature == eReverseFeature).first()
						: null
				)
			: null
		)
		: null
;

// For primitive types, return their java.lang wrappers, for non-primitive
// types returns instanceClassName as is
String getObjectCompatibleClassName(EDataType dt) :
	dt.instanceClassName.toCharList().contains(".") 
		? dt.instanceClassName
		: switch (dt.instanceClassName) {
			case "boolean" : "java.lang.Boolean"
			case "byte"    : "java.lang.Byte"
			case "char"    : "java.lang.Character"
			case "double"  : "java.lang.Double"
			case "float"   : "java.lang.Float"
			case "int"     : "java.lang.Integer"
			case "long"    : "java.lang.Long"
			case "short"   : "java.lang.Short"
			default : "java.lang.Object"
		}
;

// GenFeature#isListType()
boolean isListType(genmodel::GenFeature feature) :
JAVA org.eclipse.gmf.internal.codegen.util.GenModelUtils.isListType(org.eclipse.emf.codegen.ecore.genmodel.GenFeature)
;

// GenFeature#isDerived()
boolean isDerived(genmodel::GenFeature feature) :
JAVA org.eclipse.gmf.internal.codegen.util.GenModelUtils.isDerived(org.eclipse.emf.codegen.ecore.genmodel.GenFeature)
;

// GenFeature#getTypeGenClass()
genmodel::GenClass getTypeGenClassX(genmodel::GenFeature feature) :
JAVA org.eclipse.gmf.internal.codegen.util.GenModelUtils.getTypeGenClass(org.eclipse.emf.codegen.ecore.genmodel.GenFeature)
;

// GenFeature#getTypeGenClassifier()
genmodel::GenClassifier getTypeGenClassifier(genmodel::GenFeature feature) :
	findGenClassifier(feature.genClass.genPackage.genModel, feature.ecoreFeature.eType)
;

// FIXME: for models loaded from generated package (e.g. gmf tests often
// refer to EClass/EOperation directly from EcorePackage) instanceClassName
// is always set and thus all metamodel types are treated as external interfaces,
// with useless casts to EObject
//
// GenClass#isExternalInterface()
boolean isExternalInterface(genmodel::GenClass genClass) :
	null != genClass.ecoreClass.instanceClassName
;


// GenFeatureImpl#isContains
boolean isContains(genmodel::GenFeature gf) :
	isReferenceType(gf) && ((ecore::EReference) gf.ecoreFeature).containment
;

boolean isPrimitiveType(genmodel::GenFeature gf) :
	{"boolean", "byte", "char", "double", "float", "int", "long", "short"}.contains(gf.ecoreFeature.eType.instanceClassName)
;

private boolean isReferenceType(genmodel::GenFeature gf) :
	!{gf.ecoreFeature}.typeSelect(ecore::EReference).isEmpty()
;
@


1.22
log
@[226149] Refactor Validation/Constraints: explicit context groupings instead of ID matching, unused IClientSelectors implementations are no longer generated, less custom code in the model, odd approach with map (semanticCtxIdMap) replaced with in-place VisualID check.
@
text
@d34 8
a41 6
	let eReverseFeature = ((ecore::EReference) feature.ecoreFeature).eOpposite :
		eReverseFeature != null ? 
			(let genClass = (genmodel::GenClass) findGenClassifier(feature.genClass.genPackage.genModel, eReverseFeature.eContainingClass) :
				genClass != null ? 
					genClass.genFeatures.select(e|e.ecoreFeature == eReverseFeature).first()
					: null)
d43 2
@


1.21
log
@fixme reminder
@
text
@d76 5
d97 4
@


1.20
log
@[150177] phase IV, fix last use of qualified class names in ElementInitializers (via GMFGen genmodel java methods). Cleaned genmodel of methods no longer in use, few methods moved to ElementInitializer.ext (pending removal/refactoring)
@
text
@d76 5
@


1.19
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template, LiteRT version updated
@
text
@d43 18
@


1.18
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@a62 33
/*
Casts the argument (which is assumed to be of the given source class) to the given target class. 
A null value may be used for both source and target class to specify the EObject class.
If the cast is required, it will be parenthesized as a whole, producing, e.g., ((EObject) o). 
If the parentheses are not required, use unparenthesizedCast() extension.
*/
/***********************************
String parenthesizedCast(String what, genmodel::GenClass source, genmodel::GenClass target) :
	needsCast(source, target) ? "(" + unparenthesizedCast(what, source, target) + ")" : what
;
*/
/*
Casts the argument (which is assumed to be of the given source class) to the given target class. 
A null value may be used for both source and target class to specify the EObject class.
If the cast is required, it will NOT be parenthesized as a whole, producing, e.g., (EObject) o. 
If the parentheses are required, use parenthesizedCast() extension.
*/
/***********************************
String unparenthesizedCast(String what, genmodel::GenClass source, genmodel::GenClass target) :
	needsCast(source, target) ? 
		(target == null ? "(org.eclipse.emf.ecore.EObject)" + what : "(" + target.getQualifiedInterfaceName() + ")" + what)
		: what
;

//See cast()
private boolean needsCast(genmodel::GenClass source, genmodel::GenClass target) :
	source == target ? false :
		(target == null ? 
			(source != null && source.isExternalInterface()) : 
			source == null || target.isExternalInterface() || source.isExternalInterface() || !target.ecoreClass.isSuperTypeOf(source.ecoreClass))
;

*/
@


1.17
log
@copyright year updated; minor fix to use common code
@
text
@d16 4
a19 48
//
// GenPackageImpl#getQualifiedPackageInterfaceName()
//
String getQualifiedPackageInterfaceName(genmodel::GenPackage gp) :
	gp.genModel.suppressEMFMetaData ? getQualifiedPackageClassName(gp) : getReflectionPackageName(gp) + "." + getPackageInterfaceName(gp)
;

// GenPackageImpl#getQualifiedFactoryInterfaceName()
String getQualifiedFactoryInterfaceName(genmodel::GenPackage gp) :
	getReflectionPackageName(gp) + "." + getPrefixedName(gp, "Factory")
;

//
// GenPackageImpl#getQualifiedItemProviderAdapterFactoryClassName()
//
String getQualifiedItemProviderAdapterFactoryClassName(genmodel::GenPackage gp) :
	getQualifiedPackageName(gp, gp.providerPackageSuffix) + "." + getItemProviderAdapterFactoryClassName(gp)
;

//
// GenPackageImpl#getItemProviderAdapterFactoryClassName()
//
String getItemProviderAdapterFactoryClassName(genmodel::GenPackage gp) :
	getPrefixedName(gp, "ItemProviderAdapterFactory")
;
//
// GenClass#getQualifiedInterfaceName
//
String getQualifiedInterfaceName(genmodel::GenClass gc) :
	null != gc.ecoreClass.instanceClassName 
		? gc.ecoreClass.instanceClassName.replaceAll('\\$', '\\.')
		: (let gp = gc.genPackage
			: (null != gp.basePackage && gp.basePackage.length() > 0 ? gp.basePackage + "." : "") 
				+ safeName(gp.ecorePackage.name) 
				+ (null != gp.interfacePackageSuffix && gp.interfacePackageSuffix.length() > 0 ? "." + gp.interfacePackageSuffix : "")
				+ "." + gc.ecoreClass.name)
;

//
// GenClass#getClassifierAccessorName
//
String getClassifierAccessorName(genmodel::GenClassifier gc) :
	switch (gc.getEcoreClassifier().name) {
		case "Class" : "Class_"
		case "Name" : "Name_"
		default : gc.getEcoreClassifier().name
	}
;
a20 23
ecore::EClassifier getEcoreClassifier(genmodel::GenClassifier gc) :
	null
;

ecore::EClassifier getEcoreClassifier(genmodel::GenClass gc) :
	gc.ecoreClass
;

ecore::EClassifier getEcoreClassifier(genmodel::GenDataType gc) :
	gc.ecoreDataType
;

//
// GenFeature#getFeatureAccessorName
//
String getFeatureAccessorName(genmodel::GenFeature gf) :
	gf.genClass.ecoreClass.name + "_" + gf.ecoreFeature.name.toFirstUpper()
;

// GenFeatureImpl#getAccessorName
String getAccessorName(genmodel::GenFeature gf) :
	isMapEntryFeature(gf) ? "Typed" + gf.ecoreFeature.name.toFirstUpper() : gf.ecoreFeature.name.toFirstUpper()
;
a26 5
// GenFeature#getGetAccessor()
String getGetAccessor(genmodel::GenFeature gf) :
JAVA org.eclipse.gmf.internal.codegen.util.GenModelUtils.getGetAccessor(org.eclipse.emf.codegen.ecore.genmodel.GenFeature)
;

a62 5
// GenPackage#getFactoryInstanceName
String getFactoryInstanceName(genmodel::GenPackage gp) :
	gp.genModel.suppressEMFMetaData ? "INSTANCE" : "eINSTANCE"
;

d69 1
d73 1
a73 1

d80 1
d95 1
a95 60
// GenFeatureImpl#isMapEntryFeature
private boolean isMapEntryFeature(genmodel::GenFeature gf) :
	gf.genClass.isMapEntry() && ("key" == gf.ecoreFeature.name || "value" == gf.ecoreFeature.name)
;

// GenClassImpl#isMapEntry
boolean isMapEntry(genmodel::GenClass gc) :
	("java.util.Map.Entry" == gc.ecoreClass.instanceClassName || "java.util.Map$Entry" == gc.ecoreClass.instanceClassName) 
		&& gc.ecoreClass.getEStructuralFeature("key") != null
		&& gc.ecoreClass.getEStructuralFeature("value") != null
;

// GenPackageImpl#getReflectionPackageName()
private String getReflectionPackageName(genmodel::GenPackage gp) :
	getQualifiedPackageName(gp, gp.metaDataPackageSuffix)
;

// GenPackageImpl#getQualifiedPackageClassName()
private String getQualifiedPackageClassName(genmodel::GenPackage gp) :
	getReflectionClassPackageName(gp) + "." + getPackageClassName(gp)
;


// GenPackageImpl#getReflectionClassPackageName()
private String getReflectionClassPackageName(genmodel::GenPackage gp) :
	getQualifiedPackageName(gp, gp.genModel.suppressInterfaces ? gp.metaDataPackageSuffix : gp.classPackageSuffix)
;

// GenPackageImpl#getPackageClassName()
private string getPackageClassName(genmodel::GenPackage gp) :
	!gp.genModel.suppressEMFMetaData && !gp.genModel.suppressInterfaces ? getPackageInterfaceName(gp) + "Impl" : getPackageInterfaceName(gp)
;

// GenPackageImpl#getPackageInterfaceName()
private string getPackageInterfaceName(genmodel::GenPackage gp) :
	gp.genModel.suppressEMFMetaData && !gp.genModel.suppressInterfaces ? getPrefixedName(gp, "PackageImpl") : getPrefixedName(gp, "Package")
;

// GenPackageImpl#getPrefixedName()
private string getPrefixedName(genmodel::GenPackage gp, String name) :
	null != gp.prefix ? gp.prefix + name : name
;

// GenPackageImpl#getQualifiedPackageName(String)
private String getQualifiedPackageName(genmodel::GenPackage gp, String suffix) :
	isBlank(suffix) ? getQualifiedPackageName(gp) : getQualifiedPackageName(gp) + "." + suffix
;

// GenPackageImpl#getQualifiedPackageName()
private String getQualifiedPackageName(genmodel::GenPackage gp) :
	isBlank(gp.basePackage) ? safeName(gp.ecorePackage.name) : gp.basePackage + "." + safeName(gp.ecorePackage.name)
;

private boolean isBlank(String s) :
	null == s || s.length() == 0
;

private String safeName(String name) :
JAVA org.eclipse.emf.codegen.util.CodeGenUtil.safeName(java.lang.String)
;
a104 10

// move it to static java method
String getFeatureTargetType(genmodel::GenFeature feature) :
	isListType(feature)
		? "java.util.List"
		: (let classifier = findGenClassifier(feature.genClass.genPackage.genModel, feature.ecoreFeature.eType)
			: {classifier}.typeSelect(genmodel::GenClass).isEmpty() 
				? ((genmodel::GenDataType) classifier).ecoreDataType.instanceClassName
				: getQualifiedInterfaceName((genmodel::GenClass) classifier))
;
@


1.16
log
@[150177] phase I, refactor existing code: use same template for metainfo access
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.15
log
@Some methods and templates should be applicable to GenClassifier, not GenClass;
@
text
@a83 14
//
// GenFeature#getQualifiedFeatureAccessorName
//
String getQualifiedFeatureAccessorName(genmodel::GenFeature gf) :
	getQualifiedPackageInterfaceName(gf.genClass.genPackage) + ".eINSTANCE.get" + getFeatureAccessorName(gf)
;

//
// GenClassifier#getQualifiedClassifierAccessor
//
String getQualifiedClassifierAccessor(genmodel::GenClassifier gc) :
	getQualifiedPackageInterfaceName(gc.genPackage) + ".eINSTANCE.get" + getClassifierAccessorName(gc)
;

@


1.14
log
@add isDerived() access
@
text
@d57 2
a58 2
String getClassifierAccessorName(genmodel::GenClass gc) :
	switch (gc.ecoreClass.name) {
d61 1
a61 1
		default : gc.ecoreClass.name
d65 11
d94 1
a94 1
String getQualifiedClassifierAccessor(genmodel::GenClass gc) :
@


1.14.2.1
log
@rewrite metric provider in xpand
@
text
@d57 2
a58 2
String getClassifierAccessorName(genmodel::GenClassifier gc) :
	switch (gc.getEcoreClassifier().name) {
d61 1
a61 1
		default : gc.getEcoreClassifier().name
a64 11
ecore::EClassifier getEcoreClassifier(genmodel::GenClassifier gc) :
	null
;

ecore::EClassifier getEcoreClassifier(genmodel::GenClass gc) :
	gc.ecoreClass
;

ecore::EClassifier getEcoreClassifier(genmodel::GenDataType gc) :
	gc.ecoreDataType
;
d83 1
a83 1
String getQualifiedClassifierAccessor(genmodel::GenClassifier gc) :
@


1.13
log
@move getFeatureTargetType method to GenModelUtils
@
text
@d123 5
@


1.12
log
@Moving non-open API classes from org.eclipse.gmf.codegen.util to org.eclipse.gmf.internal.codegen.util package.
@
text
@d236 11
a246 1
;@


1.11
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@d94 1
a94 1
JAVA org.eclipse.gmf.codegen.util.GenModelUtils.getDocumentRoot(org.eclipse.emf.codegen.ecore.genmodel.GenPackage)
d99 1
a99 1
JAVA org.eclipse.gmf.codegen.util.GenModelUtils.getGetAccessor(org.eclipse.emf.codegen.ecore.genmodel.GenFeature)
d104 1
a104 1
JAVA org.eclipse.gmf.codegen.util.GenModelUtils.findGenClassifier(org.eclipse.emf.codegen.ecore.genmodel.GenModel, org.eclipse.emf.ecore.EClassifier)
d120 1
a120 1
JAVA org.eclipse.gmf.codegen.util.GenModelUtils.isListType(org.eclipse.emf.codegen.ecore.genmodel.GenFeature)
d125 1
a125 1
JAVA org.eclipse.gmf.codegen.util.GenModelUtils.getTypeGenClass(org.eclipse.emf.codegen.ecore.genmodel.GenFeature)
@


1.10
log
@[177758] - Link from a node to a link is not possible
@
text
@d46 1
a46 1
		? gc.ecoreClass.instanceClassName
@


1.9
log
@[114348] add command to reorient ref based links
@
text
@d228 9
@


1.8
log
@incorrect implementation of isMapEntry() used to lead to incompilability of ecore "lite" sample
@
text
@d123 5
@


1.7
log
@genmodel::GenFeature.getReverse() extension added;
genmodel::GenClass.isMapEntry() extension made public;
needsCast(genmodel::GenClass source, genmodel::GenClass target) extension: logic fixed to reduce the number of casts.
@
text
@d170 1
a170 1
	("java.util.Map.Entry" == gc.ecoreClass.name || "java.util.Map$Entry" == gc.ecoreClass.name) 
@


1.6
log
@DiagramEditorUtil with xpand
@
text
@d107 11
d157 1
a157 1
	source == target ? true :
d160 1
a160 1
			source == null || target.isExternalInterface() || source.isExternalInterface() || target.ecoreClass.isSuperTypeOf(source.ecoreClass))
d169 1
a169 1
private boolean isMapEntry(genmodel::GenClass gc) :
@


1.5
log
@[172664]: Provide audits and metrics for Lite diagrams (including view-based and RCP) + validation decorators + validation markers (for non-RCP case);
Several templates are rewritten with xpand;
lite-specific TextEmitter is back (otherwise importManager is sometimes passed to xpand templates)
@
text
@d20 1
a20 1
	gp.genModel.suppressEMFMetaData ? getQualifiedPackageClassName(gp) : getQualifiedPackageName(gp, gp.metaDataPackageSuffix) + "." + getPackageInterfaceName(gp)
a22 1
//
a23 1
//
d25 1
a25 1
	getQualifiedPackageName(gp, gp.metaDataPackageSuffix) + "." + getFactoryInterfaceName(gp)
d87 8
a94 3
// GenPackageImpl#getQualifiedPackageClassName()
String getQualifiedPackageClassName(genmodel::GenPackage gp) :
	getReflectionClassPackageName(gp) + "." + getPackageClassName(gp)
d109 1
a109 11
	let eFeature = feature.ecoreFeature 
		: eFeature.many 
			|| isFeatureMapType(eFeature)
			|| 0 - 2 == eFeature.upperBound
;

private boolean isFeatureMapType(ecore::EStructuralFeature feature) :
	let type = feature.eType
		: null != type && 
			("org.eclipse.emf.ecore.util.FeatureMap.Entry" == type.instanceClassName 
			|| "org.eclipse.emf.ecore.util.FeatureMap$Entry" == type.instanceClassName)
d117 5
d152 23
a189 5
// GenPackageImpl#getFactoryInterfaceName()
private string getFactoryInterfaceName(genmodel::GenPackage gp) :
	getPrefixedName(gp, "Factory")
;

@


1.4
log
@Revriting BaseItemSemanticEditPolicy to xpand
@
text
@d24 20
d75 14
d124 30
d169 5
@


1.3
log
@NodeItemSemanticEditPolicy template reimplemented using xpand.
@
text
@d60 30
@


1.2
log
@genmodel extensions rewritten with Extend to avoid static java methods. This is another way to workaround 167615
@
text
@d24 13
@


1.1
log
@rewrite element types in xpand
@
text
@d16 3
d20 1
a20 1
	JAVA org.eclipse.gmf.codegen.util.GenModelFacade.getQualifiedPackageInterfaceName(org.eclipse.emf.codegen.ecore.genmodel.GenPackage)
d23 3
d27 5
a31 1
	JAVA org.eclipse.gmf.codegen.util.GenModelFacade.getClassifierAccessorName(org.eclipse.emf.codegen.ecore.genmodel.GenClass)
d34 4
d39 44
a82 1
	JAVA org.eclipse.gmf.codegen.util.GenModelFacade.getFeatureAccessorName(org.eclipse.emf.codegen.ecore.genmodel.GenFeature)
@

