head	1.3;
access;
symbols
	v20081022-1925:1.3
	v20081015-1925:1.3
	v20081008-1925:1.3
	v20081001-1925:1.3
	v20080924-1925:1.3
	v20080917-1925:1.3
	v20080911-1728:1.3
	v20080910-1520:1.3
	v20080903-1520:1.3
	v20080827-1520:1.3
	v20080813-1520:1.3
	v20080806-1520:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.3
date	2007.02.01.11.26.41;	author dstadnik;	state dead;
branches;
next	1.2;
commitid	69af45c1ce6e4567;

1.2
date	2007.01.29.19.27.42;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	1acd45be4aae4567;

1.1
date	2007.01.29.18.59.30;	author atikhomirov;	state Exp;
branches;
next	;
commitid	774445be44114567;


desc
@@


1.3
log
@[172460] Allow to generate open diagram editpolicy
@
text
@/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»

«DEFINE EditPolicy FOR OpenDiagramBehaviour»
«EXPAND xpt::Common::copyright FOR subject.getDiagram().editorGen-»
package «subject.getDiagram().editPoliciesPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «editPolicyClassName» extends «EXPAND extendsList» {

«EXPAND getOpenCommand-»

«EXPAND openCommandClass-»

«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE extendsList FOR OpenDiagramBehaviour»org.eclipse.gmf.runtime.diagram.ui.editpolicies.OpenEditPolicy«ENDDEFINE»

«DEFINE annotationSourceConstant FOR OpenDiagramBehaviour»"uri://eclipse.org/gmf/openDiagramPolicy"«ENDDEFINE»

«DEFINE getOpenCommand FOR OpenDiagramBehaviour»
	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.gef.commands.Command getOpenCommand(org.eclipse.gef.Request request) {
		org.eclipse.gef.EditPart targetEditPart = getTargetEditPart(request);
		if (false == targetEditPart.getModel() instanceof org.eclipse.gmf.runtime.notation.View) {
			return null;
		}
		org.eclipse.emf.ecore.EAnnotation ann = ((org.eclipse.gmf.runtime.notation.View) targetEditPart.getModel()).getEAnnotation(«EXPAND annotationSourceConstant»);
		if (ann == null) {
			return null;
		}
		return new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(new OpenDiagramCommand(ann));
	}
«ENDDEFINE»

«DEFINE openCommandClass FOR OpenDiagramBehaviour»
	«EXPAND xpt::Common::generatedMemberComment»
	private static class OpenDiagramCommand extends org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand {

		«EXPAND xpt::Common::generatedMemberComment»
		private final org.eclipse.emf.ecore.EAnnotation diagramFacet;

		«EXPAND xpt::Common::generatedMemberComment»
		OpenDiagramCommand(org.eclipse.emf.ecore.EAnnotation annotation) {
			// editing domain is taken for original diagram, 
			// if we open diagram from another file, we should use another editing domain
			super(org.eclipse.emf.transaction.util.TransactionUtil.getEditingDomain(annotation), "Open diagram", null);
			diagramFacet = annotation;
		}

		// FIXME canExecute if  !(readOnly && getDiagramToOpen == null), i.e. open works on ro diagrams only when there's associated diagram already

		«EXPAND xpt::Common::generatedMemberComment»
		protected org.eclipse.gmf.runtime.common.core.command.CommandResult doExecuteWithResult(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
			try {
				org.eclipse.gmf.runtime.notation.Diagram diagram = getDiagramToOpen();
				if (diagram == null) {
					diagram = intializeNewDiagram();
				}
				org.eclipse.emf.common.util.URI uri = diagram.eResource().getURI();
				uri = uri.appendFragment(diagram.eResource().getURIFragment(diagram));
				org.eclipse.ui.IEditorInput editorInput = new org.eclipse.emf.common.ui.URIEditorInput(uri);
				org.eclipse.ui.IWorkbenchPage page = org.eclipse.ui.PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
				page.openEditor(editorInput, getEditorID());
				return org.eclipse.gmf.runtime.common.core.command.CommandResult.newOKCommandResult();
			} catch (Exception ex) {
				throw new org.eclipse.core.commands.ExecutionException("Can't open diagram", ex);
			}
		}

		«EXPAND xpt::Common::generatedMemberComment»
		protected org.eclipse.gmf.runtime.notation.Diagram getDiagramToOpen() {
			// take first
			for (java.util.Iterator it = diagramFacet.getReferences().iterator(); it.hasNext();) {
				Object next = it.next();
				if (next instanceof org.eclipse.gmf.runtime.notation.Diagram) {
					return (org.eclipse.gmf.runtime.notation.Diagram) next;
				}
			}
			return null;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		protected org.eclipse.gmf.runtime.notation.Diagram intializeNewDiagram() throws org.eclipse.core.commands.ExecutionException {
			org.eclipse.gmf.runtime.notation.Diagram d = org.eclipse.gmf.runtime.diagram.core.services.ViewService.createDiagram(getDiagramDomainElement(), getDiagramKind(), getPreferencesHint());
			if (d == null) {
				throw new org.eclipse.core.commands.ExecutionException("Can't create diagram of '" + getDiagramKind() + "' kind");
			}
			diagramFacet.getReferences().add(d);
			assert diagramFacet.eResource() != null;
			diagramFacet.eResource().getContents().add(d);
			try {
				for (java.util.Iterator it = diagramFacet.eResource().getResourceSet().getResources().iterator(); it.hasNext();) {
					((org.eclipse.emf.ecore.resource.Resource) it.next()).save(java.util.Collections.EMPTY_MAP);
				}
			} catch (java.io.IOException ex) {
				throw new org.eclipse.core.commands.ExecutionException("Can't create diagram of '" + getDiagramKind() + "' kind", ex);
			}
			return d;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		protected org.eclipse.emf.ecore.EObject getDiagramDomainElement() {
			// use same element as associated with EP
			return ((org.eclipse.gmf.runtime.notation.View) diagramFacet.getEModelElement()).getElement();
		}

		«EXPAND xpt::Common::generatedMemberComment»
		protected org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint getPreferencesHint() {
			// XXX prefhint from target diagram's editor?
			return «subject.getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».DIAGRAM_PREFERENCES_HINT;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		protected String getDiagramKind() {
			return «IF diagramKind == null»«subject.getDiagram().getEditPartQualifiedClassName()».MODEL_ID«ELSE»"«diagramKind»"«ENDIF»;
		}

		«EXPAND xpt::Common::generatedMemberComment»
		protected String getEditorID() {
			return «IF editorID == null»«subject.getDiagram().editorGen.editor.getQualifiedClassName()».ID«ELSE»"«editorID»"«ENDIF»;
		}
	}
«ENDDEFINE»

«DEFINE additions FOR OpenDiagramBehaviour»«ENDDEFINE»@


1.2
log
@correct throws
@
text
@@


1.1
log
@OpenDiagramEditPolicy as xpt
@
text
@d66 1
a66 1
		protected org.eclipse.gmf.runtime.common.core.command.CommandResult doExecuteWithResult(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.gmf.runtime.common.core.command.ExecutionException {
d79 1
a79 1
				throw new org.eclipse.gmf.runtime.common.core.command.ExecutionException("Can't open diagram", ex);
@

