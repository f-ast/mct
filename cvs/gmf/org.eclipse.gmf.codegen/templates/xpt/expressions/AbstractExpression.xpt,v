head	1.7;
access;
symbols
	v20081022-1925:1.7
	v20081015-1925:1.7
	v20081008-1925:1.7
	v20081001-1925:1.6
	v20080930-1130:1.6
	v20080926-1245:1.6
	v20080924-1925:1.6
	v20080917-1925:1.6
	v20080911-1728:1.6
	v20080910-1520:1.6
	v20080903-1520:1.6
	v20080827-1520:1.6
	v20080813-1520:1.6
	v20080806-1520:1.6
	v20080722-1827:1.6
	v20080718-1731:1.6
	v20080716-1600:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.6.0.2
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080610-1132:1.6
	v20080603-1553:1.6
	v20080528-1052:1.6
	v20080521:1.6
	v20080516-1543:1.6
	v20080516-1143:1.6
	v20080512-1200:1.6
	v20080508-2000:1.6
	v20080507-1326:1.6
	v20080503-1740:1.2
	v20080501-1739:1.2
	v20080425-1959:1.2
	v20080417-1610:1.2
	v20080411-0411:1.1
	v20080404-1111:1.1
	v20080322-0000:1.1
	v20080222-1200:1.1
	v20080215-1500:1.1
	v20080207-0207:1.1.2.2
	v20071222-1111:1.1
	v20071214-1111:1.1
	v20071130-1111:1.1
	v20071124-0000:1.1.2.2
	v20071112-0000:1.1
	v20071108-0000:1.1
	v20071003-0000:1.1
	v20070928-0000:1.1.2.2
	v20070921-0000:1.1.2.2
	v20070915-0000:1.1.2.2
	R2_0_maintenance:1.1.0.2;
locks; strict;
comment	@# @;


1.7
date	2008.10.08.14.23.47;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	3df1348ecc2734567;

1.6
date	2008.05.07.13.56.01;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	39124821b4de4567;

1.5
date	2008.05.05.21.06.41;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	4186481f76b14567;

1.4
date	2008.05.05.16.51.34;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	6bf7481f3b164567;

1.3
date	2008.05.05.11.22.37;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	2e53481eedfd4567;

1.2
date	2008.04.14.08.31.34;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	bb3480316654567;

1.1
date	2007.09.14.14.53.25;	author dstadnik;	state Exp;
branches
	1.1.2.1;
next	;
commitid	40c546eaa0634567;

1.1.2.1
date	2007.09.14.14.53.25;	author dstadnik;	state dead;
branches;
next	1.1.2.2;
commitid	18546eaa48f4567;

1.1.2.2
date	2007.09.14.15.11.12;	author dstadnik;	state Exp;
branches;
next	;
commitid	18546eaa48f4567;


desc
@@


1.7
log
@fix spacing
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»

«DEFINE AbstractExpression FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «editorGen.expressionProviders.expressionsPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public abstract class «editorGen.expressionProviders.abstractExpressionClassName» «EXPAND supertypes»{

«EXPAND status-»

«EXPAND body-»

«EXPAND context-»

«EXPAND ctors-»

«EXPAND evaluate-»

«EXPAND performCast-»

«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE supertypes FOR gmfgen::GenDiagram»«ENDDEFINE»
«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE status FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private org.eclipse.core.runtime.IStatus status = org.eclipse.core.runtime.Status.OK_STATUS;	

	«EXPAND xpt::Common::generatedMemberComment»
	protected void setStatus(int severity, String message, Throwable throwable) {		
		String pluginID = «editorGen.plugin.getActivatorQualifiedClassName()».ID;
		this.status = new org.eclipse.core.runtime.Status(severity, pluginID, -1, (message != null) ? message : "", throwable);«EXPAND xpt::Common::nonNLS»
		if(!this.status.isOK()) {
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Expression problem:" + message + "body:"+ body(), throwable);«EXPAND xpt::Common::nonNLS»«EXPAND xpt::Common::nonNLS(2)»
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.core.runtime.IStatus getStatus() {
		return status;
	}
«ENDDEFINE»

«DEFINE body FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private final String myBody;

	«EXPAND xpt::Common::generatedMemberComment»
	public String body() {
		return myBody;
	}
«ENDDEFINE»

«DEFINE context FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private final org.eclipse.emf.ecore.EClassifier myContext;

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EClassifier context() {
		return myContext;
	}
«ENDDEFINE»

«DEFINE ctors FOR gmfgen::GenDiagram-»

	«EXPAND xpt::Common::generatedMemberComment»
	protected «editorGen.expressionProviders.abstractExpressionClassName»(String body, org.eclipse.emf.ecore.EClassifier context) {
		myBody = body;
		myContext = context;
	}
«ENDDEFINE»

«DEFINE evaluate FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	protected abstract Object doEvaluate(Object context, java.util.Map env);

	«EXPAND xpt::Common::generatedMemberComment»
	public Object evaluate(Object context) {
		return evaluate(context, java.util.Collections.EMPTY_MAP);
	}

«EXPAND xpt::Common::generatedMemberComment»
	public Object evaluate(Object context, java.util.Map env) {
		if(context().isInstance(context)) {
			try {
				return doEvaluate(context, env);
			} catch(Exception e) {
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Expression evaluation failure: " + body(), e);«EXPAND xpt::Common::nonNLS»
			}
		}
		return null;
	}
«ENDDEFINE»

«DEFINE performCast FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment("Expression may return number value which is not directly compatible with feature type (e.g. Double when Integer is expected), or EEnumLiteral meta-object when literal instance is expected")»
	public static Object performCast(Object value, org.eclipse.emf.ecore.EDataType targetType) {
		if (targetType instanceof org.eclipse.emf.ecore.EEnum) {
			if (value instanceof org.eclipse.emf.ecore.EEnumLiteral) {
				org.eclipse.emf.ecore.EEnumLiteral literal = (org.eclipse.emf.ecore.EEnumLiteral) value;
				return (literal.getInstance() != null) ? literal.getInstance() : literal;
			}
		}
		if (false == value instanceof Number || targetType == null || targetType.getInstanceClass() == null) {
			return value;
		}
		Class targetClass = targetType.getInstanceClass();
		Number num = (Number) value;
		Class valClass = value.getClass();
		Class targetWrapperClass = targetClass;
		if (targetClass.isPrimitive()) {
			targetWrapperClass = org.eclipse.emf.ecore.util.EcoreUtil.wrapperClassFor(targetClass);
		}
		if (valClass.equals(targetWrapperClass)) {
			return value;
		}
		if (Number.class.isAssignableFrom(targetWrapperClass)) {
			if (targetWrapperClass.equals(Byte.class)) return new Byte(num.byteValue());
			if (targetWrapperClass.equals(Integer.class)) return new Integer(num.intValue());
			if (targetWrapperClass.equals(Short.class)) return new Short(num.shortValue());
			if (targetWrapperClass.equals(Long.class)) return new Long(num.longValue());
			if (targetWrapperClass.equals(java.math.BigInteger.class)) return java.math.BigInteger.valueOf(num.longValue());
			if (targetWrapperClass.equals(Float.class)) return new Float(num.floatValue());
			if (targetWrapperClass.equals(Double.class)) return new Double(num.doubleValue());
			if (targetWrapperClass.equals(java.math.BigDecimal.class)) return new java.math.BigDecimal(num.doubleValue());
		}
		return value;
	}
«ENDDEFINE»
@


1.6
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d48 1
a48 1
		this.status = new org.eclipse.core.runtime.Status(severity, pluginID, -1, (message != null) ? message : "", throwable); «EXPAND xpt::Common::nonNLS»
d50 1
a50 1
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Expression problem:" + message + "body:"+ body(), throwable); «EXPAND xpt::Common::nonNLS» «EXPAND xpt::Common::nonNLS(2)»
@


1.5
log
@[228913] cleaned isCopy and java provider's getOperationName that are not in use any more; introduced fine-tuning options: use expressions body for java methods and whether to throw exception or fail silently (using reasonable/appropriate for the context default value), latter change obsoleted NoImplException and respective debug options
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.4
log
@[228913] useless code removed
@
text
@a21 1
«EXPAND debugOptions-»
a33 2
«EXPAND NoImplException-»

a40 5
«DEFINE debugOptions FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static final boolean DISABLED_NO_IMPL_EXCEPTION_LOG = Boolean.valueOf(org.eclipse.core.runtime.Platform.getDebugOption(«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getBundle().getSymbolicName() + "/debug/disableNoExprImplExceptionLog")).booleanValue();«EXPAND xpt::Common::nonNLS»
«ENDDEFINE»

d104 1
a104 4
				if(DISABLED_NO_IMPL_EXCEPTION_LOG && e instanceof NoImplException) {
					return null;
				}
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Expression evaluation failure: " + body(), e);	«EXPAND xpt::Common::nonNLS»
a145 10

«DEFINE NoImplException FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedClassComment»
	public static class NoImplException extends RuntimeException {
		«EXPAND xpt::Common::generatedMemberComment»
		public NoImplException(String message) {
			super(message);
		}
	}
«ENDDEFINE»
@


1.3
log
@[226725] Refactor AbstractExpression to be used in Lite RT
@
text
@a34 2
«EXPAND nullExpression-»

a88 4
	«EXPAND xpt::Common::generatedMemberComment»
	protected «editorGen.expressionProviders.abstractExpressionClassName»(org.eclipse.emf.ecore.EClassifier context) {
		this(null, context);«REM»XXX null body??? what for? just for nullExpression?«ENDREM»
	}
a157 15
/*
	XXX what's the purpose?
 */
«DEFINE nullExpression FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	public static final «editorGen.expressionProviders.abstractExpressionClassName» createNullExpression(org.eclipse.emf.ecore.EClassifier context) {
		return new «editorGen.expressionProviders.abstractExpressionClassName»(context) {
			protected Object doEvaluate(Object context, java.util.Map env) {
				// TODO - log entry about not provider available for this expression
				return null;
			}
		};
	}
«ENDDEFINE»

@


1.2
log
@[221347] refactor ElementInitializers, 2/2: avoid reflective code if generation of specific code is possible.
@
text
@d20 1
a20 1
public abstract class «editorGen.expressionProviders.abstractExpressionClassName» {
d22 30
d53 1
a53 4
	private static final boolean DISABLED_NO_IMPL_EXCEPTION_LOG =
			Boolean.valueOf(org.eclipse.core.runtime.Platform.getDebugOption(
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getBundle().getSymbolicName()
					+ "/debug/disableNoExprImplExceptionLog")).booleanValue();
d56 7
a62 1
	private final String body;
d65 4
a68 1
	private final org.eclipse.emf.ecore.EClassifier context;
d70 1
d72 1
a72 1
	private org.eclipse.core.runtime.IStatus status = org.eclipse.core.runtime.Status.OK_STATUS;
d75 2
a76 2
	protected «editorGen.expressionProviders.abstractExpressionClassName»(org.eclipse.emf.ecore.EClassifier context) {
		this(null, context);
d78 5
d85 9
a93 3
	protected «editorGen.expressionProviders.abstractExpressionClassName»(String body, org.eclipse.emf.ecore.EClassifier context) {
		this.body = body;
		this.context = context;
d97 3
a99 8
	protected void setStatus(int severity, String message, Throwable throwable) {
		String pluginID = «editorGen.plugin.getActivatorQualifiedClassName()».ID;
		this.status = new org.eclipse.core.runtime.Status(
				severity, pluginID, -1, (message != null) ? message : "", throwable); //$NON-NLS-1$
		if (!this.status.isOK()) {
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(
					"Expression problem: " + message + " body: " + body, throwable); //$NON-NLS-1$ //$NON-NLS-2$
		}
d101 1
d103 1
d112 1
a112 1
	«EXPAND xpt::Common::generatedMemberComment»
d114 1
a114 1
		if (context().isInstance(context)) {
d118 1
a118 1
				if (DISABLED_NO_IMPL_EXCEPTION_LOG && e instanceof NoImplException) {
d121 1
a121 2
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(
						"Expression evaluation failure: " + body, e);
d126 1
d128 1
a128 15
	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.core.runtime.IStatus getStatus() {
		return status;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public String body() {
		return body;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EClassifier context() {
		return context;
	}

d161 2
a162 1
	}	
d164 4
a170 1

d177 1
d179 2
a180 1
	«EXPAND xpt::Common::generatedMemberComment»
a181 1

a186 2
	«EXPAND additions-»
}
a187 2

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»
@


1.1
log
@rewrite abs expr in xpand
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d98 6
a103 14
	«EXPAND xpt::Common::generatedMemberComment»
	public void assignTo(org.eclipse.emf.ecore.EStructuralFeature feature, org.eclipse.emf.ecore.EObject target) {
		Object value = evaluate(target);
		value = (value != null) ? performCast(value, feature) : null;
		if (feature.isMany()) {
			java.util.Collection destCollection = (java.util.Collection) target.eGet(feature);
			destCollection.clear();
			if (value instanceof java.util.Collection) {
				java.util.Collection valueCollection = (java.util.Collection) value;
				for (java.util.Iterator it = valueCollection.iterator(); it.hasNext();) {
					destCollection.add(performCast(it.next(), feature));
				}
			} else {
				destCollection.add(value);
a104 1
			return;
d106 11
a116 6
		target.eSet(feature, value);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected Object performCast(Object value, org.eclipse.emf.ecore.ETypedElement targetType) {
		if (targetType.getEType() == null || targetType.getEType().getInstanceClass() == null) {
d119 9
a127 21
		Class targetClass = targetType.getEType().getInstanceClass();
		if (value != null && value instanceof Number) {
			Number num = (Number) value;
			Class valClass = value.getClass();
			Class targetWrapperClass = targetClass;
			if (targetClass.isPrimitive()) {
				targetWrapperClass = org.eclipse.emf.ecore.util.EcoreUtil.wrapperClassFor(targetClass);
			}
			if (valClass.equals(targetWrapperClass)) {
				return value;
			}
			if (Number.class.isAssignableFrom(targetWrapperClass)) {
				if (targetWrapperClass.equals(Byte.class)) return new Byte(num.byteValue());
				if (targetWrapperClass.equals(Integer.class)) return new Integer(num.intValue());
				if (targetWrapperClass.equals(Short.class)) return new Short(num.shortValue());
				if (targetWrapperClass.equals(Long.class)) return new Long(num.longValue());
				if (targetWrapperClass.equals(java.math.BigInteger.class)) return java.math.BigInteger.valueOf(num.longValue());
				if (targetWrapperClass.equals(Float.class)) return new Float(num.floatValue());
				if (targetWrapperClass.equals(Double.class)) return new Double(num.doubleValue());
				if (targetWrapperClass.equals(java.math.BigDecimal.class)) return new java.math.BigDecimal(num.doubleValue());
			}
@


1.1.2.1
log
@file AbstractExpression.xpt was added on branch R2_0_maintenance on 2007-09-14 15:11:12 +0000
@
text
@d1 171
@


1.1.2.2
log
@rewrite abs expr in xpand
@
text
@a0 171
/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»

«DEFINE AbstractExpression FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «editorGen.expressionProviders.expressionsPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public abstract class «editorGen.expressionProviders.abstractExpressionClassName» {

	«EXPAND xpt::Common::generatedMemberComment»
	private static final boolean DISABLED_NO_IMPL_EXCEPTION_LOG =
			Boolean.valueOf(org.eclipse.core.runtime.Platform.getDebugOption(
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getBundle().getSymbolicName()
					+ "/debug/disableNoExprImplExceptionLog")).booleanValue();

	«EXPAND xpt::Common::generatedMemberComment»
	private final String body;

	«EXPAND xpt::Common::generatedMemberComment»
	private final org.eclipse.emf.ecore.EClassifier context;

	«EXPAND xpt::Common::generatedMemberComment»
	private org.eclipse.core.runtime.IStatus status = org.eclipse.core.runtime.Status.OK_STATUS;

	«EXPAND xpt::Common::generatedMemberComment»
	protected «editorGen.expressionProviders.abstractExpressionClassName»(org.eclipse.emf.ecore.EClassifier context) {
		this(null, context);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected «editorGen.expressionProviders.abstractExpressionClassName»(String body, org.eclipse.emf.ecore.EClassifier context) {
		this.body = body;
		this.context = context;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected void setStatus(int severity, String message, Throwable throwable) {
		String pluginID = «editorGen.plugin.getActivatorQualifiedClassName()».ID;
		this.status = new org.eclipse.core.runtime.Status(
				severity, pluginID, -1, (message != null) ? message : "", throwable); //$NON-NLS-1$
		if (!this.status.isOK()) {
			«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(
					"Expression problem: " + message + " body: " + body, throwable); //$NON-NLS-1$ //$NON-NLS-2$
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected abstract Object doEvaluate(Object context, java.util.Map env);

	«EXPAND xpt::Common::generatedMemberComment»
	public Object evaluate(Object context) {
		return evaluate(context, java.util.Collections.EMPTY_MAP);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public Object evaluate(Object context, java.util.Map env) {
		if (context().isInstance(context)) {
			try {
				return doEvaluate(context, env);
			} catch(Exception e) {
				if (DISABLED_NO_IMPL_EXCEPTION_LOG && e instanceof NoImplException) {
					return null;
				}
				«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(
						"Expression evaluation failure: " + body, e);
			}
		}
		return null;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.core.runtime.IStatus getStatus() {
		return status;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public String body() {
		return body;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public org.eclipse.emf.ecore.EClassifier context() {
		return context;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public void assignTo(org.eclipse.emf.ecore.EStructuralFeature feature, org.eclipse.emf.ecore.EObject target) {
		Object value = evaluate(target);
		value = (value != null) ? performCast(value, feature) : null;
		if (feature.isMany()) {
			java.util.Collection destCollection = (java.util.Collection) target.eGet(feature);
			destCollection.clear();
			if (value instanceof java.util.Collection) {
				java.util.Collection valueCollection = (java.util.Collection) value;
				for (java.util.Iterator it = valueCollection.iterator(); it.hasNext();) {
					destCollection.add(performCast(it.next(), feature));
				}
			} else {
				destCollection.add(value);
			}
			return;
		}
		target.eSet(feature, value);
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected Object performCast(Object value, org.eclipse.emf.ecore.ETypedElement targetType) {
		if (targetType.getEType() == null || targetType.getEType().getInstanceClass() == null) {
			return value;
		}
		Class targetClass = targetType.getEType().getInstanceClass();
		if (value != null && value instanceof Number) {
			Number num = (Number) value;
			Class valClass = value.getClass();
			Class targetWrapperClass = targetClass;
			if (targetClass.isPrimitive()) {
				targetWrapperClass = org.eclipse.emf.ecore.util.EcoreUtil.wrapperClassFor(targetClass);
			}
			if (valClass.equals(targetWrapperClass)) {
				return value;
			}
			if (Number.class.isAssignableFrom(targetWrapperClass)) {
				if (targetWrapperClass.equals(Byte.class)) return new Byte(num.byteValue());
				if (targetWrapperClass.equals(Integer.class)) return new Integer(num.intValue());
				if (targetWrapperClass.equals(Short.class)) return new Short(num.shortValue());
				if (targetWrapperClass.equals(Long.class)) return new Long(num.longValue());
				if (targetWrapperClass.equals(java.math.BigInteger.class)) return java.math.BigInteger.valueOf(num.longValue());
				if (targetWrapperClass.equals(Float.class)) return new Float(num.floatValue());
				if (targetWrapperClass.equals(Double.class)) return new Double(num.doubleValue());
				if (targetWrapperClass.equals(java.math.BigDecimal.class)) return new java.math.BigDecimal(num.doubleValue());
			}
		}
		return value;
	}	

	«EXPAND xpt::Common::generatedMemberComment»
	public static final «editorGen.expressionProviders.abstractExpressionClassName» createNullExpression(org.eclipse.emf.ecore.EClassifier context) {
		return new «editorGen.expressionProviders.abstractExpressionClassName»(context) {

			protected Object doEvaluate(Object context, java.util.Map env) {
				// TODO - log entry about not provider available for this expression
				return null;
			}
		};
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public static class NoImplException extends RuntimeException {

		«EXPAND xpt::Common::generatedMemberComment»
		public NoImplException(String message) {
			super(message);
		}
	}
	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»
@


