head	1.37;
access;
symbols
	v20081022-1925:1.37
	v20081015-1925:1.37
	v20081008-1925:1.37
	v20081001-1925:1.37
	v20080930-1130:1.37
	v20080926-1245:1.37
	v20080924-1925:1.37
	v20080917-1925:1.37
	v20080911-1728:1.37
	v20080910-1520:1.37
	v20080903-1520:1.37
	v20080827-1520:1.37
	v20080813-1520:1.37
	v20080806-1520:1.37
	v20080722-1827:1.37
	v20080718-1731:1.37
	v20080716-1600:1.31.2.1
	v20080716-1642:1.36
	R2_1_maintenance:1.31.0.2
	Root_R2_1_maintenance:1.31
	R2_1_0:1.31
	v20080610-1132:1.31
	v20080603-1553:1.31
	v20080528-1052:1.31
	v20080521:1.31
	v20080516-1543:1.30
	v20080516-1143:1.30
	v20080512-1200:1.30
	v20080508-2000:1.30
	v20080507-1326:1.30
	v20080503-1740:1.27
	v20080501-1739:1.27
	v20080425-1959:1.26
	v20080417-1610:1.26
	v20080411-0411:1.26
	v20080404-1111:1.26
	v20080322-0000:1.26
	v20080222-1200:1.23
	v20080215-1500:1.23
	v20080207-0207:1.22.2.2
	v20071222-1111:1.23
	v20071214-1111:1.23
	v20071130-1111:1.23
	v20071124-0000:1.22.2.2
	v20071112-0000:1.23
	v20071108-0000:1.23
	v20071003-0000:1.22
	v20070928-0000:1.22
	v20070921-0000:1.22
	v20070915-0000:1.22
	v20070903-0000:1.22
	v20070809-0000:1.22
	R2_0_maintenance:1.22.0.2
	R2_0:1.22
	R4_20:1.22
	v20070621-0000:1.22
	RC3_20:1.22
	v20070614-1400:1.22
	v20070608-1300:1.22
	v20070605-1400:1.22
	v20070601-1400:1.22
	v20070525-1500:1.21
	v20070520-1200:1.21
	v20070518-1300:1.20
	v20070504-1000:1.14
	v20070427-0600:1.14
	v20070420-1000:1.13
	v20070413-1300:1.9
	v20070405-1100:1.6
	v20070403-1500:1.4
	v20070330-1300:1.4
	v20060330-1300:1.4
	v20070322-1100:1.2
	v20060316-0600:1.2
	v20070307-0700:1.2
	v20070301-1200:1.2
	v20070228-2000:1.2
	v20070221-1500:1.2
	v20070208-1800:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.37
date	2008.07.16.17.19.49;	author ashatalin;	state Exp;
branches;
next	1.36;
commitid	67a1487e2db54567;

1.36
date	2008.07.12.12.19.06;	author ashatalin;	state Exp;
branches;
next	1.35;
commitid	45544878a1394567;

1.35
date	2008.07.11.16.13.24;	author ashatalin;	state Exp;
branches;
next	1.34;
commitid	2854487786a34567;

1.34
date	2008.07.09.19.18.20;	author atikhomirov;	state Exp;
branches;
next	1.33;
commitid	2aa048750efc4567;

1.33
date	2008.07.03.12.30.06;	author atikhomirov;	state Exp;
branches;
next	1.32;
commitid	6ea4486cc64d4567;

1.32
date	2008.06.30.19.46.29;	author atikhomirov;	state Exp;
branches;
next	1.31;
commitid	763c486938144567;

1.31
date	2008.05.20.15.45.10;	author atikhomirov;	state Exp;
branches
	1.31.2.1;
next	1.30;
commitid	29294832f2054567;

1.30
date	2008.05.07.13.55.59;	author atikhomirov;	state Exp;
branches;
next	1.29;
commitid	39124821b4de4567;

1.29
date	2008.05.05.21.06.41;	author atikhomirov;	state Exp;
branches;
next	1.28;
commitid	4186481f76b14567;

1.28
date	2008.05.05.16.49.42;	author atikhomirov;	state Exp;
branches;
next	1.27;
commitid	6a72481f3aa54567;

1.27
date	2008.04.30.21.02.35;	author atikhomirov;	state Exp;
branches;
next	1.26;
commitid	8194818de6a4567;

1.26
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.25;
commitid	19d047c419ed4567;

1.25
date	2008.02.22.20.24.43;	author atikhomirov;	state Exp;
branches;
next	1.24;
commitid	377d47bf2f8a4567;

1.24
date	2008.02.20.13.33.32;	author ashatalin;	state Exp;
branches;
next	1.23;
commitid	37a747bc2c2b4567;

1.23
date	2007.10.26.12.59.57;	author ashatalin;	state Exp;
branches;
next	1.22;
commitid	12a84721e4cd4567;

1.22
date	2007.05.30.16.17.50;	author ashatalin;	state Exp;
branches
	1.22.2.1;
next	1.21;
commitid	2040465da3ae4567;

1.21
date	2007.05.18.21.17.17;	author atikhomirov;	state Exp;
branches;
next	1.20;
commitid	2591464e17d14567;

1.20
date	2007.05.16.19.17.03;	author ashatalin;	state Exp;
branches;
next	1.19;
commitid	6987464b58af4567;

1.19
date	2007.05.16.18.44.42;	author ashatalin;	state Exp;
branches;
next	1.18;
commitid	4320464b51194567;

1.18
date	2007.05.15.19.19.22;	author ashatalin;	state Exp;
branches;
next	1.17;
commitid	43d3464a07b84567;

1.17
date	2007.05.15.18.34.12;	author ashatalin;	state Exp;
branches;
next	1.16;
commitid	25434649fd1f4567;

1.16
date	2007.05.08.12.13.56;	author ashatalin;	state Exp;
branches;
next	1.15;
commitid	3792464069824567;

1.15
date	2007.05.07.17.17.06;	author ashatalin;	state Exp;
branches;
next	1.14;
commitid	42d0463f5f114567;

1.14
date	2007.04.23.14.04.58;	author dstadnik;	state Exp;
branches;
next	1.13;
commitid	4a11462cbd094567;

1.13
date	2007.04.18.19.20.52;	author ashatalin;	state Exp;
branches;
next	1.12;
commitid	bf246266f934567;

1.12
date	2007.04.18.17.34.28;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	2e44462656a24567;

1.11
date	2007.04.13.14.29.11;	author dstadnik;	state Exp;
branches;
next	1.10;
commitid	78d4461f93b74567;

1.10
date	2007.04.13.13.44.44;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	2acb461f894b4567;

1.9
date	2007.04.12.14.15.23;	author dstadnik;	state Exp;
branches;
next	1.8;
commitid	7d7a461e3efb4567;

1.8
date	2007.04.11.13.03.51;	author dstadnik;	state Exp;
branches;
next	1.7;
commitid	713c461cdcb54567;

1.7
date	2007.04.11.11.06.07;	author dstadnik;	state Exp;
branches;
next	1.6;
commitid	483e461cc11f4567;

1.6
date	2007.04.04.13.57.24;	author dstadnik;	state Exp;
branches;
next	1.5;
commitid	4c6f4613aec34567;

1.5
date	2007.04.04.11.18.20;	author bblajer;	state Exp;
branches;
next	1.4;
commitid	2664461389794567;

1.4
date	2007.03.23.14.58.29;	author dstadnik;	state Exp;
branches;
next	1.3;
commitid	55cd4603eb144567;

1.3
date	2007.03.23.09.27.29;	author dstadnik;	state Exp;
branches;
next	1.2;
commitid	6f4346039d7f4567;

1.2
date	2007.02.02.20.49.45;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	50c945c3a3e84567;

1.1
date	2007.02.01.11.51.44;	author dstadnik;	state Exp;
branches;
next	;
commitid	dd445c1d44e4567;

1.22.2.1
date	2007.10.26.12.58.31;	author ashatalin;	state Exp;
branches;
next	1.22.2.2;
commitid	11624721e4774567;

1.22.2.2
date	2007.10.26.13.00.45;	author ashatalin;	state Exp;
branches;
next	;
commitid	13b64721e4fd4567;

1.31.2.1
date	2008.07.09.19.30.24;	author atikhomirov;	state Exp;
branches;
next	;
commitid	340c487511cf4567;


desc
@@


1.37
log
@[234562] - Adding child elements into a shortcut causes stack overflow
- getContextElementType() method added to easily switch ElementType used to get addtional EditHelperAdvices.
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION xpt::diagram::editpolicies::Utils»
«EXTENSION xpt::diagram::Utils»
«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::expressions::ValueExpression»

«DEFINE BaseItemSemanticEditPolicy FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::copyright FOR editorGen-»
package «getDiagram().editPoliciesPackageName»;

«EXPAND xpt::Common::generatedClassComment»
public class «baseItemSemanticEditPolicyClassName» extends org.eclipse.gmf.runtime.diagram.ui.editpolicies.SemanticEditPolicy {

	«EXPAND attributes-»
	
	«EXPAND constructor-»

	«EXPAND xpt::Common::generatedMemberComment(
		"Extended request data key to hold editpart visual id.\n" +
		"Add visual id of edited editpart to extended data of the request\n" +
		"so command switch can decide what kind of diagram element is being edited.\n" +
		"It is done in those cases when it\'s not possible to deduce diagram\n" +
		"element kind from domain element.\n"
	)»
	public org.eclipse.gef.commands.Command getCommand(org.eclipse.gef.Request request) {
		if (request instanceof org.eclipse.gef.requests.ReconnectRequest) {
			Object view = ((org.eclipse.gef.requests.ReconnectRequest) request).getConnectionEditPart().getModel();
			if (view instanceof org.eclipse.gmf.runtime.notation.View) {
				Integer id = new Integer(«EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall»((org.eclipse.gmf.runtime.notation.View) view));
				request.getExtendedData().put(VISUAL_ID_KEY, id);
			}
		}
		return super.getCommand(request);
	}
	
	«EXPAND xpt::Common::generatedMemberComment("Returns visual id from request parameters.\n")»
	protected int getVisualID(org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest request) {
		Object id = request.getParameter(VISUAL_ID_KEY);
		return id instanceof Integer ? ((Integer) id).intValue() : -1;
	}

	«EXPAND semanticPart-»

	«EXPAND xpt::Common::generatedMemberComment("Returns editing domain from the host edit part.\n")»
	protected org.eclipse.emf.transaction.TransactionalEditingDomain getEditingDomain() {
		return ((org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart) getHost()).getEditingDomain();
	}

	«EXPAND xpt::Common::generatedMemberComment("Creates command to destroy the link.\n")»
	protected org.eclipse.gef.commands.Command getDestroyElementCommand(org.eclipse.gmf.runtime.notation.View view) {
		org.eclipse.gef.EditPart editPart = (org.eclipse.gef.EditPart) getHost().getViewer().getEditPartRegistry().get(view);
		org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest request =
				new org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest(getEditingDomain(), false);
		return editPart.getCommand(
				new org.eclipse.gmf.runtime.diagram.ui.requests.EditCommandRequestWrapper(request, java.util.Collections.EMPTY_MAP));
	}

	«EXPAND xpt::Common::generatedMemberComment("Creates commands to destroy all host incoming and outgoing links.\n")»
	protected org.eclipse.gef.commands.CompoundCommand getDestroyEdgesCommand() {
		org.eclipse.gef.commands.CompoundCommand cmd = new org.eclipse.gef.commands.CompoundCommand();
		org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) getHost().getModel();
		for (java.util.Iterator it = view.getSourceEdges().iterator(); it.hasNext();) {
			cmd.add(getDestroyElementCommand((org.eclipse.gmf.runtime.notation.Edge) it.next()));
		}
		for (java.util.Iterator it = view.getTargetEdges().iterator(); it.hasNext();) {
			cmd.add(getDestroyElementCommand((org.eclipse.gmf.runtime.notation.Edge) it.next()));
		}
		return cmd;
	}
	
	«EXPAND addDestroyShortcutsCommand-»

	«EXPAND linkConstraints-»

	«EXPAND additions-»
}
«ENDDEFINE»

«DEFINE attributes FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment("Extended request data key to hold editpart visual id.\n")»
	public static final String VISUAL_ID_KEY = "visual_id"; «EXPAND xpt::Common::nonNLS»

	«EXPAND xpt::Common::generatedMemberComment»
	private final org.eclipse.gmf.runtime.emf.type.core.IElementType myElementType;
«ENDDEFINE»

«DEFINE constructor FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	protected «baseItemSemanticEditPolicyClassName»(org.eclipse.gmf.runtime.emf.type.core.IElementType elementType) {
		myElementType = elementType;
	}
«ENDDEFINE»

«DEFINE addDestroyShortcutsCommand FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
protected void addDestroyShortcutsCommand(org.eclipse.gef.commands.CompoundCommand command) {
	org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) getHost().getModel();
	if (view.getEAnnotation("Shortcut") != null) { «EXPAND xpt::Common::nonNLS»
		return;
	}
	for (java.util.Iterator it = view.getDiagram().getChildren().iterator(); it.hasNext();) {
		org.eclipse.gmf.runtime.notation.View nextView = (org.eclipse.gmf.runtime.notation.View) it.next();
		if (nextView.getEAnnotation("Shortcut") == null || !nextView.isSetElement() || nextView.getElement() != view.getElement()) { «EXPAND xpt::Common::nonNLS»
			continue;
		}
		command.add(getDestroyElementCommand(nextView));
	}
}
«ENDDEFINE»

«DEFINE semanticPart FOR gmfgen::GenDiagram-»
	«EXPAND getSemanticCommand-»
	
	«EXPAND getEditHelperCommand-»
	
	«EXPAND getContextElementType-»
	
	«EXPAND getSemanticCommandSwitch-»
	
	«EXPAND getConfigureCommand-»

	«EXPAND getCreateRelationshipCommand-»

	«EXPAND getCreateCommand-»

	«EXPAND getSetCommand-»

	«EXPAND getEditContextCommand-»

	«EXPAND getDestroyElementCommand-»

	«EXPAND getDestroyReferenceCommand-»

	«EXPAND getDuplicateCommand-»

	«EXPAND getMoveCommand-»

	«EXPAND getReorientReferenceRelationshipCommand-»

	«EXPAND getReorientRelationshipCommand-»
	
	«EXPAND getGEFWrapper-»
	«EXPAND getMSLWrapper-»

	«EXPAND getSemanticElement-»
«ENDDEFINE»

«DEFINE getEditHelperCommand FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private org.eclipse.gef.commands.Command getEditHelperCommand(org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest request, org.eclipse.gef.commands.Command editPolicyCommand) {
		if (editPolicyCommand != null) {
			org.eclipse.gmf.runtime.common.core.command.ICommand command = editPolicyCommand instanceof org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy ? ((org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy) editPolicyCommand).getICommand() : new org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy(editPolicyCommand);
			request.setParameter(«EXPAND xpt::diagram::edithelpers::BaseEditHelper::editPolicyCommandConstant», command);
		}
		org.eclipse.gmf.runtime.emf.type.core.IElementType requestContextElementType = getContextElementType(request);
		request.setParameter(«EXPAND xpt::diagram::edithelpers::BaseEditHelper::contextElementTypeConstant», requestContextElementType);
		org.eclipse.gmf.runtime.common.core.command.ICommand command = requestContextElementType.getEditCommand(request);
		request.setParameter(«EXPAND xpt::diagram::edithelpers::BaseEditHelper::editPolicyCommandConstant», null);
		request.setParameter(«EXPAND xpt::diagram::edithelpers::BaseEditHelper::contextElementTypeConstant», null);
		if (command != null) {
			if (!(command instanceof org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand)) {
				org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain = ((org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart) getHost()).getEditingDomain();
				command = new org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand(editingDomain, command.getLabel()).compose(command);
			}
			return new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(command);
		}
		return editPolicyCommand;
	}
«ENDDEFINE»

«DEFINE getContextElementType FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	private org.eclipse.gmf.runtime.emf.type.core.IElementType getContextElementType(org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest request) {
		org.eclipse.gmf.runtime.emf.type.core.IElementType requestContextElementType = «getElementTypesQualifiedClassName()».getElementType(getVisualID(request));
		return requestContextElementType != null ? requestContextElementType : myElementType;
	}
«ENDDEFINE»

«DEFINE getSemanticCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getSemanticCommand(org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest request) {
	org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest completedRequest = completeRequest(request);
	org.eclipse.gef.commands.Command semanticCommand = getSemanticCommandSwitch(completedRequest);
	semanticCommand = getEditHelperCommand(completedRequest, semanticCommand);
	boolean shouldProceed = true;
	if (completedRequest instanceof org.eclipse.gmf.runtime.emf.type.core.requests.DestroyRequest) {
		shouldProceed = shouldProceed((org.eclipse.gmf.runtime.emf.type.core.requests.DestroyRequest) completedRequest);
	}
	if (shouldProceed) {
		if (completedRequest instanceof org.eclipse.gmf.runtime.emf.type.core.requests.DestroyRequest) {
			org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain = ((org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart) getHost()).getEditingDomain();
			org.eclipse.gef.commands.Command deleteViewCommand = new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(new org.eclipse.gmf.runtime.diagram.core.commands.DeleteCommand(editingDomain, (org.eclipse.gmf.runtime.notation.View) getHost().getModel()));
			semanticCommand = semanticCommand == null ? deleteViewCommand : semanticCommand.chain(deleteViewCommand);
		}
		return semanticCommand;
	}
	return null;
}
«ENDDEFINE»

«DEFINE getSemanticCommandSwitch FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getSemanticCommandSwitch(org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest req) {
	if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.CreateRelationshipRequest) {
		return getCreateRelationshipCommand((org.eclipse.gmf.runtime.emf.type.core.requests.CreateRelationshipRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest) {
		return getCreateCommand((org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.ConfigureRequest) {
		return getConfigureCommand((org.eclipse.gmf.runtime.emf.type.core.requests.ConfigureRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest) {
		return getDestroyElementCommand((org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.DestroyReferenceRequest) {
		return getDestroyReferenceCommand((org.eclipse.gmf.runtime.emf.type.core.requests.DestroyReferenceRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest) {
		return getDuplicateCommand((org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.GetEditContextRequest) {
		return getEditContextCommand((org.eclipse.gmf.runtime.emf.type.core.requests.GetEditContextRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.MoveRequest) {
		return getMoveCommand((org.eclipse.gmf.runtime.emf.type.core.requests.MoveRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.ReorientReferenceRelationshipRequest) {
		return getReorientReferenceRelationshipCommand((org.eclipse.gmf.runtime.emf.type.core.requests.ReorientReferenceRelationshipRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.ReorientRelationshipRequest) {
		return getReorientRelationshipCommand((org.eclipse.gmf.runtime.emf.type.core.requests.ReorientRelationshipRequest) req);
	} else if (req instanceof org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest) {
		return getSetCommand((org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest) req);
	}
	return null;
}
«ENDDEFINE»

«DEFINE getConfigureCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getConfigureCommand(org.eclipse.gmf.runtime.emf.type.core.requests.ConfigureRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getCreateRelationshipCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getCreateRelationshipCommand(org.eclipse.gmf.runtime.emf.type.core.requests.CreateRelationshipRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getCreateCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getCreateCommand(org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getSetCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getSetCommand(org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getEditContextCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getEditContextCommand(org.eclipse.gmf.runtime.emf.type.core.requests.GetEditContextRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getDestroyElementCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getDestroyElementCommand(org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getDestroyReferenceCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getDestroyReferenceCommand(org.eclipse.gmf.runtime.emf.type.core.requests.DestroyReferenceRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getDuplicateCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getDuplicateCommand(org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getMoveCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getMoveCommand(org.eclipse.gmf.runtime.emf.type.core.requests.MoveRequest req) {
	return null;
}
«ENDDEFINE»

«DEFINE getReorientReferenceRelationshipCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getReorientReferenceRelationshipCommand(org.eclipse.gmf.runtime.emf.type.core.requests.ReorientReferenceRelationshipRequest req) {
	return org.eclipse.gef.commands.UnexecutableCommand.INSTANCE;
}
«ENDDEFINE»

«DEFINE getReorientRelationshipCommand FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gef.commands.Command getReorientRelationshipCommand(org.eclipse.gmf.runtime.emf.type.core.requests.ReorientRelationshipRequest req) {
	return org.eclipse.gef.commands.UnexecutableCommand.INSTANCE;
}
«ENDDEFINE»

«DEFINE getGEFWrapper FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment»
	protected final org.eclipse.gef.commands.Command getGEFWrapper(org.eclipse.gmf.runtime.common.core.command.ICommand cmd) {
		return new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(cmd);
	}
«ENDDEFINE»

«DEFINE getMSLWrapper FOR gmfgen::GenDiagram-»
	«EXPAND xpt::Common::generatedMemberComment("@@deprecated use getGEFWrapper() instead")»
	protected final org.eclipse.gef.commands.Command getMSLWrapper(org.eclipse.gmf.runtime.common.core.command.ICommand cmd) {
		// XXX deprecated: use getGEFWrapper() instead
		return getGEFWrapper(cmd);
	}
«ENDDEFINE»

«DEFINE getSemanticElement FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.emf.ecore.EObject getSemanticElement() {
	return org.eclipse.gmf.runtime.diagram.core.util.ViewUtil.resolveSemanticElement((org.eclipse.gmf.runtime.notation.View) getHost().getModel());
}
«ENDDEFINE»


«REM»
		FIXME need to check constraint's provider to ensure we don't generate a field
		for e.g. Java (or Literal, which is unlikely, though) expressions
«ENDREM»
«DEFINE linkConstraints FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedClassComment»
public static class «getLinkCreationConstraintsClassName()» {

«IF null != editorGen.expressionProviders-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static final String OPPOSITE_END_VAR = "oppositeEnd"; «EXPAND xpt::Common::nonNLS»

«FOREACH getValidLinkConstraints(this) AS lc-»
«IF lc.sourceEnd != null-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» «sourceConstraintFieldName(lc.link)»;
«ENDIF-»
«IF lc.targetEnd != null-»
	«EXPAND xpt::Common::generatedMemberComment»
	private static «editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» «targetConstraintFieldName(lc.link)»;
«ENDIF-»
«ENDFOREACH»
«ENDIF-»

	«EXPAND canCreate FOREACH links-»
	«EXPAND canExist FOREACH links-»
}
«ENDDEFINE»

«DEFINE canCreate FOR gmfgen::GenLink»

«EXPAND xpt::Common::generatedMemberComment»
public static boolean canCreate«getUniqueIdentifier()»(«EXPAND canCreateParameters FOR modelFacet») {
	«EXPAND checkEMFConstraints FOR modelFacet-»
	return canExist«getUniqueIdentifier()»(«EXPAND canCreateValues FOR modelFacet»);
}
«ENDDEFINE»

«REM»
		XXX for now, both constraints are injected into single method
			which may nob be suitable for modification especially when mixing
			java and ocl constraints (former requires manual code).
		Better approach would be:
			if either is non-null and providers are not the same - introduce two methods, 
			to check source and target separately. Otherwize, do it inplace.
«ENDREM»
«DEFINE canExist FOR gmfgen::GenLink»

	«EXPAND xpt::Common::generatedMemberComment»
	public static boolean canExist«getUniqueIdentifier()»(«EXPAND canCreateParameters FOR modelFacet») {
«IF creationConstraints != null && creationConstraints.isValid() && null != getDiagram().editorGen.expressionProviders-»
		try {
«IF null != creationConstraints.sourceEnd-»
			«EXPAND checkAdditionalConstraint(creationConstraints.sourceEnd, sourceConstraintFieldName(this), "source", "target", creationConstraints.getSourceEndContextClass(), creationConstraints.getTargetEndContextClass()) FOR creationConstraints.sourceEnd.provider-»
«ENDIF-»
«IF null != creationConstraints.targetEnd-»
			«EXPAND checkAdditionalConstraint(creationConstraints.targetEnd, targetConstraintFieldName(this), "target", "source", creationConstraints.getTargetEndContextClass(), creationConstraints.getSourceEndContextClass()) FOR creationConstraints.targetEnd.provider-»
«ENDIF-»
			return true;
		} catch(Exception e) {	
			«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Link constraint evaluation error", e); «EXPAND xpt::Common::nonNLS»
			return false;
		}
«ELSE-»
		return true;
«ENDIF-»
	}
«ENDDEFINE»

«DEFINE canCreateParameters FOR gmfgen::LinkModelFacet»«EXPAND incorrectLinkModelFacet»«ENDDEFINE»
«DEFINE canCreateParameters FOR gmfgen::TypeLinkModelFacet»«IF hasContainerOtherThanSource()»«EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» container, «ENDIF»«EXPAND sourceTargetParameters»«ENDDEFINE»
«DEFINE canCreateParameters FOR gmfgen::FeatureLinkModelFacet»«EXPAND sourceTargetParameters»«ENDDEFINE»

«DEFINE sourceTargetParameters FOR gmfgen::LinkModelFacet»«EXPAND MetaModel::QualifiedClassName FOR getSourceType()» source, «EXPAND MetaModel::QualifiedClassName FOR getTargetType()» target«ENDDEFINE»

«DEFINE canCreateValues FOR gmfgen::LinkModelFacet»«EXPAND incorrectLinkModelFacet»«ENDDEFINE»
«DEFINE canCreateValues FOR gmfgen::TypeLinkModelFacet»«IF hasContainerOtherThanSource()»container, «ENDIF»source, target«ENDDEFINE»
«DEFINE canCreateValues FOR gmfgen::FeatureLinkModelFacet»source, target«ENDDEFINE»



«DEFINE checkEMFConstraints FOR gmfgen::LinkModelFacet»«EXPAND incorrectLinkModelFacet»«ENDDEFINE»

«DEFINE checkEMFConstraints FOR gmfgen::TypeLinkModelFacet-»
	«LET childMetaFeature != containmentMetaFeature && childMetaFeature.ecoreFeature.upperBound > 0 AS checkChildFeatureUpperBound-»
		«IF containmentMetaFeature.ecoreFeature.upperBound > 0 || checkChildFeatureUpperBound-»
if («getContainerVariable()» != null) {
			«EXPAND checkEMFConstraints(this) FOR containmentMetaFeature-»
			«IF checkChildFeatureUpperBound-»
				«EXPAND checkEMFConstraints(this) FOR childMetaFeature-»
			«ENDIF-»
}
		«ENDIF-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE checkEMFConstraints(gmfgen::TypeLinkModelFacet modelFacet) FOR genmodel::GenFeature-»
«IF ecoreFeature.upperBound > 0-»
if («EXPAND featureBoundComparator(getContainerVariable(modelFacet), modelFacet.getSourceType())») {
	return false;
}
«ENDIF-»
«ENDDEFINE»

«DEFINE checkEMFConstraints FOR gmfgen::FeatureLinkModelFacet-»
if (source != null) {
	if («EXPAND featureBoundsConditionClause("source", getSourceType()) FOR metaFeature») {
		return false;
	}
	«IF metaFeature.isContains()-»
	if (source == target) {
		return false;
	}
	«ENDIF-»	
}
«IF getReverse(metaFeature) != null-»
if (target != null && («EXPAND featureBoundsConditionClause("target", getTargetType()) FOR getReverse(metaFeature)»)) {
	return false;
}
«ENDIF»
«ENDDEFINE»

«DEFINE featureBoundsConditionClause(String targetVar, GenClass targetType) FOR GenFeature-»
«REM»Checking upper bounds if was specified in MM«ENDREM»«-»
«IF ecoreFeature.upperBound > 0»«EXPAND featureBoundComparator(targetVar, targetType)»«ENDIF-»
«REM»Checking uniqueness in addition if upper bounds > 1«ENDREM»«-»
«IF ecoreFeature.upperBound > 1» || «ENDIF-»
«REM»Checking uniqueness in if upper bounds > 1 or < 0«ENDREM»«-»
«IF ecoreFeature.upperBound != 1»«EXPAND featureUniquenessComparator(targetVar, targetType)»«ENDIF»
«ENDDEFINE»

«DEFINE featureBoundComparator(String featureVar, genmodel::GenClass featureVarGenClass) FOR genmodel::GenFeature»«EXPAND MetaModel::getFeatureValue(featureVar, featureVarGenClass)»«IF ecoreFeature.upperBound == 1» != null«ELSE».size() >= «ecoreFeature.upperBound»«ENDIF»«ENDDEFINE»
«DEFINE featureUniquenessComparator(String featureVar, genmodel::GenClass featureVarGenClass) FOR genmodel::GenFeature»«EXPAND MetaModel::getFeatureValue(featureVar, featureVarGenClass) FOR this».contains(target)«ENDDEFINE»


«DEFINE checkAdditionalConstraint(gmfgen::ValueExpression valueExpr, String constraintFieldName, String sourceEndVar, String targetEndVar, GenClass context, GenClass oppositeEndContext) FOR gmfgen::GenExpressionProviderBase»
«ERROR "Have no idea what extra constraints to check for " + this»
«ENDDEFINE»

«DEFINE checkAdditionalConstraint(gmfgen::ValueExpression valueExpr, String constraintFieldName, String sourceEndVar, String targetEndVar, GenClass context, GenClass oppositeEndContext) FOR gmfgen::GenExpressionInterpreter-»
	if («sourceEndVar» == null) {
		return true;
	}
	if («constraintFieldName» == null) {
		java.util.Map env = java.util.Collections.singletonMap(OPPOSITE_END_VAR, «EXPAND MetaModel::MetaClass FOR oppositeEndContext»);
		«constraintFieldName» = «getQualifiedClassName()».«getExpressionAccessor(valueExpr)»(«valueExpr.getBodyString()», «EXPAND MetaModel::MetaClass FOR context», env); «EXPAND xpt::Common::nonNLS»
	}
	Object «sourceEndVar»Val = «constraintFieldName».evaluate(«sourceEndVar», java.util.Collections.singletonMap(OPPOSITE_END_VAR, «targetEndVar»));
	if (false == «sourceEndVar»Val instanceof Boolean || !((Boolean) «sourceEndVar»Val).booleanValue()) {
		return false;
	} // else fall-through
«ENDDEFINE»

«DEFINE checkAdditionalConstraint(gmfgen::ValueExpression valueExpr, String constraintFieldName, String sourceEndVar, String targetEndVar, GenClass context, GenClass oppositeEndContext) FOR gmfgen::GenJavaExpressionProvider-»
«IF injectExpressionBody && valueExpr.body != null && valueExpr.body.length() != 0-»
	«valueExpr.body»
«ELSEIF throwException || (injectExpressionBody && (valueExpr.body == null || valueExpr.body.length() == 0))-»
	// TODO: implement this method, using «sourceEndVar» and «targetEndVar» 
	// to access link source and target, respectively
	// Ensure that you remove @@generated or mark it @@generated NOT
	if (Boolean.TRUE.booleanValue()) {
		throw new java.lang.UnsupportedOperationException("No java implementation provided");«EXPAND xpt::Common::nonNLS»
	}
«ELSE-»
	if (Boolean.TRUE.booleanValue()) {«REM»just in case there are two consecutive java expression with neither throw nor inject - avoid unreachable code.«ENDREM»
		return false;
	}
«ENDIF-»
«ENDDEFINE»


«DEFINE incorrectLinkModelFacet FOR gmfgen::LinkModelFacet»«ERROR "Unrecognized link model facet: " + this»«ENDDEFINE»

«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE defaultConstructor FOR gmfgen::GenCommonBase-»
	«EXPAND xpt::Common::generatedMemberComment»
	public «itemSemanticEditPolicyClassName»() {
		«EXPAND defaultConstructorBody-»
	}
«ENDDEFINE»

«REM»
	This method should be called only with diagram, node or link used as a parameter 
	(then elementType != null)
«ENDREM»
«DEFINE defaultConstructorBody FOR gmfgen::GenCommonBase-»
	«IF elementType == null-»
		«ERROR "No element type in the passed node. Only diagram, node or link are supported in this template: " + this-»
	«ENDIF-»
	super(«getDiagram().getElementTypesQualifiedClassName()».«getUniqueIdentifier()»);
«ENDDEFINE»@


1.36
log
@[234562] - Adding child elements into a shortcut causes stack overflow
@
text
@d131 2
d170 1
a170 4
		org.eclipse.gmf.runtime.emf.type.core.IElementType requestContextElementType = «getElementTypesQualifiedClassName()».getElementType(getVisualID(request));
		if (requestContextElementType == null) {
			requestContextElementType = myElementType;
		}
d186 8
@


1.35
log
@[234562] - Adding child elements into a shortcut causes stack overflow
@
text
@d129 2
d161 26
d192 1
a192 13
	if (semanticCommand != null) {
		org.eclipse.gmf.runtime.common.core.command.ICommand command = semanticCommand instanceof org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy ? ((org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy) semanticCommand).getICommand() : new org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy(semanticCommand);
		completedRequest.setParameter(«getBaseEditHelperQualifiedClassName()».EDIT_POLICY_COMMAND, command);
	}
	org.eclipse.gmf.runtime.common.core.command.ICommand command = myElementType.getEditCommand(completedRequest);
	completedRequest.setParameter(«getBaseEditHelperQualifiedClassName()».EDIT_POLICY_COMMAND, null);
	if (command != null) {
		if (!(command instanceof org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand)) {
			org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain = ((org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart) getHost()).getEditingDomain();
			command = new org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand(editingDomain, command.getLabel()).compose(command);
		}
		semanticCommand = new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(command);
	}
@


1.34
log
@[240218] unique client context and parameters in the request only if there are chances for EditHelper to clean them eventually.
@
text
@d29 3
a31 2
	«EXPAND xpt::Common::generatedMemberComment("Extended request data key to hold editpart visual id.\n")»
	public static final String VISUAL_ID_KEY = "visual_id"; «EXPAND xpt::Common::nonNLS»
d94 15
a162 13
	Object editHelperContext = completedRequest.getEditHelperContext();
	if (editHelperContext instanceof org.eclipse.gmf.runtime.notation.View || (editHelperContext instanceof org.eclipse.gmf.runtime.emf.type.core.IEditHelperContext && ((org.eclipse.gmf.runtime.emf.type.core.IEditHelperContext) editHelperContext).getEObject() instanceof org.eclipse.gmf.runtime.notation.View)) {
		// no semantic commands are provided for pure design elements
		return null;
	}
	if (editHelperContext == null) {
		editHelperContext = org.eclipse.gmf.runtime.diagram.core.util.ViewUtil.resolveSemanticElement((org.eclipse.gmf.runtime.notation.View) getHost().getModel());
	}
	org.eclipse.gmf.runtime.emf.type.core.IElementType elementType = org.eclipse.gmf.runtime.emf.type.core.ElementTypeRegistry.getInstance().getElementType(editHelperContext);
	if (elementType == org.eclipse.gmf.runtime.emf.type.core.ElementTypeRegistry.getInstance().getType("org.eclipse.gmf.runtime.emf.type.core.default")) { «EXPAND xpt::Common::nonNLS» 
	«REM»< % = importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()) % >.getInstance().logInfo("Failed to get element type for " + editHelperContext); / / $NON-NLS-1$«ENDREM»«-»
		elementType = null;
	}
d164 10
a173 12
	if (elementType != null) {
		if (semanticCommand != null) {
			org.eclipse.gmf.runtime.common.core.command.ICommand command = semanticCommand instanceof org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy ? ((org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy) semanticCommand).getICommand() : new org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy(semanticCommand);
			completedRequest.setParameter(«getBaseEditHelperQualifiedClassName()».EDIT_POLICY_COMMAND, command);
		}
		org.eclipse.gmf.runtime.common.core.command.ICommand command = elementType.getEditCommand(completedRequest);
		if (command != null) {
			if (!(command instanceof org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand)) {
				org.eclipse.emf.transaction.TransactionalEditingDomain editingDomain = ((org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart) getHost()).getEditingDomain();
				command = new org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand(editingDomain, command.getLabel()).compose(command);
			}
			semanticCommand = new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(command);
d175 1
d496 19
a514 1
«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»@


1.33
log
@[183812] respect constraints for EReference#eOpposite during link creation
@
text
@a160 4
	if (semanticCommand != null) {
		org.eclipse.gmf.runtime.common.core.command.ICommand command = semanticCommand instanceof org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy ? ((org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy) semanticCommand).getICommand() : new org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy(semanticCommand);
		completedRequest.setParameter(«getBaseEditHelperQualifiedClassName()».EDIT_POLICY_COMMAND, command);
	}
d162 4
@


1.32
log
@[226882] Support links with childMetaFeature not from container
@
text
@d321 4
a324 1

d426 2
a427 9
	«LET "source" AS sourceVar-»
if («sourceVar» != null) {
	if (
		«REM»Checking uper bounds if was specified in MM«ENDREM»«-»
		«IF metaFeature.ecoreFeature.upperBound > 0»«EXPAND featureBoundComparator(sourceVar, getSourceType()) FOR metaFeature»«ENDIF-»
		«REM»Checking uniqueness in addition if uper bounds > 1«ENDREM»«-»
		«IF metaFeature.ecoreFeature.upperBound > 1» || «ENDIF-»
		«REM»Checking uniqueness in if uper bounds > 1 or < 0«ENDREM»«-»
		«IF metaFeature.ecoreFeature.upperBound != 1»«EXPAND featureUniquenessComparator(sourceVar, getSourceType()) FOR metaFeature»«ENDIF») {
d430 1
a430 1
		«IF metaFeature.isContains()-»
d434 5
a438 1
		«ENDIF-»	
d440 10
a449 1
	«ENDLET-»
@


1.31
log
@[228913], JavaProvider attributes: even if no body is set but throwsException is false, do not generate exception, rather respect throwException==false
@
text
@d18 1
d381 1
a381 1
«ELSE»
d388 1
a388 1
«DEFINE canCreateParameters FOR gmfgen::TypeLinkModelFacet»«IF null != sourceMetaFeature»«EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» container, «ENDIF»«EXPAND sourceTargetParameters»«ENDDEFINE»
d394 1
a394 1
«DEFINE canCreateValues FOR gmfgen::TypeLinkModelFacet»«IF null != sourceMetaFeature»container, «ENDIF»source, target«ENDDEFINE»
@


1.31.2.1
log
@[240218] merge from HEAD: unique client context and parameters in the request only if there are chances for EditHelper to clean them eventually.
@
text
@d160 4
a164 4
		if (semanticCommand != null) {
			org.eclipse.gmf.runtime.common.core.command.ICommand command = semanticCommand instanceof org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy ? ((org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy) semanticCommand).getICommand() : new org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy(semanticCommand);
			completedRequest.setParameter(«getBaseEditHelperQualifiedClassName()».EDIT_POLICY_COMMAND, command);
		}
@


1.30
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d467 1
a467 1
«ELSEIF throwException || valueExpr.body == null || valueExpr.body.length() == 0-»
@


1.29
log
@[228913] cleaned isCopy and java provider's getOperationName that are not in use any more; introduced fine-tuning options: use expressions body for java methods and whether to throw exception or fail silently (using reasonable/appropriate for the context default value), latter change obsoleted NoImplException and respective debug options
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
d370 1
a370 1
			«EXPAND checkAdditionalConstraint(creationConstraints.sourceEnd, sourceConstraintFieldName(this), "source", "target", creationConstraints.getSourceEndContextClass(), creationConstraints.getTargetEndContextClass()) FOR getDiagram().editorGen.expressionProviders.getProvider(creationConstraints.sourceEnd)-»
d373 1
a373 1
			«EXPAND checkAdditionalConstraint(creationConstraints.targetEnd, targetConstraintFieldName(this), "target", "source", creationConstraints.getTargetEndContextClass(), creationConstraints.getSourceEndContextClass()) FOR getDiagram().editorGen.expressionProviders.getProvider(creationConstraints.targetEnd)-»
@


1.28
log
@[228913] item 4 - method name is no longer equals to getJavaOperationName
@
text
@d465 3
d471 8
a478 1
	throw new «container.getAbstractExpressionQualifiedClassName()».NoImplException("No java implementation provided");«EXPAND xpt::Common::nonNLS»
@


1.27
log
@[228913] item #5: clean getExpression, refactor its use
@
text
@d468 1
a468 1
	throw new «container.getAbstractExpressionQualifiedClassName()».NoImplException("No java implementation provided in '«getOperationName(valueExpr)»' operation"); «EXPAND xpt::Common::nonNLS»
@


1.26
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d16 1
d19 1
d22 1
a22 1
	«EXPAND xpt::Common::copyright FOR editorGen-»
d319 2
d324 2
a325 1
	«IF null != editorGen.expressionProviders-»
d328 13
a340 2
		«EXPAND xpt::expressions::getExpression::defineInterptererExpressionConstants FOREACH getValidLinkConstraints(this)-»
	«ENDIF-»
a342 9
	«IF null != editorGen.expressionProviders-»
		«IF hasInterpreterConstraints(this)-»
			«EXPAND evaluateInterpreterExpression FOR editorGen.expressionProviders-»
		«ENDIF-»
		«IF hasJavaConstraints(this)-»
			«EXPAND JavaConstraints-»
		«ENDIF-»	
	«ENDIF-»
	
d355 8
d365 19
a383 12
«EXPAND xpt::Common::generatedMemberComment»
public static boolean canExist«getUniqueIdentifier()»(«EXPAND canCreateParameters FOR modelFacet») {
	«IF creationConstraints != null && creationConstraints.isValid() && null != getDiagram().editorGen.expressionProviders-»
		«IF null != creationConstraints.sourceEnd-»
			«EXPAND checkAdditionalConstraint(creationConstraints, true) FOR getDiagram().editorGen.expressionProviders.getProvider(creationConstraints.sourceEnd)-»
		«ENDIF-»
		«IF null != creationConstraints.targetEnd-»
			«EXPAND checkAdditionalConstraint(creationConstraints, false) FOR getDiagram().editorGen.expressionProviders.getProvider(creationConstraints.targetEnd)-»
		«ENDIF-»
	«ENDIF-»
	return true;
}
d386 1
a387 1

d392 3
a394 5
«DEFINE canCreateParameters FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»

«DEFINE canCreateValues FOR gmfgen::TypeLinkModelFacet»«IF null != sourceMetaFeature»container, «ENDIF»«EXPAND sourceTargetValues»«ENDDEFINE»
a395 1
«DEFINE canCreateValues FOR gmfgen::FeatureLinkModelFacet»«EXPAND sourceTargetValues»«ENDDEFINE»
a396 1
«DEFINE sourceTargetValues FOR gmfgen::LinkModelFacet»source, target«ENDDEFINE»
d398 1
a398 3
«DEFINE canCreateValues FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»
d414 1
a414 1
	«IF ecoreFeature.upperBound > 0-»
d418 1
a418 1
	«ENDIF-»
a420 2
«DEFINE featureBoundComparator(String featureVar, genmodel::GenClass featureVarGenClass) FOR genmodel::GenFeature»«EXPAND MetaModel::getFeatureValue(featureVar, featureVarGenClass)»«IF ecoreFeature.upperBound == 1» != null«ELSE».size() >= «ecoreFeature.upperBound»«ENDIF»«ENDDEFINE»

d442 1
a444 3
«DEFINE checkEMFConstraints FOR gmfgen::LinkModelFacet-»
	«EXPAND incorrectLinkModelFacet-»
«ENDDEFINE»
d446 2
a447 4
«DEFINE checkAdditionalConstraint(gmfgen::GenLinkConstraints constraints, boolean checkSource) FOR gmfgen::GenExpressionInterpreter-»
if (!evaluate(«EXPAND xpt::expressions::getExpression::interptererExpressionConstantName(checkSource) FOR constraints», «IF checkSource»source, target«ELSE»target, source«ENDIF», «!checkSource»)) {
	return false;
}
d450 2
a451 12
«DEFINE checkAdditionalConstraint(gmfgen::GenLinkConstraints constraints, boolean checkSource) FOR gmfgen::GenJavaExpressionProvider-»
if (!JavaConstraints.«getOperationName(checkSource ? constraints.sourceEnd : constraints.targetEnd)»(«IF checkSource»source, target«ELSE»target, source«ENDIF»).booleanValue()) {
	return false;
}
«ENDDEFINE»

«REM»Can be moved to xpt::expressions::getExpression.xpt«ENDREM»
«DEFINE evaluateInterpreterExpression FOR gmfgen::GenExpressionProviderContainer-»

«EXPAND xpt::Common::generatedMemberComment»
private static boolean evaluate(«getAbstractExpressionQualifiedClassName()» constraint, Object sourceEnd, Object oppositeEnd, boolean clearEnv) {
	if (sourceEnd == null) {
d454 6
a459 6
	java.util.Map evalEnv = java.util.Collections.singletonMap(OPPOSITE_END_VAR, oppositeEnd);			
	try {
		Object val = constraint.evaluate(sourceEnd, evalEnv);
		return (val instanceof Boolean) ? ((Boolean) val).booleanValue() : false;
	} catch(Exception e) {	
		«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Link constraint evaluation error", e); «EXPAND xpt::Common::nonNLS»
d461 1
a461 2
	}
}
d464 5
a468 7
«REM»Can be moved to xpt::expressions::getExpression.xpt«ENDREM»
«DEFINE JavaConstraints FOR gmfgen::GenDiagram-»

«EXPAND xpt::Common::generatedClassComment»
private static class JavaConstraints {
	«EXPAND javaExpressionOperations FOREACH getValidLinkConstraints()-»
}
a470 12
«DEFINE javaExpressionOperations FOR gmfgen::GenLinkConstraints-»
	«LET link.getDiagram().editorGen.expressionProviders AS expressionProviders-»
		«IF null != sourceEnd-»
		
			«EXPAND defineJAVAConstraint(sourceEnd, getSourceEndContextClass(), getTargetEndContextClass()) FOR expressionProviders.getProvider(sourceEnd)-»
		«ENDIF-»
		«IF null != targetEnd-»
		
			«EXPAND defineJAVAConstraint(targetEnd, getTargetEndContextClass(), getSourceEndContextClass()) FOR expressionProviders.getProvider(targetEnd)-»
		«ENDIF-»
	«ENDLET-»
«ENDDEFINE»
d472 1
a472 21
«DEFINE defineJAVAConstraint(gmfgen::GenConstraint constraint, genmodel::GenClass context, genmodel::GenClass oppositeEndContext) FOR gmfgen::GenJavaExpressionProvider»
	«EXPAND xpt::expressions::javaExpressionOperation::javaExpressionOperation(constraint, context, oppositeEndContext)-»
«ENDDEFINE»

«DEFINE defineJAVAConstraint(gmfgen::GenConstraint constraint, genmodel::GenClass context, genmodel::GenClass oppositeEndContext) FOR gmfgen::GenExpressionInterpreter»«ENDDEFINE»

«DEFINE defineJAVAConstraint(gmfgen::GenConstraint constraint, genmodel::GenClass context, genmodel::GenClass oppositeEndContext) FOR gmfgen::GenExpressionProviderBase»
	«EXPAND incorrectExpressionProviderBase-»
«ENDDEFINE»

«DEFINE checkAdditionalConstraint(gmfgen::GenLinkConstraints constraints, boolean checkSource) FOR gmfgen::GenExpressionProviderBase-»
	«EXPAND incorrectExpressionProviderBase-»
«ENDDEFINE»

«DEFINE incorrectExpressionProviderBase FOR gmfgen::GenExpressionProviderBase-»
	«ERROR "Unrecognized expression provider: " + this-»
«ENDDEFINE»

«DEFINE incorrectLinkModelFacet FOR gmfgen::LinkModelFacet-»
	«ERROR "Unrecognized link model facet: " + this-»
«ENDDEFINE»
@


1.25
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d405 1
a405 1
«DEFINE featureBoundComparator(String featureVar, genmodel::GenClass featureVarGenClass) FOR genmodel::GenFeature»«EXPAND xpt::Common::getFeatureValue(featureVar, featureVarGenClass)»«IF ecoreFeature.upperBound == 1» != null«ELSE».size() >= «ecoreFeature.upperBound»«ENDIF»«ENDDEFINE»
d428 1
a428 1
«DEFINE featureUniquenessComparator(String featureVar, genmodel::GenClass featureVarGenClass) FOR genmodel::GenFeature»«EXPAND xpt::Common::getFeatureValue(featureVar, featureVarGenClass) FOR this».contains(target)«ENDDEFINE»
@


1.24
log
@[219146] - null label for CompositeTransactionalCommand provokes NPE from operationHistoryActionHandler.shortenText
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d364 1
a364 1
«DEFINE canCreateParameters FOR gmfgen::TypeLinkModelFacet»«IF null != sourceMetaFeature»«containmentMetaFeature.genClass.getQualifiedInterfaceName()» container, «ENDIF»«EXPAND sourceTargetParameters»«ENDDEFINE»
d368 1
a368 1
«DEFINE sourceTargetParameters FOR gmfgen::LinkModelFacet»«getSourceType().getQualifiedInterfaceName()» source, «getTargetType().getQualifiedInterfaceName()» target«ENDDEFINE»
@


1.23
log
@[193474] - Should not possible to create phantom containment link from self phantom element
@
text
@d167 1
a167 1
				command = new org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand(editingDomain, null).compose(command);
@


1.22
log
@addDestroyShortcutsCommand moved to BaseItemSemanticEditPolicy
@
text
@d419 5
@


1.22.2.1
log
@[193474] - Should not possible to create phantom containment link from self phantom element
@
text
@a418 5
		«IF metaFeature.isContains()»
	if (source == target) {
		return false;
	}
		«ENDIF-»	
@


1.22.2.2
log
@[193474] - Should not possible to create phantom containment link from self phantom element
@
text
@d419 1
a419 1
		«IF metaFeature.isContains()-»
@


1.21
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@d81 2
d90 17
@


1.20
log
@Log messages are not licalized in GMF.
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
@


1.19
log
@Refactoring templates to store ExpressionInterpreter-based definition in the same file.
@
text
@d485 1
a485 13
«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»

«DEFINE i18nAccessors FOR gmfgen::GenDiagram-»
«IF null != editorGen.expressionProviders && hasInterpreterConstraints()-»
    «EXPAND xpt::Externalizer::accessorField(i18nKeyForLinkConstraintErrorLog())-»
«ENDIF-»
«ENDDEFINE»

«DEFINE i18nValues FOR gmfgen::GenDiagram-»
«IF null != editorGen.expressionProviders && hasInterpreterConstraints()-»
«EXPAND xpt::Externalizer::messageEntry(i18nKeyForLinkConstraintErrorLog(), "Link constraint evaluation error")-»
«ENDIF-»
«ENDDEFINE»
@


1.18
log
@Replacing static method calls with templates.
@
text
@d304 1
a304 1
		«EXPAND defineConstraintExpressions FOREACH getValidLinkConstraints(this)-»
d309 2
a310 2
		«IF hasOCLConstraints()-»
			«EXPAND evaluateOCL FOR editorGen.expressionProviders-»
d312 1
a312 1
		«IF hasJavaConstraints()-»
a319 30
«DEFINE defineConstraintExpressions FOR gmfgen::GenLinkConstraints-»
	«LET link.getDiagram().editorGen.expressionProviders AS expressionProviders-»
		«IF null != sourceEnd-»
		
			«EXPAND defineOCLConstraint(getSourceExpressionVarName(link), sourceEnd, getSourceEndContextClass(), getTargetEndContextClass()) FOR expressionProviders.getProvider(sourceEnd)-»
		«ENDIF-»
		«IF null != targetEnd-»
		
			«EXPAND defineOCLConstraint(getTargetExpressionVarName(link), targetEnd, getTargetEndContextClass(), getSourceEndContextClass()) FOR expressionProviders.getProvider(targetEnd)-»
		«ENDIF-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE defineOCLConstraint(String varName, gmfgen::GenConstraint constraint, genmodel::GenClass context, genmodel::GenClass oppositeEndContext) FOR gmfgen::GenExpressionInterpreter-»
«EXPAND xpt::Common::generatedMemberComment»
private static «container.editorGen.expressionProviders.getAbstractExpressionQualifiedClassName()» «varName»;

«EXPAND xpt::Common::generatedMemberComment»
static {
	«EXPAND xpt::expressions::getExpression::initOppositeEndEnv FOR oppositeEndContext-»
	«varName» = «EXPAND xpt::expressions::getExpression::getExpressionWithEnv(constraint, context)»; «EXPAND xpt::Common::nonNLS»
}
«ENDDEFINE»

«DEFINE defineOCLConstraint(String varName, gmfgen::GenConstraint constraint, genmodel::GenClass context, genmodel::GenClass oppositeEndContext) FOR gmfgen::GenJavaExpressionProvider»«ENDDEFINE»

«DEFINE defineOCLConstraint(String varName, gmfgen::GenConstraint constraint, genmodel::GenClass context, genmodel::GenClass oppositeEndContext) FOR gmfgen::GenExpressionProviderBase-»
	«EXPAND incorrectExpressionProviderBase-»
«ENDDEFINE»

d411 1
a411 1
if (!evaluate(«IF checkSource»«getSourceExpressionVarName(constraints.link)», source, target«ELSE»«getTargetExpressionVarName(constraints.link)», target, source«ENDIF», «!checkSource»)) {
d422 2
a423 1
«DEFINE evaluateOCL FOR gmfgen::GenExpressionProviderContainer-»
d435 1
a435 1
		«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError(«EXPAND xpt::Externalizer::accessorCall(i18nKeyForLinkConstraintErrorLog()) FOR editorGen», e);
d441 1
d488 1
a488 1
«IF null != editorGen.expressionProviders && hasOCLConstraints()-»
d494 1
a494 1
«IF null != editorGen.expressionProviders && hasOCLConstraints()-»
@


1.17
log
@Generating VisualIDRegistry using XPAND.
@
text
@d40 1
a40 1
				Integer id = new Integer(«getVisualIDRegistryQualifiedClassName()».getVisualID((org.eclipse.gmf.runtime.notation.View) view));
@


1.16
log
@Updating copyrights.
@
text
@d363 1
a363 1
	«IF creationConstraints != null && creationConstraints.isValid()-»
@


1.15
log
@Using semantic command form EditPart even if editHelper command == null.

Use case: phantom node (top-level diagram node without parnt stored in Resource) can not be removed because:
- domainElement container == null
- editHelperContext == defaultContext
- elementType == default element type

=> element type will be set to null and no edithelper command returned..
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.14
log
@[180702] Move logic from semantic edit policy into creation commands
@
text
@d138 3
a140 3
	org.eclipse.gef.commands.Command epCommand = getSemanticCommandSwitch(completedRequest);
	if (epCommand != null) {
		org.eclipse.gmf.runtime.common.core.command.ICommand command = epCommand instanceof org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy ? ((org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy) epCommand).getICommand() : new org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy(epCommand);
a142 1
	org.eclipse.gef.commands.Command ehCommand = null;
d150 1
a150 1
			ehCommand = new org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy(command);
d161 1
a161 1
			ehCommand = ehCommand == null ? deleteViewCommand : ehCommand.chain(deleteViewCommand);
d163 1
a163 1
		return ehCommand;
@


1.13
log
@Removing unnecessary parameters + more correct external interface check added.
@
text
@a118 2

	«EXPAND getRelationshipContainer-»
a298 20
«DEFINE getRelationshipContainer FOR gmfgen::GenDiagram-»
«EXPAND xpt::Common::generatedClassComment(
	"Finds container element for the new relationship of the specified type.\n" +
	"Default implementation goes up by containment hierarchy starting from\n" +
	"the specified element and returns the first element that is instance of\n" +
	"the specified container class.\n"
)»
protected org.eclipse.emf.ecore.EObject getRelationshipContainer(Object uelement, org.eclipse.emf.ecore.EClass containerClass, org.eclipse.gmf.runtime.emf.type.core.IElementType relationshipType) {
	if (uelement instanceof org.eclipse.emf.ecore.EObject) {
		org.eclipse.emf.ecore.EObject element = (org.eclipse.emf.ecore.EObject) uelement;
		for (; element != null; element = element.eContainer()) {
			if (containerClass.isSuperTypeOf(element.eClass())) {
				return element;
			}
		}
	}
	return null;
}
«ENDDEFINE»

@


1.12
log
@Rewriting template to xpt

[170079] - Do not generate unnecessary CanonicalEditPolicies in case if phantoms are allowed for diagram
@
text
@d439 1
a439 1
«DEFINE featureBoundComparator(String featureVar, genmodel::GenClass featureVarGenClass) FOR genmodel::GenFeature»«EXPAND xpt::Common::getFeatureValue(featureVar, featureVarGenClass, true)»«IF ecoreFeature.upperBound == 1» != null«ELSE».size() >= «ecoreFeature.upperBound»«ENDIF»«ENDDEFINE»
d457 1
a457 1
«DEFINE featureUniquenessComparator(String featureVar, genmodel::GenClass featureVarGenClass) FOR genmodel::GenFeature»«EXPAND xpt::Common::getFeatureValue(featureVar, featureVarGenClass, true) FOR this».contains(target)«ENDDEFINE»
@


1.11
log
@avoid extra confirmations
@
text
@d26 1
a26 5
	/**
	 * Extended request data key to hold editpart visual id.
	 * 
	 * @@generated
	 */
d29 7
a35 8
	/**
	 * Add visual id of edited editpart to extended data of the request
	 * so command switch can decide what kind of diagram element is being edited.
	 * It is done in those cases when it's not possible to deduce diagram
	 * element kind from domain element.
	 * 
	 * @@generated
	 */
d46 2
a47 6

	/**
	 * Returns visual id from request parameters.
	 * 
	 * @@generated
	 */
d55 1
a55 5
	/**
	 * Returns editing domain from the host edit part.
	 * 
	 * @@generated
	 */
d60 1
a60 5
	/**
	 * Creates command to destroy the link.
	 * 
	 * @@generated
	 */
d69 1
a69 5
	/**
	 * Creates commands to destroy all host incoming and outgoing links.
	 * 
	 * @@generated
	 */
d433 1
a433 1
if («EXPAND featureBoundComparator(getContainerVariable(modelFacet))») {
d439 1
a439 1
«DEFINE featureBoundComparator(String featureVar) FOR genmodel::GenFeature»«EXPAND xpt::Common::getFeatureValue(featureVar, true)»«IF ecoreFeature.upperBound == 1» != null«ELSE».size() >= «ecoreFeature.upperBound»«ENDIF»«ENDDEFINE»
d446 1
a446 1
		«IF metaFeature.ecoreFeature.upperBound > 0»«EXPAND featureBoundComparator(sourceVar) FOR metaFeature»«ENDIF-»
d450 1
a450 1
		«IF metaFeature.ecoreFeature.upperBound != 1»«EXPAND featureUniquenessComparator(sourceVar) FOR metaFeature»«ENDIF») {
d457 1
a457 1
«DEFINE featureUniquenessComparator(String featureVar) FOR genmodel::GenFeature»«EXPAND xpt::Common::getFeatureValue(featureVar, true) FOR this».contains(target)«ENDDEFINE»
@


1.10
log
@renamed getMSLWrapper into getGEFWrapper to better reflect what's going on and to avoid unknown acronym
@
text
@d78 1
a78 1
	protected org.eclipse.gef.commands.Command getDestroyElementCommand(org.eclipse.gmf.runtime.notation.View view, boolean confirm) {
d81 3
a83 2
				new org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest(getEditingDomain(), confirm);
		return editPart.getCommand(new org.eclipse.gmf.runtime.diagram.ui.requests.EditCommandRequestWrapper(request, java.util.Collections.EMPTY_MAP));
d91 1
a91 1
	protected org.eclipse.gef.commands.CompoundCommand getDestroyEdgesCommand(boolean confirm) {
d95 1
a95 1
			cmd.add(getDestroyElementCommand((org.eclipse.gmf.runtime.notation.Edge) it.next(), confirm));
d98 1
a98 1
			cmd.add(getDestroyElementCommand((org.eclipse.gmf.runtime.notation.Edge) it.next(), confirm));
@


1.9
log
@[177795] deletion of diagram node may corrupt model
@
text
@d135 1
d299 1
a299 1
«DEFINE getMSLWrapper FOR gmfgen::GenDiagram-»
d301 1
a301 1
	protected org.eclipse.gef.commands.Command getMSLWrapper(org.eclipse.gmf.runtime.common.core.command.ICommand cmd) {
d306 8
@


1.8
log
@remove extra s letter
@
text
@d78 2
a79 2
	protected org.eclipse.gef.commands.Command getDestroyEdgeCommand(org.eclipse.gmf.runtime.notation.Edge edge, boolean confirm) {
		org.eclipse.gef.EditPart editPart = (org.eclipse.gef.EditPart) getHost().getViewer().getEditPartRegistry().get(edge);
d94 1
a94 1
			cmd.add(getDestroyEdgeCommand((org.eclipse.gmf.runtime.notation.Edge) it.next(), confirm));
d97 1
a97 1
			cmd.add(getDestroyEdgeCommand((org.eclipse.gmf.runtime.notation.Edge) it.next(), confirm));
@


1.7
log
@move common code to base editpolicy
@
text
@d90 1
a90 1
	protected org.eclipse.gef.commands.CompoundCommand getDestroyEdgesCommands(boolean confirm) {
@


1.6
log
@[179063] check link constraints for type based links on reroute
@
text
@d63 39
a101 1
	
@


1.5
log
@User should be able to configure whether NON-NLS markers are shown or not
@
text
@d296 1
a296 1
protected static class «getLinkCreationConstraintsClassName()» {
d303 1
d351 8
d381 10
@


1.4
log
@support domain elements with explicit instance class names
@
text
@d31 1
a31 1
	public static final String VISUAL_ID_KEY = "visual_id"; //$NON-NLS-1$
d117 1
a117 1
	if (elementType == org.eclipse.gmf.runtime.emf.type.core.ElementTypeRegistry.getInstance().getType("org.eclipse.gmf.runtime.emf.type.core.default")) { //$NON-NLS-1$ 
d299 1
a299 1
	private static final String OPPOSITE_END_VAR = "oppositeEnd"; //$NON-NLS-1$
d335 1
a335 1
	«varName» = «EXPAND xpt::expressions::getExpression::getExpressionWithEnv(constraint, context)»; //$NON-NLS-1$
@


1.3
log
@[114348] add command to reorient ref based links
@
text
@d281 7
a287 4
protected org.eclipse.emf.ecore.EObject getRelationshipContainer(org.eclipse.emf.ecore.EObject element, org.eclipse.emf.ecore.EClass containerClass, org.eclipse.gmf.runtime.emf.type.core.IElementType relationshipType) {
	for (; element != null; element = element.eContainer()) {
		if (containerClass.isSuperTypeOf(element.eClass())) {
			return element;
@


1.2
log
@[139733] akarjakina - lack of i18n support. More templates i18n-ed
@
text
@d26 36
@


1.1
log
@editpolicy templates should be located in one folder
@
text
@d402 1
a402 1
		«editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Link constraint evaluation error", e); //$NON-NLS-1$
d451 13
a463 1
«DEFINE additions FOR gmfgen::GenDiagram»«ENDDEFINE»@

