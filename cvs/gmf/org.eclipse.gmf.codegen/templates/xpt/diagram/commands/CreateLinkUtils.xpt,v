head	1.17;
access;
symbols
	v20081022-1925:1.17
	v20081015-1925:1.17
	v20081008-1925:1.17
	v20081001-1925:1.17
	v20080930-1130:1.17
	v20080926-1245:1.17
	v20080924-1925:1.17
	v20080917-1925:1.17
	v20080911-1728:1.17
	v20080910-1520:1.17
	v20080903-1520:1.17
	v20080827-1520:1.16
	v20080813-1520:1.15
	v20080806-1520:1.15
	v20080722-1827:1.15
	v20080718-1731:1.15
	v20080716-1600:1.13
	v20080716-1642:1.15
	R2_1_maintenance:1.13.0.2
	Root_R2_1_maintenance:1.13
	R2_1_0:1.13
	v20080610-1132:1.13
	v20080603-1553:1.13
	v20080528-1052:1.13
	v20080521:1.13
	v20080516-1543:1.13
	v20080516-1143:1.13
	v20080512-1200:1.13
	v20080508-2000:1.13
	v20080507-1326:1.13
	v20080503-1740:1.12
	v20080501-1739:1.12
	v20080425-1959:1.12
	v20080417-1610:1.12
	v20080411-0411:1.12
	v20080404-1111:1.12
	v20080322-0000:1.12
	v20080222-1200:1.6
	v20080215-1500:1.6
	v20080207-0207:1.6
	v20071222-1111:1.6
	v20071214-1111:1.6
	v20071130-1111:1.6
	v20071124-0000:1.6
	v20071112-0000:1.6
	v20071108-0000:1.6
	v20071003-0000:1.6
	v20070928-0000:1.6
	v20070921-0000:1.6
	v20070915-0000:1.6
	v20070903-0000:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	v20070621-0000:1.6
	RC3_20:1.6
	v20070614-1400:1.6
	v20070608-1300:1.6
	v20070605-1400:1.6
	v20070601-1400:1.6
	v20070525-1500:1.6
	v20070520-1200:1.6
	v20070518-1300:1.5
	v20070504-1000:1.5
	v20070427-0600:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.17
date	2008.08.28.16.42.35;	author dstadnik;	state Exp;
branches;
next	1.16;
commitid	6af48b6d57a4567;

1.16
date	2008.08.20.13.30.37;	author dstadnik;	state Exp;
branches;
next	1.15;
commitid	26c448ac1c694567;

1.15
date	2008.07.01.18.48.54;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	4f11486a7c164567;

1.14
date	2008.06.30.19.46.29;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	763c486938144567;

1.13
date	2008.05.07.13.56.00;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	39124821b4de4567;

1.12
date	2008.03.04.21.07.05;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	568f47cdb9f94567;

1.11
date	2008.02.28.18.17.30;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	68cb47c6faba4567;

1.10
date	2008.02.28.17.53.04;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	5b2847c6f4ff4567;

1.9
date	2008.02.26.13.53.51;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	19d047c419ed4567;

1.8
date	2008.02.21.21.28.44;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	68147bded0c4567;

1.7
date	2008.02.21.18.35.58;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	6b4047bdc48d4567;

1.6
date	2007.05.18.21.17.19;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	2591464e17d14567;

1.5
date	2007.05.04.10.50.01;	author dstadnik;	state Exp;
branches;
next	1.4;
commitid	29e4463b0fd84567;

1.4
date	2007.04.30.11.54.36;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	27754635d8fc4567;

1.3
date	2007.04.24.15.37.47;	author dstadnik;	state Exp;
branches;
next	1.2;
commitid	4e6462e244a4567;

1.2
date	2007.04.24.09.41.43;	author dstadnik;	state Exp;
branches;
next	1.1;
commitid	5f24462dd0d64567;

1.1
date	2007.04.23.14.04.58;	author dstadnik;	state Exp;
branches;
next	;
commitid	4a11462cbd094567;


desc
@@


1.17
log
@[199995] always generate checks
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»

«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::diagram::Utils»

«REM»
	Check whether link may be created.
«ENDREM»
«DEFINE canCreate(gmfgen::GenLink link) FOR gmfgen::LinkModelFacet-»

	«EXPAND xpt::Common::generatedMemberComment»
	public boolean canExecute() {
		if (source == null && target == null) {
			return false;
		}
		if (source != null && «EXPAND MetaModel::NotInstance("source") FOR getSourceType()») {
			return false;
		}
		if (target != null && «EXPAND MetaModel::NotInstance("target") FOR getTargetType()») {
			return false;
		}
		if (getSource() == null) {
			return true; // link creation is in progress; source is not defined yet
		}
		// target may be null here but it's possible to check constraint
		«EXPAND canCreateElement(link)-»
	}
«ENDDEFINE»

«DEFINE canCreateElement(gmfgen::GenLink link) FOR gmfgen::LinkModelFacet-»
«ENDDEFINE»

«DEFINE canCreateElement(gmfgen::GenLink link) FOR gmfgen::TypeLinkModelFacet-»
	«IF hasContainerOtherThanSource()-»
	if (getContainer() == null) {
		return false;
	}
	«ENDIF-»
	return «EXPAND validatorInvocation FOR link»(«IF hasContainerOtherThanSource()»getContainer(), «ENDIF»getSource(), getTarget());
«ENDDEFINE»

«DEFINE canCreateElement(gmfgen::GenLink link) FOR gmfgen::FeatureLinkModelFacet-»
	return «EXPAND validatorInvocation FOR link»(getSource(), getTarget());
«ENDDEFINE»

«DEFINE validatorInvocation FOR gmfgen::GenLink-»
«diagram.getBaseItemSemanticEditPolicyQualifiedClassName()».«diagram.getLinkCreationConstraintsClassName()».canCreate«getUniqueIdentifier()-»
«ENDDEFINE»

«REM»
	Fields of command that creates link.
«ENDREM»
«DEFINE fields FOR gmfgen::LinkModelFacet»
	«EXPAND xpt::Common::generatedMemberComment»
	private final org.eclipse.emf.ecore.EObject source;

	«EXPAND xpt::Common::generatedMemberComment»
	private final org.eclipse.emf.ecore.EObject target;
«ENDDEFINE»

«DEFINE fields FOR gmfgen::TypeLinkModelFacet»
	«EXPAND xpt::Common::generatedMemberComment»
	private final org.eclipse.emf.ecore.EObject source;

	«EXPAND xpt::Common::generatedMemberComment»
	private final org.eclipse.emf.ecore.EObject target;
«IF hasContainerOtherThanSource()»

	«EXPAND xpt::Common::generatedMemberComment»
	private final «EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» container;
«ENDIF-»
«ENDDEFINE»

«REM»
	Field accessors of command that creates link.
«ENDREM»
«DEFINE accessors FOR gmfgen::LinkModelFacet-»

	«EXPAND xpt::Common::generatedMemberComment»
	protected «EXPAND MetaModel::QualifiedClassName FOR getSourceType()» getSource() {
		return «EXPAND MetaModel::CastEObject("source") FOR getSourceType()»;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected «EXPAND MetaModel::QualifiedClassName FOR getTargetType()» getTarget() {
		return «EXPAND MetaModel::CastEObject("target") FOR getTargetType()»;
	}
	«EXPAND containerAccessor-»
«ENDDEFINE»

«DEFINE containerAccessor FOR gmfgen::LinkModelFacet»«ENDDEFINE»

«DEFINE containerAccessor FOR gmfgen::TypeLinkModelFacet-»
«IF hasContainerOtherThanSource()-»

	«EXPAND xpt::Common::generatedMemberComment»
	public «EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» getContainer() {
		return container;
	}

	«EXPAND xpt::Common::generatedMemberComment(
		"Default approach is to traverse ancestors of the source to find instance of container.\n" +
		"Modify with appropriate logic."
	)»
	private static «EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» deduceContainer(org.eclipse.emf.ecore.EObject source, org.eclipse.emf.ecore.EObject target) {
		// Find container element for the new link.
		// Climb up by containment hierarchy starting from the source
		// and return the first element that is instance of the container class.
		for (org.eclipse.emf.ecore.EObject element = source; element != null; element = element.eContainer()) {
			if («EXPAND MetaModel::IsInstance("element") FOR containmentMetaFeature.genClass») {
				return «EXPAND MetaModel::CastEObject("element") FOR containmentMetaFeature.genClass»;
			}
		}
		return null;
	}
«ENDIF-»

«ENDDEFINE»

«REM»
	Part of the constructor that performs initialization.
«ENDREM»
«DEFINE init FOR gmfgen::LinkModelFacet-»
	this.source = source;
	this.target = target;
«ENDDEFINE»

«DEFINE init FOR gmfgen::TypeLinkModelFacet-»
	this.source = source;
	this.target = target;
	if (request.getContainmentFeature() == null) {
		setContainmentFeature(«EXPAND MetaModel::MetaFeature FOR containmentMetaFeature»);
	}
	«REM»XXX!!! 
		FIXME - do not need to setElementToEdit unless use doDefaultElementCreation (no) and canExecute from [Create|Edit]ElementCommand (no, IMO)
	«ENDREM»
	«IF hasContainerOtherThanSource()-»
	container = deduceContainer(source, target);
	if (container != null) {
		super.setElementToEdit(«EXPAND MetaModel::DowncastToEObject("container") FOR containmentMetaFeature.genClass»);
	}
	«ELSE-»
	super.setElementToEdit(«EXPAND MetaModel::DowncastToEObject("source") FOR containmentMetaFeature.genClass»);
	«ENDIF-»
«ENDDEFINE»@


1.16
log
@[199995] generate valid code for links with unchangeable features
@
text
@a47 1
«IF (sourceMetaFeature == null ? containmentMetaFeature.ecoreFeature.changeable : sourceMetaFeature.ecoreFeature.changeable) && (targetMetaFeature.ecoreFeature.changeable)-»
a53 3
«ELSE-»
	return false;
«ENDIF-»
a56 1
«IF metaFeature.ecoreFeature.changeable-»
a57 3
«ELSE-»
	return false;
«ENDIF-»
@


1.15
log
@refactored templates moving towards [188329] - Support Java 5.0 (would need to respect generic types when adding into collections) while trying to accomplish [227127]
@
text
@a44 1
	return «EXPAND validatorInvocation FOR link»(getSource(), getTarget());
d48 1
d55 11
@


1.14
log
@[226882] Support links with childMetaFeature not from container
@
text
@a155 8
«ENDDEFINE»

«DEFINE addValue(String containerVar, genmodel::GenClass containerClass, String valueVar) FOR genmodel::GenFeature-»
«IF isListType()-»
	«EXPAND MetaModel::getFeatureValue(containerVar, containerClass)».add(«valueVar»);
«ELSE-»
	«EXPAND MetaModel::setFeatureValue(containerVar, containerClass, valueVar)»;
«ENDIF-»
@


1.13
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d49 1
a49 1
	«IF sourceMetaFeature != null-»
d54 1
a54 2
	return «EXPAND validatorInvocation FOR link»(
			«IF sourceMetaFeature != null»getContainer(), «ENDIF»getSource(), getTarget());
d58 1
a58 2
«diagram.getBaseItemSemanticEditPolicyQualifiedClassName()».
	«diagram.getLinkCreationConstraintsClassName()».canCreate«getUniqueIdentifier()-»
d64 1
a64 2
«DEFINE fields FOR gmfgen::LinkModelFacet-»

a69 1
	«EXPAND containerField-»
d72 3
a74 2
«DEFINE containerField FOR gmfgen::LinkModelFacet-»
«ENDDEFINE»
d76 3
a78 2
«DEFINE containerField FOR gmfgen::TypeLinkModelFacet-»
	«IF sourceMetaFeature != null-»
d81 2
a82 2
	private «EXPAND MetaModel::QualifiedClassName FOR containmentMetaFeature.genClass» container;
	«ENDIF-»
d102 1
a102 2
«DEFINE containerAccessor FOR gmfgen::LinkModelFacet-»
«ENDDEFINE»
d105 1
a105 1
	«IF sourceMetaFeature != null-»
d111 18
a128 1
	«ENDIF-»
a136 1
	«EXPAND initContainment-»
d139 3
a141 4
«DEFINE initContainment FOR gmfgen::LinkModelFacet-»
«ENDDEFINE»

«DEFINE initContainment FOR gmfgen::TypeLinkModelFacet-»
d146 1
a146 2
	(1) why getContainer() only when sourceMetaFeature is set 
	(2) FIXME - do not need to setElementToEdit unless use doDefaultElementCreation (no) and canExecute from [Create|Edit]ElementCommand (no, IMO)
d148 4
a151 10
	«IF sourceMetaFeature != null-»
	// Find container element for the new link.
	// Climb up by containment hierarchy starting from the source
	// and return the first element that is instance of the container class.
	for (org.eclipse.emf.ecore.EObject element = source; element != null; element = element.eContainer()) {
		if («EXPAND MetaModel::IsInstance("element") FOR containmentMetaFeature.genClass») {
			container = «EXPAND MetaModel::CastEObject("element") FOR containmentMetaFeature.genClass»;
			super.«EXPAND setElementToEdit("container") FOR containmentMetaFeature-»
			break;
		}
d154 1
a154 1
	super.«EXPAND setElementToEdit("source") FOR containmentMetaFeature-»
a157 4
«DEFINE setElementToEdit(String elementVar) FOR genmodel::GenFeature-»
	setElementToEdit(«EXPAND MetaModel::DowncastToEObject(elementVar) FOR genClass»);
«ENDDEFINE»

@


1.12
log
@refactored node creation command not to delegate to superclass for primitive operations that can be easily accomplished directly
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.11
log
@refactor false == isInstance to NotInstance
@
text
@d154 1
a154 1
	setElementToEdit(«IF isExternalInterface(genClass)»(org.eclipse.emf.ecore.EObject) «ENDIF»«elementVar»);
d156 8
@


1.10
log
@refactor false == isInstance to NotInstance
@
text
@d30 1
a30 1
		if (source != null && «EXPAND MetaModel::NotInstance("source") FOR getSourceType()»)) {
@


1.9
log
@[150177] phase I, refactor existing code: completed - all metamodel access moved to MetaModel template.
@
text
@d30 1
a30 1
		if (source != null && !(«EXPAND MetaModel::IsInstance("source") FOR getSourceType()»)) {
d33 1
a33 1
		if (target != null && !(«EXPAND MetaModel::IsInstance("target") FOR getTargetType()»)) {
@


1.8
log
@[150177] phase I, refactor existing code: special alternatives for EObject.eContainer access; started extracting casts/qualified names when there's solid reason
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d131 1
a131 1
		setContainmentFeature(«EXPAND xpt::Common::metaFeatureAccessor FOR containmentMetaFeature»);
@


1.7
log
@[150177] phase I, refactor existing code: extract metamodel/generated code access into single place
@
text
@d83 1
a83 1
	private «getQualifiedInterfaceName(containmentMetaFeature.genClass)» container;
d93 2
a94 2
	protected «getQualifiedInterfaceName(getSourceType())» getSource() {
		return («getQualifiedInterfaceName(getSourceType())») source;
d98 2
a99 2
	protected «getQualifiedInterfaceName(getTargetType())» getTarget() {
		return («getQualifiedInterfaceName(getTargetType())») target;
d111 1
a111 1
	public «getQualifiedInterfaceName(containmentMetaFeature.genClass)» getContainer() {
d143 1
a143 1
			container = («getQualifiedInterfaceName(containmentMetaFeature.genClass)») element;
@


1.6
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@d30 1
a30 1
		if (source != null && !(source instanceof «getQualifiedInterfaceName(getSourceType())»)) {
d33 1
a33 1
		if (target != null && !(target instanceof «getQualifiedInterfaceName(getTargetType())»)) {
d142 1
a142 1
		if (element instanceof «getQualifiedInterfaceName(containmentMetaFeature.genClass)») {
@


1.5
log
@move getFeatureTargetType method to GenModelUtils
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
@


1.4
log
@do not delegate creation to superclass as it doesn't add anything but reflective clutter
@
text
@a17 1
«EXTENSION xpt::Utils»
@


1.3
log
@do not create additional request
@
text
@d134 4
@


1.2
log
@refactor code that finds link container
@
text
@d122 2
a123 2
	source = request.getSource();
	target = request.getTarget();
@


1.1
log
@[180702] Move logic from semantic edit policy into creation commands
@
text
@d84 1
a84 1
	private final «getQualifiedInterfaceName(containmentMetaFeature.genClass)» container;
d135 9
a143 7
	if (source != null) {
		container = («getQualifiedInterfaceName(containmentMetaFeature.genClass)») findLinkContainer(source,
				«getQualifiedPackageInterfaceName(containmentMetaFeature.genClass.genPackage)».eINSTANCE.
					get«getClassifierAccessorName(containmentMetaFeature.genClass)»());
		super.«EXPAND setElementToEdit("container") FOR containmentMetaFeature-»
	} else {
		container = null;
@

