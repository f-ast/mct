head	1.50;
access;
symbols
	v20081022-1925:1.50
	v20081015-1925:1.50
	v20081008-1925:1.50
	v20081001-1925:1.50
	v20080924-1925:1.50
	v20080917-1925:1.50
	v20080911-1728:1.50
	v20080910-1520:1.50
	v20080903-1520:1.50
	v20080827-1520:1.50
	v20080813-1520:1.50
	v20080806-1520:1.50
	v20070504-1000:1.49
	v20070427-0600:1.49
	v20070420-1000:1.49
	v20070413-1300:1.49
	v20070405-1100:1.48
	v20070403-1500:1.48
	v20070330-1300:1.48
	v20060330-1300:1.48
	v20070322-1100:1.48
	v20060316-0600:1.48
	v20070307-0700:1.48
	v20070301-1200:1.48
	v20070228-2000:1.48
	v20070221-1500:1.48
	v20070208-1800:1.48
	v20070202-0200:1.47.2.1
	v20070103-0300:1.48
	M4_20:1.48
	v20061222-1800:1.48
	v20061218-1200:1.48
	v20061214-0000:1.48
	v20061120-1300:1.48
	M3_20:1.48
	v20061117-0800:1.48
	v20061027-1200:1.47.2.1
	v20061020-1000:1.47.2.1
	v20061013-1330:1.48
	v20060919-0800:1.47.2.1
	v20060907-1100:1.47.2.1
	M1_20:1.48
	v20060904-1500:1.48
	v20060824-1600:1.47.2.1
	v20060817-1500:1.47.2.1
	v20060728-0500:1.47.2.1
	v20060713-1700:1.47
	R1_0_maintenance:1.47.0.2
	R1_0:1.47
	v20060627-1200:1.47
	v20060626-1420:1.47
	v20060620-0400:1.47
	v20060616-1400:1.47
	v20060616-1200:1.47
	v20060609-1400:1.47
	v20060531-1730:1.47
	v20060530-1930:1.47
	v20060526-1200:1.45
	v20060519-1300:1.45
	v20060519-0800:1.45
	v20060512-1000:1.43
	I20060512-1000:1.43
	I20060505-1400:1.41
	I20060428-1300:1.41
	I20060424-0500:1.39
	I20060424-0300:1.39
	M6_10:1.36
	I20060407-1200:1.33
	I20060331-1000:1.33
	I20060324-0300:1.33
	I20060317-1300:1.33
	I20060317-1200:1.33
	I20060316-1300:1.33
	I20060309-1300:1.32
	M5_10:1.31
	S20060303-1600:1.31
	I20060227-1730:1.31
	I20060216-1945:1.30
	I20060210-1715:1.26
	I20060209-1815:1.26
	I20060203-0830:1.21
	I20060202-1415:1.21
	I20060129-1145:1.20
	I20060127-0900:1.20
	I20060120-1530:1.18
	I20060113-1700:1.16
	M4_10:1.16
	I20060107-1100:1.14
	I20060105-1630:1.14
	I20051230-1230:1.14
	I20051223-1100:1.14
	I20051217-0925:1.13
	I20051208-2000:1.13
	I20051201-1800:1.13
	I20051124-2000:1.12
	M3_10:1.12
	I20051118-1245:1.12
	I20051111-1800:1.10
	I20051106-0900:1.7
	v20051030:1.6;
locks; strict;
comment	@# @;
expand	@k@;


1.50
date	2007.05.15.18.34.13;	author ashatalin;	state dead;
branches;
next	1.49;
commitid	25434649fd1f4567;

1.49
date	2007.04.06.12.14.57;	author dstadnik;	state Exp;
branches;
next	1.48;
commitid	6a69461639bf4567;

1.48
date	2006.07.24.12.37.13;	author ashatalin;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.30.15.28.05;	author radvorak;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2006.05.30.14.04.16;	author radvorak;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.18.14.03.44;	author dstadnik;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.15.17.11.53;	author ashatalin;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.11.12.21.31;	author ashatalin;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.10.11.13.14;	author dstadnik;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.27.16.46.41;	author radvorak;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.25.17.54.39;	author ashatalin;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.21.17.12.00;	author ashatalin;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.20.20.37.15;	author ashatalin;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.18.11.59.24;	author ashatalin;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.14.18.25.37;	author ashatalin;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.13.22.22.22;	author ashatalin;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.12.01.16.49;	author ashatalin;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.13.11.02.30;	author dstadnik;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.07.15.45.28;	author dstadnik;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.17.12.02.06;	author dstadnik;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.16.21.32.50;	author atikhomirov;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.14.18.46.23;	author ashatalin;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.13.19.21.42;	author ashatalin;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.13.17.20.07;	author ashatalin;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.08.16.06.19;	author atikhomirov;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.08.12.28.12;	author atikhomirov;	state Exp;
branches;
next	1.23;

1.23
date	2006.02.08.00.17.45;	author atikhomirov;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.05.22.57.54;	author atikhomirov;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.31.19.02.07;	author ashatalin;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.24.12.01.20;	author dstadnik;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.23.21.25.43;	author ashatalin;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.19.17.33.04;	author ashatalin;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.19.00.10.44;	author ashatalin;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.12.17.19.23;	author ashatalin;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.12.10.41.33;	author dstadnik;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.20.18.00.01;	author ashatalin;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.25.14.22.59;	author ashatalin;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.16.08.37.41;	author ashatalin;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.16.07.42.23;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.11.13.47.43;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.10.18.32.55;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.09.13.20.23;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.02.17.53.03;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.27.16.12.20;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.26.18.43.48;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.25.18.28.41;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.24.14.58.45;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.14.17.27.16;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.13.14.21.40;	author atikhomirov;	state Exp;
branches;
next	;

1.47.2.1
date	2006.07.24.12.54.14;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Generating VisualIDRegistry using XPAND.
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.editor" class="VisualIDRegistryGenerator"
	imports="org.eclipse.gmf.codegen.gmfgen.* java.util.* org.eclipse.gmf.common.codegen.* org.eclipse.emf.codegen.ecore.genmodel.*"%>
<%
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final String modelID = genDiagram.getEditorGen().getModelID();
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
final List genLinks = genDiagram.getLinks();
final Collection allContainers = genDiagram.getAllContainers();
%>
<%@@ include file="../copyright4java.jetinc"%>
<%importManager.emitPackageStatement(stringBuffer);%>

<%
final String matcherClassName = "Matcher";
final String javaMatcherContainer = "JavaMatchers";
importManager.registerInnerClass(matcherClassName);
importManager.registerInnerClass(javaMatcherContainer);

importManager.addImport("org.eclipse.emf.ecore.EClass");
importManager.addImport("org.eclipse.emf.ecore.EObject");
importManager.addImport("org.eclipse.gmf.runtime.notation.View");
importManager.addImport("org.eclipse.gmf.runtime.notation.Diagram");
importManager.addImport("org.eclipse.core.runtime.Platform");

importManager.markImportLocation(stringBuffer);
%>

/**
 * This registry is used to determine which type of visual object should be
 * created for the corresponding Diagram, Node, ChildNode or Link represented 
 * by a domain model object.
 *
 * @@generated
 */
public class <%=genDiagram.getVisualIDRegistryClassName()%> {

	/**
	 * @@generated
	 */
	private static final String DEBUG_KEY = <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getBundle().getSymbolicName() + "/debug/visualID"; //$NON-NLS-1$

	/**
	 * @@generated
	 */
	public static int getVisualID(View view) {
		if (view instanceof Diagram) {
			if (<%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.MODEL_ID.equals(view.getType())) {
				return <%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.VISUAL_ID;
			} else {
				return -1;
			}
		}
		return getVisualID(view.getType());
	}
	
	/**
	 * @@generated
	 */
	public static String getModelID(View view) {
		View diagram = view.getDiagram();
		while (view != diagram) {
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EAnnotation")%> annotation = view.getEAnnotation("Shortcut"); //$NON-NLS-1$
			if (annotation != null) {
				return (String) annotation.getDetails().get("modelID"); //$NON-NLS-1$
			}
			view = (View) view.eContainer();
		}
		return diagram != null ? diagram.getType() : null;
	}

	/**
	 * @@generated
	 */
	public static int getVisualID(String type) {
		try {
			return Integer.parseInt(type);
		} catch (NumberFormatException e) {
			if (Boolean.TRUE.toString().equalsIgnoreCase(Platform.getDebugOption(DEBUG_KEY))) {
				<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError("Unable to parse view type as a visualID number: " + type);
			}
		}
		return -1;
	}
	
	/**
	 * @@generated
	 */
	public static String getType(int visualID) {
		return String.valueOf(visualID);
	}
	
	/**
	 * @@generated
	 */
	public static int getDiagramVisualID(EObject domainElement) {
		if (domainElement == null) {
			return -1;
		}
		EClass domainElementMetaclass = domainElement.eClass();
		return getDiagramVisualID(domainElement, domainElementMetaclass);
	}

	/**
	 * @@generated
	 */
	private static int getDiagramVisualID(EObject domainElement, EClass domainElementMetaclass) {
<%
if (genDiagram.getDomainDiagramElement() != null) {
	String classifierAccessorName = genDiagram.getDomainDiagramElement().getClassifierAccessorName();
	String interfaceName = importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName());
%>
		if (<%=genDiagram.getMetaPackageName(importManager)%>.eINSTANCE.get<%=classifierAccessorName%>().isSuperTypeOf(domainElementMetaclass) && isDiagram<%=genDiagram.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement)) {
			return <%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.VISUAL_ID;
		}
<%}%>
		return getUnrecognizedDiagramID(domainElement);
	}

	/**
	 * @@generated
	 */
	public static int getNodeVisualID(View containerView, EObject domainElement) {
		if (domainElement == null) {
			return -1;
		}
		EClass domainElementMetaclass = domainElement.eClass();
		return getNodeVisualID(containerView, domainElement, domainElementMetaclass, null);
	}
	
	/**
	 * @@generated
	 */
	public static int getNodeVisualID(View containerView, EObject domainElement, EClass domainElementMetaclass, String semanticHint) {
		String containerModelID = getModelID(containerView);
		if (!<%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.MODEL_ID.equals(containerModelID)
<%
for (Iterator it = genDiagram.getShortcutsProvidedFor().iterator(); it.hasNext();) { 
	String nextDomainModelName = (String) it.next();
	if (modelID.equals(nextDomainModelName)) {
		continue;
	}
%>			
			&& !"<%=nextDomainModelName%>".equals(containerModelID)
<%
}
%>
		) {
			return -1;
		}
		int containerVisualID;
		if (<%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.MODEL_ID.equals(containerModelID)) {
			containerVisualID = getVisualID(containerView);
		} else {
			if (containerView instanceof Diagram) {
				containerVisualID = <%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.VISUAL_ID;		
			} else {
				return -1;
			}
		}
		int nodeVisualID = semanticHint != null ? getVisualID(semanticHint) : -1;
		switch (containerVisualID) {
<%
for (Iterator containers = allContainers.iterator(); containers.hasNext();) {
	GenContainerBase nextContainer = (GenContainerBase) containers.next();
%>
		case <%=importManager.getImportedName(nextContainer.getEditPartQualifiedClassName())%>.VISUAL_ID:
<%
	if (nextContainer instanceof GenNode) {
		GenNode node = (GenNode) nextContainer;
		for (Iterator labels = node.getLabels().iterator(); labels.hasNext();) {
			GenNodeLabel label = (GenNodeLabel) labels.next();
%>
			if (<%=importManager.getImportedName(label.getEditPartQualifiedClassName())%>.VISUAL_ID == nodeVisualID) {
				return <%=importManager.getImportedName(label.getEditPartQualifiedClassName())%>.VISUAL_ID;
			}
<%
		}
		for (Iterator compartments = node.getCompartments().iterator(); compartments.hasNext();) {
			GenCompartment compartment = (GenCompartment) compartments.next();
%>
			if (<%=importManager.getImportedName(compartment.getEditPartQualifiedClassName())%>.VISUAL_ID == nodeVisualID) {
				return <%=importManager.getImportedName(compartment.getEditPartQualifiedClassName())%>.VISUAL_ID;
			} 
<%
		}
	}

	for (Iterator childNodes = nextContainer.getContainedNodes().iterator(); childNodes.hasNext();) {
		GenNode childNode = (GenNode) childNodes.next();
%>
			if ((semanticHint == null || <%=importManager.getImportedName(childNode.getEditPartQualifiedClassName())%>.VISUAL_ID == nodeVisualID)
<%
		if (childNode.getModelFacet() != null) {
			final String classifierAccessorName = childNode.getDomainMetaClass().getClassifierAccessorName();
			final String interfaceName = importManager.getImportedName(childNode.getDomainMetaClass().getQualifiedInterfaceName());
			final String semanticPackageInterfaceName = importManager.getImportedName(childNode.getDomainMetaClass().getGenPackage().getQualifiedPackageInterfaceName()); 
%>
					&& <%=semanticPackageInterfaceName%>.eINSTANCE.get<%=classifierAccessorName%>().isSuperTypeOf(domainElementMetaclass)
					&& (domainElement == null || isNode<%=childNode.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement))
<%		}%>
				) {
				return <%=importManager.getImportedName(childNode.getEditPartQualifiedClassName())%>.VISUAL_ID;
			}
<%
	}
%>
			return getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(domainElement, semanticHint);
<%
}
for (Iterator links = genLinks.iterator(); links.hasNext();) {
	GenLink link = (GenLink) links.next();
	if (link.getLabels().size() > 0) {
%>
		case <%=importManager.getImportedName(link.getEditPartQualifiedClassName())%>.VISUAL_ID:
<%
		for (Iterator linkLabels = link.getLabels().iterator(); linkLabels.hasNext();) {
			GenLinkLabel linkLabel = (GenLinkLabel) linkLabels.next();
%>
			if (<%=importManager.getImportedName(linkLabel.getEditPartQualifiedClassName())%>.VISUAL_ID == nodeVisualID) {
				return <%=importManager.getImportedName(linkLabel.getEditPartQualifiedClassName())%>.VISUAL_ID;
			}
<%		}%>
			return getUnrecognized<%=link.getUniqueIdentifier()%>LinkLabelID(semanticHint);
<%	}
}%>
		}
		return -1;
	}
	
	/**
	 * @@generated
	 */
	public static int getLinkWithClassVisualID(EObject domainElement) {
		if (domainElement == null) {
			return -1;
		}
		EClass domainElementMetaclass = domainElement.eClass();
		return getLinkWithClassVisualID(domainElement, domainElementMetaclass);
	}
		
	/**
	 * @@generated
	 */
	public static int getLinkWithClassVisualID(EObject domainElement, EClass domainElementMetaclass) {
<%
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
		final TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) genLink.getModelFacet();
		final String semanticLinkInterfaceName = modelFacet.getMetaClass().getClassifierAccessorName();
		final String qualifiedInterfaceName = modelFacet.getMetaClass().getQualifiedInterfaceName();
		final String semanticPackageInterfaceName = importManager.getImportedName(modelFacet.getMetaClass().getGenPackage().getQualifiedPackageInterfaceName());
%>
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().isSuperTypeOf(domainElementMetaclass) && (domainElement == null || isLinkWithClass<%=genLink.getUniqueIdentifier()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) domainElement))) {
			return <%=importManager.getImportedName(genLink.getEditPartQualifiedClassName())%>.VISUAL_ID;
		} else 
<%
		}
	}
%>
		{
			return getUnrecognizedLinkWithClassID(domainElement);
		}
	}	

<%if (genDiagram.getDomainDiagramElement() != null) {%>
	/**
	 * User can change implementation of this method to check some additional 
	 * conditions here.
	 *
	 * @@generated
	 */
	private static boolean isDiagram<%=genDiagram.getUniqueIdentifier()%>(<%=importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName())%> element) {
		return true;
	}
<%}%>

	/**
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
	 * @@generated
	 */
	private static int getUnrecognizedDiagramID(EObject domainElement) {
		return -1;
	}
<%
for (Iterator nodes = genDiagram.getAllNodes().iterator(); nodes.hasNext();) {
	GenNode nextNode = (GenNode) nodes.next();
	if (nextNode.getModelFacet() == null) {
		continue;
	}
	String childNodeInterfaceName = importManager.getImportedName(nextNode.getDomainMetaClass().getQualifiedInterfaceName());
	boolean callMatcher = nextNode.getModelFacet() != null && nextNode.getModelFacet().getModelElementSelector() != null;
%>

	/**
	 * User can change implementation of this method to check some additional 
	 * conditions here.
	 *
	 * @@generated
	 */
	private static boolean isNode<%=nextNode.getUniqueIdentifier()%>(<%=childNodeInterfaceName%> element) {
		return <%if (callMatcher) {%><%=nextNode.getUniqueIdentifier()%>.matches(element)<%} else {%>true<%}%>;
	}	
<%
}
for (Iterator containers = allContainers.iterator(); containers.hasNext();) {
	GenContainerBase nextContainer = (GenContainerBase) containers.next();
%>

	/**
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
	 * @@generated
	 */	
	private static int getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(EObject domainElement, String semanticHint) {
		return -1;
	}
<%
}
for (Iterator links = genLinks.iterator(); links.hasNext();) {
	GenLink link = (GenLink) links.next();
	if (link.getLabels().size() == 0) {
		continue;
	}
%>

	/**
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
	 * @@generated
	 */	
	private static int getUnrecognized<%=link.getUniqueIdentifier()%>LinkLabelID(String semanticHint) {
		return -1;
	}
<%}%>

	/**
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
	 * @@generated
	 */
	private static int getUnrecognizedLinkWithClassID(EObject domainElement) {
		return -1;
	}
<%
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
		TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) genLink.getModelFacet();
		String interfaceName = importManager.getImportedName(modelFacet.getMetaClass().getQualifiedInterfaceName());
		boolean callMatcher = modelFacet.getModelElementSelector() != null;		
%>

	/**
	 * User can change implementation of this method to check some additional 
	 * conditions here.
	 *
	 * @@generated
	 */
	private static boolean isLinkWithClass<%=genLink.getUniqueIdentifier()%>(<%=interfaceName%> element) {
		return <%if (callMatcher) {%><%=genLink.getUniqueIdentifier()%>.matches(element)<%} else {%>true<%}%>;
	}
<%
	}
}

final GenExpressionProviderContainer expressionProviders = genDiagram.getEditorGen().getExpressionProviders();
final List javaSelectorFacets = new ArrayList();
final Map __exprEnvVariables = Collections.EMPTY_MAP;
final String __outEnvVarName = null; // no custom env
final String __javaOperationContainer = javaMatcherContainer; // put method here
int selectorCounter = 0;
for (Iterator it = genDiagram.eAllContents(); it.hasNext() && expressionProviders != null;) {
	Object next = it.next();
	String id = null;
	TypeModelFacet modelFacet = null;
	if (next instanceof GenNode) {
		id = ((GenNode) next).getUniqueIdentifier();
		modelFacet = ((GenNode) next).getModelFacet();
	} else if (next instanceof GenLink && ((GenLink) next).getModelFacet() instanceof TypeLinkModelFacet) {
		id = ((GenLink) next).getUniqueIdentifier();
		modelFacet = (TypeLinkModelFacet) ((GenLink) next).getModelFacet();
	}
	if (modelFacet == null || modelFacet.getModelElementSelector() == null || modelFacet.getMetaClass() == null) {
		continue;
	}
	GenConstraint selector = modelFacet.getModelElementSelector();
	selectorCounter++;
	// setup expression factory
	ValueExpression __genValueExpression = selector;
	GenClassifier __genExprContext = modelFacet.getMetaClass();
	GenExpressionProviderBase expressionProvider = expressionProviders.getProvider(__genValueExpression); 
	if(expressionProvider instanceof GenJavaExpressionProvider && !expressionProviders.isCopy(__genValueExpression)) {
		// skipping duplicates coming from reused node mappings 
		javaSelectorFacets.add(modelFacet);
	}
%>

	/**
	 * @@generated
	 */
	private static final <%=matcherClassName%> <%=id%> = new <%=matcherClassName%>(<%@@ include file="../expressions/getExpression.jetinc"%>);
<%
} /* end of selector interation */

if(selectorCounter > 0) { %>	

	/**
	 * @@generated	
	 */
	static class <%=matcherClassName%> {

		/**
		 * @@generated	
		 */					
		private <%=importManager.getImportedName(expressionProviders.getAbstractExpressionQualifiedClassName())%> condition;

		/**
		 * @@generated	
		 */				
		<%=matcherClassName%>(<%=importManager.getImportedName(expressionProviders.getAbstractExpressionQualifiedClassName())%> conditionExpression) {			
			this.condition = conditionExpression;
		}

		/**
		 * @@generated	
		 */						
		boolean matches(Object object) {
			Object result = condition.evaluate(object);
			return result instanceof Boolean && ((Boolean)result).booleanValue();			
		}
	}// <%=matcherClassName%>
<%
	if(!javaSelectorFacets.isEmpty()) {
%>
	/**
	 * @@generated
	 */
	private static class <%=javaMatcherContainer%> {
<%
		for(Iterator it = javaSelectorFacets.iterator(); it.hasNext();) {
			TypeModelFacet modelFacet = (TypeModelFacet) it.next();
			ValueExpression __genValueExpression = modelFacet.getModelElementSelector();
			GenClassifier __genExprContext = modelFacet.getMetaClass();
			String __genExprResultType = "java.lang.Boolean"; //$NON-NLS-1$
%>
<%@@ include file="../expressions/javaExpressionOperation.jetinc"%>
<%
		} /* java javaSelectorFacets iteration */
%>
	}// <%=javaMatcherContainer%>
<%
	} /* !javaSelectorFacets.isEmpty() */
} /* selectorCounter > 0 */
%>
}
	
<%importManager.emitSortedImports();%>
@


1.49
log
@[179027] Code does not compile if domain element has explicit class name and initializer or matcher
@
text
@@


1.48
log
@Correcting null-pointer exception.
@
text
@d412 1
a412 1
		
d417 1
a417 1
	
d422 1
a422 1
					
d429 1
a429 1
	
d433 1
a433 1
		boolean matches(EObject object) {
d444 1
a444 1
	 private static class <%=javaMatcherContainer%> {
@


1.47
log
@#144305 VisualIDRegistry.javajet should check for java expression duplicates in case of reused NodeMapping
1) provide a cleaner detection of expression copies for use in templates
@
text
@d234 3
@


1.47.2.1
log
@Correcting null-pointer in the generated code.
@
text
@a233 3
		if (domainElement == null) {
			return -1;
		}
@


1.46
log
@#144305 VisualIDRegistry.javajet should check for java expression duplicates in case of reused NodeMapping
@
text
@d395 3
a397 3
	if(expressionProvider instanceof GenJavaExpressionProvider) {
		// skip duplicates coming from reused node mappings 
		if(expressionProvider.getExpressions().contains(__genValueExpression)) javaSelectorFacets.add(modelFacet);
@


1.45
log
@#114175 Allow a diagram definition to be mapped to zero or more domain models.
@
text
@d394 4
a397 2
	if(expressionProviders.getProvider(__genValueExpression) instanceof GenJavaExpressionProvider) {
		javaSelectorFacets.add(modelFacet);
@


1.44
log
@#139843 Unable to parse view type as a visualID number
@
text
@d190 12
a201 5
		final String classifierAccessorName = childNode.getDomainMetaClass().getClassifierAccessorName();
		final String interfaceName = importManager.getImportedName(childNode.getDomainMetaClass().getQualifiedInterfaceName());
		final String semanticPackageInterfaceName = importManager.getImportedName(childNode.getDomainMetaClass().getGenPackage().getQualifiedPackageInterfaceName()); 
%>		
			if ((semanticHint == null || <%=importManager.getImportedName(childNode.getEditPartQualifiedClassName())%>.VISUAL_ID == nodeVisualID) && <%=semanticPackageInterfaceName%>.eINSTANCE.get<%=classifierAccessorName%>().isSuperTypeOf(domainElementMetaclass) && (domainElement == null || isNode<%=childNode.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement))) {
d203 1
a203 1
			} 
d287 3
@


1.43
log
@#139843
- VisualIdRegistry corrected
- .option file generated so in future we would be able to switch off info messages by default.
@
text
@d23 1
d40 5
d78 3
a80 1
			<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().logInfo("Unable to parse view type as a visualID number: " + type);
@


1.42
log
@#133836 Creating a child node without a label causes error
@
text
@d152 1
a152 1
		int nodeVisualID = getVisualID(semanticHint);
@


1.41
log
@#138696 Adapt VisualIDRegistry.javajet to use common expressions templates
@
text
@d162 1
a162 1
		for (Iterator labels = node.getLabels().iterator(); labels.hasNext() && !node.isListContainerEntry();) {
@


1.40
log
@Using "isSuperTypeOf" instead of EClasses comparision in Visual ID registry.
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* java.util.* org.eclipse.gmf.common.codegen.*"%>
d14 5
d351 5
d357 1
a357 1
for (Iterator it = genDiagram.eAllContents(); it.hasNext();) {
d368 1
a368 1
	if (modelFacet == null || modelFacet.getModelElementSelector() == null) {
d373 6
a381 3
	 * Element matching condition for <%=id%>.
	 * <pre>language: <%=selector.getLanguage()%></pre>	
	 * <pre>body    : <%=selector.getBody()%></pre>
d384 1
a384 1
	private static final Matcher <%=id%> = new Matcher("<%=selector.getBody()%>");
d386 1
a386 1
}
d393 1
a393 1
	static class Matcher {
d398 1
a398 11
		private EClass evalContext;
	
		/**
		 * @@generated	
		 */						
		private <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OCLConstraintCondition")%> condition;
	
		/**
		 * @@generated	
		 */						
		private String body;		
d403 2
a404 2
		Matcher(String expressionBody) {			
			body = expressionBody;
d410 3
a412 8
		boolean matches(EObject object) {		
			try {
				Boolean result = (object != null) ? evaluate(object) : Boolean.FALSE;
				return result.booleanValue();
			} catch(IllegalArgumentException e) {
				<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError(null, e);
				return false;
			}
d414 24
a437 29
	
		/**
		 * @@generated	
		 */		
		private Boolean evaluate(EObject context) {
			this.evalContext = context.eClass();
			if(condition == null) {					
				condition = new <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OCLConstraintCondition")%>(body, evalContext);
			}
			if(condition != null) {
				return booleanCast(condition.evaluate(context));
			}
			return Boolean.FALSE;
		}
	
		/**
		 * @@generated	
		 */					
		private static Boolean booleanCast(Object value) {
			if(value == null) {
				return null;
			} else if(value instanceof Boolean) {
				 return (Boolean)value;	
			}
			return Boolean.FALSE;
		}
	} // end of Matcher
<%}%>		

@


1.39
log
@#137999 Generate pure static VisualIDRegisrty classes
@
text
@d93 1
a93 1
	public static int getDiagramVisualID(EObject domainElement, EClass domainElementMetaclass) {
d99 1
a99 1
		if (<%=genDiagram.getMetaPackageName(importManager)%>.eINSTANCE.get<%=classifierAccessorName%>().equals(domainElementMetaclass) && (domainElement == null || isDiagram<%=genDiagram.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement))) {
d181 1
a181 1
			if ((semanticHint == null || <%=importManager.getImportedName(childNode.getEditPartQualifiedClassName())%>.VISUAL_ID == nodeVisualID) && <%=semanticPackageInterfaceName%>.eINSTANCE.get<%=classifierAccessorName%>().equals(domainElementMetaclass) && (domainElement == null || isNode<%=childNode.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement))) {
d231 1
a231 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(domainElementMetaclass) && (domainElement == null || isLinkWithClass<%=genLink.getUniqueIdentifier()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) domainElement))) {
@


1.38
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@a33 5
	public static final <%=genDiagram.getVisualIDRegistryClassName()%> INSTANCE = new <%=genDiagram.getVisualIDRegistryClassName()%>();
	
	/**
	 * @@generated
	 */
d82 1
a82 1
	public int getDiagramVisualID(EObject domainElement) {
d93 1
a93 1
	public int getDiagramVisualID(EObject domainElement, EClass domainElementMetaclass) {
d109 1
a109 1
	public int getNodeVisualID(View containerView, EObject domainElement) {
d120 1
a120 1
	public int getNodeVisualID(View containerView, EObject domainElement, EClass domainElementMetaclass, String semanticHint) {
d192 1
d196 2
a197 2
	for (Iterator linkLabels = link.getLabels().iterator(); linkLabels.hasNext();) {
		GenLinkLabel linkLabel = (GenLinkLabel) linkLabels.next();
d202 1
a202 1
<%	}%>
d204 2
a205 1
<%}%>
d213 1
a213 1
	public int getLinkWithClassVisualID(EObject domainElement) {
d221 1
a221 1
	public int getLinkWithClassVisualID(EObject domainElement, EClass domainElementMetaclass) {
d250 1
a250 1
	private boolean isDiagram<%=genDiagram.getUniqueIdentifier()%>(<%=importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName())%> element) {
d261 1
a261 1
	private int getUnrecognizedDiagramID(EObject domainElement) {
a264 1
String acceptAllMatcherAccessor = "acceptAllMatcher()"; //$NON-NLS-1$
d267 2
a268 2
	String qualifiedChildNodeInterfaceName = nextNode.getDomainMetaClass().getQualifiedInterfaceName();
	String childNodeSelector = nextNode.getModelFacet() != null && nextNode.getModelFacet().getModelElementSelector() != null ? nextNode.getUniqueIdentifier() : acceptAllMatcherAccessor;
d277 2
a278 2
	private boolean isNode<%=nextNode.getUniqueIdentifier()%>(<%=importManager.getImportedName(qualifiedChildNodeInterfaceName)%> element) {
		return ElementSelectors.<%=childNodeSelector%>.matches(element);
d292 1
a292 1
	private int getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(EObject domainElement, String semanticHint) {
d299 3
d310 1
a310 1
	private int getUnrecognized<%=link.getUniqueIdentifier()%>LinkLabelID(String semanticHint) {
d321 1
a321 1
	private int getUnrecognizedLinkWithClassID(EObject domainElement) {
d329 2
a330 2
		String qualifiedInterfaceName = modelFacet.getMetaClass().getQualifiedInterfaceName();
		String linkSelector = modelFacet.getModelElementSelector() != null ? genLink.getUniqueIdentifier() : acceptAllMatcherAccessor;		
d339 2
a340 2
	private boolean isLinkWithClass<%=genLink.getUniqueIdentifier()%>(<%=importManager.getImportedName(qualifiedInterfaceName)%> element) {
		return ElementSelectors.<%=linkSelector%>.matches(element);
a344 1
%>
a345 5
	/**
	 * @@generated
	 */
	private static class ElementSelectors {	
<%
d365 17
d383 14
a396 8
		 * Element matching condition for <%=id%>.
		 * <pre>language: <%=selector.getLanguage()%></pre>	
		 * <pre>body    : <%=selector.getBody()%></pre>
		 * @@generated
		 */
		private static final Matcher <%=id%> = new Matcher("<%=selector.getBody()%>");
<%}%>
		
d398 4
a401 3
		 * @@generated
		 */
		private ElementSelectors() {
d403 1
a403 1
<%if(selectorCounter > 0) { %>			
d405 9
a413 24
		* @@generated	
		*/
		static class Matcher {
	
			/**
			* @@generated	
			*/					
			private EClass evalContext;
	
			/**
			* @@generated	
			*/						
			private <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OCLConstraintCondition")%> condition;
	
			/**
			* @@generated	
			*/						
			private String body;		
					
			/**
			* @@generated	
			*/				
			Matcher(String expressionBody) {			
				body = expressionBody;
d415 1
d417 7
a423 11
			/**
			* @@generated	
			*/						
			boolean matches(EObject object) {		
				try {
					Boolean result = (object != null) ? evaluate(object) : Boolean.FALSE;
					return result.booleanValue();
				} catch(IllegalArgumentException e) {
					<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError(null, e);
					return false;
				}
d425 2
a426 13
	
			/**
			* @@generated	
			*/		
			private Boolean evaluate(EObject context) {
				this.evalContext = context.eClass();
				if(condition == null) {					
					condition = new <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OCLConstraintCondition")%>(body, evalContext);
				}
				if(condition != null) {
					return booleanCast(condition.evaluate(context));
				}
				return Boolean.FALSE;
d428 2
a430 13
			/**
			* @@generated	
			*/					
			private static Boolean booleanCast(Object value) {
				if(value == null) {
					return null;
				} else if(value instanceof Boolean) {
					 return (Boolean)value;	
				}
				return Boolean.FALSE;
			}
		} // end of Matcher
<%}%>		
d432 7
a438 12
		 * @@generated
		 */
		static class AcceptAllMatcher {
			/**
			 * @@generated
			 */		
			static final AcceptAllMatcher INSTANCE = new AcceptAllMatcher();
			/**
			 * @@generated
			 */					
			boolean matches(Object element) {
				return true;
d440 1
d442 3
a444 8
		
		/**
		 * @@generated
		 */		
		static AcceptAllMatcher acceptAllMatcher() {
			return AcceptAllMatcher.INSTANCE;
		}
	} // end of ElementSelectors
@


1.37
log
@#137185 Problems with visual ids of some elements
@
text
@d42 1
a42 1
				return <%=genDiagram.getVisualID()%>;
d47 1
a47 6
		try {
			return Integer.parseInt(view.getType());
		} catch (NumberFormatException e) {
			<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().logInfo("Unable to parse view type as a visualID number: " + view.getType());
		}
		return -1;
d64 20
a83 1
		
d105 1
a105 1
			return <%=genDiagram.getVisualID()%>;
d147 1
a147 1
				containerVisualID = <%=genDiagram.getVisualID()%>;		
d152 1
d158 1
a158 1
		case <%=nextContainer.getVisualID()%>:
d165 2
a166 2
			if (<%=importManager.getImportedName(label.getEditPartQualifiedClassName())%>.VISUAL_ID.equals(semanticHint)) {
				return <%=label.getVisualID()%>;
d173 2
a174 2
			if (<%=importManager.getImportedName(compartment.getEditPartQualifiedClassName())%>.VISUAL_ID.equals(semanticHint)) {
				return <%=compartment.getVisualID()%>;
d186 2
a187 2
			if ((semanticHint == null || <%=importManager.getImportedName(childNode.getEditPartQualifiedClassName())%>.VISUAL_ID.equals(semanticHint)) && <%=semanticPackageInterfaceName%>.eINSTANCE.get<%=classifierAccessorName%>().equals(domainElementMetaclass) && (domainElement == null || isNode<%=childNode.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement))) {
				return <%=childNode.getVisualID()%>;
d198 1
a198 1
		case <%=link.getVisualID()%>:
d203 2
a204 2
			if (<%=importManager.getImportedName(linkLabel.getEditPartQualifiedClassName())%>.VISUAL_ID.equals(semanticHint)) {
				return <%=linkLabel.getVisualID()%>;
d235 1
a235 1
			return <%=genLink.getVisualID()%>;
@


1.36
log
@#136863 NPE while deleting a number of elements on diagram
@
text
@d50 1
a50 1
			<%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError("Unable to parse view type as a visualID number: " + view.getType(), e);
@


1.35
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@d67 1
a67 1
		return diagram.getType();
@


1.34
log
@#125900 Redundant annotations added to View in generated view factory

Visual ID used as a semantic hint for creation of all the diagram elements.
@
text
@d31 3
d35 34
d113 1
a113 1
		if (!"<%=modelID%>".equals(containerModelID)
d129 1
a129 1
		if ("<%=modelID%>".equals(containerModelID)) {
a332 4
<%@@ include file="getModelID.jetinc" %>

<%@@ include file="getVisualID.jetinc" %>

@


1.33
log
@#129145 do not use intermediate TextCompartmentEditParts
@
text
@d53 1
a53 1
		if (<%=genDiagram.getMetaPackageName(importManager)%>.eINSTANCE.get<%=classifierAccessorName%>().equals(domainElementMetaclass) && (domainElement != null ? isDiagram<%=genDiagram.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement) : true)) {
d63 1
a63 1
	public int getNodeVisualID(View containerView, EObject domainElement, String semanticHint) {
d68 1
a68 1
		return getNodeVisualID(containerView, domainElement, domainElementMetaclass, semanticHint);
d110 1
a110 2
		String semanticHintsClassName = importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName());
		for (Iterator labels = node.getLabels().iterator(); labels.hasNext();) {
a111 1
			String labelViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Labels." + label.getSemanticHintFieldName();
d113 1
a113 1
			if (<%=labelViewId%>.equals(semanticHint)) {
a119 1
			String compartmentViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Compartments." + compartment.getSemanticHintFieldName();
d121 1
a121 1
			if (<%=compartmentViewId%>.equals(semanticHint)) {
d127 1
a127 5
%>
			if (semanticHint != null && !"".equals(semanticHint)) {
				return getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(semanticHint);
			} 
<%	
d134 1
a134 1
			if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=classifierAccessorName%>().equals(domainElementMetaclass) && (domainElement != null ? isNode<%=childNode.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement) : true)) {
d140 1
a140 1
			return getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(domainElement);
a144 1
	String semanticHintsClassName = importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName());
a149 1
		String labelViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + linkLabel.getSemanticHintFieldName();
d151 1
a151 1
			if (<%=labelViewId%>.equals(semanticHint)) {
d182 1
a182 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(domainElementMetaclass) && (domainElement != null ? isLinkWithClass<%=genLink.getUniqueIdentifier()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) domainElement) : true)) {
d244 1
a244 11
	private int getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(String semanticHint) {
		return -1;
	}

	/**
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
	 * @@generated
	 */	
	private int getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(EObject domainElement) {
@


1.32
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d21 1
a21 1
	
d113 1
a113 2
			if (label instanceof ExternalLabel) {
				String labelViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Labels." + ((ExternalLabel) label).getSemanticHintLabelFieldName();
a118 8
			} else {
				String labelTextViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Labels." + label.getSemanticHintFieldName();
%>
			if (<%=labelTextViewId%>.equals(semanticHint)) {
				return <%=label.getVisualID()%>;
			}  
<%
			}
d122 1
a122 1
			String compartmentId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Compartments." + compartment.getSemanticHintFieldName();
d124 1
a124 1
			if (<%=compartmentId%>.equals(semanticHint)) {
a148 17
	if (nextContainer instanceof GenNode) {
		GenNode node = (GenNode) nextContainer;
		String semanticHintsClassName = importManager.getImportedName(genDiagram.getSemanticHintsQualifiedClassName());
		for (Iterator labels = node.getLabels().iterator(); labels.hasNext();) {
			GenNodeLabel label = (GenNodeLabel) labels.next();
			if (label instanceof ExternalLabel) {
				String labelTextViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Labels." + label.getSemanticHintFieldName();
%>
		case <%=label.getVisualID()%>:
			if (<%=labelTextViewId%>.equals(semanticHint)) {
				return <%=label.getVisualID()%>;
			}
			return -1;
<%
			}
		}
	}
d158 1
a158 1
		String labelViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + linkLabel.getSemanticHintLabelFieldName();
d163 1
a163 3
<%
	}
%>
d165 1
a165 14
<%
	for (Iterator linkLabels = link.getLabels().iterator(); linkLabels.hasNext();) {
		GenLinkLabel linkLabel = (GenLinkLabel) linkLabels.next();
		String labelTextViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + linkLabel.getSemanticHintFieldName();
%>
		case <%=linkLabel.getVisualID()%>:
			if (<%=labelTextViewId%>.equals(semanticHint)) {
				return <%=linkLabel.getVisualID()%>;
			}
			return getUnrecognized<%=link.getUniqueIdentifier()%>LinkLabelTextID(semanticHint);
<%
	}
}
%>
a242 3
%>

<%
a267 1

d281 1
a281 3
<%
	if (link.getLabels().size() > 0) {
%>
a287 14
	 */	
	private int getUnrecognized<%=link.getUniqueIdentifier()%>LinkLabelTextID(String semanticHint) {
		return -1;
	}
<%
	}
}
%>
		
	/**
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
	 * @@generated
@


1.31
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@d9 3
a11 2

importManager.emitPackageStatement(stringBuffer);%>
@


1.30
log
@[rdvorak] #128087 - Migrate to EMFT OCL API changes - #125458, 125684
@
text
@d48 1
a48 1
{
d55 1
a56 3
<%
}
%>
d242 2
a243 1
	
d253 1
@


1.29
log
@[rdvorak] #127700 Rename genmodel::ModelElementSelector as a generic GenConstraint element
@
text
@d431 1
a431 1
			private <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OclConstraintCondition")%> condition;
d464 1
a464 1
					condition = new <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OclConstraintCondition")%>(body, evalContext);
@


1.28
log
@Rollback. Sources should be compatible with stable build of EMFT.
@
text
@d399 1
a399 1
	ModelElementSelector selector = modelFacet.getModelElementSelector();
@


1.27
log
@#127497 Creating diagram file by InitDiagramFileAction in arbitrary location
+ correcting the case of OCL-related classes
@
text
@d431 1
a431 1
			private <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OCLConstraintCondition")%> condition;
d464 1
a464 1
					condition = new <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OCLConstraintCondition")%>(body, evalContext);
@


1.26
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d431 1
a431 1
			private <%=importManager.getImportedName("org.eclipse.emf.query.ocl.conditions.OclConstraintCondition")%> condition;
d464 1
a464 1
					condition = new OclConstraintCondition(body, evalContext);
@


1.25
log
@GenEditorViewer incapsulates all Eclipse's IEditorPart-related info
@
text
@d4 1
a4 1
final GenDiagram genDiagram = (GenDiagram) argument;
d6 5
a10 4
List genLinks = genDiagram.getLinks();
Collection allContainers = genDiagram.getAllContainers();
%>
package <%=genDiagram.getEditorGen().getEditor().getPackageName()%>;
a12 2
ImportUtil importManager = new ImportUtil(genDiagram.getEditorGen().getEditor().getPackageName());

@


1.24
log
@constant used throughout templates to identify diagram (genModel.getModelName) was extracted as explicit attribute
packagePrefix added
@
text
@d9 1
a9 1
package <%=genDiagram.getEditorPackageName()%>;
d12 1
a12 1
ImportUtil importManager = new ImportUtil(genDiagram.getEditorPackageName());
@


1.23
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d5 1
a5 1
final String modelID = genDiagram.getEditorGen().getDomainGenModel().getModelName();
@


1.22
log
@ImportManager moved to oeg.common
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.emf.codegen.ecore.genmodel.* java.util.* org.eclipse.gmf.common.codegen.*"%>
d4 2
a5 1
GenDiagram genDiagram = (GenDiagram) argument;
a48 2
GenPackage genPackage = genDiagram.getDomainMetaModel();
String semanticPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
d53 1
a53 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=classifierAccessorName%>().equals(domainElementMetaclass) && (domainElement != null ? isDiagram<%=genDiagram.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement) : true)) {
d78 1
a78 1
		if (!"<%=genDiagram.getEMFGenModel().getModelName()%>".equals(containerModelID)
d82 1
a82 1
	if (genDiagram.getEMFGenModel().getModelName().equals(nextDomainModelName)) {
d94 1
a94 1
		if ("<%=genDiagram.getEMFGenModel().getModelName()%>".equals(containerModelID)) {
d148 3
a150 2
		String classifierAccessorName = childNode.getDomainMetaClass().getClassifierAccessorName();
		String interfaceName = importManager.getImportedName(childNode.getDomainMetaClass().getQualifiedInterfaceName());
d229 4
a232 3
		TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) genLink.getModelFacet();
		String semanticLinkInterfaceName = modelFacet.getMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = modelFacet.getMetaClass().getQualifiedInterfaceName();
d454 1
a454 1
					<%=importManager.getImportedName(genDiagram.getPlugin().getActivatorQualifiedClassName())%>.getInstance().logError(null, e);
@


1.21
log
@#125893
Logging methods
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.emf.codegen.ecore.genmodel.* java.util.* org.eclipse.gmf.codegen.util.*"%>
@


1.20
log
@rename GenContainerEditPart -> GenContainerBase
@
text
@d453 1
a453 2
					// TODO - add log entry
					e.printStackTrace();
@


1.19
log
@Null could be passed as a semantic hint.
@
text
@d6 1
a6 1
Collection allContainers = genDiagram.getAllContainerEditParts();
d107 1
a107 1
	GenContainerEditPart nextContainer = (GenContainerEditPart) containers.next();
d287 1
a287 1
	GenContainerEditPart nextContainer = (GenContainerEditPart) containers.next();
@


1.18
log
@#124413
Cleaning up the gmfgen model
@
text
@d143 1
a143 1
			if (!"".equals(semanticHint)) {
@


1.17
log
@#124413
Allowing infinite hierarchy of GenChildNodes
@
text
@d6 1
a6 2
Collection allContainers = new LinkedList(genDiagram.getAllContainers());
allContainers.add(genDiagram);
@


1.16
log
@#114178
Create shortcut functionality added
@
text
@a4 1
List genNodes = genDiagram.getNodes();
d6 2
a7 1
Collection allContainers = AccessUtil.getAllContainers(genDiagram);
a105 14
		case <%=genDiagram.getVisualID()%>:
<%
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	String classifierAccessorName = genNode.getDomainMetaClass().getClassifierAccessorName();
	String interfaceName = importManager.getImportedName(genNode.getDomainMetaClass().getQualifiedInterfaceName());
%>
			if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=classifierAccessorName%>().equals(domainElementMetaclass) && (domainElement != null ? isNode<%=genNode.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement) : true)) {
				return <%=genNode.getVisualID()%>;
			} 
<%
}
%>
			return getUnrecognizedDiagramChildID(domainElement);
d108 1
a108 1
	GenChildContainer nextContainer = (GenChildContainer) containers.next();
d148 1
a148 1
	for (Iterator childNodes = nextContainer.getChildNodes().iterator(); childNodes.hasNext();) {
d153 1
a153 1
			if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=classifierAccessorName%>().equals(domainElementMetaclass) && (domainElement != null ? isChildNode<%=childNode.getUniqueIdentifier()%>((<%=interfaceName%>) domainElement) : true)) {
d267 4
a270 24
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	String qualifiedNodeInterfaceName = genNode.getDomainMetaClass().getQualifiedInterfaceName();
	String nodeSelector = genNode.getModelFacet() != null && genNode.getModelFacet().getModelElementSelector() != null ? genNode.getUniqueIdentifier() : acceptAllMatcherAccessor;
%>

	/**
	 * User can change implementation of this method to check some additional 
	 * conditions here.
	 *
	 * @@generated
	 */
	private boolean isNode<%=genNode.getUniqueIdentifier()%>(<%=importManager.getImportedName(qualifiedNodeInterfaceName)%> element) {
		return ElementSelectors.<%=nodeSelector%>.matches(element);
	}
<%
}

for (Iterator containers = allContainers.iterator(); containers.hasNext();) {
	GenChildContainer nextContainer = (GenChildContainer) containers.next();
	for (Iterator childNodes = nextContainer.getChildNodes().iterator(); childNodes.hasNext();) {
		GenChildNode nextChildNode = (GenChildNode) childNodes.next();
		String qualifiedChildNodeInterfaceName = nextChildNode.getDomainMetaClass().getQualifiedInterfaceName();
		String childNodeSelector = nextChildNode.getModelFacet() != null && nextChildNode.getModelFacet().getModelElementSelector() != null ? nextChildNode.getUniqueIdentifier() : acceptAllMatcherAccessor;
d279 1
a279 1
	private boolean isChildNode<%=nextChildNode.getUniqueIdentifier()%>(<%=importManager.getImportedName(qualifiedChildNodeInterfaceName)%> element) {
a282 1
	}
a285 9
	/**
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
	 * @@generated
	 */	
	private int getUnrecognizedDiagramChildID(EObject domainElement) {
		return -1;
	}
d288 1
a288 1
	GenChildContainer nextContainer = (GenChildContainer) containers.next();
d297 1
a297 1
	private int getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(EObject domainElement) {
d300 1
a300 1
	
d307 1
a307 1
	private int getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(String semanticHint) {
@


1.15
log
@#122054 support external node labels (partial fix)
@
text
@d17 1
d79 26
a104 1
		int containerVisualID = getVisualID(containerView);
d420 2
@


1.14
log
@#121581
Fields for the compartments are named unique.
@
text
@d105 9
a113 1
			String labelTextViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Labels." + label.getSemanticHintFieldName();
d118 2
a119 1
<%			
d149 17
@


1.13
log
@#118053
Infinite child mapping hierarchy in .gmfmap
@
text
@d105 1
a105 1
			String labelTextViewId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Labels." + AccessUtil.getLabelTextId(label);
d114 1
a114 1
			String compartmentId = semanticHintsClassName + '.' + node.getUniqueIdentifier() + "Compartments." + AccessUtil.getCompartmentId(compartment);
d149 1
a149 1
		String labelViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + AccessUtil.getLabelId(linkLabel);
d161 1
a161 1
		String labelTextViewId = semanticHintsClassName + '.' + link.getUniqueIdentifier() + "Labels." + AccessUtil.getLabelTextId(linkLabel);
@


1.12
log
@#116622
Supporting infinite ChildNode hierarchy in InitDiagramFileAction
@
text
@d245 8
a252 5
	List genChildNodes = AccessUtil.getAllChildNodes(genNode);
	for (int j = 0; j < genChildNodes.size(); j++) {
		GenChildNode genChildNode = (GenChildNode) genChildNodes.get(j);
		String qualifiedChildNodeInterfaceName = genChildNode.getDomainMetaClass().getQualifiedInterfaceName();
		String childNodeSelector = genChildNode.getModelFacet() != null && genChildNode.getModelFacet().getModelElementSelector() != null ? genChildNode.getUniqueIdentifier() : acceptAllMatcherAccessor;
d261 1
a261 1
	private boolean isChildNode<%=genChildNode.getUniqueIdentifier()%>(<%=importManager.getImportedName(qualifiedChildNodeInterfaceName)%> element) {
d263 2
a265 2

<%	}
@


1.11
log
@#116031 avoid hardcoded class names in templates
@
text
@d7 1
a9 3
<%ImportUtil importManager = new ImportUtil(genDiagram.getEditorPackageName());%>
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
d11 9
a19 2
import org.eclipse.gmf.runtime.notation.View;
<%importManager.markImportLocation(stringBuffer);%>
a63 3
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
d66 6
a71 2
	private int getUnrecognizedDiagramID(EObject domainElement) {
		return -1;
d73 1
a73 5

//================================================================================================================
<%
Collection allContainers = AccessUtil.getAllContainers(genDiagram);
%>
a175 2
<%@@ include file="getVisualID.jetinc" %>

d178 4
a181 3
	 */	
	private int getUnrecognizedDiagramChildID(EObject domainElement) {
		return -1;
d183 5
a187 1
	
d189 6
a194 2
for (Iterator containers = allContainers.iterator(); containers.hasNext();) {
	GenChildContainer nextContainer = (GenChildContainer) containers.next();
d196 5
a200 8
	/**
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
	 *
	 * @@generated
	 */	
	private int getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(EObject domainElement) {
		return -1;
d202 5
d209 2
a210 2
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
d213 3
a215 3
	 */	
	private int getUnrecognized<%=nextContainer.getUniqueIdentifier()%>ChildNodeID(String semanticHint) {
		return -1;
a216 3
	
<%
}
a217 3
for (Iterator links = genLinks.iterator(); links.hasNext();) {
	GenLink link = (GenLink) links.next();
%>
d223 2
a224 2
	 */	
	private int getUnrecognized<%=link.getUniqueIdentifier()%>LinkLabelID(String semanticHint) {
d227 7
d236 2
a237 2
	 * User can change implementation of this method to handle some specific
	 * situations not covered by default logic.
d240 3
a242 3
	 */	
	private int getUnrecognized<%=link.getUniqueIdentifier()%>LinkLabelTextID(String semanticHint) {
		return -1;
d245 5
a249 1
}
a250 2
	
//================================================================================================================
d253 3
a255 1
	 * @@deprecated
d258 2
a259 3
	public int getNodeVisualID(EObject domainElement) {
		EClass domainElementMetaclass = domainElement.eClass();
		return getNodeVisualID(domainElement, domainElementMetaclass);
d262 1
a262 16

	/**
	 * @@deprecated
	 * @@generated
	 */
	public int getNodeVisualID(EObject domainElement, EClass domainElementMetaclass) {
<%
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	String semanticNodeInterfaceName = genNode.getDomainMetaClass().getClassifierAccessorName();
	String qualifiedInterfaceName = genNode.getDomainMetaClass().getQualifiedInterfaceName();
%>
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticNodeInterfaceName%>().equals(domainElementMetaclass) && (domainElement != null ? isNode<%=genNode.getUniqueIdentifier()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) domainElement) : true)) {
			return <%=genNode.getVisualID()%>;
		} else
<%
d265 1
a265 5
		{
			return getUnrecognizedNodeID(domainElement);
		}
	}
		
d271 2
a272 2
	 */
	private int getUnrecognizedNodeID(EObject domainElement) {
d275 4
d281 3
d285 3
a287 4
	 */
	public int getChildNodeVisualID(EObject domainElement) {
		EClass domainElementMetaclass = domainElement.eClass();
		return getChildNodeVisualID(domainElement, domainElementMetaclass);
d291 3
d295 4
a298 2
	 */
	public int getChildNodeVisualID(EObject domainElement, EClass domainElementMetaclass) {
a299 12
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	List genChildNodes = AccessUtil.getAllChildNodes(genNode);
	for (int j = 0; j < genChildNodes.size(); j++) {
		GenChildNode genChildNode = (GenChildNode) genChildNodes.get(j);
		String semanticChildNodeInterfaceName = genChildNode.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genChildNode.getDomainMetaClass().getQualifiedInterfaceName();
%>
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticChildNodeInterfaceName%>().equals(domainElementMetaclass) && (domainElement != null ? isChildNode<%=genChildNode.getUniqueIdentifier()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) domainElement) : true)) {
			return <%=genChildNode.getVisualID()%>;
		} else 
<%	}
d301 3
d305 1
a305 5
		{
			return getUnrecognizedChildNodeID(domainElement);
		}
	}
		
d311 2
a312 2
	 */
	private int getUnrecognizedChildNodeID(EObject domainElement) {
d315 3
d320 3
d324 3
a326 4
	 */
	public int getLinkWithClassVisualID(EObject domainElement) {
		EClass domainElementMetaclass = domainElement.eClass();
		return getLinkWithClassVisualID(domainElement, domainElementMetaclass);
a327 16
		
	/**
	 * @@generated
	 */
	public int getLinkWithClassVisualID(EObject domainElement, EClass domainElementMetaclass) {
<%
for (int i = 0; i < genLinks.size(); i++) {
	GenLink genLink = (GenLink) genLinks.get(i);
	if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
		TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) genLink.getModelFacet();
		String semanticLinkInterfaceName = modelFacet.getMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = modelFacet.getMetaClass().getQualifiedInterfaceName();
%>
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(domainElementMetaclass) && (domainElement != null ? isLinkWithClass<%=genLink.getUniqueIdentifier()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) domainElement) : true)) {
			return <%=genLink.getVisualID()%>;
		} else 
a328 1
		}
d330 1
a331 4
		{
			return getUnrecognizedLinkWithClassID(domainElement);
		}
	}
a341 46
		
	/**
	 * User can change implementation of this method to check some additional conditions here.
	 *
	 * @@generated
	 */
	private boolean isDiagram<%=genDiagram.getUniqueIdentifier()%>(<%=importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName())%> element) {
		return true;
	}
		
<%
String acceptAllMatcherAccessor = "acceptAllMatcher()"; //$NON-NLS-1$
for (int i = 0; i < genNodes.size(); i++) {
	GenNode genNode = (GenNode) genNodes.get(i);
	String qualifiedNodeInterfaceName = genNode.getDomainMetaClass().getQualifiedInterfaceName();
	String nodeSelector = genNode.getModelFacet() != null && genNode.getModelFacet().getModelElementSelector() != null ? genNode.getUniqueIdentifier() : acceptAllMatcherAccessor;
%>
	/**
	 * User can change implementation of this method to check some additional conditions here.
	 *
	 * @@generated
	 */
	private boolean isNode<%=genNode.getUniqueIdentifier()%>(<%=importManager.getImportedName(qualifiedNodeInterfaceName)%> element) {
		return ElementSelectors.<%=nodeSelector%>.matches(element);
	}

<%
	List genChildNodes = AccessUtil.getAllChildNodes(genNode);
	for (int j = 0; j < genChildNodes.size(); j++) {
		GenChildNode genChildNode = (GenChildNode) genChildNodes.get(j);
		String qualifiedChildNodeInterfaceName = genChildNode.getDomainMetaClass().getQualifiedInterfaceName();
		String childNodeSelector = genChildNode.getModelFacet() != null && genChildNode.getModelFacet().getModelElementSelector() != null ? genChildNode.getUniqueIdentifier() : acceptAllMatcherAccessor;
%>
	/**
	 * User can change implementation of this method to check some additional conditions here.
	 *
	 * @@generated
	 */
	private boolean isChildNode<%=genChildNode.getUniqueIdentifier()%>(<%=importManager.getImportedName(qualifiedChildNodeInterfaceName)%> element) {
		return ElementSelectors.<%=childNodeSelector%>.matches(element);
	}

<%	}
}
%>
	
d350 1
d352 2
a353 1
	 * User can change implementation of this method to check some additional conditions here.
d365 2
@


1.10
log
@#115972 generate single class with semantic hints
@
text
@d23 1
a23 1
public class VisualIDRegistry {
d25 1
a25 1
	public static final VisualIDRegistry INSTANCE = new VisualIDRegistry();
@


1.9
log
@#115622 use genDiagram.eAllContents() to iterate over diagram contents instead of using custom iterator
@
text
@d100 1
a100 2
		String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(node);
			
a101 1
			String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d103 1
a103 1
			String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelTextId(label);
a109 1
		
a110 1
			String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d112 1
a112 1
			String compartmentId = semanticHintsClassName + ".Compartments." + AccessUtil.getCompartmentId(compartment);
a138 1

d141 1
a141 1
	String semanticHintsQualifiedClassName = genDiagram.getProvidersPackageName() + '.' + AccessUtil.getSemanticHintsClassName(link);
a145 1
		String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d147 1
a147 1
		String labelViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelId(linkLabel);
a157 1
		String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d159 1
a159 1
		String labelTextViewId = semanticHintsClassName + ".Labels." + AccessUtil.getLabelTextId(linkLabel);
@


1.8
log
@[ashatalin] #115625 fixes compilation problems with initializers
@
text
@d443 3
a445 2
for(Iterator it = AccessUtil.getGenEntities(genDiagram); it.hasNext();) {
	GenCommonBase nextElement = (GenCommonBase)it.next();
d447 10
a456 8
	if(nextElement instanceof GenNode) {
		modelFacet = ((GenNode)nextElement).getModelFacet();
	} else if(nextElement instanceof GenLink && 
		((GenLink)nextElement).getModelFacet() instanceof TypeLinkModelFacet) {
		modelFacet = (TypeLinkModelFacet)((GenLink)nextElement).getModelFacet();
	} 
	
	if(modelFacet == null || modelFacet.getModelElementSelector() == null) continue;
d459 2
a460 1
	%>
d462 1
a462 1
		 * Element matching condition for <%=nextElement.getUniqueIdentifier()%>.
d467 1
a467 1
		private static final Matcher <%=nextElement.getUniqueIdentifier()%> = new Matcher("<%=selector.getBody()%>");
@


1.7
log
@[ashatalin] #114750 annotate diagram runtime model elements with visual id to tell one from another during EP decision making
@
text
@d101 1
a101 2
		String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
		
d103 1
d114 1
a146 1
	String semanticHintsClassName = importManager.getImportedName(semanticHintsQualifiedClassName);
d151 1
d164 1
@


1.6
log
@[ashatalin] #113892 flexible compartment hierarchy
@
text
@d6 1
d13 1
d31 3
d45 3
d49 1
a49 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=genDiagram.getDomainDiagramElement().getClassifierAccessorName()%>().equals(domainElementMetaclass) && (domainElement != null ? isDiagram<%=genDiagram.getUniqueIdentifier()%>((<%=importManager.getImportedName(genDiagram.getDomainDiagramElement().getQualifiedInterfaceName())%>) domainElement) : true)) {
d53 3
d68 4
d75 172
d250 1
a251 1
	}
d254 1
a339 1
List genLinks = genDiagram.getLinks();
@


1.5
log
@[rdvorak] #113856 refactor features left in GenBaseElement to TypeModelFacet
@
text
@d112 1
a112 1
	List genChildNodes = genNode.getChildNodes();
d208 1
a208 1
	List genChildNodes = genNode.getChildNodes();
@


1.4
log
@[rdvorak] #113647 refactoring selectors and initializers
@
text
@d196 1
a196 1
	String nodeSelector = genNode.getModelElementSelector() != null ? genNode.getUniqueIdentifier() : acceptAllMatcherAccessor;
d212 1
a212 1
		String childNodeSelector = genChildNode.getModelElementSelector() != null ? genChildNode.getUniqueIdentifier() : acceptAllMatcherAccessor;
d233 1
a233 1
		String linkSelector = genLink.getModelElementSelector() != null ? genLink.getUniqueIdentifier() : acceptAllMatcherAccessor;		
d256 10
a265 5
	GenBaseElement  genElement = nextElement instanceof GenBaseElement ? (GenBaseElement) nextElement : null;
	if(genElement == null || genElement.getModelElementSelector() == null) continue;	
		
	ModelElementSelector selector = genElement.getModelElementSelector();
	if(selector.getBody() == null) continue;
@


1.3
log
@[dstadnik] #113525 Get rid of LinkWithClass/LinkWithReference, use parallel hierarchy of modelFacet instead
@
text
@d192 1
d196 1
d204 1
a204 1
		return <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genNode)%>(element);
d212 1
d220 1
a220 1
		return <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genChildNode)%>(element);
d233 1
d241 1
a241 1
		return <%=importManager.getImportedName(PartSelectorUtil.getPartSelectorsFullClassName(genDiagram)) + "." + PartSelectorUtil.getPartSelectorMethodName(genLink)%>(element);
d247 114
d362 7
@


1.2
log
@[ashatalin] #112664 Create links w/o dedicated domain metaelement during initial filling of diagram file
@
text
@d1 2
a2 1
<%@@ jet package="org.eclipse.gmf.codegen.templates.editor" class="VisualIDRegistry" imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.emf.codegen.ecore.genmodel.* java.util.* org.eclipse.gmf.codegen.util.ImportUtil org.eclipse.gmf.codegen.util.PartSelectorUtil"%>
d155 4
a158 4
	if (genLink instanceof GenLinkWithClass) {
		GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
		String qualifiedInterfaceName = genLinkWithClass.getDomainMetaClass().getQualifiedInterfaceName();
d160 1
a160 1
		if (<%=semanticPackageInterfaceName%>.eINSTANCE.get<%=semanticLinkInterfaceName%>().equals(domainElementMetaclass) && (domainElement != null ? isLinkWithClass<%=genLinkWithClass.getUniqueIdentifier()%>((<%=importManager.getImportedName(qualifiedInterfaceName)%>) domainElement) : true)) {
d227 3
a229 3
	if (genLink instanceof GenLinkWithClass) {
		GenLinkWithClass genLinkWithClass = (GenLinkWithClass) genLink;
		String qualifiedInterfaceName = genLinkWithClass.getDomainMetaClass().getQualifiedInterfaceName();
d236 1
a236 1
	private boolean isLinkWithClass<%=genLinkWithClass.getUniqueIdentifier()%>(<%=importManager.getImportedName(qualifiedInterfaceName)%> element) {
@


1.1
log
@[ashatalin] #112122 Action to initialize diagram for domain model.
 unique id introduced, refactoring to use it throughout the code
@
text
@a192 1
	String semanticNodeInterfaceName = genNode.getDomainMetaClass().getClassifierAccessorName();
a207 1
		String semanticChildNodeInterfaceName = genChildNode.getDomainMetaClass().getClassifierAccessorName();
a227 1
		String semanticLinkInterfaceName = genLinkWithClass.getDomainMetaClass().getClassifierAccessorName();
@

