head	1.17;
access;
symbols
	v20081022-1925:1.17
	v20081015-1925:1.17
	v20081008-1925:1.17
	v20081001-1925:1.17
	v20080924-1925:1.17
	v20080917-1925:1.17
	v20080911-1728:1.17
	v20080910-1520:1.17
	v20080903-1520:1.17
	v20080827-1520:1.17
	v20080813-1520:1.17
	v20080806-1520:1.17
	v20070202-0200:1.16
	v20061027-1200:1.16
	v20061020-1000:1.16
	v20060919-0800:1.16
	v20060907-1100:1.16
	M1_20:1.16
	v20060904-1500:1.16
	v20060824-1600:1.16
	v20060817-1500:1.16
	v20060728-0500:1.16
	v20060713-1700:1.16
	R1_0_maintenance:1.16.0.2
	R1_0:1.16
	v20060627-1200:1.16
	v20060626-1420:1.16
	v20060620-0400:1.16
	v20060616-1400:1.16
	v20060616-1200:1.16
	v20060609-1400:1.16
	v20060531-1730:1.15
	v20060530-1930:1.15
	v20060526-1200:1.14
	v20060519-1300:1.14
	v20060519-0800:1.14
	v20060512-1000:1.12
	I20060512-1000:1.12
	I20060505-1400:1.12
	I20060428-1300:1.12
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.12
	I20060407-1200:1.9
	I20060331-1000:1.8
	I20060324-0300:1.8
	I20060317-1300:1.8
	I20060317-1200:1.8
	I20060316-1300:1.8
	I20060309-1300:1.8
	M5_10:1.7
	S20060303-1600:1.7
	I20060227-1730:1.6
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.4
	I20060202-1415:1.4
	I20060129-1145:1.4
	I20060127-0900:1.4
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.4
	I20051223-1100:1.4
	I20051217-0925:1.4
	I20051208-2000:1.4
	I20051201-1800:1.3
	I20051124-2000:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.17
date	2006.09.26.15.41.04;	author atikhomirov;	state dead;
branches;
next	1.16;

1.16
date	2006.06.01.09.14.34;	author dstadnik;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.29.18.20.56;	author ashatalin;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.18.14.03.44;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.08.17.19.56;	author ashatalin;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.08.16.56.36;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.08.11.41.49;	author dstadnik;	state dead;
branches;
next	1.9;

1.9
date	2006.04.07.14.49.25;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.07.15.45.27;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.03.13.22.36;	author dstadnik;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.08.17.15.39;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.05.22.57.53;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.05.18.48.06;	author ashatalin;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.25.12.21.56;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.24.11.09.27;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.21.09.35.37;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.17
log
@do not generate GraphicalNodeEditPolicy unless there's smth for it to do
@
text
@package org.eclipse.gmf.codegen.templates.policies;

import java.util.*;
import org.eclipse.emf.codegen.ecore.genmodel.*;
import org.eclipse.gmf.codegen.gmfgen.*;
import org.eclipse.gmf.common.codegen.*;

public class NodeGraphicalNodeEditPolicyGenerator
{
  protected static String nl;
  public static synchronized NodeGraphicalNodeEditPolicyGenerator create(String lineSeparator)
  {
    nl = lineSeparator;
    NodeGraphicalNodeEditPolicyGenerator result = new NodeGraphicalNodeEditPolicyGenerator();
    nl = null;
    return result;
  }

  protected final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + "/*" + NL + " *";
  protected final String TEXT_3 = NL + " */";
  protected final String TEXT_4 = NL;
  protected final String TEXT_5 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_6 = " extends ";
  protected final String TEXT_7 = " {";
  protected final String TEXT_8 = NL + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ";
  protected final String TEXT_9 = " getConnectionCompleteCommand(" + NL + "\t\t\t";
  protected final String TEXT_10 = " request) {" + NL + "\t\t";
  protected final String TEXT_11 = " elementType = getElementType(request);";
  protected final String TEXT_12 = NL + "\t\tif (";
  protected final String TEXT_13 = ".";
  protected final String TEXT_14 = " == elementType) {" + NL + "\t\t\treturn getConnectionWithReorientedViewCompleteCommand(request);" + NL + "\t\t}";
  protected final String TEXT_15 = NL + "\t\treturn super.getConnectionCompleteCommand(request);" + NL + "\t}";
  protected final String TEXT_16 = NL + "}";
  protected final String TEXT_17 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    
final GenNode genNode = (GenNode) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
GenDiagram genDiagram = genNode.getDiagram();

    stringBuffer.append(TEXT_1);
    
String copyrightText = genDiagram.getEditorGen().getCopyrightText();
if (copyrightText != null && copyrightText.trim().length() > 0) {

    stringBuffer.append(TEXT_2);
    stringBuffer.append(copyrightText.replaceAll("\n", "\n *"));
    stringBuffer.append(TEXT_3);
    }
    importManager.emitPackageStatement(stringBuffer);
    stringBuffer.append(TEXT_4);
    importManager.markImportLocation(stringBuffer);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(genNode.getGraphicalNodeEditPolicyClassName());
    stringBuffer.append(TEXT_6);
    stringBuffer.append(importManager.getImportedName(genDiagram.getBaseGraphicalNodeEditPolicyQualifiedClassName()));
    stringBuffer.append(TEXT_7);
    
Set ids = new HashSet();
for (Iterator links = genDiagram.getLinks().iterator(); links.hasNext(); ) {
	GenLink genLink = (GenLink) links.next();
	if (!genLink.isViewDirectionAlignedWithModel() || genLink.getModelFacet() == null) {
		continue;
	}
	GenClass incomingClass;
	GenClass outgoingClass;
	if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
		TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) genLink.getModelFacet();
		outgoingClass = modelFacet.getSourceMetaFeature() == null
			? modelFacet.getContainmentMetaFeature().getGenClass()
			: modelFacet.getSourceMetaFeature().getTypeGenClass();
		incomingClass = modelFacet.getTargetMetaFeature().getTypeGenClass();
	} else if (genLink.getModelFacet() instanceof FeatureModelFacet) {
		GenFeature metaFeature = ((FeatureModelFacet) genLink.getModelFacet()).getMetaFeature();
		outgoingClass = metaFeature.getGenClass();
		incomingClass = metaFeature.getTypeGenClass();
	} else {
		continue;
	}
	if (genNode.getModelFacet() == null) {
		continue;
	}
	GenClass nodeMetaClass = genNode.getModelFacet().getMetaClass();
	boolean canBeSource = outgoingClass.getEcoreClass().isSuperTypeOf(nodeMetaClass.getEcoreClass());
	boolean canBeTarget = incomingClass.getEcoreClass().isSuperTypeOf(nodeMetaClass.getEcoreClass());
/*
 * This logic is currently alligned with the logic in NodeItemSemanticEditPolicy.javajet i.e.:
 *
 * - we do not perform link rotation if this link could be drawn from instance of this EP 
 *   to the instance of this EP.
 *
 * - if link could be created in "opposite" direction (genLink.isIncomingCreationAllowed() == true)
 *   and this EP could be only a source of the link then we should reverse link at the end of link 
 *   creation
 *
 */
	if (canBeSource && canBeTarget) {
		continue;
	}
	if (genLink.isIncomingCreationAllowed() && canBeSource) {
		ids.add(genLink.getUniqueIdentifier());
	}
}
if (!ids.isEmpty()) {

    stringBuffer.append(TEXT_8);
    stringBuffer.append(importManager.getImportedName("org.eclipse.gef.commands.Command"));
    stringBuffer.append(TEXT_9);
    stringBuffer.append(importManager.getImportedName("org.eclipse.gef.requests.CreateConnectionRequest"));
    stringBuffer.append(TEXT_10);
    stringBuffer.append(importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType"));
    stringBuffer.append(TEXT_11);
    	for (Iterator it = ids.iterator(); it.hasNext();) {
    stringBuffer.append(TEXT_12);
    stringBuffer.append(importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName()));
    stringBuffer.append(TEXT_13);
    stringBuffer.append((String) it.next());
    stringBuffer.append(TEXT_14);
    	}
    stringBuffer.append(TEXT_15);
    }
    stringBuffer.append(TEXT_16);
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_17);
    return stringBuffer.toString();
  }
}
@


1.16
log
@header comment should not be a javadoc comment
@
text
@@


1.15
log
@Correcting copyright processing
@
text
@d21 1
a21 1
  protected final String TEXT_2 = NL + "/**" + NL + " *";
@


1.14
log
@#114175 Allow a diagram definition to be mapped to zero or more domain models.
@
text
@d21 1
a21 1
  protected final String TEXT_2 = NL + "/*" + NL + " * ";
d52 1
a52 1
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
@


1.13
log
@use importAssistant to emit package statement instead of handcoding
@
text
@a63 1
GenClass nodeMetaClass = genNode.getModelFacet().getMetaClass();
d85 4
@


1.12
log
@using M6 to generate code.
@
text
@d23 14
a36 15
  protected final String TEXT_4 = NL + "package ";
  protected final String TEXT_5 = ";" + NL;
  protected final String TEXT_6 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_7 = " extends ";
  protected final String TEXT_8 = " {";
  protected final String TEXT_9 = NL + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ";
  protected final String TEXT_10 = " getConnectionCompleteCommand(" + NL + "\t\t\t";
  protected final String TEXT_11 = " request) {" + NL + "\t\t";
  protected final String TEXT_12 = " elementType = getElementType(request);";
  protected final String TEXT_13 = NL + "\t\tif (";
  protected final String TEXT_14 = ".";
  protected final String TEXT_15 = " == elementType) {" + NL + "\t\t\treturn getConnectionWithReorientedViewCompleteCommand(request);" + NL + "\t\t}";
  protected final String TEXT_16 = NL + "\t\treturn super.getConnectionCompleteCommand(request);" + NL + "\t}";
  protected final String TEXT_17 = NL + "}";
  protected final String TEXT_18 = NL;
d42 2
a43 1
GenNode genNode = (GenNode) ((Object[]) argument)[0];
d55 1
d57 1
a57 1
    stringBuffer.append(genDiagram.getEditPoliciesPackageName());
d59 1
a59 2
    ImportUtil importManager = new ImportUtil(genDiagram.getEditPoliciesPackageName());
    importManager.markImportLocation(stringBuffer);
d61 1
a61 1
    stringBuffer.append(genNode.getGraphicalNodeEditPolicyClassName());
a62 2
    stringBuffer.append(importManager.getImportedName(genDiagram.getBaseGraphicalNodeEditPolicyQualifiedClassName()));
    stringBuffer.append(TEXT_8);
d108 2
d111 1
a111 1
    stringBuffer.append(importManager.getImportedName("org.eclipse.gef.commands.Command"));
d113 1
a113 1
    stringBuffer.append(importManager.getImportedName("org.eclipse.gef.requests.CreateConnectionRequest"));
d115 1
a115 1
    stringBuffer.append(importManager.getImportedName("org.eclipse.gmf.runtime.emf.type.core.IElementType"));
d117 1
a117 1
    	for (Iterator it = ids.iterator(); it.hasNext();) {
d119 1
a119 1
    stringBuffer.append(importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName()));
d121 1
a121 1
    stringBuffer.append((String) it.next());
d123 1
a123 1
    	}
d125 1
a125 1
    }
a126 2
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_18);
@


1.11
log
@restore generators
@
text
@d41 1
a41 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.10
log
@#134095 do not store compiled templates in cvs
@
text
@d41 1
a41 1
    final StringBuffer stringBuffer = new StringBuffer();
@


1.9
log
@Switching to eclipse M6.
@
text
@@


1.8
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d41 1
a41 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.7
log
@#114175 for links
@
text
@d20 18
a37 15
  protected final String TEXT_1 = "package ";
  protected final String TEXT_2 = ";" + NL;
  protected final String TEXT_3 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_4 = " extends ";
  protected final String TEXT_5 = " {";
  protected final String TEXT_6 = NL + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ";
  protected final String TEXT_7 = " getConnectionCompleteCommand(" + NL + "\t\t\t";
  protected final String TEXT_8 = " request) {" + NL + "\t\t";
  protected final String TEXT_9 = " elementType = getElementType(request);";
  protected final String TEXT_10 = NL + "\t\tif (";
  protected final String TEXT_11 = ".";
  protected final String TEXT_12 = " == elementType) {" + NL + "\t\t\treturn getConnectionWithReorientedViewCompleteCommand(request);" + NL + "\t\t}";
  protected final String TEXT_13 = NL + "\t\treturn super.getConnectionCompleteCommand(request);" + NL + "\t}";
  protected final String TEXT_14 = NL + "}";
  protected final String TEXT_15 = NL;
d47 9
d57 1
a57 1
    stringBuffer.append(TEXT_2);
d60 1
a60 1
    stringBuffer.append(TEXT_3);
d62 1
a62 1
    stringBuffer.append(TEXT_4);
d64 1
a64 1
    stringBuffer.append(TEXT_5);
d110 1
a110 1
    stringBuffer.append(TEXT_6);
d112 1
a112 1
    stringBuffer.append(TEXT_7);
d114 1
a114 1
    stringBuffer.append(TEXT_8);
d116 1
a116 1
    stringBuffer.append(TEXT_9);
d118 1
a118 1
    stringBuffer.append(TEXT_10);
d120 1
a120 1
    stringBuffer.append(TEXT_11);
d122 1
a122 1
    stringBuffer.append(TEXT_12);
d124 1
a124 1
    stringBuffer.append(TEXT_13);
d126 1
a126 1
    stringBuffer.append(TEXT_14);
d128 1
a128 1
    stringBuffer.append(TEXT_15);
@


1.6
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d58 1
a58 5
/**
 * Do not perform any rotation of links in notation model if this property was not specified in 
 * .gmfgen model
 **/	
	if (!genLink.isViewDirectionAlignedWithModel()) {
a73 1
// Should not be here!
d78 1
a78 1
/**
d80 1
a80 1
 * 
d88 1
a88 1
 **/	
a91 1
	
@


1.5
log
@ImportManager moved to oeg.common
@
text
@d40 1
a40 1
GenNode genNode = (GenNode) argument;
@


1.4
log
@#119279
Reverting link in accordance with model link.
@
text
@d6 1
a6 1
import org.eclipse.gmf.codegen.util.*;
@


1.3
log
@#115621 Support links with distinct source and containment features
@
text
@d26 1
a26 1
  protected final String TEXT_7 = " getConnectionCreateCommand(" + NL + "\t\t\t";
d31 2
a32 2
  protected final String TEXT_12 = " == elementType) {" + NL + "\t\t\treturn getConnectionWithReorientedViewCreateCommand(request);" + NL + "\t\t}";
  protected final String TEXT_13 = NL + "\t\treturn super.getConnectionCreateCommand(request);" + NL + "\t}";
d58 4
d65 2
d69 1
a69 1
		GenClass outgoingClass = modelFacet.getSourceMetaFeature() == null
d72 1
a72 3
		if (nodeMetaClass.equals(modelFacet.getTargetMetaFeature().getTypeGenClass()) && !nodeMetaClass.equals(outgoingClass)) {
			ids.add(genLink.getUniqueIdentifier());
		}
d75 25
a99 3
		if (nodeMetaClass.equals(metaFeature.getTypeGenClass()) && !nodeMetaClass.equals(metaFeature.getGenClass())) {
			ids.add(genLink.getUniqueIdentifier());
		}
@


1.2
log
@#117716 Create link between two instances of the same metaclasses in correct direction
@
text
@d63 4
a66 1
		if (nodeMetaClass.equals(modelFacet.getTargetMetaFeature().getTypeGenClass()) && !nodeMetaClass.equals(modelFacet.getContainmentMetaFeature().getGenClass())) {
@


1.1
log
@#116797 provide option in gmfgen model for the links to align direction in view with direction in model
@
text
@d63 1
a63 1
		if (nodeMetaClass.equals(modelFacet.getTargetMetaFeature().getTypeGenClass())) {
d68 1
a68 1
		if (nodeMetaClass.equals(metaFeature.getTypeGenClass())) {
@

