head	1.25;
access;
symbols
	v20081022-1925:1.25
	v20081015-1925:1.25
	v20081008-1925:1.25
	v20081001-1925:1.25
	v20080924-1925:1.25
	v20080917-1925:1.25
	v20080911-1728:1.25
	v20080910-1520:1.25
	v20080903-1520:1.25
	v20080827-1520:1.25
	v20080813-1520:1.25
	v20080806-1520:1.25
	v20070202-0200:1.16.2.1
	v20070103-0300:1.24
	M4_20:1.24
	v20061222-1800:1.23
	v20061218-1200:1.23
	v20061214-0000:1.23
	v20061120-1300:1.23
	M3_20:1.22
	v20061117-0800:1.22
	v20061027-1200:1.16.2.1
	v20061020-1000:1.16.2.1
	v20061013-1330:1.18
	v20060919-0800:1.16.2.1
	v20060907-1100:1.16.2.1
	M1_20:1.17
	v20060904-1500:1.17
	v20060824-1600:1.16.2.1
	v20060817-1500:1.16
	v20060728-0500:1.16
	v20060713-1700:1.16
	R1_0_maintenance:1.16.0.2
	R1_0:1.16
	v20060627-1200:1.16
	v20060626-1420:1.16
	v20060620-0400:1.16
	v20060616-1400:1.16
	v20060616-1200:1.16
	v20060609-1400:1.16
	v20060531-1730:1.15
	v20060530-1930:1.15
	v20060526-1200:1.14
	v20060519-1300:1.14
	v20060519-0800:1.14
	v20060512-1000:1.14
	I20060512-1000:1.14
	I20060505-1400:1.14
	I20060428-1300:1.14
	I20060424-0500:1.14
	I20060424-0300:1.14
	M6_10:1.14
	I20060407-1200:1.11
	I20060331-1000:1.10
	I20060324-0300:1.10
	I20060317-1300:1.10
	I20060317-1200:1.10
	I20060316-1300:1.10
	I20060309-1300:1.10
	M5_10:1.9
	S20060303-1600:1.9
	I20060227-1730:1.7
	I20060216-1945:1.7
	I20060210-1715:1.7
	I20060209-1815:1.7
	I20060203-0830:1.3
	I20060202-1415:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051208-2000:1.2
	I20051201-1800:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.25
date	2007.02.02.10.49.59;	author ashatalin;	state dead;
branches;
next	1.24;
commitid	527745c317554567;

1.24
date	2007.01.02.16.46.38;	author ashatalin;	state Exp;
branches;
next	1.23;
commitid	1f8459a8c6d4567;

1.23
date	2006.11.20.19.59.27;	author ashatalin;	state Exp;
branches;
next	1.22;
commitid	5e374562091f4567;

1.22
date	2006.11.14.19.23.44;	author ashatalin;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.10.15.39.57;	author ashatalin;	state Exp;
branches;
next	1.20;
commitid	6da745549d4c4567;

1.20
date	2006.10.26.14.24.57;	author ashatalin;	state Exp;
branches;
next	1.19;

1.19
date	2006.10.24.19.20.43;	author ashatalin;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.05.18.43.33;	author atikhomirov;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.23.20.01.07;	author ashatalin;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.01.09.14.34;	author dstadnik;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2006.05.29.18.20.56;	author ashatalin;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.08.17.19.56;	author ashatalin;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.08.16.56.36;	author dstadnik;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.08.11.41.49;	author dstadnik;	state dead;
branches;
next	1.11;

1.11
date	2006.04.07.14.49.25;	author ashatalin;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.07.15.45.28;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.01.14.55.16;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.01.13.02.25;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.08.17.15.50;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.08.16.06.19;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.06.15.00.14;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.05.22.57.54;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.03.18.34.55;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.24.17.02.53;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.19.17.56.08;	author atikhomirov;	state Exp;
branches;
next	;

1.16.2.1
date	2006.08.23.20.11.04;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Document Provider generated using xpand templates.
@
text
@package org.eclipse.gmf.codegen.templates.editor;

import org.eclipse.gmf.codegen.gmfgen.*;
import org.eclipse.gmf.common.codegen.*;

public class DocumentProviderGenerator
{
  protected static String nl;
  public static synchronized DocumentProviderGenerator create(String lineSeparator)
  {
    nl = lineSeparator;
    DocumentProviderGenerator result = new DocumentProviderGenerator();
    nl = null;
    return result;
  }

  protected final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + "/*" + NL + " *";
  protected final String TEXT_3 = NL + " */";
  protected final String TEXT_4 = NL;
  protected final String TEXT_5 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_6 = " extends StorageDocumentProvider implements IDiagramDocumentProvider {" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate final String myContentObjectURI;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_7 = "() {" + NL + "\t\tthis(null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_8 = "(String rootObjectURI) {" + NL + "\t\tmyContentObjectURI = rootObjectURI;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ElementInfo createElementInfo(Object element) throws CoreException {" + NL + "\t\tif (false == element instanceof FileEditorInputProxy) {" + NL + "\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ";
  protected final String TEXT_9 = ".ID, 0, \"Incorrect element used: \" + element + \" instead of FileEditorInputProxy\", null));" + NL + "\t\t}" + NL + "\t\tFileEditorInputProxy editorInput = (FileEditorInputProxy) element;" + NL + "\t\tIDiagramDocument document = (IDiagramDocument) createDocument(editorInput);" + NL + "" + NL + "\t\tResourceSetInfo info = new ResourceSetInfo(document, editorInput);" + NL + "\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\tinfo.fStatus = null;" + NL + "\t\tResourceSetModificationListener modificationListener = new ResourceSetModificationListener(info);" + NL + "\t\tinfo.getResourceSet().eAdapters().add(modificationListener);" + NL + "\t\treturn info;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate long computeModificationStamp(ResourceSetInfo info) {" + NL + "\t\tint result = 0;" + NL + "\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\tif (file != null) {" + NL + "\t\t\t\tif (file.getLocation() != null) {" + NL + "\t\t\t\t\tresult += file.getLocation().toFile().lastModified();" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tresult += file.getModificationStamp();" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn result;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IDocument createEmptyDocument() {" + NL + "\t\treturn new DiagramDocument();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean setDocumentContent(IDocument document, IEditorInput editorInput) throws CoreException {" + NL + "\t\tif (editorInput instanceof FileEditorInputProxy && document instanceof IDiagramDocument) {" + NL + "\t\t\tFileEditorInputProxy editorInputProxy = (FileEditorInputProxy) editorInput;" + NL + "\t\t\tIDiagramDocument diagramDocument = (IDiagramDocument) document;" + NL + "\t\t\tdiagramDocument.setEditingDomain(editorInputProxy.getEditingDomain());" + NL + "\t\t}" + NL + "\t\treturn super.setDocumentContent(document, editorInput);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setDocumentContentFromStorage(IDocument document, IStorage storage) throws CoreException {" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument) document;" + NL + "\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tdiagram = DiagramIOUtil.load(domain, storage, true, getProgressMonitor());" + NL + "\t\tif (myContentObjectURI != null && diagram != null && diagram.eResource() != null && !diagram.eResource().getURIFragment(diagram).equals(myContentObjectURI)) {" + NL + "\t\t\tEObject anotherContentObject = diagram.eResource().getEObject(myContentObjectURI);" + NL + "\t\t\tdocument.setContent(anotherContentObject);" + NL + "\t\t} else {" + NL + "\t\t\tdocument.setContent(diagram);" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic long getModificationStamp(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\treturn computeModificationStamp(info);" + NL + "\t\t}" + NL + "\t\treturn super.getModificationStamp(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic long getSynchronizationStamp(Object element) {" + NL + "\t\tif (element instanceof FileEditorInputProxy) {" + NL + "\t\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\t\tif (info != null) {" + NL + "\t\t\t\treturn info.getModificationStamp();" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSynchronizationStamp(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isDeleted(Object element) {" + NL + "\t\tif (element instanceof IFileEditorInput) {" + NL + "\t\t\tIFileEditorInput input = (IFileEditorInput) element;" + NL + "\t\t\tIPath path = input.getFile().getLocation();" + NL + "\t\t\tif (path == null) {" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "\t\t\treturn !path.toFile().exists();" + NL + "\t\t}" + NL + "\t\treturn super.isDeleted(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ResourceSetInfo getResourceSetInfo(Object editorInput) {" + NL + "\t\treturn (ResourceSetInfo) super.getElementInfo(editorInput);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void disposeElementInfo(Object element, ElementInfo info) {" + NL + "\t\tif (info instanceof ResourceSetInfo) {" + NL + "\t\t\tResourceSetInfo resourceSetInfo = (ResourceSetInfo) info;" + NL + "\t\t\tresourceSetInfo.dispose();" + NL + "\t\t}" + NL + "\t\tsuper.disposeElementInfo(element, info);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doValidateState(Object element, Object computationContext) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection files2Validate = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.isReadOnly()) {" + NL + "\t\t\t\t\tfiles2Validate.add(file);" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tResourcesPlugin.getWorkspace().validateEdit((IFile[]) files2Validate.toArray(new IFile[files2Validate.size()]), computationContext);" + NL + "\t\t}" + NL + "" + NL + "\t\tsuper.doValidateState(element, computationContext);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isModifiable(Object element) {" + NL + "\t\tif (!isStateValidated(element)) {" + NL + "\t\t\tif (element instanceof FileEditorInputProxy) {" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.isModifiable(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void updateCache(IStorageEditorInput input) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(input);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.isReadOnly()) {" + NL + "\t\t\t\t\tinfo.fIsReadOnly = true;" + NL + "\t\t\t\t\tinfo.fIsModifiable = false;" + NL + "\t\t\t\t\treturn;" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tinfo.fIsReadOnly = false;" + NL + "\t\t\tinfo.fIsModifiable = true;" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tsuper.updateCache(input);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isSynchronized(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\treturn info.isSynchronized();" + NL + "\t\t}" + NL + "\t\treturn super.isSynchronized(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getResetRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(computeSchedulingRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSynchronizeRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(ResourcesPlugin.getWorkspace().getRuleFactory().refreshRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getValidateStateRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection files = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\tfiles.add(file);" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().validateEditRule((IFile[]) files.toArray(new IFile[files.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists())" + NL + "\t\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent = toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t/*" + NL + "\t\t\t * XXX This is a workaround for" + NL + "\t\t\t * https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy" + NL + "\t\t\t * itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify = parent;" + NL + "\t\t\tparent = toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists());" + NL + "" + NL + "\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().createRule(toCreateOrModify);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doSynchronize(Object element, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null && element instanceof FileEditorInputProxy) {" + NL + "\t\t\thandleResourcesChanged(info, info.getResourceSet().getResources(), monitor);" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tsuper.doSynchronize(element, monitor);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void handleResourcesMoved(Map movedPathToResource) {" + NL + "\t\tfor (Iterator it = movedPathToResource.entrySet().iterator(); it.hasNext();) {" + NL + "\t\t\tEntry nextEntry = (Entry) it.next();" + NL + "\t\t\tIPath newPath = (IPath) nextEntry.getKey();" + NL + "\t\t\tResource resource = (Resource) nextEntry.getValue();" + NL + "\t\t\tresource.setURI(URI.createURI(newPath.toString()));" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void markWholeResourceSetAsDirty(ResourceSet resourceSet) {" + NL + "\t\tfor (Iterator it = resourceSet.getResources().iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tnextResource.setModified(true);" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void handleResourcesChanged(ResourceSetInfo info, Collection changedResources, IProgressMonitor monitor) {" + NL + "\t\tinfo.stopResourceListening();" + NL + "\t\tfor (Iterator it = changedResources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\tif (file != null) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tfile.refreshLocal(IResource.DEPTH_INFINITE, monitor);" + NL + "\t\t\t\t} catch (CoreException e) {" + NL + "\t\t\t\t\thandleCoreException(e, \"FileDocumentProvider.handleElementContentChanged\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tnextResource.unload();" + NL + "\t\t}" + NL + "\t\tinfo.startResourceListening();" + NL + "" + NL + "\t\tfireElementContentAboutToBeReplaced(info.getEditorInput());" + NL + "\t\tremoveUnchangedElementListeners(info.getEditorInput(), info);" + NL + "\t\tinfo.fStatus = null;" + NL + "\t\ttry {" + NL + "\t\t\tsetDocumentContent(info.fDocument, info.getEditorInput());" + NL + "\t\t} catch (CoreException e) {" + NL + "\t\t\tinfo.fStatus = e.getStatus();" + NL + "\t\t}" + NL + "\t\tif (!info.fCanBeSaved) {" + NL + "\t\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\t}" + NL + "\t\taddUnchangedElementListeners(info.getEditorInput(), info);" + NL + "\t\tfireElementContentReplaced(info.getEditorInput());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tif (!overwrite && !info.isSynchronized()) {" + NL + "\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ";
  protected final String TEXT_10 = ".ID, IResourceStatus.OUT_OF_SYNC_LOCAL, \"The file has been changed on the file system\", null));" + NL + "\t\t\t}" + NL + "\t\t\tinfo.stopResourceListening();" + NL + "\t\t\tfireElementStateChanging(element);" + NL + "\t\t\ttry {" + NL + "\t\t\t\tmonitor.beginTask(\"Saving diagram editor\", info.getResourceSet().getResources().size());" + NL + "\t\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI());" + NL + "\t\t\t\t\tif (nextResource.isLoaded() && (!nextResource.isTrackingModification() || nextResource.isModified())) {" + NL + "\t\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tmonitor.worked(1);" + NL + "\t\t\t\t}" + NL + "\t\t\t\tmonitor.done();" + NL + "\t\t\t} catch (IOException e) {" + NL + "\t\t\t\tfireElementStateChangeFailed(element);" + NL + "\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ";
  protected final String TEXT_11 = ".ID, EditorStatusCodes.RESOURCE_FAILURE, e.getLocalizedMessage(), null));" + NL + "\t\t\t} catch (RuntimeException x) {" + NL + "\t\t\t\tfireElementStateChangeFailed(element);" + NL + "\t\t\t\tthrow x;" + NL + "\t\t\t} finally {" + NL + "\t\t\t\tinfo.startResourceListening();" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\tif (info != null) {" + NL + "\t\t\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\t\t\tinfo.setSynchronized();" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\tsuper.doSaveDocument(monitor, element, document, overwrite);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void handleElementMoved(FileEditorInputProxy input, IPath path) {" + NL + "\t\tIWorkspace workspace = ResourcesPlugin.getWorkspace();" + NL + "\t\tIFile newFile = workspace.getRoot().getFile(path);" + NL + "\t\tfireElementMoved(input, newFile == null ? null : new FileEditorInput(newFile));" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void handleElementDeleted(FileEditorInputProxy input) {" + NL + "\t\tfireElementDeleted(input);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IEditorInput createInputWithEditingDomain(IEditorInput editorInput, TransactionalEditingDomain domain) {" + NL + "\t\tif (editorInput instanceof IFileEditorInput) {" + NL + "\t\t\treturn new FileEditorInputProxy((IFileEditorInput) editorInput, domain);" + NL + "\t\t}" + NL + "\t\tassert false;" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IDiagramDocument getDiagramDocument(Object element) {" + NL + "\t\tIDocument doc = getDocument(element);" + NL + "\t\tif (doc instanceof IDiagramDocument) {" + NL + "\t\t\treturn (IDiagramDocument) doc;" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */\t" + NL + "\tprotected class ResourceSetInfo extends StorageInfo {" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tprivate long myModificationStamp = IResource.NULL_STAMP;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate ResourceSetSynchronizer mySynchronizer;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate ResourceSet myResourceSet;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate Collection myUnSynchronizedResources = new ArrayList();" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate FileEditorInputProxy myEditorInput;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic ResourceSetInfo(IDiagramDocument document, FileEditorInputProxy editorInput) {" + NL + "\t\t\tsuper(document);" + NL + "\t\t\tmyResourceSet = document.getEditingDomain().getResourceSet();" + NL + "\t\t\tmyEditorInput = editorInput;" + NL + "\t\t\tmySynchronizer = new ResourceSetSynchronizer(this);" + NL + "\t\t\tstartResourceListening();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic long getModificationStamp() {" + NL + "\t\t\treturn myModificationStamp;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void setModificationStamp(long modificationStamp) {" + NL + "\t\t\tmyModificationStamp = modificationStamp;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic ResourceSetSynchronizer getSynchronizer() {" + NL + "\t\t\treturn mySynchronizer;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic ResourceSet getResourceSet() {" + NL + "\t\t\treturn myResourceSet;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic FileEditorInputProxy getEditorInput() {" + NL + "\t\t\treturn myEditorInput;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void dispose() {" + NL + "\t\t\tstopResourceListening();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic boolean isSynchronized() {" + NL + "\t\t\treturn myUnSynchronizedResources.size() == 0;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void setSynchronized() {" + NL + "\t\t\tmyUnSynchronizedResources.clear();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void setUnSynchronized(Resource resource) {" + NL + "\t\t\tmyUnSynchronizedResources.add(resource);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void setSynchronized(Resource resource) {" + NL + "\t\t\tmyUnSynchronizedResources.remove(resource);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic final void stopResourceListening() {" + NL + "\t\t\tResourcesPlugin.getWorkspace().removeResourceChangeListener(mySynchronizer);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic final void startResourceListening() {" + NL + "\t\t\tResourcesPlugin.getWorkspace().addResourceChangeListener(mySynchronizer, IResourceChangeEvent.POST_CHANGE);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */\t" + NL + "\tprotected class ResourceSetSynchronizer implements IResourceChangeListener {" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tprivate ResourceSetInfo myInfo;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tprotected ResourceSetSynchronizer(ResourceSetInfo info) {" + NL + "\t\t\tmyInfo = info;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tpublic void resourceChanged(IResourceChangeEvent event) {" + NL + "\t\t\tfinal ResourceDeltaVisitor deltaVisitor = new ResourceDeltaVisitor();" + NL + "\t\t\ttry {" + NL + "\t\t\t\tevent.getDelta().accept(deltaVisitor);" + NL + "\t\t\t} catch (CoreException e) {" + NL + "\t\t\t\thandleCoreException(e, \"FileDocumentProvider.resourceChanged\");" + NL + "\t\t\t}" + NL + "\t\t\tsynchronized (myInfo) {" + NL + "\t\t\t\tif (!myInfo.isSynchronized()) {" + NL + "\t\t\t\t\treturn;" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\tDisplay.getDefault().asyncExec(new Runnable() {" + NL + "" + NL + "\t\t\t\tpublic void run() {" + NL + "\t\t\t\t\tif (deltaVisitor.getDeletedResources().size() > 0) {" + NL + "\t\t\t\t\t\t// Just closing editor" + NL + "\t\t\t\t\t\thandleElementDeleted(myInfo.getEditorInput());" + NL + "\t\t\t\t\t\treturn;" + NL + "\t\t\t\t\t}" + NL + "" + NL + "\t\t\t\t\tEntry diagramEntry = getDiagramResourceEntry(deltaVisitor.getMovedResourcesMap());" + NL + "\t\t\t\t\tif (diagramEntry != null) {" + NL + "\t\t\t\t\t\tdeltaVisitor.getMovedResourcesMap().remove(diagramEntry.getKey());" + NL + "\t\t\t\t\t\t// Setting new editor input since diagram file was" + NL + "\t\t\t\t\t\t// renamed Could be processed together with the rest of" + NL + "\t\t\t\t\t\t// moved resources if FileEditorInputProxy will wupport" + NL + "\t\t\t\t\t\t// IFileEditorInput substitution" + NL + "\t\t\t\t\t\thandleElementMoved(myInfo.getEditorInput(), (IPath) diagramEntry.getKey());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tif (deltaVisitor.getMovedResourcesMap().size() > 0) {" + NL + "\t\t\t\t\t\thandleResourcesMoved(deltaVisitor.getMovedResourcesMap());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tif (deltaVisitor.getChangedResources().size() > 0 || deltaVisitor.getMovedResourcesMap().size() > 0) {" + NL + "\t\t\t\t\t\t// reloading changed resources + changing URIs for moved" + NL + "\t\t\t\t\t\t// resources" + NL + "\t\t\t\t\t\thandleResourcesChanged(myInfo, deltaVisitor.getChangedResources(), null);" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tif (deltaVisitor.getMovedResourcesMap().size() > 0) {" + NL + "\t\t\t\t\t\t// Marking whole ResourceSet as changed to preserve" + NL + "\t\t\t\t\t\t// changes in resource URIs made by" + NL + "\t\t\t\t\t\t// handleResourcesMoved() call" + NL + "\t\t\t\t\t\tmarkWholeResourceSetAsDirty(myInfo.getResourceSet());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "\t\t\t});" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tprivate Entry getDiagramResourceEntry(Map movedResources) {" + NL + "\t\t\tfor (Iterator it = movedResources.entrySet().iterator(); it.hasNext();) {" + NL + "\t\t\t\tEntry nextEntry = (Entry) it.next();" + NL + "\t\t\t\tResource nextResource = (Resource) nextEntry.getValue();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.equals(myInfo.getEditorInput().getFile())) {" + NL + "\t\t\t\t\treturn nextEntry;" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn null;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tprivate class ResourceDeltaVisitor implements IResourceDeltaVisitor {" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @@generated" + NL + "\t\t\t */\t" + NL + "\t\t\tprivate Collection myChangedResources = new ArrayList();" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @@generated" + NL + "\t\t\t */\t" + NL + "\t\t\tprivate Map myMovedResources = new HashMap();" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @@generated" + NL + "\t\t\t */\t" + NL + "\t\t\tprivate Collection myDeletedResources = new ArrayList();" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * Can be called from any thread" + NL + "\t\t\t * @@generated" + NL + "\t\t\t */\t" + NL + "\t\t\tpublic boolean visit(IResourceDelta delta) {" + NL + "\t\t\t\tif (delta.getFlags() != IResourceDelta.MARKERS && delta.getResource().getType() == IResource.FILE) {" + NL + "\t\t\t\t\tif ((delta.getKind() & (IResourceDelta.CHANGED | IResourceDelta.REMOVED)) != 0) {" + NL + "\t\t\t\t\t\tResource resource = myInfo.getResourceSet().getResource(URI.createURI(delta.getFullPath().toString()), false);" + NL + "\t\t\t\t\t\tif (resource != null && resource.isLoaded()) {" + NL + "\t\t\t\t\t\t\tsynchronized (myInfo) {" + NL + "\t\t\t\t\t\t\t\tif (myInfo.fCanBeSaved) {" + NL + "\t\t\t\t\t\t\t\t\tmyInfo.setUnSynchronized(resource);" + NL + "\t\t\t\t\t\t\t\t\treturn false;" + NL + "\t\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\tif ((delta.getKind() & IResourceDelta.REMOVED) != 0) {" + NL + "\t\t\t\t\t\t\t\t// element could be either moved/deleted or" + NL + "\t\t\t\t\t\t\t\t// changed." + NL + "\t\t\t\t\t\t\t\tif ((IResourceDelta.MOVED_TO & delta.getFlags()) != 0) {" + NL + "\t\t\t\t\t\t\t\t\tIPath destination = delta.getMovedToPath();" + NL + "\t\t\t\t\t\t\t\t\tmyMovedResources.put(destination, resource);" + NL + "\t\t\t\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\t\t\t\tmyDeletedResources.add(resource);" + NL + "\t\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\t\t\tmyChangedResources.add(resource);" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @@generated" + NL + "\t\t\t */\t" + NL + "\t\t\tpublic Collection getChangedResources() {" + NL + "\t\t\t\treturn myChangedResources;" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @@generated" + NL + "\t\t\t */\t" + NL + "\t\t\tpublic Collection getDeletedResources() {" + NL + "\t\t\t\treturn myDeletedResources;" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\t/**" + NL + "\t\t\t * @@generated" + NL + "\t\t\t */\t" + NL + "\t\t\tpublic Map getMovedResourcesMap() {" + NL + "\t\t\t\treturn myMovedResources;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */\t" + NL + "\tprivate class ResourceSetModificationListener extends EContentAdapter {" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tprivate NotificationFilter myModifiedFilter;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tprivate ResourceSetInfo myInfo;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tpublic ResourceSetModificationListener(ResourceSetInfo info) {" + NL + "\t\t\tmyInfo = info;" + NL + "\t\t\tmyModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET).or(NotificationFilter.createEventTypeFilter(Notification.UNSET)).and(" + NL + "\t\t\t\t\tNotificationFilter.createFeatureFilter(Resource.class, Resource.RESOURCE__IS_MODIFIED));" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */\t" + NL + "\t\tpublic void notifyChanged(Notification notification) {" + NL + "\t\t\tif (notification.getNotifier() instanceof ResourceSet) {" + NL + "\t\t\t\tsuper.notifyChanged(notification);" + NL + "\t\t\t}" + NL + "\t\t\tif (myModifiedFilter.matches(notification)) {" + NL + "\t\t\t\tif (notification.getNotifier() instanceof Resource) {" + NL + "\t\t\t\t\tResource resource = (Resource) notification.getNotifier();" + NL + "\t\t\t\t\tif (resource.isLoaded()) {" + NL + "\t\t\t\t\t\tboolean modified = false;" + NL + "\t\t\t\t\t\tfor (Iterator it = myInfo.getResourceSet().getResources().iterator(); it.hasNext() && !modified;) {" + NL + "\t\t\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\t\t\tif (nextResource.isLoaded()) {" + NL + "\t\t\t\t\t\t\t\tmodified = nextResource.isModified();" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\tboolean dirtyStateChanged = false;" + NL + "\t\t\t\t\t\tsynchronized (myInfo) {" + NL + "\t\t\t\t\t\t\tif (modified != myInfo.fCanBeSaved) {" + NL + "\t\t\t\t\t\t\t\tmyInfo.fCanBeSaved = modified;" + NL + "\t\t\t\t\t\t\t\tdirtyStateChanged = true;" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\tif (!resource.isModified()) {" + NL + "\t\t\t\t\t\t\t\tmyInfo.setSynchronized(resource);" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\tif (dirtyStateChanged) {" + NL + "\t\t\t\t\t\t\tfireElementDirtyStateChanged(myInfo.getEditorInput(), modified);" + NL + "\t\t\t\t\t\t\tif (!modified) {" + NL + "\t\t\t\t\t\t\t\tmyInfo.setModificationStamp(computeModificationStamp(myInfo));" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL;
  protected final String TEXT_12 = "\t\t\t\t\t}" + NL + "" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "}";
  protected final String TEXT_13 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];

    stringBuffer.append(TEXT_1);
    
String copyrightText = genDiagram.getEditorGen().getCopyrightText();
if (copyrightText != null && copyrightText.trim().length() > 0) {

    stringBuffer.append(TEXT_2);
    stringBuffer.append(copyrightText.replaceAll("\n", "\n *"));
    stringBuffer.append(TEXT_3);
    }
    importManager.emitPackageStatement(stringBuffer);
    stringBuffer.append(TEXT_4);
    importManager.addImport("org.eclipse.emf.ecore.EObject");
    importManager.addImport("java.io.IOException");
    importManager.addImport("java.util.ArrayList");
    importManager.addImport("java.util.Collection");
    importManager.addImport("java.util.Collections");
    importManager.addImport("java.util.HashMap");
    importManager.addImport("java.util.Iterator");
    importManager.addImport("java.util.Map");
    importManager.addImport("java.util.Map.Entry");
    importManager.addImport("org.eclipse.core.resources.IFile");
    importManager.addImport("org.eclipse.core.resources.IResource");
    importManager.addImport("org.eclipse.core.resources.IResourceChangeEvent");
    importManager.addImport("org.eclipse.core.resources.IResourceChangeListener");
    importManager.addImport("org.eclipse.core.resources.IResourceDelta");
    importManager.addImport("org.eclipse.core.resources.IResourceDeltaVisitor");
    importManager.addImport("org.eclipse.core.resources.IResourceStatus");
    importManager.addImport("org.eclipse.core.resources.IStorage");
    importManager.addImport("org.eclipse.core.resources.IWorkspace");
    importManager.addImport("org.eclipse.core.resources.ResourcesPlugin");
    importManager.addImport("org.eclipse.core.runtime.CoreException");
    importManager.addImport("org.eclipse.core.runtime.IPath");
    importManager.addImport("org.eclipse.core.runtime.IProgressMonitor");
    importManager.addImport("org.eclipse.core.runtime.IStatus");
    importManager.addImport("org.eclipse.core.runtime.Status");
    importManager.addImport("org.eclipse.core.runtime.jobs.ISchedulingRule");
    importManager.addImport("org.eclipse.core.runtime.jobs.MultiRule");
    importManager.addImport("org.eclipse.emf.common.notify.Notification");
    importManager.addImport("org.eclipse.emf.common.util.URI");
    importManager.addImport("org.eclipse.emf.ecore.resource.Resource");
    importManager.addImport("org.eclipse.emf.ecore.resource.ResourceSet");
    importManager.addImport("org.eclipse.emf.ecore.util.EContentAdapter");
    importManager.addImport("org.eclipse.emf.transaction.NotificationFilter");
    importManager.addImport("org.eclipse.emf.transaction.TransactionalEditingDomain");
    importManager.addImport("org.eclipse.emf.workspace.util.WorkspaceSynchronizer");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument");
    importManager.addImport("org.eclipse.gmf.runtime.notation.Diagram");
    importManager.addImport("org.eclipse.swt.widgets.Display");
    importManager.addImport("org.eclipse.ui.IEditorInput");
    importManager.addImport("org.eclipse.ui.IFileEditorInput");
    importManager.addImport("org.eclipse.ui.IStorageEditorInput");
    importManager.addImport("org.eclipse.ui.part.FileEditorInput");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.StorageDocumentProvider");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileEditorInputProxy");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.util.DiagramIOUtil");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.EditorStatusCodes");
    importManager.addImport("org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocumentProvider");
    importManager.registerInnerClass("ResourceSetInfo");
    importManager.registerInnerClass("ResourceSetSynchronizer");
    importManager.registerInnerClass("ResourceSetModificationListener");
    importManager.markImportLocation(stringBuffer);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(importManager.getCompilationUnitName());
    stringBuffer.append(TEXT_6);
    stringBuffer.append(importManager.getCompilationUnitName());
    stringBuffer.append(TEXT_7);
    stringBuffer.append(importManager.getCompilationUnitName());
    stringBuffer.append(TEXT_8);
    stringBuffer.append(importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()));
    stringBuffer.append(TEXT_9);
    stringBuffer.append(importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()));
    stringBuffer.append(TEXT_10);
    stringBuffer.append(importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()));
    stringBuffer.append(TEXT_11);
    stringBuffer.append(TEXT_12);
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_13);
    return stringBuffer.toString();
  }
}
@


1.24
log
@[169303] - DocumentProvider.computeModificationStamp fails for plugin resources
@
text
@@


1.23
log
@Correcting null pointer exception
@
text
@d26 1
a26 1
  protected final String TEXT_9 = ".ID, 0, \"Incorrect element used: \" + element + \" instead of FileEditorInputProxy\", null));" + NL + "\t\t}" + NL + "\t\tFileEditorInputProxy editorInput = (FileEditorInputProxy) element;" + NL + "\t\tIDiagramDocument document = (IDiagramDocument) createDocument(editorInput);" + NL + "" + NL + "\t\tResourceSetInfo info = new ResourceSetInfo(document, editorInput);" + NL + "\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\tinfo.fStatus = null;" + NL + "\t\tResourceSetModificationListener modificationListener = new ResourceSetModificationListener(info);" + NL + "\t\tinfo.getResourceSet().eAdapters().add(modificationListener);" + NL + "\t\treturn info;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate long computeModificationStamp(ResourceSetInfo info) {" + NL + "\t\tint result = 0;" + NL + "\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\tif (file != null) {" + NL + "\t\t\t\tif (file.getLocation() != null) {" + NL + "\t\t\t\t\tresult += file.getModificationStamp();" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tresult += file.getLocation().toFile().lastModified();" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn result;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IDocument createEmptyDocument() {" + NL + "\t\treturn new DiagramDocument();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean setDocumentContent(IDocument document, IEditorInput editorInput) throws CoreException {" + NL + "\t\tif (editorInput instanceof FileEditorInputProxy && document instanceof IDiagramDocument) {" + NL + "\t\t\tFileEditorInputProxy editorInputProxy = (FileEditorInputProxy) editorInput;" + NL + "\t\t\tIDiagramDocument diagramDocument = (IDiagramDocument) document;" + NL + "\t\t\tdiagramDocument.setEditingDomain(editorInputProxy.getEditingDomain());" + NL + "\t\t}" + NL + "\t\treturn super.setDocumentContent(document, editorInput);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setDocumentContentFromStorage(IDocument document, IStorage storage) throws CoreException {" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument) document;" + NL + "\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tdiagram = DiagramIOUtil.load(domain, storage, true, getProgressMonitor());" + NL + "\t\tif (myContentObjectURI != null && diagram != null && diagram.eResource() != null && !diagram.eResource().getURIFragment(diagram).equals(myContentObjectURI)) {" + NL + "\t\t\tEObject anotherContentObject = diagram.eResource().getEObject(myContentObjectURI);" + NL + "\t\t\tdocument.setContent(anotherContentObject);" + NL + "\t\t} else {" + NL + "\t\t\tdocument.setContent(diagram);" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic long getModificationStamp(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\treturn computeModificationStamp(info);" + NL + "\t\t}" + NL + "\t\treturn super.getModificationStamp(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic long getSynchronizationStamp(Object element) {" + NL + "\t\tif (element instanceof FileEditorInputProxy) {" + NL + "\t\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\t\tif (info != null) {" + NL + "\t\t\t\treturn info.getModificationStamp();" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSynchronizationStamp(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isDeleted(Object element) {" + NL + "\t\tif (element instanceof IFileEditorInput) {" + NL + "\t\t\tIFileEditorInput input = (IFileEditorInput) element;" + NL + "\t\t\tIPath path = input.getFile().getLocation();" + NL + "\t\t\tif (path == null) {" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "\t\t\treturn !path.toFile().exists();" + NL + "\t\t}" + NL + "\t\treturn super.isDeleted(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ResourceSetInfo getResourceSetInfo(Object editorInput) {" + NL + "\t\treturn (ResourceSetInfo) super.getElementInfo(editorInput);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void disposeElementInfo(Object element, ElementInfo info) {" + NL + "\t\tif (info instanceof ResourceSetInfo) {" + NL + "\t\t\tResourceSetInfo resourceSetInfo = (ResourceSetInfo) info;" + NL + "\t\t\tresourceSetInfo.dispose();" + NL + "\t\t}" + NL + "\t\tsuper.disposeElementInfo(element, info);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doValidateState(Object element, Object computationContext) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection files2Validate = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.isReadOnly()) {" + NL + "\t\t\t\t\tfiles2Validate.add(file);" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tResourcesPlugin.getWorkspace().validateEdit((IFile[]) files2Validate.toArray(new IFile[files2Validate.size()]), computationContext);" + NL + "\t\t}" + NL + "" + NL + "\t\tsuper.doValidateState(element, computationContext);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isModifiable(Object element) {" + NL + "\t\tif (!isStateValidated(element)) {" + NL + "\t\t\tif (element instanceof FileEditorInputProxy) {" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.isModifiable(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void updateCache(IStorageEditorInput input) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(input);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.isReadOnly()) {" + NL + "\t\t\t\t\tinfo.fIsReadOnly = true;" + NL + "\t\t\t\t\tinfo.fIsModifiable = false;" + NL + "\t\t\t\t\treturn;" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tinfo.fIsReadOnly = false;" + NL + "\t\t\tinfo.fIsModifiable = true;" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tsuper.updateCache(input);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isSynchronized(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\treturn info.isSynchronized();" + NL + "\t\t}" + NL + "\t\treturn super.isSynchronized(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getResetRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(computeSchedulingRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSynchronizeRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(ResourcesPlugin.getWorkspace().getRuleFactory().refreshRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getValidateStateRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection files = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\tfiles.add(file);" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().validateEditRule((IFile[]) files.toArray(new IFile[files.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists())" + NL + "\t\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent = toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t/*" + NL + "\t\t\t * XXX This is a workaround for" + NL + "\t\t\t * https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy" + NL + "\t\t\t * itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify = parent;" + NL + "\t\t\tparent = toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists());" + NL + "" + NL + "\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().createRule(toCreateOrModify);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doSynchronize(Object element, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null && element instanceof FileEditorInputProxy) {" + NL + "\t\t\thandleResourcesChanged(info, info.getResourceSet().getResources(), monitor);" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tsuper.doSynchronize(element, monitor);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void handleResourcesMoved(Map movedPathToResource) {" + NL + "\t\tfor (Iterator it = movedPathToResource.entrySet().iterator(); it.hasNext();) {" + NL + "\t\t\tEntry nextEntry = (Entry) it.next();" + NL + "\t\t\tIPath newPath = (IPath) nextEntry.getKey();" + NL + "\t\t\tResource resource = (Resource) nextEntry.getValue();" + NL + "\t\t\tresource.setURI(URI.createURI(newPath.toString()));" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void markWholeResourceSetAsDirty(ResourceSet resourceSet) {" + NL + "\t\tfor (Iterator it = resourceSet.getResources().iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tnextResource.setModified(true);" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void handleResourcesChanged(ResourceSetInfo info, Collection changedResources, IProgressMonitor monitor) {" + NL + "\t\tinfo.stopResourceListening();" + NL + "\t\tfor (Iterator it = changedResources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\tif (file != null) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tfile.refreshLocal(IResource.DEPTH_INFINITE, monitor);" + NL + "\t\t\t\t} catch (CoreException e) {" + NL + "\t\t\t\t\thandleCoreException(e, \"FileDocumentProvider.handleElementContentChanged\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tnextResource.unload();" + NL + "\t\t}" + NL + "\t\tinfo.startResourceListening();" + NL + "" + NL + "\t\tfireElementContentAboutToBeReplaced(info.getEditorInput());" + NL + "\t\tremoveUnchangedElementListeners(info.getEditorInput(), info);" + NL + "\t\tinfo.fStatus = null;" + NL + "\t\ttry {" + NL + "\t\t\tsetDocumentContent(info.fDocument, info.getEditorInput());" + NL + "\t\t} catch (CoreException e) {" + NL + "\t\t\tinfo.fStatus = e.getStatus();" + NL + "\t\t}" + NL + "\t\tif (!info.fCanBeSaved) {" + NL + "\t\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\t}" + NL + "\t\taddUnchangedElementListeners(info.getEditorInput(), info);" + NL + "\t\tfireElementContentReplaced(info.getEditorInput());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tif (!overwrite && !info.isSynchronized()) {" + NL + "\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ";
@


1.22
log
@Generating editor synchronization code
[155209] - GMF Editor does not get dirty when elements are added/removed thru custom code
@
text
@d26 1
a26 1
  protected final String TEXT_9 = ".ID, 0, \"Incorrect element used: \" + element + \" instead of FileEditorInputProxy\", null));" + NL + "\t\t}" + NL + "\t\tFileEditorInputProxy editorInput = (FileEditorInputProxy) element;" + NL + "\t\tIDiagramDocument document = (IDiagramDocument) createDocument(editorInput);" + NL + "" + NL + "\t\tResourceSetInfo info = new ResourceSetInfo(document, editorInput);" + NL + "\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\tinfo.fStatus = null;" + NL + "\t\tResourceSetModificationListener modificationListener = new ResourceSetModificationListener(info);" + NL + "\t\tinfo.getResourceSet().eAdapters().add(modificationListener);" + NL + "\t\treturn info;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate long computeModificationStamp(ResourceSetInfo info) {" + NL + "\t\tint result = 0;" + NL + "\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\tif (file != null) {" + NL + "\t\t\t\tif (file.getLocation() != null) {" + NL + "\t\t\t\t\tresult += file.getModificationStamp();" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tresult += file.getLocation().toFile().lastModified();" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn result;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IDocument createEmptyDocument() {" + NL + "\t\treturn new DiagramDocument();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean setDocumentContent(IDocument document, IEditorInput editorInput) throws CoreException {" + NL + "\t\tif (editorInput instanceof FileEditorInputProxy && document instanceof IDiagramDocument) {" + NL + "\t\t\tFileEditorInputProxy editorInputProxy = (FileEditorInputProxy) editorInput;" + NL + "\t\t\tIDiagramDocument diagramDocument = (IDiagramDocument) document;" + NL + "\t\t\tdiagramDocument.setEditingDomain(editorInputProxy.getEditingDomain());" + NL + "\t\t}" + NL + "\t\treturn super.setDocumentContent(document, editorInput);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setDocumentContentFromStorage(IDocument document, IStorage storage) throws CoreException {" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument) document;" + NL + "\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tdiagram = DiagramIOUtil.load(domain, storage, true, getProgressMonitor());" + NL + "\t\tif (myContentObjectURI != null && diagram != null && diagram.eResource() != null && !diagram.eResource().getURIFragment(diagram).equals(myContentObjectURI)) {" + NL + "\t\t\tEObject anotherContentObject = diagram.eResource().getEObject(myContentObjectURI);" + NL + "\t\t\tdocument.setContent(anotherContentObject);" + NL + "\t\t} else {" + NL + "\t\t\tdocument.setContent(diagram);" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic long getModificationStamp(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\treturn computeModificationStamp(info);" + NL + "\t\t}" + NL + "\t\treturn super.getModificationStamp(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic long getSynchronizationStamp(Object element) {" + NL + "\t\tif (element instanceof FileEditorInputProxy) {" + NL + "\t\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\t\tif (info != null) {" + NL + "\t\t\t\treturn info.getModificationStamp();" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSynchronizationStamp(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isDeleted(Object element) {" + NL + "\t\tif (element instanceof IFileEditorInput) {" + NL + "\t\t\tIFileEditorInput input = (IFileEditorInput) element;" + NL + "\t\t\tIPath path = input.getFile().getLocation();" + NL + "\t\t\tif (path == null) {" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "\t\t\treturn !path.toFile().exists();" + NL + "\t\t}" + NL + "\t\treturn super.isDeleted(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ResourceSetInfo getResourceSetInfo(Object editorInput) {" + NL + "\t\treturn (ResourceSetInfo) super.getElementInfo(editorInput);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void disposeElementInfo(Object element, ElementInfo info) {" + NL + "\t\tif (info instanceof ResourceSetInfo) {" + NL + "\t\t\tResourceSetInfo resourceSetInfo = (ResourceSetInfo) info;" + NL + "\t\t\tresourceSetInfo.dispose();" + NL + "\t\t}" + NL + "\t\tsuper.disposeElementInfo(element, info);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doValidateState(Object element, Object computationContext) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection files2Validate = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.isReadOnly()) {" + NL + "\t\t\t\t\tfiles2Validate.add(file);" + NL + "\t\t\t\t}" + NL + "\t\t\t\tIWorkspace workspace = file.getWorkspace();" + NL + "\t\t\t\tworkspace.validateEdit(new IFile[] { file }, computationContext);" + NL + "\t\t\t}" + NL + "\t\t\tResourcesPlugin.getWorkspace().validateEdit((IFile[]) files2Validate.toArray(new IFile[files2Validate.size()]), computationContext);" + NL + "\t\t}" + NL + "" + NL + "\t\tsuper.doValidateState(element, computationContext);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isModifiable(Object element) {" + NL + "\t\tif (!isStateValidated(element)) {" + NL + "\t\t\tif (element instanceof FileEditorInputProxy) {" + NL + "\t\t\t\treturn true;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.isModifiable(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void updateCache(IStorageEditorInput input) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(input);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null && file.isReadOnly()) {" + NL + "\t\t\t\t\tinfo.fIsReadOnly = true;" + NL + "\t\t\t\t\tinfo.fIsModifiable = false;" + NL + "\t\t\t\t\treturn;" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tinfo.fIsReadOnly = false;" + NL + "\t\t\tinfo.fIsModifiable = true;" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tsuper.updateCache(input);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic boolean isSynchronized(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\treturn info.isSynchronized();" + NL + "\t\t}" + NL + "\t\treturn super.isSynchronized(element);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getResetRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(computeSchedulingRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSynchronizeRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\trules.add(ResourcesPlugin.getWorkspace().getRuleFactory().refreshRule(file));" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getValidateStateRule(Object element) {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tCollection files = new ArrayList();" + NL + "\t\t\tfor (Iterator it = info.getResourceSet().getResources().iterator(); it.hasNext();) {" + NL + "\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\t\tif (file != null) {" + NL + "\t\t\t\t\tfiles.add(file);" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().validateEditRule((IFile[]) files.toArray(new IFile[files.size()]));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists())" + NL + "\t\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent = toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t/*" + NL + "\t\t\t * XXX This is a workaround for" + NL + "\t\t\t * https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy" + NL + "\t\t\t * itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify = parent;" + NL + "\t\t\tparent = toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists());" + NL + "" + NL + "\t\treturn ResourcesPlugin.getWorkspace().getRuleFactory().createRule(toCreateOrModify);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doSynchronize(Object element, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null && element instanceof FileEditorInputProxy) {" + NL + "\t\t\thandleResourcesChanged(info, info.getResourceSet().getResources(), monitor);" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tsuper.doSynchronize(element, monitor);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void handleResourcesMoved(Map movedPathToResource) {" + NL + "\t\tfor (Iterator it = movedPathToResource.entrySet().iterator(); it.hasNext();) {" + NL + "\t\t\tEntry nextEntry = (Entry) it.next();" + NL + "\t\t\tIPath newPath = (IPath) nextEntry.getKey();" + NL + "\t\t\tResource resource = (Resource) nextEntry.getValue();" + NL + "\t\t\tresource.setURI(URI.createURI(newPath.toString()));" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void markWholeResourceSetAsDirty(ResourceSet resourceSet) {" + NL + "\t\tfor (Iterator it = resourceSet.getResources().iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tnextResource.setModified(true);" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void handleResourcesChanged(ResourceSetInfo info, Collection changedResources, IProgressMonitor monitor) {" + NL + "\t\tinfo.stopResourceListening();" + NL + "\t\tfor (Iterator it = changedResources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tIFile file = WorkspaceSynchronizer.getFile(nextResource);" + NL + "\t\t\tif (file != null) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tfile.refreshLocal(IResource.DEPTH_INFINITE, monitor);" + NL + "\t\t\t\t} catch (CoreException e) {" + NL + "\t\t\t\t\thandleCoreException(e, \"FileDocumentProvider.handleElementContentChanged\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tnextResource.unload();" + NL + "\t\t}" + NL + "\t\tinfo.startResourceListening();" + NL + "" + NL + "\t\tfireElementContentAboutToBeReplaced(info.getEditorInput());" + NL + "\t\tremoveUnchangedElementListeners(info.getEditorInput(), info);" + NL + "\t\tinfo.fStatus = null;" + NL + "\t\ttry {" + NL + "\t\t\tsetDocumentContent(info.fDocument, info.getEditorInput());" + NL + "\t\t} catch (CoreException e) {" + NL + "\t\t\tinfo.fStatus = e.getStatus();" + NL + "\t\t}" + NL + "\t\tif (!info.fCanBeSaved) {" + NL + "\t\t\tinfo.setModificationStamp(computeModificationStamp(info));" + NL + "\t\t}" + NL + "\t\taddUnchangedElementListeners(info.getEditorInput(), info);" + NL + "\t\tfireElementContentReplaced(info.getEditorInput());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void doSaveDocument(IProgressMonitor monitor, Object element, IDocument document, boolean overwrite) throws CoreException {" + NL + "\t\tResourceSetInfo info = getResourceSetInfo(element);" + NL + "\t\tif (info != null) {" + NL + "\t\t\tif (!overwrite && !info.isSynchronized()) {" + NL + "\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ";
@


1.21
log
@[155209] - GMF Editor does not get dirty when elements are added/removed thru custom code
@
text
@d21 1
a21 1
  protected final String TEXT_4 = NL + NL + "import java.io.IOException;" + NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.Collections;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.resources.IStorage;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.emf.transaction.NotificationFilter;" + NL + "import org.eclipse.emf.transaction.TransactionalEditingDomain;" + NL + "import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
d23 1
a23 1
  protected final String TEXT_6 = " extends FileDiagramDocumentProvider {" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate final String contentObjectURI;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
d25 6
a30 4
  protected final String TEXT_8 = "(String rootObjectURI) {" + NL + "\t\tthis.contentObjectURI = rootObjectURI;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setDocumentContentFromStorage(IDocument document, IStorage storage) throws CoreException {" + NL + "\t\tsuper.setDocumentContentFromStorage(document, storage);" + NL + "\t\tif (contentObjectURI == null || false == document.getContent() instanceof EObject) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tEObject currentContent = (EObject) document.getContent();" + NL + "\t\tif (currentContent.eResource().getURIFragment(currentContent) == contentObjectURI) {" + NL + "\t\t\treturn; // already there" + NL + "\t\t}" + NL + "\t\tEObject anotherContentObject = currentContent.eResource().getEObject(contentObjectURI);" + NL + "\t\tdocument.setContent(anotherContentObject);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tResource diagramResource = diagram.eResource();" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument)document;" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tList resources = domain.getResourceSet().getResources();" + NL + "" + NL + "\t\tmonitor.beginTask(\"Saving diagram\", resources.size() + 1); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 1));" + NL + "\t\tfor (Iterator it = resources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI()); //$NON-NLS-1$" + NL + "\t\t\tif (nextResource != diagramResource && nextResource.isLoaded() && (!nextResource.isTrackingModification() || nextResource.isModified())) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t} catch (IOException e) {" + NL + "\t\t\t\t\t";
  protected final String TEXT_9 = ".getInstance().logError(\"Unable to save resource: \" + nextResource.getURI(), e); //$NON-NLS-1$" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tmonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tmonitor.done();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tIDiagramDocument diagramDocument = getDiagramDocument(element);" + NL + "\t\tif (diagramDocument != null) {" + NL + "\t\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "\t\t\tif (diagram != null) {" + NL + "\t\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\t\tfor (Iterator it = diagramDocument.getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {" + NL + "\t\t\t\t\tIFile nextFile = WorkspaceSynchronizer.getFile((Resource) it.next());" + NL + "\t\t\t\t\tif (nextFile != null) {" + NL + "\t\t\t\t\t\trules.add(computeSaveSchedulingRule(nextFile));\t" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "\t\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSaveRule(element);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {" + NL + "\t\tassert document instanceof DiagramDocument;" + NL + "" + NL + "\t\tDiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);" + NL + "\t\tDiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);" + NL + "" + NL + "\t\tdiagramListener.startListening();" + NL + "\t\treturn info;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))" + NL + "\t\t\treturn fResourceRuleFactory.modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent= toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t /*" + NL + "\t\t\t * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify= parent;" + NL + "\t\t\tparent= toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));" + NL + "" + NL + "\t\treturn fResourceRuleFactory.createRule(toCreateOrModify);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void fireElementDirtyStateChanged(TransactionalEditingDomain editingDomain, IFileEditorInput fileEditorInput) {" + NL + "\t\tboolean modified = false;" + NL + "\t\tfor (Iterator it = editingDomain.getResourceSet().getResources().iterator(); it.hasNext() && !modified;) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tif (nextResource.isLoaded()) {" + NL + "\t\t\t\tmodified = nextResource.isModified();" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\tElementInfo info = getElementInfo(fileEditorInput);" + NL + "\t\tif (modified) {" + NL + "\t\t\tinfo.fCanBeSaved = modified;" + NL + "\t\t} else {" + NL + "\t\t\tinfo.fCanBeSaved= false;" + NL + "\t\t\tif (info instanceof FileInfo) {" + NL + "\t\t\t\t((FileInfo) info).fModificationStamp= computeModificationStamp(fileEditorInput.getFile());\t" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\tfireElementDirtyStateChanged(fileEditorInput, modified);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate class CustomModificationListener extends DiagramModificationListener {" + NL + "\t" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate NotificationFilter myModifiedFilter;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate IFileEditorInput myFileEditorInput;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tpublic CustomModificationListener(";
  protected final String TEXT_10 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter);" + NL + "\t\t\tmyFileEditorInput = inputParameter;" + NL + "\t\t\tmyModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET).or(NotificationFilter.createEventTypeFilter(Notification.UNSET)).and(NotificationFilter.createFeatureFilter(Resource.class, Resource.RESOURCE__IS_MODIFIED));" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void notifyChanged(Notification notification) {" + NL + "\t\t\tif (myModifiedFilter.matches(notification)) {" + NL + "\t\t\t\tif (notification.getNotifier() instanceof Resource) {" + NL + "\t\t\t\t\tResource resource = (Resource) notification.getNotifier();" + NL + "\t\t\t\t\tif (resource.isLoaded()) {" + NL + "\t\t\t\t\t\tfireElementDirtyStateChanged(getEditingDomain(), myFileEditorInput);" + NL + "\t\t\t\t\t}" + NL + "" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_11 = NL;
d50 51
d111 1
a111 1
    stringBuffer.append(genDiagram.getDocumentProviderClassName());
d113 3
d117 1
a117 1
    stringBuffer.append(TEXT_11);
@


1.20
log
@Correcting isModified() usage.
@
text
@d21 1
a21 1
  protected final String TEXT_4 = NL + NL + "import java.io.IOException;" + NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.Collections;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.resources.IStorage;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.emf.transaction.DemultiplexingListener;" + NL + "import org.eclipse.emf.transaction.NotificationFilter;" + NL + "import org.eclipse.emf.transaction.TransactionalEditingDomain;" + NL + "import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
d26 2
a27 2
  protected final String TEXT_9 = ".getInstance().logError(\"Unable to save resource: \" + nextResource.getURI(), e); //$NON-NLS-1$" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tmonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tmonitor.done();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tIDiagramDocument diagramDocument = getDiagramDocument(element);" + NL + "\t\tif (diagramDocument != null) {" + NL + "\t\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "\t\t\tif (diagram != null) {" + NL + "\t\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\t\tfor (Iterator it = diagramDocument.getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {" + NL + "\t\t\t\t\tIFile nextFile = WorkspaceSynchronizer.getFile((Resource) it.next());" + NL + "\t\t\t\t\tif (nextFile != null) {" + NL + "\t\t\t\t\t\trules.add(computeSaveSchedulingRule(nextFile));\t" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "\t\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSaveRule(element);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {" + NL + "\t\tassert document instanceof DiagramDocument;" + NL + "" + NL + "\t\tDiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);" + NL + "\t\tDiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);" + NL + "" + NL + "\t\tdiagramListener.startListening();" + NL + "\t\treturn info;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))" + NL + "\t\t\treturn fResourceRuleFactory.modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent= toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t /*" + NL + "\t\t\t * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify= parent;" + NL + "\t\t\tparent= toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));" + NL + "" + NL + "\t\treturn fResourceRuleFactory.createRule(toCreateOrModify);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate class CustomModificationListener extends FileDiagramModificationListener {" + NL + "\t" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate DemultiplexingListener myListener = null;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tpublic CustomModificationListener(";
  protected final String TEXT_10 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter, inputParameter);" + NL + "\t \t\tfinal DiagramDocument document = documentParameter;" + NL + "\t\t\tNotificationFilter diagramResourceModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET);" + NL + "\t\t\tmyListener = new DemultiplexingListener(diagramResourceModifiedFilter) {" + NL + "\t\t\t\tprotected void handleNotification(TransactionalEditingDomain domain, Notification notification) {" + NL + "\t\t\t\t\tif (notification.getNotifier() instanceof EObject) {" + NL + "\t\t\t\t\t\tResource modifiedResource = ((EObject) notification.getNotifier()).eResource();" + NL + "\t\t\t\t\t\tif (modifiedResource != document.getDiagram().eResource()) {" + NL + "\t\t\t\t\t\t\tdocument.setContent(document.getContent());\t\t" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "" + NL + "\t\t\t\t}" + NL + "\t\t\t};" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void startListening() {" + NL + "\t\t\tsuper.startListening();" + NL + "\t\t\tgetEditingDomain().addResourceSetListener(myListener);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void stopListening() {" + NL + "\t\t\tgetEditingDomain().removeResourceSetListener(myListener);" + NL + "\t\t\tsuper.stopListening();" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
@


1.19
log
@Supporting EMF transfer for D&D
@
text
@d25 1
a25 1
  protected final String TEXT_8 = "(String rootObjectURI) {" + NL + "\t\tthis.contentObjectURI = rootObjectURI;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setDocumentContentFromStorage(IDocument document, IStorage storage) throws CoreException {" + NL + "\t\tsuper.setDocumentContentFromStorage(document, storage);" + NL + "\t\tif (contentObjectURI == null || false == document.getContent() instanceof EObject) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tEObject currentContent = (EObject) document.getContent();" + NL + "\t\tif (currentContent.eResource().getURIFragment(currentContent) == contentObjectURI) {" + NL + "\t\t\treturn; // already there" + NL + "\t\t}" + NL + "\t\tEObject anotherContentObject = currentContent.eResource().getEObject(contentObjectURI);" + NL + "\t\tdocument.setContent(anotherContentObject);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tResource diagramResource = diagram.eResource();" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument)document;" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tList resources = domain.getResourceSet().getResources();" + NL + "" + NL + "\t\tmonitor.beginTask(\"Saving diagram\", resources.size() + 1); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 1));" + NL + "\t\tfor (Iterator it = resources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI()); //$NON-NLS-1$" + NL + "\t\t\tif (nextResource != diagramResource && nextResource.isLoaded() && nextResource.isModified()) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t} catch (IOException e) {" + NL + "\t\t\t\t\t";
@


1.18
log
@[119465] support for diagram partitioning - few hacks to use FileEditorInput because otherwise nothing gonna work
@
text
@d25 1
a25 1
  protected final String TEXT_8 = "(String rootObjectURI) {" + NL + "\t\tthis.contentObjectURI = rootObjectURI;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setDocumentContentFromStorage(IDocument document, IStorage storage) throws CoreException {" + NL + "\t\tsuper.setDocumentContentFromStorage(document, storage);" + NL + "\t\tif (contentObjectURI == null || false == document.getContent() instanceof EObject) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tEObject currentContent = (EObject) document.getContent();" + NL + "\t\tif (currentContent.eResource().getURIFragment(currentContent) == contentObjectURI) {" + NL + "\t\t\treturn; // already there" + NL + "\t\t}" + NL + "\t\tEObject anotherContentObject = currentContent.eResource().getEObject(contentObjectURI);" + NL + "\t\tdocument.setContent(anotherContentObject);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tResource diagramResource = diagram.eResource();" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument)document;" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tList resources = domain.getResourceSet().getResources();" + NL + "" + NL + "\t\tmonitor.beginTask(\"Saving diagram\", resources.size() + 1); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 1));" + NL + "\t\tfor (Iterator it = resources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI()); //$NON-NLS-1$" + NL + "\t\t\tif (nextResource != diagramResource && nextResource.isLoaded()) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t} catch (IOException e) {" + NL + "\t\t\t\t\t";
@


1.17
log
@[153893] XXXDocumentProvider.saveDocumentToFile can cause loss of data
@
text
@d21 1
a21 1
  protected final String TEXT_4 = NL + NL + "import java.io.IOException;" + NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.Collections;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.emf.transaction.DemultiplexingListener;" + NL + "import org.eclipse.emf.transaction.NotificationFilter;" + NL + "import org.eclipse.emf.transaction.TransactionalEditingDomain;" + NL + "import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
d23 6
a28 4
  protected final String TEXT_6 = " extends FileDiagramDocumentProvider {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tResource diagramResource = diagram.eResource();" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument)document;" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tList resources = domain.getResourceSet().getResources();" + NL + "" + NL + "\t\tmonitor.beginTask(\"Saving diagram\", resources.size() + 1); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 1));" + NL + "\t\tfor (Iterator it = resources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI()); //$NON-NLS-1$" + NL + "\t\t\tif (nextResource != diagramResource && nextResource.isLoaded()) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t} catch (IOException e) {" + NL + "\t\t\t\t\t";
  protected final String TEXT_7 = ".getInstance().logError(\"Unable to save resource: \" + nextResource.getURI(), e); //$NON-NLS-1$" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tmonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tmonitor.done();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tIDiagramDocument diagramDocument = getDiagramDocument(element);" + NL + "\t\tif (diagramDocument != null) {" + NL + "\t\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "\t\t\tif (diagram != null) {" + NL + "\t\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\t\tfor (Iterator it = diagramDocument.getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {" + NL + "\t\t\t\t\tIFile nextFile = WorkspaceSynchronizer.getFile((Resource) it.next());" + NL + "\t\t\t\t\tif (nextFile != null) {" + NL + "\t\t\t\t\t\trules.add(computeSaveSchedulingRule(nextFile));\t" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "\t\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSaveRule(element);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {" + NL + "\t\tassert document instanceof DiagramDocument;" + NL + "" + NL + "\t\tDiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);" + NL + "\t\tDiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);" + NL + "" + NL + "\t\tdiagramListener.startListening();" + NL + "\t\treturn info;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))" + NL + "\t\t\treturn fResourceRuleFactory.modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent= toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t /*" + NL + "\t\t\t * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify= parent;" + NL + "\t\t\tparent= toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));" + NL + "" + NL + "\t\treturn fResourceRuleFactory.createRule(toCreateOrModify);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate class CustomModificationListener extends FileDiagramModificationListener {" + NL + "\t" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate DemultiplexingListener myListener = null;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tpublic CustomModificationListener(";
  protected final String TEXT_8 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter, inputParameter);" + NL + "\t \t\tfinal DiagramDocument document = documentParameter;" + NL + "\t\t\tNotificationFilter diagramResourceModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET);" + NL + "\t\t\tmyListener = new DemultiplexingListener(diagramResourceModifiedFilter) {" + NL + "\t\t\t\tprotected void handleNotification(TransactionalEditingDomain domain, Notification notification) {" + NL + "\t\t\t\t\tif (notification.getNotifier() instanceof EObject) {" + NL + "\t\t\t\t\t\tResource modifiedResource = ((EObject) notification.getNotifier()).eResource();" + NL + "\t\t\t\t\t\tif (modifiedResource != document.getDiagram().eResource()) {" + NL + "\t\t\t\t\t\t\tdocument.setContent(document.getContent());\t\t" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "" + NL + "\t\t\t\t}" + NL + "\t\t\t};" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void startListening() {" + NL + "\t\t\tsuper.startListening();" + NL + "\t\t\tgetEditingDomain().addResourceSetListener(myListener);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void stopListening() {" + NL + "\t\t\tgetEditingDomain().removeResourceSetListener(myListener);" + NL + "\t\t\tsuper.stopListening();" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_9 = NL;
d50 1
a50 1
    stringBuffer.append(genDiagram.getDocumentProviderClassName());
d52 4
d57 1
a57 1
    stringBuffer.append(TEXT_7);
d59 1
a59 1
    stringBuffer.append(TEXT_8);
d61 1
a61 1
    stringBuffer.append(TEXT_9);
@


1.16
log
@header comment should not be a javadoc comment
@
text
@d23 1
a23 1
  protected final String TEXT_6 = " extends FileDiagramDocumentProvider {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tResource diagramResource = diagram.eResource();" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument)document;" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tList resources = domain.getResourceSet().getResources();" + NL + "" + NL + "\t\tmonitor.beginTask(\"Saving diagram\", resources.size() + 1); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 1));" + NL + "\t\tfor (Iterator it = resources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI()); //$NON-NLS-1$" + NL + "\t\t\tif (nextResource != diagramResource) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t} catch (IOException e) {" + NL + "\t\t\t\t\t";
@


1.16.2.1
log
@[153893] XXXDocumentProvider.saveDocumentToFile can cause loss of data
@
text
@d23 1
a23 1
  protected final String TEXT_6 = " extends FileDiagramDocumentProvider {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tResource diagramResource = diagram.eResource();" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument)document;" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tList resources = domain.getResourceSet().getResources();" + NL + "" + NL + "\t\tmonitor.beginTask(\"Saving diagram\", resources.size() + 1); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 1));" + NL + "\t\tfor (Iterator it = resources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI()); //$NON-NLS-1$" + NL + "\t\t\tif (nextResource != diagramResource && nextResource.isLoaded()) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t} catch (IOException e) {" + NL + "\t\t\t\t\t";
@


1.15
log
@Correcting copyright processing
@
text
@d19 1
a19 1
  protected final String TEXT_2 = NL + "/**" + NL + " *";
@


1.14
log
@using M6 to generate code.
@
text
@d19 1
a19 1
  protected final String TEXT_2 = NL + "/*" + NL + " * ";
d41 1
a41 1
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
@


1.13
log
@restore generators
@
text
@d30 1
a30 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.12
log
@#134095 do not store compiled templates in cvs
@
text
@d30 1
a30 1
    final StringBuffer stringBuffer = new StringBuffer();
@


1.11
log
@Switching to eclipse M6.
@
text
@@


1.10
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d30 1
a30 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.9
log
@#127696 Templates should use new transaction API
@
text
@d18 9
a26 6
  protected final String TEXT_1 = NL + "import java.io.IOException;" + NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.Collections;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.emf.transaction.DemultiplexingListener;" + NL + "import org.eclipse.emf.transaction.NotificationFilter;" + NL + "import org.eclipse.emf.transaction.TransactionalEditingDomain;" + NL + "import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
  protected final String TEXT_2 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_3 = " extends FileDiagramDocumentProvider {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tResource diagramResource = diagram.eResource();" + NL + "\t\tIDiagramDocument diagramDocument = (IDiagramDocument)document;" + NL + "\t\tTransactionalEditingDomain domain = diagramDocument.getEditingDomain();" + NL + "\t\tList resources = domain.getResourceSet().getResources();" + NL + "" + NL + "\t\tmonitor.beginTask(\"Saving diagram\", resources.size() + 1); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 1));" + NL + "\t\tfor (Iterator it = resources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tmonitor.setTaskName(\"Saving \" + nextResource.getURI()); //$NON-NLS-1$" + NL + "\t\t\tif (nextResource != diagramResource) {" + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tnextResource.save(Collections.EMPTY_MAP);" + NL + "\t\t\t\t} catch (IOException e) {" + NL + "\t\t\t\t\t";
  protected final String TEXT_4 = ".getInstance().logError(\"Unable to save resource: \" + nextResource.getURI(), e); //$NON-NLS-1$" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\tmonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tmonitor.done();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tIDiagramDocument diagramDocument = getDiagramDocument(element);" + NL + "\t\tif (diagramDocument != null) {" + NL + "\t\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "\t\t\tif (diagram != null) {" + NL + "\t\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\t\tfor (Iterator it = diagramDocument.getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {" + NL + "\t\t\t\t\tIFile nextFile = WorkspaceSynchronizer.getFile((Resource) it.next());" + NL + "\t\t\t\t\tif (nextFile != null) {" + NL + "\t\t\t\t\t\trules.add(computeSaveSchedulingRule(nextFile));\t" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "\t\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSaveRule(element);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {" + NL + "\t\tassert document instanceof DiagramDocument;" + NL + "" + NL + "\t\tDiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);" + NL + "\t\tDiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);" + NL + "" + NL + "\t\tdiagramListener.startListening();" + NL + "\t\treturn info;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))" + NL + "\t\t\treturn fResourceRuleFactory.modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent= toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t /*" + NL + "\t\t\t * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify= parent;" + NL + "\t\t\tparent= toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));" + NL + "" + NL + "\t\treturn fResourceRuleFactory.createRule(toCreateOrModify);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate class CustomModificationListener extends FileDiagramModificationListener {" + NL + "\t" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate DemultiplexingListener myListener = null;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tpublic CustomModificationListener(";
  protected final String TEXT_5 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter, inputParameter);" + NL + "\t \t\tfinal DiagramDocument document = documentParameter;" + NL + "\t\t\tNotificationFilter diagramResourceModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET);" + NL + "\t\t\tmyListener = new DemultiplexingListener(diagramResourceModifiedFilter) {" + NL + "\t\t\t\tprotected void handleNotification(TransactionalEditingDomain domain, Notification notification) {" + NL + "\t\t\t\t\tif (notification.getNotifier() instanceof EObject) {" + NL + "\t\t\t\t\t\tResource modifiedResource = ((EObject) notification.getNotifier()).eResource();" + NL + "\t\t\t\t\t\tif (modifiedResource != document.getDiagram().eResource()) {" + NL + "\t\t\t\t\t\t\tdocument.setContent(document.getContent());\t\t" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "" + NL + "\t\t\t\t}" + NL + "\t\t\t};" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void startListening() {" + NL + "\t\t\tsuper.startListening();" + NL + "\t\t\tgetEditingDomain().addResourceSetListener(myListener);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void stopListening() {" + NL + "\t\t\tgetEditingDomain().removeResourceSetListener(myListener);" + NL + "\t\t\tsuper.stopListening();" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_6 = NL;
a34 1
importManager.emitPackageStatement(stringBuffer);
d36 10
d47 1
a47 1
    stringBuffer.append(TEXT_2);
d49 1
a49 1
    stringBuffer.append(TEXT_3);
d51 1
a51 1
    stringBuffer.append(TEXT_4);
d53 1
a53 1
    stringBuffer.append(TEXT_5);
d55 1
a55 1
    stringBuffer.append(TEXT_6);
@


1.8
log
@#127696 Templates should use new transaction API
@
text
@d18 1
a18 1
  protected final String TEXT_1 = NL + "import java.io.IOException;" + NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.Collections;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.emf.transaction.DemultiplexingListener;" + NL + "import org.eclipse.emf.transaction.NotificationFilter;" + NL + "import org.eclipse.emf.transaction.TransactionalEditingDomain;" + NL + "import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
d22 1
a22 1
  protected final String TEXT_5 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter, inputParameter);" + NL + "\t \t\tfinal DiagramDocument document = documentParameter;" + NL + "\t\t\tNotificationFilter diagramResourceModifiedFilter = NotificationFilter.createEventTypeFilter(Notification.SET);" + NL + "\t\t\tmyListener = new DemultiplexingListener(diagramResourceModifiedFilter) {" + NL + "\t\t\t\tprotected void handleNotification(TransactionalEditingDomain domain, Notification notification) {" + NL + "\t\t\t\t\tdocument.setContent(document.getContent());" + NL + "\t\t\t\t}" + NL + "\t\t\t};" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void startListening() {" + NL + "\t\t\tsuper.startListening();" + NL + "\t\t\tgetEditingDomain().addResourceSetListener(myListener);" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void stopListening() {" + NL + "\t\t\tgetEditingDomain().removeResourceSetListener(myListener);" + NL + "\t\t\tsuper.stopListening();" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
@


1.7
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d18 1
a18 1
  protected final String TEXT_1 = NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.Collections;" + NL + "import java.util.HashSet;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "import java.util.Set;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MFilter;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MListener;" + NL + "import org.eclipse.gmf.runtime.emf.core.util.ResourceUtil;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
d20 4
a23 3
  protected final String TEXT_3 = " extends FileDiagramDocumentProvider {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tmonitor.beginTask(\"\", 100); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 20));" + NL + "" + NL + "\t\tIProgressMonitor subMonitor = new SubProgressMonitor(monitor, 20);" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\tsubMonitor.done();" + NL + "\t\t" + NL + "\t\tsubMonitor = new SubProgressMonitor(monitor, 60);" + NL + "\t\tsubMonitor.beginTask(\"Saving external resources\", externalResources.size());" + NL + "\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tsubMonitor.setTaskName(\"Saving \" + nextResource.getURI());" + NL + "\t\t\tResourceUtil.save(nextResource);" + NL + "\t\t\tsubMonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tsubMonitor.done();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tIDiagramDocument diagramDocument = getDiagramDocument(element);" + NL + "\t\tif (diagramDocument != null) {" + NL + "\t\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "\t\t\tif (diagram != null) {" + NL + "\t\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\t\t" + NL + "\t\t\t\tResource resource = ((EObject)diagram).eResource();\t" + NL + "\t\t\t\tIFile resourceFile = ResourceUtil.getFile(resource);" + NL + "\t\t\t\trules.add(computeSaveSchedulingRule(resourceFile));" + NL + "\t\t\t\t" + NL + "\t\t\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\t\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\tIFile nextResourceFile = ResourceUtil.getFile(nextResource);" + NL + "\t\t\t\t\trules.add(computeSaveSchedulingRule(nextResourceFile));" + NL + "\t\t\t\t}" + NL + "\t\t\t\t" + NL + "\t\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSaveRule(element);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {" + NL + "\t\tassert document instanceof DiagramDocument;" + NL + "" + NL + "\t\tDiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);" + NL + "\t\tDiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);" + NL + "" + NL + "\t\tdiagramListener.startListening();" + NL + "\t\treturn info;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static Set getReferencedResources(Diagram diagram) {" + NL + "\t\tResource diagramResource = ((EObject) diagram).eResource();" + NL + "\t\tif (diagramResource == null) {" + NL + "\t\t\treturn Collections.EMPTY_SET;" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\treturn new HashSet(MEditingDomain.INSTANCE.getImports(diagramResource));" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))" + NL + "\t\t\treturn fResourceRuleFactory.modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent= toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t /*" + NL + "\t\t\t * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify= parent;" + NL + "\t\t\tparent= toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));" + NL + "" + NL + "\t\treturn fResourceRuleFactory.createRule(toCreateOrModify);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate class CustomModificationListener extends FileDiagramModificationListener {" + NL + "\t" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate MListener myListener = null;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tpublic CustomModificationListener(";
  protected final String TEXT_4 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter, inputParameter);" + NL + "\t \t\tfinal DiagramDocument document = documentParameter;" + NL + "\t\t\tMFilter diagramResourceSavedFilter = new MFilter() {" + NL + "\t\t\t\tpublic boolean matches(Notification notification) {" + NL + "\t\t\t\t\tDiagram diagram = document.getDiagram();" + NL + "\t\t\t\t\tObject notifier = notification.getNotifier();" + NL + "\t\t\t\t\tResource resource = null;" + NL + "\t\t\t\t\tif (notifier instanceof EObject) {" + NL + "\t\t\t\t\t\tresource = ((EObject) notifier).eResource();" + NL + "\t\t\t\t\t} else if (notifier instanceof Resource) {" + NL + "\t\t\t\t\t\tresource = (Resource) notifier;" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tif (diagram != null && resource != null) {" + NL + "\t\t\t\t\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\t\t\t\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\t\t\tif (resource == nextResource) {" + NL + "\t\t\t\t\t\t\t\tif (notifier == resource) {" + NL + "\t\t\t\t\t\t\t\t\treturn notification.getEventType() == Notification.SET && notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_MODIFIED && notification.getNewBooleanValue() == true;" + NL + "\t\t\t\t\t\t\t\t} else {" + NL + "/*" + NL + " * Handling notification from the objects stored in this resource it is necessary " + NL + " * if setTrackingModification(true) was not called. I.e. now for all the objects " + NL + " * stored in external resources. " + NL + " */" + NL + "\t\t\t\t\t\t\t\t\treturn true;" + NL + "\t\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\treturn false;" + NL + "\t\t\t\t};" + NL + "\t\t\t};" + NL + "\t\t\tif (myListener == null) {" + NL + "\t\t\t\tmyListener = new MListener(diagramResourceSavedFilter) {" + NL + "" + NL + "\t\t\t\t\tpublic void onEvent(List events) {" + NL + "\t\t\t\t\t\tdocument.setContent(document.getContent());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t};" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void startListening() {" + NL + "\t\t\tsuper.startListening();" + NL + "\t\t\tmyListener.startListening();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void stopListening() {" + NL + "\t\t\tmyListener.stopListening();" + NL + "\t\t\tsuper.stopListening();" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_5 = NL;
d38 2
d41 1
a41 1
    stringBuffer.append(TEXT_4);
d43 1
a43 1
    stringBuffer.append(TEXT_5);
@


1.6
log
@GenEditorViewer incapsulates all Eclipse's IEditorPart-related info
@
text
@d18 5
a22 7
  protected final String TEXT_1 = "package ";
  protected final String TEXT_2 = ";" + NL;
  protected final String TEXT_3 = NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.Collections;" + NL + "import java.util.HashSet;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "import java.util.Set;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MFilter;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MListener;" + NL + "import org.eclipse.gmf.runtime.emf.core.util.ResourceUtil;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
  protected final String TEXT_4 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_5 = " extends FileDiagramDocumentProvider {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tmonitor.beginTask(\"\", 100); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 20));" + NL + "" + NL + "\t\tIProgressMonitor subMonitor = new SubProgressMonitor(monitor, 20);" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\tsubMonitor.done();" + NL + "\t\t" + NL + "\t\tsubMonitor = new SubProgressMonitor(monitor, 60);" + NL + "\t\tsubMonitor.beginTask(\"Saving external resources\", externalResources.size());" + NL + "\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tsubMonitor.setTaskName(\"Saving \" + nextResource.getURI());" + NL + "\t\t\tResourceUtil.save(nextResource);" + NL + "\t\t\tsubMonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tsubMonitor.done();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tIDiagramDocument diagramDocument = getDiagramDocument(element);" + NL + "\t\tif (diagramDocument != null) {" + NL + "\t\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "\t\t\tif (diagram != null) {" + NL + "\t\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\t\t" + NL + "\t\t\t\tResource resource = ((EObject)diagram).eResource();\t" + NL + "\t\t\t\tIFile resourceFile = ResourceUtil.getFile(resource);" + NL + "\t\t\t\trules.add(computeSaveSchedulingRule(resourceFile));" + NL + "\t\t\t\t" + NL + "\t\t\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\t\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\tIFile nextResourceFile = ResourceUtil.getFile(nextResource);" + NL + "\t\t\t\t\trules.add(computeSaveSchedulingRule(nextResourceFile));" + NL + "\t\t\t\t}" + NL + "\t\t\t\t" + NL + "\t\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSaveRule(element);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {" + NL + "\t\tassert document instanceof DiagramDocument;" + NL + "" + NL + "\t\tDiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);" + NL + "\t\tDiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);" + NL + "" + NL + "\t\tdiagramListener.startListening();" + NL + "\t\treturn info;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static Set getReferencedResources(Diagram diagram) {" + NL + "\t\tResource diagramResource = ((EObject) diagram).eResource();" + NL + "\t\tif (diagramResource == null) {" + NL + "\t\t\treturn Collections.EMPTY_SET;" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\treturn new HashSet(MEditingDomain.INSTANCE.getImports(diagramResource));" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))" + NL + "\t\t\treturn fResourceRuleFactory.modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent= toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t /*" + NL + "\t\t\t * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify= parent;" + NL + "\t\t\tparent= toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));" + NL + "" + NL + "\t\treturn fResourceRuleFactory.createRule(toCreateOrModify);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate class CustomModificationListener extends FileDiagramModificationListener {" + NL + "\t" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate MListener myListener = null;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tpublic CustomModificationListener(";
  protected final String TEXT_6 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter, inputParameter);" + NL + "\t \t\tfinal DiagramDocument document = documentParameter;" + NL + "\t\t\tMFilter diagramResourceSavedFilter = new MFilter() {" + NL + "\t\t\t\tpublic boolean matches(Notification notification) {" + NL + "\t\t\t\t\tDiagram diagram = document.getDiagram();" + NL + "\t\t\t\t\tObject notifier = notification.getNotifier();" + NL + "\t\t\t\t\tResource resource = null;" + NL + "\t\t\t\t\tif (notifier instanceof EObject) {" + NL + "\t\t\t\t\t\tresource = ((EObject) notifier).eResource();" + NL + "\t\t\t\t\t} else if (notifier instanceof Resource) {" + NL + "\t\t\t\t\t\tresource = (Resource) notifier;" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\tif (diagram != null && resource != null) {" + NL + "\t\t\t\t\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\t\t\t\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\t\t\tif (resource == nextResource) {" + NL + "\t\t\t\t\t\t\t\tif (notifier == resource) {" + NL + "\t\t\t\t\t\t\t\t\treturn notification.getEventType() == Notification.SET && notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_MODIFIED && notification.getNewBooleanValue() == true;" + NL + "\t\t\t\t\t\t\t\t} else {" + NL + "/*" + NL + " * Handling notification from the objects stored in this resource it is necessary " + NL + " * if setTrackingModification(true) was not called. I.e. now for all the objects " + NL + " * stored in external resources. " + NL + " */" + NL + "\t\t\t\t\t\t\t\t\treturn true;" + NL + "\t\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\treturn false;" + NL + "\t\t\t\t};" + NL + "\t\t\t};" + NL + "\t\t\tif (myListener == null) {" + NL + "\t\t\t\tmyListener = new MListener(diagramResourceSavedFilter) {" + NL + "" + NL + "\t\t\t\t\tpublic void onEvent(List events) {" + NL + "\t\t\t\t\t\tdocument.setContent(document.getContent());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t};" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void startListening() {" + NL + "\t\t\tsuper.startListening();" + NL + "\t\t\tmyListener.startListening();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void stopListening() {" + NL + "\t\t\tmyListener.stopListening();" + NL + "\t\t\tsuper.stopListening();" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_7 = NL;
d27 5
a31 1
    GenDiagram genDiagram = (GenDiagram) argument;
d33 1
a33 1
    stringBuffer.append(genDiagram.getEditorGen().getEditor().getPackageName());
d35 1
a35 1
    ImportUtil importManager = new ImportUtil(genDiagram.getEditorGen().getEditor().getPackageName());
d37 1
a37 1
    importManager.markImportLocation(stringBuffer);
d39 1
a39 1
    stringBuffer.append(genDiagram.getDocumentProviderClassName());
a40 4
    stringBuffer.append(genDiagram.getDocumentProviderClassName());
    stringBuffer.append(TEXT_6);
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_7);
@


1.5
log
@#126543
Marking editor as dirty on changes in the referenced resources.
@
text
@d31 1
a31 1
    stringBuffer.append(genDiagram.getEditorPackageName());
d33 1
a33 1
    ImportUtil importManager = new ImportUtil(genDiagram.getEditorPackageName());
@


1.4
log
@ImportManager moved to oeg.common
@
text
@d23 1
a23 1
  protected final String TEXT_6 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter, inputParameter);" + NL + "\t \t\tfinal DiagramDocument document = documentParameter;" + NL + "\t\t\tMFilter diagramResourceSavedFilter = new MFilter() {" + NL + "\t\t\t\tpublic boolean matches(Notification notification) {" + NL + "\t\t\t\t\tDiagram diagram = document.getDiagram();" + NL + "\t\t\t\t\tObject notifier = notification.getNotifier();" + NL + "\t\t\t\t\tif (diagram != null && notifier instanceof Resource) {" + NL + "\t\t\t\t\t\tResource notifierResource = (Resource) notifier;" + NL + "\t\t\t\t\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\t\t\t\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\t\t\tif (notifierResource == nextResource) {" + NL + "\t\t\t\t\t\t\t\treturn notification.getEventType() == Notification.SET && notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_MODIFIED && notification.getNewBooleanValue() == true;" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\treturn false;" + NL + "\t\t\t\t};" + NL + "\t\t\t};" + NL + "\t\t\tif (myListener == null) {" + NL + "\t\t\t\tmyListener = new MListener(diagramResourceSavedFilter) {" + NL + "" + NL + "\t\t\t\t\tpublic void onEvent(List events) {" + NL + "\t\t\t\t\t\tdocument.setContent(document.getContent());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t};" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void startListening() {" + NL + "\t\t\tsuper.startListening();" + NL + "\t\t\tmyListener.startListening();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void stopListening() {" + NL + "\t\t\tmyListener.stopListening();" + NL + "\t\t\tsuper.stopListening();" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
@


1.3
log
@#122541
Saving diagram without exceptions.
@
text
@d4 1
a4 1
import org.eclipse.gmf.codegen.util.*;
@


1.2
log
@[ashatalin] #113561 use MEditingDomain.getImports instead of ExternalCrossReferencer
@
text
@d20 1
a20 1
  protected final String TEXT_3 = NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.Collections;" + NL + "import java.util.HashSet;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "import java.util.Map;" + NL + "import java.util.Set;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MFilter;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MListener;" + NL + "import org.eclipse.gmf.runtime.emf.core.resources.ILogicalResource;" + NL + "import org.eclipse.gmf.runtime.emf.core.util.ResourceUtil;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
d22 1
a22 1
  protected final String TEXT_5 = " extends FileDiagramDocumentProvider {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tmonitor.beginTask(\"\", 100); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 20));" + NL + "" + NL + "\t\tIProgressMonitor subMonitor = new SubProgressMonitor(monitor, 20);" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\tsubMonitor.done();" + NL + "\t\t" + NL + "\t\tsubMonitor = new SubProgressMonitor(monitor, 60);" + NL + "\t\tsubMonitor.beginTask(\"Saving external resources\", externalResources.size());" + NL + "\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tsubMonitor.setTaskName(\"Saving \" + nextResource.getURI());" + NL + "\t\t\tResourceUtil.save(nextResource);" + NL + "\t\t\tsubMonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tsubMonitor.done();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tIDiagramDocument diagramDocument = getDiagramDocument(element);" + NL + "\t\tif (diagramDocument != null) {" + NL + "\t\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "\t\t\tif (diagram != null) {" + NL + "\t\t\t\tResource resource = ((EObject)diagram).eResource();\t" + NL + "\t\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\t\tif (resource instanceof ILogicalResource) {" + NL + "\t\t\t\t\tMap resourcesMap = ((ILogicalResource) resource).getMappedResources();" + NL + "\t\t\t\t\tfor (Iterator it = resourcesMap.values().iterator(); it.hasNext();) {" + NL + "\t\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\t\tIFile resourceFile = ResourceUtil.getFile(nextResource);" + NL + "\t\t\t\t\t\trules.add(computeSaveSchedulingRule(resourceFile));" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\trules.add(resource);" + NL + "\t\t\t\t}" + NL + "\t\t\t\t" + NL + "\t\t\t\tSet externalResources = getReferencedResources(diagram);" + NL + "\t\t\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\tIFile resourceFile = ResourceUtil.getFile(nextResource);" + NL + "\t\t\t\t\trules.add(computeSaveSchedulingRule(resourceFile));" + NL + "\t\t\t\t}" + NL + "\t\t\t\t" + NL + "\t\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSaveRule(element);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {" + NL + "\t\tassert document instanceof DiagramDocument;" + NL + "" + NL + "\t\tDiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);" + NL + "\t\tDiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);" + NL + "" + NL + "\t\tdiagramListener.startListening();" + NL + "\t\treturn info;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static Set getReferencedResources(Diagram diagram) {" + NL + "\t\tResource diagramResource = ((EObject) diagram).eResource();" + NL + "\t\tif (diagramResource == null) {" + NL + "\t\t\treturn Collections.EMPTY_SET;" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\treturn new HashSet(MEditingDomain.INSTANCE.getImports(diagramResource));" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))" + NL + "\t\t\treturn fResourceRuleFactory.modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent= toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t /*" + NL + "\t\t\t * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify= parent;" + NL + "\t\t\tparent= toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));" + NL + "" + NL + "\t\treturn fResourceRuleFactory.createRule(toCreateOrModify);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate class CustomModificationListener extends FileDiagramModificationListener {" + NL + "\t" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate MListener myListener = null;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tpublic CustomModificationListener(";
@


1.1
log
@[ashatalin] #112988 use either same as diagram or separate file to persist domain model
@
text
@d20 1
a20 1
  protected final String TEXT_3 = NL + "import java.util.ArrayList;" + NL + "import java.util.Collection;" + NL + "import java.util.HashSet;" + NL + "import java.util.Iterator;" + NL + "import java.util.List;" + NL + "import java.util.Map;" + NL + "import java.util.Set;" + NL + "" + NL + "import org.eclipse.core.resources.IFile;" + NL + "import org.eclipse.core.resources.IResource;" + NL + "import org.eclipse.core.runtime.CoreException;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.core.runtime.NullProgressMonitor;" + NL + "import org.eclipse.core.runtime.SubProgressMonitor;" + NL + "import org.eclipse.core.runtime.jobs.ISchedulingRule;" + NL + "import org.eclipse.core.runtime.jobs.MultiRule;" + NL + "import org.eclipse.emf.common.notify.Notification;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.resource.Resource;" + NL + "import org.eclipse.emf.ecore.util.EcoreUtil;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramDocumentProvider;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.resources.editor.ide.document.FileDiagramModificationListener;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MFilter;" + NL + "import org.eclipse.gmf.runtime.emf.core.edit.MListener;" + NL + "import org.eclipse.gmf.runtime.emf.core.resources.ILogicalResource;" + NL + "import org.eclipse.gmf.runtime.emf.core.util.ResourceUtil;" + NL + "import org.eclipse.gmf.runtime.notation.Diagram;" + NL + "import org.eclipse.ui.IFileEditorInput;";
d22 2
a23 2
  protected final String TEXT_5 = " extends FileDiagramDocumentProvider {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void saveDocumentToFile(IDocument document, IFile file, boolean overwrite, IProgressMonitor monitor) throws CoreException {" + NL + "\t\tmonitor.beginTask(\"\", 100); //$NON-NLS-1$" + NL + "\t\tsuper.saveDocumentToFile(document, file, overwrite, new SubProgressMonitor(monitor, 20));" + NL + "" + NL + "\t\tIProgressMonitor subMonitor = new SubProgressMonitor(monitor, 50);" + NL + "\t\tDiagram diagram = (Diagram)document.getContent();" + NL + "\t\tSet externalResources = getReferencedResources(diagram, subMonitor);" + NL + "\t\t" + NL + "\t\tsubMonitor = new SubProgressMonitor(monitor, 30);" + NL + "\t\tsubMonitor.beginTask(\"Saving external resources\", externalResources.size());" + NL + "\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\tsubMonitor.setTaskName(\"Saving \" + nextResource.getURI());" + NL + "\t\t\tResourceUtil.save(nextResource);" + NL + "\t\t\tsubMonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tsubMonitor.done();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ISchedulingRule getSaveRule(Object element) {" + NL + "\t\tIDiagramDocument diagramDocument = getDiagramDocument(element);" + NL + "\t\tif (diagramDocument != null) {" + NL + "\t\t\tDiagram diagram = diagramDocument.getDiagram();" + NL + "\t\t\tif (diagram != null) {" + NL + "\t\t\t\tResource resource = ((EObject)diagram).eResource();\t" + NL + "\t\t\t\tCollection rules = new ArrayList();" + NL + "\t\t\t\tif (resource instanceof ILogicalResource) {" + NL + "\t\t\t\t\tMap resourcesMap = ((ILogicalResource) resource).getMappedResources();" + NL + "\t\t\t\t\tfor (Iterator it = resourcesMap.values().iterator(); it.hasNext();) {" + NL + "\t\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\t\tIFile resourceFile = ResourceUtil.getFile(nextResource);" + NL + "\t\t\t\t\t\trules.add(computeSaveSchedulingRule(resourceFile));" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\trules.add(resource);" + NL + "\t\t\t\t}" + NL + "\t\t\t\t" + NL + "\t\t\t\tSet externalResources = getReferencedResources(diagram, new NullProgressMonitor());" + NL + "\t\t\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\tIFile resourceFile = ResourceUtil.getFile(nextResource);" + NL + "\t\t\t\t\trules.add(computeSaveSchedulingRule(resourceFile));" + NL + "\t\t\t\t}" + NL + "\t\t\t\t" + NL + "\t\t\t\treturn new MultiRule((ISchedulingRule[]) rules.toArray(new ISchedulingRule[rules.size()]));" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn super.getSaveRule(element);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected FileInfo createFileInfo(IDocument document, FileSynchronizer synchronizer, IFileEditorInput input) {" + NL + "\t\tassert document instanceof DiagramDocument;" + NL + "" + NL + "\t\tDiagramModificationListener diagramListener = new CustomModificationListener(this, (DiagramDocument) document, input);" + NL + "\t\tDiagramFileInfo info = new DiagramFileInfo(document, synchronizer, diagramListener);" + NL + "" + NL + "\t\tdiagramListener.startListening();" + NL + "\t\treturn info;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static Set getReferencedResources(Diagram diagram, IProgressMonitor monitor) {" + NL + "\t\tmonitor.beginTask(\"Collecting referenced resources\", 3);" + NL + "\t\tMap externalReferences = EcoreUtil.ExternalCrossReferencer.find(diagram);" + NL + "\t\tmonitor.worked(2);" + NL + "\t\t" + NL + "\t\tIProgressMonitor subMonitor = new SubProgressMonitor(monitor, 1);" + NL + "\t\tsubMonitor.beginTask(\"Collecting external resources\", externalReferences.size());" + NL + "\t\tSet externalResources = new HashSet();" + NL + "\t\tfor (Iterator it = externalReferences.keySet().iterator(); it.hasNext();) {" + NL + "\t\t\tEObject nextExternalObject = (EObject) it.next();" + NL + "\t\t\tResource resource = nextExternalObject.eResource();" + NL + "\t\t\tif (resource != null) {" + NL + "\t\t\t\texternalResources.add(resource);" + NL + "\t\t\t}" + NL + "\t\t\tsubMonitor.worked(1);" + NL + "\t\t}" + NL + "\t\tsubMonitor.done();" + NL + "\t\tmonitor.done();" + NL + "\t\treturn externalResources;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ISchedulingRule computeSaveSchedulingRule(IResource toCreateOrModify) {" + NL + "\t\tif (toCreateOrModify.exists() && toCreateOrModify.isSynchronized(IResource.DEPTH_ZERO))" + NL + "\t\t\treturn fResourceRuleFactory.modifyRule(toCreateOrModify);" + NL + "" + NL + "\t\tIResource parent= toCreateOrModify;" + NL + "\t\tdo {" + NL + "\t\t\t /*" + NL + "\t\t\t * XXX This is a workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=67601" + NL + "\t\t\t * IResourceRuleFactory.createRule should iterate the hierarchy itself." + NL + "\t\t\t */" + NL + "\t\t\ttoCreateOrModify= parent;" + NL + "\t\t\tparent= toCreateOrModify.getParent();" + NL + "\t\t} while (parent != null && !parent.exists() && !parent.isSynchronized(IResource.DEPTH_ZERO));" + NL + "" + NL + "\t\treturn fResourceRuleFactory.createRule(toCreateOrModify);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate class CustomModificationListener extends FileDiagramModificationListener {" + NL + "\t" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate MListener myListener = null;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t \tpublic CustomModificationListener(";
  protected final String TEXT_6 = " documentProviderParameter, DiagramDocument documentParameter, IFileEditorInput inputParameter) {" + NL + "\t\t\tsuper(documentProviderParameter, documentParameter, inputParameter);" + NL + "\t \t\tfinal DiagramDocument document = documentParameter;" + NL + "\t\t\tMFilter diagramResourceSavedFilter = new MFilter() {" + NL + "\t\t\t\tpublic boolean matches(Notification notification) {" + NL + "\t\t\t\t\tDiagram diagram = document.getDiagram();" + NL + "\t\t\t\t\tObject notifier = notification.getNotifier();" + NL + "\t\t\t\t\tif (diagram != null && notifier instanceof Resource) {" + NL + "\t\t\t\t\t\tResource notifierResource = (Resource) notifier;" + NL + "\t\t\t\t\t\tSet externalResources = getReferencedResources(diagram, new NullProgressMonitor());" + NL + "\t\t\t\t\t\tfor (Iterator it = externalResources.iterator(); it.hasNext();) {" + NL + "\t\t\t\t\t\t\tResource nextResource = (Resource) it.next();" + NL + "\t\t\t\t\t\t\tif (notifierResource == nextResource) {" + NL + "\t\t\t\t\t\t\t\treturn notification.getEventType() == Notification.SET && notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_MODIFIED && notification.getNewBooleanValue() == true;" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\treturn false;" + NL + "\t\t\t\t};" + NL + "\t\t\t};" + NL + "\t\t\tif (myListener == null) {" + NL + "\t\t\t\tmyListener = new MListener(diagramResourceSavedFilter) {" + NL + "" + NL + "\t\t\t\t\tpublic void onEvent(List events) {" + NL + "\t\t\t\t\t\tdocument.setContent(document.getContent());" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t};" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void startListening() {" + NL + "\t\t\tsuper.startListening();" + NL + "\t\t\tmyListener.startListening();" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic void stopListening() {" + NL + "\t\t\tmyListener.stopListening();" + NL + "\t\t\tsuper.stopListening();" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "}";
@

