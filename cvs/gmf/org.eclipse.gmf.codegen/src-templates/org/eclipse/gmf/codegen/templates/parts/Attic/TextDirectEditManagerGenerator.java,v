head	1.8;
access;
symbols
	v20081022-1925:1.8
	v20081015-1925:1.8
	v20081008-1925:1.8
	v20081001-1925:1.8
	v20080924-1925:1.8
	v20080917-1925:1.8
	v20080911-1728:1.8
	v20080910-1520:1.8
	v20080903-1520:1.8
	v20080827-1520:1.8
	v20080813-1520:1.8
	v20080806-1520:1.8
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	I20060407-1200:1.4
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2006.04.12.16.28.45;	author dstadnik;	state dead;
branches;
next	1.7;

1.7
date	2006.04.08.17.19.56;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.08.16.56.37;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.08.11.41.49;	author dstadnik;	state dead;
branches;
next	1.4;

1.4
date	2006.04.07.14.49.25;	author ashatalin;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.14.13.14.55;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.13.18.39.47;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.13.11.02.30;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.8
log
@#135694 remove temporary code
@
text
@package org.eclipse.gmf.codegen.templates.parts;

import org.eclipse.gmf.codegen.gmfgen.*;
import org.eclipse.gmf.common.codegen.*;

public class TextDirectEditManagerGenerator
{
  protected static String nl;
  public static synchronized TextDirectEditManagerGenerator create(String lineSeparator)
  {
    nl = lineSeparator;
    TextDirectEditManagerGenerator result = new TextDirectEditManagerGenerator();
    nl = null;
    return result;
  }

  protected final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + "/*" + NL + " * ";
  protected final String TEXT_3 = NL + " */";
  protected final String TEXT_4 = NL + "package ";
  protected final String TEXT_5 = ";" + NL + "" + NL + "import org.eclipse.draw2d.FigureUtilities;" + NL + "import org.eclipse.draw2d.IFigure;" + NL + "import org.eclipse.draw2d.Label;" + NL + "import org.eclipse.draw2d.geometry.Dimension;" + NL + "import org.eclipse.draw2d.geometry.Rectangle;" + NL + "import org.eclipse.gef.GraphicalEditPart;" + NL + "import org.eclipse.gef.tools.CellEditorLocator;" + NL + "import org.eclipse.gef.tools.DirectEditManager;" + NL + "import org.eclipse.gmf.runtime.common.ui.contentassist.ContentAssistantHelper;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;" + NL + "import org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel;" + NL + "import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;" + NL + "import org.eclipse.gmf.runtime.gef.ui.internal.parts.TextCellEditorEx;" + NL + "import org.eclipse.gmf.runtime.gef.ui.internal.parts.WrapTextCellEditor;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;" + NL + "import org.eclipse.jface.util.Assert;" + NL + "import org.eclipse.jface.viewers.CellEditor;" + NL + "import org.eclipse.swt.SWT;" + NL + "import org.eclipse.swt.graphics.Color;" + NL + "import org.eclipse.swt.graphics.Font;" + NL + "import org.eclipse.swt.graphics.FontData;" + NL + "import org.eclipse.swt.graphics.Point;" + NL + "import org.eclipse.swt.graphics.RGB;" + NL + "import org.eclipse.swt.widgets.Control;" + NL + "import org.eclipse.swt.widgets.Display;" + NL + "import org.eclipse.swt.widgets.Event;" + NL + "import org.eclipse.swt.widgets.Shell;" + NL + "import org.eclipse.swt.widgets.Table;" + NL + "import org.eclipse.swt.widgets.Text;";
  protected final String TEXT_6 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class TextDirectEditManager extends DirectEditManager {" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate Color proposalPopupBackgroundColor = null;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate Color proposalPopupForegroundColor = null;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean committed = false;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean listenersAttached = true;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tstatic private class WrapTextCellEditorLocator implements CellEditorLocator {" + NL + "" + NL + "\t\tprivate WrapLabel wrapLabel;" + NL + "\t\t" + NL + "\t\tpublic WrapTextCellEditorLocator(WrapLabel wrapLabel) {" + NL + "\t\t\tsuper();" + NL + "\t\t\tthis.wrapLabel = wrapLabel;" + NL + "\t\t}" + NL + "" + NL + "\t\t" + NL + "\t\tpublic WrapLabel getWrapLabel() {" + NL + "\t\t\treturn wrapLabel;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic void relocate(CellEditor celleditor) {" + NL + "\t\t\tText text = (Text) celleditor.getControl();" + NL + "\t\t\tRectangle rect = getWrapLabel().getTextBounds().getCopy();" + NL + "\t\t\tgetWrapLabel().translateToAbsolute(rect);" + NL + "\t\t\t" + NL + "\t\t\tif (getWrapLabel().isTextWrapped() && getWrapLabel().getText().length() > 0)" + NL + "\t\t\t\trect.setSize(new Dimension(text.computeSize(rect.width, SWT.DEFAULT)));" + NL + "\t\t\telse {" + NL + "\t\t\t\tint avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();" + NL + "\t\t\t\trect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr*2, 0));" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\tif (!rect.equals(new Rectangle(text.getBounds())))" + NL + "\t\t\t\ttext.setBounds(rect.x, rect.y, rect.width, rect.height);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tstatic private class TextCellEditorLocator implements CellEditorLocator {" + NL + "" + NL + "\t\tprivate Label label;" + NL + "" + NL + "\t\tpublic TextCellEditorLocator(Label label) {" + NL + "\t\t\tsuper();" + NL + "\t\t\tthis.label = label;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic Label getLabel() {" + NL + "\t\t\treturn label;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic void relocate(CellEditor celleditor) {" + NL + "\t\t\tText text = (Text) celleditor.getControl();" + NL + "\t\t\tRectangle rect = getLabel().getTextBounds().getCopy();" + NL + "\t\t\tgetLabel().translateToAbsolute(rect);" + NL + "" + NL + "\t\t\tint avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();" + NL + "\t\t\trect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));" + NL + "" + NL + "\t\t\tif (!rect.equals(new Rectangle(text.getBounds())))" + NL + "\t\t\t\ttext.setBounds(rect.x, rect.y, rect.width, rect.height);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic TextDirectEditManager(ITextAwareEditPart source) {" + NL + "\t\tsuper(source, getTextCellEditorClass(source), getCellEditorLocator(source.getFigure()));" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic TextDirectEditManager(GraphicalEditPart source, Class editorType, CellEditorLocator locator) {" + NL + "\t\tsuper(source, editorType, locator);\t\t" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static CellEditorLocator getCellEditorLocator(IFigure label) {" + NL + "\t\tif (label instanceof Label) {" + NL + "\t\t\treturn new TextCellEditorLocator((Label) label);" + NL + "\t\t}" + NL + "\t\treturn new WrapTextCellEditorLocator((WrapLabel) label);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static Class getTextCellEditorClass(ITextAwareEditPart source) {" + NL + "\t\tIFigure label = source.getFigure();" + NL + "" + NL + "\t\tif (label instanceof WrapLabel && ((WrapLabel) label).isTextWrapped())" + NL + "\t\t\treturn WrapTextCellEditor.class;" + NL + "" + NL + "\t\treturn TextCellEditorEx.class;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Font getScaledFont(IFigure label) {" + NL + "\t\tFont scaledFont = label.getFont();" + NL + "\t\tFontData data = scaledFont.getFontData()[0];" + NL + "\t\tDimension fontSize = new Dimension(0, MapModeUtil.getMapMode(label).DPtoLP(data.getHeight()));" + NL + "\t\tlabel.translateToAbsolute(fontSize);" + NL + "\t\t" + NL + "\t\tif( Math.abs( data.getHeight() - fontSize.height ) < 2 )" + NL + "\t\t\tfontSize.height = data.getHeight();" + NL + "" + NL + "\t\tdata.setHeight(fontSize.height);" + NL + "\t\tFont newFont = DiagramFontRegistry.getInstance().getFont(null, data);" + NL + "\t\treturn newFont;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void initCellEditor() {" + NL + "\t\tcommitted = false;" + NL + "" + NL + "\t\t// Get the Text Compartments Edit Part" + NL + "\t\tITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();" + NL + "" + NL + "\t\tsetEditText(textEP.getEditText());" + NL + "" + NL + "\t\tIFigure label = textEP.getFigure();" + NL + "\t\tAssert.isNotNull(label);" + NL + "\t\tText text = (Text) getCellEditor().getControl();" + NL + "\t\t// scale the font accordingly to the zoom level" + NL + "\t\ttext.setFont(getScaledFont(label));" + NL + "\t\t" + NL + "\t\t" + NL + "\t\t// register a validator on the cell editor" + NL + "\t\tgetCellEditor().setValidator(textEP.getEditTextValidator());" + NL + "" + NL + "\t\tif (textEP.getParser() != null) {" + NL + "\t\t\tIContentAssistProcessor processor = textEP.getCompletionProcessor();" + NL + "\t\t\tif (processor != null) {" + NL + "\t\t\t\t// register content assist" + NL + "\t\t\t\tproposalPopupBackgroundColor = new Color(getCellEditor()" + NL + "\t\t\t\t\t.getControl().getShell().getDisplay(), new RGB(254, 241," + NL + "\t\t\t\t\t233));" + NL + "\t\t\t\tproposalPopupForegroundColor = new Color(getCellEditor()" + NL + "\t\t\t\t\t.getControl().getShell().getDisplay(), new RGB(0, 0, 0));" + NL + "" + NL + "\t\t\t\tContentAssistantHelper.createTextContentAssistant(text," + NL + "\t\t\t\t\tproposalPopupForegroundColor, proposalPopupBackgroundColor," + NL + "\t\t\t\t\tprocessor);" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void commit() {" + NL + "\t\tShell activeShell = Display.getCurrent().getActiveShell();" + NL + "\t\tif (activeShell != null" + NL + "\t\t\t&& getCellEditor().getControl().getShell().equals(" + NL + "\t\t\t\tactiveShell.getParent())) {" + NL + "\t\t\tControl[] children = activeShell.getChildren();" + NL + "\t\t\tif (children.length == 1 && children[0] instanceof Table) {" + NL + "\t\t\t\t/*" + NL + "\t\t\t\t * CONTENT ASSIST: focus is lost to the content assist pop up -" + NL + "\t\t\t\t * stay in focus" + NL + "\t\t\t\t */" + NL + "\t\t\t\tgetCellEditor().getControl().setVisible(true);" + NL + "\t\t\t\t((TextCellEditorEx) getCellEditor()).setDeactivationLock(true);" + NL + "\t\t\t\treturn;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t\t// content assist hacks" + NL + "\t\tif (committed) {" + NL + "\t\t\tbringDown();" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tcommitted = true;" + NL + "\t\tsuper.commit();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void bringDown() {" + NL + "\t\tif (proposalPopupForegroundColor != null) {" + NL + "\t\t\tproposalPopupForegroundColor.dispose();" + NL + "\t\t\tproposalPopupForegroundColor = null;" + NL + "\t\t}" + NL + "\t\tif (proposalPopupBackgroundColor != null) {" + NL + "\t\t\tproposalPopupBackgroundColor.dispose();" + NL + "\t\t\tproposalPopupBackgroundColor = null;" + NL + "\t\t}" + NL + "" + NL + "\t\t// myee - RATLC00523014: crashes when queued in asyncExec()" + NL + "\t\teraseFeedback();" + NL + "\t\t" + NL + "\t\tDisplay.getCurrent().asyncExec(new Runnable() {" + NL + "" + NL + "\t\t\tpublic void run() {" + NL + "\t\t\t\t// Content Assist hack - allow proper cleanup on childen" + NL + "\t\t\t\t// controls" + NL + "\t\t\t\tTextDirectEditManager.super.bringDown();" + NL + "\t\t\t}" + NL + "\t\t});" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditText(String toEdit) {" + NL + "" + NL + "\t\t// Get the cell editor" + NL + "\t\tCellEditor cellEditor = getCellEditor();" + NL + "" + NL + "\t\t// IF the cell editor doesn't exist yet..." + NL + "\t\tif (cellEditor == null) {" + NL + "\t\t\t// Do nothing" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "" + NL + "\t\t// Get the Text Compartment Edit Part" + NL + "\t\tITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();" + NL + "" + NL + "\t\t// Get the Text control" + NL + "\t\tText textControl = (Text) cellEditor.getControl();" + NL + "" + NL + "\t\t// Get the Text Edit Part's Figure (WrapLabel)" + NL + "\t\tIFigure label = textEP.getFigure();" + NL + "\t\tAssert.isNotNull(label);" + NL + "\t\t// Set the Figures text" + NL + "\t\tif (label instanceof Label) {" + NL + "\t\t\t((Label) label).setText(toEdit);" + NL + "\t\t} else {" + NL + "\t\t\t((WrapLabel) label).setText(toEdit);" + NL + "\t\t}" + NL + "\t\tObject pdEditPolicy = textEP.getEditPolicy(";
  protected final String TEXT_7 = ".PRIMARY_DRAG_ROLE);" + NL + "\t\tif (pdEditPolicy instanceof ";
  protected final String TEXT_8 = ") {" + NL + "\t\t\t((";
  protected final String TEXT_9 = ") pdEditPolicy).refreshFeedback();" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\t// See RATLC00522324" + NL + "\t\tif (cellEditor instanceof TextCellEditorEx){" + NL + "\t\t\t((TextCellEditorEx)cellEditor).setValueAndProcessEditOccured(toEdit);" + NL + "\t\t} else {" + NL + "\t\t\tcellEditor.setValue(toEdit);" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\t// Set the controls text and position the caret at the end of the text" + NL + "\t\ttextControl.setSelection(toEdit.length());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void show(char initialChar) {" + NL + "\t\t" + NL + "\t\tshow();" + NL + "\t\t// Set the cell editor text to the initial character" + NL + "\t\tString initialString = String.valueOf(initialChar);" + NL + "\t\tsetEditText(initialString);" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void show(Point location) {\t\t" + NL + "\t\tshow();" + NL + "\t\tsendMouseClick(location);\t" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void sendMouseClick(Point location) {\t\t" + NL + "\t\t" + NL + "\t\tfinal Display currDisplay = Display.getCurrent();" + NL + "\t\tfinal Point currLocation = location;" + NL + "\t\tnew Thread() {" + NL + "\t\t\tEvent event;" + NL + "\t\t\tpublic void run() {" + NL + "\t\t\t\t\tevent = new Event();" + NL + "\t\t\t\t\tevent.type = SWT.MouseDown;" + NL + "\t\t\t\t\tevent.button = 1;" + NL + "\t\t\t\t\tevent.x = currLocation.x;" + NL + "\t\t\t\t\tevent.y = currLocation.y;" + NL + "\t\t\t\t\tcurrDisplay.post(event);" + NL + "\t\t\t\t\tevent.type = SWT.MouseUp;" + NL + "\t\t\t\t\tcurrDisplay.post(event);" + NL + "\t\t\t}" + NL + "\t\t}.start();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void unhookListeners() {" + NL + "\t\tif (listenersAttached) {" + NL + "\t\t\tlistenersAttached = false;" + NL + "\t\t\tsuper.unhookListeners();" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setCellEditor(CellEditor editor) {" + NL + "\t\tsuper.setCellEditor(editor);" + NL + "\t\tif (editor != null) {" + NL + "\t\t\tlistenersAttached = true;" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void showFeedback() {" + NL + "\t\ttry {" + NL + "\t\t\tgetEditPart().getRoot();" + NL + "\t\t\tsuper.showFeedback();" + NL + "\t\t} catch (Exception e) {" + NL + "\t\t\t// TODO: handle exception" + NL + "\t\t}\t" + NL + "\t}" + NL + "}";
  protected final String TEXT_10 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    
GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];

    stringBuffer.append(TEXT_1);
    
String copyrightText = genDiagram.getEditorGen().getCopyrightText();
if (copyrightText != null && copyrightText.trim().length() > 0) {

    stringBuffer.append(TEXT_2);
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
    stringBuffer.append(TEXT_3);
    }
    stringBuffer.append(TEXT_4);
    stringBuffer.append(genDiagram.getEditPartsPackageName());
    stringBuffer.append(TEXT_5);
    
ImportUtil importManager = new ImportUtil(genDiagram.getEditPartsPackageName());
importManager.markImportLocation(stringBuffer);

    stringBuffer.append(TEXT_6);
    stringBuffer.append(importManager.getImportedName("org.eclipse.gef.EditPolicy"));
    stringBuffer.append(TEXT_7);
    stringBuffer.append(importManager.getImportedName(genDiagram.getTextSelectionEditPolicyQualifiedClassName()));
    stringBuffer.append(TEXT_8);
    stringBuffer.append(importManager.getImportedName(genDiagram.getTextSelectionEditPolicyQualifiedClassName()));
    stringBuffer.append(TEXT_9);
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_10);
    return stringBuffer.toString();
  }
}
@


1.7
log
@using M6 to generate code.
@
text
@@


1.6
log
@restore generators
@
text
@d31 1
a31 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.5
log
@#134095 do not store compiled templates in cvs
@
text
@d31 1
a31 1
    final StringBuffer stringBuffer = new StringBuffer();
@


1.4
log
@Switching to eclipse M6.
@
text
@@


1.3
log
@provide custom text selection edit policy
@
text
@d31 1
a31 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.2
log
@use Labels instead of WrapLabels
@
text
@d4 1
d22 6
a27 2
  protected final String TEXT_5 = ";" + NL + "" + NL + "import org.eclipse.draw2d.FigureUtilities;" + NL + "import org.eclipse.draw2d.IFigure;" + NL + "import org.eclipse.draw2d.Label;" + NL + "import org.eclipse.draw2d.geometry.Dimension;" + NL + "import org.eclipse.draw2d.geometry.Rectangle;" + NL + "import org.eclipse.gef.GraphicalEditPart;" + NL + "import org.eclipse.gef.tools.CellEditorLocator;" + NL + "import org.eclipse.gef.tools.DirectEditManager;" + NL + "import org.eclipse.gmf.runtime.common.ui.contentassist.ContentAssistantHelper;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;" + NL + "import org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel;" + NL + "import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;" + NL + "import org.eclipse.gmf.runtime.gef.ui.internal.parts.TextCellEditorEx;" + NL + "import org.eclipse.gmf.runtime.gef.ui.internal.parts.WrapTextCellEditor;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;" + NL + "import org.eclipse.jface.util.Assert;" + NL + "import org.eclipse.jface.viewers.CellEditor;" + NL + "import org.eclipse.swt.SWT;" + NL + "import org.eclipse.swt.graphics.Color;" + NL + "import org.eclipse.swt.graphics.Font;" + NL + "import org.eclipse.swt.graphics.FontData;" + NL + "import org.eclipse.swt.graphics.Point;" + NL + "import org.eclipse.swt.graphics.RGB;" + NL + "import org.eclipse.swt.widgets.Control;" + NL + "import org.eclipse.swt.widgets.Display;" + NL + "import org.eclipse.swt.widgets.Event;" + NL + "import org.eclipse.swt.widgets.Shell;" + NL + "import org.eclipse.swt.widgets.Table;" + NL + "import org.eclipse.swt.widgets.Text;" + NL + "" + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class TextDirectEditManager extends DirectEditManager {" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate Color proposalPopupBackgroundColor = null;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate Color proposalPopupForegroundColor = null;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean committed = false;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean listenersAttached = true;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tstatic private class WrapTextCellEditorLocator implements CellEditorLocator {" + NL + "" + NL + "\t\tprivate WrapLabel wrapLabel;" + NL + "\t\t" + NL + "\t\tpublic WrapTextCellEditorLocator(WrapLabel wrapLabel) {" + NL + "\t\t\tsuper();" + NL + "\t\t\tthis.wrapLabel = wrapLabel;" + NL + "\t\t}" + NL + "" + NL + "\t\t" + NL + "\t\tpublic WrapLabel getWrapLabel() {" + NL + "\t\t\treturn wrapLabel;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic void relocate(CellEditor celleditor) {" + NL + "\t\t\tText text = (Text) celleditor.getControl();" + NL + "\t\t\tRectangle rect = getWrapLabel().getTextBounds().getCopy();" + NL + "\t\t\tgetWrapLabel().translateToAbsolute(rect);" + NL + "\t\t\t" + NL + "\t\t\tif (getWrapLabel().isTextWrapped() && getWrapLabel().getText().length() > 0)" + NL + "\t\t\t\trect.setSize(new Dimension(text.computeSize(rect.width, SWT.DEFAULT)));" + NL + "\t\t\telse {" + NL + "\t\t\t\tint avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();" + NL + "\t\t\t\trect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr*2, 0));" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\tif (!rect.equals(new Rectangle(text.getBounds())))" + NL + "\t\t\t\ttext.setBounds(rect.x, rect.y, rect.width, rect.height);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tstatic private class TextCellEditorLocator implements CellEditorLocator {" + NL + "" + NL + "\t\tprivate Label label;" + NL + "" + NL + "\t\tpublic TextCellEditorLocator(Label label) {" + NL + "\t\t\tsuper();" + NL + "\t\t\tthis.label = label;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic Label getLabel() {" + NL + "\t\t\treturn label;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic void relocate(CellEditor celleditor) {" + NL + "\t\t\tText text = (Text) celleditor.getControl();" + NL + "\t\t\tRectangle rect = getLabel().getTextBounds().getCopy();" + NL + "\t\t\tgetLabel().translateToAbsolute(rect);" + NL + "" + NL + "\t\t\tint avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();" + NL + "\t\t\trect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));" + NL + "" + NL + "\t\t\tif (!rect.equals(new Rectangle(text.getBounds())))" + NL + "\t\t\t\ttext.setBounds(rect.x, rect.y, rect.width, rect.height);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic TextDirectEditManager(ITextAwareEditPart source) {" + NL + "\t\tsuper(source, getTextCellEditorClass(source), getCellEditorLocator(source.getFigure()));" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic TextDirectEditManager(GraphicalEditPart source, Class editorType, CellEditorLocator locator) {" + NL + "\t\tsuper(source, editorType, locator);\t\t" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static CellEditorLocator getCellEditorLocator(IFigure label) {" + NL + "\t\tif (label instanceof Label) {" + NL + "\t\t\treturn new TextCellEditorLocator((Label) label);" + NL + "\t\t}" + NL + "\t\treturn new WrapTextCellEditorLocator((WrapLabel) label);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static Class getTextCellEditorClass(ITextAwareEditPart source) {" + NL + "\t\tIFigure label = source.getFigure();" + NL + "" + NL + "\t\tif (label instanceof WrapLabel && ((WrapLabel) label).isTextWrapped())" + NL + "\t\t\treturn WrapTextCellEditor.class;" + NL + "" + NL + "\t\treturn TextCellEditorEx.class;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Font getScaledFont(IFigure label) {" + NL + "\t\tFont scaledFont = label.getFont();" + NL + "\t\tFontData data = scaledFont.getFontData()[0];" + NL + "\t\tDimension fontSize = new Dimension(0, MapModeUtil.getMapMode(label).DPtoLP(data.getHeight()));" + NL + "\t\tlabel.translateToAbsolute(fontSize);" + NL + "\t\t" + NL + "\t\tif( Math.abs( data.getHeight() - fontSize.height ) < 2 )" + NL + "\t\t\tfontSize.height = data.getHeight();" + NL + "" + NL + "\t\tdata.setHeight(fontSize.height);" + NL + "\t\tFont newFont = DiagramFontRegistry.getInstance().getFont(null, data);" + NL + "\t\treturn newFont;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void initCellEditor() {" + NL + "\t\tcommitted = false;" + NL + "" + NL + "\t\t// Get the Text Compartments Edit Part" + NL + "\t\tITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();" + NL + "" + NL + "\t\tsetEditText(textEP.getEditText());" + NL + "" + NL + "\t\tIFigure label = textEP.getFigure();" + NL + "\t\tAssert.isNotNull(label);" + NL + "\t\tText text = (Text) getCellEditor().getControl();" + NL + "\t\t// scale the font accordingly to the zoom level" + NL + "\t\ttext.setFont(getScaledFont(label));" + NL + "\t\t" + NL + "\t\t" + NL + "\t\t// register a validator on the cell editor" + NL + "\t\tgetCellEditor().setValidator(textEP.getEditTextValidator());" + NL + "" + NL + "\t\tif (textEP.getParser() != null) {" + NL + "\t\t\tIContentAssistProcessor processor = textEP.getCompletionProcessor();" + NL + "\t\t\tif (processor != null) {" + NL + "\t\t\t\t// register content assist" + NL + "\t\t\t\tproposalPopupBackgroundColor = new Color(getCellEditor()" + NL + "\t\t\t\t\t.getControl().getShell().getDisplay(), new RGB(254, 241," + NL + "\t\t\t\t\t233));" + NL + "\t\t\t\tproposalPopupForegroundColor = new Color(getCellEditor()" + NL + "\t\t\t\t\t.getControl().getShell().getDisplay(), new RGB(0, 0, 0));" + NL + "" + NL + "\t\t\t\tContentAssistantHelper.createTextContentAssistant(text," + NL + "\t\t\t\t\tproposalPopupForegroundColor, proposalPopupBackgroundColor," + NL + "\t\t\t\t\tprocessor);" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void commit() {" + NL + "\t\tShell activeShell = Display.getCurrent().getActiveShell();" + NL + "\t\tif (activeShell != null" + NL + "\t\t\t&& getCellEditor().getControl().getShell().equals(" + NL + "\t\t\t\tactiveShell.getParent())) {" + NL + "\t\t\tControl[] children = activeShell.getChildren();" + NL + "\t\t\tif (children.length == 1 && children[0] instanceof Table) {" + NL + "\t\t\t\t/*" + NL + "\t\t\t\t * CONTENT ASSIST: focus is lost to the content assist pop up -" + NL + "\t\t\t\t * stay in focus" + NL + "\t\t\t\t */" + NL + "\t\t\t\tgetCellEditor().getControl().setVisible(true);" + NL + "\t\t\t\t((TextCellEditorEx) getCellEditor()).setDeactivationLock(true);" + NL + "\t\t\t\treturn;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t\t// content assist hacks" + NL + "\t\tif (committed) {" + NL + "\t\t\tbringDown();" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tcommitted = true;" + NL + "\t\tsuper.commit();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void bringDown() {" + NL + "\t\tif (proposalPopupForegroundColor != null) {" + NL + "\t\t\tproposalPopupForegroundColor.dispose();" + NL + "\t\t\tproposalPopupForegroundColor = null;" + NL + "\t\t}" + NL + "\t\tif (proposalPopupBackgroundColor != null) {" + NL + "\t\t\tproposalPopupBackgroundColor.dispose();" + NL + "\t\t\tproposalPopupBackgroundColor = null;" + NL + "\t\t}" + NL + "" + NL + "\t\t// myee - RATLC00523014: crashes when queued in asyncExec()" + NL + "\t\teraseFeedback();" + NL + "\t\t" + NL + "\t\tDisplay.getCurrent().asyncExec(new Runnable() {" + NL + "" + NL + "\t\t\tpublic void run() {" + NL + "\t\t\t\t// Content Assist hack - allow proper cleanup on childen" + NL + "\t\t\t\t// controls" + NL + "\t\t\t\tTextDirectEditManager.super.bringDown();" + NL + "\t\t\t}" + NL + "\t\t});" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditText(String toEdit) {" + NL + "" + NL + "\t\t// Get the cell editor" + NL + "\t\tCellEditor cellEditor = getCellEditor();" + NL + "" + NL + "\t\t// IF the cell editor doesn't exist yet..." + NL + "\t\tif (cellEditor == null) {" + NL + "\t\t\t// Do nothing" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "" + NL + "\t\t// Get the Text Compartment Edit Part" + NL + "\t\tITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();" + NL + "" + NL + "\t\t// Get the Text control" + NL + "\t\tText textControl = (Text) cellEditor.getControl();" + NL + "" + NL + "\t\t// Get the Text Edit Part's Figure (WrapLabel)" + NL + "\t\tIFigure label = textEP.getFigure();" + NL + "\t\tAssert.isNotNull(label);" + NL + "\t\t// Set the Figures text" + NL + "\t\tif (label instanceof Label) {" + NL + "\t\t\t((Label) label).setText(toEdit);" + NL + "\t\t} else {" + NL + "\t\t\t((WrapLabel) label).setText(toEdit);" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\t// See RATLC00522324" + NL + "\t\tif (cellEditor instanceof TextCellEditorEx){" + NL + "\t\t\t((TextCellEditorEx)cellEditor).setValueAndProcessEditOccured(toEdit);" + NL + "\t\t} else {" + NL + "\t\t\tcellEditor.setValue(toEdit);" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\t// Set the controls text and position the caret at the end of the text" + NL + "\t\ttextControl.setSelection(toEdit.length());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void show(char initialChar) {" + NL + "\t\t" + NL + "\t\tshow();" + NL + "\t\t// Set the cell editor text to the initial character" + NL + "\t\tString initialString = String.valueOf(initialChar);" + NL + "\t\tsetEditText(initialString);" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void show(Point location) {\t\t" + NL + "\t\tshow();" + NL + "\t\tsendMouseClick(location);\t" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void sendMouseClick(Point location) {\t\t" + NL + "\t\t" + NL + "\t\tfinal Display currDisplay = Display.getCurrent();" + NL + "\t\tfinal Point currLocation = location;" + NL + "\t\tnew Thread() {" + NL + "\t\t\tEvent event;" + NL + "\t\t\tpublic void run() {" + NL + "\t\t\t\t\tevent = new Event();" + NL + "\t\t\t\t\tevent.type = SWT.MouseDown;" + NL + "\t\t\t\t\tevent.button = 1;" + NL + "\t\t\t\t\tevent.x = currLocation.x;" + NL + "\t\t\t\t\tevent.y = currLocation.y;" + NL + "\t\t\t\t\tcurrDisplay.post(event);" + NL + "\t\t\t\t\tevent.type = SWT.MouseUp;" + NL + "\t\t\t\t\tcurrDisplay.post(event);" + NL + "\t\t\t}" + NL + "\t\t}.start();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void unhookListeners() {" + NL + "\t\tif (listenersAttached) {" + NL + "\t\t\tlistenersAttached = false;" + NL + "\t\t\tsuper.unhookListeners();" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setCellEditor(CellEditor editor) {" + NL + "\t\tsuper.setCellEditor(editor);" + NL + "\t\tif (editor != null) {" + NL + "\t\t\tlistenersAttached = true;" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void showFeedback() {" + NL + "\t\ttry {" + NL + "\t\t\tgetEditPart().getRoot();" + NL + "\t\t\tsuper.showFeedback();" + NL + "\t\t} catch (Exception e) {" + NL + "\t\t\t// TODO: handle exception" + NL + "\t\t}\t" + NL + "\t}" + NL + "}";
  protected final String TEXT_6 = NL;
d47 4
d52 8
@


1.1
log
@#129145 do not use intermediate TextCompartmentEditParts
@
text
@d21 1
a21 1
  protected final String TEXT_5 = ";" + NL + "" + NL + "import org.eclipse.draw2d.FigureUtilities;" + NL + "import org.eclipse.draw2d.geometry.Dimension;" + NL + "import org.eclipse.draw2d.geometry.Rectangle;" + NL + "import org.eclipse.gef.GraphicalEditPart;" + NL + "import org.eclipse.gef.tools.CellEditorLocator;" + NL + "import org.eclipse.gef.tools.DirectEditManager;" + NL + "import org.eclipse.gmf.runtime.common.ui.contentassist.ContentAssistantHelper;" + NL + "import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;" + NL + "import org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel;" + NL + "import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;" + NL + "import org.eclipse.gmf.runtime.gef.ui.internal.parts.TextCellEditorEx;" + NL + "import org.eclipse.gmf.runtime.gef.ui.internal.parts.WrapTextCellEditor;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;" + NL + "import org.eclipse.jface.util.Assert;" + NL + "import org.eclipse.jface.viewers.CellEditor;" + NL + "import org.eclipse.swt.SWT;" + NL + "import org.eclipse.swt.graphics.Color;" + NL + "import org.eclipse.swt.graphics.Font;" + NL + "import org.eclipse.swt.graphics.FontData;" + NL + "import org.eclipse.swt.graphics.Point;" + NL + "import org.eclipse.swt.graphics.RGB;" + NL + "import org.eclipse.swt.widgets.Control;" + NL + "import org.eclipse.swt.widgets.Display;" + NL + "import org.eclipse.swt.widgets.Event;" + NL + "import org.eclipse.swt.widgets.Shell;" + NL + "import org.eclipse.swt.widgets.Table;" + NL + "import org.eclipse.swt.widgets.Text;" + NL + "" + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class TextDirectEditManager extends DirectEditManager {" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate Color proposalPopupBackgroundColor = null;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate Color proposalPopupForegroundColor = null;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean committed = false;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean listenersAttached = true;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tstatic private class TextCellEditorLocator implements CellEditorLocator {" + NL + "" + NL + "\t\tprivate WrapLabel wrapLabel;" + NL + "\t\t" + NL + "\t\tpublic TextCellEditorLocator(WrapLabel wrapLabel) {" + NL + "\t\t\tsuper();" + NL + "\t\t\tthis.wrapLabel = wrapLabel;" + NL + "\t\t}" + NL + "" + NL + "\t\t" + NL + "\t\tpublic WrapLabel getWrapLabel() {" + NL + "\t\t\treturn wrapLabel;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic void relocate(CellEditor celleditor) {" + NL + "\t\t\tText text = (Text) celleditor.getControl();" + NL + "\t\t\tRectangle rect = getWrapLabel().getTextBounds().getCopy();" + NL + "\t\t\tgetWrapLabel().translateToAbsolute(rect);" + NL + "\t\t\t" + NL + "\t\t\tif (getWrapLabel().isTextWrapped() && getWrapLabel().getText().length() > 0)" + NL + "\t\t\t\trect.setSize(new Dimension(text.computeSize(rect.width, SWT.DEFAULT)));" + NL + "\t\t\telse {" + NL + "\t\t\t\tint avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();" + NL + "\t\t\t\trect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr*2, 0));" + NL + "\t\t\t}" + NL + "" + NL + "\t\t\tif (!rect.equals(new Rectangle(text.getBounds())))" + NL + "\t\t\t\ttext.setBounds(rect.x, rect.y, rect.width, rect.height);" + NL + "\t\t}" + NL + "" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic TextDirectEditManager(ITextAwareEditPart source) {" + NL + "\t\tsuper(source, getTextCellEditorClass(source), " + NL + "\t\t\t\tnew TextCellEditorLocator(source.getLabel()));" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic TextDirectEditManager(GraphicalEditPart source, Class editorType, CellEditorLocator locator) {" + NL + "\t\tsuper(source, editorType, locator);\t\t" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static Class getTextCellEditorClass(ITextAwareEditPart source){" + NL + "\t\tWrapLabel wrapLabel = source.getLabel();" + NL + "\t\t\t\t" + NL + "\t\tif (wrapLabel.isTextWrapped())" + NL + "\t\t\treturn WrapTextCellEditor.class;" + NL + "\t\t" + NL + "\t\treturn TextCellEditorEx.class;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Font getScaledFont(WrapLabel label) {" + NL + "\t\tFont scaledFont = label.getFont();" + NL + "\t\tFontData data = scaledFont.getFontData()[0];" + NL + "\t\tDimension fontSize = new Dimension(0, MapModeUtil.getMapMode(label).DPtoLP(data.getHeight()));" + NL + "\t\tlabel.translateToAbsolute(fontSize);" + NL + "\t\t" + NL + "\t\tif( Math.abs( data.getHeight() - fontSize.height ) < 2 )" + NL + "\t\t\tfontSize.height = data.getHeight();" + NL + "" + NL + "\t\tdata.setHeight(fontSize.height);" + NL + "\t\tFont newFont = DiagramFontRegistry.getInstance().getFont(null, data);" + NL + "\t\treturn newFont;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void initCellEditor() {" + NL + "\t\tcommitted = false;" + NL + "" + NL + "\t\t// Get the Text Compartments Edit Part" + NL + "\t\tITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();" + NL + "" + NL + "\t\tsetEditText(textEP.getEditText());" + NL + "" + NL + "\t\tWrapLabel label = textEP.getLabel();" + NL + "\t\tAssert.isNotNull(label);" + NL + "\t\tText text = (Text) getCellEditor().getControl();" + NL + "\t\t// scale the font accordingly to the zoom level" + NL + "\t\ttext.setFont(getScaledFont(label));" + NL + "\t\t" + NL + "\t\t" + NL + "\t\t// register a validator on the cell editor" + NL + "\t\tgetCellEditor().setValidator(textEP.getEditTextValidator());" + NL + "" + NL + "\t\tif (textEP.getParser() != null) {" + NL + "\t\t\tIContentAssistProcessor processor = textEP.getCompletionProcessor();" + NL + "\t\t\tif (processor != null) {" + NL + "\t\t\t\t// register content assist" + NL + "\t\t\t\tproposalPopupBackgroundColor = new Color(getCellEditor()" + NL + "\t\t\t\t\t.getControl().getShell().getDisplay(), new RGB(254, 241," + NL + "\t\t\t\t\t233));" + NL + "\t\t\t\tproposalPopupForegroundColor = new Color(getCellEditor()" + NL + "\t\t\t\t\t.getControl().getShell().getDisplay(), new RGB(0, 0, 0));" + NL + "" + NL + "\t\t\t\tContentAssistantHelper.createTextContentAssistant(text," + NL + "\t\t\t\t\tproposalPopupForegroundColor, proposalPopupBackgroundColor," + NL + "\t\t\t\t\tprocessor);" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void commit() {" + NL + "\t\tShell activeShell = Display.getCurrent().getActiveShell();" + NL + "\t\tif (activeShell != null" + NL + "\t\t\t&& getCellEditor().getControl().getShell().equals(" + NL + "\t\t\t\tactiveShell.getParent())) {" + NL + "\t\t\tControl[] children = activeShell.getChildren();" + NL + "\t\t\tif (children.length == 1 && children[0] instanceof Table) {" + NL + "\t\t\t\t/*" + NL + "\t\t\t\t * CONTENT ASSIST: focus is lost to the content assist pop up -" + NL + "\t\t\t\t * stay in focus" + NL + "\t\t\t\t */" + NL + "\t\t\t\tgetCellEditor().getControl().setVisible(true);" + NL + "\t\t\t\t((TextCellEditorEx) getCellEditor()).setDeactivationLock(true);" + NL + "\t\t\t\treturn;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "" + NL + "\t\t// content assist hacks" + NL + "\t\tif (committed) {" + NL + "\t\t\tbringDown();" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tcommitted = true;" + NL + "\t\tsuper.commit();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void bringDown() {" + NL + "\t\tif (proposalPopupForegroundColor != null) {" + NL + "\t\t\tproposalPopupForegroundColor.dispose();" + NL + "\t\t\tproposalPopupForegroundColor = null;" + NL + "\t\t}" + NL + "\t\tif (proposalPopupBackgroundColor != null) {" + NL + "\t\t\tproposalPopupBackgroundColor.dispose();" + NL + "\t\t\tproposalPopupBackgroundColor = null;" + NL + "\t\t}" + NL + "" + NL + "\t\t// myee - RATLC00523014: crashes when queued in asyncExec()" + NL + "\t\teraseFeedback();" + NL + "\t\t" + NL + "\t\tDisplay.getCurrent().asyncExec(new Runnable() {" + NL + "" + NL + "\t\t\tpublic void run() {" + NL + "\t\t\t\t// Content Assist hack - allow proper cleanup on childen" + NL + "\t\t\t\t// controls" + NL + "\t\t\t\tTextDirectEditManager.super.bringDown();" + NL + "\t\t\t}" + NL + "\t\t});" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditText(String toEdit) {" + NL + "" + NL + "\t\t// Get the cell editor" + NL + "\t\tCellEditor cellEditor = getCellEditor();" + NL + "" + NL + "\t\t// IF the cell editor doesn't exist yet..." + NL + "\t\tif (cellEditor == null) {" + NL + "\t\t\t// Do nothing" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "" + NL + "\t\t// Get the Text Compartment Edit Part" + NL + "\t\tITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();" + NL + "" + NL + "\t\t// Get the Text control" + NL + "\t\tText textControl = (Text) cellEditor.getControl();" + NL + "" + NL + "\t\t// Get the Text Edit Part's Figure (WrapLabel)" + NL + "\t\tWrapLabel label = textEP.getLabel();" + NL + "\t\tAssert.isNotNull(label);" + NL + "\t\t// Set the Figures text" + NL + "\t\tlabel.setText(toEdit);" + NL + "\t\t" + NL + "\t\t" + NL + "\t\t// See RATLC00522324" + NL + "\t\tif (cellEditor instanceof TextCellEditorEx){" + NL + "\t\t\t((TextCellEditorEx)cellEditor).setValueAndProcessEditOccured(toEdit);" + NL + "\t\t} else {" + NL + "\t\t\tcellEditor.setValue(toEdit);" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\t// Set the controls text and position the caret at the end of the text" + NL + "\t\ttextControl.setSelection(toEdit.length());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void show(char initialChar) {" + NL + "\t\t" + NL + "\t\tshow();" + NL + "\t\t// Set the cell editor text to the initial character" + NL + "\t\tString initialString = String.valueOf(initialChar);" + NL + "\t\tsetEditText(initialString);" + NL + "" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void show(Point location) {\t\t" + NL + "\t\tshow();" + NL + "\t\tsendMouseClick(location);\t" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void sendMouseClick(Point location) {\t\t" + NL + "\t\t" + NL + "\t\tfinal Display currDisplay = Display.getCurrent();" + NL + "\t\tfinal Point currLocation = location;" + NL + "\t\tnew Thread() {" + NL + "\t\t\tEvent event;" + NL + "\t\t\tpublic void run() {" + NL + "\t\t\t\t\tevent = new Event();" + NL + "\t\t\t\t\tevent.type = SWT.MouseDown;" + NL + "\t\t\t\t\tevent.button = 1;" + NL + "\t\t\t\t\tevent.x = currLocation.x;" + NL + "\t\t\t\t\tevent.y = currLocation.y;" + NL + "\t\t\t\t\tcurrDisplay.post(event);" + NL + "\t\t\t\t\tevent.type = SWT.MouseUp;" + NL + "\t\t\t\t\tcurrDisplay.post(event);" + NL + "\t\t\t}" + NL + "\t\t}.start();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void unhookListeners() {" + NL + "\t\tif (listenersAttached) {" + NL + "\t\t\tlistenersAttached = false;" + NL + "\t\t\tsuper.unhookListeners();" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setCellEditor(CellEditor editor) {" + NL + "\t\tsuper.setCellEditor(editor);" + NL + "\t\tif (editor != null) {" + NL + "\t\t\tlistenersAttached = true;" + NL + "\t\t}" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void showFeedback() {" + NL + "\t\ttry {" + NL + "\t\t\tgetEditPart().getRoot();" + NL + "\t\t\tsuper.showFeedback();" + NL + "\t\t} catch (Exception e) {" + NL + "\t\t\t// TODO: handle exception" + NL + "\t\t}\t" + NL + "\t}" + NL + "}";
@

