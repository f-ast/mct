head	1.39;
access;
symbols
	v20081022-1925:1.39
	v20081015-1925:1.39
	v20081008-1925:1.39
	v20081001-1925:1.39
	v20080924-1925:1.39
	v20080917-1925:1.39
	v20080911-1728:1.39
	v20080910-1520:1.39
	v20080903-1520:1.39
	v20080827-1520:1.39
	v20080813-1520:1.39
	v20080806-1520:1.39
	v20070608-1300:1.38
	v20070605-1400:1.38
	v20070601-1400:1.37
	v20070525-1500:1.37
	v20070520-1200:1.37
	v20070518-1300:1.36
	v20070504-1000:1.36
	v20070427-0600:1.36
	v20070420-1000:1.35
	v20070413-1300:1.35
	v20070405-1100:1.35
	v20070403-1500:1.35
	v20070330-1300:1.35
	v20060330-1300:1.35
	v20070322-1100:1.35
	v20060316-0600:1.35
	v20070307-0700:1.35
	v20070301-1200:1.35
	v20070228-2000:1.35
	v20070221-1500:1.34
	v20070208-1800:1.34
	v20070202-0200:1.31
	v20070103-0300:1.33
	M4_20:1.33
	v20061222-1800:1.33
	v20061218-1200:1.33
	v20061214-0000:1.33
	v20061120-1300:1.33
	M3_20:1.33
	v20061117-0800:1.33
	v20061027-1200:1.31
	v20061020-1000:1.31
	v20061013-1330:1.32
	v20060919-0800:1.31
	v20060907-1100:1.31
	M1_20:1.31
	v20060904-1500:1.31
	v20060824-1600:1.31
	v20060817-1500:1.31
	v20060728-0500:1.31
	v20060713-1700:1.31
	R1_0_maintenance:1.31.0.2
	R1_0:1.31
	v20060627-1200:1.31
	v20060626-1420:1.31
	v20060620-0400:1.31
	v20060616-1400:1.31
	v20060616-1200:1.31
	v20060609-1400:1.31
	v20060531-1730:1.30
	v20060530-1930:1.30
	v20060526-1200:1.29
	v20060519-1300:1.29
	v20060519-0800:1.29
	v20060512-1000:1.29
	I20060512-1000:1.29
	I20060505-1400:1.29
	I20060428-1300:1.29
	I20060424-0500:1.29
	I20060424-0300:1.29
	M6_10:1.29
	I20060407-1200:1.22
	I20060331-1000:1.19
	I20060324-0300:1.19
	I20060317-1300:1.18
	I20060317-1200:1.18
	I20060316-1300:1.18
	I20060309-1300:1.18
	M5_10:1.17
	S20060303-1600:1.17
	I20060227-1730:1.17
	I20060216-1945:1.16
	I20060210-1715:1.16
	I20060209-1815:1.16
	I20060203-0830:1.11
	I20060202-1415:1.11
	I20060129-1145:1.10
	I20060127-0900:1.10
	I20060120-1530:1.9
	I20060113-1700:1.9
	M4_10:1.9
	I20060107-1100:1.7
	I20060105-1630:1.7
	I20051230-1230:1.7
	I20051223-1100:1.7
	I20051217-0925:1.7
	I20051208-2000:1.7
	I20051201-1800:1.6
	I20051124-2000:1.5
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.4;
locks; strict;
comment	@# @;
expand	@k@;


1.39
date	2007.06.13.15.14.23;	author dstadnik;	state dead;
branches;
next	1.38;
commitid	78d4467009cd4567;

1.38
date	2007.06.04.16.20.34;	author atikhomirov;	state Exp;
branches;
next	1.37;
commitid	17ef46643bcf4567;

1.37
date	2007.05.20.12.56.51;	author mfeldman;	state Exp;
branches;
next	1.36;
commitid	7de14650454a4567;

1.36
date	2007.04.24.08.57.56;	author dstadnik;	state Exp;
branches;
next	1.35;
commitid	78b462dc68e4567;

1.35
date	2007.02.22.19.49.50;	author ashatalin;	state Exp;
branches;
next	1.34;
commitid	299645ddf3da4567;

1.34
date	2007.02.07.12.05.15;	author ashatalin;	state Exp;
branches;
next	1.33;
commitid	37da45c9c07a4567;

1.33
date	2006.11.16.13.31.32;	author atikhomirov;	state Exp;
branches;
next	1.32;
commitid	5510455c68334567;

1.32
date	2006.09.28.10.52.30;	author ashatalin;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.01.09.14.34;	author dstadnik;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.29.18.20.56;	author ashatalin;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.14.18.06.24;	author atikhomirov;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.13.13.43.21;	author dstadnik;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.12.08.48.33;	author dstadnik;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.10.13.40.25;	author ashatalin;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.08.17.19.56;	author ashatalin;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.08.16.56.36;	author dstadnik;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.08.11.41.49;	author dstadnik;	state dead;
branches;
next	1.22;

1.22
date	2006.04.07.14.49.25;	author ashatalin;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.04.11.00.59;	author ashatalin;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.03.12.52.48;	author dstadnik;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.19.16.57.17;	author ashatalin;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.07.15.45.28;	author dstadnik;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.17.12.02.06;	author dstadnik;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.08.17.15.50;	author atikhomirov;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.08.16.27.57;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.08.16.06.19;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.05.22.57.54;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.31.19.02.08;	author ashatalin;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.26.13.36.41;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.10.17.20.28;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.10.16.16.58;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.05.19.16.56;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.29.18.14.04;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.16.07.42.23;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.13.14.21.40;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.04.15.40.37;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.04.13.18.06;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.29.09.49.40;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.39
log
@[192422] Rewrite Plugin.javajet template in xpand
@
text
@package org.eclipse.gmf.codegen.templates.editor;

import org.eclipse.emf.common.util.*;
import org.eclipse.emf.codegen.ecore.genmodel.*;
import org.eclipse.gmf.codegen.gmfgen.*;
import org.eclipse.gmf.common.codegen.*;

public class PluginGenerator
{
  protected static String nl;
  public static synchronized PluginGenerator create(String lineSeparator)
  {
    nl = lineSeparator;
    PluginGenerator result = new PluginGenerator();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*" + NL + " * ";
  protected final String TEXT_2 = NL + " */";
  protected final String TEXT_3 = NL + NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.runtime.IPath;" + NL + "import org.eclipse.core.runtime.IStatus;" + NL + "import org.eclipse.core.runtime.Path;" + NL + "import org.eclipse.core.runtime.Platform;" + NL + "import org.eclipse.core.runtime.Status;" + NL + "" + NL + "import org.eclipse.emf.common.notify.AdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
  protected final String TEXT_4 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_5 = " extends AbstractUIPlugin {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final String ID = \"";
  protected final String TEXT_6 = "\"; //$NON-NLS-1$" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(ID);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static ";
  protected final String TEXT_7 = " instance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ComposedAdapterFactory adapterFactory;\t" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ";
  protected final String TEXT_8 = " myDocumentProvider;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_9 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_10 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_11 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_12 = "());";
  protected final String TEXT_13 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_14 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Respects images residing in any plug-in. If path is relative," + NL + "\t * then this bundle is looked up for the image, otherwise, for absolute " + NL + "\t * path, first segment is taken as id of plug-in with image" + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path to image, either absolute (with plug-in id as first segment), or relative for bundled images" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor findImageDescriptor(String path) {" + NL + "\t\tfinal IPath p = new Path(path);" + NL + "\t\tif (p.isAbsolute() && p.segmentCount() > 1) {" + NL + "\t\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(p.segment(0), p.removeFirstSegments(1).makeAbsolute().toString());" + NL + "\t\t} else {" + NL + "\t\t\treturn getBundledImageDescriptor(p.makeAbsolute().toString());" + NL + "\t\t} " + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns string from plug-in's resource bundle" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static String getString(String key) {" + NL + "\t\treturn Platform.getResourceString(getInstance().getBundle(), \"%\" + key); //$NON-NLS-1$" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_15 = " getDocumentProvider() {" + NL + "\t\tif (myDocumentProvider == null) {" + NL + "\t\t\tmyDocumentProvider = new ";
  protected final String TEXT_16 = "();" + NL + "\t\t}" + NL + "\t\treturn myDocumentProvider;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_17 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && throwable != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_18 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "}";
  protected final String TEXT_19 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    
final GenPlugin genPlugin = (GenPlugin) ((Object[]) argument)[0];
final GenDiagram genDiagram = genPlugin.getEditorGen().getDiagram();
final EList genPackages = genPlugin.getEditorGen().getAllDomainGenPackages(true);
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];

    
String copyrightText = genDiagram.getEditorGen().getCopyrightText();
if (copyrightText != null && copyrightText.trim().length() > 0) {

    stringBuffer.append(TEXT_1);
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
    stringBuffer.append(TEXT_2);
    }
    importManager.emitPackageStatement(stringBuffer);
    stringBuffer.append(TEXT_3);
    importManager.markImportLocation(stringBuffer);
    stringBuffer.append(TEXT_4);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_5);
    stringBuffer.append(genPlugin.getID());
    stringBuffer.append(TEXT_6);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_7);
    stringBuffer.append(importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName()));
    stringBuffer.append(TEXT_8);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_9);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_10);
    
for (int i = 0; i < genPackages.size(); i++) {
	GenPackage genPackage = (GenPackage) genPackages.get(i);

    stringBuffer.append(TEXT_11);
    stringBuffer.append(importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName()));
    stringBuffer.append(TEXT_12);
    }
    stringBuffer.append(TEXT_13);
    
			// XXX dependency org.eclipse.emf.edit.ui is for ExtendedImageRegistry only. 
			// FIXME move image registry to plugin class code

    stringBuffer.append(TEXT_14);
    stringBuffer.append(importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName()));
    stringBuffer.append(TEXT_15);
    stringBuffer.append(importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName()));
    stringBuffer.append(TEXT_16);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_17);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_18);
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_19);
    return stringBuffer.toString();
  }
}
@


1.38
log
@regenerated jet emitters with EMF 2.3 RC2
@
text
@@


1.37
log
@Anna Karyakina's migration fix
@
text
@d19 1
a19 1
  protected final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
@


1.36
log
@follow consisted spacing policy
@
text
@d20 19
a38 20
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + "/*" + NL + " * ";
  protected final String TEXT_3 = NL + " */";
  protected final String TEXT_4 = NL + NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.runtime.IPath;" + NL + "import org.eclipse.core.runtime.IStatus;" + NL + "import org.eclipse.core.runtime.Path;" + NL + "import org.eclipse.core.runtime.Platform;" + NL + "import org.eclipse.core.runtime.Status;" + NL + "" + NL + "import org.eclipse.emf.common.notify.AdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
  protected final String TEXT_5 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_6 = " extends AbstractUIPlugin {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final String ID = \"";
  protected final String TEXT_7 = "\"; //$NON-NLS-1$" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(ID);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static ";
  protected final String TEXT_8 = " instance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ComposedAdapterFactory adapterFactory;\t" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ";
  protected final String TEXT_9 = " myDocumentProvider;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_10 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_11 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_12 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_13 = "());";
  protected final String TEXT_14 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_15 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Respects images residing in any plug-in. If path is relative," + NL + "\t * then this bundle is looked up for the image, otherwise, for absolute " + NL + "\t * path, first segment is taken as id of plug-in with image" + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path to image, either absolute (with plug-in id as first segment), or relative for bundled images" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor findImageDescriptor(String path) {" + NL + "\t\tfinal IPath p = new Path(path);" + NL + "\t\tif (p.isAbsolute() && p.segmentCount() > 1) {" + NL + "\t\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(p.segment(0), p.removeFirstSegments(1).makeAbsolute().toString());" + NL + "\t\t} else {" + NL + "\t\t\treturn getBundledImageDescriptor(p.makeAbsolute().toString());" + NL + "\t\t} " + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns string from plug-in's resource bundle" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static String getString(String key) {" + NL + "\t\treturn Platform.getResourceString(getInstance().getBundle(), \"%\" + key); //$NON-NLS-1$" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_16 = " getDocumentProvider() {" + NL + "\t\tif (myDocumentProvider == null) {" + NL + "\t\t\tmyDocumentProvider = new ";
  protected final String TEXT_17 = "();" + NL + "\t\t}" + NL + "\t\treturn myDocumentProvider;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_18 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && throwable != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_19 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "}";
  protected final String TEXT_20 = NL;
a48 1
    stringBuffer.append(TEXT_1);
d53 2
a55 2
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
    stringBuffer.append(TEXT_3);
d58 2
d61 1
a61 1
    importManager.markImportLocation(stringBuffer);
d63 2
a65 2
    stringBuffer.append(TEXT_6);
    stringBuffer.append(genPlugin.getID());
d67 2
a69 2
    stringBuffer.append(TEXT_8);
    stringBuffer.append(importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName()));
a72 2
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_11);
d77 2
d80 1
a80 1
    stringBuffer.append(importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName()));
a81 2
    }
    stringBuffer.append(TEXT_14);
d86 2
d91 1
a91 1
    stringBuffer.append(importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName()));
d95 1
a95 1
    stringBuffer.append(genPlugin.getActivatorClassName());
a96 2
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_20);
@


1.35
log
@[175169] - Double-click on diagram in Project Explorer should open corresponding diagram editor as before
@
text
@d21 1
a21 1
  protected final String TEXT_2 = NL + "/*" + NL + " *";
d56 1
a56 1
    stringBuffer.append(copyrightText.replaceAll("\n", "\n *"));
@


1.34
log
@Removing *EditorInputProxies - only EditorInputs are used in generated code from now.
@
text
@d27 13
a39 17
  protected final String TEXT_8 = " instance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ComposedAdapterFactory adapterFactory;\t";
  protected final String TEXT_9 = NL + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ";
  protected final String TEXT_10 = " myDocumentProvider;";
  protected final String TEXT_11 = NL + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_12 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_13 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_14 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_15 = "());";
  protected final String TEXT_16 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_17 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Respects images residing in any plug-in. If path is relative," + NL + "\t * then this bundle is looked up for the image, otherwise, for absolute " + NL + "\t * path, first segment is taken as id of plug-in with image" + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path to image, either absolute (with plug-in id as first segment), or relative for bundled images" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor findImageDescriptor(String path) {" + NL + "\t\tfinal IPath p = new Path(path);" + NL + "\t\tif (p.isAbsolute() && p.segmentCount() > 1) {" + NL + "\t\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(p.segment(0), p.removeFirstSegments(1).makeAbsolute().toString());" + NL + "\t\t} else {" + NL + "\t\t\treturn getBundledImageDescriptor(p.makeAbsolute().toString());" + NL + "\t\t} " + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns string from plug-in's resource bundle" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static String getString(String key) {" + NL + "\t\treturn Platform.getResourceString(getInstance().getBundle(), \"%\" + key); //$NON-NLS-1$" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}";
  protected final String TEXT_18 = NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_19 = " getDocumentProvider() {" + NL + "\t\tif (myDocumentProvider == null) {" + NL + "\t\t\tmyDocumentProvider = new ";
  protected final String TEXT_20 = "();" + NL + "\t\t}" + NL + "\t\treturn myDocumentProvider;" + NL + "\t}";
  protected final String TEXT_21 = NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_22 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && throwable != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_23 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "}";
  protected final String TEXT_24 = NL;
d69 1
a69 1
    if (genDiagram.getEditorGen().getApplication() == null) {
d71 1
a71 1
    stringBuffer.append(importManager.getImportedName(genDiagram.getDocumentProviderQualifiedClassName()));
d73 1
a73 1
    }
a74 4
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_12);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_13);
d79 1
a79 1
    stringBuffer.append(TEXT_14);
d81 1
a81 1
    stringBuffer.append(TEXT_15);
d83 1
a83 1
    stringBuffer.append(TEXT_16);
d88 1
a88 3
    stringBuffer.append(TEXT_17);
    if (genDiagram.getEditorGen().getApplication() == null) {
    stringBuffer.append(TEXT_18);
d90 1
a90 1
    stringBuffer.append(TEXT_19);
d92 1
a92 3
    stringBuffer.append(TEXT_20);
    }
    stringBuffer.append(TEXT_21);
d94 1
a94 1
    stringBuffer.append(TEXT_22);
d96 1
a96 1
    stringBuffer.append(TEXT_23);
d98 1
a98 1
    stringBuffer.append(TEXT_24);
@


1.33
log
@[162552] - Tool descriptions that contain special characters yield uncompilable code
Refactored to use externalized strings instead (for now from plugin.xml, may later switch to new nls bundles)
@
text
@d27 17
a43 10
  protected final String TEXT_8 = " instance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ComposedAdapterFactory adapterFactory;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_9 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_10 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_11 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_12 = "());";
  protected final String TEXT_13 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_14 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Respects images residing in any plug-in. If path is relative," + NL + "\t * then this bundle is looked up for the image, otherwise, for absolute " + NL + "\t * path, first segment is taken as id of plug-in with image" + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path to image, either absolute (with plug-in id as first segment), or relative for bundled images" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor findImageDescriptor(String path) {" + NL + "\t\tfinal IPath p = new Path(path);" + NL + "\t\tif (p.isAbsolute() && p.segmentCount() > 1) {" + NL + "\t\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(p.segment(0), p.removeFirstSegments(1).makeAbsolute().toString());" + NL + "\t\t} else {" + NL + "\t\t\treturn getBundledImageDescriptor(p.makeAbsolute().toString());" + NL + "\t\t} " + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns string from plug-in's resource bundle" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static String getString(String key) {" + NL + "\t\treturn Platform.getResourceString(getInstance().getBundle(), \"%\" + key); //$NON-NLS-1$" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_15 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && throwable != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_16 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "}";
  protected final String TEXT_17 = NL;
d73 6
d80 1
a80 1
    stringBuffer.append(TEXT_9);
d82 1
a82 1
    stringBuffer.append(TEXT_10);
d87 1
a87 1
    stringBuffer.append(TEXT_11);
d89 1
a89 1
    stringBuffer.append(TEXT_12);
d91 1
a91 1
    stringBuffer.append(TEXT_13);
d96 9
a104 1
    stringBuffer.append(TEXT_14);
d106 1
a106 1
    stringBuffer.append(TEXT_15);
d108 1
a108 1
    stringBuffer.append(TEXT_16);
d110 1
a110 1
    stringBuffer.append(TEXT_17);
@


1.32
log
@[158991] - Generating useless / inefficient code
@
text
@d23 1
a23 1
  protected final String TEXT_4 = NL + NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.runtime.IPath;" + NL + "import org.eclipse.core.runtime.IStatus;" + NL + "import org.eclipse.core.runtime.Path;" + NL + "import org.eclipse.core.runtime.Status;" + NL + "" + NL + "import org.eclipse.emf.common.notify.AdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
d33 1
a33 1
  protected final String TEXT_14 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Respects images residing in any plug-in. If path is relative," + NL + "\t * then this bundle is looked up for the image, otherwise, for absolute " + NL + "\t * path, first segment is taken as id of plug-in with image" + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path to image, either absolute (with plug-in id as first segment), or relative for bundled images" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor findImageDescriptor(String path) {" + NL + "\t\tfinal IPath p = new Path(path);" + NL + "\t\tif (p.isAbsolute() && p.segmentCount() > 1) {" + NL + "\t\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(p.segment(0), p.removeFirstSegments(1).makeAbsolute().toString());" + NL + "\t\t} else {" + NL + "\t\t\treturn getBundledImageDescriptor(p.makeAbsolute().toString());" + NL + "\t\t} " + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
d35 1
a35 1
  protected final String TEXT_16 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
@


1.31
log
@header comment should not be a javadoc comment
@
text
@d34 1
a34 1
  protected final String TEXT_15 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
@


1.30
log
@Correcting copyright processing
@
text
@d21 1
a21 1
  protected final String TEXT_2 = NL + "/**" + NL + " *";
@


1.29
log
@#128404 palette factory ignores bundle name
@
text
@d21 1
a21 1
  protected final String TEXT_2 = NL + "/*" + NL + " * ";
d53 1
a53 1
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
@


1.28
log
@remove stale code
@
text
@d23 1
a23 1
  protected final String TEXT_4 = NL + NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.runtime.IStatus;" + NL + "import org.eclipse.core.runtime.Status;" + NL + "" + NL + "import org.eclipse.emf.common.notify.AdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
d33 1
a33 1
  protected final String TEXT_14 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
@


1.27
log
@#126200 register element types in xml
@
text
@d28 9
a36 10
  protected final String TEXT_9 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\t//";
  protected final String TEXT_10 = ".register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_11 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_12 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_13 = "());";
  protected final String TEXT_14 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_15 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_16 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_17 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_18 = NL;
d68 1
a68 1
    stringBuffer.append(importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName()));
a69 2
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_11);
d74 2
d77 1
a77 1
    stringBuffer.append(importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName()));
a78 2
    }
    stringBuffer.append(TEXT_14);
d83 2
d88 1
a88 1
    stringBuffer.append(genPlugin.getActivatorClassName());
a89 2
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_18);
@


1.26
log
@#135653 Generated GMF examples use internal API
@
text
@d28 1
a28 1
  protected final String TEXT_9 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\t";
@


1.25
log
@using M6 to generate code.
@
text
@d28 10
a37 15
  protected final String TEXT_9 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());";
  protected final String TEXT_10 = NL + "\t\t";
  protected final String TEXT_11 = ".register(";
  protected final String TEXT_12 = ".eINSTANCE, ";
  protected final String TEXT_13 = ".INSTANCE);";
  protected final String TEXT_14 = NL + "\t\t";
  protected final String TEXT_15 = ".register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_16 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_17 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_18 = "());";
  protected final String TEXT_19 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_20 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_21 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_22 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_23 = NL;
d69 4
a75 2
	String domainPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
	String domainPackageEditPluginClassName = importManager.getImportedName(genPackage.getQualifiedEditPluginClassName());
a76 4
    stringBuffer.append(TEXT_10);
    stringBuffer.append(importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.util.MetamodelManager"));
    stringBuffer.append(TEXT_11);
    stringBuffer.append(domainPackageInterfaceName);
d78 1
a78 1
    stringBuffer.append(domainPackageEditPluginClassName);
a81 13
    stringBuffer.append(importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName()));
    stringBuffer.append(TEXT_15);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_16);
    
for (int i = 0; i < genPackages.size(); i++) {
	GenPackage genPackage = (GenPackage) genPackages.get(i);

    stringBuffer.append(TEXT_17);
    stringBuffer.append(importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName()));
    stringBuffer.append(TEXT_18);
    }
    stringBuffer.append(TEXT_19);
d86 1
a86 1
    stringBuffer.append(TEXT_20);
d88 1
a88 1
    stringBuffer.append(TEXT_21);
d90 1
a90 1
    stringBuffer.append(TEXT_22);
d92 1
a92 1
    stringBuffer.append(TEXT_23);
@


1.24
log
@restore generators
@
text
@d46 1
a46 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.23
log
@#134095 do not store compiled templates in cvs
@
text
@d46 1
a46 1
    final StringBuffer stringBuffer = new StringBuffer();
@


1.22
log
@Switching to eclipse M6.
@
text
@@


1.21
log
@Rollback of the latest changes to make running unit-tests + all the rest of the generated diagrams containing several diagram elements with the same EClass.

Original changes was made for fixing #126200.
@
text
@d46 1
a46 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.20
log
@#126200 register element types in xml
@
text
@d33 10
a42 9
  protected final String TEXT_14 = NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_15 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_16 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_17 = "());";
  protected final String TEXT_18 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_19 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_20 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_21 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_22 = NL;
d89 2
d92 1
a92 1
    stringBuffer.append(TEXT_15);
d97 1
a97 1
    stringBuffer.append(TEXT_16);
d99 1
a99 1
    stringBuffer.append(TEXT_17);
d101 1
a101 1
    stringBuffer.append(TEXT_18);
a105 2
    stringBuffer.append(TEXT_19);
    stringBuffer.append(genPlugin.getActivatorClassName());
d109 2
d112 1
a112 1
    stringBuffer.append(TEXT_22);
@


1.19
log
@#128024 Model references are not recognized as links
#131543 Obsolete code should be eliminated
@
text
@d33 9
a41 10
  protected final String TEXT_14 = NL + "\t\t";
  protected final String TEXT_15 = ".register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_16 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_17 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_18 = "());";
  protected final String TEXT_19 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_20 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_21 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_22 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_23 = NL;
d88 1
a88 1
    stringBuffer.append(importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName()));
a89 2
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_16);
d94 2
d97 1
a97 1
    stringBuffer.append(importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName()));
a98 2
    }
    stringBuffer.append(TEXT_19);
d103 2
d108 1
a108 1
    stringBuffer.append(genPlugin.getActivatorClassName());
a109 2
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_23);
@


1.18
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d30 13
a42 15
  protected final String TEXT_11 = ".register(new ";
  protected final String TEXT_12 = "());" + NL + "\t\t";
  protected final String TEXT_13 = ".register(";
  protected final String TEXT_14 = ".eINSTANCE, ";
  protected final String TEXT_15 = ".INSTANCE);";
  protected final String TEXT_16 = NL + "\t\t";
  protected final String TEXT_17 = ".register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_18 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_19 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_20 = "());";
  protected final String TEXT_21 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_22 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_23 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_24 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_25 = NL;
a76 1
	String domainPackageIPAFInterfaceName = importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName());
d81 1
a81 1
    stringBuffer.append(importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager"));
d83 1
a83 1
    stringBuffer.append(domainPackageIPAFInterfaceName);
d85 1
a85 1
    stringBuffer.append(importManager.getImportedName("org.eclipse.gmf.runtime.emf.core.internal.util.MetamodelManager"));
d87 1
a87 1
    stringBuffer.append(domainPackageInterfaceName);
d89 1
a89 1
    stringBuffer.append(domainPackageEditPluginClassName);
d91 1
a91 1
    }
a92 4
    stringBuffer.append(importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName()));
    stringBuffer.append(TEXT_17);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_18);
d97 1
a97 1
    stringBuffer.append(TEXT_19);
d99 1
a99 1
    stringBuffer.append(TEXT_20);
d101 1
a101 1
    stringBuffer.append(TEXT_21);
d106 1
a106 1
    stringBuffer.append(TEXT_22);
d108 1
a108 1
    stringBuffer.append(TEXT_23);
d110 1
a110 1
    stringBuffer.append(TEXT_24);
d112 1
a112 1
    stringBuffer.append(TEXT_25);
@


1.17
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@d20 25
a44 22
  protected final String TEXT_1 = NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.runtime.IStatus;" + NL + "import org.eclipse.core.runtime.Status;" + NL + "" + NL + "import org.eclipse.emf.common.notify.AdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
  protected final String TEXT_2 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_3 = " extends AbstractUIPlugin {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final String ID = \"";
  protected final String TEXT_4 = "\"; //$NON-NLS-1$" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(ID);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static ";
  protected final String TEXT_5 = " instance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ComposedAdapterFactory adapterFactory;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_6 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());";
  protected final String TEXT_7 = NL + "\t\t";
  protected final String TEXT_8 = ".register(new ";
  protected final String TEXT_9 = "());" + NL + "\t\t";
  protected final String TEXT_10 = ".register(";
  protected final String TEXT_11 = ".eINSTANCE, ";
  protected final String TEXT_12 = ".INSTANCE);";
  protected final String TEXT_13 = NL + "\t\t";
  protected final String TEXT_14 = ".register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_15 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_16 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_17 = "());";
  protected final String TEXT_18 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_19 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_20 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_21 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_22 = NL;
a54 1
importManager.emitPackageStatement(stringBuffer);
d56 4
a59 1
    importManager.markImportLocation(stringBuffer);
d61 1
a61 1
    stringBuffer.append(genPlugin.getActivatorClassName());
d63 2
a64 1
    stringBuffer.append(genPlugin.getID());
d66 1
a66 1
    stringBuffer.append(genPlugin.getActivatorClassName());
d70 6
d83 1
a83 1
    stringBuffer.append(TEXT_7);
d85 1
a85 1
    stringBuffer.append(TEXT_8);
d87 1
a87 1
    stringBuffer.append(TEXT_9);
d89 1
a89 1
    stringBuffer.append(TEXT_10);
d91 1
a91 1
    stringBuffer.append(TEXT_11);
d93 1
a93 1
    stringBuffer.append(TEXT_12);
d95 1
a95 1
    stringBuffer.append(TEXT_13);
d97 1
a97 1
    stringBuffer.append(TEXT_14);
d99 1
a99 1
    stringBuffer.append(TEXT_15);
d104 1
a104 1
    stringBuffer.append(TEXT_16);
d106 1
a106 1
    stringBuffer.append(TEXT_17);
d108 1
a108 1
    stringBuffer.append(TEXT_18);
d113 1
a113 1
    stringBuffer.append(TEXT_19);
d115 1
a115 1
    stringBuffer.append(TEXT_20);
d117 1
a117 1
    stringBuffer.append(TEXT_21);
d119 1
a119 1
    stringBuffer.append(TEXT_22);
@


1.16
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d3 1
a3 1
import java.util.*;
d20 1
a20 1
  protected final String TEXT_1 = NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.runtime.IStatus;" + NL + "import org.eclipse.core.runtime.Status;" + NL + "" + NL + "import org.eclipse.emf.common.notify.AdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLMetaModelManager;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
d25 17
a41 16
  protected final String TEXT_6 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\t//FIXME itemProviderAF, metaPackage and editPlugin are only for package of diagramMetaElement";
  protected final String TEXT_7 = NL + "\t\tMSLAdapterFactoryManager.register(new ";
  protected final String TEXT_8 = "());" + NL + "\t\tMSLMetaModelManager.register(";
  protected final String TEXT_9 = ".eINSTANCE, ";
  protected final String TEXT_10 = ".INSTANCE);" + NL + "\t\t";
  protected final String TEXT_11 = ".register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_12 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_13 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_14 = "());";
  protected final String TEXT_15 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_16 = "());";
  protected final String TEXT_17 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_18 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_19 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_20 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_21 = NL;
d49 1
a49 1
final GenModel genModel = genPlugin.getEditorGen().getDomainGenModel();
d65 5
a69 4
GenPackage genPackage = genDiagram.getDomainDiagramElement().getGenPackage();
String domainPackageIPAFInterfaceName = importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName());
String domainPackageInterfaceName = genDiagram.getMetaPackageName(importManager);
String domainPackageEditPluginClassName = importManager.getImportedName(genPackage.getQualifiedEditPluginClassName());
d72 2
a74 2
    stringBuffer.append(TEXT_8);
    stringBuffer.append(domainPackageInterfaceName);
d76 1
a76 1
    stringBuffer.append(domainPackageEditPluginClassName);
d78 1
a78 1
    stringBuffer.append(importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName()));
d80 1
a80 1
    stringBuffer.append(genPlugin.getActivatorClassName());
d82 1
a82 6
    
List genPackages = genModel.getAllGenPackagesWithClassifiers();
for (int i = 0; i < genPackages.size(); i++) {
	genPackage = (GenPackage) genPackages.get(i);
	if (genPackage.getGenModel().hasEditSupport()) {

d84 1
a84 1
    stringBuffer.append(importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName()));
d86 2
a88 3
	}
}
genPackages = genModel.getAllUsedGenPackagesWithClassifiers();
d90 1
a90 2
	genPackage = (GenPackage) genPackages.get(i);
	if (genPackage.getGenModel().hasEditSupport()) {
d92 1
a92 1
    stringBuffer.append(TEXT_15);
a93 5
    stringBuffer.append(TEXT_16);
    
	}
}

d95 2
a100 2
    stringBuffer.append(TEXT_18);
    stringBuffer.append(genPlugin.getActivatorClassName());
d104 2
d107 1
a107 1
    stringBuffer.append(TEXT_21);
@


1.15
log
@EDITOR_ID moved out from plugin to Editor
@
text
@d20 14
a33 14
  protected final String TEXT_1 = "package ";
  protected final String TEXT_2 = ";" + NL;
  protected final String TEXT_3 = NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.core.runtime.IStatus;" + NL + "import org.eclipse.core.runtime.Status;" + NL + "" + NL + "import org.eclipse.emf.common.notify.AdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLMetaModelManager;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
  protected final String TEXT_4 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_5 = " extends AbstractUIPlugin {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final String ID = \"";
  protected final String TEXT_6 = "\"; //$NON-NLS-1$" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(ID);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static ";
  protected final String TEXT_7 = " instance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ComposedAdapterFactory adapterFactory;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_8 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\t//FIXME itemProviderAF, metaPackage and editPlugin are only for package of diagramMetaElement";
  protected final String TEXT_9 = NL + "\t\tMSLAdapterFactoryManager.register(new ";
  protected final String TEXT_10 = "());" + NL + "\t\tMSLMetaModelManager.register(";
  protected final String TEXT_11 = ".eINSTANCE, ";
  protected final String TEXT_12 = ".INSTANCE);" + NL + "\t\t";
  protected final String TEXT_13 = ".register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_14 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
d36 5
a40 7
  protected final String TEXT_17 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_18 = "());";
  protected final String TEXT_19 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_20 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_21 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_22 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_23 = NL;
d46 1
a46 1
final GenPlugin genPlugin = (GenPlugin) argument;
d49 1
d51 1
d53 1
a53 1
    stringBuffer.append(genDiagram.getEditorGen().getEditor().getPackageName());
d55 1
a55 1
    ImportUtil importManager = new ImportUtil(genDiagram.getEditorGen().getEditor().getPackageName());
d57 1
a57 1
    importManager.markImportLocation(stringBuffer);
d61 1
a61 1
    stringBuffer.append(genPlugin.getID());
a62 4
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_7);
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_8);
d69 1
a69 1
    stringBuffer.append(TEXT_9);
d71 1
a71 1
    stringBuffer.append(TEXT_10);
d73 1
a73 1
    stringBuffer.append(TEXT_11);
d75 1
a75 1
    stringBuffer.append(TEXT_12);
d77 1
a77 1
    stringBuffer.append(TEXT_13);
d79 1
a79 1
    stringBuffer.append(TEXT_14);
d86 1
a86 1
    stringBuffer.append(TEXT_15);
d88 1
a88 1
    stringBuffer.append(TEXT_16);
d97 1
a97 1
    stringBuffer.append(TEXT_17);
d99 1
a99 1
    stringBuffer.append(TEXT_18);
d104 1
a104 1
    stringBuffer.append(TEXT_19);
d109 1
a109 1
    stringBuffer.append(TEXT_20);
d111 1
a111 1
    stringBuffer.append(TEXT_21);
d113 1
a113 1
    stringBuffer.append(TEXT_22);
d115 1
a115 1
    stringBuffer.append(TEXT_23);
@


1.14
log
@GenEditorViewer incapsulates all Eclipse's IEditorPart-related info
@
text
@d25 18
a42 19
  protected final String TEXT_6 = "\"; //$NON-NLS-1$" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final String EDITOR_ID = \"";
  protected final String TEXT_7 = "\";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(EDITOR_ID);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static ";
  protected final String TEXT_8 = " instance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ComposedAdapterFactory adapterFactory;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_9 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());" + NL + "\t\t//FIXME itemProviderAF, metaPackage and editPlugin are only for package of diagramMetaElement";
  protected final String TEXT_10 = NL + "\t\tMSLAdapterFactoryManager.register(new ";
  protected final String TEXT_11 = "());" + NL + "\t\tMSLMetaModelManager.register(";
  protected final String TEXT_12 = ".eINSTANCE, ";
  protected final String TEXT_13 = ".INSTANCE);" + NL + "\t\t";
  protected final String TEXT_14 = ".register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_15 = " getInstance() {" + NL + "\t\treturn instance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ComposedAdapterFactory createAdapterFactory() {" + NL + "\t\tList factories = new ArrayList();" + NL + "\t\tfillItemProviderFactories(factories);" + NL + "\t\treturn new ComposedAdapterFactory(factories);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillItemProviderFactories(List factories) {";
  protected final String TEXT_16 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_17 = "());";
  protected final String TEXT_18 = NL + "\t\tfactories.add(new ";
  protected final String TEXT_19 = "());";
  protected final String TEXT_20 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic AdapterFactory getItemProvidersAdapterFactory() {" + NL + "\t\treturn adapterFactory;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
  protected final String TEXT_21 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error) {" + NL + "\t\tlogError(error, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logError(String error, Throwable throwable) {" + NL + "\t\tif (error == null && throwable != null) {" + NL + "\t\t\terror = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.ERROR, ";
  protected final String TEXT_22 = ".ID, IStatus.OK, error, throwable));" + NL + "\t\tdebug(error, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message) {" + NL + "\t\tlogInfo(message, null);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@param throwable actual error or null could be passed" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void logInfo(String message, Throwable throwable) {" + NL + "\t\tif (message == null && message != null) {" + NL + "\t\t\tmessage = throwable.getMessage();" + NL + "\t\t}" + NL + "\t\tgetLog().log(new Status(IStatus.INFO, ";
  protected final String TEXT_23 = ".ID, IStatus.OK, message, throwable));" + NL + "\t\tdebug(message, throwable);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate void debug(String message, Throwable throwable) {" + NL + "\t\tif (!isDebugging()) {" + NL + "\t\t\treturn;" + NL + "\t\t}" + NL + "\t\tif (message != null) {" + NL + "\t\t\tSystem.err.println(message);" + NL + "\t\t}" + NL + "\t\tif (throwable != null) {" + NL + "\t\t\tthrowable.printStackTrace();" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "}";
  protected final String TEXT_24 = NL;
d63 1
a63 1
    stringBuffer.append(genPlugin.getEditorGen().getEditor().getID());
a66 2
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_9);
d73 2
d76 1
a76 1
    stringBuffer.append(domainPackageIPAFInterfaceName);
d78 1
a78 1
    stringBuffer.append(domainPackageInterfaceName);
d80 1
a80 1
    stringBuffer.append(domainPackageEditPluginClassName);
d82 1
a82 1
    stringBuffer.append(importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName()));
a83 2
    stringBuffer.append(genPlugin.getActivatorClassName());
    stringBuffer.append(TEXT_15);
d90 2
a92 2
    stringBuffer.append(importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName()));
    stringBuffer.append(TEXT_17);
d101 2
a103 2
    stringBuffer.append(importManager.getImportedName(genPackage.getQualifiedItemProviderAdapterFactoryClassName()));
    stringBuffer.append(TEXT_19);
d108 1
a108 1
    stringBuffer.append(TEXT_20);
d113 2
d118 1
a118 1
    stringBuffer.append(genPlugin.getActivatorClassName());
a119 2
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_24);
@


1.13
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d26 1
a26 1
  protected final String TEXT_7 = "ID\";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(EDITOR_ID);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static ";
d54 1
a54 1
    stringBuffer.append(genDiagram.getEditorPackageName());
d56 1
a56 1
    ImportUtil importManager = new ImportUtil(genDiagram.getEditorPackageName());
d64 1
a64 1
    stringBuffer.append(genDiagram.getEditorQualifiedClassName());
@


1.12
log
@ImportManager moved to oeg.common
@
text
@d28 1
a28 1
  protected final String TEXT_9 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());";
d49 3
a51 3
GenPlugin genPlugin = (GenPlugin) argument;
GenDiagram genDiagram = genPlugin.getDiagram();
GenModel genModel = genDiagram.getEMFGenModel();
d71 1
a71 1
GenPackage genPackage = genDiagram.getDomainMetaModel();
d73 1
a73 1
String domainPackageInterfaceName = importManager.getImportedName(genPackage.getQualifiedPackageInterfaceName());
@


1.11
log
@#125893
Logging methods
@
text
@d6 1
a6 1
import org.eclipse.gmf.codegen.util.ImportUtil;
@


1.10
log
@GenDiagram "slicing" goes on and this time attributes related to plugin activator class were moved into separate entity
@
text
@d22 1
a22 1
  protected final String TEXT_3 = NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "" + NL + "import org.eclipse.emf.common.notify.AdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLMetaModelManager;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
d40 4
a43 2
  protected final String TEXT_21 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Returns an image for the image file at the given plug-in relative path." + NL + "\t * Client do not need to dispose this image. Images will be disposed automatically." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return image instance" + NL + "\t */" + NL + "\tpublic Image getBundledImage(String path) {" + NL + "\t\tImage image = getImageRegistry().get(path);" + NL + "\t\tif (image == null) {" + NL + "\t\t\tgetImageRegistry().put(path, getBundledImageDescriptor(path));" + NL + "\t\t\timage = getImageRegistry().get(path);" + NL + "\t\t}" + NL + "\t\treturn image;" + NL + "\t}" + NL + "}";
  protected final String TEXT_22 = NL;
d117 4
d122 1
a122 1
    stringBuffer.append(TEXT_22);
@


1.9
log
@As a part of implementstion
#114178,114179
"Shortcutting" diagram elements.
@
text
@d47 2
a48 1
GenDiagram genDiagram = (GenDiagram) argument;
d58 1
a58 1
    stringBuffer.append(genDiagram.getPluginClassName());
d60 1
a60 1
    stringBuffer.append(genDiagram.getPluginID());
d64 1
a64 1
    stringBuffer.append(genDiagram.getPluginClassName());
d66 1
a66 1
    stringBuffer.append(genDiagram.getPluginClassName());
d83 1
a83 1
    stringBuffer.append(genDiagram.getPluginClassName());
@


1.8
log
@As a part of implementstion
#114178,114179
"Shortcutting" diagram elements.
@
text
@d22 1
a22 1
  protected final String TEXT_3 = NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLMetaModelManager;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.swt.graphics.Image;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
d39 1
a39 1
  protected final String TEXT_20 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {";
@


1.7
log
@#117731 icons defined has no effect in the generated code
@
text
@d22 1
a22 1
  protected final String TEXT_3 = NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLMetaModelManager;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;";
d40 1
a40 1
  protected final String TEXT_21 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getBundledImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "}";
@


1.6
log
@#118447 new-style bundle manifest (manifest.mf)
@
text
@d40 1
a40 1
  protected final String TEXT_21 = NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "}";
@


1.5
log
@#116031 avoid hardcoded class names in templates
@
text
@d39 3
a41 2
  protected final String TEXT_20 = NL + "\t\tfactories.add(new ResourceItemProviderAdapterFactory());" + NL + "\t\tfactories.add(new ReflectiveItemProviderAdapterFactory());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ImageDescriptor getItemImageDescriptor(Object item) {" + NL + "\t\tIItemLabelProvider labelProvider = (IItemLabelProvider) adapterFactory.adapt(item, IItemLabelProvider.class);" + NL + "\t\tif (labelProvider != null) {" + NL + "\t\t\treturn ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(item));" + NL + "\t\t}" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "}";
  protected final String TEXT_21 = NL;
d109 5
d115 1
a115 1
    stringBuffer.append(TEXT_21);
@


1.4
log
@[ashatalin] #112122 Action to initialize diagram for domain model.
 unique id introduced, refactoring to use it throughout the code
@
text
@d22 12
a33 12
  protected final String TEXT_3 = NL + "import java.util.ArrayList;" + NL + "import java.util.List;" + NL + "import org.eclipse.emf.edit.provider.ComposedAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.IItemLabelProvider;" + NL + "import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;" + NL + "import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;" + NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLMetaModelManager;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;" + NL + "import ";
  protected final String TEXT_4 = ".ElementTypes;";
  protected final String TEXT_5 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_6 = " extends AbstractUIPlugin {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final String ID = \"";
  protected final String TEXT_7 = "\"; //$NON-NLS-1$" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final String EDITOR_ID = \"";
  protected final String TEXT_8 = "ID\";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint(EDITOR_ID);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static ";
  protected final String TEXT_9 = " instance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ComposedAdapterFactory adapterFactory;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_10 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(DIAGRAM_PREFERENCES_HINT, getPreferenceStore());";
  protected final String TEXT_11 = NL + "\t\tMSLAdapterFactoryManager.register(new ";
  protected final String TEXT_12 = "());" + NL + "\t\tMSLMetaModelManager.register(";
  protected final String TEXT_13 = ".eINSTANCE, ";
  protected final String TEXT_14 = ".INSTANCE);" + NL + "\t\tElementTypes.register();" + NL + "\t\tadapterFactory = createAdapterFactory();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tadapterFactory.dispose();" + NL + "\t\tadapterFactory = null;" + NL + "\t\tinstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
d54 1
a54 1
    stringBuffer.append(genDiagram.getProvidersPackageName());
d56 1
a56 1
    importManager.markImportLocation(stringBuffer);
d58 1
a58 1
    stringBuffer.append(genDiagram.getPluginClassName());
d60 1
a60 1
    stringBuffer.append(genDiagram.getPluginID());
d62 1
a62 1
    stringBuffer.append(genDiagram.getEditorQualifiedClassName());
a65 2
    stringBuffer.append(genDiagram.getPluginClassName());
    stringBuffer.append(TEXT_10);
d72 2
d75 1
a75 1
    stringBuffer.append(domainPackageIPAFInterfaceName);
d77 1
a77 1
    stringBuffer.append(domainPackageInterfaceName);
d79 1
a79 1
    stringBuffer.append(domainPackageEditPluginClassName);
@


1.3
log
@[dstadnik]
#111455 Generate consistent names for notation view factories
#111461 Do not use 'final' keyword in method parameters
#111460 Generate dedicated edit part for the node label
#111457 Use model labels in palette factory
@
text
@d27 1
a27 1
  protected final String TEXT_8 = "ID\";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static ";
d29 1
a29 1
  protected final String TEXT_10 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tinstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(new PreferencesHint(EDITOR_ID), getPreferenceStore());";
@


1.2
log
@gmfgen ECore references were replaced with GenModel references to ease template coding and as alignment with overall "genmodel for GMF" concept
@
text
@d3 1
d22 1
a22 1
  protected final String TEXT_3 = NL + "import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;" + NL + "import org.eclipse.gmf.runtime.emf.core.internal.util.MSLMetaModelManager;" + NL + "import org.eclipse.jface.resource.ImageDescriptor;" + NL + "import org.eclipse.ui.plugin.AbstractUIPlugin;" + NL + "import org.osgi.framework.BundleContext;" + NL + "import ";
d28 2
a29 2
  protected final String TEXT_9 = " ourInstance;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_10 = "() {" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void start(BundleContext context) throws Exception {" + NL + "\t\tsuper.start(context);" + NL + "\t\tourInstance = this;" + NL + "\t\tPreferencesHint.registerPreferenceStore(new PreferencesHint(EDITOR_ID), getPreferenceStore());";
d33 8
a40 3
  protected final String TEXT_14 = ".INSTANCE);" + NL + "\t\tElementTypes.register();" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void stop(BundleContext context) throws Exception {" + NL + "\t\tourInstance = null;" + NL + "\t\tsuper.stop(context);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static ";
  protected final String TEXT_15 = " getInstance() {" + NL + "\t\treturn ourInstance;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * Returns an image descriptor for the image file at the given" + NL + "\t * plug-in relative path." + NL + "\t *" + NL + "\t * @@generated" + NL + "\t * @@param path the path" + NL + "\t * @@return the image descriptor" + NL + "\t */" + NL + "\tpublic static ImageDescriptor getImageDescriptor(String path) {" + NL + "\t\treturn AbstractUIPlugin.imageDescriptorFromPlugin(ID, path);" + NL + "\t}" + NL + "}";
  protected final String TEXT_16 = NL;
d45 4
a48 1
    GenDiagram genDiagram = (GenDiagram) argument;
d83 25
d109 1
a109 1
    stringBuffer.append(TEXT_16);
@


1.1
log
@[dstadnik] Use Notation Model as runtime model
@
text
@a39 1
    GenModel genModel = genDiagram.getEmfGenModel();
d60 1
a60 1
GenPackage genPackage = genDiagram.getEmfGenModel().findGenPackage(genDiagram.getDomainMetaModel());
@

