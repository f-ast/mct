head	1.23;
access;
symbols
	v20081022-1925:1.23
	v20081015-1925:1.23
	v20081008-1925:1.23
	v20081001-1925:1.23
	v20080924-1925:1.23
	v20080917-1925:1.23
	v20080911-1728:1.23
	v20080910-1520:1.23
	v20080903-1520:1.23
	v20080827-1520:1.23
	v20080813-1520:1.23
	v20080806-1520:1.23
	v20070420-1000:1.21
	v20070413-1300:1.21
	v20070405-1100:1.21
	v20070403-1500:1.21
	v20070330-1300:1.21
	v20060330-1300:1.21
	v20070322-1100:1.21
	v20060316-0600:1.21
	v20070307-0700:1.21
	v20070301-1200:1.21
	v20070228-2000:1.21
	v20070221-1500:1.21
	v20070208-1800:1.21
	v20070202-0200:1.20
	v20070103-0300:1.21
	M4_20:1.21
	v20061222-1800:1.21
	v20061218-1200:1.21
	v20061214-0000:1.21
	v20061120-1300:1.21
	M3_20:1.21
	v20061117-0800:1.21
	v20061027-1200:1.20
	v20061020-1000:1.20
	v20061013-1330:1.21
	v20060919-0800:1.20
	v20060907-1100:1.20
	M1_20:1.21
	v20060904-1500:1.21
	v20060824-1600:1.20
	v20060817-1500:1.20
	v20060728-0500:1.20
	v20060713-1700:1.20
	R1_0_maintenance:1.20.0.2
	R1_0:1.20
	v20060627-1200:1.20
	v20060626-1420:1.20
	v20060620-0400:1.20
	v20060616-1400:1.20
	v20060616-1200:1.20
	v20060609-1400:1.20
	v20060531-1730:1.18
	v20060530-1930:1.18
	v20060526-1200:1.17
	v20060519-1300:1.17
	v20060519-0800:1.17
	v20060512-1000:1.16
	I20060512-1000:1.16
	I20060505-1400:1.16
	I20060428-1300:1.16
	I20060424-0500:1.16
	I20060424-0300:1.16
	M6_10:1.16
	I20060407-1200:1.13
	I20060331-1000:1.12
	I20060324-0300:1.12
	I20060317-1300:1.12
	I20060317-1200:1.12
	I20060316-1300:1.12
	I20060309-1300:1.12
	M5_10:1.11
	S20060303-1600:1.11
	I20060227-1730:1.11
	I20060216-1945:1.11
	I20060210-1715:1.8
	I20060209-1815:1.8
	I20060203-0830:1.3
	I20060202-1415:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.23
date	2007.04.27.08.33.37;	author dstadnik;	state dead;
branches;
next	1.22;
commitid	15c64631b5604567;

1.22
date	2007.04.24.08.57.56;	author dstadnik;	state Exp;
branches;
next	1.21;
commitid	78b462dc68e4567;

1.21
date	2006.08.29.17.03.35;	author ashatalin;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.01.12.42.51;	author atikhomirov;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.01.09.14.34;	author dstadnik;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.29.18.20.56;	author ashatalin;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.18.13.58.29;	author atikhomirov;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.08.17.19.56;	author ashatalin;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.08.16.56.37;	author dstadnik;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.08.11.41.50;	author dstadnik;	state dead;
branches;
next	1.13;

1.13
date	2006.04.07.14.49.25;	author ashatalin;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.07.15.45.29;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.15.13.27.40;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.14.13.06.38;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.13.16.49.10;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.08.17.15.50;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.08.00.17.46;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.06.13.14.41;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.06.11.34.23;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.05.22.57.54;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.01.11.04.26;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.31.11.00.48;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.30.18.26.46;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.23
log
@rewrite AbstractParser in xpand
@
text
@package org.eclipse.gmf.codegen.templates.providers;

import org.eclipse.gmf.codegen.gmfgen.*;
import org.eclipse.gmf.common.codegen.*;

public class AbstractParserGenerator
{
  protected static String nl;
  public static synchronized AbstractParserGenerator create(String lineSeparator)
  {
    nl = lineSeparator;
    AbstractParserGenerator result = new AbstractParserGenerator();
    nl = null;
    return result;
  }

  protected final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + "/*" + NL + " * ";
  protected final String TEXT_3 = NL + " */";
  protected final String TEXT_4 = NL + NL + "import java.text.MessageFormat;" + NL + "import java.text.ParsePosition;" + NL + "" + NL + "import org.eclipse.core.runtime.IAdaptable;" + NL + "import org.eclipse.emf.ecore.EClassifier;" + NL + "import org.eclipse.emf.ecore.EDataType;" + NL + "import org.eclipse.emf.ecore.EEnum;" + NL + "import org.eclipse.emf.ecore.EEnumLiteral;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.EStructuralFeature;" + NL + "import org.eclipse.gmf.runtime.common.core.command.ICommand;" + NL + "import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;";
  protected final String TEXT_5 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public abstract class ";
  protected final String TEXT_6 = " implements IParser {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String viewPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat viewProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String editPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat editProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getViewPattern() {" + NL + "\t\treturn viewPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getViewProcessor() {" + NL + "\t\treturn viewProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setViewPattern(String viewPattern) {" + NL + "\t\tthis.viewPattern = viewPattern;" + NL + "\t\tviewProcessor = createViewProcessor(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createViewProcessor(String viewPattern) {" + NL + "\t\treturn new MessageFormat(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditPattern() {" + NL + "\t\treturn editPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getEditProcessor() {" + NL + "\t\treturn editProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditPattern(String editPattern) {" + NL + "\t\tthis.editPattern = editPattern;" + NL + "\t\teditProcessor = createEditProcessor(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createEditProcessor(String editPattern) {" + NL + "\t\treturn new MessageFormat(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getPrintString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getViewPattern(), getViewProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getEditPattern(), getEditProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract String getStringByPattern(IAdaptable adapter, int flags, String pattern, MessageFormat processor);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IParserEditStatus isValidEditString(IAdaptable element, String editString) {" + NL + "\t\tParsePosition pos = new ParsePosition(0);" + NL + "\t\tObject[] values = getEditProcessor().parse(editString, pos);" + NL + "\t\tif (values == null) {" + NL + "\t\t\treturn new ParserEditStatus(";
  protected final String TEXT_7 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] values = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tvalue = getValidNewValue(feature, value);" + NL + "\t\tif (value instanceof InvalidValue) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (String.class.equals(iClass)) {" + NL + "\t\t\t\tif (value == null) {" + NL + "\t\t\t\t\tvalue = \"\"; //$NON-NLS-1$" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidNewValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (Boolean.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Boolean) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tvalue = Boolean.valueOf((String) value);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Boolean is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Character.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Character) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = new Character(s.charAt(0));" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Character is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Byte.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Byte) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Byte(((Number) value).byteValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Byte.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Byte value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Byte is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Short.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Short) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Short(((Number) value).shortValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Short.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Short value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Short is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Integer.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Integer) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Integer(((Number) value).intValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Integer.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Integer value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Integer is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Long.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Long) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Long(((Number) value).longValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Long.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Long value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Long is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Float.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Float) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Float(((Number) value).floatValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Float.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Float value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Float is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Double.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Double) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Double(((Number) value).doubleValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Double.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Double value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Double is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (type instanceof EEnum) {" + NL + "\t\t\t\tif (value instanceof String) {" + NL + "\t\t\t\t\tEEnumLiteral literal = ((EEnum) type).getEEnumLiteralByLiteral((String) value);" + NL + "\t\t\t\t\tif (literal == null) {" + NL + "\t\t\t\t\t\tvalue = new InvalidValue(\"Unknown literal: \" + value);" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = literal.getInstance();" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type String is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected class InvalidValue {" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tprivate String description;" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic InvalidValue(String description) {" + NL + "\t\t\tthis.description = description;" + NL + "\t\t}" + NL + "" + NL + "\t\t/**" + NL + "\t\t * @@generated" + NL + "\t\t */" + NL + "\t\tpublic String toString() {" + NL + "\t\t\treturn description;" + NL + "\t\t}" + NL + "\t}" + NL + "}";
  protected final String TEXT_8 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    
final GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];

    stringBuffer.append(TEXT_1);
    
String copyrightText = genDiagram.getEditorGen().getCopyrightText();
if (copyrightText != null && copyrightText.trim().length() > 0) {

    stringBuffer.append(TEXT_2);
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
    stringBuffer.append(TEXT_3);
    }
    importManager.emitPackageStatement(stringBuffer);
    stringBuffer.append(TEXT_4);
    importManager.markImportLocation(stringBuffer);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(genDiagram.getAbstractParserClassName());
    stringBuffer.append(TEXT_6);
    stringBuffer.append(importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()));
    stringBuffer.append(TEXT_7);
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_8);
    return stringBuffer.toString();
  }
}
@


1.22
log
@follow consisted spacing policy
@
text
@@


1.21
log
@[155561] Correcting templates in accordance with unit-test.
@
text
@d19 1
a19 1
  protected final String TEXT_2 = NL + "/*" + NL + " *";
d40 1
a40 1
    stringBuffer.append(copyrightText.replaceAll("\n", "\n *"));
@


1.20
log
@regenerated source files with non-nls markers
@
text
@d24 1
a24 1
  protected final String TEXT_7 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] values = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tvalue = getValidNewValue(feature, value);" + NL + "\t\tif (value instanceof InvalidValue) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (String.class.equals(iClass)) {" + NL + "\t\t\t\tif (value == null) {" + NL + "\t\t\t\t\tvalue = \"\"; //$NON-NLS-1$" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidNewValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (Boolean.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Boolean) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tvalue = Boolean.valueOf((String) value);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Boolean is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Character.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Character) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = new Character(s.charAt(0));" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Character is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Byte.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Byte) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Byte(((Number) value).byteValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Byte.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Byte value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Byte is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Short.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Short) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Short(((Number) value).shortValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Short.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Short value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Short is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Integer.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Integer) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Integer(((Number) value).intValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Integer.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Integer value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Integer is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Long.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Long) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Long(((Number) value).longValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Long.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Long value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Long is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Float.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Float) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Float(((Number) value).floatValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Float.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Float value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Float is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Double.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Double) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Double(((Number) value).doubleValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Double.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Double value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Double is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (type instanceof EEnum) {" + NL + "\t\t\t\tif (value instanceof String) {" + NL + "\t\t\t\t\tEEnumLiteral literal = ((EEnum) type).getEEnumLiteralByLiteral((String) value);" + NL + "\t\t\t\t\tif (literal == null) {" + NL + "\t\t\t\t\t\tvalue = new InvalidValue(\"Unknown literal: \" + value);" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = literal.getInstance();" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type String is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected class InvalidValue {" + NL + "" + NL + "\t\tprivate String description;" + NL + "" + NL + "\t\tpublic InvalidValue(String description) {" + NL + "\t\t\tthis.description = description;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic String toString() {" + NL + "\t\t\treturn description;" + NL + "\t\t}" + NL + "\t}" + NL + "}";
@


1.19
log
@header comment should not be a javadoc comment
@
text
@d24 1
a24 1
  protected final String TEXT_7 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] values = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tvalue = getValidNewValue(feature, value);" + NL + "\t\tif (value instanceof InvalidValue) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (String.class.equals(iClass)) {" + NL + "\t\t\t\tif (value == null) {" + NL + "\t\t\t\t\tvalue = \"\";" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidNewValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (Boolean.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Boolean) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tvalue = Boolean.valueOf((String) value);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Boolean is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Character.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Character) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = new Character(s.charAt(0));" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Character is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Byte.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Byte) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Byte(((Number) value).byteValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Byte.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Byte value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Byte is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Short.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Short) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Short(((Number) value).shortValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Short.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Short value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Short is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Integer.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Integer) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Integer(((Number) value).intValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Integer.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Integer value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Integer is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Long.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Long) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Long(((Number) value).longValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Long.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Long value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Long is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Float.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Float) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Float(((Number) value).floatValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Float.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Float value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Float is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Double.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Double) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Double(((Number) value).doubleValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Double.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Double value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Double is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (type instanceof EEnum) {" + NL + "\t\t\t\tif (value instanceof String) {" + NL + "\t\t\t\t\tEEnumLiteral literal = ((EEnum) type).getEEnumLiteralByLiteral((String) value);" + NL + "\t\t\t\t\tif (literal == null) {" + NL + "\t\t\t\t\t\tvalue = new InvalidValue(\"Unknown literal: \" + value);" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = literal.getInstance();" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type String is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected class InvalidValue {" + NL + "" + NL + "\t\tprivate String description;" + NL + "" + NL + "\t\tpublic InvalidValue(String description) {" + NL + "\t\t\tthis.description = description;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic String toString() {" + NL + "\t\t\treturn description;" + NL + "\t\t}" + NL + "\t}" + NL + "}";
@


1.18
log
@Correcting copyright processing
@
text
@d19 1
a19 1
  protected final String TEXT_2 = NL + "/**" + NL + " *";
@


1.17
log
@use importAssistant to emit package statement instead of handcoding
@
text
@d19 1
a19 1
  protected final String TEXT_2 = NL + "/*" + NL + " * ";
d40 1
a40 1
    stringBuffer.append(copyrightText.replaceAll("\n", "\n * "));
@


1.16
log
@using M6 to generate code.
@
text
@d21 5
a25 7
  protected final String TEXT_4 = NL + "package ";
  protected final String TEXT_5 = ";" + NL;
  protected final String TEXT_6 = NL + "import java.text.MessageFormat;" + NL + "import java.text.ParsePosition;" + NL + "" + NL + "import org.eclipse.core.runtime.IAdaptable;" + NL + "import org.eclipse.emf.ecore.EClassifier;" + NL + "import org.eclipse.emf.ecore.EDataType;" + NL + "import org.eclipse.emf.ecore.EEnum;" + NL + "import org.eclipse.emf.ecore.EEnumLiteral;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.EStructuralFeature;" + NL + "import org.eclipse.gmf.runtime.common.core.command.ICommand;" + NL + "import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;";
  protected final String TEXT_7 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public abstract class ";
  protected final String TEXT_8 = " implements IParser {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String viewPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat viewProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String editPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat editProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getViewPattern() {" + NL + "\t\treturn viewPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getViewProcessor() {" + NL + "\t\treturn viewProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setViewPattern(String viewPattern) {" + NL + "\t\tthis.viewPattern = viewPattern;" + NL + "\t\tviewProcessor = createViewProcessor(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createViewProcessor(String viewPattern) {" + NL + "\t\treturn new MessageFormat(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditPattern() {" + NL + "\t\treturn editPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getEditProcessor() {" + NL + "\t\treturn editProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditPattern(String editPattern) {" + NL + "\t\tthis.editPattern = editPattern;" + NL + "\t\teditProcessor = createEditProcessor(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createEditProcessor(String editPattern) {" + NL + "\t\treturn new MessageFormat(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getPrintString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getViewPattern(), getViewProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getEditPattern(), getEditProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract String getStringByPattern(IAdaptable adapter, int flags, String pattern, MessageFormat processor);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IParserEditStatus isValidEditString(IAdaptable element, String editString) {" + NL + "\t\tParsePosition pos = new ParsePosition(0);" + NL + "\t\tObject[] values = getEditProcessor().parse(editString, pos);" + NL + "\t\tif (values == null) {" + NL + "\t\t\treturn new ParserEditStatus(";
  protected final String TEXT_9 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] values = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tvalue = getValidNewValue(feature, value);" + NL + "\t\tif (value instanceof InvalidValue) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (String.class.equals(iClass)) {" + NL + "\t\t\t\tif (value == null) {" + NL + "\t\t\t\t\tvalue = \"\";" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidNewValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (Boolean.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Boolean) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tvalue = Boolean.valueOf((String) value);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Boolean is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Character.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Character) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = new Character(s.charAt(0));" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Character is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Byte.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Byte) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Byte(((Number) value).byteValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Byte.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Byte value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Byte is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Short.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Short) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Short(((Number) value).shortValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Short.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Short value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Short is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Integer.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Integer) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Integer(((Number) value).intValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Integer.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Integer value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Integer is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Long.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Long) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Long(((Number) value).longValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Long.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Long value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Long is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Float.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Float) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Float(((Number) value).floatValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Float.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Float value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Float is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Double.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Double) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Double(((Number) value).doubleValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Double.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Double value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Double is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (type instanceof EEnum) {" + NL + "\t\t\t\tif (value instanceof String) {" + NL + "\t\t\t\t\tEEnumLiteral literal = ((EEnum) type).getEEnumLiteralByLiteral((String) value);" + NL + "\t\t\t\t\tif (literal == null) {" + NL + "\t\t\t\t\t\tvalue = new InvalidValue(\"Unknown literal: \" + value);" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = literal.getInstance();" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type String is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected class InvalidValue {" + NL + "" + NL + "\t\tprivate String description;" + NL + "" + NL + "\t\tpublic InvalidValue(String description) {" + NL + "\t\t\tthis.description = description;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic String toString() {" + NL + "\t\t\treturn description;" + NL + "\t\t}" + NL + "\t}" + NL + "}";
  protected final String TEXT_10 = NL;
d30 4
a33 1
    GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
d43 1
d45 1
a45 1
    stringBuffer.append(genDiagram.getProvidersPackageName());
d47 1
a47 1
    ImportUtil importManager = new ImportUtil(genDiagram.getProvidersPackageName());
d49 1
a49 1
    importManager.markImportLocation(stringBuffer);
d51 1
a51 1
    stringBuffer.append(genDiagram.getAbstractParserClassName());
a52 4
    stringBuffer.append(importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName()));
    stringBuffer.append(TEXT_9);
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_10);
@


1.15
log
@restore generators
@
text
@d31 1
a31 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.14
log
@#134095 do not store compiled templates in cvs
@
text
@d31 1
a31 1
    final StringBuffer stringBuffer = new StringBuffer();
@


1.13
log
@Switching to eclipse M6.
@
text
@@


1.12
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d31 1
a31 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.11
log
@get editing domain from eobject
@
text
@d18 10
a27 7
  protected final String TEXT_1 = "package ";
  protected final String TEXT_2 = ";" + NL;
  protected final String TEXT_3 = NL + "import java.text.MessageFormat;" + NL + "import java.text.ParsePosition;" + NL + "" + NL + "import org.eclipse.core.runtime.IAdaptable;" + NL + "import org.eclipse.emf.ecore.EClassifier;" + NL + "import org.eclipse.emf.ecore.EDataType;" + NL + "import org.eclipse.emf.ecore.EEnum;" + NL + "import org.eclipse.emf.ecore.EEnumLiteral;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.EStructuralFeature;" + NL + "import org.eclipse.gmf.runtime.common.core.command.ICommand;" + NL + "import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;";
  protected final String TEXT_4 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public abstract class ";
  protected final String TEXT_5 = " implements IParser {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String viewPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat viewProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String editPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat editProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getViewPattern() {" + NL + "\t\treturn viewPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getViewProcessor() {" + NL + "\t\treturn viewProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setViewPattern(String viewPattern) {" + NL + "\t\tthis.viewPattern = viewPattern;" + NL + "\t\tviewProcessor = createViewProcessor(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createViewProcessor(String viewPattern) {" + NL + "\t\treturn new MessageFormat(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditPattern() {" + NL + "\t\treturn editPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getEditProcessor() {" + NL + "\t\treturn editProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditPattern(String editPattern) {" + NL + "\t\tthis.editPattern = editPattern;" + NL + "\t\teditProcessor = createEditProcessor(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createEditProcessor(String editPattern) {" + NL + "\t\treturn new MessageFormat(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getPrintString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getViewPattern(), getViewProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getEditPattern(), getEditProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract String getStringByPattern(IAdaptable adapter, int flags, String pattern, MessageFormat processor);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IParserEditStatus isValidEditString(IAdaptable element, String editString) {" + NL + "\t\tParsePosition pos = new ParsePosition(0);" + NL + "\t\tObject[] values = getEditProcessor().parse(editString, pos);" + NL + "\t\tif (values == null) {" + NL + "\t\t\treturn new ParserEditStatus(";
  protected final String TEXT_6 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] values = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tvalue = getValidNewValue(feature, value);" + NL + "\t\tif (value instanceof InvalidValue) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (String.class.equals(iClass)) {" + NL + "\t\t\t\tif (value == null) {" + NL + "\t\t\t\t\tvalue = \"\";" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidNewValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (Boolean.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Boolean) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tvalue = Boolean.valueOf((String) value);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Boolean is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Character.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Character) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = new Character(s.charAt(0));" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Character is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Byte.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Byte) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Byte(((Number) value).byteValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Byte.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Byte value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Byte is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Short.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Short) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Short(((Number) value).shortValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Short.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Short value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Short is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Integer.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Integer) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Integer(((Number) value).intValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Integer.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Integer value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Integer is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Long.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Long) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Long(((Number) value).longValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Long.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Long value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Long is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Float.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Float) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Float(((Number) value).floatValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Float.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Float value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Float is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Double.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Double) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Double(((Number) value).doubleValue());" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tString s = (String) value;" + NL + "\t\t\t\t\tif (s.length() == 0) {" + NL + "\t\t\t\t\t\tvalue = null;" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\t\tvalue = Double.valueOf(s);" + NL + "\t\t\t\t\t\t} catch (NumberFormatException nfe) {" + NL + "\t\t\t\t\t\t\tvalue = new InvalidValue(\"String value does not convert to Double value\");" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Double is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (type instanceof EEnum) {" + NL + "\t\t\t\tif (value instanceof String) {" + NL + "\t\t\t\t\tEEnumLiteral literal = ((EEnum) type).getEEnumLiteralByLiteral((String) value);" + NL + "\t\t\t\t\tif (literal == null) {" + NL + "\t\t\t\t\t\tvalue = new InvalidValue(\"Unknown literal: \" + value);" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = literal.getInstance();" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type String is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected class InvalidValue {" + NL + "" + NL + "\t\tprivate String description;" + NL + "" + NL + "\t\tpublic InvalidValue(String description) {" + NL + "\t\t\tthis.description = description;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic String toString() {" + NL + "\t\t\treturn description;" + NL + "\t\t}" + NL + "\t}" + NL + "}";
  protected final String TEXT_7 = NL;
d34 9
d44 1
a44 1
    stringBuffer.append(TEXT_2);
d46 1
a46 1
    stringBuffer.append(TEXT_3);
d48 1
a48 1
    stringBuffer.append(TEXT_4);
d50 1
a50 1
    stringBuffer.append(TEXT_5);
d52 1
a52 1
    stringBuffer.append(TEXT_6);
d54 1
a54 1
    stringBuffer.append(TEXT_7);
@


1.10
log
@use new transactional emf api
@
text
@d20 1
a20 1
  protected final String TEXT_3 = NL + "import java.text.MessageFormat;" + NL + "import java.text.ParsePosition;" + NL + "" + NL + "import org.eclipse.core.runtime.IAdaptable;" + NL + "import org.eclipse.emf.ecore.EClassifier;" + NL + "import org.eclipse.emf.ecore.EDataType;" + NL + "import org.eclipse.emf.ecore.EEnum;" + NL + "import org.eclipse.emf.ecore.EEnumLiteral;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.EStructuralFeature;" + NL + "import org.eclipse.emf.transaction.TransactionalEditingDomain;" + NL + "import org.eclipse.gmf.runtime.common.core.command.ICommand;" + NL + "import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;";
d22 1
a22 1
  protected final String TEXT_5 = " implements IParser {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate TransactionalEditingDomain editingDomain;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String viewPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat viewProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String editPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat editProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic TransactionalEditingDomain getEditingDomain() {" + NL + "\t\treturn editingDomain;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditingDomain(TransactionalEditingDomain editingDomain) {" + NL + "\t\tthis.editingDomain = editingDomain;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getViewPattern() {" + NL + "\t\treturn viewPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getViewProcessor() {" + NL + "\t\treturn viewProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setViewPattern(String viewPattern) {" + NL + "\t\tthis.viewPattern = viewPattern;" + NL + "\t\tviewProcessor = createViewProcessor(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createViewProcessor(String viewPattern) {" + NL + "\t\treturn new MessageFormat(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditPattern() {" + NL + "\t\treturn editPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getEditProcessor() {" + NL + "\t\treturn editProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditPattern(String editPattern) {" + NL + "\t\tthis.editPattern = editPattern;" + NL + "\t\teditProcessor = createEditProcessor(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createEditProcessor(String editPattern) {" + NL + "\t\treturn new MessageFormat(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getPrintString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getViewPattern(), getViewProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getEditPattern(), getEditProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract String getStringByPattern(IAdaptable adapter, int flags, String pattern, MessageFormat processor);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IParserEditStatus isValidEditString(IAdaptable element, String editString) {" + NL + "\t\tParsePosition pos = new ParsePosition(0);" + NL + "\t\tObject[] values = getEditProcessor().parse(editString, pos);" + NL + "\t\tif (values == null) {" + NL + "\t\t\treturn new ParserEditStatus(";
@


1.9
log
@#127336 add convertion from string
@
text
@d20 1
a20 1
  protected final String TEXT_3 = NL + "import java.text.MessageFormat;" + NL + "import java.text.ParsePosition;" + NL + "" + NL + "import org.eclipse.core.runtime.IAdaptable;" + NL + "import org.eclipse.emf.ecore.EClassifier;" + NL + "import org.eclipse.emf.ecore.EDataType;" + NL + "import org.eclipse.emf.ecore.EEnum;" + NL + "import org.eclipse.emf.ecore.EEnumLiteral;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.EStructuralFeature;" + NL + "import org.eclipse.gmf.runtime.common.core.command.ICommand;" + NL + "import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;";
d22 1
a22 1
  protected final String TEXT_5 = " implements IParser {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String viewPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat viewProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String editPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate MessageFormat editProcessor;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getViewPattern() {" + NL + "\t\treturn viewPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getViewProcessor() {" + NL + "\t\treturn viewProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setViewPattern(String viewPattern) {" + NL + "\t\tthis.viewPattern = viewPattern;" + NL + "\t\tviewProcessor = createViewProcessor(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createViewProcessor(String viewPattern) {" + NL + "\t\treturn new MessageFormat(viewPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditPattern() {" + NL + "\t\treturn editPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat getEditProcessor() {" + NL + "\t\treturn editProcessor;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditPattern(String editPattern) {" + NL + "\t\tthis.editPattern = editPattern;" + NL + "\t\teditProcessor = createEditProcessor(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected MessageFormat createEditProcessor(String editPattern) {" + NL + "\t\treturn new MessageFormat(editPattern);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getPrintString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getViewPattern(), getViewProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getEditPattern(), getEditProcessor());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract String getStringByPattern(IAdaptable adapter, int flags, String pattern, MessageFormat processor);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IParserEditStatus isValidEditString(IAdaptable element, String editString) {" + NL + "\t\tParsePosition pos = new ParsePosition(0);" + NL + "\t\tObject[] values = getEditProcessor().parse(editString, pos);" + NL + "\t\tif (values == null) {" + NL + "\t\t\treturn new ParserEditStatus(";
@


1.8
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d23 1
a23 1
  protected final String TEXT_6 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] values = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tvalue = getValidNewValue(feature, value);" + NL + "\t\tif (value instanceof InvalidValue) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (String.class.equals(iClass)) {" + NL + "\t\t\t\tif (value == null) {" + NL + "\t\t\t\t\tvalue = \"\";" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidNewValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (Boolean.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Boolean) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tvalue = Boolean.valueOf((String) value);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Boolean is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Character.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Character) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Character is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Byte.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Byte) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Byte(((Number) value).byteValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Byte is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Short.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Short) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Short(((Number) value).shortValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Short is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Integer.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Integer) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Integer(((Number) value).intValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Integer is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Long.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Long) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Long(((Number) value).longValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Long is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Float.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Float) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Float(((Number) value).floatValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Float is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Double.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Double) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Double(((Number) value).doubleValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Double is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (type instanceof EEnum) {" + NL + "\t\t\t\tif (value instanceof String) {" + NL + "\t\t\t\t\tEEnumLiteral literal = ((EEnum) type).getEEnumLiteralByLiteral((String) value);" + NL + "\t\t\t\t\tif (literal == null) {" + NL + "\t\t\t\t\t\tvalue = new InvalidValue(\"Unknown literal: \" + value);" + NL + "\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\tvalue = literal.getInstance();" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type String is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected class InvalidValue {" + NL + "" + NL + "\t\tprivate String description;" + NL + "" + NL + "\t\tpublic InvalidValue(String description) {" + NL + "\t\t\tthis.description = description;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic String toString() {" + NL + "\t\t\treturn description;" + NL + "\t\t}" + NL + "\t}" + NL + "}";
@


1.7
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d29 1
a29 1
    GenDiagram genDiagram = (GenDiagram) argument;
@


1.6
log
@#126541 Support features with enumeration-based types for label model facets
@
text
@d39 1
a39 1
    stringBuffer.append(importManager.getImportedName(genDiagram.getPlugin().getActivatorQualifiedClassName()));
@


1.5
log
@do not show 'null' for strings when they are not set in model
@
text
@d20 1
a20 1
  protected final String TEXT_3 = NL + "import java.text.MessageFormat;" + NL + "import java.text.ParsePosition;" + NL + "" + NL + "import org.eclipse.core.runtime.IAdaptable;" + NL + "import org.eclipse.emf.ecore.EClassifier;" + NL + "import org.eclipse.emf.ecore.EDataType;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.EStructuralFeature;" + NL + "import org.eclipse.gmf.runtime.common.core.command.ICommand;" + NL + "import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;";
d23 1
a23 1
  protected final String TEXT_6 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] values = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tvalue = getValidNewValue(feature, value);" + NL + "\t\tif (value instanceof InvalidValue) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (String.class.equals(iClass)) {" + NL + "\t\t\t\tif (value == null) {" + NL + "\t\t\t\t\tvalue = \"\";" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidNewValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (Boolean.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Boolean) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tvalue = Boolean.valueOf((String) value);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Boolean is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Character.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Character) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Character is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Byte.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Byte) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Byte(((Number) value).byteValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Byte is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Short.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Short) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Short(((Number) value).shortValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Short is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Integer.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Integer) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Integer(((Number) value).intValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Integer is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Long.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Long) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Long(((Number) value).longValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Long is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Float.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Float) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Float(((Number) value).floatValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Float is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Double.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Double) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Double(((Number) value).doubleValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Double is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected class InvalidValue {" + NL + "" + NL + "\t\tprivate String description;" + NL + "" + NL + "\t\tpublic InvalidValue(String description) {" + NL + "\t\t\tthis.description = description;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic String toString() {" + NL + "\t\t\treturn description;" + NL + "\t\t}" + NL + "\t}" + NL + "}";
@


1.4
log
@ImportManager moved to oeg.common
@
text
@d23 1
a23 1
  protected final String TEXT_6 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] values = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (values == null || validateNewValues(values).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] values);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tvalue = getValidNewValue(feature, value);" + NL + "\t\tif (value instanceof InvalidValue) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object getValidNewValue(EStructuralFeature feature, Object value) {" + NL + "\t\tEClassifier type = feature.getEType();" + NL + "\t\tif (type instanceof EDataType) {" + NL + "\t\t\tClass iClass = type.getInstanceClass();" + NL + "\t\t\tif (Boolean.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Boolean) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof String) {" + NL + "\t\t\t\t\tvalue = Boolean.valueOf((String) value);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Boolean is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Character.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Character) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Character is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Byte.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Byte) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Byte(((Number) value).byteValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Byte is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Short.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Short) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Short(((Number) value).shortValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Short is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Integer.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Integer) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Integer(((Number) value).intValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Integer is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Long.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Long) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Long(((Number) value).longValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Long is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Float.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Float) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Float(((Number) value).floatValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Float is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t} else if (Double.TYPE.equals(iClass)) {" + NL + "\t\t\t\tif (value instanceof Double) {" + NL + "\t\t\t\t\t// ok" + NL + "\t\t\t\t} else if (value instanceof Number) {" + NL + "\t\t\t\t\tvalue = new Double(((Number) value).doubleValue());" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tvalue = new InvalidValue(\"Value of type Double is expected\");" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn value;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected class InvalidValue {" + NL + "" + NL + "\t\tprivate String description;" + NL + "" + NL + "\t\tpublic InvalidValue(String description) {" + NL + "\t\t\tthis.description = description;" + NL + "\t\t}" + NL + "" + NL + "\t\tpublic String toString() {" + NL + "\t\t\treturn description;" + NL + "\t\t}" + NL + "\t}" + NL + "}";
@


1.3
log
@#121534 Support link labels based on attributes that are not strings
@
text
@d4 1
a4 1
import org.eclipse.gmf.codegen.util.*;
@


1.2
log
@#125729 Support labels based on multiple structural features
@
text
@d20 1
a20 1
  protected final String TEXT_3 = NL + "import java.text.MessageFormat;" + NL + "import java.text.ParsePosition;" + NL + "" + NL + "import org.eclipse.core.runtime.IAdaptable;" + NL + "import org.eclipse.emf.ecore.EObject;" + NL + "import org.eclipse.emf.ecore.EStructuralFeature;" + NL + "import org.eclipse.gmf.runtime.common.core.command.ICommand;" + NL + "import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;" + NL + "import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;";
d23 1
a23 1
  protected final String TEXT_6 = ".ID," + NL + "\t\t\t\tIParserEditStatus.UNEDITABLE, \"Invalid input at \" + pos.getErrorIndex());" + NL + "\t\t}" + NL + "\t\treturn validateNewValues(values);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected IParserEditStatus validateNewValues(Object[] values) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ICommand getParseCommand(IAdaptable adapter, String newString, int flags) {" + NL + "\t\tObject[] newValues = getEditProcessor().parse(newString, new ParsePosition(0));" + NL + "\t\tif (newValues == null || validateNewValues(newValues).getCode() != IParserEditStatus.EDITABLE) {" + NL + "\t\t\treturn UnexecutableCommand.INSTANCE;" + NL + "\t\t}" + NL + "\t\treturn getParseCommand(adapter, newValues);" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract ICommand getParseCommand(IAdaptable adapter, Object[] newValues);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModificationCommand(EObject element, EStructuralFeature feature, Object value) {" + NL + "\t\tSetRequest request = new SetRequest(element, feature, value);" + NL + "\t\treturn new SetValueCommand(request);" + NL + "\t}" + NL + "}";
@


1.1
log
@#125729 Support labels based on multiple structural features
@
text
@d4 1
d19 6
a24 3
  protected final String TEXT_2 = ";" + NL + "" + NL + "import java.text.MessageFormat;" + NL + "import java.text.ParseException;" + NL + "" + NL + "import org.eclipse.core.runtime.IAdaptable;" + NL + "import org.eclipse.core.runtime.IProgressMonitor;" + NL + "import org.eclipse.gmf.runtime.common.core.command.CommandResult;" + NL + "import org.eclipse.gmf.runtime.common.core.command.ICommand;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParser;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.IParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.common.ui.services.parser.ParserEditStatus;" + NL + "import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractModelCommand;" + NL + "import org.eclipse.jface.text.contentassist.IContentAssistProcessor;" + NL + "" + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public abstract class ";
  protected final String TEXT_3 = " implements IParser {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate static final Object[] NO_VALUES = new Object[0];" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String viewPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate String editPattern;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getViewPattern() {" + NL + "\t\treturn viewPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setViewPattern(String viewPattern) {" + NL + "\t\tthis.viewPattern = viewPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditPattern() {" + NL + "\t\treturn editPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void setEditPattern(String editPattern) {" + NL + "\t\tthis.editPattern = editPattern;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getPrintString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getViewPattern());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic String getEditString(IAdaptable adapter, int flags) {" + NL + "\t\treturn getStringByPattern(adapter, flags, getEditPattern());" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected abstract String getStringByPattern(IAdaptable adapter, int flags, String pattern);" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected Object[] getValuesFromEditString(String editString, String pattern) {" + NL + "\t\tObject[] values;" + NL + "\t\ttry {" + NL + "\t\t\tvalues = new MessageFormat(pattern).parse(editString);" + NL + "\t\t} catch (ParseException pe) {" + NL + "\t\t\tvalues = NO_VALUES;" + NL + "\t\t}" + NL + "\t\treturn values;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IParserEditStatus isValidEditString(IAdaptable element, String editString) {" + NL + "\t\treturn ParserEditStatus.EDITABLE_STATUS;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic IContentAssistProcessor getCompletionProcessor(IAdaptable element) {" + NL + "\t\treturn null;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected ICommand getModelCommand(ICommand semanticCommand) {" + NL + "\t\tfinal ICommand command = semanticCommand;" + NL + "\t\treturn new AbstractModelCommand(command.getLabel(), command.getAffectedObjects()) {" + NL + "" + NL + "\t\t\tprotected CommandResult doExecute(IProgressMonitor progressMonitor) {" + NL + "\t\t\t\tcommand.execute(progressMonitor);" + NL + "\t\t\t\treturn command.getCommandResult();" + NL + "\t\t\t}" + NL + "\t\t};" + NL + "\t}" + NL + "}";
  protected final String TEXT_4 = NL;
d33 1
a33 1
    stringBuffer.append(genDiagram.getAbstractParserClassName());
d35 1
d37 6
@

