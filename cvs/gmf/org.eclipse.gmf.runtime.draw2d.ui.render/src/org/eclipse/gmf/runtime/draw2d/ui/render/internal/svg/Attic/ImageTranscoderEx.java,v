head	1.7;
access;
symbols
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	I20060209-1815:1.6
	I20060203-0830:1.6
	I20060129-1145:1.6
	I20060127-0900:1.6
	I20060120-1530:1.6
	I20060113-1700:1.6
	M4_10:1.6
	I20060107-1100:1.6
	I20060105-1630:1.6
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051208-2000:1.5
	I20051201-1800:1.4
	I20051124-2000:1.3
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.7
date	2006.02.10.19.18.31;	author sshaw;	state dead;
branches;
next	1.6;

1.6
date	2006.01.03.15.15.18;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.05.19.18.18;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.29.16.33.55;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.21.16.12.07;	author cmahoney;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.24.38;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.49;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.7
log
@bugzilla 119319 gmf-head sshaw 060210 Support extensibility for RenderedImageFactory
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2004, 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.render.internal.svg;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.geom.Dimension2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.batik.bridge.BaseScriptingEnvironment;
import org.apache.batik.bridge.BridgeContext;
import org.apache.batik.bridge.BridgeException;
import org.apache.batik.bridge.GVTBuilder;
import org.apache.batik.bridge.ViewBox;
import org.apache.batik.dom.svg.SVGDOMImplementation;
import org.apache.batik.dom.svg.SVGOMDocument;
import org.apache.batik.dom.util.DOMUtilities;
import org.apache.batik.ext.awt.RenderingHintsKeyExt;
import org.apache.batik.gvt.CanvasGraphicsNode;
import org.apache.batik.gvt.GraphicsNode;
import org.apache.batik.transcoder.TranscoderException;
import org.apache.batik.transcoder.TranscoderOutput;
import org.apache.batik.transcoder.TranscodingHints;
import org.apache.batik.transcoder.image.ImageTranscoder;
import org.apache.batik.transcoder.keys.BooleanKey;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.svg.SVGSVGElement;

/**
 * @@author sshaw
 *
 * Class extension for handling turning on/off anti-aliasing, replacing black and white
 * colors with choice colors and turning on/off maintain aspect ratio capability.
 */
public class ImageTranscoderEx extends ImageTranscoder {
	/**
	 * @@author sshaw
	 *
	 * Utility class for returning float width and height values from a method.
	 */
	public class DimensionFloat extends Dimension2D {

		private float w;
		private float h;
		
		/**
		 * 
		 */
		public DimensionFloat(float width, float height) {
			super();
			this.w = width;
			this.h = height;
		}

		/* (non-Javadoc)
		 * @@see java.awt.geom.Dimension2D#getWidth()
		 */
		public double getWidth() {
			return w;
		}

		/* (non-Javadoc)
		 * @@see java.awt.geom.Dimension2D#getHeight()
		 */
		public double getHeight() {
			return h;
		}

		/* (non-Javadoc)
		 * @@see java.awt.geom.Dimension2D#setSize(double, double)
		 */
		public void setSize(double width, double height) {
			this.w = (float)width;
			this.h = (float)height;

		}

	}

	/**
	 * Constructor to create an instance of SWTImageTranscoder.
	 */
	public ImageTranscoderEx() {
		// empty constructor
	}
	
	public static final TranscodingHints.Key KEY_MAINTAIN_ASPECT_RATIO
		= new BooleanKey();
	
	public static final TranscodingHints.Key KEY_FILL_COLOR
		= new ColorKey();
	
	public static final TranscodingHints.Key KEY_OUTLINE_COLOR
		= new ColorKey();
	
	public static final TranscodingHints.Key KEY_ANTI_ALIASING
		= new BooleanKey();
						
	/**
	 * initSVGDocument
	 * This is an initialization method for setting alternate stylesheet if
	 * set as a hint and also initializes the SVG document with the appropriate
	 * context.
	 * 
	 * @@param svgDoc SVGODocument to initialize.
	 */
	protected void initSVGDocument(SVGOMDocument svgDoc) {
		Color fillColor = null;
		Color outlineColor = null;
		if (hints.containsKey(KEY_FILL_COLOR)) {
			fillColor = (Color)hints.get(KEY_FILL_COLOR);
		}
		
		if (hints.containsKey(KEY_OUTLINE_COLOR)) {
			outlineColor = (Color)hints.get(KEY_OUTLINE_COLOR);
		}
		
		if (fillColor == null && outlineColor == null)
			return;
		
		SVGColorConverter.getInstance().replaceDocumentColors(svgDoc, fillColor, outlineColor);
	}
	
	/**
	 * buildGVTTree
	 * This method builds the GVT tree that is used to render the SVG data.
	 * 
	 * @@param svgDoc SVGOMDocument representing the physical SVG document.
	 * @@param context BridgeContext containing information of the render to occur.
	 * @@return GraphicsNode object.
	 * @@throws TranscoderException thrown if a BridgeException occurs when building the root object.
	 */
	protected GraphicsNode buildGVTTree(SVGOMDocument svgDoc, BridgeContext context)  
										throws TranscoderException {
		GVTBuilder gvtBuilder = new GVTBuilder();
		GraphicsNode gvtRoot = null;
		try {
			gvtRoot = gvtBuilder.build(context, svgDoc);

		} catch (BridgeException ex) {
			throw new TranscoderException(ex);
		}
		
		return gvtRoot;
	}
	
	
	/**
	 * calculateSizeTransform
	 * Calculates the transformation matrix that is applied during the render operation.  Specifically,
	 * the transformation for changing the size of the rendered data.
	 * 
	 * @@param svgRoot SVGSVGElement root element of the SVG tree.
	 * @@param gvtRoot GraphicsNode graphic node root
	 * @@param uri String of the SVG document URI
	 * @@param docWidth float width values of the original vector.
	 * @@param docHeight float height values of the original vector.
	 * @@param newWidth float width values of the rendered image.
	 * @@param newHeight float height values of the rendered image.
	 * @@return AffineTransform object that represents the size transformation to take place.
	 * @@throws TranscoderException thrown if a BridgeException occurs when building the root object.
	 */
	protected AffineTransform calculateSizeTransform(SVGSVGElement svgRoot, GraphicsNode gvtRoot, String uri, 
			float docWidth, float docHeight, 
			float newWidth, float newHeight) 
	throws TranscoderException {
		AffineTransform Px;
		String ref = null;
		try {
			ref = new URL(uri == null ? "": uri).getRef(); //$NON-NLS-1$
		} catch (MalformedURLException ex) {
			// nothing to do, catched previously
		}
		
		boolean maintainAspectRatio = true;
		if (hints.containsKey(KEY_MAINTAIN_ASPECT_RATIO)) {
			maintainAspectRatio = ((Boolean)hints.get(KEY_MAINTAIN_ASPECT_RATIO)).booleanValue();
		}
		
		if (maintainAspectRatio) {
			try {
				Px = ViewBox.getViewTransform(ref, svgRoot, newWidth, newHeight);
			} catch (BridgeException ex) {
				throw new TranscoderException(ex);
			}
			
			if (Px.isIdentity() && (newWidth != docWidth || newHeight != docHeight)) {
				// The document has no viewBox, we need to resize it by hand.
				// we want to keep the document size ratio
				float d = Math.max(docWidth, docHeight);
				float dd = Math.max(newWidth, newHeight);
				float scale = dd/d;
				Px = AffineTransform.getScaleInstance(scale, scale);
			}
		}
		else {
			float xscale = newWidth / docWidth;
			float yscale = newHeight / docHeight; 
			Px = AffineTransform.getScaleInstance(xscale, yscale);
		}
		
		// take the AOI into account if any
		if (hints.containsKey(KEY_AOI)) {
			Rectangle2D aoi = (Rectangle2D)hints.get(KEY_AOI);
			// transform the AOI into the image's coordinate system
			aoi = Px.createTransformedShape(aoi).getBounds2D();
			AffineTransform Mx = new AffineTransform();
			double sx = newWidth / aoi.getWidth();
			double sy = newHeight / aoi.getHeight();
			Mx.scale(sx, sy);
			double tx = -aoi.getX();
			double ty = -aoi.getY();
			Mx.translate(tx, ty);

			// take the AOI transformation matrix into account
			// we apply first the preserveAspectRatio matrix
			Px.preConcatenate(Mx);
		}
		
		CanvasGraphicsNode cgn = getCanvasGraphicsNode(gvtRoot);
        if (cgn != null) {
            cgn.setViewingTransform(Px);
            curTxf = new AffineTransform();
        } else {
            curTxf = Px;
        }
        
		return curTxf;
	}
	
	private boolean shouldCopyDocument(Document document) {
		if (!(document.getImplementation() instanceof SVGDOMImplementation))
			return true;
		
		if (hints.containsKey(KEY_FILL_COLOR) ||
			hints.containsKey(KEY_OUTLINE_COLOR)) {
			return true;
		}
		
		return false;
	}
	/**
	 * Transcodes the specified Document as an image in the specified output.
	 *
	 * @@param document the document to transcode
	 * @@param uri the uri of the document or null if any
	 * @@param output the ouput where to transcode
	 * @@exception TranscoderException if an error occured while transcoding
	 */
	protected void transcode(Document document,
			String uri,
			TranscoderOutput output)
	throws TranscoderException {

		if (shouldCopyDocument(document)) {
			DOMImplementation impl;
			impl = SVGDOMImplementation.getDOMImplementation();
			document = DOMUtilities.deepCloneDocument(document, impl);
			if (uri != null) {
				try { 
					URL url = new URL(uri);
					((SVGOMDocument)document).setURLObject(url);
				} catch (MalformedURLException mue) {

					//TODO: Implement error handling
				}
			}
		}

		ctx = new BridgeContext(userAgent);
		SVGOMDocument svgDoc = (SVGOMDocument)document;
		SVGSVGElement svgRoot = svgDoc.getRootElement();

		// build the GVT tree
		builder = new GVTBuilder();
		// flag that indicates if the document is dynamic
		boolean isDynamic = 
			(hints.containsKey(KEY_EXECUTE_ONLOAD) &&
					((Boolean)hints.get(KEY_EXECUTE_ONLOAD)).booleanValue() &&
					BaseScriptingEnvironment.isDynamicDocument(ctx, svgDoc));

		if (isDynamic)
			ctx.setDynamicState(BridgeContext.DYNAMIC);

		initSVGDocument(svgDoc);
		
		GraphicsNode gvtRoot;
		try {
			gvtRoot = builder.build(ctx, svgDoc);
		} catch (BridgeException ex) {
			throw new TranscoderException(ex);
		}
		
		// get the 'width' and 'height' attributes of the SVG document
		float docWidth = (float)ctx.getDocumentSize().getWidth();
		float docHeight = (float)ctx.getDocumentSize().getHeight();

		setImageSize(docWidth, docHeight);

		//compute the transformation matrix
		AffineTransform Px = calculateSizeTransform(svgRoot, gvtRoot, uri, docWidth, docHeight, width, height);

		gvtRoot = renderImage(output, gvtRoot, Px, (int)width, (int)height);

		this.root = gvtRoot;
	}
	
	/**
	 * @@param output
	 * @@param gvtRoot
	 * @@param Px
	 * @@param w
	 * @@param h
	 * @@return
	 * @@throws TranscoderException
	 */
	private GraphicsNode renderImage(TranscoderOutput output, GraphicsNode gvtRoot, AffineTransform Px, int w, int h)
		throws TranscoderException {
		
		Graphics2D g2d = createGraphics(w, h);

		// Check anti-aliasing preference
		if (hints.containsKey(KEY_ANTI_ALIASING)) {	
			boolean antialias = ((Boolean)hints.get(KEY_ANTI_ALIASING)).booleanValue();
			g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				antialias ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
		} else {
			g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
		}
		
		// needed to avoid eroneous error being dumped to console
		g2d.setRenderingHint(RenderingHintsKeyExt.KEY_TRANSCODING,
            RenderingHintsKeyExt.VALUE_TRANSCODING_PRINTING);
		
		g2d.clip(new java.awt.Rectangle(0, 0, w, h));
		
		g2d.transform(Px);
		
		gvtRoot.paint(g2d);
		
		postRenderImage(g2d);
		
		return null;
	}

	/**
	 * @@param w
	 * @@param h
	 * @@return
	 */
	protected Graphics2D createGraphics(int w, int h) {
		bufferedImage = createImage(w, h);
		Graphics2D g2d = bufferedImage.createGraphics();
		g2d.setColor(Color.white);
		g2d.fillRect(0, 0, bufferedImage.getWidth(), bufferedImage.getHeight());
		return g2d;
	}

	protected void postRenderImage(Graphics2D g2d) {
		g2d.dispose();
	}
	
	private BufferedImage bufferedImage = null;
	
	/**
	 * getBufferedImage
	 * Accessor to return the buffered image used for rendering.
	 * 
	 * @@return BufferedImage
	 */
	public BufferedImage getBufferedImage() {
		return bufferedImage;
	}
	
	/**
	 * Override to create a BufferedImage type that support an alpha channel for
	 * transparency.
	 * 
	 * @@see org.apache.batik.transcoder.image.ImageTranscoder#createImage(int, int)
	 */
	public BufferedImage createImage(int w, int h) {
		return new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
	}
	
	/** 
	 * Override to support the translation of the BufferedImage type into the SWT Image
	 * format.
	 * 
	 * @@see org.apache.batik.transcoder.image.ImageTranscoder#writeImage(java.awt.image.BufferedImage, org.apache.batik.transcoder.TranscoderOutput)
	 */
	public void writeImage(BufferedImage img, TranscoderOutput arg1)
		throws TranscoderException {

		bufferedImage = img;
	}
}
@


1.6
log
@bugzilla 111436 gmf-head sshaw 060103 Improve performance of SVG transcoder
@
text
@@


1.5
log
@bugzilla 111436 gmf-head sshaw 051205 Improve performance of SVG transcoder
@
text
@d15 1
a16 1
import java.awt.Shape;
d32 1
a34 3
import org.apache.batik.gvt.renderer.ConcreteImageRendererFactory;
import org.apache.batik.gvt.renderer.ImageRendererFactory;
import org.apache.batik.gvt.renderer.StaticRenderer;
d335 19
a353 19
		// paint the SVG document using the bridge package
		// create the appropriate renderer
		ImageRendererFactory rendFactory = new ConcreteImageRendererFactory();
		StaticRenderer renderer = (StaticRenderer)rendFactory.createStaticImageRenderer();
		
		boolean antialias = true;
		if (hints.containsKey(KEY_ANTI_ALIASING)) {
			antialias = ((Boolean)hints.get(KEY_ANTI_ALIASING)).booleanValue();
		}
		
		RenderingHints renderHints = renderer.getRenderingHints();
		renderHints.put(RenderingHints.KEY_ANTIALIASING,
				antialias ? RenderingHints.VALUE_ANTIALIAS_ON : 
					RenderingHints.VALUE_ANTIALIAS_OFF);
		renderer.setRenderingHints(renderHints);
		
		renderer.updateOffScreen(w, h);
		renderer.setTransform(Px);
		renderer.setTree(gvtRoot);
d355 6
a360 1
		gvtRoot = null; // We're done with it...
d362 12
a373 6
		try {
			Shape raoi = new Rectangle2D.Float(0, 0, width, height);
			// Warning: the renderer's AOI must be in user space
			renderer.repaint(Px.createInverse().createTransformedShape(raoi));
			BufferedImage rend = renderer.getOffScreen();
			renderer = null; // We're done with it...
d375 2
a376 5
			writeImage(rend, output);
		} catch (Exception ex) {
			throw new TranscoderException(ex);
		}
		return gvtRoot;
d378 1
a378 1

@


1.4
log
@bugzilla 111436 gmf-head sshaw 051128 Improve performance of SVG transcoder
@
text
@d247 9
d257 2
d272 1
a272 2
		if ((document != null) &&
				!(document.getImplementation() instanceof SVGDOMImplementation)) {
@


1.3
log
@Bugzilla#115895 gmf_head cmahoney 051121 Clean up usage of new String("abc")
@
text
@a13 1
import java.awt.AlphaComposite;
a14 2
import java.awt.Graphics2D;
import java.awt.Paint;
a31 1
import org.apache.batik.ext.awt.image.GraphicsUtil;
a349 2
			//TODO there should be some optimization opportunities here - to many buffer copies?
			// now we are sure that the aoi is the image size
d356 1
a356 15
			BufferedImage dest = createImage(w, h);

			Graphics2D g2d = GraphicsUtil.createGraphics(dest);
			if (hints.containsKey(KEY_BACKGROUND_COLOR)) {
				Paint bgcolor = (Paint)hints.get(KEY_BACKGROUND_COLOR);
				g2d.setComposite(AlphaComposite.SrcOver);
				g2d.setPaint(bgcolor);
				g2d.fillRect(0, 0, w, h);
			}
			if (rend != null) { // might be null if the svg document is empty
				g2d.drawRenderedImage(rend, new AffineTransform());
			}
			g2d.dispose();
			rend = null; // We're done with it...
			writeImage(dest, output);
a362 4




@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d191 1
a191 1
			ref = new URL(uri == null ? new String(""): uri).getRef(); //$NON-NLS-1$
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 7
/****************************************************************************
 Licensed Materials - Property of IBM
 (C) Copyright IBM Corp. 2002, 2004, 2005. All Rights Reserved.
 
 US Government Users Restricted Rights - Use, duplication or disclosure
 restricted by GSA ADP Schedule Contract with IBM Corp.
 *****************************************************************************/
@

