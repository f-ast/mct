head	1.12;
access;
symbols
	v20081020-0700:1.12
	v20080722-1827:1.12
	R2_1_maintenance:1.12.0.2
	Root_R2_1_maintenance:1.12
	R2_1_0:1.12
	v20080507-2230:1.12
	v20080425-1959:1.12
	v20080331-1625:1.12
	v20080328-1605:1.12
	v20080222-1200:1.11
	v20070809-0000:1.11
	R2_0_maintenance:1.11.0.2
	R2_0:1.11
	R4_20:1.11
	RC3_20:1.11
	v20070614-1400:1.11
	v20070608-1300:1.11
	v20070605-1400:1.10
	v20070601-1400:1.10
	v20070330-1300:1.10
	v20070208-1800:1.10
	M4_20:1.10
	v20061218-1500:1.9.2.1
	v20061214-0000:1.10
	M3_20:1.10
	v20061013-1330:1.10
	v20060919-0800:1.9.2.1
	M1_20:1.9
	v20060721-1130:1.9
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060616-1200:1.9
	v20060609-1400:1.9
	v20060531-1730:1.9
	v20060526-1200:1.8
	I20060505-1400:1.8
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.8
	I20060331-1000:1.8
	I20060324-0300:1.8
	I20060317-1300:1.8
	I20060317-1200:1.8
	I20060316-1300:1.8
	I20060309-1300:1.8
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.8
	I20060216-1945:1.8
	I20060210-1715:1.8
	I20060209-1815:1.8
	I20060203-0830:1.8
	I20060129-1145:1.8
	I20060127-0900:1.8
	I20060120-1530:1.7
	I20060113-1700:1.7
	M4_10:1.7
	I20060107-1100:1.7
	I20060105-1630:1.7
	I20051230-1230:1.7
	I20051223-1100:1.7
	I20051217-0925:1.7
	I20051208-2000:1.7
	I20051201-1800:1.6
	I20051124-2000:1.5
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.5
	I20051106-0900:1.4
	v20051030:1.3;
locks; strict;
comment	@# @;


1.12
date	2008.03.25.18.33.59;	author crevells;	state Exp;
branches;
next	1.11;
commitid	4fe547e945974567;

1.11
date	2007.06.06.13.50.22;	author crevells;	state Exp;
branches;
next	1.10;
commitid	1dfb4666bb9e4567;

1.10
date	2006.10.03.15.05.23;	author ahunter;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.31.19.26.11;	author sshaw;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2006.01.25.18.50.07;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.05.19.18.18;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.29.16.33.56;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.09.18.23.50;	author mmostafa;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.04.21.27.41;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.12.22.25.25;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.24.38;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.55;	author sshaw;	state Exp;
branches;
next	;

1.9.2.1
date	2006.09.13.16.44.44;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.12
log
@[222619] gmf_head wdiu 080325 NPE in ScalableImageFigure
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.render.figures;

import java.io.ByteArrayOutputStream;

import org.eclipse.draw2d.ColorConstants;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.ImageFigure;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.draw2d.ui.internal.mapmode.DiagramMapModeUtil;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.draw2d.ui.render.RenderInfo;
import org.eclipse.gmf.runtime.draw2d.ui.render.RenderedImage;
import org.eclipse.gmf.runtime.draw2d.ui.render.factory.RenderedImageFactory;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.RenderHelper;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.RenderingListener;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
import org.eclipse.swt.graphics.ImageLoader;
import org.eclipse.swt.graphics.RGB;

/**
 * An implementation of {@@link org.eclipse.draw2d.ImageFigure} that allows
 * scaling the underlying image to the containing Figure's bounds, rather then
 * being fixed to the image size.
 * 
 * <p>
 * Any image that can be implemented inside the RenderedImage interface can be
 * supported.
 * </p>
 * 
 * @@author jcorchis / sshaw
 */
public class ScalableImageFigure
	extends ImageFigure {

	private RenderingListenerImpl renderingListener = new RenderingListenerImpl();

	private class RenderingListenerImpl
		implements RenderingListener {

		public RenderingListenerImpl() {
			super();
		}

		/* (non-Javadoc)
		 * @@see org.eclipse.gmf.runtime.draw2d.ui.render.internal.RenderingListener#paintFigureWhileRendering(org.eclipse.draw2d.Graphics)
		 */
		public void paintFigureWhileRendering(Graphics g) {
			ScalableImageFigure.this.paintFigureWhileRendering(g);
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @@see org.eclipse.gmf.runtime.draw2d.ui.render.RenderingListener#imageRendered(org.eclipse.gmf.runtime.draw2d.ui.render.RenderedImage)
		 */
		public void imageRendered(RenderedImage rndImg) {
			if (ScalableImageFigure.this.getParent() != null) {
				ScalableImageFigure.this.setRenderedImage(rndImg);
				ScalableImageFigure.this.repaint();
			}
		}

		/**
		 * @@return <code>IFigure</code> that the listener wraps
		 */
		public ScalableImageFigure getFigure() {
			return ScalableImageFigure.this;
		}
		
		/*
		 * (non-Javadoc)
		 * 
		 * @@see java.lang.Object#equals(java.lang.Object)
		 */
		public boolean equals(Object obj) {
			if (obj instanceof RenderingListenerImpl) {
				return ((RenderingListenerImpl) obj).getFigure().equals(
					getFigure());
			}

			return false;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @@see java.lang.Object#hashCode()
		 */
		public int hashCode() {
			return ScalableImageFigure.this.hashCode();
		}

	}

	/** The preferred size of the image */
	private Dimension preferredSize = new Dimension(-1, -1);

	private static final int FLAG_USE_DEFAULT_IMAGESIZE = MAX_FLAG << 1,
			FLAG_MAINTAIN_ASPECT_RATIO = MAX_FLAG << 2,
			FLAG_ANTI_ALIAS = MAX_FLAG << 3,
			FLAG_USE_ORIGINAL_COLORS = MAX_FLAG << 4;

	/** The last rendered <code>RenderedImage</code> */
	private RenderedImage lastRenderedImage = null;

	/**
	 * Accessor to determine if the rendered image will be anti-aliased (if
	 * possible).
	 * 
	 * @@return <code>boolean</code> <code>true</code> if anti aliasing is
	 *         on, <code>false</code> otherwise.
	 */
	public boolean isAntiAlias() {
		return getFlag(FLAG_ANTI_ALIAS);
	}

	/**
	 * Sets a property to determine if the rendered image will be anti-aliased
	 * (if possible).
	 * 
	 * @@param antiAlias
	 *            <code>boolean</code> <code>true</code> if anti-aliasing is
	 *            to be turned on, <code>false</code> otherwise
	 */
	public void setAntiAlias(boolean antiAlias) {
		setFlag(FLAG_ANTI_ALIAS, antiAlias);
		invalidate();
	}

	/**
	 * Accessor to determine if the rendered image will respect the original
	 * aspect ratio of the default image when resized.
	 * 
	 * @@return <code>boolean</code> <code>true</code> if maintain aspect
	 *         ratio is on, <code>false</code> otherwise.
	 */
	public boolean isMaintainAspectRatio() {
		return getFlag(FLAG_MAINTAIN_ASPECT_RATIO);
	}

	/**
	 * Sets a property to determine if the rendered image will respect the
	 * original aspect ratio of the default image when resized.
	 * 
	 * @@param maintainAspectRatio
	 *            <code>boolean</code> <code>true</code> if maintain aspect
	 *            ratio is to be turned on, <code>false</code> otherwise
	 */
	public void setMaintainAspectRatio(boolean maintainAspectRatio) {
		setFlag(FLAG_MAINTAIN_ASPECT_RATIO, maintainAspectRatio);
		invalidate();
	}

	/**
	 * @@param img
	 *            the <code>Image</code> to render
	 */
	public ScalableImageFigure(Image img) {
		ImageLoader imageLoader = new ImageLoader();
		ByteArrayOutputStream byteOS = new ByteArrayOutputStream();
		imageLoader.data = new ImageData[] {img.getImageData()};
		imageLoader.logicalScreenHeight = img.getBounds().width;
		imageLoader.logicalScreenHeight = img.getBounds().height;
		imageLoader.save(byteOS, SWT.IMAGE_BMP);
		this.lastRenderedImage = RenderedImageFactory.getInstance(byteOS
			.toByteArray());

		setFlag(FLAG_USE_DEFAULT_IMAGESIZE, false);
		setFlag(FLAG_USE_ORIGINAL_COLORS, false);
		setFlag(FLAG_MAINTAIN_ASPECT_RATIO, true);
		setFlag(FLAG_ANTI_ALIAS, true);
	}

	/**
	 * @@param renderedImage
	 */
	public ScalableImageFigure(RenderedImage renderedImage) {
		this(renderedImage, false, false, true);
	}

	/**
	 * Constructor for meta image sources.
	 * 
	 * @@param renderedImage
	 *            the <code>RenderedImage</code> that is used for rendering
	 *            the image.
	 */
	public ScalableImageFigure(RenderedImage renderedImage, boolean antiAlias) {
		this(renderedImage, false, false, antiAlias);
	}

	/**
	 * Constructor for meta image sources.
	 * 
	 * @@param renderedImage
	 *            the <code>RenderedImage</code> that is used for rendering
	 *            the image.
	 * @@param useDefaultImageSize
	 *            <code>boolean</code> indicating whether to initialize the
	 *            preferred size with the default image size. Otherwise, a set
	 *            default will be used instead.
	 * @@param useOriginalColors
	 *            <code>boolean</code> indicating whether to use the original
	 *            colors of the <code>RenderedImage</code> or to replace black
	 *            with outline color and white with the fill color.
	 */
	public ScalableImageFigure(RenderedImage renderedImage,
			boolean useDefaultImageSize, boolean useOriginalColors,
			boolean antiAlias) {
		lastRenderedImage = renderedImage;
		setFlag(FLAG_USE_DEFAULT_IMAGESIZE, useDefaultImageSize);
		setFlag(FLAG_USE_ORIGINAL_COLORS, useOriginalColors);
		setFlag(FLAG_MAINTAIN_ASPECT_RATIO, true);
		setFlag(FLAG_ANTI_ALIAS, antiAlias);
	}

	/**
	 * Sets the preferred size of the image figure.
	 * 
	 * @@param w
	 *            the preferred width of the image
	 * @@param h
	 *            the preferred height of the image
	 */
	public void setPreferredImageSize(int w, int h) {
		preferredSize = new Dimension(w, h);
	}

	/**
	 * Returns the size set specified by setPreferredImageSize() or the size
	 * specified by the image. In the case of meta-images a preferred size of
	 * 32x32 is returned.
	 */
	public Dimension getPreferredSize(int wHint, int hHint) {
		if (preferredSize.height == -1 && preferredSize.width == -1) {
			int extent = MapModeUtil.getMapMode(this).DPtoLP(32);
			preferredSize = new Dimension(extent, extent);
			if (getFlag(FLAG_USE_DEFAULT_IMAGESIZE)) {
				if (getRenderedImage() != null) {
					setRenderedImage(getRenderedImage(new Dimension(0, 0)));
					Image swtImage = null;
					if (getRenderedImage() != null)
						swtImage = getRenderedImage().getSWTImage();
					if (swtImage != null) {
						org.eclipse.swt.graphics.Rectangle imgRect = swtImage
							.getBounds();
						preferredSize.width = MapModeUtil.getMapMode(this)
							.DPtoLP(imgRect.width);
						preferredSize.height = MapModeUtil.getMapMode(this)
							.DPtoLP(imgRect.height);
					}
				}
			}
		}
		return preferredSize;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.draw2d.Figure#setBounds(org.eclipse.draw2d.geometry.Rectangle)
	 */
	public void setBounds(Rectangle rect) {
		Dimension devDim = new Dimension(rect.getSize());
		MapModeUtil.getMapMode(this).LPtoDP(devDim);
		
		if (getRenderedImage() != null) {
			setRenderedImage(getRenderedImage(devDim));
		}

		super.setBounds(rect);
	}

	/**
	 * Override to return an image that is scaled to fit the bounds of the
	 * figure.
	 */
	public Image getImage() {
		if (getRenderedImage() == null)
			return null;

		return getRenderedImage().getSWTImage();
	}

	/**
	 * Gets the <code>RenderedImage</code> that is the for the specified
	 * <code>Dimension</code>
	 * 
	 * @@param dim
	 * @@return the <code>RenderedImage</code>
	 */
private RenderedImage getRenderedImage(Dimension dim) {
		Color fill = getBackgroundColor();
		Color outline = getForegroundColor();
		RenderInfo newRenderInfo = getRenderedImage().getRenderInfo();
		newRenderInfo.setValues(dim.width,
			dim.height,  
			isMaintainAspectRatio(), // maintain aspect ratio
			isAntiAlias(),
			useOriginalColors() ? (RGB)null
				: new RGB(fill.getRed(), fill.getGreen(), fill.getBlue()),
			useOriginalColors() ? (RGB)null
				: new RGB(outline.getRed(), outline.getGreen(), outline.getBlue())); // antialias

		RenderedImage newRenderedImage = getRenderedImage()
			.getNewRenderedImage(newRenderInfo);
		return newRenderedImage;
	}
	/**
	 * @@return a <code>boolean</code> <code>true</code> if the original
	 *         colors of the image should be used for rendering, or
	 *         <code>false</code> indicates that black and white colors can
	 *         replaced by the specified outline and fill colors respectively of
	 *         the <code>RenderInfo</code>.
	 */
	public boolean useOriginalColors() {
		return getFlag(FLAG_USE_ORIGINAL_COLORS);
	}

	/**
	 * If the rendering is occuring on a separate thread, this method is a hook to draw a temporary
	 * image onto the drawing surface.
	 * 
	 * @@param g the <code>Graphics</code> object to paint the temporary image to
	 */
	protected void paintFigureWhileRendering(Graphics g) {
		Rectangle area = getClientArea().getCopy();
		
		g.pushState();
		g.setBackgroundColor(ColorConstants.white);
		g.fillRectangle(area.x, area.y, area.width - 1, area.height - 1);
		g.setForegroundColor(ColorConstants.red);
		g.drawRectangle(area.x, area.y, area.width - 1, area.height - 1);
		g.setLineStyle(SWT.LINE_DOT);
		g.drawLine(area.x, area.y, area.x + area.width, area.y
			+ area.height);
		g.drawLine(area.x + area.width, area.y, area.x, area.y
			+ area.height);
		g.popState();
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.draw2d.Figure#paintFigure(org.eclipse.draw2d.Graphics)
	 */
	protected void paintFigure(Graphics graphics) {
		Rectangle area = getClientArea().getCopy();

        RenderInfo rndInfo = getRenderedImage().getRenderInfo();
        if (!useOriginalColors()) {
            RGB backgroundColor = getBackgroundColor().getRGB();
            RGB foregroundColor = getForegroundColor().getRGB();
            if ((backgroundColor != null && !backgroundColor.equals(rndInfo.getBackgroundColor())) ||
                    (foregroundColor != null && !foregroundColor.equals(rndInfo.getForegroundColor()))) {
                rndInfo.setValues(rndInfo.getWidth(), rndInfo.getHeight(), 
                        rndInfo.shouldMaintainAspectRatio(), 
                        rndInfo.shouldAntiAlias(), getBackgroundColor().getRGB(), getForegroundColor().getRGB());
                setRenderedImage(getRenderedImage().getNewRenderedImage(rndInfo));
            }
        }
		
		setRenderedImage(RenderHelper.getInstance(
			DiagramMapModeUtil.getScale(MapModeUtil.getMapMode(this)), false,
			false, null).drawRenderedImage(graphics, getRenderedImage(), area,
			renderingListener));
	}
	
	

	/**
	 * Gets the <code>RenderedImage</code> that is being displayed by this
	 * figure.
	 * 
	 * @@return <code>RenderedImage</code> that is being displayed by this
	 *         figure.
	 */
	public RenderedImage getRenderedImage() {
		return lastRenderedImage;
	}

	/**
	 * Sets the <code>RenderedImage</code> that is to be displayed by this
	 * figure
	 * 
	 * @@param the
	 *            <code>RenderedImage</code> that is to being displayed by
	 *            this figure
	 */
	public void setRenderedImage(RenderedImage renderedImage) {
		this.lastRenderedImage = renderedImage;
	}
}
@


1.11
log
@[190546] gmf_head crevells 070606 Fill & line colors change on SVG images sporadically  when one image has fill/line color set
@
text
@d281 4
a284 1
		setRenderedImage(getRenderedImage(devDim));
@


1.10
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
d362 12
a373 10
		RenderInfo rndInfo = getRenderedImage().getRenderInfo();
		if (!useOriginalColors()) {
			if (rndInfo.getBackgroundColor() != getBackgroundColor().getRGB() ||
				rndInfo.getForegroundColor() != getForegroundColor().getRGB()) {
				rndInfo.setValues(rndInfo.getWidth(), rndInfo.getHeight(), 
						rndInfo.shouldMaintainAspectRatio(), 
						rndInfo.shouldAntiAlias(), getBackgroundColor().getRGB(), getForegroundColor().getRGB());
				setRenderedImage(getRenderedImage().getNewRenderedImage(rndInfo));
			}
		}
@


1.9
log
@bugzilla 144751 gmf-head sshaw 060531 ScalableImageFigure doesn't reset colors on RenderedImage
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
@


1.9.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@


1.8
log
@bugzilla 124916 gmf-head sshaw 060124 Allow overriding of alternate rendering for ScalableImageFigure when the image is being rendered
@
text
@d362 11
d378 2
@


1.7
log
@bugzilla 111436 gmf-head sshaw 051205 Improve performance of SVG transcoder
@
text
@d16 1
d50 1
a50 2
	private RenderingListenerImpl renderingListener = new RenderingListenerImpl(
		this);
d52 1
a52 1
	static private class RenderingListenerImpl
d55 1
a55 3
		private ScalableImageFigure fig;

		public RenderingListenerImpl(ScalableImageFigure fig) {
a56 1
			this.fig = fig;
d59 2
a60 2
		/**
		 * @@return <code>IFigure</code> that the listener wraps
d62 2
a63 2
		public ScalableImageFigure getFigure() {
			return fig;
d72 3
a74 3
			if (getFigure().getParent() != null) {
				getFigure().setRenderedImage(rndImg);
				getFigure().repaint();
d78 7
d105 1
a105 1
			return getFigure().hashCode();
d332 22
@


1.6
log
@bugzilla 111436 gmf-head sshaw 051128 Improve performance of SVG transcoder
@
text
@d20 1
d25 2
a26 1
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.DrawableRenderedImage;
d32 1
a32 1

d35 3
a37 2
 * An implementation of {@@link org.eclipse.draw2d.ImageFigure} that allows scaling the 
 * underlying image to the containing Figure's bounds, rather then being fixed to the image size.
d39 4
a42 1
 * <p>Any image that can be implemented inside the RenderedImage interface can be supported.</p>
d46 59
a104 1
public class ScalableImageFigure extends ImageFigure {
a107 12
	
	private static final int
		FLAG_USE_DEFAULT_IMAGESIZE = MAX_FLAG << 1,
		FLAG_MAINTAIN_ASPECT_RATIO = MAX_FLAG << 2,
		FLAG_ANTI_ALIAS = MAX_FLAG << 3,
		FLAG_USE_ORIGINAL_COLORS = MAX_FLAG << 4;

	/** The original <code>RenderedImage</code> at 100% device coordinate size */
    private RenderedImage origRenderedImage = null;
    
    /** The cached <code>RenderedImage</code> that was last painted to the graphics context */
    private RenderedImage lastRenderedImage = null;
d109 11
a119 2
    	/**
	 * Accessor to determine if the rendered image will be anti-aliased (if possible).
d121 2
a122 1
	 * @@return <code>boolean</code> <code>true</code> if anti aliasing is on, <code>false</code> otherwise.
d127 1
a127 1
	
d129 2
a130 1
	 * Sets a property to determine if the rendered image will be anti-aliased (if possible).
d132 3
a134 2
	 * @@param antiAlias <code>boolean</code> <code>true</code> if anti-aliasing is to be turned on, 
	 * <code>false</code> otherwise
d140 1
a140 1
	
d142 2
a143 2
	 * Accessor to determine if the rendered image will respect the original aspect 
	 * ratio of the default image when resized.
d145 2
a146 1
	 * @@return <code>boolean</code> <code>true</code> if maintain aspect ratio is on, <code>false</code> otherwise.
d151 1
a151 1
	
d153 2
a154 2
	 * Sets a property to determine if the rendered image will respect the original aspect 
	 * ratio of the default image when resized.
d156 3
a158 2
	 * @@param maintainAspectRatio <code>boolean</code> <code>true</code> if maintain aspect ratio is to be turned on, 
	 * <code>false</code> otherwise
d166 2
a167 1
	 * @@param img the <code>Image</code> to render
d176 3
a178 2
		this.origRenderedImage = RenderedImageFactory.getInstance(byteOS.toByteArray());
		
d184 1
a184 1
	
d191 1
a191 1
	
d195 4
a198 2
	 * @@param renderedImage the <code>RenderedImage</code> that is used for rendering the image.
	 */	
d202 1
a202 1
	
d206 16
a221 9
	 * @@param renderedImage the <code>RenderedImage</code> that is used for rendering the image.
	 * @@param useDefaultImageSize <code>boolean</code> indicating whether to initialize the preferred size 
	 * with the default image size.  Otherwise, a set default will be used instead.
	 * @@param useOriginalColors <code>boolean</code> indicating whether to use the original colors of the
	 * <code>RenderedImage</code> or to replace black with outline color and white with the fill color.
	 */
	public ScalableImageFigure(RenderedImage renderedImage, 
				boolean useDefaultImageSize, boolean useOriginalColors, boolean antiAlias) {
		origRenderedImage = renderedImage;
d227 1
a227 1
	
d231 4
a234 2
	 * @@param w the preferred width of the image
	 * @@param h the preferred height of the image
d241 3
a243 3
	 * Returns the size set specified by setPreferredImageSize() or 
	 * the size specified by the image. In the case of meta-images
	 * a preferred size of 32x32 is returned. 
a246 3
			if (getImage() == null)
				return preferredSize;
			
d248 1
a248 1
			preferredSize =  new Dimension(extent,extent);
d251 1
a251 1
					setRenderedImage( getRenderedImage(new Dimension(0, 0)));
d256 6
a261 3
						org.eclipse.swt.graphics.Rectangle imgRect = swtImage.getBounds();
						preferredSize.width = MapModeUtil.getMapMode(this).DPtoLP(imgRect.width);
						preferredSize.height = MapModeUtil.getMapMode(this).DPtoLP(imgRect.height);
d268 4
a271 3
	
	
	/* (non-Javadoc)
d277 2
a278 2
		setRenderedImage( getRenderedImage(devDim) );
		
d283 2
a284 1
	 * Override to return an image that is scaled to fit the bounds of the figure.
d294 2
a295 1
	 * Gets the <code>RenderedImage</code> that is the for the specified <code>Dimension</code>
d300 12
a311 9
	private RenderedImage getRenderedImage(Dimension dim) {
		RenderInfo newRenderInfo =
			RenderedImageFactory.createInfo(
				dim.width,
				dim.height,
				useOriginalColors() ? null : translateSWTColorToAWTColor(getBackgroundColor()),
				useOriginalColors() ? null : translateSWTColorToAWTColor(getForegroundColor()),
				isMaintainAspectRatio(), // maintain aspect ratio
				isAntiAlias()); // antialias
d313 2
a314 1
		RenderedImage newRenderedImage = getRenderedImage().getNewRenderedImage(newRenderInfo);
a316 1

d318 5
a322 3
	 * @@return a <code>boolean</code> <code>true</code> if the original colors of the image should be used for
	 * rendering, or <code>false</code> indicates that black and white colors can replaced by the specified outline
	 * and fill colors respectively of the <code>RenderInfo</code>.
d327 2
a328 2
	
	/* 
d330 1
a333 1
		int x, y;
d335 7
a341 25
		
		y = (area.height - getBounds().height) / 2 + area.y;
		x = (area.width - getBounds().width) / 2 + area.x;		
		
		if (graphics instanceof DrawableRenderedImage) {
           	lastRenderedImage = ((DrawableRenderedImage) graphics).drawRenderedImage(getRenderedImage(new Dimension(getBounds().width, getBounds().height)),
                       x, y, getBounds().width, getBounds().height);
           	assert lastRenderedImage != null;
		} else { 
			graphics.drawImage(getRenderedImage().getSWTImage(), x, y); 
        }
	}	
	
    /**
     * Returns the corresponding java.awt.Color given an org.eclipse.swt.graphics.Color
     * 
     * @@param swtColor to be translated
     * @@return the corresponding java.awt.Color
     */    
    private java.awt.Color translateSWTColorToAWTColor(Color swtColor) {
		return (swtColor == null) ? null
			: new java.awt.Color(swtColor.getRed(), swtColor.getGreen(),
				swtColor.getBlue());
	}	
    
d343 2
a344 1
	 * Gets the <code>RenderedImage</code> that is being displayed by this figure.
d346 2
a347 1
	 * @@return <code>RenderedImage</code> that is being displayed by this figure.
d350 1
a350 1
		return origRenderedImage;
d352 1
a352 1
	
d354 2
a355 1
	 * Sets the <code>RenderedImage</code> that is to be displayed by this figure
d357 3
a359 1
	 * @@param the <code>RenderedImage</code> that is to being displayed by this figure
d362 1
a362 1
		this.origRenderedImage = renderedImage;
@


1.5
log
@bugzilla 115644 : gmf-head mmostafa 051109 : Null pointer exception while trying to open a diagram using Sun VM
@
text
@d45 8
a52 2
    /** The cached SVGImage */
    private RenderedImage renderedImage = null;
d54 4
a57 9
    private boolean useDefaultImageSize = false;
    
    private boolean maintainAspectRatio = true;
    
    private boolean antiAlias = true;
    
    private boolean useOriginalColors = false;
    
	/**
d63 1
a63 1
		return antiAlias;
d73 1
a73 1
		this.antiAlias = antiAlias;
d84 1
a84 1
		return maintainAspectRatio;
d95 1
a95 1
		this.maintainAspectRatio = maintainAspectRatio;
d109 6
a114 1
		this.renderedImage = RenderedImageFactory.getInstance(byteOS.toByteArray());
d121 1
a121 1
		this.renderedImage = renderedImage;
d130 1
a130 2
		this.renderedImage = renderedImage;
		setAntiAlias(antiAlias);
d144 5
a148 3
		this(renderedImage, antiAlias);
		this.useDefaultImageSize = useDefaultImageSize;
		this.useOriginalColors = useOriginalColors;
d173 1
a173 1
			if (useDefaultImageSize) {
d175 1
a175 1
					RenderedImage rndImage = getRenderedImage(new Dimension(0, 0));
d177 2
a178 2
					if (rndImage != null)
						swtImage = rndImage.getSWTImage();
d191 11
d209 1
a209 9
		Dimension absDim = new Dimension(getBounds().getSize());
		translateToAbsolute(absDim);
		
		RenderedImage rndImage = getRenderedImage(absDim);
		
		if (rndImage != null)
			return rndImage.getSWTImage();
		
		return null;
d229 1
a229 9
		if (getRenderedImage() != null) {
			if (getRenderedImage().equals(newRenderedImage)) {
				newRenderedImage = getRenderedImage();
			}
		}
		
		setRenderedImage(newRenderedImage);
		
		return getRenderedImage();
d238 1
a238 1
		return useOriginalColors;
d253 1
a253 1
           	((DrawableRenderedImage) graphics).drawRenderedImage(getRenderedImage(new Dimension(getBounds().width, getBounds().height)),
d255 1
d257 1
a257 6
		   // translate to device coordinates for rendering
		   area = (Rectangle)MapModeUtil.getMapMode(this).LPtoDP(area);
           RenderedImage rndImage = getRenderedImage(new Dimension(area.width, area.height));
           if (rndImage != null && renderedImage.getSWTImage()!=null)
           		graphics.drawImage(renderedImage.getSWTImage(), x, y); 
           	// no need to dispose img since it is managed by the SVGImage object lifetime
d279 1
a279 1
		return renderedImage;
d288 1
a288 1
		this.renderedImage = renderedImage;
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d257 1
a257 1
           if (rndImage != null)
@


1.3
log
@bugzilla 111210 gmf-head sshaw 051012 Running out of SWT handles / Excessive GDI handles
@
text
@d20 5
a30 6
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
import org.eclipse.gmf.runtime.draw2d.ui.render.RenderInfo;
import org.eclipse.gmf.runtime.draw2d.ui.render.RenderedImage;
import org.eclipse.gmf.runtime.draw2d.ui.render.factory.RenderedImageFactory;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.DrawableRenderedImage;

a47 3
    /** Default meta image size */
    private final int META_EXTENT = MapMode.DPtoLP(32);

d164 2
a165 1
			preferredSize =  new Dimension(META_EXTENT,META_EXTENT);
d174 2
a175 2
						preferredSize.width = MapMode.DPtoLP(imgRect.width);
						preferredSize.height = MapMode.DPtoLP(imgRect.height);
a215 1
				// TODO get the antialias property from the preferences.
d255 1
a255 1
		   area = (Rectangle)MapMode.translateToDP(area);
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d258 2
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.		               |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

