head	1.13;
access;
symbols
	v20081020-0700:1.13
	v20080722-1827:1.13
	R2_1_maintenance:1.13.0.2
	Root_R2_1_maintenance:1.13
	R2_1_0:1.13
	v20080507-2230:1.13
	v20080425-1959:1.12
	v20080331-1625:1.12
	v20080328-1605:1.11
	v20080222-1200:1.11
	v20070809-0000:1.11
	R2_0_maintenance:1.11.0.2
	R2_0:1.11
	R4_20:1.11
	RC3_20:1.11
	v20070614-1400:1.11
	v20070608-1300:1.11
	v20070605-1400:1.10
	v20070601-1400:1.10
	v20070330-1300:1.10
	v20070208-1800:1.10
	M4_20:1.10
	v20061218-1500:1.9.2.1
	v20061214-0000:1.10
	M3_20:1.10
	v20061013-1330:1.10
	v20060919-0800:1.9.2.1
	M1_20:1.9
	v20060721-1130:1.9
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060616-1200:1.9
	v20060609-1400:1.9
	v20060531-1730:1.9
	v20060526-1200:1.9
	I20060505-1400:1.8
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.8
	I20060331-1000:1.8
	I20060324-0300:1.8
	I20060317-1300:1.8
	I20060317-1200:1.8
	I20060316-1300:1.8
	I20060309-1300:1.8
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.8
	I20060216-1945:1.8
	I20060210-1715:1.8
	I20060209-1815:1.7
	I20060203-0830:1.7
	I20060129-1145:1.7
	I20060127-0900:1.7
	I20060120-1530:1.7
	I20060113-1700:1.7
	M4_10:1.7
	I20060107-1100:1.7
	I20060105-1630:1.7
	I20051230-1230:1.7
	I20051223-1100:1.7
	I20051217-0925:1.6
	I20051208-2000:1.6
	I20051201-1800:1.5
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.13
date	2008.05.07.18.07.28;	author aboyko;	state Exp;
branches;
next	1.12;
commitid	78364821efdf4567;

1.12
date	2008.03.31.15.07.52;	author ahunter;	state Exp;
branches;
next	1.11;
commitid	4c8047f0fe474567;

1.11
date	2007.06.06.13.50.22;	author crevells;	state Exp;
branches;
next	1.10;
commitid	1dfb4666bb9e4567;

1.10
date	2006.10.03.15.05.23;	author ahunter;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.23.14.39.51;	author sshaw;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2006.02.10.19.18.31;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.22.22.05.57;	author cmahoney;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.05.19.18.18;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.29.16.33.56;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.11.16.34.54;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.08.15.40.40;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.24.39;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.53;	author sshaw;	state Exp;
branches;
next	;

1.9.2.1
date	2006.09.13.16.44.44;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.13
log
@[229256] gmf_head aboyko 080507 GMF can't render SVG's with xlinked or embedded images.
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.render.factory;

import java.io.FileInputStream;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.zip.Adler32;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.Platform;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.draw2d.ui.render.RenderInfo;
import org.eclipse.gmf.runtime.draw2d.ui.render.RenderedImage;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.AbstractRenderedImage;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.Draw2dRenderDebugOptions;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.Draw2dRenderPlugin;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.factory.RenderedImageKey;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.image.ImageRenderedImage;
import org.eclipse.swt.graphics.RGB;

/**
 * @@author sshaw
 * 
 * Factory class for generating RenderedImage objects
 */
public class RenderedImageFactory {

    static private Map instanceMap = new WeakHashMap();

    /**
     * createInfo static Utility to create a RenderInfo object.
     * 
     * @@param width
     *            the width of the rendered image to set
     * @@param height
     *            the height of the rendered image to set
     * @@param maintainAspectRatio
     *            <code>boolean</code> <code>true</code> if aspect ratio of
     *            original vector file is maintained, <code>false</code>
     *            otherwise
     * @@param antialias
     *            <code>boolean</code> <code>true</code> if the image is to
     *            be rendered using anti-aliasing (removing "jaggies" producing
     *            smoother lines), <code>false</code> otherwise
     * @@param fill
     *            the <code>RGB</code> of the fill that could instrumented
     *            into image formats that support dynamic color replacement.
     *            Typically, this would replace colors in the image which are
     *            "white" i.e. RGB(255,255,255)
     * @@param outline
     *            the <code>RGB</code> of the outline that could
     *            instrumented into image formats that support dynamic color
     *            replacement. Typically, this would replace colors in the image
     *            which are "black" i.e. RGB(0,0,0)
     * @@return <code>RenderInfo</code> object that contains information about
     *         the rendered image.
     */
    static public RenderInfo createInfo(int width, int height, boolean maintainAspectRatio, boolean antialias,
            RGB fill, RGB outline ) {
        RenderedImageKey svgInfo = new RenderedImageKey();
        svgInfo.setValues(width, height, maintainAspectRatio,
            antialias, fill, outline);
        return svgInfo;
    }
    
    /**
     * getInstance static constructor method for retrieving the appropriate
     * instance of the immutable class <code>RenderedImage</code>. This
     * method is used to read svg images from JARs.
     * 
     * @@param theURL
     *            URL of the SVG image. Normally in a JAR
     * @@return <code>RenderedImage</code> instance with the size dimensions
     *         requested.
     */
    static public RenderedImage getInstance(URL theURL) {
        return getInstance(theURL, new RenderedImageKey());
    }

    /**
     * getInstance static constructor method for retrieving the appropriate
     * instance of the immutable class <code>RenderedImage</code>. This
     * method is used to read svg images from JARs.
     * 
     * @@param theURL
     *            URL of the SVG image.
     * @@param info
     *            object containing information about the size and general data
     *            regarding how the image will be rendered.
     * 
     * @@return <code>RenderedImage</code> instance with the size dimensions
     *         requested.
     */
    static public RenderedImage getInstance(URL theURL, RenderInfo info) {

        try {
            InputStream is = theURL.openStream();

            int size = is.available();
            byte[] buffer = new byte[size];

            is.read(buffer);
            is.close();

            return getInstance(buffer, info, theURL.toString());

        } catch (Exception e) {
            Trace.throwing(Draw2dRenderPlugin.getInstance(),
                Draw2dRenderDebugOptions.EXCEPTIONS_THROWING,
                RenderedImage.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
                e);
        }

        return null;
    }
    
    /**
     * getInstance static constructor method for retrieving the appropriate
     * instance of the immutable class <code>RenderedImage</code>.
     * 
     * @@param buffer
     *            byte[] array containing an cached SVG image file.
     * @@param info
     *            object containing information about the size and general data
     *            regarding how the image will be rendered.
     * @@param url the url of the image (filename url - should be there for SVG, since it may have external references)
     * @@return <code>RenderedImage</code> instance with the size dimensions
     *         requested.
     * @@since 2.1
     */
    public static RenderedImage getInstance(byte [] buffer, RenderInfo info, String url) {
        Adler32 checksum = new Adler32();
        checksum.update(buffer);
        final RenderedImageKey key = new RenderedImageKey(info, checksum.getValue(), null, url);
        WeakReference ref = (WeakReference) instanceMap.get(key);
        RenderedImage image = null;
        if (ref != null)
            image = (RenderedImage) (((WeakReference) instanceMap.get(key))
                .get());
        else
            image = autodetectImage(buffer, key);

		// Bugzilla 208374
		if (image == null) {
			// Remove entry holding null reference.
			instanceMap.remove(key);
			// Recreate entry using buffer.
			image = getInstance(buffer);
		}

        return image;
    	
    }

    /**
     * getInstance static constructor method for retrieving the appropriate
     * instance of the immutable class <code>RenderedImage</code>.
     * 
     * @@param szFilePath
     *            <code>String</code> file path of svg file
     * @@return <code>RenderedImage</code> instance with the size dimensions
     *         requested.
     */
    static public RenderedImage getInstance(String szFilePath) {
        return getInstance(szFilePath, new RenderedImageKey());
    }

    /**
     * getInstance static constructor method for retrieving the appropriate
     * instance of the immutable class <code>RenderedImage</code>.
     * 
     * @@param szFilePath
     *            <code>String</code> file path of svg file
     * @@param info
     *            <code>RenderInfo</code> object containing information about
     *            the size and general data regarding how the image will be
     *            rendered.
     * @@return <code>RenderedImage</code> instance with the size dimensions
     *         requested.
     */
    static public RenderedImage getInstance(String szFilePath, RenderInfo info) {
        try {
            FileInputStream fis = new FileInputStream(szFilePath);
            int size = fis.available();
            byte[] buffer = new byte[size];

            fis.read(buffer);
            fis.close();

            return getInstance(buffer, info, szFilePath);

        } catch (Exception e) {
            Trace.throwing(Draw2dRenderPlugin.getInstance(),
                Draw2dRenderDebugOptions.EXCEPTIONS_THROWING,
                RenderedImageFactory.class,
                "RenderedImageFactory.getInstance()", //$NON-NLS-1$
                e);
        }

        return null;
    }

    /**
     * getInstance static constructor method for retrieving the appropriate
     * instance of the immutable class <code>RenderedImage</code>.
     * 
     * @@param buffer
     *            <code>byte[]</code> array containing an cached SVG image
     *            file.
     * @@return the <code>RenderedImage</code> that encapsulates the contents
     *         of the given byte buffer.
     */
    static public RenderedImage getInstance(byte[] buffer) {
        return getInstance(buffer, new RenderedImageKey());
    }

    /**
     * Returns a related instance of the given <code>RenderedImage</code> that
     * is based on the same byte stream or file info but instrumented for the
     * passed in <code>RenderInfo</code> object
     * 
     * @@param image
     *            <code>RenderedImage</code> that is used as a base to
     *            retrieve the related instance.
     * @@param info
     *            <code>RenderInfo</code> object containing information about
     *            the size and general data regarding how the image will be
     *            rendered.
     * @@return <code>RenderedImage</code> instance with the size dimensions
     *         requested. May return <code>null</code> if no related instance
     *         can be found or if the original buffer cannot be retrieved.
     */
    static public RenderedImage getRelatedInstance(RenderedImage image,
            RenderInfo info) {
        if (image instanceof AbstractRenderedImage) {
            RenderedImageKey oldKey = ((AbstractRenderedImage) image).getKey();
            
            Object extraData = oldKey.getExtraData();
            if (info.getBackgroundColor() != null
                && !info.getBackgroundColor().equals(
                    oldKey.getBackgroundColor())) {
                extraData = null;
            } else if (info.getForegroundColor() != null
                && !info.getForegroundColor().equals(
                    oldKey.getForegroundColor())) {
                extraData = null;
            }
            
            RenderedImageKey key = new RenderedImageKey(info, oldKey.getChecksum(), extraData);
            WeakReference ref = (WeakReference) instanceMap.get(key);
            if (ref != null) {
                return (RenderedImage) ref.get();
            } else {
                return autodetectImage(((AbstractRenderedImage) image)
                    .getBuffer(), key);
            }
        }

        return null;
    }

    /**
     * getInstance static constructor method for retrieving the appropriate
     * instance of the immutable class <code>RenderedImage</code>.
     * 
     * @@param buffer
     *            byte[] array containing an cached SVG image file.
     * @@param info
     *            object containing information about the size and general data
     *            regarding how the image will be rendered.
     * @@return <code>RenderedImage</code> instance with the size dimensions
     *         requested.
     */
    static public RenderedImage getInstance(byte[] buffer, RenderInfo info) {
        if (buffer == null)
            throw new InvalidParameterException();

        Adler32 checksum = new Adler32();
        checksum.update(buffer);
        final RenderedImageKey key = new RenderedImageKey(info, checksum.getValue(), null);
        WeakReference ref = (WeakReference) instanceMap.get(key);
        RenderedImage image = null;
        if (ref != null)
            image = (RenderedImage) (((WeakReference) instanceMap.get(key))
                .get());
        else
            image = autodetectImage(buffer, key);

		// Bugzilla 208374
		if (image == null) {
			// Remove entry holding null reference.
			instanceMap.remove(key);
			// Recreate entry using buffer.
			image = getInstance(buffer);
		}

        return image;
    }

    private static final String E_MODIFIER_FACTORY = "factory"; //$NON-NLS-1$
    private static final String A_CLASS = "class"; //$NON-NLS-1$

    static private List imageTypes = null;
    
    static private RenderedImage autodetectImage(byte[] buffer,
            final RenderedImageKey key) {
        
        if (imageTypes == null) {
            imageTypes = new ArrayList();
            
            IExtensionPoint riExtensionPt = Platform.getExtensionRegistry().getExtensionPoint("org.eclipse.gmf.runtime.draw2d.ui.render", //$NON-NLS-1$
                                                            "renderedImageFactory");  //$NON-NLS-1$
            IConfigurationElement[] configEls = riExtensionPt.getConfigurationElements();
            for (int i = 0; i < configEls.length; i++) {
                IConfigurationElement element = configEls[i];
    
                if (element.getName().equals(E_MODIFIER_FACTORY)) {
                    RenderedImageType imageType = null;
                    try {
                        imageType = (RenderedImageType)element.createExecutableExtension(A_CLASS);
                        if (imageType != null)
                            imageTypes.add(imageType);
                    } catch (CoreException e) {
                        continue;
                    }
                }
            }
        }
        
        RenderedImage image = null;
        ListIterator li = imageTypes.listIterator();
        while (li.hasNext()) {
            RenderedImageType imageType = (RenderedImageType)li.next();
            image = imageType.autoDetect(buffer, key);
            if (image != null)
                break;
        }

        if (image == null) {
            // can't create a RenderedImageType for image files until bugzilla 116227 is resolved.  Until then,
            // assume, the fall through type is ImageRenderedImage.
            image = new ImageRenderedImage(buffer, key);
        }
        
        if (image != null) {
            instanceMap.put(key, new WeakReference(image));
        }
        
        return image;
    }
}
@


1.12
log
@[208374] gmf-head ahunter 080331 [ImageSupport] NullPointerException thrown in ScalableImageFigure#getRenderedImage
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2007 IBM Corporation and others.
d124 1
a124 1
            return getInstance(buffer, info);
d135 38
d209 1
a209 1
            return getInstance(buffer, info);
@


1.11
log
@[190546] gmf_head crevells 070606 Fill & line colors change on SVG images sporadically  when one image has fill/line color set
@
text
@d270 8
@


1.10
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
d47 1
a47 1
	static private Map instanceMap = new WeakHashMap();
d49 275
a323 263
	/**
	 * createInfo static Utility to create a RenderInfo object.
	 * 
	 * @@param width
	 *            the width of the rendered image to set
	 * @@param height
	 *            the height of the rendered image to set
	 * @@param maintainAspectRatio
	 *            <code>boolean</code> <code>true</code> if aspect ratio of
	 *            original vector file is maintained, <code>false</code>
	 *            otherwise
	 * @@param antialias
	 *            <code>boolean</code> <code>true</code> if the image is to
	 *            be rendered using anti-aliasing (removing "jaggies" producing
	 *            smoother lines), <code>false</code> otherwise
	 * @@param fill
	 *            the <code>RGB</code> of the fill that could instrumented
	 *            into image formats that support dynamic color replacement.
	 *            Typically, this would replace colors in the image which are
	 *            "white" i.e. RGB(255,255,255)
	 * @@param outline
	 *            the <code>RGB</code> of the outline that could
	 *            instrumented into image formats that support dynamic color
	 *            replacement. Typically, this would replace colors in the image
	 *            which are "black" i.e. RGB(0,0,0)
	 * @@return <code>RenderInfo</code> object that contains information about
	 *         the rendered image.
	 */
	static public RenderInfo createInfo(int width, int height, boolean maintainAspectRatio, boolean antialias,
			RGB fill, RGB outline ) {
		RenderedImageKey svgInfo = new RenderedImageKey();
		svgInfo.setValues(width, height, maintainAspectRatio,
			antialias, fill, outline);
		return svgInfo;
	}
	
	/**
	 * getInstance static constructor method for retrieving the appropriate
	 * instance of the immutable class <code>RenderedImage</code>. This
	 * method is used to read svg images from JARs.
	 * 
	 * @@param theURL
	 *            URL of the SVG image. Normally in a JAR
	 * @@return <code>RenderedImage</code> instance with the size dimensions
	 *         requested.
	 */
	static public RenderedImage getInstance(URL theURL) {
		return getInstance(theURL, new RenderedImageKey());
	}

	/**
	 * getInstance static constructor method for retrieving the appropriate
	 * instance of the immutable class <code>RenderedImage</code>. This
	 * method is used to read svg images from JARs.
	 * 
	 * @@param theURL
	 *            URL of the SVG image.
	 * @@param info
	 *            object containing information about the size and general data
	 *            regarding how the image will be rendered.
	 * 
	 * @@return <code>RenderedImage</code> instance with the size dimensions
	 *         requested.
	 */
	static public RenderedImage getInstance(URL theURL, RenderInfo info) {

		try {
			InputStream is = theURL.openStream();

			int size = is.available();
			byte[] buffer = new byte[size];

			is.read(buffer);
			is.close();

			return getInstance(buffer, info);

		} catch (Exception e) {
			Trace.throwing(Draw2dRenderPlugin.getInstance(),
				Draw2dRenderDebugOptions.EXCEPTIONS_THROWING,
				RenderedImage.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
				e);
		}

		return null;
	}

	/**
	 * getInstance static constructor method for retrieving the appropriate
	 * instance of the immutable class <code>RenderedImage</code>.
	 * 
	 * @@param szFilePath
	 *            <code>String</code> file path of svg file
	 * @@return <code>RenderedImage</code> instance with the size dimensions
	 *         requested.
	 */
	static public RenderedImage getInstance(String szFilePath) {
		return getInstance(szFilePath, new RenderedImageKey());
	}

	/**
	 * getInstance static constructor method for retrieving the appropriate
	 * instance of the immutable class <code>RenderedImage</code>.
	 * 
	 * @@param szFilePath
	 *            <code>String</code> file path of svg file
	 * @@param info
	 *            <code>RenderInfo</code> object containing information about
	 *            the size and general data regarding how the image will be
	 *            rendered.
	 * @@return <code>RenderedImage</code> instance with the size dimensions
	 *         requested.
	 */
	static public RenderedImage getInstance(String szFilePath, RenderInfo info) {
		try {
			FileInputStream fis = new FileInputStream(szFilePath);
			int size = fis.available();
			byte[] buffer = new byte[size];

			fis.read(buffer);
			fis.close();

			return getInstance(buffer, info);

		} catch (Exception e) {
			Trace.throwing(Draw2dRenderPlugin.getInstance(),
				Draw2dRenderDebugOptions.EXCEPTIONS_THROWING,
				RenderedImageFactory.class,
				"RenderedImageFactory.getInstance()", //$NON-NLS-1$
				e);
		}

		return null;
	}

	/**
	 * getInstance static constructor method for retrieving the appropriate
	 * instance of the immutable class <code>RenderedImage</code>.
	 * 
	 * @@param buffer
	 *            <code>byte[]</code> array containing an cached SVG image
	 *            file.
	 * @@return the <code>RenderedImage</code> that encapsulates the contents
	 *         of the given byte buffer.
	 */
	static public RenderedImage getInstance(byte[] buffer) {
		return getInstance(buffer, new RenderedImageKey());
	}

	/**
	 * Returns a related instance of the given <code>RenderedImage</code> that
	 * is based on the same byte stream or file info but instrumented for the
	 * passed in <code>RenderInfo</code> object
	 * 
	 * @@param image
	 *            <code>RenderedImage</code> that is used as a base to
	 *            retrieve the related instance.
	 * @@param info
	 *            <code>RenderInfo</code> object containing information about
	 *            the size and general data regarding how the image will be
	 *            rendered.
	 * @@return <code>RenderedImage</code> instance with the size dimensions
	 *         requested. May return <code>null</code> if no related instance
	 *         can be found or if the original buffer cannot be retrieved.
	 */
	static public RenderedImage getRelatedInstance(RenderedImage image,
			RenderInfo info) {
		if (image instanceof AbstractRenderedImage) {
			RenderedImageKey oldKey = ((AbstractRenderedImage) image).getKey();
			RenderedImageKey key = new RenderedImageKey(info, oldKey.getChecksum(), oldKey.getExtraData());
			WeakReference ref = (WeakReference) instanceMap.get(key);
			if (ref != null) {
				return (RenderedImage) ref.get();
			} else {
				return autodetectImage(((AbstractRenderedImage) image)
					.getBuffer(), key);
			}
		}

		return null;
	}

	/**
	 * getInstance static constructor method for retrieving the appropriate
	 * instance of the immutable class <code>RenderedImage</code>.
	 * 
	 * @@param buffer
	 *            byte[] array containing an cached SVG image file.
	 * @@param info
	 *            object containing information about the size and general data
	 *            regarding how the image will be rendered.
	 * @@return <code>RenderedImage</code> instance with the size dimensions
	 *         requested.
	 */
	static public RenderedImage getInstance(byte[] buffer, RenderInfo info) {
		if (buffer == null)
			throw new InvalidParameterException();

		Adler32 checksum = new Adler32();
		checksum.update(buffer);
		final RenderedImageKey key = new RenderedImageKey(info, checksum.getValue(), null);
		WeakReference ref = (WeakReference) instanceMap.get(key);
		RenderedImage image = null;
		if (ref != null)
			image = (RenderedImage) (((WeakReference) instanceMap.get(key))
				.get());
		else
			image = autodetectImage(buffer, key);

		return image;
	}

	private static final String E_MODIFIER_FACTORY = "factory"; //$NON-NLS-1$
	private static final String A_CLASS = "class"; //$NON-NLS-1$

	static private List imageTypes = null;
	
	static private RenderedImage autodetectImage(byte[] buffer,
			final RenderedImageKey key) {
		
		if (imageTypes == null) {
			imageTypes = new ArrayList();
			
			IExtensionPoint riExtensionPt = Platform.getExtensionRegistry().getExtensionPoint("org.eclipse.gmf.runtime.draw2d.ui.render", //$NON-NLS-1$
															"renderedImageFactory");  //$NON-NLS-1$
			IConfigurationElement[] configEls = riExtensionPt.getConfigurationElements();
			for (int i = 0; i < configEls.length; i++) {
				IConfigurationElement element = configEls[i];
	
				if (element.getName().equals(E_MODIFIER_FACTORY)) {
					RenderedImageType imageType = null;
					try {
						imageType = (RenderedImageType)element.createExecutableExtension(A_CLASS);
						if (imageType != null)
							imageTypes.add(imageType);
					} catch (CoreException e) {
						continue;
					}
				}
			}
		}
		
		RenderedImage image = null;
		ListIterator li = imageTypes.listIterator();
		while (li.hasNext()) {
			RenderedImageType imageType = (RenderedImageType)li.next();
			image = imageType.autoDetect(buffer, key);
			if (image != null)
				break;
		}

		if (image == null) {
			// can't create a RenderedImageType for image files until bugzilla 116227 is resolved.  Until then,
			// assume, the fall through type is ImageRenderedImage.
			image = new ImageRenderedImage(buffer, key);
		}
		
		if (image != null) {
			instanceMap.put(key, new WeakReference(image));
		}
		
		return image;
	}
@


1.9
log
@bugzilla 143007 gmf-head sshaw 060523 RenderedImageFactory references unpopulated WeakHashMap
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
@


1.9.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@


1.8
log
@bugzilla 119319 gmf-head sshaw 060210 Support extensibility for RenderedImageFactory
@
text
@d297 1
a297 1
				return image;
d300 11
a310 3
		// can't create a RenderedImageType for image files until bugzilla 116227 is resolved.  Until then,
		// assume, the fall through type is ImageRenderedImage.
		return new ImageRenderedImage(buffer, key);
@


1.7
log
@Bugzilla 115382 gmf_head tmacdoug 051222 - Autosensing for SVG fails for XML files that aren't SVG
@
text
@a13 3
import java.awt.Color;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
a14 1
import java.io.IOException;
d19 3
d26 4
a29 4
import org.apache.batik.dom.svg.SAXSVGDocumentFactory;
import org.apache.batik.util.XMLResourceDescriptor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.gmf.runtime.common.core.util.Log;
a37 3
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.svg.SVGImage;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.svg.metafile.EMFTranscoder;
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.svg.metafile.WMFTranscoder;
a55 38
	 * @@param fill
	 *            the <code>Color</code> of the fill that could instrumented
	 *            into image formats that support dynamic color replacement.
	 *            Typically, this would replace colors in the image which are
	 *            "white" i.e. RGB(255,255,255)
	 * @@param outline
	 *            the <code>Color</code> of the outline that could
	 *            instrumented into image formats that support dynamic color
	 *            replacement. Typically, this would replace colors in the image
	 *            which are "black" i.e. RGB(0,0,0)
	 * @@param maintainAspectRatio
	 *            <code>boolean</code> <code>true</code> if aspect ratio of
	 *            original vector file is maintained, <code>false</code>
	 *            otherwise
	 * @@param antialias
	 *            <code>boolean</code> <code>true</code> if the image is to
	 *            be rendered using anti-aliasing (removing "jaggies" producing
	 *            smoother lines), <code>false</code> otherwise
	 * @@return <code>RenderInfo</code> object that contains information about
	 *         the rendered image.
	 * @@deprecated use
	 *             {@@link RenderedImageFactory#createInfo(int, int, RGB, RGB, boolean, boolean)}
	 */
	static public RenderInfo createInfo(int width, int height, Color fill,
			Color outline, boolean maintainAspectRatio, boolean antialias) {
		RenderedImageKey svgInfo = new RenderedImageKey();
		svgInfo.setValues(width, height, fill, outline, maintainAspectRatio,
			antialias);
		return svgInfo;
	}

	/**
	 * createInfo static Utility to create a RenderInfo object.
	 * 
	 * @@param width
	 *            the width of the rendered image to set
	 * @@param height
	 *            the height of the rendered image to set
d261 6
a266 1
	private static RenderedImage autodetectImage(byte[] buffer,
d268 19
a286 22
		RenderedImage image = null;

		if (isSVG(buffer))
			image = new SVGImage(buffer, key);
		else {
			// not a recognizable image format so assume it's an EMF file
			try {
				WMFTranscoder imageTransformer = new WMFTranscoder();
				ByteArrayInputStream input = new ByteArrayInputStream(buffer);
				ByteArrayOutputStream output = new ByteArrayOutputStream();
				imageTransformer.transcode(input, output);
				image = new SVGImage(output.toByteArray(), key);
			} catch (Exception e2) {
				try {
					EMFTranscoder imageTransformer = new EMFTranscoder();
					ByteArrayInputStream input = new ByteArrayInputStream(
						buffer);
					ByteArrayOutputStream output = new ByteArrayOutputStream();
					imageTransformer.transcode(input, output);
					image = new SVGImage(output.toByteArray(), key);
				} catch (Exception e3) {
					image = new ImageRenderedImage(buffer, key);
d290 8
a297 3

		if (image != null) {
			instanceMap.put(key, new WeakReference(image));
d300 3
a302 15
		return image;
	}

	private static boolean isSVG(byte[] buffer) {
		ByteArrayInputStream bIS = new ByteArrayInputStream(buffer);
		String parserName = XMLResourceDescriptor.getXMLParserClassName();
		SAXSVGDocumentFactory svgFactory = new SAXSVGDocumentFactory(parserName);
		
		try {
			svgFactory.createDocument(null,bIS);
			return true;
		} catch (IOException e) {
			Log.error(Draw2dRenderPlugin.getInstance(), IStatus.ERROR, e.getMessage(), e);
		}
		return false;
@


1.6
log
@bugzilla 111436 gmf-head sshaw 051205 Improve performance of SVG transcoder
@
text
@d18 1
d27 4
a337 12
	private static String getTestString(byte[] buffer) {
		if (buffer == null)
			return null;

		StringBuffer szTestBuf = new StringBuffer(10 + 1);
		for (int i = 0; i < 10; i++)
			szTestBuf.insert(i, (char) buffer[i]);
		String szTest = new String(szTestBuf);
		szTest = szTest.trim();
		return szTest;
	}

d339 11
a349 2
		String szTest = getTestString(buffer);
		return szTest.startsWith("<?xml"); //$NON-NLS-1$
@


1.5
log
@bugzilla 111436 gmf-head sshaw 051128 Improve performance of SVG transcoder
@
text
@a31 1
import org.eclipse.gmf.runtime.draw2d.ui.render.internal.factory.RenderInfoImpl;
d37 1
a37 1

d45 1
d47 1
a47 1
 
d75 2
d78 4
a81 14
	static public RenderInfo createInfo(
		int width,
		int height,
		Color fill,
		Color outline,
		boolean maintainAspectRatio,
		boolean antialias) {
		RenderInfoImpl svgInfo = new RenderInfoImpl();
		svgInfo.setValues(
			width,
			height,
			fill,
			outline,
			maintainAspectRatio,
d87 36
d133 1
a133 1
		return getInstance(theURL, new RenderInfoImpl());
d157 1
a157 1
			
d164 4
a167 2
			Trace.throwing(Draw2dRenderPlugin.getInstance(), Draw2dRenderDebugOptions.EXCEPTIONS_THROWING, RenderedImage.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
			e);
d183 1
a183 1
		return getInstance(szFilePath, new RenderInfoImpl());
d204 1
a204 1
			
d211 5
a215 2
			Trace.throwing(Draw2dRenderPlugin.getInstance(), Draw2dRenderDebugOptions.EXCEPTIONS_THROWING, RenderedImageFactory.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
			e);
d232 1
a232 1
		return getInstance(buffer, new RenderInfoImpl());
d244 3
a246 2
	 *            <code>RenderInfo</code> object containing information about the size 
	 *            and general data regarding how the image will be rendered.
d248 1
a248 1
	 *         requested.  May return <code>null</code> if no related instance
d251 2
a252 1
	static public RenderedImage getRelatedInstance(RenderedImage image, RenderInfo info) {
d254 3
a256 3
			RenderedImageKey oldKey = ((AbstractRenderedImage)image).getKey();
			RenderedImageKey key = new RenderedImageKey(oldKey.getChecksum(), info, oldKey.getExtraData());
			WeakReference ref = (WeakReference)instanceMap.get(key);
d258 4
a261 4
				return (RenderedImage)ref.get();
			}
			else {
				return autodetectImage(((AbstractRenderedImage)image).getBuffer(), key);
d264 1
a264 1
		
d267 1
a267 1
	
d283 1
a283 1
	
d286 2
a287 2
		final RenderedImageKey key = new RenderedImageKey(checksum.getValue(), info, null);
		WeakReference ref = (WeakReference)instanceMap.get(key);
d290 2
a291 1
			image = (RenderedImage)(((WeakReference) instanceMap.get(key)).get());
d294 1
a294 1
	
d298 2
a299 1
	private static RenderedImage autodetectImage(byte[] buffer, final RenderedImageKey key) {
d301 1
a301 1
		
d306 18
a323 17
		    try {
		   	   	WMFTranscoder imageTransformer = new WMFTranscoder();
	    	   	ByteArrayInputStream input = new ByteArrayInputStream(buffer);
		   	   	ByteArrayOutputStream output = new ByteArrayOutputStream();
		   	   	imageTransformer.transcode(input, output);
		   	   	image = new SVGImage(output.toByteArray(), key);
		   	} catch (Exception e2) {
		   		try {
		   			EMFTranscoder imageTransformer = new EMFTranscoder();
	        	   	ByteArrayInputStream input = new ByteArrayInputStream(buffer);
		   	       	ByteArrayOutputStream output = new ByteArrayOutputStream();
		   	       	imageTransformer.transcode(input, output);
		   	       	image = new SVGImage(output.toByteArray(), key);
		   	    } catch (Exception e3) {
		   	    	image = new ImageRenderedImage(buffer, key);
		   	    }
		    }
d325 1
a325 1
			 
d329 1
a329 1
	
d332 1
a332 1
	
d336 4
a339 4
		
		StringBuffer szTestBuf = new StringBuffer(10+1);
		for (int i=0; i<10; i++)
			szTestBuf.insert(i, (char)buffer[i]);
d344 1
a344 1
	
@


1.4
log
@Rollback of fixes for:

Bugzilla 115382 gmf_head tmacdoug 051108 - SVG test is not complete
Bugzilla 115489 gmf_head tmacdoug 051108 - URLImageEditPartTests JUnits need to run as part of the diagram ui AllTests

due to JUnit failures.
@
text
@d29 1
d42 1
a42 1
 *
d55 10
a64 6
	 * @@param fill the <code>Color</code> of the fill that could instrumented into image formats that
	 * support dynamic color replacement.  Typically, this would replace colors in the image which are "white"
	 * i.e. RGB(255,255,255)
	 * @@param outline the <code>Color</code> of the outline that could instrumented into image formats that
	 * support dynamic color replacement.  Typically, this would replace colors in the image which are "black"
	 * i.e. RGB(0,0,0)
d66 3
a68 2
	 *            <code>boolean</code> <code>true</code> if aspect ratio of original vector file is
	 *            maintained, <code>false</code> otherwise
d70 5
a74 4
	 * 			  <code>boolean</code> <code>true</code> if the image is to be rendered using anti-aliasing
	 * 			 (removing "jaggies" producing smoother lines), <code>false</code> otherwise
	 * @@return <code>RenderInfo</code> object that contains information about the rendered
	 *         image.
d96 2
a97 2
	 * instance of the immutable class <code>RenderedImage</code>. This method is used to read
	 * svg images from JARs.
d101 2
a102 1
	 * @@return <code>RenderedImage</code> instance with the size dimensions requested.
d110 2
a111 2
	 * instance of the immutable class <code>RenderedImage</code>. This method is used to read
	 * svg images from JARs.
d119 2
a120 1
	 * @@return <code>RenderedImage</code> instance with the size dimensions requested.
d149 2
a150 1
	 * @@return <code>RenderedImage</code> instance with the size dimensions requested.
d163 5
a167 3
	 * 			  <code>RenderInfo</code> object containing information about the size and general data
	 *            regarding how the image will be rendered.
	 * @@return <code>RenderedImage</code> instance with the size dimensions requested.
d193 4
a196 2
	 *            <code>byte[]</code> array containing an cached SVG image file.
	 * @@return the <code>RenderedImage</code> that encapsulates the contents of the given byte buffer.
d203 31
d242 2
a243 1
	 * @@return <code>RenderedImage</code> instance with the size dimensions requested.
d251 1
a251 1
		final RenderedImageKey key = new RenderedImageKey(checksum.getValue(), info);
d256 8
d265 22
a286 23
		if (image == null) {
			if (isSVG(buffer))
				image = new SVGImage(buffer, key);
			else {
				// not a recognizable image format so assume it's an EMF file
			    try {
		    	   	WMFTranscoder imageTransformer = new WMFTranscoder();
	    		   	ByteArrayInputStream input = new ByteArrayInputStream(buffer);
		    	   	ByteArrayOutputStream output = new ByteArrayOutputStream();
		    	   	imageTransformer.transcode(input, output);
		    	   	image = new SVGImage(output.toByteArray(), key);
		    	} catch (Exception e2) {
		    		try {
		    			EMFTranscoder imageTransformer = new EMFTranscoder();
	    	    	   	ByteArrayInputStream input = new ByteArrayInputStream(buffer);
		    	       	ByteArrayOutputStream output = new ByteArrayOutputStream();
		    	       	imageTransformer.transcode(input, output);
		    	       	image = new SVGImage(output.toByteArray(), key);
		    	    } catch (Exception e3) {
		    	    	image = new ImageRenderedImage(buffer, key);
		    	    }
			    }
			}
d288 2
a289 2
			if (image != null)
				instanceMap.put(key, new WeakReference(image));
@


1.3
log
@Bugzilla 115382 gmf_head tmacdoug 051108 - SVG test is not complete
@
text
@a17 1
import java.io.IOException;
a25 4
import org.apache.batik.dom.svg.SAXSVGDocumentFactory;
import org.apache.batik.util.XMLResourceDescriptor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.gmf.runtime.common.core.util.Log;
d242 3
a244 5

	private static boolean isSVG(byte[] buffer) {
		ByteArrayInputStream bIS = new ByteArrayInputStream(buffer);
		String parserName = XMLResourceDescriptor.getXMLParserClassName();
		SAXSVGDocumentFactory svgFactory = new SAXSVGDocumentFactory(parserName);
d246 6
a251 7
		try {
			svgFactory.createDocument(null,bIS); //$NON-NLS-1$
			return true;
		} catch (IOException e) {
			Log.error(Draw2dRenderPlugin.getInstance(), IStatus.ERROR, e.getMessage(), e);
		}
		return false;
a252 2

	
d254 4
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d18 1
d27 4
d247 5
a251 3
	private static String getTestString(byte[] buffer) {
		if (buffer == null)
			return null;
d253 7
a259 6
		StringBuffer szTestBuf = new StringBuffer(10+1);
		for (int i=0; i<10; i++)
			szTestBuf.insert(i, (char)buffer[i]);
		String szTest = new String(szTestBuf);
		szTest = szTest.trim();
		return szTest;
d261 2
a263 4
	private static boolean isSVG(byte[] buffer) {
		String szTest = getTestString(buffer);
		return szTest.startsWith("<?xml"); //$NON-NLS-1$
	}
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

