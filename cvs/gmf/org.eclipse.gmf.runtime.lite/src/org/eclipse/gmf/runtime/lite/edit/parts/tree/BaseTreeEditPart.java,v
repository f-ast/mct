head	1.8;
access;
symbols
	v20080722-1827:1.8
	R2_1_maintenance:1.8.0.4
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080425-1959:1.8
	v20071108-0000:1.8
	v20071003-0000:1.8
	v20070921-0000:1.8
	v20070903-0000:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	v20070621-0000:1.8
	RC3_20:1.8
	v20070601-1400:1.8
	v20070525-1500:1.8
	v20070518-1300:1.8
	v20070427-0600:1.6
	v20070420-1000:1.5
	v20070413-1300:1.5
	v20070405-1100:1.5
	v20070330-1300:1.4
	v20060330-1300:1.4
	v20070322-1100:1.4
	v20060316-0600:1.3
	v20070307-0700:1.2
	v20070228-2000:1.2
	v20070208-1800:1.2
	M4_20:1.1
	v20061222-1800:1.1
	v20061218-1200:1.1
	v20061214-0000:1.1
	v20061120-1300:1.1
	M3_20:1.1
	v20061117-0800:1.1
	v20061013-1330:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2007.05.11.11.39.02;	author bblajer;	state Exp;
branches;
next	1.7;
commitid	79b0464455d54567;

1.7
date	2007.05.04.14.08.42;	author bblajer;	state Exp;
branches;
next	1.6;
commitid	4647463b3e694567;

1.6
date	2007.04.24.14.16.45;	author bblajer;	state Exp;
branches;
next	1.5;
commitid	4252462e114b4567;

1.5
date	2007.04.04.11.04.45;	author bblajer;	state Exp;
branches;
next	1.4;
commitid	18c24613864c4567;

1.4
date	2007.03.16.18.54.19;	author bblajer;	state Exp;
branches;
next	1.3;
commitid	7fc945fae7db4567;

1.3
date	2007.03.15.16.43.32;	author bblajer;	state Exp;
branches;
next	1.2;
commitid	61a145f977b34567;

1.2
date	2007.01.11.19.16.09;	author bblajer;	state Exp;
branches;
next	1.1;
commitid	6b9e45a68cf74567;

1.1
date	2006.09.11.15.45.03;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Labels with undefined label displayer should not be editable;
Empty label text should always be replaced with default text;
Closing and reopening outline should not lead to "widget disposed" exceptions;
Delete outgoing links before deleting element.
Make it easier to set the default text to display in the outline
@
text
@/**
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bblajer - initial API and implementation
 */
package org.eclipse.gmf.runtime.lite.edit.parts.tree;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gef.editparts.AbstractTreeEditPart;
import org.eclipse.gef.tools.CellEditorLocator;
import org.eclipse.gmf.runtime.lite.edit.parts.labels.AbstractLabelTextDisplayer;
import org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelController;
import org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelTextDisplayer;
import org.eclipse.gmf.runtime.lite.edit.parts.labels.ItemProviderLabelTextDisplayer;
import org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart;
import org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart;
import org.eclipse.gmf.runtime.lite.edit.parts.update.RefreshAdapter;
import org.eclipse.gmf.runtime.lite.edit.parts.update.TransactionalUpdateManager;
import org.eclipse.gmf.runtime.lite.services.TreeDirectEditManager;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.jface.viewers.CellEditor;
import org.eclipse.jface.viewers.TextCellEditor;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.TreeItem;

/**
 * Base implementation for {@@link org.eclipse.gef.TreeEditPart} used by the generated editors. 
 */
public class BaseTreeEditPart extends AbstractTreeEditPart implements IUpdatableEditPart, IExternallyUpdatableEditPart, ILabelController {
	private Image myImage;
	private ImageDescriptor myImageDescriptor;

	private AdapterFactory myAdapterFactory;
	private ILabelTextDisplayer myLabelTextDisplayer;

	private RefreshAdapter myDomainModelRefresher = new RefreshAdapter(this);

	private TreeDirectEditManager directEditManager;

	public BaseTreeEditPart(View view, AdapterFactory adapterFactory) {
		setModel(view);
		myAdapterFactory = adapterFactory;
	}

	public View getNotationView() {
		return (View) getModel();
	}

	public EObject getElement() {
		return getNotationView().getElement();
	}

	@@Override
	public void activate() {
		super.activate();
		if (getElement() != null) {
			TransactionalUpdateManager updateManager = getTransactionalUpdateManager();
			if (updateManager == null) {
					getElement().eAdapters().add(myDomainModelRefresher);
			} else {
				updateManager.addUpdatableEditPart(getElement(), this);
			}
		}
	}

	@@Override
	public void deactivate() {
		TransactionalUpdateManager updateManager = getTransactionalUpdateManager();
		if (getElement() != null) {
			if (updateManager == null) {
				getElement().eAdapters().remove(myDomainModelRefresher);
			} else {
				updateManager.removeUpdatableEditPart(getElement(), this);
			}
		}
		super.deactivate();
	}

	protected TransactionalUpdateManager getTransactionalUpdateManager() {
		if (getParent() instanceof BaseTreeEditPart) {
			return ((BaseTreeEditPart) getParent()).getTransactionalUpdateManager();
		}
		return null;
	}

	@@SuppressWarnings("unchecked")
	protected List getModelChildren() {
		return getNotationView().getVisibleChildren();
	}

	protected Image getImage() {
		ImageDescriptor descriptor = getImageDescriptor();
		if (descriptor == null) {
			disposeImage();
			myImageDescriptor = null;
			return null;
		}
		if (myImageDescriptor != descriptor) {
			disposeImage();
			myImageDescriptor = descriptor;
			return createImage();
		}
		if (myImage == null || myImage.isDisposed()) {
			return createImage();
		}
		return myImage;
	}

	public final ILabelTextDisplayer getLabelTextDisplayer() {
		if (myLabelTextDisplayer == null) {
			myLabelTextDisplayer = createLabelTextDisplayer();
			if (myLabelTextDisplayer == null) {
				myLabelTextDisplayer = new NullLabelTextDisplayer();
			}
		}
		return myLabelTextDisplayer;
	}

	protected ILabelTextDisplayer createLabelTextDisplayer() {
		return new ItemProviderLabelTextDisplayer(myAdapterFactory);
	}

	public void setLabelText(String text) {
		if (text == null || text.length() == 0) {
			text = getDefaultLabelText();
		}
		setWidgetText(text);
	}

	/**
	 * @@return The text to use if an empty string would be displayed otherwise
	 */
	protected String getDefaultLabelText() {
		return "";	//$NON-NLS-1$
	}

	private Image createImage() {
		disposeImage();
		myImage = myImageDescriptor.createImage();
		return myImage;
	}

	private void disposeImage() {
		if (myImage != null && !myImage.isDisposed()) {
			myImage.dispose();
		}
		myImage = null;
	}

	/**
	 * Returns the image descriptor provided by the given adapter factory.
	 * Subclasses may override.
	 */
	protected ImageDescriptor getImageDescriptor() {
		if (getElement() == null) {
			return null;
		}
		IItemLabelProvider labelProvider = (IItemLabelProvider) myAdapterFactory.adapt(getElement(), IItemLabelProvider.class);
		if (labelProvider != null) {
			return ExtendedImageRegistry.getInstance().getImageDescriptor(labelProvider.getImage(getElement()));
		}
		return null;
	}

	/**
	 * Returns the text provided by the given adapter factory.
	 * Subclasses may override.
	 */
	protected String getText() {
		String result = getLabelTextDisplayer().getDisplayText(getElement());
		if (result == null || result.length() == 0) {
			return getDefaultLabelText();
		}
		return result;
	}

	private HashMap<EStructuralFeature, Refresher> structuralFeatures2Refresher;

	public Refresher getRefresher(EStructuralFeature feature, Notification msg) {
		if (structuralFeatures2Refresher == null) {
			createRefreshers();
		}
		return (Refresher) structuralFeatures2Refresher.get(feature);
	}

	protected void createRefreshers() {
		structuralFeatures2Refresher = new HashMap<EStructuralFeature, Refresher>();
		Refresher childrenRefresher = new Refresher() {
			public void refresh() {
				refreshChildren();
			}
		};
		registerRefresher(NotationPackage.eINSTANCE.getView_PersistedChildren(), childrenRefresher);
		registerRefresher(NotationPackage.eINSTANCE.getView_TransientChildren(), childrenRefresher);
		registerRefresher(NotationPackage.eINSTANCE.getView_Visible(), childrenRefresher);
		registerRefresher(NotationPackage.eINSTANCE.getView_Styles(), childrenRefresher);
		registerRefresher(NotationPackage.eINSTANCE.getDrawerStyle_Collapsed(), childrenRefresher);
		//Source edges are shown as children
		registerRefresher(NotationPackage.eINSTANCE.getView_SourceEdges(), childrenRefresher);
	}

	private Collection<ExternalRefresher> myExternalRefreshers;

	public Collection<ExternalRefresher> getExternalRefreshers() {
		if (myExternalRefreshers == null) {
			myExternalRefreshers = createExternalRefreshers();
		}
		return myExternalRefreshers;
	}

	protected Collection<ExternalRefresher> createExternalRefreshers() {
		return Collections.<ExternalRefresher>singleton(new ILabelController.ExternalRefresherAdapter(this, getElement()));
	}

	protected final void registerRefresher(EStructuralFeature feature, Refresher refresher) {
		Refresher oldRefresher = (Refresher) structuralFeatures2Refresher.get(feature);
		if (oldRefresher == null) {
			structuralFeatures2Refresher.put(feature, refresher);
		} else {
			CompositeRefresher compositeRefresher = new CompositeRefresher();
			compositeRefresher.addRefresher(oldRefresher);
			compositeRefresher.addRefresher(refresher);
			structuralFeatures2Refresher.put(feature, compositeRefresher);
		}
	}

	public void performRequest(org.eclipse.gef.Request req) {
		if (org.eclipse.gef.RequestConstants.REQ_DIRECT_EDIT == req.getType() && understandsRequest(req)) {
			performDirectEdit();
		} else {
			super.performRequest(req);
		}
	}

	protected TreeDirectEditManager getDirectEditManager() {
		if (directEditManager == null) {
			directEditManager = new TreeDirectEditManager(this, getCellEditorClass(), new CellEditorLocator() {
				public void relocate(CellEditor celleditor) {
					if (checkTreeItem()) {
						celleditor.getControl().setFont(((TreeItem) getWidget()).getFont());
						celleditor.getControl().setBounds(((TreeItem) getWidget()).getBounds());
					}
				}
			}) {
				protected void initCellEditor() {
					getCellEditor().setValue(getLabelTextDisplayer().getEditText(getElement()));
				}
			};
		}
		return directEditManager;
	}

	protected Class<? extends CellEditor> getCellEditorClass() {
		return TextCellEditor.class;
	}

	protected void performDirectEdit() {
		if (isReadOnly()) {
			return;
		}
		getDirectEditManager().show();
	}

	/**
	 * Returns whether the element is read only. This is used to determine if direct edit should be invoked or not.
	 */
	protected boolean isReadOnly() {
		if (getElement() == null) {
			return true;
		}
		Resource notationResource = getNotationView().eResource();
		TransactionalEditingDomain editingDomain = TransactionUtil.getEditingDomain(notationResource);
		if (editingDomain == null) {
			return false;
		}
		if (editingDomain.isReadOnly(notationResource)) {
			return true;
		}
		Resource domainResource = getElement().eResource();
		if (domainResource == null) {
			return false;
		}
		return editingDomain.isReadOnly(domainResource);
	}

	private class NullLabelTextDisplayer extends AbstractLabelTextDisplayer {
		private NullLabelTextDisplayer() {}

		public String getDisplayText(EObject source) {
			return getDefaultLabelText();
		}

		public boolean isAffectingEvent(Notification notification) {
			return false;
		}
	}
}
@


1.7
log
@1. Links to links;
2. Exception from TreeEditPartViewer (in the outline) while closing the diagram editor (because unregister is not called, only deactivate) fixed;
3. instead of rerouting a link to an end that does not support it, remove the link
@
text
@d30 2
a32 1
import org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelController;
d107 1
d133 3
d145 11
a155 1
		setWidgetText(text == null ? "" : text);	//$NON-NLS-1$
d192 4
a195 1
		return result == null ? "" : result;
d306 12
@


1.6
log
@CanonicalStyle is taken into account while refreshing notational model to reflect changes in underlying domain model;
Update is now centralized and transactional;
Changes to visibility are dispatched to the parent of the affected view as well (was: only to the view itself);
Save options are not reused, for easy modification of the generated code;
Side-affixed children are not considered direct children;
Empty edit-patterns are treated the same way as null patterns (view pattern is used instead).
@
text
@d99 5
a103 2
	protected final TransactionalUpdateManager getTransactionalUpdateManager() {
		return (TransactionalUpdateManager) getViewer().getProperty(TransactionalUpdateManager.class.getName());
@


1.5
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@d36 1
d77 6
a82 1
			getElement().eAdapters().add(myDomainModelRefresher);
d88 1
d90 5
a94 1
			getElement().eAdapters().remove(myDomainModelRefresher);
d99 4
@


1.4
log
@EObjects that are not attached to any resource should be treated as not read only
@
text
@d89 1
a89 1
		return getNotationView().getChildren();
@


1.3
log
@[164018] Command generation seperated from Parts for commands that operate with labels;
API to display label text, apply modifications and update after (external) modifications isolated from generated code;
Moved as much common generated code as possible to BaseTreeEditPart;
[165700] Support diagrams in read-only mode: all EMF commands that are not composed of standard EMF commands, but modify EMF models directly should query the editing domain for read-onliness of the resource they operate on.
@
text
@d259 1
a259 1
			return true;
d266 1
a266 1
			return true;
@


1.2
log
@[170248]: Beautify compartments generated for the lite version
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Eclipse.org
d14 2
d23 1
d26 2
d29 5
d35 2
d40 2
d43 1
d48 1
a48 1
public class BaseTreeEditPart extends AbstractTreeEditPart implements IUpdatableEditPart {
d53 5
d72 16
d110 15
d158 2
a159 8
		if (getElement() == null) {
			return "";
		}
		IItemLabelProvider labelProvider = (IItemLabelProvider) myAdapterFactory.adapt(getElement(), IItemLabelProvider.class);
		if (labelProvider != null) {
			return labelProvider.getText(getElement());
		}
		return "";
d162 1
a162 1
	private HashMap structuralFeatures2Refresher;
d172 1
a172 1
		structuralFeatures2Refresher = new HashMap();
d187 13
d211 59
@


1.1
log
@[156358] bblajer - Diagram overview with Lite runtime
@
text
@d136 2
@

