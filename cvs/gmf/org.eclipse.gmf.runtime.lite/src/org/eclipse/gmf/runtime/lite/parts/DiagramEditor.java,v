head	1.14;
access;
symbols
	v20080722-1827:1.14
	R2_1_maintenance:1.14.0.4
	Root_R2_1_maintenance:1.14
	R2_1_0:1.14
	v20080425-1959:1.14
	v20071108-0000:1.14
	v20071003-0000:1.14
	v20070921-0000:1.14
	v20070903-0000:1.14
	v20070809-0000:1.14
	R2_0_maintenance:1.14.0.2
	R2_0:1.14
	R4_20:1.14
	v20070621-0000:1.14
	RC3_20:1.13
	v20070601-1400:1.13
	v20070525-1500:1.13
	v20070518-1300:1.12
	v20070427-0600:1.12
	v20070420-1000:1.12
	v20070413-1300:1.12
	v20070405-1100:1.10
	v20070330-1300:1.10
	v20060330-1300:1.10
	v20070322-1100:1.10
	v20060316-0600:1.10
	v20070307-0700:1.10
	v20070228-2000:1.10
	v20070208-1800:1.10
	M4_20:1.10
	v20061222-1800:1.10
	v20061218-1200:1.8
	v20061214-0000:1.7
	v20061120-1300:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061013-1330:1.3
	M1_20:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.14
date	2007.06.21.14.08.17;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	1770467a86514567;

1.13
date	2007.05.23.17.30.54;	author bblajer;	state Exp;
branches;
next	1.12;
commitid	586b46547a4e4567;

1.12
date	2007.04.12.13.06.36;	author bblajer;	state Exp;
branches;
next	1.11;
commitid	243b461e2edb4567;

1.11
date	2007.04.10.14.40.08;	author bblajer;	state Exp;
branches;
next	1.10;
commitid	5ab6461ba1c74567;

1.10
date	2006.12.21.20.35.27;	author bblajer;	state Exp;
branches;
next	1.9;
commitid	bce458af0084567;

1.9
date	2006.12.20.13.25.15;	author bblajer;	state Exp;
branches;
next	1.8;
commitid	382e458939b94567;

1.8
date	2006.12.15.14.21.49;	author bblajer;	state Exp;
branches;
next	1.7;
commitid	25f84582af7c4567;

1.7
date	2006.11.29.13.51.53;	author bblajer;	state Exp;
branches;
next	1.6;
commitid	50a4456d90794567;

1.6
date	2006.11.16.18.31.55;	author bblajer;	state Exp;
branches;
next	1.5;
commitid	4bc4455cae994567;

1.5
date	2006.11.10.19.07.23;	author bblajer;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.24.17.04.13;	author bblajer;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.02.12.29.37;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.11.15.45.03;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.01.16.14.12;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.14
log
@fix copyright years
@
text
@/**
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bblajer - initial API and implementation
 */
package org.eclipse.gmf.runtime.lite.parts;

import java.util.Collection;
import java.util.Collections;
import java.util.EventObject;
import java.util.Map;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.draw2d.ColorConstants;
import org.eclipse.draw2d.IFigure;
import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.Notifier;
import org.eclipse.emf.common.notify.impl.AdapterImpl;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.emf.workspace.WorkspaceEditingDomainFactory;
import org.eclipse.gef.DefaultEditDomain;
import org.eclipse.gef.EditDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.GraphicalViewer;
import org.eclipse.gef.commands.CommandStack;
import org.eclipse.gef.commands.CommandStackEvent;
import org.eclipse.gef.commands.CommandStackEventListener;
import org.eclipse.gef.commands.CommandStackListener;
import org.eclipse.gef.editparts.ZoomManager;
import org.eclipse.gef.palette.PaletteRoot;
import org.eclipse.gef.ui.actions.ActionRegistry;
import org.eclipse.gef.ui.actions.SelectionAction;
import org.eclipse.gef.ui.actions.StackAction;
import org.eclipse.gef.ui.actions.WorkbenchPartAction;
import org.eclipse.gef.ui.views.palette.PalettePage;
import org.eclipse.gmf.runtime.lite.services.DefaultDiagramLayouter;
import org.eclipse.gmf.runtime.lite.services.IDiagramLayouter;
import org.eclipse.jface.action.IAction;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.ui.IEditorDescriptor;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorMatchingStrategy;
import org.eclipse.ui.IEditorReference;
import org.eclipse.ui.IEditorRegistry;
import org.eclipse.ui.IEditorSite;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.part.EditorPart;
import org.eclipse.ui.views.contentoutline.IContentOutlinePage;
import org.eclipse.ui.views.properties.IPropertySheetPage;

/**
 * This class serves as the base class for the generated diagram editors. 
 * @@author bblajer
 */
public abstract class DiagramEditor extends EditorPart implements IDiagramManager {
	private DiagramDisplayer myDiagramDisplayer;
	private boolean myIsDirty = false;

	private CommandStackListener commandStackListener = new CommandStackListener() {
		public void commandStackChanged(EventObject event) {
			setDirty(((CommandStack) event.getSource()).isDirty());
		}
	};

	private CommandStackEventListener mySaveListener = new CommandStackEventListener() {
		public void stackChanged(CommandStackEvent event) {
			if (event.isPostChangeEvent() && isSaved()) {
				getCommandStack().markSaveLocation();
			}
		}
		private boolean isSaved() {
			for(Resource next : getEditingDomain().getResourceSet().getResources()) {
				if (!next.isLoaded()) {
					continue;
				}
				if (!next.isTrackingModification() || next.isModified()) {
					return false;
				}
			}
			return true;
		}
	};

	protected void save(IProgressMonitor monitor) throws CoreException {
		myDiagramDisplayer.save(getSaveOptions(), monitor);
	}

	/**
	 * Returns the options with which the resources will be saved. Subclasses should override.
	 */
	protected Map<?, ?> getSaveOptions() {
		return Collections.emptyMap();
	}

	public final TransactionalEditingDomain getEditingDomain() {
		return myDiagramDisplayer.getEditingDomain();
	}

	protected final EditDomain getEditDomain() {
		return myDiagramDisplayer.getEditDomain();
	}

	protected final CommandStack getCommandStack() {
		return getEditDomain().getCommandStack();
	}

	protected final ZoomManager getZoomManager() {
		return myDiagramDisplayer.getZoomManager();
	}

	protected final ActionRegistry getActionRegistry() {
		return myDiagramDisplayer.getActionRegistry();
	}

	protected final GraphicalViewer getGraphicalViewer() {
		return myDiagramDisplayer.getGraphicalViewer();
	}

	protected IPropertySheetPage getPropertySheetPage() {
		return myDiagramDisplayer.getPropertySheetPage();
	}

	protected IContentOutlinePage getOutlinePage() {
		return new DiagramContentOutlinePage(myDiagramDisplayer, getDefaultOutlineViewMode());
	}

	protected IDiagramLayouter getDiagramLayouter() {
		return new DefaultDiagramLayouter();
	}

	/**
	 * Returns the initial display mode for the outline page to be shown. Possible values are <code>DiagramContentOutlinePage.ID_OUTLINE</code> and 
	 * <code>DiagramContentOutlinePage.ID_OVERVIEW</code>.
	 * By default, the outline page starts in the overview mode. Subclasses may reimplement.
	 */
	protected int getDefaultOutlineViewMode() {
		return DiagramContentOutlinePage.ID_OVERVIEW;
	}

	@@Override
	public boolean isSaveAsAllowed() {
		// TODO: should be allowed.
		return false;
	}

	@@Override
	public void doSaveAs() {
		// TODO: Implement.
	}

	@@Override
	public void init(IEditorSite site, IEditorInput input) throws PartInitException {
		setSite(site);
		TransactionalEditingDomain editingDomain = getEditingDomain(input);
		if (editingDomain == null) {
			editingDomain = reuseEditingDomain(input);
		}
		if (editingDomain == null) {
			editingDomain = createEditingDomain();
		}
		ForceTrackingModificationAdapter adapter = (ForceTrackingModificationAdapter) EcoreUtil.getExistingAdapter(editingDomain.getResourceSet(), ForceTrackingModificationAdapter.class);
		if (adapter == null) {
			adapter = new ForceTrackingModificationAdapter();
			editingDomain.getResourceSet().eAdapters().add(adapter);
		}
		adapter.acquire();
		myDiagramDisplayer = new DiagramDisplayer(this, createEditDomain(), editingDomain);
		getCommandStack().addCommandStackListener(commandStackListener);
		getCommandStack().addCommandStackEventListener(mySaveListener);
		setInput(input);
	}

	@@Override
	public void dispose() {
		if (myDiagramDisplayer != null) {
			getCommandStack().removeCommandStackEventListener(mySaveListener);
			getCommandStack().removeCommandStackListener(commandStackListener);
			ForceTrackingModificationAdapter adapter = (ForceTrackingModificationAdapter) EcoreUtil.getExistingAdapter(getEditingDomain().getResourceSet(), ForceTrackingModificationAdapter.class);
			if (adapter != null) {
				adapter.release();
				if (adapter.isReleased()) {
					getEditingDomain().getResourceSet().eAdapters().remove(adapter);
				}
			}
			myDiagramDisplayer.dispose();
			myDiagramDisplayer = null;
		}
		super.dispose();
	}

	@@Override
	public Object getAdapter(Class type) {
		if (type == IPropertySheetPage.class) {
			return getPropertySheetPage();
		} else if (type == IContentOutlinePage.class) {
			return getOutlinePage();
		} else if (type == ZoomManager.class) {
			return getZoomManager();
		} else if (type == IDiagramLayouter.class) {
			return getDiagramLayouter();
		} else if (type == PalettePage.class) {
			return myDiagramDisplayer.getPalettePage();
		} else if (type == GraphicalViewer.class) {
			return getGraphicalViewer();
		} else if (type == CommandStack.class) {
			return getCommandStack();
		} else if (type == ActionRegistry.class) {
			return getActionRegistry();
		} else if (type == EditPart.class && getGraphicalViewer() != null) {
			return getGraphicalViewer().getRootEditPart();
		} else if (type == IFigure.class && getGraphicalViewer() != null) {
			return ((GraphicalEditPart)getGraphicalViewer().getRootEditPart()).getFigure();
		}
		return super.getAdapter(type);
	}

	private void setDirty(boolean isDirty) {
		if (isDirty != myIsDirty) {
			myIsDirty = isDirty;
			firePropertyChange(PROP_DIRTY);
		}
	}

	@@Override
	public boolean isDirty() {
		return myIsDirty;
	}

	/**
	 * Adds an action to this editor's <code>ActionRegistry</code>. (This is
	 * a helper method.)
	 * 
	 * @@param action
	 *            the action to add.
	 */
	protected void addAction(IAction action) {
		myDiagramDisplayer.addAction(action);
	}

	/**
	 * Adds an editor action to this editor.
	 * 
	 * <p>
	 * Editor actions are actions that depend and work on the editor.
	 * 
	 * @@param action
	 *            the editor action
	 */
	protected void addEditorAction(WorkbenchPartAction action) {
		myDiagramDisplayer.addEditorAction(action);
	}

	/**
	 * Adds an <code>EditPart</code> action to this editor.
	 * 
	 * <p>
	 * <code>EditPart</code> actions are actions that depend and work on the
	 * selected <code>EditPart</code>s.
	 * 
	 * @@param action
	 *            the <code>EditPart</code> action
	 */
	protected void addEditPartAction(SelectionAction action) {
		myDiagramDisplayer.addEditPartAction(action);
	}

	/**
	 * Adds an <code>CommandStack</code> action to this editor.
	 * 
	 * <p>
	 * <code>CommandStack</code> actions are actions that depend and work on
	 * the <code>CommandStack</code>.
	 * 
	 * @@param action
	 *            the <code>CommandStack</code> action
	 */
	protected void addStackAction(StackAction action) {
		myDiagramDisplayer.addStackAction(action);
	}

	@@Override
	public void createPartControl(Composite parent) {
		myDiagramDisplayer.createViewer(parent);
		createActions();
	}

	@@Override
	public void setFocus() {
		myDiagramDisplayer.setFocus();
	}

	/**
	 * Returns the editing domain instance to be used for the specified input. If this method returns <code>null</code>, 
	 * a {@@link #createEditDomain() default instance} will be created and used.
	 * By default, return <code>null</code>. Subclasses may reimplement.
	 */
	protected TransactionalEditingDomain getEditingDomain(IEditorInput input) {
		if (input instanceof DiagramEditorInput) {
			TransactionalEditingDomain result = TransactionUtil.getEditingDomain(((DiagramEditorInput) input).getDiagram());
			return result;
		}
		return null;
	}

	/**
	 * Returns the editing domain that is used by other editors with the same input. This is done to correctly support 
	 * "New Editor" operation that is available in the context menu of the editor tab.
	 * @@return
	 */
	protected TransactionalEditingDomain reuseEditingDomain(IEditorInput input) {
		IEditorRegistry editorRegistry = PlatformUI.getWorkbench().getEditorRegistry();
		IEditorDescriptor editorDesc = editorRegistry.findEditor(getSite().getId());
		IEditorMatchingStrategy matchingStrategy = editorDesc.getEditorMatchingStrategy();
		IEditorReference[] editorRefs = getEditorSite().getPage().getEditorReferences();
		for (int i = 0; i < editorRefs.length; i++) {
			if (matches(matchingStrategy, editorRefs[i], input)) {
				DiagramEditor anotherEditor = (DiagramEditor) editorRefs[i].getEditor(false);
				if (anotherEditor != null) {
					return anotherEditor.getEditingDomain();
				}
			}
		}
		return null;
	}

	private boolean matches(IEditorMatchingStrategy strategy, IEditorReference editorRef, IEditorInput input) {
		if (strategy == null) {
			if (getSite().getId().equals(editorRef.getId())) {
				try {
					return input.equals(editorRef.getEditorInput());
				} catch (PartInitException e) {
					return false;
				}
			}
			return false;
		} else {
			return strategy.matches(editorRef, input);
		}
	}

	/**
	 * Returns the editing domain instance to be used for the diagram if none may be {@@link #getEditingDomain(IEditorInput) inferred} from the input.
	 * Subclasses may extend or reimplement.
	 */
	protected TransactionalEditingDomain createEditingDomain() {
		TransactionalEditingDomain editingDomain = WorkspaceEditingDomainFactory.INSTANCE.createEditingDomain();
		editingDomain.getResourceSet().eAdapters().add(new AdapterFactoryEditingDomain.EditingDomainProvider(editingDomain));
		return editingDomain;
	}

	public void configureGraphicalViewer() {
		getGraphicalViewer().getControl().setBackground(ColorConstants.listBackground);
	}

	protected double[] getZoomLevels() {
		double[] result = {.05, .1, .25, .5, .75, 1, 1.25, 1.5, 1.75, 2, 4};
		return result;
	}

	public abstract void configurePalette(PaletteRoot paletteRoot);

	/**
	 * Creates edit domain that will be used for the editor. 
	 * Subclasses may extend.
	 */
	protected EditDomain createEditDomain() {
		DefaultEditDomain domain = new DefaultEditDomain(this);
		return domain;
	}

	public abstract void initializeGraphicalViewer();

	public abstract AdapterFactory getDomainAdapterFactory();

	public abstract boolean isFlyoutPalette();

	protected abstract void createActions();

	private static class ForceTrackingModificationAdapter extends AdapterImpl {
		@@Override
		public void setTarget(Notifier newTarget) {
			super.setTarget(newTarget);
			if (newTarget instanceof ResourceSet) {
				ResourceSet resourceSet = (ResourceSet) newTarget;
				for(Resource next : resourceSet.getResources()) {
					next.setTrackingModification(true);
				}
			}
		}

		@@Override
		public void notifyChanged(Notification msg) {
			if (msg.getNotifier() == getTarget() && msg.getFeatureID(ResourceSet.class) == ResourceSet.RESOURCE_SET__RESOURCES) {
				switch (msg.getEventType()) {
				case Notification.ADD:
				{
					Resource resource = (Resource) msg.getNewValue();
					resource.setTrackingModification(true);
				}
				break;
				case Notification.ADD_MANY:
				{
					@@SuppressWarnings("unchecked") Collection<Resource> resources = (Collection<Resource>) msg.getNewValue();
					for(Resource next : resources) {
						next.setTrackingModification(true);
					}
				}
				}
			}
		}
		@@Override
		public boolean isAdapterForType(Object type) {
			return ForceTrackingModificationAdapter.class.equals(type);
		}
		public void acquire() {
			myRefCount++;
		}

		public void release() {
			if (myRefCount == 0) {
				throw new IllegalStateException();
			}
			myRefCount--;
		}

		public boolean isReleased() {
			return myRefCount == 0;
		}

		private int myRefCount;
	}
}
@


1.13
log
@Provide more zoom levels
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.12
log
@[178836]: Generate IEditorMatchingStrategy implementation;
Lite Diagram Editor opened using New Editor popup menu item on editor tab should share the editing domain with the originating editor
@
text
@d370 5
@


1.11
log
@[179970] - Adopt code generater to make use of EMF "conditional resource saving";
Correctly set charset for IFiles
@
text
@d54 1
d56 3
d61 1
d171 3
d176 6
d196 3
a198 3
			}
			if (adapter.isReleased()) {
				getEditingDomain().getResourceSet().eAdapters().remove(adapter);
d315 20
a334 5
			if (result != null) {
				ForceTrackingModificationAdapter adapter = (ForceTrackingModificationAdapter) EcoreUtil.getExistingAdapter(result.getResourceSet(), ForceTrackingModificationAdapter.class);
				if (adapter == null) {
					adapter = new ForceTrackingModificationAdapter();
					result.getResourceSet().eAdapters().add(adapter);
a335 1
				adapter.acquire();
a336 1
			return result;
d341 15
a362 3
		ForceTrackingModificationAdapter forceTrackingModificationAdapter = new ForceTrackingModificationAdapter();
		editingDomain.getResourceSet().eAdapters().add(forceTrackingModificationAdapter);
		forceTrackingModificationAdapter.acquire();
@


1.10
log
@Tabbed property sheet provided for the lite runtime (if GenPropertySheet is not null);
IllegalStateException when closing editor fixed.
@
text
@d15 1
d17 1
a17 1
import java.util.Iterator;
d82 1
a82 2
			for(Iterator it = getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {
				Resource next = (Resource) it.next();
d95 8
a102 1
		myDiagramDisplayer.save(monitor);
d356 2
a357 2
				for(Iterator it = resourceSet.getResources().iterator(); it.hasNext(); ) {
					((Resource) it.next()).setTrackingModification(true);
d361 1
d374 3
a376 3
					Collection resources = (Collection) msg.getNewValue();
					for(Iterator it = resources.iterator(); it.hasNext(); ) {
						((Resource) it.next()).setTrackingModification(true);
@


1.9
log
@NPE in DiagramEditor.dispose()
@
text
@d173 3
a175 2
			assert adapter != null;
			adapter.release();
d314 3
a316 1
		editingDomain.getResourceSet().eAdapters().add(new ForceTrackingModificationAdapter());
@


1.8
log
@1. getEditingDomain() method made public (will be needed for navigator support);
2. NPE in DiagramEditor.dispose() fixed.
@
text
@a171 2
			myDiagramDisplayer.dispose();
			myDiagramDisplayer = null;
d178 2
@


1.7
log
@[165791]: Diagrams that share EMF EditingDomain should share GEF CommandStacks
@
text
@d98 1
a98 1
	protected final TransactionalEditingDomain getEditingDomain() {
d174 6
a179 6
		}
		ForceTrackingModificationAdapter adapter = (ForceTrackingModificationAdapter) EcoreUtil.getExistingAdapter(getEditingDomain().getResourceSet(), ForceTrackingModificationAdapter.class);
		assert adapter != null;
		adapter.release();
		if (adapter.isReleased()) {
			getEditingDomain().getResourceSet().eAdapters().remove(adapter);
@


1.6
log
@[164843]: Make it possible to specify the editing domain with which the editor/viewer should operate;
Refactoring to use as much common code as possible for diagram editors and viewers (for #163214);
Manifest.mf specifies J2SE1.5 as required execution environment.
@
text
@d28 1
d31 1
a37 1
import org.eclipse.gef.commands.Command;
d39 2
d74 20
d163 1
d170 1
d175 6
d290 13
a302 1
	protected TransactionalEditingDomain getEditingDomain(IEditorInput editorInput) {
a328 35
		domain.setCommandStack(new CommandStack(){
			@@Override
			public void execute(Command command) {
				super.execute(command);
				if (isSaved()) {
					markSaveLocation();
				}
			}
			@@Override
			public void undo() {
				super.undo();
				if (isSaved()) {
					markSaveLocation();
				}
			}
			@@Override
			public void redo() {
				super.redo();
				if (isSaved()) {
					markSaveLocation();
				}
			}
			private boolean isSaved() {
				for(Iterator it = getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {
					Resource next = (Resource) it.next();
					if (!next.isLoaded()) {
						continue;
					}
					if (!next.isTrackingModification() || next.isModified()) {
						return false;
					}
				}
				return true;
			}
		});
d371 20
@


1.5
log
@[162579] Support diagram partitioning
+
1. CustomBehaviours;
2. LayoutDiagramAction: execute the command through the command stack;
3. WrappingCommand: Workaround for a problem with StrictCompoundCommand.canExecute() in transactional editing domains
(For some reason, this file was not committed as a part of the commit for 162579)
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corp.
a13 2
import java.io.IOException;
import java.util.ArrayList;
a14 1
import java.util.Collections;
d20 2
a21 7
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Status;
import org.eclipse.draw2d.LightweightSystem;
import org.eclipse.draw2d.Viewport;
import org.eclipse.draw2d.parts.ScrollableThumbnail;
import org.eclipse.draw2d.parts.Thumbnail;
d32 3
a35 4
import org.eclipse.gef.KeyHandler;
import org.eclipse.gef.KeyStroke;
import org.eclipse.gef.LayerConstants;
import org.eclipse.gef.RootEditPart;
a38 4
import org.eclipse.gef.editparts.FreeformGraphicalRootEditPart;
import org.eclipse.gef.editparts.RootTreeEditPart;
import org.eclipse.gef.editparts.ScalableFreeformRootEditPart;
import org.eclipse.gef.editparts.ScalableRootEditPart;
a41 1
import org.eclipse.gef.ui.actions.GEFActionConstants;
a43 1
import org.eclipse.gef.ui.actions.UpdateAction;
d45 1
a45 7
import org.eclipse.gef.ui.parts.ContentOutlinePage;
import org.eclipse.gef.ui.parts.GraphicalEditorWithFlyoutPalette;
import org.eclipse.gef.ui.parts.TreeViewer;
import org.eclipse.gmf.internal.runtime.lite.Activator;
import org.eclipse.gmf.runtime.lite.edit.parts.tree.DiagramTreeEditPartFactory;
import org.eclipse.gmf.runtime.lite.properties.PropertySourceProvider;
import org.eclipse.gmf.runtime.lite.properties.UndoablePropertySheetEntry;
a47 1
import org.eclipse.jface.action.Action;
a48 8
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.DisposeEvent;
import org.eclipse.swt.events.DisposeListener;
import org.eclipse.swt.widgets.Canvas;
a49 2
import org.eclipse.swt.widgets.Control;
import org.eclipse.ui.IActionBars;
a50 1
import org.eclipse.ui.IEditorPart;
a51 2
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.IWorkbenchPart;
d53 1
a53 4
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.part.IPageSite;
import org.eclipse.ui.part.Page;
import org.eclipse.ui.part.PageBook;
a55 1
import org.eclipse.ui.views.properties.PropertySheetPage;
d58 2
a59 1
 * Common functionality of all diagram editors generated with the lite generator.
d61 3
a63 13
public abstract class DiagramEditor extends GraphicalEditorWithFlyoutPalette {
	protected static final int ID_OVERVIEW = 0;
	protected static final int ID_OUTLINE = 1;

	protected class DiagramContentOutlinePage extends Page implements IContentOutlinePage {
		private ContentOutlinePage myOutlinePage;
		private Canvas myOverview;
		private PageBook myPageBook;
		private IAction myShowOutlineAction;
		private IAction myShowOverviewAction;
		private Thumbnail myThumbnail;
		private TreeViewer myTreeViewer;
		private DisposeListener myDisposeListener;
d65 3
a67 15
		@@Override
		public void init(IPageSite pageSite) {
			super.init(pageSite);
			ActionRegistry registry = getActionRegistry();
			IActionBars bars = pageSite.getActionBars();
			String id = ActionFactory.UNDO.getId();
			bars.setGlobalActionHandler(id, registry.getAction(id));
			id = ActionFactory.REDO.getId();
			bars.setGlobalActionHandler(id, registry.getAction(id));
			id = ActionFactory.DELETE.getId();
			bars.setGlobalActionHandler(id, registry.getAction(id));
			bars.updateActionBars();
			
			// Toolbar refresh to solve linux defect RATLC525198
			bars.getToolBarManager().markDirty();
d69 1
d71 3
a73 5
		public void addSelectionChangedListener(ISelectionChangedListener listener) {
			if (myOutlinePage != null) {
				myOutlinePage.addSelectionChangedListener(listener);
			}
		}
d75 3
a77 5
		public void removeSelectionChangedListener(ISelectionChangedListener listener) {
			if (myOutlinePage != null) {
				myOutlinePage.removeSelectionChangedListener(listener);
			}
		}
d79 3
a81 6
		public ISelection getSelection() {
			if (myOutlinePage != null) {
				return myOutlinePage.getSelection();
			}
			return StructuredSelection.EMPTY;
		}
d83 3
a85 5
		public void setSelection(ISelection selection) {
			if (myOutlinePage != null) {
				myOutlinePage.setSelection(selection);
			}
		}
d87 3
a89 15
		@@Override
		public void createControl(Composite parent) {
			myPageBook = new PageBook(parent, SWT.NONE);
			myTreeViewer = new TreeViewer();
			myTreeViewer.setRootEditPart(new RootTreeEditPart());
			myTreeViewer.setEditDomain(getEditDomain());
			myTreeViewer.setEditPartFactory(new DiagramTreeEditPartFactory(getGraphicalViewer()));
			configureTreeViewer(myTreeViewer);
			myOutlinePage = new ContentOutlinePage(myTreeViewer);
			myOutlinePage.createControl(myPageBook);
			myTreeViewer.setContents(getGraphicalViewer().getContents().getModel());
			hookOutlineViewer(myTreeViewer);
			configureOutlinePage();
			showPage(getDefaultOutlineViewMode());
		}
d91 3
a93 3
		protected void hookOutlineViewer(TreeViewer viewer) {
			getSelectionSynchronizer().addViewer(viewer);
		}
d95 3
a97 3
		protected void unhookOutlineViewer(TreeViewer viewer) {
			getSelectionSynchronizer().removeViewer(viewer);
		}
d99 3
a101 19
		protected void configureOutlinePage() {
			IToolBarManager tbm = this.getSite().getActionBars().getToolBarManager();
			myShowOutlineAction = new Action() {
				public void run() {
					showPage(ID_OUTLINE);
				}
			};
			myShowOutlineAction.setImageDescriptor(Activator.getImageDescriptor("icons/outline.gif"));	//$NON-NLS-1$
			myShowOutlineAction.setToolTipText("Show Outline");
			tbm.add(myShowOutlineAction);
			myShowOverviewAction = new Action() {
				public void run() {
					showPage(ID_OVERVIEW);
				}
			};
			myShowOverviewAction.setImageDescriptor(Activator.getImageDescriptor("icons/overview.gif"));	//$NON-NLS-1$
			myShowOverviewAction.setToolTipText("Show Overview");
			tbm.add(myShowOverviewAction);
		}
d103 3
a105 8
		protected void configureTreeViewer(TreeViewer treeViewer) {
			KeyHandler keyHandler = new KeyHandler();
			keyHandler.put(KeyStroke.getPressed(SWT.DEL, 127, 0),
					getActionRegistry().getAction(ActionFactory.DELETE.getId()));
			keyHandler.put(KeyStroke.getPressed(SWT.F2, 0), getActionRegistry()
					.getAction(GEFActionConstants.DIRECT_EDIT));
			treeViewer.setKeyHandler(keyHandler);
		}
d107 3
a109 22
		protected void showPage(int pageId) {
			switch (pageId) {
			case ID_OUTLINE:
				myShowOutlineAction.setChecked(true);
				myShowOverviewAction.setChecked(false);
				myPageBook.showPage(myOutlinePage.getControl());
				if (myThumbnail != null) {
					myThumbnail.setVisible(false);
				}
				break;
			case ID_OVERVIEW:
				myShowOutlineAction.setChecked(false);
				myShowOverviewAction.setChecked(true);
				if (myOverview == null || myOverview.isDisposed()) {
					initializeOverview();
				}
				myPageBook.showPage(myOverview);
				if (myThumbnail != null) {
					myThumbnail.setVisible(true);
				}
			}
		}
d111 8
a118 17
		protected void initializeOverview() {
			myOverview = new Canvas(myPageBook, SWT.NONE);
			LightweightSystem lws = new LightweightSystem(myOverview);
			FreeformGraphicalRootEditPart root = (FreeformGraphicalRootEditPart) getGraphicalViewer().getRootEditPart();
			myThumbnail = new ScrollableThumbnail((Viewport) root.getFigure());
			myThumbnail.setSource(root.getLayer(LayerConstants.SCALABLE_LAYERS));
			lws.setContents(myThumbnail);
			myDisposeListener = new DisposeListener() {
				public void widgetDisposed(DisposeEvent e) {
					if (myThumbnail != null) {
						myThumbnail.deactivate();
						myThumbnail = null;
					}
				}
			};
			getGraphicalControl().addDisposeListener(myDisposeListener);
		}
d120 5
a124 4
		@@Override
		public Control getControl() {
			return myPageBook;
		}
d126 4
a129 6
		@@Override
		public void setFocus() {
			if (myOutlinePage != null) {
				myOutlinePage.setFocus();
			}
		}
d131 6
a136 15
		@@Override
		public void dispose() {
			if (myOutlinePage != null) {
				myOutlinePage.dispose();
			}
			unhookOutlineViewer(myTreeViewer);
			if (myThumbnail != null) {
				myThumbnail.deactivate();
				myThumbnail = null;
			}
			if (myDisposeListener != null) {
				getGraphicalControl().removeDisposeListener(myDisposeListener);
			}
			myOverview = null;
			super.dispose();
d138 3
d143 6
a148 4
	private static class UpdatableActionGroup {
		public void addAction(UpdateAction action) {
			assert action != null;
			myActions.add(action);
d150 2
d153 22
a174 2
		public void removeAction(UpdateAction action) {
			myActions.remove(action);
d176 2
d179 4
a182 5
		public void update() {
			for (Iterator it = myActions.iterator(); it.hasNext();) {
				UpdateAction next = (UpdateAction) it.next();
				next.update();
			}
a183 2

		private ArrayList myActions = new ArrayList();
d186 3
a188 30
	private TransactionalEditingDomain editingDomain;

	private boolean isDirty = false;

	private PaletteRoot paletteRoot;

	private PropertySheetPage undoablePropertySheetPage;

	private UpdatableActionGroup stackActions = new UpdatableActionGroup();

	private CommandStackListener commandStackListener = new CommandStackListener() {
		public void commandStackChanged(EventObject event) {
			stackActions.update();
			setDirty(((CommandStack) event.getSource()).isDirty());
		}
	};

	private UpdatableActionGroup editPartActions = new UpdatableActionGroup();

	private ISelectionListener selectionListener = new ISelectionListener() {
		public void selectionChanged(IWorkbenchPart part, ISelection selection) {
			editPartActions.update();
		}
	};

	private UpdatableActionGroup editorActions = new UpdatableActionGroup();

	protected void firePropertyChange(int propertyId) {
		super.firePropertyChange(propertyId);
		editorActions.update();
d199 1
a199 1
		getActionRegistry().registerAction(action);
d212 1
a212 2
		getActionRegistry().registerAction(action);
		editorActions.addAction(action);
d226 1
a226 2
		getActionRegistry().registerAction(action);
		editPartActions.addAction(action);
d240 7
a246 2
		getActionRegistry().registerAction(action);
		stackActions.addAction(action);
d249 36
a284 2
	public void init(IEditorSite site, IEditorInput input) throws PartInitException {
		setSite(site);
d321 1
a321 100
		setEditDomain(domain);

		// add CommandStackListener
		getCommandStack().addCommandStackListener(getStackActionsListener());

		// add selection change listener
		getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(getSelectionListener());
		setInput(input);
	}

	public void dispose() {
		// remove CommandStackListener
		getCommandStack().removeCommandStackListener(getStackActionsListener());

		// remove selection listener
		getSite().getWorkbenchWindow().getSelectionService().removeSelectionListener(getSelectionListener());

		// dispose the ActionRegistry (will dispose all actions)
		getActionRegistry().dispose();
	}

	protected void save(IProgressMonitor progressMonitor) throws CoreException {
		if (progressMonitor == null) {
			progressMonitor = new NullProgressMonitor();
		}
		progressMonitor.beginTask("Saving", getEditingDomain().getResourceSet().getResources().size());
		try {
			for(Iterator it = getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {
				Resource next = (Resource)it.next();
				if (next.isLoaded() && (next.isModified() || !next.isTrackingModification())) {
					next.save(Collections.EMPTY_MAP);
				}
				progressMonitor.worked(1);
			}
		} catch (IOException e) {
			IStatus status = new Status(IStatus.ERROR, Activator.getDefault().getBundle().getSymbolicName(), 0, "Error writing file.", e);
			throw new CoreException(status);
		} finally {
			progressMonitor.done();
		}
	}

	public boolean isSaveAsAllowed() {
		// TODO: should be allowed.
		return false;
	}

	public void doSaveAs() {
		// TODO: Implement.
	}

	public Object getAdapter(Class type) {
		if (type == IPropertySheetPage.class) {
			return getPropertySheetPage();
		} else if (type == IContentOutlinePage.class) {
			return getOutlinePage();
		} else if (type == ZoomManager.class) {
			return getZoomManager();
		} else if (type == IDiagramLayouter.class) {
			return getDiagramLayouter();
		}
		return super.getAdapter(type);
	}

	protected IDiagramLayouter getDiagramLayouter() {
		return new DefaultDiagramLayouter();
	}

	protected ZoomManager getZoomManager() {
		return getZoomManager(getGraphicalViewer());
	}

	private ZoomManager getZoomManager(GraphicalViewer viewer) {
		// get zoom manager from root edit part
		RootEditPart rootEditPart = viewer.getRootEditPart();
		ZoomManager zoomManager = null;
		if (rootEditPart instanceof ScalableFreeformRootEditPart) {
			zoomManager = ((ScalableFreeformRootEditPart) rootEditPart).getZoomManager();
		} else if (rootEditPart instanceof ScalableRootEditPart) {
			zoomManager = ((ScalableRootEditPart) rootEditPart).getZoomManager();
		}
		return zoomManager;
	}

	protected PaletteRoot getPaletteRoot() {
		if (paletteRoot == null) {
			paletteRoot = new PaletteRoot();
			configurePalette(paletteRoot);
		}
		return paletteRoot;
	}

	protected abstract void configurePalette(PaletteRoot paletteRoot);

	protected CommandStackListener getStackActionsListener() {
		return commandStackListener;
	}

	protected IContentOutlinePage getOutlinePage() {
		return new DiagramContentOutlinePage();
d324 1
a324 7
	/**
	 * Returns the initial display mode for the outline page to be shown. Possible values are <code>ID_OUTLINE</code> and <code>ID_OVERVIEW</code>.
	 * By default, the outline page starts in the overview mode. Subclasses may reimplement.
	 */
    protected int getDefaultOutlineViewMode() {
        return ID_OVERVIEW;
    }
d326 1
d328 1
a328 7
	protected PropertySheetPage getPropertySheetPage() {
		if (undoablePropertySheetPage == null) {
			undoablePropertySheetPage = new PropertySheetPage();
			UndoablePropertySheetEntry rootEntry = new UndoablePropertySheetEntry(getCommandStack());
			rootEntry.setPropertySourceProvider(new PropertySourceProvider(getDomainAdapterFactory()));
			undoablePropertySheetPage.setRootEntry(rootEntry);
		}
d330 1
a330 39
		return undoablePropertySheetPage;
	}

	private ISelectionListener getSelectionListener() {
		return selectionListener;
	}

	public boolean isDirty() {
		return isDirty;
	}

	private void setDirty(boolean dirty) {
		if (isDirty != dirty) {
			isDirty = dirty;
			firePropertyChange(IEditorPart.PROP_DIRTY);
		}
	}

	protected TransactionalEditingDomain getEditingDomain() {
		if (editingDomain == null) {
			editingDomain = WorkspaceEditingDomainFactory.INSTANCE.createEditingDomain();
			//editingDomain.setAdapterFactory(getDomainAdapterFactory());
			editingDomain.getResourceSet().eAdapters().add(new AdapterFactoryEditingDomain.EditingDomainProvider(editingDomain));
			editingDomain.getResourceSet().eAdapters().add(new ForceTrackingModificationAdapter());
		}
		return editingDomain;
	}

	protected abstract AdapterFactory getDomainAdapterFactory();

	public void setFocus() {
		getGraphicalViewer().getControl().setFocus();
	}

	public final void createPartControl(Composite parent) {
		super.createPartControl(parent);
		// initialize actions
		createActions();
	}
@


1.4
log
@#162053: Provide Diagram Overview in Outline view for diagrams
@
text
@d16 1
d31 3
d35 1
d45 1
d388 37
a424 2
		setInput(input);
		setEditDomain(new DefaultEditDomain(this));
d431 1
a442 1

d534 2
a535 1
    protected PropertySheetPage getPropertySheetPage() {
d566 1
d582 33
@


1.3
log
@[158023] bblajer - Diagram Layout
@
text
@d25 4
d38 1
d42 1
d48 1
d63 1
d65 1
d67 2
d70 3
d74 2
d83 3
d94 179
d482 1
a482 21
		final TreeViewer treeViewer = new TreeViewer();
		treeViewer.setRootEditPart(new RootTreeEditPart());
		treeViewer.setEditDomain(getEditDomain());
		treeViewer.setEditPartFactory(new DiagramTreeEditPartFactory(getGraphicalViewer()));
		getSelectionSynchronizer().addViewer(treeViewer);
		configureTreeViewer(treeViewer);
		return new ContentOutlinePage(treeViewer) {
			public void createControl(Composite parent) {
				super.createControl(parent);
				treeViewer.setContents(getGraphicalViewer().getContents().getModel());
			}
		};
	}

	protected void configureTreeViewer(TreeViewer treeViewer) {
		KeyHandler keyHandler = new KeyHandler();
		keyHandler.put(KeyStroke.getPressed(SWT.DEL, 127, 0),
				getActionRegistry().getAction(ActionFactory.DELETE.getId()));
		keyHandler.put(KeyStroke.getPressed(SWT.F2, 0), getActionRegistry()
				.getAction(GEFActionConstants.DIRECT_EDIT));
		treeViewer.setKeyHandler(keyHandler);
d485 9
a493 1
	protected PropertySheetPage getPropertySheetPage() {
@


1.2
log
@[156358] bblajer - Diagram overview with Lite runtime
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Eclipse.org
d54 2
d243 2
d249 4
a352 1

@


1.1
log
@[155040] bblajer - Common Lite runtime functionality moved to dedicated plugin
@
text
@d32 2
d37 1
d42 1
d47 1
d49 1
d51 1
d56 1
d64 1
d212 1
a212 1
				if (next.isLoaded() && next.isModified()) {
d276 21
a296 2
		//TODO: outline page missing
		return null;
@

