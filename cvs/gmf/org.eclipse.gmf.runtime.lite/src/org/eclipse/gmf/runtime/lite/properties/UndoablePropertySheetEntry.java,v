head	1.3;
access;
symbols
	v20080722-1827:1.3
	R2_1_maintenance:1.3.0.2
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080425-1959:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070921-0000:1.2.2.1
	v20070903-0000:1.3
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	v20070621-0000:1.2
	RC3_20:1.2
	v20070601-1400:1.2
	v20070525-1500:1.2
	v20070518-1300:1.2
	v20070427-0600:1.2
	v20070420-1000:1.2
	v20070413-1300:1.2
	v20070405-1100:1.2
	v20070330-1300:1.2
	v20060330-1300:1.2
	v20070322-1100:1.2
	v20060316-0600:1.2
	v20070307-0700:1.2
	v20070228-2000:1.2
	v20070208-1800:1.2
	M4_20:1.2
	v20061222-1800:1.2
	v20061218-1200:1.1
	v20061214-0000:1.1
	v20061120-1300:1.1
	M3_20:1.1
	v20061117-0800:1.1
	v20061013-1330:1.1
	M1_20:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.3
date	2007.07.04.13.22.23;	author bblajer;	state Exp;
branches;
next	1.2;
commitid	4058468b9f0d4567;

1.2
date	2006.12.21.20.35.27;	author bblajer;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	bce458af0084567;

1.1
date	2006.09.01.16.14.11;	author atikhomirov;	state Exp;
branches;
next	;

1.2.2.1
date	2007.09.17.16.01.51;	author bblajer;	state Exp;
branches;
next	;
commitid	7ad046eea4ed4567;


desc
@@


1.3
log
@Eliminated Jet templates in lite version;
i18n in lite RT;
For generated classes whose names are not directly modifiable via gmfgen file, consistent className/qualifiedClassName template is exposed (and used throughout the generation process, including the Generator);
Link labels and external node labels are not selectable, but movable;
Inner elements are not selectable with marquee tool;
Fixed copyright statements throughout the lite RT.
@
text
@/**
 * Copyright (c) 2006 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bblajer - initial API and implementation
 */
package org.eclipse.gmf.runtime.lite.properties;

import org.eclipse.gef.commands.CommandStack;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gef.commands.ForwardUndoCompoundCommand;
import org.eclipse.ui.views.properties.IPropertySource;
import org.eclipse.ui.views.properties.PropertySheetEntry;

/**
 * Copied from <code>org.eclipse.gef.ui.properties.UndoablePropertySheetEntry</code> to provide EMF compatibility.
 */
class UndoablePropertySheetEntry extends PropertySheetEntry {
	UndoablePropertySheetEntry() {
	}

	protected PropertySheetEntry createChildEntry() {
		return new UndoablePropertySheetEntry();
	}

	CommandStack getCommandStack() {
		return getRoot().getCommandStack();
	}

	RootUndoablePropertySheetEntry getRoot() {
		return ((UndoablePropertySheetEntry)getParent()).getRoot();
	}

	public void resetPropertyValue() {
		CompoundCommand cc = new CompoundCommand();
		ResetValueCommand restoreCmd;

		//	Use our parent's values to reset our values.
		boolean change = false;
		Object[] objects = getParent().getValues();
		for (int i = 0; i < objects.length; i++) {
			IPropertySource source = getPropertySource(objects[i]);
			if (source.isPropertySet(getDescriptor().getId())) {
				//source.resetPropertyValue(getDescriptor()getId());
				restoreCmd = new ResetValueCommand();
				restoreCmd.setTarget(source);
				restoreCmd.setPropertyId(getDescriptor().getId());
				cc.add(restoreCmd);			
				change = true;
			}
		}
		if (change) {
			getCommandStack().execute(cc);
			refreshFromRoot();
		}
	}

	protected void valueChanged(PropertySheetEntry child) {
		valueChanged((UndoablePropertySheetEntry)child,
				new ForwardUndoCompoundCommand());
	}

	private void valueChanged(UndoablePropertySheetEntry child, CompoundCommand command) {
		CompoundCommand cc = new CompoundCommand();
		command.add(cc);

		SetValueCommand setCommand;
		for (int i = 0; i < getValues().length; i++) {
			setCommand = new SetValueCommand(child.getDisplayName());
			setCommand.setTarget(getPropertySource(getValues()[i]));
			setCommand.setPropertyId(child.getDescriptor().getId());
			setCommand.setPropertyValue(child.getValues()[i]);
			cc.add(setCommand);
		}

		// inform our parent
		informRoot(this, command);
	}

	protected void informRoot(UndoablePropertySheetEntry child, CompoundCommand command) {
		((UndoablePropertySheetEntry)getParent()).valueChanged(this, command);
	}
}
@


1.2
log
@Tabbed property sheet provided for the lite runtime (if GenPropertySheet is not null);
IllegalStateException when closing editor fixed.
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Eclipse.org
@


1.2.2.1
log
@Fixed copyright statements throughout the lite RT
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.1
log
@[155040] bblajer - Common Lite runtime functionality moved to dedicated plugin
@
text
@a13 2
import java.util.EventObject;

a14 1
import org.eclipse.gef.commands.CommandStackListener;
d23 2
a24 14
public class UndoablePropertySheetEntry extends PropertySheetEntry {
	private CommandStackListener commandStackListener;

	private CommandStack stack;

	private UndoablePropertySheetEntry() {
	}

	/**
	 * Constructs the root entry using the given command stack.
	 * @@param stack the command stack
	 */
	public UndoablePropertySheetEntry(CommandStack stack) {
		setCommandStack(stack);
d31 2
a32 4
	public void dispose() {
		if (stack != null)
			stack.removeCommandStackListener(commandStackListener);
		super.dispose();
d35 2
a36 6
	CommandStack getCommandStack() {
		//only the root has, and is listening too, the command stack
		if (getParent() != null) {
			return ((UndoablePropertySheetEntry)getParent()).getCommandStack();
		}
		return stack;
a42 5
		if (getParent() == null) {
			// root does not have a default value
			return;
		}

a62 10
	void setCommandStack(CommandStack stack) {
		this.stack = stack;
		commandStackListener = new CommandStackListener() {
			public void commandStackChanged(EventObject e) {
				refreshFromRoot();
			}
		};
		stack.addCommandStackListener(commandStackListener);
	}

d68 1
a68 1
	void valueChanged(UndoablePropertySheetEntry child, CompoundCommand command) {
d82 5
a86 6
		if (getParent() != null) {
			((UndoablePropertySheetEntry)getParent()).valueChanged(this, command);
		}else {
			//I am the root entry
			stack.execute(command);
		}
@

