14a15,16
> import java.util.HashSet;
> import java.util.Iterator;
18a21,21
> import java.util.Set;
223a227,227
>         collectObstructions(conn, rPoly, collectObstructs);
224,243d226
<             List children = parent.getChildren();
<             for (int i = 0; i < children.size(); i++) {
<                 IFigure child = (IFigure) children.get(i);
< 
<                 if (child != conn.getSourceAnchor().getOwner() 
<                     && child != conn.getTargetAnchor().getOwner() 
<                     && !FigureUtilities.isAncestor(child, conn.getSourceAnchor().getOwner())
<                     && !FigureUtilities.isAncestor(child, conn.getTargetAnchor().getOwner())) {
<                     Rectangle rObstruct = new Rectangle(child.getBounds());
<                     child.translateToAbsolute(rObstruct);
<                     conn.translateToRelative(rObstruct);
< 
<                     // inflate slightly
<                     rObstruct.expand(1, 1);
< 
<                     if (rPoly.intersects(rObstruct)) {
<                         collectObstructs.add(rObstruct);
<                     }
<                 }
<             }
293a278,351
>      * Finds all the children shapes of the parent figure passed in that are in
>      * the way of the connection. This method will dig into children of
>      * container shapes if one of the connection ends is also in that container.
>      * 
>      * @param connection
>      *            the connection being routed
>      * @param connectionRect
>      *            the rectangle representing the connection bounds that is used
>      *            to determine if a shape intersects with the connection
>      * @param obstructionsToReturn
>      *            the list of figures that the connection should be routed
>      *            around
>      */
>     protected void collectObstructions(Connection connection,
>             Rectangle connectionRect, List obstructionsToReturn) {
> 
>         Set containerFiguresToSearch = new HashSet();
>         Set figuresToExclude = new HashSet();
> 
>         IFigure figure = connection.getSourceAnchor().getOwner();
>         figuresToExclude.add(figure);
>         figure = figure.getParent();
>         while (figure != null) {
>             if (figure.getLayoutManager() instanceof XYLayout) {
>                 containerFiguresToSearch.add(figure);
>             }
>             figuresToExclude.add(figure);
>             figure = figure.getParent();
>         }
> 
>         figure = connection.getTargetAnchor().getOwner();
>         figuresToExclude.add(figure);
>         figure = figure.getParent();
>         while (figure != null) {
>             if (figure.getLayoutManager() instanceof XYLayout) {
>                 containerFiguresToSearch.add(figure);
>             }
>             figuresToExclude.add(figure);
>             figure = figure.getParent();
>         }
> 
>         for (Iterator iter = containerFiguresToSearch.iterator(); iter
>             .hasNext();) {
>             IFigure containerFigure = (IFigure) iter.next();
> 
>             for (Iterator iterator = containerFigure.getChildren().iterator(); iterator
>                 .hasNext();) {
>                 IFigure childFigure = (IFigure) iterator.next();
> 
>                 if (!figuresToExclude.contains(childFigure)) {
> 
>                     Rectangle rObstruct = new Rectangle(childFigure.getBounds());
>                     childFigure.translateToAbsolute(rObstruct);
>                     connection.translateToRelative(rObstruct);
> 
>                     // inflate slightly
>                     rObstruct.expand(1, 1);
> 
>                     if (connectionRect.intersects(rObstruct)) {
>                         obstructionsToReturn.add(rObstruct);
>                     }
>                 }
>             }
>         }
>     }
>     
>     /**
>      * @param conn
>      *            the <code>Connection</code> that is to have used to
>      *            determine the end points for reseting the <code>newLine</code>
>      *            parameter.
>      * @param newLine
>      *            the <code>PointList</code> to reset the end points of to be
>      *            on the edge of the connection source and target nodes.
294,297d277
<      * @param conn the <code>Connection</code> that is to have used to determine the end
<      * points for reseting the <code>newLine</code> parameter.
<      * @param newLine the <code>PointList</code> to reset the end points of to be on the
<      * edge of the connection source and target nodes.
514,514d567
< 
