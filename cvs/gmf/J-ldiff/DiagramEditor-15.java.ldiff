0a1,2
> /******************************************************************************
>  * Copyright (c) 2002, 2005 IBM Corporation and others.
1,3d0
< /**
<  * Copyright (c) 2006 Borland Software Corporation
<  * 
9a9,11
>  *    IBM Corporation - initial API and implementation 
>  ****************************************************************************/
> 
10,11d8
<  *    bblajer - initial API and implementation
<  */
12,12c12,12
< package org.eclipse.gmf.runtime.lite.parts;
---
> package org.eclipse.gmf.runtime.diagram.ui.parts;
13a14,14
> import java.io.File;
14,14c15,15
< import java.util.Collection;
---
> import java.io.IOException;
14a16,16
> import java.util.ArrayList;
15a18,18
> import java.util.Iterator;
16,16d17
< import java.util.EventObject;
17,17c19,19
< import java.util.Map;
---
> import java.util.List;
18a21,24
> import org.eclipse.core.resources.IMarker;
> import org.eclipse.core.runtime.IAdaptable;
> import org.eclipse.core.runtime.IPath;
> import org.eclipse.core.runtime.IStatus;
19,21d20
< import org.eclipse.core.runtime.CoreException;
< import org.eclipse.core.runtime.IProgressMonitor;
< import org.eclipse.draw2d.ColorConstants;
22,22c25,25
< import org.eclipse.draw2d.IFigure;
---
> import org.eclipse.draw2d.FigureCanvas;
22a26,30
> import org.eclipse.draw2d.LightweightSystem;
> import org.eclipse.draw2d.Viewport;
> import org.eclipse.draw2d.geometry.Point;
> import org.eclipse.draw2d.parts.ScrollableThumbnail;
> import org.eclipse.draw2d.parts.Thumbnail;
23,28d25
< import org.eclipse.emf.common.notify.AdapterFactory;
< import org.eclipse.emf.common.notify.Notification;
< import org.eclipse.emf.common.notify.Notifier;
< import org.eclipse.emf.common.notify.impl.AdapterImpl;
< import org.eclipse.emf.ecore.resource.Resource;
< import org.eclipse.emf.ecore.resource.ResourceSet;
29,29c31,31
< import org.eclipse.emf.ecore.util.EcoreUtil;
---
> import org.eclipse.emf.ecore.EObject;
30,33d31
< import org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain;
< import org.eclipse.emf.transaction.TransactionalEditingDomain;
< import org.eclipse.emf.transaction.util.TransactionUtil;
< import org.eclipse.emf.workspace.WorkspaceEditingDomainFactory;
34,34c32,32
< import org.eclipse.gef.DefaultEditDomain;
---
> import org.eclipse.gef.ContextMenuProvider;
35,35d32
< import org.eclipse.gef.EditDomain;
36a34,38
> import org.eclipse.gef.EditPartFactory;
> import org.eclipse.gef.EditPartViewer;
> import org.eclipse.gef.KeyHandler;
> import org.eclipse.gef.KeyStroke;
> import org.eclipse.gef.LayerConstants;
37,37c39,39
< import org.eclipse.gef.GraphicalEditPart;
---
> import org.eclipse.gef.RootEditPart;
38,38c40,40
< import org.eclipse.gef.GraphicalViewer;
---
> import org.eclipse.gef.SnapToGeometry;
39,39c41,41
< import org.eclipse.gef.commands.CommandStack;
---
> import org.eclipse.gef.SnapToGrid;
40,42d41
< import org.eclipse.gef.commands.CommandStackEvent;
< import org.eclipse.gef.commands.CommandStackEventListener;
< import org.eclipse.gef.commands.CommandStackListener;
44,44c43,43
< import org.eclipse.gef.palette.PaletteRoot;
---
> import org.eclipse.gef.rulers.RulerProvider;
46,46c45,45
< import org.eclipse.gef.ui.actions.SelectionAction;
---
> import org.eclipse.gef.ui.actions.DirectEditAction;
46a46,88
> import org.eclipse.gef.ui.actions.GEFActionConstants;
> import org.eclipse.gef.ui.parts.ContentOutlinePage;
> import org.eclipse.gef.ui.parts.GraphicalEditor;
> import org.eclipse.gef.ui.parts.ScrollingGraphicalViewer;
> import org.eclipse.gef.ui.parts.TreeViewer;
> import org.eclipse.gef.ui.rulers.RulerComposite;
> import org.eclipse.gmf.runtime.common.core.command.CommandManager;
> import org.eclipse.gmf.runtime.common.core.util.Log;
> import org.eclipse.gmf.runtime.common.core.util.Trace;
> import org.eclipse.gmf.runtime.common.ui.action.ActionManager;
> import org.eclipse.gmf.runtime.common.ui.services.editor.EditorService;
> import org.eclipse.gmf.runtime.common.ui.services.marker.MarkerNavigationService;
> import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
> import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
> import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
> import org.eclipse.gmf.runtime.diagram.ui.DiagramUIDebugOptions;
> import org.eclipse.gmf.runtime.diagram.ui.DiagramUIPlugin;
> import org.eclipse.gmf.runtime.diagram.ui.actions.ActionIds;
> import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.editparts.IDiagramPreferenceSupport;
> import org.eclipse.gmf.runtime.diagram.ui.internal.actions.InsertAction;
> import org.eclipse.gmf.runtime.diagram.ui.internal.actions.PromptingDeleteAction;
> import org.eclipse.gmf.runtime.diagram.ui.internal.actions.PromptingDeleteFromModelAction;
> import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DiagramRootTreeEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.TreeDiagramEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.TreeEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramUIPluginImages;
> import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.DefaultValues;
> import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper;
> import org.eclipse.gmf.runtime.diagram.ui.internal.parts.DiagramGraphicalViewerKeyHandler;
> import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;
> import org.eclipse.gmf.runtime.diagram.ui.internal.ruler.DiagramRuler;
> import org.eclipse.gmf.runtime.diagram.ui.internal.ruler.DiagramRulerProvider;
> import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
> import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
> import org.eclipse.gmf.runtime.diagram.ui.providers.DiagramContextMenuProvider;
> import org.eclipse.gmf.runtime.diagram.ui.services.editpart.EditPartService;
> import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
> import org.eclipse.gmf.runtime.notation.Diagram;
> import org.eclipse.gmf.runtime.notation.GuideStyle;
> import org.eclipse.gmf.runtime.notation.NotationPackage;
> import org.eclipse.gmf.runtime.notation.View;
47,47c89,89
< import org.eclipse.gef.ui.actions.StackAction;
---
> import org.eclipse.jface.action.Action;
48,51d89
< import org.eclipse.gef.ui.actions.WorkbenchPartAction;
< import org.eclipse.gef.ui.views.palette.PalettePage;
< import org.eclipse.gmf.runtime.lite.services.DefaultDiagramLayouter;
< import org.eclipse.gmf.runtime.lite.services.IDiagramLayouter;
52a91,101
> import org.eclipse.jface.action.IToolBarManager;
> import org.eclipse.jface.preference.IPreferenceStore;
> import org.eclipse.jface.preference.PreferenceStore;
> import org.eclipse.jface.util.Assert;
> import org.eclipse.jface.viewers.ISelection;
> import org.eclipse.jface.viewers.IStructuredSelection;
> import org.eclipse.swt.SWT;
> import org.eclipse.swt.SWTException;
> import org.eclipse.swt.events.DisposeEvent;
> import org.eclipse.swt.events.DisposeListener;
> import org.eclipse.swt.widgets.Canvas;
53a103,103
> import org.eclipse.swt.widgets.Control;
54,54c104,104
< import org.eclipse.ui.IEditorDescriptor;
---
> import org.eclipse.ui.IActionBars;
56,57d106
< import org.eclipse.ui.IEditorMatchingStrategy;
< import org.eclipse.ui.IEditorReference;
58,58c107,107
< import org.eclipse.ui.IEditorRegistry;
---
> import org.eclipse.ui.IWorkbenchPart;
58a108,108
> import org.eclipse.ui.IWorkbenchPartSite;
60a110,110
> import org.eclipse.ui.actions.ActionFactory;
61,61d109
< import org.eclipse.ui.PlatformUI;
62,62c111,111
< import org.eclipse.ui.part.EditorPart;
---
> import org.eclipse.ui.part.IPageSite;
62a112,114
> import org.eclipse.ui.part.IShowInSource;
> import org.eclipse.ui.part.PageBook;
> import org.eclipse.ui.part.ShowInContext;
64,64c116,116
< import org.eclipse.ui.views.properties.IPropertySheetPage;
---
> import org.eclipse.wst.common.ui.properties.internal.provisional.ITabbedPropertySheetPageContributor;
66a119,122
>  * @author melaasar
>  *
>  * A generic diagram editor with no palette.
>  * DiagramEditorWithPalette will provide a palette.
67,68d118
<  * This class serves as the base class for the generated diagram editors. 
<  * @author bblajer
69a124,126
> public abstract class DiagramEditor
> 	extends GraphicalEditor
> 	implements IDiagramWorkbenchPart, ITabbedPropertySheetPageContributor, IShowInSource {
70,72d123
< public abstract class DiagramEditor extends EditorPart implements IDiagramManager {
< 	private DiagramDisplayer myDiagramDisplayer;
< 	private boolean myIsDirty = false;
73a128,131
> 	/**
> 	 * teh ID of the outline
> 	 */
> 	protected static final int ID_OUTLINE = 0;
74,78d127
< 	private CommandStackListener commandStackListener = new CommandStackListener() {
< 		public void commandStackChanged(EventObject event) {
< 			setDirty(((CommandStack) event.getSource()).isDirty());
< 		}
< 	};
79a133,168
> 	/**
> 	 * the id of the over view
> 	 */
> 	protected static final int ID_OVERVIEW = 1;
> 
> 	/**
> 	 * the work space viewer preference store
> 	 */
> 	protected PreferenceStore workspaceViewerPreferenceStore = null;
> 
> 	/**
> 	 * A diagram outline page
> 	 */
> 	class DiagramOutlinePage
> 		extends ContentOutlinePage
> 		implements IAdaptable {
> 
> 		private PageBook pageBook;
> 
> 		private Control outline;
> 
> 		private Canvas overview;
> 
> 		private IAction showOutlineAction, showOverviewAction;
> 
> 		private boolean overviewInitialized;
> 
> 		private Thumbnail thumbnail;
> 
> 		private DisposeListener disposeListener;
> 
> 		/**
> 		 * @param viewer
> 		 */
> 		public DiagramOutlinePage(EditPartViewer viewer) {
> 			super(viewer);
80,84d132
< 	private CommandStackEventListener mySaveListener = new CommandStackEventListener() {
< 		public void stackChanged(CommandStackEvent event) {
< 			if (event.isPostChangeEvent() && isSaved()) {
< 				getCommandStack().markSaveLocation();
< 			}
85a170,187
> 
> 		/* (non-Javadoc)
> 		 * @see org.eclipse.ui.part.Page#init(org.eclipse.ui.part.IPageSite)
> 		 */
> 		public void init(IPageSite pageSite) {
> 			super.init(pageSite);
> 			ActionRegistry registry = getActionRegistry();
> 			IActionBars bars = pageSite.getActionBars();
> 			String id = ActionFactory.UNDO.getId();
> 			bars.setGlobalActionHandler(id, registry.getAction(id));
> 			id = ActionFactory.REDO.getId();
> 			bars.setGlobalActionHandler(id, registry.getAction(id));
> 			id = ActionFactory.DELETE.getId();
> 			bars.setGlobalActionHandler(id, registry.getAction(id));
> 			bars.updateActionBars();
> 
> 			// Toolbar refresh to solve linux defect RATLC525198 
> 			bars.getToolBarManager().markDirty();
86,89d169
< 		private boolean isSaved() {
< 			for(Resource next : getEditingDomain().getResourceSet().getResources()) {
< 				if (!next.isLoaded()) {
< 					continue;
90a189,201
> 
> 		/**
> 		 * configures the outline viewer
> 		 */
> 		protected void configureOutlineViewer() {
> 			getViewer().setEditDomain(getEditDomain());
> 			getViewer().setEditPartFactory(new EditPartFactory() {
> 
> 				public EditPart createEditPart(EditPart context, Object model) {
> 					if (model instanceof Diagram) {
> 						return new TreeDiagramEditPart(model);
> 					} else {
> 						return new TreeEditPart(model);
91,92d188
< 				if (!next.isTrackingModification() || next.isModified()) {
< 					return false;
94a204,224
> 			});
> 			// No support for a context menu on the outline view for
> 			// release 6.0.  See RATLC00529151, RATLC00529144
> 			// The selected item is a TreeEditPart which is not an
> 			// IGraphicalEditPart and many actions/commands don't support it
> //			ContextMenuProvider provider = new DiagramContextMenuProvider(
> //				DiagramEditor.this, getViewer());
> //			getViewer().setContextMenu(provider);
> //			this.getSite().registerContextMenu(
> //				ActionIds.DIAGRAM_OUTLINE_CONTEXT_MENU, provider,
> //				this.getSite().getSelectionProvider());
> 			
> 			getViewer().setKeyHandler(getKeyHandler());
> 			//getViewer().addDropTargetListener(
> 			//  new LogicTemplateTransferDropTargetListener(getViewer()));
> 			IToolBarManager tbm = this.getSite().getActionBars()
> 				.getToolBarManager();
> 			showOutlineAction = new Action() {
> 
> 				public void run() {
> 					showPage(ID_OUTLINE);
94a1060,1061
> 							}
> 						}
95a1063,1066
> 					}
> 				});
> 		}
> 		return Collections.EMPTY_LIST;
95,95c1062,1062
< 			return true;
---
> 						return retval;
97a227,229
> 			showOutlineAction.setImageDescriptor(DiagramUIPluginImages.DESC_OUTLINE);
> 			tbm.add(showOutlineAction);
> 			showOverviewAction = new Action() {
98a231,232
> 				public void run() {
> 					showPage(ID_OVERVIEW);
99,100d230
< 	protected void save(IProgressMonitor monitor) throws CoreException {
< 		myDiagramDisplayer.save(getSaveOptions(), monitor);
101a234,237
> 			};
> 			showOverviewAction.setImageDescriptor(DiagramUIPluginImages.DESC_OVERVIEW);
> 			tbm.add(showOverviewAction);
> 			showPage(getDefaultOutlineViewMode());
102,107d233
< 
< 	/**
< 	 * Returns the options with which the resources will be saved. Subclasses should override.
< 	 */
< 	protected Map<?, ?> getSaveOptions() {
< 		return Collections.emptyMap();
109a240,247
> 		public void createControl(Composite parent) {
> 			pageBook = new PageBook(parent, SWT.NONE);
> 			outline = getViewer().createControl(pageBook);
> 			overview = new Canvas(pageBook, SWT.NONE);
> 			pageBook.showPage(outline);
> 			configureOutlineViewer();
> 			hookOutlineViewer();
> 			initializeOutlineViewer();
110,111d239
< 	public final TransactionalEditingDomain getEditingDomain() {
< 		return myDiagramDisplayer.getEditingDomain();
113a250,253
> 		public void dispose() {
> 			unhookOutlineViewer();
> 			if (thumbnail != null) {
> 				thumbnail.deactivate();
114,115d249
< 	protected final EditDomain getEditDomain() {
< 		return myDiagramDisplayer.getEditDomain();
117,119d254
< 
< 	protected final CommandStack getCommandStack() {
< 		return getEditDomain().getCommandStack();
122,123d258
< 	protected final ZoomManager getZoomManager() {
< 		return myDiagramDisplayer.getZoomManager();
125a265,266
> 		public Control getControl() {
> 			return pageBook;
126,127d264
< 	protected final ActionRegistry getActionRegistry() {
< 		return myDiagramDisplayer.getActionRegistry();
129a269,273
> 		/**
> 		 * hook the outline viewer
> 		 */
> 		protected void hookOutlineViewer() {
> 			getSelectionSynchronizer().addViewer(getViewer());
130,131d268
< 	protected final GraphicalViewer getGraphicalViewer() {
< 		return myDiagramDisplayer.getGraphicalViewer();
133a276,286
> 		/**
> 		 * initialize the outline viewer
> 		 */
> 		protected void initializeOutlineViewer() {
> 			MEditingDomainGetter.getMEditingDomain(getDiagram()).runAsRead(new MRunnable() {
> 
> 				public Object run() {
> 					getViewer().setContents(getDiagram());
> 					return null;
> 				}
> 			});
134,135d275
< 	protected IPropertySheetPage getPropertySheetPage() {
< 		return myDiagramDisplayer.getPropertySheetPage();
137a289,311
> 		/**
> 		 * initialize the overview
> 		 */
> 		protected void initializeOverview() {
> 			LightweightSystem lws = new LightweightSystem(overview);
> 			RootEditPart rep = getGraphicalViewer().getRootEditPart();
> 			DiagramRootEditPart root = (DiagramRootEditPart) rep;
> 			thumbnail = new ScrollableThumbnail((Viewport) root.getFigure());
> 			//thumbnail.setSource(root.getLayer(LayerConstants.PRINTABLE_LAYERS));
> 			thumbnail.setSource(root.getLayer(LayerConstants.SCALABLE_LAYERS));
> 
> 			lws.setContents(thumbnail);
> 			disposeListener = new DisposeListener() {
> 
> 				public void widgetDisposed(DisposeEvent e) {
> 					if (thumbnail != null) {
> 						thumbnail.deactivate();
> 						thumbnail = null;
> 					}
> 				}
> 			};
> 			getEditor().addDisposeListener(disposeListener);
> 			this.overviewInitialized = true;
138,139d288
< 	protected IContentOutlinePage getOutlinePage() {
< 		return new DiagramContentOutlinePage(myDiagramDisplayer, getDefaultOutlineViewMode());
141a565,565
> 	protected ScrollingGraphicalViewer createScrollingGraphicalViewer() {
141a314,333
> 		/**
> 		 * show page with a specific ID, possibel values are 
> 		 * ID_OUTLINE and ID_OVERVIEW
> 		 * @param id
> 		 */
> 		protected void showPage(int id) {
> 			if (id == ID_OUTLINE) {
> 				showOutlineAction.setChecked(true);
> 				showOverviewAction.setChecked(false);
> 				pageBook.showPage(outline);
> 				if (thumbnail != null)
> 					thumbnail.setVisible(false);
> 			} else if (id == ID_OVERVIEW) {
> 				if (!overviewInitialized)
> 					initializeOverview();
> 				showOutlineAction.setChecked(false);
> 				showOverviewAction.setChecked(true);
> 				pageBook.showPage(overview);
> 				thumbnail.setVisible(true);
> 			}
142,142d564
< 	protected IDiagramLayouter getDiagramLayouter() {
143,143c566,566
< 		return new DefaultDiagramLayouter();
---
> 		return new DiagramGraphicalViewer();
146a356,376
> 	/** The key handler */
> 	private KeyHandler keyHandler;
> 
> 	/** The workbench site
> 	 *  This variable overrides another one defined in <code>org.eclipse.ui.part<code>
> 	 *  This is needed to override <code>setSite</code> to simply set the site, rather than also
> 	 *  initializing the actions like <code>setSite</code> override in <code>org.eclipse.gef.ui.parts</code>
> 	 */
> 	private IWorkbenchPartSite partSite;
> 
> 	/** The RulerComposite used to enhance the graphical viewer to display
> 	 *  rulers
> 	 */
> 	private RulerComposite rulerComposite;
> 
> 	/**
> 	 * Returns this editor's outline-page default display mode. 
> 	 * @return int the integer value indicating the content-outline-page dispaly mode 
> 	 */
> 	protected int getDefaultOutlineViewMode() {
> 		return ID_OVERVIEW;
146a337,337
> 		 * unhook the outline viewer
147,149d355
< 	 * Returns the initial display mode for the outline page to be shown. Possible values are <code>DiagramContentOutlinePage.ID_OUTLINE</code> and 
< 	 * <code>DiagramContentOutlinePage.ID_OVERVIEW</code>.
< 	 * By default, the outline page starts in the overview mode. Subclasses may reimplement.
150a339,343
> 		protected void unhookOutlineViewer() {
> 			getSelectionSynchronizer().removeViewer(getViewer());
> 			if (disposeListener != null && getEditor() != null
> 				&& !getEditor().isDisposed())
> 				getEditor().removeDisposeListener(disposeListener);
151,152d338
< 	protected int getDefaultOutlineViewMode() {
< 		return DiagramContentOutlinePage.ID_OVERVIEW;
154a346,351
> 		/**
> 		 * getter for the editor conrolo
> 		 * @return <code>Control</code>
> 		 */
> 		protected Control getEditor() {
> 			return getGraphicalViewer().getControl();
155,158d345
< 	@Override
< 	public boolean isSaveAsAllowed() {
< 		// TODO: should be allowed.
< 		return false;
161,163d353
< 	@Override
< 	public void doSaveAs() {
< 		// TODO: Implement.
166,171d355
< 	@Override
< 	public void init(IEditorSite site, IEditorInput input) throws PartInitException {
< 		setSite(site);
< 		TransactionalEditingDomain editingDomain = getEditingDomain(input);
< 		if (editingDomain == null) {
< 			editingDomain = reuseEditingDomain(input);
172a378,383
> 
> 	/**
> 	 * @return Returns the rulerComp.
> 	 */
> 	protected RulerComposite getRulerComposite() {
> 		return rulerComposite;
173,174d377
< 		if (editingDomain == null) {
< 			editingDomain = createEditingDomain();
175a385,390
> 
> 	/**
> 	 * @param rulerComp The rulerComp to set.
> 	 */
> 	protected void setRulerComposite(RulerComposite rulerComp) {
> 		this.rulerComposite = rulerComp;
176,179d384
< 		ForceTrackingModificationAdapter adapter = (ForceTrackingModificationAdapter) EcoreUtil.getExistingAdapter(editingDomain.getResourceSet(), ForceTrackingModificationAdapter.class);
< 		if (adapter == null) {
< 			adapter = new ForceTrackingModificationAdapter();
< 			editingDomain.getResourceSet().eAdapters().add(adapter);
180a392,396
> 	/**
> 	 * Creates a new DiagramEditor instance
> 	 */
> 	public DiagramEditor() {
> 		createDiagramEditDomain();
181,185d391
< 		adapter.acquire();
< 		myDiagramDisplayer = new DiagramDisplayer(this, createEditDomain(), editingDomain);
< 		getCommandStack().addCommandStackListener(commandStackListener);
< 		getCommandStack().addCommandStackEventListener(mySaveListener);
< 		setInput(input);
187a399,403
> 	/**
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramEditDomain()
> 	 */
> 	public IDiagramEditDomain getDiagramEditDomain() {
> 		return (IDiagramEditDomain) getEditDomain();
188,197d398
< 	@Override
< 	public void dispose() {
< 		if (myDiagramDisplayer != null) {
< 			getCommandStack().removeCommandStackEventListener(mySaveListener);
< 			getCommandStack().removeCommandStackListener(commandStackListener);
< 			ForceTrackingModificationAdapter adapter = (ForceTrackingModificationAdapter) EcoreUtil.getExistingAdapter(getEditingDomain().getResourceSet(), ForceTrackingModificationAdapter.class);
< 			if (adapter != null) {
< 				adapter.release();
< 				if (adapter.isReleased()) {
< 					getEditingDomain().getResourceSet().eAdapters().remove(adapter);
198a405,410
> 
> 	/**
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramGraphicalViewer()
> 	 */
> 	public IDiagramGraphicalViewer getDiagramGraphicalViewer() {
> 		return (IDiagramGraphicalViewer) getGraphicalViewer();
199a412,419
> 
> 	/**
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagram()
> 	 */
> 	public Diagram getDiagram() {
> 		if (getEditorInput() != null)
> 			return ((IDiagramEditorInput) getEditorInput()).getDiagram();
> 		return null;
200,201d411
< 			myDiagramDisplayer.dispose();
< 			myDiagramDisplayer = null;
202a421,426
> 
> 	/**
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramEditPart()
> 	 */
> 	public DiagramEditPart getDiagramEditPart() {
> 		return (DiagramEditPart) getDiagramGraphicalViewer().getContents();
202a255,255
> 			this.overviewInitialized = false;
203,203c256,256
< 		super.dispose();
---
> 			super.dispose();
205a429,431
> 	/**
> 	 * @see org.eclipse.core.runtime.IAdaptable#getAdapter(Class)
> 	 */
206,206d428
< 	@Override
208,209d432
< 		if (type == IPropertySheetPage.class) {
< 			return getPropertySheetPage();
210a434,443
> 			TreeViewer viewer = new TreeViewer();
> 			viewer.setRootEditPart(new DiagramRootTreeEditPart());
> 			return new DiagramOutlinePage(viewer);
> 		}
> 		if (type == CommandManager.class)
> 			return getCommandManager();
> 		if (ActionManager.class == type)
> 			return getActionManager();
> 		if (IDiagramEditDomain.class == type)
> 			return getDiagramEditDomain();
210,210c433,433
< 		} else if (type == IContentOutlinePage.class) {
---
> 		if (type == IContentOutlinePage.class) {
211,211d433
< 			return getOutlinePage();
212,212c444,444
< 		} else if (type == ZoomManager.class) {
---
> 		if (type == ZoomManager.class)
213a259,260
> 		public Object getAdapter(Class type) {
> 			//	if (type == ZoomManager.class)
214,220d258
< 		} else if (type == IDiagramLayouter.class) {
< 			return getDiagramLayouter();
< 		} else if (type == PalettePage.class) {
< 			return myDiagramDisplayer.getPalettePage();
< 		} else if (type == GraphicalViewer.class) {
< 			return getGraphicalViewer();
< 		} else if (type == CommandStack.class) {
221,221c261,261
< 			return getCommandStack();
---
> 			//		return getZoomManager();
222,222d261
< 		} else if (type == ActionRegistry.class) {
223,223c262,262
< 			return getActionRegistry();
---
> 			return null;
224,228d262
< 		} else if (type == EditPart.class && getGraphicalViewer() != null) {
< 			return getGraphicalViewer().getRootEditPart();
< 		} else if (type == IFigure.class && getGraphicalViewer() != null) {
< 			return ((GraphicalEditPart)getGraphicalViewer().getRootEditPart()).getFigure();
< 		}
229a447,447
> 
231a450,464
> 	/**
> 	 * @see org.eclipse.ui.IEditorPart#init(IEditorSite, IEditorInput)
> 	 */
> 	public void init(IEditorSite site, IEditorInput input)
> 		throws PartInitException {
> 		try {
> 			super.init(site, input);
> 			EditorService.getInstance().registerEditor(this);
> 		} catch (Exception e) {
> 			//	RATLC 524435
> 			//	As discussed with Steve, Removing the Log and removing the 
> 			//	standard message and replacing it with one obtained from the
> 			//	Exception.
> 			Trace.catching(DiagramUIPlugin.getInstance(), DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(), "init", e); //$NON-NLS-1$
> 			throw new PartInitException(e.getMessage(), e);
232,235d449
< 	private void setDirty(boolean isDirty) {
< 		if (isDirty != myIsDirty) {
< 			myIsDirty = isDirty;
< 			firePropertyChange(PROP_DIRTY);
238a468,491
> 	/**
> 	 * Disposes this editor by:
> 	 * <br> 3. Stops all registered listeners
> 	 * @see org.eclipse.ui.IWorkbenchPart#dispose()
> 	 */
> 	public void dispose() {
> 		persistViewerSettings();
> 		EditorService.getInstance().unregisterEditor(DiagramEditor.this);
> 		stopListening();
> 
> 		/*
> 		 * RATLC00527385 DiagramRulerProvider wasn't uninitialized on dispose of the editor.
> 		 */
> 		DiagramRulerProvider vertProvider = (DiagramRulerProvider) getDiagramGraphicalViewer()
> 			.getProperty(RulerProvider.PROPERTY_VERTICAL_RULER);
> 		if (vertProvider != null)
> 			vertProvider.uninit();
> 
> 		// Set the Horizontal Ruler properties
> 		DiagramRulerProvider horzProvider = (DiagramRulerProvider) getDiagramGraphicalViewer()
> 			.getProperty(RulerProvider.PROPERTY_HORIZONTAL_RULER);
> 		if (horzProvider != null)
> 			horzProvider.uninit();
> 		super.dispose();
239,241d467
< 	@Override
< 	public boolean isDirty() {
< 		return myIsDirty;
244a706,709
> 	 * Gets the action manager for this diagram editor. The action manager's 
> 	 * command manager is used by my edit domain's command stack when executing
> 	 * commands. This is the action manager that is returned when I am asked
> 	 * to adapt to an <code>ActionManager</code>.
244a495,497
> 	 * Returns the KeyHandler with common bindings for both the Outline and Graphical Views.
> 	 * For example, delete is a common action.
> 	 * @return KeyHandler
245,246d705
< 	 * Adds an action to this editor's <code>ActionRegistry</code>. (This is
< 	 * a helper method.)
247,247c710,710
< 	 * 
---
> 	 * 
248,248d710
< 	 * @param action
249,249c711,711
< 	 *            the action to add.
---
> 	 * @return the action manager
250a499,539
> 	protected KeyHandler getKeyHandler() {
> 		if (keyHandler == null) {
> 			keyHandler = new KeyHandler();
> 
> 			ActionRegistry registry = getActionRegistry();
> 			IAction action;
> 
> 			action = new PromptingDeleteAction(this);
> 			action.setText(DiagramUIMessages.DiagramEditor_Delete_from_Diagram); 
> 			registry.registerAction(action);
> 			getSelectionActions().add(action.getId());
> 
> 			action = new InsertAction(this);
> 			action.setText(""); //$NON-NLS-1$ // no text necessary since this is not a visible action
> 			registry.registerAction(action);
> 			getSelectionActions().add(action.getId());
> 
> 			PromptingDeleteFromModelAction deleteModelAction = new PromptingDeleteFromModelAction(
> 				this);
> 			deleteModelAction.init();
> 
> 			registry.registerAction(deleteModelAction);
> 
> 			action = new DirectEditAction((IWorkbenchPart) this);
> 			registry.registerAction(action);
> 			getSelectionActions().add(action.getId());
> 
> 			keyHandler.put(KeyStroke.getPressed(SWT.INSERT, 0),
> 				getActionRegistry().getAction(InsertAction.ID));
> 			keyHandler.put(KeyStroke.getPressed(SWT.DEL, 127, 0),
> 				getActionRegistry().getAction(ActionFactory.DELETE.getId()));
> 			keyHandler.put(KeyStroke.getPressed(SWT.BS, 8, 0),
> 				getActionRegistry().getAction(ActionFactory.DELETE.getId()));
> 			keyHandler.put(/* CTRL + D */
> 			KeyStroke.getPressed((char) 0x4, 100, SWT.CTRL),
> 				getActionRegistry().getAction(
> 					ActionIds.ACTION_DELETE_FROM_MODEL));
> 			keyHandler.put(KeyStroke.getPressed(SWT.F2, 0), getActionRegistry()
> 				.getAction(GEFActionConstants.DIRECT_EDIT));
> 		}
> 		return keyHandler;
251,252d498
< 	protected void addAction(IAction action) {
< 		myDiagramDisplayer.addAction(action);
255a543,543
> 	 * @see org.eclipse.gef.ui.parts.GraphicalEditor#createGraphicalViewer(Composite)
256,262d542
< 	 * Adds an editor action to this editor.
< 	 * 
< 	 * <p>
< 	 * Editor actions are actions that depend and work on the editor.
< 	 * 
< 	 * @param action
< 	 *            the editor action
263a545,555
> 	protected void createGraphicalViewer(Composite parent) {
> 		setRulerComposite(new RulerComposite(parent, SWT.NONE));
> 
> 		ScrollingGraphicalViewer sGViewer = createScrollingGraphicalViewer();					
> 		sGViewer.createControl(getRulerComposite());
> 		setGraphicalViewer(sGViewer);
> 		hookGraphicalViewer();
> 		configureGraphicalViewer();
> 		initializeGraphicalViewer(); 
> 		getRulerComposite()
> 			.setGraphicalViewer((ScrollingGraphicalViewer) getGraphicalViewer());
264,265d544
< 	protected void addEditorAction(WorkbenchPartAction action) {
< 		myDiagramDisplayer.addEditorAction(action);
268a559,561
> 	 * Creates a ScrollingGraphicalViewer without the drop adapter which  
> 	 * excludes drag and drop functionality from other defined views (XML)
> 	 * Subclasses must override this method to include the DnD functionality
269,269d558
< 	 * Adds an <code>EditPart</code> action to this editor.
271,276d562
< 	 * <p>
< 	 * <code>EditPart</code> actions are actions that depend and work on the
< 	 * selected <code>EditPart</code>s.
< 	 * 
< 	 * @param action
< 	 *            the <code>EditPart</code> action
278,279d564
< 	protected void addEditPartAction(SelectionAction action) {
< 		myDiagramDisplayer.addEditPartAction(action);
282a570,570
> 	 * Configures the graphical viewer (the primary viewer of the editor)
283,290d569
< 	 * Adds an <code>CommandStack</code> action to this editor.
< 	 * 
< 	 * <p>
< 	 * <code>CommandStack</code> actions are actions that depend and work on
< 	 * the <code>CommandStack</code>.
< 	 * 
< 	 * @param action
< 	 *            the <code>CommandStack</code> action
291a572,573
> 	protected void configureGraphicalViewer() {
> 		super.configureGraphicalViewer();
292,294d571
< 	protected void addStackAction(StackAction action) {
< 		myDiagramDisplayer.addStackAction(action);
< 	}
295a575,600
> 		IDiagramGraphicalViewer viewer = getDiagramGraphicalViewer();
> 		
> 		RootEditPart rootEP = EditPartService.getInstance()
> 			.createRootEditPart(getDiagram());
> 		if (rootEP instanceof IDiagramPreferenceSupport) {
> 			((IDiagramPreferenceSupport) rootEP)
> 				.setPreferencesHint(getPreferencesHint());
> 		}
> 
> 		if (getDiagramGraphicalViewer() instanceof DiagramGraphicalViewer) {
> 			((DiagramGraphicalViewer) getDiagramGraphicalViewer())
> 				.hookWorkspacePreferenceStore(getWorkspaceViewerPreferenceStore());
> 		}
> 
> 		viewer.setRootEditPart(rootEP);
> 		
> 		viewer.setEditPartFactory(EditPartService.getInstance());
> 		ContextMenuProvider provider = new DiagramContextMenuProvider(this,
> 			viewer);
> 		viewer.setContextMenu(provider);
> 		getSite().registerContextMenu(ActionIds.DIAGRAM_EDITOR_CONTEXT_MENU,
> 			provider, viewer);
> 		viewer.setKeyHandler(new DiagramGraphicalViewerKeyHandler(viewer)
> 			.setParent(getKeyHandler()));
> 		((FigureCanvas) viewer.getControl())
> 			.setScrollBarVisibility(FigureCanvas.ALWAYS);
296,299d574
< 	@Override
< 	public void createPartControl(Composite parent) {
< 		myDiagramDisplayer.createViewer(parent);
< 		createActions();
301a603,607
> 	/**
> 	 * @see org.eclipse.gef.ui.parts.GraphicalEditor#initializeGraphicalViewer()
> 	 */
> 	protected void initializeGraphicalViewer() {
> 		initializeGraphicalViewerContents();
302,304d602
< 	@Override
< 	public void setFocus() {
< 		myDiagramDisplayer.setFocus();
307a611,611
> 	 * @see org.eclipse.gef.ui.parts.GraphicalEditor#initializeGraphicalViewer()
308,310d610
< 	 * Returns the editing domain instance to be used for the specified input. If this method returns <code>null</code>, 
< 	 * a {@link #createEditDomain() default instance} will be created and used.
< 	 * By default, return <code>null</code>. Subclasses may reimplement.
311a613,615
> 	protected void initializeGraphicalViewerContents() {
> 		getDiagramGraphicalViewer().setContents(getDiagram());
> 		initializeContents(getDiagramEditPart());
312,315d612
< 	protected TransactionalEditingDomain getEditingDomain(IEditorInput input) {
< 		if (input instanceof DiagramEditorInput) {
< 			TransactionalEditingDomain result = TransactionUtil.getEditingDomain(((DiagramEditorInput) input).getDiagram());
< 			return result;
316a563,563
> 	 * @return ScrollingGraphicalViewer
316a617,623
> 
> 	/**
> 	 * Creates a diagram edit domain
> 	 */
> 	protected void createDiagramEditDomain() {
> 		setEditDomain(new DiagramEditDomain(this));
> 		configureDiagramEditDomain();
317,317d562
< 		return null;
320a627,631
> 	 * Configures a diagram edit domain
> 	 */
> 	protected void configureDiagramEditDomain() {
> 		getEditDomain().setCommandStack(
> 			new DiagramCommandStack(getDiagramEditDomain()));
321,334d626
< 	 * Returns the editing domain that is used by other editors with the same input. This is done to correctly support 
< 	 * "New Editor" operation that is available in the context menu of the editor tab.
< 	 * @return
< 	 */
< 	protected TransactionalEditingDomain reuseEditingDomain(IEditorInput input) {
< 		IEditorRegistry editorRegistry = PlatformUI.getWorkbench().getEditorRegistry();
< 		IEditorDescriptor editorDesc = editorRegistry.findEditor(getSite().getId());
< 		IEditorMatchingStrategy matchingStrategy = editorDesc.getEditorMatchingStrategy();
< 		IEditorReference[] editorRefs = getEditorSite().getPage().getEditorReferences();
< 		for (int i = 0; i < editorRefs.length; i++) {
< 			if (matches(matchingStrategy, editorRefs[i], input)) {
< 				DiagramEditor anotherEditor = (DiagramEditor) editorRefs[i].getEditor(false);
< 				if (anotherEditor != null) {
< 					return anotherEditor.getEditingDomain();
335a633,641
> 
> 	/**
> 	 * @see org.eclipse.ui.part.EditorPart#setInput(IEditorInput)
> 	 */
> 	protected void setInput(IEditorInput input) {
> 		stopListening();
> 		super.setInput(input);
> 		if(input != null) {
> 			Assert.isNotNull(getDiagram(), "Couldn't load/create diagram view"); //$NON-NLS-1$
336a643,644
> 		startListening();
> 
337a890,890
> 			return workspaceViewerPreferenceStore;
337a646,652
> 
> 	/** 
> 	 * Do nothing
> 	 * @see org.eclipse.gef.ui.parts.GraphicalEditor#initializeActionRegistry()
> 	 */
> 	protected void createActions() {
> 		// null impl.
338,338d889
< 		return null;
340a655,666
> 	/**
> 	 * A utility to close the editor
> 	 * @param save
> 	 */
> 	protected void closeEditor(final boolean save) {
> 		// Make this call synchronously to avoid the following sequence:
> 		// Select me, select the model editor, close the model editor, 
> 		// closes the model, fires events causing me to close, 
> 		// if actual close is delayed using an async call then eclipse 
> 		// tries to set the selection back to me when the model editor
> 		// finishes being disposed, but model has been closed so I
> 		// am no longer connected to the model, NullPointerExceptions occur.
341,343d654
< 	private boolean matches(IEditorMatchingStrategy strategy, IEditorReference editorRef, IEditorInput input) {
< 		if (strategy == null) {
< 			if (getSite().getId().equals(editorRef.getId())) {
344a668,677
> 			getSite().getPage().closeEditor(DiagramEditor.this, save);
> 		} catch (SWTException e) {
> 			// TODO remove when "Widget is disposed" exceptions are fixed.
> 			// Temporarily catch SWT exceptions here to allow model server event
> 			// processing to continue.
> 			Trace.catching(DiagramUIPlugin.getInstance(),
> 				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, this.getClass(),
> 				"closeEditor", e); //$NON-NLS-1$
> 			Log.error(DiagramUIPlugin.getInstance(), IStatus.ERROR, e
> 				.getMessage(), e);
345,347d667
< 					return input.equals(editorRef.getEditorInput());
< 				} catch (PartInitException e) {
< 					return false;
349a680,692
> 
> 	/**
> 	 * Installs all the listeners needed by the editor
> 	 */
> 	protected void startListening() {
> 		// do nothing
> 	}
> 
> 	/**
> 	 * Removes all the listeners used by the editor
> 	 */
> 	protected void stopListening() {
> 		// do nothing		
350,352d679
< 			return false;
< 		} else {
< 			return strategy.matches(editorRef, input);
353a694,702
> 
> 	/**
> 	 * Clears the contents of the graphical viewer
> 	 */
> 	protected void clearGraphicalViewerContents() {
> 		if (getDiagramGraphicalViewer().getContents() != null) {
> 			getDiagramGraphicalViewer().getContents().removeNotify();
> 		}
> 		getDiagramGraphicalViewer().setContents(null);
357,358d705
< 	 * Returns the editing domain instance to be used for the diagram if none may be {@link #getEditingDomain(IEditorInput) inferred} from the input.
< 	 * Subclasses may extend or reimplement.
359a713,714
> 	protected ActionManager getActionManager() {
> 		return getDiagramEditDomain().getActionManager();
360,363d712
< 	protected TransactionalEditingDomain createEditingDomain() {
< 		TransactionalEditingDomain editingDomain = WorkspaceEditingDomainFactory.INSTANCE.createEditingDomain();
< 		editingDomain.getResourceSet().eAdapters().add(new AdapterFactoryEditingDomain.EditingDomainProvider(editingDomain));
< 		return editingDomain;
365a717,722
> 	/**
> 	 * A utility method to return the zoom manager from the graphical viewer's root
> 	 * @return the zoom manager
> 	 */
> 	protected ZoomManager getZoomManager() {
> 		return ((DiagramRootEditPart) getRootEditPart()).getZoomManager();
366,367d716
< 	public void configureGraphicalViewer() {
< 		getGraphicalViewer().getControl().setBackground(ColorConstants.listBackground);
369a725,726
> 	private RootEditPart getRootEditPart() {
> 		return getGraphicalViewer().getRootEditPart();		
370,372d724
< 	protected double[] getZoomLevels() {
< 		double[] result = {.05, .1, .25, .5, .75, 1, 1.25, 1.5, 1.75, 2, 4};
< 		return result;
374a729,738
> 	/**
> 	 * Convenience method to access the command manager associated with my
> 	 * action manager. This command manager is used by my edit domain's 
> 	 * command stack when executing commands.
> 	 * 
> 	 * @return the command manager
> 	 */
> 	protected CommandManager getCommandManager() {
> 		return getActionManager().getCommandManager();
> 	}
375,375d728
< 	public abstract void configurePalette(PaletteRoot paletteRoot);
377a741,742
> 	 * go to a specific marker
> 	 * @param marker marker to use
378,379d740
< 	 * Creates edit domain that will be used for the editor. 
< 	 * Subclasses may extend.
380a744,745
> 	public final void gotoMarker(IMarker marker) {
> 		MarkerNavigationService.getInstance().gotoMarker(this, marker);
381,383d743
< 	protected EditDomain createEditDomain() {
< 		DefaultEditDomain domain = new DefaultEditDomain(this);
< 		return domain;
385a748,753
> 	/**
> 	 * 
> 	 * @return The getRulerComposite(), which is the graphical control
> 	 */
> 	protected Control getGraphicalControl() {
> 		return getRulerComposite();
386,386d747
< 	public abstract void initializeGraphicalViewer();
387a755,755
> 	}
388,388d754
< 	public abstract AdapterFactory getDomainAdapterFactory();
389a757,762
> 	/**
> 	 * @see org.eclipse.ui.IWorkbenchPart#getSite()
> 	 */
> 	public IWorkbenchPartSite getSite() {
> 		return partSite;
> 	}
390,390d756
< 	public abstract boolean isFlyoutPalette();
391a764,768
> 	/**
> 	 * @see org.eclipse.ui.part.WorkbenchPart#setSite(IWorkbenchPartSite)
> 	 */
> 	protected void setSite(IWorkbenchPartSite site) {
> 		this.partSite = site;
392,392d763
< 	protected abstract void createActions();
394,401d769
< 	private static class ForceTrackingModificationAdapter extends AdapterImpl {
< 		@Override
< 		public void setTarget(Notifier newTarget) {
< 			super.setTarget(newTarget);
< 			if (newTarget instanceof ResourceSet) {
< 				ResourceSet resourceSet = (ResourceSet) newTarget;
< 				for(Resource next : resourceSet.getResources()) {
< 					next.setTrackingModification(true);
402a771,776
> 
> 	/* (non-Javadoc)
> 	 * @see org.eclipse.gmf.runtime.common.ui.properties.ITabbedPropertySheetPageContributor#getContributorId()
> 	 */
> 	public String getContributorId() {
> 		return "org.eclipse.gmf.runtime.diagram.ui.properties"; //$NON-NLS-1$
403a778,859
> 
> 	/**
> 	 * Adds the default preferences to the specified preference store.
> 	 * @param store store to use
> 	 * @param preferencesHint
> 	 *            The preference hint that is to be used to find the appropriate
> 	 *            preference store from which to retrieve diagram preference
> 	 *            values. The preference hint is mapped to a preference store in
> 	 *            the preference registry <@link DiagramPreferencesRegistry>.
> 	 */
> 	public static void addDefaultPreferences(PreferenceStore store, PreferencesHint preferencesHint) {
> 		store.setValue(WorkspaceViewerProperties.ZOOM, 1.0);
> 		store.setValue(WorkspaceViewerProperties.VIEWPAGEBREAKS, false);
> 
> 		IPreferenceStore globalPreferenceStore = (IPreferenceStore) preferencesHint.getPreferenceStore();
> 
> 		// Initialize with the global settings
> 		boolean viewGrid = globalPreferenceStore
> 			.getBoolean(IPreferenceConstants.PREF_SHOW_GRID);
> 
> 		boolean snapToGrid = globalPreferenceStore
> 			.getBoolean(IPreferenceConstants.PREF_SNAP_TO_GRID);
> 
> 		boolean viewRulers = globalPreferenceStore
> 			.getBoolean(IPreferenceConstants.PREF_SHOW_RULERS);
> 
> 		// Set defaults for Grid
> 		store.setValue(WorkspaceViewerProperties.VIEWGRID, viewGrid);
> 		store.setValue(WorkspaceViewerProperties.SNAPTOGRID, snapToGrid);
> 
> 		// Set defaults for Rulers
> 		store.setValue(WorkspaceViewerProperties.VIEWRULERS, viewRulers);
> 
> 		// Set defaults for Page Setup Dialog
> 		//PSDialog.initDefaultPreferences(store);
> 		
> 		//PSDefault.initDefaultPSPreferencePagePreferences(globalPreferenceStore);
> 		
> 		//String pageType = PageInfoHelper.getPrinterPageType();
> 		//String pageSize = PageInfoHelper.getLocaleSpecificPageType();
> 		//Point2D.Double point = (Point2D.Double) nnn.getPaperSizesInInchesMap().get(pageSize);
> 		
> 		//double[] marginSizes = nnn.getDefaultMarginSizes();
> 		
> 		//store.setValue(WorkspaceViewerProperties.USE_WORKSPACE_PRINT_SETTINGS, true);
> 		//store.setValue(WorkspaceViewerProperties.USE_DIAGRAM_PRINT_SETTINGS, false);
> 		
> 		//store.setValue(WorkspaceViewerProperties.USE_INCHES, true);
> 		//store.setValue(WorkspaceViewerProperties.USE_MILLIMETRES, false);
> 		
> 		//store.setValue(WorkspaceViewerProperties.PAGE_ORIENTATION_LANDSCAPE, false);
> 		//store.setValue(WorkspaceViewerProperties.PAGE_ORIENTATION_PORTRAIT, true);
> 		
> 		//store.setValue(WorkspaceViewerProperties.PAGE_TYPE, pageSize);
> 		
> 		//store.setValue(WorkspaceViewerProperties.PAGE_WIDTH, point.x);
> 		//store.setValue(WorkspaceViewerProperties.PAGE_HEIGHT, point.y);
> 		
> 		//store.setValue(WorkspaceViewerProperties.MARGIN_LEFT, marginSizes[0]);
> 		//store.setValue(WorkspaceViewerProperties.MARGIN_TOP, marginSizes[1]);
> 		//store.setValue(WorkspaceViewerProperties.MARGIN_RIGHT, marginSizes[2]);
> 		//store.setValue(WorkspaceViewerProperties.MARGIN_BOTTOM, marginSizes[3]);
> 		
> 		// Initialize printing defaults
> 		store.setValue(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS, DefaultValues.DEFAULT_USE_WORKSPACE_SETTINGS);
> 		store.setValue(WorkspaceViewerProperties.PREF_USE_DIAGRAM_SETTINGS, DefaultValues.DEFAULT_USE_DIAGRAM_SETTINGS);
> 			
> 		store.setValue(WorkspaceViewerProperties.PREF_USE_INCHES, DefaultValues.DEFAULT_INCHES);
> 		store.setValue(WorkspaceViewerProperties.PREF_USE_MILLIM, DefaultValues.DEFAULT_MILLIM);
> 		
> 		store.setValue(WorkspaceViewerProperties.PREF_USE_PORTRAIT, DefaultValues.DEFAULT_PORTRAIT);
> 		store.setValue(WorkspaceViewerProperties.PREF_USE_LANDSCAPE, DefaultValues.DEFAULT_LANDSCAPE);
> 		
> 		store.setValue(WorkspaceViewerProperties.PREF_PAGE_SIZE, DefaultValues.getLocaleSpecificPageType().getName());
> 		store.setValue(WorkspaceViewerProperties.PREF_PAGE_WIDTH, DefaultValues.getLocaleSpecificPageType().getWidth());
> 		store.setValue(WorkspaceViewerProperties.PREF_PAGE_HEIGHT, DefaultValues.getLocaleSpecificPageType().getHeight());
> 		
> 		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_TOP, DefaultValues.DEFAULT_MARGIN_TOP);
> 		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_BOTTOM, DefaultValues.DEFAULT_MARGIN_BOTTOM);
> 		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_LEFT, DefaultValues.DEFAULT_MARGIN_LEFT);
> 		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_RIGHT, DefaultValues.DEFAULT_MARGIN_RIGHT);
> 		
405a862,888
> 	/**
> 	 * Returns the workspace viewer <code>PreferenceStore</code>
> 	 * @return	the workspace viewer <code>PreferenceStore</code>
> 	 */
> 	public PreferenceStore getWorkspaceViewerPreferenceStore() {
> 		if (workspaceViewerPreferenceStore != null) {
> 			return workspaceViewerPreferenceStore;
> 		} else {
> 			// Try to load it
> 			IPath path = DiagramUIPlugin.getInstance()
> 				.getStateLocation();
> 			String id = ViewUtil.getIdStr(getDiagram());
> 
> 			String fileName = path.toString() + "/" + id;//$NON-NLS-1$
> 			java.io.File file = new File(fileName);
> 			workspaceViewerPreferenceStore = new PreferenceStore(fileName);
> 			if (file.exists()) {
> 				// Load it
> 				try {
> 					workspaceViewerPreferenceStore.load();
> 				} catch (Exception e) {
> 					// Create the default
> 					addDefaultPreferences();
> 				}
> 			} else {
> 				// Create it
> 				addDefaultPreferences();
406,413d861
< 		@Override
< 		public void notifyChanged(Notification msg) {
< 			if (msg.getNotifier() == getTarget() && msg.getFeatureID(ResourceSet.class) == ResourceSet.RESOURCE_SET__RESOURCES) {
< 				switch (msg.getEventType()) {
< 				case Notification.ADD:
< 				{
< 					Resource resource = (Resource) msg.getNewValue();
< 					resource.setTrackingModification(true);
415,420d889
< 				break;
< 				case Notification.ADD_MANY:
< 				{
< 					@SuppressWarnings("unchecked") Collection<Resource> resources = (Collection<Resource>) msg.getNewValue();
< 					for(Resource next : resources) {
< 						next.setTrackingModification(true);
422a893,898
> 
> 	/**
> 	 * Adds the default preferences to the workspace viewer preference store.
> 	 */
> 	protected void addDefaultPreferences() {
> 		addDefaultPreferences(workspaceViewerPreferenceStore, getPreferencesHint());
423a900,913
> 
> 	/**
> 	 * Persists the viewer settings to which this RootEditPart belongs. This method should
> 	 * be called when the diagram is being disposed.
> 	 */
> 	public void persistViewerSettings() {
> 		Viewport viewport = getDiagramEditPart().getViewport();
> 		if (viewport != null) {
> 			int x = viewport.getHorizontalRangeModel().getValue();
> 			int y = viewport.getVerticalRangeModel().getValue();
> 			getWorkspaceViewerPreferenceStore().setValue(
> 				WorkspaceViewerProperties.VIEWPORTX, x);
> 			getWorkspaceViewerPreferenceStore().setValue(
> 				WorkspaceViewerProperties.VIEWPORTY, y);
424a915,926
> 		getWorkspaceViewerPreferenceStore().setValue(
> 			WorkspaceViewerProperties.ZOOM, getZoomManager().getZoom());
> 
> 		// Write the settings, if necessary
> 		try {
> 			if (getWorkspaceViewerPreferenceStore().needsSaving())
> 				getWorkspaceViewerPreferenceStore().save();
> 		} catch (IOException ioe) {
> 			Trace.catching(DiagramUIPlugin.getInstance(),
> 				DiagramUIDebugOptions.EXCEPTIONS_CATCHING,
> 				PageInfoHelper.class, "persistViewerSettings", //$NON-NLS-1$
> 				ioe);
426,428d927
< 		@Override
< 		public boolean isAdapterForType(Object type) {
< 			return ForceTrackingModificationAdapter.class.equals(type);
429a929,1025
> 
> 
> 	/**
> 	 * Initializes the viewer's state from the workspace preference store.
> 	 * @param editpart
> 	 */
> 	private void initializeContents(EditPart editpart) {
> 		getZoomManager().setZoom(
> 			getWorkspaceViewerPreferenceStore().getDouble(
> 				WorkspaceViewerProperties.ZOOM));
> 
> 		if (getWorkspaceViewerPreferenceStore().getBoolean(WorkspaceViewerProperties.VIEWPAGEBREAKS)) {
> 			getDiagramEditPart().getFigure().invalidate();
> 			getDiagramEditPart().getFigure().validate();
> 		}
> 		getDiagramEditPart().refreshPageBreaks();
> 		
> 		// Update the range model of the viewport
> 		((DiagramEditPart) editpart).getViewport().validate();		
> 		if (editpart instanceof DiagramEditPart) {
> 			int x = getWorkspaceViewerPreferenceStore().getInt(
> 				WorkspaceViewerProperties.VIEWPORTX);
> 			int y = getWorkspaceViewerPreferenceStore().getInt(
> 				WorkspaceViewerProperties.VIEWPORTY);
> 			((DiagramEditPart) editpart).getViewport()
> 				.getHorizontalRangeModel().setValue(x);
> 			((DiagramEditPart) editpart).getViewport().getVerticalRangeModel()
> 				.setValue(y);
> 		}
> 
> 		// Get the Ruler Units properties
> 		int rulerUnits = getWorkspaceViewerPreferenceStore().getInt(WorkspaceViewerProperties.RULERUNIT);
> 
> 		// Get the Guide Style
> 		GuideStyle guideStyle = (GuideStyle) getDiagram().getStyle(
> 			NotationPackage.eINSTANCE.getGuideStyle());
> 		
> 		
> 		if (guideStyle != null) {
> 
> 			RootEditPart rep = getGraphicalViewer().getRootEditPart();
> 			DiagramRootEditPart root = (DiagramRootEditPart) rep;
> 			
> 			// Set the Vertical Ruler properties
> 			DiagramRuler verticalRuler = ((DiagramRootEditPart) getRootEditPart()).getVerticalRuler();
> 			verticalRuler.setGuideStyle(guideStyle);
> 			verticalRuler.setUnit(rulerUnits);
> 			DiagramRulerProvider vertProvider = new DiagramRulerProvider(
> 				verticalRuler, root.getMapMode());
> 			vertProvider.init();
> 			getDiagramGraphicalViewer().setProperty(
> 				RulerProvider.PROPERTY_VERTICAL_RULER, vertProvider);
> 	
> 			// Set the Horizontal Ruler properties
> 			DiagramRuler horizontalRuler = ((DiagramRootEditPart) getRootEditPart()).getHorizontalRuler();
> 			horizontalRuler.setGuideStyle(guideStyle);
> 			horizontalRuler.setUnit(rulerUnits);
> 			DiagramRulerProvider horzProvider = new DiagramRulerProvider(
> 				horizontalRuler, root.getMapMode());
> 			horzProvider.init();
> 			getDiagramGraphicalViewer().setProperty(
> 				RulerProvider.PROPERTY_HORIZONTAL_RULER, horzProvider);
> 	
> 			// Show/Hide Rulers
> 			getDiagramGraphicalViewer().setProperty(
> 				RulerProvider.PROPERTY_RULER_VISIBILITY,
> 				Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
> 					WorkspaceViewerProperties.VIEWRULERS)));
> 			
> 		}
> 
> 		// Snap to Grid
> 		getDiagramGraphicalViewer().setProperty(
> 			SnapToGeometry.PROPERTY_SNAP_ENABLED,
> 			Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
> 				WorkspaceViewerProperties.SNAPTOGRID)));
> 
> 		// Hide/Show Grid
> 		getDiagramGraphicalViewer().setProperty(
> 			SnapToGrid.PROPERTY_GRID_ENABLED,
> 			Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
> 				WorkspaceViewerProperties.VIEWGRID)));
> 		getDiagramGraphicalViewer().setProperty(
> 			SnapToGrid.PROPERTY_GRID_VISIBLE,
> 			Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
> 				WorkspaceViewerProperties.VIEWGRID)));
> 
> 		// Grid Origin (always 0, 0)
> 		Point origin = new Point();
> 		getDiagramGraphicalViewer().setProperty(
> 			SnapToGrid.PROPERTY_GRID_ORIGIN, origin);
> 
> 		// Grid Spacing
> 		double dSpacing = ((DiagramRootEditPart) getDiagramEditPart().getRoot())
> 			.getGridSpacing();
> 		((DiagramRootEditPart) getDiagramEditPart().getRoot())
> 			.setGridSpacing(dSpacing);
430,431d928
< 		public void acquire() {
< 			myRefCount++;
433a1028,1057
> 	/**
> 	 * Returns the elements in the given selection.
> 	 * @param selection  the selection
> 	 * @return a list of <code>EObject</code>
> 	 */
> 	protected List getElements(final ISelection selection) {
> 		if (selection instanceof IStructuredSelection) {
> 
> 			return (List) MEditingDomainGetter.getMEditingDomain(
> 				((IStructuredSelection) selection).toList()).runAsRead(
> 				new MRunnable() {
> 
> 					public Object run() {
> 						List retval = new ArrayList();
> 						if (selection instanceof IStructuredSelection) {
> 							IStructuredSelection structuredSelection = (IStructuredSelection) selection;
> 
> 							for (Iterator i = structuredSelection.iterator(); i
> 								.hasNext();) {
> 								Object next = i.next();
> 
> 								View view = (View) ((IAdaptable) next)
> 									.getAdapter(View.class);
> 								if (view != null) {
> 									EObject eObject = ViewUtil
> 										.resolveSemanticElement(view);
> 									if (eObject != null) {
> 										retval.add(eObject);
> 									} else {
> 										retval.add(view);
434,436d1027
< 		public void release() {
< 			if (myRefCount == 0) {
< 				throw new IllegalStateException();
438,438d1058
< 			myRefCount--;
440,442d1059
< 
< 		public boolean isReleased() {
< 			return myRefCount == 0;
444a1069,1075
> 	/* (non-Javadoc)
> 	 * @see org.eclipse.ui.part.IShowInSource#getShowInContext()
> 	 */
> 	public ShowInContext getShowInContext() {
> 
> 		ISelection selection = getGraphicalViewer().getSelection();
> 		return new ShowInContext( null, selection );
445,445d1068
< 		private int myRefCount;
446a1077,1092
> 	
> 	/**
> 	 * Gets the preferences hint that will be used to determine which preference
> 	 * store to use when retrieving diagram preferences for this diagram editor.
> 	 * The preference hint is mapped to a preference store in the preference
> 	 * registry <@link DiagramPreferencesRegistry>. By default, this method
> 	 * returns a preference hint configured with the id of the editor. If a
> 	 * preference store has not been registered against this editor id in the
> 	 * diagram preferences registry, then the default values will be used.
> 	 * 
> 	 * @return the preferences hint to be used to configure the
> 	 *         <code>RootEditPart</code>
> 	 */
> 	protected PreferencesHint getPreferencesHint() {
> 		return new PreferencesHint(getEditorSite().getId());
> 	};
