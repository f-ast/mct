0a1,1
> /*
1,1d0
< /*******************************************************************************
2,2c2,2
<  * Copyright (c) 2006, 2007 Borland Software Corporation
---
>  * Copyright (c) 2006, 2008 Borland Software Corporation
6a7,11
>  * 
>  * Contributors:
>  *     Artem Tikhomirov (Borland)
>  *     Boris Blajer (Borland) - support for composite resources
>  */
7,7d6
<  *******************************************************************************/
26a31,31
> import org.eclipse.gmf.internal.xpand.Activator;
46,46d50
< 		if (file == null) {
48a67,67
> 		String fullyQualifiedName;
48a55,62
> 		// try file directly, to get IO/Parse exceptions, if any.
> 		Reader r = new StreamConverter().toContentsReader(file);
> 		loadXtendResources(new Reader[] { r }, fullyQualifiedName);
> 		//
> 		try {
> 			return loadXtendThroughCache(fullyQualifiedName);
> 		} catch (FileNotFoundException ex) {
> 			return null;	//Missing resource is an anticipated situation, not a error that should be handled
49,49c68,68
< 		String fullyQualifiedName = toFullyQualifiedName(file);
---
> 		if (file == null || (fullyQualifiedName = toFullyQualifiedName(file)) == null) {
50,51d68
< 		if (fullyQualifiedName == null) {
< 			return null;
53,53d63
< 		return super.loadXtendResource(fullyQualifiedName);
56a51,51
> 		String fullyQualifiedName;
57,59d50
< 		if (file == null) {
< 			return null;
< 		}
60,60c52,52
< 		String fullyQualifiedName = toFullyQualifiedName(file);
---
> 		if (file == null || (fullyQualifiedName = toFullyQualifiedName(file)) == null) {
61,61d52
< 		if (fullyQualifiedName == null) {
63a71,74
> 		// try file directly, to get IO/Parse exceptions, if any.
> 		Reader r = new StreamConverter().toContentsReader(file);
> 		loadXpandResources(new Reader[] { r }, fullyQualifiedName);
> 		//
64a76,89
> 		try {
> 			return loadXpandThroughCache(fullyQualifiedName);
> 		} catch (FileNotFoundException ex) {
> 			return null;	//Missing resource is an anticipated situation, not a error that should be handled
> 		}
> 	}
> 
> 	@Override
> 	protected void handleParserException(ParserException ex) {
> 		// may get here only when some referenced template/xtend file is
> 		// broken. Since it's expected to get compiled anyway (either prior
> 		// to compilation of its use or afterwards), error messages should get
> 		// into problems view sooner or later.
> 		Activator.logWarn(ex.getClass().getSimpleName() + ":" + ex.getResourceName());
65,65d75
< 		return super.loadXpandResource(fullyQualifiedName);
79,99d102
< 	protected Reader resolve(String fqn, String ext) throws IOException {
< 		IPath fp = new Path(fqn.replaceAll(SyntaxConstants.NS_DELIM, "/")).addFileExtension(ext);
< 		IResource r = null;
< 		for (IPath p : getResolutions(fp)) {
< 			r = contextProject.findMember(p);
< 			if (r != null) {
< 				break;
< 			}
< 		}
< 		if (false == r instanceof IFile) {
< 			throw new FileNotFoundException(fp.toString());
< 		}
< 		try {
< 			return new StreamConverter().toContentsReader((IFile) r);
< 		} catch (CoreException ex) {
< 			IOException wrap = new IOException(ex.getStatus().getMessage());
< 			wrap.initCause(ex);
< 			throw wrap;
< 		}
< 	}
< 
154a158,158
> 		IPath[] rv = new IPath[myConfiguredRoots.length];
155,156d157
< 		IPath[] configured = getConfiguredRoots();
< 		IPath[] rv = new IPath[configured.length];
157,157c159,159
< 		for (int i = 0; i < configured.length; i++) {
---
> 		for (int i = 0; i < myConfiguredRoots.length; i++) {
158,158c160,160
< 			rv[i] = configured[i].append(p);
---
> 			rv[i] = myConfiguredRoots[i].append(p);
162,165d163
< 	private IPath[] getConfiguredRoots() {
< 		return myConfiguredRoots;
< 	}
< 
167,167c165,165
< 		for (IPath nextRoot : getConfiguredRoots()) {
---
> 		for (IPath nextRoot : myConfiguredRoots) {
181,181c179,179
< 	private String toFullyQualifiedName(IPath filePath) {
---
> 	private static String toFullyQualifiedName(IPath filePath) {
