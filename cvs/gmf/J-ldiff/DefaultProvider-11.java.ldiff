16a17,17
> import java.util.HashSet;
17a19,19
> import java.util.Iterator;
20a23,23
> import java.util.Set;
33a37,37
> import org.eclipse.draw2d.graph.Subgraph;
43a48,49
> import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderedShapeEditPart;
70,71d75
<     private int layoutDefaultMargin = 0;
<     private IMapMode mm;
72a76,78
>     protected int layoutDefaultMargin = 0;
>     protected IMapMode mm;
> 	
73a80,80
>     protected static final int MIN_EDGE_PADDING = 5;
73,73c79,79
< 	private static final int NODE_PADDING = 30;
---
> 	protected static final int NODE_PADDING = 30;
74,74d79
< 	private static final int MIN_EDGE_PADDING = 5;
75,75c81,81
< 	private static final int MAX_EDGE_PADDING = NODE_PADDING * 3;
---
>     protected static final int MAX_EDGE_PADDING = NODE_PADDING * 3;
107,107d121
< 
108,108c122,122
< 		mm = MapModeUtil.getMapMode(containerEditPart.getFigure());
---
> 		mm = MapModeUtil.getMapMode(containerEditPart.getFigure());
117,117d121
< 
119,119c124,124
< 		DirectedGraph g = new DirectedGraph();
---
> 		DirectedGraph g = createGraph();
121,121c126,126
< 		new DirectedGraphLayout().visit(g);
---
> 		createGraphLayout().visit(g);
146,146c151,151
< 		DirectedGraph g = new DirectedGraph();
---
> 		DirectedGraph g = createGraph();
148,148c153,153
< 		new DirectedGraphLayout().visit(g);
---
>         createGraphLayout().visit(g);
182,182c187,187
< 	private NodeList build_nodes(List selectedObjects, Map editPartToNodeDict) {
---
> 	protected NodeList build_nodes(List selectedObjects, Map editPartToNodeDict, Subgraph root) {
250a256,263
>         Rectangle rect = null;
>         Node parent = n.getParent();
>         while (parent!=null &&!(parent.data instanceof IGraphicalEditPart))
>             parent = parent.getParent();
>         if (parent!=null){
>             rect = new Rectangle(n.x - parent.x, n.y - parent.y, n.width, n.height);
>         }
>         else
250,250c255,255
< 	final protected Rectangle getNodeMetrics(Node n) {
---
> 	 protected Rectangle getNodeMetrics(Node n) {
251a265,265
>         return translateFromGraph(rect);
251,251c264,264
< 		return translateFromGraph(new Rectangle(n.x, n.y, n.width, n.height));
---
>             rect = new Rectangle(n.x, n.y, n.width, n.height);
292,292c306,306
< 	private EdgeList build_edges(List selectedObjects, Map editPartToNodeDict) {
---
> 	protected EdgeList build_edges(List selectedObjects, Map editPartToNodeDict) {
309a324,324
>         ArrayList notTopDownEdges = new ArrayList();
317a333,336
> 					if (from instanceof IBorderItemEditPart)
>                         from = from.getParent();
>                     if (to instanceof IBorderItemEditPart)
>                         to = to.getParent();
318,318d332
< 
325a344,345
> 				}else{
>                     notTopDownEdges.add(poly);
331,331c351,351
< 		li = objects.listIterator();
---
> 		li = notTopDownEdges.listIterator();
333,334d352
< 			EditPart gep = (EditPart) li.next();
< 			if (gep instanceof ConnectionEditPart) {
335,335c353,353
< 				ConnectionEditPart poly = (ConnectionEditPart) gep;
---
> 			ConnectionEditPart poly = (ConnectionEditPart) li.next();
336,337d353
< 
< 				if (!layoutTopDown(poly)) {
339a356,359
>             if (from instanceof IBorderItemEditPart)
>                 from = from.getParent();
>             if (to instanceof IBorderItemEditPart)
>                 to = to.getParent();
340,340d355
< 
349,351d367
< 			}
< 		}
< 
452a469,477
> 			GraphicalEditPart shapeEP = (GraphicalEditPart) e;
>             Set sourceConnections = new HashSet(shapeEP.getSourceConnections());
>             if (shapeEP instanceof IBorderedShapeEditPart){
>                 List borderItems = getBorderItemEditParts(shapeEP);
>                 for (Iterator iter = borderItems.iterator(); iter.hasNext();) {
>                     GraphicalEditPart element = (GraphicalEditPart) iter.next();
>                     sourceConnections.addAll(element.getSourceConnections());
>                 }
>             }
453,458d468
< 			ShapeEditPart shapeEP = (ShapeEditPart) e;
< 			List sourceConnections = shapeEP.getSourceConnections();
< 			for (int i = 0; i < sourceConnections.size(); i++) {
< 				ConnectionEditPart connectionEP = (ConnectionEditPart) sourceConnections
< 					.get(i);
< 				EditPart target = connectionEP.getTarget();
459a479,482
> 			for (Iterator iter = sourceConnections.iterator();
>                     iter.hasNext();) {
> 				ConnectionEditPart connectionEP = (ConnectionEditPart) iter.next();
> 				EditPart target = connectionEP.getTarget();
461a485,486
> 				if (target instanceof IBorderItemEditPart)
>                     target = target.getParent();
472a498,514
>      * This method searches an edit part for a child that is a border item edit part
>      * @param parent part needed to search
>      * @param set to be modified of border item edit parts that are direct children of the parent
>      */
>     private List getBorderItemEditParts(EditPart parent) {
>         Iterator iter = parent.getChildren().iterator();
>         List list = new ArrayList();
>         while(iter.hasNext()) {
>             EditPart child = (EditPart)iter.next();
>             if( child instanceof IBorderItemEditPart ) {
>                 list.add(child);
>             }
>         }
>         return list;
>     }
> 
> 	/**
483,483c525,525
< 	private void build_graph(DirectedGraph g, List selectedObjects) {
---
> 	protected void build_graph(DirectedGraph g, List selectedObjects) {
485,485d526
< 
488,488d528
< 
489,489c529,529
< 		NodeList nodes = build_nodes(selectedObjects, editPartToNodeDict);
---
>         NodeList nodes = build_nodes(selectedObjects, editPartToNodeDict,null);
495,495d534
< 
497,497d535
< 
499a538,540
>         postProcessGraph(g,editPartToNodeDict);
>         //printGraph(g);
>      }
500a542,543
>     protected void postProcessGraph(DirectedGraph g, Hashtable editPartToNodeDict) {
>         //default do nothing
501,505d541
< 		//new BreakCycles().visit(g);
< 				
< 		// this has to be called after - BreakCycles to ensure we are fully
< 		// connected.
< 		//connectNonConnectedSubgraphs(nodes, edges);
599,599c637,637
< 	Command update_diagram(GraphicalEditPart diagramEP, DirectedGraph g,
---
> 	protected Command update_diagram(GraphicalEditPart diagramEP, DirectedGraph g,
606,606c644,644
< 		Command cmd = getShapesPositionCommand(g, diff);
---
> 		Command cmd = createNodeChangeBoundCommands(g, diff);
610,610c648,648
< 		cmd = getConnectionPositionCommand(g, diff);
---
> 		cmd = createEdgesChangeBoundsCommands(g, diff);
624,624c662,662
< 	private Command getConnectionPositionCommand(DirectedGraph g, Point diff) {
---
> 	protected Command createEdgesChangeBoundsCommands(DirectedGraph g, Point diff) {
633,633c671,671
< 			if (edge.data == null)
---
> 			if (edge.data == null || edge.getPoints()==null)
661a700,701
>         PointList pointList = edge.getPoints();
>         Rectangle start = translateFromGraph(
662a703,703
>                           pointList.getFirstPoint().y, 0, 0));
662,662c702,702
< 		Point startpt = edge.getPoints().getFirstPoint();
---
>             new Rectangle(pointList.getFirstPoint().x,
663,663d702
< 		Rectangle start = translateFromGraph(new Rectangle(startpt.x, startpt.y, 0, 0));
665,665d704
< 
677,678d715
< 
< 		Point endpt = edge.getPoints().getLastPoint();
679,679c716,716
< 		Rectangle end = translateFromGraph(new Rectangle(endpt.x, endpt.y, 0, 0));
---
>         Rectangle end = translateFromGraph(new Rectangle(pointList.getLastPoint().x,
679a717,717
>             pointList.getLastPoint().y, 0, 0));
683,683c721,721
< 	private Command getShapesPositionCommand(DirectedGraph g, Point diff) {
---
> 	protected Command createNodeChangeBoundCommands(DirectedGraph g, Point diff) {
685,685d722
< 
687a730,730
>     protected void createSubCommands(Point diff, ListIterator vi, CompoundCommand cc) {
712,712c755,755
< 				if (cmd != null)
---
> 				if (cmd != null && cmd.canExecute())
715a724,725
> 		createSubCommands(diff, vi, cc);
> 	    if (cc.isEmpty())
716,717d723
< 		
< 		if (cc.isEmpty())
718,718c726,726
< 			return null;
---
> 			return null;
719,719c727,727
< 		return cc;
---
> 		return cc;
719a728,728
> 	}
748a788,857
>     
>     /**
>      * Creates the graph that will be used by the layouy provider
>      * Clients can override this method create different kind of graphs
>      * This method is called by {@link DefaultProvider#layoutEditParts(GraphicalEditPart, IAdaptable) } 
>      * and {@link DefaultProvider#layoutEditParts(List, IAdaptable)}  
>      * @return the Graph that will be used by the layout algorithm
>      */
>     protected DirectedGraph createGraph(){
>         return new DirectedGraph();
>     }
>     
>     /**
>      * Creates the graph layout algorithm that will be used to layout the diagram
>      * This method is called by {@link DefaultProvider#layoutEditParts(GraphicalEditPart, IAdaptable) } 
>      * and {@link DefaultProvider#layoutEditParts(List, IAdaptable)}  
>      * @return the graph layout 
>      */
>     protected DirectedGraphLayout createGraphLayout() {
>         return new DirectedGraphLayout();
>     }
>     
>    /* private void printGraph(DirectedGraph g){
>         int depth = 0;
>         if (g instanceof CompoundDirectedGraph){
>             NodeList subGraphs = ((CompoundDirectedGraph)g).nodes;
>             for (Iterator iter = subGraphs.iterator(); iter.hasNext();) {
>                 Node node = (Node)iter.next();
>                 if (node.getParent()!=null)
>                     continue;
>                 if (node instanceof Subgraph){
>                     printSubGraph((Subgraph)node,depth);
>                 }else {
>                     printNode(node,depth);
>                 }
>             }
>         }
>     }
> 
>     private void printNode(Node node, int depth) {
>         StringBuffer buffer = new StringBuffer();
>         for (int i =0 ; i<depth ; i++)
>             buffer.append("\t");
>         buffer.append("Node");
>         System.out.println(buffer);
>     }
> 
>     private void printSubGraph(Subgraph subgraph, int depth) {
>         StringBuffer buffer = new StringBuffer();
>         for (int i =0 ; i<depth ; i++)
>             buffer.append("\t");
>         buffer.append("SubGraph");
>         if (!subgraph.members.isEmpty()){
>             buffer.append(" : ");
>             System.out.println(buffer);
>             NodeList nodes = subgraph.members;
>             depth++;
>             for (Iterator iter = nodes.iterator(); iter.hasNext();) {
>                 Node element = (Node) iter.next();
>                 if (element instanceof Subgraph){
>                     printSubGraph((Subgraph)element,depth);
>                 }else {
>                     printNode(element,depth);
>                 }
>             }
>         }else {
>             System.out.println(buffer);
>         }
>             
>     }*/
