2,2c2,2
<  * Copyright (c) 2005, 2007 Borland Software Corporation
---
>  * Copyright (c) 2005, 2008 Borland Software Corporation
16a17,17
> import java.util.LinkedHashSet;
26a28,29
> import org.eclipse.gmf.gmfgraph.Border;
> import org.eclipse.gmf.gmfgraph.BorderRef;
28a32,32
> import org.eclipse.gmf.gmfgraph.CompoundBorder;
29a34,34
> import org.eclipse.gmf.gmfgraph.CustomBorder;
30a36,36
> import org.eclipse.gmf.gmfgraph.CustomLayout;
34a41,41
> import org.eclipse.gmf.gmfgraph.FigureRef;
35a43,43
> import org.eclipse.gmf.gmfgraph.LayoutRef;
136a145,171
> 		LinkedHashSet<String> allRequired = new LinkedHashSet<String>();
> 		for (FigureGallery gallery : findAllGalleriesForImport(figure)) {
> 			allRequired.addAll(Arrays.asList(fqnSwitch.getDependencies(gallery)));
> 		}
> 		viewmap.getRequiredPluginIDs().addAll(allRequired);
> 	}
> 
> 	// public to have access from tests. FIXME may need extra check for endless
> 	// recursion (like CompoundBorder.outer = BorderRef which points to same CompoundBorder)
> 	public static Collection<FigureGallery> findAllGalleriesForImport(Figure figure) {
> 		LinkedHashSet<FigureGallery> rv = new LinkedHashSet<FigureGallery>();
> 		rv.add(findAncestorFigureGallery(figure));
> 		LinkedList<Figure> queue = new LinkedList<Figure>();
> 		queue.add(figure);
> 		do {
> 			final RealFigure fig;
> 			if (queue.peek() instanceof RealFigure) {
> 				fig = (RealFigure) queue.removeFirst();
> 			} else if (queue.peek() instanceof FigureRef) {
> 				fig = ((FigureRef) queue.removeFirst()).getFigure();
> 			} else {
> 				assert false; // no more known subclasses of Figure at the time.
> 				queue.removeFirst();
> 				continue;
> 			}
> 			if (fig.getLayout() instanceof LayoutRef && ((LayoutRef) fig.getLayout()).getActual() instanceof CustomLayout) {
> 				rv.add(findAncestorFigureGallery(((LayoutRef) fig.getLayout()).getActual()));
137,139d144
< 		FigureGallery gallery = findAncestorFigureGallery(figure);
< 		if (gallery != null){
< 			viewmap.getRequiredPluginIDs().addAll(Arrays.asList(fqnSwitch.getDependencies(gallery)));
140a173,192
> 			if (fig.getBorder() != null) {
> 				LinkedList<Border> borderQueue = new LinkedList<Border>();
> 				borderQueue.add(fig.getBorder());
> 				do {
> 					if (borderQueue.peek() instanceof BorderRef) {
> 						borderQueue.add(((BorderRef) borderQueue.peek()).getActual());
> 					} else if (borderQueue.peek() instanceof CompoundBorder) {
> 						CompoundBorder b = (CompoundBorder) borderQueue.peek();
> 						borderQueue.addLast(b.getInner());
> 						borderQueue.addLast(b.getOuter());
> 					} else if (borderQueue.peek() instanceof CustomBorder) {
> 						rv.add(findAncestorFigureGallery(borderQueue.peek()));
> 					}
> 					borderQueue.removeFirst(); // effectively removes any null value as well
> 				} while (!borderQueue.isEmpty());
> 			}
> 			queue.addAll(fig.getChildren());
> 		} while (!queue.isEmpty());
> 		rv.remove(null);
> 		return rv;
143,143c195,195
< 	public static FigureGallery findAncestorFigureGallery(Figure figure){
---
> 	public static FigureGallery findAncestorFigureGallery(EObject figure){
