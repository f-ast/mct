14a15,15
> import java.util.Collections;
92a94,94
> 				break;
194,194d195
< 		figure.translateToAbsolute(bounds);
206a208,227
> 	    if (epStart instanceof DiagramEditPart) {
> 	        Point location = viewport.getViewLocation().getCopy();
> 	        switch (direction) {
> 	            case PositionConstants.NORTH :
> 	                location.translate(0, -pageDistance);
> 	                break;              
> 	            case PositionConstants.SOUTH :
> 	                location.translate(0, pageDistance);
> 	                break;
> 	            case PositionConstants.EAST :
> 	                location.translate(pageDistance, 0);
> 	                break;
> 	            case PositionConstants.WEST :
>                     location.translate(-pageDistance, 0);
> 	                break;
> 	        }
> 	        viewport.setViewLocation(location);
>         }
> 
> 		List<GraphicalEditPart> editParts =
207,207c278,278
< 		List editParts =
---
> 		List<GraphicalEditPart> editParts =
217,217c237,237
< 			Iterator parts = editParts.iterator();
---
> 			Iterator<GraphicalEditPart> parts = editParts.iterator();
219,219c239,239
< 				navigateToPart((EditPart) parts.next(), event);
---
> 				navigateToPart(parts.next(), event);
221,221c241,241
< 			EditPart part = (EditPart) editParts.get(editParts.size() - 1);
---
> 			EditPart part = editParts.get(editParts.size() - 1);
234a255,274
> 		
> 		// go to top-left or bottom-right corner if nothing is selected
> 		if (epStart instanceof DiagramEditPart) {
>             Viewport viewport = findViewport(epStart);
>             switch (direction) {
>                 case PositionConstants.NORTH:
>                 case PositionConstants.WEST:
>                     viewport.setViewLocation(viewport.getHorizontalRangeModel()
>                         .getMinimum(), viewport.getVerticalRangeModel()
>                         .getMinimum());
>                     break;
>                 case PositionConstants.SOUTH:
>                 case PositionConstants.EAST:
>                     viewport.setViewLocation(viewport.getHorizontalRangeModel()
>                         .getMaximum(), viewport.getVerticalRangeModel()
>                         .getMaximum());
>                     break;
>             }
>         }
> 		
238,238d277
< 		List editParts =
247,247c287,287
< 			Iterator parts = editParts.iterator();
---
> 			Iterator<GraphicalEditPart> parts = editParts.iterator();
249,249c289,289
< 				navigateToPart((EditPart) parts.next(), event);
---
> 				navigateToPart(parts.next(), event);
251,251c291,291
< 			EditPart part = (EditPart) editParts.get(editParts.size() - 1);
---
> 			EditPart part = editParts.get(editParts.size() - 1);
265,265c305,305
< 	private List findPageSibling(
---
> 	private List<GraphicalEditPart> findPageSibling(
270a311,311
> 	    
272a314,315
> 		GraphicalEditPart epFurthest = null;  // in case there is not a full pageDistance left to scroll
> 		List<GraphicalEditPart> selection = new ArrayList<GraphicalEditPart>();
273,273c370,370
< 		List selection = new ArrayList();
---
> 		List<GraphicalEditPart> selection = new ArrayList<GraphicalEditPart>();
275a318,318
> 		int distance = Integer.MAX_VALUE;
276,276c319,319
< 		int distance = 0;
---
> 		int furthestDistance = 0;
287a331,331
> 			if (!isInDirection(direction, pStart, pCurrent))
288,288d330
< 			if (pStart.getPosition(pCurrent) != direction)
292,292c335,335
< 			if (d <= pageDistance) {
---
> 			if (d >= pageDistance) {
294,294c337,337
< 				if (d > distance) {
---
> 				if (d < distance) {
298a342,344
> 			if (d > furthestDistance) {
> 			    epFurthest = epCurrent;
> 			}
303a350,352
> 		if (selection.isEmpty() && epFurthest != null) {
> 		    return Collections.singletonList(epFurthest);
> 		}
314,314c363,363
< 	private List findEndSibling(
---
> 	private List<GraphicalEditPart> findEndSibling(
321,321d369
< 		List selection = new ArrayList();
335a385,385
> 			if (!isInDirection(direction, pStart, pCurrent))
336,336d384
< 			if (pStart.getPosition(pCurrent) != direction)
468a518,544
>     /**
>      * Returns true if the point in question is in the given direction from the
>      * starting point.
>      * 
>      * @param direction
>      *            the direction
>      * @param start
>      *            the starting point
>      * @param point
>      *            the point in question
>      * @return true if the point in question is in the given direction from the
>      *         starting point; false otherwise
>      */
>     private boolean isInDirection(int direction, Point start, Point point) {
>         switch (direction) {
>             case PositionConstants.WEST:
>                 return start.x > point.x;
>             case PositionConstants.EAST:
>                 return start.x < point.x;
>             case PositionConstants.NORTH:
>                 return start.y > point.y;
>             case PositionConstants.SOUTH:
>                 return start.y < point.y;
>         }
>         return false;
>     }
>     
