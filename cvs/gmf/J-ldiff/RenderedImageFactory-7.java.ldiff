32,32d31
< import org.eclipse.gmf.runtime.draw2d.ui.render.internal.factory.RenderInfoImpl;
37a37,37
> import org.eclipse.swt.graphics.RGB;
38,38c45,45
< 
---
> 
74a75,76
> 	 * @deprecated use
> 	 *             {@link RenderedImageFactory#createInfo(int, int, RGB, RGB, boolean, boolean)}
75a78,79
> 	static public RenderInfo createInfo(int width, int height, Color fill,
> 			Color outline, boolean maintainAspectRatio, boolean antialias) {
76,82d77
< 	static public RenderInfo createInfo(
< 		int width,
< 		int height,
< 		Color fill,
< 		Color outline,
< 		boolean maintainAspectRatio,
< 		boolean antialias) {
83,83c80,80
< 		RenderInfoImpl svgInfo = new RenderInfoImpl();
---
> 		RenderedImageKey svgInfo = new RenderedImageKey();
83a81,81
> 		svgInfo.setValues(width, height, fill, outline, maintainAspectRatio,
84,89d80
< 		svgInfo.setValues(
< 			width,
< 			height,
< 			fill,
< 			outline,
< 			maintainAspectRatio,
94a87,122
> 	 * createInfo static Utility to create a RenderInfo object.
> 	 * 
> 	 * @param width
> 	 *            the width of the rendered image to set
> 	 * @param height
> 	 *            the height of the rendered image to set
> 	 * @param maintainAspectRatio
> 	 *            <code>boolean</code> <code>true</code> if aspect ratio of
> 	 *            original vector file is maintained, <code>false</code>
> 	 *            otherwise
> 	 * @param antialias
> 	 *            <code>boolean</code> <code>true</code> if the image is to
> 	 *            be rendered using anti-aliasing (removing "jaggies" producing
> 	 *            smoother lines), <code>false</code> otherwise
> 	 * @param fill
> 	 *            the <code>RGB</code> of the fill that could instrumented
> 	 *            into image formats that support dynamic color replacement.
> 	 *            Typically, this would replace colors in the image which are
> 	 *            "white" i.e. RGB(255,255,255)
> 	 * @param outline
> 	 *            the <code>RGB</code> of the outline that could
> 	 *            instrumented into image formats that support dynamic color
> 	 *            replacement. Typically, this would replace colors in the image
> 	 *            which are "black" i.e. RGB(0,0,0)
> 	 * @return <code>RenderInfo</code> object that contains information about
> 	 *         the rendered image.
> 	 */
> 	static public RenderInfo createInfo(int width, int height, boolean maintainAspectRatio, boolean antialias,
> 			RGB fill, RGB outline ) {
> 		RenderedImageKey svgInfo = new RenderedImageKey();
> 		svgInfo.setValues(width, height, maintainAspectRatio,
> 			antialias, fill, outline);
> 		return svgInfo;
> 	}
> 	
> 	/**
105,105c133,133
< 		return getInstance(theURL, new RenderInfoImpl());
---
> 		return getInstance(theURL, new RenderedImageKey());
135a164,165
> 			Trace.throwing(Draw2dRenderPlugin.getInstance(),
> 				Draw2dRenderDebugOptions.EXCEPTIONS_THROWING,
136,136c166,166
< 			Trace.throwing(Draw2dRenderPlugin.getInstance(), Draw2dRenderDebugOptions.EXCEPTIONS_THROWING, RenderedImage.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
---
> 				RenderedImage.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
153,153c183,183
< 		return getInstance(szFilePath, new RenderInfoImpl());
---
> 		return getInstance(szFilePath, new RenderedImageKey());
180a211,214
> 			Trace.throwing(Draw2dRenderPlugin.getInstance(),
> 				Draw2dRenderDebugOptions.EXCEPTIONS_THROWING,
> 				RenderedImageFactory.class,
> 				"RenderedImageFactory.getInstance()", //$NON-NLS-1$
181,181d210
< 			Trace.throwing(Draw2dRenderPlugin.getInstance(), Draw2dRenderDebugOptions.EXCEPTIONS_THROWING, RenderedImageFactory.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
199,199c232,232
< 		return getInstance(buffer, new RenderInfoImpl());
---
> 		return getInstance(buffer, new RenderedImageKey());
211,211c244,244
< 	 *            <code>RenderInfo</code> object containing information about the size 
---
> 	 *            <code>RenderInfo</code> object containing information about
212a246,246
> 	 *            rendered.
212,212c245,245
< 	 *            and general data regarding how the image will be rendered.
---
> 	 *            the size and general data regarding how the image will be
217,217c251,251
< 	static public RenderedImage getRelatedInstance(RenderedImage image, RenderInfo info) {
---
> 	static public RenderedImage getRelatedInstance(RenderedImage image,
217a252,252
> 			RenderInfo info) {
220,220c255,255
< 			RenderedImageKey key = new RenderedImageKey(oldKey.getChecksum(), info, oldKey.getExtraData());
---
> 			RenderedImageKey key = new RenderedImageKey(info, oldKey.getChecksum(), oldKey.getExtraData());
224,224d258
< 			}
225,225c259,259
< 			else {
---
> 			} else {
226a261,261
> 					.getBuffer(), key);
226,226c260,260
< 				return autodetectImage(((AbstractRenderedImage)image).getBuffer(), key);
---
> 				return autodetectImage(((AbstractRenderedImage) image)
251,251c286,286
< 		final RenderedImageKey key = new RenderedImageKey(checksum.getValue(), info, null);
---
> 		final RenderedImageKey key = new RenderedImageKey(info, checksum.getValue(), null);
255,255c290,290
< 			image = (RenderedImage)(((WeakReference) instanceMap.get(key)).get());
---
> 			image = (RenderedImage) (((WeakReference) instanceMap.get(key))
255a291,291
> 				.get());
262,262c298,298
< 	private static RenderedImage autodetectImage(byte[] buffer, final RenderedImageKey key) {
---
> 	private static RenderedImage autodetectImage(byte[] buffer,
262a299,299
> 			final RenderedImageKey key) {
278,278c315,315
< 	        	   	ByteArrayInputStream input = new ByteArrayInputStream(buffer);
---
> 					ByteArrayInputStream input = new ByteArrayInputStream(
278a316,316
> 						buffer);
