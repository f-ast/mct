184,184c184,184
< 	 * side takes precendence.
---
> 	 * side takes precedence.
190,190c190,190
< 	private Point locateOnParent(Point suggestedLocation,
---
> 	protected Point locateOnParent(Point suggestedLocation,
253a254,254
> 	 * existing borderItemFigure and returns the conflicting border item figure
254,254d253
< 	 * existing borderItemFigure.
256a257,257
> 	 * @return the conflicting border item figure
257,257d256
< 	 * @return <code>ture</code> or <code>false</code>
258a259,259
> 	protected IFigure getConflictingBorderItemFigure(Point recommendedLocation,
259,259d258
< 	private boolean conflicts(Point recommendedLocation,
273,273c273,273
< 					return true;
---
> 					return borderItem;
277,277c277,277
< 		return false;
---
> 		return null;
281,281c281,281
< 	 * The preferred side takes precendence.
---
> 	 * The preferred side takes precedence.
289,289c289,289
< 	private Point locateOnBorder(Point suggestedLocation,
---
> 	protected Point locateOnBorder(Point suggestedLocation,
298a299,300
> 		IFigure conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
> 
299,299c301,301
< 		if (circuitCount < 4 && conflicts(recommendedLocation, borderItem)) {
---
> 		if (circuitCount < 4 && conflictingBorderItem != null) {
302a305,306
> 							conflictingBorderItem.getBounds().getBottomLeft().y,
> 							vertical_gap, suggestedSide, borderItem);
302,302c304,304
< 					recommendedLocation.y += borderItemSize.height
---
> 					recommendedLocation.y = calculateNextNonConflictingPosition(
303,303d304
< 						+ vertical_gap;
304a308,308
> 				} while (conflictingBorderItem != null);
304,304c307,307
< 				} while (conflicts(recommendedLocation, borderItem));
---
> 					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
309a314,317
> 				} else if (recommendedLocation.y < getParentBorder().getTopLeft().y
> 					- borderItemSize.height) { // off the top, wrap north
> 					return locateOnBorder(recommendedLocation,
> 						PositionConstants.NORTH, circuitCount + 1, borderItem);
312a321,323
> 					recommendedLocation.x = calculateNextNonConflictingPosition(
> 							conflictingBorderItem.getBounds().getTopRight().x,
> 							horizontal_gap, suggestedSide, borderItem);
313,314d320
< 					recommendedLocation.x += borderItemSize.width
< 						+ horizontal_gap;
315,315c324,324
< 				} while (conflicts(recommendedLocation, borderItem));
---
> 					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
315a325,325
> 				} while (conflictingBorderItem != null);
319a330,333
> 				} else if (recommendedLocation.x < getParentBorder().getBottomLeft().x
> 					- borderItemSize.width) {
> 					return locateOnBorder(recommendedLocation,
> 						PositionConstants.WEST, circuitCount + 1, borderItem);
323a338,340
> 					recommendedLocation.y = calculateNextNonConflictingPosition(
> 							conflictingBorderItem.getBounds().getLocation().y,
> 							vertical_gap, suggestedSide, borderItem);
324,324d337
< 					recommendedLocation.y -= (borderItemSize.height + vertical_gap);
325a342,342
> 				} while (conflictingBorderItem != null);
325,325c341,341
< 				} while (conflicts(recommendedLocation, borderItem));
---
> 					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
329a347,350
> 				} else if (recommendedLocation.y > getParentBorder().getBottomRight().y) {
> 					// east is full, try south.
> 					return locateOnBorder(recommendedLocation,
> 						PositionConstants.SOUTH, circuitCount + 1, borderItem);
332a354,356
> 					recommendedLocation.x = calculateNextNonConflictingPosition(
> 							conflictingBorderItem.getBounds().getLocation().x,
> 							horizontal_gap, suggestedSide, borderItem);
333,333d353
< 					recommendedLocation.x -= (borderItemSize.width + horizontal_gap);
334a358,358
> 				} while (conflictingBorderItem != null);
334,334c357,357
< 				} while (conflicts(recommendedLocation, borderItem));
---
> 					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
337a362,364
> 				} else if (recommendedLocation.x > getParentBorder().getTopRight().x) {
> 					return locateOnBorder(recommendedLocation,
> 							PositionConstants.EAST, circuitCount + 1, borderItem);
344a372,394
> 	 * Default behavior is to simply check in a counter clockwise direction.
> 	 * Note:  if the currentSide is EAST or WEST, the y co-oridinate is passed as the current position.  Otherwise,
> 	 * if NORTH or SOUTH is the currentSide, then the x co-oridinate of the borderitem is passed.
> 	 * 
> 	 * @param currentPosition	The current x or y co-ordinate of the border item
> 	 * @param interval			The suggested spacing to try to find the next non-conflicting position
> 	 * @param currentSide		The current side of the border item 
> 	 * @param borderItem 		The borderItem being relocated (here to be used by subclasses if needed)
> 	 * @return the next possible non-conflicting position
> 	 */
> 	protected int calculateNextNonConflictingPosition(int currentPosition, int interval, int currentSide, IFigure borderItem) {
> 		switch (currentSide) {
> 			case PositionConstants.WEST:  // Fall through  -- Move down the west side
> 			case PositionConstants.SOUTH: // Move towards the east side
> 				return currentPosition + interval;
> 			case PositionConstants.EAST:  // Fall through - Move towards the north side
> 			case PositionConstants.NORTH: // Fall through - Move towards the west side
> 			default: /* Should never get here, but if we do, we'll default to subtraction */
> 				return currentPosition - interval;
> 		}
> 	}
> 	
> 	/**
