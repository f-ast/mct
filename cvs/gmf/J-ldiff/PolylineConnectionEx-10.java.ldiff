17,17c17,17
< import java.util.HashMap;
---
> import java.util.Hashtable;
21,21d20
< import java.util.Map;
34a34,34
> import org.eclipse.draw2d.geometry.PrecisionPoint;
40,40c38,38
< import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.PolylineAnchor;
---
> import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.BaseSlidableAnchor;
121a122,122
> 	
121,121c121,121
<     private Map connectionAnchors;
---
>     private Hashtable connectionAnchors;
157a1110,1110
> 	/**
158,158c1111,1111
< 	 * Returns the connectionAnchors.
---
> 	 * Returns the connectionAnchors.
159,159c1112,1112
< 	 * @return Hashtable
---
> 	 * @return Hashtable
160a1114,1114
> 	protected Hashtable getConnectionAnchors() {
160,160c1113,1113
< 	 */
---
> 	 */
161,161d1113
< 	protected Map getConnectionAnchors() {
162a1116,1116
> 			connectionAnchors = new Hashtable(1);
162,162c1115,1115
< 		if (connectionAnchors == null)
---
> 		if (connectionAnchors == null)
163,163d1115
< 			connectionAnchors = new HashMap(1);
164,164c1117,1117
< 		return connectionAnchors;
---
> 		return connectionAnchors;
165a1119,1122
> 	
> 	/**
> 	 * Specifies how large the area of the figure's bounds where <Code>SlidableAnchor</Code>
> 	 * will be created. The result number: 0<=result<=1
165,165c1118,1118
< 	}
---
> 	}
166a1124,1127
> 	 * @return  the size of the area of the figure's bounds
> 	 */
> 	protected double getSlidableAnchorArea() {
> 		return 0.25;
166,166c1123,1123
<     
---
> 	 * 
167,167d1123
<     /**
998,1129d988
<     /**
<      * Contains location data about a point in relation
<      * with the polyline.
<      * See getPointInfo for more information.
<      */
<     static public class PointInfo {
<         /**
<          * orthogonal distance from line
<          */
<         public int      fromLine;
<         
<         /**
<          * distance from the end of the line
<          */
<         public int      fromEnd;
<         
<         /**
<          * are the values stored as a percentage value instead of relative coordinates.
<          */
<         public boolean  isPercentage = true;
<         
<         /**
<          * Defines a sign which encodes the positive or negative position of the point
<          * as defined in {@link LineSeg#positionRelativeTo}
<          */
<         public double   proj = 0.0;
<     }
< 
< 
<     private static boolean projIn( double proj ) {
<         return proj > 0 && proj < 1;
<     }
<     
<     /**
<      * returns a measure of how much proj is away from 0
<      * when negative of from 1 when positive
<      * returns 0 when proj is between 0 and 1
<      * intended to be called when proj is not between 0 and 1
<      */
<     private static double projFactor(double proj) {
<         if (proj < 0 )
<             return -proj;
<         else if (proj > 1.0)
<             return proj - 1.0;
<         else
<             return 0;
<     }
<     
<     private boolean atLeastOneProjectionCovers(Point p) {
<         boolean oneProjIn = false;
<         
<         List segments = PointListUtilities.getLineSegments(getPoints());
<         
<         ListIterator segIter = segments.listIterator();
<         while (segIter.hasNext() && !oneProjIn) {
<             LineSeg segment = (LineSeg) segIter.next();
<             double proj = segment.projection( p.x, p.y );
<             if (projIn(proj)) {
<                 oneProjIn = true;
<             }
<         }
<         
<         return oneProjIn;
<     }
< 
<     /**
<      * Returns a structure PointInfo that contains the following information:
<      * 1) perpendicular distance from the point p to the nearest segment 
<      * 2) percentage distance from the projection of point p to the nearest segment
<      * to the beginning of the polyline
<      * NOTE:
<      * 1) has a sign which encodes the positive or negative position of the point
<      * as defined in LineSeg.positionRelativeTo()
<      */
<     private PointInfo getPointInfo( Point p ) {
<         
<         PointInfo pointInfo = new PointInfo();
<         pointInfo.fromLine = Integer.MAX_VALUE;
<         pointInfo.fromEnd  = 0;
<         pointInfo.proj = Double.NEGATIVE_INFINITY;// so that initially projFactor is maximal
<         
<         List segments = PointListUtilities.getLineSegments(getPoints());
<         
<         int accumulatedLength = 0;
<         
<         boolean isCovered = atLeastOneProjectionCovers(p);
<         
<         ListIterator segIter = segments.listIterator();
<         while (segIter.hasNext()) {
<             LineSeg segment = (LineSeg) segIter.next();
<             double proj = segment.projection( p.x, p.y );
<             Point pt = segment.perpIntersect( p.x, p.y );
<             int perpDist = (int)Math.round(p.getDistance(pt));
<             if (isCovered) {
<                 // when covered we pick the smallest perpendicular distance
<                 if (perpDist < Math.abs(pointInfo.fromLine)) {
<                     if (proj > 0 && proj < 1 ) {
<                         pointInfo.fromLine = (segment.positionRelativeTo(p) == LineSeg.Sign.POSITIVE ? perpDist : -perpDist);
<                         Point origin = segment.getOrigin();             
<                         int inSegmentDistance = (int)Math.round(origin.getDistance(pt));
<                         double fractionDistance = ((double)(accumulatedLength + inSegmentDistance))/((double)PointListUtilities.getPointsLength(getPoints()));
<                         pointInfo.fromEnd = (int)Math.round(100*fractionDistance);
<                     }
<                 }
<             }
<             else {
<                 // when not covered we pick the smallest projFactor
<                 if (projFactor(proj) < projFactor(pointInfo.proj)) {
<                     pointInfo.fromLine = (segment.positionRelativeTo(p) == LineSeg.Sign.POSITIVE ? perpDist : -perpDist);
<                     Point origin = segment.getOrigin();             
<                     // we enforce the point to stay on a perpendicular position with regard to the segment
<                     int inSegmentDistance = proj>0 ? 
<                         Math.min((int)Math.round(origin.getDistance(pt)), (int)segment.length()) 
<                         : 0;
<                         
<                     double fractionDistance = ((double)(accumulatedLength + inSegmentDistance))/((double)PointListUtilities.getPointsLength(getPoints()));
<                     pointInfo.fromEnd = (int)Math.round(100*fractionDistance);
<                     if (pointInfo.fromEnd > 0 && pointInfo.fromEnd < 100)
<                         pointInfo.fromEnd += ((inSegmentDistance == (int)segment.length()) ? -1 : 1);// to avoid corners
<                     pointInfo.proj = proj;
<                 }
<             }
<             accumulatedLength += segment.length();
<         }
<             
<         // sanity check
<         if (pointInfo.fromLine == Integer.MAX_VALUE)
<             pointInfo.fromLine = 0;// we should never get here 
<                 
<         return pointInfo;
<     }
<     
1138,1138d996
< 	/* 
1139,1139c997,997
<      * (non-Javadoc)
---
> 	/* (non-Javadoc)
1143,1143d1000
<         ConnectionAnchor connectionAnchor = (ConnectionAnchor)getConnectionAnchors().get(terminal);
1144a1002,1013
> 		ConnectionAnchor connectAnchor =
> 			(ConnectionAnchor) getConnectionAnchors().get(terminal);
> 		if (connectAnchor == null) {
> 			if (terminal.equals(szAnchor)) {
> 				// get a new one - this figure doesn't support static anchors
> 				connectAnchor = createDefaultAnchor();
> 				getConnectionAnchors().put(terminal,connectAnchor);
> 			}
> 			else {
> 				connectAnchor = createAnchor(BaseSlidableAnchor.parseTerminalString(terminal));
> 			}
> 		}
1145,1146d1001
<         if (connectionAnchor == null)
<             connectionAnchor = new PolylineAnchor(this, terminal);
1148,1148c1015,1015
<         return connectionAnchor;
---
> 		return connectAnchor;
1151,1151d1017
<     /* 
1152,1152c1018,1018
<      * (non-Javadoc)
---
> 	/* (non-Javadoc)
1155a1022,1024
> 		if (c instanceof BaseSlidableAnchor) {
> 			return ((BaseSlidableAnchor) c).getTerminal();
> 		}
1164a1034,1035
> 		getConnectionAnchor(szAnchor);
> 		return szAnchor;
1165,1165d1033
<         return null;
1182a1053,1056
> 	 * Creates the default Slidable anchor with a reference point at the center
> 	 * of the figure's bounds
> 	 * 
> 	 * @return - default SlidableAnchor, relative reference the center of the figure
1182a1077,1077
> 	/**
1183a1079,1079
> 	 * 
1183,1183c1078,1078
<      * Returns a new anchor for this node figure.
---
> 	 * Returns a new anchor for this node figure.
1184,1184c1080,1080
<      * @param p Point on the figure that gives a hint which anchor to return.
---
> 	 * @param p <code>Point</code> on the figure that gives a hint which anchor to return.
1185,1185c1081,1081
<      * @return ConnectionAnchor reference to an anchor associated with the given point on the figure.
---
> 	 * @return <code>ConnectionAnchor</code> reference to an anchor associated with the 
1185a1082,1086
> 	 * given point on the figure.
> 	 */
> 	protected ConnectionAnchor createConnectionAnchor(Point p) {
> 		if (p == null) {
> 			return getConnectionAnchor(szAnchor);
1186a1058,1060
> 	protected ConnectionAnchor createDefaultAnchor() {
> 		return new BaseSlidableAnchor(this);
> 	}
1187,1187d1057
<     protected ConnectionAnchor createConnectionAnchor(Point p) {
1188a1062,1075
> 	/**
> 	 * Creates a slidable anchor at the specified point (from the ratio of the
> 	 * reference's coordinates and bounds of the figure
> 	 * 
> 	 * @param p - relative reference for the <Code>SlidableAnchor</Code>
> 	 * @return a <code>SlidableAnchor</code> for this figure with relative reference at p
> 	 */
> 	protected ConnectionAnchor createAnchor(PrecisionPoint p) {
> 		if (p==null)
> 			// If the old terminal for the connection anchor cannot be resolved (by SlidableAnchor) a null
> 			// PrecisionPoint will passed in - this is handled here
> 			return createDefaultAnchor();
> 		return new BaseSlidableAnchor(this, p);
> 	}
1189,1190d1061
<         ConnectionAnchor connectionAnchor = null;
<         int fromEnd = 0;
1192,1193d1076
<         if (p.x < 0) {  // if negative - return an anchor at the center
<             connectionAnchor = new PolylineAnchor(this, fromEnd = 50);
1195a1089,1093
> 			Point temp = p.getCopy();
> 			translateToRelative(temp);
> 			PrecisionPoint pt = BaseSlidableAnchor.getAnchorRelativeLocation(temp, getBounds());
> 			return createAnchor(pt);
> 		}
1196,1197d1088
<             PointInfo pInfo = getPointInfo(p);
<             connectionAnchor = new PolylineAnchor(this, fromEnd = pInfo.fromEnd);
1199a1096,1107
> 	/**
> 	 * Checks whether the <PrecisionPoint> p which is a candidate for a relative reference
> 	 * for the <Code>SlidableAnchor</Code> belongs to the area where the default anchor
> 	 * must be created
> 	 * 
> 	 * @param p
> 	 * @return <code>boolean</code> <code>true</code> if <PrecisionPoint> belongs to the area where the default anchor must be 
> 	 * created, <code>false</code> otherwise
> 	 */
> 	protected boolean isDefaultAnchorArea(PrecisionPoint p) {
> 		return p.preciseX >= getSlidableAnchorArea()/2 && p.preciseX <= 1 - getSlidableAnchorArea()/2 &&
> 			p.preciseY >= getSlidableAnchorArea()/2 && p.preciseY <= 1 - getSlidableAnchorArea()/2;
1200,1202d1095
<         if (connectionAnchor != null) {
<             String szKey = szAnchor + fromEnd;
<             getConnectionAnchors().put(szKey, connectionAnchor);
1205,1205d1109
<         return connectionAnchor;
