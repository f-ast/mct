14a15,15
> import org.eclipse.core.commands.operations.IUndoableOperation;
21,21d21
< import org.eclipse.emf.workspace.AbstractEMFOperation;
38a39,39
>  * @auther ldamus
95a97,100
>         	// Run in a composite transactional operation so that subclasses can
> 			// both read and write to the model. Commands executed by subclasses
> 			// to modify the model will be appended to this composite
> 			// transactional operation.
96,103d96
<             // run in an EMF operation so that subclasses can both read and
<             // write to the model
<             AbstractEMFOperation operation = new AbstractEMFOperation(
<                 getEditingDomain(), getLabel()) {
< 
<                 protected IStatus doExecute(IProgressMonitor monitor,
<                         IAdaptable info)
<                     throws ExecutionException {
104a102,103
>         	Runnable runnable = new Runnable() {
> 				public void run() {
105a105,106
> 							.run(progressMonitor);
> 				}
105,105c104,104
<                     AbstractModelActionHandler.super.run(progressMonitor);
---
> 					AbstractModelActionHandler.super
106,107d104
<                     return getStatus();
<                 };
109a116,117
> 			};
> 			
109a109,111
>         	WriteCommand write = new WriteCommand(getEditingDomain(),
> 					getLabel(), getActionManager().getOperationHistory(),
> 					runnable) {
110,111d115
<             try {
<                 getActionManager().getOperationHistory().execute(operation,
112,112c118,118
<                     new NullProgressMonitor(), null);
---
>             execute(write, new NullProgressMonitor(), null);
113a113,114
> 				public IStatus getStatus() {
> 					return AbstractModelActionHandler.this.getStatus();
113a164,183
>     /**
> 	 * Convenience method for subclasses to execute an undoable operation on the
> 	 * action manager's operation history. Sets my status to the status of the
> 	 * operation execution, and returns that status.
> 	 * 
> 	 * @param operation
> 	 *            the operation to be executed
> 	 * @param progressMonitor
> 	 *            the progress monitor
> 	 * @param info
> 	 *            the adaptable info, may be <code>null</code>
> 	 * @return the status of the operation execution.
> 	 */
> 	protected IStatus execute(IUndoableOperation operation,
> 			IProgressMonitor progressMonitor, IAdaptable info) {
> 
> 		try {
> 			setStatus(getActionManager().getOperationHistory().execute(
> 					operation, progressMonitor, info));
> 
114,114c184,184
<             } catch (ExecutionException e) {
---
> 		} catch (ExecutionException e) {
114a185,185
> 			setStatus(new Status(Status.ERROR, MslUIPlugin.getPluginId(),
115,119d184
<                 Trace
<                     .catching(MslUIPlugin.getDefault(),
<                         MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
<                         "run", e); //$NON-NLS-1$
<                 Log.error(MslUIPlugin.getDefault(),
120a187,193
> 							.getLocalizedMessage(), e));
> 			Trace
> 					.catching(MslUIPlugin.getDefault(),
> 							MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
> 							"run", e); //$NON-NLS-1$
> 			Log.error(MslUIPlugin.getDefault(),
> 					MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
120,120c186,186
<                     MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
---
> 					MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
121a195,198
> 		}
> 		return getStatus();
> 	}
> 
121,121c194,194
<                         .getLocalizedMessage(), e);
---
> 							.getLocalizedMessage(), e);
