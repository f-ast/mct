2,2c2,2
<  * Copyright (c) 2002, 2005 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2007 IBM Corporation and others.
19a21,21
> import org.eclipse.draw2d.AutomaticRouter;
22a25,26
> import org.eclipse.draw2d.ConnectionAnchor;
> import org.eclipse.draw2d.geometry.Dimension;
24a29,29
> import org.eclipse.draw2d.geometry.PrecisionPoint;
25,25c30,30
< import org.eclipse.draw2d.geometry.Rectangle;
---
> import org.eclipse.draw2d.geometry.PrecisionRectangle;
31a37,37
> import org.eclipse.gef.handles.BendpointCreationHandle;
37,37c40,40
< import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.OrthogonalRouterUtilities;
---
> import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
39a46,46
> import org.eclipse.gmf.runtime.gef.ui.internal.handles.BendpointMoveHandleEx;
41,41c19,19
< import org.eclipse.jface.util.Assert;
---
> import org.eclipse.core.runtime.Assert;
152,152c158,158
< 				new BendpointMoveHandle(
---
> 				new BendpointMoveHandleEx(
336,336c342,342
< 			OrthogonalRouterUtilities.resetEndPointsToCenter(getConnection(), pts);
---
> 			//OrthogonalRouterUtilities.resetEndPointsToCenter(getConnection(), pts);
559,559c565,565
< 			if (REQ_CREATE_BENDPOINT.equals(request.getType())
---
> 			if (REQ_CREATE_BENDPOINT.equals(request.getType())) {
560,560d565
< 				|| REQ_MOVE_BENDPOINT.equals(request.getType())) {
561a567,568
> 			} else if (REQ_MOVE_BENDPOINT.equals(request.getType())) {
> 				showMoveOrthogonalBenspointFeedback((BendpointRequest) request);
636a645,645
> 			new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getConnection().getSourceAnchor().getOwner()));
636,636c644,644
< 		Rectangle startRect =
---
> 		PrecisionRectangle startRect =
637,638d644
< 			new Rectangle(
< 				getConnection().getSourceAnchor().getOwner().getBounds());
640a648,654
> 		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
> 			if (line.isHorizontal()) {
> 				startRect.shrink(0, 2);
> 			} else {
> 				startRect.shrink(2, 0);
> 			}
> 		}
641,644d647
< 		getConnection().translateToRelative(startRect);
< 		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED))
< 			startRect.expand(MapModeUtil.getMapMode(getConnection()).DPtoLP(-2), 
< 							MapModeUtil.getMapMode(getConnection()).DPtoLP(-2));
645a656,661
> 		getConnection().translateToRelative(startRect);
> 		/*
> 		 * Rectangle needs to be expanded by the "odd" number below because the number after
> 		 * translations could be N.999999999... 
> 		 */
> 		if (!startRect.expand(0.000001, 0.000001).contains(new PrecisionPoint(line.getOrigin()))) {
646,646d655
< 		if (!startRect.contains(line.getOrigin())) {
655,655c670,670
< 	* Utility method to determine if the constraint needs to be adjusted becauase the line is
---
> 	* Utility method to determine if the constraint needs to be adjusted because the line is
664a680,680
> 			new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getConnection().getTargetAnchor().getOwner()));
664,664c679,679
< 		Rectangle endRect =
---
> 		PrecisionRectangle endRect =
665,666d679
< 			new Rectangle(
< 				getConnection().getTargetAnchor().getOwner().getBounds());
668a683,689
> 		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
> 			if (line.isHorizontal()) {
> 				endRect.shrink(0, 2);
> 			} else {
> 				endRect.shrink(2, 0);
> 			}
> 		}
669,672d682
< 		getConnection().translateToRelative(endRect);
< 		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED))
< 			endRect.expand(MapModeUtil.getMapMode(getConnection()).DPtoLP(-2), 
< 						MapModeUtil.getMapMode(getConnection()).DPtoLP(-2)); 
673a691,696
> 		/*
> 		 * Rectangle needs to be expanded by the "odd" number below because the number after
> 		 * translations could be N.999999999... 
> 		 */
> 		getConnection().translateToRelative(endRect);
> 		if (!endRect.expand(0.00001, 0.00001).contains(new PrecisionPoint(line.getTerminus()))) {
674,674d690
< 		if (!endRect.contains(line.getTerminus())) {
701a724,724
> 	 * Draws feedback for moving a bend point of a rectilinear connection
702,703d723
< 	* Method showOutsideSourceFeedback.
< 	* Adds a bendpoint to the beginning of the constraint.
704a726,726
> 	 * @param request Benndpoint request
705,705d725
< 	* @param constraint List of bendpoints that the source point will be added too.
706a728,730
> 	private void showMoveOrthogonalBenspointFeedback(BendpointRequest request) {
> 		if (getFeedbackState().originalConstraint == null) {
> 			saveOriginalConstraint();
707,710d727
< 	protected void showOutsideSourceFeedback(List constraint) {
< 		Point ptAdd = ((Bendpoint) constraint.get(0)).getLocation();
< 		Bendpoint bp = new AbsoluteBendpoint(ptAdd);
< 		constraint.add(0, bp);
712a733,756
> 		Point ptLoc = new Point(request.getLocation());
> 		List constraint = (List)
> 			getConnection().getRoutingConstraint();
> 		
> 		getConnection().translateToRelative(ptLoc);
> 		
> 		int index =
> 		getFeedbackState().isOutsideSource ? request.getIndex() + 1 : request.getIndex();
> 		
> 		Point previous = ((Bendpoint)constraint.get(index - 1)).getLocation();
> 		Point moving = ((Bendpoint)constraint.get(index)).getLocation();
> 		Point next = ((Bendpoint)constraint.get(index + 1)).getLocation();
> 		
> 		LineSeg originalFirst = new LineSeg(previous.getCopy(), moving.getCopy());
> 		LineSeg originalSecond = new LineSeg(moving.getCopy(), next.getCopy());
> 		
> 		Dimension diff = ptLoc.getDifference(moving);
> 		
> 		if (originalFirst.isHorizontal()) {
> 			previous.y += diff.height;
> 			next.x += diff.width;
> 		} else {
> 			previous.x += diff.width;
> 			next.y += diff.height;
713,724d732
< 	/**
< 	* Method showOutsideTargetFeedback.
< 	* Adds a bendpoint to the end of the constraint.
< 	* 
< 	* @param constraint List of bendpoints that the target point will be added too.
< 	*/
< 	protected void showOutsideTargetFeedback(List constraint) {
< 		Point ptAdd =
< 			((Bendpoint) constraint.get(constraint.size() - 1))
< 				.getLocation();
< 		Bendpoint bp = new AbsoluteBendpoint(ptAdd);
< 		constraint.add(constraint.size() - 1, bp);
726a759,770
> 		LineSeg movedFirst = new LineSeg(previous, ptLoc.getCopy());
> 		LineSeg movedSecond = new LineSeg(ptLoc.getCopy(), next);
> 		
> 		index = adjustOutsideBoundsLineFeedback(movedFirst, index - 1, constraint, originalFirst);
> 		constraint.set(index, new AbsoluteBendpoint(movedFirst.getOrigin()));
> 		constraint.set(index + 1, new AbsoluteBendpoint(movedFirst.getTerminus()));
> 		
> 		index = adjustOutsideBoundsLineFeedback(movedSecond, index + 1, constraint, originalSecond);
> 		constraint.set(index + 1, new AbsoluteBendpoint(movedSecond.getTerminus()));
> 		
> 		getConnection().setRoutingConstraint(constraint);	}
> 
751,759d794
< 		if (!newLine.isHorizontal() && !newLine.isVertical()) {
< 			if (Math.abs(newLine.getOrigin().x - newLine.getTerminus().x) < 
< 				Math.abs(newLine.getOrigin().y - newLine.getTerminus().y)) {
< 				newLine.setTerminus(new Point(newLine.getOrigin().x, newLine.getTerminus().y));
< 			}
< 			else {
< 				newLine.setTerminus(new Point(newLine.getTerminus().x, newLine.getOrigin().y));
< 			}
< 		}
761,761c796,796
< 		index = adjustOutsideBoundsLineFeedback(request, constraint, index, newLine);
---
> 		index = adjustOutsideBoundsLineFeedback(newLine, index, constraint, moveLine);
763a799,799
> 		
770a808,808
> 	 * @param index the index
771,771d807
< 	 * @param request BendpointRequest that triggered the gesture
772,772c809,809
< 	 * @param constraint List of Bendpoint objects that is the constraint to the gesture.
---
> 	 * @param constraint List of Bendpoint objects that is the constraint to the gesture.
773,773c810,810
< 	 * @param index int index of the line that the user is currently manipulating.
---
> 	 * @param moveLine original segment that is being manipulated
777,777c813,813
< 	protected int adjustOutsideBoundsLineFeedback(BendpointRequest request, List constraint, int index, LineSeg newLine) {
---
> 	private int adjustOutsideBoundsLineFeedback(LineSeg newLine, int index, List constraint, LineSeg moveLine) {
778,778d813
< 		
782a864,865
> 			showOutsideSourceFeedback(newLine, moveLine, constraint);
> 			index++;
783,783d863
< 				LineSeg moveLine = getLineSeg(constraint, index + 1);
797,797c831,831
< 		if (request.getIndex() == 0 && lineOutsideSource(newLine)) {
---
> 		if (index == 0 && lineOutsideSource(newLine)) {
802,802c836,836
< 		} else if (getFeedbackState().isOutsideSource) {
---
> 		} else if (index == 1 && getFeedbackState().isOutsideSource && !lineOutsideSource(newLine)) {
815a850,850
> 				&& !lineOutsideTarget(newLine)) {
815,815c849,849
< 		} else if (getFeedbackState().isOutsideTarget) {
---
> 		} else if (checkTargetIndex == constraint.size() - 2 && getFeedbackState().isOutsideTarget
818a570,570
> 			
819,819d569
< 
821a856,856
> 			index--;
822,822d855
< 			index = request.getIndex();
830,831d863
< 			showOutsideSourceFeedback(constraint);
< 			index = request.getIndex() + 1;
835,835c869,869
< 			showOutsideTargetFeedback(constraint);
---
> 			showOutsideTargetFeedback(newLine, moveLine, constraint);
840a875,927
> 	* Method showOutsideSourceFeedback.
> 	* Adds a bendpoint to the beginning of the constraint.
> 	* Also adjusts the new segment with respect to added constraint
> 	* 
> 	* @param constraint List of bendpoints that the source point will be added too.
> 	*/
> 	private void showOutsideSourceFeedback(LineSeg newLine, LineSeg moveLine, List constraint) {
> 		Connection conn = (Connection)getHostFigure();
> 		ConnectionAnchor anchor = conn.getSourceAnchor();
> 		PrecisionPoint startPoint = new PrecisionPoint(anchor.getOwner().getBounds().getCenter());
> 		anchor.getOwner().translateToAbsolute(startPoint);
> 		conn.translateToRelative(startPoint);
> 		PrecisionRectangle bounds = new PrecisionRectangle(anchor.getOwner().getBounds());
> 		anchor.getOwner().translateToAbsolute(bounds);
> 		conn.translateToRelative(bounds);
> 		Point origin = new Point(newLine.getOrigin());
> 		if (moveLine.isHorizontal()) {
> 			origin.x = startPoint.x;
> 		} else {
> 			origin.y = startPoint.y;
> 		}
> 		newLine.setOrigin(origin);
> 		constraint.add(0, new AbsoluteBendpoint(startPoint));
> 		
> 	}
> 
> 	/**
> 	* Method showOutsideTargetFeedback.
> 	* Adds a bendpoint to the end of the constraint.
> 	* Also adjusts the new segment with respect to added constraint
> 	* 
> 	* @param constraint List of bendpoints that the target point will be added too.
> 	*/
> 	private void showOutsideTargetFeedback(LineSeg newLine, LineSeg moveLine, List constraint) {
> 		Connection conn = (Connection)getHostFigure();
> 		ConnectionAnchor anchor = conn.getTargetAnchor();
> 		PrecisionPoint endPoint = new PrecisionPoint(anchor.getOwner().getBounds().getCenter());
> 		anchor.getOwner().translateToAbsolute(endPoint);
> 		conn.translateToRelative(endPoint);
> 		PrecisionRectangle bounds = new PrecisionRectangle(anchor.getOwner().getBounds());
> 		anchor.getOwner().translateToAbsolute(bounds);
> 		conn.translateToRelative(bounds);
> 		Point terminus = new Point(newLine.getTerminus()); 
> 		if (moveLine.isHorizontal()) {
> 			terminus.x = endPoint.x;
> 		} else {
> 			terminus.y = endPoint.y;
> 		}
> 		newLine.setTerminus(terminus);
> 		constraint.add(new AbsoluteBendpoint(endPoint));
> 	}
> 
> 	/**
