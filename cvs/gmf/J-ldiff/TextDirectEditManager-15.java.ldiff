14a15,18
> import java.util.ArrayList;
> import java.util.Iterator;
> import java.util.List;
> 
17a22,22
> import org.eclipse.draw2d.PositionConstants;
20a26,26
> import org.eclipse.gef.editparts.ZoomManager;
22a29,30
> import org.eclipse.gmf.runtime.common.core.util.Log;
> import org.eclipse.gmf.runtime.common.core.util.Trace;
25a34,34
> import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
26,26c35,35
< import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;
---
> import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
26a36,37
> import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
> import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
27a39,39
> import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
30a43,47
> import org.eclipse.jface.action.IAction;
> import org.eclipse.jface.resource.DeviceResourceException;
> import org.eclipse.jface.resource.FontDescriptor;
> import org.eclipse.jface.resource.JFaceResources;
> import org.eclipse.jface.resource.ResourceManager;
45a63,68
> import org.eclipse.ui.IActionBars;
> import org.eclipse.ui.PlatformUI;
> import org.eclipse.ui.actions.ActionFactory;
> import org.eclipse.ui.part.CellEditorActionHandler;
> 
> import com.ibm.icu.util.StringTokenizer;
74a98,111
>      * Cache the font descriptor when a font is created so that it can be
>      * disposed later.
>      */
>     private List cachedFontDescriptors = new ArrayList();
>     
>     private IActionBars actionBars;
>     private CellEditorActionHandler actionHandler;
>     private IAction copy, cut, paste, undo, redo, find, selectAll, delete;
>     
>     private Font zoomLevelFont = null;
>     
>     private CellEditorLocator locator;
> 		
> 	/**
95,96d131
< 			Rectangle rect = getWrapLabel().getTextBounds().getCopy();
< 			getWrapLabel().translateToAbsolute(rect);
98,99d144
< 			if (getWrapLabel().isTextWrapped() && getWrapLabel().getText().length() > 0)
< 				rect.setSize(new Dimension(text.computeSize(rect.width, SWT.DEFAULT)));
100a132,136
>             WrapLabel fig = getWrapLabel();
>             
>             Rectangle rect = fig.getTextBounds().getCopy();
>             fig.translateToAbsolute(rect);
>             
100a152,156
>                     if (text.getBounds().x == 0 || Math.abs(text.getBounds().x - newRect.x) >= avrWidth)
>                         text.setBounds(newRect.x, newRect.y, newRect.width + avrWidth*3, newRect.height);
>                     else
>                         text.setBounds(text.getBounds().x, newRect.y, newRect.width + avrWidth*3, newRect.height);
>                 }   
101a138,142
>             
>             
>             if (fig.isTextWrapped() && fig.getText().length() > 0)
>                 rect.setSize(new Dimension(rect.width, rect.height + FigureUtilities.getFontMetrics(text.getFont()).getDescent()));
>             else
101,101c137,137
< 				int avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
---
>             int avrWidth = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
102,102c143,143
< 				rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr*2, 0));
---
>                 rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avrWidth*2, 0));
103a181,181
> 			org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
104,104d180
< 
105,105c182,182
< 			if (!rect.equals(new Rectangle(text.getBounds())))
---
> 			if (!newRect.equals(new Rectangle(text.getBounds())))
106,106c183,183
< 				text.setBounds(rect.x, rect.y, rect.width, rect.height);
---
> 				text.setBounds(newRect.x, newRect.y, newRect.width, newRect.height);
108,108c272,272
< 
---
> 	
130a145,146
>             org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
>             
131,131c147,147
< 			if (!rect.equals(new Rectangle(text.getBounds())))
---
>             Rectangle textBounds = new Rectangle(text.getBounds());
131a148,149
>             if (!newRect.equals(textBounds)) {
>                 if (!(fig.getTextWrapAlignment() == PositionConstants.LEFT || fig.getTextAlignment() == PositionConstants.LEFT))
132,132c150,150
< 				text.setBounds(rect.x, rect.y, rect.width, rect.height);
---
>                     text.setBounds(newRect.x, newRect.y, newRect.width + avrWidth*3, newRect.height);
143,143c194,194
< 		super(source, getTextCellEditorClass(source), getTextCellEditorLocator(source));
---
> 		this(source, getTextCellEditorClass(source), getTextCellEditorLocator(source));
152a204,204
> 		this.locator = locator;
205a258,269
>         try {
>             FontDescriptor fontDescriptor = FontDescriptor.createFrom(data);
>             cachedFontDescriptors.add(fontDescriptor);
>             return getResourceManager().createFont(fontDescriptor);
>         } catch (DeviceResourceException e) {
>             Trace.catching(DiagramUIPlugin.getInstance(),
>                 DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
>                 "getScaledFont", e); //$NON-NLS-1$
>             Log.error(DiagramUIPlugin.getInstance(),
>                 DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "getScaledFont", e); //$NON-NLS-1$
>         }
>         return JFaceResources.getDefaultFont();
206,208d257
< 		data.setHeight(fontSize.height);
< 		Font newFont = DiagramFontRegistry.getInstance().getFont(null, data);
< 		return newFont;
243a306,314
> 		
> 		//Hook the cell editor's copy/paste actions to the actionBars so that they can
> 		// be invoked via keyboard shortcuts.
> 		actionBars = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage()
> 				.getActiveEditor().getEditorSite().getActionBars();
> 		saveCurrentActions(actionBars);
> 		actionHandler = new CellEditorActionHandler(actionBars);
> 		actionHandler.addCellEditor(getCellEditor());
> 		actionBars.updateActionBars();
300a372,386
>         
>         for (Iterator iter = cachedFontDescriptors.iterator(); iter.hasNext();) {
>             getResourceManager().destroyFont((FontDescriptor) iter.next());           
>         }
>         cachedFontDescriptors.clear();
>         
>         if (actionHandler != null) {
>     		actionHandler.dispose();
>     		actionHandler = null;
>     	}
>     	if (actionBars != null) {
>     		restoreSavedActions(actionBars);
>     		actionBars.updateActionBars();
>     		actionBars = null;
>     	}
351a438,495
> 	}
> 	
>     /**
>      * This method obtains the fonts that are being used by the figure at its zoom level.
>      * @param gep the associated <code>GraphicalEditPart</code> of the figure
>      * @param actualFont font being used by the figure
>      * @param display
>      * @return <code>actualFont</code> if zoom level is 1.0 (or when there's an error),
>      * new Font otherwise.
>      */
> 	private Font getZoomLevelFont(Font actualFont, Display display) {
> 		Object zoom = getEditPart().getViewer().getProperty(ZoomManager.class.toString());
> 		
> 		if (zoom != null) {
> 			double zoomLevel = ((ZoomManager)zoom).getZoom();
> 			
> 			if (zoomLevel == 1.0f) 
> 				return actualFont;
> 			
> 			FontData[] fd = new FontData[actualFont.getFontData().length];
> 			FontData tempFD = null;
> 			
> 			for (int i=0; i < fd.length; i++) {
> 				tempFD = actualFont.getFontData()[i];
> 				
> 				fd[i] = new FontData(tempFD.getName(),(int)(zoomLevel * tempFD.getHeight()),tempFD.getStyle());
> 			}
> 			
>             try {
>                 FontDescriptor fontDescriptor = FontDescriptor.createFrom(fd);
>                 cachedFontDescriptors.add(fontDescriptor);
>                 return getResourceManager().createFont(fontDescriptor);
>             } catch (DeviceResourceException e) {
>                 Trace.catching(DiagramUIPlugin.getInstance(),
>                     DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
>                     "getZoomLevelFonts", e); //$NON-NLS-1$
>                 Log.error(DiagramUIPlugin.getInstance(),
>                     DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "getZoomLevelFonts", e); //$NON-NLS-1$
>                 
>                 return actualFont;
>             }
> 		}
> 		else
> 			return actualFont;
> 	}
> 	
> 	/**
> 	 * Gets the tex extent scaled to the mapping mode
> 	 */
> 	private Dimension getTextExtents(String s, Font font, IMapMode mm) {
> 		Dimension d = FigureUtilities.getTextExtents(s, font);
>         // height should be set using the font height and the number of lines
>         // in the string 
>         int lineCount = getLineCount(s);
>         d.height = FigureUtilities.getFontMetrics(font).getHeight()*lineCount;
>         
>      	return new Dimension(mm.DPtoLP(d.width), mm.DPtoLP(d.height));
> 	}
352a497,512
>     private int getLineCount(String s) {
>         StringTokenizer tokenizer = new StringTokenizer(s, "\n"); //$NON-NLS-1$
>         return tokenizer.countTokens();
>     }
> 
>     public void show() {
>     	super.show();
>     	
>     	WrapLabel fig = ((TextCompartmentEditPart)this.getEditPart()).getLabel();
> 		Control control = getCellEditor().getControl();
> 		this.zoomLevelFont = getZoomLevelFont(fig.getFont(), control.getDisplay());
> 		
>         control.setFont(this.zoomLevelFont);
>         
>         //since the font's have been resized, we need to resize the  Text control...
>         locator.relocate(getCellEditor());
366a527,617
> 		
> 		if (!(getEditPart() instanceof TextCompartmentEditPart)) {
> 			sendClickToCellEditor(location);
> 			return;
> 		}
> 		
> 		WrapLabel fig = ((TextCompartmentEditPart)this.getEditPart()).getLabel();
> 		Text textControl = (Text)getCellEditor().getControl();
> 		
> 		//we need to restore our wraplabel figure bounds after we are done
> 		Rectangle restoreRect = fig.getBounds().getCopy();
> 		
> 		Rectangle rect = fig.getBounds();
> 		fig.translateToAbsolute(rect);
>         
>         if (!rect.contains(new org.eclipse.draw2d.geometry.Point(location.x,location.y))) {
>             textControl.setSelection(0, textControl.getText().length());
>             fig.setBounds(restoreRect);
>             return;
>         }
> 		
> 		Rectangle iconBounds = fig.getIconBounds().getCopy();
> 		fig.translateToAbsolute(iconBounds);
> 
> 		double avrLines =  fig.getBounds().height / (double)FigureUtilities.getFontMetrics(this.zoomLevelFont).getHeight();
> 		
> 		int xWidth = location.x - rect.x;
> 		
> 		if (fig.getIcon() != null && fig.getTextPlacement() == PositionConstants.EAST) 
> 			xWidth -= iconBounds.width;
> 		
> 		double yPercentage = (location.y - rect.y) / (double)rect.height;
> 		
> 		//calculate the line number the mouse clicked on.
> 		int lineNum = (int)Math.ceil(avrLines * yPercentage);
> 		
> 		//character count for caret positioning...
> 		int charCount = 0;
> 		
> 		StringTokenizer tokenizer = new StringTokenizer(fig.getSubStringText(), "\n"); //$NON-NLS-1$
> 
> 		//calculate the total characters before linePos...
> 		for (int lineCount = 1; lineCount < lineNum; lineCount++) {
> 			if (tokenizer.hasMoreTokens()) {
> 				charCount += tokenizer.nextToken().length();
> 				
> 				//check if there is a user-inserted new line which will be accounted in the Text control...
> 				String newLineCheck = fig.getText().substring(charCount,charCount+1); 
> 				if (newLineCheck.equals("\r") || newLineCheck.equals("\n"))	//$NON-NLS-1$ //$NON-NLS-2$
> 					charCount++;
> 			}
> 			else {
> 				//our linePos calculation was wrong...revert to sending a mouse click...
> 				sendClickToCellEditor(location);
> 				fig.setBounds(restoreRect);
> 				return;
> 			}
> 		}
> 		
> 		//now count the last line's characters till the point where the mouse clicked...
> 		if (tokenizer.hasMoreTokens()) {
> 			String currentLineText = tokenizer.nextToken();
> 			
> 			IMapMode mm = MapModeUtil.getMapMode(fig);
> 			
> 			for (int i = 1; i <= currentLineText.length(); i++) {
> 				Dimension textExtent = getTextExtents(currentLineText.substring(0, i), this.zoomLevelFont, mm);
> 				fig.translateToAbsolute(textExtent);
> 				
> 				charCount++;
> 				
> 				if (textExtent.width >= xWidth)
> 					break;
> 			}
> 			
> 			textControl.setSelection(charCount);
> 			
> 			fig.setBounds(restoreRect);
> 			
> 		}
> 		else {
> 			//our linePos calculation was wrong...revert to sending a mouse click...
> 			sendClickToCellEditor(location);
> 			fig.setBounds(restoreRect);
> 		}
> 	}
> 	
> 	private void sendClickToCellEditor(final Point location) {
> 		//make sure the diagram doesn't receive the click event..
> 		getCellEditor().getControl().setCapture(true);
> 		
367,367d526
< 		// Send another click if the previous one is within the editor bounds 
430a681,718
>     /**
>      * Gets the resource manager to remember the resources allocated for this
>      * graphical viewer. All resources will be disposed when the graphical
>      * viewer is closed if they have not already been disposed.
>      * @return
>      */
>     protected ResourceManager getResourceManager() {
>         return ((DiagramGraphicalViewer) getEditPart().getViewer())
>             .getResourceManager();
>     }
>     
>     private void saveCurrentActions(IActionBars _actionBars) {
>     	copy = _actionBars.getGlobalActionHandler(ActionFactory.COPY.getId());
>     	paste = _actionBars.getGlobalActionHandler(ActionFactory.PASTE.getId());
>     	delete = _actionBars.getGlobalActionHandler(ActionFactory.DELETE.getId());
>     	selectAll = _actionBars.getGlobalActionHandler(ActionFactory.SELECT_ALL.getId());
>     	cut = _actionBars.getGlobalActionHandler(ActionFactory.CUT.getId());
>     	find = _actionBars.getGlobalActionHandler(ActionFactory.FIND.getId());
>     	undo = _actionBars.getGlobalActionHandler(ActionFactory.UNDO.getId());
>     	redo = _actionBars.getGlobalActionHandler(ActionFactory.REDO.getId());
>     }
>     
>     private void restoreSavedActions(IActionBars _actionBars){
>     	_actionBars.setGlobalActionHandler(ActionFactory.COPY.getId(), copy);
>     	_actionBars.setGlobalActionHandler(ActionFactory.PASTE.getId(), paste);
>     	_actionBars.setGlobalActionHandler(ActionFactory.DELETE.getId(), delete);
>     	_actionBars.setGlobalActionHandler(ActionFactory.SELECT_ALL.getId(), selectAll);
>     	_actionBars.setGlobalActionHandler(ActionFactory.CUT.getId(), cut);
>     	_actionBars.setGlobalActionHandler(ActionFactory.FIND.getId(), find);
>     	_actionBars.setGlobalActionHandler(ActionFactory.UNDO.getId(), undo);
>     	_actionBars.setGlobalActionHandler(ActionFactory.REDO.getId(), redo);
>     }
> 
>     public void setLocator(CellEditorLocator locator) {
>         super.setLocator(locator);
>         this.locator = locator;
>     }
> 
