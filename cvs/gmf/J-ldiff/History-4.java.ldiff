14a15,15
> import java.util.HashSet;
15a17,17
> import java.util.Set;
24a27,27
>  * Keep track of gmfmap-to-gmfgen transformation elements.
25,25d26
<  * We don't suppose to reuse GenTopLevelNodes, thus API references GenChildNodes
30,30c32,32
< 	private final Map/*<NodeMapping, GenChildNode>*/ myNodeMap;
---
> 	private final Map/*<NodeMapping, Set<GenChildNode>>*/ myNodeMap;
38a41,43
> 	/**
> 	 * No more then 1 GenTopLevelNode may be logged for node mapping 
> 	 */
41,47d45
< 		// TODO leave only asserts
< 		if (nodeMap == null || genNode == null) {
< 			throw new NullPointerException();
< 		}
< 		if (myTopNodeMap.containsKey(nodeMap)) {
< 			throw new IllegalArgumentException(nodeMap.toString());
< 		}
50a49,52
> 	/**
> 	 * More than 1 GenChildNode may be logged for node mapping  
> 	 * (to handle children taken from different containment/children features)
> 	 */
52,53d53
< 		assert nodeMap != null && genNode != null && !myNodeMap.containsKey(nodeMap);
< 		// TODO leave only asserts
54a55,58
> 		Set genNodes = (Set) myNodeMap.get(nodeMap);
> 		if (genNodes == null) {
> 			genNodes = new HashSet/*<GenChildNode>*/();
> 			myNodeMap.put(nodeMap, genNodes);
54,54c54,54
< 		if (nodeMap == null || genNode == null) {
---
> 		assert nodeMap != null && genNode != null;
55,58d54
< 			throw new NullPointerException();
< 		}
< 		if (myNodeMap.containsKey(nodeMap)) {
< 			throw new IllegalArgumentException(nodeMap.toString());
59a60,60
> 		genNodes.add(genNode);
60,60d59
< 		myNodeMap.put(nodeMap, genNode);
62a63,65
> 	/**
> 	 * No more than 1 GenLink is allowed for link mapping.
> 	 */
69,69d71
< 		assert nodeMap != null;
70,70c72,72
< 		return myTopNodeMap.containsKey(nodeMap) || myNodeMap.containsKey(nodeMap);
---
> 		return isKnownTopNode(nodeMap) || isKnownChildNode(nodeMap);
79a82,83
> 		// We don't check stored collections as there's no means to remove element from this history,
> 		// thus, no way to get empty collection
87a92,94
> 	/**
> 	 * @return never <code>null</code>>
> 	 */
88,88c95,95
< 	public GenChildNode findChildNode(NodeMapping nodeMap) {
---
> 	public GenChildNode[] findChildNodes(NodeMapping nodeMap) {
90,90c97,97
< 		return (GenChildNode) myNodeMap.get(nodeMap);
---
> 		Set genNodes = (Set) myNodeMap.get(nodeMap);
90a98,101
> 		if (genNodes == null) {
> 			return new GenChildNode[0];
> 		}
> 		return (GenChildNode[]) genNodes.toArray(new GenChildNode[genNodes.size()]);
98,98c109,109
< 	public GenNode find(NodeMapping nodeMap) {
---
> 	public GenNode[] find(NodeMapping nodeMap) {
101,101c112,112
< 		return genNode != null ? genNode : findChildNode(nodeMap);
---
> 		return genNode != null ? new GenNode[] {genNode} : findChildNodes(nodeMap);
