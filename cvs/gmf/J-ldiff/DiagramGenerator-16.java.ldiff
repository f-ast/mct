636,636c636,636
< 		List result = new ArrayList();
---
> 		List<PartPositionInfo> result = new ArrayList<PartPositionInfo>();
637,637c637,637
< 		List editParts = new ArrayList();
---
> 		List<IGraphicalEditPart> editParts = new ArrayList<IGraphicalEditPart>();
639,639c639,639
< 		List children = diagramEditPart.getPrimaryEditParts();
---
> 		List<IGraphicalEditPart> children = (List<IGraphicalEditPart>) diagramEditPart.getPrimaryEditParts();
647a648,648
> 		for (IGraphicalEditPart part : children) {
648,650d647
< 		Iterator li = children.iterator();
< 		while (li.hasNext()) {
< 			IGraphicalEditPart part = (IGraphicalEditPart) li.next();
654a653,653
> 		for (IGraphicalEditPart part : editParts) {
655,657d652
< 		Iterator iter = editParts.iterator();
< 		while (iter.hasNext()) {
< 			IGraphicalEditPart part = (IGraphicalEditPart) iter.next();
694,694c690,690
< 					List envelopingPts = calculateEnvelopingPolyline(mainPts,
---
> 					List<Point> envelopingPts = calculateEnvelopingPolyline(mainPts,
695a692,774
> 					List<Point> transformedPts = convertPolylineUnits(envelopingPts);
> 
> 					position.setPolyline(transformedPts);
> 					result.add(0, position);
> 				}
> 			}
> 		}
> 		return result;
> 	}
> 	
> 	public List<PartPositionInfo> getConstrainedDiagramPartInfo(int maxWidth, int maxHeight, boolean useMargins) {
> 		return getConstrainedDiagramPartInfo(_dgrmEP, maxWidth, maxHeight, useMargins);
> 	}
> 	
> 	public List<PartPositionInfo> getConstrainedDiagramPartInfo(DiagramEditPart diagramEditPart, int maxWidth, int maxHeight, boolean useMargins) {
> 		List<PartPositionInfo> result = new ArrayList<PartPositionInfo>();
> 		List<IGraphicalEditPart> editParts = new ArrayList<IGraphicalEditPart>();
> 
> 		List<IGraphicalEditPart> children = (List<IGraphicalEditPart>) diagramEditPart.getPrimaryEditParts();
> 		IMapMode mm = getMapMode();
> 
> 		// We will use the diagram generate that was used to generate the image
> 		// to figure out the outer-bound rectangle so that we are calculating
> 		// the
> 		// image positions using the same box as was used to create the image.
> 		ConstrainedImageRenderingData data = getConstrainedImageRenderingData(children, maxWidth, maxHeight, useMargins);
> 		Rectangle imageRect = data.imageOriginalBounds.getCopy();
> 		mm.DPtoLP(imageRect);
> 		if (useMargins) {
> 			imageRect.shrink(getImageMargin(), getImageMargin());
> 		}
> 		imageRect.performScale(data.scalingFactor);
> 		if (useMargins) {
> 			imageRect.expand(getImageMargin(), getImageMargin());
> 		}
> 
> 		for (IGraphicalEditPart part : children) {
> 			editParts.add(part);
> 			getNestedEditParts(part, editParts);
> 		}
> 
> 		for (IGraphicalEditPart part : editParts) {
> 			IFigure figure = part.getFigure();
> 
> 			// RATLC00139941: Need to support any kind of shape edit part
> 			// and shape compartments, too, because these sometimes
> 			// correspond to distinct semantic elements
> 			if (part instanceof ShapeEditPart
> 					|| part instanceof ShapeCompartmentEditPart) {
> 
> 				PartPositionInfo position = new PartPositionInfo();
> 
> 				position.setSemanticElement(ViewUtil
> 						.resolveSemanticElement((View) part.getModel()));
> 
> 				Rectangle bounds = figure.getBounds().getCopy();
> 				translateToPrintableLayer(figure, bounds);
> 				bounds.performScale(data.scalingFactor);
> 				bounds.translate(-imageRect.x, -imageRect.y);
> 
> 				position.setPartHeight(mm.LPtoDP(bounds.height));
> 				position.setPartWidth(mm.LPtoDP(bounds.width));
> 				position.setPartX(mm.LPtoDP(bounds.x));
> 				position.setPartY(mm.LPtoDP(bounds.y));
> 				result.add(0, position);
> 			} else if (part instanceof ConnectionEditPart) {
> 				// find a way to get (P1, P2, ... PN) for connection edit part
> 				// add MARGIN and calculate "stripe" for the polyline instead of
> 				// bounding box.
> 				PartPositionInfo position = new PartPositionInfo();
> 
> 				position.setSemanticElement(ViewUtil
> 						.resolveSemanticElement((View) part.getModel()));
> 
> 				if (figure instanceof PolylineConnection) {
> 					PolylineConnection mainPoly = (PolylineConnection) figure;
> 					PointList mainPts = mainPoly.getPoints();
> 					mainPts.performScale(data.scalingFactor);
> 
> 					translateToPrintableLayer(figure, mainPts);
> 					List<Point> envelopingPts = calculateEnvelopingPolyline(mainPts,
> 							new Point(imageRect.x, imageRect.y));
> 					List<Point> transformedPts = convertPolylineUnits(envelopingPts);
696,696d691
< 					List transformedPts = convertPolylineUnits(envelopingPts);
753,753c831,831
< 	private List calculateEnvelopingPolyline(PointList polyPts, Point origin) {
---
> 	private List<Point> calculateEnvelopingPolyline(PointList polyPts, Point origin) {
753a832,832
> 		List<Point> result = new ArrayList<Point>();
754,754d831
< 		ArrayList result = new ArrayList();
755,755c833,833
< 		List mainSegs = PointListUtilities.getLineSegments(polyPts);
---
> 		List<LineSeg> mainSegs = (List<LineSeg>) PointListUtilities.getLineSegments(polyPts);
790,790d867
< 		Object first = result.get(0);
791,791c868,868
< 		result.add(first);
---
> 		result.add(result.get(0));
804,804c881,881
< 	private List convertPolylineUnits(List polyPts) {
---
> 	private List<Point> convertPolylineUnits(List<Point> polyPts) {
805,805c882,882
< 		ArrayList result = new ArrayList();
---
> 		List<Point> result = new ArrayList<Point>();
806,807d882
< 		Iterator iter = polyPts.iterator();
< 
808a884,884
> 		for (Point point : polyPts) {
809,811d883
< 
< 		while (iter.hasNext()) {
< 			Point point = (Point) iter.next();
815,815d887
< 
903a1001,1017
> 	class ConstrainedImageRenderingData {
> 		double scalingFactor;
> 		int imageWidth; // in pixels
> 		int imageHeight; // in pixels
> 		Rectangle imageOriginalBounds; // in pixels
> 		int margin; // margins size in pixels
> 	}
> 	
> 	ConstrainedImageRenderingData getConstrainedImageRenderingData(List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
> 		ConstrainedImageRenderingData data = new ConstrainedImageRenderingData();
> 		IMapMode mm = getMapMode();
> 		
> 		data.imageOriginalBounds = new PrecisionRectangle(new Rectangle(calculateImageRectangle(editParts)));
> 		mm.LPtoDP(data.imageOriginalBounds);
> 		
> 		int deviceMargins = mm.LPtoDP(getImageMargin());
> 		data.margin = useMargins ? deviceMargins : 0; 
903a976,976
> 			ConstrainedImageRenderingData data = getConstrainedImageRenderingData(editParts, maxDeviceWidth, maxDeviceHeight, useMargins);
904,908d1000
< 			Rectangle originalBounds = new PrecisionRectangle(new Rectangle(calculateImageRectangle(editParts)));
< 			getMapMode().LPtoDP(originalBounds);
< 			
< 			int deviceMargins = mm.LPtoDP(getImageMargin());
< 			int threshold = useMargins ? deviceMargins : 0; 
909,909c1018,1018
< 			double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
---
> 		double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
909a1019,1028
> 		
> 		data.imageOriginalBounds.shrink(deviceMargins, deviceMargins);
> 		
> 		if (maxDeviceWidth > data.margin) {
> 			xScalingFactor = (maxDeviceWidth  - data.margin - data.margin)/ (data.imageOriginalBounds.preciseWidth());
> 		}
> 		if (maxDeviceHeight > data.margin) {
> 			yScalingFactor = (maxDeviceHeight - data.margin - data.margin) / (data.imageOriginalBounds.preciseHeight());
> 		}
> 		
910,919d1018
< 			
< 			originalBounds.shrink(deviceMargins, deviceMargins);
< 			
< 			if (maxDeviceWidth > threshold) {
< 				xScalingFactor = (maxDeviceWidth  - threshold - threshold)/ (originalBounds.preciseWidth());
< 			}
< 			if (maxDeviceHeight > threshold) {
< 				yScalingFactor = (maxDeviceHeight - threshold - threshold) / (originalBounds.preciseHeight());
< 			}
< 			
920,920c1029,1029
< 			double scalingFactor = Math.min(Math.min(xScalingFactor, yScalingFactor), 1);
---
> 		data.scalingFactor = Math.min(Math.min(xScalingFactor, yScalingFactor), 1);
920a1030,1033
> 		
> 		data.imageWidth = data.imageOriginalBounds.width + data.margin + data.margin;
> 		data.imageHeight = data.imageOriginalBounds.height + data.margin + data.margin;
> 				
921,924d1029
< 			
< 			int imageWidth = originalBounds.width + threshold + threshold;
< 			int imageHeight = originalBounds.height + threshold + threshold;
< 			
925,925c1034,1034
< 			if (scalingFactor < 1) {
---
> 		if (data.scalingFactor < 1) {
925a1035,1038
> 			data.imageWidth = (int) Math.round(data.imageOriginalBounds.preciseWidth() * data.scalingFactor) + data.margin + data.margin;
> 			data.imageHeight = (int) Math.round(data.imageOriginalBounds.preciseHeight() * data.scalingFactor) + data.margin + data.margin;
> 		} else {
> 			data.scalingFactor = 1;
926,927d1034
< 				imageWidth = (int) Math.round(originalBounds.preciseWidth() * scalingFactor) + threshold + threshold;
< 				imageHeight = (int) Math.round(originalBounds.preciseHeight() * scalingFactor) + threshold + threshold;
928,928c1039,1039
< 			}
---
> 		}
928a1040,1040
> 		return data;
929a1042,1042
> 	
929,929c1041,1041
< 			
---
> 	}
932,932c979,979
< 			graphics = setUpGraphics(imageWidth, imageHeight);
---
> 			graphics = setUpGraphics(data.imageWidth, data.imageHeight);
938a986,986
> 			graphics.translate(data.margin, data.margin);
939,939d985
< 			graphics.translate(threshold, threshold);
940,940c987,987
< 			mapModeGraphics.scale(scalingFactor);
---
> 			mapModeGraphics.scale(data.scalingFactor);
942,942c989,989
< 			Point location = new PrecisionPoint(originalBounds.preciseX(), originalBounds.preciseY());
---
> 			Point location = new PrecisionPoint(data.imageOriginalBounds.preciseX(), data.imageOriginalBounds.preciseY());
