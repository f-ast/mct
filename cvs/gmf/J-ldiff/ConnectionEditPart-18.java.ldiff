0a1,1
> /******************************************************************************
1,1d0
< /*
2,2c2,2
<  *  Copyright (c) 2006, 2007 Borland Software Corporation and others.
---
>  * Copyright (c) 2002, 2003 IBM Corporation and others.
9a10,10
>  ****************************************************************************/
9,9c9,9
<  *      Borland Software Corporation - initial API and implementation
---
>  *    IBM Corporation - initial API and implementation 
10,11d9
<  */
< package org.eclipse.gmf.graphdef.editor.edit.parts;
12a12,28
> package org.eclipse.gmf.runtime.diagram.ui.editparts;
> 
> import java.beans.PropertyChangeEvent;
> import java.beans.PropertyChangeListener;
> import java.util.ArrayList;
> import java.util.Dictionary;
> import java.util.HashMap;
> import java.util.Hashtable;
> import java.util.Iterator;
> import java.util.List;
> import java.util.ListIterator;
> import java.util.Map;
> 
> import org.eclipse.core.runtime.IAdaptable;
> import org.eclipse.core.runtime.IAdapterFactory;
> import org.eclipse.core.runtime.Platform;
> import org.eclipse.draw2d.Connection;
14,14c30,30
< import org.eclipse.draw2d.RectangleFigure;
---
> import org.eclipse.draw2d.RelativeBendpoint;
15,15d30
< import org.eclipse.draw2d.StackLayout;
16,16c31,31
< import org.eclipse.draw2d.ToolbarLayout;
---
> import org.eclipse.draw2d.geometry.Dimension;
17a33,33
> import org.eclipse.emf.ecore.ENamedElement;
18,18c34,34
< import org.eclipse.emf.ecore.EcorePackage;
---
> import org.eclipse.emf.ecore.EObject;
18a35,39
> import org.eclipse.emf.ecore.EStructuralFeature;
> import org.eclipse.gef.AccessibleEditPart;
> import org.eclipse.gef.CompoundSnapToHelper;
> import org.eclipse.gef.DragTracker;
> import org.eclipse.gef.EditDomain;
20a64,67
> import org.eclipse.gmf.runtime.diagram.ui.editpolicies.PropertyHandlerEditPolicy;
> import org.eclipse.gmf.runtime.diagram.ui.editpolicies.SemanticEditPolicy;
> import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DefaultEditableEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IContainedEditPart;
21,25d63
< import org.eclipse.gef.editpolicies.LayoutEditPolicy;
< import org.eclipse.gmf.graphdef.editor.edit.policies.ConnectionItemSemanticEditPolicy;
< import org.eclipse.gmf.graphdef.editor.edit.policies.GMFGraphTextSelectionEditPolicy;
< import org.eclipse.gmf.graphdef.editor.part.GMFGraphVisualIDRegistry;
< import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
26a69,76
> import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.ConnectionEditPolicy;
> import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.ConnectionLineSegEditPolicy;
> import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.TreeConnectionBendpointEditPolicy;
> import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;
> import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
> import org.eclipse.gmf.runtime.diagram.ui.internal.services.editpolicy.EditPolicyService;
> import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramColorRegistry;
> import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
26,26c68,68
< import org.eclipse.gmf.runtime.diagram.ui.editparts.ITextAwareEditPart;
---
> import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IEditableEditPart;
27,27c77,77
< import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeNodeEditPart;
---
> import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramEditDomain;
27a78,78
> import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramGraphicalViewer;
28a80,103
> import org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx;
> import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.ConnectionLayerEx;
> import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ForestRouter;
> import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.OrthogonalRouter;
> import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
> import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
> import org.eclipse.gmf.runtime.emf.core.EventTypes;
> import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
> import org.eclipse.gmf.runtime.emf.core.util.MetaModelUtil;
> import org.eclipse.gmf.runtime.emf.core.util.ProxyUtil;
> import org.eclipse.gmf.runtime.gef.ui.internal.editpolicies.GraphicalEditPolicyEx;
> import org.eclipse.gmf.runtime.gef.ui.internal.l10n.Cursors;
> import org.eclipse.gmf.runtime.gef.ui.internal.tools.SelectConnectionEditPartTracker;
> import org.eclipse.gmf.runtime.notation.Diagram;
> import org.eclipse.gmf.runtime.notation.Edge;
> import org.eclipse.gmf.runtime.notation.FontStyle;
> import org.eclipse.gmf.runtime.notation.JumpLinkStatus;
> import org.eclipse.gmf.runtime.notation.JumpLinkType;
> import org.eclipse.gmf.runtime.notation.LineStyle;
> import org.eclipse.gmf.runtime.notation.NotationPackage;
> import org.eclipse.gmf.runtime.notation.RelativeBendpoints;
> import org.eclipse.gmf.runtime.notation.Routing;
> import org.eclipse.gmf.runtime.notation.RoutingStyle;
> import org.eclipse.gmf.runtime.notation.Smoothness;
28,28c79,79
< import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConstrainedToolbarLayoutEditPolicy;
---
> import org.eclipse.gmf.runtime.diagram.ui.services.editpart.EditPartService;
29a42,58
> import org.eclipse.gef.LayerConstants;
> import org.eclipse.gef.Request;
> import org.eclipse.gef.RequestConstants;
> import org.eclipse.gef.SnapToGeometry;
> import org.eclipse.gef.SnapToGrid;
> import org.eclipse.gef.SnapToGuides;
> import org.eclipse.gef.SnapToHelper;
> import org.eclipse.gef.commands.Command;
> import org.eclipse.gef.commands.UnexecutableCommand;
> import org.eclipse.gef.editparts.AbstractConnectionEditPart;
> import org.eclipse.gef.editpolicies.SnapFeedbackPolicy;
> import org.eclipse.gef.rulers.RulerProvider;
> import org.eclipse.gmf.runtime.common.ui.services.action.filter.ActionFilterService;
> import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
> import org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker;
> import org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener;
> import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
30,30d41
< import org.eclipse.gmf.runtime.draw2d.ui.figures.ConstrainedToolbarLayout;
31,31c59,59
< import org.eclipse.gmf.runtime.draw2d.ui.figures.WrappingLabel;
---
> import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
31a60,61
> import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectionBendpointEditPolicy;
> import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectionLabelsEditPolicy;
32,32c62,62
< import org.eclipse.gmf.runtime.gef.ui.figures.DefaultSizeNodeFigure;
---
> import org.eclipse.gmf.runtime.diagram.ui.editpolicies.DecorationEditPolicy;
33,33d62
< import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;
34a105,111
> import org.eclipse.jface.util.Assert;
> import org.eclipse.swt.SWT;
> import org.eclipse.swt.accessibility.AccessibleEvent;
> import org.eclipse.swt.graphics.Color;
> import org.eclipse.swt.graphics.FontData;
> import org.eclipse.swt.widgets.Display;
> import org.eclipse.ui.IActionFilter;
36a114,117
>  * the base edit part that controls <code>Edge</code> views, it is the basic
>  * controller for the connection's view
>  * 
>  * @author mmostafa
37,37d113
<  * @generated
38a119,131
> abstract public class ConnectionEditPart
> 	extends AbstractConnectionEditPart
> 	implements IGraphicalEditPart, PropertyChangeListener, IContainedEditPart,
> 	IPrimaryEditPart, NotificationListener {
> 
> 	/** A map of listener filters ids to filter data */
> 	private Map listenerFilters;
> 
> 	/** Used for registering and unregistering the edit part */
> 	private String elementGuid;
> 
> 	/** Used for accessibility. */
> 	protected AccessibleEditPart accessibleEP;
39,39d118
< public class ConnectionEditPart extends ShapeNodeEditPart {
41a134,143
> 	 * gets a property change command for the passed property, using both of the
> 	 * old and new values
> 	 * 
> 	 * @param property
> 	 *            the property associated with the command
> 	 * @param oldValue
> 	 *            the old value associated with the command
> 	 * @param newValue
> 	 *            the new value associated with the command
> 	 * @return a command
42,42d133
< 	 * @generated
43a145,153
> 	protected Command getPropertyChangeCommand(Object property,
> 			Object oldValue, Object newValue) {
> 		// by default return null, which means there is no special command to
> 		// change the property
> 		return null;
> 	}
> 
> 	/** Used for handling the editable status of the edit part */
> 	private final IEditableEditPart editableEditPart;
44,44d144
< 	public static final int VISUAL_ID = 2007;
46a156,156
> 	 * Register the adapters for the standard properties.
47,47d155
< 	 * @generated
48a158,180
> 	static {
> 		registerAdapters();
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gef.EditPart#activate()
> 	 */
> 	public void activate() {
> 		addNotationalListeners();
> 
> 		EObject semanticProxy = ((View) getModel()).getElement();
> 		EObject semanticElement = ProxyUtil.resolve(MEditingDomainGetter
> 			.getMEditingDomain((View) getModel()), semanticProxy);
> 
> 		if (semanticElement != null)
> 			addSemanticListeners();
> 		else if (semanticProxy != null) {
> 			addListenerFilter("SemanticProxy", this, semanticProxy); //$NON-NLS-1$
> 		}
> 		super.activate();
> 	}
49,49d157
< 	protected IFigure contentPane;
51a183,190
> 	 * Adds a listener filter by adding the given listener to a passed notifier
> 	 * 
> 	 * @param filterId
> 	 *            A unique filter id (within the same editpart instance)
> 	 * @param listener
> 	 *            A listener instance
> 	 * @param notifier
> 	 *            An element notifer to add the listener to
52,52d182
< 	 * @generated
53a192,207
> 	protected void addListenerFilter(String filterId,
> 			NotificationListener listener, EObject element) {
> 
> 		if (element == null)
> 			return;
> 
> 		Assert.isNotNull(filterId);
> 		Assert.isNotNull(listener);
> 
> 		if (listenerFilters == null)
> 			listenerFilters = new HashMap();
> 
> 		DiagramEventBroker.getInstance().addNotificationListener(element,
> 			listener);
> 		listenerFilters.put(filterId, new Object[] {element, listener});
> 	}
54,54d191
< 	protected IFigure primaryShape;
56a210,241
> 	 * Adds a listener filter by adding the given listener to a passed notifier
> 	 * 
> 	 * @param filterId
> 	 *            A unique filter id (within the same editpart instance)
> 	 * @param listener
> 	 *            A listener instance
> 	 * @param notifier
> 	 *            An element notifer to add the listener to
> 	 */
> 	protected void addListenerFilter(String filterId,
> 			NotificationListener listener, EObject element,
> 			EStructuralFeature feature) {
> 
> 		if (element == null)
> 			return;
> 
> 		Assert.isNotNull(filterId);
> 		Assert.isNotNull(listener);
> 
> 		if (listenerFilters == null)
> 			listenerFilters = new HashMap();
> 
> 		DiagramEventBroker.getInstance().addNotificationListener(element,
> 			feature, listener);
> 		listenerFilters
> 			.put(filterId, new Object[] {element, feature, listener});
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gef.editparts.AbstractEditPart#createChild(java.lang.Object)
57,57d209
< 	 * @generated
58a243,255
> 	final protected EditPart createChild(Object model) {
> 		return EditPartService.getInstance()
> 			.createGraphicEditPart((View) model);
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gef.editparts.AbstractGraphicalEditPart#createConnection(java.lang.Object)
> 	 */
> 	final protected org.eclipse.gef.ConnectionEditPart createConnection(
> 			Object connectionView) {
> 		return (org.eclipse.gef.ConnectionEditPart) createChild(connectionView);
59,60d242
< 	public ConnectionEditPart(View view) {
< 		super(view);
63a259,273
> 	 * Overridden to support editpolicies installed programmatically and via the
> 	 * <code>EditPolicyService</code>. Subclasses should override
> 	 * <code>createDefaultEditPolicies()</code>.
> 	 * 
> 	 * @see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
> 	 */
> 	final protected void createEditPolicies() {
> 		createDefaultEditPolicies();
> 		EditPolicyService.getInstance().createEditPolicies(this);
> 	}
> 
> 	/**
> 	 * Should be overridden to install editpolicies programmatically.
> 	 * 
> 	 * @see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
64,64d258
< 	 * @generated
66a276,291
> 		installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
> 			new SemanticEditPolicy());
> 		installEditPolicy(EditPolicyRoles.PROPERTY_HANDLER_ROLE,
> 			new PropertyHandlerEditPolicy());
> 		installEditPolicy(EditPolicy.CONNECTION_ENDPOINTS_ROLE,
> 			new org.eclipse.gef.editpolicies.ConnectionEndpointEditPolicy());
> 		installEditPolicy(EditPolicy.CONNECTION_ROLE,
> 			new ConnectionEditPolicy());
> 		installBendpointEditPolicy();
> 		installEditPolicy(EditPolicyRoles.DECORATION_ROLE,
> 			new DecorationEditPolicy());
> 		installEditPolicy(EditPolicyRoles.CONNECTION_LABELS_ROLE,
> 			new ConnectionLabelsEditPolicy());
> 
> 		installEditPolicy(EditPolicyRoles.SNAP_FEEDBACK_ROLE,
> 			new SnapFeedbackPolicy());
67,71d275
< 		super.createDefaultEditPolicies();
< 		installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE, new ConnectionItemSemanticEditPolicy());
< 		installEditPolicy(EditPolicy.LAYOUT_ROLE, createLayoutEditPolicy());
< 		// XXX need an SCR to runtime to have another abstract superclass that would let children add reasonable editpolicies
< 		// removeEditPolicy(org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles.CONNECTION_HANDLES_ROLE);
73a294,337
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gef.EditPart#deactivate()
> 	 */
> 	public void deactivate() {
> 		boolean wasActive = isActive();
> 		super.deactivate();
> 		if (listenerFilters != null && wasActive != isActive()) {
> 			for (Iterator i = listenerFilters.keySet().iterator(); i.hasNext();) {
> 				Object[] obj = (Object[]) listenerFilters.get(i.next());
> 				if (obj.length > 2) {
> 					DiagramEventBroker.getInstance()
> 						.removeNotificationListener((EObject) obj[0],
> 							(EStructuralFeature) obj[1],
> 							(NotificationListener) obj[2]);
> 				} else {
> 					DiagramEventBroker.getInstance()
> 						.removeNotificationListener((EObject) obj[0],
> 							(NotificationListener) obj[1]);
> 				}
> 			}
> 		}
> 	}
> 
> 	/**
> 	 * executes the passed command
> 	 * 
> 	 * @param command
> 	 *            the command to execute
> 	 */
> 	protected void executeCommand(Command command) {
> 		getEditDomain().getCommandStack().execute(command);
> 	}
> 
> 	/**
> 	 * a function that registers this provider with the Eclipse AdapterManager
> 	 * as an IView and an IActionFilter adapter factory for the
> 	 * IGraphicalEditPart nodes
> 	 * 
> 	 */
> 	static private void registerAdapters() {
> 		Platform.getAdapterManager().registerAdapters(new IAdapterFactory() {
> 
74a339,366
> 			 * @see org.eclipse.core.runtime.IAdapterFactory
> 			 */
> 			public Object getAdapter(Object adaptableObject, Class adapterType) {
> 
> 				IGraphicalEditPart gep = (IGraphicalEditPart) adaptableObject;
> 
> 				if (adapterType == IActionFilter.class) {
> 					return ActionFilterService.getInstance();
> 				} else if (adapterType == View.class) {
> 					return gep.getModel();
> 				}
> 				return null;
> 			}
> 
> 			/**
> 			 * @see org.eclipse.core.runtime.IAdapterFactory
> 			 */
> 			public Class[] getAdapterList() {
> 				return new Class[] {IActionFilter.class, View.class};
> 			}
> 
> 		}, IGraphicalEditPart.class);
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gef.editparts.AbstractEditPart#getAccessibleEditPart()
75,75d338
< 	 * @generated
76a368,368
> 	protected AccessibleEditPart getAccessibleEditPart() {
77,77d367
< 	protected LayoutEditPolicy createLayoutEditPolicy() {
78a370,371
> 		if (accessibleEP == null) {
> 			accessibleEP = new AccessibleGraphicalEditPart() {
79,79d369
< 		ConstrainedToolbarLayoutEditPolicy lep = new ConstrainedToolbarLayoutEditPolicy() {
80a373,380
> 				private String getSemanticName() {
> 					EObject semanticElement = resolveSemanticElement();
> 
> 					if (semanticElement != null) {
> 						String name = semanticElement.getClass().getName();
> 						int startIndex = name.lastIndexOf('.') + 1;
> 						int endIndex = name.lastIndexOf("Impl"); //$NON-NLS-1$
> 						return name.substring(startIndex, endIndex);
81,84d372
< 			protected EditPolicy createChildEditPolicy(EditPart child) {
< 				if (child.getEditPolicy(EditPolicy.PRIMARY_DRAG_ROLE) == null) {
< 					if (child instanceof ITextAwareEditPart) {
< 						return new GMFGraphTextSelectionEditPolicy();
85a382,383
> 
> 					return DiagramUIMessages.Accessible_Connection_Label;
86a385,421
> 
> 				public void getName(AccessibleEvent e) {
> 
> 					StringBuffer msg = new StringBuffer();
> 
> 					EditPart sourceEP = getSource();
> 					EditPart targetEP = getTarget();
> 
> 					// Get the Connection Name
> 					msg.append(getSemanticName());
> 
> 					// Get the Source Name
> 					if (sourceEP != null) {
> 						AccessibleEditPart aEP = (AccessibleEditPart) sourceEP
> 							.getAdapter(AccessibleEditPart.class);
> 						AccessibleEvent event = new AccessibleEvent(this);
> 						aEP.getName(event);
> 						msg.append(" "); //$NON-NLS-1$
> 						msg
> 							.append(DiagramUIMessages.Accessible_Connection_From);
> 						msg.append(" "); //$NON-NLS-1$
> 						msg.append(event.result);
> 					}
> 
> 					// Get the Target Name
> 					if (targetEP != null) {
> 						AccessibleEditPart aEP = (AccessibleEditPart) targetEP
> 							.getAdapter(AccessibleEditPart.class);
> 						AccessibleEvent event = new AccessibleEvent(this);
> 						aEP.getName(event);
> 						msg.append(" "); //$NON-NLS-1$
> 						msg.append(DiagramUIMessages.Accessible_Connection_To);
> 						msg.append(" "); //$NON-NLS-1$
> 						msg.append(event.result);
> 					}
> 
> 					e.result = msg.toString();
87,87d384
< 				return super.createChildEditPolicy(child);
89a424,426
> 		}
> 		return accessibleEP;
> 	}
90,90d423
< 		return lep;
91a428,540
> 	/**
> 	 * Adds the ability to adapt to this editpart's view class.
> 	 */
> 	public Object getAdapter(Class key) {
> 		Object adapter = Platform.getAdapterManager().getAdapter(this, key);
> 		if (adapter != null) {
> 			return adapter;
> 		}
> 
> 		if (adapter == SnapToHelper.class) {
> 
> 			List snapStrategies = new ArrayList();
> 
> 			Boolean val = (Boolean) getViewer().getProperty(
> 				RulerProvider.PROPERTY_RULER_VISIBILITY);
> 			if (val != null && val.booleanValue())
> 				snapStrategies.add(new SnapToGuides(this));
> 
> 			val = (Boolean) getViewer().getProperty(
> 				SnapToGeometry.PROPERTY_SNAP_ENABLED);
> 			if (val != null && val.booleanValue())
> 				snapStrategies.add(new SnapToGrid(this));
> 
> 			if (snapStrategies.size() == 0)
> 				return null;
> 
> 			if (snapStrategies.size() == 1)
> 				return snapStrategies.get(0);
> 
> 			SnapToHelper ss[] = new SnapToHelper[snapStrategies.size()];
> 			for (int i = 0; i < snapStrategies.size(); i++)
> 				ss[i] = (SnapToHelper) snapStrategies.get(i);
> 			return new CompoundSnapToHelper(ss);
> 		}
> 
> 		Object model = getModel();
> 
> 		if (View.class.isAssignableFrom(key) && key.isInstance(model) ) {
> 			return getModel();
> 		}
> 
> 		if (model != null && model instanceof View) {
> 			// Adapt to semantic element
> 			EObject semanticObject = ViewUtil
> 				.resolveSemanticElement((View) model);
> 			if (key.isInstance(semanticObject)) {
> 				return semanticObject;
> 			} else if (key.isInstance(model)) {
> 				return model;
> 			}
> 		}
> 		return super.getAdapter(key);
> 	}
> 
> 	/**
> 	 * Method getChildBySemanticHint.
> 	 * 
> 	 * @param semanticHint
> 	 * @return IGraphicalEditPart
> 	 */
> 	public IGraphicalEditPart getChildBySemanticHint(String semanticHint) {
> 		if (getModel() != null) {
> 			View view = ViewUtil.getChildBySemanticHint((View) getModel(),
> 				semanticHint);
> 			if (view != null)
> 				return (IGraphicalEditPart) getViewer().getEditPartRegistry()
> 					.get(view);
> 		}
> 		return null;
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gef.EditPart#getCommand(org.eclipse.gef.Request)
> 	 */
> 	public Command getCommand(Request _request) {
> 		if (!isEditModeEnabled()) {
> 			return UnexecutableCommand.INSTANCE;
> 		}
> 
> 		final Request request = _request;
> 		Command cmd = (Command) MEditingDomainGetter.getMEditingDomain(
> 			(View) getModel()).runAsRead(new MRunnable() {
> 
> 			public Object run() {
> 				return ConnectionEditPart.super.getCommand(request);
> 			}
> 		});
> 		return cmd;
> 	}
> 
> 	/**
> 	 * Convenience method returning the editpart's Diagram, the Diagam that owns
> 	 * the edit part
> 	 * 
> 	 * @return the diagram
> 	 */
> 	protected Diagram getDiagramView() {
> 		return (Diagram) getRoot().getContents().getModel();
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getPrimaryView()
> 	 */
> 	public View getPrimaryView() {
> 		for (EditPart parent = this; parent != null; parent = parent
> 			.getParent())
> 			if (parent instanceof IPrimaryEditPart)
> 				return (View) parent.getModel();
> 		return null;
94a544,547
> 	 * Convenience method returning the editpart's edit domain. Same as calling
> 	 * <code>getRoot().getViewer().getEditDomain()</code>
> 	 * 
> 	 * @return the edit domain
95,95d543
< 	 * @generated
96a549,559
> 	protected EditDomain getEditDomain() {
> 		return getRoot().getViewer().getEditDomain();
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramEditDomain()
> 	 */
> 	public IDiagramEditDomain getDiagramEditDomain() {
> 		return (IDiagramEditDomain) getEditDomain();
97,99d548
< 	protected IFigure createNodeShape() {
< 		DiagramElementFigure figure = new DiagramElementFigure();
< 		return primaryShape = figure;
102a563,565
> 	 * Return this editpart's view (model) children.
> 	 * 
> 	 * @return list of views.
103,103d562
< 	 * @generated
104a567,568
> 	protected List getModelChildren() {
> 		return ((View) getModel()).getChildren();
105,106d566
< 	public DiagramElementFigure getPrimaryShape() {
< 		return (DiagramElementFigure) primaryShape;
109a572,579
> 	 * Convenience method to retreive the value for the supplied poperty from
> 	 * the editpart's associated view element.
> 	 * 
> 	 * @param id
> 	 *            the property id
> 	 * @return Object the value
> 	 * @deprecated use {@link #getStructuralFeatureValue(EStructuralFeature)}
> 	 *             instead
110,110d571
< 	 * @generated
111a581,582
> 	public Object getPropertyValue(Object id) {
> 		return ViewUtil.getPropertyValue((View) getModel(), id);
112,115d580
< 	protected boolean addFixedChild(EditPart childEditPart) {
< 		if (childEditPart instanceof ConnectionNameEditPart) {
< 			((ConnectionNameEditPart) childEditPart).setLabel(getPrimaryShape().getFigureDiagramElementFigure_NameLabel());
< 			return true;
116a584,591
> 
> 	/**
> 	 * Convenience method to retreive the value for the supplied value from the
> 	 * editpart's associated view element. Same as calling
> 	 * <code> ViewUtil.getStructuralFeatureValue(getNotationView(),feature)</code>.
> 	 */
> 	public Object getStructuralFeatureValue(EStructuralFeature feature) {
> 		return ViewUtil.getStructuralFeatureValue((View) getModel(), feature);
117,117d583
< 		return false;
120a595,598
> 	 * try to resolve the semantic element and Return the resolven element; if
> 	 * the element is unresolvable or null it will return null
> 	 * 
> 	 * @return non proxy EObject or NULL
121,121d594
< 	 * @generated
122a600,602
> 	public EObject resolveSemanticElement() {
> 		return (EObject) MEditingDomainGetter.getMEditingDomain(
> 			(View) getModel()).runAsRead(new MRunnable() {
123,123d599
< 	protected boolean removeFixedChild(EditPart childEditPart) {
124a604,607
> 			public Object run() {
> 				return ViewUtil.resolveSemanticElement((View) getModel());
> 			}
> 		});
125,125d603
< 		return false;
128a611,612
> 	 * Walks up the editpart hierarchy to find and return the
> 	 * <code>TopGraphicEditPart</code> instance.
129,129d610
< 	 * @generated
130a614,720
> 	public TopGraphicEditPart getTopGraphicEditPart() {
> 		EditPart editPart = this;
> 		while (editPart instanceof IGraphicalEditPart) {
> 			if (editPart instanceof TopGraphicEditPart)
> 				return (TopGraphicEditPart) editPart;
> 			editPart = editPart.getParent();
> 		}
> 		return null;
> 	}
> 
> 	/**
> 	 * Return the editpart's associated Notation View.
> 	 * 
> 	 * @return <code>View</code>, the associated view or null if there is no
> 	 *         associated Notation View
> 	 */
> 	public View getNotationView() {
> 		Object model = getModel();
> 		if (model instanceof View)
> 			return (View) model;
> 		return null;
> 	}
> 
> 	/**
> 	 * Handles the passed property changed event only if the editpart's view is
> 	 * not deleted
> 	 */
> 	public final void propertyChange(PropertyChangeEvent event) {
> 		if (isActive())
> 			handlePropertyChangeEvent(event);
> 	}
> 
> 	/**
> 	 * Handles the property changed event
> 	 * 
> 	 * @param event
> 	 *            the property changed event
> 	 */
> 	protected void handlePropertyChangeEvent(PropertyChangeEvent event) {
> 		if (event.getPropertyName().equals(
> 			Connection.PROPERTY_CONNECTION_ROUTER)) {
> 			installRouter();
> 		}
> 	}
> 
> 	/**
> 	 * Method reactivateSemanticModel. This method reactivates the edit part's
> 	 * emantic model by: 1- removing semantic listeners 2- adding semantic
> 	 * listeners if the semantic reference is resolvable 3- Refreshing it
> 	 * 
> 	 * This method is called in response to IView's Properties.ID_SEMANTICREF
> 	 * property change event However, it will only work under the following
> 	 * assumptions: 1- The old and new semantic models are compatible in their
> 	 * kind 2- The deltas between old and new semantic models do not affect
> 	 * notation 3- Connections are not refereshed since they are maintained by
> 	 * the diagram
> 	 */
> 	public void reactivateSemanticModel() {
> 		removeSemanticListeners();
> 		if (resolveSemanticElement() != null)
> 			addSemanticListeners();
> 		refresh();
> 	}
> 
> 	/** Finds an editpart given a starting editpart and an EObject */
> 	public EditPart findEditPart(EditPart epBegin, EObject theElement) {
> 		if (theElement == null) {
> 			return null;
> 		}
> 		EditPart epStart = null;
> 		if (epBegin == null) {
> 			epStart = this;
> 		} else {
> 			epStart = epBegin;
> 		}
> 
> 		final View view = (View) ((IAdaptable) epStart).getAdapter(View.class);
> 
> 		if (view != null) {
> 			EObject el = ViewUtil.resolveSemanticElement(view);
> 
> 			if ((el != null) && el.equals(theElement)) {
> 				return epStart;
> 			}
> 		}
> 
> 		ListIterator childLI = epStart.getChildren().listIterator();
> 		while (childLI.hasNext()) {
> 			EditPart epChild = (EditPart) childLI.next();
> 
> 			EditPart elementEP = findEditPart(epChild, theElement);
> 			if (elementEP != null) {
> 				return elementEP;
> 			}
> 		}
> 		return null;
> 	}
> 
> 	/**
> 	 * Refresh the editpart's figure foreground colour.
> 	 */
> 	protected void refreshForegroundColor() {
> 		LineStyle style = (LineStyle) getPrimaryView().getStyle(
> 			NotationPackage.eINSTANCE.getLineStyle());
> 		if (style != null)
> 			setForegroundColor(DiagramColorRegistry
> 				.getInstance().getColor(new Integer(style.getLineColor())));
131,133d613
< 	protected void addChildVisual(EditPart childEditPart, int index) {
< 		if (addFixedChild(childEditPart)) {
< 			return;
134a722,727
> 
> 	/**
> 	 * Refresh the editpart's figure visibility.
> 	 */
> 	protected void refreshVisibility() {
> 		setVisibility(((View) getModel()).isVisible());
135,135d721
< 		super.addChildVisual(childEditPart, -1);
138a731,734
> 	 * Removes a listener previously added with the given id
> 	 * 
> 	 * @param filterId
> 	 *            the filiter ID
139,139d730
< 	 * @generated
140a736,737
> 	protected void removeListenerFilter(String filterId) {
> 		if (listenerFilters == null)
141,142d735
< 	protected void removeChildVisual(EditPart childEditPart) {
< 		if (removeFixedChild(childEditPart)) {
143a739,789
> 
> 		Object[] objects = (Object[]) listenerFilters.get(filterId);
> 		if (objects == null) {
> 			return;
> 		}
> 
> 		if (objects.length > 2) {
> 			DiagramEventBroker.getInstance().removeNotificationListener(
> 				(EObject) objects[0], (EStructuralFeature) objects[1],
> 				(NotificationListener) objects[2]);
> 		} else {
> 			DiagramEventBroker.getInstance().removeNotificationListener(
> 				(EObject) objects[0], (NotificationListener) objects[1]);
> 		}
> 		listenerFilters.remove(filterId);
> 	}
> 
> 	/**
> 	 * sets the forefround color of the editpart's figure
> 	 * 
> 	 * @param color
> 	 *            the color
> 	 */
> 	protected void setForegroundColor(Color color) {
> 		getFigure().setForegroundColor(color);
> 	}
> 
> 	/**
> 	 * Convenience method to set a property value.
> 	 * 
> 	 * @param id
> 	 * @param value
> 	 * @deprecated use {@link #setStructuralFeatureValue(Object, Object)}
> 	 *             instead
> 	 */
> 	public void setPropertyValue(Object id, Object value) {
> 		ViewUtil.setPropertyValue((View) getModel(), id, value);
> 	}
> 
> 	/**
> 	 * Sets the passed feature if possible on this editpart's view to the passed
> 	 * value.
> 	 * 
> 	 * @param feature
> 	 *            the feature to use
> 	 * @param value
> 	 *            the value of the property being set
> 	 */
> 	public void setStructuralFeatureValue(EStructuralFeature feature,
> 			Object value) {
> 		ViewUtil.setStructuralFeatureValue((View) getModel(), feature, value);
144a791,802
> 
> 	/**
> 	 * sets the edit part's visibility
> 	 * 
> 	 * @param vis
> 	 *            the new visibilty value
> 	 */
> 	protected void setVisibility(boolean vis) {
> 		if (!vis && getSelected() != SELECTED_NONE)
> 			getViewer().deselect(this);
> 		getFigure().setVisible(vis);
> 		getFigure().revalidate();
145,145d790
< 		super.removeChildVisual(childEditPart);
148a806,808
> 	 * This method adds all listeners to the notational world (views, figures,
> 	 * editpart...etc) Override this method to add more notational listeners
> 	 * down the hierarchy
149,149d805
< 	 * @generated
150a810,814
> 	protected void addNotationalListeners() {
> 		addListenerFilter("View", this, (View) getModel());//$NON-NLS-1$
> 		getFigure().addPropertyChangeListener(
> 			Connection.PROPERTY_CONNECTION_ROUTER, this);
> 	}
151,151d809
< 	protected IFigure getContentPaneFor(IGraphicalEditPart editPart) {
152a816,823
> 	/**
> 	 * This method adds all listeners to the semantic world (IUMLElement...etc)
> 	 * Override this method to add more semantic listeners down the hierarchy
> 	 * This method is called only if the semantic element is resolvable
> 	 */
> 	protected void addSemanticListeners() {
> 		addListenerFilter("SemanticModel",//$NON-NLS-1$
> 			this, resolveSemanticElement());
153,153d815
< 		return super.getContentPaneFor(editPart);
156a827,829
> 	 * This method removes all listeners to the notational world (views,
> 	 * figures, editpart...etc) Override this method to remove notational
> 	 * listeners down the hierarchy
157,157d826
< 	 * @generated
158a831,835
> 	protected void removeNotationalListeners() {
> 		getFigure().removePropertyChangeListener(
> 			Connection.PROPERTY_CONNECTION_ROUTER, this);
> 		removeListenerFilter("View");//$NON-NLS-1$
> 	}
159,160d830
< 	protected NodeFigure createNodePlate() {
< 		DefaultSizeNodeFigure result = new DefaultSizeNodeFigure(getMapMode().DPtoLP(40), getMapMode().DPtoLP(40));
161a837,843
> 	/**
> 	 * This method removes all listeners to the semantic world
> 	 * (IUMLElement...etc) Override this method to remove semantic listeners
> 	 * down the hierarchy
> 	 */
> 	protected void removeSemanticListeners() {
> 		removeListenerFilter("SemanticModel");//$NON-NLS-1$
162,162d836
< 		return result;
165a847,860
> 	 * @see org.eclipse.gef.EditPart#addNotify()
> 	 */
> 	public void addNotify() {
> 		super.addNotify();
> 		installRouter();
> 	}
> 
> 	/**
> 	 * Return a Map of all the appearance property ids supported by the edit
> 	 * part and its children.
> 	 * 
> 	 * Each entry in the map is the factory hint of the edit part as key and a
> 	 * dictionary of appearance properties as values. The edit parts are the
> 	 * receiver itself and it's children.
166,166d846
< 	 * Creates figure for this edit part.
167a862,869
> 	 * For example, the connectable shape edit part with name, attribute,
> 	 * operation and shape compartments will return a map where: 1 entry:
> 	 * connectable shape factory hint -> dictionary: Properties.ID_FONT -> font
> 	 * data Properties.ID_FONTCOLOR -> font color Properties.ID_LINECOLOR ->
> 	 * line color Properties.ID_FILLCOLOR -> fill color 2d entry: attribute
> 	 * compartment hint -> dictionary(empty) 3d entry: operation compartment
> 	 * hint -> dictionary(empty) 4d entry: shape compartment hint ->
> 	 * dictionary(empty)
168,169d861
< 	 * Body of this method does not depend on settings in generation model
< 	 * so you may safely remove <i>generated</i> tag and modify it.
170a871,871
> 	 * @return Map
171,171d870
< 	 * @generated
172a873,876
> 	public Map getAppearancePropertiesMap() {
> 		Map properties = new HashMap();
> 		fillAppearancePropertiesMap(properties);
> 		return properties;
173,179d872
< 	protected NodeFigure createNodeFigure() {
< 		NodeFigure figure = createNodePlate();
< 		figure.setLayoutManager(new StackLayout());
< 		IFigure shape = createNodeShape();
< 		figure.add(shape);
< 		contentPane = setupContentPane(shape);
< 		return figure;
182a880,880
> 	 * a static array of appearance property ids applicable to the connections
183,186d879
< 	 * Default implementation treats passed figure as content pane.
< 	 * Respects layout one may have set for generated figure.
< 	 * @param nodeShape instance of generated figure class
< 	 * @generated
187a882,895
> 	protected static final String[] appearanceProperties = new String[] {
> 		Properties.ID_FONTNAME, Properties.ID_FONTSIZE, Properties.ID_FONTBOLD,
> 		Properties.ID_FONTITALIC, Properties.ID_FONTCOLOR,
> 		Properties.ID_LINECOLOR};
> 
> 	/**
> 	 * construcotr
> 	 * 
> 	 * @param view ,
> 	 *            the view the edit part will own
> 	 */
> 	public ConnectionEditPart(View view) {
> 		setModel(view);
> 		this.editableEditPart = new DefaultEditableEditPart(this);
188,192d881
< 	protected IFigure setupContentPane(IFigure nodeShape) {
< 		if (nodeShape.getLayoutManager() == null) {
< 			ConstrainedToolbarLayout layout = new ConstrainedToolbarLayout();
< 			layout.setSpacing(getMapMode().DPtoLP(5));
< 			nodeShape.setLayoutManager(layout);
193a897,930
> 
> 	/**
> 	 * Method createConnectionFigure.
> 	 * 
> 	 * @return a <code>Connection</code> figure
> 	 */
> 	abstract protected Connection createConnectionFigure();
> 
> 	final protected IFigure createFigure() {
> 		return createConnectionFigure();
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gef.EditPart#refresh()
> 	 */
> 	public void refresh() {
> 		if (getSource() != null && getTarget() != null)
> 			MEditingDomainGetter.getMEditingDomain((View) getModel())
> 				.runAsRead(new MRunnable() {
> 
> 					public Object run() {
> 						ConnectionEditPart.super.refresh();
> 						EditPolicyIterator i = getEditPolicyIterator();
> 						while (i.hasNext()) {
> 							EditPolicy policy = i.next();
> 							if (policy instanceof GraphicalEditPolicyEx) {
> 								((GraphicalEditPolicyEx) policy).refresh();
> 							}
> 						}
> 						return null;
> 					}
> 				});
194,194d896
< 		return nodeShape; // use nodeShape itself as contentPane
197a934,943
> 	 * utility method to get the <code>Edge</code> view
> 	 * 
> 	 * @return the <code>Edge</code>
> 	 */
> 	protected Edge getEdge() {
> 		return (Edge) getModel();
> 	}
> 
> 	/*
> 	 * @see AbstractEditPart#getDragTracker(Request)
198,198d933
< 	 * @generated
199a945,946
> 	public DragTracker getDragTracker(Request req) {
> 		return new SelectConnectionEditPartTracker(this);
200,202d944
< 	public IFigure getContentPane() {
< 		if (contentPane != null) {
< 			return contentPane;
203a948,955
> 
> 	/**
> 	 * give access to the source of the edit part's Edge
> 	 * 
> 	 * @return the source
> 	 */
> 	protected Object getModelSource() {
> 		return getEdge().getSource();
204,204d947
< 		return super.getContentPane();
207a959,961
> 	 * give access to the target of the edit part's Edge
> 	 * 
> 	 * @return the target
208,208d958
< 	 * @generated
209a963,964
> 	protected Object getModelTarget() {
> 		return getEdge().getTarget();
210,211d962
< 	public EditPart getPrimaryChildEditPart() {
< 		return getChildBySemanticHint(GMFGraphVisualIDRegistry.getType(ConnectionNameEditPart.VISUAL_ID));
214a968,969
> 	 * installes a router on the edit part, depending on the
> 	 * <code>RoutingStyle</code>
215,215d967
< 	 * @generated
216a971,1024
> 	protected void installRouter() {
> 		ConnectionLayerEx cLayer = (ConnectionLayerEx) getLayer(LayerConstants.CONNECTION_LAYER);
> 
> 		RoutingStyle style = (RoutingStyle) ((View) getModel())
> 			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
> 		if (style != null) {
> 
> 			Routing routing = style.getRouting();
> 			if (Routing.MANUAL_LITERAL == routing) {
> 				getConnectionFigure().setConnectionRouter(
> 					cLayer.getObliqueRouter());
> 			} else if (Routing.RECTILINEAR_LITERAL == routing) {
> 				getConnectionFigure().setConnectionRouter(
> 					cLayer.getRectilinearRouter());
> 			} else if (Routing.TREE_LITERAL == routing) {
> 				getConnectionFigure().setConnectionRouter(
> 					cLayer.getTreeRouter());
> 			}
> 
> 		}
> 
> 		refreshRouterChange();
> 	}
> 
> 	/**
> 	 * refresh the pendpoints owned by the EditPart's <code>Edge</code>
> 	 */
> 	protected void refreshBendpoints() {
> 		RelativeBendpoints bendpoints = (RelativeBendpoints) getEdge()
> 			.getBendpoints();
> 		List modelConstraint = bendpoints.getPoints();
> 		List figureConstraint = new ArrayList();
> 		for (int i = 0; i < modelConstraint.size(); i++) {
> 			org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint wbp = (org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint) modelConstraint
> 				.get(i);
> 			RelativeBendpoint rbp = new RelativeBendpoint(getConnectionFigure());
> 			rbp.setRelativeDimensions(new Dimension(wbp.getSourceX(), wbp
> 				.getSourceY()), new Dimension(wbp.getTargetX(), wbp
> 				.getTargetY()));
> 			rbp.setWeight((i + 1) / ((float) modelConstraint.size() + 1));
> 			figureConstraint.add(rbp);
> 		}
> 		getConnectionFigure().setRoutingConstraint(figureConstraint);
> 	}
> 
> 	private void installBendpointEditPolicy() {
> 		if (getConnectionFigure().getConnectionRouter() instanceof ForestRouter) {
> 			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
> 				new TreeConnectionBendpointEditPolicy());
> 			getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
> 		} else if (getConnectionFigure().getConnectionRouter() instanceof OrthogonalRouter) {
> 			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
> 				new ConnectionLineSegEditPolicy());
> 			getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
217,219d970
< 	protected void handleNotificationEvent(Notification event) {
< 		if (event.getNotifier() == getModel() && EcorePackage.eINSTANCE.getEModelElement_EAnnotations().equals(event.getFeature())) {
< 			handleMajorSemanticChange();
220a1026,1028
> 			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
> 				new ConnectionBendpointEditPolicy());
> 			getConnectionFigure().setCursor(Cursors.CURSOR_SEG_ADD);
221,221d1025
< 			super.handleNotificationEvent(event);
225a1033,1033
> 	 * Method refreshRouterChange.
226,226d1032
< 	 * @generated
227a1035,1038
> 	protected void refreshRouterChange() {
> 		refreshBendpoints();
> 		installBendpointEditPolicy();
> 	}
228,228d1034
< 	public class DiagramElementFigure extends RectangleFigure {
230a1041,1041
> 	 * Method refreshSmoothness.
231,231d1040
< 		 * @generated
232a1043,1060
> 	protected void refreshSmoothness() {
> 		PolylineConnectionEx poly = ((PolylineConnectionEx) getConnectionFigure());
> 		RoutingStyle style = (RoutingStyle) ((View) getModel())
> 			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
> 		if (style != null) {
> 			Smoothness smoothness = style.getSmoothness();
> 
> 			if (Smoothness.LESS_LITERAL == smoothness) {
> 				poly.setSmoothness(PolylineConnectionEx.SMOOTH_LESS);
> 			} else if (Smoothness.NORMAL_LITERAL == smoothness) {
> 				poly.setSmoothness(PolylineConnectionEx.SMOOTH_NORMAL);
> 			} else if (Smoothness.MORE_LITERAL == smoothness) {
> 				poly.setSmoothness(PolylineConnectionEx.SMOOTH_MORE);
> 			} else if (Smoothness.NONE_LITERAL == smoothness) {
> 				poly.setSmoothness(PolylineConnectionEx.SMOOTH_NONE);
> 			}
> 		}
> 	}
233,233d1042
< 		private WrappingLabel fFigureDiagramElementFigure_NameLabel;
235a1063,1063
> 	 * Method refreshJumplinks.
236,236d1062
< 		 * @generated
237a1065,1068
> 	protected void refreshJumplinks() {
> 		PolylineConnectionEx poly = ((PolylineConnectionEx) getConnectionFigure());
> 		RoutingStyle style = (RoutingStyle) ((View) getModel())
> 			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
238,238d1064
< 		public DiagramElementFigure() {
239a1070,1077
> 		JumpLinkStatus status = JumpLinkStatus.NONE_LITERAL;
> 		JumpLinkType type = JumpLinkType.SEMICIRCLE_LITERAL;
> 		boolean reverse = false;
> 		if (style != null) {
> 			status = style.getJumpLinkStatus();
> 			type = style.getJumpLinkType();
> 			reverse = style.isJumpLinksReverse();
> 		}
240,242d1069
< 			ToolbarLayout layoutThis = new ToolbarLayout();
< 			layoutThis.setStretchMinorAxis(true);
< 			layoutThis.setMinorAlignment(ToolbarLayout.ALIGN_CENTER);
243a1079,1086
> 		int jumpType = 0;
> 		if (JumpLinkStatus.BELOW_LITERAL == status) {
> 			jumpType = PolylineConnectionEx.JUMPLINK_FLAG_BELOW;
> 		} else if (JumpLinkStatus.ABOVE_LITERAL == status) {
> 			jumpType = PolylineConnectionEx.JUMPLINK_FLAG_ABOVE;
> 		} else if (JumpLinkStatus.ALL_LITERAL == status) {
> 			jumpType = PolylineConnectionEx.JUMPLINK_FLAG_ALL;
> 		}
244,245d1078
< 			layoutThis.setSpacing(0);
< 			layoutThis.setVertical(true);
246a1088,1090
> 		boolean bCurved = type.equals(JumpLinkType.SEMICIRCLE_LITERAL);
> 		boolean bAngleIn = !type.equals(JumpLinkType.SQUARE_LITERAL);
> 		boolean bOnBottom = reverse;
247,247d1087
< 			this.setLayoutManager(layoutThis);
248a1092,1093
> 		poly.setJumpLinks(jumpType != 0);
> 		poly.setJumpLinksStyles(jumpType, bCurved, bAngleIn, bOnBottom);
249,249d1091
< 			createContents();
252a1097,1097
> 	 * Method refreshRoutingStyles.
253,253d1096
< 		 * @generated
254a1099,1100
> 	protected void refreshRoutingStyles() {
> 		PolylineConnectionEx poly = ((PolylineConnectionEx) getConnectionFigure());
255,255d1098
< 		private void createContents() {
256a1102,1104
> 		RoutingStyle style = (RoutingStyle) ((View) getModel())
> 			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
> 		if (style != null) {
257,258d1101
< 			fFigureDiagramElementFigure_NameLabel = new WrappingLabel();
< 			fFigureDiagramElementFigure_NameLabel.setText("");
259a1106,1107
> 			boolean closestDistance = style.isClosestDistance();
> 			boolean avoidObstruction = style.isAvoidObstructions();
260,260d1105
< 			this.add(fFigureDiagramElementFigure_NameLabel);
261a1109,1126
> 			poly.setRoutingStyles(closestDistance, avoidObstruction);
> 		}
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gef.editparts.AbstractEditPart#refreshVisuals()
> 	 */
> 	protected void refreshVisuals() {
> 		super.refreshVisuals();
> 		refreshVisibility();
> 		refreshForegroundColor();
> 		refreshRoutingStyles();
> 		refreshSmoothness();
> 		refreshJumplinks();
> 		refreshBendpoints();
> 		refreshFont();
264a1130,1130
> 	 * Refresh the editpart's figure font.
265,265d1129
< 		 * @generated
266a1132,1141
> 	protected void refreshFont() {
> 		FontStyle style = (FontStyle) getPrimaryView().getStyle(
> 			NotationPackage.eINSTANCE.getFontStyle());
> 		if (style != null) {
> 			setFont(new FontData(style.getFontName(), style.getFontHeight(),
> 				(style.isBold() ? SWT.BOLD
> 					: SWT.NORMAL) | (style.isItalic() ? SWT.ITALIC
> 					: SWT.NORMAL)));
> 		}
> 	}
267,267d1131
< 		private boolean myUseLocalCoordinates = false;
269a1144,1162
> 	 * Sets the font to the label. This method could be overriden to change the
> 	 * font data of the font overrides typically look like this: super.setFont(
> 	 * new FontData( fontData.getName(), fontData.getHeight(),
> 	 * fontData.getStyle() <| &> SWT.????));
> 	 * 
> 	 * @param fontData
> 	 *            the font data
> 	 */
> 	protected void setFont(FontData fontData) {
> 		getFigure().setFont(
> 			DiagramFontRegistry.getInstance().getFont(Display.getDefault(),
> 				fontData));
> 		getFigure().repaint();
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#fillAppearancePropertiesMap(java.util.Map)
270,270d1143
< 		 * @generated
271a1164,1187
> 	public void fillAppearancePropertiesMap(Map properties) {
> 
> 		if (getAppearancePropertyIDs().length > 0) {
> 			// only if there are any appearance properties
> 			final Dictionary local_properties = new Hashtable();
> 			for (int i = 0; i < getAppearancePropertyIDs().length; i++) {
> 				String prob = getAppearancePropertyIDs()[i];
> 				ENamedElement element = MetaModelUtil.getElement(prob);
> 				if (element instanceof EStructuralFeature
> 					&& ViewUtil.isPropertySupported((View) getModel(), prob)) {
> 					local_properties
> 						.put(
> 							getAppearancePropertyIDs()[i],
> 							getStructuralFeatureValue((EStructuralFeature) element));
> 				}
> 			}
> 			properties.put(((View) getModel()).getType(), local_properties);
> 		}
> 
> 		Iterator iterator = getChildren().iterator();
> 		while (iterator.hasNext()) {
> 			IGraphicalEditPart child = (IGraphicalEditPart) iterator.next();
> 			child.fillAppearancePropertiesMap(properties);
> 		}
272,273d1163
< 		protected boolean useLocalCoordinates() {
< 			return myUseLocalCoordinates;
276a1191,1196
> 	 * Returns an array of the appearance property ids applicable to the
> 	 * receiver. Fro this type it is Properties.ID_FONT,
> 	 * Properties.ID_FONTCOLOR, Properties.ID_LINECOLOR
> 	 * 
> 	 * @return - an array of the appearane property ids applicable to the
> 	 *         receiver
277,277d1190
< 		 * @generated
278a1198,1199
> 	protected String[] getAppearancePropertyIDs() {
> 		return appearanceProperties;
279,280d1197
< 		protected void setUseLocalCoordinates(boolean useLocalCoordinates) {
< 			myUseLocalCoordinates = useLocalCoordinates;
283a1203,1206
> 	 * Perform a request by executing a command from the target editpart of the
> 	 * request For the Direct_Edit request, we need to show up an editor first
> 	 * 
> 	 * @see org.eclipse.gef.EditPart#performRequest(org.eclipse.gef.Request)
284,284d1202
< 		 * @generated
285a1208,1225
> 	public void performRequest(Request request) {
> 		if (!isEditModeEnabled()) {
> 			return;
> 		}
> 
> 		if (RequestConstants.REQ_DIRECT_EDIT == request.getType()) {
> 			performDirectEditRequest(request);
> 		} else {
> 			EditPart targetEditPart = getTargetEditPart(request);
> 			if (targetEditPart != null) {
> 				Command command = targetEditPart.getCommand(request);
> 				if (command != null) {
> 					getDiagramEditDomain().getDiagramCommandStack().execute(
> 						command);
> 					return;
> 				}
> 			}
> 		}
286,287d1207
< 		public WrappingLabel getFigureDiagramElementFigure_NameLabel() {
< 			return fFigureDiagramElementFigure_NameLabel;
289a1228,1244
> 	/**
> 	 * Performs a direct edit request (usually by showing some type of editor)
> 	 * 
> 	 * @param request
> 	 *            the direct edit request
> 	 */
> 	protected void performDirectEditRequest(Request request) {
> 		EditPart primaryChildEditPart = (EditPart) MEditingDomainGetter
> 			.getMEditingDomain((View) getModel()).runAsRead(new MRunnable() {
> 
> 				public Object run() {
> 					return getPrimaryChildEditPart();
> 				}
> 			});
> 		if (primaryChildEditPart != null) {
> 			primaryChildEditPart.performRequest(request);
> 		}
291a1247,1488
> 	/**
> 	 * @see org.eclipse.gef.EditPart#understandsRequest(org.eclipse.gef.Request)
> 	 */
> 	public boolean understandsRequest(Request req) {
> 		return RequestConstants.REQ_DIRECT_EDIT == req.getType()
> 			|| super.understandsRequest(req);
> 	}
> 
> 	/** Adds a [ref, editpart] mapping to the EditPartForElement map. */
> 	protected void registerModel() {
> 		super.registerModel();
> 
> 		// Save the elements Guid to use during unregister
> 		EObject ref = ((View) getModel()).getElement();
> 		if (ref == null) {
> 			return;
> 		}
> 
> 		elementGuid = ProxyUtil.getProxyID(ref);
> 
> 		((IDiagramGraphicalViewer) getViewer()).registerEditPartForElement(
> 			elementGuid, this);
> 	}
> 
> 	/** Remove this editpart from the EditPartForElement map. */
> 	protected void unregisterModel() {
> 		super.unregisterModel();
> 
> 		((IDiagramGraphicalViewer) getViewer()).unregisterEditPartForElement(
> 			elementGuid, this);
> 	}
> 
> 	/**
> 	 * Handles the case where the semantic reference has changed.
> 	 */
> 	protected final void handleMajorSemanticChange() {
> 		if (getSource() instanceof GraphicalEditPart
> 			&& getTarget() instanceof GraphicalEditPart) {
> 			((GraphicalEditPart) getSource()).refreshSourceConnection(this);
> 			((GraphicalEditPart) getTarget()).refreshTargetConnection(this);
> 		}
> 	}
> 
> 	/**
> 	 * Refreshes a child editpart by removing it and refreshing children
> 	 * 
> 	 * @param child
> 	 */
> 	final void refreshChild(GraphicalEditPart child) {
> 		removeChild(child);
> 		refreshChildren();
> 	}
> 
> 	/**
> 	 * check if there is a canonical edit policy installed on the edit part or
> 	 * not
> 	 * 
> 	 * @return <tt>true</tt> if a canonical editpolicy has been installed on
> 	 *         this editpart; otherwise <tt>false</tt>
> 	 */
> 	public final boolean isCanonical() {
> 		return getEditPolicy(EditPolicyRoles.CANONICAL_ROLE) != null;
> 	}
> 
> 	/**
> 	 * checks if the edit part's figure is visible or not
> 	 * 
> 	 * @return <tt>true</tt> if the editpart's figure is visible;
> 	 *         <tt>false</tt> otherwise.
> 	 */
> 	public boolean isSelectable() {
> 		return getFigure().isVisible();
> 	}
> 
> 	/*
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#disableEditMode()
> 	 */
> 	public void disableEditMode() {
> 		this.editableEditPart.disableEditMode();
> 	}
> 
> 	/*
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#enableEditMode()
> 	 */
> 	public void enableEditMode() {
> 		this.editableEditPart.enableEditMode();
> 	}
> 
> 	/*
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#isEditModeEnabled()
> 	 */
> 	public boolean isEditModeEnabled() {
> 		return this.editableEditPart.isEditModeEnabled();
> 	}
> 
> 	/*
> 	 * @see org.eclipse.gef.EditPart#showSourceFeedback(org.eclipse.gef.Request)
> 	 */
> 	public void showSourceFeedback(Request request) {
> 		if (!isEditModeEnabled()) {
> 			return;
> 		}
> 
> 		super.showSourceFeedback(request);
> 	}
> 
> 	/*
> 	 * @see org.eclipse.gef.EditPart#showTargetFeedback(org.eclipse.gef.Request)
> 	 */
> 	public void showTargetFeedback(Request request) {
> 		if (!isEditModeEnabled()) {
> 			return;
> 		}
> 
> 		super.showTargetFeedback(request);
> 	}
> 
> 	/*
> 	 * @see org.eclipse.gef.EditPart#eraseSourceFeedback(org.eclipse.gef.Request)
> 	 */
> 	public void eraseSourceFeedback(Request request) {
> 		if (!isEditModeEnabled()) {
> 			return;
> 		}
> 
> 		super.eraseSourceFeedback(request);
> 	}
> 
> 	/*
> 	 * @see org.eclipse.gef.EditPart#eraseTargetFeedback(org.eclipse.gef.Request)
> 	 */
> 	public void eraseTargetFeedback(Request request) {
> 		if (!isEditModeEnabled()) {
> 			return;
> 		}
> 
> 		super.eraseTargetFeedback(request);
> 	}
> 
> 	/**
> 	 * this method will return the primary child EditPart inside this edit part
> 	 * 
> 	 * @return the primary child view inside this edit part
> 	 */
> 	public EditPart getPrimaryChildEditPart() {
> 		if (getChildren().size() > 0)
> 			return (EditPart) getChildren().get(0);
> 		return null;
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramPreferencesHint()
> 	 */
> 	public PreferencesHint getDiagramPreferencesHint() {
> 		if (getRoot() instanceof IDiagramPreferenceSupport) {
> 			return ((IDiagramPreferenceSupport) getRoot()).getPreferencesHint();
> 		}
> 		return PreferencesHint.USE_DEFAULTS;
> 	}
> 
> 	/*
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener#notifyChanged(org.eclipse.emf.common.notify.Notification)
> 	 */
> 	public void notifyChanged(Notification notification) {
> 		if (isActive()) {
> 			handleNotificationEvent(notification);
> 		}
> 	}
> 
> 	/**
> 	 * Handles the property changed event
> 	 * 
> 	 * @param event
> 	 *            the property changed event
> 	 */
> 	protected void handleNotificationEvent(Notification event) {
> 		Object feature = event.getFeature();
> 		if (NotationPackage.eINSTANCE.getView_PersistedChildren().equals(
> 			feature)
> 			|| NotationPackage.eINSTANCE.getView_TransientChildren().equals(
> 				feature)) {
> 			refreshChildren();
> 		} else if (NotationPackage.eINSTANCE.getView_Visible().equals(feature)) {
> 			setVisibility(((Boolean) event.getNewValue()).booleanValue());
> 			// Reactivating in response to semantic model reference change
> 			// However, we need to verify that the event belongs to this
> 			// editpart's view
> 			// cannot do it now since property's source is (IView for RMS) and
> 			// (IUMLView for EMF)
> 		} else if (NotationPackage.eINSTANCE.getRoutingStyle_Routing().equals(
> 			feature)) {
> 			installRouter();
> 		} else if (NotationPackage.eINSTANCE.getRoutingStyle_Smoothness()
> 			.equals(feature)
> 			|| NotationPackage.eINSTANCE.getRoutingStyle_AvoidObstructions()
> 				.equals(feature)
> 			|| NotationPackage.eINSTANCE.getRoutingStyle_ClosestDistance()
> 				.equals(feature)
> 			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkStatus()
> 				.equals(feature)
> 			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkType().equals(
> 				feature)
> 			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinksReverse()
> 				.equals(feature)) {
> 			refreshVisuals();
> 		} else if (NotationPackage.eINSTANCE.getLineStyle_LineColor().equals(
> 			feature)) {
> 			Integer c = (Integer) event.getNewValue();
> 			setForegroundColor(DiagramColorRegistry
> 				.getInstance().getColor(c));
> 		} else if (NotationPackage.eINSTANCE.getRelativeBendpoints_Points()
> 			.equals(feature)) {
> 			refreshBendpoints();
> 		} else if (event.getFeature() == NotationPackage.eINSTANCE
> 			.getView_Element()
> 			&& ((EObject) event.getNotifier()) == getNotationView())
> 			handleMajorSemanticChange();
> 
> 		else if (event.getEventType() == EventTypes.UNRESOLVE
> 			&& event.getNotifier() == ((View) getModel()).getElement())
> 			handleMajorSemanticChange();
> 	}
> 
> 	/**
> 	 * @return <code>IMapMode</code> that allows for the coordinate mapping
> 	 *         from device to logical units.
> 	 */
> 	final protected IMapMode getMapMode() {
> 		EditPart parent = getParent();
> 		if (parent instanceof DiagramRootEditPart)
> 			return ((DiagramRootEditPart) parent).getMapMode();
> 		else if (parent instanceof org.eclipse.gef.GraphicalEditPart)
> 			return MapModeUtil
> 				.getMapMode(((org.eclipse.gef.GraphicalEditPart) parent)
> 					.getFigure());
> 
> 		return MapModeUtil.getMapMode();
> 	}
