17,17c17,17
< import java.util.Iterator;
---
> import java.util.Enumeration;
85,85c85,85
< 	protected String format(Map<String, String> oldHeaders) {
---
> 	protected String format(Map<String, String> oldHeaders) throws BundleException {
91,91c91,91
< 			sb.append(formatValue(e.getValue()));
---
> 			sb.append(formatValue(e.getKey(), e.getValue()));
97,97c97,97
< 	protected CharSequence formatValue(String value) {
---
> 	protected CharSequence formatValue(String headerHint, String value) throws BundleException {
101,101c101,101
< 		String[] values = ManifestElement.getArrayFromList(value);
---
> 		ManifestElement[] values = ManifestElement.parseHeader(headerHint, value);
104,104c104,104
< 		sb.append(values[0]);
---
> 		sb.append(formatValue(values[0]));
108a109,140
> 			sb.append(formatValue(values[i]));
> 		}
> 		return sb;
> 	}
> 
> 	protected CharSequence formatValue(ManifestElement element) {
> 		StringBuilder sb = new StringBuilder(element.getValue());
> 		// using tokens for directives and quoted strings for attributes
> 		// seems to be PDE convention, though I didn't find exact code that does that.
> 		// Without such a convention, it's very hard to tell whether original
> 		// directive or attribute was quoted or not - specialized Tokenizer from 
> 		// ManifestElement rips this information out.
> 		for (Enumeration<?> en = element.getDirectiveKeys(); en != null && en.hasMoreElements();) {
> 			final String directiveKey = (String) en.nextElement();
> 			for (String v : element.getDirectives(directiveKey)) {
> 				sb.append(';');
> 				sb.append(directiveKey);
> 				sb.append(':');
> 				sb.append('=');
> 				sb.append(v);
> 			}
> 		}
> 		for (Enumeration<?> en = element.getKeys(); en != null && en.hasMoreElements();) {
> 			final String attrKey = (String) en.nextElement();
> 			for (String v : element.getAttributes(attrKey)) {
> 				sb.append(';');
> 				sb.append(attrKey);
> 				sb.append('=');
> 				sb.append('"');
> 				sb.append(v);
> 				sb.append('"');
> 			}
109,109d108
< 			sb.append(values[i]);
142a174,175
> 		// quick-and-dirty way. in rare cases may give false answer (i.e. when ;att="[1.0,2.0)"
> 		// but it's ok
143,143d173
< 		// ManifestElement.getArrayFromList(value).length > 1;
146a179,182
> 	/**
> 	 * TODO rewrite to return ManifestElements instead of serializing result to String
> 	 * which will be parsed once again at {@link #format(Map)}. 
> 	 */
147a184,187
> 		ManifestElement[] oldValues = ManifestElement.parseHeader(header, oldValue);
> 		if (oldValues == null || oldValues.length == 0) {
> 			return newValue;
> 		}
148,149d183
< 		String[] oldValues = ManifestElement.getArrayFromList(oldValue);
< 		LinkedList<String> returnValue = new LinkedList<String>();
152,152c190,190
< 			returnValue.add(oldValues[i]);
---
> 			lookupValues[i] = oldValues[i].getValue();
153,155d190
< 			ManifestElement[] parsed = ManifestElement.parseHeader(header, oldValues[i]);
< 			assert parsed != null && parsed.length > 0;
< 			lookupValues[i] = parsed.length == 1 ? parsed[0].getValue() : oldValues[i];
157a193,194
> 		LinkedList<ManifestElement> additionalElements = new LinkedList<ManifestElement>();
> 		for (ManifestElement n :  ManifestElement.parseHeader(header, newValue)) {
158,166d192
< 		for (String n : ManifestElement.getArrayFromList(newValue)) {
< 			ManifestElement[] parsed = ManifestElement.parseHeader(header, n);
< 			assert parsed != null && parsed.length > 0;
< 			String toLookUp;
< 			if (parsed.length == 1) {
< 				toLookUp = parsed[0].getValue(); // look for directive-less part
< 			} else {
< 				toLookUp = n; // try the string itself
< 			}
167,167c195,195
< 			if (Arrays.binarySearch(lookupValues, toLookUp) < 0) {
---
> 			if (Arrays.binarySearch(lookupValues, n.getValue()) < 0) {
168,168c196,196
< 				returnValue.add(n);
---
> 				additionalElements.add(n);
171a200,202
> 		// we don't care about newlines as this is intermediate result
> 		for (ManifestElement me : oldValues) {
> 			sb.append(formatValue(me));
172,174d199
< 		for (Iterator<String> it = returnValue.iterator(); it.hasNext();) {
< 			sb.append(it.next());
< 			if (it.hasNext()) {
176a205,207
> 		for (ManifestElement me : additionalElements) {
> 			sb.append(formatValue(me));
> 			sb.append(',');
177a209,210
> 		assert sb.charAt(sb.length() - 1) == ',';
> 		sb.setLength(sb.length() - 1);
