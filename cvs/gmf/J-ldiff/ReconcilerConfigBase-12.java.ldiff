12,12d11
< 
24a24,24
> import org.eclipse.emf.ecore.EStructuralFeature;
60,60c77,77
< 	protected final void setCopier(EClass eClass, Copier copier){
---
> 	protected final void setCopier(EClass eClass, Copier copier){
61a79,80
> 	}
> 	
61,61c78,78
< 		getRecord(eClass, true).setCopier(copier);
---
> 		getRecord(eClass, true).setCopier(copier);
86,86c60,60
< 	protected final void setMatcher(EClass eClass, EAttribute attribute){  
---
> 	protected final void setMatcher(EClass eClass, EAttribute attribute){  
87,87c61,61
< 		checkStructuralFeature(eClass, attribute);
---
> 		checkStructuralFeature(eClass, attribute);
87a62,62
> 		setMatcher(eClass, new ReflectiveMatcher(attribute));
88,89d61
< 		Matcher matcher = new ReflectiveMatcher(attribute);
< 		setMatcher(eClass, matcher);
90,90c63,63
< 	}
---
> 	}
91,91c64,64
< 	
---
> 	
92a66,68
> 		checkStructuralFeature(eClass, reference);
> 		// XXX Perhaps, for cases, when reference's target is in some other package,
> 		// might be reasonable to have an alternative matching, non-resolving, just comparing proxyURI?
92,92c65,65
< 	protected final void setMatcher(EClass eClass, EReference reference){
---
> 	protected final void setMatcher(EClass eClass, EReference reference) {
93,94d65
< 		if (eClass.getEPackage().equals(reference.eClass().getEPackage())){
< 			//XXX: use lazyly resolved matcher??? 
95,95c69,69
< 			setMatcher(eClass, new ReflectiveMatcher(reference));
---
> 		setMatcher(eClass, new ReflectiveMatcher(reference));
96,100d69
< 		} else {
< 			setMatcher(eClass, new ReflectiveMatcher(reference));
< 		}
< 	}
< 
144,144c141,141
< 	private void checkStructuralFeature(EClass expectedClass, EAttribute feature) {
---
> 	private static void checkStructuralFeature(EClass expectedClass, EStructuralFeature feature) {
