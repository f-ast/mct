14,14d13
< import org.eclipse.core.commands.ExecutionException;
16,20d14
< import org.eclipse.core.runtime.IAdaptable;
< import org.eclipse.core.runtime.IProgressMonitor;
< import org.eclipse.core.runtime.IStatus;
< import org.eclipse.core.runtime.NullProgressMonitor;
< import org.eclipse.core.runtime.Status;
22,22d15
< import org.eclipse.emf.workspace.AbstractEMFOperation;
24,25d16
< import org.eclipse.gef.commands.Command;
< import org.eclipse.gmf.internal.runtime.lite.Activator;
26a18,18
> public class WrappingCommand extends AbstractWrappingCommand {
27,27d17
< public class WrappingCommand extends Command {
28,28c19,19
< 	private final IUndoableOperation operation;
---
> 	private final EMFCommandOperation operation;
29,29d19
< 	private final TransactionalEditingDomain editingDomain;
34,34c23,23
< 		this.editingDomain = editingDomain;
---
> 		super(editingDomain);
36a27,28
> 	public org.eclipse.emf.common.command.Command getEMFCommand() {
> 		return operation.getCommand();
37,83d26
< 	public void execute() {
< 		try {
< 			operation.execute(new NullProgressMonitor(), null);
< 		} catch (ExecutionException e) {
< 			Activator.getDefault().logError("exception occurred while executing operation", e);
< 		}
< 	}
< 
< 	public boolean canExecute() {
< 		/*
< 		 * Some commands (see StrictCompoundCommand) require read-write transaction to test for executability. 
< 		 * When they fail, the RollbackException is consumed, and the command is not rolled back, thus leaving the model in a modified state.
< 		 */
< 		final boolean[] result = new boolean[1];
< 		AbstractEMFOperation canExecute = new AbstractEMFOperation(editingDomain, "canExecute") {
< 			@Override
< 			protected IStatus doExecute(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
< 				result[0] = operation.canExecute();
< 				return Status.OK_STATUS;
< 			}
< 		};
< 		try {
< 			canExecute.execute(new NullProgressMonitor(), null);
< 		} catch (ExecutionException e) {
< 			Activator.getDefault().logError("exception occurred while testing executability of operation", e);
< 		}
< 		return result[0];
< 	}
< 
< 	public void undo() {
< 		try {
< 			operation.undo(new NullProgressMonitor(), null);
< 		} catch (ExecutionException e) {
< 			Activator.getDefault().logError("exception occurred while undoing operation", e);
< 		}
< 	}
< 
< 	public boolean canUndo() {
< 		return operation.canUndo();
< 	}
< 
< 	public void redo() {
< 		try {
< 			operation.redo(new NullProgressMonitor(), null);
< 		} catch (ExecutionException e) {
< 			Activator.getDefault().logError("exception occurred while redoing operation", e);
< 		}
86a32,33
> 	protected IUndoableOperation getOperation() {
> 		return operation;
87,89d31
< 	public void dispose() {
< 		operation.dispose();
< 		super.dispose();
