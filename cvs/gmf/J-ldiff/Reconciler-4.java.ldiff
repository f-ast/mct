14a15,15
> import java.util.ArrayList;
15a17,17
> import java.util.HashSet;
16a19,20
> import java.util.LinkedList;
> import java.util.List;
22a27,36
> 	/**
> 	 * Expected max breadth of the node in the reconciled tree
> 	 */
> 	private static final int PAIRS_POOL_SIZE = 100;
> 	
> 	/**
> 	 * Expected depth of the reconciled tree 
> 	 */
> 	private static final int STORAGE_POOL_SIZE = 10;
> 	
23a38,39
> 	private final MatchingSession myMatchingSession;
> 	private final StoragePool myStoragePool;
26a43,44
> 		myMatchingSession = new MatchingSession(new PairsPool(PAIRS_POOL_SIZE));
> 		myStoragePool = new StoragePool(STORAGE_POOL_SIZE);
33a52,56
> 	protected EObject handleNotMatchedOld(EObject currentParent, EObject notMatchedOld) {
> 		Copier copier = myConfig.getCopier(notMatchedOld.eClass());
> 		return copier.copyToCurrent(currentParent, notMatchedOld);
> 	}
> 
35,35c58,58
< 		reconcileContents(current.getContents(), old.getContents());
---
> 		reconcileContents(null, current.getContents(), old.getContents());
40,40c63,63
< 		reconcileContents(currentRoot.eContents(), oldRoot.eContents());
---
> 		reconcileContents(currentRoot, currentRoot.eContents(), oldRoot.eContents());
53,53c76,76
< 	private void reconcileContents(Collection allCurrents, Collection allOlds){
---
> 	private void reconcileContents(EObject currentParent, Collection allCurrents, Collection allOlds){
53a77,90
> 		if (allCurrents.isEmpty() && allOlds.isEmpty()){
> 			return;
> 		}
> 		List storage = myStoragePool.acquireList();
> 		myMatchingSession.match(allCurrents, allOlds, storage);
> 		
> 		for (Iterator pairs = storage.iterator(); pairs.hasNext();){
> 			Pair next = (Pair)pairs.next();
> 			EObject nextCurrent = next.current;
> 			EObject nextOld = next.old;
> 			assert (nextCurrent != null || nextOld != null);
> 			
> 			myMatchingSession.releasePair(next);
> 			
54,56d76
< 		for (Iterator currentContents = allCurrents.iterator(); currentContents.hasNext();){
< 			EObject nextCurrent = (EObject) currentContents.next();
< 			EObject nextOld = findMatched(nextCurrent, allOlds);
57,57c91,91
< 			if (nextOld == null){
---
> 			if (nextCurrent == null){
57a92,92
> 				if (currentParent != null){ //never copy top-level resource contents
58,58c93,93
< 				handleNotMatchedCurrent(nextCurrent);
---
> 					nextCurrent = handleNotMatchedOld(currentParent, nextOld);
59,59c94,94
< 			} else {
---
> 				} 
59a95,97
> 			}
> 
> 			if (nextCurrent != null && nextOld != null){
60a99,156
> 			} else if (nextOld == null){
> 				handleNotMatchedCurrent(nextCurrent);
> 			}
> 		}
> 		myStoragePool.release(storage);
> 	}
> 	
> 	private static class Pair {
> 		public EObject current;
> 		public EObject old;
> 		
> 		public void reset(){
> 			current = null;
> 			old = null;
> 		}
> 	}
> 	
> 	private class MatchingSession {
> 		private final Collection myCurrents;
> 		private final Collection myOlds;
> 		private final PairsPool myPool;
> 		private boolean myIsMatching;
> 		
> 		public MatchingSession(PairsPool pool){
> 			myPool = pool;
> 			myCurrents = new LinkedList();
> 			myOlds = new HashSet();
> 		}
> 		
> 		public void match(Collection currents, Collection olds, Collection output){
> 			assert !myIsMatching;
> 			assert myOlds.isEmpty();
> 			assert myCurrents.isEmpty();
> 			
> 			if (myIsMatching){
> 				throw new IllegalStateException("FIXME: remove me");
> 			}
> 			
> 			try {
> 				myIsMatching = true;
> 
> 				myCurrents.addAll(currents);
> 				myOlds.addAll(olds);
> 				
> 				for (Iterator currentContents = myCurrents.iterator(); !myOlds.isEmpty() && currentContents.hasNext();){
> 					EObject nextCurrent = (EObject) currentContents.next();
> 					Pair nextPair = acquirePair();
> 					nextPair.current = nextCurrent;
> 					nextPair.old = removeMatched(nextCurrent, myOlds);
> 					output.add(nextPair);
> 					currentContents.remove();
> 				}
> 				
> 				for (Iterator notMatchedOlds = myOlds.iterator(); notMatchedOlds.hasNext();){
> 					Pair nextPair = acquirePair();
> 					nextPair.current = null;
> 					nextPair.old = (EObject)notMatchedOlds.next();
> 					output.add(nextPair);
61a158,161
> 			} finally {
> 				myIsMatching = false;
> 				myCurrents.clear();
> 				myOlds.clear();
65,65c165,165
< 	private EObject findMatched(EObject current, Collection allOld){
---
> 		private EObject removeMatched(EObject current, Collection allOld){
70,70c170,170
< 			for (Iterator all = allOld.iterator(); result == null && all.hasNext();){
---
> 				for (Iterator all = allOld.iterator(); all.hasNext();){
73a174,175
> 						all.remove();
> 						break;
79a182,230
> 		private Pair acquirePair(){
> 			return myPool.acquire();
> 		}
> 		
> 		public void releasePair(Pair pair){
> 			myPool.release(pair);
> 		}
> 		
> 	}
> 	
> 	private static class PairsPool extends AbstractPool {
> 		public PairsPool(int capacity) {
> 			super(capacity);
> 		}
> 		
> 		public Pair acquire(){
> 			return (Pair)internalAcquire();
> 		}
> 		
> 		public void release(Pair pair){
> 			pair.current = null;
> 			pair.old = null;
> 			internalRelease(pair);
> 		}
> 		
> 		protected Object createNew() {
> 			return new Pair();
> 		}
> 	}
> 	
> 	private static class StoragePool extends AbstractPool {
> 		public StoragePool(int capacity){
> 			super(capacity);
> 		}
> 		
> 		public List acquireList(){
> 			return (List)internalAcquire();
> 		}
> 		
> 		public void release(List list){
> 			list.clear();
> 			internalRelease(list);
> 		}
> 		
> 		protected Object createNew() {
> 			return new ArrayList();
> 		}
> 	}
> 
