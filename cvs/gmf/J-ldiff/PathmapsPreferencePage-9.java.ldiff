13a14,16
> import java.io.File;
> import java.util.Arrays;
> import java.util.HashMap;
15a19,19
> import java.util.Map;
18,18c24,24
< import org.eclipse.core.resources.IPathVariableChangeEvent;
---
> import org.eclipse.core.runtime.CoreException;
19,19d24
< import org.eclipse.core.resources.IPathVariableChangeListener;
22a33,33
> import org.eclipse.jface.viewers.CheckStateChangedEvent;
22a26,26
> import org.eclipse.core.runtime.Path;
23,23c34,34
< import org.eclipse.emf.common.CommonPlugin;
---
> import org.eclipse.jface.viewers.CheckboxTableViewer;
23a35,35
> import org.eclipse.jface.viewers.ICheckStateListener;
27a31,31
> import org.eclipse.jface.dialogs.ErrorDialog;
30a38,38
> import org.eclipse.jface.viewers.ISelection;
39a48,48
> import org.eclipse.osgi.util.NLS;
42,42c51,51
< import org.eclipse.swt.events.ControlAdapter;
---
> import org.eclipse.swt.events.SelectionAdapter;
43,45d51
< import org.eclipse.swt.events.ControlEvent;
< import org.eclipse.swt.events.MouseEvent;
< import org.eclipse.swt.events.MouseTrackAdapter;
47,47d52
< import org.eclipse.swt.events.SelectionListener;
50,50d54
< import org.eclipse.swt.graphics.Point;
57,57d60
< import org.eclipse.swt.widgets.TableColumn;
58,58c61,61
< import org.eclipse.swt.widgets.TableItem;
---
> import org.eclipse.ui.ISharedImages;
66a70,70
>  * <p>
67,67d69
<  * <P>
69a73,77
>  * </p>
>  * <p>
>  * This class may be instantiated by clients, but is not intended to be
>  * subclassed.
>  * </p>
71a80,80
>  * @autor Christian W. Damus (cdamus)
73a83,89
>     extends PreferencePage
>     implements IWorkbenchPreferencePage {
> 
>     private static final String NAME_ATTRIBUTE = "name"; //$NON-NLS-1$
> 
>     private IPathVariableManager pathVariableManager = ResourcesPlugin
>         .getWorkspace().getPathVariableManager();
74,74d82
< 	extends PreferencePage implements IWorkbenchPreferencePage {
76,78d90
< 	private ScrolledComposite referencedPathVariablesScroll;
< 	private TableViewer referencedPathVariables;
< 	private StringsContentProvider referencedPathVariablesContent;
79a92,94
> 
>     private CheckboxTableViewer pathVariables;
> 
80,80d91
< 	private TableViewer pathVariables;
81a96,100
> 
>     private Button newVariable;
> 
>     private Button editVariable;
> 
81,81c95,95
< 	private StringsContentProvider pathVariablesContent;
---
>     private PathVariableContentProvider pathVariablesContent;
82,82d95
< 	private Button add;
83a102,103
> 
>     /** Path variable changes since last time the Apply button was pressed. */
83,83c101,101
< 	private Button remove;
---
>     private Button removeVariable;
84,84c104,104
< 	private IPathVariableChangeListener pathVariableChangeListener;
---
>     private Map variableChanges = new HashMap();
84a105,110
> 
>     private Object addedToken = new Object();
> 
>     private Object changedToken = new Object();
> 
>     private Object removedToken = new Object();
85,85d104
< 	private boolean disposed = true;
96,96c121,121
< 		composite.setLayout(new GridLayout(3, false));
---
>         composite.setLayout(new GridLayout(2, false));
97,100d121
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.horizontalSpan = 2;
< 		composite.setLayoutData(gridData);
105a127,127
>             EMFUIMessages.PathmapsPreferencePage_mainDescription,
105,105c126,126
<             "org.eclipse.ui.preferencePages.LinkedResources", EMFUIMessages.PathmapsPreferencePage_mainDescription, //$NON-NLS-1$
---
>             "org.eclipse.ui.preferencePages.LinkedResources", //$NON-NLS-1$
107,107c129,129
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
---
>         gridData = new GridData(GridData.FILL_HORIZONTAL
107a130,130
>             | GridData.FILL_VERTICAL);
110,110c133,133
< 		gridData.horizontalSpan = 3;
---
>         gridData.horizontalSpan = 2;
113,120d135
< 		Composite pathVariablesComposite = new Composite(composite, SWT.NONE);
< 		pathVariablesComposite.setLayout(new GridLayout(1, false));
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = true;
< 		gridData.horizontalSpan = 1;
< 		pathVariablesComposite.setLayoutData(gridData);
< 		
121,121c136,136
< 		Label pathVariablesLabel = new Label(pathVariablesComposite, SWT.LEFT);
---
>         Label pathVariablesLabel = new Label(composite, SWT.LEFT);
122,122c137,137
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
---
>         gridData = new GridData(GridData.FILL_HORIZONTAL
122a138,138
>             | GridData.FILL_VERTICAL);
127a144,144
>         pathVariablesLabel
128,128c145,145
< 		pathVariablesLabel.setText(EMFUIMessages.PathmapsPreferencePage_availablePathVariables);
---
>             .setText(EMFUIMessages.PathmapsPreferencePage_availablePathVariables);
130,130c147,147
< 		pathVariablesScroll = new ScrolledComposite(
---
>         pathVariablesScroll = new ScrolledComposite(composite, SWT.BORDER
131,131c148,148
< 				pathVariablesComposite, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
---
>             | SWT.H_SCROLL | SWT.V_SCROLL);
134a152,152
>             | GridData.FILL_VERTICAL);
134,134c151,151
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
---
>         gridData = new GridData(GridData.FILL_HORIZONTAL
138a157,157
> 
139,139c158,158
< 		pathVariables = new TableViewer(pathVariablesScroll, SWT.MULTI);
---
>         pathVariables = CheckboxTableViewer.newCheckList(pathVariablesScroll,
139a159,159
>             SWT.MULTI);
141a162,162
>         pathVariablesContent = new PathVariableContentProvider();
142,150d161
< 		TableColumn column = new TableColumn(pathVariables.getTable(), SWT.LEFT);
< 		column.setMoveable(false);
< 		column.setResizable(false);
< 		pathVariables.getTable().addControlListener(new ControlAdapter() {
< 			public void controlResized(ControlEvent e) {
< 				pathVariables.getTable().getColumn(0).setWidth(
< 						pathVariables.getTable().getClientArea().width);
< 			}});
< 		pathVariablesContent = new StringsContentProvider();
152,152c164,164
< 		pathVariables.setLabelProvider(new StringsLabelProvider());
---
>         pathVariables.setLabelProvider(new PathVariableLabelProvider());
153,153c165,165
< 		pathVariables.setComparator(new StringsViewerComparator());
---
>         pathVariables.setComparator(new PathVariableViewerComparator());
157,185d168
< 		add = new Button(buttonComposite, SWT.CENTER);
< 		add.setText(EMFUIMessages.PathmapsPreferencePage_addChevron);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		gridData.horizontalSpan = 1;
< 		add.setLayoutData(gridData);
< 		Button addAll = new Button(buttonComposite, SWT.CENTER);
< 		addAll.setText(EMFUIMessages.PathmapsPreferencePage_addAllChevron);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		addAll.setLayoutData(gridData);
< 		remove = new Button(buttonComposite,SWT.CENTER);
< 		remove.setText(EMFUIMessages.PathmapsPreferencePage_removeChevron);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		gridData.horizontalSpan = 1;
< 		gridData.verticalIndent = 10;
< 		remove.setLayoutData(gridData);
< 		Button removeAll = new Button(buttonComposite, SWT.CENTER);
< 		removeAll.setText(EMFUIMessages.PathmapsPreferencePage_removeAllChevron);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		gridData.horizontalSpan=1;
< 		removeAll.setLayoutData(gridData);
< 		
189a173,173
>         gridData.verticalAlignment = GridData.BEGINNING;
191a176,187
>         newVariable = new Button(buttonComposite, SWT.CENTER);
>         newVariable.setText(EMFUIMessages.PathmapsPreferencePage_newVariable);
>         setButtonLayoutData(newVariable);
> 
>         editVariable = new Button(buttonComposite, SWT.CENTER);
>         editVariable.setText(EMFUIMessages.PathmapsPreferencePage_editVariable);
>         setButtonLayoutData(editVariable);
> 
>         removeVariable = new Button(buttonComposite, SWT.CENTER);
>         removeVariable
>             .setText(EMFUIMessages.PathmapsPreferencePage_removeVariable);
>         setButtonLayoutData(removeVariable);
192,198d175
< 		Composite referencedPathVariablesComposite = new Composite(composite, SWT.NONE);
< 		referencedPathVariablesComposite.setLayout(new GridLayout(1, false));
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = true;
< 		gridData.horizontalSpan = 1;
< 		referencedPathVariablesComposite.setLayoutData(gridData);
200,207d188
< 		Label referencedPathVariablesLabel = new Label(referencedPathVariablesComposite, SWT.LEFT);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		gridData.horizontalSpan = 1;
< 		gridData.verticalIndent = 20;
< 		referencedPathVariablesLabel.setLayoutData(gridData);
< 		referencedPathVariablesLabel.setText(EMFUIMessages.PathmapsPreferencePage_pathVariablesUsedInModeling);
209,247d191
< 		referencedPathVariablesScroll = new ScrolledComposite(
< 				referencedPathVariablesComposite, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
< 		referencedPathVariablesScroll.setExpandHorizontal(true);
< 		referencedPathVariablesScroll.setExpandVertical(true);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = true;
< 		gridData.horizontalSpan = 1;
< 		referencedPathVariablesScroll.setLayoutData(gridData);
< 		referencedPathVariables = new TableViewer(referencedPathVariablesScroll, SWT.MULTI);
< 		referencedPathVariablesScroll.setContent(referencedPathVariables.getTable());
< 		
< 		column = new TableColumn(referencedPathVariables.getTable(), SWT.LEFT);
< 		column.setMoveable(false);
< 		column.setResizable(false);
< 		referencedPathVariables.getTable().addControlListener(new ControlAdapter() {
< 			public void controlResized(ControlEvent e) {
< 				referencedPathVariables.getTable().getColumn(0).setWidth(
< 						referencedPathVariables.getTable().getClientArea().width);
< 			}});
< 		referencedPathVariablesContent = new StringsContentProvider();
< 		referencedPathVariables.setContentProvider(referencedPathVariablesContent);
< 		referencedPathVariables.setLabelProvider(new StringsLabelProvider(true));
< 		referencedPathVariables.setComparator(new StringsViewerComparator());
< 		
< 		// adjust the scroll bars whenever the preference page is resized
< 		composite.addControlListener(new ControlAdapter() {
< 			public void controlResized(ControlEvent e) {
< 				adjustScrollpanes();
< 			}});
< 		
< 		pathVariables.getTable().addMouseTrackListener(new MouseTrackAdapter() {
< 			public void mouseHover(MouseEvent e) {
< 				TableItem item = pathVariables.getTable().getItem(new Point(e.x, e.y));
< 				String tip = null;
< 				
< 				if (item != null) {
< 					String var = item.getText(0);
< 					tip = getValue(var, false);
249a197,197
>         pathVariables.addCheckStateListener(new ICheckStateListener() {
249a189,189
>         pathVariables
250,252d188
< 				pathVariables.getTable().setToolTipText(tip);
< 			}});
< 		
253,253c190,190
< 		pathVariables.addSelectionChangedListener(new ISelectionChangedListener() {
---
>             .addSelectionChangedListener(new ISelectionChangedListener() {
254,257d190
< 			public void selectionChanged(SelectionChangedEvent event) {
< 				if (!event.getSelection().isEmpty()) { // prevent oscillation
< 					referencedPathVariables.setSelection(new StructuredSelection());
< 					remove.setEnabled(true);
258a199,201
>             public void checkStateChanged(CheckStateChangedEvent event) {
>                 pathVariableChecked(event, (PathVariableEntry) event
>                     .getElement());
259,263d198
< 					if (!validateAdditions((IStructuredSelection) event.getSelection(), true)) {
< 						add.setEnabled(false);
< 					} else {
< 						setMessage(null);
< 						add.setEnabled(true);
268a219,219
>         removeVariable.addSelectionListener(new SelectionAdapter() {
269,273d218
< 		referencedPathVariables.getTable().addMouseTrackListener(new MouseTrackAdapter() {
< 			public void mouseHover(MouseEvent e) {
< 				TableItem item = referencedPathVariables.getTable().getItem(
< 						new Point(e.x, e.y));
< 				String tip = null;
275,277d220
< 				if (item != null) {
< 					String var = item.getText(0);
< 					tip = getValue(var, true);
280,281d227
< 				referencedPathVariables.getTable().setToolTipText(tip);
< 			}});
283,283d191
< 		referencedPathVariables.addSelectionChangedListener(new ISelectionChangedListener() {
284,284c192,192
< 			public void selectionChanged(SelectionChangedEvent event) {
---
>                 public void selectionChanged(SelectionChangedEvent event) {
284a193,193
>                     pathVariableSelected(event.getSelection());
285,287d192
< 				if (!event.getSelection().isEmpty()) { // prevent oscillation
< 					add.setEnabled(true);
< 					pathVariables.setSelection(new StructuredSelection());
288a235,255
>     /**
>      * Responds to the user's gesture to either check or uncheck the specified
>      * <code>entry</code> in the path variables list. This may, according to
>      * the status of the path variable entry, result in the user's change being
>      * reverted (e.g., in the case of attempting to uncheck a variable
>      * registered on the extension point). This works around the inability in
>      * SWT to disable the checkbox of an item in a check-table (see <a
>      * href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=76509">bug 76509</a>
>      * for details).
>      * 
>      * @param event
>      *            the (un)check event
>      * @param entry
>      *            the path variable entry that was (un)checked
>      */
>     private void pathVariableChecked(CheckStateChangedEvent event,
>             PathVariableEntry entry) {
>         if (event.getChecked()) {
>             // validate the check
>             if (validateSelection(entry, false)) {
>                 entry.setSelected(true);
289,290d234
< 					if (!validateRemovals((IStructuredSelection) event.getSelection(), true)) {
< 						remove.setEnabled(false);
291a257,264
>                 event.getCheckable().setChecked(entry, false);
>             }
>         } else {
>             // validate the uncheck
>             if (validateDeselection(entry, false)) {
>                 entry.setSelected(false);
>             } else {
>                 event.getCheckable().setChecked(entry, true);
292,293d256
< 						setMessage(null);
< 						remove.setEnabled(true);
296a195,195
>             });
297,297d194
< 		});
298a210,213
>         });
> 
>         editVariable.addSelectionListener(new SelectionAdapter() {
> 
298a269,277
>     /**
>      * Handles the selection of zero or more path variables in the list,
>      * updating the enablement state of the "Edit..." and "Remove" buttons.
>      * 
>      * @param selection
>      *            the new path variables list selection
>      */
>     private void pathVariableSelected(ISelection selection) {
>         IStructuredSelection ssel = (IStructuredSelection) selection;
299,299d209
< 		add.addSelectionListener(new SelectionListener() {
300,300c214,214
< 			public void widgetSelected(SelectionEvent e) {
---
>             public void widgetSelected(SelectionEvent e) {
301,301d214
< 				IStructuredSelection selection =
302,302c215,215
< 					(IStructuredSelection) pathVariables.getSelection();
---
>                 editPathVariable(pathVariables.getSelection());
303a279,280
>         editVariable.setEnabled(validateEdit(ssel, false));
>         removeVariable.setEnabled(validateRemove(ssel, false));
304,309d278
< 				for (Iterator iter = selection.iterator(); iter.hasNext();) {
< 					String name = (String) iter.next();
< 					pathVariablesContent.remove(name);
< 					referencedPathVariablesContent.add(name);
< 					adjustScrollpanes();
< 				}
311a283,300
>     /**
>      * Updates the map of pending path variable changes to indicate that the
>      * specified variable has been added by the user.
>      * 
>      * @param variableName
>      *            the name of the added variable
>      */
>     private void markAdded(String variableName) {
>         Object currentChange = variableChanges.get(variableName);
> 
>         if (currentChange == removedToken) {
>             // if we previously removed this variable's value, then it will
>             // appear to be a change when we sync on apply
>             variableChanges.put(variableName, changedToken);
>         } else if (currentChange != changedToken) {
>             // shouldn't have been a "changed" if we thought we were adding
>             variableChanges.put(variableName, addedToken);
>         }
312,313d282
< 			public void widgetDefaultSelected(SelectionEvent e) {
< 				// No action is necessary
314a542,542
>         }
315,315d541
< 		});
316a303,313
>     /**
>      * Queries whether the specified path variable has an add change pending, to
>      * be applied when the OK/Apply button is pressed.
>      * 
>      * @param variableName
>      *            the path variable name
>      * @return <code>true</code> if the variable has a pending change that is
>      *         an add; <code>false</code>, otherwise
>      */
>     boolean isAdded(String variableName) {
>         return variableChanges.get(variableName) == addedToken;
317,319d302
< 		addAll.addSelectionListener(new SelectionListener() {
< 			public void widgetDefaultSelected(SelectionEvent e) {
< 				// No action necessary
321a316,324
>     /**
>      * Updates the map of pending path variable changes to indicate that the
>      * specified variable has been removed by the user.
>      * 
>      * @param variableName
>      *            the name of the removed variable
>      */
>     private void markRemoved(String variableName) {
>         Object currentChange = variableChanges.get(variableName);
322a222,222
>                 removePathVariable(pathVariables.getSelection());
322,322c221,221
< 			public void widgetSelected(SelectionEvent e) {
---
>             public void widgetSelected(SelectionEvent e) {
323,323d221
< 				Object[] items = pathVariablesContent.getElements(null);
324a326,330
>         if (currentChange == addedToken) {
>             // it was added since the last apply? Just forget about it, then
>             variableChanges.remove(variableName);
>         } else {
>             variableChanges.put(variableName, removedToken);
325,330d325
< 				for (int i=items.length - 1; i >= 0; i--) {
< 					if (validateAdditions(new StructuredSelection(items[i]), false)) {
< 						String name = (String) items[i];
< 						pathVariablesContent.remove(name);
< 						referencedPathVariablesContent.add(name);
< 						adjustScrollpanes();
332a333,344
> 
>     /**
>      * Queries whether the specified path variable has a remove change pending,
>      * to be applied when the OK/Apply button is pressed.
>      * 
>      * @param variableName
>      *            the path variable name
>      * @return <code>true</code> if the variable has a pending change that is
>      *         a removal; <code>false</code>, otherwise
>      */
>     boolean isRemoved(String variableName) {
>         return variableChanges.get(variableName) == removedToken;
333a598,598
> 
334,334d597
< 		});
335a347,355
>     /**
>      * Updates the map of pending path variable changes to indicate that the
>      * specified variable's value has been changed by the user.
>      * 
>      * @param variableName
>      *            the name of the changed variable
>      */
>     private void markChanged(String variableName) {
>         Object currentChange = variableChanges.get(variableName);
335a203,206
>         });
> 
>         newVariable.addSelectionListener(new SelectionAdapter() {
> 
336,336d202
< 		remove.addSelectionListener(new SelectionListener() {
337,337c207,207
< 			public void widgetSelected(SelectionEvent e) {
---
>             public void widgetSelected(SelectionEvent e) {
337a208,208
>                 addPathVariable();
338,339d207
< 				IStructuredSelection selection =
< 					(IStructuredSelection) referencedPathVariables.getSelection();
340a357,361
>         if (currentChange == addedToken) {
>             // do nothing in this case. If it was added, changing it doesn't
>             // change the fact that it's a new variable
>         } else {
>             variableChanges.put(variableName, changedToken);
341,345d356
< 				for (Iterator iter = selection.iterator(); iter.hasNext();) {
< 					String name = (String) iter.next();
< 					referencedPathVariablesContent.remove(name);
< 					pathVariablesContent.add(name);
< 					adjustScrollpanes();
348a365,375
>     /**
>      * Queries whether the specified path variable has a change of value
>      * pending, to be applied when the OK/Apply button is pressed.
>      * 
>      * @param variableName
>      *            the path variable name
>      * @return <code>true</code> if the variable has a pending change that is
>      *         a value change; <code>false</code>, otherwise
>      */
>     boolean isChanged(String variableName) {
>         return variableChanges.get(variableName) == changedToken;
349,350d364
< 			public void widgetDefaultSelected(SelectionEvent e) {
< 				// No action is necessary
351a601,601
> 
352,352d600
< 		});
353a378,397
>     /**
>      * Queries whether the current pending path variables (not yet applied to
>      * the workspace and GMF path map manager) has a variable referencing the
>      * specified location. Note that this does not consider path variables that
>      * are pending removal or others that are currently defined in the workspace
>      * and/or GMF that are not visible.
>      * 
>      * @param location
>      *            a location
>      * @return <code>true</code> if any of the path variables showing in the
>      *         preference page has the specified location; <code>false</code>,
>      *         otherwise
>      */
>     boolean isLocationDefined(IPath location) {
>         for (Iterator iter = pathVariablesContent.entries.iterator(); iter
>             .hasNext();) {
>             if (location.equals(((PathVariableEntry) iter.next())
>                 .getLocationPath())) {
>                 return true;
>             }
354,356d377
< 		removeAll.addSelectionListener(new SelectionListener() {
< 			public void widgetDefaultSelected(SelectionEvent e) {
< 				// No action is necessary
359,367d399
< 			public void widgetSelected(SelectionEvent e) {
< 				Object[] items = referencedPathVariablesContent.getElements(null);
< 				
< 				for (int i=items.length - 1; i >= 0; i--) {
< 					if (validateRemovals(new StructuredSelection(items[i]), false)) {
< 						String name = (String) items[i];
< 						referencedPathVariablesContent.remove(name);
< 						pathVariablesContent.add(name);
< 						adjustScrollpanes();
368a402,424
> 
>     /**
>      * Handles the pushing of the "New..." button, to create a new path map
>      * variable.
>      */
>     private void addPathVariable() {
>         NewPathVariableDialog dlg = NewPathVariableDialog.openNew(this);
>         if (dlg != null) {
>             String name = dlg.getVariableName();
>             IPath location = dlg.getVariableLocation();
> 
>             // prepare data for synchronization on apply
>             markAdded(name);
> 
>             // by default, check the variable (if the user created it in this
>             // pref page, assume that it should be used for GMF modeling)
>             PathVariableEntry entry = new PathVariableEntry(name, location);
>             entry.setSelected(true);
>             pathVariablesContent.add(entry);
>             pathVariables.setChecked(entry, true);
> 
>             // select the new path variable
>             pathVariables.setSelection(new StructuredSelection(entry));
370a621,621
>         }
371,371d620
< 		});
372a224,225
>         });
> 
372a428,437
>     /**
>      * Handles the pushing of the "Edit..." button, to edit the path variable
>      * contained in the specified <code>selection</code>.
>      * 
>      * @param selection
>      *            the current selection in the path variables list (should
>      *            contain a single {@link PathVariableEntry})
>      */
>     private void editPathVariable(ISelection selection) {
>         PathVariableEntry entry = null;
373,373c226,226
< 		initializeContents();
---
>         initializeContents();
374a439,443
>         if (selection instanceof IStructuredSelection) {
>             IStructuredSelection ssel = (IStructuredSelection) selection;
> 
>             if (!ssel.isEmpty()) {
>                 entry = (PathVariableEntry) ssel.getFirstElement();
375,383d438
< 		// In case of any changes to the path variables, we will refresh ourselves to show
< 		//  the up-to-date information.
< 		pathVariableChangeListener = new IPathVariableChangeListener() {
< 			public void pathVariableChanged(IPathVariableChangeEvent event) {
< 				referencedPathVariables.getTable().getDisplay().asyncExec(new Runnable() {
< 					public void run() {
< 						if (!PathmapsPreferencePage.this.disposed) {
< 							performDefaults();
< 						}
384a632,632
> 
385,385d631
< 				});
387,388d445
< 		};
< 		ResourcesPlugin.getWorkspace().getPathVariableManager().addChangeListener(pathVariableChangeListener);
389a447,450
>         if (entry != null) {
>             String oldName = entry.getName();
>             NewPathVariableDialog dlg = NewPathVariableDialog.openEdit(this,
>                 oldName, entry.getLocation());
390,390c400,400
< 		disposed = false;
---
>         return false;
391a452,455
>             if (dlg != null) {
>                 String newName = dlg.getVariableName();
>                 IPath newLocation = dlg.getVariableLocation();
>                 boolean nameChanged = !oldName.equals(newName);
392,392c228,228
< 		applyDialogFont(composite);
---
>         applyDialogFont(composite);
393a230,231
>         pathVariableSelected(pathVariables.getSelection());
> 
393a457,466
>                 if (nameChanged) {
>                     // changing the name is like removing the old name
>                     // and adding the new name
> 
>                     // prepare data for synchronization on apply
>                     markAdded(newName);
>                     markRemoved(oldName);
>                 } else {
>                     // prepare data for synchronization on apply
>                     markChanged(oldName);
394a233,233
>     }
394,394c232,232
< 		return composite;
---
>         return composite;
396a469,470
>                 entry.setName(newName);
>                 entry.setLocation(newLocation);
397,414d468
< 	private void adjustScrollpanes() {
< 		pathVariablesScroll.setMinSize(
< 				pathVariables.getTable().computeSize(SWT.DEFAULT, SWT.DEFAULT));
< 		pathVariablesScroll.layout();
< 		referencedPathVariablesScroll.setMinSize(
< 				referencedPathVariables.getTable().computeSize(SWT.DEFAULT, SWT.DEFAULT));
< 		referencedPathVariablesScroll.layout();
< 	}
< 	
< 	private String getValue(String pathVariable, boolean includeRegistered) {
< 		String result = null;
< 		
< 		if (includeRegistered && PathmapManager.isRegisteredPathVariable(pathVariable)) {
< 			String path = PathmapManager.getRegisteredValue(pathVariable);
< 			
< 			if (path != null) {
< 				URI uri = URI.createURI(path);
< 				uri = CommonPlugin.resolve(uri);
415a472,476
>                 pathVariables.update(entry,
>                     nameChanged ? new String[] {NAME_ATTRIBUTE}
>                         : null);
>             }
>         }
416,419d471
< 				if (uri.isFile()) {
< 					path = uri.toFileString();
< 				} else {
< 					path = uri.toString();
421a479,495
>     /**
>      * Handles the pushing of the "Remove" button, to remove the path
>      * variable(s) contained in the specified <code>selection</code>.
>      * 
>      * @param selection
>      *            the current selection in the path variables list (should
>      *            contain one or more {@link PathVariableEntry}s of which none
>      *            is registered on the extension point)
>      */
>     private void removePathVariable(ISelection selection) {
>         Iterator entries = null;
> 
>         if (selection instanceof IStructuredSelection) {
>             IStructuredSelection ssel = (IStructuredSelection) selection;
> 
>             if (!ssel.isEmpty()) {
>                 entries = ssel.iterator();
422,422d478
< 				result = path;
423a497,502
>         }
> 
>         if (entries != null) {
>             while (entries.hasNext()) {
>                 PathVariableEntry entry = (PathVariableEntry) entries.next();
>                 String name = entry.getName();
424,426d496
< 		} else {
< 			IPathVariableManager pathVarMgr =
< 				ResourcesPlugin.getWorkspace().getPathVariableManager();
427a504,505
>                 // prepare data for synchronization on apply
>                 markRemoved(name);
428,428d503
< 			IPath path = pathVarMgr.getValue(pathVariable);
429a507,508
>                 pathVariablesContent.remove(entry);
>             }
430,431d506
< 			if (path != null) {
< 				result = path.toOSString();
434a512,532
>     /**
>      * Validates an attempt to check a previously unchecked path variable in the
>      * list, optionally showing an error explaining the reason why this is not
>      * permitted.
>      * 
>      * @param entry
>      *            a path variable that the user attempted to check
>      * @param showError
>      *            whether to show any potential error message in the title area
>      * @return whether the checking of this variable is permitted
>      */
>     private boolean validateSelection(PathVariableEntry entry, boolean showError) {
>         String name = entry.getName();
> 
>         if (!PathmapManager.isCompatiblePathVariable(name)) {
>             if (showError) {
>                 setMessage(
>                     EMFUIMessages.PathmapsPreferencePage_incompatiblePathVariableErrorMessage,
>                     ERROR);
>             }
>             return false;
435,435d511
< 		return result;
437a535,540
>         if (PathmapManager.isRegisteredPathVariable(name)) {
>             if (showError) {
>                 setMessage(
>                     EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
>                     ERROR);
>             }
438,439d534
< 	private boolean validateAdditions(IStructuredSelection selection, boolean showError) {
< 		if (selection.isEmpty())
441a717,722
>         Set currentVariables = PathmapManager.getPathVariableReferences();
> 
>         try {
>             // first, process the removed workspace path variables
>             for (Iterator iter = variableChanges.keySet().iterator(); iter
>                 .hasNext();) {
442,442d716
< 		for (Iterator iter = selection.iterator(); iter.hasNext();) {
443,443c723,723
< 			String name = (String) iter.next();
---
>                 String name = (String) iter.next();
443a724,727
> 
>                 if (isRemoved(name)) {
>                     if (pathVariableManager.isDefined(name)) {
>                         pathVariableManager.setValue(name, null);
444a753,756
>                 if (entry.isSelected() && !currentVariables.contains(name)) {
>                     PathmapManager.addPathVariableReference(name);
>                 } else if (!entry.isSelected()
>                     && currentVariables.contains(name)) {
444a547,560
>     /**
>      * Validates an attempt to uncheck a previously checked path variable in the
>      * list, optionally showing an error explaining the reason why this is not
>      * permitted.
>      * 
>      * @param entry
>      *            a path variable that the user attempted to uncheck
>      * @param showError
>      *            whether to show any potential error message in the title area
>      * @return whether the unchecking of this variable is permitted
>      */
>     private boolean validateDeselection(PathVariableEntry entry,
>             boolean showError) {
>         if (entry.isRequired()) {
445,445c757,757
< 			if (!PathmapManager.isCompatiblePathVariable(name)) {
---
>                     PathmapManager.removePathVariableReference(name);
446a628,628
>                     setMessage(
447a630,630
>                         ERROR);
447,447c629,629
< 					setMessage(EMFUIMessages.PathmapsPreferencePage_incompatiblePathVariableErrorMessage,ERROR);
---
>                         EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
451a569,591
>         return true;
>     }
> 
>     /**
>      * Queries whether it is permitted to edit the specified
>      * <code>selection</code> of path variables. Editing is only permitted for
>      * a single selection that is not a registered path variable.
>      * 
>      * @param selection
>      *            the current selection in the path variables list
>      * @param showError
>      *            whether to show any potential error message in the title area
>      * @return whether the editing of this selection is permitted
>      */
>     private boolean validateEdit(IStructuredSelection selection,
>             boolean showError) {
>         if (selection.isEmpty() || (selection.size() > 1)) {
>             return false;
>         }
> 
>         String name = ((PathVariableEntry) selection.getFirstElement())
>             .getName();
> 
453a562,562
>                 setMessage(
454,454c563,563
< 					setMessage(EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,ERROR);
---
>                     EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
454a564,564
>                     ERROR);
457a636,636
> 
458,458d635
< 		}
461a605,619
>     /**
>      * Queries whether it is permitted to remove the specified
>      * <code>selection</code> of path variables. Removal is only permitted
>      * when the selection is not empty and does not contain any registered path
>      * variable.
>      * 
>      * @param selection
>      *            the current selection in the path variables list
>      * @param showError
>      *            whether to show any potential error message in the title area
>      * @return whether the editing of this selection is permitted
>      */
>     private boolean validateRemove(IStructuredSelection selection,
>             boolean showError) {
>         if (selection.isEmpty()) {
462,463d604
< 	private boolean validateRemovals(IStructuredSelection selection, boolean showError) {
< 		if (selection.isEmpty())
467,467c624,624
< 			String name = (String) iter.next();
---
>             String name = ((PathVariableEntry) iter.next()).getName();
470a594,594
>                 setMessage(
471,471c595,595
< 					setMessage(EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,ERROR);
---
>                     EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
471a596,596
>                     ERROR);
478a640,643
>     /**
>      * Loads the contents of the Path Variables list, additionally setting the
>      * check state of each variable.
>      */
481,482d645
< 		add.setEnabled(true);
< 		remove.setEnabled(true);
483a647,647
>         variableChanges.clear();
484,484d646
< 		referencedPathVariables.setInput(new HashSet(PathmapManager.getAllPathVariables()));
487a651,694
>         Set allVariables = new HashSet();
>         Set checkedVariables = new HashSet();
> 
>         Set pathVariableNames = new HashSet();
>         pathVariableNames.addAll(Arrays.asList(pathVariableManager
>             .getPathVariableNames()));
>         pathVariableNames.addAll(PathmapManager.getAllPathVariables());
> 
>         for (Iterator iter = pathVariableNames.iterator(); iter.hasNext();) {
>             String name = (String) iter.next();
>             PathVariableEntry entry;
> 
>             if (PathmapManager.isRegisteredPathVariable(name)) {
>                 String value = PathmapManager.getRegisteredValue(name);
> 
>                 try {
>                     URI uri = URI.createURI(value);
> 
>                     if (uri.isFile()) {
>                         // show the user a familiar file system path instead
>                         // of a URI
>                         value = uri.toFileString();
>                     }
>                 } catch (RuntimeException e) {
>                     // the value is not a valid URI. Nothing for us to
>                     // do; that is a problem for the plug-in developer
>                     // who registered this path map. We'll show the
>                     // value as is
>                 }
> 
>                 entry = new PathVariableEntry(name, value);
>                 checkedVariables.add(entry);
>                 allVariables.add(entry);
>             } else if (PathmapManager.isCompatiblePathVariable(name)) {
> 
>                 entry = new PathVariableEntry(name, pathVariableManager
>                     .getValue(name));
> 
>                 if (currentVariables.contains(entry.getName())) {
>                     checkedVariables.add(entry);
>                     entry.setSelected(true);
>                 }
> 
>                 allVariables.add(entry);
488,492d650
< 		Set available = new HashSet();
< 		String[] pathVariableNames = ResourcesPlugin.getWorkspace().getPathVariableManager().getPathVariableNames();
< 		for (int i=0; i<pathVariableNames.length; i++) {
< 			if (!currentVariables.contains(pathVariableNames[i])) {
< 				available.add(pathVariableNames[i]);
496,496c698,698
< 		pathVariables.setInput(available);
---
>         pathVariables.setInput(allVariables);
496a699,699
>         pathVariables.setCheckedElements(checkedVariables.toArray());
507a711,715
>     /**
>      * Applies the current check state of every path variable to the GMF
>      * {@link PathmapManager}'s list of path variable references and saves the
>      * preference store.
>      */
509,512d716
< 		Object[] nonReferencedPathVariables = pathVariablesContent.getElements(null);
< 		for (int i=0; i<nonReferencedPathVariables.length; i++) {
< 			String variableName = (String) nonReferencedPathVariables[i];
< 			PathmapManager.removePathVariableReference(variableName);
514a730,730
>                     PathmapManager.removePathVariableReference(name);
515,518d729
< 		Set currentVariables = PathmapManager.getAllPathVariables();
< 		Object[] variablesToReference = referencedPathVariablesContent.getElements(null);
< 		for (int i=0; i<variablesToReference.length; i++) {
< 			String variableName = (String) variablesToReference[i];
519a732,732
>                     iter.remove(); // successfully processed this change
520,521d731
< 			if (!currentVariables.contains(variableName)) {
< 				PathmapManager.addPathVariableReference(variableName);
524a736,741
>             // next, process the current set of path variable references to
>             // add/remove them according to the user's preferences
>             Object[] variables = pathVariablesContent.getElements(null);
>             for (int i = 0; i < variables.length; i++) {
>                 PathVariableEntry entry = (PathVariableEntry) variables[i];
>                 String name = entry.getName();
525,525d735
< 		PathmapManager.updatePreferenceStore();
526a743,750
>                 if (isChanged(name) || isAdded(name)
>                     && !pathVariableManager.isDefined(name)) {
>                     // set the workspace path variable's new value, now
>                     pathVariableManager.setValue(name, new Path(entry
>                         .getLocation()));
> 
>                     // successfully processed this change
>                     variableChanges.remove(name);
527,527c544,544
< 		return true;
---
>         return true;
527a545,545
>     }
530,534d752
< 	public void dispose() {
< 		disposed = true;
< 		if (pathVariableChangeListener != null) {
< 			ResourcesPlugin.getWorkspace().getPathVariableManager().removeChangeListener(pathVariableChangeListener);
< 			pathVariableChangeListener = null;
535a835,836
>         PathVariableLabelProvider() {
>             super();
536,536d834
< 		super.dispose();
538a761,780
>             PathmapManager.updatePreferenceStore();
> 
>             return true;
>         } catch (CoreException e) {
>             ErrorDialog.openError(getShell(),
>                 EMFUIMessages.PathmapsPreferencePage_promptTitle,
>                 EMFUIMessages.PathmapsPreferencePage_updateFailed, e
>                     .getStatus());
>             return false;
>         }
>     }
> 
>     /**
>      * A content provider for the Path Variables list.
>      */
>     private static class PathVariableContentProvider
>         implements IStructuredContentProvider {
> 
>         private Set entries;
> 
539,540d760
< 	private static class StringsContentProvider implements IStructuredContentProvider {
< 		private Set strings;
543,543c783,783
< 		StringsContentProvider() {
---
>         PathVariableContentProvider() {
544,544c784,784
< 			strings = new HashSet();
---
>             entries = new HashSet();
546a787,796
>         /**
>          * Adds a path variable to the list.
>          * 
>          * @param entry
>          *            the new path variable
>          */
>         void add(PathVariableEntry entry) {
>             if (!entries.contains(entry)) {
>                 entries.add(entry);
>                 table.add(entry);
547,550d786
< 		void add(String string) {
< 			if (!strings.contains(string)) {
< 				strings.add(string);
< 				table.add(string);
553a800,809
>         /**
>          * Removes a path variable from the list.
>          * 
>          * @param entry
>          *            the path variable to remove
>          */
>         void remove(PathVariableEntry entry) {
>             if (entries.contains(entry)) {
>                 entries.remove(entry);
>                 table.remove(entry);
554,557d799
< 		void remove(String string) {
< 			if (strings.contains(string)) {
< 				strings.remove(string);
< 				table.remove(string);
562,562c814,814
< 			return strings.toArray();
---
>             return entries.toArray();
566,566c818,818
< 			strings = (Set) newInput;
---
>             entries = (Set) newInput;
574a827,830
>     /**
>      * A label provider for the Path Variables list.
>      */
>     private static class PathVariableLabelProvider
575,575c831,831
< 	private static class StringsLabelProvider implements ITableLabelProvider, IColorProvider {
---
>         implements ITableLabelProvider, IColorProvider {
576,576d831
< 		private final boolean isReferencedPathVariables;
580,585d834
< 		StringsLabelProvider() {
< 			this(false);
< 		}
< 		
< 		StringsLabelProvider(boolean isReferencedPathVariables) {
< 			this.isReferencedPathVariables = isReferencedPathVariables;
587a839,841
>         /**
>          * Shows a lock icon for registered path variables.
>          */
588a843,845
>             PathVariableEntry entry = (PathVariableEntry) element;
>             String name = entry.getName();
> 
589,589c846,846
<             if (isReferencedPathVariables && PathmapManager.isRegisteredPathVariable((String) element)) {
---
>             if (PathmapManager.isRegisteredPathVariable(name)) {
590a848,851
>             } else if (!isDirectory(entry.getLocation())) {
>                 return MslUIPlugin.getDefault().getWorkbench()
>                     .getSharedImages()
>                     .getImage(ISharedImages.IMG_OBJS_WARN_TSK);
595a857,876
>         /**
>          * Queries whether the specified location references a directory that
>          * exists.
>          * 
>          * @param location
>          *            a location
>          * @return <code>true</code> if the location exists in the filesystem
>          *         and is a directory
>          */
>         private boolean isDirectory(String location) {
>             File file = new File(location);
> 
>             return file.exists() && file.isDirectory();
>         }
> 
>         /**
>          * Obtains the lazily-initialized lock image.
>          * 
>          * @return the lock image
>          */
597a879,880
>                 lockImage = MslUIPlugin
>                     .imageDescriptorFromPlugin(MslUIPlugin.getPluginId(),
598,598d878
<                 lockImage = MslUIPlugin.imageDescriptorFromPlugin(
599,599c881,881
<                     MslUIPlugin.getPluginId(), "/icons/full/lock.gif").createImage(); //$NON-NLS-1$
---
>                         "/icons/full/lock.gif").createImage(); //$NON-NLS-1$
604a887,890
>         /**
>          * Path variables are displayed in the same way as in the Linked
>          * Resources preference page.
>          */
605a892,899
>             if (columnIndex != 0) {
>                 return null;
>             }
> 
>             PathVariableEntry entry = (PathVariableEntry) element;
>             return NLS.bind(
>                 EMFUIMessages.PathmapsPreferencePage_variablePattern, entry
>                     .getName(), entry.getLocation());
606,606d891
< 			return (columnIndex == 0) ? (String) element : null;
636a930,937
>     /**
>      * A sorter for the Path Variables list. All registered path maps sort to
>      * the bottom of the list to keep them out of the user's way.
>      */
>     private static class PathVariableViewerComparator
>         extends ViewerComparator {
> 
>         PathVariableViewerComparator() {
637,638d929
< 	private static class StringsViewerComparator extends ViewerComparator {
< 		StringsViewerComparator() {
641a941,950
>         /**
>          * We sort by <code>name</code>.
>          */
>         public boolean isSorterProperty(Object element, String property) {
>             return NAME_ATTRIBUTE.equals(property);
>         }
> 
>         /**
>          * Registered variables are in a higher category than user variables.
>          */
643a953,1098
>             return PathmapManager
>                 .isRegisteredPathVariable(((PathVariableEntry) element)
>                     .getName()) ? 1
>                 : 0;
>         }
>     }
> 
>     /**
>      * Data model for a path variable in the Path Variables list.
>      */
>     private static final class PathVariableEntry {
> 
>         private String name;
> 
>         private String location;
> 
>         private IPath locationPath;
> 
>         private final boolean required;
> 
>         private boolean selected;
> 
>         /**
>          * Initializes a user-defined path variable with the name and location
>          * path.
>          * 
>          * @param name
>          *            the variable name
>          * @param location
>          *            the location
>          */
>         PathVariableEntry(String name, IPath location) {
>             this(name, location.toPortableString(), false);
> 
>             this.locationPath = location;
>         }
> 
>         /**
>          * Initializes a registered path variable with the name and location
>          * derived from the URI.
>          * 
>          * @param name
>          *            the variable name
>          * @param location
>          *            the location URI
>          */
>         PathVariableEntry(String name, String location) {
>             this(name, location, true);
>         }
> 
>         private PathVariableEntry(String name, String location, boolean required) {
>             this.name = name;
>             this.location = location;
>             this.required = required;
>             selected = required;
>         }
> 
>         /**
>          * Queries whether this path variable is required (a registered path
>          * variable that the user cannot edit, remove, or uncheck).
>          * 
>          * @return whether I am required
>          */
>         boolean isRequired() {
>             return required;
>         }
> 
>         /**
>          * Obtains the path variable name.
>          * 
>          * @return my name
>          */
>         String getName() {
>             return name;
>         }
> 
>         /**
>          * Sets the path variable name, if it is editable.
>          * 
>          * @param name
>          *            the new name
>          */
>         void setName(String name) {
>             if (!isRequired()) {
>                 this.name = name;
>             }
>         }
> 
>         /**
>          * Obtains the path variable location.
>          * 
>          * @return my location
>          */
>         String getLocation() {
>             return location;
>         }
> 
>         /**
>          * Obtains the path variable location, as an {@link IPath}.
>          * 
>          * @return my location
>          */
>         IPath getLocationPath() {
>             return locationPath;
>         }
> 
>         /**
>          * Sets the path variable name, if it is editable.
>          * 
>          * @param location
>          *            the new location
>          */
>         void setLocation(IPath location) {
>             if (!isRequired()) {
>                 this.locationPath = location;
>                 this.location = location.toPortableString();
>             }
>         }
> 
>         /**
>          * Queries whether the path variable is checked. Required (registered)
>          * path variables are always checked.
>          * 
>          * @return whether I am checked
>          */
>         boolean isSelected() {
>             return selected;
>         }
> 
>         /**
>          * Sets whether the path variable is checked, if it is not registered.
>          * 
>          * @param selected
>          *            whether I am checked
>          */
>         void setSelected(boolean selected) {
>             if (!isRequired()) {
>                 this.selected = selected;
>             }
>         }
> 
>         /**
>          * Displays path variable's debug string.
>          */
>         public String toString() {
>             return getName() + " - " + getLocation(); //$NON-NLS-1$
644,644d952
< 			return PathmapManager.isRegisteredPathVariable((String) element)? 1 : 0;
