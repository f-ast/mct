16a17,17
> import java.util.Iterator;
27a29,29
> 	private final HashMap myAbstractEClass2SubclassesRecord;
30a33,33
> 		myAbstractEClass2SubclassesRecord = new HashMap();
36a40,43
> 	public Copier getCopier(EClass eClass) {
> 		return getRecord(eClass, false).getCopier();
> 	}
> 	
44a52,64
> 	protected final void setCopier(EClass eClass, Copier copier){
> 		getRecord(eClass, true).setCopier(copier);
> 	}
> 	
> 	protected final void setMatcherForAllSubclasses(EClass eClass, Matcher matcher){
> 		if (!eClass.isAbstract()){
> 			throw new IllegalArgumentException(
> 					"This is not safe method that may lead to strange behaviour in case of multiple inheritance. " +
> 					"We tried to limit its usage as much as possible");
> 		}
> 		getTemplateRecord(eClass, true).setMatcher(matcher);
> 	}
> 	
71a92,99
> 				for (Iterator superClasses = eClass.getEAllSuperTypes().iterator(); result == EMPTY_RECORD && superClasses.hasNext();){
> 					EClass nextSuper = (EClass) superClasses.next();
> 					result = getTemplateRecord(nextSuper, false);
> 				}
> 				if (result != EMPTY_RECORD){
> 					//cache it for the next time
> 					myEClass2Record.put(eClass, result);
> 				}
76a105,114
> 	private EClassRecord getTemplateRecord(EClass abstractSuperClass, boolean force){
> 		assert abstractSuperClass.isAbstract();
> 		EClassRecord result = (EClassRecord)myAbstractEClass2SubclassesRecord.get(abstractSuperClass);
> 		if (result == null && force){
> 			result = new EClassRecord();
> 			myAbstractEClass2SubclassesRecord.put(abstractSuperClass, result);
> 		}
> 		return result == null ? EMPTY_RECORD : result;
> 	}
> 	
90a129,129
> 		private Copier myCopier = Copier.NEVER_COPY;
98a138,141
> 		public void setCopier(Copier copier) {
> 			myCopier = copier;
> 		}
> 
113a157,160
> 		public Copier getCopier() {
> 			return myCopier;
> 		}
> 		
