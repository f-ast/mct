17,17d16
< import java.util.Dictionary;
20,20d18
< import java.util.Hashtable;
31,31c31,31
< import org.eclipse.emf.ecore.ENamedElement;
---
> import org.eclipse.emf.transaction.RunnableWithResult;
54a51,51
> import org.eclipse.gmf.runtime.common.core.util.Log;
55,55c52,52
< import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
---
> import org.eclipse.gmf.runtime.common.core.util.Trace;
70,70c64,64
< import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
---
> import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
70a65,66
> import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
> import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
80,81d80
< import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
< import org.eclipse.gmf.runtime.emf.core.util.MetaModelUtil;
82,82c81,81
< import org.eclipse.gmf.runtime.emf.core.util.ProxyUtil;
---
> import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;
127a127,131
> 	 * Cache the editing domain after it is retrieved.
> 	 */
> 	private TransactionalEditingDomain editingDomain;
> 
> 	/**
151,151c155,155
< 		EObject semanticElement = ProxyUtil.resolve(MEditingDomainGetter.getMEditingDomain((EObject)getModel()), semanticProxy);
---
> 		EObject semanticElement = EMFCoreUtil.resolve(TransactionUtil.getEditingDomain((EObject)getModel()), semanticProxy);
181,181c185,185
< 		DiagramEventBroker.getInstance().addNotificationListener(element,listener);
---
> 		getDiagramEventBroker().addNotificationListener(element,listener);
205,205c209,209
< 		DiagramEventBroker.getInstance().addNotificationListener(element,feature,listener);
---
> 		getDiagramEventBroker().addNotificationListener(element,feature,listener);
249a254,254
> 					getDiagramEventBroker().
250,250d253
< 					DiagramEventBroker.getInstance().
253,253c257,257
< 					DiagramEventBroker.getInstance().removeNotificationListener((EObject) obj[0],(NotificationListener) obj[1]);
---
> 					getDiagramEventBroker().removeNotificationListener((EObject) obj[0],(NotificationListener) obj[1]);
301,301c305,305
< 					semanticObject = ProxyUtil.resolve(MEditingDomainGetter.getMEditingDomain(element), element);
---
> 					semanticObject = EMFCoreUtil.resolve(TransactionUtil.getEditingDomain(element), element);
395a400,404
> 			try {
> 				cmd = (Command) TransactionUtil.getEditingDomain(
> 					(EObject) getModel()).runExclusive(
> 					new RunnableWithResult.Impl() {
> 
396,397d399
< 			cmd =  (Command) MEditingDomainGetter.getMEditingDomain((EObject)getModel()).runAsRead(new MRunnable() {
< 				
398,398c405,405
< 				public Object run() {
---
> 						public void run() {
399a407,407
> 								.getCommand(request));
399,399c406,406
< 					return GraphicalEditPart.super.getCommand(request);
---
> 							setResult(GraphicalEditPart.super
401a410,417
> 			} catch (InterruptedException e) {
> 				Trace.catching(DiagramUIPlugin.getInstance(),
> 					DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
> 					"getCommand", e); //$NON-NLS-1$
> 				Log.error(DiagramUIPlugin.getInstance(),
> 					DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
> 					"getCommand", e); //$NON-NLS-1$
> 			}
593a610,613
> 		try {
> 			return (EObject) TransactionUtil.getEditingDomain(
> 				(EObject) getModel()).runExclusive(
> 				new RunnableWithResult.Impl() {
594,594d609
< 		return (EObject) MEditingDomainGetter.getMEditingDomain((EObject)getModel()).runAsRead(new MRunnable() {
596,596c615,615
< 			public Object run() {
---
> 					public void run() {
597a617,619
> 						if (model instanceof View) {
> 							setResult(ViewUtil
> 								.resolveSemanticElement((View) getModel()));
598,599d616
< 				if (model instanceof View)
< 					return ViewUtil.resolveSemanticElement((View)getModel());
600,600c620,620
< 				else if (model instanceof EObject){
---
> 						} else if (model instanceof EObject) {
602a623,623
> 								setResult(EMFCoreUtil.resolve(getEditingDomain(), element));
603,603d622
< 				    	return ProxyUtil.resolve(element); 
605,605c625,625
< 						return element;
---
> 								setResult(element);
606a1215,1215
> 	public Command transactionAboutToCommit(Notification notification) {
607,607c1216,1216
< 				return null;
---
> 		return null;
607a1217,1219
> 	}
> 
> 	
609a629,638
> 		} catch (InterruptedException e) {
> 			Trace.catching(DiagramUIPlugin.getInstance(),
> 				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
> 				"resolveSemanticElement", e); //$NON-NLS-1$
> 			Log.error(DiagramUIPlugin.getInstance(),
> 				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
> 				"resolveSemanticElement", e); //$NON-NLS-1$
> 			return null;
> 		}
> 
691a721,723
> 		try {
> 			TransactionUtil.getEditingDomain((EObject) getModel())
> 				.runExclusive(new Runnable() {
692,692d720
< 		MEditingDomainGetter.getMEditingDomain((EObject)getModel()).runAsRead(new MRunnable() {
694,694c725,725
< 			public Object run() {
---
> 				public void run() {
703,703d733
< 				return null;
705a736,744
> 		} catch (InterruptedException e) {
> 			Trace.catching(DiagramUIPlugin.getInstance(),
> 				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
> 				"refresh", e); //$NON-NLS-1$
> 			Log.error(DiagramUIPlugin.getInstance(),
> 				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
> 				"refresh", e); //$NON-NLS-1$
> 		}
> 
773a813,813
> 			getDiagramEventBroker().
774,774d812
< 			DiagramEventBroker.getInstance().
779,779c818,818
< 			DiagramEventBroker.getInstance().removeNotificationListener((EObject) objects[0],(NotificationListener) objects[1]);
---
> 			getDiagramEventBroker().removeNotificationListener((EObject) objects[0],(NotificationListener) objects[1]);
904,980d942
< 	 * Return a Map of all the appearance property ids supported by the edit
< 	 * part and its children.
< 	 * 
< 	 * Each entry in the map is the factory hint of the edit part as key and a
< 	 * dictionary of appearance properties as values. The edit parts are the
< 	 * receiver itself and it's children.
< 	 * 
< 	 * For example, the connectable shape edit part with name, attribute,
< 	 * operation and shape compartments will return a map where: 1 entry:
< 	 * connectable shape factory hint -> dictionary: Properties.ID_FONT -> font
< 	 * data Properties.ID_FONTCOLOR -> font color Properties.ID_LINECOLOR ->
< 	 * line color Properties.ID_FILLCOLOR -> fill color 2d entry: attribute
< 	 * compartment hint -> dictionary(empty) 3d entry: operation compartment
< 	 * hint -> dictionary(empty) 4d entry: shape compartment hint ->
< 	 * dictionary(empty)
< 	 * 
< 	 * @return Map
< 	 */
< 	public Map getAppearancePropertiesMap() {
< 		Map properties = new HashMap();
< 		fillAppearancePropertiesMap(properties);
< 		// for each of the children fill
< 		Iterator iterator = getChildren().iterator();
< 		while (iterator.hasNext()) {
< 			IGraphicalEditPart child = (IGraphicalEditPart) iterator.next();
< 			child.fillAppearancePropertiesMap(properties);
< 		}
< 		return properties;
< 	}
< 
< 	/**
< 	 * Add to the parent edit part appearance properties map. Edit parts that
< 	 * have thier own appearance properties in addition to the parent edit part
< 	 * font, font color, line color and fill color should override this method
< 	 * to include their specific appearance properties.
< 	 * 
< 	 * @param properties -
< 	 *            map of appearence properties to which we add our own. The map
< 	 *            has the reciever as a key and string array of the supported
< 	 *            appearance property ids.
< 	 */
< 	public void fillAppearancePropertiesMap(Map properties) {
< 		if (getAppearancePropertyIDs().length > 0) {
< 			// only if there are any appearance properties
< 			final Dictionary local_properties = new Hashtable();
< 			for (int i = 0; i < getAppearancePropertyIDs().length; i++) {
< 				String prob = getAppearancePropertyIDs()[i];
< 				ENamedElement element = MetaModelUtil.getElement(prob);
< 				if (element instanceof EStructuralFeature &&
< 					hasNotationView()&&
< 					ViewUtil.isPropertySupported((View)getModel(), prob))
< 					local_properties.put(
< 						getAppearancePropertyIDs()[i],
< 						getStructuralFeatureValue((EStructuralFeature)element));
< 			}
< 			if (hasNotationView())
< 				properties.put(((View) getModel()).getType(), local_properties);
< 		}
< 	}
< 
< 	/**
< 	 * a static array of appearance property ids applicable to shapes
< 	 */
< 	private static final String[] appearanceProperties = new String[] {Properties.ID_ISVISIBLE};
< 
< 	/**
< 	 * Returns an array of the appearance property ids applicable to the
< 	 * receiver. Fro this type it is Properties.ID_ISVISIBLE
< 	 * 
< 	 * @return - an array of the appearance property ids applicable to the
< 	 *         receiver
< 	 */
< 	private String[] getAppearancePropertyIDs() {
< 		return appearanceProperties;
< 	}
< 
< 	/**
1078,1078c1040,1040
< 		elementGuid = ProxyUtil.getProxyID(ref);
---
> 		elementGuid = EMFCoreUtil.getProxyID(ref);
1325,1325c1292,1292
<      * Derives my editing domain from my diagram view element. Subclasses may
---
>      * Derives my editing domain from my diagram element. Subclasses may
1328a1296,1296
>         if (editingDomain == null) {
1328,1328c1295,1295
<     public TransactionalEditingDomain getEditingDomain() {
---
>     public final TransactionalEditingDomain getEditingDomain() {
1329,1329c1297,1297
<         return TransactionUtil.getEditingDomain(getDiagramView());
---
>             editingDomain = TransactionUtil.getEditingDomain(getDiagramView());
1329a1298,1312
>         }
>         return editingDomain;
>     }
>     
>     /**
>      * Gets the diagram event broker from the editing domain.
>      * 
>      * @return the diagram event broker
>      */
>     private DiagramEventBroker getDiagramEventBroker() {
>         TransactionalEditingDomain theEditingDomain = getEditingDomain();
>         if (theEditingDomain != null) {
>             return DiagramEventBroker.getInstance(theEditingDomain);
>         }
>         return null;
