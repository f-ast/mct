36a37,45
> 		Matcher result = getRecord(eClass, false).getMatcher();
> 		if (result != Matcher.FALSE) {
> 			return result;
> 		}
> 		// XXX Correct strategy whould be to look up first *non-default*
> 		// matcher in the hierarchy, however, for now, expect no more that
> 		// two records per hierarchy chain (e.g. a nondefault matcher for superclass
> 		// plus a record with default matcher for subclass
> 		return getExistingRecordFromHierarchy(eClass).getMatcher();
37,37d36
< 		return getRecord(eClass, false).getMatcher();
90a109,115
> 	/**
> 	 * Looks through the hierarchy of superclasses, checking for registered 
> 	 * records for abstract classes. 
> 	 * @return never null, {@link #EMPTY_RECORD} in case none found 
> 	 */
> 	private EClassRecord getExistingRecordFromHierarchy(EClass eClass) {
> 		EClassRecord result= EMPTY_RECORD;
90a99,99
> 				result = getExistingRecordFromHierarchy(eClass);
91,91d108
< 				result = EMPTY_RECORD;
92a117,118
> 			EClass nextSuper = superClasses.next();
> 			if (nextSuper.isAbstract()) {
92,92c116,116
< 				for (Iterator<EClass> superClasses = eClass.getEAllSuperTypes().iterator(); result == EMPTY_RECORD && superClasses.hasNext();){
---
> 		for (Iterator<EClass> superClasses = eClass.getEAllSuperTypes().iterator(); result == EMPTY_RECORD && superClasses.hasNext();){
93,94d116
< 					EClass nextSuper = superClasses.next();
< 					if (nextSuper.isAbstract()) {
95,95c119,119
< 						result = getTemplateRecord(nextSuper, false);
---
> 				result = getTemplateRecord(nextSuper, false);
96,96d119
< 					}
97a121,124
> 		}
> 		return result;
> 	}
> 
97,97c120,120
< 				}
---
> 			}
