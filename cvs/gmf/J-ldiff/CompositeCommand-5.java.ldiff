2,2c2,2
<  * Copyright (c) 2002, 2004 IBM Corporation and others.
---
>  * Copyright (c) 2006 IBM Corporation and others.
16,16c18,18
< import java.util.Collections;
---
> import java.util.ListIterator;
19a20,25
> import org.eclipse.core.commands.ExecutionException;
> import org.eclipse.core.commands.operations.ICompositeOperation;
> import org.eclipse.core.commands.operations.IUndoContext;
> import org.eclipse.core.commands.operations.IUndoableOperation;
> import org.eclipse.core.resources.IFile;
> import org.eclipse.core.runtime.IAdaptable;
25a32,32
> import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;
26,26d31
< 
31a40,49
>  * An undoable command that is composed of child {@link IUndoableOperation}s
>  * that are not known to modify EMF model resources, but can contain
>  * model-affecting children. Execute, undo, redo and dispose result in execute,
>  * undo, redo and dispose on each child operation. The operation provides a list
>  * of {@link IFile}s that may be modified when the operation is executed,
>  * undone or redone.
>  * <P>
>  * The children are explicitly composed by a client before the composite is
>  * executed. Children cannot be added or removed after the composite has been
>  * executed.
32,34d39
<  * A command that is composed of other
<  * {@link org.eclipse.gmf.runtime.common.core.command.ICommand}s which can be
<  * undone and redone in a single step.
35a51,52
>  * The undo contexts of the composite are a union of the undo contexts of its
>  * children.
36,38d50
<  * A <code>CompositeCommand</code> can only be executed, undone or redone if
<  * all of the {@link org.eclipse.gmf.runtime.common.core.command.ICommand}s
<  * with which it is composed are executable, undoable or redoable, respectively.
39a54,56
>  * If a child command returns a cancel or an error status during execution, undo
>  * or redo, the remaining child commands are not processed and those that have
>  * already been executed are rolled back.
40,42d53
<  * When a <code>CompositeCommand</code> is executed, its commands are not
<  * executed independently of one another. This means that if one command
<  * execution fails, the remaining commands will not be executed.
43a58,58
>  * @author ldamus
44,45d57
<  * @author khussey
<  * @canBeSeenBy %partners
47a61,62
>     extends AbstractCommand
>     implements ICompositeCommand {
48,48d60
< 	implements ICommand {
49a64,66
>     private final List children;
> 
>     private boolean executed;
50,53d63
< 	/**
< 	 * The empty string.
< 	 */
< 	protected static final String EMPTY_STRING = ""; //$NON-NLS-1$
56,56d68
< 	 * The commands of which this composite command is composed.
58,58c479,479
< 	private final List commands = new ArrayList();
---
>         final List result = new ArrayList(size());
60a79,84
>      * Initializes me with a label and a list of child operations.
>      * 
>      * @param label
>      *            a user-readable label
>      * @param children
>      *            a list of child {@link IUndoableOperation}s
61,61d78
< 	 * The label for this composite command.
62a86,94
>     public CompositeCommand(String label, List children) {
>         super(label, null);
> 
>         if (children != null) {
>             this.children = new ArrayList(children);
>         } else {
>             this.children = new ArrayList();
>         }
>     }
63,63d85
< 	private final String label;
66,67d96
< 	 * Flag to indicate whether or not this command was canceled in its last
< 	 * execution.
68a102,104
>     public final boolean isEmpty() {
>         return size() < 1;
>     }
69,69d101
< 	private boolean canceled = false;
71a107,112
>      * Obtains my nested operations. Note that the return result is mutable and
>      * is identical to my child-operation storage, so subclasses should be
>      * careful of adding or removing contents. This should ordinarily be done
>      * only via the {@link #add(IUndoableOperation)} and
>      * {@link #remove(IUndoableOperation)} methods because these maintain the
>      * undo contexts (or, equivalently, using the iterators).
72,72d106
< 	 * Creates a new composite command with the specified label.
73a114,119
>      * @return my list of children
>      * 
>      * @see #add(IUndoableOperation)
>      * @see #remove(IUndoableOperation)
>      * @see #iterator()
>      * @see #listIterator(int)
74,75d113
< 	 * @param label
< 	 *            The label for the new composite command.
76a121,123
>     protected List getChildren() {
>         return children;
>     }
77,77c74,74
< 	public CompositeCommand(String label) {
---
>     public CompositeCommand(String label) {
77a75,76
>         this(label, null);
>     }
78,78d74
< 		super();
79a125,127
>     // Documentation copied from interface
>     public int size() {
>         return getChildren().size();
79a69,72
>      * Initializes me with a label.
>      * 
>      * @param label
>      *            a user-readable label
80,80d68
< 		this.label = label;
83a131,132
>      * Adds a child operation to me. This should only be done before I am
>      * executed. Has no effect if I already contain this operation as a child.
84,85d130
< 	 * Creates a new composite command with the specified label and list of
< 	 * commands.
86a134,138
>      * @param operation
>      *            a new child operation
>      * 
>      * @throws IllegalStateException
>      *             if I have already been successfully executed
87,90d133
< 	 * @param label
< 	 *            The label for the new composite command.
< 	 * @param commands
< 	 *            The initial list of commands
91a140,140
>     public void add(IUndoableOperation operation) {
92,93d139
< 	public CompositeCommand(String label, List commands) {
< 		super();
94a142,142
>         assertNotExecuted();
95,95d141
< 		this.label = label;
96a144,146
>         if (!getChildren().contains(operation)) {
>             getChildren().add(operation);
>             didAdd(operation);
97,101d143
< 		assert null != commands : "null commands"; //$NON-NLS-1$
< 
< 		for (Iterator i = commands.iterator(); i.hasNext();) {
< 			ICommand command = (ICommand) i.next();
< 			compose(command);
105a151,151
>      * Updates my undo contexts for the addition of a new child operation.
106,106d150
< 	 * Retrieves the commands with which this command has been composed.
107a153,154
>      * @param operation
>      *            a new child operation
108,108d152
< 	 * @return The commands with which this command has been composed.
109a156,157
>     private void didAdd(IUndoableOperation operation) {
>         IUndoContext[] childContexts = operation.getContexts();
110,112d155
< 	public final List getCommands() {
< 		return commands;
< 	}
114,123d158
< 	/* (non-Javadoc)
< 	 * @see org.eclipse.gmf.runtime.common.core.command.ICommand#getLabel()
< 	 */
< 	public final String getLabel() {
< 		if (label == null)
< 			if (getCommands().isEmpty())
< 				return null;
< 		if (label != null)
< 			return label;
< 		return ((ICommand) getCommands().get(0)).getLabel();
126a168,178
>      * Removes a child operation from me. This should only be done before I am
>      * executed. Has no effect if I do not contain this operation as a child.
>      * <p>
>      * <b>Note</b> that I do not dispose an operation when it is removed from
>      * me. Although this is specified in the contract of the
>      * {@link ICompositeOperation} interface, this would not be correct, as I
>      * did not create that operation.
>      * </p>
>      * 
>      * @param operation
>      *            a child operation to remove
127,128d167
< 	 * Retrieves the composite result of executing, undoing, or redoing this
< 	 * composite command.
129a180,181
>      * @throws IllegalStateException
>      *             if I have already been successfully executed
130,132d179
< 	 * @return A command result composed of the results of
< 	 *         executing, undoing or redoing the commands of which this composite
< 	 *         command is composed.
133a183,183
>     public void remove(IUndoableOperation operation) {
134,134d182
< 	public CommandResult getCommandResult() {
135a185,189
>         assertNotExecuted();
> 
>         if (getChildren().remove(operation)) {
>             didRemove(operation);
>         }
136,137d184
< 		if (isCanceled()) {
< 			return newCancelledCommandResult();
139a192,199
>     /**
>      * Updates my undo contexts for the removal of a child operation.
>      * 
>      * @param operation
>      *            the child operation that was removed
>      */
>     private void didRemove(IUndoableOperation operation) {
>         IUndoContext[] childContexts = operation.getContexts();
140,140c365,365
< 		List statuses = new ArrayList();
---
>         List result = new ArrayList(size());
140a366,368
> 
>         if (progressMonitor == null) {
>             progressMonitor = new NullProgressMonitor();
141,141d365
< 		List returnValues = new ArrayList();
143,143d200
< 		int severity = IStatus.OK;
144a203,207
>             if (!anyChildHasContext(childContexts[i])) {
>                 removeContext(childContexts[i]);
>             }
>         }
>     }
145,148d202
< 		String plugin = CommonCorePlugin.getPluginId();
< 		int code = CommonCoreStatusCodes.OK;
< 		String message = EMPTY_STRING;
< 		Throwable exception = null;
149a209,219
>     /**
>      * Queries whether any of my children has the specified context.
>      * 
>      * @param ctx
>      *            a context
>      * 
>      * @return <code>false</code> if none of my children has the specified
>      *         context; <code>true</code>, otherwise
>      */
>     private boolean anyChildHasContext(IUndoContext ctx) {
>         boolean result = false;
150,151d208
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
< 			ICommand command = (ICommand) i.next();
152a221,223
>         for (Iterator iter = iterator(); !result && iter.hasNext();) {
>             result = ((IUndoableOperation) iter.next()).hasContext(ctx);
>         }
153,153d220
< 			CommandResult result = command.getCommandResult();
155,158d224
< 			if (result == null) {
< 				// the result can be null if only some of the commands have been
< 				// executed (e.g., the action was abandoned)
< 				break;
160a228,232
>     /**
>      * I can execute if all of my children can execute.
>      */
>     public boolean canExecute() {
>         boolean result = super.canExecute();
161,162d227
< 			IStatus status = result.getStatus();
< 			statuses.add(result.getStatus());
163a494,496
>                     IStatus status = next.redo(new SubProgressMonitor(
>                         progressMonitor, 1), info);
>                     result.add(status);
163a234,235
>         for (Iterator iter = iterator(); result && iter.hasNext();) {
>             result = ((IUndoableOperation) iter.next()).canExecute();
164,164d493
< 			if (severity < status.getSeverity()) {
165,165c497,497
< 				severity = status.getSeverity();
---
>                     int severity = status.getSeverity();
166,169d497
< 				plugin = status.getPlugin();
< 				code = status.getCode();
< 				message = status.getMessage();
< 				exception = status.getException();
171a343,347
>                             } else {
>                                 returnValues.add(returnValue);
>                             }
> 
>                         } else {
172,177d342
< 			Object returnValue = result.getReturnValue();
< 			if (returnValue != null) {
< 				if (getClass().isInstance(command)) {
< 					if (returnValue != null && returnValue instanceof Collection) {
< 						returnValues.addAll((Collection) returnValue);
< 					} else {
178,178c348,348
< 						returnValues.add(returnValue);
---
>                             returnValues.add(returnValue);
178a349,351
>                         }
>                     }
>                 }
179,182d348
< 					}
< 				} else {
< 					returnValues.add(returnValue);
< 				}
183a240,248
> 
>     /**
>      * I can redo if all my children can all be redone.
>      */
>     public boolean canRedo() {
>         boolean result = super.canRedo();
> 
>         for (Iterator iter = iterator(); result && iter.hasNext();) {
>             result = ((IUndoableOperation) iter.next()).canRedo();
186,188d250
< 		return new CommandResult(
< 			new MultiStatus(plugin, code, (IStatus[]) statuses
< 				.toArray(new IStatus[] {}), message, exception), returnValues);
191a255,255
>      * I can undo if all my children can all be undone.
192,196d254
< 	 * Retrieves the collection of objects that would be affected if this
< 	 * composite command were executed, undone, or redone.
< 	 * 
< 	 * @return A collection containing the affected objects of all of the
< 	 *         commands of which this composite command is composed.
197a257,258
>     public boolean canUndo() {
>         boolean result = super.canUndo();
197a762,766
>     /**
>      * Returns a list containing all of the affected files from
>      * <code>ICommand</code> children.
>      */
>     public List getAffectedFiles() {
198,199d761
< 	public final Collection getAffectedObjects() {
< 		List affectedObjects = new ArrayList();
200,200c767,767
< 
---
> 
200a768,769
>         List result = new ArrayList();
> 
201,201c770,770
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
---
>         for (Iterator i = iterator(); i.hasNext();) {
201a771,771
>             IUndoableOperation nextOperation = (IUndoableOperation) i.next();
202a260,261
>         for (Iterator iter = iterator(); result && iter.hasNext();) {
>             result = ((IUndoableOperation) iter.next()).canUndo();
203,206d259
< 			Collection coll = ((ICommand) i.next()).getAffectedObjects();
< 			if (coll != null) {
< 				affectedObjects.addAll(coll);
< 			}
208a225,225
>         return result;
209,209d224
< 		return affectedObjects;
211a36,36
> import org.eclipse.gmf.runtime.common.core.util.Log;
211a267,268
>     /**
>      * Disposes of each of my children.
212,212d35
< 	/* (non-Javadoc)
213,213c37,37
< 	 * @see org.eclipse.gmf.runtime.common.core.command.ICommand#involvesReadOnlyNonWorkSpaceFiles()
---
> import org.eclipse.gmf.runtime.common.core.util.Trace;
214a270,274
>     public void dispose() {
> 
>         for (Iterator iter = iterator(); iter.hasNext();) {
>             IUndoableOperation nextOperation = (IUndoableOperation) iter.next();
>             nextOperation.dispose();
215,218d269
< 	public boolean involvesReadOnlyNonWorkSpaceFiles() {
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
< 			if (((ICommand) i.next()).involvesReadOnlyNonWorkSpaceFiles())
< 				return true;
219a238,238
>         return result;
220,220d237
< 		return false;
227,227c282,282
< 	 * @param command
---
>      * @param operation
231a287,287
> 
231,231c286,286
< 	public final ICommand compose(ICommand command) {
---
>     public final ICommand compose(IUndoableOperation operation) {
232a289,290
>             add(operation);
>         }
232,232c288,288
< 		if (command != null)
---
>         if (operation != null) {
233,233d288
< 			getCommands().add(command);
238,239d294
< 	 * Answers whether this composite command can
< 	 * be executed.
240a736,740
> 
>     /**
>      * Answers whether or not I have been executed.
>      * 
>      * @return <code>true</code> if I have been executed, <code>false</code>
241,242d735
< 	 * @return <code>false</code> if any of the commands of which this
< 	 *         composite command is composed cannot be executed;
243a742,744
>      */
>     protected final boolean isExecuted() {
>         return executed;
243,243c741,741
< 	 *         <code>true</code> otherwise.
---
>      *         otherwise.
244a303,307
>     public ICommand reduce() {
>         switch (size()) {
>             case 1:
>                 IUndoableOperation child = (IUndoableOperation) iterator()
>                     .next();
245,248d302
< 	public final boolean isExecutable() {
< 		if (getCommands().isEmpty())
< 			return false;
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
249a309,310
>                 if (child instanceof ICommand) {
>                     return ((ICommand) child).reduce();
250,251d308
< 			if (!((ICommand) i.next()).isExecutable()) {
< 				return false;
254,254d250
< 
255,255c251,251
< 		return true;
---
>         return result;
258a317,318
>      * Returns a list containing all of the return values from
>      * <code>ICommand</code> children.
259,264d316
< 	 * Answers whether this composite command can
< 	 * be redone.
< 	 * 
< 	 * @return <code>false</code> if any of the commands of which this
< 	 *         composite command is composed cannot be redone; <code>true</code>
< 	 *         otherwise.
265a320,341
>     protected List getReturnValues() {
> 
>         List returnValues = new ArrayList();
> 
>         for (Iterator i = iterator(); i.hasNext();) {
>             IUndoableOperation operation = (IUndoableOperation) i.next();
> 
>             if (operation instanceof ICommand) {
>                 ICommand command = (ICommand) operation;
> 
>                 CommandResult result = command.getCommandResult();
> 
>                 if (result != null) {
>                     Object returnValue = result.getReturnValue();
> 
>                     if (returnValue != null) {
> 
>                         if (getClass().isInstance(command)) {
>                             // unwrap the values from other composites
>                             if (returnValue != null
>                                 && returnValue instanceof Collection) {
>                                 returnValues.addAll((Collection) returnValue);
266,269d319
< 	public final boolean isRedoable() {
< 		if (getCommands().isEmpty())
< 			return false;
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
271,272d342
< 			if (!((ICommand) i.next()).isRedoable()) {
< 				return false;
276,276c264,264
< 		return true;
---
>         return result;
279a359,359
>      * Implements the execution logic by sequential execution of my children.
280,285d358
< 	 * Answers whether this composite command can
< 	 * be undone.
< 	 * 
< 	 * @return <code>false</code> if any of the commands of which this
< 	 *         composite command is composed cannot be undone; <code>true</code>
< 	 *         otherwise.
286a361,363
>     protected CommandResult doExecuteWithResult(
>             IProgressMonitor progressMonitor, IAdaptable info)
>         throws ExecutionException {
287,290d360
< 	public final boolean isUndoable() {
< 		if (getCommands().isEmpty())
< 			return false;
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
292,293d364
< 			if (!((ICommand) i.next()).isUndoable()) {
< 				return false;
294a370,413
> 
>         progressMonitor.beginTask(getLabel(), size());
> 
>         try {
> 
>             for (ListIterator iter = listIterator(); iter.hasNext();) {
>                 IUndoableOperation next = (IUndoableOperation) iter.next();
> 
>                 try {
>                     IStatus status = next.execute(new SubProgressMonitor(
>                         progressMonitor, 1), info);
>                     result.add(status);
>                     int severity = status.getSeverity();
> 
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
> 
>                         // Undo the operation to date, excluding the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(
>                                 CommonCorePlugin.getDefault(),
>                                 "Composite operation execution recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
>                         // back-track over the operation that failed
>                         iter.previous();
>                         unwindFailedExecute(iter, info);
>                         break;
> 
>                     } else if (progressMonitor.isCanceled()) {
>                         // Undo the operation to date, including the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation redo recovery: child command monitor is cancelled."); //$NON-NLS-1$
> 
>                         CommandResult cancelResult = CommandResult
>                             .newCancelledCommandResult();
>                         result.add(cancelResult.getStatus());
> 
>                         unwindFailedExecute(iter, info);
>                         break;
> 
>                     } else {
>                         progressMonitor.worked(1);
>                         executed = true;
296a416,425
>                 } catch (ExecutionException e) {
>                     // Undo the operation to date, and re-throw the exception
>                     // back-track over the operation that failed
>                     iter.previous();
>                     unwindFailedExecute(iter, info);
>                     Trace.throwing(CommonCorePlugin.getDefault(),
>                         CommonCoreDebugOptions.EXCEPTIONS_THROWING,
>                         CompositeCommand.class, "execute", e); //$NON-NLS-1$
>                     throw e;
>                 }
297,297c313,313
< 		return true;
---
>         return this;
299a428,432
>         } finally {
>             progressMonitor.done();
>         }
> 
>         return new CommandResult(aggregateStatuses(result), getReturnValues());
300,306d427
< 	/**
< 	 * Returns whether the composite command has no child commands.
< 	 * 
< 	 * @return whether the composite command has no child commands.
< 	 */
< 	public final boolean isEmpty() {
< 		return getCommands().size() == 0;
309a436,436
>      * Undoes the previous operations in the iterator.
310,310c295,295
< 	 * Returns the simplest form of this command that is equivalent. This is
---
>      * Returns the simplest form of this command that is equivalent. This is
311a297,297
>      * <P>
311,311c296,296
< 	 * useful for removing unnecessary nesting of commands.
---
>      * useful for removing unnecessary nesting of commands.
312,314d296
< 	 * <UL>
< 	 * <LI>if the composite had no sub-commands, it returns <code>null</code>
< 	 * </LI>
315,315c298,298
< 	 * <LI>if the composite had a single command, it returns the single command
---
>      * If the composite has a single command, it returns the reduction of that
316,316d298
< 	 * </LI>
317,317c299,299
< 	 * <LI>otherwise, it returns itself</LI>
---
>      * single command. Otherwise, it returns itself.
318,318d299
< 	 * </UL>
319a438,441
>      * @param iter
>      *            the execution iterator
>      * @param info
>      *            the execution info
320,320c301,301
< 	 * @return the simplest form of this command that is equivalent
---
>      * @return the simplest form of this command that is equivalent
321a443,468
>     private void unwindFailedExecute(ListIterator iter, IAdaptable info) {
> 
>         while (iter.hasPrevious()) {
>             // unwind the child operations
>             IUndoableOperation prev = (IUndoableOperation) iter.previous();
>             if (!prev.canUndo()) {
>                 // Can't unwind
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.EXECUTE_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.executeRecoveryFailed,
>                         CommonCoreMessages.cannotUndoExecuted));
>                 break;
>             }
> 
>             try {
>                 prev.undo(new NullProgressMonitor(), info);
> 
>             } catch (ExecutionException inner) {
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.EXECUTE_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.executeRecoveryFailed, inner
>                             .getLocalizedMessage()));
>                 break;
>             }
322,329d442
< 	public ICommand unwrap() {
< 		switch (commands.size()) {
< 			case 0:
< 				return UnexecutableCommand.INSTANCE;
< 			case 1:
< 				return (ICommand) commands.get(0);
< 			default:
< 				return this;
333a473,473
>      * I redo by asking my children to redo, in forward order.
334,351d472
< 	 * Executes this composite command by executing all of the commands with
< 	 * which it is composed. If one command execution fails, the remaining
< 	 * commands will not be executed.
< 	 * <P>
< 	 * The result of executing this command can be obtained by calling
< 	 * {@link #getCommandResult()}after the command has been executed.
< 	 * <P>
< 	 * The progress of this command execution is measured in the following way:
< 	 * each of <code>n</code> subcommands is allocated 1 of <code>n</code>
< 	 * work units from <code>progressMonitor</code>. Each sub-command
< 	 * execution is given a {@link SubProgressMonitor}and can futher divide its
< 	 * 1/<code>n</code> th into <code>m</code> work units. Command
< 	 * execution will stop when the progress monitor is cancelled and a
< 	 * {@link CommonCoreStatusCodes#CANCELLED}status code will be returned in
< 	 * the command result. All of the previously executed sub-commands will be
< 	 * undone as a result of cancelling.
< 	 * 
< 	 * @param progressMonitor @see org.eclipse.core.runtime.IProgressMonitor
352a475,477
>     protected CommandResult doRedoWithResult(IProgressMonitor progressMonitor,
>             IAdaptable info)
>         throws ExecutionException {
353,353d474
< 	public void execute(IProgressMonitor progressMonitor) {
355,356d478
< 		if (!getValidator().okToEdit(this)) {
< 			setCanceled(true);
358,358d480
< 		} else {
359a485,485
>         progressMonitor.beginTask(getLabel(), size());
359a481,481
>         if (progressMonitor == null) {
360a483,483
>         }
360,360c482,482
< 			IProgressMonitor monitor = (progressMonitor == null) ? new NullProgressMonitor()
---
>             progressMonitor = new NullProgressMonitor();
361,361d482
< 				: progressMonitor;
362a487,487
>         try {
363,364d486
< 			setCanceled(false);
< 			List executedCommands = new ArrayList(getCommands().size());
365a489,490
>             for (ListIterator iter = listIterator(); iter.hasNext();) {
>                 IUndoableOperation next = (IUndoableOperation) iter.next();
366,367d488
< 			int totalWork = getCommands().size();
< 			monitor.beginTask(getLabel(), totalWork);
368a492,492
>                 try {
368a201,201
>         for (int i = 0; i < childContexts.length; i++) {
369,369d200
< 			for (Iterator i = getCommands().iterator(); i.hasNext();) {
371,372d493
< 				SubProgressMonitor subprogressMonitor = new SubProgressMonitor(
< 					monitor, 1, SubProgressMonitor.SUPPRESS_SUBTASK_LABEL);
373a499,508
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
>                         // Undo the operation to date, excluding the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation redo recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
>                         // back-track over the operation that failed
>                         iter.previous();
>                         unwindFailedRedo(iter, info);
>                         break;
374,375d498
< 				ICommand nextCommand = (ICommand) i.next();
< 				nextCommand.execute(subprogressMonitor);
376a510,554
>                     } else if (progressMonitor.isCanceled()) {
>                         // Undo the operation to date, including the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation redo recovery: child command monitor is cancelled."); //$NON-NLS-1$
> 
>                         CommandResult cancelResult = CommandResult
>                             .newCancelledCommandResult();
>                         result.add(cancelResult.getStatus());
> 
>                         unwindFailedRedo(iter, info);
>                         break;
> 
>                     } else {
>                         progressMonitor.worked(1);
>                         executed = true;
>                     }
> 
>                 } catch (ExecutionException e) {
>                     // Undo the operation to date, and re-throw the exception
>                     // back-track over the operation that failed
>                     iter.previous();
>                     unwindFailedRedo(iter, info);
>                     Trace.throwing(CommonCorePlugin.getDefault(),
>                         CommonCoreDebugOptions.EXCEPTIONS_THROWING,
>                         CompositeCommand.class, "redo", e); //$NON-NLS-1$
>                     throw e;
>                 }
>             }
> 
>         } finally {
>             progressMonitor.done();
>         }
> 
>         return new CommandResult(aggregateStatuses(result), getReturnValues());
>     }
> 
>     /**
>      * Undoes the previous operations in the iterator.
>      * 
>      * @param iter
>      *            the execution iterator
>      * @param info
>      *            the execution info
377,383d509
< 				CommandResult result = nextCommand.getCommandResult();
< 				if (result != null) {
< 					if (result.getStatus().getSeverity() == IStatus.ERROR) {
< 						/*
< 						 * myee - RATLC00518953: error executing one of the
< 						 * composed commands: cancel all of the executed
< 						 * commands
384a556,580
>     private void unwindFailedRedo(ListIterator iter, IAdaptable info) {
> 
>         while (iter.hasPrevious()) {
>             // unwind the child operations
>             IUndoableOperation prev = (IUndoableOperation) iter.previous();
>             if (!prev.canUndo()) {
>                 // Can't unwind
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.REDO_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.redoRecoveryFailed,
>                         CommonCoreMessages.cannotUndo));
>                 break;
>             }
> 
>             try {
>                 prev.undo(new NullProgressMonitor(), info);
> 
>             } catch (ExecutionException inner) {
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.REDO_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.redoRecoveryFailed, inner
>                             .getLocalizedMessage()));
>                 break;
385,386d555
< 						undoCancelledCommands(executedCommands);
< 						return;
388a583,590
>     }
> 
>     /**
>      * I undo by asking my children to undo, in reverse order.
>      */
>     protected CommandResult doUndoWithResult(IProgressMonitor progressMonitor,
>             IAdaptable info)
>         throws ExecutionException {
389,389d582
< 				monitor.worked(1);
390a592,595
>         final List result = new ArrayList(size());
> 
>         if (progressMonitor == null) {
>             progressMonitor = new NullProgressMonitor();
391,395d591
< 				if (monitor.isCanceled()) {
< 					undoCancelledCommands(executedCommands);
< 					monitor.done();
< 					setCanceled(true);
< 					return;
396a597,639
> 
>         progressMonitor.beginTask(getLabel(), size());
> 
>         try {
> 
>             for (ListIterator iter = listIterator(size()); iter.hasPrevious();) {
>                 IUndoableOperation prev = (IUndoableOperation) iter.previous();
> 
>                 try {
>                     IStatus status = prev.undo(new SubProgressMonitor(
>                         progressMonitor, 1), info);
>                     result.add(status);
>                     int severity = status.getSeverity();
> 
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
>                         // Redo the operation to date, excluding the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation undo recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
>                         // back-track over the operation that failed or was
>                         // cancelled
>                         iter.next();
>                         unwindFailedUndo(iter, info);
>                         break;
> 
>                     } else if (progressMonitor.isCanceled()) {
>                         // Redo the operation to date, including the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation undo recovery: child command monitor is cancelled."); //$NON-NLS-1$
> 
>                         CommandResult cancelResult = CommandResult
>                             .newCancelledCommandResult();
>                         result.add(cancelResult.getStatus());
> 
>                         unwindFailedUndo(iter, info);
>                         break;
> 
>                     } else {
>                         progressMonitor.worked(1);
>                         executed = true;
397,397d596
< 				executedCommands.add(nextCommand);
399a642,652
>                 } catch (ExecutionException e) {
>                     // Redo the operation to date, and re-throw the exception
>                     // back-track over the operation that failed
>                     iter.next();
>                     unwindFailedUndo(iter, info);
>                     Trace.throwing(CommonCorePlugin.getDefault(),
>                         CommonCoreDebugOptions.EXCEPTIONS_THROWING,
>                         CompositeCommand.class, "undo", e); //$NON-NLS-1$
>                     throw e;
>                 }
>             }
400,400d641
< 			monitor.done();
401a654,655
>         } finally {
>             progressMonitor.done();
402a657,658
> 
>         return new CommandResult(aggregateStatuses(result), getReturnValues());
405a662,662
>      * Redoes the next operations in the iterator.
406,408d661
< 	 * Cancels the command execution by calling <code>undo()</code> on all of
< 	 * the undoable commands that were executed before the composite command was
< 	 * cancelled. The commands are undone in the reverse order of execution.
409a664,667
>      * @param iter
>      *            the execution iterator
>      * @param info
>      *            the execution info
410,414d663
< 	 * @param executedCommands
< 	 *            the commands that have been executed and need to be undone.
< 	 *            This method expects that the commands in the list are in the
< 	 *            order in which the commands were executed. They will be undone
< 	 *            in the reverse order.
415a669,669
>     private void unwindFailedUndo(ListIterator iter, IAdaptable info) {
416,416d668
< 	protected void undoCancelledCommands(List executedCommands) {
417a671,682
>         while (iter.hasNext()) {
>             // unwind the child operations
>             IUndoableOperation next = (IUndoableOperation) iter.next();
>             if (!next.canRedo()) {
>                 // Can't unwind
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.UNDO_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.undoRecoveryFailed,
>                         CommonCoreMessages.cannotRedo));
>                 break;
>             }
418,418d670
< 		Collections.reverse(executedCommands);
419a684,693
>             try {
>                 next.redo(new NullProgressMonitor(), info);
> 
>             } catch (ExecutionException inner) {
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.UNDO_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.undoRecoveryFailed, inner
>                             .getLocalizedMessage()));
>                 break;
420,423d683
< 		for (Iterator i = executedCommands.iterator(); i.hasNext();) {
< 			ICommand nextCommand = (ICommand) i.next();
< 			if (nextCommand.isUndoable()) {
< 				nextCommand.undo();
428a699,727
>      * Creates a suitable aggregate from these statuses. If there are no
>      * statuses to aggregate, then an OK status is returned. If there is a
>      * single status to aggregate, then it is returned. Otherwise, a
>      * multi-status is returned with the provided statuses as children.
>      * 
>      * @param statuses
>      *            the statuses to aggregate. May have zero, one, or more
>      *            elements (all must be {@link IStatus}es)
>      * 
>      * @return the multi-status
>      */
>     protected IStatus aggregateStatuses(List statuses) {
>         final IStatus result;
> 
>         if (statuses.isEmpty()) {
>             result = Status.OK_STATUS;
>         } else if (statuses.size() == 1) {
>             result = ((IStatus) statuses.get(0));
>         } else {
>             // find the most severe status, to use its plug-in, code, and
>             // message
>             IStatus[] statusArray = (IStatus[]) statuses
>                 .toArray(new IStatus[statuses.size()]);
> 
>             IStatus worst = statusArray[0];
>             for (int i = 1; i < statusArray.length; i++) {
>                 if (statusArray[i].getSeverity() > worst.getSeverity()) {
>                     worst = statusArray[i];
>                 }
429,441d698
< 	 * Redoes this composite command by redoing each of the commands of which
< 	 * this composite command is composed.
< 	 */
< 	public void redo() {
< 		// First check if we have the needed units available.
< 		// We are forced to do this at the composite command level
< 		// because some individual commands do not properly set their
< 		// affectedObject. For example, create a class and notice that
< 		// the SetBounds command will not have its affected object set
< 		// even though it clearly modifies a unit.
< 		if (!getValidator().okToEdit(this)) {
< 			setCanceled(true);
< 			return;
443a730,732
>             result = new MultiStatus(worst.getPlugin(), worst.getCode(),
>                 statusArray, worst.getMessage(), null);
>         }
444,444d729
< 		Collections.reverse(getCommands());
445a159,164
>         for (int i = 0; i < childContexts.length; i++) {
> 
>             if (!hasContext(childContexts[i])) {
>                 addContext(childContexts[i]);
>             }
>         }
445a734,734
>         return result;
446,447d158
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
< 			((ICommand) i.next()).redo();
451a748,749
>      * Asserts that I have not yet been executed. Changes to my children are not
>      * permitted after I have been executed.
452,453d747
< 	 * Undoes this composite command by undoing each of the commands of which
< 	 * this composite command is composed.
454a751,759
>     protected final void assertNotExecuted() {
>         if (isExecuted()) {
>             IllegalStateException exc = new IllegalStateException(
>                 "Operation already executed"); //$NON-NLS-1$
>             Trace.throwing(CommonCorePlugin.getDefault(),
>                 CommonCoreDebugOptions.EXCEPTIONS_THROWING,
>                 CompositeCommand.class, "assertNotExecuted", exc); //$NON-NLS-1$
>             throw exc;
>         }
455,464d750
< 	public void undo() {
< 		// First check if we have the needed units available.
< 		// We are forced to do this at the composite command level
< 		// because some individual commands do not properly set their
< 		// affectedObject. For example, create a class and notice that
< 		// the SetBounds command will not have its affected object set
< 		// even though it clearly modifies a unit.
< 		if (!getValidator().okToEdit(this)) {
< 			setCanceled(true);
< 			return;
467,467d761
< 		Collections.reverse(getCommands());
468a773,779
>             if (nextOperation instanceof ICommand) {
>                 List nextAffected = ((ICommand) nextOperation)
>                     .getAffectedFiles();
> 
>                 if (nextAffected != null) {
>                     result.addAll(nextAffected);
>                 }
469,470d772
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
< 			((ICommand) i.next()).undo();
472a782,783
>         return result;
>     }
474a786,787
>      * Obtains an iterator to traverse my child operations. Removing children
>      * via this iterator correctly maintains my undo contexts.
475,476d785
< 	 * Retrieves the plug-in identifier to be used in command results produced
< 	 * by this command.
477a789,789
>      * @return an iterator of my children
478,479d788
< 	 * @return The plug-in identifier to be used in command results produced by
< 	 *         this command.
480a791,792
>     public Iterator iterator() {
>         return new ChildIterator();
481,482d790
< 	protected String getPluginId() {
< 		return CommonCorePlugin.getPluginId();
485a796,805
>      * Obtains an iterator to traverse my child operations in either direction.
>      * Adding and removing children via this iterator correctly maintains my
>      * undo contexts.
>      * <p>
>      * <b>Note</b> that, unlike list iterators generally, this implementation
>      * does not permit the addition of an operation that I already contain (the
>      * composite does not permit duplicates). Moreover, only
>      * {@link IUndoableOperation}s may be added, otherwise
>      * <code>ClassCastException</code>s will result.
>      * </p>
486,487d795
< 	 * Creates a new command result with an ERROR status, a CANCELLED status
< 	 * code and no return value.
488a807,807
>      * @return an iterator of my children
489,490d806
< 	 * @return A new command result with an ERROR status and a CANCELLED status
< 	 *         code.
491a809,810
>     public ListIterator listIterator() {
>         return new ChildListIterator(0);
492,494d808
< 	protected CommandResult newCancelledCommandResult() {
< 		return new CommandResult(new Status(IStatus.ERROR, getPluginId(),
< 			CommonCoreStatusCodes.CANCELLED, CommonCoreMessages.AbstractCommand__INFO__cancelOperation, null), null);
497a814,823
>      * Obtains an iterator to traverse my child operations in either direction,
>      * starting from the specified <code>index</code>. Adding and removing
>      * children via this iterator correctly maintains my undo contexts.
>      * <p>
>      * <b>Note</b> that, unlike list iterators generally, this implementation
>      * does not permit the addition of an operation that I already contain (the
>      * composite does not permit duplicates). Moreover, only
>      * {@link IUndoableOperation}s may be added, otherwise
>      * <code>ClassCastException</code>s will result.
>      * </p>
498,498d813
< 	 * Sets the canceled state of this command.
499a825,828
>      * @param index
>      *            the index in my children at which to start iterating
>      * 
>      * @return an iterator of my children
500,502d824
< 	 * @param canceled
< 	 *            <code>true</code> if the command was canceled,
< 	 *            <code>false</code> otherwise.
503a830,831
>     public ListIterator listIterator(int index) {
>         return new ChildListIterator(index);
504,505d829
< 	protected void setCanceled(boolean canceled) {
< 		this.canceled = canceled;
508a835,836
>      * Custom iterator implementation that maintains my undo contexts correctly
>      * when elements are removed.
509,509d834
< 	 * Gets the canceled state of this command.
510a97,99
>      * Answers whether or not this composite operation has children.
>      * 
>      * @return <code>true</code> if the operation does not have children,
510a838,838
>      * @author ldamus
511,511d96
< 	 * @return <code>true</code> if the command was canceled,
512,512c100,100
< 	 *         <code>false</code> otherwise.
---
>      *         <code>false</code> otherwise.
513a840,870
>     private class ChildIterator
>         implements Iterator {
> 
>         protected Object last;
> 
>         protected final ListIterator iter;
> 
>         ChildIterator() {
>             this(0);
>         }
> 
>         ChildIterator(int index) {
>             iter = getChildren().listIterator(index);
>         }
> 
>         public void remove() {
>             assertNotExecuted();
> 
>             iter.remove();
>             didRemove((IUndoableOperation) last);
>             last = null;
>         }
> 
>         public Object next() {
>             last = iter.next();
>             return last;
>         }
> 
>         public boolean hasNext() {
>             return iter.hasNext();
>         }
514,515d839
< 	protected boolean isCanceled() {
< 		return canceled;
518a874,875
>      * Custom list-iterator implementation that maintains my undo contexts
>      * correctly, as well as uniqueness of the list contents.
519,520d873
< 	 * Return a validator which can be used to check whether the units being
< 	 * modified by a command are writable.
521a877,877
>      * @author ldamus
521a355,355
>         return returnValues;
522,522d354
< 	 * @return CMValidator
523a879,884
>     private class ChildListIterator
>         extends ChildIterator
>         implements ListIterator {
> 
>         ChildListIterator(int index) {
>             super(index);
524,525d878
< 	public CMValidator getValidator() {
< 		return new CMValidator();
527a887,923
>         public void add(Object o) {
>             assertNotExecuted();
> 
>             if (!getChildren().contains(o)) {
>                 iter.add(o);
>                 didAdd((IUndoableOperation) o);
>             }
>         }
> 
>         public void set(Object o) {
>             assertNotExecuted();
> 
>             if (!getChildren().contains(o)) {
>                 didRemove((IUndoableOperation) last);
>                 iter.set(o);
>                 last = o;
>                 didAdd((IUndoableOperation) o);
>             }
>         }
> 
>         public int previousIndex() {
>             return iter.previousIndex();
>         }
> 
>         public int nextIndex() {
>             return iter.nextIndex();
>         }
> 
>         public Object previous() {
>             last = iter.previous();
>             return last;
>         }
> 
>         public boolean hasPrevious() {
>             return iter.hasPrevious();
>         }
>     }
