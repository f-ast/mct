0a1,2
> /******************************************************************************
>  * Copyright (c) 2003, 2004 IBM Corporation and others.
1,3d0
< /**
<  * Copyright (c) 2006 Borland Software Corporation
<  * 
9a9,10
>  *    IBM Corporation - initial API and implementation 
>  ****************************************************************************/
10,11d11
<  *    bblajer - initial API and implementation
<  */
12,12c12,12
< package org.eclipse.gmf.runtime.lite.properties;
---
> package org.eclipse.gmf.runtime.diagram.ui.properties.sections;
14,15d11
< import java.util.ArrayList;
< import java.util.Iterator;
17,17c14,14
< import org.eclipse.emf.common.notify.AdapterFactory;
---
> import org.eclipse.emf.common.notify.Notification;
18,18c15,15
< import org.eclipse.emf.ecore.util.EcoreUtil;
---
> import org.eclipse.emf.ecore.EObject;
19,22d15
< import org.eclipse.emf.transaction.TransactionalEditingDomain;
< import org.eclipse.emf.transaction.util.TransactionUtil;
< import org.eclipse.gef.commands.CommandStack;
< import org.eclipse.gmf.runtime.lite.parts.CommandStackAdapterManager;
23a17,20
> import org.eclipse.swt.SWT;
> import org.eclipse.swt.custom.CLabel;
> import org.eclipse.swt.layout.FormAttachment;
> import org.eclipse.swt.layout.FormData;
24,24c22,22
< import org.eclipse.jface.viewers.StructuredSelection;
---
> import org.eclipse.ui.IActionBars;
26a24,25
> import org.eclipse.ui.views.properties.IPropertySourceProvider;
> import org.eclipse.ui.views.properties.PropertySheetPage;
28a28,90
> import org.eclipse.gmf.runtime.common.core.command.CommandManager;
> import org.eclipse.gmf.runtime.emf.core.edit.MFilter;
> import org.eclipse.gmf.runtime.emf.core.exceptions.MSLActionAbandonedException;
> import org.eclipse.gmf.runtime.emf.ui.properties.sections.UndoableModelPropertySheetEntry;
> 
> /**
>  * The advanced property section displayed the "original" tabular property sheet
>  * page.
>  * 
>  * @author Anthony Hunter <a
>  *         href="mailto:anthonyh@ca.ibm.com">anthonyh@ca.ibm.com </a>
>  */
> public class AdvancedPropertySection extends AbstractModelerPropertySection {
> 
>     /**
>      * the property sheet page for this section
>      */
>     protected PropertySheetPage page;
> 
>   
>     /* (non-Javadoc)
>      * @see org.eclipse.ui.views.properties.tabbed.ISection#createControls(org.eclipse.swt.widgets.Composite, org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage)
>      */
>     public void createControls(final Composite parent,
>             TabbedPropertySheetPage aTabbedPropertySheetPage) {
>         super.createControls(parent, aTabbedPropertySheetPage);
>         Composite composite = getWidgetFactory()
>                 .createFlatFormComposite(parent);
>         FormData data = null;
> 
>         String tableLabelStr = getTableLabel();
>         CLabel tableLabel = null;
>         if (tableLabelStr != null && tableLabelStr.length() > 0) {
>             tableLabel = getWidgetFactory().createCLabel(composite,
>                     tableLabelStr);
>             data = new FormData();
>             data.left = new FormAttachment(0, 0);
>             data.top = new FormAttachment(0, 0);
>             tableLabel.setLayoutData(data);
>         }
> 
>         page = new PropertySheetPage();
>         UndoableModelPropertySheetEntry root = new UndoableModelPropertySheetEntry(
>                 CommandManager.getDefault());
>         root.setPropertySourceProvider(getPropertySourceProvider());
>         page.setRootEntry(root);
> 
>         page.createControl(composite);
>         data = new FormData();
>         data.left = new FormAttachment(0, 0);
>         data.right = new FormAttachment(100, 0);
>         if (tableLabel == null) {
>             data.top = new FormAttachment(0, 0);
>         } else {
>             data.top = new FormAttachment(tableLabel, 0, SWT.BOTTOM);
>         }
>         data.bottom = new FormAttachment(100, 0);
>         data.height = 100;
>         data.width = 100;
>         page.getControl().setLayoutData(data);
> 
>         setActionBars(aTabbedPropertySheetPage.getSite().getActionBars());
>         
29,34d27
< public abstract class AdvancedPropertySection extends org.eclipse.ui.views.properties.tabbed.AdvancedPropertySection {
< 	public void createControls(Composite parent, TabbedPropertySheetPage tabbedPropertySheetPage) {
< 		super.createControls(parent, tabbedPropertySheetPage);
< 		myPropertySheetEntry = new RootUndoablePropertySheetEntry(null, page);
< 		myPropertySheetEntry.setPropertySourceProvider(getPropertySourceProvider());
< 		page.setRootEntry(myPropertySheetEntry);
36a93,109
>     /**
>      * Sets and prepares the actionBars for this section
>      *  
>      * @param actionBars the action bars for this page
>      * @see org.eclipse.gmf.runtime.common.ui.properties.TabbedPropertySheetPage#setActionBars(org.eclipse.ui.IActionBars)
>      */   
>     public void setActionBars(IActionBars actionBars) {
>         
>         actionBars.getMenuManager().removeAll();
>         actionBars.getToolBarManager().removeAll();
>         actionBars.getStatusLineManager().removeAll();
> 
>         page.makeContributions(actionBars.getMenuManager(), actionBars
>                 .getToolBarManager(), actionBars.getStatusLineManager());
>         
>         actionBars.getToolBarManager().update(true);
> 
37,61d92
< 	public void setInput(IWorkbenchPart part, ISelection selection) {
< 		if (selection.isEmpty()
< 				|| false == selection instanceof StructuredSelection) {
< 			super.setInput(part, selection);
< 			return;
< 		}
< 		final StructuredSelection structuredSelection = ((StructuredSelection) selection);
< 		ArrayList<Object> transformedSelection = new ArrayList<Object>(structuredSelection.size());
< 		for (Iterator<?> it = structuredSelection.iterator(); it.hasNext(); ) {
< 			Object r = transformSelection(it.next());
< 			if (r != null) {
< 				transformedSelection.add(r);
< 			}
< 		}
< 		CommandStack commandStack = getCommandStack(transformedSelection);
< 		myPropertySheetEntry.setCommandStack(commandStack);
< 		super.setInput(part, new StructuredSelection(transformedSelection));
< 	}
< 
< 	protected CommandStack getCommandStack(ArrayList<?> selection) {
< 		CommandStack result = null;
< 		for(Object next : selection) {
< 			TransactionalEditingDomain editingDomain = TransactionUtil.getEditingDomain(next);
< 			if (editingDomain == null) {
< 				return null;
62a111,121
> 
>     /**
>      * Returns the PropertySource provider. The default implementation returns
>      * static adapter factory for the properties services. If the extending
>      * class needs to use a different provider then this method has to be
>      * overwriten.
>      * 
>      * @return The PropertySource provider
>      */
>     protected IPropertySourceProvider getPropertySourceProvider() {
>         return propertiesProvider;
63,65d110
< 			CommandStack nextStackCandidate = getCommandStack(editingDomain);
< 			if (nextStackCandidate == null) {
< 				return null;
66a123,130
> 
>     /**
>      * Returns the label for the table. The default implementation returns null,
>      * that is, there is no label.
>      * 
>      * @return The label for the table
>      */
>     protected String getTableLabel() {
67,69d122
< 			if (result == null) {
< 				result = nextStackCandidate;
< 			} else if (result != nextStackCandidate) {
71a133,139
> 
>    
>     /* (non-Javadoc)
>      * @see org.eclipse.ui.views.properties.tabbed.ISection#setInput(org.eclipse.ui.IWorkbenchPart, org.eclipse.jface.viewers.ISelection)
>      */
>     public void setInput(IWorkbenchPart part, ISelection selection) {
>         page.selectionChanged(part, selection);
72a141,150
> 
>     /* (non-Javadoc)
>      * @see org.eclipse.ui.views.properties.tabbed.ISection#dispose()
>      */
>     public void dispose() {
>         super.dispose();
> 
>         if (page != null) {
>             page.dispose();
>             page = null;
73,73d140
< 		return result;
76,78d152
< 	static CommandStack getCommandStack(TransactionalEditingDomain editingDomain) {
< 		if (editingDomain == null) {
< 			return null;
80,82d153
< 		CommandStackAdapterManager adapterManager = (CommandStackAdapterManager) EcoreUtil.getExistingAdapter(editingDomain.getResourceSet(), CommandStackAdapterManager.class);
< 		if (adapterManager == null || adapterManager.isReleased()) {
< 			return null;
83a163,169
> 
>    
>     /* (non-Javadoc)
>      * @see org.eclipse.ui.views.properties.tabbed.ISection#shouldUseExtraSpace()
>      */
>     public boolean shouldUseExtraSpace() {
>         return true;
84,84d162
< 		return adapterManager.getCommandStack();
86a172,190
>     /**
>      * Update if nessesary, upon receiving the model event.
>      * 
>      * @see #aboutToBeShown()
>      * @see #aboutToBeHidden()
>      * @param notification -
>      *            even notification
>      * @param element -
>      *            element that has changed
>      */
>     public void update(final Notification notification, EObject element) {
>     	if (!isDisposed()) {
> 			postUpdateRequest(new Runnable() {
> 
> 				public void run() {
> 					if (!isDisposed() && !isNotifierDeleted(notification))
> 						refresh();
> 				}
> 			});
87,89d171
< 	protected PropertySourceProvider getPropertySourceProvider() {
< 		if (myPropertySourceProvider == null) {
< 			myPropertySourceProvider = new PropertySourceProvider(getItemProvidersAdapterFactory());
91,91d191
< 		return myPropertySourceProvider;
94,94d193
< 	protected abstract AdapterFactory getItemProvidersAdapterFactory();
95a195,200
> 	 * Overwrites the default behavior to perform update on the create event.
> 	 * That must be done because proeprties of the advanced tab might be
> 	 * affected by creation of new elements.
> 	 * 
> 	 * @see org.eclipse.gmf.runtime.emf.core.internal.events.IDemuxedMListener#handleElementCreatedEvent(org.eclipse.emf.common.notify.Notification,
> 	 *      org.eclipse.emf.ecore.EObject, org.eclipse.emf.ecore.EObject)
96,98d194
< 	 * Allows the subclasses to unwrap or otherwise modify the contents of the selection. The <code>null</code> result may be returned,
< 	 * in this case it will be ignored.
< 	 * <p/>By default, the passed object is returned untouched.
99a202,204
>     public void handleElementCreatedEvent(Notification notification,
>             EObject owner, EObject newElement) {
>         update(notification, owner);
100,101d201
< 	protected Object transformSelection(Object selected) {
< 		return selected;
103a154,158
> 
>  
>     /* (non-Javadoc)
>      * @see org.eclipse.ui.views.properties.tabbed.ISection#refresh()
>      */
103a207,229
>     /**
>      * Overwrites the default behavior to perform update on the delete event.
>      * That must be done because proeprties of the advanced tab might be
>      * affected by deletion of elements.
>      * 
>      * @see org.eclipse.gmf.runtime.emf.core.internal.events.IDemuxedMListener#handleElementDeletedEvent(org.eclipse.emf.common.notify.Notification,
>      *      org.eclipse.emf.ecore.EObject, org.eclipse.emf.ecore.EObject)
>      */
>     public void handleElementDeletedEvent(Notification notification,
>             EObject owner, EObject oldElement) {
>         update(notification, owner);
>     }
> 
>     /* (non-Javadoc)
>      * @see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#getFilter()
>      */
>     public MFilter getFilter() {
>         MFilter lifeCycleEventFilter = new MFilter.Or(
>                 MFilter.ELEMENT_CREATED_FILTER,
>                 MFilter.ELEMENT_DELETED_FILTER);
> 
>         return new MFilter.Or(lifeCycleEventFilter,
>                         MFilter.ELEMENT_MODIFIED_FILTER);
104,104d153
< 	@Override
105a160,160
> 
105,105c159,159
< 	public void refresh() {
---
>     public void refresh() {
106,106c161,161
< 		page.refresh();
---
>         page.refresh();
108a232,247
>    
>     /* (non-Javadoc)
>      * @see org.eclipse.gmf.runtime.diagram.ui.properties.sections.AbstractModelerPropertySection#addToEObjectList(java.lang.Object)
>      */
>     protected boolean addToEObjectList(Object object) {
>         /* not implemented */
>     	return true;
>     }
> 
>   
>     /* (non-Javadoc)
>      * @see org.eclipse.gmf.runtime.diagram.ui.properties.sections.AbstractModelerPropertySection#handleException(org.eclipse.gmf.runtime.emf.core.exceptions.MSLActionAbandonedException)
>      */
>     protected void handleException(MSLActionAbandonedException exception) {
>         /* not implemented */
>     }
109,111d231
< 	private PropertySourceProvider myPropertySourceProvider;
< 	private CommandStack myCommandStack;
< 	private RootUndoablePropertySheetEntry myPropertySheetEntry;
