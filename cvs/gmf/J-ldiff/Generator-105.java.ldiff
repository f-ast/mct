2,2c2,2
<  * Copyright (c) 2005 Borland Software Corporation
---
>  * Copyright (c) 2005, 2006 Borland Software Corporation
15,15d14
< import java.util.HashMap;
17,17d15
< import java.util.LinkedList;
21,22d18
< import org.eclipse.emf.ecore.EClass;
< import org.eclipse.emf.ecore.EObject;
935a932,932
> 		c.registerFactor(GMFGenPackage.eINSTANCE.getGenNode(), 8);
936,936d931
< 		c.registerValue(GMFGenPackage.eINSTANCE.getGenNode(), 8);
937,937c933,933
< 		c.registerValue(GMFGenPackage.eINSTANCE.getGenChildLabelNode(), 4);
---
> 		c.registerFactor(GMFGenPackage.eINSTANCE.getGenChildLabelNode(), 4);
937a934,934
> 		c.registerFactor(GMFGenPackage.eINSTANCE.getGenLink(), 6);
938,938d933
< 		c.registerValue(GMFGenPackage.eINSTANCE.getGenLink(), 6);
939,939c935,935
< 		c.registerValue(GMFGenPackage.eINSTANCE.getGenCompartment(), 4);
---
> 		c.registerFactor(GMFGenPackage.eINSTANCE.getGenCompartment(), 4);
940,940c936,936
< 		c.registerValue(GMFGenPackage.eINSTANCE.getGenDiagram(), 50);
---
> 		c.registerFactor(GMFGenPackage.eINSTANCE.getGenDiagram(), 50);
941,941c937,937
< 		c.registerValue(GMFGenPackage.eINSTANCE.getGenPlugin(), 8);
---
> 		c.registerFactor(GMFGenPackage.eINSTANCE.getGenPlugin(), 8);
944,997d939
< 	
< 	
< 	private static final class Counter {
< 		private final HashMap<EClass, Integer> myCounters = new HashMap<EClass, Integer>();
< 		private final HashMap<EClass, Integer> myCache = new HashMap<EClass, Integer>();
< 		private final Integer CACHE_MISS = new Integer(0);
< 
< 		public Counter() {
< 		}
< 
< 		public void registerValue(EClass eClass, int count) {
< 			myCounters.put(eClass, new Integer(count));
< 		}
< 
< 		public int getTotal(EObject from) {
< 			int total = process(from);
< 			for (Iterator it = from.eAllContents(); it.hasNext();) {
< 				total += process((EObject) it.next());
< 			}
< 			return total;
< 		}
< 
< 		@SuppressWarnings("unchecked")
< 		protected int process(EObject next) {
< 			final EClass nextKey = next.eClass();
< 			Integer cachedValue = checkCached(nextKey);
< 			if (cachedValue != null) {
< 				return cachedValue.intValue(); 
< 			}
< 			LinkedList<EClass> checkQueue = new LinkedList<EClass>();
< 			checkQueue.add(nextKey);
< 			do {
< 				EClass key = checkQueue.removeFirst();
< 				if (myCounters.containsKey(key)) {
< 					final Integer value = myCounters.get(key);
< 					cache(nextKey, value);
< 					return value.intValue();
< 				} else {
< 					// add immeditate superclasses to check first
< 					checkQueue.addAll(key.getESuperTypes());
< 				}
< 			} while (!checkQueue.isEmpty());
< 			cache(nextKey, CACHE_MISS);
< 			return 0;
< 		}
< 
< 		private Integer checkCached(EClass nextKey) {
< 			return myCache.get(nextKey);
< 		}
< 
< 		private void cache(EClass nextKey, Integer value) {
< 			myCache.put(nextKey, value);
< 		}
< 	}
