14,20d13
< import java.lang.ref.WeakReference;
< import java.util.ArrayList;
< import java.util.Map;
< import java.util.WeakHashMap;
< 
< import org.eclipse.draw2d.ColorConstants;
< import org.eclipse.draw2d.Figure;
22,22c15,15
< import org.eclipse.draw2d.Graphics;
---
> import org.eclipse.draw2d.IFigure;
23,24d15
< import org.eclipse.draw2d.LayoutManager;
< import org.eclipse.draw2d.PositionConstants;
26,26d16
< import org.eclipse.draw2d.geometry.Insets;
29,30d18
< 
< import org.eclipse.gmf.runtime.draw2d.ui.internal.mapmode.IMapModeHolder;
32,32d19
< import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
40,40d26
< 
57a44,50
>  * @author melaasar, crevells
>  * @deprecated This class has been deprecated and may be removed in the future.
>  *             Use <code>WrappingLabel</code> instead. This class now extends
>  *             from <code>WrappingLabel</code> so the behavior should be the
>  *             same. If client code is calling one of the methods on
>  *             <code>WrapLabel</code> that no longer exists, evaluate whether
>  *             this is necessary or not.
58,58d43
<  * @author melaasar
60a53,53
>     extends WrappingLabel {
61,157d52
< 	extends Figure
< 	implements PositionConstants {	
< 
< 	private static final String _ellipse = "..."; //$NON-NLS-1$
< 
< 	private static final Dimension EMPTY_DIMENSION = new Dimension(0, 0);
< 
< 	private static final Map mapModeConstantsMap = new WeakHashMap();
< 
< 	private static class MapModeConstants {
< 
< 		private static final int MAX_IMAGE_INFO = 12;
< 
< 		public final WeakReference mapModeRef;
< 
< 		public final int nDPtoLP_3;
< 
< 		public final int nDPtoLP_2;
< 
< 		public final int nDPtoLP_0;
< 
< 		public final Dimension dimension_nDPtoLP_0;
< 
< 		public final WeakHashMap fontToEllipseTextSize = new WeakHashMap();
< 
< 		public final SingleIconInfo[] singleIconInfos = new SingleIconInfo[MAX_IMAGE_INFO];
< 
< 		public MapModeConstants(IMapMode mapMode) {
< 			this.mapModeRef = new WeakReference(mapMode);
< 			nDPtoLP_2 = mapMode.DPtoLP(2);
< 			nDPtoLP_3 = mapMode.DPtoLP(3);
< 			nDPtoLP_0 = mapMode.DPtoLP(0);
< 			dimension_nDPtoLP_0 = new Dimension(nDPtoLP_0, nDPtoLP_0);
< 		}
< 
< 		public Dimension getEllipseTextSize(Font f) {
< 			Dimension d = (Dimension) fontToEllipseTextSize.get(f);
< 			if (d == null) {
< 				IMapMode mapMode = (IMapMode) mapModeRef.get();
< 				d = FigureUtilities.getTextExtents(_ellipse, f);
< 				d.height = FigureUtilities.getFontMetrics(f).getHeight();
< 				d = new Dimension(mapMode.DPtoLP(d.width), mapMode
< 					.DPtoLP(d.height));
< 				fontToEllipseTextSize.put(f, d);
< 			}
< 			return d;
< 		}
< 
< 		public SingleIconInfo getSingleIconInfo(Image image) {
< 			if (image == null) {
< 				return SingleIconInfo.NULL_INFO;
< 			}
< 			SingleIconInfo info;
< 			for (int i = 0; i < MAX_IMAGE_INFO; ++i) {
< 				info = singleIconInfos[i];
< 				if (info == null) {
< 					info = new SingleIconInfo(image);
< 					singleIconInfos[i] = info;
< 					return info;
< 				}
< 				if (info.icon == image) {
< 					return info;
< 				}
< 			}
< 			int index = SingleIconInfo.count % MAX_IMAGE_INFO;
< 			info = new SingleIconInfo(image);
< 			singleIconInfos[index] = info;
< 			return info;
< 		}
< 	}
< 
< 	// reserve 1 bit
< 	private static int FLAG_SELECTED = MAX_FLAG << 1;
< 
< 	private static int FLAG_HASFOCUS = MAX_FLAG << 2;
< 
< 	private static int FLAG_UNDERLINED = MAX_FLAG << 3;
< 
< 	private static int FLAG_STRIKEDTHROUGH = MAX_FLAG << 4;
< 
< 	private static int FLAG_WRAP = MAX_FLAG << 5;
< 
< 	// reserve 3 bits
< 	private static int FLAG_TEXT_ALIGN = MAX_FLAG << 6;
< 
< 	private static int FLAG_WRAP_ALIGN = MAX_FLAG << 9;
< 
< 	private static int FLAG_ICON_ALIGN = MAX_FLAG << 12;
< 
< 	private static int FLAG_LABEL_ALIGN = MAX_FLAG << 15;
< 
< 	private static int FLAG_TEXT_PLACEMENT = MAX_FLAG << 18;
< 
< 	private MapModeConstants mapModeConstants;
< 
< 	/** the original label's text */
< 	private String text;
162,417d57
< 	/** the size of text */
< 	private Dimension textSize;	
< 
< 	private Dimension ellipseTextSize;
< 
< 	/** the location of text */
< 	private Point textLocation;
< 
< 	/** the cached hint used to calculate text size */
< 	private int cachedPrefSizeHint_width;
< 
< 	private int cachedPrefSizeHint_height;
< 
< 	/** the icon location */
< 	private Point iconLocation;
< 
< 	private static abstract class IconInfo {
< 		/**
< 		 * Gets the icon at the index location.
< 		 * 
< 		 * @param i
< 		 *            the index to retrieve the icon of
< 		 * @return <code>Image</code> that corresponds to the given index.
< 		 */
< 		public abstract Image getIcon(int i);
< 		
< 		/**
< 		 * Gets the icon size of the icon at the given index.
< 		 * 
< 		 * @param i
< 		 * @return the <code>Dimension</code> that is the size of the icon at
< 		 *         the given index.
< 		 */
< 		public abstract Dimension getIconSize(IMapMode mapMode, int i);
< 
< 		/**
< 		 * @return the number of icons
< 		 */
< 		public abstract int getNumberofIcons();
< 		
< 		/**
< 		 * @return the <code>Dimension</code> that is the total size of all
< 		 *         the icons.
< 		 */
< 		public abstract Dimension getTotalIconSize(IMapMode mapMode);
< 
< 		public abstract void invalidate();
< 		
< 		/**
< 		 * Sets the icon at the index location.
< 		 * 
< 		 * @param icon
< 		 * @param i
< 		 */
< 		public abstract void setIcon(Image icon, int i);
< 		
< 		/**
< 		 * 
< 		 */
< 		public abstract int getMaxIcons();
< 
< 	}	
< 
< 	private static class SingleIconInfo
< 		extends IconInfo {	
< 
< 		static int count;
< 		
< 		public static final SingleIconInfo NULL_INFO = new SingleIconInfo(){
< 			public int getNumberofIcons() {
< 				return 0;
< 			}
< 		};
< 
< 		final Image icon;
< 
< 		/** total icon size */
< 		private Dimension totalIconSize;
< 
< 		private SingleIconInfo() {
< 			icon = null;//don't increment count, used only for NULL_INFO
< 		}
< 
< 		public SingleIconInfo(Image icon) {
< 			this.icon = icon;
< 			++count;
< 		}
< 
< 		public final int getMaxIcons() {
< 			return 1;
< 		}
< 
< 		
< 		public Image getIcon(int i) {
< 			if (i == 0) {
< 				return icon;
< 			} else if (i > 0) {
< 				return null;
< 			}
< 			throw new IndexOutOfBoundsException();
< 		}
< 
< 		
< 		public void setIcon(Image img, int i) {
< 			throw new UnsupportedOperationException();
< 		}
< 
< 		
< 		public Dimension getIconSize(IMapMode mapMode, int i) {
< 			if (i == 0) {
< 				return getTotalIconSize(mapMode);
< 			}
< 
< 			throw new IndexOutOfBoundsException();
< 		}
< 
< 		
< 		public int getNumberofIcons() {
< 			return 1;
< 		}
< 
< 		
< 		public Dimension getTotalIconSize(IMapMode mapMode) {
< 			if (totalIconSize != null)
< 				return totalIconSize;
< 
< 			if (icon != null && !icon.isDisposed()) {
< 				org.eclipse.swt.graphics.Rectangle imgBounds = icon.getBounds();
< 				totalIconSize = new Dimension(mapMode.DPtoLP(imgBounds.width),
< 					mapMode.DPtoLP(imgBounds.height));
< 			} else {
< 				totalIconSize = EMPTY_DIMENSION;
< 			}
< 
< 			return totalIconSize;
< 		}
< 
< 		
< 		public void invalidate() {
< 			totalIconSize = null;
< 		}
< 
< 	}
< 
< 	private static class MultiIconInfo
< 		extends IconInfo {
< 
< 		/** the label icons */
< 		private ArrayList icons = new ArrayList(2);
< 
< 		/** total icon size */
< 		private Dimension totalIconSize;
< 
< 		public MultiIconInfo() {
< 			super();
< 		}
< 
< 		public int getMaxIcons() {
< 			return -1;
< 		}
< 
< 		/**
< 		 * Gets the icon at the index location.
< 		 * 
< 		 * @param i
< 		 *            the index to retrieve the icon of
< 		 * @return <code>Image</code> that corresponds to the given index.
< 		 */
< 		public Image getIcon(int i) {
< 			if (i >= icons.size())
< 				return null;
< 
< 			return (Image) icons.get(i);
< 		}
< 
< 		/**
< 		 * Sets the icon at the index location.
< 		 * 
< 		 * @param icon
< 		 * @param i
< 		 */
< 		public void setIcon(Image icon, int i) {
< 			int size = icons.size();
< 			if (i >= size) {
< 				for (int j = size; j < i; j++)
< 					icons.add(null);
< 				icons.add(icon);
< 				icons.trimToSize();
< 			} else
< 				icons.set(i, icon);
< 		}
< 
< 		/**
< 		 * Gets the icon size of the icon at the given index.
< 		 * 
< 		 * @param i
< 		 * @return the <code>Dimension</code> that is the size of the icon at
< 		 *         the given index.
< 		 */
< 		public Dimension getIconSize(IMapMode mapMode, int i) {
< 			Image img = getIcon(i);
< 			if (img != null && !img.isDisposed()) {
< 				org.eclipse.swt.graphics.Rectangle imgBounds = img.getBounds();				
< 				return new Dimension(mapMode.DPtoLP(imgBounds.width), mapMode
< 					.DPtoLP(imgBounds.height));
< 			}
< 			return EMPTY_DIMENSION;
< 		}
< 
< 		/**
< 		 * @return the number of icons
< 		 */
< 		public int getNumberofIcons() {
< 			return icons.size();
< 		}
< 
< 		/**
< 		 * @return the <code>Dimension</code> that is the total size of all
< 		 *         the icons.
< 		 */
< 		public Dimension getTotalIconSize(IMapMode mapMode) {
< 			if (totalIconSize != null)
< 				return totalIconSize;
< 			int iconNum = getNumberofIcons();
< 			if (iconNum == 0) {
< 				return totalIconSize = EMPTY_DIMENSION;
< 			}
< 
< 			totalIconSize = new Dimension();
< 			for (int i = 0; i < iconNum; i++) {
< 				Dimension iconSize = getIconSize(mapMode, i);
< 				totalIconSize.width += iconSize.width;
< 				if (iconSize.height > totalIconSize.height)
< 					totalIconSize.height = iconSize.height;
< 			}
< 
< 			return totalIconSize;
< 		}
< 
< 		/**
< 		 * 
< 		 */
< 		public void invalidate() {
< 			totalIconSize = null;
< 		}
< 	}
< 
< 	private IconInfo iconInfo;
< 
< 	/** the cached hint used to calculate text size */	
< 	private int cachedTextSizeHint_width;
< 
< 	private int cachedTextSizeHint_height;
< 	
< 	
< 	
423a64,64
>         super();
424,430d63
< 		text = "";//$NON-NLS-1$
< 		// set defaults
< 		setAlignmentFlags(CENTER, FLAG_TEXT_ALIGN);
< 		setAlignmentFlags(CENTER, FLAG_ICON_ALIGN);
< 		setAlignmentFlags(CENTER, FLAG_LABEL_ALIGN);
< 		setAlignmentFlags(LEFT, FLAG_WRAP_ALIGN);
< 		setPlacementFlags(EAST, FLAG_TEXT_PLACEMENT);
435a70,70
>      * @param s
436,436c71,71
< 	 * @param s the label text
---
>      *            the label text
439a75,79
>         super(s);
>  
>         // Compensate for the fact that the original wraplabel never called the
>         // default constructor to set the default layout values.
>         setTextWrapAlignment(CENTER);
440,445d74
< 		if (s != null) {
< 			text = s;
< 		} else {
< 			text = "";//$NON-NLS-1$
< 		}
< //		setBorder(new LineBorderEx(ColorConstants.red,3));
450a85,85
>      * @param i
451,451c86,86
< 	 * @param i the label image
---
>      *            the label image
454a90,94
>         super(i);
>         
>         // Compensate for the fact that the original wraplabel never called the
>         // default constructor to set the default layout values.
>         setTextWrapAlignment(CENTER);
455,456d89
< 		text = "";//$NON-NLS-1$
< 		iconInfo = new SingleIconInfo(i);
462a101,103
>      * @param s
>      *            the label text
>      * @param i
463,463d100
< 	 * @param s the label text
464,464c104,104
< 	 * @param i the label image
---
>      *            the label image
467a108,108
>         super(s, i);
468,499d107
< 		if (s != null) {
< 			text = s;
< 		} else {
< 			text = "";//$NON-NLS-1$
< 		}
< 		iconInfo = new SingleIconInfo(i);
< 	}
< 	
< 	/**
< 	 * @return <code>IMapMode</code> used by this figure.
< 	 *         <code>IMapMode</code> that allows for the coordinate mapping
< 	 *         from device to logical units.
< 	 */
< 	private IMapMode getFigureMapMode() {
< 		return (IMapMode) getMapModeConstants().mapModeRef.get();
< 	}
< 
< 	private MapModeConstants getMapModeConstants() {
< 		if (mapModeConstants == null) {
< 			IMapMode mapMode = MapModeUtil.getMapMode(this);
< 			while (mapMode instanceof IMapModeHolder) {
< 				mapMode = ((IMapModeHolder) mapMode).getMapMode();
< 			}
< 			mapModeConstants = (MapModeConstants) mapModeConstantsMap
< 				.get(mapMode);
< 			if (mapModeConstants == null) {
< 				mapModeConstants = new MapModeConstants(mapMode);
< 				mapModeConstantsMap.put(mapMode, mapModeConstants);
< 			}
< 		}
< 		return mapModeConstants;
< 	}
500a110,112
>         // Compensate for the fact that the original wraplabel never called the
>         // default constructor to set the default layout values.
>         setTextWrapAlignment(CENTER);
501,540d109
< 	private void alignOnHeight(Point loc, Dimension size, int alignment) {
< 		switch (alignment) {
< 			case TOP:
< 				loc.y = getInsets().top;
< 				break;
< 			case BOTTOM:
< 				loc.y = bounds.height - size.height - getInsets().bottom;
< 				break;
< 			default:
< 				loc.y = (bounds.height - size.height) / 2;
< 		}
< 	}
< 
< 	private void alignOnWidth(Point loc, Dimension size, int alignment) {
< 		switch (alignment) {
< 			case LEFT:
< 				loc.x = getInsets().left;
< 				break;
< 			case RIGHT:
< 				loc.x = bounds.width - size.width - getInsets().right;
< 				break;
< 			default:
< 				loc.x = (bounds.width - size.width) / 2;
< 		}
< 	}
< 
< 	private void calculateAlignment(Dimension iconSize, int textPlacement) {
< 		switch (textPlacement) {
< 			case EAST:
< 			case WEST:
< 				alignOnHeight(textLocation, getTextSize(), getTextAlignment());
< 				alignOnHeight(getIconLocation(), iconSize, getIconAlignment());
< 				break;
< 			case NORTH:
< 			case SOUTH:
< 				alignOnWidth(textLocation, getSubStringTextSize(),
< 					getTextAlignment());
< 				alignOnWidth(getIconLocation(), iconSize, getIconAlignment());
< 				break;
< 		}
544,648d115
< 	 * Calculates the size of the Label using the passed Dimension as the size
< 	 * of the Label's text.
< 	 * 
< 	 * @param txtSize the precalculated size of the label's text
< 	 * @return the label's size
< 	 * @since 2.0
< 	 */
< 	protected Dimension calculateLabelSize(Dimension txtSize) {
< 		Dimension iconSize = getTotalIconSize();
< 		boolean isEmpty = (iconSize.width == 0 && iconSize.height == 0);
< 		int len = getText().length();
< 		if (len == 0 && isEmpty) {
< 			return new Dimension(txtSize.width, txtSize.height);
< 		}
< 		int gap = (len == 0 || isEmpty) ? 0
< 			: getIconTextGap();
< 		int placement = getTextPlacement();
< 		if (placement == WEST || placement == EAST) {
< 			return new Dimension(iconSize.width + gap + txtSize.width, Math
< 				.max(iconSize.height, txtSize.height));
< 		} else {
< 			return new Dimension(Math.max(iconSize.width, txtSize.width),
< 				iconSize.height + gap + txtSize.height);
< 		}
< 	}
< 
< 	private void calculateLocations() {
< 		textLocation = new Point();
< 		iconLocation = new Point();
< 		Dimension iconSize = getTotalIconSize();
< 		int textPlacement = getTextPlacement();
< 		calculatePlacement(iconSize, textPlacement);
< 		calculateAlignment(iconSize, textPlacement);
< 		Rectangle r = getBounds();
< 		Dimension ps = getPreferredSize(r.width, r.height);
< 		int w = (r.width - ps.width)
< 			+ (getTextSize().width - getSubStringTextSize().width);
< 		int h = r.height - ps.height;
< 		if (w == 0 && h == 0) {
< 			return;
< 		}
< 
< 		Dimension offset = new Dimension(w, h);
< 		switch (getLabelAlignment()) {
< 			case CENTER:
< 				offset.scale(0.5f);
< 				break;
< 			case LEFT:
< 				offset.scale(0.0f);
< 				break;
< 			case RIGHT:
< 				offset.scale(1.0f);
< 				break;
< 			case TOP:
< 				offset.height = 0;
< 				offset.scale(0.5f);
< 				break;
< 			case BOTTOM:
< 				offset.height = offset.height * 2;
< 				offset.scale(0.5f);
< 				break;
< 			default:
< 				offset.scale(0.5f);
< 				break;
< 		}
< 
< 		switch (textPlacement) {
< 			case EAST:
< 			case WEST:
< 				offset.height = 0;
< 				break;
< 			case NORTH:
< 			case SOUTH:
< 				offset.width = 0;
< 				break;
< 		}
< 
< 		textLocation.translate(offset);
< 		iconLocation.translate(offset);
< 	}
< 
< 	private void calculatePlacement(Dimension iconSize, int textPlacement) {
< 		int gap = (getText().length() == 0 || (iconSize.width == 0 && iconSize.height == 0)) ? 0
< 			: getIconTextGap();
< 		Insets insets = getInsets();
< 		switch (textPlacement) {
< 			case EAST:
< 				iconLocation.x = insets.left;
< 				textLocation.x = iconSize.width + gap + insets.left;
< 				break;
< 			case WEST:
< 				textLocation.x = insets.left;
< 				iconLocation.x = getSubStringTextSize().width + gap
< 					+ insets.left;
< 				break;
< 			case NORTH:
< 				textLocation.y = insets.top;
< 				iconLocation.y = getTextSize().height + gap + insets.top;
< 				break;
< 			case SOUTH:
< 				textLocation.y = iconSize.height + gap + insets.top;
< 				iconLocation.y = insets.top;
< 		}
< 	}
< 	/**
655a123,124
>      * @deprecated If this behavior is required then a request can be made (with
>      *             justification) for the WrappingLabel.
671a141,142
>      * @deprecated If this behavior is required then a request can be made (with
>      *             justification) for the WrappingLabel.
673a145,145
>         return getTextFlow().getPreferredSize(wHint, hHint);
674,721d144
< 		Font f = getFont();
< 		return getTextExtents(getWrappedText(wHint, hHint), f,getFigureMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight()));
< 	}
< 
< 	private void clearLocations() {
< 		iconLocation = textLocation = null;
< 	}
< 
< 	/**
< 	 * Returns the Label's icon.
< 	 * 
< 	 * @return the label icon
< 	 * @since 2.0
< 	 */
< 	public Image getIcon() {
< 		return getIcon(0);
< 	}
< 
< 	/**
< 	 * Gets the label's icon at the given index
< 	 * 
< 	 * @param index The icon index
< 	 * @return the <code>Image</code> that is the icon for the given index.
< 	 */
< 	public Image getIcon(int index) {
< 		if (iconInfo == null)
< 			return null;
< 		return iconInfo.getIcon(index);
< 	}
< 
< 	/**
< 	 * Determines if there is any icons by checking if icon size is zeros.
< 	 * 
< 	 * @return true if icons are present, false otherwise 
< 	 */
< 	protected boolean hasIcons() {
< 		return (getNumberofIcons() > 0);
< 	}
< 
< 	/**
< 	 * Returns the current alignment of the Label's icon. The default is
< 	 * {@link PositionConstants#CENTER}.
< 	 * 
< 	 * @return the icon alignment
< 	 * @since 2.0
< 	 */
< 	public int getIconAlignment() {
< 		return getAlignment(FLAG_ICON_ALIGN);
727,727c151,151
< 	 * @return the icon's bounds
---
>      * @return the icon's bounds
728,750d151
< 	 * @since 2.0
< 	 */
< 	public Rectangle getIconBounds() {
< 		return new Rectangle(getBounds().getLocation().translate(
< 			getIconLocation()), getTotalIconSize());
< 	}
< 
< 	/**
< 	 * Returns the location of the Label's icon relative to the Label.
< 	 * 
< 	 * @return the icon's location
< 	 * @since 2.0
< 	 */
< 	protected Point getIconLocation() {
< 		if (iconLocation == null)
< 			calculateLocations();
< 		return iconLocation;
< 	}
< 
< 	/**
< 	 * Returns the gap in pixels between the Label's icon and its text.
< 	 * 
< 	 * @return the gap
751a153,155
>      * @deprecated The icon location can be retrieved with
>      *             {@link #getIconLocation()} and the icon(s) size can be
>      *             retrieved with {@link #getTotalIconSize()}.
752a157,160
>     public Rectangle getIconBounds() {
>         if (hasIcons()) {
>             return new Rectangle(getBounds().getLocation().translate(
>                 getIconLocation()), getTotalIconSize());
753a401,401
>         return getTextJustification();
753,753c400,400
< 	public int getIconTextGap() {
---
>     public int getTextWrapAlignment() {
754,754d400
< 		return getMapModeConstants().nDPtoLP_3;
756,804d161
< 
< 	/**
< 	 * @see IFigure#getMinimumSize(int, int)
< 	 */
< 	public Dimension getMinimumSize(int w, int h) {
< 		if (minSize != null)
< 			return minSize;
< 		minSize = new Dimension();
< 		LayoutManager layoutManager = getLayoutManager();
< 		if (layoutManager != null)
< 			minSize.setSize(layoutManager.getMinimumSize(this, w, h));
< 		Font f = getFont();
< 		Dimension d = getEllipseTextSize().getIntersected(
< 			getTextExtents(getText(), f, getFigureMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight())));		
< 		
< 		Dimension labelSize = calculateLabelSize(d);
< 		Insets insets = getInsets();
< 		labelSize.expand(insets.getWidth(), insets.getHeight());
< 		minSize.union(labelSize);
< 		return minSize;
< 	}
< 
< 	/* 
< 	 * (non-Javadoc)
< 	 * @see org.eclipse.draw2d.IFigure#getPreferredSize(int, int)
< 	 */
< 	public Dimension getPreferredSize(int wHint, int hHint) {
< 		if (prefSize == null || wHint != cachedPrefSizeHint_width || hHint != cachedPrefSizeHint_height) {
< 			prefSize = calculateLabelSize(getTextSize(wHint, hHint));
< 			Insets insets = getInsets();
< 			prefSize.expand(insets.getWidth(), insets.getHeight());
< 			LayoutManager layoutManager = getLayoutManager();
< 			if (layoutManager != null) {
< 				prefSize.union(layoutManager.getPreferredSize(this, wHint,
< 					hHint));
< 			}
< 			prefSize.union(getMinimumSize(wHint, hHint));
< 			cachedPrefSizeHint_width = wHint;
< 			cachedPrefSizeHint_height = hHint;
< 		}
< 		return prefSize;
< 	}
< 
< 	/* (non-Javadoc)
< 	 * @see org.eclipse.draw2d.IFigure#getMaximumSize()
< 	 */
< 	public Dimension getMaximumSize() {
< 		// this assumes that getPreferredSize(wHint, hHint) is called before
< 		return prefSize;   
812a171,172
>      * @deprecated If this behavior is required then a request can be made (with
>      *             justification) for the WrappingLabel.
823a184,185
>         Dimension shrink = getPreferredSize(size.width, size.height)
>             .getDifference(size);
824,824d183
< 		Dimension shrink = getPreferredSize(size.width, size.height).getDifference(size);
825,825c186,186
< 		Dimension effectiveSize = getTextSize().getExpanded(-shrink.width, -shrink.height);
---
>         Dimension effectiveSize = getTextSize().getExpanded(-shrink.width,
825a187,187
>             -shrink.height);
846,846c208,208
< 			- getEllipseTextSize().width, 0);
---
>             - getTruncationStringSize().width, 0);
849,849c211,211
< 			i = getLineWrapPosition(remainingText.toString(), f, effectiveSizeWidth, fontHeight);
---
>             i = getLineWrapPosition(remainingText.toString(), f,
849a212,212
>                 effectiveSizeWidth, fontHeight);
855a219,219
>                     widthHint, fontHeight, charAverageWidth);
855,855c218,218
< 				i = getLargestSubstringConfinedTo(remainingText.toString(), f, widthHint, fontHeight, charAverageWidth);
---
>                 i = getLargestSubstringConfinedTo(remainingText.toString(), f,
865,926d228
< 	
< 	
< 	
< 	/**
< 	 * Creates an equivalent text to that of the label's but with "\n"(s)
< 	 * inserted at the wrapping positions. This method assumes unlimited
< 	 * bounding box and is used by <code>calculateTextSize()</code> to
< 	 * calculate the perfect size of the text with wrapping
< 	 * 
< 	 * @return the wrapped text
< 	 */	
< 	private String getWrappedText(int wHint, int hHint) {
< 		String theText = getText();		
< 		if (wHint == -1 || theText.length() == 0 || !isTextWrapped())
< 			return theText;
< 
< 		Dimension iconSize = getTotalIconSize();
< 		if (!(iconSize.width == 0 && iconSize.height == 0)) {
< 			switch(getTextPlacement()) {
< 				case EAST:
< 				case WEST:
< 					wHint -= iconSize.width + getIconTextGap();
< 					break;
< 				case NORTH:
< 				case SOUTH:
< 					if (hHint != -1)
< 						hHint -= iconSize.height + getIconTextGap();
< 					break;
< 			}
< 		}
< 		
< 		
< 		if ((hHint == 0)||(wHint == 0)) {
< 			return "";//$NON-NLS-1$;
< 		}
< 		
< 		Font f = getFont();
< 		int fontHeight = getFigureMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight());
< 		int maxLines = Integer.MAX_VALUE;
< 		if (hHint != -1) {			
< 			maxLines = (int) (hHint / (double) fontHeight);
< 			if (maxLines == 0) {
< 				return "";//$NON-NLS-1$;;
< 			}
< 		}	
< 		
< 		StringBuffer accumlatedText = new StringBuffer();
< 		StringBuffer remainingText = new StringBuffer(theText);
< 		int i = 0, j = 0;
< 
< 		while (remainingText.length() > 0 && j++  < maxLines) {
< 			if ((i = getLineWrapPosition(remainingText.toString(), f, wHint, fontHeight)) == 0)
< 				break;
< 
< 			if (accumlatedText.length() > 0)
< 				accumlatedText.append('\n');
< 			accumlatedText.append(remainingText.substring(0, i));
< 			remainingText.delete(0, i);
< 		}
< 		return accumlatedText.toString();
< 	}
< 
933a236,237
>      * @deprecated If this behavior is required then a request can be made (with
>      *             justification) for the WrappingLabel.
940,1001d243
< 	 * Returns the size of the String constant "..." the ellipse based on
< 	 * the currently used Map mode
< 	 * size.
< 	 * 
< 	 * @return the size of ellipse text
< 	 * 
< 	 */
< 	private Dimension getEllipseTextSize() {
< 		if (ellipseTextSize == null) {
< 			ellipseTextSize = getMapModeConstants().getEllipseTextSize(
< 				getFont());
< 		}
< 		return ellipseTextSize;
< 	}
< 
< 	/**
< 	 * Returns the text of the label. Note that this is the complete text of the
< 	 * label, regardless of whether it is currently being truncated. Call
< 	 * {@link #getSubStringText()}to return the label's current text contents
< 	 * with truncation considered.
< 	 * 
< 	 * @return the complete text of this label
< 	 * @since 2.0
< 	 */
< 	public String getText() {
< 		return text;
< 	}
< 
< 	/**
< 	 * Returns the current alignment of the Label's text. The default text
< 	 * alignment is {@link PositionConstants#CENTER}.
< 	 * 
< 	 * @return the text alignment
< 	 */
< 	public int getTextAlignment() {
< 		return getAlignment(FLAG_TEXT_ALIGN);
< 	}
< 
< 	/**
< 	 * Returns the current alignment of the entire Label. The default label
< 	 * alignment is {@link PositionConstants#LEFT}.
< 	 * 
< 	 * @return the label alignment
< 	 */
< 	private int getLabelAlignment() {
< 		return getAlignment(FLAG_LABEL_ALIGN);
< 	}
< 	
< 	/**
< 	 * Returns the bounds of the label's text. Note that the bounds are
< 	 * calculated using the label's complete text regardless of whether the
< 	 * label's text is currently truncated.
< 	 * 
< 	 * @return the bounds of this label's complete text
< 	 * @since 2.0
< 	 */
< 	public Rectangle getTextBounds() {
< 		return new Rectangle(getBounds().getLocation().translate(
< 			getTextLocation()), getTextSize());
< 	}
< 
< 	/**
1005a248,248
>      * @deprecated Use <code>getTextBounds().getLocation()</code> instead.
1007a251,251
>         return getTextBounds().getLocation();
1008,1022d250
< 		if (textLocation != null)
< 			return textLocation;
< 		calculateLocations();
< 		return textLocation;
< 	}
< 
< 	/**
< 	 * Returns the current placement of the label's text relative to its icon.
< 	 * The default text placement is {@link PositionConstants#EAST}.
< 	 * 
< 	 * @return the text placement
< 	 * @since 2.0
< 	 */
< 	public int getTextPlacement() {
< 		return getPlacement(FLAG_TEXT_PLACEMENT);
1031a261,263
>      * @param wHint
>      *            a width hint
>      * @param hHint
1032,1032d260
< 	 * @param wHint a width hint
1033,1033c264,264
< 	 * @param hHint a height hint
---
>      *            a height hint
1035a267,268
>      * @deprecated If this behavior is required then a request can be made (with
>      *             justification) for the WrappingLabel.
1037a271,271
>         return getTextFlow().getPreferredSize(wHint, hHint);
1038,1043d270
< 		if (textSize == null || wHint != cachedTextSizeHint_width || hHint != cachedTextSizeHint_height) {
< 			textSize = calculateTextSize(wHint, hHint);
< 			cachedTextSizeHint_width = wHint;
< 			cachedTextSizeHint_height= hHint;
< 		}
< 		return textSize;
1058,1062d285
< 		prefSize = null;
< 		minSize = null;
< 		clearLocations();
< 		ellipseTextSize = null;
< 		textSize = null;
1064,1065d286
< 		if (iconInfo != null)
< 			iconInfo.invalidate();
1074a296,297
>      * @deprecated If this behavior is required then a request can be made (with
>      *             justification) for the WrappingLabel.
1081,1317d303
< 	 * @see org.eclipse.draw2d.Figure#paintFigure(org.eclipse.draw2d.Graphics)
< 	 */
< 	public void paintFigure(Graphics graphics) {
< 		if (isSelected()) {
< 			graphics.pushState();
< 			graphics.setBackgroundColor(ColorConstants.menuBackgroundSelected);
< 			graphics.fillRectangle(getSelectionRectangle());
< 			graphics.popState();
< 			graphics.setForegroundColor(ColorConstants.white);
< 		}
< 		if (hasFocus()) {
< 			graphics.pushState();
< 			graphics.setXORMode(true);
< 			graphics.setForegroundColor(ColorConstants.menuBackgroundSelected);
< 			graphics.setBackgroundColor(ColorConstants.white);
< 			graphics.drawFocus(getSelectionRectangle().resize(-1, -1));
< 			graphics.popState();
< 		}
< 		if (isOpaque())
< 			super.paintFigure(graphics);
< 		Rectangle figBounds = getBounds();
< 
< 		graphics.translate(figBounds.x, figBounds.y);
< 		if (hasIcons())
< 			paintIcons(graphics);
< 
< 		String subString = getSubStringText();
< 		if (subString.length() > 0) {
< 			if (!isEnabled()) {
< 				graphics.translate(1, 1);
< 				graphics.setForegroundColor(ColorConstants.buttonLightest);
< 				paintText(graphics, subString);
< 				graphics.translate(-1, -1);
< 				graphics.setForegroundColor(ColorConstants.buttonDarker);
< 			} else {
< 				paintText(graphics, subString);
< 			}
< 		}
< 		graphics.translate(-figBounds.x, -figBounds.y);
< 	}
< 
< 	/**
< 	 * Paints the text and optioanally underlines it
< 	 * 
< 	 * @param graphics The graphics context
< 	 * @param subString The string to draw
< 	 */	
< 	private void paintText(Graphics graphics, String subString) {		
< 		StringTokenizer tokenizer = new StringTokenizer(subString, "\n"); //$NON-NLS-1$
< 		Font f = getFont();
< 		FontMetrics fontMetrics = FigureUtilities.getFontMetrics(f);
< 		int fontHeight = getFigureMapMode().DPtoLP(fontMetrics.getHeight());
< 		int fontHeightHalf = fontHeight / 2;
< 		int textWidth = getTextExtents(subString, f, fontHeight).width;
< 		Point p = getTextLocation();
< 		int y = p.y;
< 		int x = p.x;
< 		final int wrapAlignment = getTextWrapAlignment();
< 		boolean isUnderlined = isTextUnderlined();
< 		boolean isStrikedThrough = isTextStrikedThrough();
< 		Rectangle clipRect = new Rectangle();
< 		graphics.getClip(clipRect);
< 		int clipRectTopRight_x = clipRect.getTopRight().x;
< 		// If the font's leading area is 0 then we need to add an offset to
< 		// avoid truncating at the top (e.g. Korean fonts)
< 		if (0 == fontMetrics.getLeading()) {
< 			y +=  getMapModeConstants().nDPtoLP_2; // 2 is the leading area for default English			
< 		}				
< 
< 		while (tokenizer.hasMoreTokens()) {
<             x = p.x;
< 			String token = tokenizer.nextToken();
< 			int tokenWidth = getTextExtents(token, f, fontHeight).width;
< 			
< 			switch (wrapAlignment) {
< 				case CENTER:
< 					x += (textWidth - tokenWidth) / 2;
< 					break;
< 				case RIGHT:
< 					x += textWidth - tokenWidth;
< 					break;
< 			}
< 			
< 			// increase the clipping rectangle by a small amount to account for font overhang
< 			// from italic / irregular characters etc.
< 			
< 			
< 			if (tokenWidth + x <= clipRectTopRight_x) {
< 				Rectangle newClipRect = new Rectangle(clipRect);
< 				newClipRect.width += (tokenWidth / token.length()) / 2;
< 				graphics.setClip(newClipRect);
< 			}
< 				
< 			graphics.drawText(token, x, y);
< 			graphics.setClip(clipRect);
< 			
< 			y += fontHeight;
< 
< 			if (isUnderlined)
< 				graphics.drawLine(x, y - 1, x + tokenWidth, y - 1);
< 			if (isStrikedThrough)
< 				graphics.drawLine(x, y - fontHeightHalf + 1, x + tokenWidth, y
< 					- fontHeightHalf + 1);
< 		}
< 	}
< 
< 	/**
< 	 * Paints the icon(s)
< 	 * 
< 	 * @param graphics The graphics context
< 	 */
< 	private void paintIcons(Graphics graphics) {
< 		Point p = Point.SINGLETON;
< 		p.setLocation(getIconLocation());
< 
< 		int num = getNumberofIcons();
< 		for (int i = 0; i < num; i++) {
< 			Image icon = getIcon(i); 
< 			if (icon != null) {
< 				graphics.drawImage(icon, p);
< 				p.x += getIconSize(i).width;
< 			}
< 		}
< 	}
< 
< 	/**
< 	 * Sets the label's icon to the passed image.
< 	 * 
< 	 * @param image the new label image
< 	 * @since 2.0
< 	 */
< 	public void setIcon(Image image) {
< 		setIcon(image, 0);
< 	}
< 
< 	/**
< 	 * Sets the label's icon at given index
< 	 * 
< 	 * @param image The icon image or null to remove the icon
< 	 * @param index The icon index
< 	 */
< 	public void setIcon(Image image, int index) {
< 		if (iconInfo == null) {
< 			if (index == 0) {
< 				iconInfo = getMapModeConstants().getSingleIconInfo(image);
< 			} else {
< 				iconInfo = new MultiIconInfo();
< 				iconInfo.setIcon(image, index);
< 			}
< 			revalidate();
< 			repaint();// Call repaint, in case the image dimensions are the same.           
< 		} else if (iconInfo.getIcon(index) != image) {
< 			if (iconInfo.getMaxIcons() == 1) {
< 				if (index == 0) {
< 					iconInfo = getMapModeConstants().getSingleIconInfo(image);
< 					revalidate();
< 					repaint();// Call repaint, in case the image dimensions are the same.
< 					return;
< 				}
< 				IconInfo oldIconInfo = iconInfo;
< 				iconInfo = new MultiIconInfo();
< 				iconInfo.setIcon(oldIconInfo.getIcon(0), 0);
< 			}
< 			iconInfo.setIcon(image, index);
< 			revalidate();
< 			repaint();// Call repaint, in case the image dimensions are the same.
< 		}	
< 	}
< 
< 
< 	/**
< 	 * Sets the icon alignment relative to the .abel's alignment to the passed
< 	 * value. The default is {@link PositionConstants#CENTER}. Other possible
< 	 * values are {@link PositionConstants#TOP},
< 	 * {@link PositionConstants#BOTTOM},{@link PositionConstants#LEFT}and
< 	 * {@link PositionConstants#RIGHT}.
< 	 * 
< 	 * @param align the icon alignment
< 	 * @since 2.0
< 	 */
< 	public void setIconAlignment(int align) {
< 		if (getIconAlignment() == align)
< 			return;
< 		setAlignmentFlags(align, FLAG_ICON_ALIGN);
< 		clearLocations();
< 		repaint();
< 	}
< 
< 	/**
< 	 * getIconSize
< 	 * @param index of icon to retrieve size of.
< 	 * @return Dimension representing the icon size.
< 	 */
< 	protected Dimension getIconSize(int index) {
< 		if (iconInfo == null)
< 			return EMPTY_DIMENSION;
< 		return iconInfo.getIconSize(getFigureMapMode(), index);
< 	}
< 	
< 	/**
< 	 * getIconNumber
< 	 * @return int number of icons in the wrap label
< 	 */
< 	protected int getNumberofIcons() {
< 		if (iconInfo == null)
< 			return 0;
< 		return iconInfo.getNumberofIcons();
< 	}
< 	
< 	/**
< 	 * getTotalIconSize
< 	 * Calculates the total union of icon sizes
< 	 * @return Dimension that is the union of icon sizes
< 	 */
< 	protected Dimension getTotalIconSize() {
< 		if (iconInfo == null)
< 			return EMPTY_DIMENSION;
< 		return iconInfo.getTotalIconSize(getFigureMapMode());
< 	}
< 
< 	/**
< 	 * Sets the Label's alignment to the passed value. The default is
< 	 * {@link PositionConstants#CENTER}. Other possible values are
< 	 * {@link PositionConstants#TOP},{@link PositionConstants#BOTTOM},
< 	 * {@link PositionConstants#LEFT}and {@link PositionConstants#RIGHT}.
< 	 * 
< 	 * @param align label alignment
< 	 */
< 	public void setLabelAlignment(int align) {
< 		if (getLabelAlignment() == align)
< 			return;
< 		setAlignmentFlags(align, FLAG_LABEL_ALIGN);
< 		clearLocations();
< 		repaint();
< 	}
< 
< 	/**
1320,1320c306,306
< 	 * @return the <code>String</code> that represents the fact that the
---
>      * @return the <code>String</code> that represents the fact that the text
1321,1321c307,307
< 	 * text has been truncated and that more text is available but hidden. 
---
>      *         has been truncated and that more text is available but hidden.
1322a309,309
>      *         @deprecated Renamed to {@link #getTruncationString()}
1324a312,312
>         return ELLIPSIS;
1325,1408d311
< 		return _ellipse;
< 	}
< 	
< 	/**
< 	 * Sets the label's text.
< 	 * 
< 	 * @param s the new label text
< 	 * @since 2.0
< 	 */
< 	public void setText(String s) {
< 		//"text" will never be null.
< 		if (s == null)
< 			s = "";//$NON-NLS-1$
< 		if (text.equals(s))
< 			return;
< 		text = s;
< 		revalidate();
< 		repaint(); //If the new text does not cause a new size, we still need
< 		// to paint.
< 	}
< 
< 	/**
< 	 * Sets the text alignment of the Label relative to the label alignment. The
< 	 * default is {@link PositionConstants#CENTER}. Other possible values are
< 	 * {@link PositionConstants#TOP},{@link PositionConstants#BOTTOM},
< 	 * {@link PositionConstants#LEFT}and {@link PositionConstants#RIGHT}.
< 	 * 
< 	 * @param align the text alignment
< 	 * @since 2.0
< 	 */
< 	public void setTextAlignment(int align) {
< 		if (getTextAlignment() == align)
< 			return;
< 		setAlignmentFlags(align, FLAG_TEXT_ALIGN);
< 		clearLocations();
< 		repaint();
< 	}
< 
< 	/**
< 	 * Sets the text placement of the label relative to its icon. The default is
< 	 * {@link PositionConstants#EAST}. Other possible values are
< 	 * {@link PositionConstants#NORTH},{@link PositionConstants#SOUTH}and
< 	 * {@link PositionConstants#WEST}.
< 	 * 
< 	 * @param where the text placement
< 	 * @since 2.0
< 	 */
< 	public void setTextPlacement(int where) {
< 		if (getTextPlacement() == where)
< 			return;
< 		setPlacementFlags(where, FLAG_TEXT_PLACEMENT);
< 		revalidate();
< 		repaint();
< 	}
< 
< 	/**
< 	 * Sets whether the label text should be underlined
< 	 * 
< 	 * @param b Wether the label text should be underlined
< 	 */
< 	public void setTextUnderline(boolean b) {
< 		if (isTextUnderlined() == b)
< 			return;
< 		setFlag(FLAG_UNDERLINED, b);
< 		repaint();
< 	}
< 
< 	/**
< 	 * @return whether the label text is underlined
< 	 */
< 	public boolean isTextUnderlined() {
< 		return (flags & FLAG_UNDERLINED) != 0;
< 	}
< 	
< 	/**
< 	 * Sets whether the label text should be striked-through
< 	 * 
< 	 * @param b Wether the label text should be stricked-through
< 	 */
< 	public void setTextStrikeThrough(boolean b) {
< 		if (isTextStrikedThrough() == b)
< 			return;
< 		setFlag(FLAG_STRIKEDTHROUGH, b);
< 		repaint();
1410a315,317
>     protected String getTruncationString() {
>         if (getEllipse() != null) {
>             return getEllipse();
1411,1415d314
< 	/**
< 	 * @return wether the label text is stricked-through
< 	 */
< 	public boolean isTextStrikedThrough() {
< 		return (flags & FLAG_STRIKEDTHROUGH) != 0;
1416a319,319
>         return ELLIPSIS;
1417,1428d318
< 
< 	/**
< 	 * Sets whether the label text should wrap
< 	 * 
< 	 * @param b whether the label text should wrap
< 	 */
< 	public void setTextWrap(boolean b) {
< 		if (isTextWrapped() == b)
< 			return;
< 		setFlag(FLAG_WRAP, b);
< 		revalidate();
< 		repaint();
1432,1432c323,323
< 	 * @return wether the label text wrap is on
---
>      * @return whether the label text wrap is on
1432a324,326
>      * @deprecated Use {@link #isTextWrapOn()} instead. This method was renamed
>      *             because it never indicated if the text was actually wrapped,
>      *             but whether text wrapping was turned on in the label.
1434a162,162
>         return new Rectangle(0, 0, 0, 0);
1434a329,329
>         return isTextWrapOn();
1435,1435d161
< 		return (flags & FLAG_WRAP) != 0;
1441a336,336
>      * @param i
1442,1442c337,337
< 	 * @param i The label text wrapping width
---
>      *            The label text wrapping width
1442a338,338
>      * @deprecated this method was empty and never called
1444a341,341
>         // do nothing
1445,1448d340
< 		/*
< 		 * if (this.wrapWidth == i) return; this.wrapWidth = i; revalidate();
< 		 * repaint();
< 		 */
1454a348,362
>      * @param i
>      *            The label text wrapping width
>      * @deprecated Call {@link #setTextJustification(int)} and
>      *             {@link #setAlignment(int)} instead. This method was somewhat
>      *             controlling text justification and label alignment, but they
>      *             are really two independent settings. Previously,
>      *             setTextWrapAlignment(CENTER) would not only center-justifies
>      *             the text, but also put the label in the center. Now, you need
>      *             to call {@link #setTextJustification(int)} to justify the
>      *             text (this only affects text when it is wrapped) and
>      *             {@link #setAlignment(int)} to position the text correctly in
>      *             the label. If you want the text in the center of the label
>      *             than call <code>setAlignment(PositionConstants.CENTER)</code>.
>      *             Look at the implementation of this method to see how your
>      *             code needs to be migrated.
1455,1455d347
< 	 * @param i The label text wrapping width
1457a365,365
>         setTextJustification(i);
1458,1470d364
< 		if (getTextWrapAlignment() == i)
< 			return;
< 		
< 		setAlignmentFlags(i, FLAG_WRAP_ALIGN);
< 		repaint();
< 	}
< 
< 	/**
< 	 * @return the label text wrapping width
< 	 */
< 	public int getTextWrapAlignment() {
< 		return getAlignment(FLAG_WRAP_ALIGN);
< 	}
1471a367,372
>         // The old WrapLabel's Text Wrap Alignment (i.e. justification) and
>         // Label Alignment did not work properly. They worked together
>         // previously so we need to compensate for this here.
>         switch (i) {
>             case LEFT:
>                  setAlignment(TOP | LEFT);
1472,1490d366
< 	/**
< 	 * setPlacementFlags
< 	 * @param align 
< 	 * @param flagOffset
< 	 */
< 	private void setPlacementFlags(int align, int flagOffset) {
< 		flags &= ~(0x7 * flagOffset);
< 		switch (align) {
< 			case EAST:
< 				flags |= 0x1 * flagOffset;
< 				break;
< 			case WEST:
< 				flags |= 0x2 * flagOffset;
< 				break;
< 			case NORTH:
< 				flags |= 0x3 * flagOffset;
< 				break;
< 			case SOUTH:
< 				flags |= 0x4 * flagOffset;
1492,1522d373
< 		}
< 	}
< 
< 	/**
< 	 * getPlacement
< 	 * 
< 	 * @param flagOffset
< 	 * @return PositionConstant representing the placement
< 	 */
< 	private int getPlacement(int flagOffset) {
< 		int wrapValue = flags & (0x7 * flagOffset);
< 		if (wrapValue == 0x1 * flagOffset)
< 			return EAST;
< 		else if (wrapValue == 0x2 * flagOffset)
< 			return WEST;
< 		else if (wrapValue == 0x3 * flagOffset)
< 			return NORTH;
< 		else if (wrapValue == 0x4 * flagOffset)
< 			return SOUTH;
< 		
< 		return EAST;
< 	}
< 	
< 	/**
< 	 * setAlignmentFlags
< 	 * @param align 
< 	 * @param flagOffset
< 	 */
< 	private void setAlignmentFlags(int align, int flagOffset) {
< 		flags &= ~(0x7 * flagOffset);
< 		switch (align) {
1523a375,375
>                 setAlignment(TOP);
1524,1530d374
< 				flags |= 0x1 * flagOffset;
< 				break;
< 			case TOP:
< 				flags |= 0x2 * flagOffset;
< 				break;
< 			case LEFT:
< 				flags |= 0x3 * flagOffset;
1532a378,378
>                 setAlignment(TOP | RIGHT);
1533,1533d377
< 				flags |= 0x4 * flagOffset;
1534a380,380
>             default:
1535,1536d379
< 			case BOTTOM:
< 				flags |= 0x5 * flagOffset;
1541a386,393
>      * @deprecated This never worked properly anyways. Call
>      *             {@link #setAlignment(int)} instead to position the icon and
>      *             text within the label.
>      */
>     public void setLabelAlignment(int alignment) {
>         // setLabelAlignment() never worked properly instead the label alignment
>         // seemed to be based on the text justification. Therefore, if it was
>         // set it will be ignored.
1542,1600d385
< 	 * Retrieves the alignment value from the flags member.
< 	 * 
< 	 * @param flagOffset that is the bitwise value representing the offset.
< 	 * @return PositionConstant representing the alignment
< 	 */
< 	private int getAlignment(int flagOffset) {
< 		int wrapValue = flags & (0x7 * flagOffset);
< 		if (wrapValue == 0x1 * flagOffset)
< 			return CENTER;
< 		else if (wrapValue == 0x2 * flagOffset)
< 			return TOP;
< 		else if (wrapValue == 0x3 * flagOffset)
< 			return LEFT;
< 		else if (wrapValue == 0x4 * flagOffset)
< 			return RIGHT;
< 		else if (wrapValue == 0x5 * flagOffset)
< 			return BOTTOM;
< 		
< 		return CENTER;
< 	}
< 	
< 
< 	/**
< 	 * Sets the selection state of this label
< 	 * 
< 	 * @param b true will cause the label to appear selected
< 	 */
< 	public void setSelected(boolean b) {
< 		if (isSelected() == b)
< 			return;
< 		setFlag(FLAG_SELECTED, b);
< 		repaint();
< 	}
< 
< 	/**
< 	 * @return the selection state of this label
< 	 */
< 	public boolean isSelected() {
< 		return (flags & FLAG_SELECTED) != 0;
< 	}
< 
< 	/**
< 	 * Sets the focus state of this label
< 	 * 
< 	 * @param b true will cause a focus rectangle to be drawn around the text
< 	 *            of the Label
< 	 */
< 	public void setFocus(boolean b) {
< 		if (hasFocus() == b)
< 			return;
< 		setFlag(FLAG_HASFOCUS, b);
< 		repaint();
< 	}
< 
< 	/**
< 	 * @return the focus state of this label
< 	 */
< 	public boolean hasFocus() {
< 		return (flags & FLAG_HASFOCUS) != 0;
1603a397,398
>      * @return the label text wrapping width
>      * @deprecated Renamed to {@link #getTextJustification()}
1604,1606d396
< 	 * Returns the bounds of the text selection
< 	 * 
< 	 * @return The bounds of the text selection
1608,1614d399
< 	private Rectangle getSelectionRectangle() {
< 		Rectangle figBounds = getTextBounds();
< 		int expansion = getMapModeConstants().nDPtoLP_2;
< 		figBounds.resize(expansion, expansion);
< 		translateToParent(figBounds);
< 		figBounds.intersect(getBounds());
< 		return figBounds;
1620a408,410
>      * @param s
>      *            a text string
>      * @param f
1621,1621d407
< 	 * @param s a text string
1622a412,414
>      * @param w
>      *            width in pixles.
>      * @param fontHeight
1622,1622c411,411
< 	 * @param f font used to draw the text string
---
>      *            font used to draw the text string
1623,1623d411
< 	 * @param w width in pixles.
1624,1624c415,415
< 	 * @param fontHeight int <b>mapped already to logical units</b>.
---
>      *            int <b>mapped already to logical units</b>.
1656a448,454
>      * @param s
>      *            the original string
>      * @param f
>      *            the font
>      * @param w
>      *            the available width
>      * @param fontHeight
1657,1659d447
< 	 * @param s the original string
< 	 * @param f the font
< 	 * @param w the available width
1660a456,456
>      * @param charAverageWidth
1660,1660c455,455
< 	 * @param fontHeight int <b>mapped already to logical units</b>.
---
>      *            int <b>mapped already to logical units</b>.
1661,1661c457,457
< 	 * @param charAverageWidth int <b>mapped already to logical units</b>.
---
>      *            int <b>mapped already to logical units</b>.
1665,1665c461,461
< 	private int getLargestSubstringConfinedTo(String s, Font f, int w, int fontHeight, int charAverageWidth) {		
---
>     private int getLargestSubstringConfinedTo(String s, Font f, int w,
1665a462,462
>             int fontHeight, int charAverageWidth) {
1713,1714d509
<     
< 	
