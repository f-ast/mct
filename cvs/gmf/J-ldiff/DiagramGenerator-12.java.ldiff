35,35d34
< import org.eclipse.gmf.runtime.common.core.util.Trace;
47,48d45
< import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderDebugOptions;
< import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderPlugin;
144a142,144
> 		org.eclipse.swt.graphics.Rectangle diagramArea = calculateImageRectangle(editparts);
> 		return createAWTImageForParts(editparts, diagramArea);
> 	}
144,144c141,141
< 	abstract public Image createAWTImageForParts(List editparts);
---
> 	public Image createAWTImageForParts(List editparts) {
168a169,169
> 		return createSWTImageDescriptorForParts(editparts, sourceRect);
169a762,772
> 	/**
> 	 * Generates AWT image of specified editparts on the specified rectangle.
> 	 * 
> 	 * @param editParts editparts
> 	 * @param diagramArea clipping rectangle
> 	 * @return AWT image
> 	 */
> 	public Image createAWTImageForParts(List editParts,
> 			org.eclipse.swt.graphics.Rectangle diagramArea) {
> 		return null;
> 	}
169,169c761,761
< 
---
> 
170,171d761
< 		// initialize imageDesc to the error icon
< 		ImageDescriptor imageDesc = new ImageDescriptor() {
172a774,779
> 	final public ImageDescriptor createSWTImageDescriptorForParts(
> 			List editparts, org.eclipse.swt.graphics.Rectangle sourceRect) {
> 
> 		// initialize imageDesc to the error icon
> 		ImageDescriptor imageDesc = new ImageDescriptor() {
> 
172,172c773,773
< 
---
> 
173,173c780,780
< 			/*
---
> 			/*
174,174c781,781
< 			 * (non-Javadoc)
---
> 			 * (non-Javadoc)
175,175c782,782
< 			 * 
---
> 			 * 
176,176c783,783
< 			 * @see org.eclipse.jface.resource.ImageDescriptor#getImageData()
---
> 			 * @see org.eclipse.jface.resource.ImageDescriptor#getImageData()
177,177c784,784
< 			 */
---
> 			 */
178a786,786
> 				return SharedImages.get(SharedImages.IMG_ERROR).getImageData();
178,178c785,785
< 			public ImageData getImageData() {
---
> 			public ImageData getImageData() {
179,180d785
< 				return SharedImages.get(
< 					SharedImages.IMG_ERROR).getImageData();
181,181c787,787
< 			}
---
> 			}
182,182c788,788
< 		};
---
> 		};
183,183c789,789
< 
---
> 
184,184c790,790
< 		Graphics graphics = null;
---
> 		Graphics graphics = null;
185,185c791,791
< 		try {
---
> 		try {
186a793,793
> 
186,186c792,792
< 			IMapMode mm = getMapMode();
---
> 			IMapMode mm = getMapMode();
187,187d792
< 			
188,188c794,794
< 			// Create the graphics and wrap it with the HiMetric graphics object
---
> 			// Create the graphics and wrap it with the HiMetric graphics object
189,189c795,795
< 			graphics = setUpGraphics(mm.LPtoDP(sourceRect.width), mm
---
> 			graphics = setUpGraphics(mm.LPtoDP(sourceRect.width), mm
189a796,796
> 					.LPtoDP(sourceRect.height));
190,190d795
< 				.LPtoDP(sourceRect.height));
191,191c797,797
< 
---
> 
192a799,799
> 					graphics, getMapMode());
192,192c798,798
< 			RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics(
---
> 			RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics(
193,193d798
< 				graphics, getMapMode());
194,194c800,800
< 
---
> 
194a801,802
> 			renderToGraphics(mapModeGraphics, new Point(sourceRect.x,
> 					sourceRect.y), editparts);
195,195d800
< 			renderToGraphics(mapModeGraphics, new Point(sourceRect.x, sourceRect.y), editparts);
196a804,807
> 		} finally {
> 			if (graphics != null)
> 				disposeGraphics(graphics);
> 		}
196,196c803,803
< 			imageDesc = getImageDescriptor(graphics);
---
> 			imageDesc = getImageDescriptor(graphics);
197,202d803
< 		} catch (Error e) {
< 			// log the Error but allow execution to continue
< 			Trace.catching(DiagramUIRenderPlugin.getInstance(),
< 				DiagramUIRenderDebugOptions.EXCEPTIONS_THROWING, getClass(),
< 				"createSWTImageDescriptorForParts() failed to generate image", //$NON-NLS-1$
< 				e);
203,203c808,808
< 
---
> 
203a809,810
> 		return imageDesc;
> 	}
204,210d808
< 		} catch (Exception ex) {
< 			// log the Exception but allow execution to continue
< 			Trace.catching(DiagramUIRenderPlugin.getInstance(),
< 				DiagramUIRenderDebugOptions.EXCEPTIONS_THROWING, getClass(),
< 				"createSWTImageDescriptorForParts() failed to generate image", //$NON-NLS-1$
< 				ex);
< 		}
211,211c811,811
< 
---
> 
212,215d811
< 		if (graphics != null)
< 			disposeGraphics(graphics);
< 
< 		return imageDesc;
232a187,188
> 	 *            a <code>Point</code> that the value the
> 	 *            <code>graphics</code> object will be translated by in
233,233d186
< 	 * 			  a <code>Point</code> that the value the <code>graphics</code> object
234,234c189,189
< 	 * 		   	  will be translated by in relative coordinates.
---
> 	 *            relative coordinates.
305a261,261
> 					.getCopy();
305,305c260,260
<             relBounds = ((IExpandableFigure)figure).getExtendedBounds().getCopy();
---
> 			relBounds = ((IExpandableFigure) figure).getExtendedBounds()
554,554c510,510
< 	protected org.eclipse.swt.graphics.Rectangle calculateImageRectangle(
---
> 	public org.eclipse.swt.graphics.Rectangle calculateImageRectangle(
659,659d614
< 			}
660,660c615,615
< 			else if (part instanceof ConnectionEditPart) {
---
> 			} else if (part instanceof ConnectionEditPart) {
674a630,630
> 							new Point(imageRect.x, imageRect.y));
674,674c629,629
< 					List envelopingPts = calculateEnvelopingPolyline(mainPts, new Point(imageRect.x, imageRect.y));
---
> 					List envelopingPts = calculateEnvelopingPolyline(mainPts,
719,719c675,675
< 	 * On the figure above: AB is a given polyline. E1E2E3E4 is enveloping polyline
---
> 	 * On the figure above: AB is a given polyline. E1E2E3E4 is enveloping
720,720c676,676
< 	 * built around AB perimeter using margin MARGIN.
---
> 	 * polyline built around AB perimeter using margin MARGIN.
723a680,680
> 	 * @param origin
724,724c681,681
< 	 * @param origin location of the main diagram bounding box used to shift coordinates 
---
> 	 *            location of the main diagram bounding box used to shift
725,725c682,682
< 	 * 				to be relative against diagram
---
> 	 *            coordinates to be relative against diagram
727,727c684,684
< 	 * @return List of Point type objects (that carry X and Y coordinate pair) representing the polyline
---
> 	 * @return List of Point type objects (that carry X and Y coordinate pair)
727a685,685
> 	 *         representing the polyline
743,743c701,701
< 			orthoPoint1 = segment.locatePoint(0.0, getImageMargin(), Sign.POSITIVE);
---
> 			orthoPoint1 = segment.locatePoint(0.0, getImageMargin(),
743a702,702
> 					Sign.POSITIVE);
745a705,705
> 					Sign.POSITIVE);
745,745c704,704
< 			orthoPoint2 = segment.locatePoint(1.0, getImageMargin(), Sign.POSITIVE);
---
> 			orthoPoint2 = segment.locatePoint(1.0, getImageMargin(),
763a724,724
> 		// requirements
763,763c723,723
< 		// add first point to close the polyline per "poly" area type HTML requirements
---
> 		// add first point to close the polyline per "poly" area type HTML
774,774c735,735
< 	 * @return List of Point type objects (that carry X and Y coordinate pair) representing the polyline
---
> 	 * @return List of Point type objects (that carry X and Y coordinate pair)
774a736,736
> 	 *         representing the polyline
792,792d753
< 	
794a756,756
> 	 *         image in logical coordinates.
794,794c755,755
< 	 * @return <code>int</code> value that is the margin around the generated image in logical coordinates.
---
> 	 * @return <code>int</code> value that is the margin around the generated
