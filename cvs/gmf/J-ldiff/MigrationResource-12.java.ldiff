8a9,9
>  * Contributors: 
9,9c10,10
<  * Contributors: Radek Dvorak (Borland) - initial API and implementation
---
>  *           Borland - initial API and implementation
15,15c16,16
< import java.util.HashMap;
---
> import java.util.Collection;
19,20d19
< import org.eclipse.emf.ecore.EClass;
< import org.eclipse.emf.ecore.EObject;
22,23d20
< import org.eclipse.emf.ecore.EReference;
< import org.eclipse.emf.ecore.EStructuralFeature;
31a29,29
> public abstract class MigrationResource extends ToolResource {
32,41d28
< /**
<  * This resource implementation is intended to handle loading of old (incompatible) versions 
<  * of tooling models.
<  * <p>
<  * This class makes use of {@link MigrationConfig.Registry#INSTANCE} end performs load-time migration 
<  * in case that there is a migration config registered for the resource to load.
<  * 
<  * @see MigrationConfig
<  */
< public class MigrationResource extends ToolResource {
42a31,31
> 	private boolean isOldVersionDetected;
43,46d30
< 	protected boolean oldVersionDetected;
< 	protected boolean migrationApplied;
< 	private Map<EObject, Map<String, String>> ignoredAttributes;
< 	private MigrationConfig config;
48,48c33,33
< 	MigrationResource(URI uri) {
---
> 	protected MigrationResource(URI uri) {
51a37,37
> 	@Override
52,73d36
< 	/*
< 	 * Create XMLLoad which handles old model migration at load-time 
< 	 * @see org.eclipse.emf.ecore.xmi.impl.XMIResourceImpl#createXMLLoad()
< 	 */
< 	protected XMLLoad createXMLLoad() {
< 		return new XMILoadImpl(createXMLHelper()) {
< 
< 			protected DefaultHandler makeDefaultHandler() {
< 				return new MigrationHandler(MigrationResource.this, helper, options);			
< 			}
< 		};
< 	}
< 
< 	protected final void doUnload() {
< 		try {
< 			super.doUnload();
< 		} finally {
< 			this.oldVersionDetected = false;
< 			this.migrationApplied = false;
< 		}
< 	}
< 
75a40,40
> 			isOldVersionDetected = false;
76,76d39
< 			ignoredAttributes = new HashMap<EObject, Map<String, String>>();
77a42,42
> 			handlePostLoadSuccess();
78,78d41
< 			handlePostLoad(null);			
80,80c44,44
< 			handlePostLoad(e);
---
> 			handlePostLoadException(e);
83,83c47,47
< 			handlePostLoad(e);
---
> 			handlePostLoadException(e);
85,95d48
< 		} finally {
< 			ignoredAttributes = null;
< 			config = null;
< 		}
< 	}
< 
< 	/**
< 	 * Called back if nsURI of old version is recognized during resource load.  
< 	 */
< 	protected void handleOldVersionDetected() {
< 		this.oldVersionDetected = true;
97,102d49
< 
< 	/**
< 	 * Called back at load-time in case an incompatible model construct required migration.  
< 	 */	
< 	protected void handleMigrationPatchApplied() {
< 		this.migrationApplied = true;
104a52,52
> 	@Override
105,126d51
< 	/**
< 	 * Called back after resource load finished.
< 	 * @param exception the exception thrown during {@link #doLoad(InputStream, Map)} or
< 	 * 		<code>null</code> in case of load success.
< 	 */
< 	protected void handlePostLoad(Exception exception) {
< 		if (exception == null && config != null) {
< 			config.handleResourceLoaded(this, ignoredAttributes);
< 		}
< 	}
< 
< 	/**
< 	 * Creates resource which checks for and reports incompatible model version
< 	 * in case that resource load fails.
< 	 * 
< 	 * @param uri the resource uri
< 	 * 
< 	 * @return resource object in unloaded state
< 	 */
< 	static Resource createCheckedResource(URI uri) {
< 		return new MigrationResource(uri) {
< 			
128,128d53
< 				final MigrationResource res = this;					
130,134d54
< 					protected DefaultHandler makeDefaultHandler() {
< 						return new BCKWDCompatibleHandler(res, helper, options);			
< 					}
< 				};
< 			}
135a56,64
> 			@Override
> 			protected DefaultHandler makeDefaultHandler() {
> 				return new SAXXMIHandler(resource, helper, options) {
> 					@Override
> 					protected EPackage getPackageForURI(String uriString) {
> 						// FIXME move the check to delegate
> 						if (!getMetamodelNsURI().equals(uriString) && getBackwardSupportedURIs().contains(uriString)) {
> 							handleOldVersionDetected();
> 							return super.getPackageForURI(getMetamodelNsURI());
136,143d55
< 			protected void handlePostLoad(Exception exception) {
< 				super.handlePostLoad(exception);
< 				// if old model version is loaded, check if any problems during resource load have occured
< 				// if yes, report an old version load attempt
< 				// otherwise, the resource happens to have no incompatible contents
< 				if(oldVersionDetected && exception != null || !getErrors().isEmpty() || !getWarnings().isEmpty()) {
< 					Diagnostic diagnostic = MigrationUtil.createMessageDiagnostic(this, Messages.oldModelVersionLoadErrorMigrationMayBeRequired);
< 					getErrors().add(0, diagnostic);
144a66,66
> 						return super.getPackageForURI(uriString);
148,164d69
< 	
< 	/**
< 	 * Creates resource which performs only in-memory migration of old model versions at load-time
< 	 * and reports migration diagnostic.
< 	 *  
< 	 * @param uri the resource uri 
< 	 * @return resource object in unloaded state
< 	 */	
< 	static Resource createCheckAndMigrateOnLoadResource(URI uri) {
< 		return new MigrationResource(uri) {
< 			protected void handlePostLoad(Exception exception) {
< 				super.handlePostLoad(exception);
< 				if(this.oldVersionDetected && migrationApplied) {
< 					Diagnostic diagnostic = MigrationUtil.createMessageDiagnostic(this, Messages.oldModelVersionLoadedMigrationRequired);
< 					getWarnings().add(0, diagnostic);
< 				}
< 			}
167a73,74
> 	private void handleOldVersionDetected() {
> 		isOldVersionDetected = true;
168,211d72
< 	/**
< 	 * Handles detection of loaded model nsURI and checks if an old model version is to be loaded.
< 	 */
< 	private static class BCKWDCompatibleHandler extends SAXXMIHandler {
< 		MigrationConfig config;
< 		protected boolean fixmePotentiallyCompatibilityIssues;
< 
< 		BCKWDCompatibleHandler(MigrationResource xmiResource, XMLHelper helper, Map<?, ?> options) {
< 			super(xmiResource, helper, options);
< 		}
< 
< 		/*
< 		 * Detects if and old version of model is to be loaded
< 		 */
< 		@Override		
< 		protected EPackage getPackageForURI(String uriString) {
< 			if(config == null) {
< 				// Remark: ensure that GMF meta-models generated packages are initialized before accessing 
< 				// 	MigrationConfig.Registry, as a migrated package initialization code performs the migration config 
< 				// 	registration.
< 				//	TODO - better to use extension point for migration config registry     
< 				EPackage.Registry.INSTANCE.getEPackage(uriString);
< 				
< 				String ext = xmlResource.getURI().fileExtension();
< 				config = (ext != null) ? MigrationConfig.Registry.INSTANCE.getConfig(ext) : null;
< 				resource().config = config;
< 			}
< 			
< 			if(config != null) {
< 				if(!config.getMetamodelNsURI().equals(uriString) && 
< 					config.backwardSupportedNsURIs().contains(uriString)) {					
< 					resource().handleOldVersionDetected();
< 					
< 					return super.getPackageForURI(config.getMetamodelNsURI());
< 				}
< 				if (config.getMetamodelNsURI().equals(uriString)) {
< 					// assume new version always needs migration, at least between milestones
< 					// FIXME better detection algorithm
< 					// FIXME delete this code after genmodel freeze in 2.0
< 					fixmePotentiallyCompatibilityIssues = true;
< 				}
< 			}
< 
< 			return super.getPackageForURI(uriString);
213a77,80
> 	protected void handlePostLoadSuccess() {
> 		if (isOldVersionDetected) {
> 			Diagnostic diagnostic = MigrationResource.createMessageDiagnostic(this, Messages.oldModelVersionLoadedMigrationRequired);
> 			getWarnings().add(0, diagnostic);
214,221d76
< 		@Override
< 		protected void handleUnknownFeature(String prefix, String name, boolean isElement, EObject peekObject, String value) {
< 			if (fixmePotentiallyCompatibilityIssues) {
< 				if (config.shouldIgnoreAttribute(peekObject, name)) {
< 					resource().handleOldVersionDetected();
< 				}
< 			}
< 			super.handleUnknownFeature(prefix, name, isElement, peekObject, value);
223,226d81
< 		
< 		MigrationResource resource() {
< 			assert xmlResource instanceof MigrationResource;
< 			return (MigrationResource)xmlResource;			
228,235d82
< 	};	
< 	
< 	/**
< 	 * Handler performing migration changes at load-time 
< 	 */
< 	public static class MigrationHandler extends BCKWDCompatibleHandler {
< 
< 		private FeatureKey processedFeatureKey;
236a84,86
> 	protected void handlePostLoadException(Exception e) {
> 		Diagnostic diagnostic = MigrationResource.createMessageDiagnostic(this, Messages.oldModelVersionLoadErrorMigrationMayBeRequired);
> 		getErrors().add(0, diagnostic);
237,239d83
< 		MigrationHandler(MigrationResource resource, XMLHelper helper, Map<?, ?> options) {
< 			super(resource, helper, options);
< 			this.processedFeatureKey = new FeatureKey();
242a90,93
> 	protected XMLHelper createXMLHelper() {
> 		MigrationHelperDelegate delegate = createDelegate();
> 		assert delegate != null;
> 		return new MigrationHelper(this, delegate);
243,263d89
< 		protected void setAttribValue(EObject object, String name, String value) {
< 			if ((isMigrationEnabled() || fixmePotentiallyCompatibilityIssues)) {
< 				if (config.setAttribValue(this, object, name, value)) {
< 					notifyMigrationApplied();
< 					return;
< 				}
< 				if (config.shouldIgnoreAttribute(object, name)) {
< 					Map<EObject, Map<String, String>> ignoredAttributes = resource().ignoredAttributes;
< 					if (ignoredAttributes != null) {
< 						Map<String, String> attrs = ignoredAttributes.get(object);
< 						if (attrs == null) {
< 							attrs = new HashMap<String, String>();
< 							ignoredAttributes.put(object, attrs);
< 						}
< 						attrs.put(name, value);
< 					}
< 					notifyMigrationApplied(); // notify we had to migrate
< 					return; // do not try to set value 
< 				}
< 			}
< 			super.setAttribValue(object, name, value);
265a96,98
> 	protected abstract Collection<String> getBackwardSupportedURIs();
> 	protected abstract MigrationHelperDelegate createDelegate();
> 	protected abstract String getMetamodelNsURI();
266,289d95
< 		@Override
< 		protected void createObject(EObject peekObject, EStructuralFeature feature) {
< 			if(isMigrationEnabled()) {
< 				if (config.handleCreateObject(this, peekObject, feature)) {
< 					notifyMigrationApplied();
< 					return;
< 				}
< 				processedFeatureKey.setFeature(feature);
< 				if(getXSIType() == null && feature instanceof EReference) { 			
< 					// adding xsi/xmi:type
< 					// @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=154712
< 					EClass oldDefaultRefType = (config != null) ? config.getAddedTypeInfo(processedFeatureKey) : null;
< 	
< 					if(oldDefaultRefType != null) {
< 						String typeQName = helper.getQName(oldDefaultRefType);
< 						super.createObjectFromTypeName(peekObject, typeQName, feature);
< 						// notify resource that a migration was neccessary 
< 						notifyMigrationApplied();
< 						return;
< 					}
< 				}
< 			} // end of migration
< 			super.createObject(peekObject, feature);								
< 		}
291,300d99
< 		@Override
< 		protected void handleFeature(String prefix, String name) {
< 			if (isMigrationEnabled()) {
< 				if (config.handleFeature(this, prefix, name)) {
< 					notifyMigrationApplied();
< 					return;
< 				}
< 			}
< 			super.handleFeature(prefix, name);
< 		}
302a102,106
> 	 * Creates resource diagnostic wrapping the given message.
> 	 * @param resource the resource associated with the created diagnostic
> 	 * @param message non-<code>null</code> message text to be wrapped as diagnostic
> 	 * 
> 	 * @return diagnostic object
303,303d101
< 		 * Make public for access from config.
304a108,110
> 	private static Diagnostic createMessageDiagnostic(Resource resource, final String message) {
> 		final String location = resource.getURI() == null ? null : resource.getURI().toString();
> 		return new Diagnostic(message, location);
305,306d107
< 		public EObject createObjectFromTypeNameHook(EObject peekObject, String typeQName, EStructuralFeature feature) {
< 			return super.createObjectFromTypeName(peekObject, typeQName, feature);
309a114,114
> 	 * Just a marker for diagnostic notification messages
310,310d113
< 		 * Make public for access from config.
311a116,122
> 	public static class Diagnostic implements Resource.Diagnostic {
> 		private final String myMessage;
> 		private final String myLocation;
> 
> 		Diagnostic(String message, String  location) {
> 			myMessage = message;
> 			myLocation = location;
312,313d115
< 		public void handleFeatureHook(String prefix, String name) {
< 			super.handleFeature(prefix, name);
315a125,126
> 		public String getMessage() {
> 			return myMessage;
316,320d124
< 		/**
< 		 * Make public for access from config.
< 		 */
< 		public String getXSIType() {
< 			return super.getXSIType();
322a129,130
> 		public String getLocation() {
> 			return myLocation;
323,327d128
< 		/**
< 		 * Make public for access from config.
< 		 */
< 		public EObject peekEObject() {
< 			return objects.peekEObject();
329a133,134
> 		public int getColumn() {
> 			return 0;
330,331d132
< 		private boolean isMigrationEnabled() {
< 			return config != null && resource().oldVersionDetected;
333a137,138
> 		public int getLine() {
> 			return 0;
334,342d136
< 		/**
< 		 * To be called if a migration patch had to be applied to load model successfully.
< 		 * <p>
< 		 * Note: It's important in order to detect whether an old model version which 
< 		 * was loaded contained incompatible constructs. No diagnostics are produced
< 		 * for old version models with compatible contents.
< 		 */
< 		private void notifyMigrationApplied() {
< 			resource().handleMigrationPatchApplied();
345,345d140
< 	
