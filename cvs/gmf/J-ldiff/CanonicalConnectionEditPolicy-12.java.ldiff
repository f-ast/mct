20a21,21
> import java.util.Set;
51a53,53
> import org.eclipse.gmf.runtime.notation.Node;
111,117d112
< 	/** Returns the diagram's connection views. */
< 	private List getDiagramConnections() {
< 		Diagram dView = ((View) host().getModel()).getDiagram();
< 		return dView == null ? Collections.EMPTY_LIST
< 			: new ArrayList(dView.getEdges());
< 	}
< 
600a596,596
> 	 * compartment. 
601,603d595
< 	 * compartment. Subclasses should override
< 	 * {@link #shouldIncludeConnection(Edge, List)} to modify the returned
< 	 * collection's contents.
605,605c598,598
< 	 * @return list of <code>IConnectionView</code>s.
---
> 	 * @return list of <code>Edge</code>s.
607a601,646
> 		Collection children = getViewChildren();
> 		Set connections = new HashSet();
> 		if (getHost() instanceof IGraphicalEditPart) {
> 			IGraphicalEditPart gep = (IGraphicalEditPart)getHost();
> 			Node node = (Node)gep.getNotationView();
> 			getConnectionViews(connections, node, children);
> 		}
> 		
> 		return connections;
> 	}
> 	
> 	/**
> 	 * Add all connections that are attached to the given node and any of it's
> 	 * children.
> 	 * 
> 	 * @param connections
> 	 * @param node
> 	 */
> 	private void getConnectionViews(Set connections, Node node, Collection viewChildren ) {
> 		IGraphicalEditPart gep = (IGraphicalEditPart)getHost();
> 		View hostView = gep.getNotationView();
> 		if (hostView != node) {
> 			if (!shouldCheckForConnections(node, viewChildren))
> 				return;
> 		}
> 		
> 		Iterator sourceIter = node.getSourceEdges().listIterator();
> 		while (sourceIter.hasNext()) {
> 			Edge sourceEdge = (Edge)sourceIter.next();
> 			if (shouldIncludeConnection(sourceEdge, (List)viewChildren))
> 				connections.add(sourceEdge);
> 		}
> 		
> 		Iterator targetIter = node.getTargetEdges().listIterator();
> 		while (targetIter.hasNext()) {
> 			Edge targetEdge = (Edge)targetIter.next();
> 			if (shouldIncludeConnection(targetEdge, (List)viewChildren))
> 				connections.add(targetEdge);
> 		}
> 		
> 		List children = node.getChildren();
> 		Iterator iter = children.listIterator();
> 		while (iter.hasNext()) {
> 			View viewChild = (View)iter.next();
> 			if (viewChild instanceof Node) {
> 				getConnectionViews(connections, (Node)viewChild, viewChildren );
608,615d600
< 		Collection retval = new HashSet();
< 		List children = getViewChildren();
< 		Iterator connections = getDiagramConnections().iterator();
< 		while (connections.hasNext()) {
< 			Edge connection = (Edge) connections.next();
< 			if (connection.getSource() != null && connection.getTarget() != null
< 				&& shouldIncludeConnection(connection, children)) {
< 				retval.add(connection);
617a649,665
> 	}
> 
> 	/**
> 	 * Determines if a given view should be checked to see if any attached connections should be considered
> 	 * by the canonical synchronization routine.  By default it will consider views that are 2 levels deep from the
> 	 * container in order to allow for connections that are attached to border items on children views in the 
> 	 * container.
> 	 * 
> 	 * @param view a <code>View</code> to check to see if attached connections should be considered.
> 	 * @param viewChildren a <code>Collection</code> of view children of the host notation view, that can be used
> 	 * as a context to determine if the given view's attached connections should be considered.
> 	 * @return a <code>boolean</code> <code>true</code> if connections on the view are used as part of the 
> 	 * canonical synchronization.  <code>false</code> if the view's attached connections are to be ignored.
> 	 */
> 	protected boolean shouldCheckForConnections(View view, Collection viewChildren) {
> 		return (view != null && 
> 			(viewChildren.contains(view) || viewChildren.contains(view.eContainer())));
618,618d648
< 		return retval;
639a687,713
> 	protected boolean shouldIncludeConnection(Edge connection, Collection children) {
> 		return shouldCheckForConnections(connection.getSource(), children) ||
> 				shouldCheckForConnections(connection.getTarget(), children);
> 	}
> 	
> 	/**
> 	 * Called by {@link #getConnectionViews()} to determine if the underlying
> 	 * shape compartment is responsible for the supplied connection. By default,
> 	 * the following conditition must be met for the connection to be accepted:
> 	 * <UL>
> 	 * <LI> its source must not be null.
> 	 * <LI> its target must not be null.
> 	 * <LI> the shape compartment contains the source (or the source's container
> 	 * view).
> 	 * <LI> the shape compartment contains the target (or the target's container
> 	 * view). </LI>
> 	 * 
> 	 * @param connection
> 	 *            the connection view
> 	 * @param children
> 	 *            underlying shape compartment's children.
> 	 * @return <tt>false</tt> if supplied connection should be ignored;
> 	 *         otherwise <tt>true</tt>.
> 	 * @deprecated clients should override {@link CanonicalConnectionEditPolicy#shouldIncludeConnection(Edge, Collection) instead
> 	 * 				deprecated on Dec 22nd / 2005
> 	 * 				to be deleted on Jan 30th / 2006
> 	 */
640a715,715
> 		return shouldIncludeConnection(connection, (Collection)children);
641,648d714
< 		View src = connection.getSource();
< 		View target = connection.getTarget();
< 		//
< 		// testing the src/tgt containerview in case the src/tgt are
< 		// some type of gate view.
< 		return ((src != null && target != null) && (children.contains(src)
< 			|| children.contains(src.eContainer()) || children.contains(target) || children
< 			.contains(target.eContainer())));
