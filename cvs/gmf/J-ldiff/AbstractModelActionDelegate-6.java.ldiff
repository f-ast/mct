14a15,15
> import org.eclipse.core.commands.operations.IUndoableOperation;
21,21d21
< import org.eclipse.emf.workspace.AbstractEMFOperation;
45a46,46
>  * @auther ldamus
82a84,87
>             // Run in a composite transactional operation so that subclasses can
> 			// both read and write to the model. Commands executed by subclasses
> 			// to modify the model will be appended to this composite
> 			// transactional operation.
83,90d83
<             // run in an EMF operation so that subclasses can both read and
<             // write to the model
<             AbstractEMFOperation operation = new AbstractEMFOperation(
<                 getEditingDomain(), getLabel()) {
< 
<                 protected IStatus doExecute(IProgressMonitor monitor,
<                         IAdaptable info)
<                     throws ExecutionException {
91a89,90
>         	Runnable runnable = new Runnable() {
> 				public void run() {
92a92,93
> 							.run(progressMonitor);
> 				}
92,92c91,91
<                     AbstractModelActionDelegate.super.run(progressMonitor);
---
> 					AbstractModelActionDelegate.super
93,94d91
<                     return getStatus();
<                 };
96a96,98
>         	WriteCommand write = new WriteCommand(getEditingDomain(),
> 					getLabel(), getActionManager().getOperationHistory(),
> 					runnable) {
96a103,104
> 			};
> 
97,98d102
<             try {
<                 getActionManager().getOperationHistory().execute(operation,
99,99c105,105
<                     new NullProgressMonitor(), null);
---
>             execute(write, new NullProgressMonitor(), null);
100a150,169
>     /**
> 	 * Convenience method for subclasses to execute an undoable operation on the
> 	 * action manager's operation history. Sets my status to the status of the
> 	 * operation execution, and returns that status.
> 	 * 
> 	 * @param operation
> 	 *            the operation to be executed
> 	 * @param progressMonitor
> 	 *            the progress monitor
> 	 * @param info
> 	 *            the adaptable info, may be <code>null</code>
> 	 * @return the status of the operation execution.
> 	 */
> 	protected IStatus execute(IUndoableOperation operation,
> 			IProgressMonitor progressMonitor, IAdaptable info) {
> 
> 		try {
> 			setStatus(getActionManager().getOperationHistory().execute(
> 					operation, progressMonitor, info));
> 
100a100,101
> 				public IStatus getStatus() {
> 					return AbstractModelActionDelegate.this.getStatus();
101,101c170,170
<             } catch (ExecutionException e) {
---
> 		} catch (ExecutionException e) {
101a171,171
> 			setStatus(new Status(Status.ERROR, MslUIPlugin.getPluginId(),
102,106d170
<                 Trace
<                     .catching(MslUIPlugin.getDefault(),
<                         MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
<                         "run", e); //$NON-NLS-1$
<                 Log.error(MslUIPlugin.getDefault(),
107a173,179
> 							.getLocalizedMessage(), e));
> 			Trace
> 					.catching(MslUIPlugin.getDefault(),
> 							MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
> 							"run", e); //$NON-NLS-1$
> 			Log.error(MslUIPlugin.getDefault(),
> 					MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
107,107c172,172
<                     MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
---
> 					MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
108,108c180,180
<                         .getLocalizedMessage(), e);
---
> 							.getLocalizedMessage(), e);
108a181,183
> 		}
> 		return getStatus();
> 	}
