head	1.7;
access;
symbols
	v20080813-1520:1.7
	v20080806-1520:1.7
	v20080731-1520:1.7
	v20080425-1959:1.6
	v20080322-0000:1.6
	v20080222-1200:1.6
	v20080215-1500:1.6
	v20080207-0207:1.6
	v20071214-1111:1.6
	v20071003-0000:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	v20070621-0000:1.6
	RC3_20:1.6
	v20070605-1400:1.6
	v20070601-1400:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.7
date	2008.05.19.21.52.25;	author atikhomirov;	state dead;
branches;
next	1.6;
commitid	1c2d4831f6984567;

1.6
date	2007.06.05.17.57.47;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	76fc4665a41a4567;

1.5
date	2007.06.05.12.59.15;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	58546655e234567;

1.4
date	2007.06.04.18.48.45;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	691f46645e8d4567;

1.3
date	2007.06.04.18.09.53;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	1c8c466455714567;

1.2
date	2007.05.29.13.41.35;	author ashatalin;	state Exp;
branches;
next	1.1;
commitid	1ed6465c2d8e4567;

1.1
date	2007.05.28.13.43.39;	author atikhomirov;	state Exp;
branches;
next	;
commitid	3ee9465adc8b4567;


desc
@@


1.7
log
@[232299] refactor migration utils: gmfgraph migration done usign dynamic package for old metamodel, unused logic from MigrationHelper and MigrationDelegate was removed
@
text
@/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors: Borland - initial API and implementation
 */
package org.eclipse.gmf.internal.graphdef.util;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.impl.ResourceImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.gmf.gmfgraph.ChildAccess;
import org.eclipse.gmf.gmfgraph.Compartment;
import org.eclipse.gmf.gmfgraph.CustomFigure;
import org.eclipse.gmf.gmfgraph.DiagramElement;
import org.eclipse.gmf.gmfgraph.DiagramLabel;
import org.eclipse.gmf.gmfgraph.Figure;
import org.eclipse.gmf.gmfgraph.FigureAccessor;
import org.eclipse.gmf.gmfgraph.FigureDescriptor;
import org.eclipse.gmf.gmfgraph.FigureGallery;
import org.eclipse.gmf.gmfgraph.GMFGraphFactory;
import org.eclipse.gmf.gmfgraph.GMFGraphPackage;
import org.eclipse.gmf.gmfgraph.RealFigure;
import org.eclipse.gmf.internal.common.migrate.MigrationDelegateImpl;

class MigrationDelegate extends MigrationDelegateImpl {
	private EReference myFigure_RefElements;
	private EAttribute myDiagramElement_RefFigure;
	
	private Map<String, EObject> myId2EObject;
	private Collection<EObject> myProxiesToResolve;
	private Map<DiagramElement, String> myDiagramElementReferencedFigure;
	private Map<DiagramElement, EObject> myDiagramElementReferencedProxyFigure;
	
	private Collection<EReference> myRemainedFigureReferences;
	private Map<FigureAccessor, ChildAccess> myAccessNeedsToBeSpecifiedLater;
	
	MigrationDelegate() {
	}

	void init() {
		final GMFGraphPackage graphDefPkg = GMFGraphPackage.eINSTANCE;
		// narrowing for reference FigureAccessor.typedFigure: (the only place where concrete CustomFigure was used)
		registerNarrowedAbstractType("RealFigure", graphDefPkg.getCustomFigure()); //$NON-NLS-1$
		
		registerDeletedAttributes(graphDefPkg.getCustomClass(), "bundleName"); //$NON-NLS-1$
		
		myFigure_RefElements = createNewReference("referencingElementsFake", graphDefPkg.getDiagramElement(), false); //$NON-NLS-1$
		registerTracedFeatureForHierarchy(graphDefPkg.getFigure(), "referencingElements", myFigure_RefElements); //$NON-NLS-1$
		registerTracedFeatureForHierarchy(graphDefPkg.getFigureAccessor(), "referencingElements", myFigure_RefElements); //$NON-NLS-1$
		
		// look, we have replaced FigureDescriptor-typed reference with plain EString attribute to take full control on resolving it later in postLoad:
		// but cross-resource references are going to be handled separately
		myDiagramElement_RefFigure = createNewAttribute("figure", EcorePackage.eINSTANCE.getEString(), false); //$NON-NLS-1$
		registerTracedAttributeForHierarchy(graphDefPkg.getDiagramElement(), "figure", myDiagramElement_RefFigure); //$NON-NLS-1$

		myRemainedFigureReferences = Arrays.asList(graphDefPkg.getFigureAccessor_TypedFigure(), graphDefPkg.getPolylineConnection_SourceDecoration(), graphDefPkg.getPolylineConnection_TargetDecoration());
		
		myId2EObject = null;
		myProxiesToResolve = null;
		myDiagramElementReferencedFigure = null;
	}

	private boolean isOneOfRemainedFigureReferences(EStructuralFeature feature) {
		return myRemainedFigureReferences.contains(feature);
	}

	@@Override
	public boolean setValue(EObject object, EStructuralFeature feature, Object value, int position) {
		// during load
		
		if (object instanceof Figure && "name".equals(feature.getName())) { //$NON-NLS-1$
			// this feature used to be ID in old versions, so need to emulate this during processing to
			// provide manual reference resolving later, in postLoad
			String name = (String) value;
			saveEObjectIdLocally(object, name);
		}
		if (GMFGraphPackage.eINSTANCE.getFigureAccessor_TypedFigure().equals(feature)) {
			if (value instanceof RealFigure) {
				RealFigure figure = (RealFigure) value;
				if (figure.eIsProxy()) {
					// this could happen due to generating resource with references using an older style
					// of hyperlink serialization, where it needs to be in separate element with
					// "href" attribute (controlled by option XMIResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE)
					saveReferenceToGetContainmentLater(figure);
					return false; // default processing is essential - it will set eContainer, which would be == "object",
					// and we'll use this fact later, when deaing with myProxiesToResolve
				} else if (value instanceof CustomFigure && figure.eContainer() != null) {
					// not a proxy and has container - copy right away
					CustomFigure custom = (CustomFigure) value;
					FigureAccessor accessor = (FigureAccessor) object;
					EObject container = custom.eContainer();
					if (!custom.eIsProxy() && container != null) {
						CustomFigure copy = (CustomFigure) EcoreUtil.copy(custom);
						accessor.setTypedFigure(copy);
						fireMigrationApplied(true);
						return true;
					} 
					// opposite case for proxy is going to be processed in preReserve(), here we let the proxy value to be set as always,
					// as well as ordinary containment value (we can recognize the case by null container yet)
				}
				// FALL-THROUGH (for check isOneOfRemainedFigureReferences && value instanceof FigureDescriptor)
			}
		}
		if (myDiagramElement_RefFigure.equals(feature) ) {
			// we are going to resolve figure references in postprocessing, ourselves, see postLoad()
			DiagramElement diagramElement = (DiagramElement) object;
			String figureRef = (String) value;
			saveDiagramElementReferencedFigure(diagramElement, figureRef);
			return true;
		}
		if (GMFGraphPackage.eINSTANCE.getDiagramElement_Figure().equals(feature) ) {
			// we are going to resolve figure references in postprocessing, ourselves, see postLoad()
			DiagramElement diagramElement = (DiagramElement) object;
			EObject figureRef = (EObject) value;
			if (figureRef.eIsProxy()) {
				saveDiagramElementReferencedProxy(diagramElement, figureRef);
				return true;
			}
		}
		
		// after end of document (between preResolve and postLoad calls), handling forward references:
		
		if (isOneOfRemainedFigureReferences(feature) && value instanceof FigureDescriptor) {
			// as in old version a name is used for id of referenced figure, and now we set this name
			// for its figure descriptor, if the figure is directly nested into it, - we could receive 
			// an instanceof descriptor resolved for this id value
			FigureDescriptor descriptor = (FigureDescriptor) value;
			Figure figure = descriptor.getActualFigure();
			fireMigrationApplied(true);
			// we call setValue again only for the case of handling containment reference, where we do not want
			// it to be removed from original descriptor, but just to be copied instead 
			if (!setValue(object, feature, figure, position)) {
				object.eSet(feature, figure);
				return true;
			}
		} 
		if (myFigure_RefElements.equals(feature)) {
			migrateFigureStructureToDescriptor((EObject) value, object);
		} else {
			// other cases are would be processed as defaults
			return super.setValue(object, feature, value, position);
		}
		return true;
	}

	private void migrateFigureStructureToDescriptor(EObject value, EObject object) {
		if (value.eIsProxy()) {
			// this will LOAD all referenced resources, and migrate them if necessary
			value = EcoreUtil.resolve(value, object);
		}
		DiagramElement node = (DiagramElement) value;
		if (object instanceof Figure) {
			Figure figure = (Figure) object; // can be FigureRef as well
			RealFigure topLevel = findTopLevelFigure(figure);
			setFigureToDiagramElement(node, figure, topLevel);
			fireMigrationApplied(true);
		} else if (object instanceof FigureAccessor) {
			FigureAccessor accessor = (FigureAccessor) object;
			Figure figure = accessor.getTypedFigure();
			RealFigure topLevel = findTopLevelFigure((Figure) accessor.eContainer());
			ChildAccess access = setFigureToDiagramElement(node, figure, topLevel);
			if (figure == null) {
				// it could happen that we have not processed our typedFigure reference yet!
				saveAccessNeedsToBeSpecifiedLater(accessor, access);
			}
			fireMigrationApplied(true);
		}
	}

	private void saveAccessNeedsToBeSpecifiedLater(FigureAccessor accessor, ChildAccess access) {
		if (myAccessNeedsToBeSpecifiedLater == null) {
			myAccessNeedsToBeSpecifiedLater = new HashMap<FigureAccessor, ChildAccess>();
		}
		myAccessNeedsToBeSpecifiedLater.put(accessor, access);
	}

	private ChildAccess setFigureToDiagramElement(DiagramElement node, Figure figure, RealFigure topLevel) {
		// figure can be null, in case of processing reference to FigureAccessor directly
		FigureDescriptor figureDescriptor = topLevel.getDescriptor();
		if (figureDescriptor == null) {
			figureDescriptor = getOrCreateFigureDescriptorFor(topLevel);
		}
		node.setFigure(figureDescriptor);
		if (!topLevel.equals(figure)) {
			ChildAccess access = getOrCreateChildAccessForNested(figure, figureDescriptor);
			setNestedFigureAccessFor(node, access);
			return access;
		}
		return null;
	}

	private void saveDiagramElementReferencedFigure(DiagramElement diagramElement, String figureRef) {
		if (myDiagramElementReferencedFigure == null) {
			myDiagramElementReferencedFigure = new HashMap<DiagramElement, String>();
		}
		if (figureRef != null && figureRef.length() != 0) {
			myDiagramElementReferencedFigure.put(diagramElement, figureRef);
		}
	}

	private void saveDiagramElementReferencedProxy(DiagramElement diagramElement, EObject figureRef) {
		if (myDiagramElementReferencedProxyFigure == null) {
			myDiagramElementReferencedProxyFigure = new HashMap<DiagramElement, EObject>();
		}
		if (figureRef != null && figureRef.eIsProxy()) {
			myDiagramElementReferencedProxyFigure.put(diagramElement, figureRef);
		}
	}

	@@Override
	public boolean setManyReference(EObject object, EStructuralFeature feature, Object[] values) {
		return myFigure_RefElements.equals(feature);
	}

	@@Override
	public void preResolve() {
		super.preResolve();
		Resource resource = getResource();
		// this is run BEFORE forward references handling 
		if (myId2EObject != null && resource instanceof ResourceImpl) {
			Map<String, EObject> idMappings = ((ResourceImpl)resource).getIntrinsicIDToEObjectMap();
			if (idMappings == null) {
				idMappings = new HashMap<String, EObject>();
				((ResourceImpl)resource).setIntrinsicIDToEObjectMap(idMappings);
			}
			for (Iterator<Map.Entry<String, EObject>> it = myId2EObject.entrySet().iterator(); it.hasNext();) {
				Map.Entry<String, EObject> next = it.next();
				String id = next.getKey();
				EObject found = resource.getEObject(id);
				if (found == null) {
					idMappings.put(id, next.getValue());
				} else {
					it.remove();//setValue(found);
				}
			}
			
		}
		if (myProxiesToResolve != null) {
			for (EObject proxy : myProxiesToResolve) {
				// these proxies are expected just to be references, used to be non-containment in the past,
				// and interpreted by loader as proxies because of having "href" attribute 
				String last = EcoreUtil.getURI(proxy).lastSegment();
				EObject saved = resource.getEObject(last);//myId2EObject.get(last);
				if (proxy.eContainer() instanceof FigureAccessor) {
					FigureAccessor accessor = (FigureAccessor) proxy.eContainer();
					// saved could be FigureDescriptor for migrated resources with proxy customFigure references
					if (saved instanceof RealFigure) {
						RealFigure copyOfResolved = (RealFigure) EcoreUtil.copy(saved);
						accessor.setTypedFigure(copyOfResolved);
					} else if (saved instanceof FigureDescriptor) {
						FigureDescriptor descriptor = (FigureDescriptor) saved;
						RealFigure copyOfResolved = (RealFigure) EcoreUtil.copy(descriptor.getActualFigure());
						accessor.setTypedFigure(copyOfResolved);
					}
				}
			}
			myProxiesToResolve.clear();
		}
	}
	
	@@Override
	public void postLoad() {
		super.postLoad();
		Resource resource = getResource();
		if (myAccessNeedsToBeSpecifiedLater != null) {
			for (FigureAccessor accessor : myAccessNeedsToBeSpecifiedLater.keySet()) {
				ChildAccess access = myAccessNeedsToBeSpecifiedLater.get(accessor);
				if (access != null && access.getFigure() == null) {
					RealFigure figure = getOrCreateTypedFigure(accessor);
					access.setFigure(figure);
				}
			}
			myAccessNeedsToBeSpecifiedLater.clear();
		}
		if (myDiagramElementReferencedFigure != null) {
			for (DiagramElement diagramElement : myDiagramElementReferencedFigure.keySet()) {
				if (diagramElement.getFigure() != null) {
					// this is the case of resolving this reference while processing forwardReference,
					// that existed in the same file
					continue;
				}
				// in the other case this reference either do not have a forward one (i.e. it
				// is a new file, and the reference points to an existing descriptor),
				// either we have a reference to a figure that had no forward reference
				// to ourselves, that was possible prior to GMF 1.0 RC2_10.
				String figureRef = myDiagramElementReferencedFigure.get(diagramElement);
				EObject referencedEObject = resource.getEObject(figureRef);
				setFigureDescriptorForDiagramElement(referencedEObject, diagramElement);
			}
			myDiagramElementReferencedFigure.clear();
		}
		if (myDiagramElementReferencedProxyFigure != null) {
			for (DiagramElement diagramElement : myDiagramElementReferencedProxyFigure.keySet()) {
				if (diagramElement.getFigure() != null && !diagramElement.getFigure().eIsProxy()) {
					// this is the case of resolving this reference while processing forwardReference,
					// that existed in the same file
					continue;
				}
				// It is the case either of cross-resource reference (and that other resource
				// can be either old or new one), either it is a kind of reference, produced
				// using an older style of hyperlink serialization, where it needs to be in separate element with
				// "href" attribute (controlled by option XMIResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE)
				EObject proxyFigure = myDiagramElementReferencedProxyFigure.get(diagramElement);
				URI proxyURI = EcoreUtil.getURI(proxyFigure);
				// this should LOAD all referenced resources, and migrate them if necessary
				Resource referencedResource = resource.getResourceSet().getResource(proxyURI.trimFragment(), false);
				if (referencedResource == null) {
					referencedResource = resource.getResourceSet().createResource(proxyURI.trimFragment());
				}
				// do not load the referenced resource, cause it may happen that it is loading us now
				if (!((ResourceImpl)referencedResource).isLoading()) {
					EObject referencedEObject = resource.getResourceSet().getEObject(proxyURI, true);
					if (diagramElement.getFigure() != null && !diagramElement.getFigure().eIsProxy()) {
						// referenced file is migrated, we got value during 'referencedElements' processing
						fireMigrationApplied(true);
						continue;
					}
					setFigureDescriptorForDiagramElement(referencedEObject, diagramElement);
				}
			}
			myDiagramElementReferencedProxyFigure.clear();
		}
		if (myId2EObject != null) {
			myId2EObject.clear();
		}
	}

	private void setFigureDescriptorForDiagramElement(EObject referencedEObject, DiagramElement diagramElement) {
		if (referencedEObject instanceof FigureDescriptor) {
			// this is newest properly structured metamodel reference
			diagramElement.setFigure((FigureDescriptor) referencedEObject);
		} else if (referencedEObject instanceof Figure) {
			// this could be the case of nested figure, that came for its name
			Figure figure = (Figure) referencedEObject;
			if (figure.getDescriptor() == null) {
				// Otherwise we have a reference to a figure that had no forward reference
				// to ourselves!! That was possible prior to GMF 1.0 RC2_10.
				// Should we initialize wrapping it with descriptor in such case?
				// Fortunately, FigureAccessor (with no ID attribute!) is introduced afterwards,
				// since GMF 1.0 I20060526_1200 build (prior to RC1_0, though).
				setValue(figure, myFigure_RefElements, diagramElement, 0);
				fireMigrationApplied(true);
			}
			FigureDescriptor descriptor = figure.getDescriptor();
			if (descriptor != null) {
				diagramElement.setFigure(descriptor);
			} else {
				// this message is going to be shown to the user, so there should be i18n
				throw new IllegalArgumentException(MessageFormat.format("Reference to the figure {0} could not be resolved to its descriptor for diagram element {1}", figure, diagramElement));
			}
		} else {
			// this message is going to be shown to the user, so there should be i18n
			throw new IllegalArgumentException(MessageFormat.format("Figure reference to {0} could not be resolved for {1}", referencedEObject, diagramElement));
		}
	}

	private void saveEObjectIdLocally(EObject object, String id) {
		if (myId2EObject == null) {
			myId2EObject = new HashMap<String, EObject>();
		}
		if (myId2EObject.get(id) == null) {
			myId2EObject.put(id, object);
		} else {
			// collision with figure name expected only in new versions, as old ones used this as id 
		}
	}

	private void saveReferenceToGetContainmentLater(EObject proxy) {
		if (myProxiesToResolve == null) {
			myProxiesToResolve = new ArrayList<EObject>();
		}
		myProxiesToResolve.add(proxy);
	}

	private RealFigure getOrCreateTypedFigure(FigureAccessor accessor) {
		RealFigure result = accessor.getTypedFigure();
		if (result == null) {
			CustomFigure custom = GMFGraphFactory.eINSTANCE.createCustomFigure();
			// @@see org.eclipse.gmf.codegen/templates/xpt/diagram/editparts/TextAware.xpt::labelSetterFigureClassName
			custom.setQualifiedClassName("org.eclipse.draw2d.IFigure"); //$NON-NLS-1$
			accessor.setTypedFigure(custom);
			result = custom;
		}
		return result;
	}

	private CustomFigure findParentCustomFigure(FigureAccessor accessor) {
		CustomFigure result = null;
		if (accessor.eContainer() instanceof CustomFigure) {
			result = (CustomFigure) accessor.eContainer();
		}
		return result;
	}

	private void setNestedFigureAccessFor(DiagramElement dElem, ChildAccess access) {
		if (dElem instanceof DiagramLabel) {
			DiagramLabel label = (DiagramLabel) dElem;
			label.setAccessor(access);
		} else if (dElem instanceof Compartment) {
			Compartment bag = (Compartment) dElem;
			bag.setAccessor(access);
		}
	}

	private RealFigure findTopLevelFigure(Figure figure) {
		RealFigure result =  figure instanceof RealFigure ? (RealFigure) figure : null;
		Object container = result.eContainer();
		while (container instanceof RealFigure || container instanceof FigureAccessor) {
			if (container instanceof FigureAccessor) {
				result = findParentCustomFigure((FigureAccessor) container);
			} else {
				result = (RealFigure) result.eContainer();
			}
			container = result.eContainer();
		} // now it should be the one contained within FigureGallery or FigureDescriptor
		return result;
	}

	private ChildAccess getOrCreateChildAccessForNested(Figure nestedFigure, FigureDescriptor toplevelDescriptor) {
		for (ChildAccess haveAccess : toplevelDescriptor.getAccessors()) {
			if (nestedFigure != null && nestedFigure.equals(haveAccess.getFigure())) {
				return haveAccess;
			}
		}
		ChildAccess result = GMFGraphFactory.eINSTANCE.createChildAccess();
		result.setFigure(nestedFigure);
		toplevelDescriptor.getAccessors().add(result);
		return result;
	}
	
	private FigureDescriptor getOrCreateFigureDescriptorFor(RealFigure toplevelFigure) {
		FigureDescriptor descriptor = toplevelFigure.getDescriptor();
		if (descriptor == null) {
			descriptor = GMFGraphFactory.eINSTANCE.createFigureDescriptor();
			if (toplevelFigure.getName() != null) {
				descriptor.setName(toplevelFigure.getName());
			}
			EObject container = toplevelFigure.eContainer();
			if (container instanceof FigureGallery) {
				FigureGallery gallery = (FigureGallery) container;
				gallery.getDescriptors().add(descriptor);
			}
			descriptor.setActualFigure(toplevelFigure);
		}
		return descriptor;
	}
}
@


1.6
log
@refactor; only values in FigureAccessor_typedFigure may have FigureAccessor as proxy's eContainer, hence narrowed if clause
@
text
@@


1.5
log
@[189703] akarjakina - migration for gmfgraph, handle graphdef split into few files
@
text
@d15 1
d60 1
d62 1
a62 1
		registerNarrowedAbstractType("RealFigure", GMFGraphPackage.eINSTANCE.getCustomFigure()); //$NON-NLS-1$
d64 1
a64 1
		registerDeletedAttributes(GMFGraphPackage.eINSTANCE.getCustomClass(), "bundleName"); //$NON-NLS-1$
d66 3
a68 3
		myFigure_RefElements = createNewReference("referencingElementsFake", GMFGraphPackage.eINSTANCE.getDiagramElement(), false); //$NON-NLS-1$
		registerTracedFeatureForHierarchy(GMFGraphPackage.eINSTANCE.getFigure(), "referencingElements", myFigure_RefElements); //$NON-NLS-1$
		registerTracedFeatureForHierarchy(GMFGraphPackage.eINSTANCE.getFigureAccessor(), "referencingElements", myFigure_RefElements); //$NON-NLS-1$
d73 3
a75 5
		registerTracedAttributeForHierarchy(GMFGraphPackage.eINSTANCE.getDiagramElement(), "figure", myDiagramElement_RefFigure); //$NON-NLS-1$
		
		registerRemainedReferenceToFigure(GMFGraphPackage.eINSTANCE.getFigureAccessor_TypedFigure());
		registerRemainedReferenceToFigure(GMFGraphPackage.eINSTANCE.getPolylineConnection_SourceDecoration());
		registerRemainedReferenceToFigure(GMFGraphPackage.eINSTANCE.getPolylineConnection_TargetDecoration());
a82 3
		if (myRemainedFigureReferences == null) {
			return false;
		}
a85 7
	private void registerRemainedReferenceToFigure(EReference reference) {
		if (myRemainedFigureReferences == null) {
			myRemainedFigureReferences = new ArrayList<EReference>();
		}
		myRemainedFigureReferences.add(reference);
	}

d90 1
a90 1
		if (object instanceof Figure && "name".equals(feature.getName())) {
d96 25
a120 7
		if (isOneOfRemainedFigureReferences(feature) && value instanceof RealFigure) {
			RealFigure figure = (RealFigure) value;
			if (figure.eIsProxy()) {
				// this could happen due to generating resource with references using an older style
				// of hyperlink serialization, where it needs to be in separate element with
				// "href" attribute (controlled by option XMIResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE)
				saveReferenceToGetContainmentLater(figure);
a155 13
		if (GMFGraphPackage.eINSTANCE.getFigureAccessor_TypedFigure().equals(feature) && value instanceof CustomFigure) {
			CustomFigure custom = (CustomFigure) value;
			FigureAccessor accessor = (FigureAccessor) object;
			EObject container = custom.eContainer();
			if (!custom.eIsProxy() && container != null) {
				CustomFigure copy = (CustomFigure) EcoreUtil.copy(custom);
				accessor.setTypedFigure(copy);
				fireMigrationApplied(true);
				return true;
			} 
			// opposite case for proxy is going to be processed in preReserve(), here we let the proxy value to be set as always,
			// as well as ordinary containment value (we can recognize the case by null container yet)
		} 
@


1.4
log
@potential npe fixed
@
text
@d20 1
d50 1
d69 1
d71 1
a71 1
		registerTracedFeatureForHierarchy(GMFGraphPackage.eINSTANCE.getDiagramElement(), "figure", myDiagramElement_RefFigure); //$NON-NLS-1$
d115 1
a115 1
		if (myDiagramElement_RefFigure.equals(feature)) {
d122 9
d161 16
a176 2
		if (myFigure_RefElements.equals(feature) && object instanceof Figure) {
			DiagramElement node = (DiagramElement) resolveValue((EObject) value, object);
d181 1
a181 2
		} else if (myFigure_RefElements.equals(feature) && object instanceof FigureAccessor) {
			DiagramElement node = (DiagramElement) resolveValue((EObject) value, object);
a190 3
		} else {
			// other cases are would be processed as defaults
			return super.setValue(object, feature, value, position);
a191 1
		return true;
a200 8
	private EObject resolveValue(EObject value, EObject object) {
		EObject result = value;
		if (result.eIsProxy()) {
			result = EcoreUtil.resolve(result, object);
		}
		return result;
	}

d225 9
a305 2
				// try to resolve this reference manually
				String figureRef = myDiagramElementReferencedFigure.get(diagramElement);
d308 3
a310 2
				// either it points to another old file, that should migrate and restructure
				// itself at the moment it meets forward reference to our diagram element.
d312 26
a337 11
				if (referencedEObject != null && referencedEObject.eIsProxy()) {
					// this should LOAD all referenced resources, and migrate them if necessary
					referencedEObject = EcoreUtil.resolve(referencedEObject, diagramElement);
					Resource referencedResource = referencedEObject.eResource();
					if (referencedResource != null && !referencedResource.equals(resource)) {
						// our tests check for migration warning and error absence only on the created resource, 
						// so temporarily collect them here:
						resource.getWarnings().addAll(referencedResource.getWarnings());
						resource.getErrors().addAll(referencedResource.getErrors());
					}
					if (diagramElement.getFigure() != null) {
d342 1
a342 26
				}
				if (referencedEObject instanceof FigureDescriptor) {
					// this is newest properly structured metamodel reference
					diagramElement.setFigure((FigureDescriptor) referencedEObject);
				} else if (referencedEObject instanceof Figure) {
					// this could be the case of nested figure, that came for its name
					Figure figure = (Figure) referencedEObject;
					if (figure.getDescriptor() == null) {
						// Otherwise we have a reference to a figure that had no forward reference
						// to ourselves!! That was possible prior to GMF 1.0 RC2_10.
						// Should we initialize wrapping it with descriptor in such case?
						// Fortunately, FigureAccessor (with no ID attribute!) is introduced afterwards,
						// since GMF 1.0 I20060526_1200 build (prior to RC1_0, though).
						setValue(figure, myFigure_RefElements, diagramElement, 0);
						fireMigrationApplied(true);
					}
					FigureDescriptor descriptor = figure.getDescriptor();
					if (descriptor != null) {
						diagramElement.setFigure(descriptor);
					} else {
						// this message is going to be shown to the user, so there should be i18n
						throw new IllegalArgumentException(MessageFormat.format("Reference to the figure {0} could not be resolved to its descriptor for diagram element {1}", figure, diagramElement));
					}
				} else {
					// this message is going to be shown to the user, so there should be i18n
					throw new IllegalArgumentException(MessageFormat.format("Figure reference to {0} could not be resolved for {1}", referencedEObject, diagramElement));
d345 1
a345 1
			myDiagramElementReferencedFigure.clear();
d347 1
a347 3
		Map<String, EObject> idMappings = ((ResourceImpl)resource).getIntrinsicIDToEObjectMap();
		if (idMappings != null && myId2EObject != null) {
			idMappings.keySet().removeAll(myId2EObject.keySet());
d352 29
@


1.3
log
@[189703] akarjakina - migration for gmfgraph, handle figure accessors
@
text
@d407 1
a407 1
			if (haveAccess.getFigure().equals(nestedFigure)) {
@


1.2
log
@akarjakina - migration support for recent gmfgraph changes
@
text
@d13 3
d17 1
d20 1
d24 1
d27 1
d30 1
d34 1
a38 1
import org.eclipse.gmf.gmfgraph.Node;
d44 1
d46 6
a51 1
	//private FigureGallery myDefaultCreatedFigureGallery;
d62 29
a90 2
		myFigure_RefElements = createNewReference("referencingElements", GMFGraphPackage.eINSTANCE.getDiagramElement(), false); //$NON-NLS-1$
		registerRenamedParentAttribute(GMFGraphPackage.eINSTANCE.getFigure(), "referencingElements", myFigure_RefElements); //$NON-NLS-1$
d95 56
a150 1
		if (myFigure_RefElements.equals(feature)) {
d153 11
a163 8
			FigureDescriptor figureDescriptor = getOrCreateFigureDescriptorFor(topLevel);
			if (figure instanceof RealFigure) { //XXX!!! think smth out!
				replaceFigureIdWithDescriptorIdInResolve(figureDescriptor, ((RealFigure) figure).getName());
			}
			if (!figure.equals(topLevel)) {
				ChildAccess access = getOrCreateChildAccessForNested(figure, figureDescriptor);
				DiagramElement node = (DiagramElement) value;
				setNestedFigureAccessFor(node, access);
d173 208
a384 3
		} else if (dElem instanceof Node) {
			Node node = (Node) dElem;
			node.setContentPane(access);
d391 8
a398 10
	private void replaceFigureIdWithDescriptorIdInResolve(EObject figure, String name) {
		//XXX: there is still problem with references for figures, when not only
		// figureDescriptors are needed. For ex., see PolylineConnection.targetDecoration
		Resource resource = getResource();
		if (resource instanceof ResourceImpl) {
			ResourceImpl resourceImpl = (ResourceImpl) resource;
			Map<String, EObject> idMap = resourceImpl.getIntrinsicIDToEObjectMap();
			if (idMap == null) {
				idMap = new HashMap<String, EObject>();
				resourceImpl.setIntrinsicIDToEObjectMap(idMap);
d400 2
a401 9
			idMap.put(name, figure);
		}
	}

	private RealFigure findTopLevelFigure(Figure figure) {
		RealFigure result = figure instanceof RealFigure ? (RealFigure) figure : null;
		while (result.eContainer() instanceof RealFigure) {
			result = (RealFigure) result.eContainer();
		} // contained within FigureGallery of FigureDescriptor
a432 13
	
//	private FigureGallery getOrCreateFigureGalleryOnce(Figure figure) {
//		if (myDefaultCreatedFigureGallery == null) {
//			myDefaultCreatedFigureGallery = GMFGraphFactory.eINSTANCE.createFigureGallery();
//			if (figure.eContainer() instanceof Canvas) {
//				Canvas canvas = (Canvas) figure.eContainer();
//				canvas.getFigures().add(myDefaultCreatedFigureGallery);
//			} else {
//				figure.eResource().getContents().add(myDefaultCreatedFigureGallery);
//			}
//		}
//		return myDefaultCreatedFigureGallery;
//	}
@


1.1
log
@migration support for recent gmfgraph changes
@
text
@a12 1
import java.util.Collection;
a15 1
import org.eclipse.emf.ecore.EAttribute;
a18 1
import org.eclipse.emf.ecore.EcorePackage;
a20 3
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.gmf.gmfgraph.Canvas;
a22 1
import org.eclipse.gmf.gmfgraph.Connection;
a34 1
	private EReference myDiagramElement_RefFigures;
d37 1
a37 5
	private EReference myNode_NodeFigureRef;
	private EReference myConnection_FigureRef;
	private EReference myDiagramLabel_NodeFigureRef;
	private EAttribute myFigureNameAttribute;
	private FigureGallery myDefaultCreatedFigureGallery;
a42 1
		
d44 1
a44 40
		registerNarrowedAbstractType("RealFigure", GMFGraphPackage.eINSTANCE.getCustomFigure());
		
		registerDeletedAttributes(GMFGraphPackage.eINSTANCE.getCustomClass(), "bundleName");
		registerDeletedAttributes(GMFGraphPackage.eINSTANCE.getDiagramLabel(), "resizeConstraint", "affixedParentSide");
		registerDeletedAttributes(GMFGraphPackage.eINSTANCE.getFigure(), "parent"); // not needed: readonly !resolve ref.
		
		myFigure_RefElements = createNewReference("referencingElements1", GMFGraphPackage.eINSTANCE.getDiagramElement(), false);
		registerRenamedParentAttribute(GMFGraphPackage.eINSTANCE.getFigure(), "referencingElements", myFigure_RefElements);
		
		myDiagramElement_RefFigures = createNewReference("figure1", GMFGraphPackage.eINSTANCE.getFigure(), false, 1, 1);
		registerRenamedParentAttribute(GMFGraphPackage.eINSTANCE.getDiagramElement(), "figure", myDiagramElement_RefFigures);
		
		//readonly derived transient volatile !resolve ref
		// in fact, DiagramLabel which extends Node breaks this constraint, just because DL SHOULD NOT extend Node, but rather some common AbstractNode superclass.
		myNode_NodeFigureRef = createNewReference("nodeFigure1", GMFGraphPackage.eINSTANCE.getFigure(), false);
		// move as content pane childAccess reference!
		{
			Map<String, EStructuralFeature> renamedAttributes = new HashMap<String, EStructuralFeature>();
			renamedAttributes.put("nodeFigure", myNode_NodeFigureRef);
			registerRenamedAttributes(GMFGraphPackage.eINSTANCE.getNode(), renamedAttributes);
		}
		
		//readonly derived transient volatile !resolve ref
		// doesn't follow Figure[1] nodeFigure from superclass Node because DL is not essentially Node
		myDiagramLabel_NodeFigureRef = createNewReference("nodeFigure2", GMFGraphPackage.eINSTANCE.getFigure(), false);
		// move as label, container childAccess references!
		{
			Map<String, EStructuralFeature> renamedAttributes = new HashMap<String, EStructuralFeature>();
			renamedAttributes.put("nodeFigure", myDiagramLabel_NodeFigureRef);
			registerRenamedAttributes(GMFGraphPackage.eINSTANCE.getDiagramLabel(), renamedAttributes);
		}
		
		//readonly derived transient volatile !resolve ref 
		myConnection_FigureRef = createNewReference("connectionFigure1", GMFGraphPackage.eINSTANCE.getFigure(), false);
		// this reference was removed!!!
		{
			Map<String, EStructuralFeature> renamedAttributes = new HashMap<String, EStructuralFeature>();
			renamedAttributes.put("connectionFigure", myConnection_FigureRef);
			registerRenamedAttributes(GMFGraphPackage.eINSTANCE.getConnection(), renamedAttributes);
		}
d46 1
a46 3
		myFigureNameAttribute = createNewAttribute("name1", EcorePackage.eINSTANCE.getEString(), false, true);
		//myFigureNameAttribute.setID(true);
		//registerRenamedParentAttribute(GMFGraphPackage.eINSTANCE.getFigure(), "name", myFigureNameAttribute);
d48 2
a49 1
		myDefaultCreatedFigureGallery = null;
d58 2
a59 3
			DiagramElement node = (DiagramElement) value;
			if (figure instanceof RealFigure) {
				saveIdentityNameAttributeForId(figureDescriptor, ((RealFigure) figure).getName());
a60 1
			setDiagramElementFigureDescriptorReference(node, figureDescriptor);
d62 3
a64 24
				saveChildAccess(figureDescriptor, figure);
			}
			fireMigrationApplied(true);
		} else if (myDiagramElement_RefFigures.equals(feature)) {
//			DiagramElement node = (DiagramElement) object;
//			Figure figure = (Figure) value; // can be FigureRef as well
//			RealFigure topLevel = findTopLevelFigure(figure);
//			FigureDescriptor figureDescriptor = getOrCreateFigureDescriptorFor(topLevel);
//			setDiagramElementFigureDescriptorReference(node, figureDescriptor);
//			if (!figure.equals(topLevel)) {
//				saveChildAccess(figureDescriptor, figure);
//			}
//			fireMigrationApplied(true);
		} else if (myNode_NodeFigureRef.equals(feature)) {
			Node node = (Node) object;
			Figure figure = (Figure) value; // should cast to FigureImpl actually!!
			RealFigure topLevel = findTopLevelFigure(figure);
			if (figure.equals(topLevel)) {
				System.out.println("[MigrationDelegate] setValue: unnecessary refinement for "+figure);
			} else {
				FigureDescriptor figureDescriptor = getOrCreateFigureDescriptorFor(topLevel);
				setDiagramElementFigureDescriptorReference(node, figureDescriptor);
				ChildAccess childAccess = saveChildAccess(figureDescriptor, figure);
				saveFigureAccessForContentPane(node, childAccess);
a66 32
//		} else if (myDiagramLabel_NodeFigureRef.equals(feature)) {
//			DiagramLabel label = (DiagramLabel) object;
//			Figure figure = (Figure) value; // should cast to FigureImpl actually!!
//			RealFigure topLevel = findTopLevelFigure(figure);
//			if (figure.equals(topLevel)) {
//				System.out.println("[MigrationDelegate] setValue: unnecessary refinement for "+figure);
//			} else {
//				FigureDescriptor figureDescriptor = getOrCreateFigureDescriptorFor(topLevel);
//				setDiagramElementFigureDescriptorReference(label, figureDescriptor);
//				ChildAccess childAccess = saveChildAccess(figureDescriptor, figure);
//				saveFigureAccessForLabel(label, childAccess);
//			}
//			fireMigrationApplied(true);
//		} else if (myConnection_FigureRef.equals(feature)) {
//			Connection connection = (Connection) object;
//			Figure figure = (Figure) value; // should cast to FigureImpl actually!!
//			RealFigure topLevel = findTopLevelFigure(figure);
//			if (figure.equals(topLevel)) {
//				System.out.println("[MigrationDelegate] setValue: unnecessary refinement for "+figure);
//			} else {
//				FigureDescriptor figureDescriptor = getOrCreateFigureDescriptorFor(topLevel);
//				setDiagramElementFigureDescriptorReference(connection, figureDescriptor);
//				ChildAccess childAccess = saveChildAccess(figureDescriptor, figure);
//				saveFigureAccessForConnection(connection, childAccess);
//			}
//			fireMigrationApplied(true);
		} else if (myFigureNameAttribute.equals(feature)) {
			Figure figure = (Figure) object;
			String name = (String) value;
			//saveIdentityNameAttributeForId(figure, name);
			//fireMigrationApplied(true);
			return super.setValue(object, feature, value, position);
d74 16
a89 1
	private void saveIdentityNameAttributeForId(EObject figure, String name) {
a99 18
		if (resource != null) {
			XMLResource xmlResource = (XMLResource) resource;
			resource.getEObject(name);
			String haveID = xmlResource.getID(figure);
			if (haveID == null || !haveID.equals(name)) {
				xmlResource.setID(figure, name);
			}
		}
	}

	private void setDiagramElementFigureDescriptorReference(DiagramElement node, FigureDescriptor figureDescriptor) {
		FigureDescriptor descriptor = node.getFigure();//getDiagramElementDescriptor().get(node);
		if (descriptor == null || descriptor.equals(figureDescriptor)) {
			//getDiagramElementDescriptor().put(node, figureDescriptor);
			node.setFigure(figureDescriptor);
		} else {
			System.out.println("[MigrationDelegate] setDiagramElementFigureDescriptorReference: double reference for: "+descriptor);
		}
d104 1
a104 1
		while (result.eContainer() instanceof RealFigure) { // FigureImpl, actually! (may be FigureGallery of null?)
d106 1
a106 1
		}
d110 4
a113 5
	private ChildAccess saveChildAccess(FigureDescriptor figureDescriptor, Figure figure) {
		ChildAccess access = null;
		for (ChildAccess haveAccess : figureDescriptor.getAccessors()) {
			if (haveAccess.getFigure().equals(figure)) {
				access = haveAccess;
d116 4
a119 6
		if (access == null) {
			access = GMFGraphFactory.eINSTANCE.createChildAccess();
			access.setFigure(figure);
			figureDescriptor.getAccessors().add(access);
		}
		return access;
a121 40
	private void saveNodeReference(DiagramElement node, ChildAccess figureAccess) {
		if (node instanceof DiagramLabel) {
			DiagramLabel label = (DiagramLabel) node;
			saveFigureAccessForLabel(label, figureAccess);
		} else if (node instanceof Node) {
			Node otherNode = (Node) node;
			saveFigureAccessForContentPane(otherNode, figureAccess);
		} else {
			System.out.println("[MigrationDelegate] saveNodeReference wrong figure referenced for connection and compartment!!!"+figureAccess);
		}
	}

	private void saveFigureAccessForContentPane(Node otherNode, ChildAccess figureAccess) {
//		if (myDiagramNodeContentPaneAccess == null) {
//			myDiagramNodeContentPaneAccess = new HashMap<Node, ChildAccess>();
//		}
		ChildAccess haveAccess = otherNode.getContentPane();//myDiagramNodeContentPaneAccess.get(otherNode);
		if (haveAccess != null && !haveAccess.equals(figureAccess)) {
			System.out.println("[MigrationDelegate] saveFigureAccessForContentPane(Node): collision between label figure references!!! "+haveAccess);
		}
		otherNode.setContentPane(figureAccess);
		//myDiagramNodeContentPaneAccess.put(otherNode, figureAccess);
	}

	private void saveFigureAccessForConnection(Connection connection, ChildAccess figureAccess) {
		System.out.println("Collision!!! [MigrationDelegate] saveFigureAccessForContentPane: "+connection);
	}

	private void saveFigureAccessForCompartment(Compartment compartment, ChildAccess figureAccess) {
		System.out.println("Collision!!! [MigrationDelegate] saveFigureAccessForContentPane: "+compartment);
	}

	private void saveFigureAccessForLabel(DiagramLabel label, ChildAccess figureAccess) {
		ChildAccess haveAccess = label.getAccessor();//myDiagramLabelFigureAccess.get(label);
		if (haveAccess != null && !haveAccess.equals(figureAccess)) {
			System.out.println("[MigrationDelegate] saveFigureAccessForLabel: collision between label figure references!!! "+haveAccess);
		}
		label.setAccessor(figureAccess);
	}

a127 1
				saveIdentityNameAttributeForId(descriptor, toplevelFigure.getName());
d139 12
a150 19
	@@Override
	public void postProcess() {
		super.postProcess();
		// unfortunately, will be called BEFORE processing resolved id references!!!
	}
	
	private FigureGallery getOrCreateFigureGalleryOnce(Figure figure) {
		if (myDefaultCreatedFigureGallery == null) {
			myDefaultCreatedFigureGallery = GMFGraphFactory.eINSTANCE.createFigureGallery();
			if (figure.eContainer() instanceof Canvas) {
				Canvas canvas = (Canvas) figure.eContainer();
				canvas.getFigures().add(myDefaultCreatedFigureGallery);
			} else {
				figure.eResource().getContents().add(myDefaultCreatedFigureGallery);
			}
		}
		return myDefaultCreatedFigureGallery;
	}

@

