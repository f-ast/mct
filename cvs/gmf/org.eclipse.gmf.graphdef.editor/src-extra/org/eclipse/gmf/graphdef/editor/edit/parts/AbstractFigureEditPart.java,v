head	1.13;
access;
symbols
	v20080722-1827:1.13
	v20080718-1700:1.12
	v20080718-1731:1.13
	v20080716-1642:1.13
	R2_1_maintenance:1.12.0.2
	Root_R2_1_maintenance:1.12
	R2_1_0:1.12
	v20080610-1132:1.12
	v20080603-1553:1.12
	v20080528-1052:1.12
	v20080521:1.9
	v20080516-1143:1.8
	v20080512-1200:1.6
	v20080510-0100:1.5
	v20080507-1326:1.5
	v20080501-1739:1.5
	v20080425-1959:1.5
	v20080411-0411:1.5
	v20080404-1111:1.5
	v20080322-0000:1.5
	v20080114-2222:1.3
	v20071214-1111:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	v20070621-0000:1.3
	RC3_20:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070520-1200:1.2
	v20070420-1000:1.2
	v20070405-2000:1.1
	v20070405-1100:1.1
	v20070330-1300:1.1
	v20070307-0700:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.13
date	2008.07.02.15.20.47;	author ashatalin;	state Exp;
branches;
next	1.12;
commitid	703486b9cc54567;

1.12
date	2008.05.27.12.28.09;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	68fd483bfe544567;

1.11
date	2008.05.22.12.18.01;	author ashatalin;	state Exp;
branches;
next	1.10;
commitid	969483564774567;

1.10
date	2008.05.21.12.32.01;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	7b0e483416414567;

1.9
date	2008.05.19.16.33.11;	author ashatalin;	state Exp;
branches;
next	1.8;
commitid	77734831abc34567;

1.8
date	2008.05.14.17.23.29;	author ashatalin;	state Exp;
branches;
next	1.7;
commitid	412b482b200e4567;

1.7
date	2008.05.14.11.51.15;	author ashatalin;	state Exp;
branches;
next	1.6;
commitid	4a5e482ad2334567;

1.6
date	2008.05.12.17.40.17;	author ashatalin;	state Exp;
branches;
next	1.5;
commitid	a53482880fd4567;

1.5
date	2008.03.13.11.22.34;	author ashatalin;	state Exp;
branches;
next	1.4;
commitid	4ae847d90e794567;

1.4
date	2008.03.11.18.24.44;	author ashatalin;	state Exp;
branches;
next	1.3;
commitid	7ac947d6ce6c4567;

1.3
date	2007.05.31.15.52.31;	author ashatalin;	state Exp;
branches;
next	1.2;
commitid	49f1465eef2c4567;

1.2
date	2007.04.16.11.03.53;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	7e4e462358154567;

1.1
date	2007.03.02.18.36.49;	author atikhomirov;	state Exp;
branches;
next	;
commitid	1b3945e86ec04567;


desc
@@


1.13
log
@[233207] - Support Label figure in .gmfgraph editor
@
text
@/**
 * Copyright (c) 2006, 2007 Borland Software Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Borland Software Corporation - initial API and implementation
 */
package org.eclipse.gmf.graphdef.editor.edit.parts;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.GridData;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.LayoutManager;
import org.eclipse.draw2d.ToolbarLayout;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.DragTracker;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.tools.AbstractTool;
import org.eclipse.gmf.gmfgraph.Alignment;
import org.eclipse.gmf.gmfgraph.BasicFont;
import org.eclipse.gmf.gmfgraph.BorderLayout;
import org.eclipse.gmf.gmfgraph.BorderLayoutData;
import org.eclipse.gmf.gmfgraph.Color;
import org.eclipse.gmf.gmfgraph.ConstantColor;
import org.eclipse.gmf.gmfgraph.Dimension;
import org.eclipse.gmf.gmfgraph.FlowLayout;
import org.eclipse.gmf.gmfgraph.Font;
import org.eclipse.gmf.gmfgraph.GMFGraphPackage;
import org.eclipse.gmf.gmfgraph.GridLayout;
import org.eclipse.gmf.gmfgraph.GridLayoutData;
import org.eclipse.gmf.gmfgraph.Layout;
import org.eclipse.gmf.gmfgraph.LayoutData;
import org.eclipse.gmf.gmfgraph.LineKind;
import org.eclipse.gmf.gmfgraph.Point;
import org.eclipse.gmf.gmfgraph.RGBColor;
import org.eclipse.gmf.gmfgraph.RealFigure;
import org.eclipse.gmf.gmfgraph.StackLayout;
import org.eclipse.gmf.gmfgraph.XYLayout;
import org.eclipse.gmf.gmfgraph.XYLayoutData;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeNodeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectionHandleEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;
import org.eclipse.gmf.runtime.diagram.ui.handles.ConnectionHandle;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramColorRegistry;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.resource.FontDescriptor;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.swt.graphics.RGB;

public abstract class AbstractFigureEditPart extends ShapeNodeEditPart {

	public static final String EMPTY_STRING = ""; //$NON-NLS-1$

	private static Integer getGridDataAlignment(Alignment alignment) {
		switch (alignment.getValue()) {
		case Alignment.BEGINNING:
			return GridData.BEGINNING;
		case Alignment.END:
			return GridData.END;
		case Alignment.CENTER:
			return GridData.CENTER;
		case Alignment.FILL:
			return GridData.FILL;
		}
		return null;
	}

	private static int getFlowLayoutAllignment(Alignment alignment, boolean isToolbar) {
		switch (alignment.getValue()) {
		case Alignment.BEGINNING:
			return isToolbar ? ToolbarLayout.ALIGN_TOPLEFT : org.eclipse.draw2d.FlowLayout.ALIGN_LEFTTOP;
		case Alignment.END:
			return isToolbar ? ToolbarLayout.ALIGN_BOTTOMRIGHT : org.eclipse.draw2d.FlowLayout.ALIGN_RIGHTBOTTOM;
		}
		return isToolbar ? ToolbarLayout.ALIGN_CENTER : org.eclipse.draw2d.FlowLayout.ALIGN_CENTER;
	}

	protected static int getLineStyle(LineKind lineKind) {
		switch (lineKind.getValue()) {
		case LineKind.LINE_DASH: {
			return Graphics.LINE_DASH;
		}
		case LineKind.LINE_DOT: {
			return Graphics.LINE_DOT;
		}
		case LineKind.LINE_DASHDOT: {
			return Graphics.LINE_DASHDOT;
		}
		case LineKind.LINE_DASHDOTDOT: {
			return Graphics.LINE_DASHDOTDOT;
		}
		case LineKind.LINE_CUSTOM: {
			return Graphics.LINE_CUSTOM;
		}
		default: {
			return Graphics.LINE_SOLID;
		}
		}
	}

	protected static org.eclipse.swt.graphics.Color getColor(Color modelColor) {
		if (modelColor instanceof ConstantColor) {
			ConstantColor constantColor = (ConstantColor) modelColor;
			switch (constantColor.getValue()) {
			case BLACK_LITERAL:
				return org.eclipse.draw2d.ColorConstants.black;
			case BLUE_LITERAL:
				return org.eclipse.draw2d.ColorConstants.blue;
			case CYAN_LITERAL:
				return org.eclipse.draw2d.ColorConstants.cyan;
			case DARK_BLUE_LITERAL:
				return org.eclipse.draw2d.ColorConstants.darkBlue;
			case DARK_GRAY_LITERAL:
				return org.eclipse.draw2d.ColorConstants.darkGray;
			case DARK_GREEN_LITERAL:
				return org.eclipse.draw2d.ColorConstants.darkGreen;
			case GRAY_LITERAL:
				return org.eclipse.draw2d.ColorConstants.gray;
			case GREEN_LITERAL:
				return org.eclipse.draw2d.ColorConstants.green;
			case LIGHT_BLUE_LITERAL:
				return org.eclipse.draw2d.ColorConstants.lightBlue;
			case LIGHT_GRAY_LITERAL:
				return org.eclipse.draw2d.ColorConstants.lightGray;
			case LIGHT_GREEN_LITERAL:
				return org.eclipse.draw2d.ColorConstants.lightGreen;
			case ORANGE_LITERAL:
				return org.eclipse.draw2d.ColorConstants.orange;
			case RED_LITERAL:
				return org.eclipse.draw2d.ColorConstants.red;
			case WHITE_LITERAL:
				return org.eclipse.draw2d.ColorConstants.white;
			case YELLOW_LITERAL:
				return org.eclipse.draw2d.ColorConstants.yellow;
			}
		} else if (modelColor instanceof RGBColor) {
			RGBColor rgbColor = (RGBColor) modelColor;
			return DiagramColorRegistry.getInstance().getColor(new RGB(rgbColor.getRed(), rgbColor.getGreen(), rgbColor.getBlue()));
		}
		return null;
	}

	private FontData myCachedFontData;

	public AbstractFigureEditPart(View view) {
		super(view);
	}

	private Object getLayoutConstraint() {
		RealFigure realFigure = getRealFigure();
		if (realFigure == null || realFigure.getLayoutData() == null) {
			return null;
		}
		LayoutData layoutData = realFigure.getLayoutData();
		switch (layoutData.eClass().getClassifierID()) {
		case GMFGraphPackage.BORDER_LAYOUT_DATA: {
			BorderLayoutData borderLayoutData = (BorderLayoutData) layoutData;
			if (borderLayoutData.getAlignment() != null) {
				switch (borderLayoutData.getAlignment().getValue()) {
				case Alignment.CENTER:
				case Alignment.FILL: {
					return org.eclipse.draw2d.BorderLayout.CENTER;
				}
				case Alignment.BEGINNING: {
					return borderLayoutData.isVertical() ? org.eclipse.draw2d.BorderLayout.TOP : org.eclipse.draw2d.BorderLayout.LEFT;
				}
				case Alignment.END: {
					return borderLayoutData.isVertical() ? org.eclipse.draw2d.BorderLayout.BOTTOM : org.eclipse.draw2d.BorderLayout.RIGHT;
				}
				}
			}
			break;
		}
		case GMFGraphPackage.CUSTOM_LAYOUT_DATA: {
			// TODO: implement custom layout
			break;
		}
		case GMFGraphPackage.GRID_LAYOUT_DATA: {
			GridLayoutData gridLayoutData = (GridLayoutData) layoutData;
			GridData result = new GridData();
			result.grabExcessHorizontalSpace = gridLayoutData.isGrabExcessHorizontalSpace();
			result.grabExcessVerticalSpace = gridLayoutData.isGrabExcessVerticalSpace();
			Integer alignment = getGridDataAlignment(gridLayoutData.getHorizontalAlignment());
			if (alignment != null) {
				result.horizontalAlignment = alignment;
			}
			alignment = getGridDataAlignment(gridLayoutData.getVerticalAlignment());
			if (alignment != null) {
				result.verticalAlignment = alignment;
			}
			result.verticalSpan = gridLayoutData.getVerticalSpan();
			result.horizontalSpan = gridLayoutData.getHorizontalSpan();
			result.horizontalIndent = getMapMode().DPtoLP(gridLayoutData.getHorizontalIndent());
			if (gridLayoutData.getSizeHint() != null) {
				result.widthHint = getMapMode().DPtoLP(gridLayoutData.getSizeHint().getDx());
				result.heightHint = getMapMode().DPtoLP(gridLayoutData.getSizeHint().getDy());
			} else {
				result.widthHint = SWT.DEFAULT;
				result.heightHint = SWT.DEFAULT;
			}
			return result;
		}
		case GMFGraphPackage.XY_LAYOUT_DATA: {
			final XYLayoutData xyLayoutData = (XYLayoutData) layoutData;
			Rectangle result = new Rectangle();
			if (xyLayoutData.getTopLeft() != null && xyLayoutData.getSize() != null) {
				result.setLocation(getMapMode().DPtoLP(xyLayoutData.getTopLeft().getX()), getMapMode().DPtoLP(xyLayoutData.getTopLeft().getY()));
				result.setSize(getMapMode().DPtoLP(xyLayoutData.getSize().getDx()), getMapMode().DPtoLP(xyLayoutData.getSize().getDy()));
			}
			return result;
		}
		}
		return null;
	}

	protected void addChildVisual(EditPart childEditPart, int index) {
		IFigure child = ((GraphicalEditPart) childEditPart).getFigure();
		Object layoutConstraint = null;
		if (childEditPart instanceof AbstractFigureEditPart) {
			layoutConstraint = ((AbstractFigureEditPart) childEditPart).getLayoutConstraint();
		} else if (childEditPart instanceof AbstractPointEditPart) {
			layoutConstraint = ((AbstractPointEditPart) childEditPart).getLayoutConstraint();
		}
		LayoutManager layoutManager = getContentPane().getLayoutManager();
		if (layoutManager instanceof org.eclipse.draw2d.BorderLayout) {
			if (org.eclipse.draw2d.BorderLayout.BOTTOM != layoutConstraint && org.eclipse.draw2d.BorderLayout.CENTER != layoutConstraint && org.eclipse.draw2d.BorderLayout.LEFT != layoutConstraint
					&& org.eclipse.draw2d.BorderLayout.RIGHT != layoutConstraint && org.eclipse.draw2d.BorderLayout.TOP != layoutConstraint) {
				// TODO: put figure into special pain with unconstrained
				// elements instead
				layoutConstraint = null;
			}
		} else if (layoutManager instanceof GridLayout) {
			if (false == layoutConstraint instanceof GridData) {
				layoutConstraint = null;
			}
		} else if (layoutManager instanceof org.eclipse.draw2d.XYLayout) {
			if (false == layoutConstraint instanceof Rectangle) {
				// TODO: put figure into special pain with unconstrained
				// elements instead
				layoutConstraint = null;
			}
		}
		getContentPane().add(child, layoutConstraint, index);
	}

	protected LayoutManager getLayoutManager(Layout layout) {
		if (layout instanceof BorderLayout) {
			BorderLayout borderLayout = (BorderLayout) layout;
			org.eclipse.draw2d.BorderLayout layoutManager = new org.eclipse.draw2d.BorderLayout();
			if (borderLayout.getSpacing() != null) {
				layoutManager.setHorizontalSpacing(getMapMode().DPtoLP(borderLayout.getSpacing().getDx()));
				layoutManager.setVerticalSpacing(getMapMode().DPtoLP(borderLayout.getSpacing().getDy()));
			}
			return layoutManager;
		}

		if (layout instanceof FlowLayout) {
			FlowLayout flowLayout = (FlowLayout) layout;
			if (flowLayout.isForceSingleLine()) {
				ToolbarLayout layoutManager = new ToolbarLayout();
				layoutManager.setStretchMinorAxis(flowLayout.isMatchMinorSize());
				layoutManager.setMinorAlignment(getFlowLayoutAllignment(flowLayout.getMinorAlignment(), flowLayout.isForceSingleLine()));
				layoutManager.setSpacing(flowLayout.getMajorSpacing());
				layoutManager.setVertical(flowLayout.isVertical());
				return layoutManager;
			} else {
				org.eclipse.draw2d.FlowLayout layoutManager = new org.eclipse.draw2d.FlowLayout();
				layoutManager.setStretchMinorAxis(flowLayout.isMatchMinorSize());
				layoutManager.setMinorAlignment(getFlowLayoutAllignment(flowLayout.getMinorAlignment(), flowLayout.isForceSingleLine()));
				layoutManager.setMajorAlignment(getFlowLayoutAllignment(flowLayout.getMajorAlignment(), flowLayout.isForceSingleLine()));
				layoutManager.setMajorSpacing(flowLayout.getMajorSpacing());
				layoutManager.setMinorSpacing(flowLayout.getMinorSpacing());
				layoutManager.setHorizontal(!flowLayout.isVertical());
				return layoutManager;
			}
		}

		if (layout instanceof GridLayout) {
			GridLayout gridLayout = (GridLayout) layout;
			org.eclipse.draw2d.GridLayout layoutManager = new org.eclipse.draw2d.GridLayout();
			layoutManager.numColumns = gridLayout.getNumColumns();
			layoutManager.makeColumnsEqualWidth = gridLayout.isEqualWidth();
			if (gridLayout.getMargins() != null) {
				layoutManager.marginWidth = getMapMode().DPtoLP(gridLayout.getMargins().getDx());
				layoutManager.marginHeight = getMapMode().DPtoLP(gridLayout.getMargins().getDy());
			} else {
				int defaultMargin = 5;
				layoutManager.marginWidth = getMapMode().DPtoLP(defaultMargin);
				layoutManager.marginHeight = getMapMode().DPtoLP(defaultMargin);
			}
			if (gridLayout.getSpacing() != null) {
				layoutManager.horizontalSpacing = getMapMode().DPtoLP(gridLayout.getSpacing().getDx());
				layoutManager.verticalSpacing = getMapMode().DPtoLP(gridLayout.getSpacing().getDy());
			} else {
				int defaultSpacing = 5;
				layoutManager.horizontalSpacing = getMapMode().DPtoLP(defaultSpacing);
				layoutManager.verticalSpacing = getMapMode().DPtoLP(defaultSpacing);
			}
			return layoutManager;
		}

		if (layout instanceof StackLayout) {
			return new org.eclipse.draw2d.StackLayout();
		}

		if (layout instanceof XYLayout) {
			return new org.eclipse.draw2d.XYLayout();
		}

		return null;
	}

	protected org.eclipse.draw2d.geometry.Dimension getCornerDimensions(int width, int height) {
		return new org.eclipse.draw2d.geometry.Dimension(getMapMode().DPtoLP(width), getMapMode().DPtoLP(height));
	}

	protected PointList getPointList(List<Point> template) {
		PointList result = new PointList();
		for (Point point : template) {
			result.addPoint(new org.eclipse.draw2d.geometry.Point(getMapMode().DPtoLP(point.getX()), getMapMode().DPtoLP(point.getY())));	
		}
		return result;
	}

	protected org.eclipse.draw2d.geometry.Dimension getDraw2dDimension(Dimension dimension) {
		return new org.eclipse.draw2d.geometry.Dimension(getMapMode().DPtoLP(dimension.getDx()), getMapMode().DPtoLP(dimension.getDy()));
	}

	protected org.eclipse.draw2d.geometry.Point getDraw2DPoint(Point point) {
		return new org.eclipse.draw2d.geometry.Point(getMapMode().DPtoLP(point.getX()), getMapMode().DPtoLP(point.getY()));
	}

	protected void refreshLayoutData() {
		if (!hasParentFigure()) {
			return;
		}
		Object layoutConstraint = getLayoutConstraint();
		if (layoutConstraint != null) {
			getFigure().getParent().setConstraint(getFigure(), layoutConstraint);
		}
		/*
		 *  It is important to call handleMajorSemanticChange() here because
		 *  in case of any changes in LayoutConstraints current EditPart can 
		 *  visually replace any other existing (sibling) EditParts, so we 
		 *  have to re-layout parent Figure.
		 */
		if (getParent() instanceof AbstractFigureEditPart) {
			((AbstractFigureEditPart) getParent()).handleMajorSemanticChange();	
		}
	}

	/**
	 * Parent figure == null if this method was called from setFigure() one.
	 */
	private boolean hasParentFigure() {
		return getFigure().getParent() != null;
	}

	protected void refreshLayoutManager() {
		if (!hasParentFigure()) {
			return;
		}
		handleMajorSemanticChange();
	}

	protected RealFigure getRealFigure() {
		View view = getNotationView();
		if (view != null && view.getElement() instanceof RealFigure) {
			return (RealFigure) view.getElement();
		}
		return null;
	}

	/**
	 * Using this custom implementation instead of calling super.setFont()
	 * because we have to support unsetting font operation (setFont(null)).
	 * 
	 * TODO: getNodeFigure used here instead of getPrimaryShape() - better 
	 * use getPrimaryShape().
	 */
	protected void refreshFont() {
		Font modelFont = getRealFigure().getFont();
		if (modelFont instanceof BasicFont) {
			BasicFont basicFont = (BasicFont) modelFont;
			int fontStyle = SWT.NONE;
			switch (basicFont.getStyle()) {
			case BOLD_LITERAL:
				fontStyle = SWT.BOLD;
				break;
			case ITALIC_LITERAL:
				fontStyle = SWT.ITALIC;
				break;
			}
			if (basicFont.getFaceName() == null) {
				return;
			}
			FontData fontData = new FontData(basicFont.getFaceName(), basicFont.getHeight(), fontStyle);
			if (myCachedFontData != null && myCachedFontData.equals(fontData)) {
				return;
			}
			org.eclipse.swt.graphics.Font font = getResourceManager().createFont(FontDescriptor.createFrom(fontData));
			getNodeFigure().setFont(font);
			getNodeFigure().repaint();
			if (myCachedFontData != null) {
				getResourceManager().destroyFont(FontDescriptor.createFrom(myCachedFontData));
			}
		} else {
			getNodeFigure().setFont(null);
			getNodeFigure().repaint();
		}
	}

	protected void createDefaultEditPolicies() {
		super.createDefaultEditPolicies();

		// override default connection handles behavior, that could be installed
		// by parent
		installEditPolicy(EditPolicyRoles.CONNECTION_HANDLES_ROLE, new MyConnectionHandleEditPolicy());
	}

	private static class MyConnectionHandleEditPolicy extends ConnectionHandleEditPolicy {

		protected List getHandleFigures() {
			IGraphicalEditPart selectedPart = (IGraphicalEditPart) getHost();
			List result = new ArrayList(selectedPart.getChildren().size());
			for (int i = 0; i < selectedPart.getChildren().size(); i++) {
				final EditPart next = (EditPart) selectedPart.getChildren().get(i);
				String tooltip = EMPTY_STRING;
				if (next instanceof AbstractFigureEditPart) {
					final AbstractFigureEditPart nextAF = (AbstractFigureEditPart) next;
					View model = (View) nextAF.getModel();
					RealFigure modelElement = (RealFigure) model.getElement();
					String name = modelElement.getName();
					tooltip = modelElement.eClass().getName() + ":" + (name != null && name.length() != 0 ? name : String.valueOf(i + 1));
				}
				result.add(new MyConnectionHandle(selectedPart, next, tooltip));
			}
			return result;
		}
	}

	private static class MyConnectionHandle extends ConnectionHandle {

		private final MyHandleTool myTool;

		public MyConnectionHandle(IGraphicalEditPart ownerEditPart, EditPart nextChild, String tooltip) {
			super(ownerEditPart, HandleDirection.INCOMING, tooltip);
			myTool = new MyHandleTool(nextChild, tooltip);
		}

		protected DragTracker createDragTracker() {
			return myTool;
		}
	}

	private static class MyHandleTool extends AbstractTool implements DragTracker {

		private final EditPart myTarget;

		private final String myCommandName;

		public MyHandleTool(EditPart target, String commandName) {
			super();
			myTarget = target;
			myCommandName = commandName;
		}

		protected boolean handleButtonUp(int button) {
			myTarget.getViewer().select(myTarget);
			return true;
		}

		protected String getCommandName() {
			return myCommandName;
		}
	}

}
@


1.12
log
@[233205] - Support Polyline figure in .gmfgraph editor
@
text
@a43 1
import org.eclipse.gmf.gmfgraph.Shape;
d160 2
a161 2
		Shape shape = getShape();
		if (shape == null || shape.getLayoutData() == null) {
d164 1
a164 1
		LayoutData layoutData = shape.getLayoutData();
d376 1
a376 1
	protected Shape getShape() {
d378 2
a379 2
		if (view != null && view.getElement() instanceof Shape) {
			return (Shape) view.getElement();
d392 1
a392 1
		Font modelFont = getShape().getFont();
@


1.11
log
@[233205] - Support Polyline figure in .gmfgraph editor
@
text
@d232 2
@


1.10
log
@Relayouting parent figure if layoutData was changed for the current one.
@
text
@a13 2
import java.util.Collection;
import java.util.Iterator;
d326 1
a326 2
	// TODO: Either use this method or remove it.
	protected PointList getPointList(Collection template) {
d328 2
a329 3
		for (Iterator it = template.iterator(); it.hasNext();) {
			Point nextPoint = (Point) it.next();
			result.addPoint(new org.eclipse.draw2d.geometry.Point(getMapMode().DPtoLP(nextPoint.getX()), getMapMode().DPtoLP(nextPoint.getY())));
@


1.9
log
@[230191] - Start using FeatureTracker/AttachAdapter for listening model changes in org.eclipse.gmf.graphdef.editor
@
text
@d354 9
@


1.8
log
@Calling handleMajorSemanticChange() on any layoutManager modifications.
It's necessary to populate new instance of LayoutManager with proper layout constraints for each child figure.
@
text
@d29 1
d32 2
d36 1
d44 1
d56 1
d58 1
d60 2
d67 91
a256 25
	// ModelData transformers
	private int getDraw2dAllignment(Alignment alignment, boolean isToolbar) {
		switch (alignment.getValue()) {
		case Alignment.BEGINNING:
			return isToolbar ? ToolbarLayout.ALIGN_TOPLEFT : org.eclipse.draw2d.FlowLayout.ALIGN_LEFTTOP;
		case Alignment.END:
			return isToolbar ? ToolbarLayout.ALIGN_BOTTOMRIGHT : org.eclipse.draw2d.FlowLayout.ALIGN_RIGHTBOTTOM;
		}
		return isToolbar ? ToolbarLayout.ALIGN_CENTER : org.eclipse.draw2d.FlowLayout.ALIGN_CENTER;
	}

	private Integer getGridDataAlignment(Alignment alignment) {
		switch (alignment.getValue()) {
		case Alignment.BEGINNING:
			return GridData.BEGINNING;
		case Alignment.END:
			return GridData.END;
		case Alignment.CENTER:
			return GridData.CENTER;
		case Alignment.FILL:
			return GridData.FILL;
		}
		return null;
	}

d273 1
a273 1
				layoutManager.setMinorAlignment(getDraw2dAllignment(flowLayout.getMinorAlignment(), flowLayout.isForceSingleLine()));
d280 2
a281 2
				layoutManager.setMinorAlignment(getDraw2dAllignment(flowLayout.getMinorAlignment(), flowLayout.isForceSingleLine()));
				layoutManager.setMajorAlignment(getDraw2dAllignment(flowLayout.getMajorAlignment(), flowLayout.isForceSingleLine()));
a323 23
	protected static int getLineStyle(LineKind lineKind) {
		switch (lineKind.getValue()) {
		case LineKind.LINE_DASH: {
			return Graphics.LINE_DASH;
		}
		case LineKind.LINE_DOT: {
			return Graphics.LINE_DOT;
		}
		case LineKind.LINE_DASHDOT: {
			return Graphics.LINE_DASHDOT;
		}
		case LineKind.LINE_DASHDOTDOT: {
			return Graphics.LINE_DASHDOTDOT;
		}
		case LineKind.LINE_CUSTOM: {
			return Graphics.LINE_CUSTOM;
		}
		default: {
			return Graphics.LINE_SOLID;
		}
		}
	}

d328 1
d338 79
a481 39
	protected org.eclipse.draw2d.geometry.Dimension getDraw2dDimension(Dimension dimension) {
		return new org.eclipse.draw2d.geometry.Dimension(getMapMode().DPtoLP(dimension.getDx()), getMapMode().DPtoLP(dimension.getDy()));
	}

	protected org.eclipse.draw2d.geometry.Point getDraw2DPoint(Point point) {
		return new org.eclipse.draw2d.geometry.Point(getMapMode().DPtoLP(point.getX()), getMapMode().DPtoLP(point.getY()));
	}

	protected void refreshLayoutData() {
		if (!hasParentFigure()) {
			return;
		}
		Object layoutConstraint = getLayoutConstraint();
		if (layoutConstraint != null) {
			getFigure().getParent().setConstraint(getFigure(), layoutConstraint);
		}
	}

	/**
	 * Parent figure == null if this method was called from setFigure() one.
	 */
	private boolean hasParentFigure() {
		return getFigure().getParent() != null;
	}

	protected void refreshLayoutManager() {
		if (!hasParentFigure()) {
			return;
		}
		handleMajorSemanticChange();
	}

	protected Shape getShape() {
		View view = getNotationView();
		if (view != null && view.getElement() instanceof Shape) {
			return (Shape) view.getElement();
		}
		return null;
	}
@


1.7
log
@Removing unnecessary checks
@
text
@d192 1
a192 1
		
d213 1
a213 1
		
d237 1
a237 1
		
d241 1
a241 1
		
d245 1
a245 1
		
d359 3
d363 1
a363 1
		if (layoutConstraint != null && getFigure().getParent() != null) {
d368 14
@


1.6
log
@[230191] - Start using FeatureTracker/AttachAdapter for listening model changes in org.eclipse.gmf.graphdef.editor
@
text
@a156 7
	/**
	 * Blocking refresh of figure if it was not finally created.
	 */
	private boolean isFigureRefreshAllowed() {
		return figure != null && figure.getParent() != null;
	}

a358 3
		if (!isFigureRefreshAllowed()) {
			return;
		}
d360 1
a360 1
		if (layoutConstraint != null) {
@


1.5
log
@Correcting GridLayout processing
@
text
@a21 1
import org.eclipse.draw2d.StackLayout;
a22 1
import org.eclipse.draw2d.XYLayout;
d31 1
a37 1
import org.eclipse.gmf.gmfgraph.Layoutable;
d41 3
d55 1
d62 3
a64 3
	public Object getLayoutConstraint() {
		Layoutable layoutable = (Layoutable) ((View) getModel()).getElement();
		if (layoutable == null || layoutable.getLayoutData() == null) {
d67 1
a67 1
		LayoutData layoutData = layoutable.getLayoutData();
d119 1
a119 1
			if (xyLayoutData.getTopLeft() != null) {
a120 2
			}
			if (xyLayoutData.getSize() != null) {
d147 1
a147 1
		} else if (layoutManager instanceof XYLayout) {
d158 1
a158 7
	 * This method will be called then new LayoutData object was associated with
	 * this model element.
	 * 
	 * All the layout constraints (LayoutData objects) are actually stored in
	 * model, so just calling <code>handleMajorSemanticChange()</code> to
	 * re-create this EditPart and reload all the LayoutDatas from model
	 * 
d160 11
a170 3
	protected void layoutDataChanged(LayoutData layoutData) {
		if (isFigureRefreshAllowed()) {
			handleMajorSemanticChange();
d172 1
d175 10
a184 11
	/**
	 * This method will be called then layout was changed in model. The same
	 * method will be called to initialize layout on creating figure.
	 * 
	 * The only one way to change layout is to change corresponding model
	 * element now.
	 */
	protected void layoutChanged(Layout layout) {
		if (layout == null) {
			setFigureLayoutManager(null);
			return;
d186 2
d189 2
a190 2
		switch (layout.eClass().getClassifierID()) {
		case GMFGraphPackage.BORDER_LAYOUT: {
d192 1
a192 7
			org.eclipse.draw2d.BorderLayout layoutManager;
			if (getFigureLayoutManager() instanceof org.eclipse.draw2d.BorderLayout) {
				layoutManager = (org.eclipse.draw2d.BorderLayout) getFigureLayoutManager();
			} else {
				layoutManager = new org.eclipse.draw2d.BorderLayout();
				setFigureLayoutManager(layoutManager);
			}
d197 1
a197 1
			break;
d199 2
a200 5
		case GMFGraphPackage.CUSTOM_LAYOUT: {
			// TODO: implement custom layout
			break;
		}
		case GMFGraphPackage.FLOW_LAYOUT: {
d203 1
a203 7
				ToolbarLayout layoutManager;
				if (getFigureLayoutManager() instanceof ToolbarLayout) {
					layoutManager = (ToolbarLayout) getFigureLayoutManager();
				} else {
					layoutManager = new ToolbarLayout();
					setFigureLayoutManager(layoutManager);
				}
d208 1
d210 1
a210 7
				org.eclipse.draw2d.FlowLayout layoutManager;
				if (getFigureLayoutManager() instanceof org.eclipse.draw2d.FlowLayout) {
					layoutManager = (org.eclipse.draw2d.FlowLayout) getFigureLayoutManager();
				} else {
					layoutManager = new org.eclipse.draw2d.FlowLayout();
					setFigureLayoutManager(layoutManager);
				}
d217 1
a218 1
			break;
d220 2
a221 1
		case GMFGraphPackage.GRID_LAYOUT: {
d223 1
a223 7
			org.eclipse.draw2d.GridLayout layoutManager;
			if (getFigureLayoutManager() instanceof org.eclipse.draw2d.GridLayout) {
				layoutManager = (org.eclipse.draw2d.GridLayout) getFigureLayoutManager();
			} else {
				layoutManager = new org.eclipse.draw2d.GridLayout();
				setFigureLayoutManager(layoutManager);
			}
d242 1
a242 1
			break;
d244 3
a246 5
		case GMFGraphPackage.STACK_LAYOUT: {
			if (false == getFigureLayoutManager() instanceof StackLayout) {
				setFigureLayoutManager(new StackLayout());
			}
			break;
d248 3
a250 44
		case GMFGraphPackage.XY_LAYOUT: {
			if (false == getFigureLayoutManager() instanceof XYLayout) {
				setFigureLayoutManager(new XYLayout());
			}
			break;
		}
		}
		if (isFigureRefreshAllowed()) {
			handleMajorSemanticChange();
		}
	}

	/**
	 * Blocking refresh of figure if it was not finally created.
	 */
	private boolean isFigureRefreshAllowed() {
		return figure != null;
	}

	protected abstract LayoutManager getFigureLayoutManager();

	protected abstract void setFigureLayoutManager(LayoutManager layoutManager);

	// ModelData transformers
	private int getDraw2dAllignment(Alignment alignment, boolean isToolbar) {
		switch (alignment.getValue()) {
		case Alignment.BEGINNING:
			return isToolbar ? ToolbarLayout.ALIGN_TOPLEFT : org.eclipse.draw2d.FlowLayout.ALIGN_LEFTTOP;
		case Alignment.END:
			return isToolbar ? ToolbarLayout.ALIGN_BOTTOMRIGHT : org.eclipse.draw2d.FlowLayout.ALIGN_RIGHTBOTTOM;
		}
		return isToolbar ? ToolbarLayout.ALIGN_CENTER : org.eclipse.draw2d.FlowLayout.ALIGN_CENTER;
	}
	
	private Integer getGridDataAlignment(Alignment alignment) {
		switch (alignment.getValue()) {
		case Alignment.BEGINNING:
			return GridData.BEGINNING;
		case Alignment.END:
			return GridData.END;
		case Alignment.CENTER:
			return GridData.CENTER;
		case Alignment.FILL:
			return GridData.FILL;
d252 1
d256 1
a256 1
	protected int getLineStyle(LineKind lineKind) {
d279 4
d291 1
a291 1
	
d294 3
a296 2
		
		// override default connection handles behavior, that could be installed by parent
d305 1
a305 1
			for (int i=0; i<selectedPart.getChildren().size(); i++) {
d313 1
a313 1
					tooltip = modelElement.eClass().getName()+":"+(name != null && name.length() != 0? name : String.valueOf(i+1));
d320 1
a320 1
	
d322 1
d336 1
d338 1
d346 1
a346 1
		
d356 26
@


1.4
log
@- LayoutData properties section was added
- GridLayout support added
@
text
@d51 1
d105 7
a111 2
			result.widthHint = getMapMode().DPtoLP(gridLayoutData.getSizeHint().getDx());
			result.heightHint = getMapMode().DPtoLP(gridLayoutData.getSizeHint().getDy());
d247 16
a262 4
			layoutManager.marginWidth = getMapMode().DPtoLP(gridLayout.getMargins().getDx());
			layoutManager.marginHeight = getMapMode().DPtoLP(gridLayout.getMargins().getDy());
			layoutManager.horizontalSpacing = getMapMode().DPtoLP(gridLayout.getSpacing().getDx());
			layoutManager.verticalSpacing = getMapMode().DPtoLP(gridLayout.getSpacing().getDy());
@


1.3
log
@[190196] akarjakina - Adjust GMFGraph Editor according recent gmfgraph metamodel with support for FigureDescriptor introduced
@
text
@d19 1
d36 1
d89 18
a106 2
			// not implemented yet in .gmfgraph
			break;
d138 3
a140 1
			// not implemented yet in .gmfgraph
d231 4
a234 6
			// not implemented yet in .gmfgraph
			// GridLayout gridLayout = (GridLayout) layout;
			/*
			org.eclipse.gmf.internal.codegen.draw2d.GridLayout layoutManager;
			if (getFigureLayoutManager() instanceof org.eclipse.gmf.internal.codegen.draw2d.GridLayout) {
				layoutManager = (org.eclipse.gmf.internal.codegen.draw2d.GridLayout)getFigureLayoutManager();
d236 2
a237 1
				layoutManager = new org.eclipse.gmf.internal.codegen.draw2d.GridLayout();
d239 6
a244 2
			setFigureLayoutManager(layoutManager); }
			 */
d286 14
@


1.2
log
@[182339] akarjakina - provide different means to select parts of composite figures
Visible insets for top-level figures, custom popup action with nested submenus, simple handles behavior
@
text
@a31 1
import org.eclipse.gmf.gmfgraph.Figure;
d40 1
d314 1
a314 1
					Figure modelElement = (Figure) model.getElement();
@


1.1
log
@extract handcrafted code into separate source root from code being generated
enforce java 1.4 compatibility
@
text
@d13 1
d16 1
d26 1
d28 1
d32 1
d43 1
d45 3
d51 1
d214 7
a220 9
			 * < % =
			 * importManager.getImportedName("org.eclipse.gmf.internal.codegen.draw2d.GridLayout")%>
			 * layoutManager; if (myFigure.getLayoutManager() instanceof < % =
			 * importManager.getImportedName("org.eclipse.gmf.internal.codegen.draw2d.GridLayout")%>) {
			 * layoutManager = (< % =
			 * importManager.getImportedName("org.eclipse.gmf.internal.codegen.draw2d.GridLayout")%>)
			 * myFigure.getLayoutManager(); } else { layoutManager = new < % =
			 * importManager.getImportedName("org.eclipse.gmf.internal.codegen.draw2d.GridLayout")%>();
			 * myFigure.setLayoutManager(layoutManager); }
d295 31
d327 29
@

