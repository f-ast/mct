head	1.6;
access;
symbols
	v20080114-2222:1.5
	v20071214-1111:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070520-1200:1.4
	v20070420-1000:1.3
	v20070405-2000:1.2
	v20070405-1100:1.2
	v20070330-1300:1.2
	v20070307-0700:1.2
	v20070221-1500:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.6
date	2008.02.22.13.08.01;	author ashatalin;	state dead;
branches;
next	1.5;
commitid	4c5647bec9294567;

1.5
date	2007.05.31.15.52.32;	author ashatalin;	state Exp;
branches;
next	1.4;
commitid	49f1465eef2c4567;

1.4
date	2007.05.18.21.38.09;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	2f76464e1cbf4567;

1.3
date	2007.04.16.11.03.53;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	7e4e462358154567;

1.2
date	2007.03.02.15.39.20;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	717a45e845234567;

1.1
date	2007.02.09.20.08.32;	author atikhomirov;	state Exp;
branches;
next	;
commitid	179c45ccd4b34567;


desc
@@


1.6
log
@Updating gmfgaph editor:
- Setting default size of all graphical elements to 0,0
- updating aspect templates to reflect latest changes
- regenerating code
@
text
@/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Anna Karjakina (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2006/GraphicalDefinition"»
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»

«EXTENSION xpt::GenModelUtils»
«EXTENSION xpt::diagram::editparts::Utils»
«EXTENSION aspects::xpt::diagram::editparts::Utils»

«DEFINE addFeaturePropertyChangeListeners FOR genmodel::GenFeature-»
«IF this.isListType()-»
for (int i = 0; i < modelElement.«this.getGetAccessor()»().size(); i++) {
	addListenerFilter("«this.getFeatureAccessorName()»_PropertiesListener#" + i, «this.getFeatureAccessorName()»_PropertiesListener, (org.eclipse.emf.ecore.EObject) modelElement.«this.getGetAccessor()»().get(i));
}
«ELSE-»
if (modelElement.«this.getGetAccessor()»() != null) {
	addListenerFilter("«this.getFeatureAccessorName()»_PropertiesListener", «this.getFeatureAccessorName()»_PropertiesListener, modelElement.«this.getGetAccessor()»());
}
«ENDIF-»
«ENDDEFINE»

«DEFINE listenViewColor(String modelColorProperty, String viewColorProperty) FOR gmfgen::GenNode-»
final org.eclipse.gmf.runtime.notation.«viewColorProperty»Style the«viewColorProperty»Style1 = (org.eclipse.gmf.runtime.notation.«viewColorProperty»Style) view.getStyle(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.get«viewColorProperty»Style());
addListenerFilter("«viewColorProperty»StyleListener", new org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener() {
	public void notifyChanged(final org.eclipse.emf.common.notify.Notification notification) {
		try {
			new org.eclipse.emf.workspace.AbstractEMFOperation(getEditingDomain(), "Synchronizing model «modelColorProperty» color with the view", java.util.Collections.singletonMap(org.eclipse.emf.transaction.Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) { //$NON-NLS-1$
				protected org.eclipse.core.runtime.IStatus doExecute(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
					org.eclipse.gmf.runtime.notation.«viewColorProperty»Style the«viewColorProperty»Style = (org.eclipse.gmf.runtime.notation.«viewColorProperty»Style) notification.getNotifier();
					if (notification.getFeatureID(org.eclipse.gmf.runtime.notation.«viewColorProperty»Style.class) == org.eclipse.gmf.runtime.notation.NotationPackage.«viewColorProperty.toUpperCase()»_STYLE__«viewColorProperty.toUpperCase()»_COLOR)
						{
							int color = the«viewColorProperty»Style.get«viewColorProperty»Color();
							org.eclipse.gmf.gmfgraph.RGBColor modelColor;
							if (modelElement.get«modelColorProperty»Color() instanceof org.eclipse.gmf.gmfgraph.RGBColor) {
								modelColor = (org.eclipse.gmf.gmfgraph.RGBColor) modelElement.get«modelColorProperty»Color();
							} else {
								modelColor = org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createRGBColor();
								modelElement.set«modelColorProperty»Color(modelColor);
							}
							if (modelColor.getRed() != (color & 0x000000FF) || modelColor.getGreen() != (color & 0x0000FF00) >> 8 || modelColor.getBlue() != (color & 0x00FF0000) >> 16) {
								modelColor.setRed(color & 0x000000FF);
								modelColor.setGreen((color & 0x0000FF00) >> 8);
								modelColor.setBlue((color & 0x00FF0000) >> 16);
							}
						}
					return org.eclipse.core.runtime.Status.OK_STATUS;
				}
			}.execute(new org.eclipse.core.runtime.NullProgressMonitor(), null);
		} catch (org.eclipse.core.commands.ExecutionException e) {
			«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to synchronize model «modelColorProperty» color with the view", e); //$NON-NLS-1$
		}
	}
}, the«viewColorProperty»Style1);
«ENDDEFINE»

«DEFINE setViewColor(String modelColorProperty, String viewColorProperty) FOR gmfgen::GenNode-»
final org.eclipse.gmf.runtime.notation.«viewColorProperty»Style the«viewColorProperty»Style = (org.eclipse.gmf.runtime.notation.«viewColorProperty»Style) view.getStyle(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.get«viewColorProperty»Style());
if (modelElement.get«modelColorProperty»Color() != null) {
	final int rgbColor;
	if (modelElement.get«modelColorProperty»Color() instanceof org.eclipse.gmf.gmfgraph.RGBColor) {
		org.eclipse.gmf.gmfgraph.RGBColor modelColor = (org.eclipse.gmf.gmfgraph.RGBColor) modelElement.get«modelColorProperty»Color();
		rgbColor = (modelColor.getRed()& 0xFF) | ((modelColor.getGreen() & 0xFF) << 8) | ((modelColor.getBlue() & 0xFF) << 16);
	} else {
		org.eclipse.gmf.gmfgraph.ConstantColor modelColor = (org.eclipse.gmf.gmfgraph.ConstantColor) modelElement.get«modelColorProperty»Color();
		rgbColor = getRgbColor(modelColor);
	}
	if (rgbColor != -1 && the«viewColorProperty»Style.get«viewColorProperty»Color() != rgbColor) {
		org.eclipse.emf.workspace.AbstractEMFOperation setColorOperation = new org.eclipse.emf.workspace.AbstractEMFOperation(getEditingDomain(), "Synchronizing view «modelColorProperty» color with the model", java.util.Collections.singletonMap(org.eclipse.emf.transaction.Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) { //$NON-NLS-1$
			protected org.eclipse.core.runtime.IStatus doExecute(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
				the«viewColorProperty»Style.set«viewColorProperty»Color(rgbColor);
				return org.eclipse.core.runtime.Status.OK_STATUS;
			}
		};
		try {
			setColorOperation.execute(new org.eclipse.core.runtime.NullProgressMonitor(), null);
		} catch (org.eclipse.core.commands.ExecutionException e) {
			«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to synchronize view «modelColorProperty» color with the model", e); //$NON-NLS-1$
		}
	}
}
«ENDDEFINE»

«DEFINE listenerForDatatype FOR genmodel::GenFeature-»
«EXPAND listenerForDatatype(getTypeGenClassifier())-»
«ENDDEFINE»

«DEFINE listenerForDatatype(genmodel::GenClassifier type) FOR genmodel::GenFeature-»
	final org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener «this.getFeatureAccessorName()»_PropertiesListener = new org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener() {
		public void notifyChanged(org.eclipse.emf.common.notify.Notification notification) {
		    «getProcessChangesCall(this, "modelElement")»;
		}
	};
	«EXPAND addFeaturePropertyChangeListeners-»
«ENDDEFINE»

«DEFINE listenerForDatatype(genmodel::GenDataType type) FOR genmodel::GenFeature-»
«ENDDEFINE»

«DEFINE notifyBodyForDatatype FOR genmodel::GenFeature-»
«EXPAND notifyBodyForDatatype(getTypeGenClassifier())-»
«ENDDEFINE»

«DEFINE notifyBodyForDatatype(genmodel::GenClassifier type) FOR genmodel::GenFeature-»
    «IF this.isListType()-»
	int listSize = modelElement.«this.getGetAccessor()»().size();
	if (notification.getOldValue() instanceof java.util.Collection) {
		listSize += ((java.util.Collection) notification.getOldValue()).size();
	} else {
		listSize++;
	}
	for (int i = 0; i < listSize; i++) {
		removeListenerFilter("«this.getFeatureAccessorName()»_PropertiesListener#" + i);
	}
    «ELSE-»
	removeListenerFilter("«this.getFeatureAccessorName()»_PropertiesListener");
    «ENDIF-»
    «EXPAND addFeaturePropertyChangeListeners-»
«ENDDEFINE»

«DEFINE notifyBodyForDatatype(genmodel::GenDataType type) FOR genmodel::GenFeature-»
«ENDDEFINE»

«AROUND extendsList FOR gmfgen::GenNode-»
«IF generateSyncronizationCode(metaclass()) && isInnerClassViewmap(viewmap)-»
«getDiagram().editPartsPackageName».AbstractFigureEditPart«ELSE»«targetDef.proceed()»«ENDIF»
«ENDAROUND»

«AROUND additions FOR gmfgen::GenNode-»
«IF generateSyncronizationCode(metaclass())-»
«EXPAND additions(viewmap)-»
«ELSE-»
«targetDef.proceed()»
«ENDIF-»
«ENDAROUND»

«DEFINE additions(gmfgen::Viewmap innerViewmap) FOR gmfgen::GenNode-»
«ENDDEFINE»

«DEFINE additions(gmfgen::InnerClassViewmap innerViewmap) FOR gmfgen::GenNode-»
	«EXPAND xpt::Common::generatedMemberComment»
	private «innerViewmap.className» myFigure;
	
// TODO: use myFigure?
	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.draw2d.Figure myNodeFigure;
	
	«EXPAND xpt::Common::generatedMemberComment»
	public void activate() {
		if (isActive()){
			return;
		}
		org.eclipse.gmf.runtime.notation.View view = (org.eclipse.gmf.runtime.notation.View) getModel();
		if (view.getElement() == null) {
			super.activate();
			return;
		}

		final «metaclass().getQualifiedInterfaceName()» modelElement = («metaclass().getQualifiedInterfaceName()») view.getElement();

        «FOREACH metaclass().getAllGenFeatures() AS nextGenFeature»
            «IF !skip(nextGenFeature)-»
                «EXPAND listenerForDatatype FOR nextGenFeature-»
		addListenerFilter("«nextGenFeature.getFeatureAccessorName()»_Listener", new org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener() {
			public void notifyChanged(org.eclipse.emf.common.notify.Notification notification) {
			    «EXPAND notifyBodyForDatatype FOR nextGenFeature-»
			    «getProcessChangesCall(nextGenFeature, "modelElement")»;
			    «IF isCornerWidthOrHeight(nextGenFeature)-»
			    myFigure.repaint();
			    «ENDIF-»
			}
		}, modelElement, «nextGenFeature.genClass.genPackage.getQualifiedPackageInterfaceName()».eINSTANCE.get«nextGenFeature.getFeatureAccessorName()»());
            «ENDIF-»
        «ENDFOREACH»
        
		final org.eclipse.gmf.runtime.notation.Bounds bounds = (org.eclipse.gmf.runtime.notation.Bounds) ((org.eclipse.gmf.runtime.notation.Node) view).getLayoutConstraint();
		final int sizeX;
		final int sizeY;
		if (modelElement.getPreferredSize() != null) {
			sizeX = getMapMode().DPtoLP(modelElement.getPreferredSize().getDx());
			sizeY = getMapMode().DPtoLP(modelElement.getPreferredSize().getDy());
		} else {
			sizeX = getMapMode().DPtoLP(20);
			sizeY = getMapMode().DPtoLP(20);
		}
		final int locationX;
		final int locationY;
		if (modelElement.getLocation() != null) {
			locationX = getMapMode().DPtoLP(modelElement.getLocation().getX());
			locationY = getMapMode().DPtoLP(modelElement.getLocation().getY());
		} else {
			locationX = bounds.getX();
			locationY = bounds.getY();
		}
		if (sizeX != bounds.getWidth() || sizeY != bounds.getHeight() || locationX != bounds.getX() || locationY != bounds.getY()) {
			try {
				new org.eclipse.emf.workspace.AbstractEMFOperation(getEditingDomain(), "Synchronizing view size with the model", java.util.Collections.singletonMap(org.eclipse.emf.transaction.Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) { //$NON-NLS-1$
					protected org.eclipse.core.runtime.IStatus doExecute(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
						bounds.setX(locationX);
						bounds.setY(locationY);
						bounds.setWidth(sizeX);
						bounds.setHeight(sizeY);
						return org.eclipse.core.runtime.Status.OK_STATUS;
					}
				}.execute(new org.eclipse.core.runtime.NullProgressMonitor(), null);
			} catch (org.eclipse.core.commands.ExecutionException e) {
				«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to synchronize view size with the model", e); //$NON-NLS-1$			
			}
		}
		addListenerFilter("BoundsListener", new org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener() {
			public void notifyChanged(final org.eclipse.emf.common.notify.Notification notification) {
				try {
					new org.eclipse.emf.workspace.AbstractEMFOperation(getEditingDomain(), "Synchronizing model size with the view", java.util.Collections.singletonMap(org.eclipse.emf.transaction.Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) { //$NON-NLS-1$
						protected org.eclipse.core.runtime.IStatus doExecute(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
							org.eclipse.gmf.runtime.notation.Bounds bounds = (org.eclipse.gmf.runtime.notation.Bounds) notification.getNotifier();
							org.eclipse.gmf.gmfgraph.Dimension dim = modelElement.getPreferredSize();
							if (dim == null) {
								dim = org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createDimension();
								modelElement.setPreferredSize(dim);
							}
							org.eclipse.gmf.gmfgraph.Point location = modelElement.getLocation();
							if (location == null) {
								location = org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createPoint();
								modelElement.setLocation(location);
							}
				
							int x = getMapMode().LPtoDP(bounds.getX());
							int y = getMapMode().LPtoDP(bounds.getY());
							int width = getMapMode().LPtoDP(bounds.getWidth());
							int height = getMapMode().LPtoDP(bounds.getHeight());
							if (location.getX() != x || location.getY() != y) {
								location.setX(x);
								location.setY(y);
							}
							if (dim.getDx() != width || dim.getDy() != height) {
								dim.setDx(width);
								dim.setDy(height);
							}

							myNodeFigure.setPreferredSize(bounds.getWidth(), bounds.getHeight());
							myNodeFigure.setLocation(new org.eclipse.draw2d.geometry.Point(bounds.getX(), bounds.getY()));
				
							if (modelElement.getLayoutData() instanceof org.eclipse.gmf.gmfgraph.XYLayoutData || (modelElement.eContainer() instanceof org.eclipse.gmf.gmfgraph.Layoutable && ((org.eclipse.gmf.gmfgraph.Layoutable)modelElement.eContainer()).getLayout() instanceof org.eclipse.gmf.gmfgraph.XYLayout)) {
								org.eclipse.gmf.gmfgraph.XYLayoutData xyLayoutData = (org.eclipse.gmf.gmfgraph.XYLayoutData) modelElement.getLayoutData();
								if (xyLayoutData == null) {
									xyLayoutData = org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createXYLayoutData();
									modelElement.setLayoutData(xyLayoutData);
									xyLayoutData.setTopLeft(org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createPoint());
									xyLayoutData.getTopLeft().setX(0);
									xyLayoutData.getTopLeft().setY(0);
									xyLayoutData.setSize(org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createDimension());
									xyLayoutData.getSize().setDx(40);
									xyLayoutData.getSize().setDy(40);
								}
								org.eclipse.gmf.gmfgraph.Point topLeft;
								if (xyLayoutData.getTopLeft() != null) {
									topLeft = xyLayoutData.getTopLeft();
								} else {
									topLeft = org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createPoint();
									xyLayoutData.setTopLeft(topLeft);
								}
								if (topLeft.getX() != location.getX() || topLeft.getY() != location.getY()) {
									topLeft.setX(location.getX());
									topLeft.setY(location.getY());
								}

								org.eclipse.gmf.gmfgraph.Dimension size;
								if (xyLayoutData.getSize() != null) {
									size = xyLayoutData.getSize();
								} else {
									size = org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createDimension();
									xyLayoutData.setSize(size);
								}
								if (size.getDx() != dim.getDx() || size.getDy() != dim.getDy()) {
									size.setDx(dim.getDx());
									size.setDy(dim.getDy());
								}
							}
							return org.eclipse.core.runtime.Status.OK_STATUS;
						}
					}.execute(new org.eclipse.core.runtime.NullProgressMonitor(), null);
				} catch (org.eclipse.core.commands.ExecutionException e) {
					«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to synchronize model size with the view", e); //$NON-NLS-1$			
				}
				if (getRoot() != null) {
					handleMajorSemanticChange();	
				}
			}
		}, bounds);
		
		«EXPAND setViewColor("Background", "Fill")-»
		«EXPAND setViewColor("Foreground", "Line")-»

		«EXPAND listenViewColor("Background", "Fill")-»
		«EXPAND listenViewColor("Foreground", "Line")-»
		
		super.activate();
	}
	
	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.draw2d.LayoutManager getFigureLayoutManager() {
		return myFigure.getLayoutManager();
	}

	«EXPAND xpt::Common::generatedMemberComment»
	protected void setFigureLayoutManager(org.eclipse.draw2d.LayoutManager layoutManager) {
		myFigure.setLayoutManager(layoutManager);
	}
	
	«EXPAND xpt::Common::generatedMemberComment»
	protected void refreshBounds() {
		if (((org.eclipse.gmf.runtime.notation.View) getParent().getModel()).getElement() instanceof org.eclipse.gmf.gmfgraph.AbstractFigure) {
			int width = ((Integer) getStructuralFeatureValue(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getSize_Width())).intValue();
			int height = ((Integer) getStructuralFeatureValue(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getSize_Height())).intValue();
			myNodeFigure.setPreferredSize(new org.eclipse.draw2d.geometry.Dimension(width, height));
		} else {
			super.refreshBounds();
		}
	}

	«EXPAND xpt::Common::generatedMemberComment»
    public static int getRgbColor(org.eclipse.gmf.gmfgraph.ConstantColor modelColor) {
        final int rgbColor;
		switch (modelColor.getValue().getValue()) {
        case org.eclipse.gmf.gmfgraph.ColorConstants.WHITE: {
            rgbColor = org.eclipse.draw2d.ColorConstants.white.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.BLACK: {
            rgbColor = org.eclipse.draw2d.ColorConstants.black.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.LIGHT_GRAY: {
            rgbColor = org.eclipse.draw2d.ColorConstants.lightGray.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.GRAY: {
            rgbColor = org.eclipse.draw2d.ColorConstants.gray.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.DARK_GRAY: {
            rgbColor = org.eclipse.draw2d.ColorConstants.darkGray.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.RED: {
            rgbColor = org.eclipse.draw2d.ColorConstants.red.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.ORANGE: {
            rgbColor = org.eclipse.draw2d.ColorConstants.orange.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.YELLOW: {
            rgbColor = org.eclipse.draw2d.ColorConstants.yellow.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.GREEN: {
            rgbColor = org.eclipse.draw2d.ColorConstants.green.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.LIGHT_GREEN: {
            rgbColor = org.eclipse.draw2d.ColorConstants.lightGreen.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.DARK_GREEN: {
            rgbColor = org.eclipse.draw2d.ColorConstants.darkGreen.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.CYAN: {
            rgbColor = org.eclipse.draw2d.ColorConstants.cyan.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.LIGHT_BLUE: {
            rgbColor = org.eclipse.draw2d.ColorConstants.lightBlue.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.BLUE: {
            rgbColor = org.eclipse.draw2d.ColorConstants.blue.getRGB().hashCode();
            break;
        }
        case org.eclipse.gmf.gmfgraph.ColorConstants.DARK_BLUE: {
            rgbColor = org.eclipse.draw2d.ColorConstants.darkBlue.getRGB().hashCode();
            break;
        }
        default:
            rgbColor = -1;
        }
        return rgbColor;
    }	
«ENDDEFINE»

«DEFINE overrideGetCurrentConstraintFor(gmfgen::Viewmap innerViewmap) FOR gmfgen::GenNode-»«ENDDEFINE»

«DEFINE overrideGetCurrentConstraintFor(gmfgen::InnerClassViewmap innerViewmap) FOR gmfgen::GenNode-»

protected org.eclipse.draw2d.geometry.Rectangle getCurrentConstraintFor(org.eclipse.gef.GraphicalEditPart child) {
	org.eclipse.draw2d.geometry.Rectangle result = super.getCurrentConstraintFor(child);
	if (result == null) {
		org.eclipse.draw2d.IFigure fig = child.getFigure();
		result = fig.getBounds().getCopy();
	}
	return result;
}
«ENDDEFINE»

«DEFINE overrideGetLayoutOrigin(gmfgen::Viewmap innerViewmap) FOR gmfgen::GenNode-»«ENDDEFINE»

«DEFINE overrideGetLayoutOrigin(gmfgen::InnerClassViewmap innerViewmap) FOR gmfgen::GenNode-»

protected org.eclipse.draw2d.geometry.Point getLayoutOrigin() {
	return ((org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart)getHost()).getContentPane().getClientArea().getLocation();
}
«ENDDEFINE»

«AROUND createLayoutEditPolicyMethodBody FOR gmfgen::GenNode-»
«IF generateSyncronizationCode(metaclass())-»
	«IF gmfgen::ViewmapLayoutType::XY_LAYOUT.value == getLayoutType().value-»
	org.eclipse.gmf.runtime.diagram.ui.editpolicies.XYLayoutEditPolicy lep =
			new org.eclipse.gmf.runtime.diagram.ui.editpolicies.XYLayoutEditPolicy() {

		protected org.eclipse.gef.EditPolicy createChildEditPolicy(org.eclipse.gef.EditPart child) {
			«IF hasBorderItems()-»
			if (child instanceof org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart) {
				return new org.eclipse.gmf.runtime.diagram.ui.editpolicies.BorderItemSelectionEditPolicy();
			}
			«ENDIF-»
			org.eclipse.gef.EditPolicy result = super.createChildEditPolicy(child);
			if (result == null) {
				return new org.eclipse.gmf.runtime.diagram.ui.editpolicies.ResizableShapeEditPolicy();
			}
			return result;
		}
        «EXPAND overrideGetLayoutOrigin(viewmap)-»
        «EXPAND overrideGetCurrentConstraintFor(viewmap)-»
        
	};
	return lep;
	«ELSEIF gmfgen::ViewmapLayoutType::TOOLBAR_LAYOUT.value == getLayoutType().value»
	org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConstrainedToolbarLayoutEditPolicy lep =
			new org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConstrainedToolbarLayoutEditPolicy() {

		protected org.eclipse.gef.EditPolicy createChildEditPolicy(org.eclipse.gef.EditPart child) {
			«IF hasBorderItems()-»
			if (child instanceof org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart) {
				return new org.eclipse.gmf.runtime.diagram.ui.editpolicies.BorderItemSelectionEditPolicy();
			}
			«ENDIF-»
			if (child.getEditPolicy(org.eclipse.gef.EditPolicy.PRIMARY_DRAG_ROLE) == null) {
				if (child instanceof org.eclipse.gmf.runtime.diagram.ui.editparts.ITextAwareEditPart) {
					return new «getDiagram().getTextSelectionEditPolicyQualifiedClassName()»();
				}
			}
			return super.createChildEditPolicy(child);
		}
        «EXPAND overrideGetLayoutOrigin(this.viewmap)-»
        
	};
	return lep;
	«ELSE-»
    «targetDef.proceed()»
	«ENDIF-»
«ELSE»
«targetDef.proceed()»
«ENDIF-»
«ENDAROUND»

«AROUND createNodeShape(gmfgen::GenNode node) FOR gmfgen::InnerClassViewmap»
«IF generateSyncronizationCode(node.metaclass()) && isInnerClassViewmap(node.viewmap)»
	«EXPAND xpt::Common::generatedMemberComment»
	protected org.eclipse.draw2d.IFigure createNodeShape() {
		«className» figure = new «className»();
		«IF node.childNodes.size() > 0 && node.getLayoutType().value == gmfgen::ViewmapLayoutType::XY_LAYOUT.value-»
 		figure.setUseLocalCoordinates(true);
		«ENDIF-»
		«EXPAND processChanges(node)-»
 		return primaryShape = figure;
	}

	«EXPAND xpt::Common::generatedMemberComment»
	public «className» getPrimaryShape() {
		return («className») primaryShape;
	}
«ELSE»
«targetDef.proceed()»
«ENDIF»
«ENDAROUND»

«DEFINE processChanges(gmfgen::GenNode node) FOR gmfgen::InnerClassViewmap-»
	myFigure = figure;
	«node.metaclass().getQualifiedInterfaceName()» modelElement = («node.metaclass().getQualifiedInterfaceName()») ((org.eclipse.gmf.runtime.notation.View) getModel()).getElement();
	if (modelElement != null) {
	«FOREACH node.metaclass().getAllGenFeatures() AS nextGenFeature-»
		«IF !skip(nextGenFeature)-»
		{
		    «getProcessChangesCall(nextGenFeature, "modelElement")»;
		}
		«ENDIF-»
	«ENDFOREACH-»
	}
«ENDDEFINE»

«AROUND setupNodePlate FOR gmfgen::GenNode-»
«IF generateSyncronizationCode(metaclass()) && isInnerClassViewmap(viewmap)-»
«EXPAND setInsets-»
myNodeFigure = result;
«ELSE»«targetDef.proceed()-»«ENDIF»«ENDAROUND»

«DEFINE setInsets FOR gmfgen::GenChildNode-»
«IF containers.typeSelect(gmfgen::GenCompartment).size() > 0-»
org.eclipse.draw2d.LineBorder contourBorder = new org.eclipse.draw2d.LineBorder(org.eclipse.swt.widgets.Display.getDefault().getSystemColor(org.eclipse.swt.SWT.COLOR_WIDGET_NORMAL_SHADOW));
org.eclipse.draw2d.MarginBorder marginBorder = new org.eclipse.draw2d.MarginBorder(5);
org.eclipse.draw2d.CompoundBorder compoundBorder = new org.eclipse.draw2d.CompoundBorder(contourBorder, marginBorder);
result.setBorder(compoundBorder);«ENDIF»«ENDDEFINE»

«DEFINE setInsets FOR gmfgen::GenNode-»
«ENDDEFINE»

@


1.5
log
@[190196] akarjakina - Adjust GMFGraph Editor according recent gmfgraph metamodel with support for FigureDescriptor introduced
@
text
@@


1.4
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2005/GraphicalDefinition"»
d254 1
a254 1
							if (modelElement.getLayoutData() instanceof org.eclipse.gmf.gmfgraph.XYLayoutData || (modelElement.getParent() != null && modelElement.getParent().getLayout() instanceof org.eclipse.gmf.gmfgraph.XYLayout)) {
d323 1
a323 1
		if (((org.eclipse.gmf.runtime.notation.View) getParent().getModel()).getElement() instanceof org.eclipse.gmf.gmfgraph.FigureMarker) {
@


1.3
log
@[182339] akarjakina - provide different means to select parts of composite figures
Visible insets for top-level figures, custom popup action with nested submenus, simple handles behavior
@
text
@d14 1
a14 1
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
@


1.2
log
@[176026] akarjakina - Fix notation background and foreground colors update
[173499] akarjakina - Add custom form-based property sections fro figure attributes
@
text
@d514 14
a527 2
«IF generateSyncronizationCode(metaclass()) && isInnerClassViewmap(viewmap)»myNodeFigure = result;«ELSE»«targetDef.proceed()»«ENDIF-»
«ENDAROUND»
@


1.1
log
@[173496] akarjakina - updated gmfgraph.editor bootstrap sample with recent GMF changes
@
text
@d34 34
d69 1
d77 1
a77 10
		switch (modelColor.getValue().getValue()) {
/*
		case <nextValue>: {
			rgbColor = org.eclipse.draw2d.ColorConstants.<nextColorLiteral.getName()>.getRGB().hashCode();
			break;
		}
*/
		default: 
			rgbColor = -1;
		}
d79 1
a79 1
	if (rgbColor != -1 && shapeStyle.get«viewColorProperty»Color() != rgbColor) {
d82 1
a82 1
				shapeStyle.set«viewColorProperty»Color(rgbColor);
d89 1
a89 1
			«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to synchronize view «modelColorProperty» background color with the model", e); //$NON-NLS-1$
d179 3
a301 1
		final org.eclipse.gmf.runtime.notation.ShapeStyle shapeStyle = (org.eclipse.gmf.runtime.notation.ShapeStyle) view.getStyle(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getShapeStyle());
d304 4
a307 50
		addListenerFilter("ShapeStyleListener", new org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener() {
			public void notifyChanged(final org.eclipse.emf.common.notify.Notification notification) {
				try {
					new org.eclipse.emf.workspace.AbstractEMFOperation(getEditingDomain(), "Synchronizing model size with the view", java.util.Collections.singletonMap(org.eclipse.emf.transaction.Transaction.OPTION_UNPROTECTED, Boolean.TRUE)) { //$NON-NLS-1$
						protected org.eclipse.core.runtime.IStatus doExecute(org.eclipse.core.runtime.IProgressMonitor monitor, org.eclipse.core.runtime.IAdaptable info) throws org.eclipse.core.commands.ExecutionException {
							org.eclipse.gmf.runtime.notation.ShapeStyle shapeStyle = (org.eclipse.gmf.runtime.notation.ShapeStyle) notification.getNotifier();
							switch (notification.getFeatureID(org.eclipse.gmf.runtime.notation.ShapeStyle.class)) {
							case org.eclipse.gmf.runtime.notation.NotationPackage.SHAPE_STYLE__FILL_COLOR:
								{
									int color = shapeStyle.getFillColor();
									org.eclipse.gmf.gmfgraph.RGBColor modelColor;
									if (modelElement.getBackgroundColor() instanceof org.eclipse.gmf.gmfgraph.RGBColor) {
										modelColor = (org.eclipse.gmf.gmfgraph.RGBColor) modelElement.getBackgroundColor();
									} else {
										modelColor = org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createRGBColor();
										modelElement.setBackgroundColor(modelColor);
									}
									if (modelColor.getRed() != (color & 0x000000FF) || modelColor.getGreen() != (color & 0x0000FF00) >> 8 || modelColor.getBlue() != (color & 0x00FF0000) >> 16) {
										modelColor.setRed(color & 0x000000FF);
										modelColor.setGreen((color & 0x0000FF00) >> 8);
										modelColor.setBlue((color & 0x00FF0000) >> 16);
									}
									break;
								}
							case org.eclipse.gmf.runtime.notation.NotationPackage.SHAPE_STYLE__LINE_COLOR:
								{
									int color = shapeStyle.getLineColor();
									org.eclipse.gmf.gmfgraph.RGBColor modelColor;
									if (modelElement.getForegroundColor() instanceof org.eclipse.gmf.gmfgraph.RGBColor) {
										modelColor = (org.eclipse.gmf.gmfgraph.RGBColor) modelElement.getForegroundColor();
									} else {
										modelColor = org.eclipse.gmf.gmfgraph.GMFGraphFactory.eINSTANCE.createRGBColor();
										modelElement.setForegroundColor(modelColor);
									}
									if (modelColor.getRed() != (color & 0x000000FF) || modelColor.getGreen() != (color & 0x0000FF00) >> 8 || modelColor.getBlue() != (color & 0x00FF0000) >> 16) {
										modelColor.setRed(color & 0x000000FF);
										modelColor.setGreen((color & 0x0000FF00) >> 8);
										modelColor.setBlue((color & 0x00FF0000) >> 16);
									}
									break;
								}
							}
							return org.eclipse.core.runtime.Status.OK_STATUS;
						}
					}.execute(new org.eclipse.core.runtime.NullProgressMonitor(), null);
				} catch (org.eclipse.core.commands.ExecutionException e) {
					«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().logError("Unable to synchronize model size with the view", e); //$NON-NLS-1$			
				}
			}
		}, shapeStyle);
d331 70
@

