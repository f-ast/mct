head	1.7;
access;
symbols
	v20081020-0700:1.7
	v20080722-1827:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080425-1959:1.7
	v20080222-1200:1.6
	v20080215-1500:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	v20070621-0000:1.6
	RC3_20:1.6
	v20070601-1400:1.6
	v20070518-1300:1.6
	v20070403-1500:1.6
	v20070330-1300:1.6
	M4_20:1.6
	v20061214-0000:1.6
	M3_20:1.6
	v20061013-1330:1.6
	v20060919-0800:1.5.2.2
	M1_20:1.5
	v20060728-0500:1.5.2.1
	v20060721-1130:1.5
	v20060713-1700:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	v20060627-1200:1.5
	v20060616-1200:1.5
	v20060531-1730:1.5
	v20060519-0800:1.5
	I20060505-1400:1.5
	I20060428-1300:1.5
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.4
	I20051223-1100:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.2;
locks; strict;
comment	@# @;


1.7
date	2008.04.22.21.06.54;	author ahunter;	state Exp;
branches;
next	1.6;
commitid	172a480e536e4567;

1.6
date	2006.10.03.15.05.21;	author ahunter;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.26.15.37.30;	author ahunter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2005.12.29.19.01.05;	author vramaswamy;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.31.19.43.53;	author vramaswamy;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.28.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.08.14.47.29;	author vramaswamy;	state Exp;
branches;
next	;

1.5.2.1
date	2006.07.26.14.14.18;	author ldamus;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2006.09.13.16.46.21;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.7
log
@[227655] gmf-head ahunter 080422 Clipboard support used for copy/paste does not preserve order
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.clipboard.core.internal;

import java.io.BufferedReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.gmf.runtime.emf.clipboard.core.CopyObjects;
import org.eclipse.gmf.runtime.emf.clipboard.core.ObjectInfo;

import com.ibm.icu.util.StringTokenizer;


/**
 * Codec for the {@@link ResourceInfo meta-data} stored with the resource that
 * is serialized to a string by the copy operation.  The meta-data are
 * implemented as XML comments following the <tt>&lt;XMI&gt;</tt> document
 * element.
 * 
 * @@author Yasser Lulu
 * 
 * @@see ResourceInfo 
 */
public class ResourceInfoProcessor {

	private static final String EMPTY_STRING = ""; //$NON-NLS-1$

	private static final String BEGIN_COMMENT = "<!-- "; //$NON-NLS-1$

	private static final String END_COMMENT = " -->"; //$NON-NLS-1$

	private static final String ENDL = "\n"; //$NON-NLS-1$

	private static final String SEPARATOR = "|"; //$NON-NLS-1$

	private static final String PLUS = "+"; //$NON-NLS-1$

	private static final String COMMA = ","; //$NON-NLS-1$	

	private static final String PROPERTY_DELIM = SEPARATOR + PLUS;	

	private static final String VERSION = "VERSION"; //$NON-NLS-1$

	private static final String VERSION_VALUE = "1.0"; //$NON-NLS-1$

	private static final String TYPE = "TYPE"; //$NON-NLS-1$

	private static final String TYPE_VALUE = "EMF"; //$NON-NLS-1$

	private static final String OFFSET = "OFFSET"; //$NON-NLS-1$

	private static final String ENCODING = "ENCODING"; //$NON-NLS-1$

	private static final String OBJ_ID = "OBJ_ID"; //$NON-NLS-1$

	private static final String OBJ_COPY_TYPE = "OBJ_COPY_TYPE"; //$NON-NLS-1$

	private static final String CONTAINER_ID = "CONTAINER_ID"; //$NON-NLS-1$

	private static final String CONTAINER_CLASS = "CONTAINER_CLASS"; //$NON-NLS-1$

	private static final String HINTS = "HINTS"; //$NON-NLS-1$

	public static final String NONE = "NONE"; //$NON-NLS-1$

	private static final String COPY_PARENT_ID = "COPY_PARENT_ID"; //$NON-NLS-1$

	private static final String COPY_ALWAYS_IDS = "COPY_ALWAYS_IDS"; //$NON-NLS-1$

	private ResourceInfoProcessor() {
		//private
	}

	private static Properties getProperties(String commnetedString) {
		String str = removeCommnetTags(commnetedString);
		StringTokenizer tokenizer = new StringTokenizer(str, PROPERTY_DELIM);
		Properties properties = new Properties();
		String key = null;
		String value = null;
		while (tokenizer.hasMoreTokens()) {
			key = tokenizer.nextToken();
			value = tokenizer.nextToken();
			properties.setProperty(key.trim(), value.trim());
		}
		return properties;
	}

	private static List getCommaSeparatedStringsList(String string) {
		List list = new ArrayList();
		StringTokenizer tokenizer = new StringTokenizer(string, COMMA);
		while (tokenizer.hasMoreTokens()) {
			list.add(tokenizer.nextToken().trim());
		}
		return list;
	}

	private static String removeCommnetTags(String commnetedString) {
		return trimStrings(commnetedString, BEGIN_COMMENT, END_COMMENT);
	}

	private static String trimStrings(String string, String beginStr,
			String endStr) {
		int begin = string.indexOf(beginStr);
		int end = string.indexOf(endStr);
		String result = string.substring(begin + beginStr.length(), end);
		return result.trim();
	}

	private static void processOffset(StringBuffer stringBuffer, int offset) {
		stringBuffer.append(BEGIN_COMMENT);
		stringBuffer.append(OFFSET).append(SEPARATOR).append(offset);
		stringBuffer.append(END_COMMENT);
		stringBuffer.append(ENDL);
	}

	private static void processOffset(ResourceInfo resourceInfo, String str) {
		StringBuffer buffer = new StringBuffer(str);
		int baseLenStrOffset = str.lastIndexOf(BEGIN_COMMENT);
		String baseLenStr = buffer.substring(baseLenStrOffset);
		buffer.delete(baseLenStrOffset, buffer.length());
		int infoStrOffset = Integer.parseInt(getProperties(baseLenStr)
			.getProperty(OFFSET));
		resourceInfo.info = buffer.substring(infoStrOffset);
		buffer.delete(infoStrOffset, buffer.length());
		resourceInfo.data = buffer.toString();
	}

	private static void processEObject(ResourceInfo resourceInfo, String line) {
		ObjectInfo objectInfo = new ObjectInfo();
		Properties properties = getProperties(line);
		objectInfo.objCopyType = properties.getProperty(OBJ_COPY_TYPE);
		objectInfo.objId = properties.getProperty(OBJ_ID);
		objectInfo.containerId = properties.getProperty(CONTAINER_ID);
		objectInfo.containerClass = properties.getProperty(CONTAINER_CLASS);
		objectInfo.hints = properties.getProperty(HINTS);
		objectInfo.copyParentId = properties.getProperty(COPY_PARENT_ID);
		String copyAlwaysIdStr = properties.getProperty(COPY_ALWAYS_IDS);
		if (copyAlwaysIdStr.equals(NONE) == false) {
			List ids = getCommaSeparatedStringsList(copyAlwaysIdStr);
			objectInfo.copyAlwaysIds.addAll(ids);
		}

		resourceInfo.objects.put(objectInfo.objId, objectInfo);
	}

	private static void processEObject(StringBuffer stringBuffer,
			EObject eObject, SavingEMFResource emfResource, Map hintMap,
			CopyObjects copyObjects) {

		stringBuffer.append(BEGIN_COMMENT);

		String copyType = null;
		String containerId = null;
		String containerClass = null;
		EObject eObjectWithValidContainer = eObject;

		if (copyObjects.originalObjects.contains(eObject)) {
			copyType = ObjectCopyType.OBJ_COPY_TYPE_ORIGINAL;
		} else if (copyObjects.combinedCopyAlwaysSet.contains(eObject)) {
			copyType = ObjectCopyType.OBJ_COPY_TYPE_ALWAYS;
		} else {
			copyType = ObjectCopyType.OBJ_COPY_TYPE_PARENT;
			eObjectWithValidContainer = emfResource.getOriginalEObject(eObject);
		}

		stringBuffer.append(OBJ_COPY_TYPE).append(SEPARATOR).append(copyType)
			.append(PLUS);

		stringBuffer.append(OBJ_ID).append(SEPARATOR).append(
			emfResource.getID(eObject)).append(PLUS);
		
		if (eObjectWithValidContainer != null && eObjectWithValidContainer.eContainer() != null) {
			containerId = emfResource.getID(eObjectWithValidContainer.eContainer());
			containerClass = eObjectWithValidContainer.eContainer().eClass()
				.getInstanceClassName();

			stringBuffer.append(CONTAINER_ID).append(SEPARATOR).append(containerId)
				.append(PLUS);
	
			stringBuffer.append(CONTAINER_CLASS).append(SEPARATOR).append(
				containerClass).append(PLUS);
		}

		String hints = (String) hintMap.get(eObject);
		stringBuffer.append(HINTS).append(SEPARATOR).append(
			(hints == null) ? NONE
				: hints).append(PLUS);

		EObject copyParent = (EObject) copyObjects.objectsToCopyParentMap
			.get(eObject);
		stringBuffer.append(COPY_PARENT_ID).append(SEPARATOR).append(
			(copyParent == null) ? NONE
				: emfResource.getID(copyParent)).append(PLUS);

		String copyAlwaysIdsStr = null;
		Set copyAlwaysSet = (Set) copyObjects.copyAlwaysMap.get(eObject);
		if ((copyAlwaysSet != null) && (copyAlwaysSet.isEmpty() == false)) {
			copyAlwaysSet.retainAll(copyObjects.combinedCopyAlwaysSet);
			if (copyAlwaysSet.isEmpty() == false) {
				copyAlwaysIdsStr = EMPTY_STRING; //init
				Iterator copyAlwaysSetIt = copyAlwaysSet.iterator();
				while (copyAlwaysSetIt.hasNext()) {
					EObject copyAlwaysObject = (EObject) copyAlwaysSetIt.next();
					copyAlwaysIdsStr = copyAlwaysIdsStr
						+ emfResource.getID(copyAlwaysObject);
					if (copyAlwaysSetIt.hasNext()) {
						copyAlwaysIdsStr = copyAlwaysIdsStr + COMMA;
					}
				}
			}
		}
		stringBuffer.append(COPY_ALWAYS_IDS).append(SEPARATOR).append(
			(copyAlwaysIdsStr == null) ? NONE
				: copyAlwaysIdsStr);

		stringBuffer.append(END_COMMENT);
		stringBuffer.append(ENDL);
	}

	private static void processResource(ResourceInfo resourceInfo, String line) {
		Properties properties = getProperties(line);
		resourceInfo.encoding = properties.getProperty(ENCODING);
	}

	private static void processResource(StringBuffer stringBuffer,
			String encoding) {
		stringBuffer.append(BEGIN_COMMENT);
		stringBuffer.append(ENCODING).append(SEPARATOR).append(encoding);
		stringBuffer.append(END_COMMENT);
		stringBuffer.append(ENDL);
	}

	private static void processVersion(ResourceInfo resourceInfo, String line) {
		Properties properties = getProperties(line);
		resourceInfo.type = properties.getProperty(TYPE);
		resourceInfo.version = properties.getProperty(VERSION);
	}

	private static void processVersion(StringBuffer stringBuffer) {
		stringBuffer.append(BEGIN_COMMENT);
		stringBuffer.append(TYPE).append(SEPARATOR).append(TYPE_VALUE).append(
			PLUS);
		stringBuffer.append(VERSION).append(SEPARATOR).append(VERSION_VALUE);
		stringBuffer.append(END_COMMENT);
		stringBuffer.append(ENDL);
	}

	static ResourceInfo getResourceInfo(String str)
		throws Exception {
		ResourceInfo resourceInfo = new ResourceInfo();
		processOffset(resourceInfo, str);
		BufferedReader reader = new BufferedReader(new StringReader(
			resourceInfo.info));
		processVersion(resourceInfo, reader.readLine());
		processResource(resourceInfo, reader.readLine());
		String line = reader.readLine();
		while (line != null) {
			processEObject(resourceInfo, line);
			line = reader.readLine();
		}

		resourceInfo.completeEObjectInitialization();

		return resourceInfo;
	}

	public static String getResourceInfo(int offset, String encoding,
			SavingEMFResource emfResource, Map hintMap, CopyObjects copyObjects) {

		StringBuffer stringBuffer = new StringBuffer();

		//(1)type + version
		processVersion(stringBuffer);

		//(2)general model + resource stuff
		processResource(stringBuffer, encoding);

		//(3)generate ObjectInfo entries
		Set objectInfoSet = new LinkedHashSet(copyObjects.totalCopyObjects);
		objectInfoSet.addAll(copyObjects.originalObjects);
		Iterator it = objectInfoSet.iterator();
		while (it.hasNext()) {
			processEObject(stringBuffer, (EObject) it.next(), emfResource,
				hintMap, copyObjects);
		}

		//write offset at the end
		processOffset(stringBuffer, offset);

		return stringBuffer.toString();
	}
}@


1.6
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
a16 1
import java.util.HashSet;
d18 1
d296 1
a296 1
		Set objectInfoSet = new HashSet(copyObjects.totalCopyObjects);
@


1.5
log
@[112794] gmf_head etworkowska 060126 Adopt ICU4J as part of Eclipse 3.2
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
d25 1
@


1.5.2.1
log
@[151690] gmf_R1_0_maintenance nbalaba 060726 Subclasses of CopyOperation cannot modify the auxiliary objects being copied
@
text
@a24 1
import org.eclipse.gmf.runtime.emf.clipboard.core.CopyObjects;
@


1.5.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.4
log
@[110317], gmf_head,Contributed by cdamus, 051229, Compiler warning count should be 0 - runtime foundation layer components
@
text
@a22 1
import java.util.StringTokenizer;
d27 2
@


1.3
log
@bugzilla 107880 gmf_head cvogt 051031 ClipboardUtil should support copying of resource roots
@
text
@d55 1
a55 1
	private static final String PROPERTY_DELIM = SEPARATOR + PLUS; //$NON-NLS-1$	
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a180 4
		containerId = emfResource.getID(eObjectWithValidContainer.eContainer());
		containerClass = eObjectWithValidContainer.eContainer().eClass()
			.getInstanceClassName();

d186 12
a197 6

		stringBuffer.append(CONTAINER_ID).append(SEPARATOR).append(containerId)
			.append(PLUS);

		stringBuffer.append(CONTAINER_CLASS).append(SEPARATOR).append(
			containerClass).append(PLUS);
@


1.1
log
@Bugzilla 108844, Revisit all provisional APIs and move back to internal as needed for the EMF runtime plugins, September 8, 2005
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2003.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

