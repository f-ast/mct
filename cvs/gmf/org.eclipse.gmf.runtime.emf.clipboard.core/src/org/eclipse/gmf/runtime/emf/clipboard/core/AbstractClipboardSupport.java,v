head	1.5;
access;
symbols
	v20081020-0700:1.5
	v20080722-1827:1.5
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080425-1959:1.5
	v20080222-1200:1.5
	v20080215-1500:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070601-1400:1.5
	v20070518-1300:1.5
	v20070403-1500:1.5
	v20070330-1300:1.5
	M4_20:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061013-1330:1.5
	v20060919-0800:1.4.2.1
	M1_20:1.4
	v20060728-0500:1.4
	v20060721-1130:1.4
	v20060713-1700:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060616-1200:1.4
	v20060531-1730:1.4
	v20060519-0800:1.4
	I20060505-1400:1.4
	I20060428-1300:1.3
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.5
date	2006.10.03.15.05.21;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.04.19.49.43;	author vramaswamy;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2006.04.28.00.28.30;	author vramaswamy;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.28.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.42;	author sshaw;	state Exp;
branches;
next	;

1.4.2.1
date	2006.09.13.16.46.22;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.5
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/


package org.eclipse.gmf.runtime.emf.clipboard.core;

import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.xmi.XMLResource;


/**
 * A convenient default implementation of most of the features required of
 * a clipboard support utility.
 * <p>
 * This class is intended to be extended by clients.
 * </p>
 *
 * @@author Christian W. Damus (cdamus)
 */
public class AbstractClipboardSupport
	implements IClipboardSupport {

	private static final Object NULL_TOKEN = Boolean.FALSE;
	private final Map nameFeatureMap = new java.util.HashMap();
	
	/**
	 * Initializes me.
	 */
	public AbstractClipboardSupport() {
		super();
	}

	/**
	 * By default, there are no collisions in pasting.
	 * 
	 * @@return the {@@link PasteAction#ADD} action, always
	 */
	public PasteAction getPasteCollisionAction(EClass eClass) {
		return PasteAction.ADD;
	}

	/**
	 * By default, the following paste options are supported:
	 * <ul>
	 * <li>{@@link PasteOption#NORMAL}: always</li>
	 * <li>others: never</li>
	 * </ul>
	 */
	public boolean hasPasteOption(EObject contextEObject,
			EStructuralFeature eStructuralFeature, PasteOption pasteOption) {
		if (pasteOption.equals(PasteOption.NORMAL)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * By default, transient and derived references are never copied, and
	 * containment references always are copied.
	 */
	public boolean isCopyAlways(EObject context, EReference eReference,
			Object value) {
		if ((eReference.isTransient()) || (eReference.isDerived())) {
			return false;
		} else {
			return eReference.isContainment();
		}
	}

	/**
	 * By default, don't provide any child paste override behaviour.
	 * 
	 * @@return <code>false</code>, always
	 */
	public boolean shouldOverrideChildPasteOperation(EObject parentElement,
			EObject childEObject) {
		return false;
	}

	/**
	 * By default, don't provide any copy override behaviour.
	 * 
	 * @@return <code>false</code>, always
	 */
	public boolean shouldOverrideCopyOperation(Collection eObjects, Map hintMap) {
		return false;
	}

	/**
	 * By default, don't provide any child paste override behaviour.
	 * 
	 * @@return <code>null</code>, always
	 */
	public OverridePasteChildOperation getOverrideChildPasteOperation(
			PasteChildOperation overriddenChildPasteOperation) {
		return null;
	}

	/**
	 * By default, don't provide any copy override behaviour.
	 * 
	 * @@return <code>null</code>, always
	 */
	public OverrideCopyOperation getOverrideCopyOperation(
			CopyOperation overriddenCopyOperation) {
		return null;
	}

	/**
	 * By default, don't exclude any objects from the copy operation.
	 * 
	 * @@return an empty collection
	 */
	public Collection getExcludedCopyObjects(Set eObjects) {
		return Collections.EMPTY_SET;
	}

	/**
	 * By default, assumes that the <code>eObject</code> is attached to
	 * an XML resource, and returns that.
	 */
	public XMLResource getResource(EObject eObject) {
		return (XMLResource) eObject.eResource();
	}

	/**
	 * By default, we always remember the containment feature of an object,
	 * unless it is an Ecore element (such as an annotation) or it is a
	 * detached element.
	 * 
	 * @@return <code>false</code> if the <code>eObject</code> is an Ecore
	 *     object or is detached; <code>true</code>, otherwise
	 */
	public boolean shouldSaveContainmentFeature(EObject eObject) {
		if (EcorePackage.eINSTANCE == eObject.eClass().getEPackage()) {
			return false;
		}
		
		try {
			eObject.eResource().getURIFragment(eObject);
		} catch (Exception ex) {
			return false;
		}
		
		return true;
	}

	/**
	 * By default, there is no post processing to be done.
	 */
	public void performPostPasteProcessing(Set pastedEObjects) {
		// nothing to do
	}

	/**
	 * Obtains the cached name attribute of an eClass, or <code>null</code>
	 * if it has no attribute named "name".
	 * 
	 * @@param eClass an EClass
	 * @@return the cached "name" attribute
	 */
	protected EAttribute getNameAttribute(EClass eClass) {
		EAttribute result = null;
		
		Object value = nameFeatureMap.get(eClass);
		if (value != NULL_TOKEN) {
			result = (EAttribute) value;
			
			if (result == null) {
				nameFeatureMap.put(eClass, NULL_TOKEN);
				
				// look for an attribute named "name"
				for (Iterator iter = eClass.getEAllAttributes().iterator(); iter.hasNext();) {
					EAttribute next = (EAttribute) iter.next();
					
					if ((next.getEType().getInstanceClass() == String.class)
							&& next.getUpperBound() == 1
							&& "name".equalsIgnoreCase(next.getName())) { //$NON-NLS-1$
						
						result = next;
						nameFeatureMap.put(eClass, result);
						break;
					}
				}
			}
		}
		
		return result;
	}
	
	/**
	 * By default, elements are nameable if they have an {@@link EAttribute}
	 * named "name".
	 */
	public boolean isNameable(EObject eObject) {
		return getNameAttribute(eObject.eClass()) != null;
	}

	public String getName(EObject eObject) {
		EAttribute attr = getNameAttribute(eObject.eClass());
		
		if (attr == null) {
			throw new IllegalArgumentException("eObject not nameable"); //$NON-NLS-1$
		}
		
		return (String) eObject.eGet(attr);
	}

	public void setName(EObject eObject, String name) {
		EAttribute attr = getNameAttribute(eObject.eClass());
		
		if (attr == null) {
			throw new IllegalArgumentException("eObject not nameable"); //$NON-NLS-1$
		}
		
		eObject.eSet(attr, name);
	}

	/**
	 * Simply removes an <code>eObject</code> from its container.
	 */
	public void destroy(EObject eObject) {
		EcoreUtil.remove(eObject);
		
		if (eObject.eResource() != null) {
			// it was a cross-resource-contained element
			eObject.eResource().getContents().remove(eObject);
		}
	}

	/**
	 * Default implementation does nothing, for those applications that do not
	 * support creation notifications.
	 */
	public void sendCreateNotification(EObject eObject) {
		// do nothing
	}

	/**
	 * @@return <code>true</code> if the <code>reference</code>'s type is
	 *      compatible with the <code>containedType</code>; <code>false</code>,
	 *      otherwise
	 */
	public boolean canContain(EObject container, EReference reference,
			EClass containedType) {
		return reference.getEContainingClass().isSuperTypeOf(container.eClass())
			&& reference.getEReferenceType().isSuperTypeOf(containedType);
	}

}
@


1.4
log
@[131094] gmf_head cmcgee 060504 Sweep Code for EReference.isMany() calls
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
@


1.4.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
@


1.3
log
@[139049], gmf_head, contributed  by cdamus, 060425, Runtime EMF API must be aware of cross-resource containment
@
text
@d198 1
a198 1
							&& !next.isMany()
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d27 1
d244 1
a244 1
		EObject container = eObject.eContainer();
d246 3
a248 10
		if (container != null) {
			EReference ref = eObject.eContainmentFeature();
			
			if (ref != null) {  // shouldn't be null!
				if (ref.isMany()) {
					((Collection) container.eGet(ref)).remove(eObject);
				} else {
					container.eSet(ref, null);
				}
			}
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

