head	1.5;
access;
symbols
	v20081020-0700:1.5
	v20080722-1827:1.5
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080425-1959:1.5
	v20080222-1200:1.5
	v20080215-1500:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070601-1400:1.5
	v20070518-1300:1.5
	v20070403-1500:1.5
	v20070330-1300:1.5
	M4_20:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061013-1330:1.5
	v20060919-0800:1.4.2.1
	M1_20:1.4
	v20060728-0500:1.4.2.1
	v20060721-1130:1.4.2.1
	v20060713-1700:1.4.2.1
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060616-1200:1.4
	v20060531-1730:1.4
	v20060519-0800:1.4
	I20060505-1400:1.4
	I20060428-1300:1.4
	I20060424-0500:1.4
	I20060424-0300:1.4
	M6_10:1.4
	I20060407-1200:1.4
	I20060331-1000:1.4
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.4
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.4
	I20060209-1815:1.4
	I20060203-0830:1.4
	I20060129-1145:1.4
	I20060127-0900:1.4
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.4
	I20051223-1100:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.4;
locks; strict;
comment	@# @;


1.5
date	2006.10.03.15.05.21;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.28.20.56.00;	author vramaswamy;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2005.09.15.22.42.10;	author vramaswamy;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.28.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.46;	author sshaw;	state Exp;
branches;
next	;

1.4.2.1
date	2006.07.13.15.09.58;	author mmostafa;	state Exp;
branches;
next	;


desc
@@


1.5
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/


package org.eclipse.gmf.runtime.emf.clipboard.core.internal;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.gmf.runtime.emf.clipboard.core.IClipboardSupportFactory;
import org.eclipse.gmf.runtime.emf.clipboard.core.internal.l10n.EMFClipboardCoreMessages;
import org.eclipse.osgi.util.NLS;


/**
 * Manager for the <tt>clipboardSupport</tt> extension point.
 *
 * @@author Christian W. Damus (cdamus)
 */
public class ClipboardSupportManager {
	public static final String EP_CLIPBOARD_SUPPORT = "org.eclipse.gmf.runtime.emf.clipboard.core.clipboardSupport"; //$NON-NLS-1$
	static final String E_NSURI = "nsURI"; //$NON-NLS-1$
	static final String E_CLASS = "class"; //$NON-NLS-1$
	
	/** @@deprecated need a context-based solution */
	static final String E_PRIORITY = "priority"; //$NON-NLS-1$
	
	/** @@deprecated need a context-based solution */
	private static final List PRIORITIES = Arrays.asList(new String[] {
		"lowest", "low", "medium", "high", "highest"});  //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$//$NON-NLS-4$//$NON-NLS-5$
	
	private static final Map clipboardSupportMap = new java.util.HashMap();
	
	/** Not instantiable by clients. */
	private ClipboardSupportManager() {
		super();
	}

	/**
	 * Configures the extensions on the <tt>clipboardSupport</tt> extension
	 * point.
	 * <p>
	 * <b>Note</b> that this method must only be called by the plug-in class
	 * on initialization.
	 * </p>
	 * 
	 * @@param configs the configuration elements representing extensions
	 */
	public static void configureExtensions(IConfigurationElement[] configs) {
		for (int i = 0; i < configs.length; i++) {
			try {
				Descriptor desc = new Descriptor(configs[i]);
				Descriptor previous = (Descriptor) clipboardSupportMap.get(
					desc.getEPackage());
				
				if ((previous == null)
						|| (previous.getPriority() < desc.getPriority())) {
					
					clipboardSupportMap.put(desc.getEPackage(), desc);
				}
			} catch (CoreException e) {
				ClipboardPlugin.getPlugin().log(e.getStatus());
			}
		}
	}
	
	/**
	 * Retrieves the clipboard support factory (if any) that handles the
	 * specified <code>EPackage</code>.
	 * 
	 * @@param ePackage an <code>EPackage</code>
	 * @@return the registered clipboard support factory, or <code>null</code>
	 *     if none was registered or it could not be initialized
	 */
	public static IClipboardSupportFactory lookup(EPackage ePackage) {
		IClipboardSupportFactory result = null;
		
		Descriptor desc = (Descriptor) clipboardSupportMap.get(ePackage);
		if (desc != null) {
			result = desc.getFactory();
		}
		
		return result;
	}
	
	/**
	 * Retrieves the clipboard support factory (if any) that handles the
	 * specified <code>EClass</code>.
	 * 
	 * @@param eClass an <code>EClass</code>
	 * @@return the registered clipboard support factory, or <code>null</code>
	 *     if none was registered or it could not be initialized
	 */
	public static IClipboardSupportFactory lookup(EClass eClass) {
		return lookup(eClass.getEPackage());
	}
	
	/**
	 * Retrieves the clipboard support factory (if any) that handles the
	 * specified <code>EObject</code>.
	 * 
	 * @@param eObject an <code>EObject</code>
	 * @@return the registered clipboard support factory, or <code>null</code>
	 *     if none was registered or it could not be initialized
	 */
	public static IClipboardSupportFactory lookup(EObject eObject) {
		return lookup(eObject.eClass().getEPackage());
	}
	
	/**
	 * Creates an error status with the specified <code>message</code>.
	 * 
	 * @@param code the error code
	 * @@param message the error message
	 * @@return the status object
	 */
	static IStatus createErrorStatus(int code, String message) {
		return createErrorStatus(
			code,
			message,
			null);
	}
	
	/**
	 * Creates an error status with the specified <code>message</code>.
	 * 
	 * @@param code the error code
	 * @@param message the error message
	 * @@param exception an exception to log
	 * @@return the status object
	 */
	static IStatus createErrorStatus(int code, String message, Throwable exception) {
		return new Status(
			IStatus.ERROR,
			ClipboardPlugin.getPlugin().getSymbolicName(),
			code,
			message,
			exception);
	}
	
	/**
	 * Descriptor for an extension on the <tt>clipboardSupport</tt> point.
	 * The descriptor is responsible for lazily initializing the
	 * {@@link IClipboardSupportFactory} on its first access.
	 *
	 * @@author Christian W. Damus (cdamus)
	 */
	private static final class Descriptor {
		private final EPackage ePackage;
		private IClipboardSupportFactory factory;
		private IConfigurationElement config;
		private int priority = 2;
		
		Descriptor(IConfigurationElement config) throws CoreException {
			this.config = config;
			
			String nsUri = config.getAttribute(E_NSURI);
			if ((nsUri == null) || (nsUri.length() == 0)) {
				throw new CoreException(createErrorStatus(
					ClipboardStatusCodes.CLIPBOARDSUPPORT_MISSING_NSURI,
					NLS.bind(EMFClipboardCoreMessages.missing_nsUri_ERROR_,
						new Object[] {
							ClipboardPlugin.EXTPT_CLIPBOARDSUPPORT,
							config.getDeclaringExtension().getNamespaceIdentifier()})));
			}
			
			ePackage = EPackage.Registry.INSTANCE.getEPackage(nsUri);
			if (ePackage == null) {
				throw new CoreException(createErrorStatus(
					ClipboardStatusCodes.CLIPBOARDSUPPORT_UNRESOLVED_NSURI,
					NLS.bind(EMFClipboardCoreMessages.unresolved_nsUri_ERROR_,
						new Object[] {
							ClipboardPlugin.EXTPT_CLIPBOARDSUPPORT,
							nsUri,
							config.getDeclaringExtension().getNamespaceIdentifier()})));
			}
			
			String className = config.getAttribute(E_CLASS);
			if ((className == null) || (className.length() == 0)) {
				throw new CoreException(createErrorStatus(
					ClipboardStatusCodes.CLIPBOARDSUPPORT_MISSING_CLASS,
					NLS.bind(EMFClipboardCoreMessages.missing_class_ERROR_,
						new Object[] {
							ClipboardPlugin.EXTPT_CLIPBOARDSUPPORT,
							config.getDeclaringExtension().getNamespaceIdentifier()})));
			}
			
			String priorityStr = config.getAttribute(E_PRIORITY);
			if (priorityStr != null) {
				priorityStr = priorityStr.toLowerCase();
				
				if (PRIORITIES.contains(priorityStr)) {
					priority = PRIORITIES.indexOf(priorityStr);
				}
			}
		}
		
		EPackage getEPackage() {
			return ePackage;
		}
		
		/** @@deprecated need a context-based solution */
		int getPriority() {
			return priority;
		}
		
		IClipboardSupportFactory getFactory() {
			if ((factory == null) && (config != null)) {
				// we only keep the config element as long as we need it in
				//    order to attempt to instantiate the class
				factory = createFactory();
			}
			
			return factory;
		}
		
		private IClipboardSupportFactory createFactory() {
			IClipboardSupportFactory result = null;
			
			try {
				result = (IClipboardSupportFactory) config.createExecutableExtension(E_CLASS);
			} catch (CoreException e) {
				ClipboardPlugin.getPlugin().log(e.getStatus());
			} catch (Exception e) {
				// log any other exception, too (such as ClassCastException)
				ClipboardPlugin.getPlugin().log(createErrorStatus(
					ClipboardStatusCodes.CLIPBOARDSUPPORT_FACTORY_FAILED,
					NLS.bind(EMFClipboardCoreMessages.factory_failed_ERROR_,
						new Object[] {
							IClipboardSupportFactory.class.getName(),
							config.getAttribute(E_CLASS)}),
					e));
			} finally {
				// we won't try again to instantiate this class
				config = null;
			}
			
			return result;
		}
	}
}
@


1.4
log
@Bugzilla 114008 gmf_head cvogt 051028 - Sweep emf plugin message bundles
@
text
@d180 1
a180 1
							config.getDeclaringExtension().getNamespace()})));
d191 1
a191 1
							config.getDeclaringExtension().getNamespace()})));
d201 1
a201 1
							config.getDeclaringExtension().getNamespace()})));
@


1.4.2.1
log
@[110316] gmf_R1_0_maintenance mmostafa  060713 Compiler warning count should be 0 - runtime diagram layer components
@
text
@d180 1
a180 1
							config.getDeclaringExtension().getNamespaceIdentifier()})));
d191 1
a191 1
							config.getDeclaringExtension().getNamespaceIdentifier()})));
d201 1
a201 1
							config.getDeclaringExtension().getNamespaceIdentifier()})));
@


1.3
log
@Resolved Bugzilla 109628, ClipboardSupportManager Never Gets Initialized, Sept 15, 2005
@
text
@a25 1

d27 2
d177 1
a177 2
					ClipboardPlugin.getPlugin().getString(
						"missing.nsUri_ERROR_", //$NON-NLS-1$
d187 1
a187 2
					ClipboardPlugin.getPlugin().getString(
						"unresolved.nsUri_ERROR_", //$NON-NLS-1$
d198 1
a198 2
					ClipboardPlugin.getPlugin().getString(
						"missing.class_ERROR_", //$NON-NLS-1$
d244 1
a244 2
					ClipboardPlugin.getPlugin().getString(
						"factory.failed_ERROR_", //$NON-NLS-1$
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d36 1
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

