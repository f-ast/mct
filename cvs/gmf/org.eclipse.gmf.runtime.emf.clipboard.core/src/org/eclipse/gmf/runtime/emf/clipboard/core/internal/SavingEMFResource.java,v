head	1.9;
access;
symbols
	v20081020-0700:1.9
	v20080722-1827:1.9
	R2_1_maintenance:1.9.0.4
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080425-1959:1.9
	v20080222-1200:1.9
	v20080215-1500:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	v20070621-0000:1.9
	RC3_20:1.8
	v20070601-1400:1.8
	v20070518-1300:1.8
	v20070403-1500:1.8
	v20070330-1300:1.8
	M4_20:1.8
	v20061214-0000:1.8
	M3_20:1.8
	v20061013-1330:1.8
	v20060919-0800:1.7.2.3
	M1_20:1.7
	v20060728-0500:1.7.2.2
	v20060721-1130:1.7.2.1
	v20060713-1700:1.7.2.1
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060531-1730:1.7
	v20060519-0800:1.7
	I20060505-1400:1.7
	I20060428-1300:1.6
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.3;
locks; strict;
comment	@# @;


1.9
date	2007.06.20.17.12.16;	author ahunter;	state Exp;
branches;
next	1.8;
commitid	3f5c46795ff04567;

1.8
date	2006.10.03.15.05.21;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.04.19.50.49;	author vramaswamy;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.04.28.00.28.30;	author vramaswamy;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.29.19.01.05;	author vramaswamy;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.31.19.43.53;	author vramaswamy;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.28.21;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.14.08.12;	author vramaswamy;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.08.14.47.29;	author vramaswamy;	state Exp;
branches;
next	;

1.7.2.1
date	2006.07.07.13.43.45;	author ldamus;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2006.07.26.14.14.14;	author ldamus;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2006.09.13.16.46.21;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.9
log
@[193560] gmf-head ahunter 070620 Copy/Paste of sorted children EditParts places them on the diagram in the wrong order
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.clipboard.core.internal;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcoreFactory;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreEList;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.emf.ecore.xmi.XMLSave;
import org.eclipse.emf.ecore.xmi.impl.XMISaveImpl;
import org.eclipse.gmf.runtime.emf.clipboard.core.CopyObjects;
import org.eclipse.gmf.runtime.emf.clipboard.core.IClipboardSupport;

/**
 * @@author Yasser Lulu
 */
public class SavingEMFResource
	extends SerializationEMFResource {

	private Map copy2ObjectMap;

	private EList contentList;

	private Set contentSet;

	private CopyObjects copyObjects;

	private Collection excludedObjects;

	public SavingEMFResource(URI uri, String encoding, Map defaultSaveOptions,
		Map copy2ObjectMap, CopyObjects copyObjects,
		IClipboardSupport clipboardOperationHelper) {
		super(encoding, uri, clipboardOperationHelper);
		this.defaultSaveOptions = defaultSaveOptions;
		this.eObjectToIDMap = new HashMap();
		this.idToEObjectMap = new HashMap();
		this.copy2ObjectMap = copy2ObjectMap;
		this.contentSet = new LinkedHashSet(copyObjects.totalCopyObjects);
		this.copyObjects = copyObjects;
		this.excludedObjects = clipboardOperationHelper
			.getExcludedCopyObjects(copyObjects.totalCopyObjects);
		//we must ensure that every EObject in the contentSet has a resource,
		//becuase the serialization process needs that. Those who don't, will
		// be added to us.
		setMissingResource();
		//set containment refs.
		setContainmentFeatures();
		//needed to allow calls to unload() to proceed
		setLoaded(true);
		if (copyObjects.sortTotalCopyObjects) {
			sortContentSetOnOriginalStorageOrder();
		}
	}

	private void sortContentSetOnOriginalStorageOrder() {
		Map parentObjectMap = new HashMap();
		List roots = new ArrayList();
		Iterator it = contentSet.iterator();
		while (it.hasNext()) {
			EObject eObj = (EObject) it.next();
			EObject eParent = eObj.eContainer();
			if (eParent == null) {
				roots.add(eObj);
			} else {
				List children = (List) parentObjectMap.get(eParent);
				if (children == null) {
					children = new ArrayList();
					parentObjectMap.put(eParent, children);
				}
				children.add(eObj);
			}
		}//while

		List list = new ArrayList(roots);
		Iterator entryIt = parentObjectMap.entrySet().iterator();
		while (entryIt.hasNext()) {
			Map.Entry entry = (Map.Entry) entryIt.next();
			
			// get the basic list view of the contents list to avoid resolving
			//    cross-resource containment proxies
			Collections.sort((List) entry.getValue(), new ListIndexComparator(
				((InternalEList) ((EObject) entry.getKey()).eContents()).basicList()));
			list.addAll((List) entry.getValue());
		}
		contentSet = new LinkedHashSet(list);
	}

	private void setContainmentFeatures() {
		EAnnotation containmentAnnotations = EcoreFactory.eINSTANCE
			.createEAnnotation();
		EAnnotation eAnnotation = EcoreFactory.eINSTANCE.createEAnnotation();
		eAnnotation.setSource(SERIALIZATION_ANNOTATIONS);
		containmentAnnotations.getEAnnotations().add(eAnnotation);
		Set set = new HashSet(contentSet);
		set.addAll(copyObjects.originalObjects);
		Iterator it = set.iterator();
		while (it.hasNext()) {
			EObject eObj = (EObject) it.next();
			addToSerializationAnnotation(eAnnotation, eObj);
			
			// OK to resolve containment proxies because we must load the
			//    entire model sub-tree in order to copy it
			TreeIterator contentIt = eObj.eAllContents();
			while (contentIt.hasNext()) {
				EObject childEObj = (EObject) contentIt.next();
				if (getClipboardOperationHelper().shouldSaveContainmentFeature(
					childEObj) == false) {
					contentIt.prune();
					continue;
				}
				addToSerializationAnnotation(eAnnotation, childEObj);
			}
		}
		super.getContents().add(containmentAnnotations);
		contentSet.add(containmentAnnotations);
	}

	private void addToSerializationAnnotation(EAnnotation eAnnotation,
		EObject eObj) {
		EObject eObjectWithValidContainer = (eObj.eContainer() == null) ? getOriginalEObject(eObj)
			: eObj;
		EAnnotation ref_obj_Annotation = EcoreFactory.eINSTANCE
			.createEAnnotation();
		ref_obj_Annotation.getReferences().add(eObj);
		if (eObjectWithValidContainer != null) {
			ref_obj_Annotation.getReferences().add(
				eObjectWithValidContainer.eContainmentFeature());
		} else {
			// If there is no containment feature, which is the case when copying a
			// root element, then an unattached EReference is added to the annotation.
			// This EReference ensures that that the annotation references
			// are serialized using CROSS_DOC.
			// A better fix would be to add some intelligence to the sameDocMany(..) method
			// of the XMISameImpl class created in method createXMLSave().
			ref_obj_Annotation.getReferences().add(EcoreFactory.eINSTANCE.createEReference());
		}
		eAnnotation.getEAnnotations().add(ref_obj_Annotation);
	}

	private void setMissingResource() {
		Iterator it = contentSet.iterator();
		EObject eObject = null;
		while (it.hasNext()) {
			eObject = (EObject) it.next();
			if (eObject.eResource() == null) {
				//no resource (detached view-element), therefore add the
				// top-most
				//parent to the us so that a newer call to getResource will
				// succeed.
				// don't add the element itself, since adding the element to a
				//resource will set its container to null,and we want to
				// preserve
				//the container of the original detached element. This means
				// that
				//if the element itself has no container (top-most
				// copyAlwaysCopy),
				//then we'll add it regardless since its parent is already
				// null.
				//therefore add the container of the detached original element
				// so
				//that the container's container will be set to null
				while (eObject.eContainer() != null) {
					eObject = eObject.eContainer();
				}
				super.getContents().add(eObject);
			}
		}

		//let's make sure that things went OK, for if they didn't, the
		//paste process or even the serialization process will fail
		it = contentSet.iterator();
		while (it.hasNext()) {
			eObject = (EObject) it.next();
			if (eObject.eResource() == null) {

				RuntimeException e = new IllegalArgumentException();

				ClipboardPlugin.throwing(getClass(),
					"setMissingResource", e); //$NON-NLS-1$

				throw e;
			}
		}
	}

	public void doLoad(InputStream inputStream, Map options) throws IOException {
		throwUnsupportedOperationException("doLoad", //$NON-NLS-1$
			new UnsupportedOperationException(
				"Can't call load on serializing resource"));//$NON-NLS-1$
	}

	protected XMLSave createXMLSave() {
		return new XMISaveImpl(createXMLHelper()) {

			protected void saveElement(InternalEObject o, EStructuralFeature f) {
				// do not save cross-resource-contained objects as hrefs, because
				//    the clipboard resource must actually duplicate all of the
				//    original data
				saveElement((EObject) o, f);
			}

			protected void saveElement(EObject o, EStructuralFeature f) {
				if (excludedObjects.contains(o)) {
					return;
				}
				super.saveElement(o, f);
			}

			/**
			 * @@see org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl#sameDocMany(org.eclipse.emf.ecore.EObject,
			 *      org.eclipse.emf.ecore.EStructuralFeature)
			 */
			protected int sameDocMany(EObject o, EStructuralFeature f) {
				InternalEList values = (InternalEList) helper.getValue(o, f);
				if (values.isEmpty()) {
					return SKIP;
				}

				for (Iterator i = values.basicIterator(); i.hasNext();) {
					InternalEObject value = (InternalEObject) i.next();
					if (value.eIsProxy()
						|| (isInSavingResource(value) == false)) {
						return CROSS_DOC;
					}
				}

				return SAME_DOC;
			}

			/**
			 * @@see org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl#sameDocSingle(org.eclipse.emf.ecore.EObject,
			 *      org.eclipse.emf.ecore.EStructuralFeature)
			 */
			protected int sameDocSingle(EObject o, EStructuralFeature f) {
				InternalEObject value = (InternalEObject) helper.getValue(o, f);
				if (value == null) {
					return SKIP;
				} else if (value.eIsProxy()) {
					return CROSS_DOC;
				} else {
					return (isInSavingResource(value)) ? SAME_DOC : CROSS_DOC;
				}
			}

		};
	}

	boolean isInSavingResource(EObject eObject) {
		if (eObject.eResource() == this) {
			return true;
		} else if ((copyObjects.originalObjects.contains(eObject))
			|| (copyObjects.copyParent2CopyMap.values().contains(eObject))
			|| (copyObjects.combinedCopyAlwaysSet.contains(eObject))) {
			return true;
		}
		EObject eContainer = eObject.eContainer();
		while (eContainer != null) {
			if ((copyObjects.originalObjects.contains(eContainer))
				|| (copyObjects.copyParent2CopyMap.values().contains(eContainer))
				|| (copyObjects.combinedCopyAlwaysSet.contains(eContainer))) {
				return true;
			}
			eContainer = eContainer.eContainer();
		}
		return false;
	}

	EObject getOriginalEObject(EObject copiedEObject) {
		return (EObject) copy2ObjectMap.get(copiedEObject);
	}

	private String getOriginalID(EObject eObject) {
		Resource res = eObject.eResource();
		
		if ((res != this) && (res != null)) {
			return ((XMLResource) res).getID(eObject);
		}
		return null;
	}

	/**
	 * @@see org.eclipse.emf.ecore.xmi.XMLResource#getID(org.eclipse.emf.ecore.EObject)
	 */
	public String getID(EObject eObject) {

		//is this an original object?
		String id = getOriginalID(eObject);
		if (id == null) {
			//no, then, is it a copied object?
			EObject original = (EObject) copy2ObjectMap.get(eObject);
			if (original != null) {
				id = getOriginalID(original);
			} else {
				Resource res = eObject.eResource();
				
				if (res != null) {
					//we'll use our own assigned ids, (detached view-elements bug)
					assert eObject.eResource() == this: "eObject.eResource not same as self"; //$NON-NLS-1$
					id = super.getID(eObject);
				}
			}
		}
		return id;
	}

	/**
	 * @@see org.eclipse.emf.ecore.resource.impl.ResourceImpl#getContents()
	 */

	private static class ContentBasicEList
		extends EcoreEList.UnmodifiableEList
		implements InternalEList {

		private static final long serialVersionUID = -2551747854798104709L;

		ContentBasicEList(Set contentSet) {
			super(null, null, contentSet.size(), contentSet.toArray());
		}
	}

	public EList getContents() {
		if (contentList == null) {
			contentList = new ContentBasicEList(contentSet);
		}
		return contentList;
	}

	/**
	 * @@see org.eclipse.emf.ecore.resource.impl.ResourceImpl#doUnload()
	 */
	protected void doUnload() {
		//unset resource for those whom we've actually added to ourselves -in the setMissingResource() above
		//be carefull that the super.getContents() list is a ContentsEList and therefore calling clear on it
		//it will end up calling eInverseRemove on the EObjects it holds and they in turn would end up
		//calling the getResource().getContents() to remove themselves, but as we know that our own getContents()
		// list is unmodifiable and this will throw an exception, therefore replace our own getContents() list
		//with our parent's super.getContents() list before we clear it
		contentList = super.getContents(); 
		super.getContents().clear();

	}
}@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d19 1
d69 1
a69 1
		this.contentSet = new HashSet(copyObjects.totalCopyObjects);
d81 3
a83 1
		sortContentSetOnOriginalStorageOrder();
@


1.7
log
@Adapt to change in XMLHelperImpl that now calls XMLResource.getID(EObject) for non-contained elements
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2004 IBM Corporation and others.
d41 1
d287 2
a288 2
				|| (copyObjects.copyParent2CopyMap.values().contains(eObject))
				|| (copyObjects.combinedCopyAlwaysSet.contains(eObject))) {
@


1.7.2.1
log
@[149026] gmf_R1_0_maintenance ldamus 060707 Copy fails to find other copied objects causing paste to fail
@
text
@d286 2
a287 2
				|| (copyObjects.copyParent2CopyMap.values().contains(eContainer))
				|| (copyObjects.combinedCopyAlwaysSet.contains(eContainer))) {
@


1.7.2.2
log
@[151690] gmf_R1_0_maintenance nbalaba 060726 Subclasses of CopyOperation cannot modify the auxiliary objects being copied
@
text
@a40 1
import org.eclipse.gmf.runtime.emf.clipboard.core.CopyObjects;
@


1.7.2.3
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.6
log
@[139049], gmf_head, contributed  by cdamus, 060425, Runtime EMF API must be aware of cross-resource containment
@
text
@d35 1
d300 4
a303 2
		if (eObject.eResource() != this) {
			return ((XMLResource) eObject.eResource()).getID(eObject);
d321 7
a327 3
				//we'll use our own assigned ids, (detached view-elements bug)
				assert eObject.eResource() == this: "eObject.eResource not same as self"; //$NON-NLS-1$
				id = super.getID(eObject);
@


1.5
log
@[110317], gmf_head,Contributed by cdamus, 051229, Compiler warning count should be 0 - runtime foundation layer components
@
text
@d104 3
d108 1
a108 1
				((EObject) entry.getKey()).eContents()));
d126 3
d221 7
@


1.4
log
@bugzilla 107880 gmf_head cvogt 051031 ClipboardUtil should support copying of resource roots
@
text
@d321 2
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d145 12
a156 2
		ref_obj_Annotation.getReferences().add(
			eObjectWithValidContainer.eContainmentFeature());
@


1.2
log
@Resolved Bugzilla 109291, There are numerous warnings in the runtime and EMFT plugins, Sept 12, 2005
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Bugzilla 108844, Revisit all provisional APIs and move back to internal as needed for the EMF runtime plugins, September 8, 2005
@
text
@a37 2

import org.eclipse.gmf.runtime.emf.clipboard.core.ClipboardSupportUtil;
@

