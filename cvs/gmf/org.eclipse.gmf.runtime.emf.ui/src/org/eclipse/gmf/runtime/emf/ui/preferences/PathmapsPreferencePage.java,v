head	1.10;
access;
symbols
	v20081020-0700:1.10
	v20080722-1827:1.10
	R2_1_maintenance:1.10.0.2
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080516-1748:1.10
	v20080425-1959:1.9
	v20080222-1200:1.9
	v20080114-1111:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	v20070621-0000:1.9
	RC3_20:1.9
	v20070601-1400:1.9
	v20070413-1300:1.9
	v20070330-1300:1.8
	v20070221-1500:1.8
	M4_20:1.6
	v20061214-0000:1.6
	M3_20:1.6
	v20061013-1330:1.6
	v20060925-1700:1.6
	v20060919-0800:1.6
	v20060907-1100:1.6
	M1_20:1.6
	v20060713-1700:1.6
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060616-1200:1.6
	v20060531-1730:1.6
	v20060526-1200:1.6
	I20060505-1400:1.3
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2;
locks; strict;
comment	@# @;


1.10
date	2008.05.16.21.34.38;	author ahunter;	state Exp;
branches;
next	1.9;
commitid	5254482dfdee4567;

1.9
date	2007.04.12.20.13.20;	author crevells;	state Exp;
branches;
next	1.8;
commitid	7ef6461e92e04567;

1.8
date	2007.02.21.15.59.52;	author crevells;	state Exp;
branches;
next	1.7;
commitid	656c45dc6c774567;

1.7
date	2007.02.09.19.43.06;	author crevells;	state Exp;
branches;
next	1.6;
commitid	6ae845ccceca4567;

1.6
date	2006.05.24.18.55.53;	author vramaswamy;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.24.17.20.26;	author vramaswamy;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.24.14.54.48;	author vramaswamy;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.01.22.39.28;	author vramaswamy;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.12.19.35.37;	author ldamus;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.12.19.32.20;	author ldamus;	state Exp;
branches;
next	;


desc
@@


1.10
log
@[231923] gmf-head ahunter 040816 Pathmaps preference page should support many pathmaps
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.ui.preferences;

import java.io.File;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IPathVariableManager;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.common.util.URI;
import org.eclipse.gmf.runtime.emf.core.internal.resources.PathmapManager;
import org.eclipse.gmf.runtime.emf.ui.internal.MslUIPlugin;
import org.eclipse.gmf.runtime.emf.ui.internal.l10n.EMFUIMessages;
import org.eclipse.jface.dialogs.ErrorDialog;
import org.eclipse.jface.preference.PreferencePage;
import org.eclipse.jface.viewers.CheckStateChangedEvent;
import org.eclipse.jface.viewers.CheckboxTableViewer;
import org.eclipse.jface.viewers.ICheckStateListener;
import org.eclipse.jface.viewers.IColorProvider;
import org.eclipse.jface.viewers.ILabelProviderListener;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredContentProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.ITableLabelProvider;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.TableViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerComparator;
import org.eclipse.osgi.util.NLS;
import org.eclipse.osgi.util.TextProcessor;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Label;
import org.eclipse.ui.ISharedImages;
import org.eclipse.ui.IWorkbench;
import org.eclipse.ui.IWorkbenchPreferencePage;
import org.eclipse.ui.dialogs.PreferenceLinkArea;
import org.eclipse.ui.preferences.IWorkbenchPreferenceContainer;

/**
 * Preference page for specifying the path variables that should be considered
 * for modeling.
 * <p>
 * Path variable are created on the "Linked Resources" preference page, and
 * selected for modeling using this page.
 * </p>
 * <p>
 * This class may be instantiated by clients, but is not intended to be
 * subclassed.
 * </p>
 * 
 * @@author Chris McGee
 * @@autor Christian W. Damus (cdamus)
 */
public class PathmapsPreferencePage
    extends PreferencePage
    implements IWorkbenchPreferencePage {

    private static final String NAME_ATTRIBUTE = "name"; //$NON-NLS-1$

    private IPathVariableManager pathVariableManager = ResourcesPlugin
        .getWorkspace().getPathVariableManager();

    private Composite pathVariablesComposite;
    
    private CheckboxTableViewer pathVariables;

    private PathVariableContentProvider pathVariablesContent;

    private Button newVariable;

    private Button editVariable;

    private Button removeVariable;

    /** Path variable changes since last time the Apply button was pressed. */
    private Map variableChanges = new HashMap();

    private Object addedToken = new Object();

    private Object changedToken = new Object();

    private Object removedToken = new Object();

    protected void initHelp() {
        // No context-sensitive help for now.
    }

    protected Control createContents(Composite parent) {
        GridData gridData = null;
        Composite composite = new Composite(parent, SWT.NONE);
        composite.setFont(parent.getFont());

        composite.setLayout(new GridLayout(2, false));

        PreferenceLinkArea pathVariablesArea = new PreferenceLinkArea(
            composite,
            SWT.NONE,
            "org.eclipse.ui.preferencePages.LinkedResources", //$NON-NLS-1$
            EMFUIMessages.PathmapsPreferencePage_mainDescription,
            (IWorkbenchPreferenceContainer) getContainer(), null);
        gridData = new GridData(GridData.FILL_HORIZONTAL
            | GridData.FILL_VERTICAL);
        gridData.grabExcessHorizontalSpace = true;
        gridData.grabExcessVerticalSpace = false;
        gridData.horizontalSpan = 2;
        pathVariablesArea.getControl().setLayoutData(gridData);

        Label pathVariablesLabel = new Label(composite, SWT.LEFT);
        gridData = new GridData(GridData.FILL_HORIZONTAL
            | GridData.FILL_VERTICAL);
        gridData.grabExcessHorizontalSpace = true;
        gridData.grabExcessVerticalSpace = false;
        gridData.horizontalSpan = 2;
        gridData.verticalIndent = 20;
        pathVariablesLabel.setLayoutData(gridData);
        pathVariablesLabel
            .setText(EMFUIMessages.PathmapsPreferencePage_availablePathVariables);

        pathVariablesComposite = new Composite(composite, SWT.BORDER);
        gridData = new GridData(GridData.FILL_HORIZONTAL
            | GridData.FILL_VERTICAL);
        gridData.grabExcessHorizontalSpace = true;
        gridData.grabExcessVerticalSpace = true;
        gridData.horizontalSpan = 1;
        pathVariablesComposite.setLayoutData(gridData);
        GridLayout gridLayout = new GridLayout(1, true);
        gridLayout.marginHeight = 0;
        gridLayout.marginWidth = 0;
        gridLayout.horizontalSpacing = 0;
        gridLayout.verticalSpacing = 0;
        pathVariablesComposite.setLayout(gridLayout);

        pathVariables = CheckboxTableViewer.newCheckList(pathVariablesComposite,
            SWT.MULTI);

        pathVariablesContent = new PathVariableContentProvider();
        pathVariables.setContentProvider(pathVariablesContent);
        pathVariables.setLabelProvider(new PathVariableLabelProvider());
        pathVariables.setComparator(new PathVariableViewerComparator());
        gridData = new GridData(GridData.FILL_BOTH);
        gridData.grabExcessHorizontalSpace = true;
        gridData.grabExcessVerticalSpace = true;
        // These two hard coded values were borrowed from similar code in
        // org.eclipse.ui.internal.ide.dialogs.PathVariablesGroup
        gridData.heightHint = pathVariables.getTable().getItemHeight() * 7;
        gridData.widthHint = 332;
        pathVariables.getTable().setLayoutData(gridData);

        Composite buttonComposite = new Composite(composite, SWT.NONE);
        buttonComposite.setLayout(new GridLayout(1, false));
        gridData = new GridData(GridData.FILL_HORIZONTAL);
        gridData.grabExcessHorizontalSpace = false;
        gridData.grabExcessVerticalSpace = false;
        gridData.horizontalSpan = 1;
        gridData.verticalAlignment = GridData.BEGINNING;
        buttonComposite.setLayoutData(gridData);

        newVariable = new Button(buttonComposite, SWT.CENTER);
        newVariable.setText(EMFUIMessages.PathmapsPreferencePage_newVariable);
        setButtonLayoutData(newVariable);

        editVariable = new Button(buttonComposite, SWT.CENTER);
        editVariable.setText(EMFUIMessages.PathmapsPreferencePage_editVariable);
        setButtonLayoutData(editVariable);

        removeVariable = new Button(buttonComposite, SWT.CENTER);
        removeVariable
            .setText(EMFUIMessages.PathmapsPreferencePage_removeVariable);
        setButtonLayoutData(removeVariable);

        pathVariables
            .addSelectionChangedListener(new ISelectionChangedListener() {

                public void selectionChanged(SelectionChangedEvent event) {
                    pathVariableSelected(event.getSelection());
                }
            });

        pathVariables.addCheckStateListener(new ICheckStateListener() {

            public void checkStateChanged(CheckStateChangedEvent event) {
                pathVariableChecked(event, (PathVariableEntry) event
                    .getElement());
            }
        });

        newVariable.addSelectionListener(new SelectionAdapter() {

            public void widgetSelected(SelectionEvent e) {
                addPathVariable();
            }
        });

        editVariable.addSelectionListener(new SelectionAdapter() {

            public void widgetSelected(SelectionEvent e) {
                editPathVariable(pathVariables.getSelection());
            }
        });

        removeVariable.addSelectionListener(new SelectionAdapter() {

            public void widgetSelected(SelectionEvent e) {
                removePathVariable(pathVariables.getSelection());
            }
        });

        initializeContents();

        applyDialogFont(composite);

        pathVariableSelected(pathVariables.getSelection());

        return composite;
    }

    /**
     * Responds to the user's gesture to either check or uncheck the specified
     * <code>entry</code> in the path variables list. This may, according to
     * the status of the path variable entry, result in the user's change being
     * reverted (e.g., in the case of attempting to uncheck a variable
     * registered on the extension point). This works around the inability in
     * SWT to disable the checkbox of an item in a check-table (see <a
     * href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=76509">bug 76509</a>
     * for details).
     * 
     * @@param event
     *            the (un)check event
     * @@param entry
     *            the path variable entry that was (un)checked
     */
    private void pathVariableChecked(CheckStateChangedEvent event,
            PathVariableEntry entry) {
        if (event.getChecked()) {
            // validate the check
            if (validateSelection(entry, false)) {
                entry.setSelected(true);
            } else {
                event.getCheckable().setChecked(entry, false);
            }
        } else {
            // validate the uncheck
            if (validateDeselection(entry, false)) {
                entry.setSelected(false);
            } else {
                event.getCheckable().setChecked(entry, true);
            }
        }
    }

    /**
     * Handles the selection of zero or more path variables in the list,
     * updating the enablement state of the "Edit..." and "Remove" buttons.
     * 
     * @@param selection
     *            the new path variables list selection
     */
    private void pathVariableSelected(ISelection selection) {
        IStructuredSelection ssel = (IStructuredSelection) selection;

        editVariable.setEnabled(validateEdit(ssel, false));
        removeVariable.setEnabled(validateRemove(ssel, false));
    }

    /**
     * Updates the map of pending path variable changes to indicate that the
     * specified variable has been added by the user.
     * 
     * @@param variableName
     *            the name of the added variable
     */
    private void markAdded(String variableName) {
        Object currentChange = variableChanges.get(variableName);

        if (currentChange == removedToken) {
            // if we previously removed this variable's value, then it will
            // appear to be a change when we sync on apply
            variableChanges.put(variableName, changedToken);
        } else if (currentChange != changedToken) {
            // shouldn't have been a "changed" if we thought we were adding
            variableChanges.put(variableName, addedToken);
        }
    }

    /**
     * Queries whether the specified path variable has an add change pending, to
     * be applied when the OK/Apply button is pressed.
     * 
     * @@param variableName
     *            the path variable name
     * @@return <code>true</code> if the variable has a pending change that is
     *         an add; <code>false</code>, otherwise
     */
    boolean isAdded(String variableName) {
        return variableChanges.get(variableName) == addedToken;
    }

    /**
     * Updates the map of pending path variable changes to indicate that the
     * specified variable has been removed by the user.
     * 
     * @@param variableName
     *            the name of the removed variable
     */
    private void markRemoved(String variableName) {
        Object currentChange = variableChanges.get(variableName);

        if (currentChange == addedToken) {
            // it was added since the last apply? Just forget about it, then
            variableChanges.remove(variableName);
        } else {
            variableChanges.put(variableName, removedToken);
        }
    }

    /**
     * Queries whether the specified path variable has a remove change pending,
     * to be applied when the OK/Apply button is pressed.
     * 
     * @@param variableName
     *            the path variable name
     * @@return <code>true</code> if the variable has a pending change that is
     *         a removal; <code>false</code>, otherwise
     */
    boolean isRemoved(String variableName) {
        return variableChanges.get(variableName) == removedToken;
    }

    /**
     * Updates the map of pending path variable changes to indicate that the
     * specified variable's value has been changed by the user.
     * 
     * @@param variableName
     *            the name of the changed variable
     */
    private void markChanged(String variableName) {
        Object currentChange = variableChanges.get(variableName);

        if (currentChange == addedToken) {
            // do nothing in this case. If it was added, changing it doesn't
            // change the fact that it's a new variable
        } else {
            variableChanges.put(variableName, changedToken);
        }
    }

    /**
     * Queries whether the specified path variable has a change of value
     * pending, to be applied when the OK/Apply button is pressed.
     * 
     * @@param variableName
     *            the path variable name
     * @@return <code>true</code> if the variable has a pending change that is
     *         a value change; <code>false</code>, otherwise
     */
    boolean isChanged(String variableName) {
        return variableChanges.get(variableName) == changedToken;
    }

    /**
     * Queries whether the current pending path variables (not yet applied to
     * the workspace and GMF path map manager) has a variable referencing the
     * specified location. Note that this does not consider path variables that
     * are pending removal or others that are currently defined in the workspace
     * and/or GMF that are not visible.
     * 
     * @@param location
     *            a location
     * @@return <code>true</code> if any of the path variables showing in the
     *         preference page has the specified location; <code>false</code>,
     *         otherwise
     */
    boolean isLocationDefined(IPath location) {
        for (Iterator iter = pathVariablesContent.entries.iterator(); iter
            .hasNext();) {
            if (location.equals(((PathVariableEntry) iter.next())
                .getLocationPath())) {
                return true;
            }
        }

        return false;
    }

    /**
     * Handles the pushing of the "New..." button, to create a new path map
     * variable.
     */
    private void addPathVariable() {
        NewPathVariableDialog dlg = NewPathVariableDialog.openNew(this);
        if (dlg != null) {
            String name = dlg.getVariableName();
            IPath location = dlg.getVariableLocation();

            // prepare data for synchronization on apply
            markAdded(name);

            // by default, check the variable (if the user created it in this
            // pref page, assume that it should be used for GMF modeling)
            PathVariableEntry entry = new PathVariableEntry(name, location);
            entry.setSelected(true);
            pathVariablesContent.add(entry);
            pathVariables.setChecked(entry, true);

            // select the new path variable
            pathVariables.setSelection(new StructuredSelection(entry));
        }
    }

    /**
     * Handles the pushing of the "Edit..." button, to edit the path variable
     * contained in the specified <code>selection</code>.
     * 
     * @@param selection
     *            the current selection in the path variables list (should
     *            contain a single {@@link PathVariableEntry})
     */
    private void editPathVariable(ISelection selection) {
        PathVariableEntry entry = null;

        if (selection instanceof IStructuredSelection) {
            IStructuredSelection ssel = (IStructuredSelection) selection;

            if (!ssel.isEmpty()) {
                entry = (PathVariableEntry) ssel.getFirstElement();
            }
        }

        if (entry != null) {
            String oldName = entry.getName();
            NewPathVariableDialog dlg = NewPathVariableDialog.openEdit(this,
                oldName, entry.getLocation());

            if (dlg != null) {
                String newName = dlg.getVariableName();
                IPath newLocation = dlg.getVariableLocation();
                boolean nameChanged = !oldName.equals(newName);

                if (nameChanged) {
                    // changing the name is like removing the old name
                    // and adding the new name

                    // prepare data for synchronization on apply
                    markAdded(newName);
                    markRemoved(oldName);
                } else {
                    // prepare data for synchronization on apply
                    markChanged(oldName);
                }

                entry.setName(newName);
                entry.setLocation(newLocation);

                pathVariables.update(entry,
                    nameChanged ? new String[] {NAME_ATTRIBUTE}
                        : null);
            }
        }
    }

    /**
     * Handles the pushing of the "Remove" button, to remove the path
     * variable(s) contained in the specified <code>selection</code>.
     * 
     * @@param selection
     *            the current selection in the path variables list (should
     *            contain one or more {@@link PathVariableEntry}s of which none
     *            is registered on the extension point)
     */
    private void removePathVariable(ISelection selection) {
        Iterator entries = null;

        if (selection instanceof IStructuredSelection) {
            IStructuredSelection ssel = (IStructuredSelection) selection;

            if (!ssel.isEmpty()) {
                entries = ssel.iterator();
            }
        }

        if (entries != null) {
            while (entries.hasNext()) {
                PathVariableEntry entry = (PathVariableEntry) entries.next();
                String name = entry.getName();

                // prepare data for synchronization on apply
                markRemoved(name);

                pathVariablesContent.remove(entry);
            }
        }
    }

    /**
     * Validates an attempt to check a previously unchecked path variable in the
     * list, optionally showing an error explaining the reason why this is not
     * permitted.
     * 
     * @@param entry
     *            a path variable that the user attempted to check
     * @@param showError
     *            whether to show any potential error message in the title area
     * @@return whether the checking of this variable is permitted
     */
    private boolean validateSelection(PathVariableEntry entry, boolean showError) {
        String name = entry.getName();

        if (!PathmapManager.isCompatiblePathVariable(name)) {
            if (showError) {
                setMessage(
                    EMFUIMessages.PathmapsPreferencePage_incompatiblePathVariableErrorMessage,
                    ERROR);
            }
            return false;
        }

        if (PathmapManager.isRegisteredPathVariable(name)) {
            if (showError) {
                setMessage(
                    EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
                    ERROR);
            }
            return false;
        }

        return true;
    }

    /**
     * Validates an attempt to uncheck a previously checked path variable in the
     * list, optionally showing an error explaining the reason why this is not
     * permitted.
     * 
     * @@param entry
     *            a path variable that the user attempted to uncheck
     * @@param showError
     *            whether to show any potential error message in the title area
     * @@return whether the unchecking of this variable is permitted
     */
    private boolean validateDeselection(PathVariableEntry entry,
            boolean showError) {
        if (entry.isRequired()) {
            if (showError) {
                setMessage(
                    EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
                    ERROR);
            }
            return false;
        }

        return true;
    }

    /**
     * Queries whether it is permitted to edit the specified
     * <code>selection</code> of path variables. Editing is only permitted for
     * a single selection that is not a registered path variable.
     * 
     * @@param selection
     *            the current selection in the path variables list
     * @@param showError
     *            whether to show any potential error message in the title area
     * @@return whether the editing of this selection is permitted
     */
    private boolean validateEdit(IStructuredSelection selection,
            boolean showError) {
        if (selection.isEmpty() || (selection.size() > 1)) {
            return false;
        }

        String name = ((PathVariableEntry) selection.getFirstElement())
            .getName();

        if (PathmapManager.isRegisteredPathVariable(name)) {
            if (showError) {
                setMessage(
                    EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
                    ERROR);
            }

            return false;
        }

        return true;
    }

    /**
     * Queries whether it is permitted to remove the specified
     * <code>selection</code> of path variables. Removal is only permitted
     * when the selection is not empty and does not contain any registered path
     * variable.
     * 
     * @@param selection
     *            the current selection in the path variables list
     * @@param showError
     *            whether to show any potential error message in the title area
     * @@return whether the editing of this selection is permitted
     */
    private boolean validateRemove(IStructuredSelection selection,
            boolean showError) {
        if (selection.isEmpty()) {
            return false;
        }

        for (Iterator iter = selection.iterator(); iter.hasNext();) {
            String name = ((PathVariableEntry) iter.next()).getName();

            if (PathmapManager.isRegisteredPathVariable(name)) {
                if (showError) {
                    setMessage(
                        EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
                        ERROR);
                }

                return false;
            }
        }

        return true;
    }

    /**
     * Loads the contents of the Path Variables list, additionally setting the
     * check state of each variable.
     */
    private void initializeContents() {
        setMessage(null);

        variableChanges.clear();

        Set currentVariables = PathmapManager.getPathVariableReferences();

        Set allVariables = new HashSet();
        Set checkedVariables = new HashSet();

        Set pathVariableNames = new HashSet();
        pathVariableNames.addAll(Arrays.asList(pathVariableManager
            .getPathVariableNames()));
        pathVariableNames.addAll(PathmapManager.getAllPathVariables());

        for (Iterator iter = pathVariableNames.iterator(); iter.hasNext();) {
            String name = (String) iter.next();
            PathVariableEntry entry;

            if (PathmapManager.isRegisteredPathVariable(name)) {
                String value = PathmapManager.getRegisteredValue(name);

                try {
                    URI uri = URI.createURI(value);

                    if (uri.isFile()) {
                        // show the user a familiar file system path instead
                        // of a URI
                        value = uri.toFileString();
                    }
                } catch (RuntimeException e) {
                    // the value is not a valid URI. Nothing for us to
                    // do; that is a problem for the plug-in developer
                    // who registered this path map. We'll show the
                    // value as is
                }

                entry = new PathVariableEntry(name, value);
                checkedVariables.add(entry);
                allVariables.add(entry);
            } else if (PathmapManager.isCompatiblePathVariable(name)) {

                entry = new PathVariableEntry(name, pathVariableManager
                    .getValue(name));

                if (currentVariables.contains(entry.getName())) {
                    checkedVariables.add(entry);
                    entry.setSelected(true);
                }

                allVariables.add(entry);
            }
        }

        pathVariables.setInput(allVariables);
        pathVariables.setCheckedElements(checkedVariables.toArray());
    }

    public void init(IWorkbench workbench) {
        // No initialization is necessary.
    }

    protected void performDefaults() {
        initializeContents();
        super.performDefaults();
    }

    /**
     * Applies the current check state of every path variable to the GMF
     * {@@link PathmapManager}'s list of path variable references and saves the
     * preference store.
     */
    public boolean performOk() {
        Set currentVariables = PathmapManager.getPathVariableReferences();

        try {
            // first, process the removed workspace path variables
            for (Iterator iter = variableChanges.keySet().iterator(); iter
                .hasNext();) {
                String name = (String) iter.next();

                if (isRemoved(name)) {
                    if (pathVariableManager.isDefined(name)) {
                        pathVariableManager.setValue(name, null);
                    }

                    PathmapManager.removePathVariableReference(name);

                    iter.remove(); // successfully processed this change
                }
            }

            // next, process the current set of path variable references to
            // add/remove them according to the user's preferences
            Object[] variables = pathVariablesContent.getElements(null);
            for (int i = 0; i < variables.length; i++) {
                PathVariableEntry entry = (PathVariableEntry) variables[i];
                String name = entry.getName();

                if (isChanged(name) || isAdded(name)
                    && !pathVariableManager.isDefined(name)) {
                    // set the workspace path variable's new value, now
                    pathVariableManager.setValue(name, new Path(entry
                        .getLocation()));

                    // successfully processed this change
                    variableChanges.remove(name);
                }

                if (entry.isSelected() && !currentVariables.contains(name)) {
                    PathmapManager.addPathVariableReference(name);
                } else if (!entry.isSelected()
                    && currentVariables.contains(name)) {
                    PathmapManager.removePathVariableReference(name);
                }
            }

            PathmapManager.updatePreferenceStore();

            return true;
        } catch (CoreException e) {
            ErrorDialog.openError(getShell(),
                EMFUIMessages.PathmapsPreferencePage_promptTitle,
                EMFUIMessages.PathmapsPreferencePage_updateFailed, e
                    .getStatus());
            return false;
        }
    }

    /**
     * A content provider for the Path Variables list.
     */
    private static class PathVariableContentProvider
        implements IStructuredContentProvider {

        private Set entries;

        private TableViewer table;

        PathVariableContentProvider() {
            entries = new HashSet();
        }

        /**
         * Adds a path variable to the list.
         * 
         * @@param entry
         *            the new path variable
         */
        void add(PathVariableEntry entry) {
            if (!entries.contains(entry)) {
                entries.add(entry);
                table.add(entry);
            }
        }

        /**
         * Removes a path variable from the list.
         * 
         * @@param entry
         *            the path variable to remove
         */
        void remove(PathVariableEntry entry) {
            if (entries.contains(entry)) {
                entries.remove(entry);
                table.remove(entry);
            }
        }

        public Object[] getElements(Object inputElement) {
            return entries.toArray();
        }

        public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
            entries = (Set) newInput;
            table = (TableViewer) viewer;
        }

        public void dispose() {
            // nothing to clean up
        }
    }

    /**
     * A label provider for the Path Variables list.
     */
    private static class PathVariableLabelProvider
        implements ITableLabelProvider, IColorProvider {

        private Image lockImage = null;

        PathVariableLabelProvider() {
            super();
        }

        /**
         * Shows a lock icon for registered path variables.
         */
        public Image getColumnImage(Object element, int columnIndex) {
            PathVariableEntry entry = (PathVariableEntry) element;
            String name = entry.getName();

            if (PathmapManager.isRegisteredPathVariable(name)) {
                return getLockImage();
            } else if (!isDirectory(entry.getLocation())) {
                return MslUIPlugin.getDefault().getWorkbench()
                    .getSharedImages()
                    .getImage(ISharedImages.IMG_OBJS_WARN_TSK);
            }

            return null;
        }

        /**
         * Queries whether the specified location references a directory that
         * exists.
         * 
         * @@param location
         *            a location
         * @@return <code>true</code> if the location exists in the filesystem
         *         and is a directory
         */
        private boolean isDirectory(String location) {
            File file = new File(location);

            return file.exists() && file.isDirectory();
        }

        /**
         * Obtains the lazily-initialized lock image.
         * 
         * @@return the lock image
         */
        private Image getLockImage() {
            if (lockImage == null) {
                lockImage = MslUIPlugin
                    .imageDescriptorFromPlugin(MslUIPlugin.getPluginId(),
                        "/icons/full/lock.gif").createImage(); //$NON-NLS-1$
            }

            return lockImage;
        }

        /**
         * Path variables are displayed in the same way as in the Linked
         * Resources preference page.
         */
        public String getColumnText(Object element, int columnIndex) {
            if (columnIndex != 0) {
                return null;
            }

            PathVariableEntry entry = (PathVariableEntry) element;

            // use the TextProcessor's default separators for file paths
            // if the entry is not required, because only if it is, will
            // it possibly be a URI
            String pathString = entry.isRequired() ? TextProcessor.process(
                entry.getLocation(), MslUIPlugin.URI_BIDI_SEPARATORS)
                : TextProcessor.process(entry.getLocation());

            return NLS.bind(
                EMFUIMessages.PathmapsPreferencePage_variablePattern, entry
                    .getName(), pathString);
        }

        public void dispose() {
            if (lockImage != null) {
                lockImage.dispose();
                lockImage = null;
            }
        }

        public boolean isLabelProperty(Object element, String property) {
            return false;
        }

        public void addListener(ILabelProviderListener listener) {
            // not using listeners
        }

        public void removeListener(ILabelProviderListener listener) {
            // not using listeners
        }

        public Color getBackground(Object element) {
            return null;
        }

        public Color getForeground(Object element) {
            return null;
        }
    }

    /**
     * A sorter for the Path Variables list. All registered path maps sort to
     * the bottom of the list to keep them out of the user's way.
     */
    private static class PathVariableViewerComparator
        extends ViewerComparator {

        PathVariableViewerComparator() {
            super();
        }

        /**
         * We sort by <code>name</code>.
         */
        public boolean isSorterProperty(Object element, String property) {
            return NAME_ATTRIBUTE.equals(property);
        }

        /**
         * Registered variables are in a higher category than user variables.
         */
        public int category(Object element) {
            // sort statically-registered variables to the end of the list
            return PathmapManager
                .isRegisteredPathVariable(((PathVariableEntry) element)
                    .getName()) ? 1
                : 0;
        }
    }

    /**
     * Data model for a path variable in the Path Variables list.
     */
    private static final class PathVariableEntry {

        private String name;

        private String location;

        private IPath locationPath;

        private final boolean required;

        private boolean selected;

        /**
         * Initializes a user-defined path variable with the name and location
         * path.
         * 
         * @@param name
         *            the variable name
         * @@param location
         *            the location
         */
        PathVariableEntry(String name, IPath location) {
            this(name, location.toPortableString(), false);

            this.locationPath = location;
        }

        /**
         * Initializes a registered path variable with the name and location
         * derived from the URI.
         * 
         * @@param name
         *            the variable name
         * @@param location
         *            the location URI
         */
        PathVariableEntry(String name, String location) {
            this(name, location, true);
        }

        private PathVariableEntry(String name, String location, boolean required) {
            this.name = name;
            this.location = location;
            this.required = required;
            selected = required;
        }

        /**
         * Queries whether this path variable is required (a registered path
         * variable that the user cannot edit, remove, or uncheck).
         * 
         * @@return whether I am required
         */
        boolean isRequired() {
            return required;
        }

        /**
         * Obtains the path variable name.
         * 
         * @@return my name
         */
        String getName() {
            return name;
        }

        /**
         * Sets the path variable name, if it is editable.
         * 
         * @@param name
         *            the new name
         */
        void setName(String name) {
            if (!isRequired()) {
                this.name = name;
            }
        }

        /**
         * Obtains the path variable location.
         * 
         * @@return my location
         */
        String getLocation() {
            return location;
        }

        /**
         * Obtains the path variable location, as an {@@link IPath}.
         * 
         * @@return my location
         */
        IPath getLocationPath() {
            return locationPath;
        }

        /**
         * Sets the path variable name, if it is editable.
         * 
         * @@param location
         *            the new location
         */
        void setLocation(IPath location) {
            if (!isRequired()) {
                this.locationPath = location;
                this.location = location.toPortableString();
            }
        }

        /**
         * Queries whether the path variable is checked. Required (registered)
         * path variables are always checked.
         * 
         * @@return whether I am checked
         */
        boolean isSelected() {
            return selected;
        }

        /**
         * Sets whether the path variable is checked, if it is not registered.
         * 
         * @@param selected
         *            whether I am checked
         */
        void setSelected(boolean selected) {
            if (!isRequired()) {
                this.selected = selected;
            }
        }

        /**
         * Displays path variable's debug string.
         */
        public String toString() {
            return getName() + " - " + getLocation(); //$NON-NLS-1$
        }
    }
}
@


1.9
log
@[179192] gmf_head crevells 070412 BIDI3.3:HCG_GMF: Wrong direction for PathMap in rtl eclipse
Contributed by: Christian Damus
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
a50 1
import org.eclipse.swt.custom.ScrolledComposite;
d91 2
a92 2
    private ScrolledComposite pathVariablesScroll;

d147 1
a147 4
        pathVariablesScroll = new ScrolledComposite(composite, SWT.BORDER
            | SWT.H_SCROLL | SWT.V_SCROLL);
        pathVariablesScroll.setExpandHorizontal(true);
        pathVariablesScroll.setExpandVertical(true);
d153 7
a159 1
        pathVariablesScroll.setLayoutData(gridData);
d161 1
a161 1
        pathVariables = CheckboxTableViewer.newCheckList(pathVariablesScroll,
a162 1
        pathVariablesScroll.setContent(pathVariables.getTable());
d168 8
@


1.8
log
@[159650] gmf_head crevells 070221 Pathmaps Preference Page is not easy to use
Contributed by: Christian Damus
@
text
@d49 1
d898 8
d908 1
a908 1
                    .getName(), entry.getLocation());
@


1.7
log
@[162464] gmf_head crevells 070209 Path Maps preference page uses wrong colours
Contributed by: Christian Damus
@
text
@d14 3
d19 1
a21 2
import org.eclipse.core.resources.IPathVariableChangeEvent;
import org.eclipse.core.resources.IPathVariableChangeListener;
d24 1
d26 1
a26 1
import org.eclipse.emf.common.CommonPlugin;
d31 1
d33 3
d38 1
d48 1
d51 1
a51 4
import org.eclipse.swt.events.ControlAdapter;
import org.eclipse.swt.events.ControlEvent;
import org.eclipse.swt.events.MouseEvent;
import org.eclipse.swt.events.MouseTrackAdapter;
a52 1
import org.eclipse.swt.events.SelectionListener;
a54 1
import org.eclipse.swt.graphics.Point;
d61 1
a61 2
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.swt.widgets.TableItem;
d70 1
a70 1
 * <P>
d73 5
d80 1
d83 39
a121 1
	extends PreferencePage implements IWorkbenchPreferencePage {
a122 26
	private ScrolledComposite referencedPathVariablesScroll;
	private TableViewer referencedPathVariables;
	private StringsContentProvider referencedPathVariablesContent;
	private ScrolledComposite pathVariablesScroll;
	private TableViewer pathVariables;
	private StringsContentProvider pathVariablesContent;
	private Button add;
	private Button remove;
	private IPathVariableChangeListener pathVariableChangeListener;
	private boolean disposed = true;

	protected void initHelp() {
		// No context-sensitive help for now.
	}

	protected Control createContents(Composite parent) {
		GridData gridData = null;
		Composite composite = new Composite(parent, SWT.NONE);
		composite.setFont(parent.getFont());
		
		composite.setLayout(new GridLayout(3, false));
		gridData = new GridData(GridData.FILL_HORIZONTAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.horizontalSpan = 2;
		composite.setLayoutData(gridData);
		
d126 2
a127 1
            "org.eclipse.ui.preferencePages.LinkedResources", EMFUIMessages.PathmapsPreferencePage_mainDescription, //$NON-NLS-1$
d129 704
a832 471
		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = false;
		gridData.horizontalSpan = 3;
		pathVariablesArea.getControl().setLayoutData(gridData);
		
		Composite pathVariablesComposite = new Composite(composite, SWT.NONE);
		pathVariablesComposite.setLayout(new GridLayout(1, false));
		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = true;
		gridData.horizontalSpan = 1;
		pathVariablesComposite.setLayoutData(gridData);
		
		Label pathVariablesLabel = new Label(pathVariablesComposite, SWT.LEFT);
		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = false;
		gridData.horizontalSpan = 2;
		gridData.verticalIndent = 20;
		pathVariablesLabel.setLayoutData(gridData);
		pathVariablesLabel.setText(EMFUIMessages.PathmapsPreferencePage_availablePathVariables);
		
		pathVariablesScroll = new ScrolledComposite(
				pathVariablesComposite, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
		pathVariablesScroll.setExpandHorizontal(true);
		pathVariablesScroll.setExpandVertical(true);
		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = true;
		gridData.horizontalSpan = 1;
		pathVariablesScroll.setLayoutData(gridData);
		pathVariables = new TableViewer(pathVariablesScroll, SWT.MULTI);
		pathVariablesScroll.setContent(pathVariables.getTable());
		
		TableColumn column = new TableColumn(pathVariables.getTable(), SWT.LEFT);
		column.setMoveable(false);
		column.setResizable(false);
		pathVariables.getTable().addControlListener(new ControlAdapter() {
			public void controlResized(ControlEvent e) {
				pathVariables.getTable().getColumn(0).setWidth(
						pathVariables.getTable().getClientArea().width);
			}});
		pathVariablesContent = new StringsContentProvider();
		pathVariables.setContentProvider(pathVariablesContent);
		pathVariables.setLabelProvider(new StringsLabelProvider());
		pathVariables.setComparator(new StringsViewerComparator());
		
		Composite buttonComposite = new Composite(composite, SWT.NONE);
		buttonComposite.setLayout(new GridLayout(1, false));
		add = new Button(buttonComposite, SWT.CENTER);
		add.setText(EMFUIMessages.PathmapsPreferencePage_addChevron);
		gridData = new GridData(GridData.FILL_HORIZONTAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = false;
		gridData.horizontalSpan = 1;
		add.setLayoutData(gridData);
		Button addAll = new Button(buttonComposite, SWT.CENTER);
		addAll.setText(EMFUIMessages.PathmapsPreferencePage_addAllChevron);
		gridData = new GridData(GridData.FILL_HORIZONTAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = false;
		addAll.setLayoutData(gridData);
		remove = new Button(buttonComposite,SWT.CENTER);
		remove.setText(EMFUIMessages.PathmapsPreferencePage_removeChevron);
		gridData = new GridData(GridData.FILL_HORIZONTAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = false;
		gridData.horizontalSpan = 1;
		gridData.verticalIndent = 10;
		remove.setLayoutData(gridData);
		Button removeAll = new Button(buttonComposite, SWT.CENTER);
		removeAll.setText(EMFUIMessages.PathmapsPreferencePage_removeAllChevron);
		gridData = new GridData(GridData.FILL_HORIZONTAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = false;
		gridData.horizontalSpan=1;
		removeAll.setLayoutData(gridData);
		
		gridData = new GridData(GridData.FILL_HORIZONTAL);
		gridData.grabExcessHorizontalSpace = false;
		gridData.grabExcessVerticalSpace = false;
		gridData.horizontalSpan = 1;
		buttonComposite.setLayoutData(gridData);
		
		Composite referencedPathVariablesComposite = new Composite(composite, SWT.NONE);
		referencedPathVariablesComposite.setLayout(new GridLayout(1, false));
		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = true;
		gridData.horizontalSpan = 1;
		referencedPathVariablesComposite.setLayoutData(gridData);
		
		Label referencedPathVariablesLabel = new Label(referencedPathVariablesComposite, SWT.LEFT);
		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = false;
		gridData.horizontalSpan = 1;
		gridData.verticalIndent = 20;
		referencedPathVariablesLabel.setLayoutData(gridData);
		referencedPathVariablesLabel.setText(EMFUIMessages.PathmapsPreferencePage_pathVariablesUsedInModeling);
		
		referencedPathVariablesScroll = new ScrolledComposite(
				referencedPathVariablesComposite, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
		referencedPathVariablesScroll.setExpandHorizontal(true);
		referencedPathVariablesScroll.setExpandVertical(true);
		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = true;
		gridData.horizontalSpan = 1;
		referencedPathVariablesScroll.setLayoutData(gridData);
		referencedPathVariables = new TableViewer(referencedPathVariablesScroll, SWT.MULTI);
		referencedPathVariablesScroll.setContent(referencedPathVariables.getTable());
		
		column = new TableColumn(referencedPathVariables.getTable(), SWT.LEFT);
		column.setMoveable(false);
		column.setResizable(false);
		referencedPathVariables.getTable().addControlListener(new ControlAdapter() {
			public void controlResized(ControlEvent e) {
				referencedPathVariables.getTable().getColumn(0).setWidth(
						referencedPathVariables.getTable().getClientArea().width);
			}});
		referencedPathVariablesContent = new StringsContentProvider();
		referencedPathVariables.setContentProvider(referencedPathVariablesContent);
		referencedPathVariables.setLabelProvider(new StringsLabelProvider(true));
		referencedPathVariables.setComparator(new StringsViewerComparator());
		
		// adjust the scroll bars whenever the preference page is resized
		composite.addControlListener(new ControlAdapter() {
			public void controlResized(ControlEvent e) {
				adjustScrollpanes();
			}});
		
		pathVariables.getTable().addMouseTrackListener(new MouseTrackAdapter() {
			public void mouseHover(MouseEvent e) {
				TableItem item = pathVariables.getTable().getItem(new Point(e.x, e.y));
				String tip = null;
				
				if (item != null) {
					String var = item.getText(0);
					tip = getValue(var, false);
				}
				
				pathVariables.getTable().setToolTipText(tip);
			}});
		
		pathVariables.addSelectionChangedListener(new ISelectionChangedListener() {
			public void selectionChanged(SelectionChangedEvent event) {
				if (!event.getSelection().isEmpty()) { // prevent oscillation
					referencedPathVariables.setSelection(new StructuredSelection());
					remove.setEnabled(true);
					
					if (!validateAdditions((IStructuredSelection) event.getSelection(), true)) {
						add.setEnabled(false);
					} else {
						setMessage(null);
						add.setEnabled(true);
					}
				}
			}
		});
		
		referencedPathVariables.getTable().addMouseTrackListener(new MouseTrackAdapter() {
			public void mouseHover(MouseEvent e) {
				TableItem item = referencedPathVariables.getTable().getItem(
						new Point(e.x, e.y));
				String tip = null;
				
				if (item != null) {
					String var = item.getText(0);
					tip = getValue(var, true);
				}
				
				referencedPathVariables.getTable().setToolTipText(tip);
			}});
		
		referencedPathVariables.addSelectionChangedListener(new ISelectionChangedListener() {
			public void selectionChanged(SelectionChangedEvent event) {
				if (!event.getSelection().isEmpty()) { // prevent oscillation
					add.setEnabled(true);
					pathVariables.setSelection(new StructuredSelection());
					
					if (!validateRemovals((IStructuredSelection) event.getSelection(), true)) {
						remove.setEnabled(false);
					} else {
						setMessage(null);
						remove.setEnabled(true);
					}
				}
			}
		});
		
		add.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				IStructuredSelection selection =
					(IStructuredSelection) pathVariables.getSelection();
				
				for (Iterator iter = selection.iterator(); iter.hasNext();) {
					String name = (String) iter.next();
					pathVariablesContent.remove(name);
					referencedPathVariablesContent.add(name);
					adjustScrollpanes();
				}
			}

			public void widgetDefaultSelected(SelectionEvent e) {
				// No action is necessary
			}
		});
		
		addAll.addSelectionListener(new SelectionListener() {
			public void widgetDefaultSelected(SelectionEvent e) {
				// No action necessary
			}

			public void widgetSelected(SelectionEvent e) {
				Object[] items = pathVariablesContent.getElements(null);
				
				for (int i=items.length - 1; i >= 0; i--) {
					if (validateAdditions(new StructuredSelection(items[i]), false)) {
						String name = (String) items[i];
						pathVariablesContent.remove(name);
						referencedPathVariablesContent.add(name);
						adjustScrollpanes();
					}
				}
			}
		});
		
		remove.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				IStructuredSelection selection =
					(IStructuredSelection) referencedPathVariables.getSelection();
				
				for (Iterator iter = selection.iterator(); iter.hasNext();) {
					String name = (String) iter.next();
					referencedPathVariablesContent.remove(name);
					pathVariablesContent.add(name);
					adjustScrollpanes();
				}
			}

			public void widgetDefaultSelected(SelectionEvent e) {
				// No action is necessary
			}
		});
		
		removeAll.addSelectionListener(new SelectionListener() {
			public void widgetDefaultSelected(SelectionEvent e) {
				// No action is necessary
			}

			public void widgetSelected(SelectionEvent e) {
				Object[] items = referencedPathVariablesContent.getElements(null);
				
				for (int i=items.length - 1; i >= 0; i--) {
					if (validateRemovals(new StructuredSelection(items[i]), false)) {
						String name = (String) items[i];
						referencedPathVariablesContent.remove(name);
						pathVariablesContent.add(name);
						adjustScrollpanes();
					}
				}
			}
		});
		
		initializeContents();
		
		// In case of any changes to the path variables, we will refresh ourselves to show
		//  the up-to-date information.
		pathVariableChangeListener = new IPathVariableChangeListener() {
			public void pathVariableChanged(IPathVariableChangeEvent event) {
				referencedPathVariables.getTable().getDisplay().asyncExec(new Runnable() {
					public void run() {
						if (!PathmapsPreferencePage.this.disposed) {
							performDefaults();
						}
					}
				});
			}
		};
		ResourcesPlugin.getWorkspace().getPathVariableManager().addChangeListener(pathVariableChangeListener);
		
		disposed = false;
		
		applyDialogFont(composite);
		
		return composite;
	}
	
	private void adjustScrollpanes() {
		pathVariablesScroll.setMinSize(
				pathVariables.getTable().computeSize(SWT.DEFAULT, SWT.DEFAULT));
		pathVariablesScroll.layout();
		referencedPathVariablesScroll.setMinSize(
				referencedPathVariables.getTable().computeSize(SWT.DEFAULT, SWT.DEFAULT));
		referencedPathVariablesScroll.layout();
	}
	
	private String getValue(String pathVariable, boolean includeRegistered) {
		String result = null;
		
		if (includeRegistered && PathmapManager.isRegisteredPathVariable(pathVariable)) {
			String path = PathmapManager.getRegisteredValue(pathVariable);
			
			if (path != null) {
				URI uri = URI.createURI(path);
				uri = CommonPlugin.resolve(uri);
				
				if (uri.isFile()) {
					path = uri.toFileString();
				} else {
					path = uri.toString();
				}
				
				result = path;
			}
		} else {
			IPathVariableManager pathVarMgr =
				ResourcesPlugin.getWorkspace().getPathVariableManager();
			
			IPath path = pathVarMgr.getValue(pathVariable);
			
			if (path != null) {
				result = path.toOSString();
			}
		}
		
		return result;
	}
	
	private boolean validateAdditions(IStructuredSelection selection, boolean showError) {
		if (selection.isEmpty())
			return false;
		
		for (Iterator iter = selection.iterator(); iter.hasNext();) {
			String name = (String) iter.next();
			
			if (!PathmapManager.isCompatiblePathVariable(name)) {
				if (showError) {
					setMessage(EMFUIMessages.PathmapsPreferencePage_incompatiblePathVariableErrorMessage,ERROR);
				}
				return false;
			}
			
			if (PathmapManager.isRegisteredPathVariable(name)) {
				if (showError) {
					setMessage(EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,ERROR);
				}
				return false;
			}
		}
		return true;
	}

	private boolean validateRemovals(IStructuredSelection selection, boolean showError) {
		if (selection.isEmpty())
			return false;
		
		for (Iterator iter = selection.iterator(); iter.hasNext();) {
			String name = (String) iter.next();
			
			if (PathmapManager.isRegisteredPathVariable(name)) {
				if (showError) {
					setMessage(EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,ERROR);
				}
				return false;
			}
		}
		return true;
	}

	private void initializeContents() {
		setMessage(null);
		add.setEnabled(true);
		remove.setEnabled(true);
		
		referencedPathVariables.setInput(new HashSet(PathmapManager.getAllPathVariables()));
		
		Set currentVariables = PathmapManager.getPathVariableReferences();
		
		Set available = new HashSet();
		String[] pathVariableNames = ResourcesPlugin.getWorkspace().getPathVariableManager().getPathVariableNames();
		for (int i=0; i<pathVariableNames.length; i++) {
			if (!currentVariables.contains(pathVariableNames[i])) {
				available.add(pathVariableNames[i]);
			}
		}
		
		pathVariables.setInput(available);
	}

	public void init(IWorkbench workbench) {
		// No initialization is necessary.
	}
	
	protected void performDefaults() {
		initializeContents();
		super.performDefaults();
	}
	
	public boolean performOk() {
		Object[] nonReferencedPathVariables = pathVariablesContent.getElements(null);
		for (int i=0; i<nonReferencedPathVariables.length; i++) {
			String variableName = (String) nonReferencedPathVariables[i];
			PathmapManager.removePathVariableReference(variableName);
		}
		
		Set currentVariables = PathmapManager.getAllPathVariables();
		Object[] variablesToReference = referencedPathVariablesContent.getElements(null);
		for (int i=0; i<variablesToReference.length; i++) {
			String variableName = (String) variablesToReference[i];
			
			if (!currentVariables.contains(variableName)) {
				PathmapManager.addPathVariableReference(variableName);
			}
		}
		
		PathmapManager.updatePreferenceStore();
		
		return true;
	}
	
	public void dispose() {
		disposed = true;
		if (pathVariableChangeListener != null) {
			ResourcesPlugin.getWorkspace().getPathVariableManager().removeChangeListener(pathVariableChangeListener);
			pathVariableChangeListener = null;
		}
		super.dispose();
	}
	
	private static class StringsContentProvider implements IStructuredContentProvider {
		private Set strings;
		private TableViewer table;
		
		StringsContentProvider() {
			strings = new HashSet();
		}
		
		void add(String string) {
			if (!strings.contains(string)) {
				strings.add(string);
				table.add(string);
			}
		}
		
		void remove(String string) {
			if (strings.contains(string)) {
				strings.remove(string);
				table.remove(string);
			}
		}
		
		public Object[] getElements(Object inputElement) {
			return strings.toArray();
		}

		public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
			strings = (Set) newInput;
			table = (TableViewer) viewer;
		}

		public void dispose() {
			// nothing to clean up
		}
	}
	
	private static class StringsLabelProvider implements ITableLabelProvider, IColorProvider {
		private final boolean isReferencedPathVariables;
        
d834 13
a846 11
		
		StringsLabelProvider() {
			this(false);
		}
		
		StringsLabelProvider(boolean isReferencedPathVariables) {
			this.isReferencedPathVariables = isReferencedPathVariables;
		}
		
		public Image getColumnImage(Object element, int columnIndex) {
            if (isReferencedPathVariables && PathmapManager.isRegisteredPathVariable((String) element)) {
d848 4
d853 24
a876 4
            
			return null;
		}
        
d879 3
a881 2
                lockImage = MslUIPlugin.imageDescriptorFromPlugin(
                    MslUIPlugin.getPluginId(), "/icons/full/lock.gif").createImage(); //$NON-NLS-1$
d883 1
a883 1
            
d887 18
a904 7
		public String getColumnText(Object element, int columnIndex) {
			return (columnIndex == 0) ? (String) element : null;
		}

		public void dispose() {
			if (lockImage != null) {
			    lockImage.dispose();
d907 142
a1048 1
		}
d1050 51
a1100 31
		public boolean isLabelProperty(Object element, String property) {
			return false;
		}

		public void addListener(ILabelProviderListener listener) {
			// not using listeners
		}

		public void removeListener(ILabelProviderListener listener) {
			// not using listeners
		}

		public Color getBackground(Object element) {
			return null;
		}

		public Color getForeground(Object element) {
			return null;
		}
	}
	
	private static class StringsViewerComparator extends ViewerComparator {
		StringsViewerComparator() {
			super();
		}
		
		public int category(Object element) {
			// sort statically-registered variables to the end of the list
			return PathmapManager.isRegisteredPathVariable((String) element)? 1 : 0;
		}
	}
@


1.6
log
@[143533], gmf_head, contributed  by cdamus, 060524, [EMF UI] Should how pathmap variable values in preference page
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
d26 1
a55 1
import org.eclipse.swt.widgets.Display;
d577 2
d589 4
d595 9
d610 4
a613 1
			// nothing to dispose (the colors are all shared system colors)
a628 5
			if (isReferencedPathVariables && PathmapManager.isRegisteredPathVariable((String) element)) {
				return Display.getDefault().getSystemColor(
						SWT.COLOR_TITLE_INACTIVE_BACKGROUND);
			}
			
@


1.5
log
@[135545], gmf_head, contributed  by cdamus, 060524, The pathmaps preference page allows me to override path map variables contributed through the extension point
@
text
@d20 1
d22 3
d43 2
d49 1
d58 1
d240 13
d269 14
d406 32
@


1.4
log
@[139274], gmf_head, contributed  by cmcgee, 060524, Pathmaps preference page controls don't work properly with windows narrator
@
text
@d14 1
d16 1
d24 11
d36 3
d41 2
d48 1
d50 1
a50 1
import org.eclipse.swt.widgets.List;
d68 6
a73 2
	private List referencedPathVariables;
	private List pathVariables;
d75 1
d104 1
a104 1
	
d122 4
a125 1
		pathVariables = new List(pathVariablesComposite, SWT.MULTI | SWT.BORDER);
d130 16
a145 1
		pathVariables.setLayoutData(gridData);
d162 1
a162 1
		Button remove = new Button(buttonComposite,SWT.CENTER);
d201 4
a204 1
		referencedPathVariables = new List(referencedPathVariablesComposite,SWT.MULTI | SWT.BORDER);
d209 35
a243 12
		referencedPathVariables.setLayoutData(gridData);
		
		pathVariables.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				referencedPathVariables.deselectAll();
				
				if (!validateSelections(pathVariables.getSelection())) {
					setMessage(EMFUIMessages.PathmapsPreferencePage_incompatiblePathVariableErrorMessage,ERROR);
					add.setEnabled(false);
				} else {
					setMessage(null);
					add.setEnabled(true);
a245 4

			public void widgetDefaultSelected(SelectionEvent e) {
				// No action necessary
			}
d248 13
a260 9
		referencedPathVariables.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				setMessage(null);
				add.setEnabled(true);
				pathVariables.deselectAll();
			}

			public void widgetDefaultSelected(SelectionEvent e) {
				// No action necessary
d266 2
a267 1
				String[] selections = pathVariables.getSelection();
d269 5
a273 3
				for (int i=0; i<selections.length; i++) {
					referencedPathVariables.add(selections[i]);
					pathVariables.remove(selections[i]);
d288 1
a288 1
				String[] items = pathVariables.getItems();
d290 6
a295 4
				for (int i=0; i<items.length; i++) {
					if (validateSelections(new String[]{items[i]})) {
						referencedPathVariables.add(items[i]);
						pathVariables.remove(items[i]);
d303 2
a304 1
				String[] selections = referencedPathVariables.getSelection();
d306 5
a310 3
				for (int i=0; i<selections.length; i++) {
					pathVariables.add(selections[i]);
					referencedPathVariables.remove(selections[i]);
d325 1
a325 1
				String[] items = referencedPathVariables.getItems();
d327 7
a333 3
				for (int i=0; i<items.length; i++) {
					pathVariables.add(items[i]);
					referencedPathVariables.remove(items[i]);
d344 1
a344 1
				referencedPathVariables.getShell().getDisplay().asyncExec(new Runnable() {
d362 11
a372 2
	private boolean validateSelections(String[] selections) {
		if (selections.length == 0)
d375 2
a376 2
		for (int i=0; i<selections.length; i++) {
			String selection = selections[i];
d378 28
a405 1
			if (!PathmapManager.isCompatiblePathVariable(selection)) {
d415 5
a419 2
		referencedPathVariables.removeAll();
		pathVariables.removeAll();
d421 1
d424 3
a426 1
			pathVariables.add(pathVariableNames[i]);
d429 1
a429 5
		for (Iterator i = PathmapManager.getPathVariableReferences().iterator(); i.hasNext();) {
			String pathVariable = (String)i.next();
			referencedPathVariables.add(pathVariable);
			pathVariables.remove(pathVariable);
		}
d442 1
a442 1
		String[] nonReferencedPathVariables = pathVariables.getItems();
d444 2
a445 1
			PathmapManager.removePathVariableReference(nonReferencedPathVariables[i]);
d448 2
a449 1
		String[] variablesToReference = referencedPathVariables.getItems();
d451 5
a455 1
			PathmapManager.addPathVariableReference(variablesToReference[i]);
d471 96
@


1.3
log
@[139278], gmf_head, contributed  by cdamus, 060501, Pathmaps preference page should use the eclipse default dialog font size and color
@
text
@d80 8
d89 1
a89 1
		Label pathVariablesLabel = new Label(composite, SWT.LEFT);
d98 1
a98 10
		Label referencedPathVariablesLabel = new Label(composite, SWT.LEFT);
		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = false;
		gridData.horizontalSpan = 1;
		gridData.verticalIndent = 20;
		referencedPathVariablesLabel.setLayoutData(gridData);
		referencedPathVariablesLabel.setText(EMFUIMessages.PathmapsPreferencePage_pathVariablesUsedInModeling);
		
		pathVariables = new List(composite,SWT.MULTI | SWT.BORDER);
d142 18
a159 1
		referencedPathVariables = new List(composite,SWT.MULTI | SWT.BORDER);
@


1.2
log
@[135652] gmf_head ldamus 060412 The Modeling Preference Page Needs To Be Removed
@
text
@d62 2
d261 2
@


1.1
log
@[135652] gmf_head ldamus 060412 The Modeling Preference Page Needs To Be Removed
@
text
@d1 11
d37 9
a45 1

@

