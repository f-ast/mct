head	1.14;
access;
symbols
	v20080722-1827:1.14
	v20080716-1642:1.14
	R2_1_maintenance:1.13.0.4
	Root_R2_1_maintenance:1.13
	R2_1_0:1.13
	v20080425-1959:1.13
	v20080222-1200:1.13
	v20070809-0000:1.13
	R2_0_maintenance:1.13.0.2
	R2_0:1.13
	R4_20:1.13
	v20070621-0000:1.13
	RC3_20:1.13
	v20070601-1400:1.13
	v20070518-1300:1.13
	v20070330-1300:1.12
	v20060316-0600:1.12
	v20070228-2000:1.11
	v20070208-1800:1.10
	M4_20:1.10
	v20061214-0000:1.10
	M3_20:1.10
	v20061117-0800:1.10
	v20061013-1330:1.10
	v20060925-1700:1.10
	v20060919-0800:1.10
	M1_20:1.10
	v20060713-1700:1.10
	R1_0_maintenance:1.10.0.2
	R1_0:1.10
	v20060627-1200:1.10
	v20060616-1200:1.10
	v20060531-1730:1.10
	v20060526-1200:1.10
	I20060505-1400:1.8
	I20060424-0500:1.7
	I20060424-0300:1.7
	M6_10:1.7
	I20060407-1200:1.6
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.4
	M5_10:1.2
	S20060303-1600:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.14
date	2008.07.10.12.29.41;	author ashatalin;	state Exp;
branches;
next	1.13;
commitid	7c30487600b44567;

1.13
date	2007.05.17.22.14.13;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	63d7464cd3b54567;

1.12
date	2007.03.14.12.59.21;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	10e945f7f1a74567;

1.11
date	2007.02.27.14.36.03;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	770445e441d34567;

1.10
date	2006.05.24.14.57.47;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.23.21.09.46;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.01.10.00.25;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.10.13.28.16;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.13.15.42.36;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.10.13.58.24;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.08.14.22.42;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.07.20.12.13;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.02.13.16.16;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.01.12.35.04;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.14
log
@[217307] - "Add extension model" action: impossible use for additing nondeployed models
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Michael Golubev (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.graphdef.codegen.ui;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.text.MessageFormat;
import java.util.Collections;
import java.util.Locale;
import java.util.ResourceBundle;
import java.util.jar.Manifest;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.ContentHandler;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.gmf.gmfgraph.DiagramElement;
import org.eclipse.gmf.gmfgraph.FigureGallery;
import org.eclipse.gmf.graphdef.codegen.StandaloneGenerator;
import org.eclipse.jface.dialogs.IMessageProvider;
import org.eclipse.jface.wizard.Wizard;
import org.eclipse.jface.wizard.WizardPage;
import org.eclipse.osgi.util.ManifestElement;
import org.eclipse.pde.core.plugin.IPluginImport;
import org.eclipse.pde.core.plugin.IPluginModel;
import org.eclipse.pde.core.plugin.IPluginReference;
import org.eclipse.pde.ui.IFieldData;
import org.eclipse.pde.ui.templates.BooleanOption;
import org.eclipse.pde.ui.templates.OptionTemplateSection;
import org.eclipse.pde.ui.templates.TemplateOption;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleException;
import org.osgi.framework.Constants;

public class ConverterSection extends OptionTemplateSection {
	private static final String MY_PLUGIN_ID = "org.eclipse.gmf.graphdef.codegen.ui";
	private static final String SECTION_ID = "org.eclipse.gmf.graphdef.codegen.ui.ConverterSection";
	private static final int THE_ONLY_PAGE_INDEX = 0;
	
	public static final String OPTION_MAIN_PACKAGE_NAME = SECTION_ID + ".mainPackageName";
	public static final String OPTION_NEEDS_MAP_MODE = SECTION_ID + ".needsMapMode";
	public static final String OPTION_USE_RUNTIME_FIGURES = SECTION_ID + ".useRuntimeFigures";
	public static final String OPTION_INPUT_RESOURCE_FULL_PATH = SECTION_ID + ".inputResource";
	public static final String OPTION_OUTPUT_GALLERY_FULL_PATH = SECTION_ID + ".outputGallery";
	public static final String OPTION_OUTPUT_DIAGRAM_ELEMENTS_FULL_PATH = SECTION_ID + ".outputDiagramElements";
	
	private TemplateOption myPackageNameOption;
	private FileNameOption myInputPathOption;
	private FileNameOption myOutputGalleryPathOption;
	private FileNameOption myOutputDiagramElementsPathOption;
	private final InputValidationState myCachedInputValidationState;
	private BooleanOption myNeedsMapModeOption;
	private BooleanOption myUseRuntimeFiguresOption;
	private final boolean shouldWarnLiteVerstionDoesNotSupportMapMode;
	private ManifestElement[] myRequiredBundles;
	
	public ConverterSection(){
		setPageCount(THE_ONLY_PAGE_INDEX + 1);
		myPackageNameOption = addOption(OPTION_MAIN_PACKAGE_NAME, "Generate figures package", null, THE_ONLY_PAGE_INDEX);
		myInputPathOption = addFileNameOption(false, OPTION_INPUT_RESOURCE_FULL_PATH, "Input GMFGraph instance", "", THE_ONLY_PAGE_INDEX);
		myOutputGalleryPathOption = addFileNameOption(true, OPTION_OUTPUT_GALLERY_FULL_PATH, "Create Figure Gallery", "", THE_ONLY_PAGE_INDEX);
		myOutputGalleryPathOption.setRequired(false);
		myOutputDiagramElementsPathOption = addFileNameOption(true, OPTION_OUTPUT_DIAGRAM_ELEMENTS_FULL_PATH, "Mirror diagram elements", "", THE_ONLY_PAGE_INDEX);
		myOutputDiagramElementsPathOption.setRequired(false);
		myNeedsMapModeOption = (BooleanOption) addOption(OPTION_NEEDS_MAP_MODE, "Use IMapMode", false, THE_ONLY_PAGE_INDEX);
		myUseRuntimeFiguresOption = (BooleanOption) addOption(OPTION_USE_RUNTIME_FIGURES, "Use Enhanced Figures", true, THE_ONLY_PAGE_INDEX);
		myCachedInputValidationState = new InputValidationState(myOutputGalleryPathOption, myOutputDiagramElementsPathOption);
		shouldWarnLiteVerstionDoesNotSupportMapMode = Platform.getBundle("org.eclipse.gmf.codegen.lite") != null;
	}
	
	public void addPages(Wizard wizard) {
		super.addPages(wizard);
		WizardPage page = createPage(THE_ONLY_PAGE_INDEX);
		page.setDescription("Converts an existing instance of the gmfgraph model into plugin code");
		page.setTitle("Figure definitions converter");
		wizard.addPage(page);
		markPagesAdded();
		validateOptions(myPackageNameOption);
	}

	public IPluginReference[] getDependencies(String schemaVersion) {
		// no explicit dependencies
		return new IPluginReference[0];
	}

	protected void generateFiles(IProgressMonitor monitor) throws CoreException {
		Resource input = loadResource(myInputPathOption.getText());
		StandaloneGenerator.Config config = new StandaloneGeneratorConfigAdapter(this);
		final ConverterOptions options = newConverterOptions();
		final ConverterOutcome converterOutcome = new ConverterOutcome(options, new Resource[] {input});
		assert converterOutcome.checkInputAgainstOptions().isOK();
		StandaloneGenerator generator = new StandaloneGenerator(converterOutcome.getProcessor(), config);
		generator.setSkipPluginStructure(false);
		try {
			generator.run(new SubProgressMonitor(monitor, 1));
			readRequiredBundles();
			// XXX readBuildProperties() and use getNewFiles to propagate
			// XXX readPluginProperties(), use ??? 
			if (!generator.getRunStatus().isOK()){
				throw new CoreException(generator.getRunStatus());
			}
			IStatus s = converterOutcome.createResources(new ResourceSetImpl(), URI.createFileURI(myOutputGalleryPathOption.getText()), URI.createFileURI(myOutputDiagramElementsPathOption.getText()));
			if (s.getSeverity() == IStatus.ERROR) {
				throw new CoreException(s);
			}
		} catch (InterruptedException e) {
			String message = e.getMessage();
			if (message == null){
				message = "Interrupted";
			}
			throw new CoreException(new Status(IStatus.ERROR, MY_PLUGIN_ID, 0, message, e)); 
		} catch (IOException ex) {
			// perhaps, don't need to treat this as error? 
			throw new CoreException(new Status(IStatus.ERROR, MY_PLUGIN_ID, 0, "Failed to read generated manifest.mf", ex));
		} finally {
			input.unload();
		}
	}

	private ConverterOptions newConverterOptions() {
		final ConverterOptions options = new ConverterOptions();
		options.needMirroredGalleries = shouldGenerate(myOutputGalleryPathOption);
		options.needMirroredCanvas = shouldGenerate(myOutputDiagramElementsPathOption);
		options.separateMirrorFiles = options.needMirroredCanvas && myOutputGalleryPathOption.getText().equals(myOutputDiagramElementsPathOption.getText());
		return options;
	}
	
	private static boolean shouldGenerate(FileNameOption option){
		return option.isEnabled() && !option.isEmpty();
	}
	
	private void readRequiredBundles() throws CoreException, IOException {
		try {
			IFile f = findGeneratedManifest();
			if (f == null || !f.exists()) {
				// fail - we do expect manifest to be there?
				return;
			}
			InputStream is = f.getContents(); 
			String requiredBundles = new Manifest(is).getMainAttributes().getValue(Constants.REQUIRE_BUNDLE);
			is.close();
			myRequiredBundles = ManifestElement.parseHeader(Constants.REQUIRE_BUNDLE, requiredBundles);
		} catch (BundleException ex) {
			throw new IOException(ex.getMessage());
		}
	}

	private IFile findGeneratedManifest() {
		return (IFile) project.findMember(new Path("META-INF/MANIFEST.MF"));
	}

	public String getPluginActivatorClassFQN(){
		return model instanceof IPluginModel ? ((IPluginModel)model).getPlugin().getClassName() : null;
	}
	
	public String getPluginFriendlyName(){
		return model.getPluginBase().getName();
	}
	
	public String getPluginID(){
		return model.getPluginBase().getId();
	}
	
	public String getPluginProviderName() {
		return model.getPluginBase().getProviderName();
	}

	protected URL getInstallURL() {
		return getContributingBundle().getEntry("/");
	}

	public String getSectionId() {
		return SECTION_ID;
	}

	public void validateOptions(TemplateOption changed) {
		if ((myUseRuntimeFiguresOption.equals(changed) || myNeedsMapModeOption.equals(changed)) && shouldWarnLiteVerstionDoesNotSupportMapMode) {
			boolean useRuntimeFigures = myUseRuntimeFiguresOption.isSelected();
			boolean needsMapMode = myNeedsMapModeOption.isSelected();
			if (!useRuntimeFigures && needsMapMode) {
				getTheOnlyPage().setMessage("It is not recommended to use IMapMode for pure-GEF diagram editors", IMessageProvider.INFORMATION);
			} else {
				getTheOnlyPage().setMessage(null);
			}
		}
		if (OPTION_NEEDS_MAP_MODE.equals(changed)){
			//does not affect state
			return;
		}
		if (validateInputPath() && validatePackageName() &&  
			validateOutputOption(myOutputDiagramElementsPathOption) && 
			validateOutputOption(myOutputGalleryPathOption)){   
				resetPageState();
		}
	}

	public boolean isDependentOnParentWizard() {
		return true;
	}

	protected void initializeFields(IFieldData data) {
		super.initializeFields(data);
		String packageName = getFormattedPackageName(data.getId());
		initializeOption(OPTION_MAIN_PACKAGE_NAME, packageName);
	}

	protected ResourceBundle getPluginResourceBundle() {
		return Platform.getResourceBundle(getContributingBundle());
	}

	protected void updateModel(IProgressMonitor monitor) throws CoreException {
		if (myRequiredBundles == null) {
			return;
		}
		for (int i = 0; i < myRequiredBundles.length; i++) {
			// take first component, ignore any attributes or directives 
			addImport(myRequiredBundles[i].getValueComponents()[0]);
		}
	}
	
	private void addImport(String importedPluginId) throws CoreException {
		IPluginImport pluginImport = model.getPluginFactory().createImport();
		pluginImport.setId(importedPluginId);
		model.getPluginBase().add(pluginImport);
	}

	public String[] getNewFiles() {
		return new String[0];
	}

	public String getUsedExtensionPoint() {
		return null;
	}
	
	private Bundle getContributingBundle(){
		return Platform.getBundle(MY_PLUGIN_ID);
	}
	
	/**
	 * Stolen from PDETemplateSection, which can not be reused due to export limitations.
	 */
	private String getFormattedPackageName(String id){
		StringBuffer buffer = new StringBuffer();
		for (int i = 0; i < id.length(); i++) {
			char ch = id.charAt(i);
			if (buffer.length() == 0) {
				if (Character.isJavaIdentifierStart(ch))
					buffer.append(Character.toLowerCase(ch));
			} else {
				if (Character.isJavaIdentifierPart(ch) || ch == '.')
					buffer.append(ch);
			}
		}
		return buffer.toString().toLowerCase(Locale.ENGLISH);
	}

	private FileNameOption addFileNameOption(boolean saveNotLoad, String name, String label, String value, int pageIndex) {
		FileNameOption result = new FileNameOption(this, name, label, new String[] {"*.gmfgraph"});
		result.setSaveNotLoad(saveNotLoad);
		registerOption(result, value, pageIndex);
		return result;
	}
	
	private boolean validatePackageName(){
		boolean isValid = !myPackageNameOption.isEmpty();
		if (!isValid){
			flagMissingRequiredOption(myPackageNameOption);
		}
		return isValid;
	}
	
	private boolean validateInputPath() {
		if (myInputPathOption.isEmpty()){
			flagMissingRequiredOption(myInputPathOption);
			myOutputDiagramElementsPathOption.setEnabled(false);
			myOutputGalleryPathOption.setEnabled(false);
			return false;
		}
		String path = myInputPathOption.getText();
		myCachedInputValidationState.updateInput(path);
		if (!myCachedInputValidationState.isValid()){
			flagError(myCachedInputValidationState.getErrorMessage());
			return false;
		}
		return true;
	}
	
	private boolean validateOutputOption(FileNameOption option) {
		if (!option.isEnabled()){
			return false;
		}
		if (!validateMirrorDiagramWithoutFigureGallery()){
			return false;
		}
		if (option.isEmpty()){
			//optional -- ok
			return true;
		}
		String path = option.getText();
		return validatePath(path);
	}

	private boolean validateMirrorDiagramWithoutFigureGallery(){
		if (!myOutputDiagramElementsPathOption.isEmpty()){
			if (myOutputGalleryPathOption.isEmpty() || myOutputDiagramElementsPathOption.getText().equals(myOutputGalleryPathOption.getText())){
				flagError("In order to mirror diagram elements you have to generate separate figure gallery");
				return false;
			}
		}
		return true;
	}
	
	private boolean validatePath(String path){
		try {
			return URI.createFileURI(path) != null; 
		} catch (IllegalArgumentException e){
			flagError(MessageFormat.format("Path {0} is invalid", new Object[] {path}));
			return false;
		}
	}
	
	private WizardPage getTheOnlyPage() {
		return getPage(THE_ONLY_PAGE_INDEX);
	}
	
	private void flagError(String message){
		getTheOnlyPage().setPageComplete(false);
		getTheOnlyPage().setErrorMessage(message);
	}
	
	private static Resource loadResource(String path){
		Resource resource = new ResourceSetImpl().createResource(URI.createFileURI(path), ContentHandler.UNSPECIFIED_CONTENT_TYPE);
		try {
			resource.load(Collections.EMPTY_MAP);
			return resource;
		} catch (IOException e) {
			return null;
		}
	}
	
	private static class InputValidationState {
		private String myCachedPath;
		private String myCachedErrorMessage;
		private boolean myHasDiagramElement;
		private boolean myHasFigure;
		private final FileNameOption myDiagramElementsOption;
		private final FileNameOption myGalleryOption;
		
		public InputValidationState(FileNameOption galleryOption, FileNameOption diagramElementsOption){
			myGalleryOption = galleryOption;
			myDiagramElementsOption = diagramElementsOption;
		}
		
		public void updateInput(String path){
			if (myCachedPath == null || !myCachedPath.equals(path)){
				myCachedPath = path;
				validateInputPath(path);
				myGalleryOption.setEnabled(myHasFigure);
				myDiagramElementsOption.setEnabled(myHasDiagramElement);
			}
		}
		
		public boolean isValid(){
			return myHasFigure;
		}
		
		public String getErrorMessage(){
			return myCachedErrorMessage;
		}
		
		private void validateInputPath(String path) {
			myHasDiagramElement = false;
			myHasFigure = false;
			myCachedErrorMessage = null;

			if (path == null || !new File(path).exists()){
				myCachedErrorMessage = MessageFormat.format("Can not find file {0}", new Object[] {path});
				return;
			}
			
			Resource resource = loadResource(path);
			if (resource != null){
				classifyContents(resource);
			}
			
			if (!myHasFigure){
				myCachedErrorMessage = MessageFormat.format("File {0} does not contain any figure definitions", new Object[] {path});
			}
		}

		private void classifyContents(Resource resource){
			myHasDiagramElement = false;
			myHasFigure = false;
			for (TreeIterator<EObject> contents = resource.getAllContents(); contents.hasNext();){
				EObject next = contents.next();
				if (next instanceof FigureGallery){
					if (!myHasFigure){
						FigureGallery nextGallery = (FigureGallery) next;
						myHasFigure = !nextGallery.getFigures().isEmpty();
					}
					contents.prune();
				}
				if (next instanceof DiagramElement){
					myHasDiagramElement = true;
					contents.prune();
				}
				if (myHasDiagramElement && myHasFigure){
					break;
				}
			}
		}
		
	}
}
@


1.13
log
@moving towards not using fqnswitch and java to tell draw2d figure names; let toolsmith to control what draw2d classes are being used; fqnSwitch argument replaced with simple token indicator
@
text
@d35 1
d353 1
a353 1
		Resource resource = new ResourceSetImpl().createResource(URI.createFileURI(path));
@


1.12
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@a38 3
import org.eclipse.gmf.gmfgraph.util.FigureQualifiedNameSwitch;
import org.eclipse.gmf.gmfgraph.util.RuntimeFQNSwitch;
import org.eclipse.gmf.gmfgraph.util.RuntimeLiteFQNSwitch;
a108 6
		FigureQualifiedNameSwitch fqnSwitch;
		if (myUseRuntimeFiguresOption.isSelected()) {
			fqnSwitch = new RuntimeFQNSwitch();
		} else {
			fqnSwitch = new RuntimeLiteFQNSwitch();
		}
d112 1
a112 1
		StandaloneGenerator generator = new StandaloneGenerator(converterOutcome.getProcessor(), config, fqnSwitch);
@


1.11
log
@text instead of i18n keys
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
d423 2
a424 2
			for (TreeIterator contents = resource.getAllContents(); contents.hasNext();){
				EObject next = (EObject) contents.next();
@


1.10
log
@get rid of bogus config passing into ConverterOutcome
@
text
@d97 2
a98 2
		page.setDescription("ConverterSection.description");
		page.setTitle("ConverterSection.title");
@


1.9
log
@#140887 Remove Child interface from GMFGraph.
Although the need to reference child figures persist, thus FigureHandle was introduced, to allow diagramElements to reference either *generateable* figures (Figure subclasses) or *just-use* figures (like CustomFigure and FigureAccessor).
Refactoring performed with #131365 "Mirror GMFGraph model when generating standalone figure plugin" in mind
@
text
@d131 1
a131 1
			IStatus s = converterOutcome.createResources(new ResourceSetImpl(), URI.createFileURI(myOutputGalleryPathOption.getText()), URI.createFileURI(myOutputDiagramElementsPathOption.getText()), config);
@


1.8
log
@[bblajer] #137225 Specify whether to generate gmf.runtime-based or pure draw2d figures, within New Plug-in template
@
text
@a35 1
import org.eclipse.emf.ecore.resource.ResourceSet;
a36 1
import org.eclipse.gmf.gmfgraph.Canvas;
a42 1
import org.eclipse.gmf.internal.graphdef.codegen.StandaloneGalleryConverter;
a110 2
		FigureGallery[] figures = findFigures(input);
		assert(figures.length > 0);
d118 4
a121 1
		StandaloneGenerator generator = new StandaloneGenerator(figures, config, fqnSwitch);
d131 4
a134 1
			createSeparateResources(generator.getGenerationInfo(), input);
d148 7
a154 28
	
	private void createSeparateResources(StandaloneGenerator.GenerationInfo info, Resource input) throws CoreException {
		if (shouldGenerate(myOutputGalleryPathOption)){
			String figureGalleryPath = myOutputGalleryPathOption.getText();
			ResourceSet separateResourceSet = new ResourceSetImpl();
			StandaloneGalleryConverter converter = new StandaloneGalleryConverter(info);
			
			Resource galleryResource = separateResourceSet.createResource(URI.createFileURI(figureGalleryPath));
			galleryResource.getContents().add(converter.convertFigureGallery());
			
			Resource diagramElementsResource = null;
			if (shouldGenerate(myOutputDiagramElementsPathOption)){
				Canvas mirror = converter.mirrorDiagramElements(Collections.singleton(input));
				if (mirror != null){
					diagramElementsResource = separateResourceSet.createResource(URI.createFileURI(myOutputDiagramElementsPathOption.getText()));
					diagramElementsResource.getContents().add(mirror);
				}
			}
			
			try {
				galleryResource.save(null);
				if (diagramElementsResource != null){
					diagramElementsResource.save(null);
				}
			} catch (IOException e) {
				throw new CoreException(new Status(IStatus.ERROR, MY_PLUGIN_ID, 0, e.getMessage(), e));
			}
		}
d157 1
a157 1
	private boolean shouldGenerate(FileNameOption option){
a180 4
	private FigureGallery[] findFigures(Resource resource) {
		return new FigureFinder().findFigures(resource);
	}
	
@


1.7
log
@Refactor latest fix for #128779 - StandaloneGalleryConverter moved to gmfgraph.codegen, dependencies of oeg.tests and oeg.graphdef.codegen.ui updated.
@
text
@d41 1
d43 1
d46 1
d54 1
d68 1
d78 3
d91 2
a92 1
		addOption(OPTION_NEEDS_MAP_MODE, "Use IMapMode", false, THE_ONLY_PAGE_INDEX);
d94 1
d117 7
a123 1
		StandaloneGenerator generator = new StandaloneGenerator(figures, config, new RuntimeFQNSwitch());
d230 9
@


1.6
log
@[mgolubev] #131365 Mirror diagram elements and connect them to newly generated custom figures
@
text
@d43 1
@


1.5
log
@no need to restrict to single gallery any longer
@
text
@d36 1
d38 2
a39 1
import org.eclipse.gmf.gmfgraph.Figure;
d64 2
a65 1
	public static final String OPTION_OUTPUT_RESOURCE_FULL_PATH = SECTION_ID + ".outputResource";
d70 2
a71 1
	private final CachedInputValidationState myCachedInputValidationState;
d78 1
a78 1
		myOutputGalleryPathOption = addFileNameOption(true, OPTION_OUTPUT_RESOURCE_FULL_PATH, "Create Figure Gallery", "", THE_ONLY_PAGE_INDEX);
d80 2
d83 1
a83 1
		myCachedInputValidationState = new CachedInputValidationState();
a93 2
		validateOptions(myInputPathOption);
		validateOptions(myOutputGalleryPathOption);
d102 3
a104 2
		Resource resource = loadResource(myInputPathOption.getText());
		FigureGallery[] figures = findFigures(resource);
d113 4
d127 1
a127 4
			resource.unload();
		}
		if (!generator.getRunStatus().isOK()){
			throw new CoreException(generator.getRunStatus());
a128 1
		createFigureGallery(generator.getGenerationInfo());
d131 18
a148 5
	private void createFigureGallery(StandaloneGenerator.GenerationInfo info) throws CoreException {
		if (!myOutputGalleryPathOption.isEmpty()){
			String path = myOutputGalleryPathOption.getText();
			Resource galleryResource = new ResourceSetImpl().createResource(URI.createFileURI(path));
			galleryResource.getContents().add(new StandaloneGalleryConverter().convertFigureGallery(info));
d151 3
d155 1
a155 3
				throw new CoreException(new Status(//
						IStatus.ERROR, MY_PLUGIN_ID, 0, e.getMessage(), e
				));
d160 4
d187 1
a187 1

d217 4
a220 5
		if (!validatePackageName()){
			return;
		}
		if (!validateInputPath()){
			return;
a221 4
		if (!validateOutputGalleryPath()){
			return;
		}
		resetPageState();
d302 2
d309 1
a309 2
			getTheOnlyPage().setPageComplete(false);
			getTheOnlyPage().setErrorMessage(myCachedInputValidationState.getErrorMessage());
d315 8
a322 2
	private boolean validateOutputGalleryPath() {
		if (myOutputGalleryPathOption.isEmpty()){
d326 15
a340 1
		String path = myOutputGalleryPathOption.getText();
d342 1
a342 1
			URI.createFileURI(path);
d344 1
a344 3
			String message = MessageFormat.format("Path {0} is invalid", new Object[] {path});
			getTheOnlyPage().setPageComplete(false);
			getTheOnlyPage().setErrorMessage(message);
a346 1
		return true;
d348 1
a348 1

d353 5
d368 1
a368 1
	private static class CachedInputValidationState {
a369 1
		private boolean myCachedIsValid;
d371 9
d383 4
a386 1
				myCachedIsValid = validateInputPath(path); 
d391 1
a391 1
			return myCachedIsValid;
d398 3
a400 11
		private boolean hasAtLeastOneFigure(Resource resource){
			for (TreeIterator contents = resource.getAllContents(); contents.hasNext();){
				EObject next = (EObject) contents.next();
				if (next instanceof Figure){
					return true;
				}
			}
			return false;
		}
		
		private boolean validateInputPath(String path) {
d402 1
d405 1
a405 1
				return false;
a408 1
			boolean isValid = resource != null && hasAtLeastOneFigure(resource);
d410 1
a410 1
				resource.unload();
d412 2
a413 1
			if (!isValid){
a414 1
				return false;
a415 1
			return true;
d418 22
@


1.4
log
@[mgolubev] #128779 create new .gmfgraph as part of figure bundle generation process
@
text
@a99 1
		assert figures.length == 1 : "FIXME update generator to support multiple galleries"; 
d101 1
a101 1
		StandaloneGenerator generator = new StandaloneGenerator(figures[0], config, new RuntimeFQNSwitch());
@


1.3
log
@ui action to generate figures bundle
@
text
@d62 1
d66 1
d73 3
a75 1
		myInputPathOption = addFileNameOption(OPTION_INPUT_RESOURCE_FULL_PATH, "Input GMFGraph instance", "", THE_ONLY_PAGE_INDEX);
d89 1
d124 16
d201 3
d267 1
a267 1
	private FileNameOption addFileNameOption(String name, String label, String value, int pageIndex) {
d269 1
d296 17
@


1.2
log
@[mgolubev] #128779 generate figures as standalone plugin
#129362 - respect plug-in dependencies imposed by figure fqn switch
@
text
@a18 1
import java.util.ArrayList;
a38 1
import org.eclipse.gmf.gmfgraph.GMFGraphPackage;
d142 1
a142 12
		ArrayList rv = new ArrayList();
		for(TreeIterator it = resource.getAllContents(); it.hasNext();) {
			EObject next = (EObject) it.next();
			// FigureGallery could be either top element or as a child of canvas
			if (next.eClass().getClassifierID() == GMFGraphPackage.FIGURE_GALLERY) {
				rv.add(next);
				it.prune();
			} else if (next.eClass().getClassifierID() != GMFGraphPackage.CANVAS) {
				it.prune();
			}
		}
		return (FigureGallery[]) rv.toArray(new FigureGallery[rv.size()]);
@


1.1
log
@[mgolubev] #128779 Create standalone plugin with GEF figures
@
text
@d16 1
d19 1
a20 1
import java.util.Iterator;
d23 1
d25 1
d29 1
d39 4
a42 4
import org.eclipse.gmf.graphdef.codegen.standalone.GMFGraphTree;
import org.eclipse.gmf.graphdef.codegen.standalone.RequiredPluginsCollector;
import org.eclipse.gmf.graphdef.codegen.standalone.StandaloneGenerator;
import org.eclipse.gmf.graphdef.codegen.standalone.StandaloneGeneratorConfig;
d45 1
d48 2
a49 1
import org.eclipse.pde.core.plugin.IPluginModelBase;
d53 2
d68 1
a68 1
	private RequiredPluginsCollector myRequiredPluginsCollector;
d72 1
a72 1
		myPackageNameOption = addOption(OPTION_MAIN_PACKAGE_NAME, "Generate figures package", "", THE_ONLY_PAGE_INDEX);
d88 6
a93 1
	
d96 5
a100 6
		GMFGraphTree tree = new GMFGraphTree.ResourceAdapter(resource);
		StandaloneGeneratorConfig config = new StandaloneGeneratorConfigAdapter(this);
		StandaloneGenerator generator = new StandaloneGenerator(tree, config);
		generator.setSkipPluginStructure(true);
		myRequiredPluginsCollector = new RequiredPluginsCollector(config);
		myRequiredPluginsCollector.visitAll(tree);
d103 3
d112 3
d123 35
d195 8
a202 4
	
	public void initializeFields(IPluginModelBase model) {
		super.initializeFields(model);
		String packageName = getFormattedPackageName(model.getPluginBase().getId());
d205 1
a205 1
	
d211 6
a216 5
		if (myRequiredPluginsCollector != null){
			for (Iterator bundles = myRequiredPluginsCollector.getCollectedBundles().iterator(); bundles.hasNext();){
				String next = (String)bundles.next();
				addImport(next);
			}
@

