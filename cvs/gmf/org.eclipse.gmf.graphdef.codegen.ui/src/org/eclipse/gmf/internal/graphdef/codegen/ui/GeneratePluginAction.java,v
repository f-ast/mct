head	1.16;
access;
symbols
	v20080722-1827:1.16
	v20080716-1642:1.16
	R2_1_maintenance:1.16.0.4
	Root_R2_1_maintenance:1.16
	R2_1_0:1.16
	v20080425-1959:1.16
	v20080222-1200:1.16
	v20070809-0000:1.16
	R2_0_maintenance:1.16.0.2
	R2_0:1.16
	R4_20:1.16
	v20070621-0000:1.16
	RC3_20:1.16
	v20070601-1400:1.16
	v20070518-1300:1.16
	v20070330-1300:1.15
	v20060316-0600:1.15
	v20070228-2000:1.14
	v20070208-1800:1.10
	M4_20:1.10
	v20061214-0000:1.10
	M3_20:1.9
	v20061117-0800:1.9
	v20061013-1330:1.9
	v20060925-1700:1.9
	v20060919-0800:1.9
	M1_20:1.9
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060616-1200:1.9
	v20060531-1730:1.9
	v20060526-1200:1.9
	I20060505-1400:1.7
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.4
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.16
date	2007.05.17.22.14.13;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	63d7464cd3b54567;

1.15
date	2007.03.14.12.59.21;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	10e945f7f1a74567;

1.14
date	2007.02.27.19.12.42;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	151645e482aa4567;

1.13
date	2007.02.27.18.09.38;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	47f145e473e24567;

1.12
date	2007.02.27.17.46.49;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	77b945e46e894567;

1.11
date	2007.02.27.14.36.20;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	776245e441e44567;

1.10
date	2006.11.22.17.36.20;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	12ed45648a944567;

1.9
date	2006.05.24.14.57.47;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.23.21.09.46;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.02.15.06.06;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.01.17.26.41;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.20.17.52.45;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.10.13.28.16;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.13.15.42.36;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.10.15.50.44;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.07.20.12.13;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.16
log
@moving towards not using fqnswitch and java to tell draw2d figure names; let toolsmith to control what draw2d classes are being used; fqnSwitch argument replaced with simple token indicator
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.graphdef.codegen.ui;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.emf.common.CommonPlugin;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.gmf.graphdef.codegen.StandaloneGenerator;
import org.eclipse.jdt.core.JavaConventions;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.dialogs.IDialogConstants;
import org.eclipse.jface.dialogs.IInputValidator;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.ModifyEvent;
import org.eclipse.swt.events.ModifyListener;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Text;
import org.eclipse.ui.IObjectActionDelegate;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.forms.widgets.ExpandableComposite;

public class GeneratePluginAction implements IObjectActionDelegate, IInputValidator {
	private List<IFile> mySelectedFiles = Collections.emptyList();
	private IWorkbenchPart myTargetPart;
	private ConverterOptions myOptions;

	public GeneratePluginAction() {
	}

	public void setActivePart(IAction action, IWorkbenchPart targetPart) {
		myTargetPart = targetPart;
	}

	public void run(IAction action) {
		final ResourceSet rs = new ResourceSetImpl();
		final Resource[] input = loadFromSelection(rs);
		StandaloneGeneratorOptionsDialog dialog = new StandaloneGeneratorOptionsDialog(getShell(), null, true, this);
		if (dialog.open() != IDialogConstants.OK_ID) {
			return;
		}
		String pluginId = dialog.getPluginId();
		final StandaloneGenerator.Config config = new StandaloneGenerator.ConfigImpl(pluginId, pluginId, dialog.getMapModeCodeGenStrategy(), dialog.getRuntimeToken());
		final ConverterOutcome converterOutcome = new ConverterOutcome(getOptions(), input);
		final IStatus inputCheck = converterOutcome.checkInputAgainstOptions();
		if (!inputCheck.isOK()) {
			MessageDialog.openInformation(getShell(), "Nothing to do", inputCheck.getMessage());
			return;
		}
		URL[] dynamicTemplates = null;
		if (dialog.getTemplatesPath() != null) {
			try {
				dynamicTemplates = new URL[1];
				dynamicTemplates[0] = new URL(dialog.getTemplatesPath());
			} catch (MalformedURLException ex) {
				MessageDialog.openWarning(getShell(), "Invalid dynamic template path", "Path for dynamic templates is invalid, proceeding without dynamic templates");
				// fallthrough
			}
		}
		final StandaloneGenerator generator = new StandaloneGenerator(converterOutcome.getProcessor(), config, dynamicTemplates);
		generator.setSkipPluginStructure(false);

		new Job(action.getText()) {
			private IContainer myResourcesContainer;
			{
				setUser(true); 
			}

			protected IStatus run(IProgressMonitor monitor) {
				try {
					generator.run(monitor);
					if (!generator.getRunStatus().isOK()) {
						return generator.getRunStatus();
					}
					URI galleryURI = URI.createPlatformResourceURI(decideOnDestinationFile("bundled").getFullPath().toString(), true);
					URI canvasURI = URI.createPlatformResourceURI(decideOnDestinationFile("mirrored").getFullPath().toString(), true);
					return converterOutcome.createResources(rs, galleryURI, canvasURI);					

				} catch (InterruptedException e) {
					return Status.CANCEL_STATUS;
				} finally {
					for (Resource next : rs.getResources()) {
						next.unload();
					}
				}
			}

			private IFile decideOnDestinationFile(String baseName) {
				final IPath basePath = new Path(baseName);
				final String ext = "gmfgraph";
				IFile resultFile = getResourcesContainer().getFile(basePath.addFileExtension(ext));
				for (int i = 1; resultFile.exists(); i++) {
					resultFile = getResourcesContainer().getFile(new Path(basePath.lastSegment() + String.valueOf(i)).addFileExtension(ext));
				}
				return resultFile;
			}
			
			private IContainer getResourcesContainer(){
				if (myResourcesContainer == null){
					IProject p = ResourcesPlugin.getWorkspace().getRoot().getProject(config.getPluginID());
					assert p.exists(); // generator.runStatus.ok makes us believe
					myResourcesContainer = p;
					IFolder modelsFolder = p.getFolder("models");
					if (!modelsFolder.exists()) {
						try {
							modelsFolder.create(true, true, new NullProgressMonitor());
							myResourcesContainer = modelsFolder;
						} catch (CoreException ex) {
							// ignore or log?
						}
					}
				}
				return myResourcesContainer;
			}
		}.schedule();
	}

	private Resource[] loadFromSelection(ResourceSet rs) {
		Resource[] rv = new Resource[mySelectedFiles.size()];
		int i = 0;
		for (IFile next : mySelectedFiles) {
			rv[i++] = rs.getResource(URI.createPlatformResourceURI(next.getFullPath().toString(), true), true);
		}
		return rv;
	}

	public String isValid(String newText) {
		IStatus s = JavaConventions.validatePackageName(newText, JavaCore.VERSION_1_4, JavaCore.VERSION_1_4);
		if (s.isOK()) {
			return null;
		}
		return s.getMessage();
	}

	private Shell getShell() {
		return myTargetPart.getSite().getShell();
	}

	public void selectionChanged(IAction action, ISelection selection) {
		mySelectedFiles = new ArrayList<IFile>(5);
		if (selection instanceof IStructuredSelection) {
			@@SuppressWarnings("unchecked") List<IFile> sel = ((IStructuredSelection) selection).toList();
			mySelectedFiles.addAll(sel);
		}
	}

	private ConverterOptions getOptions() {
		if (myOptions == null) {
			myOptions = loadOptions();
		}
		return myOptions;
	}

	private ConverterOptions loadOptions() {
		ConverterOptions options = new ConverterOptions();
		options.needMirroredCanvas = true;
		options.needMirroredGalleries = true;
		return options;
	}

	private static class StandaloneGeneratorOptionsDialog extends FigureGeneratorOptionsDialog {
	    private IInputValidator pluginIdValidator;
	    private Text pluginIdText;
		private String pluginId;
		private String templatesPath;
		private final boolean shouldWarnLiteVerstionDoesNotSupportMapMode;
		private Text templatesPathControl;

		public StandaloneGeneratorOptionsDialog(Shell parentShell, String initialPluginId, boolean initialUseRuntimeFigures, IInputValidator pluginIdValidator) {
			this(parentShell, initialPluginId, initialUseRuntimeFigures, false, pluginIdValidator);
		}

		public StandaloneGeneratorOptionsDialog(Shell parentShell, String initialPluginId, boolean initialUseRuntimeFigures, boolean initialUseMapMode, IInputValidator pluginIdValidator) {
			super(parentShell, "Figure Gallery Generator", initialUseRuntimeFigures, initialUseMapMode);
			pluginId = initialPluginId;
			if (pluginId == null) {
				pluginId = "";	//$NON-NLS-1$
			}
			this.pluginIdValidator = pluginIdValidator;
			shouldWarnLiteVerstionDoesNotSupportMapMode = Platform.getBundle("org.eclipse.gmf.codegen.lite") != null;
		}

		protected void createControls(Composite result) {
	        Label label = new Label(result, SWT.WRAP);
	        label.setText("Please specify the name of plug-in/main package");
	        GridData data = new GridData(GridData.GRAB_HORIZONTAL
	                | GridData.GRAB_VERTICAL | GridData.HORIZONTAL_ALIGN_FILL
	                | GridData.VERTICAL_ALIGN_CENTER);
	        data.widthHint = convertHorizontalDLUsToPixels(IDialogConstants.MINIMUM_MESSAGE_AREA_WIDTH);
	        label.setLayoutData(data);
	        pluginIdText = new Text(result, SWT.SINGLE | SWT.BORDER);
	        pluginIdText.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL
	                | GridData.HORIZONTAL_ALIGN_FILL));
	        final ModifyListener modifyListener = new ModifyListener() {
				            public void modifyText(ModifyEvent e) {
				                validateInput();
				            }
				        };
			pluginIdText.addModifyListener(modifyListener);
	        ExpandableComposite c = new ExpandableComposite(result, SWT.NONE, ExpandableComposite.TWISTIE);
	        final GridData d = new GridData(SWT.FILL, SWT.TOP, true, true);
	        d.minimumHeight = convertVerticalDLUsToPixels(IDialogConstants.BUTTON_BAR_HEIGHT);
	        d.verticalIndent = 10;
			c.setLayoutData(d);
	        c.setText("Dynamic templates");
	        templatesPathControl = new Text(c, SWT.SINGLE | SWT.BORDER);
	        templatesPathControl.addModifyListener(modifyListener);
			c.setClient(templatesPathControl);
			super.createControls(result);
		}

	    protected void validateInput() {
	        String errorMessage = null;
	        if (pluginIdValidator != null) {
	            errorMessage = pluginIdValidator.isValid(pluginIdText.getText());
	        }
	        if (errorMessage == null && templatesPathControl.getText().trim().length() > 0) { // do dynamic templates check only when pluginID is ok
	        	try {
	        		new URL(guessAndResolvePathURL(templatesPathControl.getText().trim()));
	        	} catch (Exception ex) {
	        		errorMessage = "Illegal dynamic templates path";
	        	}
	        }
	        // Bug 16256: important not to treat "" (blank error) the same as null
	        // (no error)
	        setErrorMessage(errorMessage);
	    }

	    protected void warnLiteVerstionDoesNotSupportMapMode() {
	    	if (shouldWarnLiteVerstionDoesNotSupportMapMode) {
	    		super.warnLiteVerstionDoesNotSupportMapMode();
	    	}
	    }

	    protected void okPressed() {
	    	pluginId = pluginIdText.getText();
	    	templatesPath = templatesPathControl.getText().trim();
	    	if (templatesPath.length() == 0) {
	    		templatesPath = null;
	    	} else {
	    		templatesPath = guessAndResolvePathURL(templatesPath);
	    	}
	    	super.okPressed();
	    }

		private static String guessAndResolvePathURL(String path) {
			assert path != null;
			URI templatesURI = path.indexOf(':') == -1 ? URI.createPlatformResourceURI(path, true) : URI.createURI(path);
			return CommonPlugin.resolve(templatesURI).toString();
		}

	    public String getPluginId() {
	    	return pluginId;
	    }
	    public String getTemplatesPath() {
	    	return templatesPath;
	    }
	}
}
@


1.15
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d80 1
a80 1
		final StandaloneGenerator.Config config = new StandaloneGenerator.ConfigImpl(pluginId, pluginId, dialog.isUseMapMode());
d97 1
a97 1
		final StandaloneGenerator generator = new StandaloneGenerator(converterOutcome.getProcessor(), config, dialog.getFigureQualifiedNameSwitch(), dynamicTemplates);
@


1.14
log
@better (fine) way to denote legacy statements
@
text
@d1 11
a17 1
import java.util.Iterator;
d119 2
a120 2
					for (Iterator it = rs.getResources().iterator(); it.hasNext();) {
						((Resource) it.next()).unload();
@


1.13
log
@slightly modified version to support workspace resource uris
@
text
@a165 1
	@@SuppressWarnings("unchecked")
d169 2
a170 1
			mySelectedFiles.addAll(((IStructuredSelection) selection).toList());
@


1.12
log
@[170686] ignorant blatant support for dynamic templates for gmfgraph figures generated as standalone plugin
@
text
@d24 1
d246 1
a246 1
	        		new URL(templatesPathControl.getText().trim());
d267 2
d273 6
@


1.11
log
@use generics wherever possible
@
text
@d3 2
d47 1
d76 11
a86 1
		final StandaloneGenerator generator = new StandaloneGenerator(converterOutcome.getProcessor(), config, dialog.getFigureQualifiedNameSwitch());
d191 1
d193 1
d220 15
a234 5
	        pluginIdText.addModifyListener(new ModifyListener() {
	            public void modifyText(ModifyEvent e) {
	                validateInput();
	            }
	        });
d243 7
d263 4
d273 3
@


1.10
log
@Removing warnings
@
text
@d28 1
d47 1
a47 1
	private List/*IFile*/ mySelectedFiles = Collections.EMPTY_LIST;
d134 2
a135 3
		for (Iterator it = mySelectedFiles.iterator(); it.hasNext(); i++) {
			IFile next = (IFile) it.next();
			rv[i] = rs.getResource(URI.createPlatformResourceURI(next.getFullPath().toString(), true), true);
d141 1
a141 1
		IStatus s = JavaConventions.validatePackageName(newText);
d152 1
d154 1
a154 1
		mySelectedFiles = new ArrayList(5);
@


1.9
log
@get rid of bogus config passing into ConverterOutcome
@
text
@d87 2
a88 2
					URI galleryURI = URI.createPlatformResourceURI(decideOnDestinationFile("bundled").getFullPath().toString());
					URI canvasURI = URI.createPlatformResourceURI(decideOnDestinationFile("mirrored").getFullPath().toString());
d135 1
a135 1
			rv[i] = rs.getResource(URI.createPlatformResourceURI(next.getFullPath().toString()), true);
@


1.8
log
@#140887 Remove Child interface from GMFGraph.
Although the need to reference child figures persist, thus FigureHandle was introduced, to allow diagramElements to reference either *generateable* figures (Figure subclasses) or *just-use* figures (like CustomFigure and FigureAccessor).
Refactoring performed with #131365 "Mirror GMFGraph model when generating standalone figure plugin" in mind
@
text
@d89 1
a89 1
					return converterOutcome.createResources(rs, galleryURI, canvasURI, config);					
@


1.7
log
@organized imports
@
text
@a2 1
import java.io.IOException;
a3 1
import java.util.Arrays;
a22 1
import org.eclipse.emf.ecore.EObject;
a25 1
import org.eclipse.gmf.gmfgraph.FigureGallery;
a26 1
import org.eclipse.gmf.internal.graphdef.codegen.StandaloneGalleryConverter;
d48 1
a57 1
		List/*FigureGallery*/ galleries = new ArrayList(5);
d59 1
a59 5
		loadFromSelection(rs, galleries);
		if (galleries.isEmpty()) {
			MessageDialog.openInformation(getShell(), "Nothing to do", "No figure galleries found in the selected files, nothing to do");
			return;
		}
d65 8
a72 3
		FigureGallery[] input = (FigureGallery[]) galleries.toArray(new FigureGallery[galleries.size()]);
		StandaloneGenerator.Config config = new StandaloneGenerator.ConfigImpl(pluginId, pluginId, dialog.isUseMapMode());
		final StandaloneGenerator generator = new StandaloneGenerator(input, config, dialog.getFigureQualifiedNameSwitch());
d78 1
a78 1
				// setUser(true); FIXME fixed after M5, uncoment when switching to M6 
d87 3
a89 1
					StandaloneGalleryConverter converter = new StandaloneGalleryConverter(generator.getGenerationInfo());					
a90 5
					IStatus result = saveToFile(decideOnDestinationFile("bundled"), converter.convertFigureGallery());
					if (result.isOK()){
						result = saveToFile(decideOnDestinationFile("mirrored"), converter.mirrorDiagramElements(rs.getResources()));
					}
					return result;
d112 1
a112 1
					IProject p = ResourcesPlugin.getWorkspace().getRoot().getProject(getConfig().getPluginID());
a126 17
			
			private StandaloneGenerator.Config getConfig(){
				return generator.getGenerationInfo().getConfig();
			}

			private IStatus saveToFile(IFile outputFile, EObject root) {
				if (root != null){
					Resource outputResource = rs.createResource(URI.createPlatformResourceURI(outputFile.getFullPath().toString()));
					outputResource.getContents().add(root);
					try {
						outputResource.save(null);
					} catch (IOException e) {
						return new Status(IStatus.ERROR, "org.eclipse.gmf.graphdef.codegen.ui", 0, e.getMessage(), e);
					}
				}
				return Status.OK_STATUS;
			}
d130 6
a135 12
	private void loadFromSelection(ResourceSet rs, List/*FigureGallery*/ galleries) {
		final FigureFinder extractor = new FigureFinder();
		for (Iterator it = mySelectedFiles.iterator(); it.hasNext();) {
			try {
				IFile next = (IFile) it.next();
				Resource r = rs.getResource(URI.createPlatformResourceURI(next.getFullPath().toString()), true);
				FigureGallery[] fg = extractor.findFigures(r);
				galleries.addAll(Arrays.asList(fg));
			} catch (Exception ex) {
				ex.printStackTrace();
				// FIXME log
			}
d137 1
d159 14
@


1.6
log
@[bblajer] ##139022 Provide option to choose mapMode for figures
@
text
@a29 3
import org.eclipse.gmf.gmfgraph.util.FigureQualifiedNameSwitch;
import org.eclipse.gmf.gmfgraph.util.RuntimeFQNSwitch;
import org.eclipse.gmf.gmfgraph.util.RuntimeLiteFQNSwitch;
a33 1
import org.eclipse.jface.dialogs.Dialog;
a41 2
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.events.SelectionListener;
a42 1
import org.eclipse.swt.widgets.Button;
a43 1
import org.eclipse.swt.widgets.Control;
@


1.5
log
@[bblajer] #137225 Specify whether to generate gmf.runtime-based or pure draw2d figures
@
text
@d21 1
d46 2
d83 2
a84 8
		StandaloneGenerator.Config config = new StandaloneGenerator.ConfigImpl(pluginId, pluginId, false);
		FigureQualifiedNameSwitch fqnSwitch;
		if (dialog.isUseRuntimeFigures()) {
			fqnSwitch = new RuntimeFQNSwitch();
		} else {
			fqnSwitch = new RuntimeLiteFQNSwitch();
		}
		final StandaloneGenerator generator = new StandaloneGenerator(input, config, fqnSwitch);
d196 1
a196 1
	private static class StandaloneGeneratorOptionsDialog extends Dialog {
a198 3
	    private Text errorMessageText;
	    private Button useRuntimeFiguresButton;

d200 1
a200 1
		private boolean useRuntimeFigures;
d203 5
a207 1
			super(parentShell);
d213 1
a213 6
			useRuntimeFigures = initialUseRuntimeFigures;
		}

		protected void configureShell(Shell newShell) {
			super.configureShell(newShell);
			newShell.setText("Figure Gallery Generator");
d216 1
a216 2
		protected Control createDialogArea(Composite parent) {
			Composite result = (Composite) super.createDialogArea(parent);
a223 1
	        label.setFont(parent.getFont());
d232 1
a232 9
	        useRuntimeFiguresButton = new Button(result, SWT.CHECK);
	        useRuntimeFiguresButton.setText("Utilize enhanced features of GMF runtime");
	        useRuntimeFiguresButton.setSelection(useRuntimeFigures);
	        errorMessageText = new Text(result, SWT.READ_ONLY);
	        errorMessageText.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL
	                | GridData.HORIZONTAL_ALIGN_FILL));
	        errorMessageText.setBackground(errorMessageText.getDisplay()
	                .getSystemColor(SWT.COLOR_WIDGET_BACKGROUND));
			return result;
d245 4
a248 7
	    public void setErrorMessage(String errorMessage) {
	        errorMessageText.setText(errorMessage == null ? "" : errorMessage); //$NON-NLS-1$
	        errorMessageText.getParent().update();
	        Control button = getButton(IDialogConstants.OK_ID);
	        if (button != null) {
				button.setEnabled(errorMessage == null);
			}
a251 1
	    	useRuntimeFigures = useRuntimeFiguresButton.getSelection();
a258 4

	    public boolean isUseRuntimeFigures() {
	    	return useRuntimeFigures;
	    }
@


1.4
log
@Refactor latest fix for #128779 - StandaloneGalleryConverter moved to gmfgraph.codegen, dependencies of oeg.tests and oeg.graphdef.codegen.ui updated.
@
text
@d29 1
d31 1
d36 2
a38 1
import org.eclipse.jface.dialogs.InputDialog;
d42 8
d51 1
d74 2
a75 2
		InputDialog readInputDlg = new InputDialog(getShell(), "Specify plug-in id", "Please enter name of plug-in/main package", null, this);
		if (readInputDlg.open() != InputDialog.OK) {
d78 1
d80 8
a87 2
		StandaloneGenerator.Config config = new StandaloneGenerator.ConfigImpl(readInputDlg.getValue(), readInputDlg.getValue(), false);
		final StandaloneGenerator generator = new StandaloneGenerator(input, config, new RuntimeFQNSwitch());
d198 87
@


1.3
log
@[mgolubev] #131365 Mirror diagram elements and connect them to newly generated custom figures
@
text
@d31 1
@


1.2
log
@generate bundled.gmfgraph to reference newly generated figures
@
text
@d24 1
d71 1
d82 7
a88 3
					IFile galleryFile = decideOnDestinationFile();
					Resource r = rs.createResource(URI.createPlatformResourceURI(galleryFile.getFullPath().toString()));
					return saveNewFigureGallery(r, generator.getGenerationInfo());
d98 23
a120 12
			private IFile decideOnDestinationFile() {
				StandaloneGenerator.Config config = generator.getGenerationInfo().getConfig();
				IProject p = ResourcesPlugin.getWorkspace().getRoot().getProject(config.getPluginID());
				assert p.exists(); // generator.runStatus.ok makes us believe
				IContainer fileContainer = p;
				IFolder modelsFolder = p.getFolder("models");
				if (!modelsFolder.exists()) {
					try {
						modelsFolder.create(true, true, new NullProgressMonitor());
						fileContainer = modelsFolder;
					} catch (CoreException ex) {
						// ignore or log?
d123 5
a127 7
				final IPath baseName = new Path("bundled");
				final String ext = "gmfgraph";
				IFile galleryFile = fileContainer.getFile(baseName.addFileExtension(ext));
				for (int i = 1; galleryFile.exists(); i++) {
					galleryFile = fileContainer.getFile(new Path(baseName.lastSegment() + String.valueOf(i)).addFileExtension(ext));
				}
				return galleryFile;
d130 9
a138 6
			private IStatus saveNewFigureGallery(Resource galleryResource, StandaloneGenerator.GenerationInfo info) {
				galleryResource.getContents().add(new StandaloneGalleryConverter().convertFigureGallery(info));
				try {
					galleryResource.save(null);
				} catch (IOException e) {
					return new Status(IStatus.ERROR, "org.eclipse.gmf.graphdef.codegen.ui", 0, e.getMessage(), e);
@


1.1
log
@ui action to generate figures bundle
@
text
@d3 1
d10 1
d12 5
d19 2
d65 2
a66 1
		final StandaloneGenerator generator = new StandaloneGenerator(input, new StandaloneGenerator.ConfigImpl(readInputDlg.getValue(), readInputDlg.getValue(), false), new RuntimeFQNSwitch());
d71 1
a71 1
				setUser(true);
d77 6
a82 1
					return generator.getRunStatus();
d91 33
@

