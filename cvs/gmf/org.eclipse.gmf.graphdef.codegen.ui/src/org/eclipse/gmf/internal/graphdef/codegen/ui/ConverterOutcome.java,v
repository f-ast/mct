head	1.6;
access;
symbols
	v20080722-1827:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080425-1959:1.5
	v20080222-1200:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070601-1400:1.5
	v20070518-1300:1.5
	v20070330-1300:1.5
	v20060316-0600:1.5
	v20070228-2000:1.4
	v20070208-1800:1.2
	M4_20:1.2
	v20061214-0000:1.2
	M3_20:1.2
	v20061117-0800:1.2
	v20061013-1330:1.2
	v20060925-1700:1.2
	v20060919-0800:1.2
	M1_20:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1200:1.2
	v20060531-1730:1.2
	v20060526-1200:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.6
date	2008.07.10.12.29.41;	author ashatalin;	state Exp;
branches;
next	1.5;
commitid	7c30487600b44567;

1.5
date	2007.03.14.12.59.21;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	10e945f7f1a74567;

1.4
date	2007.02.27.19.13.36;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	161045e482e04567;

1.3
date	2007.02.27.14.36.20;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	776245e441e44567;

1.2
date	2006.05.24.14.57.47;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.23.21.09.46;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.6
log
@[217307] - "Add extension model" action: impossible use for additing nondeployed models
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.graphdef.codegen.ui;

import java.io.IOException;
import java.util.ArrayList;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.ContentHandler;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.gmf.gmfgraph.Canvas;
import org.eclipse.gmf.gmfgraph.FigureGallery;
import org.eclipse.gmf.gmfgraph.GMFGraphPackage;
import org.eclipse.gmf.graphdef.codegen.StandaloneGenerator.Processor;
import org.eclipse.gmf.internal.graphdef.codegen.CanvasProcessor;
import org.eclipse.gmf.internal.graphdef.codegen.GalleryMirrorProcessor;
import org.eclipse.gmf.internal.graphdef.codegen.GalleryProcessor;


/**
 * @@author artem
 */
class ConverterOutcome {

	private final ConverterOptions myOptions;
	private Processor myProcessor;
	private final Resource[] myInput;

	public ConverterOutcome(ConverterOptions options, Resource[] input) {
		myOptions = options;
		myInput = input;
	}

	public IStatus checkInputAgainstOptions() {
		if (myOptions.needMirroredCanvas) {
			Canvas[] c = findCanvases(myInput);
			if (c.length == 0) {
				return newError("Need canvas instance", null);
			} else if (c.length > 1) {
				return newError("Need exactly one canvas instance", null);
			}
		} else if (myOptions.needMirroredGalleries) {
			FigureGallery[] figures = findFigures(myInput);
			if (figures.length == 0) {
				return newError("Need at least one figure gallery", null);
			}
		}
		return Status.OK_STATUS;
	}

	public Processor getProcessor() {
		if (myProcessor == null) {
			myProcessor = createProcessor();
		}
		return myProcessor;
	}

	private Processor createProcessor() {
		if (myOptions.needMirroredCanvas) {
			return new CanvasProcessor(inputAsCanvas());
		} else if (myOptions.needMirroredGalleries) {
			return new GalleryMirrorProcessor(inputAsGalleries());
		} else {
			return new GalleryProcessor(inputAsGalleries());
		}
	}

	private FigureGallery[] inputAsGalleries() {
		return findFigures(myInput);
	}

	private Canvas inputAsCanvas() {
		return findCanvases(myInput)[0];
	}

	public IStatus createResources(ResourceSet rs, URI galleryResourceURI, URI mirroredCanvasURI) {
		assert rs != null && galleryResourceURI != null && mirroredCanvasURI != null;
		Resource canvasResource = null;
		Resource galleryResource = null;
		if (myOptions.needMirroredCanvas) {
			// need mirroredCanvas enforces mirrored galleries.
			// the only difference with galleries in this case is where to put them - either 
			// separate resource or not. 
			Canvas mirror = ((CanvasProcessor) getProcessor()).getOutcome();
			canvasResource = rs.createResource(mirroredCanvasURI, ContentHandler.UNSPECIFIED_CONTENT_TYPE);
			canvasResource.getContents().add(mirror);
			if (myOptions.needMirroredGalleries && myOptions.separateMirrorFiles) {
				// sic! - respect separate mirror files only if explicitly asked to mirror galleries
				// because separateMirrorFiles could be true when value for galleryOutputPath not set
				galleryResource = rs.createResource(galleryResourceURI, ContentHandler.UNSPECIFIED_CONTENT_TYPE);
				// XXX make sure we support containments in different resources
				galleryResource.getContents().addAll(mirror.getFigures());
			}
			
		} else if (myOptions.needMirroredGalleries) {
			galleryResource = rs.createResource(galleryResourceURI, ContentHandler.UNSPECIFIED_CONTENT_TYPE);
			GalleryMirrorProcessor processor = (GalleryMirrorProcessor) getProcessor();
			galleryResource.getContents().add(processor.convertFigureGallery());
		}
		try {
			if (galleryResource != null) {
				galleryResource.save(null);
			}
			if (canvasResource != null) {
				canvasResource.save(null);
			}
		} catch (IOException ex) {
			return newError(ex.getMessage(), ex);
		}
		return Status.OK_STATUS;
	}

	private static Status newError(String message, Exception ex) {
		return new Status(IStatus.ERROR, "org.eclipse.gmf.graphdef.codegen.ui", 0, message, ex);
	}

	private static FigureGallery[] findFigures(Resource[] resources) {
		ArrayList<FigureGallery> rv = new ArrayList<FigureGallery>();
		for (int i = 0; i < resources.length; i++) {
			for(TreeIterator<EObject> it = resources[i].getAllContents(); it.hasNext();) {
				EObject next = it.next();
				// FigureGallery could be either top element or as a child of canvas
				if (next.eClass().getClassifierID() == GMFGraphPackage.FIGURE_GALLERY) {
					rv.add((FigureGallery) next);
					it.prune();
				} else if (next.eClass().getClassifierID() != GMFGraphPackage.CANVAS) {
					it.prune();
				}
			}
		}
		return rv.toArray(new FigureGallery[rv.size()]);
	}

	private static Canvas[] findCanvases(Resource[] resources) {
		ArrayList<Canvas> rv = new ArrayList<Canvas>();
		for (int i = 0; i < resources.length; i++) {
			for(EObject next : resources[i].getContents()) {
				if (next.eClass().getClassifierID() == GMFGraphPackage.CANVAS) {
					rv.add((Canvas) next);
				}
			}
		}
		return rv.toArray(new Canvas[rv.size()]);
	}
}
@


1.5
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d22 1
d99 1
a99 1
			canvasResource = rs.createResource(mirroredCanvasURI);
d104 1
a104 1
				galleryResource = rs.createResource(galleryResourceURI);
d110 1
a110 1
			galleryResource = rs.createResource(galleryResourceURI);
@


1.4
log
@finally implement inputAsGalleries
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
a15 1
import java.util.Iterator;
d133 2
a134 2
			for(TreeIterator it = resources[i].getAllContents(); it.hasNext();) {
				EObject next = (EObject) it.next();
d150 1
a150 2
			for(Iterator it = resources[i].getContents().iterator(); it.hasNext();) {
				EObject next = (EObject) it.next();
@


1.3
log
@use generics wherever possible
@
text
@a81 3
	/**
	 * @@return
	 */
d83 1
a83 2
		// TODO Auto-generated method stub
		return null;
d87 1
a87 1
		return (Canvas) myInput[0].getContents().get(0);
@


1.2
log
@get rid of bogus config passing into ConverterOutcome
@
text
@d136 1
a136 1
		ArrayList rv = new ArrayList();
d142 1
a142 1
					rv.add(next);
d149 1
a149 1
		return (FigureGallery[]) rv.toArray(new FigureGallery[rv.size()]);
d153 1
a153 1
		ArrayList rv = new ArrayList();
d158 1
a158 1
					rv.add(next);
d162 1
a162 1
		return (Canvas[]) rv.toArray(new Canvas[rv.size()]);
@


1.1
log
@#140887 Remove Child interface from GMFGraph.
Although the need to reference child figures persist, thus FigureHandle was introduced, to allow diagramElements to reference either *generateable* figures (Figure subclasses) or *just-use* figures (like CustomFigure and FigureAccessor).
Refactoring performed with #131365 "Mirror GMFGraph model when generating standalone figure plugin" in mind
@
text
@a27 1
import org.eclipse.gmf.graphdef.codegen.StandaloneGenerator.Config;
d94 1
a94 2
	// TODO get rid of config argument
	public IStatus createResources(ResourceSet rs, URI galleryResourceURI, URI mirroredCanvasURI, Config config) {
d116 1
a116 1
			galleryResource.getContents().add(processor.convertFigureGallery(config));
@

