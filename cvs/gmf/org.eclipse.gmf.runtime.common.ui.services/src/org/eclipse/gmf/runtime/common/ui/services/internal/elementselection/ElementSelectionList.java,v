head	1.3;
access;
symbols
	v20081020-0700:1.3
	v20080722-1827:1.3
	v20080718-1700:1.3
	v20080718-1731:1.3
	R2_1_maintenance:1.3.0.4
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080612-1229:1.3
	v20080425-1959:1.3
	v20080222-1200:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	RC3_20:1.3
	v20070601-1400:1.3
	v20070518-1300:1.3
	v20070504-1000:1.3
	v20070420-1000:1.3
	v20070330-1300:1.3
	v20070208-1800:1.3
	v20070105-1200:1.2.2.1
	v20070103-0300:1.3
	M4_20:1.3
	v20061218-1500:1.2.2.1
	v20061218-1200:1.3
	v20061214-0000:1.3
	M3_20:1.3
	v20061013-1330:1.3
	v20061012-1100:1.2.2.1
	v20060925-1700:1.2.2.1
	v20060919-0800:1.2.2.1
	M1_20:1.2
	v20060831-1500:1.2
	v20060824-1600:1.2
	v20060803-1200:1.2
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060526-1200:1.2
	v20060519-0800:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.1
	I20060331-1000:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.3
date	2006.10.03.15.01.46;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.13.19.31.53;	author ahunter;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.03.31.02.09.33;	author ahunter;	state Exp;
branches;
next	;

1.2.2.1
date	2006.09.13.16.41.29;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.3
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/
package org.eclipse.gmf.runtime.common.ui.services.internal.elementselection;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.gmf.runtime.common.ui.services.elementselection.ElementSelectionService;
import org.eclipse.gmf.runtime.common.ui.services.elementselection.ElementSelectionServiceJob;
import org.eclipse.gmf.runtime.common.ui.services.elementselection.IElementSelectionInput;
import org.eclipse.gmf.runtime.common.ui.services.elementselection.IElementSelectionListener;
import org.eclipse.gmf.runtime.common.ui.services.elementselection.IMatchingObjectEvent;
import org.eclipse.gmf.runtime.common.ui.services.elementselection.MatchingObjectEventType;
import org.eclipse.ui.PlatformUI;

/**
 * For backward compatibility, use the element selection service and return the
 * results in a list.
 * 
 * @@author Anthony Hunter
 */
public class ElementSelectionList {

    private List results = new ArrayList();

    private MatchingObjectEventType running = MatchingObjectEventType.MATCH;

    private IElementSelectionInput elementSelectionInput;

    class ElementSelectionListener
        implements IElementSelectionListener {

        public void matchingObjectEvent(IMatchingObjectEvent matchingObjectEvent) {
            if (matchingObjectEvent.getEventType() == MatchingObjectEventType.END_OF_MATCHES) {
                synchronized (running) {
                    running = MatchingObjectEventType.END_OF_MATCHES;
                }
            } else {
                synchronized (results) {
                    results.add(matchingObjectEvent.getMatchingObject());
                }
            }
        }
    };

    /**
     * Run the element selection service and return the list of matching
     * objects.
     * 
     * @@param input
     *            input for the element selection service.
     * @@return the list of matching objects.
     */
    public List getMatchingObjects(IElementSelectionInput input) {
        this.elementSelectionInput = input;
        ElementSelectionServiceJob job = ElementSelectionService.getInstance()
            .getMatchingObjects(elementSelectionInput,
                new ElementSelectionListener());
        job.getName();
        while (true) {
            synchronized (running) {
                if (running == MatchingObjectEventType.END_OF_MATCHES) {
                    break;
                }
            }
            if (PlatformUI.getWorkbench().getDisplay().getThread().equals(
                Thread.currentThread())) {
                while (PlatformUI.getWorkbench().getDisplay().readAndDispatch()) {
                    // nothing, just dispatch events so the UI is not hung.
                }
            }
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                break;
            }
        }
        return results;
    }
}
@


1.2
log
@[136706] gmf_head ahunter 060413 Element Selection Service - requesting an option that will run service apis without progress monitor dialog
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
@


1.2.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
@


1.1
log
@[134197] gmf_head ahunter 060330 Element Selection Service should get results from multiple provider asynchronously
@
text
@a12 1
import java.lang.reflect.InvocationTargetException;
a15 2
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.gmf.runtime.common.core.util.Log;
a21 6
import org.eclipse.gmf.runtime.common.ui.services.internal.CommonUIServicesPlugin;
import org.eclipse.gmf.runtime.common.ui.services.internal.CommonUIServicesStatusCodes;
import org.eclipse.gmf.runtime.common.ui.services.internal.l10n.CommonUIServicesMessages;
import org.eclipse.jface.dialogs.ProgressMonitorDialog;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.osgi.util.NLS;
a35 2
    private IProgressMonitor progressMonitor;

d43 3
a45 1
                running = MatchingObjectEventType.END_OF_MATCHES;
a46 3
                progressMonitor.worked(1);
                progressMonitor.subTask(matchingObjectEvent.getMatchingObject()
                    .getDisplayName());
d54 17
a70 18
    IRunnableWithProgress runnable = new IRunnableWithProgress() {

        public void run(IProgressMonitor monitor)
            throws InvocationTargetException, InterruptedException {
            progressMonitor = monitor;
            ElementSelectionServiceJob job = ElementSelectionService.getInstance().getMatchingObjects(
                elementSelectionInput, new ElementSelectionListener());
            monitor.beginTask(getJobName(), 1000);
            while (true) {
                synchronized (running) {
                    if (running == MatchingObjectEventType.END_OF_MATCHES) {
                        break;
                    }
                }
                monitor.worked(1);
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
d73 5
a77 3
                if (monitor.isCanceled()) {
                    job.cancel();
                    break;
d80 5
a84 17
            monitor.done();
        }
    };

    public List getMatchingObjects(IElementSelectionInput input) {
        this.elementSelectionInput = input;
        try {
            new ProgressMonitorDialog(PlatformUI.getWorkbench().getDisplay()
                .getActiveShell()).run(true, true, runnable);
        } catch (InvocationTargetException e) {
            Log.error(CommonUIServicesPlugin.getDefault(),
                CommonUIServicesStatusCodes.SERVICE_FAILURE,
                "executeWithProgressMonitor", e); //$NON-NLS-1$
        } catch (InterruptedException e) {
            /**
             * Just return when interrupted.
             */
a87 15

    /**
     * Get the name for the ElementSelectionServiceJob. Clients can override.
     * 
     * @@return the name for the job.
     */
    protected String getJobName() {
        String providerName = getClass().getName().substring(
            getClass().getName().lastIndexOf('.') + 1);
        String filter = elementSelectionInput.getInput();
        return NLS.bind(
            CommonUIServicesMessages.ElementSelectionService_JobName,
            new String[] {providerName, filter});
    }

@

