head	1.8;
access;
symbols
	v20081020-0700:1.8
	v20080722-1827:1.8
	v20080718-1700:1.8
	v20080718-1731:1.8
	R2_1_maintenance:1.8.0.4
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080612-1229:1.8
	v20080425-1959:1.8
	v20080222-1200:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	RC3_20:1.8
	v20070601-1400:1.8
	v20070518-1300:1.8
	v20070504-1000:1.8
	v20070420-1000:1.8
	v20070330-1300:1.8
	v20070208-1800:1.8
	v20070105-1200:1.6.2.8
	v20070103-0300:1.8
	M4_20:1.8
	v20061218-1500:1.6.2.8
	v20061218-1200:1.8
	v20061214-0000:1.8
	M3_20:1.8
	v20061013-1330:1.8
	v20061012-1100:1.6.2.8
	v20060925-1700:1.6.2.7
	v20060919-0800:1.6.2.6
	M1_20:1.6
	v20060831-1500:1.6.2.6
	v20060824-1600:1.6.2.5
	v20060803-1200:1.6.2.4
	v20060721-1130:1.6.2.2
	v20060713-1700:1.6.2.1
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060616-1200:1.6
	v20060609-1400:1.6
	v20060531-1730:1.6
	v20060526-1200:1.6
	v20060519-0800:1.6
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.4
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.3
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060202-1415:1.2
	I20060129-1145:1.1
	I20060127-0900:1.1
	I20060120-1530:1.1
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1
	I20060105-1630:1.1
	I20051230-1230:1.1
	I20051223-1100:1.1
	I20051217-0925:1.1
	I20051124-2000:1.1
	M3_10:1.1
	I20051118-1245:1.1
	I20051111-1800:1.1
	I20051106-0900:1.1
	v20051030:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2006.10.06.14.31.39;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.03.15.01.46;	author ahunter;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.06.20.40.42;	author ldamus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2006.04.06.20.15.27;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.31.02.09.33;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.17.19.21.34;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.02.17.07.18;	author ahunter;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.23.14.43.53;	author ahunter;	state Exp;
branches;
next	;

1.6.2.1
date	2006.07.12.19.35.16;	author ahunter;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2006.07.19.20.08.59;	author ahunter;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2006.08.02.17.39.36;	author ahunter;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2006.08.02.18.01.56;	author ahunter;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2006.08.21.16.00.27;	author cmahoney;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2006.08.29.14.21.26;	author cmahoney;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2006.09.22.20.09.50;	author ahunter;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2006.10.06.14.26.27;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.8
log
@[159928] gmf_head ahunter 061006 Merge 1.0.2 fix to head
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/
package org.eclipse.gmf.runtime.common.ui.services.elementselection;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.ui.services.internal.l10n.CommonUIServicesMessages;
import org.eclipse.jface.dialogs.Dialog;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.TableViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerSorter;
import org.eclipse.jface.wizard.ProgressMonitorPart;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.ModifyEvent;
import org.eclipse.swt.events.ModifyListener;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.events.SelectionListener;
import org.eclipse.swt.graphics.FontMetrics;
import org.eclipse.swt.graphics.GC;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.Text;

/**
 * The element selection composite. The composite functional similar to the JDT
 * select type dialog. There is a filter field and a table containing a list of
 * elements to select from.
 * <p>
 * The element selection composite requires an IElementSelectionInput as input
 * for the element selection service.
 * <p>
 * Subclasses must override the {@@link #isValidSelection}and
 * {@@link #handleSelection(boolean)} to provide custom validation.
 * 
 * @@author Anthony Hunter
 */
public abstract class ElementSelectionComposite
    implements IElementSelectionListener {

    /**
     * The title to display at the top of the element selection composite.
     */
    private final String title;

    /**
     * The elements that have been selected by the user.
     */
    private final List selectedElements = new ArrayList();

    /**
     * Text control to display the filter text.
     */
    private Text filterText = null;

    /**
     * The table viewer to display list of matching objects.
     */
    private TableViewer tableViewer = null;

    /**
     * The progress bar when searching for matching objects.
     */
    private ProgressMonitorPart progressBar;

    /**
     * The input for the element selection service.
     */
    private AbstractElementSelectionInput input;

    /**
     * The job running the element selection service.
     */
    private ElementSelectionServiceJob job;

    /**
     * The element selection service to use to search for elements.
     */
    private final ElementSelectionService elementSelectionService;

    /**
     * Control character for the filter.
     * <p>
     * When the user enters the first character into the filterText, element
     * selection service is called. When the user enters the second character
     * after the first, we can use the existing results returned by the service.
     * If the user enters text such that the first character has been changed,
     * we need to query the service again.
     * <p>
     * For example, if the user enters "a" then "ab", we can use the existing
     * results from "a". If the user enters "a" then "b", then we must query a
     * second time.
     * <p>
     * We also must remember if the service has already been called. If the user
     * enters "a" and then "b", we must cancel "a" and wait before calling the
     * service for "b".
     */
    private char firstCharacter = Character.MIN_VALUE;

    private String lastSearchedFor = StringStatics.BLANK;

    private int lastScopeSearchedFor = 0;

    /**
     * matching objects from the element selection service.
     */
    private List matchingObjects = new ArrayList();

    /**
     * Pattern for the input filter.
     */
    private Pattern pattern;

    /**
     * Constructs a new instance that will create the new composite. I will use
     * the default {@@linkplain ElementSelectionService#getInstance() selection service}
     * to process the <tt>input</tt>.
     * 
     * @@param title
     *            the dialog title
     * @@param input
     *            the element selection input.
     */
    public ElementSelectionComposite(String title,
            AbstractElementSelectionInput input) {
        this(title, input, ElementSelectionService.getInstance());
    }

    /**
     * Constructs a new instance that will create the new composite.
     * 
     * @@param title the dialog title
     * @@param input the element selection input
     * @@param elementSelectionService the selection service to use to process the
     *     <tt>input</tt>
     */
    public ElementSelectionComposite(String title,
            AbstractElementSelectionInput input,
            ElementSelectionService elementSelectionService) {
        super();
        this.title = title;
        this.input = input;
        this.elementSelectionService = elementSelectionService;
        this.lastScopeSearchedFor = input.getScope().intValue();
    }

    /**
     * Determines if the selected elements are a valid selection.
     * 
     * @@param currentSelectedElements
     *            the selected list of Elements
     * @@return <code>true</code> if the selected elements are a valid
     *         selection
     */
    abstract protected boolean isValidSelection(List currentSelectedElements);

    /**
     * Handle a selection change, where the validity of the new selection is
     * encoded in <code>isValid</code>.
     * 
     * @@param isValid
     *            <code>true</code> if the new selection is valid,
     *            <code>false</code> otherwise.
     */
    protected abstract void handleSelection(boolean isValid);

    /**
     * Creates the composite.
     * 
     * @@param parent
     *            the parent composite
     * @@return the new composite
     */
    public Composite createComposite(Composite parent) {

        Composite result = new Composite(parent, SWT.NONE);
        result.setLayout(new GridLayout());
        result.setLayoutData(new GridData(GridData.FILL_BOTH));

        // Add the selection title label
        Label label = new Label(result, SWT.NONE);
        label.setText(title);

        // Add the element selection text widget
        filterText = new Text(result, SWT.SINGLE | SWT.BORDER);
        filterText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
        filterText.addModifyListener(new ModifyListener() {

            public void modifyText(ModifyEvent e) {
                handleFilterChange();
            }

        });

        // Add the table viewer
        int selectStyle = SWT.SINGLE;
        tableViewer = new TableViewer(result, selectStyle | SWT.H_SCROLL
            | SWT.V_SCROLL | SWT.BORDER);
        tableViewer.setUseHashlookup(true);

        Table table = tableViewer.getTable();
        GridData gridData = new GridData(GridData.FILL_BOTH);
        GC gc = new GC(result);
        gc.setFont(JFaceResources.getDefaultFont());
        FontMetrics fontMetrics = gc.getFontMetrics();
        gc.dispose();
        gridData.widthHint = Dialog
            .convertWidthInCharsToPixels(fontMetrics, 80);
        gridData.heightHint = table.getItemHeight() * 15;
        table.setLayoutData(gridData);

        table.addSelectionListener(new SelectionListener() {

            public void widgetSelected(SelectionEvent e) {
                handleSelectionChange();
            }

            public void widgetDefaultSelected(SelectionEvent e) {
                handleWidgetDefaultSelected();
            }
        });

        progressBar = new ProgressMonitorPart(result, new GridLayout());
        progressBar.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
        progressBar.setVisible(false);

        tableViewer.setLabelProvider(new LabelProvider() {

            public Image getImage(Object element) {
                assert element instanceof AbstractMatchingObject;
                return ((AbstractMatchingObject) element).getImage();
            }

            public String getText(Object element) {
                assert element instanceof AbstractMatchingObject;
                return ((AbstractMatchingObject) element).getDisplayName();
            }
        });
        tableViewer.setSorter(new ViewerSorter() {

            public int compare(Viewer viewer, Object e1, Object e2) {
                if (e1 instanceof IMatchingObject && e2 instanceof IMatchingObject)
                    return ((IMatchingObject)e1).getName().toLowerCase().compareTo(
                            ((IMatchingObject) e2).getName().toLowerCase());

                return super.compare(viewer, e1, e2);
            }
        });

        createCompositeAdditions(result);

        return result;
    }

    /**
     * The method is provided so that clients can add additional fields to the
     * bottom of the selection composite. For example, clients may want to a
     * checkbox button to the bottom of the composite.
     * 
     * @@param parent
     *            the parent composite
     */
    protected void createCompositeAdditions(Composite parent) {
        /* clients are expected to override this method */
    }

    /**
     * Handles a filter change.
     */
    public void handleFilterChange() {
        if (filterText.getText().equals(StringStatics.BLANK)) {
            /* no filter, no results */
            cancel();
            matchingObjects.clear();
            tableViewer.getTable().removeAll();
            firstCharacter = Character.MIN_VALUE;
            return;
        }

        String filter = validatePattern(filterText.getText());
        pattern = Pattern.compile(filter);
        if (firstCharacter != filterText.getText().charAt(0) ||
                this.input.getScope().intValue() != this.lastScopeSearchedFor ||
                !filterText.getText().startsWith(lastSearchedFor)) {
            // scope changes, start from scratch...
            cancel();
            matchingObjects.clear();
            tableViewer.getTable().removeAll();

            firstCharacter = filterText.getText().charAt(0);
            this.lastScopeSearchedFor = this.input.getScope().intValue();

            startElementSelectionService();
        } else {
            /*
             * clear the existing matches in the table and refilter results we have
             * received
             */
            tableViewer.getTable().removeAll();
            for (Iterator i = matchingObjects.iterator(); i.hasNext();) {
                IMatchingObject matchingObject = (IMatchingObject) i.next();
                Matcher matcher = pattern.matcher(matchingObject.getName()
                    .toLowerCase());
                if (matcher.matches()) {
                    tableViewer.add(matchingObject);
                    setSelection();
                }
            }
        }
    }

    /**
     * Fill the table viewer with results from the element selection service.
     */
    private void startElementSelectionService() {
        /*
         * Initialize all possible matching objects from the select element
         * service.
         */
        input.setInput(filterText.getText());
        lastSearchedFor = filterText.getText();

        progressBar.setVisible(true);
        progressBar.beginTask(
            CommonUIServicesMessages.ElementSelectionService_ProgressName,
            IProgressMonitor.UNKNOWN);

        job = elementSelectionService.getMatchingObjects(input, this);
    }

    /**
     * Handles a selection change and validates the new selection.
     */
    private void handleSelectionChange() {
        StructuredSelection selection = (StructuredSelection) tableViewer
            .getSelection();
        if (selection.size() == 0) {
            // nothing selected
            selectedElements.clear();
            handleSelection(false);
            return;
        }

        List selectionList = selection.toList();

        // get the current selected elements
        List currentSelectedElements = new ArrayList();
        for (Iterator iter = selectionList.iterator(); iter.hasNext();) {
            AbstractMatchingObject matchingObject = (AbstractMatchingObject) iter
                .next();
            currentSelectedElements.add(matchingObject);
        }

        // validate selection
        boolean isValidSelection = isValidSelection(currentSelectedElements);

        // store the selection
        selectedElements.clear();
        if (isValidSelection) {
            selectedElements.addAll(currentSelectedElements);
        }

        // update UI based on selection
        handleSelection(isValidSelection);

    }

    /**
     * Gets the user selected elements.
     * 
     * @@return the user selected elements
     */
    public List getSelectedElements() {
        List result = new ArrayList();
        for (Iterator iter = selectedElements.iterator(); iter.hasNext();) {
            IMatchingObject matchingObject = (IMatchingObject) iter.next();
            IElementSelectionProvider provider = matchingObject.getProvider();
            Object object = provider.resolve(matchingObject);
            result.add(object);
        }
        return result;
    }

    public void matchingObjectEvent(IMatchingObjectEvent matchingObjectEvent) {
        if (!progressBar.isDisposed()) {
            if (matchingObjectEvent.getEventType() == MatchingObjectEventType.END_OF_MATCHES) {
                progressBar.done();
                progressBar.setVisible(false);
                job = null;
            } else {
                IMatchingObject matchingObject = matchingObjectEvent
                    .getMatchingObject();
                progressBar.worked(1);
                progressBar.subTask(matchingObject.getName());
                matchingObjects.add(matchingObject);
                Matcher matcher = pattern.matcher(matchingObject.getName()
                    .toLowerCase());
                if (matcher.matches()) {
                    tableViewer.add(matchingObject);
                    setSelection();
                }
            }
        }
    }

    /**
     * Cancel the job running the element selection service.
     */
    public void cancel() {
        if (job != null) {
            elementSelectionService.cancelJob(job);
            job = null;
            progressBar.done();
            progressBar.setVisible(false);
        }
    }

    /**
     * Convert the UNIX style pattern entered by the user to a Java regex
     * pattern (? = any character, * = any string).
     * 
     * @@param string
     *            the UNIX style pattern.
     * @@return a Java regex pattern.
     */
    private String validatePattern(String string) {
        if (string.equals(StringStatics.BLANK)) {
            return string;
        }
        StringBuffer result = new StringBuffer();
        for (int i = 0; i < string.length(); i++) {
            char c = Character.toLowerCase(string.charAt(i));
            if (c == '?') {
                result.append('.');
            } else if (c == '*') {
                result.append(".*"); //$NON-NLS-1$
            } else {
                result.append(c);
            }
        }
        result.append(".*"); //$NON-NLS-1$
        return result.toString();
    }

    /**
     * If there is no selection in the composite, set the selection to the
     * provided MatchingObject.
     * 
     * @@param matchingObject
     *            the MatchingObject to select.
     */
    protected void setSelection() {
        StructuredSelection selection = (StructuredSelection) tableViewer
            .getSelection();
        if (selection.isEmpty()) {
            tableViewer.getTable().setSelection(0);
            handleSelectionChange();
        }
    }

    /**
     * Retreive the filter text field.
     * 
     * @@return the filter text field.
     */
    public Text getFilterText() {
        return filterText;
    }

    /**
     * Retreive the element selection service job.
     * 
     * @@return the element selection service job.
     */
    public ElementSelectionServiceJob getSelectionServiceJob() {
        return job;
    }

    /**
     * Handle the double click of a selection in the table viewer.
     */
    protected void handleWidgetDefaultSelected() {
        /** Default behavior is to do nothing. Subclasses can override. */
    }
}
@


1.7
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d95 1
a95 1
    
d119 1
d121 1
d133 1
a133 1
    
d135 1
a135 1
     * Constructs a new instance that will create the new composite.  I will use
d148 1
a148 1
    
d158 6
a163 6
    		AbstractElementSelectionInput input,
    		ElementSelectionService elementSelectionService) {
    	super();
    	this.title = title;
    	this.input = input;
    	this.elementSelectionService = elementSelectionService;
d239 1
a239 1
                // method not implemented
d260 1
d264 2
a265 2
                        ((IMatchingObject)e2).getName().toLowerCase());
                
d295 1
a295 1
            tableViewer.getTable().removeAll();            
d299 1
a299 1
        
d305 1
a305 1
            //scope changes, start from scratch...
d309 1
a309 1
            
d312 1
a312 1
            
d342 1
a342 1
        
a480 1
    
d482 12
a493 1
     * @@return the job
d498 7
@


1.6
log
@[135386] gmf_head ldamus 060406 Runtime plugin dependencies must specify required plugin versions
@
text
@d16 2
a19 1
import org.eclipse.core.runtime.jobs.Job;
d27 1
d94 6
a99 1
    private Job job;
d102 34
a135 1
     * Constructs a new instance that will create the new composite.
d144 19
a162 3
        super();
        this.title = title;
        this.input = input;
d257 9
a265 1
        tableViewer.setSorter(new ViewerSorter());
d287 39
a325 6
    private void handleFilterChange() {
        input.setInput(filterText.getText());
        fillTableViewer();
        Object element = tableViewer.getElementAt(0);
        if (element != null) {
            tableViewer.setSelection(new StructuredSelection(element), true);
a326 1
        handleSelectionChange();
d332 1
a332 6
    private void fillTableViewer() {
        /*
         * Clean the previous list
         */
        tableViewer.getTable().removeAll();

d337 7
a343 10
        if (!input.getInput().equals(StringStatics.BLANK)) {
            filterText.setEnabled(false);
            progressBar.setVisible(true);
            progressBar.beginTask(
                CommonUIServicesMessages.ElementSelectionService_ProgressName,
                IProgressMonitor.UNKNOWN);

            job = ElementSelectionService.getInstance().getMatchingObjects(
                input, this);
        }
d345 1
d406 1
a406 2
                filterText.setEnabled(true);
                filterText.setFocus();
d408 2
d411 8
a418 3
                progressBar.subTask(matchingObjectEvent.getMatchingObject()
                    .getName());
                tableViewer.add(matchingObjectEvent.getMatchingObject());
d428 29
a456 1
            job.cancel();
d458 26
@


1.6.2.1
log
@[148427] gmf_R1_0_maintenance cdamus 060712 Need ability to extend ElementSelectionService for transaction support
@
text
@a92 5
    
    /**
     * The element selection service to use to search for elements.
     */
    private final ElementSelectionService elementSelectionService;
d95 1
a95 3
     * Constructs a new instance that will create the new composite.  I will use
     * the default {@@linkplain ElementSelectionService#getInstance() selection service}
     * to process the <tt>input</tt>.
d104 3
a106 18
        this(title, input, ElementSelectionService.getInstance());
    }
    
    /**
     * Constructs a new instance that will create the new composite.
     * 
     * @@param title the dialog title
     * @@param input the element selection input
     * @@param elementSelectionService the selection service to use to process the
     *     <tt>input</tt>
     */
    public ElementSelectionComposite(String title,
    		AbstractElementSelectionInput input,
    		ElementSelectionService elementSelectionService) {
    	super();
    	this.title = title;
    	this.input = input;
    	this.elementSelectionService = elementSelectionService;
d253 2
a254 1
            job = elementSelectionService.getMatchingObjects(input, this);
@


1.6.2.2
log
@[139313] gmf_R1_0_maintenance ahunter 060719 Performance issues with Element Selection Service
@
text
@a15 2
import java.util.regex.Matcher;
import java.util.regex.Pattern;
a99 29
     * Control character for the filter.
     * <p>
     * When the user enters the first character into the filterText, element
     * selection service is called. When the user enters the second character
     * after the first, we can use the existing results returned by the service.
     * If the user enters text such that the first character has been changed,
     * we need to query the service again.
     * <p>
     * For example, if the user enters "a" then "ab", we can use the existing
     * results from "a". If the user enters "a" then "b", then we must query a
     * second time.
     * <p>
     * We also must remember if the service has already been called. If the user
     * enters "a" and then "b", we must cancel "a" and wait before calling the
     * service for "b".
     */
    private char firstCharacter = Character.MIN_VALUE;

    /**
     * matching objects from the element selection service.
     */
    private List matchingObjects = new ArrayList();

    /**
     * Pattern for the input filter.
     */
    private Pattern pattern;

    /**
d246 5
a250 7
        if (filterText.getText().equals(StringStatics.BLANK)) {
            /* no filter, no results */
            cancel();
            tableViewer.getTable().removeAll();
            matchingObjects.clear();
            firstCharacter = Character.MIN_VALUE;
            return;
d252 2
d255 4
d260 1
a260 2
         * clear the existing matches in the table and refilter results we have
         * received
a261 2
        String filter = validatePattern(filterText.getText());
        pattern = Pattern.compile(filter);
a262 9
        for (Iterator i = matchingObjects.iterator(); i.hasNext();) {
            IMatchingObject matchingObject = (IMatchingObject) i.next();
            Matcher matcher = pattern.matcher(matchingObject.getName()
                .toLowerCase());
            if (matcher.matches()) {
                tableViewer.add(matchingObject);
                setSelection();
            }
        }
a263 10
        if (firstCharacter == Character.MIN_VALUE) {
            firstCharacter = filterText.getText().charAt(0);
            startElementSelectionService();
        }
    }

    /**
     * Fill the table viewer with results from the element selection service.
     */
    private void startElementSelectionService() {
d268 9
a276 5
        input.setInput(filterText.getText());
        progressBar.setVisible(true);
        progressBar.beginTask(
            CommonUIServicesMessages.ElementSelectionService_ProgressName,
            IProgressMonitor.UNKNOWN);
a277 1
        job = elementSelectionService.getMatchingObjects(input, this);
d338 2
a339 1
                job = null;
a340 2
                IMatchingObject matchingObject = matchingObjectEvent
                    .getMatchingObject();
d342 3
a344 8
                progressBar.subTask(matchingObject.getName());
                Matcher matcher = pattern.matcher(matchingObject.getName()
                    .toLowerCase());
                if (matcher.matches()) {
                    matchingObjects.add(matchingObject);
                    tableViewer.add(matchingObject);
                    setSelection();
                }
a354 44
            job = null;
        }
    }

    /**
     * Convert the UNIX style pattern entered by the user to a Java regex
     * pattern (? = any character, * = any string).
     * 
     * @@param string
     *            the UNIX style pattern.
     * @@return a Java regex pattern.
     */
    private String validatePattern(String string) {
        if (string.equals(StringStatics.BLANK)) {
            return string;
        }
        StringBuffer result = new StringBuffer();
        for (int i = 0; i < string.length(); i++) {
            char c = Character.toLowerCase(string.charAt(i));
            if (c == '?') {
                result.append('.');
            } else if (c == '*') {
                result.append(".*"); //$NON-NLS-1$
            } else {
                result.append(c);
            }
        }
        result.append(".*"); //$NON-NLS-1$
        return result.toString();
    }

    /**
     * If there is no selection in the composite, set the selection to the
     * provided MatchingObject.
     * 
     * @@param matchingObject
     *            the MatchingObject to select.
     */
    protected void setSelection() {
        StructuredSelection selection = (StructuredSelection) tableViewer
            .getSelection();
        if (selection.isEmpty()) {
            tableViewer.getTable().setSelection(0);
            handleSelectionChange();
@


1.6.2.3
log
@[151540] gmf_R_1_0_maintenance ahunter 060802 ElementSelectionComposite.handleFilterChange(..) should be public
@
text
@d276 1
a276 1
    public void handleFilterChange() {
@


1.6.2.4
log
@[151231] gmf_R_1_0_maintenance syedatif 060802 ElementSelectionComposite filter fails to re-query the service
@
text
@a118 1
    private String lastSearchedFor = StringStatics.BLANK;
d129 1
a129 1
    
d303 1
a303 3
        if ((firstCharacter == Character.MIN_VALUE) ||
        	(firstCharacter != filterText.getText().charAt(0)) ||
        	(filterText.getText().indexOf(lastSearchedFor) == -1)) {
a317 2
        lastSearchedFor = filterText.getText();
        
@


1.6.2.5
log
@Bugzilla#153584 gmf_R1_0_maintenance cmahoney 060821 ElementSelectionComposite.handleFilterChange(..) needs to respect scope changes [Contributed By: Syed Atif]
@
text
@a119 1
    private int lastScopeSearchedFor = 0;
a160 1
        this.lastScopeSearchedFor = input.getScope().intValue();
d286 1
a286 8
        
        if (this.input.getScope().intValue() != this.lastScopeSearchedFor) {
            //scope changes, start from scratch...
            
            tableViewer.getTable().removeAll();
            matchingObjects.clear();
        }
        
d306 1
a306 3
        	(filterText.getText().indexOf(lastSearchedFor) == -1) ||
            this.input.getScope().intValue() != this.lastScopeSearchedFor) {
            
a307 2
            this.lastScopeSearchedFor = this.input.getScope().intValue();
            
@


1.6.2.6
log
@Bugzilla#151542 gmf_R1_0_maintenance cmahoney 060829 Select Existing service doesn't sort results properly
Contributed by:  Syed Atif Ali
@
text
@a27 1
import org.eclipse.jface.viewers.Viewer;
d257 1
a257 9
        tableViewer.setSorter(new ViewerSorter() {
            public int compare(Viewer viewer, Object e1, Object e2) {
                if (e1 instanceof IMatchingObject && e2 instanceof IMatchingObject)
                    return ((IMatchingObject)e1).getName().toLowerCase().compareTo(
                        ((IMatchingObject)e2).getName().toLowerCase());
                
                return super.compare(viewer, e1, e2);
            }
        });
@


1.6.2.7
log
@[158368] gmf_R1_0_maintenance mgoyal 060922 ElementSelectionService isn't reentrant and won't search at times.
@
text
@d20 1
d95 1
a95 1
    private ElementSelectionServiceJob job;
d292 1
a293 1
            tableViewer.getTable().removeAll();            
d298 11
d311 15
a325 7
        if (firstCharacter != filterText.getText().charAt(0) ||
                this.input.getScope().intValue() != this.lastScopeSearchedFor ||
                !filterText.getText().startsWith(lastSearchedFor)) {
            //scope changes, start from scratch...
            cancel();
            matchingObjects.clear();
            tableViewer.getTable().removeAll();
a330 15
        } else {
            /*
             * clear the existing matches in the table and refilter results we have
             * received
             */
            tableViewer.getTable().removeAll();
            for (Iterator i = matchingObjects.iterator(); i.hasNext();) {
                IMatchingObject matchingObject = (IMatchingObject) i.next();
                Matcher matcher = pattern.matcher(matchingObject.getName()
                    .toLowerCase());
                if (matcher.matches()) {
                    tableViewer.add(matchingObject);
                    setSelection();
                }
            }
a416 1
                matchingObjects.add(matchingObject);
d420 1
d433 1
a433 1
            elementSelectionService.cancelJob(job);
a434 2
            progressBar.done();
            progressBar.setVisible(false);
a479 8

    
    /**
     * @@return the job
     */
    public ElementSelectionServiceJob getSelectionServiceJob() {
        return job;
    }
@


1.6.2.8
log
@[159928] gmf_R1_0_maintenance vtrivedi 061006 ElementSelectionComposite needs to provide support for widgetDefaultSelected()
@
text
@d95 1
a95 1

a118 1

a119 1

d131 1
a131 1

d133 1
a133 1
     * Constructs a new instance that will create the new composite. I will use
d146 1
a146 1

d156 6
a161 6
            AbstractElementSelectionInput input,
            ElementSelectionService elementSelectionService) {
        super();
        this.title = title;
        this.input = input;
        this.elementSelectionService = elementSelectionService;
d237 1
a237 1
                handleWidgetDefaultSelected();
a257 1

d261 2
a262 2
                            ((IMatchingObject) e2).getName().toLowerCase());

d292 1
a292 1
            tableViewer.getTable().removeAll();
d296 1
a296 1

d302 1
a302 1
            // scope changes, start from scratch...
d306 1
a306 1

d309 1
a309 1

d339 1
a339 1

d478 1
d480 1
a480 12
     * Retreive the filter text field.
     * 
     * @@return the filter text field.
     */
    public Text getFilterText() {
        return filterText;
    }

    /**
     * Retreive the element selection service job.
     * 
     * @@return the element selection service job.
a484 7

    /**
     * Handle the double click of a selection in the table viewer.
     */
    protected void handleWidgetDefaultSelected() {
        /** Default behavior is to do nothing. Subclasses can override. */
    }
@


1.5
log
@[135384] gmf_head ahunter 060406 NullPointerException in ElementSelectionComposite.cancel()
@
text
@a13 1
import java.util.HashMap;
a15 1
import java.util.Map;
@


1.4
log
@[134197] gmf_head ahunter 060330 Element Selection Service should get results from multiple provider asynchronously
@
text
@d334 3
a336 1
        job.cancel();
@


1.3
log
@[128433] gmf_head ahunter 060217 Element Selection Service should have a more generic mechanism for filtering
@
text
@d14 1
d17 1
d19 4
a22 2
import org.eclipse.gmf.runtime.common.ui.services.internal.elementselection.ElementSelectionCompositeContentProvider;
import org.eclipse.gmf.runtime.common.ui.services.internal.elementselection.ElementSelectionCompositeLabelProvider;
d25 1
d29 1
d37 1
d58 2
a59 1
public abstract class ElementSelectionComposite {
d82 5
d92 5
d187 16
a202 4
        tableViewer
            .setLabelProvider(new ElementSelectionCompositeLabelProvider());
        tableViewer
            .setContentProvider(new ElementSelectionCompositeContentProvider());
d227 1
a227 1
        tableViewer.setInput(input);
d236 26
d313 23
@


1.2
log
@gmf_head ahunter 060202 Element Selection Service updates
@
text
@d196 1
a196 1
        input.setFilter(filterText.getText());
@


1.1
log
@gmf_head ahunter 050923 Element Selection Service Update
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d49 1
a49 2
 * @@author Anthony Hunter <a href="mailto:anthonyh@@ca.ibm.com">
 *         anthonyh@@ca.ibm.com </a>
d53 204
a256 204
	/**
	 * The title to display at the top of the element selection composite.
	 */
	private final String title;

	/**
	 * The elements that have been selected by the user.
	 */
	private final List selectedElements = new ArrayList();

	/**
	 * Text control to display the filter text.
	 */
	private Text filterText = null;

	/**
	 * The table viewer to display list of matching objects.
	 */
	private TableViewer tableViewer = null;

	/**
	 * The input for the element selection service.
	 */
	private IElementSelectionInput input;

	/**
	 * Constructs a new instance that will create the new composite.
	 * 
	 * @@param title
	 *            the dialog title
	 * @@param input
	 *            the element selection input.
	 */
	public ElementSelectionComposite(String title, IElementSelectionInput input) {

		super();
		this.title = title;
		this.input = input;
	}

	/**
	 * Determines if the selected elements are a valid selection.
	 * 
	 * @@param currentSelectedElements
	 *            the selected list of Elements
	 * @@return <code>true</code> if the selected elements are a valid
	 *         selection
	 */
	abstract protected boolean isValidSelection(List currentSelectedElements);

	/**
	 * Handle a selection change, where the validity of the new selection is
	 * encoded in <code>isValid</code>.
	 * 
	 * @@param isValid
	 *            <code>true</code> if the new selection is valid,
	 *            <code>false</code> otherwise.
	 */
	public abstract void handleSelection(boolean isValid);

	/**
	 * Creates the composite.
	 * 
	 * @@param parent
	 *            the parent composite
	 * @@return the new composite
	 */
	public Composite createComposite(Composite parent) {

		Composite result = new Composite(parent, SWT.NONE);
		result.setLayout(new GridLayout());
		result.setLayoutData(new GridData(GridData.FILL_BOTH));

		// Add the selection title label
		Label label = new Label(result, SWT.NONE);
		label.setText(title);

		// Add the element selection text widget
		filterText = new Text(result, SWT.SINGLE | SWT.BORDER);
		filterText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
		filterText.addModifyListener(new ModifyListener() {

			public void modifyText(ModifyEvent e) {
				handleFilterChange();
			}

		});

		// Add the table viewer
		int selectStyle = SWT.SINGLE;
		tableViewer = new TableViewer(result, selectStyle | SWT.H_SCROLL
			| SWT.V_SCROLL | SWT.BORDER);
		tableViewer.setUseHashlookup(true);

		Table table = tableViewer.getTable();
		GridData gridData = new GridData(GridData.FILL_BOTH);
		GC gc = new GC(result);
		gc.setFont(JFaceResources.getDefaultFont());
		FontMetrics fontMetrics = gc.getFontMetrics();
		gc.dispose();
		gridData.widthHint = Dialog
			.convertWidthInCharsToPixels(fontMetrics, 80);
		gridData.heightHint = table.getItemHeight() * 15;
		table.setLayoutData(gridData);

		table.addSelectionListener(new SelectionListener() {

			public void widgetSelected(SelectionEvent e) {
				handleSelectionChange();
			}

			public void widgetDefaultSelected(SelectionEvent e) {
				// method not implemented
			}
		});

		tableViewer
			.setLabelProvider(new ElementSelectionCompositeLabelProvider());
		tableViewer
			.setContentProvider(new ElementSelectionCompositeContentProvider(
				input));
		tableViewer.setSorter(new ViewerSorter());

		createCompositeAdditions(result);

		return result;
	}

	/**
	 * The method is provided so that clients can add additional fields to the
	 * bottom of the selection composite. For example, clients may want to a
	 * checkbox button to the bottom of the composite.
	 * 
	 * @@param parent
	 *            the parent composite
	 */
	protected void createCompositeAdditions(Composite parent) {
		/* clients are expected to override this method */
	}

	/**
	 * Handles a filter change.
	 */
	private void handleFilterChange() {
		tableViewer.setInput(filterText.getText());
		Object element = tableViewer.getElementAt(0);
		if (element != null) {
			tableViewer.setSelection(new StructuredSelection(element), true);
		}
		handleSelectionChange();
	}

	/**
	 * Handles a selection change and validates the new selection.
	 */
	public void handleSelectionChange() {
		StructuredSelection selection = (StructuredSelection) tableViewer
			.getSelection();
		if (selection.size() == 0) {
			// nothing selected
			selectedElements.clear();
			handleSelection(false);
			return;
		}

		List selectionList = selection.toList();

		// get the current selected elements
		List currentSelectedElements = new ArrayList();
		for (Iterator iter = selectionList.iterator(); iter.hasNext();) {
			AbstractMatchingObject matchingObject = (AbstractMatchingObject) iter
				.next();
			currentSelectedElements.add(matchingObject);
		}

		// validate selection
		boolean isValidSelection = isValidSelection(currentSelectedElements);

		// store the selection
		selectedElements.clear();
		if (isValidSelection) {
			selectedElements.addAll(currentSelectedElements);
		}

		// update UI based on selection
		handleSelection(isValidSelection);

	}

	/**
	 * Gets the user selected elements.
	 * 
	 * @@return the user selected elements
	 */
	public List getSelectedElements() {
		List result = new ArrayList();
		for (Iterator iter = selectedElements.iterator(); iter.hasNext();) {
			IMatchingObject matchingObject = (IMatchingObject) iter.next();
			IElementSelectionProvider provider = matchingObject.getProvider();
			Object object = provider.resolve(matchingObject);
			result.add(object);
		}
		return result;
	}
@

