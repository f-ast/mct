head	1.7;
access;
symbols
	v20081020-0700:1.7
	v20080722-1827:1.7
	v20080718-1700:1.6.2.1
	v20080718-1731:1.7
	R2_1_maintenance:1.6.0.2
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080612-1229:1.6
	v20080425-1959:1.5
	v20080222-1200:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	RC3_20:1.5
	v20070601-1400:1.5
	v20070518-1300:1.5
	v20070504-1000:1.5
	v20070420-1000:1.5
	v20070330-1300:1.5
	v20070208-1800:1.5
	v20070105-1200:1.4.2.2
	v20070103-0300:1.5
	M4_20:1.5
	v20061218-1500:1.4.2.2
	v20061218-1200:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061013-1330:1.5
	v20061012-1100:1.4.2.2
	v20060925-1700:1.4.2.2
	v20060919-0800:1.4.2.1
	M1_20:1.4
	v20060831-1500:1.4.2.1
	v20060824-1600:1.4.2.1
	v20060803-1200:1.4.2.1
	v20060721-1130:1.4.2.1
	v20060713-1700:1.4.2.1
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060616-1200:1.4
	v20060609-1400:1.4
	v20060531-1730:1.3
	v20060526-1200:1.3
	v20060519-0800:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060202-1415:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.7
date	2008.07.18.21.26.30;	author ahunter;	state Exp;
branches;
next	1.6;
commitid	9a748810a854567;

1.6
date	2008.06.12.16.19.41;	author ahunter;	state Exp;
branches
	1.6.2.1;
next	1.5;
commitid	167648514c9c4567;

1.5
date	2006.10.03.15.01.46;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.05.18.30.29;	author cmahoney;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2006.03.31.02.09.33;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.04.20.18.22;	author ahunter;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.23.14.43.53;	author ahunter;	state Exp;
branches;
next	;

1.4.2.1
date	2006.07.12.19.35.16;	author ahunter;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2006.09.22.20.09.50;	author ahunter;	state Exp;
branches;
next	;

1.6.2.1
date	2008.07.18.21.25.42;	author ahunter;	state Exp;
branches;
next	;
commitid	12df48810a564567;


desc
@@


1.7
log
@[240979] gmf-head wdiu NPE in ElementSelectionService results in job never being able to be cancelled
@
text
@/******************************************************************************
 * Copyright 2005, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/
package org.eclipse.gmf.runtime.common.ui.services.elementselection;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.jobs.IJobManager;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.gmf.runtime.common.core.service.ExecutionStrategy;
import org.eclipse.gmf.runtime.common.core.service.IOperation;
import org.eclipse.gmf.runtime.common.core.service.Service;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.ui.services.internal.CommonUIServicesPlugin;
import org.eclipse.gmf.runtime.common.ui.services.internal.elementselection.ElementSelectionList;
import org.eclipse.gmf.runtime.common.ui.services.internal.elementselection.MatchingObjectsOperation;
import org.eclipse.gmf.runtime.common.ui.services.internal.l10n.CommonUIServicesMessages;
import org.eclipse.gmf.runtime.common.ui.services.util.ActivityFilterProviderDescriptor;
import org.eclipse.osgi.util.NLS;
import org.eclipse.ui.PlatformUI;

/**
 * The element selection service.
 * 
 * @@author Anthony Hunter
 */
public class ElementSelectionService
    extends Service
    implements IElementSelectionProvider, IElementSelectionListener {

    /**
     * A provider descriptor that will ignore providers that are contributed by
     * a plug-in that is matched to a disabled capability.
     */
    private static class ProviderDescriptor
        extends Service.ProviderDescriptor {

        private ActivityFilterProviderDescriptor activityFilter;

        public ProviderDescriptor(IConfigurationElement element) {
            super(element);
            activityFilter = new ActivityFilterProviderDescriptor(element);
        }

        public boolean provides(IOperation operation) {
            return activityFilter.provides(operation)
                && super.provides(operation);
        }
    }

    protected class JobData {
        public IElementSelectionInput elementSelectionInput;

        public IElementSelectionListener elementSelectionListener;

        public HashMap<IElementSelectionProvider, ElementSelectionServiceJob> jobs = 
            new HashMap<IElementSelectionProvider, ElementSelectionServiceJob>();
    }
    
    private Map<ElementSelectionServiceJob, JobData> jobs2Data = 
        new HashMap<ElementSelectionServiceJob, JobData>();
    
    public JobData getJobData() {
        Job currentJob = jobManager.currentJob();
        assert currentJob != null;
        
        if(currentJob == null) {
            return null;
        }
        
        JobData data = null;
        synchronized(jobs2Data) {
            data = jobs2Data.get(currentJob);
        }
        
        return data;
    }

    /**
     * The singleton instance of the type selection service.
     */
    private final static ElementSelectionService instance = new ElementSelectionService();

    static {
        instance.configureProviders();
    }

    /**
     * Constructs a new type selection service.
     */
    protected ElementSelectionService() {
        super(true);
    }

    /**
     * Retrieves the singleton instance of the type selection service.
     * 
     * @@return The type selection service singleton.
     */
    public static ElementSelectionService getInstance() {
        return instance;
    }

    /**
     * For backward compatibility, use the element selection service and return
     * the results in a list.
     * 
     * @@param input
     *            the element selection input.
     * @@return list of matching objects.
     */
    public List getMatchingObjects(IElementSelectionInput input) {
        return new ElementSelectionList().getMatchingObjects(input);
    }

    /**
     * {@@inheritDoc}
     */
    public ElementSelectionServiceJob getMatchingObjects(
            IElementSelectionInput input, IElementSelectionListener listener) {
        ElementSelectionServiceJob job = createSelectionJob();
        JobData data = new JobData();
        data.elementSelectionInput = input;
        data.elementSelectionListener = listener;
        job.setName(getJobName(data));
        synchronized(jobs2Data) {
            jobs2Data.put(job, data);
        }
        job.schedule();
        return job;
    }
    
    
    protected String getJobName() {
        return StringStatics.BLANK;
    }
    
    /**
     * Creates the selection service job that manages the individual provider
     * search jobs.  This method should configure the new job with the appropriate
     * priority, scheduling rules, etc. but should not schedule it.
     * 
     * @@return a new selection service job
     */
    protected ElementSelectionServiceJob createSelectionJob() {
        ElementSelectionServiceJob job = new ElementSelectionServiceJob(getJobName(), this);
        job.setPriority(Job.SHORT);
        return job;
    }
    
    public static final IJobManager jobManager = Job.getJobManager();

    /**
     * {@@inheritDoc}
     */
    public void run(IProgressMonitor monitor) {
        JobData data = getJobData();
        if(data == null)
            return;
        
        List<IElementSelectionProvider> results = new ArrayList<IElementSelectionProvider>();
        IOperation operation = new MatchingObjectsOperation(
            data.elementSelectionInput);

        /**
         * Get the list of element selection providers based on the input.
         */
        for (int i = 0; i < ExecutionStrategy.PRIORITIES.length; ++i) {
            List providers = ExecutionStrategy.FORWARD.getUncachedProviders(
                this, ExecutionStrategy.PRIORITIES[i], operation);
            results.addAll(providers);
        }

        /**
         * Create the jobs for each provider.
         */
        for (Iterator<IElementSelectionProvider> i = results.iterator(); i.hasNext();) {
            IElementSelectionProvider provider = i.next();

            addJob(data, provider);
        }

        /**
         * Start the provider jobs.
         */
        HashMap jobsClone; 
        synchronized (data) {
            jobsClone  = (HashMap)data.jobs.clone();
        }
        for (Iterator i = jobsClone.entrySet().iterator(); i.hasNext();) {
            Map.Entry entry = (Map.Entry) i.next();
            IElementSelectionProvider provider = (IElementSelectionProvider) entry
            	.getKey();
            ElementSelectionServiceJob job = (ElementSelectionServiceJob) entry
                .getValue();
            
            schedule(provider, job);
        }

        /**
         * Now loop, waiting for the provider jobs to complete.
         */
        monitor.beginTask(getJobName(data), 1000);
        while (true) {
            synchronized (data) {
                if (data.jobs.size() == 0) {
                    break;
                }
            }
            monitor.worked(1);
            /**
             * if the progress monitor is canceled, then cancel the running jobs.
             */
            if (monitor.isCanceled()) {
                synchronized(data) {
                    // nullify the element selection listener.
                    data.elementSelectionListener = null;
                    cancelAllJobs();
                    break;
                }
            }
        }
        monitor.done();
        jobs2Data.clear();
    }
    
    /**
     * Schedules the specified selection provider job.
     * 
     * @@param provider a selection provider
     * @@param job the <code>provider</code>'s job
     */
    protected void schedule(IElementSelectionProvider provider, ElementSelectionServiceJob job) {
    	job.schedule();
    }

    /**
     * Resolve the matching object to a modeling object. The service always
     * returns null since the client should be asking the correct provider to
     * resolve the object.
     * 
     * @@return null.
     */
    public Object resolve(IMatchingObject object) {
        return null;
    }

    /**
     * Get the name for the ElementSelectionServiceJob. Clients can override.
     * 
     * @@return the name for the job.
     */
    protected String getJobName(JobData data) {
        if((getJobName() != null && getJobName().equals(StringStatics.BLANK)) && data != null) {
            String providerName = getClass().getName().substring(
                getClass().getName().lastIndexOf('.') + 1);
            String filter = data.elementSelectionInput.getInput();
            return NLS.bind(
                CommonUIServicesMessages.ElementSelectionService_JobName,
                new String[] {providerName, filter});
        }
        return getJobName();
    }

    /**
     * Add an element selection provider to the list of jobs running the providers.
     * 
     * @@param provider an element selection provider.
     */
    private void addJob(JobData data, IElementSelectionProvider provider) {
        ElementSelectionServiceJob job = provider.getMatchingObjects(
            data.elementSelectionInput, this);
        synchronized (data) {
            data.jobs.put(provider, job);
        }
        
        synchronized(jobs2Data) {
            jobs2Data.put(job, data);
        }
    }

    /**
     * Remove an element selection provider from the list.
     * 
     * @@param provider an element selection provider.
     */
    private void removeJob(JobData data, IElementSelectionProvider provider) {
        boolean end_of_matches = false;
        Object job = null;
        synchronized (data) {
            job = data.jobs.remove(provider);
            if (data.jobs.size() == 0) {
                end_of_matches = true;
            }
        }
        
        /**
         * All the jobs have finished, send end of matches event.
         */
        if (end_of_matches) {
            fireEndOfMatchesEvent();
        }

        synchronized(jobs2Data) {
            jobs2Data.remove(job);
        }
    }

    /**
     * Send the matching object event to the listener.
     * 
     * @@param matchingObjectEvent
     *            the matching object event.
     */
    protected void fireMatchingObjectEvent(
            final IMatchingObjectEvent matchingObjectEvent) {
        final Job currentJob = jobManager.currentJob();
        if(currentJob == null)
            return;
        
        JobData data = null;
        synchronized(jobs2Data) {
            data = jobs2Data.get(currentJob);
        }
        
        if(data == null)
            return;
        
        final JobData finalData = data;
        PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {

            public void run() {
                if (finalData.elementSelectionListener != null) {
                    finalData.elementSelectionListener
                        .matchingObjectEvent(matchingObjectEvent);
                }
            }
        });
    }

    /**
     * Fire an end of matches event since there are no more matches.
     */
    protected void fireEndOfMatchesEvent() {
        IMatchingObject matchingObject = new AbstractMatchingObject(null, null,
            null, this);
        MatchingObjectEvent matchingObjectEvent = new MatchingObjectEvent(
            MatchingObjectEventType.END_OF_MATCHES, matchingObject);
        fireMatchingObjectEvent(matchingObjectEvent);
    }

    /**
     * {@@inheritDoc}
     */
    public void matchingObjectEvent(IMatchingObjectEvent matchingObjectEvent) {
        JobData data = getJobData();
        if(data == null)
            return;
        if (matchingObjectEvent.getEventType() == MatchingObjectEventType.END_OF_MATCHES) {
            removeJob(data, matchingObjectEvent.getMatchingObject().getProvider());
        } else {
            fireMatchingObjectEvent(matchingObjectEvent);
        }
    }
    
    /**
     * Cancel the jobs running for the element selection service.
     */
    protected void cancelAllJobs() {
        JobData data = getJobData();
        HashMap jobsClone;
        synchronized (data) {
            jobsClone = (HashMap) data.jobs.clone();
        }
        for (Iterator i = jobsClone.entrySet().iterator(); i.hasNext();) {
            Map.Entry entry = (Map.Entry) i.next();
            IElementSelectionProvider provider = (IElementSelectionProvider) entry.getKey(); 
            ElementSelectionServiceJob job = (ElementSelectionServiceJob) entry
                .getValue();
            job.cancel();
            removeJob(data, provider);
        }
    }
    
    protected Service.ProviderDescriptor newProviderDescriptor(
            IConfigurationElement element) {
            return new ProviderDescriptor(element);
    }
    
    /**
     * Configures my providers from the <tt>elementSelectionProviders</tt>
     * extension point.
     */
    protected void configureProviders() {
    	configureProviders(
    		CommonUIServicesPlugin.getPluginId(),
        	"elementSelectionProviders"); //$NON-NLS-1$
    }
    
    public void cancelJob(ElementSelectionServiceJob job) {
        JobData data = null;
        synchronized(jobs2Data) {
            data = jobs2Data.get(job);
        }
        
        if (data != null) {
            synchronized(data) {
                data.elementSelectionListener = null;
            }
        }
        
        job.cancel();
    }
}
@


1.6
log
@[236665] gmf-head ahunter 080612 Deadlock in ElementSelectionService
@
text
@d419 4
a422 2
        synchronized(data) {
            data.elementSelectionListener = null;
d424 1
@


1.6.2.1
log
@[240979] gmf-R2_1_maintenance wdiu NPE in ElementSelectionService results in job never being able to be cancelled
@
text
@d419 2
a420 4
        if (data != null) {
            synchronized(data) {
                data.elementSelectionListener = null;
            }
a421 1
        
@


1.5
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
a20 1
import org.eclipse.core.runtime.Platform;
d69 2
a70 1
        public HashMap jobs = new HashMap();
d73 2
a74 1
    private Map jobs2Data = new HashMap();
d86 1
a86 1
            data = (JobData)jobs2Data.get(currentJob);
d164 1
a164 1
    public static final IJobManager jobManager = Platform.getJobManager();
d174 1
a174 1
        List results = new ArrayList();
d190 2
a191 3
        for (Iterator i = results.iterator(); i.hasNext();) {
            IElementSelectionProvider provider = (IElementSelectionProvider) i
                .next();
d237 1
d336 1
a336 1
            data = (JobData)jobs2Data.get(currentJob);
d346 3
a348 5
                synchronized(finalData) { 
                    if(finalData.elementSelectionListener != null) {
                        finalData.elementSelectionListener
                            .matchingObjectEvent(matchingObjectEvent);
                    }
d416 1
a416 1
            data = (JobData)jobs2Data.get(job);
@


1.4
log
@Bugzilla#137506 gmf_head cmahoney 050605 Select Element Service should filter based on capabilities
@
text
@d21 2
d27 1
d65 2
a66 1
    private IElementSelectionInput elementSelectionInput;
d68 1
a68 1
    private IElementSelectionListener elementSelectionListener;
d70 20
a89 1
    private HashMap jobs = new HashMap();
d97 1
a97 2
        instance.configureProviders(CommonUIServicesPlugin.getPluginId(),
            "elementSelectionProviders"); //$NON-NLS-1$
d133 26
a158 4
        elementSelectionInput = input;
        elementSelectionListener = listener;
        ElementSelectionServiceJob job = new ElementSelectionServiceJob(
            getJobName(), this);
a159 1
        job.schedule();
d162 2
d169 4
d175 1
a175 1
            elementSelectionInput);
d193 1
a193 1
            addJob(provider);
d200 2
a201 2
        synchronized (jobs) {
            jobsClone  = (HashMap)jobs.clone();
d205 2
d209 2
a210 1
            job.schedule();
d216 1
a216 1
        monitor.beginTask(getJobName(), 1000);
d218 2
a219 2
            synchronized (jobs) {
                if (jobs.size() == 0) {
d228 6
a233 2
                cancelAllJobs();
                break;
d238 10
d265 10
a274 7
    protected String getJobName() {
        String providerName = getClass().getName().substring(
            getClass().getName().lastIndexOf('.') + 1);
        String filter = elementSelectionInput.getInput();
        return NLS.bind(
            CommonUIServicesMessages.ElementSelectionService_JobName,
            new String[] {providerName, filter});
d282 1
a282 1
    private void addJob(IElementSelectionProvider provider) {
d284 7
a290 3
            elementSelectionInput, this);
        synchronized (jobs) {
            jobs.put(provider, job);
d299 1
a299 1
    private void removeJob(IElementSelectionProvider provider) {
d301 4
a304 3
        synchronized (jobs) {
            jobs.remove(provider);
            if (jobs.size() == 0) {
d308 1
d315 4
d329 13
d345 6
a350 2
                elementSelectionListener
                    .matchingObjectEvent(matchingObjectEvent);
d370 3
d374 1
a374 1
            removeJob(matchingObjectEvent.getMatchingObject().getProvider());
d379 1
a379 1

d384 1
d386 2
a387 2
        synchronized (jobs) {
            jobsClone = (HashMap) jobs.clone();
d395 1
a395 1
            removeJob(provider);
d403 22
@


1.4.2.1
log
@[148427] gmf_R1_0_maintenance cdamus 060712 Need ability to extend ElementSelectionService for transaction support
@
text
@d74 2
a75 1
        instance.configureProviders();
d113 3
a115 1
        ElementSelectionServiceJob job = createSelectionJob();
a118 13
    
    /**
     * Creates the selection service job that manages the individual provider
     * search jobs.  This method should configure the new job with the appropriate
     * priority, scheduling rules, etc. but should not schedule it.
     * 
     * @@return a new selection service job
     */
    protected ElementSelectionServiceJob createSelectionJob() {
        ElementSelectionServiceJob job = new ElementSelectionServiceJob(getJobName(), this);
        job.setPriority(Job.SHORT);
        return job;
    }
a155 2
            IElementSelectionProvider provider = (IElementSelectionProvider) entry
            	.getKey();
d158 1
a158 2
            
            schedule(provider, job);
a181 10
    
    /**
     * Schedules the specified selection provider job.
     * 
     * @@param provider a selection provider
     * @@param job the <code>provider</code>'s job
     */
    protected void schedule(IElementSelectionProvider provider, ElementSelectionServiceJob job) {
    	job.schedule();
    }
a302 10
    
    /**
     * Configures my providers from the <tt>elementSelectionProviders</tt>
     * extension point.
     */
    protected void configureProviders() {
    	configureProviders(
    		CommonUIServicesPlugin.getPluginId(),
        	"elementSelectionProviders"); //$NON-NLS-1$
    }
@


1.4.2.2
log
@[158368] gmf_R1_0_maintenance mgoyal 060922 ElementSelectionService isn't reentrant and won't search at times.
@
text
@a20 2
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.jobs.IJobManager;
a24 1
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
d62 1
a62 2
    protected class JobData {
        public IElementSelectionInput elementSelectionInput;
d64 1
a64 1
        public IElementSelectionListener elementSelectionListener;
d66 1
a66 20
        public HashMap jobs = new HashMap();
    }
    
    private Map jobs2Data = new HashMap();
    
    public JobData getJobData() {
        Job currentJob = jobManager.currentJob();
        assert currentJob != null;
        
        if(currentJob == null) {
            return null;
        }
        
        JobData data = null;
        synchronized(jobs2Data) {
            data = (JobData)jobs2Data.get(currentJob);
        }
        
        return data;
    }
d110 2
a112 7
        JobData data = new JobData();
        data.elementSelectionInput = input;
        data.elementSelectionListener = listener;
        job.setName(getJobName(data));
        synchronized(jobs2Data) {
            jobs2Data.put(job, data);
        }
a116 5
    
    protected String getJobName() {
        return StringStatics.BLANK;
    }
    
a128 2
    
    public static final IJobManager jobManager = Platform.getJobManager();
a133 4
        JobData data = getJobData();
        if(data == null)
            return;
        
d136 1
a136 1
            data.elementSelectionInput);
d154 1
a154 1
            addJob(data, provider);
d161 2
a162 2
        synchronized (data) {
            jobsClone  = (HashMap)data.jobs.clone();
d177 1
a177 1
        monitor.beginTask(getJobName(data), 1000);
d179 2
a180 2
            synchronized (data) {
                if (data.jobs.size() == 0) {
d189 2
a190 6
                synchronized(data) {
                    // nullify the element selection listener.
                    data.elementSelectionListener = null;
                    cancelAllJobs();
                    break;
                }
d222 7
a228 10
    protected String getJobName(JobData data) {
        if((getJobName() != null && getJobName().equals(StringStatics.BLANK)) && data != null) {
            String providerName = getClass().getName().substring(
                getClass().getName().lastIndexOf('.') + 1);
            String filter = data.elementSelectionInput.getInput();
            return NLS.bind(
                CommonUIServicesMessages.ElementSelectionService_JobName,
                new String[] {providerName, filter});
        }
        return getJobName();
d236 1
a236 1
    private void addJob(JobData data, IElementSelectionProvider provider) {
d238 3
a240 7
            data.elementSelectionInput, this);
        synchronized (data) {
            data.jobs.put(provider, job);
        }
        
        synchronized(jobs2Data) {
            jobs2Data.put(job, data);
d249 1
a249 1
    private void removeJob(JobData data, IElementSelectionProvider provider) {
d251 3
a253 4
        Object job = null;
        synchronized (data) {
            job = data.jobs.remove(provider);
            if (data.jobs.size() == 0) {
a256 1
        
a262 4

        synchronized(jobs2Data) {
            jobs2Data.remove(job);
        }
a272 13
        final Job currentJob = jobManager.currentJob();
        if(currentJob == null)
            return;
        
        JobData data = null;
        synchronized(jobs2Data) {
            data = (JobData)jobs2Data.get(currentJob);
        }
        
        if(data == null)
            return;
        
        final JobData finalData = data;
d276 2
a277 6
                synchronized(finalData) { 
                    if(finalData.elementSelectionListener != null) {
                        finalData.elementSelectionListener
                            .matchingObjectEvent(matchingObjectEvent);
                    }
                }
a296 3
        JobData data = getJobData();
        if(data == null)
            return;
d298 1
a298 1
            removeJob(data, matchingObjectEvent.getMatchingObject().getProvider());
d303 1
a303 1
    
a307 1
        JobData data = getJobData();
d309 2
a310 2
        synchronized (data) {
            jobsClone = (HashMap) data.jobs.clone();
d318 1
a318 1
            removeJob(data, provider);
a335 12
    
    public void cancelJob(ElementSelectionServiceJob job) {
        JobData data = null;
        synchronized(jobs2Data) {
            data = (JobData)jobs2Data.get(job);
        }
        
        synchronized(data) {
            data.elementSelectionListener = null;
        }
        job.cancel();
    }
@


1.3
log
@[134197] gmf_head ahunter 060330 Element Selection Service should get results from multiple provider asynchronously
@
text
@d19 1
d29 1
d42 20
d298 5
@


1.2
log
@Bugzilla 110635 gmf_head keithc 051004 Delay configuration of services
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d13 3
d17 1
d19 2
d22 1
d25 5
d34 1
a34 2
 * @@author Anthony Hunter <a href="mailto:anthonyh@@ca.ibm.com">
 *         anthonyh@@ca.ibm.com </a>
d37 2
a38 2
	extends Service
	implements IElementSelectionProvider {
d40 1
a40 39
	/**
	 * The singleton instance of the type selection service.
	 */
	private final static ElementSelectionService instance = new ElementSelectionService();

	static {
		instance.configureProviders(CommonUIServicesPlugin.getPluginId(), "elementSelectionProviders"); //$NON-NLS-1$
	}

	/**
	 * Constructs a new type selection service.
	 */
	protected ElementSelectionService() {
		super(true);
	}

	/**
	 * Retrieves the singleton instance of the type selection service.
	 * 
	 * @@return The type selection service singleton.
	 */
	public static ElementSelectionService getInstance() {
		return instance;
	}

	/**
	 * @@inheritDoc
	 */
	public List getMatchingObjects(IElementSelectionInput input) {
		return execute(ExecutionStrategy.FORWARD,
			new GetMatchingObjectsOperation(input));
	}

	/**
	 * @@inheritDoc
	 */
	public Object resolve(IMatchingObject object) {
		return null;
	}
d42 234
@


1.1
log
@gmf_head ahunter 050923 Element Selection Service Update
@
text
@d17 1
d34 4
@

