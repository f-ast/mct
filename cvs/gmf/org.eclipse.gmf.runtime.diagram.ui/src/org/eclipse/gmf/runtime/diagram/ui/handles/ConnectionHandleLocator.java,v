head	1.2;
access;
symbols
	v20081023-2107:1.2
	v20081022-1925:1.2
	v20081022-1005:1.2
	v20081020-0700:1.2
	v20080917-1925:1.2
	v20080916-2008:1.2
	v20080911-1728:1.2
	v20080911-1506:1.2
	v20080910-1520:1.2
	v20080910-1510:1.2
	v20080903-1520:1.2
	v20080903-1510:1.2
	v20080813-1510:1.2
	v20080811-1546:1.2
	v20080731-1520:1.2
	v20080725-1738:1.2
	v20080723-2246:1.2
	v20080723-2232:1.2
	v20080723-1700:1.2
	v20080722-1827:1.2
	v20080718-1700:1.2
	v20080718-1731:1.2
	v20080716-1600:1.2
	v20080716-1642:1.2
	R2_1_maintenance:1.2.0.2
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080610-1132:1.2
	v20080603-1553:1.2
	v20080527-1255:1.2
	v20080527-1151:1.1
	v20080516-1748:1.2
	v20080516-1143:1.2
	v20080512-1200:1.2
	v20080503-1740:1.2
	v20080501-2127:1.1
	v20080501-1739:1.2
	m20080429-1543:1.1
	v20080425-1959:1.2
	v20080417-1610:1.2
	v20080407-2250:1.2
	v20080407-0930:1.2
	v20080404-1111:1.2
	v20080328-1605:1.2
	v20080322-0000:1.2
	v20080222-1200:1.2
	v20080201-2010:1.2
	v20080201-0201:1.1
	v20080118-1129:1.1
	v20080114-2222:1.1
	v20080114-1111:1.2
	v20080107-1111:1.2
	v20071222-1111:1.2
	v20071214-1111:1.2
	v20071130-1111:1.2
	v20071124-0000:1.1
	v20071112-0000:1.2
	v20071108-0000:1.1
	v20071003-0000:1.1
	v20070915-0000:1.1
	v20070903-0000:1.1
	v20070809-0000:1.1
	R2_0_maintenance:1.1.0.6
	R2_0:1.1
	R4_20:1.1
	v20070621-0000:1.1
	RC3_20:1.1
	v20070614-1400:1.1
	v20070608-1300:1.1
	v20070605-1400:1.1
	v20070601-1400:1.1
	v20070525-1500:1.1
	v20070518-1300:1.1
	bugzilla111892_group_support:1.1.0.4
	Root_bugzilla111892_group_support:1.1
	v20070504-1000:1.1
	v20070420-1000:1.1
	v20070413-1300:1.1
	v20070330-1300:1.1
	v20060330-1300:1.1
	v20070322-1100:1.1
	v20060316-0600:1.1
	v20070221-1500:1.1
	v20070208-1800:1.1
	v20070202-0200:1.1
	v20070119-1200:1.1
	v20070111-0800:1.1
	v20070105-1200:1.1
	v20070103-0300:1.1
	M4_20:1.1
	v20061218-1500:1.1
	v20061218-1200:1.1
	v20061214-0000:1.1
	M3_20:1.1
	v20061117-0800:1.1
	v20061027-1200:1.1
	v20061013-1330:1.1
	v20061012-1100:1.1
	v20060925-1700:1.1
	v20060919-0800:1.1
	v20060907-1100:1.1
	M1_20:1.1
	v20060831-1500:1.1
	v20060824-1600:1.1
	v20060817-1500:1.1
	v20060810-1700:1.1
	v20060803-1200:1.1
	v20060728-0500:1.1
	v20060721-1130:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060616-1400:1.1
	v20060616-1200:1.1
	v20060609-1400:1.1
	v20060531-1730:1.1
	v20060530-1930:1.1
	v20060526-1200:1.1
	v20060519-0800:1.1
	v20060512-1000:1.1
	I20060512-1000:1.1
	I20060505-1400:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1
	I20060216-1945:1.1
	I20060210-1715:1.1
	I20060209-1815:1.1
	I20060203-0830:1.1
	I20060202-1415:1.1
	I20060129-1145:1.1
	I20060127-0900:1.1
	I20060120-1530:1.1
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1
	I20060105-1630:1.1
	I20051230-1230:1.1
	I20051223-1100:1.1
	I20051217-0925:1.1
	I20051208-2000:1.1
	I20051201-1800:1.1
	I20051124-2000:1.1
	M3_10:1.1
	I20051118-1245:1.1
	I20051111-1800:1.1
	I20051106-0900:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.2
date	2007.11.08.20.36.41;	author crevells;	state Exp;
branches;
next	1.1;
commitid	d5b473373584567;

1.1
date	2005.11.02.23.30.18;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.2
log
@[159187] gmf_head crevells 071108 [ModelingAssistant] Action Toolbar pops up outside of diagram area
@
text
@/******************************************************************************
 * Copyright (c) 2003, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.handles;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.Locator;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.Viewport;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.handles.HandleBounds;

/**
 * This locator is used to locate all the handles around the shape the closest
 * distance to the mouse location. It spaces the handles a certain distance
 * apart. Call setEastWestSouth(true) to indicate that the connection handle can
 * only be located on the east, west, or south side of the reference figure.
 * 
 * @@author cmahoney
 */
public class ConnectionHandleLocator
	implements Locator {

	/** number of pixels between connection handles */
	private static int HANDLE_SPACING = 20;

	/** the MARGIN to leave by the edge of the parent figure */
	private static int MARGIN = 2;
	
	/**
     * the margin outside the shape in which the handles will appear to
     * determine if the handles will be outside the viewport
     */
    private static Dimension HANDLE_MARGIN = new Dimension(25, 25);

	/** list of connection handles for the shape */
	private List<ConnectionHandle> handles = new ArrayList<ConnectionHandle>();

	/** a point in the shape used when locating the handles */
	private Point cursorPosition = null;

	/** the parent figure */
	private IFigure reference = null;

	/** the side on which the handles will appear, value from PositionConstants */
	private int side = PositionConstants.WEST;

	/** the point on the border where the handles should appear */
	private Point borderPoint = new Point(0, 0);

	/**
	 * flag to indicate if the connection handle should only be on the east,
	 * west, or south side
	 */
	private boolean bEastWestSouth = false;

	/**
	 * Constructor for ConnectionHandleLocator.
	 * 
	 * @@param reference
	 *            the figure
	 * @@param cursorPosition
	 *            the handles will be located on the border of the shape as
	 *            close to this position as possible
	 */
	public ConnectionHandleLocator(IFigure reference, Point cursorPosition) {
		this.reference = reference;
		this.cursorPosition = cursorPosition;
	}

	/**
	 * Adds a connection handle to the list of handles.
	 * 
	 * @@param handle
	 *            the <code>ConnectionHandle</code> to add
	 */
	public void addHandle(ConnectionHandle handle) {
		handles.add(handle);
	}

    /**
     * Return the client area of the viewport. If a viewport is not found, a
     * default rectangle is returned.
     * 
     * @@return the client area of the viewport
     */
    private Rectangle getViewportArea() {
        IFigure fig = getReference();
        while (fig != null) {
            if (fig instanceof Viewport) {
                return fig.getClientArea();
            }
            fig = fig.getParent();
        }
        return new Rectangle(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE);
    }

    /**
	 * Resets the border point and side variables where the connection handles
	 * will appear, based on the cursor location.
	 */
	private void resetBorderPointAndSide() {
        Rectangle bounds = getReferenceFigureBounds();

        // Get the point on the edge of the reference figure nearest to the
        // cursor position.
        int westDiff = cursorPosition.x - bounds.x;
        int eastDiff = bounds.getRight().x - cursorPosition.x;
        int southDiff = bounds.getBottom().y - cursorPosition.y;
        int northDiff = isEastWestSouth() ? Integer.MAX_VALUE
            : cursorPosition.y - bounds.y;

        // avoid having the handles appear outside the viewport
        Rectangle viewportRect = getViewportArea();
        Rectangle absBounds = bounds.getCopy();
        getReference().translateToAbsolute(absBounds);
        absBounds.translate(viewportRect.getLocation());
        
        Dimension handleMargin = getHandleMargin();
        if (absBounds.right() + handleMargin.width > viewportRect.right()) {
            // don't use east side
            eastDiff = Integer.MAX_VALUE;
        } else if (absBounds.x - handleMargin.width < viewportRect.x) {
            // don't use west side
            westDiff = Integer.MAX_VALUE;
        }
        if (absBounds.bottom() + handleMargin.height > viewportRect.bottom()) {
            // don't use south side
            southDiff = Integer.MAX_VALUE;
        } else if (absBounds.y - handleMargin.height < viewportRect.y) {
            // don't use north side
            northDiff = Integer.MAX_VALUE;
        }

        double minLR = Math.min(eastDiff, westDiff);
        double minUD = Math.min(southDiff, northDiff);
        // which directions is closest North/South or East/West?
        boolean bUp = (minUD < minLR);

        if (bUp) {
            if (northDiff < southDiff) {
                // re-evaluate if the north is closer than the east since the
                // handles will be placed in the north-west corner because of
                // the action bar.
                if (eastDiff < westDiff
                    && eastDiff < cursorPosition.getDistance(bounds
                        .getTopLeft())) {
                    borderPoint.setLocation(bounds.x + bounds.width,
                        cursorPosition.y);
                    side = PositionConstants.EAST;
                } else {
                    borderPoint.setLocation(bounds.x, bounds.y);
                    side = PositionConstants.NORTH;
                }
            } else {
                borderPoint.setLocation(cursorPosition.x, bounds.y
                    + bounds.height);
                side = PositionConstants.SOUTH;
            }
        } else {
            if (westDiff < eastDiff) {
                borderPoint.setLocation(bounds.x, cursorPosition.y);
                side = PositionConstants.WEST;
            } else {
                //
                borderPoint.setLocation(bounds.x + bounds.width,
                    cursorPosition.y);
                side = PositionConstants.EAST;
            }
        }
    }

	/**
	 * Gets the side (West, South, or East) on which the handles will appear,
	 * using the cursor position passed in to the constructor.
	 * 
	 * @@return the side, a value in PositionContstants
	 */
	public int getBorderSide() {
		resetBorderPointAndSide();
		return side;
	}

	/**
	 * Locates the figure on the appropriate edge of the parent depending on
	 * which side is closest to the reference point. Then adjusts the figure
	 * depending on the number of handles that this locator has so that the
	 * handles are spaced out from the center along the edge of the shape.
	 * 
	 * @@see org.eclipse.draw2d.Locator#relocate(org.eclipse.draw2d.IFigure)
	 */
	public void relocate(IFigure target) {
		Rectangle bounds = getReferenceFigureBounds();
		resetBorderPointAndSide();

		Point borderPointTranslated = borderPoint.getCopy();
		reference.translateToAbsolute(bounds);
		target.translateToRelative(bounds);
		reference.translateToAbsolute(borderPointTranslated);
		target.translateToRelative(borderPointTranslated);

		int width = target.getBounds().width;
		int halfWidth = width / 2;

		int height = target.getBounds().height;
		int halfHeight = height / 2;

		// adjust border point if the handles will extend past the bounds of the
		// shape
		if (side == PositionConstants.WEST || side == PositionConstants.EAST) {
			int halfTotalHeight = (height * handles.size() + HANDLE_SPACING
				* (handles.size() - 1)) / 2;
			if (borderPointTranslated.y - halfTotalHeight < bounds.getTop().y) {
				borderPointTranslated.y = bounds.getTop().y + halfTotalHeight;
			} else if (borderPointTranslated.y + halfTotalHeight > bounds
				.getBottom().y) {
				borderPointTranslated.y = bounds.getBottom().y
					- halfTotalHeight;
			}
		} else {
			int halfTotalWidth = (width * handles.size() + HANDLE_SPACING
				* (handles.size() - 1)) / 2;
			if (borderPointTranslated.x - halfTotalWidth < bounds.getLeft().x) {
				borderPointTranslated.x = bounds.getLeft().x + halfTotalWidth;
			} else if (borderPointTranslated.x + halfTotalWidth > bounds
				.getRight().x) {
				borderPointTranslated.x = bounds.getRight().x - halfTotalWidth;
			}
		}

		// set location based on side
		if (side == PositionConstants.WEST) {
			target.setLocation(borderPointTranslated
				.getTranslated(new Dimension(-(width + MARGIN), -halfHeight)));
		} else if (side == PositionConstants.EAST) {
			target.setLocation(borderPointTranslated
				.getTranslated(new Dimension(MARGIN, -halfHeight)));
		} else if (side == PositionConstants.SOUTH) {
			target.setLocation(borderPointTranslated
				.getTranslated(new Dimension(-halfWidth, MARGIN)));
		} else if (side == PositionConstants.NORTH) {
			target.setLocation(borderPointTranslated
				.getTranslated(new Dimension(MARGIN, -height - MARGIN)));
		}

		// space out handles
		int index = handles.indexOf(target);
		double centerOffset = index - (handles.size() / 2.0) + 0.5;

		if (side == PositionConstants.WEST || side == PositionConstants.EAST) {
			target.translate(0, (int) (centerOffset * HANDLE_SPACING));
		} else {
			target.translate((int) (centerOffset * HANDLE_SPACING), 0);
		}

	}

	/**
	 * Gets the bounding rectangle of the reference figure.
	 * 
	 * @@return the bounds
	 */
	private Rectangle getReferenceFigureBounds() {
		Rectangle bounds = reference instanceof HandleBounds ? ((HandleBounds) reference)
			.getHandleBounds().getCopy()
			: reference.getBounds().getCopy();
		return bounds;
	}

	/**
	 * Gets the reference figure.
	 * 
	 * @@return Returns the reference.
	 */
	protected IFigure getReference() {
		return reference;
	}

	/**
	 * Gets the cursor position.
	 * 
	 * @@return Returns the cursorPosition.
	 */
	protected Point getCursorPosition() {
		return cursorPosition;
	}

	/**
	 * Can the connection handle can only be located on the east, west, or south
	 * side of the reference figure.
	 * 
	 * @@return Returns true if the connection handle can only be located on the
	 *         east, west, or south side of the reference figure; false
	 *         otherwise.
	 */
	public boolean isEastWestSouth() {
		return bEastWestSouth;
	}

	/**
	 * Set to true if the connection handle can only be located on the east,
	 * west, or south side of the reference figure.
	 * 
	 * @@param eastWestSouth
	 *            The bEastWestSouth to set.
	 */
	public void setEastWestSouth(boolean eastWestSouth) {
		bEastWestSouth = eastWestSouth;
	}
	
	/**
     * Returns the margin outside the shape in which the handles will appear to
     * determine if the handles will be outside the viewport.
     * 
     * @@return the margin
     */
    protected Dimension getHandleMargin() {
        return HANDLE_MARGIN;
    }
}
@


1.1
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2005 IBM Corporation and others.
d20 1
d42 6
d50 1
a50 1
	private List handles = new ArrayList();
d94 16
a109 6
	/**
	 * Sets the point on the West, East, North or South edge of the reference
	 * figure nearest to the cursor position passed in to the constructor. Sets
	 * the side variable for which side the handles will be on.
	 */
	private void resetBorderPointAndSideAllDirections() {
d111 1
a111 78
		Rectangle bounds = getReferenceFigureBounds();
		int westDiff = cursorPosition.x - bounds.getLeft().x;
		int eastDiff = bounds.getRight().x - cursorPosition.x;
		int southDiff = bounds.getBottom().y - cursorPosition.y;
		int northDiff = cursorPosition.y - bounds.getTop().y;

		double minLR = Math.min(eastDiff, westDiff);
		double minUD = Math.min(southDiff, northDiff);
		// which directions is closest North/South or East/West?
		boolean bUp = (minUD < minLR);

		if (bUp) {
			if (northDiff < southDiff) {
				// re-evaluate if the north is closer than the east since the
				// handles will be placed in the north-west corner because of
				// the action bar.
				if (eastDiff < westDiff
					&& eastDiff < cursorPosition.getDistance(bounds
						.getTopLeft())) {
					borderPoint.setLocation(bounds.x + bounds.width,
						cursorPosition.y);
					side = PositionConstants.EAST;
				} else {
					borderPoint.setLocation(bounds.x, bounds.y);
					side = PositionConstants.NORTH;
				}
			} else {
				borderPoint.setLocation(cursorPosition.x, bounds.y
					+ bounds.height);
				side = PositionConstants.SOUTH;
			}
		} else {
			if (westDiff < eastDiff) {
				borderPoint.setLocation(bounds.x, cursorPosition.y);
				side = PositionConstants.WEST;
			} else {
				//
				borderPoint.setLocation(bounds.x + bounds.width,
					cursorPosition.y);
				side = PositionConstants.EAST;
			}
		}
	}

	/**
	 * Sets the point on the West, East, South edge of the reference figure
	 * nearest to the cursor position passed in to the constructor. Sets the
	 * side variable for which side the handles will be on.
	 */
	private void resetBorderPointAndSideEastWestSouth() {
		Rectangle bounds = getReferenceFigureBounds();

		// Get the point on the West, East, or South edge of the reference
		// figure
		// nearest to the cursor position.
		int westDiff = cursorPosition.x - bounds.x;
		int eastDiff = bounds.x + bounds.width - cursorPosition.x;
		int southDiff = bounds.y + bounds.height - cursorPosition.y;

		int min = Math.min(westDiff, eastDiff);
		if (westDiff > 30 && eastDiff > 30) { // favour East and West
			min = Math.min(min, southDiff);
		}

		if (min == westDiff) {
			borderPoint.setLocation(bounds.x, cursorPosition.y);
			side = PositionConstants.WEST;
		} else if (min == eastDiff) {
			borderPoint.setLocation(bounds.x + bounds.width, cursorPosition.y);
			side = PositionConstants.EAST;
		} else {
			borderPoint.setLocation(cursorPosition.x, bounds.y + bounds.height);
			side = PositionConstants.SOUTH;
		}

	}

	/**
d116 69
a184 5
		if (isEastWestSouth())
			resetBorderPointAndSideEastWestSouth();
		else
			resetBorderPointAndSideAllDirections();
	}
d323 10
@

