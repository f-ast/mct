head	1.8;
access;
symbols
	v20081023-2107:1.7.2.1
	v20081022-1925:1.8
	v20081022-1005:1.7.2.1
	v20081020-0700:1.8
	v20080917-1925:1.8
	v20080916-2008:1.7.2.1
	v20080911-1728:1.8
	v20080911-1506:1.7.2.1
	v20080910-1520:1.8
	v20080910-1510:1.7.2.1
	v20080903-1520:1.8
	v20080903-1510:1.7.2.1
	v20080813-1510:1.7.2.1
	v20080811-1546:1.8
	v20080731-1520:1.8
	v20080725-1738:1.7.2.1
	v20080723-2246:1.8
	v20080723-2232:1.7.2.1
	v20080723-1700:1.7.2.1
	v20080722-1827:1.7
	v20080718-1700:1.7
	v20080718-1731:1.7
	v20080716-1600:1.7
	v20080716-1642:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080610-1132:1.7
	v20080603-1553:1.7
	v20080527-1255:1.7
	v20080527-1151:1.5
	v20080516-1748:1.7
	v20080516-1143:1.7
	v20080512-1200:1.7
	v20080503-1740:1.7
	v20080501-2127:1.5
	v20080501-1739:1.7
	m20080429-1543:1.5
	v20080425-1959:1.7
	v20080417-1610:1.6
	v20080407-2250:1.6
	v20080407-0930:1.6
	v20080404-1111:1.6
	v20080328-1605:1.6
	v20080322-0000:1.6
	v20080222-1200:1.6
	v20080201-2010:1.6
	v20080201-0201:1.5
	v20080118-1129:1.5
	v20080114-2222:1.5
	v20080114-1111:1.6
	v20080107-1111:1.6
	v20071222-1111:1.6
	v20071214-1111:1.6
	v20071130-1111:1.6
	v20071124-0000:1.5
	v20071112-0000:1.5
	v20071108-0000:1.5
	v20071003-0000:1.5
	v20070915-0000:1.5
	v20070903-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.4
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070614-1400:1.5
	v20070608-1300:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070525-1500:1.5
	v20070518-1300:1.5
	bugzilla111892_group_support:1.5.0.2
	Root_bugzilla111892_group_support:1.5
	v20070504-1000:1.5
	v20070420-1000:1.5
	v20070413-1300:1.5
	v20070330-1300:1.5
	v20060330-1300:1.5
	v20070322-1100:1.5
	v20060316-0600:1.5
	v20070221-1500:1.5
	v20070208-1800:1.5
	v20070202-0200:1.2.2.4
	v20070119-1200:1.2.2.4
	v20070111-0800:1.2.2.4
	v20070105-1200:1.2.2.4
	v20070103-0300:1.5
	M4_20:1.5
	v20061218-1500:1.2.2.4
	v20061218-1200:1.5
	v20061214-0000:1.5
	M3_20:1.4
	v20061117-0800:1.4
	v20061027-1200:1.2.2.3
	v20061013-1330:1.4
	v20061012-1100:1.2.2.3
	v20060925-1700:1.2.2.2
	v20060919-0800:1.2.2.2
	v20060907-1100:1.2.2.1
	M1_20:1.2
	v20060831-1500:1.2.2.1
	v20060824-1600:1.2.2.1
	v20060817-1500:1.2.2.1
	v20060810-1700:1.2.2.1
	v20060803-1200:1.2.2.1
	v20060728-0500:1.2
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1400:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060530-1930:1.2
	v20060526-1200:1.2
	v20060519-0800:1.2
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060202-1415:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1
	I20060105-1630:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2008.07.23.20.51.02;	author aboyko;	state Exp;
branches;
next	1.7;
commitid	63b7488799b64567;

1.7
date	2008.04.21.20.13.20;	author crevells;	state Exp;
branches
	1.7.2.1;
next	1.6;
commitid	495b480cf55f4567;

1.6
date	2007.11.21.17.57.28;	author crevells;	state Exp;
branches;
next	1.5;
commitid	4a12474471874567;

1.5
date	2006.11.23.21.11.33;	author mmostafa;	state Exp;
branches;
next	1.4;
commitid	291545660e854567;

1.4
date	2006.10.11.20.46.28;	author mmostafa;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.03.15.02.04;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.17.18.12.20;	author sshaw;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.01.04.19.15.37;	author cmahoney;	state Exp;
branches;
next	;

1.2.2.1
date	2006.08.02.17.08.01;	author ahunter;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2006.09.13.16.43.40;	author ahunter;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2006.10.11.20.29.48;	author mmostafa;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2006.11.23.21.10.10;	author mmostafa;	state Exp;
branches;
next	;
commitid	1e3d45660e324567;

1.7.2.1
date	2008.07.23.20.37.10;	author aboyko;	state Exp;
branches;
next	;
commitid	4918488796764567;


desc
@@


1.8
log
@[241879] gmf_head aboyko 080723 [Layout] BorderItemContainerFigure can indefinitely revalidate itself.
@
text
@/******************************************************************************
 * Copyright (c) 2003, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.internal.figures;

import java.util.Iterator;
import java.util.ListIterator;

import org.eclipse.draw2d.Figure;
import org.eclipse.draw2d.FigureListener;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.ScalableFreeformLayeredPane;
import org.eclipse.draw2d.TreeSearch;
import org.eclipse.draw2d.Viewport;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.diagram.ui.figures.BorderItemsAwareFreeFormLayer;
import org.eclipse.gmf.runtime.diagram.ui.figures.BorderItemsUtil;
import org.eclipse.gmf.runtime.diagram.ui.figures.BorderedNodeFigure;
import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;

/**
 * BorderItemContainerFigures contain the main pane on which border items are
 * places. BorderItems are children of BorderItemContainerFigures and therefore
 * move when the parent moves. BorderItems within the BorderItemContainerFigure
 * may be painted outside the main figure and therefore the
 * BorderItemContainerFigure controls clipping region. The work of positioning
 * border items is handled by the locator. ( This implementation of border items
 * was re-written from the original created by Tauseef ). The orginal
 * implementation kept border items in a separate list ( not as children ) and
 * painted them after, requiring explicit moving of children.
 * 
 * @@author tisrar, jbruck, cmahoney, mmostafa
 */
public class BorderItemContainerFigure
	extends NodeFigure {
    
    // rectangle indicating the extended bounds of the figure
    // extended bounds include the border items in the calculations 
    private Rectangle extendedBounds = new Rectangle();
    
    private BorderItemContainerHelper helper = new BorderItemContainerHelper();
    
	/**
	 * Constructor
	 */
	public BorderItemContainerFigure() {
		super();
	}

	/**
	 * Paints this Figure's client area. The client area is typically defined as
	 * the anything inside the Figure's {@@link Border} or {@@link Insets}, and
	 * by default includes the children of this Figure. On return, this method
	 * must leave the given Graphics in its initial state.
	 * 
	 * @@param graphics
	 *            The Graphics used to paint
	 * 
	 */
	protected void paintClientArea(Graphics graphics) {
		if (getChildren().isEmpty() || !isVisible())
			return;
		Rectangle clip = getVisibleExtendedBounds();
		graphics.setClip(clip);

        if (useLocalCoordinates()) {
            graphics.translate(getBounds().x + getInsets().left, getBounds().y
                + getInsets().top);
		}
		graphics.pushState();
		paintChildren(graphics);
		graphics.popState();
		graphics.restoreState();
	}

	/**
	 * gets the handle bounds of the main figure
	 * 
	 * @@return the handle bounds of the main figure
	 * @@see org.eclipse.gef.handles.HandleBounds#getHandleBounds()
	 */
	public Rectangle getHandleBounds() {
		Rectangle handleRect = null;

		ListIterator listIterator = getChildren().listIterator();
		while (listIterator.hasNext()) {
			Object object = listIterator.next();
			if (object instanceof NodeFigure
				&& ((NodeFigure) object).isVisible()) {
				if (handleRect == null) {
					handleRect = ((NodeFigure) object).getHandleBounds()
						.getCopy();
				} else {
					handleRect.union(((NodeFigure) object).getHandleBounds()
						.getCopy());
				}
			}
		}
		return handleRect;
	}

	protected void primTranslate(int dx, int dy) {
		/*
		 * If the border item container is being moved, the children must move by the same amount too
		 * (as opposed to free form figure).
		 * We must ignore children moves in this case in the helper, since border item container shouldn't be invalidated.
		 */
		helper.ignoreChildFigureMovesHandling = true;
		super.primTranslate(dx, dy);
		helper.ignoreChildFigureMovesHandling = false;
	}

	/**
	 * We need to override this for smooth painting of border item items.
	 */
	public boolean containsPoint(int x, int y) {
		if (useLocalCoordinates()) {
            x = x - getBounds().x - getInsets().left;
            y = y - getBounds().y - getInsets().top;
        }

		for (int i = getChildren().size(); i > 0;) {
			i--;
			IFigure fig = (IFigure) getChildren().get(i);
			if (fig.containsPoint(x, y)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Returns a descendant of this Figure such that the Figure returned
	 * contains the point (x, y), and is accepted by the given TreeSearch.
	 * Returns <code>null</code> if none found.
	 * 
	 * @@param x
	 *            The X coordinate
	 * @@param y
	 *            The Y coordinate
	 * @@param search
	 *            the TreeSearch
	 * @@return The descendant Figure at (x,y)
	 */
	protected IFigure findDescendantAtExcluding(int x, int y, TreeSearch search) {
		Point pt = new Point(x, y);
		this.translateFromParent(pt);

		IFigure fig;
		for (int i = getChildren().size(); i > 0;) {
			i--;
			fig = (IFigure) getChildren().get(i);
			if (fig.isVisible()) {
				fig = fig.findFigureAt(pt.x, pt.y, search);
				if (fig != null)
					return fig;
			}
		}
		// No descendants were found
		return null;
	}

	public IFigure findFigureAt(int x, int y, TreeSearch search) {
		if (search.prune(this))
			return null;
		IFigure child = findDescendantAtExcluding(x, y, search);
		if (child != null)
			return child;
		return null;
	}

	/**
	 * Returns the deepest descendant for which {@@link #isMouseEventTarget()}
	 * returns <code>true</code> or <code>null</code> if none found. The
	 * Parameters <i>x</i> and <i>y</i> are absolute locations. Any Graphics
	 * transformations applied by this Figure to its children during
	 * {@@link #paintChildren(Graphics)} (thus causing the children to appear
	 * transformed to the user) should be applied inversely to the points <i>x</i>
	 * and <i>y</i> when called on the children.
	 * 
	 * @@param x
	 *            The X coordinate
	 * @@param y
	 *            The Y coordinate
	 * @@return The deepest descendant for which isMouseEventTarget() returns
	 *         true
	 */
	public IFigure findMouseEventTargetAt(int x, int y) {
		IFigure f = findMouseEventTargetInDescendantsAt(x, y);
		if (f != null)
			return f;
		if (isMouseEventTarget())
			return this;
		return null;
	}

	/**
	 * Searches this Figure's children for the deepest descendant for which
	 * {@@link #isMouseEventTarget()} returns <code>true</code> and returns
	 * that descendant or <code>null</code> if none found.
	 * 
	 * @@see #findMouseEventTargetAt(int, int)
	 * @@param x
	 *            The X coordinate
	 * @@param y
	 *            The Y coordiante
	 * @@return The deepest descendant for which isMouseEventTarget() returns
	 *         true
	 */
	protected IFigure findMouseEventTargetInDescendantsAt(int x, int y) {
		Point pt = new Point(x, y);
		this.translateFromParent(pt);

		IFigure fig;
		for (int i = getChildren().size(); i > 0;) {
			i--;
			fig = (IFigure) getChildren().get(i);
			if (fig.isVisible() && fig.isEnabled()) {
				if (fig.containsPoint(pt.x, pt.y)) {
					fig = fig.findMouseEventTargetAt(pt.x, pt.y);
					return fig;
				}
			}
		}
		return null;
	}

	/**
	 * @@see org.eclipse.draw2d.IFigure#intersects(Rectangle)
	 */
	public boolean intersects(Rectangle rect) {		
		Rectangle rectangle = getExtendedBounds();
		return rectangle.intersects(rect);
	}
	
    /**
     * Gets the area of the extended bounds which is visible, that is, that is
     * contained within the viewport bounds. This is needed so that when this
     * shape is within a scrollable compartment, the border items are not
     * visible when they are outside the visible area.
     * 
     * @@return the area of the extended bounds which is visible
     */
    private Rectangle getVisibleExtendedBounds() {
        Rectangle extendedRect = getExtendedBounds().getCopy();
        translateToAbsolute(extendedRect);
        Rectangle parentRect = getViewportBounds().getIntersection(
            extendedRect);
        translateToRelative(parentRect);
        return parentRect;
    }
    
    /**
     * Return the area of the parent viewport if there is one, otherwise, return
     * the client area of the parent. The viewport area is required so that
     * border items outside the viewport are not shown (i.e. when they are
     * scrolled out of view).
     * 
     * @@return returns the viewport client area in absolute coordinates
     */
    private Rectangle getViewportBounds() {
        Rectangle rect = getParent().getParent().getClientArea().getCopy();
        getParent().getParent().translateToParent(rect);
        getParent().getParent().translateToAbsolute(rect);

        IFigure port = getViewport();
        if (port != null) {
            Rectangle portRect = port.getClientArea().getCopy();
            port.translateToParent(portRect);
            port.translateToAbsolute(portRect);

            if (portRect.height != 0 && portRect.width != 0) {
                rect = portRect;
            }
        }
        return rect;
    }
    
	public IFigure getMainFigure() {
        return ((BorderedNodeFigure) getParent()).getMainFigure();
    }

	/**
	 * Helper to retrieve the viewport that this item sits on.
	 * 
	 * @@return the view port
	 */
	private IFigure getViewport() {
		//
		// Start searching for viewport to clip on from the main figure.
		//
		IFigure fig = getMainFigure();
		while (fig != null) {
			if (fig instanceof Viewport
	                || fig instanceof ScalableFreeformLayeredPane)
				return fig;
			fig = fig.getParent();
			if (fig instanceof BorderItemContainerFigure) {
				fig = ((BorderItemContainerFigure) fig).getMainFigure();
			}
		}
		return null;
	}

	public void erase() {
		if (getChildren().isEmpty()) {
			super.erase();
		} else {
			if (getParent() == null || !isVisible())
				return;
			repaint();
		}
	}

	/**
	 * Refresh adornments
	 */
	public void repaint() {
		if (getChildren().isEmpty()) {
			super.repaint();
		} else {
			if (getParent() == null || !isVisible())
				return;
			Rectangle rectBounds = getExtendedBounds();
			getParent().getParent().repaint(rectBounds);
			if (getViewport() != null) {
				getViewport().repaint(rectBounds);
			}
		}
	}
    
    public void invalidate() {
        extendedBounds = null;
        super.invalidate();
        updateLayerExtents();
    }
    
    public void validate() {
        extendedBounds = null;
        super.validate();
    }
    
    /**
     * Gets the extended bounds of the figure which includes the bounds of all
     * the border item figures.
     * 
     * @@return the extended bounds
     */
    public Rectangle getExtendedBounds() {
        if (extendedBounds == null) {
            extendedBounds = getParent().getBounds().getCopy();
            Iterator iterator = getChildren().iterator();
            while (iterator.hasNext()) {
                Figure childFigure = (Figure) iterator.next();
                Rectangle childBounds = (childFigure instanceof IExpandableFigure) ? ((IExpandableFigure) childFigure)
                    .getExtendedBounds()
                    : childFigure.getBounds(); 
                if (useLocalCoordinates()) {
                    childBounds = childBounds.getCopy();
                    childBounds.translate(getLocation());
                }
                extendedBounds.union(childBounds);
            }
        }
        return extendedBounds;
    }
    
    protected void fireFigureMoved() {
        super.fireFigureMoved();
        extendedBounds = null;
        updateLayerExtents();
    }

    private void updateLayerExtents() {
        BorderItemsAwareFreeFormLayer layer = BorderItemsUtil.getBorderItemLayer(this);
        if (layer!=null){
            layer.borderFigureMoved();
        }
    }
    
	/* (non-Javadoc)
	 * @@see org.eclipse.draw2d.Figure#add(org.eclipse.draw2d.IFigure, java.lang.Object, int)
	 */
	public void add(IFigure figure, Object constraint, int index) {
		super.add(figure, constraint, index);
		helper.hookChild(figure);
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.draw2d.Figure#remove(org.eclipse.draw2d.IFigure)
	 */
	public void remove(IFigure figure) {
		helper.unhookChild(figure);
		super.remove(figure);
	}
    
    private class BorderItemContainerHelper {
    	
    	boolean ignoreChildFigureMovesHandling;
    	
    	class ChildTracker implements FigureListener {
    		public void figureMoved(IFigure source) {
    			if (!ignoreChildFigureMovesHandling) {
    				revalidate();
    			}
    		}
    	}
    	
    	private FigureListener figureListener = new ChildTracker();
    	
    	public void hookChild(IFigure child) {
    	    revalidate();
    		child.addFigureListener(figureListener);
    	}
    	
    	public void unhookChild(IFigure child) {
    	    revalidate();
    		child.removeFigureListener(figureListener);
    	}
    	
    }
    
}
@


1.7
log
@[219849, 227021] gmf_head crevells 080421 Border Item fixes
@
text
@a16 1
import org.eclipse.draw2d.ColorConstants;
d112 11
d409 2
d413 3
a415 1
    		    revalidate();
@


1.7.2.1
log
@[241879] gmf_R2_1_maintenance aboyko 080723 [Layout] BorderItemContainerFigure can indefinitely revalidate itself.
@
text
@d17 1
a112 11
	protected void primTranslate(int dx, int dy) {
		/*
		 * If the border item container is being moved, the children must move by the same amount too
		 * (as opposed to free form figure).
		 * We must ignore children moves in this case in the helper, since border item container shouldn't be invalidated.
		 */
		helper.ignoreChildFigureMovesHandling = true;
		super.primTranslate(dx, dy);
		helper.ignoreChildFigureMovesHandling = false;
	}

a398 2
    	boolean ignoreChildFigureMovesHandling;
    	
d401 1
a401 3
    			if (!ignoreChildFigureMovesHandling) {
    				revalidate();
    			}
@


1.6
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2007 IBM Corporation and others.
d17 1
d19 1
d51 3
a53 1

d351 1
a351 1
            extendedBounds = getBounds().getCopy();
d380 39
@


1.5
log
@ [161215]   gmf_head mmostafa 061123 Scrollpanes do not consider space occupied by border items
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2006 IBM Corporation and others.
d70 1
a70 1
		Rectangle clip = getParentRectangle();
d72 5
d113 5
d228 1
a228 1
		Rectangle rectangle = getParentRectangle();
d231 16
a246 3
    
    private Rectangle getParentRectangle() {
        return _getParentRectangle();
d251 5
a255 1
     * the client area of the parent.
d257 1
a257 1
    private Rectangle _getParentRectangle() {
d259 2
d265 3
d274 4
a277 5

	private IFigure getMainFigure(BorderItemContainerFigure gf) {
		BorderedNodeFigure gpf = (BorderedNodeFigure) gf.getParent();
		return gpf.getMainFigure();
	}
d288 1
a288 1
		IFigure fig = getMainFigure(this);
d291 1
a291 1
				|| fig instanceof ScalableFreeformLayeredPane)
d295 1
a295 1
				fig = getMainFigure((BorderItemContainerFigure) fig);
d320 1
a320 1
			Rectangle rectBounds = getParentRectangle();
d334 3
a336 6
    

    public Rectangle getExtendedBounds(){
        if (extendedBounds == null)
            extendedBounds = getExtendedBounds(getParent()).getCopy();
        return extendedBounds;
d339 18
a356 24
       
    private Rectangle getExtendedBounds(IFigure figure) {
        if (figure == null)
            return getBounds().getCopy();
        else {
            Rectangle _bounds = figure.getBounds().getCopy();
            if (figure instanceof BorderedNodeFigure){
                BorderedNodeFigure borderedFigure = (BorderedNodeFigure)figure;
                BorderItemContainerFigure borderedItemContainer = (BorderItemContainerFigure)borderedFigure.getBorderItemContainer();
                if (borderedItemContainer!=null){
                    Iterator iterator = borderedItemContainer.getChildren().iterator();
                    while (iterator.hasNext()) {
                        Figure element = (Figure) iterator.next();
                        if (element instanceof BorderedNodeFigure){
                            BorderedNodeFigure childbFigure = (BorderedNodeFigure)element;
                            BorderItemContainerFigure childBorderedItemContainer = (BorderItemContainerFigure)childbFigure.getBorderItemContainer();
                            if (childBorderedItemContainer!=null)
                                _bounds.union(childBorderedItemContainer.getExtendedBounds());
                            else
                                _bounds.union(childbFigure.getBounds());
                        }
                        else
                            _bounds.union(element.getBounds());
                     }
d358 1
a359 1
            return _bounds;
d361 1
@


1.4
log
@[160532] gmf_R1_0_maintenace mmostafa 061011  need a way to get the real bounds of a bordered figure
@
text
@d25 2
d223 1
a223 2
        Rectangle rect = _getParentRectangle();
        return rect.union(getExtendedBounds());
d300 1
a304 5
    public void validate() {
        extendedBounds = null;
        super.validate();
    }
    
d340 6
d347 6
@


1.3
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d14 1
d17 1
d39 1
a39 1
 * @@author tisrar, jbruck, cmahoney
d43 4
d219 22
a240 18

	/**
	 * Return the area of the parent viewport if there is one, otherwise, return
	 * the client area of the parent.
	 */
	private Rectangle getParentRectangle() {
		Rectangle rect = getParent().getParent().getClientArea().getCopy();

		IFigure port = getViewport();
		if (port != null) {
			Rectangle portRect = port.getClientArea().getCopy();
			if (portRect.height != 0 && portRect.width != 0) {
				rect = portRect;
			}
		}
		return rect;
//		return getHandleBounds().getCopy();
	}
d295 48
@


1.2
log
@bugzilla 110316 gmf-head sshaw 060117 Compiler warning count should be 0 - runtime diagram laye...
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2005 IBM Corporation and others.
d57 1
a57 1
	 * @@since 2.0
@


1.2.2.1
log
@[148078] gmf_R_1_0_maintenance aboyko 060802 @@since 3.0/3.1 tags in Javadocs in DiagramDocumentEditor class
@
text
@d57 1
a57 1
	 * 
@


1.2.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2006 IBM Corporation and others.
@


1.2.2.3
log
@[160532] gmf_head mmostafa 061011  [160532] gmf_R1_0_maintenace mmostafa 061011  need a way to get the real bounds of a bordered figure
@
text
@a13 1
import java.util.Iterator;
a15 1
import org.eclipse.draw2d.Figure;
d37 1
a37 1
 * @@author tisrar, jbruck, cmahoney, mmostafa
a40 4
    
    // rectangle indicating the extended bounds of the figure
    // extended bounds include the border items in the calculations 
    private Rectangle extendedBounds = new Rectangle();
d213 18
a230 22
    
    private Rectangle getParentRectangle() {
        Rectangle rect = _getParentRectangle();
        return rect.union(getExtendedBounds());
    }
    
    /**
     * Return the area of the parent viewport if there is one, otherwise, return
     * the client area of the parent.
     */
    private Rectangle _getParentRectangle() {
        Rectangle rect = getParent().getParent().getClientArea().getCopy();

        IFigure port = getViewport();
        if (port != null) {
            Rectangle portRect = port.getClientArea().getCopy();
            if (portRect.height != 0 && portRect.width != 0) {
                rect = portRect;
            }
        }
        return rect;
    }
a284 48
    
    public void invalidate() {
        extendedBounds = null;
        super.invalidate();
    }
    
    

    public void validate() {
        extendedBounds = null;
        super.validate();
    }
    
    public Rectangle getExtendedBounds(){
        if (extendedBounds == null)
            extendedBounds = getExtendedBounds(getParent()).getCopy();
        return extendedBounds;
    }
    
       
    private Rectangle getExtendedBounds(IFigure figure) {
        if (figure == null)
            return getBounds().getCopy();
        else {
            Rectangle _bounds = figure.getBounds().getCopy();
            if (figure instanceof BorderedNodeFigure){
                BorderedNodeFigure borderedFigure = (BorderedNodeFigure)figure;
                BorderItemContainerFigure borderedItemContainer = (BorderItemContainerFigure)borderedFigure.getBorderItemContainer();
                if (borderedItemContainer!=null){
                    Iterator iterator = borderedItemContainer.getChildren().iterator();
                    while (iterator.hasNext()) {
                        Figure element = (Figure) iterator.next();
                        if (element instanceof BorderedNodeFigure){
                            BorderedNodeFigure childbFigure = (BorderedNodeFigure)element;
                            BorderItemContainerFigure childBorderedItemContainer = (BorderItemContainerFigure)childbFigure.getBorderItemContainer();
                            if (childBorderedItemContainer!=null)
                                _bounds.union(childBorderedItemContainer.getExtendedBounds());
                            else
                                _bounds.union(childbFigure.getBounds());
                        }
                        else
                            _bounds.union(element.getBounds());
                     }
                }
            }
            return _bounds;
        }
    }
@


1.2.2.4
log
@ [161215]   gmf_R1_0_maintenace mmostafa 061123 Scrollpanes do not consider space occupied by border items
@
text
@a24 2
import org.eclipse.gmf.runtime.diagram.ui.figures.BorderItemsAwareFreeFormLayer;
import org.eclipse.gmf.runtime.diagram.ui.figures.BorderItemsUtil;
d221 10
a230 1
         Rectangle rect = getParent().getParent().getClientArea().getCopy();
a240 2
    
   
a298 1
        updateLayerExtents();
d303 5
a342 6
    
    protected void fireFigureMoved() {
        super.fireFigureMoved();
        extendedBounds = null;
        updateLayerExtents();
    }
a343 6
    private void updateLayerExtents() {
        BorderItemsAwareFreeFormLayer layer = BorderItemsUtil.getBorderItemLayer(this);
        if (layer!=null){
            layer.borderFigureMoved();
        }
    }
@


1.1
log
@Bugzilla#111935 gmf_head cmahoney 060104 Border Item Infrastructure Consistency Issues
@
text
@a15 1
import org.eclipse.draw2d.Border;
a20 1
import org.eclipse.draw2d.geometry.Insets;
@

