head	1.17;
access;
symbols
	v20081023-2107:1.17
	v20081022-1925:1.17
	v20081022-1005:1.17
	v20081020-0700:1.17
	v20080917-1925:1.17
	v20080916-2008:1.17
	v20080911-1728:1.17
	v20080911-1506:1.17
	v20080910-1520:1.17
	v20080910-1510:1.17
	v20080903-1520:1.17
	v20080903-1510:1.17
	v20080813-1510:1.17
	v20080811-1546:1.17
	v20080731-1520:1.17
	v20080725-1738:1.17
	v20080723-2246:1.17
	v20080723-2232:1.17
	v20080723-1700:1.17
	v20080722-1827:1.17
	v20080718-1700:1.17
	v20080718-1731:1.17
	v20080716-1600:1.17
	v20080716-1642:1.17
	R2_1_maintenance:1.17.0.6
	Root_R2_1_maintenance:1.17
	R2_1_0:1.17
	v20080610-1132:1.17
	v20080603-1553:1.17
	v20080527-1255:1.17
	v20080527-1151:1.17
	v20080516-1748:1.17
	v20080516-1143:1.17
	v20080512-1200:1.17
	v20080503-1740:1.17
	v20080501-2127:1.17
	v20080501-1739:1.17
	m20080429-1543:1.17
	v20080425-1959:1.17
	v20080417-1610:1.17
	v20080407-2250:1.17
	v20080407-0930:1.17
	v20080404-1111:1.17
	v20080328-1605:1.17
	v20080322-0000:1.17
	v20080222-1200:1.17
	v20080201-2010:1.17
	v20080201-0201:1.17
	v20080118-1129:1.17
	v20080114-2222:1.17
	v20080114-1111:1.17
	v20080107-1111:1.17
	v20071222-1111:1.17
	v20071214-1111:1.17
	v20071130-1111:1.17
	v20071124-0000:1.17
	v20071112-0000:1.17
	v20071108-0000:1.17
	v20071003-0000:1.17
	v20070915-0000:1.17
	v20070903-0000:1.17
	v20070809-0000:1.17
	R2_0_maintenance:1.17.0.4
	R2_0:1.17
	R4_20:1.17
	v20070621-0000:1.17
	RC3_20:1.17
	v20070614-1400:1.17
	v20070608-1300:1.17
	v20070605-1400:1.17
	v20070601-1400:1.17
	v20070525-1500:1.17
	v20070518-1300:1.17
	bugzilla111892_group_support:1.17.0.2
	Root_bugzilla111892_group_support:1.17
	v20070504-1000:1.17
	v20070420-1000:1.17
	v20070413-1300:1.17
	v20070330-1300:1.17
	v20060330-1300:1.17
	v20070322-1100:1.17
	v20060316-0600:1.17
	v20070221-1500:1.17
	v20070208-1800:1.17
	v20070202-0200:1.16.2.1
	v20070119-1200:1.16.2.1
	v20070111-0800:1.16.2.1
	v20070105-1200:1.16.2.1
	v20070103-0300:1.17
	M4_20:1.17
	v20061218-1500:1.16.2.1
	v20061218-1200:1.17
	v20061214-0000:1.17
	M3_20:1.17
	v20061117-0800:1.17
	v20061027-1200:1.16.2.1
	v20061013-1330:1.17
	v20061012-1100:1.16.2.1
	v20060925-1700:1.16.2.1
	v20060919-0800:1.16.2.1
	v20060907-1100:1.16
	M1_20:1.16
	v20060831-1500:1.16
	v20060824-1600:1.16
	v20060817-1500:1.16
	v20060810-1700:1.16
	v20060803-1200:1.16
	v20060728-0500:1.16
	v20060721-1130:1.16
	v20060713-1700:1.16
	R1_0_maintenance:1.16.0.2
	R1_0:1.16
	v20060627-1200:1.16
	v20060616-1400:1.16
	v20060616-1200:1.16
	v20060609-1400:1.16
	v20060531-1730:1.16
	v20060530-1930:1.16
	v20060526-1200:1.16
	v20060519-0800:1.16
	v20060512-1000:1.16
	I20060512-1000:1.16
	I20060505-1400:1.15
	I20060428-1300:1.15
	I20060424-0500:1.15
	I20060424-0300:1.14
	M6_10:1.14
	I20060407-1200:1.14
	I20060331-1000:1.14
	I20060324-0300:1.14
	I20060317-1300:1.14
	I20060317-1200:1.14
	I20060316-1300:1.14
	I20060309-1300:1.14
	M5_10:1.13
	S20060303-1600:1.13
	I20060227-1730:1.12
	I20060216-1945:1.12
	I20060210-1715:1.12
	I20060209-1815:1.12
	I20060203-0830:1.12
	I20060202-1415:1.12
	I20060129-1145:1.12
	I20060127-0900:1.12
	I20060120-1530:1.12
	I20060113-1700:1.11
	M4_10:1.11
	I20060107-1100:1.11
	I20060105-1630:1.11
	I20051230-1230:1.11
	I20051223-1100:1.11
	I20051217-0925:1.10
	I20051208-2000:1.9
	I20051201-1800:1.9
	I20051124-2000:1.9
	M3_10:1.8
	I20051118-1245:1.8
	I20051111-1800:1.8
	I20051106-0900:1.8
	v20051030:1.7;
locks; strict;
comment	@# @;


1.17
date	2006.10.03.15.02.05;	author ahunter;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.09.19.45.24;	author cmahoney;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2006.04.18.20.51.25;	author cmahoney;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.07.02.40.43;	author ldamus;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.28.02.30.51;	author cmahoney;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.17.18.12.20;	author sshaw;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.20.16.49.27;	author mmostafa;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.12.16.49.28;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.24.22.21.03;	author sshaw;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.02.23.30.18;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.23.20.55.29;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.23.18.50.51;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.22.15.42.19;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.21.29.07;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.15.48.53;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.22;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.51;	author sshaw;	state Exp;
branches;
next	;

1.16.2.1
date	2006.09.13.16.43.41;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.17
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui;

import java.util.Iterator;
import java.util.List;

import org.eclipse.gmf.runtime.common.ui.services.editor.EditorService;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditorInput;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;

/**
 * Provides miscellaneous diagram utilities
 * 
 * @@author melaasar, mmostafa
 */

public class DiagramUtil {

	/**
	 * Opens an editor for a given diagram
	 * 
	 * @@param diagram
	 *            The diagram to be opened
	 */
	public static void openDiagramEditor(Diagram diagram) {
		EditorService.getInstance().openEditor(new DiagramEditorInput(diagram));
	}

	/**
	 * Rerturns an open editor for the given diagram in the given workbench
	 * window if the window is null, the active window in the platform is
	 * considered
	 * 
	 * @@param diagram
	 *            The given diagram
	 * @@param window
	 *            The given window (or null to mean the active one)
	 * @@return An <code>IDiagramWorkbenchPart</code>
	 */
	public static IDiagramWorkbenchPart getOpenedDiagramEditor(Diagram diagram,
			IWorkbenchWindow window) {
		if (null == diagram)
			throw new NullPointerException("Argument 'diagram' is null"); //$NON-NLS-1$
		if (window == null)
			window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();

		List editors = EditorService.getInstance().getRegisteredEditorParts();
		for (Iterator j = editors.iterator(); j.hasNext();) {
			IEditorPart editor = (IEditorPart) j.next();
			if (editor.getEditorSite().getWorkbenchWindow() == window) {
                if (editor instanceof IDiagramWorkbenchPart) {
                    IDiagramWorkbenchPart de = (IDiagramWorkbenchPart) editor;
                    if (de.getDiagram() == diagram)
                        return de;
                }
			}
		}
		return null;
	}

}
@


1.16
log
@Bugzilla#109422 gmf_head cmahoney 060509 Removing deprecated classes from GMF diagram components
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
@


1.16.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@


1.15
log
@Bugzilla#109422 gmf_head cmahoney 060418 Remove deprecated API
@
text
@a16 1
import org.eclipse.emf.ecore.EObject;
a19 1
import org.eclipse.gmf.runtime.emf.type.core.commands.DestroyElementCommand;
a20 1
import org.eclipse.gmf.runtime.notation.View;
a33 13
	 * Destroys a given view
	 * 
	 * @@param view
	 *            The view to be destroyed
 	 *			deprectaion date:  Dec 19 , 05
	 * 			removal date:	   Jan 31 , 06	
     * @@deprecated Use {@@link DestroyElementCommand#destroy(EObject)} instead.     	
	 */
	public static void destroyView(View view) {
		DestroyElementCommand.destroy(view);
	}

	/**
d65 5
a69 3
				IDiagramWorkbenchPart de = (IDiagramWorkbenchPart) editor;
				if (de.getDiagram() == diagram)
					return de;
@


1.14
log
@[129773] gmf_head cdamus 060306 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@a16 1
import org.eclipse.core.runtime.IAdaptable;
a18 5
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.gmf.runtime.diagram.core.services.ViewService;
import org.eclipse.gmf.runtime.diagram.core.util.ViewType;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
a20 3
import org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNode;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutService;
import org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter;
a22 2
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.Node;
a23 1
import org.eclipse.jface.util.Assert;
a36 122
	 * Creates a diagram with the given context and kind
	 * 
	 * @@param context
	 *            The diagram element context
	 * @@param kind
	 *            diagram kind, check {@@link ViewType} for predefined values
	 * @@param preferencesHint
	 *            The preference hint that is to be used to find the appropriate
	 *            preference store from which to retrieve diagram preference
	 *            values. The preference hint is mapped to a preference store in
	 *            the preference registry <@@link DiagramPreferencesRegistry>.
	 * @@return A newly created <code>Diagram</code>
	 * @@deprecated if there is a context EObject use @@link ViewService#createDiagram(EObject, String, PreferencesHint)
	 *             if there is no context EObject use   @@link ViewService#createDiagram(String, PreferencesHint)
  	 *				deprectaion date:  Dec 19 , 05
	 * 				removal date:	   Jan 31 , 06	     	
	 */
	public static Diagram createDiagram(EObject context, String kind,
			PreferencesHint preferencesHint) {
		IAdaptable viewModel = (context != null) ? new EObjectAdapter(context)
				: null;
		String viewType = (kind != null) ? kind : ""; //$NON-NLS-1$
		return ViewService.getInstance().createDiagram(viewModel, viewType,
				preferencesHint);
	}

	/**
	 * Creates a node for a given eObject and with a given type and inserts it
	 * into a given container
	 * 
	 * @@param container
	 *            The node view container
	 * @@param eObject
	 *            The node view object context
	 * @@param type
	 *            The node view type, check {@@link ViewType} for predefined
	 *            values
	 * @@param preferencesHint
	 *            The preference hint that is to be used to find the appropriate
	 *            preference store from which to retrieve diagram preference
	 *            values. The preference hint is mapped to a preference store in
	 *            the preference registry <@@link DiagramPreferencesRegistry>.
	 * @@return A newly created <code>Node</code>
	 * @@deprecated if there is a context EObject use @@link ViewService#createNode(View, EObject, String, PreferencesHint)
	 *             if there is no context EObject use   @@link ViewService#createNode(View, String, PreferencesHint)
	 *          	deprectaion date:  Dec 19 , 05
	 * 				removal date:	   Jan 31 , 06	     	
	 */
	public static Node createNode(View container, EObject eObject, String type,
			PreferencesHint preferencesHint) {
		Assert.isNotNull(container, "The container is null"); //$NON-NLS-1$
		IAdaptable viewModel = (eObject != null) ? new EObjectAdapter(eObject)
				: null;
		String viewType = (type != null) ? type : ""; //$NON-NLS-1$
		View view = ViewService.getInstance().createNode(viewModel, container,
				viewType, ViewUtil.APPEND, preferencesHint);
		return (view != null) ? (Node) view : null;
	}

	/**
	 * Creates an edge for a given eObject and with a given type in the given
	 * diagram
	 * 
	 * @@param diagram
	 *            The container diagram
	 * @@param eObject
	 *            The edge view object context
	 * @@param type
	 *            The edge view type, check {@@link ViewType} for predefined
	 *            values
	 * @@param preferencesHint
	 *            The preference hint that is to be used to find the appropriate
	 *            preference store from which to retrieve diagram preference
	 *            values. The preference hint is mapped to a preference store in
	 *            the preference registry <@@link DiagramPreferencesRegistry>.
	 * @@return A newly created <code>Edge</code>
	 * @@deprecated use {@@link ViewService#createEdge(View, View, EObject, String, PreferencesHint)}
	 *           		deprectaion date:  Dec 19 , 05
	 * 					removal date:	   Jan 31 , 06	     	
	 */
	public static Edge createEdge(Diagram diagram, EObject eObject,
			String type, PreferencesHint preferencesHint) {
		Assert.isNotNull(diagram, "The diagram is null"); //$NON-NLS-1$
		IAdaptable viewModel = (eObject != null) ? new EObjectAdapter(eObject)
				: null;
		String viewType = (type != null) ? type : ""; //$NON-NLS-1$
		View view = ViewService.getInstance().createEdge(viewModel, diagram,
				viewType, ViewUtil.APPEND, preferencesHint);
		return (view != null) ? (Edge) view : null;
	}

	/**
	 * Creates an edge for a given eObject and with a given type and connects it
	 * between a given source and a given target
	 * 
	 * @@param source
	 *            The edge's source view
	 * @@param target
	 *            The edge's target view
	 * @@param eObject
	 *            The edge view object context
	 * @@param type
	 *            The edge view type, check {@@link ViewType} for predefined
	 *            values
	 * @@param preferencesHint
	 *            The preference hint that is to be used to find the appropriate
	 *            preference store from which to retrieve diagram preference
	 *            values. The preference hint is mapped to a preference store in
	 *            the preference registry <@@link DiagramPreferencesRegistry>.
	 * @@return A newly created <code>Edge</code>
	 * @@deprecated if there is a context EObject use @@link ViewService#createEdge(View, View, EObject, String, PreferencesHint)
	 *             if there is no context EObject use  @@link ViewService#createEdge(View, View, String, PreferencesHint)
	 *           		deprectaion date:  Dec 19 , 05
	 * 					removal date:	   Jan 31 , 06	     	
	 */
	public static Edge createEdge(View source, View target, EObject eObject,
			String type, PreferencesHint preferencesHint) {
		return  ViewService.createEdge(source,target, eObject, type,
				preferencesHint);
	}

	/**
d42 2
a43 1
	 * 			removal date:	   Jan 31 , 06	     	
a59 90
	 * Gets the <code>ILayoutNode</code> in order to retrieve the actual size
	 * of the Node object irrespective of the autosize properties.
	 * 
	 * @@param node
	 *            Node to get the layout node equivalent from
	 * @@return <code>ILayoutNode</code>object
	 * 
	 * @@throws NullPointerException
	 *             <code>node</code> is <code>null</code>
	 * @@deprecated use
	 *             {@@link org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutService#getLayoutNode(Node)}
	 *             Will be removed on December 16th / 2005
	 */
	public static ILayoutNode getLayoutNode(Node node) {
		return LayoutService.getInstance().getLayoutNode(node);
	}

	/**
	 * @@param diagramEP
	 *            the diagram edit part to use
	 * @@param nodes
	 *            List of <code>Node</code> objects
	 * @@return List of <code>ILayoutNodes</code> objects
	 * @@deprecated use
	 *             {@@link org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutService#getLayoutNodes(DiagramEditPart, List)}
	 *             Will be removed on December 16th / 2005
	 */
	public static List getLayoutNodes(DiagramEditPart diagramEP, List nodes) {
		return LayoutService.getInstance().getLayoutNodes(diagramEP, nodes);
	}

	/**
	 * Utility method to layout the children of a view container.
	 * 
	 * @@param view
	 *            View object that is the container whose children will be laid
	 *            out.
	 * @@param hint
	 *            String representing a hint for what kind of layout will be
	 *            applied. Value can be one of
	 *            <code>org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider.DEFAULT_LAYOUT</code>
	 *            or
	 *            <code>org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider.RADIAL_LAYOUT</code>.
	 *            Other values would have to understand by custom providers.
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider
	 * @@throws NullPointerException
	 *             <code>View</code> is <code>null</code>
	 * @@throws NullPointerException
	 *             <code>hint</code> is <code>null</code>
	 * @@deprecated use
	 *             {@@link org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutService#layout(View, String)}
	 *             Will be removed on December 16th / 2005
	 */
	public static void layout(View view, String hint) {
		LayoutService.getInstance().layout(view, hint);
	}

	/**
	 * Utility method to layout a list of Node children on a diagram.
	 * 
	 * @@param nodes
	 *            List of Node objects
	 * @@param hint
	 *            String representing a hint for what kind of layout will be
	 *            applied. Value can be one of
	 *            <code>org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider.DEFAULT_LAYOUT</code> 
	 * <code>org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider.RADIAL_LAYOUT</code>.
	 *            Other values would have to understand by custom providers.
	 * @@see org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider
	 * @@throws NullPointerException
	 *             <code>nodes</code> is <code>null</code>
	 * @@throws IllegalArgumentException
	 *             nodes is an empty list
	 * @@throws NullPointerException
	 *             <code>hint</code> is <code>null</code>
	 * @@throws IllegalArgumentException
	 *             Argument <code>nodes</code> contains objects which aren't
	 *             of type <code>Node</code>
	 * @@throws IllegalArgumentException
	 *             Argument <code>nodes</code> contains objects which have a
	 *             different parent containment
	 * @@deprecated use
	 *             {@@link org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutService#layout(List, String)}
	 *             Will be removed on December 16th / 2005
	 */
	public static void layoutNodes(List nodes, String hint) {
		LayoutService.getInstance().layoutNodes(nodes, true, hint);
	}

	/**
@


1.13
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@a28 1
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;
d30 1
d179 1
a179 1
		EMFCoreUtil.destroy(view);
@


1.12
log
@bugzilla 110316 gmf-head sshaw 060117 Compiler warning count should be 0 - runtime diagram laye...
@
text
@d22 1
d29 1
a30 1
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
d179 1
a179 1
		EObjectUtil.destroy(view);
@


1.11
log
@bugzilla 115826 gmf-head mmostafa 051220 ViewService should be public
@
text
@a21 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewType;
@


1.10
log
@bugzilla 110316 gmf-head 051212 Compiler warning count should be 0 - runtime diagram layer
@
text
@a19 1
import org.eclipse.gmf.runtime.diagram.core.internal.services.view.ViewService;
d21 2
d61 4
d92 4
d125 3
d159 4
d166 1
a166 5
		Assert.isNotNull(source, "The source is null"); //$NON-NLS-1$
		Assert.isNotNull(target, "The target is null"); //$NON-NLS-1$
		Assert.isNotNull(source.getDiagram(), "The source is detached"); //$NON-NLS-1$
		Assert.isNotNull(target.getDiagram(), "The target is detached"); //$NON-NLS-1$
		Edge edge = createEdge(source.getDiagram(), eObject, type,
a167 5
		if (edge != null) {
			edge.setSource(source);
			edge.setTarget(target);
		}
		return edge;
d175 2
a308 1

@


1.9
log
@bugzilla 116490 gmf-head sshaw 051124 LayoutService should be public
@
text
@a21 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewType;
@


1.8
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@a13 1
import java.util.ArrayList;
a15 2
import java.util.ListIterator;
import java.util.Map;
a17 1
import org.eclipse.draw2d.geometry.Dimension;
a18 7
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.jface.util.Assert;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;

import org.eclipse.gmf.runtime.common.core.util.ObjectAdapter;
d22 2
a24 2
import org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.LayoutNode;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.LayoutService;
d28 1
a28 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d35 4
a38 1

d51 4
a54 2
	 * @@param context The diagram element context
	 * @@param kind diagram kind, check {@@link ViewType} for predefined values
d62 4
a65 2
	public static Diagram createDiagram(EObject context, String kind, PreferencesHint preferencesHint) {
		IAdaptable viewModel = (context != null) ? new EObjectAdapter(context) : null;
d67 2
a68 1
		return ViewService.getInstance().createDiagram(viewModel, viewType, preferencesHint);
d70 1
a70 1
	
d72 2
a73 1
	 * Creates a node for a given eObject and with a given type and inserts it into a given container
d75 7
a81 3
	 * @@param container The node view container
	 * @@param eObject The node view object context
	 * @@param type The node view type, check {@@link ViewType} for predefined values
d89 2
a90 1
	public static Node createNode(View container, EObject eObject, String type, PreferencesHint preferencesHint) {
d92 2
a93 1
		IAdaptable viewModel = (eObject != null) ? new EObjectAdapter(eObject) : null;
d95 3
a97 2
		View view = ViewService.getInstance().createNode(viewModel, container, viewType, ViewUtil.APPEND, preferencesHint);
		return (view != null) ? (Node)view : null;
d101 10
a110 5
	 * Creates an edge for a given eObject and with a given type in the given diagram
	 *
	 * @@param diagram The container diagram 
	 * @@param eObject The edge view object context
	 * @@param type The edge view type, check {@@link ViewType} for predefined values
d118 2
a119 1
	public static Edge createEdge(Diagram diagram, EObject eObject, String type, PreferencesHint preferencesHint) {
d121 2
a122 1
		IAdaptable viewModel = (eObject != null) ? new EObjectAdapter(eObject) : null;
d124 2
a125 1
		View view = ViewService.getInstance().createEdge(viewModel, diagram, viewType, ViewUtil.APPEND, preferencesHint);
d128 1
a128 1
	
d130 2
a131 1
	 * Creates an edge for a given eObject and with a given type and connects it between a given source and a given target
d133 9
a141 4
	 * @@param source The edge's source view
	 * @@param target The edge's target view
	 * @@param eObject The edge view object context
	 * @@param type The edge view type, check {@@link ViewType} for predefined values
d149 2
a150 1
	public static Edge createEdge(View source, View target, EObject eObject, String type, PreferencesHint preferencesHint) {
d155 2
a156 1
		Edge edge = createEdge(source.getDiagram(), eObject, type, preferencesHint);
d167 2
a168 1
	 * @@param view The view to be destroyed
d173 1
a173 1
	
d176 3
a178 1
	 * @@param diagram The diagram to be opened
d183 1
a183 1
	
d188 2
a189 1
	 * @@param node Node to get the layout node equivalent from
d194 3
d199 1
a199 35
		if (null == node) {
			throw new NullPointerException("Argument 'node' is null"); //$NON-NLS-1$
		}
		
		Diagram diagram = node.getDiagram(); 
		DiagramEditPart diagramEP = OffscreenEditPartFactory.getInstance().createDiagramEditPart(diagram);
		Map registry = diagramEP.getViewer().getEditPartRegistry();
		GraphicalEditPart gep = (GraphicalEditPart)registry.get(node);
		Dimension size = gep.getFigure().getBounds().getSize();
		
		return new LayoutNode(node, size.width, size.height);
	}
	
	private static void checkValidNodes(List nodes) {
		if (null == nodes) {
			throw new NullPointerException("Argument 'nodes' is null"); //$NON-NLS-1$
		}
		if (nodes.size() == 0) {
			throw new IllegalArgumentException("Argument 'nodes' is empty"); //$NON-NLS-1$
		}
				
		ListIterator li = nodes.listIterator();
		EObject parent = null;
		while (li.hasNext()) {
			Object next = li.next();
			if (!(next instanceof Node))
				throw new IllegalArgumentException("Argument 'nodes' contains objects which aren't of type 'Node'"); //$NON-NLS-1$
			Node node = (Node)next;
			
			if (parent == null)
				parent =  ViewUtil.getContainerView(node);
			else
				if (ViewUtil.getContainerView(node) != parent)
					throw new IllegalArgumentException("Argument 'nodes' contains objects which have a different parent containment"); //$NON-NLS-1$
		} 
d201 1
a201 1
	
d203 4
a206 2
	 * @@param diagramEP	the diagram edit part to use
	 * @@param nodes List of <code>Node</code> objects 
d208 3
d213 1
a213 19
		checkValidNodes(nodes);
		
		if (diagramEP == null){
			Diagram diagram = ((Node)nodes.get(0)).getDiagram(); 
			diagramEP = OffscreenEditPartFactory.getInstance().createDiagramEditPart(diagram);
		}
		Map registry = diagramEP.getViewer().getEditPartRegistry();
		
		List layoutNodes = new ArrayList(nodes.size());
		ListIterator li = nodes.listIterator();
		while (li.hasNext()) {
			Node node = (Node)li.next();
			GraphicalEditPart gep = (GraphicalEditPart)registry.get(node);
			Dimension size = gep.getFigure().getBounds().getSize();
			
			layoutNodes.add(new LayoutNode(node,size.width, size.height));
		}
		
		return layoutNodes;
d215 1
a215 1
	
d219 10
a228 5
	 * @@param view View object that is the container whose children will be laid out.
	 * @@param hint String representing a hint for what kind of layout will be applied.  Value can be one of
	 * <code>org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider.DEFAULT_LAYOUT</code> or 
	 * <code>org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider.RADIAL_LAYOUT</code>.  
	 * Other values would have to understand by custom providers.  
d230 7
a236 2
	 * @@throws NullPointerException <code>View</code> is <code>null</code>
	 * @@throws NullPointerException <code>hint</code> is <code>null</code>
d239 1
a239 16
		if (null == view) {
			throw new NullPointerException("Argument 'view' is null"); //$NON-NLS-1$
		}
		if (null == hint) {
			throw new NullPointerException("Argument 'hint' is null"); //$NON-NLS-1$
		}
				
		Diagram diagram = view.getDiagram();
		DiagramEditPart diagramEP = OffscreenEditPartFactory.getInstance().createDiagramEditPart(diagram);
		
		List hints = new ArrayList(2);
		hints.add(hint);
		hints.add(diagramEP);
		IAdaptable layoutHint = new ObjectAdapter(hints);
		final Runnable layoutRun =  LayoutService.getInstance().layoutNodes(getLayoutNodes(diagramEP,view.getChildren()), false, layoutHint);
		layoutRun.run();
d241 1
a241 1
	
d245 24
a268 11
	 * @@param nodes List of Node objects
	 * @@param hint String representing a hint for what kind of layout will be applied.  Value can be one of
	 * <code>org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider.DEFAULT_LAYOUT</code> 
	 * <code>org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider.RADIAL_LAYOUT</code>.  
     * Other values would have to understand by custom providers.
	 * @@see   org.eclipse.gmf.runtime.diagram.ui.services.layout.ILayoutNodesProvider
	 * @@throws NullPointerException  <code>nodes</code> is <code>null</code>
	 * @@throws IllegalArgumentException nodes is an empty list
	 * @@throws NullPointerException  <code>hint</code> is <code>null</code>
	 * @@throws IllegalArgumentException Argument <code>nodes</code> contains objects which aren't of type <code>Node</code>
	 * @@throws IllegalArgumentException Argument <code>nodes</code> contains objects which have a different parent containment
d271 1
a271 16
		checkValidNodes(nodes);
		
		if (null == hint) {
			throw new NullPointerException("Argument 'hint' is null"); //$NON-NLS-1$
		} 
		
		Node nodeFirst = (Node)nodes.get(0);
		Diagram diagram = nodeFirst.getDiagram();
		DiagramEditPart diagramEP = OffscreenEditPartFactory.getInstance().createDiagramEditPart(diagram);
		
		List hints = new ArrayList(2);
		hints.add(hint);
		hints.add(diagramEP);
		IAdaptable layoutHint = new ObjectAdapter(hints);
		final Runnable layoutRun =  LayoutService.getInstance().layoutNodes(getLayoutNodes(diagramEP,nodes), true, layoutHint);
		layoutRun.run();
a273 2

	
d275 3
a277 2
	 * Rerturns an open editor for the given diagram in the given workbench window
	 * if the window is null, the active window in the platform is considered
d279 4
a282 2
	 * @@param diagram The given diagram
	 * @@param window The given window (or null to mean the active one)
d285 2
a286 1
	public static IDiagramWorkbenchPart getOpenedDiagramEditor(Diagram diagram, IWorkbenchWindow window) {
d291 1
a291 1
		
d303 1
a303 1
	}	
@


1.7
log
@Bugzilla 109092: gmf_head sshaw 050923 : fixing build errors
@
text
@d112 1
a112 1
		View view = ViewService.getInstance().createConnectorView(viewModel, diagram, viewType, ViewUtil.APPEND, preferencesHint);
@


1.6
log
@bugzilla 110478 gmf-head sshaw Introduce a view refactoring helper based on semantic refactoring

Contributed by: Maged Elaasar
@
text
@d69 3
a71 1
		return ViewService.getInstance().createDiagram(context, kind, preferencesHint);
d89 4
a92 1
		return ViewService.getInstance().createNode(container, eObject, type, preferencesHint);
d110 4
a113 1
		return ViewService.getInstance().createEdge(diagram, eObject, type, preferencesHint);
d135 6
a140 1
		return ViewService.getInstance().createEdge(source, target, eObject, type, preferencesHint);
@


1.5
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d69 1
a69 3
		IAdaptable viewModel = (context != null) ? new EObjectAdapter(context) : null;
		String viewType = (kind != null) ? kind : ""; //$NON-NLS-1$
		return ViewService.getInstance().createDiagram(viewModel, viewType, preferencesHint);
d87 1
a87 4
		IAdaptable viewModel = (eObject != null) ? new EObjectAdapter(eObject) : null;
		String viewType = (type != null) ? type : ""; //$NON-NLS-1$
		View view = ViewService.getInstance().createNode(viewModel, container, viewType, ViewUtil.APPEND, preferencesHint);
		return (view != null) ? (Node)view : null;
d105 1
a105 4
		IAdaptable viewModel = (eObject != null) ? new EObjectAdapter(eObject) : null;
		String viewType = (type != null) ? type : ""; //$NON-NLS-1$
		View view = ViewService.getInstance().createConnectorView(viewModel, diagram, viewType, ViewUtil.APPEND, preferencesHint);
		return (view != null) ? (Edge) view : null;
d127 1
a127 6
		Edge edge = createEdge(source.getDiagram(), eObject, type, preferencesHint);
		if (edge != null) {
			edge.setSource(source);
			edge.setTarget(target);
		}
		return edge;
@


1.4
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d51 1
a51 1
 * @@author melaasar
d60 1
a60 1
	 * @@param kind diagram kind
d73 1
a73 1

d79 1
a79 1
	 * @@param type The node view type
d100 1
a100 1
	 * @@param type The edge view type
d122 1
a122 1
	 * @@param type The edge view type
@


1.3
log
@Bugzilla109092 : rmp_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d69 1
a69 4
		/*IDiagramView view = ViewService.getInstance().createDiagramView(viewModel, viewType);
		Diagram diagram = (view != null) ? (Diagram) view.getAdapter(Diagram.class) : null;
		return diagram;*/
		return ViewService.getInstance().createDiagramView(viewModel, viewType, preferencesHint);
d89 1
a89 1
		View view = ViewService.getInstance().createNodeView(viewModel, container, viewType, ViewUtil.APPEND, preferencesHint);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d40 4
a43 4
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.Edge;
import com.ibm.xtools.notation.Node;
import com.ibm.xtools.notation.View;
@

