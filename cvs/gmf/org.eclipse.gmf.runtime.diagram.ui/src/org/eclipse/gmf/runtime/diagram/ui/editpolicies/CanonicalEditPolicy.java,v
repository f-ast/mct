head	1.31;
access;
symbols
	v20081023-2107:1.30.2.1
	v20081022-1925:1.31
	v20081022-1005:1.30.2.1
	v20081020-0700:1.31
	v20080917-1925:1.31
	v20080916-2008:1.30.2.1
	v20080911-1728:1.31
	v20080911-1506:1.30.2.1
	v20080910-1520:1.31
	v20080910-1510:1.30.2.1
	v20080903-1520:1.31
	v20080903-1510:1.30.2.1
	v20080813-1510:1.30
	v20080811-1546:1.30
	v20080731-1520:1.30
	v20080725-1738:1.30
	v20080723-2246:1.30
	v20080723-2232:1.30
	v20080723-1700:1.30
	v20080722-1827:1.30
	v20080718-1700:1.30
	v20080718-1731:1.30
	v20080716-1600:1.30
	v20080716-1642:1.30
	R2_1_maintenance:1.30.0.2
	Root_R2_1_maintenance:1.30
	R2_1_0:1.30
	v20080610-1132:1.30
	v20080603-1553:1.30
	v20080527-1255:1.30
	v20080527-1151:1.28
	v20080516-1748:1.30
	v20080516-1143:1.30
	v20080512-1200:1.30
	v20080503-1740:1.30
	v20080501-2127:1.28
	v20080501-1739:1.30
	m20080429-1543:1.28
	v20080425-1959:1.30
	v20080417-1610:1.30
	v20080407-2250:1.30
	v20080407-0930:1.30
	v20080404-1111:1.30
	v20080328-1605:1.30
	v20080322-0000:1.30
	v20080222-1200:1.30
	v20080201-2010:1.30
	v20080201-0201:1.28
	v20080118-1129:1.28
	v20080114-2222:1.28
	v20080114-1111:1.29
	v20080107-1111:1.29
	v20071222-1111:1.29
	v20071214-1111:1.29
	v20071130-1111:1.29
	v20071124-0000:1.28
	v20071112-0000:1.28
	v20071108-0000:1.28
	v20071003-0000:1.28
	v20070915-0000:1.28
	v20070903-0000:1.28
	v20070809-0000:1.28
	R2_0_maintenance:1.28.0.4
	R2_0:1.28
	R4_20:1.28
	v20070621-0000:1.28
	RC3_20:1.28
	v20070614-1400:1.28
	v20070608-1300:1.28
	v20070605-1400:1.28
	v20070601-1400:1.28
	v20070525-1500:1.28
	v20070518-1300:1.28
	bugzilla111892_group_support:1.28.0.2
	Root_bugzilla111892_group_support:1.28
	v20070504-1000:1.27
	v20070420-1000:1.27
	v20070413-1300:1.27
	v20070330-1300:1.27
	v20060330-1300:1.27
	v20070322-1100:1.27
	v20060316-0600:1.27
	v20070221-1500:1.27
	v20070208-1800:1.25
	v20070202-0200:1.23.2.4
	v20070119-1200:1.23.2.4
	v20070111-0800:1.23.2.4
	v20070105-1200:1.23.2.4
	v20070103-0300:1.24
	M4_20:1.24
	v20061218-1500:1.23.2.4
	v20061218-1200:1.24
	v20061214-0000:1.24
	M3_20:1.24
	v20061117-0800:1.24
	v20061027-1200:1.23.2.4
	v20061013-1330:1.24
	v20061012-1100:1.23.2.4
	v20060925-1700:1.23.2.4
	v20060919-0800:1.23.2.4
	v20060907-1100:1.23.2.3
	M1_20:1.23
	v20060831-1500:1.23.2.3
	v20060824-1600:1.23.2.3
	v20060817-1500:1.23.2.2
	v20060810-1700:1.23.2.2
	v20060803-1200:1.23.2.2
	v20060728-0500:1.23
	v20060721-1130:1.23
	v20060713-1700:1.23
	R1_0_maintenance:1.23.0.2
	R1_0:1.23
	v20060627-1200:1.23
	v20060616-1400:1.23
	v20060616-1200:1.23
	v20060609-1400:1.21
	v20060531-1730:1.20
	v20060530-1930:1.19
	v20060526-1200:1.19
	v20060519-0800:1.19
	v20060512-1000:1.19
	I20060512-1000:1.19
	I20060505-1400:1.18
	I20060428-1300:1.18
	I20060424-0500:1.17
	I20060424-0300:1.16
	M6_10:1.16
	I20060407-1200:1.16
	I20060331-1000:1.16
	I20060324-0300:1.16
	I20060317-1300:1.16
	I20060317-1200:1.16
	I20060316-1300:1.16
	I20060309-1300:1.16
	M5_10:1.15
	S20060303-1600:1.15
	I20060227-1730:1.14
	I20060216-1945:1.14
	I20060210-1715:1.13
	I20060209-1815:1.13
	I20060203-0830:1.12
	I20060202-1415:1.12
	I20060129-1145:1.12
	I20060127-0900:1.12
	I20060120-1530:1.11
	I20060113-1700:1.11
	M4_10:1.11
	I20060107-1100:1.11
	I20060105-1630:1.11
	I20051230-1230:1.11
	I20051223-1100:1.11
	I20051217-0925:1.11
	I20051208-2000:1.11
	I20051201-1800:1.10
	I20051124-2000:1.9
	M3_10:1.9
	I20051118-1245:1.9
	I20051111-1800:1.9
	I20051106-0900:1.9
	v20051030:1.7;
locks; strict;
comment	@# @;


1.31
date	2008.09.03.15.27.38;	author aboyko;	state Exp;
branches;
next	1.30;
commitid	2d6e348beacea4567;

1.30
date	2008.01.28.20.36.35;	author ahunter;	state Exp;
branches
	1.30.2.1;
next	1.29;
commitid	2f9479e3cd24567;

1.29
date	2007.11.21.17.57.28;	author crevells;	state Exp;
branches;
next	1.28;
commitid	4a12474471874567;

1.28
date	2007.05.11.22.16.57;	author mmostafa;	state Exp;
branches
	1.28.2.1;
next	1.27;
commitid	73b74644eb594567;

1.27
date	2007.02.15.20.52.41;	author mmostafa;	state Exp;
branches;
next	1.26;
commitid	578245d4c8184567;

1.26
date	2007.02.15.20.32.14;	author mmostafa;	state Exp;
branches;
next	1.25;
commitid	365b45d4c34d4567;

1.25
date	2007.01.12.17.08.59;	author mmostafa;	state Exp;
branches;
next	1.24;
commitid	7e7245a7c0aa4567;

1.24
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.16.15.34.30;	author sshaw;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2006.06.14.18.39.49;	author ahunter;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.02.13.15.59;	author sshaw;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.31.16.26.07;	author sshaw;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.09.19.45.24;	author cmahoney;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.27.19.47.14;	author mmostafa;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.21.21.24.49;	author mmostafa;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.09.20.50.31;	author mmostafa;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.28.02.30.51;	author cmahoney;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.13.19.11.49;	author ldamus;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.07.15.19.06;	author mmostafa;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.20.22.10.12;	author cmahoney;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.07.19.46.08;	author sshaw;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.25.19.38.12;	author cmahoney;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.04.21.23.06;	author sshaw;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.22.15.42.19;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.13.15.45.50;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.12.21.29.07;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.16.08.52;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.15.48.52;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.37;	author sshaw;	state Exp;
branches;
next	;

1.23.2.1
date	2006.07.28.19.37.32;	author mmostafa;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2006.07.28.20.58.32;	author mmostafa;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2006.08.24.19.06.38;	author mmostafa;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2006.09.13.16.43.39;	author ahunter;	state Exp;
branches;
next	;

1.28.2.1
date	2007.05.18.17.36.43;	author crevells;	state Exp;
branches;
next	;
commitid	1899464de42a4567;

1.30.2.1
date	2008.09.03.15.25.06;	author aboyko;	state Exp;
branches;
next	;
commitid	2d4b048beac524567;


desc
@@


1.31
log
@[241252] gmf_head mgobeil 080903 addListenersToContainers of CanonicalEditPolicy wrongly uses toString method to generate IDs
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/


package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.util.UniqueEList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.transaction.Transaction;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.emf.workspace.AbstractEMFOperation;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartViewer;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gef.editpolicies.AbstractEditPolicy;
import org.eclipse.gef.requests.CreateRequest;
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.commands.DeleteCommand;
import org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker;
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener;
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationUtil;
import org.eclipse.gmf.runtime.diagram.core.util.ViewType;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.CreateCommand;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.SetViewMutabilityCommand;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewRequest;
import org.eclipse.gmf.runtime.diagram.ui.util.EditPartUtil;
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;
import org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter;
import org.eclipse.gmf.runtime.notation.CanonicalStyle;
import org.eclipse.gmf.runtime.notation.DrawerStyle;
import org.eclipse.gmf.runtime.notation.Node;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.Style;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.osgi.util.NLS;
import org.eclipse.ui.PlatformUI;


/**
 * The base canonical editpolicy class.
 * This edit policy will register itself with the model server to receive
 * semantic events fired to its host editpart.  It will create, if necessary,
 * notation elements for all semantic elements inserted into the host
 * element or delete the notation element for the semantic element removed
 * from the host element.
 * <P>
 * This editpolicy will create the necessary notation element by simply
 * returning a {@@link org.eclipse.gmf.runtime.diagram.ui.commands.CreateCommand}.
 * 
 * @@see #refreshSemanticChildren()
 * @@see #handleSemanticEvent(NotificationEvent) will create or delete notation elements
 * as required.
 * @@see #getCreateViewCommand(CreateRequest)
 * @@see #shouldDeleteView(View)
 * @@author mhanner, mmostafa
 */
public abstract class CanonicalEditPolicy extends AbstractEditPolicy 
implements NotificationListener {
	
	/** Runs the supplied commands asyncronously. */
	private static class AsyncCommand extends Command {
		private final CompoundCommand _cc;
		
		
		/**
		 * constructor
		 * @@param label this command label
		 */
		public AsyncCommand(String label) {
			super(label);
			_cc = new CompoundCommand(label);
		}

		/**
		 * constructor
		 * @@param cmd the command
		 */
		public AsyncCommand( Command cmd ) {
			this( cmd.getLabel() );
			add( cmd );
		}

		
		/**
		 * constructor
		 * @@param cmd the command
		 */
		public AsyncCommand( ICommand cmd ) {
			this( cmd.getLabel() );
			add( cmd );
		}
		
		/**
		 * Executes the command asynchonously. 
		 * Calls {@@link #doExecute}.
		 */
		public final void execute() {
            // do not use Display.getCurrent() this mthod could be invoked
            // on a non ui thread
            PlatformUI.getWorkbench().getDisplay().asyncExec( new Runnable() {
					public void run() {
						AsyncCommand.this.doExecute();
					}
				} );
		}
		
		/**
		 * Return the command to be executed asynchronously.
		 * @@return the command
		 */
		protected final CompoundCommand getCommand() {
			return _cc;
		}
		
		/** Executes the command. */
		protected void doExecute() {
			getCommand().execute(); 
		}
		
		/**
		 * Add supplied command to the list of commands to be executed.
		 * @@param cmd command to add
		 */
		public void add( ICommand cmd ) {
			_cc.add( new ICommandProxy(cmd));
		}

		
		/**
		 * Add supplied command to the list of commands to be executed.
		 * @@param cmd the command to add
		 */
		public void add( Command cmd ) {
			_cc.add( cmd );
		}
	}
	
	/** [semantic element, canonical editpolicy] regisrty map. */
	static Map _registry = new WeakHashMap();
	
	/** ModelServer Listener Identifiers. */	
	private static final String SEMANTIC_FILTER_ID = "SemanticFilterID";//$NON-NLS-1$
	
	/** enable refresh flag. */
	private boolean _enabled = true;
	
	/** flag signalling a refresh request made while the editpolicy was disabled. */
	private boolean _deferredRefresh = false;
	
	/** semantic listener. */
	private Map _listenerFilters;
		
	/** Adds <code>String.class</tt> adaptablity to return a factory hint. */
	protected static final class CanonicalElementAdapter extends EObjectAdapter {
		private String _hint;
		
		/**
		 * constructor
		 * @@param element
		 * @@param hint
		 */
		public CanonicalElementAdapter( EObject element, String hint ) {
			super(element);
			_hint = hint;
		}
		
		/** Adds <code>String.class</tt> adaptablity. */
		public Object getAdapter(Class adapter) { 
			if ( adapter.equals(String.class) ) {
				return _hint;
			}
			return super.getAdapter(adapter);
		}
	}
	
	/** Registier this editpolicy against its semantic host. */
	private void RegisterEditPolicy() {
		EObject semanticHost = getSemanticHost();
		Set set = (Set)_registry.get(semanticHost);
		if ( set == null ) {
			set = new HashSet();
			_registry.put( semanticHost, set );
		}
		set.add(this);
	}
	
	/** Unregisters this editpolicy from the cache. */
	private void UnregisterEditPolicy() {
		EObject semanticHost = null; 

		//
		// 1st - delete unspecified refs
		Set set = (Set)_registry.get(null);
		if ( set != null ) {
			set.remove(this);
			if ( set.isEmpty() ) {
				_registry.remove(semanticHost);
			}
		}
		
		//
		// reverse key lookup since the unregistering an editpolicy
		// typically means that the semantic element has been deleted.
		Iterator keys = _registry.keySet().iterator();
		while ( keys.hasNext() ) {
			EObject key = (EObject)keys.next();
			if ( ((Set)_registry.get(key)).contains(this)) {
				semanticHost = key;
				break;
			}
		}
		
		set = (Set)_registry.get(semanticHost);
		if ( set != null ) {
			set.remove(this);
			if ( set.isEmpty() ) {
				_registry.remove(semanticHost);
			}
		}
	}
	
	/**
	 * Returns the <code>Canonical EditPolicies</code> mapped to the supplied <i>element</i>. 
	 * Canonical EditPolicies are mapped to their {@@link #getSemanticHost()} as
	 * the key.  A single key may have multiple editpolicies registered against it.
	 * @@param element a semantic element
	 * @@return a unmodifiable list of semantic editpolicies listening to the supplied element
	 */
	public static List getRegisteredEditPolicies( EObject element ) {
		List policies = new ArrayList();
		Collection policiesWithSemanticElements = (Collection) _registry.get(element);
		if (policiesWithSemanticElements != null) {
			policies.addAll(policiesWithSemanticElements);
		}
		Collection policiesWithNullSemanticElements = (Collection) _registry.get(null);
		if (policiesWithNullSemanticElements != null) {
			policies.addAll(policiesWithNullSemanticElements);
		}
		return Collections.unmodifiableList(policies);
	}
	
	/**
	 * Returns the <b>enabled </b> <code>Canonical EditPolicies</code> mapped
	 * to the supplied <i>element </i> that are an instance of the supplied
	 * <tt>clazz</tt>. Canonical EditPolicies are mapped to their
	 * {@@link #getSemanticHost()}as the key. A single key may have multiple
	 * editpolicies registered against it.
	 * 
	 * @@param element
	 *            a semantic element
	 * @@param clazz
	 *            a class type
	 * @@return an unmodifiable list of semantic editpolicies listening to the
	 *         supplied element
	 */
	public static List getRegisteredEditPolicies( EObject element, Class clazz ) {
		List registeredPolicies = new ArrayList();
		Iterator ceps = getRegisteredEditPolicies(element).iterator();
		while( ceps.hasNext() ) {
			CanonicalEditPolicy cep = (CanonicalEditPolicy)ceps.next();
			if ( cep.isEnabled() && clazz.isInstance(cep) ) {
				registeredPolicies.add(cep);
			}
		}
		return Collections.unmodifiableList(registeredPolicies);
	}
	
	/** Asserts that the supplied host is an {@@link IGraphicalEditPart} instance. */
	public void setHost(EditPart host) {
		if ( !(host instanceof IGraphicalEditPart) ) {
			throw new IllegalArgumentException();
		}
		super.setHost(host);
	}

	/**
	 * @@return <code>(IGraphicalEditPart)host()</code>.
	 */
	protected final IGraphicalEditPart host() {
		return (IGraphicalEditPart)getHost();
	}

	/**
	 * Return the host's semantic children. <BR>
	 * @@return a list of semantic children.
	 */
	abstract protected List getSemanticChildrenList();
	
	/** 
	 * Returns the default factory hint. 
	 * @@return <code>host().getView().getSemanticType()</code>
	 */
	protected String getDefaultFactoryHint() {
		return ((View)host().getModel()).getType();
	}
	
	/**
	 * Return a factory hint to assign to this element. The supplied
	 * default hint is used if no hint can be found.
	 * @@see #getFactoryHint(IAdaptable)
	 * @@param elementAdapter adapter that adapts to {@@link EObject}.
	 * @@param defaultHint a default factory hint (typically the host's factory hint).
	 * @@return a factory hint.
	 */
	protected String getFactoryHint(
		IAdaptable elementAdapter,
		final String defaultHint) {
		String fh = getFactoryHint(elementAdapter);
		return fh == null ? defaultHint : fh;
	}

	/**
	 * Clients may override this method to return an appropriate factory
	 * hint for the supplied semantic element.  Returning <tt>null</tt> will
	 * set the factory hint to the host editpart's factory hint.
	 * @@see #getFactoryHint(IAdaptable, String)
	 * @@param elementAdapter adapter that adapts to {@@link EObject}.
	 * @@return <tt>null</tt>.
	 */
	protected String getFactoryHint(IAdaptable elementAdapter) {
		return null;
	}
	
	/**
	 * Deletes a list of views.  The views will be deleted <tt>iff</tt> their semantic
	 * element has also been deleted.
	 * @@param views an iterator on a list of views.
	 * @@return <tt>true</tt> if the host editpart should be refreshed; either one one of the supplied
	 * views was deleted or has been reparented.
	 */
	protected final boolean deleteViews( Iterator views ) {
		if ( !isEnabled() ) {
			return false;
		}
		final CompoundCommand cc = new CompoundCommand(DiagramUIMessages.DeleteCommand_Label);
		while (views.hasNext()) {
			View view = (View)views.next();
			if ( shouldDeleteView(view) ) {
				cc.add(getDeleteViewCommand(view));
			}
		} 
		
		boolean doDelete = !cc.isEmpty() && cc.canExecute();
		if ( doDelete ) {
			executeCommand(cc);
		}
		return doDelete;
	}
	
	/**
	 * gets a {@@link Command} to delete the supplied  {@@link View}.
	 * @@param view view to use
	 * @@return command
	 */
	protected Command getDeleteViewCommand(View view) {
        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost()).getEditingDomain();
		return new ICommandProxy(new DeleteCommand(editingDomain, view));
	}

	/**
	 * returns <tt>true</tt> to always delete a view if required.
	 * @@param view to consider
	 * @@return true or false
	 */
	protected boolean shouldDeleteView(View view) {
		return true;
	}
	
	/**
	 * Return a list of all the notation elements mapped to the supplied semantic element.
	 * @@param element to use
	 * @@return list of <code>View</code>s
	 */
	protected List getViewReferers(EObject element) {
		List views = new ArrayList();
		if (element != null) {
			EReference[] features = {NotationPackage.eINSTANCE
					.getView_Element()};
			views.addAll(EMFCoreUtil.getReferencers(element, features));
		}
		return views;
	}

	
	/**
	 * This method tries to locate the position that the view will be
	 * inserted into it's parent.  The position is determined by the position
	 * of the semantic element.  If the semantic element is not found the view
	 * will be appended to it's parent.
	 * 
	 * @@param semanticChild
	 * @@return position where the view should be inserted
	 */
	protected int getViewIndexFor(EObject semanticChild) {
		// The default implementation returns APPEND
		return ViewUtil.APPEND;
	}
	

	/**
	 * Creates a <code>View</code> element for each of the supplied semantic elements.
	 * @@param eObjects list of semantic element
	 * @@return a list of {@@link IAdaptable} that adapt to {@@link View}.
	 */
	protected final List createViews(List eObjects) {
		List descriptors = new ArrayList();
		Iterator elements = eObjects.iterator();
		while( elements.hasNext() ) {
			EObject element = (EObject)elements.next();
			if ( element != null ) {
				CreateViewRequest.ViewDescriptor descriptor = getViewDescriptor(element);
				descriptors.add(descriptor);
			}
		}
		
		if ( !descriptors.isEmpty() ) {
			//
			// create the request
			CreateViewRequest request = getCreateViewRequest(descriptors);
			
			//
			// get the command and execute it.
			Command cmd = getCreateViewCommand(request);
			if ( cmd != null && cmd.canExecute() ) {
				SetViewMutabilityCommand.makeMutable(new EObjectAdapter(host().getNotationView())).execute();
				executeCommand(cmd);
				List adapters = (List)request.getNewObject();
				return adapters;
			}
		}
		return Collections.EMPTY_LIST;
	}
    	
	/**
	 * Executes the supplied command inside an <code>unchecked action</code>
	 * @@param cmd command that can be executed (i.e., cmd.canExecute() == true)
	 */
	protected void executeCommand( final Command cmd ) {
        Map options = null;
        EditPart ep = getHost();
        boolean isActivating = true;
        // use the viewer to determine if we are still initializing the diagram
        // do not use the DiagramEditPart.isActivating since ConnectionEditPart's
        // parent will not be a diagram edit part
        EditPartViewer viewer = ep.getViewer();
        if (viewer instanceof DiagramGraphicalViewer){
            isActivating = ((DiagramGraphicalViewer)viewer).isInitializing();
        }
        
       
        if (isActivating||
            !EditPartUtil.isWriteTransactionInProgress((IGraphicalEditPart)getHost(), false, false))
            options = Collections.singletonMap(Transaction.OPTION_UNPROTECTED,
                Boolean.TRUE);
  
        AbstractEMFOperation operation = new AbstractEMFOperation(
			((IGraphicalEditPart) getHost()).getEditingDomain(),
			StringStatics.BLANK, options) {

			protected IStatus doExecute(IProgressMonitor monitor,
					IAdaptable info)
				throws ExecutionException {

				cmd.execute();

				return Status.OK_STATUS;
			}
		};
		try {
			operation.execute(new NullProgressMonitor(), null);
		} catch (ExecutionException e) {
			Trace.catching(DiagramUIPlugin.getInstance(),
				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"executeCommand", e); //$NON-NLS-1$
			Log.warning(DiagramUIPlugin.getInstance(),
				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
				"executeCommand", e); //$NON-NLS-1$
		}
	}

	/**
	 * Returns a {@@link CreateCommand} for each view descriptor contained
	 * in the supplied request without forwarding create requests to the
	 * host editpart.
	 * @@param request a create request
	 * @@return command create view command(s)
	 */
	protected Command getCreateViewCommand(CreateRequest request) {
        CompositeCommand cc = new CompositeCommand(DiagramUIMessages.AddCommand_Label); 
        Command cmd = host().getCommand(request);
        if (cmd == null) {
            assert request instanceof CreateViewRequest;
            Iterator descriptors = ((CreateViewRequest)request).getViewDescriptors().iterator();
            while (descriptors.hasNext()) {
                CreateViewRequest.ViewDescriptor descriptor =
                    (CreateViewRequest.ViewDescriptor)descriptors.next();
                ICommand createCommand = getCreateViewCommand(descriptor);
                cc.compose(createCommand);
            }
        }else {
            cc.compose(new CommandProxy(cmd));
            Iterator descriptors = ((CreateViewRequest)request).getViewDescriptors().iterator();
            while (descriptors.hasNext()) {
                CreateViewRequest.ViewDescriptor descriptor =
                    (CreateViewRequest.ViewDescriptor)descriptors.next();
                cc.compose(new CommandProxy(SetViewMutabilityCommand.makeMutable(descriptor)));
            }
        }
        return new ICommandProxy(cc.reduce());
	}
	
	/**
	 * @@param descriptor 
	 * @@return ICommand to create a view given a descriptor
	 */
	protected ICommand getCreateViewCommand(CreateViewRequest.ViewDescriptor descriptor) {
        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost()).getEditingDomain();
		CreateCommand createCommand =
            new CreateCommand(editingDomain,
				descriptor, 
				(View)getHost().getModel());
        CompositeCommand cmd = new CompositeCommand(DiagramUIMessages.AddCommand_Label);
        cmd.compose(createCommand);
        cmd.compose(new CommandProxy(SetViewMutabilityCommand.makeMutable(descriptor)));
		return cmd;
	}
	
	/**
	 * Return a create view request.  
	 * @@param descriptors a {@@link CreateViewRequest.ViewDescriptor} list.
	 * @@return a create request
	 */
	protected CreateViewRequest getCreateViewRequest( List descriptors ) {
		return new CreateViewRequest( descriptors );
	}
	
	/**
	 * Return a view descriptor.
	 * @@param elementAdapter semantic element
	 * @@param viewKind type of view to create
	 * @@param hint factory hint
	 * @@param index index
	 * @@return a create <i>non-persisted</i> view descriptor
	 */
	protected CreateViewRequest.ViewDescriptor getViewDescriptor(
		IAdaptable elementAdapter,
		Class viewKind,
		String hint,
		int index) {

		return new CreateViewRequest.ViewDescriptor(
				elementAdapter,
				viewKind,
				hint,
				index, 
				false, 
				host().getDiagramPreferencesHint());
	}

	/**
	 * Convenience method to create a view descriptor.  Will call
	 * {@@link #getViewDescriptor(IAdaptable, Class, String, int)}
	 * @@param element semantic element.
	 * @@return view descriptor
	 */
	protected CreateViewRequest.ViewDescriptor getViewDescriptor( EObject element ) {
		//
		// create the view descritor
		String factoryHint = getDefaultFactoryHint();
		IAdaptable elementAdapter =
			new CanonicalElementAdapter(element, factoryHint);
		
		int pos = getViewIndexFor(element);
		CreateViewRequest.ViewDescriptor descriptor = 
			getViewDescriptor(
				elementAdapter,
				Node.class,
				getFactoryHint(elementAdapter, factoryHint),
				pos);
		return descriptor;
	}
	
	/**
	 * Registers with the model server to receive semantic events targeted to 
	 * the host editpart. By default, this editpolicy will receive events fired
	 * to the semantic element mapped to the host editpart.  Clients wanting to 
	 * listen to another semantic element should override {@@link #getSemanticHost()}
	 * @@see #deactivate()
	 */
	public void activate() {
		EObject semanticHost = getSemanticHost();
		if ( semanticHost != null && !isActive() ) {
			addListenerFilter(SEMANTIC_FILTER_ID, this, semanticHost);
			// add listener to host view (handle case when user changes "visibility" property)
			addListenerFilter("NotationListener_Visibility", //$NON-NLS-1$
							  this,
							  (View)getHost().getModel(),
							  NotationPackage.eINSTANCE.getView_Visible());
			
			Style style = ((View)host().getModel()).getStyle(NotationPackage.eINSTANCE.getDrawerStyle());
			if ( style != null ) {
				addListenerFilter("NotationListener_DrawerStyle", this, style); //$NON-NLS-1$
			}
			style = ((View)host().getModel()).getStyle(NotationPackage.eINSTANCE.getCanonicalStyle());
			if ( style != null ) {
				addListenerFilter("NotationListener_CanonicalStyle", this, style);  //$NON-NLS-1$
			}
			
			refreshOnActivate();
		}
		RegisterEditPolicy();
	}

	/**
	 * Refresh that is called on activate of the editpolicy to ensure that all relevant editparts
	 * can receive canonically created connections.
	 */
	protected void refreshOnActivate() {
		refresh();
	}

	/**
	 * Return <tt>true</tt> if the editpolicy is enabled and its host
	 * is visible; otherwise <tt>false</tt>.
	 * @@return <tt>true</tt>
	 */
	public boolean isEnabled() {
        // if the editing domain is null then there is no point in enabling the edit policy
        // the editing domain could be null because the view is detached or if the host is detached
        if ( TransactionUtil.getEditingDomain((EObject)getHost().getModel())==null){
            return false;
        }
		DrawerStyle dstyle = (DrawerStyle) ((View)host().getModel()).getStyle(NotationPackage.eINSTANCE.getDrawerStyle());
		boolean isCollapsed = dstyle == null ? false : dstyle.isCollapsed();
		
		if ( isCollapsed ) {
			return false;
		}
		
		CanonicalStyle style = getCanonicalStyle();
		boolean enabled = _enabled && ((View)host().getModel()).isVisible();
		
		return style == null 
			? enabled
			: style.isCanonical() && enabled;
	}

	/**
	 * Disables the editpolicy.  While disabled, the editpolicy
	 * will not perform any refreshes.
	 * @@param enable 
	 */
	public void enableRefresh( boolean enable ) {
		_enabled = enable;
		if ( _enabled && _deferredRefresh ) {
			_deferredRefresh = false;
			refresh();
		}
	}
	
	/**
	 * Sets enable(aBoolean) on all the edit policies of the semantic host.
	 * @@param enable
	 */
	public void setEnable( boolean enable ) {
		EObject sHost = getSemanticHost();
		List registeredPolicies = getRegisteredEditPolicies(sHost);

		CanonicalEditPolicy[] policies = new CanonicalEditPolicy[registeredPolicies.size()];
		registeredPolicies.toArray(policies);
		
		for ( int i = 0; i < policies.length; i++ ) {
			policies[i].enableRefresh(enable);
		}
	}
	
	/** 
	 * check is this edit policy is active or not
	 * @@return <tt>true</tt> if the this editpart has already been activated;
	 * otherwise <tt>false</tt>.
	 */
	public final boolean isActive() {
		return _listenerFilters == null 
			? false
			: _listenerFilters.containsKey(SEMANTIC_FILTER_ID);
	}
	
	/**
	 * Return the semantic element to be <i>listened</i> to by this editpolicy.
	 * @@return <code>host().getView().resolveSemanticElement()</code> by default.
	 */
	public EObject getSemanticHost() {
		return ViewUtil.resolveSemanticElement((View)host().getModel()); 
	}
	
	/**
	 * Unregisters all registered model server listeners.
	 * @@see #activate()
	 */
    public void deactivate() {
    	if (_listenerFilters != null) {
    		Map listeners = new HashMap(_listenerFilters);
    		Iterator keys = listeners.keySet().iterator();
    		while (keys.hasNext()) {
    			String id = (String) keys.next();
    			removeListenerFilter(id);
    		}
    	}
    	
		UnregisterEditPolicy();
    }

	
    /**
	 * Adds a listener filter by adding the given listener to a passed notifier.
	 * The supplied <tt>listener</tt> will not be added to there is already a listener
	 * registered against the supplied <tt>filterId</tt>
	 * 
	 * @@param filterId A unique filter id (within the same editpart instance)
	 * @@param listener A listener instance
	 * @@param notifier An element notifer to add the listener to
	 * @@return <tt>true</tt> if the listener was added, otherwise <tt>false</tt>
	 * @@throws NullPointerException if either <tt>filterId</tt> or <tt>listner</tt> parameters are <tt>null</tt>.
	 */
	protected boolean addListenerFilter(
		String filterId,
		NotificationListener listener,
		EObject element) {
		if ( filterId == null || listener == null ) {
			throw new NullPointerException();
		}

		if (element != null) {
			if (_listenerFilters == null)
				_listenerFilters = new HashMap();
			
			if ( !_listenerFilters.containsKey(filterId)) {
				getDiagramEventBroker().addNotificationListener(element,listener);
				_listenerFilters.put(filterId, new Object[] { element, listener });
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Adds a listener filter by adding the given listener to a passed notifier.
	 * The supplied <tt>listener</tt> will not be added to there is already a listener
	 * registered against the supplied <tt>filterId</tt>
	 * 
	 * @@param filterId A unique filter id (within the same editpart instance)
	 * @@param listener A listener instance
	 * @@param notifier An element notifer to add the listener to
	 * @@return <tt>true</tt> if the listener was added, otherwise <tt>false</tt>
	 * @@throws NullPointerException if either <tt>filterId</tt> or <tt>listner</tt> parameters are <tt>null</tt>.
	 */
	protected boolean addListenerFilter(
		String filterId,
		NotificationListener listener,
		EObject element,
		EStructuralFeature feature) {
		if ( filterId == null || listener == null ) {
			throw new NullPointerException();
		}

		if (element != null) {
			if (_listenerFilters == null)
				_listenerFilters = new HashMap();
			
			if ( !_listenerFilters.containsKey(filterId)) {
				getDiagramEventBroker().addNotificationListener(element,feature,listener);
				_listenerFilters.put(filterId, new Object[] { element,feature, listener });
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Removes a listener previously added with the given id
	 * @@param filterId the filter id
	 */
	protected void removeListenerFilter(String filterId) {
		if (_listenerFilters == null)
			return;
		Object[] objects = (Object[]) _listenerFilters.remove(filterId);
		if (objects == null)
			return;
		if (objects.length > 2) {
			getDiagramEventBroker().removeNotificationListener(
				(EObject) objects[0], (EStructuralFeature) objects[1],
				(NotificationListener) objects[2]);
		} else {
			getDiagramEventBroker().removeNotificationListener(
				(EObject) objects[0], (NotificationListener) objects[1]);
		}
	}
	
	/**
	 * Event callback: filters out non IElementEvent events.
	 * @@param event an event fired from the model server.
	 */
	public final void notifyChanged(Notification notification) {
		if ( isHostStillValid()) {
			Object element = notification.getNotifier();
			if ( element == null  ) {
				return;
			}
			
			handleNotificationEvent(notification);
		}
	}
	
	/**
	 * Return <tt>true</tt> if the host is active and its view has not
	 * been deleted; otherwise <tt>false</tt>
	 * @@return true or false
	 */
	protected final boolean isHostStillValid() {
		if (!host().isActive()) {
			return false;
		}

		// is it detached?
		EObject eObject = (EObject) host().getModel();
		if (eObject != null && eObject.eResource() == null
			&& !eObject.eIsProxy()) {
			return false;
		}
		return true;
	}
	
	/**
	 * Handles <code>NotificationEvent</code> and resynchronizes the canonical
	 * container if the event should be handled.
	 * 
	 * @@param event <code>NotificationEvent</code> to handle.
	 */
	protected void handleNotificationEvent(Notification event) {
		
		boolean shouldRefresh = false;
		if ( shouldHandleNotificationEvent(event) ) {
			if ( NotationPackage.eINSTANCE.getCanonicalStyle_Canonical() == event.getFeature() ) {
				CanonicalStyle style = (CanonicalStyle) ((View)host().getModel()).getStyle(NotationPackage.eINSTANCE.getCanonicalStyle());
				if (style != null) {
					setEnable(style.isCanonical());
				}
			}
			shouldRefresh = true;
		}
		
		if (shouldRefresh)
			refresh();
	}
	
	/**
	 * Determines if the the <code>NotificationEvent</code> should be handled / processed
	 * by the editpolicy.
	 * 
	 * @@param event <code>NotificationEvent</code> to check
	 * @@return <code>true</code> if event should be handled, <code>false</code> otherwise.
	 */
	protected boolean shouldHandleNotificationEvent(Notification event) {
	  if ( NotationPackage.eINSTANCE.getDrawerStyle_Collapsed() == event.getFeature() || 
	 	   NotationPackage.eINSTANCE.getCanonicalStyle_Canonical() == event.getFeature() ||
	 	   NotationPackage.eINSTANCE.getView_Visible() == event.getFeature() ||
	 	   NotationPackage.eINSTANCE.getView_PersistedChildren() == event.getFeature()) {
		  return true;
	  }

	  Object element = event.getNotifier();
      if (element instanceof EObject && !(element instanceof View)){
          boolean addOrDelete = (NotificationUtil.isElementAddedToSlot(event) 
                  || NotificationUtil.isElementRemovedFromSlot(event));
          EStructuralFeature feature = getFeatureToSynchronize();
          if (feature!=null){
              if (feature.equals(event.getFeature()) && 
                  (addOrDelete||NotificationUtil.isSlotModified(event))){
                      return true;
              }
              return false;
          }
          Set features = getFeaturesToSynchronize();
          if (features!=null && !features.isEmpty()){
              if (features.contains(event.getFeature())&&
                  (addOrDelete||NotificationUtil.isSlotModified(event))){
                  return true;
              }
              return false;
          }
          
          // just for backward compatibility will not be needed when all clients migrate
          if (addOrDelete){
                  return true;
          }
      }
      return false;      
	}

			
	/**
     * Return the host's model children.
     * @@return list of <code>View</Code>s
     */
    protected List getViewChildren() {
        return getViewChildren((View) host().getModel());
    }

    /**
     * Return the host's model children. This is a recursive method that handles
     * groups.
     * 
     * @@param view
     *            the view to find the children for
     * @@return list of children views with groups removed.
     */
    private List getViewChildren(View view) {
        ArrayList list = new ArrayList();
        for (Iterator iter = view.getChildren().iterator(); iter.hasNext();) {

            Object child = iter.next();
            if (child instanceof Node
                && ViewType.GROUP.equals(((Node) child).getType())) {
                list.addAll(getViewChildren((View) child));
            } else {
                list.add(child);
            }
        }
        return list;
    }

	/**
	 * Resynchronize the canonical container.
	 */
	public final void refresh() {
		try {
			if ( isEnabled() ) {
				// avoid re-entry
				boolean defRefresh = _deferredRefresh;
				_deferredRefresh = false;
				refreshSemantic();
				_deferredRefresh = defRefresh;
			}
			else {
				_deferredRefresh = true;
			}
		}
		catch ( Throwable t ) {
			String eMsg = DiagramUIMessages.CanonicalEditPolicy_refresh_failed_ERROR_;
			Log.error(DiagramUIPlugin.getInstance(), IStatus.WARNING,
					eMsg, t);
		}
	}

	/**
	 * Redirects the call to {@@link #refreshSemanticChildren()}.
	 */
	protected void refreshSemantic() {
		List createdViews = refreshSemanticChildren();
		makeViewsImmutable(createdViews);
	}

	/**
	 * Sets state on views to allow for modification without changing their
	 * non-persisted status.
	 * 
	 * @@param createdViews <code<>List</code> of view adapters that were created during the 
	 * {@@link CanonicalEditPolicy#refreshSemantic()} operation
	 */
	final protected void makeViewsMutable(List createdViews) {
		if (createdViews != null && !createdViews.isEmpty()) {
			List viewAdapters = prepareAdapterList(createdViews);
			executeCommand(SetViewMutabilityCommand.makeMutable(viewAdapters));
		}
	}
	
	/**
	 * Sets views as being immutable, meaning that they are unmodifiable as 
	 * non-persisted views.  Any subsequent change to an immutable view will force 
	 * the view to be persisted.
	 * 
	 * @@param createdViews <code<>List</code> of view adapters that were created during the 
	 * {@@link CanonicalEditPolicy#refreshSemantic()} operation
	 */
	final protected void makeViewsImmutable(List createdViews) {
		if (createdViews != null && !createdViews.isEmpty()) {
			addListenersToContainers(createdViews);
			
			List viewAdapters = prepareAdapterList(createdViews);
			Command immutable = SetViewMutabilityCommand.makeImmutable(viewAdapters);
			AsyncCommand ac = new AsyncCommand(immutable);
			ac.execute();
		}
	}

	private void addListenersToContainers(List createdViews) {
		UniqueEList list = new UniqueEList();
		ListIterator li = createdViews.listIterator();
		while (li.hasNext()) {
			Object obj = li.next();
			if (obj instanceof IAdaptable) {
				View view = (View)((IAdaptable)obj).getAdapter(View.class);
				if (view != null)
					list.add(view.eContainer());
			}
		}
		
		ListIterator liContainers = list.listIterator();
		while (liContainers.hasNext()) {
			View containerView = (View)liContainers.next();
			addListenerFilter("NotationListener_Container_" + containerView.getClass().getName() + '@@' + Integer.toHexString(containerView.hashCode()), //$NON-NLS-1$
				  this,
				  containerView,
				  NotationPackage.eINSTANCE.getView_PersistedChildren()); 
		}
	}
	
	private List prepareAdapterList(List createdViews) {
		List viewAdapters = new ArrayList();
		viewAdapters.add( host() );
		ListIterator li = createdViews.listIterator();
		while (li.hasNext()) {
			Object obj = li.next();
			if (obj != null) {
				if (!(obj instanceof IAdaptable) && obj instanceof EObject)
					viewAdapters.add(new EObjectAdapter((EObject)obj));
				else
					viewAdapters.add(obj);
			}
		}
		return viewAdapters;
	}
	
	/**
	 * Updates the set of children views so that it
	 * is in sync with the semantic children. This method is called 
	 * in response to notification from the model.
	 * <P>
	 * The update is performed by comparing the exising views with the set of
	 * semantic children returned from {@@link #getViewChildren()}. Views whose
	 * semantic element no longer exists are {@@link #deleteViews(Iterator) removed}. 
	 * New semantic children have their View {@@link  #createViews(List)
	 * created}.  Subclasses must override <code>getSemanticChildren()</code>.
	 * <P>
	 * Unlike <code>AbstractEditPart#refreshChildren()</code>, this refresh will not
	 * reorder the view list to ensure both it and the semantic children are
	 * in the same order since it is possible that this edit policy will handle
	 * a specifc subset of the host's views.  
	 * <P>
	 * The host is refreshed if a view has created or deleted as a result of this
	 * refresh.
	 * 
	 * @@return <code>List</code> of new <code>View</code> objects that were created as a result of 
	 * the synchronization
	 */
	protected final List refreshSemanticChildren() {
		
		// Don't try to refresh children if the semantic element
		// cannot be resolved.
		if (resolveSemanticElement() == null) {
			return Collections.EMPTY_LIST;		
		}
		
		//
		// current views
		List viewChildren = getViewChildren();
		List semanticChildren = new ArrayList(getSemanticChildrenList());

		List orphaned = cleanCanonicalSemanticChildren(viewChildren, semanticChildren);
		boolean changed = false;
		//
		// delete all the remaining oprphaned views
		if ( !orphaned.isEmpty() ) {
			changed = deleteViews(orphaned.iterator());
		}
		
		//
		// create a view for each remaining semantic element.
		List createdViews = Collections.EMPTY_LIST;
		if ( !semanticChildren.isEmpty() ) {
			createdViews = createViews( semanticChildren );
			
			for ( int i = 0; i < createdViews.size(); i++ ) {
				View createdView = (View)((IAdaptable)createdViews.get(i)).getAdapter(View.class);
				if (createdView == null) {
					String eMsg =
						NLS
						.bind(
							DiagramUIMessages.CanonicalEditPolicy_create_view_failed_ERROR_,
							semanticChildren.get(i));
					IllegalStateException ise =
						new IllegalStateException(eMsg);
					Log.error(
						DiagramUIPlugin.getInstance(),
						IStatus.ERROR,
						eMsg,
						ise);
					throw ise;
				}
			}
		}
		
		if (changed || createdViews.size() > 0)
			postProcessRefreshSemantic(createdViews);
		

		return createdViews;
	}

	/**
	 * Synchronizes the semanticChildren the viewChildren to discover if any of the semanticChildren
	 * don't have a corresponding view.  Any <code>semanticChildren</code> that do have a view are
	 * removed from the list.
	 * 
	 * @@param viewChildren <code>List</code> of <code>View</code> elements that already exist in the container.
	 * @@param semanticChildren <code>List</code> of semantic elements that are candidates for synchronization
	 * @@return <code>List</code> of orphans views that should be deleted from the container.
	 */
	final protected List cleanCanonicalSemanticChildren(Collection viewChildren, Collection semanticChildren) {
		View viewChild;
		EObject semanticChild;
		Iterator viewChildrenIT = viewChildren.iterator();
		List orphaned = new ArrayList();
		Map viewToSemanticMap = new HashMap();
		while( viewChildrenIT.hasNext() ) {
			viewChild = (View)viewChildrenIT.next();
			semanticChild = viewChild.getElement();
			if (!isOrphaned(semanticChildren, viewChild)) {
				semanticChildren.remove(semanticChild);
				viewToSemanticMap.put(semanticChild, viewChild);
			}
			else {
				orphaned.add(viewChild);
			}
			
			View viewInMap = (View)viewToSemanticMap.get(semanticChild);
			if (viewInMap != null && !viewChild.equals(viewInMap)) { 
				if (viewInMap.isMutable()) {
					orphaned.remove(viewChild);
					orphaned.add(viewInMap);
					viewToSemanticMap.put(semanticChild, viewChild);
				}
			}
		}
		return orphaned;
	}

    /**
     * Decide if the passed view is orphened or not
     * 
     * @@param semanticChildren
     *            semantic children to check againest
     * @@param view
     *            the view that shoudlbe checked
     * @@return true if orphaned other wise false
     */
    protected boolean isOrphaned(Collection semanticChildren, View view) {
        return !semanticChildren.contains(view.getElement());
    }
	
	/**
	 * Allow for post processing of the refresh semantic to set the view mutable
	 * state and allow subclasses to add functionality.
	 * 
	 * @@param viewDescriptors <code>List</code> of IAdaptable that adapt to <code>View</code>
	 */
	protected void postProcessRefreshSemantic(List viewDescriptors) {
		// need to refresh host to create editparts so that dependent canonical editpolicies can synchronize as well.
		getHost().refresh(); 
	}
	
	/**
	 * Convenience method to return the host's semantic element.
	 * Same as calling <code>host().getView().resolveSemanticElement();</code>
	 * @@return an {@@link EObject}
	 */
	protected final EObject resolveSemanticElement() {
		return ViewUtil.resolveSemanticElement((View)host().getModel());
	}

	/**
	 * gets the canonical style that may be installed on the host shape compartment view.
	 * @@return <code>CanonicalStyle</code>
	 */
	protected CanonicalStyle getCanonicalStyle() {
		return (CanonicalStyle) ((View)host().getModel()).getStyle(NotationPackage.eINSTANCE.getCanonicalStyle());
	}	
	
    /**
     * Gets the diagram event broker from the editing domain.
     * 
     * @@return the diagram event broker
     */
    private DiagramEventBroker getDiagramEventBroker() {
        TransactionalEditingDomain theEditingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        if (theEditingDomain != null) {
            return DiagramEventBroker.getInstance(theEditingDomain);
        }
        return null;
    }

	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.parts.NotificationForEditPartsListener#getViewer()
	 */
	final public EditPartViewer getViewer() {
		return getHost().getViewer();
	}
    
    /**
     * This method should be overridden by sub classes to provide the features the canonical edit policy
     * will use to synchronize the views with the semantic element
     * This method should be overridden only if the edit policy synchronizes more than one EStructuralFeature  
     * @@return Set of EStructuralFeature features
     */

    protected Set getFeaturesToSynchronize(){
        return Collections.EMPTY_SET;
    }
    
    /**
     * This method should be overridden by sub classes to provide the feature the canonical edit policy
     * will use to synchronize the views with the semantic element
     * This method should be overridden only if the edit policy synchronizes only one EStructuralFeature  
     * @@return  EStructuralFeature 
     */
    protected EStructuralFeature getFeatureToSynchronize(){
        return null;
    }
    
    /**
     * Determines if this editpolicy would create a view for the supplied 
     * semantic element.  The default implementation will return <tt>true</tt>
     * if the supplied <tt>eObject</tt> is contained in {@@link #getSemanticChildrenList()}.
     * @@param eObject a semantic element
     * @@return <tt>true</tt> if this policy would create a view; 
     * <tt>false</tt> otherwise.
     */
    public boolean canCreate( EObject eObject ) { 
        return eObject == null 
            ? false
            : getSemanticChildrenList().contains(eObject);
    }

}
@


1.30
log
@[212195] gmf-head mhanner 080128 [DeleteFromSupport] Allow Delete from Diagram for elements in a container
@
text
@d1055 1
a1055 1
			addListenerFilter("NotationListener_Container" + containerView.toString(), //$NON-NLS-1$
@


1.30.2.1
log
@[241252] gmf_R2_1_maintenance mgobeil 080903 addListenersToContainers of CanonicalEditPolicy wrongly uses toString method to generate IDs
@
text
@d1055 1
a1055 1
			addListenerFilter("NotationListener_Container_" + containerView.getClass().getName() + '@@' + Integer.toHexString(containerView.hashCode()), //$NON-NLS-1$
@


1.29
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2007 IBM Corporation and others.
d1275 15
@


1.28
log
@[186630] gmf_head mmostafa 070511 Canonical edit policy installed on connections never use write transaction
@
text
@d57 1
d946 29
a974 7
	 * Return the host's model children.
	 * @@return list of <code>View</Code>s
	 */
	protected List getViewChildren() {
		return new ArrayList(((View)host().getModel()).getChildren());
		
	}
@


1.28.2.1
log
@[111892] gmf_head crevells 070518 First milestone of group/ungroup support (painting issues when grouping shapes with border items)
@
text
@a56 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewType;
d945 7
a951 30
     * Return the host's model children.
     * 
     * @@return list of <code>View</Code>s
     */
    protected List getViewChildren() {
        return getViewChildren((View) host().getModel());
    }

    /**
     * Return the host's model children. This is a recursive method that handles
     * groups.
     * 
     * @@param view
     *            the view to find the children for
     * @@return list of children views with groups removed.
     */
    private List getViewChildren(View view) {
        ArrayList list = new ArrayList();
        for (Iterator iter = view.getChildren().iterator(); iter.hasNext();) {

            Object child = iter.next();
            if (child instanceof Node
                && ViewType.GROUP.equals(((Node) child).getType())) {
                list.addAll(getViewChildren((View) child));
            } else {
                list.add(child);
            }
        }
        return list;
    }
d954 2
a955 2
     * Resynchronize the canonical container.
     */
@


1.27
log
@[173706] gmf_head mmostafa 070215 Canonical Edit Policy , does not work with Single feature
@
text
@a61 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
d67 1
d484 7
a490 2
        while (ep !=null && !(ep instanceof DiagramEditPart)){
            ep = ep.getParent();
d493 2
a494 2
        if ( ep==null ||
            (ep!=null && ((DiagramEditPart)ep).isActivatingDiagram())||
@


1.26
log
@[173706] gmf_head mmostafa 070215 Canonical Edit Policy , does not work with Single feature
@
text
@d922 1
a922 1
          if (features!=null){
d1235 1
a1235 1
        return null;
@


1.25
log
@[170328]  gmf_head mmostafa 070112 Canonical Connection Edit Policy does not refresh correctly
@
text
@d98 1
a98 1
 * @@author mhanner
d910 26
a935 4
	  return (element instanceof EObject 
			  && !(element instanceof View) 
	         && (NotificationUtil.isElementAddedToSlot(event) 
	            || NotificationUtil.isElementRemovedFromSlot(event)));
d1227 10
d1238 9
@


1.24
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
d1122 1
a1122 1
			if (semanticChildren.contains(semanticChild)) {
d1141 13
@


1.23
log
@bugzilla 143198 gmf-head sshaw 060616 SWTExceptions occurring when handling notifications from worker thread transactions
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2005,  IBM Corporation and others.
d40 1
a631 3
			
			// listen to persisted children to eliminate duplicate views.
			addListenerFilter(SEMANTIC_FILTER_ID, this, semanticHost);
d666 5
@


1.23.2.1
log
@[148929] gmf_R1_0_maintenace mmostafa 060728  CanonicalEditPolicy should include whether its host's view is detached as part of its enablement criteria
@
text
@a667 7
        // if the editing domain is null then there is no point in enabling the edit policy
        // the editing domain could be null because the view is detached or if the host is detached
        EditPart host = getHost();
        if ( host.getRoot()==null ||
            (host instanceof IGraphicalEditPart &&  ((IGraphicalEditPart)host).getEditingDomain()==null)){
            return false;
        }
@


1.23.2.2
log
@[148929] gmf_R1_0_maintenace mmostafa 060728  CanonicalEditPolicy should include whether its host's view is detached as part of its enablement criteria
@
text
@a39 1
import org.eclipse.emf.transaction.util.TransactionUtil;
d670 3
a672 1
        if ( TransactionUtil.getEditingDomain((EObject)getHost().getModel())==null){
@


1.23.2.3
log
@[155079] gmf_R1_0_maintenance mmostafa  060824  canonical edit policy tries to add a itself as a listener to the same element twice
@
text
@d632 3
@


1.23.2.4
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@


1.22
log
@[139856] gmf_head anthonyh 060614 EtoolsProxyCommand should be renamed to ICommandProxy
@
text
@a65 1
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.NotificationForEditPartsListener;
d100 1
a100 1
implements NotificationForEditPartsListener {
@


1.21
log
@bugzilla 140020 gmf-head sshaw 060602 Deadlock in PopupBarEditPolicy$PopupBarLabelHandle
@
text
@d59 1
a59 1
import org.eclipse.gmf.runtime.diagram.ui.commands.EtoolsProxyCommand;
d168 1
a168 1
			_cc.add( new EtoolsProxyCommand(cmd));
d400 1
a400 1
		return new EtoolsProxyCommand(new DeleteCommand(editingDomain, view));
d547 1
a547 1
        return new EtoolsProxyCommand(cc.reduce());
@


1.20
log
@bugzilla 142803 gmf-head sshaw 060531 Illegal Asynchronous Access to ResourceSetChangeEvent in DiagramEventBrokerThreadSafe
@
text
@d490 1
a490 1
            !EditPartUtil.isWriteTransactionInProgress((IGraphicalEditPart)getHost(), false))
@


1.19
log
@Bugzilla#109422 gmf_head cmahoney 060509 Removing deprecated classes from GMF diagram components
@
text
@a39 2
import org.eclipse.emf.transaction.impl.InternalTransaction;
import org.eclipse.emf.transaction.impl.InternalTransactionalEditingDomain;
d42 1
d66 1
d69 1
d101 1
a101 1
implements NotificationListener {
d490 1
a490 1
            !isWriteTransactionInProgress())
d1181 9
a1190 22
    /**
     * Checks if the current active transaction is a Write transaction or not
     * unprotected transaction are not considered write transaction
     * 
     * @@return true if the current active transaction is a write transaction 
     */
    private boolean isWriteTransactionInProgress() {
        TransactionalEditingDomain theEditingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        if (theEditingDomain instanceof InternalTransactionalEditingDomain){
            InternalTransactionalEditingDomain internalEditingDomain = 
                (InternalTransactionalEditingDomain)theEditingDomain;
            InternalTransaction transaction = internalEditingDomain.getActiveTransaction();
            if (transaction!=null && !transaction.isReadOnly()){
                Object unprotectedMode = transaction.getOptions().get(Transaction.OPTION_UNPROTECTED); 
                if (unprotectedMode == null ||
                    unprotectedMode == Boolean.FALSE)
                return true;
            }
        }
        return false;
    }
@


1.18
log
@bugzilla 135968 gmf-head mmostafa 060427 Thread safety of EditPart handleNotification
@
text
@d143 4
a146 4
                public void run() {
                    AsyncCommand.this.doExecute();
                }
            } );
a866 24

	/** 
	 * Will invoke {@@link #refreshSemantic()} if
	 * {@@link #shouldHandleSemanticEvent(NotificationEvent)} returns <tt>true</tt>.
	 * 
	 * @@param event a semantic event.
	 * @@deprecated use {@@link CanonicalEditPolicy#handleNotificationEvent} instead
	 */
	protected void handleSemanticEvent(Notification event) {
		refresh();
	}
		
	/**
	 * Return <tt>true</tt> is the event is triggered by adding to or
	 * removing from one of element's slots.
	 * 
	 * @@param event a semantic event
	 * @@return <tt>true</tt> if {@@link #refreshSemantic()} should be invoked;
	 * otherwise <tt>false</tt>.
	 * @@deprecated use {@@link CanonicalEditPolicy#shouldHandleNotificationEvent} instead
	 */
	protected boolean shouldHandleSemanticEvent(Notification event) {
		return NotificationUtil.isElementAddedToSlot(event) || NotificationUtil.isElementRemovedFromSlot(event);
	}
a886 7
		// This can be removed when all clients have migrated
		// to handleNotificationEvent
		if (shouldHandleSemanticEvent(event)) {
			handleSemanticEvent(event);
			return;
		}
		
@


1.17
log
@bugzilla 138064 gmf-head mmostafa 060421 Redo is broken on canonically created elements
@
text
@d78 1
a78 1
import org.eclipse.swt.widgets.Display;
d140 7
a146 5
				Display.getCurrent().asyncExec( new Runnable() {
					public void run() {
						AsyncCommand.this.doExecute();
					}
				} );
@


1.16
log
@bugzilla 128977 gmf-head mmostafa 060309 Adopt transaction API in diagram event broker API and CanonicalEditPolicy API
@
text
@d40 2
d62 1
d479 13
a491 4
		Map options = Collections.singletonMap(Transaction.OPTION_UNPROTECTED,
			Boolean.TRUE);

		AbstractEMFOperation operation = new AbstractEMFOperation(
d1209 23
@


1.15
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d56 1
d438 1
a438 1
	 * Creates a view facade element for each of the supplied semantic elements.
a464 1
				makeViewsMutable(adapters);
d470 1
a470 1
		
a501 2
		
		//getHost().refresh();
d512 21
a532 18
		Command cmd = host().getCommand(request);
		if (cmd == null) {
			assert request instanceof CreateViewRequest;
			CompositeCommand cc = new CompositeCommand(DiagramUIMessages.AddCommand_Label);
			Iterator descriptors = ((CreateViewRequest)request).getViewDescriptors().iterator();

			while (descriptors.hasNext()) {
				CreateViewRequest.ViewDescriptor descriptor =
					(CreateViewRequest.ViewDescriptor)descriptors.next();

				ICommand createCommand = getCreateViewCommand(descriptor);

				cc.compose(createCommand);
			}
			cmd = new EtoolsProxyCommand(cc.reduce());
		}
		
		return cmd;
d545 4
a548 1
		return createCommand;
@


1.14
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d27 1
d29 1
d31 2
d38 1
d40 1
d49 2
a51 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
d60 1
d62 1
d65 1
a65 3
import org.eclipse.gmf.runtime.emf.core.edit.MObjectState;
import org.eclipse.gmf.runtime.emf.core.edit.MRunOption;
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
a66 1
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
d415 1
a415 1
			views.addAll(EObjectUtil.getReferencers(element, features));
d476 14
a489 6
		int options = MRunOption.UNCHECKED /*| MRunOption.SILENT*/;
		MEditingDomainGetter.getMEditingDomain((View)getHost().getModel()).runWithOptions(new MRunnable() {
		//MEditingDomainGetter.getMEditingDomain((View)getHost().getModel()).runAsUnchecked( new MRunnable() {
			public Object run() { 
				cmd.execute(); 
				return null;
d491 12
a502 1
		},options);
d534 5
a538 5
    /**
     * @@param descriptor 
     * @@return ICommand to create a view given a descriptor
     */
    protected ICommand getCreateViewCommand(CreateViewRequest.ViewDescriptor descriptor) {
d540 1
a540 1
        CreateCommand createCommand =
d542 4
a545 4
                descriptor, 
                (View)getHost().getModel());
        return createCommand;
    }
d755 1
a755 1
				DiagramEventBroker.getInstance().addNotificationListener(element,listener);
d788 1
a788 1
				DiagramEventBroker.getInstance().addNotificationListener(element,feature,listener);
d806 7
a812 6
		if (objects.length>2){
			DiagramEventBroker.getInstance().removeNotificationListener(
				(EObject)objects[0],(EStructuralFeature)objects[1],(NotificationListener) objects[2]);
		}else {
			DiagramEventBroker.getInstance().removeNotificationListener(
					(EObject)objects[0],(NotificationListener) objects[1]);
d837 11
a847 1
		return host().isActive() && !EObjectUtil.getState((EObject)host().getModel()).equals(MObjectState.DETACHED);
d1178 15
a1192 1
	}				
@


1.13
log
@bugzilla 117592 gmf-head mmostafa 060207 Eroneous references to xtools in diagram plugins
@
text
@d34 1
d386 2
a387 1
		return new EtoolsProxyCommand(new DeleteCommand(view));
d503 1
a503 1
			cmd = new EtoolsProxyCommand(cc.unwrap());
d509 12
a520 11
	/**
	 * @@param descriptor 
	 * @@return ICommand to create a view given a descriptor
	 */
	protected ICommand getCreateViewCommand(CreateViewRequest.ViewDescriptor descriptor) {
		CreateCommand createCommand =
			new CreateCommand(
				descriptor, 
				(View)getHost().getModel());
		return createCommand;
	}
@


1.12
log
@Bugzilla#123313 gmf_head cmahoney 060120 Making DiagramUIPlugin, DiagramUIStatusCodes, and DiagramUIDebugOptions internal
@
text
@a313 15
	 * Sample useage:<BR>
	 * Composite State (Shape): <br>
	 * <pre>
	 *		IUML2State state =  (IUML2State)resolveSemanticElement() 
	 *      return state == null 
	 *			? Collections.EMPTY_LIST
	 *			: state.getRegions();
	 * </pre><BR>
	 * Region (ShapeCompartment): <BR>
	 *		IUML2Region regions = (IUML2Region)resolveSemanticElement();
	 *		return regions == null 
	 *			? Collections.EMPTY_LIST
	 *			: regions.getSubvertices();
	 * </pre><BR>
	 * 
@


1.11
log
@bugzilla 118836 gmf-head sshaw 051207 CanonicalConnectionEditPolicy should delete orphans before creating new ones
@
text
@a47 1
import org.eclipse.gmf.runtime.diagram.ui.DiagramUIPlugin;
d52 1
@


1.10
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d607 1
a607 1
							  NotationPackage.eINSTANCE.getView_Visible());//$NON-NLS-1$
d1050 7
a1056 1

a1082 7
		boolean changed = false;
		//
		// delete all the remaining oprphaned views
		if ( !orphaned.isEmpty() ) {
			changed = deleteViews(orphaned.iterator());
		}
		
@


1.9
log
@ bugzilla 114992  gmf-head sshaw 051104 Connectors not showing up on diagram open
@
text
@a14 1
import java.text.MessageFormat;
d44 1
a46 1
import org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker;
d53 1
a53 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d66 1
d379 1
a379 1
		final CompoundCommand cc = new CompoundCommand(DiagramResourceManager.getI18NString("DeleteCommand.Label"));//$NON-NLS-1$
d505 1
a505 1
			CompositeCommand cc = new CompositeCommand(DiagramResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
d929 1
a929 1
			String eMsg = DiagramResourceManager	.getI18NString("CanonicalEditPolicy.refresh.failed_ERROR_");//$NON-NLS-1$
d1061 4
a1064 4
						MessageFormat.format(
							DiagramResourceManager.getI18NString(
							"CanonicalEditPolicy.create.view.failed_ERROR_"),//$NON-NLS-1$
							new Object[] { semanticChildren.get(i)});
@


1.8
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d618 1
a618 1
			refresh();
d624 8
@


1.7
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d47 1
a47 1
import org.eclipse.gmf.runtime.diagram.core.listener.PresentationListener;
d54 1
a54 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d379 1
a379 1
		final CompoundCommand cc = new CompoundCommand(PresentationResourceManager.getI18NString("DeleteCommand.Label"));//$NON-NLS-1$
d505 1
a505 1
			CompositeCommand cc = new CompositeCommand(PresentationResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
d734 1
a734 1
				PresentationListener.getInstance().addNotificationListener(element,listener);
d767 1
a767 1
				PresentationListener.getInstance().addNotificationListener(element,feature,listener);
d786 1
a786 1
			PresentationListener.getInstance().removeNotificationListener(
d789 1
a789 1
			PresentationListener.getInstance().removeNotificationListener(
d921 1
a921 1
			String eMsg = PresentationResourceManager	.getI18NString("CanonicalEditPolicy.refresh.failed_ERROR_");//$NON-NLS-1$
d1054 1
a1054 1
							PresentationResourceManager.getI18NString(
@


1.6
log
@bugzilla 109407 gmf-head sshaw 050913 CanonicalEditPolicy hierarchy consolidation
@
text
@a14 2
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
d30 1
d45 2
a46 1
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationEvent;
d57 1
d89 1
a89 1
implements PropertyChangeListener {
d483 3
a485 1
		MEditingDomainGetter.getMEditingDomain((View)getHost().getModel()).runAsUnchecked( new MRunnable() {
d490 2
a491 1
		});
d723 1
a723 1
		PropertyChangeListener listener,
d734 1
a734 1
				PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d755 1
a755 1
		PropertyChangeListener listener,
d767 1
a767 1
				PresentationListener.getInstance().addPropertyChangeListener(element,feature,listener);
d786 2
a787 2
			PresentationListener.getInstance().removePropertyChangeListener(
				(EObject)objects[0],(EStructuralFeature)objects[1],(PropertyChangeListener) objects[2]);
d789 2
a790 2
			PresentationListener.getInstance().removePropertyChangeListener(
					(EObject)objects[0],(PropertyChangeListener) objects[1]);
d798 3
a800 4
	public final void propertyChange(PropertyChangeEvent event) {
		if ( isHostStillValid() && event instanceof NotificationEvent ) {
			NotificationEvent ne = (NotificationEvent)event;
			EObject element = ne.getElement();
d805 1
a805 1
			handleNotificationEvent(ne);
d825 2
a826 4
	protected void handleSemanticEvent(NotificationEvent event) {
		if ( shouldHandleSemanticEvent(event) ) {
			refresh();
		}
d838 2
a839 2
	protected boolean shouldHandleSemanticEvent(NotificationEvent event) {
		return event.isElementAddedToSlot() || event.isElementRemovedFromSlot();
d848 1
a848 1
	protected void handleNotificationEvent(NotificationEvent event) {
d879 1
a879 1
	protected boolean shouldHandleNotificationEvent( NotificationEvent event) {
d887 5
a891 4
	  EObject element = event.getElement();
	  return (!(element instanceof View) 
	         && (event.isElementAddedToSlot() 
	            || event.isElementRemovedFromSlot()));
@


1.5
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d32 1
a47 1
import org.eclipse.gmf.runtime.diagram.core.listener.PropertyChangeNotifier;
a52 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.ConnectionEditPart;
d60 2
d64 1
a65 1
import org.eclipse.jface.util.Assert;
d91 1
a91 1
	public static class AsyncCommand extends Command {
d182 1
a182 1
	public static final class CanonicalElementAdapter extends EObjectAdapter {
d498 9
a506 3
		Assert.isTrue( request instanceof CreateViewRequest);
		CompositeCommand cc = new CompositeCommand(PresentationResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
		Iterator descriptors = ((CreateViewRequest)request).getViewDescriptors().iterator();
d508 1
a508 3
		while (descriptors.hasNext()) {
			CreateViewRequest.ViewDescriptor descriptor =
				(CreateViewRequest.ViewDescriptor)descriptors.next();
d510 3
a512 3
			ICommand createCommand = getCreateViewCommand(descriptor);

			cc.compose(createCommand);
d514 2
a515 2
		return new EtoolsProxyCommand(cc.unwrap());

d517 1
d529 1
a529 1

d596 3
d605 9
a618 1

d625 13
a637 1
		return _enabled && ((View)host().getModel()).isVisible();
d701 1
a701 2
    	removeListenerFilter("NotationListener_Visibility");//$NON-NLS-1$
		
a703 21
	
    /**
	 * Adds a listener filter by adding the given listener to a passed notifier.
	 * The supplied <tt>listener</tt> will not be added to there is already a listener
	 * registered against the supplied <tt>filterId</tt>
	 * 
	 * @@param filterId A unique filter id (within the same editpart instance)
	 * @@param listener A listener instance
	 * @@param notifier An element notifer to add the listener to
	 * @@return <tt>true</tt> if the listener was added, otherwise <tt>false</tt>
	 * @@throws NullPointerException if either <tt>filterId</tt> or <tt>listner</tt> parameters are <tt>null</tt>.
	 * @@deprecated use {@@link CanonicalEditPolicy#addListenerFilter(String, PropertyChangeListener, EObject)} or
	 * {@@link CanonicalEditPolicy#addListenerFilter(String, PropertyChangeListener, EObject,EStructuralFeature )}
	 */
	protected boolean addListenerFilter(
		String filterId,
		PropertyChangeListener listener,
		PropertyChangeNotifier notifier) {
		if ( filterId == null || listener == null ) {
			throw new NullPointerException();
		}
a704 12
		if (notifier != null) {
			if (_listenerFilters == null)
				_listenerFilters = new HashMap();
			
			if ( !_listenerFilters.containsKey(filterId)) {
				notifier.addPropertyChangeListener(listener);
				_listenerFilters.put(filterId, new Object[] { notifier, listener });
				return true;
			}
		}
		return false;
	}
d785 1
a785 5
			if (objects[0] instanceof PropertyChangeNotifier){
				((PropertyChangeNotifier) objects[0]).removePropertyChangeListener(
					(PropertyChangeListener) objects[1]);
			} else{
				PresentationListener.getInstance().removePropertyChangeListener(
a786 1
			}
a787 1
		
d840 1
a840 1
		
d851 6
d870 1
a870 1

d879 4
a882 1
	  if ( NotationPackage.eINSTANCE.getView_Visible() == event.getFeature() ) {
d957 2
d965 22
d1095 1
d1099 1
a1099 1
			if (semanticChildren.contains(semanticChild) ) {
d1101 1
d1106 9
d1137 8
@


1.4
log
@Bugzilla109092 : gmf_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004, 2005, All Rights Reserved.               |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.3
log
@Bugzilla109092 : rmp_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d51 1
d685 2
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d32 1
a37 3
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.widgets.Display;

d46 1
a53 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d61 2
d586 1
a586 2
			addListenerFilter(SEMANTIC_FILTER_ID, this, PresentationListener
					.getNotifier(semanticHost));
d588 4
a591 1
			addListenerFilter("NotationListener_Visibility", this, PresentationListener.getNotifier(((View)getHost().getModel()),NotationPackage.eINSTANCE.getView_Visible()));//$NON-NLS-1$
d674 1
a674 1
	/**
d706 65
d781 13
a793 2
		((PropertyChangeNotifier) objects[0]).removePropertyChangeListener(
			(PropertyChangeListener) objects[1]);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d60 3
a62 3
import com.ibm.xtools.notation.Node;
import com.ibm.xtools.notation.NotationPackage;
import com.ibm.xtools.notation.View;
@

