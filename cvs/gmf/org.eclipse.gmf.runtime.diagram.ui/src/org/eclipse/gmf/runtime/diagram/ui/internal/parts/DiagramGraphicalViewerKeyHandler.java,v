head	1.6;
access;
symbols
	v20081023-2107:1.6
	v20081022-1925:1.6
	v20081022-1005:1.6
	v20081020-0700:1.6
	v20080917-1925:1.6
	v20080916-2008:1.6
	v20080911-1728:1.6
	v20080911-1506:1.6
	v20080910-1520:1.6
	v20080910-1510:1.6
	v20080903-1520:1.6
	v20080903-1510:1.6
	v20080813-1510:1.6
	v20080811-1546:1.6
	v20080731-1520:1.6
	v20080725-1738:1.6
	v20080723-2246:1.6
	v20080723-2232:1.6
	v20080723-1700:1.6
	v20080722-1827:1.6
	v20080718-1700:1.6
	v20080718-1731:1.6
	v20080716-1600:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.6.0.2
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080610-1132:1.6
	v20080603-1553:1.6
	v20080527-1255:1.6
	v20080527-1151:1.4
	v20080516-1748:1.6
	v20080516-1143:1.6
	v20080512-1200:1.6
	v20080503-1740:1.6
	v20080501-2127:1.4
	v20080501-1739:1.6
	m20080429-1543:1.4
	v20080425-1959:1.6
	v20080417-1610:1.6
	v20080407-2250:1.6
	v20080407-0930:1.6
	v20080404-1111:1.6
	v20080328-1605:1.6
	v20080322-0000:1.6
	v20080222-1200:1.6
	v20080201-2010:1.6
	v20080201-0201:1.4
	v20080118-1129:1.4
	v20080114-2222:1.4
	v20080114-1111:1.5
	v20080107-1111:1.4
	v20071222-1111:1.4
	v20071214-1111:1.4
	v20071130-1111:1.4
	v20071124-0000:1.4
	v20071112-0000:1.4
	v20071108-0000:1.4
	v20071003-0000:1.4
	v20070915-0000:1.4
	v20070903-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.4
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.4
	v20070614-1400:1.4
	v20070608-1300:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070525-1500:1.4
	v20070518-1300:1.4
	bugzilla111892_group_support:1.4.0.2
	Root_bugzilla111892_group_support:1.4
	v20070504-1000:1.4
	v20070420-1000:1.4
	v20070413-1300:1.4
	v20070330-1300:1.4
	v20060330-1300:1.4
	v20070322-1100:1.4
	v20060316-0600:1.4
	v20070221-1500:1.4
	v20070208-1800:1.4
	v20070202-0200:1.3.2.1
	v20070119-1200:1.3.2.1
	v20070111-0800:1.3.2.1
	v20070105-1200:1.3.2.1
	v20070103-0300:1.4
	M4_20:1.4
	v20061218-1500:1.3.2.1
	v20061218-1200:1.4
	v20061214-0000:1.4
	M3_20:1.4
	v20061117-0800:1.4
	v20061027-1200:1.3.2.1
	v20061013-1330:1.4
	v20061012-1100:1.3.2.1
	v20060925-1700:1.3.2.1
	v20060919-0800:1.3.2.1
	v20060907-1100:1.3
	M1_20:1.3
	v20060831-1500:1.3
	v20060824-1600:1.3
	v20060817-1500:1.3
	v20060810-1700:1.3
	v20060803-1200:1.3
	v20060728-0500:1.3
	v20060721-1130:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1400:1.3
	v20060616-1200:1.3
	v20060609-1400:1.3
	v20060531-1730:1.3
	v20060530-1930:1.3
	v20060526-1200:1.3
	v20060519-0800:1.3
	v20060512-1000:1.3
	I20060512-1000:1.3
	I20060505-1400:1.3
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060202-1415:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051208-2000:1.2
	I20051201-1800:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.6
date	2008.01.18.20.29.50;	author crevells;	state Exp;
branches;
next	1.5;
commitid	119947910c3e4567;

1.5
date	2008.01.11.15.59.37;	author crevells;	state Exp;
branches;
next	1.4;
commitid	6a2c478792684567;

1.4
date	2006.10.03.15.02.05;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.13.19.59.15;	author sshaw;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2005.09.12.21.29.06;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.44;	author sshaw;	state Exp;
branches;
next	;

1.3.2.1
date	2006.09.08.15.54.54;	author cmahoney;	state Exp;
branches;
next	;


desc
@@


1.6
log
@[215851] gmf_head crevells 080118 Page Down, Page Up, Home, and End keys work sporadically on a diagram
@
text
@/******************************************************************************
 * Copyright (c) 2000, 2008  IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.internal.parts;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.Viewport;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.GraphicalViewer;
import org.eclipse.gef.RootEditPart;
import org.eclipse.gef.ui.parts.GraphicalViewerKeyHandler;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.KeyEvent;

/**
 * @@author melaasar
 * @@canBeSeenBy org.eclipse.gmf.runtime.diagram.ui.*
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 *
 * <p>
 * Code taken from Eclipse reference bugzilla #98820
 *
 */
public class DiagramGraphicalViewerKeyHandler
	extends GraphicalViewerKeyHandler {

	/**
	 * @@param viewer
	 */
	public DiagramGraphicalViewerKeyHandler(GraphicalViewer viewer) {
		super(viewer);
	}

	/**
	 * @@see org.eclipse.gef.KeyHandler#keyPressed(org.eclipse.swt.events.KeyEvent)
	 */
	public boolean keyPressed(KeyEvent event) {
		switch (event.keyCode) {
			case SWT.HOME :
				if ((event.stateMask & SWT.ALT) != 0) {
					if (navigateEndSibling(event, PositionConstants.WEST))
						return true;
				} else {
					if (navigateEndSibling(event, PositionConstants.NORTH))
						return true;
				}
                break;
			case SWT.END :
				if ((event.stateMask & SWT.ALT) != 0) {
					if (navigateEndSibling(event, PositionConstants.EAST))
						return true;
				} else {
					if (navigateEndSibling(event, PositionConstants.SOUTH))
						return true;
				}
                break;
			case SWT.PAGE_UP :
				if ((event.stateMask & SWT.ALT) != 0) {
					if (navigatePageSibling(event, PositionConstants.WEST))
						return true;
				} else {
					if (navigatePageSibling(event, PositionConstants.NORTH))
						return true;
				}
                break;
			case SWT.PAGE_DOWN :
				if ((event.stateMask & SWT.ALT) != 0) {
					if (navigatePageSibling(event, PositionConstants.EAST))
						return true;
				} else {
					if (navigatePageSibling(event, PositionConstants.SOUTH))
						return true;
				}
				break;
	        case SWT.TAB:
	            if ((event.stateMask & SWT.SHIFT) != 0) {
                    if (navigateNextHorizontalSibling(isViewerMirrored() ? PositionConstants.EAST
                        : PositionConstants.WEST)) {
                        return true;
                    }
                } else {
                    if (navigateNextHorizontalSibling(isViewerMirrored() ? PositionConstants.WEST
                        : PositionConstants.EAST)) {
                        return true;
                    }
                }
                break;
		}
		return super.keyPressed(event);
	}

	/**
	 * @@return
	 */
	protected GraphicalEditPart getFocusPart() {
		return (GraphicalEditPart) getViewer().getFocusEditPart();
	}

	/**
	 * @@param part
	 * @@param event
	 */
	protected void navigateToPart(EditPart part, KeyEvent event) {
		if (part == null)
			return;
		if (!part.isSelectable()) {
			getViewer().deselectAll();
			getViewer().setFocus(part);
		} else if ((event.stateMask & SWT.SHIFT) != 0) {
			getViewer().appendSelection(part);
			getViewer().setFocus(part);
		} else if ((event.stateMask & SWT.CONTROL) != 0)
			getViewer().setFocus(part);
		else
			getViewer().select(part);
		getViewer().reveal(part);
	}

	/**
	 * @@return
	 */
	protected List getPartNavigationSiblings() {
        EditPart epParent = findParent(getFocusPart());
        if (epParent != null)
            return epParent.getChildren();
        else
            return null;
	}

	/**
	 * @@param figure
	 * @@return
	 */
	protected Point getFigureInterestingPoint(IFigure figure) {
		return figure.getBounds().getCenter();
	}

	protected Viewport findViewport(GraphicalEditPart part) {
        if (part == null) 
            return null;
        
		IFigure figure = null;
		Viewport port = null;
		do {
			if (figure == null)
				figure = part.getContentPane();
			else
				figure = figure.getParent();
			if (figure instanceof Viewport) {
				port = (Viewport) figure;
				break;
			}
		} while (figure != null);
		return port;
	}

	/**
	 * @@param event
	 * @@param direction
	 * @@param page
	 * @@param list
	 * @@return
	 */
	protected boolean navigatePageSibling(KeyEvent event, int direction) {
		GraphicalEditPart epStart = getFocusPart();
		IFigure figure = epStart.getFigure();
		Point pStart = getFigureInterestingPoint(figure);
		figure.translateToAbsolute(pStart);

		GraphicalEditPart epParent = (GraphicalEditPart) findParent(epStart);
		Viewport viewport = findViewport(epParent);
		Rectangle bounds =
			(viewport != null)
				? new Rectangle(viewport.getBounds())
				: epParent.getFigure().getClientArea();
		int pageDistance = 0;
		switch (direction) {
			case PositionConstants.NORTH :
			case PositionConstants.SOUTH :
				pageDistance = bounds.height;
				break;
			case PositionConstants.EAST :
			case PositionConstants.WEST :
				pageDistance = bounds.width;
				break;
		}
		
	    if (epStart instanceof DiagramEditPart) {
	        Point location = viewport.getViewLocation().getCopy();
	        switch (direction) {
	            case PositionConstants.NORTH :
	                location.translate(0, -pageDistance);
	                break;              
	            case PositionConstants.SOUTH :
	                location.translate(0, pageDistance);
	                break;
	            case PositionConstants.EAST :
	                location.translate(pageDistance, 0);
	                break;
	            case PositionConstants.WEST :
                    location.translate(-pageDistance, 0);
	                break;
	        }
	        viewport.setViewLocation(location);
        }

		List<GraphicalEditPart> editParts =
			findPageSibling(
				getPartNavigationSiblings(),
				pStart,
				pageDistance,
				direction,
				epStart);
		if (editParts.isEmpty())
			return false;
		if ((event.stateMask & SWT.SHIFT) != 0) {
			Iterator<GraphicalEditPart> parts = editParts.iterator();
			while (parts.hasNext())
				navigateToPart(parts.next(), event);
		} else {
			EditPart part = editParts.get(editParts.size() - 1);
			navigateToPart(part, event);
		}
		return true;
	}

	/**
	 * @@param event
	 * @@param direction
	 * @@param list
	 * @@return
	 */
	protected boolean navigateEndSibling(KeyEvent event, int direction) {
		GraphicalEditPart epStart = getFocusPart();
		
		// go to top-left or bottom-right corner if nothing is selected
		if (epStart instanceof DiagramEditPart) {
            Viewport viewport = findViewport(epStart);
            switch (direction) {
                case PositionConstants.NORTH:
                case PositionConstants.WEST:
                    viewport.setViewLocation(viewport.getHorizontalRangeModel()
                        .getMinimum(), viewport.getVerticalRangeModel()
                        .getMinimum());
                    break;
                case PositionConstants.SOUTH:
                case PositionConstants.EAST:
                    viewport.setViewLocation(viewport.getHorizontalRangeModel()
                        .getMaximum(), viewport.getVerticalRangeModel()
                        .getMaximum());
                    break;
            }
        }
		
		IFigure figure = epStart.getFigure();
		Point pStart = getFigureInterestingPoint(figure);
		figure.translateToAbsolute(pStart);
		List<GraphicalEditPart> editParts =
			findEndSibling(
				getPartNavigationSiblings(),
				pStart,
				direction,
				epStart);
		if (editParts.isEmpty())
			return false;
		if ((event.stateMask & SWT.SHIFT) != 0) {
			Iterator<GraphicalEditPart> parts = editParts.iterator();
			while (parts.hasNext())
				navigateToPart(parts.next(), event);
		} else {
			EditPart part = editParts.get(editParts.size() - 1);
			navigateToPart(part, event);
		}
		return true;
	}

	/**
	 * @@param siblings
	 * @@param pStart
	 * @@param minDistance
	 * @@param direction
	 * @@param exclude
	 * @@return
	 */
	private List<GraphicalEditPart> findPageSibling(
		List siblings,
		Point pStart,
		int pageDistance,
		int direction,
		EditPart exclude) {
	    
		GraphicalEditPart epCurrent;
		GraphicalEditPart epFinal = null;
		GraphicalEditPart epFurthest = null;  // in case there is not a full pageDistance left to scroll
		List<GraphicalEditPart> selection = new ArrayList<GraphicalEditPart>();
		IFigure figure;
		Point pCurrent;
		int distance = Integer.MAX_VALUE;
		int furthestDistance = 0;

		Iterator iter = siblings.iterator();
		while (iter.hasNext()) {
			epCurrent = (GraphicalEditPart) iter.next();
			if (epCurrent == exclude
				|| !epCurrent.getFigure().isVisible()
				|| epCurrent.getFigure().getBounds().isEmpty())
				continue;
			figure = epCurrent.getFigure();
			pCurrent = getFigureInterestingPoint(figure);
			figure.translateToAbsolute(pCurrent);
			if (!isInDirection(direction, pStart, pCurrent))
				continue;

			int d = pCurrent.getDistanceOrthogonal(pStart);
			if (d >= pageDistance) {
				selection.add(epCurrent);
				if (d < distance) {
					distance = d;
					epFinal = epCurrent;
				}
			}
			if (d > furthestDistance) {
			    epFurthest = epCurrent;
			}
			if (epFinal != null) {
				selection.remove(epFinal);
				selection.add(epFinal);
			}
		}
		if (selection.isEmpty() && epFurthest != null) {
		    return Collections.singletonList(epFurthest);
		}
		return selection;
	}

	/**
	 * @@param siblings
	 * @@param pStart
	 * @@param direction
	 * @@param exclude
	 * @@return
	 */
	private List<GraphicalEditPart> findEndSibling(
		List siblings,
		Point pStart,
		int direction,
		EditPart exclude) {
		GraphicalEditPart epCurrent;
		GraphicalEditPart epFinal = null;
		List<GraphicalEditPart> selection = new ArrayList<GraphicalEditPart>();
		IFigure figure;
		Point pCurrent;
		int distance = 0;

		Iterator iter = siblings.iterator();
		while (iter.hasNext()) {
			epCurrent = (GraphicalEditPart) iter.next();
			if (epCurrent == exclude
				|| !epCurrent.getFigure().isVisible()
				|| epCurrent.getFigure().getBounds().isEmpty())
				continue;
			figure = epCurrent.getFigure();
			pCurrent = getFigureInterestingPoint(figure);
			figure.translateToAbsolute(pCurrent);
			if (!isInDirection(direction, pStart, pCurrent))
				continue;

			selection.add(epCurrent);
			int d = pCurrent.getDistanceOrthogonal(pStart);
			if (d > distance) {
				distance = d;
				epFinal = epCurrent;
			}
		}
		if (epFinal != null) {
			selection.remove(epFinal);
			selection.add(epFinal);
		}
		return selection;
	}
    
    
    /**
     * @@param child
     * @@return EditPart
     */
    private EditPart findParent(EditPart child) {
        //check to see if we are not looking for a parent on RootEditPart, 
        //as it does not have a parent.
        if (child instanceof RootEditPart)
            return child;
        else
            return child.getParent(); //any other EditPart    
    }

    /**
     * Traverses to the closest EditPart in the given list that is also in the
     * given direction (EAST or WEST). The x-location alone is used to determine
     * the closest sibling. If the direction is EAST and there are no EditParts
     * to the EAST then the farthest WEST EditPart is returned (and vice versa).
     * This allows the user to cycle through all the EditParts using the TAB
     * key.
     * 
     * @@param direction
     *            the direction in which to navigate (either
     *            PositionConstants.WEST or PositionConstants.EAST)
     * @@return true if a sibling was found to navigate to; false otherwise.
     */
    private boolean navigateNextHorizontalSibling(int direction) {
        GraphicalEditPart epStart = getFocusEditPart();
        EditPart next = null;
        if (epStart instanceof DiagramEditPart) {
            next = findClosestHorizontalSibling(epStart.getChildren(),
                new Point(0, 0), PositionConstants.EAST, null);
        } else {
            IFigure figure = epStart.getFigure();
            Point pStart = figure.getBounds().getCenter();
            figure.translateToAbsolute(pStart);
            next = findClosestHorizontalSibling(getNavigationSiblings(),
                pStart, direction, epStart);
        }
        if (next == null)
            return false;

        getViewer().select(next);
        getViewer().reveal(next);
        return true;
    }

    /**
     * Given an absolute point (pStart) and a list of EditParts, this method
     * finds the closest EditPart (except for the one to be excluded) in the
     * given direction (EAST or WEST). The x-location alone is used to determine
     * the closest sibling. If the direction is EAST and there are no EditParts
     * to the EAST then the farthest WEST EditPart is returned (and vice versa).
     * This allows the user to cycle through all the EditParts using the TAB
     * key.
     * 
     * @@param siblings
     *            List of sibling EditParts
     * @@param pStart
     *            The starting point (must be in absolute coordinates) from
     *            which the next sibling is to be found.
     * @@param direction
     *            PositionConstants.EAST or PositionConstants.WEST
     * @@param exclude
     *            The EditPart to be excluded from the search
     */
    private GraphicalEditPart findClosestHorizontalSibling(List siblings,
            Point pStart, int direction, EditPart exclude) {
        GraphicalEditPart epCurrent;
        GraphicalEditPart epFinal = null;
        GraphicalEditPart epCycle = null; // in case there are no more shapes
                                            // in this direction
        IFigure figure;
        Point pCurrent;
        int distance = Integer.MAX_VALUE;
        int xCycle = direction == PositionConstants.EAST ? Integer.MAX_VALUE
            : 0;

        Iterator iter = siblings.iterator();
        while (iter.hasNext()) {
            epCurrent = (GraphicalEditPart) iter.next();
            if (epCurrent == exclude || !epCurrent.isSelectable())
                continue;
            figure = epCurrent.getFigure();
            pCurrent = figure.getBounds().getCenter();
            figure.translateToAbsolute(pCurrent);

            int dx = pCurrent.x - pStart.x;

            if ((direction == PositionConstants.EAST && dx > 0)
                || (direction == PositionConstants.WEST && dx < 0)) {
                int abs_dx = Math.abs(dx);
                if (abs_dx < distance) {
                    distance = abs_dx;
                    epFinal = epCurrent;
                }
            }

            if (epFinal == null) {
                if (direction == PositionConstants.EAST && pCurrent.x < xCycle) {
                    xCycle = pCurrent.x;
                    epCycle = epCurrent;
                } else if (direction == PositionConstants.WEST
                    && pCurrent.x > xCycle) {
                    xCycle = pCurrent.x;
                    epCycle = epCurrent;
                }
            }
        }
        if (epFinal == null) {
            return epCycle;
        }
        return epFinal;
    }

    /**
     * Returns true if the point in question is in the given direction from the
     * starting point.
     * 
     * @@param direction
     *            the direction
     * @@param start
     *            the starting point
     * @@param point
     *            the point in question
     * @@return true if the point in question is in the given direction from the
     *         starting point; false otherwise
     */
    private boolean isInDirection(int direction, Point start, Point point) {
        switch (direction) {
            case PositionConstants.WEST:
                return start.x > point.x;
            case PositionConstants.EAST:
                return start.x < point.x;
            case PositionConstants.NORTH:
                return start.y > point.y;
            case PositionConstants.SOUTH:
                return start.y < point.y;
        }
        return false;
    }
    
}
@


1.5
log
@[111901] gmf_head crevells 080111 [KeyboardBindings] Ability to move shapes using cursors keys. (by default)
@
text
@d15 1
d94 1
a195 1
		figure.translateToAbsolute(bounds);
d207 19
d227 1
a227 1
		List editParts =
d237 1
a237 1
			Iterator parts = editParts.iterator();
d239 1
a239 1
				navigateToPart((EditPart) parts.next(), event);
d241 1
a241 1
			EditPart part = (EditPart) editParts.get(editParts.size() - 1);
d255 20
d278 1
a278 1
		List editParts =
d287 1
a287 1
			Iterator parts = editParts.iterator();
d289 1
a289 1
				navigateToPart((EditPart) parts.next(), event);
d291 1
a291 1
			EditPart part = (EditPart) editParts.get(editParts.size() - 1);
d305 1
a305 1
	private List findPageSibling(
d311 1
d314 2
a315 1
		List selection = new ArrayList();
d318 2
a319 1
		int distance = 0;
d331 1
a331 1
			if (pStart.getPosition(pCurrent) != direction)
d335 1
a335 1
			if (d <= pageDistance) {
d337 1
a337 1
				if (d > distance) {
d342 3
d350 3
d363 1
a363 1
	private List findEndSibling(
d370 1
a370 1
		List selection = new ArrayList();
d385 1
a385 1
			if (pStart.getPosition(pCurrent) != direction)
d517 27
@


1.4
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2003, 2006  IBM Corporation and others.
d28 1
d93 13
d366 103
@


1.3
log
@bugzilla 136582 gmf-head sshaw 060413 Refactor DirectEditRequestWrapper in public API
@
text
@d26 1
d65 1
d74 1
d83 1
d127 5
a131 1
		return getFocusPart().getParent().getChildren();
d143 3
d174 1
a174 1
		GraphicalEditPart epParent = (GraphicalEditPart) epStart.getParent();
d338 14
@


1.3.2.1
log
@Bugzilla#148887 gmf_R1_0_maintenance cmahoney 060908 Problems with PAGE_UP/PAGE_DOWN/HOME/END
Contributed by: Syed Atif Ali
@
text
@a25 1
import org.eclipse.gef.RootEditPart;
a63 1
                break;
a71 1
                break;
a79 1
                break;
d123 1
a123 5
        EditPart epParent = findParent(getFocusPart());
        if (epParent != null)
            return epParent.getChildren();
        else
            return null;
a134 3
        if (part == null) 
            return null;
        
d163 1
a163 1
		GraphicalEditPart epParent = (GraphicalEditPart) findParent(epStart);
a326 14
    
    
    /**
     * @@param child
     * @@return EditPart
     */
    private EditPart findParent(EditPart child) {
        //check to see if we are not looking for a parent on RootEditPart, 
        //as it does not have a parent.
        if (child instanceof RootEditPart)
            return child;
        else
            return child.getParent(); //any other EditPart    
    }
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2003  IBM Corporation and others.
a29 2
import org.eclipse.gmf.runtime.gef.ui.internal.requests.DirectEditRequestWrapper;

a54 8
		if (isAlphaNum(event)) {
			// Create a Direct Edit Request and cache the character typed
			DirectEditRequestWrapper req =
				new DirectEditRequestWrapper(event.character);
			// Send the request to the current edit part in focus
			getFocusPart().performRequest(req);
			return true;
		}
a92 23
	 * Tests to see if the key pressed was an letter or number
	 * @@param event KeyEvent to be tested
	 * @@return true if the key pressed is Alpha Numeric, otherwise false.
	 */
	protected boolean isAlphaNum(KeyEvent event) {

		final String allowedStartingCharacters = "`~!@@#$%^&*()-_=+{}[]|;:',.<>?\""; //$NON-NLS-1$

		// IF the character is a letter or number or is contained
		// in the list of allowed starting characters ...
		if (Character.isLetterOrDigit(event.character)
			|| !(allowedStartingCharacters.indexOf(event.character) == -1)) {

			// And the character hasn't been modified or is only modified
			// with SHIFT
			if (event.stateMask == 0 || event.stateMask == SWT.SHIFT)
				return true;
		}

		return false;
	}

	/**
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 4
a4 4
/*******************************************************************************
 * Copyright (c) 2000, 2003 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
d6 2
a7 2
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
d9 3
a11 2
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
@

