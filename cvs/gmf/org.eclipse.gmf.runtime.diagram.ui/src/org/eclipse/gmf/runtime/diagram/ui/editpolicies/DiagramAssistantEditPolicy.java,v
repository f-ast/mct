head	1.8;
access;
symbols
	v20081023-2107:1.8
	v20081022-1925:1.8
	v20081022-1005:1.8
	v20081020-0700:1.8
	v20080917-1925:1.8
	v20080916-2008:1.8
	v20080911-1728:1.8
	v20080911-1506:1.8
	v20080910-1520:1.8
	v20080910-1510:1.8
	v20080903-1520:1.8
	v20080903-1510:1.8
	v20080813-1510:1.8
	v20080811-1546:1.8
	v20080731-1520:1.8
	v20080725-1738:1.8
	v20080723-2246:1.8
	v20080723-2232:1.8
	v20080723-1700:1.8
	v20080722-1827:1.8
	v20080718-1700:1.8
	v20080718-1731:1.8
	v20080716-1600:1.8
	v20080716-1642:1.8
	R2_1_maintenance:1.8.0.2
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080610-1132:1.8
	v20080603-1553:1.8
	v20080527-1255:1.8
	v20080527-1151:1.7
	v20080516-1748:1.8
	v20080516-1143:1.8
	v20080512-1200:1.8
	v20080503-1740:1.8
	v20080501-2127:1.7
	v20080501-1739:1.8
	m20080429-1543:1.7
	v20080425-1959:1.8
	v20080417-1610:1.8
	v20080407-2250:1.8
	v20080407-0930:1.8
	v20080404-1111:1.8
	v20080328-1605:1.8
	v20080322-0000:1.8
	v20080222-1200:1.8
	v20080201-2010:1.8
	v20080201-0201:1.7
	v20080118-1129:1.7
	v20080114-2222:1.7
	v20080114-1111:1.7
	v20080107-1111:1.7
	v20071222-1111:1.7
	v20071214-1111:1.7
	v20071130-1111:1.7
	v20071124-0000:1.7
	v20071112-0000:1.7
	v20071108-0000:1.7
	v20071003-0000:1.7
	v20070915-0000:1.7
	v20070903-0000:1.7
	v20070809-0000:1.7
	R2_0_maintenance:1.7.0.4
	R2_0:1.7
	R4_20:1.7
	v20070621-0000:1.7
	RC3_20:1.7
	v20070614-1400:1.7
	v20070608-1300:1.7
	v20070605-1400:1.7
	v20070601-1400:1.7
	v20070525-1500:1.7
	v20070518-1300:1.7
	bugzilla111892_group_support:1.7.0.2
	Root_bugzilla111892_group_support:1.7
	v20070504-1000:1.7
	v20070420-1000:1.7
	v20070413-1300:1.7
	v20070330-1300:1.7
	v20060330-1300:1.7
	v20070322-1100:1.7
	v20060316-0600:1.7
	v20070221-1500:1.7
	v20070208-1800:1.7
	v20070202-0200:1.6.2.3
	v20070119-1200:1.6.2.3
	v20070111-0800:1.6.2.3
	v20070105-1200:1.6.2.3
	v20070103-0300:1.7
	M4_20:1.7
	v20061218-1500:1.6.2.3
	v20061218-1200:1.7
	v20061214-0000:1.7
	M3_20:1.7
	v20061117-0800:1.7
	v20061027-1200:1.6.2.3
	v20061013-1330:1.7
	v20061012-1100:1.6.2.3
	v20060925-1700:1.6.2.3
	v20060919-0800:1.6.2.3
	v20060907-1100:1.6.2.1
	M1_20:1.6
	v20060831-1500:1.6.2.1
	v20060824-1600:1.6.2.1
	v20060817-1500:1.6
	v20060810-1700:1.6
	v20060803-1200:1.6
	v20060728-0500:1.6
	v20060721-1130:1.6
	v20060713-1700:1.6
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060616-1400:1.6
	v20060616-1200:1.6
	v20060609-1400:1.6
	v20060531-1730:1.6
	v20060530-1930:1.6
	v20060526-1200:1.6
	v20060519-0800:1.6
	v20060512-1000:1.6
	I20060512-1000:1.6
	I20060505-1400:1.6
	I20060428-1300:1.5
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.4
	I20060209-1815:1.4
	I20060203-0830:1.4
	I20060202-1415:1.4
	I20060129-1145:1.4
	I20060127-0900:1.4
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.4
	I20051223-1100:1.4
	I20051217-0925:1.4
	I20051208-2000:1.4
	I20051201-1800:1.4
	I20051124-2000:1.4
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2008.01.17.20.45.24;	author crevells;	state Exp;
branches;
next	1.7;
commitid	7524478fbe644567;

1.7
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.04.19.20.34;	author cmahoney;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2006.02.28.02.30.51;	author cmahoney;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.21.15.40.03;	author cmahoney;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.14.15.17.42;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.07.19.21.25;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.23.20.56.03;	author sshaw;	state Exp;
branches;
next	;

1.6.2.1
date	2006.08.21.18.22.53;	author mmostafa;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2006.09.08.14.33.21;	author cmahoney;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2006.09.13.16.43.39;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.8
log
@[110721] gmf_head crevells 080117 Limit display of diagram assistance (connection handles and action tool bars) to one selection at a time
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.draw2d.MouseEvent;
import org.eclipse.draw2d.MouseMotionListener;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartListener;
import org.eclipse.gef.editpolicies.GraphicalEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.progress.UIJob;

/**
 * Encapsulates behavior common to editpolicies that popup diagram assistants.
 * 
 * @@author cmahoney
 */
public abstract class DiagramAssistantEditPolicy
	extends GraphicalEditPolicy
	implements MouseMotionListener {
    
	/**
	 * The <code>Job</code> used to show the diagram assistant after a certain
	 * amount of time has passed.
	 */
	private class ShowDiagramAssistantJob
		extends UIJob {

		/** the mouse location when the job was created */
		private Point originalMouseLocation;

		/**
         * Creates a new instance.
         */
        protected ShowDiagramAssistantJob() {
            super("Show Diagram Assistant"); //$NON-NLS-1$
            setSystem(true);
        }

		/**
		 * Sets mouse location
		 * 
		 * @@param originalMouseLocation
		 *            the current mouse location
		 */
		public void setOriginalMouseLocation(Point originalMouseLocation) {
			this.originalMouseLocation = originalMouseLocation;
		}

		/**
		 * The diagram assistant added when this task is run if the mouse is
		 * still at the same spot where it was when the timer was started (i.e.
		 * only add the diagram assistant when the user stops moving the mouse).
		 */
		public IStatus runInUIThread(IProgressMonitor monitor) {
			if (originalMouseLocation != null
				&& originalMouseLocation.equals(getMouseLocation())) {
				if (isDiagramAssistantShowing()
					&& !shouldAvoidHidingDiagramAssistant()) {
					hideDiagramAssistant();
				}
				if (shouldShowDiagramAssistant()) {

                    // Cancel the hide diagram assistant job for this host if it
                    // is waiting to run.
                    hideDiagramAssistantJob.cancel();

                    // Schedule any hide diagram assistant jobs on other
                    // editparts to run immediately to avoid duplicate diagram
                    // assistants showing.
                    if (getDiagramAssistantID() != null) {
                        Job.getJobManager().wakeUp(getDiagramAssistantID());
                    }

					showDiagramAssistant(originalMouseLocation);
				}
			}
			return Status.OK_STATUS;
		}
	}

	/**
	 * The <code>Job</code> used to hide the diagram assistant after a certain
	 * amount of time has passed.
	 */
	private class HideDiagramAssistantJob
        extends UIJob {

        protected HideDiagramAssistantJob() {
            super("Hide Diagram Assistant"); //$NON-NLS-1$
            setSystem(true);
        }

		/**
		 * The diagram assistant is removed when this task is run if the mouse
		 * is still outside the shape.
		 */
		public IStatus runInUIThread(IProgressMonitor monitor) {
			if (getMouseLocation() == null
				|| !shouldAvoidHidingDiagramAssistant()) {
				hideDiagramAssistant();
			}
			return Status.OK_STATUS;
		}

        public boolean belongsTo(Object family) {
            return family == getDiagramAssistantID();
        }
	}
	
	/**
	 * Listens to the focus events on the owner editpart so that the diagram
	 * assistant can be added when the space bar is pressed. I tried to use
	 * IFigure.addFocusListener(), but the figure isn't getting any focus change
	 * events when the space bar is pressed.
	 */
	private class FocusListener
		extends EditPartListener.Stub {

		/*
		 * (non-Javadoc)
		 * 
		 * @@see org.eclipse.gef.EditPartListener#selectedStateChanged(org.eclipse.gef.EditPart)
		 */
		public void selectedStateChanged(EditPart part) {
			if (part.hasFocus() && shouldShowDiagramAssistant()) {
				showDiagramAssistant(getMouseLocation());
			} else {
				hideDiagramAssistant();
			}
		}
	}

	/**
	 * The amount of time to wait before showing the diagram assistant.
	 */
	private static final int APPEARANCE_DELAY = 200;

	/**
	 * The amount of time to wait before hiding the diagram assistant after it
	 * has been made visible.
	 */
	private static final int DISAPPEARANCE_DELAY = 2000;

	/**
	 * The amount of time to wait before hiding the diagram assistant after the
	 * user has moved the mouse outside of the editpart.
	 */
	private static final int DISAPPEARANCE_DELAY_UPON_EXIT = 1000;

	/**
	 * The current mouse location within the host used to determine where the
	 * diagram assistant should be displayed. This will be null if the mouse is
	 * outside the host and diagram assistant figure.
	 */
	private Point mouseLocation;

	/** Listens to focus change events on the host editpart. */
	private FocusListener focusListener = new FocusListener();

	/** Flag to indicate that the diagram assistant should not be hidden. */
	private boolean avoidHidingDiagramAssistant = true;

	private ShowDiagramAssistantJob showDiagramAssistantJob = new ShowDiagramAssistantJob();

	private HideDiagramAssistantJob hideDiagramAssistantJob = new HideDiagramAssistantJob();

	/**
	 * Creates a new instance.
	 */
	public DiagramAssistantEditPolicy() {
		super();
	}

	/**
	 * Checks if the object is or is part of the diagram assistant figure. This
	 * is used to determine if the mouse is hovering over the diagram assistant.
	 * 
	 * @@param object
	 *            the object in question
	 * @@return True if the object in question is or is part of the diagram
	 *         assistant figure; false otherwise.
	 */
	protected abstract boolean isDiagramAssistant(Object object);

	/**
	 * Returns true if the diagram assistant is currently showing; false
	 * otherwise. This is used to determine if the diagram assistant should be
	 * shown or hidden at a given point in time.
	 * 
	 * @@return true if the diagram assistant is showing; false otherwise
	 */
	protected abstract boolean isDiagramAssistantShowing();

	/**
	 * Shows the diagram assistant figure(s).
	 * 
	 * @@param referencePoint
	 *            The reference point which may be used to determine where the
	 *            diagram assistant should be located. This is most likely the
	 *            current mouse location. This could be null, for example, when
	 *            the host gains focus via the space bar, in which case the
	 *            diagram assistant should be shown in a default location.
	 */
	protected abstract void showDiagramAssistant(Point referencePoint);

	/**
	 * Hides the diagram assistant figure(s).
	 */
	protected abstract void hideDiagramAssistant();
	
	/**
	 * Returns true if the diagram assistant should be shown; false otherwise.
	 * This can be overridden to check any other conditions which must be met
	 * prior to showing the diagram assistant.
	 * 
	 * @@return true if the diagram assistant should be shown; false otherwise.
	 */
	protected boolean shouldShowDiagramAssistant() {
		return getHost().isActive() && isPreferenceOn() && isHostEditable()
			&& isHostResolvable() && isDiagramPartActive();
	}

	/**
	 * Returns true if the preference to show this diagram assistant is on or if
	 * there is no applicable preference; false otherwise.
	 */
	protected boolean isPreferenceOn() {
		String prefName = getPreferenceName();
		if (prefName == null) {
			return true;
		}
		IPreferenceStore preferenceStore = (IPreferenceStore) ((IGraphicalEditPart) getHost())
			.getDiagramPreferencesHint().getPreferenceStore();
		return preferenceStore.getBoolean(prefName);
	}

	/**
	 * The preference name indicating if the preference should be on or off.
	 * This preference must be a boolean preference stored in the diagram
	 * preferences.
	 * 
	 * @@return the preference name if applicable; null otherwise
	 */
	String getPreferenceName() {
		return null;
	}
	
	/**
	 * Checks if the host editpart is editable.
	 * 
	 * @@return True if the host is editable; false otherwise.
	 */
	private boolean isHostEditable() {
		if (getHost() instanceof GraphicalEditPart) {
			return ((GraphicalEditPart) getHost()).isEditModeEnabled();
		}
		return true;
	}

	/**
	 * Is the host's semantic reference resolvable (if applicable)?
	 * 
	 * @@return true if the semantic reference is resolvable, true if there is no
	 *         semantic reference, and false otherwise
	 */
	private boolean isHostResolvable() {
		final View view = (View) getHost().getModel();
        EObject element = view.getElement();
		if (element != null) {
			return !element.eIsProxy();
		} 
		return true;
	}
	
	
	/**
	 * Checks if the diagram part is active.
	 * 
	 * @@return True if the diagram part is active; false otherwise.
	 */
	private boolean isDiagramPartActive() {
		IWorkbenchWindow window = PlatformUI.getWorkbench()
			.getActiveWorkbenchWindow();

		if (window != null) {
			IWorkbenchPage page = window.getActivePage();
			if (page != null) {
				IWorkbenchPart activePart = page.getActivePart();
				if (activePart instanceof IDiagramWorkbenchPart) {
					return ((IDiagramWorkbenchPart) activePart)
						.getDiagramEditPart().getRoot().equals(
							((IGraphicalEditPart) getHost()).getRoot());
				}
			}
		}
		return false;
	}
	
	/**
	 * Shows the diagram assistant after a certain amount of time has passed.
	 * 
	 * @@param delay
	 *            the delay in milliseconds
	 */
	protected void showDiagramAssistantAfterDelay(int delay) {
		if (delay >= 0) {
            showDiagramAssistantJob.setOriginalMouseLocation(getMouseLocation());
            showDiagramAssistantJob.cancel();
            showDiagramAssistantJob.schedule(delay);
		}
	}

	/**
	 * Hides the diagram assistant after a certain amount of time has passed.
	 * 
	 * @@param delay
	 *            the delay in milliseconds
	 */
	protected void hideDiagramAssistantAfterDelay(int delay) {
		if (isDiagramAssistantShowing() && delay >= 0) {
            hideDiagramAssistantJob.cancel();
            hideDiagramAssistantJob.schedule(delay);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.editpolicies.AbstractEditPolicy#activate()
	 */
	public void activate() {
		super.activate();
		((IGraphicalEditPart) getHost()).getFigure().addMouseMotionListener(
			this);
		((IGraphicalEditPart) getHost()).addEditPartListener(focusListener);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.editpolicies.AbstractEditPolicy#deactivate()
	 */
	public void deactivate() {
		((IGraphicalEditPart) getHost()).getFigure().removeMouseMotionListener(
			this);
		((IGraphicalEditPart) getHost()).removeEditPartListener(focusListener);

		hideDiagramAssistant();

		super.deactivate();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.draw2d.MouseMotionListener#mouseEntered(org.eclipse.draw2d.MouseEvent)
	 */
	public void mouseEntered(MouseEvent me) {
		setMouseLocation(me.getLocation());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.draw2d.MouseMotionListener#mouseExited(org.eclipse.draw2d.MouseEvent)
	 */
	public void mouseExited(MouseEvent me) {
		setMouseLocation(null);
		hideDiagramAssistantAfterDelay(getDisappearanceDelayUponExit());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.draw2d.MouseMotionListener#mouseMoved(org.eclipse.draw2d.MouseEvent)
	 */
	public void mouseMoved(MouseEvent me) {
		setMouseLocation(me.getLocation());

		// do not hide the diagram assistant if the user is hovering over it
		setAvoidHidingDiagramAssistant(isDiagramAssistant(me.getSource()));

		showDiagramAssistantAfterDelay(getAppearanceDelay());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.draw2d.MouseMotionListener#mouseHover(org.eclipse.draw2d.MouseEvent)
	 */
	public void mouseHover(MouseEvent me) {
		// do nothing
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.draw2d.MouseMotionListener#mouseDragged(org.eclipse.draw2d.MouseEvent)
	 */
	public void mouseDragged(MouseEvent me) {
		// do nothing
	}

	/**
	 * Gets the amount of time to wait before showing the diagram assistant.
	 * 
	 * @@return the time to wait in milliseconds
	 */
	protected int getAppearanceDelay() {
		return APPEARANCE_DELAY;
	}

	/**
	 * Gets the amount of time to wait before hiding the diagram assistant after
	 * it has been made visible.
	 * 
	 * @@return the time to wait in milliseconds
	 */
	protected int getDisappearanceDelay() {
		return DISAPPEARANCE_DELAY;
	}

	/**
	 * Gets the amount of time to wait before hiding the diagram assistant after
	 * the user has moved the mouse outside of the editpart.
	 * 
	 * @@return the time to wait in milliseconds
	 */
	protected int getDisappearanceDelayUponExit() {
		return DISAPPEARANCE_DELAY_UPON_EXIT;
	}

	/**
	 * Gets the current mouse location. This will be null if the mouse is
	 * outside the host and diagram assistant figure.
	 * 
	 * @@return Returns the current mouse location
	 */
	protected Point getMouseLocation() {
		return mouseLocation;
	}

	/**
	 * Sets the current mouse location. If set to null, this implies that the
	 * mouse is outside the host and diagram assistant figure.
	 * 
	 * @@param mouseLocation
	 *            the current mouse location
	 */
	protected void setMouseLocation(Point mouseLocation) {
		this.mouseLocation = mouseLocation;
	}

	/**
	 * Sets the flag to indicate that the diagram assistant should not be
	 * hidden.
	 * 
	 * @@param avoidHidingDiagramAssistant
	 *            Flag to indicate that the diagram assistant should not be
	 *            hidden
	 */
	protected void setAvoidHidingDiagramAssistant(boolean avoidHidingDiagramAssistant) {
		this.avoidHidingDiagramAssistant = avoidHidingDiagramAssistant;
	}

	/**
	 * Returns true if the diagram assistant should not be hidden; false
	 * otherwise.
	 * 
	 * @@return true if the diagram assistant should not be hidden; false
	 *         otherwise.
	 */
	protected boolean shouldAvoidHidingDiagramAssistant() {
		return avoidHidingDiagramAssistant;
	}

	/**
     * Gets an ID string used to identify the diagram assistant classification.
     * This ID should be the same string for all instances of a particular type
     * of diagram assistant. One use of this ID is to avoid having multiple
     * diagram assistants of the same type showing at the same time on different
     * editparts. A good ID string would be the class's name (e.g.
     * ConnectionHandleEditPolicy.class.getName()).
     * 
     * @@return a unique string for a diagram assistant type or null
     */
    protected String getDiagramAssistantID() {
        return null;
    }

}
@


1.7
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
d14 4
a29 1
import org.eclipse.swt.widgets.Display;
d34 1
d44 1
a44 1

d46 2
a47 2
	 * The <code>Runnable</code> used when a timer is started to show the
	 * diagram assistant after a certain amount of time has passed.
d49 2
a50 2
	private class ShowDiagramAssistantRunnable
		implements Runnable {
d52 1
a52 1
		/** the mouse location when the timer was started */
d56 8
d78 3
a80 2
		public void run() {
			if (originalMouseLocation != null && originalMouseLocation.equals(getMouseLocation())) {
d86 12
d101 1
d106 2
a107 2
	 * The <code>Runnable</code> used when a timer is started to hide the
	 * diagram assistant after a certain amount of time has passed.
d109 7
a115 2
	private class HideDiagramAssistantRunnable implements Runnable
	{
d121 1
a121 1
		public void run() {
d126 1
d128 4
d186 4
a189 3
	
	private ShowDiagramAssistantRunnable showDiagramAssistantRunnable = new ShowDiagramAssistantRunnable();
	private HideDiagramAssistantRunnable hideDiagramAssistantRunnable = new HideDiagramAssistantRunnable();
d330 5
a334 2
		showDiagramAssistantRunnable.setOriginalMouseLocation(getMouseLocation());
		Display.getCurrent().timerExec(delay,showDiagramAssistantRunnable);
d344 3
a346 2
		if (isDiagramAssistantShowing()) {
			Display.getCurrent().timerExec(delay, hideDiagramAssistantRunnable);
d501 14
@


1.6
log
@Bugzilla#140037 gmf_head cmahoney 050406 NPE in DiagramAssistantEditPolicy$ShowDiagramAssistantRunnable.run()
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d17 1
a17 1
import org.eclipse.emf.transaction.RunnableWithResult;
a20 3
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
a22 3
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
d52 1
a52 1
		 * Creates a new instance.
d57 1
a57 1
		protected ShowDiagramAssistantRunnable(Point originalMouseLocation) {
d83 2
a84 1
	private Runnable hideDiagramAssistantRunnable = new Runnable() {
d96 1
a96 1
	};
d150 3
d255 4
a258 23
		if (view.getElement() != null) {
			Boolean retval;
			try {
				retval = (Boolean) ((IGraphicalEditPart) getHost())
					.getEditingDomain().runExclusive(
						new RunnableWithResult.Impl() {

					public void run() {
						setResult(ViewUtil.resolveSemanticElement(view) != null ? Boolean.TRUE
							: Boolean.FALSE);
					}
				});
				return retval.booleanValue();
			} catch (InterruptedException e) {
				   Trace.catching(DiagramUIPlugin.getInstance(),
						DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
						"isHostResolvable", e); //$NON-NLS-1$
					Log.error(DiagramUIPlugin.getInstance(),
						DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
						"isHostResolvable", e); //$NON-NLS-1$
				   return false;
			}
		}
d293 2
a294 4
		if (shouldShowDiagramAssistant()) {
			Display.getCurrent().timerExec(delay,
				new ShowDiagramAssistantRunnable(getMouseLocation()));
		}
@


1.6.2.1
log
@[154363] gmf_R1_0_maintenance mmostafa  060818  DiagramAssistantEditPolicy starts un-needed trnasaction
@
text
@d17 1
a17 1
import org.eclipse.emf.ecore.EObject;
d21 3
d26 3
d257 23
a279 4
        EObject element = view.getElement();
		if (element != null) {
			return !element.eIsProxy();
		} 
@


1.6.2.2
log
@Bugzilla#156577 gmf_R1_0_maintenance cmahoney 060908 Diagram assistant figure doesn't reappear at the new location
Contributed by: Alex Boyko <aboyko@@ca.ibm.com>
@
text
@d52 1
a52 1
		 * Sets mouse location
d57 1
a57 1
		public void setOriginalMouseLocation(Point originalMouseLocation) {
d83 1
a83 2
	private class HideDiagramAssistantRunnable implements Runnable
	{
d95 1
a95 1
	}
a148 3
	
	private ShowDiagramAssistantRunnable showDiagramAssistantRunnable = new ShowDiagramAssistantRunnable();
	private HideDiagramAssistantRunnable hideDiagramAssistantRunnable = new HideDiagramAssistantRunnable();
d289 4
a292 2
		showDiagramAssistantRunnable.setOriginalMouseLocation(getMouseLocation());
		Display.getCurrent().timerExec(delay,showDiagramAssistantRunnable);
@


1.6.2.3
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
@


1.5
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d73 1
a73 1
			if (originalMouseLocation.equals(getMouseLocation())) {
@


1.4
log
@Bugzilla#116708 gmf_head cmahoney 051121 NPEs in DiagramAssistantEditPolicy.isPreferenceOn() because EditPart has no parent
@
text
@d17 1
d21 2
a22 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
d26 3
a29 1
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
d258 21
a278 9
			Boolean retval = (Boolean) MEditingDomainGetter.getMEditingDomain(
				view).runAsRead(new MRunnable() {

				public Object run() {
					return ViewUtil.resolveSemanticElement(view) != null ? Boolean.TRUE
						: Boolean.FALSE;
				}
			});
			return retval.booleanValue();
@


1.3
log
@Bugzilla 112521 gmf_head sshaw 051013 Diagram Assistants should not appear if editor is not active
Contributed by: Cherie Mahoney
@
text
@d204 1
a204 1
		return isPreferenceOn() && getHost().isActive() && isHostEditable()
@


1.2
log
@bugzilla 111952 gmf_head sshaw 051007 Connector handles do not appear when hovering over compartments
Contributed by: Cherie Mahoney
@
text
@d20 3
d24 4
d29 4
d74 3
a76 1
				showDiagramAssistant(originalMouseLocation);
d114 1
a114 1
			if (part.hasFocus()) {
d195 61
d257 34
d298 4
a301 2
		Display.getCurrent().timerExec(delay,
			new ShowDiagramAssistantRunnable(getMouseLocation()));
@


1.1
log
@Bugzilla 110480 gmf_head sshaw 050923 Modeling Assistant Service should have generic getTypes() operation to be used in commands with popups
Contributed by Cherie Mahoney
@
text
@d14 5
d20 2
d28 80
a107 2
public class DiagramAssistantEditPolicy
	extends GraphicalEditPolicy {
d118 1
a118 1
	private int DISAPPEARANCE_DELAY = 2000;
d127 13
d147 138
d312 45
@

