head	1.40;
access;
symbols
	v20081023-2107:1.40
	v20081022-1925:1.40
	v20081022-1005:1.40
	v20081020-0700:1.40
	v20080917-1925:1.40
	v20080916-2008:1.40
	v20080911-1728:1.40
	v20080911-1506:1.40
	v20080910-1520:1.40
	v20080910-1510:1.40
	v20080903-1520:1.40
	v20080903-1510:1.40
	v20080813-1510:1.40
	v20080811-1546:1.40
	v20080731-1520:1.40
	v20080725-1738:1.40
	v20080723-2246:1.40
	v20080723-2232:1.40
	v20080723-1700:1.40
	v20080722-1827:1.40
	v20080718-1700:1.40
	v20080718-1731:1.40
	v20080716-1600:1.40
	v20080716-1642:1.40
	R2_1_maintenance:1.40.0.2
	Root_R2_1_maintenance:1.40
	R2_1_0:1.40
	v20080610-1132:1.40
	v20080603-1553:1.40
	v20080527-1255:1.40
	v20080527-1151:1.34
	v20080516-1748:1.40
	v20080516-1143:1.40
	v20080512-1200:1.40
	v20080503-1740:1.39
	v20080501-2127:1.34
	v20080501-1739:1.38
	m20080429-1543:1.34
	v20080425-1959:1.36
	v20080417-1610:1.36
	v20080407-2250:1.36
	v20080407-0930:1.36
	v20080404-1111:1.36
	v20080328-1605:1.36
	v20080322-0000:1.36
	v20080222-1200:1.36
	v20080201-2010:1.36
	v20080201-0201:1.34
	v20080118-1129:1.34
	v20080114-2222:1.34
	v20080114-1111:1.36
	v20080107-1111:1.36
	v20071222-1111:1.36
	v20071214-1111:1.36
	v20071130-1111:1.35
	v20071124-0000:1.34
	v20071112-0000:1.34
	v20071108-0000:1.34
	v20071003-0000:1.34
	v20070915-0000:1.34
	v20070903-0000:1.34
	v20070809-0000:1.34
	R2_0_maintenance:1.34.0.2
	R2_0:1.34
	R4_20:1.34
	v20070621-0000:1.34
	RC3_20:1.33
	v20070614-1400:1.33
	v20070608-1300:1.33
	v20070605-1400:1.33
	v20070601-1400:1.33
	v20070525-1500:1.33
	v20070518-1300:1.33
	bugzilla111892_group_support:1.32.0.2
	Root_bugzilla111892_group_support:1.32
	v20070504-1000:1.31
	v20070420-1000:1.31
	v20070413-1300:1.31
	v20070330-1300:1.30
	v20060330-1300:1.30
	v20070322-1100:1.30
	v20060316-0600:1.30
	v20070221-1500:1.30
	v20070208-1800:1.30
	v20070202-0200:1.29.2.7
	v20070119-1200:1.29.2.7
	v20070111-0800:1.29.2.7
	v20070105-1200:1.29.2.7
	v20070103-0300:1.30
	M4_20:1.30
	v20061218-1500:1.29.2.7
	v20061218-1200:1.30
	v20061214-0000:1.30
	M3_20:1.30
	v20061117-0800:1.30
	v20061027-1200:1.29.2.7
	v20061013-1330:1.30
	v20061012-1100:1.29.2.7
	v20060925-1700:1.29.2.7
	v20060919-0800:1.29.2.7
	v20060907-1100:1.29.2.5
	M1_20:1.29
	v20060831-1500:1.29.2.5
	v20060824-1600:1.29.2.5
	v20060817-1500:1.29.2.5
	v20060810-1700:1.29.2.5
	v20060803-1200:1.29.2.4
	v20060728-0500:1.29.2.3
	v20060721-1130:1.29.2.2
	v20060713-1700:1.29.2.1
	R1_0_maintenance:1.29.0.2
	R1_0:1.29
	v20060627-1200:1.29
	v20060616-1400:1.29
	v20060616-1200:1.29
	v20060609-1400:1.29
	v20060531-1730:1.29
	v20060530-1930:1.28
	v20060526-1200:1.28
	v20060519-0800:1.27
	v20060512-1000:1.25
	I20060512-1000:1.25
	I20060505-1400:1.24
	I20060428-1300:1.24
	I20060424-0500:1.24
	I20060424-0300:1.24
	M6_10:1.24
	I20060407-1200:1.22
	I20060331-1000:1.22
	I20060324-0300:1.21
	I20060317-1300:1.20
	I20060317-1200:1.20
	I20060316-1300:1.20
	I20060309-1300:1.20
	M5_10:1.19
	S20060303-1600:1.19
	I20060227-1730:1.17
	I20060216-1945:1.17
	I20060210-1715:1.16
	I20060209-1815:1.15
	I20060203-0830:1.15
	I20060202-1415:1.15
	I20060129-1145:1.15
	I20060127-0900:1.15
	I20060120-1530:1.14
	I20060113-1700:1.13
	M4_10:1.13
	I20060107-1100:1.12
	I20060105-1630:1.12
	I20051230-1230:1.12
	I20051223-1100:1.12
	I20051217-0925:1.12
	I20051208-2000:1.12
	I20051201-1800:1.12
	I20051124-2000:1.11
	M3_10:1.10
	I20051118-1245:1.10
	I20051111-1800:1.10
	I20051106-0900:1.9
	v20051030:1.6;
locks; strict;
comment	@# @;


1.40
date	2008.05.09.15.12.06;	author ahunter;	state Exp;
branches;
next	1.39;
commitid	458d482469c64567;

1.39
date	2008.05.03.20.09.31;	author ahunter;	state Exp;
branches;
next	1.38;
commitid	2d9e481cc67a4567;

1.38
date	2008.04.30.20.18.08;	author crevells;	state Exp;
branches;
next	1.37;
commitid	79844818d4004567;

1.37
date	2008.04.28.21.45.51;	author ahunter;	state Exp;
branches;
next	1.36;
commitid	166b4816458f4567;

1.36
date	2007.12.11.15.17.03;	author crevells;	state Exp;
branches;
next	1.35;
commitid	70dc475ea9ed4567;

1.35
date	2007.11.21.17.57.28;	author crevells;	state Exp;
branches;
next	1.34;
commitid	4a12474471874567;

1.34
date	2007.06.21.14.04.19;	author crevells;	state Exp;
branches;
next	1.33;
commitid	184467a85634567;

1.33
date	2007.05.18.12.03.28;	author ahunter;	state Exp;
branches;
next	1.32;
commitid	3209464d96104567;

1.32
date	2007.05.16.16.50.41;	author ahunter;	state Exp;
branches
	1.32.2.1;
next	1.31;
commitid	43e3464b36614567;

1.31
date	2007.04.11.17.41.52;	author aboyko;	state Exp;
branches;
next	1.30;
commitid	c4b461d1ddf4567;

1.30
date	2006.10.03.15.02.04;	author ahunter;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.31.16.26.07;	author sshaw;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2006.05.26.12.50.43;	author cmahoney;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.12.21.21.11;	author sshaw;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.12.15.02.29;	author mmostafa;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.11.13.53.20;	author sshaw;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.13.19.59.15;	author sshaw;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.11.21.42.13;	author sshaw;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.29.21.27.14;	author ldamus;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.23.23.12.24;	author sshaw;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.06.23.25.39;	author ldamus;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.02.18.02.49;	author cmahoney;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.28.02.31.21;	author cmahoney;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.13.19.11.49;	author ldamus;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.10.21.32.32;	author ahunter;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.20.22.10.12;	author cmahoney;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.16.19.48.39;	author sshaw;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.13.15.27.49;	author sshaw;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.25.19.38.13;	author cmahoney;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.21.16.04.46;	author cmahoney;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.08.16.02.31;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.04.21.27.49;	author sshaw;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.02.16.39.33;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.14.20.50.55;	author mmostafa;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.14.19.37.49;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.21.29.05;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.08.18.58.41;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.45;	author sshaw;	state Exp;
branches;
next	;

1.29.2.1
date	2006.07.13.15.10.10;	author mmostafa;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2006.07.17.19.48.00;	author ahunter;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2006.07.27.21.34.16;	author mmostafa;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2006.08.02.17.11.40;	author ahunter;	state Exp;
branches;
next	1.29.2.5;

1.29.2.5
date	2006.08.10.18.39.12;	author ldamus;	state Exp;
branches;
next	1.29.2.6;

1.29.2.6
date	2006.09.13.19.33.36;	author mmostafa;	state Exp;
branches;
next	1.29.2.7;

1.29.2.7
date	2006.09.14.19.50.46;	author mmostafa;	state Exp;
branches;
next	;

1.32.2.1
date	2007.05.18.17.36.44;	author crevells;	state Exp;
branches;
next	;
commitid	1899464de42a4567;


desc
@@


1.40
log
@210642 gmf-head jacques.lescot 080409 Handle scroll-wheel zoom
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 *    Dmitry Stadnik (Borland) - contribution for bugzilla 136582
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.parts;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.eclipse.core.commands.operations.IOperationHistory;
import org.eclipse.core.commands.operations.IOperationHistoryListener;
import org.eclipse.core.commands.operations.IUndoContext;
import org.eclipse.core.commands.operations.IUndoableOperation;
import org.eclipse.core.commands.operations.ObjectUndoContext;
import org.eclipse.core.commands.operations.OperationHistoryEvent;
import org.eclipse.core.commands.operations.OperationHistoryFactory;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.draw2d.FigureCanvas;
import org.eclipse.draw2d.LightweightSystem;
import org.eclipse.draw2d.Viewport;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.emf.edit.domain.IEditingDomainProvider;
import org.eclipse.emf.transaction.RunnableWithResult;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.emf.workspace.ResourceUndoContext;
import org.eclipse.gef.ContextMenuProvider;
import org.eclipse.gef.DefaultEditDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartFactory;
import org.eclipse.gef.EditPartViewer;
import org.eclipse.gef.KeyHandler;
import org.eclipse.gef.KeyStroke;
import org.eclipse.gef.LayerConstants;
import org.eclipse.gef.MouseWheelHandler;
import org.eclipse.gef.MouseWheelZoomHandler;
import org.eclipse.gef.RootEditPart;
import org.eclipse.gef.SnapToGeometry;
import org.eclipse.gef.SnapToGrid;
import org.eclipse.gef.commands.CommandStack;
import org.eclipse.gef.editparts.ZoomManager;
import org.eclipse.gef.rulers.RulerProvider;
import org.eclipse.gef.ui.actions.ActionRegistry;
import org.eclipse.gef.ui.actions.DirectEditAction;
import org.eclipse.gef.ui.actions.GEFActionConstants;
import org.eclipse.gef.ui.actions.ZoomInAction;
import org.eclipse.gef.ui.actions.ZoomOutAction;
import org.eclipse.gef.ui.parts.ContentOutlinePage;
import org.eclipse.gef.ui.parts.GraphicalEditor;
import org.eclipse.gef.ui.parts.ScrollingGraphicalViewer;
import org.eclipse.gef.ui.parts.TreeViewer;
import org.eclipse.gef.ui.rulers.RulerComposite;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.action.ActionManager;
import org.eclipse.gmf.runtime.common.ui.services.editor.EditorService;
import org.eclipse.gmf.runtime.common.ui.util.IPartSelector;
import org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker;
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.gmf.runtime.diagram.core.util.ViewType;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.actions.ActionIds;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IDiagramPreferenceSupport;
import org.eclipse.gmf.runtime.diagram.ui.editparts.TreeContainerEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.TreeDiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.TreeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.internal.actions.InsertAction;
import org.eclipse.gmf.runtime.diagram.ui.internal.actions.PromptingDeleteAction;
import org.eclipse.gmf.runtime.diagram.ui.internal.actions.PromptingDeleteFromModelAction;
import org.eclipse.gmf.runtime.diagram.ui.internal.actions.ToggleRouterAction;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DiagramRootTreeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramUIPluginImages;
import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper;
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.DiagramGraphicalViewerKeyHandler;
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.DirectEditKeyHandler;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;
import org.eclipse.gmf.runtime.diagram.ui.internal.ruler.DiagramRuler;
import org.eclipse.gmf.runtime.diagram.ui.internal.ruler.DiagramRulerProvider;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
import org.eclipse.gmf.runtime.diagram.ui.providers.DiagramContextMenuProvider;
import org.eclipse.gmf.runtime.diagram.ui.services.editpart.EditPartService;
import org.eclipse.gmf.runtime.draw2d.ui.internal.parts.ScrollableThumbnailEx;
import org.eclipse.gmf.runtime.draw2d.ui.internal.parts.ThumbnailEx;
import org.eclipse.gmf.runtime.emf.commands.core.command.EditingDomainUndoContext;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.GuideStyle;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.preference.PreferenceStore;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.SWT;
import org.eclipse.swt.SWTException;
import org.eclipse.swt.events.DisposeEvent;
import org.eclipse.swt.events.DisposeListener;
import org.eclipse.swt.widgets.Canvas;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorSite;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchPartSite;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.contexts.IContextService;
import org.eclipse.ui.part.IPageSite;
import org.eclipse.ui.part.IShowInSource;
import org.eclipse.ui.part.PageBook;
import org.eclipse.ui.part.ShowInContext;
import org.eclipse.ui.views.contentoutline.IContentOutlinePage;
import org.eclipse.ui.views.properties.tabbed.ITabbedPropertySheetPageContributor;

/**
 * @@author melaasar
 * 
 * A generic diagram editor with no palette. DiagramEditorWithPalette will
 * provide a palette.
 */
public abstract class DiagramEditor
    extends GraphicalEditor
    implements IDiagramWorkbenchPart, ITabbedPropertySheetPageContributor,
    IShowInSource {
	
	public static String DIAGRAM_CONTEXT_ID = "org.eclipse.gmf.runtime.diagram.ui.diagramContext"; //$NON-NLS-1$

    /**
     * teh ID of the outline
     */
    protected static final int ID_OUTLINE = 0;

    /**
     * the id of the over view
     */
    protected static final int ID_OVERVIEW = 1;

    /**
     * the work space viewer preference store
     */
    protected PreferenceStore workspaceViewerPreferenceStore = null;

    /**
     * A diagram outline page
     */
    class DiagramOutlinePage
        extends ContentOutlinePage
        implements IAdaptable {

        private PageBook pageBook;

        private Control outline;

        private Canvas overview;

        private IAction showOutlineAction, showOverviewAction;

        private boolean overviewInitialized;

        private ThumbnailEx thumbnail;

        private DisposeListener disposeListener;

        /**
         * @@param viewer
         */
        public DiagramOutlinePage(EditPartViewer viewer) {
            super(viewer);
        }

        /*
         * (non-Javadoc)
         * 
         * @@see org.eclipse.ui.part.Page#init(org.eclipse.ui.part.IPageSite)
         */
        public void init(IPageSite pageSite) {
            super.init(pageSite);
            ActionRegistry registry = getActionRegistry();
            IActionBars bars = pageSite.getActionBars();
            String id = ActionFactory.UNDO.getId();
            bars.setGlobalActionHandler(id, registry.getAction(id));
            id = ActionFactory.REDO.getId();
            bars.setGlobalActionHandler(id, registry.getAction(id));
            id = ActionFactory.DELETE.getId();
            bars.setGlobalActionHandler(id, registry.getAction(id));
            bars.updateActionBars();

            // Toolbar refresh to solve linux defect RATLC525198
            bars.getToolBarManager().markDirty();
        }

        /**
         * configures the outline viewer
         */
        protected void configureOutlineViewer() {
            getViewer().setEditDomain(getEditDomain());
            getViewer().setEditPartFactory(getOutlineViewEditPartFactory());
            
            MenuManager outlineContextMenuProvider = getOutlineContextMenuProvider(getViewer());
            if (outlineContextMenuProvider != null) {
            	getViewer().setContextMenu(outlineContextMenuProvider);
            }

            getViewer().setKeyHandler(getKeyHandler());
            // getViewer().addDropTargetListener(
            // new LogicTemplateTransferDropTargetListener(getViewer()));
            IToolBarManager tbm = this.getSite().getActionBars()
                .getToolBarManager();
            showOutlineAction = new Action() {

                public void run() {
                    showPage(ID_OUTLINE);
                }
            };
            showOutlineAction
                .setImageDescriptor(DiagramUIPluginImages.DESC_OUTLINE);
            showOutlineAction.setToolTipText(DiagramUIMessages.OutlineView_OutlineTipText);
            tbm.add(showOutlineAction);
            showOverviewAction = new Action() {
            	
                public void run() {
                    showPage(ID_OVERVIEW);
                }
            };
            showOverviewAction
                .setImageDescriptor(DiagramUIPluginImages.DESC_OVERVIEW);
            showOverviewAction.setToolTipText(DiagramUIMessages.OutlineView_OverviewTipText);
            tbm.add(showOverviewAction);
            showPage(getDefaultOutlineViewMode());
        }

        public void createControl(Composite parent) {
            pageBook = new PageBook(parent, SWT.NONE);
            outline = getViewer().createControl(pageBook);
            overview = new Canvas(pageBook, SWT.NONE);
            pageBook.showPage(outline);
            configureOutlineViewer();
            hookOutlineViewer();
            initializeOutlineViewer();
        }

        public void dispose() {
            unhookOutlineViewer();
            if (thumbnail != null) {
                thumbnail.deactivate();
            }
            this.overviewInitialized = false;
            super.dispose();
        }

        public Object getAdapter(Class type) {
            // if (type == ZoomManager.class)
            // return getZoomManager();
            return null;
        }

        public Control getControl() {
            return pageBook;
        }

        /**
         * hook the outline viewer
         */
        protected void hookOutlineViewer() {
            getSelectionSynchronizer().addViewer(getViewer());
        }

        /**
         * initialize the outline viewer
         */
        protected void initializeOutlineViewer() {
            try {
                TransactionUtil.getEditingDomain(getDiagram()).runExclusive(
                    new Runnable() {

                        public void run() {
                            getViewer().setContents(getDiagram());
                        }
                    });
            } catch (InterruptedException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "initializeOutlineViewer", e); //$NON-NLS-1$
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                    "initializeOutlineViewer", e); //$NON-NLS-1$
            }
        }

        /**
         * initialize the overview
         */
        protected void initializeOverview() {
            LightweightSystem lws = new LightweightSystem(overview);
            RootEditPart rep = getGraphicalViewer().getRootEditPart();
            DiagramRootEditPart root = (DiagramRootEditPart) rep;
            thumbnail = new ScrollableThumbnailEx((Viewport) root.getFigure());
            // thumbnail.setSource(root.getLayer(LayerConstants.PRINTABLE_LAYERS));
            thumbnail.setSource(root.getLayer(LayerConstants.SCALABLE_LAYERS));

            lws.setContents(thumbnail);
            disposeListener = new DisposeListener() {

                public void widgetDisposed(DisposeEvent e) {
                    if (thumbnail != null) {
                        thumbnail.deactivate();
                        thumbnail = null;
                    }
                }
            };
            getEditor().addDisposeListener(disposeListener);
            this.overviewInitialized = true;
        }

        /**
         * show page with a specific ID, possibel values are ID_OUTLINE and
         * ID_OVERVIEW
         * 
         * @@param id
         */
        protected void showPage(int id) {
            if (id == ID_OUTLINE) {
                showOutlineAction.setChecked(true);
                showOverviewAction.setChecked(false);
                pageBook.showPage(outline);
                if (thumbnail != null)
                    thumbnail.setVisible(false);
            } else if (id == ID_OVERVIEW) {
                if (!overviewInitialized)
                    initializeOverview();
                showOutlineAction.setChecked(false);
                showOverviewAction.setChecked(true);
                pageBook.showPage(overview);
                thumbnail.setVisible(true);
            }
        }

        /**
         * unhook the outline viewer
         */
        protected void unhookOutlineViewer() {
            getSelectionSynchronizer().removeViewer(getViewer());
            if (disposeListener != null && getEditor() != null
                && !getEditor().isDisposed())
                getEditor().removeDisposeListener(disposeListener);
        }

        /**
         * getter for the editor conrolo
         * 
         * @@return <code>Control</code>
         */
        protected Control getEditor() {
            return getGraphicalViewer().getControl();
        }

    }

    /**
     * My editing domain provider.
     */
    private IEditingDomainProvider domainProvider = new IEditingDomainProvider() {

        public EditingDomain getEditingDomain() {
            return DiagramEditor.this.getEditingDomain();
        }
    };

    /** The key handler */
    private KeyHandler keyHandler;

    /**
     * The workbench site This variable overrides another one defined in
     * <code>org.eclipse.ui.part<code>
     *  This is needed to override <code>setSite</code> to simply set the site, rather than also
     *  initializing the actions like <code>setSite</code> override in <code>org.eclipse.gef.ui.parts</code>
     */
    private IWorkbenchPartSite partSite;

    /**
     * The RulerComposite used to enhance the graphical viewer to display rulers
     */
    private RulerComposite rulerComposite;

    /**
     * My undo context.
     */
    private IUndoContext undoContext;

    /**
     * My operation history listener. By default it adds my undo context to
     * operations that have affected my editing domain. Subclasses may override
     * {@@link #createHistoryListener()} to do something different.
     */
    private IOperationHistoryListener historyListener;

    /**
     * Alternative operation history listener. By default it adds it disables
     * updates when command is executing on a separate thread and then reables
     * afterwards.
     */
    private IOperationHistoryListener disableUpdateHistoryListener;

    /**
     * Returns this editor's outline-page default display mode.
     * 
     * @@return int the integer value indicating the content-outline-page dispaly
     *         mode
     */
    protected int getDefaultOutlineViewMode() {
        return ID_OVERVIEW;
    }

    /**
     * Returns the context menu provider for the outline view.
     * 
     * @@param viewer The outline viewer for which this context menu provider
     *  will be added.
     *  
     * @@return A menu manager that can be used in the provided outline viewer
     *  or null if no context menu should be shown.
     *  
     */
    protected MenuManager getOutlineContextMenuProvider(EditPartViewer viewer) {
		return null;
	}

	/**
     * @@return Returns the rulerComp.
     */
    protected RulerComposite getRulerComposite() {
        return rulerComposite;
    }

    /**
     * @@param rulerComp
     *            The rulerComp to set.
     */
    protected void setRulerComposite(RulerComposite rulerComp) {
        this.rulerComposite = rulerComp;
    }

    /**
     * Creates a new DiagramEditor instance
     */
    public DiagramEditor() {
        createDiagramEditDomain();

        // add my operation history listener, if I have one
        historyListener = createHistoryListener();
        disableUpdateHistoryListener = createDisableUpdateHistoryListener();
    }

    /**
     * Creates a listener on the <code>IOperationHistory</code> that allows
     * us to turn off updates when execution is performed on a separate
     * thread.
     * 
     * @@return 
     */
    private IOperationHistoryListener createDisableUpdateHistoryListener() {
        return new IOperationHistoryListener() {

            public void historyNotification(final OperationHistoryEvent event) {

                if (event.getEventType() == OperationHistoryEvent.ABOUT_TO_EXECUTE ||
                    event.getEventType() == OperationHistoryEvent.ABOUT_TO_UNDO ||
                    event.getEventType() == OperationHistoryEvent.ABOUT_TO_REDO) {
                    DiagramGraphicalViewer viewer = (DiagramGraphicalViewer)getDiagramGraphicalViewer();

                    if (viewer != null && Display.getCurrent() == null)
                        viewer.enableUpdates(false); 
                }
                else if (event.getEventType() == OperationHistoryEvent.OPERATION_NOT_OK ||
                    event.getEventType() == OperationHistoryEvent.DONE ||
                    event.getEventType() == OperationHistoryEvent.UNDONE ||
                    event.getEventType() == OperationHistoryEvent.REDONE) {
                    DiagramGraphicalViewer viewer = (DiagramGraphicalViewer)getDiagramGraphicalViewer();

                    if (viewer != null)
                        viewer.enableUpdates(true); 
                }
            }
        };
    }
    
    /**
     * Gets my operation history listener. By default it adds my undo context to
     * operations that have affected my editing domain.
     * <P>
     * Subclasses may override this method to return a different history
     * listener, or to return <code>null</code> if they do not want to listen
     * to the operation history.
     * 
     * @@return my operation history listener
     */
    protected IOperationHistoryListener createHistoryListener() {

        return new IOperationHistoryListener() {

            public void historyNotification(final OperationHistoryEvent event) {

                if (event.getEventType() == OperationHistoryEvent.DONE) {
                    IUndoableOperation operation = event.getOperation();

                    if (shouldAddUndoContext(operation)) {
                        // add my undo context to populate my undo
                        // menu
                        operation.addContext(getUndoContext());
                    }
                }
            }
        };
    }

    /**
     * Answers whether or not I should add my undo context to the undoable
     * <code>operation</code>, thereby making the operation available from my
     * undo menu.
     * <P>
     * The default implementation adds my context to any operation that affected
     * the same editing domain that has loaded the resource that contains my
     * diagram element. Subclasses can override this method if they wish to add
     * their context to operations for different reasons.
     * 
     * @@param operation
     *            the operation
     * @@return <code>true</code> if the operation should appear on my undo
     *         menu, <code>false</code> otherwise.
     */
    protected boolean shouldAddUndoContext(IUndoableOperation operation) {
        EditingDomain domain = getEditingDomain();

        if (domain != null) {
            Set affectedResources = ResourceUndoContext
                .getAffectedResources(operation);

            for (Iterator i = affectedResources.iterator(); i.hasNext();) {
                Resource nextResource = (Resource) i.next();

                ResourceSet resourceSet = nextResource.getResourceSet();

                if (resourceSet != null) {
                    TransactionalEditingDomain resourceSetEditingDomain = TransactionalEditingDomain.Factory.INSTANCE
                        .getEditingDomain(resourceSet);

                    if (domain.equals(resourceSetEditingDomain)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramEditDomain()
     */
    public IDiagramEditDomain getDiagramEditDomain() {
        return (IDiagramEditDomain) getEditDomain();
    }

    /**
     * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramGraphicalViewer()
     */
    public IDiagramGraphicalViewer getDiagramGraphicalViewer() {
        return (IDiagramGraphicalViewer) getGraphicalViewer();
    }

    /**
     * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagram()
     */
    public Diagram getDiagram() {
        if (getEditorInput() != null)
            return ((IDiagramEditorInput) getEditorInput()).getDiagram();
        return null;
    }

    /**
     * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramEditPart()
     */
    public DiagramEditPart getDiagramEditPart() {
        return (DiagramEditPart) getDiagramGraphicalViewer().getContents();
    }

    /**
     * @@see org.eclipse.core.runtime.IAdaptable#getAdapter(Class)
     */
    public Object getAdapter(Class type) {
        if (type == IContentOutlinePage.class) {
            TreeViewer viewer = new TreeViewer();
            viewer.setRootEditPart(new DiagramRootTreeEditPart());
            return new DiagramOutlinePage(viewer);
        }
        if (ActionManager.class == type)
            return getActionManager();
        if (IDiagramEditDomain.class == type)
            return getDiagramEditDomain();
        if (type == ZoomManager.class)
            return getZoomManager();

        if (type == IUndoContext.class) {
            return getUndoContext();
        }
        if (type == IOperationHistory.class) {
            return getOperationHistory();
        }
        if (type == IEditingDomainProvider.class) {
            return domainProvider;
        }

        return super.getAdapter(type);

    }

    /**
     * @@see org.eclipse.ui.IEditorPart#init(IEditorSite, IEditorInput)
     */
    public void init(IEditorSite site, IEditorInput input)
        throws PartInitException {
        
        super.init(site, input);
        
        try {
            EditorService.getInstance().registerEditor(this);
        } catch (Exception e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                   DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                   "init", e); //$NON-NLS-1$
            if (e.getMessage() != null)
                throw new PartInitException(e.getMessage(), e);
            else
                throw new PartInitException("DiagramEditor failed to initialize", e);//$NON-NLS-1$
        }
    }

    /**
     * Disposes this editor by: <br>
     * 3. Stops all registered listeners
     * 
     * @@see org.eclipse.ui.IWorkbenchPart#dispose()
     */
    public void dispose() {
        persistViewerSettings();
        EditorService.getInstance().unregisterEditor(DiagramEditor.this);
        stopListening();

        /*
         * RATLC00527385 DiagramRulerProvider wasn't uninitialized on dispose of
         * the editor.
         */
        DiagramRulerProvider vertProvider = (DiagramRulerProvider) getDiagramGraphicalViewer()
            .getProperty(RulerProvider.PROPERTY_VERTICAL_RULER);
        if (vertProvider != null)
            vertProvider.uninit();

        // Set the Horizontal Ruler properties
        DiagramRulerProvider horzProvider = (DiagramRulerProvider) getDiagramGraphicalViewer()
            .getProperty(RulerProvider.PROPERTY_HORIZONTAL_RULER);
        if (horzProvider != null)
            horzProvider.uninit();

        // Dispose my GEF command stack
        getEditDomain().getCommandStack().dispose();

        // stop listening to the history
        if (historyListener != null) {
            getOperationHistory().removeOperationHistoryListener(
                historyListener);
            
            // dispose my undo context
            getOperationHistory().dispose(getUndoContext(), true, true, true);
        }

        if (disableUpdateHistoryListener != null) {
            getOperationHistory().removeOperationHistoryListener(
                disableUpdateHistoryListener);
        }
        
        super.dispose();
    }

    /**
     * Returns the KeyHandler with common bindings for both the Outline and
     * Graphical Views. For example, delete is a common action.
     * 
     * @@return KeyHandler
     */
    protected KeyHandler getKeyHandler() {
        if (keyHandler == null) {
            keyHandler = new KeyHandler();

            ActionRegistry registry = getActionRegistry();
            IAction action;

            action = new PromptingDeleteAction(this);
            action.setText(DiagramUIMessages.DiagramEditor_Delete_from_Diagram);
            registry.registerAction(action);
            getSelectionActions().add(action.getId());

            action = new InsertAction(this);
            action.setText(""); //$NON-NLS-1$ // no text necessary since this is not a visible action
            registry.registerAction(action);
            getSelectionActions().add(action.getId());

            PromptingDeleteFromModelAction deleteModelAction = new PromptingDeleteFromModelAction(
                this);
            deleteModelAction.init();

            registry.registerAction(deleteModelAction);

            action = new DirectEditAction((IWorkbenchPart) this);
            registry.registerAction(action);
            getSelectionActions().add(action.getId());

            action = new ZoomInAction(getZoomManager());
            action.setText(""); //$NON-NLS-1$ // no text necessary since this is not a visible action
            registry.registerAction(action);
            getSelectionActions().add(action.getId());

            action = new ZoomOutAction(getZoomManager());
            action.setText(""); //$NON-NLS-1$ // no text necessary since this is not a visible action
            registry.registerAction(action);
            getSelectionActions().add(action.getId());

            action = new ToggleRouterAction(((IWorkbenchPart) this).getSite().getPage());
            ((ToggleRouterAction) action).setPartSelector(new IPartSelector() {
            	public boolean selects(IWorkbenchPart part) {
            		return part == DiagramEditor.this;
            	}
            });
            action.setText(""); //$NON-NLS-1$ // no text necessary since this is not a visible action
            registry.registerAction(action);
            getSelectionActions().add(action.getId());
            
            keyHandler.put(KeyStroke.getPressed(SWT.INSERT, 0),
                getActionRegistry().getAction(InsertAction.ID));
            keyHandler.put(KeyStroke.getPressed(SWT.DEL, 127, 0),
                getActionRegistry().getAction(ActionFactory.DELETE.getId()));
            keyHandler.put(KeyStroke.getPressed(SWT.BS, 8, 0),
                getActionRegistry().getAction(ActionFactory.DELETE.getId()));
            
            keyHandler.put(/* CTRL + D */
                    KeyStroke.getPressed((char) 0x4, 100, SWT.CTRL),
                        getActionRegistry().getAction(
                            ActionIds.ACTION_DELETE_FROM_MODEL));
            keyHandler.put(/* CTRL + '=' */
                    KeyStroke.getPressed('=', 0x3d, SWT.CTRL),
                        getActionRegistry().getAction(
                        		GEFActionConstants.ZOOM_IN));
            keyHandler.put(/* CTRL + '-' */
                    KeyStroke.getPressed('-', 0x2d, SWT.CTRL),
                        getActionRegistry().getAction(
                        		GEFActionConstants.ZOOM_OUT));
            keyHandler.put(/* CTRL + L */
                    KeyStroke.getPressed((char) 0xC, 108, SWT.CTRL),
                        getActionRegistry().getAction(
                        		ActionIds.ACTION_TOGGLE_ROUTER));
            keyHandler.put(KeyStroke.getPressed(SWT.F2, 0), getActionRegistry()
                .getAction(GEFActionConstants.DIRECT_EDIT));
        }
        return keyHandler;
    }

    /**
     * @@see org.eclipse.gef.ui.parts.GraphicalEditor#createGraphicalViewer(Composite)
     */
    protected void createGraphicalViewer(Composite parent) {
        setRulerComposite(new RulerComposite(parent, SWT.NONE));

        ScrollingGraphicalViewer sGViewer = createScrollingGraphicalViewer();
        sGViewer.createControl(getRulerComposite());
        setGraphicalViewer(sGViewer);
        hookGraphicalViewer();
        configureGraphicalViewer();
        initializeGraphicalViewer();
        getRulerComposite().setGraphicalViewer(
            (ScrollingGraphicalViewer) getGraphicalViewer());
    }

    /**
     * Creates a ScrollingGraphicalViewer without the drop adapter which
     * excludes drag and drop functionality from other defined views (XML)
     * Subclasses must override this method to include the DnD functionality
     * 
     * @@return ScrollingGraphicalViewer
     */
    protected ScrollingGraphicalViewer createScrollingGraphicalViewer() {
        return new DiagramGraphicalViewer();
    }

    /**
     * Configures the graphical viewer (the primary viewer of the editor)
     */
    protected void configureGraphicalViewer() {
        super.configureGraphicalViewer();

        IDiagramGraphicalViewer viewer = getDiagramGraphicalViewer();

        RootEditPart rootEP = EditPartService.getInstance().createRootEditPart(
            getDiagram());
        if (rootEP instanceof IDiagramPreferenceSupport) {
            ((IDiagramPreferenceSupport) rootEP)
                .setPreferencesHint(getPreferencesHint());
        }

        if (getDiagramGraphicalViewer() instanceof DiagramGraphicalViewer) {
            ((DiagramGraphicalViewer) getDiagramGraphicalViewer())
                .hookWorkspacePreferenceStore(getWorkspaceViewerPreferenceStore());
        }
   
        viewer.setRootEditPart(rootEP);
  
        viewer.setEditPartFactory(EditPartService.getInstance());
        ContextMenuProvider provider = new DiagramContextMenuProvider(this,
            viewer);
        viewer.setContextMenu(provider);
        getSite().registerContextMenu(ActionIds.DIAGRAM_EDITOR_CONTEXT_MENU,
            provider, viewer);
        KeyHandler viewerKeyHandler = new DiagramGraphicalViewerKeyHandler(viewer)
            .setParent(getKeyHandler());
        viewer.setKeyHandler(new DirectEditKeyHandler(viewer)
            .setParent(viewerKeyHandler));
        ((FigureCanvas) viewer.getControl())
            .setScrollBarVisibility(FigureCanvas.ALWAYS);
    }

    /**
     * @@see org.eclipse.gef.ui.parts.GraphicalEditor#initializeGraphicalViewer()
     */
    protected void initializeGraphicalViewer() {
        initializeGraphicalViewerContents();
    }

    /**
     * @@see org.eclipse.gef.ui.parts.GraphicalEditor#initializeGraphicalViewer()
     */
    protected void initializeGraphicalViewerContents() {
        getDiagramGraphicalViewer().setContents(getDiagram());
        initializeContents(getDiagramEditPart());
    }

    /**
     * Creates a diagram edit domain
     */
    protected void createDiagramEditDomain() {
        DiagramEditDomain editDomain = new DiagramEditDomain(this);
        editDomain.setActionManager(createActionManager());
        setEditDomain(editDomain);
    }

    /**
     * Configures my diagram edit domain with its command stack.
     */
    protected void configureDiagramEditDomain() {

        DefaultEditDomain editDomain = getEditDomain();

        if (editDomain != null) {
            CommandStack stack = editDomain.getCommandStack();

            if (stack != null) {
                // dispose the old stack
                stack.dispose();
            }

            // create and assign the new stack
            DiagramCommandStack diagramStack = new DiagramCommandStack(
                getDiagramEditDomain());
            diagramStack.setOperationHistory(getOperationHistory());

            // changes made on the stack can be undone from this editor
            diagramStack.setUndoContext(getUndoContext());

            editDomain.setCommandStack(diagramStack);
        }
    }

    /**
     * @@overridable
     */
    protected ActionManager createActionManager() {
        return new ActionManager(createOperationHistory());
    }

    /**
     * Create my operation history.
     * 
     * @@return my operation history
     */
    protected IOperationHistory createOperationHistory() {
        return OperationHistoryFactory.getOperationHistory();
    }

    /**
     * @@see org.eclipse.ui.part.EditorPart#setInput(IEditorInput)
     */
    protected void setInput(IEditorInput input) {
        stopListening();
        super.setInput(input);
        if (input != null) {
            Assert.isNotNull(getDiagram(), "Couldn't load/create diagram view"); //$NON-NLS-1$
        }
        // dispose the old command stack and create a new one
        configureDiagramEditDomain();
        startListening();
    }

    /**
     * Do nothing
     * 
     * @@see org.eclipse.gef.ui.parts.GraphicalEditor#initializeActionRegistry()
     */
    protected void createActions() {
        // null impl.
    }

    /**
     * A utility to close the editor
     * 
     * @@param save
     */
    protected void closeEditor(final boolean save) {
        // Make this call synchronously to avoid the following sequence:
        // Select me, select the model editor, close the model editor,
        // closes the model, fires events causing me to close,
        // if actual close is delayed using an async call then eclipse
        // tries to set the selection back to me when the model editor
        // finishes being disposed, but model has been closed so I
        // am no longer connected to the model, NullPointerExceptions occur.
        try {
            getSite().getPage().closeEditor(DiagramEditor.this, save);
        } catch (SWTException e) {
            // TODO remove when "Widget is disposed" exceptions are fixed.
            // Temporarily catch SWT exceptions here to allow model server event
            // processing to continue.
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, this.getClass(),
                "closeEditor", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(), IStatus.ERROR, e
                .getMessage(), e);
        }
    }
    
    /**
     * Installs all the listeners needed by the editor
     */
    protected void startListening() {
        // Create a diagram event broker if there isn't already one for this
        // editing domain.
        TransactionalEditingDomain domain = getEditingDomain();
        if (domain != null) {
            if (historyListener != null) { 
                getOperationHistory().addOperationHistoryListener(
                    historyListener);
            }

            if (disableUpdateHistoryListener != null) { 
                getOperationHistory().addOperationHistoryListener(
                    disableUpdateHistoryListener);
            }
            
            DiagramEventBroker eventBroker = DiagramEventBroker
                .getInstance(domain);
            if (eventBroker == null) {
                DiagramEventBroker.startListening(domain);
            }
        }
    }

    /**
     * Removes all the listeners used by the editor
     */
    protected void stopListening() {
        if (historyListener != null) {
            
            if (undoContext != null) {
                // dispose my undo context
                getOperationHistory().dispose(getUndoContext(), true, true, true);
            }
            
            getOperationHistory().removeOperationHistoryListener(
                historyListener);
        }
        
        if (disableUpdateHistoryListener != null) {
            getOperationHistory().removeOperationHistoryListener(
                disableUpdateHistoryListener);
        }
    }

    /**
     * Clears the contents of the graphical viewer
     */
    protected void clearGraphicalViewerContents() {
        if (getDiagramGraphicalViewer().getContents() != null) {
            getDiagramGraphicalViewer().getContents().deactivate();
            getDiagramGraphicalViewer().getContents().removeNotify();
        }

        /*
         * DiagramRulerProvider needs to be uninitialized in case the input has
         * been changed during editor life cycle.
         * 
         * https://bugs.eclipse.org/bugs/show_bug.cgi?id=167523
         */
        DiagramRulerProvider vertProvider = (DiagramRulerProvider) getDiagramGraphicalViewer()
            .getProperty(RulerProvider.PROPERTY_VERTICAL_RULER);
        if (vertProvider != null)
            vertProvider.uninit();
        DiagramRulerProvider horzProvider = (DiagramRulerProvider) getDiagramGraphicalViewer()
            .getProperty(RulerProvider.PROPERTY_HORIZONTAL_RULER);
        if (horzProvider != null)
            horzProvider.uninit();

        getDiagramGraphicalViewer().setContents(null);
    }

    /**
     * Gets the action manager for this diagram editor. The action manager's
     * command manager is used by my edit domain's command stack when executing
     * commands. This is the action manager that is returned when I am asked to
     * adapt to an <code>ActionManager</code>.
     * 
     * @@return the action manager
     */
    protected ActionManager getActionManager() {
        return getDiagramEditDomain().getActionManager();
    }

    /**
     * A utility method to return the zoom manager from the graphical viewer's
     * root
     * 
     * @@return the zoom manager
     */
    protected ZoomManager getZoomManager() {
        return ((DiagramRootEditPart) getRootEditPart()).getZoomManager();
    }

    private RootEditPart getRootEditPart() {
        return getGraphicalViewer().getRootEditPart();
    }

    /**
     * Returns the operation history from my action manager.
     * 
     * @@return the operation history
     */
    protected IOperationHistory getOperationHistory() {
        return getActionManager().getOperationHistory();
    }

    /**
     * Gets my editing domain derived from my diagram editor input.
     * <P>
     * If subclasses have a known editing domain, they should override this
     * method to return that editing domain as that will be more efficient that
     * the generic implementation provided here.
     * 
     * @@return my editing domain
     */
    public TransactionalEditingDomain getEditingDomain() {
        if (getDiagram() != null) {
            return TransactionUtil.getEditingDomain(getDiagram());
        }
        return null;
    }

    /**
     * Gets my undo context. Lazily initializes my undo context if it has not
     * been set.
     * 
     * @@return my undo context
     */
    protected IUndoContext getUndoContext() {

        if (undoContext == null) {
            TransactionalEditingDomain domain = getEditingDomain();

            if (domain != null) {
                undoContext = new EditingDomainUndoContext(domain);

            } else {
                undoContext = new ObjectUndoContext(this);
            }
        }
        return undoContext;
    }

    /**
     * Sets my undo context
     * 
     * @@param context
     *            the undo context
     */
    protected void setUndoContext(IUndoContext context) {
        this.undoContext = context;
    }

    /**
     * 
     * @@return The getRulerComposite(), which is the graphical control
     */
    protected Control getGraphicalControl() {
        return getRulerComposite();

    }

    /**
     * @@see org.eclipse.ui.IWorkbenchPart#getSite()
     */
    public IWorkbenchPartSite getSite() {
        return partSite;
    }

    /**
     * @@see org.eclipse.ui.part.WorkbenchPart#setSite(IWorkbenchPartSite)
     */
    protected void setSite(IWorkbenchPartSite site) {
        this.partSite = site;

    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.common.ui.properties.ITabbedPropertySheetPageContributor#getContributorId()
     */
    public String getContributorId() {
        return "org.eclipse.gmf.runtime.diagram.ui.properties"; //$NON-NLS-1$
    }

    /**
     * Adds the default preferences to the specified preference store.
     * 
     * @@param store
     *            store to use
     * @@param preferencesHint
     *            The preference hint that is to be used to find the appropriate
     *            preference store from which to retrieve diagram preference
     *            values. The preference hint is mapped to a preference store in
     *            the preference registry <@@link DiagramPreferencesRegistry>.
     */
    public static void addDefaultPreferences(PreferenceStore store,
            PreferencesHint preferencesHint) {
        store.setValue(WorkspaceViewerProperties.ZOOM, 1.0);
        store.setValue(WorkspaceViewerProperties.VIEWPAGEBREAKS, false);

        IPreferenceStore globalPreferenceStore = (IPreferenceStore) preferencesHint
            .getPreferenceStore();

        // Initialize with the global settings
        boolean viewGrid = globalPreferenceStore
            .getBoolean(IPreferenceConstants.PREF_SHOW_GRID);

        boolean snapToGrid = globalPreferenceStore
            .getBoolean(IPreferenceConstants.PREF_SNAP_TO_GRID);
        
        boolean snapToGeometry = globalPreferenceStore
        .getBoolean(IPreferenceConstants.PREF_SNAP_TO_GEOMETRY);

        boolean viewRulers = globalPreferenceStore
            .getBoolean(IPreferenceConstants.PREF_SHOW_RULERS);

        // Set defaults for Grid
        store.setValue(WorkspaceViewerProperties.VIEWGRID, viewGrid);
        store.setValue(WorkspaceViewerProperties.SNAPTOGRID, snapToGrid);        
        store.setValue(WorkspaceViewerProperties.SNAPTOGEOMETRY, snapToGeometry);

        // Set defaults for Rulers
        store.setValue(WorkspaceViewerProperties.VIEWRULERS, viewRulers);
        
        // Initialize printing defaults from the workspace preferences 
        IPreferenceStore workspacePreferences = (IPreferenceStore)preferencesHint.getPreferenceStore();
     
        store.setValue(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS,
						workspacePreferences
								.getBoolean(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS));

		store.setValue(WorkspaceViewerProperties.PREF_USE_DIAGRAM_SETTINGS,
						workspacePreferences
								.getBoolean(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS));

		store.setValue(WorkspaceViewerProperties.PREF_USE_INCHES,
				workspacePreferences
						.getBoolean(WorkspaceViewerProperties.PREF_USE_INCHES));

		store.setValue(WorkspaceViewerProperties.PREF_USE_MILLIM,
				workspacePreferences
						.getBoolean(WorkspaceViewerProperties.PREF_USE_MILLIM));

		store.setValue(WorkspaceViewerProperties.PREF_USE_PORTRAIT,
						workspacePreferences
								.getBoolean(WorkspaceViewerProperties.PREF_USE_PORTRAIT));
		
		store.setValue(WorkspaceViewerProperties.PREF_USE_LANDSCAPE,
						workspacePreferences
								.getBoolean(WorkspaceViewerProperties.PREF_USE_LANDSCAPE));

		store.setValue(WorkspaceViewerProperties.PREF_PAGE_SIZE,
				workspacePreferences
						.getString(WorkspaceViewerProperties.PREF_PAGE_SIZE));

		store.setValue(WorkspaceViewerProperties.PREF_PAGE_WIDTH,
				workspacePreferences
						.getDouble(WorkspaceViewerProperties.PREF_PAGE_WIDTH));
		
		store.setValue(WorkspaceViewerProperties.PREF_PAGE_HEIGHT,
				workspacePreferences
						.getDouble(WorkspaceViewerProperties.PREF_PAGE_HEIGHT));

		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_TOP,
				workspacePreferences
						.getDouble(WorkspaceViewerProperties.PREF_MARGIN_TOP));

		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_BOTTOM,
						workspacePreferences
								.getDouble(WorkspaceViewerProperties.PREF_MARGIN_BOTTOM));

		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_LEFT,
				workspacePreferences
						.getDouble(WorkspaceViewerProperties.PREF_MARGIN_LEFT));
		
		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_RIGHT,
						workspacePreferences
								.getDouble(WorkspaceViewerProperties.PREF_MARGIN_RIGHT));
    }

    /**
	 * Returns the workspace viewer <code>PreferenceStore</code>
	 * 
	 * @@return the workspace viewer <code>PreferenceStore</code>
	 */
    public PreferenceStore getWorkspaceViewerPreferenceStore() {
        if (workspaceViewerPreferenceStore != null) {
            return workspaceViewerPreferenceStore;
        } else {
            // Try to load it
            IPath path = DiagramUIPlugin.getInstance().getStateLocation();
            String id = ViewUtil.getIdStr(getDiagram());

            String fileName = path.toString() + "/" + id;//$NON-NLS-1$
            java.io.File file = new File(fileName);
            workspaceViewerPreferenceStore = new PreferenceStore(fileName);
            if (file.exists()) {
                // Load it
                try {
                    workspaceViewerPreferenceStore.load();
                } catch (Exception e) {
                    // Create the default
                    addDefaultPreferences();
                }
            } else {
                // Create it
                addDefaultPreferences();
            }
            return workspaceViewerPreferenceStore;
        }
    }

    /**
     * Adds the default preferences to the workspace viewer preference store.
     */
    protected void addDefaultPreferences() {
        addDefaultPreferences(workspaceViewerPreferenceStore,
            getPreferencesHint());
    }

    /**
     * Persists the viewer settings to which this RootEditPart belongs. This
     * method should be called when the diagram is being disposed.
     */
    public void persistViewerSettings() {
        Viewport viewport = getDiagramEditPart().getViewport();
        if (viewport != null) {
            int x = viewport.getHorizontalRangeModel().getValue();
            int y = viewport.getVerticalRangeModel().getValue();
            getWorkspaceViewerPreferenceStore().setValue(
                WorkspaceViewerProperties.VIEWPORTX, x);
            getWorkspaceViewerPreferenceStore().setValue(
                WorkspaceViewerProperties.VIEWPORTY, y);
        }
        getWorkspaceViewerPreferenceStore().setValue(
            WorkspaceViewerProperties.ZOOM, getZoomManager().getZoom());

        // Write the settings, if necessary
        try {
            if (getWorkspaceViewerPreferenceStore().needsSaving())
                getWorkspaceViewerPreferenceStore().save();
        } catch (IOException ioe) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING,
                PageInfoHelper.class, "persistViewerSettings", //$NON-NLS-1$
                ioe);
        }
    }

    /**
     * Initializes the viewer's state from the workspace preference store.
     * 
     * @@param editpart
     */
    private void initializeContents(EditPart editpart) {
        getZoomManager().setZoom(
            getWorkspaceViewerPreferenceStore().getDouble(
                WorkspaceViewerProperties.ZOOM));

        if (getWorkspaceViewerPreferenceStore().getBoolean(
            WorkspaceViewerProperties.VIEWPAGEBREAKS)) {
            getDiagramEditPart().getFigure().invalidate();
            getDiagramEditPart().getFigure().validate();
        }
        getDiagramEditPart().refreshPageBreaks();

        // Update the range model of the viewport
        ((DiagramEditPart) editpart).getViewport().validate();
        if (editpart instanceof DiagramEditPart) {
            int x = getWorkspaceViewerPreferenceStore().getInt(
                WorkspaceViewerProperties.VIEWPORTX);
            int y = getWorkspaceViewerPreferenceStore().getInt(
                WorkspaceViewerProperties.VIEWPORTY);
            ((DiagramEditPart) editpart).getViewport()
                .getHorizontalRangeModel().setValue(x);
            ((DiagramEditPart) editpart).getViewport().getVerticalRangeModel()
                .setValue(y);
        }

        // Get the Ruler Units properties
        int rulerUnits = getWorkspaceViewerPreferenceStore().getInt(
            WorkspaceViewerProperties.RULERUNIT);

        // Get the Guide Style
        GuideStyle guideStyle = (GuideStyle) getDiagram().getStyle(
            NotationPackage.eINSTANCE.getGuideStyle());

        if (guideStyle != null) {

            RootEditPart rep = getGraphicalViewer().getRootEditPart();
            DiagramRootEditPart root = (DiagramRootEditPart) rep;

            // Set the Vertical Ruler properties
            DiagramRuler verticalRuler = ((DiagramRootEditPart) getRootEditPart())
                .getVerticalRuler();
            verticalRuler.setGuideStyle(guideStyle);
            verticalRuler.setUnit(rulerUnits);
            DiagramRulerProvider vertProvider = new DiagramRulerProvider(
                getEditingDomain(), verticalRuler, root.getMapMode());
            vertProvider.init();
            getDiagramGraphicalViewer().setProperty(
                RulerProvider.PROPERTY_VERTICAL_RULER, vertProvider);

            // Set the Horizontal Ruler properties
            DiagramRuler horizontalRuler = ((DiagramRootEditPart) getRootEditPart())
                .getHorizontalRuler();
            horizontalRuler.setGuideStyle(guideStyle);
            horizontalRuler.setUnit(rulerUnits);
            DiagramRulerProvider horzProvider = new DiagramRulerProvider(
                getEditingDomain(), horizontalRuler, root.getMapMode());
            horzProvider.init();
            getDiagramGraphicalViewer().setProperty(
                RulerProvider.PROPERTY_HORIZONTAL_RULER, horzProvider);

            // Show/Hide Rulers
            getDiagramGraphicalViewer().setProperty(
                RulerProvider.PROPERTY_RULER_VISIBILITY,
                Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
                    WorkspaceViewerProperties.VIEWRULERS)));

        }

        // Snap to Geometry        
        getDiagramGraphicalViewer().setProperty(
            SnapToGeometry.PROPERTY_SNAP_ENABLED,
            Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
                    WorkspaceViewerProperties.SNAPTOGEOMETRY))); 
        // Snap to Grid
        getDiagramGraphicalViewer().setProperty(
            SnapToGrid.PROPERTY_GRID_ENABLED,
            Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
                WorkspaceViewerProperties.SNAPTOGRID)));
        // Hide/Show Grid
        getDiagramGraphicalViewer().setProperty(
            SnapToGrid.PROPERTY_GRID_VISIBLE,
            Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
                WorkspaceViewerProperties.VIEWGRID)));

        // Grid Origin (always 0, 0)
        Point origin = new Point();
        getDiagramGraphicalViewer().setProperty(
        		SnapToGrid.PROPERTY_GRID_ORIGIN, origin);

        // Grid Spacing
        double dSpacing = ((DiagramRootEditPart) getDiagramEditPart().getRoot())
            .getGridSpacing();
        ((DiagramRootEditPart) getDiagramEditPart().getRoot())
            .setGridSpacing(dSpacing);

        // Scroll-wheel Zoom
        getGraphicalViewer().setProperty(MouseWheelHandler.KeyGenerator.getKey(SWT.CTRL), MouseWheelZoomHandler.SINGLETON);
    }

    /**
     * Returns the elements in the given selection.
     * 
     * @@param selection
     *            the selection
     * @@return a list of <code>EObject</code>
     */
    protected List getElements(final ISelection selection) {
        if (selection instanceof IStructuredSelection && !selection.isEmpty()) {

            try {
                return (List) TransactionUtil.getEditingDomain(
                    ((IAdaptable) ((IStructuredSelection) selection).toList()
                        .get(0)).getAdapter(View.class)).runExclusive(
                    new RunnableWithResult.Impl() {

                        public void run() {
                            List retval = new ArrayList();
                            if (selection instanceof IStructuredSelection) {
                                IStructuredSelection structuredSelection = (IStructuredSelection) selection;

                                for (Iterator i = structuredSelection
                                    .iterator(); i.hasNext();) {
                                    Object next = i.next();

                                    View view = (View) ((IAdaptable) next)
                                        .getAdapter(View.class);
                                    if (view != null) {
                                        EObject eObject = ViewUtil
                                            .resolveSemanticElement(view);
                                        if (eObject != null) {
                                            retval.add(eObject);
                                        } else {
                                            retval.add(view);
                                        }
                                    }
                                }
                            }
                            setResult(retval);
                        }
                    });
            } catch (InterruptedException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "createEditPart", e); //$NON-NLS-1$
                return Collections.EMPTY_LIST;
            }
        }
        return Collections.EMPTY_LIST;
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.ui.part.IShowInSource#getShowInContext()
     */
    public ShowInContext getShowInContext() {

        ISelection selection = getGraphicalViewer().getSelection();
        return new ShowInContext(null, selection);
    }

    /**
     * Gets the preferences hint that will be used to determine which preference
     * store to use when retrieving diagram preferences for this diagram editor.
     * The preference hint is mapped to a preference store in the preference
     * registry <@@link DiagramPreferencesRegistry>. By default, this method
     * returns a preference hint configured with the id of the editor. If a
     * preference store has not been registered against this editor id in the
     * diagram preferences registry, then the default values will be used.
     * 
     * @@return the preferences hint to be used to configure the
     *         <code>RootEditPart</code>
     */
    protected PreferencesHint getPreferencesHint() {
        return new PreferencesHint(getEditorSite().getId());
    };
    
    /**
     * Returns false if the editor is read only and returns true if the editor
     * is writable.
     * 
     * By default, edit parts have their edit mode enabled and this method
     * returns true.
     * 
     * Subclasses may override and disable the edit mode on parts.
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IEditableEditPart.
     * 
     * @@return false if the editor is read only and returns true if the editor
     * is writable.
     */
    public boolean isWritable() {
        return (getDiagramEditPart() != null && getDiagramEditPart().isEditModeEnabled());
    }
    
    /**
     * Creates edit part factory that will be creating tree edit parts in
     * the tree viewer
     * @@return <code>EditPartFactory</code> factory for the tree viewer
     */
    protected EditPartFactory getOutlineViewEditPartFactory() {
		return new EditPartFactory() {

			public EditPart createEditPart(EditPart context, Object model) {
				if (model instanceof Diagram) {
					return new TreeDiagramEditPart(model);
                } else if (model instanceof View
                    && ViewType.GROUP.equals(((View) model).getType())) {
                    return new TreeContainerEditPart(model);
				} else {
					return new TreeEditPart(model);
				}
			}
		};
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gef.ui.parts.GraphicalEditor#createPartControl(org.eclipse.swt.widgets.Composite)
	 */
	public void createPartControl(Composite parent) {
		super.createPartControl(parent);
		IContextService contextService = (IContextService) getSite()
		  .getService(IContextService.class);
		if (contextService != null)
			contextService.activateContext(getContextID());
	}
	
	/**
	 * Get the context identifier for this diagram editor.
	 * 
	 * @@return the context identifier.
	 */
	protected String getContextID() {
		return DIAGRAM_CONTEXT_ID;
	}

}
@


1.39
log
@[230056] gmf-head ahunter 080503 setLineWidth in ScaledGraphics does not support the zoom factor
@
text
@d55 2
d1429 3
@


1.38
log
@[229676] gmf_head jbruck 080430 The default page setup values for the diagram should be initialized differently.
@
text
@a37 2
import org.eclipse.draw2d.parts.ScrollableThumbnail;
import org.eclipse.draw2d.parts.Thumbnail;
d106 2
d189 1
a189 1
        private Thumbnail thumbnail;
d326 1
a326 1
            thumbnail = new ScrollableThumbnail((Viewport) root.getFigure());
@


1.37
log
@[229186] gmf-head ahunter 080428 GMF should provide a way to add context menus to the diagram outline
@
text
@a97 1
import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.DefaultValues;
d1202 4
a1205 40

        // Set defaults for Page Setup Dialog
        // PSDialog.initDefaultPreferences(store);

        // PSDefault.initDefaultPSPreferencePagePreferences(globalPreferenceStore);

        // String pageType = PageInfoHelper.getPrinterPageType();
        // String pageSize = PageInfoHelper.getLocaleSpecificPageType();
        // Point2D.Double point = (Point2D.Double)
        // nnn.getPaperSizesInInchesMap().get(pageSize);

        // double[] marginSizes = nnn.getDefaultMarginSizes();

        // store.setValue(WorkspaceViewerProperties.USE_WORKSPACE_PRINT_SETTINGS,
        // true);
        // store.setValue(WorkspaceViewerProperties.USE_DIAGRAM_PRINT_SETTINGS,
        // false);

        // store.setValue(WorkspaceViewerProperties.USE_INCHES, true);
        // store.setValue(WorkspaceViewerProperties.USE_MILLIMETRES, false);

        // store.setValue(WorkspaceViewerProperties.PAGE_ORIENTATION_LANDSCAPE,
        // false);
        // store.setValue(WorkspaceViewerProperties.PAGE_ORIENTATION_PORTRAIT,
        // true);

        // store.setValue(WorkspaceViewerProperties.PAGE_TYPE, pageSize);

        // store.setValue(WorkspaceViewerProperties.PAGE_WIDTH, point.x);
        // store.setValue(WorkspaceViewerProperties.PAGE_HEIGHT, point.y);

        // store.setValue(WorkspaceViewerProperties.MARGIN_LEFT,
        // marginSizes[0]);
        // store.setValue(WorkspaceViewerProperties.MARGIN_TOP, marginSizes[1]);
        // store.setValue(WorkspaceViewerProperties.MARGIN_RIGHT,
        // marginSizes[2]);
        // store.setValue(WorkspaceViewerProperties.MARGIN_BOTTOM,
        // marginSizes[3]);

        // Initialize printing defaults
d1207 2
a1208 29
            DefaultValues.DEFAULT_USE_WORKSPACE_SETTINGS);
        store.setValue(WorkspaceViewerProperties.PREF_USE_DIAGRAM_SETTINGS,
            DefaultValues.DEFAULT_USE_DIAGRAM_SETTINGS);

        store.setValue(WorkspaceViewerProperties.PREF_USE_INCHES,
            DefaultValues.DEFAULT_INCHES);
        store.setValue(WorkspaceViewerProperties.PREF_USE_MILLIM,
            DefaultValues.DEFAULT_MILLIM);

        store.setValue(WorkspaceViewerProperties.PREF_USE_PORTRAIT,
            DefaultValues.DEFAULT_PORTRAIT);
        store.setValue(WorkspaceViewerProperties.PREF_USE_LANDSCAPE,
            DefaultValues.DEFAULT_LANDSCAPE);

        store.setValue(WorkspaceViewerProperties.PREF_PAGE_SIZE, DefaultValues
            .getLocaleSpecificPageType().getName());
        store.setValue(WorkspaceViewerProperties.PREF_PAGE_WIDTH, DefaultValues
            .getLocaleSpecificPageType().getWidth());
        store.setValue(WorkspaceViewerProperties.PREF_PAGE_HEIGHT,
            DefaultValues.getLocaleSpecificPageType().getHeight());

        store.setValue(WorkspaceViewerProperties.PREF_MARGIN_TOP,
            DefaultValues.DEFAULT_MARGIN_TOP);
        store.setValue(WorkspaceViewerProperties.PREF_MARGIN_BOTTOM,
            DefaultValues.DEFAULT_MARGIN_BOTTOM);
        store.setValue(WorkspaceViewerProperties.PREF_MARGIN_LEFT,
            DefaultValues.DEFAULT_MARGIN_LEFT);
        store.setValue(WorkspaceViewerProperties.PREF_MARGIN_RIGHT,
            DefaultValues.DEFAULT_MARGIN_RIGHT);
d1210 47
d1260 4
a1263 4
     * Returns the workspace viewer <code>PreferenceStore</code>
     * 
     * @@return the workspace viewer <code>PreferenceStore</code>
     */
@


1.36
log
@[188974] gmf_head crevells 071211 [RulersGrid] GEF alignment feature missing
Contributed by:  Carson Li
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d117 1
d229 4
a232 10
            // No support for a context menu on the outline view for
            // release 6.0. See RATLC00529151, RATLC00529144
            // The selected item is a TreeEditPart which is not an
            // IGraphicalEditPart and many actions/commands don't support it
            // ContextMenuProvider provider = new DiagramContextMenuProvider(
            // DiagramEditor.this, getViewer());
            // getViewer().setContextMenu(provider);
            // this.getSite().registerContextMenu(
            // ActionIds.DIAGRAM_OUTLINE_CONTEXT_MENU, provider,
            // this.getSite().getSelectionProvider());
d445 14
@


1.35
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@d763 1
d832 1
a832 1

d834 1
a834 1

d1180 3
d1189 2
a1190 1
        store.setValue(WorkspaceViewerProperties.SNAPTOGRID, snapToGrid);
d1409 1
a1409 1
        // Snap to Grid
d1413 2
a1414 3
                WorkspaceViewerProperties.SNAPTOGRID)));

        // Hide/Show Grid
d1418 2
a1419 1
                WorkspaceViewerProperties.VIEWGRID)));
d1428 1
a1428 1
            SnapToGrid.PROPERTY_GRID_ORIGIN, origin);
@


1.34
log
@[167523] gmf_head crevells 070621 [DiagramEditor] Memory leak when saving as... for the diagram
@
text
@d80 1
d86 1
d1539 3
@


1.33
log
@[187771] gmf_head ahunter 070518 Add DiagramEditor.getContextID() method and use returned id in DiagramEditor.createPartControl()
@
text
@d30 1
a116 1
import org.eclipse.jface.util.Assert;
a133 1
import org.eclipse.ui.contexts.IContextActivation;
d153 1
a153 1
	public static String DIAGRAM_CONTEXT_ID = "org.eclipse.gmf.runtime.diagram.ui.diagramContext";
d1018 16
@


1.32
log
@gmf_head ahunter 070516 Update Copyright for files changed in 2007
@
text
@d1537 10
a1546 1
			contextService.activateContext(DIAGRAM_CONTEXT_ID);
@


1.32.2.1
log
@[111892] gmf_head crevells 070518 First milestone of group/ungroup support (painting issues when grouping shapes with border items)
@
text
@a29 1
import org.eclipse.core.runtime.Assert;
a78 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewType;
a83 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.TreeContainerEditPart;
d116 1
d134 1
d154 1
a154 1
	public static String DIAGRAM_CONTEXT_ID = "org.eclipse.gmf.runtime.diagram.ui.diagramContext"; //$NON-NLS-1$
d1520 6
a1525 9
                if (model instanceof Diagram) {
                    return new TreeDiagramEditPart(model);
                } else if (model instanceof View
                    && ViewType.GROUP.equals(((View) model).getType())) {
                    return new TreeContainerEditPart(model);
                } else {
                    return new TreeEditPart(model);
                }
            }
@


1.31
log
@[177937] gmf_head aboyko 070411 DuplicateAction shortcut conflicts with Debug's Display
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.30
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d134 2
d153 2
d1529 11
@


1.29
log
@bugzilla 142803 gmf-head sshaw 060531 Illegal Asynchronous Access to ResourceSetChangeEvent in DiagramEventBrokerThreadSafe
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 - 2006 IBM Corporation and others.
d76 1
d84 2
a93 2
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.TreeDiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.TreeEditPart;
a129 1
import org.eclipse.ui.IWorkbenchPage;
d221 2
a222 10
            getViewer().setEditPartFactory(new EditPartFactory() {

                public EditPart createEditPart(EditPart context, Object model) {
                    if (model instanceof Diagram) {
                        return new TreeDiagramEditPart(model);
                    } else {
                        return new TreeEditPart(model);
                    }
                }
            });
d247 1
d250 1
a250 1

d257 1
d742 6
a747 1
            action = new ToggleRouterAction((IWorkbenchPage) ((IWorkbenchPart) this).getSite().getPage());
d1012 1
d1488 37
@


1.29.2.1
log
@[110316] gmf_R1_0_maintenance mmostafa  060713 Compiler warning count should be 0 - runtime diagram layer components
@
text
@d129 1
d748 1
a748 1
            action = new ToggleRouterAction(((IWorkbenchPart) this).getSite().getPage());
@


1.29.2.2
log
@[150280] gmf_R1_0_maintenance ahunter 060717 Incorrect copyright in some GMF files
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.29.2.3
log
@[152020] gmf_R1_0_maintenace mmostafa 060727  Cannot perform save as when there are connectors on the diagram, and diagram becomes unusable
@
text
@a1011 1
            getDiagramGraphicalViewer().getContents().deactivate();
@


1.29.2.4
log
@[150057] gmf_R_1_0_maintenance aboyko 060802 Tooltips are needed for Outline Window buttons
@
text
@a253 1
            showOutlineAction.setToolTipText(DiagramUIMessages.OutlineView_OutlineTipText);
d256 1
a256 1
            	
a262 1
            showOverviewAction.setToolTipText(DiagramUIMessages.OutlineView_OverviewTipText);
@


1.29.2.5
log
@[132261] gmf_R1_0_maintenance ldamus 060810 Project explorer :  when you scroll using up/down keys, is slow : GMF tree selection change listener takes time
@
text
@a75 1
import org.eclipse.gmf.runtime.common.ui.util.IPartSelector;
a749 5
            ((ToggleRouterAction) action).setPartSelector(new IPartSelector() {
            	public boolean selects(IWorkbenchPart part) {
            		return part == DiagramEditor.this;
            	}
            });
@


1.29.2.6
log
@[157023] gmf_R1_0_maintenace wdiu 060913  Cannot selectively enable or disable whether a properties contributor is read only with IReadOnlyDiagramPropertySheetPageContributor
@
text
@a1495 18
    
    /**
     * Returns false if the editor is read only and returns true if the editor
     * is writable.
     * 
     * By default, edit parts have their edit mode enabled and this method
     * returns true.
     * 
     * Subclasses may override and disable the edit mode on parts.
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IEditableEditPart.
     * 
     * @@return false if the editor is read only and returns true if the editor
     * is writable.
     */
    public boolean isWritable() {
        return (getDiagramEditPart() != null && getDiagramEditPart().isEditModeEnabled());
    }
@


1.29.2.7
log
@[153305] draw2d_maintenace aboyko 060914  compartment items not shown in outline view (tree)
@
text
@a83 2
import org.eclipse.gmf.runtime.diagram.ui.editparts.TreeDiagramEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.TreeEditPart;
d92 2
d221 10
a230 2
            getViewer().setEditPartFactory(getOutlineViewEditPartFactory());
            
a1513 19
    
    /**
     * Creates edit part factory that will be creating tree edit parts in
     * the tree viewer
     * @@return <code>EditPartFactory</code> factory for the tree viewer
     */
    protected EditPartFactory getOutlineViewEditPartFactory() {
		return new EditPartFactory() {

			public EditPart createEditPart(EditPart context, Object model) {
				if (model instanceof Diagram) {
					return new TreeDiagramEditPart(model);
				} else {
					return new TreeEditPart(model);
				}
			}
		};
	}

@


1.28
log
@Bugzilla#129244 gmf_head cmahoney 060525 Bookmarks don't work in Geoshapes and Logic examples
@
text
@a29 1
import org.eclipse.core.resources.IMarker;
a43 1
import org.eclipse.emf.transaction.ResourceSetChangeEvent;
a75 1
import org.eclipse.gmf.runtime.common.ui.services.marker.MarkerNavigationService;
a132 1
import org.eclipse.ui.PlatformUI;
a959 37

    private class DiagramEventBrokerThreadSafe extends DiagramEventBroker {

        public DiagramEventBrokerThreadSafe() {
            super();
            // TODO Auto-generated constructor stub
        }

        /* (non-Javadoc)
         * @@see org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker#resourceSetChanged(org.eclipse.emf.transaction.ResourceSetChangeEvent)
         */
        public void resourceSetChanged(ResourceSetChangeEvent event) {
            if (Display.getCurrent() == null) {
                EditPartViewer viewer = getDiagramGraphicalViewer();
                if (viewer instanceof DiagramGraphicalViewer) {
                    DiagramGraphicalViewer dgv = (DiagramGraphicalViewer)viewer;
                    if (!dgv.areUpdatesDisabled()) {
                        // force synchronization with the main thread
                        final ResourceSetChangeEvent eventToHandle = event;
                        PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() { 
                            public void run() {
                                internal_resourceSetChanged(eventToHandle);
                            }
                        });
                        
                        return;
                    }
                }
            }
            
            super.resourceSetChanged(event);
        }
        
        private void internal_resourceSetChanged(ResourceSetChangeEvent event) {
            super.resourceSetChanged(event);
        }
    };
d982 1
a982 1
                DiagramEventBroker.startListening(domain, new DiagramEventBrokerThreadSafe());
@


1.27
log
@bugzilla 140488 gmf-head sshaw 060512 Adding shapes to a diagarm on a different thread makes diagram unusable
@
text
@a1141 10
     * go to a specific marker
     * 
     * @@param marker
     *            marker to use
     */
    public final void gotoMarker(IMarker marker) {
        MarkerNavigationService.getInstance().gotoMarker(this, marker);
    }

    /**
@


1.26
log
@bugzilla 141551 gmf-head mmostafa 060512 Memory leaks in the Diagram layer cause the edit parts to stay in memory
@
text
@d45 1
d136 1
d965 37
d1023 1
a1023 1
                DiagramEventBroker.startListening(domain);
@


1.25
log
@bugzilla 111897 gmf-head tmacdoug 060511 No accelerators for line styles or zoom
@
text
@a921 1
        startListening();
d924 1
@


1.24
log
@bugzilla 136582 gmf-head sshaw 060413 Refactor DirectEditRequestWrapper in public API
@
text
@d66 2
d91 1
d131 1
d740 15
d762 15
a776 3
            KeyStroke.getPressed((char) 0x4, 100, SWT.CTRL),
                getActionRegistry().getAction(
                    ActionIds.ACTION_DELETE_FROM_MODEL));
@


1.23
log
@bugzilla 133029 gmf-head sshaw 060411 DiagramEditor doesn't propagate init() exceptions properly
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d10 1
d96 1
d807 4
a810 2
        viewer.setKeyHandler(new DiagramGraphicalViewerKeyHandler(viewer)
            .setParent(getKeyHandler()));
@


1.22
log
@[133879] gmf_head ldamus 060329 Copying a shape on the diagram clears the undo history
@
text
@d639 3
a642 1
            super.init(site, input);
a644 4
            // RATLC 524435
            // As discussed with Steve, Removing the Log and removing the
            // standard message and replacing it with one obtained from the
            // Exception.
d646 6
a651 3
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "init", e); //$NON-NLS-1$
            throw new PartInitException(e.getMessage(), e);
@


1.21
log
@bugzilla 132032 gmf-head sshaw 060323 Can't drop a semantic element onto a diagram from non-UI thread
@
text
@d958 5
a962 2
            // dispose my undo context
            getOperationHistory().dispose(getUndoContext(), true, true, true);
@


1.20
log
@[130641] gmf_head ldamus 060306 Overriding the disposal of the DiagramEditor undo context is inconvenient
@
text
@d122 1
d430 7
d469 1
d473 33
d692 5
d940 5
d964 5
@


1.19
log
@Bugzilla#129785 Undo/redo doesn't work after making changes in property pages
@
text
@d645 3
a648 2
        // dispose my undo context
        getOperationHistory().dispose(getUndoContext(), true, true, true);
d888 1
a888 1
            if (historyListener != null) {
d906 3
@


1.18
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d138 3
a140 3
 *
 * A generic diagram editor with no palette.
 * DiagramEditorWithPalette will provide a palette.
d143 3
a145 2
	extends GraphicalEditor
	implements IDiagramWorkbenchPart, ITabbedPropertySheetPageContributor, IShowInSource {
d147 9
a155 234
	/**
	 * teh ID of the outline
	 */
	protected static final int ID_OUTLINE = 0;

	/**
	 * the id of the over view
	 */
	protected static final int ID_OVERVIEW = 1;

	/**
	 * the work space viewer preference store
	 */
	protected PreferenceStore workspaceViewerPreferenceStore = null;

	/**
	 * A diagram outline page
	 */
	class DiagramOutlinePage
		extends ContentOutlinePage
		implements IAdaptable {

		private PageBook pageBook;

		private Control outline;

		private Canvas overview;

		private IAction showOutlineAction, showOverviewAction;

		private boolean overviewInitialized;

		private Thumbnail thumbnail;

		private DisposeListener disposeListener;

		/**
		 * @@param viewer
		 */
		public DiagramOutlinePage(EditPartViewer viewer) {
			super(viewer);
		}

		/* (non-Javadoc)
		 * @@see org.eclipse.ui.part.Page#init(org.eclipse.ui.part.IPageSite)
		 */
		public void init(IPageSite pageSite) {
			super.init(pageSite);
			ActionRegistry registry = getActionRegistry();
			IActionBars bars = pageSite.getActionBars();
			String id = ActionFactory.UNDO.getId();
			bars.setGlobalActionHandler(id, registry.getAction(id));
			id = ActionFactory.REDO.getId();
			bars.setGlobalActionHandler(id, registry.getAction(id));
			id = ActionFactory.DELETE.getId();
			bars.setGlobalActionHandler(id, registry.getAction(id));
			bars.updateActionBars();

			// Toolbar refresh to solve linux defect RATLC525198 
			bars.getToolBarManager().markDirty();
		}

		/**
		 * configures the outline viewer
		 */
		protected void configureOutlineViewer() {
			getViewer().setEditDomain(getEditDomain());
			getViewer().setEditPartFactory(new EditPartFactory() {

				public EditPart createEditPart(EditPart context, Object model) {
					if (model instanceof Diagram) {
						return new TreeDiagramEditPart(model);
					} else {
						return new TreeEditPart(model);
					}
				}
			});
			// No support for a context menu on the outline view for
			// release 6.0.  See RATLC00529151, RATLC00529144
			// The selected item is a TreeEditPart which is not an
			// IGraphicalEditPart and many actions/commands don't support it
//			ContextMenuProvider provider = new DiagramContextMenuProvider(
//				DiagramEditor.this, getViewer());
//			getViewer().setContextMenu(provider);
//			this.getSite().registerContextMenu(
//				ActionIds.DIAGRAM_OUTLINE_CONTEXT_MENU, provider,
//				this.getSite().getSelectionProvider());
			
			getViewer().setKeyHandler(getKeyHandler());
			//getViewer().addDropTargetListener(
			//  new LogicTemplateTransferDropTargetListener(getViewer()));
			IToolBarManager tbm = this.getSite().getActionBars()
				.getToolBarManager();
			showOutlineAction = new Action() {

				public void run() {
					showPage(ID_OUTLINE);
				}
			};
			showOutlineAction.setImageDescriptor(DiagramUIPluginImages.DESC_OUTLINE);
			tbm.add(showOutlineAction);
			showOverviewAction = new Action() {

				public void run() {
					showPage(ID_OVERVIEW);
				}
			};
			showOverviewAction.setImageDescriptor(DiagramUIPluginImages.DESC_OVERVIEW);
			tbm.add(showOverviewAction);
			showPage(getDefaultOutlineViewMode());
		}

		public void createControl(Composite parent) {
			pageBook = new PageBook(parent, SWT.NONE);
			outline = getViewer().createControl(pageBook);
			overview = new Canvas(pageBook, SWT.NONE);
			pageBook.showPage(outline);
			configureOutlineViewer();
			hookOutlineViewer();
			initializeOutlineViewer();
		}

		public void dispose() {
			unhookOutlineViewer();
			if (thumbnail != null) {
				thumbnail.deactivate();
			}
			this.overviewInitialized = false;
			super.dispose();
		}

		public Object getAdapter(Class type) {
			//	if (type == ZoomManager.class)
			//		return getZoomManager();
			return null;
		}

		public Control getControl() {
			return pageBook;
		}

		/**
		 * hook the outline viewer
		 */
		protected void hookOutlineViewer() {
			getSelectionSynchronizer().addViewer(getViewer());
		}

		/**
		 * initialize the outline viewer
		 */
		protected void initializeOutlineViewer() {
			try {
				TransactionUtil.getEditingDomain(getDiagram())
					.runExclusive(new Runnable() {

					public void run() {
						getViewer().setContents(getDiagram());
					}
				});
			} catch (InterruptedException e) {
				Trace.catching(DiagramUIPlugin.getInstance(),
					DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
					"initializeOutlineViewer", e); //$NON-NLS-1$
				Log.error(DiagramUIPlugin.getInstance(),
					DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
					"initializeOutlineViewer", e); //$NON-NLS-1$
			}
		}

		/**
		 * initialize the overview
		 */
		protected void initializeOverview() {
			LightweightSystem lws = new LightweightSystem(overview);
			RootEditPart rep = getGraphicalViewer().getRootEditPart();
			DiagramRootEditPart root = (DiagramRootEditPart) rep;
			thumbnail = new ScrollableThumbnail((Viewport) root.getFigure());
			//thumbnail.setSource(root.getLayer(LayerConstants.PRINTABLE_LAYERS));
			thumbnail.setSource(root.getLayer(LayerConstants.SCALABLE_LAYERS));

			lws.setContents(thumbnail);
			disposeListener = new DisposeListener() {

				public void widgetDisposed(DisposeEvent e) {
					if (thumbnail != null) {
						thumbnail.deactivate();
						thumbnail = null;
					}
				}
			};
			getEditor().addDisposeListener(disposeListener);
			this.overviewInitialized = true;
		}

		/**
		 * show page with a specific ID, possibel values are 
		 * ID_OUTLINE and ID_OVERVIEW
		 * @@param id
		 */
		protected void showPage(int id) {
			if (id == ID_OUTLINE) {
				showOutlineAction.setChecked(true);
				showOverviewAction.setChecked(false);
				pageBook.showPage(outline);
				if (thumbnail != null)
					thumbnail.setVisible(false);
			} else if (id == ID_OVERVIEW) {
				if (!overviewInitialized)
					initializeOverview();
				showOutlineAction.setChecked(false);
				showOverviewAction.setChecked(true);
				pageBook.showPage(overview);
				thumbnail.setVisible(true);
			}
		}

		/**
		 * unhook the outline viewer
		 */
		protected void unhookOutlineViewer() {
			getSelectionSynchronizer().removeViewer(getViewer());
			if (disposeListener != null && getEditor() != null
				&& !getEditor().isDisposed())
				getEditor().removeDisposeListener(disposeListener);
		}

		/**
		 * getter for the editor conrolo
		 * @@return <code>Control</code>
		 */
		protected Control getEditor() {
			return getGraphicalViewer().getControl();
		}
d157 232
a388 1
	}
d400 2
a401 2
	/** The key handler */
	private KeyHandler keyHandler;
d403 12
a414 11
	/** The workbench site
	 *  This variable overrides another one defined in <code>org.eclipse.ui.part<code>
	 *  This is needed to override <code>setSite</code> to simply set the site, rather than also
	 *  initializing the actions like <code>setSite</code> override in <code>org.eclipse.gef.ui.parts</code>
	 */
	private IWorkbenchPartSite partSite;

	/** The RulerComposite used to enhance the graphical viewer to display
	 *  rulers
	 */
	private RulerComposite rulerComposite;
d416 1
a416 1
	/**
d420 1
a420 1
    
d428 31
a458 27
	/**
	 * Returns this editor's outline-page default display mode. 
	 * @@return int the integer value indicating the content-outline-page dispaly mode 
	 */
	protected int getDefaultOutlineViewMode() {
		return ID_OVERVIEW;
	}

	/**
	 * @@return Returns the rulerComp.
	 */
	protected RulerComposite getRulerComposite() {
		return rulerComposite;
	}

	/**
	 * @@param rulerComp The rulerComp to set.
	 */
	protected void setRulerComposite(RulerComposite rulerComp) {
		this.rulerComposite = rulerComp;
	}
	/**
	 * Creates a new DiagramEditor instance
	 */
	public DiagramEditor() {
		createDiagramEditDomain();
        
d461 1
a461 4
        if (historyListener != null) {
            getOperationHistory().addOperationHistoryListener(historyListener);
	}
	}
d463 1
a463 1
	/**
d481 1
a481 1
                    
d491 1
a491 1
        
d532 46
a577 46
	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramEditDomain()
	 */
	public IDiagramEditDomain getDiagramEditDomain() {
		return (IDiagramEditDomain) getEditDomain();
	}

	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramGraphicalViewer()
	 */
	public IDiagramGraphicalViewer getDiagramGraphicalViewer() {
		return (IDiagramGraphicalViewer) getGraphicalViewer();
	}

	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagram()
	 */
	public Diagram getDiagram() {
		if (getEditorInput() != null)
			return ((IDiagramEditorInput) getEditorInput()).getDiagram();
		return null;
	}

	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramEditPart()
	 */
	public DiagramEditPart getDiagramEditPart() {
		return (DiagramEditPart) getDiagramGraphicalViewer().getContents();
	}

	/**
	 * @@see org.eclipse.core.runtime.IAdaptable#getAdapter(Class)
	 */
	public Object getAdapter(Class type) {		
		if (type == IContentOutlinePage.class) {
			TreeViewer viewer = new TreeViewer();
			viewer.setRootEditPart(new DiagramRootTreeEditPart());
			return new DiagramOutlinePage(viewer);
		}
		if (ActionManager.class == type)
			return getActionManager();
		if (IDiagramEditDomain.class == type)
			return getDiagramEditDomain();
		if (type == ZoomManager.class)
			return getZoomManager();
        
d587 51
a637 48
        
        
		return super.getAdapter(type);

	}

	/**
	 * @@see org.eclipse.ui.IEditorPart#init(IEditorSite, IEditorInput)
	 */
	public void init(IEditorSite site, IEditorInput input)
		throws PartInitException {
		try {
			super.init(site, input);
			EditorService.getInstance().registerEditor(this);
		} catch (Exception e) {
			//	RATLC 524435
			//	As discussed with Steve, Removing the Log and removing the 
			//	standard message and replacing it with one obtained from the
			//	Exception.
			Trace.catching(DiagramUIPlugin.getInstance(), DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(), "init", e); //$NON-NLS-1$
			throw new PartInitException(e.getMessage(), e);
		}
	}

	/**
	 * Disposes this editor by:
	 * <br> 3. Stops all registered listeners
	 * @@see org.eclipse.ui.IWorkbenchPart#dispose()
	 */
	public void dispose() {
		persistViewerSettings();
		EditorService.getInstance().unregisterEditor(DiagramEditor.this);
		stopListening();

		/*
		 * RATLC00527385 DiagramRulerProvider wasn't uninitialized on dispose of the editor.
		 */
		DiagramRulerProvider vertProvider = (DiagramRulerProvider) getDiagramGraphicalViewer()
			.getProperty(RulerProvider.PROPERTY_VERTICAL_RULER);
		if (vertProvider != null)
			vertProvider.uninit();

		// Set the Horizontal Ruler properties
		DiagramRulerProvider horzProvider = (DiagramRulerProvider) getDiagramGraphicalViewer()
			.getProperty(RulerProvider.PROPERTY_HORIZONTAL_RULER);
		if (horzProvider != null)
			horzProvider.uninit();
        
d649 127
a775 2
		super.dispose();
	}
d777 4
a780 128
	/**
	 * Returns the KeyHandler with common bindings for both the Outline and Graphical Views.
	 * For example, delete is a common action.
	 * @@return KeyHandler
	 */
	protected KeyHandler getKeyHandler() {
		if (keyHandler == null) {
			keyHandler = new KeyHandler();

			ActionRegistry registry = getActionRegistry();
			IAction action;

			action = new PromptingDeleteAction(this);
			action.setText(DiagramUIMessages.DiagramEditor_Delete_from_Diagram); 
			registry.registerAction(action);
			getSelectionActions().add(action.getId());

			action = new InsertAction(this);
			action.setText(""); //$NON-NLS-1$ // no text necessary since this is not a visible action
			registry.registerAction(action);
			getSelectionActions().add(action.getId());

			PromptingDeleteFromModelAction deleteModelAction = new PromptingDeleteFromModelAction(
				this);
			deleteModelAction.init();

			registry.registerAction(deleteModelAction);

			action = new DirectEditAction((IWorkbenchPart) this);
			registry.registerAction(action);
			getSelectionActions().add(action.getId());

			keyHandler.put(KeyStroke.getPressed(SWT.INSERT, 0),
				getActionRegistry().getAction(InsertAction.ID));
			keyHandler.put(KeyStroke.getPressed(SWT.DEL, 127, 0),
				getActionRegistry().getAction(ActionFactory.DELETE.getId()));
			keyHandler.put(KeyStroke.getPressed(SWT.BS, 8, 0),
				getActionRegistry().getAction(ActionFactory.DELETE.getId()));
			keyHandler.put(/* CTRL + D */
			KeyStroke.getPressed((char) 0x4, 100, SWT.CTRL),
				getActionRegistry().getAction(
					ActionIds.ACTION_DELETE_FROM_MODEL));
			keyHandler.put(KeyStroke.getPressed(SWT.F2, 0), getActionRegistry()
				.getAction(GEFActionConstants.DIRECT_EDIT));
		}
		return keyHandler;
	}

	/**
	 * @@see org.eclipse.gef.ui.parts.GraphicalEditor#createGraphicalViewer(Composite)
	 */
	protected void createGraphicalViewer(Composite parent) {
		setRulerComposite(new RulerComposite(parent, SWT.NONE));

		ScrollingGraphicalViewer sGViewer = createScrollingGraphicalViewer();					
		sGViewer.createControl(getRulerComposite());
		setGraphicalViewer(sGViewer);
		hookGraphicalViewer();
		configureGraphicalViewer();
		initializeGraphicalViewer(); 
		getRulerComposite()
			.setGraphicalViewer((ScrollingGraphicalViewer) getGraphicalViewer());
	}

	/**
	 * Creates a ScrollingGraphicalViewer without the drop adapter which  
	 * excludes drag and drop functionality from other defined views (XML)
	 * Subclasses must override this method to include the DnD functionality
	 * 
	 * @@return ScrollingGraphicalViewer
	 */
	protected ScrollingGraphicalViewer createScrollingGraphicalViewer() {
		return new DiagramGraphicalViewer();
	}

	/**
	 * Configures the graphical viewer (the primary viewer of the editor)
	 */
	protected void configureGraphicalViewer() {
		super.configureGraphicalViewer();
		
		IDiagramGraphicalViewer viewer = getDiagramGraphicalViewer();
		
		RootEditPart rootEP = EditPartService.getInstance()
			.createRootEditPart(getDiagram());
		if (rootEP instanceof IDiagramPreferenceSupport) {
			((IDiagramPreferenceSupport) rootEP)
				.setPreferencesHint(getPreferencesHint());
		}

		if (getDiagramGraphicalViewer() instanceof DiagramGraphicalViewer) {
			((DiagramGraphicalViewer) getDiagramGraphicalViewer())
				.hookWorkspacePreferenceStore(getWorkspaceViewerPreferenceStore());
		}

		viewer.setRootEditPart(rootEP);
		
		viewer.setEditPartFactory(EditPartService.getInstance());
		ContextMenuProvider provider = new DiagramContextMenuProvider(this,
			viewer);
		viewer.setContextMenu(provider);
		getSite().registerContextMenu(ActionIds.DIAGRAM_EDITOR_CONTEXT_MENU,
			provider, viewer);
		viewer.setKeyHandler(new DiagramGraphicalViewerKeyHandler(viewer)
			.setParent(getKeyHandler()));
		((FigureCanvas) viewer.getControl())
			.setScrollBarVisibility(FigureCanvas.ALWAYS);
	}

	/**
	 * @@see org.eclipse.gef.ui.parts.GraphicalEditor#initializeGraphicalViewer()
	 */
	protected void initializeGraphicalViewer() {
		initializeGraphicalViewerContents();
	}

	/**
	 * @@see org.eclipse.gef.ui.parts.GraphicalEditor#initializeGraphicalViewer()
	 */
	protected void initializeGraphicalViewerContents() {
		getDiagramGraphicalViewer().setContents(getDiagram());
		initializeContents(getDiagramEditPart());
	}

	/**
	 * Creates a diagram edit domain
	 */
	protected void createDiagramEditDomain() {
d783 2
a784 2
		setEditDomain(editDomain);
	}
d786 1
a786 1
	/**
d788 2
a789 2
	 */
	protected void configureDiagramEditDomain() {
d799 1
a799 1
	}
d802 2
a803 1
            DiagramCommandStack diagramStack = new DiagramCommandStack(getDiagramEditDomain());
d812 2
a813 2
    
	/**
d819 1
a819 1
    
d829 9
a837 9
	/**
	 * @@see org.eclipse.ui.part.EditorPart#setInput(IEditorInput)
	 */
	protected void setInput(IEditorInput input) {
		stopListening();
		super.setInput(input);
		if(input != null) {
			Assert.isNotNull(getDiagram(), "Couldn't load/create diagram view"); //$NON-NLS-1$
 		}
d841 1
a841 1
	}
d843 104
a946 90
	/** 
	 * Do nothing
	 * @@see org.eclipse.gef.ui.parts.GraphicalEditor#initializeActionRegistry()
	 */
	protected void createActions() {
		// null impl.
	}

	/**
	 * A utility to close the editor
	 * @@param save
	 */
	protected void closeEditor(final boolean save) {
		// Make this call synchronously to avoid the following sequence:
		// Select me, select the model editor, close the model editor, 
		// closes the model, fires events causing me to close, 
		// if actual close is delayed using an async call then eclipse 
		// tries to set the selection back to me when the model editor
		// finishes being disposed, but model has been closed so I
		// am no longer connected to the model, NullPointerExceptions occur.
		try {
			getSite().getPage().closeEditor(DiagramEditor.this, save);
		} catch (SWTException e) {
			// TODO remove when "Widget is disposed" exceptions are fixed.
			// Temporarily catch SWT exceptions here to allow model server event
			// processing to continue.
			Trace.catching(DiagramUIPlugin.getInstance(),
				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, this.getClass(),
				"closeEditor", e); //$NON-NLS-1$
			Log.error(DiagramUIPlugin.getInstance(), IStatus.ERROR, e
				.getMessage(), e);
		}
	}

	/**
	 * Installs all the listeners needed by the editor
	 */
	protected void startListening() {		
		// Create a diagram event broker if there isn't already one for this editing domain.
		TransactionalEditingDomain domain = getEditingDomain();
		if (domain != null) {
			DiagramEventBroker eventBroker = DiagramEventBroker.getInstance(domain);
			if (eventBroker == null) {
				DiagramEventBroker.startListening(domain);
			}
		}
	}

	/**
	 * Removes all the listeners used by the editor
	 */
	protected void stopListening() {
		// do nothing
	}

	/**
	 * Clears the contents of the graphical viewer
	 */
	protected void clearGraphicalViewerContents() {
		if (getDiagramGraphicalViewer().getContents() != null) {
			getDiagramGraphicalViewer().getContents().removeNotify();
		}
		getDiagramGraphicalViewer().setContents(null);
	}

	/**
	 * Gets the action manager for this diagram editor. The action manager's 
	 * command manager is used by my edit domain's command stack when executing
	 * commands. This is the action manager that is returned when I am asked
	 * to adapt to an <code>ActionManager</code>.
	 * 
	 * @@return the action manager
	 */
	protected ActionManager getActionManager() {
		return getDiagramEditDomain().getActionManager();
	}

	/**
	 * A utility method to return the zoom manager from the graphical viewer's root
	 * @@return the zoom manager
	 */
	protected ZoomManager getZoomManager() {
		return ((DiagramRootEditPart) getRootEditPart()).getZoomManager();
	}

	private RootEditPart getRootEditPart() {
		return getGraphicalViewer().getRootEditPart();		
	}
	
	/**
d948 1
a948 1
	 * 
d950 1
a950 1
	 */
d953 1
a953 1
	}
d955 1
a955 1
	/**
d958 3
a960 3
     * If subclasses have a known editing domain, they should override this method
     * to return that editing domain as that will be more efficient that the
     * generic implementation provided here.
d965 1
a965 1
    	if (getDiagram() != null) {
d970 1
a970 1
    
d991 1
a991 1
    
d1002 2
a1003 2
	/**
	 * go to a specific marker
d1007 393
a1399 358
	 */
	public final void gotoMarker(IMarker marker) {
		MarkerNavigationService.getInstance().gotoMarker(this, marker);
	}

	/**
	 * 
	 * @@return The getRulerComposite(), which is the graphical control
	 */
	protected Control getGraphicalControl() {
		return getRulerComposite();

	}

	/**
	 * @@see org.eclipse.ui.IWorkbenchPart#getSite()
	 */
	public IWorkbenchPartSite getSite() {
		return partSite;
	}

	/**
	 * @@see org.eclipse.ui.part.WorkbenchPart#setSite(IWorkbenchPartSite)
	 */
	protected void setSite(IWorkbenchPartSite site) {
		this.partSite = site;

	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.ui.properties.ITabbedPropertySheetPageContributor#getContributorId()
	 */
	public String getContributorId() {
		return "org.eclipse.gmf.runtime.diagram.ui.properties"; //$NON-NLS-1$
	}

	/**
	 * Adds the default preferences to the specified preference store.
	 * @@param store store to use
	 * @@param preferencesHint
	 *            The preference hint that is to be used to find the appropriate
	 *            preference store from which to retrieve diagram preference
	 *            values. The preference hint is mapped to a preference store in
	 *            the preference registry <@@link DiagramPreferencesRegistry>.
	 */
	public static void addDefaultPreferences(PreferenceStore store, PreferencesHint preferencesHint) {
		store.setValue(WorkspaceViewerProperties.ZOOM, 1.0);
		store.setValue(WorkspaceViewerProperties.VIEWPAGEBREAKS, false);

		IPreferenceStore globalPreferenceStore = (IPreferenceStore) preferencesHint.getPreferenceStore();

		// Initialize with the global settings
		boolean viewGrid = globalPreferenceStore
			.getBoolean(IPreferenceConstants.PREF_SHOW_GRID);

		boolean snapToGrid = globalPreferenceStore
			.getBoolean(IPreferenceConstants.PREF_SNAP_TO_GRID);

		boolean viewRulers = globalPreferenceStore
			.getBoolean(IPreferenceConstants.PREF_SHOW_RULERS);

		// Set defaults for Grid
		store.setValue(WorkspaceViewerProperties.VIEWGRID, viewGrid);
		store.setValue(WorkspaceViewerProperties.SNAPTOGRID, snapToGrid);

		// Set defaults for Rulers
		store.setValue(WorkspaceViewerProperties.VIEWRULERS, viewRulers);

		// Set defaults for Page Setup Dialog
		//PSDialog.initDefaultPreferences(store);
		
		//PSDefault.initDefaultPSPreferencePagePreferences(globalPreferenceStore);
		
		//String pageType = PageInfoHelper.getPrinterPageType();
		//String pageSize = PageInfoHelper.getLocaleSpecificPageType();
		//Point2D.Double point = (Point2D.Double) nnn.getPaperSizesInInchesMap().get(pageSize);
		
		//double[] marginSizes = nnn.getDefaultMarginSizes();
		
		//store.setValue(WorkspaceViewerProperties.USE_WORKSPACE_PRINT_SETTINGS, true);
		//store.setValue(WorkspaceViewerProperties.USE_DIAGRAM_PRINT_SETTINGS, false);
		
		//store.setValue(WorkspaceViewerProperties.USE_INCHES, true);
		//store.setValue(WorkspaceViewerProperties.USE_MILLIMETRES, false);
		
		//store.setValue(WorkspaceViewerProperties.PAGE_ORIENTATION_LANDSCAPE, false);
		//store.setValue(WorkspaceViewerProperties.PAGE_ORIENTATION_PORTRAIT, true);
		
		//store.setValue(WorkspaceViewerProperties.PAGE_TYPE, pageSize);
		
		//store.setValue(WorkspaceViewerProperties.PAGE_WIDTH, point.x);
		//store.setValue(WorkspaceViewerProperties.PAGE_HEIGHT, point.y);
		
		//store.setValue(WorkspaceViewerProperties.MARGIN_LEFT, marginSizes[0]);
		//store.setValue(WorkspaceViewerProperties.MARGIN_TOP, marginSizes[1]);
		//store.setValue(WorkspaceViewerProperties.MARGIN_RIGHT, marginSizes[2]);
		//store.setValue(WorkspaceViewerProperties.MARGIN_BOTTOM, marginSizes[3]);
		
		// Initialize printing defaults
		store.setValue(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS, DefaultValues.DEFAULT_USE_WORKSPACE_SETTINGS);
		store.setValue(WorkspaceViewerProperties.PREF_USE_DIAGRAM_SETTINGS, DefaultValues.DEFAULT_USE_DIAGRAM_SETTINGS);
			
		store.setValue(WorkspaceViewerProperties.PREF_USE_INCHES, DefaultValues.DEFAULT_INCHES);
		store.setValue(WorkspaceViewerProperties.PREF_USE_MILLIM, DefaultValues.DEFAULT_MILLIM);
		
		store.setValue(WorkspaceViewerProperties.PREF_USE_PORTRAIT, DefaultValues.DEFAULT_PORTRAIT);
		store.setValue(WorkspaceViewerProperties.PREF_USE_LANDSCAPE, DefaultValues.DEFAULT_LANDSCAPE);
		
		store.setValue(WorkspaceViewerProperties.PREF_PAGE_SIZE, DefaultValues.getLocaleSpecificPageType().getName());
		store.setValue(WorkspaceViewerProperties.PREF_PAGE_WIDTH, DefaultValues.getLocaleSpecificPageType().getWidth());
		store.setValue(WorkspaceViewerProperties.PREF_PAGE_HEIGHT, DefaultValues.getLocaleSpecificPageType().getHeight());
		
		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_TOP, DefaultValues.DEFAULT_MARGIN_TOP);
		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_BOTTOM, DefaultValues.DEFAULT_MARGIN_BOTTOM);
		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_LEFT, DefaultValues.DEFAULT_MARGIN_LEFT);
		store.setValue(WorkspaceViewerProperties.PREF_MARGIN_RIGHT, DefaultValues.DEFAULT_MARGIN_RIGHT);
		
	}

	/**
	 * Returns the workspace viewer <code>PreferenceStore</code>
	 * @@return	the workspace viewer <code>PreferenceStore</code>
	 */
	public PreferenceStore getWorkspaceViewerPreferenceStore() {
		if (workspaceViewerPreferenceStore != null) {
			return workspaceViewerPreferenceStore;
		} else {
			// Try to load it
			IPath path = DiagramUIPlugin.getInstance()
				.getStateLocation();
			String id = ViewUtil.getIdStr(getDiagram());

			String fileName = path.toString() + "/" + id;//$NON-NLS-1$
			java.io.File file = new File(fileName);
			workspaceViewerPreferenceStore = new PreferenceStore(fileName);
			if (file.exists()) {
				// Load it
				try {
					workspaceViewerPreferenceStore.load();
				} catch (Exception e) {
					// Create the default
					addDefaultPreferences();
				}
			} else {
				// Create it
				addDefaultPreferences();
			}
			return workspaceViewerPreferenceStore;
		}
	}

	/**
	 * Adds the default preferences to the workspace viewer preference store.
	 */
	protected void addDefaultPreferences() {
		addDefaultPreferences(workspaceViewerPreferenceStore, getPreferencesHint());
	}

	/**
	 * Persists the viewer settings to which this RootEditPart belongs. This method should
	 * be called when the diagram is being disposed.
	 */
	public void persistViewerSettings() {
		Viewport viewport = getDiagramEditPart().getViewport();
		if (viewport != null) {
			int x = viewport.getHorizontalRangeModel().getValue();
			int y = viewport.getVerticalRangeModel().getValue();
			getWorkspaceViewerPreferenceStore().setValue(
				WorkspaceViewerProperties.VIEWPORTX, x);
			getWorkspaceViewerPreferenceStore().setValue(
				WorkspaceViewerProperties.VIEWPORTY, y);
		}
		getWorkspaceViewerPreferenceStore().setValue(
			WorkspaceViewerProperties.ZOOM, getZoomManager().getZoom());

		// Write the settings, if necessary
		try {
			if (getWorkspaceViewerPreferenceStore().needsSaving())
				getWorkspaceViewerPreferenceStore().save();
		} catch (IOException ioe) {
			Trace.catching(DiagramUIPlugin.getInstance(),
				DiagramUIDebugOptions.EXCEPTIONS_CATCHING,
				PageInfoHelper.class, "persistViewerSettings", //$NON-NLS-1$
				ioe);
		}
	}


	/**
	 * Initializes the viewer's state from the workspace preference store.
	 * @@param editpart
	 */
	private void initializeContents(EditPart editpart) {
		getZoomManager().setZoom(
			getWorkspaceViewerPreferenceStore().getDouble(
				WorkspaceViewerProperties.ZOOM));

		if (getWorkspaceViewerPreferenceStore().getBoolean(WorkspaceViewerProperties.VIEWPAGEBREAKS)) {
			getDiagramEditPart().getFigure().invalidate();
			getDiagramEditPart().getFigure().validate();
		}
		getDiagramEditPart().refreshPageBreaks();
		
		// Update the range model of the viewport
		((DiagramEditPart) editpart).getViewport().validate();		
		if (editpart instanceof DiagramEditPart) {
			int x = getWorkspaceViewerPreferenceStore().getInt(
				WorkspaceViewerProperties.VIEWPORTX);
			int y = getWorkspaceViewerPreferenceStore().getInt(
				WorkspaceViewerProperties.VIEWPORTY);
			((DiagramEditPart) editpart).getViewport()
				.getHorizontalRangeModel().setValue(x);
			((DiagramEditPart) editpart).getViewport().getVerticalRangeModel()
				.setValue(y);
		}

		// Get the Ruler Units properties
		int rulerUnits = getWorkspaceViewerPreferenceStore().getInt(WorkspaceViewerProperties.RULERUNIT);

		// Get the Guide Style
		GuideStyle guideStyle = (GuideStyle) getDiagram().getStyle(
			NotationPackage.eINSTANCE.getGuideStyle());
		
		
		if (guideStyle != null) {

			RootEditPart rep = getGraphicalViewer().getRootEditPart();
			DiagramRootEditPart root = (DiagramRootEditPart) rep;
			
			// Set the Vertical Ruler properties
			DiagramRuler verticalRuler = ((DiagramRootEditPart) getRootEditPart()).getVerticalRuler();
			verticalRuler.setGuideStyle(guideStyle);
			verticalRuler.setUnit(rulerUnits);
			DiagramRulerProvider vertProvider = new DiagramRulerProvider(getEditingDomain(),
				verticalRuler, root.getMapMode());
			vertProvider.init();
			getDiagramGraphicalViewer().setProperty(
				RulerProvider.PROPERTY_VERTICAL_RULER, vertProvider);
	
			// Set the Horizontal Ruler properties
			DiagramRuler horizontalRuler = ((DiagramRootEditPart) getRootEditPart()).getHorizontalRuler();
			horizontalRuler.setGuideStyle(guideStyle);
			horizontalRuler.setUnit(rulerUnits);
			DiagramRulerProvider horzProvider = new DiagramRulerProvider(getEditingDomain(),
				horizontalRuler, root.getMapMode());
			horzProvider.init();
			getDiagramGraphicalViewer().setProperty(
				RulerProvider.PROPERTY_HORIZONTAL_RULER, horzProvider);
	
			// Show/Hide Rulers
			getDiagramGraphicalViewer().setProperty(
				RulerProvider.PROPERTY_RULER_VISIBILITY,
				Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
					WorkspaceViewerProperties.VIEWRULERS)));
			
		}

		// Snap to Grid
		getDiagramGraphicalViewer().setProperty(
			SnapToGeometry.PROPERTY_SNAP_ENABLED,
			Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
				WorkspaceViewerProperties.SNAPTOGRID)));

		// Hide/Show Grid
		getDiagramGraphicalViewer().setProperty(
			SnapToGrid.PROPERTY_GRID_ENABLED,
			Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
				WorkspaceViewerProperties.VIEWGRID)));
		getDiagramGraphicalViewer().setProperty(
			SnapToGrid.PROPERTY_GRID_VISIBLE,
			Boolean.valueOf(getWorkspaceViewerPreferenceStore().getBoolean(
				WorkspaceViewerProperties.VIEWGRID)));

		// Grid Origin (always 0, 0)
		Point origin = new Point();
		getDiagramGraphicalViewer().setProperty(
			SnapToGrid.PROPERTY_GRID_ORIGIN, origin);

		// Grid Spacing
		double dSpacing = ((DiagramRootEditPart) getDiagramEditPart().getRoot())
			.getGridSpacing();
		((DiagramRootEditPart) getDiagramEditPart().getRoot())
			.setGridSpacing(dSpacing);
	}

	/**
	 * Returns the elements in the given selection.
	 * @@param selection  the selection
	 * @@return a list of <code>EObject</code>
	 */
	protected List getElements(final ISelection selection) {
		if (selection instanceof IStructuredSelection && !selection.isEmpty()) {

			try {
				return (List) TransactionUtil.getEditingDomain(
					((IAdaptable) ((IStructuredSelection) selection).toList()
						.get(0)).getAdapter(View.class)).runExclusive(
					new RunnableWithResult.Impl() {

						public void run() {
							List retval = new ArrayList();
							if (selection instanceof IStructuredSelection) {
								IStructuredSelection structuredSelection = (IStructuredSelection) selection;

								for (Iterator i = structuredSelection.iterator(); i
									.hasNext();) {
									Object next = i.next();

									View view = (View) ((IAdaptable) next)
										.getAdapter(View.class);
									if (view != null) {
										EObject eObject = ViewUtil
											.resolveSemanticElement(view);
										if (eObject != null) {
											retval.add(eObject);
										} else {
											retval.add(view);
										}
									}
								}
							}
							setResult(retval);
						}
					});
			} catch (InterruptedException e) {
				Trace.catching(DiagramUIPlugin.getInstance(),
					DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
					"createEditPart", e); //$NON-NLS-1$
				return Collections.EMPTY_LIST;
			}
		}
		return Collections.EMPTY_LIST;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.ui.part.IShowInSource#getShowInContext()
	 */
	public ShowInContext getShowInContext() {

		ISelection selection = getGraphicalViewer().getSelection();
		return new ShowInContext( null, selection );
	}
	
	/**
	 * Gets the preferences hint that will be used to determine which preference
	 * store to use when retrieving diagram preferences for this diagram editor.
	 * The preference hint is mapped to a preference store in the preference
	 * registry <@@link DiagramPreferencesRegistry>. By default, this method
	 * returns a preference hint configured with the id of the editor. If a
	 * preference store has not been registered against this editor id in the
	 * diagram preferences registry, then the default values will be used.
	 * 
	 * @@return the preferences hint to be used to configure the
	 *         <code>RootEditPart</code>
	 */
	protected PreferencesHint getPreferencesHint() {
		return new PreferencesHint(getEditorSite().getId());
	};
@


1.17
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d44 1
d75 1
a75 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
d84 1
a102 1
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
d298 3
a300 1
			MEditingDomainGetter.getMEditingDomain(getDiagram()).runAsRead(new MRunnable() {
d302 12
a313 5
				public Object run() {
					getViewer().setContents(getDiagram());
					return null;
				}
			});
d382 1
a382 1
    
d407 2
a408 2
    
    /**
a450 1
        }
d452 3
a454 2
    
    /**
d511 1
a511 1
                    TransactionalEditingDomain editingDomain = TransactionalEditingDomain.Factory.INSTANCE
d514 1
a514 1
                    if (domain.equals(editingDomain)) {
d524 2
a525 2
     * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramEditDomain()
     */
d556 1
a556 1
	public Object getAdapter(Class type) {	
d775 2
a776 2
     */
    protected void configureDiagramEditDomain() {
d786 1
a786 1
            }
d799 1
a799 1
    /**
d823 2
a824 3
		}
		startListening();

d827 1
a827 1
    }
d866 9
a874 2
	protected void startListening() {
		// do nothing
d881 1
a881 1
		// do nothing		
d917 2
a918 2
    
    /**
d920 1
a920 1
     * 
d922 1
a922 1
     */
d925 3
a927 3
    }
    
    /**
d936 5
a940 2
    protected EditingDomain getEditingDomain() {
        return TransactionUtil.getEditingDomain(getDiagram());
d952 1
a952 1
            TransactionalEditingDomain domain = (TransactionalEditingDomain) getEditingDomain();
d975 1
a975 1
     * go to a specific marker
d979 1
a979 1
     */
d1212 1
a1212 1
			DiagramRulerProvider vertProvider = new DiagramRulerProvider((TransactionalEditingDomain) getEditingDomain(),
d1222 1
a1222 1
			DiagramRulerProvider horzProvider = new DiagramRulerProvider((TransactionalEditingDomain) getEditingDomain(),
d1270 1
a1270 1
		if (selection instanceof IStructuredSelection) {
d1272 25
a1296 22
			return (List) MEditingDomainGetter.getMEditingDomain(
				((IStructuredSelection) selection).toList()).runAsRead(
				new MRunnable() {

					public Object run() {
						List retval = new ArrayList();
						if (selection instanceof IStructuredSelection) {
							IStructuredSelection structuredSelection = (IStructuredSelection) selection;

							for (Iterator i = structuredSelection.iterator(); i
								.hasNext();) {
								Object next = i.next();

								View view = (View) ((IAdaptable) next)
									.getAdapter(View.class);
								if (view != null) {
									EObject eObject = ViewUtil
										.resolveSemanticElement(view);
									if (eObject != null) {
										retval.add(eObject);
									} else {
										retval.add(view);
d1300 1
d1302 7
a1308 3
						return retval;
					}
				});
a1336 1
   
@


1.16
log
@gmf_head ahunter 060210 Migrate GMF usage of tabbed properties view from WTP to Eclipse Core (org.eclipse.wst.common.ui.properties to org.eclipse.ui.views.properties.tabbed)
@
text
@d20 1
d22 7
d40 7
d48 1
d58 1
a68 1
import org.eclipse.gmf.runtime.common.core.command.CommandManager;
d100 1
d372 10
d397 12
d436 76
a511 1
	}
d514 2
a515 2
	 * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagramEditDomain()
	 */
d546 1
a546 1
	public Object getAdapter(Class type) {		
a551 2
		if (type == CommandManager.class)
			return getCommandManager();
d558 12
d615 12
d758 3
a760 2
		setEditDomain(new DiagramEditDomain(this));
		configureDiagramEditDomain();
d764 40
a803 6
	 * Configures a diagram edit domain
	 */
	protected void configureDiagramEditDomain() {
		getEditDomain().setCommandStack(
			new DiagramCommandStack(getDiagramEditDomain()));
	}
d816 3
a818 1
	}
d901 60
a960 16
	
	/**
	 * Convenience method to access the command manager associated with my
	 * action manager. This command manager is used by my edit domain's 
	 * command stack when executing commands.
	 * 
	 * @@return the command manager
	 */
	protected CommandManager getCommandManager() {
		return getActionManager().getCommandManager();
	}

	/**
	 * go to a specific marker
	 * @@param marker marker to use
	 */
d1193 1
a1193 1
			DiagramRulerProvider vertProvider = new DiagramRulerProvider(
d1203 1
a1203 1
			DiagramRulerProvider horzProvider = new DiagramRulerProvider(
d1310 1
@


1.15
log
@Bugzilla#123313 gmf_head cmahoney 060120 Making DiagramUIPlugin, DiagramUIStatusCodes, and DiagramUIDebugOptions internal
@
text
@d116 1
a116 1
import org.eclipse.wst.common.ui.properties.internal.provisional.ITabbedPropertySheetPageContributor;
@


1.14
log
@bugzilla 112992 gmf-head sshaw 060116 Recalculated page-breaks state of a diagram is not persisted
@
text
@a60 2
import org.eclipse.gmf.runtime.diagram.ui.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.DiagramUIPlugin;
d65 2
@


1.13
log
@[123283] gmf_head tmacdoug 060113 Grid: Grid spacing is not persisted...
@
text
@d871 1
a871 1
			IPath path = ((DiagramUIPlugin) DiagramUIPlugin.getInstance())
d940 4
@


1.12
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d956 1
a956 2
		int rulerUnits = ((IPreferenceStore) ((DiagramRootEditPart) getRootEditPart()).getPreferencesHint().getPreferenceStore())
			.getInt(IPreferenceConstants.PREF_RULER_UNITS);
@


1.11
log
@Bugzilla#116030 gmf_head cmahoney 051121 Diagram ActionIds should be public
@
text
@d73 1
d80 1
a80 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d227 1
a227 3
			showOutlineAction.setImageDescriptor(DiagramResourceManager
				.getInstance().getImageDescriptor(
					DiagramResourceManager.IMAGE_OUTLINE));
d235 1
a235 3
			showOverviewAction.setImageDescriptor(DiagramResourceManager
				.getInstance().getImageDescriptor(
					DiagramResourceManager.IMAGE_OVERVIEW));
d507 1
a507 2
			action.setText(DiagramResourceManager
				.getI18NString("DiagramEditor.Delete_from_Diagram")); //$NON-NLS-1$
@


1.10
log
@bugzilla 112788 gmf-head sshaw 051108 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d63 1
a76 1
import org.eclipse.gmf.runtime.diagram.ui.internal.requests.ActionIds;
@


1.9
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d582 1
a582 1
			.createRootEditPart();
@


1.8
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d970 3
d978 1
a978 1
				verticalRuler);
d988 1
a988 1
				horizontalRuler);
@


1.7
log
@Bugzilla 112990 gmf_head tmacdoug 051102 - The Logic Diagram does not respect the Anti-Aliasing Preference or the Ruler Units
@
text
@a62 1
import org.eclipse.gmf.runtime.diagram.ui.IPreferenceConstants;
d79 2
a80 2
import org.eclipse.gmf.runtime.diagram.ui.l10n.Images;
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d226 3
a228 1
			showOutlineAction.setImageDescriptor(Images.DESC_ACTION_OUTLINE);
d236 3
a238 1
			showOverviewAction.setImageDescriptor(Images.DESC_ACTION_OVERVIEW);
d510 1
a510 1
			action.setText(PresentationResourceManager
d989 1
a989 1
			
@


1.6
log
@bugzilla 110254 gmf-head mmostafa 051014 Unknow view reference in DiagramEditor
@
text
@d723 1
a723 2
		return ((DiagramRootEditPart) getGraphicalViewer().getRootEditPart())
			.getZoomManager();
d726 4
a930 2
	IPreferenceStore pluginStore = DiagramUIPlugin.getInstance()
		.getPreferenceStore();
d957 1
a957 1
		int rulerUnits = pluginStore
d968 3
a970 2
			DiagramRuler verticalRuler = new DiagramRuler(false, rulerUnits,
				guideStyle);
d978 3
a980 2
			DiagramRuler horizontalRuler = new DiagramRuler(true, rulerUnits,
				guideStyle);
d986 1
a986 1
	
@


1.5
log
@bugzilla 112685 gmf-head sshaw 051014 Sweep code for creation of Boolean objects
@
text
@a51 31
import org.eclipse.gef.ui.stackview.CommandStackInspectorPage;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.preference.PreferenceStore;
import org.eclipse.jface.util.Assert;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.SWT;
import org.eclipse.swt.SWTException;
import org.eclipse.swt.events.DisposeEvent;
import org.eclipse.swt.events.DisposeListener;
import org.eclipse.swt.widgets.Canvas;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorSite;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchPartSite;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.part.IPageSite;
import org.eclipse.ui.part.IShowInSource;
import org.eclipse.ui.part.IShowInTargetList;
import org.eclipse.ui.part.PageBook;
import org.eclipse.ui.part.ShowInContext;
import org.eclipse.ui.views.contentoutline.IContentOutlinePage;
import org.eclipse.wst.common.ui.properties.internal.provisional.ITabbedPropertySheetPageContributor;

d60 1
a83 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d89 28
a437 2
		if (type == CommandStackInspectorPage.class)
			return new CommandStackInspectorPage(getCommandStack());
a445 10
		
		if (type == IShowInTargetList.class) {
			return new IShowInTargetList() {
				public String[] getShowInTargetIds() {
					return new String[] { "com.ibm.xtools.modeler.ui.views.modelexplorer.ModelExplorer" }; //$NON-NLS-1$
				}

			};
		}

@


1.4
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d1002 1
a1002 1
				new Boolean(getWorkspaceViewerPreferenceStore().getBoolean(
d1010 1
a1010 1
			new Boolean(getWorkspaceViewerPreferenceStore().getBoolean(
d1016 1
a1016 1
			new Boolean(getWorkspaceViewerPreferenceStore().getBoolean(
d1020 1
a1020 1
			new Boolean(getWorkspaceViewerPreferenceStore().getBoolean(
@


1.3
log
@Bugzilla 109092  : rumv_head mmostafa 050908 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@a102 1
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.DiagramContextMenuProvider;
d110 1
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d114 4
a117 4
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.GuideStyle;
import com.ibm.xtools.notation.NotationPackage;
import com.ibm.xtools.notation.View;
@

