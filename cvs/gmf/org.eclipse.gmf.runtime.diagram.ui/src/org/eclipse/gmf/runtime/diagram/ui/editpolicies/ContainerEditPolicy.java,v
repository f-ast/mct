head	1.28;
access;
symbols
	v20081023-2107:1.27.2.1
	v20081022-1925:1.28
	v20081022-1005:1.27.2.1
	v20081020-0700:1.28
	v20080917-1925:1.28
	v20080916-2008:1.27.2.1
	v20080911-1728:1.28
	v20080911-1506:1.27.2.1
	v20080910-1520:1.28
	v20080910-1510:1.27.2.1
	v20080903-1520:1.28
	v20080903-1510:1.27.2.1
	v20080813-1510:1.27.2.1
	v20080811-1546:1.28
	v20080731-1520:1.28
	v20080725-1738:1.27.2.1
	v20080723-2246:1.27
	v20080723-2232:1.27
	v20080723-1700:1.27
	v20080722-1827:1.27
	v20080718-1700:1.27
	v20080718-1731:1.27
	v20080716-1600:1.27
	v20080716-1642:1.27
	R2_1_maintenance:1.27.0.2
	Root_R2_1_maintenance:1.27
	R2_1_0:1.27
	v20080610-1132:1.27
	v20080603-1553:1.27
	v20080527-1255:1.27
	v20080527-1151:1.19
	v20080516-1748:1.27
	v20080516-1143:1.27
	v20080512-1200:1.27
	v20080503-1740:1.27
	v20080501-2127:1.19
	v20080501-1739:1.27
	m20080429-1543:1.19
	v20080425-1959:1.26
	v20080417-1610:1.24
	v20080407-2250:1.24
	v20080407-0930:1.24
	v20080404-1111:1.24
	v20080328-1605:1.24
	v20080322-0000:1.24
	v20080222-1200:1.24
	v20080201-2010:1.24
	v20080201-0201:1.19
	v20080118-1129:1.19
	v20080114-2222:1.19
	v20080114-1111:1.23
	v20080107-1111:1.23
	v20071222-1111:1.23
	v20071214-1111:1.23
	v20071130-1111:1.23
	v20071124-0000:1.19
	v20071112-0000:1.20
	v20071108-0000:1.20
	v20071003-0000:1.19
	v20070915-0000:1.19
	v20070903-0000:1.19
	v20070809-0000:1.19
	R2_0_maintenance:1.19.0.4
	R2_0:1.19
	R4_20:1.19
	v20070621-0000:1.19
	RC3_20:1.19
	v20070614-1400:1.19
	v20070608-1300:1.19
	v20070605-1400:1.19
	v20070601-1400:1.19
	v20070525-1500:1.19
	v20070518-1300:1.19
	bugzilla111892_group_support:1.19.0.2
	Root_bugzilla111892_group_support:1.19
	v20070504-1000:1.19
	v20070420-1000:1.19
	v20070413-1300:1.19
	v20070330-1300:1.19
	v20060330-1300:1.19
	v20070322-1100:1.19
	v20060316-0600:1.19
	v20070221-1500:1.19
	v20070208-1800:1.19
	v20070202-0200:1.18.2.2
	v20070119-1200:1.18.2.2
	v20070111-0800:1.18.2.2
	v20070105-1200:1.18.2.2
	v20070103-0300:1.19
	M4_20:1.19
	v20061218-1500:1.18.2.2
	v20061218-1200:1.19
	v20061214-0000:1.19
	M3_20:1.19
	v20061117-0800:1.19
	v20061027-1200:1.18.2.2
	v20061013-1330:1.19
	v20061012-1100:1.18.2.2
	v20060925-1700:1.18.2.2
	v20060919-0800:1.18.2.2
	v20060907-1100:1.18
	M1_20:1.18
	v20060831-1500:1.18
	v20060824-1600:1.18
	v20060817-1500:1.18
	v20060810-1700:1.18
	v20060803-1200:1.18
	v20060728-0500:1.18
	v20060721-1130:1.18
	v20060713-1700:1.18
	R1_0_maintenance:1.18.0.2
	R1_0:1.18
	v20060627-1200:1.18
	v20060616-1400:1.18
	v20060616-1200:1.18
	v20060609-1400:1.17
	v20060531-1730:1.17
	v20060530-1930:1.17
	v20060526-1200:1.17
	v20060519-0800:1.17
	v20060512-1000:1.15
	I20060512-1000:1.15
	I20060505-1400:1.15
	I20060428-1300:1.15
	I20060424-0500:1.15
	I20060424-0300:1.14
	M6_10:1.14
	I20060407-1200:1.14
	I20060331-1000:1.14
	I20060324-0300:1.13
	I20060317-1300:1.13
	I20060317-1200:1.13
	I20060316-1300:1.13
	I20060309-1300:1.13
	M5_10:1.13
	S20060303-1600:1.13
	I20060227-1730:1.12
	I20060216-1945:1.12
	I20060210-1715:1.11
	I20060209-1815:1.11
	I20060203-0830:1.11
	I20060202-1415:1.11
	I20060129-1145:1.10
	I20060127-0900:1.9
	I20060120-1530:1.9
	I20060113-1700:1.9
	M4_10:1.9
	I20060107-1100:1.9
	I20060105-1630:1.9
	I20051230-1230:1.9
	I20051223-1100:1.9
	I20051217-0925:1.9
	I20051208-2000:1.9
	I20051201-1800:1.9
	I20051124-2000:1.8
	M3_10:1.6
	I20051118-1245:1.6
	I20051111-1800:1.6
	I20051106-0900:1.6
	v20051030:1.4;
locks; strict;
comment	@# @;


1.28
date	2008.07.25.21.40.41;	author aboyko;	state Exp;
branches;
next	1.27;
commitid	45dc488a48594567;

1.27
date	2008.04.28.22.53.23;	author aboyko;	state Exp;
branches
	1.27.2.1;
next	1.26;
commitid	6db9481655624567;

1.26
date	2008.04.22.21.06.54;	author ahunter;	state Exp;
branches;
next	1.25;
commitid	170e480e536d4567;

1.25
date	2008.04.17.21.16.35;	author crevells;	state Exp;
branches;
next	1.24;
commitid	7f9d4807be334567;

1.24
date	2008.01.16.16.51.00;	author crevells;	state Exp;
branches;
next	1.23;
commitid	349478e35f24567;

1.23
date	2007.11.21.19.15.27;	author crevells;	state Exp;
branches;
next	1.22;
commitid	112c474483cf4567;

1.22
date	2007.11.21.17.57.28;	author crevells;	state Exp;
branches;
next	1.21;
commitid	4a12474471874567;

1.21
date	2007.11.20.20.26.16;	author crevells;	state Exp;
branches;
next	1.20;
commitid	14c8474342e74567;

1.20
date	2007.11.02.21.03.36;	author aboyko;	state Exp;
branches;
next	1.19;
commitid	7608472b90a74567;

1.19
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2006.06.14.18.39.49;	author ahunter;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2006.05.17.14.00.26;	author ldamus;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.15.15.26.01;	author cmahoney;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.18.15.12.20;	author cmahoney;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.24.21.52.18;	author mmostafa;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.28.02.30.51;	author cmahoney;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.13.19.11.49;	author ldamus;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.01.20.17.39;	author mmostafa;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.27.20.22.56;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.25.19.38.12;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.24.22.21.03;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.21.16.13.24;	author cmahoney;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.04.21.27.49;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.02.23.30.15;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.25.15.44.00;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.29.06;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.37;	author sshaw;	state Exp;
branches;
next	;

1.18.2.1
date	2006.09.13.16.43.39;	author ahunter;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2006.09.18.21.57.42;	author cmahoney;	state Exp;
branches;
next	;

1.19.2.1
date	2007.05.18.17.36.43;	author crevells;	state Exp;
branches;
next	;
commitid	1899464de42a4567;

1.27.2.1
date	2008.07.25.21.23.42;	author aboyko;	state Exp;
branches;
next	;
commitid	4cd4488a445d4567;


desc
@@


1.28
log
@[242124] gmf_head aboyko 080725 [CopyPaste] Edges that shouldn't be copied are being copied without source/target
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.draw2d.XYLayout;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.Request;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gef.commands.UnexecutableCommand;
import org.eclipse.gef.requests.CreateRequest;
import org.eclipse.gef.requests.GroupRequest;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
import org.eclipse.gmf.runtime.common.core.util.ObjectAdapter;
import org.eclipse.gmf.runtime.common.ui.util.ICustomData;
import org.eclipse.gmf.runtime.diagram.core.commands.GroupCommand;
import org.eclipse.gmf.runtime.diagram.core.internal.commands.BringForwardCommand;
import org.eclipse.gmf.runtime.diagram.core.internal.commands.BringToFrontCommand;
import org.eclipse.gmf.runtime.diagram.core.internal.commands.SendBackwardCommand;
import org.eclipse.gmf.runtime.diagram.core.internal.commands.SendToBackCommand;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.actions.ActionIds;
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.DeferredLayoutCommand;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.PasteCommand;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ConnectionEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GroupEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ListItemEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.DuplicateViewsCommand;
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.RefreshEditPartCommand;
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.SnapCommand;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IEditableEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.ISurfaceEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.IInternalLayoutRunnable;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.LayoutNode;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.requests.ArrangeRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.DuplicateRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.EditCommandRequestWrapper;
import org.eclipse.gmf.runtime.diagram.ui.requests.PasteViewRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants;
import org.eclipse.gmf.runtime.diagram.ui.requests.ZOrderRequest;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutService;
import org.eclipse.gmf.runtime.diagram.ui.services.layout.LayoutType;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.emf.clipboard.core.ClipboardSupportUtil;
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand;
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;
import org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.Node;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.preference.IPreferenceStore;

/**
 * the container edit policy
 * @@author sshaw
 */
public class ContainerEditPolicy
    extends org.eclipse.gef.editpolicies.ContainerEditPolicy {

    protected Command getAddCommand(GroupRequest request) {
        return null;
    }

    /**
     * gets a delete dependant command  
     * @@param request the request
     * @@return command
     */
    protected Command getDeleteDependantCommand(Request request) {
        return null;
    }

    protected Command getCreateCommand(CreateRequest request) {
        return null;
    }

    public Command getOrphanChildrenCommand(GroupRequest request) {
        return null;
    }

    /**
     * Returns a command to paste the views
     * @@param request The PasteViewRequest
     * @@return Command the command to execute
     */
    protected Command getPasteCommand(PasteViewRequest request) {
        /* Get the view context */
        IGraphicalEditPart editPart = (IGraphicalEditPart) getHost();
        View viewContext = (View) ((IAdaptable)editPart).getAdapter(View.class);

        /* Get the clipboard data */
        ICustomData[] data = request.getData();

        /* Return the paste command */
        if (data != null
            && viewContext != null
            && editPart instanceof ISurfaceEditPart) {
            return new ICommandProxy(new PasteCommand(editPart
                .getEditingDomain(), DiagramUIMessages.PasteCommand_Label,
                viewContext, data, MapModeUtil
                    .getMapMode(((org.eclipse.gef.GraphicalEditPart) getHost())
                        .getFigure())));
        }

        return null;
    }
    
    private class EditPartComparator implements Comparator {
        
        /* (non-Javadoc)
         * @@see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        public int compare(Object arg0, Object arg1) {

            EditPart ep0 = (EditPart)arg0;
            EditPart ep1 = (EditPart)arg1;
            
            EditPart parent = ep0.getParent();
            int ep0Index = parent.getChildren().indexOf( ep0 );
            int ep1Index = parent.getChildren().indexOf( ep1 );
            
            return ep0Index - ep1Index;
        }
        
    }

    private List sortSelection( List editPartsToSort ) {

        // IF the list to be sorted is less than 2...
        if( editPartsToSort.size() < 2 ) {
            // Return the original list
            return editPartsToSort;
        }

        List toReturn = new ArrayList( editPartsToSort.size() );
        toReturn.addAll( editPartsToSort );

        Collections.sort( toReturn, new EditPartComparator() );
    
        return toReturn;
    }

    private List reverseSortSelection( List toSort ) {
        List toReturn = sortSelection( toSort );
        
        Collections.reverse( toReturn );
        return toReturn;
    }

    /**
     * Returns a command that moves the selected views to the front
     * @@param request the ZOrder Request
     * @@return the command to execute
     */
    protected Command getBringToFrontCommand( ZOrderRequest request ) {
        
        CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
        
        // Create commands for each view to move
        for (Iterator iter = sortSelection( request.getPartsToOrder() ).iterator();
            iter.hasNext(); ) {
            
            IGraphicalEditPart element = (IGraphicalEditPart) iter.next();
            toReturn.compose(new BringToFrontCommand(
                element.getEditingDomain(), (View) element.getModel()));
        }
        
        return new ICommandProxy( toReturn );
    }

    /**
     * Returns a command the moves the selected views one step toward the front
     * @@param request the ZOrder Request
     * @@return the command to execute
     */
    protected Command getBringForwardCommand( ZOrderRequest request ) {
        
        CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
    
        // Create commands for each view to move
        for (Iterator iter = reverseSortSelection( request.getPartsToOrder() ).iterator(); iter.hasNext();) {
            IGraphicalEditPart toOrder = (IGraphicalEditPart) iter.next();
            
            toReturn.compose(new BringForwardCommand(
                toOrder.getEditingDomain(), (View) toOrder.getModel()));
        }
        
        return new ICommandProxy( toReturn );
    }

    /**
     * Returns a command the moves the selected views to the back
     * @@param request the ZOrder Request
     * @@return the command to execute
     */
    protected Command getSendToBackCommand( ZOrderRequest request ) {
        
        CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
        
        // Create commands for each view to move
        for (Iterator iter = reverseSortSelection(request.getPartsToOrder()).iterator(); iter.hasNext();) {
            IGraphicalEditPart toOrder = (IGraphicalEditPart) iter.next();
            
            toReturn.compose(new SendToBackCommand(toOrder.getEditingDomain(),
                (View) toOrder.getModel()));
        }
        
        return new ICommandProxy( toReturn );
    }
    
    /**
     * Returns a command the moves the selected views one step toward the back
     * @@param request the ZOrder Request
     * @@return the command to execute
     */
    protected Command getSendBackwardCommand( ZOrderRequest request ) {

        CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
        
        // Create commands for each view to move
        for (Iterator iter = sortSelection(request.getPartsToOrder()).iterator(); iter.hasNext();) {
            IGraphicalEditPart toOrder = (IGraphicalEditPart) iter.next();
            
            toReturn.compose(new SendBackwardCommand(
                toOrder.getEditingDomain(), (View) toOrder.getModel()));
        }
        
        return new ICommandProxy( toReturn );
    }

    /**
     * gets an arrange command 
     * @@param request
     * @@return command
     */
    protected Command getArrangeCommand(ArrangeRequest request) {
        
        if (RequestConstants.REQ_ARRANGE_DEFERRED.equals(request.getType())) {
            String layoutType = request.getLayoutType();
            TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
                .getEditingDomain();
            return new ICommandProxy(
                new DeferredLayoutCommand(editingDomain,
                    request.getViewAdaptersToArrange(),
                    (IGraphicalEditPart) getHost(),
                    layoutType));
        }
        
        String layoutDesc = request.getLayoutType() != null ? request.getLayoutType() : LayoutType.DEFAULT;
        boolean offsetFromBoundingBox = false;
        List editparts = new ArrayList();
        
        if ( (ActionIds.ACTION_ARRANGE_ALL.equals(request.getType())) || 
             (ActionIds.ACTION_TOOLBAR_ARRANGE_ALL.equals(request.getType()))) {
            editparts = ((IGraphicalEditPart)getHost()).getChildren();          
            request.setPartsToArrange(editparts);
        }
        if ( (ActionIds.ACTION_ARRANGE_SELECTION.equals(request.getType())) ||
             (ActionIds.ACTION_TOOLBAR_ARRANGE_SELECTION.equals(request.getType()))) {
            editparts = request.getPartsToArrange();
            if (editparts.size() < 2
                || !(((GraphicalEditPart) ((EditPart) editparts.get(0))
                    .getParent()).getContentPane().getLayoutManager() instanceof XYLayout)) {
                return null;
            }
            offsetFromBoundingBox = true;
        } 
        if (RequestConstants.REQ_ARRANGE_RADIAL.equals(request.getType())) {
            editparts = request.getPartsToArrange();
            offsetFromBoundingBox = true;
            layoutDesc = LayoutType.RADIAL;
        }
        if (editparts.isEmpty())
            return null;
        List nodes = new ArrayList(editparts.size());
        ListIterator li = editparts.listIterator();     
        while (li.hasNext()) {
            IGraphicalEditPart ep = (IGraphicalEditPart)li.next();      
            View view = ep.getNotationView();
            if (ep.isActive() && view != null && view instanceof Node) {
                Rectangle bounds = ep.getFigure().getBounds();
                nodes.add(new LayoutNode((Node)view, bounds.width, bounds.height));
            }
        }
        if (nodes.isEmpty()) {
            return null;
        }
        
        List hints = new ArrayList(2);
        hints.add(layoutDesc);
        hints.add(getHost());
        IAdaptable layoutHint = new ObjectAdapter(hints);
        final Runnable layoutRun = layoutNodes(nodes, offsetFromBoundingBox, layoutHint);
                
        boolean isSnap = true;  
        //retrieves the preference store from the first edit part
        IGraphicalEditPart firstEditPart = (IGraphicalEditPart)editparts.get(0);
        if (firstEditPart.getViewer() instanceof DiagramGraphicalViewer){           
             IPreferenceStore preferenceStore = ((DiagramGraphicalViewer)firstEditPart.getViewer())
            .getWorkspaceViewerPreferenceStore();
             if (preferenceStore != null){
                    isSnap = preferenceStore.getBoolean(WorkspaceViewerProperties.SNAPTOGRID);          
             }      
        }   
        
        //the snapCommand still invokes proper calculations if snap to grid is turned off, this additional check
        //is intended to make the code more appear more logical     
                
        CompoundCommand cmd = new CompoundCommand();        
        if (layoutRun instanceof IInternalLayoutRunnable) {
            cmd.add(((IInternalLayoutRunnable) layoutRun).getCommand());        
        }
        else {
            TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
                .getEditingDomain(); 
            cmd.add(new ICommandProxy(new AbstractTransactionalCommand(editingDomain, "", null) {//$NON-NLS-1$
                protected CommandResult doExecuteWithResult(
                            IProgressMonitor progressMonitor, IAdaptable info)
                        throws ExecutionException {
                    layoutRun.run();
                    return CommandResult.newOKCommandResult();
                }
            }));     
        }       
        if (isSnap) {
            cmd.add(getSnapCommand(request));
        }
        return cmd;
    }
    
    /**
     * @@param offsetFromBoundingBox
     * @@param nodes
     * @@param layoutHint
     * @@return runnable
     */
    public Runnable layoutNodes(List nodes, boolean offsetFromBoundingBox, IAdaptable layoutHint) {
        final Runnable layoutRun =  LayoutService.getInstance().layoutLayoutNodes(nodes, offsetFromBoundingBox, layoutHint);
        return layoutRun;
    }

    /**
     * Returns a command to to duplicate views and their underlying semantic
     * elements (if applicable) of the given editparts.
     * 
     * @@param request
     *            the <code>DuplicateElementsRequest</code> whose list of duplicated
     *            views will be populated when the command is executed
     * @@return the command to perform the duplication
     */
    private Command getDuplicateCommand(DuplicateRequest request) {
        List notationViewsToDuplicate = new ArrayList();
        Set elementsToDuplicate = new HashSet();

        for (Iterator iter = request.getEditParts().iterator(); iter.hasNext();) {
            Object ep = iter.next();
            
            // Disable duplicate on groups for now.  See bugzilla 182972.
            if (ep instanceof GroupEditPart) {
                return UnexecutableCommand.INSTANCE;
            }
            
            if (ep instanceof ConnectionEditPart || ep instanceof ShapeEditPart
                || ep instanceof ListItemEditPart) {
                                
                View notationView = (View)((IGraphicalEditPart) ep).getModel();
                if (notationView != null) {
                    notationViewsToDuplicate.add(notationView);
                }
            }
        }
        
        // Remove views whose container view is getting copied.
        ClipboardSupportUtil.getCopyElements(notationViewsToDuplicate);
        
        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart)getHost()).getEditingDomain();
        
        for (Iterator iter = notationViewsToDuplicate.iterator(); iter
                .hasNext();) {
            View view = (View) iter.next();
            EObject element = view.getElement();

            if (element != null) {
                EObject resolvedElement = EMFCoreUtil.resolve(editingDomain,
                        element);
                if (resolvedElement != null) {
                    elementsToDuplicate.add(resolvedElement);
                }
            }
        }

        /*
         * We must append all inner edges of a node being duplicated. Edges are non-containment
         * references, hence they won't be duplicated for free. Therefore, we add them here to
         * the list views to duplicate.
         * We don't add semantic elements of the edges to the list of semantic elements to duplicate
         * since we assume that their semantic elements are owned by source or target or their semantic
         * containers. 
         */
        /**
         * Until duplicate views action enablement is driven by the created duplicate views command,
         * we can't look for edges to duplicate. It's a performance hit.
         */
//        List<Edge> allInnerEdges = new LinkedList<Edge>();
//        for (Iterator itr = notationViewsToDuplicate.iterator(); itr.hasNext();) {
//        	allInnerEdges.addAll(ViewUtil.getAllInnerEdges((View) itr.next()));
//        }
//        notationViewsToDuplicate.addAll(allInnerEdges);
        
        if (!notationViewsToDuplicate.isEmpty()) {
            if (!elementsToDuplicate.isEmpty()) {
                org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest duplicateElementsRequest = new DuplicateElementsRequest(
                    editingDomain, new ArrayList(elementsToDuplicate));
                
                Command duplicateElementsCommand = getHost().getCommand(
                    new EditCommandRequestWrapper(duplicateElementsRequest, request.getExtendedData()));
                if (duplicateElementsCommand != null
                    && duplicateElementsCommand.canExecute()) {
                    CompositeCommand cc = new CompositeCommand(
                        DiagramUIMessages.Commands_Duplicate_Label);
                    cc
                        .compose(new CommandProxy(
                            duplicateElementsCommand));
                    
                    cc.compose(new DuplicateViewsCommand(editingDomain,
                        DiagramUIMessages.Commands_Duplicate_Label,
                        request, notationViewsToDuplicate,
                        duplicateElementsRequest.getAllDuplicatedElementsMap(), getDuplicateViewsOffset(request)));
                    return new ICommandProxy(cc);
                }
            } else {
                return new ICommandProxy(new DuplicateViewsCommand(editingDomain,
                    DiagramUIMessages.Commands_Duplicate_Label,
                    request, notationViewsToDuplicate, getDuplicateViewsOffset(request)));
            }
        }
        return null;
    }
    
    private Point getDuplicateViewsOffset(DuplicateRequest request) {
        if (request.getOffset() != null) {
            return request.getOffset();
        }
        int offset = MapModeUtil.getMapMode(
            ((org.eclipse.gef.GraphicalEditPart) getHost()).getFigure())
            .DPtoLP(10);
        return new Point(offset, offset);
    }
    
    private Command getSnapCommand(Request request){
            
        List editparts = null;
        if (request instanceof GroupRequest){           
            editparts =  ((GroupRequest)request).getEditParts();
        }   
        else if (request instanceof ArrangeRequest){
            editparts = ((ArrangeRequest)request).getPartsToArrange();
        }
        
        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
                .getEditingDomain();
        if (editparts != null){
            return new ICommandProxy(new SnapCommand(editingDomain, editparts));
        }       
        return null;
    }
    
    /**
     * @@see org.eclipse.gef.EditPolicy#getCommand(Request)
     */
    public Command getCommand(Request request) {
        if (ActionIds.ACTION_GROUP.equals(request.getType())
            && request instanceof GroupRequest) {
            return getGroupCommand((GroupRequest) request);
        } 
        else if (request instanceof ArrangeRequest) {
            return getArrangeCommand((ArrangeRequest)request);
        }       
        
        if (RequestConstants.REQ_SNAP_TO_GRID.equals(request.getType())){
            return getSnapCommand(request);
        }
        
        if (RequestConstants.REQ_REFRESH.equals(request.getType())) {
            IGraphicalEditPart containerEP = (IGraphicalEditPart) getHost();

            CompositeCommand cc = new CompositeCommand(""); //$NON-NLS-1$
            ListIterator li = containerEP.getChildren().listIterator();
            while (li.hasNext()) {
                cc.compose(
                    new RefreshEditPartCommand(
                        (IGraphicalEditPart) li.next(),
                        false));
            }
            cc.compose(
                new RefreshEditPartCommand(
                    (IGraphicalEditPart) getHost(),
                    true));

            return new ICommandProxy(cc);
        }

        if (RequestConstants.REQ_PASTE.equals(request.getType())) {
            return getPasteCommand((PasteViewRequest) request);
        }

        if (RequestConstants.REQ_DUPLICATE.equals(request.getType())) {
            return getDuplicateCommand(((DuplicateRequest) request));
        }

        if (ZOrderRequest.REQ_BRING_TO_FRONT.equals(request.getType())) {
            return getBringToFrontCommand((ZOrderRequest) request);
        }
        
        if (ZOrderRequest.REQ_BRING_FORWARD.equals(request.getType())) {
            return getBringForwardCommand((ZOrderRequest) request);
        }
        
        if (ZOrderRequest.REQ_SEND_TO_BACK.equals(request.getType())) {
            return getSendToBackCommand((ZOrderRequest) request);
        }
        
        if (ZOrderRequest.REQ_SEND_BACKWARD.equals(request.getType())) {
            return getSendBackwardCommand((ZOrderRequest) request);
        }

        return super.getCommand(request);
    }

    /**
     * Returns a command to group the editparts in the request.
     * 
     * @@param request
     *            the request containing the editparts to be grouped.
     * @@return the command to perform the grouping
     */
    protected Command getGroupCommand(GroupRequest request) {
        List shapeViews = new LinkedList();
        IGraphicalEditPart parentEP = null;
        for (Iterator iter = request.getEditParts().iterator(); iter.hasNext();) {
            Object editpart = iter.next();

            if (editpart instanceof ShapeEditPart) {

                if (!((IEditableEditPart) editpart).isEditModeEnabled()) {
                    return null;
                }
                
                if (editpart instanceof IBorderItemEditPart) {
                    return null;
                }

                if (parentEP != null) {
                    if (parentEP != ((ShapeEditPart) editpart).getParent()) {
                        // can only group shapes with the same parent
                        return null;
                    }
                } else {
                    parentEP = (IGraphicalEditPart) ((ShapeEditPart) editpart)
                        .getParent();
                }

                if (((ShapeEditPart) editpart).getModel() instanceof Node) {
                    shapeViews.add(((ShapeEditPart) editpart).getModel());
                }
            }
        }

        if (parentEP == null || !parentEP.isEditModeEnabled()) {
            return null;
    }

        GroupCommand cmd = new GroupCommand(((IGraphicalEditPart) getHost())
            .getEditingDomain(), shapeViews);
        return new ICommandProxy(cmd);
    }

    /**
     * @@see org.eclipse.gef.EditPolicy#getTargetEditPart(org.eclipse.gef.Request)
     */
    public EditPart getTargetEditPart(Request request) {
        return understandsRequest(request) ? getHost() : null;
    }

    /**
     * @@see org.eclipse.gef.EditPolicy#understandsRequest(org.eclipse.gef.Request)
     */
    public boolean understandsRequest(Request request) {
        return (
            ActionIds.ACTION_ARRANGE_ALL.equals(request.getType())
                || ActionIds.ACTION_TOOLBAR_ARRANGE_ALL.equals(request.getType())
                || ActionIds.ACTION_ARRANGE_SELECTION.equals(request.getType())
                || ActionIds.ACTION_GROUP.equals(request.getType())
                || ActionIds.ACTION_TOOLBAR_ARRANGE_SELECTION.equals(request.getType())             
                || RequestConstants.REQ_ARRANGE_RADIAL.equals(request.getType())
                || RequestConstants.REQ_ARRANGE_DEFERRED.equals(request.getType())
                || RequestConstants.REQ_REFRESH.equals(request.getType())
                || RequestConstants.REQ_PASTE.equals(request.getType())
                || RequestConstants.REQ_DUPLICATE.equals(request.getType())
                || RequestConstants.REQ_SNAP_TO_GRID.equals(request.getType())
                || ZOrderRequest.REQ_BRING_TO_FRONT.equals(request.getType())
                || ZOrderRequest.REQ_BRING_FORWARD.equals(request.getType())
                || ZOrderRequest.REQ_SEND_TO_BACK.equals(request.getType())
                || ZOrderRequest.REQ_SEND_BACKWARD.equals(request.getType()));
    }

}@


1.27
log
@[226150] gmf_head aboyko 080428 Arrange All Command need to check whether the EditPart is active
@
text
@d436 9
a444 5
        HashSet<Edge> allInnerEdges = new HashSet<Edge>();
        for (Iterator itr = notationViewsToDuplicate.iterator(); itr.hasNext();) {
            ViewUtil.getAllRelatedEdgesFromViews(((View)itr.next()).getChildren(), allInnerEdges);
        }
        notationViewsToDuplicate.addAll(allInnerEdges);
@


1.27.2.1
log
@[242124] gmf_R2_1_maintenance aboyko 080725 [CopyPaste] Edges that shouldn't be copied are being copied without source/target
@
text
@d436 5
a440 9
        /**
         * Until duplicate views action enablement is driven by the created duplicate views command,
         * we can't look for edges to duplicate. It's a performance hit.
         */
//        List<Edge> allInnerEdges = new LinkedList<Edge>();
//        for (Iterator itr = notationViewsToDuplicate.iterator(); itr.hasNext();) {
//        	allInnerEdges.addAll(ViewUtil.getAllInnerEdges((View) itr.next()));
//        }
//        notationViewsToDuplicate.addAll(allInnerEdges);
@


1.26
log
@[227655] gmf-head ahunter 080422 Clipboard support used for copy/paste does not preserve order
@
text
@d316 1
a316 1
            if (view != null && view instanceof Node) {
@


1.25
log
@[227651] gmf_head crevells 080417 PasteViewRequest should be public
@
text
@d54 1
a61 1
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.PasteCommand;
@


1.24
log
@[215505] gmf_head crevells 080116 Should be able to right-click a Circuit and arrange contents of its compartment
@
text
@a66 1
import org.eclipse.gmf.runtime.diagram.ui.internal.requests.PasteViewRequest;
d74 1
@


1.23
log
@[119252] gmf_head crevells 071121 [RulersGrid] Useability: diagram arrange all
should snap to grid if snap to grid is on
Contributed by:  Carson Li
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d27 1
d33 1
d297 5
d321 3
@


1.22
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@d34 1
a35 1
import org.eclipse.gef.commands.CompoundCommand;
d61 1
a62 1
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.SnapCommand;
a69 1
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart;
a85 2
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.PlatformUI;
d92 1
a92 1
	extends org.eclipse.gef.editpolicies.ContainerEditPolicy {
d94 39
a132 39
	protected Command getAddCommand(GroupRequest request) {
		return null;
	}

	/**
	 * gets a delete dependant command  
	 * @@param request the request
	 * @@return command
	 */
	protected Command getDeleteDependantCommand(Request request) {
		return null;
	}

	protected Command getCreateCommand(CreateRequest request) {
		return null;
	}

	public Command getOrphanChildrenCommand(GroupRequest request) {
		return null;
	}

	/**
	 * Returns a command to paste the views
	 * @@param request The PasteViewRequest
	 * @@return Command the command to execute
	 */
	protected Command getPasteCommand(PasteViewRequest request) {
		/* Get the view context */
		IGraphicalEditPart editPart = (IGraphicalEditPart) getHost();
		View viewContext = (View) ((IAdaptable)editPart).getAdapter(View.class);

		/* Get the clipboard data */
		ICustomData[] data = request.getData();

		/* Return the paste command */
		if (data != null
			&& viewContext != null
			&& editPart instanceof ISurfaceEditPart) {
			return new ICommandProxy(new PasteCommand(editPart
d137 46
a182 1
		}
d184 15
a198 60
		return null;
	}
	
	private class EditPartComparator implements Comparator {
		
		/* (non-Javadoc)
		 * @@see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
		 */
		public int compare(Object arg0, Object arg1) {

			EditPart ep0 = (EditPart)arg0;
			EditPart ep1 = (EditPart)arg1;
			
			EditPart parent = ep0.getParent();
			int ep0Index = parent.getChildren().indexOf( ep0 );
			int ep1Index = parent.getChildren().indexOf( ep1 );
			
			return ep0Index - ep1Index;
		}
		
	}

	private List sortSelection( List editPartsToSort ) {

		// IF the list to be sorted is less than 2...
		if( editPartsToSort.size() < 2 ) {
			// Return the original list
			return editPartsToSort;
		}

		List toReturn = new ArrayList( editPartsToSort.size() );
		toReturn.addAll( editPartsToSort );

		Collections.sort( toReturn, new EditPartComparator() );
	
		return toReturn;
	}

	private List reverseSortSelection( List toSort ) {
		List toReturn = sortSelection( toSort );
		
		Collections.reverse( toReturn );
		return toReturn;
	}

	/**
	 * Returns a command that moves the selected views to the front
	 * @@param request the ZOrder Request
	 * @@return the command to execute
	 */
	protected Command getBringToFrontCommand( ZOrderRequest request ) {
		
		CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
		
		// Create commands for each view to move
		for (Iterator iter = sortSelection( request.getPartsToOrder() ).iterator();
			iter.hasNext(); ) {
			
			IGraphicalEditPart element = (IGraphicalEditPart) iter.next();
			toReturn.compose(new BringToFrontCommand(
d200 19
a218 19
		}
		
		return new ICommandProxy( toReturn );
	}

	/**
	 * Returns a command the moves the selected views one step toward the front
	 * @@param request the ZOrder Request
	 * @@return the command to execute
	 */
	protected Command getBringForwardCommand( ZOrderRequest request ) {
		
		CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
	
		// Create commands for each view to move
		for (Iterator iter = reverseSortSelection( request.getPartsToOrder() ).iterator(); iter.hasNext();) {
			IGraphicalEditPart toOrder = (IGraphicalEditPart) iter.next();
			
			toReturn.compose(new BringForwardCommand(
d220 19
a238 19
		}
		
		return new ICommandProxy( toReturn );
	}

	/**
	 * Returns a command the moves the selected views to the back
	 * @@param request the ZOrder Request
	 * @@return the command to execute
	 */
	protected Command getSendToBackCommand( ZOrderRequest request ) {
		
		CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
		
		// Create commands for each view to move
		for (Iterator iter = reverseSortSelection(request.getPartsToOrder()).iterator(); iter.hasNext();) {
			IGraphicalEditPart toOrder = (IGraphicalEditPart) iter.next();
			
			toReturn.compose(new SendToBackCommand(toOrder.getEditingDomain(),
d240 19
a258 19
		}
		
		return new ICommandProxy( toReturn );
	}
	
	/**
 	 * Returns a command the moves the selected views one step toward the back
	 * @@param request the ZOrder Request
	 * @@return the command to execute
	 */
	protected Command getSendBackwardCommand( ZOrderRequest request ) {

		CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
		
		// Create commands for each view to move
		for (Iterator iter = sortSelection(request.getPartsToOrder()).iterator(); iter.hasNext();) {
			IGraphicalEditPart toOrder = (IGraphicalEditPart) iter.next();
			
			toReturn.compose(new SendBackwardCommand(
d260 14
a273 14
		}
		
		return new ICommandProxy( toReturn );
	}

	/**
	 * gets an arrange command 
	 * @@param request
	 * @@return command
	 */
	protected Command getArrangeCommand(ArrangeRequest request) {
		
		if (RequestConstants.REQ_ARRANGE_DEFERRED.equals(request.getType())) {
			String layoutType = request.getLayoutType();
d276 27
a302 27
			return new ICommandProxy(
				new DeferredLayoutCommand(editingDomain,
					request.getViewAdaptersToArrange(),
					(IGraphicalEditPart) getHost(),
					layoutType));
		}
		
		String layoutDesc = request.getLayoutType() != null ? request.getLayoutType() : LayoutType.DEFAULT;
		boolean offsetFromBoundingBox = false;
		List editparts = new ArrayList();
		
		if ( (ActionIds.ACTION_ARRANGE_ALL.equals(request.getType())) || 
			 (ActionIds.ACTION_TOOLBAR_ARRANGE_ALL.equals(request.getType()))) {
			editparts = ((IGraphicalEditPart)getHost()).getChildren();			
			request.setPartsToArrange(editparts);
		}
		if ( (ActionIds.ACTION_ARRANGE_SELECTION.equals(request.getType())) ||
			 (ActionIds.ACTION_TOOLBAR_ARRANGE_SELECTION.equals(request.getType()))) {
			editparts = request.getPartsToArrange();
			offsetFromBoundingBox = true;
		} 
		if (RequestConstants.REQ_ARRANGE_RADIAL.equals(request.getType())) {
			editparts = request.getPartsToArrange();
			offsetFromBoundingBox = true;
			layoutDesc = LayoutType.RADIAL;
		}
		if (editparts.isEmpty())
d304 28
a331 29
		List nodes = new ArrayList(editparts.size());
		ListIterator li = editparts.listIterator();
		while (li.hasNext()) {
			IGraphicalEditPart ep = (IGraphicalEditPart)li.next();
			View view = ep.getNotationView();
			if (view != null && view instanceof Node) {
				Rectangle bounds = ep.getFigure().getBounds();
				nodes.add(new LayoutNode((Node)view, bounds.width, bounds.height));
			}
		}
		
		List hints = new ArrayList(2);
		hints.add(layoutDesc);
		hints.add(getHost());
		IAdaptable layoutHint = new ObjectAdapter(hints);
		final Runnable layoutRun = layoutNodes(nodes, offsetFromBoundingBox, layoutHint);

		boolean isSnap = true;
		
		IWorkbenchPart activePart = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActivePart();
		if (activePart != null){
		     IDiagramWorkbenchPart editor = (IDiagramWorkbenchPart) activePart;
		     if (editor != null){
		    	   DiagramGraphicalViewer viewer = (DiagramGraphicalViewer) editor.getDiagramGraphicalViewer();
		           IPreferenceStore preferenceStore = viewer.getWorkspaceViewerPreferenceStore();	
		           isSnap = preferenceStore.getBoolean(WorkspaceViewerProperties.SNAPTOGRID);
		     }
		}        
     
d333 7
a339 7
        //is intended to make the code more appear more logical		
				
		CompoundCommand cmd = new CompoundCommand();		
		if (layoutRun instanceof IInternalLayoutRunnable) {
			cmd.add(((IInternalLayoutRunnable) layoutRun).getCommand());		
		}
		else {
d343 1
a343 1
				protected CommandResult doExecuteWithResult(
d346 39
a384 39
					layoutRun.run();
					return CommandResult.newOKCommandResult();
				}
			}));     
		}		
		if (isSnap) {
			cmd.add(getSnapCommand(request));
		}
		return cmd;
	}
	
	/**
	 * @@param offsetFromBoundingBox
	 * @@param nodes
	 * @@param layoutHint
	 * @@return runnable
	 */
	public Runnable layoutNodes(List nodes, boolean offsetFromBoundingBox, IAdaptable layoutHint) {
		final Runnable layoutRun =  LayoutService.getInstance().layoutLayoutNodes(nodes, offsetFromBoundingBox, layoutHint);
		return layoutRun;
	}

	/**
	 * Returns a command to to duplicate views and their underlying semantic
	 * elements (if applicable) of the given editparts.
	 * 
	 * @@param request
	 *            the <code>DuplicateElementsRequest</code> whose list of duplicated
	 *            views will be populated when the command is executed
	 * @@return the command to perform the duplication
	 */
	private Command getDuplicateCommand(DuplicateRequest request) {
		List notationViewsToDuplicate = new ArrayList();
		Set elementsToDuplicate = new HashSet();

		for (Iterator iter = request.getEditParts().iterator(); iter.hasNext();) {
			Object ep = iter.next();
			
			// Disable duplicate on groups for now.  See bugzilla 182972.
d388 47
a434 47
			
			if (ep instanceof ConnectionEditPart || ep instanceof ShapeEditPart
				|| ep instanceof ListItemEditPart) {
			    
				View notationView = (View)((IGraphicalEditPart) ep).getModel();
				if (notationView != null) {
					notationViewsToDuplicate.add(notationView);
				}
			}
		}
		
		// Remove views whose container view is getting copied.
		ClipboardSupportUtil.getCopyElements(notationViewsToDuplicate);
		
		TransactionalEditingDomain editingDomain = ((IGraphicalEditPart)getHost()).getEditingDomain();
		
		for (Iterator iter = notationViewsToDuplicate.iterator(); iter
				.hasNext();) {
			View view = (View) iter.next();
			EObject element = view.getElement();

			if (element != null) {
				EObject resolvedElement = EMFCoreUtil.resolve(editingDomain,
						element);
				if (resolvedElement != null) {
					elementsToDuplicate.add(resolvedElement);
				}
			}
		}

		/*
		 * We must append all inner edges of a node being duplicated. Edges are non-containment
		 * references, hence they won't be duplicated for free. Therefore, we add them here to
		 * the list views to duplicate.
		 * We don't add semantic elements of the edges to the list of semantic elements to duplicate
		 * since we assume that their semantic elements are owned by source or target or their semantic
		 * containers. 
		 */
		HashSet<Edge> allInnerEdges = new HashSet<Edge>();
		for (Iterator itr = notationViewsToDuplicate.iterator(); itr.hasNext();) {
			ViewUtil.getAllRelatedEdgesFromViews(((View)itr.next()).getChildren(), allInnerEdges);
		}
		notationViewsToDuplicate.addAll(allInnerEdges);
		
		if (!notationViewsToDuplicate.isEmpty()) {
			if (!elementsToDuplicate.isEmpty()) {
				org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest duplicateElementsRequest = new DuplicateElementsRequest(
d436 10
a445 10
				
				Command duplicateElementsCommand = getHost().getCommand(
					new EditCommandRequestWrapper(duplicateElementsRequest, request.getExtendedData()));
				if (duplicateElementsCommand != null
					&& duplicateElementsCommand.canExecute()) {
					CompositeCommand cc = new CompositeCommand(
						DiagramUIMessages.Commands_Duplicate_Label);
					cc
						.compose(new CommandProxy(
							duplicateElementsCommand));
d447 16
a462 16
					cc.compose(new DuplicateViewsCommand(editingDomain,
						DiagramUIMessages.Commands_Duplicate_Label,
						request, notationViewsToDuplicate,
						duplicateElementsRequest.getAllDuplicatedElementsMap(), getDuplicateViewsOffset(request)));
					return new ICommandProxy(cc);
				}
			} else {
				return new ICommandProxy(new DuplicateViewsCommand(editingDomain,
					DiagramUIMessages.Commands_Duplicate_Label,
					request, notationViewsToDuplicate, getDuplicateViewsOffset(request)));
			}
		}
		return null;
	}
	
	private Point getDuplicateViewsOffset(DuplicateRequest request) {
d471 23
a493 23
	
	private Command getSnapCommand(Request request){
			
		List editparts = null;
		if (request instanceof GroupRequest){			
			editparts =  ((GroupRequest)request).getEditParts();
		}	
		else if (request instanceof ArrangeRequest){
			editparts = ((ArrangeRequest)request).getPartsToArrange();
		}
		
		TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
				.getEditingDomain();
		if (editparts != null){
			return new ICommandProxy(new SnapCommand(editingDomain, editparts));
		}		
		return null;
	}
	
	/**
	 * @@see org.eclipse.gef.EditPolicy#getCommand(Request)
	 */
	public Command getCommand(Request request) {
d499 33
a531 49
			return getArrangeCommand((ArrangeRequest)request);
		}		
		
		if (RequestConstants.REQ_SNAP_TO_GRID.equals(request.getType())){
			return getSnapCommand(request);
		}
		
		if (RequestConstants.REQ_REFRESH.equals(request.getType())) {
			IGraphicalEditPart containerEP = (IGraphicalEditPart) getHost();

			CompositeCommand cc = new CompositeCommand(""); //$NON-NLS-1$
			ListIterator li = containerEP.getChildren().listIterator();
			while (li.hasNext()) {
				cc.compose(
					new RefreshEditPartCommand(
						(IGraphicalEditPart) li.next(),
						false));
			}
			cc.compose(
				new RefreshEditPartCommand(
					(IGraphicalEditPart) getHost(),
					true));

			return new ICommandProxy(cc);
		}

		if (RequestConstants.REQ_PASTE.equals(request.getType())) {
			return getPasteCommand((PasteViewRequest) request);
		}

		if (RequestConstants.REQ_DUPLICATE.equals(request.getType())) {
			return getDuplicateCommand(((DuplicateRequest) request));
		}

		if (ZOrderRequest.REQ_BRING_TO_FRONT.equals(request.getType())) {
			return getBringToFrontCommand((ZOrderRequest) request);
		}
		
		if (ZOrderRequest.REQ_BRING_FORWARD.equals(request.getType())) {
			return getBringForwardCommand((ZOrderRequest) request);
		}
		
		if (ZOrderRequest.REQ_SEND_TO_BACK.equals(request.getType())) {
			return getSendToBackCommand((ZOrderRequest) request);
		}
		
		if (ZOrderRequest.REQ_SEND_BACKWARD.equals(request.getType())) {
			return getSendBackwardCommand((ZOrderRequest) request);
		}
d533 18
a550 2
		return super.getCommand(request);
	}
d593 1
a593 1
        }
d601 14
a614 14
	 * @@see org.eclipse.gef.EditPolicy#getTargetEditPart(org.eclipse.gef.Request)
	 */
	public EditPart getTargetEditPart(Request request) {
		return understandsRequest(request) ? getHost() : null;
	}

	/**
	 * @@see org.eclipse.gef.EditPolicy#understandsRequest(org.eclipse.gef.Request)
	 */
	public boolean understandsRequest(Request request) {
		return (
			ActionIds.ACTION_ARRANGE_ALL.equals(request.getType())
				|| ActionIds.ACTION_TOOLBAR_ARRANGE_ALL.equals(request.getType())
				|| ActionIds.ACTION_ARRANGE_SELECTION.equals(request.getType())
d616 12
a627 12
				|| ActionIds.ACTION_TOOLBAR_ARRANGE_SELECTION.equals(request.getType())				
				|| RequestConstants.REQ_ARRANGE_RADIAL.equals(request.getType())
				|| RequestConstants.REQ_ARRANGE_DEFERRED.equals(request.getType())
				|| RequestConstants.REQ_REFRESH.equals(request.getType())
				|| RequestConstants.REQ_PASTE.equals(request.getType())
				|| RequestConstants.REQ_DUPLICATE.equals(request.getType())
				|| RequestConstants.REQ_SNAP_TO_GRID.equals(request.getType())
				|| ZOrderRequest.REQ_BRING_TO_FRONT.equals(request.getType())
				|| ZOrderRequest.REQ_BRING_FORWARD.equals(request.getType())
				|| ZOrderRequest.REQ_SEND_TO_BACK.equals(request.getType())
				|| ZOrderRequest.REQ_SEND_BACKWARD.equals(request.getType()));
	}
@


1.21
log
@[119252] gmf_head crevells 071120 [RulersGrid] Useability: diagram arrange all should snap to grid if snap to grid is on
Contributed by:  Carson Li
@
text
@d19 1
d34 1
d42 1
d53 2
d61 1
d387 6
d395 1
a395 1
								
d498 5
a502 2
		
		if (request instanceof ArrangeRequest) {
d556 49
a604 1
	/**
d619 1
@


1.20
log
@[208622] gmf_HEAD aboyko 071102 Contents of Canonical compartments are duplicated incorrectly
@
text
@d33 1
d56 1
d58 1
d63 2
d80 3
d286 2
a287 1
			editparts = ((IGraphicalEditPart)getHost()).getChildren();
d317 2
d320 14
d335 1
a335 1
			return ((IInternalLayoutRunnable)layoutRun).getCommand();
d339 2
a340 3
                .getEditingDomain();
            
			return new ICommandProxy(new AbstractTransactionalCommand(editingDomain, "", null) {//$NON-NLS-1$
d347 4
a350 1
			});
d352 1
d464 18
d489 4
d494 1
a494 1

d556 1
a556 1
				|| ActionIds.ACTION_TOOLBAR_ARRANGE_SELECTION.equals(request.getType())
d562 1
@


1.19
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d43 1
d72 1
d368 2
a369 1
		for (Iterator iter = notationViewsToDuplicate.iterator(); iter.hasNext();) {
d372 1
a372 1
			
d374 2
a375 2
				EObject resolvedElement = EMFCoreUtil
					.resolve(editingDomain, element);
d382 14
@


1.19.2.1
log
@[111892] gmf_head crevells 070518 First milestone of group/ungroup support (painting issues when grouping shapes with border items)
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
a18 1
import java.util.LinkedList;
a38 1
import org.eclipse.gmf.runtime.diagram.core.commands.GroupCommand;
a47 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart;
a53 1
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IEditableEditPart;
d423 2
a424 5
        if (ActionIds.ACTION_GROUP.equals(request.getType())
            && request instanceof GroupRequest) {
            return getGroupCommand((GroupRequest) request);
        } 
        else if (request instanceof ArrangeRequest) {
d474 1
a474 49
    /**
     * Returns a command to group the editparts in the request.
     * 
     * @@param request
     *            the request containing the editparts to be grouped.
     * @@return the command to perform the grouping
     */
    protected Command getGroupCommand(GroupRequest request) {
        List shapeViews = new LinkedList();
        IGraphicalEditPart parentEP = null;
        for (Iterator iter = request.getEditParts().iterator(); iter.hasNext();) {
            Object editpart = iter.next();

            if (editpart instanceof ShapeEditPart) {

                if (!((IEditableEditPart) editpart).isEditModeEnabled()) {
                    return null;
                }
                
                if (editpart instanceof IBorderItemEditPart) {
                    return null;
                }

                if (parentEP != null) {
                    if (parentEP != ((ShapeEditPart) editpart).getParent()) {
                        // can only group shapes with the same parent
                        return null;
                    }
                } else {
                    parentEP = (IGraphicalEditPart) ((ShapeEditPart) editpart)
                        .getParent();
                }

                if (((ShapeEditPart) editpart).getModel() instanceof Node) {
                    shapeViews.add(((ShapeEditPart) editpart).getModel());
                }
            }
        }

        if (parentEP == null || !parentEP.isEditModeEnabled()) {
            return null;
        }

        GroupCommand cmd = new GroupCommand(((IGraphicalEditPart) getHost())
            .getEditingDomain(), shapeViews);
        return new ICommandProxy(cmd);
    }

    /**
a488 1
                || ActionIds.ACTION_GROUP.equals(request.getType())
@


1.18
log
@[139856] gmf_head anthonyh 060614 EtoolsProxyCommand should be renamed to ICommandProxy
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d353 1
a353 13
				
				// More work needs to be done to duplicate connections whose
				// source or target isn't also duplicated, so disable for now.
				if (ep instanceof ConnectionEditPart) {
					ConnectionEditPart connectionEP = (ConnectionEditPart) ep;
					if (!request.getEditParts().contains(
						connectionEP.getSource())
						|| !request.getEditParts().contains(
							connectionEP.getTarget())) {
						return null;
					}
				}
				
@


1.18.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.18.2.2
log
@Bugzilla#157685 gmf_R1_0_maintenance crevells 060918 Add ability to duplicate a connection without also duplicating the two ends
@
text
@d353 13
a365 1
								
@


1.17
log
@[137749] gmf_head ldamus 060517 Transfer GEF Request's extended data into IEditCommandRequest's parameters
@
text
@d46 1
a46 1
import org.eclipse.gmf.runtime.diagram.ui.commands.EtoolsProxyCommand;
d119 1
a119 1
			return new EtoolsProxyCommand(new PasteCommand(editPart
d189 1
a189 1
		return new EtoolsProxyCommand( toReturn );
d209 1
a209 1
		return new EtoolsProxyCommand( toReturn );
d229 1
a229 1
		return new EtoolsProxyCommand( toReturn );
d249 1
a249 1
		return new EtoolsProxyCommand( toReturn );
d263 1
a263 1
			return new EtoolsProxyCommand(
d314 1
a314 1
			return new EtoolsProxyCommand(new AbstractTransactionalCommand(editingDomain, "", null) {//$NON-NLS-1$
d410 1
a410 1
					return new EtoolsProxyCommand(cc);
d413 1
a413 1
				return new EtoolsProxyCommand(new DuplicateViewsCommand(editingDomain,
d456 1
a456 1
			return new EtoolsProxyCommand(cc);
@


1.16
log
@Bugzilla#140166 gmf_head cmahoney 060515 Move necessary client accessed internal classes into public API
@
text
@d395 1
d397 1
a397 1
					new EditCommandRequestWrapper(duplicateElementsRequest));
d513 1
a513 1
}
@


1.15
log
@Bugzilla#124034 gmf_head cmahoney 060418 DragEditPartsTrackerEx should create DuplicateRequests since suberclass creates Clone requests
@
text
@a54 1
import org.eclipse.gmf.runtime.diagram.ui.internal.requests.DuplicateRequest;
d60 1
@


1.14
log
@bugzilla 130671 gmf-head mmostafa 060324 Executing an Arrange All with no nodes causes exception
@
text
@d26 1
d408 1
a408 1
						duplicateElementsRequest.getAllDuplicatedElementsMap(), getPasteOffset()));
d414 1
a414 1
					request, notationViewsToDuplicate, getPasteOffset()));
d420 9
a428 3
	private int getPasteOffset() {
		return MapModeUtil.getMapMode(((org.eclipse.gef.GraphicalEditPart)getHost()).getFigure()).DPtoLP(10);
	}
@


1.13
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d287 2
a288 1
		
@


1.12
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@a41 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
d43 1
a45 1
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
d68 1
a68 2
import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;
import org.eclipse.gmf.runtime.emf.core.util.ProxyUtil;
a72 3
/*
 * @@canBeSeenBy %partners
 */
d123 1
a123 1
        }
d177 1
a177 1
        CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
d186 1
a186 1
        }
d206 1
a206 1
        }
d218 1
a218 1
        CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
d226 1
a226 1
        }
d238 1
a238 1
        CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
d246 1
a246 1
        }
d262 1
a262 1
            return new EtoolsProxyCommand(
d374 1
a374 1
		MEditingDomain editingDomain = MEditingDomainGetter.getMEditingDomain((View)getHost().getModel());
d381 1
a381 1
				EObject resolvedElement = ProxyUtil
d391 1
a391 1
                org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest duplicateElementsRequest = new DuplicateElementsRequest(
d397 1
a397 1
                    CompositeCommand cc = new CompositeCommand(
d434 1
a434 1
            CompositeCommand cc = new CompositeCommand(""); //$NON-NLS-1$
@


1.11
log
@bugzilla 109923 gmf-head mmostafa 060201 Class names contain 'xtools'
@
text
@d23 1
d28 1
d68 1
a68 1
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractModelCommand;
d123 6
a128 2
			return new EtoolsProxyCommand(new PasteCommand(DiagramUIMessages.PasteCommand_Label, viewContext, data, MapModeUtil.getMapMode(((org.eclipse.gef.GraphicalEditPart)getHost()).getFigure()))); 
		}
d182 1
a182 1
		CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
d189 3
a191 2
			toReturn.compose( new BringToFrontCommand((View) element.getModel() ));
		}
d209 3
a211 2
			toReturn.compose(new BringForwardCommand((View)toOrder.getModel() ));
		}
d223 1
a223 1
		CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
d229 3
a231 2
			toReturn.compose(new SendToBackCommand((View)toOrder.getModel() ));
		}
d243 1
a243 1
		CompositeCommand toReturn = new CompositeCommand( "" ); //$NON-NLS-1$
d249 3
a251 2
			toReturn.compose(new SendBackwardCommand((View)toOrder.getModel() ));
		}
d265 4
a268 2
			return new EtoolsProxyCommand(
				new DeferredLayoutCommand(
d314 7
a320 2
			return new EtoolsProxyCommand(new AbstractModelCommand("", null) {//$NON-NLS-1$
				protected CommandResult doExecute(IProgressMonitor progressMonitor) {
d322 1
a322 1
					return newOKCommandResult();
d396 2
a397 2
				org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest duplicateElementsRequest = new DuplicateElementsRequest(
					new ArrayList(elementsToDuplicate));
d402 1
a402 1
					CompositeCommand cc = new CompositeCommand(
d407 2
a408 1
					cc.compose(new DuplicateViewsCommand(
d415 1
a415 1
				return new EtoolsProxyCommand(new DuplicateViewsCommand(
d439 1
a439 1
			CompositeCommand cc = new CompositeCommand(""); //$NON-NLS-1$
@


1.10
log
@bugzilla 116224 gmf-head sshaw 060119 Notation meta-model support for coordinate systems
@
text
@d44 1
a44 1
import org.eclipse.gmf.runtime.diagram.ui.commands.XtoolsProxyCommand;
d388 1
a388 1
						.compose(new XtoolsProxyCommand(
@


1.9
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d121 1
a121 1
			return new EtoolsProxyCommand(new PasteCommand(DiagramUIMessages.PasteCommand_Label, viewContext, data, getPasteOffset())); 
a125 4

	private int getPasteOffset() {
		return MapModeUtil.getMapMode(((org.eclipse.gef.GraphicalEditPart)getHost()).getFigure()).DPtoLP(10);
	}
d405 4
@


1.8
log
@bugzilla 116490 gmf-head sshaw 051124 LayoutService should be public
@
text
@d57 1
a57 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d121 1
a121 1
			return new EtoolsProxyCommand(new PasteCommand(DiagramResourceManager.getI18NString("PasteCommand.Label"), viewContext, data, getPasteOffset())); //$NON-NLS-1$
d390 1
a390 2
						DiagramResourceManager
							.getI18NString("Commands.Duplicate.Label")); //$NON-NLS-1$
d395 1
a395 2
						DiagramResourceManager
							.getI18NString("Commands.Duplicate.Label"), //$NON-NLS-1$
d402 1
a402 2
					DiagramResourceManager
						.getI18NString("Commands.Duplicate.Label"), //$NON-NLS-1$
@


1.7
log
@Bugzilla#116030 gmf_head cmahoney 051121 Diagram ActionIds should be public
@
text
@a56 1
import org.eclipse.gmf.runtime.diagram.ui.internal.services.layout.LayoutService;
d62 1
d322 1
a322 1
		final Runnable layoutRun =  LayoutService.getInstance().layoutNodes(nodes, offsetFromBoundingBox, layoutHint);
@


1.6
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d41 1
a52 1
import org.eclipse.gmf.runtime.diagram.ui.internal.requests.ActionIds;
@


1.5
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d64 1
d121 1
a121 1
			return new EtoolsProxyCommand(new PasteCommand(DiagramResourceManager.getI18NString("PasteCommand.Label"), viewContext, data)); //$NON-NLS-1$
d127 4
d399 1
a399 1
						duplicateElementsRequest.getAllDuplicatedElementsMap()));
d406 1
a406 1
					request, notationViewsToDuplicate));
@


1.4
log
@Bugzilla 112855 gmf_head sshaw 051025 Duplicate should be enabled on shape compartment editparts
Contributed by: Cherie Mahoney
@
text
@d46 1
a46 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.ListItemCompartmentEditPart;
d58 1
a58 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d120 1
a120 1
			return new EtoolsProxyCommand(new PasteCommand(PresentationResourceManager.getI18NString("PasteCommand.Label"), viewContext, data)); //$NON-NLS-1$
d337 1
a337 1
				|| ep instanceof ListItemCompartmentEditPart) {
d385 1
a385 1
						PresentationResourceManager
d391 1
a391 1
						PresentationResourceManager
d399 1
a399 1
					PresentationResourceManager
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a31 1

a46 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.ShapeCompartmentEditPart;
a47 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.TopGraphicEditPart;
a338 9
				// TODO: Remove when I've had a chance to test this on machine
				// diagrams.
				TopGraphicEditPart topEP = ((IGraphicalEditPart) ep)
					.getTopGraphicEditPart();
				if (topEP != null
					&& topEP.getParent() instanceof ShapeCompartmentEditPart) {
					return null;
				}
				
d382 2
a383 1
				if (duplicateElementsCommand != null) {
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d70 2
a71 2
import com.ibm.xtools.notation.Node;
import com.ibm.xtools.notation.View;
@

