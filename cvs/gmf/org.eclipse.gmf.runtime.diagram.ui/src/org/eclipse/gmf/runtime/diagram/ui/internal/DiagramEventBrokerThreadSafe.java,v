head	1.2;
access;
symbols
	v20081023-2107:1.2
	v20081022-1925:1.2
	v20081022-1005:1.2
	v20081020-0700:1.2
	v20080917-1925:1.2
	v20080916-2008:1.2
	v20080911-1728:1.2
	v20080911-1506:1.2
	v20080910-1520:1.2
	v20080910-1510:1.2
	v20080903-1520:1.2
	v20080903-1510:1.2
	v20080813-1510:1.2
	v20080811-1546:1.2
	v20080731-1520:1.2
	v20080725-1738:1.2
	v20080723-2246:1.2
	v20080723-2232:1.2
	v20080723-1700:1.2
	v20080722-1827:1.2
	v20080718-1700:1.2
	v20080718-1731:1.2
	v20080716-1600:1.2
	v20080716-1642:1.2
	R2_1_maintenance:1.2.0.8
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080610-1132:1.2
	v20080603-1553:1.2
	v20080527-1255:1.2
	v20080527-1151:1.2
	v20080516-1748:1.2
	v20080516-1143:1.2
	v20080512-1200:1.2
	v20080503-1740:1.2
	v20080501-2127:1.2
	v20080501-1739:1.2
	m20080429-1543:1.2
	v20080425-1959:1.2
	v20080417-1610:1.2
	v20080407-2250:1.2
	v20080407-0930:1.2
	v20080404-1111:1.2
	v20080328-1605:1.2
	v20080322-0000:1.2
	v20080222-1200:1.2
	v20080201-2010:1.2
	v20080201-0201:1.2
	v20080118-1129:1.2
	v20080114-2222:1.2
	v20080114-1111:1.2
	v20080107-1111:1.2
	v20071222-1111:1.2
	v20071214-1111:1.2
	v20071130-1111:1.2
	v20071124-0000:1.2
	v20071112-0000:1.2
	v20071108-0000:1.2
	v20071003-0000:1.2
	v20070915-0000:1.2
	v20070903-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.6
	R2_0:1.2
	R4_20:1.2
	v20070621-0000:1.2
	RC3_20:1.2
	v20070614-1400:1.2
	v20070608-1300:1.2
	v20070605-1400:1.2
	v20070601-1400:1.2
	v20070525-1500:1.2
	v20070518-1300:1.2
	bugzilla111892_group_support:1.2.0.4
	Root_bugzilla111892_group_support:1.2
	v20070504-1000:1.2
	v20070420-1000:1.2
	v20070413-1300:1.2
	v20070330-1300:1.2
	v20060330-1300:1.2
	v20070322-1100:1.2
	v20060316-0600:1.2
	v20070221-1500:1.2
	v20070208-1800:1.2
	v20070202-0200:1.2
	v20070119-1200:1.2
	v20070111-0800:1.2
	v20070105-1200:1.2
	v20070103-0300:1.2
	M4_20:1.2
	v20061218-1500:1.2
	v20061218-1200:1.2
	v20061214-0000:1.2
	M3_20:1.2
	v20061117-0800:1.2
	v20061027-1200:1.2
	v20061013-1330:1.2
	v20061012-1100:1.2
	v20060925-1700:1.2
	v20060919-0800:1.2
	v20060907-1100:1.2
	M1_20:1.2
	v20060831-1500:1.2
	v20060824-1600:1.2
	v20060817-1500:1.2
	v20060810-1700:1.2
	v20060803-1200:1.2
	v20060728-0500:1.2
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1400:1.2
	v20060616-1200:1.2
	v20060609-1400:1.1
	v20060531-1730:1.1;
locks; strict;
comment	@# @;


1.2
date	2006.06.16.15.34.30;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.31.16.26.07;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.2
log
@bugzilla 143198 gmf-head sshaw 060616 SWTExceptions occurring when handling notifications from worker thread transactions
@
text
@/******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/
package org.eclipse.gmf.runtime.diagram.ui.internal;

import java.lang.ref.WeakReference;

import org.eclipse.emf.transaction.ResourceSetChangeEvent;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.PlatformUI;

/**
 * This is an extension of the DiagramEventBroker that has special handling for notifications that
 * occurs from a worker thread / non-UI thread.  If the notification occurs on the main thread
 * then execution is delegated to the super class immediately.  If execution is not on the main thread
 * then there are 2 scenarios that have to be considered.  
 * 
 * The first scenario is for a long operation
 * that has been exeucted with a progress meter, where the progress meter is displaying UI on the main
 * thread and there is a background thread that is being executed that the progress meter is monitoring.
 * For this scenario, the UI updates on the diagram viewer have been disabled so as to avoid concurrency
 * issues.  When notifications are handled, they are synchronized to the main thread to avoid
 * SWTExceptions when UI tries to access SWT resources when updating figures or other UI.
 * 
 * The second scenario is for when a job has been executed on a worker thread, but has not been executed
 * through the OperationHistory.  Consequently, there is no hook for turning off display updates.  This
 * means that if the notifications were to continue on the worker thread, then the display could update
 * at the same time on the main thread thereby causing concurrent modification errors and other errors.
 * In this case, we need to resynchronize the notifications with the main thread.  In order to do this
 * it is necessary to run the notifications in an synchronous runnable that will run immediately
 * on the main thread.
 * 
 * @@author sshaw
 */
class DiagramEventBrokerThreadSafe extends DiagramEventBroker {

	WeakReference editingDomainRef;
	
    public DiagramEventBrokerThreadSafe(TransactionalEditingDomain editingDomain) {
        super();
        editingDomainRef = new WeakReference(editingDomain);
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker#resourceSetChanged(org.eclipse.emf.transaction.ResourceSetChangeEvent)
     */
    public void resourceSetChanged(ResourceSetChangeEvent event) {
        if (shouldSynchronizeWithMainThread(event)) {
           	// force synchronization with the main thread
            final ResourceSetChangeEvent eventToHandle = event;
            TransactionalEditingDomain editingDomain = (TransactionalEditingDomain)editingDomainRef.get();
            if (editingDomain != null) {
	            PlatformUI.getWorkbench().getDisplay().syncExec(editingDomain.createPrivilegedRunnable(new Runnable() { 
	                public void run() {
	                    internal_resourceSetChanged(eventToHandle);
	                }
	            }));
	                
	            return;
            }
        }
        
        super.resourceSetChanged(event);
    }
    
    private boolean shouldSynchronizeWithMainThread(ResourceSetChangeEvent event) {
    	if (Display.getCurrent() == null)
    		return true;
        
        return false;
    }
    
    private void internal_resourceSetChanged(ResourceSetChangeEvent event) {
        super.resourceSetChanged(event);
    }
}@


1.1
log
@bugzilla 142803 gmf-head sshaw 060531 Illegal Asynchronous Access to ResourceSetChangeEvent in DiagramEventBrokerThreadSafe
@
text
@a13 2
import java.util.Iterator;
import java.util.Set;
a14 1
import org.eclipse.emf.common.notify.Notification;
a16 1
import org.eclipse.gef.EditPartViewer;
a17 2
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.NotificationForEditPartsListener;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
d31 2
a32 2
 * issues and it is desirable that the notifications continue to be handled on the worker thread so that
 * the progress meter doesn't lock up.
d57 10
a66 11
        if (Display.getCurrent() == null) {
        	if (shouldSynchronizeWithMainThread(event)) {
            	// force synchronization with the main thread
                final ResourceSetChangeEvent eventToHandle = event;
                TransactionalEditingDomain editingDomain = (TransactionalEditingDomain)editingDomainRef.get();
                if (editingDomain != null) {
	                PlatformUI.getWorkbench().getDisplay().syncExec(editingDomain.createPrivilegedRunnable(new Runnable() { 
	                    public void run() {
	                        internal_resourceSetChanged(eventToHandle);
	                    }
	                }));
d68 2
a69 3
	                return;
                }
        	}
d76 2
a77 17
    	
    	for (Iterator i = event.getNotifications().iterator(); i.hasNext();) {
        	final Notification notification = (Notification) i.next();
        	Set nlSet = getInterestedNotificationListeners(notification, false);
        	Iterator iter = nlSet.iterator();
        	while (iter.hasNext()) {
        		Object listener = iter.next();
            	if (listener instanceof NotificationForEditPartsListener) {
            		EditPartViewer viewer = ((NotificationForEditPartsListener)listener).getViewer();
            		if (viewer instanceof DiagramGraphicalViewer) {
                        if (!((DiagramGraphicalViewer)viewer).areUpdatesDisabled()) {
                        	return true;
                        }
                    }
            	}
        	}
         }
@

