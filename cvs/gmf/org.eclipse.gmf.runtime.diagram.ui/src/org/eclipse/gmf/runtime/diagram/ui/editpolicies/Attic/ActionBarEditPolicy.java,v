head	1.7;
access;
symbols
	v20081022-1925:1.7
	v20080917-1925:1.7
	v20080911-1728:1.7
	v20080910-1520:1.7
	v20080903-1520:1.7
	v20080731-1520:1.7
	v20080723-2246:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	I20051124-2000:1.6
	M3_10:1.6
	I20051118-1245:1.6
	I20051111-1800:1.6
	I20051106-0900:1.6
	v20051030:1.5;
locks; strict;
comment	@# @;


1.7
date	2005.11.25.19.34.26;	author cmahoney;	state dead;
branches;
next	1.6;

1.6
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.14.15.17.42;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.07.19.21.25;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.23.20.56.03;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.29.06;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.37;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Bugzilla#113157 gmf_head cmahoney 051125 Removing deprecated classes
@
text
@/******************************************************************************
 * Copyright (c) 2003, 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.draw2d.ColorConstants;
import org.eclipse.draw2d.FigureCanvas;
import org.eclipse.draw2d.FigureListener;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.Label;
import org.eclipse.draw2d.MouseEvent;
import org.eclipse.draw2d.MouseListener;
import org.eclipse.draw2d.RoundedRectangle;
import org.eclipse.draw2d.Viewport;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.DragTracker;
import org.eclipse.gef.Handle;
import org.eclipse.gef.LayerConstants;
import org.eclipse.gef.Tool;
import org.eclipse.gef.requests.CreateRequest;
import org.eclipse.gef.tools.SelectionTool;
import org.eclipse.gmf.runtime.common.ui.services.icon.IconService;
import org.eclipse.gmf.runtime.diagram.ui.IPreferenceConstants;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.ISurfaceEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.tools.AbstractPopupBarTool;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
import org.eclipse.gmf.runtime.diagram.ui.tools.AddUMLActionBarTool;
import org.eclipse.gmf.runtime.diagram.ui.tools.PopupBarTool;
import org.eclipse.gmf.runtime.diagram.ui.util.INotationType;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.emf.ui.services.modelingassistant.ModelingAssistantService;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Display;

/**
 * ActionBars are esentially a cartoon balloon with buttons that are activated
 * during mouse hover over a shape.
 * 
 * @@author affrantz@@us.ibm.com, cmahoney
 * @@deprecated Renamed to {@@link org.eclipse.gmf.runtime.diagram.ui.editpolicies.PopupBarEditPolicy}
 */
public class ActionBarEditPolicy extends DiagramAssistantEditPolicy {

	/* ************************** nested classes *********************** */
	/**
	 * 
	 * Class to hold pertinent information about the tool placed on the actionbar
	 * 
	 * @@author affrantz@@us.ibm.com
	 */
	private class ActionBarDescriptor {

		/** The action button tooltip */
		private String _tooltip = new String();

		/** The image for the button */
		private Image _icon = null;

		/** The typeinfo used to create the Request for the command */
		private IElementType _elementType;

		/** The DracgTracker / Tool associatd with the actionbar button */
		private DragTracker _dragTracker = null;

		/**
		 * constructor
		 * @@param s
		 * @@param i
		 * @@param elementType
		 * @@param theTracker
		 */
		public ActionBarDescriptor(
				String s,
				Image i,
				IElementType elementType,
				DragTracker theTracker) {
			_tooltip = s;
			_icon = i;
			_dragTracker = theTracker;
			_elementType = elementType;

		}

		/**
		 * gets the element type associated with this Descriptor
		 * @@return element type
		 */
		public final IElementType getElementtype() {
			return _elementType;
		}

		/**
		 * gets the icon associated with this Descriptor
		 * @@return Image
		 */
		public final Image getIcon() {
			return _icon;
		}

		/**
		 * gets the drag tracker associated with this Descriptor
		 * @@return drag tracker
		 */
		public final DragTracker getDragTracker() {
			return _dragTracker;
		}

		/**
		 * gets the tool tip associated with this Descriptor
		 * @@return string
		 */
		public final String getToolTip() {
			return _tooltip;
		}

	} // end ActionBarDescriptor

	/**
	 * Default tool placed on the actionbar
	 * 
	 * @@author affrantz@@us.ibm.com
	 */
	private class ActionBarLabelHandle extends Label implements Handle {
		/**
		 * flag to drawFocus rect around the handle when the mouse rolls over
		 * it
		 */
		private boolean myMouseOver = false;

		private Image myDisabledImage = null;

		/** The dragTracker CreationTool associated with the handle * */
		private DragTracker myDragTracker = null;

		private Image getDisabledImage()
		{
			if (myDisabledImage != null)
				return myDisabledImage;

			Image theImage = this.getIcon();
			if (theImage == null)
				return null;

			myDisabledImage = new Image(Display.getCurrent(), theImage, SWT.IMAGE_DISABLE);
			imagesToBeDisposed.add(myDisabledImage);
			return myDisabledImage;
		}

		/**
		 * cnostructor
		 * @@param tracker
		 * @@param theImage
		 */
		public ActionBarLabelHandle(DragTracker tracker, Image theImage) {
			super(theImage);
			myDragTracker = tracker;
			this.setOpaque(true);
			this.setBackgroundColor(ColorConstants.buttonLightest);
		}

		/**
		 * @@see org.eclipse.gef.Handle#getAccessibleLocation()
		 */
		public Point getAccessibleLocation() {
			return null;
		}

		/**
		 * @@see org.eclipse.gef.Handle#getDragTracker()
		 */
		public DragTracker getDragTracker() {
			return myDragTracker;
		}

		/**
		 * @@see org.eclipse.draw2d.Figure#paintBorder(org.eclipse.draw2d.Graphics)
		 *      paint a focus rectangle for the label if the mouse is inside
		 *      the label
		 */
		protected void paintBorder(Graphics graphics) {
			super.paintBorder(graphics);

			if (myMouseOver) {

				Rectangle area = getClientArea();
				graphics.setForegroundColor(ColorConstants.black);
				graphics.setBackgroundColor(ColorConstants.white);

				graphics.drawFocus(
					area.x,
					area.y,
					area.width - 1,
					area.height - 1);

			}

		}

		/**
		 * @@see org.eclipse.draw2d.IFigure#handleMouseEntered(org.eclipse.draw2d.MouseEvent)
		 *      flip myMouseOver bit and repaint
		 */
		public void handleMouseEntered(MouseEvent event) {

			super.handleMouseEntered(event);
			myMouseOver = true;
			repaint();
		}

		/**
		 * @@see org.eclipse.draw2d.IFigure#handleMouseExited(org.eclipse.draw2d.MouseEvent)
		 *      flip myMouseOver bit and repaint
		 */
		public void handleMouseExited(MouseEvent event) {

			super.handleMouseExited(event);
			myMouseOver = false;
			repaint();
		}

		/**
		 * @@see org.eclipse.draw2d.IFigure#handleMousePressed(org.eclipse.draw2d.MouseEvent)
		 *      set ActionBarEditPolicy.myActionMoveFigure bit so the ActionBar
		 *      is not dismissed after creating an item in the editpart
		 * 
		 */
		public void handleMousePressed(MouseEvent event) {

			if (1 == event.button) 
			{
				// this is the flag in ActionBarEditPolicy that
				// prevents the actionbar from dismissing after a new item
				// is added to a shape, which causes the editpart to be
				// resized.
				setFlag(ACTIONBAR_MOVE_FIGURE, true);
				// future: when other tools besides PopupBarTool are
				// used
				// we will need a way in which to call

			}

			super.handleMousePressed(event);
		}

		/**
		 * checks if tool tip is enabled or not
		 * @@return true or false
		 */
		protected boolean isToolEnabled()
		{
			if((myDragTracker != null) && (myDragTracker instanceof AbstractPopupBarTool))
			{
				AbstractPopupBarTool abarTool = (AbstractPopupBarTool) myDragTracker;
				return abarTool.isCommandEnabled();
			}
			return true;
		}

		/**
		 * @@see org.eclipse.draw2d.Figure#paintFigure(org.eclipse.draw2d.Graphics)
		 */
		protected void paintFigure(Graphics graphics) {
			if(!isToolEnabled())
			{
				Image theImage = getDisabledImage();
				if (theImage != null)
				{
					graphics.translate(bounds.x, bounds.y);
					graphics.drawImage(theImage, getIconLocation());
					graphics.translate(-bounds.x, -bounds.y);
					return;
				}

			}
			super.paintFigure(graphics);

		}
	}

	private static Image DESC_ACTION_ACTIONBAR_PLUS_IMAGE = DiagramResourceManager
		.getInstance().getImage(DiagramResourceManager.IMAGE_POPUPBAR_PLUS);

	private static Image DESC_ACTION_ACTIONBAR_IMAGE = DiagramResourceManager
		.getInstance().getImage(DiagramResourceManager.IMAGE_POPUPBAR);
	
	/**
	 * 
	 * This is the figure that represents the ballon portion of the actionbar
	 * 
	 * @@author affrantz@@us.ibm.com
	 */
	private class RoundedRectangleWithTail extends RoundedRectangle {

		private Image myActionTailImage = null;

		private boolean bIsInit = false;

		private int myCornerDimension = 6;

		/**
		 * constructor
		 */
		public RoundedRectangleWithTail() {
			// we do not make the myActionTailFigue opaque because it
			// doesn't look good when magnification is set.
			this.setFill(true);
			this.setBackgroundColor(ColorConstants.buttonLightest);
			this.setForegroundColor(ColorConstants.lightGray);
			this.setVisible(true);
			this.setEnabled(true);
			this.setOpaque(true);

		}

		/**
		 * @@see org.eclipse.draw2d.Figure#paintFigure(org.eclipse.draw2d.Graphics)
		 */
		public void paintFigure(Graphics graphics) {
			int shiftWidth = 3;
			Image theTail = getTail();
			Rectangle theBounds = this.getBounds().getCopy();
			theBounds.height -= theTail.getBounds().height;
			theBounds.height -= shiftWidth;// shift slight above cursor
			theBounds.x += shiftWidth; // shift slight to right of cursor
			theBounds.width -= (shiftWidth + 1); // otherwise rhs is clipped

			// fill the round rectangle first since it is opaque
			graphics.fillRoundRectangle(
				theBounds,
				myCornerDimension,
				myCornerDimension);
			graphics.drawRoundRectangle(
				theBounds,
				myCornerDimension,
				myCornerDimension);

			graphics.drawImage(
				theTail,
				theBounds.x + 6,
				theBounds.y + theBounds.height - 1);

		}
		private Image getTail()
		{
			if(!bIsInit)
			{
				if(getIsDisplayAtMouseHoverLocation() && !getHostIsConnector())
				{
					if(myActionTailImage == null)
					{
						myActionTailImage = DESC_ACTION_ACTIONBAR_PLUS_IMAGE;
						bIsInit = true;
					}
				}
				else
				{
					if(myActionTailImage == null)
					{
						myActionTailImage = DESC_ACTION_ACTIONBAR_IMAGE;
						bIsInit = true;
					}
				}

			}
			return myActionTailImage;

		}

	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#isDiagramAssistant(java.lang.Object)
	 */
	protected boolean isDiagramAssistant(Object object) {
		return object instanceof RoundedRectangleWithTail
			|| object instanceof ActionBarLabelHandle;
	}

	/**
	 * Adds the connector handles after a delay
	 */
	public void mouseHover(MouseEvent me) {
			// if the cursor is inside the actionbar
			// or the keyboar triggred activation
			// then we do not want to deactivate
			if (!isDiagramAssistant(me.getSource()))
				setAvoidHidingDiagramAssistant(false);

			setMouseLocation(me.getLocation());
			if (getIsDisplayAtMouseHoverLocation())
				showDiagramAssistantAfterDelay(getAppearanceDelayLocationSpecific()); // no
																						// delay
			else if (shouldShowDiagramAssistant()) {
				showDiagramAssistant(getMouseLocation()); // no delay
			}
	}

	/**
	 * @@see org.eclipse.draw2d.MouseMotionListener#mouseMoved(org.eclipse.draw2d.MouseEvent)
	 */
	public void mouseMoved(MouseEvent me) {

		if(getIsDisplayAtMouseHoverLocation())
			{
			Object srcObj = me.getSource();
			if ((srcObj != null) && srcObj.equals(getHostFigure())) {
				hideDiagramAssistant();
			}
		}
		setAvoidHidingDiagramAssistant(true);
		setMouseLocation(me.getLocation());

		if (!getIsDisplayAtMouseHoverLocation()) {
			// if the cursor is inside the actionbar
			// or the keyboar triggred activation
			// then we do not want to deactivate
			if (!isDiagramAssistant(me.getSource()))
				setAvoidHidingDiagramAssistant(false);

			showDiagramAssistantAfterDelay(getAppearanceDelay());
		}
	}

	/**
	 * Listens to the owner figure being moved so the handles can be removed
	 * when this occurs.
	 * 
	 * @@author affrantz@@us.ibm.com
	 * 
	 */
	private class OwnerMovedListener implements FigureListener {

		private Point myActionBarLastPosition = new Point(0, 0);

		boolean hasPositionChanged(Rectangle theBounds) {
			if (theBounds.x != myActionBarLastPosition.x)
				return true;
			if (theBounds.y != myActionBarLastPosition.y)
				return true;
			return false;
		}

		/**
		 * @@see org.eclipse.draw2d.FigureListener#figureMoved(org.eclipse.draw2d.IFigure)
		 */
		public void figureMoved(IFigure source) {
			// for some reason we get more than one
			// figure moved call after compartment items are added
			// myActionMoveFigure handles the first one which we expect
			// hasPositionChanged handles the others caused by the selection of
			// the compartment
			// item.
			if (getFlag(ACTIONBAR_MOVE_FIGURE)
				&& hasPositionChanged(source.getBounds())) {
				hideDiagramAssistant(); // without delay
			} else {
				setFlag(ACTIONBAR_MOVE_FIGURE, false); // toggle flag back
				Rectangle theBounds = source.getBounds();
				myActionBarLastPosition.setLocation(theBounds.x, theBounds.y);

			}

		}
	}

	/**
	 * Listens for mouse key presses so the actionbar can be dismissed if the context 
	 * menu is displayed
	 * 
	 * @@author affrantz@@us.ibm.com
	 */
	private class ActionBarMouseListener extends MouseListener.Stub {

		/**
		 * @@see org.eclipse.draw2d.MouseListener#mousePressed(org.eclipse.draw2d.MouseEvent)
		 */
		public void mousePressed(MouseEvent me) {
			if (3 == me.button) // context menu, hide the actionbar
			{
				hideDiagramAssistant();
			}
			super.mousePressed(me);
			setActionbarOnDiagramActivated(true);
		}
		public void mouseReleased(MouseEvent me)
		{
			super.mouseReleased(me);

		}
	}

	/* ************************* End nested classes ******************** */

	/**
	 * Delay in ms to wait for displaying the actionBar on a diagrms or machine
	 * diagram. This delay is greater than normal because the actionbar is more
	 * intrusive.
	 */
	private static final int APPEARANCE_DELAY_LOCATION_SPECIFIC = 1000;

	/** Y postion offset from shape where the balloon top begin. */
	static private int BALLOON_Y_OFFSET = 10;

	/** Y postion offset from shape where the balloon top begin. */
	static private double BALLOON_X_OFFSET_RHS = 0.65;

	static private double BALLOON_X_OFFSET_LHS = 0.25;

	/** Y postion offset from shape where the balloon top begin. */
	static private int ACTION_WIDTH_HGT = 30;

	static private int ACTION_BUTTON_START_X = 5;

	static private int ACTION_BUTTON_START_Y = 5;

	static private int ACTION_MARGIN_RIGHT = 10;

	/** ActionBar bits */
	static private int ACTIONBAR_ACTIVATEONHOVER				= 0x01; /* Display the action when hovering*/
	static private int ACTIONBAR_MOVE_FIGURE			 		= 0x02; /* Ignore the first figureMoved event when creating elements inside a shape via an actionBar*/ 
	static private int ACTIONBAR_DISPLAYATMOUSEHOVERLOCATION	= 0x04; /* Display the actIOnbar at the mouse location used by diagrams and machine edit parts*/
	static private int ACTIONBAR_ONDIAGRAMACTIVATED				= 0x10; /* For actionBars on diagram and machine edit parts, where we ACTIONBAR_DISPLAYATMOUSEHOVERLOCATION, don't display actionBar until user clicks on surface*/
	static private int ACTIONBAR_HOST_IS_CONNECTOR				= 0x20; /* For actionBars on connector edit parts*/

	/** Bit field for the actrionbar associated bits */
	private int myActionBarFlags = ACTIONBAR_ACTIVATEONHOVER;

	private double myBallonOffsetPercent = BALLOON_X_OFFSET_RHS;

	/** the figure used to surround the action buttons */
	private IFigure myBalloon = null;

	/** The action bar descriptors for the action bar buttons */
	private List myActionBarDescriptors = new ArrayList();

	/** Images created that must be deleted when actionbar is removed */
	protected List imagesToBeDisposed = new ArrayList();

	/** mouse keys listener for the owner shape */
	private ActionBarMouseListener myMouseKeyListener = new ActionBarMouseListener();

	/** listener for owner shape movement */
	private OwnerMovedListener myOwnerMovedListener = new OwnerMovedListener();

	/** flag for whether mouse cursor within shape */

	private void setFlag(int bit, boolean b)
	{
		if (b)
			myActionBarFlags |= bit;
		else if (getFlag(bit))
			myActionBarFlags ^= bit;

	}

	private boolean getFlag(int bit)
	{
		return ((myActionBarFlags & bit) > 0);
	}


	
	private void setActionbarOnDiagramActivated(boolean bVal)
	{
		setFlag(ACTIONBAR_ONDIAGRAMACTIVATED, bVal);
	}
	private boolean getActionbarOnDiagramActivated()
	{
		return getFlag(ACTIONBAR_ONDIAGRAMACTIVATED);
	}

	/**
	 * set the host is connector flag
	 * @@param bVal the new value
	 */
	protected void setHostIsConnector(boolean bVal)
	{
		setFlag(ACTIONBAR_HOST_IS_CONNECTOR, bVal);
	}

	/**
	 * get the host is connector flag
	 * @@return true or false
	 */
	protected boolean getHostIsConnector()
	{
		return getFlag(ACTIONBAR_HOST_IS_CONNECTOR);
	}

	/**
	 * Populates the action bar with actionbar descriptors added by suclassing
	 * this editpolicy (i.e. <code>fillActionBarDescriptors</code> and by
	 * querying the modeling assistant service for all types supported on the
	 * actionbar of this host. For those types added by the modeling assistant
	 * service the icons are retrieved using the Icon Service.
	 */
	protected void populateActionBars() {
		fillActionDescriptors();
		List types = ModelingAssistantService.getInstance()
			.getTypesForActionBar(getHost());
		for (Iterator iter = types.iterator(); iter.hasNext();) {
			Object type = iter.next();
			if (type instanceof IElementType) {
				addActionBarDescriptor2((IElementType) type, IconService
					.getInstance().getIcon((IElementType) type));
			}
		}
	}

	/**
	 * This is the entry point that subclasses can override to fill the
	 * actionbar descrioptors if they have customized tools that cannot be done
	 * using the type along with the modeling assistant service.
	 */
	protected void fillActionDescriptors() {
		// subclasses can override.
	}

	private boolean isSelectionToolActive()
	{
		// getViewer calls getParent so check for null
		if(getHost().getParent() != null && getHost().isActive() )
		{
			Tool theTool = getHost().getViewer().getEditDomain().getActiveTool();
			if((theTool != null) && theTool instanceof SelectionTool)
			{
				return true;
			}
		}
		return false;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#shouldShowDiagramAssistant()
	 */
	protected boolean shouldShowDiagramAssistant()
	{
		if (!super.shouldShowDiagramAssistant()) {
			return false;
		}

		if(this.getIsDisplayAtMouseHoverLocation())
		{
			if (getHostIsConnector())
				return isSelectionToolActive();
			if (getActionbarOnDiagramActivated())
				return isSelectionToolActive();
			return false;
		}
		else
			return isSelectionToolActive();

	}

	/**
	 * allows plugins to add their own actionbar tools and tips
	 * @@param elementType
	 * @@param theImage
	 * @@param theTracker
	 * @@param theTip
	 */
	protected void addActionBarDescriptor(
			IElementType elementType,
			Image theImage,
			DragTracker theTracker,
			String theTip) {

		ActionBarDescriptor desc =
			new ActionBarDescriptor(theTip, theImage, elementType, theTracker);
		myActionBarDescriptors.add(desc);

	}

	/**
	 * adds action bar descriptor
	 * @@param elementType
	 * @@param theImage
	 * @@param theTracker
	 */
	protected void addActionBarDescriptor(
		IElementType elementType,
		Image theImage,
		DragTracker theTracker) {

		String theInputStr = DiagramResourceManager.getI18NString("PopupBar.AddNew"); //$NON-NLS-1$


		String theTip = MessageFormat.format(theInputStr, new Object[] {elementType.getDisplayName()});
	
		addActionBarDescriptor(elementType, theImage, theTracker, theTip);
	}

	/**
	 * default method for plugins which passes along the PopupBarTool
	 * as the tool to be used.
	 * @@param elementType
	 * @@param theImage
	 */
	protected void addActionBarDescriptor2(IElementType elementType,
			Image theImage) {

		this.addActionBarDescriptor(elementType, theImage,
			new PopupBarTool(getHost(), elementType));

	}

	/**
	 * @@param elementType
	 * @@param theImage
	 * @@param theTip
	 */
	protected void addActionBarDescriptor2(
			IElementType elementType,
			Image theImage,
			String theTip) {

		PopupBarTool theTracker =
			new PopupBarTool(getHost(), elementType);
		ActionBarDescriptor desc =
			new ActionBarDescriptor(theTip, theImage, elementType, theTracker);
		myActionBarDescriptors.add(desc);

	}

	/**
	 * method used primarily to add UnspecifiedTypeCreationTool
	 * @@param elementType
	 * @@param theImage
	 * @@param theRequest the create request to be used
	 */
	protected void addActionBarDescriptor2(
			IElementType elementType,
			Image theImage,
			CreateRequest theRequest)
	{

		PopupBarTool theTracker =
			new PopupBarTool(getHost(), theRequest);

		this.addActionBarDescriptor(elementType, theImage, theTracker);

	}

	/**
	 * default method for plugins which passes along the AddUMLActionBarTool as
	 * the tool to be used.
	 * @@param elementType
	 * @@param theImage
	 * @@deprecated Use <code>addActionBarDescriptor2</code> instead. All your
	 *             actionbar scenarios should be tested when migrating to
	 *             <code>addActionBarDescriptor2</code>. The difference
	 *             between the two is that <code>AddUMLActionBarTool</code>
	 *             has been removed and <code>PopupBarTool</code> is now
	 *             used always. <code>AddUMLActionBarTool</code> used a
	 *             request to create an element only, whereas
	 *             <code>PopupBarTool</code> uses a request to create an
	 *             element and view and if that does not return a command, then
	 *             it tries a request to create an element only. Alternatively,
	 *             you could migrate to use the Modeling Assistant Service to
	 *             handle the actionbar types instead of overriding this
	 *             editpolicy. Contact Cherie for assistance.
	 */
	protected void addActionBarDescriptor(
		IElementType elementType,
			Image theImage) {

		DragTracker theTracker;
		if (elementType instanceof INotationType) {
			theTracker = new PopupBarTool(getHost(), elementType);
		}
		else{
			theTracker = new AddUMLActionBarTool(getHost(), elementType);
		}
		this.addActionBarDescriptor(elementType, theImage, theTracker);

	}

	/**
	 * @@param elementType
	 * @@param theImage
	 * @@param theTip
	 * @@deprecated Use <code>addActionBarDescriptor2</code> instead. All your
	 *             actionbar scenarios should be tested when migrating to
	 *             <code>addActionBarDescriptor2</code>. The difference
	 *             between the two is that <code>AddUMLActionBarTool</code>
	 *             has been removed and <code>PopupBarTool</code> is now
	 *             used always. <code>AddUMLActionBarTool</code> used a
	 *             request to create an element only, whereas
	 *             <code>PopupBarTool</code> uses a request to create an
	 *             element and view and if that does not return a command, then
	 *             it tries a request to create an element only. Contact Cherie
	 *             for assistance.
	 */
	protected void addActionBarDescriptor(
			IElementType elementType,
			Image theImage,
			String theTip) {

		AddUMLActionBarTool theTracker =
			new AddUMLActionBarTool(getHost(), elementType);
		ActionBarDescriptor desc =
			new ActionBarDescriptor(theTip, theImage, elementType, theTracker);
		myActionBarDescriptors.add(desc);

	}

	/**
	 * method used primarily to add UnspecifiedTypeCreationTool
	 * @@param elementType
	 * @@param theImage
	 * @@param theTool
	 * @@deprecated Use <code>addActionBarDescriptor2</code> instead. All your
	 *             actionbar scenarios should be tested when migrating to
	 *             <code>addActionBarDescriptor2</code>. The difference
	 *             between the two is that <code>AddUMLActionBarTool</code>
	 *             has been removed and <code>PopupBarTool</code> is now
	 *             used always. <code>AddUMLActionBarTool</code> used a
	 *             request to create an element only, whereas
	 *             <code>PopupBarTool</code> uses a request to create an
	 *             element and view and if that does not return a command, then
	 *             it tries a request to create an element only. Contact Cherie
	 *             for assistance.
	 */
	protected void addActionBarDescriptor(
			IElementType elementType,
			Image theImage,
			CreateRequest theRequest)
	{

		AddUMLActionBarTool theTracker =
			new AddUMLActionBarTool(getHost(), theRequest);

		this.addActionBarDescriptor(elementType, theImage, theTracker);

	}

	/**
	 * gets the action bar descriptors
	 * @@return list
	 */
	protected List getActionBarDescriptors() {
		return myActionBarDescriptors;
	}

	/**
	 * initialize the action bars from the list of action descriptors.
	 */
	private void initActionBars() {

		List theList = getActionBarDescriptors();
		if (theList.isEmpty()) {
			return;
		}
		myBalloon = createActionBarFigure();

		int iTotal = ACTION_WIDTH_HGT * theList.size() + ACTION_MARGIN_RIGHT;

		getBalloon().setSize(
			iTotal,
			ACTION_WIDTH_HGT + 2 * ACTION_BUTTON_START_Y);

		int xLoc = ACTION_BUTTON_START_X;
		int yLoc = ACTION_BUTTON_START_Y;

		for (Iterator iter = theList.iterator(); iter.hasNext();) {
			ActionBarDescriptor theDesc = (ActionBarDescriptor) iter.next();

			// Button b = new Button(theDesc.myButtonIcon);
			ActionBarLabelHandle b =
				new ActionBarLabelHandle(
					theDesc.getDragTracker(),
					theDesc.getIcon());

			Rectangle r1 = new Rectangle();
			r1.setLocation(xLoc, yLoc);
			xLoc += ACTION_WIDTH_HGT;
			r1.setSize(
				ACTION_WIDTH_HGT,
				ACTION_WIDTH_HGT - ACTION_MARGIN_RIGHT);

			Label l = new Label();
			l.setText(theDesc.getToolTip());

			b.setToolTip(l);
			b.setPreferredSize(ACTION_WIDTH_HGT, ACTION_WIDTH_HGT);
			b.setBounds(r1);

			getBalloon().add(b);

			b.addMouseMotionListener(this);
			b.addMouseListener(this.myMouseKeyListener);

		}
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#getPreferenceName()
	 */
	String getPreferenceName() {
		return IPreferenceConstants.PREF_SHOW_POPUP_BARS;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#isDiagramAssistantShowing()
	 */
	protected boolean isDiagramAssistantShowing() {
		return getBalloon() != null;
	}

	private IFigure getBalloon() {
		return myBalloon;
	}

	protected IFigure createActionBarFigure() {
		return new RoundedRectangleWithTail();
	}

	protected void showDiagramAssistant(Point referencePoint) {

		// already have a one
		if (getBalloon() != null && getBalloon().getParent() != null) 
		{
			return;
		}

		if (this.myActionBarDescriptors.isEmpty()) 
		{

			populateActionBars();
			initActionBars();

			if (myActionBarDescriptors.isEmpty()) {
				return; // nothing to show
			}
		}
		getBalloon().addMouseMotionListener(this);
		getBalloon().addMouseListener(myMouseKeyListener);

		// the feedback layer figures do not recieve mouse events so do not use
		// it for actionbars
		IFigure layer = getLayer(LayerConstants.HANDLE_LAYER);
		layer.add(getBalloon());
		
		if (referencePoint == null) {
			referencePoint = getHostFigure().getBounds().getCenter();
		}

		Point thePoint = getBalloonPosition(referencePoint);

		getBalloon().setLocation(thePoint);

		// dismiss the actionBar after a delay
		if(!shouldAvoidHidingDiagramAssistant())
		{
			hideDiagramAssistantAfterDelay(getDisappearanceDelay());
		}
	}

	/**
	 * getter for the IsDisplayAtMouseHoverLocation flag
	 * @@return true or false
	 */
	protected boolean getIsDisplayAtMouseHoverLocation()
	{
		return getFlag(ACTIONBAR_DISPLAYATMOUSEHOVERLOCATION);
	}

	/**
	 * setter for the IsDisplayAtMouseHoverLocation
	 * @@param bVal
	 */
	protected void setIsDisplayAtMouseHoverLocation(boolean bVal)
	{
		setFlag(ACTIONBAR_DISPLAYATMOUSEHOVERLOCATION, bVal);
	}

	/**
	 * For editparts that consume the entire viewport, statechart, structure,
	 * communication, we want to display the actionbar at the mouse location.
	 * @@param referencePoint
	 *            The reference point which may be used to determine where the
	 *            diagram assistant should be located. This is most likely the
	 *            current mouse location. 
	 *            @@return Point
	 */
	private Point getBalloonPosition(Point referencePoint)
	{
		Point thePoint = new Point();
		boolean atMouse = getIsDisplayAtMouseHoverLocation();
		if (atMouse) {
			thePoint.setLocation(referencePoint);
			getHostFigure().translateToAbsolute(thePoint);
			getBalloon().translateToRelative(thePoint);

			// shift the ballon so it is above the cursor.
			thePoint.y -= ACTION_WIDTH_HGT;

			if (willBalloonBeClipped(thePoint)) {
				Rectangle rcBounds = getHostFigure().getBounds().getCopy();
				getHostFigure().translateToAbsolute(rcBounds);
				getBalloon().translateToRelative(rcBounds);
				Dimension dim = getBalloon().getSize();
				int offsetX = dim.width + ACTION_WIDTH_HGT;
				thePoint.x = rcBounds.right() - offsetX;
			}

		}
		else
		{
			Dimension theoffset = new Dimension();
			Rectangle rcBounds = getHostFigure().getBounds().getCopy();

			getHostFigure().translateToAbsolute(rcBounds);
			getBalloon().translateToRelative(rcBounds);

			theoffset.height = -(BALLOON_Y_OFFSET + ACTION_WIDTH_HGT);
			theoffset.width = (int) (rcBounds.width * myBallonOffsetPercent);

			thePoint.x = rcBounds.x + theoffset.width;
			thePoint.y = rcBounds.y + theoffset.height;
			if (isRightDisplay() && willBalloonBeClipped(thePoint)) {
				this.setLeftHandDisplay();
				theoffset.width = (int) (rcBounds.width * myBallonOffsetPercent);
				thePoint.x = rcBounds.x + theoffset.width;

			}
		}
		return thePoint;
	}

	private boolean willBalloonBeClipped(Point pnt) {
		Control ctrl1 = getHost().getViewer().getControl();
		if (ctrl1 instanceof FigureCanvas) {
			FigureCanvas figureCanvas = (FigureCanvas) ctrl1;
			Viewport vp = figureCanvas.getViewport();
			Rectangle vpRect = vp.getClientArea();
			Dimension dim = getBalloon().getSize();
			if ((pnt.x + dim.width) >= (vpRect.x + vpRect.width)) {
				return true;
			}
		}
		return false;
	}

	private void teardownActionBar() {
		getBalloon().removeMouseMotionListener(this);
		getBalloon().removeMouseListener(myMouseKeyListener);
		// the feedback layer figures do not recieve mouse events
		IFigure layer = getLayer(LayerConstants.HANDLE_LAYER);
		if (myBalloon.getParent() != null) {
			layer.remove(myBalloon);
		}
		myBalloon = null;

		this.myActionBarDescriptors.clear();
		setRightHandDisplay(); // set back to default

		for (Iterator iter = imagesToBeDisposed.iterator(); iter.hasNext();) {
			((Image) iter.next()).dispose();
		}
		imagesToBeDisposed.clear();

	}

	protected void hideDiagramAssistant() {
		if (getBalloon() != null) {

			teardownActionBar();
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#showDiagramAssistantAfterDelay(int)
	 */
	protected void showDiagramAssistantAfterDelay(int theDelay) {
		// only show the actionbar if it isn't already showing
		if (!isDiagramAssistantShowing()) {
			super.showDiagramAssistantAfterDelay(theDelay);
		}
	}

	/**
	 * 
	 * @@see org.eclipse.gef.EditPolicy#activate()
	 */
	public void activate() {
		super.activate();

		getHostFigure().addMouseListener(this.myMouseKeyListener);
		getHostFigure().addFigureListener(this.myOwnerMovedListener);

		if (getHost() instanceof ISurfaceEditPart) {
			setIsDisplayAtMouseHoverLocation(true);
		}
	}

	/**
	 * 
	 * @@see org.eclipse.gef.EditPolicy#deactivate()
	 */
	public void deactivate() {
		getHostFigure().removeMouseListener(this.myMouseKeyListener);
		getHostFigure().removeFigureListener(this.myOwnerMovedListener);

		super.deactivate();

	}

	/**
	 * This is the default which places the actionbar to favor the right side
	 * of the shape
	 * 
	 */
	protected void setRightHandDisplay() {
		this.myBallonOffsetPercent = BALLOON_X_OFFSET_RHS;
	}

	/**
	 * Place the actionbar to favor the left had side of the shape
	 * 
	 */
	protected void setLeftHandDisplay() {
		this.myBallonOffsetPercent = BALLOON_X_OFFSET_LHS;
	}

	/**
	 * check thee right display status
	 * @@return true or false
	 */
	protected boolean isRightDisplay() {
		return (BALLOON_X_OFFSET_RHS == myBallonOffsetPercent);
	}

	/**
	 * Gets the amount of time to wait before showing the actionbar if the
	 * actionbar is to be shown at the mouse location
	 * {@@link #getIsDisplayAtMouseHoverLocation()}.
	 * 
	 * @@return the time to wait in milliseconds
	 */
	protected int getAppearanceDelayLocationSpecific() {
		return APPEARANCE_DELAY_LOCATION_SPECIFIC;
	}
	
	/**
	 * @@deprecated Use {@@link DiagramAssistantEditPolicy#setMouseLocation(Point)}
	 */
	protected void setMouseMoveLocation(Point thePoint)
	{
		setMouseLocation(thePoint);
	}
	
	/**
	 * @@deprecated Use {@@link DiagramAssistantEditPolicy#getMouseLocation()
	 */
	protected Point getMouseMoveLocation()
	{
		return getMouseLocation();
	}
		
	/**
	 * @@deprecated Use {@@link DiagramAssistantEditPolicy#getMouseLocation()
	 */
	protected Point getMyMouseHoverLocation() {
		return getMouseLocation();
	}
	
	/**
	 * @@deprecated Use {@@link DiagramAssistantEditPolicy#setMouseLocation(Point)}
	 */
	protected void setMyMouseHoverLocation(Point theMouseHoverLocation) {
		setMouseLocation(theMouseHoverLocation);
	}

}
@


1.6
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@@


1.5
log
@Bugzilla 112521 gmf_head sshaw 051013 Diagram Assistants should not appear if editor is not active
Contributed by: Cherie Mahoney
@
text
@d41 2
a42 4
import org.eclipse.gmf.runtime.diagram.ui.internal.tools.AbstractAddActionBarTool;
import org.eclipse.gmf.runtime.diagram.ui.l10n.Images;
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
import org.eclipse.gmf.runtime.diagram.ui.tools.AddActionBarTool;
d44 1
d58 1
d254 1
a254 1
				// future: when other tools besides AddActionBarTool are
d269 1
a269 1
			if((myDragTracker != null) && (myDragTracker instanceof AbstractAddActionBarTool))
d271 1
a271 1
				AbstractAddActionBarTool abarTool = (AbstractAddActionBarTool) myDragTracker;
d298 6
a303 2
	private static Image DESC_ACTION_ACTIONBAR_PLUS_IMAGE = Images.DESC_ACTION_ACTIONBAR_PLUS.createImage();
	private static Image DESC_ACTION_ACTIONBAR_IMAGE = Images.DESC_ACTION_ACTIONBAR.createImage();
d703 1
a703 1
		String theInputStr = PresentationResourceManager.getI18NString("ActionBar.AddNew"); //$NON-NLS-1$
d712 1
a712 1
	 * default method for plugins which passes along the AddActionBarTool
d721 1
a721 1
			new AddActionBarTool(getHost(), elementType));
d735 2
a736 2
		AddActionBarTool theTracker =
			new AddActionBarTool(getHost(), elementType);
d755 2
a756 2
		AddActionBarTool theTracker =
			new AddActionBarTool(getHost(), theRequest);
d771 1
a771 1
	 *             has been removed and <code>AddActionBarTool</code> is now
d774 1
a774 1
	 *             <code>AddActionBarTool</code> uses a request to create an
d787 1
a787 1
			theTracker = new AddActionBarTool(getHost(), elementType);
d804 1
a804 1
	 *             has been removed and <code>AddActionBarTool</code> is now
d807 1
a807 1
	 *             <code>AddActionBarTool</code> uses a request to create an
d834 1
a834 1
	 *             has been removed and <code>AddActionBarTool</code> is now
d837 1
a837 1
	 *             <code>AddActionBarTool</code> uses a request to create an
d918 1
a918 1
		return IPreferenceConstants.PREF_SHOW_ACTION_BARS;
@


1.4
log
@bugzilla 111952 gmf_head sshaw 051007 Connector handles do not appear when hovering over compartments
Contributed by: Cherie Mahoney
@
text
@a39 2
import org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
a48 1
import org.eclipse.jface.preference.IPreferenceStore;
a54 1
 * 
d56 1
a56 7
 * during mouse hover over a shape. The current thinking is to start this by
 * including the Add UML commands for the appropirate shape. The idea for this
 * came from the bpel editor and we are drawing the balloon the same as the
 * bpel editor. Addtional usages for actionbar's (besides add uml)
 * Shapes/Connectors Format Commands Shapes/Connectors Appearance Commands
 * Shapes/Connectors User defined would be nice Diagram Add UML (essentially
 * the current toolbox)
a59 1

d407 1
a407 1
			else
d409 1
d417 1
a417 1
			if(getIsDisplayAtMouseHoverLocation() && shouldDisplayActionBar())
d427 1
a427 1
		if (!getIsDisplayAtMouseHoverLocation() && shouldDisplayActionBar()) {
d646 3
a648 2
	/** Never display actionbars when there is an active tool on the pallette
	 * 
d650 1
a650 1
	private boolean shouldDisplayActionBar()
d652 2
a653 5
		//RATLC00532515: ActionBars shouldn't be shown if the host edit part isn't editable.
		if (getHost() instanceof GraphicalEditPart) {
			if (!((GraphicalEditPart) getHost()).isEditModeEnabled()) {
				return false;
			}
d655 1
d910 2
a911 4
	/**
	 * Is the Action bar preference turned on?
	 * 
	 * @@return true iff the show action bar preference is turned on
d913 2
a914 6
	private boolean isPreferenceOn() {
		IPreferenceStore preferenceStore = (IPreferenceStore)
			((IGraphicalEditPart) getHost())
			.getDiagramPreferencesHint().getPreferenceStore();
		return preferenceStore.getBoolean(
			IPreferenceConstants.PREF_SHOW_ACTION_BARS);
a934 2
		if (!shouldDisplayActionBar() || !isPreferenceOn())
			return;
@


1.3
log
@Bugzilla 110480 gmf_head sshaw 050923 Modeling Assistant Service should have generic getTypes() operation to be used in commands with popups
Contributed by Cherie Mahoney
@
text
@a26 1
import org.eclipse.draw2d.MouseMotionListener;
a32 2
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartListener;
d72 2
a73 2
	
	/* ************************** nested classes ************************/
d75 1
a75 1
	 *
d78 1
a78 1
	 * @@author affrantz@@us.ibm.com 
d81 1
d106 4
a109 4
				_tooltip = s;
				_icon = i;
				_dragTracker = theTracker;
				_elementType = elementType;
d111 1
a111 1
			}
d114 1
a114 1
		 * gets the element type associated with this Descriptor 
d120 1
a120 1
		
d122 1
a122 1
		 * gets the icon associated with this Descriptor 
d128 1
a128 1
		
d130 1
a130 1
		 * gets the drag tracker associated with this Descriptor 
d136 1
a136 1
		
d138 1
a138 1
		 * gets the tool tip associated with this Descriptor 
d140 1
a140 1
		 */		
d146 1
a146 1
	
d150 1
a150 1
	 * @@author affrantz@@us.ibm.com 
d163 1
a163 1
		
d172 1
a172 1
				
d189 1
a189 1
		
d213 1
a213 1
				
d217 1
a217 1
			
d223 1
a223 1
				
d254 1
a254 1
		 *  
a273 1
		
d275 1
a275 1
		 * checks if tool tip is enabled or not 
d287 1
a287 3
		
		
		
d301 1
a301 1
				}				
d312 1
a312 1
	 *
d318 1
a318 1
		
d320 3
a322 1
		private boolean bIsInit=false;
d339 1
d347 1
a347 1
			theBounds.height -= theTail.getBounds().height ;
d349 2
a350 3
			theBounds.x 	+= shiftWidth; // shift slight to right of cursor
			theBounds.width -= (shiftWidth+1); // otherwise rhs is clipped
			
d377 1
a377 1
						bIsInit=true;
d385 1
a385 1
						bIsInit=true;
d388 1
a388 1
				
d391 1
a391 1
		
d395 9
a403 1
	
d405 1
a405 4
	 * Listens to mouse events on the owner shape and handles so that the
	 * action bar balloon can be added or removed.
	 * 
	 * @@author affrantz@@us.ibm.com
d407 6
a412 1
	private class ActionBarMouseMotionListener extends MouseMotionListener.Stub {
d414 12
a425 5
		public void mouseEntered(MouseEvent me) {
			// Avoid handles from being removed if the mouse has moved back
			// inside the shape when the handles were already being displayed.
			setMouseInsideShape(true);
		}
d427 1
a427 25
		public void mouseExited(MouseEvent me) {
			setMouseInsideShape(false);
			hideActionBalloonDelayed(getDisappearanceDelayUponExit());
		}
		/**
		 * We the tools to dismiss after the delay period if 
		 * the mouse is inside the shape, but we do not want the tools to 
		 * dismiss if the mouse is inside the one of the tools.
		 * 
		 */
		private boolean shouldHoverActivate(Object theObj)
		{
			if(theObj instanceof RoundedRectangleWithTail)
				return true;
			if(theObj instanceof ActionBarLabelHandle)
				return true;
			
			
			return false;
		}
		/**
		 * Adds the connector handles after a delay
		 */
		public void mouseHover(MouseEvent me) {
			if(getActivateOnHover())
d429 3
a431 11
				// if the cursor is inside the actionbar
				// or the keyboar triggred activation 
				// then we do not want to deactivate
				if(!shouldHoverActivate(me.getSource()))
					setActivateOnHover(false);
				
				myMouseHoverLocation.setLocation(me.getLocation());
				if(getIsDisplayAtMouseHoverLocation())
					showActionBalloonDelayed(getAppearanceDelayLocationSpecific()); // no delay
				else
					showActionBalloon(); // no delay
a432 2
				
			
d434 9
a442 26
		/**
		 * @@see org.eclipse.draw2d.MouseMotionListener#mouseMoved(org.eclipse.draw2d.MouseEvent)
		 */
		public void mouseMoved(MouseEvent me) {
			
			if(getIsDisplayAtMouseHoverLocation() && shouldDisplayActionBar())
			{
				Object srcObj = me.getSource(); 
				if((srcObj!=null)&& srcObj.equals(getHostFigure()))
				{	
					hideActionBalloon();
				}
			}
			setActivateOnHover(true);
			setMouseMoveLocation(me.getLocation());
			setMyMouseHoverLocation(me.getLocation());
			
			if(!getIsDisplayAtMouseHoverLocation() && shouldDisplayActionBar()) {
				// if the cursor is inside the actionbar
				// or the keyboar triggred activation 
				// then we do not want to deactivate
				if(!shouldHoverActivate(me.getSource()))
					setActivateOnHover(false);
				
				showActionBalloonDelayed(getAppearanceDelay());
			}
d444 1
a444 1
			super.mouseMoved(me);
d446 1
a447 1
	}
d453 1
a453 1
	 *  
d466 1
d479 1
a479 1
				hideActionBalloon(); // without delay
a490 22
	 * Listens to the focus events on the owner editpart so that the handles
	 * can be added when the space bar is pressed. I tried to use
	 * IFigure.addFocusListener(), but the figure isn't getting any focus
	 * change events when the space bar is pressed.
	 * 
	 * @@author affrantz@@us.ibm.com 
	 */
	private class EditPartFocusListener extends EditPartListener.Stub {
		/**
		 * @@see org.eclipse.gef.EditPartListener#selectedStateChanged(org.eclipse.gef.EditPart)
		 */
		public void selectedStateChanged(EditPart part) {
	
			if (part.hasFocus() && isMouseInsideShape()) {
				showActionBalloon();
			} else {
				hideActionBalloon();
			}
		}
	}
	/**
	 *
d494 1
a494 1
	 * @@author affrantz@@us.ibm.com 
d497 1
a497 1
		
d500 1
a500 1
		*/
d502 1
a502 1
			if(3 == me.button) // context menu, hide the actionbar
d504 1
a504 1
				hideActionBalloon();
d512 1
a512 1
			
d514 3
a516 2
}
	/* ************************* End nested classes *********************/
d530 1
d535 1
d537 1
d539 1
a545 1
	static private int ACTIONBAR_MOUSEINSIDE_SHAPE 				= 0x08; /* is the Mouse inside the bounds of the shape */
d548 1
a548 1
	
d550 2
a551 2
	private int myActionBarFlags 								= ACTIONBAR_ACTIVATEONHOVER;
	
a556 2
	private Point myMouseHoverLocation = new Point();
	
d562 2
a563 5
	
	/** mouse motion listener for the owner shape and handles */
	private ActionBarMouseMotionListener myMouseListener = new ActionBarMouseMotionListener();
	
	/** mouse keys listener for the owner shape*/
d569 1
a569 2
	/** listener for focus change on editpart */
	private EditPartFocusListener myFocusListener = new EditPartFocusListener();
a570 4
	private Point myMouseMoveLocation = new Point();
	
	/** flag for whether mouse cursor within shape */
	
d573 1
a573 1
		if(b)
d575 1
a575 1
		else if(getFlag(bit))
d595 1
a595 10
	// Member functions
	private void setActivateOnHover(boolean bVal)
	{
		setFlag(ACTIONBAR_ACTIVATEONHOVER, bVal);
	}
	private boolean getActivateOnHover()
	{
		return getFlag(ACTIONBAR_ACTIVATEONHOVER);
	}
	
d597 1
a597 1
	 * set the host is connector flag 
d604 1
a604 1
	
d606 1
a606 1
	 * get the host is connector flag 
d613 1
a613 1
	
d642 1
a642 1
	
d654 1
a654 1
		return false;		
d658 1
a658 1
	 */ 
d663 1
a663 1
			if (!((GraphicalEditPart)getHost()).isEditModeEnabled()) {
d669 3
a671 1
			if(getHostIsConnector())
d673 1
a673 3
			 if(getActionbarOnDiagramActivated())
			 	return isSelectionToolActive();
			 return false;
d679 1
a679 1
	
d711 2
a712 2
		
		
a717 1
	
d731 1
a731 1
	
d749 1
a749 1
	
d764 1
a764 1
		
d766 1
a766 1
	
d768 1
a768 1
	
d790 2
a791 2
		Image theImage) {	
		
d793 1
a793 1
		if (elementType instanceof INotationType){
d800 1
a800 1
		
d802 1
a802 1
	
d831 1
d836 1
a836 1
	 * @@param theTool 
d857 1
a857 1
		
d859 1
a859 1
	
d869 1
d881 1
a881 1
	    int iTotal = ACTION_WIDTH_HGT * theList.size() + ACTION_MARGIN_RIGHT;
d898 1
a898 1
			
d915 1
a915 1
			b.addMouseMotionListener(this.myMouseListener);
a920 46


	/** the <code>Runnable</code> used for the remove handles delay timer */
	private Runnable hideBalloonRunnable = new Runnable() {
		public void run() {
			if (!isMouseInsideShape() || !getActivateOnHover()) {
				hideActionBalloon();
			}
		}
	};
	
	/** the <code>Runnable</code> class used for the show balloon delay timer */
	private class ShowBalloonRunnable
		implements Runnable {

		/** the mouse location when the timer was started */
		private Point originalMouseLocation;

		/**
		 * @@param originalMouseLocation
		 */
		protected ShowBalloonRunnable(Point originalMouseLocation) {
			this.originalMouseLocation = originalMouseLocation;
		}

		/**
		 * The connector handles are added when this task is run, assuming the
		 * mouse is still at the same spot where it was when the timer was
		 * started (i.e. only add the connector handles when the user stops
		 * moving the mouse).
		 */
		public void run() {
			if (isMouseInsideShape()
				&& originalMouseLocation.equals(getMouseMoveLocation())) {
				showActionBalloon();
			}
		}
	}
	
	private void setMouseInsideShape(boolean bVal) {
		this.setFlag(ACTIONBAR_MOUSEINSIDE_SHAPE, bVal);
	}
	private boolean isMouseInsideShape() {
		return getFlag(ACTIONBAR_MOUSEINSIDE_SHAPE);
	}
	
d929 1
a929 1
				.getDiagramPreferencesHint().getPreferenceStore();
d933 10
d946 1
d950 3
a952 2
	private void showActionBalloon() {
		if(!shouldDisplayActionBar()  || !isPreferenceOn())
d954 2
a955 2
		
		// already have a one 
d958 1
a958 1
			return ;
d960 1
a960 1
		
d963 1
a963 1
			
d971 1
a971 1
		getBalloon().addMouseMotionListener(myMouseListener);
a972 1
		
d978 6
a983 2
				
		Point thePoint = getBalloonPosition();
d986 1
a986 1
		
d988 1
a988 1
		if(!getActivateOnHover())
d990 1
a990 1
			hideActionBalloonDelayed(getDisappearanceDelay());
d992 2
a993 2
	}	
	
d1002 1
d1005 1
a1005 1
	 * @@param bVal 
d1011 11
a1021 7
	
	/** 
	 * For editparts that consume the entire viewport, statechart, structure, communication,
	 * we want to display the actionbar at the mouse location.  
	 * @@return Point
	 */ 
	private Point getBalloonPosition()
d1025 2
a1026 3
		if(atMouse)
		{	
			thePoint.setLocation(myMouseHoverLocation);
d1029 4
a1032 4
			
			//	shift the ballon so it is above the cursor.
			thePoint.y -= ACTION_WIDTH_HGT;  
			
d1038 1
a1038 1
				int offsetX = dim.width + ACTION_WIDTH_HGT; 
d1041 1
a1041 1
						
d1047 1
a1047 1
	
d1051 1
a1051 1
			theoffset.height = - (BALLOON_Y_OFFSET + ACTION_WIDTH_HGT);
d1061 1
a1061 1
			}			
d1065 1
d1079 1
d1081 1
a1081 1
		getBalloon().removeMouseMotionListener(myMouseListener);
d1092 1
a1092 1
		
d1099 2
a1100 1
	private void hideActionBalloon() {
d1107 5
a1111 4
	
	/**
	 * Sets a timer to show the actionbar
	 *  
d1113 4
a1116 13
	private void showActionBalloonDelayed(int theDelay) {
		if (getBalloon() == null) {
			Display.getCurrent().timerExec(theDelay,
				new ShowBalloonRunnable(getMouseMoveLocation()));
		}
	}	
	
	/**
	 * Sets a timer to remove the actionbar if currently shown.
	 */	
	private void hideActionBalloonDelayed(int theDelay) {
		if (getBalloon() != null) {
			Display.getCurrent().timerExec(theDelay, hideBalloonRunnable);
a1126 1
		getHostFigure().addMouseMotionListener(this.myMouseListener);
a1129 3
		((IGraphicalEditPart) getHost()).addEditPartListener(
			this.myFocusListener);
		
a1139 1
		getHostFigure().removeMouseMotionListener(this.myMouseListener);
a1141 4
		
		((IGraphicalEditPart) getHost()).removeEditPartListener(
			this.myFocusListener);
		hideActionBalloon();
d1146 1
d1150 1
a1150 1
	 *  
d1155 1
d1158 1
a1158 1
	 *  
d1163 1
d1165 1
a1165 1
	 * check thee right display status 
d1171 11
d1184 1
a1184 2
	 * sets the mouse move location
	 * @@param thePoint
d1188 1
a1188 1
		this.myMouseMoveLocation = thePoint;
d1192 1
a1192 2
	 * gets the mouse move location
	 * @@return point
d1196 1
a1196 1
		return this.myMouseMoveLocation;
d1200 1
a1200 1
	 * @@return Returns the myMouseHoverLocation.
d1203 1
a1203 1
		return myMouseHoverLocation;
d1205 1
d1207 1
a1207 1
	 * @@param theMouseHoverLocation The myMouseHoverLocation to set.
d1210 1
a1210 1
		this.myMouseHoverLocation.setLocation( theMouseHoverLocation.x, theMouseHoverLocation.y);
a1212 10
	/**
	 * Gets the amount of time to wait before showing the actionbar if the
	 * actionbar is to be shown at the mouse location
	 * {@@link #getIsDisplayAtMouseHoverLocation()}.
	 * 
	 * @@return the time to wait in milliseconds
	 */
	protected int getAppearanceDelayLocationSpecific() {
		return APPEARANCE_DELAY_LOCATION_SPECIFIC;
	}
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a38 1
import org.eclipse.gef.editpolicies.GraphicalEditPolicy;
a40 6
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Display;

d52 1
d54 5
a58 1
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
d71 1
a71 1
 * @@author affrantz@@us.ibm.com
d74 1
a74 1
public class ActionBarEditPolicy extends GraphicalEditPolicy {
d415 1
a415 1
			hideActionBalloonDelayed(HIDE_DELAY);
d447 1
a447 1
					showActionBalloonDelayed(SHOW_DELAY_LOCATION_SPECIFIC); // no delay
d478 1
a478 1
				showActionBalloonDelayed(DEFAULT_SHOW_DELAY);
a574 8
	/** Delay in ms to wait after leaving shape editpart. */
	static private int HIDE_DELAY = 1000;
	
	/**
	 * Delay in ms to wait before showing the actionbar upon entering the shape.
	 */
	private static final int DEFAULT_SHOW_DELAY = 200;

d577 2
a578 1
	 * diagram. There is no delay when displaying for a typcail shape.
d580 1
a580 6
	static private int SHOW_DELAY_LOCATION_SPECIFIC = 1000;
	
	/** Only keep the action bar visible for this length of time.
	 * 
	*/
	static private int STAY_VISIBLE_DELAY = 2000;
d609 1
a609 1
	private RoundedRectangleWithTail myBalloon = null;
d951 1
a951 1
		createBalloon();
d1051 1
a1051 1
	private RoundedRectangleWithTail getBalloon() {
d1054 2
a1055 2
	private void createBalloon() {
		myBalloon = new RoundedRectangleWithTail();
d1090 1
a1090 1
		// dismiss the actionBar after STAY_VISIBLE_DELAY ms.
d1093 1
a1093 1
			hideActionBalloonDelayed(STAY_VISIBLE_DELAY);
d1313 10
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2003, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

