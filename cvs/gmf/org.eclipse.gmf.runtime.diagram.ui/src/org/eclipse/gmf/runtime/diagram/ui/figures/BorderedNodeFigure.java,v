head	1.7;
access;
symbols
	v20081023-2107:1.6.4.1
	v20081022-1925:1.7
	v20081022-1005:1.6.4.1
	v20081020-0700:1.6
	v20080917-1925:1.6
	v20080916-2008:1.6
	v20080911-1728:1.6
	v20080911-1506:1.6
	v20080910-1520:1.6
	v20080910-1510:1.6
	v20080903-1520:1.6
	v20080903-1510:1.6
	v20080813-1510:1.6
	v20080811-1546:1.6
	v20080731-1520:1.6
	v20080725-1738:1.6
	v20080723-2246:1.6
	v20080723-2232:1.6
	v20080723-1700:1.6
	v20080722-1827:1.6
	v20080718-1700:1.6
	v20080718-1731:1.6
	v20080716-1600:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.6.0.4
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080610-1132:1.6
	v20080603-1553:1.6
	v20080527-1255:1.6
	v20080527-1151:1.6
	v20080516-1748:1.6
	v20080516-1143:1.6
	v20080512-1200:1.6
	v20080503-1740:1.6
	v20080501-2127:1.6
	v20080501-1739:1.6
	m20080429-1543:1.6
	v20080425-1959:1.6
	v20080417-1610:1.6
	v20080407-2250:1.6
	v20080407-0930:1.6
	v20080404-1111:1.6
	v20080328-1605:1.6
	v20080322-0000:1.6
	v20080222-1200:1.6
	v20080201-2010:1.6
	v20080201-0201:1.6
	v20080118-1129:1.6
	v20080114-2222:1.6
	v20080114-1111:1.6
	v20080107-1111:1.6
	v20071222-1111:1.6
	v20071214-1111:1.6
	v20071130-1111:1.6
	v20071124-0000:1.6
	v20071112-0000:1.6
	v20071108-0000:1.6
	v20071003-0000:1.6
	v20070915-0000:1.6
	v20070903-0000:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	v20070621-0000:1.6
	RC3_20:1.5
	v20070614-1400:1.5
	v20070608-1300:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070525-1500:1.5
	v20070518-1300:1.5
	bugzilla111892_group_support:1.5.0.2
	Root_bugzilla111892_group_support:1.5
	v20070504-1000:1.5
	v20070420-1000:1.5
	v20070413-1300:1.5
	v20070330-1300:1.5
	v20060330-1300:1.5
	v20070322-1100:1.5
	v20060316-0600:1.5
	v20070221-1500:1.5
	v20070208-1800:1.5
	v20070202-0200:1.2.2.2
	v20070119-1200:1.2.2.2
	v20070111-0800:1.2.2.2
	v20070105-1200:1.2.2.2
	v20070103-0300:1.4
	M4_20:1.4
	v20061218-1500:1.2.2.2
	v20061218-1200:1.4
	v20061214-0000:1.4
	M3_20:1.3
	v20061117-0800:1.3
	v20061027-1200:1.2.2.1
	v20061013-1330:1.3
	v20061012-1100:1.2.2.1
	v20060925-1700:1.2
	v20060919-0800:1.2
	v20060907-1100:1.2
	M1_20:1.2
	v20060831-1500:1.2
	v20060824-1600:1.2
	v20060817-1500:1.2
	v20060810-1700:1.2
	v20060803-1200:1.2
	v20060728-0500:1.2
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1400:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060530-1930:1.2
	v20060526-1200:1.2
	v20060519-0800:1.2
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060202-1415:1.2
	I20060129-1145:1.2
	I20060127-0900:1.1
	I20060120-1530:1.1
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1
	I20060105-1630:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.7
date	2008.10.22.13.53.21;	author aboyko;	state Exp;
branches;
next	1.6;
commitid	1136848ff30514567;

1.6
date	2007.06.18.19.10.09;	author ahunter;	state Exp;
branches
	1.6.4.1;
next	1.5;
commitid	7c604676d8904567;

1.5
date	2007.01.08.22.27.35;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	438245a2c5564567;

1.4
date	2006.11.23.21.11.33;	author mmostafa;	state Exp;
branches;
next	1.3;
commitid	291545660e854567;

1.3
date	2006.10.11.20.46.28;	author mmostafa;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.27.20.04.24;	author sshaw;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.01.04.19.15.36;	author cmahoney;	state Exp;
branches;
next	;

1.2.2.1
date	2006.10.11.20.29.48;	author mmostafa;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2006.11.23.21.10.10;	author mmostafa;	state Exp;
branches;
next	;
commitid	1e3d45660e324567;

1.6.4.1
date	2008.10.22.13.50.15;	author aboyko;	state Exp;
branches;
next	;
commitid	1086c48ff2f964567;


desc
@@


1.7
log
@[250018] gmf_head aboyko 081022 BorderedNodeFigure#layout() may cause infinite loop
@
text
@/******************************************************************************
 * Copyright (c) 2003, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.figures;

import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.DelegatingLayout;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.LayoutAnimator;
import org.eclipse.draw2d.TreeSearch;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.BorderItemContainerFigure;
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.IExpandableFigure;
import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;

/**
 * Wrapper figure that contains the main figure and the border item figures.
 * This is required to allow the main figure's layout manager to ignore the
 * border items. The border item container applies a delegating layout manager
 * to allow border item children to lay themselves out.
 * 
 * @@author jbruck, cmahoney, mmostafa
 */
public class BorderedNodeFigure
	extends NodeFigure implements IExpandableFigure{

	private BorderItemContainerFigure borderItemContainer;

	private IFigure mainFigure;

	/**
	 * Creates a new BorderedNodeFigure figure.
	 * 
	 * @@param mainFigure
	 *            the figure to use with this figure
	 */
	public BorderedNodeFigure(IFigure mainFigure) {
		super();
		setOpaque(false); // set transparent by default
		setBorder(null);
		setLayoutManager(null);
		this.mainFigure = mainFigure;

		add(getMainFigure());
		add(getBorderItemContainer());

		setBounds(getMainFigure().getBounds().getCopy());
		getBorderItemContainer().setBounds(new Rectangle(0, 0, 1, 1));
	}

	/**
	 * Gets the border item container figure to which border item figures can be
	 * added with a {@@link IBorderItemLocator} as the constraint and then later
	 * removed.
	 * 
	 * @@return The border item container figure
	 */
	public IFigure getBorderItemContainer() {
		if (borderItemContainer == null) {
			borderItemContainer = new BorderItemContainerFigure();
			borderItemContainer
				.setLayoutManager(new DelegatingLayout());
			borderItemContainer.addLayoutListener(LayoutAnimator.getDefault());
			borderItemContainer.setVisible(true);
		}
		return borderItemContainer;
	}

	/**
	 * Gets the main figure of this bordered figure.
	 * 
	 * @@return The "main" figure
	 */
	public IFigure getMainFigure() {
		return mainFigure;
	}

	public Rectangle getClientArea(Rectangle rect) {
		if (getMainFigure() != null) {
			return getMainFigure().getClientArea(rect);
		}
		return super.getClientArea(rect);
	}

	/**
	 * gets the handle bounds of the main figure
	 * 
	 * @@return the hnalde bounds
	 */
	public Rectangle getHandleBounds() {
		if (getMainFigure() instanceof NodeFigure) {
			return ((NodeFigure) getMainFigure()).getHandleBounds().getCopy();
		} else {
			return getMainFigure().getBounds().getCopy();
		}
	}

	/**
	 * Give the main figure the entire bounds of the wrapper.
	 */
	protected void layout() {
		if (!this.getBounds().equals(getMainFigure().getBounds())) {
			getMainFigure().setBounds(this.getBounds().getCopy());
		}
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.draw2d.Figure#invalidate()
	 */
	public void invalidate() {
		super.invalidate();
		
		// When parent resizes, cause the border items to be relocated.
		getBorderItemContainer().invalidateTree();
		erase();
	}

	/**
	 * We need to override this for smooth painting of border items.
	 */
	public boolean containsPoint(int x, int y) {
		if (borderItemContainer.containsPoint(x, y)) {
			return true;
		}
		return super.containsPoint(x, y);
	}

	protected void primTranslate(int dx, int dy) {
		super.primTranslate(dx, dy);
		erase();
	}

	public void erase() {
		super.erase();
		if (borderItemContainer != null)
			borderItemContainer.erase();
	}

	/**
	 * Refresh adornments
	 */
	public void repaint() {
		super.repaint();
		if (borderItemContainer != null)
			borderItemContainer.repaint();
	}

	public IFigure findFigureAt(int x, int y, TreeSearch search) {
		if (search.prune(this))
			return null;
		IFigure result = borderItemContainer.findFigureAt(x, y, search);
		if (result != null) {
			return result;
		}
		return getMainFigure().findFigureAt(x, y, search);
	}

	public IFigure findMouseEventTargetAt(int x, int y) {
		IFigure borderItemFigure = borderItemContainer.findMouseEventTargetAt(
			x, y);
		if (borderItemFigure != null)
			return borderItemFigure;
		return super.findMouseEventTargetAt(x, y);
	}

    public boolean intersects(Rectangle rect) {
        if (getExtendedBounds().intersects(rect))
            return true;
        return super.intersects(rect);
    }

	public Dimension getMinimumSize(int wHint, int hHint) {
		return getMainFigure().getMinimumSize(wHint, hHint);
	}

	public Dimension getPreferredSize(int wHint, int hHint) {
		return getMainFigure().getPreferredSize(wHint, hHint);
	}

	public IFigure getToolTip() {
		return getMainFigure().getToolTip();
	}

	public void setToolTip(IFigure f) {
		getMainFigure().setToolTip(f);
	}

	public ConnectionAnchor getSourceConnectionAnchorAt(Point p) {
		if (getMainFigure() instanceof NodeFigure)
			return ((NodeFigure) getMainFigure())
				.getSourceConnectionAnchorAt(p);
		return super.getSourceConnectionAnchorAt(p);
	}

	public ConnectionAnchor getTargetConnectionAnchorAt(Point p) {
		if (getMainFigure() instanceof NodeFigure)
			return ((NodeFigure) getMainFigure())
				.getTargetConnectionAnchorAt(p);
		return super.getTargetConnectionAnchorAt(p);
	}

	public ConnectionAnchor getConnectionAnchor(String terminal) {
		if (getMainFigure() instanceof NodeFigure)
			return ((NodeFigure) getMainFigure()).getConnectionAnchor(terminal);
		return super.getConnectionAnchor(terminal);
	}

	public String getConnectionAnchorTerminal(ConnectionAnchor c) {
		if (getMainFigure() instanceof NodeFigure)
			return ((NodeFigure) getMainFigure())
				.getConnectionAnchorTerminal(c);
		return super.getConnectionAnchorTerminal(c);
	}

	/**
	 * This method provides a generic way to get a target figure's parent's main
	 * figure where if the target figure is a border item figure, then its
	 * parent is considered the figure on which it borders.It is not possible to
	 * get a target figure's parent using <code>IFigure#getParent()</code> if
	 * the target figure is a border item figure, since this would return the
	 * border item container figure.
	 * 
	 * @@param target
	 *            the target figure, may or may not be acting as a border item
	 *            figure
	 * @@return the parent figure or if the target figure was on a border item
	 *         container figure, then the main figure that it borders.
	 */
	public static IFigure getParentFigure(IFigure target) {
		IFigure parent = target.getParent();
		if (parent instanceof BorderItemContainerFigure) {
			return ((BorderedNodeFigure) parent.getParent()).getMainFigure();
		}
		return parent;
	}
    

    public Rectangle getExtendedBounds() {
        Rectangle rect = getBounds().getCopy();
         if (borderItemContainer!=null){
            return rect.union(borderItemContainer.getExtendedBounds().getCopy());
        }
        return rect;
    }
}
@


1.6
log
@gmf_head ahunter 070618 Update Copyright for files changed in 2007 for GMF 2.0
@
text
@d115 8
@


1.6.4.1
log
@[250018] gmf_R2_1_maintenance aboyko 081022 BorderedNodeFigure#layout() may cause infinite loop
@
text
@a114 8
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.draw2d.Figure#invalidate()
	 */
	public void invalidate() {
		super.invalidate();
		
@


1.5
log
@[168340] gmf_head aboyko 070108 BorderedNodeFigure#findFigureAt(int, int, TreeSearch) ignores exclusion set
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2006 IBM Corporation and others.
@


1.4
log
@ [161215]   gmf_head mmostafa 061123 Scrollpanes do not consider space occupied by border items
@
text
@d151 2
@


1.3
log
@[160532] gmf_R1_0_maintenace mmostafa 061011  need a way to get the real bounds of a bordered figure
@
text
@d32 1
a32 1
 * @@author jbruck, cmahoney
d239 3
a241 2
        if (borderItemContainer!=null){
            return borderItemContainer.getExtendedBounds().getCopy();
d243 1
a243 1
        return getBounds().getCopy();
@


1.2
log
@bugzilla 125158 gmf-head sshaw 060126 Migrate GMF animation support to use GEF 3.2 infrastructure for animation
@
text
@d23 1
d35 1
a35 1
	extends NodeFigure {
d166 5
a170 6
	public boolean intersects(Rectangle rect) {
		if (borderItemContainer.intersects(rect)) {
			return true;
		}
		return super.intersects(rect);
	}
d236 1
d238 6
@


1.2.2.1
log
@[160532] gmf_head mmostafa 061011  [160532] gmf_R1_0_maintenace mmostafa 061011  need a way to get the real bounds of a bordered figure
@
text
@a22 1
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.IExpandableFigure;
d34 1
a34 1
	extends NodeFigure implements IExpandableFigure{
d165 6
a170 5
    public boolean intersects(Rectangle rect) {
        if (getExtendedBounds().intersects(rect))
            return true;
        return super.intersects(rect);
    }
a235 1
    
a236 6
    public Rectangle getExtendedBounds() {
        if (borderItemContainer!=null){
            return borderItemContainer.getExtendedBounds().getCopy();
        }
        return getBounds().getCopy();
    }
@


1.2.2.2
log
@ [161215]   gmf_R1_0_maintenace mmostafa 061123 Scrollpanes do not consider space occupied by border items
@
text
@d32 1
a32 1
 * @@author jbruck, cmahoney, mmostafa
d239 2
a240 3
        Rectangle rect = getBounds().getCopy();
         if (borderItemContainer!=null){
            return rect.union(borderItemContainer.getExtendedBounds().getCopy());
d242 1
a242 1
        return rect;
@


1.1
log
@Bugzilla#111935 gmf_head cmahoney 060104 Border Item Infrastructure Consistency Issues
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2005 IBM Corporation and others.
d17 1
a22 1
import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.AnimationFigureHelper;
a60 16
	 * For animated layout.
	 * 
	 * @@author jbruck
	 */
	private class AnimatableDelegatingLayout
		extends DelegatingLayout {

		public void layout(IFigure container) {
			if (!AnimationFigureHelper.getInstance().layoutManagerHook(
				container)) {
				super.layout(container);
			}
		}
	}

	/**
d71 2
a72 1
				.setLayoutManager(new AnimatableDelegatingLayout());
@

