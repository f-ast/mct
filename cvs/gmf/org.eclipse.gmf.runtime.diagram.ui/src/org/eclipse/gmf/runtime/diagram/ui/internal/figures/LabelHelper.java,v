head	1.5;
access;
symbols
	v20081023-2107:1.5
	v20081022-1925:1.5
	v20081022-1005:1.5
	v20081020-0700:1.5
	v20080917-1925:1.5
	v20080916-2008:1.5
	v20080911-1728:1.5
	v20080911-1506:1.5
	v20080910-1520:1.5
	v20080910-1510:1.5
	v20080903-1520:1.5
	v20080903-1510:1.5
	v20080813-1510:1.5
	v20080811-1546:1.5
	v20080731-1520:1.5
	v20080725-1738:1.5
	v20080723-2246:1.5
	v20080723-2232:1.5
	v20080723-1700:1.5
	v20080722-1827:1.5
	v20080718-1700:1.5
	v20080718-1731:1.5
	v20080716-1600:1.5
	v20080716-1642:1.5
	R2_1_maintenance:1.5.0.6
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080610-1132:1.5
	v20080603-1553:1.5
	v20080527-1255:1.5
	v20080527-1151:1.5
	v20080516-1748:1.5
	v20080516-1143:1.5
	v20080512-1200:1.5
	v20080503-1740:1.5
	v20080501-2127:1.5
	v20080501-1739:1.5
	m20080429-1543:1.5
	v20080425-1959:1.5
	v20080417-1610:1.5
	v20080407-2250:1.5
	v20080407-0930:1.5
	v20080404-1111:1.5
	v20080328-1605:1.5
	v20080322-0000:1.5
	v20080222-1200:1.5
	v20080201-2010:1.5
	v20080201-0201:1.5
	v20080118-1129:1.5
	v20080114-2222:1.5
	v20080114-1111:1.5
	v20080107-1111:1.5
	v20071222-1111:1.5
	v20071214-1111:1.5
	v20071130-1111:1.5
	v20071124-0000:1.5
	v20071112-0000:1.5
	v20071108-0000:1.5
	v20071003-0000:1.5
	v20070915-0000:1.5
	v20070903-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.4
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070614-1400:1.5
	v20070608-1300:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070525-1500:1.5
	v20070518-1300:1.5
	bugzilla111892_group_support:1.5.0.2
	Root_bugzilla111892_group_support:1.5
	v20070504-1000:1.5
	v20070420-1000:1.5
	v20070413-1300:1.5
	v20070330-1300:1.5
	v20060330-1300:1.5
	v20070322-1100:1.5
	v20060316-0600:1.5
	v20070221-1500:1.5
	v20070208-1800:1.5
	v20070202-0200:1.4.2.1
	v20070119-1200:1.4.2.1
	v20070111-0800:1.4.2.1
	v20070105-1200:1.4.2.1
	v20070103-0300:1.5
	M4_20:1.5
	v20061218-1500:1.4.2.1
	v20061218-1200:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061117-0800:1.5
	v20061027-1200:1.4.2.1
	v20061013-1330:1.5
	v20061012-1100:1.4.2.1
	v20060925-1700:1.4.2.1
	v20060919-0800:1.4.2.1
	v20060907-1100:1.4
	M1_20:1.4
	v20060831-1500:1.4
	v20060824-1600:1.4
	v20060817-1500:1.4
	v20060810-1700:1.4
	v20060803-1200:1.4
	v20060728-0500:1.4
	v20060721-1130:1.4
	v20060713-1700:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060616-1400:1.4
	v20060616-1200:1.4
	v20060609-1400:1.4
	v20060531-1730:1.4
	v20060530-1930:1.4
	v20060526-1200:1.4
	v20060519-0800:1.3
	v20060512-1000:1.3
	I20060512-1000:1.3
	I20060505-1400:1.3
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.3
	I20060216-1945:1.3
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060202-1415:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051208-2000:1.3
	I20051201-1800:1.3
	I20051124-2000:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.2;
locks; strict;
comment	@# @;


1.5
date	2006.10.03.15.02.04;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.24.01.43.06;	author sshaw;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2005.11.04.22.13.15;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.29.10;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.08.18.58.41;	author sshaw;	state Exp;
branches;
next	;

1.4.2.1
date	2006.09.13.16.43.40;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.5
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/
package org.eclipse.gmf.runtime.diagram.ui.internal.figures;

import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.Rectangle;

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

/**
 * Helper class to convert the label coordinates from an offset value
 * from a keypoint to real draw2d coordinate
 * 
 * @@author sshaw
 *
 */
public class LabelHelper {

	/**
	 * Calculates the label offset from the reference point given the label bounds.  
	 * 
	 * @@param label the <code>IFigure</code> to calculate the offset for
	 * @@param bounds the <code>Rectangle</code> that is the bounding box of the label.
	 * @@param ref the <code>Point</code> that is the reference point that the offset
	 * is based on.
	 * @@return a <code>Point</code> which represents a value offset from the <code>ref</code>
	 * point oriented based on the nearest line segment.
	 */
	static public Point offsetFromRelativeCoordinate(IFigure label, Rectangle bounds, Point ref) {
		return offsetFromRelativeCoordinate(label, bounds, getParentPointList(label), ref);
	}
	
	/**
	 * Calculates the label offset from the reference point given the label bounds and a points list.  
	 * 
	 * @@param label the <code>IFigure</code> to calculate the offset for
	 * @@param bounds the <code>Rectangle</code> that is the bounding box of the label.
	 * @@param points the <code>PointList</code> that contains that the label offset is relative to.
	 * @@param ref the <code>Point</code> that is the reference point that the offset
	 * is based on.
	 * @@return a <code>Point</code> which represents a value offset from the <code>ref</code>
	 * point oriented based on the nearest line segment.
	 */
	static private Point offsetFromRelativeCoordinate(IFigure label, Rectangle bounds, PointList points, Point ref) {
		Rectangle rect = new Rectangle(bounds);
		
		//Componsate for the fact that we are using the 
		// figure center
		rect.translate(rect.width /2, rect.height /2);
		
		Point normalPoint = normalizeRelativePointToPointOnLine(points, ref,
				new Point(rect.x - ref.x, rect.y - ref.y));
		
		return normalPoint;
	}
	
	/**
	 * Calculates the relative coordinate that is equivalent to the offset from the reference 
	 * point, that can be used to set the label location.
	 * 
	 * @@param label the <code>IFigure</code> to calculate the relative coordinate for 
	 * @@param ref a <code>Point</code> located on the parent which the offset value
	 * is relative to.
	 * @@param offset a <code>Point</code> which represents a value offset from the <code>ref</code>
	 * point oriented based on the nearest line segment.
	 * @@return a <code>Point</code> that is the relative coordinate of the label that can be
	 * used to set it's location.
	 */
	static public Point relativeCoordinateFromOffset(IFigure label, Point ref, Point offset) {
		return relativeCoordinateFromOffset(label, getParentPointList(label), ref, offset);
	}
	
	/**
	 * Calculates the relative coordinate that is equivalent to the offset from the reference 
	 * point, that can be used to set the label location.
	 * 
	 * @@param label the <code>IFigure</code> to calculate the relative coordinate for 
	 * @@param points the <code>PointList</code> that contains that the label offset is relative to.
	 * @@param ref a <code>Point</code> located on the parent which the offset value
	 * is relative to.
	 * @@param offset a <code>Point</code> which represents a value offset from the <code>ref</code>
	 * point oriented based on the nearest line segment.
	 * @@return a <code>Point</code> that is the relative coordinate of the label that can be
	 * used to set it's location.
	 */
	static private Point relativeCoordinateFromOffset(IFigure label, PointList points, Point ref, Point offset) {
		Point location = calculatePointRelativeToPointOnLine(points, ref, offset);
		location.translate(-1 * label.getBounds().width /2, -1 * label.getBounds().height /2);
		return location;
	}
	
	/**
	 * gets the point list using the passed figure to get the parent
	 * 
	 * @@param label the <code>IFigure</code> to use to retrieve the parent points
	 * @@return List of points
	 */
	static private PointList getParentPointList(IFigure label) {
		IFigure parent = label.getParent();
		if (parent instanceof Connection) {
			return ((Connection) parent).getPoints();
		} else {
			PointList ptList = new PointList();
			ptList.addPoint(parent.getBounds().getLocation());
			return ptList;
		}			
	}
	
	/**
	 * Returns a point located relative to the line by the given offset.
	 * 
	 * @@param ptLst the point
	 * @@param ptOnLine
	 * @@param offset
	 * @@return the relative point given the line angle
	 */
	protected static Point calculatePointRelativeToPointOnLine(PointList ptLst, Point ptOnLine, Point offset) {
		// Calculate slope of line
		if (ptLst.size() == 1) {
			// This is a node...
			return ptLst.getFirstPoint().getTranslated(offset);
		} else if (ptLst.size() >= 2){
			// This is a edge...
			int index = PointListUtilities.findNearestLineSegIndexOfPoint(ptLst, ptOnLine);		
			LineSeg segment = (LineSeg) PointListUtilities.getLineSegments(ptLst).get(index - 1);
			Point relativeOffset = null;
			if (segment != null) {
				if (segment.isHorizontal()) {
					if (segment.getOrigin().x > segment.getTerminus().x) {
						relativeOffset = ptOnLine.getTranslated(offset.getNegated());
						//System.out.println("1. Relative offset: " + relativeOffset);//$NON-NLS-1$
						return relativeOffset;
					} else {
						relativeOffset = ptOnLine.getTranslated(offset);	
						//System.out.println("2. Relative offset: " + relativeOffset);//$NON-NLS-1$
						return relativeOffset;
					}
				} else if (segment.isVertical()) {
					if (segment.getOrigin().y > segment.getTerminus().y) {
						relativeOffset = ptOnLine.getTranslated(offset.getCopy().scale(-1, 1).transpose());
						//System.out.println("3. Relative offset: " + relativeOffset);//$NON-NLS-1$
						return relativeOffset;						
					} else {
						relativeOffset = ptOnLine.getTranslated(offset.getCopy().scale(1, -1).transpose());
						//System.out.println("4. Relative offset: " + relativeOffset);//$NON-NLS-1$
						return relativeOffset;
					}
				} else {				
					double slope = segment.slope();
					double theta = Math.atan(slope);
					Point normalizedOffset = new Point(offset);
					Point calculatedOffset = new Point();
					if (segment.getOrigin().x > segment.getTerminus().x) {
						normalizedOffset = offset.getCopy().scale(-1, -1);
					}

					calculatedOffset = new Point(normalizedOffset.x
						* Math.cos(theta) - normalizedOffset.y
						* Math.sin(theta), normalizedOffset.x * Math.sin(theta)
						+ normalizedOffset.y * Math.cos(theta));
					relativeOffset = ptOnLine.getTranslated(calculatedOffset);
					//System.out.println("5. Relative offset: " + relativeOffset);//$NON-NLS-1$
					return relativeOffset;									
				}
			}
		}					
		return null;
	}
	
	/**
	 * Calculates the normalized offset from a point on a <code>Connection</code>'s point list to an point.
	 * 
	 * @@param ptLst
	 * @@param ptOnLine
	 * @@param offset
	 * @@return the normalized offset
	 */
	private static Point normalizeRelativePointToPointOnLine(PointList ptLst, Point ptOnLine, Point offset) {
		// Calculate slope of line
		if (ptLst.size() == 1) {
			// This is a node...
			return offset;
		} else if (ptLst.size() >= 2){
			// This is a edge...
			int index = PointListUtilities.findNearestLineSegIndexOfPoint(ptLst, ptOnLine);		
			LineSeg segment = (LineSeg) PointListUtilities.getLineSegments(ptLst).get(index - 1);
			Point normalOffset = null;
			if (segment != null) {
				if (segment.isHorizontal()) {
					if (segment.getOrigin().x > segment.getTerminus().x) {
						normalOffset = offset.getNegated();
						//System.out.println("1. Normal offset: " + normalOffset);//$NON-NLS-1$
						return normalOffset;
					} else {
						normalOffset = offset;
						//System.out.println("2. Normal offset: " + normalOffset);//$NON-NLS-1$
						return normalOffset;						
					}					
				} else if (segment.isVertical()) {
					if (segment.getOrigin().y < segment.getTerminus().y) {
						normalOffset = offset.scale(-1, 1).transpose();
						//System.out.println("3. Normal offset: " + normalOffset);//$NON-NLS-1$
						return normalOffset;
					} else {
						normalOffset = offset.scale(1, -1).transpose();
						//System.out.println("4. Normal offset: " + normalOffset);//$NON-NLS-1$						
						return normalOffset;
					}
				} else {				
					Point p = ptOnLine.getTranslated(offset);
					normalOffset = getOrthogonalDistances(segment, ptOnLine, p);	
					//System.out.println("5. Normal offset: " + normalOffset);//$NON-NLS-1$
					return normalOffset;										
				}
			}
		}					
		return null;

	}
	
	/**
	 * Calculates distances from a <code>Point</code> on a <code>LineSeg</code> to 
	 * another <code>Point</code>.  The sign of the distances indicate direction.
	 * 
	 * @@param lineSeg
	 * @@param ptOnLine
	 * @@param refPoint
	 * @@return the distance from <code>Point</code> on a <code>LineSeg</code> to another <code>Point</code>
	 */
	private static Point getOrthogonalDistances(LineSeg lineSeg, Point ptOnLine, Point refPoint) {
		LineSeg parallelSeg = lineSeg.getParallelLineSegThroughPoint(refPoint);
		Point p1 = parallelSeg.perpIntersect(ptOnLine.x, ptOnLine.y);
		double dx = p1.getDistance(refPoint) * ((p1.x > refPoint.x) ? -1 : 1);
		double dy = p1.getDistance(ptOnLine) * ((p1.y < ptOnLine.y) ? -1 : 1);
		Point orth = new Point(dx, dy);	
		// Reflection in the y axis		
		if (lineSeg.getOrigin().x > lineSeg.getTerminus().x)
			orth = orth.scale(-1, -1);
		return orth;
	}
}
@


1.4
log
@bugzilla 141888 gmf-head sshaw 060523 Label repositioning inconsistent with feedback
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
@


1.4.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
@


1.3
log
@Bugzilla#113157 gmf_head cmahoney 051104 Updating tutorial guides and some comments with name changes
@
text
@a16 1
import org.eclipse.draw2d.geometry.PrecisionRectangle;
d57 1
a57 1
		PrecisionRectangle rect = new PrecisionRectangle(bounds);
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d184 1
a184 1
	 * Calculates the normalized offset from a point on a <code>Connector</code>'s point list to an point.
@


1.1
log
@Bugzilla 109092  : rumv_head mmostafa 050908 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d1 10
@

