head	1.23;
access;
symbols
	v20081023-2107:1.23
	v20081022-1925:1.23
	v20081022-1005:1.23
	v20081020-0700:1.23
	v20080917-1925:1.23
	v20080916-2008:1.23
	v20080911-1728:1.23
	v20080911-1506:1.23
	v20080910-1520:1.23
	v20080910-1510:1.23
	v20080903-1520:1.23
	v20080903-1510:1.23
	v20080813-1510:1.23
	v20080811-1546:1.23
	v20080731-1520:1.23
	v20080725-1738:1.23
	v20080723-2246:1.23
	v20080723-2232:1.23
	v20080723-1700:1.23
	v20080722-1827:1.23
	v20080718-1700:1.23
	v20080718-1731:1.23
	v20080716-1600:1.23
	v20080716-1642:1.23
	R2_1_maintenance:1.23.0.2
	Root_R2_1_maintenance:1.23
	R2_1_0:1.23
	v20080610-1132:1.23
	v20080603-1553:1.23
	v20080527-1255:1.23
	v20080527-1151:1.21
	v20080516-1748:1.23
	v20080516-1143:1.23
	v20080512-1200:1.23
	v20080503-1740:1.23
	v20080501-2127:1.21
	v20080501-1739:1.23
	m20080429-1543:1.21
	v20080425-1959:1.23
	v20080417-1610:1.22
	v20080407-2250:1.22
	v20080407-0930:1.22
	v20080404-1111:1.22
	v20080328-1605:1.22
	v20080322-0000:1.21
	v20080222-1200:1.21
	v20080201-2010:1.21
	v20080201-0201:1.21
	v20080118-1129:1.21
	v20080114-2222:1.21
	v20080114-1111:1.21
	v20080107-1111:1.21
	v20071222-1111:1.21
	v20071214-1111:1.21
	v20071130-1111:1.21
	v20071124-0000:1.21
	v20071112-0000:1.21
	v20071108-0000:1.21
	v20071003-0000:1.21
	v20070915-0000:1.21
	v20070903-0000:1.21
	v20070809-0000:1.21
	R2_0_maintenance:1.21.0.4
	R2_0:1.21
	R4_20:1.21
	v20070621-0000:1.21
	RC3_20:1.21
	v20070614-1400:1.21
	v20070608-1300:1.21
	v20070605-1400:1.21
	v20070601-1400:1.21
	v20070525-1500:1.21
	v20070518-1300:1.21
	bugzilla111892_group_support:1.21.0.2
	Root_bugzilla111892_group_support:1.21
	v20070504-1000:1.21
	v20070420-1000:1.21
	v20070413-1300:1.21
	v20070330-1300:1.21
	v20060330-1300:1.21
	v20070322-1100:1.21
	v20060316-0600:1.21
	v20070221-1500:1.21
	v20070208-1800:1.21
	v20070202-0200:1.20.2.7
	v20070119-1200:1.20.2.7
	v20070111-0800:1.20.2.7
	v20070105-1200:1.20.2.7
	v20070103-0300:1.21
	M4_20:1.21
	v20061218-1500:1.20.2.7
	v20061218-1200:1.21
	v20061214-0000:1.21
	M3_20:1.21
	v20061117-0800:1.21
	v20061027-1200:1.20.2.7
	v20061013-1330:1.21
	v20061012-1100:1.20.2.7
	v20060925-1700:1.20.2.7
	v20060919-0800:1.20.2.6
	v20060907-1100:1.20.2.5
	M1_20:1.20
	v20060831-1500:1.20.2.5
	v20060824-1600:1.20.2.4
	v20060817-1500:1.20.2.4
	v20060810-1700:1.20.2.4
	v20060803-1200:1.20.2.4
	v20060728-0500:1.20.2.4
	v20060721-1130:1.20.2.4
	v20060713-1700:1.20.2.3
	R1_0_maintenance:1.20.0.2
	R1_0:1.20
	v20060627-1200:1.20
	v20060616-1400:1.20
	v20060616-1200:1.20
	v20060609-1400:1.19
	v20060531-1730:1.19
	v20060530-1930:1.19
	v20060526-1200:1.19
	v20060519-0800:1.18
	v20060512-1000:1.17
	I20060512-1000:1.17
	I20060505-1400:1.17
	I20060428-1300:1.16
	I20060424-0500:1.16
	I20060424-0300:1.16
	M6_10:1.16
	I20060407-1200:1.15
	I20060331-1000:1.15
	I20060324-0300:1.15
	I20060317-1300:1.15
	I20060317-1200:1.15
	I20060316-1300:1.15
	I20060309-1300:1.15
	M5_10:1.15
	S20060303-1600:1.15
	I20060227-1730:1.14
	I20060216-1945:1.14
	I20060210-1715:1.12
	I20060209-1815:1.12
	I20060203-0830:1.12
	I20060202-1415:1.12
	I20060129-1145:1.11
	I20060127-0900:1.11
	I20060120-1530:1.11
	I20060113-1700:1.11
	M4_10:1.11
	I20060107-1100:1.11
	I20060105-1630:1.11
	I20051230-1230:1.11
	I20051223-1100:1.11
	I20051217-0925:1.11
	I20051208-2000:1.11
	I20051201-1800:1.11
	I20051124-2000:1.10
	M3_10:1.9
	I20051118-1245:1.9
	I20051111-1800:1.8
	I20051106-0900:1.8
	v20051030:1.5;
locks; strict;
comment	@# @;


1.23
date	2008.04.25.18.39.38;	author ahunter;	state Exp;
branches;
next	1.22;
commitid	2698481225694567;

1.22
date	2008.03.28.21.54.56;	author ahunter;	state Exp;
branches;
next	1.21;
commitid	713047ed692e4567;

1.21
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.14.18.39.49;	author ahunter;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2006.05.25.21.54.58;	author ldamus;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.17.14.00.26;	author ldamus;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.03.17.59.24;	author ldamus;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.10.20.33.48;	author ldamus;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.28.02.30.51;	author cmahoney;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.16.18.48.38;	author ldamus;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.13.19.11.49;	author ldamus;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.01.20.17.39;	author mmostafa;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.25.19.38.12;	author cmahoney;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.23.15.49.23;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.15.00.22.22;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.03.14.52.14;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.03.01.55.20;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.03.16.07.14;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.22.15.42.19;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.29.06;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.37;	author sshaw;	state Exp;
branches;
next	;

1.20.2.1
date	2006.07.06.17.25.43;	author cmahoney;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2006.07.07.17.46.44;	author ldamus;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2006.07.13.15.10.10;	author mmostafa;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2006.07.14.14.31.01;	author sshaw;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2006.08.31.18.25.44;	author cmahoney;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2006.09.13.16.43.39;	author ahunter;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2006.09.22.14.07.53;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.23
log
@[228915] gmf-head ahunter 080425 Non-externalized string literal; it should be followed by //$NON-NLS-<n>
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.ConnectionLayer;
import org.eclipse.draw2d.ConnectionRouter;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.PolylineConnection;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.LayerConstants;
import org.eclipse.gef.Request;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.requests.CreateConnectionRequest;
import org.eclipse.gef.requests.CreateRequest;
import org.eclipse.gef.requests.ReconnectRequest;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.diagram.core.commands.SetConnectionAnchorsCommand;
import org.eclipse.gmf.runtime.diagram.core.commands.SetConnectionEndsCommand;
import org.eclipse.gmf.runtime.diagram.core.commands.SetPropertyCommand;
import org.eclipse.gmf.runtime.diagram.core.edithelpers.CreateElementRequestAdapter;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.CreateCommand;
import org.eclipse.gmf.runtime.diagram.ui.commands.CreateOrSelectElementCommand;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.SemanticCreateCommand;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.INodeEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ITreeBranchEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.SetConnectionBendpointsCommand;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
import org.eclipse.gmf.runtime.diagram.ui.requests.ChangePropertyValueRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateConnectionViewAndElementRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateConnectionViewRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateUnspecifiedTypeConnectionRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewRequestFactory;
import org.eclipse.gmf.runtime.diagram.ui.requests.EditCommandRequestWrapper;
import org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants;
import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.ConnectionLayerEx;
import org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter;
import org.eclipse.gmf.runtime.emf.core.util.PackageUtil;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.emf.type.core.requests.CreateRelationshipRequest;
import org.eclipse.gmf.runtime.emf.ui.services.modelingassistant.ModelingAssistantService;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.Routing;
import org.eclipse.gmf.runtime.notation.RoutingStyle;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.swt.widgets.Display;

/*
 * @@canBeSeenBy %partners
 */
/**
 * the graphical node edit policy
 * @@see org.eclipse.gef.editpolicies.GraphicalNodeEditPolicy
 * 
 * @@author mmostafa, cmahoney
 */
public class GraphicalNodeEditPolicy
		extends
			org.eclipse.gef.editpolicies.GraphicalNodeEditPolicy {
	/** describes the view to be created. */
	private IAdaptable _viewAdapter;
	
	/**
	 * The label used for the command to create a new connection.
	 */
	private static final String CREATE_CONNECTION_COMMAND_LABEL = DiagramUIMessages.GraphicalNodeEditPolicy_createRelationshipCommand_label;
	
	/**
	 * Gets a command that pops up a menu which allows the user to select which
	 * type of connection to be created and then creates the connection. This
	 * command uses
	 * {@@link #getCommandForMenuSelection(Object, CreateConnectionRequest)} on
	 * the connection chosen to get the creation command.
	 * 
	 * @@author cmahoney
	 */
	protected class PromptAndCreateConnectionCommand
		extends CreateOrSelectElementCommand {

		/**
		 * Cache the request because it needs to be passed to
		 * {@@link #getCommandForMenuSelection(Object, CreateConnectionRequest)}.
		 */
		private CreateConnectionRequest request;

		/**
		 * Creates a new instance.
		 * 
		 * @@param content
		 *            The list of items making up the content of the popup menu.
		 * @@param request
		 *            The relevant create connection request.
		 */
		public PromptAndCreateConnectionCommand(List content,
				CreateConnectionRequest request) {
			super(CREATE_CONNECTION_COMMAND_LABEL, Display.getCurrent()
				.getActiveShell(), content);
			this.request = request;
		}

		/**
		 * The command to create the connection that may need to be
		 * undone/redone.
		 */
		private Command createCommand;

		/**
		 * Pops up the dialog with the content provided, gets the command to be
		 * executed based on the user selection, and then executes the command.
		 */
		protected CommandResult doExecuteWithResult(
                IProgressMonitor progressMonitor, IAdaptable info)
            throws ExecutionException {
            
			CommandResult cmdResult = super.doExecuteWithResult(progressMonitor, info);
			if (!cmdResult.getStatus().isOK()) {
				return cmdResult;
			}

            Object connectionType = cmdResult.getReturnValue();

            Command cmd = getConnectionCompleteCommand(connectionType, getRequest());
			Assert.isTrue(cmd != null && cmd.canExecute());
			cmd.execute();
			createCommand = cmd;
            
            if (connectionType instanceof IElementType) {
                CreateRequest createRequest = ((CreateUnspecifiedTypeConnectionRequest) request)
                    .getRequestForType((IElementType) connectionType);
                Object newObject = createRequest.getNewObject();

                return CommandResult.newOKCommandResult(newObject);
            }
            return CommandResult.newOKCommandResult();
		}

		protected CommandResult doUndoWithResult(IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
			if (createCommand != null) {
				createCommand.undo();
			}
			return super.doUndoWithResult(progressMonitor, info);
		}

		protected CommandResult doRedoWithResult(IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
			if (createCommand != null) {
				createCommand.redo();
			}
			return super.doRedoWithResult(progressMonitor, info);
		}

		/**
		 * Gets the request.
		 * 
		 * @@return Returns the request.
		 */
		private CreateConnectionRequest getRequest() {
			return request;
		}

	}
	
	protected Connection createDummyConnection(Request req) {
		PolylineConnection c = (PolylineConnection) super.createDummyConnection(req);
		c.setLineStyle(Graphics.LINE_DASHDOT);
		c.setForegroundColor(((GraphicalEditPart) getHost()).getFigure()
				.getForegroundColor());
		return c;
	}
	
	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.gef.editpolicies.GraphicalNodeEditPolicy#getDummyConnectionRouter(org.eclipse.gef.requests.CreateConnectionRequest)
	 */
	protected ConnectionRouter getDummyConnectionRouter(CreateConnectionRequest arg0) {
		EditPart ep = getHost();
		if (ep instanceof IGraphicalEditPart) {
			IGraphicalEditPart gep = ((IGraphicalEditPart)ep);
			Routing routingVal = Routing.MANUAL_LITERAL;
			if (gep.getNotationView() != null) {
				Diagram dgrm = gep.getNotationView().getDiagram();
				EditPart epfromReg = (EditPart)gep.getViewer().getEditPartRegistry().get(dgrm);
				if (epfromReg != null)
					routingVal = (Routing)epfromReg.getAdapter(Routing.class);
			}
			else {
				IPreferenceStore store = (IPreferenceStore) ((IGraphicalEditPart)ep).getDiagramPreferencesHint().getPreferenceStore();
				routingVal = Routing.get(store.getInt(IPreferenceConstants.PREF_LINE_STYLE));
			}
			
			ConnectionLayer cLayer = (ConnectionLayer) getLayer(LayerConstants.CONNECTION_LAYER);
			if (cLayer instanceof ConnectionLayerEx) {
				ConnectionLayerEx cLayerEx = (ConnectionLayerEx)cLayer;
				if (routingVal == Routing.MANUAL_LITERAL) {
					return cLayerEx.getObliqueRouter();
				}
				else if (routingVal == Routing.RECTILINEAR_LITERAL) {
					return cLayerEx.getRectilinearRouter();
				}
				else if (routingVal == Routing.TREE_LITERAL) {
					return cLayerEx.getTreeRouter();
				}
			}
		}
		
		return super.getDummyConnectionRouter(arg0);
	}



	protected ConnectionAnchor getSourceConnectionAnchor(
			CreateConnectionRequest request) {
		EditPart source = request.getSourceEditPart();
		return source instanceof INodeEditPart ? ((INodeEditPart) source)
				.getSourceConnectionAnchor(request) : null;
	}
	
	protected ConnectionAnchor getTargetConnectionAnchor(
			CreateConnectionRequest request) {
		EditPart target = request.getTargetEditPart();
		return target instanceof INodeEditPart ? ((INodeEditPart) target)
				.getTargetConnectionAnchor(request) : null;
	}

	/**
	 * get a connectable edit part
	 * @@return INodeEditPart
	 */
	protected INodeEditPart getConnectableEditPart() {
		return (INodeEditPart) getHost();
	}
	/**
	 * getConnectionCompleteEditPart
	 * 
	 * This method is used when the connection is verified and made complete to
	 * retrieve the final connecting editpart to be used in the connection
	 * creation. This is by default the "host" edit part which is what is
	 * connected to by the user feedback. Subclassing edit-policies may wish to
	 * redirect the connection to a different edit-part depending on the
	 * gesture. i.e. the tree-view for generalizations will redirect the
	 * connection to the target of the host.
	 * 
	 * @@param request
	 *            Request giving some information about the user gesture.
	 * @@return INodeEditPart which will be the target connection.
	 */
	protected INodeEditPart getConnectionCompleteEditPart(Request request) {
		if (getHost() instanceof INodeEditPart) {
			return (INodeEditPart) getHost();
		}
		return null;
	}
	/**
	 * getConnectionTargetAnchor Method used during reconnection to retrieve
	 * the appropriate target anchor based on a request.
	 * 
	 * @@param request
	 *            Request giving some information about the user gesture.
	 * @@return ConnectionAnchor the connections target end will connect to.
	 */
	protected ConnectionAnchor getConnectionTargetAnchor(Request request) {
		INodeEditPart node = getConnectableEditPart();
		if (node != null)
			return node.getTargetConnectionAnchor(request);
		
		return null;
	}
	/**
	 * get this edit policy's edit part <code>View</code>
	 * @@return View
	 */
	protected View getView() {
		return (View)getHost().getModel();
	}
	/**
	 * getSemanticHint Retrieves the semanticHint from the request regarding
	 * the type of elemen being manipulated.
	 * 
	 * @@param request
	 *            Request that is sent from the user gesture
	 * @@return String that is the semantic type.
	 */
	protected String getSemanticHint(Request request) {
		String hint = null;
		if (request instanceof CreateConnectionViewAndElementRequest) {
			CreateConnectionViewAndElementRequest ccvr = (CreateConnectionViewAndElementRequest) request;
			// get the element descriptor
			CreateElementRequestAdapter requestAdapter = ccvr
					.getConnectionViewAndElementDescriptor()
					.getCreateElementRequestAdapter();
			// get the semantic request
			CreateRelationshipRequest createElementRequest = (CreateRelationshipRequest) requestAdapter
					.getAdapter(CreateRelationshipRequest.class);
			hint = PackageUtil.getID(createElementRequest.getElementType().getEClass());
		} else if (request instanceof ReconnectRequest) {
			ReconnectRequest rr = (ReconnectRequest) request;
			hint = ViewUtil.getSemanticElementClassId((View)rr.getConnectionEditPart().getModel());
		} else if (request instanceof CreateConnectionViewRequest) {
			CreateConnectionViewRequest ccvr = (CreateConnectionViewRequest) request;
			hint = ccvr.getConnectionViewDescriptor().getSemanticHint();
		}
		return hint;
	}
	/**
	 * getRoutingAdjustment method to adjust routing if the reorient has moved
	 * the connection into a different routing environment. Specifically, if
	 * the connection has been reoriented out of a tree structure it will
	 * change routing to the default set in preference. Likewise, if the
	 * connection has connected to a tree structure then the routing will
	 * create a tree.
	 * 
	 * @@param connection
	 *            IAdaptable that is placeholder for not yet created connection.
	 *            Also adapts directly to a ConnectionEditPart in the case of a
	 *            reorient.
	 * @@param connectionHint
	 *            String that is the semantic hint of the connection being
	 *            manipulated
	 * @@param currentRouterType
	 *            Integer current representation of the routing style
	 * @@param target
	 *            EditPart that is being targeted by the request.
	 * @@return Command to make any routing adjustments if necessary.
	 */
	protected Command getRoutingAdjustment(IAdaptable connection,
			String connectionHint, Routing currentRouterType, EditPart target) {
		Command cmd = null;
		if (connectionHint == null ||
				target == null || target.getModel() == null
				|| ((View)target.getModel()).getElement() == null)
			return null;
		// check if router needs to change type due to reorient.
		String targetHint = ViewUtil.getSemanticElementClassId((View) target.getModel());
		Routing newRouterType = null;
		if (target instanceof ITreeBranchEditPart
				&& connectionHint.equals(targetHint)) {
			newRouterType = Routing.TREE_LITERAL;
			ChangePropertyValueRequest cpvr = new ChangePropertyValueRequest(
					StringStatics.BLANK, Properties.ID_ROUTING, newRouterType);
			Command cmdRouter = target.getCommand(cpvr);
			if (cmdRouter != null)
				cmd = cmd == null ? cmdRouter : cmd.chain(cmdRouter);
		} else {
			if (currentRouterType.equals(Routing.TREE_LITERAL)) {
				IPreferenceStore store = (IPreferenceStore)
					((IGraphicalEditPart) getHost())
						.getDiagramPreferencesHint().getPreferenceStore();
				newRouterType = Routing.get(store.getInt(IPreferenceConstants.PREF_LINE_STYLE));
			}
		}
		if (newRouterType != null) {
			// add commands for line routing. Convert the new connection and
			// also the targeted connection.
			ICommand spc = new SetPropertyCommand(
                getEditingDomain(), connection,
				Properties.ID_ROUTING, StringStatics.BLANK, newRouterType);
			Command cmdRouter = new ICommandProxy(spc);
			if (cmdRouter != null) {
				cmd = cmd == null ? cmdRouter : cmd.chain(cmdRouter);
			}
		}
		return cmd;
	}
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.editpolicies.GraphicalNodeEditPolicy#getReconnectTargetCommand(org.eclipse.gef.requests.ReconnectRequest)
	 */
	protected Command getReconnectTargetCommand(ReconnectRequest request) {
		INodeEditPart node = getConnectableEditPart();
		if (node == null)
			return null;
		
        TransactionalEditingDomain editingDomain = getEditingDomain();
		
		ConnectionAnchor targetAnchor = getConnectionTargetAnchor(request);
		INodeEditPart targetEP = getConnectionCompleteEditPart(request);
		if (targetEP == null) {
			return null;
		}
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, StringStatics.BLANK);
		sceCommand.setEdgeAdaptor(new EObjectAdapter((EObject)request
				.getConnectionEditPart().getModel()));
		sceCommand.setNewTargetAdaptor(targetEP);
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, StringStatics.BLANK);
		scaCommand.setEdgeAdaptor(new EObjectAdapter((EObject) request
			.getConnectionEditPart().getModel()));
		scaCommand.setNewTargetTerminal(targetEP
				.mapConnectionAnchorToTerminal(targetAnchor));
		CompositeCommand cc = new CompositeCommand(
			DiagramUIMessages.Commands_SetConnectionEndsCommand_Target);
		cc.compose(sceCommand);
		cc.compose(scaCommand);
		Command cmd = new ICommandProxy(cc);
		EditPart cep = request.getConnectionEditPart();
		RoutingStyle style = (RoutingStyle) ((View)cep.getModel()).getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
		Routing currentRouter = Routing.MANUAL_LITERAL;		
		if (style != null) {
			currentRouter = style.getRouting();
		}
		Command cmdRouter = getRoutingAdjustment(request
				.getConnectionEditPart(), getSemanticHint(request),
				currentRouter, request.getTarget());
		if (cmdRouter != null) {
			cmd = cmd == null ? cmdRouter : cmd.chain(cmdRouter);
			// reset the bendpoints
			ConnectionAnchor sourceAnchor = node
					.getSourceConnectionAnchor(request);
			PointList pointList = new PointList();
			pointList.addPoint(sourceAnchor.getLocation(targetAnchor
					.getReferencePoint()));
			pointList.addPoint(targetAnchor.getLocation(sourceAnchor
					.getReferencePoint()));
            
			SetConnectionBendpointsCommand sbbCommand = new SetConnectionBendpointsCommand(editingDomain);
			sbbCommand.setEdgeAdapter(request.getConnectionEditPart());
			sbbCommand.setNewPointList(pointList, sourceAnchor
					.getReferencePoint(), targetAnchor.getReferencePoint());
			Command cmdBP = new ICommandProxy(sbbCommand);
			if (cmdBP != null) {
				cmd = cmd == null ? cmdBP : cmd.chain(cmdBP);
			}
		}
		return cmd;
	}
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.editpolicies.GraphicalNodeEditPolicy#getReconnectSourceCommand(org.eclipse.gef.requests.ReconnectRequest)
	 */
	protected Command getReconnectSourceCommand(ReconnectRequest request) {
		INodeEditPart node = getConnectableEditPart();
		if (node == null)
			return null;
		
        TransactionalEditingDomain editingDomain = getEditingDomain();
        
		ConnectionAnchor sourceAnchor = node.getSourceConnectionAnchor(request);
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, StringStatics.BLANK);
		sceCommand.setEdgeAdaptor(new EObjectAdapter((View) request
				.getConnectionEditPart().getModel()));
		sceCommand.setNewSourceAdaptor(new EObjectAdapter((View)node
				.getModel()));
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, StringStatics.BLANK);
		scaCommand.setEdgeAdaptor(new EObjectAdapter((View) request
			.getConnectionEditPart().getModel()));
		scaCommand.setNewSourceTerminal(node.mapConnectionAnchorToTerminal(sourceAnchor));
		CompositeCommand cc = new CompositeCommand(
			DiagramUIMessages.Commands_SetConnectionEndsCommand_Source);
		cc.compose(sceCommand);
		cc.compose(scaCommand);
		return new ICommandProxy(cc);
	}
	/**
	 * Returns a command that will create the connection.
	 * 
	 * If you must override this method, you should call super.
	 *  
	 * @@see org.eclipse.gef.editpolicies.GraphicalNodeEditPolicy#getConnectionCompleteCommand(org.eclipse.gef.requests.CreateConnectionRequest)
	 *
	 */
	protected Command getConnectionCompleteCommand(
			CreateConnectionRequest request) {
		ICommandProxy proxy = (ICommandProxy) request
			.getStartCommand();
		if (proxy == null) {
			return null;
		}

		// reset the target edit-part for the request
		INodeEditPart targetEP = getConnectionCompleteEditPart(request);
		if (targetEP == null) {
			return null;
		}

		CompositeCommand cc = (CompositeCommand) proxy.getICommand();
		ConnectionAnchor targetAnchor = targetEP
			.getTargetConnectionAnchor(request);
        Iterator commandItr = cc.iterator();
        commandItr.next(); //0
		SetConnectionEndsCommand sceCommand = (SetConnectionEndsCommand) commandItr.next(); //1
		sceCommand.setNewTargetAdaptor(new EObjectAdapter(((IGraphicalEditPart) targetEP).getNotationView()));
		SetConnectionAnchorsCommand scaCommand = (SetConnectionAnchorsCommand) commandItr.next(); //2
		scaCommand.setNewTargetTerminal(targetEP
			.mapConnectionAnchorToTerminal(targetAnchor));
		setViewAdapter(sceCommand.getEdgeAdaptor());
		INodeEditPart sourceEditPart = (INodeEditPart) request
			.getSourceEditPart();
		ConnectionAnchor sourceAnchor = sourceEditPart
			.mapTerminalToConnectionAnchor(scaCommand.getNewSourceTerminal());
		PointList pointList = new PointList();
		if (request.getLocation() == null) {
			pointList.addPoint(sourceAnchor.getLocation(targetAnchor.getReferencePoint()));
			pointList.addPoint(targetAnchor.getLocation(sourceAnchor.getReferencePoint()));			
		}
		else {
			pointList.addPoint(sourceAnchor.getLocation(request.getLocation()));
			pointList.addPoint(targetAnchor.getLocation(request.getLocation()));
		}
		SetConnectionBendpointsCommand sbbCommand = (SetConnectionBendpointsCommand) commandItr.next(); //3
		sbbCommand.setNewPointList(pointList, sourceAnchor.getReferencePoint(),
			targetAnchor.getReferencePoint());
		return request.getStartCommand();
	}
	
	/**
	 * Cache the view descriptor describing the connection to be create.
	 * 
	 * @@param viewAdapter
	 */
	protected final void setViewAdapter(IAdaptable viewAdapter) {
		_viewAdapter = viewAdapter;
	}
	
	/**
	 * Return the view adapter describing the element to be created.
	 * @@see #setViewAdapter(IAdaptable)
	 * @@return adpater that can adapt <code>View.class</code>
	 */
	protected final IAdaptable getViewAdapter() {
		return _viewAdapter;
	}
	protected Command getConnectionCreateCommand(CreateConnectionRequest request) {
		if (!(request instanceof CreateConnectionViewRequest))
			return null;
		CreateConnectionViewRequest req = (CreateConnectionViewRequest) request;
		CompositeCommand cc = new CompositeCommand(
			DiagramUIMessages.Commands_CreateCommand_Connection_Label);
		Diagram diagramView = ((View)getHost().getModel())
				.getDiagram();
        TransactionalEditingDomain editingDomain = getEditingDomain();
        CreateCommand createCommand = new CreateCommand(editingDomain, req
				.getConnectionViewDescriptor(), diagramView.getDiagram());
		setViewAdapter((IAdaptable) createCommand.getCommandResult()
				.getReturnValue());
        
        
        SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, StringStatics.BLANK);
		sceCommand.setEdgeAdaptor(getViewAdapter());
		sceCommand.setNewSourceAdaptor(new EObjectAdapter(getView()));
		ConnectionAnchor sourceAnchor = getConnectableEditPart()
				.getSourceConnectionAnchor(request);
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, StringStatics.BLANK);
		scaCommand.setEdgeAdaptor(getViewAdapter());
		scaCommand.setNewSourceTerminal(getConnectableEditPart()
				.mapConnectionAnchorToTerminal(sourceAnchor));
		SetConnectionBendpointsCommand sbbCommand = new SetConnectionBendpointsCommand(editingDomain);
		sbbCommand.setEdgeAdapter(getViewAdapter());
		cc.compose(createCommand);
		cc.compose(sceCommand);
		cc.compose(scaCommand);
		cc.compose(sbbCommand);
		Command c = new ICommandProxy(cc);
		request.setStartCommand(c);
		return c;
	}
	
	public Command getCommand(Request request) {
		if (RequestConstants.REQ_CONNECTION_START.equals(request.getType())) {
			if (request instanceof CreateConnectionViewAndElementRequest) {
				return getConnectionAndRelationshipCreateCommand((CreateConnectionViewAndElementRequest) request);
			} else if (request instanceof CreateUnspecifiedTypeConnectionRequest) {
				return getUnspecifiedConnectionCreateCommand((CreateUnspecifiedTypeConnectionRequest) request);
			}
		} else if (RequestConstants.REQ_CONNECTION_END
			.equals(request.getType())) {
			if (request instanceof CreateConnectionViewAndElementRequest) {
				return getConnectionAndRelationshipCompleteCommand((CreateConnectionViewAndElementRequest) request);
			} else if (request instanceof CreateUnspecifiedTypeConnectionRequest) {
				return getUnspecifiedConnectionCompleteCommand((CreateUnspecifiedTypeConnectionRequest) request);
			}
		}
		return super.getCommand(request);
	}
	
	/**
	 * Gets the command to start the creation of a new connection and
	 * relationship. This will update the request appropriately.
	 * 
	 * @@param request
	 * @@return Command
	 */
	protected Command getConnectionAndRelationshipCreateCommand(
			CreateConnectionViewAndElementRequest request) {
		// get the element descriptor
		CreateElementRequestAdapter requestAdapter = request
				.getConnectionViewAndElementDescriptor().getCreateElementRequestAdapter();
		// get the semantic request
		CreateRelationshipRequest createElementRequest = (CreateRelationshipRequest) requestAdapter
				.getAdapter(CreateRelationshipRequest.class);
		// complete the semantic request by filling in the source
		View sourceView = (View)getHost().getModel();
		createElementRequest.setSource(ViewUtil.resolveSemanticElement(sourceView));
		// get the create element request based on the elementdescriptor's
		// request
		Command createElementCommand = getHost().getCommand(
			new EditCommandRequestWrapper(
						(CreateRelationshipRequest) requestAdapter
								.getAdapter(CreateRelationshipRequest.class), request.getExtendedData()));
		// if element cannot be created, ignore
		if (createElementCommand == null || !createElementCommand.canExecute())
			return null;


		return getConnectionCreateCommand(request);
	}
	
	/**
	 * Gets the command to start the creation of a new connection and
	 * relationship (if applicable) for a unspecified type request. This will
	 * update all the individual requests appropriately.
	 * 
	 * @@param request
	 *            the unspecified type request
	 * @@return the command
	 */
	private Command getUnspecifiedConnectionCreateCommand(
			final CreateUnspecifiedTypeConnectionRequest request) {

		if (request.isDirectionReversed()) {
			return new Command() {

				/**
				 * All we know is the target and the possible relationship
				 * types. At this point, there is no way to validate the
				 * commands for this scenario.
				 */
				public boolean canExecute() {
					return true;
				}
			};
		} else {

			// Get the start command for each individual request, this will
			// update each request as required.
			final List commands = new ArrayList();
			for (Iterator iter = request.getAllRequests().iterator(); iter
				.hasNext();) {
				Request individualRequest = (Request) iter.next();
				Command cmd = null;
				if (individualRequest instanceof CreateConnectionViewAndElementRequest) {
					cmd = getConnectionAndRelationshipCreateCommand((CreateConnectionViewAndElementRequest) individualRequest);
				} else if (individualRequest instanceof CreateConnectionViewRequest) {
					cmd = getConnectionCreateCommand((CreateConnectionViewRequest) individualRequest);
				}
				if (cmd != null && cmd.canExecute()) {
					commands.add(cmd);
				}
			}

			if (commands.isEmpty()) {
				// GEF's AbstractConnectionCreationTool expects a null command
				// when the gesture should be disabled.
				return null;
			}
			
			// return an executable command that does nothing
			return new Command() {/* do nothing*/};
		}
	}	
	
	/**
	 * Gets the command to complete the creation of a new connection and
	 * relationship.
	 * 
	 * @@param request
	 * @@return Command
	 */
	protected Command getConnectionAndRelationshipCompleteCommand(
			CreateConnectionViewAndElementRequest request) {
		// get the element descriptor
		CreateElementRequestAdapter requestAdapter = request
				.getConnectionViewAndElementDescriptor().getCreateElementRequestAdapter();
		// get the semantic request
		CreateRelationshipRequest createElementRequest = (CreateRelationshipRequest) requestAdapter
				.getAdapter(CreateRelationshipRequest.class);
		
		createElementRequest.setPrompt(!request.isUISupressed());
		
		// complete the semantic request by filling in the source and
		// destination
		INodeEditPart targetEP = getConnectionCompleteEditPart(request);
		View sourceView = (View)request.getSourceEditPart().getModel();
		View targetView = (View)targetEP.getModel();
		
		// resolve the source
		EObject source = ViewUtil.resolveSemanticElement(sourceView);
		if (source == null) {
			source = sourceView;
		}
		createElementRequest.setSource(source);
		
		// resolve the target
		EObject target = ViewUtil.resolveSemanticElement(targetView);
		if (target == null) {
			target = targetView;
		}
		createElementRequest.setTarget(target);
		
		// get the create element request based on the elementdescriptor's
		// request
		Command createElementCommand = targetEP
				.getCommand(new EditCommandRequestWrapper(
						(CreateRelationshipRequest) requestAdapter
								.getAdapter(CreateRelationshipRequest.class), request.getExtendedData()));
		
		// create the create semantic element wrapper command
		if (null == createElementCommand)
			return null;
		
		SemanticCreateCommand semanticCommand = new SemanticCreateCommand(
			requestAdapter, createElementCommand);
		// get the view command
		Command viewCommand = getConnectionCompleteCommand(request);
		if (null == viewCommand)
			return null;
		// form the compound command and return
		CompositeCommand cc = new CompositeCommand(semanticCommand.getLabel());
		cc.compose( semanticCommand );
		cc.compose( new CommandProxy(viewCommand) );
		return new ICommandProxy(cc);
	}

	/**
	 * Gets the command to complete the creation of a new connection and
	 * relationship (if applicable) for an unspecified type request. This command
	 * includes a command to popup a menu to prompt the user for the type of
	 * connection to be created.
	 * 
	 * @@param request
	 *            the unspecified type request
	 * @@return the command
	 */
	protected Command getUnspecifiedConnectionCompleteCommand(
			CreateUnspecifiedTypeConnectionRequest request) {

		if (request.isDirectionReversed()) {
			return getReversedUnspecifiedConnectionCompleteCommand(request);
		}

		List menuContent = getConnectionMenuContent(request);

		if (menuContent.isEmpty()) {
			return null;
		} else if (menuContent.size() == 1) {
			return getConnectionCompleteCommand(menuContent.get(0), request);
		} else {
			return new ICommandProxy(getPromptAndCreateConnectionCommand(
				menuContent, request));
		}
	}

	/**
	 * Gets a command that pops up a menu which allows the user to select which
	 * type of connection to be created and then creates the connection.
	 * 
	 * @@param content
	 *            The list of items making up the content of the popup menu.
	 * @@param request
	 *            The relevant create connection request.
	 * @@return the command to popup up the menu and create the connection
	 */
	protected ICommand getPromptAndCreateConnectionCommand(List content,
			CreateConnectionRequest request) {
		return new PromptAndCreateConnectionCommand(content, request);
	}
	
	/**
	 * Gets the command to create a connection based on the request and the
	 * connection identifier. This method is called after the user has selected
	 * the connection to be created when presented with a popup.
	 * @@see #getPromptAndCreateConnectionCommand(List, CreateConnectionRequest)
	 * 
	 * @@param connectionType
	 *            the connection type as specified in
	 *            {@@link #getConnectionMenuContent(CreateConnectionRequest)}
	 * @@param request
	 *            the request, identifying the source and target
	 * @@return the command to create the connection
	 */
	protected Command getConnectionCompleteCommand(Object connectionType,
			CreateConnectionRequest request) {
		if (connectionType instanceof IElementType) {
			if (request instanceof CreateUnspecifiedTypeConnectionRequest) {
				CreateRequest createRequest = ((CreateUnspecifiedTypeConnectionRequest) request)
						.getRequestForType((IElementType) connectionType);
				if (createRequest != null) {
					return getHost().getCommand(createRequest);
				}
			}
		}
		return null;
	}

	/**
	 * Gets a list of all the connector items that will represent the connector
	 * choices and will appear in the popup menu. This method will get the
	 * connector content if the given request is a
	 * <code>CreateUnspecifiedTypeConnectionRequest</code> using the types it
	 * holds or the types retrieved from the Modeling Assistant Service.
	 * 
	 * <p>
	 * If a subclass wishes to provide additional element types they should
	 * consider providing these in a Modeling Assistant Provider. If a subclass
	 * wishes to provide connector choices that are not elements types they may
	 * provide them here, in this case, the label provider for
	 * {@@link PromptAndCreateConnectionCommand} may need to customized.
	 * </p>
	 * 
	 * @@return the list of connector items to appear in the popup menu
	 */
	protected List getConnectionMenuContent(CreateConnectionRequest request) {
        List validRelTypes = new ArrayList();
        if (request instanceof CreateUnspecifiedTypeConnectionRequest) {
            CreateUnspecifiedTypeConnectionRequest unspecifiedRequest = (CreateUnspecifiedTypeConnectionRequest) request;
            List allRequests = unspecifiedRequest.getAllRequests();
            if (allRequests.isEmpty()) {
                return null;
            }
            IGraphicalEditPart sourceEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
                .get(0)).getSourceEditPart();
            IGraphicalEditPart targetEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
                .get(0)).getTargetEditPart();

            List allRelTypes = unspecifiedRequest.useModelingAssistantService() ? ModelingAssistantService
                .getInstance().getRelTypesOnSourceAndTarget(sourceEP, targetEP)
                : unspecifiedRequest.getElementTypes();

            for (Iterator iter = allRelTypes.iterator(); iter.hasNext();) {
                IElementType type = (IElementType) iter.next();

                Command individualCmd = null;

                Request createConnectionRequest = unspecifiedRequest
                    .getRequestForType(type);
                if (createConnectionRequest != null) {
                    individualCmd = getHost().getCommand(
                        createConnectionRequest);
                    
                    if (individualCmd != null && individualCmd.canExecute()) {
                        validRelTypes.add(type);
                    }
                } else {
                    // This type may not have been given when the connection
                    // creation occurred. In this case, use the deferred
                    // connection creation mechanism.

                    // First, setup the request to initialize the connection
                    // start command.
                    CreateConnectionViewRequest connectionRequest = CreateViewRequestFactory
                        .getCreateConnectionRequest(type,
                            ((IGraphicalEditPart) getHost())
                                .getDiagramPreferencesHint());
                    connectionRequest.setSourceEditPart(null);
                    connectionRequest.setTargetEditPart(sourceEP);
                    connectionRequest
                        .setType(RequestConstants.REQ_CONNECTION_START);
                    sourceEP.getCommand(connectionRequest);

                    // Now, setup the request in preparation to get the
                    // connection end
                    // command.
                    connectionRequest.setSourceEditPart(sourceEP);
                    connectionRequest.setTargetEditPart(targetEP);
                    connectionRequest
                        .setType(RequestConstants.REQ_CONNECTION_END);
                    individualCmd = targetEP.getCommand(connectionRequest);                   

                    if (individualCmd != null && individualCmd.canExecute()) {
                        validRelTypes.add(type);
                        unspecifiedRequest.addRequest(type, connectionRequest);
                    }
                }
            }

        }
        return validRelTypes;
    }
				
	/**
	 * Gets the command to complete the creation of a new connection and
	 * relationship (if applicable) for an unspecified type request. This command
	 * includes a command to popup a menu to prompt the user for the type of
	 * relationship to be created.
	 * 
	 * @@param request
	 *            the reversed unspecified type request
	 * @@return the command
	 */
	protected Command getReversedUnspecifiedConnectionCompleteCommand(
			CreateUnspecifiedTypeConnectionRequest request) {
		EditPart realSourceEP = request.getTargetEditPart();
		EditPart realTargetEP = request.getSourceEditPart();
		for (Iterator iter = request.getAllRequests().iterator(); iter
			.hasNext();) {
			CreateConnectionRequest connectionRequest = (CreateConnectionRequest) iter
				.next();

			// First, setup the request to initialize the connection start
			// command.
			connectionRequest.setSourceEditPart(null);
			connectionRequest.setTargetEditPart(realSourceEP);
			connectionRequest.setType(RequestConstants.REQ_CONNECTION_START);
			realSourceEP.getCommand(connectionRequest);

			// Now, setup the request in preparation to get the connection end
			// command.
			connectionRequest.setSourceEditPart(realSourceEP);
			connectionRequest.setTargetEditPart(realTargetEP);
			connectionRequest.setType(RequestConstants.REQ_CONNECTION_END);
		}

		// The requests are now ready to be sent to get the connection end
		// command from real source to real target.
		request.setDirectionReversed(false);
		Command command = realTargetEP.getCommand(request);
		return command;
	}

    private TransactionalEditingDomain getEditingDomain() {
        return ((IGraphicalEditPart) getHost()).getEditingDomain();
}
}
@


1.22
log
@[224706] gmf-head ahunter 080328 IUndoableOperation changes in the platform cause AssertionFailedException
@
text
@d413 1
a413 1
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, "");
d417 1
a417 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, "");
d471 1
a471 1
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, "");
d476 1
a476 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, "");
d570 1
a570 1
        SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, "");
d575 1
a575 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, "");
@


1.21
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d19 1
a78 1
import org.eclipse.jface.util.Assert;
d413 1
a413 1
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, null);
d417 1
a417 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, null);
d471 1
a471 1
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, null);
d476 1
a476 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, null);
d570 1
a570 1
        SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(editingDomain, null);
d575 1
a575 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(editingDomain, null);
@


1.20
log
@[139856] gmf_head anthonyh 060614 EtoolsProxyCommand should be renamed to ICommandProxy
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
d23 2
d32 1
d66 1
d153 3
a155 2
			Command cmd = getConnectionCompleteCommand(
				cmdResult.getReturnValue(), getRequest());
d159 9
a167 2

			return CommandResult.newOKCommandResult();
d202 40
d326 1
a326 1
			hint = PackageUtil.getDisplayName(createElementRequest.getElementType().getEClass());
d678 1
a678 1
				if (cmd != null) {
d683 8
a690 16
			return new Command() {

				/**
				 * If at least one of the relationship types is supported, then
				 * this is supported.
				 */
				public boolean canExecute() {
					for (Iterator iter = commands.iterator(); iter.hasNext();) {
						Command cmd = (Command) iter.next();
						if (cmd.canExecute()) {
							return true;
						}
					}
					return false;
				}
			};
d845 66
a910 61
		List validRelTypes = new ArrayList();
		if (request instanceof CreateUnspecifiedTypeConnectionRequest) {
			CreateUnspecifiedTypeConnectionRequest unspecifiedRequest = (CreateUnspecifiedTypeConnectionRequest) request;
			List allRequests = unspecifiedRequest.getAllRequests();
		if (allRequests.isEmpty()) {
			return null;
		}
		IGraphicalEditPart sourceEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
			.get(0)).getSourceEditPart();
		IGraphicalEditPart targetEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
			.get(0)).getTargetEditPart();

			List allRelTypes = unspecifiedRequest.useModelingAssistantService() ? ModelingAssistantService
			.getInstance().getRelTypesOnSourceAndTarget(sourceEP, targetEP)
				: unspecifiedRequest.getElementTypes();

			for (Iterator iter = allRelTypes.iterator(); iter.hasNext();) {
			IElementType type = (IElementType) iter.next();

				Command individualCmd = null;

				Request createConnectionRequest = unspecifiedRequest
				.getRequestForType(type);
			if (createConnectionRequest != null) {
					individualCmd = getHost().getCommand(
					createConnectionRequest);
		} else {
					// This type may not have been given when the connection
					// creation occurred. In this case, use the deferred
					// connection creation mechanism.
				
					// First, setup the request to initialize the connection
					// start command.
					CreateConnectionViewRequest connectionRequest = CreateViewRequestFactory
						.getCreateConnectionRequest(type,
							((IGraphicalEditPart) getHost())
								.getDiagramPreferencesHint());
					connectionRequest.setSourceEditPart(null);
					connectionRequest.setTargetEditPart(sourceEP);
					connectionRequest
						.setType(RequestConstants.REQ_CONNECTION_START);
					sourceEP.getCommand(connectionRequest);

					// Now, setup the request in preparation to get the
					// connection end
					// command.
					connectionRequest.setSourceEditPart(sourceEP);
					connectionRequest.setTargetEditPart(targetEP);
					connectionRequest
						.setType(RequestConstants.REQ_CONNECTION_END);
					individualCmd = targetEP.getCommand(connectionRequest);
					}

				if (individualCmd != null && individualCmd.canExecute()) {
					validRelTypes.add(type);
				}
					}
				
					}
		return validRelTypes;
				}
d914 1
a914 1
	 * relationship (if applicable) for a unspecified type request. This command
@


1.20.2.1
log
@Bugzilla#148076 gmf_R1_0_maintenance cmahoney 060706 Creation using multi-tool does not go into direct edit mode
@
text
@d149 2
a150 3
            Object connectionType = cmdResult.getReturnValue();

            Command cmd = getConnectionCompleteCommand(connectionType, getRequest());
d154 2
a155 9
            
            if (connectionType instanceof IElementType) {
                CreateRequest createRequest = ((CreateUnspecifiedTypeConnectionRequest) request)
                    .getRequestForType((IElementType) connectionType);
                Object newObject = createRequest.getNewObject();

                return CommandResult.newOKCommandResult(newObject);
            }
            return CommandResult.newOKCommandResult();
@


1.20.2.2
log
@[136875] gmf_R1_0_maintenance ldamus 060707 [TaiPan] It should not be possible to start route link from ship node
@
text
@d634 1
a634 1
				if (cmd != null && cmd.canExecute()) {
d639 16
a654 8
			if (commands.isEmpty()) {
				// GEF's AbstractConnectionCreationTool expects a null command
				// when the gesture should be disabled.
				return null;
			}
			
			// return an executable command that does nothing
			return new Command() {};
@


1.20.2.3
log
@[110316] gmf_R1_0_maintenance mmostafa  060713 Compiler warning count should be 0 - runtime diagram layer components
@
text
@d646 1
a646 1
			return new Command() {/* do nothing*/};
@


1.20.2.4
log
@bugzilla 145336 gmf_R1_0_maintenance sshaw 060713 Creating connections with Rectilinear routing doesn't respect initial anchor feedback
@
text
@a22 2
import org.eclipse.draw2d.ConnectionLayer;
import org.eclipse.draw2d.ConnectionRouter;
a29 1
import org.eclipse.gef.LayerConstants;
a62 1
import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.ConnectionLayerEx;
a197 40
	
	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.gef.editpolicies.GraphicalNodeEditPolicy#getDummyConnectionRouter(org.eclipse.gef.requests.CreateConnectionRequest)
	 */
	protected ConnectionRouter getDummyConnectionRouter(CreateConnectionRequest arg0) {
		EditPart ep = getHost();
		if (ep instanceof IGraphicalEditPart) {
			IGraphicalEditPart gep = ((IGraphicalEditPart)ep);
			Routing routingVal = Routing.MANUAL_LITERAL;
			if (gep.getNotationView() != null) {
				Diagram dgrm = gep.getNotationView().getDiagram();
				EditPart epfromReg = (EditPart)gep.getViewer().getEditPartRegistry().get(dgrm);
				if (epfromReg != null)
					routingVal = (Routing)epfromReg.getAdapter(Routing.class);
			}
			else {
				IPreferenceStore store = (IPreferenceStore) ((IGraphicalEditPart)ep).getDiagramPreferencesHint().getPreferenceStore();
				routingVal = Routing.get(store.getInt(IPreferenceConstants.PREF_LINE_STYLE));
			}
			
			ConnectionLayer cLayer = (ConnectionLayer) getLayer(LayerConstants.CONNECTION_LAYER);
			if (cLayer instanceof ConnectionLayerEx) {
				ConnectionLayerEx cLayerEx = (ConnectionLayerEx)cLayer;
				if (routingVal == Routing.MANUAL_LITERAL) {
					return cLayerEx.getObliqueRouter();
				}
				else if (routingVal == Routing.RECTILINEAR_LITERAL) {
					return cLayerEx.getRectilinearRouter();
				}
				else if (routingVal == Routing.TREE_LITERAL) {
					return cLayerEx.getTreeRouter();
				}
			}
		}
		
		return super.getDummyConnectionRouter(arg0);
	}


@


1.20.2.5
log
@Bugzilla#155584 gmf_R1_0_maintenance cmahoney 060831 Incorrect Modeling Assistant Provider values shouldn't cause exceptions
@
text
@d845 61
a905 66
        List validRelTypes = new ArrayList();
        if (request instanceof CreateUnspecifiedTypeConnectionRequest) {
            CreateUnspecifiedTypeConnectionRequest unspecifiedRequest = (CreateUnspecifiedTypeConnectionRequest) request;
            List allRequests = unspecifiedRequest.getAllRequests();
            if (allRequests.isEmpty()) {
                return null;
            }
            IGraphicalEditPart sourceEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
                .get(0)).getSourceEditPart();
            IGraphicalEditPart targetEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
                .get(0)).getTargetEditPart();

            List allRelTypes = unspecifiedRequest.useModelingAssistantService() ? ModelingAssistantService
                .getInstance().getRelTypesOnSourceAndTarget(sourceEP, targetEP)
                : unspecifiedRequest.getElementTypes();

            for (Iterator iter = allRelTypes.iterator(); iter.hasNext();) {
                IElementType type = (IElementType) iter.next();

                Command individualCmd = null;

                Request createConnectionRequest = unspecifiedRequest
                    .getRequestForType(type);
                if (createConnectionRequest != null) {
                    individualCmd = getHost().getCommand(
                        createConnectionRequest);
                    
                    if (individualCmd != null && individualCmd.canExecute()) {
                        validRelTypes.add(type);
                    }
                } else {
                    // This type may not have been given when the connection
                    // creation occurred. In this case, use the deferred
                    // connection creation mechanism.

                    // First, setup the request to initialize the connection
                    // start command.
                    CreateConnectionViewRequest connectionRequest = CreateViewRequestFactory
                        .getCreateConnectionRequest(type,
                            ((IGraphicalEditPart) getHost())
                                .getDiagramPreferencesHint());
                    connectionRequest.setSourceEditPart(null);
                    connectionRequest.setTargetEditPart(sourceEP);
                    connectionRequest
                        .setType(RequestConstants.REQ_CONNECTION_START);
                    sourceEP.getCommand(connectionRequest);

                    // Now, setup the request in preparation to get the
                    // connection end
                    // command.
                    connectionRequest.setSourceEditPart(sourceEP);
                    connectionRequest.setTargetEditPart(targetEP);
                    connectionRequest
                        .setType(RequestConstants.REQ_CONNECTION_END);
                    individualCmd = targetEP.getCommand(connectionRequest);                   

                    if (individualCmd != null && individualCmd.canExecute()) {
                        validRelTypes.add(type);
                        unspecifiedRequest.addRequest(type, connectionRequest);
                    }
                }
            }

        }
        return validRelTypes;
    }
d909 1
a909 1
	 * relationship (if applicable) for an unspecified type request. This command
@


1.20.2.6
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.20.2.7
log
@Bugzilla [158297] gmf_R1_0_maintenance sshaw 060922 GraphicalNodeEditPolicy#getSemanticHint is returning a localized string
@
text
@d326 1
a326 1
			hint = PackageUtil.getID(createElementRequest.getElementType().getEClass());
@


1.19
log
@[143769] gmf_head ldamus 060525  Connection creation supported to notation-only shapes when it shouldn't be
@
text
@d47 1
a47 1
import org.eclipse.gmf.runtime.diagram.ui.commands.EtoolsProxyCommand;
d337 1
a337 1
			Command cmdRouter = new EtoolsProxyCommand(spc);
d374 1
a374 1
		Command cmd = new EtoolsProxyCommand(cc);
d399 1
a399 1
			Command cmdBP = new EtoolsProxyCommand(sbbCommand);
d432 1
a432 1
		return new EtoolsProxyCommand(cc);
d444 1
a444 1
		EtoolsProxyCommand proxy = (EtoolsProxyCommand) request
d533 1
a533 1
		Command c = new EtoolsProxyCommand(cc);
d709 1
a709 1
		return new EtoolsProxyCommand(cc);
d736 1
a736 1
			return new EtoolsProxyCommand(getPromptAndCreateConnectionCommand(
@


1.18
log
@[137749] gmf_head ldamus 060517 Transfer GEF Request's extended data into IEditCommandRequest's parameters
@
text
@d673 15
a687 2
		createElementRequest.setSource(ViewUtil.resolveSemanticElement(sourceView));
		createElementRequest.setTarget(ViewUtil.resolveSemanticElement(targetView));
@


1.17
log
@[140034] gmf_head ldamus 060503 GraphicalNodeEditPolicy#getConnectionCompleteCommand asks for command for null request
@
text
@d579 1
a579 1
								.getAdapter(CreateRelationshipRequest.class)));
d680 1
a680 1
								.getAdapter(CreateRelationshipRequest.class)));
@


1.16
log
@[135584] gmf_head ldamus 060410 Classes and methods required by clients should be made public
@
text
@d33 1
d760 5
a764 3
				return getHost().getCommand(
					((CreateUnspecifiedTypeConnectionRequest) request)
						.getRequestForType((IElementType) connectionType));
@


1.15
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@a52 1
import org.eclipse.gmf.runtime.diagram.ui.internal.requests.CreateViewRequestFactory;
d59 1
@


1.14
log
@[117922] gmf_head ldamus 060216 It should not be possible to start creating connection when semantic command that creates it is not executable
@
text
@d63 1
a63 1
import org.eclipse.gmf.runtime.emf.core.util.MetaModelUtil;
d273 1
a273 1
			hint = MetaModelUtil.getDisplayName(createElementRequest.getElementType().getEClass());
a330 1

d352 1
a352 1
   
d886 1
a886 1
    
d889 1
a889 2
    }

@


1.13
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d43 1
a47 1
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
d581 1
a581 1
		if (createElementCommand == null)
@


1.12
log
@bugzilla 109923 gmf-head mmostafa 060201 Class names contain 'xtools'
@
text
@d18 1
d27 1
d139 5
a143 2
		protected CommandResult doExecute(IProgressMonitor progressMonitor) {
			CommandResult cmdResult = super.doExecute(progressMonitor);
d154 1
a154 1
			return newOKCommandResult();
d157 1
a157 1
		protected CommandResult doUndo() {
d161 1
a161 1
			return super.doUndo();
d164 1
a164 1
		protected CommandResult doRedo() {
d168 1
a168 1
			return super.doRedo();
d331 1
d334 2
a335 1
			ICommand spc = new SetPropertyCommand(connection,
d353 2
d361 1
a361 1
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(null);
d365 1
a365 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(null);
d394 2
a395 1
			SetConnectionBendpointsCommand sbbCommand = new SetConnectionBendpointsCommand();
d416 2
d419 1
a419 1
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(null);
d424 1
a424 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(null);
d459 3
a461 2
		SetConnectionEndsCommand sceCommand = (SetConnectionEndsCommand) cc
			.getCommands().get(1);
d463 1
a463 2
		SetConnectionAnchorsCommand scaCommand = (SetConnectionAnchorsCommand) cc
		.getCommands().get(2);
d480 1
a480 2
		SetConnectionBendpointsCommand sbbCommand = (SetConnectionBendpointsCommand) cc
			.getCommands().get(3);
d511 2
a512 1
		CreateCommand createCommand = new CreateCommand(req
d516 3
a518 1
		SetConnectionEndsCommand sceCommand = new SetConnectionEndsCommand(null);
d523 1
a523 1
		SetConnectionAnchorsCommand scaCommand = new SetConnectionAnchorsCommand(null);
d527 1
a527 1
		SetConnectionBendpointsCommand sbbCommand = new SetConnectionBendpointsCommand();
d887 4
@


1.11
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d45 1
a45 1
import org.eclipse.gmf.runtime.diagram.ui.commands.XtoolsProxyCommand;
d681 1
a681 1
		cc.compose( new XtoolsProxyCommand(viewCommand) );
@


1.10
log
@bugzilla 114746 gmf-head sshaw 051122 heck that GEF command can't be executed by calling it's canExecute() method
@
text
@d52 1
a52 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
a85 1
	
d92 1
a92 2
	private static final String CREATE_CONNECTION_COMMAND_LABEL = DiagramResourceManager.getInstance()
		.getString("GraphicalNodeEditPolicy.createRelationshipCommand.label"); //$NON-NLS-1$
d362 1
a362 1
			DiagramResourceManager.getI18NString("Commands.SetConnectionEndsCommand.Target")); //$NON-NLS-1$
d417 1
a417 1
			DiagramResourceManager.getI18NString("Commands.SetConnectionEndsCommand.Source")); //$NON-NLS-1$
d496 2
a497 2
		CompositeCommand cc = new CompositeCommand(DiagramResourceManager.
			getI18NString("Commands.CreateCommand.Connection.Label")); //$NON-NLS-1$
d776 7
a782 7
			if (allRequests.isEmpty()) {
				return null;
			}
			IGraphicalEditPart sourceEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
				.get(0)).getSourceEditPart();
			IGraphicalEditPart targetEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
				.get(0)).getTargetEditPart();
d785 1
a785 1
				.getInstance().getRelTypesOnSourceAndTarget(sourceEP, targetEP)
d789 1
a789 1
				IElementType type = (IElementType) iter.next();
d794 2
a795 2
					.getRequestForType(type);
				if (createConnectionRequest != null) {
d797 2
a798 2
						createConnectionRequest);
				} else {
d802 1
a802 1

d823 1
a823 1
				}
d828 3
a830 3
			}

		}
d832 2
a833 2
	}
	
@


1.9
log
@Bugzilla#110796 gmf_head cmahoney 051114 GraphicalNodeEditpolicy should be extensible so that non-IElementTypes can be listed in the popups
@
text
@a29 1
import org.eclipse.gef.commands.UnexecutableCommand;
d569 1
a569 2
		if (createElementCommand == null
				|| createElementCommand instanceof UnexecutableCommand)
d671 3
@


1.8
log
@rollback fix
@
text
@a14 1
import java.util.HashMap;
a16 1
import java.util.Map;
a32 4
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.widgets.Display;

d41 1
d52 1
a60 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
a62 1
import org.eclipse.gmf.runtime.emf.ui.services.modelingassistant.ModelingAssistantService;
d65 1
d71 3
d82 1
a82 1
 * @@author mmostafa
d87 1
d97 83
d688 1
a688 1
	 * relationship (if applicable) for a unspecified type request. This command
d690 1
a690 1
	 * relationship to be created.
d703 3
a705 2
		List allRequests = request.getAllRequests();
		if (allRequests.isEmpty()) {
d707 44
d752 2
a753 8
		IGraphicalEditPart sourceEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
			.get(0)).getSourceEditPart();
		IGraphicalEditPart targetEP = (IGraphicalEditPart) ((CreateConnectionRequest) allRequests
			.get(0)).getTargetEditPart();

		List relTypes = request.useModelingAssistantService() ? ModelingAssistantService
			.getInstance().getRelTypesOnSourceAndTarget(sourceEP, targetEP)
			: request.getElementTypes();
d755 18
a772 1
		final Map connectionCmds = new HashMap();
d774 51
a824 7
		for (Iterator iter = relTypes.iterator(); iter.hasNext();) {
			IElementType type = (IElementType) iter.next();
			Request createConnectionRequest = request
				.getRequestForType(type);
			if (createConnectionRequest != null) {
				Command individualCmd = getHost().getCommand(
					createConnectionRequest);
a826 1
					connectionCmds.put(type, individualCmd);
a829 36
		}
		
		if (connectionCmds.isEmpty()) {
			return null;
		} else if (connectionCmds.size() == 1) {
			return (Command) connectionCmds.values().toArray()[0];
		} else {
			CreateOrSelectElementCommand selectAndCreateConnectionCmd = new CreateOrSelectElementCommand(
				CREATE_CONNECTION_COMMAND_LABEL, Display.getCurrent().getActiveShell(), validRelTypes) {
				
				/**
				 * My command to undo/redo.
				 */
				private Command undoCommand;

				/**
				 * Execute the command that prompts the user with the popup
				 * menu, then executes the command prepared for the relationship
				 * type that the user selected.
				 * 
				 * @@see org.eclipse.gmf.runtime.common.core.command.AbstractCommand#doExecute(org.eclipse.core.runtime.IProgressMonitor)
				 */
				protected CommandResult doExecute(
						IProgressMonitor progressMonitor) {
					CommandResult cmdResult = super.doExecute(progressMonitor);
					if (!cmdResult.getStatus().isOK()) {
						return cmdResult;
					}

					IElementType relationshipType = (IElementType) cmdResult
						.getReturnValue();

					Command cmd = (Command) connectionCmds.get(relationshipType);
					Assert.isTrue(cmd != null && cmd.canExecute());
					cmd.execute();
					undoCommand = cmd;
a830 21
					return newOKCommandResult();
				}
				
				protected CommandResult doUndo() {
					if (undoCommand != null) {
						undoCommand.undo();
					}
					return super.doUndo();
				}
				
				protected CommandResult doRedo() {
					if (undoCommand != null) {
						undoCommand.redo();
					}
					return super.doRedo();
				}
				
			};
			

			return new EtoolsProxyCommand(selectAndCreateConnectionCmd);
d832 1
d834 1
a834 1

@


1.7
log
@bugzilla 114746 sshaw 051102 command can't be executed by calling it's canExecute() method

trivial fix as indicated in bugzilla
@
text
@d32 1
d35 4
a46 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d65 1
d68 1
a70 1
import org.eclipse.gmf.runtime.emf.ui.services.modelingassistant.ModelingAssistantService;
a75 3
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.widgets.Display;
d489 1
a489 1
				|| !createElementCommand.canExecute())
@


1.6
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@a31 1
import org.eclipse.gef.commands.UnexecutableCommand;
a33 4
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.widgets.Display;

d42 1
a60 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
a62 1
import org.eclipse.gmf.runtime.emf.ui.services.modelingassistant.ModelingAssistantService;
d65 1
d71 3
d487 1
a487 1
				|| createElementCommand instanceof UnexecutableCommand)
@


1.5
log
@bugzilla 110997 gmf-head sshaw 051003 NPE when re-anchoring a reference connector in a shape comparment
@
text
@d43 2
a44 2
import org.eclipse.gmf.runtime.diagram.core.commands.SetConnectorAnchorsCommand;
import org.eclipse.gmf.runtime.diagram.core.commands.SetConnectorEndsCommand;
a46 1
import org.eclipse.gmf.runtime.diagram.ui.IPreferenceConstants;
d55 1
a55 1
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.SetConnectorBendpointsCommand;
d57 2
a58 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d60 2
a61 2
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateConnectorViewAndElementRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateConnectorViewRequest;
d93 1
a93 1
	 * The label used for the command to create a new connector.
d95 1
a95 1
	private static final String CREATE_CONNECTOR_COMMAND_LABEL = PresentationResourceManager.getInstance()
d180 2
a181 2
		if (request instanceof CreateConnectorViewAndElementRequest) {
			CreateConnectorViewAndElementRequest ccvr = (CreateConnectorViewAndElementRequest) request;
d184 1
a184 1
					.getConnectorViewAndElementDescriptor()
d193 3
a195 3
		} else if (request instanceof CreateConnectorViewRequest) {
			CreateConnectorViewRequest ccvr = (CreateConnectorViewRequest) request;
			hint = ccvr.getConnectorViewDescriptor().getSemanticHint();
d207 2
a208 2
	 * @@param connector
	 *            IAdaptable that is placeholder for not yet created connector.
d211 2
a212 2
	 * @@param connectorHint
	 *            String that is the semantic hint of the connector being
d220 2
a221 2
	protected Command getRoutingAdjustment(IAdaptable connector,
			String connectorHint, Routing currentRouterType, EditPart target) {
d223 1
a223 1
		if (connectorHint == null ||
d231 1
a231 1
				&& connectorHint.equals(targetHint)) {
d249 1
a249 1
			ICommand spc = new SetPropertyCommand(connector,
d273 2
a274 2
		SetConnectorEndsCommand sceCommand = new SetConnectorEndsCommand(null);
		sceCommand.setConnectorAdaptor(new EObjectAdapter((EObject)request
d277 2
a278 2
		SetConnectorAnchorsCommand scaCommand = new SetConnectorAnchorsCommand(null);
		scaCommand.setConnectorAdaptor(new EObjectAdapter((EObject) request
d283 1
a283 1
			PresentationResourceManager.getI18NString("Commands.SetConnectorEndsCommand.Target")); //$NON-NLS-1$
d306 2
a307 2
			SetConnectorBendpointsCommand sbbCommand = new SetConnectorBendpointsCommand();
			sbbCommand.setConnectorAdapter(request.getConnectionEditPart());
d328 2
a329 2
		SetConnectorEndsCommand sceCommand = new SetConnectorEndsCommand(null);
		sceCommand.setConnectorAdaptor(new EObjectAdapter((View) request
d333 2
a334 2
		SetConnectorAnchorsCommand scaCommand = new SetConnectorAnchorsCommand(null);
		scaCommand.setConnectorAdaptor(new EObjectAdapter((View) request
d338 1
a338 1
			PresentationResourceManager.getI18NString("Commands.SetConnectorEndsCommand.Source")); //$NON-NLS-1$
d368 1
a368 1
		SetConnectorEndsCommand sceCommand = (SetConnectorEndsCommand) cc
d371 1
a371 1
		SetConnectorAnchorsCommand scaCommand = (SetConnectorAnchorsCommand) cc
d375 1
a375 1
		setViewAdapter(sceCommand.getConnectorAdaptor());
d389 1
a389 1
		SetConnectorBendpointsCommand sbbCommand = (SetConnectorBendpointsCommand) cc
d397 1
a397 1
	 * Cache the view descriptor describing the connector to be create.
d414 1
a414 1
		if (!(request instanceof CreateConnectorViewRequest))
d416 3
a418 3
		CreateConnectorViewRequest req = (CreateConnectorViewRequest) request;
		CompositeCommand cc = new CompositeCommand(PresentationResourceManager.
			getI18NString("Commands.CreateCommand.Connector.Label")); //$NON-NLS-1$
d422 1
a422 1
				.getConnectorViewDescriptor(), diagramView.getDiagram());
d425 2
a426 2
		SetConnectorEndsCommand sceCommand = new SetConnectorEndsCommand(null);
		sceCommand.setConnectorAdaptor(getViewAdapter());
d430 2
a431 2
		SetConnectorAnchorsCommand scaCommand = new SetConnectorAnchorsCommand(null);
		scaCommand.setConnectorAdaptor(getViewAdapter());
d434 2
a435 2
		SetConnectorBendpointsCommand sbbCommand = new SetConnectorBendpointsCommand();
		sbbCommand.setConnectorAdapter(getViewAdapter());
d447 2
a448 2
			if (request instanceof CreateConnectorViewAndElementRequest) {
				return getConnectionAndRelationshipCreateCommand((CreateConnectorViewAndElementRequest) request);
d454 2
a455 2
			if (request instanceof CreateConnectorViewAndElementRequest) {
				return getConnectionAndRelationshipCompleteCommand((CreateConnectorViewAndElementRequest) request);
d471 1
a471 1
			CreateConnectorViewAndElementRequest request) {
d474 1
a474 1
				.getConnectorViewAndElementDescriptor().getCreateElementRequestAdapter();
d529 4
a532 4
				if (individualRequest instanceof CreateConnectorViewAndElementRequest) {
					cmd = getConnectionAndRelationshipCreateCommand((CreateConnectorViewAndElementRequest) individualRequest);
				} else if (individualRequest instanceof CreateConnectorViewRequest) {
					cmd = getConnectionCreateCommand((CreateConnectorViewRequest) individualRequest);
d566 1
a566 1
			CreateConnectorViewAndElementRequest request) {
d569 1
a569 1
				.getConnectorViewAndElementDescriptor().getCreateElementRequestAdapter();
d634 1
a634 1
		final Map connectorCmds = new HashMap();
d638 1
a638 1
			Request createConnectorRequest = request
d640 1
a640 1
			if (createConnectorRequest != null) {
d642 1
a642 1
					createConnectorRequest);
d645 1
a645 1
					connectorCmds.put(type, individualCmd);
d651 1
a651 1
		if (connectorCmds.isEmpty()) {
d653 2
a654 2
		} else if (connectorCmds.size() == 1) {
			return (Command) connectorCmds.values().toArray()[0];
d656 2
a657 2
			CreateOrSelectElementCommand selectAndCreateConnectorCmd = new CreateOrSelectElementCommand(
				CREATE_CONNECTOR_COMMAND_LABEL, Display.getCurrent().getActiveShell(), validRelTypes) {
d681 1
a681 1
					Command cmd = (Command) connectorCmds.get(relationshipType);
d706 1
a706 1
			return new EtoolsProxyCommand(selectAndCreateConnectorCmd);
d726 1
a726 1
			CreateConnectionRequest connectorRequest = (CreateConnectionRequest) iter
d731 4
a734 4
			connectorRequest.setSourceEditPart(null);
			connectorRequest.setTargetEditPart(realSourceEP);
			connectorRequest.setType(RequestConstants.REQ_CONNECTION_START);
			realSourceEP.getCommand(connectorRequest);
d738 3
a740 3
			connectorRequest.setSourceEditPart(realSourceEP);
			connectorRequest.setTargetEditPart(realTargetEP);
			connectorRequest.setType(RequestConstants.REQ_CONNECTION_END);
@


1.4
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d157 5
a161 1
		return getConnectableEditPart().getTargetConnectionAnchor(request);
d264 4
d299 1
a299 1
			ConnectionAnchor sourceAnchor = getConnectableEditPart()
d323 5
a327 2
		ConnectionAnchor sourceAnchor = getConnectableEditPart()
				.getSourceConnectionAnchor(request);
d331 1
a331 1
		sceCommand.setNewSourceAdaptor(new EObjectAdapter((View)getConnectableEditPart()
d336 1
a336 2
		scaCommand.setNewSourceTerminal(getConnectableEditPart()
				.mapConnectionAnchorToTerminal(sourceAnchor));
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d57 1
a58 1
import org.eclipse.gmf.runtime.diagram.ui.properties.Properties;
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2003.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d69 5
a73 5
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.NotationPackage;
import com.ibm.xtools.notation.Routing;
import com.ibm.xtools.notation.RoutingStyle;
import com.ibm.xtools.notation.View;
@

