head	1.19;
access;
symbols
	v20081023-2107:1.19
	v20081022-1925:1.19
	v20081022-1005:1.19
	v20081020-0700:1.19
	v20080917-1925:1.19
	v20080916-2008:1.19
	v20080911-1728:1.19
	v20080911-1506:1.19
	v20080910-1520:1.19
	v20080910-1510:1.19
	v20080903-1520:1.19
	v20080903-1510:1.19
	v20080813-1510:1.19
	v20080811-1546:1.19
	v20080731-1520:1.19
	v20080725-1738:1.19
	v20080723-2246:1.19
	v20080723-2232:1.19
	v20080723-1700:1.19
	v20080722-1827:1.19
	v20080718-1700:1.19
	v20080718-1731:1.19
	v20080716-1600:1.19
	v20080716-1642:1.19
	R2_1_maintenance:1.19.0.2
	Root_R2_1_maintenance:1.19
	R2_1_0:1.19
	v20080610-1132:1.19
	v20080603-1553:1.18
	v20080527-1255:1.17
	v20080527-1151:1.16
	v20080516-1748:1.17
	v20080516-1143:1.17
	v20080512-1200:1.17
	v20080503-1740:1.17
	v20080501-2127:1.16
	v20080501-1739:1.17
	m20080429-1543:1.16
	v20080425-1959:1.17
	v20080417-1610:1.17
	v20080407-2250:1.17
	v20080407-0930:1.17
	v20080404-1111:1.17
	v20080328-1605:1.17
	v20080322-0000:1.17
	v20080222-1200:1.17
	v20080201-2010:1.17
	v20080201-0201:1.16
	v20080118-1129:1.16
	v20080114-2222:1.16
	v20080114-1111:1.17
	v20080107-1111:1.17
	v20071222-1111:1.17
	v20071214-1111:1.17
	v20071130-1111:1.17
	v20071124-0000:1.16
	v20071112-0000:1.17
	v20071108-0000:1.17
	v20071003-0000:1.16
	v20070915-0000:1.16
	v20070903-0000:1.16
	v20070809-0000:1.16
	R2_0_maintenance:1.16.0.4
	R2_0:1.16
	R4_20:1.16
	v20070621-0000:1.16
	RC3_20:1.16
	v20070614-1400:1.16
	v20070608-1300:1.16
	v20070605-1400:1.16
	v20070601-1400:1.16
	v20070525-1500:1.16
	v20070518-1300:1.16
	bugzilla111892_group_support:1.16.0.2
	Root_bugzilla111892_group_support:1.16
	v20070504-1000:1.16
	v20070420-1000:1.16
	v20070413-1300:1.16
	v20070330-1300:1.16
	v20060330-1300:1.16
	v20070322-1100:1.16
	v20060316-0600:1.16
	v20070221-1500:1.16
	v20070208-1800:1.16
	v20070202-0200:1.13.2.10
	v20070119-1200:1.13.2.10
	v20070111-0800:1.13.2.10
	v20070105-1200:1.13.2.10
	v20070103-0300:1.16
	M4_20:1.16
	v20061218-1500:1.13.2.10
	v20061218-1200:1.16
	v20061214-0000:1.16
	M3_20:1.15
	v20061117-0800:1.15
	v20061027-1200:1.13.2.9
	v20061013-1330:1.15
	v20061012-1100:1.13.2.9
	v20060925-1700:1.13.2.7
	v20060919-0800:1.13.2.7
	v20060907-1100:1.13.2.6
	M1_20:1.13
	v20060831-1500:1.13.2.5
	v20060824-1600:1.13.2.4
	v20060817-1500:1.13.2.3
	v20060810-1700:1.13.2.3
	v20060803-1200:1.13.2.3
	v20060728-0500:1.13.2.2
	v20060721-1130:1.13.2.2
	v20060713-1700:1.13
	R1_0_maintenance:1.13.0.2
	R1_0:1.13
	v20060627-1200:1.13
	v20060616-1400:1.13
	v20060616-1200:1.13
	v20060609-1400:1.12
	v20060531-1730:1.12
	v20060530-1930:1.12
	v20060526-1200:1.12
	v20060519-0800:1.11
	v20060512-1000:1.10
	I20060512-1000:1.10
	I20060505-1400:1.10
	I20060428-1300:1.10
	I20060424-0500:1.10
	I20060424-0300:1.10
	M6_10:1.10
	I20060407-1200:1.9
	I20060331-1000:1.9
	I20060324-0300:1.9
	I20060317-1300:1.9
	I20060317-1200:1.9
	I20060316-1300:1.9
	I20060309-1300:1.9
	M5_10:1.9
	S20060303-1600:1.9
	I20060227-1730:1.9
	I20060216-1945:1.9
	I20060210-1715:1.9
	I20060209-1815:1.9
	I20060203-0830:1.9
	I20060202-1415:1.9
	I20060129-1145:1.9
	I20060127-0900:1.9
	I20060120-1530:1.9
	I20060113-1700:1.9
	M4_10:1.9
	I20060107-1100:1.9
	I20060105-1630:1.9
	I20051230-1230:1.9
	I20051223-1100:1.9
	I20051217-0925:1.9
	I20051208-2000:1.9
	I20051201-1800:1.9
	I20051124-2000:1.8
	M3_10:1.8
	I20051118-1245:1.8
	I20051111-1800:1.8
	I20051106-0900:1.8
	v20051030:1.7;
locks; strict;
comment	@# @;


1.19
date	2008.06.10.15.19.57;	author ahunter;	state Exp;
branches;
next	1.18;
commitid	640e484e9b9d4567;

1.18
date	2008.05.29.19.30.51;	author ahunter;	state Exp;
branches;
next	1.17;
commitid	4092483f046b4567;

1.17
date	2007.10.16.14.11.55;	author crevells;	state Exp;
branches;
next	1.16;
commitid	2b604714c6a84567;

1.16
date	2006.11.29.19.08.50;	author crevells;	state Exp;
branches;
next	1.15;
commitid	5a50456ddac24567;

1.15
date	2006.10.11.18.19.24;	author cmahoney;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.03.15.02.05;	author ahunter;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.15.20.22.44;	author mmostafa;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2006.05.25.18.00.56;	author sshaw;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.15.14.35.02;	author sshaw;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.12.15.54.18;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.25.19.38.13;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.04.21.27.49;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.11.15.31.37;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.04.19.52.43;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.03.14.31.16;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.21.29.08;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.06.20.55.01;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.06.19.06.40;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.45;	author sshaw;	state Exp;
branches;
next	;

1.13.2.1
date	2006.07.13.21.53.22;	author sshaw;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2006.07.14.21.02.16;	author cmahoney;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2006.08.02.22.12.58;	author mmostafa;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2006.08.22.15.12.29;	author mmostafa;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2006.08.30.13.49.15;	author cmahoney;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2006.09.06.18.18.41;	author cmahoney;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2006.09.08.21.07.56;	author cmahoney;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2006.10.05.21.16.42;	author ahunter;	state Exp;
branches;
next	1.13.2.9;

1.13.2.9
date	2006.10.06.16.10.41;	author cmahoney;	state Exp;
branches;
next	1.13.2.10;

1.13.2.10
date	2006.11.29.18.47.16;	author crevells;	state Exp;
branches;
next	;
commitid	78a456dd5b44567;


desc
@@


1.19
log
@[215800] gmf-head ahunter 080610 Deadlock caused by TextDirectEditManager
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 *    Dmitry Stadnik (Borland) - contribution for bugzilla 135694
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.tools;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.runtime.Assert;
import org.eclipse.draw2d.AncestorListener;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.editparts.ZoomManager;
import org.eclipse.gef.tools.CellEditorLocator;
import org.eclipse.gef.tools.DirectEditManager;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.contentassist.ContentAssistantHelper;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ITextAwareEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.label.ILabelDelegate;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel;
import org.eclipse.gmf.runtime.draw2d.ui.figures.WrappingLabel;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.gef.ui.internal.parts.TextCellEditorEx;
import org.eclipse.gmf.runtime.gef.ui.internal.parts.WrapTextCellEditor;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.resource.DeviceResourceException;
import org.eclipse.jface.resource.FontDescriptor;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.resource.ResourceManager;
import org.eclipse.jface.text.contentassist.IContentAssistProcessor;
import org.eclipse.jface.viewers.CellEditor;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Event;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.Text;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.part.CellEditorActionHandler;


/**
 * @@author melaasar
 */
public class TextDirectEditManager
    extends DirectEditManager {

    /**
     * content assist background color
     */
    private Color proposalPopupBackgroundColor = null;

    /**
     * content assist foreground color
     */
    private Color proposalPopupForegroundColor = null;

    private boolean committed = false;

    /**
     * flag used to avoid unhooking listeners twice if the UI thread is blocked
     */
    private boolean listenersAttached = true;

    /** String buffer to hold initial characters * */
    private StringBuffer initialString = new StringBuffer();

    /**
     * Cache the font descriptor when a font is created so that it can be
     * disposed later.
     */
    private List cachedFontDescriptors = new ArrayList();

    private IActionBars actionBars;

    private CellEditorActionHandler actionHandler;

    private IAction copy, cut, paste, undo, redo, find, selectAll, delete;

    private Font zoomLevelFont = null;

    /**
     * The superclass only relocates the cell editor when the location of the
     * editpart's figure moves, but we need to also relocate the cell editor
     * when the text figure's location changes.
     */
    private AncestorListener textFigureListener;

    /**
     * Cache locally so we can check if the user specified an editorType.
     */
    private Class editorType;

    /**
     * constructor
     * 
     * @@param source
     *            <code>GraphicalEditPart</code> to support direct edit of.
     *            The figure of the <code>source</code> edit part must be of
     *            type <code>WrapLabel</code>.
     */
    public TextDirectEditManager(ITextAwareEditPart source) {
        this(source, null,
            getTextCellEditorLocator(source));
    }

    /**
     * @@param source
     * @@param editorType
     * @@param locator
     */
    public TextDirectEditManager(GraphicalEditPart source, Class editorType,
            CellEditorLocator locator) {
        super(source, editorType, locator);
        this.editorType = editorType;
    }

    /**
     * @@param source
     *            the <code>ITextAwareEditPart</code> to determine the cell
     *            editor for
     * @@return the <code>CellEditorLocator</code> that is appropriate for the
     *         source <code>EditPart</code>
     */
    public static CellEditorLocator getTextCellEditorLocator(
            final ITextAwareEditPart source) {

        final ILabelDelegate label = (ILabelDelegate) source
            .getAdapter(ILabelDelegate.class);
        if (label != null) {
            return new CellEditorLocator() {

                public void relocate(CellEditor celleditor) {
                    Text text = (Text) celleditor.getControl();

                    Rectangle rect = label.getTextBounds().getCopy();
                    if (label.getText().length() <= 0) {
                        // if there is no text, let's assume a default size
                        // because it looks silly when the cell editor it tiny.
                        rect.setSize(new Dimension(text.computeSize(
                            SWT.DEFAULT, SWT.DEFAULT)));

                        if (label.isTextWrapOn()) {
                            // adjust the location of the cell editor based on text
                            // justification (i.e. where the cursor will be
                            if (label.getTextJustification() == PositionConstants.RIGHT) {
                                rect.translate(-rect.width, 0);
                            } else 
                                if (label.getTextJustification() == PositionConstants.CENTER) {
                                rect.translate(-rect.width / 2, 0);
                            }
                        }
                    }

                    if (label.isTextWrapOn()) {
                    	if (!text.getFont().isDisposed()) {
                    		// When zoomed in, the height of this rectangle is not
                    		// sufficient because the text is shifted downwards a
                    		// little bit. Add some to the height to compensate for
                    		// this. I'm not sure why this is happening, but I can
                    		// see the text shifting down even in a label on a GEF
                    		// logic diagram when zoomed into 400%.
                    		int charHeight = FigureUtilities.getFontMetrics(
                    				text.getFont()).getHeight();
                    		rect.resize(0, charHeight / 2);
                    	}
                        
                    } else { 
                        
                      rect.setSize(new Dimension(text.computeSize(
                            SWT.DEFAULT, SWT.DEFAULT)));

                        // If SWT.WRAP is not passed in as a style of the
                        // TextCellEditor, then for some reason the first
                        // character disappears upon entering the second 
                        // character. This should be investigated and an 
                        // SWT bug logged.
                        int avr = FigureUtilities
                            .getFontMetrics(text.getFont())
                            .getAverageCharWidth();
                        rect.setSize(new Dimension(text.computeSize(
                            SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));
                    }

                    org.eclipse.swt.graphics.Rectangle newRect = text
                        .computeTrim(rect.x, rect.y, rect.width, rect.height);
                    if (!newRect.equals(text.getBounds())) {
                        text.setBounds(newRect.x, newRect.y, newRect.width,
                            newRect.height);
                    }
                }
            };
        }

        // return a default figure locator
        return new CellEditorLocator() {
            public void relocate(CellEditor celleditor) {
                Text text = (Text) celleditor.getControl();
                Rectangle rect = source.getFigure().getBounds().getCopy();
                source.getFigure().translateToAbsolute(rect);
                if (!rect.equals(new Rectangle(text.getBounds()))) {
                    text.setBounds(rect.x, rect.y, rect.width, rect.height);
                }
            }
        };
    }

    /**
     * @@param source
     *            the <code>GraphicalEditPart</code> that is used to determine
     *            which <code>CellEditor</code> class to use.
     * @@return the <code>Class</code> of the <code>CellEditor</code> to use
     *         for the text editing.
     * @@deprecated to override the cell editor class, use
     *             {@@link #createCellEditorOn(Composite)}, this provides the
     *             flexibility necessary to initialize the cell editor with a
     *             style.
     */
    public static Class getTextCellEditorClass(GraphicalEditPart source) {
        IFigure figure = source.getFigure();
                
        if (figure instanceof WrapLabel && ((WrapLabel) figure).isTextWrapped())
            return WrapTextCellEditor.class;
        
        return TextCellEditorEx.class;
    }

    /**
     * This method is overridden so that the editor class can have a style as
     * the style needs to be passed into the editor class when it is created. It
     * will default to the super behavior if an <code>editorType</code> was
     * passed into the constructor.
     * @@since 2.1
     */
    protected CellEditor createCellEditorOn(Composite composite) {

        // if the client has overridden this class and provided their own editor
        // type, then we should use that
        if (editorType != null) {
            return super.createCellEditorOn(composite);
        }

        ILabelDelegate label = (ILabelDelegate) getEditPart().getAdapter(
            ILabelDelegate.class);
        if (label != null && label.isTextWrapOn()) {
            int style = SWT.WRAP | SWT.MULTI;
            
            switch (label.getTextJustification()) {
                case PositionConstants.LEFT:
                    style = style | SWT.LEAD;
                    break;
                case PositionConstants.RIGHT:
                    style = style | SWT.TRAIL;
                    break;
                case PositionConstants.CENTER:
                    style = style | SWT.CENTER;
                    break;
                default:
                    break;
            }
            return new WrapTextCellEditor(composite, style);
        } else {
            return new TextCellEditorEx(composite);
        }
    }

    /**
     * Given a label figure object, this will calculate the 
     * correct Font needed to display into screen coordinates, taking into 
     * account the current mapmode.  This will typically be used by direct
     * edit cell editors that need to display independent of the zoom or any
     * coordinate mapping that is taking place on the drawing surface.
     * 
     * @@param label the label to use for the font calculation
     * @@return the <code>Font</code> that is scaled to the screen coordinates.
     * Note: the returned <code>Font</code> should not be disposed since it is
     * cached by a common resource manager.
     */
    protected Font getScaledFont(IFigure label) {
        Font scaledFont = label.getFont();
        FontData data = scaledFont.getFontData()[0];
        Dimension fontSize = new Dimension(0, MapModeUtil.getMapMode(label).DPtoLP(data.getHeight()));
        label.translateToAbsolute(fontSize);
        
        if( Math.abs( data.getHeight() - fontSize.height ) < 2 )
            fontSize.height = data.getHeight();

        try {
            FontDescriptor fontDescriptor = FontDescriptor.createFrom(data);
            cachedFontDescriptors.add(fontDescriptor);
            return getResourceManager().createFont(fontDescriptor);
        } catch (DeviceResourceException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "getScaledFont", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "getScaledFont", e); //$NON-NLS-1$
        }
        return JFaceResources.getDefaultFont();
    }

    
    protected void initCellEditor() {
        committed = false;

        // Get the Text Compartments Edit Part
        ITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();

        setEditText(textEP.getEditText());

        IFigure label = textEP.getFigure();
        Assert.isNotNull(label);
        Text text = (Text) getCellEditor().getControl();
        // scale the font accordingly to the zoom level
        text.setFont(getScaledFont(label));
        
        
        // register a validator on the cell editor
        getCellEditor().setValidator(textEP.getEditTextValidator());

        if (textEP.getParser() != null) {
            IContentAssistProcessor processor = textEP.getCompletionProcessor();
            if (processor != null) {
                // register content assist
                proposalPopupBackgroundColor = new Color(getCellEditor()
                    .getControl().getShell().getDisplay(), new RGB(254, 241,
                    233));
                proposalPopupForegroundColor = new Color(getCellEditor()
                    .getControl().getShell().getDisplay(), new RGB(0, 0, 0));

                ContentAssistantHelper.createTextContentAssistant(text,
                    proposalPopupForegroundColor, proposalPopupBackgroundColor,
                    processor);
            }
        }
        
        //Hook the cell editor's copy/paste actions to the actionBars so that they can
        // be invoked via keyboard shortcuts.
        actionBars = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage()
                .getActiveEditor().getEditorSite().getActionBars();
        saveCurrentActions(actionBars);
        actionHandler = new CellEditorActionHandler(actionBars);
        actionHandler.addCellEditor(getCellEditor());
        actionBars.updateActionBars();
    }

    /**
     * @@see org.eclipse.gef.tools.DirectEditManager#commit()
     */
    protected void commit() {
        Shell activeShell = Display.getCurrent().getActiveShell();
        if (activeShell != null
            && getCellEditor().getControl().getShell().equals(
                activeShell.getParent())) {
            Control[] children = activeShell.getChildren();
            if (children.length == 1 && children[0] instanceof Table) {
                /*
                 * CONTENT ASSIST: focus is lost to the content assist pop up -
                 * stay in focus
                 */
                getCellEditor().getControl().setVisible(true);
                ((TextCellEditorEx) getCellEditor()).setDeactivationLock(true);
                return;
            }
        }

        // content assist hacks
        if (committed) {
            bringDown();
            return;
        }
        committed = true;
        super.commit();
    }

    /**
     * @@see org.eclipse.gef.tools.DirectEditManager#bringDown()
     */
    protected void bringDown() {
        if (proposalPopupForegroundColor != null) {
            proposalPopupForegroundColor.dispose();
            proposalPopupForegroundColor = null;
        }
        if (proposalPopupBackgroundColor != null) {
            proposalPopupBackgroundColor.dispose();
            proposalPopupBackgroundColor = null;
        }

        // myee - RATLC00523014: crashes when queued in asyncExec()
        eraseFeedback();
        
        initialString = new StringBuffer();
        
        Display.getCurrent().asyncExec(new Runnable() {

            public void run() {
                // Content Assist hack - allow proper cleanup on childen
                // controls
                TextDirectEditManager.super.bringDown();
            }
        });
        
        for (Iterator iter = cachedFontDescriptors.iterator(); iter.hasNext();) {
            getResourceManager().destroyFont((FontDescriptor) iter.next());           
        }
        cachedFontDescriptors.clear();
        
        if (actionHandler != null) {
            actionHandler.dispose();
            actionHandler = null;
        }
        if (actionBars != null) {
            restoreSavedActions(actionBars);
            actionBars.updateActionBars();
            actionBars = null;
        }
    }

    /**
     * This method is used to set the cell editors text
     * 
     * @@param toEdit
     *            String to be set in the cell editor
     */
    public void setEditText(String toEdit) {

        // Get the cell editor
        CellEditor cellEditor = getCellEditor();

        // IF the cell editor doesn't exist yet...
        if (cellEditor == null) {
            // Do nothing
            return;
        }

        // Get the Text Compartment Edit Part
        ITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();

        // Get the Text control
        Text textControl = (Text) cellEditor.getControl();

        // Set the Figures text
        textEP.setLabelText(toEdit);
        
        
        // See RATLC00522324
        if (cellEditor instanceof TextCellEditorEx){
            ((TextCellEditorEx)cellEditor).setValueAndProcessEditOccured(toEdit);
        } else {
            cellEditor.setValue(toEdit);
        }
        
        // Set the controls text and position the caret at the end of the text
        textControl.setSelection(toEdit.length());
    }

    /**
     * Performs show and sets the edit string to be the initial character or string
     * @@param initialChar
     */
    public void show(char initialChar) {
        initialString = initialString.append(initialChar);
        show();
        if (SWT.getPlatform() != "carbon") { //$NON-NLS-1$ 
            // Set the cell editor text to the initial character
            setEditText(initialString.toString());
        }
    }
    
    /**
     * This method obtains the fonts that are being used by the figure at its zoom level.
     * @@param gep the associated <code>GraphicalEditPart</code> of the figure
     * @@param actualFont font being used by the figure
     * @@param display
     * @@return <code>actualFont</code> if zoom level is 1.0 (or when there's an error),
     * new Font otherwise.
     */
    private Font getZoomLevelFont(Font actualFont, Display display) {
        Object zoom = getEditPart().getViewer().getProperty(ZoomManager.class.toString());
        
        if (zoom != null) {
            double zoomLevel = ((ZoomManager)zoom).getZoom();
            
            if (zoomLevel == 1.0f) 
                return actualFont;
            
            FontData[] fd = new FontData[actualFont.getFontData().length];
            FontData tempFD = null;
            
            for (int i=0; i < fd.length; i++) {
                tempFD = actualFont.getFontData()[i];
                
                fd[i] = new FontData(tempFD.getName(),(int)(zoomLevel * tempFD.getHeight()),tempFD.getStyle());
            }
            
            try {
                FontDescriptor fontDescriptor = FontDescriptor.createFrom(fd);
                cachedFontDescriptors.add(fontDescriptor);
                return getResourceManager().createFont(fontDescriptor);
            } catch (DeviceResourceException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "getZoomLevelFonts", e); //$NON-NLS-1$
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "getZoomLevelFonts", e); //$NON-NLS-1$
                
                return actualFont;
            }
        }
        else
            return actualFont;
    }

    public void show() {
        super.show();

        IFigure fig = getEditPart().getFigure();

        Control control = getCellEditor().getControl();
        this.zoomLevelFont = getZoomLevelFont(fig.getFont(), control.getDisplay());

        control.setFont(this.zoomLevelFont);

        //since the font's have been resized, we need to resize the  Text control...
        getLocator().relocate(getCellEditor());

    }
    
    /**
     * 
     * Performs show and sends an extra mouse click to the point location so
     * that cursor appears at the mouse click point
     * 
     * The Text control does not allow for the cursor to appear at point location but
     * at a character location
     * 
     * @@param location
     */
    public void show(Point location) {      
        show();
        sendClickToCellEditor(location);
    }

    private void sendClickToCellEditor(final Point location) {
        //make sure the diagram doesn't receive the click event..
        getCellEditor().getControl().setCapture(true);
        
        if (getCellEditor() != null && getCellEditor().getControl().getBounds().contains(location))
            sendMouseClick(location);
    }

    
    /**
     * 
     * Sends a SWT MouseUp and MouseDown event to the point location 
     * to the current Display
     * 
     * @@param location
     */
    private void sendMouseClick(final Point location) {     
        
        final Display currDisplay = Display.getCurrent();
        currDisplay.asyncExec(new Runnable() {
	        public void run() {
	         Event event;
                event = new Event();
                event.type = SWT.MouseDown;
                event.button = 1;
                event.x = location.x;
                event.y = location.y;
                currDisplay.post(event);
                event.type = SWT.MouseUp;
                currDisplay.post(event);
	        }
	    });
    }

    protected void hookListeners() {
        super.hookListeners();

        // TODO: This gets around the problem of the cell editor not growing big
        // enough when in autosize mode because it doesn't listen to textflow
        // size changes. The superclass should be modified to not assume we want
        // to listen to the editpart's figure.
        ILabelDelegate label = (ILabelDelegate) getEditPart().getAdapter(
            ILabelDelegate.class);
        if (label != null && getEditPart().getFigure() instanceof WrappingLabel) {

            textFigureListener = new AncestorListener.Stub() {

                public void ancestorMoved(IFigure ancestor) {
                    getLocator().relocate(getCellEditor());
                }
            };
            ((IFigure) ((WrappingLabel) getEditPart().getFigure())
                .getTextFigure().getChildren().get(0))
                .addAncestorListener(textFigureListener);
        }
    }

    /*
     * Overrides super unhookListeners to set listeners attached flag This
     * method prevents unhooking listeners twice if the UI thread is blocked.
     * For example, a validation dialog may block the thread
     */
    protected void unhookListeners() {
        if (listenersAttached) {
            listenersAttached = false;
            super.unhookListeners();

            ILabelDelegate label = (ILabelDelegate) getEditPart().getAdapter(
                ILabelDelegate.class);
            if (label != null && textFigureListener != null) {
                ((IFigure) ((WrappingLabel) getEditPart().getFigure())
                    .getTextFigure().getChildren().get(0))
                    .removeAncestorListener(textFigureListener);
                textFigureListener = null;
            }
        }
    }

    /* 
     * Sets the listeners attached flag if the cell editor exists
     */
    protected void setCellEditor(CellEditor editor) {
        super.setCellEditor(editor);
        if (editor != null) {
            listenersAttached = true;
        }
    }

    public void showFeedback() {
        try {
            getEditPart().getRoot();
            super.showFeedback();
        } catch (Exception e) {
            // TODO: handle exception
        }
        
    }    
    
    /**
     * Gets the resource manager to remember the resources allocated for this
     * graphical viewer. All resources will be disposed when the graphical
     * viewer is closed if they have not already been disposed.
     * @@return
     */
    protected ResourceManager getResourceManager() {
        return ((DiagramGraphicalViewer) getEditPart().getViewer())
            .getResourceManager();
    }
    
    private void saveCurrentActions(IActionBars _actionBars) {
        copy = _actionBars.getGlobalActionHandler(ActionFactory.COPY.getId());
        paste = _actionBars.getGlobalActionHandler(ActionFactory.PASTE.getId());
        delete = _actionBars.getGlobalActionHandler(ActionFactory.DELETE.getId());
        selectAll = _actionBars.getGlobalActionHandler(ActionFactory.SELECT_ALL.getId());
        cut = _actionBars.getGlobalActionHandler(ActionFactory.CUT.getId());
        find = _actionBars.getGlobalActionHandler(ActionFactory.FIND.getId());
        undo = _actionBars.getGlobalActionHandler(ActionFactory.UNDO.getId());
        redo = _actionBars.getGlobalActionHandler(ActionFactory.REDO.getId());
    }
    
    private void restoreSavedActions(IActionBars _actionBars){
        _actionBars.setGlobalActionHandler(ActionFactory.COPY.getId(), copy);
        _actionBars.setGlobalActionHandler(ActionFactory.PASTE.getId(), paste);
        _actionBars.setGlobalActionHandler(ActionFactory.DELETE.getId(), delete);
        _actionBars.setGlobalActionHandler(ActionFactory.SELECT_ALL.getId(), selectAll);
        _actionBars.setGlobalActionHandler(ActionFactory.CUT.getId(), cut);
        _actionBars.setGlobalActionHandler(ActionFactory.FIND.getId(), find);
        _actionBars.setGlobalActionHandler(ActionFactory.UNDO.getId(), undo);
        _actionBars.setGlobalActionHandler(ActionFactory.REDO.getId(), redo);
    }

}@


1.18
log
@[234679] gmf-head lgrahek 080529 IllegalArgumentException when clicking enter on blank cell editor at <> 100% zoom
@
text
@d591 13
a603 14
        
        new Thread() {
            Event event;
            public void run() {
                    event = new Event();
                    event.type = SWT.MouseDown;
                    event.button = 1;
                    event.x = location.x;
                    event.y = location.y;
                    currDisplay.post(event);
                    event.type = SWT.MouseUp;
                    currDisplay.post(event);
            }
        }.start();
@


1.17
log
@[162932] gmf_head crevells 071016 [NoteTextLabel] WrapLabel should use Gef's text layout
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d184 11
a194 9
                        // When zoomed in, the height of this rectangle is not
                        // sufficient because the text is shifted downwards a
                        // little bit. Add some to the height to compensate for
                        // this. I'm not sure why this is happening, but I can
                        // see the text shifting down even in a label on a GEF
                        // logic diagram when zoomed into 400%.
                        int charHeight = FigureUtilities.getFontMetrics(
                            text.getFont()).getHeight();
                        rect.resize(0, charHeight / 2);
d196 1
a196 1
                    } else {
@


1.16
log
@[161793] gmf_head crevells 061129 StringIndexOutOfBoundsException on show() of TextDirectEditManager
Contributed by: Syed Atif Ali
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d19 2
a20 1
import org.eclipse.draw2d.FigureUtilities;
a21 1
import org.eclipse.draw2d.Label;
a32 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.TextCompartmentEditPart;
d36 1
d38 1
d40 1
a40 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
a49 1
import org.eclipse.jface.util.Assert;
a54 1
import org.eclipse.swt.graphics.Image;
d57 1
a68 1
import com.ibm.icu.util.StringTokenizer;
d75 1
a75 1
    
d85 1
a85 1
    
d87 1
a87 1
    
d93 2
a95 3
    /** String buffer to hold initial characters **/
    private StringBuffer initialString = new StringBuffer();
    
d101 1
a101 1
    
d103 1
d105 1
d107 1
a107 1
    
d109 1
a109 3
    
    private CellEditorLocator locator;
        
d111 3
a113 3
     * the text cell editor locator
     * @@author mmostafa
     *
d115 1
a115 1
    static private class TextCellEditorLocator implements CellEditorLocator {
d117 4
a120 68
        private WrapLabel wrapLabel;
        
        public TextCellEditorLocator(WrapLabel wrapLabel) {
            super();
            this.wrapLabel = wrapLabel;
        }

        
        public WrapLabel getWrapLabel() {
            return wrapLabel;
        }

        public void relocate(CellEditor celleditor) {
            Text text = (Text) celleditor.getControl();
            WrapLabel fig = getWrapLabel();
            
            Rectangle rect = fig.getTextBounds().getCopy();
            fig.translateToAbsolute(rect);
            
            int avrWidth = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
            
            
            if (fig.isTextWrapped() && fig.getText().length() > 0)
                rect.setSize(new Dimension(rect.width, rect.height + FigureUtilities.getFontMetrics(text.getFont()).getDescent()));
            else
                rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avrWidth*2, 0));
            
            org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
            
            Rectangle textBounds = new Rectangle(text.getBounds());
            if (!newRect.equals(textBounds)) {
                if (!(fig.getTextWrapAlignment() == PositionConstants.LEFT || fig.getTextAlignment() == PositionConstants.LEFT))
                    text.setBounds(newRect.x, newRect.y, newRect.width + avrWidth*3, newRect.height);
                else {
                    if (text.getBounds().x == 0 || Math.abs(text.getBounds().x - newRect.x) >= avrWidth)
                        text.setBounds(newRect.x, newRect.y, newRect.width + avrWidth*3, newRect.height);
                    else
                        text.setBounds(text.getBounds().x, newRect.y, newRect.width + avrWidth*3, newRect.height);
                }   
            }
        }
    }

    private static class LabelCellEditorLocator implements CellEditorLocator {

        private Label label;

        public LabelCellEditorLocator(Label label) {
            this.label = label;
        }

        public Label getLabel() {
            return label;
        }

        public void relocate(CellEditor celleditor) {
            Text text = (Text) celleditor.getControl();
            Rectangle rect = getLabel().getTextBounds().getCopy();
            getLabel().translateToAbsolute(rect);

            int avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
            rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));

            org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
            if (!newRect.equals(new Rectangle(text.getBounds())))
                text.setBounds(newRect.x, newRect.y, newRect.width, newRect.height);
        }
    }
d125 4
a128 2
     * @@param source <code>GraphicalEditPart</code> to support direct edit of.  The figure of
     * the <code>source</code> edit part must be of type <code>WrapLabel</code>.
d131 2
a132 1
        this(source, getTextCellEditorClass(source), getTextCellEditorLocator(source));
d140 2
a141 1
    public TextDirectEditManager(GraphicalEditPart source, Class editorType, CellEditorLocator locator) {
d143 1
a143 1
        this.locator = locator;
d147 85
a231 12
     * @@param source the <code>ITextAwareEditPart</code> to determine the cell editor for
     * @@return the <code>CellEditorLocator</code> that is appropriate for the source <code>EditPart</code>
     */
    public static CellEditorLocator getTextCellEditorLocator(ITextAwareEditPart source){
               
        if (source instanceof TextCompartmentEditPart)
            return new TextCellEditorLocator(((TextCompartmentEditPart)source).getLabel());
        else {
            IFigure figure = source.getFigure();
            assert figure instanceof Label;
            return new LabelCellEditorLocator((Label)figure);
        }
d233 1
a233 1
    
d235 9
a243 3
     * @@param source the <code>GraphicalEditPart</code> that is used to determine which
     * <code>CellEditor</code> class to use.
     * @@return the <code>Class</code> of the <code>CellEditor</code> to use for the text editing.
d245 1
a245 1
    public static Class getTextCellEditorClass(GraphicalEditPart source){
a252 1
    
d255 40
a294 1
     * Given a <code>WrapLabel</code> object, this will calculate the 
d300 2
a301 2
     * @@param label the <code>WrapLabel</code> to use for the font calculation
     * @@return the <code>Font</code> that is scaled to the screen coordinates.  
a538 18
    
    /**
     * Gets the tex extent scaled to the mapping mode
     */
    private Dimension getTextExtents(String s, Font font, IMapMode mm) {
        Dimension d = FigureUtilities.getTextExtents(s, font);
        // height should be set using the font height and the number of lines
        // in the string 
        int lineCount = getLineCount(s);
        d.height = FigureUtilities.getFontMetrics(font).getHeight()*lineCount;
        
        return new Dimension(mm.DPtoLP(d.width), mm.DPtoLP(d.height));
    }

    private int getLineCount(String s) {
        StringTokenizer tokenizer = new StringTokenizer(s, "\n"); //$NON-NLS-1$
        return tokenizer.countTokens();
    }
d551 1
a551 1
        locator.relocate(getCellEditor());
d567 2
a568 59
        
        Rectangle iconBounds;
        Image icon;
        int textPlacement;
        String subStringText;
        String text;

        IFigure fig = getEditPart().getFigure();
        if (fig instanceof WrapLabel) {
            WrapLabel label = (WrapLabel) fig;
            iconBounds = label.getIconBounds().getCopy();
            icon = label.getIcon();
            textPlacement = label.getTextPlacement();
            subStringText = label.getSubStringText();
            text = label.getText();
        } else if (fig instanceof Label) {
            Label label = (Label) fig;
            iconBounds = label.getIconBounds().getCopy();
            icon = label.getIcon();
            textPlacement = label.getTextPlacement();
            subStringText = label.getSubStringText();
            text = label.getText();
        } else {
            sendClickToCellEditor(location);
            return;
        }

        Text textControl = (Text)getCellEditor().getControl();
        
        //we need to restore our wraplabel figure bounds after we are done
        Rectangle restoreRect = fig.getBounds().getCopy();
        
        Rectangle rect = fig.getBounds();
        fig.translateToAbsolute(rect);
        
        if (!rect.contains(new org.eclipse.draw2d.geometry.Point(location.x,location.y))) {
            textControl.setSelection(0, textControl.getText().length());
            fig.setBounds(restoreRect);
            return;
        }
        
        fig.translateToAbsolute(iconBounds);

        double avrLines =  fig.getBounds().height / (double)FigureUtilities.getFontMetrics(this.zoomLevelFont).getHeight();
        
        int xWidth = location.x - rect.x;
        
        if (icon != null && textPlacement == PositionConstants.EAST) 
            xWidth -= iconBounds.width;
        
        double yPercentage = (location.y - rect.y) / (double)rect.height;
        
        //calculate the line number the mouse clicked on.
        int lineNum = (int)Math.ceil(avrLines * yPercentage);
        
        //character count for caret positioning...
        int charCount = 0;
        
        StringTokenizer tokenizer = new StringTokenizer(subStringText, "\n"); //$NON-NLS-1$
a569 49
        //calculate the total characters before linePos...
        for (int lineCount = 1; lineCount < lineNum; lineCount++) {
            if (tokenizer.hasMoreTokens()) {
                charCount += tokenizer.nextToken().length();
                
                if (charCount >= text.length())
                    break;
                
                //check if there is a user-inserted new line which will be accounted in the Text control...
                String newLineCheck = text.substring(charCount,charCount+1); 
                if (newLineCheck.equals("\r") || newLineCheck.equals("\n")) //$NON-NLS-1$ //$NON-NLS-2$
                    charCount++;
            }
            else {
                //our linePos calculation was wrong...revert to sending a mouse click...
                sendClickToCellEditor(location);
                fig.setBounds(restoreRect);
                return;
            }
        }
        
        //now count the last line's characters till the point where the mouse clicked...
        if (tokenizer.hasMoreTokens()) {
            String currentLineText = tokenizer.nextToken();
            
            IMapMode mm = MapModeUtil.getMapMode(fig);
            
            for (int i = 1; i <= currentLineText.length(); i++) {
                Dimension textExtent = getTextExtents(currentLineText.substring(0, i), this.zoomLevelFont, mm);
                fig.translateToAbsolute(textExtent);
                
                charCount++;
                
                if (textExtent.width >= xWidth)
                    break;
            }
            
            textControl.setSelection(charCount);
            
            fig.setBounds(restoreRect);
            
        }
        else {
            //our linePos calculation was wrong...revert to sending a mouse click...
            sendClickToCellEditor(location);
            fig.setBounds(restoreRect);
        }
    }
    
d605 26
a630 3
    /* 
     * Overrides super unhookListeners to set listeners attached flag
     * This method prevents unhooking listeners twice if the UI thread is blocked.
d637 9
a701 5
    public void setLocator(CellEditorLocator locator) {
        super.setLocator(locator);
        this.locator = locator;
    }

@


1.15
log
@[159705] gmf_head crevells 061011 CCE in TextDirectEditManager
@
text
@d595 3
@


1.14
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d10 1
a10 1
 * 	  Dmitry Stadnik (Borland) - contribution for bugzilla 135694
d55 1
d75 18
a92 18
	extends DirectEditManager {
	
	/**
	 * content assist background color
	 */
	private Color proposalPopupBackgroundColor = null;

	/**
	 * content assist foreground color
	 */
	private Color proposalPopupForegroundColor = null;
	
	private boolean committed = false;
	
	/**
	 * flag used to avoid unhooking listeners twice if the UI thread is blocked
	 */
	private boolean listenersAttached = true;
d95 2
a96 2
	/** String buffer to hold initial characters **/
	private StringBuffer initialString = new StringBuffer();
d111 19
a129 19
		
	/**
	 * the text cell editor locator
	 * @@author mmostafa
	 *
	 */
	static private class TextCellEditorLocator implements CellEditorLocator {

		private WrapLabel wrapLabel;
		
		public TextCellEditorLocator(WrapLabel wrapLabel) {
			super();
			this.wrapLabel = wrapLabel;
		}

		
		public WrapLabel getWrapLabel() {
			return wrapLabel;
		}
d160 18
a177 1
	}
d179 2
a180 1
	private static class LabelCellEditorLocator implements CellEditorLocator {
d182 5
a186 1
		private Label label;
d188 19
a206 41
		public LabelCellEditorLocator(Label label) {
			this.label = label;
		}

		public Label getLabel() {
			return label;
		}

		public void relocate(CellEditor celleditor) {
			Text text = (Text) celleditor.getControl();
			Rectangle rect = getLabel().getTextBounds().getCopy();
			getLabel().translateToAbsolute(rect);

			int avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
			rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));

			org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
			if (!newRect.equals(new Rectangle(text.getBounds())))
				text.setBounds(newRect.x, newRect.y, newRect.width, newRect.height);
		}
	}

	/**
	 * constructor
	 * 
	 * @@param source <code>GraphicalEditPart</code> to support direct edit of.  The figure of
	 * the <code>source</code> edit part must be of type <code>WrapLabel</code>.
	 */
	public TextDirectEditManager(ITextAwareEditPart source) {
		this(source, getTextCellEditorClass(source), getTextCellEditorLocator(source));
	}

	/**
	 * @@param source
	 * @@param editorType
	 * @@param locator
	 */
	public TextDirectEditManager(GraphicalEditPart source, Class editorType, CellEditorLocator locator) {
		super(source, editorType, locator);
		this.locator = locator;
	}
d223 2
a224 2
	/**
	 * @@param source the <code>GraphicalEditPart</code> that is used to determine which
d226 32
a257 32
	 * @@return the <code>Class</code> of the <code>CellEditor</code> to use for the text editing.
	 */
	public static Class getTextCellEditorClass(GraphicalEditPart source){
		IFigure figure = source.getFigure();
				
		if (figure instanceof WrapLabel && ((WrapLabel) figure).isTextWrapped())
			return WrapTextCellEditor.class;
		
		return TextCellEditorEx.class;
	}
	

	/**
	 * Given a <code>WrapLabel</code> object, this will calculate the 
	 * correct Font needed to display into screen coordinates, taking into 
	 * account the current mapmode.  This will typically be used by direct
	 * edit cell editors that need to display independent of the zoom or any
	 * coordinate mapping that is taking place on the drawing surface.
	 * 
	 * @@param label the <code>WrapLabel</code> to use for the font calculation
	 * @@return the <code>Font</code> that is scaled to the screen coordinates.  
	 * Note: the returned <code>Font</code> should not be disposed since it is
	 * cached by a common resource manager.
	 */
	protected Font getScaledFont(IFigure label) {
		Font scaledFont = label.getFont();
		FontData data = scaledFont.getFontData()[0];
		Dimension fontSize = new Dimension(0, MapModeUtil.getMapMode(label).DPtoLP(data.getHeight()));
		label.translateToAbsolute(fontSize);
		
		if( Math.abs( data.getHeight() - fontSize.height ) < 2 )
			fontSize.height = data.getHeight();
d273 100
a372 100
	
	protected void initCellEditor() {
		committed = false;

		// Get the Text Compartments Edit Part
		ITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();

		setEditText(textEP.getEditText());

		IFigure label = textEP.getFigure();
		Assert.isNotNull(label);
		Text text = (Text) getCellEditor().getControl();
		// scale the font accordingly to the zoom level
		text.setFont(getScaledFont(label));
		
		
		// register a validator on the cell editor
		getCellEditor().setValidator(textEP.getEditTextValidator());

		if (textEP.getParser() != null) {
			IContentAssistProcessor processor = textEP.getCompletionProcessor();
			if (processor != null) {
				// register content assist
				proposalPopupBackgroundColor = new Color(getCellEditor()
					.getControl().getShell().getDisplay(), new RGB(254, 241,
					233));
				proposalPopupForegroundColor = new Color(getCellEditor()
					.getControl().getShell().getDisplay(), new RGB(0, 0, 0));

				ContentAssistantHelper.createTextContentAssistant(text,
					proposalPopupForegroundColor, proposalPopupBackgroundColor,
					processor);
			}
		}
		
		//Hook the cell editor's copy/paste actions to the actionBars so that they can
		// be invoked via keyboard shortcuts.
		actionBars = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage()
				.getActiveEditor().getEditorSite().getActionBars();
		saveCurrentActions(actionBars);
		actionHandler = new CellEditorActionHandler(actionBars);
		actionHandler.addCellEditor(getCellEditor());
		actionBars.updateActionBars();
	}

	/**
	 * @@see org.eclipse.gef.tools.DirectEditManager#commit()
	 */
	protected void commit() {
		Shell activeShell = Display.getCurrent().getActiveShell();
		if (activeShell != null
			&& getCellEditor().getControl().getShell().equals(
				activeShell.getParent())) {
			Control[] children = activeShell.getChildren();
			if (children.length == 1 && children[0] instanceof Table) {
				/*
				 * CONTENT ASSIST: focus is lost to the content assist pop up -
				 * stay in focus
				 */
				getCellEditor().getControl().setVisible(true);
				((TextCellEditorEx) getCellEditor()).setDeactivationLock(true);
				return;
			}
		}

		// content assist hacks
		if (committed) {
			bringDown();
			return;
		}
		committed = true;
		super.commit();
	}

	/**
	 * @@see org.eclipse.gef.tools.DirectEditManager#bringDown()
	 */
	protected void bringDown() {
		if (proposalPopupForegroundColor != null) {
			proposalPopupForegroundColor.dispose();
			proposalPopupForegroundColor = null;
		}
		if (proposalPopupBackgroundColor != null) {
			proposalPopupBackgroundColor.dispose();
			proposalPopupBackgroundColor = null;
		}

		// myee - RATLC00523014: crashes when queued in asyncExec()
		eraseFeedback();
		
		initialString = new StringBuffer();
		
		Display.getCurrent().asyncExec(new Runnable() {

			public void run() {
				// Content Assist hack - allow proper cleanup on childen
				// controls
				TextDirectEditManager.super.bringDown();
			}
		});
d380 61
a440 61
    		actionHandler.dispose();
    		actionHandler = null;
    	}
    	if (actionBars != null) {
    		restoreSavedActions(actionBars);
    		actionBars.updateActionBars();
    		actionBars = null;
    	}
	}

	/**
	 * This method is used to set the cell editors text
	 * 
	 * @@param toEdit
	 *            String to be set in the cell editor
	 */
	public void setEditText(String toEdit) {

		// Get the cell editor
		CellEditor cellEditor = getCellEditor();

		// IF the cell editor doesn't exist yet...
		if (cellEditor == null) {
			// Do nothing
			return;
		}

		// Get the Text Compartment Edit Part
		ITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();

		// Get the Text control
		Text textControl = (Text) cellEditor.getControl();

		// Set the Figures text
		textEP.setLabelText(toEdit);
		
		
		// See RATLC00522324
		if (cellEditor instanceof TextCellEditorEx){
			((TextCellEditorEx)cellEditor).setValueAndProcessEditOccured(toEdit);
		} else {
			cellEditor.setValue(toEdit);
		}
		
		// Set the controls text and position the caret at the end of the text
		textControl.setSelection(toEdit.length());
	}

	/**
	 * Performs show and sets the edit string to be the initial character or string
	 * @@param initialChar
	 */
	public void show(char initialChar) {
		initialString = initialString.append(initialChar);
		show();
		if (SWT.getPlatform() != "carbon") { //$NON-NLS-1$ 
			// Set the cell editor text to the initial character
			setEditText(initialString.toString());
		}
	}
	
d449 18
a466 18
	private Font getZoomLevelFont(Font actualFont, Display display) {
		Object zoom = getEditPart().getViewer().getProperty(ZoomManager.class.toString());
		
		if (zoom != null) {
			double zoomLevel = ((ZoomManager)zoom).getZoom();
			
			if (zoomLevel == 1.0f) 
				return actualFont;
			
			FontData[] fd = new FontData[actualFont.getFontData().length];
			FontData tempFD = null;
			
			for (int i=0; i < fd.length; i++) {
				tempFD = actualFont.getFontData()[i];
				
				fd[i] = new FontData(tempFD.getName(),(int)(zoomLevel * tempFD.getHeight()),tempFD.getStyle());
			}
			
d480 10
a489 10
		}
		else
			return actualFont;
	}
	
	/**
	 * Gets the tex extent scaled to the mapping mode
	 */
	private Dimension getTextExtents(String s, Font font, IMapMode mm) {
		Dimension d = FigureUtilities.getTextExtents(s, font);
d495 2
a496 2
     	return new Dimension(mm.DPtoLP(d.width), mm.DPtoLP(d.height));
	}
d504 7
a510 6
    	super.show();
    	
    	WrapLabel fig = ((TextCompartmentEditPart)this.getEditPart()).getLabel();
		Control control = getCellEditor().getControl();
		this.zoomLevelFont = getZoomLevelFont(fig.getFont(), control.getDisplay());
		
d512 1
a512 1
        
d515 1
d518 46
a563 26
	/**
	 * 
	 * Performs show and sends an extra mouse click to the point location so 
	 * that cursor appears at the mouse click point
	 * 
	 * The Text control does not allow for the cursor to appear at point location but
	 * at a character location
	 * 
	 * @@param location
	 */
	public void show(Point location) {		
		show();
		
		if (!(getEditPart() instanceof TextCompartmentEditPart)) {
			sendClickToCellEditor(location);
			return;
		}
		
		WrapLabel fig = ((TextCompartmentEditPart)this.getEditPart()).getLabel();
		Text textControl = (Text)getCellEditor().getControl();
		
		//we need to restore our wraplabel figure bounds after we are done
		Rectangle restoreRect = fig.getBounds().getCopy();
		
		Rectangle rect = fig.getBounds();
		fig.translateToAbsolute(rect);
d570 132
a701 133
		
		Rectangle iconBounds = fig.getIconBounds().getCopy();
		fig.translateToAbsolute(iconBounds);

		double avrLines =  fig.getBounds().height / (double)FigureUtilities.getFontMetrics(this.zoomLevelFont).getHeight();
		
		int xWidth = location.x - rect.x;
		
		if (fig.getIcon() != null && fig.getTextPlacement() == PositionConstants.EAST) 
			xWidth -= iconBounds.width;
		
		double yPercentage = (location.y - rect.y) / (double)rect.height;
		
		//calculate the line number the mouse clicked on.
		int lineNum = (int)Math.ceil(avrLines * yPercentage);
		
		//character count for caret positioning...
		int charCount = 0;
		
		StringTokenizer tokenizer = new StringTokenizer(fig.getSubStringText(), "\n"); //$NON-NLS-1$

		//calculate the total characters before linePos...
		for (int lineCount = 1; lineCount < lineNum; lineCount++) {
			if (tokenizer.hasMoreTokens()) {
				charCount += tokenizer.nextToken().length();
				
				//check if there is a user-inserted new line which will be accounted in the Text control...
				String newLineCheck = fig.getText().substring(charCount,charCount+1); 
				if (newLineCheck.equals("\r") || newLineCheck.equals("\n"))	//$NON-NLS-1$ //$NON-NLS-2$
					charCount++;
			}
			else {
				//our linePos calculation was wrong...revert to sending a mouse click...
				sendClickToCellEditor(location);
				fig.setBounds(restoreRect);
				return;
			}
		}
		
		//now count the last line's characters till the point where the mouse clicked...
		if (tokenizer.hasMoreTokens()) {
			String currentLineText = tokenizer.nextToken();
			
			IMapMode mm = MapModeUtil.getMapMode(fig);
			
			for (int i = 1; i <= currentLineText.length(); i++) {
				Dimension textExtent = getTextExtents(currentLineText.substring(0, i), this.zoomLevelFont, mm);
				fig.translateToAbsolute(textExtent);
				
				charCount++;
				
				if (textExtent.width >= xWidth)
					break;
			}
			
			textControl.setSelection(charCount);
			
			fig.setBounds(restoreRect);
			
		}
		else {
			//our linePos calculation was wrong...revert to sending a mouse click...
			sendClickToCellEditor(location);
			fig.setBounds(restoreRect);
		}
	}
	
	private void sendClickToCellEditor(final Point location) {
		//make sure the diagram doesn't receive the click event..
		getCellEditor().getControl().setCapture(true);
		
		if (getCellEditor() != null && getCellEditor().getControl().getBounds().contains(location))
			sendMouseClick(location);
	}

	
	/**
	 * 
	 * Sends a SWT MouseUp and MouseDown event to the point location 
	 * to the current Display
	 * 
	 * @@param location
	 */
	private void sendMouseClick(final Point location) {		
		
		final Display currDisplay = Display.getCurrent();
		
		new Thread() {
			Event event;
			public void run() {
					event = new Event();
					event.type = SWT.MouseDown;
					event.button = 1;
					event.x = location.x;
					event.y = location.y;
					currDisplay.post(event);
					event.type = SWT.MouseUp;
					currDisplay.post(event);
			}
		}.start();
	}

	/* 
	 * Overrides super unhookListeners to set listeners attached flag
	 * This method prevents unhooking listeners twice if the UI thread is blocked.
	 * For example, a validation dialog may block the thread
	 */
	protected void unhookListeners() {
		if (listenersAttached) {
			listenersAttached = false;
			super.unhookListeners();
		}
	}

	/* 
	 * Sets the listeners attached flag if the cell editor exists
	 */
	protected void setCellEditor(CellEditor editor) {
		super.setCellEditor(editor);
		if (editor != null) {
			listenersAttached = true;
		}
	}

	public void showFeedback() {
		try {
			getEditPart().getRoot();
			super.showFeedback();
		} catch (Exception e) {
			// TODO: handle exception
		}
		
	}    
d715 8
a722 8
    	copy = _actionBars.getGlobalActionHandler(ActionFactory.COPY.getId());
    	paste = _actionBars.getGlobalActionHandler(ActionFactory.PASTE.getId());
    	delete = _actionBars.getGlobalActionHandler(ActionFactory.DELETE.getId());
    	selectAll = _actionBars.getGlobalActionHandler(ActionFactory.SELECT_ALL.getId());
    	cut = _actionBars.getGlobalActionHandler(ActionFactory.CUT.getId());
    	find = _actionBars.getGlobalActionHandler(ActionFactory.FIND.getId());
    	undo = _actionBars.getGlobalActionHandler(ActionFactory.UNDO.getId());
    	redo = _actionBars.getGlobalActionHandler(ActionFactory.REDO.getId());
d726 8
a733 8
    	_actionBars.setGlobalActionHandler(ActionFactory.COPY.getId(), copy);
    	_actionBars.setGlobalActionHandler(ActionFactory.PASTE.getId(), paste);
    	_actionBars.setGlobalActionHandler(ActionFactory.DELETE.getId(), delete);
    	_actionBars.setGlobalActionHandler(ActionFactory.SELECT_ALL.getId(), selectAll);
    	_actionBars.setGlobalActionHandler(ActionFactory.CUT.getId(), cut);
    	_actionBars.setGlobalActionHandler(ActionFactory.FIND.getId(), find);
    	_actionBars.setGlobalActionHandler(ActionFactory.UNDO.getId(), undo);
    	_actionBars.setGlobalActionHandler(ActionFactory.REDO.getId(), redo);
@


1.13
log
@[127433] tmacdoug gmf_head 060615 TextCompartmentEditPart can't accept multibyte characters from IM(Input method)
@
text
@d15 4
d22 1
d26 1
d29 2
d34 4
a37 1
import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;
d39 1
d43 5
d63 6
d96 14
d130 29
a158 16
		public void relocate(CellEditor celleditor) {
			Text text = (Text) celleditor.getControl();
			Rectangle rect = getWrapLabel().getTextBounds().getCopy();
			getWrapLabel().translateToAbsolute(rect);
			
			if (getWrapLabel().isTextWrapped() && getWrapLabel().getText().length() > 0)
				rect.setSize(new Dimension(text.computeSize(rect.width, SWT.DEFAULT)));
			else {
				int avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
				rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr*2, 0));
			}

			if (!rect.equals(new Rectangle(text.getBounds())))
				text.setBounds(rect.x, rect.y, rect.width, rect.height);
		}

d181 3
a183 2
			if (!rect.equals(new Rectangle(text.getBounds())))
				text.setBounds(rect.x, rect.y, rect.width, rect.height);
d194 1
a194 1
		super(source, getTextCellEditorClass(source), getTextCellEditorLocator(source));
d203 2
a204 1
		super(source, editorType, locator);		
d258 14
a271 4
		data.setHeight(fontSize.height);
		Font newFont = DiagramFontRegistry.getInstance().getFont(null, data);
		return newFont;
	}
d306 9
d372 15
d438 58
d497 4
a500 1
	}
d502 13
d527 91
a617 1
		// Send another click if the previous one is within the editor bounds 
d619 1
a619 1
			sendMouseClick(location);	
d679 39
a717 1
	}
@


1.13.2.1
log
@bugzilla 145338 gmf_R1_0_maintenance sshaw 060713 Text moves between editing and displaying
@
text
@d105 2
a106 3
			org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
			if (!newRect.equals(new Rectangle(text.getBounds())))
				text.setBounds(newRect.x, newRect.y, newRect.width, newRect.height);
d131 2
a132 3
			org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
			if (!newRect.equals(new Rectangle(text.getBounds())))
				text.setBounds(newRect.x, newRect.y, newRect.width, newRect.height);
@


1.13.2.2
log
@Bugzilla#146289 gmf_R1_0_maintenance cmahoney 060714 DiagramFontRegistry appears to be a permanent resource leak
@
text
@a14 4
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

a22 2
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
d26 1
a26 4
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
a30 4
import org.eclipse.jface.resource.DeviceResourceException;
import org.eclipse.jface.resource.FontDescriptor;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.resource.ResourceManager;
a72 6
    
    /**
     * Cache the font descriptor when a font is created so that it can be
     * disposed later.
     */
    private List cachedFontDescriptors = new ArrayList();
d208 4
a211 14
        try {
            FontDescriptor fontDescriptor = FontDescriptor.createFrom(data);
            cachedFontDescriptors.add(fontDescriptor);
            return getResourceManager().createFont(fontDescriptor);
        } catch (DeviceResourceException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "getScaledFont", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "getScaledFont", e); //$NON-NLS-1$
        }
        return JFaceResources.getDefaultFont();
    }

a302 5
        
        for (Iterator iter = cachedFontDescriptors.iterator(); iter.hasNext();) {
            getResourceManager().destroyFont((FontDescriptor) iter.next());           
        }
        cachedFontDescriptors.clear();
d431 1
a431 12
	}    
    
    /**
     * Gets the resource manager to remember the resources allocated for this
     * graphical viewer. All resources will be disposed when the graphical
     * viewer is closed if they have not already been disposed.
     * @@return
     */
    protected ResourceManager getResourceManager() {
        return ((DiagramGraphicalViewer) getEditPart().getViewer())
            .getResourceManager();
    }
@


1.13.2.3
log
@[150978] gmf_R1_0_maintenance syedAtif 060802 Direct-Editing should provide the "Ctrl+C/V/X" keystroke support.
@
text
@a39 1
import org.eclipse.jface.action.IAction;
a58 4
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.part.CellEditorActionHandler;
a91 4
    
    private IActionBars actionBars;
    private CellEditorActionHandler actionHandler;
    private IAction copy, cut, paste, undo, redo, find, selectAll, delete;
a274 9
		
		//Hook the cell editor's copy/paste actions to the actionBars so that they can
		// be invoked via keyboard shortcuts.
		actionBars = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage()
				.getActiveEditor().getEditorSite().getActionBars();
		saveCurrentActions(actionBars);
		actionHandler = new CellEditorActionHandler(actionBars);
		actionHandler.addCellEditor(getCellEditor());
		actionBars.updateActionBars();
a336 10
        
        if (actionHandler != null) {
    		actionHandler.dispose();
    		actionHandler = null;
    	}
    	if (actionBars != null) {
    		restoreSavedActions(actionBars);
    		actionBars.updateActionBars();
    		actionBars = null;
    	}
a476 22
    
    private void saveCurrentActions(IActionBars _actionBars) {
    	copy = _actionBars.getGlobalActionHandler(ActionFactory.COPY.getId());
    	paste = _actionBars.getGlobalActionHandler(ActionFactory.PASTE.getId());
    	delete = _actionBars.getGlobalActionHandler(ActionFactory.DELETE.getId());
    	selectAll = _actionBars.getGlobalActionHandler(ActionFactory.SELECT_ALL.getId());
    	cut = _actionBars.getGlobalActionHandler(ActionFactory.CUT.getId());
    	find = _actionBars.getGlobalActionHandler(ActionFactory.FIND.getId());
    	undo = _actionBars.getGlobalActionHandler(ActionFactory.UNDO.getId());
    	redo = _actionBars.getGlobalActionHandler(ActionFactory.REDO.getId());
    }
    
    private void restoreSavedActions(IActionBars _actionBars){
    	_actionBars.setGlobalActionHandler(ActionFactory.COPY.getId(), copy);
    	_actionBars.setGlobalActionHandler(ActionFactory.PASTE.getId(), paste);
    	_actionBars.setGlobalActionHandler(ActionFactory.DELETE.getId(), delete);
    	_actionBars.setGlobalActionHandler(ActionFactory.SELECT_ALL.getId(), selectAll);
    	_actionBars.setGlobalActionHandler(ActionFactory.CUT.getId(), cut);
    	_actionBars.setGlobalActionHandler(ActionFactory.FIND.getId(), find);
    	_actionBars.setGlobalActionHandler(ActionFactory.UNDO.getId(), undo);
    	_actionBars.setGlobalActionHandler(ActionFactory.REDO.getId(), redo);
    }
@


1.13.2.4
log
@[148244] gmf_R1_0_maintenance satif 060822  Mouse-enabled direct-edit not working properly
@
text
@a21 1
import org.eclipse.draw2d.PositionConstants;
a24 1
import org.eclipse.gef.editparts.ZoomManager;
a36 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
a64 2
import com.ibm.icu.util.StringTokenizer;

a100 2
    
    private Font zoomLevelFont = null;
d416 1
a416 57
	}
	
    /**
     * This method obtains the fonts that are being used by the figure at its zoom level.
     * @@param gep the associated <code>GraphicalEditPart</code> of the figure
     * @@param actualFont font being used by the figure
     * @@param display
     * @@return <code>actualFont</code> if zoom level is 1.0 (or when there's an error),
     * new Font otherwise.
     */
	private Font getZoomLevelFont(Font actualFont, Display display) {
		Object zoom = getEditPart().getViewer().getProperty(ZoomManager.class.toString());
		
		if (zoom != null) {
			double zoomLevel = ((ZoomManager)zoom).getZoom();
			
			if (zoomLevel == 1.0f) 
				return actualFont;
			
			FontData[] fd = new FontData[actualFont.getFontData().length];
			FontData tempFD = null;
			
			for (int i=0; i < fd.length; i++) {
				tempFD = actualFont.getFontData()[i];
				
				fd[i] = new FontData(tempFD.getName(),(int)(zoomLevel * tempFD.getHeight()),tempFD.getStyle());
			}
			
            try {
                FontDescriptor fontDescriptor = FontDescriptor.createFrom(fd);
                cachedFontDescriptors.add(fontDescriptor);
                return getResourceManager().createFont(fontDescriptor);
            } catch (DeviceResourceException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "getZoomLevelFonts", e); //$NON-NLS-1$
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "getZoomLevelFonts", e); //$NON-NLS-1$
                
                return actualFont;
            }
		}
		else
			return actualFont;
	}
	
	/**
	 * Gets the tex extent scaled to the mapping mode
	 */
	private Dimension getTextExtents(String s, Font font, IMapMode mm) {
		Dimension d = FigureUtilities.getTextExtents(s, font);
        // height should be set using the font height and the number of lines
        // in the string 
        int lineCount = getLineCount(s);
        d.height = FigureUtilities.getFontMetrics(font).getHeight()*lineCount;
        
     	return new Dimension(mm.DPtoLP(d.width), mm.DPtoLP(d.height));
a418 18
    private int getLineCount(String s) {
        StringTokenizer tokenizer = new StringTokenizer(s, "\n"); //$NON-NLS-1$
        return tokenizer.countTokens();
    }

    public void show() {
    	super.show();
    	
    	WrapLabel fig = ((TextCompartmentEditPart)this.getEditPart()).getLabel();
		Text textControl = (Text)getCellEditor().getControl();
		this.zoomLevelFont = getZoomLevelFont(fig.getFont(), textControl.getDisplay());
		
		textControl.setFont(this.zoomLevelFont);
        
        //since the font's have been resized, we need to resize the  Text control...
        getTextCellEditorLocator((ITextAwareEditPart)getEditPart()).relocate(getCellEditor());
    }
    
d431 1
a431 85
		
		if (!(getEditPart() instanceof TextCompartmentEditPart)) {
			sendClickToCellEditor(location);
			return;
		}
		
		WrapLabel fig = ((TextCompartmentEditPart)this.getEditPart()).getLabel();
		Text textControl = (Text)getCellEditor().getControl();
		
		//we need to restore our wraplabel figure bounds after we are done
		Rectangle restoreRect = fig.getBounds().getCopy();
		
		Rectangle rect = fig.getBounds();
		fig.translateToAbsolute(rect);
		
		Rectangle iconBounds = fig.getIconBounds().getCopy();
		fig.translateToAbsolute(iconBounds);

		double avrLines =  fig.getBounds().height / (double)FigureUtilities.getFontMetrics(this.zoomLevelFont).getHeight();
		
		int xWidth = location.x - rect.x;
		
		if (fig.getIcon() != null && fig.getTextPlacement() == PositionConstants.EAST) 
			xWidth -= iconBounds.width;
		
		double yPercentage = (location.y - rect.y) / (double)rect.height;
		
		//calculate the line number the mouse clicked on.
		int lineNum = (int)Math.ceil(avrLines * yPercentage);
		
		//character count for caret positioning...
		int charCount = 0;
		
		StringTokenizer tokenizer = new StringTokenizer(fig.getSubStringText(), "\n"); //$NON-NLS-1$

		//calculate the total characters before linePos...
		for (int lineCount = 1; lineCount < lineNum; lineCount++) {
			if (tokenizer.hasMoreTokens()) {
				charCount += tokenizer.nextToken().length();
				
				//check if there is a user-inserted new line which will be accounted in the Text control...
				String newLineCheck = fig.getText().substring(charCount,charCount+1); 
				if (newLineCheck.equals("\r") || newLineCheck.equals("\n"))	//$NON-NLS-1$ //$NON-NLS-2$
					charCount++;
			}
			else {
				//our linePos calculation was wrong...revert to sending a mouse click...
				sendClickToCellEditor(location);
				fig.setBounds(restoreRect);
				return;
			}
		}
		
		//now count the last line's characters till the point where the mouse clicked...
		if (tokenizer.hasMoreTokens()) {
			String currentLineText = tokenizer.nextToken();
			
			IMapMode mm = MapModeUtil.getMapMode(fig);
			
			for (int i = 1; i < currentLineText.length(); i++) {
				Dimension textExtent = getTextExtents(currentLineText.substring(0, i), this.zoomLevelFont, mm);
				fig.translateToAbsolute(textExtent);
				
				charCount++;
				
				if (textExtent.width >= xWidth)
					break;
			}
			
			textControl.setSelection(charCount);
			
			fig.setBounds(restoreRect);
			
		}
		else {
			//our linePos calculation was wrong...revert to sending a mouse click...
			sendClickToCellEditor(location);
			fig.setBounds(restoreRect);
		}
	}
	
	private void sendClickToCellEditor(final Point location) {
		//make sure the diagram doesn't receive the click event..
		getCellEditor().getControl().setCapture(true);
		
d433 1
a433 1
			sendMouseClick(location);
@


1.13.2.5
log
@Bugzilla#155456 gmf_R1_0_maintenance cmahoney 060830 Out of bounds error on note text when clicking below a note's text box three times
Contributed by: Syed Atif Ali
@
text
@a525 6
        
        if (!rect.contains(new org.eclipse.draw2d.geometry.Point(location.x,location.y))) {
            textControl.setSelection(0, textControl.getText().length());
            fig.setBounds(restoreRect);
            return;
        }
d571 1
a571 1
			for (int i = 1; i <= currentLineText.length(); i++) {
@


1.13.2.6
log
@Bugzilla#155846 gmf_R1_0_maintenance cmahoney 060906 ClassCastException in TextDirectEditManager when cell editor control is not Text
Contributed by: Syed Atif Ali
@
text
@a107 2
    
    private CellEditorLocator locator;
d180 1
a180 1
		this(source, getTextCellEditorClass(source), getTextCellEditorLocator(source));
d189 1
a189 2
		super(source, editorType, locator);
		this.locator = locator;
d491 2
a492 2
		Control control = getCellEditor().getControl();
		this.zoomLevelFont = getZoomLevelFont(fig.getFont(), control.getDisplay());
d494 1
a494 1
        control.setFont(this.zoomLevelFont);
d497 1
a497 1
        locator.relocate(getCellEditor());
a698 5
    public void setLocator(CellEditorLocator locator) {
        super.setLocator(locator);
        this.locator = locator;
    }

@


1.13.2.7
log
@Bugzilla#155610  gmf_R1_0_maintenance cmahoney 060908 TextCompartmentEditPart figure flickers when entring text
Contributed by: Syed Atif Ali
@
text
@d130 17
a146 29
        public void relocate(CellEditor celleditor) {
            Text text = (Text) celleditor.getControl();
            WrapLabel fig = getWrapLabel();
            
            Rectangle rect = fig.getTextBounds().getCopy();
            fig.translateToAbsolute(rect);
            
            int avrWidth = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
            
            
            if (fig.isTextWrapped() && fig.getText().length() > 0)
                rect.setSize(new Dimension(rect.width, rect.height + FigureUtilities.getFontMetrics(text.getFont()).getDescent()));
            else
                rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avrWidth*2, 0));
            
            org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
            
            Rectangle textBounds = new Rectangle(text.getBounds());
            if (!newRect.equals(textBounds)) {
                if (!(fig.getTextWrapAlignment() == PositionConstants.LEFT || fig.getTextAlignment() == PositionConstants.LEFT))
                    text.setBounds(newRect.x, newRect.y, newRect.width + avrWidth*3, newRect.height);
                else {
                    if (text.getBounds().x == 0 || Math.abs(text.getBounds().x - newRect.x) >= avrWidth)
                        text.setBounds(newRect.x, newRect.y, newRect.width + avrWidth*3, newRect.height);
                    else
                        text.setBounds(text.getBounds().x, newRect.y, newRect.width + avrWidth*3, newRect.height);
                }   
            }
        }
@


1.13.2.8
log
@[159705] gmf_R1_0_maintenance crevells 091005 CCE in TextDirectEditManager
@
text
@d503 4
a506 9
        super.show();

         if (!(getEditPart().getFigure() instanceof WrapLabel)) {
            return;
        }

        WrapLabel fig = (WrapLabel) getEditPart().getFigure();

        Control control = getCellEditor().getControl();
d508 1
a508 1

d510 1
a510 1

a512 1

d516 4
a519 4
     * 
     * Performs show and sends an extra mouse click to the point location so
     * that cursor appears at the mouse click point
     * 
d522 3
a524 3
     * 
     * @@param location
     */
a526 5
        
        if (!(getEditPart().getFigure() instanceof WrapLabel)) {
          sendClickToCellEditor(location);
          return;        
        }
d528 6
a533 1
		WrapLabel fig = (WrapLabel) getEditPart().getFigure();
@


1.13.2.9
log
@Bugzilla#159705 gmf_R1_0_maintenance crevells 061006 CCE in TextDirectEditManager
@
text
@d10 1
a10 1
 *    Dmitry Stadnik (Borland) - contribution for bugzilla 135694
a54 1
import org.eclipse.swt.graphics.Image;
d74 18
a91 18
    extends DirectEditManager {
    
    /**
     * content assist background color
     */
    private Color proposalPopupBackgroundColor = null;

    /**
     * content assist foreground color
     */
    private Color proposalPopupForegroundColor = null;
    
    private boolean committed = false;
    
    /**
     * flag used to avoid unhooking listeners twice if the UI thread is blocked
     */
    private boolean listenersAttached = true;
d94 2
a95 2
    /** String buffer to hold initial characters **/
    private StringBuffer initialString = new StringBuffer();
d110 19
a128 19
        
    /**
     * the text cell editor locator
     * @@author mmostafa
     *
     */
    static private class TextCellEditorLocator implements CellEditorLocator {

        private WrapLabel wrapLabel;
        
        public TextCellEditorLocator(WrapLabel wrapLabel) {
            super();
            this.wrapLabel = wrapLabel;
        }

        
        public WrapLabel getWrapLabel() {
            return wrapLabel;
        }
d159 1
a159 13
    }

    private static class LabelCellEditorLocator implements CellEditorLocator {

        private Label label;

        public LabelCellEditorLocator(Label label) {
            this.label = label;
        }

        public Label getLabel() {
            return label;
        }
d161 1
a161 4
        public void relocate(CellEditor celleditor) {
            Text text = (Text) celleditor.getControl();
            Rectangle rect = getLabel().getTextBounds().getCopy();
            getLabel().translateToAbsolute(rect);
d163 1
a163 2
            int avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
            rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));
d165 41
a205 25
            org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
            if (!newRect.equals(new Rectangle(text.getBounds())))
                text.setBounds(newRect.x, newRect.y, newRect.width, newRect.height);
        }
    }

    /**
     * constructor
     * 
     * @@param source <code>GraphicalEditPart</code> to support direct edit of.  The figure of
     * the <code>source</code> edit part must be of type <code>WrapLabel</code>.
     */
    public TextDirectEditManager(ITextAwareEditPart source) {
        this(source, getTextCellEditorClass(source), getTextCellEditorLocator(source));
    }

    /**
     * @@param source
     * @@param editorType
     * @@param locator
     */
    public TextDirectEditManager(GraphicalEditPart source, Class editorType, CellEditorLocator locator) {
        super(source, editorType, locator);
        this.locator = locator;
    }
d222 2
a223 2
    /**
     * @@param source the <code>GraphicalEditPart</code> that is used to determine which
d225 32
a256 32
     * @@return the <code>Class</code> of the <code>CellEditor</code> to use for the text editing.
     */
    public static Class getTextCellEditorClass(GraphicalEditPart source){
        IFigure figure = source.getFigure();
                
        if (figure instanceof WrapLabel && ((WrapLabel) figure).isTextWrapped())
            return WrapTextCellEditor.class;
        
        return TextCellEditorEx.class;
    }
    

    /**
     * Given a <code>WrapLabel</code> object, this will calculate the 
     * correct Font needed to display into screen coordinates, taking into 
     * account the current mapmode.  This will typically be used by direct
     * edit cell editors that need to display independent of the zoom or any
     * coordinate mapping that is taking place on the drawing surface.
     * 
     * @@param label the <code>WrapLabel</code> to use for the font calculation
     * @@return the <code>Font</code> that is scaled to the screen coordinates.  
     * Note: the returned <code>Font</code> should not be disposed since it is
     * cached by a common resource manager.
     */
    protected Font getScaledFont(IFigure label) {
        Font scaledFont = label.getFont();
        FontData data = scaledFont.getFontData()[0];
        Dimension fontSize = new Dimension(0, MapModeUtil.getMapMode(label).DPtoLP(data.getHeight()));
        label.translateToAbsolute(fontSize);
        
        if( Math.abs( data.getHeight() - fontSize.height ) < 2 )
            fontSize.height = data.getHeight();
d272 100
a371 100
    
    protected void initCellEditor() {
        committed = false;

        // Get the Text Compartments Edit Part
        ITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();

        setEditText(textEP.getEditText());

        IFigure label = textEP.getFigure();
        Assert.isNotNull(label);
        Text text = (Text) getCellEditor().getControl();
        // scale the font accordingly to the zoom level
        text.setFont(getScaledFont(label));
        
        
        // register a validator on the cell editor
        getCellEditor().setValidator(textEP.getEditTextValidator());

        if (textEP.getParser() != null) {
            IContentAssistProcessor processor = textEP.getCompletionProcessor();
            if (processor != null) {
                // register content assist
                proposalPopupBackgroundColor = new Color(getCellEditor()
                    .getControl().getShell().getDisplay(), new RGB(254, 241,
                    233));
                proposalPopupForegroundColor = new Color(getCellEditor()
                    .getControl().getShell().getDisplay(), new RGB(0, 0, 0));

                ContentAssistantHelper.createTextContentAssistant(text,
                    proposalPopupForegroundColor, proposalPopupBackgroundColor,
                    processor);
            }
        }
        
        //Hook the cell editor's copy/paste actions to the actionBars so that they can
        // be invoked via keyboard shortcuts.
        actionBars = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage()
                .getActiveEditor().getEditorSite().getActionBars();
        saveCurrentActions(actionBars);
        actionHandler = new CellEditorActionHandler(actionBars);
        actionHandler.addCellEditor(getCellEditor());
        actionBars.updateActionBars();
    }

    /**
     * @@see org.eclipse.gef.tools.DirectEditManager#commit()
     */
    protected void commit() {
        Shell activeShell = Display.getCurrent().getActiveShell();
        if (activeShell != null
            && getCellEditor().getControl().getShell().equals(
                activeShell.getParent())) {
            Control[] children = activeShell.getChildren();
            if (children.length == 1 && children[0] instanceof Table) {
                /*
                 * CONTENT ASSIST: focus is lost to the content assist pop up -
                 * stay in focus
                 */
                getCellEditor().getControl().setVisible(true);
                ((TextCellEditorEx) getCellEditor()).setDeactivationLock(true);
                return;
            }
        }

        // content assist hacks
        if (committed) {
            bringDown();
            return;
        }
        committed = true;
        super.commit();
    }

    /**
     * @@see org.eclipse.gef.tools.DirectEditManager#bringDown()
     */
    protected void bringDown() {
        if (proposalPopupForegroundColor != null) {
            proposalPopupForegroundColor.dispose();
            proposalPopupForegroundColor = null;
        }
        if (proposalPopupBackgroundColor != null) {
            proposalPopupBackgroundColor.dispose();
            proposalPopupBackgroundColor = null;
        }

        // myee - RATLC00523014: crashes when queued in asyncExec()
        eraseFeedback();
        
        initialString = new StringBuffer();
        
        Display.getCurrent().asyncExec(new Runnable() {

            public void run() {
                // Content Assist hack - allow proper cleanup on childen
                // controls
                TextDirectEditManager.super.bringDown();
            }
        });
d379 61
a439 61
            actionHandler.dispose();
            actionHandler = null;
        }
        if (actionBars != null) {
            restoreSavedActions(actionBars);
            actionBars.updateActionBars();
            actionBars = null;
        }
    }

    /**
     * This method is used to set the cell editors text
     * 
     * @@param toEdit
     *            String to be set in the cell editor
     */
    public void setEditText(String toEdit) {

        // Get the cell editor
        CellEditor cellEditor = getCellEditor();

        // IF the cell editor doesn't exist yet...
        if (cellEditor == null) {
            // Do nothing
            return;
        }

        // Get the Text Compartment Edit Part
        ITextAwareEditPart textEP = (ITextAwareEditPart) getEditPart();

        // Get the Text control
        Text textControl = (Text) cellEditor.getControl();

        // Set the Figures text
        textEP.setLabelText(toEdit);
        
        
        // See RATLC00522324
        if (cellEditor instanceof TextCellEditorEx){
            ((TextCellEditorEx)cellEditor).setValueAndProcessEditOccured(toEdit);
        } else {
            cellEditor.setValue(toEdit);
        }
        
        // Set the controls text and position the caret at the end of the text
        textControl.setSelection(toEdit.length());
    }

    /**
     * Performs show and sets the edit string to be the initial character or string
     * @@param initialChar
     */
    public void show(char initialChar) {
        initialString = initialString.append(initialChar);
        show();
        if (SWT.getPlatform() != "carbon") { //$NON-NLS-1$ 
            // Set the cell editor text to the initial character
            setEditText(initialString.toString());
        }
    }
    
d448 18
a465 18
    private Font getZoomLevelFont(Font actualFont, Display display) {
        Object zoom = getEditPart().getViewer().getProperty(ZoomManager.class.toString());
        
        if (zoom != null) {
            double zoomLevel = ((ZoomManager)zoom).getZoom();
            
            if (zoomLevel == 1.0f) 
                return actualFont;
            
            FontData[] fd = new FontData[actualFont.getFontData().length];
            FontData tempFD = null;
            
            for (int i=0; i < fd.length; i++) {
                tempFD = actualFont.getFontData()[i];
                
                fd[i] = new FontData(tempFD.getName(),(int)(zoomLevel * tempFD.getHeight()),tempFD.getStyle());
            }
            
d479 10
a488 10
        }
        else
            return actualFont;
    }
    
    /**
     * Gets the tex extent scaled to the mapping mode
     */
    private Dimension getTextExtents(String s, Font font, IMapMode mm) {
        Dimension d = FigureUtilities.getTextExtents(s, font);
d494 2
a495 2
        return new Dimension(mm.DPtoLP(d.width), mm.DPtoLP(d.height));
    }
d505 5
a509 1
        IFigure fig = getEditPart().getFigure();
d512 1
a512 1
        this.zoomLevelFont = getZoomLevelFont(fig.getFont(), control.getDisplay());
d521 1
a521 1
    /**
d526 2
a527 2
     * The Text control does not allow for the cursor to appear at point location but
     * at a character location
d531 2
a532 2
    public void show(Point location) {      
        show();
d534 13
a546 33
        Rectangle iconBounds;
        Image icon;
        int textPlacement;
        String subStringText;
        String text;

        IFigure fig = getEditPart().getFigure();
        if (fig instanceof WrapLabel) {
            WrapLabel label = (WrapLabel) fig;
            iconBounds = label.getIconBounds().getCopy();
            icon = label.getIcon();
            textPlacement = label.getTextPlacement();
            subStringText = label.getSubStringText();
            text = label.getText();
        } else if (fig instanceof Label) {
            Label label = (Label) fig;
            iconBounds = label.getIconBounds().getCopy();
            icon = label.getIcon();
            textPlacement = label.getTextPlacement();
            subStringText = label.getSubStringText();
            text = label.getText();
        } else {
            sendClickToCellEditor(location);
            return;
        }

        Text textControl = (Text)getCellEditor().getControl();
        
        //we need to restore our wraplabel figure bounds after we are done
        Rectangle restoreRect = fig.getBounds().getCopy();
        
        Rectangle rect = fig.getBounds();
        fig.translateToAbsolute(rect);
d553 133
a685 132
        
        fig.translateToAbsolute(iconBounds);

        double avrLines =  fig.getBounds().height / (double)FigureUtilities.getFontMetrics(this.zoomLevelFont).getHeight();
        
        int xWidth = location.x - rect.x;
        
        if (icon != null && textPlacement == PositionConstants.EAST) 
            xWidth -= iconBounds.width;
        
        double yPercentage = (location.y - rect.y) / (double)rect.height;
        
        //calculate the line number the mouse clicked on.
        int lineNum = (int)Math.ceil(avrLines * yPercentage);
        
        //character count for caret positioning...
        int charCount = 0;
        
        StringTokenizer tokenizer = new StringTokenizer(subStringText, "\n"); //$NON-NLS-1$

        //calculate the total characters before linePos...
        for (int lineCount = 1; lineCount < lineNum; lineCount++) {
            if (tokenizer.hasMoreTokens()) {
                charCount += tokenizer.nextToken().length();
                
                //check if there is a user-inserted new line which will be accounted in the Text control...
                String newLineCheck = text.substring(charCount,charCount+1); 
                if (newLineCheck.equals("\r") || newLineCheck.equals("\n")) //$NON-NLS-1$ //$NON-NLS-2$
                    charCount++;
            }
            else {
                //our linePos calculation was wrong...revert to sending a mouse click...
                sendClickToCellEditor(location);
                fig.setBounds(restoreRect);
                return;
            }
        }
        
        //now count the last line's characters till the point where the mouse clicked...
        if (tokenizer.hasMoreTokens()) {
            String currentLineText = tokenizer.nextToken();
            
            IMapMode mm = MapModeUtil.getMapMode(fig);
            
            for (int i = 1; i <= currentLineText.length(); i++) {
                Dimension textExtent = getTextExtents(currentLineText.substring(0, i), this.zoomLevelFont, mm);
                fig.translateToAbsolute(textExtent);
                
                charCount++;
                
                if (textExtent.width >= xWidth)
                    break;
            }
            
            textControl.setSelection(charCount);
            
            fig.setBounds(restoreRect);
            
        }
        else {
            //our linePos calculation was wrong...revert to sending a mouse click...
            sendClickToCellEditor(location);
            fig.setBounds(restoreRect);
        }
    }
    
    private void sendClickToCellEditor(final Point location) {
        //make sure the diagram doesn't receive the click event..
        getCellEditor().getControl().setCapture(true);
        
        if (getCellEditor() != null && getCellEditor().getControl().getBounds().contains(location))
            sendMouseClick(location);
    }

    
    /**
     * 
     * Sends a SWT MouseUp and MouseDown event to the point location 
     * to the current Display
     * 
     * @@param location
     */
    private void sendMouseClick(final Point location) {     
        
        final Display currDisplay = Display.getCurrent();
        
        new Thread() {
            Event event;
            public void run() {
                    event = new Event();
                    event.type = SWT.MouseDown;
                    event.button = 1;
                    event.x = location.x;
                    event.y = location.y;
                    currDisplay.post(event);
                    event.type = SWT.MouseUp;
                    currDisplay.post(event);
            }
        }.start();
    }

    /* 
     * Overrides super unhookListeners to set listeners attached flag
     * This method prevents unhooking listeners twice if the UI thread is blocked.
     * For example, a validation dialog may block the thread
     */
    protected void unhookListeners() {
        if (listenersAttached) {
            listenersAttached = false;
            super.unhookListeners();
        }
    }

    /* 
     * Sets the listeners attached flag if the cell editor exists
     */
    protected void setCellEditor(CellEditor editor) {
        super.setCellEditor(editor);
        if (editor != null) {
            listenersAttached = true;
        }
    }

    public void showFeedback() {
        try {
            getEditPart().getRoot();
            super.showFeedback();
        } catch (Exception e) {
            // TODO: handle exception
        }
        
    }    
d699 8
a706 8
        copy = _actionBars.getGlobalActionHandler(ActionFactory.COPY.getId());
        paste = _actionBars.getGlobalActionHandler(ActionFactory.PASTE.getId());
        delete = _actionBars.getGlobalActionHandler(ActionFactory.DELETE.getId());
        selectAll = _actionBars.getGlobalActionHandler(ActionFactory.SELECT_ALL.getId());
        cut = _actionBars.getGlobalActionHandler(ActionFactory.CUT.getId());
        find = _actionBars.getGlobalActionHandler(ActionFactory.FIND.getId());
        undo = _actionBars.getGlobalActionHandler(ActionFactory.UNDO.getId());
        redo = _actionBars.getGlobalActionHandler(ActionFactory.REDO.getId());
d710 8
a717 8
        _actionBars.setGlobalActionHandler(ActionFactory.COPY.getId(), copy);
        _actionBars.setGlobalActionHandler(ActionFactory.PASTE.getId(), paste);
        _actionBars.setGlobalActionHandler(ActionFactory.DELETE.getId(), delete);
        _actionBars.setGlobalActionHandler(ActionFactory.SELECT_ALL.getId(), selectAll);
        _actionBars.setGlobalActionHandler(ActionFactory.CUT.getId(), cut);
        _actionBars.setGlobalActionHandler(ActionFactory.FIND.getId(), find);
        _actionBars.setGlobalActionHandler(ActionFactory.UNDO.getId(), undo);
        _actionBars.setGlobalActionHandler(ActionFactory.REDO.getId(), redo);
@


1.13.2.10
log
@[161793] gmf_R1_0_maintenance crevells 061129 StringIndexOutOfBoundsException on show() of TextDirectEditManager
Contributed by: Syed Atif Ali
@
text
@a594 3
                if (charCount >= text.length())
                    break;
                
@


1.12
log
@bugzilla 136867 gmf-head sshaw 060525 First character is doubled when user activates direct editor by typing text
@
text
@d69 5
a73 1
	
d291 2
d342 1
a342 1
	 * Performs show and sets the edit string to be the initial character
d346 1
a346 1
		
d350 1
a350 2
			String initialString = String.valueOf(initialChar);
			setEditText(initialString);
@


1.11
log
@bugzilla 126272 sshaw gmf-head 060515 The text cell editor flickers when clicking on the edge on a geoshape

Contributed by: Tom MacDougall
@
text
@d342 5
a346 3
		// Set the cell editor text to the initial character
		String initialString = String.valueOf(initialChar);
		setEditText(initialString);
@


1.10
log
@bugzilla 135694 gmf-head sshaw 060412 Make TextDirectEditManager more generic to handle GEF labels
@
text
@d360 3
a362 1
		sendMouseClick(location);	
@


1.9
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
d10 1
d16 2
d24 1
a48 4
 * 
 * To change this generated comment edit the template variable "typecomment":
 * Window>Preferences>Java>Templates. To enable and disable the creation of type
 * comments go to Window>Preferences>Java>Code Generation.
d106 26
a131 1
	
d138 2
a139 3
	public TextDirectEditManager(TextCompartmentEditPart source) {
		super(source, getTextCellEditorClass(source), 
				new TextCellEditorLocator(source.getLabel()));
d151 22
a172 2
	private static Class getTextCellEditorClass(TextCompartmentEditPart source){
		WrapLabel wrapLabel = source.getLabel();
d174 1
a174 1
		if (wrapLabel.isTextWrapped())
d193 1
a193 1
	protected Font getScaledFont(WrapLabel label) {
d211 1
a211 1
		TextCompartmentEditPart textEP = (TextCompartmentEditPart) getEditPart();
d215 1
a215 1
		WrapLabel label = textEP.getLabel();
d315 1
a315 1
		TextCompartmentEditPart textEP = (TextCompartmentEditPart) getEditPart();
a319 3
		// Get the Text Edit Part's Figure (WrapLabel)
		WrapLabel label = textEP.getLabel();
		Assert.isNotNull(label);
d321 1
a321 1
		label.setText(toEdit);
@


1.8
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d22 1
a23 1
import org.eclipse.gmf.runtime.draw2d.ui.internal.l10n.Draw2dResourceManager;
d159 1
a159 1
		Font newFont = Draw2dResourceManager.getInstance().getFont(null, data);
@


1.7
log
@Bugzilla 112227 gmf_head tmacdoug 051011 - The TextDirectEditManager should not show feedback for edit parts that are not active
@
text
@d24 1
a24 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d152 1
a152 1
		Dimension fontSize = new Dimension(0, MapMode.DPtoLP(data.getHeight()));
@


1.6
log
@Bugzilla 108875 gmf_head tmacdoug 051004 - Editing note text in full removes first inputed character
@
text
@d371 10
@


1.5
log
@bugzilla 110859 gmf-head sshaw 051003 TextDirectEditManager causes ClassCastException reaching for WrapLabel
@
text
@d291 1
a291 1
		textControl.selectAll();
@


1.4
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d113 3
a115 4
	public TextDirectEditManager(GraphicalEditPart source) {

		super(source, getTextCellEditorClass(source),
				new TextCellEditorLocator((WrapLabel)source.getFigure()));
d127 3
a129 4
	private static Class getTextCellEditorClass(GraphicalEditPart source){
		assert source.getFigure() instanceof WrapLabel;
		
		WrapLabel wrapLabel = (WrapLabel)source.getFigure();
@


1.3
log
@bugzilla 108310 gmf-head sshaw 050824 API analysis of draw2d / draw2d.render plug-ins
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2003.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.2
log
@RATLC00537541 rmp_head tmacdoug 050811 Cannot edit attribute from diagram after setting attribute type using content assist
@
text
@d12 1
d14 1
d18 7
a40 7
import org.eclipse.gmf.runtime.common.ui.contentassist.ContentAssistantHelper;
import org.eclipse.gmf.runtime.diagram.ui.editparts.TextCompartmentEditPart;
import org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel;
import org.eclipse.gmf.runtime.draw2d.ui.internal.l10n.Draw2dResourceManager;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
import org.eclipse.gmf.runtime.gef.ui.parts.TextCellEditorEx;

d67 38
d107 13
a119 2
	 * @@param source 
	 * @@param editorType 
d122 3
a124 2
	public TextDirectEditManager(GraphicalEditPart source, Class editorType,
			CellEditorLocator locator) {
d126 8
a133 1
		super(source, editorType, locator);
d135 1
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d153 1
@

