head	1.10;
access;
symbols
	v20081023-2107:1.8.2.2
	v20081022-1925:1.10
	v20081022-1005:1.8.2.2
	v20081020-0700:1.10
	v20080917-1925:1.10
	v20080916-2008:1.8.2.2
	v20080911-1728:1.10
	v20080911-1506:1.8.2.2
	v20080910-1520:1.10
	v20080910-1510:1.8.2.2
	v20080903-1520:1.10
	v20080903-1510:1.8.2.2
	v20080813-1510:1.8.2.2
	v20080811-1546:1.10
	v20080731-1520:1.9
	v20080725-1738:1.8.2.1
	v20080723-2246:1.9
	v20080723-2232:1.8.2.1
	v20080723-1700:1.8.2.1
	v20080722-1827:1.9
	v20080718-1700:1.8.2.1
	v20080718-1731:1.9
	v20080716-1600:1.8.2.1
	v20080716-1642:1.9
	R2_1_maintenance:1.8.0.2
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080610-1132:1.8
	v20080603-1553:1.8
	v20080527-1255:1.8
	v20080527-1151:1.5
	v20080516-1748:1.8
	v20080516-1143:1.8
	v20080512-1200:1.8
	v20080503-1740:1.8
	v20080501-2127:1.5
	v20080501-1739:1.8
	m20080429-1543:1.5
	v20080425-1959:1.8
	v20080417-1610:1.7
	v20080407-2250:1.7
	v20080407-0930:1.6
	v20080404-1111:1.6
	v20080328-1605:1.6
	v20080322-0000:1.6
	v20080222-1200:1.6
	v20080201-2010:1.6
	v20080201-0201:1.5
	v20080118-1129:1.5
	v20080114-2222:1.5
	v20080114-1111:1.5
	v20080107-1111:1.5
	v20071222-1111:1.5
	v20071214-1111:1.5
	v20071130-1111:1.5
	v20071124-0000:1.5
	v20071112-0000:1.5
	v20071108-0000:1.5
	v20071003-0000:1.5
	v20070915-0000:1.5
	v20070903-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.4
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070614-1400:1.5
	v20070608-1300:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070525-1500:1.5
	v20070518-1300:1.5
	bugzilla111892_group_support:1.5.0.2
	Root_bugzilla111892_group_support:1.5
	v20070504-1000:1.5
	v20070420-1000:1.5
	v20070413-1300:1.5
	v20070330-1300:1.5
	v20060330-1300:1.5
	v20070322-1100:1.5
	v20060316-0600:1.5
	v20070221-1500:1.5
	v20070208-1800:1.5
	v20070202-0200:1.3.2.2
	v20070119-1200:1.3.2.2
	v20070111-0800:1.3.2.2
	v20070105-1200:1.3.2.2
	v20070103-0300:1.5
	M4_20:1.5
	v20061218-1500:1.3.2.2
	v20061218-1200:1.5
	v20061214-0000:1.5
	M3_20:1.4
	v20061117-0800:1.4
	v20061027-1200:1.3.2.2
	v20061013-1330:1.4
	v20061012-1100:1.3.2.2
	v20060925-1700:1.3.2.2
	v20060919-0800:1.3.2.2
	v20060907-1100:1.3.2.1
	M1_20:1.3
	v20060831-1500:1.3
	v20060824-1600:1.3
	v20060817-1500:1.3
	v20060810-1700:1.3
	v20060803-1200:1.3
	v20060728-0500:1.3
	v20060721-1130:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1400:1.3
	v20060616-1200:1.3
	v20060609-1400:1.3
	v20060531-1730:1.3
	v20060530-1930:1.3
	v20060526-1200:1.3
	v20060519-0800:1.3
	v20060512-1000:1.3
	I20060512-1000:1.3
	I20060505-1400:1.3
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060202-1415:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.1
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1
	I20060105-1630:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.10
date	2008.08.08.21.44.02;	author aboyko;	state Exp;
branches;
next	1.9;
commitid	73c8489cbe224567;

1.9
date	2008.06.18.21.58.21;	author aboyko;	state Exp;
branches;
next	1.8;
commitid	5ebe485984fd4567;

1.8
date	2008.04.21.20.13.20;	author crevells;	state Exp;
branches
	1.8.2.1;
next	1.7;
commitid	495b480cf55f4567;

1.7
date	2008.04.08.02.16.38;	author ahunter;	state Exp;
branches;
next	1.6;
commitid	4d0547fad5804567;

1.6
date	2008.01.14.20.42.42;	author crevells;	state Exp;
branches;
next	1.5;
commitid	4925478bc9424567;

1.5
date	2006.11.24.22.04.24;	author crevells;	state Exp;
branches;
next	1.4;
commitid	739a45676c684567;

1.4
date	2006.10.03.15.02.05;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.28.02.32.24;	author cmahoney;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2006.01.23.20.55.26;	author cmahoney;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.04.19.15.37;	author cmahoney;	state Exp;
branches;
next	;

1.3.2.1
date	2006.09.06.15.39.23;	author cmahoney;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2006.09.13.16.43.40;	author ahunter;	state Exp;
branches;
next	;

1.8.2.1
date	2008.06.18.22.30.48;	author aboyko;	state Exp;
branches;
next	1.8.2.2;
commitid	5db248598c984567;

1.8.2.2
date	2008.08.08.21.41.53;	author aboyko;	state Exp;
branches;
next	;
commitid	72bd489cbda04567;


desc
@@


1.10
log
@[243594] gmf_head aboyko 080808 [Layout] Inifinite loop in BorderItemLocator#locateOnBorder(..)
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.figures;

import java.util.List;

import org.eclipse.core.runtime.Assert;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.gef.ui.figures.NodeFigure;

/**
 * BorderItemLocator works closely with border items in determining position.
 * BorderItemLocators use a figure as the bounds around which the
 * borderItemFigure can be placed. This figure may not necessarily be the main
 * figure.
 * <p>
 * BorderItemLocator allows intial placement ( N/W/S/E ) and is used in
 * conjunction with BorderItemSelectionEditPolicy for feedback.
 * <p>
 * Collision detection is provided so that border items cannot overlap and
 * therefore be hidden.
 * <p>
 * Border item movement is restricted along border of bordered shape.
 * 
 * @@author tisrar, jbruck, cmahoney
 */
public class BorderItemLocator
	implements IBorderItemLocator {

	/** the figure around which this border item appears */
	private IFigure parentFigure = null;

	private Rectangle constraint = new Rectangle(0, 0, 0, 0);

	private Dimension borderItemOffset = new Dimension(1, 1);

	private int preferredSide = PositionConstants.WEST;

	private int currentSide = PositionConstants.WEST;
	
	private int interval;
	
	/**
	 * Accessor to return the constraint location of the border item.
	 * 
	 * @@return the constraint
	 */
	protected Rectangle getConstraint() {
		return constraint;
	}
	
	/**
	 * The preferred side determines placement of figure.
	 * 
	 * @@param interval interval between border items used in collision resolving (must be > 0)
	 * @@param parentFigure
	 */
	public BorderItemLocator(int interval, IFigure parentFigure) {
		Assert.isTrue(interval > 0);
		Assert.isNotNull(parentFigure);
		this.parentFigure = parentFigure;
		this.interval = interval;
	}

	/**
	 * The preferred side determines placement of figure.
	 * 
	 * @@param parentFigure
	 */
	public BorderItemLocator(IFigure parentFigure) {
		this(MapModeUtil.getMapMode(parentFigure).DPtoLP(8), parentFigure);
	}

	/**
	 * The preferred side determines placement of figure.
	 * 
	 * @@param parentFigure
	 * @@param preferredSide
	 *            the preferred side of the parent figure on which to place this
	 *            border item as defined in {@@link PositionConstants}
	 */
	public BorderItemLocator(IFigure parentFigure, int preferredSide) {
		this(parentFigure);
		this.preferredSide = preferredSide;
	}
	
	/**
	 * The preferred side determines placement of figure.
	 * 
	 * @@param parentFigure
	 * @@param preferredSide
	 *            the preferred side of the parent figure on which to place this
	 *            border item as defined in {@@link PositionConstants}
	 * @@param interval interval between border items used in collision resolving (must be > 0)
	 */
	public BorderItemLocator(IFigure parentFigure, int preferredSide, int interval) {
		this(interval, parentFigure);
		this.preferredSide = preferredSide;
	}
	
	/**
	 * The preferred location overrides the preferred side.
	 * 
	 * @@param parentFigure
	 * @@param constraint
	 */
	public BorderItemLocator(IFigure borderItem, IFigure parentFigure,
			Rectangle constraint) {
		this(parentFigure);
		setConstraint(constraint);
	}

	/**
	 * The preferred location overrides the preferred side.
	 * 
	 * @@param parentFigure
	 * @@param constraint
	 * @@param interval interval between border items used in collision resolving (must be > 0)
	 */
	public BorderItemLocator(IFigure borderItem, IFigure parentFigure,
			Rectangle constraint, int interval) {
		this(interval, parentFigure);
		setConstraint(constraint);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.figures.IBorderItemLocator#resetPosition(org.eclipse.draw2d.geometry.Rectangle)
	 */
	public void setConstraint(Rectangle theConstraint) {
		this.constraint = theConstraint;

		if (theConstraint.getTopLeft().x == 0
			|| theConstraint.getTopLeft().y == 0) {
			setCurrentSideOfParent(getPreferredSideOfParent());
		}
	}

	/**
	 * Get the preferred location. If none has been previously set, use the
	 * preferred side to take an initial guess.
	 * 
	 * @@return point
	 */
	protected Point getPreferredLocation(IFigure borderItem) {
		Point constraintLocation = getConstraint().getLocation();
		Point ptAbsoluteLocation = this.getAbsoluteToBorder(constraintLocation);

		if (constraintLocation.x == 0 || constraintLocation.y == 0) {
			return getPreferredLocation(getPreferredSideOfParent(), borderItem);
		} else {
			return ptAbsoluteLocation;
		}
	}

	/**
	 * Utility to calculate the parent bounds with consideration for the handle
	 * bounds inset.
	 * 
	 * @@return <code>Rectangle</code> that is the bounds of the parent.
	 */
	protected Rectangle getParentBorder() {
		Rectangle bounds = getParentFigure().getBounds().getCopy();
		if (getParentFigure() instanceof NodeFigure) {
			bounds = ((NodeFigure) getParentFigure()).getHandleBounds()
				.getCopy();
		}
		return bounds;
	}
	
	/**
	 * Get an initial location based on the side. ( choose middle of the side )
	 * 
	 * @@param side
	 *            the preferred side of the parent figure on which to place this
	 *            border item as defined in {@@link PositionConstants}
	 * @@return point
	 */
	protected Point getPreferredLocation(int side, IFigure borderItem) {
		Rectangle bounds = getParentBorder();
		int parentFigureWidth = bounds.width;
		int parentFigureHeight = bounds.height;
		int parentFigureX = bounds.x;
		int parentFigureY = bounds.y;
		int x = parentFigureX;
		int y = parentFigureY;

		Dimension borderItemSize = getSize(borderItem);

		if (side == PositionConstants.WEST) {
			x = parentFigureX - borderItemSize.width
				+ getBorderItemOffset().width;
			y += parentFigureHeight / 2;
		} else if (side == PositionConstants.EAST) {
			x = parentFigureX + parentFigureWidth - getBorderItemOffset().width;
			y += parentFigureHeight / 2;
		} else if (side == PositionConstants.NORTH) {
			y = parentFigureY - borderItemSize.height
				+ getBorderItemOffset().height;
			x += parentFigureWidth / 2;
		} else if (side == PositionConstants.SOUTH) {
			x += parentFigureWidth / 2;
			y = parentFigureY + parentFigureHeight
				- getBorderItemOffset().height;
		}
		return new Point(x, y);
	}
	/**
	 * Ensure the suggested location actually lies on the parent boundary. The
	 * side takes precedence.
	 * 
	 * @@param suggestedLocation
	 * @@param suggestedSide
	 * @@return point
	 */
	protected Point locateOnParent(Point suggestedLocation,
			int suggestedSide, IFigure borderItem) {
		Rectangle bounds = getParentBorder();
		int parentFigureWidth = bounds.width;
		int parentFigureHeight = bounds.height;
		int parentFigureX = bounds.x;
		int parentFigureY = bounds.y;
		Dimension borderItemSize = getSize(borderItem);
		int newX = suggestedLocation.x;
		int newY = suggestedLocation.y;
		int westX = parentFigureX - borderItemSize.width
			+ getBorderItemOffset().width;
		int eastX = parentFigureX + parentFigureWidth
			- getBorderItemOffset().width;
		int southY = parentFigureY + parentFigureHeight
			- getBorderItemOffset().height;
		int northY = parentFigureY - borderItemSize.height
			+ getBorderItemOffset().height;
		if (suggestedSide == PositionConstants.WEST) {
			if (suggestedLocation.x != westX) {
				newX = westX;
			}
			if (suggestedLocation.y < bounds.getTopLeft().y) {
				newY = northY + borderItemSize.height;
			} else if (suggestedLocation.y > bounds.getBottomLeft().y
				- borderItemSize.height) {
				newY = southY - borderItemSize.height;
			}
		} else if (suggestedSide == PositionConstants.EAST) {
			if (suggestedLocation.x != eastX) {
				newX = eastX;
			}
			if (suggestedLocation.y < bounds.getTopLeft().y) {
				newY = northY + borderItemSize.height;
			} else if (suggestedLocation.y > bounds.getBottomLeft().y
				- borderItemSize.height) {
				newY = southY - borderItemSize.height;
			}
		} else if (suggestedSide == PositionConstants.SOUTH) {
			if (suggestedLocation.y != southY) {
				newY = southY;
			}
			if (suggestedLocation.x < bounds.getBottomLeft().x) {
				newX = westX + borderItemSize.width;
			} else if (suggestedLocation.x > bounds.getBottomRight().x
				- borderItemSize.width) {
				newX = eastX - borderItemSize.width;
			}
		} else { // NORTH
			if (suggestedLocation.y != northY) {
				newY = northY;
			}
			if (suggestedLocation.x < bounds.getBottomLeft().x) {
				newX = westX + borderItemSize.width;
			} else if (suggestedLocation.x > bounds.getBottomRight().x
				- borderItemSize.width) {
				newX = eastX - borderItemSize.width;
			}
		}
		return new Point(newX, newY);
	}

	/**
	 * Determine if the the given point conflicts with the position of an
	 * existing borderItemFigure and returns the conflicting border item figure
	 * 
	 * @@param recommendedLocation
	 * @@return the conflicting border item figure
	 */
	protected IFigure getConflictingBorderItemFigure(Point recommendedLocation,
			IFigure targetBorderItem) {
		Rectangle recommendedRect = new Rectangle(recommendedLocation,
			getSize(targetBorderItem));
		List borderItems = targetBorderItem.getParent().getChildren();
        
        // Only check those border items that would have already been
        // relocated. See Bugzilla#214799.
        int currentIndex = borderItems.indexOf(targetBorderItem);
        for (int i = 0; i < currentIndex; i++) {
            IFigure borderItem = (IFigure) borderItems.get(i);
			if (borderItem.isVisible()) {
				Rectangle rect = borderItem.getBounds().getCopy();
				if (rect.intersects(recommendedRect)) {
					return borderItem;
				}
			}
		}
		return null;
	}

	/**
	 * The preferred side takes precedence.
	 * 
	 * @@param suggestedLocation
	 * @@param suggestedSide
	 * @@param circuitCount
	 *            recursion count to avoid an infinite loop
	 * @@return point
	 */
	protected Point locateOnBorder(Point suggestedLocation,
			int suggestedSide, int circuitCount, IFigure borderItem) {
		Point recommendedLocation = locateOnParent(suggestedLocation,
			suggestedSide, borderItem);

		Dimension borderItemSize = getSize(borderItem);
		
		IFigure conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);

		if (circuitCount < 4 && conflictingBorderItem != null) {
			if (suggestedSide == PositionConstants.WEST) {
				do {
					calculateNextNonConflictingPosition(recommendedLocation,
							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
				} while (conflictingBorderItem != null);
				if (recommendedLocation.y > getParentBorder().getBottomLeft().y
					- borderItemSize.height) { // off the bottom,
					// wrap south
					return locateOnBorder(recommendedLocation,
						PositionConstants.SOUTH, circuitCount + 1, borderItem);
				} else if (recommendedLocation.y < getParentBorder().getTopLeft().y
					- borderItemSize.height) { // off the top, wrap north
					return locateOnBorder(recommendedLocation,
						PositionConstants.NORTH, circuitCount + 1, borderItem);
				}  
			} else if (suggestedSide == PositionConstants.SOUTH) {
				do {
					calculateNextNonConflictingPosition(recommendedLocation,
							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
				} while (conflictingBorderItem != null);
				if (recommendedLocation.x > getParentBorder().getBottomRight().x
					- borderItemSize.width) {
					return locateOnBorder(recommendedLocation,
						PositionConstants.EAST, circuitCount + 1, borderItem);
				} else if (recommendedLocation.x < getParentBorder().getBottomLeft().x
					- borderItemSize.width) {
					return locateOnBorder(recommendedLocation,
						PositionConstants.WEST, circuitCount + 1, borderItem);
				}
			} else if (suggestedSide == PositionConstants.EAST) {
				// move up the east side
				do {
					calculateNextNonConflictingPosition(recommendedLocation,
							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
				} while (conflictingBorderItem != null);
				if (recommendedLocation.y < getParentBorder().getTopRight().y) {
					// east is full, try north.
					return locateOnBorder(recommendedLocation,
						PositionConstants.NORTH, circuitCount + 1, borderItem);
				} else if (recommendedLocation.y > getParentBorder().getBottomRight().y) {
					// east is full, try south.
					return locateOnBorder(recommendedLocation,
						PositionConstants.SOUTH, circuitCount + 1, borderItem);
				}
			} else { // NORTH
				do {
					calculateNextNonConflictingPosition(recommendedLocation,
							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
				} while (conflictingBorderItem != null);
				if (recommendedLocation.x < getParentBorder().getTopLeft().x) {
					return locateOnBorder(recommendedLocation,
						PositionConstants.WEST, circuitCount + 1, borderItem);
				} else if (recommendedLocation.x > getParentBorder().getTopRight().x) {
					return locateOnBorder(recommendedLocation,
							PositionConstants.EAST, circuitCount + 1, borderItem);
				}
			}
		}
		return recommendedLocation;
	}

	/**
	 * Modifies the location of the border item (currentLocation) to avoid
	 * overlapping with the obstacle rectangle (another border item bounds)
	 * 
	 * @@param currentLocation
	 *            The current location of the border item
	 * @@param interval
	 *            The suggested spacing to try to find the next non-conflicting
	 *            position
	 * @@param currentSide
	 *            The current side of the border item
	 * @@param borderItem
	 *            The borderItem being relocated (here to be used by subclasses
	 *            if needed)
	 * @@param obstacle
	 *            The bounds of the border item conflicting with the border item
	 *            currently being relocated
	 */
	protected void calculateNextNonConflictingPosition(Point currentLocation,
			int interval, int currentSide, IFigure borderItem,
			Rectangle obstacle) {
		switch (currentSide) {
		case PositionConstants.WEST:
			currentLocation.y = obstacle.getBottomLeft().y + interval;
			break;
		case PositionConstants.SOUTH: // Move towards the east side
			currentLocation.x = obstacle.getBottomRight().x + interval;
			break;
		case PositionConstants.EAST:
			currentLocation.y = obstacle.getTopRight().y - interval
					- borderItem.getBounds().height;
			break;
		case PositionConstants.NORTH: // Move towards the west side
			currentLocation.x = obstacle.getTopLeft().x - interval
					- borderItem.getBounds().width;
			break;
		default:
			throw new IllegalArgumentException(
					"Invalid side argument: " //$NON-NLS-1$
							+ currentSide
							+ ". Should be the value from PositionConstants: WEST, EAST, NORTH or SOUTH"); //$NON-NLS-1$
		}
	}
	
	/**
	 * Convert the relative coords in the model to ones that are Relative to the
	 * container (absolute in respect to the main figure)
	 * 
	 * @@param ptRelativeOffset
	 * @@return point
	 */
	protected Point getAbsoluteToBorder(Point ptRelativeOffset) {
		Point parentOrigin = getParentBorder().getTopLeft();
		return parentOrigin.translate(ptRelativeOffset);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.figures.IBorderItemLocator#getValidLocation(org.eclipse.draw2d.geometry.Rectangle,
	 *      org.eclipse.draw2d.IFigure)
	 */
	public Rectangle getValidLocation(Rectangle proposedLocation,
			IFigure borderItem) {
		Rectangle realLocation = new Rectangle(proposedLocation);
		int side = findClosestSideOfParent(proposedLocation, getParentBorder());
		Point newTopLeft = locateOnBorder(realLocation.getTopLeft(), side, 0,
			borderItem);
		realLocation.setLocation(newTopLeft);
		return realLocation;
	}

	/**
	 * Find the closest side when x,y is inside parent.
	 * 
	 * @@param proposedLocation
	 * @@param parentBorder
	 * @@return draw constant
	 */
	public static int findClosestSideOfParent(Rectangle proposedLocation,
			Rectangle parentBorder) {
		// Rectangle parentBorder = getParentBorder();
		Point parentCenter = parentBorder.getCenter();
		Point childCenter = proposedLocation.getCenter();
		if (childCenter.x < parentCenter.x) // West, North or South.
		{
			if (childCenter.y < parentCenter.y) // west or north
			{
				// closer to west or north?
				Point parentTopLeft = parentBorder.getTopLeft();
				if ((childCenter.x - parentTopLeft.x) <= (childCenter.y - parentTopLeft.y)) {
					return PositionConstants.WEST;
				} else {
					return PositionConstants.NORTH;
				}
			} else { // west or south
				Point parentBottomLeft = parentBorder.getBottomLeft();
				if ((childCenter.x - parentBottomLeft.x) <= (parentBottomLeft.y - childCenter.y)) {
					return PositionConstants.WEST;
				} else {
					return PositionConstants.SOUTH;
				}
			}
		} else { // EAST, NORTH or SOUTH
			if (childCenter.y < parentCenter.y) // north or east
			{
				Point parentTopRight = parentBorder.getTopRight();
				if ((parentTopRight.x - childCenter.x) <= (childCenter.y - parentTopRight.y)) {
					return PositionConstants.EAST;
				} else {
					return PositionConstants.NORTH;
				}
			} else { // south or east.
				Point parentBottomRight = parentBorder.getBottomRight();
				if ((parentBottomRight.x - childCenter.x) <= (parentBottomRight.y - childCenter.y)) {
					return PositionConstants.EAST;
				} else {
					return PositionConstants.SOUTH;
				}
			}
		}
	}
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.draw2d.Locator#relocate(org.eclipse.draw2d.IFigure)
	 */
	public void relocate(IFigure borderItem) {
        Dimension size = getSize(borderItem);
		Rectangle rectSuggested = new Rectangle(
			getPreferredLocation(borderItem), size);
		int closestSide = findClosestSideOfParent(rectSuggested,
			getParentBorder());
		setPreferredSideOfParent(closestSide);

		Point ptNewLocation = locateOnBorder(getPreferredLocation(borderItem),
			getPreferredSideOfParent(), 0, borderItem);
        borderItem.setBounds(new Rectangle(ptNewLocation, size));

		setCurrentSideOfParent(findClosestSideOfParent(new Rectangle(ptNewLocation, size), getParentBorder()));
	}

	/**
	 * getter for the parent figure
	 * 
	 * @@return <code>IFigure</code>
	 */
	public IFigure getParentFigure() {
		return parentFigure;
	}

	/**
	 * @@return Returns the borderItemOffset.
	 */
	public Dimension getBorderItemOffset() {
		return borderItemOffset;
	}

	/**
	 * @@param borderItemOffset
	 *            The borderItemOffset to set.
	 */
	public void setBorderItemOffset(Dimension borderItemOffset) {
		this.borderItemOffset = borderItemOffset;
	}

	/**
	 * Returns the preferred side of the parent figure on which to place this
	 * border item.
	 * 
	 * @@return the preferred side of the parent figure on which to place this
	 *         border item as defined in {@@link PositionConstants}
	 */
	public int getPreferredSideOfParent() {
		return preferredSide;
	}

	/**
	 * Sets the preferred side of the parent figure on which to place this
	 * border item.
	 * 
	 * @@param preferredSide
	 *            the preferred side of the parent figure on which to place this
	 *            border item as defined in {@@link PositionConstants}
	 */
	public void setPreferredSideOfParent(int preferredSide) {
		this.preferredSide = preferredSide;
		setCurrentSideOfParent(preferredSide);
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.figures.IBorderItemLocator#getSide()
	 */
	public int getCurrentSideOfParent() {
		return currentSide;
	}

	/**
	 * Sets the side of the parent figure on which the border item should
	 * appear.
	 * 
	 * @@param side
	 *            the side on which this border item appears as defined in
	 *            {@@link PositionConstants}
	 */
	public void setCurrentSideOfParent(int side) {
		this.currentSide = side;
	}
	
	/**
	 * Gets the size of the border item figure.
	 * @@param borderItem
	 * @@return the size of the border item figure.
	 */
	protected final Dimension getSize(IFigure borderItem) {
        Dimension size = getConstraint().getSize();
        if (size.isEmpty()) {
        	size = borderItem.getPreferredSize();
        }
        return size;
	}
}
@


1.9
log
@[237202] gmf_head aboyko 080618 Finding non-conflicting location of border items not working properly in all scenarios
@
text
@d54 3
a56 1

d65 13
d85 1
a85 2
		Assert.isNotNull(parentFigure);
		this.parentFigure = parentFigure;
d102 14
d127 13
d185 1
a185 1

a334 3
		int vertical_gap = MapModeUtil.getMapMode(getParentFigure()).DPtoLP(8);
		int horizontal_gap = MapModeUtil.getMapMode(getParentFigure())
			.DPtoLP(8);
d342 2
a343 3
					recommendedLocation.y = calculateNextNonConflictingPosition(
							conflictingBorderItem.getBounds().getBottomLeft().y,
							vertical_gap, suggestedSide, borderItem);
d358 2
a359 3
					recommendedLocation.x = calculateNextNonConflictingPosition(
							conflictingBorderItem.getBounds().getTopRight().x,
							horizontal_gap, suggestedSide, borderItem);
d374 2
a375 3
					recommendedLocation.y = calculateNextNonConflictingPosition(
							conflictingBorderItem.getBounds().getLocation().y,
							vertical_gap, suggestedSide, borderItem);
d389 2
a390 3
					recommendedLocation.x = calculateNextNonConflictingPosition(
							conflictingBorderItem.getBounds().getLocation().x,
							horizontal_gap, suggestedSide, borderItem);
d406 20
a425 11
	 * Default behavior is to simply check in a counter clockwise direction.
	 * Note:  if the currentSide is EAST or WEST, the y co-oridinate is passed as the current position.  Otherwise,
	 * if NORTH or SOUTH is the currentSide, then the x co-oridinate of the borderitem is passed.
	 * 
	 * @@param currentPosition	The current x or y co-ordinate of the border item
	 * @@param interval			The suggested spacing to try to find the next non-conflicting position
	 * @@param currentSide		The current side of the border item 
	 * @@param borderItem 		The borderItem being relocated (here to be used by subclasses if needed)
	 * @@return the next possible non-conflicting position
	 */
	protected int calculateNextNonConflictingPosition(int currentPosition, int interval, int currentSide, IFigure borderItem) {
d427 19
a445 7
			case PositionConstants.WEST:  // Fall through  -- Move down the west side
			case PositionConstants.SOUTH: // Move towards the east side
				return currentPosition + interval;
			case PositionConstants.EAST:  // Fall through - Move towards the north side
			case PositionConstants.NORTH: // Fall through - Move towards the west side
			default: /* Should never get here, but if we do, we'll default to subtraction */
				return currentPosition - interval;
@


1.8
log
@[219849, 227021] gmf_head crevells 080421 Border Item fixes
@
text
@d184 1
a184 1
	 * side takes precendence.
d190 1
a190 1
	private Point locateOnParent(Point suggestedLocation,
d254 1
a254 1
	 * existing borderItemFigure.
d257 1
a257 1
	 * @@return <code>ture</code> or <code>false</code>
d259 1
a259 1
	private boolean conflicts(Point recommendedLocation,
d273 1
a273 1
					return true;
d277 1
a277 1
		return false;
d281 1
a281 1
	 * The preferred side takes precendence.
d289 1
a289 1
	private Point locateOnBorder(Point suggestedLocation,
d298 2
d301 1
a301 1
		if (circuitCount < 4 && conflicts(recommendedLocation, borderItem)) {
d304 5
a308 3
					recommendedLocation.y += borderItemSize.height
						+ vertical_gap;
				} while (conflicts(recommendedLocation, borderItem));
d314 5
a318 1
				}
d321 5
a325 3
					recommendedLocation.x += borderItemSize.width
						+ horizontal_gap;
				} while (conflicts(recommendedLocation, borderItem));
d330 4
d338 5
a342 2
					recommendedLocation.y -= (borderItemSize.height + vertical_gap);
				} while (conflicts(recommendedLocation, borderItem));
d347 4
d354 5
a358 2
					recommendedLocation.x -= (borderItemSize.width + horizontal_gap);
				} while (conflicts(recommendedLocation, borderItem));
d362 3
d372 23
@


1.8.2.1
log
@[237202] gmf_R2_1_maintenance aboyko 080618 Finding non-conflicting location of border items not working properly in all scenarios
@
text
@d184 1
a184 1
	 * side takes precedence.
d190 1
a190 1
	protected Point locateOnParent(Point suggestedLocation,
d254 1
a254 1
	 * existing borderItemFigure and returns the conflicting border item figure
d257 1
a257 1
	 * @@return the conflicting border item figure
d259 1
a259 1
	protected IFigure getConflictingBorderItemFigure(Point recommendedLocation,
d273 1
a273 1
					return borderItem;
d277 1
a277 1
		return null;
d281 1
a281 1
	 * The preferred side takes precedence.
d289 1
a289 1
	protected Point locateOnBorder(Point suggestedLocation,
a297 2
		
		IFigure conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
d299 1
a299 1
		if (circuitCount < 4 && conflictingBorderItem != null) {
d302 3
a304 5
					recommendedLocation.y = calculateNextNonConflictingPosition(
							conflictingBorderItem.getBounds().getBottomLeft().y,
							vertical_gap, suggestedSide, borderItem);
					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
				} while (conflictingBorderItem != null);
d310 1
a310 5
				} else if (recommendedLocation.y < getParentBorder().getTopLeft().y
					- borderItemSize.height) { // off the top, wrap north
					return locateOnBorder(recommendedLocation,
						PositionConstants.NORTH, circuitCount + 1, borderItem);
				}  
d313 3
a315 5
					recommendedLocation.x = calculateNextNonConflictingPosition(
							conflictingBorderItem.getBounds().getTopRight().x,
							horizontal_gap, suggestedSide, borderItem);
					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
				} while (conflictingBorderItem != null);
a319 4
				} else if (recommendedLocation.x < getParentBorder().getBottomLeft().x
					- borderItemSize.width) {
					return locateOnBorder(recommendedLocation,
						PositionConstants.WEST, circuitCount + 1, borderItem);
d324 2
a325 5
					recommendedLocation.y = calculateNextNonConflictingPosition(
							conflictingBorderItem.getBounds().getLocation().y,
							vertical_gap, suggestedSide, borderItem);
					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
				} while (conflictingBorderItem != null);
a329 4
				} else if (recommendedLocation.y > getParentBorder().getBottomRight().y) {
					// east is full, try south.
					return locateOnBorder(recommendedLocation,
						PositionConstants.SOUTH, circuitCount + 1, borderItem);
d333 2
a334 5
					recommendedLocation.x = calculateNextNonConflictingPosition(
							conflictingBorderItem.getBounds().getLocation().x,
							horizontal_gap, suggestedSide, borderItem);
					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
				} while (conflictingBorderItem != null);
a337 3
				} else if (recommendedLocation.x > getParentBorder().getTopRight().x) {
					return locateOnBorder(recommendedLocation,
							PositionConstants.EAST, circuitCount + 1, borderItem);
a344 23
	 * Default behavior is to simply check in a counter clockwise direction.
	 * Note:  if the currentSide is EAST or WEST, the y co-oridinate is passed as the current position.  Otherwise,
	 * if NORTH or SOUTH is the currentSide, then the x co-oridinate of the borderitem is passed.
	 * 
	 * @@param currentPosition	The current x or y co-ordinate of the border item
	 * @@param interval			The suggested spacing to try to find the next non-conflicting position
	 * @@param currentSide		The current side of the border item 
	 * @@param borderItem 		The borderItem being relocated (here to be used by subclasses if needed)
	 * @@return the next possible non-conflicting position
	 */
	protected int calculateNextNonConflictingPosition(int currentPosition, int interval, int currentSide, IFigure borderItem) {
		switch (currentSide) {
			case PositionConstants.WEST:  // Fall through  -- Move down the west side
			case PositionConstants.SOUTH: // Move towards the east side
				return currentPosition + interval;
			case PositionConstants.EAST:  // Fall through - Move towards the north side
			case PositionConstants.NORTH: // Fall through - Move towards the west side
			default: /* Should never get here, but if we do, we'll default to subtraction */
				return currentPosition - interval;
		}
	}
	
	/**
@


1.8.2.2
log
@[243594] gmf_R2_1_maintenance aboyko 080808 [Layout] Inifinite loop in BorderItemLocator#locateOnBorder(..)
@
text
@d54 1
a54 3
	
	private int interval;
	
d63 1
a63 1
	
a66 1
	 * @@param interval interval between border items used in collision resolving (must be > 0)
d69 1
a69 2
	public BorderItemLocator(int interval, IFigure parentFigure) {
		Assert.isTrue(interval > 0);
a71 10
		this.interval = interval;
	}

	/**
	 * The preferred side determines placement of figure.
	 * 
	 * @@param parentFigure
	 */
	public BorderItemLocator(IFigure parentFigure) {
		this(MapModeUtil.getMapMode(parentFigure).DPtoLP(8), parentFigure);
a87 14
	 * The preferred side determines placement of figure.
	 * 
	 * @@param parentFigure
	 * @@param preferredSide
	 *            the preferred side of the parent figure on which to place this
	 *            border item as defined in {@@link PositionConstants}
	 * @@param interval interval between border items used in collision resolving (must be > 0)
	 */
	public BorderItemLocator(IFigure parentFigure, int preferredSide, int interval) {
		this(interval, parentFigure);
		this.preferredSide = preferredSide;
	}
	
	/**
a98 13
	/**
	 * The preferred location overrides the preferred side.
	 * 
	 * @@param parentFigure
	 * @@param constraint
	 * @@param interval interval between border items used in collision resolving (must be > 0)
	 */
	public BorderItemLocator(IFigure borderItem, IFigure parentFigure,
			Rectangle constraint, int interval) {
		this(interval, parentFigure);
		setConstraint(constraint);
	}

d144 1
a144 1
	
d294 3
d304 3
a306 2
					calculateNextNonConflictingPosition(recommendedLocation,
							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
d321 3
a323 2
					calculateNextNonConflictingPosition(recommendedLocation,
							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
d338 3
a340 2
					calculateNextNonConflictingPosition(recommendedLocation,
							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
d354 3
a356 2
					calculateNextNonConflictingPosition(recommendedLocation,
							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
d372 11
a382 20
	 * Modifies the location of the border item (currentLocation) to avoid
	 * overlapping with the obstacle rectangle (another border item bounds)
	 * 
	 * @@param currentLocation
	 *            The current location of the border item
	 * @@param interval
	 *            The suggested spacing to try to find the next non-conflicting
	 *            position
	 * @@param currentSide
	 *            The current side of the border item
	 * @@param borderItem
	 *            The borderItem being relocated (here to be used by subclasses
	 *            if needed)
	 * @@param obstacle
	 *            The bounds of the border item conflicting with the border item
	 *            currently being relocated
	 */
	protected void calculateNextNonConflictingPosition(Point currentLocation,
			int interval, int currentSide, IFigure borderItem,
			Rectangle obstacle) {
d384 7
a390 19
		case PositionConstants.WEST:
			currentLocation.y = obstacle.getBottomLeft().y + interval;
			break;
		case PositionConstants.SOUTH: // Move towards the east side
			currentLocation.x = obstacle.getBottomRight().x + interval;
			break;
		case PositionConstants.EAST:
			currentLocation.y = obstacle.getTopRight().y - interval
					- borderItem.getBounds().height;
			break;
		case PositionConstants.NORTH: // Move towards the west side
			currentLocation.x = obstacle.getTopLeft().x - interval
					- borderItem.getBounds().width;
			break;
		default:
			throw new IllegalArgumentException(
					"Invalid side argument: " //$NON-NLS-1$
							+ currentSide
							+ ". Should be the value from PositionConstants: WEST, EAST, NORTH or SOUTH"); //$NON-NLS-1$
@


1.7
log
@[226065] gmf-head ahunter 080407 Fix warning: The type Assert is deprecated
@
text
@a110 1
		getParentFigure().revalidate();
d262 1
a262 1
			targetBorderItem.getSize());
d437 1
a437 2
		borderItem.setLocation(ptNewLocation);
        borderItem.setSize(size);
d516 1
a516 1
        if (LayoutHelper.UNDEFINED.getSize().equals(size)) {
@


1.6
log
@[214799] gmf_head crevells 080114 Border items near top-left corner of shape move when diagram is reopened
@
text
@a14 1
import java.util.ListIterator;
d16 1
a23 1
import org.eclipse.jface.util.Assert;
@


1.5
log
@[154536] gmf_head crevells 061124 BorderItemLocator never sets the size for side-affixed figures forcing all of them to have width=height=0
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
d266 6
a271 3
		ListIterator iterator = borderItems.listIterator();
		while (iterator.hasNext()) {
			IFigure borderItem = (IFigure) iterator.next();
d274 1
a274 2
				if (borderItem != targetBorderItem
					&& rect.intersects(recommendedRect)) {
@


1.4
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d164 1
a164 1
		Rectangle borderItemBounds = borderItem.getBounds();
d167 1
a167 1
			x = parentFigureX - borderItemBounds.width
d174 1
a174 1
			y = parentFigureY - borderItemBounds.height
d199 1
a199 1
		Rectangle borderItemBounds = borderItem.getBounds();
d202 1
a202 1
		int westX = parentFigureX - borderItemBounds.width
d208 1
a208 1
		int northY = parentFigureY - borderItemBounds.height
d215 1
a215 1
				newY = northY + borderItemBounds.height;
d217 2
a218 2
				- borderItemBounds.height) {
				newY = southY - borderItemBounds.height;
d225 1
a225 1
				newY = northY + borderItemBounds.height;
d227 2
a228 2
				- borderItemBounds.height) {
				newY = southY - borderItemBounds.height;
d235 1
a235 1
				newX = westX + borderItemBounds.width;
d237 2
a238 2
				- borderItemBounds.width) {
				newX = eastX - borderItemBounds.width;
d245 1
a245 1
				newX = westX + borderItemBounds.width;
d247 2
a248 2
				- borderItemBounds.width) {
				newX = eastX - borderItemBounds.width;
d297 1
a297 1
		Rectangle borderItemBounds = borderItem.getBounds();
d302 1
a302 1
					recommendedLocation.y += borderItemBounds.height
d306 1
a306 1
					- borderItemBounds.height) { // off the bottom,
d313 1
a313 1
					recommendedLocation.x += borderItemBounds.width
d317 1
a317 1
					- borderItemBounds.width) {
d324 1
a324 1
					recommendedLocation.y -= (borderItemBounds.height + vertical_gap);
d333 1
a333 1
					recommendedLocation.x -= (borderItemBounds.width + horizontal_gap);
d428 1
d430 1
a430 1
			getPreferredLocation(borderItem), borderItem.getBounds().getSize());
d438 1
d440 1
a440 2
		setCurrentSideOfParent(findClosestSideOfParent(new Rectangle(ptNewLocation, borderItem
			.getBounds().getSize()), getParentBorder()));
d509 13
@


1.3
log
@Bugzilla#109422 gmf_head cmahoney 060227 Removing deprecated API
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d324 1
a324 2
					recommendedLocation.y -= borderItemBounds.height
						- vertical_gap;
d333 1
a333 2
					recommendedLocation.x -= borderItemBounds.width
						- horizontal_gap;
@


1.3.2.1
log
@Bugzilla#150018 gmf_R1_0_maintenance cmahoney 060906 east and north side border items overlap; can cause infinite loop / crash
Contributed by: Jennifer Cormier <jcormier@@acm.org>
@
text
@d324 2
a325 1
					recommendedLocation.y -= (borderItemBounds.height + vertical_gap);
d334 2
a335 1
					recommendedLocation.x -= (borderItemBounds.width + horizontal_gap);
@


1.3.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
@


1.2
log
@Bugzilla#121457 gmf_head cmahoney 060123 Removing org.eclipse.gmf.runtime.diagram.ui.util.DrawConstant
@
text
@a21 1
import org.eclipse.gmf.runtime.diagram.ui.util.DrawConstant;
a77 44
	 * @@param borderItemFigure
	 * @@param parentFigure
	 * @@deprecated 06/01/23 Use {@@link #BorderItemLocator(IFigure, int)}. See
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=121457
	 */
	public BorderItemLocator(IFigure parentFigure, DrawConstant preferredSide) {
		this(parentFigure);
		if (preferredSide == DrawConstant.BOTTOM) {
			this.preferredSide = PositionConstants.BOTTOM;
		} else if (preferredSide == DrawConstant.CENTER) {
			this.preferredSide = PositionConstants.CENTER;
		} else if (preferredSide == DrawConstant.EAST) {
			this.preferredSide = PositionConstants.EAST;
		} else if (preferredSide == DrawConstant.HORIZONTAL) {
			this.preferredSide = PositionConstants.HORIZONTAL;
		} else if (preferredSide == DrawConstant.LEFT) {
			this.preferredSide = PositionConstants.LEFT;
		} else if (preferredSide == DrawConstant.NORTH) {
			this.preferredSide = PositionConstants.NORTH;
		} else if (preferredSide == DrawConstant.NORTH_EAST) {
			this.preferredSide = PositionConstants.NORTH_EAST;
		} else if (preferredSide == DrawConstant.NORTH_WEST) {
			this.preferredSide = PositionConstants.NORTH_WEST;
		} else if (preferredSide == DrawConstant.RIGHT) {
			this.preferredSide = PositionConstants.RIGHT;
		} else if (preferredSide == DrawConstant.SOUTH) {
			this.preferredSide = PositionConstants.SOUTH;
		} else if (preferredSide == DrawConstant.SOUTH_EAST) {
			this.preferredSide = PositionConstants.SOUTH_EAST;
		} else if (preferredSide == DrawConstant.SOUTH_WEST) {
			this.preferredSide = PositionConstants.SOUTH_WEST;
		} else if (preferredSide == DrawConstant.TOP) {
			this.preferredSide = PositionConstants.TOP;
		} else if (preferredSide == DrawConstant.VERTICAL) {
			this.preferredSide = PositionConstants.VERTICAL;
		} else if (preferredSide == DrawConstant.WEST) {
			this.preferredSide = PositionConstants.WEST;
		}
		this.preferredSide = PositionConstants.WEST;
	}

	/**
	 * The preferred side determines placement of figure.
	 * 
a150 38
	 * @@return point
	 * @@deprecated 06/01/23 Use {@@link #getPreferredLocation(int, IFigure)}. See
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=121457
	 */
	protected Point getPreferredLocation(DrawConstant side, IFigure borderItem) {
		Rectangle bounds = getParentBorder();
		int parentFigureWidth = bounds.width;
		int parentFigureHeight = bounds.height;
		int parentFigureX = bounds.x;
		int parentFigureY = bounds.y;
		int x = parentFigureX;
		int y = parentFigureY;

		Rectangle borderItemBounds = borderItem.getBounds();

		if (side == DrawConstant.WEST) {
			x = parentFigureX - borderItemBounds.width
				+ getBorderItemOffset().width;
			y += parentFigureHeight / 2;
		} else if (side == DrawConstant.EAST) {
			x = parentFigureX + parentFigureWidth - getBorderItemOffset().width;
			y += parentFigureHeight / 2;
		} else if (side == DrawConstant.NORTH) {
			y = parentFigureY - borderItemBounds.height
				+ getBorderItemOffset().height;
			x += parentFigureWidth / 2;
		} else if (side == DrawConstant.SOUTH) {
			x += parentFigureWidth / 2;
			y = parentFigureY + parentFigureHeight
				- getBorderItemOffset().height;
		}
		return new Point(x, y);
	}

	/**
	 * Get an initial location based on the side. ( choose middle of the side )
	 * 
	 * @@param side
a379 53
	 * @@deprecated 06/01/23 Use {@@link #findClosestSideOfParent(Rectangle, Rectangle)}. See
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=121457
	 */
	public static DrawConstant findClosestSide(Rectangle proposedLocation,
			Rectangle parentBorder) {
		// Rectangle parentBorder = getParentBorder();
		Point parentCenter = parentBorder.getCenter();
		Point childCenter = proposedLocation.getCenter();
		if (childCenter.x < parentCenter.x) // West, North or South.
		{
			if (childCenter.y < parentCenter.y) // west or north
			{
				// closer to west or north?
				Point parentTopLeft = parentBorder.getTopLeft();
				if ((childCenter.x - parentTopLeft.x) <= (childCenter.y - parentTopLeft.y)) {
					return DrawConstant.WEST;
				} else {
					return DrawConstant.NORTH;
				}
			} else { // west or south
				Point parentBottomLeft = parentBorder.getBottomLeft();
				if ((childCenter.x - parentBottomLeft.x) <= (parentBottomLeft.y - childCenter.y)) {
					return DrawConstant.WEST;
				} else {
					return DrawConstant.SOUTH;
				}
			}
		} else { // EAST, NORTH or SOUTH
			if (childCenter.y < parentCenter.y) // north or east
			{
				Point parentTopRight = parentBorder.getTopRight();
				if ((parentTopRight.x - childCenter.x) <= (childCenter.y - parentTopRight.y)) {
					return DrawConstant.EAST;
				} else {
					return DrawConstant.NORTH;
				}
			} else { // south or east.
				Point parentBottomRight = parentBorder.getBottomRight();
				if ((parentBottomRight.x - childCenter.x) <= (parentBottomRight.y - childCenter.y)) {
					return DrawConstant.EAST;
				} else {
					return DrawConstant.SOUTH;
				}
			}
		}
	}

	/**
	 * Find the closest side when x,y is inside parent.
	 * 
	 * @@param proposedLocation
	 * @@param parentBorder
	 * @@return draw constant
a468 40
	 * @@return Returns the preferredSide.
	 * @@deprecated 06/01/23 Use {@@link #getCurrentSideOfParent()}. See
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=121457
	 */
	public DrawConstant getPreferredSide() {
		if (preferredSide == PositionConstants.BOTTOM) {
			return DrawConstant.BOTTOM;
		} else if (preferredSide == PositionConstants.CENTER) {
			return DrawConstant.CENTER;
		} else if (preferredSide == PositionConstants.EAST) {
			return DrawConstant.EAST;
		} else if (preferredSide == PositionConstants.HORIZONTAL) {
			return DrawConstant.HORIZONTAL;
		} else if (preferredSide == PositionConstants.LEFT) {
			return DrawConstant.LEFT;
		} else if (preferredSide == PositionConstants.NORTH) {
			return DrawConstant.NORTH;
		} else if (preferredSide == PositionConstants.NORTH_EAST) {
			return DrawConstant.NORTH_EAST;
		} else if (preferredSide == PositionConstants.NORTH_WEST) {
			return DrawConstant.NORTH_WEST;
		} else if (preferredSide == PositionConstants.RIGHT) {
			return DrawConstant.RIGHT;
		} else if (preferredSide == PositionConstants.SOUTH) {
			return DrawConstant.SOUTH;
		} else if (preferredSide == PositionConstants.SOUTH_EAST) {
			return DrawConstant.SOUTH_EAST;
		} else if (preferredSide == PositionConstants.SOUTH_WEST) {
			return DrawConstant.SOUTH_WEST;
		} else if (preferredSide == PositionConstants.TOP) {
			return DrawConstant.TOP;
		} else if (preferredSide == PositionConstants.VERTICAL) {
			return DrawConstant.VERTICAL;
		} else if (preferredSide == PositionConstants.WEST) {
			return DrawConstant.WEST;
		}
		return DrawConstant.WEST;
	}

	/**
a477 42
	
	/**
	 * @@param preferredSide
	 *            The preferredSide to set.
	 * @@deprecated 06/01/23 Use {@@link #setPreferredSideOnParent()}. See
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=121457
	 */
	public void setPreferredSide(DrawConstant preferredSide) {
		if (preferredSide == DrawConstant.BOTTOM) {
			this.preferredSide = PositionConstants.BOTTOM;
		} else if (preferredSide == DrawConstant.CENTER) {
			this.preferredSide = PositionConstants.CENTER;
		} else if (preferredSide == DrawConstant.EAST) {
			this.preferredSide = PositionConstants.EAST;
		} else if (preferredSide == DrawConstant.HORIZONTAL) {
			this.preferredSide = PositionConstants.HORIZONTAL;
		} else if (preferredSide == DrawConstant.LEFT) {
			this.preferredSide = PositionConstants.LEFT;
		} else if (preferredSide == DrawConstant.NORTH) {
			this.preferredSide = PositionConstants.NORTH;
		} else if (preferredSide == DrawConstant.NORTH_EAST) {
			this.preferredSide = PositionConstants.NORTH_EAST;
		} else if (preferredSide == DrawConstant.NORTH_WEST) {
			this.preferredSide = PositionConstants.NORTH_WEST;
		} else if (preferredSide == DrawConstant.RIGHT) {
			this.preferredSide = PositionConstants.RIGHT;
		} else if (preferredSide == DrawConstant.SOUTH) {
			this.preferredSide = PositionConstants.SOUTH;
		} else if (preferredSide == DrawConstant.SOUTH_EAST) {
			this.preferredSide = PositionConstants.SOUTH_EAST;
		} else if (preferredSide == DrawConstant.SOUTH_WEST) {
			this.preferredSide = PositionConstants.SOUTH_WEST;
		} else if (preferredSide == DrawConstant.TOP) {
			this.preferredSide = PositionConstants.TOP;
		} else if (preferredSide == DrawConstant.VERTICAL) {
			this.preferredSide = PositionConstants.VERTICAL;
		} else if (preferredSide == DrawConstant.WEST) {
			this.preferredSide = PositionConstants.WEST;
		}
		this.preferredSide = PositionConstants.WEST;
		setCurrentSideOfParent(this.preferredSide);
	}
a491 39
	/**
	 * @@deprecated 06/01/23 Use {@@link #getCurrentSideOnParent()}. See
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=121457
	 */
	public DrawConstant getCurrentSide() {
		if (currentSide == PositionConstants.BOTTOM) {
			return DrawConstant.BOTTOM;
		} else if (currentSide == PositionConstants.CENTER) {
			return DrawConstant.CENTER;
		} else if (currentSide == PositionConstants.EAST) {
			return DrawConstant.EAST;
		} else if (currentSide == PositionConstants.HORIZONTAL) {
			return DrawConstant.HORIZONTAL;
		} else if (currentSide == PositionConstants.LEFT) {
			return DrawConstant.LEFT;
		} else if (currentSide == PositionConstants.NORTH) {
			return DrawConstant.NORTH;
		} else if (currentSide == PositionConstants.NORTH_EAST) {
			return DrawConstant.NORTH_EAST;
		} else if (currentSide == PositionConstants.NORTH_WEST) {
			return DrawConstant.NORTH_WEST;
		} else if (currentSide == PositionConstants.RIGHT) {
			return DrawConstant.RIGHT;
		} else if (currentSide == PositionConstants.SOUTH) {
			return DrawConstant.SOUTH;
		} else if (currentSide == PositionConstants.SOUTH_EAST) {
			return DrawConstant.SOUTH_EAST;
		} else if (currentSide == PositionConstants.SOUTH_WEST) {
			return DrawConstant.SOUTH_WEST;
		} else if (currentSide == PositionConstants.TOP) {
			return DrawConstant.TOP;
		} else if (currentSide == PositionConstants.VERTICAL) {
			return DrawConstant.VERTICAL;
		} else if (currentSide == PositionConstants.WEST) {
			return DrawConstant.WEST;
		}
		return DrawConstant.WEST;
	}
	
a497 41
	
	/**
	 * @@param currentSide
	 *            The currentSide to set.
	 * @@deprecated 06/01/23 Use {@@link #getSide()}. See
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=121457
	 */
	public void setCurrentSide(DrawConstant side) {
		if (side == DrawConstant.BOTTOM) {
			currentSide = PositionConstants.BOTTOM;
		} else if (side == DrawConstant.CENTER) {
			currentSide = PositionConstants.CENTER;
		} else if (side == DrawConstant.EAST) {
			currentSide = PositionConstants.EAST;
		} else if (side == DrawConstant.HORIZONTAL) {
			currentSide = PositionConstants.HORIZONTAL;
		} else if (side == DrawConstant.LEFT) {
			currentSide = PositionConstants.LEFT;
		} else if (side == DrawConstant.NORTH) {
			currentSide = PositionConstants.NORTH;
		} else if (side == DrawConstant.NORTH_EAST) {
			currentSide = PositionConstants.NORTH_EAST;
		} else if (side == DrawConstant.NORTH_WEST) {
			currentSide = PositionConstants.NORTH_WEST;
		} else if (side == DrawConstant.RIGHT) {
			currentSide = PositionConstants.RIGHT;
		} else if (side == DrawConstant.SOUTH) {
			currentSide = PositionConstants.SOUTH;
		} else if (side == DrawConstant.SOUTH_EAST) {
			currentSide = PositionConstants.SOUTH_EAST;
		} else if (side == DrawConstant.SOUTH_WEST) {
			currentSide = PositionConstants.SOUTH_WEST;
		} else if (side == DrawConstant.TOP) {
			currentSide = PositionConstants.TOP;
		} else if (side == DrawConstant.VERTICAL) {
			currentSide = PositionConstants.VERTICAL;
		} else if (side == DrawConstant.WEST) {
			currentSide = PositionConstants.WEST;
		}
		currentSide = PositionConstants.WEST;
	}
@


1.1
log
@Bugzilla#111935 gmf_head cmahoney 060104 Border Item Infrastructure Consistency Issues
@
text
@d18 1
d53 1
a53 1
	private DrawConstant preferredSide = DrawConstant.WEST;
d55 1
a55 1
	private DrawConstant currentSide = DrawConstant.WEST;
d81 2
d86 44
d132 1
a132 1

d155 1
a155 1
			setCurrentSide(getPreferredSide());
d171 1
a171 1
			return getPreferredLocation(getPreferredSide(), borderItem);
d197 2
d231 37
d276 1
a276 1
			DrawConstant suggestedSide, IFigure borderItem) {
d293 1
a293 1
		if (suggestedSide == DrawConstant.WEST) {
d303 1
a303 1
		} else if (suggestedSide == DrawConstant.EAST) {
d313 1
a313 1
		} else if (suggestedSide == DrawConstant.SOUTH) {
d373 1
a373 1
			DrawConstant suggestedSide, int circuitCount, IFigure borderItem) {
d383 1
a383 1
			if (suggestedSide == DrawConstant.WEST) {
d392 1
a392 1
						DrawConstant.SOUTH, circuitCount + 1, borderItem);
d394 1
a394 1
			} else if (suggestedSide == DrawConstant.SOUTH) {
d402 1
a402 1
						DrawConstant.EAST, circuitCount + 1, borderItem);
d404 1
a404 1
			} else if (suggestedSide == DrawConstant.EAST) {
d413 1
a413 1
						DrawConstant.NORTH, circuitCount + 1, borderItem);
d422 1
a422 1
						DrawConstant.WEST, circuitCount + 1, borderItem);
d450 1
a450 1
		DrawConstant side = findClosestSide(proposedLocation, getParentBorder());
d463 2
d510 50
d568 1
a568 1
		DrawConstant closestSide = findClosestSide(rectSuggested,
d570 1
a570 1
		setPreferredSide(closestSide);
d573 1
a573 1
			getPreferredSide(), 0, borderItem);
d576 1
a576 1
		setCurrentSide(findClosestSide(new Rectangle(ptNewLocation, borderItem
d606 2
d610 42
d654 1
a654 1

d658 2
d662 33
a694 2
		this.preferredSide = preferredSide;
		setCurrentSide(preferredSide);
d697 3
a699 2
	/*
	 * (non-Javadoc)
d701 12
a712 1
	 * @@see org.eclipse.gmf.runtime.diagram.ui.figures.IBorderItemLocator#getCurrentSide()
d715 38
d755 1
a755 1

d759 2
d762 33
a794 2
	public void setCurrentSide(DrawConstant currentSide) {
		this.currentSide = currentSide;
d797 11
@

