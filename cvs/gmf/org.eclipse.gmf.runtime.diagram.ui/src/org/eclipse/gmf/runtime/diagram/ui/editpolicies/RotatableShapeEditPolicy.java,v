head	1.3;
access;
symbols
	v20081023-2107:1.3
	v20081022-1925:1.3
	v20081022-1005:1.3
	v20081020-0700:1.3
	v20080917-1925:1.3
	v20080916-2008:1.3
	v20080911-1728:1.3
	v20080911-1506:1.3
	v20080910-1520:1.3
	v20080910-1510:1.3
	v20080903-1520:1.3
	v20080903-1510:1.3
	v20080813-1510:1.3
	v20080811-1546:1.3
	v20080731-1520:1.3
	v20080725-1738:1.3
	v20080723-2246:1.3
	v20080723-2232:1.3
	v20080723-1700:1.3
	v20080722-1827:1.3
	v20080718-1700:1.3
	v20080718-1731:1.3
	v20080716-1600:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.6
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080610-1132:1.3
	v20080603-1553:1.3
	v20080527-1255:1.3
	v20080527-1151:1.3
	v20080516-1748:1.3
	v20080516-1143:1.3
	v20080512-1200:1.3
	v20080503-1740:1.3
	v20080501-2127:1.3
	v20080501-1739:1.3
	m20080429-1543:1.3
	v20080425-1959:1.3
	v20080417-1610:1.3
	v20080407-2250:1.3
	v20080407-0930:1.3
	v20080404-1111:1.3
	v20080328-1605:1.3
	v20080322-0000:1.3
	v20080222-1200:1.3
	v20080201-2010:1.3
	v20080201-0201:1.3
	v20080118-1129:1.3
	v20080114-2222:1.3
	v20080114-1111:1.3
	v20080107-1111:1.3
	v20071222-1111:1.3
	v20071214-1111:1.3
	v20071130-1111:1.3
	v20071124-0000:1.3
	v20071112-0000:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070915-0000:1.3
	v20070903-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.4
	R2_0:1.3
	R4_20:1.3
	v20070621-0000:1.3
	RC3_20:1.3
	v20070614-1400:1.3
	v20070608-1300:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070525-1500:1.3
	v20070518-1300:1.3
	bugzilla111892_group_support:1.3.0.2
	Root_bugzilla111892_group_support:1.3
	v20070504-1000:1.3
	v20070420-1000:1.3
	v20070413-1300:1.3
	v20070330-1300:1.3
	v20060330-1300:1.3
	v20070322-1100:1.3
	v20060316-0600:1.3
	v20070221-1500:1.3
	v20070208-1800:1.3
	v20070202-0200:1.2.2.1
	v20070119-1200:1.2.2.1
	v20070111-0800:1.2.2.1
	v20070105-1200:1.2.2.1
	v20070103-0300:1.3
	M4_20:1.3
	v20061218-1500:1.2.2.1
	v20061218-1200:1.3
	v20061214-0000:1.3
	M3_20:1.3
	v20061117-0800:1.3
	v20061027-1200:1.2.2.1
	v20061013-1330:1.3
	v20061012-1100:1.2.2.1
	v20060925-1700:1.2.2.1
	v20060919-0800:1.2.2.1
	v20060907-1100:1.2
	M1_20:1.2
	v20060831-1500:1.2
	v20060824-1600:1.2
	v20060817-1500:1.2
	v20060810-1700:1.2
	v20060803-1200:1.2
	v20060728-0500:1.2
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1400:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060530-1930:1.2
	v20060526-1200:1.2
	v20060519-0800:1.2
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1
	I20060216-1945:1.1
	I20060210-1715:1.1
	I20060209-1815:1.1
	I20060203-0830:1.1
	I20060202-1415:1.1
	I20060129-1145:1.1
	I20060127-0900:1.1
	I20060120-1530:1.1
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1
	I20060105-1630:1.1
	I20051230-1230:1.1
	I20051223-1100:1.1
	I20051217-0925:1.1
	I20051208-2000:1.1
	I20051201-1800:1.1
	I20051124-2000:1.1
	M3_10:1.1
	I20051118-1245:1.1
	I20051111-1800:1.1
	I20051106-0900:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.3
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.06.20.04.27;	author sshaw;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	;

1.2.2.1
date	2006.09.13.16.43.39;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.3
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import java.util.List;

import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PrecisionRectangle;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.Handle;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.requests.ChangeBoundsRequest;
import org.eclipse.gmf.runtime.diagram.ui.internal.handles.RotateHandle;
import org.eclipse.gmf.runtime.diagram.ui.internal.tools.RotateTracker;
import org.eclipse.gmf.runtime.gef.ui.internal.requests.RotateShapeRequest;

/**
 * A rotatable editpolicy for rotating fork and join itparts
 * It rotates the figure if diagonal handlers are dragged and
 * resizes the figure otherwise as defined by the superclass
 *  
 * @@author oboyko
 */
public class RotatableShapeEditPolicy extends ResizableShapeEditPolicy {
	
	// how much should be the mice moved to rotate the figure
	private final static int DEFAULT_TOLERANCE = 6;

	/*
	 * Create the selection handles for edit parts that have Rotatable Edit Policy
	 * installed on them, i.e. Forks and Joins from Activity and State Machine diagrams
	 *  (non-Javadoc)
	 * @@see org.eclipse.gef.editpolicies.SelectionHandlesEditPolicy#createSelectionHandles()
	 */
	protected List createSelectionHandles() {
        setResizeDirections(PositionConstants.EAST | PositionConstants.SOUTH | 
            PositionConstants.WEST | PositionConstants.NORTH);
        
        List selectionhandles = super.createSelectionHandles();
        GraphicalEditPart part = (GraphicalEditPart) getHost();
		
		selectionhandles.add(createRotationHandle(part, PositionConstants.SOUTH_EAST));
		selectionhandles.add(createRotationHandle(part, PositionConstants.SOUTH_WEST));
		selectionhandles.add(createRotationHandle(part, PositionConstants.NORTH_WEST));
		selectionhandles.add(createRotationHandle(part, PositionConstants.NORTH_EAST));
		return selectionhandles;
	}
	
	/**
	 * Create rotate handle with a rotate tracker
	 * @@param owner the owner edit part
	 * @@param direction the handle direction
	 * @@return the handle
	 */
	protected Handle createRotationHandle(GraphicalEditPart owner, int direction) {
		RotateHandle handle = new RotateHandle(owner, direction);
		handle.setDragTracker(
			new RotateTracker(owner, direction));
		return handle;
	}
	
	/**
	 * Shows or updates feedback for a change bounds request that is seen as rotation
	 * @@param request the request
	*/
	protected void showChangeBoundsFeedback(ChangeBoundsRequest request) {
		// If the figure is being rotated draw the rotation feedback
		if ( isRotationRequired(request)) {
			// Get current feedback
			IFigure feedback = getDragSourceFeedbackFigure();
			
			if (doRotation(request)) {
				// Get the absolute coordinates for rotated figure
				PrecisionRectangle rect = getAbsoluteRotatedBounds();
				// Draw the rotated figure in the feedback
				feedback.translateToRelative(rect);
				feedback.setBounds(rect);
			}
			else {
				// Get the absolute coordinates for initial and rotated figure
				PrecisionRectangle initFigure = getAbsoluteInitialBounds();
				// Draw the initial figure in the feedback
				feedback.translateToRelative(initFigure);
				feedback.setBounds(initFigure);
			}
		}
		else {
			// otherwise the figure is being resized
			super.showChangeBoundsFeedback(request);
		}
	}
	
	/*
	 * Returns PrecisionRectangle obtained from the rotation by 90 deg. of an argument rectangle
	 * with respect to it's geometrical centre
	 * @@param Rectangle r
	 * @@return PrecisionRectangle rect obtained from rotation of r
	 */
	private PrecisionRectangle rotateRectangle(Rectangle r) {
		PrecisionRectangle rect = new PrecisionRectangle(r);
		if (isVertical(r)) {
			rect.setX(rect.preciseX-rect.preciseHeight/2.0+rect.preciseWidth/2.0);
			rect.setY(rect.preciseY+rect.preciseHeight/2.0-rect.preciseWidth/2.0);
		}
		else {
			rect.setX(rect.preciseX+rect.preciseWidth/2.0-rect.preciseHeight/2.0);
			rect.setY(rect.preciseY-rect.preciseWidth/2.0+rect.preciseHeight/2.0);
		}
		transposePrecisionRectangleSize(rect);
		return rect;
	}
	
	/*
	 * Check whether the bar (or figure) is vertical or horizontal
	 * @@param Rectangle - the bounds of the figure
	 * @@return true if figure is vertical, fasle if figure is horizontal
	 */
	private boolean isVertical(Rectangle r) {
		return r.height>r.width;
	}
	
	/*
	 * Transposes PrecisionRectangle's size
	 * @@param PrecisionRectangle
	 * @@return PrecisionRectangle with transposed size  
	 */
	private void transposePrecisionRectangleSize(PrecisionRectangle r) {
		double height = r.preciseHeight;
		r.setHeight(r.preciseWidth);
		r.setWidth(height);
	}
	
	/*
	 * Returns if figure must be rotated based on the info in the request, i.e. 
	 * diagonal resize direction and rotatable edit parts are selected.
	 * @@param change bounds request
	 * @@return true if figure must be rotated
	 */
	private boolean isRotationRequired(ChangeBoundsRequest request) {
		return request instanceof RotateShapeRequest ?  ((RotateShapeRequest) request).shouldRotate() : false; 
	}
	
	/*
	 * Returns the command contribution for the given resize request. By default, the request
	 * is redispatched to the host's parent as a {@@link
	 * org.eclipse.gef.RequestConstants#REQ_RESIZE_CHILDREN}.  The parent's editpolicies
	 * determine how to perform the resize based on the layout manager in use.
	 * @@param request the resize request
	 * @@return the command contribution obtained from the parent
	 * @@see org.eclipse.gef.editpolicies.ResizableEditPolicy#getResizeCommand(org.eclipse.gef.requests.ChangeBoundsRequest)
	*/
	protected Command getResizeCommand(ChangeBoundsRequest request) {
		// if the figure needs to be rotated set the command with the proper data
		if (isRotationRequired(request)) {
			ChangeBoundsRequest req = new ChangeBoundsRequest(REQ_RESIZE_CHILDREN);
			req.setEditParts(getHost());

			// fake resizing and movement to resize the figure if mice is moved far enough
			if (doRotation(request)) {
					// Get the absolute coordinates for initial and rotated figure
					PrecisionRectangle rect = getAbsoluteRotatedBounds();
					PrecisionRectangle initFigure = getAbsoluteInitialBounds();
					req.setMoveDelta
						(new Point(rect.preciseX - initFigure.preciseX, rect.preciseY - initFigure.preciseY));
					req.setSizeDelta
						(new Dimension(rect.width - initFigure.width, rect.height - initFigure.height));
				}
				else {
					// otherwise SizeDelta and MoveDelta must be 0s
					req.setSizeDelta(new Dimension());
					req.setMoveDelta(new Point());
				}
			
			req.setLocation(request.getLocation());
			req.setExtendedData(request.getExtendedData());
			req.setResizeDirection(request.getResizeDirection());
			return getHost().getParent().getCommand(req);
		}
		else {
			// otherwise the figure is being resized
			return super.getResizeCommand(request);
		}
	}
	
	/*
	 * Based on the size delta from the request determines whether the EditPart must be rotated or
	 * remain as it is 
	 */
	private boolean doRotation(ChangeBoundsRequest request) {
		return Math.abs(request.getSizeDelta().width) > DEFAULT_TOLERANCE || Math.abs(request.getSizeDelta().height) > DEFAULT_TOLERANCE;
	}
	
	/*
	 * Returns the bounds of the initial figure in the absolute coordinates
	 */
	private PrecisionRectangle getAbsoluteInitialBounds() {
		// store the initial figure
		PrecisionRectangle initFigure = new PrecisionRectangle(getInitialFeedbackBounds().getCopy());
		getHostFigure().translateToAbsolute(initFigure);
		return initFigure;
	}
	
	/*
	 * Returns the bounds of the rotated initial figure with respect to its geometrical centre
	 * in absolute coordinates
	 */
	private PrecisionRectangle getAbsoluteRotatedBounds() {
		// store the rotated figure
		PrecisionRectangle rect = new PrecisionRectangle(rotateRectangle(getInitialFeedbackBounds().getCopy()));
		getHostFigure().translateToAbsolute(rect);
		return rect;
	}
}@


1.2
log
@bugzilla 134462 gmf-head sshaw 060406 ResizableShapeEditPolicy doesn't follow contract of it's superclass
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
@


1.2.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@


1.1
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@a13 1
import java.util.ArrayList;
a24 1
import org.eclipse.gef.handles.MoveHandle;
a25 1

d49 6
a54 6
		GraphicalEditPart part = (GraphicalEditPart) getHost();
		List selectionhandles = new ArrayList(9);
		MoveHandle moveHandle = new MoveHandle(part);
		moveHandle.setBorder(null);
		selectionhandles.add(moveHandle);
		selectionhandles.add(super.createHandle(part, PositionConstants.EAST));
a55 1
		selectionhandles.add(super.createHandle(part, PositionConstants.SOUTH));
a56 1
		selectionhandles.add(super.createHandle(part, PositionConstants.WEST));
a57 1
		selectionhandles.add(super.createHandle(part, PositionConstants.NORTH));
@

