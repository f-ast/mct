head	1.8;
access;
symbols
	v20081022-1925:1.8
	v20080917-1925:1.8
	v20080911-1728:1.8
	v20080910-1520:1.8
	v20080903-1520:1.8
	v20080731-1520:1.8
	v20080723-2246:1.8
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	I20051124-2000:1.7
	M3_10:1.7
	I20051118-1245:1.7
	I20051111-1800:1.7
	I20051106-0900:1.7
	v20051030:1.6;
locks; strict;
comment	@# @;


1.8
date	2005.11.25.19.34.26;	author cmahoney;	state dead;
branches;
next	1.7;

1.7
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.14.15.17.42;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.07.19.21.25;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.23.20.56.03;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.29.06;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.22;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.37;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Bugzilla#113157 gmf_head cmahoney 051125 Removing deprecated classes
@
text
@/******************************************************************************
 * Copyright (c) 2003, 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.draw2d.FigureListener;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.gef.LayerConstants;
import org.eclipse.gef.Tool;
import org.eclipse.gef.tools.SelectionTool;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.handles.ConnectionHandle;
import org.eclipse.gmf.runtime.diagram.ui.handles.ConnectionHandleLocator;
import org.eclipse.gmf.runtime.diagram.ui.handles.ConnectionHandle.HandleDirection;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
import org.eclipse.gmf.runtime.emf.ui.services.modelingassistant.ModelingAssistantService;

/**
 * This editpolicy is responsible for adding the connector handles to a shape.
 * 
 * @@author cmahoney
 *  * @@deprecated Renamed to {@@link org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectionHandleEditPolicy}
 */
public class ConnectorHandleEditPolicy extends DiagramAssistantEditPolicy {

	/**
	 * Listens to the owner figure being moved so the handles can be removed
	 * when this occurs.
	 */
	private class OwnerMovedListener implements FigureListener {

		/**
		 * @@see org.eclipse.draw2d.FigureListener#figureMoved(org.eclipse.draw2d.IFigure)
		 */
		public void figureMoved(IFigure source) {
			hideDiagramAssistant();
		}
	}

	/** listener for owner shape movement */
	private OwnerMovedListener ownerMovedListener = new OwnerMovedListener();

	/** list of connector handles currently being displayed */
	private List handles = null;

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#isDiagramAssistant(java.lang.Object)
	 */
	protected boolean isDiagramAssistant(Object object) {
		return object instanceof ConnectionHandle;
	}

	/**
	 * Gets the two connector handle figures to be added to this shape if they
	 * support user gestures.
	 * @@return a list of <code>ConnectionHandle</code> objects
	 */
	protected List getHandleFigures() {
		List list = new ArrayList(2);
		
		String tooltip;
		tooltip = buildTooltip(HandleDirection.INCOMING);
		if (tooltip != null) {
			list.add(new ConnectionHandle((IGraphicalEditPart) getHost(),
				HandleDirection.INCOMING, tooltip));
		}

		tooltip = buildTooltip(HandleDirection.OUTGOING);
		if (tooltip != null) {
			list.add(new ConnectionHandle((IGraphicalEditPart) getHost(),
				HandleDirection.OUTGOING, tooltip));
		}

		return list;
	}

	/**
	 * Builds the applicable tooltip string based on whether the Modeling
	 * Assistant Service supports handle gestures on this element. If no
	 * gestures are supported, the tooltip returned will be null.
	 * 
	 * @@param direction
	 *            the handle direction.
	 * @@return tooltip the tooltip string; if null, the handle should be not be
	 *         displayed
	 */
	protected String buildTooltip(HandleDirection direction) {
		ModelingAssistantService service = ModelingAssistantService
			.getInstance();

		boolean supportsCreation = (direction == HandleDirection.OUTGOING) ? !service
			.getRelTypesOnSource(getHost()).isEmpty()
			: !service.getRelTypesOnTarget(getHost()).isEmpty();

		boolean supportsSRE = (direction == HandleDirection.OUTGOING) ? !service
			.getRelTypesForSREOnSource(getHost()).isEmpty()
			: !service.getRelTypesForSREOnTarget(getHost()).isEmpty();

		if (supportsSRE) {
			if (supportsCreation) {
				return DiagramResourceManager
					.getI18NString("ConnectionHandle.ToolTip.ShowRelatedElementsAndCreateRelationship"); //$NON-NLS-1$
			} else {
				return DiagramResourceManager
					.getI18NString("ConnectionHandle.ToolTip.ShowRelatedElementsOnly"); //$NON-NLS-1$
			}
		} else if (supportsCreation) {
			return DiagramResourceManager
				.getI18NString("ConnectionHandle.ToolTip.CreateRelationshipOnly"); //$NON-NLS-1$
		}
		return null;
	}

	public void activate() {
		super.activate();
		
		((IGraphicalEditPart) getHost()).getFigure().addFigureListener(
			ownerMovedListener);
	}

	public void deactivate() {
		((IGraphicalEditPart) getHost()).getFigure().removeFigureListener(
			ownerMovedListener);

		super.deactivate();
	}

	/**
	 * @@deprecated use {@@link #showDiagramAssistant(Point)}
	 */
	protected void addConnectorHandles(Point referencePoint) {
		showDiagramAssistant(referencePoint);
	}
	
	protected void showDiagramAssistant(Point referencePoint) {
		if (referencePoint == null) {
			referencePoint = getHostFigure().getBounds().getRight();
		}

		handles = getHandleFigures();
		if (handles == null) {
			return;
		}

		ConnectionHandleLocator locator = getConnectorHandleLocator(referencePoint);
		IFigure layer = getLayer(LayerConstants.HANDLE_LAYER);
		for (Iterator iter = handles.iterator(); iter.hasNext();) {
			ConnectionHandle handle = (ConnectionHandle) iter.next();
			
			handle.setLocator(locator);
			locator.addHandle(handle);

			handle.addMouseMotionListener(this);
			layer.add(handle);

			// Register this figure with it's host editpart so mouse events
			// will be propagated to it's host.
			getHost().getViewer().getVisualPartMap().put(handle, getHost());
		}
		
		if(!shouldAvoidHidingDiagramAssistant())
		{
			// dismiss the handles after a delay
			hideDiagramAssistantAfterDelay(getDisappearanceDelay());
		}
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#getPreferenceName()
	 */
	String getPreferenceName() {
		return org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants.PREF_SHOW_CONNECTION_HANDLES;
	}

	/**
	 * Removes the connector handles.
	 */
	protected void hideDiagramAssistant() {
		if (handles == null) {
			return;
		}
		IFigure layer = getLayer(LayerConstants.HANDLE_LAYER);
		for (Iterator iter = handles.iterator(); iter.hasNext();) {
			IFigure handle = (IFigure) iter.next();
			handle.removeMouseMotionListener(this);
			layer.remove(handle);
			getHost().getViewer().getVisualPartMap().remove(handle);
		}
		handles = null;
	}
		
	private boolean isSelectionToolActive()
	{
		// getViewer calls getParent so check for null
		if(getHost().getParent() != null)
		{
			Tool theTool = getHost().getViewer().getEditDomain().getActiveTool();
			if((theTool != null) && theTool instanceof SelectionTool)
			{
				return true;
			}
		}
		return false;		
	}

	/**
	 * checks if the Host edit part is editable or not
	 * @@return true or false
	 * @@deprecated if someone needs this let me know -- Cherie Mahoney
	 */
	protected boolean isEditable() {
		GraphicalEditPart theEditPart = null;
		if (getHost() instanceof GraphicalEditPart) {
			theEditPart = (GraphicalEditPart) getHost();
			return theEditPart.isEditModeEnabled();
		} 
		return false;
	}
	
	/**
	 * checks if it is ok to show ConnectorHandles or not 
	 * @@return true or false
	 * @@deprecated use shouldShowDiagramAssistant()
	 */
	protected boolean isOkayToShowConnectorHandles(){
		return shouldShowDiagramAssistant();
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#shouldShowDiagramAssistant()
	 */
	protected boolean shouldShowDiagramAssistant(){
		if (!super.shouldShowDiagramAssistant()) {
			return false;
		}
		if (handles != null || !isSelectionToolActive()) {
			return false;
		}
		return true;
	}
	
	/**
	 * get the connector handle locator using the host and the passed reference
	 * point
	 * 
	 * @@param referencePoint
	 * @@return <code>ConnectionHandleLocator</code>
	 */
	protected ConnectionHandleLocator getConnectorHandleLocator(Point referencePoint){
		return new ConnectionHandleLocator(getHostFigure(), referencePoint);		
	}
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editpolicies.DiagramAssistantEditPolicy#isDiagramAssistantShowing()
	 */
	protected boolean isDiagramAssistantShowing() {
		return handles != null;
	}
}@


1.7
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@@


1.6
log
@Bugzilla 112521 gmf_head sshaw 051013 Diagram Assistants should not appear if editor is not active
Contributed by: Cherie Mahoney
@
text
@a23 1
import org.eclipse.gmf.runtime.diagram.ui.IPreferenceConstants;
d26 4
a29 4
import org.eclipse.gmf.runtime.diagram.ui.handles.ConnectorHandle;
import org.eclipse.gmf.runtime.diagram.ui.handles.ConnectorHandleLocator;
import org.eclipse.gmf.runtime.diagram.ui.handles.ConnectorHandle.HandleDirection;
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d36 1
d64 1
a64 1
		return object instanceof ConnectorHandle;
d70 1
a70 1
	 * @@return a list of <code>ConnectorHandle</code> objects
d78 1
a78 1
			list.add(new ConnectorHandle((IGraphicalEditPart) getHost(),
d84 1
a84 1
			list.add(new ConnectorHandle((IGraphicalEditPart) getHost(),
d115 2
a116 2
				return PresentationResourceManager
					.getI18NString("ConnectorHandle.ToolTip.ShowRelatedElementsAndCreateRelationship"); //$NON-NLS-1$
d118 2
a119 2
				return PresentationResourceManager
					.getI18NString("ConnectorHandle.ToolTip.ShowRelatedElementsOnly"); //$NON-NLS-1$
d122 2
a123 2
			return PresentationResourceManager
				.getI18NString("ConnectorHandle.ToolTip.CreateRelationshipOnly"); //$NON-NLS-1$
d159 1
a159 1
		ConnectorHandleLocator locator = getConnectorHandleLocator(referencePoint);
d162 1
a162 1
			ConnectorHandle handle = (ConnectorHandle) iter.next();
d188 1
a188 1
		return IPreferenceConstants.PREF_SHOW_CONNECTOR_HANDLES;
d263 1
a263 1
	 * @@return <code>ConnectorHandleLocator</code>
d265 2
a266 2
	protected ConnectorHandleLocator getConnectorHandleLocator(Point referencePoint){
		return new ConnectorHandleLocator(getHostFigure(), referencePoint);		
@


1.5
log
@bugzilla 111952 gmf_head sshaw 051007 Connector handles do not appear when hovering over compartments
Contributed by: Cherie Mahoney
@
text
@a23 2
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
a30 1
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
a31 2
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.preference.IPreferenceStore;
a152 2
		if (!(isOkayToShowConnectorHandles()))
			return;
d182 2
a183 14
	/**
	 * Is the show connector handles preference turned on?
	 * @@return true iff the show connector handles preference is turned on
	 */
	private boolean isShowHandlesPreferenceOn() {
		IPreferenceStore preferenceStore = (IPreferenceStore)
			((IGraphicalEditPart) getHost())
				.getDiagramPreferencesHint().getPreferenceStore();
		return preferenceStore.getBoolean(
			IPreferenceConstants.PREF_SHOW_CONNECTOR_HANDLES);
	}

	/**
	 * Is the semantic reference (if applicable) is unresolvable?
d185 1
a185 1
	 * @@return true iff the semantic reference (if applicable) is unresolvable
d187 2
a188 12
	private boolean isSemanticReferenceUnresolvable() {
		final View view = (View)getHost().getModel();
		if (view.getElement() != null) {
			Boolean retval = (Boolean) MEditingDomainGetter.getMEditingDomain(view).runAsRead(new MRunnable() {

				public Object run() {
					return new Boolean(ViewUtil.resolveSemanticElement(view) == null);
				}
			});
			return retval.booleanValue();
		}
		return false;
d225 1
a235 1
	
d239 1
d242 11
a252 6
		if (handles != null || !getHost().isActive() || 
				!isShowHandlesPreferenceOn() || 
				isSemanticReferenceUnresolvable() ||
				!isSelectionToolActive() ||
				!isEditable())
		{
d259 3
a261 1
	 * get the connector handle locator using the host and the passed reference point
@


1.4
log
@Bugzilla 110480 gmf_head sshaw 050923 Modeling Assistant Service should have generic getTypes() operation to be used in commands with popups
Contributed by Cherie Mahoney
@
text
@a19 2
import org.eclipse.draw2d.MouseEvent;
import org.eclipse.draw2d.MouseMotionListener;
a20 2
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartListener;
a36 1
import org.eclipse.swt.widgets.Display;
d46 2
a47 49
	 * Listens to mouse events on the owner shape and handles so that the
	 * handles can be added or removed at the appropriate time.
	 */
	private class MouseListener extends MouseMotionListener.Stub {

		public void mouseEntered(MouseEvent me) {
			setMouseLocation(me.getLocation());
		}

		public void mouseExited(MouseEvent me) {
			setMouseLocation(null);
			removeHandlesAfterDelay(getDisappearanceDelayUponExit());
		}

		/**
		 * We the tools to dismiss after the delay period if 
		 * the mouse is inside the shape, but we do not want the tools to 
		 * dismiss if the mouse is inside the one of the tools.
		 * 
		 */
		private boolean shouldHoverActivate(Object theObj)
		{
			if(theObj instanceof ConnectorHandle)
				return true;
						
			return false;
		}
		
		/**
		 * @@see org.eclipse.draw2d.MouseMotionListener#mouseMoved(org.eclipse.draw2d.MouseEvent)
		 */
		public void mouseMoved(MouseEvent me) {
			setActivateOnHover(true);
			setMouseLocation(me.getLocation());

			// if the cursor is inside the handles
			// then we do not want to deactivate
			if (!shouldHoverActivate(me.getSource()))
				setActivateOnHover(false);

			addHandlesAfterDelay(getAppearanceDelay());
				
			super.mouseMoved(me);
		}		
	}

	/**
	 * Listens to the owner figure being moved so the handles can be 
	 * removed when this occurs.
d55 1
a55 1
			removeConnectorHandles();
a58 22
	/**
	 * Listens to the focus events on the owner editpart so that the handles
	 * can be added when the space bar is pressed.  I tried to use 
	 * IFigure.addFocusListener(), but the figure isn't getting any focus
	 * change events when the space bar is pressed.
	 */
	private class FocusListener extends EditPartListener.Stub {
		/**
		* @@see org.eclipse.gef.EditPartListener#selectedStateChanged(org.eclipse.gef.EditPart)
		*/
		public void selectedStateChanged(EditPart part) {
			if (part.hasFocus()) {
				addConnectorHandles(getHostFigure().getBounds().getRight());
			} else {
				removeConnectorHandles();
			}
		}
	}
	
	/** mouse motion listener for the owner shape and handles */
	private MouseListener mouseListener = new MouseListener();

a61 3
	/** listener for focus change on editpart */
	private FocusListener focusListener = new FocusListener();

d65 6
a70 4
	private boolean myActivateOnHover = true;
	
	/** the <code>Runnable</code> used for the remove handles delay timer */
	private Runnable removeHandlesRunnable = new Runnable() {
a71 49
		/**
		 * The connector handles are removed when this task is run, assuming the
		 * mouse is still outside the shape.
		 */
		public void run() {
			if (getMouseLocation() == null || !getActivateOnHover()) {
				removeConnectorHandles();
			}
		}
	};
	
	/**
	 * The current mouse location within the shape used to determine where the
	 * connector handles should be displayed. If this is null, then we can
	 * assume the user has moved the mouse outside the shape or connector
	 * handles.
	 */
	private Point mouseLocation;

	/** the <code>Runnable</code> class used for the add handles delay timer */
	private class AddHandlesRunnable
		implements Runnable {

		/** the mouse location when the timer was started */
		private Point originalMouseLocation;

		/**
		 * @@param originalMouseLocation
		 */
		protected AddHandlesRunnable(Point originalMouseLocation) {
			this.originalMouseLocation = originalMouseLocation;
		}

		/**
		 * The connector handles are added when this task is run, assuming the
		 * mouse is still at the same spot where it was when the timer was
		 * started (i.e. only add the connector handles when the user stops
		 * moving the mouse).
		 */
		public void run() {
			if (originalMouseLocation.equals(getMouseLocation())) {
				if (handles != null && !getActivateOnHover()) {
					removeConnectorHandles();
				}
				addConnectorHandles(originalMouseLocation);
			}
		}
	}
	
d135 1
a135 3

		((IGraphicalEditPart) getHost()).getFigure().addMouseMotionListener(
			mouseListener);
a137 1
		((IGraphicalEditPart) getHost()).addEditPartListener(focusListener);
a140 2
		((IGraphicalEditPart) getHost()).getFigure().removeMouseMotionListener(
			mouseListener);
a142 3
		((IGraphicalEditPart) getHost()).removeEditPartListener(focusListener);
		
		removeConnectorHandles();
d148 1
a148 5
	 * Creates the handles and adds them to the handle layer if the
	 * handles have not already been created and all the conditions
	 * are met.
	 * @@param referencePoint the point inside the shape where the handles
	 * should be placed near.
d151 7
d174 1
a174 1
			handle.addMouseMotionListener(mouseListener);
d182 1
a182 1
		if(!getActivateOnHover())
d185 1
a185 1
			removeHandlesAfterDelay(getDisappearanceDelay());
a218 20
	
	/**
	 * Sets a timer to remove the connector handles if the handles are currently
	 * shown.
	 */
	private void removeHandlesAfterDelay(int theDelay) {
		if (handles != null) {
			Display.getCurrent().timerExec(theDelay, removeHandlesRunnable);
		}
	}

	/**
	 * Sets a timer to add the connector handles if the mouse is still in the
	 * shape
	 */
	private void addHandlesAfterDelay(int theDelay) {
		Display.getCurrent().timerExec(theDelay,
			new AddHandlesRunnable(getMouseLocation()));
	}

d223 1
a223 1
	private void removeConnectorHandles() {
d230 1
a230 1
			handle.removeMouseMotionListener(mouseListener);
a236 8
	private void setActivateOnHover(boolean bVal)
	{
		myActivateOnHover=bVal;
	}
	private boolean getActivateOnHover()
	{
		return myActivateOnHover;
	}
d289 2
a290 3
	
	/**
	 * @@return Returns the mouseLocation.
d292 2
a293 2
	protected Point getMouseLocation() {
		return mouseLocation;
d295 1
a295 9
	
	/**
	 * @@param mouseLocation The mouseLocation to set.
	 */
	protected void setMouseLocation(Point mouseLocation) {
		this.mouseLocation = mouseLocation;
	}

}
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a26 1
import org.eclipse.gef.editpolicies.GraphicalEditPolicy;
a27 3
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.swt.widgets.Display;

d29 1
a36 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d40 2
d48 1
a48 13
public class ConnectorHandleEditPolicy extends GraphicalEditPolicy {

	/** Delay in ms to wait after leaving shape before removing handles. */
	private static final int REMOVE_HANDLES_DELAY = 1000;

	/** Only keep the widget visible for this length of time.*/
	private int STAY_VISIBLE_DELAY = 2000;
	
	/**
	 * Delay in ms to wait before showing the connector handles upon entering
	 * the shape.
	 */
	private static final int ADD_HANDLES_DELAY = 200;
d62 1
a62 1
			removeConnectorHandlesAfterDelay();
d91 1
a91 1
			addConnectorHandlesAfterDelay();
d313 2
a314 2
			// dismiss the handles after STAY_VISIBLE_DELAY ms.
			removeConnectorHandlesAfterDelayAmt(STAY_VISIBLE_DELAY);
d317 1
a317 1

d348 1
a348 1

d353 1
a353 7
	private void removeConnectorHandlesAfterDelay() {
		removeConnectorHandlesAfterDelayAmt(REMOVE_HANDLES_DELAY);
		
		
	}
	
	private void removeConnectorHandlesAfterDelayAmt(int theDelay) {
d363 2
a364 2
	private void addConnectorHandlesAfterDelay() {
		Display.getCurrent().timerExec(ADD_HANDLES_DELAY,
d367 2
a368 1
	
d460 1
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2003, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d41 1
a41 1
import com.ibm.xtools.notation.View;
@

