head	1.16;
access;
symbols
	v20081023-2107:1.16
	v20081022-1925:1.16
	v20081022-1005:1.16
	v20081020-0700:1.16
	v20080917-1925:1.16
	v20080916-2008:1.16
	v20080911-1728:1.16
	v20080911-1506:1.16
	v20080910-1520:1.16
	v20080910-1510:1.16
	v20080903-1520:1.16
	v20080903-1510:1.16
	v20080813-1510:1.16
	v20080811-1546:1.16
	v20080731-1520:1.16
	v20080725-1738:1.16
	v20080723-2246:1.16
	v20080723-2232:1.16
	v20080723-1700:1.16
	v20080722-1827:1.16
	v20080718-1700:1.16
	v20080718-1731:1.16
	v20080716-1600:1.16
	v20080716-1642:1.16
	R2_1_maintenance:1.16.0.2
	Root_R2_1_maintenance:1.16
	R2_1_0:1.16
	v20080610-1132:1.16
	v20080603-1553:1.16
	v20080527-1255:1.16
	v20080527-1151:1.15
	v20080516-1748:1.16
	v20080516-1143:1.16
	v20080512-1200:1.16
	v20080503-1740:1.16
	v20080501-2127:1.15
	v20080501-1739:1.16
	m20080429-1543:1.15
	v20080425-1959:1.16
	v20080417-1610:1.16
	v20080407-2250:1.16
	v20080407-0930:1.16
	v20080404-1111:1.16
	v20080328-1605:1.16
	v20080322-0000:1.16
	v20080222-1200:1.16
	v20080201-2010:1.16
	v20080201-0201:1.15
	v20080118-1129:1.15
	v20080114-2222:1.15
	v20080114-1111:1.16
	v20080107-1111:1.16
	v20071222-1111:1.16
	v20071214-1111:1.16
	v20071130-1111:1.16
	v20071124-0000:1.15
	v20071112-0000:1.15
	v20071108-0000:1.15
	v20071003-0000:1.15
	v20070915-0000:1.15
	v20070903-0000:1.15
	v20070809-0000:1.15
	R2_0_maintenance:1.15.0.2
	R2_0:1.15
	R4_20:1.15
	v20070621-0000:1.15
	RC3_20:1.14
	v20070614-1400:1.14
	v20070608-1300:1.14
	v20070605-1400:1.14
	v20070601-1400:1.14
	v20070525-1500:1.14
	v20070518-1300:1.14
	bugzilla111892_group_support:1.14.0.2
	Root_bugzilla111892_group_support:1.14
	v20070504-1000:1.14
	v20070420-1000:1.14
	v20070413-1300:1.14
	v20070330-1300:1.14
	v20060330-1300:1.14
	v20070322-1100:1.14
	v20060316-0600:1.14
	v20070221-1500:1.14
	v20070208-1800:1.14
	v20070202-0200:1.11.2.4
	v20070119-1200:1.11.2.4
	v20070111-0800:1.11.2.4
	v20070105-1200:1.11.2.4
	v20070103-0300:1.14
	M4_20:1.14
	v20061218-1500:1.11.2.4
	v20061218-1200:1.14
	v20061214-0000:1.14
	M3_20:1.13
	v20061117-0800:1.13
	v20061027-1200:1.11.2.3
	v20061013-1330:1.13
	v20061012-1100:1.11.2.3
	v20060925-1700:1.11.2.2
	v20060919-0800:1.11.2.2
	v20060907-1100:1.11.2.1
	M1_20:1.11
	v20060831-1500:1.11.2.1
	v20060824-1600:1.11.2.1
	v20060817-1500:1.11.2.1
	v20060810-1700:1.11.2.1
	v20060803-1200:1.11.2.1
	v20060728-0500:1.11.2.1
	v20060721-1130:1.11.2.1
	v20060713-1700:1.11.2.1
	R1_0_maintenance:1.11.0.2
	R1_0:1.11
	v20060627-1200:1.11
	v20060616-1400:1.11
	v20060616-1200:1.11
	v20060609-1400:1.10
	v20060531-1730:1.10
	v20060530-1930:1.10
	v20060526-1200:1.9
	v20060519-0800:1.9
	v20060512-1000:1.9
	I20060512-1000:1.9
	I20060505-1400:1.9
	I20060428-1300:1.8
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.8
	I20060331-1000:1.8
	I20060324-0300:1.8
	I20060317-1300:1.8
	I20060317-1200:1.8
	I20060316-1300:1.8
	I20060309-1300:1.8
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.8
	I20060216-1945:1.8
	I20060210-1715:1.7
	I20060209-1815:1.7
	I20060203-0830:1.7
	I20060202-1415:1.7
	I20060129-1145:1.6
	I20060127-0900:1.6
	I20060120-1530:1.6
	I20060113-1700:1.6
	M4_10:1.6
	I20060107-1100:1.6
	I20060105-1630:1.6
	I20051230-1230:1.6
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051208-2000:1.5
	I20051201-1800:1.5
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.3;
locks; strict;
comment	@# @;


1.16
date	2007.11.21.17.57.28;	author crevells;	state Exp;
branches;
next	1.15;
commitid	4a12474471874567;

1.15
date	2007.06.19.15.54.43;	author crevells;	state Exp;
branches;
next	1.14;
commitid	39624677fc434567;

1.14
date	2006.11.22.13.13.37;	author ldamus;	state Exp;
branches
	1.14.2.1;
next	1.13;
commitid	564a45644d004567;

1.13
date	2006.10.06.21.27.13;	author ldamus;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.14.18.39.49;	author ahunter;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2006.05.30.21.14.50;	author ldamus;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.02.18.00.32;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.13.19.11.49;	author ldamus;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.01.20.17.39;	author mmostafa;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.23.20.28.43;	author mmostafa;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.25.19.38.12;	author cmahoney;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.29.06;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.37;	author sshaw;	state Exp;
branches;
next	;

1.11.2.1
date	2006.07.06.17.25.43;	author cmahoney;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2006.09.13.16.43.39;	author ahunter;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2006.10.06.20.56.13;	author ldamus;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2006.11.22.13.12.19;	author ldamus;	state Exp;
branches;
next	;
commitid	5ce545644cb34567;

1.14.2.1
date	2007.05.18.17.36.43;	author crevells;	state Exp;
branches;
next	;
commitid	1899464de42a4567;


desc
@@


1.16
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.Request;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.UnexecutableCommand;
import org.eclipse.gef.editpolicies.AbstractEditPolicy;
import org.eclipse.gef.requests.ChangeBoundsRequest;
import org.eclipse.gef.requests.CreateRequest;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
import org.eclipse.gmf.runtime.common.core.command.FileModificationValidator;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.diagram.core.commands.AddCommand;
import org.eclipse.gmf.runtime.diagram.core.edithelpers.CreateElementRequestAdapter;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandUtilities;
import org.eclipse.gmf.runtime.diagram.ui.commands.CreateCommand;
import org.eclipse.gmf.runtime.diagram.ui.commands.CreateOrSelectElementCommand;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.commands.SemanticCreateCommand;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GroupEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.LabelEditPart;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateUnspecifiedTypeRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewAndElementRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.EditCommandRequestWrapper;
import org.eclipse.gmf.runtime.diagram.ui.requests.RefreshConnectionsRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants;
import org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand;
import org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.MoveRequest;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.swt.widgets.Display;

/**
 * This edit policy returns the command that will create a new notational view
 * for a the given request.
 * 
 * @@author choang
 */
public class CreationEditPolicy extends AbstractEditPolicy {
	
	/**
	 * @@return Command for the REQ_CREATE request. If the request is of type
	 *         CreateViewAndElementRequest then a command to create the
	 *         semantic, and the view will
	 * @@see org.eclipse.gef.EditPolicy#getCommand(org.eclipse.gef.Request)
	 */
	public Command getCommand(Request request) {
		if (understandsRequest(request)) {
			if (request instanceof CreateUnspecifiedTypeRequest) {
				return getUnspecifiedTypeCreateCommand((CreateUnspecifiedTypeRequest) request);
			} else if (request instanceof CreateViewAndElementRequest) {
				return getCreateElementAndViewCommand(
					(CreateViewAndElementRequest)request);
			}
			else if (request instanceof CreateViewRequest) {
				return getCreateCommand((CreateViewRequest)request);
			}
			else if (request instanceof ChangeBoundsRequest) {
				return getReparentCommand((ChangeBoundsRequest)request);
			}
			return super.getCommand(request);
		}
		return null;
	}

	/** Understands <tt>REQ_CREATE</tt> and <tt>REQ_ADD</tt> request types. */
	public boolean understandsRequest(Request request) {
		return RequestConstants.REQ_CREATE.equals(request.getType())
		    || RequestConstants.REQ_ADD.equals(request.getType())
			|| super.understandsRequest(request);
	}
	
	/**
	 * Determines if a semantic reparent is being performed.
	 * @@param element element being reparented
	 * @@param newContext the new container element
	 * @@return <tt>true</tt> if the supplied elemnet's container is
	 * not equals to the supplied <code>newContext</code>.\; otherwise <tt>false</tt>.
	 */
	protected boolean shouldReparent( EObject element, EObject newContext ) {
		return !(element == null ||
				element == newContext ||
				element.eContainer() == newContext ||
				isContainedIn( element, newContext )
				);
	}
	
	/*
	 * This method checks to see element's containment tree already includes
	 * itself.  This is necessary to prevent cyclic graphs in the model that
	 * cause StackOverflowExceptions.
	 */
	private boolean isContainedIn( EObject element, EObject newContext )
	{
		EObject container = newContext.eContainer();
		while( container != null ) {
			if( container.equals(element) )
				return true;
			container = container.eContainer();
		}
		return false;
	}

	/** Return a command to reparent both the semantic and view elements. */
	/**
	 * return a command to reparent both the semantic and view elements. 
	 * @@param request the request
	 * @@return command
	 */
	protected Command getReparentCommand(ChangeBoundsRequest request) {
		Iterator editParts = request.getEditParts().iterator();
		View container = (View)getHost().getAdapter(View.class);
		EObject context = container == null ? null : ViewUtil.resolveSemanticElement(container);
        CompositeCommand cc = new CompositeCommand(DiagramUIMessages.AddCommand_Label);
		while ( editParts.hasNext() ) {
			EditPart ep = (EditPart)editParts.next();
			if ( ep instanceof LabelEditPart ) {
				continue;
			}
			if (ep instanceof GroupEditPart) {
                cc.compose(getReparentGroupCommand((GroupEditPart) ep));
            }		
			View view = (View)ep.getAdapter(View.class);
			if ( view == null ) {
				continue;
			}
			
			EObject semantic = ViewUtil.resolveSemanticElement(view);
			if ( semantic == null ) {
				cc.compose(getReparentViewCommand((IGraphicalEditPart)ep));
			}
			else if ( context != null && shouldReparent(semantic, context)) {
				cc.compose(getReparentCommand((IGraphicalEditPart)ep));
			}
		}
		return cc.isEmpty() ? null : new ICommandProxy(cc.reduce());
	}
	
    /**
     * Return the command to reparent the supplied group editpart's semantic and
     * notation elements.
     * 
     * @@param gep
     *            the groupEP editpart being reparented
     * @@return A composite command that will reparent both the semantic and
     *         notation elements of the group.
     */
    protected ICommand getReparentGroupCommand(GroupEditPart groupEP) {
        CompositeCommand cc = new CompositeCommand(
            DiagramUIMessages.AddCommand_Label);
        View container = (View) getHost().getModel();
        EObject context = ViewUtil.resolveSemanticElement(container);

        // semantic
        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        for (Iterator iter = groupEP.getShapeChildren().iterator(); iter
            .hasNext();) {
            IGraphicalEditPart childEP = (IGraphicalEditPart) iter.next();
            EObject element = ViewUtil.resolveSemanticElement((View) childEP
                .getModel());
            if (element != null) {
                Command moveSemanticCmd = getHost().getCommand(
                    new EditCommandRequestWrapper(new MoveRequest(
                        editingDomain, context, element)));

                if (moveSemanticCmd == null) {
                    return org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand.INSTANCE;
                }

                cc.compose(new CommandProxy(moveSemanticCmd));
            }
        }

        // notation
        cc.compose(getReparentViewCommand(groupEP));
        return cc;
    }
	
	/** 
	 * Return the command to reparent the supplied editpart's semantic and notation
	 * elements.
	 * @@param gep the editpart being reparented
	 * @@return A CompositeCommand2 that will reparent both the semantic and notation elements.
	 */
	protected ICommand getReparentCommand( IGraphicalEditPart gep ) {
        CompositeCommand cc = new CompositeCommand(DiagramUIMessages.AddCommand_Label); 
		View container = (View)getHost().getModel();
		EObject context = ViewUtil.resolveSemanticElement(container);
		View view = (View)gep.getModel();
		EObject element = ViewUtil.resolveSemanticElement(view);

        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        
        //
		// semantic
		if ( element != null ) {
			Command moveSemanticCmd =
				getHost().getCommand(
					new EditCommandRequestWrapper(
						new MoveRequest(editingDomain, context, element)));
            
              if (moveSemanticCmd == null) {
                  return org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand.INSTANCE;
              }
			
			cc.compose ( new CommandProxy(moveSemanticCmd) );
		}
		//
		// notation
		cc.compose(getReparentViewCommand(gep));
		return cc;
	}
	
	/** 
	 * Return the command to reparent the supplied editpart's view only.
	 * @@param gep the editpart being reparented
	 * @@return A command to reparent the notation element.
	 */
	protected ICommand getReparentViewCommand( IGraphicalEditPart gep ) {
		View container = (View)getHost().getModel();
		View view = (View)gep.getModel();
		return new AddCommand(gep.getEditingDomain(), new EObjectAdapter(container),
							  new EObjectAdapter(view));
	}
	
	/**
	 * Called in response to a <tt>REQ_CREATE</tt> request.
	 * 
	 * Creates a compound command and populated with the following commands for
	 * each element to be created: <BR>
	 * <OL>
	 * <LI>a {@@link CreateCommand}for each of the request's view descriptor.
	 * </OL>
	 * 
	 * @@param request
	 *            a create request (understands instances of
	 *            {@@link CreateViewRequest}).
	 * @@return a command to satify the request; <tt>null</tt> if the request
	 *         is not understood.
	 */
	protected Command getCreateCommand(CreateViewRequest request) {

        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        CompositeTransactionalCommand cc = new CompositeTransactionalCommand(
            editingDomain, DiagramUIMessages.AddCommand_Label);
        
        Iterator descriptors = request.getViewDescriptors().iterator();

		while (descriptors.hasNext()) {
			CreateViewRequest.ViewDescriptor descriptor =
				(CreateViewRequest.ViewDescriptor)descriptors.next();

			CreateCommand createCommand =
				new CreateCommand(editingDomain,
					descriptor, 
					(View)(getHost().getModel()));

			cc.compose(createCommand);
		}
		return new ICommandProxy(cc.reduce());

	}

	/**
	 * Method getCreateElementAndViewCommand.
	 * 
	 * @@param request
	 * @@return Command Which creates the sematnic and the view command for the
	 *         given CreateViewAndElementRequest
	 */
	protected Command getCreateElementAndViewCommand(CreateViewAndElementRequest request) {
		// get the element descriptor
		CreateElementRequestAdapter requestAdapter =
			request.getViewAndElementDescriptor().getCreateElementRequestAdapter();

		// get the semantic request
		CreateElementRequest createElementRequest =
			(CreateElementRequest) requestAdapter.getAdapter(
				CreateElementRequest.class);

		if (createElementRequest.getContainer() == null) {
			// complete the semantic request by filling in the host's semantic
			// element as the context
			View view = (View)getHost().getModel();
			EObject hostElement = ViewUtil.resolveSemanticElement(view);
			
			if (hostElement == null && view.getElement() == null) {
				hostElement = view;
			}			

			// Returns null if host is unresolvable so that trying to create a
			// new element in an unresolved shape will not be allowed.
			if (hostElement == null) {
				return null;
			}
			createElementRequest.setContainer(hostElement);
		}

		// get the create element command based on the elementdescriptor's
		// request
		Command createElementCommand =
			getHost().getCommand(
				new EditCommandRequestWrapper(
					(CreateElementRequest)requestAdapter.getAdapter(
						CreateElementRequest.class), request.getExtendedData()));

		if (createElementCommand == null) 
			return UnexecutableCommand.INSTANCE;

		// create the semantic create wrapper command
		SemanticCreateCommand semanticCommand =
			new SemanticCreateCommand(requestAdapter, createElementCommand);
		Command viewCommand = getCreateCommand(request);

		Command refreshConnectionCommand =
			getHost().getCommand(
				new RefreshConnectionsRequest(((List)request.getNewObject())));


		// form the compound command and return
        CompositeCommand cc = new CompositeCommand(semanticCommand.getLabel());
		cc.compose(semanticCommand);
		cc.compose(new CommandProxy(viewCommand));
		if ( refreshConnectionCommand != null ) {
			cc.compose(new CommandProxy(refreshConnectionCommand));
		}

		return new ICommandProxy(cc);
	}

	/**
	 * Gets the command to create a new view (and optionally element) for an
	 * unspecified type request. This command includes a command to popup a menu
	 * to prompt the user for the type to be created.
	 * 
	 * @@param request
	 *            the unspecified type request
	 * @@return the command
	 */
	private Command getUnspecifiedTypeCreateCommand(
			final CreateUnspecifiedTypeRequest request) {

		final Map createCmds = new HashMap();
		List validTypes = new ArrayList();
		for (Iterator iter = request.getElementTypes().iterator(); iter
			.hasNext();) {
			IElementType elementType = (IElementType) iter.next();
			Request createRequest = request.getRequestForType(elementType);
			if (createRequest != null) {
				EditPart target = getHost().getTargetEditPart(createRequest);
				if ( target == null )  {
					continue;
				}
				Command individualCmd = target.getCommand(createRequest);

				if (individualCmd != null && individualCmd.canExecute()) {
					createCmds.put(elementType, individualCmd);
					validTypes.add(elementType);
				}
			}
		}

		if (createCmds.isEmpty()) {
			return null;
		} else if (createCmds.size() == 1) {
			return (Command) createCmds.values().toArray()[0];
		} else {
			CreateOrSelectElementCommand selectAndCreateViewCmd = new CreateOrSelectElementCommand(
                DiagramUIMessages.CreateCommand_Label, Display.getCurrent()
                    .getActiveShell(), validTypes) {
				
				private Command _createCmd;
				/**
				 * Execute the command that prompts the user with the popup
				 * menu, then executes the command prepared for the element
				 * type that the user selected.
				 */
				protected CommandResult doExecuteWithResult(
                        IProgressMonitor progressMonitor, IAdaptable info)
                    throws ExecutionException {
                    
					CommandResult cmdResult = super.doExecuteWithResult(progressMonitor, info);
					if (!cmdResult.getStatus().isOK()) {
						return cmdResult;
					}

					IElementType type = (IElementType) cmdResult
						.getReturnValue();

					_createCmd = (Command) createCmds.get(type);
					Assert.isTrue(_createCmd != null && _createCmd.canExecute());
					
					// validate the affected files
					IStatus status = validateAffectedFiles(_createCmd);
					if (!status.isOK()) {
						return new CommandResult(status);
					}
					
					_createCmd.execute();

					// Set the result in the unspecified type request.
					CreateRequest createRequest = request
						.getRequestForType(type);
                    
                    Collection newObject = ((Collection) createRequest
                            .getNewObject());
					request.setNewObject(newObject);

					return CommandResult.newOKCommandResult(newObject);
				}
				
				protected CommandResult doUndoWithResult(
                        IProgressMonitor progressMonitor, IAdaptable info)
                    throws ExecutionException {
                    
					if (_createCmd != null && _createCmd.canUndo() ) {
						// validate the affected files
						IStatus status = validateAffectedFiles(_createCmd);
						if (!status.isOK()) {
							return new CommandResult(status);
						}
						_createCmd.undo();
					}
					return super.doUndoWithResult(progressMonitor, info);
				}
				
				protected CommandResult doRedoWithResult(
                        IProgressMonitor progressMonitor, IAdaptable info)
                    throws ExecutionException {
                    
					if (_createCmd != null && CommandUtilities.canRedo(_createCmd)) {
						// validate the affected files
						IStatus status = validateAffectedFiles(_createCmd);
						if (!status.isOK()) {
							return new CommandResult(status);
						}
						_createCmd.redo();
					}
					return super.doRedoWithResult(progressMonitor, info);
				}
				
				private IStatus validateAffectedFiles(Command command) {
					Collection affectedFiles = CommandUtilities
							.getAffectedFiles(command);
					int fileCount = affectedFiles.size();
					if (fileCount > 0) {
						return FileModificationValidator
								.approveFileModification((IFile[]) affectedFiles
										.toArray(new IFile[fileCount]));
					}
					return Status.OK_STATUS;
				}
			};

			return new ICommandProxy(selectAndCreateViewCmd);
		}
	}
	
	/** Return the host if this editpolicy understands the supplied request. */
	public EditPart getTargetEditPart(Request request) {
		return understandsRequest(request) ? getHost() : null;
	}
}
@


1.15
log
@[149249] gmf_head crevells 070619 Undo label not that applicable when using unspecified type tools
@
text
@d50 1
d155 3
a157 1
			
d174 41
@


1.14
log
@[161668] gmf_head ldamus 061122 File validation not performed when using UnspecifiedTypeCreationTool
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
d23 1
a64 1
import org.eclipse.jface.util.Assert;
d362 3
a364 2
			CreateOrSelectElementCommand selectAndCreateConnectionCmd = new CreateOrSelectElementCommand(
				Display.getCurrent().getActiveShell(), validTypes) {
d369 1
a369 1
				 * menu, then executes the command prepared for the relationship
d449 1
a449 1
			return new ICommandProxy(selectAndCreateConnectionCmd);
@


1.14.2.1
log
@[111892] gmf_head crevells 070518 First milestone of group/ungroup support (painting issues when grouping shapes with border items)
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2007 IBM Corporation and others.
a22 1
import org.eclipse.core.runtime.Assert;
a48 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.GroupEditPart;
d64 1
a153 3
            if (ep instanceof GroupEditPart) {
                cc.compose(getReparentGroupCommand((GroupEditPart) ep));
            }
d170 7
a176 51
    
    /**
     * Return the command to reparent the supplied group editpart's semantic and
     * notation elements.
     * 
     * @@param gep
     *            the groupEP editpart being reparented
     * @@return A composite command that will reparent both the semantic and
     *         notation elements of the group.
     */
    protected ICommand getReparentGroupCommand(GroupEditPart groupEP) {
        CompositeCommand cc = new CompositeCommand(
            DiagramUIMessages.AddCommand_Label);
        View container = (View) getHost().getModel();
        EObject context = ViewUtil.resolveSemanticElement(container);

        // semantic
        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        for (Iterator iter = groupEP.getFlattenedChildren().iterator(); iter
            .hasNext();) {
            IGraphicalEditPart childEP = (IGraphicalEditPart) iter.next();
            EObject element = ViewUtil.resolveSemanticElement((View) childEP
                .getModel());
            if (element != null) {
                Command moveSemanticCmd = getHost().getCommand(
                    new EditCommandRequestWrapper(new MoveRequest(
                        editingDomain, context, element)));

                if (moveSemanticCmd == null) {
                    return org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand.INSTANCE;
                }

                cc.compose(new CommandProxy(moveSemanticCmd));
            }
        }

        // notation
        cc.compose(getReparentViewCommand(groupEP));
        return cc;
    }

    /**
     * Return the command to reparent the supplied editpart's semantic and
     * notation elements.
     * 
     * @@param gep
     *            the editpart being reparented
     * @@return A CompositeCommand2 that will reparent both the semantic and
     *         notation elements.
     */
@


1.13
log
@[160048] gmf_head ldamus 061060 Redoing command to create unspecified types in CreationEditPolicy tests ICommand#canExecute rather than ICommand#canRedo
@
text
@d22 1
d25 2
d38 1
d385 7
d410 5
d425 5
d434 12
@


1.12
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d40 1
d408 1
a408 1
					if (_createCmd != null && _createCmd.canExecute() ) {
@


1.11
log
@[139856] gmf_head anthonyh 060614 EtoolsProxyCommand should be renamed to ICommandProxy
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
d385 4
a388 2
					request.setNewObject(((Collection) createRequest
						.getNewObject()));
d390 1
a390 1
					return CommandResult.newOKCommandResult();
@


1.11.2.1
log
@Bugzilla#148076 gmf_R1_0_maintenance cmahoney 060706 Creation using multi-tool does not go into direct edit mode
@
text
@d385 2
a386 4
                    
                    Collection newObject = ((Collection) createRequest
                            .getNewObject());
					request.setNewObject(newObject);
d388 1
a388 1
					return CommandResult.newOKCommandResult(newObject);
@


1.11.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@


1.11.2.3
log
@[160048] gmf_R1_0_maintenance ldamus 061060 Redoing command to create unspecified types in CreationEditPolicy tests ICommand#canExecute rather than ICommand#canRedo
@
text
@a39 1
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandUtilities;
d407 1
a407 1
					if (_createCmd != null && CommandUtilities.canRedo(_createCmd)) {
@


1.11.2.4
log
@[161668] gmf_R1_0_maintenance ldamus 061122 File validation not performed when using UnspecifiedTypeCreationTool
@
text
@a21 1
import org.eclipse.core.resources.IFile;
a23 2
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
a34 1
import org.eclipse.gmf.runtime.common.core.command.FileModificationValidator;
a380 7
					
					// validate the affected files
					IStatus status = validateAffectedFiles(_createCmd);
					if (!status.isOK()) {
						return new CommandResult(status);
					}
					
a398 5
						// validate the affected files
						IStatus status = validateAffectedFiles(_createCmd);
						if (!status.isOK()) {
							return new CommandResult(status);
						}
a408 5
						// validate the affected files
						IStatus status = validateAffectedFiles(_createCmd);
						if (!status.isOK()) {
							return new CommandResult(status);
						}
a412 12
				
				private IStatus validateAffectedFiles(Command command) {
					Collection affectedFiles = CommandUtilities
							.getAffectedFiles(command);
					int fileCount = affectedFiles.size();
					if (fileCount > 0) {
						return FileModificationValidator
								.approveFileModification((IFile[]) affectedFiles
										.toArray(new IFile[fileCount]));
					}
					return Status.OK_STATUS;
				}
@


1.10
log
@[143611] gmf_head ldamus 060530 Impossible to create top level elements in the Taipan/Mindmap samples
@
text
@d42 1
a42 1
import org.eclipse.gmf.runtime.diagram.ui.commands.EtoolsProxyCommand;
d163 1
a163 1
		return cc.isEmpty() ? null : new EtoolsProxyCommand(cc.reduce());
d249 1
a249 1
		return new EtoolsProxyCommand(cc.reduce());
d317 1
a317 1
		return new EtoolsProxyCommand(cc);
d412 1
a412 1
			return new EtoolsProxyCommand(selectAndCreateConnectionCmd);
@


1.9
log
@Bugzilla#139204 gmf_head cmahoney 050206 NPE in CreationEditPolicy.getReparentCommand when moveSemanticCmd is null
@
text
@d39 1
a43 1
import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy;
a57 1
import org.eclipse.gmf.runtime.notation.Diagram;
d274 5
a278 7
			EObject hostElement;
			if (view instanceof Diagram){
				hostElement = view.getDiagram();
			}
			else{
				hostElement = ViewUtil.resolveSemanticElement(view);
			}				
@


1.8
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d190 4
d299 1
a299 1
		if (createElementCommand == null)
@


1.7
log
@bugzilla 109923 gmf-head mmostafa 060201 Class names contain 'xtools'
@
text
@d21 2
d25 1
d53 1
a53 1
import org.eclipse.gmf.runtime.emf.commands.core.command.CompositeModelCommand;
d144 1
a144 1
		CompositeCommand cc = new CompositeCommand(DiagramUIMessages.AddCommand_Label);
d164 1
a164 1
		return cc.isEmpty() ? null : new EtoolsProxyCommand(cc.unwrap());
d171 1
a171 1
	 * @@return A CompositeCommand that will reparent both the semantic and notation elements.
d174 1
a174 1
		CompositeCommand cc = new CompositeCommand(DiagramUIMessages.AddCommand_Label); 
d180 4
a183 1
		//
d189 1
a189 1
						new MoveRequest(context, element)));
d207 1
a207 1
		return new AddCommand(new EObjectAdapter(container),
d228 6
a233 2
		CompositeModelCommand cc = new CompositeModelCommand(DiagramUIMessages.AddCommand_Label);
		Iterator descriptors = request.getViewDescriptors().iterator();
d240 1
a240 1
				new CreateCommand(
d246 1
a246 1
		return new EtoolsProxyCommand(cc.unwrap());
d309 1
a309 1
		CompositeCommand cc = new CompositeCommand(semanticCommand.getLabel());
a363 2
				 * 
				 * @@see org.eclipse.gmf.runtime.common.core.command.AbstractCommand#doExecute(org.eclipse.core.runtime.IProgressMonitor)
d365 5
a369 3
				protected CommandResult doExecute(
						IProgressMonitor progressMonitor) {
					CommandResult cmdResult = super.doExecute(progressMonitor);
d387 1
a387 1
					return newOKCommandResult();
d390 4
a393 1
				protected CommandResult doUndo() {
d397 1
a397 1
					return super.doUndo();
d400 4
a403 1
				protected CommandResult doRedo() {
d407 1
a407 1
					return super.doRedo();
@


1.6
log
@bugzilla 119065 gmf-head mmostafa 051224 Enahnce the ViewRefactorHelper utility
@
text
@d40 1
a40 1
import org.eclipse.gmf.runtime.diagram.ui.commands.XtoolsProxyCommand;
d185 1
a185 1
			cc.compose ( new XtoolsProxyCommand(moveSemanticCmd) );
d301 1
a301 1
		cc.compose(new XtoolsProxyCommand(viewCommand));
d303 1
a303 1
			cc.compose(new XtoolsProxyCommand(refreshConnectionCommand));
@


1.5
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d26 1
d285 3
@


1.4
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@a28 3
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.widgets.Display;

d34 1
d42 1
a42 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
a48 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d56 2
d140 1
a140 1
		CompositeCommand cc = new CompositeCommand(DiagramResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
d170 1
a170 1
		CompositeCommand cc = new CompositeCommand(DiagramResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
d221 1
a221 1
		CompositeModelCommand cc = new CompositeModelCommand(DiagramResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d44 1
a44 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d49 1
a49 1
import org.eclipse.gmf.runtime.diagram.ui.requests.RefreshConnectorsRequest;
d141 1
a141 1
		CompositeCommand cc = new CompositeCommand(PresentationResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
d171 1
a171 1
		CompositeCommand cc = new CompositeCommand(PresentationResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
d222 1
a222 1
		CompositeModelCommand cc = new CompositeModelCommand(PresentationResourceManager.getI18NString("AddCommand.Label")); //$NON-NLS-1$
d290 1
a290 1
		Command refreshConnectorCommand =
d292 1
a292 1
				new RefreshConnectorsRequest(((List)request.getNewObject())));
d299 2
a300 2
		if ( refreshConnectorCommand != null ) {
			cc.compose(new XtoolsProxyCommand(refreshConnectorCommand));
d343 1
a343 1
			CreateOrSelectElementCommand selectAndCreateConnectorCmd = new CreateOrSelectElementCommand(
d392 1
a392 1
			return new EtoolsProxyCommand(selectAndCreateConnectorCmd);
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d55 2
a56 2
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.View;
@

