head	1.2;
access;
symbols
	v20081023-2107:1.2
	v20081022-1925:1.2
	v20081022-1005:1.2
	v20081020-0700:1.2
	v20080917-1925:1.2
	v20080916-2008:1.2
	v20080911-1728:1.2
	v20080911-1506:1.2
	v20080910-1520:1.2
	v20080910-1510:1.2
	v20080903-1520:1.2
	v20080903-1510:1.2
	v20080813-1510:1.2
	v20080811-1546:1.2
	v20080731-1520:1.2
	v20080725-1738:1.2
	v20080723-2246:1.2
	v20080723-2232:1.2
	v20080723-1700:1.2
	v20080722-1827:1.2
	v20080718-1700:1.2
	v20080718-1731:1.2
	v20080716-1600:1.2
	v20080716-1642:1.2
	R2_1_maintenance:1.2.0.2
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080610-1132:1.2
	v20080603-1553:1.2
	v20080527-1255:1.1
	v20080516-1748:1.1
	v20080516-1143:1.1
	v20080512-1200:1.1
	v20080503-1740:1.1
	v20080501-1739:1.1
	v20080425-1959:1.1
	v20080417-1610:1.1
	v20080407-2250:1.1
	v20080407-0930:1.1
	v20080404-1111:1.1
	v20080328-1605:1.1
	v20080322-0000:1.1
	v20080222-1200:1.1
	v20080201-2010:1.1
	v20080114-1111:1.1;
locks; strict;
comment	@# @;


1.2
date	2008.06.03.18.10.51;	author aboyko;	state Exp;
branches;
next	1.1;
commitid	8e24845892b4567;

1.1
date	2008.01.11.15.59.37;	author crevells;	state Exp;
branches;
next	;
commitid	6a2c478792684567;


desc
@@


1.2
log
@[235361] gmf_head aboyko 080603 Up and down arrow key moves list items in compartments instead of moving the selection
@
text
@/******************************************************************************
 * Copyright (c) 2007, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.services.palette;

import org.eclipse.draw2d.XYLayout;
import org.eclipse.gef.DragTracker;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPolicy;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.editpolicies.NonResizableEditPolicy;
import org.eclipse.gef.tools.SelectionTool;
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.BorderItemContainerFigure;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.KeyEvent;
import org.eclipse.swt.events.TraverseEvent;

/**
 * GMF's customized version of GEF's <code>SelectionTool</code> overridden to:
 * <li>support traversing of shapes on a diagram using the TAB and SHIFT + TAB
 * keys</li>
 * <li>support moving a shape with the arrow keys without first accessing the
 * traverse handles</li>
 * 
 * @@author crevells
 */
public class SelectionToolEx
    extends SelectionTool {

    /**
     * Are the traverse handles being used? That is, has the '.' key been
     * pressed first before using the arrow keys?
     */
    private boolean isUsingTraverseHandles = false;

    protected void handleKeyTraversed(TraverseEvent e) {
        resetHover();

        // Tab and shift tab will be used for shape selection on the diagram, so
        // we must override the system tab traversal and ensure we get the key
        // pressed events.
        if (acceptTabKey(e)) {
            e.doit = false;
        } else {
            super.handleKeyTraversed(e);
        }
    }

    /* (non-Javadoc)
     * @@see org.eclipse.gef.tools.SelectionTool#handleKeyDown(org.eclipse.swt.events.KeyEvent)
     */
    protected boolean handleKeyDown(KeyEvent e) {
		resetHover();

		if (acceptTabKey(e)) {
			if (getCurrentViewer().getKeyHandler() != null) {
				return getCurrentViewer().getKeyHandler().keyPressed(e);
			}
		}

		if (acceptArrowKeyOnly(e) && getState() == STATE_INITIAL
				&& !getCurrentViewer().getSelectedEditParts().isEmpty()) {

			EditPart selectedEP = (EditPart) getCurrentViewer()
					.getSelectedEditParts().get(0);
			
			if (selectedEP instanceof GraphicalEditPart) {
			
				GraphicalEditPart gep = (GraphicalEditPart) selectedEP; 
	
				/*
				 * The shape we'll be moved in the direction of the arrow key iff:
				 * 1) It has the appropriate edit policy that supports shape moving installed on the editpart
				 * 2) The editparts figure's parent layout manager is some sort of XYLayout
				 * In all other cases we just change the selection based on arrow key (implemented in GEF).  
				 */
				if (gep.getEditPolicy(EditPolicy.PRIMARY_DRAG_ROLE) instanceof NonResizableEditPolicy
						&& gep.getFigure().getParent() != null
						&& (gep.getFigure().getParent().getLayoutManager() instanceof XYLayout
								|| gep.getFigure().getParent() instanceof BorderItemContainerFigure)) {
	
					resetHover();
		
					if (getDragTracker() != null)
						getDragTracker().deactivate();
		
					setState(STATE_ACCESSIBLE_DRAG_IN_PROGRESS);
		
					setTargetEditPart(gep);
		
					updateTargetRequest();
					DragTracker dragTracker = gep
							.getDragTracker(getTargetRequest());
					if (dragTracker != null) {
						setDragTracker(dragTracker);
						dragTracker.keyDown(e, getCurrentViewer());
						lockTargetEditPart(gep);
						return true;
					}
					return false;
				}
			}
		}
		return super.handleKeyDown(e);
	}

    /* (non-Javadoc)
     * @@see org.eclipse.gef.tools.SelectionTool#handleKeyUp(org.eclipse.swt.events.KeyEvent)
     */
    protected boolean handleKeyUp(KeyEvent e) {
        boolean returnVal = super.handleKeyUp(e);
        if (acceptArrowKeyOnly(e) && !isUsingTraverseHandles) {
            if (getDragTracker() != null) {
                getDragTracker().commitDrag();
            }
            setDragTracker(null);
            setState(STATE_INITIAL);
            unlockTargetEditPart();
        }
        return returnVal;
    }

    /**
     * Returns true if the event corresponds to a tab key and if the system is
     * in a state where the tab key should be accepted.
     * 
     * @@param e
     *            the <code>KeyEvent</code>
     * @@return true if the tab key should be accepted.
     */
    private boolean acceptTabKey(KeyEvent e) {
        return isInState(STATE_INITIAL | STATE_ACCESSIBLE_DRAG
            | STATE_ACCESSIBLE_DRAG_IN_PROGRESS)
            && e.keyCode == SWT.TAB
            && (e.stateMask & (SWT.ALT | SWT.CONTROL)) == 0;
    }

    /**
     * Returns true if the event corresponds to an arrow key without any
     * modifiers and if the system is in a state where the arrow key should be
     * accepted.
     * 
     * @@param e
     *            the <code>KeyEvent</code>
     * @@return true if the tab key should be accepted.
     */
    private boolean acceptArrowKeyOnly(KeyEvent e) {
        int key = e.keyCode;
        if (!(isInState(STATE_INITIAL | STATE_ACCESSIBLE_DRAG
            | STATE_ACCESSIBLE_DRAG_IN_PROGRESS))) {
            return false;
        }
        return ((key == SWT.ARROW_UP) || (key == SWT.ARROW_RIGHT)
            || (key == SWT.ARROW_DOWN) || (key == SWT.ARROW_LEFT))
            && (e.stateMask & (SWT.ALT | SWT.CONTROL | SWT.SHIFT)) == 0;
    }

    protected void setState(int state) {
        if (state == STATE_TRAVERSE_HANDLE) {
            isUsingTraverseHandles = true;
        } else if (state == STATE_INITIAL) {
            isUsingTraverseHandles = false;
        }
        super.setState(state);
    }

}
@


1.1
log
@[111901] gmf_head crevells 080111 [KeyboardBindings] Ability to move shapes using cursors keys. (by default)
@
text
@d14 1
d17 3
d21 1
d57 3
d61 1
a61 1
        resetHover();
d63 51
a113 5
        if (acceptTabKey(e)) {
            if (getCurrentViewer().getKeyHandler() != null) {
                return getCurrentViewer().getKeyHandler().keyPressed(e);
            }
        }
d115 3
a117 34
        if (acceptArrowKeyOnly(e) && getState() == STATE_INITIAL) {
            if (!stateTransition(STATE_INITIAL,
                STATE_ACCESSIBLE_DRAG_IN_PROGRESS)) {
                resetHover();
                return true;
            }
            resetHover();

            if (getDragTracker() != null)
                getDragTracker().deactivate();

            if (!getCurrentViewer().getSelectedEditParts().isEmpty()) {
                EditPart selectedEP = (EditPart) getCurrentViewer()
                    .getSelectedEditParts().get(0);
                setTargetEditPart(selectedEP);

                if (selectedEP != null) {
                    updateTargetRequest();
                    DragTracker dragTracker = selectedEP
                        .getDragTracker(getTargetRequest());
                    if (dragTracker != null) {
                        setDragTracker(dragTracker);
                        dragTracker.keyDown(e, getCurrentViewer());
                        lockTargetEditPart(selectedEP);
                        return true;
                    }
                }
                return false;
            }
        }
        return super.handleKeyDown(e);
    }

    @@Override
@

