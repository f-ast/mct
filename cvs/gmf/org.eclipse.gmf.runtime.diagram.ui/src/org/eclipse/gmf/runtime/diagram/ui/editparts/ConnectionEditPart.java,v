head	1.48;
access;
symbols
	v20081023-2107:1.48
	v20081022-1925:1.48
	v20081022-1005:1.48
	v20081020-0700:1.48
	v20080917-1925:1.48
	v20080916-2008:1.48
	v20080911-1728:1.48
	v20080911-1506:1.48
	v20080910-1520:1.48
	v20080910-1510:1.48
	v20080903-1520:1.48
	v20080903-1510:1.48
	v20080813-1510:1.48
	v20080811-1546:1.48
	v20080731-1520:1.48
	v20080725-1738:1.48
	v20080723-2246:1.48
	v20080723-2232:1.48
	v20080723-1700:1.48
	v20080722-1827:1.48
	v20080718-1700:1.48
	v20080718-1731:1.48
	v20080716-1600:1.48
	v20080716-1642:1.48
	R2_1_maintenance:1.48.0.2
	Root_R2_1_maintenance:1.48
	R2_1_0:1.48
	v20080610-1132:1.48
	v20080603-1553:1.48
	v20080527-1255:1.48
	v20080527-1151:1.40
	v20080516-1748:1.48
	v20080516-1143:1.48
	v20080512-1200:1.48
	v20080503-1740:1.47
	v20080501-2127:1.40
	v20080501-1739:1.46
	m20080429-1543:1.40
	v20080425-1959:1.46
	v20080417-1610:1.46
	v20080407-2250:1.46
	v20080407-0930:1.46
	v20080404-1111:1.46
	v20080328-1605:1.45
	v20080322-0000:1.45
	v20080222-1200:1.44
	v20080201-2010:1.44
	v20080201-0201:1.40
	v20080118-1129:1.40
	v20080114-2222:1.40
	v20080114-1111:1.44
	v20080107-1111:1.43
	v20071222-1111:1.41
	v20071214-1111:1.41
	v20071130-1111:1.41
	v20071124-0000:1.40
	v20071112-0000:1.40
	v20071108-0000:1.40
	v20071003-0000:1.40
	v20070915-0000:1.40
	v20070903-0000:1.40
	v20070809-0000:1.40
	R2_0_maintenance:1.40.0.4
	R2_0:1.40
	R4_20:1.40
	v20070621-0000:1.40
	RC3_20:1.40
	v20070614-1400:1.40
	v20070608-1300:1.40
	v20070605-1400:1.40
	v20070601-1400:1.40
	v20070525-1500:1.40
	v20070518-1300:1.40
	bugzilla111892_group_support:1.40.0.2
	Root_bugzilla111892_group_support:1.40
	v20070504-1000:1.39
	v20070420-1000:1.39
	v20070413-1300:1.39
	v20070330-1300:1.39
	v20060330-1300:1.39
	v20070322-1100:1.39
	v20060316-0600:1.39
	v20070221-1500:1.39
	v20070208-1800:1.39
	v20070202-0200:1.35.2.12
	v20070119-1200:1.35.2.12
	v20070111-0800:1.35.2.12
	v20070105-1200:1.35.2.12
	v20070103-0300:1.38
	M4_20:1.38
	v20061218-1500:1.35.2.12
	v20061218-1200:1.38
	v20061214-0000:1.38
	M3_20:1.36
	v20061117-0800:1.36
	v20061027-1200:1.35.2.10
	v20061013-1330:1.36
	v20061012-1100:1.35.2.10
	v20060925-1700:1.35.2.10
	v20060919-0800:1.35.2.10
	v20060907-1100:1.35.2.10
	M1_20:1.35
	v20060831-1500:1.35.2.10
	v20060824-1600:1.35.2.10
	v20060817-1500:1.35.2.8
	v20060810-1700:1.35.2.8
	v20060803-1200:1.35.2.7
	v20060728-0500:1.35.2.3
	v20060721-1130:1.35.2.3
	v20060713-1700:1.35.2.1
	R1_0_maintenance:1.35.0.2
	R1_0:1.35
	v20060627-1200:1.35
	v20060616-1400:1.35
	v20060616-1200:1.35
	v20060609-1400:1.34
	v20060531-1730:1.32
	v20060530-1930:1.30
	v20060526-1200:1.30
	v20060519-0800:1.30
	v20060512-1000:1.30
	I20060512-1000:1.30
	I20060505-1400:1.29
	I20060428-1300:1.29
	I20060424-0500:1.29
	I20060424-0300:1.29
	M6_10:1.29
	I20060407-1200:1.28
	I20060331-1000:1.28
	I20060324-0300:1.28
	I20060317-1300:1.28
	I20060317-1200:1.28
	I20060316-1300:1.28
	I20060309-1300:1.28
	M5_10:1.25
	S20060303-1600:1.25
	I20060227-1730:1.24
	I20060216-1945:1.22
	I20060210-1715:1.21
	I20060209-1815:1.21
	I20060203-0830:1.20
	I20060202-1415:1.20
	I20060129-1145:1.20
	I20060127-0900:1.19
	I20060120-1530:1.19
	I20060113-1700:1.18
	M4_10:1.18
	I20060107-1100:1.17
	I20060105-1630:1.17
	I20051230-1230:1.17
	I20051223-1100:1.16
	I20051217-0925:1.16
	I20051208-2000:1.15
	I20051201-1800:1.15
	I20051124-2000:1.14
	M3_10:1.14
	I20051118-1245:1.14
	I20051111-1800:1.14
	I20051106-0900:1.13
	v20051030:1.12;
locks; strict;
comment	@# @;


1.48
date	2008.05.09.20.27.23;	author aboyko;	state Exp;
branches;
next	1.47;
commitid	67644824b3ab4567;

1.47
date	2008.05.03.20.56.21;	author ahunter;	state Exp;
branches;
next	1.46;
commitid	608a481cd1724567;

1.46
date	2008.04.04.18.23.22;	author aboyko;	state Exp;
branches;
next	1.45;
commitid	56a447f672194567;

1.45
date	2008.03.17.22.02.30;	author aboyko;	state Exp;
branches;
next	1.44;
commitid	231447deea764567;

1.44
date	2008.01.11.15.59.37;	author crevells;	state Exp;
branches;
next	1.43;
commitid	6a2c478792684567;

1.43
date	2008.01.03.17.42.57;	author aboyko;	state Exp;
branches;
next	1.42;
commitid	3287477d1ea14567;

1.42
date	2008.01.02.20.06.58;	author aboyko;	state Exp;
branches;
next	1.41;
commitid	5a82477beee14567;

1.41
date	2007.11.23.14.11.40;	author crevells;	state Exp;
branches;
next	1.40;
commitid	9084746df9c4567;

1.40
date	2007.05.11.22.17.46;	author mmostafa;	state Exp;
branches;
next	1.39;
commitid	75b54644eb894567;

1.39
date	2007.01.16.14.53.59;	author mmostafa;	state Exp;
branches;
next	1.38;
commitid	78d445ace7064567;

1.38
date	2006.12.06.22.01.19;	author mmostafa;	state Exp;
branches;
next	1.37;
commitid	627645773dae4567;

1.37
date	2006.11.22.17.40.01;	author ldamus;	state Exp;
branches;
next	1.36;
commitid	7a8c45648b714567;

1.36
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.16.15.34.30;	author sshaw;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2006.06.05.20.30.20;	author sshaw;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.02.13.15.59;	author sshaw;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.31.17.05.01;	author sshaw;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.31.16.26.07;	author sshaw;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.09.19.45.24;	author cmahoney;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.12.14.08.37;	author sshaw;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.09.22.44.20;	author ldamus;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.09.16.33.15;	author cmahoney;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.08.16.54.44;	author cmahoney;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.28.02.31.20;	author cmahoney;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.23.21.42.21;	author sshaw;	state Exp;
branches;
next	1.23;

1.23
date	2006.02.23.20.31.56;	author sshaw;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.13.19.11.49;	author ldamus;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.07.15.19.06;	author mmostafa;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.27.20.22.56;	author sshaw;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.17.18.47.09;	author sshaw;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.11.23.43.41;	author cmahoney;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.23.20.27.17;	author mmostafa;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.08.22.53.39;	author sshaw;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.25.19.38.13;	author cmahoney;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.08.18.50.25;	author sshaw;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.02.23.30.15;	author sshaw;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.14.20.58.50;	author mmostafa;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.03.18.08.31;	author sshaw;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.23.20.55.29;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.23.18.50.51;	author sshaw;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.23.18.37.25;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.22.15.42.19;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.15.14.59.19;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.12.21.29.05;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.16.04.33;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.15.48.52;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.36;	author sshaw;	state Exp;
branches;
next	;

1.35.2.1
date	2006.07.11.15.10.29;	author cmahoney;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2006.07.14.21.02.16;	author cmahoney;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2006.07.18.22.37.27;	author mmostafa;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2006.08.01.18.18.00;	author mmostafa;	state Exp;
branches;
next	1.35.2.5;

1.35.2.5
date	2006.08.01.19.10.23;	author mmostafa;	state Exp;
branches;
next	1.35.2.6;

1.35.2.6
date	2006.08.02.13.38.48;	author mmostafa;	state Exp;
branches;
next	1.35.2.7;

1.35.2.7
date	2006.08.02.19.31.24;	author ldamus;	state Exp;
branches;
next	1.35.2.8;

1.35.2.8
date	2006.08.10.20.39.18;	author mmostafa;	state Exp;
branches;
next	1.35.2.9;

1.35.2.9
date	2006.08.17.20.47.57;	author sshaw;	state Exp;
branches;
next	1.35.2.10;

1.35.2.10
date	2006.08.22.14.54.26;	author cmahoney;	state Exp;
branches;
next	1.35.2.11;

1.35.2.11
date	2006.11.22.18.05.17;	author ldamus;	state Exp;
branches;
next	1.35.2.12;
commitid	28a34564915d4567;

1.35.2.12
date	2006.12.06.22.00.53;	author mmostafa;	state Exp;
branches;
next	;
commitid	5d5745773d954567;


desc
@@


1.48
log
@[[231365] gmf_head aboyko 080509 [Layout] Support routing of invalid connections
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editparts;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IAdapterFactory;
import org.eclipse.core.runtime.Platform;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.ConnectionLayer;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PolygonDecoration;
import org.eclipse.draw2d.PolylineDecoration;
import org.eclipse.draw2d.RelativeBendpoint;
import org.eclipse.draw2d.RotatableDecoration;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.transaction.RunnableWithResult;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gef.AccessibleEditPart;
import org.eclipse.gef.DragTracker;
import org.eclipse.gef.EditDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartViewer;
import org.eclipse.gef.EditPolicy;
import org.eclipse.gef.LayerConstants;
import org.eclipse.gef.Request;
import org.eclipse.gef.RequestConstants;
import org.eclipse.gef.RootEditPart;
import org.eclipse.gef.SnapToHelper;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gef.commands.UnexecutableCommand;
import org.eclipse.gef.editparts.AbstractConnectionEditPart;
import org.eclipse.gef.editpolicies.SnapFeedbackPolicy;
import org.eclipse.gef.requests.CreateConnectionRequest;
import org.eclipse.gef.requests.DropRequest;
import org.eclipse.gef.requests.GroupRequest;
import org.eclipse.gef.requests.ReconnectRequest;
import org.eclipse.gef.requests.TargetRequest;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.services.action.filter.ActionFilterService;
import org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker;
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener;
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectionBendpointEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectionLabelsEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.DecorationEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.PropertyHandlerEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.SemanticEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.ToggleCanonicalModeCommand;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IContainedEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IEditableEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.ConnectionEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.ConnectionLineSegEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.TreeConnectionBendpointEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
import org.eclipse.gmf.runtime.diagram.ui.internal.ruler.SnapToHelperUtil;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.editpolicy.EditPolicyService;
import org.eclipse.gmf.runtime.diagram.ui.internal.type.NotationTypeUtil;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramColorRegistry;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramEditDomain;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateConnectionViewRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.EditCommandRequestWrapper;
import org.eclipse.gmf.runtime.diagram.ui.services.editpart.EditPartService;
import org.eclipse.gmf.runtime.diagram.ui.util.EditPartUtil;
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx;
import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.ConnectionLayerEx;
import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ForestRouter;
import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.OrthogonalRouter;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;
import org.eclipse.gmf.runtime.gef.ui.internal.editpolicies.GraphicalEditPolicyEx;
import org.eclipse.gmf.runtime.gef.ui.internal.l10n.Cursors;
import org.eclipse.gmf.runtime.gef.ui.internal.tools.SelectConnectionEditPartTracker;
import org.eclipse.gmf.runtime.notation.ArrowStyle;
import org.eclipse.gmf.runtime.notation.ArrowType;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.FontStyle;
import org.eclipse.gmf.runtime.notation.JumpLinkStatus;
import org.eclipse.gmf.runtime.notation.JumpLinkType;
import org.eclipse.gmf.runtime.notation.LineStyle;
import org.eclipse.gmf.runtime.notation.LineType;
import org.eclipse.gmf.runtime.notation.LineTypeStyle;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.RelativeBendpoints;
import org.eclipse.gmf.runtime.notation.Routing;
import org.eclipse.gmf.runtime.notation.RoutingStyle;
import org.eclipse.gmf.runtime.notation.Smoothness;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.preference.PreferenceConverter;
import org.eclipse.jface.resource.DeviceResourceException;
import org.eclipse.jface.resource.FontDescriptor;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.resource.ResourceManager;
import org.eclipse.osgi.util.NLS;
import org.eclipse.swt.SWT;
import org.eclipse.swt.accessibility.AccessibleEvent;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.ui.IActionFilter;

/**
 * the base edit part that controls <code>Edge</code> views, it is the basic
 * controller for the connection's view
 * 
 * @@author mmostafa
 */
abstract public class ConnectionEditPart
    extends AbstractConnectionEditPart
    implements IGraphicalEditPart, PropertyChangeListener, IContainedEditPart,
    IPrimaryEditPart, NotificationListener {

    /** A map of listener filters ids to filter data */
    private Map listenerFilters;

    /** Used for registering and unregistering the edit part */
    private String elementGuid;

    /**
     * Flag to indicate if the edit part is in edit mode
     */
    private boolean isEditable = true;

    /** Used for accessibility. */
    protected AccessibleEditPart accessibleEP;

    /**
     * Cache the editing domain after it is retrieved.
     */
    private TransactionalEditingDomain editingDomain;

     
    /**
     * Cache the font data when a font is created so that it can be
     * disposed later.
     */
    private FontData cachedFontData;
    
    /**
	 * Cache the answer to whether or not this is a semantic connection after it
	 * is retrieved.
	 */
    private Boolean semanticConnection;
    
    /** counter that tracs the recursive depth of the getCommand() method. */
    private static volatile int GETCOMMAND_RECURSIVE_COUNT = 0;
    
    /** A list of editparts who's canonical editpolicies are to be temporarily disabled. */
    private static Set _disableCanonicalEditPolicyList = new HashSet();
    
    /**
     * gets a property change command for the passed property, using both of the
     * old and new values
     * 
     * @@param property
     *            the property associated with the command
     * @@param oldValue
     *            the old value associated with the command
     * @@param newValue
     *            the new value associated with the command
     * @@return a command
     */
    protected Command getPropertyChangeCommand(Object property,
            Object oldValue, Object newValue) {
        // by default return null, which means there is no special command to
        // change the property
        return null;
    }
    
    

    protected void addChild(EditPart child, int index) {
        super.addChild(child, index);
        if (child instanceof GraphicalEditPart){
            GraphicalEditPart gEP = (GraphicalEditPart)child;
            boolean editMode = isEditModeEnabled(); 
            if (editMode != gEP.isEditModeEnabled()){
                if (editMode)
                    gEP.enableEditMode();
                else
                    gEP.disableEditMode();
            }
        }
    }



    /**
     * Register the adapters for the standard properties.
     */
    static {
        registerAdapters();
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#activate()
     */
    public void activate() {
    	
    	if (isActive()) {
            return;
        }
    	
        addNotationalListeners();

        EObject semanticProxy = ((View) getModel()).getElement();
        EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(),
            semanticProxy);

        if (semanticElement != null)
            addSemanticListeners();
        else if (semanticProxy != null) {
            addListenerFilter("SemanticProxy", this, semanticProxy); //$NON-NLS-1$
        }
        super.activate();
    }

    /**
     * Adds a listener filter by adding the given listener to a passed notifier
     * 
     * @@param filterId
     *            A unique filter id (within the same editpart instance)
     * @@param listener
     *            A listener instance
     * @@param notifier
     *            An element notifer to add the listener to
     */
    protected void addListenerFilter(String filterId,
            NotificationListener listener, EObject element) {

        if (element == null)
            return;

    	assert filterId != null;
    	assert listener != null;

        if (listenerFilters == null)
            listenerFilters = new HashMap();

        getDiagramEventBroker().addNotificationListener(element, listener);
        listenerFilters.put(filterId, new Object[] {element, listener});
    }

    /**
     * Adds a listener filter by adding the given listener to a passed notifier
     * 
     * @@param filterId
     *            A unique filter id (within the same editpart instance)
     * @@param listener
     *            A listener instance
     * @@param notifier
     *            An element notifer to add the listener to
     */
    protected void addListenerFilter(String filterId,
            NotificationListener listener, EObject element,
            EStructuralFeature feature) {

        if (element == null)
            return;

    	assert filterId != null;
    	assert listener != null;

        if (listenerFilters == null)
            listenerFilters = new HashMap();

        getDiagramEventBroker().addNotificationListener(element, feature,
            listener);
        listenerFilters
            .put(filterId, new Object[] {element, feature, listener});
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createChild(java.lang.Object)
     */
    final protected EditPart createChild(Object model) {
        return EditPartService.getInstance()
            .createGraphicEditPart((View) model);
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractGraphicalEditPart#createConnection(java.lang.Object)
     */
    final protected org.eclipse.gef.ConnectionEditPart createConnection(
            Object connectionView) {
        return (org.eclipse.gef.ConnectionEditPart) createChild(connectionView);
    }

    /**
     * Overridden to support editpolicies installed programmatically and via the
     * <code>EditPolicyService</code>. Subclasses should override
     * <code>createDefaultEditPolicies()</code>.
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
     */
    final protected void createEditPolicies() {
        createDefaultEditPolicies();
        EditPolicyService.getInstance().createEditPolicies(this);
    }

    /**
     * Should be overridden to install editpolicies programmatically.
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
     */
    protected void createDefaultEditPolicies() {
        installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
            new SemanticEditPolicy());
        installEditPolicy(EditPolicyRoles.PROPERTY_HANDLER_ROLE,
            new PropertyHandlerEditPolicy());
        installEditPolicy(EditPolicy.CONNECTION_ENDPOINTS_ROLE,
            new org.eclipse.gef.editpolicies.ConnectionEndpointEditPolicy());
        installEditPolicy(EditPolicy.CONNECTION_ROLE,
            new ConnectionEditPolicy());
        installBendpointEditPolicy();
        installEditPolicy(EditPolicyRoles.DECORATION_ROLE,
            new DecorationEditPolicy());
        installEditPolicy(EditPolicyRoles.CONNECTION_LABELS_ROLE,
            new ConnectionLabelsEditPolicy());

        installEditPolicy(EditPolicyRoles.SNAP_FEEDBACK_ROLE,
            new SnapFeedbackPolicy());
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#deactivate()
     */
   public void deactivate() {
	   
	   if (!isActive()) {
           return;
       }
	   
        boolean wasActive = isActive();
        super.deactivate();
        if (listenerFilters != null && wasActive != isActive()) {
            for (Iterator i = listenerFilters.keySet().iterator(); i.hasNext();) {
                Object[] obj = (Object[]) listenerFilters.get(i.next());
                if (obj.length > 2) {
                    getDiagramEventBroker().removeNotificationListener(
                        (EObject) obj[0], (EStructuralFeature) obj[1],
                        (NotificationListener) obj[2]);
                } else {
                    getDiagramEventBroker().removeNotificationListener(
                        (EObject) obj[0], (NotificationListener) obj[1]);
                }
            }
        }
    }

    public void removeNotify() {
        super.removeNotify();
        
        if (cachedFontData != null) {
            getResourceManager().destroyFont(
                FontDescriptor.createFrom(cachedFontData));
            cachedFontData = null;
        }
    }

    /**
     * executes the passed command
     * 
     * @@param command
     *            the command to execute
     */
    protected void executeCommand(Command command) {
        getEditDomain().getCommandStack().execute(command);
    }

    /**
     * a function that registers this provider with the Eclipse AdapterManager
     * as an IView and an IActionFilter adapter factory for the
     * IGraphicalEditPart nodes
     * 
     */
    static private void registerAdapters() {
        Platform.getAdapterManager().registerAdapters(new IAdapterFactory() {

            /**
             * @@see org.eclipse.core.runtime.IAdapterFactory
             */
            public Object getAdapter(Object adaptableObject, Class adapterType) {

                IGraphicalEditPart gep = (IGraphicalEditPart) adaptableObject;

                if (adapterType == IActionFilter.class) {
                    return ActionFilterService.getInstance();
                } else if (adapterType == View.class) {
                    return gep.getModel();
                }
                return null;
            }

            /**
             * @@see org.eclipse.core.runtime.IAdapterFactory
             */
            public Class[] getAdapterList() {
                return new Class[] {IActionFilter.class, View.class};
            }

        }, IGraphicalEditPart.class);
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#getAccessibleEditPart()
     */
    protected AccessibleEditPart getAccessibleEditPart() {
        if (accessibleEP == null) {
            accessibleEP = new AccessibleGraphicalEditPart() {

                private String getSemanticName() {
                    EObject semanticElement = resolveSemanticElement();

                    if (semanticElement != null) {
                        String name = semanticElement.getClass().getName();
                        int startIndex = name.lastIndexOf('.') + 1;
                        int endIndex = name.lastIndexOf("Impl"); //$NON-NLS-1$
                        return name.substring(startIndex, endIndex);
                    }

                    return DiagramUIMessages.Accessible_Connection_Label;
                }

                public void getName(AccessibleEvent e) {

                    EditPart sourceEP = getSource();
                    EditPart targetEP = getTarget();

                    // Get the Connection Name
                    String connectionName = getSemanticName();

                    // Get the Source Name
                    String sourceName = null;
                    if (sourceEP != null) {
                        AccessibleEditPart aEP = (AccessibleEditPart) sourceEP
                            .getAdapter(AccessibleEditPart.class);
                        AccessibleEvent event = new AccessibleEvent(this);
                        aEP.getName(event);
                        sourceName = event.result;
                    }

                    // Get the Target Name
                    String targetName = null;
                    if (targetEP != null) {
                        AccessibleEditPart aEP = (AccessibleEditPart) targetEP
                            .getAdapter(AccessibleEditPart.class);
                        AccessibleEvent event = new AccessibleEvent(this);
                        aEP.getName(event);
                        targetName = event.result;
                    }

                    if (sourceName != null && targetName != null) {
                        e.result = NLS
                            .bind(
                                DiagramUIMessages.Accessible_Connection_From_Source_To_Target,
                                new Object[] {connectionName, sourceName,
                                    targetName});
                    } else if (sourceName != null) {
                        e.result = NLS
                            .bind(
                                DiagramUIMessages.Accessible_Connection_From_Source,
                                new Object[] {connectionName, sourceName});
                    } else if (targetName != null) {
                        e.result = NLS.bind(
                            DiagramUIMessages.Accessible_Connection_To_Target,
                            new Object[] {connectionName, targetName});
                    } else {
                        e.result = connectionName;
                    }
                }
            };
        }
        return accessibleEP;
    }

    /**
     * Adds the ability to adapt to this editpart's view class.
     */
    public Object getAdapter(Class key) {
        Object adapter = Platform.getAdapterManager().getAdapter(this, key);
        if (adapter != null) {
            return adapter;
        }

        if (key == SnapToHelper.class) {   
            return SnapToHelperUtil.getSnapHelper(
            		(org.eclipse.gef.GraphicalEditPart) this.getSource());
        }        

        Object model = getModel();

        if (View.class.isAssignableFrom(key) && key.isInstance(model)) {
            return model;
        }

        if (model != null && model instanceof View) {
            // Adapt to semantic element
            EObject semanticObject = ViewUtil
                .resolveSemanticElement((View) model);
            if (key.isInstance(semanticObject)) {
                return semanticObject;
            }else if (key.isInstance(model)) {
                return model;
            }
        }
        return super.getAdapter(key);
    }

    /**
     * Method getChildBySemanticHint.
     * 
     * @@param semanticHint
     * @@return IGraphicalEditPart
     */
    public IGraphicalEditPart getChildBySemanticHint(String semanticHint) {
        if (getModel() != null) {
            View view = ViewUtil.getChildBySemanticHint((View) getModel(),
                semanticHint);
            if (view != null)
                return (IGraphicalEditPart) getViewer().getEditPartRegistry()
                    .get(view);
        }
        return null;
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#getCommand(org.eclipse.gef.Request)
     */
    public Command getCommand(Request _request) {
        if (!isEditModeEnabled()) {
            return UnexecutableCommand.INSTANCE;
        }

        Command cmd = null;
        try {
            GETCOMMAND_RECURSIVE_COUNT++;
            final Request request = _request;
            try {
                cmd = (Command) getEditingDomain().runExclusive(
                    new RunnableWithResult.Impl() {

                        public void run() {
                            setResult(ConnectionEditPart.super
                                .getCommand(request));
                        }
                    });
            } catch (InterruptedException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "getCommand", e); //$NON-NLS-1$
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                    "getCommand", e); //$NON-NLS-1$
            }
            

            if ( cmd != null ) {
                _disableCanonicalEditPolicyList.addAll(disableCanonicalFor(_request));
            }
            
            GETCOMMAND_RECURSIVE_COUNT--;
            
            if ( GETCOMMAND_RECURSIVE_COUNT == 0 ) {
                if ( cmd != null 
                        && !_disableCanonicalEditPolicyList.isEmpty() ) {
                    CompoundCommand cc = new CompoundCommand();
                    cc.setLabel( cmd.getLabel() );
                    ToggleCanonicalModeCommand tcmd = 
                        ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(_disableCanonicalEditPolicyList, false);
                    cc.add( tcmd );
                    cc.add( cmd );
                    ToggleCanonicalModeCommand tcmd2 = ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(tcmd, true);
                    if (tcmd2 != null) {
                        tcmd2.setDomain(getEditingDomain());
                    }
                    cc.add( tcmd2 );
                    _disableCanonicalEditPolicyList.clear();
                    return cc.unwrap();
                }
            }
        }
        catch( RuntimeException t ) {
            GETCOMMAND_RECURSIVE_COUNT = 0;
            throw t;
        }
        return cmd;
    }
    
    /**
     * Return a list of editparts who's canonical editpolicies should be disabled
     * prior to executing the commands associated to the supplied request.
     * This implementation will return the editpart honoring a <code>SemanticWrapperRequest</code>
     * and a <code>CreateConnectionViewRequest</code>'s source and target editparts.
     *
     * @@param request a request that has returned a command.
     * @@return list of editparts.
     */
    protected Collection disableCanonicalFor( final Request request ) {
        //
        // not the most generic of solution; however, it will have to do for now...
        //
        // Alternate solutions
        // 1. common request interface on all the requests
        //  IRequest#getAffectedEditParts
        //
        // 2. Traverse down the command and collect of the ICommand#getAffectedObjects()
        //  -- this requires that all our commands properly set this value.
        
        Set hosts = new HashSet();
        if ( (request instanceof EditCommandRequestWrapper)  
                || request instanceof TargetRequest
                || request instanceof DropRequest ) {
            hosts.add(this);
            hosts.add(getParent());
        }
        if((request instanceof ReconnectRequest)) {
            ReconnectRequest reconnect = (ReconnectRequest)request;
            hosts.add(this);
            hosts.add(getParent());
            if(reconnect.getTarget() != null) {
                EditPart target  = reconnect.getTarget();
                addEditPartAndParent(hosts, target);
            }
            if(reconnect.getConnectionEditPart() != null) {
                org.eclipse.gef.ConnectionEditPart connectionEditPart = reconnect.getConnectionEditPart();
                if(connectionEditPart.getSource() != null) {
                    EditPart srcEP = connectionEditPart.getSource();
                    addEditPartAndParent(hosts, srcEP);
                }
                if(connectionEditPart.getTarget() != null) {
                    EditPart trgEP = connectionEditPart.getTarget();
                    addEditPartAndParent(hosts, trgEP);
                }
            }
        }
        if ((request instanceof CreateConnectionRequest) ) {
            CreateConnectionRequest ccvr = (CreateConnectionRequest)request;
            hosts.add(this);
            hosts.add(getParent());
            if ( ccvr.getSourceEditPart() != null ) {
                hosts.add( ccvr.getSourceEditPart());
                hosts.add( ccvr.getSourceEditPart().getParent());
            }
            if ( ccvr.getTargetEditPart() != null ) {
                hosts.add( ccvr.getTargetEditPart());
                hosts.add( ccvr.getTargetEditPart().getParent());
            }
        }
        if ((request instanceof GroupRequest)) {
            List parts = ((GroupRequest)request).getEditParts();
            hosts.add(this);
            hosts.add(getParent());
        
            Iterator editparts = parts == null ? Collections.EMPTY_LIST.iterator() : parts.iterator();  
            while ( editparts.hasNext() ) {
                EditPart ep = (EditPart)editparts.next();
                addEditPartAndParent(hosts, ep);
            }
        }
        
        /////////////////////////////////////////////////////////////
        // This following behavior is specific to BorderItemEditPart and
        // AbstractBorderItemEditPart, but we do not want to allow clients to
        // override this method so we do not want to make it protected.
        
        if (this instanceof IBorderItemEditPart) {
            if ((request instanceof CreateConnectionViewRequest)) {
                CreateConnectionViewRequest ccvr = (CreateConnectionViewRequest) request;
                if (ccvr.getSourceEditPart() instanceof IBorderItemEditPart) {
                    hosts.add(ccvr.getSourceEditPart().getParent().getParent());
                }
                if (ccvr.getTargetEditPart() instanceof IBorderItemEditPart) {
                    hosts.add(ccvr.getTargetEditPart().getParent().getParent());
                }
            }
        }
        /////////////////////////////////////////////////////////////

        return hosts;
    }
    
    private void addEditPartAndParent(Set hosts, EditPart editPart) {
        hosts.add(editPart);
        hosts.add(editPart.getParent());
    }

    
    

    /**
     * Convenience method returning the editpart's Diagram, the Diagam that owns
     * the edit part
     * 
     * @@return the diagram
     */
    protected Diagram getDiagramView() {
        return (Diagram) getRoot().getContents().getModel();
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getPrimaryView()
     */
    public View getPrimaryView() {
        for (EditPart parent = this; parent != null; parent = parent
            .getParent())
            if (parent instanceof IPrimaryEditPart)
                return (View) parent.getModel();
        return null;
    }

    /**
     * Convenience method returning the editpart's edit domain. Same as calling
     * <code>getRoot().getViewer().getEditDomain()</code>
     * 
     * @@return the edit domain
     */
    protected EditDomain getEditDomain() {
        return getRoot().getViewer().getEditDomain();
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramEditDomain()
     */
    public IDiagramEditDomain getDiagramEditDomain() {
        return (IDiagramEditDomain) getEditDomain();
    }

    /**
     * Return this editpart's view (model) children.
     * 
     * @@return list of views.
     */
    protected List getModelChildren() {
        return ((View) getModel()).getChildren();
    }

    /**
     * Convenience method to retreive the value for the supplied value from the
     * editpart's associated view element. Same as calling
     * <code> ViewUtil.getStructuralFeatureValue(getNotationView(),feature)</code>.
     */
    public Object getStructuralFeatureValue(EStructuralFeature feature) {
        return ViewUtil.getStructuralFeatureValue((View) getModel(), feature);
    }

    /**
     * try to resolve the semantic element and Return the resolven element; if
     * the element is unresolvable or null it will return null
     * 
     * @@return non proxy EObject or NULL
     */
    public EObject resolveSemanticElement() {
        EObject eObj = ((View) getModel()).getElement();
        if (eObj == null) {
            return null;
        }

        if (!eObj.eIsProxy()) {
            return eObj;
        }

        try {
            return (EObject) getEditingDomain().runExclusive(
                new RunnableWithResult.Impl() {

                    public void run() {
                        setResult(ViewUtil
                            .resolveSemanticElement((View) getModel()));
                    }
                });
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "resolveSemanticElement", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "resolveSemanticElement", e); //$NON-NLS-1$
            return null;
        }
    }

    /**
     * Walks up the editpart hierarchy to find and return the
     * <code>TopGraphicEditPart</code> instance.
     */
    public TopGraphicEditPart getTopGraphicEditPart() {
        EditPart editPart = this;
        while (editPart instanceof IGraphicalEditPart) {
            if (editPart instanceof TopGraphicEditPart)
                return (TopGraphicEditPart) editPart;
            editPart = editPart.getParent();
        }
        return null;
    }

    /**
     * Return the editpart's associated Notation View.
     * 
     * @@return <code>View</code>, the associated view or null if there is no
     *         associated Notation View
     */
    public View getNotationView() {
        Object model = getModel();
        if (model instanceof View)
            return (View) model;
        return null;
    }

    /**
     * Handles the passed property changed event only if the editpart's view is
     * not deleted
     */
    public final void propertyChange(PropertyChangeEvent event) {
        if (isActive())
            handlePropertyChangeEvent(event);
    }

    /**
     * Handles the property changed event. Clients should override to respond to
     * the specific notification events they are interested.
     * 
     * Note: This method may get called on a non-UI thread. Clients should
     * either ensure that their code is thread safe and/or doesn't make
     * unsupported calls (i.e. Display.getCurrent() ) assuming they are on the
     * main thread. Alternatively if this is not possible, then the client can
     * wrap their handler within the Display.synchExec runnable to ensure
     * synchronization and subsequent execution on the main thread.
     * 
     * @@param event
     *            the <code>Notification</code> object that is the property
     *            changed event
     */
    protected void handlePropertyChangeEvent(PropertyChangeEvent event) {
        if (event.getPropertyName().equals(
            Connection.PROPERTY_CONNECTION_ROUTER)) {
            installRouter();
        }
    }

    /**
     * Method reactivateSemanticModel. This method reactivates the edit part's
     * emantic model by: 1- removing semantic listeners 2- adding semantic
     * listeners if the semantic reference is resolvable 3- Refreshing it
     * 
     * This method is called in response to IView's Properties.ID_SEMANTICREF
     * property change event However, it will only work under the following
     * assumptions: 1- The old and new semantic models are compatible in their
     * kind 2- The deltas between old and new semantic models do not affect
     * notation 3- Connections are not refereshed since they are maintained by
     * the diagram
     */
    public void reactivateSemanticModel() {
        removeSemanticListeners();
        if (resolveSemanticElement() != null)
            addSemanticListeners();
        refresh();
    }

    /** Finds an editpart given a starting editpart and an EObject */
    public EditPart findEditPart(EditPart epBegin, EObject theElement) {
        if (theElement == null) {
            return null;
        }
        EditPart epStart = null;
        if (epBegin == null) {
            epStart = this;
        } else {
            epStart = epBegin;
        }

        final View view = (View) ((IAdaptable) epStart).getAdapter(View.class);

        if (view != null) {
            EObject el = ViewUtil.resolveSemanticElement(view);

            if ((el != null) && el.equals(theElement)) {
                return epStart;
            }
        }

        ListIterator childLI = epStart.getChildren().listIterator();
        while (childLI.hasNext()) {
            EditPart epChild = (EditPart) childLI.next();

            EditPart elementEP = findEditPart(epChild, theElement);
            if (elementEP != null) {
                return elementEP;
            }
        }
        return null;
    }

    /**
     * Refresh the editpart's figure foreground colour.
     */
    protected void refreshForegroundColor() {
        LineStyle style = (LineStyle) getPrimaryView().getStyle(
            NotationPackage.Literals.LINE_STYLE);
        if (style != null)
            setForegroundColor(DiagramColorRegistry.getInstance().getColor(
                new Integer(style.getLineColor())));
    }

    /**
     * Refresh the editpart's figure visibility.
     */
    protected void refreshVisibility() {
        setVisibility(((View) getModel()).isVisible());
    }

    /**
     * Removes a listener previously added with the given id
     * 
     * @@param filterId
     *            the filiter ID
     */
    protected void removeListenerFilter(String filterId) {
        if (listenerFilters == null)
            return;

        Object[] objects = (Object[]) listenerFilters.get(filterId);
        if (objects == null) {
            return;
        }

        if (objects.length > 2) {
            getDiagramEventBroker().removeNotificationListener(
                (EObject) objects[0], (EStructuralFeature) objects[1],
                (NotificationListener) objects[2]);
        } else {
            getDiagramEventBroker().removeNotificationListener(
                (EObject) objects[0], (NotificationListener) objects[1]);
        }
        listenerFilters.remove(filterId);
    }

    /**
     * sets the forefround color of the editpart's figure
     * 
     * @@param color
     *            the color
     */
    protected void setForegroundColor(Color color) {
        getFigure().setForegroundColor(color);
    }

    /**
     * Sets the passed feature if possible on this editpart's view to the passed
     * value.
     * 
     * @@param feature
     *            the feature to use
     * @@param value
     *            the value of the property being set
     */
    public void setStructuralFeatureValue(EStructuralFeature feature,
            Object value) {
        ViewUtil.setStructuralFeatureValue((View) getModel(), feature, value);
    }

    /**
     * sets the edit part's visibility
     * 
     * @@param vis
     *            the new visibilty value
     */
    protected void setVisibility(boolean vis) {
        if (!vis && getSelected() != SELECTED_NONE)
            getViewer().deselect(this);
        getFigure().setVisible(vis);
        getFigure().revalidate();
    }

    /**
     * This method adds all listeners to the notational world (views, figures,
     * editpart...etc) Override this method to add more notational listeners
     * down the hierarchy
     */
    protected void addNotationalListeners() {
        addListenerFilter("View", this, (View) getModel());//$NON-NLS-1$
        getFigure().addPropertyChangeListener(
            Connection.PROPERTY_CONNECTION_ROUTER, this);
    }

    /**
     * This method adds all listeners to the semantic element behind this
     * EditPart Override this method to add more semantic listeners down the
     * hierarchy This method is called only if the semantic element is
     * resolvable
     */
    protected void addSemanticListeners() {
        addListenerFilter("SemanticModel",//$NON-NLS-1$
            this, resolveSemanticElement());
    }

    /**
     * This method removes all listeners to the notational world (views,
     * figures, editpart...etc) Override this method to remove notational
     * listeners down the hierarchy
     */
    protected void removeNotationalListeners() {
        getFigure().removePropertyChangeListener(
            Connection.PROPERTY_CONNECTION_ROUTER, this);
        removeListenerFilter("View");//$NON-NLS-1$
    }

    /**
     * This method removes all listeners to the semantic element behind this
     * EditPart Override this method to remove semantic listeners down the
     * hierarchy
     */
    protected void removeSemanticListeners() {
        removeListenerFilter("SemanticModel");//$NON-NLS-1$
    }

    /**
     * @@see org.eclipse.gef.EditPart#addNotify()
     */
    public void addNotify() {
        super.addNotify();
        installRouter();
    }

    /**
     * a static array of appearance property ids applicable to the connections
     */
    protected static final String[] appearanceProperties = new String[] {
        Properties.ID_FONTNAME, Properties.ID_FONTSIZE, Properties.ID_FONTBOLD,
        Properties.ID_FONTITALIC, Properties.ID_FONTCOLOR,
        Properties.ID_LINECOLOR};

    /**
     * construcotr
     * 
     * @@param view ,
     *            the view the edit part will own
     */
    public ConnectionEditPart(View view) {
        setModel(view);
    }

    /**
     * Method createConnectionFigure.
     * 
     * @@return a <code>Connection</code> figure
     */
    abstract protected Connection createConnectionFigure();

    final protected IFigure createFigure() {
        return createConnectionFigure();
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#refresh()
     */
    public void refresh() {
        if (getSource() != null && getTarget() != null) {
            try {
                getEditingDomain().runExclusive(new Runnable() {

                    public void run() {
                        ConnectionEditPart.super.refresh();
                        EditPolicyIterator i = getEditPolicyIterator();
                        while (i.hasNext()) {
                            EditPolicy policy = i.next();
                            if (policy instanceof GraphicalEditPolicyEx) {
                                ((GraphicalEditPolicyEx) policy).refresh();
                            }
                        }
                    }
                });
            } catch (InterruptedException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "refresh", e); //$NON-NLS-1$
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                    "refresh", e); //$NON-NLS-1$
            }
        }
    }

    /**
     * utility method to get the <code>Edge</code> view
     * 
     * @@return the <code>Edge</code>
     */
    protected Edge getEdge() {
        return (Edge) getModel();
    }

    /*
     * @@see AbstractEditPart#getDragTracker(Request)
     */
    public DragTracker getDragTracker(Request req) {
        return new SelectConnectionEditPartTracker(this);
    }

    /**
     * give access to the source of the edit part's Edge
     * 
     * @@return the source
     */
    protected Object getModelSource() {
        return getEdge().getSource();
    }

    /**
     * give access to the target of the edit part's Edge
     * 
     * @@return the target
     */
    protected Object getModelTarget() {
        return getEdge().getTarget();
    }

    /**
     * installes a router on the edit part, depending on the
     * <code>RoutingStyle</code>
     */
    protected void installRouter() {
        ConnectionLayer cLayer = (ConnectionLayer) getLayer(LayerConstants.CONNECTION_LAYER);
        RoutingStyle style = (RoutingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);

        if (style != null && cLayer instanceof ConnectionLayerEx) {

            ConnectionLayerEx cLayerEx = (ConnectionLayerEx) cLayer;
            Routing routing = style.getRouting();
            if (Routing.MANUAL_LITERAL == routing) {
                getConnectionFigure().setConnectionRouter(
                    cLayerEx.getObliqueRouter());
            } else if (Routing.RECTILINEAR_LITERAL == routing) {
                getConnectionFigure().setConnectionRouter(
                    cLayerEx.getRectilinearRouter());
            } else if (Routing.TREE_LITERAL == routing) {
                getConnectionFigure().setConnectionRouter(
                    cLayerEx.getTreeRouter());
            }

        }

        refreshRouterChange();
    }

    /**
     * refresh the pendpoints owned by the EditPart's <code>Edge</code>
     */
    protected void refreshBendpoints() {
        RelativeBendpoints bendpoints = (RelativeBendpoints) getEdge()
            .getBendpoints();
        List modelConstraint = bendpoints.getPoints();
        List figureConstraint = new ArrayList();
        for (int i = 0; i < modelConstraint.size(); i++) {
            org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint wbp = (org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint) modelConstraint
                .get(i);
            RelativeBendpoint rbp = new RelativeBendpoint(getConnectionFigure());
            rbp.setRelativeDimensions(new Dimension(wbp.getSourceX(), wbp
                .getSourceY()), new Dimension(wbp.getTargetX(), wbp
                .getTargetY()));
            if (modelConstraint.size() == 1) {
            	rbp.setWeight(0.5f);
            } else {
            	rbp.setWeight(i / ((float) modelConstraint.size() - 1));
            }
            figureConstraint.add(rbp);
        }
        getConnectionFigure().setRoutingConstraint(figureConstraint);
    }

    private void installBendpointEditPolicy() {
        if (getConnectionFigure().getConnectionRouter() instanceof ForestRouter) {
            installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
                new TreeConnectionBendpointEditPolicy());
        } else if (getConnectionFigure().getConnectionRouter() instanceof OrthogonalRouter) {
            installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
                new ConnectionLineSegEditPolicy());
        } else {
            installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
                new ConnectionBendpointEditPolicy());
        }

        EditPartUtil.synchronizeRunnableToMainThread(this, new Runnable() {

            public void run() {
                if (getConnectionFigure().getConnectionRouter() instanceof ForestRouter) {
                    getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
                } else if (getConnectionFigure().getConnectionRouter() instanceof OrthogonalRouter) {
                    getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
                } else {
                    getConnectionFigure().setCursor(Cursors.CURSOR_SEG_ADD);
                }
            };
        });
    }

    /**
     * Method refreshRouterChange.
     */
    protected void refreshRouterChange() {
        refreshBendpoints();
        installBendpointEditPolicy();
    }

    /**
     * Method refreshSmoothness.
     */
    protected void refreshSmoothness() {
        Connection connection = getConnectionFigure();
        if (!(connection instanceof PolylineConnectionEx))
            return;

        PolylineConnectionEx poly = (PolylineConnectionEx) connection;
        RoutingStyle style = (RoutingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);
        if (style != null) {
            Smoothness smoothness = style.getSmoothness();

            if (Smoothness.LESS_LITERAL == smoothness) {
                poly.setSmoothness(PolylineConnectionEx.SMOOTH_LESS);
            } else if (Smoothness.NORMAL_LITERAL == smoothness) {
                poly.setSmoothness(PolylineConnectionEx.SMOOTH_NORMAL);
            } else if (Smoothness.MORE_LITERAL == smoothness) {
                poly.setSmoothness(PolylineConnectionEx.SMOOTH_MORE);
            } else if (Smoothness.NONE_LITERAL == smoothness) {
                poly.setSmoothness(PolylineConnectionEx.SMOOTH_NONE);
            }
        }
    }

    /**
     * Method refreshJumplinks.
     */
    protected void refreshJumplinks() {
        Connection connection = getConnectionFigure();
        if (!(connection instanceof PolylineConnectionEx))
            return;

        PolylineConnectionEx poly = (PolylineConnectionEx) connection;
        RoutingStyle style = (RoutingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);

        JumpLinkStatus status = JumpLinkStatus.NONE_LITERAL;
        JumpLinkType type = JumpLinkType.SEMICIRCLE_LITERAL;
        boolean reverse = false;
        if (style != null) {
            status = style.getJumpLinkStatus();
            type = style.getJumpLinkType();
            reverse = style.isJumpLinksReverse();
        }

        int jumpType = 0;
        if (JumpLinkStatus.BELOW_LITERAL == status) {
            jumpType = PolylineConnectionEx.JUMPLINK_FLAG_BELOW;
        } else if (JumpLinkStatus.ABOVE_LITERAL == status) {
            jumpType = PolylineConnectionEx.JUMPLINK_FLAG_ABOVE;
        } else if (JumpLinkStatus.ALL_LITERAL == status) {
            jumpType = PolylineConnectionEx.JUMPLINK_FLAG_ALL;
        }

        boolean bCurved = type.equals(JumpLinkType.SEMICIRCLE_LITERAL);
        boolean bAngleIn = !type.equals(JumpLinkType.SQUARE_LITERAL);
        boolean bOnBottom = reverse;

        poly.setJumpLinks(jumpType != 0);
        poly.setJumpLinksStyles(jumpType, bCurved, bAngleIn, bOnBottom);
    }

    /**
     * Method refreshRoutingStyles.
     */
    protected void refreshRoutingStyles() {
        Connection connection = getConnectionFigure();
        if (!(connection instanceof PolylineConnectionEx))
            return;

        PolylineConnectionEx poly = (PolylineConnectionEx) connection;

        RoutingStyle style = (RoutingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);
        if (style != null) {

            boolean closestDistance = style.isClosestDistance();
            boolean avoidObstruction = style.isAvoidObstructions();

            poly.setRoutingStyles(closestDistance, avoidObstruction);
            
			if (avoidObstruction)
				installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,null);
			else
				installBendpointEditPolicy();

        }
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#refreshVisuals()
     */
    protected void refreshVisuals() {
        super.refreshVisuals();
        refreshVisibility();
        refreshForegroundColor();
        refreshRoutingStyles();
        refreshSmoothness();
        refreshJumplinks();
        refreshBendpoints();
        refreshFont();
    }

    /**
     * Refresh the editpart's figure font.
     */
    protected void refreshFont() {
        FontStyle style = (FontStyle) getPrimaryView().getStyle(
            NotationPackage.Literals.FONT_STYLE);
        if (style != null) {
            setFont(new FontData(style.getFontName(), style.getFontHeight(),
                (style.isBold() ? SWT.BOLD
                    : SWT.NORMAL) | (style.isItalic() ? SWT.ITALIC
                    : SWT.NORMAL)));
        }
    }

    /**
     * Sets the font to the label. This method could be overriden to change the
     * font data of the font overrides typically look like this: super.setFont(
     * new FontData( fontData.getName(), fontData.getHeight(),
     * fontData.getStyle() <| &> SWT.????));
     * 
     * @@param fontData
     *            the font data
     */
    protected void setFont(FontData fontData) {
        if (cachedFontData != null && cachedFontData.equals(fontData)) {
            // the font was previously set and has not changed; do nothing.
            return;
        }

        try {
            Font newFont = getResourceManager().createFont(
                FontDescriptor.createFrom(fontData));
            getFigure().setFont(newFont);
            getFigure().repaint();

            if (cachedFontData != null) {
                getResourceManager().destroyFont(
                    FontDescriptor.createFrom(cachedFontData));
            }
            cachedFontData = fontData;
        } catch (DeviceResourceException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "setFont", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "setFont", e); //$NON-NLS-1$
        }
    }

    /**
     * Returns an array of the appearance property ids applicable to the
     * receiver. Fro this type it is Properties.ID_FONT,
     * Properties.ID_FONTCOLOR, Properties.ID_LINECOLOR
     * 
     * @@return - an array of the appearane property ids applicable to the
     *         receiver
     */
    protected String[] getAppearancePropertyIDs() {
        return appearanceProperties;
    }

    /**
     * Perform a request by executing a command from the target editpart of the
     * request For the Direct_Edit request, we need to show up an editor first
     * 
     * @@see org.eclipse.gef.EditPart#performRequest(org.eclipse.gef.Request)
     */
    public void performRequest(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }

        if (RequestConstants.REQ_DIRECT_EDIT == request.getType()) {
            performDirectEditRequest(request);
        } else {
            EditPart targetEditPart = getTargetEditPart(request);
            if (targetEditPart != null) {
                Command command = targetEditPart.getCommand(request);
                if (command != null) {
                    getDiagramEditDomain().getDiagramCommandStack().execute(
                        command);
                    return;
                }
            }
        }
    }

    /**
     * Performs a direct edit request (usually by showing some type of editor)
     * 
     * @@param request
     *            the direct edit request
     */
    protected void performDirectEditRequest(Request request) {
        try {
            EditPart primaryChildEditPart = (EditPart) getEditingDomain()
                .runExclusive(new RunnableWithResult.Impl() {

                    public void run() {
                        setResult(getPrimaryChildEditPart());
                    }
                });
            if (primaryChildEditPart != null) {
                primaryChildEditPart.performRequest(request);
            }

        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "performDirectEditRequest", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "performDirectEditRequest", e); //$NON-NLS-1$
        }

    }

    /**
     * @@see org.eclipse.gef.EditPart#understandsRequest(org.eclipse.gef.Request)
     */
    public boolean understandsRequest(Request req) {
        return RequestConstants.REQ_DIRECT_EDIT == req.getType()
            || super.understandsRequest(req);
    }

    /** Adds a [ref, editpart] mapping to the EditPartForElement map. */
    protected void registerModel() {
        super.registerModel();

        // Save the elements Guid to use during unregister
        EObject ref = ((View) getModel()).getElement();
        if (ref == null) {
            return;
        }

        elementGuid = EMFCoreUtil.getProxyID(ref);

        ((IDiagramGraphicalViewer) getViewer()).registerEditPartForElement(
            elementGuid, this);
    }

    /** Remove this editpart from the EditPartForElement map. */
    protected void unregisterModel() {
        super.unregisterModel();

        ((IDiagramGraphicalViewer) getViewer()).unregisterEditPartForElement(
            elementGuid, this);
    }

    /**
     * Handles the case where the semantic reference has changed.
     */
    protected final void handleMajorSemanticChange() {
        if (getSource() instanceof GraphicalEditPart
            && getTarget() instanceof GraphicalEditPart) {
            ((GraphicalEditPart) getSource()).refreshSourceConnection(this);
            ((GraphicalEditPart) getTarget()).refreshTargetConnection(this);
        }
    }

    /**
     * Refreshes a child editpart by removing it and refreshing children
     * 
     * @@param child
     */
    final void refreshChild(GraphicalEditPart child) {
        removeChild(child);
        refreshChildren();
    }

    /**
     * check if there is a canonical edit policy installed on the edit part or
     * not
     * 
     * @@return <tt>true</tt> if a canonical editpolicy has been installed on
     *         this editpart; otherwise <tt>false</tt>
     */
    public final boolean isCanonical() {
        return getEditPolicy(EditPolicyRoles.CANONICAL_ROLE) != null;
    }

    /**
     * checks if the edit part's figure is visible or not
     * 
     * @@return <tt>true</tt> if the editpart's figure is visible;
     *         <tt>false</tt> otherwise.
     */
    public boolean isSelectable() {
        return getFigure().isVisible();
    }

    /*
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#disableEditMode()
     */
    public void disableEditMode() {
        if (isEditable == false) {
            return;
        }

        List l = getSourceConnections();
        int size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        List c = getChildren();
        size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        isEditable = false;
    }

    /*
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#enableEditMode()
     */
    public void enableEditMode() {
        if (isEditable) {
            return;
        }
        isEditable = true;
        List c = getChildren();
        int size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }

        List l = getSourceConnections();
        size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }
    }

    /*
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#isEditModeEnabled()
     */
    public boolean isEditModeEnabled() {
        // protect against deadlock - don't allow any action while write
        // transaction
        // is active on another thread
        if (EditPartUtil.isWriteTransactionInProgress(this, true, true))
            return false;
        return isEditable;
    }

    /*
     * @@see org.eclipse.gef.EditPart#showSourceFeedback(org.eclipse.gef.Request)
     */
    public void showSourceFeedback(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }

        super.showSourceFeedback(request);
    }

    /*
     * @@see org.eclipse.gef.EditPart#showTargetFeedback(org.eclipse.gef.Request)
     */
    public void showTargetFeedback(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }

        super.showTargetFeedback(request);
    }

    /*
     * @@see org.eclipse.gef.EditPart#eraseSourceFeedback(org.eclipse.gef.Request)
     */
    public void eraseSourceFeedback(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }

        super.eraseSourceFeedback(request);
    }

    /*
     * @@see org.eclipse.gef.EditPart#eraseTargetFeedback(org.eclipse.gef.Request)
     */
    public void eraseTargetFeedback(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }

        super.eraseTargetFeedback(request);
    }

    /**
     * this method will return the primary child EditPart inside this edit part
     * 
     * @@return the primary child view inside this edit part
     */
    public EditPart getPrimaryChildEditPart() {
        if (getChildren().size() > 0)
            return (EditPart) getChildren().get(0);
        return null;
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramPreferencesHint()
     */
    public PreferencesHint getDiagramPreferencesHint() {
        RootEditPart root = getRoot();
        if (root instanceof IDiagramPreferenceSupport) {
            return ((IDiagramPreferenceSupport) root).getPreferencesHint();
        }
        return PreferencesHint.USE_DEFAULTS;
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener#notifyChanged(org.eclipse.emf.common.notify.Notification)
     */
    public void notifyChanged(Notification notification) {
        if (isActive()) {
            handleNotificationEvent(notification);
        }
    }

    /**
     * Handles the property changed event
     * 
     * @@param event
     *            the property changed event
     */
    protected void handleNotificationEvent(Notification event) {
        Object feature = event.getFeature();
        if (NotationPackage.Literals.VIEW__PERSISTED_CHILDREN.equals(
            feature)
            || NotationPackage.Literals.VIEW__TRANSIENT_CHILDREN.equals(
                feature)) {
            refreshChildren();
        } else if (NotationPackage.Literals.VIEW__VISIBLE.equals(feature)) {
            Object notifier = event.getNotifier();
            if (notifier == getModel())
                setVisibility(((Boolean) event.getNewValue()).booleanValue());
            // Reactivating in response to semantic model reference change
            // However, we need to verify that the event belongs to this
            // editpart's view
        } else if (NotationPackage.Literals.ROUTING_STYLE__ROUTING.equals(
            feature)) {
            installRouter();
        } else if (NotationPackage.Literals.ROUTING_STYLE__SMOOTHNESS
            .equals(feature)
            || NotationPackage.Literals.ROUTING_STYLE__AVOID_OBSTRUCTIONS
                .equals(feature)
            || NotationPackage.Literals.ROUTING_STYLE__CLOSEST_DISTANCE
                .equals(feature)
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINK_STATUS
                .equals(feature)
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINK_TYPE.equals(
                feature)
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINKS_REVERSE
                .equals(feature)) {
            refreshVisuals();
        } else if (NotationPackage.Literals.LINE_STYLE__LINE_COLOR.equals(
            feature)) {
            Integer c = (Integer) event.getNewValue();
            setForegroundColor(DiagramColorRegistry.getInstance().getColor(c));
        } else if (NotationPackage.Literals.RELATIVE_BENDPOINTS__POINTS
            .equals(feature)) {
            refreshBendpoints();
        } else if (event.getFeature() == NotationPackage.Literals
            .VIEW__ELEMENT
            && ((EObject) event.getNotifier()) == getNotationView()){
            handleMajorSemanticChange();
       } else if (event.getEventType() == EventType.UNRESOLVE
                && event.getNotifier() == ((View) getModel()).getElement())
                handleMajorSemanticChange();
    }

    /**
     * @@return <code>IMapMode</code> that allows for the coordinate mapping
     *         from device to logical units.
     */
    protected IMapMode getMapMode() {
        RootEditPart root = getRoot();
        if (root instanceof DiagramRootEditPart) {
            DiagramRootEditPart dgrmRoot = (DiagramRootEditPart) root;
            return dgrmRoot.getMapMode();
        }

        return MapModeUtil.getMapMode();
    }

    /**
     * Derives my editing domain from my diagram element. Subclasses may
     * override.
     */
    public TransactionalEditingDomain getEditingDomain() {
        if (editingDomain == null) {
            // try to get the editing domain for the model
            editingDomain = TransactionUtil.getEditingDomain(getModel());

            if (editingDomain == null) {
                // try to get the editing domain from the diagram view
                editingDomain = TransactionUtil
                    .getEditingDomain(getDiagramView());
            }
        }
        return editingDomain;
    }

    /**
     * Gets the diagram event broker from the editing domain.
     * 
     * @@return the diagram event broker
     */
    private DiagramEventBroker getDiagramEventBroker() {
        TransactionalEditingDomain theEditingDomain = getEditingDomain();
        if (theEditingDomain != null) {
            return DiagramEventBroker.getInstance(theEditingDomain);
        }
        return null;
    }
    
    
    public Object getPreferredValue(EStructuralFeature feature) {
        Object preferenceStore = getDiagramPreferencesHint()
            .getPreferenceStore();
        if (preferenceStore instanceof IPreferenceStore) {            
            if (feature == NotationPackage.eINSTANCE.getLineStyle_LineColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_LINE_COLOR));
                
            } else if (feature == NotationPackage.eINSTANCE
                .getFontStyle_FontColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_FONT_COLOR));
                
            }
        }
        return getStructuralFeatureValue(feature);
    }
    
    
    /**
     * Gets the resource manager to remember the resources allocated for this
     * graphical viewer. All resources will be disposed when the graphical
     * viewer is closed if they have not already been disposed.
     * 
     * @@return the resource manager
     */
    protected ResourceManager getResourceManager() {
        EditPartViewer viewer = getViewer();
        if (viewer instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) viewer).getResourceManager();
        }
        return JFaceResources.getResources();
    } 
    
    /**
	 * Answers whether or not this connection represents a part of the semantic
	 * model.
	 * 
	 * @@return <code>true</code> if this connection has semantic meaning,
	 *         <code>false</code> otherwise.
	 */
	public boolean isSemanticConnection() {

		if (semanticConnection == null) {
			if (getEdge() != null && (getEdge().getElement() != null
					|| !NotationTypeUtil.hasNotationType(getEdge()))) {
				semanticConnection = Boolean.TRUE;
			} else {
				semanticConnection = Boolean.FALSE;
			}
		}
		return semanticConnection.booleanValue();
	}
	
	/**
	 * Clear the semantic connection value when the model changes.
	 */
	public void setModel(Object model) {
		super.setModel(model);
		semanticConnection = null;
	}

	/**
	 * Set the line width of the connection. Clients need to override if they
	 * support line width.
	 * 
	 * @@param width
	 *            the line width.
	 */
	protected void setLineWidth(int width) {
		/* not implemented */
	}
	
	/**
	 * Get the line width of the connection.
	 * 
	 * @@return width
	 *            the line width.
	 */
	protected int getLineWidth() {
		/* a default of -1 means the diagram does not implement line width */
		int lineWidth = -1;
		
		LineStyle style = (LineStyle) getPrimaryView().getStyle(NotationPackage.eINSTANCE.getLineStyle());
		if (style != null) {
			lineWidth = style.getLineWidth();
		}

		return lineWidth;
	}
	
	/**
	 * Set the line type of the connection. Clients need to override if they
	 * support line type.
	 * 
	 * @@param lineType
	 *            the line type.
	 */
	protected void setLineType(int lineType) {
		/* not implemented */
	}
	
	/**
	 * Get the line type of the connection.
	 * 
	 * @@return the line type.
	 */
	protected int getLineType() {
		// default to Graphics.LINE_SOLID.
		int lineType = Graphics.LINE_SOLID;

		LineTypeStyle style = (LineTypeStyle) getPrimaryView().getStyle(
				NotationPackage.eINSTANCE.getLineTypeStyle());
		if (style != null) {
			if (style.getLineType() == LineType.SOLID_LITERAL) {
				lineType = Graphics.LINE_SOLID;
			} else if (style.getLineType() == LineType.DASH_LITERAL) {
				lineType = Graphics.LINE_DASH;
			} else if (style.getLineType() == LineType.DOT_LITERAL) {
				lineType = Graphics.LINE_DOT;
			} else if (style.getLineType() == LineType.DASH_DOT_LITERAL) {
				lineType = Graphics.LINE_DASHDOT;
			} else if (style.getLineType() == LineType.DASH_DOT_DOT_LITERAL) {
				lineType = Graphics.LINE_DASHDOTDOT;
			}
		}
		
		return lineType;
	}

	/**
	 * Set the arrow decoration on the connection source end. Clients need to override if they
	 * support arrow decorations.
	 * 
	 * @@param arrowDecoration
	 *            the arrow decoration.
	 */
	protected void setArrowSource(RotatableDecoration arrowDecoration) {
		/* not implemented */
	}
	
	/**
	 * Set the arrow decoration on the connection target end. Clients need to override if they
	 * support arrow decorations.
	 * 
	 * @@param arrowDecoration
	 *            the arrow type.
	 */
	protected void setArrowTarget(RotatableDecoration arrowDecoration) {
		/* not implemented */
	}
	
	/**
	 * Get the arrow decoration for the arrow type.
	 * 
	 * @@param arrowType
	 *            the arrow type.
	 */
	protected RotatableDecoration getArrowDecoration(int arrowType) {
		
		RotatableDecoration decoration = null;
		if (arrowType == ArrowType.OPEN_ARROW) {
			decoration = new PolylineDecoration();
			((PolylineDecoration)decoration).setScale(11 + getLineWidth(), 6 + getLineWidth());
			((PolylineDecoration)decoration).setTemplate(PolylineDecoration.TRIANGLE_TIP);
			((PolylineDecoration)decoration).setLineWidth(getLineWidth());
		} else if (arrowType == ArrowType.SOLID_ARROW) {
			decoration = new PolygonDecoration();
			((PolygonDecoration)decoration).setScale(11 + getLineWidth(), 6 + getLineWidth());
			((PolygonDecoration)decoration).setTemplate(PolygonDecoration.TRIANGLE_TIP);
			((PolygonDecoration)decoration).setLineWidth(getLineWidth());
			((PolygonDecoration)decoration).setFill(true);
		}
		return decoration;
	}
	
	/**
	 * Refreshes the line type property.
	 */
	protected void refreshLineWidth() {
		setLineWidth(getLineWidth());
	}

	/**
	 * Refreshes the line type property.
	 */
	protected void refreshLineType() {
		setLineType(getLineType());
	}

	/**
	 * Refreshes the arrow decoration on the source end property.
	 */
	protected void refreshArrowSource() {
		// default to no decoration.
		int arrowType = ArrowType.NONE;
		
		ArrowStyle style = (ArrowStyle) getPrimaryView().getStyle(NotationPackage.eINSTANCE.getArrowStyle());
		if (style != null) {
			arrowType = style.getArrowSource().getValue();
		}
		
		setArrowSource(getArrowDecoration(arrowType));
	}

	/**
	 * Refreshes the arrow decoration on the target end property.
	 */
	protected void refreshArrowTarget() {
		// default to no decoration.
		int arrowType = ArrowType.NONE;
		
		ArrowStyle style = (ArrowStyle) getPrimaryView().getStyle(NotationPackage.eINSTANCE.getArrowStyle());
		if (style != null) {
			arrowType = style.getArrowTarget().getValue();
		}
		
		setArrowTarget(getArrowDecoration(arrowType));
	}
}
@


1.47
log
@[225137] gmf-head ahunter 080503 Line styles enhancement
@
text
@d1221 5
a1225 1
            rbp.setWeight(i / ((float) modelConstraint.size() - 1));
@


1.46
log
@[225793] gmf_head aboyko 080404 BorderItemRectilinearRouter conflicts with RectilinearRouter
@
text
@d32 1
d34 2
d37 1
d113 2
d121 2
a1220 1
//          	rbp.setWeight((i + 1) / ((float) modelConstraint.size() + 1));
d1869 158
a2026 1
  
@


1.45
log
@GEF's GraphicalEditPart needs to be used instead of GMF's to get the snap helper for source editpart
@
text
@d1213 2
a1214 1
            rbp.setWeight((i + 1) / ((float) modelConstraint.size() + 1));
@


1.44
log
@[111901] gmf_head crevells 080111 [KeyboardBindings] Ability to move shapes using cursors keys. (by default)
@
text
@d531 1
a531 1
            		(GraphicalEditPart)this.getSource());
@


1.43
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
a80 1
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.SanpToHelperUtil;
d85 1
d530 1
a530 1
            return SanpToHelperUtil.getSnapHelper(
@


1.42
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d531 1
a531 1
            		(org.eclipse.gef.GraphicalEditPart)this.getSource());
@


1.41
log
@[194282] gmf_head crevells 071123 [RulersGrid] Useability: diagram arrange all
should snap to grid if snap to grid is on
Contributed by:  Carson Li
@
text
@d531 1
a531 1
            		(GraphicalEditPart)this.getSource());
@


1.40
log
@[186631] gmf_head mmostafa 070511 ConnectionEditPart does not implement getCommand correctly
@
text
@d529 4
a532 3
        if (key == SnapToHelper.class) {
            return SanpToHelperUtil.getSnapHelper(this);
        }
@


1.39
log
@[112799]  gmf_head mmostafa 070116 Shapes do not snap to grid when dragged over other shapes
@
text
@d17 2
d20 1
d25 1
d53 1
d57 5
d78 1
d94 2
d178 6
d579 1
a579 1
        final Request request = _request;
d581 5
a585 2
            Command cmd = (Command) getEditingDomain().runExclusive(
                new RunnableWithResult.Impl() {
d587 10
a596 12
                    public void run() {
                        setResult(ConnectionEditPart.super.getCommand(request));
                    }

                });
            return cmd;
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "getCommand", e); //$NON-NLS-1$
            Log
                .error(DiagramUIPlugin.getInstance(),
d599 122
a720 1
            return null;
d722 8
d732 3
@


1.38
log
@[162114]   gmf_head mmostafa 061206 GraphicalEditPart refresh creates a child edit part without the correct editable state
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
a37 1
import org.eclipse.gef.CompoundSnapToHelper;
a46 3
import org.eclipse.gef.SnapToGeometry;
import org.eclipse.gef.SnapToGrid;
import org.eclipse.gef.SnapToGuides;
a51 1
import org.eclipse.gef.rulers.RulerProvider;
d70 1
d511 1
a511 23

            List snapStrategies = new ArrayList();
            EditPartViewer viewer = getViewer();
            Boolean val = (Boolean) viewer
                .getProperty(RulerProvider.PROPERTY_RULER_VISIBILITY);
            if (val != null && val.booleanValue())
                snapStrategies.add(new SnapToGuides(this));

            val = (Boolean) viewer
                .getProperty(SnapToGeometry.PROPERTY_SNAP_ENABLED);
            if (val != null && val.booleanValue())
                snapStrategies.add(new SnapToGrid(this));

            if (snapStrategies.size() == 0)
                return null;

            if (snapStrategies.size() == 1)
                return snapStrategies.get(0);

            SnapToHelper ss[] = new SnapToHelper[snapStrategies.size()];
            for (int i = 0; i < snapStrategies.size(); i++)
                ss[i] = (SnapToHelper) snapStrategies.get(i);
            return new CompoundSnapToHelper(ss);
@


1.37
log
@[162133] gmf_head ldamus 061122 ConnectionEditPart deactivates itself when not active
@
text
@a117 1
import org.eclipse.jface.util.Assert;
d187 18
d254 2
a255 2
        Assert.isNotNull(filterId);
        Assert.isNotNull(listener);
d281 2
a282 2
        Assert.isNotNull(filterId);
        Assert.isNotNull(listener);
@


1.36
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d202 5
d338 5
@


1.35
log
@bugzilla 143198 gmf-head sshaw 060616 SWTExceptions occurring when handling notifications from worker thread transactions
@
text
@d42 1
a72 1
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DefaultEditableEditPart;
a77 1
import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;
d80 1
d83 1
d86 1
d89 1
d112 6
d123 1
a124 1
import org.eclipse.swt.widgets.Display;
d134 3
a136 3
	extends AbstractConnectionEditPart
	implements IGraphicalEditPart, PropertyChangeListener, IContainedEditPart,
	IPrimaryEditPart, NotificationListener {
d138 2
a139 2
	/** A map of listener filters ids to filter data */
	private Map listenerFilters;
d141 10
a150 2
	/** Used for registering and unregistering the edit part */
	private String elementGuid;
a151 3
	/** Used for accessibility. */
	protected AccessibleEditPart accessibleEP;
	
d157 10
a166 11
	/**
	 * gets a property change command for the passed property, using both of the
	 * old and new values
	 * 
	 * @@param property
	 *            the property associated with the command
	 * @@param oldValue
	 *            the old value associated with the command
	 * @@param newValue
	 *            the new value associated with the command
	 * @@return a command
d168 35
a202 6
	protected Command getPropertyChangeCommand(Object property,
			Object oldValue, Object newValue) {
		// by default return null, which means there is no special command to
		// change the property
		return null;
	}
d204 11
a214 2
	/** Used for handling the editable status of the edit part */
	private final IEditableEditPart editableEditPart;
d216 12
a227 6
	/**
	 * Register the adapters for the standard properties.
	 */
	static {
		registerAdapters();
	}
d229 2
a230 7
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.EditPart#activate()
	 */
	public void activate() {
		addNotationalListeners();
d232 2
a233 2
		EObject semanticProxy = ((View) getModel()).getElement();
		EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(), semanticProxy);
d235 2
a236 7
		if (semanticElement != null)
			addSemanticListeners();
		else if (semanticProxy != null) {
			addListenerFilter("SemanticProxy", this, semanticProxy); //$NON-NLS-1$
		}
		super.activate();
	}
d238 3
a240 12
	/**
	 * Adds a listener filter by adding the given listener to a passed notifier
	 * 
	 * @@param filterId
	 *            A unique filter id (within the same editpart instance)
	 * @@param listener
	 *            A listener instance
	 * @@param notifier
	 *            An element notifer to add the listener to
	 */
	protected void addListenerFilter(String filterId,
			NotificationListener listener, EObject element) {
d242 13
a254 2
		if (element == null)
			return;
d256 2
a257 2
		Assert.isNotNull(filterId);
		Assert.isNotNull(listener);
d259 2
a260 2
		if (listenerFilters == null)
			listenerFilters = new HashMap();
d262 2
a263 4
		getDiagramEventBroker().addNotificationListener(element,
			listener);
		listenerFilters.put(filterId, new Object[] {element, listener});
	}
d265 5
a269 28
	/**
	 * Adds a listener filter by adding the given listener to a passed notifier
	 * 
	 * @@param filterId
	 *            A unique filter id (within the same editpart instance)
	 * @@param listener
	 *            A listener instance
	 * @@param notifier
	 *            An element notifer to add the listener to
	 */
	protected void addListenerFilter(String filterId,
			NotificationListener listener, EObject element,
			EStructuralFeature feature) {

		if (element == null)
			return;

		Assert.isNotNull(filterId);
		Assert.isNotNull(listener);

		if (listenerFilters == null)
			listenerFilters = new HashMap();

		getDiagramEventBroker().addNotificationListener(element,
			feature, listener);
		listenerFilters
			.put(filterId, new Object[] {element, feature, listener});
	}
d271 9
a279 9
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#createChild(java.lang.Object)
	 */
	final protected EditPart createChild(Object model) {
		return EditPartService.getInstance()
			.createGraphicEditPart((View) model);
	}
d281 9
a289 9
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.editparts.AbstractGraphicalEditPart#createConnection(java.lang.Object)
	 */
	final protected org.eclipse.gef.ConnectionEditPart createConnection(
			Object connectionView) {
		return (org.eclipse.gef.ConnectionEditPart) createChild(connectionView);
	}
d291 11
a301 11
	/**
	 * Overridden to support editpolicies installed programmatically and via the
	 * <code>EditPolicyService</code>. Subclasses should override
	 * <code>createDefaultEditPolicies()</code>.
	 * 
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
	 */
	final protected void createEditPolicies() {
		createDefaultEditPolicies();
		EditPolicyService.getInstance().createEditPolicies(this);
	}
d303 19
a321 19
	/**
	 * Should be overridden to install editpolicies programmatically.
	 * 
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
	 */
	protected void createDefaultEditPolicies() {
		installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
			new SemanticEditPolicy());
		installEditPolicy(EditPolicyRoles.PROPERTY_HANDLER_ROLE,
			new PropertyHandlerEditPolicy());
		installEditPolicy(EditPolicy.CONNECTION_ENDPOINTS_ROLE,
			new org.eclipse.gef.editpolicies.ConnectionEndpointEditPolicy());
		installEditPolicy(EditPolicy.CONNECTION_ROLE,
			new ConnectionEditPolicy());
		installBendpointEditPolicy();
		installEditPolicy(EditPolicyRoles.DECORATION_ROLE,
			new DecorationEditPolicy());
		installEditPolicy(EditPolicyRoles.CONNECTION_LABELS_ROLE,
			new ConnectionLabelsEditPolicy());
d323 3
a325 3
		installEditPolicy(EditPolicyRoles.SNAP_FEEDBACK_ROLE,
			new SnapFeedbackPolicy());
	}
d327 22
a348 22
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.EditPart#deactivate()
	 */
	public void deactivate() {
		boolean wasActive = isActive();
		super.deactivate();
		if (listenerFilters != null && wasActive != isActive()) {
			for (Iterator i = listenerFilters.keySet().iterator(); i.hasNext();) {
				Object[] obj = (Object[]) listenerFilters.get(i.next());
				if (obj.length > 2) {
					getDiagramEventBroker().removeNotificationListener(
						(EObject) obj[0], (EStructuralFeature) obj[1],
						(NotificationListener) obj[2]);
				} else {
					getDiagramEventBroker().removeNotificationListener(
						(EObject) obj[0], (NotificationListener) obj[1]);
				}
			}
		}
	}
d350 9
a358 9
	/**
	 * executes the passed command
	 * 
	 * @@param command
	 *            the command to execute
	 */
	protected void executeCommand(Command command) {
		getEditDomain().getCommandStack().execute(command);
	}
d360 9
a368 8
	/**
	 * a function that registers this provider with the Eclipse AdapterManager
	 * as an IView and an IActionFilter adapter factory for the
	 * IGraphicalEditPart nodes
	 * 
	 */
	static private void registerAdapters() {
		Platform.getAdapterManager().registerAdapters(new IAdapterFactory() {
d370 8
a377 14
			/**
			 * @@see org.eclipse.core.runtime.IAdapterFactory
			 */
			public Object getAdapter(Object adaptableObject, Class adapterType) {

				IGraphicalEditPart gep = (IGraphicalEditPart) adaptableObject;

				if (adapterType == IActionFilter.class) {
					return ActionFilterService.getInstance();
				} else if (adapterType == View.class) {
					return gep.getModel();
				}
				return null;
			}
d379 14
a392 6
			/**
			 * @@see org.eclipse.core.runtime.IAdapterFactory
			 */
			public Class[] getAdapterList() {
				return new Class[] {IActionFilter.class, View.class};
			}
d394 6
a399 2
		}, IGraphicalEditPart.class);
	}
d401 2
a402 73
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#getAccessibleEditPart()
	 */
	protected AccessibleEditPart getAccessibleEditPart() {
		if (accessibleEP == null) {
			accessibleEP = new AccessibleGraphicalEditPart() {

				private String getSemanticName() {
					EObject semanticElement = resolveSemanticElement();

					if (semanticElement != null) {
						String name = semanticElement.getClass().getName();
						int startIndex = name.lastIndexOf('.') + 1;
						int endIndex = name.lastIndexOf("Impl"); //$NON-NLS-1$
						return name.substring(startIndex, endIndex);
					}

					return DiagramUIMessages.Accessible_Connection_Label;
				}

				public void getName(AccessibleEvent e) {

					EditPart sourceEP = getSource();
					EditPart targetEP = getTarget();

					// Get the Connection Name
					String connectionName = getSemanticName();

					// Get the Source Name
					String sourceName = null;
					if (sourceEP != null) {
						AccessibleEditPart aEP = (AccessibleEditPart) sourceEP
							.getAdapter(AccessibleEditPart.class);
						AccessibleEvent event = new AccessibleEvent(this);
						aEP.getName(event);
						sourceName = event.result;
					}

					// Get the Target Name
					String targetName = null;
					if (targetEP != null) {
						AccessibleEditPart aEP = (AccessibleEditPart) targetEP
							.getAdapter(AccessibleEditPart.class);
						AccessibleEvent event = new AccessibleEvent(this);
						aEP.getName(event);
						targetName = event.result;
					}
					
					if (sourceName != null && targetName != null) {
						e.result = NLS
							.bind(
								DiagramUIMessages.Accessible_Connection_From_Source_To_Target,
								new Object[] {connectionName, sourceName,
									targetName});
					} else if (sourceName != null) {
						e.result = NLS
							.bind(
								DiagramUIMessages.Accessible_Connection_From_Source,
								new Object[] {connectionName, sourceName});
					} else if (targetName != null) {
						e.result = NLS.bind(
							DiagramUIMessages.Accessible_Connection_To_Target,
							new Object[] {connectionName, targetName});
					} else {
						e.result = connectionName;
					}
				}
			};
		}
		return accessibleEP;
	}
d404 73
a476 8
	/**
	 * Adds the ability to adapt to this editpart's view class.
	 */
	public Object getAdapter(Class key) {
		Object adapter = Platform.getAdapterManager().getAdapter(this, key);
		if (adapter != null) {
			return adapter;
		}
d478 8
a485 1
		if (adapter == SnapToHelper.class) {
d487 1
a487 1
			List snapStrategies = new ArrayList();
d489 23
a511 21
			Boolean val = (Boolean) getViewer().getProperty(
				RulerProvider.PROPERTY_RULER_VISIBILITY);
			if (val != null && val.booleanValue())
				snapStrategies.add(new SnapToGuides(this));

			val = (Boolean) getViewer().getProperty(
				SnapToGeometry.PROPERTY_SNAP_ENABLED);
			if (val != null && val.booleanValue())
				snapStrategies.add(new SnapToGrid(this));

			if (snapStrategies.size() == 0)
				return null;

			if (snapStrategies.size() == 1)
				return snapStrategies.get(0);

			SnapToHelper ss[] = new SnapToHelper[snapStrategies.size()];
			for (int i = 0; i < snapStrategies.size(); i++)
				ss[i] = (SnapToHelper) snapStrategies.get(i);
			return new CompoundSnapToHelper(ss);
		}
d513 1
a513 1
		Object model = getModel();
d515 3
a517 3
		if (View.class.isAssignableFrom(key) && key.isInstance(model) ) {
			return getModel();
		}
d519 12
a530 12
		if (model != null && model instanceof View) {
			// Adapt to semantic element
			EObject semanticObject = ViewUtil
				.resolveSemanticElement((View) model);
			if (key.isInstance(semanticObject)) {
				return semanticObject;
			} else if (key.isInstance(model)) {
				return model;
			}
		}
		return super.getAdapter(key);
	}
d532 16
a547 16
	/**
	 * Method getChildBySemanticHint.
	 * 
	 * @@param semanticHint
	 * @@return IGraphicalEditPart
	 */
	public IGraphicalEditPart getChildBySemanticHint(String semanticHint) {
		if (getModel() != null) {
			View view = ViewUtil.getChildBySemanticHint((View) getModel(),
				semanticHint);
			if (view != null)
				return (IGraphicalEditPart) getViewer().getEditPartRegistry()
					.get(view);
		}
		return null;
	}
d549 9
a557 9
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.EditPart#getCommand(org.eclipse.gef.Request)
	 */
	public Command getCommand(Request _request) {
		if (!isEditModeEnabled()) {
			return UnexecutableCommand.INSTANCE;
		}
d559 3
a561 3
		final Request request = _request;
		try {
			Command cmd = (Command) getEditingDomain().runExclusive(
d564 40
a603 16
				public void run() {
					setResult(ConnectionEditPart.super.getCommand(request));
				}

			});
			return cmd;
		} catch (InterruptedException e) {
			Trace.catching(DiagramUIPlugin.getInstance(),
				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"getCommand", e); //$NON-NLS-1$
			Log.error(DiagramUIPlugin.getInstance(),
				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
				"getCommand", e); //$NON-NLS-1$
			return null;
		}
	}
d605 9
a613 9
	/**
	 * Convenience method returning the editpart's Diagram, the Diagam that owns
	 * the edit part
	 * 
	 * @@return the diagram
	 */
	protected Diagram getDiagramView() {
		return (Diagram) getRoot().getContents().getModel();
	}
d615 8
a622 12
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getPrimaryView()
	 */
	public View getPrimaryView() {
		for (EditPart parent = this; parent != null; parent = parent
			.getParent())
			if (parent instanceof IPrimaryEditPart)
				return (View) parent.getModel();
		return null;
	}
d624 8
a631 9
	/**
	 * Convenience method returning the editpart's edit domain. Same as calling
	 * <code>getRoot().getViewer().getEditDomain()</code>
	 * 
	 * @@return the edit domain
	 */
	protected EditDomain getEditDomain() {
		return getRoot().getViewer().getEditDomain();
	}
d633 8
a640 8
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramEditDomain()
	 */
	public IDiagramEditDomain getDiagramEditDomain() {
		return (IDiagramEditDomain) getEditDomain();
	}
d642 11
a652 8
	/**
	 * Return this editpart's view (model) children.
	 * 
	 * @@return list of views.
	 */
	protected List getModelChildren() {
		return ((View) getModel()).getChildren();
	}
d654 3
a656 8
	/**
	 * Convenience method to retreive the value for the supplied value from the
	 * editpart's associated view element. Same as calling
	 * <code> ViewUtil.getStructuralFeatureValue(getNotationView(),feature)</code>.
	 */
	public Object getStructuralFeatureValue(EStructuralFeature feature) {
		return ViewUtil.getStructuralFeatureValue((View) getModel(), feature);
	}
d658 2
a659 9
	/**
	 * try to resolve the semantic element and Return the resolven element; if
	 * the element is unresolvable or null it will return null
	 * 
	 * @@return non proxy EObject or NULL
	 */
	public EObject resolveSemanticElement() {
		try {
			return (EObject) getEditingDomain().runExclusive(
a660 14
	
				public void run() {
					setResult(ViewUtil.resolveSemanticElement((View) getModel()));
				}
			});
		} catch (InterruptedException e) {
			Trace.catching(DiagramUIPlugin.getInstance(),
				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"resolveSemanticElement", e); //$NON-NLS-1$
			Log.error(DiagramUIPlugin.getInstance(),
				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
				"resolveSemanticElement", e); //$NON-NLS-1$
			return null;
		}
d662 29
a690 1
	}
d692 12
a703 13
	/**
	 * Walks up the editpart hierarchy to find and return the
	 * <code>TopGraphicEditPart</code> instance.
	 */
	public TopGraphicEditPart getTopGraphicEditPart() {
		EditPart editPart = this;
		while (editPart instanceof IGraphicalEditPart) {
			if (editPart instanceof TopGraphicEditPart)
				return (TopGraphicEditPart) editPart;
			editPart = editPart.getParent();
		}
		return null;
	}
d705 8
a712 12
	/**
	 * Return the editpart's associated Notation View.
	 * 
	 * @@return <code>View</code>, the associated view or null if there is no
	 *         associated Notation View
	 */
	public View getNotationView() {
		Object model = getModel();
		if (model instanceof View)
			return (View) model;
		return null;
	}
d714 21
a734 8
	/**
	 * Handles the passed property changed event only if the editpart's view is
	 * not deleted
	 */
	public final void propertyChange(PropertyChangeEvent event) {
		if (isActive())
			handlePropertyChangeEvent(event);
	}
d736 18
a753 20
	/**
	 * Handles the property changed event.  Clients should override to
	 * respond to the specific notification events they are interested.
	 * 
	 * Note: This method may get called on a non-UI thread.  Clients should
	 * either ensure that their code is thread safe and/or doesn't make
	 * unsupported calls (i.e. Display.getCurrent() ) assuming they are on
	 * the main thread.  Alternatively if this is not possible, then the
	 * client can wrap their handler within the Display.synchExec runnable
	 * to ensure synchronization and subsequent execution on the main thread.
	 * 
	 * @@param event
	 *            the <code>Notification</code> object that is the property changed event
	 */
	protected void handlePropertyChangeEvent(PropertyChangeEvent event) {
		if (event.getPropertyName().equals(
			Connection.PROPERTY_CONNECTION_ROUTER)) {
			installRouter();
		}
	}
d755 11
a765 18
	/**
	 * Method reactivateSemanticModel. This method reactivates the edit part's
	 * emantic model by: 1- removing semantic listeners 2- adding semantic
	 * listeners if the semantic reference is resolvable 3- Refreshing it
	 * 
	 * This method is called in response to IView's Properties.ID_SEMANTICREF
	 * property change event However, it will only work under the following
	 * assumptions: 1- The old and new semantic models are compatible in their
	 * kind 2- The deltas between old and new semantic models do not affect
	 * notation 3- Connections are not refereshed since they are maintained by
	 * the diagram
	 */
	public void reactivateSemanticModel() {
		removeSemanticListeners();
		if (resolveSemanticElement() != null)
			addSemanticListeners();
		refresh();
	}
d767 1
a767 11
	/** Finds an editpart given a starting editpart and an EObject */
	public EditPart findEditPart(EditPart epBegin, EObject theElement) {
		if (theElement == null) {
			return null;
		}
		EditPart epStart = null;
		if (epBegin == null) {
			epStart = this;
		} else {
			epStart = epBegin;
		}
d769 2
a770 1
		final View view = (View) ((IAdaptable) epStart).getAdapter(View.class);
d772 4
a775 2
		if (view != null) {
			EObject el = ViewUtil.resolveSemanticElement(view);
d777 11
a787 4
			if ((el != null) && el.equals(theElement)) {
				return epStart;
			}
		}
d789 10
a798 11
		ListIterator childLI = epStart.getChildren().listIterator();
		while (childLI.hasNext()) {
			EditPart epChild = (EditPart) childLI.next();

			EditPart elementEP = findEditPart(epChild, theElement);
			if (elementEP != null) {
				return elementEP;
			}
		}
		return null;
	}
d800 6
a805 10
	/**
	 * Refresh the editpart's figure foreground colour.
	 */
	protected void refreshForegroundColor() {
		LineStyle style = (LineStyle) getPrimaryView().getStyle(
			NotationPackage.eINSTANCE.getLineStyle());
		if (style != null)
			setForegroundColor(DiagramColorRegistry
				.getInstance().getColor(new Integer(style.getLineColor())));
	}
d807 9
a815 6
	/**
	 * Refresh the editpart's figure visibility.
	 */
	protected void refreshVisibility() {
		setVisibility(((View) getModel()).isVisible());
	}
d817 4
a820 14
	/**
	 * Removes a listener previously added with the given id
	 * 
	 * @@param filterId
	 *            the filiter ID
	 */
	protected void removeListenerFilter(String filterId) {
		if (listenerFilters == null)
			return;

		Object[] objects = (Object[]) listenerFilters.get(filterId);
		if (objects == null) {
			return;
		}
d822 10
a831 10
		if (objects.length > 2) {
			DiagramEventBroker.getInstance(getEditingDomain()).removeNotificationListener(
				(EObject) objects[0], (EStructuralFeature) objects[1],
				(NotificationListener) objects[2]);
		} else {
			getDiagramEventBroker().removeNotificationListener(
				(EObject) objects[0], (NotificationListener) objects[1]);
		}
		listenerFilters.remove(filterId);
	}
d833 9
a841 9
	/**
	 * sets the forefround color of the editpart's figure
	 * 
	 * @@param color
	 *            the color
	 */
	protected void setForegroundColor(Color color) {
		getFigure().setForegroundColor(color);
	}
d843 13
a855 13
	/**
	 * Sets the passed feature if possible on this editpart's view to the passed
	 * value.
	 * 
	 * @@param feature
	 *            the feature to use
	 * @@param value
	 *            the value of the property being set
	 */
	public void setStructuralFeatureValue(EStructuralFeature feature,
			Object value) {
		ViewUtil.setStructuralFeatureValue((View) getModel(), feature, value);
	}
d857 12
a868 12
	/**
	 * sets the edit part's visibility
	 * 
	 * @@param vis
	 *            the new visibilty value
	 */
	protected void setVisibility(boolean vis) {
		if (!vis && getSelected() != SELECTED_NONE)
			getViewer().deselect(this);
		getFigure().setVisible(vis);
		getFigure().revalidate();
	}
d870 10
a879 10
	/**
	 * This method adds all listeners to the notational world (views, figures,
	 * editpart...etc) Override this method to add more notational listeners
	 * down the hierarchy
	 */
	protected void addNotationalListeners() {
		addListenerFilter("View", this, (View) getModel());//$NON-NLS-1$
		getFigure().addPropertyChangeListener(
			Connection.PROPERTY_CONNECTION_ROUTER, this);
	}
d881 10
a890 9
	/**
	 * This method adds all listeners to the semantic element behind this EditPart 
	 * Override this method to add more semantic listeners down the hierarchy
	 * This method is called only if the semantic element is resolvable
	 */
	protected void addSemanticListeners() {
		addListenerFilter("SemanticModel",//$NON-NLS-1$
			this, resolveSemanticElement());
	}
d892 10
a901 10
	/**
	 * This method removes all listeners to the notational world (views,
	 * figures, editpart...etc) Override this method to remove notational
	 * listeners down the hierarchy
	 */
	protected void removeNotationalListeners() {
		getFigure().removePropertyChangeListener(
			Connection.PROPERTY_CONNECTION_ROUTER, this);
		removeListenerFilter("View");//$NON-NLS-1$
	}
d903 8
a910 8
	/**
	 * This method removes all listeners to the semantic element behind this EditPart
	 * Override this method to remove semantic listeners
	 * down the hierarchy
	 */
	protected void removeSemanticListeners() {
		removeListenerFilter("SemanticModel");//$NON-NLS-1$
	}
d912 7
a918 7
	/**
	 * @@see org.eclipse.gef.EditPart#addNotify()
	 */
	public void addNotify() {
		super.addNotify();
		installRouter();
	}
d920 7
a926 7
	/**
	 * a static array of appearance property ids applicable to the connections
	 */
	protected static final String[] appearanceProperties = new String[] {
		Properties.ID_FONTNAME, Properties.ID_FONTSIZE, Properties.ID_FONTBOLD,
		Properties.ID_FONTITALIC, Properties.ID_FONTCOLOR,
		Properties.ID_LINECOLOR};
d928 9
a936 10
	/**
	 * construcotr
	 * 
	 * @@param view ,
	 *            the view the edit part will own
	 */
	public ConnectionEditPart(View view) {
		setModel(view);
		this.editableEditPart = new DefaultEditableEditPart(this);
	}
d938 6
a943 6
	/**
	 * Method createConnectionFigure.
	 * 
	 * @@return a <code>Connection</code> figure
	 */
	abstract protected Connection createConnectionFigure();
d945 3
a947 3
	final protected IFigure createFigure() {
		return createConnectionFigure();
	}
d949 8
a956 8
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.EditPart#refresh()
	 */
	public void refresh() {
		if (getSource() != null && getTarget() != null) {
			try {
d959 21
a979 21
						public void run() {
							ConnectionEditPart.super.refresh();
							EditPolicyIterator i = getEditPolicyIterator();
							while (i.hasNext()) {
								EditPolicy policy = i.next();
								if (policy instanceof GraphicalEditPolicyEx) {
									((GraphicalEditPolicyEx) policy).refresh();
								}
							}
						}
					});
			} catch (InterruptedException e) {
				Trace.catching(DiagramUIPlugin.getInstance(),
					DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
					"refresh", e); //$NON-NLS-1$
				Log.error(DiagramUIPlugin.getInstance(),
					DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
					"refresh", e); //$NON-NLS-1$
			}
		}
	}
d981 8
a988 8
	/**
	 * utility method to get the <code>Edge</code> view
	 * 
	 * @@return the <code>Edge</code>
	 */
	protected Edge getEdge() {
		return (Edge) getModel();
	}
d990 6
a995 6
	/*
	 * @@see AbstractEditPart#getDragTracker(Request)
	 */
	public DragTracker getDragTracker(Request req) {
		return new SelectConnectionEditPartTracker(this);
	}
d997 8
a1004 8
	/**
	 * give access to the source of the edit part's Edge
	 * 
	 * @@return the source
	 */
	protected Object getModelSource() {
		return getEdge().getSource();
	}
d1006 8
a1013 8
	/**
	 * give access to the target of the edit part's Edge
	 * 
	 * @@return the target
	 */
	protected Object getModelTarget() {
		return getEdge().getTarget();
	}
d1015 15
a1029 15
	/**
	 * installes a router on the edit part, depending on the
	 * <code>RoutingStyle</code>
	 */
	protected void installRouter() {
		ConnectionLayer cLayer = (ConnectionLayer) getLayer(LayerConstants.CONNECTION_LAYER);
		RoutingStyle style = (RoutingStyle) ((View) getModel())
			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());

		if (style != null && cLayer instanceof ConnectionLayerEx) {

            ConnectionLayerEx cLayerEx = (ConnectionLayerEx)cLayer;
			Routing routing = style.getRouting();
			if (Routing.MANUAL_LITERAL == routing) {
				getConnectionFigure().setConnectionRouter(
d1031 2
a1032 2
			} else if (Routing.RECTILINEAR_LITERAL == routing) {
				getConnectionFigure().setConnectionRouter(
d1034 2
a1035 2
			} else if (Routing.TREE_LITERAL == routing) {
				getConnectionFigure().setConnectionRouter(
d1037 39
a1075 1
			}
d1077 1
a1077 1
		}
d1079 11
a1089 2
		refreshRouterChange();
	}
d1091 7
a1097 20
	/**
	 * refresh the pendpoints owned by the EditPart's <code>Edge</code>
	 */
	protected void refreshBendpoints() {
		RelativeBendpoints bendpoints = (RelativeBendpoints) getEdge()
			.getBendpoints();
		List modelConstraint = bendpoints.getPoints();
		List figureConstraint = new ArrayList();
		for (int i = 0; i < modelConstraint.size(); i++) {
			org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint wbp = (org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint) modelConstraint
				.get(i);
			RelativeBendpoint rbp = new RelativeBendpoint(getConnectionFigure());
			rbp.setRelativeDimensions(new Dimension(wbp.getSourceX(), wbp
				.getSourceY()), new Dimension(wbp.getTargetX(), wbp
				.getTargetY()));
			rbp.setWeight((i + 1) / ((float) modelConstraint.size() + 1));
			figureConstraint.add(rbp);
		}
		getConnectionFigure().setRoutingConstraint(figureConstraint);
	}
d1099 7
a1105 24
	private void installBendpointEditPolicy() {
		if (getConnectionFigure().getConnectionRouter() instanceof ForestRouter) {
			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
				new TreeConnectionBendpointEditPolicy());
		} else if (getConnectionFigure().getConnectionRouter() instanceof OrthogonalRouter) {
			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
				new ConnectionLineSegEditPolicy());
		} else {
			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
				new ConnectionBendpointEditPolicy());
		}
		
		EditPartUtil.synchronizeRunnableToMainThread(this, new Runnable() {
			public void run() {
				if (getConnectionFigure().getConnectionRouter() instanceof ForestRouter) {
					getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
				} else if (getConnectionFigure().getConnectionRouter() instanceof OrthogonalRouter) {
					getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
				} else {
					getConnectionFigure().setCursor(Cursors.CURSOR_SEG_ADD);
				}
			};
		});
	}
d1107 17
a1123 7
	/**
	 * Method refreshRouterChange.
	 */
	protected void refreshRouterChange() {
		refreshBendpoints();
		installBendpointEditPolicy();
	}
d1125 4
a1128 4
	/**
	 * Method refreshSmoothness.
	 */
	protected void refreshSmoothness() {
a1131 18
        
		PolylineConnectionEx poly = (PolylineConnectionEx) connection;
		RoutingStyle style = (RoutingStyle) ((View) getModel())
			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
		if (style != null) {
			Smoothness smoothness = style.getSmoothness();

			if (Smoothness.LESS_LITERAL == smoothness) {
				poly.setSmoothness(PolylineConnectionEx.SMOOTH_LESS);
			} else if (Smoothness.NORMAL_LITERAL == smoothness) {
				poly.setSmoothness(PolylineConnectionEx.SMOOTH_NORMAL);
			} else if (Smoothness.MORE_LITERAL == smoothness) {
				poly.setSmoothness(PolylineConnectionEx.SMOOTH_MORE);
			} else if (Smoothness.NONE_LITERAL == smoothness) {
				poly.setSmoothness(PolylineConnectionEx.SMOOTH_NONE);
			}
		}
	}
d1133 34
a1166 4
	/**
	 * Method refreshJumplinks.
	 */
	protected void refreshJumplinks() {
a1169 13
        
		PolylineConnectionEx poly = (PolylineConnectionEx) connection;
		RoutingStyle style = (RoutingStyle) ((View) getModel())
			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());

		JumpLinkStatus status = JumpLinkStatus.NONE_LITERAL;
		JumpLinkType type = JumpLinkType.SEMICIRCLE_LITERAL;
		boolean reverse = false;
		if (style != null) {
			status = style.getJumpLinkStatus();
			type = style.getJumpLinkType();
			reverse = style.isJumpLinksReverse();
		}
d1171 18
a1188 8
		int jumpType = 0;
		if (JumpLinkStatus.BELOW_LITERAL == status) {
			jumpType = PolylineConnectionEx.JUMPLINK_FLAG_BELOW;
		} else if (JumpLinkStatus.ABOVE_LITERAL == status) {
			jumpType = PolylineConnectionEx.JUMPLINK_FLAG_ABOVE;
		} else if (JumpLinkStatus.ALL_LITERAL == status) {
			jumpType = PolylineConnectionEx.JUMPLINK_FLAG_ALL;
		}
d1190 15
a1204 3
		boolean bCurved = type.equals(JumpLinkType.SEMICIRCLE_LITERAL);
		boolean bAngleIn = !type.equals(JumpLinkType.SQUARE_LITERAL);
		boolean bOnBottom = reverse;
d1206 13
a1218 3
		poly.setJumpLinks(jumpType != 0);
		poly.setJumpLinksStyles(jumpType, bCurved, bAngleIn, bOnBottom);
	}
d1220 12
a1231 6
	/**
	 * Method refreshRoutingStyles.
	 */
	protected void refreshRoutingStyles() {
        Connection connection = getConnectionFigure();
        if (!(connection instanceof PolylineConnectionEx))
d1233 1
a1233 2
        
		PolylineConnectionEx poly = (PolylineConnectionEx) connection;
d1235 19
a1253 3
		RoutingStyle style = (RoutingStyle) ((View) getModel())
			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
		if (style != null) {
d1255 11
a1265 2
			boolean closestDistance = style.isClosestDistance();
			boolean avoidObstruction = style.isAvoidObstructions();
d1267 10
a1276 3
			poly.setRoutingStyles(closestDistance, avoidObstruction);
		}
	}
d1278 14
a1291 15
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#refreshVisuals()
	 */
	protected void refreshVisuals() {
		super.refreshVisuals();
		refreshVisibility();
		refreshForegroundColor();
		refreshRoutingStyles();
		refreshSmoothness();
		refreshJumplinks();
		refreshBendpoints();
		refreshFont();
	}
d1293 18
a1310 13
	/**
	 * Refresh the editpart's figure font.
	 */
	protected void refreshFont() {
		FontStyle style = (FontStyle) getPrimaryView().getStyle(
			NotationPackage.eINSTANCE.getFontStyle());
		if (style != null) {
			setFont(new FontData(style.getFontName(), style.getFontHeight(),
				(style.isBold() ? SWT.BOLD
					: SWT.NORMAL) | (style.isItalic() ? SWT.ITALIC
					: SWT.NORMAL)));
		}
	}
d1312 8
a1319 15
	/**
	 * Sets the font to the label. This method could be overriden to change the
	 * font data of the font overrides typically look like this: super.setFont(
	 * new FontData( fontData.getName(), fontData.getHeight(),
	 * fontData.getStyle() <| &> SWT.????));
	 * 
	 * @@param fontData
	 *            the font data
	 */
	protected void setFont(FontData fontData) {
		getFigure().setFont(
			DiagramFontRegistry.getInstance().getFont(Display.getDefault(),
				fontData));
		getFigure().repaint();
	}
d1321 1
a1321 11
	/**
	 * Returns an array of the appearance property ids applicable to the
	 * receiver. Fro this type it is Properties.ID_FONT,
	 * Properties.ID_FONTCOLOR, Properties.ID_LINECOLOR
	 * 
	 * @@return - an array of the appearane property ids applicable to the
	 *         receiver
	 */
	protected String[] getAppearancePropertyIDs() {
		return appearanceProperties;
	}
d1323 7
a1329 10
	/**
	 * Perform a request by executing a command from the target editpart of the
	 * request For the Direct_Edit request, we need to show up an editor first
	 * 
	 * @@see org.eclipse.gef.EditPart#performRequest(org.eclipse.gef.Request)
	 */
	public void performRequest(Request request) {
		if (!isEditModeEnabled()) {
			return;
		}
d1331 9
a1339 14
		if (RequestConstants.REQ_DIRECT_EDIT == request.getType()) {
			performDirectEditRequest(request);
		} else {
			EditPart targetEditPart = getTargetEditPart(request);
			if (targetEditPart != null) {
				Command command = targetEditPart.getCommand(request);
				if (command != null) {
					getDiagramEditDomain().getDiagramCommandStack().execute(
						command);
					return;
				}
			}
		}
	}
d1341 1
a1341 18
	/**
	 * Performs a direct edit request (usually by showing some type of editor)
	 * 
	 * @@param request
	 *            the direct edit request
	 */
	protected void performDirectEditRequest(Request request) {
		try {
			EditPart primaryChildEditPart = (EditPart) getEditingDomain()
				.runExclusive(new RunnableWithResult.Impl() {

						public void run() {
							setResult(getPrimaryChildEditPart());
						}
					});
			if (primaryChildEditPart != null) {
				primaryChildEditPart.performRequest(request);
			}
d1343 3
a1345 8
		} catch (InterruptedException e) {
			Trace.catching(DiagramUIPlugin.getInstance(),
				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"performDirectEditRequest", e); //$NON-NLS-1$
			Log.error(DiagramUIPlugin.getInstance(),
				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
				"performDirectEditRequest", e); //$NON-NLS-1$
		}
d1347 3
a1349 1
	}
d1351 3
a1353 7
	/**
	 * @@see org.eclipse.gef.EditPart#understandsRequest(org.eclipse.gef.Request)
	 */
	public boolean understandsRequest(Request req) {
		return RequestConstants.REQ_DIRECT_EDIT == req.getType()
			|| super.understandsRequest(req);
	}
d1355 10
a1364 9
	/** Adds a [ref, editpart] mapping to the EditPartForElement map. */
	protected void registerModel() {
		super.registerModel();

		// Save the elements Guid to use during unregister
		EObject ref = ((View) getModel()).getElement();
		if (ref == null) {
			return;
		}
d1366 9
a1374 1
		elementGuid = EMFCoreUtil.getProxyID(ref);
d1376 10
a1385 3
		((IDiagramGraphicalViewer) getViewer()).registerEditPartForElement(
			elementGuid, this);
	}
d1387 9
a1395 3
	/** Remove this editpart from the EditPartForElement map. */
	protected void unregisterModel() {
		super.unregisterModel();
d1397 7
a1403 3
		((IDiagramGraphicalViewer) getViewer()).unregisterEditPartForElement(
			elementGuid, this);
	}
d1405 8
a1412 10
	/**
	 * Handles the case where the semantic reference has changed.
	 */
	protected final void handleMajorSemanticChange() {
		if (getSource() instanceof GraphicalEditPart
			&& getTarget() instanceof GraphicalEditPart) {
			((GraphicalEditPart) getSource()).refreshSourceConnection(this);
			((GraphicalEditPart) getTarget()).refreshTargetConnection(this);
		}
	}
d1414 8
a1421 9
	/**
	 * Refreshes a child editpart by removing it and refreshing children
	 * 
	 * @@param child
	 */
	final void refreshChild(GraphicalEditPart child) {
		removeChild(child);
		refreshChildren();
	}
d1423 2
a1424 10
	/**
	 * check if there is a canonical edit policy installed on the edit part or
	 * not
	 * 
	 * @@return <tt>true</tt> if a canonical editpolicy has been installed on
	 *         this editpart; otherwise <tt>false</tt>
	 */
	public final boolean isCanonical() {
		return getEditPolicy(EditPolicyRoles.CANONICAL_ROLE) != null;
	}
d1426 16
a1441 9
	/**
	 * checks if the edit part's figure is visible or not
	 * 
	 * @@return <tt>true</tt> if the editpart's figure is visible;
	 *         <tt>false</tt> otherwise.
	 */
	public boolean isSelectable() {
		return getFigure().isVisible();
	}
d1443 9
a1451 6
	/*
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#disableEditMode()
	 */
	public void disableEditMode() {
		this.editableEditPart.disableEditMode();
	}
d1453 11
a1463 6
	/*
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#enableEditMode()
	 */
	public void enableEditMode() {
		this.editableEditPart.enableEditMode();
	}
d1465 7
a1471 11
	/*
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#isEditModeEnabled()
	 */
	public boolean isEditModeEnabled() {
		// protect against deadlock - don't allow any action while write transaction
		// is active on another thread
		if (EditPartUtil.isWriteTransactionInProgress(this, true, true))
			return false;
		
		return this.editableEditPart.isEditModeEnabled();
	}
d1473 2
a1474 7
	/*
	 * @@see org.eclipse.gef.EditPart#showSourceFeedback(org.eclipse.gef.Request)
	 */
	public void showSourceFeedback(Request request) {
		if (!isEditModeEnabled()) {
			return;
		}
d1476 7
a1482 2
		super.showSourceFeedback(request);
	}
d1484 2
a1485 7
	/*
	 * @@see org.eclipse.gef.EditPart#showTargetFeedback(org.eclipse.gef.Request)
	 */
	public void showTargetFeedback(Request request) {
		if (!isEditModeEnabled()) {
			return;
		}
d1487 7
a1493 2
		super.showTargetFeedback(request);
	}
d1495 2
a1496 7
	/*
	 * @@see org.eclipse.gef.EditPart#eraseSourceFeedback(org.eclipse.gef.Request)
	 */
	public void eraseSourceFeedback(Request request) {
		if (!isEditModeEnabled()) {
			return;
		}
d1498 7
a1504 2
		super.eraseSourceFeedback(request);
	}
d1506 2
a1507 7
	/*
	 * @@see org.eclipse.gef.EditPart#eraseTargetFeedback(org.eclipse.gef.Request)
	 */
	public void eraseTargetFeedback(Request request) {
		if (!isEditModeEnabled()) {
			return;
		}
d1509 10
a1518 2
		super.eraseTargetFeedback(request);
	}
d1520 12
a1531 10
	/**
	 * this method will return the primary child EditPart inside this edit part
	 * 
	 * @@return the primary child view inside this edit part
	 */
	public EditPart getPrimaryChildEditPart() {
		if (getChildren().size() > 0)
			return (EditPart) getChildren().get(0);
		return null;
	}
d1533 10
a1542 11
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramPreferencesHint()
	 */
	public PreferencesHint getDiagramPreferencesHint() {
		if (getRoot() instanceof IDiagramPreferenceSupport) {
			return ((IDiagramPreferenceSupport) getRoot()).getPreferencesHint();
		}
		return PreferencesHint.USE_DEFAULTS;
	}
d1544 51
a1594 10
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener#notifyChanged(org.eclipse.emf.common.notify.Notification)
	 */
	public void notifyChanged(Notification notification) {
		if (isActive()) {
			handleNotificationEvent(notification);
		}
	}
d1596 10
a1605 49
	/**
	 * Handles the property changed event
	 * 
	 * @@param event
	 *            the property changed event
	 */
	protected void handleNotificationEvent(Notification event) {
		Object feature = event.getFeature();
		if (NotationPackage.eINSTANCE.getView_PersistedChildren().equals(
			feature)
			|| NotationPackage.eINSTANCE.getView_TransientChildren().equals(
				feature)) {
			refreshChildren();
		} else if (NotationPackage.eINSTANCE.getView_Visible().equals(feature)) {
            Object notifier = event.getNotifier();
            if (notifier== getModel())
			setVisibility(((Boolean) event.getNewValue()).booleanValue());
			// Reactivating in response to semantic model reference change
			// However, we need to verify that the event belongs to this
			// editpart's view
		} else if (NotationPackage.eINSTANCE.getRoutingStyle_Routing().equals(
			feature)) {
			installRouter();
		} else if (NotationPackage.eINSTANCE.getRoutingStyle_Smoothness()
			.equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_AvoidObstructions()
				.equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_ClosestDistance()
				.equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkStatus()
				.equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkType().equals(
				feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinksReverse()
				.equals(feature)) {
			refreshVisuals();
		} else if (NotationPackage.eINSTANCE.getLineStyle_LineColor().equals(
			feature)) {
			Integer c = (Integer) event.getNewValue();
			setForegroundColor(DiagramColorRegistry
				.getInstance().getColor(c));
		} else if (NotationPackage.eINSTANCE.getRelativeBendpoints_Points()
			.equals(feature)) {
			refreshBendpoints();
		} else if (event.getFeature() == NotationPackage.eINSTANCE
			.getView_Element()
			&& ((EObject) event.getNotifier()) == getNotationView())
			handleMajorSemanticChange();
	}
d1607 2
a1608 10
	/**
	 * @@return <code>IMapMode</code> that allows for the coordinate mapping from device to
	 * logical units. 
	 */
	final protected IMapMode getMapMode() {
		RootEditPart root = getRoot();
		if (root instanceof DiagramRootEditPart) {
			DiagramRootEditPart dgrmRoot = (DiagramRootEditPart)root;
			return dgrmRoot.getMapMode();
		}
a1609 3
		return MapModeUtil.getMapMode();
	}
	
d1618 1
a1618 1
            
d1621 2
a1622 1
                editingDomain = TransactionUtil.getEditingDomain(getDiagramView());
d1626 8
a1633 8
    } 	
    
	/**
	 * Gets the diagram event broker from the editing domain.
	 * 
	 * @@return the diagram event broker
	 */
	private DiagramEventBroker getDiagramEventBroker() {
d1640 68
@


1.35.2.1
log
@Bugzilla#146690 gmf_R1_0_maintenance cmahoney 060711 Inconsistent default colours
@
text
@a84 1
import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
a86 1
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
a108 2
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.preference.PreferenceConverter;
a1522 23

    public Object getPreferredValue(EStructuralFeature feature) {
        Object preferenceStore = getDiagramPreferencesHint()
            .getPreferenceStore();
        if (preferenceStore instanceof IPreferenceStore) {            
            if (feature == NotationPackage.eINSTANCE.getLineStyle_LineColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_LINE_COLOR));
                
            } else if (feature == NotationPackage.eINSTANCE
                .getFontStyle_FontColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_FONT_COLOR));
                
            }
        }
        return getStructuralFeatureValue(feature);
    }       
    
@


1.35.2.2
log
@Bugzilla#146289 gmf_R1_0_maintenance cmahoney 060714 DiagramFontRegistry appears to be a permanent resource leak
@
text
@d78 1
a82 1
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
a112 4
import org.eclipse.jface.resource.DeviceResourceException;
import org.eclipse.jface.resource.FontDescriptor;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.resource.ResourceManager;
a117 1
import org.eclipse.swt.graphics.Font;
d119 1
d146 1
a146 7
    
    /**
     * Cache the font data when a font is created so that it can be
     * disposed later.
     */
    private FontData cachedFontData;
    
a327 5
        if (cachedFontData != null) {
            getResourceManager().destroyFont(
                FontDescriptor.createFrom(cachedFontData));
            cachedFontData = null;
        }
d1182 5
a1186 24
        if (cachedFontData != null && cachedFontData.equals(fontData)) {
            // the font was previously set and has not changed; do nothing.
            return;
        }

        try {
            Font newFont = getResourceManager().createFont(
                FontDescriptor.createFrom(fontData));
            getFigure().setFont(newFont);
            getFigure().repaint();

            if (cachedFontData != null) {
                getResourceManager().destroyFont(
                    FontDescriptor.createFrom(cachedFontData));
            }
            cachedFontData = fontData;
        } catch (DeviceResourceException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "setFont", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "setFont", e); //$NON-NLS-1$
        }
    }
d1189 7
a1195 7
     * Returns an array of the appearance property ids applicable to the
     * receiver. Fro this type it is Properties.ID_FONT,
     * Properties.ID_FONTCOLOR, Properties.ID_LINECOLOR
     * 
     * @@return - an array of the appearane property ids applicable to the
     *         receiver
     */
d1548 1
a1548 1
    }    
a1549 13
    /**
     * Gets the resource manager to remember the resources allocated for this
     * graphical viewer. All resources will be disposed when the graphical
     * viewer is closed if they have not already been disposed.
     * 
     * @@return the resource manager
     */
    protected ResourceManager getResourceManager() {
        if (getViewer() instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) getViewer()).getResourceManager();
        }
        return JFaceResources.getResources();
    }
@


1.35.2.3
log
@ [148860] gmf_R1_0_maintenance mmostafa  060718 Connection Edit Part does not handle the Unresolve Event any more
@
text
@d1514 1
a1514 1
			&& ((EObject) event.getNotifier()) == getNotationView()){
a1515 3
        } else if (event.getEventType() == EventType.UNRESOLVE
                && event.getNotifier() == ((View) getModel()).getElement())
                handleMajorSemanticChange();
@


1.35.2.4
log
@[152392] gmf_R1_0_maintenance yLulu 060801 Performance of DiagramEditPart and ConnectionEditPart could be enhanced
@
text
@a41 1
import org.eclipse.gef.EditPartViewer;
d72 1
d133 13
a145 18
    extends AbstractConnectionEditPart
    implements IGraphicalEditPart, PropertyChangeListener, IContainedEditPart,
    IPrimaryEditPart, NotificationListener {

    /** A map of listener filters ids to filter data */
    private Map listenerFilters;

    /** Used for registering and unregistering the edit part */
    private String elementGuid;

    /**
     * Flag to indicate if the edit part is in edit mode
     */
    private boolean isEditable = true;

    /** Used for accessibility. */
    protected AccessibleEditPart accessibleEP;

d150 1
a150 2

     
d176 2
a177 6
    /**
     * Register the adapters for the standard properties.
     */
    static {
        registerAdapters();
    }
d179 6
a184 7
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#activate()
     */
    public void activate() {
        addNotationalListeners();
d186 7
a192 11
        EObject semanticProxy = ((View) getModel()).getElement();
        EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(),
            semanticProxy);

        if (semanticElement != null)
            addSemanticListeners();
        else if (semanticProxy != null) {
            addListenerFilter("SemanticProxy", this, semanticProxy); //$NON-NLS-1$
        }
        super.activate();
    }
d194 2
a195 12
    /**
     * Adds a listener filter by adding the given listener to a passed notifier
     * 
     * @@param filterId
     *            A unique filter id (within the same editpart instance)
     * @@param listener
     *            A listener instance
     * @@param notifier
     *            An element notifer to add the listener to
     */
    protected void addListenerFilter(String filterId,
            NotificationListener listener, EObject element) {
d197 7
a203 2
        if (element == null)
            return;
d205 12
a216 2
        Assert.isNotNull(filterId);
        Assert.isNotNull(listener);
d218 2
a219 2
        if (listenerFilters == null)
            listenerFilters = new HashMap();
d221 2
a222 3
        getDiagramEventBroker().addNotificationListener(element, listener);
        listenerFilters.put(filterId, new Object[] {element, listener});
    }
d224 2
a225 13
    /**
     * Adds a listener filter by adding the given listener to a passed notifier
     * 
     * @@param filterId
     *            A unique filter id (within the same editpart instance)
     * @@param listener
     *            A listener instance
     * @@param notifier
     *            An element notifer to add the listener to
     */
    protected void addListenerFilter(String filterId,
            NotificationListener listener, EObject element,
            EStructuralFeature feature) {
d227 4
a230 2
        if (element == null)
            return;
d232 28
a259 2
        Assert.isNotNull(filterId);
        Assert.isNotNull(listener);
d261 9
a269 2
        if (listenerFilters == null)
            listenerFilters = new HashMap();
d271 9
a279 5
        getDiagramEventBroker().addNotificationListener(element, feature,
            listener);
        listenerFilters
            .put(filterId, new Object[] {element, feature, listener});
    }
d281 11
a291 9
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createChild(java.lang.Object)
     */
    final protected EditPart createChild(Object model) {
        return EditPartService.getInstance()
            .createGraphicEditPart((View) model);
    }
d293 19
a311 9
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractGraphicalEditPart#createConnection(java.lang.Object)
     */
    final protected org.eclipse.gef.ConnectionEditPart createConnection(
            Object connectionView) {
        return (org.eclipse.gef.ConnectionEditPart) createChild(connectionView);
    }
d313 3
a315 11
    /**
     * Overridden to support editpolicies installed programmatically and via the
     * <code>EditPolicyService</code>. Subclasses should override
     * <code>createDefaultEditPolicies()</code>.
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
     */
    final protected void createEditPolicies() {
        createDefaultEditPolicies();
        EditPolicyService.getInstance().createEditPolicies(this);
    }
d317 6
a322 30
    /**
     * Should be overridden to install editpolicies programmatically.
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
     */
    protected void createDefaultEditPolicies() {
        installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
            new SemanticEditPolicy());
        installEditPolicy(EditPolicyRoles.PROPERTY_HANDLER_ROLE,
            new PropertyHandlerEditPolicy());
        installEditPolicy(EditPolicy.CONNECTION_ENDPOINTS_ROLE,
            new org.eclipse.gef.editpolicies.ConnectionEndpointEditPolicy());
        installEditPolicy(EditPolicy.CONNECTION_ROLE,
            new ConnectionEditPolicy());
        installBendpointEditPolicy();
        installEditPolicy(EditPolicyRoles.DECORATION_ROLE,
            new DecorationEditPolicy());
        installEditPolicy(EditPolicyRoles.CONNECTION_LABELS_ROLE,
            new ConnectionLabelsEditPolicy());

        installEditPolicy(EditPolicyRoles.SNAP_FEEDBACK_ROLE,
            new SnapFeedbackPolicy());
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#deactivate()
     */
   public void deactivate() {
d345 62
a406 9
    /**
     * executes the passed command
     * 
     * @@param command
     *            the command to execute
     */
    protected void executeCommand(Command command) {
        getEditDomain().getCommandStack().execute(command);
    }
d408 2
a409 8
    /**
     * a function that registers this provider with the Eclipse AdapterManager
     * as an IView and an IActionFilter adapter factory for the
     * IGraphicalEditPart nodes
     * 
     */
    static private void registerAdapters() {
        Platform.getAdapterManager().registerAdapters(new IAdapterFactory() {
d411 1
a411 14
            /**
             * @@see org.eclipse.core.runtime.IAdapterFactory
             */
            public Object getAdapter(Object adaptableObject, Class adapterType) {

                IGraphicalEditPart gep = (IGraphicalEditPart) adaptableObject;

                if (adapterType == IActionFilter.class) {
                    return ActionFilterService.getInstance();
                } else if (adapterType == View.class) {
                    return gep.getModel();
                }
                return null;
            }
d413 2
a414 6
            /**
             * @@see org.eclipse.core.runtime.IAdapterFactory
             */
            public Class[] getAdapterList() {
                return new Class[] {IActionFilter.class, View.class};
            }
d416 2
a417 2
        }, IGraphicalEditPart.class);
    }
d419 43
a461 73
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#getAccessibleEditPart()
     */
    protected AccessibleEditPart getAccessibleEditPart() {
        if (accessibleEP == null) {
            accessibleEP = new AccessibleGraphicalEditPart() {

                private String getSemanticName() {
                    EObject semanticElement = resolveSemanticElement();

                    if (semanticElement != null) {
                        String name = semanticElement.getClass().getName();
                        int startIndex = name.lastIndexOf('.') + 1;
                        int endIndex = name.lastIndexOf("Impl"); //$NON-NLS-1$
                        return name.substring(startIndex, endIndex);
                    }

                    return DiagramUIMessages.Accessible_Connection_Label;
                }

                public void getName(AccessibleEvent e) {

                    EditPart sourceEP = getSource();
                    EditPart targetEP = getTarget();

                    // Get the Connection Name
                    String connectionName = getSemanticName();

                    // Get the Source Name
                    String sourceName = null;
                    if (sourceEP != null) {
                        AccessibleEditPart aEP = (AccessibleEditPart) sourceEP
                            .getAdapter(AccessibleEditPart.class);
                        AccessibleEvent event = new AccessibleEvent(this);
                        aEP.getName(event);
                        sourceName = event.result;
                    }

                    // Get the Target Name
                    String targetName = null;
                    if (targetEP != null) {
                        AccessibleEditPart aEP = (AccessibleEditPart) targetEP
                            .getAdapter(AccessibleEditPart.class);
                        AccessibleEvent event = new AccessibleEvent(this);
                        aEP.getName(event);
                        targetName = event.result;
                    }

                    if (sourceName != null && targetName != null) {
                        e.result = NLS
                            .bind(
                                DiagramUIMessages.Accessible_Connection_From_Source_To_Target,
                                new Object[] {connectionName, sourceName,
                                    targetName});
                    } else if (sourceName != null) {
                        e.result = NLS
                            .bind(
                                DiagramUIMessages.Accessible_Connection_From_Source,
                                new Object[] {connectionName, sourceName});
                    } else if (targetName != null) {
                        e.result = NLS.bind(
                            DiagramUIMessages.Accessible_Connection_To_Target,
                            new Object[] {connectionName, targetName});
                    } else {
                        e.result = connectionName;
                    }
                }
            };
        }
        return accessibleEP;
    }
d463 5
a467 5
    /**
     * Adds the ability to adapt to this editpart's view class.
     */
    public Object getAdapter(Class key) {
    	Object adapter = Platform.getAdapterManager().getAdapter(this, key);
d472 3
a474 1
        if (key == SnapToHelper.class) {
d476 21
a496 23
            List snapStrategies = new ArrayList();
            EditPartViewer viewer = getViewer();
            Boolean val = (Boolean) viewer
                .getProperty(RulerProvider.PROPERTY_RULER_VISIBILITY);
            if (val != null && val.booleanValue())
                snapStrategies.add(new SnapToGuides(this));

            val = (Boolean) viewer
                .getProperty(SnapToGeometry.PROPERTY_SNAP_ENABLED);
            if (val != null && val.booleanValue())
                snapStrategies.add(new SnapToGrid(this));

            if (snapStrategies.size() == 0)
                return null;

            if (snapStrategies.size() == 1)
                return snapStrategies.get(0);

            SnapToHelper ss[] = new SnapToHelper[snapStrategies.size()];
            for (int i = 0; i < snapStrategies.size(); i++)
                ss[i] = (SnapToHelper) snapStrategies.get(i);
            return new CompoundSnapToHelper(ss);
        }
d498 1
a498 1
        Object model = getModel();
d500 3
a502 3
        if (View.class.isAssignableFrom(key) && key.isInstance(model)) {
            return model;
        }
d504 7
a510 7
        if (model != null && model instanceof View) {
            // Adapt to semantic element
            EObject semanticObject = ViewUtil
                .resolveSemanticElement((View) model);
            if (key.isInstance(semanticObject)) {
                return semanticObject;
            }else if (key.isInstance(model)) {
d513 3
a515 3
        }
        return super.getAdapter(key);
    }
d517 16
a532 16
    /**
     * Method getChildBySemanticHint.
     * 
     * @@param semanticHint
     * @@return IGraphicalEditPart
     */
    public IGraphicalEditPart getChildBySemanticHint(String semanticHint) {
        if (getModel() != null) {
            View view = ViewUtil.getChildBySemanticHint((View) getModel(),
                semanticHint);
            if (view != null)
                return (IGraphicalEditPart) getViewer().getEditPartRegistry()
                    .get(view);
        }
        return null;
    }
d534 9
a542 9
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#getCommand(org.eclipse.gef.Request)
     */
    public Command getCommand(Request _request) {
        if (!isEditModeEnabled()) {
            return UnexecutableCommand.INSTANCE;
        }
d544 3
a546 3
        final Request request = _request;
        try {
            Command cmd = (Command) getEditingDomain().runExclusive(
d549 16
a564 17
                    public void run() {
                        setResult(ConnectionEditPart.super.getCommand(request));
                    }

                });
            return cmd;
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "getCommand", e); //$NON-NLS-1$
            Log
                .error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                    "getCommand", e); //$NON-NLS-1$
            return null;
        }
    }
d566 9
a574 9
    /**
     * Convenience method returning the editpart's Diagram, the Diagam that owns
     * the edit part
     * 
     * @@return the diagram
     */
    protected Diagram getDiagramView() {
        return (Diagram) getRoot().getContents().getModel();
    }
d576 12
a587 12
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getPrimaryView()
     */
    public View getPrimaryView() {
        for (EditPart parent = this; parent != null; parent = parent
            .getParent())
            if (parent instanceof IPrimaryEditPart)
                return (View) parent.getModel();
        return null;
    }
d589 9
a597 9
    /**
     * Convenience method returning the editpart's edit domain. Same as calling
     * <code>getRoot().getViewer().getEditDomain()</code>
     * 
     * @@return the edit domain
     */
    protected EditDomain getEditDomain() {
        return getRoot().getViewer().getEditDomain();
    }
d599 8
a606 8
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramEditDomain()
     */
    public IDiagramEditDomain getDiagramEditDomain() {
        return (IDiagramEditDomain) getEditDomain();
    }
d608 8
a615 8
    /**
     * Return this editpart's view (model) children.
     * 
     * @@return list of views.
     */
    protected List getModelChildren() {
        return ((View) getModel()).getChildren();
    }
d617 8
a624 8
    /**
     * Convenience method to retreive the value for the supplied value from the
     * editpart's associated view element. Same as calling
     * <code> ViewUtil.getStructuralFeatureValue(getNotationView(),feature)</code>.
     */
    public Object getStructuralFeatureValue(EStructuralFeature feature) {
        return ViewUtil.getStructuralFeatureValue((View) getModel(), feature);
    }
d626 24
a649 14
    /**
     * try to resolve the semantic element and Return the resolven element; if
     * the element is unresolvable or null it will return null
     * 
     * @@return non proxy EObject or NULL
     */
    public EObject resolveSemanticElement() {
        EObject eObj = ((View) getModel()).getElement();
        if (eObj != null && eObj.eIsProxy()) {
            return null;
        } else {
            return eObj;
        }
    }
d651 1
a651 13
    /**
     * Walks up the editpart hierarchy to find and return the
     * <code>TopGraphicEditPart</code> instance.
     */
    public TopGraphicEditPart getTopGraphicEditPart() {
        EditPart editPart = this;
        while (editPart instanceof IGraphicalEditPart) {
            if (editPart instanceof TopGraphicEditPart)
                return (TopGraphicEditPart) editPart;
            editPart = editPart.getParent();
        }
        return null;
    }
d653 13
a665 12
    /**
     * Return the editpart's associated Notation View.
     * 
     * @@return <code>View</code>, the associated view or null if there is no
     *         associated Notation View
     */
    public View getNotationView() {
        Object model = getModel();
        if (model instanceof View)
            return (View) model;
        return null;
    }
d667 12
a678 8
    /**
     * Handles the passed property changed event only if the editpart's view is
     * not deleted
     */
    public final void propertyChange(PropertyChangeEvent event) {
        if (isActive())
            handlePropertyChangeEvent(event);
    }
d680 8
a687 21
    /**
     * Handles the property changed event. Clients should override to respond to
     * the specific notification events they are interested.
     * 
     * Note: This method may get called on a non-UI thread. Clients should
     * either ensure that their code is thread safe and/or doesn't make
     * unsupported calls (i.e. Display.getCurrent() ) assuming they are on the
     * main thread. Alternatively if this is not possible, then the client can
     * wrap their handler within the Display.synchExec runnable to ensure
     * synchronization and subsequent execution on the main thread.
     * 
     * @@param event
     *            the <code>Notification</code> object that is the property
     *            changed event
     */
    protected void handlePropertyChangeEvent(PropertyChangeEvent event) {
        if (event.getPropertyName().equals(
            Connection.PROPERTY_CONNECTION_ROUTER)) {
            installRouter();
        }
    }
d689 20
a708 18
    /**
     * Method reactivateSemanticModel. This method reactivates the edit part's
     * emantic model by: 1- removing semantic listeners 2- adding semantic
     * listeners if the semantic reference is resolvable 3- Refreshing it
     * 
     * This method is called in response to IView's Properties.ID_SEMANTICREF
     * property change event However, it will only work under the following
     * assumptions: 1- The old and new semantic models are compatible in their
     * kind 2- The deltas between old and new semantic models do not affect
     * notation 3- Connections are not refereshed since they are maintained by
     * the diagram
     */
    public void reactivateSemanticModel() {
        removeSemanticListeners();
        if (resolveSemanticElement() != null)
            addSemanticListeners();
        refresh();
    }
d710 18
a727 11
    /** Finds an editpart given a starting editpart and an EObject */
    public EditPart findEditPart(EditPart epBegin, EObject theElement) {
        if (theElement == null) {
            return null;
        }
        EditPart epStart = null;
        if (epBegin == null) {
            epStart = this;
        } else {
            epStart = epBegin;
        }
d729 11
a739 1
        final View view = (View) ((IAdaptable) epStart).getAdapter(View.class);
d741 1
a741 2
        if (view != null) {
            EObject el = ViewUtil.resolveSemanticElement(view);
d743 2
a744 4
            if ((el != null) && el.equals(theElement)) {
                return epStart;
            }
        }
d746 4
a749 11
        ListIterator childLI = epStart.getChildren().listIterator();
        while (childLI.hasNext()) {
            EditPart epChild = (EditPart) childLI.next();

            EditPart elementEP = findEditPart(epChild, theElement);
            if (elementEP != null) {
                return elementEP;
            }
        }
        return null;
    }
d751 11
a761 10
    /**
     * Refresh the editpart's figure foreground colour.
     */
    protected void refreshForegroundColor() {
        LineStyle style = (LineStyle) getPrimaryView().getStyle(
            NotationPackage.Literals.LINE_STYLE);
        if (style != null)
            setForegroundColor(DiagramColorRegistry.getInstance().getColor(
                new Integer(style.getLineColor())));
    }
d763 10
a772 6
    /**
     * Refresh the editpart's figure visibility.
     */
    protected void refreshVisibility() {
        setVisibility(((View) getModel()).isVisible());
    }
d774 6
a779 9
    /**
     * Removes a listener previously added with the given id
     * 
     * @@param filterId
     *            the filiter ID
     */
    protected void removeListenerFilter(String filterId) {
        if (listenerFilters == null)
            return;
d781 14
a794 4
        Object[] objects = (Object[]) listenerFilters.get(filterId);
        if (objects == null) {
            return;
        }
d796 10
a805 10
        if (objects.length > 2) {
            getDiagramEventBroker().removeNotificationListener(
                (EObject) objects[0], (EStructuralFeature) objects[1],
                (NotificationListener) objects[2]);
        } else {
            getDiagramEventBroker().removeNotificationListener(
                (EObject) objects[0], (NotificationListener) objects[1]);
        }
        listenerFilters.remove(filterId);
    }
d807 9
a815 9
    /**
     * sets the forefround color of the editpart's figure
     * 
     * @@param color
     *            the color
     */
    protected void setForegroundColor(Color color) {
        getFigure().setForegroundColor(color);
    }
d817 13
a829 13
    /**
     * Sets the passed feature if possible on this editpart's view to the passed
     * value.
     * 
     * @@param feature
     *            the feature to use
     * @@param value
     *            the value of the property being set
     */
    public void setStructuralFeatureValue(EStructuralFeature feature,
            Object value) {
        ViewUtil.setStructuralFeatureValue((View) getModel(), feature, value);
    }
d831 12
a842 12
    /**
     * sets the edit part's visibility
     * 
     * @@param vis
     *            the new visibilty value
     */
    protected void setVisibility(boolean vis) {
        if (!vis && getSelected() != SELECTED_NONE)
            getViewer().deselect(this);
        getFigure().setVisible(vis);
        getFigure().revalidate();
    }
d844 10
a853 10
    /**
     * This method adds all listeners to the notational world (views, figures,
     * editpart...etc) Override this method to add more notational listeners
     * down the hierarchy
     */
    protected void addNotationalListeners() {
        addListenerFilter("View", this, (View) getModel());//$NON-NLS-1$
        getFigure().addPropertyChangeListener(
            Connection.PROPERTY_CONNECTION_ROUTER, this);
    }
d855 9
a863 10
    /**
     * This method adds all listeners to the semantic element behind this
     * EditPart Override this method to add more semantic listeners down the
     * hierarchy This method is called only if the semantic element is
     * resolvable
     */
    protected void addSemanticListeners() {
        addListenerFilter("SemanticModel",//$NON-NLS-1$
            this, resolveSemanticElement());
    }
d865 10
a874 10
    /**
     * This method removes all listeners to the notational world (views,
     * figures, editpart...etc) Override this method to remove notational
     * listeners down the hierarchy
     */
    protected void removeNotationalListeners() {
        getFigure().removePropertyChangeListener(
            Connection.PROPERTY_CONNECTION_ROUTER, this);
        removeListenerFilter("View");//$NON-NLS-1$
    }
d876 8
a883 8
    /**
     * This method removes all listeners to the semantic element behind this
     * EditPart Override this method to remove semantic listeners down the
     * hierarchy
     */
    protected void removeSemanticListeners() {
        removeListenerFilter("SemanticModel");//$NON-NLS-1$
    }
d885 7
a891 7
    /**
     * @@see org.eclipse.gef.EditPart#addNotify()
     */
    public void addNotify() {
        super.addNotify();
        installRouter();
    }
d893 7
a899 7
    /**
     * a static array of appearance property ids applicable to the connections
     */
    protected static final String[] appearanceProperties = new String[] {
        Properties.ID_FONTNAME, Properties.ID_FONTSIZE, Properties.ID_FONTBOLD,
        Properties.ID_FONTITALIC, Properties.ID_FONTCOLOR,
        Properties.ID_LINECOLOR};
d901 10
a910 9
    /**
     * construcotr
     * 
     * @@param view ,
     *            the view the edit part will own
     */
    public ConnectionEditPart(View view) {
        setModel(view);
    }
d912 6
a917 6
    /**
     * Method createConnectionFigure.
     * 
     * @@return a <code>Connection</code> figure
     */
    abstract protected Connection createConnectionFigure();
d919 3
a921 3
    final protected IFigure createFigure() {
        return createConnectionFigure();
    }
d923 8
a930 8
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#refresh()
     */
    public void refresh() {
        if (getSource() != null && getTarget() != null) {
            try {
d933 21
a953 21
                    public void run() {
                        ConnectionEditPart.super.refresh();
                        EditPolicyIterator i = getEditPolicyIterator();
                        while (i.hasNext()) {
                            EditPolicy policy = i.next();
                            if (policy instanceof GraphicalEditPolicyEx) {
                                ((GraphicalEditPolicyEx) policy).refresh();
                            }
                        }
                    }
                });
            } catch (InterruptedException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "refresh", e); //$NON-NLS-1$
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                    "refresh", e); //$NON-NLS-1$
            }
        }
    }
d955 8
a962 8
    /**
     * utility method to get the <code>Edge</code> view
     * 
     * @@return the <code>Edge</code>
     */
    protected Edge getEdge() {
        return (Edge) getModel();
    }
d964 6
a969 6
    /*
     * @@see AbstractEditPart#getDragTracker(Request)
     */
    public DragTracker getDragTracker(Request req) {
        return new SelectConnectionEditPartTracker(this);
    }
d971 8
a978 8
    /**
     * give access to the source of the edit part's Edge
     * 
     * @@return the source
     */
    protected Object getModelSource() {
        return getEdge().getSource();
    }
d980 8
a987 8
    /**
     * give access to the target of the edit part's Edge
     * 
     * @@return the target
     */
    protected Object getModelTarget() {
        return getEdge().getTarget();
    }
d989 15
a1003 15
    /**
     * installes a router on the edit part, depending on the
     * <code>RoutingStyle</code>
     */
    protected void installRouter() {
        ConnectionLayer cLayer = (ConnectionLayer) getLayer(LayerConstants.CONNECTION_LAYER);
        RoutingStyle style = (RoutingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);

        if (style != null && cLayer instanceof ConnectionLayerEx) {

            ConnectionLayerEx cLayerEx = (ConnectionLayerEx) cLayer;
            Routing routing = style.getRouting();
            if (Routing.MANUAL_LITERAL == routing) {
                getConnectionFigure().setConnectionRouter(
d1005 2
a1006 2
            } else if (Routing.RECTILINEAR_LITERAL == routing) {
                getConnectionFigure().setConnectionRouter(
d1008 2
a1009 2
            } else if (Routing.TREE_LITERAL == routing) {
                getConnectionFigure().setConnectionRouter(
d1011 1
a1011 1
            }
d1013 1
a1013 1
        }
d1015 2
a1016 2
        refreshRouterChange();
    }
d1018 20
a1037 32
    /**
     * refresh the pendpoints owned by the EditPart's <code>Edge</code>
     */
    protected void refreshBendpoints() {
        RelativeBendpoints bendpoints = (RelativeBendpoints) getEdge()
            .getBendpoints();
        List modelConstraint = bendpoints.getPoints();
        List figureConstraint = new ArrayList();
        for (int i = 0; i < modelConstraint.size(); i++) {
            org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint wbp = (org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint) modelConstraint
                .get(i);
            RelativeBendpoint rbp = new RelativeBendpoint(getConnectionFigure());
            rbp.setRelativeDimensions(new Dimension(wbp.getSourceX(), wbp
                .getSourceY()), new Dimension(wbp.getTargetX(), wbp
                .getTargetY()));
            rbp.setWeight((i + 1) / ((float) modelConstraint.size() + 1));
            figureConstraint.add(rbp);
        }
        getConnectionFigure().setRoutingConstraint(figureConstraint);
    }

    private void installBendpointEditPolicy() {
        if (getConnectionFigure().getConnectionRouter() instanceof ForestRouter) {
            installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
                new TreeConnectionBendpointEditPolicy());
        } else if (getConnectionFigure().getConnectionRouter() instanceof OrthogonalRouter) {
            installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
                new ConnectionLineSegEditPolicy());
        } else {
            installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
                new ConnectionBendpointEditPolicy());
        }
d1039 24
a1062 1
        EditPartUtil.synchronizeRunnableToMainThread(this, new Runnable() {
d1064 7
a1070 11
            public void run() {
                if (getConnectionFigure().getConnectionRouter() instanceof ForestRouter) {
                    getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
                } else if (getConnectionFigure().getConnectionRouter() instanceof OrthogonalRouter) {
                    getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
                } else {
                    getConnectionFigure().setCursor(Cursors.CURSOR_SEG_ADD);
                }
            };
        });
    }
d1072 4
a1075 12
    /**
     * Method refreshRouterChange.
     */
    protected void refreshRouterChange() {
        refreshBendpoints();
        installBendpointEditPolicy();
    }

    /**
     * Method refreshSmoothness.
     */
    protected void refreshSmoothness() {
d1079 18
d1098 4
a1101 22
        PolylineConnectionEx poly = (PolylineConnectionEx) connection;
        RoutingStyle style = (RoutingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);
        if (style != null) {
            Smoothness smoothness = style.getSmoothness();

            if (Smoothness.LESS_LITERAL == smoothness) {
                poly.setSmoothness(PolylineConnectionEx.SMOOTH_LESS);
            } else if (Smoothness.NORMAL_LITERAL == smoothness) {
                poly.setSmoothness(PolylineConnectionEx.SMOOTH_NORMAL);
            } else if (Smoothness.MORE_LITERAL == smoothness) {
                poly.setSmoothness(PolylineConnectionEx.SMOOTH_MORE);
            } else if (Smoothness.NONE_LITERAL == smoothness) {
                poly.setSmoothness(PolylineConnectionEx.SMOOTH_NONE);
            }
        }
    }

    /**
     * Method refreshJumplinks.
     */
    protected void refreshJumplinks() {
d1105 13
d1119 8
a1126 12
        PolylineConnectionEx poly = (PolylineConnectionEx) connection;
        RoutingStyle style = (RoutingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);

        JumpLinkStatus status = JumpLinkStatus.NONE_LITERAL;
        JumpLinkType type = JumpLinkType.SEMICIRCLE_LITERAL;
        boolean reverse = false;
        if (style != null) {
            status = style.getJumpLinkStatus();
            type = style.getJumpLinkType();
            reverse = style.isJumpLinksReverse();
        }
d1128 3
a1130 8
        int jumpType = 0;
        if (JumpLinkStatus.BELOW_LITERAL == status) {
            jumpType = PolylineConnectionEx.JUMPLINK_FLAG_BELOW;
        } else if (JumpLinkStatus.ABOVE_LITERAL == status) {
            jumpType = PolylineConnectionEx.JUMPLINK_FLAG_ABOVE;
        } else if (JumpLinkStatus.ALL_LITERAL == status) {
            jumpType = PolylineConnectionEx.JUMPLINK_FLAG_ALL;
        }
d1132 3
a1134 3
        boolean bCurved = type.equals(JumpLinkType.SEMICIRCLE_LITERAL);
        boolean bAngleIn = !type.equals(JumpLinkType.SQUARE_LITERAL);
        boolean bOnBottom = reverse;
d1136 4
a1139 8
        poly.setJumpLinks(jumpType != 0);
        poly.setJumpLinksStyles(jumpType, bCurved, bAngleIn, bOnBottom);
    }

    /**
     * Method refreshRoutingStyles.
     */
    protected void refreshRoutingStyles() {
d1143 2
d1146 3
a1148 1
        PolylineConnectionEx poly = (PolylineConnectionEx) connection;
d1150 2
a1151 3
        RoutingStyle style = (RoutingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);
        if (style != null) {
d1153 3
a1155 2
            boolean closestDistance = style.isClosestDistance();
            boolean avoidObstruction = style.isAvoidObstructions();
d1157 15
a1171 3
            poly.setRoutingStyles(closestDistance, avoidObstruction);
        }
    }
d1173 13
a1185 15
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#refreshVisuals()
     */
    protected void refreshVisuals() {
        super.refreshVisuals();
        refreshVisibility();
        refreshForegroundColor();
        refreshRoutingStyles();
        refreshSmoothness();
        refreshJumplinks();
        refreshBendpoints();
        refreshFont();
    }
d1187 1
a1187 15
    /**
     * Refresh the editpart's figure font.
     */
    protected void refreshFont() {
        FontStyle style = (FontStyle) getPrimaryView().getStyle(
            NotationPackage.Literals.FONT_STYLE);
        if (style != null) {
            setFont(new FontData(style.getFontName(), style.getFontHeight(),
                (style.isBold() ? SWT.BOLD
                    : SWT.NORMAL) | (style.isItalic() ? SWT.ITALIC
                    : SWT.NORMAL)));
        }
    }

    /**
d1222 1
a1222 1
    /**
d1230 3
a1232 3
    protected String[] getAppearancePropertyIDs() {
        return appearanceProperties;
    }
d1234 10
a1243 10
    /**
     * Perform a request by executing a command from the target editpart of the
     * request For the Direct_Edit request, we need to show up an editor first
     * 
     * @@see org.eclipse.gef.EditPart#performRequest(org.eclipse.gef.Request)
     */
    public void performRequest(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }
d1245 14
a1258 14
        if (RequestConstants.REQ_DIRECT_EDIT == request.getType()) {
            performDirectEditRequest(request);
        } else {
            EditPart targetEditPart = getTargetEditPart(request);
            if (targetEditPart != null) {
                Command command = targetEditPart.getCommand(request);
                if (command != null) {
                    getDiagramEditDomain().getDiagramCommandStack().execute(
                        command);
                    return;
                }
            }
        }
    }
d1260 18
a1277 10
    /**
     * Performs a direct edit request (usually by showing some type of editor)
     * 
     * @@param request
     *            the direct edit request
     */
    protected void performDirectEditRequest(Request request) {
        try {
            EditPart primaryChildEditPart = (EditPart) getEditingDomain()
                .runExclusive(new RunnableWithResult.Impl() {
d1279 8
a1286 7
                    public void run() {
                        setResult(getPrimaryChildEditPart());
                    }
                });
            if (primaryChildEditPart != null) {
                primaryChildEditPart.performRequest(request);
            }
d1288 1
a1288 8
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "performDirectEditRequest", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "performDirectEditRequest", e); //$NON-NLS-1$
        }
d1290 7
a1296 1
    }
d1298 9
a1306 7
    /**
     * @@see org.eclipse.gef.EditPart#understandsRequest(org.eclipse.gef.Request)
     */
    public boolean understandsRequest(Request req) {
        return RequestConstants.REQ_DIRECT_EDIT == req.getType()
            || super.understandsRequest(req);
    }
d1308 1
a1308 9
    /** Adds a [ref, editpart] mapping to the EditPartForElement map. */
    protected void registerModel() {
        super.registerModel();

        // Save the elements Guid to use during unregister
        EObject ref = ((View) getModel()).getElement();
        if (ref == null) {
            return;
        }
d1310 3
a1312 1
        elementGuid = EMFCoreUtil.getProxyID(ref);
d1314 3
a1316 3
        ((IDiagramGraphicalViewer) getViewer()).registerEditPartForElement(
            elementGuid, this);
    }
d1318 3
a1320 3
    /** Remove this editpart from the EditPartForElement map. */
    protected void unregisterModel() {
        super.unregisterModel();
d1322 10
a1331 3
        ((IDiagramGraphicalViewer) getViewer()).unregisterEditPartForElement(
            elementGuid, this);
    }
d1333 9
a1341 10
    /**
     * Handles the case where the semantic reference has changed.
     */
    protected final void handleMajorSemanticChange() {
        if (getSource() instanceof GraphicalEditPart
            && getTarget() instanceof GraphicalEditPart) {
            ((GraphicalEditPart) getSource()).refreshSourceConnection(this);
            ((GraphicalEditPart) getTarget()).refreshTargetConnection(this);
        }
    }
d1343 10
a1352 9
    /**
     * Refreshes a child editpart by removing it and refreshing children
     * 
     * @@param child
     */
    final void refreshChild(GraphicalEditPart child) {
        removeChild(child);
        refreshChildren();
    }
d1354 9
a1362 10
    /**
     * check if there is a canonical edit policy installed on the edit part or
     * not
     * 
     * @@return <tt>true</tt> if a canonical editpolicy has been installed on
     *         this editpart; otherwise <tt>false</tt>
     */
    public final boolean isCanonical() {
        return getEditPolicy(EditPolicyRoles.CANONICAL_ROLE) != null;
    }
d1364 6
a1369 9
    /**
     * checks if the edit part's figure is visible or not
     * 
     * @@return <tt>true</tt> if the editpart's figure is visible;
     *         <tt>false</tt> otherwise.
     */
    public boolean isSelectable() {
        return getFigure().isVisible();
    }
d1371 6
a1376 7
    /*
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#disableEditMode()
     */
    public void disableEditMode() {
        if (isEditable == false) {
            return;
        }
d1378 11
a1388 8
        List l = getSourceConnections();
        int size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }
d1390 7
a1396 8
        List c = getChildren();
        size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }
d1398 2
a1399 2
        isEditable = false;
    }
d1401 7
a1407 16
    /*
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#enableEditMode()
     */
    public void enableEditMode() {
        if (isEditable) {
            return;
        }
        isEditable = true;
        List c = getChildren();
        int size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }
d1409 2
a1410 9
        List l = getSourceConnections();
        size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }
    }
d1412 7
a1418 11
    /*
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#isEditModeEnabled()
     */
    public boolean isEditModeEnabled() {
        // protect against deadlock - don't allow any action while write
        // transaction
        // is active on another thread
        if (EditPartUtil.isWriteTransactionInProgress(this, true, true))
            return false;
        return isEditable;
    }
d1420 2
a1421 7
    /*
     * @@see org.eclipse.gef.EditPart#showSourceFeedback(org.eclipse.gef.Request)
     */
    public void showSourceFeedback(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }
d1423 7
a1429 2
        super.showSourceFeedback(request);
    }
d1431 2
a1432 7
    /*
     * @@see org.eclipse.gef.EditPart#showTargetFeedback(org.eclipse.gef.Request)
     */
    public void showTargetFeedback(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }
d1434 10
a1443 2
        super.showTargetFeedback(request);
    }
d1445 11
a1455 7
    /*
     * @@see org.eclipse.gef.EditPart#eraseSourceFeedback(org.eclipse.gef.Request)
     */
    public void eraseSourceFeedback(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }
d1457 10
a1466 2
        super.eraseSourceFeedback(request);
    }
d1468 14
a1481 60
    /*
     * @@see org.eclipse.gef.EditPart#eraseTargetFeedback(org.eclipse.gef.Request)
     */
    public void eraseTargetFeedback(Request request) {
        if (!isEditModeEnabled()) {
            return;
        }

        super.eraseTargetFeedback(request);
    }

    /**
     * this method will return the primary child EditPart inside this edit part
     * 
     * @@return the primary child view inside this edit part
     */
    public EditPart getPrimaryChildEditPart() {
        if (getChildren().size() > 0)
            return (EditPart) getChildren().get(0);
        return null;
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramPreferencesHint()
     */
    public PreferencesHint getDiagramPreferencesHint() {
    	RootEditPart root = getRoot();
        if (root instanceof IDiagramPreferenceSupport) {
            return ((IDiagramPreferenceSupport) root).getPreferencesHint();
        }
        return PreferencesHint.USE_DEFAULTS;
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener#notifyChanged(org.eclipse.emf.common.notify.Notification)
     */
    public void notifyChanged(Notification notification) {
        if (isActive()) {
            handleNotificationEvent(notification);
        }
    }

    /**
     * Handles the property changed event
     * 
     * @@param event
     *            the property changed event
     */
    protected void handleNotificationEvent(Notification event) {
        Object feature = event.getFeature();
        if (NotationPackage.Literals.VIEW__PERSISTED_CHILDREN.equals(
            feature)
            || NotationPackage.Literals.VIEW__TRANSIENT_CHILDREN.equals(
                feature)) {
            refreshChildren();
        } else if (NotationPackage.Literals.VIEW__VISIBLE.equals(feature)) {
d1483 34
a1516 33
            if (notifier == getModel())
                setVisibility(((Boolean) event.getNewValue()).booleanValue());
            // Reactivating in response to semantic model reference change
            // However, we need to verify that the event belongs to this
            // editpart's view
        } else if (NotationPackage.Literals.ROUTING_STYLE__ROUTING.equals(
            feature)) {
            installRouter();
        } else if (NotationPackage.Literals.ROUTING_STYLE__SMOOTHNESS
            .equals(feature)
            || NotationPackage.Literals.ROUTING_STYLE__AVOID_OBSTRUCTIONS
                .equals(feature)
            || NotationPackage.Literals.ROUTING_STYLE__CLOSEST_DISTANCE
                .equals(feature)
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINK_STATUS
                .equals(feature)
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINK_TYPE.equals(
                feature)
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINKS_REVERSE
                .equals(feature)) {
            refreshVisuals();
        } else if (NotationPackage.Literals.LINE_STYLE__LINE_COLOR.equals(
            feature)) {
            Integer c = (Integer) event.getNewValue();
            setForegroundColor(DiagramColorRegistry.getInstance().getColor(c));
        } else if (NotationPackage.Literals.RELATIVE_BENDPOINTS__POINTS
            .equals(feature)) {
            refreshBendpoints();
        } else if (event.getFeature() == NotationPackage.Literals
            .VIEW__ELEMENT
            && ((EObject) event.getNotifier()) == getNotationView()){
            handleMajorSemanticChange();
       } else if (event.getEventType() == EventType.UNRESOLVE
d1519 1
a1519 1
    }
d1521 10
a1530 13
    /**
     * @@return <code>IMapMode</code> that allows for the coordinate mapping
     *         from device to logical units.
     */
    protected IMapMode getMapMode() {
        RootEditPart root = getRoot();
        if (root instanceof DiagramRootEditPart) {
            DiagramRootEditPart dgrmRoot = (DiagramRootEditPart) root;
            return dgrmRoot.getMapMode();
        }

        return MapModeUtil.getMapMode();
    }
d1532 3
d1543 1
a1543 1

d1546 1
a1546 2
                editingDomain = TransactionUtil
                    .getEditingDomain(getDiagramView());
d1550 8
a1557 8
    }

    /**
     * Gets the diagram event broker from the editing domain.
     * 
     * @@return the diagram event broker
     */
    private DiagramEventBroker getDiagramEventBroker() {
d1564 1
a1564 2
    
    
d1585 1
a1585 2
    }
    
d1595 2
a1596 3
    	EditPartViewer viewer = getViewer();
        if (viewer instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) viewer).getResourceManager();
d1599 1
a1599 2
    }   
  
@


1.35.2.5
log
@[152392] gmf_R1_0_maintenance Reverting  yLulu 060801 Performance of DiagramEditPart and ConnectionEditPart could be enhanced
@
text
@d42 1
a72 1
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DefaultEditableEditPart;
d143 5
d150 1
a150 1
    
d155 2
a156 1
    
d163 18
a180 21
    /**
     * gets a property change command for the passed property, using both of the
     * old and new values
     * 
     * @@param property
     *            the property associated with the command
     * @@param oldValue
     *            the old value associated with the command
     * @@param newValue
     *            the new value associated with the command
     * @@return a command
     */
    protected Command getPropertyChangeCommand(Object property,
            Object oldValue, Object newValue) {
        // by default return null, which means there is no special command to
        // change the property
        return null;
    }

    /** Used for handling the editable status of the edit part */
    private final IEditableEditPart editableEditPart;
d198 2
a199 1
        EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(), semanticProxy);
d231 1
a231 2
        getDiagramEventBroker().addNotificationListener(element,
            listener);
d258 2
a259 2
        getDiagramEventBroker().addNotificationListener(element,
            feature, listener);
d325 16
a340 16
    public void deactivate() {
        boolean wasActive = isActive();
        super.deactivate();
        if (listenerFilters != null && wasActive != isActive()) {
            for (Iterator i = listenerFilters.keySet().iterator(); i.hasNext();) {
                Object[] obj = (Object[]) listenerFilters.get(i.next());
                if (obj.length > 2) {
                    getDiagramEventBroker().removeNotificationListener(
                        (EObject) obj[0], (EStructuralFeature) obj[1],
                        (NotificationListener) obj[2]);
                } else {
                    getDiagramEventBroker().removeNotificationListener(
                        (EObject) obj[0], (NotificationListener) obj[1]);
                }
            }
        }
d346 1
a346 1
    }
d441 1
a441 1
                    
d470 4
a473 4
        Object adapter = Platform.getAdapterManager().getAdapter(this, key);
        if (adapter != null) {
            return adapter;
        }
d475 1
a475 1
        if (adapter == SnapToHelper.class) {
d478 3
a480 3

            Boolean val = (Boolean) getViewer().getProperty(
                RulerProvider.PROPERTY_RULER_VISIBILITY);
d484 2
a485 2
            val = (Boolean) getViewer().getProperty(
                SnapToGeometry.PROPERTY_SNAP_ENABLED);
d503 2
a504 2
        if (View.class.isAssignableFrom(key) && key.isInstance(model) ) {
            return getModel();
d513 3
a515 3
            } else if (key.isInstance(model)) {
                return model;
            }
d552 3
a554 3
                public void run() {
                    setResult(ConnectionEditPart.super.getCommand(request));
                }
d556 1
a556 1
            });
d562 4
a565 3
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "getCommand", e); //$NON-NLS-1$
d637 2
a638 15
        try {
            return (EObject) getEditingDomain().runExclusive(
                new RunnableWithResult.Impl() {
    
                public void run() {
                    setResult(ViewUtil.resolveSemanticElement((View) getModel()));
                }
            });
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "resolveSemanticElement", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "resolveSemanticElement", e); //$NON-NLS-1$
d640 2
a642 1

d682 2
a683 2
     * Handles the property changed event.  Clients should override to
     * respond to the specific notification events they are interested.
d685 1
a685 1
     * Note: This method may get called on a non-UI thread.  Clients should
d687 4
a690 4
     * unsupported calls (i.e. Display.getCurrent() ) assuming they are on
     * the main thread.  Alternatively if this is not possible, then the
     * client can wrap their handler within the Display.synchExec runnable
     * to ensure synchronization and subsequent execution on the main thread.
d693 2
a694 1
     *            the <code>Notification</code> object that is the property changed event
d761 1
a761 1
            NotationPackage.eINSTANCE.getLineStyle());
d763 2
a764 2
            setForegroundColor(DiagramColorRegistry
                .getInstance().getColor(new Integer(style.getLineColor())));
d790 1
a790 1
            DiagramEventBroker.getInstance(getEditingDomain()).removeNotificationListener(
d849 4
a852 3
     * This method adds all listeners to the semantic element behind this EditPart 
     * Override this method to add more semantic listeners down the hierarchy
     * This method is called only if the semantic element is resolvable
d871 3
a873 3
     * This method removes all listeners to the semantic element behind this EditPart
     * Override this method to remove semantic listeners
     * down the hierarchy
a902 1
        this.editableEditPart = new DefaultEditableEditPart(this);
d926 7
a932 8
                        public void run() {
                            ConnectionEditPart.super.refresh();
                            EditPolicyIterator i = getEditPolicyIterator();
                            while (i.hasNext()) {
                                EditPolicy policy = i.next();
                                if (policy instanceof GraphicalEditPolicyEx) {
                                    ((GraphicalEditPolicyEx) policy).refresh();
                                }
d935 2
a936 1
                    });
d989 1
a989 1
            .getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
d993 1
a993 1
            ConnectionLayerEx cLayerEx = (ConnectionLayerEx)cLayer;
d1043 1
a1043 1
        
d1045 1
d1073 1
a1073 1
        
d1076 1
a1076 1
            .getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
d1099 1
a1099 1
        
d1102 1
a1102 1
            .getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
d1137 1
a1137 1
        
d1141 1
a1141 1
            .getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
d1172 1
a1172 1
            NotationPackage.eINSTANCE.getFontStyle());
d1182 9
a1190 9
     * Sets the font to the label. This method could be overriden to change the
     * font data of the font overrides typically look like this: super.setFont(
     * new FontData( fontData.getName(), fontData.getHeight(),
     * fontData.getStyle() <| &> SWT.????));
     * 
     * @@param fontData
     *            the font data
     */
    protected void setFont(FontData fontData) {
d1265 4
a1268 4
                        public void run() {
                            setResult(getPrimaryChildEditPart());
                        }
                    });
d1362 23
a1384 1
        this.editableEditPart.disableEditMode();
d1391 21
a1411 1
        this.editableEditPart.enableEditMode();
d1418 2
a1419 1
        // protect against deadlock - don't allow any action while write transaction
d1423 1
a1423 2
        
        return this.editableEditPart.isEditModeEnabled();
d1487 3
a1489 2
        if (getRoot() instanceof IDiagramPreferenceSupport) {
            return ((IDiagramPreferenceSupport) getRoot()).getPreferencesHint();
d1513 1
a1513 1
        if (NotationPackage.eINSTANCE.getView_PersistedChildren().equals(
d1515 1
a1515 1
            || NotationPackage.eINSTANCE.getView_TransientChildren().equals(
d1518 1
a1518 1
        } else if (NotationPackage.eINSTANCE.getView_Visible().equals(feature)) {
d1520 2
a1521 2
            if (notifier== getModel())
            setVisibility(((Boolean) event.getNewValue()).booleanValue());
d1525 1
a1525 1
        } else if (NotationPackage.eINSTANCE.getRoutingStyle_Routing().equals(
d1528 1
a1528 1
        } else if (NotationPackage.eINSTANCE.getRoutingStyle_Smoothness()
d1530 1
a1530 1
            || NotationPackage.eINSTANCE.getRoutingStyle_AvoidObstructions()
d1532 1
a1532 1
            || NotationPackage.eINSTANCE.getRoutingStyle_ClosestDistance()
d1534 1
a1534 1
            || NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkStatus()
d1536 1
a1536 1
            || NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkType().equals(
d1538 1
a1538 1
            || NotationPackage.eINSTANCE.getRoutingStyle_JumpLinksReverse()
d1541 1
a1541 1
        } else if (NotationPackage.eINSTANCE.getLineStyle_LineColor().equals(
d1544 2
a1545 3
            setForegroundColor(DiagramColorRegistry
                .getInstance().getColor(c));
        } else if (NotationPackage.eINSTANCE.getRelativeBendpoints_Points()
d1548 2
a1549 2
        } else if (event.getFeature() == NotationPackage.eINSTANCE
            .getView_Element()
d1552 1
a1552 1
        } else if (event.getEventType() == EventType.UNRESOLVE
d1558 2
a1559 2
     * @@return <code>IMapMode</code> that allows for the coordinate mapping from device to
     * logical units. 
d1561 1
a1561 1
    final protected IMapMode getMapMode() {
d1564 1
a1564 1
            DiagramRootEditPart dgrmRoot = (DiagramRootEditPart)root;
d1570 1
a1570 1
    
d1579 1
a1579 1
            
d1582 2
a1583 1
                editingDomain = TransactionUtil.getEditingDomain(getDiagramView());
d1587 2
a1588 2
    }   
    
d1601 2
a1602 1

d1623 2
a1624 1
    }    
d1634 3
a1636 2
        if (getViewer() instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) getViewer()).getResourceManager();
d1639 2
a1640 1
    }
@


1.35.2.6
log
@[152392] gmf_R1_0_maintenance Reverting  yLulu 060801 Performance of DiagramEditPart and ConnectionEditPart could be enhanced
@
text
@a41 1
import org.eclipse.gef.EditPartViewer;
d72 1
a142 5
    /**
     * Flag to indicate if the edit part is in edit mode
     */
    private boolean isEditable = true;

d145 1
a145 1

d150 1
a150 2

     
d176 3
d195 1
a195 2
        EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(),
            semanticProxy);
d227 2
a228 1
        getDiagramEventBroker().addNotificationListener(element, listener);
d255 2
a256 2
        getDiagramEventBroker().addNotificationListener(element, feature,
            listener);
d322 1
a322 1
   public void deactivate() {
d438 1
a438 1

d472 1
a472 1
        if (key == SnapToHelper.class) {
d475 3
a477 3
            EditPartViewer viewer = getViewer();
            Boolean val = (Boolean) viewer
                .getProperty(RulerProvider.PROPERTY_RULER_VISIBILITY);
d481 2
a482 2
            val = (Boolean) viewer
                .getProperty(SnapToGeometry.PROPERTY_SNAP_ENABLED);
d500 2
a501 2
        if (View.class.isAssignableFrom(key) && key.isInstance(model)) {
            return model;
d510 1
a510 1
            }else if (key.isInstance(model)) {
d549 3
a551 3
                    public void run() {
                        setResult(ConnectionEditPart.super.getCommand(request));
                    }
d553 1
a553 1
                });
d559 3
a561 4
            Log
                .error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                    "getCommand", e); //$NON-NLS-1$
a632 9
        EObject eObj = ((View) getModel()).getElement();
        if (eObj == null) {
            return null;
        }

        if (!eObj.eIsProxy()) {
            return eObj;
        }

d636 5
a640 6

                    public void run() {
                        setResult(ViewUtil
                            .resolveSemanticElement((View) getModel()));
                    }
                });
d650 1
d690 2
a691 2
     * Handles the property changed event. Clients should override to respond to
     * the specific notification events they are interested.
d693 1
a693 1
     * Note: This method may get called on a non-UI thread. Clients should
d695 4
a698 4
     * unsupported calls (i.e. Display.getCurrent() ) assuming they are on the
     * main thread. Alternatively if this is not possible, then the client can
     * wrap their handler within the Display.synchExec runnable to ensure
     * synchronization and subsequent execution on the main thread.
d701 1
a701 2
     *            the <code>Notification</code> object that is the property
     *            changed event
d768 1
a768 1
            NotationPackage.Literals.LINE_STYLE);
d770 2
a771 2
            setForegroundColor(DiagramColorRegistry.getInstance().getColor(
                new Integer(style.getLineColor())));
d797 1
a797 1
            getDiagramEventBroker().removeNotificationListener(
d856 3
a858 4
     * This method adds all listeners to the semantic element behind this
     * EditPart Override this method to add more semantic listeners down the
     * hierarchy This method is called only if the semantic element is
     * resolvable
d877 3
a879 3
     * This method removes all listeners to the semantic element behind this
     * EditPart Override this method to remove semantic listeners down the
     * hierarchy
d909 1
d933 8
a940 7
                    public void run() {
                        ConnectionEditPart.super.refresh();
                        EditPolicyIterator i = getEditPolicyIterator();
                        while (i.hasNext()) {
                            EditPolicy policy = i.next();
                            if (policy instanceof GraphicalEditPolicyEx) {
                                ((GraphicalEditPolicyEx) policy).refresh();
d943 1
a943 2
                    }
                });
d996 1
a996 1
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);
d1000 1
a1000 1
            ConnectionLayerEx cLayerEx = (ConnectionLayerEx) cLayer;
d1050 1
a1050 1

a1051 1

d1079 1
a1079 1

d1082 1
a1082 1
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);
d1105 1
a1105 1

d1108 1
a1108 1
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);
d1143 1
a1143 1

d1147 1
a1147 1
            .getStyle(NotationPackage.Literals.ROUTING_STYLE);
d1178 1
a1178 1
            NotationPackage.Literals.FONT_STYLE);
d1271 4
a1274 4
                    public void run() {
                        setResult(getPrimaryChildEditPart());
                    }
                });
d1368 1
a1368 23
        if (isEditable == false) {
            return;
        }

        List l = getSourceConnections();
        int size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        List c = getChildren();
        size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        isEditable = false;
d1375 1
a1375 21
        if (isEditable) {
            return;
        }
        isEditable = true;
        List c = getChildren();
        int size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }

        List l = getSourceConnections();
        size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }
d1382 1
a1382 2
        // protect against deadlock - don't allow any action while write
        // transaction
d1386 2
a1387 1
        return isEditable;
d1451 2
a1452 3
        RootEditPart root = getRoot();
        if (root instanceof IDiagramPreferenceSupport) {
            return ((IDiagramPreferenceSupport) root).getPreferencesHint();
d1476 1
a1476 1
        if (NotationPackage.Literals.VIEW__PERSISTED_CHILDREN.equals(
d1478 1
a1478 1
            || NotationPackage.Literals.VIEW__TRANSIENT_CHILDREN.equals(
d1481 1
a1481 1
        } else if (NotationPackage.Literals.VIEW__VISIBLE.equals(feature)) {
d1483 2
a1484 2
            if (notifier == getModel())
                setVisibility(((Boolean) event.getNewValue()).booleanValue());
d1488 1
a1488 1
        } else if (NotationPackage.Literals.ROUTING_STYLE__ROUTING.equals(
d1491 1
a1491 1
        } else if (NotationPackage.Literals.ROUTING_STYLE__SMOOTHNESS
d1493 1
a1493 1
            || NotationPackage.Literals.ROUTING_STYLE__AVOID_OBSTRUCTIONS
d1495 1
a1495 1
            || NotationPackage.Literals.ROUTING_STYLE__CLOSEST_DISTANCE
d1497 1
a1497 1
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINK_STATUS
d1499 1
a1499 1
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINK_TYPE.equals(
d1501 1
a1501 1
            || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINKS_REVERSE
d1504 1
a1504 1
        } else if (NotationPackage.Literals.LINE_STYLE__LINE_COLOR.equals(
d1507 3
a1509 2
            setForegroundColor(DiagramColorRegistry.getInstance().getColor(c));
        } else if (NotationPackage.Literals.RELATIVE_BENDPOINTS__POINTS
d1512 2
a1513 2
        } else if (event.getFeature() == NotationPackage.Literals
            .VIEW__ELEMENT
d1516 1
a1516 1
       } else if (event.getEventType() == EventType.UNRESOLVE
d1522 2
a1523 2
     * @@return <code>IMapMode</code> that allows for the coordinate mapping
     *         from device to logical units.
d1525 1
a1525 1
    protected IMapMode getMapMode() {
d1528 1
a1528 1
            DiagramRootEditPart dgrmRoot = (DiagramRootEditPart) root;
d1534 1
a1534 1

d1543 1
a1543 1

d1546 1
a1546 2
                editingDomain = TransactionUtil
                    .getEditingDomain(getDiagramView());
d1550 2
a1551 2
    }

d1564 1
a1564 2
    
    
d1585 1
a1585 2
    }
    
d1595 2
a1596 3
        EditPartViewer viewer = getViewer();
        if (viewer instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) viewer).getResourceManager();
d1599 1
a1599 2
    }   
  
@


1.35.2.7
log
@[151097] gmf_R1_0_maintenance ldamus 060802 Connections with semantic meaning can be incorrectly reoriented to shapes
@
text
@a79 1
import org.eclipse.gmf.runtime.diagram.ui.internal.type.NotationTypeUtil;
a163 6
	 * Cache the answer to whether or not this is a semantic connection after it
	 * is retrieved.
	 */
    private Boolean semanticConnection;
    
    /**
d1660 1
a1660 29
    } 
    
    /**
	 * Answers whether or not this connection represents a part of the semantic
	 * model.
	 * 
	 * @@return <code>true</code> if this connection has semantic meaning,
	 *         <code>false</code> otherwise.
	 */
	public boolean isSemanticConnection() {

		if (semanticConnection == null) {
			if (getEdge() != null && (getEdge().getElement() != null
					|| !NotationTypeUtil.hasNotationType(getEdge()))) {
				semanticConnection = Boolean.TRUE;
			} else {
				semanticConnection = Boolean.FALSE;
			}
		}
		return semanticConnection.booleanValue();
	}
	
	/**
	 * Clear the semantic connection value when the model changes.
	 */
	public void setModel(Object model) {
		super.setModel(model);
		semanticConnection = null;
	}
@


1.35.2.8
log
@[144567] gmf_R1_0_maintenance ABoyko 060810 Problems when using the "avoid obstructions" setting for connections
@
text
@a1175 7
            
			if (avoidObstruction)
				installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,null);
			else
				installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
							new ConnectionBendpointEditPolicy());

@


1.35.2.9
log
@[154243] gmf_R1_0_maintenance sshaw 060816 TreeRouting connections broken on re-opening of diagram
@
text
@d1180 2
a1181 1
				installBendpointEditPolicy();
@


1.35.2.10
log
@Bugzilla#154062 gmf_R1_0_maintenance cmahoney 060822 recent gmf diagram change breaks compare/merge
@
text
@a347 5
    }

    public void removeNotify() {
        super.removeNotify();
        
@


1.35.2.11
log
@[162133] gmf_R1_0_maintenance ldamus 061122 ConnectionEditPart deactivates itself when not active
@
text
@a201 5
    	
    	if (isActive()) {
            return;
        }
    	
a332 5
	   
	   if (!isActive()) {
           return;
       }
	   
@


1.35.2.12
log
@[162114]   gmf_R1_0_maintenace mmostafa 061206 GraphicalEditPart refresh creates a child edit part without the correct editable state
@
text
@a187 18
    
    

    protected void addChild(EditPart child, int index) {
        super.addChild(child, index);
        if (child instanceof GraphicalEditPart){
            GraphicalEditPart gEP = (GraphicalEditPart)child;
            boolean editMode = isEditModeEnabled(); 
            if (editMode != gEP.isEditModeEnabled()){
                if (editMode)
                    gEP.enableEditMode();
                else
                    gEP.disableEditMode();
            }
        }
    }


@


1.34
log
@bugzilla 145363 gmf-head sshaw 060605 Layout not invoked during drag and drop operation
@
text
@a78 1
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.NotificationForEditPartsListener;
d127 1
a127 1
	IPrimaryEditPart, NotificationForEditPartsListener {
@


1.33
log
@bugzilla 140020 gmf-head sshaw 060602 Deadlock in PopupBarEditPolicy$PopupBarLabelHandle
@
text
@d1022 11
a1035 2
					installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
						new TreeConnectionBendpointEditPolicy());
a1037 2
					installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
						new ConnectionLineSegEditPolicy());
a1039 2
					installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
						new ConnectionBendpointEditPolicy());
@


1.32
log
@bugzilla 142803 gmf-head sshaw 060531 Illegal Asynchronous Access to ResourceSetChangeEvent in DiagramEventBrokerThreadSafe
@
text
@d1342 1
a1342 1
		if (EditPartUtil.isWriteTransactionInProgress(this, true))
@


1.31
log
@bugzilla 142803 gmf-head sshaw 060531 Illegal Asynchronous Access to ResourceSetChangeEvent in DiagramEventBrokerThreadSafe
@
text
@d1022 1
a1022 1
		EditPartUtil.handleRunnableForAccessingSWT(this, new Runnable() {
@


1.30
log
@Bugzilla#109422 gmf_head cmahoney 060509 Removing deprecated classes from GMF diagram components
@
text
@d79 1
d87 1
d128 1
a128 1
	IPrimaryEditPart, NotificationListener {
d1022 17
a1038 13
		if (getConnectionFigure().getConnectionRouter() instanceof ForestRouter) {
			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
				new TreeConnectionBendpointEditPolicy());
			getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
		} else if (getConnectionFigure().getConnectionRouter() instanceof OrthogonalRouter) {
			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
				new ConnectionLineSegEditPolicy());
			getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
		} else {
			installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,
				new ConnectionBendpointEditPolicy());
			getConnectionFigure().setCursor(Cursors.CURSOR_SEG_ADD);
		}
d1340 5
@


1.29
log
@bugzilla 128968 gmf-head sshaw 060411 Allow to use arbitrary connection figures in runtime (remove casts to PolylineConnectionEx)
@
text
@a597 14
	 * Convenience method to retreive the value for the supplied poperty from
	 * the editpart's associated view element.
	 * 
	 * @@param id
	 *            the property id
	 * @@return Object the value
	 * @@deprecated use {@@link #getStructuralFeatureValue(EStructuralFeature)}
	 *             instead
	 */
	public Object getPropertyValue(Object id) {
		return ViewUtil.getPropertyValue((View) getModel(), id);
	}

	/**
a797 12
	 * Convenience method to set a property value.
	 * 
	 * @@param id
	 * @@param value
	 * @@deprecated use {@@link #setStructuralFeatureValue(Object, Object)}
	 *             instead
	 */
	public void setPropertyValue(Object id, Object value) {
		ViewUtil.setPropertyValue((View) getModel(), id, value);
	}

	/**
@


1.28
log
@[131119] gmf_head ldamus 060209 Unable to override GraphicalEditPart.getEditingDomain() as it is final
@
text
@d1073 5
a1077 1
		PolylineConnectionEx poly = ((PolylineConnectionEx) getConnectionFigure());
d1099 5
a1103 1
		PolylineConnectionEx poly = ((PolylineConnectionEx) getConnectionFigure());
d1137 5
a1141 1
		PolylineConnectionEx poly = ((PolylineConnectionEx) getConnectionFigure());
@


1.27
log
@Bugzilla#131119 gmf_head cmahoney 060309 Unable to override GraphicalEditPart.getEditingDomain() as it is final
@
text
@d1499 7
a1505 1
            editingDomain = TransactionUtil.getEditingDomain(getDiagramView());
@


1.26
log
@Bugzilla#129773 gmf_head cmahoney 060308 Delete from Project Explorer does not delete view from diagram
@
text
@d1497 1
a1497 1
    public final TransactionalEditingDomain getEditingDomain() {
@


1.25
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d526 2
a527 2
			Command cmd = (Command) TransactionUtil.getEditingDomain(
				(View) getModel()).runExclusive(new RunnableWithResult.Impl() {
d628 2
a629 2
			return (EObject) TransactionUtil.getEditingDomain(
				(View) getModel()).runExclusive(new RunnableWithResult.Impl() {
d937 1
a937 2
				TransactionUtil.getEditingDomain((View) getModel())
					.runExclusive(new Runnable() {
@


1.24
log
@bugzilla 123819 gmf-head sshaw 060223 Hide Connector Labels hides connectors as well
@
text
@a16 1
import java.util.Dictionary;
a17 1
import java.util.Hashtable;
a31 1
import org.eclipse.emf.ecore.ENamedElement;
d34 1
d56 2
a58 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
d69 3
d92 1
a92 4
import org.eclipse.gmf.runtime.emf.core.EventTypes;
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.emf.core.util.MetaModelUtil;
import org.eclipse.gmf.runtime.emf.core.util.ProxyUtil;
d136 5
d180 1
a180 2
		EObject semanticElement = ProxyUtil.resolve(MEditingDomainGetter
			.getMEditingDomain((View) getModel()), semanticProxy);
d212 1
a212 1
		DiagramEventBroker.getInstance().addNotificationListener(element,
d240 1
a240 1
		DiagramEventBroker.getInstance().addNotificationListener(element,
d314 3
a316 4
					DiagramEventBroker.getInstance()
						.removeNotificationListener((EObject) obj[0],
							(EStructuralFeature) obj[1],
							(NotificationListener) obj[2]);
d318 2
a319 3
					DiagramEventBroker.getInstance()
						.removeNotificationListener((EObject) obj[0],
							(NotificationListener) obj[1]);
d525 7
a531 2
		Command cmd = (Command) MEditingDomainGetter.getMEditingDomain(
			(View) getModel()).runAsRead(new MRunnable() {
d533 11
a543 5
			public Object run() {
				return ConnectionEditPart.super.getCommand(request);
			}
		});
		return cmd;
d627 17
a643 2
		return (EObject) MEditingDomainGetter.getMEditingDomain(
			(View) getModel()).runAsRead(new MRunnable() {
a644 4
			public Object run() {
				return ViewUtil.resolveSemanticElement((View) getModel());
			}
		});
d791 1
a791 1
			DiagramEventBroker.getInstance().removeNotificationListener(
d795 1
a795 1
			DiagramEventBroker.getInstance().removeNotificationListener(
a899 25
	 * Return a Map of all the appearance property ids supported by the edit
	 * part and its children.
	 * 
	 * Each entry in the map is the factory hint of the edit part as key and a
	 * dictionary of appearance properties as values. The edit parts are the
	 * receiver itself and it's children.
	 * 
	 * For example, the connectable shape edit part with name, attribute,
	 * operation and shape compartments will return a map where: 1 entry:
	 * connectable shape factory hint -> dictionary: Properties.ID_FONT -> font
	 * data Properties.ID_FONTCOLOR -> font color Properties.ID_LINECOLOR ->
	 * line color Properties.ID_FILLCOLOR -> fill color 2d entry: attribute
	 * compartment hint -> dictionary(empty) 3d entry: operation compartment
	 * hint -> dictionary(empty) 4d entry: shape compartment hint ->
	 * dictionary(empty)
	 * 
	 * @@return Map
	 */
	public Map getAppearancePropertiesMap() {
		Map properties = new HashMap();
		fillAppearancePropertiesMap(properties);
		return properties;
	}

	/**
d935 13
a947 11
		if (getSource() != null && getTarget() != null)
			MEditingDomainGetter.getMEditingDomain((View) getModel())
				.runAsRead(new MRunnable() {

					public Object run() {
						ConnectionEditPart.super.refresh();
						EditPolicyIterator i = getEditPolicyIterator();
						while (i.hasNext()) {
							EditPolicy policy = i.next();
							if (policy instanceof GraphicalEditPolicyEx) {
								((GraphicalEditPolicyEx) policy).refresh();
d950 10
a959 3
						return null;
					}
				});
d1004 1
a1004 1
        
a1188 31
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#fillAppearancePropertiesMap(java.util.Map)
	 */
	public void fillAppearancePropertiesMap(Map properties) {

		if (getAppearancePropertyIDs().length > 0) {
			// only if there are any appearance properties
			final Dictionary local_properties = new Hashtable();
			for (int i = 0; i < getAppearancePropertyIDs().length; i++) {
				String prob = getAppearancePropertyIDs()[i];
				ENamedElement element = MetaModelUtil.getElement(prob);
				if (element instanceof EStructuralFeature
					&& ViewUtil.isPropertySupported((View) getModel(), prob)) {
					local_properties
						.put(
							getAppearancePropertyIDs()[i],
							getStructuralFeatureValue((EStructuralFeature) element));
				}
			}
			properties.put(((View) getModel()).getType(), local_properties);
		}

		Iterator iterator = getChildren().iterator();
		while (iterator.hasNext()) {
			IGraphicalEditPart child = (IGraphicalEditPart) iterator.next();
			child.fillAppearancePropertiesMap(properties);
		}
	}

d1234 11
a1244 2
		EditPart primaryChildEditPart = (EditPart) MEditingDomainGetter
			.getMEditingDomain((View) getModel()).runAsRead(new MRunnable() {
d1246 7
a1252 6
				public Object run() {
					return getPrimaryChildEditPart();
				}
			});
		if (primaryChildEditPart != null) {
			primaryChildEditPart.performRequest(request);
d1254 1
d1275 1
a1275 1
		elementGuid = ProxyUtil.getProxyID(ref);
d1446 1
a1446 1
                setVisibility(((Boolean) event.getNewValue()).booleanValue());
a1477 4

		else if (event.getEventType() == EventTypes.UNRESOLVE
			&& event.getNotifier() == ((View) getModel()).getElement())
			handleMajorSemanticChange();
d1490 1
a1490 1
				
d1493 1
a1493 1
    
d1495 1
a1495 1
     * Derives my editing domain from my diagram view element. Subclasses may
d1498 18
a1515 2
    public TransactionalEditingDomain getEditingDomain() {
        return TransactionUtil.getEditingDomain(getDiagramView());
@


1.23
log
@bugzilla 128971 gmf-head sshaw 060223 Do not throw CCE when connection layer other then ConnectionLayerEx is used

Contributed slightly modified patch for Dmitri Stadnik dstadnik@@borland.com
@
text
@d1457 3
a1459 1
			setVisibility(((Boolean) event.getNewValue()).booleanValue());
@


1.22
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d29 1
d994 1
a994 2
		ConnectionLayerEx cLayer = (ConnectionLayerEx) getLayer(LayerConstants.CONNECTION_LAYER);

d997 2
a998 1
		if (style != null) {
d1000 1
d1004 1
a1004 1
					cLayer.getObliqueRouter());
d1007 1
a1007 1
					cLayer.getRectilinearRouter());
d1010 1
a1010 1
					cLayer.getTreeRouter());
@


1.21
log
@bugzilla 117592 gmf-head mmostafa 060207 Eroneous references to xtools in diagram plugins
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
d36 2
d1506 8
@


1.20
log
@bugzilla 116224 gmf-head sshaw 060119 Notation meta-model support for coordinate systems
@
text
@d836 1
a836 1
	 * This method adds all listeners to the semantic world (IUMLElement...etc)
d857 2
a858 2
	 * This method removes all listeners to the semantic world
	 * (IUMLElement...etc) Override this method to remove semantic listeners
a1456 2
			// cannot do it now since property's source is (IView for RMS) and
			// (IUMLView for EMF)
@


1.19
log
@bugzilla 117912 gmf-head sshaw 060117 GraphicalEditPart / ConnectionEditPart could cause invalid thread access
@
text
@d45 1
d1494 2
a1495 2
	 * @@return <code>IMapMode</code> that allows for the coordinate mapping
	 *         from device to logical units.
d1498 6
a1503 8
		EditPart parent = getParent();
		if (parent instanceof DiagramRootEditPart)
			return ((DiagramRootEditPart) parent).getMapMode();
		else if (parent instanceof org.eclipse.gef.GraphicalEditPart)
			return MapModeUtil
				.getMapMode(((org.eclipse.gef.GraphicalEditPart) parent)
					.getFigure());

@


1.18
log
@Bugzilla#121452 gmf_head cmahoney 060112 Fix *.properties files for CHKPII and SEGCHK
@
text
@d657 9
a665 1
	 * Handles the property changed event
d668 1
a668 1
	 *            the property changed event
@


1.17
log
@bugzilla 121784 gmf-head mmostafa 051224 Class cast exception when adapting to Diagram when model is a Node
@
text
@d106 1
a369 1

a387 2
					StringBuffer msg = new StringBuffer();

d392 1
a392 1
					msg.append(getSemanticName());
d395 1
d401 1
a401 5
						msg.append(" "); //$NON-NLS-1$
						msg
							.append(DiagramUIMessages.Accessible_Connection_From);
						msg.append(" "); //$NON-NLS-1$
						msg.append(event.result);
d405 1
d411 20
a430 4
						msg.append(" "); //$NON-NLS-1$
						msg.append(DiagramUIMessages.Accessible_Connection_To);
						msg.append(" "); //$NON-NLS-1$
						msg.append(event.result);
a431 2

					e.result = msg.toString();
@


1.16
log
@bugzilla 120017 gmf-head sshaw 051208 Redundant classes for managing connection retargetting
@
text
@d465 1
a465 1
		if (View.class.isAssignableFrom(key) && model instanceof View) {
a1409 48
	 * ATTENTION!!!!: Do not remove, see below. Only update based on newer GEF
	 * framework
	 * 
	 * This function is "copied" from GEF for the following reason: GEF does not
	 * check if the connection's source or target are the same as the editpart
	 * before setting them to <code>null</code> which causes the following
	 * usecase to currently fail:
	 * 
	 * "in a model transaction, view's source connections are detached, a new
	 * view is created, and the connections are attached to it, then the old
	 * view is destroyed"
	 * 
	 * The reason for the problem is the filtering of Deleted/Uncreated object's
	 * events in the DiagramEventBroker which prevents the first connection
	 * detach event from coming and avoiding the problem
	 * 
	 * TODO: Remove this override as soon as the bugzilla <Bug 110476> is
	 * resolved or the event filtering is removed
	 * 
	 * @@see org.eclipse.gef.EditPart#removeNotify()
	 */
	public void removeNotify() {
		deactivateFigure();
		if (getSelected() != SELECTED_NONE)
			getViewer().deselect(this);
		if (hasFocus())
			getViewer().setFocus(null);

		List _children = getChildren();
		for (int i = 0; i < _children.size(); i++)
			((EditPart) _children.get(i)).removeNotify();
		unregister();
		List conns;
		conns = getSourceConnections();
		for (int i = 0; i < conns.size(); i++) {
			ConnectionEditPart conn = (ConnectionEditPart) conns.get(i);
			if (conn.getSource() == this)
				conn.setSource(null);
		}
		conns = getTargetConnections();
		for (int i = 0; i < conns.size(); i++) {
			ConnectionEditPart conn = (ConnectionEditPart) conns.get(i);
			if (conn.getTarget() == this)
				conn.setTarget(null);
		}
	}

	/*
@


1.15
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@a60 1
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectionEndpointEditPolicy;
d281 1
a281 1
			new ConnectionEndpointEditPolicy());
d455 1
a455 1
				return (SnapToHelper) snapStrategies.get(0);
@


1.14
log
@bugzilla 112788 gmf-head sshaw 051108 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d73 1
d76 2
a77 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d384 1
a384 2
					return DiagramResourceManager.getInstance().getString(
						"Accessible.Connection.Label"); //$NON-NLS-1$
d404 2
a405 2
						msg.append(DiagramResourceManager.getInstance()
							.getString("Accessible.Connection.From")); //$NON-NLS-1$
d417 1
a417 2
						msg.append(DiagramResourceManager.getInstance()
							.getString("Accessible.Connection.To")); //$NON-NLS-1$
d720 2
a721 2
			setForegroundColor(DiagramResourceManager.getInstance().getColor(
				new Integer(style.getLineColor())));
d1155 1
a1155 1
			DiagramResourceManager.getInstance().getFont(Display.getDefault(),
d1508 2
a1509 1
			setForegroundColor(DiagramResourceManager.getInstance().getColor(c));
d1522 1
a1522 1
	
d1524 2
a1525 2
	 * @@return <code>IMapMode</code> that allows for the coordinate mapping from device to
	 * logical units. 
d1529 2
a1530 2
		if (parent instanceof DiagramRootEditPart) 
			return ((DiagramRootEditPart)parent).getMapMode();
d1532 4
a1535 2
			return MapModeUtil.getMapMode(((org.eclipse.gef.GraphicalEditPart)parent).getFigure());
		
@


1.13
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d83 2
d1521 14
@


1.12
log
@bugzilla 110316 gmf-head mmostafa 051014 Compiler warning count should be 0 - runtime diagram layer components
@
text
@d56 1
a57 1
import org.eclipse.gmf.runtime.diagram.core.listener.PresentationListener;
d60 3
a62 3
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectorBendpointEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectorEndpointEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ConnectorLabelsEditPolicy;
d70 3
a72 3
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.ConnectorEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.ConnectorLineSegEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.TreeConnectorBendpointEditPolicy;
d75 1
a75 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d89 1
a89 1
import org.eclipse.gmf.runtime.gef.ui.internal.tools.SelectConnectorEditPartTracker;
d109 1
d111 3
a113 2
 * the base edit part that controls <code>Edge</code> views, it is the basic 
 * controller for the connector's view
d118 2
a119 1
	implements IGraphicalEditPart, PropertyChangeListener, IContainedEditPart, IPrimaryEditPart, NotificationListener {
d123 1
a123 1
	
d129 1
a129 1
	
d131 15
a145 12
	 * gets a property change command for the passed property, using both of the 
	 * old and new values 
	 * @@param property 	the property associated with the command
	 * @@param oldValue  the old value associated with the command
	 * @@param newValue  the new value associated with the command
	 * @@return	a command
	 */
	protected Command getPropertyChangeCommand(
		Object property,
		Object oldValue,
		Object newValue) {
		// by default return null, which means there is no special command to change the property
d151 1
a151 1
	
d159 3
a161 1
	/* (non-Javadoc)
d165 6
a170 5
			addNotationalListeners();
		
		EObject semanticProxy = ((View)getModel()).getElement();
		EObject semanticElement = ProxyUtil.resolve(MEditingDomainGetter.getMEditingDomain((View)getModel()), semanticProxy);
		
d172 1
a172 1
				addSemanticListeners();
d174 1
a174 1
			addListenerFilter("SemanticProxy", this,semanticProxy); //$NON-NLS-1$
d177 1
a177 2
		}

a178 1
	
d182 9
a190 8
	 * @@param filterId A unique filter id (within the same editpart instance)
	 * @@param listener A listener instance
	 * @@param notifier An element notifer to add the listener to
	 */
	protected void addListenerFilter(
		String filterId,
		NotificationListener listener,
		EObject element) {
d201 3
a203 2
		PresentationListener.getInstance().addNotificationListener(element,listener);
		listenerFilters.put(filterId, new Object[] { element, listener });
d205 1
a205 1
	
d209 10
a218 9
	 * @@param filterId A unique filter id (within the same editpart instance)
	 * @@param listener A listener instance
	 * @@param notifier An element notifer to add the listener to
	 */
	protected void addListenerFilter(
		String filterId,
		NotificationListener listener,
		EObject element,
		EStructuralFeature feature) {
d229 4
a232 2
		PresentationListener.getInstance().addNotificationListener(element,feature,listener);
		listenerFilters.put(filterId, new Object[] { element,feature, listener });
d235 3
a237 1
	/* (non-Javadoc)
d241 2
a242 2
		return EditPartService.getInstance().createGraphicEditPart(
			(View) model);
d245 3
a247 1
	/* (non-Javadoc)
d251 2
a252 2
		Object connectorView) {
		return (org.eclipse.gef.ConnectionEditPart) createChild(connectorView);
d256 2
a257 2
	 * Overridden to support editpolicies installed programmatically and
	 * via the <code>EditPolicyService</code>.  Subclasses should override
d259 1
d269 1
d273 1
a273 2
		installEditPolicy(
			EditPolicyRoles.SEMANTIC_ROLE,
d275 1
a275 2
		installEditPolicy(
			EditPolicyRoles.PROPERTY_HANDLER_ROLE,
d277 4
a280 6
		installEditPolicy(
			EditPolicy.CONNECTION_ENDPOINTS_ROLE,
			new ConnectorEndpointEditPolicy());
		installEditPolicy(
			EditPolicy.CONNECTION_ROLE,
			new ConnectorEditPolicy());
d282 1
a282 2
		installEditPolicy(
			EditPolicyRoles.DECORATION_ROLE,
d284 3
a286 4
		installEditPolicy(
			EditPolicyRoles.CONNECTOR_LABELS,
			new ConnectorLabelsEditPolicy());
		
d291 3
a293 1
	/* (non-Javadoc)
d302 5
a306 3
				if (obj.length>2){
					PresentationListener.getInstance().
						removeNotificationListener((EObject)obj[0],(EStructuralFeature) obj[1],(NotificationListener) obj[2]);
d308 3
a310 1
					PresentationListener.getInstance().removeNotificationListener((EObject)obj[0],(NotificationListener) obj[1]);
d317 4
a320 2
	 * executes the passed command 
	 * @@param command the command to execute
d327 5
a331 5
	* a function that registers this provider with the Eclipse AdapterManager
	* as an IView and an IActionFilter adapter factory for the 
	* IGraphicalEditPart nodes
	*     
	*/
d338 1
a338 3
			public Object getAdapter(
				Object adaptableObject,
				Class adapterType) {
d346 1
a346 1
				} 
d354 1
a354 1
				return new Class[] { IActionFilter.class, View.class };
d360 3
a362 2
	
	/* (non-Javadoc)
d367 1
a367 1
		if( accessibleEP == null ) {
d372 2
a373 2
					
					if( semanticElement != null ) {
d376 1
a376 1
						int endIndex = name.lastIndexOf( "Impl" ); //$NON-NLS-1$
d379 3
a381 2
					
					return PresentationResourceManager.getInstance().getString( "Accessible.Connection.Label" ); //$NON-NLS-1$
d385 1
a385 1
					
d387 1
a387 1
					
d392 1
a392 1
					msg.append( getSemanticName() );
d396 2
a397 1
						AccessibleEditPart aEP = (AccessibleEditPart)sourceEP.getAdapter(AccessibleEditPart.class);
d399 6
a404 5
						aEP.getName( event );
						msg.append( " " ); //$NON-NLS-1$
						msg.append( PresentationResourceManager.getInstance().getString( "Accessible.Connection.From" ) ); //$NON-NLS-1$
						msg.append( " " ); //$NON-NLS-1$
						msg.append( event.result );
d409 2
a410 1
						AccessibleEditPart aEP = (AccessibleEditPart)targetEP.getAdapter(AccessibleEditPart.class);
d412 6
a417 5
						aEP.getName( event );
						msg.append( " " ); //$NON-NLS-1$
						msg.append( PresentationResourceManager.getInstance().getString( "Accessible.Connection.To" ) ); //$NON-NLS-1$
						msg.append( " " ); //$NON-NLS-1$
						msg.append( event.result );
d419 1
a419 1
					
d427 1
a427 2

	/** 
d435 1
a435 1
		
d440 2
a441 1
			Boolean val = (Boolean)getViewer().getProperty(RulerProvider.PROPERTY_RULER_VISIBILITY);
d445 2
a446 1
			val = (Boolean)getViewer().getProperty(SnapToGeometry.PROPERTY_SNAP_ENABLED);
d454 1
a454 1
				return (SnapToHelper)snapStrategies.get(0);
d458 1
a458 1
				ss[i] = (SnapToHelper)snapStrategies.get(i);
d461 1
a461 1
		
d463 2
a464 2
		
		if ( View.class.isAssignableFrom(key) && model instanceof View) {
a466 1
		
d468 1
a468 2
		if (model != null &&
			model instanceof View) {
d470 2
a471 1
			EObject semanticObject = ViewUtil.resolveSemanticElement((View)model);
d474 1
a474 1
			} else if (key.isInstance(model)){
d483 1
d488 3
a490 2
		if (getModel()!=null){
			View view = ViewUtil.getChildBySemanticHint((View)getModel(),semanticHint);
d492 2
a493 1
				return  (IGraphicalEditPart)getViewer().getEditPartRegistry().get(view);
d498 3
a500 1
	/* (non-Javadoc)
d504 1
a504 1
		if ( !isEditModeEnabled() ) {
d509 4
a512 2
		Command cmd = (Command)MEditingDomainGetter.getMEditingDomain((View)getModel()).runAsRead( new MRunnable() {
			public Object run() { 
d520 3
a522 1
	 * Convenience method returning the editpart's Diagram, the Diagam that owns the edit part 
d526 1
a526 1
		return (Diagram)getRoot().getContents().getModel();
d529 3
a531 1
	/* (non-Javadoc)
d535 2
a536 1
		for (EditPart parent = this; parent != null; parent = parent.getParent())
d541 1
a541 1
	
d543 3
a545 2
	 * Convenience method returning the editpart's edit domain.
	 * Same as calling <code>getRoot().getViewer().getEditDomain()</code>
d552 3
a554 2

	/* (non-Javadoc)
d563 1
d567 1
a567 1
		return ((View)getModel()).getChildren();
d569 1
a569 2
	
	
d571 5
a575 3
	 * Convenience method to retreive the value for the supplied poperty
	 * from the editpart's associated view element.
	 * @@param id the property id
d577 2
a578 1
	 * @@deprecated use {@@link #getStructuralFeatureValue(EStructuralFeature)} instead
d583 1
a583 1
	
d590 1
a590 1
		return ViewUtil.getStructuralFeatureValue((View) getModel(),feature);
a592 1

d594 4
a597 3
	 * try to resolve the semantic element and Return the resolven element; if the 
	 * element is unresolvable or null it will return null
	 * @@return non proxy EObject or NULL 
d600 3
a602 1
		return (EObject) MEditingDomainGetter.getMEditingDomain((View)getModel()).runAsRead( new MRunnable() {
d608 2
a609 2
	
	/** 
d625 3
a627 1
	 * @@return <code>View</code>, the associated view or null if there is no associated Notation View
d632 1
a632 1
			return (View)model;
d636 4
a639 1
	/** Handles the passed property changed event only if the editpart's view is not deleted */
d641 1
a641 1
		if(isActive())
d647 3
a649 1
	 * @@param event the property changed event
d652 2
a653 1
		if (event.getPropertyName().equals(Connection.PROPERTY_CONNECTION_ROUTER)) {
d659 10
a668 11
	 * Method reactivateSemanticModel.
	 * This method reactivates the edit part's emantic model by:
	 * 1- removing semantic listeners
	 * 2- adding semantic listeners if the semantic reference is resolvable
	 * 3- Refreshing it
	 * 
	 * This method is called in response to IView's Properties.ID_SEMANTICREF property change event
	 * However, it will only work under the following assumptions:
	 * 1- The old and new semantic models are compatible in their kind
	 * 2- The deltas between old and new semantic models do not affect notation
	 * 3- Connectors are not refereshed since they are maintained by the diagram
d676 1
a676 1
	
d679 1
a679 1
		if(theElement == null) {
d683 1
a683 1
		if(epBegin == null) {
d685 2
d688 1
a688 4
		else {
			epStart=epBegin;
		}
		
d690 1
a690 1
		
d694 1
a694 1
			if ((el != null)&& el.equals(theElement)) {
d715 2
a716 1
		LineStyle style = (LineStyle)  getPrimaryView().getStyle(NotationPackage.eINSTANCE.getLineStyle());
d718 2
a719 1
			setForegroundColor(PresentationResourceManager.getInstance().getColor(new Integer(style.getLineColor())));
d726 1
a726 1
		setVisibility(((View)getModel()).isVisible());
d731 3
a733 1
	 * @@param filterId	the filiter ID
d740 1
a740 1
		if (objects == null){
a742 1
			
d744 4
a747 5
		if (objects.length>2){
			PresentationListener.getInstance().
				removeNotificationListener((EObject) objects[0],
											 (EStructuralFeature) objects[1],
											 (NotificationListener) objects[2]);
d749 2
a750 3
			PresentationListener.getInstance().
				removeNotificationListener((EObject) objects[0],
					 				 (NotificationListener) objects[1]);
d757 3
a759 1
	 * @@param color	the color
d767 1
d770 2
a771 1
	 * @@deprecated use {@@link #setStructuralFeatureValue(Object, Object)} instead
d776 1
a776 1
	
d778 7
a784 4
	 * Sets the passed feature if possible on this editpart's view
	 * to the passed value.
	 * @@param feature the feature to use
	 * @@param value  the value of the property being set
d786 2
a787 1
	public void setStructuralFeatureValue(EStructuralFeature feature, Object value) {
d793 3
a795 1
	 * @@param vis	the new visibilty value
d805 3
a807 2
	 * This method adds all listeners to the notational world (views, figures, editpart...etc)
	 * Override this method to add more notational listeners down the hierarchy
d810 1
a810 1
		addListenerFilter("View", this, (View)getModel());//$NON-NLS-1$
d812 1
a812 2
			Connection.PROPERTY_CONNECTION_ROUTER,
			this);
d821 2
a822 4
		addListenerFilter(
			"SemanticModel",//$NON-NLS-1$
			this,
			resolveSemanticElement());
d826 3
a828 2
	 * This method removes all listeners to the notational world (views, figures, editpart...etc)
	 * Override this method to remove notational listeners down the hierarchy
d832 1
a832 2
			Connection.PROPERTY_CONNECTION_ROUTER,
			this);
d837 3
a839 2
	 * This method removes all listeners to the semantic world (IUMLElement...etc)
	 * Override this method to remove semantic listeners down the hierarchy
d854 6
a859 2
	 * Return a Map of all the appearance property ids supported by the edit part and its
	 * children.
d861 8
a868 15
	 * Each entry in the map is the factory hint of the edit part as key and a 
	 * dictionary of appearance properties  as
	 * values. The edit parts are the receiver itself and it's children.
	 * 
	 * For example, the connectable shape edit part with name, attribute, operation and
	 * shape compartments will return a map where:
	 * 1 entry: 
	 * 		connectable shape factory hint ->  dictionary:
	 * 										   Properties.ID_FONT  -> font data
	 * 										   Properties.ID_FONTCOLOR -> font color
	 * 										   Properties.ID_LINECOLOR -> line color
	 * 										   Properties.ID_FILLCOLOR -> fill color
	 * 2d entry: attribute compartment hint -> dictionary(empty)
	 * 3d entry: operation compartment hint -> dictionary(empty)
	 * 4d entry: shape compartment hint -> dictionary(empty)
d879 1
a879 1
	 * a static array of appearance property ids  applicable to the connectors
d881 4
a884 8
	protected static final String[] appearanceProperties =
		new String[] {
			Properties.ID_FONTNAME,
			Properties.ID_FONTSIZE,
			Properties.ID_FONTBOLD,
			Properties.ID_FONTITALIC,
			Properties.ID_FONTCOLOR,
			Properties.ID_LINECOLOR };
d888 3
a890 1
	 * @@param view , the view the edit part will own
d899 1
d908 3
a910 1
	/* (non-Javadoc)
d914 4
a917 2
		if (getSource() != null && getTarget() != null) 
			MEditingDomainGetter.getMEditingDomain((View)getModel()).runAsRead(new MRunnable() {
d919 7
a925 6
					ConnectionEditPart.super.refresh();
					EditPolicyIterator i = getEditPolicyIterator();
					while (i.hasNext()) {
						EditPolicy policy = i.next();
						if (policy instanceof GraphicalEditPolicyEx) {
							((GraphicalEditPolicyEx) policy).refresh();
d927 1
d929 1
a929 3
						return null; 
				}
			});
d933 1
a933 1
	 * Method getConnectorView.
a934 4
	 * @@return IConnectorView
	 */
	/**
	 * utility method to get the <code>Edge</code> view
d937 1
a937 1
	protected Edge getConnectorView() {
d945 1
a945 1
		return new SelectConnectorEditPartTracker(this);
d950 1
d954 1
a954 1
		return getConnectorView().getSource();
d959 1
d963 1
a963 1
		return getConnectorView().getTarget();
d967 2
a968 1
	 * installes a router on the edit part, depending on the <code>RoutingStyle</code>
d971 1
a971 2
		ConnectionLayerEx cLayer =
			(ConnectionLayerEx) getLayer(LayerConstants.CONNECTION_LAYER);
d973 2
a974 1
		RoutingStyle style = (RoutingStyle) ((View) getModel()).getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
d976 2
a977 2
			
			Routing routing = style.getRouting();			
d986 1
a986 1
					cLayer.getTreeRouter()); 
d988 1
a988 1
			
d998 3
a1000 2
		RelativeBendpoints bendpoints = (RelativeBendpoints) getConnectorView().getBendpoints();
		List modelConstraint = bendpoints.getPoints(); 
d1003 6
a1008 7
			org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint wbp =
				(org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint) modelConstraint.get(i);
			RelativeBendpoint rbp =
				new RelativeBendpoint(getConnectionFigure());
			rbp.setRelativeDimensions(
				new Dimension(wbp.getSourceX(), wbp.getSourceY()),
				new Dimension(wbp.getTargetX(), wbp.getTargetY()));
d1016 7
a1022 12
		if (getConnectionFigure().getConnectionRouter()
				instanceof ForestRouter) {
				installEditPolicy(
					EditPolicy.CONNECTION_BENDPOINTS_ROLE,
					new TreeConnectorBendpointEditPolicy());
				getConnectionFigure().setCursor(Cursors.CURSOR_SEG_MOVE);
			}
		else if (getConnectionFigure().getConnectionRouter()
			instanceof OrthogonalRouter) {
			installEditPolicy(
				EditPolicy.CONNECTION_BENDPOINTS_ROLE,
				new ConnectorLineSegEditPolicy());
d1024 3
a1026 5
		}
		else {
			installEditPolicy(
				EditPolicy.CONNECTION_BENDPOINTS_ROLE,
				new ConnectorBendpointEditPolicy());
d1043 3
a1045 3
		PolylineConnectionEx poly =
			((PolylineConnectionEx) getConnectionFigure());
		RoutingStyle style = (RoutingStyle)((View) getModel()).getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
d1048 1
a1048 1
	
d1065 4
a1068 4
		PolylineConnectionEx poly =
			((PolylineConnectionEx) getConnectionFigure());
		RoutingStyle style = (RoutingStyle) ((View) getModel()).getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
		
d1070 1
a1070 1
		JumpLinkType type = JumpLinkType.SEMICIRCLE_LITERAL;	
d1099 1
a1099 2
		PolylineConnectionEx poly =
			((PolylineConnectionEx) getConnectionFigure());
d1101 2
a1102 1
		RoutingStyle style = (RoutingStyle) ((View) getModel()).getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
d1104 1
a1104 1
	
d1107 1
a1107 1
	
d1112 3
a1114 1
	/* (non-Javadoc)
d1132 2
a1133 1
		FontStyle style = (FontStyle) getPrimaryView().getStyle(NotationPackage.eINSTANCE.getFontStyle());
d1135 4
a1138 5
			setFont(new FontData(
				style.getFontName(), 
				style.getFontHeight(), 
				(style.isBold() ? SWT.BOLD : SWT.NORMAL) | 
				(style.isItalic() ? SWT.ITALIC : SWT.NORMAL)));
d1143 7
a1149 9
	 * Sets the font to the label.
	 * This method could be overriden to change the font data of the font
	 * overrides typically look like this:
	 * 		super.setFont(
	 *		new FontData(
	 *			fontData.getName(),
	 *			fontData.getHeight(),
	 *			fontData.getStyle() <| &> SWT.????));
	 * @@param fontData the font data
d1153 1
a1153 2
			PresentationResourceManager.getInstance().getFont(
				Display.getDefault(),
d1158 3
a1160 1
	/* (non-Javadoc)
d1171 6
a1176 5
				if (element instanceof EStructuralFeature &&
					ViewUtil.isPropertySupported((View) getModel(),prob)){
					local_properties.put(
						getAppearancePropertyIDs()[i],
						getStructuralFeatureValue((EStructuralFeature)element));
d1179 1
a1179 3
			properties.put(
				((View) getModel()).getType(),
				local_properties);
d1190 3
a1192 2
	 * Returns an array of the appearance property ids applicable to the receiver.
	 * Fro this type it is  Properties.ID_FONT, Properties.ID_FONTCOLOR, Properties.ID_LINECOLOR 
d1194 2
a1195 1
	 * @@return - an array of the appearane property ids applicable to the receiver
d1202 3
a1204 2
	 * Perform a request by executing a command from the target editpart of the request
	 * For the Direct_Edit request, we need to show up an editor first
d1208 1
a1208 1
		if ( !isEditModeEnabled() ) {
d1229 3
a1231 1
	 * @@param request the direct edit request
d1234 7
a1240 5
		EditPart primaryChildEditPart = (EditPart)MEditingDomainGetter.getMEditingDomain((View)getModel()).runAsRead( new MRunnable()  {
			public Object run() {
				return getPrimaryChildEditPart();
			}
		});
a1253 1

d1260 1
a1260 1
		if ( ref == null ) {
d1263 1
a1263 1
		
d1267 1
a1267 2
			elementGuid,
			this);
d1275 1
a1275 2
			elementGuid,
			this);
d1282 2
a1283 1
		if (getSource() instanceof GraphicalEditPart && getTarget() instanceof GraphicalEditPart) {
d1291 1
d1299 4
a1302 3
	/** 
	 * check if there is a canonical edit policy installed on the edit part
	 * or not
d1304 1
a1304 1
	 * this editpart; otherwise <tt>false</tt>
d1309 2
a1310 2
	
	/** 
d1312 1
d1314 1
a1314 1
	 * <tt>false</tt> otherwise.
d1320 1
a1320 1
	/* 
d1324 1
a1324 1
		this.editableEditPart.disableEditMode();		
d1326 2
a1327 2
	
	/* 
d1333 2
a1334 2
	
	/* 
d1340 2
a1341 2
	
	/* 
d1345 1
a1345 1
		if ( !isEditModeEnabled()) {
d1348 1
a1348 1
		
d1351 2
a1352 2
	
	/* 
d1356 1
a1356 1
		if ( !isEditModeEnabled()) {
d1359 1
a1359 1
		
d1363 1
a1363 1
	/* 
d1367 1
a1367 1
		if ( !isEditModeEnabled()) {
d1370 1
a1370 1
		
d1373 2
a1374 1
	/* 
d1378 1
a1378 1
		if ( !isEditModeEnabled()) {
d1384 1
a1384 1
	
d1387 1
d1390 1
a1390 1
	public EditPart getPrimaryChildEditPart(){
d1395 4
a1398 2
	
	/* (non-Javadoc)
d1407 13
a1419 14
	
		/*
	 * ATTENTION!!!!: Do not remove, see below. Only update based on newer GEF framework
	 *  
	 * This function is "copied" from GEF for the following reason:
	 * GEF does not check if the connector's source or target are the same as the editpart
	 * before setting them to <code>null</code> which causes the following usecase to currently fail:
	 * 
	 * "in a model transaction, view's source connectors are detached, a new view is
	 * created, and the connectors are attached to it, then the old view is destroyed"
	 * 
	 * The reason for the problem is the filtering of Deleted/Uncreated object's events in the
	 * PresentationListener which prevents the first connector detach event from coming and 
	 * avoiding the problem
d1421 6
a1426 1
	 * TODO: Remove this override as soon as the bugzilla <Bug 110476> is resolved or the event filtering is removed
d1439 1
a1439 2
			((EditPart)_children.get(i))
				.removeNotify();
d1444 1
a1444 1
			ConnectionEditPart conn = (ConnectionEditPart)conns.get(i);
d1450 1
a1450 1
			ConnectionEditPart conn = (ConnectionEditPart)conns.get(i);
d1455 4
a1458 2
	
	/* (non-Javadoc)
d1462 1
a1462 1
		if (isActive()){
d1475 6
a1480 5
		if (NotationPackage.eINSTANCE.getView_PersistedChildren().equals(feature)||
			NotationPackage.eINSTANCE.getView_TransientChildren().equals(feature)) {
				refreshChildren();
		}
		else if (NotationPackage.eINSTANCE.getView_Visible().equals(feature)) {
d1483 6
a1488 4
			// However, we need to verify that the event belongs to this editpart's view
			// cannot do it now since property's source is (IView for RMS) and (IUMLView for EMF)
		}
		else if (NotationPackage.eINSTANCE.getRoutingStyle_Routing().equals(feature)) {
d1490 12
a1501 7
		}
		else if (NotationPackage.eINSTANCE.getRoutingStyle_Smoothness().equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_AvoidObstructions().equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_ClosestDistance().equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkStatus().equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkType().equals(feature)
			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinksReverse().equals(feature)) {
d1503 2
a1504 2
		}
		else if (NotationPackage.eINSTANCE.getLineStyle_LineColor().equals(feature)) {
d1506 3
a1508 3
			setForegroundColor(PresentationResourceManager.getInstance().getColor(c));
		}
		else if (NotationPackage.eINSTANCE.getRelativeBendpoints_Points().equals(feature)) {
d1510 3
a1512 3
		}
		else if (event.getFeature() == NotationPackage.eINSTANCE.getView_Element()
		 && ((EObject)event.getNotifier()) == getNotationView())
d1515 2
a1516 2
		else if (event.getEventType() == EventTypes.UNRESOLVE 
				&& event.getNotifier() == ((View) getModel()).getElement())
@


1.11
log
@bugzilla 111142 gmf-head sshaw 051003 Performance regression fix, contributrd by Mohammed mostafa
@
text
@d1370 3
a1372 3
		List children = getChildren();
		for (int i = 0; i < children.size(); i++)
			((EditPart)children.get(i))
@


1.10
log
@Bugzilla 109092: gmf_head sshaw 050923 : fixing build errors
@
text
@d219 1
a219 1
		PresentationListener.getInstance().addNotificationListener(element,listener);
@


1.9
log
@bugzilla 110478 gmf-head sshaw Introduce a view refactoring helper based on semantic refactoring

Contributed by: Maged Elaasar
@
text
@d56 1
a56 1
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationEvent;
a57 1
import org.eclipse.gmf.runtime.diagram.core.listener.PropertyChangeNotifier;
d73 1
a77 1
import org.eclipse.gmf.runtime.diagram.ui.properties.Properties;
a108 3
/*
 * @@canBeSeenBy %partners
 */
d116 1
a116 1
	implements IGraphicalEditPart, PropertyChangeListener, IContainedEditPart, IPrimaryEditPart {
a169 20
	/**
	 * Adds a listener filter by adding the given listener to a passed notifier
	 * 
	 * @@param filterId A unique filter id (within the same editpart instance)
	 * @@param listener A listener instance
	 * @@param notifier An element notifer to add the listener to
	 */
	protected void addListenerFilter(
		String filterId,
		PropertyChangeListener listener,
		PropertyChangeNotifier notifier) {

		if (notifier == null)
			return;

		Assert.isNotNull(filterId);
		Assert.isNotNull(listener);

		if (listenerFilters == null)
			listenerFilters = new HashMap();
a170 3
		notifier.addPropertyChangeListener(listener);
		listenerFilters.put(filterId, new Object[] { notifier, listener });
	}
a177 2
	 * @@deprecated use {@@link ConnectionEditPart#addListenerFilter(String, PropertyChangeListener, EObject)} or
	 * {@@link ConnectionEditPart#addListenerFilter(String, PropertyChangeListener, EObject,EStructuralFeature )}
d181 1
a181 1
		PropertyChangeListener listener,
d193 1
a193 1
		PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d206 1
a206 1
		PropertyChangeListener listener,
d219 1
a219 1
		PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d290 1
a290 1
						removePropertyChangeListener((EObject)obj[0],(EStructuralFeature) obj[1],(PropertyChangeListener) obj[2]);
d292 1
a292 4
					if (obj[0] instanceof PropertyChangeNotifier)
						((PropertyChangeNotifier) obj[0]).removePropertyChangeListener((PropertyChangeListener) obj[1]);
					else
						PresentationListener.getInstance().removePropertyChangeListener((EObject)obj[0],(PropertyChangeListener) obj[1]);
d602 1
a602 14
		if (event.getPropertyName().equals(Properties.ID_PERSISTED_CHILDREN)||
			event.getPropertyName().equals(Properties.ID_TRANSIENT_CHILDREN)) {
			refreshChildren();
		}
		else if (event.getPropertyName().equals(Properties.ID_ISVISIBLE)) {
			setVisibility(((Boolean) event.getNewValue()).booleanValue());
		// Reactivating in response to semantic model reference change
		// However, we need to verify that the event belongs to this editpart's view
		// cannot do it now since property's source is (IView for RMS) and (IUMLView for EMF)
		}
		else if (
			event.getPropertyName().equals(Properties.ID_ROUTING)
				|| event.getPropertyName().equals(
					Connection.PROPERTY_CONNECTION_ROUTER)) {
a604 20
		else if (
			event.getPropertyName().equals(Properties.ID_SMOOTHNESS)
				|| event.getPropertyName().equals(Properties.ID_AVOIDOBSTRUCTIONS)
				|| event.getPropertyName().equals(Properties.ID_CLOSESTDISTANCE)
				|| event.getPropertyName().equals(Properties.ID_JUMPLINKS_STATUS)
				|| event.getPropertyName().equals(Properties.ID_JUMPLINKS_TYPE)
				|| event.getPropertyName().equals(
					Properties.ID_JUMPLINKS_REVERSE)) {
			refreshVisuals();
		}
		else if (event.getPropertyName().equals(Properties.ID_LINECOLOR)) {
			Integer c = (Integer) event.getNewValue();
			setForegroundColor(PresentationResourceManager.getInstance().getColor(c));
		}
		else if (event.getPropertyName().equals(Properties.ID_BENDPOINT)) {
			refreshBendpoints();
		}
		else if (event instanceof NotificationEvent) {
			handleNotificationEvent((NotificationEvent) event);
		}
a606 17
	
	/**
	 * Handles the supplied notification event.
	 * @@param e the event to handle
	 */
	protected void handleNotificationEvent(NotificationEvent e) {
		Notification event = e.getNotification();
		
		if (event.getFeature() == NotationPackage.eINSTANCE.getView_Element()
		 && ((EObject)event.getNotifier()) == getNotationView())
			handleMajorSemanticChange();

		else if (event.getEventType() == EventTypes.UNRESOLVE 
				&& event.getNotifier() == ((View) getModel()).getElement())
			handleMajorSemanticChange();
	}
		
d694 1
a694 1
				removePropertyChangeListener((EObject) objects[0],
d696 1
a696 1
											 (PropertyChangeListener) objects[2]);
d698 3
a700 10
			// check if it uses a PropertyChangeNotifier or not the block inside the if 
			// statement should be removed as soon as the deprecation warnings are fixed
			if (objects[0] instanceof PropertyChangeNotifier){
				((PropertyChangeNotifier) objects[0]).removePropertyChangeListener(
					(PropertyChangeListener) objects[1]);
			} else {
				PresentationListener.getInstance().
					removePropertyChangeListener((EObject) objects[0],
					 				 (PropertyChangeListener) objects[1]);
			}
d1344 2
a1345 2

	/*
a1442 1
	
@


1.8
log
@Bugzilla 109092: gmf_head sshaw 050923 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d56 1
a56 1
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener;
d58 1
a73 1
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
d78 1
d110 3
d120 1
a120 1
	implements IGraphicalEditPart, PropertyChangeListener, IContainedEditPart, IPrimaryEditPart, NotificationListener {
d174 20
d195 3
d205 2
d210 1
a210 1
		NotificationListener listener,
d222 1
a222 1
		PresentationListener.getInstance().addNotificationListener(element,listener);
d235 1
a235 1
		NotificationListener listener,
d248 1
a248 1
		PresentationListener.getInstance().addNotificationListener(element,listener);
d319 1
a319 1
						removeNotificationListener((EObject)obj[0],(EStructuralFeature) obj[1],(NotificationListener) obj[2]);
d321 4
a324 1
					PresentationListener.getInstance().removeNotificationListener((EObject)obj[0],(NotificationListener) obj[1]);
d634 14
a647 1
		if (event.getPropertyName().equals(Connection.PROPERTY_CONNECTION_ROUTER)) {
d650 20
d672 17
d776 1
a776 1
				removeNotificationListener((EObject) objects[0],
d778 1
a778 1
											 (NotificationListener) objects[2]);
d780 10
a789 3
			PresentationListener.getInstance().
				removeNotificationListener((EObject) objects[0],
					 				 (NotificationListener) objects[1]);
d1433 45
d1532 1
@


1.7
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d33 1
d85 1
d532 6
a537 2
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getPropertyValue(java.lang.Object)
d542 10
d713 6
d722 10
d1118 3
a1120 1
				if (ViewUtil.isPropertySupported((View) getModel(),prob))
d1123 2
a1124 1
						getPropertyValue(prob));
@


1.6
log
@Bugzilla 109618: gmf_head mmostafa 050915 :  Remove the deprecated view facade interfaces and classes
@
text
@d55 1
a55 1
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationEvent;
a56 1
import org.eclipse.gmf.runtime.diagram.core.listener.PropertyChangeNotifier;
d72 1
a76 1
import org.eclipse.gmf.runtime.diagram.ui.properties.Properties;
a106 3
/*
 * @@canBeSeenBy %partners
 */
d114 1
a114 1
	implements IGraphicalEditPart, PropertyChangeListener, IContainedEditPart, IPrimaryEditPart {
a167 20
	/**
	 * Adds a listener filter by adding the given listener to a passed notifier
	 * 
	 * @@param filterId A unique filter id (within the same editpart instance)
	 * @@param listener A listener instance
	 * @@param notifier An element notifer to add the listener to
	 */
	protected void addListenerFilter(
		String filterId,
		PropertyChangeListener listener,
		PropertyChangeNotifier notifier) {

		if (notifier == null)
			return;

		Assert.isNotNull(filterId);
		Assert.isNotNull(listener);

		if (listenerFilters == null)
			listenerFilters = new HashMap();
a168 3
		notifier.addPropertyChangeListener(listener);
		listenerFilters.put(filterId, new Object[] { notifier, listener });
	}
a175 2
	 * @@deprecated use {@@link ConnectionEditPart#addListenerFilter(String, PropertyChangeListener, EObject)} or
	 * {@@link ConnectionEditPart#addListenerFilter(String, PropertyChangeListener, EObject,EStructuralFeature )}
d179 1
a179 1
		PropertyChangeListener listener,
d191 1
a191 1
		PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d204 1
a204 1
		PropertyChangeListener listener,
d217 1
a217 1
		PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d288 1
a288 1
						removePropertyChangeListener((EObject)obj[0],(EStructuralFeature) obj[1],(PropertyChangeListener) obj[2]);
d290 1
a290 4
					if (obj[0] instanceof PropertyChangeNotifier)
						((PropertyChangeNotifier) obj[0]).removePropertyChangeListener((PropertyChangeListener) obj[1]);
					else
						PresentationListener.getInstance().removePropertyChangeListener((EObject)obj[0],(PropertyChangeListener) obj[1]);
d586 1
a586 14
		if (event.getPropertyName().equals(Properties.ID_PERSISTED_CHILDREN)||
			event.getPropertyName().equals(Properties.ID_TRANSIENT_CHILDREN)) {
			refreshChildren();
		}
		else if (event.getPropertyName().equals(Properties.ID_ISVISIBLE)) {
			setVisibility(((Boolean) event.getNewValue()).booleanValue());
		// Reactivating in response to semantic model reference change
		// However, we need to verify that the event belongs to this editpart's view
		// cannot do it now since property's source is (IView for RMS) and (IUMLView for EMF)
		}
		else if (
			event.getPropertyName().equals(Properties.ID_ROUTING)
				|| event.getPropertyName().equals(
					Connection.PROPERTY_CONNECTION_ROUTER)) {
a588 20
		else if (
			event.getPropertyName().equals(Properties.ID_SMOOTHNESS)
				|| event.getPropertyName().equals(Properties.ID_AVOIDOBSTRUCTIONS)
				|| event.getPropertyName().equals(Properties.ID_CLOSESTDISTANCE)
				|| event.getPropertyName().equals(Properties.ID_JUMPLINKS_STATUS)
				|| event.getPropertyName().equals(Properties.ID_JUMPLINKS_TYPE)
				|| event.getPropertyName().equals(
					Properties.ID_JUMPLINKS_REVERSE)) {
			refreshVisuals();
		}
		else if (event.getPropertyName().equals(Properties.ID_LINECOLOR)) {
			Integer c = (Integer) event.getNewValue();
			setForegroundColor(PresentationResourceManager.getInstance().getColor(c));
		}
		else if (event.getPropertyName().equals(Properties.ID_BENDPOINT)) {
			refreshBendpoints();
		}
		else if (event instanceof NotificationEvent) {
			handleNotificationEvent((NotificationEvent) event);
		}
a590 17
	
	/**
	 * Handles the supplied notification event.
	 * @@param e the event to handle
	 */
	protected void handleNotificationEvent(NotificationEvent e) {
		Notification event = e.getNotification();
		
		if (event.getFeature() == NotationPackage.eINSTANCE.getView_Element()
		 && ((EObject)event.getNotifier()) == getNotationView())
			handleMajorSemanticChange();

		else if (event.getEventType() == EventTypes.UNRESOLVE 
				&& event.getNotifier() == ((View) getModel()).getElement())
			handleMajorSemanticChange();
	}
		
d678 1
a678 1
				removePropertyChangeListener((EObject) objects[0],
d680 1
a680 1
											 (PropertyChangeListener) objects[2]);
d682 3
a684 10
			// check if it uses a PropertyChangeNotifier or not the block inside the if 
			// statement should be removed as soon as the deprecation warnings are fixed
			if (objects[0] instanceof PropertyChangeNotifier){
				((PropertyChangeNotifier) objects[0]).removePropertyChangeListener(
					(PropertyChangeListener) objects[1]);
			} else {
				PresentationListener.getInstance().
					removePropertyChangeListener((EObject) objects[0],
					 				 (PropertyChangeListener) objects[1]);
			}
d1309 54
@


1.5
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a54 1
import org.eclipse.gmf.runtime.diagram.core.internal.view.IView;
a73 1
import org.eclipse.gmf.runtime.diagram.ui.internal.util.IncarnationUtil;
a129 5
	 * @@deprecated
	 */
	private IView incarnatedView = null;

	/**
d574 1
a574 1
	protected EObject resolveSemanticElement() {
a595 10
	/** 
	 * Return the editpart's associated view.
	 * Same as calling <code>(IView)getModel()</code>
	 */ 
	public IView getView() {
		if (incarnatedView==null)
			incarnatedView = IncarnationUtil.incarnateView((View)getModel());
		return incarnatedView;
	}
	
@


1.4
log
@Bugzilla109092 : gmf_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2003.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.3
log
@Bugzilla109092 : rmp_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d208 2
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d32 1
a50 8
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.SWT;
import org.eclipse.swt.accessibility.AccessibleEvent;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.IActionFilter;

d58 1
a78 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d101 7
d122 1
a122 1

d172 2
a173 2
			addListenerFilter("SemanticProxy", this, PresentationListener.getNotifier(semanticProxy)); //$NON-NLS-1$
			}
d201 51
d318 9
a326 1
				((PropertyChangeNotifier) obj[0]).removePropertyChangeListener((PropertyChangeListener) obj[1]);
d766 1
a766 1
		if (objects == null)
d768 2
d771 17
a787 3
		((PropertyChangeNotifier) objects[0]).removePropertyChangeListener(
			(PropertyChangeListener) objects[1]);

d819 1
a819 1
		addListenerFilter("View", this, ViewUtil.getPropertyChangeNotifier((View)getModel()));//$NON-NLS-1$
d834 1
a834 1
			PresentationListener.getNotifier(resolveSemanticElement()));
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d96 12
a107 12
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.Edge;
import com.ibm.xtools.notation.FontStyle;
import com.ibm.xtools.notation.JumpLinkStatus;
import com.ibm.xtools.notation.JumpLinkType;
import com.ibm.xtools.notation.LineStyle;
import com.ibm.xtools.notation.NotationPackage;
import com.ibm.xtools.notation.RelativeBendpoints;
import com.ibm.xtools.notation.Routing;
import com.ibm.xtools.notation.RoutingStyle;
import com.ibm.xtools.notation.Smoothness;
import com.ibm.xtools.notation.View;
d939 2
a940 2
			com.ibm.xtools.notation.datatype.RelativeBendpoint wbp =
				(com.ibm.xtools.notation.datatype.RelativeBendpoint) modelConstraint.get(i);
@

