head	1.3;
access;
symbols
	v20081023-2107:1.3
	v20081022-1925:1.3
	v20081022-1005:1.3
	v20081020-0700:1.3
	v20080917-1925:1.3
	v20080916-2008:1.3
	v20080911-1728:1.3
	v20080911-1506:1.3
	v20080910-1520:1.3
	v20080910-1510:1.3
	v20080903-1520:1.3
	v20080903-1510:1.3
	v20080813-1510:1.3
	v20080811-1546:1.3
	v20080731-1520:1.3
	v20080725-1738:1.3
	v20080723-2246:1.3
	v20080723-2232:1.3
	v20080723-1700:1.3
	v20080722-1827:1.3
	v20080718-1700:1.3
	v20080718-1731:1.3
	v20080716-1600:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.6
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080610-1132:1.3
	v20080603-1553:1.3
	v20080527-1255:1.3
	v20080527-1151:1.3
	v20080516-1748:1.3
	v20080516-1143:1.3
	v20080512-1200:1.3
	v20080503-1740:1.3
	v20080501-2127:1.3
	v20080501-1739:1.3
	m20080429-1543:1.3
	v20080425-1959:1.3
	v20080417-1610:1.3
	v20080407-2250:1.3
	v20080407-0930:1.3
	v20080404-1111:1.3
	v20080328-1605:1.3
	v20080322-0000:1.3
	v20080222-1200:1.3
	v20080201-2010:1.3
	v20080201-0201:1.3
	v20080118-1129:1.3
	v20080114-2222:1.3
	v20080114-1111:1.3
	v20080107-1111:1.3
	v20071222-1111:1.3
	v20071214-1111:1.3
	v20071130-1111:1.3
	v20071124-0000:1.3
	v20071112-0000:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070915-0000:1.3
	v20070903-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.4
	R2_0:1.3
	R4_20:1.3
	v20070621-0000:1.3
	RC3_20:1.3
	v20070614-1400:1.3
	v20070608-1300:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070525-1500:1.3
	v20070518-1300:1.3
	bugzilla111892_group_support:1.3.0.2
	Root_bugzilla111892_group_support:1.3
	v20070504-1000:1.3
	v20070420-1000:1.3
	v20070413-1300:1.3
	v20070330-1300:1.3
	v20060330-1300:1.3
	v20070322-1100:1.3
	v20060316-0600:1.3
	v20070221-1500:1.3
	v20070208-1800:1.3
	v20070202-0200:1.2.2.6
	v20070119-1200:1.2.2.6
	v20070111-0800:1.2.2.6
	v20070105-1200:1.2.2.6
	v20070103-0300:1.3
	M4_20:1.3
	v20061218-1500:1.2.2.6
	v20061218-1200:1.3
	v20061214-0000:1.3
	M3_20:1.3
	v20061117-0800:1.3
	v20061027-1200:1.2.2.6
	v20061013-1330:1.3
	v20061012-1100:1.2.2.6
	v20060925-1700:1.2.2.6
	v20060919-0800:1.2.2.6
	v20060907-1100:1.2.2.5
	M1_20:1.2
	v20060831-1500:1.2.2.4
	v20060824-1600:1.2.2.4
	v20060817-1500:1.2.2.4
	v20060810-1700:1.2.2.4
	v20060803-1200:1.2.2.4
	v20060728-0500:1.2.2.2
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1400:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060530-1930:1.2
	v20060526-1200:1.2
	v20060519-0800:1.2
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1
	I20060216-1945:1.1
	I20060210-1715:1.1
	I20060209-1815:1.1
	I20060203-0830:1.1
	I20060202-1415:1.1
	I20060129-1145:1.1
	I20060127-0900:1.1
	I20060120-1530:1.1
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1
	I20060105-1630:1.1
	I20051230-1230:1.1
	I20051223-1100:1.1
	I20051217-0925:1.1
	I20051208-2000:1.1
	I20051201-1800:1.1;
locks; strict;
comment	@# @;


1.3
date	2006.10.03.15.02.04;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.13.20.05.16;	author mmostafa;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.12.01.15.31.51;	author mmostafa;	state Exp;
branches;
next	;

1.2.2.1
date	2006.07.26.20.06.00;	author sshaw;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2006.07.27.21.36.10;	author mmostafa;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2006.07.28.16.17.33;	author mmostafa;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2006.07.28.20.40.45;	author sshaw;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2006.09.06.21.15.25;	author mmostafa;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2006.09.13.16.43.39;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.3
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editparts;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.gef.EditPart;
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationUtil;
import org.eclipse.gmf.runtime.notation.DrawerStyle;
import org.eclipse.gmf.runtime.notation.Filtering;
import org.eclipse.gmf.runtime.notation.FilteringStyle;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.Sorting;
import org.eclipse.gmf.runtime.notation.SortingDirection;
import org.eclipse.gmf.runtime.notation.SortingStyle;
import org.eclipse.gmf.runtime.notation.View;

/**
 * A List compartment Edit part that contains semantic edit parts. A semantic
 * edit part is an edit part that controls a semantic element, it does not
 * control a Notation <code>View<code>. 
 * This list compartment is canonical by default, to turn off the canonical 
 * support just override the isCanonicalEnabled and return false
 * 
 * To convert your List compartment Edit Part to a semantic List compartment, make the Edit Part 
 * extends <code>SemanticListCompartmentEditPart</code> then implement the abstrtact methods:
 *  
 *  semanticChildAdded(EObject child,int index)
 *   Which will be called when a semantic child is added 
 *  And, getSemanticChildrenList()
 *   Which returns a list of all semantic children inside this editpart's model
 *   
 * Then on the EditPart's you add to this list make sure thathasNotationView 
 * returns <code>false</code> 
 *   
 * @@author mmostafa
 */

abstract public class SemanticListCompartmentEditPart
	extends ListCompartmentEditPart {
	
	/**
	 * constructor
	 * @@param model the mdoel controlled by this edit part
	 */
	public SemanticListCompartmentEditPart(EObject model) {
		super(model);
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#refreshChildren()
	 */
	protected void refreshChildren() {
		int i;
		GraphicalEditPart editPart;		
		List modelObjects = getModelChildren();
		List _children = getChildren();
		
		if ((modelObjects.size() == 0) && (_children.size() == 0)) {
			return;
		}
		
		Map modelToEditPart = new HashMap();
		for (i = 0; i < _children.size(); i++) {
			editPart = (GraphicalEditPart)_children.get(i);
			modelToEditPart.put(editPart.basicGetModel(), editPart);
		}

		

		for (i = 0; i < modelObjects.size(); i++) {
			EObject element  = (EObject)modelObjects.get(i);
			//Do a quick check to see if editPart[i] == model[i]
			if (i < _children.size()
				&& (((GraphicalEditPart)_children.get(i)).basicGetModel()) == element)
					continue;

			//Look to see if the EditPart is already around but in the wrong location
			editPart = (GraphicalEditPart)modelToEditPart.get(element);

			if (editPart != null)
				reorderChild (editPart, i);
			else {
				//An editpart for this model doesn't exist yet.  Create and insert one.
				semanticChildAdded(element,i);
			}
		}
		List trash = new ArrayList();
		for (; i < _children.size(); i++)
			trash.add(_children.get(i));
		for (i = 0; i < trash.size(); i++) {
			EditPart ep = (EditPart)trash.get(i);
			removeChild(ep);
		}
	}


	/**
	 * @@param child
	 */
	protected void semanticChildRemoved(EObject child){
        if (children==null)
            return;
        for (Iterator iter = children.iterator(); iter.hasNext();) {
			GraphicalEditPart ep = (GraphicalEditPart) iter.next();
			if (ep.basicGetModel().equals(child)){
				removeChild(ep);
				break;
			}
		}
	}
	
	/**
	 * Updates the set of children views so that it
	 * is in sync with the semantic children. This method is called 
	 * in response to notification from the model.
	 * <P>
	 * The update is performed by comparing the exising views with the set of
	 * semantic children returned from {@@link #getViewChildren()}. Views whose
	 * semantic element no longer exists are {@@link #deleteViews(Iterator) removed}. 
	 * New semantic children have their View {@@link  #createViews(List)
	 * created}.  Subclasses must override <code>getSemanticChildren()</code>.
	 * <P>
	 * Unlike <code>AbstractEditPart#refreshChildren()</code>, this refresh will not
	 * reorder the view list to ensure both it and the semantic children are
	 * in the same order since it is possible that this edit policy will handle
	 * a specifc subset of the host's views.  
	 * <P>
	 * The host is refreshed if a view has created or deleted as a result of this
	 * refresh.
	 */
	protected void refreshSemanticChildren() {
		if (!isCanonicalEnabled())
			return ; 
		// Don't try to refresh children if the semantic element
		// cannot be resolved.
		if (resolveSemanticElement() == null) {
			return;		
		}
		
		//
		// current EditParts
		List editPartsChildren = getChildren();
		List modelChildren = getModelChildren();
		if ((editPartsChildren.size() == 0) && (modelChildren.size() == 0)) {
			return;
		}		
		
		List semanticChildren = new ArrayList(modelChildren);
		
		//View viewChild;
		EObject semanticChild;
				
		

		Iterator childrenIT = editPartsChildren.iterator();		
		while( childrenIT.hasNext() ) {
			GraphicalEditPart eP = (GraphicalEditPart)childrenIT.next();
			semanticChild = (EObject)eP.basicGetModel();
			semanticChildren.remove(semanticChild);
		}
		
		//
		// create a view for each remaining semantic element.
		if ( !semanticChildren.isEmpty()) {
			for (Iterator iter = semanticChildren.iterator(); iter.hasNext();) {
				EObject element = (EObject) iter.next();
				semanticChildAdded(element,-1);
			}
		}
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gef.EditPart#activate()
	 */
	public void activate() {
		super.activate();
		refreshSemanticChildren();
	}
	
	/**
	 * This method will be called when a child is added to the
	 * EditPart's model id Canonical is enabled
	 * @@param child	the child being added, the index where its edit part should be created 
	 * @@param index
	 */
	abstract protected void semanticChildAdded(EObject child,int index);
	
	/**
	 * Returns a list of all semantic children inside this editpart's model
	 * @@return
	 */
	abstract protected List getSemanticChildrenList();


	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart#handleNotificationEvent(org.eclipse.emf.common.notify.Notification)
	 */
	protected void handleNotificationEvent(Notification event) {
		Object feature = event.getFeature();
		if (hasModelChildrenChanged(event)){
			semanticChildrenListChanged(event);
		}
		else if ((NotationPackage.eINSTANCE.getDrawerStyle_Collapsed() == feature ||
				  NotationPackage.eINSTANCE.getView_Visible() == feature&& 
			       !event.getNewBooleanValue())||
			      (NotationPackage.eINSTANCE.getView_Visible() == feature && 
				   event.getNewBooleanValue())){
			refreshSemanticChildren();
		}
		super.handleNotificationEvent(event);
	}
	
	/**
	 * called by the <code>handlePropertyChangeEvent</code> when the semantic children list 
	 * is changed, then this method will check if the change was add or delete of an element
	 * and calls either <code>semanticChildAdded</code> or <code>semanticChildDeleted</code>
	 * this could be used to implement a canonical list without a canonical edit policy
	 * @@param evt
	 */
	protected void semanticChildrenListChanged(Notification event) {
		if (isCanonicalEnabled()){
			if (NotificationUtil.isElementAddedToSlot(event) ||
				NotificationUtil.isMove(event)){
				refreshChildren();
			}
			else if(NotificationUtil.isElementRemovedFromSlot(event) &&
				event.getOldValue() instanceof  EObject){
				semanticChildRemoved((EObject)event.getOldValue());
			
			}
		}else if(NotificationUtil.isElementRemovedFromSlot(event) &&
				event.getOldValue() instanceof  EObject &&
				!getChildren().isEmpty()){
				semanticChildRemoved((EObject)event.getOldValue());
		}
	}
	
	/**
     * indicated if canonical is enabled or not Canonical is disabled if the
     * edit part's view is collapsed or hidden
     * 
     * @@return
     */
    protected boolean isCanonicalEnabled() {
        DrawerStyle dstyle = (DrawerStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.DRAWER_STYLE);
        boolean isCollapsed = dstyle == null ? false
            : dstyle.isCollapsed();

        if (isCollapsed) {
            return false;
        }

        return ((View) getModel()).isVisible();
    }
	
	/**
     * indicated if canonical is enabled or not Canonical is disabled if the
     * edit part's view is collapsed or hidden
     * 
     * @@return
     */
    public boolean isCanonicalOn() {
        return isCanonicalEnabled();
    }

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getSortedChildren()
	 */
	protected List getSortedChildren() {
		SortingStyle style = (SortingStyle)  ((View)getModel()).getStyle(NotationPackage.eINSTANCE.getSortingStyle());

		if (style != null) {
			Sorting sorting = style.getSorting();
			if (Sorting.NONE_LITERAL == sorting) {
				
				return getSemanticChildrenList();
				
			} else if (Sorting.MANUAL_LITERAL == sorting) {
	
				List allChildren = getSemanticChildrenList();
				// Return the empty list if the model children have not yet been
				// created.
				if (allChildren.isEmpty())
					return allChildren;
				
				List sortedChildren = style.eIsSet(NotationPackage.eINSTANCE.getSortingStyle_SortedObjects())
					? style.getSortedObjects() 
					: Collections.EMPTY_LIST;
	
				List sorted = new ArrayList();
				
				// Get the corresponding views...
				Iterator i = sortedChildren.iterator();
				while(i.hasNext()) {
					EObject eObject = (EObject) i.next();
					if (allChildren.contains(eObject))
						sorted.add(eObject);
				}	
				
				// Add any remaining model children to the end
				for (int j = 0; j < allChildren.size(); j++) {
					EObject element = (EObject) allChildren.get(j);
					if (!sorted.contains(element))
						sorted.add(element);
				}
				
				return sorted;
				
			} else if (Sorting.AUTOMATIC_LITERAL == sorting) {
				Map sortingKeys = style.eIsSet(NotationPackage.eINSTANCE.getSortingStyle_SortingKeys())
					? style.getSortingKeys() 
					: Collections.EMPTY_MAP;
				return getChildrenSortedBy(sortingKeys);
			}
		}
		
		return getSemanticChildrenList();		
	}
	
	/**
	 * Returns the model children sorted by the order specified by Properties.ID_SORTING_KEYS.
	 * This is used to support dynamic list compartment sorting.
	 * @@param sortingKeys
	 * @@return the model children sorted
	 */
	protected List getChildrenSortedBy(Map sortingKeys) {
		List allChildren = new ArrayList(getSemanticChildrenList());
		// Currently only one sorting key is supported.
		if (sortingKeys != null && !sortingKeys.isEmpty()) {
			Collection keySet = sortingKeys.keySet();
			Iterator i = keySet.iterator();
			String name = (String) i.next();
			SortingDirection direction = (SortingDirection) sortingKeys.get(name);
			
			Comparator comparator = getComparator(name, direction);
			
			if (comparator != null)
				Collections.sort(allChildren, getComparator(name, direction));									
		} 
		return allChildren;
	}


	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getFilteredChildren()
	 */
	protected List getFilteredChildren() {
		Object model = getModel();
		if (model instanceof View){
			View view = (View)model;
			FilteringStyle style = (FilteringStyle)  view.getStyle(NotationPackage.eINSTANCE.getFilteringStyle());
			if (style != null) {
				Filtering filtering = style.getFiltering();
				if (Filtering.NONE_LITERAL == filtering) {
					
					return Collections.EMPTY_LIST;
					
				} else if (Filtering.MANUAL_LITERAL == filtering) {
					
					List filteredChildren = style.eIsSet(NotationPackage.eINSTANCE.getFilteringStyle_FilteredObjects())
						? style.getFilteredObjects() 
						: Collections.EMPTY_LIST;
					return filteredChildren;	
				
				} else if (Filtering.AUTOMATIC_LITERAL == filtering) {
					List filteringKeys = style.eIsSet(NotationPackage.eINSTANCE.getFilteringStyle_FilteringKeys())
						? style.getFilteringKeys() 
						: Collections.EMPTY_LIST;
					return getChildrenFilteredBy(filteringKeys);
				}
			}
		}
		return Collections.EMPTY_LIST;
	}
	
	public boolean isCanonical() {
        return true;
    }
	
}
@


1.2
log
@bugzilla 135888 gmf-head mmostafa 060413 NPE in SemanticListCompartmentEditPart when Child Destroyed
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
d37 2
a38 2
 * A List compartment Edit part that contains semantic edit parts.
 * A semantic edit part is an edit part that controls a semantic element, it does not 
d73 8
a80 1
		GraphicalEditPart editPart;
a81 2
		List _children = getChildren();

d87 1
a87 1
		List modelObjects = getModelChildren();
d159 10
d172 1
a172 4
		//
		// current EditParts
		List editPartsChildren = getChildren();
		List semanticChildren = new ArrayList(getModelChildren());
d174 1
a174 2
		Iterator childrenIT = editPartsChildren.iterator();
		List orphaned = new ArrayList();
d178 1
a178 6
			if ( semanticChildren.contains(semanticChild) ) {
				semanticChildren.remove(semanticChild);
			}
			else {
				orphaned.add(eP);
			}
d240 6
a245 7
		if (!isCanonicalEnabled())
			return;
		if (NotificationUtil.isElementAddedToSlot(event) ||
			NotificationUtil.isMove(event)){
			refreshChildren();
		}
		else if(NotificationUtil.isElementRemovedFromSlot(event) &&
d248 6
d258 27
a284 14
	 * indicated is canonical is enabled or not
	 * Canonical is disabled if the edit part's view is collapsed or hidden
	 * @@return
	 */
	protected boolean isCanonicalEnabled() {
		DrawerStyle dstyle = (DrawerStyle) ((View)getModel()).getStyle(NotationPackage.eINSTANCE.getDrawerStyle());
		boolean isCollapsed = dstyle == null ? false : dstyle.isCollapsed();
		
		if ( isCollapsed ) {
			return false;
		}
		
		return ((View)getModel()).isVisible();
	}
d395 5
@


1.2.2.1
log
@bugzilla 150316 sshaw gmf-R1_0_maintenance 060726 SemanticListCompartmentEditPart could improve its performance

Contributed by: Yaser Lulu
@
text
@d37 2
a38 2
 * A List compartment Edit part that contains semantic edit parts. A semantic
 * edit part is an edit part that controls a semantic element, it does not
d58 51
a108 1
    extends ListCompartmentEditPart {
a109 23
    /**
     * constructor
     * 
     * @@param model
     *            the mdoel controlled by this edit part
     */
    public SemanticListCompartmentEditPart(EObject model) {
        super(model);
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#refreshChildren()
     */
    protected void refreshChildren() {
        List childs = getChildren();
        List modelObjects = getModelChildren();
        int childrenSize = childs.size();
        int modelObjectsSize = modelObjects.size();
        if (childrenSize == 0 && modelObjectsSize == 0) {
            return;
        }
d111 5
a115 65
        int i;
        GraphicalEditPart editPart;
        Object model;

        Map modelToEditPart = null;

        for (i = 0; i < modelObjectsSize; i++) {
            model = modelObjects.get(i);

            // Do a quick check to see if editPart[i] == model[i]
            if (i < childrenSize
                && ((GraphicalEditPart) childs.get(i)).basicGetModel() == model)
                continue;

            if (modelToEditPart == null) {
                if (childrenSize == 0) {
                    modelToEditPart = Collections.EMPTY_MAP;
                } else {
                    modelToEditPart = new HashMap();
                    for (int j = 0; j < childrenSize; j++) {
                        editPart = (GraphicalEditPart) childs.get(j);
                        modelToEditPart.put(editPart.basicGetModel(), editPart);
                    }
                }
            }

            // Look to see if the EditPart is already around but in the wrong
            // location
            editPart = (GraphicalEditPart) modelToEditPart.get(model);

            if (editPart != null)
                reorderChild(editPart, i);
            else {
                // An editpart for this model doesn't exist yet. Create and
                // insert one.
                semanticChildAdded((EObject)model, i);
            }
        }

        if (i < childrenSize) {
            for (; i < childrenSize; i++) {
                EditPart child = (EditPart) childs.get(i);
                fireRemovingChild(child, i);
                if (isActive()) {
                    child.deactivate();
                }
                child.removeNotify();
                removeChildVisual(child);
                child.setParent(null);
            }

            if (i == 0) {
                children = new ArrayList(2);
            } else {
                children = new ArrayList(childs.subList(0, modelObjectsSize));
            }
        }

    }

    /**
     * @@param child
     */
    protected void semanticChildRemoved(EObject child) {
        if (children == null)
d118 39
a156 36
            GraphicalEditPart ep = (GraphicalEditPart) iter.next();
            if (ep.basicGetModel().equals(child)) {
                removeChild(ep);
                break;
            }
        }
    }

    /**
     * Updates the set of children views so that it is in sync with the semantic
     * children. This method is called in response to notification from the
     * model.
     * <P>
     * The update is performed by comparing the exising views with the set of
     * semantic children returned from {@@link #getViewChildren()}. Views whose
     * semantic element no longer exists are
     * {@@link #deleteViews(Iterator) removed}. New semantic children have their
     * View {@@link  #createViews(List) created}. Subclasses must override
     * <code>getSemanticChildren()</code>.
     * <P>
     * Unlike <code>AbstractEditPart#refreshChildren()</code>, this refresh
     * will not reorder the view list to ensure both it and the semantic
     * children are in the same order since it is possible that this edit policy
     * will handle a specifc subset of the host's views.
     * <P>
     * The host is refreshed if a view has created or deleted as a result of
     * this refresh.
     */
    protected void refreshSemanticChildren() {
        if (!isCanonicalEnabled())
            return;
        // Don't try to refresh children if the semantic element
        // cannot be resolved.
        if (resolveSemanticElement() == null) {
            return;
        }				
d160 12
a171 12
		List modelChildren = getSemanticChildrenList();
		if(editPartsChildren.size()==0 && modelChildren.size()==0){
			return;
		}
		List semanticChildren = getModelChildren(modelChildren);
		if (editPartsChildren.size() > 0) {
			//View viewChild;		
			semanticChildren = new ArrayList(semanticChildren);
			Iterator childrenIT = editPartsChildren.iterator();
			while (childrenIT.hasNext()) {
				GraphicalEditPart eP = (GraphicalEditPart) childrenIT.next();
				semanticChildren.remove(eP.basicGetModel());
d174 1
a174 1

d177 1
a177 1
		if (!semanticChildren.isEmpty()) {
d180 1
a180 1
				semanticChildAdded(element, -1);
d183 30
a212 37
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gef.EditPart#activate()
     */
    public void activate() {
        super.activate();
        refreshSemanticChildren();
    }

    /**
     * This method will be called when a child is added to the EditPart's model
     * id Canonical is enabled
     * 
     * @@param child
     *            the child being added, the index where its edit part should be
     *            created
     * @@param index
     */
    abstract protected void semanticChildAdded(EObject child, int index);

    /**
     * Returns a list of all semantic children inside this editpart's model
     * 
     * @@return
     */
    abstract protected List getSemanticChildrenList();

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart#handleNotificationEvent(org.eclipse.emf.common.notify.Notification)
     */
    protected void handleNotificationEvent(Notification event) {
        Object feature = event.getFeature();
d224 147
a370 202
    }

    /**
     * called by the <code>handlePropertyChangeEvent</code> when the semantic
     * children list is changed, then this method will check if the change was
     * add or delete of an element and calls either
     * <code>semanticChildAdded</code> or <code>semanticChildDeleted</code>
     * this could be used to implement a canonical list without a canonical edit
     * policy
     * 
     * @@param evt
     */
    protected void semanticChildrenListChanged(Notification event) {
        if (!isCanonicalEnabled())
            return;
        if (NotificationUtil.isElementAddedToSlot(event)
            || NotificationUtil.isMove(event)) {
            refreshChildren();
        } else if (NotificationUtil.isElementRemovedFromSlot(event)
            && event.getOldValue() instanceof EObject) {
            semanticChildRemoved((EObject) event.getOldValue());
        }
    }

    /**
     * indicated is canonical is enabled or not Canonical is disabled if the
     * edit part's view is collapsed or hidden
     * 
     * @@return
     */
    protected boolean isCanonicalEnabled() {
        DrawerStyle dstyle = (DrawerStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.DRAWER_STYLE);
        boolean isCollapsed = dstyle == null ? false
            : dstyle.isCollapsed();

        if (isCollapsed) {
            return false;
        }

        return ((View) getModel()).isVisible();
    }
    
    /* 
     * (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getModelChildren()
     */
    protected List getModelChildren() {
    	return getModelChildren(getSemanticChildrenList());
    }
    
    /* 
     * (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getSortedChildren(java.util.List)
     */
    List getSortedChildren(List modelChildren) {
        SortingStyle style = (SortingStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.SORTING_STYLE);

        if (style != null) {
            Sorting sorting = style.getSorting();
            if (Sorting.NONE_LITERAL == sorting) {

                return modelChildren;

            } else if (Sorting.MANUAL_LITERAL == sorting) {

                // Return the empty list if the model children have not yet been
                // created.
                if (modelChildren.isEmpty())
                    return modelChildren;

                List sortedChildren = style.eIsSet(NotationPackage.Literals
                    .SORTING_STYLE__SORTED_OBJECTS) ? style
                    .getSortedObjects()
                    : Collections.EMPTY_LIST;

                if (sortedChildren.isEmpty()) {
                    return modelChildren;
                }

                List sorted = new ArrayList();

                // Get the corresponding views...
                Iterator i = sortedChildren.iterator();
                while (i.hasNext()) {
                    EObject eObject = (EObject) i.next();
                    if (modelChildren.contains(eObject))
                        sorted.add(eObject);
                }

                // Add any remaining model children to the end
                int size = modelChildren.size();
                for (int j = 0; j < size; j++) {
                    EObject element = (EObject) modelChildren.get(j);
                    if (!sorted.contains(element))
                        sorted.add(element);
                }

                return sorted;

            } else if (Sorting.AUTOMATIC_LITERAL == sorting) {
                Map sortingKeys = style.eIsSet(NotationPackage.Literals
                    .SORTING_STYLE__SORTING_KEYS) ? style.getSortingKeys()
                    : Collections.EMPTY_MAP;
                return (sortingKeys.isEmpty()) ? getSemanticChildrenList()
                    : getChildrenSortedBy(sortingKeys, modelChildren);
            }
        }

        return getSemanticChildrenList();
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getSortedChildren()
     */
    protected List getSortedChildren() {
        List modelChildren = getSemanticChildrenList();
        if (modelChildren.isEmpty() == false) {
            return getSortedChildren(modelChildren);
        }
        return modelChildren;
    }

    /**
     * Returns the model children sorted by the order specified by
     * Properties.ID_SORTING_KEYS. This is used to support dynamic list
     * compartment sorting.
     * 
     * @@param sortingKeys
     * @@return the model children sorted
     */
    protected List getChildrenSortedBy(Map sortingKeys) {
        if (sortingKeys != null && !sortingKeys.isEmpty()) {
            List allChildren = new ArrayList(getSemanticChildrenList());
            // Currently only one sorting key is supported.

            Collection keySet = sortingKeys.keySet();
            Iterator i = keySet.iterator();
            String name = (String) i.next();
            SortingDirection direction = (SortingDirection) sortingKeys
                .get(name);

            Comparator comparator = getComparator(name, direction);

            if (comparator != null)
                Collections.sort(allChildren, comparator);
            return allChildren;
        }

        return getSemanticChildrenList();

    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getFilteredChildren()
     */
    protected List getFilteredChildren() {
        List modelChildren = getSemanticChildrenList();
        if (modelChildren.isEmpty() == false) {
            return getFilteredChildren(modelChildren);
        }
        return Collections.EMPTY_LIST;
    }

    /* 
     * (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getFilteredChildren(java.util.List)
     */
    List getFilteredChildren(List modelChildren) {
        FilteringStyle style = (FilteringStyle) ((View) getModel())
            .getStyle(NotationPackage.Literals.FILTERING_STYLE);
        if (style != null) {
            Filtering filtering = style.getFiltering();
            if (Filtering.NONE_LITERAL == filtering) {

                return Collections.EMPTY_LIST;

            } else if (Filtering.MANUAL_LITERAL == filtering) {

                List filteredChildren = style.eIsSet(NotationPackage.Literals
                    .FILTERING_STYLE__FILTERED_OBJECTS) ? style
                    .getFilteredObjects()
                    : Collections.EMPTY_LIST;
                return filteredChildren;

            } else if (Filtering.AUTOMATIC_LITERAL == filtering) {
                List filteringKeys = style.eIsSet(NotationPackage.Literals
                    .FILTERING_STYLE__FILTERING_KEYS) ? style
                    .getFilteringKeys()
                    : Collections.EMPTY_LIST;
                return (filteringKeys.isEmpty()) ? filteringKeys
                    : getChildrenFilteredBy(filteringKeys, modelChildren);
            }
        }

        return Collections.EMPTY_LIST;
    }
@


1.2.2.2
log
@[152036] gmf_R1_0_maintenace mmostafa 060727  Componenet Edit Policy does not consider the semantic list compartment
@
text
@d286 1
a286 1
     * indicated if canonical is enabled or not Canonical is disabled if the
a303 10
    /**
     * indicated if canonical is enabled or not Canonical is disabled if the
     * edit part's view is collapsed or hidden
     * 
     * @@return
     */
    public boolean isCanonicalOn() {
        return isCanonicalEnabled();
    }
    
a462 9

    protected boolean hasModelChildrenChanged(Notification evt) {
        // TODO Auto-generated method stub
        return false;
    }

    public boolean isCanonical() {
        return true;
    }
@


1.2.2.3
log
@[152036] gmf_R1_0_maintenace mmostafa 060727  Componenet Edit Policy does not consider the semantic list compartment
@
text
@d474 5
a478 3
    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart#isCanonical()
     */
@


1.2.2.4
log
@bugzilla 150316 sshaw gmf-R1_0_maintenance 060726 SemanticListCompartmentEditPart could improve its performance

Contributed by: Yaser Lulu (less intrusive patch)
@
text
@d58 11
a68 28
	extends ListCompartmentEditPart {
	
	/**
	 * constructor
	 * @@param model the mdoel controlled by this edit part
	 */
	public SemanticListCompartmentEditPart(EObject model) {
		super(model);
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#refreshChildren()
	 */
	protected void refreshChildren() {
		int i;
		GraphicalEditPart editPart;		
		List modelObjects = getModelChildren();
		List _children = getChildren();
		
		if ((modelObjects.size() == 0) && (_children.size() == 0)) {
			return;
		}
		
		Map modelToEditPart = new HashMap();
		for (i = 0; i < _children.size(); i++) {
			editPart = (GraphicalEditPart)_children.get(i);
			modelToEditPart.put(editPart.basicGetModel(), editPart);
		}
d70 13
a82 1
		
d84 57
a140 25
		for (i = 0; i < modelObjects.size(); i++) {
			EObject element  = (EObject)modelObjects.get(i);
			//Do a quick check to see if editPart[i] == model[i]
			if (i < _children.size()
				&& (((GraphicalEditPart)_children.get(i)).basicGetModel()) == element)
					continue;

			//Look to see if the EditPart is already around but in the wrong location
			editPart = (GraphicalEditPart)modelToEditPart.get(element);

			if (editPart != null)
				reorderChild (editPart, i);
			else {
				//An editpart for this model doesn't exist yet.  Create and insert one.
				semanticChildAdded(element,i);
			}
		}
		List trash = new ArrayList();
		for (; i < _children.size(); i++)
			trash.add(_children.get(i));
		for (i = 0; i < trash.size(); i++) {
			EditPart ep = (EditPart)trash.get(i);
			removeChild(ep);
		}
	}
d142 1
d144 5
a148 5
	/**
	 * @@param child
	 */
	protected void semanticChildRemoved(EObject child){
        if (children==null)
d151 36
a186 36
			GraphicalEditPart ep = (GraphicalEditPart) iter.next();
			if (ep.basicGetModel().equals(child)){
				removeChild(ep);
				break;
			}
		}
	}
	
	/**
	 * Updates the set of children views so that it
	 * is in sync with the semantic children. This method is called 
	 * in response to notification from the model.
	 * <P>
	 * The update is performed by comparing the exising views with the set of
	 * semantic children returned from {@@link #getViewChildren()}. Views whose
	 * semantic element no longer exists are {@@link #deleteViews(Iterator) removed}. 
	 * New semantic children have their View {@@link  #createViews(List)
	 * created}.  Subclasses must override <code>getSemanticChildren()</code>.
	 * <P>
	 * Unlike <code>AbstractEditPart#refreshChildren()</code>, this refresh will not
	 * reorder the view list to ensure both it and the semantic children are
	 * in the same order since it is possible that this edit policy will handle
	 * a specifc subset of the host's views.  
	 * <P>
	 * The host is refreshed if a view has created or deleted as a result of this
	 * refresh.
	 */
	protected void refreshSemanticChildren() {
		if (!isCanonicalEnabled())
			return ; 
		// Don't try to refresh children if the semantic element
		// cannot be resolved.
		if (resolveSemanticElement() == null) {
			return;		
		}
		
d190 2
a191 2
		List modelChildren = getModelChildren();
		if ((editPartsChildren.size() == 0) && (modelChildren.size() == 0)) {
a192 14
		}		
		
		List semanticChildren = new ArrayList(modelChildren);
		
		//View viewChild;
		EObject semanticChild;
				
		

		Iterator childrenIT = editPartsChildren.iterator();		
		while( childrenIT.hasNext() ) {
			GraphicalEditPart eP = (GraphicalEditPart)childrenIT.next();
			semanticChild = (EObject)eP.basicGetModel();
			semanticChildren.remove(semanticChild);			
d194 11
a204 1
		
d207 1
a207 1
		if ( !semanticChildren.isEmpty()) {
d210 1
a210 1
				semanticChildAdded(element,-1);
d213 37
a249 30
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gef.EditPart#activate()
	 */
	public void activate() {
		super.activate();
		refreshSemanticChildren();
	}
	
	/**
	 * This method will be called when a child is added to the
	 * EditPart's model id Canonical is enabled
	 * @@param child	the child being added, the index where its edit part should be created 
	 * @@param index
	 */
	abstract protected void semanticChildAdded(EObject child,int index);
	
	/**
	 * Returns a list of all semantic children inside this editpart's model
	 * @@return
	 */
	abstract protected List getSemanticChildrenList();


	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart#handleNotificationEvent(org.eclipse.emf.common.notify.Notification)
	 */
	protected void handleNotificationEvent(Notification event) {
		Object feature = event.getFeature();
d261 25
a285 23
	}
	
	/**
	 * called by the <code>handlePropertyChangeEvent</code> when the semantic children list 
	 * is changed, then this method will check if the change was add or delete of an element
	 * and calls either <code>semanticChildAdded</code> or <code>semanticChildDeleted</code>
	 * this could be used to implement a canonical list without a canonical edit policy
	 * @@param evt
	 */
	protected void semanticChildrenListChanged(Notification event) {
		if (!isCanonicalEnabled())
			return;
		if (NotificationUtil.isElementAddedToSlot(event) ||
			NotificationUtil.isMove(event)){
			refreshChildren();
		}
		else if(NotificationUtil.isElementRemovedFromSlot(event) &&
				event.getOldValue() instanceof  EObject){
				semanticChildRemoved((EObject)event.getOldValue());
		}
	}
	
	/**
d303 2
a304 2
	
	/**
d313 67
d381 97
a477 111
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getSortedChildren()
	 */
	protected List getSortedChildren() {
		SortingStyle style = (SortingStyle)  ((View)getModel()).getStyle(NotationPackage.eINSTANCE.getSortingStyle());

		if (style != null) {
			Sorting sorting = style.getSorting();
			if (Sorting.NONE_LITERAL == sorting) {
				
				return getSemanticChildrenList();
				
			} else if (Sorting.MANUAL_LITERAL == sorting) {
	
				List allChildren = getSemanticChildrenList();
				// Return the empty list if the model children have not yet been
				// created.
				if (allChildren.isEmpty())
					return allChildren;
				
				List sortedChildren = style.eIsSet(NotationPackage.eINSTANCE.getSortingStyle_SortedObjects())
					? style.getSortedObjects() 
					: Collections.EMPTY_LIST;
	
				List sorted = new ArrayList();
				
				// Get the corresponding views...
				Iterator i = sortedChildren.iterator();
				while(i.hasNext()) {
					EObject eObject = (EObject) i.next();
					if (allChildren.contains(eObject))
						sorted.add(eObject);
				}	
				
				// Add any remaining model children to the end
				for (int j = 0; j < allChildren.size(); j++) {
					EObject element = (EObject) allChildren.get(j);
					if (!sorted.contains(element))
						sorted.add(element);
				}
				
				return sorted;
				
			} else if (Sorting.AUTOMATIC_LITERAL == sorting) {
				Map sortingKeys = style.eIsSet(NotationPackage.eINSTANCE.getSortingStyle_SortingKeys())
					? style.getSortingKeys() 
					: Collections.EMPTY_MAP;
				return getChildrenSortedBy(sortingKeys);
			}
		}
		
		return getSemanticChildrenList();		
	}
	
	/**
	 * Returns the model children sorted by the order specified by Properties.ID_SORTING_KEYS.
	 * This is used to support dynamic list compartment sorting.
	 * @@param sortingKeys
	 * @@return the model children sorted
	 */
	protected List getChildrenSortedBy(Map sortingKeys) {
		List allChildren = new ArrayList(getSemanticChildrenList());
		// Currently only one sorting key is supported.
		if (sortingKeys != null && !sortingKeys.isEmpty()) {
			Collection keySet = sortingKeys.keySet();
			Iterator i = keySet.iterator();
			String name = (String) i.next();
			SortingDirection direction = (SortingDirection) sortingKeys.get(name);
			
			Comparator comparator = getComparator(name, direction);
			
			if (comparator != null)
				Collections.sort(allChildren, getComparator(name, direction));									
		} 
		return allChildren;
	}


	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ListCompartmentEditPart#getFilteredChildren()
	 */
	protected List getFilteredChildren() {
		Object model = getModel();
		if (model instanceof View){
			View view = (View)model;
			FilteringStyle style = (FilteringStyle)  view.getStyle(NotationPackage.eINSTANCE.getFilteringStyle());
			if (style != null) {
				Filtering filtering = style.getFiltering();
				if (Filtering.NONE_LITERAL == filtering) {
					
					return Collections.EMPTY_LIST;
					
				} else if (Filtering.MANUAL_LITERAL == filtering) {
					
					List filteredChildren = style.eIsSet(NotationPackage.eINSTANCE.getFilteringStyle_FilteredObjects())
						? style.getFilteredObjects() 
						: Collections.EMPTY_LIST;
					return filteredChildren;	
				
				} else if (Filtering.AUTOMATIC_LITERAL == filtering) {
					List filteringKeys = style.eIsSet(NotationPackage.eINSTANCE.getFilteringStyle_FilteringKeys())
						? style.getFilteringKeys() 
						: Collections.EMPTY_LIST;
					return getChildrenFilteredBy(filteringKeys);
				}
			}
		}
		return Collections.EMPTY_LIST;
	}
	
	public boolean isCanonical() {
d479 1
a479 2
    }	
	
@


1.2.2.5
log
@[156253] gmf_R1_0_maintenace aboyko 060906  Children of SemanticListCompartmentEditPart cannot be deleted
@
text
@d178 1
a178 1
			semanticChildren.remove(semanticChild);
d240 7
a246 6
		if (isCanonicalEnabled()){
			if (NotificationUtil.isElementAddedToSlot(event) ||
				NotificationUtil.isMove(event)){
				refreshChildren();
			}
			else if(NotificationUtil.isElementRemovedFromSlot(event) &&
a248 6
			
			}
		}else if(NotificationUtil.isElementRemovedFromSlot(event) &&
				event.getOldValue() instanceof  EObject &&
				!getChildren().isEmpty()){
				semanticChildRemoved((EObject)event.getOldValue());
d393 1
a393 1
    }
@


1.2.2.6
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.1
log
@ bugzilla 111894 gmf-head mmostafa 051201 Improve memory consumption of opened notation diagram
@
text
@d115 3
a117 1
		for (Iterator iter = children.iterator(); iter.hasNext();) {
@

