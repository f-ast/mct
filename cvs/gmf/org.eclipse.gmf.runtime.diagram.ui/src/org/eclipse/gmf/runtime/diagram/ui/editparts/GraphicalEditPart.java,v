head	1.51;
access;
symbols
	v20081023-2107:1.51
	v20081022-1925:1.51
	v20081022-1005:1.51
	v20081020-0700:1.51
	v20080917-1925:1.51
	v20080916-2008:1.51
	v20080911-1728:1.51
	v20080911-1506:1.51
	v20080910-1520:1.51
	v20080910-1510:1.51
	v20080903-1520:1.51
	v20080903-1510:1.51
	v20080813-1510:1.51
	v20080811-1546:1.51
	v20080731-1520:1.51
	v20080725-1738:1.51
	v20080723-2246:1.51
	v20080723-2232:1.51
	v20080723-1700:1.51
	v20080722-1827:1.51
	v20080718-1700:1.51
	v20080718-1731:1.51
	v20080716-1600:1.51
	v20080716-1642:1.51
	R2_1_maintenance:1.51.0.2
	Root_R2_1_maintenance:1.51
	R2_1_0:1.51
	v20080610-1132:1.51
	v20080603-1553:1.51
	v20080527-1255:1.51
	v20080527-1151:1.48
	v20080516-1748:1.51
	v20080516-1143:1.51
	v20080512-1200:1.51
	v20080503-1740:1.51
	v20080501-2127:1.48
	v20080501-1739:1.50
	m20080429-1543:1.48
	v20080425-1959:1.50
	v20080417-1610:1.50
	v20080407-2250:1.50
	v20080407-0930:1.50
	v20080404-1111:1.50
	v20080328-1605:1.50
	v20080322-0000:1.50
	v20080222-1200:1.50
	v20080201-2010:1.50
	v20080201-0201:1.48
	v20080118-1129:1.48
	v20080114-2222:1.48
	v20080114-1111:1.50
	v20080107-1111:1.49
	v20071222-1111:1.49
	v20071214-1111:1.49
	v20071130-1111:1.49
	v20071124-0000:1.48
	v20071112-0000:1.49
	v20071108-0000:1.49
	v20071003-0000:1.48
	v20070915-0000:1.48
	v20070903-0000:1.48
	v20070809-0000:1.48
	R2_0_maintenance:1.48.0.2
	R2_0:1.48
	R4_20:1.48
	v20070621-0000:1.48
	RC3_20:1.48
	v20070614-1400:1.48
	v20070608-1300:1.48
	v20070605-1400:1.48
	v20070601-1400:1.48
	v20070525-1500:1.47
	v20070518-1300:1.47
	bugzilla111892_group_support:1.47.0.2
	Root_bugzilla111892_group_support:1.47
	v20070504-1000:1.47
	v20070420-1000:1.47
	v20070413-1300:1.47
	v20070330-1300:1.47
	v20060330-1300:1.47
	v20070322-1100:1.47
	v20060316-0600:1.47
	v20070221-1500:1.47
	v20070208-1800:1.47
	v20070202-0200:1.42.2.11
	v20070119-1200:1.42.2.11
	v20070111-0800:1.42.2.11
	v20070105-1200:1.42.2.11
	v20070103-0300:1.45
	M4_20:1.45
	v20061218-1500:1.42.2.11
	v20061218-1200:1.45
	v20061214-0000:1.45
	M3_20:1.44
	v20061117-0800:1.44
	v20061027-1200:1.42.2.10
	v20061013-1330:1.44
	v20061012-1100:1.42.2.10
	v20060925-1700:1.42.2.9
	v20060919-0800:1.42.2.9
	v20060907-1100:1.42.2.9
	M1_20:1.42
	v20060831-1500:1.42.2.9
	v20060824-1600:1.42.2.9
	v20060817-1500:1.42.2.8
	v20060810-1700:1.42.2.8
	v20060803-1200:1.42.2.7
	v20060728-0500:1.42.2.4
	v20060721-1130:1.42.2.3
	v20060713-1700:1.42.2.1
	R1_0_maintenance:1.42.0.2
	R1_0:1.42
	v20060627-1200:1.42
	v20060616-1400:1.42
	v20060616-1200:1.42
	v20060609-1400:1.41
	v20060531-1730:1.40
	v20060530-1930:1.39
	v20060526-1200:1.39
	v20060519-0800:1.38
	v20060512-1000:1.37
	I20060512-1000:1.37
	I20060505-1400:1.36
	I20060428-1300:1.36
	I20060424-0500:1.36
	I20060424-0300:1.35
	M6_10:1.35
	I20060407-1200:1.35
	I20060331-1000:1.35
	I20060324-0300:1.35
	I20060317-1300:1.35
	I20060317-1200:1.35
	I20060316-1300:1.35
	I20060309-1300:1.35
	M5_10:1.30
	S20060303-1600:1.30
	I20060227-1730:1.28
	I20060216-1945:1.28
	I20060210-1715:1.27
	I20060209-1815:1.27
	I20060203-0830:1.26
	I20060202-1415:1.26
	I20060129-1145:1.26
	I20060127-0900:1.25
	I20060120-1530:1.25
	I20060113-1700:1.24
	M4_10:1.24
	I20060107-1100:1.24
	I20060105-1630:1.24
	I20051230-1230:1.24
	I20051223-1100:1.23
	I20051217-0925:1.23
	I20051208-2000:1.21
	I20051201-1800:1.19
	I20051124-2000:1.17
	M3_10:1.17
	I20051118-1245:1.17
	I20051111-1800:1.17
	I20051106-0900:1.16
	v20051030:1.14;
locks; strict;
comment	@# @;


1.51
date	2008.05.03.20.56.21;	author ahunter;	state Exp;
branches;
next	1.50;
commitid	608a481cd1724567;

1.50
date	2008.01.11.15.59.37;	author crevells;	state Exp;
branches;
next	1.49;
commitid	6a2c478792684567;

1.49
date	2007.10.16.14.11.54;	author crevells;	state Exp;
branches;
next	1.48;
commitid	2b604714c6a84567;

1.48
date	2007.05.29.18.24.49;	author mmostafa;	state Exp;
branches;
next	1.47;
commitid	2c3b465c6ff14567;

1.47
date	2007.01.18.18.58.02;	author mmostafa;	state Exp;
branches;
next	1.46;
commitid	24d745afc33a4567;

1.46
date	2007.01.16.14.53.59;	author mmostafa;	state Exp;
branches;
next	1.45;
commitid	78d445ace7064567;

1.45
date	2006.12.06.22.01.19;	author mmostafa;	state Exp;
branches;
next	1.44;
commitid	627645773dae4567;

1.44
date	2006.10.06.13.41.42;	author ahunter;	state Exp;
branches;
next	1.43;

1.43
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.16.15.34.30;	author sshaw;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2006.06.02.13.15.59;	author sshaw;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.31.16.26.07;	author sshaw;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.25.20.40.20;	author mmostafa;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.16.18.31.49;	author cmahoney;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.09.19.45.24;	author cmahoney;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.21.21.28.32;	author mmostafa;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.09.23.15.40;	author ldamus;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.09.22.44.20;	author ldamus;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.09.16.33.15;	author cmahoney;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.08.16.54.44;	author cmahoney;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.06.23.22.24;	author ldamus;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.28.02.31.20;	author cmahoney;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.27.19.36.25;	author sshaw;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.13.19.11.49;	author ldamus;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.07.15.19.06;	author mmostafa;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.27.20.22.56;	author sshaw;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.17.18.47.09;	author sshaw;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.23.20.27.17;	author mmostafa;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.14.19.18.25;	author mmostafa;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.09.21.06.12;	author mmostafa;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.07.15.35.20;	author mmostafa;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.02.17.27.44;	author mmostafa;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.01.15.31.43;	author mmostafa;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.25.19.38.13;	author cmahoney;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.08.19.38.16;	author mmostafa;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.04.21.27.48;	author sshaw;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.02.23.30.15;	author sshaw;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.14.20.58.50;	author mmostafa;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.03.18.08.31;	author sshaw;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.23.20.55.29;	author sshaw;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.23.18.50.51;	author sshaw;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.23.18.37.25;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.22.15.42.19;	author sshaw;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.15.14.59.19;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.13.15.45.50;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.12.21.29.05;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.12.16.08.52;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.16.04.33;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.15.48.52;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.36;	author sshaw;	state Exp;
branches;
next	;

1.42.2.1
date	2006.07.11.15.10.29;	author cmahoney;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2006.07.14.19.53.42;	author mmostafa;	state Exp;
branches;
next	1.42.2.3;

1.42.2.3
date	2006.07.14.21.02.16;	author cmahoney;	state Exp;
branches;
next	1.42.2.4;

1.42.2.4
date	2006.07.27.21.36.10;	author mmostafa;	state Exp;
branches;
next	1.42.2.5;

1.42.2.5
date	2006.08.01.18.18.00;	author mmostafa;	state Exp;
branches;
next	1.42.2.6;

1.42.2.6
date	2006.08.01.19.10.24;	author mmostafa;	state Exp;
branches;
next	1.42.2.7;

1.42.2.7
date	2006.08.02.13.38.48;	author mmostafa;	state Exp;
branches;
next	1.42.2.8;

1.42.2.8
date	2006.08.10.18.40.27;	author mmostafa;	state Exp;
branches;
next	1.42.2.9;

1.42.2.9
date	2006.08.22.14.54.26;	author cmahoney;	state Exp;
branches;
next	1.42.2.10;

1.42.2.10
date	2006.10.05.21.14.55;	author ahunter;	state Exp;
branches;
next	1.42.2.11;

1.42.2.11
date	2006.12.06.22.00.54;	author mmostafa;	state Exp;
branches;
next	;
commitid	5d5745773d954567;


desc
@@


1.51
log
@[225137] gmf-head ahunter 080503 Line styles enhancement
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editparts;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.IFigure;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.transaction.RunnableWithResult;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gef.AccessibleEditPart;
import org.eclipse.gef.DragTracker;
import org.eclipse.gef.EditDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartViewer;
import org.eclipse.gef.EditPolicy;
import org.eclipse.gef.Request;
import org.eclipse.gef.RequestConstants;
import org.eclipse.gef.RootEditPart;
import org.eclipse.gef.SnapToHelper;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.commands.CompoundCommand;
import org.eclipse.gef.commands.UnexecutableCommand;
import org.eclipse.gef.editparts.AbstractGraphicalEditPart;
import org.eclipse.gef.requests.CreateConnectionRequest;
import org.eclipse.gef.requests.DropRequest;
import org.eclipse.gef.requests.GroupRequest;
import org.eclipse.gef.requests.ReconnectRequest;
import org.eclipse.gef.requests.TargetRequest;
import org.eclipse.gmf.runtime.common.core.util.IAdaptableSelection;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.services.action.filter.ActionFilterService;
import org.eclipse.gmf.runtime.common.ui.services.parser.CommonParserHint;
import org.eclipse.gmf.runtime.diagram.core.listener.DiagramEventBroker;
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener;
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CanonicalEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.DecorationEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.PropertyHandlerEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.SemanticEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.internal.commands.ToggleCanonicalModeCommand;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DummyEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.IEditableEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.ruler.SnapToHelperUtil;
import org.eclipse.gmf.runtime.diagram.ui.internal.services.editpolicy.EditPolicyService;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramColorRegistry;
import org.eclipse.gmf.runtime.diagram.ui.label.ILabelDelegate;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramEditDomain;
import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
import org.eclipse.gmf.runtime.diagram.ui.requests.CreateConnectionViewRequest;
import org.eclipse.gmf.runtime.diagram.ui.requests.EditCommandRequestWrapper;
import org.eclipse.gmf.runtime.diagram.ui.tools.DragEditPartsTrackerEx;
import org.eclipse.gmf.runtime.diagram.ui.util.EditPartUtil;
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;
import org.eclipse.gmf.runtime.gef.ui.internal.editpolicies.GraphicalEditPolicyEx;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.FillStyle;
import org.eclipse.gmf.runtime.notation.FontStyle;
import org.eclipse.gmf.runtime.notation.LineStyle;
import org.eclipse.gmf.runtime.notation.LineType;
import org.eclipse.gmf.runtime.notation.LineTypeStyle;
import org.eclipse.gmf.runtime.notation.Node;
import org.eclipse.gmf.runtime.notation.NotationFactory;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.preference.PreferenceConverter;
import org.eclipse.jface.resource.DeviceResourceException;
import org.eclipse.jface.resource.FontDescriptor;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.resource.ResourceManager;
import org.eclipse.swt.SWT;
import org.eclipse.swt.accessibility.AccessibleEvent;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.ui.IActionFilter;

/**
 * @@author melaasar,mmostafa
 * 
 * The root of all component graphical edit parts that own a view as a model
 */
public abstract class GraphicalEditPart
    extends AbstractGraphicalEditPart
    implements IGraphicalEditPart, IAdaptableSelection, NotificationListener {
  
    /** A map of listener filters ids to filter data */
    private Map listenerFilters;
    
    /** Used for accessibility. */
    protected AccessibleEditPart accessibleEP;

    /** Used for registering and unregistering the edit part */
    protected String elementGuid;

    /**
     * Flag to indicate if the edit part is in edit mode
     */
    private boolean isEditable = true;
    
    /**
     * Cache the editing domain after it is retrieved.
     */
    private TransactionalEditingDomain editingDomain;

    /**
     * Cache the font data when a font is created so that it can be
     * disposed later.
     */
    private FontData cachedFontData;
    
    /**
     * Create an instance.
     * 
     * @@param model
     *            the underlying model.
     */
    public GraphicalEditPart(EObject model) {
        setModel(model);        
    }

    /** Registers this editpart to recieve notation and semantic events. */
    public void activate() {
        if (isActive()) {
            return;
        }
        addNotationalListeners();

        EObject semanticElement;
        EObject semanticProxy;
        if (hasNotationView()) {
            semanticProxy = ((View) super.getModel()).getElement();
            if ((semanticProxy==null)||semanticProxy.eIsProxy()) {
                semanticElement = null;
            } else {
                semanticElement = semanticProxy;
            }
        } else {
            semanticProxy = (EObject) basicGetModel();
            if ((semanticProxy!=null) && semanticProxy.eIsProxy()) {
                semanticElement = EMFCoreUtil.resolve(getEditingDomain(),
                    semanticProxy);
            } else {
                semanticElement = semanticProxy;
            }
        }

        if (semanticElement != null)
            addSemanticListeners();
        else if (semanticProxy != null) {
            addListenerFilter("SemanticProxy", this, semanticProxy); //$NON-NLS-1$
        }
        GraphicalEditPart.super.activate();

    }

    /**
     * Adds a listener filter by adding the given listener to a passed notifier
     * 
     * @@param filterId
     *            A unique filter id (within the same editpart instance)
     * @@param listener
     *            A listener instance
     * @@param element
     *            An element to add the listener to
     */
    protected void addListenerFilter(String filterId,
            NotificationListener listener,
            EObject element) {
        if (element == null)
            return;

        DiagramEventBroker diagramEventBroker = getDiagramEventBroker();
        if (diagramEventBroker != null) {
        	assert filterId != null;
        	assert listener != null;
            if (listenerFilters == null)
                listenerFilters = new HashMap();
            diagramEventBroker.addNotificationListener(element,listener);
            listenerFilters.put(filterId.intern(), new Object[] {element, listener});
        }
    }
    
    /**
     * Adds a listener filter by adding the given listener to a passed notifier
     * 
     * @@param filterId
     *            A unique filter id (within the same editpart instance)
     * @@param listener
     *            A listener instance
     * @@param element
     *            An element to add the listener to
     */
    protected void addListenerFilter(String filterId,
            NotificationListener listener,
            EObject element,
            EStructuralFeature feature) {
        if (element == null)
            return;
                
        DiagramEventBroker diagramEventBroker = getDiagramEventBroker();
        if (diagramEventBroker != null) {
        	assert filterId != null;
        	assert listener != null;
            if (listenerFilters == null)
                listenerFilters = new HashMap();

            diagramEventBroker.addNotificationListener(element,feature,listener);

            listenerFilters.put(filterId.intern(), new Object[] {element,feature, listener});
        }
    }

    /** Creates a connection editpart. */
    final protected org.eclipse.gef.ConnectionEditPart createConnection(
            Object connectionView) {
        return (org.eclipse.gef.ConnectionEditPart) createChild(connectionView);
    }

    /**
     * Overridden to support editpolicies installed programmatically and via the
     * <code>EditPolicyService</code>. Subclasses should override
     * <code>createDefaultEditPolicies()</code>.
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
     */
    final protected void createEditPolicies() {
        createDefaultEditPolicies();
        EditPolicyService.getInstance().createEditPolicies(this);
    }

    /**
     * Should be overridden to install editpolicies programmatically.
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
     */
    protected void createDefaultEditPolicies() {
        installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
            new SemanticEditPolicy());
        installEditPolicy(EditPolicyRoles.PROPERTY_HANDLER_ROLE,
            new PropertyHandlerEditPolicy());
        installEditPolicy(EditPolicyRoles.DECORATION_ROLE,
            new DecorationEditPolicy());
    }

    public void deactivate() {
        if ( !isActive() ) {
            return;
        }
        removeNotationalListeners();
        removeSemanticListeners();
        if (listenerFilters != null ) {
            for (Iterator i = listenerFilters.keySet().iterator(); i.hasNext();) {
                Object[] obj = (Object[]) listenerFilters.get(i.next());
                if (obj.length>2){
                    getDiagramEventBroker().
                        removeNotificationListener((EObject)obj[0],(EStructuralFeature) obj[1],(NotificationListener) obj[2]);
                }else {
                    getDiagramEventBroker().removeNotificationListener((EObject) obj[0],(NotificationListener) obj[1]);
                }
            }
        }
        super.deactivate();
    }

    public void removeNotify() {
        
        View view = getNotationView();
        if (view != null && !view.isVisible()){
            setConnectionsVisibility(false);
        }
        
        super.removeNotify();
        
        if (cachedFontData != null) {
            getResourceManager().destroyFont(
                FontDescriptor.createFrom(cachedFontData));
            cachedFontData = null;
        }

    }

    /**
     * executes the passed <code>Command</code>
     * @@param command the command to exectue
     */
    protected void executeCommand(Command command) {
        getViewer().getEditDomain().getCommandStack().execute(command);
    }
    
    /**
     * Access the model member variable
     * @@return
     */
    final protected Object basicGetModel(){
        return super.getModel();
    }

    /** Adds the ability to adapt to the edit part's view class. */
    public Object getAdapter(Class key) {       

        // Adapt to IActionFilter
        if (key == IActionFilter.class) {
            return ActionFilterService.getInstance();
        }

        if (View.class.isAssignableFrom(key)) {
            Object _model = getModel();
            if (key.isInstance(_model))
                return _model;
            else
                return null;
        }

        if (key == SnapToHelper.class) {
            return SnapToHelperUtil.getSnapHelper(this);
        }

        Object model = basicGetModel();
        if (model != null &&
            EObject.class.isAssignableFrom(key)) {
            // Adapt to semantic element
            EObject semanticObject = null;
            if (hasNotationView()){
                semanticObject = ViewUtil.resolveSemanticElement((View)model);
            }
            else{
                EObject element = (EObject)model;
                if (element.eIsProxy()){
                    semanticObject = EMFCoreUtil.resolve(getEditingDomain(), element);
                }
            }
            if ((semanticObject!=null) && key.isInstance(semanticObject)) {
                return semanticObject;
            }
            else if (key.isInstance(model)){
                return model;
            }
            
        }

        // Delegate
        return super.getAdapter(key);
    }

    /**
     * Utility method to get the primary view and then query for a child based on the
     * semantic hint
     * 
     * @@param semanticHint <code>String</code> that is the hint that can retrieved on the getType
     * method of <code>View</code>
     * @@return <code>IGraphicalEditPart</code> that matches with the given semanticHint
     */
    public IGraphicalEditPart getChildBySemanticHintOnPrimaryView(String semanticHint) {
        View primaryView = getPrimaryView();
        View childView = ViewUtil.getChildBySemanticHint(primaryView, semanticHint);
        if (childView != null)
            return  (IGraphicalEditPart)getViewer().getEditPartRegistry().get(childView);

        return null;
    }
    
    /**
     * Method getChildBySemanticHint.
     * 
     * @@param semanticHint
     * @@return IGraphicalEditPart
     */
    public IGraphicalEditPart getChildBySemanticHint(String semanticHint) {
        View view;
        if (hasNotationView() && (view = (View) super.getModel()) != null) {
            view = ViewUtil.getChildBySemanticHint(view,semanticHint);
            if (view != null){
                IGraphicalEditPart ep =   (IGraphicalEditPart)getViewer().getEditPartRegistry().get(view);
                // TODO remove this code after the clients change there code to 
                // be aware of the on demand editpart creation
                if (ep == null){
                    // the ep had not been created yet, create a dummy one 
                    ep  =  new DummyEditPart(view);
                }
                return ep;
            }
        }
        return null;
    }
    
    /**
     * Method getChildViewBySemanticHint.
     * 
     * @@param semanticHint
     * @@return IGraphicalEditPart
     */
    public View getChildViewBySemanticHint(String semanticHint) {
        View view;
        if (hasNotationView() && (view = (View) super.getModel()) != null) {
            return ViewUtil.getChildBySemanticHint(view, semanticHint);
        }
        return null;
    }

    
    /** counter that tracs the recursive depth of the getCommand() method. */
    private static volatile int GETCOMMAND_RECURSIVE_COUNT = 0;
    
    /** A list of editparts who's canonical editpolicies are to be temporarily disabled. */
    private static Set _disableCanonicalEditPolicyList = new HashSet();
    

    /** Return a command for the supplied request. */
    public Command getCommand(Request _request) {
        if ( !isEditModeEnabled() ) {
            if (RequestConstants.REQ_OPEN.equals(_request.getType())) {
                //allowed, continue
            }
            else {
                return UnexecutableCommand.INSTANCE;
            }           
        }
        
        Command cmd = null;
        try {
            GETCOMMAND_RECURSIVE_COUNT++;
            final Request request = _request;
            try {
                cmd = (Command) getEditingDomain().runExclusive(
                    new RunnableWithResult.Impl() {

                        public void run() {
                            setResult(GraphicalEditPart.super
                                .getCommand(request));
                        }
                    });
            } catch (InterruptedException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "getCommand", e); //$NON-NLS-1$
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                    "getCommand", e); //$NON-NLS-1$
            }
            

            if ( cmd != null ) {
                _disableCanonicalEditPolicyList.addAll(disableCanonicalFor(_request));
            }
            
            GETCOMMAND_RECURSIVE_COUNT--;
            
            if ( GETCOMMAND_RECURSIVE_COUNT == 0 ) {
                if ( cmd != null 
                        && !_disableCanonicalEditPolicyList.isEmpty() ) {
                    CompoundCommand cc = new CompoundCommand();
                    cc.setLabel( cmd.getLabel() );
                    ToggleCanonicalModeCommand tcmd = 
                        ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(_disableCanonicalEditPolicyList, false);
                    cc.add( tcmd );
                    cc.add( cmd );
                    ToggleCanonicalModeCommand tcmd2 = ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(tcmd, true);
                    if (tcmd2 != null) {
                        tcmd2.setDomain(getEditingDomain());
                    }
                    cc.add( tcmd2 );
                    _disableCanonicalEditPolicyList.clear();
                    return cc.unwrap();
                }
            }
        }
        catch( RuntimeException t ) {
            GETCOMMAND_RECURSIVE_COUNT = 0;
            throw t;
        }
        return cmd;
        
    }
    
    /**
     * Return a list of editparts who's canonical editpolicies should be disabled
     * prior to executing the commands associated to the supplied request.
     * This implementation will return the editpart honoring a <code>SemanticWrapperRequest</code>
     * and a <code>CreateConnectionViewRequest</code>'s source and target editparts.
     *
     * @@param request a request that has returned a command.
     * @@return list of editparts.
     */
    protected Collection disableCanonicalFor( final Request request ) {
        //
        // not the most generic of solution; however, it will have to do for now...
        //
        // Alternate solutions
        // 1. common request interface on all the requests
        //  IRequest#getAffectedEditParts
        //
        // 2. Traverse down the command and collect of the ICommand#getAffectedObjects()
        //  -- this requires that all our commands properly set this value.
        
        Set hosts = new HashSet();
        if ( (request instanceof EditCommandRequestWrapper)  
                || request instanceof TargetRequest
                || request instanceof DropRequest ) {
            hosts.add(this);
            hosts.add(getParent());
        }
        if((request instanceof ReconnectRequest)) {
            ReconnectRequest reconnect = (ReconnectRequest)request;
            hosts.add(this);
            hosts.add(getParent());
            if(reconnect.getTarget() != null) {
                EditPart target  = reconnect.getTarget();
                addEditPartAndParent(hosts, target);
            }
            if(reconnect.getConnectionEditPart() != null) {
                org.eclipse.gef.ConnectionEditPart connectionEditPart = reconnect.getConnectionEditPart();
                if(connectionEditPart.getSource() != null) {
                    EditPart srcEP = connectionEditPart.getSource();
                    addEditPartAndParent(hosts, srcEP);
                }
                if(connectionEditPart.getTarget() != null) {
                    EditPart trgEP = connectionEditPart.getTarget();
                    addEditPartAndParent(hosts, trgEP);
                }
            }
        }
        if ((request instanceof CreateConnectionRequest) ) {
            CreateConnectionRequest ccvr = (CreateConnectionRequest)request;
            hosts.add(this);
            hosts.add(getParent());
            if ( ccvr.getSourceEditPart() != null ) {
                hosts.add( ccvr.getSourceEditPart());
                hosts.add( ccvr.getSourceEditPart().getParent());
            }
            if ( ccvr.getTargetEditPart() != null ) {
                hosts.add( ccvr.getTargetEditPart());
                hosts.add( ccvr.getTargetEditPart().getParent());
            }
        }
        if ((request instanceof GroupRequest)) {
            List parts = ((GroupRequest)request).getEditParts();
            hosts.add(this);
            hosts.add(getParent());
        
            Iterator editparts = parts == null ? Collections.EMPTY_LIST.iterator() : parts.iterator();  
            while ( editparts.hasNext() ) {
                EditPart ep = (EditPart)editparts.next();
                addEditPartAndParent(hosts, ep);
            }
        }
        
        /////////////////////////////////////////////////////////////
        // This following behavior is specific to BorderItemEditPart and
        // AbstractBorderItemEditPart, but we do not want to allow clients to
        // override this method so we do not want to make it protected.
        
        if (this instanceof IBorderItemEditPart) {
            if ((request instanceof CreateConnectionViewRequest)) {
                CreateConnectionViewRequest ccvr = (CreateConnectionViewRequest) request;
                if (ccvr.getSourceEditPart() instanceof IBorderItemEditPart) {
                    hosts.add(ccvr.getSourceEditPart().getParent().getParent());
                }
                if (ccvr.getTargetEditPart() instanceof IBorderItemEditPart) {
                    hosts.add(ccvr.getTargetEditPart().getParent().getParent());
                }
            }
        }
        /////////////////////////////////////////////////////////////

        return hosts;
    }

    private void addEditPartAndParent(Set hosts, EditPart editPart) {
        hosts.add(editPart);
        hosts.add(editPart.getParent());
    }

    /**
     * gets the content pane for the supplied editpart.
     * @@param editPart the edit part to use to get the contents pane
     * @@return <code>IFigure</code>
     */
    protected IFigure getContentPaneFor(IGraphicalEditPart editPart) {
        return getContentPane();
    }

    /**
     * Convenience method returning the editpart's parimary view. 
     * @@return the diagram
     */
    protected Diagram getDiagramView() {
        return (Diagram) getRoot().getContents().getModel();
    }

    /**
     * Convenience method returning the editpart's parimary view. Same as
     * calling <code>getView().getPrimaryView()</code>
     */
    public final View getPrimaryView() {
        for (EditPart parent = this; parent != null; parent = parent.getParent())
            if (parent instanceof IPrimaryEditPart && parent.getModel() instanceof View)
                return (View)parent.getModel();
        return null;
    }

    /**
     * gets this editpart's edit domain.
     * @@return the edit domain
     */
    protected EditDomain getEditDomain() {
        EditDomain result = null;

        try {
            result = getRoot().getViewer().getEditDomain();
        } catch (NullPointerException nullPointerException) {
            /*
             * The reason why we would the code in try block throws a NPE is
             * partly because when the diagram is saved as another diagram, the
             * an event is generated which forces the refreshing of the
             * properties and if the selection is this editpart, then in order
             * to open a read action, properties provider will grab its
             * editDomain. Since this editPart would be in the state of flux and
             * may not have the root or the viewer set yet, therefore, a null
             * pointer exception can be thrown.
             *  
             */
            return null;
        }
        return result;
    }

    /** Return the editpart's diagram edit domain. */
    public IDiagramEditDomain getDiagramEditDomain() {
        return (IDiagramEditDomain) getEditDomain();
    }

    /**
     * Return this editpart's view (model) children.
     * 
     * @@return list of views.
     */
    protected List getModelChildren() {
        Object model = getModel();
        if(model!=null && model instanceof View){
            return new ArrayList(((View)model).getVisibleChildren());
        }
        return Collections.EMPTY_LIST;
    }
    
    /**
     * Convenience method to retreive the value for the supplied value from the
     * editpart's associated view element. Same as calling
     * <code> ViewUtil.getStructuralFeatureValue(getNotationView(),feature)</code>.
     */
    public Object getStructuralFeatureValue(EStructuralFeature feature) {
        if (hasNotationView())
            return ViewUtil.getPropertyValue((View) super.getModel(), feature,
                feature.getEContainingClass());
        else
            return null;
    }

    
    /**
     * gets the semantic element associated to this editpart.
     * @@return the semantic element or <code>null</code> if the semantic element was
     * <code>null</code> or unresolvable 
     */
    public EObject resolveSemanticElement() {
        EObject semanticElement = null;
        Object basicModel = basicGetModel();
        if (hasNotationView()) {
            semanticElement = ((View) basicModel).getElement();
        } else if (basicModel instanceof EObject) {
            semanticElement = (EObject) basicModel;
        }
        if (semanticElement == null) {
            return null;
        }

        if (!semanticElement.eIsProxy()) {
            return semanticElement;
        }

        try {
            return (EObject) getEditingDomain().runExclusive(
                new RunnableWithResult.Impl() {

                    public void run() {
                        Object model = getModel();
                        if (model instanceof View) {
                            setResult(ViewUtil
                                .resolveSemanticElement((View) getModel()));
                        } else if (model instanceof EObject) {
                            EObject element = (EObject) model;
                            if (element.eIsProxy())
                                setResult(EMFCoreUtil.resolve(
                                    getEditingDomain(), element));
                            else
                                setResult(element);
                        }
                    }
                });
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "resolveSemanticElement", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "resolveSemanticElement", e); //$NON-NLS-1$
            return null;
        }

    }

    /**
     * Walks up the editpart hierarchy to find and return the
     * <code>TopGraphicEditPart</code> instance.
     */
    public TopGraphicEditPart getTopGraphicEditPart() {
        EditPart editPart = this;
        while (editPart instanceof IGraphicalEditPart) {
            if (editPart instanceof TopGraphicEditPart)
                return (TopGraphicEditPart) editPart;
            editPart = editPart.getParent();
        }
        return null;
    }

    /**
     * Return the editpart's associated Notation View.
     * @@return <code>View</code>, the associated view or null if there is no associated Notation View
     */
    public View getNotationView() {
        Object model = getModel();
        if (model instanceof View)
            return (View)model;
        return null;
    }

    /**
     * Method reactivateSemanticModel. This method reactivates the edit part's
     * emantic model by: 1- removing semantic listeners 2- adding semantic
     * listeners if the semantic reference is resolvable 3- Refreshing it
     * 
     * This method is called in response to IView's Properties.ID_SEMANTICREF
     * property change event However, it will only work under the following
     * assumptions: 1- The old and new semantic models are compatible in their
     * kind 2- The deltas between old and new semantic models do not affect
     * notation 3- Connections are not refereshed since they are maintained by
     * the diagram
     */
    protected void reactivateSemanticModel() {
        removeSemanticListeners();
        if (resolveSemanticElement() != null)
            addSemanticListeners();
    }

    /** Finds an editpart given a starting editpart and an EObject */
    public EditPart findEditPart(EditPart epBegin, EObject theElement) {
        if (theElement == null) {
            return null;
        }
        EditPart epStart = null;
        if (epBegin == null) {
            epStart = this;
        } else {
            epStart = epBegin;
        }

        final View view = (View) ((IAdaptable) epStart)
            .getAdapter(View.class);

        if (view != null) {
            EObject el = ViewUtil.resolveSemanticElement(view);

            if ((el != null) && el.equals(theElement)) {
                return epStart;
            }
        }

        ListIterator childLI = epStart.getChildren().listIterator();
        while (childLI.hasNext()) {
            EditPart epChild = (EditPart) childLI.next();

            EditPart elementEP = findEditPart(epChild, theElement);
            if (elementEP != null) {
                return elementEP;
            }
        }
        return null;
    }

    /** Invoke the editpart's refresh mechanism. */
    public void refresh() {
        try {
            getEditingDomain().runExclusive(new Runnable() {
    
                public void run() {
                    EditPolicyIterator i = getEditPolicyIterator();
                    while (i.hasNext()) {
                        EditPolicy policy = i.next();
                        if (policy instanceof GraphicalEditPolicyEx) {
                            ((GraphicalEditPolicyEx) policy).refresh();
                        }
                    }
                    GraphicalEditPart.super.refresh();
                }
            });
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "refresh", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "refresh", e); //$NON-NLS-1$
        }

    }

    /** Refresh the editpart's figure background colour. */
    protected void refreshBackgroundColor() {
        FillStyle style = (FillStyle)getPrimaryView().getStyle(NotationPackage.Literals.FILL_STYLE);
        if ( style != null ) {
            setBackgroundColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getFillColor())));
        }
    }

    /** Refresh the editpart's figure font. */
    protected void refreshFont() {
        FontStyle style = (FontStyle) getPrimaryView().getStyle(NotationPackage.Literals.FONT_STYLE);
        if (style != null) {
            setFont(new FontData(
                style.getFontName(), 
                style.getFontHeight(), 
                (style.isBold() ? SWT.BOLD : SWT.NORMAL) | 
                (style.isItalic() ? SWT.ITALIC : SWT.NORMAL)));
        }
    }

    /** Refresh the editpart's figure font colour. */
    protected void refreshFontColor() {
        FontStyle style = (FontStyle)  getPrimaryView().getStyle(NotationPackage.Literals.FONT_STYLE);
        if ( style != null ) {
            setFontColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getFontColor())));
        }
    }

    /** Refresh the editpart's figure foreground colour. */
    protected void refreshForegroundColor() {
        LineStyle style = (LineStyle)  getPrimaryView().getStyle(NotationPackage.Literals.LINE_STYLE);
        if ( style != null ) {
            setForegroundColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getLineColor())));
        }
    }

    /** Refresh the editpart's figure visibility. */
    protected void refreshVisibility() {
        Object model = null;
        EditPart ep = this;
        while (!(model instanceof View) && ep!=null){
            model = ep.getModel();
            ep = ep.getParent();
        }
        if (model instanceof View)
            setVisibility(((View)model).isVisible());
    }

    /** Refresh the editpart's figure visual properties. */
    protected void refreshVisuals() {
        super.refreshVisuals();
        refreshVisibility();
    }

    /**
     * Removes a listener previously added with the given id
     * 
     * @@param filterId the filter ID
     */
    protected void removeListenerFilter(String filterId) {
        if (listenerFilters == null)
            return;
        Object[] objects = (Object[]) listenerFilters.remove(filterId);
        if (objects == null)
            return;
        if (objects.length>2){
            getDiagramEventBroker().
                removeNotificationListener((EObject) objects[0],
                                             (EStructuralFeature) objects[1],
                                             (NotificationListener) objects[2]);
        }else{
            getDiagramEventBroker().removeNotificationListener((EObject) objects[0],(NotificationListener) objects[1]);
        }
        
    }

    /**
     * sets the back ground color of this edit part
     * @@param color the new value of the back ground color
     */
    protected void setBackgroundColor(Color color) {
        getFigure().setBackgroundColor(color);
    }

    /**
     * Sets the font to the label.
     * This method could be overriden to change the font data of the font
     * overrides typically look like this:
     *      super.setFont(
     *      new FontData(
     *          fontData.getName(),
     *          fontData.getHeight(),
     *          fontData.getStyle() <| &> SWT.????));
     * @@param fontData the font data
     */
    protected void setFont(FontData fontData) {
         if (cachedFontData != null && cachedFontData.equals(fontData)) {
            // the font was previously set and has not changed; do nothing.
            return;
        }

        try {
            Font newFont = getResourceManager().createFont(
                FontDescriptor.createFrom(fontData));
            getFigure().setFont(newFont);
            getFigure().repaint();

            if (cachedFontData != null) {
                getResourceManager().destroyFont(
                    FontDescriptor.createFrom(cachedFontData));
            }
            cachedFontData = fontData;
        } catch (DeviceResourceException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "setFont", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "setFont", e); //$NON-NLS-1$
        }
    }

    /**
     * sets the font color
     * @@param color the new value of the font color
     */
    protected void setFontColor(Color color) {
        // NULL implementation
    }

    /**
     * sets the fore ground color of this edit part's figure
     * @@param color the new value of the foregroundcolor
     */
    protected void setForegroundColor(Color color) {
        getFigure().setForegroundColor(color);
    }
    
    /**
     * Sets the passed feature if possible on this editpart's view
     * to the passed value.
     * @@param feature the feature to use
     * @@param value  the value of the property being set
     */
    public void setStructuralFeatureValue(EStructuralFeature feature, Object value) {
        if (hasNotationView() && (feature != null)) {
            ViewUtil.setPropertyValue((View) super.getModel(), feature, feature
                .getEContainingClass(), value);
        }
    }

    /**
     * sets the visibility of this edit part
     * @@param vis the new value of the visibility
     */
    protected void setVisibility(boolean vis) {
        if (!vis && getSelected() != SELECTED_NONE)
            getViewer().deselect(this);
        
        IFigure _figure = getFigure();
        if (_figure.isVisible()==vis){
            return;
        }
        
        // if we are going to hide the node then connections comming to the
        // node or outside it should be hidden as well
        setConnectionsVisibility(vis);
        _figure.setVisible(vis);
        _figure.revalidate();
    }
    
    protected void setConnectionsVisibility(boolean visibility) {
        List _srcConnections = getSourceConnections();
        for (Iterator iter = _srcConnections.iterator(); iter.hasNext();) {
            ConnectionEditPart connection = (ConnectionEditPart) iter.next();
            if (connection.getFigure().isVisible()!=visibility)
                connection.setVisibility(visibility);
        }
        
        List _targetConnections = getTargetConnections();
        for (Iterator iter = _targetConnections.iterator(); iter.hasNext();) {
            ConnectionEditPart connection = (ConnectionEditPart) iter.next();
            if (connection.getFigure().isVisible()!=visibility)
                connection.setVisibility(visibility);
        }
        
    }

    /**
     * This method adds all listeners to the notational world (views, figures,
     * editpart...etc) Override this method to add more notational listeners
     * down the hierarchy
     */
    protected void addNotationalListeners() {
        if (hasNotationView()){
            addListenerFilter("View", this,(View)getModel()); //$NON-NLS-1$
        }
    }
    
    /**
     * This method adds all listeners to the semantic element behind this EditPart
     * Override this method to add more semantic listeners down the hierarchy
     * This method is called only if the semantic element is resolvable
     */
    protected void addSemanticListeners() {
        addListenerFilter("SemanticElement", this,resolveSemanticElement());//$NON-NLS-1$
    }

    /**
     * This method removes all listeners to the notational world (views,
     * figures, editpart...etc) Override this method to remove notational
     * listeners down the hierarchy
     */
    protected void removeNotationalListeners() {
        removeListenerFilter("View"); //$NON-NLS-1$
    }

    /**
     * This method removes all listeners to the semantic element behind this EditPart
     * Override this method to remove semantic listeners
     * down the hierarchy
     */
    protected void removeSemanticListeners() {
        removeListenerFilter("SemanticElement"); //$NON-NLS-1$
    }

    /**
     * Perform a request by executing a command from the target editpart of the
     * request For the Direct_Edit request, we need to show up an editor first
     * 
     * @@see org.eclipse.gef.EditPart#performRequest(org.eclipse.gef.Request)
     */
    public void performRequest(Request request) {
        if ( !isEditModeEnabled() ) {
            if (RequestConstants.REQ_OPEN.equals(request.getType())) {
                //allowed, continue
            }
            else {
                return;
            }
        }
        
        if (RequestConstants.REQ_DIRECT_EDIT == request.getType()) {
            performDirectEditRequest(request);
        } else {
            EditPart targetEditPart = getTargetEditPart(request);
            if (targetEditPart != null) {
                Command command = targetEditPart.getCommand(request);
                if (command != null) {
                    getDiagramEditDomain().getDiagramCommandStack().execute(
                        command);
                    return;
                }
            }
        }
    }

    /**
     * Performs a direct edit request (usually by showing some type of editor)
     * 
     * @@param request
     *            the direct edit request
     */
    protected void performDirectEditRequest(Request request) {
        // NULL implementation
    }

    /**
     * @@see org.eclipse.gef.editparts.AbstractEditPart#getAccessibleEditPart()
     */
    protected AccessibleEditPart getAccessibleEditPart() {
        if (accessibleEP == null)
            accessibleEP = new AccessibleGraphicalEditPart() {

            private String getSemanticName() {
                EObject semanticElement = resolveSemanticElement();
            
                if( semanticElement != null ) {
                    String name = semanticElement.getClass().getName();
                    int startIndex = name.lastIndexOf('.') + 1;
                    int endIndex = name.lastIndexOf( "Impl" ); //$NON-NLS-1$
                    return name.substring(startIndex, endIndex);
                }
            
                return null;
            }

            public void getName(AccessibleEvent e) {
                IGraphicalEditPart childEP = getChildBySemanticHint(CommonParserHint.NAME);
                if (childEP == null) {
                    childEP = getChildBySemanticHint(CommonParserHint.DESCRIPTION);
                }
                if (childEP != null) {
                    ILabelDelegate label = (ILabelDelegate) childEP.getAdapter(ILabelDelegate.class);
                    if (label != null) {
                        e.result = label.getText();
                    }
                } else {
                    e.result = getSemanticName();
                }
            }
            };

        return accessibleEP;
    }

    /** Adds a [ref, editpart] mapping to the EditPartForElement map. */
    protected void registerModel() {
        EditPartViewer viewer = getViewer();
        if (hasNotationView()) {
            super.registerModel();
        } else {
            viewer.getEditPartRegistry().put(basicGetModel(), this);
        }

        // Save the elements Guid to use during unregister.
        // If the reference is null, do not register.
        EObject ref = null;
        if (hasNotationView())
            ref = getNotationView().getElement();
        else
            ref = (EObject) basicGetModel();
        if (ref == null) {
            return;
        }
        elementGuid = EMFCoreUtil.getProxyID(ref);
        ((IDiagramGraphicalViewer) viewer).registerEditPartForElement(
            elementGuid, this);
    }


    /** Remove this editpart from the EditPartForElement map. */
    protected void unregisterModel() {
        EditPartViewer viewer = getViewer();
        if (hasNotationView())
            super.unregisterModel();
        else {
            Map registry = viewer.getEditPartRegistry();
            if (registry.get(basicGetModel()) == this)
                registry.remove(basicGetModel());
        }

        //Do not need to unregister if the guid is null.
        if (elementGuid == null) {
            return;
        }
        ((IDiagramGraphicalViewer) viewer).unregisterEditPartForElement(
            elementGuid, this);
    }

    /**
     * Refreshes a child editpart by removing it and refreshing children
     * @@param child the child to refresh
     */
    protected final void refreshChild(GraphicalEditPart child) {
        removeChild(child);
        refreshChildren();
    }
    
    /**
     * Refreshes a source connection editpart by removing it and refreshing source connections
     * @@param conn the connection to refresh
     */
    protected final void refreshSourceConnection(ConnectionEditPart conn) {
        removeSourceConnection(conn);
        refreshSourceConnections();
    }

    /**
     * Refreshes a target connection editpart by removing it and refreshing target connections
     * @@param conn the connection to refresh
     */
    protected final void refreshTargetConnection(ConnectionEditPart conn) {
        removeTargetConnection(conn);
        refreshTargetConnections();
    }

    /**
     * Handles the case where the semantic reference has changed.
     */
    protected final void handleMajorSemanticChange() {
        if (getParent() instanceof GraphicalEditPart)
            ((GraphicalEditPart) getParent()).refreshChild(this);
        else if (getParent() instanceof ConnectionEditPart)
            ((ConnectionEditPart) getParent()).refreshChild(this);
    }
    
    /**
     * @@see org.eclipse.gef.EditPart#getDragTracker(org.eclipse.gef.Request)
     */
    public DragTracker getDragTracker(Request request) {
        return new DragEditPartsTrackerEx(this);
    }

    /**
     * @@return <tt>true</tt> a canonical editpolicy has been installed on this editpart
     * and it is active; otherwise <tt>false</tt>.
     */
    public boolean isCanonical() {
        CanonicalEditPolicy policy = (CanonicalEditPolicy)getEditPolicy(EditPolicyRoles.CANONICAL_ROLE);
        return policy == null ? false : policy.isActive();
    }

    /**
     * Return <tt>true</tt> if the editpart's figure is visible;
     * <tt>false</tt> otherwise.
     */
    public boolean isSelectable() {
        return getFigure().isShowing();
    }

    /* 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#disableEditMode()
     */
    public void disableEditMode() {
        if (!isEditModeEnabled()) {
            return;
        }

        List l = getSourceConnections();
        int size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        List c = getChildren();
        size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        isEditable = false;
    }
    
    
    
    protected void addChild(EditPart child, int index) {
        super.addChild(child, index);
        if (child instanceof GraphicalEditPart){
            GraphicalEditPart gEP = (GraphicalEditPart)child;
            boolean editMode = isEditModeEnabled(); 
            if (editMode != gEP.isEditModeEnabled()){
                if (editMode)
                    gEP.enableEditMode();
                else
                    gEP.disableEditMode();
            }
        }
    }

    /* 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#enableEditMode()
     */
    public void enableEditMode() {
        if (isEditModeEnabled()) {
            return;
        }

        isEditable = true;

        List c = getChildren();
        int size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }

        List l = getSourceConnections();
        size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }
    }
    
    /* 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#isEditModeEnabled()
     */
    public boolean isEditModeEnabled() {
        // protect against deadlock - don't allow any action while write transaction
        // is active on another thread
        if (EditPartUtil.isWriteTransactionInProgress(this, true, true))
            return false;
        return isEditable;
    }
    
    /* 
     * @@see org.eclipse.gef.EditPart#showSourceFeedback(org.eclipse.gef.Request)
     */
    public void showSourceFeedback(Request request) {
        if ( !isEditModeEnabled()) {
            return;
        }
        
        super.showSourceFeedback(request);
    }
    
    /* 
     * @@see org.eclipse.gef.EditPart#showTargetFeedback(org.eclipse.gef.Request)
     */
    public void showTargetFeedback(Request request) {
        if ( !isEditModeEnabled()) {
            return;
        }
        
        super.showTargetFeedback(request);
    }

    /* 
     * @@see org.eclipse.gef.EditPart#eraseSourceFeedback(org.eclipse.gef.Request)
     */
    public void eraseSourceFeedback(Request request) {
        if ( !isEditModeEnabled()) {
            return;
        }
        
        super.eraseSourceFeedback(request);
    }
    /* 
     * @@see org.eclipse.gef.EditPart#eraseTargetFeedback(org.eclipse.gef.Request)
     */
    public void eraseTargetFeedback(Request request) {
        if ( !isEditModeEnabled()) {
            return;
        }

        super.eraseTargetFeedback(request);
    }
    
    /**
     * this method will return the primary child EditPart  inside this edit part
     * @@return the primary child view inside this edit part
     */
    public EditPart getPrimaryChildEditPart(){
        if (getChildren().size() > 0)
            return (EditPart) getChildren().get(0);
        return null;
    }
    
    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramPreferencesHint()
     */
    public PreferencesHint getDiagramPreferencesHint() {
        RootEditPart root = getRoot();
        if (root instanceof IDiagramPreferenceSupport) {
            return ((IDiagramPreferenceSupport) root).getPreferencesHint();
        }
        return PreferencesHint.USE_DEFAULTS;
    }

    public void notifyChanged(Notification notification) {
        if (isActive()){
            handleNotificationEvent(notification);
        }
    }
    
    public Command transactionAboutToCommit(Notification notification) {
        return null;
    }

    
    /**
     * Handles the property changed event.  Clients should override to
     * respond to the specific notification events they are interested.
     * 
     * Note: This method may get called on a non-UI thread.  Clients should
     * either ensure that their code is thread safe and/or doesn't make
     * unsupported calls (i.e. Display.getCurrent() ) assuming they are on
     * the main thread.  Alternatively if this is not possible, then the
     * client can wrap their handler within the Display.synchExec runnable
     * to ensure synchronization and subsequent execution on the main thread.
     * 
     * @@param event
     *            the <code>Notification</code> object that is the property changed event
     */
    protected void handleNotificationEvent(Notification event) {        
        if (NotationPackage.Literals.VIEW__PERSISTED_CHILDREN.equals(event.getFeature())||
                NotationPackage.Literals.VIEW__TRANSIENT_CHILDREN.equals(event.getFeature())) {
            refreshChildren();
        }else if (NotationPackage.Literals.VIEW__VISIBLE.equals(event.getFeature())) {
            Object notifier = event.getNotifier();
            if (notifier== getModel())
                refreshVisibility();
            else{
                // refresh the children only if the notificatino is not comming for and edge
                // sincethe children list had no edges
                if (!(event.getNotifier() instanceof Edge))
                    refreshChildren();
            }
        }
        else if (NotationPackage.Literals.VIEW__ELEMENT.equals(event.getFeature())) {
            handleMajorSemanticChange();
        } 
    }
    
    /**
     * @@return <code>IMapMode</code> that allows for the coordinate mapping from device to
     * logical units. 
     */
     protected IMapMode getMapMode() {
        RootEditPart root = getRoot();
        if (root instanceof DiagramRootEditPart) {
            DiagramRootEditPart dgrmRoot = (DiagramRootEditPart)root;
            return dgrmRoot.getMapMode();
        }
        
        return MapModeUtil.getMapMode();
    }
    
    /**
     * indicates if this edit part's model is a view or not 
     * @@return <code>true</code> or <code>false</code>
     */
    public boolean hasNotationView(){
        return true;
    }
    
    /**
     * Returns tis edit part's model; the returned values is not granteed to be 
     * <code>View</code>, the return value could be null or any Object depending
     * on the edit part implementation 
     * 
     */
    public Object getModel() {
        if (hasNotationView()){
            return super.getModel();
        } else {
            Object _model = basicGetModel();
            Node node = NotationFactory.eINSTANCE.createNode();;
            node.setElement((EObject)_model);
            return node;
        }
    }
    
    /**
     * Derives my editing domain from my model or my diagram element. Subclasses
     * may override.
     */
    public TransactionalEditingDomain getEditingDomain() {
        if (editingDomain == null) {
            // try to get the editing domain for the model
            editingDomain = TransactionUtil.getEditingDomain(getModel());
            
            if (editingDomain == null) {
                // try to get the editing domain from the diagram view
                editingDomain = TransactionUtil.getEditingDomain(getDiagramView());
            }
        }
        return editingDomain;
    }
    
    protected IFigure createFigure() {
        // TODO Auto-generated method stub
        return null;
    }

    public void setModel(Object model) {
        // reset the editing domain cache
        editingDomain = null;
        super.setModel(model);
    }

    /**
     * Gets the diagram event broker from the editing domain.
     * 
     * @@return the diagram event broker
     */
    private DiagramEventBroker getDiagramEventBroker() {
        TransactionalEditingDomain theEditingDomain = getEditingDomain();
        if (theEditingDomain != null) {
            return DiagramEventBroker.getInstance(theEditingDomain);
        }
        return null;
    }

    // documentation copied from superclass
    public RootEditPart getRoot() {
        if (getParent() != null) {
            return super.getRoot();
        }
        return null;
    }
    
   public Object getPreferredValue(EStructuralFeature feature) {
        Object preferenceStore = getDiagramPreferencesHint()
            .getPreferenceStore();
        if (preferenceStore instanceof IPreferenceStore) {
            if (feature == NotationPackage.eINSTANCE.getLineStyle_LineColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_LINE_COLOR));
                
            } else if (feature == NotationPackage.eINSTANCE
                .getFontStyle_FontColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_FONT_COLOR));
                
            } else if (feature == NotationPackage.eINSTANCE
                .getFillStyle_FillColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_FILL_COLOR));
                
            }
        }

        return getStructuralFeatureValue(feature);
    }    
    /**
     * Gets the resource manager to remember the resources allocated for this
     * graphical viewer. All resources will be disposed when the graphical
     * viewer is closed if they have not already been disposed.
     * 
     * @@return the resource manager
     */
    protected ResourceManager getResourceManager() {
        EditPartViewer viewer = getViewer();
        if (viewer instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) viewer).getResourceManager();
        }
        return JFaceResources.getResources();
    }    
    
	/**
	 * Set the line width of the shape. Clients need to override if they support
	 * line width.
	 * 
	 * @@param width
	 *            the line width.
	 */
	protected void setLineWidth(int width) {
		/* not implemented */
	}

	/**
	 * Get the line width of the shape.
	 * 
	 * @@return width the line width.
	 */
	protected int getLineWidth() {
		/* a default of -1 means the diagram does not implement line width */
		int lineWidth = -1;

		LineStyle style = (LineStyle) getPrimaryView().getStyle(
				NotationPackage.eINSTANCE.getLineStyle());
		if (style != null) {
			lineWidth = style.getLineWidth();
		}

		return lineWidth;
	}

	/**
	 * Refresh the line width of the shape.
	 */
	protected void refreshLineWidth() {
		setLineWidth(getLineWidth());
	}

	/**
	 * Set the line type of the shape. Clients need to override if they support
	 * line type.
	 * 
	 * @@param lineType
	 *            the line type.
	 */
	protected void setLineType(int lineType) {
		/* not implemented */
	}

	/**
	 * Get the line type of the shape.
	 * 
	 * @@return the line type.
	 */
	protected int getLineType() {
		// default to a solid line.
		int lineType = Graphics.LINE_SOLID;

		LineTypeStyle style = (LineTypeStyle) getPrimaryView().getStyle(
				NotationPackage.eINSTANCE.getLineTypeStyle());
		if (style != null) {
			if (style.getLineType() == LineType.SOLID_LITERAL) {
				lineType = Graphics.LINE_SOLID;
			} else if (style.getLineType() == LineType.DASH_LITERAL) {
				lineType = Graphics.LINE_DASH;
			} else if (style.getLineType() == LineType.DOT_LITERAL) {
				lineType = Graphics.LINE_DOT;
			} else if (style.getLineType() == LineType.DASH_DOT_LITERAL) {
				lineType = Graphics.LINE_DASHDOT;
			} else if (style.getLineType() == LineType.DASH_DOT_DOT_LITERAL) {
				lineType = Graphics.LINE_DASHDOTDOT;
			}
		}

		return lineType;
	}

	/**
	 * Refresh the line type of the shape.
	 */
	protected void refreshLineType() {
		setLineType(getLineType());
	}

}@


1.50
log
@[111901] gmf_head crevells 080111 [KeyboardBindings] Ability to move shapes using cursors keys. (by default)
@
text
@d26 1
d95 2
d1589 82
@


1.49
log
@[162932] gmf_head crevells 071016 [NoteTextLabel] WrapLabel should use Gef's text layout
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d72 1
a72 1
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.SanpToHelperUtil;
d349 1
a349 1
            return SanpToHelperUtil.getSnapHelper(this);
@


1.48
log
@[184081] gmf_head mmostafa 070514 Connection figure shows in the diagram even after its edge (notation) visibility set to FALSE.
@
text
@d75 1
a84 1
import org.eclipse.gmf.runtime.draw2d.ui.figures.WrapLabel;
d1142 3
a1144 3
                    IFigure fig = childEP.getFigure();
                    if (fig instanceof WrapLabel) {
                        e.result = ((WrapLabel) fig).getText();
@


1.47
log
@[170953] gmf_head mmostafa 070118 GraphicalEditPart#disableCanonicalFor should be protected
@
text
@d90 1
d300 6
d1007 11
a1017 3

        getFigure().setVisible(vis);
        getFigure().revalidate();
d1020 17
d1442 5
a1446 2
            else {
                refreshChildren();
@


1.46
log
@[112799]  gmf_head mmostafa 070116 Shapes do not snap to grid when dragged over other shapes
@
text
@d511 1
a511 1
    Collection disableCanonicalFor( final Request request ) {
@


1.45
log
@[162114]   gmf_head mmostafa 061206 GraphicalEditPart refresh creates a child edit part without the correct editable state
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d42 1
d72 1
d340 6
a345 2
        
        Object model = basicGetModel();     
d349 1
a349 1
            EObject semanticObject = null;            
@


1.44
log
@[158731] gmf_head ahunter 061006 Merge 1.0.2 fix to head
@
text
@a100 1
import org.eclipse.jface.util.Assert;
d205 2
a206 2
            Assert.isNotNull(filterId);
            Assert.isNotNull(listener);
d233 2
a234 2
            Assert.isNotNull(filterId);
            Assert.isNotNull(listener);
d1251 16
@


1.43
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d49 1
d524 20
d565 1
a565 2
                hosts.add(ep);
                hosts.add(ep.getParent());
d590 5
@


1.42
log
@bugzilla 143198 gmf-head sshaw 060616 SWTExceptions occurring when handling notifications from worker thread transactions
@
text
@a25 1
import org.eclipse.core.runtime.Platform;
d37 1
a67 1
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DefaultEditableEditPart;
a69 1
import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;
d72 1
d75 1
d80 1
d94 6
a105 1
import org.eclipse.swt.widgets.Display;
d114 2
a115 2
	extends AbstractGraphicalEditPart
	implements IGraphicalEditPart, IAdaptableSelection, NotificationListener {
d118 84
a201 66
	private Map listenerFilters;
	
	/** Used for accessibility. */
	protected AccessibleEditPart accessibleEP;

	/** Used for registering and unregistering the edit part */
	protected String elementGuid;

	/** Used for handling the editable status of the edit part */
	private final IEditableEditPart editableEditPart;
	
	/**
	 * Cache the editing domain after it is retrieved.
	 */
	private TransactionalEditingDomain editingDomain;

	/**
	 * Create an instance.
	 * 
	 * @@param model
	 *            the underlying model.
	 */
	public GraphicalEditPart(EObject model) {
		setModel(model);
		this.editableEditPart = new DefaultEditableEditPart(this);
	}

	/** Registers this editpart to recieve notation and semantic events. */
	public void activate() {
		if (isActive()){
			return;
		}
		addNotationalListeners();
		
		EObject semanticProxy = null;
		if (hasNotationView())
			semanticProxy = ((View) getModel()).getElement();
		else
			semanticProxy = (EObject)basicGetModel();
		
		EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(), semanticProxy);
		
		if (semanticElement != null)
			addSemanticListeners();
		else if (semanticProxy != null) {
			addListenerFilter("SemanticProxy", this, semanticProxy); //$NON-NLS-1$
		}
		GraphicalEditPart.super.activate();
		
	}

	/**
	 * Adds a listener filter by adding the given listener to a passed notifier
	 * 
	 * @@param filterId
	 *            A unique filter id (within the same editpart instance)
	 * @@param listener
	 *            A listener instance
	 * @@param element
	 *            An element to add the listener to
	 */
	protected void addListenerFilter(String filterId,
			NotificationListener listener,
			EObject element) {
		if (element == null)
			return;
d206 3
a208 3
    		Assert.isNotNull(listener);
    		if (listenerFilters == null)
    			listenerFilters = new HashMap();
d210 1
a210 1
    		listenerFilters.put(filterId.intern(), new Object[] {element, listener});
d212 18
a229 18
	}
	
	/**
	 * Adds a listener filter by adding the given listener to a passed notifier
	 * 
	 * @@param filterId
	 *            A unique filter id (within the same editpart instance)
	 * @@param listener
	 *            A listener instance
	 * @@param element
	 *            An element to add the listener to
	 */
	protected void addListenerFilter(String filterId,
			NotificationListener listener,
			EObject element,
			EStructuralFeature feature) {
		if (element == null)
			return;
d242 7
a248 1
	}
d250 31
a280 37
	/** Creates a connection editpart. */
	final protected org.eclipse.gef.ConnectionEditPart createConnection(
			Object connectionView) {
		return (org.eclipse.gef.ConnectionEditPart) createChild(connectionView);
	}

	/**
	 * Overridden to support editpolicies installed programmatically and via the
	 * <code>EditPolicyService</code>. Subclasses should override
	 * <code>createDefaultEditPolicies()</code>.
	 * 
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
	 */
	final protected void createEditPolicies() {
		createDefaultEditPolicies();
		EditPolicyService.getInstance().createEditPolicies(this);
	}

	/**
	 * Should be overridden to install editpolicies programmatically.
	 * 
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
	 */
	protected void createDefaultEditPolicies() {
		installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
			new SemanticEditPolicy());
		installEditPolicy(EditPolicyRoles.PROPERTY_HANDLER_ROLE,
			new PropertyHandlerEditPolicy());
		installEditPolicy(EditPolicyRoles.DECORATION_ROLE,
			new DecorationEditPolicy());
	}

	public void deactivate() {
		if ( !isActive() ) {
			return;
		}
		removeNotationalListeners();
d282 266
a547 250
		if (listenerFilters != null ) {
			for (Iterator i = listenerFilters.keySet().iterator(); i.hasNext();) {
				Object[] obj = (Object[]) listenerFilters.get(i.next());
				if (obj.length>2){
					getDiagramEventBroker().
						removeNotificationListener((EObject)obj[0],(EStructuralFeature) obj[1],(NotificationListener) obj[2]);
				}else {
					getDiagramEventBroker().removeNotificationListener((EObject) obj[0],(NotificationListener) obj[1]);
				}
			}
		}
		super.deactivate();
	}

	/**
	 * executes the passed <code>Command</code>
	 * @@param command the command to exectue
	 */
	protected void executeCommand(Command command) {
		getViewer().getEditDomain().getCommandStack().execute(command);
	}
	
	/**
	 * Access the model member variable
	 * @@return
	 */
	final protected Object basicGetModel(){
		return super.getModel();
	}

	/** Adds the ability to adapt to the edit part's view class. */
	public Object getAdapter(Class key) {
		Object model = basicGetModel();

		// Adapt to IActionFilter
		if (key == IActionFilter.class) {
			return ActionFilterService.getInstance();
		}

		if ( View.class.isAssignableFrom(key)) {
			Object _model = getModel();
			if (key.isInstance(_model))
				return _model;
		}
		
		if (model != null &&
			EObject.class.isAssignableFrom(key)) {
			// Adapt to semantic element
			EObject semanticObject = null;
			if (hasNotationView()){
				semanticObject = ViewUtil.resolveSemanticElement((View)model);
			}
			else{
				EObject element = (EObject)model;
				if (element.eIsProxy()){
					semanticObject = EMFCoreUtil.resolve(getEditingDomain(), element);
				}
			}
			if (key.isInstance(semanticObject)) {
				return semanticObject;
			}
			else if (key.isInstance(model)){
				return model;
			}
			
		}

		// Delegate
		Object adapter = super.getAdapter(key);
		if (adapter != null)
			return adapter;
		return Platform.getAdapterManager().getAdapter(this, key);
	}

	/**
	 * Utility method to get the primary view and then query for a child based on the
	 * semantic hint
	 * 
	 * @@param semanticHint <code>String</code> that is the hint that can retrieved on the getType
	 * method of <code>View</code>
	 * @@return <code>IGraphicalEditPart</code> that matches with the given semanticHint
	 */
	public IGraphicalEditPart getChildBySemanticHintOnPrimaryView(String semanticHint) {
		View primaryView = getPrimaryView();
		View childView = ViewUtil.getChildBySemanticHint(primaryView, semanticHint);
		if (childView != null)
			return  (IGraphicalEditPart)getViewer().getEditPartRegistry().get(childView);

		return null;
	}
	
	/**
	 * Method getChildBySemanticHint.
	 * 
	 * @@param semanticHint
	 * @@return IGraphicalEditPart
	 */
	public IGraphicalEditPart getChildBySemanticHint(String semanticHint) {
		if (getModel()!=null){
			View view = ViewUtil.getChildBySemanticHint((View)getModel(),semanticHint);
			if (view != null){
				IGraphicalEditPart ep =   (IGraphicalEditPart)getViewer().getEditPartRegistry().get(view);
				// TODO remove this code after the clients change there code to 
				// be aware of the on demand editpart creation
				if (ep == null){
					// the ep had not been created yet, create a dummy one 
					ep  =  new DummyEditPart(view);
				}
				return ep;
			}
		}
		return null;
	}
	
	/**
	 * Method getChildViewBySemanticHint.
	 * 
	 * @@param semanticHint
	 * @@return IGraphicalEditPart
	 */
	public View getChildViewBySemanticHint(String semanticHint) {
		if (getModel()!=null){
			return ViewUtil.getChildBySemanticHint((View)getModel(),semanticHint);
		}
		return null;
	}

	
	/** counter that tracs the recursive depth of the getCommand() method. */
	private static volatile int GETCOMMAND_RECURSIVE_COUNT = 0;
	
	/** A list of editparts who's canonical editpolicies are to be temporarily disabled. */
	private static Set _disableCanonicalEditPolicyList = new HashSet();
	

	/** Return a command for the supplied request. */
	public Command getCommand(Request _request) {
		if ( !isEditModeEnabled() ) {
			if (RequestConstants.REQ_OPEN.equals(_request.getType())) {
				//allowed, continue
			}
			else {
				return UnexecutableCommand.INSTANCE;
			}			
		}
		
		Command cmd = null;
		try {
			GETCOMMAND_RECURSIVE_COUNT++;
			final Request request = _request;
			try {
				cmd = (Command) getEditingDomain().runExclusive(
					new RunnableWithResult.Impl() {

						public void run() {
							setResult(GraphicalEditPart.super
								.getCommand(request));
						}
					});
			} catch (InterruptedException e) {
				Trace.catching(DiagramUIPlugin.getInstance(),
					DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
					"getCommand", e); //$NON-NLS-1$
				Log.error(DiagramUIPlugin.getInstance(),
					DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
					"getCommand", e); //$NON-NLS-1$
			}
			

			if ( cmd != null ) {
				_disableCanonicalEditPolicyList.addAll(disableCanonicalFor(_request));
			}
			
			GETCOMMAND_RECURSIVE_COUNT--;
			
			if ( GETCOMMAND_RECURSIVE_COUNT == 0 ) {
				if ( cmd != null 
						&& !_disableCanonicalEditPolicyList.isEmpty() ) {
					CompoundCommand cc = new CompoundCommand();
					cc.setLabel( cmd.getLabel() );
					ToggleCanonicalModeCommand tcmd = 
						ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(_disableCanonicalEditPolicyList, false);
					cc.add( tcmd );
					cc.add( cmd );
					cc.add( ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(tcmd, true));
					_disableCanonicalEditPolicyList.clear();
					return cc.unwrap();
				}
			}
		}
		catch( RuntimeException t ) {
			GETCOMMAND_RECURSIVE_COUNT = 0;
			throw t;
		}
		return cmd;
		
	}
	
	/**
	 * Return a list of editparts who's canonical editpolicies should be disabled
	 * prior to executing the commands associated to the supplied request.
	 * This implementation will return the editpart honoring a <code>SemanticWrapperRequest</code>
	 * and a <code>CreateConnectionViewRequest</code>'s source and target editparts.
	 *
	 * @@param request a request that has returned a command.
	 * @@return list of editparts.
	 */
	Collection disableCanonicalFor( final Request request ) {
		//
		// not the most generic of solution; however, it will have to do for now...
		//
		// Alternate solutions
		// 1. common request interface on all the requests
		//  IRequest#getAffectedEditParts
		//
		// 2. Traverse down the command and collect of the ICommand#getAffectedObjects()
		//  -- this requires that all our commands properly set this value.
		
		Set hosts = new HashSet();
		if ( (request instanceof EditCommandRequestWrapper)  
				|| request instanceof TargetRequest
				|| request instanceof DropRequest ) {
			hosts.add(this);
			hosts.add(getParent());
		}
		if ((request instanceof CreateConnectionRequest) ) {
			CreateConnectionRequest ccvr = (CreateConnectionRequest)request;
			hosts.add(this);
			hosts.add(getParent());
			if ( ccvr.getSourceEditPart() != null ) {
				hosts.add( ccvr.getSourceEditPart());
				hosts.add( ccvr.getSourceEditPart().getParent());
			}
			if ( ccvr.getTargetEditPart() != null ) {
				hosts.add( ccvr.getTargetEditPart());
				hosts.add( ccvr.getTargetEditPart().getParent());
			}
		}
		if ((request instanceof GroupRequest)) {
			List parts = ((GroupRequest)request).getEditParts();
			hosts.add(this);
			hosts.add(getParent());
		
			Iterator editparts = parts == null ? Collections.EMPTY_LIST.iterator() : parts.iterator();	
			while ( editparts.hasNext() ) {
				EditPart ep = (EditPart)editparts.next();
				hosts.add(ep);
				hosts.add(ep.getParent());
			}
		}
d570 219
a788 206
	/**
	 * gets the content pane for the supplied editpart.
	 * @@param editPart the edit part to use to get the contents pane
	 * @@return <code>IFigure</code>
	 */
	protected IFigure getContentPaneFor(IGraphicalEditPart editPart) {
		return getContentPane();
	}

	/**
	 * Convenience method returning the editpart's parimary view. 
	 * @@return the diagram
	 */
	protected Diagram getDiagramView() {
		return (Diagram) getRoot().getContents().getModel();
	}

	/**
	 * Convenience method returning the editpart's parimary view. Same as
	 * calling <code>getView().getPrimaryView()</code>
	 */
	public final View getPrimaryView() {
		for (EditPart parent = this; parent != null; parent = parent.getParent())
			if (parent instanceof IPrimaryEditPart && parent.getModel() instanceof View)
				return (View)parent.getModel();
		return null;
	}

	/**
	 * gets this editpart's edit domain.
	 * @@return the edit domain
	 */
	protected EditDomain getEditDomain() {
		EditDomain result = null;

		try {
			result = getRoot().getViewer().getEditDomain();
		} catch (NullPointerException nullPointerException) {
			/*
			 * The reason why we would the code in try block throws a NPE is
			 * partly because when the diagram is saved as another diagram, the
			 * an event is generated which forces the refreshing of the
			 * properties and if the selection is this editpart, then in order
			 * to open a read action, properties provider will grab its
			 * editDomain. Since this editPart would be in the state of flux and
			 * may not have the root or the viewer set yet, therefore, a null
			 * pointer exception can be thrown.
			 *  
			 */
			return null;
		}
		return result;
	}

	/** Return the editpart's diagram edit domain. */
	public IDiagramEditDomain getDiagramEditDomain() {
		EditDomain editDomain = getEditDomain();
		if (editDomain != null) {
			return (IDiagramEditDomain) editDomain;
		}
		return null;
	}

	/**
	 * Return this editpart's view (model) children.
	 * 
	 * @@return list of views.
	 */
	protected List getModelChildren() {
		Object model = getModel();
		if(model!=null && model instanceof View){
			return new ArrayList(((View)model).getVisibleChildren());
		}
		return Collections.EMPTY_LIST;
	}
	
	/**
	 * Convenience method to retreive the value for the supplied value from the
	 * editpart's associated view element. Same as calling
	 * <code> ViewUtil.getStructuralFeatureValue(getNotationView(),feature)</code>.
	 */
	public Object getStructuralFeatureValue(EStructuralFeature feature) {
		if (hasNotationView())
			return ViewUtil.getStructuralFeatureValue((View) getModel(),feature);
		else
			return null;
	}

	
	/**
	 * gets the semantic element associated to this editpart.
	 * @@return the semantic element or <code>null</code> if the semantic element was
	 * <code>null</code> or unresolvable 
	 */
	public EObject resolveSemanticElement() {
		try {
			return (EObject) getEditingDomain().runExclusive(
				new RunnableWithResult.Impl() {

					public void run() {
						Object model = getModel();
						if (model instanceof View) {
							setResult(ViewUtil
								.resolveSemanticElement((View) getModel()));
						} else if (model instanceof EObject) {
							EObject element = (EObject) model;
							if (element.eIsProxy())
								setResult(EMFCoreUtil.resolve(getEditingDomain(), element));
							else
								setResult(element);
						}
					}
				});
		} catch (InterruptedException e) {
			Trace.catching(DiagramUIPlugin.getInstance(),
				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"resolveSemanticElement", e); //$NON-NLS-1$
			Log.error(DiagramUIPlugin.getInstance(),
				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
				"resolveSemanticElement", e); //$NON-NLS-1$
			return null;
		}

	}

	/**
	 * Walks up the editpart hierarchy to find and return the
	 * <code>TopGraphicEditPart</code> instance.
	 */
	public TopGraphicEditPart getTopGraphicEditPart() {
		EditPart editPart = this;
		while (editPart instanceof IGraphicalEditPart) {
			if (editPart instanceof TopGraphicEditPart)
				return (TopGraphicEditPart) editPart;
			editPart = editPart.getParent();
		}
		return null;
	}

	/**
	 * Return the editpart's associated Notation View.
	 * @@return <code>View</code>, the associated view or null if there is no associated Notation View
	 */
	public View getNotationView() {
		Object model = getModel();
		if (model instanceof View)
			return (View)model;
		return null;
	}

	/**
	 * Method reactivateSemanticModel. This method reactivates the edit part's
	 * emantic model by: 1- removing semantic listeners 2- adding semantic
	 * listeners if the semantic reference is resolvable 3- Refreshing it
	 * 
	 * This method is called in response to IView's Properties.ID_SEMANTICREF
	 * property change event However, it will only work under the following
	 * assumptions: 1- The old and new semantic models are compatible in their
	 * kind 2- The deltas between old and new semantic models do not affect
	 * notation 3- Connections are not refereshed since they are maintained by
	 * the diagram
	 */
	protected void reactivateSemanticModel() {
		removeSemanticListeners();
		if (resolveSemanticElement() != null)
			addSemanticListeners();
	}

	/** Finds an editpart given a starting editpart and an EObject */
	public EditPart findEditPart(EditPart epBegin, EObject theElement) {
		if (theElement == null) {
			return null;
		}
		EditPart epStart = null;
		if (epBegin == null) {
			epStart = this;
		} else {
			epStart = epBegin;
		}

		final View view = (View) ((IAdaptable) epStart)
			.getAdapter(View.class);

		if (view != null) {
			EObject el = ViewUtil.resolveSemanticElement(view);

			if ((el != null) && el.equals(theElement)) {
				return epStart;
			}
		}

		ListIterator childLI = epStart.getChildren().listIterator();
		while (childLI.hasNext()) {
			EditPart epChild = (EditPart) childLI.next();

			EditPart elementEP = findEditPart(epChild, theElement);
			if (elementEP != null) {
				return elementEP;
			}
		}
		return null;
	}

	/** Invoke the editpart's refresh mechanism. */
	public void refresh() {
		try {
d790 96
a885 122
	
				public void run() {
					EditPolicyIterator i = getEditPolicyIterator();
					while (i.hasNext()) {
						EditPolicy policy = i.next();
						if (policy instanceof GraphicalEditPolicyEx) {
							((GraphicalEditPolicyEx) policy).refresh();
						}
					}
					GraphicalEditPart.super.refresh();
				}
			});
		} catch (InterruptedException e) {
			Trace.catching(DiagramUIPlugin.getInstance(),
				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"refresh", e); //$NON-NLS-1$
			Log.error(DiagramUIPlugin.getInstance(),
				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
				"refresh", e); //$NON-NLS-1$
		}

	}

	/** Refresh the editpart's figure background colour. */
	protected void refreshBackgroundColor() {
		FillStyle style = (FillStyle)getPrimaryView().getStyle(NotationPackage.eINSTANCE.getFillStyle());
		if ( style != null ) {
			setBackgroundColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getFillColor())));
		}
	}

	/** Refresh the editpart's figure font. */
	protected void refreshFont() {
		FontStyle style = (FontStyle) getPrimaryView().getStyle(NotationPackage.eINSTANCE.getFontStyle());
		if (style != null) {
			setFont(new FontData(
				style.getFontName(), 
				style.getFontHeight(), 
				(style.isBold() ? SWT.BOLD : SWT.NORMAL) | 
				(style.isItalic() ? SWT.ITALIC : SWT.NORMAL)));
		}
	}

	/** Refresh the editpart's figure font colour. */
	protected void refreshFontColor() {
		FontStyle style = (FontStyle)  getPrimaryView().getStyle(NotationPackage.eINSTANCE.getFontStyle());
		if ( style != null ) {
			setFontColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getFontColor())));
		}
	}

	/** Refresh the editpart's figure foreground colour. */
	protected void refreshForegroundColor() {
		LineStyle style = (LineStyle)  getPrimaryView().getStyle(NotationPackage.eINSTANCE.getLineStyle());
		if ( style != null ) {
			setForegroundColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getLineColor())));
		}
	}

	/** Refresh the editpart's figure visibility. */
	protected void refreshVisibility() {
		Object model = null;
		EditPart ep = this;
		while (!(model instanceof View) && ep!=null){
			model = ep.getModel();
			ep = ep.getParent();
		}
		if (model instanceof View)
			setVisibility(((View)model).isVisible());
	}

	/** Refresh the editpart's figure visual properties. */
	protected void refreshVisuals() {
		super.refreshVisuals();
		refreshVisibility();
	}

	/**
	 * Removes a listener previously added with the given id
	 * 
	 * @@param filterId the filter ID
	 */
	protected void removeListenerFilter(String filterId) {
		if (listenerFilters == null)
			return;
		Object[] objects = (Object[]) listenerFilters.get(filterId);
		if (objects == null)
			return;
		if (objects.length>2){
			getDiagramEventBroker().
				removeNotificationListener((EObject) objects[0],
											 (EStructuralFeature) objects[1],
											 (NotificationListener) objects[2]);
		}else{
			getDiagramEventBroker().removeNotificationListener((EObject) objects[0],(NotificationListener) objects[1]);
		}
		listenerFilters.remove(filterId);
	}

	/**
	 * sets the back ground color of this edit part
	 * @@param color the new value of the back ground color
	 */
	protected void setBackgroundColor(Color color) {
		getFigure().setBackgroundColor(color);
	}

	/**
	 * Sets the font to the label.
	 * This method could be overriden to change the font data of the font
	 * overrides typically look like this:
	 * 		super.setFont(
	 *		new FontData(
	 *			fontData.getName(),
	 *			fontData.getHeight(),
	 *			fontData.getStyle() <| &> SWT.????));
	 * @@param fontData the font data
	 */
	protected void setFont(FontData fontData) {
        Font newFont = DiagramFontRegistry.getInstance().getFont(
				Display.getDefault(),
            fontData);
d887 30
a916 1
        if (!newFont.equals(getFigure().getFont())) {
d918 478
a1395 418
		getFigure().repaint();
	}
	}

	/**
	 * sets the font color
	 * @@param color the new value of the font color
	 */
	protected void setFontColor(Color color) {
		// NULL implementation
	}

	/**
	 * sets the fore ground color of this edit part's figure
	 * @@param color the new value of the foregroundcolor
	 */
	protected void setForegroundColor(Color color) {
		getFigure().setForegroundColor(color);
	}
	
	/**
	 * Sets the passed feature if possible on this editpart's view
	 * to the passed value.
	 * @@param feature the feature to use
	 * @@param value  the value of the property being set
	 */
	public void setStructuralFeatureValue(EStructuralFeature feature, Object value) {
		if (hasNotationView())
			ViewUtil.setStructuralFeatureValue((View) getModel(), feature, value);
	}

	/**
	 * sets the visibility of this edit part
	 * @@param vis the new value of the visibility
	 */
	protected void setVisibility(boolean vis) {
		if (!vis && getSelected() != SELECTED_NONE)
			getViewer().deselect(this);

		getFigure().setVisible(vis);
		getFigure().revalidate();
	}
	
	/**
	 * This method adds all listeners to the notational world (views, figures,
	 * editpart...etc) Override this method to add more notational listeners
	 * down the hierarchy
	 */
	protected void addNotationalListeners() {
		if (hasNotationView()){
			addListenerFilter("View", this,(View)getModel()); //$NON-NLS-1$
		}
	}
	
	/**
	 * This method adds all listeners to the semantic element behind this EditPart
	 * Override this method to add more semantic listeners down the hierarchy
	 * This method is called only if the semantic element is resolvable
	 */
	protected void addSemanticListeners() {
		addListenerFilter("SemanticElement", this,resolveSemanticElement());//$NON-NLS-1$
	}

	/**
	 * This method removes all listeners to the notational world (views,
	 * figures, editpart...etc) Override this method to remove notational
	 * listeners down the hierarchy
	 */
	protected void removeNotationalListeners() {
		removeListenerFilter("View"); //$NON-NLS-1$
	}

	/**
	 * This method removes all listeners to the semantic element behind this EditPart
	 * Override this method to remove semantic listeners
	 * down the hierarchy
	 */
	protected void removeSemanticListeners() {
		removeListenerFilter("SemanticElement"); //$NON-NLS-1$
	}

	/**
	 * Perform a request by executing a command from the target editpart of the
	 * request For the Direct_Edit request, we need to show up an editor first
	 * 
	 * @@see org.eclipse.gef.EditPart#performRequest(org.eclipse.gef.Request)
	 */
	public void performRequest(Request request) {
		if ( !isEditModeEnabled() ) {
			if (RequestConstants.REQ_OPEN.equals(request.getType())) {
				//allowed, continue
			}
			else {
				return;
			}
		}
		
		if (RequestConstants.REQ_DIRECT_EDIT == request.getType()) {
			performDirectEditRequest(request);
		} else {
			EditPart targetEditPart = getTargetEditPart(request);
			if (targetEditPart != null) {
				Command command = targetEditPart.getCommand(request);
				if (command != null) {
					getDiagramEditDomain().getDiagramCommandStack().execute(
						command);
					return;
				}
			}
		}
	}

	/**
	 * Performs a direct edit request (usually by showing some type of editor)
	 * 
	 * @@param request
	 *            the direct edit request
	 */
	protected void performDirectEditRequest(Request request) {
		// NULL implementation
	}

	/**
	 * @@see org.eclipse.gef.editparts.AbstractEditPart#getAccessibleEditPart()
	 */
	protected AccessibleEditPart getAccessibleEditPart() {
		if (accessibleEP == null)
			accessibleEP = new AccessibleGraphicalEditPart() {

			private String getSemanticName() {
				EObject semanticElement = resolveSemanticElement();
			
				if( semanticElement != null ) {
					String name = semanticElement.getClass().getName();
					int startIndex = name.lastIndexOf('.') + 1;
					int endIndex = name.lastIndexOf( "Impl" ); //$NON-NLS-1$
					return name.substring(startIndex, endIndex);
				}
			
				return null;
			}

			public void getName(AccessibleEvent e) {
				IGraphicalEditPart childEP = getChildBySemanticHint(CommonParserHint.NAME);
				if (childEP == null) {
					childEP = getChildBySemanticHint(CommonParserHint.DESCRIPTION);
				}
				if (childEP != null) {
					IFigure fig = childEP.getFigure();
					if (fig instanceof WrapLabel) {
						e.result = ((WrapLabel) fig).getText();
					}
				} else {
					e.result = getSemanticName();
				}
			}
			};

		return accessibleEP;
	}

	/** Adds a [ref, editpart] mapping to the EditPartForElement map. */
	protected void registerModel() {
		if (hasNotationView()) {
			super.registerModel();
		} else {
			getViewer().getEditPartRegistry().put(basicGetModel(), this);
		}

		// Save the elements Guid to use during unregister.
		// If the reference is null, do not register.
		EObject ref = null;
		if (hasNotationView())
			ref = getNotationView().getElement();
		else
			ref = (EObject) basicGetModel();
		if (ref == null) {
			return;
		}
		elementGuid = EMFCoreUtil.getProxyID(ref);
		((IDiagramGraphicalViewer) getViewer()).registerEditPartForElement(
			elementGuid, this);
	}


	/** Remove this editpart from the EditPartForElement map. */
	protected void unregisterModel() {
		if (hasNotationView())
			super.unregisterModel();
		else {
			Map registry = getViewer().getEditPartRegistry();
			if (registry.get(basicGetModel()) == this)
				registry.remove(basicGetModel());
		}

		//Do not need to unregister if the guid is null.
		if (elementGuid == null) {
			return;
		}
		((IDiagramGraphicalViewer) getViewer()).unregisterEditPartForElement(
			elementGuid, this);
	}

	/**
	 * Refreshes a child editpart by removing it and refreshing children
	 * @@param child the child to refresh
	 */
	protected final void refreshChild(GraphicalEditPart child) {
		removeChild(child);
		refreshChildren();
	}
	
	/**
	 * Refreshes a source connection editpart by removing it and refreshing source connections
	 * @@param conn the connection to refresh
	 */
	protected final void refreshSourceConnection(ConnectionEditPart conn) {
		removeSourceConnection(conn);
		refreshSourceConnections();
	}

	/**
	 * Refreshes a target connection editpart by removing it and refreshing target connections
	 * @@param conn the connection to refresh
	 */
	protected final void refreshTargetConnection(ConnectionEditPart conn) {
		removeTargetConnection(conn);
		refreshTargetConnections();
	}

	/**
	 * Handles the case where the semantic reference has changed.
	 */
	protected final void handleMajorSemanticChange() {
		if (getParent() instanceof GraphicalEditPart)
			((GraphicalEditPart) getParent()).refreshChild(this);
		else if (getParent() instanceof ConnectionEditPart)
			((ConnectionEditPart) getParent()).refreshChild(this);
	}
	
	/**
	 * @@see org.eclipse.gef.EditPart#getDragTracker(org.eclipse.gef.Request)
	 */
	public DragTracker getDragTracker(Request request) {
		return new DragEditPartsTrackerEx(this);
	}

	/**
	 * @@return <tt>true</tt> a canonical editpolicy has been installed on this editpart
	 * and it is active; otherwise <tt>false</tt>.
	 */
	public final boolean isCanonical() {
		CanonicalEditPolicy policy = (CanonicalEditPolicy)getEditPolicy(EditPolicyRoles.CANONICAL_ROLE);
		return policy == null ? false : policy.isActive();
	}

	/**
	 * Return <tt>true</tt> if the editpart's figure is visible;
	 * <tt>false</tt> otherwise.
	 */
	public boolean isSelectable() {
		return getFigure().isShowing();
	}

	/* 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#disableEditMode()
	 */
	public void disableEditMode() {
		this.editableEditPart.disableEditMode();		
	}
	
	/* 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#enableEditMode()
	 */
	public void enableEditMode() {
		this.editableEditPart.enableEditMode();
	}
	
	/* 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#isEditModeEnabled()
	 */
	public boolean isEditModeEnabled() {
		// protect against deadlock - don't allow any action while write transaction
		// is active on another thread
		if (EditPartUtil.isWriteTransactionInProgress(this, true, true))
			return false;
		
		return this.editableEditPart.isEditModeEnabled();
	}
	
	/* 
	 * @@see org.eclipse.gef.EditPart#showSourceFeedback(org.eclipse.gef.Request)
	 */
	public void showSourceFeedback(Request request) {
		if ( !isEditModeEnabled()) {
			return;
		}
		
		super.showSourceFeedback(request);
	}
	
	/* 
	 * @@see org.eclipse.gef.EditPart#showTargetFeedback(org.eclipse.gef.Request)
	 */
	public void showTargetFeedback(Request request) {
		if ( !isEditModeEnabled()) {
			return;
		}
		
		super.showTargetFeedback(request);
	}

	/* 
	 * @@see org.eclipse.gef.EditPart#eraseSourceFeedback(org.eclipse.gef.Request)
	 */
	public void eraseSourceFeedback(Request request) {
		if ( !isEditModeEnabled()) {
			return;
		}
		
		super.eraseSourceFeedback(request);
	}
	/* 
	 * @@see org.eclipse.gef.EditPart#eraseTargetFeedback(org.eclipse.gef.Request)
	 */
	public void eraseTargetFeedback(Request request) {
		if ( !isEditModeEnabled()) {
			return;
		}

		super.eraseTargetFeedback(request);
	}
	
	/**
	 * this method will return the primary child EditPart  inside this edit part
	 * @@return the primary child view inside this edit part
	 */
	public EditPart getPrimaryChildEditPart(){
		if (getChildren().size() > 0)
			return (EditPart) getChildren().get(0);
		return null;
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramPreferencesHint()
	 */
	public PreferencesHint getDiagramPreferencesHint() {
		if (getRoot() instanceof IDiagramPreferenceSupport) {
			return ((IDiagramPreferenceSupport) getRoot()).getPreferencesHint();
		}
		return PreferencesHint.USE_DEFAULTS;
	}

	public void notifyChanged(Notification notification) {
		if (isActive()){
			handleNotificationEvent(notification);
		}
	}
	
	public Command transactionAboutToCommit(Notification notification) {
		return null;
	}

	
	/**
	 * Handles the property changed event.  Clients should override to
	 * respond to the specific notification events they are interested.
	 * 
	 * Note: This method may get called on a non-UI thread.  Clients should
	 * either ensure that their code is thread safe and/or doesn't make
	 * unsupported calls (i.e. Display.getCurrent() ) assuming they are on
	 * the main thread.  Alternatively if this is not possible, then the
	 * client can wrap their handler within the Display.synchExec runnable
	 * to ensure synchronization and subsequent execution on the main thread.
	 * 
	 * @@param event
	 *            the <code>Notification</code> object that is the property changed event
	 */
	protected void handleNotificationEvent(Notification event) {
		if (NotationPackage.eINSTANCE.getView_PersistedChildren().equals(event.getFeature())||
				NotationPackage.eINSTANCE.getView_TransientChildren().equals(event.getFeature())) {
			refreshChildren();
		}else if (NotationPackage.eINSTANCE.getView_Visible().equals(event.getFeature())) {
			Object notifier = event.getNotifier();
			if (notifier== getModel())
				refreshVisibility();
			else {
				refreshChildren();
			}
		}
		else if (NotationPackage.eINSTANCE.getView_Element().equals(event.getFeature())) {
			handleMajorSemanticChange();
		} 
	}
	
	/**
	 * @@return <code>IMapMode</code> that allows for the coordinate mapping from device to
	 * logical units. 
	 */
	final protected IMapMode getMapMode() {
		RootEditPart root = getRoot();
		if (root instanceof DiagramRootEditPart) {
			DiagramRootEditPart dgrmRoot = (DiagramRootEditPart)root;
			return dgrmRoot.getMapMode();
		}
		
		return MapModeUtil.getMapMode();
	}
	
	/**
	 * indicates if this edit part's model is a view or not 
	 * @@return <code>true</code> or <code>false</code>
	 */
	public boolean hasNotationView(){
		return true;
	}
	
	/**
d1400 6
a1405 6
	 */
	public Object getModel() {
		if (hasNotationView()){
			return super.getModel();
		} else {
			Object _model = basicGetModel();
d1408 4
a1411 4
			return node;
		}
	}
	
d1429 11
d1453 1
a1453 1
	// documentation copied from superclass
d1460 45
@


1.42.2.1
log
@Bugzilla#146690 gmf_R1_0_maintenance cmahoney 060711 Inconsistent default colours
@
text
@a75 1
import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
a79 1
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
a92 2
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.preference.PreferenceConverter;
a1332 31

    public Object getPreferredValue(EStructuralFeature feature) {
        Object preferenceStore = getDiagramPreferencesHint()
            .getPreferenceStore();
        if (preferenceStore instanceof IPreferenceStore) {
            if (feature == NotationPackage.eINSTANCE.getLineStyle_LineColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_LINE_COLOR));
                
            } else if (feature == NotationPackage.eINSTANCE
                .getFontStyle_FontColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_FONT_COLOR));
                
            } else if (feature == NotationPackage.eINSTANCE
                .getFillStyle_FillColor()) {
                
                return FigureUtilities.RGBToInteger(PreferenceConverter
                    .getColor((IPreferenceStore) preferenceStore,
                        IPreferenceConstants.PREF_FILL_COLOR));
                
            }
        }

        return getStructuralFeatureValue(feature);
    }   
    
@


1.42.2.2
log
@[150705] gmf_R1_0_maintenance mmostafa  060714 ToggleCanonicalEditPolicy might corrupt the undo stack
@
text
@d440 9
a448 13
                    CompoundCommand cc = new CompoundCommand();
                    cc.setLabel( cmd.getLabel() );
                    ToggleCanonicalModeCommand tcmd = 
                        ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(_disableCanonicalEditPolicyList, false);
                    cc.add( tcmd );
                    cc.add( cmd );
                    ToggleCanonicalModeCommand tcmd2 = ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(tcmd, true);
                    if (tcmd2 != null) {
                        tcmd2.setDomain(getEditingDomain());
                    }
                    cc.add( tcmd2 );
                    _disableCanonicalEditPolicyList.clear();
                    return cc.unwrap();
@


1.42.2.3
log
@Bugzilla#146289 gmf_R1_0_maintenance cmahoney 060714 DiagramFontRegistry appears to be a permanent resource leak
@
text
@d71 1
a73 1
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
a96 4
import org.eclipse.jface.resource.DeviceResourceException;
import org.eclipse.jface.resource.FontDescriptor;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.resource.ResourceManager;
d103 1
a131 6
    /**
     * Cache the font data when a font is created so that it can be
     * disposed later.
     */
    private FontData cachedFontData;
    
a273 6
        
        if (cachedFontData != null) {
            getResourceManager().destroyFont(
                FontDescriptor.createFrom(cachedFontData));
            cachedFontData = null;
        }
d440 6
a445 6
					CompoundCommand cc = new CompoundCommand();
					cc.setLabel( cmd.getLabel() );
					ToggleCanonicalModeCommand tcmd = 
						ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(_disableCanonicalEditPolicyList, false);
					cc.add( tcmd );
					cc.add( cmd );
d451 2
a452 2
					_disableCanonicalEditPolicyList.clear();
					return cc.unwrap();
d864 5
a868 8
        if (cachedFontData != null && cachedFontData.equals(fontData)) {
            // the font was previously set and has not changed; do nothing.
            return;
        }

        try {
            Font newFont = getResourceManager().createFont(
                FontDescriptor.createFrom(fontData));
d870 3
a872 15
            getFigure().repaint();

            if (cachedFontData != null) {
                getResourceManager().destroyFont(
                    FontDescriptor.createFrom(cachedFontData));
            }
            cachedFontData = fontData;
        } catch (DeviceResourceException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "setFont", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "setFont", e); //$NON-NLS-1$
        }
    }
d875 3
a877 5
     * sets the font color
     * 
     * @@param color
     *            the new value of the font color
     */
d883 3
a885 5
     * sets the fore ground color of this edit part's figure
     * 
     * @@param color
     *            the new value of the foregroundcolor
     */
a1371 13
    /**
     * Gets the resource manager to remember the resources allocated for this
     * graphical viewer. All resources will be disposed when the graphical
     * viewer is closed if they have not already been disposed.
     * 
     * @@return the resource manager
     */
    protected ResourceManager getResourceManager() {
        if (getViewer() instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) getViewer()).getResourceManager();
        }
        return JFaceResources.getResources();
    }
@


1.42.2.4
log
@[152036] gmf_R1_0_maintenace mmostafa 060727  Componenet Edit Policy does not consider the semantic list compartment
@
text
@d283 2
a284 2
		
		if (cachedFontData != null) {
d1155 1
a1155 1
	public boolean isCanonical() {
@


1.42.2.5
log
@[152392] gmf_R1_0_maintenance yLulu 060801 Performance of DiagramEditPart and ConnectionEditPart could be enhanced
@
text
@d26 1
a37 1
import org.eclipse.gef.EditPartViewer;
d68 1
d127 2
a128 4
    /**
     * Flag to indicate if the edit part is in edit mode
     */
    private boolean isEditable = true;
d148 2
a149 1
		setModel(model);		
d154 21
a174 32
        if (isActive()) {
            return;
        }
        addNotationalListeners();

        EObject semanticElement;
        EObject semanticProxy;
        if (hasNotationView()) {
            semanticProxy = ((View) super.getModel()).getElement();
            if ((semanticProxy==null)||semanticProxy.eIsProxy()) {
                semanticElement = null;
            } else {
                semanticElement = semanticProxy;
            }
        } else {
            semanticProxy = (EObject) basicGetModel();
            if ((semanticProxy!=null) && semanticProxy.eIsProxy()) {
                semanticElement = EMFCoreUtil.resolve(getEditingDomain(),
                    semanticProxy);
            } else {
                semanticElement = semanticProxy;
            }
        }

        if (semanticElement != null)
            addSemanticListeners();
        else if (semanticProxy != null) {
            addListenerFilter("SemanticProxy", this, semanticProxy); //$NON-NLS-1$
        }
        GraphicalEditPart.super.activate();

    }
d308 2
a309 1
	public Object getAdapter(Class key) {		
d316 1
a316 1
		if (View.class.isAssignableFrom(key)) {
a319 2
            else
                return null;
d321 1
a321 2
        
        Object model = basicGetModel();		
d325 1
a325 1
			EObject semanticObject = null;            
d335 1
a335 1
			if ((semanticObject!=null) && key.isInstance(semanticObject)) {
d345 4
a348 1
		return super.getAdapter(key);
d375 2
a376 3
		View view;
        if (hasNotationView() && (view = (View) super.getModel()) != null) {
			view = ViewUtil.getChildBySemanticHint(view,semanticHint);
d398 4
a401 5
        View view;
        if (hasNotationView() && (view = (View) super.getModel()) != null) {
            return ViewUtil.getChildBySemanticHint(view, semanticHint);
        }
        return null;
d609 5
a613 1
        return (IDiagramEditDomain) getEditDomain();
d635 4
a638 5
        if (hasNotationView())
            return ViewUtil.getPropertyValue((View) super.getModel(), feature,
                feature.getEContainingClass());
        else
            return null;
d648 29
a676 35
        Object model = super.getModel();
        if (hasNotationView()) {
            EObject eObj = ((View) model).getElement();
            if (eObj != null && eObj.eIsProxy()) {
                return null;
            } else {
                return eObj;
            }
        } else if (model instanceof EObject) {
           final EObject eObj = (EObject) model;
            if (eObj.eIsProxy()) {
            	try {
					return (EObject) getEditingDomain().runExclusive(
						new RunnableWithResult.Impl() {

							public void run() {
								EObject resolvedEObj = EMFCoreUtil.resolve(
									getEditingDomain(), eObj);
								setResult(resolvedEObj);
							}
						});
				} catch (InterruptedException e) {
        			Trace.catching(DiagramUIPlugin.getInstance(),
        				DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
        				"resolveSemanticElement", e); //$NON-NLS-1$
        			Log.error(DiagramUIPlugin.getInstance(),
        				DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
        				"resolveSemanticElement", e); //$NON-NLS-1$
        			return null;
        		}            	
            }
            return eObj;
        }
        return null;
    }
d785 1
a785 1
		FillStyle style = (FillStyle)getPrimaryView().getStyle(NotationPackage.Literals.FILL_STYLE);
d793 1
a793 1
		FontStyle style = (FontStyle) getPrimaryView().getStyle(NotationPackage.Literals.FONT_STYLE);
d805 1
a805 1
		FontStyle style = (FontStyle)  getPrimaryView().getStyle(NotationPackage.Literals.FONT_STYLE);
d813 1
a813 1
		LineStyle style = (LineStyle)  getPrimaryView().getStyle(NotationPackage.Literals.LINE_STYLE);
d845 1
a845 1
		Object[] objects = (Object[]) listenerFilters.remove(filterId);
d856 1
a856 1
		
d879 1
a879 1
         if (cachedFontData != null && cachedFontData.equals(fontData)) {
d902 1
a902 1
	}
d905 5
a909 3
	 * sets the font color
	 * @@param color the new value of the font color
	 */
d915 5
a919 3
	 * sets the fore ground color of this edit part's figure
	 * @@param color the new value of the foregroundcolor
	 */
d931 2
a932 4
        if (hasNotationView() && (feature != null)) {
            ViewUtil.setPropertyValue((View) super.getModel(), feature, feature
                .getEContainingClass(), value);
        }
a1066 1
        EditPartViewer viewer = getViewer();
d1070 1
a1070 1
            viewer.getEditPartRegistry().put(basicGetModel(), this);
d1084 1
a1084 1
		((IDiagramGraphicalViewer) viewer).registerEditPartForElement(
a1090 1
        EditPartViewer viewer = getViewer();
d1094 1
a1094 1
			Map registry = viewer.getEditPartRegistry();
d1103 1
a1103 1
		((IDiagramGraphicalViewer) viewer).unregisterEditPartForElement(
d1172 2
a1173 24
        if (!isEditModeEnabled()) {
            return;
        }

        List l = getSourceConnections();
        int size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        List c = getChildren();
        size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        isEditable = false;
    }
d1179 2
a1180 24
        if (isEditModeEnabled()) {
            return;
        }

        isEditable = true;

        List c = getChildren();
        int size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }

        List l = getSourceConnections();
        size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }
    }
d1186 7
a1192 6
        // protect against deadlock - don't allow any action while write transaction
        // is active on another thread
        if (EditPartUtil.isWriteTransactionInProgress(this, true, true))
            return false;
        return isEditable;
    }
d1251 2
a1252 3
		RootEditPart root = getRoot();
		if (root instanceof IDiagramPreferenceSupport) {
			return ((IDiagramPreferenceSupport) root).getPreferencesHint();
d1282 3
a1284 3
	protected void handleNotificationEvent(Notification event) {        
		if (NotationPackage.Literals.VIEW__PERSISTED_CHILDREN.equals(event.getFeature())||
				NotationPackage.Literals.VIEW__TRANSIENT_CHILDREN.equals(event.getFeature())) {
d1286 1
a1286 1
		}else if (NotationPackage.Literals.VIEW__VISIBLE.equals(event.getFeature())) {
d1294 1
a1294 1
		else if (NotationPackage.Literals.VIEW__ELEMENT.equals(event.getFeature())) {
d1303 1
a1303 1
	 protected IMapMode getMapMode() {
d1375 2
a1376 2
    
   public Object getPreferredValue(EStructuralFeature feature) {
d1404 2
a1405 1
    }    
d1414 2
a1415 3
    	EditPartViewer viewer = getViewer();
        if (viewer instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) viewer).getResourceManager();
d1418 1
a1418 2
    }    
    
@


1.42.2.6
log
@[152392] gmf_R1_0_maintenance Reverting  yLulu 060801 Performance of DiagramEditPart and ConnectionEditPart could be enhanced
@
text
@a25 1
import org.eclipse.core.runtime.Platform;
d37 1
a67 1
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DefaultEditableEditPart;
d114 2
a115 2
    extends AbstractGraphicalEditPart
    implements IGraphicalEditPart, IAdaptableSelection, NotificationListener {
d118 17
a134 15
    private Map listenerFilters;
    
    /** Used for accessibility. */
    protected AccessibleEditPart accessibleEP;

    /** Used for registering and unregistering the edit part */
    protected String elementGuid;

    /** Used for handling the editable status of the edit part */
    private final IEditableEditPart editableEditPart;
    
    /**
     * Cache the editing domain after it is retrieved.
     */
    private TransactionalEditingDomain editingDomain;
d142 13
a154 14
    /**
     * Create an instance.
     * 
     * @@param model
     *            the underlying model.
     */
    public GraphicalEditPart(EObject model) {
        setModel(model);
        this.editableEditPart = new DefaultEditableEditPart(this);
    }

    /** Registers this editpart to recieve notation and semantic events. */
    public void activate() {
        if (isActive()){
d158 20
a177 9
        
        EObject semanticProxy = null;
        if (hasNotationView())
            semanticProxy = ((View) getModel()).getElement();
        else
            semanticProxy = (EObject)basicGetModel();
        
        EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(), semanticProxy);
        
d184 1
a184 1
        
d187 15
a201 15
    /**
     * Adds a listener filter by adding the given listener to a passed notifier
     * 
     * @@param filterId
     *            A unique filter id (within the same editpart instance)
     * @@param listener
     *            A listener instance
     * @@param element
     *            An element to add the listener to
     */
    protected void addListenerFilter(String filterId,
            NotificationListener listener,
            EObject element) {
        if (element == null)
            return;
d206 3
a208 3
            Assert.isNotNull(listener);
            if (listenerFilters == null)
                listenerFilters = new HashMap();
d210 1
a210 1
            listenerFilters.put(filterId.intern(), new Object[] {element, listener});
d212 18
a229 18
    }
    
    /**
     * Adds a listener filter by adding the given listener to a passed notifier
     * 
     * @@param filterId
     *            A unique filter id (within the same editpart instance)
     * @@param listener
     *            A listener instance
     * @@param element
     *            An element to add the listener to
     */
    protected void addListenerFilter(String filterId,
            NotificationListener listener,
            EObject element,
            EStructuralFeature feature) {
        if (element == null)
            return;
d242 1
a242 7
    }

    /** Creates a connection editpart. */
    final protected org.eclipse.gef.ConnectionEditPart createConnection(
            Object connectionView) {
        return (org.eclipse.gef.ConnectionEditPart) createChild(connectionView);
    }
d244 37
a280 31
    /**
     * Overridden to support editpolicies installed programmatically and via the
     * <code>EditPolicyService</code>. Subclasses should override
     * <code>createDefaultEditPolicies()</code>.
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
     */
    final protected void createEditPolicies() {
        createDefaultEditPolicies();
        EditPolicyService.getInstance().createEditPolicies(this);
    }

    /**
     * Should be overridden to install editpolicies programmatically.
     * 
     * @@see org.eclipse.gef.editparts.AbstractEditPart#createEditPolicies()
     */
    protected void createDefaultEditPolicies() {
        installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
            new SemanticEditPolicy());
        installEditPolicy(EditPolicyRoles.PROPERTY_HANDLER_ROLE,
            new PropertyHandlerEditPolicy());
        installEditPolicy(EditPolicyRoles.DECORATION_ROLE,
            new DecorationEditPolicy());
    }

    public void deactivate() {
        if ( !isActive() ) {
            return;
        }
        removeNotationalListeners();
d282 14
a295 14
        if (listenerFilters != null ) {
            for (Iterator i = listenerFilters.keySet().iterator(); i.hasNext();) {
                Object[] obj = (Object[]) listenerFilters.get(i.next());
                if (obj.length>2){
                    getDiagramEventBroker().
                        removeNotificationListener((EObject)obj[0],(EStructuralFeature) obj[1],(NotificationListener) obj[2]);
                }else {
                    getDiagramEventBroker().removeNotificationListener((EObject) obj[0],(NotificationListener) obj[1]);
                }
            }
        }
        super.deactivate();
        
        if (cachedFontData != null) {
d300 1
a300 1
    }
d302 31
a332 30
    /**
     * executes the passed <code>Command</code>
     * @@param command the command to exectue
     */
    protected void executeCommand(Command command) {
        getViewer().getEditDomain().getCommandStack().execute(command);
    }
    
    /**
     * Access the model member variable
     * @@return
     */
    final protected Object basicGetModel(){
        return super.getModel();
    }

    /** Adds the ability to adapt to the edit part's view class. */
    public Object getAdapter(Class key) {
        Object model = basicGetModel();

        // Adapt to IActionFilter
        if (key == IActionFilter.class) {
            return ActionFilterService.getInstance();
        }

        if ( View.class.isAssignableFrom(key)) {
            Object _model = getModel();
            if (key.isInstance(_model))
                return _model;
        }
d334 78
a411 65
        if (model != null &&
            EObject.class.isAssignableFrom(key)) {
            // Adapt to semantic element
            EObject semanticObject = null;
            if (hasNotationView()){
                semanticObject = ViewUtil.resolveSemanticElement((View)model);
            }
            else{
                EObject element = (EObject)model;
                if (element.eIsProxy()){
                    semanticObject = EMFCoreUtil.resolve(getEditingDomain(), element);
                }
            }
            if (key.isInstance(semanticObject)) {
                return semanticObject;
            }
            else if (key.isInstance(model)){
                return model;
            }
            
        }

        // Delegate
        Object adapter = super.getAdapter(key);
        if (adapter != null)
            return adapter;
        return Platform.getAdapterManager().getAdapter(this, key);
    }

    /**
     * Utility method to get the primary view and then query for a child based on the
     * semantic hint
     * 
     * @@param semanticHint <code>String</code> that is the hint that can retrieved on the getType
     * method of <code>View</code>
     * @@return <code>IGraphicalEditPart</code> that matches with the given semanticHint
     */
    public IGraphicalEditPart getChildBySemanticHintOnPrimaryView(String semanticHint) {
        View primaryView = getPrimaryView();
        View childView = ViewUtil.getChildBySemanticHint(primaryView, semanticHint);
        if (childView != null)
            return  (IGraphicalEditPart)getViewer().getEditPartRegistry().get(childView);

        return null;
    }
    
    /**
     * Method getChildBySemanticHint.
     * 
     * @@param semanticHint
     * @@return IGraphicalEditPart
     */
    public IGraphicalEditPart getChildBySemanticHint(String semanticHint) {
        if (getModel()!=null){
            View view = ViewUtil.getChildBySemanticHint((View)getModel(),semanticHint);
            if (view != null){
                IGraphicalEditPart ep =   (IGraphicalEditPart)getViewer().getEditPartRegistry().get(view);
                // TODO remove this code after the clients change there code to 
                // be aware of the on demand editpart creation
                if (ep == null){
                    // the ep had not been created yet, create a dummy one 
                    ep  =  new DummyEditPart(view);
                }
                return ep;
            }
d414 1
a414 56
    }
    
    /**
     * Method getChildViewBySemanticHint.
     * 
     * @@param semanticHint
     * @@return IGraphicalEditPart
     */
    public View getChildViewBySemanticHint(String semanticHint) {
        if (getModel()!=null){
            return ViewUtil.getChildBySemanticHint((View)getModel(),semanticHint);
        }
        return null;
    }

    
    /** counter that tracs the recursive depth of the getCommand() method. */
    private static volatile int GETCOMMAND_RECURSIVE_COUNT = 0;
    
    /** A list of editparts who's canonical editpolicies are to be temporarily disabled. */
    private static Set _disableCanonicalEditPolicyList = new HashSet();
    

    /** Return a command for the supplied request. */
    public Command getCommand(Request _request) {
        if ( !isEditModeEnabled() ) {
            if (RequestConstants.REQ_OPEN.equals(_request.getType())) {
                //allowed, continue
            }
            else {
                return UnexecutableCommand.INSTANCE;
            }           
        }
        
        Command cmd = null;
        try {
            GETCOMMAND_RECURSIVE_COUNT++;
            final Request request = _request;
            try {
                cmd = (Command) getEditingDomain().runExclusive(
                    new RunnableWithResult.Impl() {

                        public void run() {
                            setResult(GraphicalEditPart.super
                                .getCommand(request));
                        }
                    });
            } catch (InterruptedException e) {
                Trace.catching(DiagramUIPlugin.getInstance(),
                    DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "getCommand", e); //$NON-NLS-1$
                Log.error(DiagramUIPlugin.getInstance(),
                    DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                    "getCommand", e); //$NON-NLS-1$
            }
            
d416 57
a472 15
            if ( cmd != null ) {
                _disableCanonicalEditPolicyList.addAll(disableCanonicalFor(_request));
            }
            
            GETCOMMAND_RECURSIVE_COUNT--;
            
            if ( GETCOMMAND_RECURSIVE_COUNT == 0 ) {
                if ( cmd != null 
                        && !_disableCanonicalEditPolicyList.isEmpty() ) {
                    CompoundCommand cc = new CompoundCommand();
                    cc.setLabel( cmd.getLabel() );
                    ToggleCanonicalModeCommand tcmd = 
                        ToggleCanonicalModeCommand.getToggleCanonicalModeCommand(_disableCanonicalEditPolicyList, false);
                    cc.add( tcmd );
                    cc.add( cmd );
d478 65
a542 65
                    _disableCanonicalEditPolicyList.clear();
                    return cc.unwrap();
                }
            }
        }
        catch( RuntimeException t ) {
            GETCOMMAND_RECURSIVE_COUNT = 0;
            throw t;
        }
        return cmd;
        
    }
    
    /**
     * Return a list of editparts who's canonical editpolicies should be disabled
     * prior to executing the commands associated to the supplied request.
     * This implementation will return the editpart honoring a <code>SemanticWrapperRequest</code>
     * and a <code>CreateConnectionViewRequest</code>'s source and target editparts.
     *
     * @@param request a request that has returned a command.
     * @@return list of editparts.
     */
    Collection disableCanonicalFor( final Request request ) {
        //
        // not the most generic of solution; however, it will have to do for now...
        //
        // Alternate solutions
        // 1. common request interface on all the requests
        //  IRequest#getAffectedEditParts
        //
        // 2. Traverse down the command and collect of the ICommand#getAffectedObjects()
        //  -- this requires that all our commands properly set this value.
        
        Set hosts = new HashSet();
        if ( (request instanceof EditCommandRequestWrapper)  
                || request instanceof TargetRequest
                || request instanceof DropRequest ) {
            hosts.add(this);
            hosts.add(getParent());
        }
        if ((request instanceof CreateConnectionRequest) ) {
            CreateConnectionRequest ccvr = (CreateConnectionRequest)request;
            hosts.add(this);
            hosts.add(getParent());
            if ( ccvr.getSourceEditPart() != null ) {
                hosts.add( ccvr.getSourceEditPart());
                hosts.add( ccvr.getSourceEditPart().getParent());
            }
            if ( ccvr.getTargetEditPart() != null ) {
                hosts.add( ccvr.getTargetEditPart());
                hosts.add( ccvr.getTargetEditPart().getParent());
            }
        }
        if ((request instanceof GroupRequest)) {
            List parts = ((GroupRequest)request).getEditParts();
            hosts.add(this);
            hosts.add(getParent());
        
            Iterator editparts = parts == null ? Collections.EMPTY_LIST.iterator() : parts.iterator();  
            while ( editparts.hasNext() ) {
                EditPart ep = (EditPart)editparts.next();
                hosts.add(ep);
                hosts.add(ep.getParent());
            }
        }
d565 78
a642 82
    /**
     * gets the content pane for the supplied editpart.
     * @@param editPart the edit part to use to get the contents pane
     * @@return <code>IFigure</code>
     */
    protected IFigure getContentPaneFor(IGraphicalEditPart editPart) {
        return getContentPane();
    }

    /**
     * Convenience method returning the editpart's parimary view. 
     * @@return the diagram
     */
    protected Diagram getDiagramView() {
        return (Diagram) getRoot().getContents().getModel();
    }

    /**
     * Convenience method returning the editpart's parimary view. Same as
     * calling <code>getView().getPrimaryView()</code>
     */
    public final View getPrimaryView() {
        for (EditPart parent = this; parent != null; parent = parent.getParent())
            if (parent instanceof IPrimaryEditPart && parent.getModel() instanceof View)
                return (View)parent.getModel();
        return null;
    }

    /**
     * gets this editpart's edit domain.
     * @@return the edit domain
     */
    protected EditDomain getEditDomain() {
        EditDomain result = null;

        try {
            result = getRoot().getViewer().getEditDomain();
        } catch (NullPointerException nullPointerException) {
            /*
             * The reason why we would the code in try block throws a NPE is
             * partly because when the diagram is saved as another diagram, the
             * an event is generated which forces the refreshing of the
             * properties and if the selection is this editpart, then in order
             * to open a read action, properties provider will grab its
             * editDomain. Since this editPart would be in the state of flux and
             * may not have the root or the viewer set yet, therefore, a null
             * pointer exception can be thrown.
             *  
             */
            return null;
        }
        return result;
    }

    /** Return the editpart's diagram edit domain. */
    public IDiagramEditDomain getDiagramEditDomain() {
        EditDomain editDomain = getEditDomain();
        if (editDomain != null) {
            return (IDiagramEditDomain) editDomain;
        }
        return null;
    }

    /**
     * Return this editpart's view (model) children.
     * 
     * @@return list of views.
     */
    protected List getModelChildren() {
        Object model = getModel();
        if(model!=null && model instanceof View){
            return new ArrayList(((View)model).getVisibleChildren());
        }
        return Collections.EMPTY_LIST;
    }
    
    /**
     * Convenience method to retreive the value for the supplied value from the
     * editpart's associated view element. Same as calling
     * <code> ViewUtil.getStructuralFeatureValue(getNotationView(),feature)</code>.
     */
    public Object getStructuralFeatureValue(EStructuralFeature feature) {
d644 2
a645 1
            return ViewUtil.getStructuralFeatureValue((View) getModel(),feature);
d648 1
a648 1
    }
d650 14
a663 100
    
    /**
     * gets the semantic element associated to this editpart.
     * @@return the semantic element or <code>null</code> if the semantic element was
     * <code>null</code> or unresolvable 
     */
    public EObject resolveSemanticElement() {
        try {
            return (EObject) getEditingDomain().runExclusive(
                new RunnableWithResult.Impl() {

                    public void run() {
                        Object model = getModel();
                        if (model instanceof View) {
                            setResult(ViewUtil
                                .resolveSemanticElement((View) getModel()));
                        } else if (model instanceof EObject) {
                            EObject element = (EObject) model;
                            if (element.eIsProxy())
                                setResult(EMFCoreUtil.resolve(getEditingDomain(), element));
                            else
                                setResult(element);
                        }
                    }
                });
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "resolveSemanticElement", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "resolveSemanticElement", e); //$NON-NLS-1$
            return null;
        }

    }

    /**
     * Walks up the editpart hierarchy to find and return the
     * <code>TopGraphicEditPart</code> instance.
     */
    public TopGraphicEditPart getTopGraphicEditPart() {
        EditPart editPart = this;
        while (editPart instanceof IGraphicalEditPart) {
            if (editPart instanceof TopGraphicEditPart)
                return (TopGraphicEditPart) editPart;
            editPart = editPart.getParent();
        }
        return null;
    }

    /**
     * Return the editpart's associated Notation View.
     * @@return <code>View</code>, the associated view or null if there is no associated Notation View
     */
    public View getNotationView() {
        Object model = getModel();
        if (model instanceof View)
            return (View)model;
        return null;
    }

    /**
     * Method reactivateSemanticModel. This method reactivates the edit part's
     * emantic model by: 1- removing semantic listeners 2- adding semantic
     * listeners if the semantic reference is resolvable 3- Refreshing it
     * 
     * This method is called in response to IView's Properties.ID_SEMANTICREF
     * property change event However, it will only work under the following
     * assumptions: 1- The old and new semantic models are compatible in their
     * kind 2- The deltas between old and new semantic models do not affect
     * notation 3- Connections are not refereshed since they are maintained by
     * the diagram
     */
    protected void reactivateSemanticModel() {
        removeSemanticListeners();
        if (resolveSemanticElement() != null)
            addSemanticListeners();
    }

    /** Finds an editpart given a starting editpart and an EObject */
    public EditPart findEditPart(EditPart epBegin, EObject theElement) {
        if (theElement == null) {
            return null;
        }
        EditPart epStart = null;
        if (epBegin == null) {
            epStart = this;
        } else {
            epStart = epBegin;
        }

        final View view = (View) ((IAdaptable) epStart)
            .getAdapter(View.class);

        if (view != null) {
            EObject el = ViewUtil.resolveSemanticElement(view);

            if ((el != null) && el.equals(theElement)) {
                return epStart;
d665 22
a686 9
        }

        ListIterator childLI = epStart.getChildren().listIterator();
        while (childLI.hasNext()) {
            EditPart epChild = (EditPart) childLI.next();

            EditPart elementEP = findEditPart(epChild, theElement);
            if (elementEP != null) {
                return elementEP;
d688 1
d693 81
a773 3
    /** Invoke the editpart's refresh mechanism. */
    public void refresh() {
        try {
d775 120
a894 120
    
                public void run() {
                    EditPolicyIterator i = getEditPolicyIterator();
                    while (i.hasNext()) {
                        EditPolicy policy = i.next();
                        if (policy instanceof GraphicalEditPolicyEx) {
                            ((GraphicalEditPolicyEx) policy).refresh();
                        }
                    }
                    GraphicalEditPart.super.refresh();
                }
            });
        } catch (InterruptedException e) {
            Trace.catching(DiagramUIPlugin.getInstance(),
                DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "refresh", e); //$NON-NLS-1$
            Log.error(DiagramUIPlugin.getInstance(),
                DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING,
                "refresh", e); //$NON-NLS-1$
        }

    }

    /** Refresh the editpart's figure background colour. */
    protected void refreshBackgroundColor() {
        FillStyle style = (FillStyle)getPrimaryView().getStyle(NotationPackage.eINSTANCE.getFillStyle());
        if ( style != null ) {
            setBackgroundColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getFillColor())));
        }
    }

    /** Refresh the editpart's figure font. */
    protected void refreshFont() {
        FontStyle style = (FontStyle) getPrimaryView().getStyle(NotationPackage.eINSTANCE.getFontStyle());
        if (style != null) {
            setFont(new FontData(
                style.getFontName(), 
                style.getFontHeight(), 
                (style.isBold() ? SWT.BOLD : SWT.NORMAL) | 
                (style.isItalic() ? SWT.ITALIC : SWT.NORMAL)));
        }
    }

    /** Refresh the editpart's figure font colour. */
    protected void refreshFontColor() {
        FontStyle style = (FontStyle)  getPrimaryView().getStyle(NotationPackage.eINSTANCE.getFontStyle());
        if ( style != null ) {
            setFontColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getFontColor())));
        }
    }

    /** Refresh the editpart's figure foreground colour. */
    protected void refreshForegroundColor() {
        LineStyle style = (LineStyle)  getPrimaryView().getStyle(NotationPackage.eINSTANCE.getLineStyle());
        if ( style != null ) {
            setForegroundColor(DiagramColorRegistry.getInstance().getColor(new Integer(style.getLineColor())));
        }
    }

    /** Refresh the editpart's figure visibility. */
    protected void refreshVisibility() {
        Object model = null;
        EditPart ep = this;
        while (!(model instanceof View) && ep!=null){
            model = ep.getModel();
            ep = ep.getParent();
        }
        if (model instanceof View)
            setVisibility(((View)model).isVisible());
    }

    /** Refresh the editpart's figure visual properties. */
    protected void refreshVisuals() {
        super.refreshVisuals();
        refreshVisibility();
    }

    /**
     * Removes a listener previously added with the given id
     * 
     * @@param filterId the filter ID
     */
    protected void removeListenerFilter(String filterId) {
        if (listenerFilters == null)
            return;
        Object[] objects = (Object[]) listenerFilters.get(filterId);
        if (objects == null)
            return;
        if (objects.length>2){
            getDiagramEventBroker().
                removeNotificationListener((EObject) objects[0],
                                             (EStructuralFeature) objects[1],
                                             (NotificationListener) objects[2]);
        }else{
            getDiagramEventBroker().removeNotificationListener((EObject) objects[0],(NotificationListener) objects[1]);
        }
        listenerFilters.remove(filterId);
    }

    /**
     * sets the back ground color of this edit part
     * @@param color the new value of the back ground color
     */
    protected void setBackgroundColor(Color color) {
        getFigure().setBackgroundColor(color);
    }

    /**
     * Sets the font to the label.
     * This method could be overriden to change the font data of the font
     * overrides typically look like this:
     *      super.setFont(
     *      new FontData(
     *          fontData.getName(),
     *          fontData.getHeight(),
     *          fontData.getStyle() <| &> SWT.????));
     * @@param fontData the font data
     */
    protected void setFont(FontData fontData) {
        if (cachedFontData != null && cachedFontData.equals(fontData)) {
d917 1
a917 1
    }
d919 270
a1188 51
    /**
     * sets the font color
     * 
     * @@param color
     *            the new value of the font color
     */
    protected void setFontColor(Color color) {
        // NULL implementation
    }

    /**
     * sets the fore ground color of this edit part's figure
     * 
     * @@param color
     *            the new value of the foregroundcolor
     */
    protected void setForegroundColor(Color color) {
        getFigure().setForegroundColor(color);
    }
    
    /**
     * Sets the passed feature if possible on this editpart's view
     * to the passed value.
     * @@param feature the feature to use
     * @@param value  the value of the property being set
     */
    public void setStructuralFeatureValue(EStructuralFeature feature, Object value) {
        if (hasNotationView())
            ViewUtil.setStructuralFeatureValue((View) getModel(), feature, value);
    }

    /**
     * sets the visibility of this edit part
     * @@param vis the new value of the visibility
     */
    protected void setVisibility(boolean vis) {
        if (!vis && getSelected() != SELECTED_NONE)
            getViewer().deselect(this);

        getFigure().setVisible(vis);
        getFigure().revalidate();
    }
    
    /**
     * This method adds all listeners to the notational world (views, figures,
     * editpart...etc) Override this method to add more notational listeners
     * down the hierarchy
     */
    protected void addNotationalListeners() {
        if (hasNotationView()){
            addListenerFilter("View", this,(View)getModel()); //$NON-NLS-1$
a1189 10
    }
    
    /**
     * This method adds all listeners to the semantic element behind this EditPart
     * Override this method to add more semantic listeners down the hierarchy
     * This method is called only if the semantic element is resolvable
     */
    protected void addSemanticListeners() {
        addListenerFilter("SemanticElement", this,resolveSemanticElement());//$NON-NLS-1$
    }
d1191 6
a1196 31
    /**
     * This method removes all listeners to the notational world (views,
     * figures, editpart...etc) Override this method to remove notational
     * listeners down the hierarchy
     */
    protected void removeNotationalListeners() {
        removeListenerFilter("View"); //$NON-NLS-1$
    }

    /**
     * This method removes all listeners to the semantic element behind this EditPart
     * Override this method to remove semantic listeners
     * down the hierarchy
     */
    protected void removeSemanticListeners() {
        removeListenerFilter("SemanticElement"); //$NON-NLS-1$
    }

    /**
     * Perform a request by executing a command from the target editpart of the
     * request For the Direct_Edit request, we need to show up an editor first
     * 
     * @@see org.eclipse.gef.EditPart#performRequest(org.eclipse.gef.Request)
     */
    public void performRequest(Request request) {
        if ( !isEditModeEnabled() ) {
            if (RequestConstants.REQ_OPEN.equals(request.getType())) {
                //allowed, continue
            }
            else {
                return;
d1199 7
a1205 12
        
        if (RequestConstants.REQ_DIRECT_EDIT == request.getType()) {
            performDirectEditRequest(request);
        } else {
            EditPart targetEditPart = getTargetEditPart(request);
            if (targetEditPart != null) {
                Command command = targetEditPart.getCommand(request);
                if (command != null) {
                    getDiagramEditDomain().getDiagramCommandStack().execute(
                        command);
                    return;
                }
a1207 31
    }

    /**
     * Performs a direct edit request (usually by showing some type of editor)
     * 
     * @@param request
     *            the direct edit request
     */
    protected void performDirectEditRequest(Request request) {
        // NULL implementation
    }

    /**
     * @@see org.eclipse.gef.editparts.AbstractEditPart#getAccessibleEditPart()
     */
    protected AccessibleEditPart getAccessibleEditPart() {
        if (accessibleEP == null)
            accessibleEP = new AccessibleGraphicalEditPart() {

            private String getSemanticName() {
                EObject semanticElement = resolveSemanticElement();
            
                if( semanticElement != null ) {
                    String name = semanticElement.getClass().getName();
                    int startIndex = name.lastIndexOf('.') + 1;
                    int endIndex = name.lastIndexOf( "Impl" ); //$NON-NLS-1$
                    return name.substring(startIndex, endIndex);
                }
            
                return null;
            }
d1209 1
a1209 17
            public void getName(AccessibleEvent e) {
                IGraphicalEditPart childEP = getChildBySemanticHint(CommonParserHint.NAME);
                if (childEP == null) {
                    childEP = getChildBySemanticHint(CommonParserHint.DESCRIPTION);
                }
                if (childEP != null) {
                    IFigure fig = childEP.getFigure();
                    if (fig instanceof WrapLabel) {
                        e.result = ((WrapLabel) fig).getText();
                    }
                } else {
                    e.result = getSemanticName();
                }
            }
            };

        return accessibleEP;
d1211 6
a1216 17

    /** Adds a [ref, editpart] mapping to the EditPartForElement map. */
    protected void registerModel() {
        if (hasNotationView()) {
            super.registerModel();
        } else {
            getViewer().getEditPartRegistry().put(basicGetModel(), this);
        }

        // Save the elements Guid to use during unregister.
        // If the reference is null, do not register.
        EObject ref = null;
        if (hasNotationView())
            ref = getNotationView().getElement();
        else
            ref = (EObject) basicGetModel();
        if (ref == null) {
a1218 4
        elementGuid = EMFCoreUtil.getProxyID(ref);
        ((IDiagramGraphicalViewer) getViewer()).registerEditPartForElement(
            elementGuid, this);
    }
d1220 1
d1222 7
a1228 8
    /** Remove this editpart from the EditPartForElement map. */
    protected void unregisterModel() {
        if (hasNotationView())
            super.unregisterModel();
        else {
            Map registry = getViewer().getEditPartRegistry();
            if (registry.get(basicGetModel()) == this)
                registry.remove(basicGetModel());
d1231 7
a1237 3
        //Do not need to unregister if the guid is null.
        if (elementGuid == null) {
            return;
a1238 77
        ((IDiagramGraphicalViewer) getViewer()).unregisterEditPartForElement(
            elementGuid, this);
    }

    /**
     * Refreshes a child editpart by removing it and refreshing children
     * @@param child the child to refresh
     */
    protected final void refreshChild(GraphicalEditPart child) {
        removeChild(child);
        refreshChildren();
    }
    
    /**
     * Refreshes a source connection editpart by removing it and refreshing source connections
     * @@param conn the connection to refresh
     */
    protected final void refreshSourceConnection(ConnectionEditPart conn) {
        removeSourceConnection(conn);
        refreshSourceConnections();
    }

    /**
     * Refreshes a target connection editpart by removing it and refreshing target connections
     * @@param conn the connection to refresh
     */
    protected final void refreshTargetConnection(ConnectionEditPart conn) {
        removeTargetConnection(conn);
        refreshTargetConnections();
    }

    /**
     * Handles the case where the semantic reference has changed.
     */
    protected final void handleMajorSemanticChange() {
        if (getParent() instanceof GraphicalEditPart)
            ((GraphicalEditPart) getParent()).refreshChild(this);
        else if (getParent() instanceof ConnectionEditPart)
            ((ConnectionEditPart) getParent()).refreshChild(this);
    }
    
    /**
     * @@see org.eclipse.gef.EditPart#getDragTracker(org.eclipse.gef.Request)
     */
    public DragTracker getDragTracker(Request request) {
        return new DragEditPartsTrackerEx(this);
    }

    /**
     * @@return <tt>true</tt> a canonical editpolicy has been installed on this editpart
     * and it is active; otherwise <tt>false</tt>.
     */
    public boolean isCanonical() {
        CanonicalEditPolicy policy = (CanonicalEditPolicy)getEditPolicy(EditPolicyRoles.CANONICAL_ROLE);
        return policy == null ? false : policy.isActive();
    }

    /**
     * Return <tt>true</tt> if the editpart's figure is visible;
     * <tt>false</tt> otherwise.
     */
    public boolean isSelectable() {
        return getFigure().isShowing();
    }

    /* 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#disableEditMode()
     */
    public void disableEditMode() {
        this.editableEditPart.disableEditMode();        
    }
    
    /* 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#enableEditMode()
     */
    public void enableEditMode() {
        this.editableEditPart.enableEditMode();
d1240 5
a1244 5
    
    /* 
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#isEditModeEnabled()
     */
    public boolean isEditModeEnabled() {
d1249 1
a1249 121
        
        return this.editableEditPart.isEditModeEnabled();
    }
    
    /* 
     * @@see org.eclipse.gef.EditPart#showSourceFeedback(org.eclipse.gef.Request)
     */
    public void showSourceFeedback(Request request) {
        if ( !isEditModeEnabled()) {
            return;
        }
        
        super.showSourceFeedback(request);
    }
    
    /* 
     * @@see org.eclipse.gef.EditPart#showTargetFeedback(org.eclipse.gef.Request)
     */
    public void showTargetFeedback(Request request) {
        if ( !isEditModeEnabled()) {
            return;
        }
        
        super.showTargetFeedback(request);
    }

    /* 
     * @@see org.eclipse.gef.EditPart#eraseSourceFeedback(org.eclipse.gef.Request)
     */
    public void eraseSourceFeedback(Request request) {
        if ( !isEditModeEnabled()) {
            return;
        }
        
        super.eraseSourceFeedback(request);
    }
    /* 
     * @@see org.eclipse.gef.EditPart#eraseTargetFeedback(org.eclipse.gef.Request)
     */
    public void eraseTargetFeedback(Request request) {
        if ( !isEditModeEnabled()) {
            return;
        }

        super.eraseTargetFeedback(request);
    }
    
    /**
     * this method will return the primary child EditPart  inside this edit part
     * @@return the primary child view inside this edit part
     */
    public EditPart getPrimaryChildEditPart(){
        if (getChildren().size() > 0)
            return (EditPart) getChildren().get(0);
        return null;
    }
    
    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart#getDiagramPreferencesHint()
     */
    public PreferencesHint getDiagramPreferencesHint() {
        if (getRoot() instanceof IDiagramPreferenceSupport) {
            return ((IDiagramPreferenceSupport) getRoot()).getPreferencesHint();
        }
        return PreferencesHint.USE_DEFAULTS;
    }

    public void notifyChanged(Notification notification) {
        if (isActive()){
            handleNotificationEvent(notification);
        }
    }
    
    public Command transactionAboutToCommit(Notification notification) {
        return null;
    }

    
    /**
     * Handles the property changed event.  Clients should override to
     * respond to the specific notification events they are interested.
     * 
     * Note: This method may get called on a non-UI thread.  Clients should
     * either ensure that their code is thread safe and/or doesn't make
     * unsupported calls (i.e. Display.getCurrent() ) assuming they are on
     * the main thread.  Alternatively if this is not possible, then the
     * client can wrap their handler within the Display.synchExec runnable
     * to ensure synchronization and subsequent execution on the main thread.
     * 
     * @@param event
     *            the <code>Notification</code> object that is the property changed event
     */
    protected void handleNotificationEvent(Notification event) {
        if (NotationPackage.eINSTANCE.getView_PersistedChildren().equals(event.getFeature())||
                NotationPackage.eINSTANCE.getView_TransientChildren().equals(event.getFeature())) {
            refreshChildren();
        }else if (NotationPackage.eINSTANCE.getView_Visible().equals(event.getFeature())) {
            Object notifier = event.getNotifier();
            if (notifier== getModel())
                refreshVisibility();
            else {
                refreshChildren();
            }
        }
        else if (NotationPackage.eINSTANCE.getView_Element().equals(event.getFeature())) {
            handleMajorSemanticChange();
        } 
    }
    
    /**
     * @@return <code>IMapMode</code> that allows for the coordinate mapping from device to
     * logical units. 
     */
    final protected IMapMode getMapMode() {
        RootEditPart root = getRoot();
        if (root instanceof DiagramRootEditPart) {
            DiagramRootEditPart dgrmRoot = (DiagramRootEditPart)root;
            return dgrmRoot.getMapMode();
        }
        
        return MapModeUtil.getMapMode();
d1251 130
a1380 10
    
    /**
     * indicates if this edit part's model is a view or not 
     * @@return <code>true</code> or <code>false</code>
     */
    public boolean hasNotationView(){
        return true;
    }
    
    /**
d1385 6
a1390 6
     */
    public Object getModel() {
        if (hasNotationView()){
            return super.getModel();
        } else {
            Object _model = basicGetModel();
d1393 4
a1396 4
            return node;
        }
    }
    
d1427 1
a1427 1
    // documentation copied from superclass
d1434 2
a1435 2

    public Object getPreferredValue(EStructuralFeature feature) {
d1463 1
a1463 2
    }   
    
d1472 3
a1474 2
        if (getViewer() instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) getViewer()).getResourceManager();
d1477 2
a1478 1
    }
@


1.42.2.7
log
@[152392] gmf_R1_0_maintenance Reverting  yLulu 060801 Performance of DiagramEditPart and ConnectionEditPart could be enhanced
@
text
@d26 1
a37 1
import org.eclipse.gef.EditPartViewer;
d68 1
d127 2
a128 4
    /**
     * Flag to indicate if the edit part is in edit mode
     */
    private boolean isEditable = true;
d148 2
a149 1
        setModel(model);        
d154 1
a154 1
        if (isActive()) {
d158 9
a166 20

        EObject semanticElement;
        EObject semanticProxy;
        if (hasNotationView()) {
            semanticProxy = ((View) super.getModel()).getElement();
            if ((semanticProxy==null)||semanticProxy.eIsProxy()) {
                semanticElement = null;
            } else {
                semanticElement = semanticProxy;
            }
        } else {
            semanticProxy = (EObject) basicGetModel();
            if ((semanticProxy!=null) && semanticProxy.eIsProxy()) {
                semanticElement = EMFCoreUtil.resolve(getEditingDomain(),
                    semanticProxy);
            } else {
                semanticElement = semanticProxy;
            }
        }

d173 1
a173 1

d308 2
a309 1
    public Object getAdapter(Class key) {       
d316 1
a316 1
        if (View.class.isAssignableFrom(key)) {
a319 2
            else
                return null;
a321 1
        Object model = basicGetModel();     
d325 1
a325 1
            EObject semanticObject = null;            
d335 1
a335 1
            if ((semanticObject!=null) && key.isInstance(semanticObject)) {
d345 4
a348 1
        return super.getAdapter(key);
d375 2
a376 3
        View view;
        if (hasNotationView() && (view = (View) super.getModel()) != null) {
            view = ViewUtil.getChildBySemanticHint(view,semanticHint);
d398 2
a399 3
        View view;
        if (hasNotationView() && (view = (View) super.getModel()) != null) {
            return ViewUtil.getChildBySemanticHint(view, semanticHint);
d609 5
a613 1
        return (IDiagramEditDomain) getEditDomain();
d636 1
a636 2
            return ViewUtil.getPropertyValue((View) super.getModel(), feature,
                feature.getEContainingClass());
a647 15
        EObject semanticElement = null;
        Object basicModel = basicGetModel();
        if (hasNotationView()) {
            semanticElement = ((View) basicModel).getElement();
        } else if (basicModel instanceof EObject) {
            semanticElement = (EObject) basicModel;
        }
        if (semanticElement == null) {
            return null;
        }

        if (!semanticElement.eIsProxy()) {
            return semanticElement;
        }

d660 1
a660 2
                                setResult(EMFCoreUtil.resolve(
                                    getEditingDomain(), element));
d785 1
a785 1
        FillStyle style = (FillStyle)getPrimaryView().getStyle(NotationPackage.Literals.FILL_STYLE);
d793 1
a793 1
        FontStyle style = (FontStyle) getPrimaryView().getStyle(NotationPackage.Literals.FONT_STYLE);
d805 1
a805 1
        FontStyle style = (FontStyle)  getPrimaryView().getStyle(NotationPackage.Literals.FONT_STYLE);
d813 1
a813 1
        LineStyle style = (LineStyle)  getPrimaryView().getStyle(NotationPackage.Literals.LINE_STYLE);
d845 1
a845 1
        Object[] objects = (Object[]) listenerFilters.remove(filterId);
d856 1
a856 1
        
d879 1
a879 1
         if (cachedFontData != null && cachedFontData.equals(fontData)) {
d906 3
a908 1
     * @@param color the new value of the font color
d916 3
a918 1
     * @@param color the new value of the foregroundcolor
d931 2
a932 4
        if (hasNotationView() && (feature != null)) {
            ViewUtil.setPropertyValue((View) super.getModel(), feature, feature
                .getEContainingClass(), value);
        }
a1066 1
        EditPartViewer viewer = getViewer();
d1070 1
a1070 1
            viewer.getEditPartRegistry().put(basicGetModel(), this);
d1084 1
a1084 1
        ((IDiagramGraphicalViewer) viewer).registerEditPartForElement(
a1090 1
        EditPartViewer viewer = getViewer();
d1094 1
a1094 1
            Map registry = viewer.getEditPartRegistry();
d1103 1
a1103 1
        ((IDiagramGraphicalViewer) viewer).unregisterEditPartForElement(
d1172 1
a1172 23
        if (!isEditModeEnabled()) {
            return;
        }

        List l = getSourceConnections();
        int size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        List c = getChildren();
        size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).disableEditMode();
            }
        }

        isEditable = false;
d1179 1
a1179 23
        if (isEditModeEnabled()) {
            return;
        }

        isEditable = true;

        List c = getChildren();
        int size = c.size();
        for (int i = 0; i < size; i++) {
            Object obj = c.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }

        List l = getSourceConnections();
        size = l.size();
        for (int i = 0; i < size; i++) {
            Object obj = l.get(i);
            if (obj instanceof IEditableEditPart) {
                ((IEditableEditPart) obj).enableEditMode();
            }
        }
d1190 2
a1191 1
        return isEditable;
d1251 2
a1252 3
        RootEditPart root = getRoot();
        if (root instanceof IDiagramPreferenceSupport) {
            return ((IDiagramPreferenceSupport) root).getPreferencesHint();
d1282 3
a1284 3
    protected void handleNotificationEvent(Notification event) {        
        if (NotationPackage.Literals.VIEW__PERSISTED_CHILDREN.equals(event.getFeature())||
                NotationPackage.Literals.VIEW__TRANSIENT_CHILDREN.equals(event.getFeature())) {
d1286 1
a1286 1
        }else if (NotationPackage.Literals.VIEW__VISIBLE.equals(event.getFeature())) {
d1294 1
a1294 1
        else if (NotationPackage.Literals.VIEW__ELEMENT.equals(event.getFeature())) {
d1303 1
a1303 1
     protected IMapMode getMapMode() {
d1375 2
a1376 2
    
   public Object getPreferredValue(EStructuralFeature feature) {
d1404 2
a1405 1
    }    
d1414 2
a1415 3
        EditPartViewer viewer = getViewer();
        if (viewer instanceof DiagramGraphicalViewer) {
            return ((DiagramGraphicalViewer) viewer).getResourceManager();
d1418 1
a1418 2
    }    
    
@


1.42.2.8
log
@[152470] gmf_R1_0_maintenance mmostafa  060810 Graphical edit part does not update the cached editing
[146337] gmf_R1_0_maintenance mmostafa  060810 DiagramEventBroker isn't listening to resource level events
@
text
@a1423 11
    protected IFigure createFigure() {
        // TODO Auto-generated method stub
        return null;
    }

    public void setModel(Object model) {
        // reset the editing domain cache
        editingDomain = null;
        super.setModel(model);
    }

@


1.42.2.9
log
@Bugzilla#154062 gmf_R1_0_maintenance cmahoney 060822 recent gmf diagram change breaks compare/merge
@
text
@a293 4
    }

    public void removeNotify() {
        super.removeNotify();
a299 1

@


1.42.2.10
log
@[158731] gmf_R1_0_maintenance mgoyal 061005 GraphicalEditPart isn't disabling source/target canonical editpolicies for ReconnectRequest
@
text
@a48 1
import org.eclipse.gef.requests.ReconnectRequest;
a522 20
        if((request instanceof ReconnectRequest)) {
            ReconnectRequest reconnect = (ReconnectRequest)request;
            hosts.add(this);
            hosts.add(getParent());
            if(reconnect.getTarget() != null) {
                EditPart target  = reconnect.getTarget();
                addEditPartAndParent(hosts, target);
            }
            if(reconnect.getConnectionEditPart() != null) {
                org.eclipse.gef.ConnectionEditPart connectionEditPart = reconnect.getConnectionEditPart();
                if(connectionEditPart.getSource() != null) {
                    EditPart srcEP = connectionEditPart.getSource();
                    addEditPartAndParent(hosts, srcEP);
                }
                if(connectionEditPart.getTarget() != null) {
                    EditPart trgEP = connectionEditPart.getTarget();
                    addEditPartAndParent(hosts, trgEP);
                }
            }
        }
d544 2
a545 1
                addEditPartAndParent(hosts, ep);
a569 5
    private void addEditPartAndParent(Set hosts, EditPart editPart) {
        hosts.add(editPart);
        hosts.add(editPart.getParent());
    }

@


1.42.2.11
log
@[162114]   gmf_R1_0_maintenace mmostafa 061206 GraphicalEditPart refresh creates a child edit part without the correct editable state
@
text
@a1251 16
    
    
    protected void addChild(EditPart child, int index) {
        super.addChild(child, index);
        if (child instanceof GraphicalEditPart){
            GraphicalEditPart gEP = (GraphicalEditPart)child;
            boolean editMode = isEditModeEnabled(); 
            if (editMode != gEP.isEditModeEnabled()){
                if (editMode)
                    gEP.enableEditMode();
                else
                    gEP.disableEditMode();
            }
        }
    }

@


1.41
log
@bugzilla 140020 gmf-head sshaw 060602 Deadlock in PopupBarEditPolicy$PopupBarLabelHandle
@
text
@a71 1
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.NotificationForEditPartsListener;
d109 1
a109 1
	implements IGraphicalEditPart, IAdaptableSelection, NotificationForEditPartsListener {
@


1.40
log
@bugzilla 142803 gmf-head sshaw 060531 Illegal Asynchronous Access to ResourceSetChangeEvent in DiagramEventBrokerThreadSafe
@
text
@d1147 1
a1147 1
		if (EditPartUtil.isWriteTransactionInProgress(this, true))
@


1.39
log
@bugzilla 143558 gmf-head mmostafa 060525 GraphicalEditPart#deactivate() should call removeSemanticListeners()
@
text
@d72 1
d80 1
d110 1
a110 1
	implements IGraphicalEditPart, IAdaptableSelection, NotificationListener {
d1145 5
d1326 2
a1327 2
    
    // documentation copied from superclass
@


1.38
log
@Bugzilla#142004 gmf_head cmahoney 050516 Cannot assume getDiagramEventBroker() will not be null
@
text
@d256 1
@


1.37
log
@Bugzilla#109422 gmf_head cmahoney 060509 Removing deprecated classes from GMF diagram components
@
text
@d177 10
a186 6
		Assert.isNotNull(filterId);
		Assert.isNotNull(listener);
		if (listenerFilters == null)
			listenerFilters = new HashMap();
		getDiagramEventBroker().addNotificationListener(element,listener);
		listenerFilters.put(filterId.intern(), new Object[] {element, listener});
d205 12
a216 6
		Assert.isNotNull(filterId);
		Assert.isNotNull(listener);
		if (listenerFilters == null)
			listenerFilters = new HashMap();
		getDiagramEventBroker().addNotificationListener(element,feature,listener);
		listenerFilters.put(filterId.intern(), new Object[] {element,feature, listener});
@


1.36
log
@bugzilla 138066 gmf-head mmostafa 060421 Memory leak caused by the GraphicalEditPart
@
text
@d76 1
d496 21
a516 2
		return hosts;
	}
a592 11

	/**
	 * Convenience method to retreive the value for the supplied value from the
	 * editpart's associated view element. Same as calling
	 * <code> ViewUtil.getPropertyValue(getNotationViewT(),id)</code>.
	 * @@deprecated use {@@link #getStructuralFeatureValue(EStructuralFeature)} instead
	 */

	public Object getPropertyValue(Object id) {
		return ViewUtil.getPropertyValue((View) getModel(), id);
	}
a868 12

	/**
	 * Sets the property with the given id if possible on this editpart's view
	 * to the passed value.
	 * @@param id  the id of the property being set
	 * @@param value  the value of the property being set
	 * @@deprecated use {@@link #setStructuralFeatureValue(Object, Object)} instead
	 */
	public void setPropertyValue(Object id, Object value) {
		if (hasNotationView())
			ViewUtil.setPropertyValue((View) getModel(), id, value);
	}
@


1.35
log
@[131220] gmf_head ldamus 060309 NPE in GraphicalEditPart#getRoot
@
text
@d108 2
a109 2

	/** A map of listener filters ids to filter data */
a120 5
	// temporary object used to make getModel returns a view 
	// this should be removed after the assumption that getModel
	// will return a view is removed
	private static Node dummyNode = null;
	
d1265 5
a1269 2
	/* (non-Javadoc)
	 * @@see org.eclipse.gef.EditPart#getModel()
d1276 3
a1278 7
			// this is just temporary, so we do not break the assumption that the model
			// is always a view
			if (dummyNode == null){
				dummyNode = NotationFactory.eINSTANCE.createNode();
			}
			dummyNode.setElement((EObject)_model);
			return dummyNode;
@


1.34
log
@[131119] gmf_head ldamus 060209 Unable to override GraphicalEditPart.getEditingDomain() as it is final
@
text
@d1317 8
@


1.33
log
@Bugzilla#131119 gmf_head cmahoney 060309 Unable to override GraphicalEditPart.getEditingDomain() as it is final
@
text
@d1289 2
a1290 2
     * Derives my editing domain from my diagram element. Subclasses may
     * override.
d1294 7
a1300 1
            editingDomain = TransactionUtil.getEditingDomain(getDiagramView());
@


1.32
log
@Bugzilla#129773 gmf_head cmahoney 060308 Delete from Project Explorer does not delete view from diagram
@
text
@d1292 1
a1292 1
    public final TransactionalEditingDomain getEditingDomain() {
@


1.31
log
@[130634] gmf_head ldamus 060306 GraphicalEditPart#getCommand() should get the editing domain using #getEditingDomain()
@
text
@d155 1
a155 1
		EObject semanticElement = EMFCoreUtil.resolve(TransactionUtil.getEditingDomain((EObject)getModel()), semanticProxy);
d305 1
a305 1
					semanticObject = EMFCoreUtil.resolve(TransactionUtil.getEditingDomain(element), element);
d610 1
a610 2
			return (EObject) TransactionUtil.getEditingDomain(
				(EObject) getModel()).runExclusive(
d720 1
a720 2
			TransactionUtil.getEditingDomain((EObject) getModel())
				.runExclusive(new Runnable() {
@


1.30
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d401 1
a401 2
				cmd = (Command) TransactionUtil.getEditingDomain(
					(EObject) getModel()).runExclusive(
@


1.29
log
@bugzilla 127691 gmf-head sshaw 060227 Labels on connections don't print correctly - very small
@
text
@a16 1
import java.util.Dictionary;
a18 1
import java.util.Hashtable;
a28 1
import org.eclipse.emf.ecore.ENamedElement;
d31 1
d51 2
a54 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
d64 3
a71 1
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
d81 1
a81 3
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.emf.core.util.MetaModelUtil;
import org.eclipse.gmf.runtime.emf.core.util.ProxyUtil;
d127 5
d155 1
a155 1
		EObject semanticElement = ProxyUtil.resolve(MEditingDomainGetter.getMEditingDomain((EObject)getModel()), semanticProxy);
d185 1
a185 1
		DiagramEventBroker.getInstance().addNotificationListener(element,listener);
d209 1
a209 1
		DiagramEventBroker.getInstance().addNotificationListener(element,feature,listener);
d254 1
a254 1
					DiagramEventBroker.getInstance().
d257 1
a257 1
					DiagramEventBroker.getInstance().removeNotificationListener((EObject) obj[0],(NotificationListener) obj[1]);
d305 1
a305 1
					semanticObject = ProxyUtil.resolve(MEditingDomainGetter.getMEditingDomain(element), element);
d400 18
a417 6
			cmd =  (Command) MEditingDomainGetter.getMEditingDomain((EObject)getModel()).runAsRead(new MRunnable() {
				
				public Object run() {
					return GraphicalEditPart.super.getCommand(request);
				}
			});
d610 28
a637 1
		return (EObject) MEditingDomainGetter.getMEditingDomain((EObject)getModel()).runAsRead(new MRunnable() {
a638 14
			public Object run() {
				Object model = getModel();
				if (model instanceof View)
					return ViewUtil.resolveSemanticElement((View)getModel());
				else if (model instanceof EObject){
					EObject element = (EObject)model;
					if (element.eIsProxy())
				    	return ProxyUtil.resolve(element); 
					else
						return element;
				}
				return null;
			}
		});
d721 11
a731 8
		MEditingDomainGetter.getMEditingDomain((EObject)getModel()).runAsRead(new MRunnable() {

			public Object run() {
				EditPolicyIterator i = getEditPolicyIterator();
				while (i.hasNext()) {
					EditPolicy policy = i.next();
					if (policy instanceof GraphicalEditPolicyEx) {
						((GraphicalEditPolicyEx) policy).refresh();
d733 1
d735 10
a744 4
				GraphicalEditPart.super.refresh();
				return null;
			}
		});
d813 1
a813 1
			DiagramEventBroker.getInstance().
d818 1
a818 1
			DiagramEventBroker.getInstance().removeNotificationListener((EObject) objects[0],(NotificationListener) objects[1]);
d844 1
a844 1
            Display.getDefault(),
d849 2
a850 2
    		getFigure().repaint();
        }
a940 77
	
	/**
	 * Return a Map of all the appearance property ids supported by the edit
	 * part and its children.
	 * 
	 * Each entry in the map is the factory hint of the edit part as key and a
	 * dictionary of appearance properties as values. The edit parts are the
	 * receiver itself and it's children.
	 * 
	 * For example, the connectable shape edit part with name, attribute,
	 * operation and shape compartments will return a map where: 1 entry:
	 * connectable shape factory hint -> dictionary: Properties.ID_FONT -> font
	 * data Properties.ID_FONTCOLOR -> font color Properties.ID_LINECOLOR ->
	 * line color Properties.ID_FILLCOLOR -> fill color 2d entry: attribute
	 * compartment hint -> dictionary(empty) 3d entry: operation compartment
	 * hint -> dictionary(empty) 4d entry: shape compartment hint ->
	 * dictionary(empty)
	 * 
	 * @@return Map
	 */
	public Map getAppearancePropertiesMap() {
		Map properties = new HashMap();
		fillAppearancePropertiesMap(properties);
		// for each of the children fill
		Iterator iterator = getChildren().iterator();
		while (iterator.hasNext()) {
			IGraphicalEditPart child = (IGraphicalEditPart) iterator.next();
			child.fillAppearancePropertiesMap(properties);
		}
		return properties;
	}

	/**
	 * Add to the parent edit part appearance properties map. Edit parts that
	 * have thier own appearance properties in addition to the parent edit part
	 * font, font color, line color and fill color should override this method
	 * to include their specific appearance properties.
	 * 
	 * @@param properties -
	 *            map of appearence properties to which we add our own. The map
	 *            has the reciever as a key and string array of the supported
	 *            appearance property ids.
	 */
	public void fillAppearancePropertiesMap(Map properties) {
		if (getAppearancePropertyIDs().length > 0) {
			// only if there are any appearance properties
			final Dictionary local_properties = new Hashtable();
			for (int i = 0; i < getAppearancePropertyIDs().length; i++) {
				String prob = getAppearancePropertyIDs()[i];
				ENamedElement element = MetaModelUtil.getElement(prob);
				if (element instanceof EStructuralFeature &&
					hasNotationView()&&
					ViewUtil.isPropertySupported((View)getModel(), prob))
					local_properties.put(
						getAppearancePropertyIDs()[i],
						getStructuralFeatureValue((EStructuralFeature)element));
			}
			if (hasNotationView())
				properties.put(((View) getModel()).getType(), local_properties);
		}
	}

	/**
	 * a static array of appearance property ids applicable to shapes
	 */
	private static final String[] appearanceProperties = new String[] {Properties.ID_ISVISIBLE};

	/**
	 * Returns an array of the appearance property ids applicable to the
	 * receiver. Fro this type it is Properties.ID_ISVISIBLE
	 * 
	 * @@return - an array of the appearance property ids applicable to the
	 *         receiver
	 */
	private String[] getAppearancePropertyIDs() {
		return appearanceProperties;
	}
d1040 1
a1040 1
		elementGuid = ProxyUtil.getProxyID(ref);
d1214 4
d1219 1
d1261 1
a1261 1
				
d1290 11
d1303 3
a1305 2
     * Derives my editing domain from my diagram view element. Subclasses may
     * override.
d1307 6
a1312 2
    public TransactionalEditingDomain getEditingDomain() {
        return TransactionUtil.getEditingDomain(getDiagramView());
@


1.28
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@a33 2
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
d96 1
d804 8
a811 5
		getFigure().setFont(
			DiagramFontRegistry.getInstance().getFont(
				Display.getDefault(),
				fontData));
		getFigure().repaint();
@


1.27
log
@bugzilla 117592 gmf-head mmostafa 060207 Eroneous references to xtools in diagram plugins
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2004 IBM Corporation and others.
d34 4
d1321 8
@


1.26
log
@bugzilla 116224 gmf-head sshaw 060119 Notation meta-model support for coordinate systems
@
text
@d871 1
a871 1
	 * This method adds all listeners to the semantic world (IUMLElement...etc)
d889 2
a890 2
	 * This method removes all listeners to the semantic world
	 * (IUMLElement...etc) Override this method to remove semantic listeners
@


1.25
log
@bugzilla 117912 gmf-head sshaw 060117 GraphicalEditPart / ConnectionEditPart could cause invalid thread access
@
text
@d41 1
d1283 6
a1288 4
		EditPart parent = getParent();
		if (parent instanceof org.eclipse.gef.GraphicalEditPart)
			return MapModeUtil.getMapMode(((org.eclipse.gef.GraphicalEditPart)parent).getFigure());
		
@


1.24
log
@bugzilla 121784 gmf-head mmostafa 051224 Class cast exception when adapting to Diagram when model is a Node
@
text
@d1247 9
a1255 1
	 * Handles the property changed event
d1258 1
a1258 1
	 *            the property changed event
@


1.23
log
@111894  gmf-head mmostafa 051201 Improve memory consumption of opened notation diagram
@
text
@d283 1
a283 1
			if (_model instanceof View)
a1239 44
	/*
	 * ATTENTION!!!!: Do not remove, see below. Only update based on newer GEF framework
	 *  
	 * This function is "copied" from GEF for the following reason:
	 * GEF does not check if the connection's source or target are the same as the editpart
	 * before setting them to <code>null</code> which causes the following usecase to currently fail:
	 * 
	 * "in a model transaction, view's source connections are detached, a new view is
	 * created, and the connections are attached to it, then the old view is destroyed"
	 * 
	 * The reason for the problem is the filtering of Deleted/Uncreated object's events in the
	 * DiagramEventBroker which prevents the first connection detach event from coming and 
	 * avoiding the problem
	 * 
	 * TODO: Remove this override as soon as the bugzilla <Bug 110476> is resolved or the event filtering is removed
	 * 
	 * @@see org.eclipse.gef.EditPart#removeNotify()
	 */
	public void removeNotify() {
		if (getSelected() != SELECTED_NONE)
			getViewer().deselect(this);
		if (hasFocus())
			getViewer().setFocus(null);

		List _children = getChildren();
		for (int i = 0; i < _children.size(); i++)
			((EditPart)_children.get(i))
				.removeNotify();
		unregister();
		List conns;
		conns = getSourceConnections();
		for (int i = 0; i < conns.size(); i++) {
			ConnectionEditPart conn = (ConnectionEditPart)conns.get(i);
			if (conn.getSource() == this)
				conn.setSource(null);
		}
		conns = getTargetConnections();
		for (int i = 0; i < conns.size(); i++) {
			ConnectionEditPart conn = (ConnectionEditPart)conns.get(i);
			if (conn.getTarget() == this)
				conn.setTarget(null);
		}
	}

@


1.22
log
@111894  gmf-head mmostafa 051201 Improve memory consumption of opened notation diagram
@
text
@d64 1
d199 2
d342 23
a364 2
			if (view != null)
				return  (IGraphicalEditPart)getViewer().getEditPartRegistry().get(view);
d555 1
a555 1
			return new ArrayList(((View)model).getChildren());
d864 1
a864 1
		if (hasNotationView())
d866 1
d868 1
a868 1

d895 1
a895 1

d1300 7
a1306 3
		}
		else if (NotationPackage.eINSTANCE.getView_Visible().equals(event.getFeature())) {
			refreshVisibility();
@


1.21
log
@119526 gmf-head mmostafa 051207 ListCompartmentEditPart causes UnsupportedOperationException in automatic filtering/sorting mode
@
text
@d198 1
@


1.20
log
@111894  gmf-head mmostafa 051201 Improve memory consumption of opened notation diagram
@
text
@d14 1
d177 1
a177 1
		listenerFilters.put(filterId, new Object[] {element, listener});
d198 1
a198 1
		listenerFilters.put(filterId, new Object[] {element,feature, listener});
d530 1
a530 1
			return ((View)model).getChildren();
@


1.19
log
@ bugzilla 111894 gmf-head mmostafa 051201 Improve memory consumption of opened notation diagram
@
text
@d1052 7
a1058 1
		super.unregisterModel();
@


1.18
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d83 2
d106 1
a106 1

d111 1
a111 1
	private String elementGuid;
d116 5
d124 1
a124 1
	 * @@param view
d127 2
a128 2
	public GraphicalEditPart(View view) {
		setModel(view);
d139 7
a145 2
		EObject semanticProxy = ((View) getModel()).getElement();
		EObject semanticElement = ProxyUtil.resolve(MEditingDomainGetter.getMEditingDomain((View)getModel()), semanticProxy);
a196 3
		if (listenerFilters == null)
			listenerFilters = new HashMap();
		DiagramEventBroker.getInstance().addNotificationListener(element,feature,listener);
d258 8
d269 1
a269 2
		
		Object model = getModel();
d276 4
a279 2
		if ( View.class.isAssignableFrom(key) && model instanceof View) {
			return model;
a282 1
			model instanceof View &&
d285 10
a294 1
			EObject semanticObject = ViewUtil.resolveSemanticElement((View)model);
d366 1
a366 1
			cmd =  (Command) MEditingDomainGetter.getMEditingDomain((View)getModel()).runAsRead(new MRunnable() {
d481 1
a481 1
			if (parent instanceof IPrimaryEditPart)
a528 1
			//return ((View)model).getVisibleChildren();
d551 4
a554 1
		return ViewUtil.getStructuralFeatureValue((View) getModel(),feature);
d564 1
a564 1
		return (EObject) MEditingDomainGetter.getMEditingDomain((View)getModel()).runAsRead(new MRunnable() {
d567 11
a577 1
				return ViewUtil.resolveSemanticElement((View) getModel());
d662 1
a662 1
		MEditingDomainGetter.getMEditingDomain((View)getModel()).runAsRead(new MRunnable() {
d716 8
a723 1
		setVisibility(((View)getModel()).isVisible());
d805 2
a806 1
		ViewUtil.setPropertyValue((View) getModel(), id, value);
d816 2
a817 1
		ViewUtil.setStructuralFeatureValue((View) getModel(), feature, value);
d838 2
a839 1
		addListenerFilter("View", this,(View)getModel()); //$NON-NLS-1$
d919 1
d925 2
a926 1
			properties.put(((View) getModel()).getType(), local_properties);
d1028 5
a1032 1
		super.registerModel();
d1034 7
a1040 3
		//Save the elements Guid to use during unregister.
		//If the reference is null, do not register.
		EObject ref = ((View) getModel()).getElement();
a1044 1

d1049 1
d1287 26
a1312 1

@


1.17
log
@bugzilla 115523 gmf-head mmostafa 051108 : the Activate method was being called on editparts that were already active
@
text
@d64 1
d67 1
a67 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d644 1
a644 1
			setBackgroundColor(DiagramResourceManager.getInstance().getColor(new Integer(style.getFillColor())));
d664 1
a664 1
			setFontColor(DiagramResourceManager.getInstance().getColor(new Integer(style.getFontColor())));
d672 1
a672 1
			setForegroundColor(DiagramResourceManager.getInstance().getColor(new Integer(style.getLineColor())));
d730 1
a730 1
			DiagramResourceManager.getInstance().getFont(
@


1.16
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@a13 1
import java.util.ArrayList;
d126 3
d140 1
d502 2
a503 1
			return new ArrayList(((View)model).getChildren());
d511 1
a511 1
	 * <code> ViewUtil.getPropertyValue(getNotationView(),id)</code>.
@


1.15
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d73 2
d1212 12
@


1.14
log
@bugzilla 110316 gmf-head mmostafa 051014 Compiler warning count should be 0 - runtime diagram layer components
@
text
@a18 1

d53 1
a54 1
import org.eclipse.gmf.runtime.diagram.core.listener.PresentationListener;
d67 1
a67 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d157 1
a157 1
		PresentationListener.getInstance().addNotificationListener(element,listener);
d181 1
a181 1
		PresentationListener.getInstance().addNotificationListener(element,feature,listener);
d185 1
a185 1
	/** Creates a connector editpart. */
d187 2
a188 2
			Object connectorView) {
		return (org.eclipse.gef.ConnectionEditPart) createChild(connectorView);
d226 1
a226 1
					PresentationListener.getInstance().
d229 1
a229 1
					PresentationListener.getInstance().removeNotificationListener((EObject) obj[0],(NotificationListener) obj[1]);
d375 1
a375 1
	 * and a <code>CreateConnectorViewRequest</code>'s source and target editparts.
d571 1
a571 1
	 * notation 3- Connectors are not refereshed since they are maintained by
d637 1
a637 1
			setBackgroundColor(PresentationResourceManager.getInstance().getColor(new Integer(style.getFillColor())));
d657 1
a657 1
			setFontColor(PresentationResourceManager.getInstance().getColor(new Integer(style.getFontColor())));
d665 1
a665 1
			setForegroundColor(PresentationResourceManager.getInstance().getColor(new Integer(style.getLineColor())));
d692 1
a692 1
			PresentationListener.getInstance().
d697 1
a697 1
			PresentationListener.getInstance().removeNotificationListener((EObject) objects[0],(NotificationListener) objects[1]);
d723 1
a723 1
			PresentationResourceManager.getInstance().getFont(
d1146 1
a1146 1
	 * GEF does not check if the connector's source or target are the same as the editpart
d1149 2
a1150 2
	 * "in a model transaction, view's source connectors are detached, a new view is
	 * created, and the connectors are attached to it, then the old view is destroyed"
d1153 1
a1153 1
	 * PresentationListener which prevents the first connector detach event from coming and 
@


1.13
log
@bugzilla 111142 gmf-head sshaw 051003 Performance regression fix, contributrd by Mohammed mostafa
@
text
@d1167 3
a1169 3
		List children = getChildren();
		for (int i = 0; i < children.size(); i++)
			((EditPart)children.get(i))
@


1.12
log
@Bugzilla 109092: gmf_head sshaw 050923 : fixing build errors
@
text
@a112 9
	//	protected Command getPropertyChangeCommand(
	//		Object property,
	//		Object oldValue,
	//		Object newValue) {
	//		// by default return null, which means there is no special command to
	// change the property
	//		return null;
	//	}

a145 24
	 * @@param notifier
	 *            An element notifer to add the listener to
	 * @@deprecated use {@@link GraphicalEditPart#addListenerFilter(String, PropertyChangeListener, EObject)} or
	 * {@@link GraphicalEditPart#addListenerFilter(String, PropertyChangeListener, EObject,EStructuralFeature )}
	 */
	/*protected void addListenerFilter(String filterId,
			PropertyChangeListener listener, PropertyChangeNotifier notifier) {
		if (notifier == null)
			return;
		Assert.isNotNull(filterId);
		Assert.isNotNull(listener);
		if (listenerFilters == null)
			listenerFilters = new HashMap();
		notifier.addPropertyChangeListener(listener);
		listenerFilters.put(filterId, new Object[] {notifier, listener});
	}*/
	
	/**
	 * Adds a listener filter by adding the given listener to a passed notifier
	 * 
	 * @@param filterId
	 *            A unique filter id (within the same editpart instance)
	 * @@param listener
	 *            A listener instance
d182 1
a182 1
		PresentationListener.getInstance().addNotificationListener(element,listener);
@


1.11
log
@bugzilla 110478 gmf-head sshaw Introduce a view refactoring helper based on semantic refactoring

Contributed by: Maged Elaasar
@
text
@a13 2
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
d19 1
d54 1
a54 1
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationEvent;
a55 1
import org.eclipse.gmf.runtime.diagram.core.listener.PropertyChangeNotifier;
d66 1
a70 1
import org.eclipse.gmf.runtime.diagram.ui.properties.Properties;
d93 1
a93 1
 * @@author melaasar
d99 1
a99 1
	implements IGraphicalEditPart, PropertyChangeListener, IAdaptableSelection {
d160 1
a160 1
	protected void addListenerFilter(String filterId,
d170 1
a170 1
	}
d183 1
a183 1
			PropertyChangeListener listener,
d191 1
a191 1
		PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d206 1
a206 1
			PropertyChangeListener listener,
d215 1
a215 1
		PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d261 1
a261 1
						removePropertyChangeListener((EObject)obj[0],(EStructuralFeature) obj[1],(PropertyChangeListener) obj[2]);
d263 1
a263 4
					if (obj[0] instanceof PropertyChangeNotifier)
						((PropertyChangeNotifier) obj[0]).removePropertyChangeListener((PropertyChangeListener) obj[1]);
					else
						PresentationListener.getInstance().removePropertyChangeListener((EObject) obj[0],(PropertyChangeListener) obj[1]);
a596 39
	 * Handles the passed property changed event only if the editpart's view is
	 * not deleted.
	 */
	public final void propertyChange(PropertyChangeEvent event) {
		if (isActive())
			handlePropertyChangeEvent(event);
	}

	/**
	 * Handles the property changed event
	 * 
	 * @@param event
	 *            the property changed event
	 */
	protected void handlePropertyChangeEvent(PropertyChangeEvent event) {
		if (Properties.ID_PERSISTED_CHILDREN.equals(event.getPropertyName())||
			Properties.ID_TRANSIENT_CHILDREN.equals(event.getPropertyName())) {
			refreshChildren();
		}
		else if (Properties.ID_ISVISIBLE.equals(event.getPropertyName())) {
			refreshVisibility();
		}
		else if (Properties.ID_SEMANTICREF.equals(event.getPropertyName())) {
			handleMajorSemanticChange();
		} else if (event instanceof NotificationEvent) {
			handleNotificationEvent((NotificationEvent) event);
		}
	}

	/**
	 * Handles the supplied notification event.
	 * 
	 * @@param e event to handle
	 */
	protected void handleNotificationEvent(NotificationEvent e) {
		// for children to override
	}

	/**
d727 1
a727 1
				removePropertyChangeListener((EObject) objects[0],
d729 1
a729 1
											 (PropertyChangeListener) objects[2]);
d731 1
a731 6
			if (objects[0] instanceof PropertyChangeNotifier){
				((PropertyChangeNotifier) objects[0])
				  .removePropertyChangeListener((PropertyChangeListener) objects[1]);
			} else {
				PresentationListener.getInstance().removePropertyChangeListener((EObject) objects[0],(PropertyChangeListener) objects[1]);
			}
@


1.10
log
@Bugzilla 109092: gmf_head sshaw 050923 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d14 2
d55 1
a55 1
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationListener;
d57 1
a67 1
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
d72 1
d95 1
a95 1
 * @@author melaasar,mmostafa
d101 1
a101 1
	implements IGraphicalEditPart, IAdaptableSelection, NotificationListener {
d162 1
a162 1
	/*protected void addListenerFilter(String filterId,
d172 1
a172 1
	}*/
d185 1
a185 1
			NotificationListener listener,
d193 1
a193 1
		PresentationListener.getInstance().addNotificationListener(element,listener);
d208 1
a208 1
			NotificationListener listener,
d217 1
a217 1
		PresentationListener.getInstance().addNotificationListener(element,listener);
d263 1
a263 1
						removeNotificationListener((EObject)obj[0],(EStructuralFeature) obj[1],(NotificationListener) obj[2]);
d265 4
a268 1
					PresentationListener.getInstance().removeNotificationListener((EObject) obj[0],(NotificationListener) obj[1]);
d602 39
d771 1
a771 1
				removeNotificationListener((EObject) objects[0],
d773 1
a773 1
											 (NotificationListener) objects[2]);
d775 6
a780 1
			PresentationListener.getInstance().removeNotificationListener((EObject) objects[0],(NotificationListener) objects[1]);
d1225 44
@


1.9
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d31 1
d74 1
d538 2
a539 1
	 * <code> getView().getPropertyValue(id)</code>.
d545 9
d778 7
d788 10
d895 3
a897 1
				if (ViewUtil.isPropertySupported((View)getModel(), prob))
d900 1
a900 1
						getPropertyValue(prob));
@


1.8
log
@Bugzilla 109618: gmf_head mmostafa 050915 :  Remove the deprecated view facade interfaces and classes
@
text
@a13 2
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
d30 1
d52 1
a52 1
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationEvent;
a53 1
import org.eclipse.gmf.runtime.diagram.core.listener.PropertyChangeNotifier;
d64 1
a68 1
import org.eclipse.gmf.runtime.diagram.ui.properties.Properties;
d90 1
a90 1
 * @@author melaasar
d96 1
a96 1
	implements IGraphicalEditPart, PropertyChangeListener, IAdaptableSelection {
d157 1
a157 1
	protected void addListenerFilter(String filterId,
d167 1
a167 1
	}
d180 1
a180 1
			PropertyChangeListener listener,
d188 1
a188 1
		PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d203 1
a203 1
			PropertyChangeListener listener,
d212 1
a212 1
		PresentationListener.getInstance().addPropertyChangeListener(element,listener);
d258 1
a258 1
						removePropertyChangeListener((EObject)obj[0],(EStructuralFeature) obj[1],(PropertyChangeListener) obj[2]);
d260 1
a260 4
					if (obj[0] instanceof PropertyChangeNotifier)
						((PropertyChangeNotifier) obj[0]).removePropertyChangeListener((PropertyChangeListener) obj[1]);
					else
						PresentationListener.getInstance().removePropertyChangeListener((EObject) obj[0],(PropertyChangeListener) obj[1]);
a583 39
	 * Handles the passed property changed event only if the editpart's view is
	 * not deleted.
	 */
	public final void propertyChange(PropertyChangeEvent event) {
		if (isActive())
			handlePropertyChangeEvent(event);
	}

	/**
	 * Handles the property changed event
	 * 
	 * @@param event
	 *            the property changed event
	 */
	protected void handlePropertyChangeEvent(PropertyChangeEvent event) {
		if (Properties.ID_PERSISTED_CHILDREN.equals(event.getPropertyName())||
			Properties.ID_TRANSIENT_CHILDREN.equals(event.getPropertyName())) {
			refreshChildren();
		}
		else if (Properties.ID_ISVISIBLE.equals(event.getPropertyName())) {
			refreshVisibility();
		}
		else if (Properties.ID_SEMANTICREF.equals(event.getPropertyName())) {
			handleMajorSemanticChange();
		} else if (event instanceof NotificationEvent) {
			handleNotificationEvent((NotificationEvent) event);
		}
	}

	/**
	 * Handles the supplied notification event.
	 * 
	 * @@param e event to handle
	 */
	protected void handleNotificationEvent(NotificationEvent e) {
		// for children to override
	}

	/**
d714 1
a714 1
				removePropertyChangeListener((EObject) objects[0],
d716 1
a716 1
											 (PropertyChangeListener) objects[2]);
d718 1
a718 6
			if (objects[0] instanceof PropertyChangeNotifier){
				((PropertyChangeNotifier) objects[0])
				  .removePropertyChangeListener((PropertyChangeListener) objects[1]);
			} else {
				PresentationListener.getInstance().removePropertyChangeListener((EObject) objects[0],(PropertyChangeListener) objects[1]);
			}
d1144 25
@


1.7
log
@bugzilla 109407 gmf-head sshaw 050913 CanonicalEditPolicy hierarchy consolidation
@
text
@a52 1
import org.eclipse.gmf.runtime.diagram.core.internal.view.IView;
a66 1
import org.eclipse.gmf.runtime.diagram.ui.internal.util.IncarnationUtil;
a111 2
	private IView incarnatedView = null;
	
d554 1
a554 1
	protected EObject resolveSemanticElement() {
a577 11
	 * Return the editpart's associated view. Same as calling
	 * <code>(IView)getModel()</code>
	 */
	public IView getView() {
		if (incarnatedView==null){
			incarnatedView = IncarnationUtil.incarnateView((View)getModel()); 
		}
		return incarnatedView;
	}
	
	/**
@


1.6
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a58 1
import org.eclipse.gmf.runtime.diagram.ui.commands.ToggleCanonicalModeCommand;
d64 1
@


1.5
log
@Bugzilla109092 : gmf_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.4
log
@Bugzilla109092 : gmf_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d159 1
a159 1
	 * {@@link ConnectionEditPart#addListenerFilter(String, PropertyChangeListener, EObject,EStructuralFeature )}
@


1.3
log
@Bugzilla109092 : rmp_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d158 2
a159 1
	 *  @@deprecated use <code> addListenerFilter(String,PropertyChangeListener,EObject)</code>
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d31 1
a46 8
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.SWT;
import org.eclipse.swt.accessibility.AccessibleEvent;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.IActionFilter;

d56 1
a72 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d83 7
d144 1
a144 1
			addListenerFilter("SemanticProxy", this, PresentationListener.getNotifier(semanticProxy)); //$NON-NLS-1$
d158 1
d171 47
d259 9
a267 1
				((PropertyChangeNotifier) obj[0]).removePropertyChangeListener((PropertyChangeListener) obj[1]);
d768 13
a780 2
		((PropertyChangeNotifier) objects[0])
			.removePropertyChangeListener((PropertyChangeListener) objects[1]);
d849 1
a849 1
		addListenerFilter("View", this, ViewUtil.getPropertyChangeNotifier((View)getModel())); //$NON-NLS-1$
d858 1
a858 1
		addListenerFilter("SemanticElement", this, PresentationListener.getNotifier(resolveSemanticElement()));//$NON-NLS-1$
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d84 6
a89 6
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.FillStyle;
import com.ibm.xtools.notation.FontStyle;
import com.ibm.xtools.notation.LineStyle;
import com.ibm.xtools.notation.NotationPackage;
import com.ibm.xtools.notation.View;
@

