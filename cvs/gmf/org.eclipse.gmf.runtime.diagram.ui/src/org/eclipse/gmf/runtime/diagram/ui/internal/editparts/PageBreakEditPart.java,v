head	1.9;
access;
symbols
	v20081023-2107:1.9
	v20081022-1925:1.9
	v20081022-1005:1.9
	v20081020-0700:1.9
	v20080917-1925:1.9
	v20080916-2008:1.9
	v20080911-1728:1.9
	v20080911-1506:1.9
	v20080910-1520:1.9
	v20080910-1510:1.9
	v20080903-1520:1.9
	v20080903-1510:1.9
	v20080813-1510:1.9
	v20080811-1546:1.9
	v20080731-1520:1.9
	v20080725-1738:1.9
	v20080723-2246:1.9
	v20080723-2232:1.9
	v20080723-1700:1.9
	v20080722-1827:1.9
	v20080718-1700:1.9
	v20080718-1731:1.9
	v20080716-1600:1.9
	v20080716-1642:1.9
	R2_1_maintenance:1.9.0.6
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080610-1132:1.9
	v20080603-1553:1.9
	v20080527-1255:1.9
	v20080527-1151:1.9
	v20080516-1748:1.9
	v20080516-1143:1.9
	v20080512-1200:1.9
	v20080503-1740:1.9
	v20080501-2127:1.9
	v20080501-1739:1.9
	m20080429-1543:1.9
	v20080425-1959:1.9
	v20080417-1610:1.9
	v20080407-2250:1.9
	v20080407-0930:1.9
	v20080404-1111:1.9
	v20080328-1605:1.9
	v20080322-0000:1.9
	v20080222-1200:1.9
	v20080201-2010:1.9
	v20080201-0201:1.9
	v20080118-1129:1.9
	v20080114-2222:1.9
	v20080114-1111:1.9
	v20080107-1111:1.9
	v20071222-1111:1.9
	v20071214-1111:1.9
	v20071130-1111:1.9
	v20071124-0000:1.9
	v20071112-0000:1.9
	v20071108-0000:1.9
	v20071003-0000:1.9
	v20070915-0000:1.9
	v20070903-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.4
	R2_0:1.9
	R4_20:1.9
	v20070621-0000:1.9
	RC3_20:1.9
	v20070614-1400:1.9
	v20070608-1300:1.9
	v20070605-1400:1.9
	v20070601-1400:1.9
	v20070525-1500:1.9
	v20070518-1300:1.9
	bugzilla111892_group_support:1.9.0.2
	Root_bugzilla111892_group_support:1.9
	v20070504-1000:1.9
	v20070420-1000:1.9
	v20070413-1300:1.9
	v20070330-1300:1.9
	v20060330-1300:1.9
	v20070322-1100:1.9
	v20060316-0600:1.9
	v20070221-1500:1.9
	v20070208-1800:1.9
	v20070202-0200:1.6.2.3
	v20070119-1200:1.6.2.2
	v20070111-0800:1.6.2.2
	v20070105-1200:1.6.2.2
	v20070103-0300:1.7
	M4_20:1.7
	v20061218-1500:1.6.2.2
	v20061218-1200:1.7
	v20061214-0000:1.7
	M3_20:1.7
	v20061117-0800:1.7
	v20061027-1200:1.6.2.2
	v20061013-1330:1.7
	v20061012-1100:1.6.2.2
	v20060925-1700:1.6.2.2
	v20060919-0800:1.6.2.2
	v20060907-1100:1.6.2.1
	M1_20:1.6
	v20060831-1500:1.6.2.1
	v20060824-1600:1.6.2.1
	v20060817-1500:1.6.2.1
	v20060810-1700:1.6.2.1
	v20060803-1200:1.6.2.1
	v20060728-0500:1.6.2.1
	v20060721-1130:1.6.2.1
	v20060713-1700:1.6.2.1
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060616-1400:1.6
	v20060616-1200:1.6
	v20060609-1400:1.6
	v20060531-1730:1.5
	v20060530-1930:1.5
	v20060526-1200:1.5
	v20060519-0800:1.5
	v20060512-1000:1.5
	I20060512-1000:1.5
	I20060505-1400:1.5
	I20060428-1300:1.5
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060202-1415:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.4
	I20051223-1100:1.4
	I20051217-0925:1.4
	I20051208-2000:1.4
	I20051201-1800:1.4
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.3
	v20051030:1.2;
locks; strict;
comment	@# @;


1.9
date	2007.01.26.21.46.31;	author aboyko;	state Exp;
branches;
next	1.8;
commitid	544545ba76b74567;

1.8
date	2007.01.26.21.35.18;	author aboyko;	state Exp;
branches;
next	1.7;
commitid	5dfc45ba74154567;

1.7
date	2006.10.03.15.02.04;	author ahunter;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.05.19.42.45;	author sshaw;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2006.01.16.19.48.39;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.08.16.02.31;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.04.21.27.49;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.29.07;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.52;	author sshaw;	state Exp;
branches;
next	;

1.6.2.1
date	2006.07.11.17.46.19;	author cmahoney;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2006.09.13.16.43.40;	author ahunter;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2007.01.26.21.49.57;	author aboyko;	state Exp;
branches;
next	;
commitid	560f45ba77854567;


desc
@@


1.9
log
@gmf_head aboyko 070126 Updated copyrights date
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.internal.editparts;

import org.eclipse.draw2d.Cursors;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gef.DragTracker;
import org.eclipse.gef.EditPolicy;
import org.eclipse.gef.Request;
import org.eclipse.gef.RootEditPart;
import org.eclipse.gef.editparts.AbstractGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint;
import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IDiagramPreferenceSupport;
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.PageBreakNonResizableEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.figures.PageBreaksFigure;
import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
import org.eclipse.gmf.runtime.diagram.ui.tools.DragEditPartsTrackerEx;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.jface.preference.IPreferenceStore;

/**
 * Edit part which controls the page breaks figure. 
 * 
 * @@author jcorchis
 * @@canBeSeenBy %level1
 */
public class PageBreakEditPart extends AbstractGraphicalEditPart {

	/* Figure associated with this graphic edit part */
	private PageBreaksFigure pageOutlineFigure;

	/* The size for the entire diagram 	 */
	private Rectangle diagramBounds = new Rectangle();

//	/* Attribute used to store the page breaks */
//	private Rectangle pageBreakBounds;

	/**
	 * Method to update this the bounds of the shapes
	 * on the diagram.
	 * @@param bounds the bounds of the shapes on the diagram
	 */
	public void set(Point location, Rectangle bounds) {
		
		if (bounds.x < location.x || bounds.y < location.y) {
			// Figure's have been moved to the left or above the 
			// the page breaks figure's location
			calculatePageBreakFigureBounds(true, bounds.getSize());
		} else {
			// Calculate the number of pages needed to contain
			// the diagram
			int width = Math.abs(bounds.right() - location.x);
			int height = Math.abs(bounds.bottom() - location.y);
			
			updatePageCount(width, height);			
			
			getPageBreaksFigure().setLocation(location);
			
			
		}	
	}

	private void updatePageCount(int width, int height) {
		Point printerPageSize = getPageSize();
		float numCols = ((float) width) / printerPageSize.x;
		int cols = Math.max(1, (int) Math.ceil(numCols));
		float numRows = ((float) height) / printerPageSize.y;
		int rows = Math.max(1, (int) Math.ceil(numRows));

		int xInc = printerPageSize.x * cols;
		int yInc = printerPageSize.y * rows;

		getPageBreaksFigure().setSize(new Dimension(xInc, yInc));
		getPageBreaksFigure().setPageCount(rows, cols);
	}
	
	/**
	 * Calculates the size of the page breaks figure and the
	 * number of rows and columns based on the print page size.
	 * This method updates the page breaks figure bounds directly.
	 * 
	 * @@param center true to center the page breaks figure,
	 * false to not center it.
	 */
	public void calculatePageBreakFigureBounds(boolean center) {
		calculatePageBreakFigureBounds(center, diagramBounds.getSize());
	}
	
	/**
	 * Calculates the size of the page breaks figure and the
	 * number of rows and columns based on the print page size.
	 * This method will also center the page breaks figure.
	 */
	public void calculatePageBreakFigureBounds() {
		calculatePageBreakFigureBounds(true, diagramBounds.getSize());
	}	
	
	/**
	 * Calculates the size of the page breaks figure and the
	 * number of rows and columns based on the print page size.
	 * This method updates the page breaks figure bounds directly.
	 * 
	 * @@param center true to center the page breaks figure,
	 * false to not center it.
	 */
	private void calculatePageBreakFigureBounds(boolean center, Dimension bounds) {
		updatePageCount(bounds.width, bounds.height);
		
		if (center) {
			centerPageBreaksFigure();
		}
	}
	
	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.AbstractGraphicEditPart#createFigure()
	 */
	protected IFigure createFigure() {
		pageOutlineFigure = new PageBreaksFigure(PageBreaksFigure.FIGURE);
		pageOutlineFigure.setCursor(Cursors.SIZEALL);
		return pageOutlineFigure;
	}
	
	private PageBreaksFigure getPageBreaksFigure() {
		if (pageOutlineFigure == null) {
			createFigure();
		}
		return pageOutlineFigure;
	}

	/**
	 * @@see com.ibm.etools.gef.editparts.AbstractEditPart#createEditPolicies()
	 */
	protected void createEditPolicies() {
		installEditPolicy(
			EditPolicy.PRIMARY_DRAG_ROLE,
			new PageBreakNonResizableEditPolicy());
	}
	
	/**
	 * Utility method that calculate the printer page size.      
	 * @@return point the page size point.x == width, point.y == height
	 */
	public Point getPageSize() {
		IPreferenceStore s = getPreferenceStoreForPageSetup();
		
		IMapMode mm = MapModeUtil.getMapMode();
		RootEditPart drEP = getRoot();
		if (drEP instanceof DiagramRootEditPart) {
			mm = ((DiagramRootEditPart)drEP).getMapMode();
		}
		
		return PageInfoHelper.getPageSize(s, mm);
	}

	/**
	 * Utility method to set the page breaks figure such that the 
	 * all the diagram shapes appear centered within the page breaks
	 * figure.
	 */
	private void centerPageBreaksFigure() {

		Rectangle pageBreakBounds = getPageBreaksFigure().getBounds();

		Rectangle r = diagramBounds;
		Point offset =
			new Point(
				((pageBreakBounds.width - diagramBounds.width) / 2),
				((pageBreakBounds.height - diagramBounds.height) / 2));
		Rectangle centeredRec =
			new Rectangle(
				r.x - offset.x,
				r.y - offset.y,
				pageBreakBounds.width,
				pageBreakBounds.height);
		getPageBreaksFigure().setBounds(centeredRec);
		updatePreferenceStore();
	}

	/**
	 * Resizes the page outline figure based on changes to the diagram's children 
	 * @@param bounds the bounds of the figure 
	 */
	public void resize(Rectangle newBounds) {
		Rectangle pageBreakBounds = getFigure().getBounds();
		Point pageSize = getPageSize();

		// Change in the EAST/WEST directions
		if (newBounds.x != diagramBounds.x
			|| newBounds.width != diagramBounds.width) {

			if (newBounds.x < diagramBounds.x
				|| newBounds.right() < diagramBounds.right()) {

				// Move WEST: add cols to the WEST
				if (newBounds.x < pageBreakBounds.x) {
					int effectivewidth =
						Math.abs(pageBreakBounds.right() - newBounds.right())
							+ newBounds.width;
					float cols = ((float) effectivewidth) / pageSize.x;
					int requiredCols = (int) Math.ceil(Math.abs(cols));
					int xOffset = Math.round(requiredCols * pageSize.x);

					getPageBreaksFigure().setCols(requiredCols);
					pageBreakBounds = getPageBreaksFigure().getBounds();
					getPageBreaksFigure().setBounds(
						new Rectangle(
							pageBreakBounds.right() - xOffset,
							pageBreakBounds.y,
							xOffset,
							pageBreakBounds.height));
				}

				// Remove cols from the EAST? 
				pageBreakBounds = getPageBreaksFigure().getBounds();
				int effectiveWidth =
					Math.abs(newBounds.x - pageBreakBounds.x) + newBounds.width;
				float cols = ((float) effectiveWidth) / pageSize.x;
				int requiredCols = (int) Math.ceil(Math.abs(cols));
				int xOffset = Math.round(requiredCols * pageSize.x);
				getPageBreaksFigure().setCols(requiredCols);
				getPageBreaksFigure().setBounds(
					new Rectangle(
						pageBreakBounds.x,
						pageBreakBounds.y,
						xOffset,
						pageBreakBounds.height));

			} else {

				// Move EAST: add cols to the EAST
				if (newBounds.right() > pageBreakBounds.right()) {
					int effectiveWidth =
						Math.abs(newBounds.x - pageBreakBounds.x)
							+ newBounds.width;
					float x = ((float) effectiveWidth) / pageSize.x;
					int reqdCols = (int) Math.ceil(Math.abs(x));
					int xOffset = Math.round(reqdCols * pageSize.x);
					getPageBreaksFigure().setCols(reqdCols);
					pageBreakBounds = getFigure().getBounds();
					getPageBreaksFigure().setBounds(
						new Rectangle(
							pageBreakBounds.x,
							pageBreakBounds.y,
							xOffset,
							pageBreakBounds.height));
				}

				// Remove cols from the WEST?
				pageBreakBounds = getPageBreaksFigure().getBounds();
				int effectiveWidth =
					Math.abs(pageBreakBounds.right() - newBounds.right())
						+ newBounds.width;
				float cols = ((float) effectiveWidth) / pageSize.x;
				int requiredCols = (int) Math.ceil(Math.abs(cols));
				int xOffset = Math.round(requiredCols * pageSize.x);
				getPageBreaksFigure().setCols(requiredCols);
				getPageBreaksFigure().setBounds(
					new Rectangle(
						pageBreakBounds.right() - xOffset,
						pageBreakBounds.y,
						xOffset,
						pageBreakBounds.height));

			}
		}

		// Change in NORTH/SOUTH directions
		if (newBounds.y != diagramBounds.y
			|| newBounds.height != diagramBounds.height) {

			if (newBounds.y < diagramBounds.y
				|| newBounds.bottom() < diagramBounds.bottom()) {

				// Move NORTH: add rows to the NORTH
				if (newBounds.y < pageBreakBounds.y) {
					// Add row to the top
					int effectiveHeight =
						(pageBreakBounds.bottom() - newBounds.bottom())
							+ newBounds.height;
					float rows = ((float) effectiveHeight) / pageSize.y;
					int requiredRows = (int) Math.ceil(Math.abs(rows));
					int yOffset = Math.round(requiredRows * pageSize.y);

					getPageBreaksFigure().setRows(requiredRows);
					pageBreakBounds = getFigure().getBounds();
					getPageBreaksFigure().setBounds(
						new Rectangle(
							pageBreakBounds.x,
							pageBreakBounds.bottom() - yOffset,
							pageBreakBounds.width,
							yOffset));
				}

				// Remove rows to the SOUTH?
				pageBreakBounds = getPageBreaksFigure().getBounds();
				int effectiveHeight =
					Math.abs(newBounds.y - pageBreakBounds.y)
						+ newBounds.height;
				float rows = ((float) effectiveHeight) / pageSize.y;
				int requiredRows = (int) Math.ceil(Math.abs(rows));
				int yOffset = Math.round(requiredRows * pageSize.y);
				getPageBreaksFigure().setRows(requiredRows);
				pageBreakBounds = getFigure().getBounds();
				getPageBreaksFigure().setBounds(
					new Rectangle(
						pageBreakBounds.x,
						pageBreakBounds.y,
						pageBreakBounds.width,
						yOffset));


			} else {

				// Move SOUTH: add rows the SOUTH
				if (newBounds.bottom() > pageBreakBounds.bottom()) {
					// move south outside the page breaks boundary           		
					int effectiveHeight =
						(newBounds.y - pageBreakBounds.y) + newBounds.height;
					float rows = ((float) effectiveHeight) / pageSize.y;
					int requiredRows = (int) Math.ceil(Math.abs(rows));
					int yOffset = Math.round(requiredRows * pageSize.y);

					getPageBreaksFigure().setRows(requiredRows);
					pageBreakBounds = getFigure().getBounds();
					getPageBreaksFigure().setBounds(
						new Rectangle(
							pageBreakBounds.x,
							pageBreakBounds.y,
							pageBreakBounds.width,
							yOffset));
				}

				// Remove rows from the NORTH?
				pageBreakBounds = getPageBreaksFigure().getBounds();
				int effectiveheight =
					Math.abs(pageBreakBounds.bottom() - newBounds.bottom())
						+ newBounds.height;
				float rows = ((float) effectiveheight) / pageSize.y;
				int requiredRows = (int) Math.ceil(Math.abs(rows));
				int yOffset = Math.round(requiredRows * pageSize.y);

				getPageBreaksFigure().setRows(requiredRows);
				pageBreakBounds = getFigure().getBounds();
				getPageBreaksFigure().setBounds(
					new Rectangle(
						pageBreakBounds.x,
						pageBreakBounds.bottom() - yOffset,
						pageBreakBounds.width,
						yOffset));

			}
		}

		this.diagramBounds = newBounds;
	}
	
	/**
	 * Updates the workspace viewer's prefence store values for
	 * the page breaks figure location.
	 */
	public void updatePreferenceStore() {
		Rectangle r = getPageBreaksFigure().getBounds();
		
		//don't use the workspace one
		IPreferenceStore s = ((DiagramGraphicalViewer) getRoot().getViewer())
		.getWorkspaceViewerPreferenceStore();
		
		if (s != null) {
			s.setValue(WorkspaceViewerProperties.PAGEBREAK_X, r.x);
			s.setValue(WorkspaceViewerProperties.PAGEBREAK_Y, r.y);
		}
	}	

	/*
	 * @@see AbstractEditPart#getDragTracker(Request)
	 */
	public DragTracker getDragTracker(Request req) {
		return new DragEditPartsTrackerEx(this) {
			protected boolean isMove() {
				return true;
			}
		};
	}
	
	/**
	 * Return the workspace preference store from the DiagramUIPlugin or the
	 * diagram viewer's preference store, depending on what the user chose
	 * in the Page Setup dialog.
	 * 
	 * @@return IPreferenceStore for the workspace or diagram viewer
	 */
	private IPreferenceStore getPreferenceStoreForPageSetup() {
		IPreferenceStore workspaceStore = ((DiagramGraphicalViewer) getRoot()
			.getViewer()).getWorkspaceViewerPreferenceStore();

		if (workspaceStore
			.getBoolean(WorkspaceViewerProperties.PREF_USE_DIAGRAM_SETTINGS)) {
			return workspaceStore;
		} else if (getRoot() instanceof IDiagramPreferenceSupport) {
			return (IPreferenceStore)((IDiagramPreferenceSupport) getRoot()).getPreferencesHint()
				.getPreferenceStore();
		}
		return (IPreferenceStore) PreferencesHint.USE_DEFAULTS
			.getPreferenceStore();
	}
}
@


1.8
log
@[171428] gmf_head aboyko 070126 Print Preview and page breaks on the diagram are different
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.7
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d192 1
@


1.6
log
@bugzilla 145352 gmf-head sshaw 060605 Disposing of Viewer that doesn't have an Editor causes NPE
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d415 1
a415 1
			((IDiagramPreferenceSupport) getRoot()).getPreferencesHint()
@


1.6.2.1
log
@Bugzilla#145077 gmf_R1_0_maintenance cmahoney 060711 Workspace settings do not affect page breaks
Contributed by: Syed Atif Ali
@
text
@d415 1
a415 1
			return (IPreferenceStore)((IDiagramPreferenceSupport) getRoot()).getPreferencesHint()
@


1.6.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.6.2.3
log
@[171428] gmf_R1_maintenance aboyko 070126 Print Preview and page breaks on the diagram are different
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
a191 1
		updatePreferenceStore();
@


1.5
log
@bugzilla 112992 gmf-head sshaw 060116 Recalculated page-breaks state of a diagram is not persisted
@
text
@d383 4
a386 2
		s.setValue(WorkspaceViewerProperties.PAGEBREAK_X, r.x);
		s.setValue(WorkspaceViewerProperties.PAGEBREAK_Y, r.y);
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051108 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d64 1
a64 1
			calculatePageBreakFigureBounds();
d71 7
a77 5
			Point printerPageSize = getPageSize();
			float numCols = ((float) width) / printerPageSize.x;
			int cols = Math.max(1, (int) Math.ceil(numCols));
			float numRows = ((float) height) / printerPageSize.y;
			int rows = Math.max(1, (int) Math.ceil(numRows));
d79 9
a87 2
			int xInc = printerPageSize.x * cols;
			int yInc = printerPageSize.y * rows;
d89 38
a126 5
			getPageBreaksFigure().setSize(new Dimension(xInc, yInc));
			getPageBreaksFigure().setLocation(location);
			getPageBreaksFigure().setPageCount(rows, cols);			
					
			
a127 2
		//diagramBounds = bounds;
		//calculatePageBreakFigureSize();	
d129 1
a129 1

a153 36

	/**
	 * Calculates the size of the page breaks figure and the
	 * number of rows and columns based on the print page size.
	 * This method updates the page breaks figure bounds directly.
	 * 
	 * @@param center true to center the page breaks figure,
	 * false to not center it.
	 */
	public void calculatePageBreakFigureBounds(boolean center) {
		Point printerPageSize = getPageSize();
		float numCols = ((float) diagramBounds.width) / printerPageSize.x;
		int cols = Math.max(1, (int) Math.ceil(numCols));
		float numRows = ((float) diagramBounds.height) / printerPageSize.y;
		int rows = Math.max(1, (int) Math.ceil(numRows));

		int xInc = printerPageSize.x * cols;
		int yInc = printerPageSize.y * rows;

		getPageBreaksFigure().setSize(new Dimension(xInc, yInc));
		getPageBreaksFigure().setPageCount(rows, cols);
		if (center) {
			centerPageBreaksFigure();
			//setSize won't affect x and y, just width and height
			updatePreferenceStore();
		}
	}
	
	/**
	 * Calculates the size of the page breaks figure and the
	 * number of rows and columns based on the print page size.
	 * This method will also center the page breaks figure.
	 */
	public void calculatePageBreakFigureBounds() {
		calculatePageBreakFigureBounds(true);
	}	
a369 1
//		this.pageBreakBounds = getPageBreaksFigure().getBounds();
d376 1
a376 1
	private void updatePreferenceStore() {
d378 1
a378 1

@


1.3
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d22 1
d25 1
d33 1
d158 7
a164 1
		return PageInfoHelper.getPageSize(s, MapModeUtil.getMapMode(getPageBreaksFigure()));
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a22 2
import org.eclipse.jface.preference.IPreferenceStore;

d31 2
d155 1
a155 1
		return PageInfoHelper.getPageSize(s);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

