head	1.13;
access;
symbols
	v20081023-2107:1.13
	v20081022-1925:1.13
	v20081022-1005:1.13
	v20081020-0700:1.13
	v20080917-1925:1.13
	v20080916-2008:1.13
	v20080911-1728:1.13
	v20080911-1506:1.13
	v20080910-1520:1.13
	v20080910-1510:1.13
	v20080903-1520:1.13
	v20080903-1510:1.13
	v20080813-1510:1.13
	v20080811-1546:1.13
	v20080731-1520:1.13
	v20080725-1738:1.13
	v20080723-2246:1.13
	v20080723-2232:1.13
	v20080723-1700:1.13
	v20080722-1827:1.13
	v20080718-1700:1.13
	v20080718-1731:1.13
	v20080716-1600:1.13
	v20080716-1642:1.13
	R2_1_maintenance:1.13.0.2
	Root_R2_1_maintenance:1.13
	R2_1_0:1.13
	v20080610-1132:1.13
	v20080603-1553:1.13
	v20080527-1255:1.13
	v20080527-1151:1.10
	v20080516-1748:1.13
	v20080516-1143:1.13
	v20080512-1200:1.13
	v20080503-1740:1.13
	v20080501-2127:1.10
	v20080501-1739:1.13
	m20080429-1543:1.10
	v20080425-1959:1.13
	v20080417-1610:1.13
	v20080407-2250:1.13
	v20080407-0930:1.13
	v20080404-1111:1.13
	v20080328-1605:1.13
	v20080322-0000:1.13
	v20080222-1200:1.13
	v20080201-2010:1.13
	v20080201-0201:1.10
	v20080118-1129:1.10
	v20080114-2222:1.10
	v20080114-1111:1.13
	v20080107-1111:1.12
	v20071222-1111:1.12
	v20071214-1111:1.11
	v20071130-1111:1.11
	v20071124-0000:1.10
	v20071112-0000:1.11
	v20071108-0000:1.11
	v20071003-0000:1.10
	v20070915-0000:1.10
	v20070903-0000:1.10
	v20070809-0000:1.10
	R2_0_maintenance:1.10.0.4
	R2_0:1.10
	R4_20:1.10
	v20070621-0000:1.10
	RC3_20:1.10
	v20070614-1400:1.10
	v20070608-1300:1.10
	v20070605-1400:1.10
	v20070601-1400:1.10
	v20070525-1500:1.10
	v20070518-1300:1.10
	bugzilla111892_group_support:1.10.0.2
	Root_bugzilla111892_group_support:1.10
	v20070504-1000:1.10
	v20070420-1000:1.10
	v20070413-1300:1.10
	v20070330-1300:1.10
	v20060330-1300:1.10
	v20070322-1100:1.9
	v20060316-0600:1.9
	v20070221-1500:1.9
	v20070208-1800:1.9
	v20070202-0200:1.9
	v20070119-1200:1.9
	v20070111-0800:1.9
	v20070105-1200:1.9
	v20070103-0300:1.9
	M4_20:1.9
	v20061218-1500:1.9
	v20061218-1200:1.9
	v20061214-0000:1.9
	M3_20:1.9
	v20061117-0800:1.9
	v20061027-1200:1.9
	v20061013-1330:1.9
	v20061012-1100:1.9
	v20060925-1700:1.9
	v20060919-0800:1.9
	v20060907-1100:1.9
	M1_20:1.9
	v20060831-1500:1.9
	v20060824-1600:1.9
	v20060817-1500:1.9
	v20060810-1700:1.9
	v20060803-1200:1.9
	v20060728-0500:1.9
	v20060721-1130:1.9
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060616-1400:1.9
	v20060616-1200:1.9
	v20060609-1400:1.9
	v20060531-1730:1.9
	v20060530-1930:1.9
	v20060526-1200:1.9
	v20060519-0800:1.9
	v20060512-1000:1.9
	I20060512-1000:1.9
	I20060505-1400:1.9
	I20060428-1300:1.9
	I20060424-0500:1.9
	I20060424-0300:1.9
	M6_10:1.9
	I20060407-1200:1.9
	I20060331-1000:1.9
	I20060324-0300:1.9
	I20060317-1300:1.9
	I20060317-1200:1.9
	I20060316-1300:1.9
	I20060309-1300:1.9
	M5_10:1.9
	S20060303-1600:1.9
	I20060227-1730:1.9
	I20060216-1945:1.9
	I20060210-1715:1.9
	I20060209-1815:1.9
	I20060203-0830:1.9
	I20060202-1415:1.9
	I20060129-1145:1.9
	I20060127-0900:1.9
	I20060120-1530:1.9
	I20060113-1700:1.9
	M4_10:1.9
	I20060107-1100:1.9
	I20060105-1630:1.9
	I20051230-1230:1.9
	I20051223-1100:1.9
	I20051217-0925:1.9
	I20051208-2000:1.8
	I20051201-1800:1.8
	I20051124-2000:1.8
	M3_10:1.8
	I20051118-1245:1.8
	I20051111-1800:1.7
	I20051106-0900:1.7
	v20051030:1.6;
locks; strict;
comment	@# @;


1.13
date	2008.01.08.20.59.59;	author crevells;	state Exp;
branches;
next	1.12;
commitid	5a0e4783e44f4567;

1.12
date	2007.12.20.22.47.39;	author crevells;	state Exp;
branches;
next	1.11;
commitid	3e16476af10b4567;

1.11
date	2007.10.19.19.45.32;	author ahunter;	state Exp;
branches;
next	1.10;
commitid	61b14719095b4567;

1.10
date	2007.03.26.17.34.25;	author crevells;	state Exp;
branches;
next	1.9;
commitid	4f66460804204567;

1.9
date	2005.12.12.16.49.28;	author sshaw;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.15.00.21.37;	author cmahoney;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.14.15.13.03;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.05.20.10.02;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.22.17.08.28;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.29.05;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.06.18.42.06;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.45;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.13
log
@[117917] gmf_head crevells 080108 [Palette] Palette should remember the side it was attached to
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.parts;

import org.eclipse.draw2d.PositionConstants;
import org.eclipse.gef.ContextMenuProvider;
import org.eclipse.gef.DefaultEditDomain;
import org.eclipse.gef.KeyHandler;
import org.eclipse.gef.Tool;
import org.eclipse.gef.palette.PaletteRoot;
import org.eclipse.gef.ui.palette.FlyoutPaletteComposite;
import org.eclipse.gef.ui.palette.PaletteContextMenuProvider;
import org.eclipse.gef.ui.palette.PaletteCustomizer;
import org.eclipse.gef.ui.palette.PaletteViewer;
import org.eclipse.gef.ui.palette.PaletteViewerProvider;
import org.eclipse.gef.ui.views.palette.PalettePage;
import org.eclipse.gef.ui.views.palette.PaletteViewerPage;
import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin;
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.ImageFileDropTargetListener;
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.PaletteToolTransferDragSourceListener;
import org.eclipse.gmf.runtime.diagram.ui.internal.parts.PaletteToolTransferDropTargetListener;
import org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteService;
import org.eclipse.gmf.runtime.diagram.ui.tools.ConnectionCreationTool;
import org.eclipse.gmf.runtime.diagram.ui.tools.CreationTool;
import org.eclipse.gmf.runtime.gef.ui.palette.customize.PaletteCustomizerEx;
import org.eclipse.gmf.runtime.gef.ui.palette.customize.PaletteViewerEx;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.util.TransferDropTargetListener;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.KeyEvent;
import org.eclipse.swt.events.MouseEvent;
import org.eclipse.swt.events.MouseListener;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.activities.ActivityManagerEvent;
import org.eclipse.ui.activities.IActivityManagerListener;

/**
 * A generic diagram editor with a palette.  This supports the palette moved from
 * the diagram to a palette view.  If the palette view is open than the
 * palette in the diagram will be removed.
 * @@author choang, cmahoney
 */
public abstract class DiagramEditorWithFlyOutPalette
	extends DiagramEditor
{
	/**
	 * Listens for activity/capability events.
	 * 
	 * @@author cmahoney
	 */
	class ActivityManagerListener
		implements IActivityManagerListener {

		public void activityManagerChanged(
				ActivityManagerEvent activityManagerEvent) {
			if (activityManagerEvent.haveEnabledActivityIdsChanged()) {
				if (getEditDomain() != null
					&& getEditDomain().getPaletteViewer() != null
					&& getEditDomain().getPaletteViewer().getPaletteRoot() != null) {

					createPaletteRoot(getEditDomain().getPaletteViewer()
						.getPaletteRoot());
				}
			}
		}
	}
	
	/**
	 * The activity listener.
	 */
	private IActivityManagerListener activityManagerListener;

	boolean fHasFlyoutPalette = true;
	public DiagramEditorWithFlyOutPalette() {
		// empty
	}
	
	public DiagramEditorWithFlyOutPalette(boolean hasFlyout) {
		fHasFlyoutPalette = hasFlyout;
	}

	/**
	 * uncollapsed pinned palette state constant
	 */
	protected static final int UNCOLLAPSED_PINNED = 4;
	/**
	 * collapsed pinned palette state constant
	 */
	protected static final int COLLAPSED = 2;

	// Provider that creates palette viewer

	private PaletteViewerProvider provider;
	// Splitter the supports the moving of the palette in and out of the diagram
	// from a palette view.
	private FlyoutPaletteComposite splitter;
	// Page that supports the slurping in and out of the palette from the diagram to
	// and from a palette view.  The palette view is like any other view it can be moved
	// around.  Similiar in docking functionality as the outline view.
	private CustomPalettePage page;

	protected void initializeGraphicalViewer() {
		if(fHasFlyoutPalette) {
			splitter.hookDropTargetListener(getGraphicalViewer());
			
			super.initializeGraphicalViewer();

			/* Add a drop target listener for ME drop events */
			getDiagramGraphicalViewer().addDropTargetListener(
				(TransferDropTargetListener) new ImageFileDropTargetListener(
					getDiagramGraphicalViewer()));

			// Add a transfer drag target listener that is supported on
			// palette template entries whose template is a creation tool.
			// This will enable drag and drop of the palette shape creation
			// tools.
			getDiagramGraphicalViewer()
				.addDropTargetListener(
					new PaletteToolTransferDropTargetListener(
						getGraphicalViewer()));

		} else {
			super.initializeGraphicalViewer();
		}
	}
	
	protected boolean toolSupportsAccessibility(Tool t) {
		return (t instanceof CreationTool) || 
				(t instanceof ConnectionCreationTool);
	}
	
	protected PaletteViewer constructPaletteViewer() {
		return new PaletteViewerEx();
	}

	/**
	 * Creates a PaletteViewerProvider.
	 * @@return PaletteViewerProvider that provides for the palette viewer for the diagram
	 */
	protected PaletteViewerProvider createPaletteViewerProvider() {
		assert fHasFlyoutPalette == true;
		getEditDomain().setPaletteRoot(createPaletteRoot(null));
		return new PaletteViewerProvider(getEditDomain()){

			public PaletteViewer createPaletteViewer(Composite parent) {
				PaletteViewer pViewer = constructPaletteViewer();
				pViewer.createControl(parent);
				configurePaletteViewer(pViewer);
				hookPaletteViewer(pViewer);
				return pViewer;
			}
			
			/**
			 * Override to provide the additional behavior for the tools.
			 * Will intialize with a PaletteEditPartFactory that has a TrackDragger that
			 * understand how to handle the mouseDoubleClick event for shape creation tools.
			 * Also will initialize the palette with a defaultTool that is the SelectToolEx that undestands
			 * how to handle the enter key which will result in the creation of the shape also.
			 */
			protected void configurePaletteViewer(PaletteViewer viewer) {
				super.configurePaletteViewer(viewer);

				viewer.getKeyHandler().setParent(getPaletteKeyHandler());
				viewer.getControl().addMouseListener(getPaletteMouseListener());

				// Add a transfer drag target listener that is supported on
				// palette template entries whose template is a creation tool.
				// This will enable drag and drop of the palette shape creation
				// tools.
				viewer
					.addDragSourceListener(new PaletteToolTransferDragSourceListener(
						viewer));
                viewer.setCustomizer(createPaletteCustomizer());
			}


			/**
			 * @@return Palette Key Handler for the palette
			 */
			private KeyHandler getPaletteKeyHandler() {

				if (paletteKeyHandler == null) {

					paletteKeyHandler = new KeyHandler() {

						/**
						 * Processes a <i>key released </i> event. This method
						 * is called by the Tool whenever a key is released, and
						 * the Tool is in the proper state. Override to support
						 * pressing the enter key to create a shape or connection
						 * (between two selected shapes)
						 *
						 * @@param event
						 *            the KeyEvent
						 * @@return <code>true</code> if KeyEvent was handled
						 *         in some way
						 */
						public boolean keyReleased(KeyEvent event) {

							if (event.keyCode == SWT.Selection) {

								Tool tool =
									getPaletteViewer()
										.getActiveTool()
										.createTool();

								if (toolSupportsAccessibility(tool)) {

									tool.keyUp(event, getDiagramGraphicalViewer());

									// 	deactivate current selection
									getPaletteViewer().setActiveTool(null);

									return true;
								}

							}
							return super.keyReleased(event);
						}

					};

				}
				return paletteKeyHandler;
			}

			/**
			 * @@return Palette Mouse listener for the palette
			 */
			private MouseListener getPaletteMouseListener() {

				if (paletteMouseListener == null) {

					paletteMouseListener = new MouseListener() {

						/**
						 * Flag to indicate that the current active tool should
						 * be cleared after a mouse double-click event.
						 */
						private boolean clearActiveTool = false;

						/**
						 * Override to support double-clicking a palette tool
						 * entry to create a shape or connection (between two
						 * selected shapes).
						 *
						 * @@see org.eclipse.swt.events.MouseListener#mouseDoubleClick(org.eclipse.swt.events.MouseEvent)
						 */
						public void mouseDoubleClick(MouseEvent e) {
							Tool tool = getPaletteViewer().getActiveTool()
								.createTool();

							if (toolSupportsAccessibility(tool)) {

								tool.setViewer(getDiagramGraphicalViewer());
								tool.setEditDomain(getDiagramGraphicalViewer()
									.getEditDomain());
								tool.mouseDoubleClick(e,
									getDiagramGraphicalViewer());

								// Current active tool should be deactivated,
								// but if it is down here it will get
								// reactivated deep in GEF palette code after
								// receiving mouse up events.
								clearActiveTool = true;
							}
						}

						public void mouseDown(MouseEvent e) {
							// do nothing
						}

						public void mouseUp(MouseEvent e) {
							// 	Deactivate current active tool here if a
							// double-click was handled.
							if (clearActiveTool) {
								getPaletteViewer().setActiveTool(null);
								clearActiveTool = false;
							}

						}
					};

				}
				return paletteMouseListener;
			}

		};
	}

	/** Key Handler for the palette */
	KeyHandler paletteKeyHandler = null;

	/** Mouse listener for the palette */
	MouseListener paletteMouseListener = null;

	/**
	 * @@see org.eclipse.ui.IWorkbenchPart#setFocus()
	 */
	public void setFocus() {
		if (getGraphicalControl()!=null)
			getGraphicalControl().setFocus();
	}


	/**
	 * Creates a splitter composite that will contain
	 * 2 parts one is for the diagram and the other is for the palette.
	 * @@see org.eclipse.ui.IWorkbenchPart#createPartControl(Composite)
	 */
	public void createPartControl(Composite parent) {

		if(fHasFlyoutPalette) {
			FlyoutPaletteComposite.FlyoutPreferences flyoutPrefs = new FlyoutPreferencesImpl(
                getPreferenceStore());

			splitter = new FlyoutPaletteComposite(parent, SWT.NONE, getSite().getPage(), getPaletteViewerProvider(), flyoutPrefs);
			super.createPartControl(splitter);
			splitter.setGraphicalControl(getGraphicalControl());
			if (page != null) {
				splitter.setExternalViewer(getPaletteViewer());
				page = null;
			}

			// CWD: FlyoutPaletteComposite no longer implements the Java Beans
			//      property change API, nor does it even have a 'default state'
			//      property in the IES M9 drop
			//TODO(M9):  Review whether this listener is needed
//			splitter.addPropertyChangeListener(new PropertyChangeListener() {
//			public void propertyChange(PropertyChangeEvent evt) {
//				if (evt.getPropertyName().equals(FlyoutPaletteCompositeEx.PROPERTY_DEFAULT_STATE))
//					handlePaletteDefaultStateChanged(((Integer)evt.getNewValue()).intValue());
//				else
//					handlePaletteResized(((Integer)evt.getNewValue()).intValue());
//				}
//			});
		} else {
			super.createPartControl(parent);
		}

	}
	
	/**
     * Returns a preference store where GMF global workspace preferences can be
     * saved. For example, the palette customizations are saved in this
     * preference store. These settings are workspace-wide and not specific to
     * any particular diagram.  Override to customize.
     * 
     * @@return the preference store
     * @@since 2.1
     */
    protected IPreferenceStore getPreferenceStore() {
        return DiagramUIPlugin.getInstance().getPreferenceStore();
    }
	
	/**
	 * Adapts to
	 * <LI> PalettePage.class
	 * <LI> PaletteViewer.class
	 * other wise delegates to super.getAdapter()
	 */
	public Object getAdapter(Class type) {

		if(fHasFlyoutPalette) {
			if (type == PalettePage.class) {
				if (splitter == null) {
					page = new CustomPalettePage(getPaletteViewerProvider());
					return page;
				}
				return new CustomPalettePage(getPaletteViewerProvider());
			}
			// Please do not remove PaletteViewer adapter
			// QE automation depends on it
			if (type == PaletteViewer.class){
	
				return getPaletteViewer();
			}
		}
		return super.getAdapter(type);
	}

	/**
	 * Creates the palette root for the palette viewer or updates the existing
	 * palette root passed in if entries should be added/removed based on the
	 * current state.
	 * 
	 * @@param existingPaletteRoot
	 *            the existing palette root if the palette has already been
	 *            created, or null if the palette root has not yet been created
	 * @@return the new palette root or the updated palette root
	 */
	protected PaletteRoot createPaletteRoot(PaletteRoot existingPaletteRoot) {
	    PaletteRoot paletteRoot;
		if (existingPaletteRoot == null) {
			paletteRoot = PaletteService.getInstance().createPalette(this,
				getDefaultPaletteContent());
		} else {
			PaletteService.getInstance().updatePalette(existingPaletteRoot,
				this, getDefaultPaletteContent());
			paletteRoot = existingPaletteRoot;
		}
        applyCustomizationsToPalette(paletteRoot);
        return paletteRoot;
	}

	/**
	 * Gets the palette content to be sent to the palette service when creating
	 * the palette.
	 * 
	 * @@return the palette content
	 */
	protected abstract Object getDefaultPaletteContent();

	/**
	 * Returns the palette view provider that is reponsible for creating and
	 * palette view.
	 * 
	 * @@return PaletteViewerProvider
	 */
	protected final PaletteViewerProvider getPaletteViewerProvider() {
		if (provider == null)
			provider = createPaletteViewerProvider();
		return provider;
	}

	/**
	 * Returns the initial palette size in pixels. Subclasses may override this method to
	 * return a persisted value.
	 * @@see #handlePaletteResized(int)
	 * @@return the initial size of the palette in pixels.
	 */
	protected int getInitialPaletteSize() {
		// '125' is the value of the FlyoutPaletteComposite.DEFAULT_PALETTE_SIZE constant
		//   which was formerly public but is now private
		return 125;
	}

	/**
	 * gets the initial palette state, it could be 
	 * UNCOLLAPSED_PINNED or COLLAPSED
	 * @@return int
	 */
	protected int getInitialPaletteState() {
		// '4' is the value of the FlyoutPaletteComposite.STATE_UNCOLLAPSED constant
		//   which is private.
		return UNCOLLAPSED_PINNED;
	}
	
    /**
     * Returns the initial docking location of the palette either
     * {@@link PositionConstants#EAST} or {@@link PositionConstants#WEST}. The
     * 
     * @@return the initial dock location either {@@link PositionConstants#EAST}
     *         or {@@link PositionConstants#WEST}
     */
    protected int getInitialDockLocation() {
        return PositionConstants.EAST;
    }

	protected void setEditDomain(DefaultEditDomain ed) {
		super.setEditDomain(ed);

	}

	/**
	 * Called to configure the viewer before it receives its contents.
	 */
	protected void configurePaletteViewer() {
		assert fHasFlyoutPalette == true;
		PaletteViewer viewer = getPaletteViewer();

		if (viewer == null) return;

		ContextMenuProvider paletteContextProvider = new PaletteContextMenuProvider(viewer);
		getPaletteViewer().setContextMenu(paletteContextProvider);
	}

	/**
	 * Helper method to returns the PaletteViewer from the
	 * page.
	 * @@return the palette viewer
	 */
	private PaletteViewer getPaletteViewer() {

		return getEditDomain().getPaletteViewer();

	}

	/**
	 * CustomPalettePage that helps with the switching of the palette
	 * from the diagram to the palette view.
	 * @@author choang
	 */
	protected class CustomPalettePage extends PaletteViewerPage {
		/**
		 * constructor
		 * @@param provider
		 */
		public CustomPalettePage(PaletteViewerProvider provider) {
			super(provider);
		}
		public void createControl(Composite parent) {
			super.createControl(parent);
			if (splitter != null)
				splitter.setExternalViewer(viewer);
		}
		public void dispose() {
			if (splitter != null)
				splitter.setExternalViewer(null);
			super.dispose();
		}
		/**
		 * gets the palette viewer
		 * @@return <code>PaletteViewer</code>
		 */
		public PaletteViewer getPaletteViewer() {
			return viewer;
		}
	}

	/**
	 * Called whenever the user resizes the palette.  Sub-classes can store the new palette
	 * size.  May want to use this to store preferences as a perferences.
	 * @@param newSize the new size in pixels
	 */
	protected void handlePaletteResized(int newSize){
		//
	}
	/**
	 * Called whenever the user updates the default palette state.  Sub-classes can store
	 * the new palette state.  May want to use this to store preferences as a perferences.
	 * @@param newState the new state
	 */
	protected void handlePaletteDefaultStateChanged(int newState){
		//
	}

	/**
     * An implementation of the fly-out palette preferences that stores the
     * flyout palette settings in the given Preferences.
     */
	private final class FlyoutPreferencesImpl
			implements FlyoutPaletteComposite.FlyoutPreferences {

        private static final String PALETTE_DOCK_LOCATION = "org.eclipse.gmf.pdock"; //$NON-NLS-1$
        private static final String PALETTE_SIZE = "org.eclipse.gmf.psize"; //$NON-NLS-1$
        private static final String PALETTE_STATE = "org.eclipse.gmf.pstate"; //$NON-NLS-1$

        private IPreferenceStore preferences;

        private FlyoutPreferencesImpl(IPreferenceStore preferenceStore) {
            preferences = preferenceStore;
        }
        
        public int getDockLocation() {
            if (preferences.contains(PALETTE_DOCK_LOCATION)) {
                return preferences.getInt(PALETTE_DOCK_LOCATION);
            } else {
                return getInitialDockLocation();
            }
        }

        public int getPaletteState() {
            if (preferences.contains(PALETTE_STATE)) {
                return preferences.getInt(PALETTE_STATE);
            } else {
                return getInitialPaletteState();
            }
        }

        public int getPaletteWidth() {
            if (preferences.contains(PALETTE_SIZE)) {
                return preferences.getInt(PALETTE_SIZE);
            } else {
                return getInitialPaletteSize();
            }
        }
        
        public void setDockLocation(int location) {
            preferences.setValue(PALETTE_DOCK_LOCATION, location);
        }
        
        public void setPaletteState(int state) {
            preferences.setValue(PALETTE_STATE, state);
        }
        
        public void setPaletteWidth(int width) {
            preferences.setValue(PALETTE_SIZE, width);
        }   
	}

	protected void startListening() {
		super.startListening();
		activityManagerListener = createActivityManagerListener();
		if (activityManagerListener != null) {
			PlatformUI.getWorkbench().getActivitySupport().getActivityManager()
				.addActivityManagerListener(activityManagerListener);
		}
	}

	protected void stopListening() {
		if (activityManagerListener != null) {
			PlatformUI.getWorkbench().getActivitySupport().getActivityManager()
				.removeActivityManagerListener(activityManagerListener);
			activityManagerListener = null;
		}
		super.stopListening();
	}
	
    protected IActivityManagerListener createActivityManagerListener() {
        return new ActivityManagerListener();
    }

    /**
     * Applies any current customizations to the palette root. If the palette
     * viewer is not set or it does not have its palette root set, this method
     * will do nothing.
     */
    protected void applyCustomizationsToPalette(PaletteRoot paletteRoot) {
        PaletteCustomizer customizer = (getPaletteViewer() != null) ? getPaletteViewer()
            .getCustomizer()
            : createPaletteCustomizer();
        if (customizer instanceof PaletteCustomizerEx) {
            ((PaletteCustomizerEx) customizer)
                .applyCustomizationsToPalette(paletteRoot);
        }
    }

    /**
     * Creation factory method for the palette customizer.
     * @@return a new palette customizer
     */
    protected PaletteCustomizer createPaletteCustomizer() {
        return new PaletteCustomizerEx(getPreferenceStore());
    }

}
@


1.12
log
@[114117] gmf_head crevells 071220 [Palette] Expose the customize palette capability from GEF
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d27 1
d36 1
d324 2
a325 3
			FlyoutPaletteComposite.FlyoutPreferences flyoutPrefs = new FlyoutPreferencesImpl();
			flyoutPrefs.setPaletteState(getInitialPaletteState());
			flyoutPrefs.setPaletteWidth(getInitialPaletteSize());
d352 14
a365 1

d458 11
d549 4
a552 3
	 * An implementation of the fly-out palette preferences.
	 */
	private static final class FlyoutPreferencesImpl
d555 3
a557 2
		// 'EAST' is the default dock location
		private int dockLocation = PositionConstants.EAST;
d559 1
a559 3
		// '4' is the value of the FlyoutPaletteComposite.STATE_UNCOLLAPSED constant
		//   which is private.
		private int paletteState = UNCOLLAPSED_PINNED;
d561 11
a571 3
		// '125' is the value of the FlyoutPaletteComposite.DEFAULT_PALETTE_SIZE constant
		//   which was formerly public but is now private
		private int paletteWidth = 125;
d573 7
a579 6
		/* (non-Javadoc)
		 * @@see org.eclipse.gef.ui.palette.FlyoutPaletteComposite.FlyoutPreferences#getDockLocation()
		 */
		public int getDockLocation() {
			return dockLocation;
		}
d581 19
a599 34
		/* (non-Javadoc)
		 * @@see org.eclipse.gef.ui.palette.FlyoutPaletteComposite.FlyoutPreferences#getPaletteState()
		 */
		public int getPaletteState() {
			return paletteState;
		}

		/* (non-Javadoc)
		 * @@see org.eclipse.gef.ui.palette.FlyoutPaletteComposite.FlyoutPreferences#getPaletteWidth()
		 */
		public int getPaletteWidth() {
			return paletteWidth;
		}

		/* (non-Javadoc)
		 * @@see org.eclipse.gef.ui.palette.FlyoutPaletteComposite.FlyoutPreferences#setDockLocation(int)
		 */
		public void setDockLocation(int location) {
			dockLocation = location;
		}

		/* (non-Javadoc)
		 * @@see org.eclipse.gef.ui.palette.FlyoutPaletteComposite.FlyoutPreferences#setPaletteState(int)
		 */
		public void setPaletteState(int state) {
			paletteState = state;
		}

		/* (non-Javadoc)
		 * @@see org.eclipse.gef.ui.palette.FlyoutPaletteComposite.FlyoutPreferences#setPaletteWidth(int)
		 */
		public void setPaletteWidth(int width) {
			paletteWidth = width;
		}
d644 1
a644 1
        return new PaletteCustomizerEx();
@


1.11
log
@[206821] gmf-head ahunter 071019 Cannot extend the GMF Palette
@
text
@d33 2
d141 1
a141 1
		return new PaletteViewer();
d181 1
a181 1

d389 1
d391 1
a391 1
			return PaletteService.getInstance().createPalette(this,
d396 1
a396 1
			return existingPaletteRoot;
d398 2
a460 9
		viewer.setCustomizer(new PaletteCustomizer() {
			public void revertToSaved() {
			    //
			}

			public void save() {
			    //
			}
		});
d604 24
a627 1
	
@


1.10
log
@[178925] gmf_head crevells 070326 Provide overrideable method in DiagramEditorWithFlyOutPalette to create custom IActivityManagerListener
Contributed by: Christian Vogt
@
text
@d132 9
d151 8
d213 1
a213 2
								if (tool instanceof CreationTool
									|| tool instanceof ConnectionCreationTool) {
d259 1
a259 2
							if (tool instanceof CreationTool
								|| tool instanceof ConnectionCreationTool) {
@


1.9
log
@bugzilla 110316 gmf-head 051212 Compiler warning count should be 0 - runtime diagram layer
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d77 1
a77 1
	private ActivityManagerListener activityManagerListener;
d574 5
a578 3
		activityManagerListener = new ActivityManagerListener();
		PlatformUI.getWorkbench().getActivitySupport().getActivityManager()
			.addActivityManagerListener(activityManagerListener);
d585 1
a586 1
		activityManagerListener = null;
d590 4
@


1.8
log
@Bugzilla#113580 gmf_head cmahoney 051114 Can not add elements to diagram doing drag and drop from palette
@
text
@a18 1
import org.eclipse.gef.dnd.TemplateTransferDragSourceListener;
@


1.7
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d19 1
d29 2
d119 10
a128 1
						
d156 8
@


1.6
log
@Bugzilla 110765 gmf_head sshaw 051013 Allow to customize palette model creation
Contributed by: Cherie Mahoney
@
text
@d29 1
a29 1
import org.eclipse.gmf.runtime.diagram.ui.tools.ConnectorCreationTool;
d160 1
a160 1
						 * pressing the enter key to create a shape or connector
d178 1
a178 1
									|| tool instanceof ConnectorCreationTool) {
d215 1
a215 1
						 * entry to create a shape or connector (between two
d225 1
a225 1
								|| tool instanceof ConnectorCreationTool) {
@


1.5
log
@bugzilla 111610 gmf_head sshaw 051005 Palette not updated when diagram is opened which prompts to enable capability
Committed by: Cherie Mahoney
@
text
@d61 7
a67 1
				updatePaletteRoot();
d128 1
a128 1
		getEditDomain().setPaletteRoot(createPaletteRoot());
d343 3
a345 1
	 * Creates the palette root for the palette viewer.
d347 8
a354 17
	 * @@return the new palette root
	 */
	private PaletteRoot createPaletteRoot() {
		return PaletteService.getInstance().createPalette(this,
			getDefaultPaletteContent());
	}

	/**
	 * Updates the palette root by adding/removing entries as necessary.
	 */
	private void updatePaletteRoot() {
		if (getEditDomain() != null
			&& getEditDomain().getPaletteViewer() != null
			&& getEditDomain().getPaletteViewer().getPaletteRoot() != null) {
			
			PaletteService.getInstance().updatePalette(
				getEditDomain().getPaletteViewer().getPaletteRoot(), this,
d356 4
@


1.4
log
@Bugzilla 109904 gmf_head sshaw 050922 Capability support for Contribution Item Service
Contribution by: Cherie Mahoney
@
text
@d110 1
a110 5
			
			activityManagerListener = new ActivityManagerListener();
			PlatformUI.getWorkbench().getActivitySupport().getActivityManager()
				.addActivityManagerListener(activityManagerListener);
			
d350 8
a357 3
		PaletteService.getInstance().updatePalette(
			getEditDomain().getPaletteViewer().getPaletteRoot(), this,
			getDefaultPaletteContent());
d550 7
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d45 1
a45 1
 * @@author choang
d48 1
a48 1
	extends DiagramEditor implements IActivityManagerListener
d50 20
d111 1
d113 1
a113 1
			.addActivityManagerListener(this);
d549 4
a552 8
	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.ui.activities.IActivityManagerListener#activityManagerChanged(org.eclipse.ui.activities.ActivityManagerEvent)
	 */
	public void activityManagerChanged(ActivityManagerEvent activityManagerEvent) {
		if (activityManagerEvent.haveEnabledActivityIdsChanged()) {
			updatePaletteRoot();
d554 2
@


1.2
log
@Bugzilla 108849 gmf_head sshaw 050906 Capability support for Modeling Assistant and Palette Services
Contribution by: Cherie Mahoney
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d25 4
d35 3
a37 4

import org.eclipse.gmf.runtime.diagram.ui.internal.parts.ImageFileDropTargetListener;
import org.eclipse.gmf.runtime.diagram.ui.tools.ConnectorCreationTool;
import org.eclipse.gmf.runtime.diagram.ui.tools.CreationTool;
d46 1
a46 1
	extends DiagramEditor
d51 1
d88 4
d103 1
a103 1
		getEditDomain().setPaletteRoot(getPaletteRoot());
d318 3
a320 2
	 * Returns the PaletteRoot for the palette viewer.
	 * @@return the palette root
d322 4
a325 1
	protected abstract PaletteRoot getPaletteRoot();
d328 20
a347 2
	 * Returns the palette view provider that is reponsible for
	 * creating and palette view.
d525 12
@

