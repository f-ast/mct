head	1.16;
access;
symbols
	v20081023-2107:1.16
	v20081022-1925:1.16
	v20081022-1005:1.16
	v20081020-0700:1.16
	v20080917-1925:1.16
	v20080916-2008:1.16
	v20080911-1728:1.16
	v20080911-1506:1.16
	v20080910-1520:1.16
	v20080910-1510:1.16
	v20080903-1520:1.16
	v20080903-1510:1.16
	v20080813-1510:1.16
	v20080811-1546:1.16
	v20080731-1520:1.16
	v20080725-1738:1.16
	v20080723-2246:1.16
	v20080723-2232:1.16
	v20080723-1700:1.16
	v20080722-1827:1.16
	v20080718-1700:1.16
	v20080718-1731:1.16
	v20080716-1600:1.16
	v20080716-1642:1.16
	R2_1_maintenance:1.16.0.2
	Root_R2_1_maintenance:1.16
	R2_1_0:1.16
	v20080610-1132:1.16
	v20080603-1553:1.16
	v20080527-1255:1.16
	v20080527-1151:1.15
	v20080516-1748:1.16
	v20080516-1143:1.16
	v20080512-1200:1.16
	v20080503-1740:1.16
	v20080501-2127:1.15
	v20080501-1739:1.16
	m20080429-1543:1.15
	v20080425-1959:1.16
	v20080417-1610:1.16
	v20080407-2250:1.16
	v20080407-0930:1.16
	v20080404-1111:1.16
	v20080328-1605:1.16
	v20080322-0000:1.16
	v20080222-1200:1.16
	v20080201-2010:1.16
	v20080201-0201:1.15
	v20080118-1129:1.15
	v20080114-2222:1.15
	v20080114-1111:1.16
	v20080107-1111:1.16
	v20071222-1111:1.16
	v20071214-1111:1.16
	v20071130-1111:1.16
	v20071124-0000:1.15
	v20071112-0000:1.15
	v20071108-0000:1.15
	v20071003-0000:1.15
	v20070915-0000:1.15
	v20070903-0000:1.15
	v20070809-0000:1.15
	R2_0_maintenance:1.15.0.2
	R2_0:1.15
	R4_20:1.15
	v20070621-0000:1.15
	RC3_20:1.15
	v20070614-1400:1.15
	v20070608-1300:1.15
	v20070605-1400:1.15
	v20070601-1400:1.14
	v20070525-1500:1.14
	v20070518-1300:1.14
	bugzilla111892_group_support:1.14.0.2
	Root_bugzilla111892_group_support:1.14
	v20070504-1000:1.13
	v20070420-1000:1.13
	v20070413-1300:1.13
	v20070330-1300:1.13
	v20060330-1300:1.13
	v20070322-1100:1.13
	v20060316-0600:1.13
	v20070221-1500:1.13
	v20070208-1800:1.13
	v20070202-0200:1.12.2.3
	v20070119-1200:1.12.2.3
	v20070111-0800:1.12.2.3
	v20070105-1200:1.12.2.3
	v20070103-0300:1.13
	M4_20:1.13
	v20061218-1500:1.12.2.3
	v20061218-1200:1.13
	v20061214-0000:1.13
	M3_20:1.13
	v20061117-0800:1.13
	v20061027-1200:1.12.2.3
	v20061013-1330:1.13
	v20061012-1100:1.12.2.3
	v20060925-1700:1.12.2.3
	v20060919-0800:1.12.2.3
	v20060907-1100:1.12.2.2
	M1_20:1.12
	v20060831-1500:1.12.2.2
	v20060824-1600:1.12.2.2
	v20060817-1500:1.12.2.2
	v20060810-1700:1.12.2.2
	v20060803-1200:1.12.2.2
	v20060728-0500:1.12.2.1
	v20060721-1130:1.12.2.1
	v20060713-1700:1.12.2.1
	R1_0_maintenance:1.12.0.2
	R1_0:1.12
	v20060627-1200:1.12
	v20060616-1400:1.12
	v20060616-1200:1.12
	v20060609-1400:1.11
	v20060531-1730:1.11
	v20060530-1930:1.11
	v20060526-1200:1.11
	v20060519-0800:1.11
	v20060512-1000:1.10
	I20060512-1000:1.10
	I20060505-1400:1.10
	I20060428-1300:1.10
	I20060424-0500:1.10
	I20060424-0300:1.10
	M6_10:1.10
	I20060407-1200:1.10
	I20060331-1000:1.10
	I20060324-0300:1.9
	I20060317-1300:1.9
	I20060317-1200:1.9
	I20060316-1300:1.9
	I20060309-1300:1.9
	M5_10:1.7
	S20060303-1600:1.7
	I20060227-1730:1.7
	I20060216-1945:1.7
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.6
	I20060202-1415:1.6
	I20060129-1145:1.6
	I20060127-0900:1.6
	I20060120-1530:1.6
	I20060113-1700:1.6
	M4_10:1.6
	I20060107-1100:1.6
	I20060105-1630:1.6
	I20051230-1230:1.6
	I20051223-1100:1.6
	I20051217-0925:1.6
	I20051208-2000:1.6
	I20051201-1800:1.6
	I20051124-2000:1.5
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.3;
locks; strict;
comment	@# @;


1.16
date	2007.11.21.17.57.28;	author crevells;	state Exp;
branches;
next	1.15;
commitid	4a12474471874567;

1.15
date	2007.06.05.17.07.15;	author crevells;	state Exp;
branches;
next	1.14;
commitid	1dd2466598434567;

1.14
date	2007.05.18.14.23.07;	author crevells;	state Exp;
branches;
next	1.13;
commitid	6e9e464db6ca4567;

1.13
date	2006.10.03.15.02.03;	author ahunter;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.14.18.39.49;	author ahunter;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2006.05.17.14.00.26;	author ldamus;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.15.47.23;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.08.21.20.43;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.07.02.40.43;	author ldamus;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.13.19.11.49;	author ldamus;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.25.19.38.12;	author cmahoney;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.23.15.49.23;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.02.23.30.16;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.29.06;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.22;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.37;	author sshaw;	state Exp;
branches;
next	;

1.12.2.1
date	2006.07.07.20.09.41;	author ldamus;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2006.08.02.19.31.24;	author ldamus;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2006.09.13.16.43.39;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.16
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editpolicies;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.Request;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.editpolicies.AbstractEditPolicy;
import org.eclipse.gef.requests.ReconnectRequest;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.diagram.core.commands.DeleteCommand;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ConnectionEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GroupEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.editparts.ITreeBranchEditPart;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
import org.eclipse.gmf.runtime.diagram.ui.requests.EditCommandRequestWrapper;
import org.eclipse.gmf.runtime.diagram.ui.requests.RequestConstants;
import org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand;
import org.eclipse.gmf.runtime.emf.type.core.ElementTypeRegistry;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyReferenceRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.ReorientReferenceRelationshipRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.ReorientRelationshipRequest;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.dialogs.IDialogConstants;
import org.eclipse.jface.dialogs.MessageDialogWithToggle;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.swt.widgets.Display;

/**
 * An editpolicy to handle creation and updating of semantic model elements
 * 
 * @@author melaasar
 */
public class SemanticEditPolicy
	extends AbstractEditPolicy {

	private static final String DELETE_FROM_MODEL_DLG_TITLE = DiagramUIMessages.PromptingDeleteFromModelAction_DeleteFromModelDialog_Title;

	private static final String DELETE_FROM_MODEL_DLG_MESSAGE = DiagramUIMessages.PromptingDeleteFromModelAction_DeleteFromModelDialog_Message;

	private static final String DELETE_FROM_MODEL_DLG_TOGGLE_LABEL = DiagramUIMessages.MessageDialogWithToggle_DoNotPromptAgainToggle_label; 	

	/**
	 * @@see org.eclipse.gef.EditPolicy#getCommand(Request)
	 */
	public Command getCommand(Request request) {
		if (RequestConstants.REQ_SEMANTIC_WRAPPER.equals(request.getType())) {
			return getSemanticCommand(((EditCommandRequestWrapper) request)
				.getEditCommandRequest());
		} else if (REQ_RECONNECT_SOURCE.equals(request.getType())
			&& relationshipSourceHasChanged((ReconnectRequest) request)) {
			EditPart connectionEP = ((ReconnectRequest) request)
				.getConnectionEditPart();
			if (ViewUtil.resolveSemanticElement((View) connectionEP.getModel()) == null) {
				return getReorientRefRelationshipSourceCommand((ReconnectRequest) request);
			} else {
				return getReorientRelationshipSourceCommand((ReconnectRequest) request);
			}
		} else if (REQ_RECONNECT_TARGET.equals(request.getType())
			&& relationshipTargetHasChanged((ReconnectRequest) request)) {
			EditPart connectionEP = ((ReconnectRequest) request)
				.getConnectionEditPart();
			if (ViewUtil.resolveSemanticElement((View) connectionEP.getModel()) == null) {
				return getReorientRefRelationshipTargetCommand((ReconnectRequest) request);
			} else {
				return getReorientRelationshipTargetCommand((ReconnectRequest) request);
			}
		}

		return super.getCommand(request);
	}

	/**
	 * Has the relationship target changed? If not, then it is not necessary to
	 * return a command that will change the relationship's target.
	 * 
	 * @@param request
	 *            the request to reconnect the target of a relationship
	 * @@return true if the target has changed; false otherwise
	 */
	private boolean relationshipTargetHasChanged(ReconnectRequest request) {
		return !request.getConnectionEditPart().getTarget().equals(
			request.getTarget());
	}

	/**
	 * Has the relationship source changed? If not, then it is not necessary to
	 * return a command that will change the relationship's source.
	 * 
	 * @@param request
	 *            the request to reconnect the source of a relationship
	 * @@return true if the source has changed; false otherwise
	 */
	private boolean relationshipSourceHasChanged(ReconnectRequest request) {
		return !request.getConnectionEditPart().getSource().equals(
			request.getTarget());
	}

	/**
	 * Method getSemanticCommand.
	 * 
	 * @@param request
	 * @@return Command
	 */
	protected Command getSemanticCommand(IEditCommandRequest request) {

		if ((request instanceof DestroyRequest)  && (getHost() instanceof ConnectionEditPart)
				&& !((ConnectionEditPart) getHost()).isSemanticConnection()) {
			// no semantic meaning to the connection being destroyed
			return null;
		}
		
		IEditCommandRequest completedRequest = completeRequest(request);
        
        boolean shouldPromptOnDestroy = false;
        if (completedRequest instanceof DestroyRequest && !isParentCanonical(getHost())) {
            shouldPromptOnDestroy = ((DestroyRequest) completedRequest).isConfirmationRequired();
            ((DestroyRequest) completedRequest).setConfirm(false);
        }
		
		IElementType elementType = ElementTypeRegistry.getInstance()
			.getElementType(completedRequest.getEditHelperContext());
		
		ICommand semanticCommand = (elementType != null) ? elementType
			.getEditCommand(completedRequest)
			: null;

		if (semanticCommand == null)
			return null;
		
        if (completedRequest instanceof DestroyRequest) {
            ((DestroyRequest) completedRequest).setConfirm(shouldPromptOnDestroy);
        }
		
		boolean shouldProceed = true;
		if (completedRequest instanceof DestroyRequest) {
			shouldProceed = shouldProceed((DestroyRequest) completedRequest);
		}
		if (shouldProceed) {
			Command c = new ICommandProxy(semanticCommand);
			if (completedRequest instanceof DestroyRequest) {
				TransactionalEditingDomain domain = ((IGraphicalEditPart) getHost()).getEditingDomain();
				ICommand ic = new DeleteCommand(domain, (View)getHost().getModel());
				CompositeTransactionalCommand cc = new CompositeTransactionalCommand(domain, semanticCommand
					.getLabel());
				cc.setTransactionNestingEnabled(true);
				cc.compose(semanticCommand);
				cc.compose(ic);
				c = new ICommandProxy(cc);
			}
			return c;
		}
		
		return null;
	}

	/**
	 * @@see org.eclipse.gef.EditPolicy#understandsRequest(Request)
	 */
	public boolean understandsRequest(Request request) {
		if (request instanceof EditCommandRequestWrapper)
			return true;
		
		if (REQ_RECONNECT_SOURCE.equals(request.getType())
			|| REQ_RECONNECT_TARGET.equals(request.getType())) {
			EObject parentElement = null;
			if (getHost().getParent() instanceof IGraphicalEditPart) {
				parentElement = ViewUtil
					.resolveSemanticElement((View) getHost().getParent()
						.getModel());
			}
			
			if (getHostElement() != parentElement)
				return true;
		}
		
		return false;
	}

	private EObject getHostElement() {
		return ViewUtil.resolveSemanticElement((View) getHost()
			.getModel());
	}

	/**
	 * Returns a new completed version of the <code>request</code>, mainly
	 * based on targetting the host of this edit policy.
	 * 
	 * @@param request
	 *            the request to be completed
	 * @@return the completed version of the request. This may or may not be a
	 *         new instance.
	 */
	protected IEditCommandRequest completeRequest(IEditCommandRequest request) {

		IEditCommandRequest result = request;

		if (result instanceof DestroyRequest) {
			DestroyRequest destroyRequest = (DestroyRequest) result;

			
			if (getHostElement() != null) {
				// Destroy element request

				if (destroyRequest instanceof DestroyElementRequest) {
					((DestroyElementRequest) destroyRequest)
						.setElementToDestroy(getHostElement());
					((DestroyElementRequest) destroyRequest).getParameters().clear();
				} else {
					result = new DestroyElementRequest(request
                        .getEditingDomain(), getHostElement(), destroyRequest
                        .isConfirmationRequired());
					result.addParameters(request.getParameters());
                }

				
			} else if (getHost() instanceof ConnectionEditPart) {
				// Destroy reference request

				EObject container = ViewUtil
					.resolveSemanticElement(((Edge) getHost().getModel())
						.getSource());

				EObject referenceObject = ViewUtil
					.resolveSemanticElement(((Edge) getHost().getModel())
						.getTarget());

				if (destroyRequest instanceof DestroyReferenceRequest) {
					DestroyReferenceRequest destroyReferenceRequest = (DestroyReferenceRequest) result;

					destroyReferenceRequest.setContainer(container);
					destroyReferenceRequest
						.setReferencedObject(referenceObject);

				} else {
					result = new DestroyReferenceRequest(((IGraphicalEditPart)getHost())
                        .getEditingDomain(), container, null, referenceObject,
                        destroyRequest.isConfirmationRequired());
					result.addParameters(request.getParameters());
				}
			}
		}
		return result;
	}

	/**
	 * Method getReorientRelationshipSourceCommand.
	 * 
	 * @@param request
	 * @@return Command
	 */
	protected Command getReorientRelationshipSourceCommand(
			ReconnectRequest request) {
		EObject connectionSemElement = ViewUtil.resolveSemanticElement(((View) request.getConnectionEditPart()
				.getModel()));
		EObject targetSemElement = ViewUtil.resolveSemanticElement(((View) request.getTarget().getModel()));
		EObject oldSemElement = ViewUtil.resolveSemanticElement(((View) request.getConnectionEditPart()
				.getSource().getModel())); 

        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        ReorientRelationshipRequest semRequest = new ReorientRelationshipRequest(
            editingDomain, connectionSemElement, targetSemElement,
            oldSemElement, ReorientRelationshipRequest.REORIENT_SOURCE);
        
        semRequest.addParameters(request.getExtendedData());
		
		return getSemanticCommand(semRequest);
	}

	/**
	 * Method getReorientRelationshipTargetCommand.
	 * 
	 * @@param request
	 * @@return Command
	 */
	protected Command getReorientRelationshipTargetCommand(
			ReconnectRequest request) {
		EObject connectionSemElement = ViewUtil.resolveSemanticElement((View) request.getConnectionEditPart().getModel());
		EObject targetSemElement = ViewUtil.resolveSemanticElement((View) request.getTarget().getModel());
		EObject oldSemElement = ViewUtil.resolveSemanticElement((View) request.getConnectionEditPart()
			.getTarget().getModel());

		// check if we need to redirect the semantic request because of a tree
		// gesture.
		String connectionHint = ViewUtil
			.getSemanticElementClassId((View) request.getConnectionEditPart()
				.getModel());
		if (((View) request.getTarget().getModel()).getElement() != null) {
			String targetHint = ViewUtil
				.getSemanticElementClassId((View) request.getTarget()
					.getModel());
			if (request.getConnectionEditPart() instanceof ITreeBranchEditPart
				&& request.getTarget() instanceof ITreeBranchEditPart
				&& connectionHint.equals(targetHint)) {
				ITreeBranchEditPart targetBranch = (ITreeBranchEditPart) request
					.getTarget();

				targetSemElement = ViewUtil.resolveSemanticElement((View) targetBranch.getTarget().getModel());
			}
		}

        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        ReorientRelationshipRequest semRequest = new ReorientRelationshipRequest(
            editingDomain, connectionSemElement, targetSemElement,
            oldSemElement, ReorientRelationshipRequest.REORIENT_TARGET);
        
        semRequest.addParameters(request.getExtendedData());
		
		return getSemanticCommand(semRequest);
	}

	/*
	 * Returns the getHost() if the policy understands the request.
	 * 
	 * @@see org.eclipse.gef.EditPolicy#getTargetEditPart(org.eclipse.gef.Request)
	 */
	public EditPart getTargetEditPart(Request request) {
		if (understandsRequest(request)) {
			return getHost();
		} else {
			return super.getTargetEditPart(request);
		}

	}

	/**
	 * Method getReorientRelationshipSourceCommand.
	 * 
	 * @@param request
	 * @@return Command
	 */
	protected Command getReorientRefRelationshipSourceCommand(
			ReconnectRequest request) {

		org.eclipse.gef.ConnectionEditPart connectionEP = (request).getConnectionEditPart();
		
		if (connectionEP instanceof ConnectionEditPart) {
			if (!((ConnectionEditPart) connectionEP).isSemanticConnection()) {
				return null;
			}
		}

		EditPart sourceEditPart = connectionEP.getSource();
		EditPart targetEditPart = connectionEP.getTarget();
		EObject referenceOwner = ViewUtil
			.resolveSemanticElement((View) sourceEditPart.getModel());
		EObject oldTarget = ViewUtil
			.resolveSemanticElement((View) targetEditPart.getModel());
		EObject newTarget = ViewUtil
			.resolveSemanticElement((View) request.getTarget().getModel());

        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();
        
		ReorientReferenceRelationshipRequest semRequest = new ReorientReferenceRelationshipRequest(
            editingDomain, referenceOwner, newTarget, oldTarget,
            ReorientReferenceRelationshipRequest.REORIENT_SOURCE);
		
		semRequest.addParameters(request.getExtendedData());

		return getSemanticCommand(semRequest);
	}

	/**
	 * Method getReorientRefRelationshipTargetCommand. Removes the reference the
	 * ConnectionEditPart current has an add the new TargetEditPart
	 * 
	 * @@param request
	 * @@return Command
	 */
	protected Command getReorientRefRelationshipTargetCommand(
			ReconnectRequest request) {
		
		org.eclipse.gef.ConnectionEditPart connectionEP = (request).getConnectionEditPart();
		
		if (connectionEP instanceof ConnectionEditPart) {
			if (!((ConnectionEditPart) connectionEP).isSemanticConnection()) {
				return null;
			}
		}

		EditPart sourceEditPart = connectionEP.getSource();
		EditPart targetEditPart = connectionEP.getTarget();
		EObject referenceOwner = ViewUtil
			.resolveSemanticElement((View) sourceEditPart.getModel());
		EObject oldTarget = ViewUtil
			.resolveSemanticElement((View) targetEditPart.getModel());
		EObject newTarget = ViewUtil
			.resolveSemanticElement((View) request.getTarget().getModel());

        TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost())
            .getEditingDomain();

        ReorientReferenceRelationshipRequest semRequest = new ReorientReferenceRelationshipRequest(
            editingDomain, referenceOwner, newTarget, oldTarget,
            ReorientReferenceRelationshipRequest.REORIENT_TARGET);
        
        semRequest.addParameters(request.getExtendedData());

		return getSemanticCommand(semRequest);
	}

	/**
	 * should proceed
	 * @@param destroyRequest the destroy request
	 * @@return true or false
	 */
	protected boolean shouldProceed(DestroyRequest destroyRequest) {
		if (isParentCanonical(getHost())) {
		    return true;
        }
		
		if (!(destroyRequest.isConfirmationRequired())){
			return true;
		}else{
			destroyRequest.setConfirm(false);
			return showMessageDialog();					
		}
	}

    /**
     * Checks if the parent container is canonical
     * 
     * @@param editpart the editpart in question
     * @@return true if the parent shape is canonical
     */
    private static boolean isParentCanonical(EditPart editpart) {
        EditPart parent = null;
        if ((editpart instanceof ConnectionEditPart)
            && (((ConnectionEditPart) editpart).getSource() != null)) {
            parent = ((ConnectionEditPart) editpart).getSource().getParent();
        } else {
            parent = editpart.getParent();
        }
        
        while (parent instanceof GroupEditPart) {
            parent = parent.getParent();
        }
        
        return ((parent instanceof GraphicalEditPart) && ((GraphicalEditPart) parent)
            .isCanonical());
    }


	/**
	 * launches the prompting dialogBox on deletion of elements from the model
	 * for the end user.
	 * 
	 * @@return boolean true if user pressed YES; false otherwise
	 */
	private boolean showMessageDialog() {
		MessageDialogWithToggle dialog = MessageDialogWithToggle
			.openYesNoQuestion(Display.getCurrent().getActiveShell(),
				DELETE_FROM_MODEL_DLG_TITLE, DELETE_FROM_MODEL_DLG_MESSAGE,
				DELETE_FROM_MODEL_DLG_TOGGLE_LABEL, false,
				(IPreferenceStore) ((IGraphicalEditPart) getHost())
					.getDiagramPreferencesHint().getPreferenceStore(),
				IPreferenceConstants.PREF_PROMPT_ON_DEL_FROM_MODEL);

		if (dialog.getReturnCode() == IDialogConstants.YES_ID)
			return true;
		else
			return false;
	}
}@


1.15
log
@[190909] gmf_head crevells 070605 Support delete prompting when shapes are on a canonical diagram
@
text
@d27 1
d458 5
@


1.14
log
@[187810] gmf_head crevells 070518 SemanticEditPolicy could trigger double delete confirmation prompts
@
text
@d136 1
a136 1
        if (completedRequest instanceof DestroyRequest) {
d431 3
a433 11
		EditPart parent = null;
		if ((getHost() instanceof ConnectionEditPart)&&
				(((ConnectionEditPart)getHost()).getSource() != null)){
			parent = ((ConnectionEditPart)getHost()).getSource().getParent();
		}else{
			parent = getHost().getParent();
		}
		if ((parent instanceof GraphicalEditPart)&& 
				((GraphicalEditPart) parent).isCanonical()){
			return true;
		}
d443 18
@


1.13
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d134 6
d151 3
@


1.12
log
@[139856] gmf_head anthonyh 060614 EtoolsProxyCommand should be renamed to ICommandProxy
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2004 IBM Corporation and others.
a20 1
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
d33 1
d127 6
d153 3
a155 3
				ICommand ic = new DeleteCommand(((IGraphicalEditPart) getHost()).getEditingDomain(),
					(View)getHost().getModel());
				CompositeCommand cc = new CompositeCommand(semanticCommand
d157 1
d348 10
a357 2
		EditPart sourceEditPart = request.getConnectionEditPart().getSource();
		EditPart targetEditPart = request.getConnectionEditPart().getTarget();
d386 8
d395 2
a396 2
		EditPart sourceEditPart = request.getConnectionEditPart().getSource();
		EditPart targetEditPart = request.getConnectionEditPart().getTarget();
@


1.12.2.1
log
@[147043] gmf_R1_0_maintenance ldamus 060707 SemanticEditPolicy.getSemanticCommand to use CompositeTransactionalCommand
@
text
@d21 1
a33 1
import org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand;
d147 3
a149 3
				TransactionalEditingDomain domain = ((IGraphicalEditPart) getHost()).getEditingDomain();
				ICommand ic = new DeleteCommand(domain, (View)getHost().getModel());
				CompositeTransactionalCommand cc = new CompositeTransactionalCommand(domain, semanticCommand
a150 1
				cc.setTransactionNestingEnabled(true);
@


1.12.2.2
log
@[151097] gmf_R1_0_maintenance ldamus 060802 Connections with semantic meaning can be incorrectly reoriented to shapes
@
text
@a126 6
		if ((request instanceof DestroyRequest)  && (getHost() instanceof ConnectionEditPart)
				&& !((ConnectionEditPart) getHost()).isSemanticConnection()) {
			// no semantic meaning to the connection being destroyed
			return null;
		}
		
d342 2
a343 10
		org.eclipse.gef.ConnectionEditPart connectionEP = (request).getConnectionEditPart();
		
		if (connectionEP instanceof ConnectionEditPart) {
			if (!((ConnectionEditPart) connectionEP).isSemanticConnection()) {
				return null;
			}
		}

		EditPart sourceEditPart = connectionEP.getSource();
		EditPart targetEditPart = connectionEP.getTarget();
a371 8
		
		org.eclipse.gef.ConnectionEditPart connectionEP = (request).getConnectionEditPart();
		
		if (connectionEP instanceof ConnectionEditPart) {
			if (!((ConnectionEditPart) connectionEP).isSemanticConnection()) {
				return null;
			}
		}
d373 2
a374 2
		EditPart sourceEditPart = connectionEP.getSource();
		EditPart targetEditPart = connectionEP.getTarget();
@


1.12.2.3
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.11
log
@[137749] gmf_head ldamus 060517 Transfer GEF Request's extended data into IEditCommandRequest's parameters
@
text
@d25 1
a25 1
import org.eclipse.gmf.runtime.diagram.ui.commands.EtoolsProxyCommand;
d145 1
a145 1
			Command c = new EtoolsProxyCommand(semanticCommand);
d153 1
a153 1
				c = new EtoolsProxyCommand(cc);
@


1.10
log
@bugzilla 133436 gmf-head sshaw 060328 Remove deprecated reference to MObjectType and MEditingDomain
@
text
@d217 1
d243 1
d269 2
d312 2
d356 2
d387 2
@


1.9
log
@Bugzilla#130985 gmf_head cmahoney 060308 SemanticEditPolicy assumes it can get editingdomain from DestroyElementRequest
@
text
@a33 2
import org.eclipse.gmf.runtime.emf.core.edit.MObjectType;
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
d404 2
a405 9
			boolean modellingObject = false; 	
			if (getHostElement() != null)
				if (EObjectUtil.getType(getHostElement()) == MObjectType.MODELING)
					modellingObject = true;	
			
			if (modellingObject){
				destroyRequest.setConfirm(false);
				return showMessageDialog();					
			}
a406 1
		return true;
@


1.8
log
@[129773] gmf_head cdamus 060306 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@d149 1
a149 1
				ICommand ic = new DeleteCommand(request.getEditingDomain(),
d241 1
a241 1
					result = new DestroyReferenceRequest(request
@


1.7
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d214 1
a214 1

@


1.6
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d15 1
d149 1
a149 1
				ICommand ic = new DeleteCommand(
d216 4
a219 3
					result = new DestroyElementRequest(getHostElement(),
						destroyRequest.isConfirmationRequired());
				}
d241 3
a243 3
					result = new DestroyReferenceRequest(container, null,
						referenceObject, destroyRequest
							.isConfirmationRequired());
d264 5
a268 3
		ReorientRelationshipRequest semRequest = new ReorientRelationshipRequest(
			connectionSemElement, targetSemElement, oldSemElement,
			ReorientRelationshipRequest.REORIENT_SOURCE);
d305 5
a309 3
		ReorientRelationshipRequest semRequest = new ReorientRelationshipRequest(
			connectionSemElement, targetSemElement, oldSemElement,
			ReorientRelationshipRequest.REORIENT_TARGET);
d346 3
d350 2
a351 2
			referenceOwner, newTarget, oldTarget,
			ReorientReferenceRelationshipRequest.REORIENT_SOURCE);
d375 6
a380 3
		ReorientReferenceRelationshipRequest semRequest = new ReorientReferenceRelationshipRequest(
			referenceOwner, newTarget, oldTarget,
			ReorientReferenceRelationshipRequest.REORIENT_TARGET);
@


1.5
log
@bugzilla 114746 gmf-head sshaw 051122 heck that GEF command can't be executed by calling it's canExecute() method
@
text
@d29 1
a29 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d58 5
a62 6
	private static final String DELETE_FROM_MODEL_DLG_TITLE = DiagramResourceManager
	.getI18NString("PromptingDeleteFromModelAction.DeleteFromModelDialog.Title"); //$NON-NLS-1$ 
	private static final String DELETE_FROM_MODEL_DLG_MESSAGE = DiagramResourceManager
	.getI18NString("PromptingDeleteFromModelAction.DeleteFromModelDialog.Message"); //$NON-NLS-1$ 	
	private static final String DELETE_FROM_MODEL_DLG_TOGGLE_LABEL =DiagramResourceManager
	.getI18NString("MessageDialogWithToggle.DoNotPromptAgainToggle.label"); //$NON-NLS-1$ 	
d140 1
@


1.4
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@a17 1
import org.eclipse.gef.commands.UnexecutableCommand;
a19 5
import org.eclipse.jface.dialogs.IDialogConstants;
import org.eclipse.jface.dialogs.MessageDialogWithToggle;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.swt.widgets.Display;

d23 1
a32 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
d45 4
d139 1
a139 2
			return UnexecutableCommand.INSTANCE;
		
a157 1
		return UnexecutableCommand.INSTANCE;
d159 1
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a28 1
import org.eclipse.gmf.runtime.diagram.ui.IPreferenceConstants;
d34 2
a35 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d60 1
a60 1
	private static final String DELETE_FROM_MODEL_DLG_TITLE = PresentationResourceManager
d62 1
a62 1
	private static final String DELETE_FROM_MODEL_DLG_MESSAGE = PresentationResourceManager
d64 1
a64 1
	private static final String DELETE_FROM_MODEL_DLG_TOGGLE_LABEL =PresentationResourceManager
d287 1
a287 1
		String connectorHint = ViewUtil
d296 1
a296 1
				&& connectorHint.equals(targetHint)) {
d352 1
a352 1
	 * ConnectorEditPart current has an add the new TargetEditPart
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d47 2
a48 2
import com.ibm.xtools.notation.Edge;
import com.ibm.xtools.notation.View;
@

