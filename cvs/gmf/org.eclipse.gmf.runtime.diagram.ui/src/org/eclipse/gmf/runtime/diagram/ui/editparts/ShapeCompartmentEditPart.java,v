head	1.23;
access;
symbols
	v20081023-2107:1.23
	v20081022-1925:1.23
	v20081022-1005:1.23
	v20081020-0700:1.23
	v20080917-1925:1.23
	v20080916-2008:1.23
	v20080911-1728:1.23
	v20080911-1506:1.23
	v20080910-1520:1.23
	v20080910-1510:1.23
	v20080903-1520:1.23
	v20080903-1510:1.23
	v20080813-1510:1.23
	v20080811-1546:1.23
	v20080731-1520:1.23
	v20080725-1738:1.23
	v20080723-2246:1.23
	v20080723-2232:1.23
	v20080723-1700:1.23
	v20080722-1827:1.23
	v20080718-1700:1.23
	v20080718-1731:1.23
	v20080716-1600:1.23
	v20080716-1642:1.23
	R2_1_maintenance:1.23.0.2
	Root_R2_1_maintenance:1.23
	R2_1_0:1.23
	v20080610-1132:1.23
	v20080603-1553:1.23
	v20080527-1255:1.23
	v20080527-1151:1.19.2.2
	v20080516-1748:1.23
	v20080516-1143:1.23
	v20080512-1200:1.23
	v20080503-1740:1.22
	v20080501-2127:1.19.2.2
	v20080501-1739:1.22
	m20080429-1543:1.19.2.2
	v20080425-1959:1.22
	v20080417-1610:1.22
	v20080407-2250:1.22
	v20080407-0930:1.22
	v20080404-1111:1.22
	v20080328-1605:1.22
	v20080322-0000:1.22
	v20080222-1200:1.22
	v20080201-2010:1.22
	v20080201-0201:1.19.2.2
	v20080118-1129:1.19.2.2
	v20080114-2222:1.19.2.2
	v20080114-1111:1.22
	v20080107-1111:1.19
	v20071222-1111:1.19
	v20071214-1111:1.19
	v20071130-1111:1.19
	v20071124-0000:1.19
	v20071112-0000:1.19
	v20071108-0000:1.19
	v20071003-0000:1.19
	v20070915-0000:1.19
	v20070903-0000:1.19
	v20070809-0000:1.19
	R2_0_maintenance:1.19.0.2
	R2_0:1.19
	R4_20:1.19
	v20070621-0000:1.19
	RC3_20:1.19
	v20070614-1400:1.19
	v20070608-1300:1.18
	v20070605-1400:1.18
	v20070601-1400:1.18
	v20070525-1500:1.18
	v20070518-1300:1.18
	bugzilla111892_group_support:1.18.0.2
	Root_bugzilla111892_group_support:1.18
	v20070504-1000:1.18
	v20070420-1000:1.18
	v20070413-1300:1.18
	v20070330-1300:1.18
	v20060330-1300:1.18
	v20070322-1100:1.18
	v20060316-0600:1.18
	v20070221-1500:1.18
	v20070208-1800:1.18
	v20070202-0200:1.15.2.3
	v20070119-1200:1.15.2.3
	v20070111-0800:1.15.2.3
	v20070105-1200:1.15.2.3
	v20070103-0300:1.17
	M4_20:1.17
	v20061218-1500:1.15.2.3
	v20061218-1200:1.17
	v20061214-0000:1.17
	M3_20:1.16
	v20061117-0800:1.16
	v20061027-1200:1.15.2.2
	v20061013-1330:1.16
	v20061012-1100:1.15.2.2
	v20060925-1700:1.15.2.2
	v20060919-0800:1.15.2.2
	v20060907-1100:1.15.2.1
	M1_20:1.15
	v20060831-1500:1.15.2.1
	v20060824-1600:1.15.2.1
	v20060817-1500:1.15.2.1
	v20060810-1700:1.15.2.1
	v20060803-1200:1.15.2.1
	v20060728-0500:1.15.2.1
	v20060721-1130:1.15
	v20060713-1700:1.15
	R1_0_maintenance:1.15.0.2
	R1_0:1.15
	v20060627-1200:1.15
	v20060616-1400:1.15
	v20060616-1200:1.15
	v20060609-1400:1.15
	v20060531-1730:1.15
	v20060530-1930:1.15
	v20060526-1200:1.15
	v20060519-0800:1.15
	v20060512-1000:1.14
	I20060512-1000:1.14
	I20060505-1400:1.14
	I20060428-1300:1.14
	I20060424-0500:1.14
	I20060424-0300:1.14
	M6_10:1.14
	I20060407-1200:1.14
	I20060331-1000:1.14
	I20060324-0300:1.13
	I20060317-1300:1.13
	I20060317-1200:1.13
	I20060316-1300:1.13
	I20060309-1300:1.13
	M5_10:1.12
	S20060303-1600:1.12
	I20060227-1730:1.12
	I20060216-1945:1.12
	I20060210-1715:1.12
	I20060209-1815:1.12
	I20060203-0830:1.12
	I20060202-1415:1.12
	I20060129-1145:1.12
	I20060127-0900:1.11
	I20060120-1530:1.10
	I20060113-1700:1.10
	M4_10:1.10
	I20060107-1100:1.10
	I20060105-1630:1.10
	I20051230-1230:1.10
	I20051223-1100:1.10
	I20051217-0925:1.9
	I20051208-2000:1.9
	I20051201-1800:1.9
	I20051124-2000:1.9
	M3_10:1.9
	I20051118-1245:1.9
	I20051111-1800:1.9
	I20051106-0900:1.7
	v20051030:1.5;
locks; strict;
comment	@# @;


1.23
date	2008.05.08.18.18.30;	author aboyko;	state Exp;
branches;
next	1.22;
commitid	1d2d482343f64567;

1.22
date	2008.01.11.22.56.00;	author aboyko;	state Exp;
branches;
next	1.21;
commitid	e1c4787f3ff4567;

1.21
date	2008.01.09.20.37.08;	author aboyko;	state Exp;
branches;
next	1.20;
commitid	3eba478530734567;

1.20
date	2008.01.09.18.59.17;	author aboyko;	state Exp;
branches;
next	1.19;
commitid	3ee1478519844567;

1.19
date	2007.06.13.20.14.43;	author crevells;	state Exp;
branches
	1.19.2.1;
next	1.18;
commitid	4d9e467050334567;

1.18
date	2007.01.16.14.53.59;	author mmostafa;	state Exp;
branches;
next	1.17;
commitid	78d445ace7064567;

1.17
date	2006.12.13.19.39.52;	author mmostafa;	state Exp;
branches;
next	1.16;
commitid	1efd458056fd4567;

1.16
date	2006.10.03.15.02.04;	author ahunter;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.15.15.26.01;	author cmahoney;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2006.03.30.21.14.57;	author sshaw;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.06.16.33.20;	author sshaw;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.27.20.04.24;	author sshaw;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.20.22.07.28;	author cmahoney;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.20.21.05.04;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.09.22.12.39;	author mmostafa;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.09.18.22.43;	author mmostafa;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.04.21.27.48;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.02.23.30.15;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.22.15.42.19;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.21.29.05;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.06.20.55.01;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.49.21;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.36;	author sshaw;	state Exp;
branches;
next	;

1.15.2.1
date	2006.07.25.19.04.45;	author mmostafa;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2006.09.14.16.05.32;	author cmahoney;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2006.12.13.19.41.18;	author mmostafa;	state Exp;
branches;
next	;
commitid	6b67458057304567;

1.19.2.1
date	2008.01.09.21.13.50;	author aboyko;	state Exp;
branches;
next	1.19.2.2;
commitid	492d4785390d4567;

1.19.2.2
date	2008.01.11.23.12.55;	author aboyko;	state Exp;
branches;
next	;
commitid	19df4787f7f74567;


desc
@@


1.23
log
@[195555] gmf_head aboyko 080508 [Connections] The connection visibility is set by the compartment.
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.editparts;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.draw2d.Bendpoint;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.FigureCanvas;
import org.eclipse.draw2d.FigureListener;
import org.eclipse.draw2d.FreeformLayout;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.LayoutAnimator;
import org.eclipse.draw2d.LayoutManager;
import org.eclipse.draw2d.RangeModel;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.gef.ConnectionEditPart;
import org.eclipse.gef.DragTracker;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.EditPartListener;
import org.eclipse.gef.EditPartViewer;
import org.eclipse.gef.EditPolicy;
import org.eclipse.gef.Request;
import org.eclipse.gef.editpolicies.SnapFeedbackPolicy;
import org.eclipse.gef.requests.SelectionRequest;
import org.eclipse.gef.tools.DeselectAllTracker;
import org.eclipse.gmf.runtime.diagram.core.listener.NotificationUtil;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ContainerEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ContainerNodeEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.CreationEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.PopupBarEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ShapeCompartmentDropEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.XYLayoutEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.figures.ShapeCompartmentFigure;
import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.ISurfaceEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.DiagramLinkDragDropEditPolicy;
import org.eclipse.gmf.runtime.diagram.ui.internal.tools.RubberbandDragTracker;
import org.eclipse.gmf.runtime.diagram.ui.layout.FreeFormLayoutEx;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.swt.widgets.Display;

/**
 * A generic (sub) shape container that holds instances of
 * <code>ShapeNodeEditPart</code>s and manages the display of
 * <code>ConnectionNodeEditPart</code>s anchored to these shape editpart
 * instances.
 * 
 * @@author mhanner
 */
public abstract class ShapeCompartmentEditPart
	extends ResizableCompartmentEditPart
	implements ISurfaceEditPart, PropertyChangeListener {

	/** private connection refresh manager. */
	private ConnectionRefreshMgr _crMgr;

	private boolean _refreshQueued = false;

	private boolean isSupportingViewActions = false;
    
    // Listen to editparts being added to or removed from this compartment
    // editpart so that when a figure moves within the compartment we can call
    // refreshConnections(). See bugzilla#146581.
    private EditPartListener editpartListener = new EditPartListener.Stub() {

        private FigureListener childFigureListener = new FigureListener() {

            public void figureMoved(IFigure source) {
                refreshConnections();
            }
        };

        public void childAdded(EditPart child, int index) {
            ((GraphicalEditPart) child).getFigure().addFigureListener(
                childFigureListener);
        }

        public void removingChild(EditPart child, int index) {
            ((GraphicalEditPart) child).getFigure().removeFigureListener(
                childFigureListener);

        }

    };

	/**
	 * Class used to refresh the connections associated to the shape
	 * compartment's children. This implementation will hide all connections
	 * whose endpoints are not visible inside the shape compartment.
	 */
	public static class ConnectionRefreshMgr {
		/**
		 * Cycles through all the connections associated to the editparts
		 * contained within the passed shape compartment and sets their
		 * visibility.
		 * 
		 * @@see ConnectionNodeEditPart#getSourceConnectionAnchor()
		 * @@see ConnectionNodeEditPart#getTargetConnectionAnchor()
		 * @@param scep
		 *            edit part to consider
		 */
		protected void refreshConnections(ShapeCompartmentEditPart scep) {
			Iterator connectionNodes = getConnectionNodes(scep).iterator();
			while (connectionNodes.hasNext()) {
				ConnectionNodeEditPart cep = (ConnectionNodeEditPart) connectionNodes
					.next();
				Connection connection = (Connection) cep.getFigure();
				View connectionView = cep.getNotationView();
				if (connectionView != null && !connectionView.isVisible()) {
					/*
					 * Compartment is not responsible for refreshing a
					 * connection, the view of which is not visible
					 */
					continue;
				}
				
				IGraphicalEditPart source = (IGraphicalEditPart) getSourceEditPart(cep);
				IGraphicalEditPart target = (IGraphicalEditPart) getTargetEditPart(cep);
				
				if (!source.getFigure().isShowing() || !target.getFigure().isShowing()) {
					connection.setVisible(false);
					continue;
				}
				
				ShapeCompartmentEditPart sContainer = getOwningShapeCompartment(source);
				ShapeCompartmentEditPart tContainer = getOwningShapeCompartment(target);
				// only deal with items contained within a shape compartment
				if (sContainer == null && tContainer == null) {
					continue;
				}
				boolean sfVisible = source != null;
				boolean tfVisible = target != null;
                
                ConnectionAnchor sc = cep.getSourceConnectionAnchor();
                ConnectionAnchor tc = cep.getTargetConnectionAnchor();
                Point sRefPoint;
                Point tRefPoint;
                List bendpoints = (List) connection.getConnectionRouter()
                    .getConstraint(connection);
                if (bendpoints.size() >= 2) {
                    sRefPoint = ((Bendpoint) bendpoints.get(0)).getLocation()
                        .getCopy();
                    connection.translateToAbsolute(sRefPoint);
                    tRefPoint = ((Bendpoint) bendpoints
                        .get(bendpoints.size() - 1)).getLocation().getCopy();
                    connection.translateToAbsolute(tRefPoint);
                } else {
                    sRefPoint = tc.getReferencePoint();
                    tRefPoint = sc.getReferencePoint();
                }
                Point sLoc = sc.getLocation(sRefPoint);
                Point tLoc = tc.getLocation(tRefPoint);
               
				Diagram diagram = ((View) scep.getModel()).getDiagram();
				Map registry = scep.getViewer().getEditPartRegistry();
				IGraphicalEditPart dep = (IGraphicalEditPart) registry
					.get(diagram);
				IFigure stopFigure = dep == null ? null
					: dep.getContentPane();
                boolean noSource = false;
                boolean noTarget = false;

				//
				// if sContainer is null, then the source connection is a child
				// of the diagram and not
				// a shape compartment. It's visibility is, therefore, true.
				if (sContainer != null) {
					ShapeCompartmentFigure fig = sContainer
						.getShapeCompartmentFigure();
                    noSource  = !fig.isVisible();
					sfVisible = isFigureVisible(fig, sLoc, stopFigure);
					if (!sfVisible) {
						sfVisible = isBorderItem(sContainer, source);
					}
				}
				//
				// if tContainer is null, then the source connection is a child
				// of the diagram and not
				// a shape compartment. It's visibility is, therefore, true.
				if (tContainer != null) {
					ShapeCompartmentFigure fig = tContainer
						.getShapeCompartmentFigure();
                    noTarget = !fig.isVisible();
                    tfVisible = isFigureVisible(fig, tLoc, stopFigure);
					if (!tfVisible) {
						tfVisible = isBorderItem(tContainer, target);
					}
				}
				// set connection visibility true iff both anchor points are
                // visible
                if (noSource || noTarget){
                  if (noSource && cep.getTarget()!=null)
                      cep.getTarget().refresh();
                  if (noTarget && cep.getSource()!=null)
                        cep.getSource().refresh();
                }else{
                    connection.setVisible(sfVisible && tfVisible);
                    refreshConnectionEnds(cep);
                }
			}
		}
        
        private void refreshConnectionEnds(ConnectionEditPart cEP){
            EditPart srcEditPart = cEP.getSource();
            EditPart trgEditPart = cEP.getTarget();
            Object model = cEP.getModel();
            if (model instanceof Edge){
                Edge edge = (Edge)model;
                View source = edge.getSource();
                View target = edge.getTarget();
                if (srcEditPart==null){
                    refreshEditPart(cEP.getViewer(), source);
                }
                if (trgEditPart==null){
                    refreshEditPart(cEP.getViewer(), target);
                }
            }
        }

        private void refreshEditPart(EditPartViewer  viewer, View view) {
            EditPart ep = (EditPart)viewer.getEditPartRegistry().get(view);
            if (ep!=null){
                ep.refresh();
            }
        }

		/**
		 * Return the set of {@@link ConnectionNodeEditPart}s contained in the
		 * supplied shape compartment.
		 * 
		 * @@param scep
		 *            a shape compartment.
		 * @@return a {@@link Set} of {@@link ConnectionNodeEditPart}.
		 */

		protected Set getConnectionNodes(ShapeCompartmentEditPart scep) {
			Set endPoints = new HashSet();
			Object modelObject = scep.getModel();
			if (scep.getViewer() == null || modelObject == null 
				|| !(modelObject instanceof View)) {
				return endPoints;
			}
			
			if (((View)modelObject).getDiagram()==null)
				return endPoints;

			Diagram diagram = ((View) modelObject).getDiagram();
			Map registry = scep.getViewer().getEditPartRegistry();
			List edges = diagram.getEdges();
			Iterator edgesIterator = edges.iterator();

			while (edgesIterator.hasNext()) {
				Edge edge = (Edge) edgesIterator.next();
				EditPart endPoint = (EditPart) registry.get(edge.getSource());
				if (isChildOf(scep, endPoint)) {
					Object cep = registry.get(edge);
					if (cep != null) {
						endPoints.add(cep);
					}
					continue;
				}
				endPoint = (EditPart) registry.get(edge.getTarget());
				if (isChildOf(scep, endPoint)) {
					Object cep = registry.get(edge);
					if (cep != null) {
						endPoints.add(cep);
					}
				}
			}
			return endPoints;
		}

		/**
		 * Return <tt>true</tt> if <tt>parent</tt> child's ancestor;
		 * otherwise <tt>false</tt>
		 * 
		 * @@param parent
		 *            parent to consider
		 * @@param child
		 *            child to consider
		 * @@return <tt>true</tt> or <tt>false</tt>
		 */
		protected boolean isChildOf(EditPart parent, EditPart child) {
			EditPart walker = child;
			while (walker != null && walker != parent) {
				walker = walker.getParent();
			}
			return walker != null;
		}

		/**
		 * gets the supplied editparts containing shape compartment.
		 * 
		 * @@param ep
		 *            edit part
		 * @@return <code> ShapeCompartmentEditPart</code>
		 */
		protected ShapeCompartmentEditPart getOwningShapeCompartment(EditPart ep) {
			EditPart walker = ep;
			while (walker != null
				&& !(walker instanceof ShapeCompartmentEditPart)) {
				walker = walker.getParent();
			}
			return (ShapeCompartmentEditPart) walker;
		}

		/**
         * This method can be overridden to allow connections between border
         * items around the container of the compartment to be drawn to items
         * within the interior of the compartment. This method should not return
         * true for all border items, only for those may be outside of the area
         * within the shape compartment.
         * 
         * @@param scep
         * @@param itemEditPart
         * @@return true if the itemEditPart is a border item around or outside
         *         the shape compartment editpart passed in; false otherwise.
         */
        protected boolean isBorderItem(ShapeCompartmentEditPart scep,
                IGraphicalEditPart itemEditPart) {
            return false;
        }

		/**
		 * Returns source edit part.
		 * 
		 * @@param connectionEditPart
		 * @@return EditPart
		 */
		protected EditPart getSourceEditPart(
				ConnectionEditPart connectionEditPart) {
			return connectionEditPart.getSource();
		}

		/**
		 * Returns target editPart
		 * 
		 * @@param connectionEditPart
		 * @@return EditPart
		 */
		protected EditPart getTargetEditPart(
				ConnectionEditPart connectionEditPart) {
			return connectionEditPart.getTarget();
		}

		/**
		 * gets the source connections of the passed edit part
		 * 
		 * @@param editPart
		 *            edit part to consider
		 * @@return source connections
		 */
		protected List getSourceConnections(IGraphicalEditPart editPart) {
			return editPart.getSourceConnections();
		}

		/**
		 * get the target connections of the passed edit part
		 * 
		 * @@param editPart
		 *            edit part to consider
		 * @@return target connection
		 */
		protected List getTargetConnections(IGraphicalEditPart editPart) {
			return editPart.getTargetConnections();
		}

		/**
		 * Walks up the hierarchy to make sure that supplied figure is visible
		 * inside its figure hierarchy. <BR>
		 * Same as calling <code>isFigureVisible(figure, loc, null);</code>
		 * 
		 * @@param figure
		 *            The figure under test.
		 * @@param loc
		 *            the child's location in absolute coordinates.
		 * @@return boolean visibility of the figure by going up the chain.
		 */
		protected boolean isFigureVisible(final IFigure figure, final Point loc) {
			return isFigureVisible(figure, loc, null);
		}

		/**
		 * Walks up the hierarchy to make sure that the point <code>loc</code> is visible
		 * inside its figure hierarchy. <BR>
		 * 
		 * @@param figure
		 *            The figure under test.
		 * @@param loc
		 *            the child's location in absolute coordinates.
		 * @@param stopFigure
		 *            root figure in the figure hierarchy being tested.
		 * @@return boolean visibility of the figure by going up the chain.
		 */
		protected boolean isFigureVisible(final IFigure figure,
				final Point loc, final IFigure stopFigure) {
			if (!(figure.isShowing())) {
				return false;
			} else {
				Rectangle bounds = figure.getBounds().getCopy();
				figure.translateToAbsolute(bounds);
				if (!(bounds.contains(loc))) {
					return false;
				}
			}

			IFigure parent = figure.getParent();
			while (parent != null && parent != stopFigure) {
				return isFigureVisible(parent, loc, stopFigure);
			}
			return true;
		}
	}

	/**
	 * Constructor for ShapeCompartmentEditPart.
	 * 
	 * @@param view
	 *            the view <code>controlled</code> by this editpart.
	 */
	public ShapeCompartmentEditPart(View view) {
		super(view);
	}

	/**
	 * Returns the connection refresh manager.
	 * 
	 * @@return <code>ConnectionRefreshMgr</code>
	 */
	protected final ConnectionRefreshMgr getConnectionRefreshMgr() {
		if (_crMgr == null) {
			_crMgr = createConnectionRefreshMgr();
		}
		return _crMgr;
	}

	/**
	 * Factory method to create a refresh connection. This implementation
	 * returns a {@@link ShapeCompartmentEditPart.ConnectionRefreshMgr} instance.
	 * 
	 * @@return <code>ConnectionRefreshMgr</code>
	 */
	protected ConnectionRefreshMgr createConnectionRefreshMgr() {
		return new ConnectionRefreshMgr();
	}

	/**
	 * Returns the layout manager to be used by this shape compartment. This
	 * implemantion returns a {@@link FreeformLayout} instance.
	 * 
	 * @@return a layout manager.
	 */
	protected LayoutManager getLayoutManager() {
		return new FreeFormLayoutEx();
	}

	/**
	 * Creates a scrollpane (with auto scrollbars) in which the children are
	 * drawn. The factory hint property is used to set this compartments label.
	 */
	protected IFigure createFigure() {
		ShapeCompartmentFigure scf = new ShapeCompartmentFigure(getCompartmentName(), getMapMode());
		scf.getContentPane().setLayoutManager(getLayoutManager());
        scf.getContentPane().addLayoutListener(LayoutAnimator.getDefault());

		return scf;
	}

	/**
	 * Convenience method to retrieve the shape compartment figure. Same as
	 * calling <code>(ShapeCompartmentFigure)getCompartmentFigure()</code>.
	 * 
	 * @@return <code>ShapeCompartmentFigure</code>
	 */
	public ShapeCompartmentFigure getShapeCompartmentFigure() {
		return (ShapeCompartmentFigure) getCompartmentFigure();
	}

	/** Return the container in which shape editparts are added. */
	public IFigure getContentPane() {
		return getShapeCompartmentFigure().getContentPane();
	}

	/**
	 * Adds the following editpolicies: <BR>
	 * <UL>
	 * <LI> {@@link EditPolicyRoles#CREATION_ROLE} :: {@@link CreationEditPolicy}
	 * <LI> {@@link EditPolicy#LAYOUT_ROLE} :: {@@link XYLayoutEditPolicy}
	 * <LI> {@@link EditPolicy#CONTAINER_ROLE} :: {@@link ContainerEditPolicy}
	 * <LI> {@@link EditPolicyRoles#DRAG_DROP_ROLE} ::
	 * {@@link DiagramLinkDragDropEditPolicy}
	 * <LI> {@@link EditPolicy#GRAPHICAL_NODE_ROLE} ::
	 * {@@link ContainerNodeEditPolicy}
	 * 
	 * <LI> {@@link EditPolicyRoles#SNAP_FEEDBACK_ROLE} ::
	 * {@@link SnapFeedbackPolicy}
	 * <LI> {@@link EditPolicyRoles#DRAG_DROP_ROLE} ::
	 * {@@link ShapeCompartmentDropEditPolicy}
	 * <LI> {@@link EditPolicyRoles#POPUPBAR_ROLE} :: {@@link PopupBarEditPolicy}
	 * </UL>
	 */
	protected void createDefaultEditPolicies() {
		super.createDefaultEditPolicies();
		installEditPolicy(EditPolicyRoles.CREATION_ROLE,
			new CreationEditPolicy());
		installEditPolicy(EditPolicy.LAYOUT_ROLE, new XYLayoutEditPolicy());
		installEditPolicy(EditPolicy.CONTAINER_ROLE, new ContainerEditPolicy());
		// TODO: this edit policy get overriden by code at the end of this
		// function
		// may be this breaks some use cases; it needs to be checked
		installEditPolicy(EditPolicyRoles.DRAG_DROP_ROLE,
			new DiagramLinkDragDropEditPolicy());
		installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE,
			new ContainerNodeEditPolicy());
		// Install an edit policy for snap
		installEditPolicy(EditPolicyRoles.SNAP_FEEDBACK_ROLE,
			new SnapFeedbackPolicy());
		installEditPolicy(EditPolicyRoles.DRAG_DROP_ROLE,
			new ShapeCompartmentDropEditPolicy());
		installEditPolicy(EditPolicyRoles.POPUPBAR_ROLE,
			new PopupBarEditPolicy());
	}

	/**
	 * Handles property change callbacks. All unrecognized events are forwarded
	 * to the parent class.
	 * 
	 * @@param event
	 *            a property change event.
	 */
	protected void handlePropertyChangeEvent(PropertyChangeEvent event) {
		String pName = event.getPropertyName();
		if (RangeModel.PROPERTY_EXTENT.equals(pName)
			|| RangeModel.PROPERTY_VALUE.equals(pName)) {
			refreshConnections();
		}
	}

	/**
	 * Refreshes the connections inside the shape compartment if the supplied
	 * event is for an element inserted or removed from the editpart.
	 * 
	 * @@see #refreshConnections()
	 * @@param event
	 *            a model server event.
	 */
	protected void handleNotificationEvent(Notification event) {
		Object feature = event.getFeature();
		if (NotationPackage.eINSTANCE.getSize_Width().equals(feature)
			|| NotationPackage.eINSTANCE.getSize_Height().equals(feature)) {
			refreshConnections();
		} else
			super.handleNotificationEvent(event);

		if (NotificationUtil.isElementAddedToSlot(event)
			|| NotificationUtil.isElementRemovedFromSlot(event)) {
			refreshConnections();
		}
	}

	/**
	 * Refresh the connections associated the the children of this shape
	 * compartment.
	 */
	protected void refreshConnections() {
		if (!_refreshQueued) {
			_refreshQueued = true;
			Display.getDefault().asyncExec(new Runnable() {

				public void run() {
					forceRefreshConnections();
				}
			});
		}
	}
    
    /**
     * Refresh the connections associated the the children of this shape
     * compartment.
     */
    protected void forceRefreshConnections() {
      try {
            //
            // test if active since the editpartg may have been
            // deleted
            // by the time this method is executed.
            if (ShapeCompartmentEditPart.this.isActive()) {
                getConnectionRefreshMgr().refreshConnections(
                    ShapeCompartmentEditPart.this);
            }
        } finally {
            ShapeCompartmentEditPart.this._refreshQueued = false;
        }
        
    }

	/** Unregisters this instance as a PropertyChangeListener on its figure. */
	protected void unregister() {
		super.unregister();
		getShapeCompartmentFigure().removePropertyChangeListener(this);
		EditPartViewer viewer = getViewer();
		if (viewer != null && viewer.getControl() instanceof FigureCanvas) {
			FigureCanvas figureCanvas = (FigureCanvas) viewer.getControl();
			figureCanvas.getViewport().getVerticalRangeModel()
				.removePropertyChangeListener(this);
			figureCanvas.getViewport().getHorizontalRangeModel()
				.removePropertyChangeListener(this);
		}
	}

	/** Registers this instance as a PropertyChangeListener on its figure. */
	protected void registerVisuals() {
		super.registerVisuals();
		getShapeCompartmentFigure().addPropertyChangeListener(this);

		EditPartViewer viewer = getViewer();
		if (viewer != null && viewer.getControl() instanceof FigureCanvas) {
			FigureCanvas figureCanvas = (FigureCanvas) viewer.getControl();
			figureCanvas.getViewport().getVerticalRangeModel()
				.addPropertyChangeListener(this);
			figureCanvas.getViewport().getHorizontalRangeModel()
				.addPropertyChangeListener(this);
		}
	}

	/**
	 * Determines if the shape compartment supports drag selection of it's
	 * children. Otherwise, it will default to the core behavior of selecting
	 * the compartment itself on click on the compartment background surface.
	 * 
	 * @@return <code>boolean</code> <code>true</code> if shape compartment
	 *         supports drag selection of it's children, <code>false</code>
	 *         otherwise.
	 */
	protected boolean supportsDragSelection() {
		return true;
	}

	/**
	 * @@see org.eclipse.gef.EditPart#getDragTracker(org.eclipse.gef.Request)
	 */
	public DragTracker getDragTracker(Request req) {
		if (!supportsDragSelection())
			return super.getDragTracker(req);

		if (req instanceof SelectionRequest
			&& ((SelectionRequest) req).getLastButtonPressed() == 3)
			return new DeselectAllTracker(this) {

				protected boolean handleButtonDown(int button) {
					getCurrentViewer().select(ShapeCompartmentEditPart.this);
					return true;
				}
			};
		return new RubberbandDragTracker() {

			protected void handleFinished() {
				if (getViewer().getSelectedEditParts().isEmpty())
					getViewer().select(ShapeCompartmentEditPart.this);
			}
		};
	}

	/** Also calls {@@link #refreshConnections()}. */
	protected void refreshVisibility() {
		super.refreshVisibility();
        View view  = getNotationView();
        if (view !=null && !view.isVisible())
            forceRefreshConnections();
        else
            refreshConnections();
	}

	/*
	 * (non-Javadoc)
	 */
	public boolean isSupportingViewActions() {
		return this.isSupportingViewActions;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.editparts.ISurfaceEditPart#setIsSupportingViewActions(boolean)
	 */
	public void setIsSupportingViewActions(boolean supportsViewActions) {
		this.isSupportingViewActions = supportsViewActions;
	}

	/**
	 * Handles the passed property changed event only if the editpart's view is
	 * not deleted.
	 */
	public final void propertyChange(PropertyChangeEvent event) {
		if (isActive())
			handlePropertyChangeEvent(event);
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.internal.editparts.ISurfaceEditPart#getPrimaryEditParts()
	 */
	public List getPrimaryEditParts() {
		List connections = new ArrayList();

		Object diagramEditPart = getViewer().getEditPartRegistry().get(
			getDiagramView());

		List shapes = getChildren();
		Set connectableEditParts = new HashSet(shapes);
		Iterator iter = shapes.iterator();
		while (iter.hasNext()) {
			getBorderItemEditParts((EditPart) iter.next(), connectableEditParts);
		}

		if (diagramEditPart instanceof DiagramEditPart) {
			Iterator diagramConnections = ((DiagramEditPart) diagramEditPart)
				.getConnections().iterator();
			while (diagramConnections.hasNext()) {
				ConnectionEditPart connection = (ConnectionEditPart) diagramConnections
					.next();
				if (connectableEditParts.contains(connection.getSource())
					|| connectableEditParts.contains(connection.getTarget()))
					connections.add(connection);
			}
		}

		if (connections.size() > 0 || shapes.size() > 0) {
			List primaryEditParts = new ArrayList();
			primaryEditParts.addAll(shapes);
			primaryEditParts.addAll(connections);
			return primaryEditParts;
		}
		return Collections.EMPTY_LIST;
	}
	
	/**
	 * This method searches an edit part for a child that is a border item edit part
	 * @@param parent part needed to search
	 * @@param set to be modified of border item edit parts that are direct children of the parent
	 */
	private void getBorderItemEditParts(EditPart parent, Set retval) {
		
		Iterator iter = parent.getChildren().iterator();
		while(iter.hasNext()) {
			EditPart child = (EditPart)iter.next();
			if( child instanceof IBorderItemEditPart ) {
				retval.add(child);
				retval.addAll(child.getChildren());
			}
			getBorderItemEditParts(child, retval);
		}
	}
    
    public void addNotify() {
        addEditPartListener(editpartListener);
        super.addNotify();
    }

    public void removeNotify() {
        removeEditPartListener(editpartListener);
        super.removeNotify();
    }

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ResizableCompartmentEditPart#setCollapsed(boolean, boolean)
	 */
	protected void setCollapsed(boolean collapsed, boolean animate) {
		super.setCollapsed(collapsed, animate);
		refreshConnections();
	}

}
@


1.22
log
@Rollback router related part of the fix for Bugzilla 214622
@
text
@d132 9
@


1.21
log
@[214622] gmf_head aboyko 080109 ShapeCompartmentEditPart.ConnectionRefreshMgr needs improvement
@
text
@d24 1
d26 1
a34 1
import org.eclipse.draw2d.geometry.PrecisionPoint;
d149 19
a167 9
				if (!connection.isVisible()) {
					connection.setVisible(true);
					connection.getConnectionRouter().route(connection);
					connection.setVisible(false);
				}
				Point sLoc = new PrecisionPoint(connection.getPoints().getFirstPoint());
				Point tLoc = new PrecisionPoint(connection.getPoints().getLastPoint());
				connection.translateToAbsolute(sLoc);
				connection.translateToAbsolute(tLoc);
@


1.20
log
@[214622] gmf_head aboyko 080109 ShapeCompartmentEditPart.ConnectionRefreshMgr needs improvement
@
text
@d402 1
a408 1
				return false;
@


1.19
log
@[157813] gmf_head crevells 070613 Issues with ShapeCompartmentEditPart.ConnectionRefreshMgr
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
a23 1
import org.eclipse.draw2d.Bendpoint;
a24 1
import org.eclipse.draw2d.ConnectionAnchor;
d33 1
a33 1
import org.eclipse.draw2d.geometry.PointList;
d133 6
d148 9
a156 19
                ConnectionAnchor sc = cep.getSourceConnectionAnchor();
                ConnectionAnchor tc = cep.getTargetConnectionAnchor();
                Point sRefPoint;
                Point tRefPoint;
                List bendpoints = (List) connection.getConnectionRouter()
                    .getConstraint(connection);
                if (bendpoints.size() >= 2) {
                    sRefPoint = ((Bendpoint) bendpoints.get(0)).getLocation()
                        .getCopy();
                    connection.translateToAbsolute(sRefPoint);
                    tRefPoint = ((Bendpoint) bendpoints
                        .get(bendpoints.size() - 1)).getLocation().getCopy();
                    connection.translateToAbsolute(tRefPoint);
                } else {
                    sRefPoint = tc.getReferencePoint();
                    tRefPoint = sc.getReferencePoint();
                }
                Point sLoc = sc.getLocation(sRefPoint);
                Point tLoc = tc.getLocation(tRefPoint);
d388 1
a388 1
		 * Walks up the hierarchy to make sure that supplied figure is visible
d401 1
a401 2
			if (!(figure.isVisible())) {
				return false;
d408 1
d768 8
@


1.19.2.1
log
@[214622] gmf_R2_0_maintenance aboyko 080109 ShapeCompartmentEditPart.ConnectionRefreshMgr needs improvement
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2008 IBM Corporation and others.
d24 1
d26 1
d35 1
a35 1
import org.eclipse.draw2d.geometry.PrecisionPoint;
a134 6
				
				if (!source.getFigure().isShowing() || !target.getFigure().isShowing()) {
					connection.setVisible(false);
					continue;
				}
				
d144 19
a162 9
				if (!connection.isVisible()) {
					connection.setVisible(true);
					connection.getConnectionRouter().route(connection);
					connection.setVisible(false);
				}
				Point sLoc = new PrecisionPoint(connection.getPoints().getFirstPoint());
				Point tLoc = new PrecisionPoint(connection.getPoints().getLastPoint());
				connection.translateToAbsolute(sLoc);
				connection.translateToAbsolute(tLoc);
d394 1
a394 1
		 * Walks up the hierarchy to make sure that the point <code>loc</code> is visible
d407 1
a407 1
			if (!(figure.isShowing())) {
a773 8
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.ResizableCompartmentEditPart#setCollapsed(boolean, boolean)
	 */
	protected void setCollapsed(boolean collapsed, boolean animate) {
		super.setCollapsed(collapsed, animate);
		refreshConnections();
	}

@


1.19.2.2
log
@Rollback router related part of the fix for Bugzilla 214622
@
text
@a23 1
import org.eclipse.draw2d.Bendpoint;
a24 1
import org.eclipse.draw2d.ConnectionAnchor;
d33 1
d148 9
a156 19
                ConnectionAnchor sc = cep.getSourceConnectionAnchor();
                ConnectionAnchor tc = cep.getTargetConnectionAnchor();
                Point sRefPoint;
                Point tRefPoint;
                List bendpoints = (List) connection.getConnectionRouter()
                    .getConstraint(connection);
                if (bendpoints.size() >= 2) {
                    sRefPoint = ((Bendpoint) bendpoints.get(0)).getLocation()
                        .getCopy();
                    connection.translateToAbsolute(sRefPoint);
                    tRefPoint = ((Bendpoint) bendpoints
                        .get(bendpoints.size() - 1)).getLocation().getCopy();
                    connection.translateToAbsolute(tRefPoint);
                } else {
                    sRefPoint = tc.getReferencePoint();
                    tRefPoint = sc.getReferencePoint();
                }
                Point sLoc = sc.getLocation(sRefPoint);
                Point tLoc = tc.getLocation(tRefPoint);
@


1.18
log
@[112799]  gmf_head mmostafa 070116 Shapes do not snap to grid when dragged over other shapes
@
text
@d24 1
d35 1
a116 1

d143 21
a163 7
				ConnectionAnchor sc = cep.getSourceConnectionAnchor();
				ConnectionAnchor tc = cep.getTargetConnectionAnchor();
				//
				// get the connection locations
				Point sLoc = sc.getLocation(tc.getReferencePoint());
				Point tLoc = tc.getLocation(sc.getReferencePoint());

d318 15
a332 12
		 * This method can be overridden to allow connections between border
		 * items to be drawn to items within the interior of the compartment.
		 * 
		 * @@param scep
		 * @@param itemEditPart
		 * @@return false by default. Override to allow connections to border
		 *         items.
		 */
		protected boolean isBorderItem(ShapeCompartmentEditPart scep,
				IGraphicalEditPart itemEditPart) {
			return false;
		}
@


1.17
log
@[167878]  gmf_head mmostafa 061213 Users can resize Figures to be smaller than the min size
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
a35 1
import org.eclipse.gef.CompoundSnapToHelper;
a42 4
import org.eclipse.gef.SnapToGeometry;
import org.eclipse.gef.SnapToGrid;
import org.eclipse.gef.SnapToGuides;
import org.eclipse.gef.SnapToHelper;
a44 1
import org.eclipse.gef.rulers.RulerProvider;
a655 33
	/** Adds the ability to adapt to {@@link SnapToHelper}. */
	public Object getAdapter(Class adapter) {

		if (adapter == SnapToHelper.class) {

			List snapStrategies = new ArrayList();

			Boolean val = (Boolean) getViewer().getProperty(
				RulerProvider.PROPERTY_RULER_VISIBILITY);
			if (val != null && val.booleanValue())
				snapStrategies.add(new SnapToGuides(this));

			val = (Boolean) getViewer().getProperty(
				SnapToGeometry.PROPERTY_SNAP_ENABLED);
			if (val != null && val.booleanValue())
				snapStrategies.add(new SnapToGrid((GraphicalEditPart) this
					.getParent()));

			if (snapStrategies.size() == 0)
				return null;

			if (snapStrategies.size() == 1)
				return snapStrategies.get(0);

			SnapToHelper ss[] = new SnapToHelper[snapStrategies.size()];
			for (int i = 0; i < snapStrategies.size(); i++)
				ss[i] = (SnapToHelper) snapStrategies.get(i);
			return new CompoundSnapToHelper(ss);
		}

		return super.getAdapter(adapter);
	}

@


1.16
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d64 1
d452 1
a452 1
		return new FreeformLayout();
@


1.15
log
@Bugzilla#140166 gmf_head cmahoney 060515 Move necessary client accessed internal classes into public API
@
text
@d27 1
d40 1
d88 25
a131 1

d160 2
d170 1
d183 2
a184 1
					tfVisible = isFigureVisible(fig, tLoc, stopFigure);
d190 10
a199 2
				// visible
				connection.setVisible(sfVisible && tfVisible);
d202 24
d568 1
a568 12
					try {
						//
						// test if active since the editpartg may have been
						// deleted
						// by the time this method is executed.
						if (ShapeCompartmentEditPart.this.isActive()) {
							getConnectionRefreshMgr().refreshConnections(
								ShapeCompartmentEditPart.this);
						}
					} finally {
						ShapeCompartmentEditPart.this._refreshQueued = false;
					}
d573 20
d697 5
a701 1
		refreshConnections();
d783 10
@


1.15.2.1
log
@[149689] gmf_R1_0_maintenace mmostafa 060725  Canonical edipolicy does not refresh connectors if one compartment becomes invisible.
@
text
@a133 2
                boolean noSource = false;
                boolean noTarget = false;
a141 1
                    noSource  = !fig.isVisible();
d154 1
a154 2
                    noTarget = !fig.isVisible();
                    tfVisible = isFigureVisible(fig, tLoc, stopFigure);
d160 2
a161 10
                // visible
                if (noSource || noTarget){
                  if (noSource && cep.getTarget()!=null)
                      cep.getTarget().refresh();
                  if (noTarget && cep.getSource()!=null)
                        cep.getSource().refresh();
                }else{
                    connection.setVisible(sfVisible && tfVisible);
                    refreshConnectionEnds(cep);
                }
a163 24
        
        private void refreshConnectionEnds(ConnectionEditPart cEP){
            EditPart srcEditPart = cEP.getSource();
            EditPart trgEditPart = cEP.getTarget();
            Object model = cEP.getModel();
            if (model instanceof Edge){
                Edge edge = (Edge)model;
                View source = edge.getSource();
                View target = edge.getTarget();
                if (srcEditPart==null){
                    refreshEditPart(cEP.getViewer(), source);
                }
                if (trgEditPart==null){
                    refreshEditPart(cEP.getViewer(), target);
                }
            }
        }

        private void refreshEditPart(EditPartViewer  viewer, View view) {
            EditPart ep = (EditPart)viewer.getEditPartRegistry().get(view);
            if (ep!=null){
                ep.refresh();
            }
        }
d506 12
a517 1
					forceRefreshConnections();
a521 20
    
    /**
     * Refresh the connections associated the the children of this shape
     * compartment.
     */
    protected void forceRefreshConnections() {
      try {
            //
            // test if active since the editpartg may have been
            // deleted
            // by the time this method is executed.
            if (ShapeCompartmentEditPart.this.isActive()) {
                getConnectionRefreshMgr().refreshConnections(
                    ShapeCompartmentEditPart.this);
            }
        } finally {
            ShapeCompartmentEditPart.this._refreshQueued = false;
        }
        
    }
d626 1
a626 5
        View view  = getNotationView();
        if (view !=null && !view.isVisible())
            forceRefreshConnections();
        else
            refreshConnections();
@


1.15.2.2
log
@Bugzilla#146581 gmf_R1_0_maintenance cmahoney 060914 Hidden connection doesn't reappear
@
text
@a26 1
import org.eclipse.draw2d.FigureListener;
a38 1
import org.eclipse.gef.EditPartListener;
a85 25
    
    // Listen to editparts being added to or removed from this compartment
    // editpart so that when a figure moves within the compartment we can call
    // refreshConnections(). See bugzilla#146581.
    private EditPartListener editpartListener = new EditPartListener.Stub() {

        private FigureListener childFigureListener = new FigureListener() {

            public void figureMoved(IFigure source) {
                refreshConnections();
            }
        };

        public void childAdded(EditPart child, int index) {
            ((GraphicalEditPart) child).getFigure().addFigureListener(
                childFigureListener);
        }

        public void removingChild(EditPart child, int index) {
            ((GraphicalEditPart) child).getFigure().removeFigureListener(
                childFigureListener);

        }

    };
d105 1
a756 10
    
    public void addNotify() {
        addEditPartListener(editpartListener);
        super.addNotify();
    }

    public void removeNotify() {
        removeEditPartListener(editpartListener);
        super.removeNotify();
    }
@


1.15.2.3
log
@[167878]  gmf_R1_0_maintenace mmostafa 061213 Users can resize Figures to be smaller than the min size
@
text
@a63 1
import org.eclipse.gmf.runtime.diagram.ui.layout.FreeFormLayoutEx;
d451 1
a451 1
		return new FreeFormLayoutEx();
@


1.14
log
@bugzilla 132219 gmf-head sshaw 030630 Use diagram editor mapmode in ShapeCompartmentFigure and ResizableCompartmentFigure
@
text
@d56 1
a60 1
import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.ShapeCompartmentDropEditPolicy;
@


1.13
log
@bugzilla 129794 gmf-head sshaw 060306 Animated layout doesn't work inside shape compartment container
@
text
@a56 1
import org.eclipse.gmf.runtime.diagram.ui.figures.ResizableCompartmentFigure;
d397 1
a397 2
		ShapeCompartmentFigure scf = new ShapeCompartmentFigure(getCompartmentName(),
			getMapMode().DPtoLP(ResizableCompartmentFigure.MIN_CLIENT_DP));
@


1.12
log
@bugzilla 125158 gmf-head sshaw 060126 Migrate GMF animation support to use GEF 3.2 infrastructure for animation
@
text
@d401 1
a401 1
		scf.addLayoutListener(LayoutAnimator.getDefault());
@


1.11
log
@Bugzilla#123778 gmf_head cmahoney 060120 CopyToImageAction support in GMF
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d29 1
a62 1
import org.eclipse.gmf.runtime.draw2d.ui.figures.AnimatableLayoutListener;
d401 1
a401 1
		scf.addLayoutListener(new AnimatableLayoutListener());
@


1.10
log
@bugzilla 121595 gmf_head sshaw 051220 Make ResizableCompartmentEditPart#getTitleName public
@
text
@d17 1
d35 1
d655 55
@


1.9
log
@bugzilla  115643 : gmf-head mmostafa 051109 :  Null Pointer Exception on ShapeCompartment edit part
@
text
@d54 1
d396 2
a397 1
		ShapeCompartmentFigure scf = new ShapeCompartmentFigure(getTitleName());
a589 5
	/** Return null. */
	protected String getTitleName() {
		return null;
	}

d612 1
a612 1
				return (SnapToHelper) snapStrategies.get(0);
@


1.8
log
@bugzilla  115643 : gmf-head mmostafa 051109 :  Null Pointer Exception on ShapeCompartment edit part
@
text
@a47 1
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
a53 1
import org.eclipse.gmf.runtime.diagram.ui.figures.ResizableCompartmentFigure;
@


1.7
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d48 1
d177 1
a177 1
			if (scep.getViewer() == null || modelObject == null
d181 3
@


1.6
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d54 1
d60 1
d395 2
@


1.5
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d13 1
a47 1
import org.eclipse.gmf.runtime.diagram.ui.editpolicies.ActionBarEditPolicy;
d52 1
d64 1
d66 3
a68 2
 * A generic (sub) shape container that holds instances of <code>ShapeNodeEditPart</code>s and
 * manages the display of <code>ConnectionNodeEditPart</code>s anchored to these shape editpart 
d70 1
a70 1
 *
d73 7
a79 5
public abstract class ShapeCompartmentEditPart extends ResizableCompartmentEditPart implements ISurfaceEditPart, PropertyChangeListener {
	
	/** private connector refresh manager. */
	private ConnectorRefreshMgr _crMgr;
	
d81 1
a81 1
	
d83 1
a83 1
	
d85 3
a87 3
	 * Class used to refresh the connectors associated to the shape compartment's
	 * children.  This implementation will hide all connectors whose endpoints are
	 * not visible inside the shape compartment.
d89 2
a90 1
	public static class ConnectorRefreshMgr {
d92 4
a95 2
		 * Cycles through all the connectors associated to the editparts contained within
		 * the passed shape compartment and sets their visibility. 
d98 2
a99 1
		 * @@param scep edit part to consider
d101 2
a102 2
		protected void refreshConnectors(ShapeCompartmentEditPart scep) {
			
d104 6
a109 8
			while( connectionNodes.hasNext() ) {
				ConnectionNodeEditPart cep = (ConnectionNodeEditPart)connectionNodes.next();
				Connection connector =
					(Connection)cep.getFigure();
				IGraphicalEditPart source =
					(IGraphicalEditPart)getSourceEditPart(cep);
				IGraphicalEditPart target =
					(IGraphicalEditPart)getTargetEditPart(cep);
d113 1
a113 1
				if ( sContainer == null && tContainer == null ) {
d121 1
a121 1
				// get the connector locations
a123 1
				
d125 1
a125 1
				Diagram diagram = ((View)scep.getModel()).getDiagram();
d127 5
a131 3
				IGraphicalEditPart dep = (IGraphicalEditPart)registry.get(diagram);
				IFigure stopFigure = dep == null ? null : dep.getContentPane();
				
d133 3
a135 2
				// if sContainer is null, then the source connector is a child of the diagram and not
				// a shape compartment.  It's visibility is, therefore, true.				
d137 2
a138 1
					ShapeCompartmentFigure fig = sContainer.getShapeCompartmentFigure();
d140 1
a140 1
					if( !sfVisible ) {
d145 3
a147 2
				// if tContainer is null, then the source connector is a child of the diagram and not
				// a shape compartment.  It's visibility is, therefore, true.
d149 2
a150 1
					ShapeCompartmentFigure fig = tContainer.getShapeCompartmentFigure();
d152 1
a152 1
					if( !tfVisible ) {
d156 3
a158 2
				// set connector visibility true iff both anchor points are visible
				connector.setVisible(sfVisible && tfVisible);
d161 8
a168 5
		/** 
		 * Return the set of {@@link ConnectionNodeEditPart}s
		 * contained in the supplied shape compartment.
		 * @@param scep a shape compartment.
		 * @@return a {@@link Set} of  {@@link ConnectionNodeEditPart}.
d171 1
a171 1
		protected Set getConnectionNodes( ShapeCompartmentEditPart scep ) {
d174 2
a175 3
			if (scep.getViewer() == null ||
				modelObject  == null || 
				!(modelObject instanceof View)) {
d179 1
a179 1
			Diagram diagram = ((View)modelObject).getDiagram();
d181 2
a182 2
			List edges = diagram.getEdges();			
			Iterator connectors = edges.iterator();
d184 7
a190 7
			while( connectors.hasNext() ) {
				Edge connector = (Edge)connectors.next();
				EditPart endPoint = (EditPart)registry.get(connector.getSource() );
				if ( isChildOf(scep, endPoint) ) {
					Object cep = registry.get(connector);
					if ( cep != null ) {
						endPoints.add( cep );
d194 5
a198 5
				endPoint = (EditPart)registry.get(connector.getTarget());
				if ( isChildOf(scep, endPoint) ) {
					Object cep = registry.get(connector);
					if ( cep != null ) {
						endPoints.add( cep );
a204 1
		
d206 7
a212 3
		 * Return <tt>true</tt> if <tt>parent</tt> child's ancestor; otherwise <tt>false</tt>
		 * @@param parent parent to consider
		 * @@param child child to consider
d215 8
a222 8
		protected boolean isChildOf( EditPart parent, EditPart child ) {
		 	EditPart walker = child;
		 	while( walker != null && walker != parent ) {
		 		walker = walker.getParent();
		 	}
		 	return walker != null;
		 }
		 
d225 3
a227 1
		 * @@param ep edit part 
d230 1
a230 1
		protected ShapeCompartmentEditPart getOwningShapeCompartment( EditPart ep ) {
d232 2
a233 1
			while ( walker != null && !(walker instanceof ShapeCompartmentEditPart) ) {
d236 1
a236 1
			return (ShapeCompartmentEditPart)walker;
d238 1
a238 1
		
d240 2
a241 2
		 * This method can be overridden to allow connections between border items to be
		 * drawn to items within the interior of the compartment.  
d245 2
a246 1
		 * @@return false by default.  Override to allow connections to border items.
d248 2
a249 1
		protected boolean isBorderItem( ShapeCompartmentEditPart scep, IGraphicalEditPart itemEditPart ) {
d252 1
a252 1
		
d255 1
d259 2
a260 1
		protected EditPart getSourceEditPart(ConnectionEditPart connectionEditPart) {
d263 1
d266 1
d270 2
a271 1
		protected EditPart getTargetEditPart(ConnectionEditPart connectionEditPart) {
d277 3
a279 1
		 * @@param editPart edit part to consider
d285 1
d288 4
a291 2
		 * @@param editPart edit part to consider
		 * @@return target connection 
d296 1
a296 1
		
d301 5
a305 2
		 * @@param figure The figure under test.
		 * @@param loc the child's location in absolute coordinates.
d308 2
a309 2
		protected boolean isFigureVisible(final IFigure figure, final Point loc ) {
			return isFigureVisible( figure, loc, null );
d311 1
a311 1
		
d315 7
a321 3
		 * @@param figure The figure under test.
		 * @@param loc the child's location in absolute coordinates.
		 * @@param stopFigure root figure in the figure hierarchy being tested.
d324 2
a325 1
		protected boolean isFigureVisible(final IFigure figure, final Point loc, final IFigure stopFigure) {
d328 1
a328 2
			}
			else {
d335 1
a335 1
			
d343 1
a343 2
	
	
d346 3
a348 1
	 * @@param view the view <code>controlled</code> by this editpart.
d355 3
a357 2
	 * Returns the connector refresh manager.
	 * @@return <code>ConnectorRefreshMgr</code> 
d359 1
a359 1
	protected final ConnectorRefreshMgr getConnectorRefreshMgr() {
d361 1
a361 1
			_crMgr = createConnectorRefreshMgr();
d367 4
a370 3
	 * Factory method to create a refresh connector.  This implementation returns
	 * a {@@link ShapeCompartmentEditPart.ConnectorRefreshMgr} instance.
	 * @@return <code>ConnectorRefreshMgr</code>
d372 2
a373 2
	protected ConnectorRefreshMgr createConnectorRefreshMgr() {
		return new ConnectorRefreshMgr();
d375 1
a375 1
	
d377 3
a379 2
	 * Returns the layout manager to be used by this shape compartment.
	 * This implemantion returns a {@@link FreeformLayout} instance.
d385 1
d387 2
a388 2
	 * Creates a scrollpane (with auto scrollbars) in which the children are drawn.
	 * The factory hint property is used to set this compartments label.
d395 5
a399 4
		
	/** 
	 * Convenience method to retrieve the shape compartment figure.
	 * Same as calling <code>(ShapeCompartmentFigure)getCompartmentFigure()</code>.
d403 1
a403 1
		return (ShapeCompartmentFigure)getCompartmentFigure();
d405 1
a405 1
	
d410 1
a410 1
	
d417 4
a420 2
	 * <LI> {@@link EditPolicyRoles#DRAG_DROP_ROLE} :: {@@link DiagramLinkDragDropEditPolicy}
	 * <LI> {@@link EditPolicy#GRAPHICAL_NODE_ROLE} :: {@@link ContainerNodeEditPolicy}
d422 5
a426 3
	 * <LI> {@@link EditPolicyRoles#SNAP_FEEDBACK_ROLE} :: {@@link SnapFeedbackPolicy}
	 * <LI> {@@link EditPolicyRoles#DRAG_DROP_ROLE} :: {@@link ShapeCompartmentDropEditPolicy}
	 * <LI> {@@link EditPolicyRoles#ACTIONBAR_ROLE} :: {@@link ActionBarEditPolicy}
d431 2
a432 1
		installEditPolicy(EditPolicyRoles.CREATION_ROLE,new CreationEditPolicy());
d435 2
a436 1
		// TODO: this edit policy get overriden by code at the end of this function 
d438 3
a440 3
		installEditPolicy(EditPolicyRoles.DRAG_DROP_ROLE, new DiagramLinkDragDropEditPolicy());
		installEditPolicy(
			EditPolicy.GRAPHICAL_NODE_ROLE,
d443 6
a448 3
		installEditPolicy(EditPolicyRoles.SNAP_FEEDBACK_ROLE, new SnapFeedbackPolicy());
		installEditPolicy(EditPolicyRoles.DRAG_DROP_ROLE, new ShapeCompartmentDropEditPolicy());
		installEditPolicy(EditPolicyRoles.ACTIONBAR_ROLE, new ActionBarEditPolicy());
d450 1
a450 1
	
d452 1
a452 1
	 * Handles property change callbacks.  All unrecognized events are forwarded
d454 3
a456 1
	 * @@param event a property change event.
d462 1
a462 1
			refreshConnectors();
d465 1
a465 1
	
d467 6
a472 5
	 * Refreshes the connectors inside the shape compartment 
	 * if the supplied event is for an element inserted or
	 * removed from the editpart.
	 * @@see #refreshConnectors()
	 * @@param event a model server event.
d474 1
a474 1
	protected void handleNotificationEvent( Notification event ) {
d478 1
a478 1
			refreshConnectors();
d481 4
a484 4
		
		if (NotificationUtil.isElementAddedToSlot(event) ||
			NotificationUtil.isElementRemovedFromSlot(event) ) {
			refreshConnectors();
d488 6
a493 4
	
	/** Refresh the connectors associated the the children of this shape compartment. */
	protected void refreshConnectors() {
		if ( !_refreshQueued ) {
d495 2
a496 1
			Display.getDefault().asyncExec( new Runnable() {
d500 2
a501 1
						// test if active since the editpartg may have been deleted
d503 3
a505 2
						if ( ShapeCompartmentEditPart.this.isActive() ) {
							getConnectorRefreshMgr().refreshConnectors(ShapeCompartmentEditPart.this);
d507 1
a507 2
					}
					finally {
d521 5
a525 3
			FigureCanvas figureCanvas = (FigureCanvas)viewer.getControl();
			figureCanvas.getViewport().getVerticalRangeModel().removePropertyChangeListener(this);
			figureCanvas.getViewport().getHorizontalRangeModel().removePropertyChangeListener(this);
d528 1
a528 1
	
d533 1
a533 1
		
d535 6
a540 4
		if ( viewer != null && viewer.getControl() instanceof FigureCanvas) {
			FigureCanvas figureCanvas = (FigureCanvas)viewer.getControl();
			figureCanvas.getViewport().getVerticalRangeModel().addPropertyChangeListener(this);
			figureCanvas.getViewport().getHorizontalRangeModel().addPropertyChangeListener(this);
d543 1
a543 1
	
d545 3
a547 2
	 * Determines if the shape compartment supports drag selection of it's children.  Otherwise, it will default
	 * to the core behavior of selecting the compartment itself on click on the compartment background surface.
d549 3
a551 2
	 * @@return <code>boolean</code> <code>true</code> if shape compartment supports drag selection of it's children,
	 * <code>false</code> otherwise.
d556 1
a556 1
	
d563 10
a572 9
		
		if (req instanceof SelectionRequest 
			&& ((SelectionRequest)req).getLastButtonPressed() == 3)
				return new DeselectAllTracker(this) {
					protected boolean handleButtonDown(int button) {
						getCurrentViewer().select(ShapeCompartmentEditPart.this);
						return true;
					}
				};
d574 1
d581 1
a581 1
	
d586 1
a586 1
		
d594 2
a595 1
			Boolean val = (Boolean)getViewer().getProperty(RulerProvider.PROPERTY_RULER_VISIBILITY);
d599 2
a600 1
			val = (Boolean)getViewer().getProperty(SnapToGeometry.PROPERTY_SNAP_ENABLED);
d602 2
a603 1
				snapStrategies.add(new SnapToGrid((GraphicalEditPart)this.getParent()));
d609 1
a609 1
				return (SnapToHelper)snapStrategies.get(0);
d613 1
a613 1
				ss[i] = (SnapToHelper)snapStrategies.get(i);
d619 2
a620 2
	
	/** Also calls {@@link #refreshConnectors()}. */
d623 1
a623 1
		refreshConnectors();
d625 3
a627 3
	
	
	/* (non-Javadoc)
d629 1
a629 1
	public boolean isSupportingViewActions(){
d632 4
a635 2
	
	/* (non-Javadoc)
d638 1
a638 1
	public void setIsSupportingViewActions(boolean supportsViewActions){
d641 1
a641 1
	
a650 1

@


1.4
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d14 1
d31 1
d46 1
a46 3
import org.eclipse.swt.widgets.Display;

import org.eclipse.gmf.runtime.diagram.core.listener.NotificationEvent;
a57 1
import org.eclipse.gmf.runtime.diagram.ui.properties.Properties;
d60 1
d62 1
d70 1
a70 1
public abstract class ShapeCompartmentEditPart extends ResizableCompartmentEditPart implements ISurfaceEditPart {
d403 1
a403 3
		if (Properties.ID_EXTENTX.equals(pName)
			|| Properties.ID_EXTENTY.equals(pName)
			|| RangeModel.PROPERTY_EXTENT.equals(pName)
a406 3
		else {
			super.handlePropertyChangeEvent(event);
		}
d416 10
a425 3
	protected void handleNotificationEvent( NotificationEvent event ) {
		super.handleNotificationEvent(event);
		if ( event.isElementAddedToSlot() || event.isElementRemovedFromSlot() ) {
d566 11
@


1.3
log
@bugzilla 108310 gmf-head sshaw 050824 API analysis of draw2d / draw2d.render plug-ins
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d474 11
d488 3
d556 1
a560 7
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart#shouldAllowDisableCanonicalRefresh()
	 */
	protected boolean shouldAllowDisableCanonicalRefresh() {
		return false;
	}
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d57 3
a59 3
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.Edge;
import com.ibm.xtools.notation.View;
@

