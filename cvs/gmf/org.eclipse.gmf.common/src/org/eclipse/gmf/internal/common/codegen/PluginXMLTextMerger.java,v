head	1.5;
access;
symbols
	v20081015-1925:1.5
	v20080930-1130:1.5
	v20080926-1245:1.5
	v20080924-1925:1.5
	v20080722-1827:1.5
	v20080716-1642:1.5
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080610-1132:1.5
	v20080521:1.5
	v20080516-1143:1.5
	v20080508-2000:1.5
	v20080417-1610:1.5
	v20080322-0000:1.5
	v20080222-1200:1.5
	v20071108-0000:1.5
	v20070903-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070525-1500:1.4
	v20070520-1200:1.4
	v20070518-1300:1.4
	v20070427-0600:1.4
	v20070420-1000:1.4
	v20070413-1300:1.4
	v20070405-1100:1.4
	v20070330-1300:1.4
	v20060330-1300:1.4
	v20070322-1100:1.4
	v20070307-0700:1.3
	v20070301-1200:1.3
	v20070228-2000:1.3
	v20070221-1500:1.3
	v20070208-1800:1.3
	M4_20:1.3
	v20061222-1800:1.3
	v20061214-0000:1.3
	v20061120-1300:1.3
	M3_20:1.3
	v20061117-0800:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.5
date	2007.06.21.14.13.37;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	1e3f467a878e4567;

1.4
date	2007.03.19.16.49.09;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	5cce45febf044567;

1.3
date	2006.11.15.18.33.28;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	7487455b5d774567;

1.2
date	2006.11.15.15.13.24;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	6bc4455b2e934567;

1.1
date	2006.11.15.13.26.46;	author atikhomirov;	state Exp;
branches;
next	;
commitid	5f78455b15954567;


desc
@@


1.5
log
@fix copyright years
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Fedorov (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - members' visibility/access
 */
package org.eclipse.gmf.internal.common.codegen;

import java.io.IOException;
import java.io.StringReader;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;

import org.eclipse.gmf.internal.common.Activator;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/*
 * Please do not blame anyone for the implementation, it will be changed soon
 * FIXME rewrite with SAX/DOM and separate post-processing formatter
 */
public class PluginXMLTextMerger {
	
	private static final String ATTR_POINT = "point"; //$NON-NLS-1$

	private static final String ELEM_EXTENSION = "extension"; //$NON-NLS-1$
	private static final String ELEM_EXTENSION_START = "<" + ELEM_EXTENSION; //$NON-NLS-1$
	private static final String ELEM_EXTENSION_END = "</" + ELEM_EXTENSION + ">"; //$NON-NLS-1$ //$NON-NLS-2$

	private static final String ELEM_PLUGIN = "plugin"; //$NON-NLS-1$
	private static final String ELEM_PLUGIN_END = "</" + ELEM_PLUGIN + ">"; //$NON-NLS-1$ //$NON-NLS-2$

	private static final String COMMENT_START = "<!--"; //$NON-NLS-1$
	private static final String COMMENT_END = "-->"; //$NON-NLS-1$
	
//	private final String myPITarget;
//	private final String myPIAttrName;
//	private final String myPIAttrValue;
	private final String myPITag;

	private SAXParserFactory factory;

	public PluginXMLTextMerger(String piTarget, String piAttrName, String piAttrValue) {
//		this.myPITarget = piTarget;
//		this.myPIAttrName = piAttrName;
//		myPIAttrValue = piAttrValue;
		this.myPITag = MessageFormat.format("<?{0} {1}=\"{2}\"?>", piTarget, piAttrName, piAttrValue); //$NON-NLS-1$
	}

	public boolean isRecognizedDocument(String xml) {
		try {
			final ParsedPluginXML doc = parseDocument(xml);
			return doc != null && doc.getExtensionsStart() > 0 & doc.getExtensionsEnd() >= doc.getExtensionsStart();
		} catch (Exception ex) {
			return false;
		}
	}

	public String process(String oldXML, String newXML) {
		ParsedPluginXML newDoc;
		try {
			newDoc = parseDocument(newXML);
		} catch (Exception e) {
			logException("Generated plugin.xml is invalid. Existing plugin.xml will be kept", e); //$NON-NLS-1$
			return oldXML;
		}
		ParsedPluginXML oldDoc;
		try {
			oldDoc = parseDocument(oldXML);
		} catch (Exception e) {
			logException("Existing plugin.xml is invalid and will be replaced with generated one", e); //$NON-NLS-1$
			return newXML;
		}
		String result = mergeDocuments(oldDoc, newDoc);
		try {
			parseDocument(result);
		} catch (Exception e) {
			logException("Merged plugin.xml is invalid and will be replaced with generated one", e); //$NON-NLS-1$
			return newXML;
		}
		return result;
	}

	private ParsedPluginXML parseDocument(String xml) throws SAXException, ParserConfigurationException, IOException {
		ParsedPluginXML pluginXML = new ParsedPluginXML(xml, myPITag);
		InputSource is = new InputSource(new StringReader(xml));
		getParserFactory().newSAXParser().parse(is, pluginXML);
        return pluginXML;
	}

	private SAXParserFactory getParserFactory() {
		if (factory == null) {
			factory = SAXParserFactory.newInstance();
		}
		return factory;
	}

	private String mergeDocuments(ParsedPluginXML oldDoc, ParsedPluginXML newDoc) {
		StringBuilder result = new StringBuilder();
		int currentPosition = oldDoc.getExtensionsStart() - 1;
		final String oldXML = oldDoc.getXML();
		result.append(oldXML.substring(0, currentPosition));
		final int length = oldXML.length();
		while (currentPosition < length) {
			int key = currentPosition;
			ExtensionDescriptor oldED = oldDoc.getExtensionByStart(key);
			if (oldED == null) {
				result.append(oldXML.charAt(currentPosition));
				currentPosition++;
			} else {
				List<ExtensionDescriptor> newEDs = newDoc.getExtensionsByPoint(oldED.pointName);
				if (oldED.generated) {
					if (newEDs == null) {
						//delete
						currentPosition = oldED.endLine;
						oldED.remove();
					} else {
						//replace
						ExtensionDescriptor newED = newEDs.get(0);
						result.append(newED.getText());
						currentPosition = oldED.endLine;
						oldED.remove();
						newED.remove();
					}
				} else {
					//keep
					result.append(oldED.getText());
					currentPosition += oldED.getTextLength();
					oldED.remove();
					if (newEDs != null && !oldDoc.hasGeneratedExtension(oldED.pointName)) {
						ExtensionDescriptor newED = newEDs.get(0);
						newED.remove();
					}
				}
			}
			if (oldDoc.getExtensions().isEmpty()  && !newDoc.getExtensions().isEmpty()) {
				boolean sameStartEnd = oldDoc.getExtensionsStart() == oldDoc.getExtensionsEnd();
				boolean afterStart = currentPosition >= oldDoc.getExtensionsStart(); 
				if (afterStart && (sameStartEnd || currentPosition < oldDoc.getExtensionsEnd())) {
					for (ExtensionDescriptor newED : newDoc.getExtensions()) {
						result.append(newED.getText());
						newED.remove();
						result.append(getPlatformNewLine());
					}
				}
			}
		}
		
		return result.toString();
	}

	protected void logException(String message, Exception e) {
		Activator.logError(message, e);
	}
	
	private static String getPlatformNewLine() {
		return System.getProperties().getProperty("line.separator"); //$NON-NLS-1$
	}

	private static class ParsedPluginXML extends DefaultHandler {
		private final String myXML;
		private String myGeneratedToken;
		private int myPluginEnd;
		
		private final Map<String, List<ExtensionDescriptor>> myPoint2ExtensionsMap;
		private final SortedMap<Integer, ExtensionDescriptor> myStart2ExtensionMap;
		private Iterator<ExtensionDescriptor> myIterator;
		private final int myCachedExtStart;
		
		ParsedPluginXML(String xml, String generatedToken) {
			this.myXML = xml;
			this.myGeneratedToken = generatedToken;
			this.myPoint2ExtensionsMap = new HashMap<String, List<ExtensionDescriptor>>();
			this.myStart2ExtensionMap = new TreeMap<Integer, ExtensionDescriptor>();
			parse(xml);
			myCachedExtStart  = myStart2ExtensionMap.size() > 0 ? myStart2ExtensionMap.firstKey() : myPluginEnd;
		}

		private void parse(String xml) {
			int currentIndex = 0;
			final int length = xml.length();
			this.myPluginEnd = xml.lastIndexOf(ELEM_PLUGIN_END);
			while (currentIndex < length) {
				int extensionStart = getStartIndex(xml, ELEM_EXTENSION_START, currentIndex);
				if (extensionStart == length - 1) {
					break;
				}
				if (isInsideComment(xml, extensionStart)) {
					currentIndex = extensionStart + ELEM_EXTENSION_START.length();
					continue;
				}
				if (!Character.isWhitespace(xml.charAt(extensionStart + ELEM_EXTENSION_START.length()))) {
					// e.g. "<extension-point"
					currentIndex = extensionStart + ELEM_EXTENSION_START.length();
					continue;
				}
				currentIndex = processExtensonBlock(xml, extensionStart);
			}
		}
		
		private int processExtensonBlock(String xml, int fromIndex) {
			int extensionStart = fromIndex;
			int extensionEnd = getStartIndex(xml, ELEM_EXTENSION_END, fromIndex) + ELEM_EXTENSION_END.length();
			while (isInsideComment(xml, extensionEnd)) {
				extensionEnd = getStartIndex(xml, ELEM_EXTENSION_END, extensionEnd) + ELEM_EXTENSION_END.length();
			}
			boolean isGenerated = isGenerated(xml, extensionStart, extensionEnd);
			ExtensionDescriptor ed = new ExtensionDescriptor(this, extensionStart, extensionEnd, isGenerated);
			myStart2ExtensionMap.put(ed.startLine, ed);
			return extensionEnd;
		}
		
		private boolean isGenerated(String xml, int extensionStart, int extensionEnd) {
			int genStart = getStartIndex(xml, myGeneratedToken, extensionStart);
			while (genStart < extensionEnd) {
				if (!isInsideComment(xml, genStart)) {
					return true;
				}
				genStart = getStartIndex(xml, myGeneratedToken, genStart + myGeneratedToken.length());
			}
			return false;
		}

		private int getStartIndex(String xml, String token, int fromIndex) {
			int commentStart = xml.indexOf(token, fromIndex);
			return (commentStart < 0) ? xml.length()-1 : commentStart;
		}
		
		private boolean isInsideComment(String xml, int fromIndex) {
			int lastOpened = xml.lastIndexOf(COMMENT_START, fromIndex);
			if (lastOpened < 0) {
				return false;
			}
			int lastClosed = xml.lastIndexOf(COMMENT_END, fromIndex);
			if (lastClosed > lastOpened && lastClosed < fromIndex) {
				return false;
			}
			return true;
		}
		
		List<ExtensionDescriptor> getExtensionsByPoint(String point) {
			List<ExtensionDescriptor> list = myPoint2ExtensionsMap.get(point);
			return list;
		}
		
		ExtensionDescriptor getExtensionByStart(int start) {
			return myStart2ExtensionMap.get(start);
		}

		void removeExtension(ExtensionDescriptor ed) {
			myStart2ExtensionMap.remove(ed.startLine);
			List<ExtensionDescriptor> list = getExtensionsByPoint(ed.pointName);
			if (list != null) {
				list.remove(ed);
				if (list.size() == 0) {
					myPoint2ExtensionsMap.remove(ed.pointName);
				}
			}
		}

		boolean hasGeneratedExtension(String point) {
			List<ExtensionDescriptor> list = getExtensionsByPoint(point);
			if (list != null && list.size() > 0) {
				for (ExtensionDescriptor ed : list) {
					if (ed.generated) {
						return true;
					}
				}
			}
			return false;
		}

		List<ExtensionDescriptor> getExtensions() {
			return new ArrayList<ExtensionDescriptor>(myStart2ExtensionMap.values());
		}
		
		int getExtensionsStart() {
			if (myStart2ExtensionMap.size() > 0) {
				return myStart2ExtensionMap.firstKey();
			}
			return myCachedExtStart;
		}

		int getExtensionsEnd() {
			if (myStart2ExtensionMap.size() > 0) {
				ExtensionDescriptor ed = myStart2ExtensionMap.get(myStart2ExtensionMap.lastKey());
				return ed.endLine;
			}
			return myPluginEnd;
		}
		
		String getXML() {
			return this.myXML;
		}

		@@Override
		public void startDocument() throws SAXException {
			myIterator = myStart2ExtensionMap.values().iterator();
		}

		@@Override
		public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
			if (ELEM_EXTENSION.equals(qName)) {
				String pointName = attributes.getValue(ATTR_POINT);
				if (pointName != null) {
					if (myIterator != null && myIterator.hasNext()) {
						ExtensionDescriptor ed = myIterator.next();
						ed.pointName = pointName;
						List<ExtensionDescriptor> list = getExtensionsByPoint(ed.pointName);
						if (list == null) {
							list = new ArrayList<ExtensionDescriptor>();
							myPoint2ExtensionsMap.put(ed.pointName, list);
						}
						list.add(ed);
					}
				}
			}
		}

		@@Override
		public void endDocument() throws SAXException {
			myIterator = null;
		}

	}
	
	private static class ExtensionDescriptor {
		private final ParsedPluginXML parsedDoc;
		String pointName;
		final boolean generated;
		private final int startLine;
		private final int endLine;
		
		ExtensionDescriptor(ParsedPluginXML parsedPluginXml, int start, int end, boolean isGenerated) {
			parsedDoc = parsedPluginXml;
			startLine = start;
			endLine = end;
			generated = isGenerated;
		}

		String getText() {
			return parsedDoc.getXML().substring(startLine, endLine);
		}
		int getTextLength() {
			return endLine - startLine;
		}
		void remove() {
			parsedDoc.removeExtension(this);
		}
	}
}
@


1.4
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.3
log
@update test for merge service
@
text
@d157 1
a157 3
					List<ExtensionDescriptor> newEDs = newDoc.getExtensions();
					for (Iterator iter = newEDs.iterator(); iter.hasNext();) {
						ExtensionDescriptor newED = (ExtensionDescriptor) iter.next();
d281 1
a281 2
				for (Iterator iter = list.iterator(); iter.hasNext();) {
					ExtensionDescriptor ed = (ExtensionDescriptor) iter.next();
@


1.2
log
@turn plugin.xml merging on, preceding mechanism of protected regions removed
@
text
@d69 2
a70 1
			return parseDocument(xml) != null;
@


1.1
log
@[139738] afedorov - code merging for plugin.xml
@
text
@d66 9
a74 1
	
@

