head	1.17;
access;
symbols
	v20081015-1925:1.17
	v20080930-1130:1.17
	v20080926-1245:1.17
	v20080924-1925:1.17
	v20080722-1827:1.17
	v20080716-1642:1.17
	R2_1_maintenance:1.17.0.2
	Root_R2_1_maintenance:1.17
	R2_1_0:1.17
	v20080610-1132:1.17
	v20080521:1.17
	v20080516-1143:1.16
	v20080508-2000:1.15
	v20080417-1610:1.15
	v20080322-0000:1.15
	v20080222-1200:1.15
	v20071108-0000:1.15
	v20070903-0000:1.15
	v20070809-0000:1.15
	R2_0_maintenance:1.15.0.2
	R2_0:1.15
	R4_20:1.15
	v20070621-0000:1.15
	RC3_20:1.15
	v20070605-1400:1.15
	v20070601-1400:1.14
	v20070525-1500:1.14
	v20070520-1200:1.12
	v20070518-1300:1.10
	v20070427-0600:1.9
	v20070420-1000:1.9
	v20070413-1300:1.9
	v20070405-1100:1.9
	v20070330-1300:1.9
	v20060330-1300:1.9
	v20070322-1100:1.9
	v20070307-0700:1.8
	v20070301-1200:1.8
	v20070228-2000:1.8
	v20070221-1500:1.8
	v20070208-1800:1.8
	M4_20:1.8
	v20061222-1800:1.8
	v20061214-0000:1.8
	v20061120-1300:1.8
	M3_20:1.7
	v20061117-0800:1.7
	v20061013-1330:1.4
	M1_20:1.2
	v20060904-1500:1.2;
locks; strict;
comment	@# @;


1.17
date	2008.05.19.21.52.28;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	1c3b4831f69b4567;

1.16
date	2008.05.15.12.54.59;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	7abf482c32a24567;

1.15
date	2007.06.04.18.10.00;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	1d28466455784567;

1.14
date	2007.05.24.09.34.42;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	4f9546555c314567;

1.13
date	2007.05.22.17.38.30;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	14d646532a964567;

1.12
date	2007.05.18.22.42.56;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	1943464e2bf04567;

1.11
date	2007.05.18.20.39.13;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	58f6464e0ef14567;

1.10
date	2007.05.10.13.55.22;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	14b9464324494567;

1.9
date	2007.03.19.16.49.09;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	5cce45febf044567;

1.8
date	2006.11.17.16.52.21;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	43bf455de8c44567;

1.7
date	2006.10.20.16.22.22;	author dstadnik;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.18.14.21.15;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.17.15.49.17;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.21.13.16.00;	author radvorak;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.14.17.52.38;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.04.09.35.18;	author radvorak;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.29.17.46.28;	author radvorak;	state Exp;
branches;
next	;


desc
@@


1.17
log
@[232299] refactor migration utils: gmfgraph migration done usign dynamic package for old metamodel, unused logic from MigrationHelper and MigrationDelegate was removed
@
text
@/*
 * Copyright (c) 2006, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors: 
 *           Borland - initial API and implementation
 */
package org.eclipse.gmf.internal.common.migrate;

import java.io.IOException;
import java.io.InputStream;
import java.util.Map;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.xmi.XMLHelper;
import org.eclipse.gmf.internal.common.ToolingResourceFactory.ToolResource;

public abstract class MigrationResource extends ToolResource {

	private MigrationHelper myMigrationHelper;

	protected MigrationResource(URI uri) {
		super(uri);
	}

	@@Override
	public final void doLoad(InputStream inputStream, Map<?,?> options) throws IOException {
		try {
			super.doLoad(inputStream, options);
			handlePostLoadSuccess();
		} catch (IOException e) {
			handlePostLoadException(e);
			throw e;
		} catch (RuntimeException e) {
			handlePostLoadException(e);
			throw e;
		}
	}

	protected void handlePostLoadSuccess() {
		if (myMigrationHelper == null) {
			return;
		}
		if (myMigrationHelper.isMigrationApplied()) {
			Diagnostic diagnostic = MigrationResource.createMessageDiagnostic(this, Messages.oldModelVersionLoadedMigrationRequired);
			getWarnings().add(0, diagnostic);
		}
	}

	protected void handlePostLoadException(Exception e) {
		if (myMigrationHelper == null) {
			return;
		}
		if (myMigrationHelper.isMigrationApplied()) {
			Diagnostic diagnostic = MigrationResource.createMessageDiagnostic(this, Messages.oldModelVersionLoadErrorMigrationMayBeRequired);
			getErrors().add(0, diagnostic);
		}
	}

	@@Override
	protected XMLHelper createXMLHelper() {
		MigrationDelegate delegate = createDelegate();
		assert delegate != null;
		myMigrationHelper = new MigrationHelper(this, delegate);
		return myMigrationHelper;
	}

	protected abstract MigrationDelegate createDelegate();

	/**
	 * Creates resource diagnostic wrapping the given message.
	 * @@param resource the resource associated with the created diagnostic
	 * @@param message non-<code>null</code> message text to be wrapped as diagnostic
	 * 
	 * @@return diagnostic object
	 */
	public static Diagnostic createMessageDiagnostic(Resource resource, final String message) {
		final String location = resource.getURI() == null ? null : resource.getURI().toString();
		return new Diagnostic(message, location);
	}

	/**
	 * Just a marker for diagnostic notification messages
	 */
	public static class Diagnostic implements Resource.Diagnostic {
		private final String myMessage;
		private final String myLocation;

		Diagnostic(String message, String  location) {
			myMessage = message;
			myLocation = location;
		}

		public String getMessage() {
			return myMessage;
		}		

		public String getLocation() {
			return myLocation;
		}

		public int getColumn() {
			return 0;
		}

		public int getLine() {
			return 0;
		}
	}
}
@


1.16
log
@[228913] bring back tests for old migrations, with fixes.
@
text
@a48 1
		myMigrationHelper.postLoad();
a58 1
		myMigrationHelper.postLoad();
@


1.15
log
@[189703] akarjakina - migration for gmfgraph, handle figure accessors
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 Borland Software Corporation
d84 1
a84 1
	private static Diagnostic createMessageDiagnostic(Resource resource, final String message) {
@


1.14
log
@[188768] akarjakina - Migration should not rely solely on nsURIs;
MIgrationHelperDelegate was renamed to MigrationDelegate
@
text
@d46 5
a50 1
		if (myMigrationHelper != null && myMigrationHelper.isMigrationApplied()) {
d57 5
a61 1
		if (myMigrationHelper != null && myMigrationHelper.isMigrationApplied()) {
@


1.13
log
@[187811] akarjakina - migrating gmf 1.0 models to 2.0, refactoring, tests
@
text
@d46 1
a46 1
		if (myMigrationHelper != null && myMigrationHelper.isEnabled()) {
d53 4
a56 2
		Diagnostic diagnostic = MigrationResource.createMessageDiagnostic(this, Messages.oldModelVersionLoadErrorMigrationMayBeRequired);
		getErrors().add(0, diagnostic);
d61 1
a61 1
		MigrationHelperDelegate delegate = createDelegate();
d67 1
a67 1
	protected abstract MigrationHelperDelegate createDelegate();
@


1.12
log
@do not process up-to-date versions of the model, consult delegate only when old version was detected
@
text
@a15 1
import java.util.Collection;
a18 1
import org.eclipse.emf.ecore.EPackage;
a20 3
import org.eclipse.emf.ecore.xmi.XMLLoad;
import org.eclipse.emf.ecore.xmi.impl.SAXXMIHandler;
import org.eclipse.emf.ecore.xmi.impl.XMILoadImpl;
a21 1
import org.xml.sax.helpers.DefaultHandler;
a24 1
	private boolean isOldVersionDetected;
a33 1
			isOldVersionDetected = false;
a44 28
	@@Override
	protected XMLLoad createXMLLoad() {
		return new XMILoadImpl(createXMLHelper()) {

			@@Override
			protected DefaultHandler makeDefaultHandler() {
				return new SAXXMIHandler(resource, helper, options) {
					@@Override
					protected EPackage getPackageForURI(String uriString) {
						// FIXME move the check to delegate
						if (!getMetamodelNsURI().equals(uriString) && getBackwardSupportedURIs().contains(uriString)) {
							handleOldVersionDetected();
							return super.getPackageForURI(getMetamodelNsURI());
						}
						return super.getPackageForURI(uriString);
					}
				};
			}
		};
	}

	private void handleOldVersionDetected() {
		if (myMigrationHelper != null) {
			myMigrationHelper.enableDelegate(true);
		}
		isOldVersionDetected = true;
	}

d46 1
a46 1
		if (isOldVersionDetected) {
a64 1
	protected abstract Collection<String> getBackwardSupportedURIs();
a65 1
	protected abstract String getMetamodelNsURI();
a66 1
	
@


1.11
log
@[187811] akarjakina - Migration support refactored
@
text
@d32 1
d75 3
d97 2
a98 1
		return new MigrationHelper(this, delegate);
@


1.10
log
@[185372] akarjakina - Migration of gmfgen 1.0 models with GenAuditContainer and GenAuditRule structures
@
text
@d9 2
a10 1
 * Contributors: Radek Dvorak (Borland) - initial API and implementation
d16 1
a16 1
import java.util.HashMap;
a19 2
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
a20 2
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
d29 3
a31 15
/**
 * This resource implementation is intended to handle loading of old (incompatible) versions 
 * of tooling models.
 * <p>
 * This class makes use of {@@link MigrationConfig.Registry#INSTANCE} end performs load-time migration 
 * in case that there is a migration config registered for the resource to load.
 * 
 * @@see MigrationConfig
 */
public class MigrationResource extends ToolResource {
	
	protected boolean oldVersionDetected;
	protected boolean migrationApplied;
	private Map<EObject, Map<String, String>> ignoredAttributes;
	private MigrationConfig config;
d33 1
a33 1
	MigrationResource(URI uri) {
d37 1
a37 22
	/*
	 * Create XMLLoad which handles old model migration at load-time 
	 * @@see org.eclipse.emf.ecore.xmi.impl.XMIResourceImpl#createXMLLoad()
	 */
	protected XMLLoad createXMLLoad() {
		return new XMILoadImpl(createXMLHelper()) {

			protected DefaultHandler makeDefaultHandler() {
				return new MigrationHandler(MigrationResource.this, helper, options);			
			}
		};
	}

	protected final void doUnload() {
		try {
			super.doUnload();
		} finally {
			this.oldVersionDetected = false;
			this.migrationApplied = false;
		}
	}

d40 1
a40 1
			ignoredAttributes = new HashMap<EObject, Map<String, String>>();
d42 1
a42 1
			handlePostLoad(null);			
d44 1
a44 1
			handlePostLoad(e);
d47 1
a47 1
			handlePostLoad(e);
a48 3
		} finally {
			ignoredAttributes = null;
			config = null;
d52 3
a54 6
	/**
	 * Called back if nsURI of old version is recognized during resource load.  
	 */
	protected void handleOldVersionDetected() {
		this.oldVersionDetected = true;
	}
d56 11
a66 34
	/**
	 * Called back at load-time in case an incompatible model construct required migration.  
	 */	
	protected void handleMigrationPatchApplied() {
		this.migrationApplied = true;
	}
	
	/**
	 * Called back after resource load finished.
	 * @@param exception the exception thrown during {@@link #doLoad(InputStream, Map)} or
	 * 		<code>null</code> in case of load success.
	 */
	protected void handlePostLoad(Exception exception) {
		if (exception == null && config != null) {
			config.handleResourceLoaded(this, ignoredAttributes);
		}
	}

	/**
	 * Creates resource which checks for and reports incompatible model version
	 * in case that resource load fails.
	 * 
	 * @@param uri the resource uri
	 * 
	 * @@return resource object in unloaded state
	 */
	static Resource createCheckedResource(URI uri) {
		return new MigrationResource(uri) {
			
			protected XMLLoad createXMLLoad() {	
				final MigrationResource res = this;					
				return new XMILoadImpl(createXMLHelper()) {
					protected DefaultHandler makeDefaultHandler() {
						return new BCKWDCompatibleHandler(res, helper, options);			
a69 11
			
			protected void handlePostLoad(Exception exception) {
				super.handlePostLoad(exception);
				// if old model version is loaded, check if any problems during resource load have occured
				// if yes, report an old version load attempt
				// otherwise, the resource happens to have no incompatible contents
				if(oldVersionDetected && exception != null || !getErrors().isEmpty() || !getWarnings().isEmpty()) {
					Diagnostic diagnostic = MigrationUtil.createMessageDiagnostic(this, Messages.oldModelVersionLoadErrorMigrationMayBeRequired);
					getErrors().add(0, diagnostic);
				}
			}
a71 19
	
	/**
	 * Creates resource which performs only in-memory migration of old model versions at load-time
	 * and reports migration diagnostic.
	 *  
	 * @@param uri the resource uri 
	 * @@return resource object in unloaded state
	 */	
	static Resource createCheckAndMigrateOnLoadResource(URI uri) {
		return new MigrationResource(uri) {
			protected void handlePostLoad(Exception exception) {
				super.handlePostLoad(exception);
				if(this.oldVersionDetected && migrationApplied) {
					Diagnostic diagnostic = MigrationUtil.createMessageDiagnostic(this, Messages.oldModelVersionLoadedMigrationRequired);
					getWarnings().add(0, diagnostic);
				}
			}
		};
	}	
d73 3
a75 6
	/**
	 * Handles detection of loaded model nsURI and checks if an old model version is to be loaded.
	 */
	private static class BCKWDCompatibleHandler extends SAXXMIHandler {
		MigrationConfig config;
		protected boolean fixmePotentiallyCompatibilityIssues;
d77 4
a80 2
		BCKWDCompatibleHandler(MigrationResource xmiResource, XMLHelper helper, Map<?, ?> options) {
			super(xmiResource, helper, options);
d82 6
d89 6
a94 31
		/*
		 * Detects if and old version of model is to be loaded
		 */
		@@Override		
		protected EPackage getPackageForURI(String uriString) {
			if(config == null) {
				// Remark: ensure that GMF meta-models generated packages are initialized before accessing 
				// 	MigrationConfig.Registry, as a migrated package initialization code performs the migration config 
				// 	registration.
				//	TODO - better to use extension point for migration config registry     
				EPackage.Registry.INSTANCE.getEPackage(uriString);
				
				String ext = xmlResource.getURI().fileExtension();
				config = (ext != null) ? MigrationConfig.Registry.INSTANCE.getConfig(ext) : null;
				resource().config = config;
			}
			
			if(config != null) {
				if(!config.getMetamodelNsURI().equals(uriString) && 
					config.backwardSupportedNsURIs().contains(uriString)) {					
					resource().handleOldVersionDetected();
					
					return super.getPackageForURI(config.getMetamodelNsURI());
				}
				if (config.getMetamodelNsURI().equals(uriString)) {
					// assume new version always needs migration, at least between milestones
					// FIXME better detection algorithm
					// FIXME delete this code after genmodel freeze in 2.0
					fixmePotentiallyCompatibilityIssues = true;
				}
			}
d96 3
a98 2
			return super.getPackageForURI(uriString);
		}
a99 15
		@@Override
		protected void handleUnknownFeature(String prefix, String name, boolean isElement, EObject peekObject, String value) {
			if (fixmePotentiallyCompatibilityIssues) {
				if (config.shouldIgnoreAttribute(peekObject, name)) {
					resource().handleOldVersionDetected();
				}
			}
			super.handleUnknownFeature(prefix, name, isElement, peekObject, value);
		}
		
		MigrationResource resource() {
			assert xmlResource instanceof MigrationResource;
			return (MigrationResource)xmlResource;			
		}
	};	
d102 5
a106 1
	 * Handler performing migration changes at load-time 
d108 4
a111 1
	public static class MigrationHandler extends BCKWDCompatibleHandler {
d113 6
a118 30
		private FeatureKey processedFeatureKey;
		
		MigrationHandler(MigrationResource resource, XMLHelper helper, Map<?, ?> options) {
			super(resource, helper, options);
			this.processedFeatureKey = new FeatureKey();
		}

		@@Override
		protected void setAttribValue(EObject object, String name, String value) {
			if ((isMigrationEnabled() || fixmePotentiallyCompatibilityIssues)) {
				if (config.setAttribValue(this, object, name, value)) {
					notifyMigrationApplied();
					return;
				}
				if (config.shouldIgnoreAttribute(object, name)) {
					Map<EObject, Map<String, String>> ignoredAttributes = resource().ignoredAttributes;
					if (ignoredAttributes != null) {
						Map<String, String> attrs = ignoredAttributes.get(object);
						if (attrs == null) {
							attrs = new HashMap<String, String>();
							ignoredAttributes.put(object, attrs);
						}
						attrs.put(name, value);
					}
					notifyMigrationApplied(); // notify we had to migrate
					return; // do not try to set value 
				}
			}
			super.setAttribValue(object, name, value);
		}
d120 3
a122 23
		@@Override
		protected void createObject(EObject peekObject, EStructuralFeature feature) {
			if(isMigrationEnabled()) {
				if (config.handleCreateObject(this, peekObject, feature)) {
					notifyMigrationApplied();
					return;
				}
				processedFeatureKey.setFeature(feature);
				if(getXSIType() == null && feature instanceof EReference) { 			
					// adding xsi/xmi:type
					// @@see https://bugs.eclipse.org/bugs/show_bug.cgi?id=154712
					EClass oldDefaultRefType = (config != null) ? config.getAddedTypeInfo(processedFeatureKey) : null;
	
					if(oldDefaultRefType != null) {
						String typeQName = helper.getQName(oldDefaultRefType);
						super.createObjectFromTypeName(peekObject, typeQName, feature);
						// notify resource that a migration was neccessary 
						notifyMigrationApplied();
						return;
					}
				}
			} // end of migration
			super.createObject(peekObject, feature);								
d125 3
a127 17
		@@Override
		protected void handleFeature(String prefix, String name) {
			if (isMigrationEnabled()) {
				if (config.handleFeature(this, prefix, name)) {
					notifyMigrationApplied();
					return;
				}
			}
			super.handleFeature(prefix, name);
		}
		
		/**
		 * Make public for access from config.
		 */
		public EObject createObjectFromTypeNameHook(EObject peekObject, String typeQName, EStructuralFeature feature) {
			return super.createObjectFromTypeName(peekObject, typeQName, feature);
		}
d129 2
a130 5
		/**
		 * Make public for access from config.
		 */
		public void handleFeatureHook(String prefix, String name) {
			super.handleFeature(prefix, name);
d133 2
a134 5
		/**
		 * Make public for access from config.
		 */
		public String getXSIType() {
			return super.getXSIType();
d137 2
a138 20
		/**
		 * Make public for access from config.
		 */
		public EObject peekEObject() {
			return objects.peekEObject();
		}

		private boolean isMigrationEnabled() {
			return config != null && resource().oldVersionDetected;
		}
		
		/**
		 * To be called if a migration patch had to be applied to load model successfully.
		 * <p>
		 * Note: It's important in order to detect whether an old model version which 
		 * was loaded contained incompatible constructs. No diagnostics are produced
		 * for old version models with compatible contents.
		 */
		private void notifyMigrationApplied() {
			resource().handleMigrationPatchApplied();
a140 1
	
@


1.9
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
d244 14
a257 7
			if ((isMigrationEnabled() || fixmePotentiallyCompatibilityIssues) && config.shouldIgnoreAttribute(object, name)) {
				Map<EObject, Map<String, String>> ignoredAttributes = resource().ignoredAttributes;
				if (ignoredAttributes != null) {
					Map<String, String> attrs = ignoredAttributes.get(object);
					if (attrs == null) {
						attrs = new HashMap<String, String>();
						ignoredAttributes.put(object, attrs);
d259 2
a260 1
					attrs.put(name, value);
a261 2
				notifyMigrationApplied(); // notify we had to migrate
				return; // do not try to set value 
d301 1
a301 1

d345 1
@


1.8
log
@removed stale attributes from gmfgen model.
migration resource eagerly treats any resource with newest nsURI as potential candidate for missed attributes
@
text
@d74 1
a74 1
	public final void doLoad(InputStream inputStream, Map options) throws IOException {
d110 1
a110 1
	protected void handlePostLoad(@@SuppressWarnings("unused")Exception exception) {
a135 1
			@@SuppressWarnings("unchecked")
a157 1
			@@SuppressWarnings("unchecked")
d175 1
a175 1
		BCKWDCompatibleHandler(MigrationResource xmiResource, XMLHelper helper, Map options) {
d237 1
a237 1
		MigrationHandler(MigrationResource resource, XMLHelper helper, Map options) {
@


1.7
log
@rename method that handles loaded resource
@
text
@d175 1
d205 6
d215 10
d246 1
a246 1
			if (isMigrationEnabled() && config.shouldIgnoreAttribute(object, name)) {
@


1.6
log
@#161380 simplify feature model facets
@
text
@d112 1
a112 1
			config.handleIgnoredAttributes(this, ignoredAttributes);
@


1.5
log
@#160894 support readOnly attribute migration
@
text
@d41 1
a41 1
class MigrationResource extends ToolResource {
d218 1
a218 1
	private static class MigrationHandler extends BCKWDCompatibleHandler {
d248 4
a252 1
				
a266 1
			
d270 39
@


1.4
log
@#157836 Feature-based model migration patches should NOT use object identity equals() on metamodel
@
text
@d15 1
d45 3
a47 1
		
d58 1
d64 1
a64 1
		
d73 1
a73 1
	
d76 1
d85 4
a88 1
		}		
d90 1
a90 1
	
d110 4
a113 2
	protected void handlePostLoad(@@SuppressWarnings("unused")Exception exception) { 
		// do nothing here
d115 1
a115 1
	
d194 1
d219 1
d226 1
a226 1
		
d230 9
d267 1
a267 1
		
@


1.3
log
@migration utils updated to support clean processing of attributes removed from metamodel
@
text
@d102 1
a102 2
	protected void handlePostLoad(Exception exception) {
		assert exception == exception; // get rid of unused param warn 
d142 1
d164 1
a164 2
		final MigrationConfig config;
		boolean oldVersionDetected = false;
a167 2
			String ext = xmiResource.getURI().fileExtension();
			config = (ext != null) ? MigrationConfig.Registry.INSTANCE.getConfig(ext) : null;
a171 1
		 * @@see org.eclipse.emf.ecore.xmi.impl.XMLHandler#getPackageForURI(java.lang.String)
d173 1
d175 11
a188 1
					this.oldVersionDetected = true;
d208 1
d212 1
d214 1
a214 1

d218 1
d227 2
d232 1
a232 2
					EReference referenceFeature = ((EReference)feature);
					EClass oldDefaultRefType = (config != null) ? config.getAddedTypeInfo(referenceFeature) : null;
d238 1
a238 1
						resource().handleMigrationPatchApplied();
d248 12
a259 1
			return config != null && oldVersionDetected;
@


1.2
log
@Get rid of Java 5 type-safety warnings
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
d205 10
a214 1
				
@


1.1
log
@#154698 Support migration of GMF tooling models in case of backward incomatible changes
@
text
@d127 1
d149 1
@

