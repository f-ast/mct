head	1.11;
access;
symbols
	v20081015-1925:1.11
	v20080930-1130:1.10
	v20080926-1245:1.10
	v20080924-1925:1.10
	v20080722-1827:1.10
	v20080716-1642:1.10
	R2_1_maintenance:1.9.0.4
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080610-1132:1.9
	v20080521:1.9
	v20080516-1143:1.9
	v20080508-2000:1.9
	v20080417-1610:1.9
	v20080322-0000:1.9
	v20080222-1200:1.9
	v20071108-0000:1.9
	v20070903-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	v20070621-0000:1.9
	RC3_20:1.9
	v20070605-1400:1.9
	v20070601-1400:1.9
	v20070525-1500:1.9
	v20070520-1200:1.9
	v20070518-1300:1.9
	v20070427-0600:1.9
	v20070420-1000:1.9
	v20070413-1300:1.9
	v20070405-1100:1.9
	v20070330-1300:1.8
	v20060330-1300:1.8
	v20070322-1100:1.8
	v20070307-0700:1.6
	v20070301-1200:1.6
	v20070228-2000:1.6
	v20070221-1500:1.6
	v20070208-1800:1.6
	M4_20:1.6
	v20061222-1800:1.6
	v20061214-0000:1.6
	v20061120-1300:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061013-1330:1.6
	v20060925-1700:1.5
	v20060919-0800:1.5
	M1_20:1.5
	v20060904-1500:1.5
	v20060713-1700:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	v20060627-1200:1.5
	v20060626-1420:1.5
	v20060616-1200:1.5
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060530-1930:1.2
	v20060526-1200:1.2
	v20060519-1300:1.2
	v20060519-0800:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2008.10.14.18.04.23;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	4ebb48f4df274567;

1.10
date	2008.06.27.16.19.42;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	70544865131e4567;

1.9
date	2007.04.04.17.40.06;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	41784613e2f64567;

1.8
date	2007.03.20.17.51.59;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	610746001f3f4567;

1.7
date	2007.03.19.16.49.09;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	5cce45febf044567;

1.6
date	2006.09.04.18.10.53;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.14.12.14.00;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.13.17.25.23;	author mfeldman;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.13.11.17.02;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.15.15.16.59;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.13.12.02.47;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.11
log
@refactoring - odd if condition eliminated
@
text
@/*
 * Copyright (c) 2006, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Michael Golubev (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.common.reconcile;

import java.text.MessageFormat;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;

public class ReconcilerConfigBase implements ReconcilerConfig {
	private static final EClassRecord EMPTY_RECORD = new EClassRecord();
	private final HashMap<EClass, EClassRecord> myEClass2Record;
	private final HashMap<EClass, EClassRecord> myAbstractEClass2SubclassesRecord;
	
	public ReconcilerConfigBase(){
		myEClass2Record = new HashMap<EClass, EClassRecord>();
		myAbstractEClass2SubclassesRecord = new HashMap<EClass, EClassRecord>();
	}
	
	public final Matcher getMatcher(EClass eClass) {
		Matcher result = getRecord(eClass, false).getMatcher();
		if (result != Matcher.FALSE) {
			return result;
		}
		// XXX Correct strategy whould be to look up first *non-default*
		// matcher in the hierarchy, however, for now, expect no more that
		// two records per hierarchy chain (e.g. a nondefault matcher for superclass
		// plus a record with default matcher for subclass
		return getExistingRecordFromHierarchy(eClass).getMatcher();
	}

	public Copier getCopier(EClass eClass) {
		return getRecord(eClass, false).getCopier();
	}
	
	public final Decision[] getDecisions(EClass eClass) {
		return getRecord(eClass, false).getDecisions();
	}
	
	protected final void setMatcher(EClass eClass, Matcher matcher){
		getRecord(eClass, true).setMatcher(matcher);
	}

	protected final void setMatcher(EClass eClass, EAttribute attribute){  
		checkStructuralFeature(eClass, attribute);
		setMatcher(eClass, new ReflectiveMatcher(attribute));
	}
	
	protected final void setMatcher(EClass eClass, EReference reference) {
		checkStructuralFeature(eClass, reference);
		// XXX Perhaps, for cases, when reference's target is in some other package,
		// might be reasonable to have an alternative matching, non-resolving, just comparing proxyURI?
		setMatcher(eClass, new ReflectiveMatcher(reference));
	}

	protected final void setMatcherForAllSubclasses(EClass eClass, Matcher matcher){
		checkAbstract(eClass);
		getTemplateRecord(eClass, true).setMatcher(matcher);
	}

	protected final void setCopier(EClass eClass, Copier copier){
		getRecord(eClass, true).setCopier(copier);
	}
	
	protected final void setCopierForAllSubclasses(EClass eClass, Copier copier){
		checkAbstract(eClass);
		getTemplateRecord(eClass, true).setCopier(copier);
	}
	
	private static void checkAbstract(EClass eClass){
		if (!eClass.isAbstract()){
			throw new IllegalArgumentException(
					"This is not safe method that may lead to strange behaviour in case of multiple inheritance. " +
					"We tried to limit its usage as much as possible");
		}
	}

	protected final void addDecision(EClass eClass, Decision decision){
		getRecord(eClass, true).addDecision(decision);
	}
	
	private EClassRecord getRecord(EClass eClass, boolean force){
		EClassRecord result = myEClass2Record.get(eClass);
		if (result == null){
			if (force){
				result = new EClassRecord();
				myEClass2Record.put(eClass, result);
			} else {
				result = getExistingRecordFromHierarchy(eClass);
				if (result != EMPTY_RECORD){
					//cache it for the next time
					myEClass2Record.put(eClass, result);
				}
			}
		}
		return result;
	}

	/**
	 * Looks through the hierarchy of superclasses, checking for registered 
	 * records for abstract classes. 
	 * @@return never null, {@@link #EMPTY_RECORD} in case none found 
	 */
	private EClassRecord getExistingRecordFromHierarchy(EClass eClass) {
		EClassRecord result= EMPTY_RECORD;
		for (Iterator<EClass> superClasses = eClass.getEAllSuperTypes().iterator(); result == EMPTY_RECORD && superClasses.hasNext();){
			EClass nextSuper = superClasses.next();
			if (nextSuper.isAbstract()) {
				result = getTemplateRecord(nextSuper, false);
			}
		}
		return result;
	}

	private EClassRecord getTemplateRecord(EClass abstractSuperClass, boolean force){
		assert abstractSuperClass.isAbstract();
		EClassRecord result = myAbstractEClass2SubclassesRecord.get(abstractSuperClass);
		if (result == null && force){
			result = new EClassRecord();
			myAbstractEClass2SubclassesRecord.put(abstractSuperClass, result);
		}
		return result == null ? EMPTY_RECORD : result;
	}
	
	private static void checkStructuralFeature(EClass expectedClass, EStructuralFeature feature) {
		if (expectedClass.getEStructuralFeature(feature.getFeatureID()) != feature){
			throw new IllegalArgumentException(MessageFormat.format("Alien feature {0} for EClass {1}", new Object[] {feature, expectedClass}));
		}
	}
	
	protected static final Matcher ALWAYS_MATCH = new Matcher(){
		public boolean match(EObject current, EObject old) {
			return current.eClass().equals(old.eClass());
		}
	};

	private static class EClassRecord {
		private Matcher myMatcher = Matcher.FALSE; 
		private Copier myCopier = Copier.NEVER_COPY;
		private final List<Decision> myDecisions = new LinkedList<Decision>();
		private Decision[] myMakersArray;
		
		public void addDecision(Decision maker){
			myDecisions.add(maker);
			makersSetChanged();
		}
		
		public void setCopier(Copier copier) {
			myCopier = copier;
		}

		public Decision[] getDecisions(){
			if (myMakersArray == null){
				myMakersArray = myDecisions.toArray(new Decision[myDecisions.size()]);
			}
			return myMakersArray;
		}
		
		public void setMatcher(Matcher matcher) {
			myMatcher = matcher;
		}
		
		public Matcher getMatcher() {
			return myMatcher;
		}
		
		public Copier getCopier() {
			return myCopier;
		}
		
		private void makersSetChanged(){
			myMakersArray = null;
		}
	}

}
@


1.10
log
@[231133] reconcile viewmap attributes
@
text
@a11 1

d24 1
d59 5
d65 5
a69 2
	protected final void setCopier(EClass eClass, Copier copier){
		getRecord(eClass, true).setCopier(copier);
d71 1
a71 1
	
d76 4
a97 15
	protected final void setMatcher(EClass eClass, EAttribute attribute){  
		checkStructuralFeature(eClass, attribute);
		Matcher matcher = new ReflectiveMatcher(attribute);
		setMatcher(eClass, matcher);
	}
	
	protected final void setMatcher(EClass eClass, EReference reference){
		if (eClass.getEPackage().equals(reference.eClass().getEPackage())){
			//XXX: use lazyly resolved matcher??? 
			setMatcher(eClass, new ReflectiveMatcher(reference));
		} else {
			setMatcher(eClass, new ReflectiveMatcher(reference));
		}
	}

d141 1
a141 1
	private void checkStructuralFeature(EClass expectedClass, EAttribute feature) {
@


1.9
log
@[174496] Custom property tabs lost when gmfgen is re-created
ReconcilerConfigBase - need to respect matcher defined for abstract superclass if there's a default matcher for concrete subclass
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 Borland Software Corporation
d65 10
a79 1
		getTemplateRecord(eClass, true).setMatcher(matcher);
d81 1
a81 1
	
@


1.8
log
@merged DecisionMaker and Decision into single Decision class, subclasses renamed accordingly (DefaultDecisionMaker as DefaultDecision and StringPatternDecisionMaker as StringPatternDecision).
@
text
@d37 9
a45 1
		return getRecord(eClass, false).getMatcher();
d99 1
a99 7
				result = EMPTY_RECORD;
				for (Iterator<EClass> superClasses = eClass.getEAllSuperTypes().iterator(); result == EMPTY_RECORD && superClasses.hasNext();){
					EClass nextSuper = superClasses.next();
					if (nextSuper.isAbstract()) {
						result = getTemplateRecord(nextSuper, false);
					}
				}
d108 17
a124 1
	
@


1.7
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
d44 2
a45 2
	public final DecisionMaker[] getDecisionMakers(EClass eClass) {
		return getRecord(eClass, false).getDecisionMakers();
d65 2
a66 2
	protected final void addDecisionMaker(EClass eClass, DecisionMaker decisionMaker){
		getRecord(eClass, true).addDecisionMaker(decisionMaker);
d132 2
a133 2
		private final List<DecisionMaker> myDecisionMakers = new LinkedList<DecisionMaker>();
		private DecisionMaker[] myMakersArray;
d135 2
a136 2
		public void addDecisionMaker(DecisionMaker maker){
			myDecisionMakers.add(maker);
d144 1
a144 1
		public DecisionMaker[] getDecisionMakers(){
d146 1
a146 1
				myMakersArray = myDecisionMakers.toArray(new DecisionMaker[myDecisionMakers.size()]);
@


1.6
log
@use generics wherever possible
@
text
@d92 2
a93 2
				for (Iterator superClasses = eClass.getEAllSuperTypes().iterator(); result == EMPTY_RECORD && superClasses.hasNext();){
					EClass nextSuper = (EClass) superClasses.next();
@


1.5
log
@Correcting asserts.
@
text
@d28 2
a29 2
	private final HashMap myEClass2Record;
	private final HashMap myAbstractEClass2SubclassesRecord;
d32 2
a33 2
		myEClass2Record = new HashMap();
		myAbstractEClass2SubclassesRecord = new HashMap();
d85 1
a85 1
		EClassRecord result = (EClassRecord) myEClass2Record.get(eClass);
d109 1
a109 1
		EClassRecord result = (EClassRecord)myAbstractEClass2SubclassesRecord.get(abstractSuperClass);
d132 1
a132 1
		private final List myDecisionMakers = new LinkedList();
d146 1
a146 1
				myMakersArray = (DecisionMaker[]) myDecisionMakers.toArray(new DecisionMaker[myDecisionMakers.size()]);
@


1.4
log
@Assert 		assert abstractSuperClass.isAbstract();
at line 106removed
@
text
@d94 3
a96 1
					result = getTemplateRecord(nextSuper, false);
d108 1
@


1.3
log
@[mgolubev] #146026 [Reconciler] User defined gmfgen Viewmap attributes should be preserved
@
text
@a105 1
		assert abstractSuperClass.isAbstract();
@


1.2
log
@[mgolubev] #131762 preserve GenChildContainer properties
@
text
@d17 1
d29 1
d33 1
d40 4
d52 13
d92 8
d105 10
d129 1
d138 4
d157 4
@


1.1
log
@[mgolubev] #131355 Preserve modified gmfgen attributes which initialy had some default values
@
text
@d22 1
d51 1
a51 1
		Matcher matcher = new AttributeMatcher(attribute);
d58 1
a58 1
			setMatcher(eClass, new AttributeMatcher(reference));
d60 1
a60 1
			setMatcher(eClass, new AttributeMatcher(reference));
d82 6
@

