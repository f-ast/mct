head	1.34;
access;
symbols
	v20081015-1925:1.34
	v20080930-1130:1.34
	v20080926-1245:1.34
	v20080924-1925:1.34
	v20080722-1827:1.34
	v20080716-1642:1.34
	R2_1_maintenance:1.34.0.2
	Root_R2_1_maintenance:1.34
	R2_1_0:1.34
	v20080610-1132:1.34
	v20080521:1.34
	v20080516-1143:1.34
	v20080508-2000:1.34
	v20080417-1610:1.34
	v20080322-0000:1.34
	v20080222-1200:1.34
	v20071108-0000:1.34
	v20070903-0000:1.33
	v20070809-0000:1.33
	R2_0_maintenance:1.33.0.2
	R2_0:1.33
	R4_20:1.33
	v20070621-0000:1.33
	RC3_20:1.33
	v20070605-1400:1.33
	v20070601-1400:1.33
	v20070525-1500:1.33
	v20070520-1200:1.33
	v20070518-1300:1.32
	v20070427-0600:1.32
	v20070420-1000:1.31
	v20070413-1300:1.31
	v20070405-1100:1.29
	v20070330-1300:1.29
	v20060330-1300:1.29
	v20070322-1100:1.29
	v20070307-0700:1.28
	v20070301-1200:1.28
	v20070228-2000:1.27
	v20070221-1500:1.27
	v20070208-1800:1.26
	M4_20:1.21
	v20061222-1800:1.21
	v20061214-0000:1.19
	v20061120-1300:1.14
	M3_20:1.14
	v20061117-0800:1.14
	v20061013-1330:1.12
	v20060925-1700:1.4
	v20060919-0800:1.4
	M1_20:1.10
	v20060904-1500:1.10
	v20060713-1700:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060626-1420:1.4
	v20060616-1200:1.4
	v20060609-1400:1.4
	v20060531-1730:1.4
	v20060530-1930:1.3
	v20060526-1200:1.2
	v20060519-1300:1.2
	v20060519-0800:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.34
date	2007.10.12.15.44.49;	author atikhomirov;	state Exp;
branches;
next	1.33;
commitid	5c6e470f96714567;

1.33
date	2007.05.18.22.54.23;	author atikhomirov;	state Exp;
branches;
next	1.32;
commitid	2a4e464e2e9f4567;

1.32
date	2007.04.25.11.27.36;	author atikhomirov;	state Exp;
branches;
next	1.31;
commitid	7f9e462f3b274567;

1.31
date	2007.04.10.18.47.33;	author atikhomirov;	state Exp;
branches;
next	1.30;
commitid	7da9461bdbc44567;

1.30
date	2007.04.10.14.30.07;	author atikhomirov;	state Exp;
branches;
next	1.29;
commitid	5b5c461b9f6f4567;

1.29
date	2007.03.19.16.49.09;	author atikhomirov;	state Exp;
branches;
next	1.28;
commitid	5cce45febf044567;

1.28
date	2007.03.01.16.27.48;	author atikhomirov;	state Exp;
branches;
next	1.27;
commitid	5a0445e6ff034567;

1.27
date	2007.02.09.19.58.54;	author atikhomirov;	state Exp;
branches;
next	1.26;
commitid	3b845ccd27d4567;

1.26
date	2007.02.07.17.41.36;	author atikhomirov;	state Exp;
branches;
next	1.25;
commitid	326445ca0f504567;

1.25
date	2007.02.07.11.52.27;	author atikhomirov;	state Exp;
branches;
next	1.24;
commitid	26b45c9bd7b4567;

1.24
date	2007.02.07.11.51.07;	author atikhomirov;	state Exp;
branches;
next	1.23;
commitid	277745c9bd2a4567;

1.23
date	2007.02.06.20.27.25;	author atikhomirov;	state Exp;
branches;
next	1.22;
commitid	31b045c8e4ad4567;

1.22
date	2007.02.01.13.31.03;	author atikhomirov;	state Exp;
branches;
next	1.21;
commitid	105e45c1eb964567;

1.21
date	2006.12.22.16.43.24;	author ashatalin;	state Exp;
branches;
next	1.20;
commitid	2bf9458c0b2b4567;

1.20
date	2006.12.22.16.33.46;	author ashatalin;	state Exp;
branches;
next	1.19;
commitid	1d4f458c08e94567;

1.19
date	2006.12.13.19.01.47;	author dstadnik;	state Exp;
branches;
next	1.18;
commitid	b7945804e1b4567;

1.18
date	2006.12.11.16.05.14;	author dstadnik;	state Exp;
branches;
next	1.17;
commitid	56a1457d81ba4567;

1.17
date	2006.12.06.19.28.50;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	73da457719f14567;

1.16
date	2006.12.05.13.15.57;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	6f734575710c4567;

1.15
date	2006.11.28.17.23.25;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	2cc7456c708c4567;

1.14
date	2006.11.13.13.22.15;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	52a5455871864567;

1.13
date	2006.10.27.12.29.51;	author bblajer;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.09.10.32.51;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.03.12.06.16;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.01.16.03.18;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.30.17.55.32;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.30.17.36.39;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.30.15.09.09;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.25.16.36.50;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.21.13.48.46;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.31.16.49.47;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.29.17.17.14;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.19.14.30.16;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.18.19.12.37;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.34
log
@[200527] The java file is not merged when it is open in the editor area - first, let user save all editors, than, use working copy for existing units
@
text
@/*
 * Copyright (c) 2005, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.common.codegen;

import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspaceRunnable;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.emf.codegen.util.CodeGenUtil.EclipseUtil;
import org.eclipse.emf.common.util.BasicDiagnostic;
import org.eclipse.emf.common.util.Diagnostic;
import org.eclipse.emf.common.util.DiagnosticException;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.gmf.common.UnexpectedBehaviourException;
import org.eclipse.gmf.common.codegen.ImportAssistant;
import org.eclipse.gmf.internal.common.Activator;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IImportDeclaration;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IPackageFragment;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.ToolFactory;
import org.eclipse.jdt.core.formatter.CodeFormatter;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

/**
 * XXX do I really need refreshLocal in doGenerate[Binary]File? Guess, not.
 * @@author artem
 */
public abstract class GeneratorBase implements Runnable {

	private CodeFormatter myCodeFormatter;
    private OrganizeImportsPostprocessor myImportsPostprocessor;
	private IProgressMonitor myProgress = new NullProgressMonitor();

	// myDestRoot.getJavaProject().getElementName() == myDestProject.getName()
	private IPackageFragmentRoot myDestRoot;
	private IProject myDestProject;
	private final List<IStatus> myExceptions;
	private IStatus myRunStatus = Status.CANCEL_STATUS;
	private TextMerger myMerger;
	private final boolean isToRestoreExistingImports = true;

	protected abstract void customRun() throws InterruptedException, UnexpectedBehaviourException;

	protected abstract void setupProgressMonitor();

	public GeneratorBase() {
		myExceptions = new LinkedList<IStatus>();
	}

	public void run(IProgressMonitor progress) throws InterruptedException {
		setProgressMonitor(progress);
		clearExceptionsList();
		doRun();
	}

	public void run() {
		clearExceptionsList();
		try {
			doRun();
		} catch (InterruptedException ex) {
			myRunStatus = new Status(IStatus.CANCEL, Activator.getID(), 0, Messages.interrupted, ex);
		}
	}

	/**
	 * Provides information about success/failures during {@@link #run()}
	 * @@return state of the generator run, or CANCEL if generator was not yet run.
	 */
	public IStatus getRunStatus() {
		return myRunStatus;
	}

	/**
	 * Optionally, specify progressMonitor to use. Should be called prior to {@@link #run()}
	 * @@param progress
	 */
	public void setProgressMonitor(IProgressMonitor progress) {
		myProgress = progress;
	}

	protected final void handleException(CoreException ex) {
		handleException(ex.getStatus());
	}

	protected final void handleException(IStatus status) {
		myExceptions.add(status);
	}

	protected final void handleException(Throwable ex) {
		if (ex instanceof DiagnosticException) {
			// unwind invocation target exceptions as much as possible 
			final Diagnostic diagnostic = ((DiagnosticException) ex).getDiagnostic();
			if (diagnostic.getException() instanceof InvocationTargetException) {
				Throwable originalEx = ((InvocationTargetException) diagnostic.getException()).getCause();
				handleException(newStatus(originalEx));
			} else {
				handleException(BasicDiagnostic.toIStatus(diagnostic));
			}
		} else {
			handleException(newStatus(ex));
		}
	}

	/**
	 * by default, process as ordinary exception
	 */
	protected void handleUnexpected(UnexpectedBehaviourException ex) {
		handleException(ex);
	}

	protected static IStatus newStatus(Throwable ex) {
		return newStatus(IStatus.ERROR, ex);
	}

	protected static IStatus newStatus(int severity, Throwable ex) {
		final String msg = ex.getMessage() == null ? ex.getClass().getName() : ex.getMessage();
		return new Status(severity, Activator.getID(), 0, Messages.bind(Messages.exception, msg), ex);
	}

	protected final IProject getDestProject() {
		return myDestProject;
	}

	protected final IProgressMonitor getProgress() {
		return myProgress;
	}

	/**
	 * @@param task optional string to be shown in the progress dialog
	 * @@param total estimation of number of activities to happen
	 */
	protected final void setupProgressMonitor(String task, int total) {
		if (myProgress == null) {
			myProgress = new NullProgressMonitor();
			return;
			// no need to set it up
		}
		myProgress.beginTask(task == null ? Messages.start : task, total);
	}

	protected final IProgressMonitor getNextStepMonitor() throws InterruptedException {
		if (myProgress.isCanceled()) {
			throw new InterruptedException();
		}
		return new SubProgressMonitor(myProgress, 1);
	}

	/**
	 * @@see #initializeEditorProject(String, IPath, List)
	 */
	protected final void initializeEditorProject(String pluginId, IPath projectLocation) throws UnexpectedBehaviourException, InterruptedException {
		initializeEditorProject(pluginId, projectLocation, Collections.<IProject>emptyList());
	}

	/**
	 * @@param pluginId both name of workspace project and plug-in id
	 * @@param projectLocation {@@link IPath} to folder where <code>.project</code> file would reside. Use <code>null</code> to use default workspace location.
	 * @@param referencedProjects collection of {@@link IProject}
	 * @@throws UnexpectedBehaviourException something goes really wrong 
	 * @@throws InterruptedException user canceled operation
	 */
	protected final void initializeEditorProject(String pluginId, IPath projectLocation, List<IProject> referencedProjects) throws UnexpectedBehaviourException, InterruptedException {
		myDestProject = ResourcesPlugin.getWorkspace().getRoot().getProject(pluginId);
		final Path srcPath = new Path('/' + myDestProject.getName() + "/src"); //$NON-NLS-1$
		final int style = org.eclipse.emf.codegen.ecore.Generator.EMF_PLUGIN_PROJECT_STYLE;
		// pluginVariables is NOT used when style is EMF_PLUGIN_PROJECT_STYLE
		final List<?> pluginVariables = null;
		final IProgressMonitor pm = getNextStepMonitor();
		setProgressTaskName(Messages.initproject);

		org.eclipse.emf.codegen.ecore.Generator.createEMFProject(srcPath, projectLocation, referencedProjects, pm, style, pluginVariables);

		try {
			final IJavaProject jp = JavaCore.create(myDestProject);
			myDestRoot = jp.findPackageFragmentRoot(srcPath);
			// createEMFProject doesn't create source entry in case project exists and has some classpath entries already, 
			// though the folder gets created. 
			if (myDestRoot == null) {
				IClasspathEntry[] oldCP = jp.getRawClasspath();
				IClasspathEntry[] newCP = new IClasspathEntry[oldCP.length + 1];
				System.arraycopy(oldCP, 0, newCP, 0, oldCP.length);
				newCP[oldCP.length] = JavaCore.newSourceEntry(srcPath);
				jp.setRawClasspath(newCP, new NullProgressMonitor());
				myDestRoot = jp.findPackageFragmentRoot(srcPath);
			}
		} catch (JavaModelException ex) {
			throw new UnexpectedBehaviourException(ex.getMessage());
		}
		if (myDestRoot == null) {
			throw new UnexpectedBehaviourException("no source root can be found");
		}
	}

	/**
	 * Generate ordinary file.
	 * @@param emitter template to use
	 * @@param filePath - project-relative path to file, e.g. META-INF/MANIFEST.MF
	 * @@param param TODO
	 * @@throws InterruptedException
	 */
	protected final void doGenerateFile(TextEmitter emitter, IPath filePath, Object... param) throws InterruptedException {
		assert !myDestProject.getName().equals(filePath.segment(0));
		IProgressMonitor pm = getNextStepMonitor();
		try {
			setProgressTaskName(filePath.lastSegment());
			pm.beginTask(null, 5);
			IPath containerPath = myDestProject.getFullPath().append(filePath.removeLastSegments(1));
			EclipseUtil.findOrCreateContainer(containerPath, false, (IPath) null, new SubProgressMonitor(pm, 1));
			String genText = emitter.generate(new SubProgressMonitor(pm, 1), param);
			IFile f = myDestProject.getFile(filePath);
			final boolean propertyFile = "properties".equals(filePath.getFileExtension());
			String charset = propertyFile ? "ISO-8859-1" : "UTF-8";
			if (propertyFile) {
				genText = Conversions.escapeUnicode(genText);
			}
			String oldText = null;
			if (f.exists()) {
				oldText = FileServices.getFileContents(f);
			}
			if (oldText != null) {
				genText = mergePlainText(oldText, genText, f, new SubProgressMonitor(pm, 1));
				if (!oldText.equals(genText)) {
					f.setContents(new ByteArrayInputStream(genText.getBytes(charset)), true, true, new SubProgressMonitor(pm, 1));
				} else {
					pm.worked(1);
				}
			} else {
				f.create(new ByteArrayInputStream(genText.getBytes(charset)), true, new SubProgressMonitor(pm, 2));
			}
			f.getParent().refreshLocal(IResource.DEPTH_ONE, new SubProgressMonitor(pm, 1));
		} catch (InvocationTargetException ex) {
			handleException(ex.getCause());
		} catch (UnexpectedBehaviourException ex) {
			handleUnexpected(ex);
		} catch (CoreException ex) {
			handleException(ex);
		} catch (UnsupportedEncodingException ex) {
			handleException(ex);
		} finally {
			pm.done();
		}
	}

	/**
	 * Inspired by GenBaseImpl.EclipseUtil.findOrCreateContainer
	 * Although later (with EMF API adopting Platform changes) we might need to return URI here
	 * @@return path suitable for IProjectDescription, or <code>null</code> to indicate use of default
	 */
	protected final IPath guessNewProjectLocation(Path examplaryProjectPath, String newProjectName) {
		assert newProjectName != null;
		try {
			if (ResourcesPlugin.getWorkspace().getRoot().getProject(newProjectName).exists()) {
				// just use whatever already specified.
				// Returned value doesn't make sense in this case -
				// oee.codegen.ecore.Generator#EclipseHelper#createEMFProject doesn't use it then. 
				return null;
			}
			if (examplaryProjectPath == null || !examplaryProjectPath.isAbsolute()) {
				return null;
			}
			IProject p = ResourcesPlugin.getWorkspace().getRoot().getProject(examplaryProjectPath.segment(0));
			if (!p.exists()) {
				return null;
			}
			java.net.URI locationURI = p.getDescription().getLocationURI();
			// org.eclipse.core.internal.utils.FileUtil#toPath
			if (locationURI == null) {
				return null;
			}
			if (locationURI.getScheme() != null && !"file".equals(locationURI.getScheme())) {
				return null;
			}
			return new Path(locationURI.getSchemeSpecificPart()).removeLastSegments(1).append(newProjectName);
		} catch (CoreException ex) {
			handleException(newStatus(IStatus.WARNING, ex));
			return null;
		}
	}

	protected final ImportAssistant createImportAssistant(String packageName, String className) {
		return new ImportUtil(packageName, className, myDestRoot);
	}

	protected final void doGenerateJavaClass(TextEmitter emitter, String qualifiedClassName, Object... input) throws InterruptedException {
		doGenerateJavaClass(emitter, CodeGenUtil.getPackageName(qualifiedClassName), CodeGenUtil.getSimpleClassName(qualifiedClassName), input);
	}

	/**
	 * NOTE: potential problem - packageName and className should match those specified in 
	 * the template. Besides, getQualifiedXXX helpers in diagram GenModel should also correctly
	 * return qualified class names.  
	 */
	protected final void doGenerateJavaClass(TextEmitter emitter, String packageName, String className, Object... input) throws InterruptedException {
		IProgressMonitor pm = getNextStepMonitor();
		try {
			setProgressTaskName(className);
			pm.beginTask(null, 7);
			String genText = emitter.generate(new SubProgressMonitor(pm, 2), input);
			IPackageFragment pf = myDestRoot.createPackageFragment(packageName, true, new SubProgressMonitor(pm, 1));
			ICompilationUnit cu = pf.getCompilationUnit(className + ".java"); //$NON-NLS-1$
			if (cu.exists()) {
				ICompilationUnit workingCopy = null;
				try {
					workingCopy = cu.getWorkingCopy(new SubProgressMonitor(pm, 1));
					final String oldContents = workingCopy.getSource();
	                IImportDeclaration[] declaredImports = workingCopy.getImports();
	                workingCopy.getBuffer().setContents(genText);
	                workingCopy.reconcile(ICompilationUnit.NO_AST, false, null, null);
					try {
	                    //Since we do organizeImports prior to merge, we must ensure imports added manually are known to OrganizeImportsProcessor
	                    String[] declaredImportsAsStrings = new String[declaredImports.length];
	                    for (int i=0; i<declaredImports.length; i++) {
	                        declaredImportsAsStrings[i] = declaredImports[i].getElementName();
	                    }
						getImportsPostrocessor().organizeImports(workingCopy, declaredImportsAsStrings, new SubProgressMonitor(pm, 1));
					} catch (CoreException e) {
						workingCopy.commitWorkingCopy(true, new SubProgressMonitor(pm, 1)); // save to investigate contents
						throw e;
					}
					genText = mergeJavaCode(oldContents, workingCopy.getSource(), new SubProgressMonitor(pm, 1));
					genText = formatCode(genText);
					if (!genText.equals(oldContents)) {
						workingCopy.getBuffer().setContents(genText);
						workingCopy.reconcile(ICompilationUnit.NO_AST, false, null, null);
						workingCopy.commitWorkingCopy(true, new SubProgressMonitor(pm, 1));
					} else {
						// discard changes - would happen in finally, nothing else to do
						pm.worked(1);
					}
				} finally {
					workingCopy.discardWorkingCopy();
				}
			} else {
				cu = pf.createCompilationUnit(cu.getElementName(), genText, true, new SubProgressMonitor(pm, 1));
				getImportsPostrocessor().organizeImports(cu, null, new SubProgressMonitor(pm, 1));
				String newContents = formatCode(cu.getSource());
				cu.getBuffer().setContents(newContents);
				cu.save(new SubProgressMonitor(pm, 2), true);
			}
		} catch (NullPointerException ex) {
			handleException(ex);
		} catch (InvocationTargetException ex) {
			handleException(ex.getCause());
		} catch (UnexpectedBehaviourException ex) {
			handleUnexpected(ex);
		} catch (CoreException ex) {
			handleException(ex);
		} finally {
			pm.done();
		}
	}

	protected final void doGenerateBinaryFile(BinaryEmitter emitter, Path outputPath, Object[] params) throws InterruptedException, UnexpectedBehaviourException {
		IProgressMonitor pm = getNextStepMonitor();
		setProgressTaskName(outputPath.lastSegment());
		IFile f = getDestProject().getFile(outputPath);
		if (f.exists()) {
			// Follow EMF's policy and do not overwrite file if exists
			return;
		}
		try {
			pm.beginTask(null, 4);
			IPath containerPath = getDestProject().getFullPath().append(outputPath.removeLastSegments(1));
			EclipseUtil.findOrCreateContainer(containerPath, false, (IPath) null, new SubProgressMonitor(pm, 1));
			byte[] contents = emitter.generate(new SubProgressMonitor(pm, 1), params);
			f.create(new ByteArrayInputStream(contents), true, new SubProgressMonitor(pm, 1));
			f.getParent().refreshLocal(IResource.DEPTH_ONE, new SubProgressMonitor(pm, 1));
		} catch (InvocationTargetException ex) {
			handleException(ex.getCause());
		} catch (CoreException ex) {
			handleException(ex);
		} finally {
			pm.done();
		}
	}

	protected String mergeJavaCode(String oldContents, String generatedText, IProgressMonitor pm) throws JavaModelException {
		pm.beginTask(Messages.merge, 1);
		try {
			return getMergeService().mergeJava(oldContents, generatedText);
		} finally {
			pm.done();
		}
	}

	protected String mergePlainText(String oldText, String genText, IFile oldRes, IProgressMonitor pm) {
		pm.beginTask(Messages.merge, 1);
		try {
			return getMergeService().process(oldRes.getName(), oldText, genText);
		} finally {
			pm.done();
		}
	}

	private TextMerger getMergeService() {
		if (myMerger == null) {
			myMerger = createMergeService();
			assert myMerger != null;
		}
		return myMerger;
	}

	/**
	 * By default, provides facility that doesn't perform any merge at all.
	 * @@return facility to perform merges, should never return null. 
	 */
	protected TextMerger createMergeService() {
		return new TextMerger();
	}

	protected void setProgressTaskName(String text) {
		myProgress.subTask(text);
	}

	protected final String formatCode(String text) {
		IDocument doc = new Document(text);
		TextEdit edit = getCodeFormatter().format(CodeFormatter.K_COMPILATION_UNIT, doc.get(), 0, doc.get().length(), 0, null);

		try {
			// check if text formatted successfully
			if (edit != null) {
				edit.apply(doc);
				text = doc.get();
			}
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return text;
	}

	private void doRun() throws InterruptedException {
		try {
			setupProgressMonitor();
			ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable() {
				public void run(IProgressMonitor monitor) throws CoreException {
					try {
						customRun();
						myRunStatus = getExceptionsStatus();
						// XXX consider catching CCE and provide "programming error"
						// to help users with their templates
					} catch (NullPointerException ex) {
						myRunStatus = new Status(IStatus.ERROR, Activator.getID(), 0, NullPointerException.class.getName(), ex);
					} catch (UnexpectedBehaviourException ex) {
						myRunStatus = new Status(Status.ERROR, Activator.getID(), 0, Messages.unexpected, ex);
					} catch (InterruptedException ex) {
						myRunStatus = new Status(IStatus.CANCEL, Activator.getID(), 0, Messages.interrupted, ex); 
					}
				}
			}, null);
			if (myRunStatus.getSeverity() == IStatus.CANCEL && myRunStatus.getException() instanceof InterruptedException) {
				throw (InterruptedException) myRunStatus.getException();
			}
		} catch (CoreException ex) {
			myRunStatus = ex.getStatus();
		} finally {
			getProgress().done();
			clearExceptionsList();
		}
	}

	private CodeFormatter getCodeFormatter() {
		if (myCodeFormatter == null) {
			myCodeFormatter = ToolFactory.createCodeFormatter(null);
		}
		return myCodeFormatter;
	}

	private OrganizeImportsPostprocessor getImportsPostrocessor() {
		if (myImportsPostprocessor == null) {
			myImportsPostprocessor = new OrganizeImportsPostprocessor(isToRestoreExistingImports);
		}
		return myImportsPostprocessor;
	}

	private final void clearExceptionsList(){
		myExceptions.clear();
	}

	private final IStatus getExceptionsStatus() {
		if (myExceptions == null || myExceptions.isEmpty()) {
			return Status.OK_STATUS;
		} else {
			IStatus[] s = myExceptions.toArray(new IStatus[myExceptions.size()]);
			return new MultiStatus(Activator.getID(), 0, s, Messages.problems, null);
		}
	}

	protected static final class Counter {
		private final HashMap<EClass, Integer> myCounters = new HashMap<EClass, Integer>();
		private final HashMap<EClass, Integer> myCache = new HashMap<EClass, Integer>();
		private final Integer CACHE_MISS = new Integer(0);

		public Counter() {
		}

		public void registerFactor(EClass eClass, int count) {
			myCounters.put(eClass, count);
		}

		public int getTotal(EObject from) {
			int total = process(from);
			for (Iterator<EObject> it = from.eAllContents(); it.hasNext();) {
				total += process(it.next());
			}
			return total;
		}

		protected int process(EObject next) {
			final EClass nextKey = next.eClass();
			Integer cachedValue = checkCached(nextKey);
			if (cachedValue != null) {
				return cachedValue;
			}
			LinkedList<EClass> checkQueue = new LinkedList<EClass>();
			checkQueue.add(nextKey);
			do {
				EClass key = checkQueue.removeFirst();
				if (myCounters.containsKey(key)) {
					final Integer value = myCounters.get(key);
					cache(nextKey, value);
					return value;
				} else {
					// add immeditate superclasses to check first
					checkQueue.addAll(key.getESuperTypes());
				}
			} while (!checkQueue.isEmpty());
			cache(nextKey, CACHE_MISS);
			return 0;
		}

		private Integer checkCached(EClass nextKey) {
			return myCache.get(nextKey);
		}

		private void cache(EClass nextKey, Integer value) {
			myCache.put(nextKey, value);
		}
	}
}
@


1.33
log
@minor beautify
@
text
@d339 1
a339 3
				final String oldContents = cu.getSource();
                IImportDeclaration[] declaredImports = cu.getImports();
				cu.getBuffer().setContents(genText);
d341 28
a368 18
                    //Since we do organizeImports prior to merge, we must ensure imports added manually are known to OrganizeImportsProcessor
                    String[] declaredImportsAsStrings = new String[declaredImports.length];
                    for (int i=0; i<declaredImports.length; i++) {
                        declaredImportsAsStrings[i] = declaredImports[i].getElementName();
                    }
					getImportsPostrocessor().organizeImports(cu, declaredImportsAsStrings, new SubProgressMonitor(pm, 1));
				} catch (CoreException e) {
					cu.save(new SubProgressMonitor(pm, 1), true); // save to investigate contents
					throw e;
				}
				genText = mergeJavaCode(oldContents, cu.getSource(), new SubProgressMonitor(pm, 1));
				genText = formatCode(genText);
				if (!genText.equals(oldContents)) {
					cu.getBuffer().setContents(genText);
					cu.save(new SubProgressMonitor(pm, 1), true);
				} else {
					cu.getBuffer().close(); // discard changes
					pm.worked(1);
@


1.32
log
@moving towards 146774 - merge for manifest.mf
@
text
@d189 1
a189 2
		final List<IProject> referencedProjects = Collections.emptyList();
		initializeEditorProject(pluginId, projectLocation, referencedProjects);
@


1.31
log
@GeneratorBaseMessages renamed to Messages to reflect it's not specific to GeneratorBase;
externalized error from OIP which might appear in the UI
@
text
@d419 1
a419 1
			return getMergeService().process(oldRes.getFileExtension(), oldText, genText);
@


1.30
log
@unwind invocationtargetexception as much as possible; add a message to visually improve error indication in the ErrorDialog (which stupidly shows both status message and exception.toString)
@
text
@d98 1
a98 1
			myRunStatus = new Status(IStatus.CANCEL, Activator.getID(), 0, GeneratorBaseMessages.interrupted, ex);
d154 1
a154 1
		return new Status(severity, Activator.getID(), 0, GeneratorBaseMessages.bind(GeneratorBaseMessages.exception, msg), ex);
d175 1
a175 1
		myProgress.beginTask(task == null ? GeneratorBaseMessages.start : task, total);
d207 1
a207 1
		setProgressTaskName(GeneratorBaseMessages.initproject);
d408 1
a408 1
		pm.beginTask(GeneratorBaseMessages.merge, 1);
d417 1
a417 1
		pm.beginTask(GeneratorBaseMessages.merge, 1);
d474 1
a474 1
						myRunStatus = new Status(Status.ERROR, Activator.getID(), 0, GeneratorBaseMessages.unexpected, ex);
d476 1
a476 1
						myRunStatus = new Status(IStatus.CANCEL, Activator.getID(), 0, GeneratorBaseMessages.interrupted, ex); 
d514 1
a514 1
			return new MultiStatus(Activator.getID(), 0, s, GeneratorBaseMessages.problems, null);
@


1.29
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d39 3
d127 12
a138 1
		handleException(newStatus(ex));
d153 2
a154 1
		return new Status(severity, Activator.getID(), 0, ex.getMessage() == null ? ex.getClass().getName() : ex.getMessage(), ex);
@


1.28
log
@use generics wherever possible
@
text
@d190 1
a190 1
		final List pluginVariables = null;
d517 2
a518 2
			for (Iterator it = from.eAllContents(); it.hasNext();) {
				total += process((EObject) it.next());
a522 1
		@@SuppressWarnings("unchecked")
@


1.27
log
@[173462] akarjakina - do not create intemediate file state that could be overlooked after merge
@
text
@d174 2
a175 1
		initializeEditorProject(pluginId, projectLocation, Collections.EMPTY_LIST);
d185 1
a185 1
	protected final void initializeEditorProject(String pluginId, IPath projectLocation, List/*<IProject>*/ referencedProjects) throws UnexpectedBehaviourException, InterruptedException {
@


1.26
log
@fix test failure - need to let OrganizeImportProcessor know about imports kept in the original CU
@
text
@d325 1
a325 1
				IImportDeclaration[] declaredImports = cu.getImports();
d328 6
a333 2
					copyImports(cu, declaredImports, new SubProgressMonitor(pm, 1));
					getImportsPostrocessor().organizeImports(cu, new SubProgressMonitor(pm, 1));
d349 1
a349 1
				getImportsPostrocessor().organizeImports(cu, new SubProgressMonitor(pm, 1));
a366 23
	/*
	 * Since we do organizeImports prior to merge, we must ensure
	 * imports added manually are known to OrganizeImportsProcessor
	 */
	private static void copyImports(ICompilationUnit cu, IImportDeclaration[] importsToCopy, IProgressMonitor progress) throws JavaModelException {
		if (importsToCopy == null || importsToCopy.length == 0) {
			return;
		}
		progress.beginTask(null, importsToCopy.length + 1);
		final String[] imports = new String[importsToCopy.length];
		final int[] flags = new int[imports.length];
		for (int i = 0; i < importsToCopy.length; i++) {
			imports[i] = importsToCopy[i].getElementName();
			flags[i] = importsToCopy[i].getFlags();
		}
		// ensure resource is in sync with buffer (otherwize NPE from CreateElementInCUOperation) 
		cu.save(new SubProgressMonitor(progress, 1), true);
		for (int i = 0; i < imports.length; i++) {
			cu.createImport(imports[i], null, flags[i], new SubProgressMonitor(progress, 1));
		}
		progress.done();
	}

@


1.25
log
@isToRestoreExistingImports is essentially a constant
@
text
@d46 1
d319 1
a319 1
			pm.beginTask(null, 6);
d325 1
d328 1
d348 1
a348 1
				cu.save(new SubProgressMonitor(pm, 1), true);
d363 23
@


1.24
log
@do not pull almost-always-true argument through all method parameters
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
d73 1
a73 1
	private boolean isToRestoreExistingImports = true;
@


1.23
log
@[168713] JMerge can't merge methods with simple and fully-qualified arguments, need to organize imports prior to merge
@
text
@d326 1
a326 1
					getImportsPostrocessor().organizeImports(cu, isToRestoreExistingImports, new SubProgressMonitor(pm, 1));
d342 1
a342 1
				getImportsPostrocessor().organizeImports(cu, isToRestoreExistingImports, new SubProgressMonitor(pm, 1));
d477 1
a477 1
			myImportsPostprocessor = new OrganizeImportsPostprocessor();
@


1.22
log
@java5's convenience
@
text
@d318 2
a319 2
			pm.beginTask(null, 5);
			String genText = emitter.generate(new SubProgressMonitor(pm, 1), input);
d324 8
a331 1
				genText = mergeJavaCode(oldContents, genText, new SubProgressMonitor(pm, 1));
d333 1
a333 1
				if (!genText.equals(oldContents)) { // compare text with fqns; works for jet templates
d335 1
a335 13
					try {
						getImportsPostrocessor().organizeImports(cu, isToRestoreExistingImports, new SubProgressMonitor(pm, 1));
					} catch (CoreException e) {
						cu.save(new SubProgressMonitor(pm, 1), true); // save to investigate contents
						throw e;
					}
					String newContents = formatCode(cu.getSource());
					if (!newContents.equals(oldContents)) { // compare text with organized imports; works for xpand templates
						cu.getBuffer().setContents(newContents);
						cu.save(new SubProgressMonitor(pm, 1), true);
					} else {
						pm.worked(1);
					}
d337 2
a338 1
					pm.worked(2);
@


1.21
log
@Rollback incorrect changes.
@
text
@d222 1
a222 1
	protected final void doGenerateFile(TextEmitter emitter, IPath filePath, Object[] param) throws InterruptedException {
@


1.20
log
@Continue working if import manager produces error.
@
text
@d332 1
a332 1
						handleException(e);
@


1.19
log
@save cu when organize imports fails for post-mortem analysis
@
text
@d332 1
a332 1
						throw e;
@


1.18
log
@do not overwrite the same java files
@
text
@d328 6
a333 1
					getImportsPostrocessor().organizeImports(cu, isToRestoreExistingImports, new SubProgressMonitor(pm, 1));
@


1.17
log
@[165864] akarjakina - Provide post-generation facility to automatically organize java imports
@
text
@a321 1
			String oldContents = null;
d323 1
a323 1
				oldContents = cu.getSource();
d325 14
d340 5
a344 9
				pm.worked(1);
			}
			genText = formatCode(genText);
			if (!genText.equals(oldContents)) {
				ICompilationUnit newCU = pf.createCompilationUnit(cu.getElementName(), genText, true, new SubProgressMonitor(pm, 1));
                getImportsPostrocessor().organizeImports(newCU, isToRestoreExistingImports, new SubProgressMonitor(pm, 1));
                newCU.save(new SubProgressMonitor(pm, 1), true);
			} else {
				pm.worked(1);
@


1.16
log
@run all generation templates inside a workspace operation to avoid unnecessary updates
@
text
@d64 1
d73 1
d318 1
a318 1
			pm.beginTask(null, 4);
d331 3
a333 1
				pf.createCompilationUnit(cu.getElementName(), genText, true, new SubProgressMonitor(pm, 1));
d465 7
@


1.15
log
@java5 way to pass object array is bit more convenient
@
text
@d26 1
d74 1
a74 1
	
d77 1
a77 1
	public GeneratorBase(){
d80 1
a80 1
	
d86 1
a86 1
	
d95 1
a95 1
	
d115 1
a115 1
	
d142 1
a142 1
	
d146 1
a146 1
	
d159 1
a159 1
	
d340 1
a340 1
			handleException(ex);		
d368 1
a368 1
	}	
d413 2
a414 2
			// check if text formatted successfully 
			if(edit != null) {
d416 2
a417 2
				text = doc.get();				
			}		
d427 21
a447 7
			customRun();
			myRunStatus = getExceptionsStatus();
			// XXX consider catching CCE and provide "programming error" to help users with their templates
		} catch (NullPointerException ex) {
			myRunStatus = new Status(IStatus.ERROR, Activator.getID(), 0, NullPointerException.class.getName(), ex);
		} catch (UnexpectedBehaviourException ex) {
			myRunStatus = new Status(Status.ERROR, Activator.getID(), 0, GeneratorBaseMessages.unexpected, ex);
d460 1
a460 1
	
d464 3
a466 3
	
	private final IStatus getExceptionsStatus(){
		if (myExceptions == null || myExceptions.isEmpty()){
d478 1
a478 1
	
d481 1
a481 1
	
d485 1
a485 1
	
d493 1
a493 1
	
d499 1
a499 1
				return cachedValue; 
d517 1
a517 1
	
d521 1
a521 1
	
@


1.14
log
@do not use hardcoded plugin id
@
text
@d302 1
a302 1
	protected final void doGenerateJavaClass(TextEmitter emitter, String qualifiedClassName, Object[] input) throws InterruptedException {
d311 1
a311 1
	protected final void doGenerateJavaClass(TextEmitter emitter, String packageName, String className, Object[] input) throws InterruptedException {
@


1.13
log
@On regeneration, do not generate imports that conflict with those already present in the compilation unit, use FQNs instead (currently, only in Lite Generator to prove the concept) + Test
@
text
@d42 1
d91 1
a91 1
			myRunStatus = new Status(IStatus.CANCEL, "org.eclipse.gmf.common", 0, GeneratorBaseMessages.interrupted, ex);
d135 1
a135 1
		return new Status(severity, "org.eclipse.gmf.common", 0, ex.getMessage() == null ? ex.getClass().getName() : ex.getMessage(), ex);
d430 1
a430 1
			myRunStatus = new Status(IStatus.ERROR, "org.eclipse.gmf.common", 0, NullPointerException.class.getName(), ex);
d432 1
a432 1
			myRunStatus = new Status(Status.ERROR, "org.eclipse.gmf.common", 0, GeneratorBaseMessages.unexpected, ex);
d455 1
a455 1
			return new MultiStatus("org.eclipse.gmf.common", 0, s, GeneratorBaseMessages.problems, null);
@


1.12
log
@[150469] UnexpectedBehaviourException when target project exists but there's no source root
@
text
@d41 1
d210 1
a210 1
	
d297 4
@


1.11
log
@deprecated method removed
@
text
@d41 1
d43 1
d190 12
a201 1
			myDestRoot = JavaCore.create(myDestProject).findPackageFragmentRoot(srcPath);
@


1.10
log
@refactoring: abstract use of JMerge for merging away from generator services (GeneratorBase)
@
text
@a16 1
import java.net.URL;
a67 4
	protected final URL getJMergeControlFile() {
		return null;
	}
	
@


1.9
log
@use same counter code to estimate amount of work
@
text
@a14 4
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
a36 2
import org.eclipse.emf.codegen.merge.java.JControlModel;
import org.eclipse.emf.codegen.merge.java.JMerger;
a58 1
	private JControlModel myJControlModel;
d67 1
d69 3
a71 1
	protected abstract URL getJMergeControlFile();
d214 1
a214 1
			pm.beginTask(null, 4);
d219 1
a219 1
			boolean propertyFile = "properties".equals(filePath.getFileExtension());
d226 1
a226 1
				oldText = getFileContents(f);
d229 1
a229 4
				TextMerger merger = TextMerger.getForFile(f.getName());
				if (merger != null) {
					genText = merger.process(oldText, genText);
				}
d236 1
a236 1
				f.create(new ByteArrayInputStream(genText.getBytes(charset)), true, new SubProgressMonitor(pm, 1));
a251 23
	private static String getFileContents(IFile file) {
		StringBuffer contents = new StringBuffer();
		char[] buffer = new char[1024];
		int count;
		try {
			Reader in = new InputStreamReader(file.getContents(true), file.getCharset());
			try {
				while ((count = in.read(buffer)) > 0) {
					contents.append(buffer, 0, count);
				}
			} finally {
				in.close();
			}
		} catch (CoreException ce) {
			ce.printStackTrace();
			return null;
		} catch (IOException ioe) {
			ioe.printStackTrace();
			return null;
		}
		return contents.toString();
	}

a287 23
	/**
	 * @@return <code>true</code> if the file contains the input stream contents
	 */
	protected boolean contains(IFile f, InputStream is) {
		int fc = 0;
		int ic = 0;
		InputStream fs = null;
		try {
			fs = f.getContents(true);
			while ((fc = fs.read()) == (ic = is.read()) && fc >= 0);
		} catch (CoreException ce) {
		} catch (IOException ioe) {
		} finally {
			if (fs != null) {
				try {
					fs.close();
				} catch (IOException ioe) {
				}
			}
		}
		return fc <0 && ic < 0;
	}

d305 7
a311 1
			genText = mergeJavaCode(genText, cu, new SubProgressMonitor(pm, 1));
d313 1
a313 1
			if (!cu.exists() || !genText.equals(cu.getSource())) {
d355 1
a355 1
	protected final String mergeJavaCode(String generatedText, ICompilationUnit oldCU, IProgressMonitor pm) throws JavaModelException {
d358 10
a367 9
			if (oldCU != null && oldCU.exists() && getJControlModel() != null) {
				JMerger jMerge = new JMerger(getJControlModel());
				jMerge.setSourceCompilationUnit(jMerge.createCompilationUnitForContents(generatedText));
				jMerge.setTargetCompilationUnit(jMerge.createCompilationUnitForContents(oldCU.getSource()));
				jMerge.merge();
				return jMerge.getTargetCompilationUnitContents();
			} else {
				return generatedText;
			}
d373 16
a424 14
	private JControlModel getJControlModel() {
		if (myJControlModel == null) {
			URL controlFile = getJMergeControlFile();
			if (controlFile != null){
				myJControlModel = new JControlModel();
				myJControlModel.initialize(CodeGenUtil.instantiateFacadeHelper(JMerger.DEFAULT_FACADE_HELPER_CLASS), controlFile.toString());
				if (!myJControlModel.canMerge()){
					throw new IllegalStateException("Can not initialize JControlModel");
				}
			}
		}
		return myJControlModel;
	}

@


1.8
log
@properties reorganized
@
text
@d1 11
d23 2
d45 2
d64 1
d488 53
@


1.7
log
@avoid 'unchecked' warnings
@
text
@d135 4
d145 1
a145 1
		myProgress.beginTask(task, total);
d176 1
d201 1
a201 1
			myProgress.subTask(filePath.lastSegment());
d337 1
a337 1
			myProgress.subTask(className);
d364 1
a364 1
		myProgress.subTask(outputPath.lastSegment());
d403 4
@


1.6
log
@minor refactoring
@
text
@d56 1
a56 1
	private final List/*<IStatus>*/ myExceptions;
d66 1
a66 1
		myExceptions = new LinkedList/*<IStatus>*/();
d459 1
a459 1
			IStatus[] s = (IStatus[]) myExceptions.toArray(new IStatus[myExceptions.size()]);
@


1.5
log
@add file merge support for other text files (!java)
@
text
@d71 1
d205 1
a205 1
				genText = escapeUnicode(genText);
a260 24
	private static String escapeUnicode(String text) {
	    StringBuffer result = new StringBuffer(text.length());
	    for (int i = 0, size = text.length(); i < size; ++i)
	    {
	      char character = text.charAt(i);
	      if (character > '\u00ff')
	      {
	        result.append("\\u");
	        String hex = Integer.toString(character, 16);
	        for (int j = hex.length(); j < 4; ++j)
	        {
	          result.append("0");
	        }
	        result.append(hex);
	      }
	      else
	      {
	        result.append(character);
	      }
	    }

	    return result.toString();
	}

@


1.4
log
@do not overwrite existing binary files (inspired with #144665)
@
text
@d6 2
d185 1
a185 1
	 * Generate ordinary file. No merge is performed at the moment.
d206 1
a206 1
			// FIXME merge!
d208 8
a215 1
				if (!contains(f, new ByteArrayInputStream(genText.getBytes(charset)))) {
d237 23
@


1.3
log
@#141865 Icon not displayed for the wizard banner
Wizard banner image and wizard/editor icon are generated now with EMF facility for coloured .gifs
Keyword added to iconPath values to allow reference icons from EMF editor
@
text
@d350 6
a356 1
			myProgress.subTask(outputPath.lastSegment());
a359 1
			IFile f = getDestProject().getFile(outputPath);
d361 1
a361 9
			if (f.exists()) {
				if (!contains(f, new ByteArrayInputStream(contents))) {
					f.setContents(new ByteArrayInputStream(contents), true, true, new SubProgressMonitor(pm, 1));
				} else {
					pm.worked(1);
				}
			} else {
				f.create(new ByteArrayInputStream(contents), true, new SubProgressMonitor(pm, 1));
			}
@


1.2
log
@#125964 match location of generated project with other EMF projects
@
text
@d42 4
d347 29
a375 1
	
d457 1
a457 1
	}	
@


1.1
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@d9 1
d112 6
a117 2
	protected IStatus newStatus(Throwable ex) {
		return new Status(IStatus.ERROR, "org.eclipse.gmf.common", 0, ex.getMessage() == null ? ex.getClass().getName() : ex.getMessage(), ex);
d143 16
a158 2
	
	protected final void initializeEditorProject(String pluginId, List referencedProjects) throws UnexpectedBehaviourException, InterruptedException {
a160 1
		final Path projectLocation = null; // use default
d249 36
@

