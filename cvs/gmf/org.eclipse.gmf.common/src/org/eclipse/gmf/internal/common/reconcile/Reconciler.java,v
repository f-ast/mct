head	1.14;
access;
symbols
	v20081015-1925:1.14
	v20080930-1130:1.14
	v20080926-1245:1.12
	v20080924-1925:1.10
	v20080722-1827:1.10
	v20080716-1642:1.10
	R2_1_maintenance:1.10.0.4
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080610-1132:1.10
	v20080521:1.10
	v20080516-1143:1.10
	v20080508-2000:1.10
	v20080417-1610:1.10
	v20080322-0000:1.10
	v20080222-1200:1.10
	v20071108-0000:1.10
	v20070903-0000:1.10
	v20070809-0000:1.10
	R2_0_maintenance:1.10.0.2
	R2_0:1.10
	R4_20:1.10
	v20070621-0000:1.10
	RC3_20:1.10
	v20070605-1400:1.10
	v20070601-1400:1.10
	v20070525-1500:1.10
	v20070520-1200:1.10
	v20070518-1300:1.10
	v20070427-0600:1.10
	v20070420-1000:1.10
	v20070413-1300:1.10
	v20070405-1100:1.9
	v20070330-1300:1.9
	v20060330-1300:1.9
	v20070322-1100:1.8
	v20070307-0700:1.6
	v20070301-1200:1.6
	v20070228-2000:1.6
	v20070221-1500:1.6
	v20070208-1800:1.6
	M4_20:1.6
	v20061222-1800:1.6
	v20061214-0000:1.6
	v20061120-1300:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061013-1330:1.6
	v20060925-1700:1.3
	v20060919-0800:1.3
	M1_20:1.4
	v20060904-1500:1.4
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060626-1420:1.3
	v20060616-1200:1.3
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060530-1930:1.2
	v20060526-1200:1.2
	v20060519-1300:1.2
	v20060519-0800:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.14
date	2008.09.26.16.49.18;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	13bcd48dd128e4567;

1.13
date	2008.09.26.16.47.18;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	13a6f48dd12164567;

1.12
date	2008.09.26.15.46.59;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	10ba148dd03f24567;

1.11
date	2008.09.26.12.57.53;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	71df48dcdc504567;

1.10
date	2007.04.12.12.48.14;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	9fe461e2a8d4567;

1.9
date	2007.03.29.20.10.34;	author ashatalin;	state Exp;
branches;
next	1.8;
commitid	4843460c1d3a4567;

1.8
date	2007.03.20.17.52.00;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	610746001f3f4567;

1.7
date	2007.03.19.16.49.09;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	5cce45febf044567;

1.6
date	2006.09.04.18.10.44;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.04.17.48.25;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.28.17.16.08;	author ashatalin;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.13.11.17.02;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.15.15.16.59;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.13.12.02.47;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.14
log
@[248327] Reconcile should respect cross-references, subtle improvements - do not keep empty entry if no changeable features found
@
text
@/*
 * Copyright (c) 2006, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Michael Golubev (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.common.reconcile;

import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature.Setting;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.FeatureMapUtil;
import org.eclipse.gmf.internal.common.Activator;

public class Reconciler {
	private final ReconcilerConfig myConfig;
	// Maps EObject referenced elsewhere to a setting representing the use
	private final Map<EObject, List<Setting>> myCrossRefsToFix;
	private final Map<EObject, EObject> myMatches;
	private boolean myIsMatching;

	private final boolean traceMatches;
	private final boolean traceDecision;
	private final boolean traceFeatureInDecision;
	private final boolean traceCrossRefUpdate;

	public Reconciler(ReconcilerConfig config){
		myConfig = config;
		myCrossRefsToFix = new LinkedHashMap<EObject, List<Setting>>();
		myMatches = new LinkedHashMap<EObject, EObject>();
		final String recon = "/reconciler/", op1 = "traceMatches", op2 = "traceDecision", op3 = "/features", op4 = "traceCrossRefUpdate";
		traceMatches = Boolean.parseBoolean(Platform.getDebugOption(Activator.getID() + recon + op1));
		traceDecision = Boolean.parseBoolean(Platform.getDebugOption(Activator.getID() + recon + op2));
		traceFeatureInDecision = Boolean.parseBoolean(Platform.getDebugOption(Activator.getID() + recon + op2 + op3));
		traceCrossRefUpdate = Boolean.parseBoolean(Platform.getDebugOption(Activator.getID() + recon + op4));
	}

	protected void handleNotMatchedCurrent(EObject current){
		//FIXME ??? Is it user escape -- check history ???
		//FIXME How to handle not macthed old ???
		/*
		 * [AS]: inversed constructor parameter was added to DefaultDecision, so
		 * it looks like a way to remove genmodel nodes removed by user.
		 */
	}
	
	protected EObject handleNotMatchedOld(EObject currentParent, EObject notMatchedOld) {
		Copier copier = myConfig.getCopier(notMatchedOld.eClass());
		return copier.copyToCurrent(currentParent, notMatchedOld, this);
	}

	public void reconcileResource(Resource current, Resource old){
		reconcileContents(null, current.getContents(), old.getContents());
		updateCrossReferences();
	}
	
	public void reconcileTree(EObject currentRoot, EObject oldRoot){
		internalReconcileTree(currentRoot, oldRoot);
		updateCrossReferences();
	}
	
	protected void reconcileVertex(EObject current, EObject old){
		assert current.eClass().equals(old.eClass());
		registerMatch(current, old);
		for (Decision decision : myConfig.getDecisions(current.eClass())){
			decision.apply(current, old);
			if (traceDecision) {
				trace(traceFeatureInDecision ? "[decision] %s (%s)" : "[decision] %s", decision.getClass().getName(), decision.getFeature().getName());
			}
		}
	}

	protected void internalReconcileTree(EObject currentRoot, EObject oldRoot){
		reconcileVertex(currentRoot, oldRoot);
		reconcileContents(currentRoot, currentRoot.eContents(), oldRoot.eContents());
	}

	protected void registerMatch(EObject current, EObject old) {
		myMatches.put(old, current);
		if (traceMatches) {
			trace("[matched]%s -> %s", old.eClass().getName(), current.eClass().getName());
		}
	}

	protected void updateCrossReferences() {
		for (Map.Entry<EObject, List<Setting>> e : myCrossRefsToFix.entrySet()) {
			final EObject oldReferenceTarget = e.getKey();
			if (myMatches.containsKey(oldReferenceTarget)) {
				EObject copied = myMatches.get(oldReferenceTarget);
				if (traceCrossRefUpdate) {
					trace("[crossRefUpd] matched %s -> %s", oldReferenceTarget, copied);
				}
				for (Setting s : e.getValue()) {
					if (myMatches.containsKey(s.getEObject())) {
						EObject newOwner = myMatches.get(s.getEObject());
						if (traceCrossRefUpdate) {
							trace("[crossRefUpd] updating '%s' value of %s", s.getEStructuralFeature().getName(), newOwner);
						}
						if (s.getEStructuralFeature().isMany() || FeatureMapUtil.isMany(s.getEObject(), s.getEStructuralFeature())) {
							@@SuppressWarnings("unchecked")
							List<EObject> values = (List<EObject>) newOwner.eGet(s.getEStructuralFeature());
							assert !values.contains(copied); // sanity, wonder if that may happen, ever
							if (values.contains(oldReferenceTarget)) {
								// replace old value, keep position
								values.set(values.indexOf(oldReferenceTarget), copied);
							} else {
								values.add(copied);
							}
						} else {
							newOwner.eSet(s.getEStructuralFeature(), copied);
						}
					} else {
						if (traceCrossRefUpdate) {
							trace("[crossRefUpd] no matching owner for %s (old owner: %s)", s.getEStructuralFeature().getName(), s.getEObject());
						}
					}
				}
			} else {
				if (traceCrossRefUpdate) {
					trace("[crossRefUpd] no match for old %s", oldReferenceTarget);
				}
			}
		}
		// TODO Auto-generated method stub
	}

	/* package-local */void registerCrossReferencesToUpdate(Map<EObject, Collection<Setting>> crossReferences) {
		for (Map.Entry<EObject, Collection<Setting>> e : crossReferences.entrySet()) {
			List<Setting> entries = myCrossRefsToFix.get(e.getKey());
			if (entries == null) {
				entries = new LinkedList<Setting>();
				myCrossRefsToFix.put(e.getKey(), entries);
			}
			for (Setting s : e.getValue()) {
				if (s.getEStructuralFeature().isChangeable()) {
					entries.add(s);
				}
			}
			if (entries.isEmpty()) {
				myCrossRefsToFix.remove(e.getKey()); // none changeable, no reason to keep empty list 
			}
		}
	}

	private void reconcileContents(EObject currentParent, Collection<EObject> allCurrents, Collection<EObject> allOlds) {
		if (allCurrents.isEmpty() && allOlds.isEmpty()) {
			return;
		}
		final List<Pair> storage = new LinkedList<Pair>();
		match(allCurrents, allOlds, storage);

		for (Pair next : storage) {
			EObject nextCurrent = next.current;
			EObject nextOld = next.old;
			assert (nextCurrent != null || nextOld != null);

			if (nextCurrent == null) {
				if (currentParent != null) { // never copy top-level resource contents
					nextCurrent = handleNotMatchedOld(currentParent, nextOld);
				}
			}

			if (nextCurrent != null && nextOld != null) {
				internalReconcileTree(nextCurrent, nextOld);
			} else if (nextOld == null) {
				handleNotMatchedCurrent(nextCurrent);
			}
		}
	}
	
	private void match(Collection<EObject> currents, Collection<EObject> olds, Collection<Pair> output) {
		assert !myIsMatching;

		final Collection<EObject> myOlds;
		final Collection<EObject> myCurrents;
		try {
			myIsMatching = true;

			myOlds = new LinkedHashSet<EObject>(olds);
			myCurrents = new LinkedList<EObject>(currents);

			for (Iterator<EObject> currentContents = myCurrents.iterator(); !myOlds.isEmpty() && currentContents.hasNext();) {
				EObject nextCurrent = currentContents.next();
				EObject matchedOld = removeMatched(nextCurrent, myOlds);
				output.add(new Pair(nextCurrent, matchedOld));
				currentContents.remove();
			}

			for (Iterator<EObject> notMatchedOlds = myOlds.iterator(); notMatchedOlds.hasNext();) {
				output.add(new Pair(null, notMatchedOlds.next()));
			}
		} finally {
			myIsMatching = false;
		}
	}
		
	private EObject removeMatched(EObject current, Collection<EObject> allOld) {
		EClass eClass = current.eClass();
		Matcher matcher = myConfig.getMatcher(eClass);
		EObject result = null;
		if (matcher != Matcher.FALSE) {
			for (Iterator<EObject> all = allOld.iterator(); all.hasNext();) {
				EObject next = all.next();
				if (eClass.equals(next.eClass()) && matcher.match(current, next)) {
					result = next;
					all.remove();
					break;
				}
			}
		}
		return result;
	}

	private static void trace(String format, Object... args) {
		Activator.log(new Status(IStatus.INFO, Activator.getID(), String.format(format, args)));
	}

	private static class Pair {
		public final EObject current;
		public final EObject old;

		public Pair(EObject cur, EObject old) {
			this.current = cur;
			this.old = old;
		}
	}
}
@


1.13
log
@[248327] Reconcile should respect cross-references, replace old values (that might get copied from old reference)
@
text
@d156 3
@


1.12
log
@[248327] Reconcile should respect cross-references, do not respect non-changeable references, though
@
text
@d104 3
a106 2
			if (myMatches.containsKey(e.getKey())) {
				EObject copied = myMatches.get(e.getKey());
d108 1
a108 1
					trace("[crossRefUpd] matched %s -> %s", e.getKey(), copied);
a118 1
							assert !values.contains(e.getKey()); // sanity, in case that may happen, should support replacement
d120 6
a125 1
							values.add(copied);
d137 1
a137 1
					trace("[crossRefUpd] no match for old %s", e.getKey());
@


1.11
log
@[248327] Reconcile should respect cross-references
@
text
@d146 5
a150 1
			entries.addAll(e.getValue());
@


1.10
log
@[181844] keep extra existing root objects in .gmfgen resource during transformation
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 Borland Software Corporation
a11 1

d16 1
d20 1
d22 3
d27 1
d29 2
d34 9
a42 2

	private final MatchingSession myMatchingSession;
d46 7
a52 1
		myMatchingSession = new MatchingSession();
d54 1
a54 1
	
d66 1
a66 1
		return copier.copyToCurrent(currentParent, notMatchedOld);
d71 1
d75 2
a76 2
		reconcileVertex(currentRoot, oldRoot);
		reconcileContents(currentRoot, currentRoot.eContents(), oldRoot.eContents());
d81 1
d84 63
d149 3
a151 3
	
	private void reconcileContents(EObject currentParent, Collection<EObject> allCurrents, Collection<EObject> allOlds){
		if (allCurrents.isEmpty() && allOlds.isEmpty()){
d155 3
a157 3
		myMatchingSession.match(allCurrents, allOlds, storage);
		
		for (Pair next : storage){
d161 3
a163 3
			
			if (nextCurrent == null){
				if (currentParent != null){ //never copy top-level resource contents
d165 1
a165 1
				} 
d168 3
a170 3
			if (nextCurrent != null && nextOld != null){
				reconcileTree(nextCurrent, nextOld);
			} else if (nextOld == null){
d176 20
a195 39
	private static class Pair {
		public EObject current;
		public EObject old;
	}
	
	private class MatchingSession {
		private boolean myIsMatching;
		
		public MatchingSession(){
		}
		
		public void match(Collection<EObject> currents, Collection<EObject> olds, Collection<Pair> output){
			assert !myIsMatching;
			
			final Collection<EObject> myOlds;
			final Collection<EObject> myCurrents;
			try {
				myIsMatching = true;

				myOlds = new LinkedHashSet<EObject>(olds);
				myCurrents = new LinkedList<EObject>(currents);

				for (Iterator<EObject> currentContents = myCurrents.iterator(); !myOlds.isEmpty() && currentContents.hasNext();){
					EObject nextCurrent = currentContents.next();
					Pair nextPair = acquirePair();
					nextPair.current = nextCurrent;
					nextPair.old = removeMatched(nextCurrent, myOlds);
					output.add(nextPair);
					currentContents.remove();
				}
				
				for (Iterator<EObject> notMatchedOlds = myOlds.iterator(); notMatchedOlds.hasNext();){
					Pair nextPair = acquirePair();
					nextPair.current = null;
					nextPair.old = notMatchedOlds.next();
					output.add(nextPair);
				}
			} finally {
				myIsMatching = false;
d197 2
d200 1
d202 11
a212 12
		private EObject removeMatched(EObject current, Collection<EObject> allOld){
			EClass eClass = current.eClass();
			Matcher matcher = myConfig.getMatcher(eClass);
			EObject result = null;
			if (matcher != Matcher.FALSE){
				for (Iterator<EObject> all = allOld.iterator(); all.hasNext();){
					EObject next = all.next();
					if (eClass.equals(next.eClass()) && matcher.match(current, next)){
						result = next;
						all.remove();
						break;
					}
a214 1
			return result;
d216 10
d227 3
a229 2
		private Pair acquirePair(){
			return new Pair();
@


1.9
log
@Reconciling GenNavigator properties
@
text
@d58 1
a58 1
	private void reconcileVertex(EObject current, EObject old){
@


1.8
log
@merged DecisionMaker and Decision into single Decision class, subclasses renamed accordingly (DefaultDecisionMaker as DefaultDecision and StringPatternDecisionMaker as StringPatternDecision).
@
text
@d38 4
@


1.7
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
d56 2
a57 5
		DecisionMaker[] decisionMakers = myConfig.getDecisionMakers(current.eClass());
		for (int i = 0; i < decisionMakers.length; i++){
			DecisionMaker next = decisionMakers[i];
			Decision decision = next.makeDecision(current, old);
			decision.apply(current, old, next.getFeature());
a100 3
			if (myIsMatching){
				throw new IllegalStateException("FIXME: remove me");
			}
@


1.6
log
@there's no value in reusing pairs
@
text
@a44 1
	@@SuppressWarnings("unchecked")
a48 1
	@@SuppressWarnings("unchecked")
d135 1
a135 1
		private EObject removeMatched(EObject current, Collection allOld){
d140 2
a141 2
				for (Iterator all = allOld.iterator(); all.hasNext();){
					EObject next = (EObject)all.next();
@


1.5
log
@there's no value in reusing lists
@
text
@a25 5
	/**
	 * Expected max breadth of the node in the reconciled tree
	 */
	private static final int PAIRS_POOL_SIZE = 100;
	
d27 1
d32 1
a32 1
		myMatchingSession = new MatchingSession(new PairsPool(PAIRS_POOL_SIZE));
d45 1
d50 1
d66 1
a66 1
	private void reconcileContents(EObject currentParent, Collection allCurrents, Collection allOlds){
a77 2
			myMatchingSession.releasePair(next);
			
a94 5
		
		public void reset(){
			current = null;
			old = null;
		}
a97 3
		private final Collection myCurrents;
		private final Collection myOlds;
		private final PairsPool myPool;
d100 1
a100 4
		public MatchingSession(PairsPool pool){
			myPool = pool;
			myCurrents = new LinkedList();
			myOlds = new LinkedHashSet();
d103 1
a103 1
		public void match(Collection currents, Collection olds, Collection<Pair> output){
a104 2
			assert myOlds.isEmpty();
			assert myCurrents.isEmpty();
d109 2
a110 1
			
d114 5
a118 5
				myCurrents.addAll(currents);
				myOlds.addAll(olds);
				
				for (Iterator currentContents = myCurrents.iterator(); !myOlds.isEmpty() && currentContents.hasNext();){
					EObject nextCurrent = (EObject) currentContents.next();
d126 1
a126 1
				for (Iterator notMatchedOlds = myOlds.iterator(); notMatchedOlds.hasNext();){
d129 1
a129 1
					nextPair.old = (EObject)notMatchedOlds.next();
a133 2
				myCurrents.clear();
				myOlds.clear();
a154 25
			return myPool.acquire();
		}
		
		public void releasePair(Pair pair){
			myPool.release(pair);
		}
		
	}
	
	private static class PairsPool extends AbstractPool {
		public PairsPool(int capacity) {
			super(capacity);
		}
		
		public Pair acquire(){
			return (Pair)internalAcquire();
		}
		
		public void release(Pair pair){
			pair.current = null;
			pair.old = null;
			internalRelease(pair);
		}
		
		protected Object createNew() {
@


1.4
log
@Correcting GenChildNode matching logic.
Temporary solution. Matcher should be improved in advance.
@
text
@a14 1
import java.util.ArrayList;
a30 5
	/**
	 * Expected depth of the reconciled tree 
	 */
	private static final int STORAGE_POOL_SIZE = 10;
	
a32 1
	private final StoragePool myStoragePool;
a36 1
		myStoragePool = new StoragePool(STORAGE_POOL_SIZE);
d72 1
a72 1
		List storage = myStoragePool.acquireList();
d75 1
a75 2
		for (Iterator pairs = storage.iterator(); pairs.hasNext();){
			Pair next = (Pair)pairs.next();
a93 1
		myStoragePool.release(storage);
d118 1
a118 1
		public void match(Collection currents, Collection olds, Collection output){
a200 20
	
	private static class StoragePool extends AbstractPool {
		public StoragePool(int capacity){
			super(capacity);
		}
		
		public List acquireList(){
			return (List)internalAcquire();
		}
		
		public void release(List list){
			list.clear();
			internalRelease(list);
		}
		
		protected Object createNew() {
			return new ArrayList();
		}
	}

@


1.3
log
@[mgolubev] #146026 [Reconciler] User defined gmfgen Viewmap attributes should be preserved
@
text
@a16 1
import java.util.HashSet;
d18 1
d125 1
a125 1
			myOlds = new HashSet();
@


1.2
log
@[mgolubev] #131762 preserve GenChildContainer properties
@
text
@d15 1
d17 1
d19 2
d27 10
d38 2
d43 2
d52 5
d58 1
a58 1
		reconcileContents(current.getContents(), old.getContents());
d63 1
a63 1
		reconcileContents(currentRoot.eContents(), oldRoot.eContents());
d76 24
a99 5
	private void reconcileContents(Collection allCurrents, Collection allOlds){
		for (Iterator currentContents = allCurrents.iterator(); currentContents.hasNext();){
			EObject nextCurrent = (EObject) currentContents.next();
			EObject nextOld = findMatched(nextCurrent, allOlds);
			if (nextOld == null){
a100 2
			} else {
				reconcileTree(nextCurrent, nextOld);
d103 1
d106 51
a156 9
	private EObject findMatched(EObject current, Collection allOld){
		EClass eClass = current.eClass();
		Matcher matcher = myConfig.getMatcher(eClass);
		EObject result = null;
		if (matcher != Matcher.FALSE){
			for (Iterator all = allOld.iterator(); result == null && all.hasNext();){
				EObject next = (EObject)all.next();
				if (eClass.equals(next.eClass()) && matcher.match(current, next)){
					result = next;
d158 4
d164 65
a228 1
		return result;
@


1.1
log
@[mgolubev] #131355 Preserve modified gmfgen attributes which initialy had some default values
@
text
@d72 1
a72 1
				if (eClass.equals(eClass) && matcher.match(current, next)){
@

