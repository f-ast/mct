head	1.4;
access;
symbols
	v20081015-1925:1.4
	v20080930-1130:1.4
	v20080926-1245:1.4
	v20080924-1925:1.4
	v20080722-1827:1.4
	v20080716-1642:1.4
	R2_1_maintenance:1.4.0.4
	Root_R2_1_maintenance:1.4
	R2_1_0:1.4
	v20080610-1132:1.4
	v20080521:1.4
	v20080516-1143:1.4
	v20080508-2000:1.4
	v20080417-1610:1.4
	v20080322-0000:1.4
	v20080222-1200:1.4
	v20071108-0000:1.4
	v20070903-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070525-1500:1.3
	v20070520-1200:1.3
	v20070518-1300:1.3
	v20070427-0600:1.3
	v20070420-1000:1.3
	v20070413-1300:1.3
	v20070405-1100:1.2
	v20070330-1300:1.2
	v20060330-1300:1.2
	v20070322-1100:1.2
	v20070307-0700:1.2
	v20070301-1200:1.1
	v20070228-2000:1.1
	v20070221-1500:1.1
	v20070208-1800:1.1
	M4_20:1.1
	v20061222-1800:1.1
	v20061214-0000:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.4
date	2007.06.21.14.13.37;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	1e3f467a878e4567;

1.3
date	2007.04.11.13.34.40;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	2e25461ce3f04567;

1.2
date	2007.03.01.20.01.05;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	403a45e731004567;

1.1
date	2006.12.06.19.28.50;	author atikhomirov;	state Exp;
branches;
next	;
commitid	73da457719f14567;


desc
@@


1.4
log
@fix copyright years
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Anna Karjakina (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.common.codegen;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;

import org.eclipse.emf.common.util.URI;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.osgi.util.NLS;
import org.eclipse.swt.SWT;

class PackageReferencesCollector extends ASTVisitor {

    public static void collect(ASTNode node, Collection<Name> resultingQualifiedTypeReferences, Collection<SimpleName> resultingSimpleTypeReferences, Collection<String> resultingImportDeclarations) {
        node.accept(new PackageReferencesCollector(resultingQualifiedTypeReferences, resultingSimpleTypeReferences, resultingImportDeclarations));
    }

    public static void collect(ASTNode node, Collection<Name> resultingQualifiedTypeReferences, Collection<SimpleName> resultingSimpleTypeReferences, Collection<String> resultingImportDeclarations, Collection<String> hardcodedTypeNames) {
        node.accept(new PackageReferencesCollector(resultingQualifiedTypeReferences, resultingSimpleTypeReferences, resultingImportDeclarations, hardcodedTypeNames));
    }

    private Collection<SimpleName> mySimpleTypeReferences;
    private Collection<Name> myQualifiedTypeReferences;
    private Collection<String> myImportDeclarations;
    private Collection<String> myKnownPackages = new HashSet<String>();
    private Collection<String> myHardcodedTypes;

    private PackageReferencesCollector(Collection<Name> resultingTypeReferences, Collection<SimpleName> resultingSimpleTypeReferences, Collection<String> resultingImportDeclarations) {
        this(resultingTypeReferences, resultingSimpleTypeReferences, resultingImportDeclarations, null);
    }

    private PackageReferencesCollector(Collection<Name> resultingTypeReferences, Collection<SimpleName> resultingSimpleTypeReferences, Collection<String> resultingImportDeclarations, Collection<String> hardcodedTypes) {
        super(true);
        myQualifiedTypeReferences = resultingTypeReferences;
        mySimpleTypeReferences = resultingSimpleTypeReferences;
        myImportDeclarations = resultingImportDeclarations;
        myHardcodedTypes = hardcodedTypes;
    }

    private void addQualifiedReference(QualifiedName node) {
        myKnownPackages.add(node.getQualifier().getFullyQualifiedName());
        myQualifiedTypeReferences.add(node);
    }
    
    private void addSimpleReference(SimpleName name) {
        mySimpleTypeReferences.add(name);
    }
    
    private void addImport(Name name) {
        if (name.isQualifiedName()) {
            QualifiedName qName = (QualifiedName) name;
            myImportDeclarations.add(qName.getName().getFullyQualifiedName());
            myKnownPackages.add(qName.getQualifier().getFullyQualifiedName());
        } else {
            addSimpleReference((SimpleName) name);
        }
    }

    protected void typeRefFound(Name node) {
        Name name = node;
        if (node.isQualifiedName()) {
            name = hackRecognizeTypesAndPackagesForTheirLettersCase((QualifiedName) node);
            if (name == null) {
                return;
            }
        }
        if (name.isQualifiedName()) {
            addQualifiedReference((QualifiedName) name);
        } else {
            addSimpleReference((SimpleName) name);
        }
    }
    
    protected Name hackRecognizeTypesAndPackagesForTheirLettersCase(QualifiedName node) {
        Name name = node;
        List<Name> qualifiers = new ArrayList<Name>();
        while (name.isQualifiedName()) {
            qualifiers.add(name);
            name = ((QualifiedName) name).getQualifier();
        }
        qualifiers.add(name);
        for (ListIterator<Name> it=qualifiers.listIterator(qualifiers.size()); it.hasPrevious();) {
            Name packagePart = it.previous();
            if (getHardcodedTypes().contains(packagePart.getFullyQualifiedName())) {
                return packagePart;
            }
            SimpleName lastPart = packagePart.isSimpleName() ? (SimpleName)packagePart : ((QualifiedName)packagePart).getName();
            char[] letters = lastPart.getFullyQualifiedName().toCharArray();
            if (letters.length > 0) {
                if (Character.isUpperCase(letters[0])) {
                    //XXX: Type reference is recognized for its first Upper letter and at least one Lower
                    for (int i=0; i<letters.length; i++) {
                        if (Character.isLowerCase(letters[i])) {
                            return packagePart;
                        }
                    }
                } else {
                    //XXX: Package reference is recognized for all its chars are Lower case or digits
                    for (int i=0; i<letters.length; i++) {
                        if (!(Character.isLowerCase(letters[i]) || Character.isDigit(letters[i]))) {
                            return null;
                        }
                    }
                }
            }
        }
        return null;
    }
    
    public Collection<String> getHardcodedTypes() {
        if (myHardcodedTypes == null) {
            myHardcodedTypes = new HashSet<String>();
            initializeDefaultHardcodedTypes(myHardcodedTypes);
        }
        return myHardcodedTypes;
    }

    protected void initializeDefaultHardcodedTypes(Collection<String> container) {
        container.add(SWT.class.getCanonicalName());
        container.add(NLS.class.getCanonicalName());
        container.add(URI.class.getCanonicalName());
    }

    public boolean visit(ImportDeclaration node) {
        if (node.isOnDemand()) {
            myKnownPackages.add(node.getName().getFullyQualifiedName());
        } else {
            addImport(node.getName());
        }
        // not to visit the qualified name in imports
        return false;
    }

    public boolean visit(PackageDeclaration node) {
        // not to visit the qualified name in imports
        return false;
    }

    public boolean visit(SimpleType node) {
        typeRefFound(node.getName());
        return false;
    }

    public boolean visit(TypeDeclaration node) {
        addSimpleReference(node.getName());
        return true;
    }

    public boolean visit(QualifiedName node) {
        typeRefFound(node);
        return false;
    }

}
@


1.3
log
@recognize URI as classname
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.2
log
@[176020] akarjakina - OrganizeImports should process class names like SWT and NLS correctly
@
text
@d20 1
d142 1
@


1.1
log
@[165864] akarjakina - Provide post-generation facility to automatically organize java imports
@
text
@d29 2
d38 4
d46 1
d49 4
d57 1
d98 1
a98 1
            qualifiers.add(qualifiers.size(), name);
d104 3
d118 1
a118 1
                    //XXX: Package referenct is recognized for all its chars are Lower case or digits
d130 13
@

