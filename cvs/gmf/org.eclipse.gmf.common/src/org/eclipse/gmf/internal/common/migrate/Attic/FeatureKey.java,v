head	1.2;
access;
symbols
	v20081015-1925:1.2
	v20080924-1925:1.2
	v20070518-1300:1.1
	v20070427-0600:1.1
	v20070420-1000:1.1
	v20070413-1300:1.1
	v20070405-1100:1.1
	v20070330-1300:1.1
	v20060330-1300:1.1
	v20070322-1100:1.1
	v20070307-0700:1.1
	v20070301-1200:1.1
	v20070228-2000:1.1
	v20070221-1500:1.1
	v20070208-1800:1.1
	M4_20:1.1
	v20061222-1800:1.1
	v20061214-0000:1.1
	v20061120-1300:1.1
	M3_20:1.1
	v20061117-0800:1.1
	v20061013-1330:1.1;
locks; strict;
comment	@# @;


1.2
date	2007.05.18.20.39.13;	author atikhomirov;	state dead;
branches;
next	1.1;
commitid	58f6464e0ef14567;

1.1
date	2006.09.21.13.16.00;	author radvorak;	state Exp;
branches;
next	;


desc
@@


1.2
log
@[187811] akarjakina - Migration support refactored
@
text
@/**
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors: dvorak - initial API and implementation
 */
package org.eclipse.gmf.internal.common.migrate;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EStructuralFeature;

/**
 * Key class uniquely identifying a structural feature.
 * <p>
 * Motivation: avoid use of object identity based equals(..) for EStructuralFeature.    
 */
public class FeatureKey {
	
	private String namespaceURI;	
	private String className;
	private String featureName;
	
	/**
	 * Creates uninitialized feature key.
	 * <p>
	 * Note: It's safe to use {@@link #equals(Object)}, {@@link #hashCode()} on the created
	 * 		instance. A particular feature can be assigned repeatedly in order to support key 
	 * 		instance reuse. 
	 * 
	 * @@see #setFeature(EStructuralFeature)     
	 */
	public FeatureKey() {			
	}
	
	public static FeatureKey create(EStructuralFeature feature) {
		FeatureKey pair = new FeatureKey();
		pair.setFeature(feature);
		return pair;
	}
	
	public void setFeature(EStructuralFeature feature) {
		EClass eClass = feature.getEContainingClass();
		this.className = (eClass != null) ? eClass.getName() : null;
		this.namespaceURI = (eClass != null && eClass.getEPackage() != null) ? eClass.getEPackage().getNsURI() : null;
		this.featureName = feature.getName();
	}
	
	@@Override
	public boolean equals(Object that) {
		FeatureKey another = (FeatureKey) that;
		return	(className != null ? className.equals(another.className) : another.className == null) && 
				(featureName != null ? featureName.equals(another.featureName) : another.featureName == null) && 
				(namespaceURI != null ? namespaceURI.equals(another.namespaceURI) : another.namespaceURI == null);
	}
	
	@@Override
	public int hashCode() {
		return (className == null ? 0 : className.hashCode()) ^ (featureName == null ? 0 : featureName.hashCode()) ^ (namespaceURI == null ? 0 : namespaceURI.hashCode());
	}
	
	@@Override
	public String toString() {
		StringBuffer buf = new StringBuffer();
		buf.append('[').append(namespaceURI).append(']').append(':');
		buf.append(className).append(':').append(featureName);
		return buf.toString();
	}
}@


1.1
log
@#157836 Feature-based model migration patches should NOT use object identity equals() on metamodel
@
text
@@

