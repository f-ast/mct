head	1.7;
access;
symbols
	v20081015-1925:1.7
	v20080930-1130:1.7
	v20080926-1245:1.7
	v20080924-1925:1.7
	v20080722-1827:1.7
	v20080716-1642:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080610-1132:1.7
	v20080521:1.7
	v20080516-1143:1.6
	v20080508-2000:1.4
	v20080417-1610:1.4
	v20080322-0000:1.4
	v20080222-1200:1.4
	v20071108-0000:1.4
	v20070903-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.4
	v20070605-1400:1.4
	v20070601-1400:1.2
	v20070525-1500:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.7
date	2008.05.19.21.52.28;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	1c3b4831f69b4567;

1.6
date	2008.05.15.17.25.01;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	5cab482c71ed4567;

1.5
date	2008.05.15.12.54.59;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	7abf482c32a24567;

1.4
date	2007.06.05.12.59.14;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	56b46655e224567;

1.3
date	2007.06.04.18.10.00;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	1d28466455784567;

1.2
date	2007.05.28.13.43.40;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	3f0b465adc8c4567;

1.1
date	2007.05.24.09.34.42;	author atikhomirov;	state Exp;
branches;
next	;
commitid	4f9546555c314567;


desc
@@


1.7
log
@[232299] refactor migration utils: gmfgraph migration done usign dynamic package for old metamodel, unused logic from MigrationHelper and MigrationDelegate was removed
@
text
@/*
 * Copyright (c) 2007, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.common.migrate;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EFactory;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcoreFactory;
import org.eclipse.emf.ecore.EcorePackage;

public class MigrationDelegateImpl implements MigrationDelegate {
	private final EStructuralFeature myDeletedAttribute = EcoreFactory.eINSTANCE.createEAttribute();
	private boolean isMigrationApplied;

	public MigrationDelegateImpl() {
		super();
		myDeletedAttribute.setName("attributeIsDeleted"); //$NON-NLS-1$
		myDeletedAttribute.setEType(EcorePackage.eINSTANCE.getEString());
		isMigrationApplied = false;
	}

	private Map<EClassifier, Collection<String>> myDeletedAttributes = new HashMap<EClassifier, Collection<String>>();
	private Map<String, EClass> myNarrowedTypes = new HashMap<String, EClass>();
	private Map<EClass, Map<String, EStructuralFeature>> myRenamedAttributes = new HashMap<EClass, Map<String, EStructuralFeature>>();
	private Map<String, EClassifier> myRenamedTypes = new HashMap<String, EClassifier>();
	
	public void registerDeletedAttributes(EClassifier classifier, String... deletedAttrNames) {
		assert !myDeletedAttributes.containsKey(classifier);
		myDeletedAttributes.put(classifier, Arrays.asList(deletedAttrNames));
	}
	
	public void registerRenamedAttributes(EClass eClass, Map<String, EStructuralFeature> renamedAttributes) {
		myRenamedAttributes.put(eClass, renamedAttributes);
	}
	
	public void registerNarrowedAbstractType(String abstractTypeName, EClass narrowedType) {
		myNarrowedTypes.put(abstractTypeName, narrowedType);
	}
	
	public void registerRenamedType(String oldTypeName, EClassifier newType) {
		myRenamedTypes.put(oldTypeName, newType);
	}
	
	private boolean isAttributeDeleted(EClass clazz, String name) {
		Collection<String> deletedAttributes = myDeletedAttributes.get(clazz);
		boolean result = deletedAttributes != null && deletedAttributes.contains(name);
		for (Iterator<EClass> it=clazz.getEAllSuperTypes().iterator(); !result && it.hasNext();) {
			EClass nextParent = it.next();
			result = isAttributeDeleted(nextParent, name);
		}
		return result;
	}
	
	public EClass getNarrowReferenceType(String abstractTypeName) {
		return myNarrowedTypes.get(abstractTypeName);
	}

	public EStructuralFeature getRenamedFeatureFor(EClass clazz, String name) {
	    Map<String, EStructuralFeature> renamings = myRenamedAttributes.get(clazz);
		return renamings != null ? renamings.get(name) : null;
	}

	public EClassifier getRenamedType(String typeName) {
		return myRenamedTypes.get(typeName);
	}

	public boolean setValue(EObject object, EStructuralFeature feature, Object value, int position) {
		return myDeletedAttribute.equals(feature);
	}

	public EStructuralFeature getFeature(EClass eClass, String namespaceURI, String name, boolean isElement) {
		EStructuralFeature result = null;
		EStructuralFeature rename = null;
		if ((rename = getRenamedFeatureFor(eClass, name)) != null) {
			result = rename;
			fireMigrationApplied(true);
		} else if (isAttributeDeleted(eClass, name)) {
			result = myDeletedAttribute;
			fireMigrationApplied(true);
		}
		return result;
	}

	public EClassifier getType(EFactory factory, String typeName) {
		EClassifier renamedType = getRenamedType(typeName);
		if (renamedType != null) {
			fireMigrationApplied(true);
			return renamedType;
		}
		EClassifier narrowedType = getNarrowReferenceType(typeName);
		if (narrowedType != null) {
			fireMigrationApplied(true);
			return narrowedType;
		}
		return null;
	}

	public void preResolve() {
	}

	public boolean isMigrationApplied() {
		return isMigrationApplied;
	}
	
	protected void fireMigrationApplied(boolean applied) {
		isMigrationApplied = applied;
	}
	
	protected static EReference createNewReference(String name, EClass eType, boolean isContainment) {
		return createNewReference(name, eType, isContainment, 0, -1);
	}

	protected static EReference createNewReference(String name, EClass eType, boolean isContainment, int lowerBound, int upperBound) {
		EReference ref = EcoreFactory.eINSTANCE.createEReference();
		ref.setName(name);
		ref.setEType(eType);
		ref.setContainment(isContainment);
		ref.setLowerBound(lowerBound);
		ref.setUpperBound(upperBound);
		return ref;
	}

	public String getURI(String prefix, String uri) {
		return null;
	}
}@


1.6
log
@[232299] refactor CustomCopier (now FilteringCopier)
severe defect with content elements that do not need to be migrated being excluded from resulting resource
minor cleanup
@
text
@a19 1
import org.eclipse.emf.ecore.EAttribute;
a21 1
import org.eclipse.emf.ecore.EDataType;
a27 1
import org.eclipse.emf.ecore.resource.Resource;
a43 3
	private Map<EClass, Map<String, EStructuralFeature>> myTracedHierarchyFeatures = new HashMap<EClass, Map<String, EStructuralFeature>>();
	private Map<EClass, Map<String, EStructuralFeature>> myTracedHierarchyAttributes = new HashMap<EClass, Map<String, EStructuralFeature>>();
	private Resource myResource;
d62 1
a62 35
	private void registerRenamedAttribute(EClass eClass, String oldName, EStructuralFeature newStructuralFeature) {
		Map<String, EStructuralFeature> renamedAttributes = myRenamedAttributes.get(eClass);
		if (renamedAttributes == null) {
			renamedAttributes = new HashMap<String, EStructuralFeature>();
		}
		renamedAttributes.put(oldName, newStructuralFeature);
		registerRenamedAttributes(eClass, renamedAttributes);
	}
	
	/**
	 * Traced feature is a feature you use through the hierarchy as a marker, catching it in setValue and notifying of
	 * whether migration has happened or not
	 */
	public void registerTracedFeatureForHierarchy(EClass eClass, String xmlName, EStructuralFeature tracerFeature) {
		registerTracedElementForHierarchy(eClass, xmlName, tracerFeature);
		registerTracedAttributeForHierarchy(eClass, xmlName, tracerFeature);
	}
	
	public void registerTracedAttributeForHierarchy(EClass eClass, String xmlName, EStructuralFeature tracerFeature) {
		Map<String, EStructuralFeature> tracedFeatures = myTracedHierarchyAttributes.get(eClass);
		if (tracedFeatures == null) {
			myTracedHierarchyAttributes.put(eClass, tracedFeatures = new HashMap<String, EStructuralFeature>());
		}
		tracedFeatures.put(xmlName, tracerFeature);
	}
	
	private void registerTracedElementForHierarchy(EClass eClass, String xmlName, EStructuralFeature tracerFeature) {
		Map<String, EStructuralFeature> tracedFeatures = myTracedHierarchyFeatures.get(eClass);
		if (tracedFeatures == null) {
			myTracedHierarchyFeatures.put(eClass, tracedFeatures = new HashMap<String, EStructuralFeature>());
		}
		tracedFeatures.put(xmlName, tracerFeature);
	}
	
	public boolean isAttributeDeleted(EClass clazz, String name) {
a80 20
	public EStructuralFeature getTracedParentFeatureFor(EClass clazz, String name) {
	    Map<String, EStructuralFeature> tracings = myTracedHierarchyFeatures.get(clazz);
	    EStructuralFeature result = tracings != null ? tracings.get(name) : null;
		for (Iterator<EClass> it=clazz.getEAllSuperTypes().iterator(); result == null && it.hasNext();) {
			EClass nextParent = it.next();
			result = getTracedParentFeatureFor(nextParent, name);
		}
		return result;
	}
	
	public EStructuralFeature getTracedParentAttributeFor(EClass clazz, String name) {
	    Map<String, EStructuralFeature> tracings = myTracedHierarchyAttributes.get(clazz);
	    EStructuralFeature result = tracings != null ? tracings.get(name) : null;
		for (Iterator<EClass> it=clazz.getEAllSuperTypes().iterator(); result == null && it.hasNext();) {
			EClass nextParent = it.next();
			result = getTracedParentAttributeFor(nextParent, name);
		}
		return result;
	}
	
a97 8
		} else if (isElement && (rename = getTracedParentFeatureFor(eClass, name)) != null) {
			result = rename;
			// if somebody has provided a feature to trace, it is his own business to notify us of whether 
			// a migration is required and has happened, cause it is not necessary that anything has been actually changed.
		} else if (!isElement && (rename = getTracedParentAttributeFor(eClass, name)) != null) {
			result = rename;
			// if somebody has provided a feature to trace, it is his own business to notify us of whether 
			// a migration is required and has happened, cause it is not necessary that anything has been actually changed.
a115 4
	public EObject createObject(EFactory factory, EClassifier type) {
		return null;
	}
	
a118 7
	public void processObject(EObject result) {
	}

	public boolean setManyReference(EObject object, EStructuralFeature feature, Object[] values) {
		return false;
	}
	
a140 24
	protected static EAttribute createNewAttribute(String name, EDataType eType, boolean isMany) {
		return createNewAttribute(name, eType, isMany, false);
	}
	
	protected static EAttribute createNewAttribute(String name, EDataType eType, boolean isMany, boolean isObligatory) {
		EAttribute attr = EcoreFactory.eINSTANCE.createEAttribute();
		attr.setName(name);
		attr.setEType(eType);
		attr.setLowerBound(isObligatory ? 1 : 0);
		attr.setUpperBound(isMany ? -1 : 1);
		return attr;
	}

	public void setResource(Resource resource) {
		myResource = resource;
	}
	
	protected Resource getResource() {
		return myResource;
	}

	public void postLoad(){
	}

@


1.5
log
@[228913] bring back tests for old migrations, with fixes.
@
text
@a59 12
	/**
	 * Traced feature is a feature you use through the hierarchy as a marker, catching it in setValue and notifying of
	 * whether migration has happened or not
	 */
	private void registerTracedElementForHierarchy(EClass eClass, Map<String, EStructuralFeature> tracedFeature) {
		myTracedHierarchyFeatures.put(eClass, tracedFeature);
	}
	
	private void registerTracedAttributeForHierarchy(EClass eClass, Map<String, EStructuralFeature> tracedFeature) {
		myTracedHierarchyAttributes.put(eClass, tracedFeature);
	}
	
d68 1
a68 1
	public void registerRenamedAttribute(EClass eClass, String oldName, EStructuralFeature newStructuralFeature) {
d89 1
a89 1
			tracedFeatures = new HashMap<String, EStructuralFeature>();
a91 1
		registerTracedAttributeForHierarchy(eClass, tracedFeatures);
d97 1
a97 1
			tracedFeatures = new HashMap<String, EStructuralFeature>();
a99 1
		registerTracedElementForHierarchy(eClass, tracedFeatures);
@


1.4
log
@[189703] akarjakina - migration for gmfgraph, handle graphdef split into few files
@
text
@d2 1
a2 1
 * Copyright (c) 2007 Borland Software Corporation
d64 1
a64 1
	public void registerTracedElementForHierarchy(EClass eClass, Map<String, EStructuralFeature> tracedFeature) {
d68 1
a68 1
	public void registerTracedAttributeForHierarchy(EClass eClass, Map<String, EStructuralFeature> tracedFeature) {
d107 1
a107 1
	public void registerTracedElementForHierarchy(EClass eClass, String xmlName, EStructuralFeature tracerFeature) {
d257 4
@


1.3
log
@[189703] akarjakina - migration for gmfgraph, handle figure accessors
@
text
@d48 1
d64 1
a64 1
	public void registerTracedFeatureForHierarchy(EClass eClass, Map<String, EStructuralFeature> tracedFeature) {
d68 4
d94 14
d113 1
a113 1
		registerTracedFeatureForHierarchy(eClass, tracedFeatures);
d145 10
d172 5
a176 1
		} else if ((rename = getTracedParentFeatureFor(eClass, name)) != null) {
@


1.2
log
@migration support for recent gmfgraph changes
@
text
@d23 1
d30 1
a30 1
import org.eclipse.emf.ecore.xmi.XMLResource;
d47 2
a48 2
	private Map<EClass, Map<String, EStructuralFeature>> myRenamedParentAttributes = new HashMap<EClass, Map<String, EStructuralFeature>>();
	private XMLResource myResource;
d59 6
a64 2
	public void registerRenamedParentAttributes(EClass eClass, Map<String, EStructuralFeature> renamedAttributes) {
		myRenamedParentAttributes.put(eClass, renamedAttributes);
d84 8
a91 4
	public void registerRenamedParentAttribute(EClass eClass, String oldName, EStructuralFeature newStructuralFeature) {
		Map<String, EStructuralFeature> renamedAttributes = myRenamedParentAttributes.get(eClass);
		if (renamedAttributes == null) {
			renamedAttributes = new HashMap<String, EStructuralFeature>();
d93 2
a94 2
		renamedAttributes.put(oldName, newStructuralFeature);
		registerRenamedParentAttributes(eClass, renamedAttributes);
d116 3
a118 3
	public EStructuralFeature getRenamedParentFeatureFor(EClass clazz, String name) {
	    Map<String, EStructuralFeature> renamings = myRenamedParentAttributes.get(clazz);
	    EStructuralFeature result = renamings != null ? renamings.get(name) : null;
d121 1
a121 1
			result = getRenamedParentFeatureFor(nextParent, name);
d125 1
a125 1

a139 3
		} else if ((rename = getRenamedParentFeatureFor(eClass, name)) != null) {
			result = rename;
			fireMigrationApplied(true);
d143 4
d169 1
a169 5
	public String getID(EObject obj) {
		return null;
	}
	
	public void postProcess() {
d175 4
d201 1
a201 1
	protected static EAttribute createNewAttribute(String name, EClassifier eType, boolean isMany) {
d205 1
a205 1
	protected static EAttribute createNewAttribute(String name, EClassifier eType, boolean isMany, boolean isObligatory) {
d214 1
a214 1
	public void setResource(XMLResource resource) {
d218 1
a218 1
	protected XMLResource getResource() {
d221 3
@


1.1
log
@[188768] akarjakina - Migration should not rely solely on nsURIs;
MIgrationHelperDelegate was renamed to MigrationDelegate
@
text
@d20 1
d29 1
d46 2
d58 4
d79 9
d107 10
d131 3
d159 4
d178 4
d186 2
a187 2
		ref.setLowerBound(0);
		ref.setUpperBound(-1);
d190 21
@

