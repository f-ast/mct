head	1.6;
access;
symbols
	v20081015-1925:1.6
	v20080930-1130:1.6
	v20080926-1245:1.6
	v20080924-1925:1.5
	v20080722-1827:1.5
	v20080716-1642:1.5
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080610-1132:1.5
	v20080521:1.5
	v20080516-1143:1.5
	v20080508-2000:1.5
	v20080417-1610:1.5
	v20080322-0000:1.5
	v20080222-1200:1.5
	v20071108-0000:1.5
	v20070903-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070525-1500:1.4
	v20070520-1200:1.4
	v20070518-1300:1.4
	v20070427-0600:1.4
	v20070420-1000:1.4
	v20070413-1300:1.4
	v20070405-1100:1.3
	v20070330-1300:1.3
	v20060330-1300:1.3
	v20070322-1100:1.3
	v20070307-0700:1.2
	v20070301-1200:1.2
	v20070228-2000:1.2
	v20070221-1500:1.2
	v20070208-1800:1.2
	M4_20:1.2
	v20061222-1800:1.2
	v20061214-0000:1.2
	v20061120-1300:1.2
	M3_20:1.2
	v20061117-0800:1.2
	v20061013-1330:1.2
	v20060925-1700:1.1
	v20060919-0800:1.1
	M1_20:1.1
	v20060904-1500:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060626-1420:1.1
	v20060616-1200:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.6
date	2008.09.26.12.57.53;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	71df48dcdc504567;

1.5
date	2007.06.21.14.13.38;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	1e3f467a878e4567;

1.4
date	2007.04.12.11.41.44;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	1c4a461e1af74567;

1.3
date	2007.03.19.16.49.09;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	5cce45febf044567;

1.2
date	2006.09.04.18.10.53;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.13.11.17.02;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@[248327] Reconcile should respect cross-references
@
text
@/*
 * Copyright (c) 2006, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Michael Golubev (Borland) - initial API and implementation
 *    Artem Tikhomirov (Borland) - copy elements with cross-references
 */

package org.eclipse.gmf.internal.common.reconcile;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EStructuralFeature.Setting;
import org.eclipse.emf.ecore.util.EcoreUtil;

public interface Copier {
	/**
	 * Copies relevant content of the old object into the current ancestor.
	 * 
	 * @@param currentParent
	 *            the parent node in the current tree. It is guarranteed that
	 *            parent was matched with <code>old.eContainer()</code>
	 * @@param old
	 *            the element found in the old tree which does not have matched
	 *            element in the current tree
	 * @@param reconciler TODO
	 * @@return just created element copied into the current tree or
	 *         <code>null</code> if copier decided to avoid creation of
	 *         element.
	 * 
	 * NOTE: in case if this method returns created element, result is
	 * considered as "matched" with <code>old</code> automatically, without
	 * any further matchings
	 */
	public EObject copyToCurrent(EObject currentParent, EObject old, Reconciler reconciler);
	
	public static final Copier NEVER_COPY = new Copier(){
		public EObject copyToCurrent(EObject currentParent, EObject old, Reconciler reconciler) {
			return null;
		}
	};
	
	public static final Copier COMPLETE_COPY_NO_CROSSREF = new Copier() {
		public EObject copyToCurrent(EObject currentParent, EObject old, Reconciler reconciler) {
			safetyCheck(old);
			EClass currentParentEClass = currentParent.eClass();
			EObject oldParent = old.eContainer();
			EClass oldParentEClass = oldParent.eClass();
			EObject currentCopy = null;
			if (currentParentEClass.equals(oldParentEClass)) {
				currentCopy = EcoreUtil.copy(old);
				EStructuralFeature containment = old.eContainingFeature();
				Object currentValue = currentParent.eGet(containment);
				if (currentValue instanceof Collection) {
					@@SuppressWarnings("unchecked")
					Collection<Object> asCollection = (Collection<Object>) currentValue;
					asCollection.add(currentCopy);
				} else {
					currentParent.eSet(containment, currentCopy);
				}
			}
			return currentCopy;
		}

		/**
		 * It is not trivial to copy the external references while reconciling. If you need this, do not use this simple implementation.
		 */
		private void safetyCheck(EObject old) {
			if (!EcoreUtil.CrossReferencer.find(Collections.singleton(old)).isEmpty()) {
				throw new IllegalArgumentException("I am not intended to copy elements with cross references");
			}
		}
	};

	// XXX for now, keep this new implementation separate, however, won't hurt to combine it with the old one
	public static final Copier COMPLETE_COPY_WITH_CROSSREF = new Copier() {

		public EObject copyToCurrent(EObject currentParent, EObject old, Reconciler reconciler) {
			final Map<EObject, Collection<Setting>> crossReferences = EcoreUtil.CrossReferencer.find(Collections.singleton(old));
			EClass currentParentEClass = currentParent.eClass();
			EObject oldParent = old.eContainer();
			EClass oldParentEClass = oldParent.eClass();
			EObject currentCopy = null;
			if (currentParentEClass.equals(oldParentEClass)) {
				currentCopy = EcoreUtil.copy(old);
				EStructuralFeature containment = old.eContainingFeature();
				Object currentValue = currentParent.eGet(containment);
				if (currentValue instanceof Collection) {
					@@SuppressWarnings("unchecked")
					Collection<Object> asCollection = (Collection<Object>) currentValue;
					asCollection.add(currentCopy);
				} else {
					currentParent.eSet(containment, currentCopy);
				}
				reconciler.registerCrossReferencesToUpdate(crossReferences);
			}
			return currentCopy;
		}
	};
}
@


1.5
log
@fix copyright years
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 Borland Software Corporation
d11 1
d18 1
d23 1
d36 1
d45 1
a45 1
	public EObject copyToCurrent(EObject currentParent, EObject old);
d48 1
a48 1
		public EObject copyToCurrent(EObject currentParent, EObject old) {
d53 2
a54 3
	public static final Copier COMPLETE_COPY = new Copier(){
	
		public EObject copyToCurrent(EObject currentParent, EObject old) {
d60 1
a60 1
			if (currentParentEClass.equals(oldParentEClass)){
d74 1
a74 1
		
d76 1
a76 2
		 * It is not trivial to copy the external references while reconciling.
		 * If you need this, do not use this simple implementation.
d78 2
a79 2
		private void safetyCheck(EObject old){
			if (!EcoreUtil.CrossReferencer.find(Collections.singleton(old)).isEmpty()){
a82 1
	
d85 25
@


1.4
log
@typo
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.3
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d78 1
a78 1
				throw new IllegalArgumentException("I am not intended to copy elements woth cross references");
@


1.2
log
@use generics wherever possible
@
text
@a50 1
		@@SuppressWarnings("unchecked")
d61 4
a64 2
				if (currentValue instanceof Collection){
					((Collection)currentValue).add(currentCopy);
@


1.1
log
@[mgolubev] #146026 [Reconciler] User defined gmfgen Viewmap attributes should be preserved
@
text
@d51 1
@

