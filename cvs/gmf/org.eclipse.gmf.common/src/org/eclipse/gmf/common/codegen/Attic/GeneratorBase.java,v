head	1.11;
access;
symbols
	v20081015-1925:1.11
	v20080924-1925:1.11
	R1_0_maintenance:1.11.0.2
	R1_0:1.11
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2006.05.18.19.12.37;	author atikhomirov;	state dead;
branches;
next	1.10;

1.10
date	2006.05.18.12.18.08;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.17.17.16.16;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.11.19.18.46;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.11.19.16.41;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.11.18.03.24;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.29.17.21.43;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.10.15.33.53;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.10.12.49.07;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.02.13.16.19;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.20.12.18.34;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@package org.eclipse.gmf.common.codegen;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.emf.codegen.jet.JETEmitter;
import org.eclipse.emf.codegen.jet.JETException;
import org.eclipse.emf.codegen.merge.java.JControlModel;
import org.eclipse.emf.codegen.merge.java.JMerger;
import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.emf.codegen.util.CodeGenUtil.EclipseUtil;
import org.eclipse.gmf.common.UnexpectedBehaviourException;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IPackageFragment;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.ToolFactory;
import org.eclipse.jdt.core.formatter.CodeFormatter;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.text.edits.TextEdit;

public abstract class GeneratorBase implements Runnable {
	private JControlModel myJControlModel;
	private CodeFormatter myCodeFormatter;
	private IProgressMonitor myProgress = new NullProgressMonitor();

	// myDestRoot.getJavaProject().getElementName() == myDestProject.getName()
	private IPackageFragmentRoot myDestRoot;
	private IProject myDestProject;
	private final List/*<IStatus>*/ myExceptions;
	private IStatus myRunStatus = Status.CANCEL_STATUS;

	protected abstract URL getJMergeControlFile();
	
	protected abstract void customRun() throws InterruptedException, UnexpectedBehaviourException;
	
	protected abstract void setupProgressMonitor();

	/**
	 * FIXME odd. abstracts emitter away from JET but throws JETException 
	 */
	public static interface Emitter {
		public String generate(IProgressMonitor monitor, Object arguments) throws JETException ;
	}
	
	public GeneratorBase(){
		myExceptions = new LinkedList/*<IStatus>*/();
	}
	
	public void run(IProgressMonitor progress) throws InterruptedException {
		setProgressMonitor(progress);
		doRun();
	}
	
	public void run() {
		clearExceptionsList();
		try {
			doRun();
		} catch (InterruptedException ex) {
			myRunStatus = new Status(IStatus.CANCEL, "org.eclipse.gmf.common", 0, GeneratorBaseMessages.interrupted, ex);
		}
	}
	
	/**
	 * Provides information about success/failures during {@@link #run()}
	 * @@return state of the generator run, or CANCEL if generator was not yet run.
	 */
	public IStatus getRunStatus() {
		return myRunStatus;
	}

	/**
	 * Optionally, specify progressMonitor to use. Should be called prior to {@@link #run()}
	 * @@param progress
	 */
	public void setProgressMonitor(IProgressMonitor progress) {
		myProgress = progress;
	}

	protected final void handleException(CoreException ex){
		handleException(ex.getStatus());
	}
	
	protected final void handleException(IStatus status){
		myExceptions.add(status);
	}
	
	protected final IProject getDestProject() {
		return myDestProject;
	}
	
	protected final IProgressMonitor getProgress() {
		return myProgress;
	}
	
	protected final void setupProgressMonitor(String task, int total) {
		if (myProgress == null) {
			myProgress = new NullProgressMonitor();
			return;
			// no need to set it up
		}
		myProgress.beginTask(task, total);
	}
	
	protected final IProgressMonitor getNextStepMonitor() throws InterruptedException {
		if (myProgress.isCanceled()) {
			throw new InterruptedException();
		}
		return new SubProgressMonitor(myProgress, 1);
	}
	
	protected final void initializeEditorProject(String pluginId, List referencedProjects) throws UnexpectedBehaviourException, InterruptedException {
		myDestProject = ResourcesPlugin.getWorkspace().getRoot().getProject(pluginId);
		final Path srcPath = new Path('/' + myDestProject.getName() + "/src"); //$NON-NLS-1$
		final Path projectLocation = null; // use default
		final int style = org.eclipse.emf.codegen.ecore.Generator.EMF_PLUGIN_PROJECT_STYLE;
		// pluginVariables is NOT used when style is EMF_PLUGIN_PROJECT_STYLE
		final List pluginVariables = null;
		final IProgressMonitor pm = getNextStepMonitor();

		org.eclipse.emf.codegen.ecore.Generator.createEMFProject(srcPath, projectLocation, referencedProjects, pm, style, pluginVariables);

		try {
			myDestRoot = JavaCore.create(myDestProject).findPackageFragmentRoot(srcPath);
		} catch (JavaModelException ex) {
			throw new UnexpectedBehaviourException(ex.getMessage());
		}
		if (myDestRoot == null) {
			throw new UnexpectedBehaviourException("no source root can be found");
		}
	}
	
	protected final void doGenerateFile(JETEmitter emitter, IPath filePath, Object param) throws InterruptedException {
		doGenerateFile(new JetAdapter(emitter), filePath, param);
	}
	
	/**
	 * Generate ordinary file. No merge is performed at the moment.
	 * @@param emitter template to use
	 * @@param filePath - project-relative path to file, e.g. META-INF/MANIFEST.MF
	 * @@param param TODO
	 * @@throws InterruptedException
	 */
	protected final void doGenerateFile(Emitter emitter, IPath filePath, Object param) throws InterruptedException {
		assert !myDestProject.getName().equals(filePath.segment(0));
		IProgressMonitor pm = getNextStepMonitor();
		try {
			myProgress.subTask(filePath.lastSegment());
			pm.beginTask(null, 4);
			IPath containerPath = myDestProject.getFullPath().append(filePath.removeLastSegments(1));
			EclipseUtil.findOrCreateContainer(containerPath, false, (IPath) null, new SubProgressMonitor(pm, 1));
			String genText = emitter.generate(new SubProgressMonitor(pm, 1), param);
			IFile f = myDestProject.getFile(filePath);
			boolean propertyFile = "properties".equals(filePath.getFileExtension());
			String charset = propertyFile ? "ISO-8859-1" : "UTF-8";
			if (propertyFile) {
				genText = escapeUnicode(genText);
			}
			// FIXME merge!
			if (f.exists()) {
				if (!contains(f, new ByteArrayInputStream(genText.getBytes(charset)))) {
					f.setContents(new ByteArrayInputStream(genText.getBytes(charset)), true, true, new SubProgressMonitor(pm, 1));
				} else {
					pm.worked(1);
				}
			} else {
				f.create(new ByteArrayInputStream(genText.getBytes(charset)), true, new SubProgressMonitor(pm, 1));
			}
			f.getParent().refreshLocal(IResource.DEPTH_ONE, new SubProgressMonitor(pm, 1));
		} catch (JETException ex) {
			handleException(ex.getStatus());
		} catch (CoreException ex) {
			handleException(ex);
		} catch (UnsupportedEncodingException ex) {
			handleException(new Status(IStatus.ERROR, "org.eclipse.gmf.common", 0, "Unsupported encoding", ex));
		} finally {
			pm.done();
		}
	}

	private static String escapeUnicode(String text) {
	    StringBuffer result = new StringBuffer(text.length());
	    for (int i = 0, size = text.length(); i < size; ++i)
	    {
	      char character = text.charAt(i);
	      if (character > '\u00ff')
	      {
	        result.append("\\u");
	        String hex = Integer.toString(character, 16);
	        for (int j = hex.length(); j < 4; ++j)
	        {
	          result.append("0");
	        }
	        result.append(hex);
	      }
	      else
	      {
	        result.append(character);
	      }
	    }

	    return result.toString();
	}

	/**
	 * @@return <code>true</code> if the file contains the input stream contents
	 */
	protected boolean contains(IFile f, InputStream is) {
		int fc = 0;
		int ic = 0;
		InputStream fs = null;
		try {
			fs = f.getContents(true);
			while ((fc = fs.read()) == (ic = is.read()) && fc >= 0);
		} catch (CoreException ce) {
		} catch (IOException ioe) {
		} finally {
			if (fs != null) {
				try {
					fs.close();
				} catch (IOException ioe) {
				}
			}
		}
		return fc <0 && ic < 0;
	}

	/**
	 * NOTE: potential problem - packageName and className should match those specified in 
	 * the template. Besides, getQualifiedXXX helpers in diagram GenModel should also correctly
	 * return qualified class names.  
	 */
	protected final void doGenerateJavaClass(JETEmitter emitter, String packageName, String className, Object input) throws InterruptedException {
		doGenerateJavaClass(new JetAdapter(emitter, packageName), packageName, className, input);
	}

	protected final void doGenerateJavaClass(JETEmitter emitter, String qualifiedClassName, Object input) throws InterruptedException {
		doGenerateJavaClass(emitter, CodeGenUtil.getPackageName(qualifiedClassName), CodeGenUtil.getSimpleClassName(qualifiedClassName), input);
	}

	/**
	 * NOTE: potential problem - packageName and className should match those specified in 
	 * the template. Besides, getQualifiedXXX helpers in diagram GenModel should also correctly
	 * return qualified class names.  
	 */
	protected final void doGenerateJavaClass(Emitter emitter, String packageName, String className, Object input) throws InterruptedException {
		IProgressMonitor pm = getNextStepMonitor();
		try {
			myProgress.subTask(className);
			pm.beginTask(null, 4);
			String genText = emitter.generate(new SubProgressMonitor(pm, 1), input);
			IPackageFragment pf = myDestRoot.createPackageFragment(packageName, true, new SubProgressMonitor(pm, 1));
			ICompilationUnit cu = pf.getCompilationUnit(className + ".java"); //$NON-NLS-1$
			genText = mergeJavaCode(genText, cu, new SubProgressMonitor(pm, 1));
			genText = formatCode(genText);
			if (!cu.exists() || !genText.equals(cu.getSource())) {
				pf.createCompilationUnit(cu.getElementName(), genText, true, new SubProgressMonitor(pm, 1));
			} else {
				pm.worked(1);
			}
		} catch (NullPointerException ex) {
			handleException(new Status(IStatus.ERROR, "org.eclipse.gmf.common", 0, ex.getMessage(), ex));
		} catch (JETException ex) {
			handleException(ex.getStatus());
		} catch (CoreException ex) {
			handleException(ex);		
		} finally {
			pm.done();
		}
	}
	
	protected final String mergeJavaCode(String generatedText, ICompilationUnit oldCU, IProgressMonitor pm) throws JavaModelException {
		pm.beginTask(GeneratorBaseMessages.merge, 1);
		try {
			if (oldCU != null && oldCU.exists() && getJControlModel() != null) {
				JMerger jMerge = new JMerger(getJControlModel());
				jMerge.setSourceCompilationUnit(jMerge.createCompilationUnitForContents(generatedText));
				jMerge.setTargetCompilationUnit(jMerge.createCompilationUnitForContents(oldCU.getSource()));
				jMerge.merge();
				return jMerge.getTargetCompilationUnitContents();
			} else {
				return generatedText;
			}
		} finally {
			pm.done();
		}
	}

	protected final String formatCode(String text) {
		IDocument doc = new Document(text);
		TextEdit edit = getCodeFormatter().format(CodeFormatter.K_COMPILATION_UNIT, doc.get(), 0, doc.get().length(), 0, null);

		try {
			// check if text formatted successfully 
			if(edit != null) {
				edit.apply(doc);
				text = doc.get();				
			}		
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return text;
	}

	private void doRun() throws InterruptedException {
		try {
			setupProgressMonitor();
			customRun();
			myRunStatus = getExceptionsStatus();
			// XXX consider catching CCE and provide "programming error" to help users with their templates
		} catch (NullPointerException ex) {
			myRunStatus = new Status(IStatus.ERROR, "org.eclipse.gmf.common", 0, NullPointerException.class.getName(), ex);
		} catch (UnexpectedBehaviourException ex) {
			myRunStatus = new Status(Status.ERROR, "org.eclipse.gmf.common", 0, GeneratorBaseMessages.unexpected, ex);
		} finally {
			getProgress().done();
			clearExceptionsList();
		}
	}

	private JControlModel getJControlModel() {
		if (myJControlModel == null) {
			URL controlFile = getJMergeControlFile();
			if (controlFile != null){
				myJControlModel = new JControlModel();
				myJControlModel.initialize(CodeGenUtil.instantiateFacadeHelper(JMerger.DEFAULT_FACADE_HELPER_CLASS), controlFile.toString());
				if (!myJControlModel.canMerge()){
					throw new IllegalStateException("Can not initialize JControlModel");
				}
			}
		}
		return myJControlModel;
	}

	private CodeFormatter getCodeFormatter() {
		if (myCodeFormatter == null) {
			myCodeFormatter = ToolFactory.createCodeFormatter(null);
		}
		return myCodeFormatter;
	}
	
	private final void clearExceptionsList(){
		myExceptions.clear();
	}
	
	private final IStatus getExceptionsStatus(){
		if (myExceptions == null || myExceptions.isEmpty()){
			return Status.OK_STATUS;
		} else {
			IStatus[] s = (IStatus[]) myExceptions.toArray(new IStatus[myExceptions.size()]);
			return new MultiStatus("org.eclipse.gmf.common", 0, s, GeneratorBaseMessages.problems, null);
		}
	}

	/**
	 * FIXME assumes emitters to get array of two objects as argument
	 */
	private static class JetAdapter implements Emitter {
		private final JETEmitter myEmitter;
		private final ImportAssistant myImportAssistant;

		public JetAdapter(JETEmitter emitter, ImportAssistant importAssistant){
			myEmitter = emitter;
			myImportAssistant = importAssistant;
		}
		
		public JetAdapter(JETEmitter emitter){
			this(emitter, (ImportAssistant)null);
		}
		
		public JetAdapter(JETEmitter emitter, String packageName){
			this(emitter, new ImportUtil(packageName));
		}
		
		public String generate(IProgressMonitor monitor, Object param) throws JETException {
			Object[] jetArgs = shouldAddImports() ? 
					new Object[] {new Object[] {param, myImportAssistant}} :
					new Object[] {param};
			return myEmitter.generate(monitor, jetArgs);
		}

		private boolean shouldAddImports() {
			return myImportAssistant != null;
		}
	}

	
}
@


1.10
log
@better progress reporting during codegen
@
text
@@


1.9
log
@remove deprecated and unused code
@
text
@d168 2
a169 1
			pm.beginTask(filePath.lastSegment(), 4);
d269 2
a270 1
			pm.beginTask(className, 4);
@


1.8
log
@refactor exception thrown during generation. There's nothing we could do about JETException, so why treat it differently from Unexpected
@
text
@a10 3
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

d26 2
a27 2
import org.eclipse.emf.codegen.jmerge.JControlModel;
import org.eclipse.emf.codegen.jmerge.JMerger;
d29 1
a40 1
import org.w3c.dom.Element;
d170 1
a170 1
			CodeGenUtil.findOrCreateContainer(containerPath, false, (IPath) null, new SubProgressMonitor(pm, 1));
d272 1
a272 5
			if (cu.exists() && canMerge()) {
				genText = merge(genText, cu.getSource(), new SubProgressMonitor(pm, 1));
			} else {
				pm.worked(1);
			}
d290 14
a303 7
	protected final boolean canMerge() {
		return getJControlModel() != null;
	}

	protected final String merge(String generatedText, String oldContents, IProgressMonitor pm) {
		if (!canMerge()){
			throw new IllegalStateException("Can not initialize JMerge model");
a304 8
		pm.beginTask(GeneratorBaseMessages.merge, 1);
		JMerger jMerge = new JMerger();
		jMerge.setControlModel(getJControlModel());
		jMerge.setSourceCompilationUnit(jMerge.createCompilationUnitForContents(generatedText));
		jMerge.setTargetCompilationUnit(jMerge.createCompilationUnitForContents(oldContents));
		jMerge.merge();
		pm.done();
		return jMerge.getTargetCompilationUnitContents();
d343 5
a347 1
				myJControlModel = new JControlModel(controlFile.toString());
a352 12
	private JControlModel createEmptyJControlModel() {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		org.w3c.dom.Document document;
		try {
			document = factory.newDocumentBuilder().newDocument();
		} catch (ParserConfigurationException e) {
			throw new RuntimeException("Can not initialize DOM", e);
		}
		Element root = (Element)document.appendChild(document.createElement("fake"));
		return new JControlModel(root);
	}

@


1.7
log
@refactor exception thrown during generation. There's nothing we could do about JETException, so why treat it differently from Unexpected
@
text
@d156 1
a156 1
	protected final void doGenerateFile(JETEmitter emitter, IPath filePath, Object param) throws UnexpectedBehaviourException, InterruptedException {
@


1.6
log
@handy method to pass qualified class name and rely on gmfgen implementation to use correct one
@
text
@d58 1
a58 1
	protected abstract void customRun() throws InterruptedException, JETException, UnexpectedBehaviourException;
d61 4
a64 1
		
a106 4
	protected final void handleException(UnexpectedBehaviourException e){
		
	}
	
d156 1
a156 1
	protected final void doGenerateFile(JETEmitter emitter, IPath filePath, Object param) throws JETException, InterruptedException {
a164 1
	 * @@throws JETException
d167 1
a167 1
	protected final void doGenerateFile(Emitter emitter, IPath filePath, Object param) throws JETException, InterruptedException {
d192 2
d336 1
a338 2
		} catch (JETException ex) {
			myRunStatus = ex.getStatus();
@


1.5
log
@#132545 Bidi3.2: [HCG]plugin.xml is not encoded in UTF-8
#132524 Bidi3.2: [HCG]Manifest is not generated in UTF-8 encoding
@
text
@d258 5
a262 1
	
d390 3
@


1.4
log
@check that compilation unit exists
@
text
@d6 1
d80 1
a80 1
			myRunStatus = new Status(IStatus.CANCEL, "org.eclipse.gmf.codegen", 0, GeneratorBaseMessages.interrupted, ex);
d178 5
d185 2
a186 2
				if (!contains(f, new ByteArrayInputStream(genText.getBytes()))) {
					f.setContents(new ByteArrayInputStream(genText.getBytes()), true, true, new SubProgressMonitor(pm, 1));
d191 1
a191 1
				f.create(new ByteArrayInputStream(genText.getBytes()), true, new SubProgressMonitor(pm, 1));
d196 2
d203 24
d283 1
a283 1
			handleException(new Status(IStatus.ERROR, "org.eclipse.gmf.codegen", 0, ex.getMessage(), ex));
d333 1
a333 1
			myRunStatus = new Status(IStatus.ERROR, "org.eclipse.gmf.codegen", 0, NullPointerException.class.getName(), ex);
d337 1
a337 1
			myRunStatus = new Status(Status.ERROR, "org.eclipse.gmf.codegen", 0, GeneratorBaseMessages.unexpected, ex);
d382 1
a382 1
			return new MultiStatus("org.eclipse.gmf.codegen", 0, s, GeneratorBaseMessages.problems, null);
@


1.3
log
@do not modify files with the same content
@
text
@d245 1
a245 1
			if (!genText.equals(cu.getSource())) {
@


1.2
log
@[mgolubev] #128779 generate figures as standalone plugin
#129362 - respect plug-in dependencies imposed by figure fqn switch
@
text
@d4 2
d179 5
a183 1
				f.setContents(new ByteArrayInputStream(genText.getBytes()), true, true, new SubProgressMonitor(pm, 1));
d194 24
a217 1
	
d244 6
a249 1
			pf.createCompilationUnit(cu.getElementName(), formatCode(genText), true, new SubProgressMonitor(pm, 1));
d261 1
a261 1
	protected final boolean canMerge(){
@


1.1
log
@[michael.golubev] #128620 Split org.eclipse.gmf.codegen.util.Generator
@
text
@d210 1
a210 1
			if (cu.exists()) {
d226 4
d232 3
d281 3
a283 1
			myJControlModel = controlFile == null ? createEmptyJControlModel() : new JControlModel(controlFile.toString());
@

