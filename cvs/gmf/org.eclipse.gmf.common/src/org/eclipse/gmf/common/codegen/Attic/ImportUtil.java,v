head	1.5;
access;
symbols
	v20081015-1925:1.5
	v20080924-1925:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	I20060424-0500:1.4
	I20060424-0300:1.4
	M6_10:1.4
	I20060407-1200:1.4
	I20060331-1000:1.4
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.5
date	2006.05.18.19.12.37;	author atikhomirov;	state dead;
branches;
next	1.4;

1.4
date	2006.03.17.16.52.38;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.07.15.45.39;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.08.17.15.23;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.04.22.13.27;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@/*
 * Copyright (c) 2005 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.common.codegen;

import java.util.Iterator;

import org.eclipse.emf.codegen.ecore.genmodel.GenPackage;
import org.eclipse.emf.codegen.util.ImportManager;
import org.eclipse.gmf.common.codegen.ImportAssistant;

/**
 * Copy of GenModelImpl functionality
 */
public class ImportUtil implements ImportAssistant {
	private final ImportManager myImportManager;
	private final String myPackageName;

	private StringBuffer importStringBuffer;

	private int importInsertionPoint;

	public ImportUtil(String compilationUnitPackage) {
		myImportManager = new ImportManager(compilationUnitPackage);
		myPackageName = compilationUnitPackage;
	}

	public String getPackageName() {
		return myPackageName;
	}

	public void emitPackageStatement(StringBuffer stringBuffer) {
		if (myPackageName == null || myPackageName.trim().length() == 0) {
			return;
		}
		stringBuffer.append("\npackage ");
		stringBuffer.append(myPackageName);
		stringBuffer.append(';');
	}

	public void markImportLocation(StringBuffer stringBuffer, GenPackage genPackage) {
		markImportLocation(stringBuffer);
		myImportManager.addJavaLangImports(genPackage.getJavaLangConflicts());
	}

	public void markImportLocation(StringBuffer stringBuffer) {
		importStringBuffer = stringBuffer;
		importInsertionPoint = stringBuffer.length();
		myImportManager.addCompilationUnitImports(stringBuffer.toString());
	}

	public void emitSortedImports() {
		String NL = System.getProperties().getProperty("line.separator");
		StringBuffer importsBuf = new StringBuffer();

		String previousPackageName = null;
		for (Iterator iter = myImportManager.getImports().iterator(); iter.hasNext();) {
			String importName = (String) iter.next();
			int index = importName.lastIndexOf(".");
			if (index != -1) {
				String packageName = importName.substring(0, index);
				if (previousPackageName != null && !previousPackageName.equals(packageName)) {
					importsBuf.append(NL);
				}
				previousPackageName = packageName;
			}
			importsBuf.append(NL + "import " + importName + ";");
		}

		importStringBuffer.insert(importInsertionPoint, importsBuf.toString());
	}

	// one from GenModelImpl
	public String getImportedName(String qualifiedName) {
		int index = qualifiedName.indexOf("$");
		myImportManager.addImport(index == -1 ? qualifiedName : qualifiedName.substring(0, index));
		return myImportManager.getImportedName(qualifiedName);
	}

	public void addImport(String qualifiedName) {
		myImportManager.addImport(qualifiedName);
	}

	public void registerInnerClass(String innerClassName) {
		myImportManager.addPseudoImport(innerClassName);
	}

	public void addImport(String packageName, String shortName) {
		myImportManager.addImport(packageName, shortName);
	}
}
@


1.4
log
@Class names of Figures generated as inner classes may clash with well-known classes, thus we have to make sure we avoid that
@
text
@@


1.3
log
@#130100 Allow to specify copyright text in gmfgen model
@
text
@d92 4
@


1.2
log
@ImportManager has to know its package anyway, so why not use it to emit appropriate statement?
Besides, package fragment is external to template, template has no control over file placement, thus we'd better pass package name as an argument
@
text
@d44 1
a44 1
		stringBuffer.append("package ");
@


1.1
log
@shared functionality among tooling plug-ins. Opposed to bridge, which combines everything we got in tooling
@
text
@d25 1
d33 14
@

