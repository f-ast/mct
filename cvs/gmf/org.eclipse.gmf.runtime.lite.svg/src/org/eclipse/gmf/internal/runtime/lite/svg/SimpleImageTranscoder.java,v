head	1.5;
access;
symbols
	v20080813-1520:1.5
	v20080807-1333:1.1;
locks; strict;
comment	@# @;


1.5
date	2008.08.12.22.45.37;	author dstadnik;	state Exp;
branches;
next	1.4;
commitid	470e48a212824567;

1.4
date	2008.08.12.13.37.43;	author dstadnik;	state Exp;
branches;
next	1.3;
commitid	4ff648a192234567;

1.3
date	2008.08.08.13.27.22;	author dstadnik;	state Exp;
branches;
next	1.2;
commitid	7f6f489c49b84567;

1.2
date	2008.08.08.12.33.15;	author dstadnik;	state dead;
branches;
next	1.1;
commitid	2ad1489c3d084567;

1.1
date	2008.07.29.12.27.50;	author dstadnik;	state Exp;
branches;
next	;
commitid	5b3f488f0cc04567;


desc
@@


1.5
log
@[243565] infer antialias value from graphics
@
text
@/**
 * Copyright (c) 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik - initial API and implementation
 */
package org.eclipse.gmf.internal.runtime.lite.svg;

import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;

import org.apache.batik.bridge.BridgeContext;
import org.apache.batik.dom.svg.SVGOMDocument;
import org.apache.batik.gvt.renderer.ImageRenderer;
import org.apache.batik.gvt.renderer.StaticRenderer;
import org.apache.batik.transcoder.SVGAbstractTranscoder;
import org.apache.batik.transcoder.TranscoderException;
import org.apache.batik.transcoder.TranscoderInput;
import org.apache.batik.transcoder.TranscoderOutput;
import org.apache.batik.transcoder.image.ImageTranscoder;
import org.w3c.dom.Document;

public class SimpleImageTranscoder extends SVGAbstractTranscoder {

	private BufferedImage bufferedImage;
	private Document document;
	private int canvasWidth = -1, canvasHeight = -1;
	private Rectangle2D canvasAOI;
	private RenderingHints renderingHints;

	public SimpleImageTranscoder(Document document) {
		this.document = document;
		renderingHints = new RenderingHints(null);
	}

	public final Document getDocument() {
		return document;
	}

	public final RenderingHints getRenderingHints() {
		return renderingHints;
	}

	public final int getCanvasWidth() {
		return canvasWidth;
	}

	public final int getCanvasHeight() {
		return canvasHeight;
	}

	public void setCanvasSize(int width, int height) {
		if (this.canvasWidth == width && this.canvasHeight == height) {
			return;
		}
		this.canvasWidth = width;
		this.canvasHeight = height;
		contentChanged();
	}

	public final Rectangle2D getCanvasAreaOfInterest() {
		if (canvasAOI == null) {
			return null;
		}
		Rectangle2D result = new Rectangle2D.Float();
		result.setRect(canvasAOI);
		return result;
	}

	public void setCanvasAreaOfInterest(Rectangle2D value) {
		if (value == null) {
			if (canvasAOI == null) {
				return;
			}
			canvasAOI = null;
			contentChanged();
			return;
		}
		if (value.equals(canvasAOI)) {
			return;
		}
		canvasAOI = new Rectangle2D.Float();
		canvasAOI.setRect(value);
		contentChanged();
	}

	/**
	 * Call before querying for CSS properties. If document has CSS engine installed returns null. Client is responsible to
	 * dispose bridge context if it was returned by this method.
	 */
	public BridgeContext initCSSEngine() {
		if (this.document == null) {
			return null;
		}
		SVGOMDocument sd = (SVGOMDocument) this.document;
		if (sd.getCSSEngine() != null) {
			return null;
		}
		class BridgeContextEx extends BridgeContext {

			public BridgeContextEx() {
				super(SimpleImageTranscoder.this.userAgent);
				BridgeContextEx.this.setDocument(SimpleImageTranscoder.this.document);
				BridgeContextEx.this.initializeDocument(SimpleImageTranscoder.this.document);
			}
		}
		return new BridgeContextEx();
	}

	public void contentChanged() {
		bufferedImage = null;
	}

	private void updateImage() {
		if (document == null) {
			return;
		}
		try {
			if (canvasWidth >= 0) {
				addTranscodingHint(ImageTranscoder.KEY_WIDTH, new Float(canvasWidth));
			} else {
				removeTranscodingHint(ImageTranscoder.KEY_WIDTH);
			}
			if (canvasHeight >= 0) {
				addTranscodingHint(ImageTranscoder.KEY_HEIGHT, new Float(canvasHeight));
			} else {
				removeTranscodingHint(ImageTranscoder.KEY_HEIGHT);
			}
			if (canvasAOI != null) {
				addTranscodingHint(ImageTranscoder.KEY_AOI, canvasAOI);
			} else {
				removeTranscodingHint(ImageTranscoder.KEY_AOI);
			}
			transcode(new TranscoderInput(document), new TranscoderOutput());
		} catch (TranscoderException e) {
			Activator.logError("Error transcoding SVG image", e);
		}
	}

	protected void transcode(Document document, String uri, TranscoderOutput output) throws TranscoderException {
		super.transcode(document, uri, output);
		int w = (int) (width + 0.5);
		int h = (int) (height + 0.5);
		ImageRenderer renderer = createImageRenderer();
		renderer.updateOffScreen(w, h);
		// curTxf.translate(0.5, 0.5);
		renderer.setTransform(curTxf);
		renderer.setTree(this.root);
		this.root = null; // We're done with it...
		try {
			Shape raoi = new Rectangle2D.Float(0, 0, width, height);
			// Warning: the renderer's AOI must be in user space
			renderer.repaint(curTxf.createInverse().createTransformedShape(raoi));
			bufferedImage = renderer.getOffScreen();
		} catch (Exception ex) {
			throw new TranscoderException(ex);
		}
	}

	protected ImageRenderer createImageRenderer() {
		StaticRenderer renderer = new StaticRenderer();
		renderer.getRenderingHints().add(renderingHints);
		return renderer;
	}

	public final BufferedImage getBufferedImage() {
		if (bufferedImage == null) {
			updateImage();
		}
		return bufferedImage;
	}
}
@


1.4
log
@[243051] manage canvas size
@
text
@d14 2
d21 3
d30 1
a30 1
public class SimpleImageTranscoder extends ImageTranscoder {
d36 1
d40 1
d47 4
d147 26
a178 10

	@@Override
	public final BufferedImage createImage(int width, int height) {
		return new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
	}

	@@Override
	public final void writeImage(BufferedImage img, TranscoderOutput output) throws TranscoderException {
		bufferedImage = img;
	}
@


1.3
log
@[243571] always render using buffered image
@
text
@d14 1
d20 1
d28 54
d87 5
a91 2
	public BridgeContext initCSSEngine(final Document d) {
		SVGOMDocument sd = (SVGOMDocument) d;
d99 2
a100 2
				BridgeContextEx.this.setDocument(d);
				BridgeContextEx.this.initializeDocument(d);
d106 34
a139 1
	public BufferedImage getBufferedImage() {
d144 1
a144 1
	public BufferedImage createImage(int width, int height) {
d149 1
a149 1
	public void writeImage(BufferedImage img, TranscoderOutput output) throws TranscoderException {
@


1.2
log
@[243571] always render using buffered image
@
text
@d16 2
d21 1
d27 20
d51 3
a53 2
	public BufferedImage createImage(int w, int h) {
		return bufferedImage = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
d56 1
d58 1
@


1.1
log
@add lightweight SVG support
@
text
@@

