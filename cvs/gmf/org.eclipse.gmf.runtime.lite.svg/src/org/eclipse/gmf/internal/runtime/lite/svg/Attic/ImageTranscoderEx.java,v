head	1.4;
access;
symbols
	v20080813-1520:1.4
	v20080807-1333:1.2;
locks; strict;
comment	@# @;


1.4
date	2008.08.08.13.27.22;	author dstadnik;	state dead;
branches;
next	1.3;
commitid	7f6f489c49b84567;

1.3
date	2008.08.08.12.33.15;	author dstadnik;	state Exp;
branches;
next	1.2;
commitid	2ad1489c3d084567;

1.2
date	2008.08.07.08.57.19;	author dstadnik;	state Exp;
branches;
next	1.1;
commitid	3b47489ab8e44567;

1.1
date	2008.07.29.12.27.51;	author dstadnik;	state Exp;
branches;
next	;
commitid	5b3f488f0cc04567;


desc
@@


1.4
log
@[243571] always render using buffered image
@
text
@/**
 * Copyright (c) 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik - initial API and implementation
 */
package org.eclipse.gmf.internal.runtime.lite.svg;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;

import org.apache.batik.bridge.BridgeContext;
import org.apache.batik.dom.svg.SVGOMDocument;
import org.apache.batik.ext.awt.image.GraphicsUtil;
import org.apache.batik.transcoder.SVGAbstractTranscoder;
import org.apache.batik.transcoder.TranscoderException;
import org.apache.batik.transcoder.TranscoderOutput;
import org.w3c.dom.Document;

public class ImageTranscoderEx extends SVGAbstractTranscoder {

	private BufferedImage bufferedImage;

	/**
	 * Call before querying for CSS properties. If document has CSS engine installed returns null. Client is responsible to
	 * dispose bridge context if it was returned by this method.
	 */
	public BridgeContext initCSSEngine(final Document d) {
		SVGOMDocument sd = (SVGOMDocument) d;
		if (sd.getCSSEngine() != null) {
			return null;
		}
		class BridgeContextEx extends BridgeContext {

			public BridgeContextEx() {
				super(ImageTranscoderEx.this.userAgent);
				BridgeContextEx.this.setDocument(d);
				BridgeContextEx.this.initializeDocument(d);
			}
		}
		return new BridgeContextEx();
	}

	protected void transcode(Document document, String uri, TranscoderOutput output) throws TranscoderException {
		super.transcode(document, uri, output);
		Graphics2D g2d = createGraphics();
		g2d.transform(curTxf);
		root.paint(g2d);
		g2d.dispose();
	}

	protected Graphics2D createGraphics() {
		int w = (int) (width + 0.5);
		int h = (int) (height + 0.5);
		bufferedImage = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g2d = GraphicsUtil.createGraphics(bufferedImage);
		return g2d;
	}

	public BufferedImage getBufferedImage() {
		return bufferedImage;
	}
}
@


1.3
log
@[243571] always render using buffered image
@
text
@@


1.2
log
@[243391] init css engine
@
text
@a14 3
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;
a15 2
import java.net.MalformedURLException;
import java.net.URL;
a16 1
import org.apache.batik.bridge.BaseScriptingEnvironment;
a17 3
import org.apache.batik.bridge.BridgeException;
import org.apache.batik.bridge.GVTBuilder;
import org.apache.batik.dom.svg.SVGDOMImplementation;
a18 1
import org.apache.batik.dom.util.DOMUtilities;
d20 1
a20 2
import org.apache.batik.gvt.CanvasGraphicsNode;
import org.apache.batik.gvt.GraphicsNode;
a22 3
import org.apache.batik.transcoder.image.ImageTranscoder;
import org.eclipse.draw2d.Graphics;
import org.w3c.dom.DOMImplementation;
a23 1
import org.w3c.dom.svg.SVGSVGElement;
d25 1
a25 1
public class ImageTranscoderEx extends ImageTranscoder {
a26 1
	private Graphics draw2dGraphics;
a29 7
	 * Set Draw2D graphics to use for transcoding. If it is null then result is in bufferedImage.
	 */
	public void setDraw2DGraphics(Graphics g) {
		this.draw2dGraphics = g;
	}

	/**
a48 81
	/**
	 * buildGVTTree This method builds the GVT tree that is used to render the SVG data.
	 * 
	 * @@param svgDoc SVGOMDocument representing the physical SVG document.
	 * @@param context BridgeContext containing information of the render to occur.
	 * @@return GraphicsNode object.
	 * @@throws TranscoderException thrown if a BridgeException occurs when building the root object.
	 */
	protected GraphicsNode buildGVTTree(SVGOMDocument svgDoc, BridgeContext context) throws TranscoderException {
		GVTBuilder gvtBuilder = new GVTBuilder();
		try {
			return gvtBuilder.build(context, svgDoc);
		} catch (BridgeException ex) {
			throw new TranscoderException(ex);
		}
	}

	/**
	 * calculateSizeTransform Calculates the transformation matrix that is applied during the render operation. Specifically,
	 * the transformation for changing the size of the rendered data.
	 * 
	 * @@param svgRoot SVGSVGElement root element of the SVG tree.
	 * @@param gvtRoot GraphicsNode graphic node root
	 * @@param docWidth float width values of the original vector.
	 * @@param docHeight float height values of the original vector.
	 * @@param newWidth float width values of the rendered image.
	 * @@param newHeight float height values of the rendered image.
	 * @@return AffineTransform object that represents the size transformation to take place.
	 * @@throws TranscoderException thrown if a BridgeException occurs when building the root object.
	 */
	protected AffineTransform calculateSizeTransform(SVGSVGElement svgRoot, GraphicsNode gvtRoot, float docWidth,
			float docHeight, float newWidth, float newHeight) throws TranscoderException {
		AffineTransform Px;
		float xscale = newWidth / docWidth;
		float yscale = newHeight / docHeight;
		Px = AffineTransform.getScaleInstance(xscale, yscale);

		// take the AOI into account if any
		if (hints.containsKey(KEY_AOI)) {
			Rectangle2D aoi = (Rectangle2D) hints.get(KEY_AOI);
			// transform the AOI into the image's coordinate system
			aoi = Px.createTransformedShape(aoi).getBounds2D();
			AffineTransform Mx = new AffineTransform();
			double sx = newWidth / aoi.getWidth();
			double sy = newHeight / aoi.getHeight();
			Mx.scale(sx, sy);
			double tx = -aoi.getX();
			double ty = -aoi.getY();
			Mx.translate(tx, ty);

			// take the AOI transformation matrix into account
			// we apply first the preserveAspectRatio matrix
			Px.preConcatenate(Mx);
		}

		CanvasGraphicsNode cgn = getCanvasGraphicsNode(gvtRoot);
		if (cgn != null) {
			cgn.setViewingTransform(Px);
			curTxf = new AffineTransform();
		} else {
			curTxf = Px;
		}

		return curTxf;
	}

	private boolean shouldCopyDocument(Document document) {
		if (!(document.getImplementation() instanceof SVGDOMImplementation)) {
			return true;
		}
		return false;
	}

	/**
	 * Transcodes the specified Document as an image in the specified output.
	 * 
	 * @@param document the document to transcode
	 * @@param uri the uri of the document or null if any
	 * @@param output the ouput where to transcode
	 * @@exception TranscoderException if an error occured while transcoding
	 */
d50 5
a54 58
		if (shouldCopyDocument(document)) {
			DOMImplementation impl;
			impl = SVGDOMImplementation.getDOMImplementation();
			document = DOMUtilities.deepCloneDocument(document, impl);
			if (uri != null) {
				try {
					URL url = new URL(uri);
					((SVGOMDocument) document).setURLObject(url);
				} catch (MalformedURLException mue) {
					//TODO: Implement error handling
				}
			}
		}

		ctx = new BridgeContext(userAgent);
		SVGOMDocument svgDoc = (SVGOMDocument) document;
		SVGSVGElement svgRoot = svgDoc.getRootElement();

		// build the GVT tree
		builder = new GVTBuilder();
		// flag that indicates if the document is dynamic
		boolean isDynamic = (hints.containsKey(KEY_EXECUTE_ONLOAD) && ((Boolean) hints.get(KEY_EXECUTE_ONLOAD)).booleanValue() && BaseScriptingEnvironment
				.isDynamicDocument(ctx, svgDoc));

		if (isDynamic) {
			ctx.setDynamicState(BridgeContext.DYNAMIC);
		}

		GraphicsNode gvtRoot;
		try {
			gvtRoot = builder.build(ctx, svgDoc);
		} catch (BridgeException ex) {
			throw new TranscoderException(ex);
		}

		// get the 'width' and 'height' attributes of the SVG document
		float docWidth = (float) ctx.getDocumentSize().getWidth();
		float docHeight = (float) ctx.getDocumentSize().getHeight();

		setImageSize(docWidth, docHeight);

		//compute the transformation matrix
		AffineTransform Px = calculateSizeTransform(svgRoot, gvtRoot, docWidth, docHeight, width, height);

		gvtRoot = renderImage(output, gvtRoot, Px, (int) width, (int) height);

		this.root = gvtRoot;
	}

	private GraphicsNode renderImage(TranscoderOutput output, GraphicsNode gvtRoot, AffineTransform Px, int w, int h)
			throws TranscoderException {
		Graphics2D g2d = createGraphics(w, h);
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		g2d.clip(new java.awt.Rectangle(0, 0, w, h));
		g2d.transform(Px);
		gvtRoot.paint(g2d);
		postRenderImage(g2d);
		return null;
d57 4
a60 5
	protected Graphics2D createGraphics(int w, int h) {
		if (draw2dGraphics != null) {
			return new SVGGraphics2D(draw2dGraphics);
		}
		bufferedImage = createImage(w, h);
a64 4
	protected void postRenderImage(Graphics2D g2d) {
		g2d.dispose();
	}

a67 7

	public BufferedImage createImage(int w, int h) {
		return new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
	}

	public void writeImage(BufferedImage img, TranscoderOutput output) throws TranscoderException {
	}
@


1.1
log
@add lightweight SVG support
@
text
@d35 1
d42 1
d46 27
d215 3
@

