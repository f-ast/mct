head	1.11;
access;
symbols
	v20080813-1520:1.11
	v20080807-1333:1.7;
locks; strict;
comment	@# @;


1.11
date	2008.08.12.22.45.37;	author dstadnik;	state Exp;
branches;
next	1.10;
commitid	470e48a212824567;

1.10
date	2008.08.12.13.37.42;	author dstadnik;	state Exp;
branches;
next	1.9;
commitid	4ff648a192234567;

1.9
date	2008.08.08.13.27.22;	author dstadnik;	state Exp;
branches;
next	1.8;
commitid	7f6f489c49b84567;

1.8
date	2008.08.08.12.33.14;	author dstadnik;	state Exp;
branches;
next	1.7;
commitid	2ad1489c3d084567;

1.7
date	2008.08.07.13.29.42;	author dstadnik;	state Exp;
branches;
next	1.6;
commitid	6559489af8c44567;

1.6
date	2008.08.07.08.57.18;	author dstadnik;	state Exp;
branches;
next	1.5;
commitid	3b47489ab8e44567;

1.5
date	2008.08.05.12.52.14;	author dstadnik;	state Exp;
branches;
next	1.4;
commitid	20d948984cfc4567;

1.4
date	2008.08.05.11.45.20;	author dstadnik;	state Exp;
branches;
next	1.3;
commitid	6fdd48983d4e4567;

1.3
date	2008.08.04.12.45.29;	author dstadnik;	state Exp;
branches;
next	1.2;
commitid	6c3d4896f9e84567;

1.2
date	2008.07.30.21.34.56;	author dstadnik;	state Exp;
branches;
next	1.1;
commitid	fca4890de7d4567;

1.1
date	2008.07.29.12.27.50;	author dstadnik;	state Exp;
branches;
next	;
commitid	5b3f488f0cc04567;


desc
@@


1.11
log
@[243565] infer antialias value from graphics
@
text
@/**
 * Copyright (c) 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik - initial API and implementation
 */
package org.eclipse.gmf.runtime.lite.svg;

import java.awt.RenderingHints;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.io.IOException;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.apache.batik.bridge.BridgeContext;
import org.apache.batik.dom.svg.SAXSVGDocumentFactory;
import org.apache.batik.util.XMLResourceDescriptor;
import org.eclipse.draw2d.Figure;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.internal.runtime.lite.svg.Activator;
import org.eclipse.gmf.internal.runtime.lite.svg.InferringNamespaceContext;
import org.eclipse.gmf.internal.runtime.lite.svg.SimpleImageTranscoder;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Device;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
import org.eclipse.swt.graphics.PaletteData;
import org.eclipse.swt.widgets.Display;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

public class SVGFigure extends Figure {

	private String uri;
	private boolean failedToLoadDocument, specifyCanvasWidth = true, specifyCanvasHeight = true;
	private SimpleImageTranscoder transcoder;

	public final String getURI() {
		return uri;
	}

	public final void setURI(String uri) {
		setURI(uri, true);
	}

	public void setURI(String uri, boolean loadOnDemand) {
		this.uri = uri;
		transcoder = null;
		failedToLoadDocument = false;
		if (loadOnDemand) {
			loadDocument();
		}
	}

	private void loadDocument() {
		transcoder = null;
		failedToLoadDocument = true;
		if (uri == null) {
			return;
		}
		String parser = XMLResourceDescriptor.getXMLParserClassName();
		SAXSVGDocumentFactory factory = new SAXSVGDocumentFactory(parser);
		try {
			Document document = factory.createDocument(uri);
			transcoder = new SimpleImageTranscoder(document);
			failedToLoadDocument = false;
		} catch (IOException e) {
			Activator.logError("Error loading SVG file", e);
		}
	}

	protected final Document getDocument() {
		if (failedToLoadDocument) {
			return null;
		}
		if (transcoder == null) {
			loadDocument();
		}
		return transcoder == null ? null : transcoder.getDocument();
	}

	/**
	 * Returns true if document was loaded without errors; tries to load document if needed.
	 */
	public final boolean checkContentAvailable() {
		return getDocument() != null;
	}

	private XPath getXPath() {
		XPath xpath = XPathFactory.newInstance().newXPath();
		xpath.setNamespaceContext(new InferringNamespaceContext(getDocument().getDocumentElement()));
		return xpath;
	}

	/**
	 * Executes XPath query over the SVG document.
	 */
	protected final NodeList getNodes(String query) {
		Document document = getDocument();
		if (document != null) {
			try {
				return (NodeList) getXPath().evaluate(query, document, XPathConstants.NODESET);
			} catch (XPathExpressionException e) {
				throw new RuntimeException(e);
			}
		}
		return null;
	}

	/**
	 * Reads color value from the document.
	 */
	protected Color getColor(Element element, String attributeName) {
		if (getDocument() == null || getDocument() != element.getOwnerDocument()) {
			return null;
		}
		Color color = null;
		// Make sure that CSSEngine is available.
		BridgeContext ctx = transcoder.initCSSEngine();
		try {
			color = SVGUtils.toSWTColor(element, attributeName);
		} finally {
			if (ctx != null) {
				ctx.dispose();
			}
		}
		return color;
	}

	@@Override
	protected void paintFigure(Graphics graphics) {
		super.paintFigure(graphics);
		Document document = getDocument();
		if (document == null) {
			return;
		}
		Image image = null;
		try {
			Rectangle r = getClientArea();
			transcoder.setCanvasSize(specifyCanvasWidth ? r.width : -1, specifyCanvasHeight ? r.height : -1);
			updateRenderingHints(graphics);
			BufferedImage awtImage = transcoder.getBufferedImage();
			if (awtImage != null) {
				image = toSWT(Display.getCurrent(), awtImage);
				graphics.drawImage(image, r.x, r.y);
			}
		} finally {
			if (image != null) {
				image.dispose();
			}
		}
	}

	private void updateRenderingHints(Graphics graphics) {
		{
			int aa = SWT.DEFAULT;
			try {
				aa = graphics.getAntialias();
			} catch (Exception e) {
				// not supported
			}
			Object aaHint;
			if (aa == SWT.ON) {
				aaHint = RenderingHints.VALUE_ANTIALIAS_ON;
			} else if (aa == SWT.OFF) {
				aaHint = RenderingHints.VALUE_ANTIALIAS_OFF;
			} else {
				aaHint = RenderingHints.VALUE_ANTIALIAS_DEFAULT;
			}
			if (transcoder.getRenderingHints().get(RenderingHints.KEY_ANTIALIASING) != aaHint) {
				transcoder.getRenderingHints().put(RenderingHints.KEY_ANTIALIASING, aaHint);
				transcoder.contentChanged();
			}
		}
		{
			int aa = SWT.DEFAULT;
			try {
				aa = graphics.getTextAntialias();
			} catch (Exception e) {
				// not supported
			}
			Object aaHint;
			if (aa == SWT.ON) {
				aaHint = RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
			} else if (aa == SWT.OFF) {
				aaHint = RenderingHints.VALUE_TEXT_ANTIALIAS_OFF;
			} else {
				aaHint = RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT;
			}
			if (transcoder.getRenderingHints().get(RenderingHints.KEY_TEXT_ANTIALIASING) != aaHint) {
				transcoder.getRenderingHints().put(RenderingHints.KEY_TEXT_ANTIALIASING, aaHint);
				transcoder.contentChanged();
			}
		}
	}

	/**
	 * Converts an AWT based buffered image into an SWT <code>Image</code>. This will always return an <code>Image</code> that
	 * has 24 bit depth regardless of the type of AWT buffered image that is passed into the method.
	 * 
	 * @@param awtImage the {@@link java.awt.image.BufferedImage} to be converted to an <code>Image</code>
	 * @@return an <code>Image</code> that represents the same image data as the AWT <code>BufferedImage</code> type.
	 */
	private static org.eclipse.swt.graphics.Image toSWT(Device device, BufferedImage awtImage) {
		// We can force bitdepth to be 24 bit because BufferedImage getRGB
		// allows us to always retrieve 24 bit data regardless of source color depth.
		PaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);
		ImageData swtImageData = new ImageData(awtImage.getWidth(), awtImage.getHeight(), 24, palette);
		// Ensure scansize is aligned on 32 bit.
		int scansize = (((awtImage.getWidth() * 3) + 3) * 4) / 4;
		WritableRaster alphaRaster = awtImage.getAlphaRaster();
		byte[] alphaBytes = new byte[awtImage.getWidth()];
		for (int y = 0; y < awtImage.getHeight(); y++) {
			int[] buff = awtImage.getRGB(0, y, awtImage.getWidth(), 1, null, 0, scansize);
			swtImageData.setPixels(0, y, awtImage.getWidth(), buff, 0);
			if (alphaRaster != null) {
				int[] alpha = alphaRaster.getPixels(0, y, awtImage.getWidth(), 1, (int[]) null);
				for (int i = 0; i < awtImage.getWidth(); i++) {
					alphaBytes[i] = (byte) alpha[i];
				}
				swtImageData.setAlphas(0, y, awtImage.getWidth(), alphaBytes, 0);
			}
		}
		return new org.eclipse.swt.graphics.Image(device, swtImageData);
	}

	public final Rectangle2D getAreaOfInterest() {
		getDocument();
		return transcoder == null ? null : transcoder.getCanvasAreaOfInterest();
	}

	public void setAreaOfInterest(Rectangle2D value) {
		getDocument();
		if (transcoder != null) {
			transcoder.setCanvasAreaOfInterest(value);
		}
		repaint();
	}

	public final boolean isSpecifyCanvasWidth() {
		return specifyCanvasWidth;
	}

	public void setSpecifyCanvasWidth(boolean specifyCanvasWidth) {
		this.specifyCanvasWidth = specifyCanvasWidth;
		contentChanged();
	}

	public final boolean isSpecifyCanvasHeight() {
		return specifyCanvasHeight;
	}

	public void setSpecifyCanvasHeight(boolean specifyCanvasHeight) {
		this.specifyCanvasHeight = specifyCanvasHeight;
		contentChanged();
	}

	/**
	 * Should be called when SVG document has been changed. It will be re-rendered and figure will be repainted.
	 */
	public void contentChanged() {
		getDocument();
		if (transcoder != null) {
			transcoder.contentChanged();
		}
		repaint();
	}
}
@


1.10
log
@[243051] manage canvas size
@
text
@d14 1
d34 1
d154 1
d167 43
@


1.9
log
@[243571] always render using buffered image
@
text
@a25 5
import org.apache.batik.transcoder.Transcoder;
import org.apache.batik.transcoder.TranscoderException;
import org.apache.batik.transcoder.TranscoderInput;
import org.apache.batik.transcoder.TranscoderOutput;
import org.apache.batik.transcoder.image.ImageTranscoder;
d31 1
a32 1
import org.eclipse.gmf.internal.runtime.lite.svg.InferringNamespaceContext;
d46 1
a46 2
	private Document document;
	private boolean failedToLoadDocument;
a47 1
	private Rectangle2D aoi;
d59 1
a59 1
		document = null;
d75 2
a76 1
			document = factory.createDocument(uri);
a77 1
			transcoder = new SimpleImageTranscoder();
d87 1
a87 1
		if (document == null) {
d90 1
a90 1
		return document;
d125 1
a125 2
		Document document = getDocument();
		if (document == null || transcoder == null) {
d130 1
a130 1
		BridgeContext ctx = transcoder.initCSSEngine(document);
a140 14
	private void renderDocument(Transcoder transcoder, Document document) {
		try {
			Rectangle r = getClientArea();
			transcoder.addTranscodingHint(ImageTranscoder.KEY_WIDTH, new Float(r.width));
			transcoder.addTranscodingHint(ImageTranscoder.KEY_HEIGHT, new Float(r.height));
			if (aoi != null) {
				transcoder.addTranscodingHint(ImageTranscoder.KEY_AOI, aoi);
			}
			transcoder.transcode(new TranscoderInput(document), new TranscoderOutput());
		} catch (TranscoderException e) {
			Activator.logError("Error rendering SVG image", e);
		}
	}

d150 2
a151 1
			renderDocument(transcoder, document);
a154 1
				Rectangle r = getClientArea();
d195 8
a202 2
		if (aoi == null) {
			return null;
d204 19
a222 3
		Rectangle2D result = new Rectangle2D.Float();
		result.setRect(aoi);
		return result;
d225 7
a231 4
	public void setAreaOfInterest(Rectangle2D value) {
		if (value == null) {
			aoi = null;
			return;
a232 2
		aoi = new Rectangle2D.Float();
		aoi.setRect(value);
@


1.8
log
@[243571] always render using buffered image
@
text
@d36 1
a36 1
import org.eclipse.gmf.internal.runtime.lite.svg.ImageTranscoderEx;
d53 1
a53 1
	private ImageTranscoderEx transcoder;
d84 1
a84 1
			transcoder = new ImageTranscoderEx();
@


1.7
log
@[243403] support float properties
@
text
@d16 1
a31 1
import org.eclipse.core.runtime.IStatus;
a37 1
import org.eclipse.gmf.internal.runtime.lite.svg.SVGGraphics2D;
d39 1
d41 2
a53 2
	private boolean safeRendering;
	private boolean directRenderingSucceeded;
a169 26
		directRenderingSucceeded = false;
		if (safeRendering) {
			paintUsingAWT(graphics, document);
		} else {
			// Try to paint directly on provided graphics with fallback to
			// safe routine.
			try {
				graphics.pushState();
				paintDirectly(graphics, document);
				directRenderingSucceeded = true;
			} catch (RuntimeException e) {
				Activator.log(IStatus.INFO, "Failed to paint SVG image directly", e);
				graphics.restoreState();
				paintUsingAWT(graphics, document);
			} finally {
				graphics.popState();
			}
		}
	}

	private void paintDirectly(final Graphics graphics, Document document) {
		transcoder.setDraw2DGraphics(graphics);
		renderDocument(transcoder, document);
	}

	private void paintUsingAWT(Graphics graphics, Document document) {
a171 1
			transcoder.setDraw2DGraphics(null);
d175 1
a175 1
				image = SVGGraphics2D.toSWT(Display.getCurrent(), awtImage);
d186 28
a213 11
	public final boolean isDirectRenderingSucceeded() {
		return directRenderingSucceeded;
	}

	public final boolean isSafeRendering() {
		return safeRendering;
	}

	public void setSafeRendering(boolean safeRendering) {
		this.safeRendering = safeRendering;
		repaint();
@


1.6
log
@[243391] init css engine
@
text
@d230 1
a230 1
		Rectangle2D result = new Rectangle2D.Double();
d240 1
a240 1
		aoi = new Rectangle2D.Double();
@


1.5
log
@[243143] use client area
@
text
@a13 1
import java.awt.Graphics2D;
d23 1
d39 1
d43 1
d51 1
d74 1
d84 1
d128 21
d191 1
a191 7
		ImageTranscoderEx transcoder = new ImageTranscoderEx() {

			@@Override
			protected Graphics2D createGraphics(int w, int h) {
				return new SVGGraphics2D(graphics);
			}
		};
d198 1
a198 2
			// SimpleImageTranscoder transcoder = new SimpleImageTranscoder();
			ImageTranscoderEx transcoder = new ImageTranscoderEx();
@


1.4
log
@[243050] support AOI
@
text
@d34 1
d125 3
a127 2
			transcoder.addTranscodingHint(ImageTranscoder.KEY_WIDTH, new Float(getBounds().width));
			transcoder.addTranscodingHint(ImageTranscoder.KEY_HEIGHT, new Float(getBounds().height));
d184 2
a185 1
				graphics.drawImage(image, getBounds().x, getBounds().y);
@


1.3
log
@[243052] add prop to force safe rendering
@
text
@d15 1
d50 1
d126 3
d203 19
@


1.2
log
@[2410] support document properties editing
@
text
@d47 2
d54 4
d92 7
d134 9
a142 1
		if (document != null) {
d146 1
d185 13
@


1.1
log
@add lightweight SVG support
@
text
@d18 5
d35 1
d40 1
d76 1
a76 1
	private Document getDocument() {
d86 21
@

