head	1.2;
access;
symbols
	v20081022-1925:1.2
	v20081020-0700:1.2
	ocl_qvt:1.2.0.2
	Root_ocl_qvt:1.2
	v20080722-1827:1.2
	v20080718-1731:1.2
	v20080716-1600:1.1
	v20080716-1642:1.1
	R2_1_maintenance:1.1.0.2
	Root_R2_1_maintenance:1.1
	R2_1_0:1.1
	v20080528-1052:1.1
	v20080516-1143:1.1
	v20080417-1610:1.1
	v20080322-0000:1.1
	v20080222-1200:1.1
	v20071130-1111:1.1
	v20071108-0000:1.1;
locks; strict;
comment	@# @;


1.2
date	2008.07.18.15.38.20;	author ashatalin;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	50084880b8eb4567;

1.1
date	2007.10.29.16.58.22;	author atikhomirov;	state Exp;
branches;
next	;
commitid	5b914726112d4567;

1.2.2.1
date	2008.07.29.15.57.05;	author ashatalin;	state dead;
branches;
next	;
commitid	337c488f3dcd4567;


desc
@@


1.2
log
@Typo corrected.
@
text
@/**
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bblajer - initial API and implementation
 */
package org.eclipse.gmf.internal.xpand.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.gmf.internal.xpand.ResourceManager;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContext;
import org.eclipse.gmf.internal.xpand.xtend.ast.Extension;
import org.eclipse.gmf.internal.xpand.xtend.ast.XtendResource;

/**
 * Composes several Xtend ast trees to produce a single resource. Extensions are merged:
 * if extensions with same signatures are found, the one that comes first (i.e., from a more recent source) wins.
 */
class CompositeXtendResource implements XtendResource {
	private final XtendResource[] myResources;
	private final List<Extension> myCachedExtensions;

	public CompositeXtendResource(ResourceManager manager, XtendResource[] resources) {
		myResources = resources;
		myCachedExtensions = new ArrayList<Extension>();
		HashSet<DefinitionSignature> signatures = new HashSet<DefinitionSignature>();
		ExecutionContext context = ContextFactory.createXtendContext(manager);
		for (XtendResource nextResource : myResources) {
			mergeExtensions(context, nextResource.getExtensions(), myCachedExtensions, signatures);
		}
	}

	private void mergeExtensions(ExecutionContext context, List<Extension> extensions, List<Extension> collector, Set<DefinitionSignature> usedSignatures) {
		for (Extension nextExtension : extensions) {
			if (context.currentResource() != nextExtension.getExtensionFile()) {
				context = context.cloneWithResource(nextExtension.getExtensionFile());
			}
			DefinitionSignature signature = DefinitionSignature.create(context, nextExtension);
			if (signature == null || usedSignatures.contains(signature)) {
				continue;
			}
			usedSignatures.add(signature);
			collector.add(nextExtension);
		}
	}

	public void analyze(ExecutionContext ctx, Set<AnalysationIssue> issues) {
		for (XtendResource nextResource : myResources) {
			nextResource.analyze(ctx, issues);
		}
	}

	public List<Extension> getExtensions() {
		return myCachedExtensions;
	}

	public String[] getImportedExtensions() {
		final List<String> result= new ArrayList<String>();
        for (XtendResource nextResource : myResources) {
        	result.addAll(Arrays.asList(nextResource.getImportedExtensions()));
        }
		return result.toArray(new String[result.size()]);
	}

	public String[] getImportedNamespaces() {
		final List<String> result= new ArrayList<String>();
        for (XtendResource nextResource : myResources) {
        	result.addAll(Arrays.asList(nextResource.getImportedNamespaces()));
        }
		return result.toArray(new String[result.size()]);
	}

	public List<Extension> getPublicExtensions(ResourceManager resourceManager) {
        List<Extension> publicExtensions = new ArrayList<Extension>();
		HashSet<DefinitionSignature> signatures = new HashSet<DefinitionSignature>();
		ExecutionContext context = ContextFactory.createXtendContext(resourceManager);
        for (XtendResource nextResource : myResources) {
        	mergeExtensions(context, nextResource.getPublicExtensions(resourceManager), publicExtensions, signatures);
        }
		return publicExtensions;
	}

}
@


1.2.2.1
log
@Xtend-based implementation of XPand extensions was separated into .migration plugin.
@
text
@@


1.1
log
@[207437] Resources to be composed from several sources
@
text
@d71 1
a71 1
        	result.addAll(Arrays.asList(nextResource.getImportedNamespaces()));
d79 1
a79 1
        	result.addAll(Arrays.asList(nextResource.getImportedExtensions()));
@

