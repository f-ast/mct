head	1.9;
access;
symbols
	v20081022-1925:1.9
	v20081020-0700:1.9
	ocl_qvt:1.9.0.4
	Root_ocl_qvt:1.9
	v20080722-1827:1.9
	v20080718-1731:1.9
	v20080716-1600:1.9
	v20080716-1642:1.9
	R2_1_maintenance:1.9.0.2
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080528-1052:1.9
	v20080516-1143:1.9
	v20080417-1610:1.9
	v20080322-0000:1.9
	v20080222-1200:1.9
	v20071130-1111:1.9
	v20071124-0000:1.7
	v20071108-0000:1.9
	v20071003-0000:1.7
	v20070921-0000:1.7
	v20070903-0000:1.7
	v20070809-0000:1.7
	R2_0_maintenance:1.7.0.2
	R2_0:1.7
	R4_20:1.7
	RC3_20:1.7
	v20070608-1300:1.7
	v20070605-1400:1.7
	v20070601-1400:1.7
	v20070518-1300:1.7
	v20070420-1000:1.7
	v20070405-1100:1.7
	v20070403-1500:1.7
	v20070330-1300:1.7
	v20070208-1800:1.7
	v20070103-0300:1.6
	M4_20:1.6
	M3_20:1.6;
locks; strict;
comment	@# @;


1.9
date	2007.10.29.17.40.17;	author atikhomirov;	state Exp;
branches
	1.9.4.1;
next	1.8;
commitid	10ff47261b014567;

1.8
date	2007.10.29.16.58.24;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	5b914726112d4567;

1.7
date	2007.01.31.14.08.27;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	4b7645c0a2d14567;

1.6
date	2006.11.10.17.49.47;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.07.14.20.05;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.30.19.39.57;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.25.17.24.04;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.23.16.13.10;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.50;	author atikhomirov;	state Exp;
branches;
next	;

1.9.4.1
date	2008.08.05.12.49.25;	author atikhomirov;	state Exp;
branches;
next	1.9.4.2;
commitid	546c48984c4a4567;

1.9.4.2
date	2008.08.06.14.05.34;	author atikhomirov;	state dead;
branches;
next	;
commitid	35b4899afa74567;


desc
@@


1.9
log
@[207437] Resources to be composed from several sources - fix/support and test for local calls from non-resource-based templates (hanging in the air wiith "nofile"), simplified default root handling for ws resources.
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2007 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.model;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.gmf.internal.xpand.Activator;
import org.eclipse.gmf.internal.xpand.ResourceManager;
import org.eclipse.gmf.internal.xpand.ResourceMarker;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContextImpl;
import org.eclipse.gmf.internal.xpand.expression.PolymorphicResolver;
import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;
import org.eclipse.gmf.internal.xpand.expression.TypeNameUtil;
import org.eclipse.gmf.internal.xpand.expression.Variable;

/**
 * *
 * 
 * @@author Sven Efftinge *
 */
public class XpandExecutionContextImpl extends ExecutionContextImpl implements XpandExecutionContext {

    protected final Output output;
    
    protected final ProtectedRegionResolver protectedRegionResolver;
    
    private final List<XpandAdvice> registeredAdvices = new ArrayList<XpandAdvice>();

    public XpandExecutionContextImpl(ResourceManager resourceManager, Output output, ProtectedRegionResolver prs) {
        this (resourceManager, output, prs, null);
    }
    
    public XpandExecutionContextImpl(ResourceManager resourceManager, Output output, ProtectedRegionResolver prs, Collection<Variable> globalVars) {
        super(resourceManager, globalVars);
        this.output = output;
        this.protectedRegionResolver = prs;
    }

    protected XpandExecutionContextImpl (ResourceManager resourceManager, ResourceMarker currentResource, Collection<Variable> vars, 
            Collection<Variable> globalVars, Output output, ProtectedRegionResolver protectedRegionResolver) {
        super(resourceManager, currentResource, vars, globalVars);
        this.output = output;
        this.protectedRegionResolver = protectedRegionResolver;
    }

    /*copy constructor*/
    private XpandExecutionContextImpl(XpandExecutionContextImpl original) {
    	super(original);
    	this.output = original.output;
    	this.protectedRegionResolver = original.protectedRegionResolver;
    }
    

    @@Override
    public XpandExecutionContextImpl cloneContext() {
        final XpandExecutionContextImpl result = new XpandExecutionContextImpl(this);
        result.registeredAdvices.addAll(registeredAdvices); //todo: [aha] before I refactored, there was an assignment in this place. Is this modification correct?
        return result;
    }

    public XpandDefinition findDefinition(final String name, final EClassifier target, final EClassifier[] paramTypes) {
        String templateName;
        boolean localCall = name.indexOf(SyntaxConstants.NS_DELIM) < 0;
        if (localCall) {
        	templateName = ((XpandResource) currentResource()).getFullyQualifiedName();	//need an enclosing resource in case of composite
        } else {
        	templateName = TypeNameUtil.withoutLastSegment(name);
        }
        XpandResource tpl = findTemplate(templateName);
        if (tpl == null) {
        	if (localCall) {
        		tpl = (XpandResource) currentResource();
        	} else {
        		return null;
        	}
		}
        final XpandExecutionContext ctx = (XpandExecutionContext) cloneWithResource(tpl);
        XpandDefinition def = findDefinition(tpl.getDefinitions(), name, target, paramTypes, ctx);
        if (def == null) {
        	return null;
        }
        XpandAdvice[] advicesInResource = tpl.getAdvices();
        for (int x = advicesInResource.length - 1; x >= 0; x--) {
            final XpandAdvice adv = advicesInResource[x];
            if (adv.matches(def, this)) {
                def = new AdvicedDefinition(adv, def);
            }
        }
        for (int x = registeredAdvices.size() - 1; x >= 0; x--) {
            final XpandAdvice adv = registeredAdvices.get(x);
            if (adv.matches(def, this)) {
                def = new AdvicedDefinition(adv, def);
            }
        }
        return def;
    }

	public void registerAdvices(final String fullyQualifiedName) {
        final XpandResource tpl = findTemplate(fullyQualifiedName);
        if (tpl == null) {
			throw new RuntimeException("Couldn't find template : " + fullyQualifiedName);
		}
        final XpandAdvice[] as = tpl.getAdvices();
        for (final XpandAdvice advice : as) {
            if (registeredAdvices.contains(advice)) {
                Activator.logWarn("advice " + advice.toString() + " allready registered!");
            } else {
                registeredAdvices.add(advice);
            }
        }
    }

    public ProtectedRegionResolver getProtectedRegionResolver() {
        return protectedRegionResolver;
    }

    public Output getOutput() {
        return output;
    }

    @@Override
    protected String[] getImportedNamespaces() {
    	if (currentResource() instanceof XpandResource) {
    		return ((XpandResource) currentResource()).getImportedNamespaces();
    	}
    	return super.getImportedNamespaces();
    }

    @@Override
    protected String[] getImportedExtensions() {
    	if (currentResource() instanceof XpandResource) {
    		return ((XpandResource) currentResource()).getImportedExtensions();
    	}
    	return super.getImportedExtensions();
    }

    public XpandResource findTemplate(final String templateName) {
    	if (getResourceManager() == null) {
    		return null;
    	}
    	// XXX findTemplate needs kinda file uri, while metamodel import needs nsURI
    	final List<String> possibleNames = getPossibleNames(templateName, getImportedNamespaces());
        for (String name : possibleNames) {
            final XpandResource tpl = getResourceManager().loadXpandResource(name);
            if (tpl != null) {
//            	installAspectsFor(templateName);
				return tpl;
			}
        }
        return null;
    }

//    private void installAspectsFor(String templateName) {
//    	String aspectsTemplateName = "aspects" + SyntaxConstants.NS_DELIM + templateName;
//    	XpandResource aspects = getResourceManager().loadXpandResource(aspectsTemplateName);
//    	if (aspects != null) {
//    		registeredAdvices.addAll(Arrays.asList(aspects.getAdvices()));
//    	}
//	}

	private List<String> getPossibleNames(final String name, final String[] importedNs) {
        final String typeName = TypeNameUtil.getTypeName(name);
        final String typesMetamodelName = TypeNameUtil.getMetaModelName(name);
        final String collectionTypeName = TypeNameUtil.getCollectionTypeName(name);

        final List<String> result = new ArrayList<String>();
        result.add(name);
        
        for (final String string : importedNs) {
            final StringBuffer s = new StringBuffer();
            if (collectionTypeName != null) {
                s.append(collectionTypeName).append("[");
            }
            if (typesMetamodelName != null) {
                s.append(typesMetamodelName).append("!");
            }
            s.append(string).append(SyntaxConstants.NS_DELIM).append(typeName);
            if (collectionTypeName != null) {
                s.append("]");
            }
            result.add(s.toString());
        }
        return result;
    }

    /**
     * resolves the correct definition (using parametric polymorphism)
	 * XXX: get rid of the ctx argument and redeclare as non-static?
     * @@param definitions
     * @@param target
     * @@param paramTypes
     * @@return
     */
    private static XpandDefinition findDefinition(final XpandDefinition[] definitions, final String name, final EClassifier target,
            EClassifier[] paramTypes, final XpandExecutionContext ctx) {
        if (paramTypes == null) {
            paramTypes = new EClassifier[0];
        }
        final String unqualifiedName = TypeNameUtil.getLastSegment(name);
        // XXX Instead of using map as a mere pair storage, do it like Extension does with init(ctx)
        // to resolve and keep typed arguments
        HashMap<XpandDefinition, List<EClassifier>> resolvedDefs = new HashMap<XpandDefinition, List<EClassifier>>();
        for (final XpandDefinition def : definitions) {
        	if (!def.getName().equals(unqualifiedName)) {
        		continue;
        	}
            if (def.getParams().length == paramTypes.length) {
                final LinkedList<EClassifier> defsParamTypes = new LinkedList<EClassifier>();
                EClassifier t = null;
                boolean complete = true;
                for (int j = 0; (j < paramTypes.length) && complete; j++) {
                    t = ctx.getTypeForName(def.getParams()[j].getType().getValue());
                    if (t == null) {
                        complete = false;
                    }
                    defsParamTypes.add(t);
                }
                t = ctx.getTypeForName(def.getTargetType());
                if (t == null) {
                    complete = false;
                } else {
                	defsParamTypes.addFirst(t);
                }
                if (complete) {
                	resolvedDefs.put(def, defsParamTypes);
                }
            }
        }
		return PolymorphicResolver.filterDefinition(resolvedDefs, target, Arrays.asList(paramTypes));
    }
}
@


1.9.4.1
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
a13 1
 *     Artem Tikhomirov (Borland) - Migration to OCL expressions
d30 1
d81 1
a81 1
        boolean localCall = !TypeNameUtil.isQualifiedName(name);
d83 1
a83 3
        	// [artem] the reason can't just use currentResource() as it might be part of composite?
        	// otherwise, see no reason to load it once again in findTemplate()
        	templateName = ((XpandResource) currentResource()).getFullyQualifiedName(); // need an enclosing resource in case of composite	
a154 2
    // XXX completely rewritten, NEEDS TESTS!
    // getPossibleNames(getImportedNamespaces()), along with FQN added in #getImportedNamespaces(), was stupid hack anyway.
d159 2
a160 20
    	String[] possibleNames;
    	if (currentResource() instanceof XpandResource) {
    		String contextTemplate = ((XpandResource) currentResource()).getFullyQualifiedName();
    		if (!TypeNameUtil.isQualifiedName(contextTemplate)) {
        		possibleNames = new String[] { templateName };
    		} else {
    			String contextNS = TypeNameUtil.withoutLastSegment(contextTemplate);
	    		possibleNames = new String[] {
		    		templateName,
		    		contextNS + TypeNameUtil.NS_DELIM + templateName
		    	};
	    		if (!TypeNameUtil.isQualifiedName(templateName)) {
	    			// unqualified name, try relative to current template first
	    			possibleNames[0] = possibleNames[1];
	    			possibleNames[1] = templateName;
	    		}
    		}
    	} else {
    		possibleNames = new String[] { templateName };
    	}
d179 25
d230 1
a230 1
                    t = def.getParams()[j].getTypeForName(ctx);
d236 1
a236 1
                t = def.getTargetType().getTypeForName(ctx);
d247 1
a247 1
		return PolymorphicResolver.filterDefinition(resolvedDefs, target, Arrays.asList(paramTypes), ctx.getOCLEnvironment());
@


1.9.4.2
log
@[243154] Use OCL instead of home-grown expression language. Refactored to eliminate context specific to expressions (moving towards using OCL environment for that), split modifiable (context-specific) and static execution data.
@
text
@@


1.8
log
@[207437] Resources to be composed from several sources
@
text
@d81 2
a82 1
        if (name.indexOf(SyntaxConstants.NS_DELIM) < 0) {	//local call
d89 5
a93 1
			return null;
d116 1
a116 1
    public void registerAdvices(final String fullyQualifiedName) {
d156 3
@


1.7
log
@NPE when no definition found
@
text
@d4 1
a4 1
 * Copyright (c) 2005-2006 Sven Efftinge and others.
d80 3
a82 3
        XpandResource tpl = null;
        if (name.indexOf(SyntaxConstants.NS_DELIM) != -1) { // local call
            tpl = findTemplate(TypeNameUtil.withoutLastSegment(name));
d84 1
a84 1
            tpl = (XpandResource) currentResource();
d86 1
d95 7
d156 1
a156 1
            	installAspectsFor(templateName);
d163 7
a169 7
    private void installAspectsFor(String templateName) {
    	String aspectsTemplateName = "aspects" + SyntaxConstants.NS_DELIM + templateName;
    	XpandResource aspects = getResourceManager().loadXpandResource(aspectsTemplateName);
    	if (aspects != null) {
    		registeredAdvices.addAll(Arrays.asList(aspects.getAdvices()));
    	}
	}
d198 1
d204 1
a204 1
    private XpandDefinition findDefinition(final XpandDefinition[] definitions, final String name, final EClassifier target,
@


1.6
log
@recognize aspects residing in adjustent folders
@
text
@d91 3
@


1.5
log
@filter templates by name right away
@
text
@d145 1
d152 9
a160 1
    private List<String> getPossibleNames(final String name, final String[] importedNs) {
@


1.4
log
@reminder to filter by name right away
@
text
@a177 1
     * XXX why not filter with name right here, and not in PolymorphicResolver?
d188 1
d193 3
d218 1
a218 1
        return PolymorphicResolver.filterDefinition(resolvedDefs, TypeNameUtil.getLastSegment(name), target, Arrays.asList(paramTypes));
@


1.3
log
@*** empty log message ***
@
text
@d178 1
a178 1
     * 
@


1.2
log
@refactored use of variables (no need to expose Map)
@
text
@d45 1
a45 1
    private List<XpandAdvice> registeredAdvices = new ArrayList<XpandAdvice>();
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d19 1
a22 1
import java.util.Map;
d51 1
a51 1
    public XpandExecutionContextImpl(ResourceManager resourceManager, Output output, ProtectedRegionResolver prs, Map<String, Variable> globalVars) {
d57 3
a59 4
    
    protected XpandExecutionContextImpl (ResourceManager resourceManager, ResourceMarker currentResource, Map<String, Variable> vars, 
            Map<String, Variable> globalVars, Output output, ProtectedRegionResolver protectedRegionResolver) {
        super (resourceManager, currentResource, vars, globalVars);
d64 6
d74 1
a74 1
        final XpandExecutionContextImpl result = new XpandExecutionContextImpl (getResourceManager(), currentResource(), getVisibleVariables(), getGlobalVariables(), output, protectedRegionResolver);
@

