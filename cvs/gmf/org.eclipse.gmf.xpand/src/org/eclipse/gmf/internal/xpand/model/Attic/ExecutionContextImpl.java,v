head	1.1;
access;
symbols
	v20081022-1925:1.1
	ocl_qvt:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2008.08.06.14.05.35;	author atikhomirov;	state dead;
branches
	1.1.2.1;
next	;
commitid	35b4899afa74567;

1.1.2.1
date	2008.08.06.14.05.35;	author atikhomirov;	state Exp;
branches;
next	1.1.2.2;
commitid	35b4899afa74567;

1.1.2.2
date	2008.08.07.23.23.37;	author atikhomirov;	state Exp;
branches;
next	1.1.2.3;
commitid	55a7489b83f64567;

1.1.2.3
date	2008.08.08.16.33.25;	author atikhomirov;	state Exp;
branches;
next	1.1.2.4;
commitid	a21489c75534567;

1.1.2.4
date	2008.08.10.15.10.44;	author atikhomirov;	state Exp;
branches;
next	1.1.2.5;
commitid	2d13489f04f14567;

1.1.2.5
date	2008.08.13.16.45.23;	author atikhomirov;	state Exp;
branches;
next	1.1.2.6;
commitid	140948a30fa24567;

1.1.2.6
date	2008.08.19.17.25.21;	author atikhomirov;	state Exp;
branches;
next	1.1.2.7;
commitid	380048ab02014567;

1.1.2.7
date	2008.10.24.17.50.52;	author atikhomirov;	state Exp;
branches;
next	;
commitid	cb8049020afb4567;


desc
@@


1.1
log
@file ExecutionContextImpl.java was initially added on branch ocl_qvt.
@
text
@@


1.1.2.1
log
@[243154] Use OCL instead of home-grown expression language. Refactored to eliminate context specific to expressions (moving towards using OCL environment for that), split modifiable (context-specific) and static execution data.
@
text
@a0 263
/*
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *     Artem Tikhomirov (Borland) - Migration to OCL expressions
 */
package org.eclipse.gmf.internal.xpand.model;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.impl.EPackageRegistryImpl;
import org.eclipse.gmf.internal.xpand.Activator;
import org.eclipse.gmf.internal.xpand.ResourceMarker;
import org.eclipse.gmf.internal.xpand.model.ExecutionContext;
import org.eclipse.gmf.internal.xpand.util.PolymorphicResolver;
import org.eclipse.gmf.internal.xpand.util.TypeNameUtil;
import org.eclipse.gmf.internal.xpand.xtend.ast.GenericExtension;
import org.eclipse.gmf.internal.xpand.xtend.ast.QvtResource;
import org.eclipse.ocl.ecore.EcoreEnvironment;
import org.eclipse.ocl.ecore.EcoreEnvironmentFactory;

/**
 * @@author Sven Efftinge
 * @@author Arno Haase
 */
public final class ExecutionContextImpl implements ExecutionContext {

    private final Map<String, Variable> variables = new HashMap<String, Variable> ();

    // never null
    private final Scope scope;

    private final ResourceMarker currentResource;

    public ExecutionContextImpl(Scope rootScope) {
        this (rootScope, null, (Collection<Variable>) null);
    }

    public ExecutionContextImpl(Scope rootScope, ResourceMarker resource, Collection<Variable> variables) {
    	assert rootScope != null;
		this.scope = rootScope;
		this.currentResource = resource;
		if (variables != null) {
			for (Variable v : variables) {
				this.variables.put(v.getName(), v);
			}
		}
    }

    public Scope getScope() {
    	return scope;
    }

    public Variable getVariable(final String name) {
        return variables.get(name);
    }


	public ExecutionContext cloneWithVariable(final Variable... vars) {
        final ExecutionContextImpl result = new ExecutionContextImpl(scope, currentResource, variables.values());
        result.envFactory = envFactory;
    	result.environment = null; // XXX or create new, delegating?
        for (Variable v : vars) {
        	// adding to the set of original variables because of e.g. nested let statements
        	result.variables.put(v.getName(), v);
        }
        return result;
    }

    public ExecutionContext cloneWithResource(final ResourceMarker ns) {
        if (ns == currentResource) {
        	return this;
        }
        final ExecutionContextImpl result = new ExecutionContextImpl(scope, ns, variables.values());
    	result.envFactory = null; // need to make sure resource's imports are read into registry.
    	result.environment = null;
        return result;
    }

    public ResourceMarker currentResource() {
        return currentResource;
    }

    private Set<GenericExtension> allExtensions = null;

    private String[] getImportedExtensions() {
    	return currentResource == null ? new String[0] : currentResource.getImportedExtensions();
    }

	public Set<? extends GenericExtension> getAllExtensions() {
        if (allExtensions == null) {
            allExtensions = new HashSet<GenericExtension>();
            final String[] extensions = getImportedExtensions();
            for (String extension : extensions) {
            	final QvtResource qvtResource = getScope().findExtension(extension);
            	if (qvtResource != null) {
            		final ExecutionContext ctx = cloneWithResource(qvtResource);
                    final List<? extends GenericExtension> extensionList = qvtResource.getExtensions();
                    for (GenericExtension element : extensionList) {
                        element.init(ctx);
                        allExtensions.add(element);
                    }
            	} else {
            		// XXX ask Vano - used to be exception
            		//throw new RuntimeException("Unable to load extension file : " + extension);
            	}
            }
        }
        return allExtensions;
    }

    public GenericExtension getExtension(final String functionName, final EClassifier[] parameterTypes) {
        return PolymorphicResolver.getExtension(getAllExtensions(), functionName, Arrays.asList(parameterTypes), null/*FIXME*/);
    }

    public XpandDefinition findDefinition(String name, EClassifier target, EClassifier[] paramTypes) {
        String templateName;
        boolean localCall = !TypeNameUtil.isQualifiedName(name);
        if (localCall) {
        	// [artem] the reason can't just use currentResource() as it might be part of composite?
        	// otherwise, see no reason to load it once again in findTemplate()
        	templateName = ((XpandResource) currentResource()).getFullyQualifiedName(); // need an enclosing resource in case of composite	
        } else {
        	templateName = TypeNameUtil.withoutLastSegment(name);
        }
        XpandResource tpl = findTemplate(templateName);
        if (tpl == null) {
        	if (localCall) {
        		tpl = (XpandResource) currentResource();
        	} else {
        		return null;
        	}
		}
        final ExecutionContext ctx = cloneWithResource(tpl);
        XpandDefinition def = findDefinition(tpl.getDefinitions(), name, target, paramTypes, ctx);
        if (def == null) {
        	return null;
        }
        XpandAdvice[] advicesInResource = tpl.getAdvices();
        for (int x = advicesInResource.length - 1; x >= 0; x--) {
            final XpandAdvice adv = advicesInResource[x];
            if (adv.matches(def, this)) {
                def = new AdvicedDefinition(adv, def);
            }
        }
        for (int x = scope.getAdvices().size() - 1; x >= 0; x--) {
            final XpandAdvice adv = scope.getAdvices().get(x);
            if (adv.matches(def, this)) {
                def = new AdvicedDefinition(adv, def);
            }
        }
        return def;
    }

    // XXX completely rewritten, NEEDS TESTS!
    // getPossibleNames(getImportedNamespaces()), along with FQN added in #getImportedNamespaces(), was stupid hack anyway.
    private XpandResource findTemplate(final String templateName) {
    	if (currentResource() instanceof XpandResource) {
    		String contextTemplate = ((XpandResource) currentResource()).getFullyQualifiedName();
    		return scope.findTemplate(templateName, contextTemplate);
    	} else {
    		return scope.findTemplate(templateName);
    	}
    }

    /**
     * resolves the correct definition (using parametric polymorphism)
	 * XXX: get rid of the ctx argument and redeclare as non-static?
     * @@param definitions
     * @@param target
     * @@param paramTypes
     * @@return
     */
    private static XpandDefinition findDefinition(final XpandDefinition[] definitions, final String name, final EClassifier target,
            EClassifier[] paramTypes, final ExecutionContext ctx) {
        if (paramTypes == null) {
            paramTypes = new EClassifier[0];
        }
        final String unqualifiedName = TypeNameUtil.getLastSegment(name);
        // XXX Instead of using map as a mere pair storage, do it like Extension does with init(ctx)
        // to resolve and keep typed arguments
        HashMap<XpandDefinition, List<EClassifier>> resolvedDefs = new HashMap<XpandDefinition, List<EClassifier>>();
        for (final XpandDefinition def : definitions) {
        	if (!def.getName().equals(unqualifiedName)) {
        		continue;
        	}
            if (def.getParams().length == paramTypes.length) {
                final LinkedList<EClassifier> defsParamTypes = new LinkedList<EClassifier>();
                EClassifier t = null;
                boolean complete = true;
                for (int j = 0; (j < paramTypes.length) && complete; j++) {
                    t = def.getParams()[j].getTypeForName(ctx);
                    if (t == null) {
                        complete = false;
                    }
                    defsParamTypes.add(t);
                }
                t = def.getTargetType().getTypeForName(ctx);
                if (t == null) {
                    complete = false;
                } else {
                	defsParamTypes.addFirst(t);
                }
                if (complete) {
                	resolvedDefs.put(def, defsParamTypes);
                }
            }
        }
		return PolymorphicResolver.filterDefinition(resolvedDefs, target, Arrays.asList(paramTypes), ctx.getOCLEnvironment());
    }

    private EcoreEnvironmentFactory envFactory; // null-ified when context's resource is changed
    private EcoreEnvironment environment;

    public EcoreEnvironment getOCLEnvironment() {
    	if (environment != null) {
    		return environment;
    	}
    	if (envFactory == null) {
    		envFactory = new EcoreEnvironmentFactory(getAllVisibleModels());
    	}
    	environment = (EcoreEnvironment) envFactory.createEnvironment();
    	return environment;
    }

    private String[] getImportedNamespaces() {
    	return currentResource == null ? new String[0] : currentResource.getImportedNamespaces();
    }

    private EPackage.Registry getAllVisibleModels() {
		String[] importedNamespaces = getImportedNamespaces();
		assert importedNamespaces != null;
		// TODO respect meta-models imported not only with nsURI
		EPackage.Registry result = new EPackageRegistryImpl();
		for (String namespace : importedNamespaces) {
			EPackage pkg = Activator.findMetaModel(namespace);
			if (pkg != null) {
				result.put(namespace, pkg);
			}
		}
		if (result.isEmpty()) {
			// hack for tests
			result.put(EcorePackage.eNS_URI, EcorePackage.eINSTANCE);
		}
		return result;
	}

}
@


1.1.2.2
log
@[243154] Use OCL instead of home-grown expression language - fixing and running tests.
@
text
@d29 1
a35 1
import org.eclipse.ocl.ecore.EcoreEvaluationEnvironment;
d128 1
a128 1
        return PolymorphicResolver.getExtension(getAllExtensions(), functionName, Arrays.asList(parameterTypes), getOCLEnvironment());
a236 3
//		org.eclipse.ocl.ecore.Variable oclVar = EcoreFactory.eINSTANCE.createVariable();
//		oclVar.setName(v.getName());
//		oclVar.setType((EClassifier) v.getValue());
a239 8
    
    public void populate(EcoreEvaluationEnvironment ee) {
    	for (Variable v : variables.values()) {
    		if (!IMPLICIT_VARIABLE.equals(v.getName())) {
    			ee.add(v.getName(), v.getValue());
    		}
    	}
	}
@


1.1.2.3
log
@[243154] Use OCL instead of home-grown expression language - populate ocl environment with variable types (hence, need to tell var value from var type)
@
text
@a27 1
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
a35 1
import org.eclipse.ocl.ecore.EcoreFactory;
d237 3
a240 18
    	for (Variable v : variables.values()) {
    		if (!IMPLICIT_VARIABLE.equals(v.getName())) {
    			// XXX alternative: environment.getOCLFactory().createVariable()
    			org.eclipse.ocl.ecore.Variable oclVar = EcoreFactory.eINSTANCE.createVariable();
    			oclVar.setName(v.getName());
    			if (v.getType() == null) {
    				oclVar.setType(BuiltinMetaModel.getType(v.getValue()));
    			} else {
    				oclVar.setType(v.getType());
    			}
    			environment.addElement(oclVar.getName(), oclVar, true);
    		}
    	}
		Variable v = variables.get(ExecutionContext.IMPLICIT_VARIABLE);
		if (v != null) {
			EClassifier type = v.getType() == null ? BuiltinMetaModel.getType(v.getValue()) : v.getType();
			environment = (EcoreEnvironment) envFactory.createClassifierContext(environment, type);
		}
@


1.1.2.4
log
@[243154] Use OCL instead of home-grown expression language - most (what's feasible) of the extension invocation fixed. A lot of hacks and questions, though.
@
text
@a23 3
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EOperation;
a24 2
import org.eclipse.emf.ecore.EParameter;
import org.eclipse.emf.ecore.EStructuralFeature;
a25 1
import org.eclipse.emf.ecore.impl.EFactoryImpl;
d32 1
a32 1
import org.eclipse.gmf.internal.xpand.xtend.ast.QvtExtension;
a33 7
import org.eclipse.m2m.internal.qvt.oml.ast.env.QvtOperationalEnv;
import org.eclipse.m2m.internal.qvt.oml.ast.env.QvtOperationalEnvFactory;
import org.eclipse.m2m.internal.qvt.oml.ast.env.QvtOperationalFileEnv;
import org.eclipse.m2m.internal.qvt.oml.expressions.Module;
import org.eclipse.ocl.Environment;
import org.eclipse.ocl.ecore.CallOperationAction;
import org.eclipse.ocl.ecore.Constraint;
d35 1
a37 2
import org.eclipse.ocl.ecore.SendSignalAction;
import org.eclipse.ocl.utilities.UMLReflection;
d101 1
a101 1
    private Set<QvtExtension> allExtensions = null;
d107 1
a107 1
	public Set<QvtExtension> getAllExtensions() {
d109 1
a109 1
            allExtensions = new HashSet<QvtExtension>();
d113 10
a122 2
            	if (qvtResource == null) {
            		throw new RuntimeException("Unable to load extension file : " + extension);
a123 6
        		final ExecutionContext ctx = cloneWithResource(qvtResource);
                final List<QvtExtension> extensionList = qvtResource.getExtensions();
                for (QvtExtension element : extensionList) {
                    element.init(ctx);
                    allExtensions.add(element);
                }
d129 4
d229 2
a230 2
    private QvtOperationalEnvFactory envFactory; // null-ified when context's resource is changed
    private QvtOperationalEnv environment;
d237 1
a237 3
    		//envFactory = new EcoreEnvironmentFactory(getAllVisibleModels());
    		envFactory = QvtOperationalEnvFactory.INSTANCE;
    		// XXX shouldn't I keep instance of QvtOperationalEnv with the visible models instead?
d239 1
a239 3
    	QvtOperationalEnv rootEnv = new QvtOperationalEnv(null, getAllVisibleModels()) {};
		environment = envFactory.createEnvironment(rootEnv );
		//handleImportedExtensions(rootEnv);
d246 1
a246 1
    				oclVar.setType(BuiltinMetaModel.getType(this, v.getValue()));
d255 2
a256 16
			EClassifier type = v.getType() == null ? BuiltinMetaModel.getType(this, v.getValue()) : v.getType();
			//environment = (EcoreEnvironment) envFactory.createClassifierContext(environment, type);
			// make sure environment can be casted to QvtOperationalEnv, though it should be fixed in the factory
			QvtOperationalEnv parent = (QvtOperationalEnv) environment;
			//
			// copy from createClassifierContext
			//
			environment = envFactory.createEnvironment(parent);
	        UMLReflection<EPackage, EClassifier, EOperation, EStructuralFeature, EEnumLiteral, EParameter, EObject, CallOperationAction, SendSignalAction, Constraint> uml = parent.getUMLReflection();
	        type = uml.asOCLType(type);
	        org.eclipse.ocl.expressions.Variable<EClassifier, EParameter> self = parent.getOCLFactory().createVariable();
	        uml.setName(self, Environment.SELF_VARIABLE_NAME);
	        uml.setType(self, type);
	        
	        environment.addElement(self.getName(), self, true);
	        environment.setSelfVariable(self);
a257 1
		handleImportedExtensions(rootEnv, environment);
d260 1
a260 46

    /*
     * Behavior differs when rootEnv or leaf is populated, because
     * QVTTypeResolver looks for additional operations in siblings of root environment,
     * while QvtEnvironmentBase#lookupImplicitSourceForOperation
     * respects siblings of actual environment being queried.  
     */
    private void handleImportedExtensions(QvtOperationalEnv... envToPopulate) {
		if (getImportedExtensions().length == 0) {
			return;
		}
		HashSet<QvtOperationalEnv> siblings = new HashSet<QvtOperationalEnv>();
        final String[] extensions = getImportedExtensions();
        for (String extension : extensions) {
        	final QvtResource qvtResource = getScope().findExtension(extension);
        	if (qvtResource == null) {
        		throw new RuntimeException("Unable to load extension file : " + extension);
        	}
        	siblings.add(qvtResource.getEnvironment());
        }
        for (QvtOperationalEnv s : siblings) {
    		// XXX alternative is to respect siblings on any level of the environment hierarchy
        	// either in QVTTypeResolverImpl#getAdditionalOperations
        	// or QvtEnvironmentBase#getAdditionalOperations
        	for (QvtOperationalEnv toPopulate: envToPopulate) {
        		toPopulate.addSibling(s);
        	}
        }
/*
		TypeResolver<EClassifier, EOperation, EStructuralFeature> typeResolver = environment.getTypeResolver();
		for (QvtExtension e : getAllExtensions()) {
			if (e.getContext() == null || e.getOperation() == null) {
				// perhaps, static helper. Skip?
				// FIXME not sure how to handle static operations,
				// TypeUtil#getOperations (look for uml.isStatic() call ) and 
				// implementation of ecore.UMLReflection#isStatic (always false) make me believe 
				// (for now), that it's not feasible with Ecore models
				System.out.println("resolveAdditionalOperation:" + e.getContext());
				System.out.println("resolveAdditionalOperation:" + e.getOperation());
			} else {
				typeResolver.resolveAdditionalOperation(e.getContext(), e.getOperation());
			}
		}
*/
    }

a266 9
    	for (Object s : environment.getSiblings()) {
    		Module moduleClass = ((QvtOperationalEnv) s).getModuleContextType();
    		if (moduleClass == null) {
    			continue;
    		}
			EObject instance = fakeModuleInstanceFactory.create(moduleClass);
	    	ee.replace(moduleClass.getName() + QvtOperationalFileEnv.THIS_VAR_QNAME_SUFFIX, instance);

    	}
a267 1
    private static EFactoryImpl fakeModuleInstanceFactory = new EFactoryImpl() {};
d290 1
@


1.1.2.5
log
@siblings are not supposed to be available to any but parent environment
@
text
@d92 1
a92 1
        result.rootEnvironment = rootEnvironment;
d106 1
a106 1
    	result.rootEnvironment = null; // need to make sure resource's imports are read into registry.
d237 1
a237 1
    private QvtOperationalEnv rootEnvironment; // null-ified when context's resource is changed
d244 1
a244 1
    	if (rootEnvironment == null) {
d246 2
a247 2
    		rootEnvironment = new QvtOperationalEnv(null, getAllVisibleModels()) {};
    		handleImportedExtensions();
d249 3
a251 2
    	QvtOperationalEnvFactory envFactory = QvtOperationalEnvFactory.INSTANCE;
		environment = envFactory.createEnvironment(rootEnvironment);
d284 1
d288 7
a294 2
    // rootEnvironment must be initialized at the moment
    private void handleImportedExtensions() {
a297 1
    	assert rootEnvironment != null;
d311 3
a313 1
       		rootEnvironment.addSibling(s);
a333 2
    	assert rootEnvironment != null;
    	getOCLEnvironment(); // just in case root environment is not yet initialized
d339 1
a339 2
    	// siblings make sense for root environment only
    	for (Object s : rootEnvironment.getSiblings()) {
@


1.1.2.6
log
@[243154] Use OCL instead of home-grown expression language - moving towards no explicit use of 'this' keyword
@
text
@d85 2
a86 2
    public Variable getImplicitVariable() {
        return variables.get(IMPLICIT_VARIABLE);
@


1.1.2.7
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d24 3
d28 2
d31 1
d40 3
a43 1
import org.eclipse.m2m.qvt.oml.runtime.util.OCLEnvironmentWithQVTAccessFactory;
d45 2
d50 2
d92 1
a92 1
        result.envFactory = envFactory;
d106 1
a106 1
    	result.envFactory = null; // need to make sure resource's imports are read into registry.
d237 2
a238 2
    private OCLEnvironmentWithQVTAccessFactory envFactory; // null-ified when context's resource is changed
    private EcoreEnvironment environment;
d244 4
a247 11
    	if (envFactory == null) {
    		HashSet<Module> imports = new HashSet<Module>();
            final String[] extensions = getImportedExtensions();
            for (String extension : extensions) {
            	final QvtResource qvtResource = getScope().findExtension(extension);
            	if (qvtResource == null) {
            		throw new RuntimeException("Unable to load extension file : " + extension);
            	}
            	imports.add(qvtResource.getEnvironment().getModuleContextType());
            }
    		envFactory = new OCLEnvironmentWithQVTAccessFactory(imports, getAllVisibleModels());
d249 2
a250 2
		environment = (EcoreEnvironment) envFactory.createEnvironment();
		Variable that = getImplicitVariable();
d252 1
a252 1
    		if (that != v) {
d264 18
a281 3
		if (that != null) {
			EClassifier type = that.getType() == null ? BuiltinMetaModel.getType(this, that.getValue()) : that.getType();
			environment = (EcoreEnvironment) envFactory.createClassifierContext(environment, type);
d286 42
a327 6
    public EcoreEvaluationEnvironment createEvaluationEnvironment() {
    	if (envFactory == null) {
    		getOCLEnvironment();
    	}
    	EcoreEvaluationEnvironment ee = (EcoreEvaluationEnvironment) envFactory.createEvaluationEnvironment();
    	Variable that = getImplicitVariable();
d329 1
a329 1
    		if (that != v) {
d333 9
a341 2
    	if (that != null) {
    		ee.add(Environment.SELF_VARIABLE_NAME, that.getValue());
a342 1
    	return ee;
d344 1
d346 3
a348 3
	private String[] getImportedNamespaces() {
		return currentResource == null ? new String[0] : currentResource.getImportedNamespaces();
	}
@


