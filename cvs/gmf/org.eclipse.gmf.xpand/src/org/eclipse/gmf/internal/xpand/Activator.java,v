head	1.7;
access;
symbols
	v20081022-1925:1.7
	v20081020-0700:1.7
	ocl_qvt:1.7.0.4
	Root_ocl_qvt:1.7
	v20080722-1827:1.7
	v20080718-1731:1.7
	v20080716-1600:1.7
	v20080716-1642:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080528-1052:1.7
	v20080516-1143:1.7
	v20080417-1610:1.7
	v20080322-0000:1.7
	v20080222-1200:1.7
	v20071130-1111:1.7
	v20071124-0000:1.5
	v20071108-0000:1.7
	v20071003-0000:1.5
	v20070921-0000:1.5
	v20070903-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	RC3_20:1.5
	v20070608-1300:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070518-1300:1.5
	v20070420-1000:1.5
	v20070405-1100:1.5
	v20070403-1500:1.5
	v20070330-1300:1.5
	v20070208-1800:1.5
	v20070103-0300:1.5
	M4_20:1.5
	M3_20:1.4;
locks; strict;
comment	@# @;


1.7
date	2007.10.29.17.40.17;	author atikhomirov;	state Exp;
branches
	1.7.4.1;
next	1.6;
commitid	10ff47261b014567;

1.6
date	2007.10.29.16.58.22;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	5b914726112d4567;

1.5
date	2006.11.27.19.47.01;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	3793456b40b54567;

1.4
date	2006.11.10.13.17.06;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.09.21.03.17;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.25.17.23.40;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.50;	author atikhomirov;	state Exp;
branches;
next	;

1.7.4.1
date	2008.08.08.16.30.30;	author atikhomirov;	state Exp;
branches;
next	1.7.4.2;
commitid	90c489c74a54567;

1.7.4.2
date	2008.08.12.11.17.21;	author atikhomirov;	state Exp;
branches;
next	;
commitid	119348a1713f4567;


desc
@@


1.7
log
@[207437] Resources to be composed from several sources - fix/support and test for local calls from non-resource-based templates (hanging in the air wiith "nofile"), simplified default root handling for ws resources.
@
text
@/*******************************************************************************
 * Copyright (c) 2006, 2007 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package org.eclipse.gmf.internal.xpand;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Plugin;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.gmf.internal.xpand.build.MetaModelSource;
import org.osgi.framework.BundleContext;

public class Activator extends Plugin {
	private static Activator anInstance;

	public Activator() {
	}

	@@Override
	public void start(BundleContext context) throws Exception {
		super.start(context);
		anInstance = this;
		ResourcesPlugin.getWorkspace().addResourceChangeListener(myRootsTracker);
	}

	@@Override
	public void stop(BundleContext context) throws Exception {
		ResourcesPlugin.getWorkspace().removeResourceChangeListener(myRootsTracker);
		anInstance = null;
		super.stop(context);
	}

	public static String getId() {
		return anInstance.getBundle().getSymbolicName();
	}
	public static void logWarn(String message) {
		log(new Status(IStatus.WARNING, getId(), 0, message, null));
	}
	public static void logError(Exception e) {
		if (e instanceof CoreException) {
			log(((CoreException) e).getStatus());
		} else {
			log(new Status(IStatus.ERROR, getId(), 0, e.getMessage(), e));
		}
	}
	public static void log(IStatus status) {
		anInstance.getLog().log(status);
	}

	private final Map<IProject, RootManager> rootManagers = new HashMap<IProject, RootManager>();

	public static ResourceManager getResourceManager(final IFile file) {
		//TODO: return a delegating resource manager to XpandEditor, to silently change context when roots change.
		RootManager manager = getRootManager(file.getProject());
		ResourceManager result = manager.getResourceManager(file);
		assert result != null;
		return result;
	}

	public static RootManager getRootManager(IProject project) {
		synchronized(anInstance.myRootsTracker) {
			RootManager result = anInstance.rootManagers.get(project);
			if (result == null) {
				result = new RootManager(project);
				anInstance.rootManagers.put(project, result);
			}
			return result;
		}
	}

	private final IResourceChangeListener myRootsTracker = new IResourceChangeListener() {
		public synchronized void resourceChanged(IResourceChangeEvent event) {
			if (event == null || event.getDelta() == null) {
				return;
			}
			Set<RootManager> affectedRootManagers = new HashSet<RootManager>();
			IResourceDelta rootDelta = event.getDelta();
			for (IResourceDelta projectDelta : rootDelta.getAffectedChildren()) {
				IProject affectedProject = (IProject) projectDelta.getResource();
				if (isRemovedOrClosed(projectDelta)) {
					rootManagers.remove(affectedProject);
				} else {
					IResourceDelta configFileDelta = projectDelta.findMember(RootManager.PROJECT_RELATIVE_PATH_TO_CONFIG_FILE);
					if (configFileDelta != null && rootManagers.containsKey(affectedProject) && affectsConfigFile(configFileDelta)) {
						affectedRootManagers.add(getRootManager(affectedProject));
					}
				}
			}
			//Opening/closing or creating/deleting a project may affect roots with absolute paths.
			for (IResourceDelta projectDelta : rootDelta.getAffectedChildren()) {
				if (mayAffectOtherResourceManagers(projectDelta)) {
					IPath projectPath = projectDelta.getFullPath();
					for (RootManager nextManager : rootManagers.values()) {
						if (nextManager.containsProject(projectPath)) {
							affectedRootManagers.add(nextManager);
						}
					}
				}
			}
			for (RootManager nextManager : affectedRootManagers) {
				nextManager.rootsChanged();
			}
		}

		private boolean affectsConfigFile(IResourceDelta configFileDelta) {
			if ((configFileDelta.getKind() & (IResourceDelta.ADDED | IResourceDelta.REMOVED)) > 0) {
				return true;
			}
			if ((configFileDelta.getFlags() & (IResourceDelta.CONTENT | IResourceDelta.ENCODING | IResourceDelta.SYNC | IResourceDelta.TYPE | IResourceDelta.REPLACED)) > 0) {
				return true;
			}
			return false;
		}

		private boolean isRemovedOrClosed(IResourceDelta projectDelta) {
			if (projectDelta.getKind() == IResourceDelta.REMOVED) {
				return true;
			}
			if ((projectDelta.getFlags() & IResourceDelta.OPEN) > 0) {
				return !projectDelta.getResource().isAccessible();
			}
			return false;
		}
		private boolean mayAffectOtherResourceManagers(IResourceDelta projectDelta) {
			if ((projectDelta.getKind() & (IResourceDelta.REMOVED | IResourceDelta.ADDED)) > 0) {
				return true;
			}
			if ((projectDelta.getFlags() & IResourceDelta.OPEN) > 0) {
				return !projectDelta.getResource().isAccessible();
			}
			return false;
		}
	};

	private final Set<MetaModelSource> modelSources = new LinkedHashSet<MetaModelSource>();
	public static void registerModelSource(MetaModelSource modelSource) {
		assert modelSource != null;
		anInstance.modelSources.add(modelSource);
	}

	public static EPackage findMetaModel(String nsURI) {
		if (anInstance == null) {
			// this is for tests execution (which doesn't take place in plugin env)
			return null;
		}
		for (MetaModelSource s : anInstance.modelSources) {
			EPackage p = s.find(nsURI);
			if (p != null) {
				return p;
			}
		}
		return EPackage.Registry.INSTANCE.getEPackage(nsURI);
	}
}
@


1.7.4.1
log
@fixed copyrights
@
text
@d1 2
a2 2
/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
d8 1
a8 1
 */
@


1.7.4.2
log
@[243154] Use OCL instead of home-grown expression language - support old syntax for DEFINE
@
text
@d53 1
a53 1
		return anInstance == null ? String.valueOf(anInstance) : anInstance.getBundle().getSymbolicName();
d66 1
a66 5
		if (anInstance != null) {
			anInstance.getLog().log(status);
		} else {
			System.err.println(status);
		}
@


1.6
log
@[207437] Resources to be composed from several sources
@
text
@a10 3
import java.io.IOException;
import java.io.Reader;
import java.util.Collection;
a25 1
import org.eclipse.core.runtime.Path;
a29 3
import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;
import org.eclipse.gmf.internal.xpand.util.ResourceManagerImpl;
import org.eclipse.gmf.internal.xpand.util.StreamConverter;
d75 2
a76 23
		if (result != null) {
			return result;
		}
		//Must not return null here. Return a fake resource manager that only knows how to handle the given file
		return new ResourceManagerImpl() {
			@@Override
			protected boolean shouldCache() {
				return false;
			}
			@@Override
			protected Reader resolve(String fullyQualifiedName, String extension) throws IOException {
				if (extension.equals(file.getFileExtension()) && fullyQualifiedName.replace(SyntaxConstants.NS_DELIM, "/").equals(file.getProjectRelativePath().toString())) {
					try {
						return new StreamConverter().toContentsReader(file);
					} catch (CoreException ex) {
						IOException wrap = new IOException(ex.getStatus().getMessage());
						wrap.initCause(ex);
						throw wrap;
					}
				}
				return null;
			}
		};
@


1.5
log
@avoid NPE during test run
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Eclipse.org
d11 3
d15 1
d20 1
d22 4
d27 1
d29 1
d34 3
a36 1
import org.eclipse.gmf.internal.xpand.build.WorkspaceResourceManager;
d49 1
d54 1
d76 1
a76 1
	private final Map<IProject, ResourceManager> resourceManagers = new HashMap<IProject, ResourceManager>();
d78 6
a83 3
	public static ResourceManager getResourceManager(IProject context) {
		if (anInstance.resourceManagers.containsKey(context)) {
			return anInstance.resourceManagers.get(context);
d85 20
a104 3
		ResourceManager resourceManager = new WorkspaceResourceManager(context);
		registerResourceManager(context, resourceManager);
		return resourceManager;
d107 9
a115 3
	public static void registerResourceManager(IProject project, ResourceManager resourceManager) {
		assert !anInstance.resourceManagers.containsKey(project);
		anInstance.resourceManagers.put(project, resourceManager);
d118 64
@


1.4
log
@use model instances from development workspace
@
text
@d84 4
@


1.3
log
@qualified names are not used
@
text
@d12 1
d14 1
d21 2
d76 16
@


1.2
log
@refactored resource manager into capable working in workspace and working with uris, added experimental extended error reporting to provide more details on parsing errors
@
text
@a17 1
import org.eclipse.core.runtime.QualifiedName;
d64 1
a64 6
		anInstance.resourceManagers.put(context, resourceManager);
		try {
			context.setSessionProperty(new QualifiedName("xpand","resourceManager"), resourceManager);
		} catch (CoreException ex) {
			log(ex.getStatus());
		}
d67 5
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@a13 1
import org.eclipse.core.resources.IFile;
a15 1
import org.eclipse.core.runtime.IPath;
d20 1
a20 2
import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;
import org.eclipse.gmf.internal.xpand.util.ResourceManagerImpl;
a57 6
	public static String getQualifiedName(final IFile file) {
		IPath p = file.getProjectRelativePath().removeFileExtension().makeRelative();
		final String fqn = p.toString().replace("/", SyntaxConstants.NS_DELIM);
		return fqn;
	}

d64 1
a64 1
		ResourceManagerImpl resourceManager = new ResourceManagerImpl(context);
@

