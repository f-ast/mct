head	1.3;
access;
symbols
	v20081022-1925:1.3
	v20081020-0700:1.3
	ocl_qvt:1.3.0.4
	Root_ocl_qvt:1.3
	v20080722-1827:1.3
	v20080718-1731:1.3
	v20080716-1600:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.2
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080528-1052:1.3
	v20080516-1143:1.3
	v20080417-1610:1.3
	v20080322-0000:1.3
	v20080222-1200:1.3
	v20071130-1111:1.3
	v20071124-0000:1.2.2.1
	v20071108-0000:1.2
	v20071003-0000:1.2
	v20070921-0000:1.2
	v20070903-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	RC3_20:1.2
	v20070608-1300:1.2
	v20070605-1400:1.2
	v20070601-1400:1.2
	v20070518-1300:1.2
	v20070420-1000:1.2
	v20070405-1100:1.2
	v20070403-1500:1.2
	v20070330-1300:1.2
	v20070208-1800:1.2
	v20070103-0300:1.2
	M4_20:1.2
	M3_20:1.2;
locks; strict;
comment	@# @;


1.3
date	2007.11.16.13.45.23;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	4d4473d9ef24567;

1.2
date	2006.11.08.19.08.32;	author atikhomirov;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.11.08.14.45.16;	author atikhomirov;	state Exp;
branches;
next	;

1.2.2.1
date	2007.11.16.13.48.37;	author atikhomirov;	state Exp;
branches;
next	;
commitid	889473d9fb44567;


desc
@@


1.3
log
@fully-qualified names of xpand templates are not processed correctly with the old pattern - and with assertions enabled the thread is stopped.
@
text
@$Globals
	/.import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.gmf.internal.xpand.util.ParserException.ErrorLocationInfo;
./
$End

$Headers
	/.
		public ErrorLocationInfo[] getErrors() {
			return errors.toArray(new ErrorLocationInfo[errors.size()]);
		}

		private void resetErrors() {
			errors.clear();
		}

		private final List<ErrorLocationInfo> errors = new LinkedList<ErrorLocationInfo>();

		@@Override
		public void reportError(int errorCode, String locationInfo, int leftToken, int rightToken, String tokenText) {
			final int leftTokenLine = getLine(leftToken);
			final int leftTokenColumn = getColumn(leftToken);
			final int rightTokenLine = getEndLine(rightToken);
			final int rightTokenColumn = getEndColumn(rightToken);
			final String msg = tokenText + errorMsgText[errorCode];
			errors.add(new ErrorLocationInfo(msg, leftTokenLine, leftTokenColumn, rightTokenLine, rightTokenColumn));
		}
/*
		@@Override
		public void reportError(int leftToken, int rightToken) {
			int errorCode = (rightToken >= getStreamLength() ? EOF_CODE : leftToken == rightToken ? LEX_ERROR_CODE : INVALID_TOKEN_CODE);
			int endToken = (leftToken == rightToken ? rightToken : rightToken - 1);
			String msg = (errorCode == EOF_CODE ? "End-of-file " : errorCode == INVALID_TOKEN_CODE
						? "\"" + new String(getInputChars(), leftToken, rightToken - leftToken) + "\" "
						: "\"" + getCharValue(leftToken) + "\" ");

			final int leftTokenLine = getLine(leftToken);
			final int leftTokenColumn = getColumn(leftToken);
			final int rightTokenLine = getEndLine(endToken);
			final int rightTokenColumn = getEndColumn(endToken);
			errors.add(new ErrorLocationInfo(msg, leftTokenLine, leftTokenColumn, rightTokenLine, rightTokenColumn));
		}
*/
		@@Override
		public void reportError(int errorCode, String locationInfo, String tokenText) {
			try {
				Matcher m = Pattern.compile("(?:[^:]+::)*[^:]+:(\\d+):(\\d+):(\\d+):(\\d+):.*").matcher(locationInfo);
				boolean t = m.matches(); // ignore return value, rely on exception if anything wrong
				assert t;
				final int leftTokenLine = getLine(Integer.parseInt(m.group(1)));
				final int leftTokenColumn = getColumn(Integer.parseInt(m.group(2)));
				final int rightTokenLine = getEndLine(Integer.parseInt(m.group(3)));
				final int rightTokenColumn = getEndColumn(Integer.parseInt(m.group(4)));
				final String msg = tokenText + errorMsgText[errorCode];
				errors.add(new ErrorLocationInfo(msg, leftTokenLine, leftTokenColumn, rightTokenLine, rightTokenColumn));
			} catch (Throwable ex) {
				// ignore
				errors.add(new ErrorLocationInfo(tokenText + errorMsgText[errorCode]));
			}
		}
	./
$End@


1.2
log
@combine errors reported separately from lexer and parser
@
text
@d51 1
a51 1
				Matcher m = Pattern.compile("[^:]+:(\\d+):(\\d+):(\\d+):(\\d+):.*").matcher(locationInfo);
d60 1
a60 1
			} catch (Exception ex) {
@


1.2.2.1
log
@merge fix from HEAD: fully-qualified names of xpand templates are not processed correctly with the old pattern - and with assertions enabled the thread is stopped.
@
text
@d51 1
a51 1
				Matcher m = Pattern.compile("(?:[^:]+::)*[^:]+:(\\d+):(\\d+):(\\d+):(\\d+):.*").matcher(locationInfo);
d60 1
a60 1
			} catch (Throwable ex) {
@


1.1
log
@error handling
@
text
@a30 1
			super.reportError(errorCode, locationInfo, leftToken, rightToken, tokenText);
a45 1
			super.reportError(leftToken, rightToken);
a63 1
			super.reportError(errorCode, locationInfo, tokenText);
@

