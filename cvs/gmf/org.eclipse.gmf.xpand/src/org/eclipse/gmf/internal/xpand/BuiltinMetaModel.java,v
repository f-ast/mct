head	1.23;
access;
symbols
	v20081022-1925:1.23
	v20081020-0700:1.23
	ocl_qvt:1.23.0.2
	Root_ocl_qvt:1.23
	v20080722-1827:1.23
	v20080718-1731:1.23
	v20080716-1600:1.21
	v20080716-1642:1.23
	R2_1_maintenance:1.21.0.4
	Root_R2_1_maintenance:1.21
	R2_1_0:1.21
	v20080528-1052:1.21
	v20080516-1143:1.21
	v20080417-1610:1.21
	v20080322-0000:1.21
	v20080222-1200:1.21
	v20071130-1111:1.21
	v20071124-0000:1.21
	v20071108-0000:1.21
	v20071003-0000:1.21
	v20070921-0000:1.21
	v20070903-0000:1.21
	v20070809-0000:1.21
	R2_0_maintenance:1.21.0.2
	R2_0:1.21
	R4_20:1.21
	RC3_20:1.21
	v20070608-1300:1.21
	v20070605-1400:1.20
	v20070601-1400:1.19
	v20070518-1300:1.19
	v20070420-1000:1.19
	v20070405-1100:1.18
	v20070403-1500:1.18
	v20070330-1300:1.17
	v20070208-1800:1.17
	v20070103-0300:1.12
	M4_20:1.12
	M3_20:1.4;
locks; strict;
comment	@# @;


1.23
date	2008.07.01.20.03.54;	author atikhomirov;	state Exp;
branches
	1.23.2.1;
next	1.22;
commitid	2928486a8da94567;

1.22
date	2008.07.01.18.45.02;	author atikhomirov;	state Exp;
branches;
next	1.21;
commitid	4c7c486a7b2c4567;

1.21
date	2007.06.06.17.43.20;	author atikhomirov;	state Exp;
branches;
next	1.20;
commitid	71f64666f2374567;

1.20
date	2007.06.05.13.37.24;	author atikhomirov;	state Exp;
branches;
next	1.19;
commitid	2f49466567134567;

1.19
date	2007.04.19.10.00.27;	author atikhomirov;	state Exp;
branches;
next	1.18;
commitid	554a46273dba4567;

1.18
date	2007.04.03.16.00.50;	author atikhomirov;	state Exp;
branches;
next	1.17;
commitid	749246127a2e4567;

1.17
date	2007.01.25.15.50.20;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	4e6845b8d1bb4567;

1.16
date	2007.01.23.13.49.34;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	22a545b6126e4567;

1.15
date	2007.01.18.19.17.04;	author ashatalin;	state Exp;
branches;
next	1.14;
commitid	22f45afc7b04567;

1.14
date	2007.01.17.13.12.36;	author ashatalin;	state Exp;
branches;
next	1.13;
commitid	3d7745ae20c34567;

1.13
date	2007.01.10.17.28.14;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	62345a5222c4567;

1.12
date	2006.12.28.19.15.08;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	7940459417bb4567;

1.11
date	2006.12.19.14.39.37;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	3c694587f9a84567;

1.10
date	2006.12.15.17.26.23;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	1d5e4582dabc4567;

1.9
date	2006.11.30.14.32.00;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	3757456eeb5e4567;

1.8
date	2006.11.30.14.04.14;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	6600456ee4dd4567;

1.7
date	2006.11.29.16.26.47;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	461f456db4c64567;

1.6
date	2006.11.27.20.32.17;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	232f456b4b514567;

1.5
date	2006.11.27.19.48.11;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	3970456b40fb4567;

1.4
date	2006.11.02.17.34.35;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.30.19.40.21;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.24.19.49.42;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.50;	author atikhomirov;	state Exp;
branches;
next	;

1.23.2.1
date	2008.08.05.12.49.24;	author atikhomirov;	state Exp;
branches;
next	1.23.2.2;
commitid	546c48984c4a4567;

1.23.2.2
date	2008.08.06.14.05.35;	author atikhomirov;	state Exp;
branches;
next	1.23.2.3;
commitid	35b4899afa74567;

1.23.2.3
date	2008.08.08.18.15.51;	author atikhomirov;	state Exp;
branches;
next	1.23.2.4;
commitid	51ea489c8d554567;

1.23.2.4
date	2008.08.10.15.10.44;	author atikhomirov;	state Exp;
branches;
next	;
commitid	2d13489f04f14567;


desc
@@


1.23
log
@recognizez java object operations (like == or !=) on EnumType::EnumLiteral during analyze phase
@
text
@/*******************************************************************************
 * Copyright (c) 2006, 2008 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package org.eclipse.gmf.internal.xpand;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.eclipse.emf.common.util.Enumerator;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EParameter;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.EcoreFactory;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.gmf.internal.xpand.expression.PolymorphicResolver;
import org.eclipse.gmf.internal.xpand.model.XpandDefinitionWrap;
import org.eclipse.gmf.internal.xpand.model.XpandIterator;

/**
 * XXX Guess, will need special support to recognize the fact
 * EJavaObject.isSupertypeOf(EObject)
 * 
 * @@author artem
 */
@@SuppressWarnings("unchecked")
public class BuiltinMetaModel {
    public final static String SET = "Set";
    public final static String LIST = "List";

	
	private static EPackage XECORE = EcoreFactory.eINSTANCE.createEPackage();
	
	static {
		XECORE.setName("xecore");
		XECORE.setNsPrefix("xecore");
		XECORE.setNsURI("uri:org.eclipse.modeling/m2t/xpand/xecore/1.0");
	}

	private static EClass PARAMETERIZED_TYPE = EcoreFactory.eINSTANCE.createEClass();
	private static EReference PT_INNER_TYPE_REF = EcoreFactory.eINSTANCE.createEReference();
	private static EAttribute PT_INNER_TYPE_ATTR = EcoreFactory.eINSTANCE.createEAttribute();

	static {
		PARAMETERIZED_TYPE.setName("ParameterizedType");
		PARAMETERIZED_TYPE.getESuperTypes().add(EcorePackage.eINSTANCE.getEClass());
		PARAMETERIZED_TYPE.setAbstract(true);
		PT_INNER_TYPE_REF.setName("innerType");
		PT_INNER_TYPE_REF.setContainment(false);
		PT_INNER_TYPE_REF.setEType(EcorePackage.eINSTANCE.getEClass());

		PARAMETERIZED_TYPE.getEStructuralFeatures().add(PT_INNER_TYPE_REF);

		PT_INNER_TYPE_ATTR.setName("innerDataType");
		PT_INNER_TYPE_ATTR.setEType(EcorePackage.eINSTANCE.getEDataType());
		PARAMETERIZED_TYPE.getEStructuralFeatures().add(PT_INNER_TYPE_ATTR);
		XECORE.getEClassifiers().add(PARAMETERIZED_TYPE);
	}

	/**
	 * Checks whether classifier is one of user's model extension classes
	 * (conforming to ParameterizedType from our extended ECore meta-model).
	 * EClassifier instances available in analyze() methods are param
	 * candidates.
	 * 
	 * @@param parameterizedTypeM1 -
	 *            e.g. EClass "Order", or XEClass "OrderList"
	 */
	public static boolean isParameterizedType(EClassifier parameterizedTypeM1) {
		return PARAMETERIZED_TYPE.isSuperTypeOf(parameterizedTypeM1.eClass());
	}

	// XXX revisit invocations, this check is doubled with isParameterizedType, perhaps, can refactor it 
	public static boolean isCollectionType(EClassifier parameterizedTypeM1) {
		// XXX this implementation is not really 'isCollectionType', it's just a copy of what was in the original code
		return isAssignableFrom(CollectionTypesSupport.COLLECTION_OF_OBJECT, parameterizedTypeM1);
	}

	public static EClassifier getInnerType(EClassifier parameterizedTypeM1) {
		assert isParameterizedType(parameterizedTypeM1);
		if (parameterizedTypeM1.eIsSet(PT_INNER_TYPE_REF)) {
			return (EClass) parameterizedTypeM1.eGet(PT_INNER_TYPE_REF);
		} else {
			return (EDataType) parameterizedTypeM1.eGet(PT_INNER_TYPE_ATTR);
		}
	}

	/**
	 * NOTE, parameterizedTypeM1 is M1 instance, you can't pass {@@link BuiltinMetaModel#COLLECTION_TYPE} (or {@@link BuiltinMetaModel#LIST_TYPE}) here,
	 * because COLLECTION_TYPE just extends PARAMETERIZED_TYPE, but still instance of EClass. We could, however, have COLLECTION_TYPE to be an
	 * instance of PARAMETERIZED_TYPE, and then we could use this method. The reasons not to do so (at least, now) are
	 * (a) didn't think it over yet (b) looks like extending M2 (sic!) dynamically, though I don't like even M1 polluting with type
	 * that happens.
	 * @@param parameterizedTypeM1
	 * @@param innerTypeM1
	 * @@return
	 */
	public static EClass cloneParametrizedType(EClassifier parameterizedTypeM1, EClassifier innerTypeM1) {
		assert isParameterizedType(parameterizedTypeM1);
		return collectionTypes.getCollectionType(parameterizedTypeM1.eClass(), innerTypeM1);
	}

	/*package*/ static EClass internalNewParameterizedType(EClass parameterizedTypeM2, EClassifier inner) {
		assert PARAMETERIZED_TYPE.isSuperTypeOf(parameterizedTypeM2);
		EObject anInstance = XECORE.getEFactoryInstance().create(parameterizedTypeM2);
		assert anInstance instanceof EClass : "EClass is first supertype with instanceClass set";
		// e.g. "OrderCollection" or "IntegerList"
		((EClass) anInstance).setName(inner.getName() + parameterizedTypeM2.getName());
		anInstance.eSet(inner instanceof EClass ? PT_INNER_TYPE_REF : PT_INNER_TYPE_ATTR, inner);
		return (EClass) anInstance;
	}

	public static final EClass VOID = EcoreFactory.eINSTANCE.createEClass();

	static {
		VOID.setName("void");
		XECORE.getEClassifiers().add(VOID);
	}

	private static CollectionTypesSupport collectionTypes = new CollectionTypesSupport();

	static {
		collectionTypes.init(XECORE, PARAMETERIZED_TYPE);
	}
	/**
	 * @@param name
	 * @@return true if name is one of M2 collection meta-types (either Collection, List, Set)
	 */
	public static boolean isCollectionMetaType(String name) {
		return collectionTypes.isCollectionMetaType(name);
	}

	public static EClass getCollectionType(String metaTypeName, EClassifier innerType) {
		return collectionTypes.getCollectionType(metaTypeName, innerType);
	}

	// XXX actually, it's odd to use abstract and vague 'collection' 
	public static EClass getCollectionType(EClassifier innerType) {
		return collectionTypes.getCollectionType(innerType);
	}
	public static EClass getListType(EClassifier innerType) {
		return collectionTypes.getListType(innerType);
	}
	public static EClass getSetType(EClassifier innerType) {
		return collectionTypes.getSetType(innerType);
	}

	public static final EClass DEFINITION_TYPE = EcoreFactory.eINSTANCE.createEClass();

	static {
		DEFINITION_TYPE.setName("xpand2::Definition");
		DEFINITION_TYPE.getESuperTypes().add(EcorePackage.eINSTANCE.getEClass());
		XECORE.getEClassifiers().add(DEFINITION_TYPE);
	}

	public static final EClass ITERATOR_TYPE = EcoreFactory.eINSTANCE.createEClass();

	static {
		ITERATOR_TYPE.setName("xpand2::Iterator");
		ITERATOR_TYPE.getESuperTypes().add(EcorePackage.eINSTANCE.getEClass());
		XECORE.getEClassifiers().add(ITERATOR_TYPE);
	}

	/**
	 * ECore doesn't support 'return types' for Enums, to my best knowledge,
	 * they are all integers. original EEnumType returns itself as static
	 * property's return type BTW, what if we'd like to get string value, name,
	 * instead
	 */
	public static EClassifier getReturnType(EEnumLiteral sp) {
		return sp.getEEnum();
	}

	// TODO obj.getClass lookup tree?
	public static EClassifier getType(Object obj) {
		if (obj == null) {
			return VOID;
		}
		if (obj instanceof Enumerator) {
			// unlike original impl, we don't return Enum as type
			// mostly because it's just too hard to look for actual enum
			// XXX perhaps, EEnumLiteral.getEEnum could help?
			return EcorePackage.eINSTANCE.getEEnumerator();
		}
		if (obj instanceof EObject) {
			return ((EObject) obj).eClass();
		}
		if (obj instanceof Collection) {
			EClassifier type = null;
			if (!((Collection) obj).isEmpty()) {
				// FIXME respect all! elements in the collection, not only the first one
				type = getType(((Collection) obj).iterator().next());
			}
			if (obj instanceof Set) {
				return collectionTypes.getSetType(type);
			}
			if (obj instanceof List) {
				return collectionTypes.getListType(type);
			}
			return collectionTypes.getCollectionType(type);
		}
		if (obj instanceof Boolean) {
			return EcorePackage.eINSTANCE.getEBoolean();
		}
		if ((obj instanceof Byte) || (obj instanceof Integer) || (obj instanceof Long) || obj instanceof Short) {
			return EcorePackage.eINSTANCE.getEInt();
		}
		if ((obj instanceof Float) || (obj instanceof Double)) {
			return EcorePackage.eINSTANCE.getEDouble();
		}
		if (obj instanceof String) {
			return EcorePackage.eINSTANCE.getEString();
		}
		if (obj instanceof XpandDefinitionWrap) {
			return DEFINITION_TYPE;
		}
		if (obj instanceof XpandIterator) {
			return ITERATOR_TYPE;
		}
		return EcorePackage.eINSTANCE.getEJavaObject();
	}

	/**
	 * FIXME HACK!!!
	 */
	public static Object newInstance(EClassifier t) {
		if (isCollectionType(t)) {
			return collectionTypes.newInstance(t);
		}
		if (t.getInstanceClass() != null) {
			try {
				return t.getInstanceClass().newInstance();
			} catch (Exception ex) {
				ex.printStackTrace();
			}
		}
		return null;
	}

	/**
	 * FIXME what if args has null or getType() returns null - we can't find an
	 * op then, and it's caller who knows how to handle this.
	 * 
	 * @@param name
	 * @@param args
	 * @@param instance
	 * @@return
	 */
	public static Operation executableOperation(String name, Object[] args, Object instance) {
		EClassifier[] argTypes = new EClassifier[args.length];
		for (int i = 0; i < args.length; i++) {
			argTypes[i] = getType(args[i]);
		}
		EOperation metaOp = findOperation(getType(instance), name, argTypes);
		if (metaOp == null) {
			return null;
		}
		if (InternalOperation.isInternalOp(metaOp)) {
			for (List<InternalOperation> ops : internalOperationsMap.values()) {
				for (InternalOperation internalOp : ops) {
					if (internalOp.metaOp == metaOp) {
						return new OperationEx(instance, args, internalOp);
					}
				}
			}
			throw new IllegalStateException("Can't find implementation of built-in operation" + metaOp);
		}
		return new Operation(instance, args, metaOp);
	}

	public static EOperation findOperation(EClassifier targetType, String name, EClassifier[] args) {
		List<EOperation> allOp;
		if (hasBuiltinSupport(targetType)) {
			// this one is to cover m2 types that are *propagated* to user's model, m1. Those like
			// boolean, integer, string, etc.
			allOp = findInternalOp(targetType);
		} else if (hasBuiltinSupport(targetType.eClass())){
			// this one is to cover collection types, because we register their operations
			// against meta-model (m2) instance, rather than against M1 
			allOp = findInternalOp(targetType.eClass());
		} else {
			if (false == (targetType instanceof EClass)) {
				return null;
			} else {
				allOp = new LinkedList<EOperation>(((EClass) targetType).getEAllOperations());
				allOp.addAll(findInternalOp(EcorePackage.eINSTANCE.getEJavaObject()));
			}
		}
		return PolymorphicResolver.filterOperation(allOp, name, targetType, Arrays.asList(args));
	}

	private static Map<String, String> attrNameSubsts = new TreeMap<String, String>();
	static {
		attrNameSubsts.put("default_", "default");
	}
	public static EStructuralFeature getAttribute(EClassifier type, String name) {
		if (hasBuiltinSupport(type)) {
			return findInternalAttr(type, name);
		}
		if (type instanceof EClass) {
			return ((EClass) type).getEStructuralFeature(attrNameSubsts.containsKey(name) ? attrNameSubsts.get(name): name);
		}
		if (type instanceof EEnum || type == EcorePackage.eINSTANCE.getEEnumLiteral() || type == EcorePackage.eINSTANCE.getEEnumerator()) {
			return EcorePackage.eINSTANCE.getEEnumLiteral().getEStructuralFeature(name);
		}
		return null;
	}
	public static Object getValue(EStructuralFeature prop, Object instance) {
		if (instance instanceof Enumerator) {
			if (prop == EcorePackage.eINSTANCE.getEEnumLiteral_Literal()) {
				return ((Enumerator) instance).getLiteral();
			}
			if (prop == EcorePackage.eINSTANCE.getENamedElement_Name()) {
				return ((Enumerator) instance).getName();
			}
			if (prop == EcorePackage.eINSTANCE.getEEnumLiteral_Value()) {
				return ((Enumerator) instance).getValue();
			}
		}
		if (instance instanceof EObject) {
			return ((EObject) instance).eGet(prop);
		}
		// handle collection/set/list properties?
		return "HeyHo!";
	}

	private static boolean hasBuiltinSupport(EClassifier type) {
		return internalOperationsMap.containsKey(type);
	}

	private static EStructuralFeature findInternalAttr(EClassifier type, String name) {
		if (type instanceof EClass) {
			return ((EClass) type).getEStructuralFeature(name);
		}
		if (type instanceof EDataType && type == EcorePackage.eINSTANCE.getEEnumerator()) {
			// I do not know where EMF uses EEnumLiteralImpl and where Enumerator for EEnum value. 
			return EcorePackage.eINSTANCE.getEEnumLiteral().getEStructuralFeature(name);
		}
		// TODO Auto-generated method stub
		return null;
	}

	private static final Map<EClassifier,List<InternalOperation>>  internalOperationsMap = new HashMap<EClassifier, List<InternalOperation>>();

	static {
		final EcorePackage ecorePkg = EcorePackage.eINSTANCE;
		final OperationFactory opf = new OperationFactory();

		final List<InternalOperation> objectOps = new LinkedList<InternalOperation>();
		objectOps.add(new InternalOperation<Object>(opf.create("compareTo", ecorePkg.getEBoolean(), ecorePkg.getEJavaObject())) {
			@@Override
			public Object evaluate(Object target, Object[] params) {
				if (target == null) {
					return params[0] == null ? 0 : -1;
				}
				if (params[0] == null) {
					return 1;
				}
				if (target instanceof Comparable) {
					return ((Comparable) target).compareTo(params[0]);
				}
				// note, unlike ObjectTypeImpl we don't invoke toString registered against metatype here
				return String.valueOf(target).compareTo(String.valueOf(params[0]));
			}
		});
		objectOps.add(new InternalOperation<Object>(opf.create("toString", ecorePkg.getEString())) {
			@@Override
			public Object evaluate(Object target, Object[] params) {
				return String.valueOf(target);
			}
		});
		objectOps.add(new InternalOperation<Object>(opf.create("==", boolean.class, Object.class)) {
			@@Override
			public Object evaluate(Object target, Object[] params) {
				return target == null ? params[0] == null : target.equals(params[0]);
			}
		});
		objectOps.add(new InternalOperation<Object>(opf.create("!=", boolean.class, Object.class)) {
			@@Override
			public Object evaluate(Object target, Object[] params) {
				return target == null ? params[0] != null : !target.equals(params[0]);
			}
		});
		List<InternalOperation> unmodifiableObjectOps = Collections.unmodifiableList(objectOps);
		internalOperationsMap.put(ecorePkg.getEJavaObject(), unmodifiableObjectOps);
		// EEnumerator are enum literal instances at runtime (#evaluate),
		// while EEnum are their types during #analyze phase
		internalOperationsMap.put(ecorePkg.getEEnumerator(), unmodifiableObjectOps);
		internalOperationsMap.put(ecorePkg.getEEnum(), unmodifiableObjectOps);

		final List<InternalOperation> stringOps = new LinkedList<InternalOperation>();

		stringOps.add(new InternalOperation<String>(opf.create("+",ecorePkg.getEString(),ecorePkg.getEJavaObject())) {
			@@Override
			public Object evaluate(String target, Object[] params) {
				return target + String.valueOf(params[0]);
			}
		});
		stringOps.add(new InternalOperation<String>(opf.create("toFirstUpper",ecorePkg.getEString())) {
			@@Override
			public Object evaluate(String target, Object[] params) {
				return StringHelper.firstUpper(target);
			}
		});
		stringOps.add(new InternalOperation<String>(opf.create("toFirstLower",ecorePkg.getEString())) {
			@@Override
			public Object evaluate(String target, Object[] params) {
				return StringHelper.firstLower(target);
			}
		});
		stringOps.add(new InternalOperation<String>(opf.create("toCharList",collectionTypes.getListType(ecorePkg.getEString()))) {
			@@Override
			public Object evaluate(String target, Object[] params) {
				ArrayList<String> rv = new ArrayList<String>(target.length());
				for (int i = 0; i < target.length(); i++) {
					rv.add(target.substring(i, i+1));
				}
				return rv;
			}
		});
		stringOps.add(opf.createReflective(String.class, "startsWith", String.class));
		stringOps.add(opf.createReflective(String.class, "endsWith", String.class));
		InternalOperation subStringOp = opf.createReflective(String.class, "substring", int.class, int.class);
		subStringOp.metaOp.setName("subString");
		stringOps.add(subStringOp);
		subStringOp = opf.createReflective(String.class, "substring", int.class);
		subStringOp.metaOp.setName("subString");
		stringOps.add(subStringOp);
		stringOps.add(opf.createReflective(String.class, "toUpperCase"));
		stringOps.add(opf.createReflective(String.class, "toLowerCase"));
		stringOps.add(opf.createReflective(String.class, "replaceAll", String.class, String.class));
		stringOps.add(opf.createReflective(String.class, "replaceFirst", String.class, String.class));
		stringOps.add(opf.createReflective(String.class, "split", String.class));
		stringOps.add(opf.createReflective(String.class, "matches", String.class));
		stringOps.add(opf.createReflective(String.class, "trim"));
		stringOps.add(opf.createReflective(String.class, "length"));
		stringOps.addAll(unmodifiableObjectOps);
		internalOperationsMap.put(ecorePkg.getEString(), Collections.unmodifiableList(stringOps));

		final List<InternalOperation> booleanOps = new LinkedList<InternalOperation>();
		booleanOps.add(new InternalOperation<Boolean>(opf.create("!", boolean.class)) {
			@@Override
			public Object evaluate(Boolean target, Object[] params) {
				return Boolean.valueOf(!target.booleanValue());
			}
		});
		booleanOps.addAll(unmodifiableObjectOps);
		internalOperationsMap.put(ecorePkg.getEBoolean(), Collections.unmodifiableList(booleanOps));
		final List<InternalOperation> voidOps = new LinkedList<InternalOperation>();
		voidOps.addAll(unmodifiableObjectOps);
		internalOperationsMap.put(VOID, Collections.unmodifiableList(voidOps));

		//---------------------------------------------------------------------------------
		class InternalSumOp extends InternalOperation<Number> {
			InternalSumOp(EOperation metaOp) {
				super(metaOp);
			}
			@@Override
			public Object evaluate(Number target, Object[] params) {
				if (target instanceof Double || params[0] instanceof Double) {
					return new Double(target.doubleValue() + ((Number) params[0]).doubleValue());
				} else {
					return new Integer(target.intValue() + ((Number) params[0]).intValue());
				}
			}
			
		}; 
		class InternalSubOp extends InternalOperation<Number> {
			InternalSubOp(EOperation metaOp) {
				super(metaOp);
			}
			@@Override
			public Object evaluate(Number target, Object[] params) {
				if (target instanceof Double || params[0] instanceof Double) {
					return new Double(target.doubleValue() - ((Number) params[0]).doubleValue());
				} else {
					return new Integer(target.intValue() - ((Number) params[0]).intValue());
				}
			}
			
		}; 
		class InternalMulOp extends InternalOperation<Number> {
			InternalMulOp(EOperation metaOp) {
				super(metaOp);
			}
			@@Override
			public Object evaluate(Number target, Object[] params) {
				if (target instanceof Double || params[0] instanceof Double) {
					return new Double(target.doubleValue() * ((Number) params[0]).doubleValue());
				} else {
					return new Integer(target.intValue() * ((Number) params[0]).intValue());
				}
			}
			
		}; 
		class InternalDivOp extends InternalOperation<Number> {
			InternalDivOp(EOperation metaOp) {
				super(metaOp);
			}
			@@Override
			public Object evaluate(Number target, Object[] params) {
				if (target instanceof Double || params[0] instanceof Double) {
					return new Double(target.doubleValue() / ((Number) params[0]).doubleValue());
				} else {
					return new Integer(target.intValue() / ((Number) params[0]).intValue());
				}
			}
			
		};
		class InternalNegateOp extends InternalOperation<Number> {
			InternalNegateOp(EOperation metaOp) {
				super(metaOp);
			}
			@@Override
			public Object evaluate(Number target, Object[] params) {
				if (target instanceof Double) {
					return -target.doubleValue();
				}
				return -target.intValue();
			}
		}
		//---------------------------------------------------------------------------------

		final List<InternalOperation> intOps = new LinkedList<InternalOperation>();
		intOps.add(new InternalSumOp(opf.create("+", int.class, int.class)));
		intOps.add(new InternalSumOp(opf.create("+", int.class, double.class)));
		intOps.add(new InternalSubOp(opf.create("-", int.class, int.class)));
		intOps.add(new InternalSubOp(opf.create("-", int.class, double.class)));
		intOps.add(new InternalMulOp(opf.create("*", int.class, int.class)));
		intOps.add(new InternalMulOp(opf.create("*", int.class, double.class)));
		intOps.add(new InternalDivOp(opf.create("/", int.class, int.class)));
		intOps.add(new InternalDivOp(opf.create("/", int.class, double.class)));
		intOps.add(new InternalNegateOp(opf.create("-", int.class)));
//		intOps.add(new InternalOperation<Number>(opf.create("==", boolean.class, int.class)) {
//			@@Override
//			public Object evaluate(Number target, Object[] params) {
//				//we may need this to handle cases like {Long(5), Long(4)}.exists(a | a == 5)
//				return Boolean.valueOf(target.intValue() == ((Integer) params[0]).intValue());
//			}
//			
//		});
		intOps.add(new InternalOperation<Number>(opf.create(">=", boolean.class, int.class)) {
			@@Override
			public Object evaluate(Number target, Object[] params) {
				return Boolean.valueOf(target.intValue() >= ((Number) params[0]).intValue());
			}
		});
		intOps.add(new InternalOperation<Number>(opf.create("<=", boolean.class, int.class)) {
			@@Override
			public Object evaluate(Number target, Object[] params) {
				return Boolean.valueOf(target.intValue() <= ((Number) params[0]).intValue());
			}
		});
		intOps.add(new InternalOperation<Number>(opf.create("<", boolean.class, int.class)) {
			@@Override
			public Object evaluate(Number target, Object[] params) {
				return Boolean.valueOf(target.intValue() < ((Number) params[0]).intValue());
			}
		});
		intOps.add(new InternalOperation<Number>(opf.create(">", boolean.class, int.class)) {
			@@Override
			public Object evaluate(Number target, Object[] params) {
				return Boolean.valueOf(target.intValue() > ((Number) params[0]).intValue());
			}
		});
		intOps.add(new InternalOperation<Number>(opf.create("upTo", collectionTypes.getListType(ecorePkg.getEInt()), ecorePkg.getEInt())) {
			@@Override
			public Object evaluate(Number target, Object[] params) {
                final ArrayList<Integer> result = new ArrayList<Integer>();
                for (int l1 = target.intValue(), l2 = ((Number) params[0]).intValue(); l1 <= l2; l1++) {
                    result.add(new Integer(l1));
                }
                return result;
			}
			
		});
		intOps.addAll(unmodifiableObjectOps);
		List<InternalOperation> unmodifiableListIntOps = Collections.unmodifiableList(intOps);
		internalOperationsMap.put(ecorePkg.getEIntegerObject(), unmodifiableListIntOps);
		internalOperationsMap.put(ecorePkg.getEInt(), unmodifiableListIntOps);

		final List<InternalOperation> doubleOps = new LinkedList<InternalOperation>();
		doubleOps.add(new InternalSumOp(opf.create("+", double.class, double.class)));
		doubleOps.add(new InternalSumOp(opf.create("+", double.class, int.class)));
		doubleOps.add(new InternalSubOp(opf.create("-", double.class, double.class)));
		doubleOps.add(new InternalSubOp(opf.create("-", double.class, int.class)));
		doubleOps.add(new InternalMulOp(opf.create("*", double.class, double.class)));
		doubleOps.add(new InternalMulOp(opf.create("*", double.class, int.class)));
		doubleOps.add(new InternalDivOp(opf.create("/", double.class, double.class)));
		doubleOps.add(new InternalDivOp(opf.create("/", double.class, int.class)));
		doubleOps.add(new InternalNegateOp(opf.create("-", int.class)));
		doubleOps.addAll(unmodifiableObjectOps);
		internalOperationsMap.put(ecorePkg.getEDouble(), doubleOps);

		final List<InternalOperation> collectionOps = new LinkedList<InternalOperation>();
		collectionOps.add(new InternalOperation<Collection>(opf.create("isEmpty", ecorePkg.getEBoolean())) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				// TODO isEmpty is rather attribute
				return target.isEmpty();
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("add", CollectionTypesSupport.COLLECTION_OF_OBJECT, ecorePkg.getEJavaObject())) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				target.add(params[0]);
				return target;
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("addAll", CollectionTypesSupport.COLLECTION_OF_OBJECT, CollectionTypesSupport.COLLECTION_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				target.addAll((Collection) params[0]);
				return target;
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("clear", CollectionTypesSupport.COLLECTION_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				target.clear();
				return target;
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("flatten", CollectionTypesSupport.COLLECTION_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				LinkedList rv = new LinkedList();
				for (Object o : target) {
					if (o instanceof Collection) {
						// XXX unlike original xpand, we do not flatten recursively
						rv.addAll((Collection) o);
					} else {
						rv.add(o);
					}
				}
				return rv;
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("size", ecorePkg.getEInt())) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				return target.size();
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("union", CollectionTypesSupport.COLLECTION_OF_OBJECT, CollectionTypesSupport.COLLECTION_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				LinkedHashSet<Object> rv = new LinkedHashSet<Object>(target);
				rv.addAll((Collection) params[0]);
				return rv;
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("intersect", CollectionTypesSupport.COLLECTION_OF_OBJECT, CollectionTypesSupport.COLLECTION_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				LinkedHashSet<Object> rv = new LinkedHashSet<Object>(target);
				rv.retainAll((Collection) params[0]);
				return rv;
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("without", CollectionTypesSupport.COLLECTION_OF_OBJECT, CollectionTypesSupport.COLLECTION_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				LinkedHashSet<Object> rv = new LinkedHashSet<Object>(target);
				rv.removeAll((Collection) params[0]);
				return rv;
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("toSet", CollectionTypesSupport.SET_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				return new LinkedHashSet<Object>(target);
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("toList", CollectionTypesSupport.LIST_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				return new LinkedList<Object>(target);
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("contains", ecorePkg.getEBoolean(), ecorePkg.getEJavaObject())) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				return target.contains(params[0]);
			}
		});
		collectionOps.add(new InternalOperation<Collection>(opf.create("containsAll", ecorePkg.getEBoolean(), CollectionTypesSupport.COLLECTION_OF_OBJECT)) {
			@@Override
			public Object evaluate(Collection target, Object[] params) {
				return target.containsAll((Collection) params[0]);
			}
		});
		List<InternalOperation> unmodifiableListCollectionOps = Collections.unmodifiableList(collectionOps);
		internalOperationsMap.put(CollectionTypesSupport.COLLECTION_TYPE, unmodifiableListCollectionOps);
		internalOperationsMap.put(CollectionTypesSupport.SET_TYPE, unmodifiableListCollectionOps);
		final List<InternalOperation> listOps = new LinkedList<InternalOperation>(unmodifiableListCollectionOps);
		listOps.add(new InternalOperation<List>(opf.create("get", ecorePkg.getEJavaObject(), ecorePkg.getEInt())) {
			@@Override
			public Object evaluate(List target, Object[] params) {
				int index = ((Number) params[0]).intValue();
				return index < target.size() ? target.get(index) : null;
			}
		});
		listOps.add(new InternalOperation<List>(opf.create("first", ecorePkg.getEJavaObject())) {
			@@Override
			public Object evaluate(List target, Object[] params) {
				return target.isEmpty() ? null : target.get(0);
			}
		});
		listOps.add(new InternalOperation<List>(opf.create("last", ecorePkg.getEJavaObject())) {
			@@Override
			public Object evaluate(List target, Object[] params) {
				return target.isEmpty() ? null : target.get(target.size() - 1);
			}
		});
		listOps.add(new InternalOperation<List>(opf.create("withoutFirst", CollectionTypesSupport.LIST_OF_OBJECT)) {
			@@Override
			public Object evaluate(List target, Object[] params) {
				if (!target.isEmpty()) {
					LinkedList rv = new LinkedList(target);
					rv.removeFirst();
					return rv;
				}
				return target;
			}
		});
		listOps.add(new InternalOperation<List>(opf.create("withoutLast", CollectionTypesSupport.LIST_OF_OBJECT)) {
			@@Override
			public Object evaluate(List target, Object[] params) {
				if (!target.isEmpty()) {
					LinkedList rv = new LinkedList(target);
					rv.removeLast();
					return rv;
				}
				return target;
			}
		});
		listOps.add(new InternalOperation<List>(opf.create("purgeDups", CollectionTypesSupport.LIST_OF_OBJECT)) {
			@@Override
			public Object evaluate(List target, Object[] params) {
				if (target.isEmpty()) {
					return target;
				}
				return new LinkedList<Object>(new LinkedHashSet<Object>(target));
			}
		});
		listOps.add(new InternalOperation<List>(opf.create("indexOf", ecorePkg.getEInt(), ecorePkg.getEJavaObject())) {
			@@Override
			public Object evaluate(List target, Object[] params) {
				return target.indexOf(params[0]);
			}
		});
		internalOperationsMap.put(CollectionTypesSupport.LIST_TYPE, Collections.unmodifiableList(listOps));

		final List<InternalOperation> definitionOps = new LinkedList<InternalOperation>();
		definitionOps.add(new InternalOperation<XpandDefinitionWrap>(opf.create("proceed", VOID)) {
			@@Override
			public Object evaluate(XpandDefinitionWrap target, Object[] params) {
				target.proceed();
				return null;
			}
		});
		internalOperationsMap.put(DEFINITION_TYPE, Collections.unmodifiableList(definitionOps));
		
		final List<InternalOperation> iteratorOps = new LinkedList<InternalOperation>();
		iteratorOps.add(new InternalOperation<XpandIterator>(opf.create("isFirstIteration", ecorePkg.getEBoolean())) {
			@@Override
			public Object evaluate(XpandIterator target, Object[] params) {
				return target.isFirstIteration();
			}
		});
		internalOperationsMap.put(ITERATOR_TYPE, Collections.unmodifiableList(iteratorOps));
	}

	private static List<EOperation> findInternalOp(EClassifier targetType) {
		List<InternalOperation> ops = internalOperationsMap.get(targetType);
		if (ops != null) {
			List<EOperation> rv = new ArrayList<EOperation>(ops.size());
			for (InternalOperation iop : ops) {
				rv.add(iop.metaOp);
			}
			return rv;
		}
		if (targetType.eClass() == EcorePackage.eINSTANCE.getEClass()) {
			// not instanceof because parametric type and all other XECore
			// classes have different operations, at least
			// meanwhile, when they are dynamic
			return((EClass) targetType).getEAllOperations();
		}
		// TODO Auto-generated method stub
		// String length, +, startsWith, endsWith, subString, toUpperCase, toFirstUpper, toFirstLower, toCharList, replaceAll, replaceFirst, split, matches, trim
		// Int/Real +-*/ > >= < <= != ==
		// Collection toList, toSet, toString, add, addAll, contains, containsAll, remove, removeAll, without, intersect, flatten ;
		// properties - size, isEmpty
		// List get, indexOf, last, first, withoutFirst, withoutLast
		// Set - none
		return null;
	}

	public static EClassifier getTypedElementType(ETypedElement p) {
		if (p.isMany()) {
			return p.isOrdered() ? getListType(p.getEType()) : p.isUnique() ? getSetType(p.getEType()) : getCollectionType(p.getEType());
		}
		return p.getEType();
	}

	private static class OperationFactory {
		EOperation create(String name, Class returnType, Class ... params) {
			EClassifier[] paramsNew = new EClassifier[params.length];
			for (int i = 0; i < paramsNew.length; i++) {
				paramsNew[i] = toEClassifier(params[i]);
				assert params[i] != null;
			}
			EClassifier rt = toEClassifier(returnType);
			assert rt != null : "Unrecognized return type:" + returnType;
			return create(name, rt, paramsNew);
		}

		/**
		 * NOTE, targetType is NOT operation's return type, but method owning class 
		 */
		InternalOperation createReflective(Class targetType, String methodName, Class ... params) {
			try {
				final Method m = targetType.getMethod(methodName, params);
				assert m != null;
				return new InternalOperation<Object>(create(methodName, m.getReturnType(), params)) {
					public Object evaluate(Object target, Object[] params) {
						try {
							Object rv = m.invoke(target, params);
							if (rv != null && rv.getClass().isArray()) {
								return new LinkedList(Arrays.asList((Object[]) rv));
							}
							return rv;
						} catch (Exception e) {
							Activator.logError(e);
							return null;
						}
					}
				};
			} catch (NoSuchMethodException ex) {
				assert false : ex.getMessage();
			}
			return null;
		}

		private EClassifier toEClassifier(Class targetType) {
			if (targetType == void.class) {
				return VOID;
			}
			for (EClassifier c : EcorePackage.eINSTANCE.getEClassifiers()) {
				if (c.getInstanceClass() == targetType) {
					return c;
				}
			}
			if (targetType.isArray()) {
				EClassifier t = toEClassifier(targetType.getComponentType());
				assert t != null : "Unrecognized array component type:" + targetType;
				return getListType(t);
			}
			// TODO other packages
			return null;
		}

		EOperation create(String name, EClassifier returnType, EClassifier ... params) {
			EOperation op = EcoreFactory.eINSTANCE.createEOperation();
			op.setName(name);
			op.setEType(returnType);
			for (EClassifier c : params) {
				EParameter p1 = EcoreFactory.eINSTANCE.createEParameter();
				p1.setName("arg" + c.getName());
				p1.setEType(c);
				op.getEParameters().add(p1);
			}
			return op;
		}
	}

	private static abstract class InternalOperation<T> {
		private final EOperation metaOp;
		private static String INTERNAL_OP_ANNOTATION = "::internalop::";

		private InternalOperation(EOperation metaOp) {
			assert metaOp != null;
			this.metaOp = metaOp;
			EAnnotation internalOpAnn = EcoreFactory.eINSTANCE.createEAnnotation();
			internalOpAnn.setSource(INTERNAL_OP_ANNOTATION);
			metaOp.getEAnnotations().add(internalOpAnn);
		}

		public abstract Object evaluate(T target, Object[] params);

		static boolean isInternalOp(EOperation op) {
			return op.getEAnnotation(INTERNAL_OP_ANNOTATION) != null;
		}
	}

	public static class OperationEx extends Operation {
		private final InternalOperation<Object> internalOp;
		private OperationEx(Object targetObject, Object[] args, InternalOperation<Object> internalOp) {
			super(targetObject, args, internalOp.metaOp);
			this.internalOp = internalOp;
		}
		@@Override
		public Object evaluate() {
			return internalOp.evaluate(targetObject, args);
		}
	}

	private static final Map<EOperation, Method> externalOpImplementations = new HashMap<EOperation, Method>(); 

	public static void registerOperationImpl(EOperation metaOp, Method implementation) {
		assert metaOp != null;
		assert implementation != null;
		assert Modifier.isStatic(implementation.getModifiers());
		externalOpImplementations.put(metaOp, implementation);
	}

	public static class Operation {
		protected final EOperation metaOp;
		protected final Object[] args;
		protected final Object targetObject;

		private Operation(Object targetObject, Object[] args, EOperation metaOp) {
			this.targetObject = targetObject;
			this.args = args;
			this.metaOp = metaOp;
			
		}
		public Object evaluate() {
            try {
                final Method m;
                if (externalOpImplementations.containsKey(metaOp)) {
                	m = externalOpImplementations.get(metaOp);
                } else {
                	m = targetObject.getClass().getMethod(metaOp.getName(), getParameterClasses());
                }
                return m.invoke(targetObject, args);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
		}

		private Class[] getParameterClasses() {
			List<EParameter> emfParams = metaOp.getEParameters();
			final Class[] paramClasses = new Class[emfParams.size()];
            for (int i = 0, x = emfParams.size(); i < x; i++) {
                final EParameter param = emfParams.get(i);
        		// XXX works only for generated classes, or those with instance
				// class set,
                // and doesn't work with dynamic models, right?
                paramClasses[i] = param.getEType().getInstanceClass();
            }
            return paramClasses;
		}
	}

	/**
	 * @@return true if first argument is more general and second is more
	 *         specific, think Object and String
	 * @@see AbstractTypeImpl.isAssignableFrom(this, t)
	 */
	public static boolean isAssignableFrom(EClassifier c1, EClassifier t) {
		if ((t == null) || (c1 == null)) {
			return false;
		}
		if (BuiltinMetaModel.primEquals(c1, t)) {
			return true;
		}
		if (t.equals(VOID)) {
			return true;
		}
		if (false == (t instanceof EClass)) {
			if (c1 instanceof EEnum && t == EcorePackage.eINSTANCE.getEEnumerator()) {
				return true; // HACK - any enumerator instance can be assigned to any enum attribute. 
			}
			if (c1 instanceof EDataType && t instanceof EDataType) {
				return isCompatibleDataTypes((EDataType) c1, (EDataType) t);
			}
			return false;
		}
		if (c1 instanceof EDataType) {
			Class c1Class = ((EDataType) c1).getInstanceClass();
			return c1Class.isAssignableFrom(t.getInstanceClass() == null ? Object.class : t.getInstanceClass()); 
		}
		if (isParameterizedType(c1) && isParameterizedType(t)) {
			return c1.eClass().isSuperTypeOf(t.eClass()) && isAssignableFrom(getInnerType(c1), getInnerType(t));
		}
		// == c1.isSuperTypeOf(t);
		for (EClass superType : ((EClass) t).getEAllSuperTypes()) {
			if (BuiltinMetaModel.primEquals(superType, c1)) {
				return true;
			}
		}
		return false;
	}

	private static boolean primEquals(EClassifier c1, EClassifier obj) {
	    if (obj == null) {
			return false;
		}
	    if (c1 == obj) {
	        return true;
	    }
	    final boolean namesEqual = c1.getName().equals(obj.getName());
	    if (!namesEqual) {
	    	return false;
	    }
	    if (c1.getEPackage() == null) {
	    	return obj.getEPackage() == null;
	    }
    	if (obj.getEPackage() == null) {
    		return false;
    	}
    	if (c1.getEPackage().getNsURI() == null) {
    		return obj.getEPackage().getNsURI() == null;
    	}
   		return c1.getEPackage().getNsURI().equals(obj.getEPackage().getNsURI());  
	}

	private static boolean isCompatibleDataTypes(EDataType dt1, EDataType dt2) {
		try {
			final Class dt1Class = dt1.getInstanceClass();
			final Class dt2Class = dt2.getInstanceClass();
			if (dt1Class != null && dt2Class != null) {
				if (dt1Class == Object.class) {
					// anything (with or without wrapping) can be assigned to object
					return true;
				}
				if (dt1Class.isPrimitive() && !dt2Class.isPrimitive()) {
					Field f = dt2Class.getField("TYPE");
					return dt1Class.equals(f.get(null));
				} else if (!dt1Class.isPrimitive() && dt2Class.isPrimitive()) {
					Field f = dt1Class.getField("TYPE");
					return dt2Class.equals(f.get(null));
				}
				return dt1Class.isAssignableFrom(dt2Class);
			}
			if (dt1Class != null && dt2Class == null) {
				// special case for dt2 datatype from dynamic model instance
				// (e.g. model file in same workspace as template)
				// hence no instance classes yet, but anything is assignable to Object
				// Fixed while resolving #analyze of enum literals compare (==)
				return dt1Class == Object.class;
			}
		} catch (NoSuchFieldException ex) {
			// IGNORE
		} catch (IllegalAccessException ex) {
			// IGNORE
		}
		return false;
	}
	public static List<EStructuralFeature> getAllFeatures(EClassifier targetType) {
		// FIXME @@see getAllOperations
		if (targetType instanceof EClass) {
			return ((EClass) targetType).getEAllStructuralFeatures();
		}
		return Collections.emptyList();
	}

	public static List<EOperation> getAllOperation(EClassifier targetType) {
		// FIXME - either have datatypes like int/real as 'honest' EClasses, or
		// provide their operations here
		if (hasBuiltinSupport(targetType)) {
			return findInternalOp(targetType);
		}
		if (targetType instanceof EClass) {
			return ((EClass) targetType).getEAllOperations();
		}
		/*
		 * XXX might be not bad idea to use java reflection to provide
		 * datatype's possible operations if (targetType instanceof EDataType &&
		 * false == targetType instanceof EEnum) { EDataType dt = (EDataType)
		 * targetType; dt.getInstanceClass().getMethods() }
		 */
		return Collections.emptyList();
	}
}
@


1.23.2.1
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d1 3
a3 3
/*
 * Copyright (c) 2006, 2008 Borland Software Corporation
 *
d8 1
a8 4
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
a44 1
import org.eclipse.gmf.internal.xpand.model.XpandExecutionContext;
a45 4
import org.eclipse.gmf.internal.xpand.ocl.TypeHelper;
import org.eclipse.ocl.EvaluationEnvironment;
import org.eclipse.ocl.ecore.EcoreEvaluationEnvironment;
import org.eclipse.ocl.util.TypeUtil;
a200 5
	public static EClassifier getType(XpandExecutionContext ctx, Object obj) {
		EcoreEvaluationEnvironment ee = (EcoreEvaluationEnvironment) ctx.getOCLEnvironment().getFactory().createEvaluationEnvironment();
		return TypeUtil.resolveType(ctx.getOCLEnvironment(), ee.getType(obj));
	}
	
d202 1
a202 1
	private static EClassifier getType(Object obj) {
d316 1
a316 1
		return PolymorphicResolver.filterOperation(allOp, name, targetType, Arrays.asList(args), null/*FIXME*/);
@


1.23.2.2
log
@[243154] Use OCL instead of home-grown expression language. Refactored to eliminate context specific to expressions (moving towards using OCL environment for that), split modifiable (context-specific) and static execution data.
@
text
@d15 13
d29 2
d36 1
d38 1
d40 1
d42 2
d46 8
a53 1
import org.eclipse.ocl.ecore.EcoreEnvironmentFactory;
d199 13
a211 25
	public static EClassifier getType(Object obj) {
		// XXX (1) not sure how Collections are handled
		// FIXME (2) need to support own types (IteratorType and DefinitionType)
//		if (obj instanceof Collection) {
//		EClassifier type = null;
//		if (!((Collection) obj).isEmpty()) {
//			// FIXME respect all! elements in the collection, not only the first one
//			type = getType(((Collection) obj).iterator().next());
//		}
//		if (obj instanceof Set) {
//			return collectionTypes.getSetType(type);
//		}
//		if (obj instanceof List) {
//			return collectionTypes.getListType(type);
//		}
//		return collectionTypes.getCollectionType(type);
//	}
//	if (obj instanceof XpandDefinitionWrap) {
//		return DEFINITION_TYPE;
//	}
//	if (obj instanceof XpandIterator) {
//		return ITERATOR_TYPE;
//	}
		return EcoreEnvironmentFactory.INSTANCE.createEvaluationEnvironment().getType(obj);
//		return TypeUtil.resolveType(ctx.getOCLEnvironment(), ee.getType(obj));
d214 783
d1092 25
@


1.23.2.3
log
@[243154] Use OCL instead of home-grown expression language - AOP tests fixed, though with sort of hack to pass proceed() java method implementation to OCL
@
text
@d14 3
d19 3
a21 1
import org.eclipse.emf.ecore.EOperation;
d23 1
a25 2
import org.eclipse.gmf.internal.xpand.model.ExecutionContext;
import org.eclipse.gmf.internal.xpand.model.XpandDefinitionWrap;
a26 2
import org.eclipse.ocl.util.TypeUtil;
import org.eclipse.ocl.utilities.UMLReflection;
d34 1
d48 108
d160 1
a160 6
		DEFINITION_TYPE.getESuperTypes().add(EcorePackage.eINSTANCE.getEClass()); // XXX perhaps, with OCL, some other superclassifier? 
		EOperation proceedOp = EcoreFactory.eINSTANCE.createEOperation();
		proceedOp.setName("proceed");
		proceedOp.setEType(EcorePackage.eINSTANCE.getEObject()); // FIXME not sure what do I need as a type here
		DEFINITION_TYPE.setInstanceClass(XpandDefinitionWrap.class);
		DEFINITION_TYPE.getEOperations().add(proceedOp);
a199 1
	 * @@param ctx 
d204 89
a292 2
	public static boolean isAssignableFrom(ExecutionContext ctx, EClassifier t1, EClassifier t2) {
		return 0 != (UMLReflection.SUBTYPE & TypeUtil.getRelationship(ctx.getOCLEnvironment(), t2, t1));
@


1.23.2.4
log
@[243154] Use OCL instead of home-grown expression language - most (what's feasible) of the extension invocation fixed. A lot of hacks and questions, though.
@
text
@a13 4
import java.util.Collection;
import java.util.List;
import java.util.Set;

a17 1
import org.eclipse.emf.ecore.EStructuralFeature;
a21 1
import org.eclipse.ocl.TypeResolver;
a22 2
import org.eclipse.ocl.expressions.CollectionKind;
import org.eclipse.ocl.types.OCLStandardLibrary;
d66 1
a66 1
	public static EClassifier getType(ExecutionContext ctx, Object obj) {
a88 13
		if (obj instanceof Collection) {
			EClassifier firstElementType = ((Collection<?>) obj).isEmpty() ? null : getType(ctx, ((Collection<?>) obj).iterator().next());
			TypeResolver<EClassifier, EOperation, EStructuralFeature> tr = ctx.getOCLEnvironment().getTypeResolver();
			OCLStandardLibrary<EClassifier> stdLib = ctx.getOCLEnvironment().getOCLStandardLibrary();
			if (obj instanceof Set) {
				// XXX odd TypeResolver - CollectionType returned is EDataType for Ecore, need to cast nevertheless
				return firstElementType == null ? stdLib.getSet() : (EClassifier) tr.resolveCollectionType(CollectionKind.SET_LITERAL, firstElementType);
			}
			if (obj instanceof List) {
				return firstElementType == null ? stdLib.getSequence() : (EClassifier) tr.resolveCollectionType(CollectionKind.SEQUENCE_LITERAL, firstElementType);
			}
			return firstElementType == null ? stdLib.getCollection() : (EClassifier) tr.resolveCollectionType(CollectionKind.COLLECTION_LITERAL, firstElementType);
		}
@


1.22
log
@recognizez java object operations (like == or !=) on EnumType::EnumLiteral during analyze phase
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 Eclipse.org
d1065 7
@


1.21
log
@[191303] Restore old behavior (adding layout manager) for diagram nodes with inner labels; CCE in xpand's Collection.isEmpty fixed; better formatting for layout generated code
@
text
@d413 2
d416 1
@


1.20
log
@clear and indexOf operations added to help generate unique names based on order of element in collection
@
text
@d620 1
a620 1
		collectionOps.add(new InternalOperation<List>(opf.create("isEmpty", ecorePkg.getEBoolean())) {
d622 1
a622 1
			public Object evaluate(List target, Object[] params) {
@


1.19
log
@0.8.21 - toSet implemented with LinkedHashSet; added List.purgeDups operation to clean dupplicates away from list
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Eclipse.org
a18 1
import java.util.HashSet;
d641 7
d771 6
d874 1
a874 1
			for (EClassifier c : (List<EClassifier>) EcorePackage.eINSTANCE.getEClassifiers()) {
@


1.18
log
@immutable withoutFirst and withoutLast operations
@
text
@d690 1
a690 1
				return new HashSet<Object>(target);
d734 1
a734 1
		listOps.add(new InternalOperation<List>(opf.create("withoutFirst", collectionTypes.getCollectionType(ecorePkg.getEJavaObject()))) {
d745 1
a745 1
		listOps.add(new InternalOperation<List>(opf.create("withoutLast", collectionTypes.getCollectionType(ecorePkg.getEJavaObject()))) {
d756 9
@


1.17
log
@0.8.17 - EClasses loaded via ../plugin/ and via nsURI were not recognized as isSuperTypeOf
@
text
@d738 3
a740 1
					target.remove(0);
d749 3
a751 1
					target.remove(target.size() - 1);
@


1.16
log
@negation ops for int and double added
@
text
@d988 6
a993 1
		return ((EClass) t).getEAllSuperTypes().contains(c1);
d1003 14
a1016 1
	    return c1.getName().equals(obj.getName());
@


1.15
log
@isOrdered() && isUnique() collections are ratehr ordered then unique.

Unit-test created.
@
text
@d534 13
a546 1
		}; 
d558 1
d616 1
@


1.14
log
@NodeItemSemanticEditPolicy template reimplemented using xpand.
@
text
@a43 1
import org.eclipse.emf.ecore.util.EObjectEList;
d222 1
a222 2
			// EObjectEList isUnique() == true.
			if (obj instanceof Set || obj instanceof EObjectEList) {
d787 1
a787 1
			return p.isUnique() ? getSetType(p.getEType()) : p.isOrdered() ? getListType(p.getEType()) : getCollectionType(p.getEType()); 
@


1.13
log
@== and != null finally supported
@
text
@d44 1
d223 2
a224 1
			if (obj instanceof Set) {
@


1.12
log
@- adding metainformation for Iterator.isFirstIteration() operation
- correcting operation type calculation
@
text
@d313 2
a314 1
				allOp = ((EClass) targetType).getEAllOperations();
@


1.11
log
@[168239] unpredicatable order of without operation
@
text
@d41 1
d46 1
d245 3
d748 9
d784 1
a784 1
	public static EClassifier getAttributeType(EStructuralFeature p) {
@


1.10
log
@[167462] not boolean operation ("!") has incorrect return type
@
text
@d20 1
d646 1
a646 1
				HashSet<Object> rv = new HashSet<Object>(target);
d654 1
a654 1
				HashSet<Object> rv = new HashSet<Object>(target);
d662 1
a662 1
				HashSet<Object> rv = new HashSet<Object>(target);
@


1.9
log
@integer comparison operations added
@
text
@d459 1
a459 1
		booleanOps.add(new InternalOperation<Boolean>(opf.create("!", Boolean.class)) {
@


1.8
log
@correct return value for the operation
@
text
@d547 1
a547 1
		intOps.add(new InternalOperation<Number>(opf.create(">=", boolean.class, int.class, int.class)) {
d552 18
a569 1
			
@


1.7
log
@flatten op added
@
text
@d547 1
a547 1
		intOps.add(new InternalOperation<Number>(opf.create(">=", int.class, int.class)) {
@


1.6
log
@naive support for attributes  with names equal to reserved keywords
@
text
@d604 15
@


1.5
log
@Collection.addAll to complement union (set vs non-set semantics)
convenient String.substring with single argument
@
text
@d24 1
d313 4
d322 1
a322 1
			return ((EClass) type).getEStructuralFeature(name);
@


1.4
log
@detect nested type for collections
@
text
@d439 3
d585 1
a585 1
		collectionOps.add(new InternalOperation<Collection>(opf.create("add", collectionTypes.getCollectionType(ecorePkg.getEJavaObject()), ecorePkg.getEJavaObject())) {
d592 7
d605 1
a605 1
		collectionOps.add(new InternalOperation<Collection>(opf.create("union", collectionTypes.getSetType(ecorePkg.getEJavaObject()), collectionTypes.getCollectionType(ecorePkg.getEJavaObject()))) {
d613 1
a613 1
		collectionOps.add(new InternalOperation<Collection>(opf.create("intersect", collectionTypes.getSetType(ecorePkg.getEJavaObject()), collectionTypes.getCollectionType(ecorePkg.getEJavaObject()))) {
d621 1
a621 1
		collectionOps.add(new InternalOperation<Collection>(opf.create("without", collectionTypes.getSetType(ecorePkg.getEJavaObject()), collectionTypes.getCollectionType(ecorePkg.getEJavaObject()))) {
d629 1
a629 1
		collectionOps.add(new InternalOperation<Collection>(opf.create("toSet", collectionTypes.getSetType(ecorePkg.getEJavaObject()))) {
d635 1
a635 1
		collectionOps.add(new InternalOperation<Collection>(opf.create("toList", collectionTypes.getListType(ecorePkg.getEJavaObject()))) {
d647 1
a647 1
		collectionOps.add(new InternalOperation<Collection>(opf.create("containsAll", ecorePkg.getEBoolean(), collectionTypes.getCollectionType(ecorePkg.getEJavaObject()))) {
@


1.3
log
@hack to deal with Enumerator - Enum issue
@
text
@a211 1
		// FIXME reuse
d213 5
d219 1
a219 1
				return CollectionTypesSupport.SET_OF_OBJECT;
d222 1
a222 1
				return CollectionTypesSupport.LIST_OF_OBJECT;
d224 1
a224 1
			return CollectionTypesSupport.COLLECTION_OF_OBJECT;
@


1.2
log
@to get enum literals working...
@
text
@d891 3
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d347 4
@

