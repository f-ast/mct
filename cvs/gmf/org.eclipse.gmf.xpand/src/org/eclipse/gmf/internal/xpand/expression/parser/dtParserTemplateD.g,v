head	1.3;
access;
symbols
	v20081022-1925:1.3
	v20081020-0700:1.3
	ocl_qvt:1.3.0.6
	Root_ocl_qvt:1.3
	v20080722-1827:1.3
	v20080718-1731:1.3
	v20080716-1600:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.4
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080528-1052:1.3
	v20080516-1143:1.3
	v20080417-1610:1.3
	v20080322-0000:1.3
	v20080222-1200:1.3
	v20071130-1111:1.3
	v20071124-0000:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070921-0000:1.3
	v20070903-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	RC3_20:1.3
	v20070608-1300:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070518-1300:1.3
	v20070420-1000:1.3
	v20070405-1100:1.3
	v20070403-1500:1.3
	v20070330-1300:1.3
	v20070208-1800:1.3
	v20070103-0300:1.3
	M4_20:1.3
	M3_20:1.3;
locks; strict;
comment	@# @;


1.3
date	2006.11.08.14.45.15;	author atikhomirov;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2006.11.08.11.26.52;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.06.16.36.18;	author atikhomirov;	state Exp;
branches;
next	;

1.3.6.1
date	2008.08.05.12.49.24;	author atikhomirov;	state Exp;
branches;
next	;
commitid	546c48984c4a4567;


desc
@@


1.3
log
@error handling
@
text
@--
-- In a parser using this template, the following macro may be redefined:
--
--     $additional_interfaces
--     $ast_class
--     $initialization_code [+; artem]
--
-- B E G I N N I N G   O F   T E M P L A T E   dtParserTemplateD
--
%Options programming_language=java,margin=4
%Options table,error_maps,scopes
%options prefix=TK_,
%options action=("*.java", "/.", "./")
%options ParseTable=lpg.lpgjavaruntime.ParseTable

--
-- This template requires that the name of the EOF token be set
-- to EOF_TOKEN to be consistent with LexerTemplateD and LexerTemplateE
--
$EOF
    EOF_TOKEN
$End

$ERROR
    ERROR_TOKEN
$End

$Define
    $Header
    /.
                //
                // Rule $rule_number:  $rule_text
                //./

    $BeginAction
    /. $Header
                case $rule_number: {./

    $EndAction
    /.          break;
                }./

    $BeginJava
    /.$BeginAction
                    $symbol_declarations./

    $EndJava /.$EndAction./

    $NoAction
    /. $Header
                case $rule_number:
                    break;./

    $BadAction
    /. $Header
                case $rule_number:
                    throw new Error("No action specified for rule " + $rule_number);./

    $NullAction
    /. $Header
                case $rule_number:
                    setResult(null);
                    break;./

    $BeginActions
    /.
        public void ruleAction(int ruleNumber) {
            switch (ruleNumber) {./

    $SplitActions
    /.
	            default:
	                ruleAction$rule_number(ruleNumber);
	                break;
	        }
	        return;
	    }
	
	    public void ruleAction$rule_number(int ruleNumber)
	    {
	        switch (ruleNumber)
	        {./

    $EndActions
    /.
                default:
                    break;
            }
            return;
        }./

    $additional_interfaces /../
    $ast_class /.$ast_type./
    $initialization_code /../

$End

$Globals
    /.import lpg.lpgjavaruntime.*;
    ./
$End

$Headers
    /.
    public class $action_type extends PrsStream implements RuleAction$additional_interfaces {
        private static ParseTable prs = new $prs_type();
        private DeterministicParser dtParser;

        public DeterministicParser getParser() { return dtParser; }
        private void setResult(Object object) { dtParser.setSym1(object); }
        public Object getRhsSym(int i) { return dtParser.getSym(i); }

        public int getRhsTokenIndex(int i) { return dtParser.getToken(i); }
        public IToken getRhsIToken(int i) { return super.getIToken(getRhsTokenIndex(i)); }
        
        public int getRhsFirstTokenIndex(int i) { return dtParser.getFirstToken(i); }
        public IToken getRhsFirstIToken(int i) { return super.getIToken(getRhsFirstTokenIndex(i)); }

        public int getRhsLastTokenIndex(int i) { return dtParser.getLastToken(i); }
        public IToken getRhsLastIToken(int i) { return super.getIToken(getRhsLastTokenIndex(i)); }

        public int getLeftSpan() { return dtParser.getFirstToken(); }
        public IToken getLeftIToken()  { return super.getIToken(getLeftSpan()); }

        public int getRightSpan() { return dtParser.getLastToken(); }
        public IToken getRightIToken() { return super.getIToken(getRightSpan()); }

        public int getRhsErrorTokenIndex(int i) {
            int index = dtParser.getToken(i);
            IToken err = super.getIToken(index);
            return (err instanceof ErrorToken ? index : 0);
        }
        public ErrorToken getRhsErrorIToken(int i) {
            int index = dtParser.getToken(i);
            IToken err = super.getIToken(index);
            return (ErrorToken) (err instanceof ErrorToken ? err : null);
        }

        public $action_type(LexStream lexStream) {
            super(lexStream);
            $initialization_code

            try {
                super.remapTerminalSymbols(orderedTerminalSymbols(), $prs_type.EOFT_SYMBOL);
            }
            catch(NullExportedSymbolsException e) {
            }
            catch(NullTerminalSymbolsException e) {
            }
            catch(UnimplementedTerminalsException e) {
                java.util.ArrayList unimplemented_symbols = e.getSymbols();
                System.out.println("The Lexer will not scan the following token(s):");
                for (int i = 0; i < unimplemented_symbols.size(); i++)
                {
                    Integer id = (Integer) unimplemented_symbols.get(i);
                    System.out.println("    " + $sym_type.orderedTerminalSymbols[id.intValue()]);               
                }
                System.out.println();                        
            }
            catch(UndefinedEofSymbolException e) {
                throw new Error(new UndefinedEofSymbolException
                                    ("The Lexer does not implement the Eof symbol " +
                                     $sym_type.orderedTerminalSymbols[$prs_type.EOFT_SYMBOL]));
            } 
        }
 
        public String[] orderedTerminalSymbols() { return $sym_type.orderedTerminalSymbols; }
        public String getTokenKindName(int kind) { return $sym_type.orderedTerminalSymbols[kind]; }            
        public int getEOFTokenKind() { return $prs_type.EOFT_SYMBOL; }
        public PrsStream getParseStream() { return (PrsStream) this; }

        public $ast_class parser() {
            return parser(null, 0);
        }
            
        public $ast_class parser(Monitor monitor) {
            return parser(monitor, 0);
        }
            
        public $ast_class parser(int error_repair_count) {
            return parser(null, error_repair_count);
        }
            
        public $ast_class parser(Monitor monitor, int error_repair_count) {
            try {
            	resetErrors();
                dtParser = new DeterministicParser(monitor, (TokenStream)this, prs, (RuleAction)this);
            }
            catch (NotDeterministicParseTableException e) {
                throw new Error(new NotDeterministicParseTableException
                                    ("Regenerate $prs_type.java with -NOBACKTRACK option"));
            }
            catch (BadParseSymFileException e) {
                throw new Error(new BadParseSymFileException("Bad Parser Symbol File -- $sym_type.java. Regenerate $prs_type.java"));
            }

            try {
                return ($ast_class) dtParser.parse();
            }
            catch (BadParseException e) {
                reset(e.error_token); // point to error token

                DiagnoseParser diagnoseParser = new DiagnoseParser(this, prs);
                diagnoseParser.diagnose(e.error_token);
            }

            return null;
        }

    ./

$End

$Import
	errorHandling.g
$End

$Rules
    /.$BeginActions./
$End

$Trailers
    /.
        $EndActions
    }
    ./
$End

--
-- E N D   O F   T E M P L A T E
--@


1.3.6.1
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d151 1
a151 1
                java.util.ArrayList<?> unimplemented_symbols = e.getSymbols();
a213 1
-- XXX Include instead?
d218 3
a220 2
-- XXX EssentialOCL.g has both $Rules section with BeginActions
-- and $Trailers with EndActions, hence no need duplicate here
d222 6
@


1.2
log
@polishing templates - parser:added initialization code macro, lexer:getKind implementation made overridable, useless methods removed, braces styles updated
@
text
@d186 1
d214 4
@


1.1
log
@handle dollar sign ($) correctly inside strings/comments
do not use external includes and copy external templates locally to be able to tweak them
minor changes to the includes
@
text
@d6 1
d67 2
a68 4
        public void ruleAction(int ruleNumber)
        {
            switch (ruleNumber)
            {./
d94 1
a95 14
    $setSym1 /. // macro setSym1 is deprecated. Use function setResult
                getParser().setSym1./
    $setResult /. // macro setResult is deprecated. Use function setResult
                 getParser().setSym1./
    $getSym /. // macro getSym is deprecated. Use function getRhsSym
              getParser().getSym./
    $getToken /. // macro getToken is deprecated. Use function getRhsTokenIndex
                getParser().getToken./
    $getIToken /. // macro getIToken is deprecated. Use function getRhsIToken
                 super.getIToken./
    $getLeftSpan /. // macro getLeftSpan is deprecated. Use function getLeftSpan
                   getParser().getFirstToken./
    $getRightSpan /. // macro getRightSpan is deprecated. Use function getRightSpan
                    getParser().getLastToken./
d105 1
a105 2
    public class $action_type extends PrsStream implements RuleAction$additional_interfaces
    {
d128 1
a128 2
        public int getRhsErrorTokenIndex(int i)
        {
d133 1
a133 2
        public ErrorToken getRhsErrorIToken(int i)
        {
d139 1
a139 2
        public $action_type(LexStream lexStream)
        {
d141 1
d143 1
a143 2
            try
            {
d150 1
a150 2
            catch(UnimplementedTerminalsException e)
            {
d160 1
a160 2
            catch(UndefinedEofSymbolException e)
            {
d172 1
a172 2
        public $ast_class parser()
        {
d176 1
a176 2
        public $ast_class parser(Monitor monitor)
        {
d180 1
a180 2
        public $ast_class parser(int error_repair_count)
        {
d184 2
a185 4
        public $ast_class parser(Monitor monitor, int error_repair_count)
        {
            try
            {
d188 1
a188 2
            catch (NotDeterministicParseTableException e)
            {
d192 1
a192 2
            catch (BadParseSymFileException e)
            {
d196 1
a196 2
            try
            {
d199 1
a199 2
            catch (BadParseException e)
            {
@

