head	1.10;
access;
symbols
	v20081022-1925:1.10
	v20081020-0700:1.10
	ocl_qvt:1.10.0.4
	Root_ocl_qvt:1.10
	v20080722-1827:1.10
	v20080718-1731:1.10
	v20080716-1600:1.10
	v20080716-1642:1.10
	R2_1_maintenance:1.10.0.2
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080528-1052:1.10
	v20080516-1143:1.10
	v20080417-1610:1.10
	v20080322-0000:1.10
	v20080222-1200:1.10
	v20071130-1111:1.10
	v20071124-0000:1.8.2.1
	v20071108-0000:1.10
	v20071003-0000:1.8
	v20070921-0000:1.8
	v20070903-0000:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	RC3_20:1.8
	v20070608-1300:1.8
	v20070605-1400:1.8
	v20070601-1400:1.8
	v20070518-1300:1.8
	v20070420-1000:1.5
	v20070405-1100:1.5
	v20070403-1500:1.5
	v20070330-1300:1.5
	v20070208-1800:1.5
	v20070103-0300:1.5
	M4_20:1.5
	M3_20:1.5;
locks; strict;
comment	@# @;


1.10
date	2007.10.29.16.58.22;	author atikhomirov;	state Exp;
branches
	1.10.4.1;
next	1.9;
commitid	5b914726112d4567;

1.9
date	2007.10.23.11.06.33;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	3267471dd5b84567;

1.8
date	2007.05.15.09.41.13;	author atikhomirov;	state Exp;
branches
	1.8.2.1;
next	1.7;
commitid	1d72464980384567;

1.7
date	2007.05.14.17.55.50;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	75ac4648a2a64567;

1.6
date	2007.05.14.11.13.35;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	44814648445e4567;

1.5
date	2006.11.10.13.19.07;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.24.17.19.13;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.23.16.13.10;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.23.14.59.15;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.51;	author atikhomirov;	state Exp;
branches;
next	;

1.8.2.1
date	2007.10.24.13.30.55;	author atikhomirov;	state Exp;
branches;
next	;
commitid	31fe471f490f4567;

1.10.4.1
date	2008.07.24.16.21.35;	author ashatalin;	state Exp;
branches;
next	1.10.4.2;
commitid	7c4a4888ac0d4567;

1.10.4.2
date	2008.07.29.15.57.05;	author ashatalin;	state Exp;
branches;
next	1.10.4.3;
commitid	337c488f3dcd4567;

1.10.4.3
date	2008.08.05.12.49.25;	author atikhomirov;	state Exp;
branches;
next	1.10.4.4;
commitid	546c48984c4a4567;

1.10.4.4
date	2008.08.06.10.50.42;	author ashatalin;	state Exp;
branches;
next	1.10.4.5;
commitid	63d3489982014567;

1.10.4.5
date	2008.08.06.14.05.36;	author atikhomirov;	state dead;
branches;
next	;
commitid	35b4899afa74567;


desc
@@


1.10
log
@[207437] Resources to be composed from several sources
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2007 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.expression;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.gmf.internal.xpand.Activator;
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
import org.eclipse.gmf.internal.xpand.ResourceManager;
import org.eclipse.gmf.internal.xpand.ResourceMarker;
import org.eclipse.gmf.internal.xpand.eval.EvaluationListener;
import org.eclipse.gmf.internal.xpand.util.ClassLoadContext;
import org.eclipse.gmf.internal.xpand.xtend.ast.Extension;
import org.eclipse.gmf.internal.xpand.xtend.ast.XtendResource;

/**
 * @@author Sven Efftinge
 * @@author Arno Haase
 */
public class ExecutionContextImpl implements ExecutionContext {

    private final Map<String, Variable> variables = new HashMap<String, Variable> ();

    private final Map<String, Variable> globalVars = new HashMap<String, Variable> ();

    private ClassLoadContext contextClassLoader;

    private EvaluationListener evaluationListener;

    /**
     * this field is conceptually final, i.e. it is set only at object construction time. To simplify implementation, it is however technically not
     *  final. This is done so that the cloneWith/WithoutResource methods can delegate to cloneContext and afterwards modify the instance. That 
     *  provides cloneContext as a single method for subclasses to override.
     */
    private ResourceMarker currentResource;

	private final ResourceManager resourceManager;

    public ExecutionContextImpl(ResourceManager resourceManager) {
        this (resourceManager, (Collection<Variable>) null);
    }
    
    public ExecutionContextImpl(ResourceManager resourceManager, Collection<Variable> globalVars) {
        this (resourceManager, null, null, globalVars);
    }

    public ExecutionContextImpl(ResourceManager resourceManager, ResourceMarker resource, Collection<Variable> variables, Collection<Variable> globalVars) {
        this.resourceManager = resourceManager;
		this.currentResource = resource;
		if (variables != null) {
			for (Variable v : variables) {
				this.variables.put(v.getName(), v);
			}
		}
        if (globalVars != null) {
        	for (Variable v : globalVars) {
        		this.globalVars.put(v.getName(), v);
        	}
		}
    }

    // copy constuctor
    protected ExecutionContextImpl(ExecutionContextImpl original) {
    	this.resourceManager = original.resourceManager;
    	this.currentResource = original.currentResource;
    	this.variables.putAll(original.variables);
    	this.globalVars.putAll(original.globalVars);
    	this.contextClassLoader = original.contextClassLoader;
    	this.evaluationListener = original.evaluationListener;
    }

    /*
     * Need this for code completion only? move to proposal computer than
     */
    @@SuppressWarnings("unchecked")
	public EClassifier[] findTypesForPrefix(final String prefix) {
    	final EPackage[] importedNamespaces;
    	final String typeName = TypeNameUtil.getTypeName(prefix);
    	final String typesMetamodelName = TypeNameUtil.getMetaModelName(typeName);
        // TODO filter importedNamespaces with metamodel name (use ePackage.nsPrefix for metamodel name? 
    	final String collectionTypeName = TypeNameUtil.getCollectionTypeName(prefix);
    	final String simpleTypeName;
    	// XXX handle cases like "metamodelName!" and "List[" as prefixes
        if (TypeNameUtil.isQualifiedName(typeName)) {
        	EPackage exactNamespace = findImportedNamespace(TypeNameUtil.withoutLastSegment(typeName));
        	if (exactNamespace == null) {
        		return new EClassifier[0];
        	} else {
        		importedNamespaces = new EPackage[] { exactNamespace };
        	}
            simpleTypeName = TypeNameUtil.getLastSegment(typeName);
        } else {
        	importedNamespaces = getAllVisibleModels();
        	simpleTypeName = TypeNameUtil.toCanonicalNameFromAlias(typeName);
        }
        if (collectionTypeName != null) {
            if (!BuiltinMetaModel.isCollectionMetaType(collectionTypeName)) {
				return new EClassifier[0];
			}
        }
        final List<EClassifier> result = new ArrayList<EClassifier>();
        for (final EPackage namespace : importedNamespaces) {
        	if (simpleTypeName == null || simpleTypeName.trim().length() == 0) {
        		result.addAll(namespace.getEClassifiers());
        	} else {
        		result.addAll(filterByNamePrefix(simpleTypeName, namespace.getEClassifiers()));
        	}
        }
        if (collectionTypeName == null) {
            return result.toArray(new EClassifier[result.size()]);
        }
        EClassifier[] rv = new EClassifier[result.size()];
        final Iterator<EClassifier> iterator = result.iterator();
        for (int i = 0; i < rv.length; i++) {
        	rv[i] = BuiltinMetaModel.getCollectionType(collectionTypeName, iterator.next());
        }
        return rv;
    }

	private EPackage findImportedNamespace(String namespace) {
    	assert namespace != null;
    	LinkedList<EPackage> potentialMatches = new LinkedList<EPackage>();
    	potentialMatches.addAll(Arrays.asList(getAllVisibleModels()));
    	String[] namespaceChain = namespace.split(SyntaxConstants.NS_DELIM);
    	EPackage returnValue = null;
		for (String namespacePart : namespaceChain) {
			LinkedList<EPackage> subPackages = new LinkedList<EPackage>();
			returnValue = null;
			for (EPackage candidate : potentialMatches) {
				if (candidate.getName().equals(namespacePart)) {
					subPackages.addAll(candidate.getESubpackages());
					returnValue = candidate;
					break; // no more than one package with specified namespacePart 
				}
			}
			potentialMatches = subPackages;
		}
		return returnValue;
	}

    private static <T extends ENamedElement> Collection<T> filterByNamePrefix(final String namePrefix, final Collection<? extends T> knownNamedElements) {
        final Set<T> result = new HashSet<T>();
        for (T t : knownNamedElements) {
            if (t.getName().startsWith(namePrefix)) {
            	result.add(t);
            }
        }
        return result;
    }

    /**
     * {@@link ClassLoadContext} to use in {@@link #loadClass(String)}.
     * @@param classLoader loader to use or null to use default system-wide
     */
    public void setContextClassLoader(ClassLoadContext classLoadContext) {
    	this.contextClassLoader = classLoadContext;
    }

    public Class<?> loadClass(String value) {
    	// FIXME delegate to resourcemanager or Environment
    	try {
    		if (contextClassLoader != null) {
    			Class<?> c = contextClassLoader.load(value);
    			if (c != null) {
    				return c;
    			}
    		}
    		return Class.forName(value);
    	} catch (ClassNotFoundException ex) {
    		ex.getMessage();
    		// IGNORE?
    	}
    	return null;
    }

	protected EPackage[] getAllVisibleModels() {
		String[] importedNamespaces = getImportedNamespaces();
		assert importedNamespaces != null;
		// TODO respect meta-models imported not only with nsURI
		LinkedList<EPackage> result = new LinkedList<EPackage>();
		for (String namespace : importedNamespaces) {
			EPackage pkg = Activator.findMetaModel(namespace);
			if (pkg != null) {
				result.add(pkg);
			}
		}
		if (result.isEmpty()) {
			// hack for tests
			result.add(EcorePackage.eINSTANCE);
		}
//		result.add(BuiltinMetaModel.VOID.getEPackage());
		return result.toArray(new EPackage[result.size()]);
	}

    public EClassifier getTypeForName(String name) {
    	final String simpleTypeName = TypeNameUtil.toCanonicalNameFromAlias(TypeNameUtil.getSimpleName(TypeNameUtil.getTypeName(name)));
    	final String collectionTypeName = TypeNameUtil.getCollectionTypeName(name);
    	for (EClassifier potentialMatch : findTypesForPrefix(name)) {
    		// we don't know the order types get returned from #findTypesForPrefix, thus, need to 
    		// look for exact match
    		if (collectionTypeName != null) {
    			assert  BuiltinMetaModel.isParameterizedType(potentialMatch);
    			if (BuiltinMetaModel.getInnerType(potentialMatch).getName().equals(simpleTypeName)) {
    				return potentialMatch;
    			}
    		} else {
    			if (potentialMatch.getName().equals(simpleTypeName)) {
    				return potentialMatch;
    			}
    		}
       	}
    	return null;
    }

    protected String[] getImportedNamespaces() {
    	if (currentResource() instanceof XtendResource) {
    		return ((XtendResource) currentResource()).getImportedNamespaces();
    	}
    	return new String[0];
    }

    protected String[] getImportedExtensions() {
    	if (currentResource() instanceof XtendResource) {
    		return ((XtendResource) currentResource()).getImportedExtensions();
    	}
    	return new String[0];
    }

    public ExecutionContext cloneContext() {
        return new ExecutionContextImpl(this);
    }

    protected final ResourceManager getResourceManager() {
    	return resourceManager;
    }

    public Variable getVariable(final String name) {
        return variables.get(name);
    }

    public Collection<Variable> getVisibleVariables() {
        return Collections.unmodifiableCollection(variables.values());
    }

    public Collection<Variable> getGlobalVariables() {
        return Collections.unmodifiableCollection(globalVars.values());
    }

    public Variable getGlobalVariable(String name) {
    	return globalVars.get(name);
    }

	@@SuppressWarnings("unchecked")
	public ExecutionContext cloneWithVariable(final Variable... vars) {
        final ExecutionContextImpl result = (ExecutionContextImpl) cloneContext();
        for (Variable v : vars) {
        	result.variables.put(v.getName(), v);
        }
        return result;
    }

    @@SuppressWarnings("unchecked")
    public <T extends ExecutionContext> T cloneWithVariable(Collection<Variable> v) {
    	return (T) cloneWithVariable(v.toArray(new Variable[v.size()]));
    }

    @@SuppressWarnings("unchecked")
    public ExecutionContext cloneWithoutVariables() {
        final ExecutionContextImpl result = (ExecutionContextImpl) cloneContext();
        result.variables.clear();
        return result;
    }

    @@SuppressWarnings("unchecked")
    public ExecutionContext cloneWithResource(final ResourceMarker ns) {
        final ExecutionContextImpl ctx = (ExecutionContextImpl) cloneContext();
        ctx.currentResource = ns;
        return ctx;
    }

    public ResourceMarker currentResource() {
        return currentResource;
    }

    private Set<Extension> allExtensions = null;

	public Set<Extension> getAllExtensions() {
        if (allExtensions == null) {
            allExtensions = new HashSet<Extension>();
            final ResourceMarker res = currentResource();
            if (res != null) {
                final String[] extensions = getImportedExtensions();
                for (String extension : extensions) {
                    final XtendResource extFile = resourceManager.loadXtendResource(extension);
                    if (extFile == null) {
						throw new RuntimeException("Unable to load extension file : " + extension);
					}
                    final ExecutionContext ctx = cloneWithResource(extFile);
                    final List<Extension> extensionList = extFile.getPublicExtensions(resourceManager);
                    for (Extension element : extensionList) {
                        element.init(ctx);
                        allExtensions.add(element);
                    }
                }
                if (res instanceof XtendResource) {
                    final List<Extension> extensionList = ((XtendResource) res).getExtensions();
                    for (Extension element : extensionList) {
                        element.init(this);
                        allExtensions.add(element);
                    }
                }
            }
        }
        return allExtensions;
    }

    public Extension getExtension(final String functionName, final EClassifier[] parameterTypes) {
        return PolymorphicResolver.getExtension(getAllExtensions(), functionName, Arrays.asList(parameterTypes));
    }

    public EvaluationListener getEvaluationListener() {
    	return evaluationListener;
    }

    public void setEvaluationListener(EvaluationListener listener) {
    	this.evaluationListener = listener;
    }
}
@


1.10.4.1
log
@Initial commit of extend->qvt migration in xpand.
@
text
@d39 1
a39 2
import org.eclipse.gmf.internal.xpand.xtend.ast.GenericExtension;
import org.eclipse.gmf.internal.xpand.xtend.ast.QvtResource;
d311 1
a311 1
    private Set<GenericExtension> allExtensions = null;
d313 1
a313 1
	public Set<? extends GenericExtension> getAllExtensions() {
d315 1
a315 1
            allExtensions = new HashSet<GenericExtension>();
a319 12
                	// trying to load qvt extensions first
                	final QvtResource qvtResource = resourceManager.loadQvtResource(extension);
                	if (qvtResource != null) {
                		final ExecutionContext ctx = cloneWithResource(qvtResource);
                        final List<? extends GenericExtension> extensionList = qvtResource.getExtensions();
                        for (GenericExtension element : extensionList) {
                            element.init(ctx);
                            allExtensions.add(element);
                        }
                        continue;
                	}
                	// then xtend
d325 2
a326 2
                    final List<? extends GenericExtension> extensionList = extFile.getPublicExtensions(resourceManager);
                    for (GenericExtension element : extensionList) {
d332 2
a333 2
                    final List<? extends GenericExtension> extensionList = ((XtendResource) res).getExtensions();
                    for (GenericExtension element : extensionList) {
d343 1
a343 1
    public GenericExtension getExtension(final String functionName, final EClassifier[] parameterTypes) {
@


1.10.4.2
log
@Xtend-based implementation of XPand extensions was separated into .migration plugin.
@
text
@d41 1
d243 3
d250 3
d321 1
d332 18
@


1.10.4.3
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
a13 1
 *     Artem Tikhomirov (Borland) - Migration to OCL expressions
d17 1
d20 1
d23 2
d30 1
a32 1
import org.eclipse.emf.ecore.impl.EPackageRegistryImpl;
d34 1
a40 2
import org.eclipse.ocl.ecore.EcoreEnvironment;
import org.eclipse.ocl.ecore.EcoreEnvironmentFactory;
d96 79
a174 2
    	this.envFactory = original.envFactory;
    	this.environment = original.environment;
d202 39
d261 8
a275 1
    	result.environment = null; // XXX or create new, delegating?
d283 5
a290 1
    	result.environment = null;
a295 3
        if (ns == currentResource) {
        	return this;
        }
a297 2
    	ctx.envFactory = null; // need to make sure resource's imports are read into registry.
    	ctx.environment = null;
d310 15
a324 14
            final String[] extensions = getImportedExtensions();
            for (String extension : extensions) {
            	final QvtResource qvtResource = resourceManager.loadQvtResource(extension);
            	if (qvtResource != null) {
            		final ExecutionContext ctx = cloneWithResource(qvtResource);
                    final List<? extends GenericExtension> extensionList = qvtResource.getExtensions();
                    for (GenericExtension element : extensionList) {
                        element.init(ctx);
                        allExtensions.add(element);
                    }
            	} else {
            		// XXX ask Vano - used to be exception
            		//throw new RuntimeException("Unable to load extension file : " + extension);
            	}
d331 1
a331 15
        return PolymorphicResolver.getExtension(getAllExtensions(), functionName, Arrays.asList(parameterTypes), null/*FIXME*/);
    }

    private EcoreEnvironmentFactory envFactory; // null-ified when context's resource is changed
    private EcoreEnvironment environment;

    public EcoreEnvironment getOCLEnvironment() {
    	if (environment != null) {
    		return environment;
    	}
    	if (envFactory == null) {
    		envFactory = new EcoreEnvironmentFactory(getAllVisibleModels());
    	}
    	environment = (EcoreEnvironment) envFactory.createEnvironment();
    	return environment;
a333 18
    private EPackage.Registry getAllVisibleModels() {
		String[] importedNamespaces = getImportedNamespaces();
		assert importedNamespaces != null;
		// TODO respect meta-models imported not only with nsURI
		EPackage.Registry result = new EPackageRegistryImpl();
		for (String namespace : importedNamespaces) {
			EPackage pkg = Activator.findMetaModel(namespace);
			if (pkg != null) {
				result.put(namespace, pkg);
			}
		}
		if (result.isEmpty()) {
			// hack for tests
			result.put(EcorePackage.eNS_URI, EcorePackage.eINSTANCE);
		}
		return result;
	}

@


1.10.4.4
log
@Throwing exception if QvtResource was not found.
@
text
@d185 10
a194 8
            	if (qvtResource == null) {
            		throw new RuntimeException("Unable to load extension file : " + extension);
            	}
            	final ExecutionContext ctx = cloneWithResource(qvtResource);
            	final List<? extends GenericExtension> extensionList = qvtResource.getExtensions();
            	for (GenericExtension element : extensionList) {
            		element.init(ctx);
            		allExtensions.add(element);
@


1.10.4.5
log
@[243154] Use OCL instead of home-grown expression language. Refactored to eliminate context specific to expressions (moving towards using OCL environment for that), split modifiable (context-specific) and static execution data.
@
text
@@


1.9
log
@make compilable with 3.3.1
@
text
@d4 1
a4 1
 * Copyright (c) 2005-2006 Sven Efftinge and others.
a39 1
import org.eclipse.gmf.internal.xpand.xtend.ast.ExtensionFile;
d242 2
a243 2
    	if (currentResource() instanceof ExtensionFile) {
    		return ((ExtensionFile) currentResource()).getImportedNamespaces();
d249 2
a250 2
    	if (currentResource() instanceof ExtensionFile) {
    		return ((ExtensionFile) currentResource()).getImportedExtensions();
@


1.8
log
@no longer need with EMF 2.3
@
text
@d279 2
a280 2
    
    @@SuppressWarnings("unchecked")
d290 2
a291 2
    public ExecutionContext cloneWithVariable(Collection<Variable> v) {
    	return cloneWithVariable(v.toArray(new Variable[v.size()]));
@


1.8.2.1
log
@make compilable with 3.3.1
@
text
@d279 2
a280 2

	@@SuppressWarnings("unchecked")
d290 2
a291 2
    public <T extends ExecutionContext> T cloneWithVariable(Collection<Variable> v) {
    	return (T) cloneWithVariable(v.toArray(new Variable[v.size()]));
@


1.7
log
@abstract class loading concept
@
text
@a146 1
    @@SuppressWarnings("unchecked")
@


1.6
log
@basic debug support for xpand
@
text
@d38 1
d53 1
a53 1
    private ClassLoader contextClassLoader;
d180 1
a180 1
     * {@@link ClassLoader} to use in {@@link #loadClass(String)}.
d183 2
a184 2
    public void setContextClassLoader(ClassLoader classLoader) {
    	contextClassLoader = classLoader;
d187 1
a187 1
    public Class loadClass(String value) {
d191 1
a191 1
    			Class c = contextClassLoader.loadClass(value);
@


1.5
log
@use model instances from development workspace
@
text
@d37 1
d54 2
d95 1
d347 8
@


1.4
log
@add context classloader to resolve access problems to methods from inaccessible (no dependency) plug-ins
@
text
@d33 1
d193 1
d205 1
a205 1
			EPackage pkg = EPackage.Registry.INSTANCE.getEPackage(namespace);
@


1.3
log
@refactored use of variables (no need to expose Map)
@
text
@d49 3
a51 2
    
    
d90 1
d173 8
d182 1
a182 2
    	// TODO Auto-generated method stub
    	// XXX delegate to resourcemanager?
d184 6
@


1.2
log
@useless cloneWithoutResource removed
@
text
@d61 1
a61 1
        this (resourceManager, (Map<String, Variable>) null);
d64 1
a64 1
    public ExecutionContextImpl(ResourceManager resourceManager, Map<String, Variable> globalVars) {
d68 1
a68 1
    public ExecutionContextImpl(ResourceManager resourceManager, ResourceMarker resource, Map<String, Variable> variables, Map<String, Variable> globalVars) {
d72 3
a74 1
			this.variables.putAll(variables);
d77 3
a79 1
			this.globalVars.putAll (globalVars);
d82 9
a90 1
    
d236 1
a236 1
        return new ExecutionContextImpl (resourceManager, currentResource, variables, globalVars);
d247 2
a248 2
    public Map<String, Variable> getVisibleVariables() {
        return Collections.unmodifiableMap(variables);
d251 6
a256 2
    public Map<String, Variable> getGlobalVariables () {
        return Collections.unmodifiableMap(globalVars);
d260 1
a260 1
	public ExecutionContext cloneWithVariable(final Variable v) {
d262 3
a264 1
        result.variables.put(v.getName(), v);
d269 5
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@a263 7
    @@SuppressWarnings("unchecked")
    public ExecutionContext cloneWithoutResource() {
        final ExecutionContextImpl ctx = (ExecutionContextImpl) cloneContext();
        ctx.currentResource = null;
        return ctx;
    }

@

