head	1.3;
access;
symbols
	v20081022-1925:1.3
	v20081020-0700:1.3
	ocl_qvt:1.3.0.4
	Root_ocl_qvt:1.3
	v20080722-1827:1.3
	v20080718-1731:1.3
	v20080716-1600:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.2
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080528-1052:1.3
	v20080516-1143:1.3
	v20080417-1610:1.3
	v20080322-0000:1.3
	v20080222-1200:1.3
	v20071130-1111:1.3
	v20071124-0000:1.2
	v20071108-0000:1.3
	v20071003-0000:1.2
	v20070921-0000:1.2
	v20070903-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	RC3_20:1.2
	v20070608-1300:1.2
	v20070605-1400:1.2
	v20070601-1400:1.2
	v20070518-1300:1.2
	v20070420-1000:1.2
	v20070405-1100:1.2
	v20070403-1500:1.2
	v20070330-1300:1.2
	v20070208-1800:1.2
	v20070103-0300:1.2
	M4_20:1.2
	M3_20:1.2;
locks; strict;
comment	@# @;


1.3
date	2007.10.29.16.58.22;	author atikhomirov;	state Exp;
branches
	1.3.4.1;
next	1.2;
commitid	5b914726112d4567;

1.2
date	2006.11.07.14.20.05;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.51;	author atikhomirov;	state Exp;
branches;
next	;

1.3.4.1
date	2008.07.24.16.21.35;	author ashatalin;	state Exp;
branches;
next	1.3.4.2;
commitid	7c4a4888ac0d4567;

1.3.4.2
date	2008.08.05.12.49.25;	author atikhomirov;	state Exp;
branches;
next	1.3.4.3;
commitid	546c48984c4a4567;

1.3.4.3
date	2008.08.06.14.05.36;	author atikhomirov;	state dead;
branches;
next	;
commitid	35b4899afa74567;


desc
@@


1.3
log
@[207437] Resources to be composed from several sources
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2007 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.expression;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EParameter;
import org.eclipse.gmf.internal.xpand.model.XpandDefinition;
import org.eclipse.gmf.internal.xpand.xtend.ast.Extension;

/**
 * @@author Sven Efftinge
 * @@author Arno Haase
 */
public class PolymorphicResolver {

	public static XpandDefinition filterDefinition(final HashMap<XpandDefinition, List<EClassifier>> resolvedDefs, EClassifier targetType, List<EClassifier> paramTypes) {
        final List<EClassifier> allParams = new ArrayList<EClassifier>();
        allParams.add(targetType);
        allParams.addAll(paramTypes);

        final List<XpandDefinition> candidateDefinition = new ArrayList<XpandDefinition>();
        for (XpandDefinition def : resolvedDefs.keySet()) {
            final List<? extends EClassifier> featureParamTypes = resolvedDefs.get(def);
            if ((featureParamTypes.size() == allParams.size())
                    && (typesComparator.compare(featureParamTypes, allParams) >= 0)) {
            	candidateDefinition.add(def);
            }
        }
		final Comparator<XpandDefinition> comparator = new Comparator<XpandDefinition>() {
	        public int compare(XpandDefinition d1, XpandDefinition d2) {
	            return typesComparator.compare(resolvedDefs.get(d1), resolvedDefs.get(d2));
	        }
	    };
	    try {
	    	return filterWithComparator(candidateDefinition, comparator);
	    } catch (IllegalStateException ex) {
			throw new RuntimeException("Ambiguous definitions " + candidateDefinition.get(0).toString() + " and "
                    + candidateDefinition.get(1).toString() + " for param types " + paramTypes);
	    }
	}

    public final static Extension getExtension(final Set<Extension> extensions, final String name, final List<EClassifier> paramTypes) {
        final List<Extension> candidateExtensions = new ArrayList<Extension>();
        for (Extension ext : extensions) {
            if (ext.getName().equals(name)) {
                final List<? extends EClassifier> featureParamTypes = ext.getParameterTypes();
                if ((featureParamTypes.size() == paramTypes.size())
                        && (typesComparator.compare(featureParamTypes, paramTypes) >= 0)) {
                    candidateExtensions.add(ext);
                }
            }
        }
		final Comparator<Extension> extensionComparator = new Comparator<Extension>() {
	        public int compare(Extension e1, Extension e2) {
	            return typesComparator.compare(e1.getParameterTypes(), e2.getParameterTypes());
	        }
	    };
	    try {
	    	return filterWithComparator(candidateExtensions, extensionComparator);
	    } catch (IllegalStateException ex) {
            // candidateExtensions was passed by reference, hence, it's already sort
			throw new RuntimeException("Ambiguous extensions " + candidateExtensions.get(0).toString() + " and "
                    + candidateExtensions.get(1).toString() + " for param types " + paramTypes);
	    }
    }
    
    @@SuppressWarnings("unchecked")
	public static EOperation filterOperation(List<EOperation> allOperations, String name, EClassifier targetType, List<EClassifier> paramTypes) {
		final Map<EOperation, List<EClassifier>> candidates = new HashMap<EOperation, List<EClassifier>>();
		ArrayList<EClassifier> expectedParamsWithTarget = new ArrayList(paramTypes.size() + 1);
		expectedParamsWithTarget.add(targetType);
		expectedParamsWithTarget.addAll(paramTypes);
		for (EOperation op : allOperations) {
			if (op.getName().equals(name) && (op.getEParameters().size() == paramTypes.size())) {
				List<EClassifier> candidateOperationParams = new ArrayList<EClassifier>(paramTypes.size() + 1);
				if (op.getEContainingClass() != null) {
					candidateOperationParams.add(op.getEContainingClass());
				}
				List<EParameter> allParams = op.getEParameters();
				for (EParameter p : allParams ) {
					candidateOperationParams.add(p.getEType());
				}
				if (typesComparator.compare(candidateOperationParams, op.getEContainingClass() != null ? expectedParamsWithTarget : paramTypes) >= 0) {
					candidates.put(op, candidateOperationParams);
				}
			}
		}
		final Comparator<EOperation> comparator = new Comparator<EOperation>() {
	        public int compare(EOperation o1, EOperation o2) {
	            return typesComparator.compare(candidates.get(o1), candidates.get(o2));
	        }
	    };
    	final List<EOperation> candidates2 = new LinkedList<EOperation>();
	    try {
	    	candidates2.addAll(candidates.keySet());
	    	return filterWithComparator(candidates2, comparator);
	    } catch (IllegalStateException ex) {
			throw new RuntimeException("Ambiguous definitions " + candidates2.get(0).toString() + " and "
                    + candidates2.get(1).toString() + " for param types " + paramTypes, ex);
	    }    }
    /**
     * @@throws IllegalStateException when there are more than one candidates with same priority
     */
    private static <T> T filterWithComparator(List<T> candidates, Comparator<T> comparator) throws IllegalStateException {
        if (candidates.size() == 1) {
			return candidates.get(0);
		} else if (candidates.isEmpty()) {
			return null;
		} else {
            // sort features by specialization
            Collections.sort(candidates, comparator);

            if (comparator.compare(candidates.get(1), candidates.get(0)) > 0) {
				return candidates.get(0);
			} else {
				throw new IllegalStateException();
			}
        }
    }

    private final static TypesComparator typesComparator = new TypesComparator();
}
@


1.3.4.1
log
@Initial commit of extend->qvt migration in xpand.
@
text
@d30 1
a30 1
import org.eclipse.gmf.internal.xpand.xtend.ast.GenericExtension;
d64 3
a66 3
    public final static GenericExtension getExtension(final Set<? extends GenericExtension> extensions, final String name, final List<EClassifier> paramTypes) {
        final List<GenericExtension> candidateExtensions = new ArrayList<GenericExtension>();
        for (GenericExtension ext : extensions) {
d75 2
a76 2
		final Comparator<GenericExtension> extensionComparator = new Comparator<GenericExtension>() {
	        public int compare(GenericExtension e1, GenericExtension e2) {
@


1.3.4.2
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
a13 1
 *     Artem Tikhomirov (Borland) - Migration to OCL expressions
a30 1
import org.eclipse.ocl.ecore.EcoreEnvironment;
d38 1
a38 1
	public static XpandDefinition filterDefinition(final HashMap<XpandDefinition, List<EClassifier>> resolvedDefs, EClassifier targetType, List<EClassifier> paramTypes, EcoreEnvironment env) {
a42 2
        final TypesComparator typesComparator = new TypesComparator(env);
        
d44 1
a44 1
		for (XpandDefinition def : resolvedDefs.keySet()) {
d47 1
a47 1
                    && (typesComparator .compare(featureParamTypes, allParams) >= 0)) {
d64 1
a64 1
    public final static GenericExtension getExtension(final Set<? extends GenericExtension> extensions, final String name, final List<EClassifier> paramTypes, EcoreEnvironment env) {
a65 1
        final TypesComparator typesComparator = new TypesComparator(env);
d90 1
a90 1
	public static EOperation filterOperation(List<EOperation> allOperations, String name, EClassifier targetType, List<EClassifier> paramTypes, EcoreEnvironment env) {
a94 1
        final TypesComparator typesComparator = new TypesComparator(env);
d142 2
@


1.3.4.3
log
@[243154] Use OCL instead of home-grown expression language. Refactored to eliminate context specific to expressions (moving towards using OCL environment for that), split modifiable (context-specific) and static execution data.
@
text
@@


1.2
log
@filter templates by name right away
@
text
@d4 1
a4 1
 * Copyright (c) 2005-2006 Sven Efftinge and others.
d121 1
a121 1
                    + candidates2.get(1).toString() + " for param types " + paramTypes);
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d38 1
a38 1
	public static XpandDefinition filterDefinition(final HashMap<XpandDefinition, List<EClassifier>> resolvedDefs, String name, EClassifier targetType, List<EClassifier> paramTypes) {
d45 4
a48 6
            if (def.getName().equals(name)) {
                final List<? extends EClassifier> featureParamTypes = resolvedDefs.get(def);
                if ((featureParamTypes.size() == allParams.size())
                        && (typesComparator.compare(featureParamTypes, allParams) >= 0)) {
                	candidateDefinition.add(def);
                }
@

