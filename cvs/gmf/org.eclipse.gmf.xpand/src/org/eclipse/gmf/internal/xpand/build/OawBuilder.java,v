head	1.7;
access;
symbols
	v20081022-1925:1.7
	v20081020-0700:1.7
	ocl_qvt:1.7.0.4
	Root_ocl_qvt:1.7
	v20080722-1827:1.7
	v20080718-1731:1.7
	v20080716-1600:1.7
	v20080716-1642:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080528-1052:1.7
	v20080516-1143:1.7
	v20080417-1610:1.7
	v20080322-0000:1.7
	v20080222-1200:1.7
	v20071130-1111:1.7
	v20071124-0000:1.6
	v20071108-0000:1.7
	v20071003-0000:1.6
	v20070921-0000:1.6
	v20070903-0000:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	RC3_20:1.6
	v20070608-1300:1.6
	v20070605-1400:1.6
	v20070601-1400:1.6
	v20070518-1300:1.6
	v20070420-1000:1.6
	v20070405-1100:1.6
	v20070403-1500:1.6
	v20070330-1300:1.6
	v20070208-1800:1.6
	v20070103-0300:1.6
	M4_20:1.6
	M3_20:1.5;
locks; strict;
comment	@# @;


1.7
date	2007.10.29.16.58.24;	author atikhomirov;	state Exp;
branches
	1.7.4.1;
next	1.6;
commitid	5b914726112d4567;

1.6
date	2006.11.27.20.32.43;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	2645456b4b6b4567;

1.5
date	2006.11.10.13.17.06;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.02.18.30.45;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.25.17.23.40;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.23.21.10.46;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.52;	author atikhomirov;	state Exp;
branches;
next	;

1.7.4.1
date	2008.07.29.15.57.05;	author ashatalin;	state Exp;
branches;
next	1.7.4.2;
commitid	337c488f3dcd4567;

1.7.4.2
date	2008.08.06.14.05.34;	author atikhomirov;	state Exp;
branches;
next	;
commitid	35b4899afa74567;


desc
@@


1.7
log
@[207437] Resources to be composed from several sources
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2007 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.build;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IResourceVisitor;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.gmf.internal.xpand.Activator;
import org.eclipse.gmf.internal.xpand.RootManager;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContext;
import org.eclipse.gmf.internal.xpand.model.XpandExecutionContext;
import org.eclipse.gmf.internal.xpand.model.XpandResource;
import org.eclipse.gmf.internal.xpand.util.ContextFactory;
import org.eclipse.gmf.internal.xpand.util.OawMarkerManager;
import org.eclipse.gmf.internal.xpand.util.ParserException;
import org.eclipse.gmf.internal.xpand.util.ParserException.ErrorLocationInfo;
import org.eclipse.gmf.internal.xpand.xtend.ast.XtendResource;

public class OawBuilder extends IncrementalProjectBuilder implements RootManager.IRootChangeListener {
	private RootManager myRootManager;

	private WorkspaceModelRegistry modelRegistry;

	private boolean myRootsChanged = true;

	// XXX again, using map as mere pairs
	private final Map<XtendResource, IFile> xtendResourcesToAnalyze = new HashMap<XtendResource, IFile>();
	private final Map<XpandResource, IFile> xpandResourcesToAnalyze = new HashMap<XpandResource, IFile>();

	public static final String getBUILDER_ID() {
		return Activator.getId() + ".oawBuilder";
	}

	@@Override
	protected void startupOnInitialize() {
		super.startupOnInitialize();
		myRootManager = Activator.getRootManager(getProject());
		myRootManager.addRootChangeListener(this);
		modelRegistry = new WorkspaceModelRegistry();
		Activator.registerModelSource(modelRegistry);
	}

	@@Override
	protected IProject[] build(final int kind, final Map args, final IProgressMonitor monitor) throws CoreException {
		try {
			doBuild(kind, args, monitor);
		} catch (final Throwable e) {
			e.printStackTrace();
		}
		// TODO to separate thread
		for (XtendResource r : xtendResourcesToAnalyze.keySet()) {
	        final ExecutionContext ctx = ContextFactory.createXtendContext(getResourceManager(xtendResourcesToAnalyze.get(r)));
	        final Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
	        r.analyze(ctx, issues);
	        updateMarkers(xtendResourcesToAnalyze.get(r), issues);
		}
		for (XpandResource r : xpandResourcesToAnalyze.keySet()) {
	        final XpandExecutionContext ctx = ContextFactory.createXpandContext(getResourceManager(xpandResourcesToAnalyze.get(r)));
	        final Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
	        r.analyze(ctx, issues);
	        updateMarkers(xpandResourcesToAnalyze.get(r), issues);
		}
		xtendResourcesToAnalyze.clear();
		xpandResourcesToAnalyze.clear();

		myRootsChanged = false;
		Set<IProject> referencedProjects = myRootManager.getReferencedProjects();
		referencedProjects.remove(getProject());
		return referencedProjects.toArray(new IProject[referencedProjects.size()]);
	}

	private void doBuild(int kind, Map<?, ?> args, IProgressMonitor monitor) throws CoreException {
		if ((kind == FULL_BUILD) || haveRootsChangedSinceLastBuild()) {
			fullBuild(monitor);
		} else {
			Set<IProject> referencedProjects = myRootManager.getReferencedProjects();
			referencedProjects.remove(getProject());
			Collection<IResourceDelta> deltas = new ArrayList<IResourceDelta>(referencedProjects.size());
			IResourceDelta projectDelta = getDelta(getProject());
			if (projectDelta == null) {
				fullBuild(monitor);
				return;
			}
			for (IProject next : referencedProjects) {
				final IResourceDelta delta = getDelta(next);
				if (delta == null) {
					fullBuild(monitor);
					return;
				}
				deltas.add(delta);
			}
			incrementalBuild(projectDelta, deltas, monitor);
		}
	}

	public void rootsChanged(RootManager rootManager) {
		myRootsChanged = true;
	}

	private boolean haveRootsChangedSinceLastBuild() {
		return myRootsChanged;
	}

	void reloadResource(final IFile resource) {
		getResourceManager(resource).forget(resource);
		if (!resource.exists()) {
			return;
		}
		try {
			if (isXpand(resource)) {
				XpandResource r = getResourceManager(resource).loadXpandResource(resource);
				if (r != null) {
					xpandResourcesToAnalyze.put(r, resource);
				}
			} else if (isXtend(resource)) {
				XtendResource r = getResourceManager(resource).loadXtendResource(resource);
				if (r != null) {
					xtendResourcesToAnalyze.put(r, resource);
				}
			}
		} catch (ParserException ex) {
			updateMarkers(resource, ex.getParsingErrors());
		} catch (Exception ex) {
			Activator.logError(ex);
			// perhaps, depending on exception type (Core|IO) we can decide to keep old markers? 
			OawMarkerManager.deleteMarkers(resource);
			OawMarkerManager.addErrorMarker(resource, ex.getMessage(), -1, -1);
		}
	}

	public void handleRemovement(final IFile resource) {
		OawMarkerManager.deleteMarkers(resource);
		getResourceManager(resource).forget(resource);
	}

	private WorkspaceResourceManager getResourceManager(IFile file) {
		WorkspaceResourceManager result = myRootManager.getResourceManager(file);
		assert result != null;
		return result;
	}

	protected void fullBuild(final IProgressMonitor monitor) throws CoreException {
		Set<IProject> referencedProjects = myRootManager.getReferencedProjects();
		referencedProjects.add(getProject());
		OawMarkerManager.deleteMarkers(getProject());	//to delete markers from obsolete roots.
		monitor.beginTask(null, 1 + referencedProjects.size());
		try {
			for (IProject next : referencedProjects) {
				checkCanceled(monitor);
				next.accept(new XpandResourceVisitor(new SubProgressMonitor(monitor, 1)));
			}
			checkCanceled(monitor);
			modelRegistry.build(getProject(), new SubProgressMonitor(monitor, 1));
		} finally {
			monitor.done();
		}
	}

	protected void incrementalBuild(final IResourceDelta projectDelta, final Collection<IResourceDelta> referencedProjectDeltas, final IProgressMonitor monitor) throws CoreException {
		monitor.beginTask(null, 2 + referencedProjectDeltas.size());
		try {
			for (IResourceDelta delta : referencedProjectDeltas) {
				checkCanceled(monitor);
				delta.accept(new XpandResourceVisitor(new SubProgressMonitor(monitor, 1)));
			}
			checkCanceled(monitor);
			projectDelta.accept(new XpandResourceVisitor(new SubProgressMonitor(monitor, 1)));
			checkCanceled(monitor);
			modelRegistry.build(getProject(), projectDelta, new SubProgressMonitor(monitor, 1));
		} finally {
			monitor.done();
		}
	}

	private void checkCanceled(final IProgressMonitor monitor) {
		if (monitor.isCanceled()) {
			throw new OperationCanceledException();
		}
	}

	private static void updateMarkers(IFile resource, Set<AnalysationIssue> issues) {
        OawMarkerManager.deleteMarkers(resource);
        OawMarkerManager.addMarkers(resource, issues.toArray(new AnalysationIssue[issues.size()]));
	}

	private static void updateMarkers(IFile resource, ErrorLocationInfo[] parsingErrors) {
        OawMarkerManager.deleteMarkers(resource);
        OawMarkerManager.addMarkers(resource, parsingErrors);
	}

	private static boolean isXtend(final IFile resource) {
		return XtendResource.FILE_EXTENSION.equals(resource.getFileExtension());
	}

	private static boolean isXpand(final IFile resource) {
		return XpandResource.TEMPLATE_EXTENSION.equals(resource.getFileExtension());
	}

	private boolean isFileOfInterest(IFile file) {
		if (!isXpand(file) && !isXtend(file)) {
			return false;
		}
		if (getResourceManager(file) == null) {
			return false;
		}
		return true;
	}

	private class XpandResourceVisitor implements IResourceVisitor, IResourceDeltaVisitor {
		private final IProgressMonitor monitor;

		public XpandResourceVisitor(final IProgressMonitor monitor) {
			this.monitor = monitor;
		}

		public boolean visit(final IResource resource) {
			if (!resource.isDerived() && (resource instanceof IFile) && isFileOfInterest((IFile) resource)) {
				reloadResource((IFile) resource);
			}
			monitor.worked(1);
			return true;
		}

		public boolean visit(final IResourceDelta delta) throws CoreException {
			final IResource resource = delta.getResource();
			if (resource.isDerived()) {
				return false;
			}
			if ((resource instanceof IFile)) {
				IFile file = (IFile) resource;
				if (!isFileOfInterest(file)) {
					return false;
				}
				switch (delta.getKind()) {
				case IResourceDelta.ADDED:
					reloadResource(file);
					break;
				case IResourceDelta.REMOVED:
					handleRemovement(file);
					break;
				case IResourceDelta.CHANGED:
					reloadResource(file);
					break;
				}
			} else if (resource instanceof IProject) {
				// forget about project in resource manager
				if (delta.getKind() == IResourceDelta.REMOVED) {
					System.err.println("Project removed:" + resource.getName());
				}
				if (delta.getKind() == IResourceDelta.OPEN) {
					System.err.println("Project open:" + ((IProject) resource).isOpen());
				}
			}
			monitor.worked(1);
			return true;
		}
	}

}
@


1.7.4.1
log
@Xtend-based implementation of XPand extensions was separated into .migration plugin.
@
text
@d38 1
d45 1
d55 1
d79 6
d91 1
d143 5
d219 4
d228 1
a228 1
		if (!isXpand(file)) {
@


1.7.4.2
log
@[243154] Use OCL instead of home-grown expression language. Refactored to eliminate context specific to expressions (moving towards using OCL environment for that), split modifiable (context-specific) and static execution data.
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
a13 1
 *     Artem Tikhomirov (Borland) - Migration to OCL expressions
d37 2
a38 2
import org.eclipse.gmf.internal.xpand.model.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.model.ExecutionContext;
d77 1
a77 1
	        final ExecutionContext ctx = ContextFactory.createXpandContext(getResourceManager(xpandResourcesToAnalyze.get(r)));
@


1.6
log
@fixme not to forget to rework assertion
@
text
@d4 1
a4 1
 * Copyright (c) 2005-2006 Sven Efftinge and others.
d17 2
d33 1
d36 1
d47 2
a48 1
public class OawBuilder extends IncrementalProjectBuilder {
a49 2
	private boolean firstBuild = true; // XXX odd
	private WorkspaceResourceManager resourceManager;
d52 2
d65 2
a66 4
		resourceManager = new WorkspaceResourceManager(getProject());
		// FIXME if codesense has been activated, there's already manager instance and we fail with exception here
		Activator.registerResourceManager(getProject(), resourceManager);
		firstBuild = true;
d74 1
a74 10
			if (firstBuild || (kind == FULL_BUILD)) {
				fullBuild(monitor);
			} else {
				final IResourceDelta delta = getDelta(getProject());
				if (delta == null) {
					fullBuild(monitor);
				} else {
					incrementalBuild(delta, monitor);
				}
			}
a77 1
		firstBuild = false;
a78 1
		
d80 1
a80 1
	        final ExecutionContext ctx = ContextFactory.createXtendContext(getResourceManager());
d86 1
a86 1
	        final XpandExecutionContext ctx = ContextFactory.createXpandContext(getResourceManager());
a90 1
		// XXX is builder's instance shared for several projects - if yes, we may get ConcurrentModificationEx here 
d93 37
a129 1
		return null;
d133 1
a136 1
		getResourceManager().forget(resource);
d139 1
a139 1
				XpandResource r = getResourceManager().loadXpandResource(resource);
d144 1
a144 1
				XtendResource r = getResourceManager().loadXtendResource(resource);
d161 7
a167 1
		getResourceManager().forget(resource);
d171 14
a184 4
		monitor.beginTask(null, 2);
		getProject().accept(new XpandResourceVisitor(new SubProgressMonitor(monitor, 1)));
		modelRegistry.build(getProject(), new SubProgressMonitor(monitor, 1));
		monitor.done();
d187 14
a200 5
	protected void incrementalBuild(final IResourceDelta delta, final IProgressMonitor monitor) throws CoreException {
		monitor.beginTask(null, 2);
		delta.accept(new XpandResourceVisitor(new SubProgressMonitor(monitor, 1)));
		modelRegistry.build(getProject(), delta, new SubProgressMonitor(monitor, 1));
		monitor.done();
d203 4
a206 2
	private WorkspaceResourceManager getResourceManager() {
		return resourceManager;
d227 8
a234 2
	private static boolean isFileOfInterest(IFile file) {
		return isXpand(file) || isXtend(file);
d286 1
@


1.5
log
@use model instances from development workspace
@
text
@d61 1
@


1.4
log
@changed ids not to clash with oaw plugins (just in case), get rid of nature nobody seemed to be really using
@
text
@d31 1
d45 1
a45 1
	private static boolean firstBuild = true; // XXX odd
d47 1
a56 4
	private static boolean isFileOfInterest(IFile file) {
		return XpandResource.TEMPLATE_EXTENSION.equals(file.getFileExtension()) || XtendResource.FILE_EXTENSION.equals(file.getFileExtension());
	}

a58 1
		// TODO Auto-generated method stub
d61 4
a70 1
				System.err.println("First build, kind:" + kind + " and is FULLBUILD:" + (kind == FULL_BUILD));
d110 1
a110 1
			if (XpandResource.TEMPLATE_EXTENSION.equals(resource.getFileExtension())) {
d115 1
a115 1
			} else if (XtendResource.FILE_EXTENSION.equals(resource.getFileExtension())) {
a130 1

d137 4
a140 1
		getProject().accept(new XpandResourceVisitor(monitor));
d144 4
a147 1
		delta.accept(new XpandResourceVisitor(monitor));
d164 12
d177 1
a177 1
		private IProgressMonitor monitor;
@


1.3
log
@refactored resource manager into capable working in workspace and working with uris, added experimental extended error reporting to provide more details on parsing errors
@
text
@d52 1
a52 1
		return "org.openarchitectureware.base.oawBuilder";
@


1.2
log
@markers refactored not to parse file when there's information about line number already available
@
text
@a31 1
import org.eclipse.gmf.internal.xpand.ResourceManager;
d38 2
d45 1
d47 3
a49 50
	class OawDeltaVisitor implements IResourceDeltaVisitor {
		private IProgressMonitor monitor;

		public OawDeltaVisitor(final IProgressMonitor monitor) {
			this.monitor = monitor;
		}

		public boolean visit(final IResourceDelta delta) throws CoreException {
			final IResource resource = delta.getResource();
			if (resource.isDerived()) {
				return false;
			}
			if ((resource instanceof IFile)) {
				IFile file = (IFile) resource;
				if (!isFileOfInterest(file)) {
					return false;
				}
				switch (delta.getKind()) {
				case IResourceDelta.ADDED:
					reloadResource(file);
					break;
				case IResourceDelta.REMOVED:
					handleRemovement(file);
					break;
				case IResourceDelta.CHANGED:
					reloadResource(file);
					break;
				}
			}
			monitor.worked(1);
			return true;
		}

	}

	private class XpandResourceVisitor implements IResourceVisitor {
		private IProgressMonitor monitor;

		public XpandResourceVisitor(final IProgressMonitor monitor) {
			this.monitor = monitor;
		}

		public boolean visit(final IResource resource) {
			if (!resource.isDerived() && (resource instanceof IFile) && isFileOfInterest((IFile) resource)) {
				reloadResource((IFile) resource);
			}
			monitor.worked(1);
			return true;
		}
	}
d59 6
a64 3
	// XXX again, using map as mere pairs
	private final Map<XtendResource, IFile> xtendResourcesToAnalyze = new HashMap<XtendResource, IFile>();
	private final Map<XpandResource, IFile> xpandResourcesToAnalyze = new HashMap<XpandResource, IFile>();
d70 1
a103 5
	private static void updateMarkers(IFile resource, Set<AnalysationIssue> issues) {
        OawMarkerManager.deleteMarkers(resource);
        OawMarkerManager.addMarkers(resource, issues.toArray(new AnalysationIssue[issues.size()]));
	}

d109 11
a119 9
		if (XpandResource.TEMPLATE_EXTENSION.equals(resource.getFileExtension())) {
			XpandResource r = getResourceManager().loadXpandResource(resource);
			if (r != null) {
				xpandResourcesToAnalyze.put(r, resource);
			}
		} else if (XtendResource.FILE_EXTENSION.equals(resource.getFileExtension())) {
			XtendResource r = getResourceManager().loadXtendResource(resource);
			if (r != null) {
				xtendResourcesToAnalyze.put(r, resource);
d121 7
d131 1
d142 1
a142 1
		delta.accept(new OawDeltaVisitor(monitor));
d145 62
a206 2
	protected ResourceManager getResourceManager() {
		return Activator.getResourceManager(getProject());
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d147 1
a147 3
        for (AnalysationIssue i : issues) {
            OawMarkerManager.addMarker(resource, i);
        }
@

