head	1.3;
access;
symbols
	v20081022-1925:1.3
	v20081020-0700:1.3
	ocl_qvt:1.3.0.6
	Root_ocl_qvt:1.3
	v20080722-1827:1.3
	v20080718-1731:1.3
	v20080716-1600:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.4
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080528-1052:1.3
	v20080516-1143:1.3
	v20080417-1610:1.3
	v20080322-0000:1.3
	v20080222-1200:1.3
	v20071130-1111:1.3
	v20071124-0000:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070921-0000:1.3
	v20070903-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	RC3_20:1.3
	v20070608-1300:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070518-1300:1.3
	v20070420-1000:1.3
	v20070405-1100:1.3
	v20070403-1500:1.3
	v20070330-1300:1.3
	v20070208-1800:1.3
	v20070103-0300:1.3
	M4_20:1.3
	M3_20:1.3;
locks; strict;
comment	@# @;


1.3
date	2006.11.06.16.36.18;	author atikhomirov;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2006.10.23.17.57.12;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.48;	author atikhomirov;	state Exp;
branches;
next	;

1.3.6.1
date	2008.08.05.14.49.23;	author atikhomirov;	state Exp;
branches;
next	;
commitid	48a6489868694567;


desc
@@


1.3
log
@handle dollar sign ($) correctly inside strings/comments
do not use external includes and copy external templates locally to be able to tweak them
minor changes to the includes
@
text
@/*******************************************************************************
* Copyright (c) 2006 Eclipse.org
* 
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*******************************************************************************/
package org.eclipse.gmf.internal.xpand.parser;


public class XpandKWLexer extends XpandKWLexerprs implements XpandParsersym
{
    private char[] inputChars;
    private final int keywordKind[] = new int[47 + 1];

    public int[] getKeywordKinds() { return keywordKind; }

    public int lexer(int curtok, int lasttok)
    {
        int current_kind = getKind(inputChars[curtok]),
            act;

        for (act = tAction(START_STATE, current_kind);
             act > NUM_RULES && act < ACCEPT_ACTION;
             act = tAction(act, current_kind))
        {
            curtok++;
            current_kind = (curtok > lasttok
                                   ? Char_EOF
                                   : getKind(inputChars[curtok]));
        }

        if (act > ERROR_ACTION)
        {
            curtok++;
            act -= ERROR_ACTION;
        }

        return keywordKind[act == ERROR_ACTION  || curtok <= lasttok ? 0 : act];
    }

    public void setInputChars(char[] inputChars) { this.inputChars = inputChars; }


    final static int tokenKind[] = new int[128];
    static {
        tokenKind['a'] = Char_a;
        tokenKind['b'] = Char_b;
        tokenKind['c'] = Char_c;
        tokenKind['d'] = Char_d;
        tokenKind['e'] = Char_e;
        tokenKind['f'] = Char_f;
        tokenKind['g'] = Char_g;
        tokenKind['h'] = Char_h;
        tokenKind['i'] = Char_i;
        tokenKind['j'] = Char_j;
        tokenKind['k'] = Char_k;
        tokenKind['l'] = Char_l;
        tokenKind['m'] = Char_m;
        tokenKind['n'] = Char_n;
        tokenKind['o'] = Char_o;
        tokenKind['p'] = Char_p;
        tokenKind['q'] = Char_q;
        tokenKind['r'] = Char_r;
        tokenKind['s'] = Char_s;
        tokenKind['t'] = Char_t;
        tokenKind['u'] = Char_u;
        tokenKind['v'] = Char_v;
        tokenKind['w'] = Char_w;
        tokenKind['x'] = Char_x;
        tokenKind['y'] = Char_y;
        tokenKind['z'] = Char_z;

        tokenKind['A'] = Char_A;
        tokenKind['B'] = Char_B;
        tokenKind['C'] = Char_C;
        tokenKind['D'] = Char_D;
        tokenKind['E'] = Char_E;
        tokenKind['F'] = Char_F;
        tokenKind['G'] = Char_G;
        tokenKind['H'] = Char_H;
        tokenKind['I'] = Char_I;
        tokenKind['J'] = Char_J;
        tokenKind['K'] = Char_K;
        tokenKind['L'] = Char_L;
        tokenKind['M'] = Char_M;
        tokenKind['N'] = Char_N;
        tokenKind['O'] = Char_O;
        tokenKind['P'] = Char_P;
        tokenKind['Q'] = Char_Q;
        tokenKind['R'] = Char_R;
        tokenKind['S'] = Char_S;
        tokenKind['T'] = Char_T;
        tokenKind['U'] = Char_U;
        tokenKind['V'] = Char_V;
        tokenKind['W'] = Char_W;
        tokenKind['X'] = Char_X;
        tokenKind['Y'] = Char_Y;
        tokenKind['Z'] = Char_Z;
    };

    final int getKind(char c) {
        return (c < 128 ? tokenKind[c] : 0);
    }


    public XpandKWLexer(char[] inputChars, int identifierKind)
    {
        this.inputChars = inputChars;
        keywordKind[0] = identifierKind;

        //
        // Rule 1:  KeyWord ::= n u l l
        //
		keywordKind[1] = (TK_null);
	  
	
        //
        // Rule 2:  KeyWord ::= t r u e
        //
		keywordKind[2] = (TK_true);
	  
	
        //
        // Rule 3:  KeyWord ::= f a l s e
        //
		keywordKind[3] = (TK_false);
	  
	
        //
        // Rule 4:  KeyWord ::= n e w
        //
		keywordKind[4] = (TK_new);
	  
	
        //
        // Rule 5:  KeyWord ::= l e t
        //
		keywordKind[5] = (TK_let);
	  
	
        //
        // Rule 6:  KeyWord ::= s w i t c h
        //
		keywordKind[6] = (TK_switch);
	  
	
        //
        // Rule 7:  KeyWord ::= c a s e
        //
		keywordKind[7] = (TK_case);
	  
	
        //
        // Rule 8:  KeyWord ::= d e f a u l t
        //
		keywordKind[8] = (TK_default);
	  
	
        //
        // Rule 9:  KeyWord ::= i m p l i e s
        //
		keywordKind[9] = (TK_implies);
	  
	
        //
        // Rule 10:  KeyWord ::= S e t
        //
		keywordKind[10] = (TK_Set);
	  
	
        //
        // Rule 11:  KeyWord ::= L i s t
        //
		keywordKind[11] = (TK_List);
	  
	
        //
        // Rule 12:  KeyWord ::= C o l l e c t i o n
        //
		keywordKind[12] = (TK_Collection);
	  
	
        //
        // Rule 13:  KeyWord ::= f o r A l l
        //
		keywordKind[13] = (TK_forAll);
	  
	
        //
        // Rule 14:  KeyWord ::= e x i s t s
        //
		keywordKind[14] = (TK_exists);
	  
	
        //
        // Rule 15:  KeyWord ::= n o t E x i s t s
        //
		keywordKind[15] = (TK_notExists);
	  
	
        //
        // Rule 16:  KeyWord ::= c o l l e c t
        //
		keywordKind[16] = (TK_collect);
	  
	
        //
        // Rule 17:  KeyWord ::= s e l e c t
        //
		keywordKind[17] = (TK_select);
	  
	
        //
        // Rule 18:  KeyWord ::= r e j e c t
        //
		keywordKind[18] = (TK_reject);
	  
	
        //
        // Rule 19:  KeyWord ::= t y p e S e l e c t
        //
		keywordKind[19] = (TK_typeSelect);
	  
	
        //
        // Rule 20:  KeyWord ::= I M P O R T
        //
		keywordKind[20] = (TK_IMPORT);
	
        //
        // Rule 21:  KeyWord ::= E X T E N S I O N
        //
		keywordKind[21] = (TK_EXTENSION);
	
        //
        // Rule 22:  KeyWord ::= A R O U N D
        //
		keywordKind[22] = (TK_AROUND);
	
        //
        // Rule 23:  KeyWord ::= E N D A R O U N D
        //
		keywordKind[23] = (TK_ENDAROUND);
	
        //
        // Rule 24:  KeyWord ::= D E F I N E
        //
		keywordKind[24] = (TK_DEFINE);
	
        //
        // Rule 25:  KeyWord ::= E N D D E F I N E
        //
		keywordKind[25] = (TK_ENDDEFINE);
	
        //
        // Rule 26:  KeyWord ::= E R R O R
        //
		keywordKind[26] = (TK_ERROR);
	
        //
        // Rule 27:  KeyWord ::= E X P A N D
        //
		keywordKind[27] = (TK_EXPAND);
	
        //
        // Rule 28:  KeyWord ::= F O R
        //
		keywordKind[28] = (TK_FOR);
	
        //
        // Rule 29:  KeyWord ::= S E P A R A T O R
        //
		keywordKind[29] = (TK_SEPARATOR);
	
        //
        // Rule 30:  KeyWord ::= A S
        //
		keywordKind[30] = (TK_AS);
	
        //
        // Rule 31:  KeyWord ::= I T E R A T O R
        //
		keywordKind[31] = (TK_ITERATOR);
	
        //
        // Rule 32:  KeyWord ::= F O R E A C H
        //
		keywordKind[32] = (TK_FOREACH);
	
        //
        // Rule 33:  KeyWord ::= E N D F O R E A C H
        //
		keywordKind[33] = (TK_ENDFOREACH);
	
        //
        // Rule 34:  KeyWord ::= F I L E
        //
		keywordKind[34] = (TK_FILE);
	
        //
        // Rule 35:  KeyWord ::= E N D F I L E
        //
		keywordKind[35] = (TK_ENDFILE);
	
        //
        // Rule 36:  KeyWord ::= I F
        //
		keywordKind[36] = (TK_IF);
	
        //
        // Rule 37:  KeyWord ::= E L S E I F
        //
		keywordKind[37] = (TK_ELSEIF);
	
        //
        // Rule 38:  KeyWord ::= E L S E
        //
		keywordKind[38] = (TK_ELSE);
	
        //
        // Rule 39:  KeyWord ::= E N D I F
        //
		keywordKind[39] = (TK_ENDIF);
	
        //
        // Rule 40:  KeyWord ::= L E T
        //
		keywordKind[40] = (TK_LET);
	
        //
        // Rule 41:  KeyWord ::= E N D L E T
        //
		keywordKind[41] = (TK_ENDLET);
	
        //
        // Rule 42:  KeyWord ::= P R O T E C T
        //
		keywordKind[42] = (TK_PROTECT);
	
        //
        // Rule 43:  KeyWord ::= C S T A R T
        //
		keywordKind[43] = (TK_CSTART);
	
        //
        // Rule 44:  KeyWord ::= C E N D
        //
		keywordKind[44] = (TK_CEND);
	
        //
        // Rule 45:  KeyWord ::= I D
        //
		keywordKind[45] = (TK_ID);
	
        //
        // Rule 46:  KeyWord ::= D I S A B L E
        //
		keywordKind[46] = (TK_DISABLE);
	
        //
        // Rule 47:  KeyWord ::= E N D P R O T E C T
        //
		keywordKind[47] = (TK_ENDPROTECT);
	

        for (int i = 0; i < keywordKind.length; i++)
        {
            if (keywordKind[i] == 0)
                keywordKind[i] = identifierKind;
        }
    }
}

@


1.3.6.1
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d1 8
a8 12
/*
 * Copyright (c) 2006, 2008 Borland Software Corporation and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     committers of openArchitectureWare - Xpand language syntax
 *     Artem Tikhomirov (Borland) - LALR grammar
 *                                - Migration to OCL expressions
 */
a11 1

d15 1
a15 1
    private final int keywordKind[] = new int[91 + 1];
d47 1
a47 4
    static
    {
        tokenKind['$'] = Char_DollarSign;

d103 1
a103 2
    final int getKind(char c)
    {
d114 1
a114 265
        // Rule 1:  KeyWord ::= s e l f
        //
		keywordKind[1] = (TK_self);
	  
	
        //
        // Rule 2:  KeyWord ::= i n v
        //
		keywordKind[2] = (TK_inv);
	  
	
        //
        // Rule 3:  KeyWord ::= p r e
        //
		keywordKind[3] = (TK_pre);
	  
	
        //
        // Rule 4:  KeyWord ::= p o s t
        //
		keywordKind[4] = (TK_post);
	  
	
        //
        // Rule 5:  KeyWord ::= b o d y
        //
		keywordKind[5] = (TK_body);
	  
	
        //
        // Rule 6:  KeyWord ::= c o n t e x t
        //
		keywordKind[6] = (TK_context);
	  
	
        //
        // Rule 7:  KeyWord ::= p a c k a g e
        //
		keywordKind[7] = (TK_package);
	  
	
        //
        // Rule 8:  KeyWord ::= e n d p a c k a g e
        //
		keywordKind[8] = (TK_endpackage);
	  
	
        //
        // Rule 9:  KeyWord ::= d e f
        //
		keywordKind[9] = (TK_def);
	  
	
        //
        // Rule 10:  KeyWord ::= d e r i v e
        //
		keywordKind[10] = (TK_derive);
	  
	
        //
        // Rule 11:  KeyWord ::= i n i t
        //
		keywordKind[11] = (TK_init);
	  
	
        //
        // Rule 12:  KeyWord ::= i f
        //
		keywordKind[12] = (TK_if);
	  
	
        //
        // Rule 13:  KeyWord ::= t h e n
        //
		keywordKind[13] = (TK_then);
	  
	
        //
        // Rule 14:  KeyWord ::= e l s e
        //
		keywordKind[14] = (TK_else);
	  
	
        //
        // Rule 15:  KeyWord ::= e n d i f
        //
		keywordKind[15] = (TK_endif);
	  
	
        //
        // Rule 16:  KeyWord ::= a n d
        //
		keywordKind[16] = (TK_and);
	  
	
        //
        // Rule 17:  KeyWord ::= o r
        //
		keywordKind[17] = (TK_or);
	  
	
        //
        // Rule 18:  KeyWord ::= x o r
        //
		keywordKind[18] = (TK_xor);
	  
	
        //
        // Rule 19:  KeyWord ::= n o t
        //
		keywordKind[19] = (TK_not);
	  
	
        //
        // Rule 20:  KeyWord ::= i m p l i e s
        //
		keywordKind[20] = (TK_implies);
	  
	
        //
        // Rule 21:  KeyWord ::= l e t
        //
		keywordKind[21] = (TK_let);
	  
	
        //
        // Rule 22:  KeyWord ::= i n
        //
		keywordKind[22] = (TK_in);
	  
	
        //
        // Rule 23:  KeyWord ::= t r u e
        //
		keywordKind[23] = (TK_true);
	  
	
        //
        // Rule 24:  KeyWord ::= f a l s e
        //
		keywordKind[24] = (TK_false);
	  
	
        //
        // Rule 25:  KeyWord ::= S e t
        //
		keywordKind[25] = (TK_Set);
	  
	
        //
        // Rule 26:  KeyWord ::= B a g
        //
		keywordKind[26] = (TK_Bag);
	  
	
        //
        // Rule 27:  KeyWord ::= S e q u e n c e
        //
		keywordKind[27] = (TK_Sequence);
	  
	
        //
        // Rule 28:  KeyWord ::= C o l l e c t i o n
        //
		keywordKind[28] = (TK_Collection);
	  
	
        //
        // Rule 29:  KeyWord ::= O r d e r e d S e t
        //
		keywordKind[29] = (TK_OrderedSet);
	  
	
        //
        // Rule 30:  KeyWord ::= i t e r a t e
        //
		keywordKind[30] = (TK_iterate);
	  
	
        //
        // Rule 31:  KeyWord ::= f o r A l l
        //
		keywordKind[31] = (TK_forAll);
	  
	
        //
        // Rule 32:  KeyWord ::= e x i s t s
        //
		keywordKind[32] = (TK_exists);
	  
	
        //
        // Rule 33:  KeyWord ::= i s U n i q u e
        //
		keywordKind[33] = (TK_isUnique);
	  
	
        //
        // Rule 34:  KeyWord ::= a n y
        //
		keywordKind[34] = (TK_any);
	  
	
        //
        // Rule 35:  KeyWord ::= o n e
        //
		keywordKind[35] = (TK_one);
	  
	
        //
        // Rule 36:  KeyWord ::= c o l l e c t
        //
		keywordKind[36] = (TK_collect);
	  
	
        //
        // Rule 37:  KeyWord ::= s e l e c t
        //
		keywordKind[37] = (TK_select);
	  
	
        //
        // Rule 38:  KeyWord ::= r e j e c t
        //
		keywordKind[38] = (TK_reject);
	  
	
        //
        // Rule 39:  KeyWord ::= c o l l e c t N e s t e d
        //
		keywordKind[39] = (TK_collectNested);
	  
	
        //
        // Rule 40:  KeyWord ::= s o r t e d B y
        //
		keywordKind[40] = (TK_sortedBy);
	  
	
        //
        // Rule 41:  KeyWord ::= c l o s u r e
        //
		keywordKind[41] = (TK_closure);
	  
	
        //
        // Rule 42:  KeyWord ::= o c l I s K i n d O f
        //
		keywordKind[42] = (TK_oclIsKindOf);
	  
	
        //
        // Rule 43:  KeyWord ::= o c l I s T y p e O f
        //
		keywordKind[43] = (TK_oclIsTypeOf);
	  
	
        //
        // Rule 44:  KeyWord ::= o c l A s T y p e
        //
		keywordKind[44] = (TK_oclAsType);
	  
	
        //
        // Rule 45:  KeyWord ::= o c l I s N e w
d116 1
a116 1
		keywordKind[45] = (TK_oclIsNew);
d120 1
a120 1
        // Rule 46:  KeyWord ::= o c l I s U n d e f i n e d
d122 1
a122 1
		keywordKind[46] = (TK_oclIsUndefined);
d126 1
a126 1
        // Rule 47:  KeyWord ::= o c l I s I n v a l i d
d128 1
a128 1
		keywordKind[47] = (TK_oclIsInvalid);
d132 1
a132 1
        // Rule 48:  KeyWord ::= o c l I s I n S t a t e
d134 1
a134 1
		keywordKind[48] = (TK_oclIsInState);
d138 1
a138 1
        // Rule 49:  KeyWord ::= a l l I n s t a n c e s
d140 1
a140 1
		keywordKind[49] = (TK_allInstances);
d144 1
a144 1
        // Rule 50:  KeyWord ::= S t r i n g
d146 1
a146 1
		keywordKind[50] = (TK_String);
d150 1
a150 1
        // Rule 51:  KeyWord ::= I n t e g e r
d152 1
a152 1
		keywordKind[51] = (TK_Integer);
d156 1
a156 1
        // Rule 52:  KeyWord ::= U n l i m i t e d N a t u r a l
d158 1
a158 1
		keywordKind[52] = (TK_UnlimitedNatural);
d162 1
a162 1
        // Rule 53:  KeyWord ::= R e a l
d164 1
a164 1
		keywordKind[53] = (TK_Real);
d168 1
a168 1
        // Rule 54:  KeyWord ::= B o o l e a n
d170 1
a170 1
		keywordKind[54] = (TK_Boolean);
d174 1
a174 1
        // Rule 55:  KeyWord ::= T u p l e
d176 1
a176 1
		keywordKind[55] = (TK_Tuple);
d180 1
a180 1
        // Rule 56:  KeyWord ::= O c l A n y
d182 1
a182 1
		keywordKind[56] = (TK_OclAny);
d186 1
a186 1
        // Rule 57:  KeyWord ::= O c l V o i d
d188 1
a188 1
		keywordKind[57] = (TK_OclVoid);
d192 1
a192 1
        // Rule 58:  KeyWord ::= I n v a l i d
d194 1
a194 1
		keywordKind[58] = (TK_Invalid);
d198 1
a198 1
        // Rule 59:  KeyWord ::= O c l M e s s a g e
d200 1
a200 1
		keywordKind[59] = (TK_OclMessage);
d204 1
a204 1
        // Rule 60:  KeyWord ::= n u l l
d206 1
a206 1
		keywordKind[60] = (TK_null);
d210 1
a210 1
        // Rule 61:  KeyWord ::= O c l I n v a l i d
d212 1
a212 1
		keywordKind[61] = (TK_OclInvalid);
d216 1
a216 1
        // Rule 62:  KeyWord ::= a t t r
d218 1
a218 1
		keywordKind[62] = (TK_attr);
d222 1
a222 1
        // Rule 63:  KeyWord ::= o p e r
d224 1
a224 1
		keywordKind[63] = (TK_oper);
d228 1
a228 1
        // Rule 64:  KeyWord ::= I M P O R T
d230 1
a230 1
		keywordKind[64] = (TK_IMPORT);
d233 1
a233 1
        // Rule 65:  KeyWord ::= E X T E N S I O N
d235 1
a235 1
		keywordKind[65] = (TK_EXTENSION);
d238 1
a238 1
        // Rule 66:  KeyWord ::= A R O U N D
d240 1
a240 1
		keywordKind[66] = (TK_AROUND);
d243 1
a243 1
        // Rule 67:  KeyWord ::= E N D A R O U N D
d245 1
a245 1
		keywordKind[67] = (TK_ENDAROUND);
d248 1
a248 1
        // Rule 68:  KeyWord ::= D E F I N E
d250 1
a250 1
		keywordKind[68] = (TK_DEFINE);
d253 1
a253 1
        // Rule 69:  KeyWord ::= E N D D E F I N E
d255 1
a255 1
		keywordKind[69] = (TK_ENDDEFINE);
d258 1
a258 1
        // Rule 70:  KeyWord ::= E R R O R
d260 1
a260 1
		keywordKind[70] = (TK_ERROR);
d263 1
a263 1
        // Rule 71:  KeyWord ::= E X P A N D
d265 1
a265 1
		keywordKind[71] = (TK_EXPAND);
d268 1
a268 1
        // Rule 72:  KeyWord ::= F O R
d270 1
a270 1
		keywordKind[72] = (TK_FOR);
d273 1
a273 1
        // Rule 73:  KeyWord ::= S E P A R A T O R
d275 1
a275 1
		keywordKind[73] = (TK_SEPARATOR);
d278 1
a278 1
        // Rule 74:  KeyWord ::= A S
d280 1
a280 1
		keywordKind[74] = (TK_AS);
d283 1
a283 1
        // Rule 75:  KeyWord ::= I T E R A T O R
d285 1
a285 1
		keywordKind[75] = (TK_ITERATOR);
d288 1
a288 1
        // Rule 76:  KeyWord ::= F O R E A C H
d290 1
a290 1
		keywordKind[76] = (TK_FOREACH);
d293 1
a293 1
        // Rule 77:  KeyWord ::= E N D F O R E A C H
d295 1
a295 1
		keywordKind[77] = (TK_ENDFOREACH);
d298 1
a298 1
        // Rule 78:  KeyWord ::= F I L E
d300 1
a300 1
		keywordKind[78] = (TK_FILE);
d303 1
a303 1
        // Rule 79:  KeyWord ::= E N D F I L E
d305 1
a305 1
		keywordKind[79] = (TK_ENDFILE);
d308 1
a308 1
        // Rule 80:  KeyWord ::= I F
d310 1
a310 1
		keywordKind[80] = (TK_IF);
d313 1
a313 1
        // Rule 81:  KeyWord ::= E L S E I F
d315 1
a315 1
		keywordKind[81] = (TK_ELSEIF);
d318 1
a318 1
        // Rule 82:  KeyWord ::= E L S E
d320 1
a320 1
		keywordKind[82] = (TK_ELSE);
d323 1
a323 1
        // Rule 83:  KeyWord ::= E N D I F
d325 1
a325 1
		keywordKind[83] = (TK_ENDIF);
d328 1
a328 1
        // Rule 84:  KeyWord ::= L E T
d330 1
a330 1
		keywordKind[84] = (TK_LET);
d333 1
a333 1
        // Rule 85:  KeyWord ::= E N D L E T
d335 1
a335 1
		keywordKind[85] = (TK_ENDLET);
d338 1
a338 1
        // Rule 86:  KeyWord ::= P R O T E C T
d340 1
a340 1
		keywordKind[86] = (TK_PROTECT);
d343 1
a343 1
        // Rule 87:  KeyWord ::= C S T A R T
d345 1
a345 1
		keywordKind[87] = (TK_CSTART);
d348 1
a348 1
        // Rule 88:  KeyWord ::= C E N D
d350 1
a350 1
		keywordKind[88] = (TK_CEND);
d353 1
a353 1
        // Rule 89:  KeyWord ::= I D
d355 1
a355 1
		keywordKind[89] = (TK_ID);
d358 1
a358 1
        // Rule 90:  KeyWord ::= D I S A B L E
d360 1
a360 1
		keywordKind[90] = (TK_DISABLE);
d363 1
a363 1
        // Rule 91:  KeyWord ::= E N D P R O T E C T
d365 1
a365 1
		keywordKind[91] = (TK_ENDPROTECT);
@


1.2
log
@imports were not processed correctly - fix, test added
updated copyrights
@
text
@d47 1
a47 4
    static
    {
        tokenKind['$'] = Char_DollarSign;

d103 1
a103 2
    final int getKind(char c)
    {
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d2 7
a8 7
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
@

