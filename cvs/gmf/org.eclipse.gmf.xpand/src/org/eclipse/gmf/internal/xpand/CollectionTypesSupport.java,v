head	1.2;
access;
symbols
	v20081022-1925:1.2
	v20081020-0700:1.2
	ocl_qvt:1.2.0.6
	Root_ocl_qvt:1.2
	v20080722-1827:1.2
	v20080718-1731:1.2
	v20080716-1600:1.2
	v20080716-1642:1.2
	R2_1_maintenance:1.2.0.4
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080528-1052:1.2
	v20080516-1143:1.2
	v20080417-1610:1.2
	v20080322-0000:1.2
	v20080222-1200:1.2
	v20071130-1111:1.2
	v20071124-0000:1.2
	v20071108-0000:1.2
	v20071003-0000:1.2
	v20070921-0000:1.2
	v20070903-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	RC3_20:1.2
	v20070608-1300:1.2
	v20070605-1400:1.2
	v20070601-1400:1.2
	v20070518-1300:1.2
	v20070420-1000:1.2
	v20070405-1100:1.1
	v20070403-1500:1.1
	v20070330-1300:1.1
	v20070208-1800:1.1
	v20070103-0300:1.1
	M4_20:1.1
	M3_20:1.1;
locks; strict;
comment	@# @;


1.2
date	2007.04.19.10.00.27;	author atikhomirov;	state Exp;
branches
	1.2.6.1;
next	1.1;
commitid	554a46273dba4567;

1.1
date	2006.10.18.20.33.50;	author atikhomirov;	state Exp;
branches;
next	;

1.2.6.1
date	2008.08.08.18.15.51;	author atikhomirov;	state dead;
branches;
next	;
commitid	51ea489c8d554567;


desc
@@


1.2
log
@0.8.21 - toSet implemented with LinkedHashSet; added List.purgeDups operation to clean dupplicates away from list
@
text
@/*******************************************************************************
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package org.eclipse.gmf.internal.xpand;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EcoreFactory;
import org.eclipse.emf.ecore.EcorePackage;

public class CollectionTypesSupport {

	private final Map<EClassifier, EClass> collectionsM1 = new HashMap<EClassifier, EClass>();  
	private final Map<EClassifier, EClass> listsM1 = new HashMap<EClassifier, EClass>();  
	private final Map<EClassifier, EClass> setsM1 = new HashMap<EClassifier, EClass>();  

	// These are M2 elements, next to EClass and EReferences, extension of ECore
	// meta model
	static final EClass COLLECTION_TYPE = EcoreFactory.eINSTANCE.createEClass();
	static final EClass LIST_TYPE = EcoreFactory.eINSTANCE.createEClass();
	static final EClass SET_TYPE = EcoreFactory.eINSTANCE.createEClass();

	@@SuppressWarnings("unchecked")
	void init(EPackage xecore, EClass parameterizedType) {
		COLLECTION_TYPE.setName("Collection");
		LIST_TYPE.setName("List");
		SET_TYPE.setName("Set");
		COLLECTION_TYPE.getESuperTypes().add(parameterizedType);
		LIST_TYPE.getESuperTypes().add(COLLECTION_TYPE);
		SET_TYPE.getESuperTypes().add(COLLECTION_TYPE);
		xecore.getEClassifiers().add(COLLECTION_TYPE);
		xecore.getEClassifiers().add(LIST_TYPE);
		xecore.getEClassifiers().add(SET_TYPE);

		COLLECTION_OF_OBJECT = newCollectionType(EcorePackage.eINSTANCE.getEJavaObject());
		LIST_OF_OBJECT = newListType(EcorePackage.eINSTANCE.getEJavaObject());
		SET_OF_OBJECT = newSetType(EcorePackage.eINSTANCE.getEJavaObject());
		// XXX why didn't I put LIST_OF_* into collectionsM1, listsM1 and setsM1?
		// treat collections without type, like {}, as collections of 'void' which is assignable to anything  
		collectionsM1.put(null, newCollectionType(BuiltinMetaModel.VOID));
		listsM1.put(null, newListType(BuiltinMetaModel.VOID));
		setsM1.put(null, newSetType(BuiltinMetaModel.VOID));
	}

	
	/**
	 * @@param name
	 * @@return true if name is one of M2 collection meta-types (either Collection, List, Set)
	 */
	public boolean isCollectionMetaType(String name) {
		return COLLECTION_TYPE.getName().equals(name) || LIST_TYPE.getName().equals(name) || SET_TYPE.getName().equals(name);
	}

	public EClass getCollectionType(String metaTypeName, EClassifier innerType) {
		assert isCollectionMetaType(metaTypeName);
		if (LIST_TYPE.getName().equals(metaTypeName)) {
			return getListType(innerType);
		}
		if (SET_TYPE.getName().equals(metaTypeName)) {
			return getSetType(innerType);
		}
		if (COLLECTION_TYPE.getName().equals(metaTypeName)) {
			return getCollectionType(innerType);
		}
		throw new IllegalStateException();
	}

	/*package*/ EClass getCollectionType(EClass metaType, EClassifier innerType) {
		if (LIST_TYPE.equals(metaType)) {
			return getListType(innerType);
		}
		if (SET_TYPE.equals(metaType)) {
			return getSetType(innerType);
		}
		if (COLLECTION_TYPE.equals(metaType)) {
			return getCollectionType(innerType);
		}
		throw new IllegalStateException();
	}


	Collection newInstance(EClassifier m1) {
		if (m1.eClass() == LIST_TYPE) {
			return new LinkedList<Object>();
		}
		if (m1.eClass() == SET_TYPE) {
			return new HashSet<Object>();
		}
		// can't create instance of Collection, right?
		return null;
	}

	public EClass getCollectionType(EClassifier innerType) {
		EClass existing = collectionsM1.get(innerType);
		if (existing == null) {
			existing = newCollectionType(innerType);
			collectionsM1.put(innerType, existing);
		}
		return existing;
	}

	public EClass getListType(EClassifier innerType) {
		EClass existing = listsM1.get(innerType);
		if (existing == null) {
			existing = newListType(innerType);
			listsM1.put(innerType, existing);
		}
		return existing;
	}

	public EClass getSetType(EClassifier innerType) {
		EClass existing = setsM1.get(innerType);
		if (existing == null) {
			existing = newSetType(innerType);
			setsM1.put(innerType, existing);
		}
		return existing;
	}

	// way to implicitly extend user's model with typed lists
	@@SuppressWarnings("unchecked")
	private static EClass newCollectionType(EClassifier innerType) {
		EClass c = BuiltinMetaModel.internalNewParameterizedType(COLLECTION_TYPE, innerType);
		// @@see CollectionTypeImpl.getSuperTypes
		c.getESuperTypes().add(EcorePackage.eINSTANCE.getEObject());
		return c;
	}

	@@SuppressWarnings("unchecked")
	private static EClass newListType(EClassifier innerType) {
		EClass c = BuiltinMetaModel.internalNewParameterizedType(LIST_TYPE, innerType);
		// @@see ListTypeImpl.getSuperTypes
		c.getESuperTypes().add(COLLECTION_OF_OBJECT); // XXX perhaps, collection(inner) may be required
		return c;
	}

	@@SuppressWarnings("unchecked")
	private static EClass newSetType(EClassifier innerType) {
		EClass c = BuiltinMetaModel.internalNewParameterizedType(SET_TYPE, innerType);
		// @@see SetTypeImpl.getSuperTypes
		c.getESuperTypes().add(COLLECTION_OF_OBJECT); // XXX perhaps, collection(inner) may be required
		return c;
	}

	/*
	 * 1. Actually, [List|Set]TypeImpl extend Collection(innerType), but I guess
	 * it's an overkill
	 * 
	 * 2. Instead of analyze's code (working with M1) EClassifier targetType =
	 * XEClass "OrderList"
	 * isAssignableFrom(BuiltinMetaModel.COLLECTION_OF_OBJECT, targetType) and
	 * having all these hierarchies of list|set extending collection (above)
	 * would be better to check
	 * COLLECTION_TYPE.isSuperClassOf("OrderCollection".eClass)
	 */

	// These are M1 elements, next to user's "Purchase" and "Order" classes,
	// user's model
	// during analyze, we have EClasses from same meta-level
	// and during evaluate, we work with instances of these
	static EClass COLLECTION_OF_OBJECT;
	static EClass LIST_OF_OBJECT;
	static EClass SET_OF_OBJECT;
}
@


1.2.6.1
log
@[243154] Use OCL instead of home-grown expression language - AOP tests fixed, though with sort of hack to pass proceed() java method implementation to OCL
@
text
@@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d50 1
@

