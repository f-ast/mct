head	1.6;
access;
symbols
	v20081022-1925:1.6
	v20081020-0700:1.6
	ocl_qvt:1.6.0.4
	Root_ocl_qvt:1.6
	v20080722-1827:1.6
	v20080718-1731:1.6
	v20080716-1600:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.6.0.2
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080528-1052:1.6
	v20080516-1143:1.6
	v20080417-1610:1.6
	v20080322-0000:1.6
	v20080222-1200:1.5
	v20071130-1111:1.5
	v20071124-0000:1.5
	v20071108-0000:1.5
	v20071003-0000:1.5
	v20070921-0000:1.5
	v20070903-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	RC3_20:1.5
	v20070608-1300:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070518-1300:1.5
	v20070420-1000:1.5
	v20070405-1100:1.5
	v20070403-1500:1.5
	v20070330-1300:1.5
	v20070208-1800:1.5
	v20070103-0300:1.5
	M4_20:1.5
	M3_20:1.5;
locks; strict;
comment	@# @;


1.6
date	2008.02.22.16.03.40;	author atikhomirov;	state Exp;
branches
	1.6.4.1;
next	1.5;
commitid	3d8447bef25b4567;

1.5
date	2006.11.08.19.08.32;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.08.14.45.16;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.25.17.23.40;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.23.21.10.46;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.51;	author atikhomirov;	state Exp;
branches;
next	;

1.6.4.1
date	2008.08.12.11.17.21;	author atikhomirov;	state Exp;
branches;
next	;
commitid	119348a1713f4567;


desc
@@


1.6
log
@restored behaviour to populate problems view on parsing error instead of plain parser exception logging.
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *     Artem Tikhomirov - LPG lexer/parser and error reporting
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.util;

import java.io.IOException;
import java.io.Reader;

import org.eclipse.gmf.internal.xpand.ast.Template;
import org.eclipse.gmf.internal.xpand.model.XpandResource;
import org.eclipse.gmf.internal.xpand.parser.XpandLexer;
import org.eclipse.gmf.internal.xpand.parser.XpandParser;
import org.eclipse.gmf.internal.xpand.util.ParserException.ErrorLocationInfo;

public class XpandResourceParser {

	// XXX everything except exact lexer and parser instances are the same as n XtendResourceParser
	public XpandResource parse(final Reader source, final String qualifiedTemplateName) throws IOException, ParserException {
		Template tpl = null;
		XpandParser parser = null;
		XpandLexer scanner = null;
		final char[] buffer = new StreamConverter().toCharArray(source);
		try {
			scanner = new XpandLexer(buffer, qualifiedTemplateName);
			parser = new XpandParser(scanner);
			scanner.lexer(parser);
			tpl = parser.parser();
			// FIXME handle errors if find out how to force generated parser to throw exception instead of consuming it
		} catch (final Exception e) {
			ErrorLocationInfo[] errors = extractErrors(scanner, parser);
        	if (errors.length == 0) {
        		throw new IOException("Unexpected exception while parsing");
        	} else {
        		throw new ParserException(qualifiedTemplateName, errors);
        	}
		}
		if (tpl != null) {
			// XXX two choices here - 
			// (1) pass any name into parse method, do not assume it's fqn and move setFQN outside of this method
			// (2) assume fqn is passed into parse() as it's now.
			tpl.setFullyQualifiedName(qualifiedTemplateName);
			return tpl;
		}
		ErrorLocationInfo[] errors = extractErrors(scanner, parser);
		assert errors.length > 0 : "otherwise, no reason not to get template";
		throw new ParserException(qualifiedTemplateName, errors);
	}

	// FIXME do it in the parser itself, though keeping errors separate may help
	// those willing to report them separately
	private static ErrorLocationInfo[] extractErrors(XpandLexer scanner, XpandParser parser) {
		ErrorLocationInfo[] e1 = scanner.getErrors();
		ErrorLocationInfo[] e2 = parser.getErrors();
		ErrorLocationInfo[] res = new ErrorLocationInfo[e1.length + e2.length];
		System.arraycopy(e1, 0, res, 0, e1.length);
		System.arraycopy(e2, 0, res, e1.length, e2.length);
		return res;
	}
}
@


1.6.4.1
log
@[243154] Use OCL instead of home-grown expression language - support old syntax for DEFINE
@
text
@d44 1
a44 1
        		throw new IOException("Unexpected exception while parsing:" + e.toString());
@


1.5
log
@combine errors reported separately from lexer and parser
@
text
@d4 1
a4 1
 * Copyright (c) 2005-2006 Sven Efftinge and others.
d46 1
a46 1
        		throw new ParserException(errors);
d58 1
a58 1
		throw new ParserException(errors);
@


1.4
log
@error handling
@
text
@d25 1
d42 1
a42 1
			ParserException.ErrorLocationInfo[] errors = scanner.getErrors();
d56 1
a56 1
		ParserException.ErrorLocationInfo[] errors = scanner.getErrors();
d61 10
@


1.3
log
@refactored resource manager into capable working in workspace and working with uris, added experimental extended error reporting to provide more details on parsing errors
@
text
@a19 1
import java.util.ArrayList;
a32 1
		final ArrayList<ParserException.ErrorLocationInfo> errors = new ArrayList<ParserException.ErrorLocationInfo>();
d35 1
a35 8
			scanner = new XpandLexer(buffer, qualifiedTemplateName) {
        		// FIXME move to XpandLexer.g template
            	@@Override
            	public void reportError(int left_loc, int right_loc) {
                    errors.add(XtendResourceParser.createError(this, left_loc, right_loc));
            		super.reportError(left_loc, right_loc);
            	}
			};
d41 2
a42 1
        	if (errors.isEmpty()) {
d55 3
a57 1
		return null;
@


1.2
log
@markers refactored not to parse file when there's information about line number already available
@
text
@d12 1
d19 2
a20 1
import java.io.UnsupportedEncodingException;
a21 3
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.gmf.internal.xpand.Activator;
d29 2
a30 1
	public XpandResource parse(final IFile file) {
d34 2
a35 1
		char[] buffer;
d37 8
a44 14
			StreamConverter sc = new StreamConverter();
			buffer = sc.toCharArray(file);
		} catch (final CoreException ex) {
			Activator.log(ex.getStatus());
			return null;
		} catch (UnsupportedEncodingException ex) {
			Activator.logError(ex);
			return null;
		} catch (IOException ex) {
			Activator.logError(ex);
			return null;
		}
		try {
			scanner = new XpandLexer(buffer, file.getName());
d48 1
a48 12
			// FIXME handle errors
//		} catch (final MismatchedTokenException e) {
//			final Token t = e.token;
//			final int offSet = t.getColumn() - 1;
//			OawMarkerManager.deleteMarkers(file);
//			OawMarkerManager.addErrorMarker(file, e.getMessage(), IMarker.SEVERITY_ERROR, offSet, offSet + t.getText().length());
//		} catch (final NoViableAltException e) {
//			final Token t = e.token;
//			final int offSet = t.getColumn() - 1;
//			final int length = t.getText() == null ? offSet : offSet + t.getText().length();
//			OawMarkerManager.deleteMarkers(file);
//			OawMarkerManager.addErrorMarker(file, e.getMessage(), IMarker.SEVERITY_ERROR, offSet, length);
d50 5
a54 4
			final int start = scanner.getStreamIndex() - 1;
			final int end = start + 1;
			OawMarkerManager.deleteMarkers(file);
			OawMarkerManager.addErrorMarker(file, e.getMessage(), start, end);
d57 4
a60 1
			tpl.setFullyQualifiedName(Activator.getQualifiedName(file));
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@a20 1
import org.eclipse.core.resources.IMarker;
d69 1
a69 1
			OawMarkerManager.addErrorMarker(file, e.getMessage(), IMarker.SEVERITY_ERROR, start, end);
@

