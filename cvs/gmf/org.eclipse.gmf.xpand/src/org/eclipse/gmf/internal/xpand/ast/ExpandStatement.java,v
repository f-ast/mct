head	1.6;
access;
symbols
	v20081022-1925:1.6
	v20081020-0700:1.6
	ocl_qvt:1.6.0.6
	Root_ocl_qvt:1.6
	v20080722-1827:1.6
	v20080718-1731:1.6
	v20080716-1600:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.6.0.4
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080528-1052:1.6
	v20080516-1143:1.6
	v20080417-1610:1.6
	v20080322-0000:1.6
	v20080222-1200:1.6
	v20071130-1111:1.6
	v20071124-0000:1.6
	v20071108-0000:1.6
	v20071003-0000:1.6
	v20070921-0000:1.6
	v20070903-0000:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	RC3_20:1.6
	v20070608-1300:1.6
	v20070605-1400:1.6
	v20070601-1400:1.6
	v20070518-1300:1.6
	v20070420-1000:1.6
	v20070405-1100:1.6
	v20070403-1500:1.6
	v20070330-1300:1.6
	v20070208-1800:1.6
	v20070103-0300:1.4
	M4_20:1.4
	M3_20:1.4;
locks; strict;
comment	@# @;


1.6
date	2007.01.19.18.23.55;	author atikhomirov;	state Exp;
branches
	1.6.6.1;
next	1.5;
commitid	53ce45b10cbb4567;

1.5
date	2007.01.15.13.05.47;	author dstadnik;	state Exp;
branches;
next	1.4;
commitid	3ad445ab7c2a4567;

1.4
date	2006.11.09.18.00.11;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.23.21.10.02;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.23.18.58.22;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.50;	author atikhomirov;	state Exp;
branches;
next	;

1.6.6.1
date	2008.08.05.12.49.25;	author atikhomirov;	state Exp;
branches;
next	1.6.6.2;
commitid	546c48984c4a4567;

1.6.6.2
date	2008.08.06.14.05.35;	author atikhomirov;	state Exp;
branches;
next	1.6.6.3;
commitid	35b4899afa74567;

1.6.6.3
date	2008.08.07.23.23.37;	author atikhomirov;	state Exp;
branches;
next	1.6.6.4;
commitid	55a7489b83f64567;

1.6.6.4
date	2008.08.08.16.32.18;	author atikhomirov;	state Exp;
branches;
next	1.6.6.5;
commitid	9a2489c75114567;

1.6.6.5
date	2008.08.19.17.25.21;	author atikhomirov;	state Exp;
branches;
next	;
commitid	380048ab02014567;


desc
@@


1.6
log
@assert just in case
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2006 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.ast;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.EvaluationException;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContext;
import org.eclipse.gmf.internal.xpand.expression.Variable;
import org.eclipse.gmf.internal.xpand.expression.ast.Expression;
import org.eclipse.gmf.internal.xpand.expression.ast.Identifier;
import org.eclipse.gmf.internal.xpand.model.XpandDefinition;
import org.eclipse.gmf.internal.xpand.model.XpandExecutionContext;

/**
 * @@author Sven Efftinge
 */
public class ExpandStatement extends Statement {

    private final boolean foreach;

    private final Expression[] parameters;

    private final Expression separator;

    private final Expression target;

    private final Identifier definition;

    public ExpandStatement(final int start, final int end, final int line, final Identifier definition,
            final Expression target, final Expression separator, final Expression[] parameters, final boolean foreach) {
        super(start, end, line);
        this.definition = definition;
        this.target = target;
        this.separator = separator;
        this.parameters = parameters != null ? parameters : new Expression[0];
        this.foreach = foreach;
    }

    public Identifier getDefinition() {
        return definition;
    }

    public boolean isForeach() {
        return foreach;
    }

    public Expression[] getParameters() {
        return parameters;
    }

    public Expression getSeparator() {
        return separator;
    }

    public Expression getTarget() {
        return target;
    }

    public void analyze(final XpandExecutionContext ctx, final Set<AnalysationIssue> issues) {
        final EClassifier[] paramTypes = new EClassifier[getParameters().length];
        for (int i = 0; i < getParameters().length; i++) {
            paramTypes[i] = getParameters()[i].analyze(ctx, issues);

        }
        EClassifier targetType = null;
        if (isForeach()) {
            targetType = target.analyze(ctx, issues);
            if (BuiltinMetaModel.isCollectionType(targetType)) {
            	// XXX [artem] though COLLECTION TYPE *is* ParameterizedType, perhaps
            	// reason to check for instanceof ParameterizedType here
            	// is to avoid cases when targetType is VOID
            	assert BuiltinMetaModel.isParameterizedType(targetType) : "Just curious (is it ever == false): ";
                if (BuiltinMetaModel.isParameterizedType(targetType)) {
                    targetType = BuiltinMetaModel.getInnerType(targetType);
                } else {
                    targetType = EcorePackage.eINSTANCE.getEJavaObject();
                }
            } else {
                issues.add(new AnalysationIssue(AnalysationIssue.Type.INCOMPATIBLE_TYPES, "Collection type expected!", target));
                return;
            }
        } else {
            final Variable var = ctx.getVariable(ExecutionContext.IMPLICIT_VARIABLE);
            if (var == null) {
                issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR,
                        "No implicite variable 'this' could be found!", target));
                return;
            }
            targetType = (EClassifier) var.getValue();
            if (target != null) {
                targetType = target.analyze(ctx, issues);
            }
        }
        if ((targetType == null) || Arrays.asList(paramTypes).contains(null)) {
			return;
		}
        final XpandDefinition def = ctx.findDefinition(getDefinition().getValue(), targetType, paramTypes);
        if (def == null) {
            issues.add(new AnalysationIssue(AnalysationIssue.Type.DEFINITION_NOT_FOUND,
                    "Couldn't find definition " + getDefinition().getValue() + getParamTypeString(paramTypes)
                            + " for type " + targetType.getName(), this));
        }
    }

    @@Override
    public void evaluateInternal(final XpandExecutionContext ctx) {
        final Object[] params = new Object[getParameters().length];
        for (int i = 0; i < getParameters().length; i++) {
            params[i] = getParameters()[i].evaluate(ctx);
        }
        final EClassifier[] paramTypes = new EClassifier[params.length];
        for (int i = 0; i < params.length; i++) {
            paramTypes[i] = BuiltinMetaModel.getType(params[i]);
        }
        final String defName = getDefinition().getValue();
        final String sep = (String) (separator != null ? separator.evaluate(ctx) : null);
        Object targetObject = null;
        if (isForeach()) {
            targetObject = target.evaluate(ctx);
            if (!(targetObject instanceof Collection)) {
				throw new EvaluationException("Collection expected!", target);
			}

            final Collection<?> col = (Collection<?>) targetObject;
            for (final Iterator<?> iter = col.iterator(); iter.hasNext();) {
                final Object targetObj = iter.next();
                invokeDefinition(defName, targetObj, params, paramTypes, ctx);
                if ((sep != null) && iter.hasNext()) {
                    ctx.getOutput().write(sep);
                }
            }

        } else {
            if (target != null) {
                targetObject = target.evaluate(ctx);
            } else {
                final Variable var = ctx.getVariable(ExecutionContext.IMPLICIT_VARIABLE);
                targetObject = var.getValue();
            }
            if (targetObject != null) {
            	invokeDefinition(defName, targetObject, params, paramTypes, ctx);
            } else {
            	// XXX logInfo that feature value is null or conditionally fail?
            	// perhaps, could check if target is feature and multiplicity of the feature is at least 1 and fail then?
            	// though all these checks are not template's tasks
            }
        }
    }

    private void invokeDefinition(final String defName, final Object targetObj, final Object[] params,
            final EClassifier[] paramTypes, XpandExecutionContext ctx) {
        final EClassifier t = BuiltinMetaModel.getType(targetObj);
        final XpandDefinition def = ctx.findDefinition(defName, t, paramTypes);
        if (def == null) {
			throw new EvaluationException("No Definition '" + defName + getParamTypeString(paramTypes) + " for "
                    + t.getName() + "' found!", this);
		}

        // register variables
        ctx = ctx.cloneWithoutVariables();
        ctx = ctx.cloneWithVariable(new Variable(ExecutionContext.IMPLICIT_VARIABLE, targetObj));
        for (int i = 0; i < def.getParams().length; i++) {
            final String name = def.getParams()[i].getName().getValue();
            final Object val = params[i];
            ctx = ctx.cloneWithVariable(new Variable(name, val));
        }
        if (def.getOwner() != null) {
            ctx = ctx.cloneWithResource(def.getOwner());
        }
        def.evaluate(ctx);

    }

    private String getParamTypeString(final EClassifier[] paramTypes) {
        if (paramTypes.length == 0) {
			return "";
		}
        final StringBuffer buff = new StringBuffer("(");
        for (int i = 0; i < paramTypes.length; i++) {
            final EClassifier type = paramTypes[i];
            buff.append(type.getName());
            if (i + 1 < paramTypes.length) {
                buff.append(", ");
            }
        }
        return buff.append(")").toString();
    }

    private String getParamString(final Expression[] paramTypes) {
        if (paramTypes.length == 0) {
			return "";
		}
        final StringBuffer buff = new StringBuffer("(");
        for (int i = 0; i < paramTypes.length; i++) {
            final Expression type = paramTypes[i];
            buff.append(type);
            if (i + 1 < paramTypes.length) {
                buff.append(", ");
            }
        }
        return buff.append(")").toString();
    }

    @@Override
    public String toString() {
        return "EXPAND " + definition + getParamString(getParameters())
                + (target != null ? (isForeach() ? " FOREACH " : " FOR ") + target : "")
                + (separator != null ? " SEPARATOR " + separator : "");
    }

}
@


1.6.6.1
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
a13 1
 *     Artem Tikhomirov (Borland) - Migration to OCL expressions
d29 2
a32 4
import org.eclipse.gmf.internal.xpand.ocl.ExpressionHelper;
import org.eclipse.gmf.internal.xpand.ocl.TypeHelper;
import org.eclipse.ocl.cst.OCLExpressionCS;
import org.eclipse.ocl.cst.PathNameCS;
d39 1
a39 1
    private final boolean isForeach;
d41 1
a41 1
    private final ExpressionHelper[] parameters;
d43 1
a43 1
    private final ExpressionHelper separator;
d45 1
a45 1
    private final ExpressionHelper target;
d47 1
a47 1
    private final String definition;
d49 2
a50 2
    public ExpandStatement(final int start, final int end, final int line, final PathNameCS definition,
            final OCLExpressionCS target, final OCLExpressionCS separator, final OCLExpressionCS[] parameters, final boolean foreach) {
d52 25
a76 12
        this.definition = TypeHelper.toString(definition);
        this.target = new ExpressionHelper(target);
        this.separator = new ExpressionHelper(separator);
        if (parameters == null) {
        	this.parameters = new ExpressionHelper[0];
        } else {
        	this.parameters = new ExpressionHelper[parameters.length];
        	for (int i = 0; i < parameters.length; i++) {
        		this.parameters[i] = new ExpressionHelper(parameters[i]);
        	}
        }
        this.isForeach = foreach;
d80 3
a82 3
        final EClassifier[] paramTypes = new EClassifier[parameters.length];
        for (int i = 0; i < parameters.length; i++) {
            paramTypes[i] = parameters[i].analyze(ctx, issues);
d86 1
a86 1
        if (isForeach) {
d105 2
a106 1
                issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR, "No implicite variable 'this' could be found!", target));
d117 1
a117 1
        final XpandDefinition def = ctx.findDefinition(definition, targetType, paramTypes);
d120 1
a120 1
                    "Couldn't find definition " + definition + getParamTypeString(paramTypes)
d127 3
a129 3
        final Object[] params = new Object[parameters.length];
        for (int i = 0; i < parameters.length; i++) {
            params[i] = parameters[i].evaluate(ctx);
d133 1
a133 1
            paramTypes[i] = BuiltinMetaModel.getType(ctx, params[i]);
d135 1
d138 1
a138 1
        if (isForeach) {
d141 1
a141 1
				throw new EvaluationException("Collection expected!", this, target.getCST());
d147 1
a147 1
                invokeDefinition(definition, targetObj, params, paramTypes, ctx);
d161 1
a161 1
            	invokeDefinition(definition, targetObject, params, paramTypes, ctx);
d172 1
a172 1
        final EClassifier t = BuiltinMetaModel.getType(ctx, targetObj);
a177 1
        assert def.getParams().length == params.length;
a180 2
        // guess, it's important to keet implicit variable in a separate context
        // to allow arguments with the same name.
a181 1
        Variable[] vars = new Variable[params.length];
d183 1
a183 1
            final String name = def.getParams()[i].getVarName();
d185 1
a185 1
            vars[i] = new Variable(name, val);
a186 1
        ctx = ctx.cloneWithVariable(vars);
d209 2
a210 2
    private String getParamString() {
        if (parameters.length == 0) {
d214 4
a217 3
        for (int i = 0; i < parameters.length; i++) {
            buff.append(parameters[i]);
            if (i + 1 < parameters.length) {
d226 2
a227 2
        return "EXPAND " + definition + getParamString()
                + (target != null ? (isForeach ? " FOREACH " : " FOR ") + target : "")
@


1.6.6.2
log
@[243154] Use OCL instead of home-grown expression language. Refactored to eliminate context specific to expressions (moving towards using OCL environment for that), split modifiable (context-specific) and static execution data.
@
text
@d22 4
a25 4
import org.eclipse.gmf.internal.xpand.XpandFacade;
import org.eclipse.gmf.internal.xpand.model.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.model.EvaluationException;
import org.eclipse.gmf.internal.xpand.model.Variable;
d27 1
a27 1
import org.eclipse.gmf.internal.xpand.model.ExecutionContext;
d65 1
a65 1
    public void analyze(final ExecutionContext ctx, final Set<AnalysationIssue> issues) {
d111 1
a111 1
    public void evaluateInternal(final ExecutionContext ctx) {
d116 4
a121 1
        XpandFacade xpandFacade = new XpandFacade(ctx.getScope(), ctx);
d130 2
a131 1
                xpandFacade.evaluate(definition, iter.next(), params);
d133 1
a133 1
                    ctx.getScope().getOutput().write(sep);
d145 1
a145 1
                xpandFacade.evaluate(definition, targetObject, params);
d154 29
@


1.6.6.3
log
@[243154] Use OCL instead of home-grown expression language - fixing and running tests.
@
text
@d52 2
a53 2
        this.target = target == null ? null : new ExpressionHelper(target);
        this.separator = separator == null ? null : new ExpressionHelper(separator);
d118 1
a118 1
        XpandFacade xpandFacade = new XpandFacade(ctx);
@


1.6.6.4
log
@[243154] Use OCL instead of home-grown expression language - use appropriate way to tell if type is collection or not
@
text
@d20 2
a24 1
import org.eclipse.gmf.internal.xpand.model.ExecutionContext;
d27 1
a31 1
import org.eclipse.ocl.ecore.CollectionType;
d74 10
a83 2
            if (targetType instanceof CollectionType) {
                targetType = ((CollectionType) targetType).getElementType();
@


1.6.6.5
log
@[243154] Use OCL instead of home-grown expression language - moving towards no explicit use of 'this' keyword
@
text
@d80 1
a80 1
            final Variable var = ctx.getImplicitVariable();
d82 1
a82 1
                issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR, "No implicite variable 'this/self' could be found!", target));
d128 1
a128 1
                final Variable var = ctx.getImplicitVariable();
@


1.5
log
@do not pollute console
@
text
@d92 1
a92 1
            	//System.err.println("Just curious (is it ever == false): " + BuiltinMetaModel.isParameterizedType(targetType));
@


1.4
log
@issue's type converted to enum, added decreased (warning) severity option toease development with xpand
@
text
@d92 1
a92 1
            	System.err.println("Just curious (is it ever == false): " + BuiltinMetaModel.isParameterizedType(targetType));
@


1.3
log
@do not fool around with EXPAND FOREACH referenceZeroOrOne.nonNull, just treat null value as 'no need to invoke template'
@
text
@d99 1
a99 1
                issues.add(new AnalysationIssue(AnalysationIssue.INCOMPATIBLE_TYPES, "Collection type expected!", target));
d105 1
a105 1
                issues.add(new AnalysationIssue(AnalysationIssue.INTERNAL_ERROR,
d119 1
a119 1
            issues.add(new AnalysationIssue(new AnalysationIssue.Type("Definition not found"),
@


1.2
log
@finals
@
text
@d160 7
a166 1
            invokeDefinition(defName, targetObject, params, paramTypes, ctx);
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d35 1
a35 3
 * *
 * 
 * @@author Sven Efftinge *
d39 1
a39 1
    private boolean foreach = false;
d41 1
a41 1
    private Expression[] parameters = new Expression[0];
d43 1
a43 1
    private Expression separator = null;
d45 1
a45 1
    private Expression target = null;
d47 1
a47 1
    private Identifier definition;
@

