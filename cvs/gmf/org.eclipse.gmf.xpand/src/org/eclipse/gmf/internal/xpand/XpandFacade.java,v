head	1.3;
access;
symbols
	v20081022-1925:1.3
	v20081020-0700:1.3
	ocl_qvt:1.3.0.6
	Root_ocl_qvt:1.3
	v20080722-1827:1.3
	v20080718-1731:1.3
	v20080716-1600:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.4
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080528-1052:1.3
	v20080516-1143:1.3
	v20080417-1610:1.3
	v20080322-0000:1.3
	v20080222-1200:1.3
	v20071130-1111:1.3
	v20071124-0000:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070921-0000:1.3
	v20070903-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	RC3_20:1.3
	v20070608-1300:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070518-1300:1.3
	v20070420-1000:1.3
	v20070405-1100:1.3
	v20070403-1500:1.3
	v20070330-1300:1.3
	v20070208-1800:1.3
	v20070103-0300:1.3
	M4_20:1.3
	M3_20:1.3;
locks; strict;
comment	@# @;


1.3
date	2006.10.23.18.39.37;	author atikhomirov;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2006.10.23.16.13.10;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.50;	author atikhomirov;	state Exp;
branches;
next	;

1.3.6.1
date	2008.08.05.12.49.24;	author atikhomirov;	state Exp;
branches;
next	1.3.6.2;
commitid	546c48984c4a4567;

1.3.6.2
date	2008.08.06.14.05.35;	author atikhomirov;	state Exp;
branches;
next	1.3.6.3;
commitid	35b4899afa74567;

1.3.6.3
date	2008.08.07.23.23.37;	author atikhomirov;	state Exp;
branches;
next	1.3.6.4;
commitid	55a7489b83f64567;

1.3.6.4
date	2008.08.08.16.33.25;	author atikhomirov;	state Exp;
branches;
next	1.3.6.5;
commitid	a21489c75534567;

1.3.6.5
date	2008.08.10.15.10.44;	author atikhomirov;	state Exp;
branches;
next	;
commitid	2d13489f04f14567;


desc
@@


1.3
log
@unmodifiable model, and refactored Identifiers as the only place that required ast to be modified
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2006 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.EvaluationException;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContext;
import org.eclipse.gmf.internal.xpand.expression.Variable;
import org.eclipse.gmf.internal.xpand.model.XpandDefinition;
import org.eclipse.gmf.internal.xpand.model.XpandExecutionContext;
import org.eclipse.gmf.internal.xpand.model.XpandResource;

/**
 * @@author Sven Efftinge
 */
public class XpandFacade {
    private XpandExecutionContext ctx = null;

    public XpandFacade(final XpandExecutionContext ctx) {
        this.ctx = ctx;
    }

    public void evaluate(final String definitionName, final Object targetObject, Object[] params) {
        params = params == null ? new Object[0] : params;
        final EClassifier targetType = BuiltinMetaModel.getType(targetObject);
        final EClassifier[] paramTypes = new EClassifier[params.length];
        for (int i = 0; i < paramTypes.length; i++) {
            paramTypes[i] = BuiltinMetaModel.getType(params[i]);
        }

        final XpandDefinition def = ctx.findDefinition(definitionName, targetType, paramTypes);
        if (def == null)
            throw new EvaluationException("No Definition " + definitionName + getParamString(paramTypes) + " for "
                    + targetType.getName() + " could be found!", null);

        ArrayList<Variable> vars = new ArrayList<Variable>(params.length + 1);
        vars.add(new Variable(ExecutionContext.IMPLICIT_VARIABLE, targetObject));
        for (int i = 0; i < params.length; i++) {
            vars.add(new Variable(def.getParams()[i].getName().getValue(), params[i]));
        }
        ctx = ctx.cloneWithVariable(vars);
        ctx = ctx.cloneWithResource(def.getOwner());
        def.evaluate(ctx);
    }

    private String getParamString(final EClassifier[] paramTypes) {
        if (paramTypes.length == 0)
            return "";
        final StringBuffer buff = new StringBuffer("(");
        for (int i = 0; i < paramTypes.length; i++) {
            final EClassifier t = paramTypes[i];
            buff.append(t.getName());
            if (i + 1 < paramTypes.length) {
                buff.append(",");
            }
        }
        buff.append(")");
        return buff.toString();
    }

    public AnalysationIssue[] analyze(final String templateName) {
        final Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
        final XpandResource tpl = ctx.findTemplate(templateName);
        tpl.analyze(ctx, issues);
        return issues.toArray(new AnalysationIssue[issues.size()]);
    }
}
@


1.3.6.1
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
a13 1
 *     Artem Tikhomirov (Borland) - Migration to OCL expressions
d17 1
d42 1
a42 1
        final EClassifier targetType = BuiltinMetaModel.getType(ctx, targetObject);
d45 1
a45 1
            paramTypes[i] = BuiltinMetaModel.getType(ctx, params[i]);
d49 1
a49 1
        if (def == null) {
a51 1
        }
d53 2
a54 3
        ctx = ctx.cloneWithResource(def.getOwner());
        Variable[] vars = new Variable[params.length + 1];
        vars[0] = new Variable(ExecutionContext.IMPLICIT_VARIABLE, targetObject);
d56 1
a56 1
            vars[1+i] = new Variable(def.getParams()[i].getVarName(), params[i]);
d59 1
@


1.3.6.2
log
@[243154] Use OCL instead of home-grown expression language. Refactored to eliminate context specific to expressions (moving towards using OCL environment for that), split modifiable (context-specific) and static execution data.
@
text
@a13 1
import java.util.ArrayList;
d18 4
a21 5
import org.eclipse.gmf.internal.xpand.model.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.model.EvaluationException;
import org.eclipse.gmf.internal.xpand.model.ExecutionContextImpl;
import org.eclipse.gmf.internal.xpand.model.Scope;
import org.eclipse.gmf.internal.xpand.model.Variable;
d23 1
a23 1
import org.eclipse.gmf.internal.xpand.model.ExecutionContext;
d30 1
a30 2
	private final Scope scope;
	private ExecutionContext ctx;
d32 49
a80 63
	public XpandFacade(Scope scope) {
		this(scope, null);
	}

	public XpandFacade(Scope scope, ExecutionContext ctx) {
		assert scope != null;
		this.scope = scope;
		this.ctx = ctx;
	}

	public void evaluate(final String definitionName, final Object targetObject, Object[] params) {
		params = params == null ? new Object[0] : params;
		final EClassifier targetType = BuiltinMetaModel.getType(targetObject);
		final EClassifier[] paramTypes = new EClassifier[params.length];
		for (int i = 0; i < paramTypes.length; i++) {
			paramTypes[i] = BuiltinMetaModel.getType(params[i]);
		}

		final XpandDefinition def = getContext().findDefinition(definitionName, targetType, paramTypes);
		if (def == null) {
			throw new EvaluationException("No Definition " + definitionName + getParamString(paramTypes) + " for " + targetType.getName() + " could be found!", null);
		}

		ArrayList<Variable> vars = new ArrayList<Variable>(params.length + 1);
		vars.add(new Variable(ExecutionContext.IMPLICIT_VARIABLE, targetObject));
		for (int i = 0; i < params.length; i++) {
			vars.add(new Variable(def.getParams()[i].getVarName(), params[i]));
		}
		ExecutionContextImpl ctx = new ExecutionContextImpl(scope, def.getOwner(), vars);
		def.evaluate(ctx);
	}

	// FIXME Actually, we don't need the whole context, just currentResource(),
	// but that would be another story to fix.
	private ExecutionContext getContext() {
		if (ctx == null) {
			ctx = new ExecutionContextImpl(scope);
		}
		return ctx;
	}

	private String getParamString(final EClassifier[] paramTypes) {
		if (paramTypes.length == 0) {
			return "";
		}
		final StringBuilder buff = new StringBuilder("(");
		for (int i = 0; i < paramTypes.length; i++) {
			final EClassifier t = paramTypes[i];
			buff.append(t.getName());
			if (i + 1 < paramTypes.length) {
				buff.append(",");
			}
		}
		buff.append(")");
		return buff.toString();
	}

	public AnalysationIssue[] analyze(final String templateName) {
		final Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
		final XpandResource tpl = scope.findTemplate(templateName);
		tpl.analyze(new ExecutionContextImpl(scope, tpl, null), issues);
		return issues.toArray(new AnalysationIssue[issues.size()]);
	}
@


1.3.6.3
log
@[243154] Use OCL instead of home-grown expression language - fixing and running tests.
@
text
@d36 4
a41 4
	}

	public XpandFacade(ExecutionContext ctx) {
		this(ctx.getScope());
@


1.3.6.4
log
@[243154] Use OCL instead of home-grown expression language - populate ocl environment with variable types (hence, need to tell var value from var type)
@
text
@d59 1
a59 1
		vars.add(new Variable(ExecutionContext.IMPLICIT_VARIABLE, targetType, targetObject));
d61 1
a61 1
			vars.add(new Variable(def.getParams()[i].getVarName(), paramTypes[i], params[i]));
@


1.3.6.5
log
@[243154] Use OCL instead of home-grown expression language - most (what's feasible) of the extension invocation fixed. A lot of hacks and questions, though.
@
text
@d47 1
a47 1
		final EClassifier targetType = BuiltinMetaModel.getType(getContext(), targetObject);
d50 1
a50 1
			paramTypes[i] = BuiltinMetaModel.getType(getContext(), params[i]);
@


1.2
log
@refactored use of variables (no need to expose Map)
@
text
@d31 1
a31 3
 * *
 * 
 * @@author Sven Efftinge *
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d17 1
d55 2
a56 2
        ctx = (XpandExecutionContext) ctx.cloneWithVariable(new Variable(ExecutionContext.IMPLICIT_VARIABLE,
                targetObject));
d58 1
a58 2
            final Variable v = new Variable(def.getParams()[i].getName().getValue(), params[i]);
            ctx = (XpandExecutionContext) ctx.cloneWithVariable(v);
d60 2
a61 1
        ctx = (XpandExecutionContext) ctx.cloneWithResource(def.getOwner());
@

