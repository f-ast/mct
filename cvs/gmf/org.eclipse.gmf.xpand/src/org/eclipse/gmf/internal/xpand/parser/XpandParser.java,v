head	1.11;
access;
symbols
	v20081022-1925:1.11
	v20081020-0700:1.11
	ocl_qvt:1.11.0.4
	Root_ocl_qvt:1.11
	v20080722-1827:1.11
	v20080718-1731:1.11
	v20080716-1600:1.11
	v20080716-1642:1.11
	R2_1_maintenance:1.11.0.2
	Root_R2_1_maintenance:1.11
	R2_1_0:1.11
	v20080528-1052:1.11
	v20080516-1143:1.11
	v20080417-1610:1.11
	v20080322-0000:1.11
	v20080222-1200:1.11
	v20071130-1111:1.11
	v20071124-0000:1.9.2.2
	v20071108-0000:1.10
	v20071003-0000:1.9
	v20070921-0000:1.9
	v20070903-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	RC3_20:1.9
	v20070608-1300:1.9
	v20070605-1400:1.9
	v20070601-1400:1.9
	v20070518-1300:1.9
	v20070420-1000:1.9
	v20070405-1100:1.9
	v20070403-1500:1.9
	v20070330-1300:1.9
	v20070208-1800:1.9
	v20070103-0300:1.9
	M4_20:1.9
	M3_20:1.9;
locks; strict;
comment	@# @;


1.11
date	2007.11.16.13.45.23;	author atikhomirov;	state Exp;
branches
	1.11.4.1;
next	1.10;
commitid	4d4473d9ef24567;

1.10
date	2007.10.23.17.55.34;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	269471e35954567;

1.9
date	2006.11.09.17.39.32;	author atikhomirov;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2006.11.09.11.10.39;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.08.19.08.32;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.08.14.45.16;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.08.11.31.19;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.24.18.31.37;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.23.18.39.37;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.23.17.57.12;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.48;	author atikhomirov;	state Exp;
branches;
next	;

1.9.2.1
date	2007.10.24.13.31.53;	author atikhomirov;	state Exp;
branches;
next	1.9.2.2;
commitid	3382471f49474567;

1.9.2.2
date	2007.11.16.13.48.37;	author atikhomirov;	state Exp;
branches;
next	;
commitid	889473d9fb44567;

1.11.4.1
date	2008.08.05.14.49.23;	author atikhomirov;	state Exp;
branches;
next	1.11.4.2;
commitid	48a6489868694567;

1.11.4.2
date	2008.08.12.11.17.21;	author atikhomirov;	state Exp;
branches;
next	;
commitid	119348a1713f4567;


desc
@@


1.11
log
@fully-qualified names of xpand templates are not processed correctly with the old pattern - and with assertions enabled the thread is stopped.
@
text
@/*******************************************************************************
* Copyright (c) 2006, 2007 Eclipse.org
* 
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*******************************************************************************/
package org.eclipse.gmf.internal.xpand.parser;

import lpg.lpgjavaruntime.*;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.gmf.internal.xpand.util.ParserException.ErrorLocationInfo;

import org.eclipse.gmf.internal.xpand.expression.parser.ExpressionFactory;
import org.eclipse.gmf.internal.xpand.ast.*;

import org.eclipse.gmf.internal.xpand.expression.ast.*;

import java.util.Collections;

public class XpandParser extends PrsStream implements RuleAction {
    private static ParseTable prs = new XpandParserprs();
    private DeterministicParser dtParser;

    public DeterministicParser getParser() { return dtParser; }
    private void setResult(Object object) { dtParser.setSym1(object); }
    public Object getRhsSym(int i) { return dtParser.getSym(i); }

    public int getRhsTokenIndex(int i) { return dtParser.getToken(i); }
    public IToken getRhsIToken(int i) { return super.getIToken(getRhsTokenIndex(i)); }
    
    public int getRhsFirstTokenIndex(int i) { return dtParser.getFirstToken(i); }
    public IToken getRhsFirstIToken(int i) { return super.getIToken(getRhsFirstTokenIndex(i)); }

    public int getRhsLastTokenIndex(int i) { return dtParser.getLastToken(i); }
    public IToken getRhsLastIToken(int i) { return super.getIToken(getRhsLastTokenIndex(i)); }

    public int getLeftSpan() { return dtParser.getFirstToken(); }
    public IToken getLeftIToken()  { return super.getIToken(getLeftSpan()); }

    public int getRightSpan() { return dtParser.getLastToken(); }
    public IToken getRightIToken() { return super.getIToken(getRightSpan()); }

    public int getRhsErrorTokenIndex(int i) {
        int index = dtParser.getToken(i);
        IToken err = super.getIToken(index);
        return (err instanceof ErrorToken ? index : 0);
    }
    public ErrorToken getRhsErrorIToken(int i) {
        int index = dtParser.getToken(i);
        IToken err = super.getIToken(index);
        return (ErrorToken) (err instanceof ErrorToken ? err : null);
    }

    public XpandParser(LexStream lexStream) {
        super(lexStream);
        xpandFactory = new XpandFactory(lexStream.getFileName());
		factory = new ExpressionFactory(lexStream.getFileName());

        try {
            super.remapTerminalSymbols(orderedTerminalSymbols(), XpandParserprs.EOFT_SYMBOL);
        }
        catch(NullExportedSymbolsException e) {
        }
        catch(NullTerminalSymbolsException e) {
        }
        catch(UnimplementedTerminalsException e) {
            java.util.ArrayList unimplemented_symbols = e.getSymbols();
            System.out.println("The Lexer will not scan the following token(s):");
            for (int i = 0; i < unimplemented_symbols.size(); i++)
            {
                Integer id = (Integer) unimplemented_symbols.get(i);
                System.out.println("    " + XpandParsersym.orderedTerminalSymbols[id.intValue()]);               
            }
            System.out.println();                        
        }
        catch(UndefinedEofSymbolException e) {
            throw new Error(new UndefinedEofSymbolException
                                ("The Lexer does not implement the Eof symbol " +
                                 XpandParsersym.orderedTerminalSymbols[XpandParserprs.EOFT_SYMBOL]));
        } 
    }

    public String[] orderedTerminalSymbols() { return XpandParsersym.orderedTerminalSymbols; }
    public String getTokenKindName(int kind) { return XpandParsersym.orderedTerminalSymbols[kind]; }            
    public int getEOFTokenKind() { return XpandParserprs.EOFT_SYMBOL; }
    public PrsStream getParseStream() { return (PrsStream) this; }

    public Template parser() {
        return parser(null, 0);
    }
        
    public Template parser(Monitor monitor) {
        return parser(monitor, 0);
    }
        
    public Template parser(int error_repair_count) {
        return parser(null, error_repair_count);
    }
        
    public Template parser(Monitor monitor, int error_repair_count) {
        try {
        	resetErrors();
            dtParser = new DeterministicParser(monitor, (TokenStream)this, prs, (RuleAction)this);
        }
        catch (NotDeterministicParseTableException e) {
            throw new Error(new NotDeterministicParseTableException
                                ("Regenerate XpandParserprs.java with -NOBACKTRACK option"));
        }
        catch (BadParseSymFileException e) {
            throw new Error(new BadParseSymFileException("Bad Parser Symbol File -- XpandParsersym.java. Regenerate XpandParserprs.java"));
        }

        try {
            return (Template) dtParser.parse();
        }
        catch (BadParseException e) {
            reset(e.error_token); // point to error token

            DiagnoseParser diagnoseParser = new DiagnoseParser(this, prs);
            diagnoseParser.diagnose(e.error_token);
        }

        return null;
    }


	public ErrorLocationInfo[] getErrors() {
		return errors.toArray(new ErrorLocationInfo[errors.size()]);
	}

	private void resetErrors() {
		errors.clear();
	}

	private final List<ErrorLocationInfo> errors = new LinkedList<ErrorLocationInfo>();

	@@Override
	public void reportError(int errorCode, String locationInfo, int leftToken, int rightToken, String tokenText) {
		final int leftTokenLine = getLine(leftToken);
		final int leftTokenColumn = getColumn(leftToken);
		final int rightTokenLine = getEndLine(rightToken);
		final int rightTokenColumn = getEndColumn(rightToken);
		final String msg = tokenText + errorMsgText[errorCode];
		errors.add(new ErrorLocationInfo(msg, leftTokenLine, leftTokenColumn, rightTokenLine, rightTokenColumn));
	}
/*
	@@Override
	public void reportError(int leftToken, int rightToken) {
		int errorCode = (rightToken >= getStreamLength() ? EOF_CODE : leftToken == rightToken ? LEX_ERROR_CODE : INVALID_TOKEN_CODE);
		int endToken = (leftToken == rightToken ? rightToken : rightToken - 1);
		String msg = (errorCode == EOF_CODE ? "End-of-file " : errorCode == INVALID_TOKEN_CODE
					? "\"" + new String(getInputChars(), leftToken, rightToken - leftToken) + "\" "
					: "\"" + getCharValue(leftToken) + "\" ");

		final int leftTokenLine = getLine(leftToken);
		final int leftTokenColumn = getColumn(leftToken);
		final int rightTokenLine = getEndLine(endToken);
		final int rightTokenColumn = getEndColumn(endToken);
		errors.add(new ErrorLocationInfo(msg, leftTokenLine, leftTokenColumn, rightTokenLine, rightTokenColumn));
	}
*/
	@@Override
	public void reportError(int errorCode, String locationInfo, String tokenText) {
		try {
			Matcher m = Pattern.compile("(?:[^:]+::)*[^:]+:(\\d+):(\\d+):(\\d+):(\\d+):.*").matcher(locationInfo);
			boolean t = m.matches(); // ignore return value, rely on exception if anything wrong
			assert t;
			final int leftTokenLine = getLine(Integer.parseInt(m.group(1)));
			final int leftTokenColumn = getColumn(Integer.parseInt(m.group(2)));
			final int rightTokenLine = getEndLine(Integer.parseInt(m.group(3)));
			final int rightTokenColumn = getEndColumn(Integer.parseInt(m.group(4)));
			final String msg = tokenText + errorMsgText[errorCode];
			errors.add(new ErrorLocationInfo(msg, leftTokenLine, leftTokenColumn, rightTokenLine, rightTokenColumn));
		} catch (Throwable ex) {
			// ignore
			errors.add(new ErrorLocationInfo(tokenText + errorMsgText[errorCode]));
		}
	}

	private final XpandFactory xpandFactory;

	private final ExpressionFactory factory;

    public void ruleAction(int ruleNumber) {
        switch (ruleNumber) {
 
            //
            // Rule 2:  letExpression ::= let IDENT ASSIGN castedExpression COLON castedExpression
            //
            case 2: {
                
		setResult(factory.createLetExpression(getLeftIToken(),getRhsIToken(2),(Expression) getRhsSym(4), (Expression) getRhsSym(6)));
	          break;
            } 
            //
            // Rule 4:  castedExpression ::= LPAREN type RPAREN infixExpression
            //
            case 4: {
                
		setResult(factory.createCast(getLeftIToken(), (Identifier) getRhsSym(2),(Expression) getRhsSym(4)));
	          break;
            } 
            //
            // Rule 7:  chainExpression ::= ifExpression ARROW chainExpression
            //
            case 7: {
                
		Expression e = (Expression) getRhsSym(1);
		Expression right = (Expression) getRhsSym(3);
		if (right instanceof ChainExpression) {
			ChainExpression rchain = (ChainExpression) right;
			Expression newFirst = factory.createChainExpression(e, rchain.getFirst()); 
			setResult(factory.createChainExpression(newFirst, rchain.getNext()));
		} else {
			setResult(factory.createChainExpression(e, right));
		}
	          break;
            } 
            //
            // Rule 9:  ifExpression ::= switchExpression QUESTION_MARK switchExpression COLON switchExpression
            //
            case 9: {
                
		setResult(factory.createIf((Expression) getRhsSym(1),(Expression) getRhsSym(3), (Expression) getRhsSym(5)));
	          break;
            } 
            //
            // Rule 10:  switchExpression ::= switch LPAREN expression RPAREN LCURLY switchCases default COLON orExpression RCURLY
            //
            case 10: {
                
		setResult(factory.createSwitchExpression(getLeftIToken(),getRightIToken(), (Expression) getRhsSym(3), (List) getRhsSym(6), (Expression) getRhsSym(9)));
	          break;
            } 
            //
            // Rule 12:  switchCases ::= $Empty
            //
            case 12: {
                
		setResult(Collections.emptyList());
	          break;
            } 
            //
            // Rule 13:  switchCases ::= case orExpression COLON orExpression switchCases
            //
            case 13: {
                
		LinkedList r = new LinkedList();
		r.add(factory.createCase(getLeftIToken(), (Expression) getRhsSym(2), (Expression) getRhsSym(4)));
		r.addAll((List) getRhsSym(5));
		setResult(r);
	          break;
            } 
            //
            // Rule 15:  orExpression ::= andExpression OR orExpression
            //
            case 15: {
                
		Expression e = (Expression) getRhsSym(1);
		Expression r = (Expression) getRhsSym(3);
		setResult(factory.createBooleanOperation(e.getStart(),r.getEnd(),e.getLine(),getRhsIToken(2),e,r));
	          break;
            } 
            //
            // Rule 17:  andExpression ::= impliesExpression AND andExpression
            //
            case 17: {
                
		Expression e = (Expression) getRhsSym(1);
		Expression r = (Expression) getRhsSym(3);
		setResult(factory.createBooleanOperation(e.getStart(),r.getEnd(),e.getLine(),getRhsIToken(2),e,r));
	          break;
            } 
            //
            // Rule 19:  impliesExpression ::= relationalExpression implies relationalExpression
            //
            case 19: {
                
		Expression e = (Expression) getRhsSym(1);
		Expression r = (Expression) getRhsSym(3);
		setResult(factory.createBooleanOperation(e.getStart(),r.getEnd(),e.getLine(),getRhsIToken(2),e,r));
	          break;
            } 
            //
            // Rule 21:  relationalExpression ::= additiveExpression relationalOperator additiveExpression
            //
            case 21: {
                
		Expression e = (Expression) getRhsSym(1);
		IToken t = (IToken) getRhsSym(2);
		Expression r = (Expression) getRhsSym(3);
		setResult(factory.createOperationCall(e.getStart(),r.getEnd(),e.getLine(),t,e,Collections.singletonList(r)));
	          break;
            } 
            //
            // Rule 22:  relationalOperator ::= EQ
            //
            case 22: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 23:  relationalOperator ::= NE
            //
            case 23: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 24:  relationalOperator ::= GE
            //
            case 24: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 25:  relationalOperator ::= LE
            //
            case 25: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 26:  relationalOperator ::= GT
            //
            case 26: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 27:  relationalOperator ::= LT
            //
            case 27: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 29:  additiveExpression ::= additiveExpression additiveOperator multiplicativeExpression
            //
            case 29: {
                
		Expression e = (Expression) getRhsSym(1);
		IToken t = (IToken) getRhsSym(2);
		Expression r = (Expression) getRhsSym(3);
		setResult(factory.createOperationCall(e.getStart(),r.getEnd(),e.getLine(),t,e,Collections.singletonList(r)));
	          break;
            } 
            //
            // Rule 30:  additiveOperator ::= PLUS
            //
            case 30: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 31:  additiveOperator ::= MINUS
            //
            case 31: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 33:  multiplicativeExpression ::= unaryExpression multiplicativeOperator multiplicativeExpression
            //
            case 33: {
                
		Expression e = (Expression) getRhsSym(1);
		IToken t = (IToken) getRhsSym(2);
		Expression r = (Expression) getRhsSym(3);
		setResult(factory.createOperationCall(e.getStart(),r.getEnd(),e.getLine(),t,e,Collections.singletonList(r)));
	          break;
            } 
            //
            // Rule 34:  multiplicativeOperator ::= MULTI
            //
            case 34: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 35:  multiplicativeOperator ::= DIV
            //
            case 35: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 37:  unaryExpression ::= NOT infixExpression
            //
            case 37: {
                
		Expression e = (Expression) getRhsSym(2);
		setResult(factory.createOperationCall(getLeftIToken().getColumn(),e.getEnd(),getLeftIToken().getLine(),getLeftIToken(),e,Collections.EMPTY_LIST));
	          break;
            } 
            //
            // Rule 38:  unaryExpression ::= MINUS infixExpression
            //
            case 38: {
                
		Expression e = (Expression) getRhsSym(2);
		setResult(factory.createOperationCall(getLeftIToken().getColumn(),e.getEnd(),getLeftIToken().getLine(),getLeftIToken(),e,Collections.EMPTY_LIST));
	          break;
            } 
            //
            // Rule 39:  infixExpressionSuffix ::= DOT featureCall
            //
            case 39: {
                
		setResult(getRhsSym(2));
	          break;
            } 
            //
            // Rule 40:  infixExpressionSuffix ::= DOT featureCall infixExpressionSuffix
            //
            case 40: {
                
		final FeatureCall op = (FeatureCall) getRhsSym(3);
		FeatureCall fc = op;
		while (fc.getTarget() != null) {
			fc = (FeatureCall) fc.getTarget();
		}
		fc.setTarget((FeatureCall) getRhsSym(2));
		setResult(op);
	          break;
            } 
            //
            // Rule 42:  infixExpression ::= primaryExpression infixExpressionSuffix
            //
            case 42: {
                
		final FeatureCall op = (FeatureCall) getRhsSym(2);
		FeatureCall fc = op;
		while (fc.getTarget() != null) {
			fc = (FeatureCall) fc.getTarget();
		}
		fc.setTarget((Expression) getRhsSym(1));
		setResult(op);
	          break;
            } 
            //
            // Rule 43:  primaryExpression ::= STRING
            //
            case 43: {
                
		setResult(factory.createStringLiteral(getLeftIToken()));
	          break;
            } 
            //
            // Rule 51:  primaryExpression ::= LPAREN expression RPAREN
            //
            case 51: {
                
		setResult(getRhsSym(2));
	          break;
            } 
            //
            // Rule 52:  featureCall ::= IDENT LPAREN parameterList RPAREN
            //
            case 52: {
                
		setResult(factory.createOperationCall(getRightIToken(),getLeftIToken(),null, (List<Expression>) getRhsSym(3)));
	          break;
            } 
            //
            // Rule 53:  featureCall ::= IDENT LPAREN RPAREN
            //
            case 53: {
                
		setResult(factory.createOperationCall(getRightIToken(), getLeftIToken(), null, Collections.EMPTY_LIST));
	          break;
            } 
            //
            // Rule 54:  featureCall ::= type
            //
            case 54: {
                
		setResult(factory.createFeatureCall((Identifier) getRhsSym(1),null));
	          break;
            } 
            //
            // Rule 56:  listLiteral ::= LCURLY parameterList RCURLY
            //
            case 56: {
                
		setResult(factory.createListLiteral(getLeftIToken(),getRightIToken(), (List<Expression>) getRhsSym(2)));
	          break;
            } 
            //
            // Rule 57:  listLiteral ::= LCURLY RCURLY
            //
            case 57: {
                
		setResult(factory.createListLiteral(getLeftIToken(), getRightIToken(), Collections.EMPTY_LIST));
	          break;
            } 
            //
            // Rule 58:  constructorCall ::= new simpleType
            //
            case 58: {
                
		setResult(factory.createConstructorCall(getLeftIToken(), (Identifier) getRhsSym(2)));
	          break;
            } 
            //
            // Rule 59:  booleanLiteral ::= false
            //
            case 59: {
                
		setResult(factory.createBooleanLiteral(getRhsIToken(1)));
	          break;
            } 
            //
            // Rule 60:  booleanLiteral ::= true
            //
            case 60: {
                
		setResult(factory.createBooleanLiteral(getRhsIToken(1)));
	          break;
            } 
            //
            // Rule 61:  nullLiteral ::= null
            //
            case 61: {
                
		setResult(factory.createNullLiteral(getRhsIToken(1)));
	          break;
            } 
            //
            // Rule 62:  intLiteral ::= INT_CONST
            //
            case 62: {
                
		setResult(factory.createIntegerLiteral(getRhsIToken(1)));
	          break;
            } 
            //
            // Rule 63:  realLiteral ::= REAL_CONST
            //
            case 63: {
                
		setResult(factory.createRealLiteral(getRhsIToken(1)));
	          break;
            } 
            //
            // Rule 64:  collectionExpression ::= typeSelect LPAREN type RPAREN
            //
            case 64: {
                
		setResult(factory.createTypeSelectExpression(getRhsIToken(1), getRightIToken(), (Identifier) getRhsSym(3),null));
	          break;
            } 
            //
            // Rule 65:  collectionExpression ::= collectionExpressionName LPAREN IDENT BAR expression RPAREN
            //
            case 65: {
                
		setResult(factory.createCollectionExpression((IToken) getRhsSym(1), getRightIToken(), getRhsIToken(3), (Expression) getRhsSym(5),null));
	          break;
            } 
            //
            // Rule 66:  collectionExpression ::= collectionExpressionName LPAREN expression RPAREN
            //
            case 66: {
                
		setResult(factory.createCollectionExpression((IToken) getRhsSym(1), getRightIToken(), null, (Expression) getRhsSym(3),null));
	          break;
            } 
            //
            // Rule 67:  collectionExpressionName ::= collect
            //
            case 67: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 68:  collectionExpressionName ::= select
            //
            case 68: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 69:  collectionExpressionName ::= reject
            //
            case 69: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 70:  collectionExpressionName ::= exists
            //
            case 70: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 71:  collectionExpressionName ::= notExists
            //
            case 71: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 72:  collectionExpressionName ::= forAll
            //
            case 72: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 73:  declaredParameterListOpt ::= $Empty
            //
            case 73: {
                
		setResult(Collections.EMPTY_LIST);
	          break;
            } 
            //
            // Rule 75:  declaredParameterList ::= type IDENT
            //
            case 75: {
                
		Identifier id = factory.createIdentifier(getRightIToken());
		DeclaredParameter p = factory.createDeclaredParameter((Identifier) getRhsSym(1), id);
		setResult(Collections.singletonList(p));
	          break;
            } 
            //
            // Rule 76:  declaredParameterList ::= type IDENT COMMA declaredParameterList
            //
            case 76: {
                
		LinkedList r = new LinkedList();
		Identifier id = factory.createIdentifier(getRhsIToken(2));
		DeclaredParameter p = factory.createDeclaredParameter((Identifier) getRhsSym(1), id);
		r.add(p);
		r.addAll((List) getRhsSym(4));
		setResult(r);
	          break;
            } 
            //
            // Rule 77:  parameterList ::= expression
            //
            case 77: {
                
		setResult(Collections.singletonList((Expression) getRhsSym(1)));
	          break;
            } 
            //
            // Rule 78:  parameterList ::= expression COMMA parameterList
            //
            case 78: {
                
		LinkedList r = new LinkedList();
		r.add(getRhsSym(1));
		r.addAll((List) getRhsSym(3));
		setResult(r);
	          break;
            } 
            //
            // Rule 81:  collectionType ::= collectionTypeName LSQUARE simpleType RSQUARE
            //
            case 81: {
                
		Identifier id = (Identifier) getRhsSym(1);
		id = id.append(factory.createIdentifier(getRhsIToken(2)));
		id = id.append((Identifier) getRhsSym(3));
		id = id.append(factory.createIdentifier(getRhsIToken(4)));
		setResult(id);
	          break;
            } 
            //
            // Rule 82:  collectionTypeName ::= Collection
            //
            case 82: {
                
		setResult(factory.createIdentifier(getRhsIToken(1)));
	          break;
            } 
            //
            // Rule 83:  collectionTypeName ::= List
            //
            case 83: {
                
		setResult(factory.createIdentifier(getRhsIToken(1)));
	          break;
            } 
            //
            // Rule 84:  collectionTypeName ::= Set
            //
            case 84: {
                
		setResult(factory.createIdentifier(getRhsIToken(1)));
	          break;
            } 
            //
            // Rule 85:  simpleType ::= IDENT NOT qualifiedType
            //
            case 85: {
                
		Identifier id = factory.createIdentifier(getLeftIToken());
		id = id.append(factory.createIdentifier(getRhsIToken(2)));
		id = id.append((Identifier) getRhsSym(3));
		setResult(id);
	          break;
            } 
            //
            // Rule 87:  qualifiedType ::= IDENT
            //
            case 87: {
                
		setResult(factory.createIdentifier(getLeftIToken()));
	          break;
            } 
            //
            // Rule 88:  qualifiedType ::= IDENT DCOLON qualifiedType
            //
            case 88: {
                
		Identifier id = factory.createIdentifier(getLeftIToken());
		id = id.append(factory.createIdentifier(getRhsIToken(2)));
		id = id.append((Identifier) getRhsSym(3));
		setResult(id);
	          break;
            } 
            //
            // Rule 89:  template ::= emptyTemplate
            //
            case 89: {
                
		setResult(xpandFactory.createTemplate(Collections.EMPTY_LIST, Collections.EMPTY_LIST, Collections.EMPTY_LIST, Collections.EMPTY_LIST, getRightIToken()));
	          break;
            } 
            //
            // Rule 92:  template ::= LG commentTextPairAny imports extensionImports defineOrAroundSeq
            //
            case 92: {
                
		List imports = (List) getRhsSym(3);
		List extensionImports = (List) getRhsSym(4);
		List defineOrAround = (List) getRhsSym(5);
		List<Advice> advices = new LinkedList<Advice>();
		List<Definition> defines = new LinkedList<Definition>();
		for (Object o : defineOrAround) {
			if (o instanceof Definition) {
				defines.add((Definition) o);
			} else if (o instanceof Advice) {
				advices.add((Advice) o);
			} else {
				throw new IllegalStateException();// assert false?
			}
		}
		setResult(xpandFactory.createTemplate(imports, extensionImports, defines, advices, getRightIToken()));
	          break;
            } 
            //
            // Rule 93:  defineOrAroundSeq ::= define TEXT commentTextPairAny defineOrAroundSuffix
            //
            case 93: {
                
		List result = new LinkedList();
		result.add(getRhsSym(1));
		result.addAll((List) getRhsSym(4));
		setResult(result);
	          break;
            } 
            //
            // Rule 94:  defineOrAroundSeq ::= around TEXT commentTextPairAny defineOrAroundSuffix
            //
            case 94: {
                
		List result = new LinkedList();
		result.add(getRhsSym(1));
		result.addAll((List) getRhsSym(4));
		setResult(result);
	          break;
            } 
            //
            // Rule 95:  defineOrAroundSuffix ::= $Empty
            //
            case 95: {
                
		setResult(Collections.EMPTY_LIST);
	          break;
            } 
            //
            // Rule 101:  imports ::= $Empty
            //
            case 101: {
                
		setResult(Collections.EMPTY_LIST);
	          break;
            } 
            //
            // Rule 102:  imports ::= anImport imports
            //
            case 102: {
                
		List res = new LinkedList();
		res.add(getRhsSym(1));
		res.addAll((List) getRhsSym(2));
		setResult(res);
	          break;
            } 
            //
            // Rule 103:  anImport ::= IMPORT STRING TEXT commentTextPairAny
            //
            case 103: {
                
		setResult(xpandFactory.createNamespaceImport(getLeftIToken(),xpandFactory.createStringLiteral(getRhsIToken(2))));
	          break;
            } 
            //
            // Rule 104:  extensionImports ::= $Empty
            //
            case 104: {
                
		setResult(Collections.EMPTY_LIST);
	          break;
            } 
            //
            // Rule 105:  extensionImports ::= anExtensionImport extensionImports
            //
            case 105: {
                
		List res = new LinkedList();
		res.add(getRhsSym(1));
		res.addAll((List) getRhsSym(2));
		setResult(res);
	          break;
            } 
            //
            // Rule 106:  anExtensionImport ::= EXTENSION simpleType TEXT commentTextPairAny
            //
            case 106: {
                
		setResult(xpandFactory.createImportDeclaration(getLeftIToken(), (Identifier) getRhsSym(2)));
	          break;
            } 
            //
            // Rule 107:  around ::= AROUND pointcut FOR type sequence ENDAROUND
            //
            case 107: {
                
		setResult(xpandFactory.createAround(getLeftIToken(), getRightIToken(), (Identifier) getRhsSym(2), Collections.EMPTY_LIST, false, (Identifier) getRhsSym(4), (List) getRhsSym(5)));
	          break;
            } 
            //
            // Rule 108:  around ::= AROUND pointcut LPAREN declaredParameterList RPAREN FOR type sequence ENDAROUND
            //
            case 108: {
                
		setResult(xpandFactory.createAround(getLeftIToken(), getRightIToken(), (Identifier) getRhsSym(2), (List) getRhsSym(4), false, (Identifier) getRhsSym(7), (List) getRhsSym(8)));
	          break;
            } 
            //
            // Rule 109:  around ::= AROUND pointcut LPAREN declaredParameterList COMMA MULTI RPAREN FOR type sequence ENDAROUND
            //
            case 109: {
                
		setResult(xpandFactory.createAround(getLeftIToken(), getRightIToken(), (Identifier) getRhsSym(2), (List) getRhsSym(4), true, (Identifier) getRhsSym(9), (List) getRhsSym(10)));
	          break;
            } 
            //
            // Rule 110:  around ::= AROUND pointcut LPAREN MULTI RPAREN FOR type sequence ENDAROUND
            //
            case 110: {
                
		setResult(xpandFactory.createAround(getLeftIToken(), getRightIToken(), (Identifier) getRhsSym(2), Collections.EMPTY_LIST, true, (Identifier) getRhsSym(7), (List) getRhsSym(8)));
	          break;
            } 
            //
            // Rule 111:  pointcut ::= MULTI pointcutSuffix
            //
            case 111: {
                
		Identifier res = xpandFactory.createIdentifier(getLeftIToken());
		if (getRhsSym(2) != null) {
			res = res.append((Identifier) getRhsSym(2));
		}
		setResult(res);
	          break;
            } 
            //
            // Rule 112:  pointcut ::= IDENT pointcutSuffix
            //
            case 112: {
                
		Identifier res = xpandFactory.createIdentifier(getLeftIToken());
		if (getRhsSym(2) != null) {
			res = res.append((Identifier) getRhsSym(2));
		}
		setResult(res);
	          break;
            } 
            //
            // Rule 113:  pointcutSuffix ::= $Empty
            //
            case 113: {
                
		setResult(null);
	          break;
            } 
            //
            // Rule 115:  pointcutSuffix ::= DCOLON pointcutSuffix
            //
            case 115: {
                
		Identifier res = xpandFactory.createIdentifier(getLeftIToken());
		if (getRhsSym(2) != null) {
			res = res.append((Identifier) getRhsSym(2));
		}
		setResult(res);
	          break;
            } 
            //
            // Rule 116:  define ::= DEFINE IDENT FOR type sequence ENDDEFINE
            //
            case 116: {
                
		setResult(xpandFactory.createDefinition(getLeftIToken(), getRightIToken(), getRhsIToken(2), Collections.EMPTY_LIST, (Identifier) getRhsSym(4), (List) getRhsSym(5)));
	          break;
            } 
            //
            // Rule 117:  define ::= DEFINE IDENT LPAREN declaredParameterList RPAREN FOR type sequence ENDDEFINE
            //
            case 117: {
                
		setResult(xpandFactory.createDefinition(getLeftIToken(), getRightIToken(), getRhsIToken(2), (List) getRhsSym(4), (Identifier) getRhsSym(7), (List) getRhsSym(8)));
	          break;
            } 
            //
            // Rule 118:  sequence ::= text sequenceSuffix
            //
            case 118: {
                
		List res = new LinkedList();
		res.addAll((List) getRhsSym(1));
		res.addAll((List) getRhsSym(2));
		setResult(res);
	          break;
            } 
            //
            // Rule 119:  sequenceSuffix ::= $Empty
            //
            case 119: {
                
		setResult(Collections.EMPTY_LIST);
	          break;
            } 
            //
            // Rule 120:  sequenceSuffix ::= statement text sequenceSuffix
            //
            case 120: {
                
		List res = new LinkedList();
		res.add(getRhsSym(1));
		res.addAll((List) getRhsSym(2));
		res.addAll((List) getRhsSym(3));
		setResult(res);
	          break;
            } 
            //
            // Rule 127:  text ::= minusOpt TEXT textSuffix
            //
            case 127: {
                
		List res = new LinkedList();
		res.add(xpandFactory.createTextStatement(getRhsIToken(2), (IToken) getRhsSym(1)));
		res.addAll((List) getRhsSym(3));
		setResult(res);
	          break;
            } 
            //
            // Rule 128:  textSuffix ::= $Empty
            //
            case 128: {
                
		setResult(Collections.EMPTY_LIST);
	          break;
            } 
            //
            // Rule 129:  textSuffix ::= minusOpt TEXT textSuffix
            //
            case 129: {
                
		List res = new LinkedList();
		res.add(xpandFactory.createTextStatement(getRhsIToken(2), (IToken) getRhsSym(1)));
		res.addAll((List) getRhsSym(3));
		setResult(res);
	          break;
            } 
            //
            // Rule 130:  minusOpt ::= $Empty
            //
            case 130: {
                
		setResult(null);
	          break;
            } 
            //
            // Rule 131:  minusOpt ::= MINUS
            //
            case 131: {
                
		setResult(getLeftIToken());
	          break;
            } 
            //
            // Rule 135:  errorStatement ::= ERROR expression
            //
            case 135: {
                
		setResult(xpandFactory.createErrorStatement(getLeftIToken(), (Expression) getRhsSym(2)));
	          break;
            } 
            //
            // Rule 136:  expandStatement ::= EXPAND definitionName parameterListOpt
            //
            case 136: {
                
		setResult(xpandFactory.createExpandStatement(getLeftIToken(), (Identifier) getRhsSym(2), (List) getRhsSym(3), null, false, null));
	          break;
            } 
            //
            // Rule 137:  expandStatement ::= EXPAND definitionName parameterListOpt FOR expression
            //
            case 137: {
                
		setResult(xpandFactory.createExpandStatement(getLeftIToken(), (Identifier) getRhsSym(2), (List) getRhsSym(3), (Expression) getRhsSym(5), false, null));
	          break;
            } 
            //
            // Rule 138:  expandStatement ::= EXPAND definitionName parameterListOpt FOREACH expression separatorOpt
            //
            case 138: {
                
		setResult(xpandFactory.createExpandStatement(getLeftIToken(), (Identifier) getRhsSym(2), (List) getRhsSym(3), (Expression) getRhsSym(5), true, (Expression) getRhsSym(6)));
	          break;
            } 
            //
            // Rule 139:  parameterListOpt ::= $Empty
            //
            case 139: {
                
		setResult(Collections.EMPTY_LIST);
	          break;
            } 
            //
            // Rule 140:  parameterListOpt ::= LPAREN parameterList RPAREN
            //
            case 140: {
                
		setResult(getRhsSym(2));
	          break;
            } 
            //
            // Rule 142:  expressionStmt ::= expression
            //
            case 142: {
                
		setResult(xpandFactory.createExpressionStatement((Expression) getRhsSym(1)));
	          break;
            } 
            //
            // Rule 143:  fileStatement ::= FILE expression identOpt sequence ENDFILE
            //
            case 143: {
                
		setResult(xpandFactory.createFileStatement(getLeftIToken(), getRightIToken(), (Expression) getRhsSym(2), (Identifier) getRhsSym(3), (List) getRhsSym(4)));
	          break;
            } 
            //
            // Rule 144:  identOpt ::= $Empty
            //
            case 144: {
                
		setResult(null);
	          break;
            } 
            //
            // Rule 145:  identOpt ::= IDENT
            //
            case 145: {
                
		setResult(xpandFactory.createIdentifier(getLeftIToken()));
	          break;
            } 
            //
            // Rule 146:  foreachStatement ::= FOREACH expression AS IDENT iteratorOpt separatorOpt sequence ENDFOREACH
            //
            case 146: {
                
		setResult(xpandFactory.createForEachStatement(getLeftIToken(), getRightIToken(), (Expression) getRhsSym(2), getRhsIToken(4), (Expression) getRhsSym(6), (IToken) getRhsSym(5), (List) getRhsSym(7)));
	          break;
            } 
            //
            // Rule 147:  iteratorOpt ::= $Empty
            //
            case 147: {
                
		setResult(null);
	          break;
            } 
            //
            // Rule 148:  iteratorOpt ::= ITERATOR IDENT
            //
            case 148: {
                
		setResult(getRightIToken());
	          break;
            } 
            //
            // Rule 149:  separatorOpt ::= $Empty
            //
            case 149: {
                
		setResult(null);
	          break;
            } 
            //
            // Rule 150:  separatorOpt ::= SEPARATOR expression
            //
            case 150: {
                
		setResult(getRhsSym(2));
	          break;
            } 
            //
            // Rule 151:  ifStatement ::= IF expression sequence elseifAny elseOpt ENDIF
            //
            case 151: {
                
		IfStatement i = xpandFactory.createIfStatement(getLeftIToken(), (Expression) getRhsSym(2), (List) getRhsSym(3), null);
		IfStatement elseIf = (IfStatement) getRhsSym(4);
		IfStatement elseStmt = (IfStatement) getRhsSym(5);
		if (elseIf != null) {
			i.setElseIf(elseIf);
			IfStatement curElseIf = elseIf;
			// get the latest one in the chain
			while (curElseIf.getElseIf() != null) {
				curElseIf = curElseIf.getElseIf();
			}
			curElseIf.setElseIf(elseStmt);
		} else {
			i.setElseIf(elseStmt);
		}
		setResult(i);
	          break;
            } 
            //
            // Rule 152:  elseifAny ::= $Empty
            //
            case 152: {
                
		setResult(null);
	          break;
            } 
            //
            // Rule 153:  elseifAny ::= ELSEIF expression sequence elseifAny
            //
            case 153: {
                
		IfStatement elseIf = xpandFactory.createIfStatement(getLeftIToken(), (Expression) getRhsSym(2), (List) getRhsSym(3), null);
		IfStatement restElseIf = (IfStatement) getRhsSym(4);
		elseIf.setElseIf(restElseIf);
		setResult(elseIf);
	          break;
            } 
            //
            // Rule 154:  elseOpt ::= $Empty
            //
            case 154: {
                
		setResult(null);
	          break;
            } 
            //
            // Rule 155:  elseOpt ::= ELSE sequence
            //
            case 155: {
                
		setResult(xpandFactory.createIfStatement(getLeftIToken(), null, (List) getRhsSym(2), null));
	          break;
            } 
            //
            // Rule 156:  letStatement ::= LET expression AS IDENT sequence ENDLET
            //
            case 156: {
                
		setResult(xpandFactory.createLetStatement(getLeftIToken(), getRightIToken(), (Expression) getRhsSym(2), getRhsIToken(4), (List) getRhsSym(5)));
	          break;
            } 
            //
            // Rule 157:  protectStatement ::= PROTECT CSTART expression CEND expression ID expression disabledOpt sequence ENDPROTECT
            //
            case 157: {
                
		setResult(xpandFactory.createProtectStatement(getLeftIToken(), getRightIToken(), (Expression) getRhsSym(3), (Expression) getRhsSym(5), (Expression) getRhsSym(7), (IToken) getRhsSym(8), (List) getRhsSym(9)));
	          break;
            } 
            //
            // Rule 158:  disabledOpt ::= $Empty
            //
            case 158: {
                
		setResult(null);
	          break;
            } 
            //
            // Rule 159:  disabledOpt ::= DISABLE
            //
            case 159: {
                
		setResult(getLeftIToken());
	          break;
            }
    
            default:
                break;
        }
        return;
    }
}

@


1.11.4.1
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d1 8
a8 12
/*
 * Copyright (c) 2006, 2008 Borland Software Corporation and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     committers of openArchitectureWare - Xpand language syntax
 *     Artem Tikhomirov (Borland) - LALR grammar
 *                                - Migration to OCL expressions
 */
d19 1
a19 1
import org.eclipse.gmf.internal.xpand.expression.ast.Identifier;
d21 3
a23 1
import org.eclipse.ocl.cst.*;
a24 30
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.ocl.cst.CSTNode;
import org.eclipse.ocl.cst.CallExpCS;
import org.eclipse.ocl.cst.CollectionTypeIdentifierEnum;
import org.eclipse.ocl.cst.DotOrArrowEnum;
import org.eclipse.ocl.cst.IntegerLiteralExpCS;
import org.eclipse.ocl.cst.IsMarkedPreCS;
import org.eclipse.ocl.cst.MessageExpCS;
import org.eclipse.ocl.cst.OCLExpressionCS;
import org.eclipse.ocl.cst.OCLMessageArgCS;
import org.eclipse.ocl.cst.OperationCallExpCS;
import org.eclipse.ocl.cst.PathNameCS;
import org.eclipse.ocl.cst.SimpleNameCS;
import org.eclipse.ocl.cst.SimpleTypeEnum;
import org.eclipse.ocl.cst.StateExpCS;
import org.eclipse.ocl.cst.TypeCS;
import org.eclipse.ocl.cst.VariableCS;
import org.eclipse.ocl.util.OCLStandardLibraryUtil;
import org.eclipse.ocl.utilities.PredefinedType;

import lpg.lpgjavaruntime.BadParseException;
import lpg.lpgjavaruntime.BadParseSymFileException;
import lpg.lpgjavaruntime.DeterministicParser;
import lpg.lpgjavaruntime.DiagnoseParser;
import lpg.lpgjavaruntime.IToken;
import lpg.lpgjavaruntime.Monitor;
import lpg.lpgjavaruntime.NotDeterministicParseTableException;
import lpg.lpgjavaruntime.ParseTable;
import lpg.lpgjavaruntime.RuleAction;
d63 1
d73 1
a73 1
            java.util.ArrayList<?> unimplemented_symbols = e.getSymbols();
d188 1
d190 262
a451 432

private OperationCS createOperationCS(
		PathNameCS pathNameCS,
		SimpleNameCS simpleNameCS,
		EList<VariableCS> list,
		TypeCS typeCS) {
	OperationCS result = CSTFactory.eINSTANCE.createOperationCS();
	result.setPathNameCS(pathNameCS);
	result.setSimpleNameCS(simpleNameCS);
	result.getParameters().addAll(list);
	result.setTypeCS(typeCS);
	return result;
}

private OperationCS createOperationCS(
		String simpleName,
		EList<VariableCS> list,
		TypeCS typeCS) {
	return createOperationCS(
			null,
			createSimpleNameCS(SimpleTypeEnum.IDENTIFIER_LITERAL, simpleName),
			list,
			typeCS);
}

private OperationCallExpCS createOperationCallExpCS(
		OCLExpressionCS oclExpressionCS,
		SimpleNameCS simpleNameCS,
		IsMarkedPreCS isMarkedPreCS,
		EList<OCLExpressionCS> arguments) {
	OperationCallExpCS result = CSTFactory.eINSTANCE.createOperationCallExpCS();
	result.setSource(oclExpressionCS);
	result.setSimpleNameCS(simpleNameCS);
	result.setIsMarkedPreCS(isMarkedPreCS);
	result.getArguments().addAll(arguments);
	return result;
}

private OperationCallExpCS createOperationCallExpCS(
		OCLExpressionCS oclExpressionCS,
		SimpleNameCS simpleNameCS,
		EList<OCLExpressionCS> arguments) {
	return createOperationCallExpCS(oclExpressionCS, simpleNameCS,
			createIsMarkedPreCS(false), arguments);
}

private OperationCallExpCS createOperationCallExpCS(
		SimpleNameCS simpleNameCS,
		IsMarkedPreCS isMarkedPreCS,
		EList<OCLExpressionCS> arguments) {
	return createOperationCallExpCS(null, simpleNameCS, isMarkedPreCS, arguments);
}

private OperationCallExpCS createOperationCallExpCS(
		SimpleNameCS simpleNameCS,
		IsMarkedPreCS isMarkedPreCS,
		StateExpCS stateExpCS) {
	OperationCallExpCS result = CSTFactory.eINSTANCE.createOperationCallExpCS();
	result.setSimpleNameCS(simpleNameCS);
	result.setIsMarkedPreCS(isMarkedPreCS);
	result.getArguments().add(stateExpCS);
	return result;
}

private StateExpCS createStateExpCS(PathNameCS pathName) {
	StateExpCS result = CSTFactory.eINSTANCE.createStateExpCS();
	result.getSequenceOfNames().addAll(pathName.getSequenceOfNames());
	return result;
}

private VariableExpCS createVariableExpCS(
		SimpleNameCS simpleNameCS,
		EList<OCLExpressionCS> arguments,
		IsMarkedPreCS isMarkedPreCS) {
	VariableExpCS result = CSTFactory.eINSTANCE.createVariableExpCS();
	result.setSimpleNameCS(simpleNameCS);
	result.getArguments().addAll(arguments);
	result.setIsMarkedPreCS(isMarkedPreCS);
	return result;
}

private SimpleNameCS createSimpleNameCS(
		SimpleTypeEnum type,
		String value) {
	SimpleNameCS result = CSTFactory.eINSTANCE.createSimpleNameCS();
	result.setType(type);
	result.setValue(unquote(value));
	return result;
}

private PrimitiveTypeCS createPrimitiveTypeCS(
		SimpleTypeEnum type,
		String value) {
	PrimitiveTypeCS result = CSTFactory.eINSTANCE.createPrimitiveTypeCS();
	result.setType(type);
	result.setValue(value);
	return result;
}

private PathNameCS createPathNameCS(String pathName) {
	PathNameCS result = CSTFactory.eINSTANCE.createPathNameCS();
	result.getSequenceOfNames().add(unquote(pathName));
	return result;
}

private PathNameCS extendPathNameCS(PathNameCS path, String name) {
	path.getSequenceOfNames().add(unquote(name));
	return path;
}

private PathNameCS createPathNameCS() {
	return CSTFactory.eINSTANCE.createPathNameCS();
}

private EnumLiteralExpCS createEnumLiteralExpCS(
		PathNameCS pathNameCS,
		SimpleNameCS simpleNameCS) {
	EnumLiteralExpCS result = CSTFactory.eINSTANCE.createEnumLiteralExpCS();
	result.setPathNameCS(pathNameCS);
	result.setSimpleNameCS(simpleNameCS);
	return result;
}

private EnumLiteralExpCS createEnumLiteralExpCS(
		PathNameCS pathNameCS,
		String simpleName) {
	return createEnumLiteralExpCS(pathNameCS,
		createSimpleNameCS(SimpleTypeEnum.IDENTIFIER_LITERAL, simpleName));
}

private CollectionLiteralExpCS createCollectionLiteralExpCS(
		CollectionTypeIdentifierEnum type,
		EList<CollectionLiteralPartCS> collectionLiteralParts) {
	CollectionLiteralExpCS result = CSTFactory.eINSTANCE.createCollectionLiteralExpCS();
	result.setCollectionType(type);
	result.getCollectionLiteralParts().addAll(collectionLiteralParts);
	return result;
}

private CollectionLiteralPartCS createCollectionLiteralPartCS(OCLExpressionCS oclExpressionCS) {
	CollectionLiteralPartCS result = CSTFactory.eINSTANCE.createCollectionLiteralPartCS();
	result.setExpressionCS(oclExpressionCS);
	return result;
}

private CollectionRangeCS createCollectionRangeCS(
		OCLExpressionCS oclExpressionCS,
		OCLExpressionCS lastOCLExpressionCS) {
	CollectionRangeCS result = CSTFactory.eINSTANCE.createCollectionRangeCS();
	result.setExpressionCS(oclExpressionCS);
	result.setLastExpressionCS(lastOCLExpressionCS);
	return result;
}

private IntegerLiteralExpCS createRangeStart(
		String integerDotDot,
		boolean isNegative) {
	String intToken = integerDotDot.substring(0, integerDotDot.indexOf('.'));
	int intValue = Integer.parseInt(intToken);
	if (isNegative) {
		intValue = -intValue;
	}
	
	IntegerLiteralExpCS result = CSTFactory.eINSTANCE.createIntegerLiteralExpCS();
	result.setIntegerSymbol(new Integer(intValue));
	result.setSymbol(Integer.toString(intValue));
	
	return result;
}

private TupleLiteralExpCS createTupleLiteralExpCS(EList<VariableCS> variables) {
	TupleLiteralExpCS result = CSTFactory.eINSTANCE.createTupleLiteralExpCS();
	result.getVariables().addAll(variables);
	return result;
}

private IntegerLiteralExpCS createIntegerLiteralExpCS(String string) {
	IntegerLiteralExpCS result = CSTFactory.eINSTANCE.createIntegerLiteralExpCS();
	result.setSymbol(string);
	result.setIntegerSymbol(Integer.valueOf(string));
	return result;
}

@@SuppressWarnings("nls")
private UnlimitedNaturalLiteralExpCS createUnlimitedNaturalLiteralExpCS(String string) {
	UnlimitedNaturalLiteralExpCS result = CSTFactory.eINSTANCE.createUnlimitedNaturalLiteralExpCS();
	result.setSymbol(string);
	if ("*".equals(string)) {
		result.setIntegerSymbol(-1);
	} else {
		result.setIntegerSymbol(Integer.valueOf(string));
	}
	return result;
}

private RealLiteralExpCS createRealLiteralExpCS(String string) {
	RealLiteralExpCS result = CSTFactory.eINSTANCE.createRealLiteralExpCS();
	result.setSymbol(string);
	result.setRealSymbol(Double.valueOf(string));
	return result;
}

private StringLiteralExpCS createStringLiteralExpCS(String string) {
	StringLiteralExpCS result = CSTFactory.eINSTANCE.createStringLiteralExpCS();
	result.setSymbol(string);
	result.setStringSymbol(string);
	return result;
}

private BooleanLiteralExpCS createBooleanLiteralExpCS(String string) {
	BooleanLiteralExpCS result = CSTFactory.eINSTANCE.createBooleanLiteralExpCS();
	result.setSymbol(string);
	result.setBooleanSymbol(Boolean.valueOf(string));
	return result;
}

private NullLiteralExpCS createNullLiteralExpCS(String string) {
	NullLiteralExpCS result = CSTFactory.eINSTANCE.createNullLiteralExpCS();
	result.setSymbol(string);
	return result;
}

private InvalidLiteralExpCS createInvalidLiteralExpCS(String string) {
	InvalidLiteralExpCS result = CSTFactory.eINSTANCE.createInvalidLiteralExpCS();
	result.setSymbol(string);
	return result;
}

private IteratorExpCS createIteratorExpCS(
		SimpleNameCS simpleNameCS,
		VariableCS variable1,
		VariableCS variable2,
		OCLExpressionCS oclExpressionCS) {
	IteratorExpCS result = CSTFactory.eINSTANCE.createIteratorExpCS();
	result.setSimpleNameCS(simpleNameCS);
	result.setVariable1(variable1);
	result.setVariable2(variable2);
	result.setBody(oclExpressionCS);
	return result;
}

private IterateExpCS createIterateExpCS(
		SimpleNameCS simpleNameCS,
		VariableCS variable1,
		VariableCS variable2,
		OCLExpressionCS oclExpressionCS) {
	IterateExpCS result = CSTFactory.eINSTANCE.createIterateExpCS();
	result.setSimpleNameCS(simpleNameCS);
	result.setVariable1(variable1);
	result.setVariable2(variable2);
	result.setBody(oclExpressionCS);
	return result;
}

private VariableCS createVariableCS(
		String varName,
		TypeCS typeCS,
		OCLExpressionCS oclExpressionCS) {
	VariableCS result = CSTFactory.eINSTANCE.createVariableCS();
	result.setName(unquote(varName));
	result.setTypeCS(typeCS);
	result.setInitExpression(oclExpressionCS);
	return result;
}

private CollectionTypeCS createCollectionTypeCS(
		CollectionTypeIdentifierEnum collectionType,
		TypeCS typeCS) {
	CollectionTypeCS result = CSTFactory.eINSTANCE.createCollectionTypeCS();
	result.setCollectionTypeIdentifier(collectionType);
	result.setTypeCS(typeCS);
	return result;
}

private TupleTypeCS createTupleTypeCS(EList<VariableCS> variables) {
	TupleTypeCS result = CSTFactory.eINSTANCE.createTupleTypeCS();
	result.getVariables().addAll(variables);
	return result;
}

private FeatureCallExpCS createFeatureCallExpCS(
		SimpleNameCS simpleNameCS,
		EList<OCLExpressionCS> arguments,
		IsMarkedPreCS isMarkedPreCS) {
	FeatureCallExpCS result = CSTFactory.eINSTANCE.createFeatureCallExpCS();
	result.setSimpleNameCS(simpleNameCS);
	result.getArguments().addAll(arguments);
	result.setIsMarkedPreCS(isMarkedPreCS);
	return result;
}

private IsMarkedPreCS createIsMarkedPreCS(boolean isMarkedPre) {
	IsMarkedPreCS result = CSTFactory.eINSTANCE.createIsMarkedPreCS();
	result.setPre(isMarkedPre);
	return result;
}

private LetExpCS createLetExpCS(
		EList<VariableCS> variables,
		OCLExpressionCS oclExpressionCS) {
	LetExpCS result = CSTFactory.eINSTANCE.createLetExpCS();
	result.getVariables().addAll(variables);
	result.setInExpression(oclExpressionCS);
	return result;
}

private IfExpCS createIfExpCS(
		OCLExpressionCS condition,
		OCLExpressionCS thenExpression,
		OCLExpressionCS elseExpression) {
	IfExpCS result = CSTFactory.eINSTANCE.createIfExpCS();
	result.setCondition(condition);
	result.setThenExpression(thenExpression);
	result.setElseExpression(elseExpression);
	return result;
}

private MessageExpCS createMessageExpCS(
		boolean hasSent,
		SimpleNameCS simpleNameCS,
		EList<OCLMessageArgCS> oclMessageArgs) {
	MessageExpCS result = CSTFactory.eINSTANCE.createMessageExpCS();
	result.setKind(hasSent ? MessageExpKind.HAS_SENT_LITERAL : MessageExpKind.SENT_LITERAL);
	result.setSimpleNameCS(simpleNameCS);
	result.getArguments().addAll(oclMessageArgs);
	return result;
}

private OCLMessageArgCS createOCLMessageArgCS(
		TypeCS typeCS,
		OCLExpressionCS oclExpressionCS) {
	OCLMessageArgCS result = CSTFactory.eINSTANCE.createOCLMessageArgCS();
	result.setTypeCS(typeCS);
	result.setExpression(oclExpressionCS);
	return result;
}

/**
 * Sets the start and end offsets of the given <code>CSTNode</code>
 * to the start and end offsets of the given <code>IToken</code>
 *
 * @@param cstNode <code>CSTNode</code> to set offsets
 * @@param startEnd <code>IToken</code> to retrieve offsets from
 */
private void setOffsets(CSTNode cstNode, IToken startEnd) {
	cstNode.setStartOffset(startEnd.getStartOffset());
	cstNode.setEndOffset(startEnd.getEndOffset());
}

/**
 * Sets the start and end offsets of the given <code>CSTNode</code>
 * to the start and end offsets of the 2nd given <code>CSTNode</code>
 *
 * @@param cstNode <code>CSTNode</code> to set offsets
 * @@param startEnd <code>CSTNode</code> to retrieve offsets from
 */
private void setOffsets(CSTNode cstNode, CSTNode startEnd) {
	cstNode.setStartOffset(startEnd.getStartOffset());
	cstNode.setEndOffset(startEnd.getEndOffset());
}

/**
 * Sets the start and end offsets of the given <code>CSTNode</code>
 * to the start offset of the 2nd given <code>CSTNode</code> and the
 * end offset of the 3rd given <code>CSTNode</code>
 *
 * @@param cstNode <code>CSTNode</code> to set offsets
 * @@param start <code>CSTNode</code> to retrieve start offset from
 * @@param end <code>CSTNode</code> to retrieve end offset from
 */
private void setOffsets(CSTNode cstNode, CSTNode start, CSTNode end) {
	cstNode.setStartOffset(start.getStartOffset());
	cstNode.setEndOffset(end.getEndOffset());
}

/**
 * Sets the start and end offsets of the given <code>CSTNode</code>
 * to the start offset of the 2nd given <code>CSTNode</code> and the
 * end offset of the given <code>IToken</code>
 *
 * @@param cstNode <code>CSTNode</code> to set offsets
 * @@param start <code>CSTNode</code> to retrieve start offset from
 * @@param end <code>IToken</code> to retrieve end offset from
 */
private void setOffsets(CSTNode cstNode, CSTNode start, IToken end) {
	cstNode.setStartOffset(start.getStartOffset());
	cstNode.setEndOffset(end.getEndOffset());
}

/**
 * Sets the start and end offsets of the given <code>CSTNode</code>
 * to the start offset of the given <code>IToken</code> and the
 * end offset of the 2nd given <code>CSTNode</code>
 *
 * @@param cstNode <code>CSTNode</code> to set offsets
 * @@param start <code>IToken</code> to retrieve start offset from
 * @@param end <code>CSTNode</code> to retrieve end offset from
 */
private void setOffsets(CSTNode cstNode, IToken start, CSTNode end) {
	cstNode.setStartOffset(start.getStartOffset());
	cstNode.setEndOffset(end.getEndOffset());
}

/**
 * Sets the start and end offsets of the given <code>CSTNode</code>
 * to the start offset of the 1std given <code>IToken</code> and the
 * end offset of the 2nd given <code>IToken</code>
 *
 * @@param cstNode <code>CSTNode</code> to set offsets
 * @@param start <code>IToken</code> to retrieve start offset from
 * @@param end <code>IToken</code> to retrieve end offset from
 */
private void setOffsets(CSTNode cstNode, IToken start, IToken end) {
	cstNode.setStartOffset(start.getStartOffset());
	cstNode.setEndOffset(end.getEndOffset());
}

/**
 * Removes the "s surrounding a quoted string, if any.
 * 
 * @@param quoted a possibly quoted string
 * @@return <code>quoted</code> without the surrounding quotes, or just
 *	 <code>quoted</code> verbatim if there were none
 */
private String unquote(String quoted) {
	String result = quoted;

	if ((result != null) && (result.length() > 1)) {
		int max = result.length() - 1;

		if ((result.charAt(0) == '"') && (quoted.charAt(max) == '"')) {
			result = result.substring(1, max);
d453 301
a753 1891
		
		// this is a regexp, so the backslash needs to be
		//   re-escaped, thus "\\" is rendered in a Java
		//   string literal as "\\\\"
		result = result.replaceAll("\\\\\"", "\"");  //$NON-NLS-2$//$NON-NLS-1$
		/*
		 * [artem] removed extra error handling fon non-spec escape processing 
		 */
	}

	return result;
}

	@@SuppressWarnings("unchecked")
	public void ruleAction(int ruleNumber)
	{
		switch (ruleNumber) {
		
 
			//
			// Rule 26:  operationCS1 ::= IDENTIFIER ( parametersCSopt ) : typeCSopt
			//
			case 26: {
				
				CSTNode result = createOperationCS(
						getTokenText(dtParser.getToken(1)),
						(EList)dtParser.getSym(3),
						(TypeCS)dtParser.getSym(6)
					);
				if (dtParser.getSym(6) != null) {
					setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(6));
				} else {
					setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(5)));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 27:  operationCS2 ::= pathNameCS :: simpleNameCS ( parametersCSopt ) : typeCSopt
			//
			case 27: {
				
				CSTNode result = createOperationCS(
						(PathNameCS)dtParser.getSym(1),
						(SimpleNameCS)dtParser.getSym(3),
						(EList)dtParser.getSym(5),
						(TypeCS)dtParser.getSym(8)
					);
				if (dtParser.getSym(8) != null) {
					setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(8));
				} else {
					setOffsets(result, (CSTNode)dtParser.getSym(1), getIToken(dtParser.getToken(7)));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 28:  parametersCSopt ::= $Empty
			//
			case 28:
				dtParser.setSym1(new BasicEList());
				break;
 
			//
			// Rule 30:  parametersCS ::= variableCS
			//
			case 30: {
				
				EList result = new BasicEList();
				result.add(dtParser.getSym(1));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 31:  parametersCS ::= parametersCS , variableCS
			//
			case 31: {
				
				EList result = (EList)dtParser.getSym(1);
				result.add(dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 32:  simpleNameCSopt ::= $Empty
			//
			case 32:
				dtParser.setSym1(null);
				break;
 
			//
			// Rule 38:  impliesExpCS ::= impliesExpCS implies andOrXorExpCS
			//
			case 38:
 
			//
			// Rule 39:  impliesWithLet ::= impliesExpCS implies andOrXorWithLet
			//
			case 39:
 
			//
			// Rule 42:  andOrXorExpCS ::= andOrXorExpCS and equalityExpCS
			//
			case 42:
 
			//
			// Rule 43:  andOrXorExpCS ::= andOrXorExpCS or equalityExpCS
			//
			case 43:
 
			//
			// Rule 44:  andOrXorExpCS ::= andOrXorExpCS xor equalityExpCS
			//
			case 44:
 
			//
			// Rule 45:  andOrXorWithLet ::= andOrXorExpCS and equalityWithLet
			//
			case 45:
 
			//
			// Rule 46:  andOrXorWithLet ::= andOrXorExpCS or equalityWithLet
			//
			case 46:
 
			//
			// Rule 47:  andOrXorWithLet ::= andOrXorExpCS xor equalityWithLet
			//
			case 47: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							getTokenText(dtParser.getToken(2))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 50:  equalityExpCS ::= equalityExpCS = relationalExpCS
			//
			case 50:
 
			//
			// Rule 51:  equalityWithLet ::= equalityExpCS = relationalWithLet
			//
			case 51: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.EQUAL)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 52:  equalityExpCS ::= equalityExpCS <> relationalExpCS
			//
			case 52:
 
			//
			// Rule 53:  equalityWithLet ::= equalityExpCS <> relationalWithLet
			//
			case 53: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.NOT_EQUAL)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 56:  relationalExpCS ::= relationalExpCS > ifExpCSPrec
			//
			case 56:
 
			//
			// Rule 57:  relationalWithLet ::= relationalExpCS > additiveWithLet
			//
			case 57: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.GREATER_THAN)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 58:  relationalExpCS ::= relationalExpCS < ifExpCSPrec
			//
			case 58:
 
			//
			// Rule 59:  relationalWithLet ::= relationalExpCS < additiveWithLet
			//
			case 59: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.LESS_THAN)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 60:  relationalExpCS ::= relationalExpCS >= ifExpCSPrec
			//
			case 60:
 
			//
			// Rule 61:  relationalWithLet ::= relationalExpCS >= additiveWithLet
			//
			case 61: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.GREATER_THAN_EQUAL)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 62:  relationalExpCS ::= relationalExpCS <= ifExpCSPrec
			//
			case 62:
 
			//
			// Rule 63:  relationalWithLet ::= relationalExpCS <= additiveWithLet
			//
			case 63: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.LESS_THAN_EQUAL)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 68:  additiveExpCS ::= additiveExpCS + multiplicativeExpCS
			//
			case 68:
 
			//
			// Rule 69:  additiveWithLet ::= additiveExpCS + multiplicativeWithLet
			//
			case 69: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.PLUS)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 70:  additiveExpCS ::= additiveExpCS - multiplicativeExpCS
			//
			case 70:
 
			//
			// Rule 71:  additiveWithLet ::= additiveExpCS - multiplicativeWithLet
			//
			case 71: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.MINUS)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 74:  multiplicativeExpCS ::= multiplicativeExpCS * unaryExpCS
			//
			case 74:
 
			//
			// Rule 75:  multiplicativeWithLet ::= multiplicativeExpCS * unaryWithLet
			//
			case 75: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.TIMES)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 76:  multiplicativeExpCS ::= multiplicativeExpCS / unaryExpCS
			//
			case 76:
 
			//
			// Rule 77:  multiplicativeWithLet ::= multiplicativeExpCS / unaryWithLet
			//
			case 77: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.DIVIDE)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(2)));
				EList args = new BasicEList();
				args.add(dtParser.getSym(3));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(1),
						simpleNameCS,
						args
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 80:  unaryExpCS ::= - unaryExpCS
			//
			case 80: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							OCLStandardLibraryUtil.getOperationName(PredefinedType.MINUS)
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(2),
						simpleNameCS,
						new BasicEList()
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(2));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 81:  unaryExpCS ::= not unaryExpCS
			//
			case 81: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.STRING_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createOperationCallExpCS(
						(OCLExpressionCS)dtParser.getSym(2),
						simpleNameCS,
						new BasicEList()
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(2));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 83:  dotArrowExpCS ::= dotArrowExpCS callExpCS
			//
			case 83: {
				
				CallExpCS result = (CallExpCS)dtParser.getSym(2);
				result.setSource((OCLExpressionCS)dtParser.getSym(1));
				setOffsets(result, (CSTNode)dtParser.getSym(1), result);
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 84:  dotArrowExpCS ::= dotArrowExpCS messageExpCS
			//
			case 84: {
				
				MessageExpCS result = (MessageExpCS)dtParser.getSym(2);
				result.setTarget((OCLExpressionCS)dtParser.getSym(1));
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(2));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 85:  dotArrowExpCS ::= NUMERIC_OPERATION ( argumentsCSopt )
			//
			case 85: {
				
				// NUMERIC_OPERATION -> Integer '.' Identifier
				String text = getTokenText(dtParser.getToken(1));
				int index = text.indexOf('.');
				String integer = text.substring(0, index);
				String simpleName = text.substring(index + 1);

				// create the IntegerLiteralExpCS
				int startOffset = getIToken(dtParser.getToken(1)).getStartOffset();
				int endOffset = startOffset + integer.length() - 1; // inclusive

				IntegerLiteralExpCS integerLiteralExpCS = createIntegerLiteralExpCS(integer);
				integerLiteralExpCS.setStartOffset(startOffset);
				integerLiteralExpCS.setEndOffset(endOffset);

				startOffset = endOffset + 2; // end of integerLiteral + 1('.') + 1(start of simpleName)
				endOffset = getIToken(dtParser.getToken(1)).getEndOffset();

				// create the SimpleNameCS
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.IDENTIFIER_LITERAL,
							simpleName
						);
				simpleNameCS.setStartOffset(startOffset);
				simpleNameCS.setEndOffset(endOffset);

				// create the OperationCallExpCS
				CSTNode result = createOperationCallExpCS(
						integerLiteralExpCS,
						simpleNameCS,
						(EList)dtParser.getSym(3)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(4)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 86:  dotArrowExpCS ::= pathNameCS :: simpleNameCS ( argumentsCSopt )
			//
			case 86: {
				
				OperationCallExpCS result = createOperationCallExpCS(
						(PathNameCS)dtParser.getSym(1),
						(SimpleNameCS)dtParser.getSym(3),
						(EList)dtParser.getSym(5)
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), getIToken(dtParser.getToken(6)));
				result.setAccessor(DotOrArrowEnum.DOT_LITERAL);
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 91:  oclExpCS ::= ( oclExpressionCS )
			//
			case 91: {
				
				CSTNode result = (CSTNode)dtParser.getSym(2);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(3)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 92:  variableExpCS ::= simpleNameCS isMarkedPreCS
			//
			case 92: {
				
				IsMarkedPreCS isMarkedPreCS = (IsMarkedPreCS)dtParser.getSym(2);
				CSTNode result = createVariableExpCS(
						(SimpleNameCS)dtParser.getSym(1),
						new BasicEList(),
						isMarkedPreCS
					);
				if (isMarkedPreCS.isPre()) {
					setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(2));
				} else {
					setOffsets(result, (CSTNode)dtParser.getSym(1));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 93:  variableExpCS ::= keywordAsIdentifier1 isMarkedPreCS
			//
			case 93: {
				
				IsMarkedPreCS isMarkedPreCS = (IsMarkedPreCS)dtParser.getSym(2);
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.IDENTIFIER_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createVariableExpCS(
						simpleNameCS,
						new BasicEList(),
						isMarkedPreCS
					);
				if (isMarkedPreCS.isPre()) {
					setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(2));
				} else {
					setOffsets(result, getIToken(dtParser.getToken(1)));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 94:  variableExpCS ::= simpleNameCS [ argumentsCS ] isMarkedPreCS
			//
			case 94: {
				
				IsMarkedPreCS isMarkedPreCS = (IsMarkedPreCS)dtParser.getSym(5);
				CSTNode result = createVariableExpCS(
						(SimpleNameCS)dtParser.getSym(1),
						(EList)dtParser.getSym(3),
						isMarkedPreCS
					);
				if (isMarkedPreCS.isPre()) {
					setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(5));
				} else {
					setOffsets(result, (CSTNode)dtParser.getSym(1), getIToken(dtParser.getToken(4)));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 95:  variableExpCS ::= keywordAsIdentifier1 [ argumentsCS ] isMarkedPreCS
			//
			case 95: {
				
				IsMarkedPreCS isMarkedPreCS = (IsMarkedPreCS)dtParser.getSym(5);
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.IDENTIFIER_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createVariableExpCS(
						(SimpleNameCS)dtParser.getSym(1),
						(EList)dtParser.getSym(3),
						isMarkedPreCS
					);
				if (isMarkedPreCS.isPre()) {
					setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(5));
				} else {
					setOffsets(result, (CSTNode)dtParser.getSym(1), getIToken(dtParser.getToken(4)));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 97:  simpleNameCS ::= self
			//
			case 97: {
				
				CSTNode result = createSimpleNameCS(
						SimpleTypeEnum.SELF_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 98:  simpleNameCS ::= IDENTIFIER
			//
			case 98: {
				
				CSTNode result = createSimpleNameCS(
						SimpleTypeEnum.IDENTIFIER_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 99:  primitiveTypeCS ::= Integer
			//
			case 99: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.INTEGER_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 100:  primitiveTypeCS ::= UnlimitedNatural
			//
			case 100: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.UNLIMITED_NATURAL_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 101:  primitiveTypeCS ::= String
			//
			case 101: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.STRING_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 102:  primitiveTypeCS ::= Real
			//
			case 102: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.REAL_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 103:  primitiveTypeCS ::= Boolean
			//
			case 103: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.BOOLEAN_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 104:  primitiveTypeCS ::= OclAny
			//
			case 104: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.OCL_ANY_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 105:  primitiveTypeCS ::= OclVoid
			//
			case 105: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.OCL_VOID_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 106:  primitiveTypeCS ::= Invalid
			//
			case 106: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.INVALID_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 107:  primitiveTypeCS ::= OclMessage
			//
			case 107: {
				
				CSTNode result = createPrimitiveTypeCS(
						SimpleTypeEnum.OCL_MESSAGE_LITERAL,
						getTokenText(dtParser.getToken(1))
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 108:  pathNameCS ::= IDENTIFIER
			//
			case 108: {
				
				CSTNode result = createPathNameCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 109:  pathNameCS ::= pathNameCS :: simpleNameCS
			//
			case 109: {
				
				PathNameCS result = (PathNameCS)dtParser.getSym(1);
				result = extendPathNameCS(result, getTokenText(dtParser.getToken(3)));
				setOffsets(result, result, (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 110:  pathNameCSOpt ::= $Empty
			//
			case 110: {
				
				CSTNode result = createPathNameCS();
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 118:  enumLiteralExpCS ::= pathNameCS :: keywordAsIdentifier
			//
			case 118: {
				
				CSTNode result = createEnumLiteralExpCS(
						(PathNameCS)dtParser.getSym(1),
						getTokenText(dtParser.getToken(3))
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), getIToken(dtParser.getToken(3)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 119:  enumLiteralExpCS ::= pathNameCS :: simpleNameCS
			//
			case 119: {
				
				CSTNode result = createEnumLiteralExpCS(
						(PathNameCS)dtParser.getSym(1),
						(SimpleNameCS)dtParser.getSym(3)
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 120:  collectionLiteralExpCS ::= collectionTypeIdentifierCS { collectionLiteralPartsCSopt }
			//
			case 120: {
				
				Object[] objs = (Object[])dtParser.getSym(1);
				CSTNode result = createCollectionLiteralExpCS(
						(CollectionTypeIdentifierEnum)objs[1],
						(EList)dtParser.getSym(3)
					);
				setOffsets(result, (IToken)objs[0], getIToken(dtParser.getToken(4)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 121:  collectionTypeIdentifierCS ::= Set
			//
			case 121: {
				
				dtParser.setSym1(new Object[]{getIToken(dtParser.getToken(1)), CollectionTypeIdentifierEnum.SET_LITERAL});
	  		  break;
			}
	 
			//
			// Rule 122:  collectionTypeIdentifierCS ::= Bag
			//
			case 122: {
				
				dtParser.setSym1(new Object[]{getIToken(dtParser.getToken(1)), CollectionTypeIdentifierEnum.BAG_LITERAL});
	  		  break;
			}
	 
			//
			// Rule 123:  collectionTypeIdentifierCS ::= Sequence
			//
			case 123: {
				
				dtParser.setSym1(new Object[]{getIToken(dtParser.getToken(1)), CollectionTypeIdentifierEnum.SEQUENCE_LITERAL});
	  		  break;
			}
	 
			//
			// Rule 124:  collectionTypeIdentifierCS ::= Collection
			//
			case 124: {
				
				dtParser.setSym1(new Object[]{getIToken(dtParser.getToken(1)), CollectionTypeIdentifierEnum.COLLECTION_LITERAL});
	  		  break;
			}
	 
			//
			// Rule 125:  collectionTypeIdentifierCS ::= OrderedSet
			//
			case 125: {
				
				dtParser.setSym1(new Object[]{getIToken(dtParser.getToken(1)), CollectionTypeIdentifierEnum.ORDERED_SET_LITERAL});
	  		  break;
			}
	 
			//
			// Rule 126:  collectionLiteralPartsCSopt ::= $Empty
			//
			case 126:
				dtParser.setSym1(new BasicEList());
				break;
 
			//
			// Rule 128:  collectionLiteralPartsCS ::= collectionLiteralPartCS
			//
			case 128: {
				
				EList result = new BasicEList();
				result.add(dtParser.getSym(1));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 129:  collectionLiteralPartsCS ::= collectionLiteralPartsCS , collectionLiteralPartCS
			//
			case 129: {
				
				EList result = (EList)dtParser.getSym(1);
				result.add(dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 131:  collectionLiteralPartCS ::= oclExpressionCS
			//
			case 131: {
				
				CSTNode result = createCollectionLiteralPartCS(
						(OCLExpressionCS)dtParser.getSym(1)
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 132:  collectionRangeCS ::= - INTEGER_RANGE_START oclExpressionCS
			//
			case 132: {
				
				OCLExpressionCS rangeStart = createRangeStart(
						getTokenText(dtParser.getToken(2)), true);
				CSTNode result = createCollectionRangeCS(
						rangeStart,
						(OCLExpressionCS)dtParser.getSym(3)
					);
				setOffsets(result, rangeStart, (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 133:  collectionRangeCS ::= INTEGER_RANGE_START oclExpressionCS
			//
			case 133: {
				
				OCLExpressionCS rangeStart = createRangeStart(
						getTokenText(dtParser.getToken(1)), false);
				CSTNode result = createCollectionRangeCS(
						rangeStart,
						(OCLExpressionCS)dtParser.getSym(2)
					);
				setOffsets(result, rangeStart, (CSTNode)dtParser.getSym(2));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 134:  collectionRangeCS ::= oclExpressionCS .. oclExpressionCS
			//
			case 134: {
				
				CSTNode result = createCollectionRangeCS(
						(OCLExpressionCS)dtParser.getSym(1),
						(OCLExpressionCS)dtParser.getSym(3)
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 140:  tupleLiteralExpCS ::= Tuple { variableListCS2 }
			//
			case 140: {
				
				CSTNode result = createTupleLiteralExpCS((EList)dtParser.getSym(3));
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(4)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 141:  integerLiteralExpCS ::= INTEGER_LITERAL
			//
			case 141: {
				
				CSTNode result = createIntegerLiteralExpCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 142:  unlimitedNaturalLiteralExpCS ::= *
			//
			case 142: {
				
				CSTNode result = createUnlimitedNaturalLiteralExpCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 143:  realLiteralExpCS ::= REAL_LITERAL
			//
			case 143: {
				
				CSTNode result = createRealLiteralExpCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 144:  stringLiteralExpCS ::= STRING_LITERAL
			//
			case 144: {
				
				CSTNode result = createStringLiteralExpCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 145:  booleanLiteralExpCS ::= true
			//
			case 145: {
				
				CSTNode result = createBooleanLiteralExpCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 146:  booleanLiteralExpCS ::= false
			//
			case 146: {
				
				CSTNode result = createBooleanLiteralExpCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 147:  nullLiteralExpCS ::= null
			//
			case 147: {
				
				CSTNode result = createNullLiteralExpCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 148:  invalidLiteralExpCS ::= OclInvalid
			//
			case 148: {
				
				CSTNode result = createInvalidLiteralExpCS(getTokenText(dtParser.getToken(1)));
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 149:  callExpCS ::= -> featureCallExpCS
			//
			case 149:
 
			//
			// Rule 150:  callExpCS ::= -> loopExpCS
			//
			case 150: {
				
				CallExpCS result = (CallExpCS)dtParser.getSym(2);
				result.setAccessor(DotOrArrowEnum.ARROW_LITERAL);
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 151:  callExpCS ::= . keywordOperationCallExpCS
			//
			case 151:
 
			//
			// Rule 152:  callExpCS ::= . featureCallExpCS
			//
			case 152: {
				
				CallExpCS result = (CallExpCS)dtParser.getSym(2);
				result.setAccessor(DotOrArrowEnum.DOT_LITERAL);
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 155:  iteratorExpCS ::= forAll ( iterContents )
			//
			case 155:
 
			//
			// Rule 156:  iteratorExpCS ::= exists ( iterContents )
			//
			case 156:
 
			//
			// Rule 157:  iteratorExpCS ::= isUnique ( iterContents )
			//
			case 157:
 
			//
			// Rule 158:  iteratorExpCS ::= one ( iterContents )
			//
			case 158:
 
			//
			// Rule 159:  iteratorExpCS ::= any ( iterContents )
			//
			case 159:
 
			//
			// Rule 160:  iteratorExpCS ::= collect ( iterContents )
			//
			case 160:
 
			//
			// Rule 161:  iteratorExpCS ::= select ( iterContents )
			//
			case 161:
 
			//
			// Rule 162:  iteratorExpCS ::= reject ( iterContents )
			//
			case 162:
 
			//
			// Rule 163:  iteratorExpCS ::= collectNested ( iterContents )
			//
			case 163:
 
			//
			// Rule 164:  iteratorExpCS ::= sortedBy ( iterContents )
			//
			case 164:
 
			//
			// Rule 165:  iteratorExpCS ::= closure ( iterContents )
			//
			case 165: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.KEYWORD_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				Object[] iterContents = (Object[])dtParser.getSym(3);
				CSTNode result = createIteratorExpCS(
						simpleNameCS,
						(VariableCS)iterContents[0],
						(VariableCS)iterContents[1],
						(OCLExpressionCS)iterContents[2]
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(4)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 166:  iterContents ::= oclExpressionCS
			//
			case 166: {
				
				dtParser.setSym1(new Object[] {
						null,
						null,
						dtParser.getSym(1)
					});
	  		  break;
			}
	 
			//
			// Rule 167:  iterContents ::= variableCS | oclExpressionCS
			//
			case 167: {
				
				dtParser.setSym1(new Object[] {
						dtParser.getSym(1),
						null,
						dtParser.getSym(3)
					});
	  		  break;
			}
	 
			//
			// Rule 168:  iterContents ::= variableCS , variableCS | oclExpressionCS
			//
			case 168: {
				
				dtParser.setSym1(new Object[] {
						dtParser.getSym(1),
						dtParser.getSym(3),
						dtParser.getSym(5)
					});
	  		  break;
			}
	 
			//
			// Rule 169:  iterateExpCS ::= iterate ( variableCS | oclExpressionCS )
			//
			case 169: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.KEYWORD_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createIterateExpCS(
						simpleNameCS,
						(VariableCS)dtParser.getSym(3),
						null,
						(OCLExpressionCS)dtParser.getSym(5)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(6)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 170:  iterateExpCS ::= iterate ( variableCS ; variableCS | oclExpressionCS )
			//
			case 170: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.KEYWORD_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createIterateExpCS(
						simpleNameCS,
						(VariableCS)dtParser.getSym(3),
						(VariableCS)dtParser.getSym(5),
						(OCLExpressionCS)dtParser.getSym(7)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(8)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 171:  variableCS ::= IDENTIFIER
			//
			case 171: {
				
				CSTNode result = createVariableCS(
						getTokenText(dtParser.getToken(1)),
						null,
						null
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 172:  variableCS ::= IDENTIFIER : typeCS
			//
			case 172: {
				
				CSTNode result = createVariableCS(
						getTokenText(dtParser.getToken(1)),
						(TypeCS)dtParser.getSym(3),
						null
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 173:  variableCS ::= IDENTIFIER : typeCS = oclExpressionCS
			//
			case 173: {
				
				CSTNode result = createVariableCS(
						getTokenText(dtParser.getToken(1)),
						(TypeCS)dtParser.getSym(3),
						(OCLExpressionCS)dtParser.getSym(5)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(5));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 174:  variableCS2 ::= IDENTIFIER = oclExpressionCS
			//
			case 174: {
				
				CSTNode result = createVariableCS(
						getTokenText(dtParser.getToken(1)),
						null,
						(OCLExpressionCS)dtParser.getSym(3)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 175:  typeCSopt ::= $Empty
			//
			case 175:
				dtParser.setSym1(null);
				break;
 
			//
			// Rule 181:  collectionTypeCS ::= collectionTypeIdentifierCS ( typeCS )
			//
			case 181: {
				
				Object[] objs = (Object[])dtParser.getSym(1);
				CSTNode result = createCollectionTypeCS(
						(CollectionTypeIdentifierEnum)objs[1],
						(TypeCS)dtParser.getSym(3)
					);
				setOffsets(result, (IToken)objs[0], getIToken(dtParser.getToken(4)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 182:  tupleTypeCS ::= Tuple ( variableListCSopt )
			//
			case 182: {
				
				CSTNode result = createTupleTypeCS((EList)dtParser.getSym(3));
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(4)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 183:  variableListCSopt ::= $Empty
			//
			case 183:
				dtParser.setSym1(new BasicEList());
				break;
 
			//
			// Rule 185:  variableListCS ::= variableCS
			//
			case 185: {
				
				EList result = new BasicEList();
				result.add(dtParser.getSym(1));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 186:  variableListCS ::= variableListCS , variableCS
			//
			case 186: {
				
				EList result = (EList)dtParser.getSym(1);
				result.add(dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 187:  variableListCS2 ::= variableCS2
			//
			case 187:
 
			//
			// Rule 188:  variableListCS2 ::= variableCS
			//
			case 188: {
				
				EList result = new BasicEList();
				result.add(dtParser.getSym(1));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 189:  variableListCS2 ::= variableListCS2 , variableCS2
			//
			case 189:
 
			//
			// Rule 190:  variableListCS2 ::= variableListCS2 , variableCS
			//
			case 190: {
				
				EList result = (EList)dtParser.getSym(1);
				result.add(dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 193:  featureCallExpCS ::= MINUS isMarkedPreCS ( argumentsCSopt )
			//
			case 193:
 
			//
			// Rule 194:  featureCallExpCS ::= not isMarkedPreCS ( argumentsCSopt )
			//
			case 194: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.IDENTIFIER_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createOperationCallExpCS(
						simpleNameCS,
						(IsMarkedPreCS)dtParser.getSym(2),
						(EList)dtParser.getSym(4)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(5)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 195:  operationCallExpCS ::= simpleNameCS isMarkedPreCS ( argumentsCSopt )
			//
			case 195: {
				
				CSTNode result = createOperationCallExpCS(
						(SimpleNameCS)dtParser.getSym(1),
						(IsMarkedPreCS)dtParser.getSym(2),
						(EList)dtParser.getSym(4)
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1), getIToken(dtParser.getToken(5)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 196:  operationCallExpCS ::= oclIsUndefined isMarkedPreCS ( argumentsCSopt )
			//
			case 196:
 
			//
			// Rule 197:  operationCallExpCS ::= oclIsInvalid isMarkedPreCS ( argumentsCSopt )
			//
			case 197:
 
			//
			// Rule 198:  operationCallExpCS ::= oclIsNew isMarkedPreCS ( argumentsCSopt )
			//
			case 198:
 
			//
			// Rule 199:  operationCallExpCS ::= oclAsType isMarkedPreCS ( argumentsCSopt )
			//
			case 199:
 
			//
			// Rule 200:  operationCallExpCS ::= oclIsKindOf isMarkedPreCS ( argumentsCSopt )
			//
			case 200:
 
			//
			// Rule 201:  operationCallExpCS ::= oclIsTypeOf isMarkedPreCS ( argumentsCSopt )
			//
			case 201:
 
			//
			// Rule 202:  operationCallExpCS ::= EQUAL isMarkedPreCS ( argumentsCSopt )
			//
			case 202:
 
			//
			// Rule 203:  operationCallExpCS ::= NOT_EQUAL isMarkedPreCS ( argumentsCSopt )
			//
			case 203:
 
			//
			// Rule 204:  operationCallExpCS ::= PLUS isMarkedPreCS ( argumentsCSopt )
			//
			case 204:
 
			//
			// Rule 205:  operationCallExpCS ::= MULTIPLY isMarkedPreCS ( argumentsCSopt )
			//
			case 205:
 
			//
			// Rule 206:  operationCallExpCS ::= DIVIDE isMarkedPreCS ( argumentsCSopt )
			//
			case 206:
 
			//
			// Rule 207:  operationCallExpCS ::= GREATER isMarkedPreCS ( argumentsCSopt )
			//
			case 207:
 
			//
			// Rule 208:  operationCallExpCS ::= LESS isMarkedPreCS ( argumentsCSopt )
			//
			case 208:
 
			//
			// Rule 209:  operationCallExpCS ::= GREATER_EQUAL isMarkedPreCS ( argumentsCSopt )
			//
			case 209:
 
			//
			// Rule 210:  operationCallExpCS ::= LESS_EQUAL isMarkedPreCS ( argumentsCSopt )
			//
			case 210:
 
			//
			// Rule 211:  operationCallExpCS ::= and isMarkedPreCS ( argumentsCSopt )
			//
			case 211:
 
			//
			// Rule 212:  operationCallExpCS ::= or isMarkedPreCS ( argumentsCSopt )
			//
			case 212:
 
			//
			// Rule 213:  operationCallExpCS ::= xor isMarkedPreCS ( argumentsCSopt )
			//
			case 213:
 
			//
			// Rule 214:  keywordOperationCallExpCS ::= keywordAsIdentifier isMarkedPreCS ( argumentsCSopt )
			//
			case 214: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.IDENTIFIER_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createOperationCallExpCS(
						simpleNameCS,
						(IsMarkedPreCS)dtParser.getSym(2),
						(EList)dtParser.getSym(4)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(5)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 215:  operationCallExpCS ::= oclIsInState isMarkedPreCS ( pathNameCSOpt )
			//
			case 215: {
				
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.KEYWORD_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));

				PathNameCS pathNameCS = (PathNameCS) dtParser.getSym(4);
				StateExpCS stateExpCS = createStateExpCS(pathNameCS);
				setOffsets(stateExpCS, pathNameCS);
			
				CSTNode result = createOperationCallExpCS(
						simpleNameCS,
						(IsMarkedPreCS)dtParser.getSym(2),
						stateExpCS
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(5)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 216:  attrOrNavCallExpCS ::= simpleNameCS isMarkedPreCS
			//
			case 216: {
				
				IsMarkedPreCS isMarkedPreCS = (IsMarkedPreCS)dtParser.getSym(2);
				CSTNode result = createFeatureCallExpCS(
						(SimpleNameCS)dtParser.getSym(1),
						new BasicEList(),
						isMarkedPreCS
					);
				if (isMarkedPreCS.isPre()) {
					setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(2));
				} else {
					setOffsets(result, (CSTNode)dtParser.getSym(1));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 217:  attrOrNavCallExpCS ::= keywordAsIdentifier isMarkedPreCS
			//
			case 217: {
				
				IsMarkedPreCS isMarkedPreCS = (IsMarkedPreCS)dtParser.getSym(2);
				SimpleNameCS simpleNameCS = createSimpleNameCS(
							SimpleTypeEnum.IDENTIFIER_LITERAL,
							getTokenText(dtParser.getToken(1))
						);
				setOffsets(simpleNameCS, getIToken(dtParser.getToken(1)));
				CSTNode result = createFeatureCallExpCS(
						simpleNameCS,
						new BasicEList(),
						isMarkedPreCS
					);
				if (isMarkedPreCS.isPre()) {
					setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(2));
				} else {
					setOffsets(result, getIToken(dtParser.getToken(1)));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 218:  attrOrNavCallExpCS ::= simpleNameCS [ argumentsCS ] isMarkedPreCS
			//
			case 218: {
				
				IsMarkedPreCS isMarkedPreCS = (IsMarkedPreCS)dtParser.getSym(5);
				CSTNode result = createFeatureCallExpCS(
						(SimpleNameCS)dtParser.getSym(1),
						(EList)dtParser.getSym(3),
						isMarkedPreCS
					);
				if (isMarkedPreCS.isPre()) {
					setOffsets(result, (CSTNode)dtParser.getSym(1), (CSTNode)dtParser.getSym(5));
				} else {
					setOffsets(result, (CSTNode)dtParser.getSym(1), getIToken(dtParser.getToken(4)));
				}
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 219:  isMarkedPreCS ::= $Empty
			//
			case 219: {
				
				CSTNode result = createIsMarkedPreCS(false);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 220:  isMarkedPreCS ::= @@pre
			//
			case 220: {
				
				CSTNode result = createIsMarkedPreCS(true);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 221:  argumentsCSopt ::= $Empty
			//
			case 221:
				dtParser.setSym1(new BasicEList());
				break;
 
			//
			// Rule 223:  argumentsCS ::= oclExpressionCS
			//
			case 223: {
				
				EList result = new BasicEList();
				result.add(dtParser.getSym(1));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 224:  argumentsCS ::= argumentsCS , oclExpressionCS
			//
			case 224: {
				
				EList result = (EList)dtParser.getSym(1);
				result.add(dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 225:  letExpCS ::= let variableCS letExpSubCSopt in oclExpressionCS
			//
			case 225: {
				
				EList variables = (EList)dtParser.getSym(3);
				variables.add(0, dtParser.getSym(2));
				CSTNode result = createLetExpCS(
						variables,
						(OCLExpressionCS)dtParser.getSym(5)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(5));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 226:  letExpSubCSopt ::= $Empty
			//
			case 226:
				dtParser.setSym1(new BasicEList());
				break;
 
			//
			// Rule 228:  letExpSubCS ::= , variableCS
			//
			case 228: {
				
				EList result = new BasicEList();
				result.add(dtParser.getSym(2));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 229:  letExpSubCS ::= letExpSubCS , variableCS
			//
			case 229: {
				
				EList result = (EList)dtParser.getSym(1);
				result.add(dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 230:  ifExpCS ::= if oclExpressionCS then oclExpressionCS else oclExpressionCS endif
			//
			case 230: {
				
				CSTNode result = createIfExpCS(
						(OCLExpressionCS)dtParser.getSym(2),
						(OCLExpressionCS)dtParser.getSym(4),
						(OCLExpressionCS)dtParser.getSym(6)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(7)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 231:  messageExpCS ::= ^ simpleNameCS ( oclMessageArgumentsCSopt )
			//
			case 231:
 
			//
			// Rule 232:  messageExpCS ::= ^^ simpleNameCS ( oclMessageArgumentsCSopt )
			//
			case 232: {
				
				CSTNode result = createMessageExpCS(
						getIToken(dtParser.getToken(1)).getKind() == XpandParsersym.TK_CARET,
						(SimpleNameCS)dtParser.getSym(2),
						(EList<OCLMessageArgCS>)dtParser.getSym(4)
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), getIToken(dtParser.getToken(5)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 233:  oclMessageArgumentsCSopt ::= $Empty
			//
			case 233:
				dtParser.setSym1(new BasicEList());
				break;
 
			//
			// Rule 235:  oclMessageArgumentsCS ::= oclMessageArgCS
			//
			case 235: {
				
				EList result = new BasicEList();
				result.add(dtParser.getSym(1));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 236:  oclMessageArgumentsCS ::= oclMessageArgumentsCS , oclMessageArgCS
			//
			case 236: {
				
				EList result = (EList)dtParser.getSym(1);
				result.add(dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 237:  oclMessageArgCS ::= oclExpressionCS
			//
			case 237: {
				
				CSTNode result = createOCLMessageArgCS(
						null,
						(OCLExpressionCS)dtParser.getSym(1)
					);
				setOffsets(result, (CSTNode)dtParser.getSym(1));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 238:  oclMessageArgCS ::= ?
			//
			case 238: {
				
				CSTNode result = createOCLMessageArgCS(
						null,
						null
					);
				setOffsets(result, getIToken(dtParser.getToken(1)));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 239:  oclMessageArgCS ::= ? : typeCS
			//
			case 239: {
				
				CSTNode result = createOCLMessageArgCS(
						(TypeCS)dtParser.getSym(3),
						null
					);
				setOffsets(result, getIToken(dtParser.getToken(1)), (CSTNode)dtParser.getSym(3));
				dtParser.setSym1(result);
	  		  break;
			}
	 
			//
			// Rule 240:  template ::= emptyTemplate
			//
			case 240: {
				
d755 7
a761 7
			  break;
			} 
			//
			// Rule 243:  template ::= LG commentTextPairAny imports extensionImports defineOrAroundSeq
			//
			case 243: {
				
d777 7
a783 7
			  break;
			} 
			//
			// Rule 244:  defineOrAroundSeq ::= define TEXT commentTextPairAny defineOrAroundSuffix
			//
			case 244: {
				
d788 7
a794 7
			  break;
			} 
			//
			// Rule 245:  defineOrAroundSeq ::= around TEXT commentTextPairAny defineOrAroundSuffix
			//
			case 245: {
				
d799 7
a805 7
			  break;
			} 
			//
			// Rule 246:  defineOrAroundSuffix ::= $Empty
			//
			case 246: {
				
d807 7
a813 7
			  break;
			} 
			//
			// Rule 252:  imports ::= $Empty
			//
			case 252: {
				
d815 7
a821 7
			  break;
			} 
			//
			// Rule 253:  imports ::= anImport imports
			//
			case 253: {
				
d826 15
a840 15
			  break;
			} 
			//
			// Rule 254:  anImport ::= IMPORT stringLiteralExpCS TEXT commentTextPairAny
			//
			case 254: {
				
		setResult(xpandFactory.createNamespaceImport(getLeftIToken(), (StringLiteralExpCS) getRhsSym(2)));
			  break;
			} 
			//
			// Rule 255:  extensionImports ::= $Empty
			//
			case 255: {
				
d842 7
a848 7
			  break;
			} 
			//
			// Rule 256:  extensionImports ::= anExtensionImport extensionImports
			//
			case 256: {
				
d853 47
a899 50
			  break;
			} 
			//
			// Rule 257:  anExtensionImport ::= EXTENSION pathNameCS TEXT commentTextPairAny
			//
			case 257: {
				
		setResult(xpandFactory.createImportDeclaration(getLeftIToken(), (PathNameCS) getRhsSym(2)));
			  break;
			} 
			//
			// Rule 258:  around ::= AROUND pointcut FOR typeCS sequence ENDAROUND
			//
			case 258: {
				
		setResult(xpandFactory.createAround(getLeftIToken(), getRightIToken(), (Identifier) getRhsSym(2), Collections.<VariableCS>emptyList(), false, (TypeCS) getRhsSym(4), (List) getRhsSym(5)));
			  break;
			} 
			//
			// Rule 259:  around ::= AROUND pointcut LPAREN parametersCS RPAREN FOR typeCS sequence ENDAROUND
			//
			case 259: {
				
		setResult(xpandFactory.createAround(getLeftIToken(), getRightIToken(), (Identifier) getRhsSym(2), (List<VariableCS>) getRhsSym(4), false, (TypeCS) getRhsSym(7), (List) getRhsSym(8)));
			  break;
			} 
			//
			// Rule 260:  around ::= AROUND pointcut LPAREN parametersCS COMMA MULTIPLY RPAREN FOR typeCS sequence ENDAROUND
			//
			case 260: {
				
		setResult(xpandFactory.createAround(getLeftIToken(), getRightIToken(), (Identifier) getRhsSym(2), (List<VariableCS>) getRhsSym(4), true, (TypeCS) getRhsSym(9), (List) getRhsSym(10)));
			  break;
			} 
			//
			// Rule 261:  around ::= AROUND pointcut LPAREN MULTIPLY RPAREN FOR typeCS sequence ENDAROUND
			//
			case 261: {
				
		setResult(xpandFactory.createAround(getLeftIToken(), getRightIToken(), (Identifier) getRhsSym(2), Collections.<VariableCS>emptyList(), true, (TypeCS) getRhsSym(7), (List) getRhsSym(8)));
			  break;
			} 
			//
			// Rule 262:  pointcut ::= MULTIPLY pointcutSuffix
			//
			case 262: {
				
//			FIXME: may use SimpleNameCS here, though need more sophisticated code to update end position
//			SimpleNameCS simpleNameCS = createSimpleNameCS(SimpleTypeEnum.IDENTIFIER_LITERAL, getTokenText(getRhsTokenIndex(1)));
//			setOffsets(simpleNameCS, getLeftIToken());
d905 7
a911 7
			  break;
			} 
			//
			// Rule 263:  pointcut ::= IDENTIFIER pointcutSuffix
			//
			case 263: {
				
d917 7
a923 7
			  break;
			} 
			//
			// Rule 264:  pointcutSuffix ::= $Empty
			//
			case 264: {
				
d925 7
a931 7
			  break;
			} 
			//
			// Rule 266:  pointcutSuffix ::= COLONCOLON pointcutSuffix
			//
			case 266: {
				
d937 23
a959 23
			  break;
			} 
			//
			// Rule 267:  define ::= DEFINE IDENTIFIER FOR typeCS sequence ENDDEFINE
			//
			case 267: {
				
		setResult(xpandFactory.createDefinition(getLeftIToken(), getRightIToken(), getRhsIToken(2), Collections.<VariableCS>emptyList(), (TypeCS) getRhsSym(4), (List) getRhsSym(5)));
			  break;
			} 
			//
			// Rule 268:  define ::= DEFINE IDENTIFIER LPAREN parametersCS RPAREN FOR typeCS sequence ENDDEFINE
			//
			case 268: {
				
		setResult(xpandFactory.createDefinition(getLeftIToken(), getRightIToken(), getRhsIToken(2), (List<VariableCS>) getRhsSym(4), (TypeCS) getRhsSym(7), (List) getRhsSym(8)));
			  break;
			} 
			//
			// Rule 269:  sequence ::= text sequenceSuffix
			//
			case 269: {
				
d964 7
a970 7
			  break;
			} 
			//
			// Rule 270:  sequenceSuffix ::= $Empty
			//
			case 270: {
				
d972 7
a978 7
			  break;
			} 
			//
			// Rule 271:  sequenceSuffix ::= statement text sequenceSuffix
			//
			case 271: {
				
d984 7
a990 7
			  break;
			} 
			//
			// Rule 278:  text ::= minusOpt TEXT textSuffix
			//
			case 278: {
				
d995 7
a1001 7
			  break;
			} 
			//
			// Rule 279:  textSuffix ::= $Empty
			//
			case 279: {
				
d1003 7
a1009 7
			  break;
			} 
			//
			// Rule 280:  textSuffix ::= minusOpt TEXT textSuffix
			//
			case 280: {
				
d1014 7
a1020 7
			  break;
			} 
			//
			// Rule 281:  minusOpt ::= $Empty
			//
			case 281: {
				
d1022 7
a1028 7
			  break;
			} 
			//
			// Rule 282:  minusOpt ::= MINUS
			//
			case 282: {
				
d1030 39
a1068 39
			  break;
			} 
			//
			// Rule 286:  errorStatement ::= ERROR oclExpressionCS
			//
			case 286: {
				
		setResult(xpandFactory.createErrorStatement(getLeftIToken(), (OCLExpressionCS) getRhsSym(2)));
			  break;
			} 
			//
			// Rule 287:  expandStatement ::= EXPAND definitionName parameterListOpt
			//
			case 287: {
				
		setResult(xpandFactory.createExpandStatement(getLeftIToken(), (PathNameCS) getRhsSym(2), (List) getRhsSym(3), null, false, null));
			  break;
			} 
			//
			// Rule 288:  expandStatement ::= EXPAND definitionName parameterListOpt FOR oclExpressionCS
			//
			case 288: {
				
		setResult(xpandFactory.createExpandStatement(getLeftIToken(), (PathNameCS) getRhsSym(2), (List) getRhsSym(3), (OCLExpressionCS) getRhsSym(5), false, null));
			  break;
			} 
			//
			// Rule 289:  expandStatement ::= EXPAND definitionName parameterListOpt FOREACH oclExpressionCS separatorOpt
			//
			case 289: {
				
		setResult(xpandFactory.createExpandStatement(getLeftIToken(), (PathNameCS) getRhsSym(2), (List) getRhsSym(3), (OCLExpressionCS) getRhsSym(5), true, (OCLExpressionCS) getRhsSym(6)));
			  break;
			} 
			//
			// Rule 290:  parameterListOpt ::= $Empty
			//
			case 290: {
				
d1070 7
a1076 7
			  break;
			} 
			//
			// Rule 291:  parameterListOpt ::= LPAREN argumentsCS RPAREN
			//
			case 291: {
				
d1078 23
a1100 25
			  break;
			} 
			//
			// Rule 293:  expressionStmt ::= oclExpressionCS
			//
			case 293: {
				
		// XXX OCL CST doesn't keep track of line numbers, but we use them (perhaps, might refactor to stop using?)
		int lineNumber = getLeftIToken().getLine();
		setResult(xpandFactory.createExpressionStatement((OCLExpressionCS) getRhsSym(1), lineNumber));
			  break;
			} 
			//
			// Rule 294:  fileStatement ::= FILE oclExpressionCS identOpt sequence ENDFILE
			//
			case 294: {
				
		setResult(xpandFactory.createFileStatement(getLeftIToken(), getRightIToken(), (OCLExpressionCS) getRhsSym(2), (Identifier) getRhsSym(3), (List) getRhsSym(4)));
			  break;
			} 
			//
			// Rule 295:  identOpt ::= $Empty
			//
			case 295: {
				
d1102 7
a1108 7
			  break;
			} 
			//
			// Rule 296:  identOpt ::= IDENTIFIER
			//
			case 296: {
				
d1110 15
a1124 15
			  break;
			} 
			//
			// Rule 297:  foreachStatement ::= FOREACH oclExpressionCS AS IDENTIFIER iteratorOpt separatorOpt sequence ENDFOREACH
			//
			case 297: {
				
		setResult(xpandFactory.createForEachStatement(getLeftIToken(), getRightIToken(), (OCLExpressionCS) getRhsSym(2), getRhsIToken(4), (OCLExpressionCS) getRhsSym(6), (IToken) getRhsSym(5), (List) getRhsSym(7)));
			  break;
			} 
			//
			// Rule 298:  iteratorOpt ::= $Empty
			//
			case 298: {
				
d1126 7
a1132 7
			  break;
			} 
			//
			// Rule 299:  iteratorOpt ::= ITERATOR IDENTIFIER
			//
			case 299: {
				
d1134 7
a1140 7
			  break;
			} 
			//
			// Rule 300:  separatorOpt ::= $Empty
			//
			case 300: {
				
d1142 7
a1148 7
			  break;
			} 
			//
			// Rule 301:  separatorOpt ::= SEPARATOR oclExpressionCS
			//
			case 301: {
				
d1150 8
a1157 8
			  break;
			} 
			//
			// Rule 302:  ifStatement ::= IF oclExpressionCS sequence elseifAny elseOpt ENDIF
			//
			case 302: {
				
		IfStatement i = xpandFactory.createIfStatement(getLeftIToken(), (OCLExpressionCS) getRhsSym(2), (List) getRhsSym(3), null);
d1172 7
a1178 7
			  break;
			} 
			//
			// Rule 303:  elseifAny ::= $Empty
			//
			case 303: {
				
d1180 8
a1187 8
			  break;
			} 
			//
			// Rule 304:  elseifAny ::= ELSEIF oclExpressionCS sequence elseifAny
			//
			case 304: {
				
		IfStatement elseIf = xpandFactory.createIfStatement(getLeftIToken(), (OCLExpressionCS) getRhsSym(2), (List) getRhsSym(3), null);
d1191 7
a1197 7
			  break;
			} 
			//
			// Rule 305:  elseOpt ::= $Empty
			//
			case 305: {
				
d1199 7
a1205 7
			  break;
			} 
			//
			// Rule 306:  elseOpt ::= ELSE sequence
			//
			case 306: {
				
d1207 23
a1229 23
			  break;
			} 
			//
			// Rule 307:  letStatement ::= LET oclExpressionCS AS IDENTIFIER sequence ENDLET
			//
			case 307: {
				
		setResult(xpandFactory.createLetStatement(getLeftIToken(), getRightIToken(), (OCLExpressionCS) getRhsSym(2), getRhsIToken(4), (List) getRhsSym(5)));
			  break;
			} 
			//
			// Rule 308:  protectStatement ::= PROTECT CSTART oclExpressionCS CEND oclExpressionCS ID oclExpressionCS disabledOpt sequence ENDPROTECT
			//
			case 308: {
				
		setResult(xpandFactory.createProtectStatement(getLeftIToken(), getRightIToken(), (OCLExpressionCS) getRhsSym(3), (OCLExpressionCS) getRhsSym(5), (OCLExpressionCS) getRhsSym(7), (IToken) getRhsSym(8), (List) getRhsSym(9)));
			  break;
			} 
			//
			// Rule 309:  disabledOpt ::= $Empty
			//
			case 309: {
				
d1231 7
a1237 7
			  break;
			} 
			//
			// Rule 310:  disabledOpt ::= DISABLE
			//
			case 310: {
				
d1239 8
a1246 8
			  break;
			}
	
			default:
				break;
		}
		return;
	}
@


1.11.4.2
log
@[243154] Use OCL instead of home-grown expression language - support old syntax for DEFINE
@
text
@d3 6
a8 6
* All rights reserved.   This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
d12 1
a12 2
*/

d2741 1
a2741 1
			// Rule 268:  define ::= DEFINE IDENTIFIER LPAREN parametersList RPAREN FOR typeCS sequence ENDDEFINE
d2749 1
a2749 1
			// Rule 269:  parametersList ::= parameter
a2752 33
		VariableCS param = (VariableCS) getRhsSym(1);
		LinkedList res = new LinkedList();
		res.add(param);
		setResult(res);
			  break;
			} 
			//
			// Rule 270:  parametersList ::= parametersList , parameter
			//
			case 270: {
				
		VariableCS param = (VariableCS) getRhsSym(3);
		LinkedList res = new LinkedList();
		res.addAll((List) getRhsSym(1));
		res.add(param);
		setResult(res);
			  break;
			} 
			//
			// Rule 272:  parameter ::= typeCS IDENTIFIER
			//
			case 272: {
				
		VariableCS result = createVariableCS(getRhsIToken(2).toString(), (TypeCS) getRhsSym(1), null);
		setOffsets(result, (TypeCS) getRhsSym(1), getRhsIToken(2));
		setResult(result);
			  break;
			} 
			//
			// Rule 273:  sequence ::= text sequenceSuffix
			//
			case 273: {
				
d2760 1
a2760 1
			// Rule 274:  sequenceSuffix ::= $Empty
d2762 1
a2762 1
			case 274: {
d2768 1
a2768 1
			// Rule 275:  sequenceSuffix ::= statement text sequenceSuffix
d2770 1
a2770 1
			case 275: {
d2780 1
a2780 1
			// Rule 282:  text ::= minusOpt TEXT textSuffix
d2782 1
a2782 1
			case 282: {
d2791 1
a2791 1
			// Rule 283:  textSuffix ::= $Empty
d2793 1
a2793 1
			case 283: {
d2799 1
a2799 1
			// Rule 284:  textSuffix ::= minusOpt TEXT textSuffix
d2801 1
a2801 1
			case 284: {
d2810 1
a2810 1
			// Rule 285:  minusOpt ::= $Empty
d2812 1
a2812 1
			case 285: {
d2818 1
a2818 1
			// Rule 286:  minusOpt ::= MINUS
d2820 1
a2820 1
			case 286: {
d2826 1
a2826 1
			// Rule 290:  errorStatement ::= ERROR oclExpressionCS
d2828 1
a2828 1
			case 290: {
d2834 1
a2834 1
			// Rule 291:  expandStatement ::= EXPAND definitionName parameterListOpt
d2836 1
a2836 1
			case 291: {
d2842 1
a2842 1
			// Rule 292:  expandStatement ::= EXPAND definitionName parameterListOpt FOR oclExpressionCS
d2844 1
a2844 1
			case 292: {
d2850 1
a2850 1
			// Rule 293:  expandStatement ::= EXPAND definitionName parameterListOpt FOREACH oclExpressionCS separatorOpt
d2852 1
a2852 1
			case 293: {
d2858 1
a2858 1
			// Rule 294:  parameterListOpt ::= $Empty
d2860 1
a2860 1
			case 294: {
d2866 1
a2866 1
			// Rule 295:  parameterListOpt ::= LPAREN argumentsCS RPAREN
d2868 1
a2868 1
			case 295: {
d2874 1
a2874 1
			// Rule 297:  expressionStmt ::= oclExpressionCS
d2876 1
a2876 1
			case 297: {
d2884 1
a2884 1
			// Rule 298:  fileStatement ::= FILE oclExpressionCS identOpt sequence ENDFILE
d2886 1
a2886 1
			case 298: {
d2892 1
a2892 1
			// Rule 299:  identOpt ::= $Empty
d2894 1
a2894 1
			case 299: {
d2900 1
a2900 1
			// Rule 300:  identOpt ::= IDENTIFIER
d2902 1
a2902 1
			case 300: {
d2908 1
a2908 1
			// Rule 301:  foreachStatement ::= FOREACH oclExpressionCS AS IDENTIFIER iteratorOpt separatorOpt sequence ENDFOREACH
d2910 1
a2910 1
			case 301: {
d2916 1
a2916 1
			// Rule 302:  iteratorOpt ::= $Empty
d2918 1
a2918 1
			case 302: {
d2924 1
a2924 1
			// Rule 303:  iteratorOpt ::= ITERATOR IDENTIFIER
d2926 1
a2926 1
			case 303: {
d2932 1
a2932 1
			// Rule 304:  separatorOpt ::= $Empty
d2934 1
a2934 1
			case 304: {
d2940 1
a2940 1
			// Rule 305:  separatorOpt ::= SEPARATOR oclExpressionCS
d2942 1
a2942 1
			case 305: {
d2948 1
a2948 1
			// Rule 306:  ifStatement ::= IF oclExpressionCS sequence elseifAny elseOpt ENDIF
d2950 1
a2950 1
			case 306: {
d2970 1
a2970 1
			// Rule 307:  elseifAny ::= $Empty
d2972 1
a2972 1
			case 307: {
d2978 1
a2978 1
			// Rule 308:  elseifAny ::= ELSEIF oclExpressionCS sequence elseifAny
d2980 1
a2980 1
			case 308: {
d2989 1
a2989 1
			// Rule 309:  elseOpt ::= $Empty
d2991 1
a2991 1
			case 309: {
d2997 1
a2997 1
			// Rule 310:  elseOpt ::= ELSE sequence
d2999 1
a2999 1
			case 310: {
d3005 1
a3005 1
			// Rule 311:  letStatement ::= LET oclExpressionCS AS IDENTIFIER sequence ENDLET
d3007 1
a3007 1
			case 311: {
d3013 1
a3013 1
			// Rule 312:  protectStatement ::= PROTECT CSTART oclExpressionCS CEND oclExpressionCS ID oclExpressionCS disabledOpt sequence ENDPROTECT
d3015 1
a3015 1
			case 312: {
d3021 1
a3021 1
			// Rule 313:  disabledOpt ::= $Empty
d3023 1
a3023 1
			case 313: {
d3029 1
a3029 1
			// Rule 314:  disabledOpt ::= DISABLE
d3031 1
a3031 1
			case 314: {
@


1.10
log
@[200786] left-associative addition/substraction
@
text
@d171 1
a171 1
			Matcher m = Pattern.compile("[^:]+:(\\d+):(\\d+):(\\d+):(\\d+):.*").matcher(locationInfo);
d180 1
a180 1
		} catch (Exception ex) {
@


1.9
log
@handle comment-only templates
@
text
@d2 1
a2 1
* Copyright (c) 2006 Eclipse.org
d350 1
a350 1
            // Rule 29:  additiveExpression ::= multiplicativeExpression additiveOperator additiveExpression
@


1.9.2.1
log
@[200786] fix additive operator precedence, merge from HEAD
@
text
@d2 1
a2 1
* Copyright (c) 2006, 2007 Eclipse.org
d350 1
a350 1
            // Rule 29:  additiveExpression ::= additiveExpression additiveOperator multiplicativeExpression
@


1.9.2.2
log
@merge fix from HEAD: fully-qualified names of xpand templates are not processed correctly with the old pattern - and with assertions enabled the thread is stopped.
@
text
@d171 1
a171 1
			Matcher m = Pattern.compile("(?:[^:]+::)*[^:]+:(\\d+):(\\d+):(\\d+):(\\d+):.*").matcher(locationInfo);
d180 1
a180 1
		} catch (Throwable ex) {
@


1.8
log
@do not pass comment up to syntax analyzer
@
text
@d750 1
a750 1
            // Rule 89:  template ::= $Empty
d758 1
a758 1
            // Rule 90:  template ::= lgOpt commentTextPairAny imports extensionImports defineOrAroundSeq
d760 1
a760 1
            case 90: {
d780 1
a780 1
            // Rule 91:  defineOrAroundSeq ::= define TEXT commentTextPairAny defineOrAroundSuffix
d782 1
a782 1
            case 91: {
d791 1
a791 1
            // Rule 92:  defineOrAroundSeq ::= around TEXT commentTextPairAny defineOrAroundSuffix
d793 1
a793 1
            case 92: {
d802 1
a802 1
            // Rule 93:  defineOrAroundSuffix ::= $Empty
d804 1
a804 1
            case 93: {
d810 1
a810 1
            // Rule 99:  imports ::= $Empty
d812 1
a812 1
            case 99: {
d818 1
a818 1
            // Rule 100:  imports ::= anImport imports
d820 1
a820 1
            case 100: {
d829 1
a829 1
            // Rule 101:  anImport ::= IMPORT STRING TEXT commentTextPairAny
d831 1
a831 1
            case 101: {
d837 1
a837 1
            // Rule 102:  extensionImports ::= $Empty
d839 1
a839 1
            case 102: {
d845 1
a845 1
            // Rule 103:  extensionImports ::= anExtensionImport extensionImports
d847 1
a847 1
            case 103: {
d856 1
a856 1
            // Rule 104:  anExtensionImport ::= EXTENSION simpleType TEXT commentTextPairAny
d858 1
a858 1
            case 104: {
d864 1
a864 1
            // Rule 105:  around ::= AROUND pointcut FOR type sequence ENDAROUND
d866 1
a866 1
            case 105: {
d872 1
a872 1
            // Rule 106:  around ::= AROUND pointcut LPAREN declaredParameterList RPAREN FOR type sequence ENDAROUND
d874 1
a874 1
            case 106: {
d880 1
a880 1
            // Rule 107:  around ::= AROUND pointcut LPAREN declaredParameterList COMMA MULTI RPAREN FOR type sequence ENDAROUND
d882 1
a882 1
            case 107: {
d888 1
a888 1
            // Rule 108:  around ::= AROUND pointcut LPAREN MULTI RPAREN FOR type sequence ENDAROUND
d890 1
a890 1
            case 108: {
d896 1
a896 1
            // Rule 109:  pointcut ::= MULTI pointcutSuffix
d898 1
a898 1
            case 109: {
d908 1
a908 1
            // Rule 110:  pointcut ::= IDENT pointcutSuffix
d910 1
a910 1
            case 110: {
d920 1
a920 1
            // Rule 111:  pointcutSuffix ::= $Empty
d922 1
a922 1
            case 111: {
d928 1
a928 1
            // Rule 113:  pointcutSuffix ::= DCOLON pointcutSuffix
d930 1
a930 1
            case 113: {
d940 1
a940 1
            // Rule 114:  define ::= DEFINE IDENT FOR type sequence ENDDEFINE
d942 1
a942 1
            case 114: {
d948 1
a948 1
            // Rule 115:  define ::= DEFINE IDENT LPAREN declaredParameterList RPAREN FOR type sequence ENDDEFINE
d950 1
a950 1
            case 115: {
d956 1
a956 1
            // Rule 116:  sequence ::= text sequenceSuffix
d958 1
a958 1
            case 116: {
d967 1
a967 1
            // Rule 117:  sequenceSuffix ::= $Empty
d969 1
a969 1
            case 117: {
d975 1
a975 1
            // Rule 118:  sequenceSuffix ::= statement text sequenceSuffix
d977 1
a977 1
            case 118: {
d987 1
a987 1
            // Rule 125:  text ::= minusOpt TEXT textSuffix
d989 1
a989 1
            case 125: {
d998 1
a998 1
            // Rule 126:  textSuffix ::= $Empty
d1000 1
a1000 1
            case 126: {
d1006 1
a1006 1
            // Rule 127:  textSuffix ::= minusOpt TEXT textSuffix
d1008 1
a1008 1
            case 127: {
d1017 1
a1017 1
            // Rule 128:  minusOpt ::= $Empty
d1019 1
a1019 1
            case 128: {
d1025 1
a1025 1
            // Rule 129:  minusOpt ::= MINUS
d1027 1
a1027 1
            case 129: {
d1033 1
a1033 1
            // Rule 133:  errorStatement ::= ERROR expression
d1035 1
a1035 1
            case 133: {
d1041 1
a1041 1
            // Rule 134:  expandStatement ::= EXPAND definitionName parameterListOpt
d1043 1
a1043 1
            case 134: {
d1049 1
a1049 1
            // Rule 135:  expandStatement ::= EXPAND definitionName parameterListOpt FOR expression
d1051 1
a1051 1
            case 135: {
d1057 1
a1057 1
            // Rule 136:  expandStatement ::= EXPAND definitionName parameterListOpt FOREACH expression separatorOpt
d1059 1
a1059 1
            case 136: {
d1065 1
a1065 1
            // Rule 137:  parameterListOpt ::= $Empty
d1067 1
a1067 1
            case 137: {
d1073 1
a1073 1
            // Rule 138:  parameterListOpt ::= LPAREN parameterList RPAREN
d1075 1
a1075 1
            case 138: {
d1081 1
a1081 1
            // Rule 140:  expressionStmt ::= expression
d1083 1
a1083 1
            case 140: {
d1089 1
a1089 1
            // Rule 141:  fileStatement ::= FILE expression identOpt sequence ENDFILE
d1091 1
a1091 1
            case 141: {
d1097 1
a1097 1
            // Rule 142:  identOpt ::= $Empty
d1099 1
a1099 1
            case 142: {
d1105 1
a1105 1
            // Rule 143:  identOpt ::= IDENT
d1107 1
a1107 1
            case 143: {
d1113 1
a1113 1
            // Rule 144:  foreachStatement ::= FOREACH expression AS IDENT iteratorOpt separatorOpt sequence ENDFOREACH
d1115 1
a1115 1
            case 144: {
d1121 1
a1121 1
            // Rule 145:  iteratorOpt ::= $Empty
d1123 1
a1123 1
            case 145: {
d1129 1
a1129 1
            // Rule 146:  iteratorOpt ::= ITERATOR IDENT
d1131 1
a1131 1
            case 146: {
d1137 1
a1137 1
            // Rule 147:  separatorOpt ::= $Empty
d1139 1
a1139 1
            case 147: {
d1145 1
a1145 1
            // Rule 148:  separatorOpt ::= SEPARATOR expression
d1147 1
a1147 1
            case 148: {
d1153 1
a1153 1
            // Rule 149:  ifStatement ::= IF expression sequence elseifAny elseOpt ENDIF
d1155 1
a1155 1
            case 149: {
d1175 1
a1175 1
            // Rule 150:  elseifAny ::= $Empty
d1177 1
a1177 1
            case 150: {
d1183 1
a1183 1
            // Rule 151:  elseifAny ::= ELSEIF expression sequence elseifAny
d1185 1
a1185 1
            case 151: {
d1194 1
a1194 1
            // Rule 152:  elseOpt ::= $Empty
d1196 1
a1196 1
            case 152: {
d1202 1
a1202 1
            // Rule 153:  elseOpt ::= ELSE sequence
d1204 1
a1204 1
            case 153: {
d1210 1
a1210 1
            // Rule 154:  letStatement ::= LET expression AS IDENT sequence ENDLET
d1212 1
a1212 1
            case 154: {
d1218 1
a1218 1
            // Rule 155:  protectStatement ::= PROTECT CSTART expression CEND expression ID expression disabledOpt sequence ENDPROTECT
d1220 1
a1220 1
            case 155: {
d1226 1
a1226 1
            // Rule 156:  disabledOpt ::= $Empty
d1228 1
a1228 1
            case 156: {
d1234 1
a1234 1
            // Rule 157:  disabledOpt ::= DISABLE
d1236 1
a1236 1
            case 157: {
@


1.7
log
@combine errors reported separately from lexer and parser
@
text
@d1006 1
a1006 1
            // Rule 127:  textSuffix ::= COMMENT minusOpt TEXT textSuffix
d1011 2
a1012 2
		res.add(xpandFactory.createTextStatement(getRhsIToken(3), (IToken) getRhsSym(2)));
		res.addAll((List) getRhsSym(4));
@


1.6
log
@error handling
@
text
@a150 1
		super.reportError(errorCode, locationInfo, leftToken, rightToken, tokenText);
a165 1
		super.reportError(leftToken, rightToken);
a183 1
		super.reportError(errorCode, locationInfo, tokenText);
@


1.5
log
@polishing templates - parser:added initialization code macro, lexer:getKind implementation made overridable, useless methods removed, braces styles updated
@
text
@d12 6
a24 2
import java.util.LinkedList;
import java.util.List;
d63 1
a63 1
        factory = new ExpressionFactory(lexStream.getFileName());
d108 1
d133 56
@


1.4
log
@no way to initialize factory without file name (though not sure it's needed at all)
@
text
@d22 1
a22 2
public class XpandParser extends PrsStream implements RuleAction
{
d45 1
a45 2
    public int getRhsErrorTokenIndex(int i)
    {
d50 1
a50 2
    public ErrorToken getRhsErrorIToken(int i)
    {
d56 1
a56 2
    public XpandParser(LexStream lexStream)
    {
d61 1
a61 2
        try
        {
d68 1
a68 2
        catch(UnimplementedTerminalsException e)
        {
d78 1
a78 2
        catch(UndefinedEofSymbolException e)
        {
d90 1
a90 2
    public Template parser()
    {
d94 1
a94 2
    public Template parser(Monitor monitor)
    {
d98 1
a98 2
    public Template parser(int error_repair_count)
    {
d102 2
a103 4
    public Template parser(Monitor monitor, int error_repair_count)
    {
        try
        {
d106 1
a106 2
        catch (NotDeterministicParseTableException e)
        {
d110 1
a110 2
        catch (BadParseSymFileException e)
        {
d114 1
a114 2
        try
        {
d117 1
a117 2
        catch (BadParseException e)
        {
d128 1
a128 1
    private final XpandFactory xpandFactory;
d132 2
a133 4
    public void ruleAction(int ruleNumber)
    {
        switch (ruleNumber)
        {
d630 5
a634 5
    			Identifier id = (Identifier) getRhsSym(1);
    			id = id.append(factory.createIdentifier(getRhsIToken(2)));
    			id = id.append((Identifier) getRhsSym(3));
    			id = id.append(factory.createIdentifier(getRhsIToken(4)));
    			setResult(id);
d666 4
a669 4
    			Identifier id = factory.createIdentifier(getLeftIToken());
    			id = id.append(factory.createIdentifier(getRhsIToken(2)));
    			id = id.append((Identifier) getRhsSym(3));
    			setResult(id);
d685 4
a688 4
    			Identifier id = factory.createIdentifier(getLeftIToken());
    			id = id.append(factory.createIdentifier(getRhsIToken(2)));
    			id = id.append((Identifier) getRhsSym(3));
    			setResult(id);
@


1.3
log
@unmodifiable model, and refactored Identifiers as the only place that required ast to be modified
@
text
@d63 1
d146 1
a146 1
	private final ExpressionFactory factory = new ExpressionFactory();
@


1.2
log
@imports were not processed correctly - fix, test added
updated copyrights
@
text
@d647 5
a651 5
		Identifier id = (Identifier) getRhsSym(1);
		id.append(getRhsIToken(2));
		id.append((Identifier) getRhsSym(3));
		id.append(getRhsIToken(4));
		setResult(id);
d683 4
a686 4
		Identifier id = factory.createIdentifier(getLeftIToken());
		id.append(getRhsIToken(2));
		id.append((Identifier) getRhsSym(3));
		setResult(id);
d702 4
a705 4
		Identifier id = factory.createIdentifier(getLeftIToken());
		id.append(getRhsIToken(2));
		id.append((Identifier) getRhsSym(3));
		setResult(id);
d861 1
a861 1
			res.append((Identifier) getRhsSym(2));
d873 1
a873 1
			res.append((Identifier) getRhsSym(2));
d893 1
a893 1
			res.append((Identifier) getRhsSym(2));
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d2 7
a8 7
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
d13 1
d15 1
a16 2
import org.eclipse.gmf.internal.xpand.expression.parser.ExpressionFactory;

d792 1
a792 1
		setResult(xpandFactory.createNamespaceImport(getLeftIToken(),xpandFactory.createStringLiteral(getRightIToken())));
@

