head	1.4;
access;
symbols
	v20081022-1925:1.4
	v20081020-0700:1.4
	ocl_qvt:1.4.0.6
	Root_ocl_qvt:1.4
	v20080722-1827:1.4
	v20080718-1731:1.4
	v20080716-1600:1.4
	v20080716-1642:1.4
	R2_1_maintenance:1.4.0.4
	Root_R2_1_maintenance:1.4
	R2_1_0:1.4
	v20080528-1052:1.4
	v20080516-1143:1.4
	v20080417-1610:1.4
	v20080322-0000:1.4
	v20080222-1200:1.4
	v20071130-1111:1.4
	v20071124-0000:1.4
	v20071108-0000:1.4
	v20071003-0000:1.4
	v20070921-0000:1.4
	v20070903-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	RC3_20:1.4
	v20070608-1300:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070518-1300:1.4
	v20070420-1000:1.4
	v20070405-1100:1.4
	v20070403-1500:1.4
	v20070330-1300:1.4
	v20070208-1800:1.4
	v20070103-0300:1.4
	M4_20:1.4
	M3_20:1.4;
locks; strict;
comment	@# @;


1.4
date	2006.11.08.19.08.32;	author atikhomirov;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2006.11.08.13.15.12;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.24.18.31.37;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.48;	author atikhomirov;	state Exp;
branches;
next	;

1.4.6.1
date	2008.08.05.12.49.26;	author atikhomirov;	state Exp;
branches;
next	;
commitid	546c48984c4a4567;


desc
@@


1.4
log
@combine errors reported separately from lexer and parser
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2006 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.parser;

import java.util.List;

import lpg.lpgjavaruntime.IToken;

import org.eclipse.gmf.internal.xpand.ast.Advice;
import org.eclipse.gmf.internal.xpand.ast.Definition;
import org.eclipse.gmf.internal.xpand.ast.ErrorStatement;
import org.eclipse.gmf.internal.xpand.ast.ExpandStatement;
import org.eclipse.gmf.internal.xpand.ast.ExpressionStatement;
import org.eclipse.gmf.internal.xpand.ast.FileStatement;
import org.eclipse.gmf.internal.xpand.ast.ForEachStatement;
import org.eclipse.gmf.internal.xpand.ast.IfStatement;
import org.eclipse.gmf.internal.xpand.ast.ImportDeclaration;
import org.eclipse.gmf.internal.xpand.ast.LetStatement;
import org.eclipse.gmf.internal.xpand.ast.NamespaceImport;
import org.eclipse.gmf.internal.xpand.ast.ProtectStatement;
import org.eclipse.gmf.internal.xpand.ast.Statement;
import org.eclipse.gmf.internal.xpand.ast.Template;
import org.eclipse.gmf.internal.xpand.ast.TextStatement;
import org.eclipse.gmf.internal.xpand.expression.ast.DeclaredParameter;
import org.eclipse.gmf.internal.xpand.expression.ast.Expression;
import org.eclipse.gmf.internal.xpand.expression.ast.Identifier;
import org.eclipse.gmf.internal.xpand.expression.ast.StringLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.SyntaxElement;
import org.eclipse.gmf.internal.xpand.expression.parser.ExpressionFactory;

/**
 * @@author Sven Efftinge
 */
public class XpandFactory extends ExpressionFactory {

	public XpandFactory(final String fileName) {
		super(fileName);
	}

	public Template createTemplate(final List<NamespaceImport> imports, final List<ImportDeclaration> extensions, final List<Definition> defines, final List<Advice> advices, final IToken eof) {
		final NamespaceImport[] i = imports.toArray(new NamespaceImport[imports.size()]);
		final ImportDeclaration[] ext = extensions.toArray(new ImportDeclaration[extensions.size()]);

		final Definition[] d = defines.toArray(new Definition[defines.size()]);
		final Advice[] a = advices.toArray(new Advice[advices.size()]);
		final Template t = new Template(0, end(eof), 0, i, ext, d, a);
		return handle(t);
	}

	public Definition createDefinition(final IToken startToken, final IToken endToken, final IToken n, final List<SyntaxElement> p, final Identifier type, final List<SyntaxElement> s) {
		final int start = start(startToken);
		final int end = end(endToken);
		final int line = line(startToken);
		final Identifier name = createIdentifier(n);
		final DeclaredParameter[] params = p.toArray(new DeclaredParameter[p.size()]);
		final Statement[] body = s.toArray(new Statement[s.size()]);
		return handle(new Definition(start, end, line, name, type, params, body));
	}

	public TextStatement createTextStatement(final IToken t, final IToken m) {
		String text = t.toString();
		if (text.length() > 1) {
			text = text.substring(1, text.length() - 1);
		} else {
			text = "";
		}
		return handle(new TextStatement(start(m != null ? m : t), end(t), line(m != null ? m : t), text, m != null));
	}

	public ForEachStatement createForEachStatement(final IToken start, final IToken end, final Expression e, final IToken v, final Expression sep, final IToken iter, final List<SyntaxElement> s) {
		final Statement[] body = s.toArray(new Statement[s.size()]);
		return handle(new ForEachStatement(start(start), end(end), line(start), createIdentifier(v), e, body, sep, iter != null ? createIdentifier(iter) : null));
	}

	public IfStatement createIfStatement(final IToken start, final Expression condition, final List<SyntaxElement> statements, final IfStatement elseIf) {
		final Statement[] body = statements.toArray(new Statement[statements.size()]);
		final int end = body[body.length - 1].getEnd();
		return handle(new IfStatement(start(start), end, line(start), condition, body, elseIf));
	}

	public LetStatement createLetStatement(final IToken start, final IToken end, final Expression e, final IToken name, final List<SyntaxElement> statements) {
		final Statement[] body = statements.toArray(new Statement[statements.size()]);
		return handle(new LetStatement(start(start), end(end), line(start), createIdentifier(name), e, body));
	}

	public ErrorStatement createErrorStatement(final IToken start, final Expression expr) {
		return handle(new ErrorStatement(start(start), expr.getEnd(), line(start), expr));
	}

	public ExpressionStatement createExpressionStatement(final Expression e) {
		return handle(new ExpressionStatement(e.getStart(), e.getEnd(), e.getLine(), e));
	}

	public FileStatement createFileStatement(final IToken start, final IToken end, final Expression fileName, final Identifier option, final List<SyntaxElement> statements) {
		final Statement[] body = statements.toArray(new Statement[statements.size()]);
		return handle(new FileStatement(start(start), end(end), line(start), fileName, body, option));
	}

	// FIXME disabled as token - no reason, just true/false 
	public ProtectStatement createProtectStatement(final IToken start, final IToken end, final Expression startC, final Expression endC, final Expression id, final IToken disabled, final List<SyntaxElement> statements) {
		final Statement[] body = statements.toArray(new Statement[statements.size()]);
		return handle(new ProtectStatement(start(start), end(end), line(start), startC, endC, body, id, disabled != null));
	}

	public ExpandStatement createExpandStatement(final IToken start, final Identifier definition, final List<Expression> parameters, final Expression target, final boolean foreach, final Expression sep) {
		final Expression[] params = parameters.toArray(new Expression[parameters.size()]);
		int end = definition.getEnd();
		if (sep != null) {
			end = sep.getEnd();
		} else if (target != null) {
			end = target.getEnd();
		} else if (params.length > 0) {
			end = params[params.length - 1].getEnd();
		}
		return handle(new ExpandStatement(start(start), end, line(start), definition, target, sep, params, foreach));
	}

	public NamespaceImport createNamespaceImport(IToken start, StringLiteral namespace) {
		return handle(new NamespaceImport(start(start), namespace.getEnd(), line(start), namespace));
	}

	public ImportDeclaration createImportDeclaration(final IToken start, final Identifier namespace) {
		return handle(new ImportDeclaration(start(start), namespace.getEnd(), line(start), namespace));
	}

	public Advice createAround(final IToken start, final IToken end, final Identifier n, final List<SyntaxElement> p, final boolean wildparams, final Identifier t, final List<SyntaxElement> s) {
		final DeclaredParameter[] params = p.toArray(new DeclaredParameter[p.size()]);
		final Statement[] body = s.toArray(new Statement[s.size()]);
		final Advice a = new Advice(start(start), end(end), line(start), n, t, params, wildparams, body);
		return handle(a);
	}

}
@


1.4.6.1
log
@[243154] Use OCL instead of home-grown expression language
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
a13 1
 *     Artem Tikhomirov (Borland) - Migration to OCL expressions
d36 2
d39 1
d41 1
a41 6
import org.eclipse.gmf.internal.xpand.ocl.DeclaredParameter;
import org.eclipse.ocl.cst.OCLExpressionCS;
import org.eclipse.ocl.cst.PathNameCS;
import org.eclipse.ocl.cst.StringLiteralExpCS;
import org.eclipse.ocl.cst.TypeCS;
import org.eclipse.ocl.cst.VariableCS;
d46 1
a46 3
public class XpandFactory {

	private final String fileName;
d49 1
a49 1
		this.fileName = fileName;
d62 1
a62 1
	public Definition createDefinition(final IToken startToken, final IToken endToken, final IToken n, final List<VariableCS> p, final TypeCS type, final List<Statement> s) {
d67 1
d69 1
a69 1
		return handle(new Definition(start, end, line, name, type, DeclaredParameter.create(p), body));
d82 1
a82 1
	public ForEachStatement createForEachStatement(final IToken start, final IToken end, final OCLExpressionCS e, final IToken v, final OCLExpressionCS sep, final IToken iter, final List<SyntaxElement> s) {
d87 1
a87 1
	public IfStatement createIfStatement(final IToken start, final OCLExpressionCS condition, final List<SyntaxElement> statements, final IfStatement elseIf) {
d93 1
a93 1
	public LetStatement createLetStatement(final IToken start, final IToken end, final OCLExpressionCS e, final IToken name, final List<SyntaxElement> statements) {
d98 2
a99 2
	public ErrorStatement createErrorStatement(final IToken start, final OCLExpressionCS expr) {
		return handle(new ErrorStatement(start(start), expr.getEndOffset(), line(start), expr));
d102 2
a103 2
	public ExpressionStatement createExpressionStatement(final OCLExpressionCS e, int lineNumber) {
		return handle(new ExpressionStatement(e.getStartOffset(), e.getEndOffset(), lineNumber, e));
d106 1
a106 1
	public FileStatement createFileStatement(final IToken start, final IToken end, final OCLExpressionCS fileName, final Identifier option, final List<SyntaxElement> statements) {
d112 1
a112 1
	public ProtectStatement createProtectStatement(final IToken start, final IToken end, final OCLExpressionCS startC, final OCLExpressionCS endC, final OCLExpressionCS id, final IToken disabled, final List<SyntaxElement> statements) {
d117 3
a119 3
	public ExpandStatement createExpandStatement(final IToken start, final PathNameCS definition, final List<OCLExpressionCS> parameters, final OCLExpressionCS target, final boolean foreach, final OCLExpressionCS sep) {
		final OCLExpressionCS[] params = parameters.toArray(new OCLExpressionCS[parameters.size()]);
		int end = definition.getEndOffset();
d121 1
a121 1
			end = sep.getEndOffset();
d123 1
a123 1
			end = target.getEndOffset();
d125 1
a125 1
			end = params[params.length - 1].getEndOffset();
d130 2
a131 2
	public NamespaceImport createNamespaceImport(IToken start, StringLiteralExpCS namespace) {
		return handle(new NamespaceImport(start(start), namespace.getEndOffset(), line(start), namespace));
d134 2
a135 2
	public ImportDeclaration createImportDeclaration(final IToken start, final PathNameCS namespace) {
		return handle(new ImportDeclaration(start(start), namespace.getEndOffset(), line(start), namespace));
d138 2
a139 1
	public Advice createAround(final IToken start, final IToken end, final Identifier n, final List<VariableCS> p, final boolean wildparams, final TypeCS t, final List<Statement> s) {
d141 1
a141 1
		final Advice a = new Advice(start(start), end(end), line(start), n, t, DeclaredParameter.create(p), wildparams, body);
a144 21
	// copy from ExpressionFactory
	private <T extends SyntaxElement> T handle(final T expr) {
		expr.setFileName(fileName);
		return expr;
	}

	private static int end(final IToken c) {
		return c.getEndColumn();
	}

	private static int start(final IToken c) {
		return c.getColumn() - 1;
	}

	private static int line(final IToken c) {
		return c.getLine();
	}

	public Identifier createIdentifier(IToken name) {
		return new Identifier(start(name), end(name), line(name), name.toString());
	}
@


1.3
log
@reminder
@
text
@d74 5
a78 2
		// XXX in fact, XpandLexer allows TEXT to be RG char only, in which case we'd get NPE here
		text = text.substring(1, text.length() - 1);
@


1.2
log
@no way to initialize factory without file name (though not sure it's needed at all)
@
text
@d74 1
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d44 1
a44 3
 * *
 * 
 * @@author Sven Efftinge *
@

