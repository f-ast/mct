22a23,24
> import org.eclipse.core.runtime.Assert;
> 
32a35,38
> import org.eclipse.draw2d.geometry.PrecisionPoint;
> 
> import org.eclipse.draw2d.geometry.PrecisionRectangle;
> 
72a79,80
> import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;
> 
357a366,370
>     public List getDiagramPartInfo () {
>         Assert.isNotNull (_dgrmEP);
>         return getDiagramPartInfo (_dgrmEP);
>     }
> 
487a501,552
>     final public ImageDescriptor createConstrainedSWTImageDecriptorForParts (List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
>         ImageDescriptor imageDesc = new ImageDescriptor () {
> 
>             public ImageData getImageData () {
>                 return SharedImages.get (SharedImages.IMG_ERROR).getImageData ();
>             }
> 
>         }
> 
>         ;
>         Graphics graphics = null;
>         try {
>             IMapMode mm = getMapMode ();
>             Rectangle originalBounds = new PrecisionRectangle (new Rectangle (calculateImageRectangle (editParts)));
>             getMapMode ().LPtoDP (originalBounds);
>             int deviceMargins = mm.LPtoDP (getImageMargin ());
>             int threshold = useMargins ? deviceMargins : 0;
>             double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
>             originalBounds.shrink (deviceMargins, deviceMargins);
>             if (maxDeviceWidth > threshold) {
>                 xScalingFactor = (maxDeviceWidth - threshold - threshold) / (originalBounds.preciseWidth ());
>             }
>             if (maxDeviceHeight > threshold) {
>                 yScalingFactor = (maxDeviceHeight - threshold - threshold) / (originalBounds.preciseHeight ());
>             }
>             double scalingFactor = Math.min (Math.min (xScalingFactor, yScalingFactor), 1);
>             int imageWidth = originalBounds.width + threshold + threshold;
>             int imageHeight = originalBounds.height + threshold + threshold;
>             if (scalingFactor < 1) {
>                 imageWidth = (int) Math.round (originalBounds.preciseWidth () * scalingFactor) + threshold + threshold;
>                 imageHeight = (int) Math.round (originalBounds.preciseHeight () * scalingFactor) + threshold + threshold;
>             }
>             graphics = setUpGraphics (imageWidth, imageHeight);
>             ScaledGraphics scaledGraphics = new ScaledGraphics (graphics);
>             RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics (scaledGraphics, getMapMode ());
>             graphics.translate (threshold, threshold);
>             mapModeGraphics.scale (scalingFactor);
>             Point location = new PrecisionPoint (originalBounds.preciseX (), originalBounds.preciseY ());
>             mm.DPtoLP (location);
>             renderToGraphics (mapModeGraphics, location, editParts);
>             imageDesc = getImageDescriptor (graphics);
>         } finally {
>             if (graphics != null) disposeGraphics (graphics);
> 
>         }
>         return imageDesc;
>     }
> 
>     public Image createConstrainedAWTImageForParts (List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
>         return null;
>     }
> 
