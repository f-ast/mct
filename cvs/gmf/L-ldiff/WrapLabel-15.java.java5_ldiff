3,14d2
< import java.lang.ref.WeakReference;
< 
< import java.util.ArrayList;
< 
< import java.util.Map;
< 
< import java.util.WeakHashMap;
< 
< import org.eclipse.draw2d.ColorConstants;
< 
< import org.eclipse.draw2d.Figure;
< 
17,17c5,5
< import org.eclipse.draw2d.Graphics;
---
> import org.eclipse.draw2d.IFigure;
18,21d5
< 
< import org.eclipse.draw2d.LayoutManager;
< 
< import org.eclipse.draw2d.PositionConstants;
25,26d8
< import org.eclipse.draw2d.geometry.Insets;
< 
31,32d12
< import org.eclipse.gmf.runtime.draw2d.ui.internal.mapmode.IMapModeHolder;
< 
35,36d14
< import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
< 
46a25,25
> public class WrapLabel extends WrappingLabel {
47,117d24
< public class WrapLabel extends Figure implements PositionConstants {
<     private static final String _ellipse = "...";
<     private static final Dimension EMPTY_DIMENSION = new Dimension (0, 0);
<     private static final Map mapModeConstantsMap = new WeakHashMap ();
<     private static class MapModeConstants {
<         private static final int MAX_IMAGE_INFO = 12;
<         public final WeakReference mapModeRef;
<         public final int nDPtoLP_3;
<         public final int nDPtoLP_2;
<         public final int nDPtoLP_0;
<         public final Dimension dimension_nDPtoLP_0;
<         public final WeakHashMap fontToEllipseTextSize = new WeakHashMap ();
<         public final SingleIconInfo [] singleIconInfos = new SingleIconInfo [MAX_IMAGE_INFO];
< 
<         public MapModeConstants (IMapMode mapMode) {
<             this.mapModeRef = new WeakReference (mapMode);
<             nDPtoLP_2 = mapMode.DPtoLP (2);
<             nDPtoLP_3 = mapMode.DPtoLP (3);
<             nDPtoLP_0 = mapMode.DPtoLP (0);
<             dimension_nDPtoLP_0 = new Dimension (nDPtoLP_0, nDPtoLP_0);
<         }
< 
<         public Dimension getEllipseTextSize (Font f) {
<             Dimension d = (Dimension) fontToEllipseTextSize.get (f);
<             if (d == null) {
<                 IMapMode mapMode = (IMapMode) mapModeRef.get ();
<                 d = FigureUtilities.getTextExtents (_ellipse, f);
<                 d.height = FigureUtilities.getFontMetrics (f).getHeight ();
<                 d = new Dimension (mapMode.DPtoLP (d.width), mapMode.DPtoLP (d.height));
<                 fontToEllipseTextSize.put (f, d);
<             }
<             return d;
<         }
< 
<         public SingleIconInfo getSingleIconInfo (Image image) {
<             if (image == null) {
<                 return SingleIconInfo.NULL_INFO;
<             }
<             SingleIconInfo info;
<             for (int i = 0;
<             i < MAX_IMAGE_INFO; ++ i) {
<                 info = singleIconInfos [i];
<                 if (info == null) {
<                     info = new SingleIconInfo (image);
<                     singleIconInfos [i] = info;
<                     return info;
<                 }
<                 if (info.icon == image) {
<                     return info;
<                 }
<             }
<             int index = SingleIconInfo.count % MAX_IMAGE_INFO;
<             info = new SingleIconInfo (image);
<             singleIconInfos [index] = info;
<             return info;
<         }
< 
<     }
< 
<     private static int FLAG_SELECTED = MAX_FLAG << 1;
<     private static int FLAG_HASFOCUS = MAX_FLAG << 2;
<     private static int FLAG_UNDERLINED = MAX_FLAG << 3;
<     private static int FLAG_STRIKEDTHROUGH = MAX_FLAG << 4;
<     private static int FLAG_WRAP = MAX_FLAG << 5;
<     private static int FLAG_TEXT_ALIGN = MAX_FLAG << 6;
<     private static int FLAG_WRAP_ALIGN = MAX_FLAG << 9;
<     private static int FLAG_ICON_ALIGN = MAX_FLAG << 12;
<     private static int FLAG_LABEL_ALIGN = MAX_FLAG << 15;
<     private static int FLAG_TEXT_PLACEMENT = MAX_FLAG << 18;
<     private MapModeConstants mapModeConstants;
<     private String text;
119,282d26
<     private Dimension textSize;
<     private Dimension ellipseTextSize;
<     private Point textLocation;
<     private int cachedPrefSizeHint_width;
<     private int cachedPrefSizeHint_height;
<     private Point iconLocation;
<     private static abstract class IconInfo {
< 
<         public abstract Image getIcon (int i);
< 
<         public abstract Dimension getIconSize (IMapMode mapMode, int i);
< 
<         public abstract int getNumberofIcons ();
< 
<         public abstract Dimension getTotalIconSize (IMapMode mapMode);
< 
<         public abstract void invalidate ();
< 
<         public abstract void setIcon (Image icon, int i);
< 
<         public abstract int getMaxIcons ();
< 
<     }
< 
<     private static class SingleIconInfo extends IconInfo {
<         static int count;
<         public static final SingleIconInfo NULL_INFO = new SingleIconInfo () {
< 
<             public int getNumberofIcons () {
<                 return 0;
<             }
< 
<         }
< 
<         ;
<         final Image icon;
<         private Dimension totalIconSize;
< 
<         private SingleIconInfo () {
<             icon = null;
<         }
< 
<         public SingleIconInfo (Image icon) {
<             this.icon = icon;
<             ++ count;
<         }
< 
<         public final int getMaxIcons () {
<             return 1;
<         }
< 
<         public Image getIcon (int i) {
<             if (i == 0) {
<                 return icon;
<             } else if (i > 0) {
<                 return null;
<             }
< 
<             throw new IndexOutOfBoundsException ();
<         }
< 
<         public void setIcon (Image img, int i) {
<             throw new UnsupportedOperationException ();
<         }
< 
<         public Dimension getIconSize (IMapMode mapMode, int i) {
<             if (i == 0) {
<                 return getTotalIconSize (mapMode);
<             }
<             throw new IndexOutOfBoundsException ();
<         }
< 
<         public int getNumberofIcons () {
<             return 1;
<         }
< 
<         public Dimension getTotalIconSize (IMapMode mapMode) {
<             if (totalIconSize != null) return totalIconSize;
< 
<             if (icon != null && ! icon.isDisposed ()) {
<                 org.eclipse.swt.graphics.Rectangle imgBounds = icon.getBounds ();
<                 totalIconSize = new Dimension (mapMode.DPtoLP (imgBounds.width), mapMode.DPtoLP (imgBounds.height));
<             } else {
<                 totalIconSize = EMPTY_DIMENSION;
<             }
<             return totalIconSize;
<         }
< 
<         public void invalidate () {
<             totalIconSize = null;
<         }
< 
<     }
< 
<     private static class MultiIconInfo extends IconInfo {
<         private ArrayList icons = new ArrayList (2);
<         private Dimension totalIconSize;
< 
<         public MultiIconInfo () {
<             super ();
<         }
< 
<         public int getMaxIcons () {
<             return - 1;
<         }
< 
<         public Image getIcon (int i) {
<             if (i >= icons.size ()) return null;
< 
<             return (Image) icons.get (i);
<         }
< 
<         public void setIcon (Image icon, int i) {
<             int size = icons.size ();
<             if (i >= size) {
<                 for (int j = size;
<                 j < i; j ++) icons.add (null);
< 
<                 icons.add (icon);
<                 icons.trimToSize ();
<             } else icons.set (i, icon);
< 
<         }
< 
<         public Dimension getIconSize (IMapMode mapMode, int i) {
<             Image img = getIcon (i);
<             if (img != null && ! img.isDisposed ()) {
<                 org.eclipse.swt.graphics.Rectangle imgBounds = img.getBounds ();
<                 return new Dimension (mapMode.DPtoLP (imgBounds.width), mapMode.DPtoLP (imgBounds.height));
<             }
<             return EMPTY_DIMENSION;
<         }
< 
<         public int getNumberofIcons () {
<             return icons.size ();
<         }
< 
<         public Dimension getTotalIconSize (IMapMode mapMode) {
<             if (totalIconSize != null) return totalIconSize;
< 
<             int iconNum = getNumberofIcons ();
<             if (iconNum == 0) {
<                 return totalIconSize = EMPTY_DIMENSION;
<             }
<             totalIconSize = new Dimension ();
<             for (int i = 0;
<             i < iconNum; i ++) {
<                 Dimension iconSize = getIconSize (mapMode, i);
<                 totalIconSize.width += iconSize.width;
<                 if (iconSize.height > totalIconSize.height) totalIconSize.height = iconSize.height;
< 
<             }
<             return totalIconSize;
<         }
< 
<         public void invalidate () {
<             totalIconSize = null;
<         }
< 
<     }
< 
<     private IconInfo iconInfo;
<     private int cachedTextSizeHint_width;
<     private int cachedTextSizeHint_height;
284a29,29
>         super ();
285,290d28
<         text = "";
<         setAlignmentFlags (CENTER, FLAG_TEXT_ALIGN);
<         setAlignmentFlags (CENTER, FLAG_ICON_ALIGN);
<         setAlignmentFlags (CENTER, FLAG_LABEL_ALIGN);
<         setAlignmentFlags (LEFT, FLAG_WRAP_ALIGN);
<         setPlacementFlags (EAST, FLAG_TEXT_PLACEMENT);
293a33,34
>         super (s);
>         setTextWrapAlignment (CENTER);
294,298d32
<         if (s != null) {
<             text = s;
<         } else {
<             text = "";
<         }
301a38,39
>         super (i);
>         setTextWrapAlignment (CENTER);
302,303d37
<         text = "";
<         iconInfo = new SingleIconInfo (i);
306a43,44
>         super (s, i);
>         setTextWrapAlignment (CENTER);
307,461d42
<         if (s != null) {
<             text = s;
<         } else {
<             text = "";
<         }
<         iconInfo = new SingleIconInfo (i);
<     }
< 
<     private IMapMode getFigureMapMode () {
<         return (IMapMode) getMapModeConstants ().mapModeRef.get ();
<     }
< 
<     private MapModeConstants getMapModeConstants () {
<         if (mapModeConstants == null) {
<             IMapMode mapMode = MapModeUtil.getMapMode (this);
<             while (mapMode instanceof IMapModeHolder) {
<                 mapMode = ((IMapModeHolder) mapMode).getMapMode ();
<             }
<             mapModeConstants = (MapModeConstants) mapModeConstantsMap.get (mapMode);
<             if (mapModeConstants == null) {
<                 mapModeConstants = new MapModeConstants (mapMode);
<                 mapModeConstantsMap.put (mapMode, mapModeConstants);
<             }
<         }
<         return mapModeConstants;
<     }
< 
<     private void alignOnHeight (Point loc, Dimension size, int alignment) {
<         switch (alignment) {
<             case TOP :
<                 loc.y = getInsets ().top;
<                 break;
<             case BOTTOM :
<                 loc.y = bounds.height - size.height - getInsets ().bottom;
<                 break;
<             default :
<                 loc.y = (bounds.height - size.height) / 2;
<         }
<     }
< 
<     private void alignOnWidth (Point loc, Dimension size, int alignment) {
<         switch (alignment) {
<             case LEFT :
<                 loc.x = getInsets ().left;
<                 break;
<             case RIGHT :
<                 loc.x = bounds.width - size.width - getInsets ().right;
<                 break;
<             default :
<                 loc.x = (bounds.width - size.width) / 2;
<         }
<     }
< 
<     private void calculateAlignment (Dimension iconSize, int textPlacement) {
<         switch (textPlacement) {
<             case EAST :
<             case WEST :
<                 alignOnHeight (textLocation, getTextSize (), getTextAlignment ());
<                 alignOnHeight (getIconLocation (), iconSize, getIconAlignment ());
<                 break;
<             case NORTH :
<             case SOUTH :
<                 alignOnWidth (textLocation, getSubStringTextSize (), getTextAlignment ());
<                 alignOnWidth (getIconLocation (), iconSize, getIconAlignment ());
<                 break;
<         }
<     }
< 
<     protected Dimension calculateLabelSize (Dimension txtSize) {
<         Dimension iconSize = getTotalIconSize ();
<         boolean isEmpty = (iconSize.width == 0 && iconSize.height == 0);
<         int len = getText ().length ();
<         if (len == 0 && isEmpty) {
<             return new Dimension (txtSize.width, txtSize.height);
<         }
<         int gap = (len == 0 || isEmpty) ? 0 : getIconTextGap ();
<         int placement = getTextPlacement ();
<         if (placement == WEST || placement == EAST) {
<             return new Dimension (iconSize.width + gap + txtSize.width, Math.max (iconSize.height, txtSize.height));
<         } else {
<             return new Dimension (Math.max (iconSize.width, txtSize.width), iconSize.height + gap + txtSize.height);
<         }
<     }
< 
<     private void calculateLocations () {
<         textLocation = new Point ();
<         iconLocation = new Point ();
<         Dimension iconSize = getTotalIconSize ();
<         int textPlacement = getTextPlacement ();
<         calculatePlacement (iconSize, textPlacement);
<         calculateAlignment (iconSize, textPlacement);
<         Rectangle r = getBounds ();
<         Dimension ps = getPreferredSize (r.width, r.height);
<         int w = (r.width - ps.width) + (getTextSize ().width - getSubStringTextSize ().width);
<         int h = r.height - ps.height;
<         if (w == 0 && h == 0) {
<             return;
<         }
<         Dimension offset = new Dimension (w, h);
<         switch (getLabelAlignment ()) {
<             case CENTER :
<                 offset.scale (0.5f);
<                 break;
<             case LEFT :
<                 offset.scale (0.0f);
<                 break;
<             case RIGHT :
<                 offset.scale (1.0f);
<                 break;
<             case TOP :
<                 offset.height = 0;
<                 offset.scale (0.5f);
<                 break;
<             case BOTTOM :
<                 offset.height = offset.height * 2;
<                 offset.scale (0.5f);
<                 break;
<             default :
<                 offset.scale (0.5f);
<                 break;
<         }
<         switch (textPlacement) {
<             case EAST :
<             case WEST :
<                 offset.height = 0;
<                 break;
<             case NORTH :
<             case SOUTH :
<                 offset.width = 0;
<                 break;
<         }
<         textLocation.translate (offset);
<         iconLocation.translate (offset);
<     }
< 
<     private void calculatePlacement (Dimension iconSize, int textPlacement) {
<         int gap = (getText ().length () == 0 || (iconSize.width == 0 && iconSize.height == 0)) ? 0 : getIconTextGap ();
<         Insets insets = getInsets ();
<         switch (textPlacement) {
<             case EAST :
<                 iconLocation.x = insets.left;
<                 textLocation.x = iconSize.width + gap + insets.left;
<                 break;
<             case WEST :
<                 textLocation.x = insets.left;
<                 iconLocation.x = getSubStringTextSize ().width + gap + insets.left;
<                 break;
<             case NORTH :
<                 textLocation.y = insets.top;
<                 iconLocation.y = getTextSize ().height + gap + insets.top;
<                 break;
<             case SOUTH :
<                 textLocation.y = iconSize.height + gap + insets.top;
<                 iconLocation.y = insets.top;
<         }
469a53,53
>         return getTextFlow ().getPreferredSize (wHint, hHint);
470,493d52
<         Font f = getFont ();
<         return getTextExtents (getWrappedText (wHint, hHint), f, getFigureMapMode ().DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ()));
<     }
< 
<     private void clearLocations () {
<         iconLocation = textLocation = null;
<     }
< 
<     public Image getIcon () {
<         return getIcon (0);
<     }
< 
<     public Image getIcon (int index) {
<         if (iconInfo == null) return null;
< 
<         return iconInfo.getIcon (index);
<     }
< 
<     protected boolean hasIcons () {
<         return (getNumberofIcons () > 0);
<     }
< 
<     public int getIconAlignment () {
<         return getAlignment (FLAG_ICON_ALIGN);
496a57,57
>         if (hasIcons ()) {
499,543d59
< 
<     protected Point getIconLocation () {
<         if (iconLocation == null) calculateLocations ();
< 
<         return iconLocation;
<     }
< 
<     public int getIconTextGap () {
<         return getMapModeConstants ().nDPtoLP_3;
<     }
< 
<     public Dimension getMinimumSize (int w, int h) {
<         if (minSize != null) return minSize;
< 
<         minSize = new Dimension ();
<         LayoutManager layoutManager = getLayoutManager ();
<         if (layoutManager != null) minSize.setSize (layoutManager.getMinimumSize (this, w, h));
< 
<         Font f = getFont ();
<         Dimension d = getEllipseTextSize ().getIntersected (getTextExtents (getText (), f, getFigureMapMode ().DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ())));
<         Dimension labelSize = calculateLabelSize (d);
<         Insets insets = getInsets ();
<         labelSize.expand (insets.getWidth (), insets.getHeight ());
<         minSize.union (labelSize);
<         return minSize;
<     }
< 
<     public Dimension getPreferredSize (int wHint, int hHint) {
<         if (prefSize == null || wHint != cachedPrefSizeHint_width || hHint != cachedPrefSizeHint_height) {
<             prefSize = calculateLabelSize (getTextSize (wHint, hHint));
<             Insets insets = getInsets ();
<             prefSize.expand (insets.getWidth (), insets.getHeight ());
<             LayoutManager layoutManager = getLayoutManager ();
<             if (layoutManager != null) {
<                 prefSize.union (layoutManager.getPreferredSize (this, wHint, hHint));
<             }
<             prefSize.union (getMinimumSize (wHint, hHint));
<             cachedPrefSizeHint_width = wHint;
<             cachedPrefSizeHint_height = hHint;
<         }
<         return prefSize;
<     }
< 
<     public Dimension getMaximumSize () {
<         return prefSize;
572,572c89,89
<         int widthHint = Math.max (effectiveSizeWidth - getEllipseTextSize ().width, 0);
---
>         int widthHint = Math.max (effectiveSizeWidth - getTruncationStringSize ().width, 0);
589,632d105
<     private String getWrappedText (int wHint, int hHint) {
<         String theText = getText ();
<         if (wHint == - 1 || theText.length () == 0 || ! isTextWrapped ()) return theText;
< 
<         Dimension iconSize = getTotalIconSize ();
<         if (! (iconSize.width == 0 && iconSize.height == 0)) {
<             switch (getTextPlacement ()) {
<                 case EAST :
<                 case WEST :
<                     wHint -= iconSize.width + getIconTextGap ();
<                     break;
<                 case NORTH :
<                 case SOUTH :
<                     if (hHint != - 1) hHint -= iconSize.height + getIconTextGap ();
< 
<                     break;
<             }
<         }
<         if ((hHint == 0) || (wHint == 0)) {
<             return "";
<         }
<         Font f = getFont ();
<         int fontHeight = getFigureMapMode ().DPtoLP (FigureUtilities.getFontMetrics (f).getHeight ());
<         int maxLines = Integer.MAX_VALUE;
<         if (hHint != - 1) {
<             maxLines = (int) (hHint / (double) fontHeight);
<             if (maxLines == 0) {
<                 return "";
<             }
<         }
<         StringBuffer accumlatedText = new StringBuffer ();
<         StringBuffer remainingText = new StringBuffer (theText);
<         int i = 0, j = 0;
<         while (remainingText.length () > 0 && j ++ < maxLines) {
<             if ((i = getLineWrapPosition (remainingText.toString (), f, wHint, fontHeight)) == 0) break;
< 
<             if (accumlatedText.length () > 0) accumlatedText.append ('\n');
< 
<             accumlatedText.append (remainingText.substring (0, i));
<             remainingText.delete (0, i);
<         }
<         return accumlatedText.toString ();
<     }
< 
637,659d109
<     private Dimension getEllipseTextSize () {
<         if (ellipseTextSize == null) {
<             ellipseTextSize = getMapModeConstants ().getEllipseTextSize (getFont ());
<         }
<         return ellipseTextSize;
<     }
< 
<     public String getText () {
<         return text;
<     }
< 
<     public int getTextAlignment () {
<         return getAlignment (FLAG_TEXT_ALIGN);
<     }
< 
<     private int getLabelAlignment () {
<         return getAlignment (FLAG_LABEL_ALIGN);
<     }
< 
<     public Rectangle getTextBounds () {
<         return new Rectangle (getBounds ().getLocation ().translate (getTextLocation ()), getTextSize ());
<     }
< 
660a111,111
>         return getTextBounds ().getLocation ();
661,668d110
<         if (textLocation != null) return textLocation;
< 
<         calculateLocations ();
<         return textLocation;
<     }
< 
<     public int getTextPlacement () {
<         return getPlacement (FLAG_TEXT_PLACEMENT);
671a115,115
>         return getTextFlow ().getPreferredSize (wHint, hHint);
672,677d114
<         if (textSize == null || wHint != cachedTextSizeHint_width || hHint != cachedTextSizeHint_height) {
<             textSize = calculateTextSize (wHint, hHint);
<             cachedTextSizeHint_width = wHint;
<             cachedTextSizeHint_height = hHint;
<         }
<         return textSize;
686,690d123
<         prefSize = null;
<         minSize = null;
<         clearLocations ();
<         ellipseTextSize = null;
<         textSize = null;
692,693d124
<         if (iconInfo != null) iconInfo.invalidate ();
< 
701,864d131
<     public void paintFigure (Graphics graphics) {
<         if (isSelected ()) {
<             graphics.pushState ();
<             graphics.setBackgroundColor (ColorConstants.menuBackgroundSelected);
<             graphics.fillRectangle (getSelectionRectangle ());
<             graphics.popState ();
<             graphics.setForegroundColor (ColorConstants.white);
<         }
<         if (hasFocus ()) {
<             graphics.pushState ();
<             graphics.setXORMode (true);
<             graphics.setForegroundColor (ColorConstants.menuBackgroundSelected);
<             graphics.setBackgroundColor (ColorConstants.white);
<             graphics.drawFocus (getSelectionRectangle ().resize (- 1, - 1));
<             graphics.popState ();
<         }
<         if (isOpaque ()) super.paintFigure (graphics);
< 
<         Rectangle figBounds = getBounds ();
<         graphics.translate (figBounds.x, figBounds.y);
<         if (hasIcons ()) paintIcons (graphics);
< 
<         String subString = getSubStringText ();
<         if (subString.length () > 0) {
<             if (! isEnabled ()) {
<                 graphics.translate (1, 1);
<                 graphics.setForegroundColor (ColorConstants.buttonLightest);
<                 paintText (graphics, subString);
<                 graphics.translate (- 1, - 1);
<                 graphics.setForegroundColor (ColorConstants.buttonDarker);
<             } else {
<                 paintText (graphics, subString);
<             }
<         }
<         graphics.translate (- figBounds.x, - figBounds.y);
<     }
< 
<     private void paintText (Graphics graphics, String subString) {
<         StringTokenizer tokenizer = new StringTokenizer (subString, "\n");
<         Font f = getFont ();
<         FontMetrics fontMetrics = FigureUtilities.getFontMetrics (f);
<         int fontHeight = getFigureMapMode ().DPtoLP (fontMetrics.getHeight ());
<         int fontHeightHalf = fontHeight / 2;
<         int textWidth = getTextExtents (subString, f, fontHeight).width;
<         Point p = getTextLocation ();
<         int y = p.y;
<         int x = p.x;
<         final int wrapAlignment = getTextWrapAlignment ();
<         boolean isUnderlined = isTextUnderlined ();
<         boolean isStrikedThrough = isTextStrikedThrough ();
<         Rectangle clipRect = new Rectangle ();
<         graphics.getClip (clipRect);
<         int clipRectTopRight_x = clipRect.getTopRight ().x;
<         if (0 == fontMetrics.getLeading ()) {
<             y += getMapModeConstants ().nDPtoLP_2;
<         }
<         while (tokenizer.hasMoreTokens ()) {
<             x = p.x;
<             String token = tokenizer.nextToken ();
<             int tokenWidth = getTextExtents (token, f, fontHeight).width;
<             switch (wrapAlignment) {
<                 case CENTER :
<                     x += (textWidth - tokenWidth) / 2;
<                     break;
<                 case RIGHT :
<                     x += textWidth - tokenWidth;
<                     break;
<             }
<             if (tokenWidth + x <= clipRectTopRight_x) {
<                 Rectangle newClipRect = new Rectangle (clipRect);
<                 newClipRect.width += (tokenWidth / token.length ()) / 2;
<                 graphics.setClip (newClipRect);
<             }
<             graphics.drawText (token, x, y);
<             graphics.setClip (clipRect);
<             y += fontHeight;
<             if (isUnderlined) graphics.drawLine (x, y - 1, x + tokenWidth, y - 1);
< 
<             if (isStrikedThrough) graphics.drawLine (x, y - fontHeightHalf + 1, x + tokenWidth, y - fontHeightHalf + 1);
< 
<         }
<     }
< 
<     private void paintIcons (Graphics graphics) {
<         Point p = Point.SINGLETON;
<         p.setLocation (getIconLocation ());
<         int num = getNumberofIcons ();
<         for (int i = 0;
<         i < num; i ++) {
<             Image icon = getIcon (i);
<             if (icon != null) {
<                 graphics.drawImage (icon, p);
<                 p.x += getIconSize (i).width;
<             }
<         }
<     }
< 
<     public void setIcon (Image image) {
<         setIcon (image, 0);
<     }
< 
<     public void setIcon (Image image, int index) {
<         if (iconInfo == null) {
<             if (index == 0) {
<                 iconInfo = getMapModeConstants ().getSingleIconInfo (image);
<             } else {
<                 iconInfo = new MultiIconInfo ();
<                 iconInfo.setIcon (image, index);
<             }
<             revalidate ();
<             repaint ();
<         } else if (iconInfo.getIcon (index) != image) {
<             if (iconInfo.getMaxIcons () == 1) {
<                 if (index == 0) {
<                     iconInfo = getMapModeConstants ().getSingleIconInfo (image);
<                     revalidate ();
<                     repaint ();
<                     return;
<                 }
<                 IconInfo oldIconInfo = iconInfo;
<                 iconInfo = new MultiIconInfo ();
<                 iconInfo.setIcon (oldIconInfo.getIcon (0), 0);
<             }
<             iconInfo.setIcon (image, index);
<             revalidate ();
<             repaint ();
<         }
< 
<     }
< 
<     public void setIconAlignment (int align) {
<         if (getIconAlignment () == align) return;
< 
<         setAlignmentFlags (align, FLAG_ICON_ALIGN);
<         clearLocations ();
<         repaint ();
<     }
< 
<     protected Dimension getIconSize (int index) {
<         if (iconInfo == null) return EMPTY_DIMENSION;
< 
<         return iconInfo.getIconSize (getFigureMapMode (), index);
<     }
< 
<     protected int getNumberofIcons () {
<         if (iconInfo == null) return 0;
< 
<         return iconInfo.getNumberofIcons ();
<     }
< 
<     protected Dimension getTotalIconSize () {
<         if (iconInfo == null) return EMPTY_DIMENSION;
< 
<         return iconInfo.getTotalIconSize (getFigureMapMode ());
<     }
< 
<     public void setLabelAlignment (int align) {
<         if (getLabelAlignment () == align) return;
< 
<         setAlignmentFlags (align, FLAG_LABEL_ALIGN);
<         clearLocations ();
<         repaint ();
<     }
< 
866,866c133,133
<         return _ellipse;
---
>         return ELLIPSIS;
868a136,138
>     protected String getTruncationString () {
>         if (getEllipse () != null) {
>             return getEllipse ();
869,876d135
<     public void setText (String s) {
<         if (s == null) s = "";
< 
<         if (text.equals (s)) return;
< 
<         text = s;
<         revalidate ();
<         repaint ();
877a140,140
>         return ELLIPSIS;
878,922d139
< 
<     public void setTextAlignment (int align) {
<         if (getTextAlignment () == align) return;
< 
<         setAlignmentFlags (align, FLAG_TEXT_ALIGN);
<         clearLocations ();
<         repaint ();
<     }
< 
<     public void setTextPlacement (int where) {
<         if (getTextPlacement () == where) return;
< 
<         setPlacementFlags (where, FLAG_TEXT_PLACEMENT);
<         revalidate ();
<         repaint ();
<     }
< 
<     public void setTextUnderline (boolean b) {
<         if (isTextUnderlined () == b) return;
< 
<         setFlag (FLAG_UNDERLINED, b);
<         repaint ();
<     }
< 
<     public boolean isTextUnderlined () {
<         return (flags & FLAG_UNDERLINED) != 0;
<     }
< 
<     public void setTextStrikeThrough (boolean b) {
<         if (isTextStrikedThrough () == b) return;
< 
<         setFlag (FLAG_STRIKEDTHROUGH, b);
<         repaint ();
<     }
< 
<     public boolean isTextStrikedThrough () {
<         return (flags & FLAG_STRIKEDTHROUGH) != 0;
<     }
< 
<     public void setTextWrap (boolean b) {
<         if (isTextWrapped () == b) return;
< 
<         setFlag (FLAG_WRAP, b);
<         revalidate ();
<         repaint ();
925a144,144
>         return isTextWrapOn ();
926,926c60,60
<         return (flags & FLAG_WRAP) != 0;
---
>         return new Rectangle (0, 0, 0, 0);
932a151,154
>         setTextJustification (i);
>         switch (i) {
>             case LEFT :
>                 setAlignment (TOP | LEFT);
933,956d150
<         if (getTextWrapAlignment () == i) return;
< 
<         setAlignmentFlags (i, FLAG_WRAP_ALIGN);
<         repaint ();
<     }
< 
<     public int getTextWrapAlignment () {
<         return getAlignment (FLAG_WRAP_ALIGN);
<     }
< 
<     private void setPlacementFlags (int align, int flagOffset) {
<         flags &= ~ (0x7 * flagOffset);
<         switch (align) {
<             case EAST :
<                 flags |= 0x1 * flagOffset;
<                 break;
<             case WEST :
<                 flags |= 0x2 * flagOffset;
<                 break;
<             case NORTH :
<                 flags |= 0x3 * flagOffset;
<                 break;
<             case SOUTH :
<                 flags |= 0x4 * flagOffset;
958,973d155
<         }
<     }
< 
<     private int getPlacement (int flagOffset) {
<         int wrapValue = flags & (0x7 * flagOffset);
<         if (wrapValue == 0x1 * flagOffset) return EAST;
<         else if (wrapValue == 0x2 * flagOffset) return WEST;
<         else if (wrapValue == 0x3 * flagOffset) return NORTH;
<         else if (wrapValue == 0x4 * flagOffset) return SOUTH;
< 
<         return EAST;
<     }
< 
<     private void setAlignmentFlags (int align, int flagOffset) {
<         flags &= ~ (0x7 * flagOffset);
<         switch (align) {
974a157,157
>                 setAlignment (TOP);
975,981d156
<                 flags |= 0x1 * flagOffset;
<                 break;
<             case TOP :
<                 flags |= 0x2 * flagOffset;
<                 break;
<             case LEFT :
<                 flags |= 0x3 * flagOffset;
983a160,160
>                 setAlignment (TOP | RIGHT);
984,984d159
<                 flags |= 0x4 * flagOffset;
985a162,162
>             default :
986,987d161
<             case BOTTOM :
<                 flags |= 0x5 * flagOffset;
991a167,167
>     public void setLabelAlignment (int alignment) {
992,1000d166
<     private int getAlignment (int flagOffset) {
<         int wrapValue = flags & (0x7 * flagOffset);
<         if (wrapValue == 0x1 * flagOffset) return CENTER;
<         else if (wrapValue == 0x2 * flagOffset) return TOP;
<         else if (wrapValue == 0x3 * flagOffset) return LEFT;
<         else if (wrapValue == 0x4 * flagOffset) return RIGHT;
<         else if (wrapValue == 0x5 * flagOffset) return BOTTOM;
< 
<         return CENTER;
1002a170,171
>     public int getTextWrapAlignment () {
>         return getTextJustification ();
1003,1031d169
<     public void setSelected (boolean b) {
<         if (isSelected () == b) return;
< 
<         setFlag (FLAG_SELECTED, b);
<         repaint ();
<     }
< 
<     public boolean isSelected () {
<         return (flags & FLAG_SELECTED) != 0;
<     }
< 
<     public void setFocus (boolean b) {
<         if (hasFocus () == b) return;
< 
<         setFlag (FLAG_HASFOCUS, b);
<         repaint ();
<     }
< 
<     public boolean hasFocus () {
<         return (flags & FLAG_HASFOCUS) != 0;
<     }
< 
<     private Rectangle getSelectionRectangle () {
<         Rectangle figBounds = getTextBounds ();
<         int expansion = getMapModeConstants ().nDPtoLP_2;
<         figBounds.resize (expansion, expansion);
<         translateToParent (figBounds);
<         figBounds.intersect (getBounds ());
<         return figBounds;
