8a9,10
> import java.util.Collection;
> 
10a13,14
> import java.util.LinkedList;
> 
36a41,44
> import org.eclipse.emf.ecore.EReference;
> 
> import org.eclipse.emf.ecore.EStructuralFeature;
> 
40a49,52
> import org.eclipse.emf.ecore.util.EcoreUtil;
> 
> import org.eclipse.emf.ecore.util.EcoreUtil.ExternalCrossReferencer;
> 
388a401,409
>         try {
>             Resource gmfgenRes = rs.getResource (getGenURI (), true);
>             updateExistingResource (gmfgenRes, genBurdern);
>             final Map < String, Object > saveOptions = getSaveOptions ();
>             if (gmfgenRes.getContents ().size () > 1 && Plugin.ignoreDanglingHrefOnSave ()) {
>                 saveOptions.put (XMLResource.OPTION_PROCESS_DANGLING_HREF, XMLResource.OPTION_PROCESS_DANGLING_HREF_RECORD);
>             }
>             gmfgenRes.save (saveOptions);
>         } catch (RuntimeException ex) {
392a414,478
>     }
> 
>     private static void updateExistingResource (Resource gmfgenRes, GenEditorGenerator genBurden) {
>         boolean editorGenFound = false;
>         for (int i = 0;
>         ! editorGenFound && i < gmfgenRes.getContents ().size (); i ++) {
>             if (gmfgenRes.getContents ().get (i) instanceof GenEditorGenerator) {
>                 if (gmfgenRes.getContents ().size () > 1) {
>                     LinkedList < EObject > rest = new LinkedList < EObject > (gmfgenRes.getContents ());
>                     GenEditorGenerator oldEditorGenerator = (GenEditorGenerator) rest.remove (i);
>                     updateExternalReferences (genBurden, oldEditorGenerator, rest);
>                 }
>                 gmfgenRes.getContents ().set (i, genBurden);
>                 editorGenFound = true;
>             }
>         }
>         if (! editorGenFound) {
>             gmfgenRes.getContents ().add (genBurden);
>         }
>     }
> 
>     private static void updateExternalReferences (GenEditorGenerator newEditorGenerator, final GenEditorGenerator oldEditorGenerator, List < EObject > allContentButOldGenerator) {
>         final Map < EObject, Collection < EStructuralFeature.Setting > > crossReferences = new ExternalCrossReferencer (allContentButOldGenerator) {
> 
>             @Override
>             protected boolean crossReference (EObject object, EReference reference, EObject crossReferencedEObject) {
>                 return super.crossReference (object, reference, crossReferencedEObject) && EcoreUtil.isAncestor (oldEditorGenerator, crossReferencedEObject);
>             }
> 
>             Map < EObject, Collection < EStructuralFeature.Setting > > find () {
>                 return findExternalCrossReferences ();
>             }
> 
>         }
> 
>         .find ();
>         new Reconciler (new GMFGenConfig ()) {
> 
>             @Override
>             protected void handleNotMatchedCurrent (EObject current) {
>             }
> 
>             ;
> 
>             @Override
>             protected EObject handleNotMatchedOld (EObject currentParent, EObject notMatchedOld) {
>                 return null;
>             }
> 
>             ;
> 
>             @Override
>             protected void reconcileVertex (EObject current, EObject old) {
>                 if (! crossReferences.containsKey (old)) {
>                     return;
>                 }
>                 for (EStructuralFeature.Setting s : crossReferences.get (old)) {
>                     s.set (current);
>                 }
>             }
> 
>         }
> 
>         .reconcileTree (newEditorGenerator, oldEditorGenerator);
>     }
394,394c480,480
<     private Map < ?, ? > getSaveOptions () {
---
>     private Map < String, Object > getSaveOptions () {
