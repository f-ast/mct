22a29,30
> import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;
> 
38a19,19
> import org.eclipse.draw2d.geometry.PrecisionPoint;
39,39d18
< import org.eclipse.swt.graphics.Rectangle;
40a21,24
> import org.eclipse.draw2d.geometry.PrecisionRectangle;
> 
> import org.eclipse.draw2d.geometry.Rectangle;
> 
40,40c20,20
< 
---
> 
54,54c60,60
<         image = new Image (display, new Rectangle (0, 0, width, height));
---
>         image = new Image (display, new org.eclipse.swt.graphics.Rectangle (0, 0, width, height));
102a109,154
>     public java.awt.Image createConstrainedAWTImageForParts (List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
>         BufferedImage awtImage = null;
>         IMapMode mm = getMapMode ();
>         Rectangle originalBounds = new PrecisionRectangle (new Rectangle (calculateImageRectangle (editParts)));
>         mm.LPtoDP (originalBounds);
>         int deviceMargins = mm.LPtoDP (getImageMargin ());
>         int threshold = useMargins ? deviceMargins : 0;
>         double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
>         originalBounds.shrink (deviceMargins, deviceMargins);
>         if (maxDeviceWidth > threshold) {
>             xScalingFactor = (maxDeviceWidth - threshold - threshold) / (originalBounds.preciseWidth ());
>         }
>         if (maxDeviceHeight > threshold) {
>             yScalingFactor = (maxDeviceHeight - threshold - threshold) / (originalBounds.preciseHeight ());
>         }
>         double scalingFactor = Math.min (Math.min (xScalingFactor, yScalingFactor), 1);
>         int imageWidth = originalBounds.width + threshold + threshold;
>         int imageHeight = originalBounds.height + threshold + threshold;
>         if (scalingFactor < 1) {
>             imageWidth = (int) Math.round (originalBounds.preciseWidth () * scalingFactor) + threshold + threshold;
>             imageHeight = (int) Math.round (originalBounds.preciseHeight () * scalingFactor) + threshold + threshold;
>         }
>         awtImage = new BufferedImage (imageWidth, imageHeight, BufferedImage.TYPE_4BYTE_ABGR_PRE);
>         Graphics2D g2d = awtImage.createGraphics ();
>         g2d.setColor (Color.white);
>         g2d.fillRect (0, 0, awtImage.getWidth (), awtImage.getHeight ());
>         IPreferenceStore preferenceStore = (IPreferenceStore) getDiagramEditPart ().getDiagramPreferencesHint ().getPreferenceStore ();
>         if (preferenceStore.getBoolean (IPreferenceConstants.PREF_ENABLE_ANTIALIAS)) {
>             g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
>         } else {
>             g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
>         }
>         g2d.clip (new java.awt.Rectangle (0, 0, awtImage.getWidth (), awtImage.getHeight ()));
>         Graphics graphics = new GraphicsToGraphics2DAdaptor (g2d, new org.eclipse.swt.graphics.Rectangle (0, 0, imageWidth, imageHeight));
>         ScaledGraphics scaledGraphics = new ScaledGraphics (graphics);
>         RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics (scaledGraphics, mm);
>         g2d.translate (threshold, threshold);
>         mapModeGraphics.scale (scalingFactor);
>         Point location = new PrecisionPoint (originalBounds.preciseX (), originalBounds.preciseY ());
>         mm.DPtoLP (location);
>         renderToGraphics (mapModeGraphics, location, editParts);
>         graphics.dispose ();
>         g2d.dispose ();
>         return awtImage;
>     }
> 
