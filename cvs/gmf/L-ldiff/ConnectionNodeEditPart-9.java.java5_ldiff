2a3,6
> import java.util.HashSet;
> 
> import java.util.Iterator;
> 
4a9,10
> import org.eclipse.draw2d.Connection;
> 
12a19,20
> import org.eclipse.gef.EditPart;
> 
22a31,32
> import org.eclipse.gef.requests.ReconnectRequest;
> 
36a47,48
> import org.eclipse.gmf.runtime.diagram.ui.internal.editpolicies.NoteAttachmentReorientEditPolicy;
> 
55a68,68
>         installEditPolicy ("NoteAttachmentReorient", new NoteAttachmentReorientEditPolicy ());
175a189,240
>     private void getSourceAndTargetConnections (HashSet set, org.eclipse.gef.ConnectionEditPart connectionEditPart) {
>         if (connectionEditPart == null || set == null) return;
> 
>         for (Iterator i = connectionEditPart.getSourceConnections ().iterator ();
>         i.hasNext ();) {
>             org.eclipse.gef.ConnectionEditPart next = (org.eclipse.gef.ConnectionEditPart) i.next ();
>             Connection sourceConnection = (Connection) next.getFigure ();
>             set.add (sourceConnection);
>             getSourceAndTargetConnections (set, next);
>         }
>         for (Iterator i = connectionEditPart.getTargetConnections ().iterator ();
>         i.hasNext ();) {
>             org.eclipse.gef.ConnectionEditPart next = (org.eclipse.gef.ConnectionEditPart) i.next ();
>             Connection targetConnection = (Connection) next.getFigure ();
>             set.add (targetConnection);
>             getSourceAndTargetConnections (set, next);
>         }
>     }
> 
>     private boolean isCyclicConnectionRequest (org.eclipse.gef.ConnectionEditPart targetCEP, org.eclipse.gef.ConnectionEditPart sourceCEP, boolean checkSourceAndTargetEditParts, boolean doNotCheckSourceEditPart) {
>         if (targetCEP == null || sourceCEP == null) return false;
> 
>         HashSet set = new HashSet ();
>         getSourceAndTargetConnections (set, sourceCEP);
>         if (set.contains (targetCEP.getFigure ())) return true;
> 
>         EditPart sourceEP = sourceCEP.getSource (), targetEP = sourceCEP.getTarget ();
>         if ((sourceEP == targetCEP) || (targetEP == targetCEP)) {
>             return true;
>         } else {
>             if (! checkSourceAndTargetEditParts && doNotCheckSourceEditPart) {
>             } else if (sourceEP instanceof org.eclipse.gef.ConnectionEditPart && isCyclicConnectionRequest (targetCEP, (org.eclipse.gef.ConnectionEditPart) sourceEP, true, doNotCheckSourceEditPart)) return true;
> 
>             if (! checkSourceAndTargetEditParts && ! doNotCheckSourceEditPart) {
>             } else if (targetEP instanceof org.eclipse.gef.ConnectionEditPart && isCyclicConnectionRequest (targetCEP, (org.eclipse.gef.ConnectionEditPart) targetEP, true, doNotCheckSourceEditPart)) return true;
> 
>         }
>         return false;
>     }
> 
>     public EditPart getTargetEditPart (Request request) {
>         EditPart ep = super.getTargetEditPart (request);
>         if (ep != null && ep instanceof org.eclipse.gef.ConnectionEditPart) {
>             if (request instanceof ReconnectRequest) {
>                 ReconnectRequest rRequest = (ReconnectRequest) request;
>                 if (isCyclicConnectionRequest ((org.eclipse.gef.ConnectionEditPart) ep, rRequest.getConnectionEditPart (), false, rRequest.isMovingStartAnchor ())) return null;
> 
>             }
>         }
>         return ep;
>     }
> 
