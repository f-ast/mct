4a5,6
> import java.util.Collections;
> 
12a15,16
> import org.eclipse.emf.common.command.AbstractCommand;
> 
14a19,20
> import org.eclipse.emf.common.command.CompoundCommand;
> 
32a39,40
> import org.eclipse.emf.transaction.TransactionChangeDescription;
> 
47,47c55,55
< import org.eclipse.emf.transaction.util.CompositeChangeDescription;
---
> import org.eclipse.emf.transaction.util.TriggerCommand;
130a139,153
>         public void precommit (InternalTransaction tx) throws RollbackException {
>             super.precommit (tx);
>             if ((tx.getParent () == null) && (deb != null)) {
>                 Command existingTriggers = tx.getTriggers ();
>                 if (existingTriggers instanceof CompoundCommand) {
>                 } else if (existingTriggers != null) {
>                     tx.addTriggers (NOOP_TRIGGER);
>                 } else {
>                     tx.addTriggers (NOOP_TRIGGER);
>                     tx.addTriggers (NOOP_TRIGGER);
>                 }
> 
>             }
>         }
> 
140a164,164
>                         originatingTransaction.addTriggers (new TriggerCommand (Collections.singletonList (new DiagramEventBrokerCommand (tx.getChangeDescription ()))));
141,141d163
<                         ((CompositeChangeDescription) originatingTransaction.getChangeDescription ()).add (tx.getChangeDescription ());
169a193,246
>     private static class DiagramEventBrokerCommand extends AbstractCommand {
>         private final TransactionChangeDescription change;
> 
>         DiagramEventBrokerCommand (TransactionChangeDescription change) {
>             this.change = change;
>         }
> 
>         protected boolean prepare () {
>             return true;
>         }
> 
>         public final void execute () {
>         }
> 
>         public boolean canUndo () {
>             return (change != null) && change.canApply ();
>         }
> 
>         public final void undo () {
>             if (change != null) {
>                 change.applyAndReverse ();
>             }
>         }
> 
>         public final void redo () {
>             if (change != null) {
>                 change.applyAndReverse ();
>             }
>         }
> 
>     }
> 
>     static final TriggerCommand NOOP_TRIGGER = new TriggerCommand (Collections.singletonList (new AbstractCommand () {
> 
>         protected boolean prepare () {
>             return true;
>         }
> 
>         public void execute () {
>         }
> 
>         public boolean canUndo () {
>             return true;
>         }
> 
>         public void undo () {
>         }
> 
>         public void redo () {
>         }
> 
>     }
> 
>     ));
