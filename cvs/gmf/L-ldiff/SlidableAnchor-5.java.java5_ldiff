3,4d2
< import org.eclipse.draw2d.AbstractConnectionAnchor;
< 
7,10d4
< import org.eclipse.draw2d.geometry.Point;
< 
< import org.eclipse.draw2d.geometry.PointList;
< 
17,18d10
< import org.eclipse.gmf.runtime.common.core.util.StringStatics;
< 
19,19c11,11
< import org.eclipse.gmf.runtime.draw2d.ui.figures.IPolygonAnchorableFigure;
---
> import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.BaseSlidableAnchor;
20,21d11
< 
< import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
22a13,13
> public class SlidableAnchor extends BaseSlidableAnchor {
23,29d12
< import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
< 
< public class SlidableAnchor extends AbstractConnectionAnchor {
<     final private static char TERMINAL_START_CHAR = '(';
<     final private static char TERMINAL_DELIMITER_CHAR = ',';
<     final private static char TERMINAL_END_CHAR = ')';
<     private PrecisionPoint relativeReference;
38a23,23
>         super (f, p);
39,128d22
<         super (f);
<         this.relativeReference = new PrecisionPoint (p.preciseX, p.preciseY);
<     }
< 
<     public String getTerminal () {
<         if (isDefaultAnchor ()) return StringStatics.BLANK;
< 
<         return composeTerminalString (relativeReference);
<     }
< 
<     public Point getReferencePoint () {
<         Point p = new Point ();
<         if (getOwner () instanceof NodeFigure) {
<             p = getAnchorPosition ();
<         }
<         return p;
<     }
< 
<     public static String composeTerminalString (PrecisionPoint p) {
<         StringBuffer s = new StringBuffer (24);
<         s.append (TERMINAL_START_CHAR);
<         s.append ((float) p.preciseX);
<         s.append (TERMINAL_DELIMITER_CHAR);
<         s.append ((float) p.preciseY);
<         s.append (TERMINAL_END_CHAR);
<         return s.toString ();
<     }
< 
<     private Point getAnchorPosition () {
<         Rectangle rBox = getBox ();
<         if (isDefaultAnchor ()) return rBox.getCenter ();
< 
<         return new Point (Math.round (relativeReference.preciseX * rBox.width + rBox.x), Math.round (relativeReference.preciseY * rBox.height + rBox.y));
<     }
< 
<     protected Point getLocation (Point ownReference, Point foreignReference) {
<         PointList intersections = getIntersectionPoints (ownReference, foreignReference);
<         if (intersections != null && intersections.size () != 0) {
<             Point location = PointListUtilities.pickClosestPoint (intersections, foreignReference);
<             return location;
<         }
<         return null;
<     }
< 
<     static private int STRAIGHT_LINE_TOLERANCE = 10;
< 
<     public Point getLocation (Point reference) {
<         Point foreignReference = reference.getCopy ();
<         Point ownReference = getReferencePoint ().getCopy ();
<         ownReference = normalizeToStraightlineTolerance (foreignReference, ownReference, STRAIGHT_LINE_TOLERANCE);
<         Point location = getLocation (ownReference, foreignReference);
<         if (location == null || getBox ().expand (1, 1).contains (foreignReference) && ! getBox ().shrink (1, 1).contains (foreignReference)) location = getLocation (getBox ().getCenter (), foreignReference);
< 
<         if (location == null) {
<             location = getBox ().getCenter ();
<         }
<         return location;
<     }
< 
<     protected Point normalizeToStraightlineTolerance (Point foreignReference, Point ownReference, int tolerance) {
<         Point normalizedReference = ownReference.getCopy ();
<         if (Math.abs (foreignReference.x - ownReference.x) < tolerance || Math.abs (foreignReference.y - ownReference.y) < tolerance) {
<             LineSeg lineSeg = new LineSeg (ownReference, foreignReference);
<             normalizedReference = lineSeg.perpIntersect (ownReference.x, ownReference.y);
<             if (Math.abs (normalizedReference.x - foreignReference.x) < Math.abs (normalizedReference.y - foreignReference.y)) normalizedReference.x = foreignReference.x;
<             else normalizedReference.y = foreignReference.y;
< 
<         }
<         return normalizedReference;
<     }
< 
<     protected PointList getIntersectionPoints (Point ownReference, Point foreignReference) {
<         final PointList polygon = getPolygonPoints ();
<         return (new LineSeg (ownReference, foreignReference)).getLineIntersectionsWithLineSegs (polygon);
<     }
< 
<     protected PointList getPolygonPoints () {
<         if (getOwner () instanceof IPolygonAnchorableFigure) {
<             PointList polyList = ((IPolygonAnchorableFigure) getOwner ()).getPolygonPoints ();
<             getOwner ().translateToAbsolute (polyList);
<             return polyList;
<         }
<         Rectangle rBox = getBox ();
<         PointList ptList = new PointList ();
<         ptList.addPoint (rBox.getTopLeft ());
<         ptList.addPoint (rBox.getTopRight ());
<         ptList.addPoint (rBox.getBottomRight ());
<         ptList.addPoint (rBox.getBottomLeft ());
<         ptList.addPoint (rBox.getTopLeft ());
<         return ptList;
139,150d33
<     public boolean isDefaultAnchor () {
<         return relativeReference == null;
<     }
< 
<     public static PrecisionPoint parseTerminalString (String terminal) {
<         try {
<             return new PrecisionPoint (Float.parseFloat (terminal.substring (terminal.indexOf (SlidableAnchor.TERMINAL_START_CHAR) + 1, terminal.indexOf (SlidableAnchor.TERMINAL_DELIMITER_CHAR))), Float.parseFloat (terminal.substring (terminal.indexOf (SlidableAnchor.TERMINAL_DELIMITER_CHAR) + 1, terminal.indexOf (SlidableAnchor.TERMINAL_END_CHAR))));
<         } catch (Exception e) {
<             return null;
<         }
<     }
< 
