11a12,12
>     private final EStructuralFeature myFeature;
12,18d11
<     private EClass myOwner;
<     private Reflector myReflector;
<     public interface Reflector {
< 
<         public Object reflect (EObject target);
< 
<     }
20a15,16
>         assert feature != null;
>         myFeature = feature;
21,26d14
<         this (feature.getEContainingClass (), new StructuralFeatureReflector (feature));
<     }
< 
<     public ReflectiveMatcher (EClass reflectorOwner, Reflector reflector) {
<         myOwner = reflectorOwner;
<         myReflector = reflector;
31a22,22
>         Object currentValue = current.eGet (myFeature);
32,32d21
<         Object currentValue = myReflector.reflect (current);
33,33c23,23
<         return currentValue != null && currentValue.equals (myReflector.reflect (old));
---
>         return currentValue != null && currentValue.equals (old.eGet (myFeature));
42a33,33
>         if (! myFeature.getEContainingClass ().isSuperTypeOf (eClass)) {
43,43d32
<         if (! myOwner.isSuperTypeOf (eClass)) {
44,44c34,34
<             throw new IllegalStateException (MessageFormat.format ("EClass {0} is not compatible with expected class {1} ", new Object [] {eClass, myOwner}));
---
>             throw new IllegalStateException (MessageFormat.format ("EClass {0} is not compatible with expected class {1} ", new Object [] {eClass, myFeature.getEContainingClass ()}));
45,45d34
<         }
47,59d35
< 
<     public static class StructuralFeatureReflector implements Reflector {
<         private final EStructuralFeature myFeature;
< 
<         public StructuralFeatureReflector (EStructuralFeature feature) {
<             assert feature != null;
<             myFeature = feature;
<         }
< 
<         public Object reflect (EObject target) {
<             return target.eGet (myFeature);
<         }
< 
