head	1.16;
access;
symbols
	v20080813-1520:1.16
	v20080806-1520:1.16
	v20080731-1520:1.16
	v20061027-1200:1.12
	v20061013-1330:1.14
	v20060925-1700:1.12
	v20060919-0800:1.12
	M1_20:1.14
	v20060904-1500:1.14
	v20060713-1700:1.12
	R1_0_maintenance:1.12.0.2
	R1_0:1.12
	v20060627-1200:1.12
	v20060626-1420:1.12
	v20060616-1200:1.11
	v20060531-1730:1.11
	v20060530-1930:1.11
	v20060526-1200:1.11
	v20060519-1300:1.11
	v20060519-0800:1.11
	I20060505-1400:1.10
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.7
	I20060407-1200:1.6
	I20060331-1000:1.5
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.16
date	2006.11.02.21.58.36;	author atikhomirov;	state dead;
branches;
next	1.15;

1.15
date	2006.11.01.12.49.44;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.24.15.38.55;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.24.13.13.37;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.26.16.49.27;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.18.19.12.40;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.02.15.05.35;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.02.11.44.18;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.21.17.47.10;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.13.15.03.34;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.07.14.49.17;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.30.22.39.09;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.13.17.53.19;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.27.17.40.11;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.06.22.21.42;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.06.18.10.22;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.16
log
@JET templates for gmfgraph model replaced with Xpand counterparts.
MapMode handling simplified
@
text
@package org.eclipse.gmf.graphdef.codegen.templates;

import org.eclipse.gmf.gmfgraph.*;
import org.eclipse.gmf.common.codegen.*;
import org.eclipse.gmf.graphdef.codegen.*;
import org.eclipse.emf.ecore.*;
import java.util.Iterator;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.codegen.util.CodeGenUtil;;

public class TopFigureGenerator
{
  protected static String nl;
  public static synchronized TopFigureGenerator create(String lineSeparator)
  {
    nl = lineSeparator;
    TopFigureGenerator result = new TopFigureGenerator();
    nl = null;
    return result;
  }

  protected final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = "\t\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ";
  protected final String TEXT_4 = " ";
  protected final String TEXT_5 = "() {" + NL + "\t\t";
  protected final String TEXT_6 = " result = new ";
  protected final String TEXT_7 = "();" + NL + "\t\t";
  protected final String TEXT_8 = NL + "\t\treturn result;" + NL + "\t}";
  protected final String TEXT_9 = NL;
  protected final String TEXT_10 = "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate final org.eclipse.draw2d.geometry.PointList myTemplate = new org.eclipse.draw2d.geometry.PointList();" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate org.eclipse.draw2d.geometry.Rectangle myTemplateBounds;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void addPoint(org.eclipse.draw2d.geometry.Point point){" + NL + "\t\tmyTemplate.addPoint(point);" + NL + "\t\tmyTemplateBounds = null;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillShape(org.eclipse.draw2d.Graphics graphics) {" + NL + "\t\torg.eclipse.draw2d.geometry.Rectangle bounds = getBounds();" + NL + "\t\tgraphics.pushState();" + NL + "\t\tgraphics.translate(bounds.x, bounds.y);" + NL + "\t\tgraphics.fillPolygon(scalePointList());" + NL + "\t\tgraphics.popState();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void outlineShape(org.eclipse.draw2d.Graphics graphics) {" + NL + "\t\torg.eclipse.draw2d.geometry.Rectangle bounds = getBounds();" + NL + "\t\tgraphics.pushState();" + NL + "\t\tgraphics.translate(bounds.x, bounds.y);" + NL + "\t\tgraphics.drawPolygon(scalePointList());" + NL + "\t\tgraphics.popState();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate org.eclipse.draw2d.geometry.Rectangle getTemplateBounds(){" + NL + "\t\tif (myTemplateBounds == null) {" + NL + "\t\t\tmyTemplateBounds = myTemplate.getBounds().getCopy().union(0, 0);" + NL + "\t\t\t//just safety -- we are going to use this as divider " + NL + "\t\t\tif (myTemplateBounds.width < 1){" + NL + "\t\t\t\tmyTemplateBounds.width = 1;" + NL + "\t\t\t}" + NL + "\t\t\tif (myTemplateBounds.height < 1){" + NL + "\t\t\t\tmyTemplateBounds.height = 1;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn myTemplateBounds;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate int[] scalePointList() {" + NL + "\t\torg.eclipse.draw2d.geometry.Rectangle pointsBounds = getTemplateBounds();" + NL + "\t\torg.eclipse.draw2d.geometry.Rectangle actualBounds = getBounds();" + NL + "" + NL + "\t\tfloat xScale = ((float) actualBounds.width) / pointsBounds.width;" + NL + "\t\tfloat yScale = ((float) actualBounds.height) / pointsBounds.height;" + NL + "" + NL + "\t\tif (xScale == 1 && yScale == 1) {" + NL + "\t\t\treturn myTemplate.toIntArray();" + NL + "\t\t}" + NL + "\t\tint[] scaled = (int[]) myTemplate.toIntArray().clone();" + NL + "\t\tfor (int i = 0; i < scaled.length; i += 2) {" + NL + "\t\t\tscaled[i] = (int) Math.floor(scaled[i] * xScale);" + NL + "\t\t\tscaled[i + 1] = (int) Math.floor(scaled[i + 1] * yScale);" + NL + "\t\t}" + NL + "\t\treturn scaled;" + NL + "\t}";
  protected final String TEXT_11 = NL + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_12 = "() {";
  protected final String TEXT_13 = NL + "\t\t";
  protected final String TEXT_14 = NL + "\t\t";
  protected final String TEXT_15 = NL + "\t\tcreateContents();" + NL + "\t}" + NL;
  protected final String TEXT_16 = NL;
  protected final String TEXT_17 = NL;
  protected final String TEXT_18 = NL;
  protected final String TEXT_19 = NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean myUseLocalCoordinates = ";
  protected final String TEXT_20 = ";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean useLocalCoordinates() {" + NL + "\t\treturn myUseLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setUseLocalCoordinates(boolean useLocalCoordinates) {" + NL + "\t\tmyUseLocalCoordinates = useLocalCoordinates;" + NL + "\t}" + NL + "\t";

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    
final GraphDefDispatcher.Args innerArgs = (GraphDefDispatcher.Args) ((Object[]) argument)[0];
final Figure figure = innerArgs.getFigure();
final GraphDefDispatcher dispatcher = innerArgs.getDispatcher();
final ImportAssistant importManager = dispatcher.getImportManager();

    stringBuffer.append(TEXT_1);
    stringBuffer.append(TEXT_2);
    
//input: [oeg].common.codegen.ImportAssistant importManager 
//input: [oeg].graphdef.codegen GraphDefDispatcher dispatcher
//input: [oeg].gmfgraph.Figure figure
 
{ //namespace -- use "bfm" (stands for BorderFactoryMethod) to avoid name clashes
	int bfmNextIndex = 1;
	String bfmLastFigureName = "";
	for (Iterator bfmAllCustomBorders = EcoreUtil.getAllContents(figure, false); bfmAllCustomBorders.hasNext();){
		EObject bfmNext = (EObject)bfmAllCustomBorders.next();
		if (GMFGraphPackage.eINSTANCE.getFigure().isSuperTypeOf(bfmNext.eClass())){
			bfmLastFigureName = (String)bfmNext.eGet(GMFGraphPackage.eINSTANCE.getIdentity_Name());
			if (bfmLastFigureName == null){
				bfmLastFigureName = "";
			}
		}
		// XXX [artem] why not do this with ((Figure) bfmNext).getBorder()? 
		if (bfmNext.eClass().getClassifierID() != GMFGraphPackage.CUSTOM_BORDER){
			continue;
		}
		
		String bfmNextImplClass = dispatcher.getFQNSwitch().get(bfmNext, importManager);	
		String bfmNextMethodName = "createBorder_" + CodeGenUtil.capName(bfmLastFigureName) + "_" + (bfmNextIndex++);
		

    stringBuffer.append(TEXT_3);
    stringBuffer.append(importManager.getImportedName("org.eclipse.draw2d.Border"));
    stringBuffer.append(TEXT_4);
    stringBuffer.append(bfmNextMethodName);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(bfmNextImplClass);
    stringBuffer.append(TEXT_6);
    stringBuffer.append(bfmNextImplClass);
    stringBuffer.append(TEXT_7);
    stringBuffer.append(dispatcher.dispatch("customAttributes", new Object[] {bfmNext, dispatcher, "result"} ));
    stringBuffer.append(TEXT_8);
    		
		dispatcher.getAuxiliaryDataStorage().registerData(bfmNext, bfmNextMethodName);
	}
} //end of namespace

    if (figure instanceof ScalablePolygon) {
    stringBuffer.append(TEXT_9);
    stringBuffer.append(TEXT_10);
    }
    stringBuffer.append(TEXT_11);
    stringBuffer.append(figure.getName());
    stringBuffer.append(TEXT_12);
    
GraphDefDispatcher.LayoutArgs dispatcherArgs = dispatcher.createLayoutArgs(figure, "this", "myGenLayoutManager", null);

    stringBuffer.append(TEXT_13);
    stringBuffer.append(dispatcher.dispatch("createLayout", dispatcherArgs));
    stringBuffer.append(TEXT_14);
    stringBuffer.append(dispatcher.dispatch(figure, dispatcherArgs));
    stringBuffer.append(TEXT_15);
    stringBuffer.append(TEXT_16);
    stringBuffer.append(dispatcher.dispatch("Children", dispatcherArgs));
    stringBuffer.append(TEXT_17);
    if (false == figure instanceof Polyline) {/*no much sense to define useLocalCoordinates for polyline and its descendants*/
    stringBuffer.append(TEXT_18);
    
// simple heuristic to detect need for local coordinates
boolean useLocalDefaultValue = false;
for (java.util.Iterator it = figure.getChildren().iterator(); it.hasNext(); ) {
	if (it.next() instanceof Polyline) {
		useLocalDefaultValue = true;
		break;
	}
}

    stringBuffer.append(TEXT_19);
    stringBuffer.append(useLocalDefaultValue);
    stringBuffer.append(TEXT_20);
    }
    return stringBuffer.toString();
  }
}
@


1.15
log
@do not modify original template when calculating bounds
@
text
@@


1.14
log
@[154687] mgolubev - Support scalable polygons
@
text
@d32 1
a32 1
  protected final String TEXT_10 = "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate final org.eclipse.draw2d.geometry.PointList myTemplate = new org.eclipse.draw2d.geometry.PointList();" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate org.eclipse.draw2d.geometry.Rectangle myTemplateBounds;" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic void addPoint(org.eclipse.draw2d.geometry.Point point){" + NL + "\t\tmyTemplate.addPoint(point);" + NL + "\t\tmyTemplateBounds = null;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void fillShape(org.eclipse.draw2d.Graphics graphics) {" + NL + "\t\torg.eclipse.draw2d.geometry.Rectangle bounds = getBounds();" + NL + "\t\tgraphics.pushState();" + NL + "\t\tgraphics.translate(bounds.x, bounds.y);" + NL + "\t\tgraphics.fillPolygon(scalePointList());" + NL + "\t\tgraphics.popState();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void outlineShape(org.eclipse.draw2d.Graphics graphics) {" + NL + "\t\torg.eclipse.draw2d.geometry.Rectangle bounds = getBounds();" + NL + "\t\tgraphics.pushState();" + NL + "\t\tgraphics.translate(bounds.x, bounds.y);" + NL + "\t\tgraphics.drawPolygon(scalePointList());" + NL + "\t\tgraphics.popState();" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate org.eclipse.draw2d.geometry.Rectangle getTemplateBounds(){" + NL + "\t\tif (myTemplateBounds == null){" + NL + "\t\t\tmyTemplateBounds = new org.eclipse.draw2d.geometry.Rectangle();" + NL + "\t\t\tmyTemplateBounds = myTemplate.getBounds().union(0, 0);" + NL + "\t\t\t//just safety -- we are going to use this as divider " + NL + "\t\t\tif (myTemplateBounds.width < 1){" + NL + "\t\t\t\tmyTemplateBounds.width = 1;" + NL + "\t\t\t}" + NL + "\t\t\tif (myTemplateBounds.height < 1){" + NL + "\t\t\t\tmyTemplateBounds.height = 1;" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\treturn myTemplateBounds;" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate int[] scalePointList() {" + NL + "\t\torg.eclipse.draw2d.geometry.Rectangle pointsBounds = getTemplateBounds();" + NL + "\t\torg.eclipse.draw2d.geometry.Rectangle actualBounds = getBounds();" + NL + "" + NL + "\t\tfloat xScale = ((float) actualBounds.width) / pointsBounds.width;" + NL + "\t\tfloat yScale = ((float) actualBounds.height) / pointsBounds.height;" + NL + "" + NL + "\t\tif (xScale == 1 && yScale == 1) {" + NL + "\t\t\treturn myTemplate.toIntArray();" + NL + "\t\t}" + NL + "\t\tint[] scaled = (int[]) myTemplate.toIntArray().clone();" + NL + "\t\tfor (int i = 0; i < scaled.length; i += 2) {" + NL + "\t\t\tscaled[i] = (int) Math.floor(scaled[i] * xScale);" + NL + "\t\t\tscaled[i + 1] = (int) Math.floor(scaled[i + 1] * yScale);" + NL + "\t\t}" + NL + "\t\treturn scaled;" + NL + "\t}";
@


1.13
log
@[154683] mgolubev - Handle custom borders.
@
text
@a3 1
import org.eclipse.gmf.gmfgraph.util.*;
d24 12
a35 12
  protected final String TEXT_2 = NL + NL + "/**" + NL + " * @@generated" + NL + " */" + NL + "public class ";
  protected final String TEXT_3 = " extends ";
  protected final String TEXT_4 = " {" + NL;
  protected final String TEXT_5 = NL;
  protected final String TEXT_6 = "\t\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ";
  protected final String TEXT_7 = " ";
  protected final String TEXT_8 = "() {" + NL + "\t\t";
  protected final String TEXT_9 = " result = new ";
  protected final String TEXT_10 = "();" + NL + "\t\t";
  protected final String TEXT_11 = NL + "\t\treturn result;" + NL + "\t}";
  protected final String TEXT_12 = NL + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_13 = "() {";
d37 2
a38 2
  protected final String TEXT_15 = NL + "\t\t";
  protected final String TEXT_16 = NL + "\t\tcreateContents();" + NL + "\t}" + NL;
d41 2
a42 16
  protected final String TEXT_19 = NL;
  protected final String TEXT_20 = NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean myUseLocalCoordinates = ";
  protected final String TEXT_21 = ";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean useLocalCoordinates() {" + NL + "\t\treturn myUseLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setUseLocalCoordinates(boolean useLocalCoordinates) {" + NL + "\t\tmyUseLocalCoordinates = useLocalCoordinates;" + NL + "\t}" + NL + "\t";
  protected final String TEXT_22 = NL;
  protected final String TEXT_23 = NL + "}" + NL + "\t";
  protected final String TEXT_24 = NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final ";
  protected final String TEXT_25 = " ";
  protected final String TEXT_26 = " = ";
  protected final String TEXT_27 = ";";
  protected final String TEXT_28 = NL + "\t";
  protected final String TEXT_29 = NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final ";
  protected final String TEXT_30 = " ";
  protected final String TEXT_31 = " = ";
  protected final String TEXT_32 = ";";
  protected final String TEXT_33 = NL + "}";
  protected final String TEXT_34 = NL;
d48 4
a51 5
Object[] args = (Object[]) argument;
Figure figure = (Figure) args[0];
final ImportAssistant importManager = (ImportAssistant) args[1];
final FigureQualifiedNameSwitch fqnSwitch = (FigureQualifiedNameSwitch) args[2];
final GraphDefDispatcher dispatcher = (GraphDefDispatcher) args[3];
a52 4
//[MG] FIXME: Why we need this? Is it in use somewhere?
final boolean isInnerClass = ((Boolean) args[4]).booleanValue();

    importManager.emitPackageStatement(stringBuffer);
a53 1
    importManager.markImportLocation(stringBuffer);
a54 5
    stringBuffer.append(importManager.getCompilationUnitName());
    stringBuffer.append(TEXT_3);
    stringBuffer.append(fqnSwitch.get(figure, importManager));
    stringBuffer.append(TEXT_4);
    stringBuffer.append(TEXT_5);
d80 1
a80 1
    stringBuffer.append(TEXT_6);
d82 1
a82 1
    stringBuffer.append(TEXT_7);
d84 1
a84 1
    stringBuffer.append(TEXT_8);
d86 1
a86 1
    stringBuffer.append(TEXT_9);
d88 1
a88 1
    stringBuffer.append(TEXT_10);
d90 1
a90 1
    stringBuffer.append(TEXT_11);
d96 6
a102 2
    stringBuffer.append(figure.getName());
    stringBuffer.append(TEXT_13);
d106 2
d109 1
a109 1
    stringBuffer.append(dispatcher.dispatch("createLayout", dispatcherArgs));
a110 1
    stringBuffer.append(dispatcher.dispatch(figure, dispatcherArgs));
d112 1
d114 1
a114 1
    stringBuffer.append(dispatcher.dispatch("Children", dispatcherArgs));
a115 2
    if (false == figure instanceof Polyline) {/*no much sense to define useLocalCoordinates for polyline and its descendants*/
    stringBuffer.append(TEXT_19);
d126 2
a128 40
    stringBuffer.append(useLocalDefaultValue);
    stringBuffer.append(TEXT_21);
    }
    stringBuffer.append(TEXT_22);
    
//input: [oeg].graphdef.codegen GraphDefDispatcher dispatcher
//input: boolean isInnerClass
if (isInnerClass){ /*put fields out of inner class body*/ 
    stringBuffer.append(TEXT_23);
    
//input: [oeg].graphdef.codegen GraphDefDispatcher dispatcher
for (Iterator allFields = dispatcher.getStaticFieldsManager().allFields(); allFields.hasNext();) {
	StaticFieldsManager.StaticField next = (StaticFieldsManager.StaticField)allFields.next(); 
    stringBuffer.append(TEXT_24);
    stringBuffer.append(next.getType());
    stringBuffer.append(TEXT_25);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_26);
    stringBuffer.append(next.getValue());
    stringBuffer.append(TEXT_27);
    
}

     } else { 
    stringBuffer.append(TEXT_28);
    
//input: [oeg].graphdef.codegen GraphDefDispatcher dispatcher
for (Iterator allFields = dispatcher.getStaticFieldsManager().allFields(); allFields.hasNext();) {
	StaticFieldsManager.StaticField next = (StaticFieldsManager.StaticField)allFields.next(); 
    stringBuffer.append(TEXT_29);
    stringBuffer.append(next.getType());
    stringBuffer.append(TEXT_30);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_31);
    stringBuffer.append(next.getValue());
    stringBuffer.append(TEXT_32);
    
}

    stringBuffer.append(TEXT_33);
a129 2
    importManager.emitSortedImports();
    stringBuffer.append(TEXT_34);
@


1.12
log
@[mgolubev] #148402 Do not create unlimited number of font/color resources.
@
text
@d7 4
a10 1
import java.util.Iterator;;
d27 31
a57 23
  protected final String TEXT_4 = " {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_5 = "() {";
  protected final String TEXT_6 = "\t" + NL + "\t\t";
  protected final String TEXT_7 = NL + "\t\t";
  protected final String TEXT_8 = NL + "\t\tcreateContents();" + NL + "\t}" + NL;
  protected final String TEXT_9 = NL;
  protected final String TEXT_10 = NL;
  protected final String TEXT_11 = NL;
  protected final String TEXT_12 = NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean myUseLocalCoordinates = ";
  protected final String TEXT_13 = ";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean useLocalCoordinates() {" + NL + "\t\treturn myUseLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setUseLocalCoordinates(boolean useLocalCoordinates) {" + NL + "\t\tmyUseLocalCoordinates = useLocalCoordinates;" + NL + "\t}" + NL + "\t";
  protected final String TEXT_14 = NL;
  protected final String TEXT_15 = NL + "}" + NL + "\t";
  protected final String TEXT_16 = NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final ";
  protected final String TEXT_17 = " ";
  protected final String TEXT_18 = " = ";
  protected final String TEXT_19 = ";";
  protected final String TEXT_20 = NL + "\t";
  protected final String TEXT_21 = NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic static final ";
  protected final String TEXT_22 = " ";
  protected final String TEXT_23 = " = ";
  protected final String TEXT_24 = ";";
  protected final String TEXT_25 = NL + "}";
  protected final String TEXT_26 = NL;
d68 2
a79 1
    stringBuffer.append(figure.getName());
d82 23
a104 1
GraphDefDispatcher.LayoutArgs dispatcherArgs = dispatcher.createLayoutArgs(figure, "this", "myGenLayoutManager", null);
d107 1
a107 1
    stringBuffer.append(dispatcher.dispatch("createLayout", dispatcherArgs));
d109 1
a109 1
    stringBuffer.append(dispatcher.dispatch(figure, dispatcherArgs));
d111 1
d113 21
d135 1
a135 1
    stringBuffer.append(TEXT_10);
d137 1
a137 1
    stringBuffer.append(TEXT_11);
d148 1
a148 1
    stringBuffer.append(TEXT_12);
d150 1
a150 1
    stringBuffer.append(TEXT_13);
d152 1
a152 1
    stringBuffer.append(TEXT_14);
d157 1
a157 1
    stringBuffer.append(TEXT_15);
d162 1
a162 1
    stringBuffer.append(TEXT_16);
d164 1
a164 1
    stringBuffer.append(TEXT_17);
d166 1
a166 1
    stringBuffer.append(TEXT_18);
d168 1
a168 1
    stringBuffer.append(TEXT_19);
d173 1
a173 1
    stringBuffer.append(TEXT_20);
d178 1
a178 1
    stringBuffer.append(TEXT_21);
d180 1
a180 1
    stringBuffer.append(TEXT_22);
d182 1
a182 1
    stringBuffer.append(TEXT_23);
d184 1
a184 1
    stringBuffer.append(TEXT_24);
d188 1
a188 1
    stringBuffer.append(TEXT_25);
d191 1
a191 1
    stringBuffer.append(TEXT_26);
@


1.11
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@d7 1
d34 13
a46 2
  protected final String TEXT_14 = NL + "}";
  protected final String TEXT_15 = NL;
d57 1
d97 37
d135 1
a135 1
    stringBuffer.append(TEXT_15);
@


1.10
log
@unused code removed
@
text
@d46 1
d50 1
a50 1
    stringBuffer.append(figure.getName());
@


1.9
log
@[mgolubev] #139139 Compilation error in the generated diagram code if DiagramLabel points to the deep Label
Add getters/setters for each figure that is being used by any diagram element
@
text
@a6 1
import java.util.*;
@


1.8
log
@#137840 uncompiliable code if CustomFigure contains Label  - gmfgen expects getters generated for figure's children; besides, it makes no much sense to keep both Figure.javajet and Shape.javajet, with sole difference in the way they process children
@
text
@d28 8
a35 30
  protected final String TEXT_8 = NL + "\t\t" + NL + "\t\t";
  protected final String TEXT_9 = " ";
  protected final String TEXT_10 = " = createFigure";
  protected final String TEXT_11 = "();" + NL + "\t\tsetFigure";
  protected final String TEXT_12 = "(";
  protected final String TEXT_13 = ");" + NL + "\t\tadd(";
  protected final String TEXT_14 = ");" + NL + "\t\t";
  protected final String TEXT_15 = "\t\t";
  protected final String TEXT_16 = NL + "\t}" + NL;
  protected final String TEXT_17 = NL + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ";
  protected final String TEXT_18 = " f";
  protected final String TEXT_19 = "; " + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
  protected final String TEXT_20 = " getFigure";
  protected final String TEXT_21 = "() {" + NL + "\t\treturn f";
  protected final String TEXT_22 = ";" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setFigure";
  protected final String TEXT_23 = "(";
  protected final String TEXT_24 = " figure) {" + NL + "\t\tf";
  protected final String TEXT_25 = " = figure;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate ";
  protected final String TEXT_26 = " createFigure";
  protected final String TEXT_27 = "() {";
  protected final String TEXT_28 = NL;
  protected final String TEXT_29 = NL;
  protected final String TEXT_30 = NL + "\t\treturn ";
  protected final String TEXT_31 = ";" + NL + "\t}" + NL;
  protected final String TEXT_32 = NL;
  protected final String TEXT_33 = NL;
  protected final String TEXT_34 = NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean myUseLocalCoordinates = ";
  protected final String TEXT_35 = ";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean useLocalCoordinates() {" + NL + "\t\treturn myUseLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setUseLocalCoordinates(boolean useLocalCoordinates) {" + NL + "\t\tmyUseLocalCoordinates = useLocalCoordinates;" + NL + "\t}" + NL + "\t";
  protected final String TEXT_36 = NL + "}";
  protected final String TEXT_37 = NL;
a62 4
    
for (Iterator it = figure.getChildren().iterator(); it.hasNext();) {
		Figure next = (Figure) it.next();
		final String childVarName = "child" + next.getName();
a63 1
    stringBuffer.append(fqnSwitch.get(next, importManager));
d65 1
a65 1
    stringBuffer.append(childVarName);
d67 1
a67 1
    stringBuffer.append(next.getName());
a68 48
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_12);
    stringBuffer.append(childVarName);
    stringBuffer.append(TEXT_13);
    stringBuffer.append(childVarName);
    stringBuffer.append(TEXT_14);
    stringBuffer.append(dispatcher.dispatch("createLayoutData", dispatcher.createLayoutArgs(next, childVarName, dispatcherArgs.getManagerVariableName(), "layoutData" + next.getName())));
    stringBuffer.append(TEXT_15);
    }
    stringBuffer.append(TEXT_16);
    
int fc = 0;
for (Iterator it = figure.getChildren().iterator(); it.hasNext(); fc++) {
	Figure next = (Figure) it.next();
	final String nextClassName = fqnSwitch.get(next, importManager);
    stringBuffer.append(TEXT_17);
    stringBuffer.append(nextClassName);
    stringBuffer.append(TEXT_18);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_19);
    stringBuffer.append(nextClassName);
    stringBuffer.append(TEXT_20);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_21);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_22);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_23);
    stringBuffer.append(nextClassName);
    stringBuffer.append(TEXT_24);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_25);
    stringBuffer.append(nextClassName);
    stringBuffer.append(TEXT_26);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_27);
     GraphDefDispatcher.LayoutArgs childFigureArgs = dispatcher.createLayoutArgs(next, next.getName(), "layoutManager" + next.getName(), null);
    stringBuffer.append(TEXT_28);
    stringBuffer.append(dispatcher.dispatch("instantiate", childFigureArgs));
    stringBuffer.append(TEXT_29);
    stringBuffer.append(dispatcher.dispatch("Children", new Object[] {next.getChildren(), dispatcher, childFigureArgs}));
    stringBuffer.append(TEXT_30);
    stringBuffer.append(next.getName());
    stringBuffer.append(TEXT_31);
    }
    stringBuffer.append(TEXT_32);
    if (false == figure instanceof Polyline) {/*no much sense to define useLocalCoordinates for polyline and its descendants*/
    stringBuffer.append(TEXT_33);
d79 1
a79 1
    stringBuffer.append(TEXT_34);
d81 1
a81 1
    stringBuffer.append(TEXT_35);
d83 1
a83 1
    stringBuffer.append(TEXT_36);
d85 1
a85 1
    stringBuffer.append(TEXT_37);
@


1.7
log
@#135015 some heuristic to provide valid default useLocalCoordinates.
@
text
@d6 2
a7 1
import org.eclipse.gmf.graphdef.codegen.GraphDefDispatcher;
d26 32
a57 9
  protected final String TEXT_6 = NL + "\t\t";
  protected final String TEXT_7 = "\t" + NL + "\t\t";
  protected final String TEXT_8 = NL + "\t\t";
  protected final String TEXT_9 = NL + "\t}";
  protected final String TEXT_10 = NL;
  protected final String TEXT_11 = NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean myUseLocalCoordinates = ";
  protected final String TEXT_12 = ";" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean useLocalCoordinates() {" + NL + "\t\treturn myUseLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setUseLocalCoordinates(boolean useLocalCoordinates) {" + NL + "\t\tmyUseLocalCoordinates = useLocalCoordinates;" + NL + "\t}" + NL + "\t";
  protected final String TEXT_13 = NL + "}";
  protected final String TEXT_14 = NL;
d79 1
a79 1
GraphDefDispatcher.LayoutArgs dispatcherArgs = dispatcher.createLayoutArgs(figure, "this", "genLayoutManager", null);
d85 4
d90 1
a90 1
    stringBuffer.append(dispatcher.dispatch("Children", new Object[] {figure.getChildren(), dispatcher, dispatcherArgs}));
d92 50
d143 1
a143 1
    stringBuffer.append(TEXT_10);
d154 1
a154 1
    stringBuffer.append(TEXT_11);
d156 1
a156 1
    stringBuffer.append(TEXT_12);
d158 1
a158 1
    stringBuffer.append(TEXT_13);
d160 1
a160 1
    stringBuffer.append(TEXT_14);
@


1.6
log
@Switching to eclipse M6.
@
text
@d23 1
a23 1
  protected final String TEXT_4 = " {" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprivate boolean myUseLocalCoordinates;" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
d28 1
a28 1
  protected final String TEXT_9 = NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean useLocalCoordinates() {" + NL + "\t\treturn myUseLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setUseLocalCoordinates(boolean useLocalCoordinates) {" + NL + "\t\tmyUseLocalCoordinates = useLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "}";
d30 4
d64 17
d82 1
a82 1
    stringBuffer.append(TEXT_10);
@


1.5
log
@[mgolubev] #134097 Invalid code is generated for the node figure with XYLayout
@
text
@d33 1
a33 1
    StringBuffer stringBuffer = new StringBuffer();
@


1.4
log
@explicit method names for fqn switch to better reflect it's intention
@
text
@d24 1
a24 1
  protected final String TEXT_5 = "() {" + NL + "\t\t";
d26 4
a29 2
  protected final String TEXT_7 = NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected boolean useLocalCoordinates() {" + NL + "\t\treturn myUseLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tprotected void setUseLocalCoordinates(boolean useLocalCoordinates) {" + NL + "\t\tmyUseLocalCoordinates = useLocalCoordinates;" + NL + "\t}" + NL + "" + NL + "}";
  protected final String TEXT_8 = NL;
d50 3
a52 1
    stringBuffer.append(dispatcher.dispatch(figure, dispatcher.create(figure, "this")));
d54 1
a54 1
    stringBuffer.append(dispatcher.dispatch("Children", new Object[] {figure.getChildren(), dispatcher, "this"}));
d56 4
d61 1
a61 1
    stringBuffer.append(TEXT_8);
@


1.3
log
@Adding "setUseLocalCoordinates" method.
Useful for inner shape-figures located outside of compartment.
@
text
@d36 1
a36 1
final GMFGraphSwitch fqnSwitch = (GMFGraphSwitch) args[2];
d44 1
a44 1
    stringBuffer.append(importManager.getImportedName((String) fqnSwitch.doSwitch(figure)));
@


1.2
log
@refactor - moved EmitterFactory/Dispatcher infrastructure to gmf.common to enable its use in oeg.codegen
@
text
@d23 1
a23 1
  protected final String TEXT_4 = " {" + NL + "\t/**" + NL + "\t * @@generated" + NL + "\t */" + NL + "\tpublic ";
d26 1
a26 1
  protected final String TEXT_7 = NL + "\t}" + NL + "}";
@


1.1
log
@major refactoring of gmfgraph codegen utilizing dispatcher infrastructure
@
text
@d6 1
a6 1
import org.eclipse.gmf.graphdef.codegen.Dispatcher;
d36 2
a37 2
final GMFGraphSwitch fqnSwitch = new FigureQualifiedNameSwitch();
final Dispatcher dispatcher = (Dispatcher) args[2];
d48 1
a48 1
    stringBuffer.append(dispatcher.dispatch(figure, dispatcher.create(figure, "this", importManager, fqnSwitch)));
d50 1
a50 1
    stringBuffer.append(dispatcher.dispatch("Children", new Object[] {figure.getChildren(), importManager, fqnSwitch, dispatcher, "this"}));
@

