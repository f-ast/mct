head	1.22;
access;
symbols
	v20080813-1520:1.22
	v20080807-1333:1.22
	v20080806-1520:1.22
	v20080731-1520:1.22
	v20080722-1827:1.22
	R2_1_maintenance:1.22.0.4
	Root_R2_1_maintenance:1.22
	R2_1_0:1.22
	v20080528-1052:1.22
	v20080417-1610:1.22
	v20080222-1200:1.22
	v20080215-1500:1.22
	v20080207-0207:1.22
	v20071214-1111:1.22
	v20071108-0000:1.22
	v20071003-0000:1.22
	v20070809-0000:1.22
	R2_0_maintenance:1.22.0.2
	R2_0:1.22
	R4_20:1.22
	v20070621-0000:1.22
	RC3_20:1.22
	v20070608-1300:1.22
	v20070605-1400:1.22
	v20070601-1400:1.21
	v20070518-1300:1.20
	v20070330-1300:1.19
	v20060316-0600:1.19
	v20070307-0700:1.19
	v20070228-2000:1.18
	v20070208-1800:1.16
	M4_20:1.15
	v20061214-0000:1.15
	M3_20:1.15
	v20061117-0800:1.15
	v20061027-1200:1.11
	v20061013-1330:1.12
	v20060925-1700:1.11
	v20060919-0800:1.11
	M1_20:1.12
	v20060904-1500:1.12
	v20060713-1700:1.11
	R1_0_maintenance:1.11.0.2
	R1_0:1.11
	v20060627-1200:1.11
	v20060626-1420:1.11
	v20060616-1200:1.10
	v20060531-1730:1.10
	v20060530-1930:1.10
	v20060526-1200:1.10
	v20060519-1300:1.8
	v20060519-0800:1.7
	I20060505-1400:1.6
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.4
	I20060331-1000:1.4
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.3
	M5_10:1.1
	S20060303-1600:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.22
date	2007.06.04.11.31.32;	author atikhomirov;	state Exp;
branches;
next	1.21;
commitid	1c654663f8134567;

1.21
date	2007.05.28.13.33.47;	author atikhomirov;	state Exp;
branches;
next	1.20;
commitid	3e69465ada3a4567;

1.20
date	2007.05.17.22.14.20;	author atikhomirov;	state Exp;
branches;
next	1.19;
commitid	640b464cd3bb4567;

1.19
date	2007.03.02.16.51.13;	author atikhomirov;	state Exp;
branches;
next	1.18;
commitid	160d45e856004567;

1.18
date	2007.02.27.15.16.34;	author atikhomirov;	state Exp;
branches;
next	1.17;
commitid	222145e44b514567;

1.17
date	2007.02.27.14.39.00;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	6e0345e442834567;

1.16
date	2007.02.01.13.39.01;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	26c345c1ed754567;

1.15
date	2006.11.02.21.58.37;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.02.17.38.23;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.31.13.26.06;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.09.01.16.03.19;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.26.16.49.28;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.24.14.57.46;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.23.21.09.44;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.19.14.30.19;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.18.19.12.40;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.01.17.26.39;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.11.19.16.42;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.13.17.53.19;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.08.14.22.44;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.07.20.07.34;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.02.13.16.15;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.22
log
@pass actual runtime token
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Michael Golubev (Borland) - initial API and implementation
 */
package org.eclipse.gmf.graphdef.codegen;

import java.net.URL;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.core.runtime.Path;
import org.eclipse.emf.codegen.merge.java.JControlModel;
import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.gmf.common.UnexpectedBehaviourException;
import org.eclipse.gmf.gmfgraph.FigureDescriptor;
import org.eclipse.gmf.gmfgraph.util.FigureQualifiedNameSwitch;
import org.eclipse.gmf.internal.common.codegen.DefaultTextMerger;
import org.eclipse.gmf.internal.common.codegen.GeneratorBase;
import org.eclipse.gmf.internal.common.codegen.ImportUtil;
import org.eclipse.gmf.internal.common.codegen.TextEmitter;
import org.eclipse.gmf.internal.common.codegen.TextMerger;

/**
 * FIXME move to internal package as it's not necessary to expose this class to public
 */
public class StandaloneGenerator extends GeneratorBase {
	protected final Config myArgs;
	private final TextEmitter myFigureGenerator;
	private final StandaloneEmitters myAuxiliaryGenerators;
	private boolean mySkipPluginStructire;
	protected Processor myProcessor;
	private final Map<String, FigureDescriptor> myCallbackFigures = new LinkedHashMap<String, FigureDescriptor>(); 
	
	public interface Config {
		public String getPluginID();
		public String getPluginFriendlyName();
		public String getPluginProviderName();
		public String getMainPackageName();

		public String getPluginActivatorClassName();
		public String getPluginActivatorPackageName();
		public MapModeCodeGenStrategy getMapMode();
		public String getRuntimeToken();
	}

	public static class ConfigImpl implements Config {
		private final String myPluginId;
		private final String myMainPackageName;
		private final String myPluginFriendlyName;
		private final String myPluginProviderName;
		
		private final String myPluginActivatorClassName;
		private final String myPluginActivatorPackageName;

		private final MapModeCodeGenStrategy myMapMode;
		private final String myRuntimeToken;
		
		public ConfigImpl(String pluginId, String mainPackageName){
			this(pluginId, mainPackageName, MapModeCodeGenStrategy.DYNAMIC, null);
		}

		public ConfigImpl(String pluginId, String mainPackageName, MapModeCodeGenStrategy mapMode, String runtimeToken) {
			this(pluginId, mainPackageName, pluginId, "", "PluginActivator", (mainPackageName == null ? "" : mainPackageName + ".")  + "activator", mapMode, runtimeToken);
		}

		public ConfigImpl(String pluginId, String mainPackageName, String pluginFriendlyName, String pluginProviderName, String pluginActivatorClassName, String pluginActivatorPackageName, MapModeCodeGenStrategy mapMode, String runtimeToken){
			myPluginId = pluginId;
			myMainPackageName = mainPackageName == null ? "" : mainPackageName;
			myPluginFriendlyName = pluginFriendlyName;
			myPluginProviderName = pluginProviderName;
			myPluginActivatorClassName = pluginActivatorClassName;
			myPluginActivatorPackageName = pluginActivatorPackageName;
			myMapMode = mapMode;
			myRuntimeToken = runtimeToken;
		}
		
		public String getMainPackageName() {
			return myMainPackageName;
		}
		
		public String getPluginFriendlyName() {
			return myPluginFriendlyName;
		}
		
		public String getPluginID() {
			return myPluginId;
		}
		
		public String getPluginProviderName() {
			return myPluginProviderName;
		}
		
		public String getPluginActivatorClassName() {
			return myPluginActivatorClassName;
		}
		
		public String getPluginActivatorPackageName() {
			return myPluginActivatorPackageName;
		}
		
		public MapModeCodeGenStrategy getMapMode() {
			return myMapMode;
		}

		public String getRuntimeToken() {
			return myRuntimeToken;
		}
	}

	public static abstract class Processor {
		public abstract void go(ProcessorCallback callback, Config config) throws InterruptedException ;

		public String[] getRequiredBundles(FigureQualifiedNameSwitch fqnSwitch) {
			return new String[0];
		}
	}

	public interface ProcessorCallback {
		public String visitFigure(FigureDescriptor f) throws InterruptedException;
	}


	public StandaloneGenerator(Processor p, Config config) {
		this(p, config, null);
	}

	public StandaloneGenerator(Processor p, Config config, URL[] dynamicTemplates) {
		assert p != null && config != null;
		myArgs = config;
		myProcessor = p;
		String pluginActivatorFQN = composePluginActivatorClassFQN(config);
		final MapModeCodeGenStrategy strategy;
		String accessor;
		if (config.getMapMode() == MapModeCodeGenStrategy.DYNAMIC) {
			strategy = MapModeCodeGenStrategy.DYNAMIC;
			accessor = pluginActivatorFQN + ".getDefault().";
		} else {
			strategy = config.getMapMode() == null ? MapModeCodeGenStrategy.STATIC : config.getMapMode();
			accessor = null;
		}
		
		myFigureGenerator = new FigureGenerator(config.getRuntimeToken(), getPackageName(), strategy, accessor, false, dynamicTemplates);
		myAuxiliaryGenerators = new StandaloneEmitters(strategy, dynamicTemplates);
	}

	/**
	 * Allows clients to skip generating of manifest.mf, pligin and build properties files. 
	 * "New-plugin-by-template" generator uses this feature because it delegates this generation to PDE defaults.
	 */
	public void setSkipPluginStructure(boolean skipManifest){
		mySkipPluginStructire = skipManifest;
	}
	
	protected void setupProgressMonitor() {
		//setupProgressMonitor("Generating GMFGraph plugin", 100);
	}
	
	@@Override
	protected TextMerger createMergeService() {
		// jcontrol model that is not initialized can't merge, hence java merging won't happen
		return new DefaultTextMerger(new JControlModel());
	}
	
	protected void customRun() throws InterruptedException, UnexpectedBehaviourException {
		initializeEditorProject(myArgs.getPluginID(), null /*support only workspace project with figures*/);
		
		if (!mySkipPluginStructire){
			generatePluginStructure();
		}
		try {
			generateTopLevelFigures();
			generatePluginActivator();
		} catch (IllegalStateException e){
			throw new UnexpectedBehaviourException(e);
		}
	}
	
	protected void generatePluginActivator() throws UnexpectedBehaviourException, InterruptedException{
		Object[] args = new Object[] {myArgs, new ImportUtil(myArgs.getPluginActivatorPackageName(), myArgs.getPluginActivatorClassName()), new ArrayList<String>(myCallbackFigures.keySet())};
		doGenerateJavaClass(myAuxiliaryGenerators.getPluginActivatorEmitter(), myArgs.getPluginActivatorPackageName(), myArgs.getPluginActivatorClassName(), args);		
	}
	
	protected void generatePluginStructure() throws UnexpectedBehaviourException, InterruptedException {
		doGenerateFile(myAuxiliaryGenerators.getBuildPropertiesEmitter(), new Path("build.properties"), myArgs);
		doGenerateFile(myAuxiliaryGenerators.getManifestMFEmitter(), new Path("META-INF/MANIFEST.MF"), myArgs, myProcessor.getRequiredBundles(null));
		doGenerateFile(myAuxiliaryGenerators.getPluginPropertiesEmitter(), new Path("plugin.properties"), myArgs);
	}

	private void generateTopLevelFigures() throws InterruptedException {
		myCallbackFigures.clear(); // just in case
		myProcessor.go(new ProcessorCallback() {
			public String visitFigure(FigureDescriptor f) throws InterruptedException {
				return StandaloneGenerator.this.visitFigure(f);
			}
		}, myArgs);
	}
	
	private String visitFigure(FigureDescriptor figureDescriptor) throws InterruptedException {
		// XXX either use compilationUnitName from Util.ext or pass cu name as template argument
		if (figureDescriptor.getName() == null) {
			throw new IllegalArgumentException("FigureDescriptor needs a name");
		}
		final String compilationUnitName = CodeGenUtil.validJavaIdentifier(CodeGenUtil.capName(figureDescriptor.getName()));  
		doGenerateJavaClass(myFigureGenerator, getPackageName(), compilationUnitName, figureDescriptor);
		final String qualifiedName = composeFQN(getPackageName(), compilationUnitName);
		myCallbackFigures.put(qualifiedName, figureDescriptor);
		return qualifiedName;
	}

	private String getPackageName(){
		return myArgs.getMainPackageName();
	}
	
	private static String composePluginActivatorClassFQN(Config config) {
		String packageName = config.getPluginActivatorPackageName();
		String className = config.getPluginActivatorClassName();
		return composeFQN(packageName, className);
	}

	private static String composeFQN(String packageName, String className){
		return packageName == null || "".equals(packageName) ? className : packageName + "." + className; 
	}
}
@


1.21
log
@FigureDescriptor with explicit means to access children introduced into gmfgraph
@
text
@d71 1
a71 1
			this(pluginId, mainPackageName, pluginId, "", "PluginActivator", (mainPackageName == null ? "" : mainPackageName + ".")  + "activator", mapMode, null);
@


1.20
log
@moving towards not using fqnswitch and java to tell draw2d figure names; let toolsmith to control what draw2d classes are being used; fqnSwitch argument replaced with simple token indicator
@
text
@d23 1
a23 2
import org.eclipse.gmf.common.codegen.ImportAssistant;
import org.eclipse.gmf.gmfgraph.Figure;
d40 1
a40 1
	private final Map<String, Figure> myCallbackFigures = new LinkedHashMap<String, Figure>(); 
d127 1
a127 1
		public String visitFigure(Figure f) throws InterruptedException;
d150 1
a150 1
		myFigureGenerator = new FigureGenerator(config.getRuntimeToken(), strategy, accessor, false, dynamicTemplates);
d200 1
a200 1
			public String visitFigure(Figure f) throws InterruptedException {
d206 9
a214 6
	private String visitFigure(Figure figure) throws InterruptedException {
		final ImportAssistant importAssistant = new ImportUtil(getPackageName(), CodeGenUtil.validJavaIdentifier(figure.getName()));
		Object[] args = new Object[] { figure, importAssistant };
		doGenerateJavaClass(myFigureGenerator, getPackageName(), importAssistant.getCompilationUnitName(), args);
		final String qualifiedName = composeFQN(getPackageName(), importAssistant.getCompilationUnitName());
		myCallbackFigures.put(qualifiedName, figure);
@


1.19
log
@pass list of generated figures qualified names in case activator needs to reference them
@
text
@a39 1
	protected final FigureQualifiedNameSwitch myFigureNameSwitch;
d51 2
a52 2

		public boolean needsMapMode(); // FIXME remove or (?) return MapModeCodeGenStrategy
d64 2
a65 1
		private final boolean myNeedsMapMode;
d68 1
a68 1
			this(pluginId, mainPackageName, true);
d71 2
a72 2
		public ConfigImpl(String pluginId, String mainPackageName, boolean useMapMode) {
			this(pluginId, mainPackageName, pluginId, "", "PluginActivator", (mainPackageName == null ? "" : mainPackageName + ".")  + "activator", useMapMode);
d75 1
a75 1
		public ConfigImpl(String pluginId, String mainPackageName, String pluginFriendlyName, String pluginProviderName, String pluginActivatorClassName, String pluginActivatorPackageName, boolean needsMapMode){
d82 2
a83 1
			myNeedsMapMode = needsMapMode;
d110 6
a115 2
		public boolean needsMapMode() {
			return myNeedsMapMode;
d132 2
a133 2
	public StandaloneGenerator(Processor p, Config config, FigureQualifiedNameSwitch fqnSwitch) {
		this(p, config, fqnSwitch, null);
d136 2
a137 2
	public StandaloneGenerator(Processor p, Config config, FigureQualifiedNameSwitch fqnSwitch, URL[] dynamicTemplates) {
		assert p != null && config != null && fqnSwitch != null;
a139 1
		myFigureNameSwitch = fqnSwitch;
d141 1
a141 1
		MapModeCodeGenStrategy strategy;
d143 1
a143 1
		if (config.needsMapMode()) {
d147 1
a147 1
			strategy = MapModeCodeGenStrategy.STATIC;
d151 1
a151 1
		myFigureGenerator = new FigureGenerator(fqnSwitch, strategy, accessor, false, dynamicTemplates);
d194 1
a194 1
		doGenerateFile(myAuxiliaryGenerators.getManifestMFEmitter(), new Path("META-INF/MANIFEST.MF"), myArgs, myProcessor.getRequiredBundles(myFigureNameSwitch));
@


1.18
log
@[170686] support dynamic templates for gmfgraph
@
text
@d15 3
d42 1
d176 1
a177 1
			generateTopLevelFigures();
d184 2
a185 2
		Object[] args = new Object[] {myArgs, new ImportUtil(myArgs.getPluginActivatorPackageName(), myArgs.getPluginActivatorClassName())};
		doGenerateJavaClass(myAuxiliaryGenerators.getPluginActivatorEmitter(), myArgs.getPluginActivatorPackageName(), myArgs.getPluginActivatorClassName(), new Object[] {args});		
d195 1
d207 3
a209 1
		return composeFQN(getPackageName(), importAssistant.getCompilationUnitName());
@


1.17
log
@clean hack with delegating import assistant
@
text
@d14 2
d29 3
d124 4
d143 2
a144 2
		myFigureGenerator = new FigureGenerator(fqnSwitch, strategy, accessor, false);
		myAuxiliaryGenerators = new StandaloneEmitters(strategy);
@


1.16
log
@use common XpandTextEmitter
@
text
@a21 1
import org.eclipse.gmf.internal.common.codegen.DelegateImportManager;
a29 1
	private DelegateImportManager myMapModeImportHack;
a126 1
			myMapModeImportHack = new DelegateImportManager();
a191 3
		if (myMapModeImportHack != null) {
			myMapModeImportHack.setDelegate(importAssistant);
		}
@


1.15
log
@JET templates for gmfgraph model replaced with Xpand counterparts.
MapMode handling simplified
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
a177 1
	// FIXME do not wrap array of arguments into another array (new Object[] { new Object[] {)
d179 3
a181 3
		doGenerateFile(myAuxiliaryGenerators.getBuildPropertiesEmitter(), new Path("build.properties"), new Object[] { myArgs });
		doGenerateFile(myAuxiliaryGenerators.getManifestMFEmitter(), new Path("META-INF/MANIFEST.MF"), new Object[] { new Object[] { myArgs, myProcessor.getRequiredBundles(myFigureNameSwitch) } });
		doGenerateFile(myAuxiliaryGenerators.getPluginPropertiesEmitter(), new Path("plugin.properties"), new Object[] { myArgs });
@


1.14
log
@moving towards jet-to-xpand switch
@
text
@d46 1
a46 1
		public boolean needsMapMode(); // FIXME remove
d127 1
d131 1
d133 2
a134 1
			strategy = MapModeCodeGenStrategy.StaticIdentity;
d137 2
a138 6
		myFigureGenerator = createFigureGenerator(fqnSwitch, strategy);
		myAuxiliaryGenerators = new StandaloneEmitters();
	}

	protected TextEmitter createFigureGenerator(FigureQualifiedNameSwitch fqnSwitch, MapModeCodeGenStrategy strategy) {
		return new FigureGenerator(fqnSwitch, strategy, false);
d178 1
@


1.13
log
@let subclasses override figure generator
@
text
@d29 1
a29 1
	private final Config myArgs;
d34 2
a35 2
	private final FigureQualifiedNameSwitch myFigureNameSwitch;
	private Processor myProcessor;
d46 1
a46 1
		public boolean needsMapMode();
d129 1
a129 1
			strategy = new MapModeCodeGenStrategy.RuntimeMapModeFromPluginClass(myMapModeImportHack, pluginActivatorFQN);
d131 1
a131 1
			strategy = new MapModeCodeGenStrategy.StaticIdentityMapMode();
d174 1
a174 1
	private void generatePluginActivator() throws UnexpectedBehaviourException, InterruptedException{
d179 1
a179 1
	private void generatePluginStructure() throws UnexpectedBehaviourException, InterruptedException {
@


1.12
log
@refactoring: abstract use of JMerge for merging away from generator services (GeneratorBase)
@
text
@d25 1
d30 1
a30 1
	private final FigureGenerator myFigureGenerator;
d134 1
a134 1
		myFigureGenerator = new FigureGenerator(fqnSwitch, strategy, false);
d137 5
a141 1
	
@


1.11
log
@[mgolubev] #148402 Do not create unlimited number of font/color resources.
@
text
@a13 2
import java.net.URL;

d15 1
d21 1
d25 1
d149 4
a152 2
	protected URL getJMergeControlFile() {
		return null;
@


1.10
log
@get rid of bogus config passing into ConverterOutcome
@
text
@d132 1
a132 1
		myFigureGenerator = new FigureGenerator(fqnSwitch, strategy);
@


1.9
log
@#140887 Remove Child interface from GMFGraph.
Although the need to reference child figures persist, thus FigureHandle was introduced, to allow diagramElements to reference either *generateable* figures (Figure subclasses) or *just-use* figures (like CustomFigure and FigureAccessor).
Refactoring performed with #131365 "Mirror GMFGraph model when generating standalone figure plugin" in mind
@
text
@d106 1
a106 1
		public abstract void go(ProcessorCallback callback) throws InterruptedException ;
d182 1
a182 1
		});
@


1.8
log
@#125964 match location of generated project with other EMF projects
@
text
@a14 7
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
a20 1
import org.eclipse.gmf.gmfgraph.FigureGallery;
a27 1
	private final FigureGallery[] myInput;
d33 1
a33 7
	private final GenerationInfoImpl myGenerationInfo;
	
	public interface GenerationInfo {
		public Config getConfig(); 
		public Enumeration/*<Figure>*/ getProcessedFigures();
		public String getGeneratedClassFQN(Figure figure);
	}
d105 6
a110 2
	public StandaloneGenerator(FigureGallery input, Config config, FigureQualifiedNameSwitch fqnSwitch) {
		this(new FigureGallery[] {input}, config, fqnSwitch);
d113 7
a119 2
	public StandaloneGenerator(FigureGallery[] input, Config config, FigureQualifiedNameSwitch fqnSwitch) {
		assert input != null && config != null && fqnSwitch != null && !Arrays.asList(input).contains(null);
d121 1
a121 1
		myInput = input;
a133 5
		myGenerationInfo = new GenerationInfoImpl(myArgs);
	}
	
	public GenerationInfo getGenerationInfo() {
		return myGenerationInfo;
d173 1
a173 1
		doGenerateFile(myAuxiliaryGenerators.getManifestMFEmitter(), new Path("META-INF/MANIFEST.MF"), new Object[] { new Object[] { myArgs, getRequiredBundles() } });
a176 12
	private String[] getRequiredBundles() {
		HashSet rv = new HashSet();
		for (int i = 0; i < myInput.length; i++) {
			if (myInput[i].getImplementationBundle() != null && myInput[i].getImplementationBundle().trim().length() > 0) {
				rv.add(myInput[i].getImplementationBundle());
				}
			String[] additional = myFigureNameSwitch.getDependencies(myInput[i]);
			rv.addAll(Arrays.asList(additional));
		}
		return (String[]) rv.toArray(new String[rv.size()]);
	}

d178 3
a180 4
		for (int i = 0; i < myInput.length; i++) {
			for (Iterator it = myInput[i].getFigures().iterator(); it.hasNext();){
				Figure next = (Figure) it.next();
				visitFigure(next);
d182 1
a182 1
		}
d185 1
a185 1
	private void visitFigure(Figure figure) throws InterruptedException {
d192 1
a192 1
		myGenerationInfo.registerFQN(figure, composeFQN(getPackageName(), importAssistant.getCompilationUnitName()));
a207 27
	
	private static class GenerationInfoImpl implements GenerationInfo {
		private final Map myFigure2FQN = new IdentityHashMap();
		private final Config myConfig;
		
		public GenerationInfoImpl(Config config){
			myConfig = config;
		}
		
		public Config getConfig() {
			return myConfig;
		}
		
		public void registerFQN(Figure figure, String fqn){
			myFigure2FQN.put(figure, fqn);
		}
		
		public String getGeneratedClassFQN(Figure figure) {
			return (String)myFigure2FQN.get(figure);
		}
		
		public Enumeration getProcessedFigures() {
			return Collections.enumeration(myFigure2FQN.keySet());
		}
		
	}
	
@


1.7
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@a20 1
import java.util.List;
a162 4
	protected List createReferencedProjectsList() {
		return Collections.EMPTY_LIST;
	}
	
d164 1
a164 1
		initializeEditorProject(myArgs.getPluginID(), createReferencedProjectsList());
@


1.6
log
@[bblajer] ##139022 Provide option to choose mapMode for figures
@
text
@a23 1
import org.eclipse.core.runtime.IProgressMonitor;
d25 1
a25 1
import org.eclipse.emf.codegen.jet.JETException;
a26 1
import org.eclipse.gmf.common.codegen.GeneratorBase;
a27 1
import org.eclipse.gmf.common.codegen.ImportUtil;
d31 3
d38 2
a39 1
	private final Emitter myFigureGenerator;
d79 1
a79 1
			this(pluginId, mainPackageName, pluginId, "", "PluginActivator", mainPackageName + ".activator", useMapMode);
d84 1
a84 1
			myMainPackageName = mainPackageName;
a129 1
		ImportAssistant importAssistant = new ImportUtil(getPackageName());
d133 2
a134 1
			strategy = new MapModeCodeGenStrategy.RuntimeMapModeFromPluginClass(importAssistant, pluginActivatorFQN);
d139 1
a139 3
		myFigureGenerator = new FigureGeneratorAdapter( //
				new FigureGenerator(getPackageName(), importAssistant, fqnSwitch, strategy)
		);
d183 2
a184 1
		doGenerateJavaClass(myAuxiliaryGenerators.getPluginActivatorEmitter(), myArgs.getPluginActivatorPackageName(), myArgs.getPluginActivatorClassName(), myArgs);		
d188 3
a190 3
		doGenerateFile(myAuxiliaryGenerators.getBuildPropertiesEmitter(), new Path("build.properties"), myArgs);
		doGenerateFile(myAuxiliaryGenerators.getManifestMFEmitter(), new Path("META-INF/MANIFEST.MF"), new Object[] {myArgs, getRequiredBundles()});
		doGenerateFile(myAuxiliaryGenerators.getPluginPropertiesEmitter(), new Path("plugin.properties"), myArgs);
d215 7
a221 4
		String packageName = getPackageName();
		String className = figure.getName();
		doGenerateJavaClass(myFigureGenerator, packageName, className, figure);
		myGenerationInfo.registerFQN(figure, composeFQN(packageName, className));
a237 15
	private static class FigureGeneratorAdapter implements GeneratorBase.Emitter {
		private final FigureGenerator myDelegate;

		public FigureGeneratorAdapter(FigureGenerator delegate){
			myDelegate = delegate;
		}
		
		public String generate(IProgressMonitor monitor, Object param) throws JETException {
			if (false == param instanceof Figure){
				throw new IllegalStateException("Figure expected: " + param);
			}
			return myDelegate.go((Figure)param);
		}
	}
	
@


1.5
log
@refactor exception thrown during generation. There's nothing we could do about JETException, so why treat it differently from Unexpected
@
text
@d135 1
a135 1
			strategy = new MapModeCodeGenStrategy.StaticIdentityMapMode(importAssistant);
@


1.4
log
@explicit method names for fqn switch to better reflect it's intention
@
text
@d169 1
a169 1
	protected void customRun() throws InterruptedException, JETException, UnexpectedBehaviourException {
d183 1
a183 1
	private void generatePluginActivator() throws JETException, InterruptedException{
d187 1
a187 1
	private void generatePluginStructure() throws JETException, InterruptedException {
@


1.3
log
@[mgolubev] #128779 create new .gmfgraph as part of figure bundle generation process
@
text
@d199 1
a199 1
			String[] additional = (String[]) myFigureNameSwitch.doSwitch(myInput[i]);
@


1.2
log
@support multiple galleries as input
respect needsMap when creating strategy
@
text
@d17 1
d19 1
d22 1
d42 7
d142 5
a156 6
	private static String composePluginActivatorClassFQN(Config config) {
		String packageName = config.getPluginActivatorPackageName();
		String className = config.getPluginActivatorClassName();
		return packageName == null || "".equals(packageName) ? className : packageName + "." + className; 
	}

d215 4
a218 1
		doGenerateJavaClass(myFigureGenerator, getPackageName(), figure.getName(), figure);
d224 6
d231 4
d250 26
@


1.1
log
@[mgolubev] #128779 generate figures as standalone plugin
#129362 - respect plug-in dependencies imposed by figure fqn switch
@
text
@d34 1
a34 1
	private final FigureGallery myInput;
d64 5
a68 1
			this(pluginId, mainPackageName, pluginId, "", "PluginActivator", mainPackageName + ".activator", true);
d109 7
a115 3
	
	public StandaloneGenerator(FigureGallery input, Config config, FigureQualifiedNameSwitch fqnSwitch){
		assert input != null && config != null && fqnSwitch != null;
d121 6
a126 2
		MapModeCodeGenStrategy strategy = new MapModeCodeGenStrategy.RuntimeMapModeFromPluginClass( //
				importAssistant, pluginActivatorFQN);
d186 6
a191 2
		if (myInput.getImplementationBundle() != null && myInput.getImplementationBundle().trim().length() > 0) {
			rv.add(myInput.getImplementationBundle());
a192 2
		String[] additional = (String[]) myFigureNameSwitch.doSwitch(myInput);
		rv.addAll(Arrays.asList(additional));
d197 5
a201 3
		for (Iterator it = myInput.getFigures().iterator(); it.hasNext();){
			Figure next = (Figure) it.next();
			visitFigure(next);
@

