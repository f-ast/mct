head	1.30;
access;
symbols
	v20080813-1520:1.30
	v20080807-1333:1.30
	v20080806-1520:1.30
	v20080731-1520:1.30
	v20080722-1827:1.30
	R2_1_maintenance:1.30.0.4
	Root_R2_1_maintenance:1.30
	R2_1_0:1.30
	v20080528-1052:1.30
	v20080417-1610:1.30
	v20080222-1200:1.30
	v20080215-1500:1.30
	v20080207-0207:1.30
	v20071214-1111:1.30
	v20071108-0000:1.30
	v20071003-0000:1.30
	v20070809-0000:1.30
	R2_0_maintenance:1.30.0.2
	R2_0:1.30
	R4_20:1.30
	v20070621-0000:1.30
	RC3_20:1.30
	v20070608-1300:1.30
	v20070605-1400:1.30
	v20070601-1400:1.30
	v20070518-1300:1.29
	v20070330-1300:1.28
	v20060316-0600:1.28
	v20070307-0700:1.28
	v20070228-2000:1.28
	v20070208-1800:1.27
	M4_20:1.26
	v20061214-0000:1.26
	M3_20:1.26
	v20061117-0800:1.26
	v20061027-1200:1.21.2.1
	v20061013-1330:1.24
	v20060925-1700:1.21.2.1
	v20060919-0800:1.21.2.1
	M1_20:1.24
	v20060904-1500:1.24
	v20060713-1700:1.21
	R1_0_maintenance:1.21.0.2
	R1_0:1.21
	v20060627-1200:1.21
	v20060626-1420:1.21
	v20060616-1200:1.20
	v20060531-1730:1.20
	v20060530-1930:1.20
	v20060526-1200:1.20
	v20060519-1300:1.19
	v20060519-0800:1.19
	I20060505-1400:1.18
	I20060424-0500:1.17
	I20060424-0300:1.17
	M6_10:1.16
	I20060407-1200:1.16
	I20060331-1000:1.15
	I20060324-0300:1.14
	I20060317-1300:1.14
	I20060317-1200:1.14
	I20060316-1300:1.14
	I20060309-1300:1.14
	M5_10:1.14
	S20060303-1600:1.14
	I20060227-1730:1.12
	I20060216-1945:1.11
	I20060210-1715:1.7
	I20060209-1815:1.7
	I20060203-0830:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.1
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.30
date	2007.05.28.13.33.47;	author atikhomirov;	state Exp;
branches;
next	1.29;
commitid	3e69465ada3a4567;

1.29
date	2007.05.17.22.14.20;	author atikhomirov;	state Exp;
branches;
next	1.28;
commitid	640b464cd3bb4567;

1.28
date	2007.02.27.15.16.34;	author atikhomirov;	state Exp;
branches;
next	1.27;
commitid	222145e44b514567;

1.27
date	2007.02.01.13.39.01;	author atikhomirov;	state Exp;
branches;
next	1.26;
commitid	26c345c1ed754567;

1.26
date	2006.11.02.21.58.37;	author atikhomirov;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.02.17.38.23;	author atikhomirov;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.30.15.12.12;	author atikhomirov;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.24.15.38.54;	author atikhomirov;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.24.13.13.37;	author atikhomirov;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.26.16.49.28;	author atikhomirov;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2006.05.23.21.09.44;	author atikhomirov;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.18.19.12.40;	author atikhomirov;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.01.17.26.39;	author atikhomirov;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.21.17.47.10;	author atikhomirov;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.31.18.08.36;	author ashatalin;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.29.12.56.04;	author ashatalin;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.01.20.24.39;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.01.20.18.30;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.24.15.11.34;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.16.19.09.29;	author ashatalin;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.15.18.59.28;	author ashatalin;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.15.14.44.35;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.13.17.36.17;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.06.22.32.28;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.06.22.21.42;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.06.18.10.23;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.05.23.00.50;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.04.22.34.49;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.23.20.00.49;	author ashatalin;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.06.19.17.28;	author atikhomirov;	state Exp;
branches;
next	;

1.21.2.1
date	2006.09.13.23.07.17;	author rgronback;	state Exp;
branches;
next	;


desc
@@


1.30
log
@FigureDescriptor with explicit means to access children introduced into gmfgraph
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.graphdef.codegen;

import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.gmf.common.UnexpectedBehaviourException;
import org.eclipse.gmf.gmfgraph.Figure;
import org.eclipse.gmf.gmfgraph.FigureDescriptor;
import org.eclipse.gmf.internal.common.codegen.TextEmitter;
import org.eclipse.gmf.internal.graphdef.codegen.Activator;
import org.eclipse.gmf.internal.xpand.BufferOutput;
import org.eclipse.gmf.internal.xpand.ResourceManager;
import org.eclipse.gmf.internal.xpand.XpandFacade;
import org.eclipse.gmf.internal.xpand.expression.Variable;
import org.eclipse.gmf.internal.xpand.util.ContextFactory;

public class FigureGenerator implements TextEmitter {

	private static final String VAR_MM_ACCESS = "mapModeAccessor";
	private static final String VAR_OUTPUT_FIELDS = "outputStaticFields";
	private static final String VAR_RT_TOKEN = "runtimeToken";

	private static final String SLOT_FIELDS = "staticFields";

	private final XpandFacade xpandFacade;

	private final StringBuilder result;

	private final boolean myIsInnerClassCode;

	private StringBuilder additionalFields;

	private String packageStatement;


	/**
	 * XXX consider using enum for runtimeToken
	 * @@param runtimeToken either "full" or null to indicate full GMF runtime use, any other value is to be processed by custom templates 
	 * @@param asInnerClass
	 */
	public FigureGenerator(String runtimeToken, String packageStmt, boolean asInnerClass) {
		this(runtimeToken, packageStmt, MapModeCodeGenStrategy.DYNAMIC, "getMapMode().", asInnerClass);
	}

	public FigureGenerator(String runtimeToken, String packageStmt, MapModeCodeGenStrategy mapModeStrategy, String mapModeAccessor, boolean asInnerClass) {
		this(runtimeToken, packageStmt, mapModeStrategy, mapModeAccessor, asInnerClass, null);
	}

	public FigureGenerator(String runtimeToken, String packageStmt, MapModeCodeGenStrategy mapModeStrategy, String mapModeAccessor, boolean asInnerClass, URL[] dynamicTemplates) {
		myIsInnerClassCode = asInnerClass;
		this.packageStatement = packageStmt;
		if (mapModeStrategy == MapModeCodeGenStrategy.STATIC) {
			if (mapModeAccessor != null && mapModeAccessor.trim().length() > 0) {
				throw new IllegalArgumentException("Can't use map mode accessor with identity map mode");
			}
		}
		final ArrayList<Variable> globals = new ArrayList<Variable>();
		if (mapModeStrategy == MapModeCodeGenStrategy.DYNAMIC) {
			globals.add(new Variable(VAR_MM_ACCESS, mapModeAccessor == null ? "" : mapModeAccessor));
		}
		if (runtimeToken != null) {
			globals.add(new Variable(VAR_RT_TOKEN, runtimeToken));
		}
		additionalFields = new StringBuilder();
		globals.add(new Variable(VAR_OUTPUT_FIELDS, "") {
			public Object getValue() {
				return additionalFields.toString();
			}
		});
		result = new StringBuilder(200);
		Map<String, StringBuilder> slots = new HashMap<String, StringBuilder>();
		slots.put(SLOT_FIELDS, additionalFields);
		BufferOutput bufferOutput = new BufferOutput(result, slots);

		ResourceManager resourceManager = Activator.createResourceEngine(mapModeStrategy, dynamicTemplates);
		xpandFacade = new XpandFacade(ContextFactory.createXpandContext(resourceManager, bufferOutput, globals, getClass().getClassLoader()));
	}

	public String getPackageName() {
		return packageStatement;
	}

	public String fqnSwitch(Figure figure) {
		result.setLength(0);
		additionalFields.setLength(0);
		xpandFacade.evaluate("Runtime::fqn", figure, null);
		return result.toString();
	}
	
	/**
	 * @@param packageStmt can be null if asInnerClass was true
	 * @@param figure
	 */
	public String go(FigureDescriptor figure) {
		result.setLength(0);
		additionalFields.setLength(0);
		if (myIsInnerClassCode) {
			xpandFacade.evaluate("top::Descriptor::Inner", figure, null);
		} else {
			xpandFacade.evaluate("top::Descriptor::Top", figure, new Object[] { packageStatement });
		}
		return result.toString();
	}

	public String generate(IProgressMonitor monitor, Object[] arguments) throws InterruptedException, InvocationTargetException, UnexpectedBehaviourException {
		if (arguments == null || arguments.length != 1 || false == arguments[0] instanceof FigureDescriptor) {
			throw new UnexpectedBehaviourException("(FigureDescriptor) expected as arguments, not " + arguments);
		}
		return go((FigureDescriptor) arguments[0]);
	}
}
@


1.29
log
@moving towards not using fqnswitch and java to tell draw2d figure names; let toolsmith to control what draw2d classes are being used; fqnSwitch argument replaced with simple token indicator
@
text
@a21 1
import org.eclipse.gmf.common.codegen.ImportAssistant;
d23 1
a35 2
	private static final String VAR_OUTPUT_METHODS = "outputAdditionalMethods";
	private static final String VAR_PACKAGE_STMT = "packageStatement";
a38 1
	private static final String SLOT_METHODS = "additionalMethods";
a43 4
	private Variable packageStatement;

	private StringBuilder additionalMethods;

d48 2
d56 2
a57 2
	public FigureGenerator(String runtimeToken, boolean asInnerClass) {
		this(runtimeToken, MapModeCodeGenStrategy.DYNAMIC, "getMapMode().", asInnerClass);
d60 2
a61 2
	public FigureGenerator(String runtimeToken, MapModeCodeGenStrategy mapModeStrategy, String mapModeAccessor, boolean asInnerClass) {
		this(runtimeToken, mapModeStrategy, mapModeAccessor, asInnerClass, null);
d64 1
a64 1
	public FigureGenerator(String runtimeToken, MapModeCodeGenStrategy mapModeStrategy, String mapModeAccessor, boolean asInnerClass, URL[] dynamicTemplates) {
d66 1
a78 8
		packageStatement = new Variable(VAR_PACKAGE_STMT, "");
		globals.add(packageStatement);
		additionalMethods = new StringBuilder();
		globals.add(new Variable(VAR_OUTPUT_METHODS, "") {
			public Object getValue() {
				return additionalMethods.toString();
			}
		});
a86 1
		slots.put(SLOT_METHODS, additionalMethods);
d94 5
a98 1
	public String go(Figure figure, ImportAssistant importAssistant) {
a99 1
		additionalMethods.setLength(0);
d101 17
a117 6
		StringBuffer ss = new StringBuffer();
		importAssistant.emitPackageStatement(ss);
		packageStatement.setValue(ss.toString());
		xpandFacade.evaluate("top::Figure::FigureClass", figure, new Object[] {myIsInnerClassCode});
		final String resultString = result.toString();
		return resultString;
d121 2
a122 2
		if (arguments == null || arguments.length != 2 || false == arguments[0] instanceof Figure || false == arguments[1] instanceof ImportAssistant) {
			throw new UnexpectedBehaviourException("(Figure, ImportAssistant) expected as arguments, not " + arguments);
d124 1
a124 1
		return go((Figure) arguments[0], (ImportAssistant) arguments[1]);
@


1.28
log
@[170686] support dynamic templates for gmfgraph
@
text
@a23 1
import org.eclipse.gmf.gmfgraph.util.FigureQualifiedNameSwitch;
d33 10
d55 8
a62 2
	public FigureGenerator(FigureQualifiedNameSwitch fqnSwitch, boolean asInnerClass) {
		this(fqnSwitch, MapModeCodeGenStrategy.DYNAMIC, "getMapMode().", asInnerClass);
d65 2
a66 2
	public FigureGenerator(FigureQualifiedNameSwitch fqnSwitch, MapModeCodeGenStrategy mapModeStrategy, String mapModeAccessor, boolean asInnerClass) {
		this(fqnSwitch, mapModeStrategy, mapModeAccessor, asInnerClass, null);
d69 1
a69 1
	public FigureGenerator(FigureQualifiedNameSwitch fqnSwitch, MapModeCodeGenStrategy mapModeStrategy, String mapModeAccessor, boolean asInnerClass, URL[] dynamicTemplates) {
d78 4
a81 1
			globals.add(new Variable("mapModeAccessor", mapModeAccessor == null ? "" : mapModeAccessor));
d83 1
a83 2
		globals.add(new Variable(FigureQualifiedNameSwitch.class.getSimpleName(), fqnSwitch));
		packageStatement = new Variable("packageStatement", "");
d86 1
a86 1
		globals.add(new Variable("outputAdditionalMethods", "") {
d92 1
a92 1
		globals.add(new Variable("outputStaticFields", "") {
d99 2
a100 2
		slots.put("additionalMethods", additionalMethods);
		slots.put("staticFields", additionalFields);
@


1.27
log
@use common XpandTextEmitter
@
text
@d15 1
d51 4
d86 1
a86 1
		ResourceManager resourceManager = Activator.createResourceEngine(mapModeStrategy);
@


1.26
log
@JET templates for gmfgraph model replaced with Xpand counterparts.
MapMode handling simplified
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
d27 1
d30 1
d80 3
a82 1
		xpandFacade = Activator.createTemplateEngine(mapModeStrategy, bufferOutput, globals);
@


1.25
log
@moving towards jet-to-xpand switch
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
d15 3
a19 1
import org.eclipse.core.runtime.Platform;
a21 7
import org.eclipse.gmf.gmfgraph.BorderLayout;
import org.eclipse.gmf.gmfgraph.BorderLayoutData;
import org.eclipse.gmf.gmfgraph.CompoundBorder;
import org.eclipse.gmf.gmfgraph.CustomBorder;
import org.eclipse.gmf.gmfgraph.CustomFigure;
import org.eclipse.gmf.gmfgraph.CustomLayout;
import org.eclipse.gmf.gmfgraph.CustomLayoutData;
a22 13
import org.eclipse.gmf.gmfgraph.FlowLayout;
import org.eclipse.gmf.gmfgraph.GridLayout;
import org.eclipse.gmf.gmfgraph.GridLayoutData;
import org.eclipse.gmf.gmfgraph.Label;
import org.eclipse.gmf.gmfgraph.LineBorder;
import org.eclipse.gmf.gmfgraph.MarginBorder;
import org.eclipse.gmf.gmfgraph.PolygonDecoration;
import org.eclipse.gmf.gmfgraph.Polyline;
import org.eclipse.gmf.gmfgraph.PolylineConnection;
import org.eclipse.gmf.gmfgraph.PolylineDecoration;
import org.eclipse.gmf.gmfgraph.RoundedRectangle;
import org.eclipse.gmf.gmfgraph.Shape;
import org.eclipse.gmf.gmfgraph.XYLayoutData;
a23 36
import org.eclipse.gmf.graphdef.codegen.templates.CustomClassAttributesGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.CustomFigureAttrGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.FigureAttrGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.FigureChildrenGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.InitBorderLayoutDataGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.InitBorderLayoutGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.InitCustomLayoutDataGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.InitCustomLayoutGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.InitFlowLayoutGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.InitGridLayoutDataGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.InitGridLayoutGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.InitXYLayoutDataGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.LabelAttrGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.NewCompoundBorderExpressionGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.NewCustomBorderExpressionGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.NewFigureGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.NewLayoutDataGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.NewLayoutGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.NewLineBorderExpressionGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.NewMarginBorderExpressionGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.PolygonDecorationAttrGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.PolylineAttrGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.PolylineDecorationAttrGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.RoundedRectAttrGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.ShapeAttrGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.TopConnectionGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.TopFigureGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.TopGenerator;
import org.eclipse.gmf.internal.codegen.dispatch.CachingEmitterFactory;
import org.eclipse.gmf.internal.codegen.dispatch.EmitterFactory;
import org.eclipse.gmf.internal.codegen.dispatch.EmitterFactoryImpl;
import org.eclipse.gmf.internal.codegen.dispatch.HierarchyKeyMap;
import org.eclipse.gmf.internal.codegen.dispatch.KeyChain;
import org.eclipse.gmf.internal.codegen.dispatch.KeyMap;
import org.eclipse.gmf.internal.codegen.dispatch.StaticTemplateRegistry;
import org.eclipse.gmf.internal.codegen.dispatch.TemplateRegistry;
d25 4
a28 1
import org.osgi.framework.Bundle;
a29 4
/**
 * @@author artem
 *
 */
d31 7
a37 1
	private static final String ENTRY_POINT = "main";
a38 2
	private final GraphDefDispatcher myTopDispatcher;
	private final GraphDefDispatcher myInnerDispatcher;
d41 1
a41 3
	public FigureGenerator(FigureQualifiedNameSwitch figureNameSwitch, boolean asInnerClass) {
		this(figureNameSwitch, MapModeCodeGenStrategy.DYNAMIC, asInnerClass);
	}
d43 2
a44 17
	public FigureGenerator(FigureQualifiedNameSwitch figureNameSwitch, MapModeCodeGenStrategy mapModeStrategy, boolean placeStaticFieldsOutsideClassBody) {
		myIsInnerClassCode = placeStaticFieldsOutsideClassBody;
		final Bundle thisBundle = Platform.getBundle("org.eclipse.gmf.graphdef.codegen");
		final String[] variables = new String[] {
				"org.eclipse.gmf.graphdef",
				"org.eclipse.emf.ecore",
				"org.eclipse.emf.common",
				"org.eclipse.gmf.common",
				"org.eclipse.gmf.graphdef.codegen"
		};

		KeyMap keyMap = new ClassesOrStringsKeyMap();
		String[] templatePath = new String[] {thisBundle.getEntry("/templates/").toString()};
		EmitterFactory topFactory = new CachingEmitterFactory(new EmitterFactoryImpl(templatePath, fillTopLevel(), true, variables));
		myTopDispatcher = new GraphDefDispatcher(topFactory, keyMap, figureNameSwitch, mapModeStrategy);
		EmitterFactory innerFactory = new CachingEmitterFactory(new EmitterFactoryImpl(templatePath, fillAttrs(), true, variables));
		myInnerDispatcher = new GraphDefDispatcher(innerFactory, keyMap, figureNameSwitch, mapModeStrategy);
d47 44
a90 54
	private static TemplateRegistry fillTopLevel() {
		StaticTemplateRegistry tr = new StaticTemplateRegistry(FigureGenerator.class.getClassLoader());
		tr.put(ENTRY_POINT, "/top/Top.javajet", TopGenerator.class);
		tr.put(PolylineConnection.class, "/top/PolylineConnection.javajet", TopConnectionGenerator.class);
		tr.put(Figure.class, "/top/Figure.javajet", TopFigureGenerator.class);
		return tr;
	}
	
	// XXX NOTE, the fact we use "instantiate" and "Children" strings
	// helps us to postpone resolution of the next problem (one we make these twwo overridable):
	// it's not possible to tell from single dispatcher.dispatch(Figure, args) what's the intention - 
	// whether to instantiate, look for children or initialize attributes
	// Perhaps, we should have distinct methods in the Dispatcher, or add "hint" as another argument
	private static TemplateRegistry fillAttrs() {
		StaticTemplateRegistry tr = new StaticTemplateRegistry(FigureGenerator.class.getClassLoader());
		tr.put(Figure.class, "/attr/Figure.javajet", FigureAttrGenerator.class);
		tr.put(Shape.class, "/attr/Shape.javajet", ShapeAttrGenerator.class);
		tr.put(Label.class, "/attr/Label.javajet", LabelAttrGenerator.class);
		tr.put(Polyline.class, "/attr/Polyline.javajet", PolylineAttrGenerator.class);
		tr.put(RoundedRectangle.class, "/attr/RoundedRectangle.javajet", RoundedRectAttrGenerator.class);
		tr.put(PolygonDecoration.class, "/attr/PolygonDecoration.javajet", PolygonDecorationAttrGenerator.class);
		tr.put(PolylineDecoration.class, "/attr/PolylineDecoration.javajet", PolylineDecorationAttrGenerator.class);
		tr.put(CustomFigure.class, "/attr/CustomFigure.javajet", CustomFigureAttrGenerator.class);
		// instantiation templates - only single one now. FIXME - make it overridable
		tr.put("instantiate", "/new/Figure.javajet", NewFigureGenerator.class);
		// children templates - only single one now. FIXME - make it overridable
		tr.put("Children", "/children/Figure.javajet", FigureChildrenGenerator.class);
		// FIXME same template is registered twice
		tr.put("Shape", "/attr/Shape.javajet", ShapeAttrGenerator.class);
		tr.put("Figure", "/attr/Figure.javajet", FigureAttrGenerator.class);
		tr.put("PolylineDecoration", "/attr/PolylineDecoration.javajet", PolylineDecorationAttrGenerator.class);

		// Custom attributes support
		tr.put("customAttributes", "/attr/CustomConfigurableClass.javajet", CustomClassAttributesGenerator.class);
		// Layout related dispatching chain.  
		tr.put("createLayout", "/new/Layout.javajet", NewLayoutGenerator.class);
		tr.put(GridLayout.class, "/layout/GridLayout.javajet", InitGridLayoutGenerator.class);
		tr.put(BorderLayout.class, "/layout/BorderLayout.javajet", InitBorderLayoutGenerator.class);
		tr.put(CustomLayout.class, "/layout/CustomLayout.javajet", InitCustomLayoutGenerator.class);
		tr.put(FlowLayout.class, "/layout/FlowLayout.javajet", InitFlowLayoutGenerator.class);
		
		tr.put("createLayoutData", "/new/LayoutData.javajet", NewLayoutDataGenerator.class);
		tr.put(GridLayoutData.class, "/layoutData/GridLayoutData.javajet", InitGridLayoutDataGenerator.class);
		tr.put(BorderLayoutData.class, "/layoutData/BorderLayoutData.javajet", InitBorderLayoutDataGenerator.class);
		tr.put(CustomLayoutData.class, "/layoutData/CustomLayoutData.javajet", InitCustomLayoutDataGenerator.class);
		tr.put(XYLayoutData.class, "/layoutData/XYLayoutData.javajet", InitXYLayoutDataGenerator.class);
		
		//Borders 
		tr.put(LineBorder.class, "/new/LineBorder.javajet", NewLineBorderExpressionGenerator.class);
		tr.put(MarginBorder.class, "/new/MarginBorder.javajet", NewMarginBorderExpressionGenerator.class);
		tr.put(CompoundBorder.class, "/new/CompoundBorder.javajet", NewCompoundBorderExpressionGenerator.class);
		tr.put(CustomBorder.class, "/new/CustomBorder.javajet", NewCustomBorderExpressionGenerator.class);

		return tr;
a98 32

	public String go(Figure fig, ImportAssistant importManager/*, Feedback feedback*/) {
		String res = null;
		myTopDispatcher.resetForNewClass(importManager);
		myInnerDispatcher.resetForNewClass(importManager);
		Object args = new Object[] {fig, myInnerDispatcher, myTopDispatcher, Boolean.valueOf(myIsInnerClassCode)};
		res = myTopDispatcher.dispatch(ENTRY_POINT, args);
		if (res == null) {
			throw new IllegalStateException();
		}
		return res;
	}
	
	private static class ClassesOrStringsKeyMap extends HierarchyKeyMap {
		/*
		 * Capture knowledge that we use classes and strings as keys
		 */
		public KeyChain map(Object key) {
			if (key instanceof String) {
				return super.map(key);
			} else {
				return super.map(key.getClass());
			}
		}
	}
/*
	public static class Feedback {
		void registerChildAccessor(Figure parent, Figure child, String getterName, String setterName) {
			// do nothing
		}
	}
*/
@


1.24
log
@extracted caching behaviour outside from the factory - moving towards support for different template engines, #114207
@
text
@d93 1
a93 1
		this(figureNameSwitch, new MapModeCodeGenStrategy.RuntimeUnspecifiedMapMode(), asInnerClass);
@


1.23
log
@[154687] mgolubev - Support scalable polygons
@
text
@d70 1
d72 1
d109 1
a109 1
		EmitterFactory topFactory = new EmitterFactory(templatePath, fillTopLevel(), true, variables, true);
d111 1
a111 1
		EmitterFactory innerFactory = new EmitterFactory(templatePath, fillAttrs(), true, variables, true);
@


1.22
log
@[154683] mgolubev - Handle custom borders.
@
text
@d69 1
d84 2
d105 1
a105 12
		KeyMap keyMap = new HierarchyKeyMap() {
			/*
			 * Capture knowledge that we use classes and strings as keys
			 */
			public KeyChain map(Object key) {
				if (key instanceof String) {
					return super.map(key);
				} else {
					return super.map(key.getClass());
				}
			}
		};
d115 1
d180 2
a181 2
		Object args = new Object[] {fig, importManager, myTopDispatcher.getFQNSwitch(), myInnerDispatcher, Boolean.valueOf(myIsInnerClassCode)};
		res = myTopDispatcher.dispatch(fig, args);
d187 13
@


1.21
log
@[mgolubev] #148402 Do not create unlimited number of font/color resources.
@
text
@d23 1
d56 1
d83 2
a84 2
	private GraphDefDispatcher myTopDispatcher;
	private GraphDefDispatcher myInnerDispatcher;
d171 1
@


1.21.2.1
log
@[153901] Updated copyright date from 2005 to 2005, 2006 for those changed in CVS in 2006 (based on Tom/Anthony's script).
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
@


1.20
log
@#140887 Remove Child interface from GMFGraph.
Although the need to reference child figures persist, thus FigureHandle was introduced, to allow diagramElements to reference either *generateable* figures (Figure subclasses) or *just-use* figures (like CustomFigure and FigureAccessor).
Refactoring performed with #131365 "Mirror GMFGraph model when generating standalone figure plugin" in mind
@
text
@d83 1
d85 2
a86 2
	public FigureGenerator(FigureQualifiedNameSwitch figureNameSwitch) {
		this(figureNameSwitch, new MapModeCodeGenStrategy.RuntimeUnspecifiedMapMode());
d89 2
a90 1
	public FigureGenerator(FigureQualifiedNameSwitch figureNameSwitch, MapModeCodeGenStrategy mapModeStrategy) {
d182 3
a184 3
		myTopDispatcher.setImportManager(importManager);
		myInnerDispatcher.setImportManager(importManager);
		Object args = new Object[] {fig, importManager, myTopDispatcher.getFQNSwitch(), myInnerDispatcher};
@


1.19
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@d173 1
a173 1
			throw new UnexpectedBehaviourException("Single Figure expected as argument: " + arguments);
d178 1
a178 1
	public String go(Figure fig, ImportAssistant importManager) {
d189 7
@


1.18
log
@[bblajer] ##139022 Provide option to choose mapMode for figures
@
text
@d14 3
d18 1
a18 1
import org.eclipse.emf.codegen.jet.JETException;
d73 1
d80 1
a80 2
public class FigureGenerator {
	private final String packageName;
d84 2
a85 2
	public FigureGenerator(String aPackageName, ImportAssistant importManager, FigureQualifiedNameSwitch figureNameSwitch) {
		this(aPackageName, importManager, figureNameSwitch, new MapModeCodeGenStrategy.RuntimeUnspecifiedMapMode());
d88 1
a88 2
	public FigureGenerator(String aPackageName, ImportAssistant importManager, FigureQualifiedNameSwitch figureNameSwitch, MapModeCodeGenStrategy mapModeStrategy) {
		packageName = aPackageName;
d112 1
a112 1
		myTopDispatcher = new GraphDefDispatcher(topFactory, keyMap, importManager, figureNameSwitch, mapModeStrategy);
d114 1
a114 8
		myInnerDispatcher = new GraphDefDispatcher(innerFactory, keyMap, importManager, figureNameSwitch, mapModeStrategy);
	}

	/**
	 * @@return possibly <code>null</code>
	 */
	public String getPackageStatement() {
		return packageName;
d171 8
a178 1
	public String go(Figure fig) throws JETException {
d180 3
a182 1
		Object args = new Object[] {fig, myTopDispatcher.getImportManager(), myTopDispatcher.getFQNSwitch(), myInnerDispatcher};
d187 1
a187 1
		return packageName == null ? res : "package " + packageName + ";\n" + res;
@


1.17
log
@#137840 uncompiliable code if CustomFigure contains Label  - gmfgen expects getters generated for figure's children; besides, it makes no much sense to keep both Figure.javajet and Shape.javajet, with sole difference in the way they process children
@
text
@d82 1
a82 1
		this(aPackageName, importManager, figureNameSwitch, new MapModeCodeGenStrategy.RuntimeUnspecifiedMapMode(importManager));
@


1.16
log
@[mgolubev] 134249 Generate all Figure/Shape properties
@
text
@a63 1
import org.eclipse.gmf.graphdef.codegen.templates.TopShapeGenerator;
a124 1
		tr.put(Shape.class, "/top/Shape.javajet", TopShapeGenerator.class);
@


1.15
log
@[mgolubev] #133290 customAttributes is not being dispatched.
@
text
@d19 1
d28 2
d51 1
d55 2
d169 6
@


1.14
log
@no reason to default FigureGenerator to use rt fqn switch, let clients decide
@
text
@d19 1
d36 1
d139 1
@


1.13
log
@Split FQNSwitch into interface and rt-specific implementation
New requirement on the switch - to provide additional requiremens
@
text
@a16 1
import org.eclipse.gmf.common.codegen.NullImportAssistant;
a33 1
import org.eclipse.gmf.gmfgraph.util.RuntimeFQNSwitch;
a73 4
	public FigureGenerator() {
		this(null, new NullImportAssistant(), new RuntimeFQNSwitch());
	}
	
@


1.12
log
@[mgolubev] #129328 handle MapMode access in a variety of ways
@
text
@d35 1
a35 1
import org.eclipse.gmf.gmfgraph.util.GMFGraphSwitch;
d77 1
a77 1
		this(null, new NullImportAssistant(), new FigureQualifiedNameSwitch());
d80 1
a80 1
	public FigureGenerator(String aPackageName, ImportAssistant importManager, GMFGraphSwitch figureNameSwitch) {
d84 1
a84 1
	public FigureGenerator(String aPackageName, ImportAssistant importManager, GMFGraphSwitch figureNameSwitch, MapModeCodeGenStrategy mapModeStrategy) {
d123 1
a123 1
		tr.put(PolylineConnection.class, "/PolylineConnection.javajet", TopConnectionGenerator.class);
@


1.11
log
@#125175
- Do not cache templates if dynamicTemplates == true
- template classLoader could be specified if using dynamicTemplates
@
text
@d79 4
d84 1
a84 1
	public FigureGenerator(String aPackageName, ImportAssistant importManager, GMFGraphSwitch figureNameSwitch) {
d109 1
a109 1
		myTopDispatcher = new GraphDefDispatcher(topFactory, keyMap, importManager, figureNameSwitch);
d111 1
a111 1
		myInnerDispatcher = new GraphDefDispatcher(innerFactory, keyMap, importManager, figureNameSwitch);
@


1.10
log
@#125175 Allow toolsmith to use different (sub)set of templates for editor code generation
@
text
@d118 1
a118 1
		StaticTemplateRegistry tr = new StaticTemplateRegistry();
d131 1
a131 1
		StaticTemplateRegistry tr = new StaticTemplateRegistry();
@


1.9
log
@[mgolubev] #127252 layout support
@
text
@d103 2
a104 1
		EmitterFactory topFactory = new EmitterFactory(thisBundle.getEntry("/"), fillTopLevel(), true, variables, true);
d106 1
a106 1
		EmitterFactory innerFactory = new EmitterFactory(thisBundle.getEntry("/"), fillAttrs(), true, variables, true);
d119 3
a121 3
		tr.put(PolylineConnection.class, "/templates/PolylineConnection.javajet", TopConnectionGenerator.class);
		tr.put(Shape.class, "/templates/top/Shape.javajet", TopShapeGenerator.class);
		tr.put(Figure.class, "/templates/top/Figure.javajet", TopFigureGenerator.class);
d132 7
a138 7
		tr.put(Figure.class, "/templates/attr/Figure.javajet", FigureAttrGenerator.class);
		tr.put(Shape.class, "/templates/attr/Shape.javajet", ShapeAttrGenerator.class);
		tr.put(Label.class, "/templates/attr/Label.javajet", LabelAttrGenerator.class);
		tr.put(Polyline.class, "/templates/attr/Polyline.javajet", PolylineAttrGenerator.class);
		tr.put(RoundedRectangle.class, "/templates/attr/RoundedRectangle.javajet", RoundedRectAttrGenerator.class);
		tr.put(PolygonDecoration.class, "/templates/attr/PolygonDecoration.javajet", PolygonDecorationAttrGenerator.class);
		tr.put(PolylineDecoration.class, "/templates/attr/PolylineDecoration.javajet", PolylineDecorationAttrGenerator.class);
d140 1
a140 1
		tr.put("instantiate", "/templates/new/Figure.javajet", NewFigureGenerator.class);
d142 1
a142 1
		tr.put("Children", "/templates/children/Figure.javajet", FigureChildrenGenerator.class);
d144 3
a146 3
		tr.put("Shape", "/templates/attr/Shape.javajet", ShapeAttrGenerator.class);
		tr.put("Figure", "/templates/attr/Figure.javajet", FigureAttrGenerator.class);
		tr.put("PolylineDecoration", "/templates/attr/PolylineDecoration.javajet", PolylineDecorationAttrGenerator.class);
d149 1
a149 1
		tr.put("customAttributes", "/templates/attr/CustomConfigurableClass.javajet", CustomClassAttributesGenerator.class);
d151 5
a155 5
		tr.put("createLayout", "/templates/new/Layout.javajet", NewLayoutGenerator.class);
		tr.put(GridLayout.class, "/templates/layout/GridLayout.javajet", InitGridLayoutGenerator.class);
		tr.put(BorderLayout.class, "/templates/layout/BorderLayout.javajet", InitBorderLayoutGenerator.class);
		tr.put(CustomLayout.class, "/templates/layout/CustomLayout.javajet", InitCustomLayoutGenerator.class);
		tr.put(FlowLayout.class, "/templates/layout/FlowLayout.javajet", InitFlowLayoutGenerator.class);
d157 5
a161 5
		tr.put("createLayoutData", "/templates/new/LayoutData.javajet", NewLayoutDataGenerator.class);
		tr.put(GridLayoutData.class, "/templates/layoutData/GridLayoutData.javajet", InitGridLayoutDataGenerator.class);
		tr.put(BorderLayoutData.class, "/templates/layoutData/BorderLayoutData.javajet", InitBorderLayoutDataGenerator.class);
		tr.put(CustomLayoutData.class, "/templates/layoutData/CustomLayoutData.javajet", InitCustomLayoutDataGenerator.class);
		tr.put(XYLayoutData.class, "/templates/layoutData/XYLayoutData.javajet", InitXYLayoutDataGenerator.class);
@


1.8
log
@[mgolubev] #127252 layout support
@
text
@d23 1
d33 1
d43 1
d46 1
d154 1
d160 1
@


1.7
log
@minor refactoring
@
text
@d18 4
d23 2
d34 1
d37 6
d45 2
d119 1
a119 1

d142 13
@


1.6
log
@refactor - moved EmitterFactory/Dispatcher infrastructure to gmf.common to enable its use in oeg.codegen
@
text
@a13 2
import java.util.ArrayList;

d64 7
a70 6
		final ArrayList variables = new ArrayList();
		variables.add("org.eclipse.gmf.graphdef");
		variables.add("org.eclipse.emf.ecore");
		variables.add("org.eclipse.emf.common");
		variables.add("org.eclipse.gmf.common");
		variables.add("org.eclipse.gmf.graphdef.codegen");
@


1.5
log
@major refactoring of gmfgraph codegen utilizing dispatcher infrastructure
@
text
@d28 2
d42 6
a47 7
import org.eclipse.gmf.internal.graphdef.codegen.DispatcherImpl;
import org.eclipse.gmf.internal.graphdef.codegen.HierarchyKeyMap;
import org.eclipse.gmf.internal.graphdef.codegen.KeyChain;
import org.eclipse.gmf.internal.graphdef.codegen.KeyMap;
import org.eclipse.gmf.internal.graphdef.codegen.StaticTemplateRegistry;
import org.eclipse.gmf.internal.graphdef.codegen.TemplateRegistry;
import org.eclipse.gmf.internal.graphdef.codegen.YAEmitterFactory;
d56 2
a57 2
	private Dispatcher myTopDispatcher;
	private Dispatcher myInnerDispatcher;
d60 1
a60 1
		this(null);
d63 1
a63 1
	public FigureGenerator(String aPackageName) {
d85 4
a88 4
		YAEmitterFactory topFactory = new YAEmitterFactory(thisBundle.getEntry("/"), fillTopLevel(), true, variables, true);
		myTopDispatcher = new DispatcherImpl(topFactory, keyMap);
		YAEmitterFactory innerFactory = new YAEmitterFactory(thisBundle.getEntry("/"), fillAttrs(), true, variables, true);
		myInnerDispatcher = new DispatcherImpl(innerFactory, keyMap);
a131 4
		return go(fig, new NullImportAssistant());
	}

	public String go(Figure fig, ImportAssistant importManager) {
d133 2
a134 1
		res = myTopDispatcher.dispatch(fig, new Object[] {fig, importManager, myInnerDispatcher});
@


1.4
log
@provisional framework that supports (double-)dispatch from templates to
a) avoid lengthy if instanceof elseif checks,
b) solve scope and name visibility issues when extracting common code into jetinc
@
text
@a16 1
import org.eclipse.emf.codegen.jet.JETEmitter;
d18 1
a18 2
import org.eclipse.emf.common.util.BasicMonitor;
import org.eclipse.gmf.common.UnexpectedBehaviourException;
a19 2
import org.eclipse.gmf.gmfgraph.CustomFigure;
import org.eclipse.gmf.gmfgraph.DecorationFigure;
d22 2
d25 2
d28 12
a39 6
import org.eclipse.gmf.graphdef.codegen.templates.ConnectionGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.CustomFigureGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.DecorationFigureGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.LabelGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.ShapeAttrsGenerator;
import org.eclipse.gmf.graphdef.codegen.templates.ShapeGenerator;
d41 3
a43 1
import org.eclipse.gmf.internal.graphdef.codegen.NoSuchTemplateException;
d55 2
a56 2
	private YAEmitterFactory myFactory;
	private Dispatcher myDispatcher;
d72 16
a87 2
		myFactory = new YAEmitterFactory(thisBundle.getEntry("/"), fill(), true, variables, true);
		myDispatcher = new DispatcherImpl(myFactory);
d97 1
a97 1
	private static TemplateRegistry fill() {
d99 28
a126 6
		tr.put(PolylineConnection.class, "/templates/PolylineConnection.javajet", ConnectionGenerator.class);
		tr.put(DecorationFigure.class, "/templates/DecorationFigure.javajet", DecorationFigureGenerator.class);
		tr.put(Shape.class, "/templates/ConcreteShape.javajet", ShapeGenerator.class);
		tr.put(Label.class, "/templates/Label.javajet", LabelGenerator.class);
		tr.put(CustomFigure.class, "/templates/CustomFigure.javajet", CustomFigureGenerator.class);
		tr.put("ShapeAttrs", "/templates/ShapeAttrs.javajet", ShapeAttrsGenerator.class);
d131 4
d136 1
a136 13
		try {
		if (fig instanceof PolylineConnection) {
			res = generate(fig, myFactory.acquireEmitter(PolylineConnection.class));
		} else if (fig instanceof DecorationFigure) {
			res = generate(fig, myFactory.acquireEmitter(DecorationFigure.class));
		} else if (fig instanceof Shape) {
			res = generate(fig, myFactory.acquireEmitter(Shape.class));
		} else if (fig instanceof CustomFigure) {
			res = generate(fig, myFactory.acquireEmitter(CustomFigure.class));
		} else if (fig instanceof Label) {
			res = generate(fig, myFactory.acquireEmitter(Label.class));
		}
// TODO: } else if (fig instanceof LabeledContainer) {
a139 5
		} catch (UnexpectedBehaviourException ex) {
			throw new IllegalStateException(ex);
		} catch (NoSuchTemplateException ex) {
			throw new IllegalStateException(ex);
		}
a141 5

	private String generate(Figure fig, JETEmitter emitter) throws JETException {
		Object argument = new Object[] {fig, new NullImportAssistant(), myDispatcher};
		return emitter.generate(new BasicMonitor.Printing(System.out), new Object[] {argument});
	}
@


1.3
log
@provide option to use importManager
@
text
@d14 2
d20 1
d28 11
a45 4
	private final JETEmitter shapeEmitter;
	private final JETEmitter customFigureEmitter;
	private final JETEmitter decorationFigureEmitter;
	private final JETEmitter polylineConnectionEmitter;
d47 2
a48 1
	private final JETEmitter labelFigureEmitter;
d57 9
a65 10
		shapeEmitter = new JETEmitter(thisBundle.getEntry("/templates/ConcreteShape.javajet").toString(), FigureGenerator.class.getClassLoader());
		initEmitter(shapeEmitter);
		customFigureEmitter = new JETEmitter(thisBundle.getEntry("/templates/CustomFigure.javajet").toString(), FigureGenerator.class.getClassLoader());
		initEmitter(customFigureEmitter);
		decorationFigureEmitter = new JETEmitter(thisBundle.getEntry("/templates/DecorationFigure.javajet").toString(), FigureGenerator.class.getClassLoader());
		initEmitter(decorationFigureEmitter);
		polylineConnectionEmitter = new JETEmitter(thisBundle.getEntry("/templates/PolylineConnection.javajet").toString(), FigureGenerator.class.getClassLoader());
		initEmitter(polylineConnectionEmitter);
		labelFigureEmitter = new JETEmitter(thisBundle.getEntry("/templates/Label.javajet").toString(), FigureGenerator.class.getClassLoader());
		initEmitter(labelFigureEmitter);
d75 9
a83 10
	private static void initEmitter(JETEmitter emitter) {
		try {
			emitter.addVariable("A", "org.eclipse.gmf.graphdef");
			emitter.addVariable("B", "org.eclipse.emf.ecore");
			emitter.addVariable("C", "org.eclipse.emf.common");
			emitter.addVariable("D", "org.eclipse.gmf.common");
		} catch (JETException ex) {
			ex.printStackTrace();
			// ignore for now
		}
d88 1
d90 1
a90 1
			res = generate(fig, polylineConnectionEmitter);
d92 1
a92 1
			res = generate(fig, decorationFigureEmitter);
d94 1
a94 1
			res = generate(fig, shapeEmitter);
d96 1
a96 1
			res = generate(fig, customFigureEmitter);
d98 1
a98 1
			res = generate(fig, labelFigureEmitter);
d104 5
d113 1
a113 1
		Object argument = new Object[] {fig, new NullImportAssistant()};
@


1.2
log
@- Generating figures for Child node
- Transforming coordinates for rounded rectangles
@
text
@d18 1
d70 1
d98 2
a99 1
		return emitter.generate(new BasicMonitor.Printing(System.out), new Object[] {fig});
@


1.1
log
@ some templates to support #114177 (graphical definition model) - with GEF IFigure code as an outcome
@
text
@d21 1
d36 1
d53 2
d85 2
d88 1
@

