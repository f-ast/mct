head	1.11;
access;
symbols
	v20080813-1520:1.11
	v20080806-1520:1.11
	v20080731-1520:1.11
	v20061027-1200:1.7
	v20061013-1330:1.9
	v20060925-1700:1.7
	v20060919-0800:1.7
	M1_20:1.9
	v20060904-1500:1.9
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060626-1420:1.7
	v20060616-1200:1.6
	v20060531-1730:1.6
	v20060530-1930:1.6
	v20060526-1200:1.6
	v20060519-1300:1.6
	v20060519-0800:1.6
	I20060505-1400:1.5
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.4
	I20060216-1945:1.3
	I20060210-1715:1.1
	I20060209-1815:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2006.11.02.21.58.37;	author atikhomirov;	state dead;
branches;
next	1.10;

1.10
date	2006.11.02.17.38.23;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.30.15.09.11;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.24.13.13.37;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.26.16.49.29;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.18.19.12.40;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.01.20.18.30;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.24.15.11.34;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.15.14.44.35;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.13.17.36.17;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.06.22.21.42;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.11
log
@JET templates for gmfgraph model replaced with Xpand counterparts.
MapMode handling simplified
@
text
@/*
 * Copyright (c) 2006 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.graphdef.codegen;

import java.util.HashMap;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.gmf.common.codegen.ImportAssistant;
import org.eclipse.gmf.gmfgraph.Figure;
import org.eclipse.gmf.gmfgraph.Layout;
import org.eclipse.gmf.gmfgraph.LayoutData;
import org.eclipse.gmf.gmfgraph.util.FigureQualifiedNameSwitch;
import org.eclipse.gmf.internal.codegen.dispatch.DispatcherImpl;
import org.eclipse.gmf.internal.codegen.dispatch.EmitterFactory;
import org.eclipse.gmf.internal.codegen.dispatch.KeyMap;

/**
 * @@author artem
 */
public class GraphDefDispatcher extends DispatcherImpl {
	private ImportAssistant myImportManager;
	private final FigureQualifiedNameSwitch myFqnSwitch;
	private final MapModeCodeGenStrategy myMapModeStrategy;
	private final StaticFieldsManager myStaticFieldsManager;
	private final AuxiliaryDataStorage myAuxiliaryDataStorage;
	
	public GraphDefDispatcher(EmitterFactory factory, KeyMap keyMap, FigureQualifiedNameSwitch fqnSwitch, MapModeCodeGenStrategy mapModeStrategy) {
		super(factory, keyMap);
		assert mapModeStrategy != null;
		myFqnSwitch = fqnSwitch;
		myMapModeStrategy = mapModeStrategy;
		myStaticFieldsManager = new StaticFieldsManager();
		myAuxiliaryDataStorage = new AuxiliaryDataStorage();
	}
	
	public StaticFieldsManager getStaticFieldsManager(){
		return myStaticFieldsManager;
	}
	
	public String DPtoLP(int deviceUnit){
		return String.valueOf(deviceUnit);
	}
	
	public String LPtoDP(int logicalUnit){
		return String.valueOf(logicalUnit);
	}
	
	public ImportAssistant getImportManager() {
		return myImportManager;
	}
	
	public AuxiliaryDataStorage getAuxiliaryDataStorage(){
		return myAuxiliaryDataStorage;
	}
	
	/**
	 * Not good. Would be better to have importManager as part of Args, perhaps. 
	 */
	/*package-local*/ void resetForNewClass(ImportAssistant assistant) {
		setImportManager(assistant);
		myStaticFieldsManager.reset();
		myAuxiliaryDataStorage.reset();
	}

	public FigureQualifiedNameSwitch getFQNSwitch() {
		return myFqnSwitch;
	}
	
	public Args create(Figure figure, String figureVarName) {
		return new Args(this, figure, figureVarName);
	}

	public LayoutArgs getLayoutArgsFor(Args prototype) {
		return prototype instanceof LayoutArgs ? (LayoutArgs)prototype : new LayoutArgs(prototype);
	}

	public LayoutArgs createLayoutArgs(Figure figure, String figureVarName, String managerVarName, String constraintVarName) {
		return new LayoutArgs(this, figure, figureVarName, managerVarName, constraintVarName);
	}

	public LayoutArgs createLayoutArgs(Args inherit, String managerVarName, String constraintVarName) {
		return new LayoutArgs(inherit, managerVarName, constraintVarName);
	}
	
	private void setImportManager(ImportAssistant manager) {
		myImportManager = manager; 
	}
	
	/**
	 * "Write-once" map that allows to associate arbitrary data with some
	 * gmfgraph instance.
	 * 
	 * It allows to generate some auxiliary code (say, getter method) for given
	 * gmfgraph instance in one template, store the getter name in the Storage
	 * and retrieve it in different template to insert call for this getter into
	 * different place.
	 * 
	 * To avoid unexpected data loss, any key may be set only once and remains
	 * available during generation of some compilation unit. It is the reason
	 * for data to be declared as Object instead of String. If you need to
	 * associate 2 different strings with given object use ad hoc class to store
	 * data.
	 * 
	 * NOTE: This data storage is automatically reset when owning dispatcher is
	 * reset for new compilation unit generation.
	 */
	public static class AuxiliaryDataStorage {
		private final HashMap<EObject, Object> myData;
		
		public AuxiliaryDataStorage(){
			myData = new HashMap<EObject, Object>();
		}
		
		public void registerData(EObject owner, Object data){
			if (myData.containsKey(owner)){
				throw new IllegalArgumentException("EObject: " + owner + " has registered data: " + myData.get(owner));
			}
			if (data == null){
				throw new NullPointerException("Null data for EObject: " + owner);
			}
			myData.put(owner, data);
		}
		
		public Object getRegisteredData(EObject owner){
			return myData.get(owner);
		}
		
		private void reset(){
			myData.clear();
		}
	}

	public static class Args {
		private final Figure myFigure;
		private final String myFigureVarName;
		private final GraphDefDispatcher myOwner;

		public Args(GraphDefDispatcher owner, Figure figure, String figureVarName) {
			myOwner = owner;
			myFigure = figure;
			myFigureVarName = figureVarName;
		}

		protected Args(Args other) {
			this(other.getDispatcher(), other.getFigure(), other.getVariableName());
		}

		public Figure getFigure() {
			return myFigure;
		}

		public String getVariableName() {
			return myFigureVarName;
		}

		public GraphDefDispatcher getDispatcher() {
			return myOwner;
		}
	}

	public static class LayoutArgs extends Args {
		private final String myLayoutVariableName;
		private final String myLayoutDataVariableName;

		/**
		 * @@param managerVariableName
		 *            name of layout manager variable defined somewhere in the
		 *            generated code, should not be <code>null</code>
		 * @@param constraintVariableName
		 *            optional name of the layout constraint variable, or
		 *            <code>null</code> if current context does not contain
		 *            constraint information.
		 */
		private LayoutArgs(GraphDefDispatcher owner, Figure figure, String figureVarName, String managerVariableName, String constraintVariableName) {
			super(owner, figure, figureVarName);
			myLayoutVariableName = managerVariableName;
			myLayoutDataVariableName = constraintVariableName;
		}

		private LayoutArgs(Args inherit, String managerVariableName, String constraintVariableName) {
			super(inherit);
			myLayoutVariableName = managerVariableName;
			myLayoutDataVariableName = constraintVariableName;
		}

		private LayoutArgs(Args args) {
			this(args, args.getVariableName() + "Layouter", args.getVariableName() + "Constraint");
		}

		public Layout getLayout() {
			return getFigure().getLayout();
		}

		public LayoutData getData() {
			return getFigure().getLayoutData();
		}

		public String getManagerVariableName() {
			return myLayoutVariableName;
		}
		
		public String getConstraintVariableName() {
			return myLayoutDataVariableName;
		}
	}
}
@


1.10
log
@moving towards jet-to-xpand switch
@
text
@@


1.9
log
@avoid 'unchecked' warnings
@
text
@d50 1
a50 1
		return myMapModeStrategy.DPtoLP(deviceUnit);
d54 1
a54 1
		return myMapModeStrategy.LPtoDP(logicalUnit);
@


1.8
log
@[154683] mgolubev - Handle custom borders.
@
text
@d117 1
a117 1
		private final HashMap myData;
d120 1
a120 1
			myData = new HashMap();
@


1.7
log
@[mgolubev] #148402 Do not create unlimited number of font/color resources.
@
text
@d14 3
d34 1
d42 1
d61 4
d71 1
d97 44
@


1.6
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@d30 1
d36 6
a41 1
		myMapModeStrategy = mapModeStrategy;  
d55 1
a55 1

d59 3
a61 2
	/*package-local*/ void setImportManager(ImportAssistant manager) {
		myImportManager = manager; 
d83 4
@


1.5
log
@Split FQNSwitch into interface and rt-specific implementation
New requirement on the switch - to provide additional requiremens
@
text
@d27 1
a27 1
	private final ImportAssistant myImportManager;
d31 1
a31 1
	public GraphDefDispatcher(EmitterFactory factory, KeyMap keyMap, ImportAssistant importManager, FigureQualifiedNameSwitch fqnSwitch, MapModeCodeGenStrategy mapModeStrategy) {
a33 1
		myImportManager = importManager;
d50 7
@


1.4
log
@[mgolubev] #129328 handle MapMode access in a variety of ways
@
text
@d18 1
a18 1
import org.eclipse.gmf.gmfgraph.util.GMFGraphSwitch;
d28 1
a28 1
	private final GMFGraphSwitch myFqnSwitch;
d31 1
a31 1
	public GraphDefDispatcher(EmitterFactory factory, KeyMap keyMap, ImportAssistant importManager, GMFGraphSwitch fqnSwitch, MapModeCodeGenStrategy mapModeStrategy) {
d51 1
a51 1
	public GMFGraphSwitch getFQNSwitch() {
@


1.3
log
@[mgolubev] #127252 layout support
@
text
@d29 3
a31 2

	public GraphDefDispatcher(EmitterFactory factory, KeyMap keyMap, ImportAssistant importManager, GMFGraphSwitch fqnSwitch) {
d33 1
d36 9
@


1.2
log
@[mgolubev] #127252 layout support
@
text
@d48 2
a49 2
	public LayoutArgs createLayoutArgs(Args inherit, String layoutVarName) {
		return new LayoutArgs(inherit, layoutVarName);
d52 2
a53 2
	public LayoutArgs createLayoutArgs(Args inherit) {
		return new LayoutArgs(inherit);
d56 2
a57 2
	public LayoutArgs createLayoutArgs(Figure figure, String figureVarName, String layoutVarName) {
		return new LayoutArgs(this, figure, figureVarName, layoutVarName);
d90 1
d93 7
a99 4
		 * @@param layoutVariableName
		 *            may be either name of layout manager or figure constraint,
		 *            because there are no contexts requiring both of names in the
		 *            same time
d101 4
a104 3
		public LayoutArgs(Args inherit, String layoutVariableName) {
			super(inherit);
			myLayoutVariableName = layoutVariableName;
d107 4
a110 2
		public LayoutArgs(Args args) {
			this(args, args.getVariableName() + "Layout");
d113 2
a114 3
		public LayoutArgs(GraphDefDispatcher owner, Figure figure, String figureVarName, String layoutVarName) {
			super(owner, figure, figureVarName);
			myLayoutVariableName = layoutVarName;
d125 1
a125 1
		public String getLayoutVariableName() {
d128 4
@


1.1
log
@refactor - moved EmitterFactory/Dispatcher infrastructure to gmf.common to enable its use in oeg.codegen
@
text
@d16 2
d35 1
a35 1

d43 4
d48 7
d56 2
a57 2
	public Args create(Figure figure, String figureVarName) {
		return new Args(this, figure, figureVarName);
d71 4
d87 36
@

