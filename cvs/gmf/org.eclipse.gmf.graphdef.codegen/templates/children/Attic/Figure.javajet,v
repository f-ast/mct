head	1.9;
access;
symbols
	v20080813-1520:1.9
	v20080806-1520:1.9
	v20080731-1520:1.9
	v20061027-1200:1.8
	v20061013-1330:1.8
	v20060925-1700:1.8
	v20060919-0800:1.8
	M1_20:1.8
	v20060904-1500:1.8
	v20060713-1700:1.8
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	v20060627-1200:1.8
	v20060626-1420:1.8
	v20060616-1200:1.8
	v20060531-1730:1.8
	v20060530-1930:1.8
	v20060526-1200:1.8
	v20060519-1300:1.7
	v20060519-0800:1.7
	I20060505-1400:1.7
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.4
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.2
	I20060209-1815:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.9
date	2006.11.02.21.58.38;	author atikhomirov;	state dead;
branches;
next	1.8;

1.8
date	2006.05.25.14.06.33;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.02.11.44.18;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.14.14.37.44;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.30.22.39.09;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.15.14.44.35;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.13.17.36.17;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.06.22.21.42;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.06.18.10.23;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.9
log
@JET templates for gmfgraph model replaced with Xpand counterparts.
MapMode handling simplified
@
text
@<%@@ jet package="org.eclipse.gmf.graphdef.codegen.templates" class="FigureChildrenGenerator"
	imports="org.eclipse.gmf.gmfgraph.* org.eclipse.gmf.graphdef.codegen.* org.eclipse.gmf.common.codegen.* org.eclipse.gmf.gmfgraph.util.* org.eclipse.emf.codegen.util.CodeGenUtil java.util.*"%>
<%
GraphDefDispatcher.LayoutArgs parentArgs = (GraphDefDispatcher.LayoutArgs) argument;
final Figure root = parentArgs.getFigure();
final GraphDefDispatcher dispatcher = parentArgs.getDispatcher();
final ImportAssistant importManager = dispatcher.getImportManager();

final List/*<Figure>*/ fieldsRequired = new LinkedList/*<Figure>*/();
final Stack/*GraphDefDispatcher.LayoutArgs*/ contextStack = new Stack/*GraphDefDispatcher.LayoutArgs*/();
final LinkedList queue = new LinkedList();
final Object marker = new Object();
final NamingStrategy namingStrategy = NamingStrategy.INSTANCE;

class FieldSupport {
	private final Figure myRoot;

	public FieldSupport(Figure root){
		myRoot = root;
	}
	
	public boolean isFieldRequired(Figure descendant){
		return myRoot.equals(descendant.getParent()) || !descendant.getReferencingElements().isEmpty();
	}
}
final FieldSupport fieldSupport = new FieldSupport(root);

%>

	/**
	 * @@generated
	 */
	private void createContents(){
<%
queue.addAll(root.getChildren());
int figureCount = 0;
while (!queue.isEmpty()){
	Object _nxt = queue.removeFirst();
	if (_nxt == marker){
		parentArgs = (GraphDefDispatcher.LayoutArgs)contextStack.pop();
		continue;
	}
	if (_nxt instanceof FigureRef) {
		throw new IllegalStateException("FIXME: sorry, don't support FigureRef for a while");
	}
	final Figure nextChild = (Figure) _nxt;	
	final String childVarName = "fig_" + figureCount;
	final String childLayoutManager = "layouter" + figureCount;
	final String childConstraint = "layData" + figureCount;
	figureCount++;
	
	// FIXME instantiate - FigureRef - dispatch to 'instantiate' template?
	GraphDefDispatcher.LayoutArgs nextLevelArgs = dispatcher.createLayoutArgs(nextChild, childVarName, childLayoutManager, childConstraint);%>
		<%=dispatcher.dispatch("instantiate", nextLevelArgs)%>
<%
if (fieldSupport.isFieldRequired(nextChild)){
	fieldsRequired.add(nextChild); %>
		setFigure<%=nextChild.getName()%>(<%=childVarName%>);
<%}%>
		<%=dispatcher.dispatch("createLayoutData", nextLevelArgs)%>
		<%=parentArgs.getVariableName()%>.add(<%=childVarName%>, <%=childConstraint%>);
<%
	if (!nextChild.getChildren().isEmpty()) {
		queue.addFirst(marker);
		queue.addAll(0, nextChild.getChildren());
		contextStack.push(parentArgs);
		parentArgs = nextLevelArgs; // go on processing children of new parentFigure
	} 
} // while
%>
	}
	
<%
	final FigureQualifiedNameSwitch fqnSwitch = dispatcher.getFQNSwitch();
	for (Iterator fieldFigures = fieldsRequired.iterator(); fieldFigures.hasNext();){
		Figure next = (Figure)fieldFigures.next(); 
		final String nextClassName = fqnSwitch.get(next, importManager);%>
		
	/**
	 * @@generated
	 */
	private <%=nextClassName%> f<%=CodeGenUtil.capName(next.getName())%>; 

	/**
	 * @@generated
	 */
	public <%=nextClassName%> <%=namingStrategy.getChildFigureGetterName(next)%>() {
		return f<%=CodeGenUtil.capName(next.getName())%>;
	}
	
	/**
	 * @@generated
	 */
	private void setFigure<%=next.getName()%>(<%=nextClassName%> fig){
		f<%=CodeGenUtil.capName(next.getName())%> = fig;
	}

<%	}%>
@


1.8
log
@[mgolubev] #139148 Respect gmfgraph.compartment figure
[mgolubev] #143619 Temp fix for misassumption of ParentAssignedViewmap regarding generated getter name
@
text
@@


1.7
log
@[mgolubev] #139139 Compilation error in the generated diagram code if DiagramLabel points to the deep Label
Add getters/setters for each figure that is being used by any diagram element
@
text
@d13 1
d87 1
a87 1
	public <%=nextClassName%> getFigure<%=next.getName()%>() {
@


1.6
log
@#135020 remove irrelevant comments from generated figure code
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.gmfgraph.* org.eclipse.gmf.graphdef.codegen.* java.util.*"%>
d4 23
a26 4
Object[] args = (Object[]) argument;
List/*<Figure>*/ figureChildren = (List) args[0];
final GraphDefDispatcher dispatcher = (GraphDefDispatcher) args[1];
GraphDefDispatcher.LayoutArgs parentArgs = (GraphDefDispatcher.LayoutArgs) args[2];
d29 4
d34 1
a34 4
LinkedList l = new LinkedList();
l.addAll(figureChildren);
final Object marker = new Object();
Stack figureVarNamesStack = new Stack();
d36 4
a39 4
while (!l.isEmpty()) {
	Object _nxt = l.removeFirst();
	if (_nxt == marker) {
		parentArgs = (GraphDefDispatcher.LayoutArgs) figureVarNamesStack.pop();
d42 1
a42 2
	final FigureMarker figureMarker = (FigureMarker) _nxt;
	if (figureMarker instanceof FigureRef) {
d45 4
a48 3
	final String figureVarName = "fig_" + figureCount;
	final String layoutManagerVarName = "layouter" + figureCount;
	final String layoutDataVarName = "layData" + figureCount;
d50 3
a52 2
		// FIXME instantiate - FigureRef - dispatch to 'instantiate' template?
		GraphDefDispatcher.LayoutArgs nextLevelArgs = dispatcher.createLayoutArgs((Figure) figureMarker, figureVarName, layoutManagerVarName, layoutDataVarName);%>
a53 2
		<%=parentArgs.getVariableName()%>.add(<%=figureVarName%>);
		<%=dispatcher.dispatch("createLayoutData", dispatcher.createLayoutArgs(nextLevelArgs, parentArgs.getManagerVariableName(), layoutDataVarName))%>
d55 13
a67 6
if (_nxt instanceof Figure && !((Figure) _nxt).getChildren().isEmpty()) {
	l.addFirst(marker);
	l.addAll(0, ((Figure) _nxt).getChildren());
	figureVarNamesStack.push(parentArgs);
	parentArgs = nextLevelArgs; // go on processing children of new parentFigure
} // if
d70 28
@


1.5
log
@[mgolubev] #134097 Invalid code is generated for the node figure with XYLayout
@
text
@d29 1
a29 1
	figureCount++;%>
d31 1
a31 1
		<%GraphDefDispatcher.LayoutArgs nextLevelArgs = dispatcher.createLayoutArgs((Figure) figureMarker, figureVarName, layoutManagerVarName, layoutDataVarName);%>
@


1.4
log
@[mgolubev] #127252 layout support
@
text
@d7 1
a7 1
String parentFigureVarName = (String) args[2];
d19 1
a19 1
		parentFigureVarName = (String) figureVarNamesStack.pop();
d26 1
a26 1
	final String figureVarName = "fig" + figureCount;
d31 4
a34 5
		<%GraphDefDispatcher.Args dargs = dispatcher.create((Figure) figureMarker, figureVarName);
		GraphDefDispatcher.LayoutArgs layoutAwareArgs = dispatcher.createLayoutArgs(dargs, layoutManagerVarName, layoutDataVarName);%>
		<%=dispatcher.dispatch("instantiate", layoutAwareArgs)%>
		<%=parentFigureVarName%>.add(<%=figureVarName%>);
		<%=dispatcher.dispatch("createLayoutData", layoutAwareArgs)%>
d39 2
a40 2
	figureVarNamesStack.push(parentFigureVarName);
	parentFigureVarName = figureVarName; // go on processing children of new parentFigure
@


1.3
log
@[mgolubev] #127252 layout support
@
text
@d27 1
d31 3
a33 2
		<%GraphDefDispatcher.Args dargs = dispatcher.create((Figure) figureMarker, figureVarName);%>
		<%=dispatcher.dispatch("instantiate", dargs)%>
d35 1
a35 1
		<%=dispatcher.dispatch("createLayoutData", dispatcher.createLayoutArgs(dargs, layoutDataVarName))%>
@


1.2
log
@refactor - moved EmitterFactory/Dispatcher infrastructure to gmf.common to enable its use in oeg.codegen
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.gmfgraph.* org.eclipse.gmf.graphdef.codegen.GraphDefDispatcher java.util.*"%>
d26 3
a28 1
	final String figureVarName = "fig" + (figureCount++);%>
d30 2
a31 1
		<%=dispatcher.dispatch("instantiate", dispatcher.create((Figure) figureMarker, figureVarName))%>
d33 1
@


1.1
log
@major refactoring of gmfgraph codegen utilizing dispatcher infrastructure
@
text
@d2 1
a2 1
	imports="org.eclipse.gmf.gmfgraph.* org.eclipse.gmf.gmfgraph.util.* org.eclipse.gmf.common.codegen.* org.eclipse.gmf.graphdef.codegen.Dispatcher java.util.*"%>
d6 2
a7 4
final ImportAssistant importManager = (ImportAssistant) args[1];
final GMFGraphSwitch fqnSwitch = (GMFGraphSwitch) args[2];
final Dispatcher dispatcher = (Dispatcher) args[3];
String parentFigureVarName = (String) args[4];
d28 1
a28 1
		<%=dispatcher.dispatch("instantiate", dispatcher.create((Figure) figureMarker, figureVarName, importManager, fqnSwitch))%>
@

