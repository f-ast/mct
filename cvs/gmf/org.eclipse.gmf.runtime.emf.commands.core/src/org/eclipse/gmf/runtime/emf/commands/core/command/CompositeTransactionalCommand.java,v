head	1.9;
access;
symbols
	v20081020-0700:1.9
	v20080722-1827:1.9
	v20080716-1600:1.9
	v20080716-1642:1.9
	R2_1_maintenance:1.9.0.2
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080425-1959:1.9
	v20080402-1725:1.8
	v20080222-1200:1.6
	v20080114-2222:1.5.2.1
	v20071130-1111:1.6
	v20071124-0000:1.5.2.1
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	RC3_20:1.5
	v20070601-1400:1.5
	v20070330-1300:1.5
	v20070221-1500:1.5
	v20070209-1900:1.3.2.2
	v20060209-1900:1.3.2.2
	M4_20:1.4
	v20061214-0000:1.4
	M3_20:1.4
	v20061117-0800:1.4
	v20061020-1000:1.3.2.1
	v20061013-1330:1.3
	v20060925-1700:1.3
	v20060919-0800:1.3
	M1_20:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1200:1.3
	v20060531-1730:1.3
	v20060519-0800:1.3
	I20060505-1400:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1
	I20060216-1945:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.9
date	2008.04.25.18.39.54;	author ahunter;	state Exp;
branches;
next	1.8;
commitid	27984812257a4567;

1.8
date	2008.04.03.14.38.35;	author ahunter;	state Exp;
branches;
next	1.7;
commitid	40ca47f4ebeb4567;

1.7
date	2008.04.03.14.09.04;	author ahunter;	state Exp;
branches;
next	1.6;
commitid	223c47f4e5004567;

1.6
date	2007.11.21.21.19.22;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	50424744a0da4567;

1.5
date	2007.02.09.14.29.24;	author crevells;	state Exp;
branches
	1.5.2.1;
next	1.4;
commitid	64d645cc85434567;

1.4
date	2006.10.13.21.44.23;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.11.19.59.39;	author ldamus;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2006.03.27.21.12.47;	author ldamus;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.13.19.11.05;	author ldamus;	state Exp;
branches;
next	;

1.3.2.1
date	2006.10.13.21.33.53;	author ahunter;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2007.02.09.14.08.07;	author crevells;	state Exp;
branches;
next	;
commitid	40ce45cc80474567;

1.5.2.1
date	2007.11.21.21.21.46;	author aboyko;	state Exp;
branches;
next	;
commitid	51a44744a16a4567;


desc
@@


1.9
log
@[228915] gmf-head ahunter 080425 Non-externalized string literal; it should be followed by //$NON-NLS-<n>
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.commands.core.command;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.core.commands.operations.IOperationApprover;
import org.eclipse.core.commands.operations.IUndoableOperation;
import org.eclipse.core.commands.operations.OperationHistoryFactory;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.workspace.AbstractEMFOperation;
import org.eclipse.emf.workspace.CompositeEMFOperation;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.command.ICompositeCommand;
import org.eclipse.gmf.runtime.common.core.internal.command.ICommandWithSettableResult;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;

/**
 * An undoable operation that is composed of child {@@link IUndoableOperation}s
 * that are expected to modify EMF model resources.
 * <p>
 * The operation provides a list of {@@link IFile}s that are expected to be
 * modified when the operation is executed, undone or redone. An
 * {@@link IOperationApprover} is registered with the
 * {@@link OperationHistoryFactory#getOperationHistory()} to validate the
 * modification to these resources.
 * <P>
 * This class is meant to be instantiated by clients.
 * 
 * @@author ldamus
 */
public class CompositeTransactionalCommand
    extends CompositeEMFOperation
    implements ICompositeCommand, ICommandWithSettableResult {

    private CommandResult commandResult;

    /**
     * Initializes me with the editing domain in which I am making model changes
     * and a label.
     * 
     * @@param domain
     *            my editing domain
     * @@param label
     *            my user-readable label, should never be <code>null</code>.
     */
    public CompositeTransactionalCommand(TransactionalEditingDomain domain,
            String label) {
        super(domain, (label == null) ? StringStatics.BLANK : label);
    }

    /**
     * Initializes me with the editing domain, a label, and transaction options.
     * 
     * @@param domain
     *            my editing domain
     * @@param label
     *            my user-readable label, should never be <code>null</code>.
     * @@param options
     *            for the transaction in which I execute myself, or
     *            <code>null</code> for the default options
     */
    public CompositeTransactionalCommand(TransactionalEditingDomain domain,
            String label, Map options) {
        super(domain, (label == null) ? StringStatics.BLANK : label, options);
    }

    /**
     * Initializes me with the editing domain, a label, and child operations.
     * 
     * @@param domain
     *            my editing domain
     * @@param label
     *            my user-readable label, should never be <code>null</code>.
     * @@param children
     *            a list of operations to compose
     */
    public CompositeTransactionalCommand(TransactionalEditingDomain domain,
            String label, List children) {
        super(domain, (label == null) ? StringStatics.BLANK : label, children);
    }

    /**
     * Initializes me with the editing domain, a label, and child operations,
     * and transaction options.
     * 
     * @@param domain
     *            my editing domain
     * @@param label
     *            my user-readable label, should never be <code>null</code>.
     * @@param children
     *            a list of operations to compose
     * @@param options
     *            for the transaction in which I execute myself, or
     *            <code>null</code> for the default options
     */
    public CompositeTransactionalCommand(TransactionalEditingDomain domain,
            String label, List children, Map options) {
        super(domain, (label == null) ? StringStatics.BLANK : label, children, options);
    }

    /**
     * Returns the {@@link IFile}s for resources that may be modified when the
     * operation is executed, undone or redone.
     */
    public List getAffectedFiles() {

        HashSet result = new HashSet();

        for (Iterator i = iterator(); i.hasNext();) {
            IUndoableOperation nextOperation = (IUndoableOperation) i.next();

            if (nextOperation instanceof ICommand) {
                List nextAffected = ((ICommand) nextOperation)
                    .getAffectedFiles();

                if (nextAffected != null) {
                    result.addAll(nextAffected);
                }
            }
        }
        return new ArrayList(result);
    }

    // Documentation copied from the interface
    public CommandResult getCommandResult() {
        return commandResult;
    }

    /**
     * Sets the command result.
     * 
     * @@param result
     *            the new result for this command.
     */
    protected void setResult(CommandResult result) {
        this.commandResult = result;
    }

    /**
     * Returns a list containing all of the return values from
     * <code>ICommand</code> children.
     */
    protected List getReturnValues() {

        List returnValues = new ArrayList();

        for (Iterator i = iterator(); i.hasNext();) {
            IUndoableOperation operation = (IUndoableOperation) i.next();

            if (operation instanceof ICommand) {
                ICommand command = (ICommand) operation;

                CommandResult result = command.getCommandResult();

                if (result != null) {
                    Object returnValue = result.getReturnValue();

                    if (returnValue != null) {

                        if (getClass().isInstance(command)) {
                            // unwrap the values from other composites
                            if (returnValue != null
                                && returnValue instanceof Collection) {
                                returnValues.addAll((Collection) returnValue);

                            } else {
                                returnValues.add(returnValue);
                            }

                        } else {
                            returnValues.add(returnValue);
                        }
                    }
                }
            }
        }

        return returnValues;
    }

    /**
     * Overrides the superclass implementation to set the command result.
     */
    protected IStatus aggregateStatuses(List statuses) {
        IStatus aggregate = super.aggregateStatuses(statuses);
        setResult(new CommandResult(aggregate, getReturnValues()));
        return aggregate;
    }

    // Documentation copied from the interface
    public final ICommand compose(IUndoableOperation operation) {

        if (operation != null) {
            add(operation);
        }
        return this;
    }

    /**
     * Returns the simplest form of this command that is equivalent. This is
     * useful for removing unnecessary nesting of commands.
     * <P>
     * If the composite has a single command, it returns the reduction of that
     * single command. Otherwise, it returns itself.
     * 
     * @@return the simplest form of this command that is equivalent
     */
    public ICommand reduce() {
        switch (size()) {
        case 0:
            return this;
        case 1:
            IUndoableOperation child = (IUndoableOperation) iterator()
                    .next();

            if (child instanceof ICommand &&
                    child instanceof AbstractEMFOperation) {
                // return the single command if is a kind of EMF operation;
                // otherwise this composite will be returned to preserve the
                // EMF transaction behaviour.
                return ((ICommand) child).reduce();
            }
        default:
            if (!isTransactionNestingEnabled()) {
                List children = getChildren();
                IUndoableOperation[] opChildren = (IUndoableOperation[]) children
                        .toArray(new IUndoableOperation[children.size()]);
                children.clear();
                for (int i = 0; i < opChildren.length; ++i) {
                    doReduce(opChildren[i], children);
                }
            }
        }
        return this;
    }

    private void doReduce(IUndoableOperation operation, List children) {
        if (operation instanceof CompositeEMFOperation) {
            for (Iterator i = ((CompositeEMFOperation) operation).iterator(); i.hasNext();) {
                doReduce((IUndoableOperation) i.next(), children);
            }
        } else {
            children.add(operation);
        }
    }

    /**
     * Answers whether or not this composite operation has children.
     * 
     * @@return <code>true</code> if the operation does not have children,
     *         <code>false</code> otherwise.
     */
    public final boolean isEmpty() {
        return size() < 1;
    }
    
    /**
     * I can execute if I am not empty and all of my children can execute.
     */
    public boolean canExecute() {
    	return !isEmpty() && super.canExecute();
    }
    
    /**
     * I can redo if I am not empty and all my children can all be redone.
     */
    public boolean canRedo() {
    	return !isEmpty() && super.canRedo();
    }
    
    /**
     * I can undo if I am not empty and all my children can all be undone.
     */
    public boolean canUndo() {
    	return !isEmpty() && super.canUndo();
    }
    
    /**
     * Internal method to set the command result.
     * 
     * @@param result CommandResult to set
     * @@deprecated internal API
     */
    public void internalSetResult(CommandResult result) {
        this.commandResult = result;
    }
}
@


1.8
log
@[224706] gmf-head ahunter 080403 IUndoableOperation changes in the platform cause AssertionFailedException
@
text
@d33 1
d66 1
a66 1
        super(domain, (label == null) ? "" : label);
d82 1
a82 1
        super(domain, (label == null) ? "" : label, options);
d97 1
a97 1
        super(domain, (label == null) ? "" : label, children);
d116 1
a116 1
        super(domain, (label == null) ? "" : label, children, options);
@


1.7
log
@[224706] gmf-head ahunter 080403 IUndoableOperation changes in the platform cause AssertionFailedException
@
text
@d90 1
a90 1
     *            my user-readable label, , should never be <code>null</code>.
d106 1
a106 1
     *            my user-readable label
d115 1
a115 1
        super(domain, label, children, options);
@


1.6
log
@[209709] gmf_head aboyko 071121 CompositeTransactionalCommand#reduce should flatten child commands if !isTransactionNestingEnabled()
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
d61 1
a61 1
     *            my user-readable label
d65 1
a65 1
        super(domain, label);
d74 1
a74 1
     *            my user-readable label
d81 1
a81 1
        super(domain, label, options);
d90 1
a90 1
     *            my user-readable label
d96 1
a96 1
        super(domain, label, children);
@


1.5
log
@[163131] gmf_head crevells 070208 Duplicate affected files in composite commands
@
text
@d227 4
a230 2
            case 1:
                IUndoableOperation child = (IUndoableOperation) iterator()
d233 15
a247 6
                if (child instanceof ICommand
                    && (child instanceof CompositeEMFOperation || child instanceof AbstractEMFOperation)) {
                    // return the single command if is a kind of EMF operation;
                    // otherwise this composite will be returned to preserve the
                    // EMF transaction behaviour.
                    return ((ICommand) child).reduce();
d249 1
d254 10
@


1.5.2.1
log
@[209708] gmf_R2_0_maintenance aboyko 071121 CompositeTransactionalCommand#reduce should flatten child commands if !isTransactionNestingEnabled()
@
text
@d227 2
a228 4
        case 0:
            return this;
        case 1:
            IUndoableOperation child = (IUndoableOperation) iterator()
d231 6
a236 15
            if (child instanceof ICommand &&
                    child instanceof AbstractEMFOperation) {
                // return the single command if is a kind of EMF operation;
                // otherwise this composite will be returned to preserve the
                // EMF transaction behaviour.
                return ((ICommand) child).reduce();
            }
        default:
            if (!isTransactionNestingEnabled()) {
                List children = getChildren();
                IUndoableOperation[] opChildren = (IUndoableOperation[]) children
                        .toArray(new IUndoableOperation[children.size()]);
                children.clear();
                for (int i = 0; i < opChildren.length; ++i) {
                    doReduce(opChildren[i], children);
a237 1
            }
a241 10
    private void doReduce(IUndoableOperation operation, List children) {
        if (operation instanceof CompositeEMFOperation) {
            for (Iterator i = ((CompositeEMFOperation) operation).iterator(); i.hasNext();) {
                doReduce((IUndoableOperation) i.next(), children);
            }
        } else {
            children.add(operation);
        }
    }

@


1.4
log
@[160541] gmf_head ahunter 061013 Merge 1.0.2 fix to HEAD
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2006 IBM Corporation and others.
d16 1
d124 1
a124 1
        List result = new ArrayList();
d138 1
a138 1
        return result;
@


1.3
log
@[133091] gmf_head ldamus 060411 canExecute() on CompositeCommand should return false if contains no children
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
d31 1
d49 1
a49 1
    implements ICompositeCommand {
d271 10
@


1.3.2.1
log
@[160541] gmf_R1_0_maintenance wdiu 061013 When commands are executed using DefaultOperationHistory, unapproved commands will not be executed and CommandResult including IStatus will not be set
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2006 IBM Corporation and others.
a30 1
import org.eclipse.gmf.runtime.common.core.internal.command.ICommandWithSettableResult;
d48 1
a48 1
    implements ICompositeCommand, ICommandWithSettableResult {
a269 10
    
    /**
     * Internal method to set the command result.
     * 
     * @@param result CommandResult to set
     * @@deprecated internal API
     */
    public void internalSetResult(CommandResult result) {
        this.commandResult = result;
    }
@


1.3.2.2
log
@[163131] gmf_R1_0_maintenance crevells 070208 Duplicate affected files in composite commands
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
a15 1
import java.util.HashSet;
d123 1
a123 1
        HashSet result = new HashSet();
d137 1
a137 1
        return new ArrayList(result);
@


1.2
log
@[112826] gmf_head ldamus 060327 Adopt Eclipse 3.1 Operation History Framework - removing deprecated API
@
text
@d249 21
@


1.1
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@a15 1
import java.util.Collections;
a19 1
import org.eclipse.core.commands.ExecutionException;
a23 2
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
a24 1
import org.eclipse.core.runtime.NullProgressMonitor;
a27 1
import org.eclipse.gmf.runtime.common.core.command.CMValidator;
a30 4
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;
import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
a248 130

    //
    // TODO LMDAMUS The following methods to be removed when deprecated API on ICommand
    // is removed. 
    // 

    /**
     * Returns the affected {@@link IFile}s.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #getAffectedFiles()} instead.
     */
    public Collection getAffectedObjects() {
        return Collections.EMPTY_LIST;
    }

    /**
     * Returns <code>null</code>.
     * 
     * @@deprecated File validation is now done through a
     *             {@@link IOperationApprover} registered with with the
     *             {@@link OperationHistoryFactory#getOperationHistory()}. No
     *             need to return a validator for backwards compatilibity.
     */
    public CMValidator getValidator() {
        return null;
    }

    /**
     * Returns <code>false</code>.
     * 
     * @@deprecated File validation is now done through a
     *             {@@link IOperationApprover} registered with with the
     *             {@@link OperationHistoryFactory#getOperationHistory()}. No
     *             need to calculate the answer for backwards compatilibity.
     */
    public boolean involvesReadOnlyNonWorkSpaceFiles() {
        return false;
    }

    /**
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canExecute()} instead.
     */
    public boolean isExecutable() {
        return canExecute();
    }

    /**
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canRedo()} instead.
     */
    public boolean isRedoable() {
        return canRedo();
    }

    /**
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canUndo()} instead.
     */
    public boolean isUndoable() {
        return canUndo();
    }

    /**
     * Delegates to {@@link #execute(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #execute(IProgressMonitor, IAdaptable)} instead.
     */
    public void execute(IProgressMonitor progressMonitor) {

        try {
            execute(progressMonitor, null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Delegates to {@@link #redo(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #redo(IProgressMonitor, IAdaptable)} instead.
     */
    public void redo() {
        try {
            redo(new NullProgressMonitor(), null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Delegates to {@@link #undo(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #undo(IProgressMonitor, IAdaptable)} instead.
     */
    public void undo() {
        try {
            undo(new NullProgressMonitor(), null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Handles the specified exception by logging, tracing and setting the
     * command result to an error.
     * 
     * @@param exception
     *            The exception to be handled.
     * @@deprecated Supports deprecated implementation
     */
    protected void handle(Exception exception) {
        Trace.catching(CommonCorePlugin.getDefault(),
                CommonCoreDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "handle", exception); //$NON-NLS-1$

        setResult(CommandResult.newErrorCommandResult(exception));

        Log.log(CommonCorePlugin.getDefault(), getCommandResult().getStatus());
    }
@

