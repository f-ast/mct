head	1.7;
access;
symbols
	v20081020-0700:1.7
	v20080722-1827:1.7
	v20080716-1600:1.7
	v20080716-1642:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080425-1959:1.7
	v20080402-1725:1.6
	v20080222-1200:1.5
	v20080114-2222:1.5
	v20071130-1111:1.5
	v20071124-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	RC3_20:1.5
	v20070601-1400:1.5
	v20070330-1300:1.5
	v20070221-1500:1.5
	v20070209-1900:1.4.2.1
	v20060209-1900:1.4.2.1
	M4_20:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061117-0800:1.5
	v20061020-1000:1.4.2.1
	v20061013-1330:1.4
	v20060925-1700:1.4
	v20060919-0800:1.4
	M1_20:1.4
	v20060713-1700:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060616-1200:1.4
	v20060531-1730:1.4
	v20060519-0800:1.4
	I20060505-1400:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.2
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1
	I20060216-1945:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.7
date	2008.04.25.18.39.54;	author ahunter;	state Exp;
branches;
next	1.6;
commitid	27984812257a4567;

1.6
date	2008.04.02.21.01.24;	author ahunter;	state Exp;
branches;
next	1.5;
commitid	136f47f3f4234567;

1.5
date	2006.10.13.21.44.23;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.18.15.58.34;	author ldamus;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2006.03.27.21.12.47;	author ldamus;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.23.22.05.24;	author vramaswamy;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.13.19.11.05;	author ldamus;	state Exp;
branches;
next	;

1.4.2.1
date	2006.10.13.21.33.53;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.7
log
@[228915] gmf-head ahunter 080425 Non-externalized string literal; it should be followed by //$NON-NLS-<n>
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.commands.core.command;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.operations.IOperationApprover;
import org.eclipse.core.commands.operations.IUndoableOperation;
import org.eclipse.core.commands.operations.OperationHistoryFactory;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.transaction.Transaction;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.CompositeChangeDescription;
import org.eclipse.emf.workspace.AbstractEMFOperation;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.internal.command.ICommandWithSettableResult;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;

/**
 * An abstract superclass for GMF {@@link IUndoableOperation}s that modify EMF
 * model resources.
 * <p>
 * The operation provides a list of {@@link IFile}s that are expected to be
 * modified when the operation is executed, undone or redone. An
 * {@@link IOperationApprover} is registered with the
 * {@@link OperationHistoryFactory#getOperationHistory()} to validate the
 * modification to these resources.
 * <p>
 * Subclasses must return the command execution result in their implementation
 * of {@@link #doExecuteWithResult(IProgressMonitor, IAdaptable)}.
 * <p>
 * This class is meant to be extended by clients.
 * 
 * @@author ldamus
 */
public abstract class AbstractTransactionalCommand
    extends AbstractEMFOperation
    implements ICommand, ICommandWithSettableResult {

    /**
     * Convenience method to get a list of workspaces files associated with
     * <code>eObject</code>.
     * 
     * @@param eObject
     *            the model object, may be <code>null</code>
     * @@return the list of {@@link IFile}s
     */
    protected static List getWorkspaceFiles(EObject eObject) {
        List result = new ArrayList();

        if (eObject != null) {
            Resource resource = eObject.eResource();
            
            if (resource != null) {
                IFile file = WorkspaceSynchronizer.getFile(resource);
    
                if (file != null) {
                    result.add(file);
                }
            }
        }

        return result;
    }

    /**
     * Convenience method to get a list of workspaces files associated with
     * {@@link EObject}s in <code>eObject</code>.
     * 
     * @@param eObjects
     *            the list of model object
     * @@return the list of {@@link IFile}s
     */
    protected static List getWorkspaceFiles(List eObjects) {
        List result = new ArrayList();

        for (Iterator i = eObjects.iterator(); i.hasNext();) {
            Object next = i.next();

            if (next instanceof EObject) {
                Resource resource = ((EObject) next).eResource();
                
                if (resource != null) {
                    IFile file = WorkspaceSynchronizer.getFile(resource);
    
                    if (file != null) {
                        result.add(file);
                    }
                }
            }
        }

        return result;
    }

    private final List affectedFiles;

    private CommandResult commandResult;

    /**
     * Initializes me with the editing domain in which I am making model
     * changes, a label, and a list of {@@link IFile}s that I anticipate
     * modifying when I am executed, undone or redone.
     * 
     * @@param domain
     *            my editing domain
     * @@param label
     *            my user-readable label, should never be <code>null</code>.
     * @@param affectedFiles
     *            the list of affected {@@link IFile}s; may be <code>null</code>
     */
    public AbstractTransactionalCommand(TransactionalEditingDomain domain,
            String label, List affectedFiles) {
        this(domain, label, null, affectedFiles);
    }

    /**
     * Initializes me with the editing domain, a label, transaction options, and
     * a list of {@@link IFile}s that anticipate modifying when I am executed,
     * undone or redone.
     * 
     * @@param domain
     *            my editing domain
     * @@param label
     *            my user-readable label, should never be <code>null</code>.
     * @@param options
     *            for the transaction in which I execute myself, or
     *            <code>null</code> for the default options
     * @@param affectedFiles
     *            the list of affected {@@link IFile}s; may be <code>null</code>
     */
    public AbstractTransactionalCommand(TransactionalEditingDomain domain,
            String label, Map options, List affectedFiles) {
        super(domain, (label == null) ? StringStatics.BLANK : label, options);

        if (affectedFiles == null) {
            this.affectedFiles = new ArrayList();

        } else {
            this.affectedFiles = affectedFiles;
        }
    }

    /**
     * Returns the {@@link IFile}s for resources that may be modified when the
     * operation is executed, undone or redone.
     */
    public List getAffectedFiles() {
        return affectedFiles;
    }

    // Documentation copied from the interface
    public final CommandResult getCommandResult() {
        return commandResult;
    }

    /**
     * Sets the command result.
     * 
     * @@param result
     *            the new result for this command.
     */
    protected final void setResult(CommandResult result) {
        this.commandResult = result;
    }

    // Documentation copied from the interface
    public ICommand compose(IUndoableOperation operation) {

        if (operation != null) {

            return new CompositeTransactionalCommand(getEditingDomain(), getLabel())
                .compose(this).compose(operation);
        }
        return this;
    }

    // Documentation copied from the interface
    public ICommand reduce() {
        return this;
    }

    /**
     * Implemented by subclasses to perform the model changes.  These changes
     * are applied by manipulation of the EMF metamodel's API, <em>not</em>
     * by executing commands on the editing domain's command stack.
     * 
     * @@param monitor the progress monitor provided by the operation history
     * @@param info the adaptable provided by the operation history
     * 
     * @@return the result of the execution
     * 
     * @@throws ExecutionException if, for some reason, I fail to complete
     *     the operation
     */
    protected abstract CommandResult doExecuteWithResult(
            IProgressMonitor monitor, IAdaptable info)
        throws ExecutionException;

    protected void didUndo(Transaction tx) {
    	// We will amalgamate any change description that were added by the DiagramEditingDomain's
    	//  special post-commit listener. See DiagramEditingDomainFactory for more details.
    	if (tx.getChangeDescription() != null && !tx.getChangeDescription().isEmpty()) {
    		((CompositeChangeDescription)getChange()).add(tx.getChangeDescription());
    	}
    }
    
    protected void didRedo(Transaction tx) {
    	// We will amalgamate any change description that were added by the DiagramEditingDomain's
    	//  special post-commit listener. See DiagramEditingDomainFactory for more details.
    	if (tx.getChangeDescription() != null && !tx.getChangeDescription().isEmpty()) {
    		((CompositeChangeDescription)getChange()).add(tx.getChangeDescription());
    	}
    }
    
    /**
     * Delegates to {@@link #doExecuteWithResult(IProgressMonitor, IAdaptable)}
     * to perform the model changes. Sets the command result and calls
     * {@@link #cleanup()} to give subclasses a chance to dispose of any objects
     * that were required for the execution but will not be required for undo or
     * redo.
     */
    protected IStatus doExecute(IProgressMonitor monitor, IAdaptable info)
        throws ExecutionException {

        CommandResult result = doExecuteWithResult(monitor, info);
        setResult(result);
        cleanup();
        return result != null ? result.getStatus()
            : Status.OK_STATUS;
    }

    /**
     * Overrides superclass to set the command result.
     */
    protected IStatus doUndo(IProgressMonitor monitor, IAdaptable info)
        throws ExecutionException {

        IStatus status = super.doUndo(monitor, info);
        CommandResult result = new CommandResult(status);
        setResult(result);

        return status;
    }

    /**
     * Overrides superclass to set the command result.
     */
    protected IStatus doRedo(IProgressMonitor monitor, IAdaptable info)
        throws ExecutionException {

        IStatus status = super.doRedo(monitor, info);
        CommandResult result = new CommandResult(status);
        setResult(result);

        return status;
    }
    
    /**
	 * Considers that the aggregate status may be different from the present
	 * status, and updates the command result accordingly.
	 */
    protected IStatus aggregateStatuses(List statuses) {

		IStatus status = super.aggregateStatuses(statuses);
		CommandResult result = getCommandResult();

		if (result == null) {
			result = new CommandResult(status);
			setResult(result);
			
		} else if (status != result.getStatus()) {
			result = new CommandResult(status, result.getReturnValue());
			setResult(result);
		}

		return status;
	}

    /**
	 * Subclasses may implement this method to dispose of objects that were
	 * required for execution, but are no longer require to undo or redo this
	 * operation.
	 * <P>
	 * This method is invoked at the end of
	 * {@@link #doExecute(IProgressMonitor, IAdaptable)}.
	 */
    protected void cleanup() {
        // subclasses can use this to cleanup
    }
    
    /**
     * Internal method to set the command result.
     * 
     * @@param result CommandResult to set
     * @@deprecated internal API
     */
    public void internalSetResult(CommandResult result) {
        this.commandResult = result;
    }
}
@


1.6
log
@[224706] gmf-head ahunter 080402 IUndoableOperation changes in the platform cause AssertionFailedException
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2006 IBM Corporation and others.
d38 1
d155 1
a155 1
        super(domain, (label == null) ? "" : label, options);
@


1.5
log
@[160541] gmf_head ahunter 061013 Merge 1.0.2 fix to HEAD
@
text
@d128 1
a128 1
     *            my user-readable label
d145 1
a145 1
     *            my user-readable label
d154 1
a154 1
        super(domain, label, options);
@


1.4
log
@[142025] gmf_head ldamus 060518 AbstractTransactionalCommand doesn't provide the correct CommandResult when precommit listeners fail
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
d37 1
d58 1
a58 1
    implements ICommand {
d311 10
@


1.4.2.1
log
@[160541] gmf_R1_0_maintenance wdiu 061013 When commands are executed using DefaultOperationHistory, unapproved commands will not be executed and CommandResult including IStatus will not be set
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2006 IBM Corporation and others.
a36 1
import org.eclipse.gmf.runtime.common.core.internal.command.ICommandWithSettableResult;
d57 1
a57 1
    implements ICommand, ICommandWithSettableResult {
a309 10
    
    /**
     * Internal method to set the command result.
     * 
     * @@param result CommandResult to set
     * @@deprecated internal API
     */
    public void internalSetResult(CommandResult result) {
        this.commandResult = result;
    }
@


1.3
log
@[112826] gmf_head ldamus 060327 Adopt Eclipse 3.1 Operation History Framework - removing deprecated API
@
text
@d277 21
d300 7
a306 7
     * Subclasses may implement this method to dispose of objects that were
     * required for execution, but are no longer require to undo or redo this
     * operation.
     * <P>
     * This method is invoked at the end of
     * {@@link #doExecute(IProgressMonitor, IAdaptable)}.
     */
@


1.2
log
@[132367] gmf_head cmcgee 060323 Provide specialized post commit listener that can open a write transaction
@
text
@a14 2
import java.util.Collection;
import java.util.Collections;
a26 1
import org.eclipse.core.runtime.NullProgressMonitor;
a34 1
import org.eclipse.gmf.runtime.common.core.command.CMValidator;
a36 4
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;
import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
a288 131
    
    //
    // TODO LMDAMUS The following methods to be removed when deprecated API on ICommand
    // is removed. 
    // 

    /**
     * Returns the affected {@@link IFile}s.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #getAffectedFiles()} instead.
     */
    public Collection getAffectedObjects() {
        return Collections.EMPTY_LIST;
    }

    /**
     * Returns <code>null</code>.
     * 
     * @@deprecated File validation is now done through a
     *             {@@link IOperationApprover} registered with with the
     *             {@@link OperationHistoryFactory#getOperationHistory()}. No
     *             need to return a validator for backwards compatilibity.
     */
    public CMValidator getValidator() {
        return null;
    }

    /**
     * Returns <code>false</code>.
     * 
     * @@deprecated File validation is now done through a
     *             {@@link IOperationApprover} registered with with the
     *             {@@link OperationHistoryFactory#getOperationHistory()}. No
     *             need to calculate the answer for backwards compatilibity.
     */
    public boolean involvesReadOnlyNonWorkSpaceFiles() {
        return false;
    }

    /**
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canExecute()} instead.
     */
    public boolean isExecutable() {
        return canExecute();
    }

    /**
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canRedo()} instead.
     */
    public boolean isRedoable() {
        return canRedo();
    }

    /**
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canUndo()} instead.
     */
    public boolean isUndoable() {
        return canUndo();
    }

    /**
     * Delegates to {@@link #execute(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #execute(IProgressMonitor, IAdaptable)} instead.
     */
    public void execute(IProgressMonitor progressMonitor) {

        try {
            execute(progressMonitor, null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Delegates to {@@link #redo(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #redo(IProgressMonitor, IAdaptable)} instead.
     */
    public void redo() {
        try {
            redo(new NullProgressMonitor(), null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Delegates to {@@link #undo(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #undo(IProgressMonitor, IAdaptable)} instead.
     */
    public void undo() {
        try {
            undo(new NullProgressMonitor(), null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Handles the specified exception by logging, tracing and setting the
     * command result to an error.
     * 
     * @@param exception
     *            The exception to be handled.
     * @@deprecated Supports deprecated implementation
     */
    protected void handle(Exception exception) {
        Trace.catching(CommonCorePlugin.getDefault(),
                CommonCoreDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "handle", exception); //$NON-NLS-1$

        setResult(CommandResult.newErrorCommandResult(exception));

        Log.log(CommonCorePlugin.getDefault(), getCommandResult().getStatus());
    }

@


1.1
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d33 1
d35 1
d227 16
@

