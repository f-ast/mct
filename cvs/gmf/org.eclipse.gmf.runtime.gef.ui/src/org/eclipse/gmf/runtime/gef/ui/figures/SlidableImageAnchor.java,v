head	1.6;
access;
symbols
	v20081020-0700:1.6
	v20080813-1510:1.6
	v20080811-1546:1.6
	v20080722-1827:1.6
	R2_1_maintenance:1.6.0.2
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080503-1740:1.6
	v20080425-1959:1.6
	v20080328-1605:1.6
	v20080222-1200:1.6
	v20080114-1111:1.6
	v20080107-1111:1.5
	v20071222-1111:1.3
	v20071214-1111:1.3
	v20071130-1111:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.4
	R2_0:1.3
	R4_20:1.3
	RC3_20:1.3
	v20070601-1400:1.3
	v20070330-1300:1.3
	M4_20:1.3
	v20061214-0000:1.3
	M3_20:1.3
	v20061013-1330:1.3
	v20060919-0800:1.3
	v20060907-1100:1.3
	M1_20:1.3
	v20060721-1130:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1200:1.3
	v20060531-1730:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.3
	I20060216-1945:1.3
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051208-2000:1.3
	I20051201-1800:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.6
date	2008.01.10.23.02.29;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	6a7b4786a4054567;

1.5
date	2008.01.03.17.43.00;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	328e477d1ea34567;

1.4
date	2008.01.02.20.07.00;	author aboyko;	state Exp;
branches;
next	1.3;
commitid	5aa3477beee34567;

1.3
date	2005.11.09.18.23.51;	author mmostafa;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.27.28;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.45;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Commit back [194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.gef.ui.figures;

import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;

import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.ImageFigure;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.Ray;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;

/**
 * Implements sliding connection anchor functionality for Image figures
 * 
 * @@author aboyko
 *
 */
public class SlidableImageAnchor
	extends SlidableAnchor {

	static private class ImageAnchorLocation {

		static private Map<Image, ImageAnchorLocation> imageAnchorLocationMap = new WeakHashMap<Image, ImageAnchorLocation>();

		/**
		 * getInstance Static method for returning an instance of the
		 * ImageAnchorLocation object corresponding to the given Image.
		 * 
		 * @@param image
		 *            Image to determine anchor location for
		 * @@return ImageAnchorLocation containing cached information about
		 *         anchor
		 */
		static ImageAnchorLocation getInstance(Image image) {
			ImageAnchorLocation imgAnchorLoc = imageAnchorLocationMap
				.get(image);
			if (imgAnchorLoc == null) {
				imgAnchorLoc = new ImageAnchorLocation(image);
				imageAnchorLocationMap.put(image, imgAnchorLoc);
			}

			return imgAnchorLoc;
		}

		private Map<Integer, Point> locationMap = new HashMap<Integer, Point>();

		private ImageData imgData = null;

		private ImageData transMaskData = null;

		private ImageAnchorLocation(Image img) {
			imgData = img.getImageData();
			transMaskData = imgData.getTransparencyMask();
		}

		/**
		 * @@return Returns the imgData.
		 */
		protected ImageData getImageData() {
			return imgData;
		}

		/**
		 * @@return Returns the transMaskData.
		 */
		protected ImageData getTransparencyMaskData() {
			return transMaskData;
		}

		/**
		 * isTransparentAt Accessor to determine if the image is transparent at
		 * a given point.
		 * 
		 * @@param x
		 *            int location into the image
		 * @@param y
		 *            int location into the image
		 * @@param checkAdjacent
		 *            check adjacent pixels for transparency as well.
		 * @@return boolean true if transparent, false otherwise.
		 */
		protected boolean isTransparentAt(int x, int y, boolean checkAdjacent) {
			// boundary checking
			if (x < 0 || x >= getImageData().width || y < 0
				|| y >= getImageData().height)
				return true;

			// check for alpha channel
			int transValue = 255;
			// check for transparency mask
			if (getTransparencyMaskData() != null) {
				transValue = getTransparencyMaskData().getPixel(x, y) == 0 ? 0
					: 255;
			}

			if (transValue != 0) {
				if (getImageData().alphaData != null) {
					transValue = getImageData().getAlpha(x, y);
				}
			}

			// use a tolerance
			boolean trans = false;
			if (transValue < 10) {
				trans = true;

				if (checkAdjacent) {
					trans &= isTransparentAt(x + 1, y, false);
					trans &= isTransparentAt(x + 1, y + 1, false);
					trans &= isTransparentAt(x + 1, y - 1, false);
					trans &= isTransparentAt(x - 1, y + 1, false);
					trans &= isTransparentAt(x - 1, y, false);
					trans &= isTransparentAt(x - 1, y - 1, false);
					trans &= isTransparentAt(x, y + 1, false);
					trans &= isTransparentAt(x, y - 1, false);
				}
			}

			return trans;
		}

		/**
		 * getLocation Delegation function used by the ConnectionAnchor
		 * getLocation
		 * 
		 * @@param start the <code>Point</code> that is the beginning of a line segment used to 
		 * calculate the anchor location inside the image.
		 * @@param edge the <code>Point</code> that is the end of a line segment used to 
		 * calculate the anchor location inside the image.
		 * @@param isDefaultAnchor - true if location for the default anchor should be calculated
		 * @@return Point representing the location inside the image to anchor
		 *         to.
		 */
		private Point getLocation(Point start, Point edge, Rectangle containerRect, boolean isDefaultAnchor) {

			int angle = calculateAngleOfEntry(start, edge);
			Point top = containerRect.getTopLeft();
			
			Point ptIntersect = null;
			
			// Default anchors are cached
			if (isDefaultAnchor) {
				// determine if a cached value exists
				ptIntersect = locationMap.get(new Integer(angle));
			}
			if (ptIntersect == null) {
				// if no cached value exists return the calculated value and add to
				// the map
				Dimension dim = edge.getDifference(top);
				Point edgeImg = new Point(Math.max(0, Math.min(dim.width,
					getImageData().width - 1)), Math.max(0, Math.min(dim.height,
					getImageData().height - 1)));
				Dimension startDim = start.getDifference(top);
				Point startImg = new Point(Math.max(0, Math.min(startDim.width,
					getImageData().width - 1)), Math.max(0, Math.min(
					startDim.height, getImageData().height - 1)));
				ptIntersect = calculateIntersection(startImg, edgeImg);
				if (ptIntersect == null)
					return null;
				if (isDefaultAnchor) {
					locationMap.put(new Integer(angle), ptIntersect);
				}
			}
			return ptIntersect.getTranslated(top.x, top.y);
		}

		/**
		 * calculateAngleOfEntry Utility method to calculate the angle of entry
		 * 
		 * @@param start
		 * @@param edge
		 * @@return int angle in degrees rounded to 15% for use as a key to a
		 *         map.
		 */
		private int calculateAngleOfEntry(Point start, Point edge) {
			LineSeg lineSeg = new LineSeg(start, edge);
			Ray ray = new Ray(lineSeg.getOrigin(), new Point(lineSeg
				.getOrigin().x + 1, lineSeg.getOrigin().y));

			double angle = 0.0;
			LineSeg.TrigValues trig = lineSeg.getTrigValues(ray);
			if (trig != null)
				angle = Math.atan2(-trig.sinTheta, -trig.cosTheta) + Math.PI;

			int keyAngle = (int) Math.round(angle * 360 / (Math.PI * 2));
			return keyAngle - (keyAngle % 10);
		}

		/**
		 * calculateIntersection Utility method to calculate the intersection
		 * point of a given point at an angle into the image to find the first
		 * opaque pixel.
		 * 
		 * @@param start
		 *            Point that is in the center of the Image.
		 * @@param edge
		 *            Point that is on the edge of the Image.
		 * @@return Point that is the intersection with the first opaque pixel.
		 */
		private Point calculateIntersection(Point start, Point edge) {
			Point opaque = new Point(edge);

			LineSeg line = new LineSeg(start, edge);
			long distance = Math.round(line.length());

			// otherwise calculate value
			while (opaque.x >= 0 && opaque.x < getImageData().width
				&& opaque.y >= 0 && opaque.y < getImageData().height) {

				if (!isTransparentAt(opaque.x, opaque.y, true)) {
					return opaque;
				}

				line.pointOn(distance, LineSeg.KeyPoint.ORIGIN, opaque);
				distance--;
			}

			// default is to fall through and return the chopbox point
			return null;
		}
	}

	private ImageFigure imageFig;

	/**
	 * Empty constructor
	 */
	public SlidableImageAnchor() {
		super();
	}

	/**
	 * Dumb default constructor, for which reference point is at the center of the figure
	 * @@param f the <code>IFigure</code> bounding figure
	 */
	public SlidableImageAnchor(IFigure f) {
		super(f);
	}

	/**
	 * Default constructor, for which reference point is at the cneter of the figure
	 * 
	 * @@param container the <code>IFigure</code> bounding figure
	 * @@param imageFig the <code>ImageFigure</code> inside the bounding figure
	 */
	public SlidableImageAnchor(IFigure container, ImageFigure imageFig) {
		super(container);
		this.imageFig = imageFig;
	}

	/**
	 * Constructor, for which reference point is specified
	 * 
	 * @@param f the <code>IFigure</code> bounding figure
	 * @@param imageFig the <code>ImageFigure</code> inside the bounding figure
	 * @@param p the <code>PrecisionPoint</code> relative reference
	 */
	public SlidableImageAnchor(IFigure f, ImageFigure imageFig, PrecisionPoint p) {
		super(f, p);
		this.imageFig = imageFig;
	}

	/**
	 * Returns the image.
	 * 
	 * @@return the <code>Image</code> object
	 */
	protected Image getImage() {
		return imageFig.getImage();
	}
	
	/**
	 * Returns bounds of the figure.
	 * 
	 * @@return the owner figure
	 */
	protected IFigure getContainer() {
		return getOwner();
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.draw2d.ui.figures.BaseSlidableAnchor#getLocation(org.eclipse.draw2d.geometry.Point, org.eclipse.draw2d.geometry.Point)
	 */
	protected Point getLocation(Point ownReference, Point foreignReference) {
		Image image = getImage();
		if (image == null)
			return super.getLocation(ownReference, foreignReference);
		Rectangle ownerRect = getBox();
		PointList intersections = getIntersectionPoints(ownReference,
				foreignReference);
		if (intersections != null && intersections.size() != 0) {
			Point ptRef = PointListUtilities.pickFarestPoint(intersections,
					foreignReference);
			Point ptEdge = PointListUtilities.pickClosestPoint(intersections,
					foreignReference);
			Point location = ImageAnchorLocation.getInstance(getImage())
					.getLocation(ptRef, ptEdge, ownerRect,
							getReferencePoint().equals(ownReference) && isDefaultAnchor());
			if (location != null) {
				location = normalizeToStraightlineTolerance(foreignReference,
						location, 3);
			}
			return location;
		}
		return null;
	}

}
@


1.5
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
d26 2
a30 3
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

d32 3
a34 1
 * @@author oboyko
a35 1
 * Window - Preferences - Java - Code Style - Code Templates
d42 1
a42 1
		static private Map imageAnchorLocationMap = new WeakHashMap();
d54 1
a54 1
			ImageAnchorLocation imgAnchorLoc = (ImageAnchorLocation) imageAnchorLocationMap
d64 1
a64 1
		private Map locationMap = new HashMap();
d163 1
a163 1
				ptIntersect = (Point) locationMap.get(new Integer(angle));
d300 2
a301 3
	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.gef.ui.figures.SlidableAnchor#getLocation(org.eclipse.draw2d.geometry.Point, org.eclipse.draw2d.geometry.Point)
d305 18
a322 11
		if (image==null)
			return super.getLocation(ownReference,foreignReference);
		Rectangle ownerRect = new Rectangle(getBox());
		PointList intersections = getIntersectionPoints(ownReference, foreignReference);
		if (intersections!=null && intersections.size()!=0) {
			Point ptRef = PointListUtilities.pickFarestPoint(intersections, foreignReference);
			Point ptEdge = PointListUtilities.pickClosestPoint(intersections,foreignReference);
			Point loc = ImageAnchorLocation.getInstance(getImage()).getLocation(ptRef, ptEdge, ownerRect, isDefaultAnchor());
			if (loc != null)
				loc = normalizeToStraightlineTolerance(foreignReference, loc, 3);
			return loc;
d326 1
@


1.4
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2007 IBM Corporation and others.
d26 3
a30 2
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
d33 1
a33 3
 * Implements sliding connection anchor functionality for Image figures
 * 
 * @@author aboyko
d35 1
d42 1
a42 1
		static private Map<Image, ImageAnchorLocation> imageAnchorLocationMap = new WeakHashMap<Image, ImageAnchorLocation>();
d54 1
a54 1
			ImageAnchorLocation imgAnchorLoc = imageAnchorLocationMap
d64 1
a64 1
		private Map<Integer, Point> locationMap = new HashMap<Integer, Point>();
d163 1
a163 1
				ptIntersect = locationMap.get(new Integer(angle));
d300 3
a302 2
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.draw2d.ui.figures.BaseSlidableAnchor#getLocation(org.eclipse.draw2d.geometry.Point, org.eclipse.draw2d.geometry.Point)
d306 11
a316 18
		if (image == null)
			return super.getLocation(ownReference, foreignReference);
		Rectangle ownerRect = getBox();
		PointList intersections = getIntersectionPoints(ownReference,
				foreignReference);
		if (intersections != null && intersections.size() != 0) {
			Point ptRef = PointListUtilities.pickFarestPoint(intersections,
					foreignReference);
			Point ptEdge = PointListUtilities.pickClosestPoint(intersections,
					foreignReference);
			Point location = ImageAnchorLocation.getInstance(getImage())
					.getLocation(ptRef, ptEdge, ownerRect,
							getReferencePoint().equals(ownReference) && isDefaultAnchor());
			if (location != null) {
				location = normalizeToStraightlineTolerance(foreignReference,
						location, 3);
			}
			return location;
a319 1

@


1.3
log
@bugzilla 115644 : gmf-head mmostafa 051109 : Null pointer exception while trying to open a diagram using Sun VM
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
d26 2
a30 3
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

d32 3
a34 1
 * @@author oboyko
a35 1
 * Window - Preferences - Java - Code Style - Code Templates
d42 1
a42 1
		static private Map imageAnchorLocationMap = new WeakHashMap();
d54 1
a54 1
			ImageAnchorLocation imgAnchorLoc = (ImageAnchorLocation) imageAnchorLocationMap
d64 1
a64 1
		private Map locationMap = new HashMap();
d163 1
a163 1
				ptIntersect = (Point) locationMap.get(new Integer(angle));
d300 2
a301 3
	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.gef.ui.figures.SlidableAnchor#getLocation(org.eclipse.draw2d.geometry.Point, org.eclipse.draw2d.geometry.Point)
d305 18
a322 11
		if (image==null)
			return super.getLocation(ownReference,foreignReference);
		Rectangle ownerRect = new Rectangle(getBox());
		PointList intersections = getIntersectionPoints(ownReference, foreignReference);
		if (intersections!=null && intersections.size()!=0) {
			Point ptRef = PointListUtilities.pickFarestPoint(intersections, foreignReference);
			Point ptEdge = PointListUtilities.pickClosestPoint(intersections,foreignReference);
			Point loc = ImageAnchorLocation.getInstance(getImage()).getLocation(ptRef, ptEdge, ownerRect, isDefaultAnchor());
			if (loc != null)
				loc = normalizeToStraightlineTolerance(foreignReference, loc, 3);
			return loc;
d326 1
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d305 3
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

