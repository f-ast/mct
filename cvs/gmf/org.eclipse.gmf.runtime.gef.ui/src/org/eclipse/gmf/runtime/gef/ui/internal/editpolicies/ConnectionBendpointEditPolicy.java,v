head	1.8;
access;
symbols
	v20081020-0700:1.8
	v20080813-1510:1.8
	v20080811-1546:1.8
	v20080722-1827:1.8
	R2_1_maintenance:1.8.0.2
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080503-1740:1.8
	v20080425-1959:1.8
	v20080328-1605:1.8
	v20080222-1200:1.8
	v20080114-1111:1.8
	v20080107-1111:1.7
	v20071222-1111:1.5
	v20071214-1111:1.5
	v20071130-1111:1.5
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	RC3_20:1.4
	v20070601-1400:1.4
	v20070330-1300:1.4
	M4_20:1.4
	v20061214-0000:1.4
	M3_20:1.4
	v20061013-1330:1.4
	v20060919-0800:1.3.2.2
	v20060907-1100:1.3.2.2
	M1_20:1.3
	v20060721-1130:1.3.2.1
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1200:1.3
	v20060531-1730:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.3
	I20060216-1945:1.3
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051208-2000:1.2
	I20051201-1800:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2008.01.10.23.02.29;	author aboyko;	state Exp;
branches;
next	1.7;
commitid	6a7b4786a4054567;

1.7
date	2008.01.03.17.43.00;	author aboyko;	state Exp;
branches;
next	1.6;
commitid	328e477d1ea34567;

1.6
date	2008.01.02.20.07.00;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	5aa3477beee34567;

1.5
date	2007.11.23.14.11.41;	author crevells;	state Exp;
branches;
next	1.4;
commitid	9214746df9d4567;

1.4
date	2006.10.03.15.06.36;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.12.15.47.57;	author sshaw;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2005.11.08.16.02.39;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.04.22.13.19;	author sshaw;	state Exp;
branches;
next	;

1.3.2.1
date	2006.07.17.19.47.58;	author ahunter;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2006.09.05.15.52.25;	author cmahoney;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Commit back [194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.gef.ui.internal.editpolicies;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.runtime.Assert;
import org.eclipse.draw2d.AbsoluteBendpoint;
import org.eclipse.draw2d.AutomaticRouter;
import org.eclipse.draw2d.Bendpoint;
import org.eclipse.draw2d.BendpointLocator;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.PrecisionRectangle;
import org.eclipse.gef.AccessibleHandleProvider;
import org.eclipse.gef.ConnectionEditPart;
import org.eclipse.gef.EditPart;
import org.eclipse.gef.Request;
import org.eclipse.gef.commands.Command;
import org.eclipse.gef.editpolicies.SelectionHandlesEditPolicy;
import org.eclipse.gef.handles.BendpointCreationHandle;
import org.eclipse.gef.handles.BendpointMoveHandle;
import org.eclipse.gef.requests.BendpointRequest;
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.FeedbackConnection;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
import org.eclipse.gmf.runtime.gef.ui.internal.handles.BendpointCreationInvisibleHandle;
import org.eclipse.gmf.runtime.gef.ui.internal.handles.BendpointMoveHandleEx;
import org.eclipse.gmf.runtime.gef.ui.internal.handles.LineSegMoveInvisibleHandle;

/**
 * This EditPolicy defines the behavior of Bendpoints on a Connection.
 */
/*
 * @@canBeSeenBy org.eclipse.gmf.runtime.gef.ui.*
 */
abstract public class ConnectionBendpointEditPolicy
	extends SelectionHandlesEditPolicy
	implements PropertyChangeListener {

	private static List NULL_CONSTRAINT = new ArrayList();
	private static final int STICKY_TOLERANCE_DP = 6;

	private LineMode lineSegMode = LineMode.OBLIQUE;
	
	static private class FeedbackState {
		public List originalConstraint;
		public Point ref1 = new Point();
		public Point ref2 = new Point();
		public boolean isDeleting = false;
		public boolean isOutsideSource = false;
		public boolean isOutsideTarget = false;
		public boolean init = false;
	}
	
	private FeedbackState feedbackState = null;
	
	private FeedbackState getFeedbackState() {
		if (feedbackState == null) {
			feedbackState = new FeedbackState();
		}
		
		return feedbackState;
	}
	
	private boolean useRealtimeFeedback() {
		return false;
	}
	
	/**
	 * Constructor for EditPolicy
	 * @@param lineSegMode
	 */
	public ConnectionBendpointEditPolicy(LineMode lineSegMode) {
		super();
		this.lineSegMode = lineSegMode;
	}

	/**
	 * @@return Returns the lineSegMode.
	 */
	public LineMode getLineSegMode() {
		return lineSegMode;
	}

	/** 
	 * Adds a PropertyChangeListener to the Connection so we can react
	 * to point changes in the connection.  
	 *
	 * @@see SelectionHandlesEditPolicy#activate()
	 */
	public void activate() {
		super.activate();
		getConnection().addPropertyChangeListener(
			Connection.PROPERTY_POINTS,
			this);
	}

	/**
	 * @@return <code>Connection</code> representing drag source feedback
	 */
	protected Connection createDragSourceFeedbackConnection() {
		if (useRealtimeFeedback()) {
			// Use the actual figure for feedback
			return getConnection();
		} else {
			// Use a ghost rectangle for feedback
			FeedbackConnection r = new FeedbackConnection(getConnection());
			addFeedback(r);
			return r;
		}
	}

	/**
	 * Adds selection handles to the connection for the bendpoints.  In this class,
	 * this method just decides if it is appropriate to add the handles, and then
	 * calls on the superclass to do the dirty work.s
	 */
	protected void addSelectionHandles() {
		if (handles == null)
			super.addSelectionHandles();
		else {
			int count = handles.size();
			int points = getConnection().getPoints().size();
			if (count != points * 2 - 3)
				super.addSelectionHandles();
		}
	}

	/**
	 * @@return list of manual handles
	 */
	protected List createManualHandles() {
		List list = new ArrayList();
		ConnectionEditPart connEP = (ConnectionEditPart) getHost();
		PointList points = getConnection().getPoints();
		for (int i = 1; i < points.size() - 1; i++) {
			addInvisibleCreationHandle(list, connEP, i - 1);
			list.add(
				new BendpointMoveHandleEx(
					connEP,
					i,
					new BendpointLocator(getConnection(), i)));
		}		
		addInvisibleCreationHandle(list, connEP, points.size() - 2);
		return list;
	}

	/**
	 * Method addInvisibleCreationHandle.
	 * This handle is necessary for the accessibility feature to allow keyboard navigation to
	 * the add bendpoint feature.
	 * @@param list
	 * @@param connEP
	 * @@param i
	 */
	protected void addInvisibleCreationHandle(
		List list,
		ConnectionEditPart connEP,
		int i) {
		if (getLineSegMode() != LineMode.OBLIQUE) {
			list.add(new LineSegMoveInvisibleHandle(connEP, i));
		} else {
			list.add(new BendpointCreationInvisibleHandle(connEP, i));
		}
	}

	/**
	 * Creates selection handles for the bendpoints.  Explicit (user-defined)
	 * bendpoints will have {@@link BendpointMoveHandle}s on them with a single 
	 * {@@link BendpointCreationHandle} between 2 consecutive explicit bendpoints.
	 * If implicit bendpoints (such as those created by the {@@link AutomaticRouter})
	 * are used, one {@@link BendpointCreationHandle} is placed in the middle
	 * of the Connection.
	 */
	protected List createSelectionHandles() {
		List list = new ArrayList();
		list = createManualHandles();
		return list;
	}

	/**
	 * Removes this from the Connection's list of PropertyChangeListeners.
	 *
	 * @@see SelectionHandlesEditPolicy#deactivate()
	 */
	public void deactivate() {
		getConnection().removePropertyChangeListener(
			Connection.PROPERTY_POINTS,
			this);

		super.deactivate();
	}

	/**
	 * Erases bendpoint feedback.  Since the original figure is used
	 * for feedback, we just restore the original constraint that
	 * was saved before feedback started to show.
	 */
	protected void eraseConnectionFeedback(
		BendpointRequest request,
		boolean removeFeedbackFigure) {
		restoreOriginalConstraint();
		getFeedbackState().originalConstraint = null;
		if (removeFeedbackFigure)
			feedbackState = null;
	}

	/**
	 * Erases feedback, when appropriate.
	 *
	 * @@see #eraseConnectionFeedback(BendpointRequest, boolean)
	 */
	public void eraseSourceFeedback(Request request) {
		if (REQ_MOVE_BENDPOINT.equals(request.getType())
			|| REQ_CREATE_BENDPOINT.equals(request.getType()))
			eraseConnectionFeedback((BendpointRequest) request, true);
	}

	/**
	 * Returns the appropriate Command for the request type given.  Handles
	 * creating, moving and deleting bendpoints.  The actual creation of the
	 * command is taken care of by subclasses implementing the appropriate
	 * methods.
	 *
	 * @@see #getCreateBendpointCommand(BendpointRequest)
	 * @@see #getMoveBendpointCommand(BendpointRequest)
	 * @@see #getDeleteBendpointCommand(BendpointRequest)
	 */
	public Command getCommand(Request request) {
		if (REQ_MOVE_BENDPOINT.equals(request.getType())) {
			if (getLineSegMode() != LineMode.OBLIQUE) {
				return getMoveLineSegCommand((BendpointRequest) request);
			} else {
				if (getFeedbackState().isDeleting)
					return getDeleteBendpointCommand(
						(BendpointRequest) request);
				return getMoveBendpointCommand((BendpointRequest) request);
			}
		}
		if (REQ_CREATE_BENDPOINT.equals(request.getType()))
			return getCreateBendpointCommand((BendpointRequest) request);

		return null;
	}

	/**
	 * Returns the Connection associated with this EditPolicy.
	 */
	protected Connection getConnection() {
		return (Connection) ((ConnectionEditPart) getHost()).getFigure();
	}

	/**
	 * @@return Point cached value representing the first reference point.
	 */
	private Point getFirstReferencePoint() {
		return getFeedbackState().ref1;
	}

	/**
	 * @@return Point cached value representing the second reference point.
	 */
	private Point getSecondReferencePoint() {
		return getFeedbackState().ref2;
	}

	/**
	 * Utility method to determine if point p passes through the line segment 
	 * defined by p1 and p2.
	 * 
	 * @@param p1 Point that is the first point in the line segment to test against.
	 * @@param p2 Point that is the second point in the line segment to test against.
	 * @@param p Point that is tested to see if it falls in the line segment defined by p1 and p2.
	 * @@return true if line segment contains Point p, false otherwise.
	 */
	private boolean lineContainsPoint(Point p1, Point p2, Point p) {
		LineSeg line = new LineSeg(p1, p2);
		return line.containsPoint(p, getStickyTolerance() / 3);
	}

	/**
	 * Adds selection handles to the Connection, if it is selected, when the points 
	 * property changes.  Since we only listen for changes in the points property, 
	 * this method is only called when the points of the Connection have changed.
	 */
	public void propertyChange(PropertyChangeEvent evt) {
		if (getHost().getSelected() != EditPart.SELECTED_NONE) {
//			int count = handles.size();
//			int points = getConnection().getPoints().size();
//			if (count != points * 2 - 3)
				addSelectionHandles();
		}
	}

	/**
	 * Restores the original constraint that was saved before feedback
	 * began to show.
	 */
	protected void restoreOriginalConstraint() {
		if (getFeedbackState().originalConstraint != null) {
			Assert.isTrue(getFeedbackState().originalConstraint.size() >= 2);
			getConnection().setRoutingConstraint(
				getFeedbackState().originalConstraint);
		}
	}

	/**
	 * Since the original figure is used for feedback, this method saves the 
	 * original constraint, so that is can be restored when the feedback is
	 * erased.
	 */
	protected void saveOriginalConstraint() {
		getFeedbackState().originalConstraint = (List)
			getConnection().getRoutingConstraint();
		if (getFeedbackState().originalConstraint == null)
			getFeedbackState().originalConstraint = NULL_CONSTRAINT;

		if (getLineSegMode() != LineMode.OBLIQUE && !getFeedbackState().init) {
			// Update the constraint based on the current figure
			List newConstraint = new ArrayList(getFeedbackState().originalConstraint.size());
			PointList pts =
				PointListUtilities.copyPoints(getConnection().getPoints());
			//OrthogonalRouterUtilities.resetEndPointsToCenter(getConnection(), pts);

			for (int i = 0; i < pts.size(); i++) {
				Bendpoint abp = new AbsoluteBendpoint(pts.getPoint(i));
				newConstraint.add(abp);
			}

			Assert.isTrue(getFeedbackState().originalConstraint.size() >= 2);
			getConnection().setRoutingConstraint(
				newConstraint);

			// reset booleans
			getFeedbackState().isOutsideSource = false;
			getFeedbackState().isOutsideTarget = false;
		} else {
			// if the constraint and the connection figure points list don't match then reset the constraint
			// based on the connection figure list.  This could happen in certain cases - sepcifically when
			// fan router detects a collision or when a self relation is routed.
			int nConstraintSize = getFeedbackState().originalConstraint.size();
			PointList pts = getConnection().getPoints();
			int nPointSize = pts.size();

			if (!getFeedbackState().init && nConstraintSize != nPointSize) {

				while (getFeedbackState().originalConstraint.size() > 0) {
					getFeedbackState().originalConstraint.remove(0);
				}

				for (int i = 0; i < pts.size(); i++) {
					Bendpoint bpNew = new AbsoluteBendpoint(pts.getPoint(i));
					getFeedbackState().originalConstraint.add(i, bpNew);
				}
			}

			Assert.isTrue(getFeedbackState().originalConstraint.size() >= 2);
			getConnection().setRoutingConstraint(
				new ArrayList(getFeedbackState().originalConstraint));
		}
		
		getFeedbackState().init = true;
	}

	/**
	 * Method setReferencePoints.
	 * This method will calculate the two end reference points for a point that is
	 * being moved or created.  The reference points are used to determine if the 
	 * request point can be deleted or not (for straight line tolerance).
	 * 
	 * @@param request BendpointRequest object containing index information.
	 */
	private void setReferencePoints(BendpointRequest request) {
		if (getFeedbackState().originalConstraint == null) {
			saveOriginalConstraint();
		}

		List constraint = (List)
			getConnection().getRoutingConstraint();
		Bendpoint bp = (Bendpoint) constraint.get(Math.max(0, request.getIndex() - 1));
		getFeedbackState().ref1 = bp.getLocation();

		bp = (Bendpoint) constraint.get(Math.min(request.getIndex() + 1, constraint.size() -1));
		getFeedbackState().ref2 = bp.getLocation();
	}

	private void setNewFeedbackConstraint(List constraint) {
		Assert.isTrue(constraint.size() >= 2);
		getConnection().setRoutingConstraint(constraint);
	}

	/**
	 * Shows feedback when a bendpoint is being created.  The original figure
	 * is used for feedback and the original constraint is saved, so that it
	 * can be restored when feedback is erased.
	 */
	protected void showCreateBendpointFeedback(BendpointRequest request) {
		Point p = new Point(request.getLocation());
		List constraint;
		
		getConnection().translateToRelative(p);

		Bendpoint bp = new AbsoluteBendpoint(p);
		if (getFeedbackState().originalConstraint == null) {
			saveOriginalConstraint();
			constraint = (List)
				getConnection().getRoutingConstraint();
			constraint.add(request.getIndex() + 1, bp);
		} else {
			constraint = (List)
				getConnection().getRoutingConstraint();
		}

		stickyStraightLineFeedback(constraint, request.getIndex() + 1, bp);

		setNewFeedbackConstraint(constraint);
	}

	/**
	 * Shows feedback when a bendpoint is being deleted.  This method is
	 * only called once when the bendpoint is first deleted, not every
	 * mouse move.  The original figure is used for feedback and the original 
	 * constraint is saved, so that it can be restored when feedback is erased.
	 */
	protected void showDeleteBendpointFeedback(BendpointRequest request) {
		if (getFeedbackState().originalConstraint == null) {
			saveOriginalConstraint();
			List constraint = (List)
				getConnection().getRoutingConstraint();
			constraint.remove(request.getIndex());

			setNewFeedbackConstraint(constraint);
		}
	}

	/**
	 * Shows feedback when a bendpoint is being moved.  Also checks to see if the bendpoint 
	 * should be deleted and then calls {@@link #showDeleteBendpointFeedback(BendpointRequest)}
	 * if needed.  The original figure is used for feedback and the original constraint is 
	 * saved, so that it can be restored when feedback is erased.
	 */
	protected void showMoveBendpointFeedback(BendpointRequest request) {		
		Point p = new Point(request.getLocation());
		if (!getFeedbackState().isDeleting) {
			setReferencePoints(request);
		}

		getConnection().translateToRelative(p);
		Bendpoint bp = new AbsoluteBendpoint(p);

		if (getFeedbackState().originalConstraint == null) {
			saveOriginalConstraint();
		}

		if (lineContainsPoint(getFirstReferencePoint(),
			getSecondReferencePoint(),
			p)) {
			if (!getFeedbackState().isDeleting) {
				getFeedbackState().isDeleting = true;
				eraseConnectionFeedback(request, false);
				showDeleteBendpointFeedback(request);
			}
			return;
		}
		if (getFeedbackState().isDeleting) {
			getFeedbackState().isDeleting = false;
			eraseConnectionFeedback(request, false);
		}

		List constraint = (List)
			getConnection().getRoutingConstraint();
		stickyStraightLineFeedback(constraint, request.getIndex(), bp);

		setNewFeedbackConstraint(constraint);
	}

	/**
	 * This method will set the constraint with the given bendpoint, with the additional behavior of
	 * "sticking" the point around a tolerance to a straight line.  If it's within a tolerance of the
	 * previous point, stick it to the horizontal or vertical coordinates that make it straight.
	 */
	protected void stickyStraightLineFeedback(
		List constraint,
		int nIndex,
		Bendpoint bp) {
		Point ptLoc = new Point(bp.getLocation());
		
		int sticky_tolerance = getStickyTolerance();
		
		if (nIndex > 0) {
			Point ptPrev;
			if ((nIndex - 1) == 0) {
				ptPrev =
					getConnection()
						.getSourceAnchor()
						.getReferencePoint();
				getConnection().translateToRelative(ptPrev);
			} else
				ptPrev = ((Bendpoint) constraint.get(nIndex - 1)).getLocation();

			if (Math.abs(ptPrev.x - ptLoc.x) < sticky_tolerance)
				ptLoc.x = ptPrev.x;
			if (Math.abs(ptPrev.y - ptLoc.y) < sticky_tolerance)
				ptLoc.y = ptPrev.y;
		}

		if (nIndex < constraint.size() - 1) {
			Point ptNext;
			if ((nIndex + 1) == (constraint.size() - 1)) {
				ptNext =
					getConnection()
						.getTargetAnchor()
						.getReferencePoint();
				getConnection().translateToRelative(ptNext);
			} else
				ptNext = ((Bendpoint) constraint.get(nIndex + 1)).getLocation();

			if (Math.abs(ptNext.x - ptLoc.x) < sticky_tolerance)
				ptLoc.x = ptNext.x;
			if (Math.abs(ptNext.y - ptLoc.y) < sticky_tolerance)
				ptLoc.y = ptNext.y;
		}

		if (!ptLoc.equals(bp.getLocation())) {
			Bendpoint bpNew = new AbsoluteBendpoint(ptLoc);
			constraint.set(nIndex, bpNew);
		} else {
			constraint.set(nIndex, bp);
		}
	}

	private int getStickyTolerance() {
		int sticky_tolerance = MapModeUtil.getMapMode(getConnection()).DPtoLP(STICKY_TOLERANCE_DP);
		return sticky_tolerance;
	}

	/**
	 * Shows feedback, when appropriate.  Calls a different method
	 * depending on the request type.
	 *
	 * @@see #showCreateBendpointFeedback(BendpointRequest)
	 * @@see #showMoveBendpointFeedback(BendpointRequest)
	 */
	public void showSourceFeedback(Request request) {
		if (getLineSegMode() != LineMode.OBLIQUE) {
			if (REQ_CREATE_BENDPOINT.equals(request.getType())) {
				showMoveLineSegFeedback((BendpointRequest) request);
			} else if (REQ_MOVE_BENDPOINT.equals(request.getType())) {
				showMoveOrthogonalBenspointFeedback((BendpointRequest) request);
			}
			
		} else {
			if (REQ_MOVE_BENDPOINT.equals(request.getType()))
				showMoveBendpointFeedback((BendpointRequest) request);
			else if (REQ_CREATE_BENDPOINT.equals(request.getType()))
				showCreateBendpointFeedback((BendpointRequest) request);
		}

		super.showSourceFeedback(request);
	}

	/**
	 * Method getBendpointsChangedCommand.
	 * This method will return a SetBendpointsCommand with the points retrieved from
	 * the user feedback in the figure.
	 * @@param request BendpointRequest from the user gesture for moving / creating a bendpoint
	 * @@return Command SetBendpointsCommand that contains the point changes for the connection.
	 */
	abstract protected Command getBendpointsChangedCommand(BendpointRequest request);

	protected Command getCreateBendpointCommand(BendpointRequest request) {
		return getBendpointsChangedCommand(request);
	}

	protected Command getMoveBendpointCommand(BendpointRequest request) {
		return getBendpointsChangedCommand(request);
	}

	protected Command getDeleteBendpointCommand(BendpointRequest request) {
		return getBendpointsChangedCommand(request);
	}

	protected final LineSeg getLineSeg(List bendPoints, int nIndex) {
		Point pt1 =
			new Point(((Bendpoint) bendPoints.get(nIndex - 1)).getLocation());
		Point pt2 =
			new Point(((Bendpoint) bendPoints.get(nIndex)).getLocation());

		return new LineSeg(pt1, pt2);
	}

	/**
	 * @@param bendPoints
	 * @@param nIndex
	 * @@param newLine
	 */
	protected void setLineSeg(List bendPoints, int nIndex, LineSeg newLine) {
		Bendpoint bp1 = new AbsoluteBendpoint(newLine.getOrigin());
		Bendpoint bp2 = new AbsoluteBendpoint(newLine.getTerminus());
		
		bendPoints.set(nIndex - 1, bp1);
		bendPoints.set(nIndex, bp2);
	}

	/**
	 * @@param request
	 * @@return move line segment command
	 */
	protected Command getMoveLineSegCommand(BendpointRequest request) {
		return getBendpointsChangedCommand(request);
	}


	/**
	* Method lineOutsideSource.
	* Utility method to determine if the constraint needs to be adjusted becauase the line is
	* outside of the source bounds.
	* 
	* @@param line LineSeg defining the new line moved by the user gesture
	* @@return boolean true if origin of line lies outside the starting source element, false otherwise.
	*/
	protected boolean lineOutsideSource(LineSeg line) {

		// check if end points are outside of bounds and if so - add a new point
		PrecisionRectangle startRect =
			new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getConnection().getSourceAnchor().getOwner()));
		getConnection().getSourceAnchor().getOwner().translateToAbsolute(
			startRect);
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
			if (line.isHorizontal()) {
				startRect.shrink(0, 2);
			} else {
				startRect.shrink(2, 0);
			}
		}
		
		getConnection().translateToRelative(startRect);
		/*
		 * Rectangle needs to be expanded by the "odd" number below because the number after
		 * translations could be N.999999999... 
		 */
		if (!startRect.expand(0.000001, 0.000001).contains(new PrecisionPoint(line.getOrigin()))) {
			return true;
		}

		return false;
	}

	/**
	* Method lineOutsideTarget.
	* Utility method to determine if the constraint needs to be adjusted because the line is
	* outside of the target bounds.
	* 
	* @@param line LineSeg defining the new line moved by the user gesture.
	* @@return boolean true if terminus of line lies outside the target element, false otherwise.
	*/
	protected boolean lineOutsideTarget(LineSeg line) {

		// check if end points are outside of bounds and if so - add a new point
		PrecisionRectangle endRect =
			new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getConnection().getTargetAnchor().getOwner()));
		getConnection().getTargetAnchor().getOwner().translateToAbsolute(
			endRect);
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
			if (line.isHorizontal()) {
				endRect.shrink(0, 2);
			} else {
				endRect.shrink(2, 0);
			}
		}
		
		/*
		 * Rectangle needs to be expanded by the "odd" number below because the number after
		 * translations could be N.999999999... 
		 */
		getConnection().translateToRelative(endRect);
		if (!endRect.expand(0.00001, 0.00001).contains(new PrecisionPoint(line.getTerminus()))) {
			return true;
		}

		return false;
	}

	/**
	* Method removeOutsideSourceFeedback.
	* Removes a bendpoint from the beginning of the constraint.
	* 
	* @@param constraint List of bendpoints that the source point will be added too.
	*/
	protected void removeOutsideSourceFeedback(List constraint) {
		constraint.remove(0);
	}

	/**
	* Method removeOutsideTargetFeedback.
	* Removes a bendpoint from the end of the constraint.
	* 
	* @@param constraint List of bendpoints that the target point will be added too.
	*/
	protected void removeOutsideTargetFeedback(List constraint) {
		constraint.remove(constraint.size() - 1);
	}
	
	/**
	 * Draws feedback for moving a bend point of a rectilinear connection
	 * 
	 * @@param request Benndpoint request
	 */
	private void showMoveOrthogonalBenspointFeedback(BendpointRequest request) {
		if (getFeedbackState().originalConstraint == null) {
			saveOriginalConstraint();
		}
		
		Point ptLoc = new Point(request.getLocation());
		List constraint = (List)
			getConnection().getRoutingConstraint();
		
		getConnection().translateToRelative(ptLoc);
		
		int index =
		getFeedbackState().isOutsideSource ? request.getIndex() + 1 : request.getIndex();
		
		Point previous = ((Bendpoint)constraint.get(index - 1)).getLocation();
		Point moving = ((Bendpoint)constraint.get(index)).getLocation();
		Point next = ((Bendpoint)constraint.get(index + 1)).getLocation();
		
		LineSeg originalFirst = new LineSeg(previous.getCopy(), moving.getCopy());
		LineSeg originalSecond = new LineSeg(moving.getCopy(), next.getCopy());
		
		Dimension diff = ptLoc.getDifference(moving);
		
		if (originalFirst.isHorizontal()) {
			previous.y += diff.height;
			next.x += diff.width;
		} else {
			previous.x += diff.width;
			next.y += diff.height;
		}
		
		LineSeg movedFirst = new LineSeg(previous, ptLoc.getCopy());
		LineSeg movedSecond = new LineSeg(ptLoc.getCopy(), next);
		
		index = adjustOutsideBoundsLineFeedback(movedFirst, index - 1, constraint, originalFirst);
		constraint.set(index, new AbsoluteBendpoint(movedFirst.getOrigin()));
		constraint.set(index + 1, new AbsoluteBendpoint(movedFirst.getTerminus()));
		
		index = adjustOutsideBoundsLineFeedback(movedSecond, index + 1, constraint, originalSecond);
		constraint.set(index + 1, new AbsoluteBendpoint(movedSecond.getTerminus()));
		
		getConnection().setRoutingConstraint(constraint);	}

	/**
	* Shows feedback when a line segment is being moved.  Also checks to see if the bendpoint 
	* should be deleted and then calls {@@link #showDeleteBendpointFeedback(BendpointRequest)}
	* if needed.  The original figure is used for feedback and the original constraint is 
	* saved, so that it can be restored when feedback is erased.
	*/
	protected void showMoveLineSegFeedback(BendpointRequest request) {

		if (getFeedbackState().originalConstraint == null) {
			saveOriginalConstraint();
		}

		Point ptLoc = new Point(request.getLocation());
		List constraint = (List)
			getConnection().getRoutingConstraint();
		
		getConnection().translateToRelative(ptLoc);
		
		// adjust request index to account for source bendpoint if needed
		int index =
			getFeedbackState().isOutsideSource ? request.getIndex() + 1 : request.getIndex();

		LineSeg moveLine = getLineSeg(constraint, index + 1);
		LineSeg newLine = moveLine.getParallelLineSegThroughPoint(ptLoc);
				
		index = adjustOutsideBoundsLineFeedback(newLine, index, constraint, moveLine);
		
		setLineSeg(constraint, index + 1, newLine);
		
		getConnection().setRoutingConstraint(constraint);
	}
	
	/**
	 * adjustOutsideBoundsLineFeedback
	 * Method to handle feedback where the line is dragged outside of the source or target shapes bounding box.
	 * 
	 * @@param newLine LineSeg representing the line currently being manipulated.
	 * @@param index the index
	 * @@param constraint List of Bendpoint objects that is the constraint to the gesture.
	 * @@param moveLine original segment that is being manipulated
	 * @@return int new index value after the constraint and feedback have been adjusted.
	 */
	private int adjustOutsideBoundsLineFeedback(LineSeg newLine, int index, List constraint, LineSeg moveLine) {
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
			// merely enforce the fact that we can't adjust the line outside the bounds of the source and target.
			if ((index == 0 && lineOutsideSource(newLine)) ||
				((index + 1 == constraint.size() - 1)&& lineOutsideTarget(newLine))) {
				newLine.setOrigin(moveLine.getOrigin());
				newLine.setTerminus(moveLine.getTerminus());
			}

			return index;
		}
		
		boolean bRemoveSource = false;
		boolean bRemoveTarget = false;
		boolean bSetNewSource = false;
		boolean bSetNewTarget = false;

		// Check source to see if we need to add a bendpoint
		if (index == 0 && lineOutsideSource(newLine)) {
			if (!getFeedbackState().isOutsideSource) {
				getFeedbackState().isOutsideSource = true;
				bSetNewSource = true;
			}
		} else if (index == 1 && getFeedbackState().isOutsideSource && !lineOutsideSource(newLine)) {
			getFeedbackState().isOutsideSource = false;
			bRemoveSource = true;
		}
		
		// Check target to see if we need to add a bendpoint
		int checkTargetIndex = index + 1 + (getFeedbackState().isOutsideTarget ? 1 : 0);
		if ((checkTargetIndex == constraint.size() - 1)
			&& lineOutsideTarget(newLine)) {
			if (!getFeedbackState().isOutsideTarget) {
				getFeedbackState().isOutsideTarget = true;
				bSetNewTarget = true;
			}
		} else if (checkTargetIndex == constraint.size() - 2 && getFeedbackState().isOutsideTarget
				&& !lineOutsideTarget(newLine)) {
			getFeedbackState().isOutsideTarget = false;
			bRemoveTarget = true;
		}
		if (bRemoveSource) {
			removeOutsideSourceFeedback(constraint);
			index--;
		}
		
		if (bRemoveTarget) {
			removeOutsideTargetFeedback(constraint);
		}

		if (bSetNewSource) {
			showOutsideSourceFeedback(newLine, moveLine, constraint);
			index++;
		}

		if (bSetNewTarget) {
			showOutsideTargetFeedback(newLine, moveLine, constraint);
		}
		return index;
	}
	
	/**
	* Method showOutsideSourceFeedback.
	* Adds a bendpoint to the beginning of the constraint.
	* Also adjusts the new segment with respect to added constraint
	* 
	* @@param constraint List of bendpoints that the source point will be added too.
	*/
	private void showOutsideSourceFeedback(LineSeg newLine, LineSeg moveLine, List constraint) {
		Connection conn = (Connection)getHostFigure();
		ConnectionAnchor anchor = conn.getSourceAnchor();
		PrecisionPoint startPoint = new PrecisionPoint(anchor.getOwner().getBounds().getCenter());
		anchor.getOwner().translateToAbsolute(startPoint);
		conn.translateToRelative(startPoint);
		PrecisionRectangle bounds = new PrecisionRectangle(anchor.getOwner().getBounds());
		anchor.getOwner().translateToAbsolute(bounds);
		conn.translateToRelative(bounds);
		Point origin = new Point(newLine.getOrigin());
		if (moveLine.isHorizontal()) {
			origin.x = startPoint.x;
		} else {
			origin.y = startPoint.y;
		}
		newLine.setOrigin(origin);
		constraint.add(0, new AbsoluteBendpoint(startPoint));
		
	}

	/**
	* Method showOutsideTargetFeedback.
	* Adds a bendpoint to the end of the constraint.
	* Also adjusts the new segment with respect to added constraint
	* 
	* @@param constraint List of bendpoints that the target point will be added too.
	*/
	private void showOutsideTargetFeedback(LineSeg newLine, LineSeg moveLine, List constraint) {
		Connection conn = (Connection)getHostFigure();
		ConnectionAnchor anchor = conn.getTargetAnchor();
		PrecisionPoint endPoint = new PrecisionPoint(anchor.getOwner().getBounds().getCenter());
		anchor.getOwner().translateToAbsolute(endPoint);
		conn.translateToRelative(endPoint);
		PrecisionRectangle bounds = new PrecisionRectangle(anchor.getOwner().getBounds());
		anchor.getOwner().translateToAbsolute(bounds);
		conn.translateToRelative(bounds);
		Point terminus = new Point(newLine.getTerminus()); 
		if (moveLine.isHorizontal()) {
			terminus.x = endPoint.x;
		} else {
			terminus.y = endPoint.y;
		}
		newLine.setTerminus(terminus);
		constraint.add(new AbsoluteBendpoint(endPoint));
	}

	/**
	 * Override for AccessibleHandleProvider when deactivated
	 * https://bugs.eclipse.org/bugs/show_bug.cgi?id=69316
	 * 
	 * @@see org.eclipse.core.runtime.IAdaptable#getAdapter(java.lang.Class)
	 */
	public Object getAdapter(Class key) {
		if (key == AccessibleHandleProvider.class)
			//handles == null when deactivated
			if (handles == null) {
				return null;
			}
		return super.getAdapter(key);
	}	
}
@


1.7
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d19 1
d21 1
d25 2
d29 2
a30 1
import org.eclipse.draw2d.geometry.Rectangle;
d37 1
d40 1
a43 1
import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.OrthogonalRouterUtilities;
d46 1
a47 1
import org.eclipse.jface.util.Assert;
d158 1
a158 1
				new BendpointMoveHandle(
d162 1
a162 1
		}
d342 1
a342 1
			OrthogonalRouterUtilities.resetEndPointsToCenter(getConnection(), pts);
d461 1
a461 1
	protected void showMoveBendpointFeedback(BendpointRequest request) {
d565 1
a565 2
			if (REQ_CREATE_BENDPOINT.equals(request.getType())
				|| REQ_MOVE_BENDPOINT.equals(request.getType())) {
d567 2
d570 1
d619 1
a619 1

d644 2
a645 3
		Rectangle startRect =
			new Rectangle(
				getConnection().getSourceAnchor().getOwner().getBounds());
d648 8
d657 5
a661 5
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED))
			startRect.expand(MapModeUtil.getMapMode(getConnection()).DPtoLP(-2), 
							MapModeUtil.getMapMode(getConnection()).DPtoLP(-2));
		
		if (!startRect.contains(line.getOrigin())) {
d670 1
a670 1
	* Utility method to determine if the constraint needs to be adjusted becauase the line is
d679 2
a680 3
		Rectangle endRect =
			new Rectangle(
				getConnection().getTargetAnchor().getOwner().getBounds());
d683 12
d696 1
a696 5
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED))
			endRect.expand(MapModeUtil.getMapMode(getConnection()).DPtoLP(-2), 
						MapModeUtil.getMapMode(getConnection()).DPtoLP(-2)); 
		
		if (!endRect.contains(line.getTerminus())) {
d724 46
a769 24
	* Method showOutsideSourceFeedback.
	* Adds a bendpoint to the beginning of the constraint.
	* 
	* @@param constraint List of bendpoints that the source point will be added too.
	*/
	protected void showOutsideSourceFeedback(List constraint) {
		Point ptAdd = ((Bendpoint) constraint.get(0)).getLocation();
		Bendpoint bp = new AbsoluteBendpoint(ptAdd);
		constraint.add(0, bp);
	}

	/**
	* Method showOutsideTargetFeedback.
	* Adds a bendpoint to the end of the constraint.
	* 
	* @@param constraint List of bendpoints that the target point will be added too.
	*/
	protected void showOutsideTargetFeedback(List constraint) {
		Point ptAdd =
			((Bendpoint) constraint.get(constraint.size() - 1))
				.getLocation();
		Bendpoint bp = new AbsoluteBendpoint(ptAdd);
		constraint.add(constraint.size() - 1, bp);
	}
d786 1
a786 1

d788 1
a788 1

d795 2
a796 9
		if (!newLine.isHorizontal() && !newLine.isVertical()) {
			if (Math.abs(newLine.getOrigin().x - newLine.getTerminus().x) < 
				Math.abs(newLine.getOrigin().y - newLine.getTerminus().y)) {
				newLine.setTerminus(new Point(newLine.getOrigin().x, newLine.getTerminus().y));
			}
			else {
				newLine.setTerminus(new Point(newLine.getTerminus().x, newLine.getOrigin().y));
			}
		}
a797 2
		index = adjustOutsideBoundsLineFeedback(request, constraint, index, newLine);

d799 1
d802 1
a802 1

d807 2
a808 1
	 * @@param request BendpointRequest that triggered the gesture
d810 1
a810 2
	 * @@param index int index of the line that the user is currently manipulating.
	 * @@param newLine LineSeg representing the line currently being manipulated.
d813 1
a813 2
	protected int adjustOutsideBoundsLineFeedback(BendpointRequest request, List constraint, int index, LineSeg newLine) {
		
a817 1
				LineSeg moveLine = getLineSeg(constraint, index + 1);
d831 1
a831 1
		if (request.getIndex() == 0 && lineOutsideSource(newLine)) {
d836 1
a836 1
		} else if (getFeedbackState().isOutsideSource) {
d840 1
a840 1

d849 2
a850 1
		} else if (getFeedbackState().isOutsideTarget) {
a853 1

d856 1
a856 1
			index = request.getIndex();
d864 2
a865 2
			showOutsideSourceFeedback(constraint);
			index = request.getIndex() + 1;
d869 1
a869 1
			showOutsideTargetFeedback(constraint);
d873 53
@


1.6
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
a18 1
import org.eclipse.core.runtime.Assert;
a19 1
import org.eclipse.draw2d.AutomaticRouter;
a22 2
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.geometry.Dimension;
d25 1
a25 2
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.PrecisionRectangle;
a31 1
import org.eclipse.gef.handles.BendpointCreationHandle;
a33 1
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
d37 1
a39 1
import org.eclipse.gmf.runtime.gef.ui.internal.handles.BendpointMoveHandleEx;
d41 1
d152 1
a152 1
				new BendpointMoveHandleEx(
d156 1
a156 1
		}		
d336 1
a336 1
			//OrthogonalRouterUtilities.resetEndPointsToCenter(getConnection(), pts);
d455 1
a455 1
	protected void showMoveBendpointFeedback(BendpointRequest request) {		
d559 2
a560 1
			if (REQ_CREATE_BENDPOINT.equals(request.getType())) {
a561 2
			} else if (REQ_MOVE_BENDPOINT.equals(request.getType())) {
				showMoveOrthogonalBenspointFeedback((BendpointRequest) request);
a562 1
			
d611 1
a611 1
		
d636 3
a638 2
		PrecisionRectangle startRect =
			new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getConnection().getSourceAnchor().getOwner()));
d641 4
a644 7
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
			if (line.isHorizontal()) {
				startRect.shrink(0, 2);
			} else {
				startRect.shrink(2, 0);
			}
		}
d646 1
a646 6
		getConnection().translateToRelative(startRect);
		/*
		 * Rectangle needs to be expanded by the "odd" number below because the number after
		 * translations could be N.999999999... 
		 */
		if (!startRect.expand(0.000001, 0.000001).contains(new PrecisionPoint(line.getOrigin()))) {
d655 1
a655 1
	* Utility method to determine if the constraint needs to be adjusted because the line is
d664 3
a666 2
		PrecisionRectangle endRect =
			new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getConnection().getTargetAnchor().getOwner()));
d669 4
a672 7
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
			if (line.isHorizontal()) {
				endRect.shrink(0, 2);
			} else {
				endRect.shrink(2, 0);
			}
		}
d674 1
a674 6
		/*
		 * Rectangle needs to be expanded by the "odd" number below because the number after
		 * translations could be N.999999999... 
		 */
		getConnection().translateToRelative(endRect);
		if (!endRect.expand(0.00001, 0.00001).contains(new PrecisionPoint(line.getTerminus()))) {
d702 24
a725 46
	 * Draws feedback for moving a bend point of a rectilinear connection
	 * 
	 * @@param request Benndpoint request
	 */
	private void showMoveOrthogonalBenspointFeedback(BendpointRequest request) {
		if (getFeedbackState().originalConstraint == null) {
			saveOriginalConstraint();
		}
		
		Point ptLoc = new Point(request.getLocation());
		List constraint = (List)
			getConnection().getRoutingConstraint();
		
		getConnection().translateToRelative(ptLoc);
		
		int index =
		getFeedbackState().isOutsideSource ? request.getIndex() + 1 : request.getIndex();
		
		Point previous = ((Bendpoint)constraint.get(index - 1)).getLocation();
		Point moving = ((Bendpoint)constraint.get(index)).getLocation();
		Point next = ((Bendpoint)constraint.get(index + 1)).getLocation();
		
		LineSeg originalFirst = new LineSeg(previous.getCopy(), moving.getCopy());
		LineSeg originalSecond = new LineSeg(moving.getCopy(), next.getCopy());
		
		Dimension diff = ptLoc.getDifference(moving);
		
		if (originalFirst.isHorizontal()) {
			previous.y += diff.height;
			next.x += diff.width;
		} else {
			previous.x += diff.width;
			next.y += diff.height;
		}
		
		LineSeg movedFirst = new LineSeg(previous, ptLoc.getCopy());
		LineSeg movedSecond = new LineSeg(ptLoc.getCopy(), next);
		
		index = adjustOutsideBoundsLineFeedback(movedFirst, index - 1, constraint, originalFirst);
		constraint.set(index, new AbsoluteBendpoint(movedFirst.getOrigin()));
		constraint.set(index + 1, new AbsoluteBendpoint(movedFirst.getTerminus()));
		
		index = adjustOutsideBoundsLineFeedback(movedSecond, index + 1, constraint, originalSecond);
		constraint.set(index + 1, new AbsoluteBendpoint(movedSecond.getTerminus()));
		
		getConnection().setRoutingConstraint(constraint);	}
d742 1
a742 1
		
d744 1
a744 1
		
d751 9
a759 2
				
		index = adjustOutsideBoundsLineFeedback(newLine, index, constraint, moveLine);
d761 2
a763 1
		
d766 1
a766 1
	
d771 3
a774 3
	 * @@param index the index
	 * @@param constraint List of Bendpoint objects that is the constraint to the gesture.
	 * @@param moveLine original segment that is being manipulated
d777 2
a778 1
	private int adjustOutsideBoundsLineFeedback(LineSeg newLine, int index, List constraint, LineSeg moveLine) {
d783 1
d797 1
a797 1
		if (index == 0 && lineOutsideSource(newLine)) {
d802 1
a802 1
		} else if (index == 1 && getFeedbackState().isOutsideSource && !lineOutsideSource(newLine)) {
d806 1
a806 1
		
d815 1
a815 2
		} else if (checkTargetIndex == constraint.size() - 2 && getFeedbackState().isOutsideTarget
				&& !lineOutsideTarget(newLine)) {
d819 1
d822 1
a822 1
			index--;
d830 2
a831 2
			showOutsideSourceFeedback(newLine, moveLine, constraint);
			index++;
d835 1
a835 1
			showOutsideTargetFeedback(newLine, moveLine, constraint);
a838 53
	
	/**
	* Method showOutsideSourceFeedback.
	* Adds a bendpoint to the beginning of the constraint.
	* Also adjusts the new segment with respect to added constraint
	* 
	* @@param constraint List of bendpoints that the source point will be added too.
	*/
	private void showOutsideSourceFeedback(LineSeg newLine, LineSeg moveLine, List constraint) {
		Connection conn = (Connection)getHostFigure();
		ConnectionAnchor anchor = conn.getSourceAnchor();
		PrecisionPoint startPoint = new PrecisionPoint(anchor.getOwner().getBounds().getCenter());
		anchor.getOwner().translateToAbsolute(startPoint);
		conn.translateToRelative(startPoint);
		PrecisionRectangle bounds = new PrecisionRectangle(anchor.getOwner().getBounds());
		anchor.getOwner().translateToAbsolute(bounds);
		conn.translateToRelative(bounds);
		Point origin = new Point(newLine.getOrigin());
		if (moveLine.isHorizontal()) {
			origin.x = startPoint.x;
		} else {
			origin.y = startPoint.y;
		}
		newLine.setOrigin(origin);
		constraint.add(0, new AbsoluteBendpoint(startPoint));
		
	}

	/**
	* Method showOutsideTargetFeedback.
	* Adds a bendpoint to the end of the constraint.
	* Also adjusts the new segment with respect to added constraint
	* 
	* @@param constraint List of bendpoints that the target point will be added too.
	*/
	private void showOutsideTargetFeedback(LineSeg newLine, LineSeg moveLine, List constraint) {
		Connection conn = (Connection)getHostFigure();
		ConnectionAnchor anchor = conn.getTargetAnchor();
		PrecisionPoint endPoint = new PrecisionPoint(anchor.getOwner().getBounds().getCenter());
		anchor.getOwner().translateToAbsolute(endPoint);
		conn.translateToRelative(endPoint);
		PrecisionRectangle bounds = new PrecisionRectangle(anchor.getOwner().getBounds());
		anchor.getOwner().translateToAbsolute(bounds);
		conn.translateToRelative(bounds);
		Point terminus = new Point(newLine.getTerminus()); 
		if (moveLine.isHorizontal()) {
			terminus.x = endPoint.x;
		} else {
			terminus.y = endPoint.y;
		}
		newLine.setTerminus(terminus);
		constraint.add(new AbsoluteBendpoint(endPoint));
	}
@


1.5
log
@[194282] gmf_head crevells 071123 [RulersGrid] Useability: diagram arrange all
should snap to grid if snap to grid is on
Contributed by:  Carson Li
@
text
@d19 1
d21 1
d25 2
d29 2
a30 1
import org.eclipse.draw2d.geometry.Rectangle;
d37 1
d40 1
a43 1
import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.OrthogonalRouterUtilities;
a47 1
import org.eclipse.jface.util.Assert;
d342 1
a342 1
			OrthogonalRouterUtilities.resetEndPointsToCenter(getConnection(), pts);
d565 1
a565 2
			if (REQ_CREATE_BENDPOINT.equals(request.getType())
				|| REQ_MOVE_BENDPOINT.equals(request.getType())) {
d567 2
d570 1
d619 1
a619 1

d644 2
a645 3
		Rectangle startRect =
			new Rectangle(
				getConnection().getSourceAnchor().getOwner().getBounds());
d648 8
d657 5
a661 5
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED))
			startRect.expand(MapModeUtil.getMapMode(getConnection()).DPtoLP(-2), 
							MapModeUtil.getMapMode(getConnection()).DPtoLP(-2));
		
		if (!startRect.contains(line.getOrigin())) {
d670 1
a670 1
	* Utility method to determine if the constraint needs to be adjusted becauase the line is
d679 2
a680 3
		Rectangle endRect =
			new Rectangle(
				getConnection().getTargetAnchor().getOwner().getBounds());
d683 12
d696 1
a696 5
		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED))
			endRect.expand(MapModeUtil.getMapMode(getConnection()).DPtoLP(-2), 
						MapModeUtil.getMapMode(getConnection()).DPtoLP(-2)); 
		
		if (!endRect.contains(line.getTerminus())) {
d724 46
a769 24
	* Method showOutsideSourceFeedback.
	* Adds a bendpoint to the beginning of the constraint.
	* 
	* @@param constraint List of bendpoints that the source point will be added too.
	*/
	protected void showOutsideSourceFeedback(List constraint) {
		Point ptAdd = ((Bendpoint) constraint.get(0)).getLocation();
		Bendpoint bp = new AbsoluteBendpoint(ptAdd);
		constraint.add(0, bp);
	}

	/**
	* Method showOutsideTargetFeedback.
	* Adds a bendpoint to the end of the constraint.
	* 
	* @@param constraint List of bendpoints that the target point will be added too.
	*/
	protected void showOutsideTargetFeedback(List constraint) {
		Point ptAdd =
			((Bendpoint) constraint.get(constraint.size() - 1))
				.getLocation();
		Bendpoint bp = new AbsoluteBendpoint(ptAdd);
		constraint.add(constraint.size() - 1, bp);
	}
d786 1
a786 1

d788 1
a788 1

d795 2
a796 9
		if (!newLine.isHorizontal() && !newLine.isVertical()) {
			if (Math.abs(newLine.getOrigin().x - newLine.getTerminus().x) < 
				Math.abs(newLine.getOrigin().y - newLine.getTerminus().y)) {
				newLine.setTerminus(new Point(newLine.getOrigin().x, newLine.getTerminus().y));
			}
			else {
				newLine.setTerminus(new Point(newLine.getTerminus().x, newLine.getOrigin().y));
			}
		}
a797 2
		index = adjustOutsideBoundsLineFeedback(request, constraint, index, newLine);

d799 1
d802 1
a802 1

d807 2
a808 1
	 * @@param request BendpointRequest that triggered the gesture
d810 1
a810 2
	 * @@param index int index of the line that the user is currently manipulating.
	 * @@param newLine LineSeg representing the line currently being manipulated.
d813 1
a813 2
	protected int adjustOutsideBoundsLineFeedback(BendpointRequest request, List constraint, int index, LineSeg newLine) {
		
a817 1
				LineSeg moveLine = getLineSeg(constraint, index + 1);
d831 1
a831 1
		if (request.getIndex() == 0 && lineOutsideSource(newLine)) {
d836 1
a836 1
		} else if (getFeedbackState().isOutsideSource) {
d840 1
a840 1

d849 2
a850 1
		} else if (getFeedbackState().isOutsideTarget) {
a853 1

d856 1
a856 1
			index = request.getIndex();
d864 2
a865 2
			showOutsideSourceFeedback(constraint);
			index = request.getIndex() + 1;
d869 1
a869 1
			showOutsideTargetFeedback(constraint);
d873 53
@


1.4
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d40 1
d153 1
a153 1
				new BendpointMoveHandle(
d157 1
a157 1
		}
d456 1
a456 1
	protected void showMoveBendpointFeedback(BendpointRequest request) {
@


1.3
log
@bugzilla 110316 gmf-head 051212 Compiler warning count should be 0 - runtime diagram layer
@
text
@d2 1
a2 1
 * Copyright (c) 2002 - 2005 IBM Corporation and others.
d751 1
a751 1
		if (!newLine.isHorizontal() || !newLine.isVertical()) {
@


1.3.2.1
log
@[150280] gmf_R1_0_maintenance ahunter 060717 Incorrect copyright in some GMF files
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
@


1.3.2.2
log
@Bugzilla#135064 gmf_R1_0_maintenance cmahoney 060905 Wrong test in ConnectionBendpointEditPolicy
@
text
@d751 1
a751 1
		if (!newLine.isHorizontal() && !newLine.isVertical()) {
@


1.2
log
@bugzilla 112788 gmf-head sshaw 051108 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@a19 1
import org.eclipse.draw2d.AutomaticRouter;
a31 1
import org.eclipse.gef.handles.BendpointCreationHandle;
@


1.1
log
@Bugzilla#113157 gmf_head cmahoney 051104 Updating tutorial guides and some comments with name changes
@
text
@d56 1
a56 1
	private static final int STICKY_TOLERANCE = 6 * 26;
d293 1
a293 1
		return line.containsPoint(p, STICKY_TOLERANCE / 3);
d502 3
d516 1
a516 1
			if (Math.abs(ptPrev.x - ptLoc.x) < STICKY_TOLERANCE)
d518 1
a518 1
			if (Math.abs(ptPrev.y - ptLoc.y) < STICKY_TOLERANCE)
d533 1
a533 1
			if (Math.abs(ptNext.x - ptLoc.x) < STICKY_TOLERANCE)
d535 1
a535 1
			if (Math.abs(ptNext.y - ptLoc.y) < STICKY_TOLERANCE)
d547 5
@

