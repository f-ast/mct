head	1.13;
access;
symbols
	v20081015-1925:1.13
	v20080917-1925:1.13
	v20080903-1520:1.13
	v20080827-1520:1.13
	v20080813-1520:1.13
	v20080722-1827:1.13
	v20080716-1642:1.13
	R2_1_maintenance:1.13.0.2
	Root_R2_1_maintenance:1.13
	R2_1_0:1.13
	v20080528-1052:1.13
	v20080507-1326:1.11
	v20080417-1610:1.11
	v20080222-1200:1.11
	v20070809-0000:1.11
	R2_0_maintenance:1.11.0.2
	R2_0:1.11
	R4_20:1.11
	v20070621-0000:1.11
	RC3_20:1.11
	v20070608-1300:1.11
	v20070605-1400:1.10
	v20070601-1400:1.9
	v20070525-1500:1.8
	v20070518-1300:1.8
	v20070504-1000:1.7
	v20070427-0600:1.7
	v20070420-1000:1.7
	v20070413-1300:1.7
	v20070405-1100:1.7
	v20070330-1300:1.7
	v20070322-1100:1.7
	v20060316-0600:1.6
	v20070228-2000:1.6
	v20070208-1800:1.5
	M4_20:1.5
	v20061222-1800:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061117-0800:1.5
	v20061013-1330:1.4
	v20060925-1700:1.2.2.1
	v20060919-0800:1.2.2.1
	M1_20:1.4
	v20060904-1500:1.4
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060626-1420:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.13
date	2008.05.21.17.10.18;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	b114834577a4567;

1.12
date	2008.05.21.16.42.11;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	6f43483450e34567;

1.11
date	2007.06.08.18.48.07;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	27304669a4664567;

1.10
date	2007.06.05.19.16.08;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	24e4665b6774567;

1.9
date	2007.05.28.13.33.38;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	3e0b465ada314567;

1.8
date	2007.05.17.22.14.15;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	63f0464cd3b74567;

1.7
date	2007.03.19.16.49.06;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	5c9c45febf004567;

1.6
date	2007.02.28.19.39.40;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	b7645e5da7b4567;

1.5
date	2006.11.02.21.58.31;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.04.15.11.59;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.25.19.02.06;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.26.16.49.34;	author atikhomirov;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.06.26.14.05.04;	author atikhomirov;	state Exp;
branches;
next	;

1.2.2.1
date	2006.09.13.23.07.20;	author rgronback;	state Exp;
branches;
next	;


desc
@@


1.13
log
@[139126] respect implementation bundle of custom borders and layouts: documenting, depreciating FQNSwitch as it's only use is to detect dependencies which doesn't require rest of the code to be there (figure fqns)
@
text
@/*
 * Copyright (c) 2005, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.genmodel;

import java.net.URL;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.LinkedList;

import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.gmf.codegen.gmfgen.FigureViewmap;
import org.eclipse.gmf.codegen.gmfgen.GMFGenFactory;
import org.eclipse.gmf.codegen.gmfgen.InnerClassViewmap;
import org.eclipse.gmf.codegen.gmfgen.ParentAssignedViewmap;
import org.eclipse.gmf.codegen.gmfgen.Viewmap;
import org.eclipse.gmf.gmfgraph.Border;
import org.eclipse.gmf.gmfgraph.BorderRef;
import org.eclipse.gmf.gmfgraph.ChildAccess;
import org.eclipse.gmf.gmfgraph.Compartment;
import org.eclipse.gmf.gmfgraph.CompoundBorder;
import org.eclipse.gmf.gmfgraph.Connection;
import org.eclipse.gmf.gmfgraph.CustomBorder;
import org.eclipse.gmf.gmfgraph.CustomFigure;
import org.eclipse.gmf.gmfgraph.CustomLayout;
import org.eclipse.gmf.gmfgraph.DiagramLabel;
import org.eclipse.gmf.gmfgraph.Figure;
import org.eclipse.gmf.gmfgraph.FigureDescriptor;
import org.eclipse.gmf.gmfgraph.FigureGallery;
import org.eclipse.gmf.gmfgraph.FigureRef;
import org.eclipse.gmf.gmfgraph.GMFGraphPackage;
import org.eclipse.gmf.gmfgraph.LayoutRef;
import org.eclipse.gmf.gmfgraph.Node;
import org.eclipse.gmf.gmfgraph.RealFigure;
import org.eclipse.gmf.gmfgraph.util.FigureQualifiedNameSwitch;
import org.eclipse.gmf.gmfgraph.util.RuntimeFQNSwitch;
import org.eclipse.gmf.gmfgraph.util.RuntimeLiteFQNSwitch;
import org.eclipse.gmf.graphdef.codegen.FigureGenerator;
import org.eclipse.gmf.graphdef.codegen.MapModeCodeGenStrategy;

/**
 * @@author artem
 */
public class InnerClassViewmapProducer extends DefaultViewmapProducer {

	private final FigureGenerator figureGenerator;
	private final FigureQualifiedNameSwitch fqnSwitch;

	public InnerClassViewmapProducer() {
		this(null, MapModeCodeGenStrategy.DYNAMIC, null);
	}

	public InnerClassViewmapProducer(String runtimeToken, MapModeCodeGenStrategy mapModeCodeGenStrategy, URL[] dynamicFigureTemplates) {
		// FIXME get rid of fqnSwitch altogether
		this.fqnSwitch = "lite".equalsIgnoreCase(runtimeToken) ? new RuntimeLiteFQNSwitch() : new RuntimeFQNSwitch();
		figureGenerator = new FigureGenerator(runtimeToken, null, mapModeCodeGenStrategy, null, true, dynamicFigureTemplates);
	}

	@@Override
	public Viewmap create(Node node) {
		if (node.getFigure() == null) {
			return super.create(node);
		}
		final Viewmap viewmap = createViewmap(node.getFigure());
		setupResizeConstraints(viewmap, node);
		setupLayoutType(viewmap, node);
		setupDefaultSize(viewmap, node);
		return viewmap;
	}
	
	@@Override
	public Viewmap create(Connection link) {
		if (link.getFigure() == null) {
			return super.create(link);
		}
		return createViewmap(link.getFigure());
	}

	@@Override
	public Viewmap create(DiagramLabel diagramLabel) {
		if (diagramLabel.getFigure() == null) {
			return super.create(diagramLabel);
		}
		if (diagramLabel.getAccessor() == null) {
			return createViewmap(diagramLabel.getFigure());
		} else {
			return createViewmap(diagramLabel.getFigure(), diagramLabel.getAccessor());
		}
	}
	
	@@Override
	public Viewmap create(Compartment compartment) {
		if (compartment.getFigure() == null){
			return super.create(compartment);
		}
		if (compartment.getAccessor() == null) {
			return createViewmap(compartment.getFigure());
		} else {
			return createViewmap(compartment.getFigure(), compartment.getAccessor());
		}
	}

	private Viewmap createViewmap(FigureDescriptor figureDescriptor) {
		Viewmap result;
		if (figureDescriptor.getActualFigure() == null) {
			throw new NullPointerException();
		}
		final Figure figure = figureDescriptor.getActualFigure();
		if (figure instanceof RealFigure && isBareInstance((RealFigure) figure)) {
			FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
			v.setFigureQualifiedClassName(figureGenerator.fqnSwitch(figure));
			result = v;
			// XXX perhaps, create SnippetViewmap when there are no children but some props
		} else {
			InnerClassViewmap v = GMFGenFactory.eINSTANCE.createInnerClassViewmap();
			v.setClassBody(figureGenerator.go(figureDescriptor));
			v.setClassName(getCompilationUnitName(figureDescriptor));
			result = v;
		}
		setupPluginDependencies(result, figureDescriptor.getActualFigure());
		setupStyleAttributes(result, figureDescriptor.getActualFigure());
		return result;
	}

	private Viewmap createViewmap(FigureDescriptor owner, ChildAccess labelAccess) {
		ParentAssignedViewmap v = GMFGenFactory.eINSTANCE.createParentAssignedViewmap();
		v.setGetterName(labelAccess.getAccessor());
		v.setFigureQualifiedClassName(figureGenerator.fqnSwitch(labelAccess.getFigure()));
		setupStyleAttributes(v, labelAccess.getFigure());
		return v;
	}

	// XXX shouldn't that reside in superclass - 
	// use of fqnSwitch is questionable anyway, for all but first gallery
	// we don't need to delegate to switch, and should rather use 
	// implementationBundle field directly (though that's true only
	// if borders and layouts are from another FG, if there are FigureRefs,
	// delegating to fqnSwitch to find out dependencies may be reasonable)
	private void setupPluginDependencies(Viewmap viewmap, Figure figure){
		LinkedHashSet<String> allRequired = new LinkedHashSet<String>();
		for (FigureGallery gallery : findAllGalleriesForImport(figure)) {
			allRequired.addAll(Arrays.asList(fqnSwitch.getDependencies(gallery)));
		}
		viewmap.getRequiredPluginIDs().addAll(allRequired);
	}

	// public to have access from tests. FIXME may need extra check for endless
	// recursion (like CompoundBorder.outer = BorderRef which points to same CompoundBorder)
	public static Collection<FigureGallery> findAllGalleriesForImport(Figure figure) {
		LinkedHashSet<FigureGallery> rv = new LinkedHashSet<FigureGallery>();
		rv.add(findAncestorFigureGallery(figure));
		LinkedList<Figure> queue = new LinkedList<Figure>();
		queue.add(figure);
		do {
			final RealFigure fig;
			if (queue.peek() instanceof RealFigure) {
				fig = (RealFigure) queue.removeFirst();
			} else if (queue.peek() instanceof FigureRef) {
				fig = ((FigureRef) queue.removeFirst()).getFigure();
			} else {
				assert false; // no more known subclasses of Figure at the time.
				queue.removeFirst();
				continue;
			}
			if (fig.getLayout() instanceof LayoutRef && ((LayoutRef) fig.getLayout()).getActual() instanceof CustomLayout) {
				rv.add(findAncestorFigureGallery(((LayoutRef) fig.getLayout()).getActual()));
			}
			if (fig.getBorder() != null) {
				LinkedList<Border> borderQueue = new LinkedList<Border>();
				borderQueue.add(fig.getBorder());
				do {
					if (borderQueue.peek() instanceof BorderRef) {
						borderQueue.add(((BorderRef) borderQueue.peek()).getActual());
					} else if (borderQueue.peek() instanceof CompoundBorder) {
						CompoundBorder b = (CompoundBorder) borderQueue.peek();
						borderQueue.addLast(b.getInner());
						borderQueue.addLast(b.getOuter());
					} else if (borderQueue.peek() instanceof CustomBorder) {
						rv.add(findAncestorFigureGallery(borderQueue.peek()));
					}
					borderQueue.removeFirst(); // effectively removes any null value as well
				} while (!borderQueue.isEmpty());
			}
			queue.addAll(fig.getChildren());
		} while (!queue.isEmpty());
		rv.remove(null);
		return rv;
	}

	public static FigureGallery findAncestorFigureGallery(EObject figure){
		EObject current = figure;
		while (true){
			EObject next = current.eContainer();
			if (next == null){
				return null;
			} else if (next instanceof FigureGallery){
				return (FigureGallery)next;
			} else {
				current = next;
			}
		}
	}

	private static String getCompilationUnitName(FigureDescriptor fd) {
		// XXX either use Util.ext or have some template to invoke
		return CodeGenUtil.validJavaIdentifier(CodeGenUtil.capName(fd.getName()));
	}

	private static boolean isBareInstance(RealFigure figure) {
		if (!figure.getChildren().isEmpty()) {
			return false;
		}
		final Collection<EStructuralFeature> featuresToCheck = new LinkedList<EStructuralFeature>(figure.eClass().getEAllStructuralFeatures());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getRealFigure_Name());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getRealFigure_Children());
		if (figure instanceof CustomFigure) {
			featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getCustomClass_QualifiedClassName());
			featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getCustomFigure_CustomChildren());
		}
		for (EStructuralFeature next : featuresToCheck) {
			if (next.isDerived()) {
				continue;
			}
			if (figure.eIsSet(next)) {
				return false;
			}
		}
		return true;
	}
}
@


1.12
log
@[139126] respect implementation bundle of custom borders and layouts
@
text
@d144 6
@


1.11
log
@correct copyright year
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2007 Borland Software Corporation
d17 1
d28 2
d32 1
d34 1
d36 1
d41 1
d43 1
d145 48
a192 4
		FigureGallery gallery = findAncestorFigureGallery(figure);
		if (gallery != null){
			viewmap.getRequiredPluginIDs().addAll(Arrays.asList(fqnSwitch.getDependencies(gallery)));
		}
d195 1
a195 1
	public static FigureGallery findAncestorFigureGallery(Figure figure){
@


1.10
log
@fix failing ViewmapProducersTest#testAbleToProcessFigureAccessor. ChildAccess should be the sole point to control naming for figure getters, hence NamingStrategy no needed any more. Plus, since ChildAccess always has a reference to figure, we may specify exact class names in ParentAssignedViewmap
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
@


1.9
log
@FigureDescriptor with explicit means to access children introduced into gmfgraph
@
text
@a32 1
import org.eclipse.gmf.gmfgraph.FigureAccessor;
a34 1
import org.eclipse.gmf.gmfgraph.RealFigure;
d37 1
a42 1
import org.eclipse.gmf.graphdef.codegen.NamingStrategy;
d130 1
a130 3
		// XXX yet another assumption - getter name
		// FIXME introduce feedback to FigureGenerator to let us know exact names
		v.setGetterName(NamingStrategy.getChildFigureGetterName(labelAccess));
a135 10
	// XXX needs review
	private Viewmap createFigureAccessorViewmap(FigureAccessor figureAccess) {
		ParentAssignedViewmap v = GMFGenFactory.eINSTANCE.createParentAssignedViewmap();
		v.setGetterName(figureAccess.getAccessor());
		if (figureAccess.getTypedFigure() != null) {
			v.setFigureQualifiedClassName(figureGenerator.fqnSwitch(figureAccess.getTypedFigure()));
		}
		return v;
	}
	
@


1.8
log
@moving towards not using fqnswitch and java to tell draw2d figure names; let toolsmith to control what draw2d classes are being used; fqnSwitch argument replaced with simple token indicator
@
text
@a16 1
import java.util.HashSet;
a17 1
import java.util.Set;
a21 1
import org.eclipse.emf.ecore.util.EcoreUtil;
d27 1
a27 1
import org.eclipse.gmf.common.codegen.ImportAssistant;
d34 1
d36 1
a36 1
import org.eclipse.gmf.gmfgraph.FigureHandle;
a44 1
import org.eclipse.gmf.internal.common.codegen.NullImportAssistant;
a46 1
 * Stateful. Don't reuse.
a52 1
	private final Set<Figure> processedFigures;
d61 1
a61 2
		processedFigures = new HashSet<Figure>();
		figureGenerator = new FigureGenerator(runtimeToken, mapModeCodeGenStrategy, null, true, dynamicFigureTemplates);
d64 1
d69 1
a69 1
		final Viewmap viewmap = createViewmap(node.getNodeFigure());
d76 1
d81 1
a81 1
		return createViewmap(link.getConnectionFigure());
d84 9
a92 3
	public Viewmap create(DiagramLabel label) {
		if (label.getFigure() == null) {
			return super.create(label);
a93 1
		return createViewmap(label.getFigure());
d96 1
d98 1
a98 2
		FigureHandle handle = compartment.getFigure();
		if (handle == null){
d101 5
a105 1
		return createViewmap(compartment.getFigure());
d107 2
a108 2
	
	private Viewmap createFigureViewmap(Figure figure) {
d110 7
a116 9
		if (EcoreUtil.isAncestor(processedFigures, figure.getParent())) {
			// we generated code for parent, thus (if figure generation logic not changed)
			// all inner figures were generated as well (with accessors), thus, everything
			// we need here is just reference one
			ParentAssignedViewmap v = GMFGenFactory.eINSTANCE.createParentAssignedViewmap();
			// XXX yet another assumption - getter name
			// FIXME introduce feedback to FigureGenerator to let us know exact names
			v.setGetterName(NamingStrategy.INSTANCE.getChildFigureGetterName(figure));
			v.setFigureQualifiedClassName(fqnSwitch.get(figure));
d118 1
d120 4
a123 12
			if (isBareInstance(figure)) {
				FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
				v.setFigureQualifiedClassName(fqnSwitch.get(figure));
				result = v;
				// XXX perhaps, create SnippetViewmap when there are no children but some props
			} else {
				InnerClassViewmap v = GMFGenFactory.eINSTANCE.createInnerClassViewmap();
				ImportAssistant importManager = new NullImportAssistant(null, CodeGenUtil.validJavaIdentifier(figure.getName())); 
				v.setClassBody(figureGenerator.go(figure, importManager));
				v.setClassName(importManager.getCompilationUnitName());
				result = v;
			}
d125 2
a126 4
		if (false == result instanceof ParentAssignedViewmap) {
			setupPluginDependencies(result, figure);
		} // otherwise, dependencies are already there
		processedFigures.add(figure);
d130 8
a137 11
	private Viewmap createViewmap(FigureHandle figure) {
		Viewmap result;
		if (figure instanceof Figure) {
			result = createFigureViewmap((Figure) figure);
		} else if (figure instanceof FigureAccessor) {
			result = createFigureAccessorViewmap((FigureAccessor) figure);
		} else {
			throw new IllegalStateException();
		}
		setupStyleAttributes(result, figure);
		return result;
d140 1
d145 1
a145 1
			v.setFigureQualifiedClassName(figureAccess.getTypedFigure().getQualifiedClassName());
d156 1
a156 1
	
d161 2
a162 2
			if (next instanceof Figure){
				current = next;
d166 1
a166 1
				return null;
d171 6
a176 1
	private static boolean isBareInstance(Figure figure){
d181 2
a182 4
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getIdentity_Name());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getFigure_Children());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getFigureMarker_Parent());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getFigureHandle_ReferencingElements());
a183 1
			featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getCustomClass_BundleName());
@


1.7
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d43 1
d60 1
a60 1
		this(new RuntimeFQNSwitch(), MapModeCodeGenStrategy.DYNAMIC, null);
d63 3
a65 3
	public InnerClassViewmapProducer(FigureQualifiedNameSwitch figureNameSwitch, MapModeCodeGenStrategy mapModeCodeGenStrategy, URL[] dynamicFigureTemplates) {
		assert figureNameSwitch != null;
		fqnSwitch = figureNameSwitch;
d67 1
a67 1
		figureGenerator = new FigureGenerator(fqnSwitch, mapModeCodeGenStrategy, null, true, dynamicFigureTemplates);
@


1.6
log
@[171782] add preference to keep path for dynamic figure templates
@
text
@a17 1
import java.util.Iterator;
a156 1
	@@SuppressWarnings("unchecked")
a177 1
	@@SuppressWarnings("unchecked")
d192 1
a192 2
		for(Iterator it = featuresToCheck.iterator(); it.hasNext();) {
			final EStructuralFeature next = (EStructuralFeature) it.next();
@


1.5
log
@JET templates for gmfgraph model replaced with Xpand counterparts.
MapMode handling simplified
@
text
@d14 1
d60 1
a60 1
		this(new RuntimeFQNSwitch(), MapModeCodeGenStrategy.DYNAMIC);
d63 1
a63 1
	public InnerClassViewmapProducer(FigureQualifiedNameSwitch figureNameSwitch, MapModeCodeGenStrategy mapModeCodeGenStrategy) {
d67 1
a67 1
		figureGenerator = new FigureGenerator(fqnSwitch, mapModeCodeGenStrategy, null, true);
@


1.4
log
@use generics wherever possible
@
text
@d59 1
a59 1
		this(new RuntimeFQNSwitch(), new MapModeCodeGenStrategy.RuntimeUnspecifiedMapMode());
d66 1
a66 1
		figureGenerator = new FigureGenerator(fqnSwitch, mapModeCodeGenStrategy, true);
@


1.3
log
@[155230] mgolubev ViewmapProducer to deduce DefaultSizeAttributes from figure's preferred size
@
text
@d56 1
a56 1
	private final Set/*<Figure>*/ processedFigures;
d65 1
a65 1
		processedFigures = new HashSet();
d157 1
d179 1
d184 1
a184 1
		final Collection featuresToCheck = new LinkedList(figure.eClass().getEAllStructuralFeatures());
@


1.2
log
@[mgolubev] #148402 Do not create unlimited number of font/color resources.
@
text
@d76 1
@


1.2.2.1
log
@[153901] Updated copyright date from 2005 to 2005, 2006 for those changed in CVS in 2006 (based on Tom/Anthony's script).
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
@


1.1
log
@no api packages, classes are for internal use only
@
text
@d66 1
a66 1
		figureGenerator = new FigureGenerator(fqnSwitch, mapModeCodeGenStrategy);
@

