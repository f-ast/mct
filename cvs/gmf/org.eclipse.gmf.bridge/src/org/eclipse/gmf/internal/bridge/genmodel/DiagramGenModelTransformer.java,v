head	1.44;
access;
symbols
	v20081015-1925:1.44
	v20080917-1925:1.43
	v20080903-1520:1.42
	v20080827-1520:1.40
	v20080813-1520:1.39
	v20080722-1827:1.38
	v20080716-1642:1.38
	R2_1_maintenance:1.37.0.2
	Root_R2_1_maintenance:1.37
	R2_1_0:1.37
	v20080528-1052:1.35
	v20080507-1326:1.35
	v20080417-1610:1.34
	v20080222-1200:1.32
	v20070809-0000:1.32
	R2_0_maintenance:1.32.0.2
	R2_0:1.32
	R4_20:1.32
	v20070621-0000:1.32
	RC3_20:1.32
	v20070608-1300:1.32
	v20070605-1400:1.31
	v20070601-1400:1.31
	v20070525-1500:1.30
	v20070518-1300:1.29
	v20070504-1000:1.27
	v20070427-0600:1.23
	v20070420-1000:1.22
	v20070413-1300:1.22
	v20070405-1100:1.22
	v20070330-1300:1.21
	v20070322-1100:1.21
	v20060316-0600:1.20
	v20070228-2000:1.20
	v20070208-1800:1.19
	M4_20:1.14
	v20061222-1800:1.14
	v20061214-0000:1.13
	M3_20:1.12
	v20061117-0800:1.12
	v20061013-1330:1.7
	v20060925-1700:1.1.2.1
	v20060919-0800:1.1.2.1
	M1_20:1.3
	v20060904-1500:1.3
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060626-1420:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.44
date	2008.10.14.12.53.37;	author atikhomirov;	state Exp;
branches;
next	1.43;
commitid	2e34448f4964f4567;

1.43
date	2008.09.17.12.26.46;	author atikhomirov;	state Exp;
branches;
next	1.42;
commitid	2dc248d0f7854567;

1.42
date	2008.08.29.18.54.12;	author atikhomirov;	state Exp;
branches;
next	1.41;
commitid	48fe48b845d34567;

1.41
date	2008.08.28.21.22.14;	author atikhomirov;	state Exp;
branches;
next	1.40;
commitid	3cb748b717054567;

1.40
date	2008.08.26.20.53.03;	author atikhomirov;	state Exp;
branches;
next	1.39;
commitid	3a8e48b46d2c4567;

1.39
date	2008.08.13.13.49.08;	author dstadnik;	state Exp;
branches;
next	1.38;
commitid	43c548a2e64b4567;

1.38
date	2008.07.02.16.47.45;	author atikhomirov;	state Exp;
branches;
next	1.37;
commitid	3368486bb1304567;

1.37
date	2008.06.05.18.24.37;	author dstadnik;	state Exp;
branches;
next	1.36;
commitid	481a48482f554567;

1.36
date	2008.06.04.12.42.01;	author dstadnik;	state Exp;
branches;
next	1.35;
commitid	2ef148468d984567;

1.35
date	2008.05.07.13.56.03;	author atikhomirov;	state Exp;
branches;
next	1.34;
commitid	3a1c4821b4f34567;

1.34
date	2008.04.17.11.58.50;	author atikhomirov;	state Exp;
branches;
next	1.33;
commitid	330f48073b794567;

1.33
date	2008.04.14.08.37.46;	author atikhomirov;	state Exp;
branches;
next	1.32;
commitid	1b03480317d94567;

1.32
date	2007.06.08.18.47.22;	author atikhomirov;	state Exp;
branches;
next	1.31;
commitid	266f4669a4394567;

1.31
date	2007.05.28.13.33.38;	author atikhomirov;	state Exp;
branches;
next	1.30;
commitid	3e0b465ada314567;

1.30
date	2007.05.22.17.27.44;	author atikhomirov;	state Exp;
branches;
next	1.29;
commitid	6a254653280f4567;

1.29
date	2007.05.16.17.33.19;	author atikhomirov;	state Exp;
branches;
next	1.28;
commitid	3644464b405e4567;

1.28
date	2007.05.11.16.01.19;	author ashatalin;	state Exp;
branches;
next	1.27;
commitid	44bd4644934e4567;

1.27
date	2007.05.04.09.37.48;	author dstadnik;	state Exp;
branches;
next	1.26;
commitid	5eec463afeec4567;

1.26
date	2007.05.03.09.58.36;	author dstadnik;	state Exp;
branches;
next	1.25;
commitid	513e4639b24a4567;

1.25
date	2007.04.30.11.55.01;	author atikhomirov;	state Exp;
branches;
next	1.24;
commitid	27964635d9144567;

1.24
date	2007.04.27.11.23.39;	author dstadnik;	state Exp;
branches;
next	1.23;
commitid	10844631dd3a4567;

1.23
date	2007.04.26.15.39.46;	author dstadnik;	state Exp;
branches;
next	1.22;
commitid	38554630c7c14567;

1.22
date	2007.04.04.16.30.49;	author atikhomirov;	state Exp;
branches;
next	1.21;
commitid	542c4613d2b84567;

1.21
date	2007.03.19.16.49.06;	author atikhomirov;	state Exp;
branches;
next	1.20;
commitid	5c9c45febf004567;

1.20
date	2007.02.22.16.55.47;	author dstadnik;	state Exp;
branches;
next	1.19;
commitid	340745ddcb124567;

1.19
date	2007.02.08.18.06.29;	author atikhomirov;	state Exp;
branches;
next	1.18;
commitid	51d45cb66a54567;

1.18
date	2007.01.12.13.25.50;	author dstadnik;	state Exp;
branches;
next	1.17;
commitid	615d45a78c5e4567;

1.17
date	2007.01.10.17.38.34;	author dstadnik;	state Exp;
branches;
next	1.16;
commitid	1adc45a524994567;

1.16
date	2007.01.09.13.12.26;	author dstadnik;	state Exp;
branches;
next	1.15;
commitid	1a9645a394b94567;

1.15
date	2007.01.09.13.11.21;	author dstadnik;	state Exp;
branches;
next	1.14;
commitid	196745a394784567;

1.14
date	2006.12.21.17.14.30;	author dstadnik;	state Exp;
branches;
next	1.13;
commitid	7164458ac0f54567;

1.13
date	2006.11.24.18.02.54;	author dstadnik;	state Exp;
branches;
next	1.12;
commitid	7fa2456733cd4567;

1.12
date	2006.10.19.15.22.01;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.19.11.07.57;	author radvorak;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.18.14.21.19;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.10.18.09.57.01;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.17.13.08.15;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.03.18.11.05;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.28.18.21.16;	author radvorak;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.15.20.44.17;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.11.18.21.40;	author ashatalin;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.04.15.11.59;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.25.18.32.35;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.26.14.05.04;	author atikhomirov;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.09.13.23.07.20;	author rgronback;	state Exp;
branches;
next	;


desc
@@


1.44
log
@[174961] Menu actions - refactor LoadResource and CreateShortcut actions to use generic genmodel action infrastructure
@
text
@/*
 * Copyright (c) 2005, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.genmodel;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.emf.codegen.ecore.genmodel.GenClassifier;
import org.eclipse.emf.codegen.ecore.genmodel.GenDataType;
import org.eclipse.emf.codegen.ecore.genmodel.GenFeature;
import org.eclipse.emf.codegen.ecore.genmodel.GenModel;
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EModelElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.gmf.codegen.gmfgen.*;
import org.eclipse.gmf.gmfgraph.Alignment;
import org.eclipse.gmf.gmfgraph.AlignmentFacet;
import org.eclipse.gmf.gmfgraph.Compartment;
import org.eclipse.gmf.gmfgraph.DiagramElement;
import org.eclipse.gmf.gmfgraph.Direction;
import org.eclipse.gmf.gmfgraph.LabelOffsetFacet;
import org.eclipse.gmf.gmfgraph.Node;
import org.eclipse.gmf.gmfgraph.VisualFacet;
import org.eclipse.gmf.internal.bridge.History;
import org.eclipse.gmf.internal.bridge.Knowledge;
import org.eclipse.gmf.internal.bridge.NaiveIdentifierDispenser;
import org.eclipse.gmf.internal.bridge.VisualIdentifierDispenser;
import org.eclipse.gmf.internal.bridge.genmodel.navigator.NavigatorHandler;
import org.eclipse.gmf.internal.bridge.naming.gen.GenModelNamingMediator;
import org.eclipse.gmf.internal.bridge.tooldef.PaletteHandler;
import org.eclipse.gmf.mappings.AuditContainer;
import org.eclipse.gmf.mappings.AuditRule;
import org.eclipse.gmf.mappings.AuditedMetricTarget;
import org.eclipse.gmf.mappings.CanvasMapping;
import org.eclipse.gmf.mappings.ChildReference;
import org.eclipse.gmf.mappings.CompartmentMapping;
import org.eclipse.gmf.mappings.Constraint;
import org.eclipse.gmf.mappings.DesignLabelMapping;
import org.eclipse.gmf.mappings.DiagramElementTarget;
import org.eclipse.gmf.mappings.DomainAttributeTarget;
import org.eclipse.gmf.mappings.DomainElementTarget;
import org.eclipse.gmf.mappings.ElementInitializer;
import org.eclipse.gmf.mappings.FeatureInitializer;
import org.eclipse.gmf.mappings.FeatureLabelMapping;
import org.eclipse.gmf.mappings.FeatureSeqInitializer;
import org.eclipse.gmf.mappings.FeatureValueSpec;
import org.eclipse.gmf.mappings.GMFMapPackage;
import org.eclipse.gmf.mappings.LabelMapping;
import org.eclipse.gmf.mappings.Language;
import org.eclipse.gmf.mappings.LinkConstraints;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.Mapping;
import org.eclipse.gmf.mappings.MappingEntry;
import org.eclipse.gmf.mappings.MetricContainer;
import org.eclipse.gmf.mappings.MetricRule;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.NodeReference;
import org.eclipse.gmf.mappings.NotationElementTarget;
import org.eclipse.gmf.mappings.ReferenceNewElementSpec;
import org.eclipse.gmf.mappings.Severity;
import org.eclipse.gmf.mappings.TopNodeReference;

/**
 * Creates generation model from diagram definition.
 * @@author artem
 */
public class DiagramGenModelTransformer extends MappingTransformer {

	private GenEditorGenerator myGenModel;
	protected GenModelMatcher myGenModelMatch;
	private final DiagramRunTimeModelHelper myDRTHelper;
	private final ViewmapProducer myViewmaps;
	private final VisualIdentifierDispenser myVisualIDs;
	private final boolean rcp;
	private final History myHistory;
	private final Map<GenClass, ElementType> myProcessedTypes = new IdentityHashMap<GenClass, ElementType>(); // GenClass -> MetamodelType
	private final Map<org.eclipse.gmf.mappings.ValueExpression, ValueExpression> myProcessedExpressions;

	private final GenModelNamingMediator myNamingStrategy;
	private final PaletteHandler myPaletteProcessor;
	private final NavigatorHandler myNavigatorProcessor;
	private final PropertySheetHandler myPropertySheetProcessor;
	private final EcoreGenModelMatcher myEcoreGenModelMatch;
	private ExternalParser myDesignLabelParser;
	private ExternalParser myAuxParser;
	private GenContextMenu myDiagramContextMenu;

	private GenAuditContext myDefaultAuditContext;

	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, GenModelNamingMediator namingStrategy) {
		this(drtHelper, namingStrategy, new InnerClassViewmapProducer(), new NaiveIdentifierDispenser(), false);
	}

	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, GenModelNamingMediator namingStrategy, ViewmapProducer viewmaps, VisualIdentifierDispenser visualIdD, boolean rcp) {
		assert drtHelper != null && namingStrategy != null && viewmaps != null;
		myDRTHelper = drtHelper;
		myNamingStrategy = namingStrategy;
		myViewmaps = viewmaps;
		myVisualIDs = visualIdD;
		this.rcp = rcp;
		myHistory = new History();
		myPaletteProcessor = new PaletteHandler();
		myNavigatorProcessor = new NavigatorHandler();
		myPropertySheetProcessor = new PropertySheetHandler();
		myEcoreGenModelMatch = new EcoreGenModelMatcher();
		myProcessedExpressions = new HashMap<org.eclipse.gmf.mappings.ValueExpression, ValueExpression>();
	}

	/**
	 * Optionally set GenModel to match ECore elements against. 
	 * Should be invoked prior to {@@link MappingTransformer#transform(Mapping)}, otherwise has no effect.
	 * Useful for tests (and other cases) when GenModel is not known to EMF 
	 * (and thus can't be obtained using EMF techniques).
	 * @@param emfGenModel EMF GenModel for domain model
	 */
	public void setEMFGenModel(GenModel emfGenModel) {
		myGenModelMatch = new GenModelMatcher(emfGenModel);
	}

	public GenEditorGenerator getResult() {
		return getGenEssence();
	}

	private GenEditorGenerator getGenEssence() {
		if (myGenModel == null) {
			myGenModel = GMFGenFactory.eINSTANCE.createGenEditorGenerator();
		}
		// init editor as well - transformer does not set any property to it, just make sure it's not null
		if (myGenModel.getEditor() == null) {
			myGenModel.setEditor(GMFGenFactory.eINSTANCE.createGenEditorView());
		}
		return myGenModel;
	}

	private GenDiagram getGenDiagram() {
		if (getGenEssence().getDiagram() == null) {
			getGenEssence().setDiagram(GMFGenFactory.eINSTANCE.createGenDiagram());
		}
		return getGenEssence().getDiagram();
	}

	private void initGenPlugin() {
		if (getGenEssence().getPlugin() == null) {
			getGenEssence().setPlugin(GMFGenFactory.eINSTANCE.createGenPlugin());
		}
	}
	
	private void initGenUpdater() {
		if (getGenEssence().getDiagramUpdater() == null) {
			getGenEssence().setDiagramUpdater(GMFGenFactory.eINSTANCE.createGenDiagramUpdater());
		}
		
	}
	
	private GenNavigator genGenNavigator() {
		if (getGenEssence().getNavigator() == null) {
			getGenEssence().setNavigator(GMFGenFactory.eINSTANCE.createGenNavigator());
		}
		return getGenEssence().getNavigator();
	}

	private Palette getGenPalette() {
		Palette p = getGenDiagram().getPalette();
		if (p == null) {
			p = GMFGenFactory.eINSTANCE.createPalette();
			getGenDiagram().setPalette(p);
		}
		return p;
	}

	private GenPropertySheet getPropertySheet() {
		if (getGenEssence().getPropertySheet() == null) {
			getGenEssence().setPropertySheet(GMFGenFactory.eINSTANCE.createGenPropertySheet());
		}
		return getGenEssence().getPropertySheet();
	}

	private GenParsers getGenParsers() {
		// XXX meanwhile, we don't set any attributes to GenParsers (rather delegating to old, deprecated)
		if (getGenEssence().getLabelParsers() == null) {
			getGenEssence().setLabelParsers(GMFGenFactory.eINSTANCE.createGenParsers());
			// unless bug #235113 is fixed, always do ParserService
			getGenEssence().getLabelParsers().setExtensibleViaService(true);
		}
		return getGenEssence().getLabelParsers();
	}

	private GenContextMenu getDiagramContextMenu() {
		if (myDiagramContextMenu == null) {
			myDiagramContextMenu = GMFGenFactory.eINSTANCE.createGenContextMenu();
			myDiagramContextMenu.getContext().add(getGenDiagram());
		}
		return myDiagramContextMenu;
	}

	protected void process(CanvasMapping mapping) {
		if (myGenModelMatch == null && mapping.getDomainModel() != null) {
			myGenModelMatch = new GenModelMatcher(mapping.getDomainModel());
		}
		myHistory.purge();
		if (mapping.getPalette() != null) {
			myPaletteProcessor.initialize(getGenPalette());
			myPaletteProcessor.process(mapping.getPalette());
		}
		if (!rcp) {
			myNavigatorProcessor.initialize(getGenDiagram(), genGenNavigator());
		}
		GenPackage primaryPackage = findGenPackage(mapping.getDomainModel());
		getGenEssence().setDomainGenModel(primaryPackage == null ? null : primaryPackage.getGenModel());
		getGenDiagram().setDomainDiagramElement(findGenClass(mapping.getDomainMetaElement()));
		getGenDiagram().setDiagramRunTimeClass(findRunTimeClass(mapping));
		getGenDiagram().setVisualID(myVisualIDs.get(getGenDiagram()));
		getGenDiagram().setViewmap(myViewmaps.create(mapping.getDiagramCanvas()));
		getGenDiagram().setIconProviderPriority(ProviderPriority.LOW_LITERAL); // override ElementTypeIconProvider
		getGenDiagram().setValidationProviderPriority(ProviderPriority.LOW_LITERAL); // otherwise it's not available
		if (getGenDiagram().getDomainDiagramElement() != null) {
			// since diagram is the first entity to process consider it defines metamodel type
			getGenDiagram().setElementType(GMFGenFactory.eINSTANCE.createMetamodelType());
			myProcessedTypes.put(getGenDiagram().getDomainDiagramElement(), getGenDiagram().getElementType());
		} else {
			getGenDiagram().setElementType(GMFGenFactory.eINSTANCE.createNotationType());
		}
		
		initGenPlugin();
		initGenUpdater();

		myPropertySheetProcessor.initialize(getPropertySheet());
		myPropertySheetProcessor.process(mapping);
		addPreferencePages(getGenDiagram());
		
		if (rcp) {
			if (getGenEssence().getApplication() == null) {
				GenApplication app = GMFGenFactory.eINSTANCE.createGenApplication();
				addContributions(app);
				getGenEssence().setApplication(app);
			}
		}
		// XXX actually, better do it once whole transformation is complete
		if (getGenDiagram().generateCreateShortcutAction()) {
			getDiagramContextMenu().getItems().add(GMFGenFactory.eINSTANCE.createCreateShortcutAction());
		}
		// XXX ask Vano, if it's reasonable to generate LoadResourceAction only when there are shortcuts?
		getDiagramContextMenu().getItems().add(GMFGenFactory.eINSTANCE.createLoadResourceAction());
		
		
		// set class names
		myNamingStrategy.feed(getGenDiagram(), mapping);
	}

	protected void process(TopNodeReference topNode) {
		final NodeMapping nme = topNode.getChild();
		assert nme != null;
		assertNodeMapping(nme);
		
		GenTopLevelNode genNode = GMFGenFactory.eINSTANCE.createGenTopLevelNode();
		getGenDiagram().getTopLevelNodes().add(genNode);
		genNode.setDiagramRunTimeClass(findRunTimeClass(nme));
		genNode.setModelFacet(createModelFacet(topNode));
		genNode.setVisualID(myVisualIDs.get(genNode));
		genNode.setViewmap(myViewmaps.create((Node) nme.getDiagramNode()));
		setupElementType(genNode); 
		myPaletteProcessor.process(nme, genNode);

		// set class names
		myNamingStrategy.feed(genNode, nme);
		
		processAbstractNode(nme, genNode);
		myHistory.log(nme, genNode);
		
		if (!rcp) {
			myNavigatorProcessor.process(genNode);
		}
	}
	
	protected void process(AuditContainer audits) {
		if(audits != null) {
			getGenEssence().setAudits(createGenAuditRoot(audits));	
		}
	}	
	
	protected void process(MetricContainer metrics) {
		if(metrics != null) {
			GenMetricContainer genMetricContainer = GMFGenFactory.eINSTANCE.createGenMetricContainer();
			for (MetricRule next : metrics.getMetrics()) {
				genMetricContainer.getMetrics().add(createGenMetric(next));				
			}
			getGenEssence().setMetrics(genMetricContainer);
		}
	}

	private void process(ChildReference childNodeRef, GenChildContainer container) {
		final NodeMapping childNodeMapping = childNodeRef.getChild();
		assert childNodeMapping != null;
		assertNodeMapping(childNodeMapping);

		GenChildNode childNode;
		if (!myHistory.isKnownChildNode(childNodeMapping)) {
			childNode = createGenChildNode(childNodeRef);
		} else {
			GenChildNode[] alreadyKnownChildren = myHistory.findChildNodes(childNodeMapping);

			childNode = null;
			for (int i = 0; i < alreadyKnownChildren.length; i++) {
				if (matchChildReferenceFeatures(childNodeRef, alreadyKnownChildren[i])) {
					childNode = alreadyKnownChildren[i];
					break;
				}
			}
			if (childNode == null) { // no match
				childNode = createGenChildNode(childNodeRef);
			}
		}
		if (container instanceof GenCompartment && childNodeMapping.getChildren().size() > 0) {
			// TODO just layout from childNodeMapping.getDiagramNode()
			((GenCompartment)container).setListLayout(false);
		}
		container.getChildNodes().add(childNode);
		if (!rcp) {
			myNavigatorProcessor.process(childNode, container);
		}
	}

	/**
	 * Handle case when second-level ChildReference references existing nodemapping, but 
	 * with different containment/children reference. 
	 * @@see https://bugs.eclipse.org/bugs/show_bug.cgi?id=129552
	 */
	private static boolean matchChildReferenceFeatures(ChildReference childNodeRef, GenChildNode childNode) {
		final boolean containmentFeatureMatch;
		final boolean childrenFeatureMatch;
		if (childNode.getModelFacet() == null || childNode.getModelFacet().getContainmentMetaFeature() == null) {
			containmentFeatureMatch = (null == childNodeRef.getContainmentFeature());
		} else {
			// seems legal to use '==' because features should came from the same model
			containmentFeatureMatch = childNodeRef.getContainmentFeature() == childNode.getModelFacet().getContainmentMetaFeature().getEcoreFeature();
		}
		if (childNode.getModelFacet() == null || childNode.getModelFacet().getChildMetaFeature() == null) {
			childrenFeatureMatch = (null == childNodeRef.getChildrenFeature());
		} else {
			if (childNodeRef.getChildrenFeature() == null) {
				// likely, childMetaFeature in model facet was derived from containment feature 
				childrenFeatureMatch = childNode.getModelFacet().getChildMetaFeature() == childNode.getModelFacet().getContainmentMetaFeature();
			} else {
				// honest check
				childrenFeatureMatch = childNode.getModelFacet().getChildMetaFeature().getEcoreFeature() == childNodeRef.getChildrenFeature();
			}
		}
		return containmentFeatureMatch && childrenFeatureMatch;
	}

	private GenChildNode createGenChildNode(ChildReference childNodeRef) {
		final NodeMapping childNodeMapping = childNodeRef.getChild();
		final GenChildNode childNode;
		final boolean needCompartmentChildrenLabelProcessing;
		if (Knowledge.isPureLabelNode(childNodeMapping)) {
			LabelMapping soleLabel = childNodeMapping.getLabelMappings().get(0);
			GenChildLabelNode childLabelNode = GMFGenFactory.eINSTANCE.createGenChildLabelNode();
			childLabelNode.setViewmap(myViewmaps.create(soleLabel.getDiagramLabel()));
			childLabelNode.setLabelModelFacet(createLabelModelFacet(soleLabel));
			childLabelNode.setLabelReadOnly(soleLabel.isReadOnly());
			childLabelNode.setLabelElementIcon(soleLabel.getDiagramLabel().isElementIcon());
			childNode = childLabelNode;
			needCompartmentChildrenLabelProcessing = false;
		} else if (((Node) childNodeMapping.getDiagramNode()).getAffixedParentSide() != Direction.NONE_LITERAL){
			GenChildSideAffixedNode sideAffixedNode = GMFGenFactory.eINSTANCE.createGenChildSideAffixedNode(); 
			sideAffixedNode.setViewmap(myViewmaps.create((Node) childNodeMapping.getDiagramNode()));
			String positionConstantName = getAffixedSideAsPositionConstantsName((Node) childNodeMapping.getDiagramNode());
			sideAffixedNode.setPreferredSideName(positionConstantName);
			childNode = sideAffixedNode;
			needCompartmentChildrenLabelProcessing = true;
		} else {
			childNode = GMFGenFactory.eINSTANCE.createGenChildNode();
			childNode.setViewmap(myViewmaps.create((Node) childNodeMapping.getDiagramNode()));
			needCompartmentChildrenLabelProcessing = true;
		}
		myHistory.log(childNodeMapping, childNode);
		getGenDiagram().getChildNodes().add(childNode);

		childNode.setModelFacet(createModelFacet(childNodeRef));
		
		childNode.setDiagramRunTimeClass(findRunTimeClass(childNodeMapping));
		childNode.setVisualID(myVisualIDs.get(childNode));
		setupElementType(childNode); 

		// set class names
		myNamingStrategy.feed(childNode, childNodeMapping);

		myPaletteProcessor.process(childNodeMapping, childNode);
		if (needCompartmentChildrenLabelProcessing) {
			processAbstractNode(childNodeMapping, childNode);
		}
		return childNode;
	}
	
	private String getAffixedSideAsPositionConstantsName(Node diagramNode) {
		Direction affixedSide = diagramNode.getAffixedParentSide(); 
		final String ANY_SIDE = "NONE"; 
		switch (affixedSide.getValue()){
			case Direction.NONE : 
				throw new IllegalStateException("DiagramNode: " + diagramNode + " is not side-affixed");
			case Direction.EAST :
			case Direction.NORTH :
			case Direction.WEST :
			case Direction.SOUTH :
				return affixedSide.getName();
			
			case Direction.NSEW:
				return ANY_SIDE;
			
			default:
				//Runtime does not support this
				return ANY_SIDE;
		}
	}
	
	private void processAbstractNode(NodeMapping mapping, GenNode genNode) {
		HashMap<CompartmentMapping, GenCompartment> compartments2GenCompartmentsMap = new HashMap<CompartmentMapping, GenCompartment>();
		for (CompartmentMapping compartmentMapping : mapping.getCompartments()) {
			GenCompartment compartmentGen = createGenCompartment(compartmentMapping, genNode);
			compartments2GenCompartmentsMap.put(compartmentMapping, compartmentGen);
		}

		for (ChildReference childNodeRef : mapping.getChildren()) {
// Currently childNodeMapping should has compartment but we plan to make this reference optional
			CompartmentMapping compartmentMapping = childNodeRef.getCompartment();
			GenChildContainer genChildContainer;
			if (compartmentMapping != null && compartments2GenCompartmentsMap.containsKey(compartmentMapping)) {
				genChildContainer = compartments2GenCompartmentsMap.get(compartmentMapping);
			} else {
				genChildContainer = genNode;
			}
			process(childNodeRef, genChildContainer);
		}
		for (LabelMapping labelMapping : mapping.getLabelMappings()) {
			GenNodeLabel label = createNodeLabel(genNode, labelMapping);

			// set class names
			myNamingStrategy.feed(label, labelMapping);
		}
		for (CanvasMapping nextRelatedCanvas : mapping.getRelatedDiagrams()) {
			OpenDiagramBehaviour openDiagramPolicy = GMFGenFactory.eINSTANCE.createOpenDiagramBehaviour();
			// ugly check that nodeMapping is related to owning canvasMapping, iow mapping.getCanvasMapping() == nextRelatedCanvas
			if (nextRelatedCanvas.eResource() != mapping.eResource()) {
				// unless we would like to ask user where to take appropriate .gmfgen...
				openDiagramPolicy.setDiagramKind("FIXME put GenEditorGenerator.modelID value here");
				openDiagramPolicy.setEditorID("FIXME put GenEditorView.id value here");
			}
			genNode.getBehaviour().add(openDiagramPolicy);
		}
	}

	private GenCompartment createGenCompartment(CompartmentMapping mapping, GenNode genNode) {
		Compartment compartment = mapping.getCompartment(); 
		assert compartment != null;
		GenCompartment childCompartment = GMFGenFactory.eINSTANCE.createGenCompartment();
		getGenDiagram().getCompartments().add(childCompartment);
		genNode.getCompartments().add(childCompartment);
		childCompartment.setVisualID(myVisualIDs.get(childCompartment));
		childCompartment.setDiagramRunTimeClass(getChildContainerRunTimeClass());
		childCompartment.setViewmap(myViewmaps.create(mapping.getCompartment()));
		childCompartment.setCanCollapse(compartment.isCollapsible());
		childCompartment.setNeedsTitle(compartment.isNeedsTitle());
		childCompartment.setTitle(compartment.getName());

		// set class names
		myNamingStrategy.feed(childCompartment, mapping);
		return childCompartment;
	}

	protected void process(LinkMapping lme) {
		assertLinkMapping(lme);
		GenLink gl = GMFGenFactory.eINSTANCE.createGenLink();
		getGenDiagram().getLinks().add(gl);
		gl.setModelFacet(createModelFacet(lme));
		gl.setVisualID(myVisualIDs.get(gl));
		myPaletteProcessor.process(lme, gl);
		for (LabelMapping labelMapping : lme.getLabelMappings()) {
			GenLinkLabel label = createLinkLabel(gl, labelMapping);

			// set class names
			myNamingStrategy.feed(label, labelMapping);
		}
		gl.setDiagramRunTimeClass(findRunTimeClass(lme));

		setupElementType(gl);

		// set class names
		myNamingStrategy.feed(gl, lme);

		gl.setViewmap(myViewmaps.create(lme.getDiagramLink()));

		if(lme.getCreationConstraints() != null) {
			gl.setCreationConstraints(createLinkCreationConstraints(lme.getCreationConstraints()));
		}
		
		myHistory.log(lme, gl);
		if (!rcp) {
			myNavigatorProcessor.process(gl);
		}
	}

//	private void process(AppearanceSteward appSteward) {
//		if (appSteward.getAppearanceStyle() == null) {
//			return;
//		}
//		
//	}

	private GenNodeLabel createNodeLabel(GenNode node, LabelMapping mapping) {
		GenNodeLabel label;
		if (mapping.getDiagramLabel().isExternal()) {
			label = GMFGenFactory.eINSTANCE.createGenExternalNodeLabel();
		} else {
			label = GMFGenFactory.eINSTANCE.createGenNodeLabel();
		}
		node.getLabels().add(label);
		label.setVisualID(myVisualIDs.get(label));
		label.setDiagramRunTimeClass(findRunTimeClass(mapping));
		label.setViewmap(myViewmaps.create(mapping.getDiagramLabel()));
		label.setModelFacet(createLabelModelFacet(mapping));
		label.setReadOnly(mapping.isReadOnly());
		label.setElementIcon(mapping.getDiagramLabel().isElementIcon());
		return label;
	}

	private GenLinkLabel createLinkLabel(GenLink link, LabelMapping mapping) {
		GenLinkLabel label = GMFGenFactory.eINSTANCE.createGenLinkLabel();
		link.getLabels().add(label);
		label.setVisualID(myVisualIDs.get(label));
		label.setDiagramRunTimeClass(findRunTimeClass(mapping));
		label.setViewmap(myViewmaps.create(mapping.getDiagramLabel()));
		label.setModelFacet(createLabelModelFacet(mapping));
		label.setReadOnly(mapping.isReadOnly());
		label.setElementIcon(mapping.getDiagramLabel().isElementIcon());
		if (findVF(mapping.getDiagramLabel(), AlignmentFacet.class) != null) {
			AlignmentFacet af = findVF(mapping.getDiagramLabel(), AlignmentFacet.class);
			label.setAlignment(getLinkLabelAlignment(af.getAlignment()));
		}
		LabelOffsetAttributes loa = GMFGenFactory.eINSTANCE.createLabelOffsetAttributes();
		LabelOffsetFacet lof = findVF(mapping.getDiagramLabel(), LabelOffsetFacet.class);
		if (lof != null) {
			loa.setX(lof.getX());
			loa.setY(lof.getY());
		} else {
			// stack labels under link by default
			int weight = link.getLabels().size() + 1;
			loa.setY(weight * 20);
		}
		label.getViewmap().getAttributes().add(loa);
		return label;
	}
	private static <T extends VisualFacet> T findVF(DiagramElement element, Class<T> facetClass) {
		for (VisualFacet vf : element.getFacets()) {
			if (facetClass.isInstance(vf)) {
				return facetClass.cast(vf);
			}
		}
		return null;
	}

	private LinkLabelAlignment getLinkLabelAlignment(Alignment alignment) {
		switch (alignment.getValue()) {
		case Alignment.BEGINNING: return LinkLabelAlignment.SOURCE_LITERAL;
		case Alignment.CENTER: return LinkLabelAlignment.MIDDLE_LITERAL;
		case Alignment.END: return LinkLabelAlignment.TARGET_LITERAL;
		default: throw new IllegalArgumentException("Link doesn't support alignment:" + alignment.getName());
		}
	}

	private LabelModelFacet createLabelModelFacet(LabelMapping mapping) {
		if (mapping instanceof FeatureLabelMapping) {
			FeatureLabelMapping flMapping = (FeatureLabelMapping) mapping;
			FeatureLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureLabelModelFacet();
			for (EAttribute attr : (Collection<? extends EAttribute>) flMapping.getFeatures()) {
				modelFacet.getMetaFeatures().add(findGenFeature(attr));
			}
			for (EAttribute attr : (Collection<? extends EAttribute>) flMapping.getEditableFeatures()) {
				modelFacet.getEditableMetaFeatures().add(findGenFeature(attr));
			}
			modelFacet.setViewPattern(flMapping.getViewPattern());
			modelFacet.setEditorPattern(flMapping.getEditorPattern());
			modelFacet.setEditPattern(flMapping.getEditPattern());
			if (flMapping.eIsSet(GMFMapPackage.eINSTANCE.getFeatureLabelMapping_ViewMethod())) {
				modelFacet.setViewMethod(LabelTextAccessMethod.get(flMapping.getViewMethod().getValue()));
			}
			if (flMapping.eIsSet(GMFMapPackage.eINSTANCE.getFeatureLabelMapping_EditMethod())) {
				modelFacet.setEditMethod(LabelTextAccessMethod.get(flMapping.getEditMethod().getValue()));
			}
			// XXX temp code
			modelFacet.setParser(getOrCreateParser(flMapping));
			// XXX
			return modelFacet;
		}
		if (mapping instanceof DesignLabelMapping) {
			DesignLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createDesignLabelModelFacet();
			modelFacet.setParser(getOrCreateParser((DesignLabelMapping) mapping));
			return modelFacet;
		}
		// create bare instance that points to a ExternalParser
		// this is modification of old contract (though, not breaking change, I believe)
		// that says null modelFacet means use of external parser
		LabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createLabelModelFacet();
		modelFacet.setParser(getOrCreateParser(mapping));
		return modelFacet;
	}

	private void setupElementType(GenNode genNode) {
		if (genNode.getModelFacet() != null) {
			MetamodelType metamodelType = (MetamodelType) myProcessedTypes.get(genNode.getModelFacet().getMetaClass());
			if (metamodelType == null) {
				// this is the first metaclass encounter; consider metamodel type definition
				genNode.setElementType(GMFGenFactory.eINSTANCE.createMetamodelType());
				myProcessedTypes.put(genNode.getModelFacet().getMetaClass(), genNode.getElementType());
			} else {
				// all subsequent encounters lead to specialization definitions
				SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
				specializationType.setMetamodelType(metamodelType);
				genNode.setElementType(specializationType);
			}
		} else {
			genNode.setElementType(GMFGenFactory.eINSTANCE.createNotationType());
		}
	}

	private void setupElementType(GenLink gl) {
		if (gl.getModelFacet() != null) {
			if (gl.getModelFacet() instanceof TypeModelFacet) {
				GenClass metaClass = ((TypeModelFacet) gl.getModelFacet()).getMetaClass();
				MetamodelType metamodelType = (MetamodelType) myProcessedTypes.get(metaClass);
				if (metamodelType == null) {
					// this is the first metaclass encounter; consider metamodel type definition
					gl.setElementType(GMFGenFactory.eINSTANCE.createMetamodelType());
					myProcessedTypes.put(metaClass, gl.getElementType());
				} else {
					// all subsequent encounters lead to specialization definitions
					SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
					specializationType.setMetamodelType(metamodelType);
					gl.setElementType(specializationType);
				}
			} else {
				// ref-based link; specialize null
				SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
				gl.setElementType(specializationType);
			}
		} else {
			gl.setElementType(GMFGenFactory.eINSTANCE.createNotationType());
		}
	}

	private GenClass findRunTimeClass(NodeMapping nme) {
		return myDRTHelper.get(nme);
	}

	private GenClass findRunTimeClass(LinkMapping lme) {
		return myDRTHelper.get(lme);
	}

	private GenClass findRunTimeClass(CanvasMapping mapping) {
		return myDRTHelper.get(mapping);
	}

	private GenClass getChildContainerRunTimeClass() {
		return myDRTHelper.getChildContainerDefault();
	}

	private GenClass findRunTimeClass(LabelMapping mapping) {
		return myDRTHelper.get(mapping);
	}


	private void assertNodeMapping(NodeMapping mapping) {
		assert mapping.getDiagramNode() != null;
		assert checkLabelMappings(mapping);
	}

	private void assertLinkMapping(LinkMapping linkMapping) {
		assert linkMapping.getDiagramLink() != null;
		if (linkMapping.getDomainMetaElement() != null) {
			assert linkMapping.getLinkMetaFeature() != null;
		}
		assert checkLabelMappings(linkMapping);
	}

	private static boolean checkLabelMappings(MappingEntry entry) {
		for (LabelMapping labelMapping : (Collection<? extends LabelMapping>) entry.getLabelMappings()) {
			if (labelMapping instanceof FeatureLabelMapping) {
				final EClass domainElement = labelMapping.getMapEntry().getDomainContext();
				for (EAttribute attr : (Collection<? extends EAttribute>) ((FeatureLabelMapping) labelMapping).getFeatures()) {
					if (!attr.getEContainingClass().isSuperTypeOf(domainElement)) {
						return false;
					}
				}
			}
		}
		return true;
	}

	private GenPackage findGenPackage(EPackage ePackage) {
		if (myGenModelMatch == null) {
			warnNoGenModelMatcher(ePackage);
			return null;
		}
		return myGenModelMatch.findGenPackage(ePackage);
	}

	private GenClass findGenClass(EClass eClass) {
		if (myGenModelMatch == null) {
			warnNoGenModelMatcher(eClass);
			return null;
		}
		return myGenModelMatch.findGenClass(eClass);
	}

	private GenFeature findGenFeature(EStructuralFeature feature) {
		if (myGenModelMatch == null) {
			warnNoGenModelMatcher(feature);
			return null;
		}
		return myGenModelMatch.findGenFeature(feature);
	}
	
	private void warnNoGenModelMatcher(EModelElement element) {
		// TODO : emit warning
	}
	
	private TypeModelFacet createModelFacet(NodeReference anm) {
		final NodeMapping nodeMapping = anm.getChild();
		if (nodeMapping.getDomainContext() == null) {
			return null;
		}
		TypeModelFacet typeModelFacet = setupModelFacet(nodeMapping.getDomainContext(), anm.getContainmentFeature(), anm.getChildrenFeature());
		return setupAux(typeModelFacet, nodeMapping.getDomainSpecialization(), nodeMapping.getDomainInitializer());
	}

	private LinkModelFacet createModelFacet(LinkMapping lme) {
		if (lme.getDomainMetaElement() != null) {
			TypeLinkModelFacet mf = GMFGenFactory.eINSTANCE.createTypeLinkModelFacet();
			mf.setMetaClass(findGenClass(lme.getDomainMetaElement()));
			mf.setContainmentMetaFeature(findGenFeature(lme.getContainmentFeature()));
			mf.setChildMetaFeature(mf.getContainmentMetaFeature());
			mf.setSourceMetaFeature(findGenFeature(lme.getSourceMetaFeature()));
			mf.setTargetMetaFeature(findGenFeature(lme.getLinkMetaFeature()));
			setupAux(mf, lme.getDomainSpecialization(), lme.getDomainInitializer());
			return mf;
		} else if (lme.getLinkMetaFeature() != null) {
			FeatureLinkModelFacet mf = GMFGenFactory.eINSTANCE.createFeatureLinkModelFacet();
			mf.setMetaFeature(findGenFeature(lme.getLinkMetaFeature()));
			return mf;
		}
		return null; // notation link
	}

	private GenLinkConstraints createLinkCreationConstraints(LinkConstraints constraints) {
		LinkMapping lme = constraints.getLinkMapping();
		if(lme == null) {
			return null;
		}				
		GenLinkConstraints genConstraints = GMFGenFactory.eINSTANCE.createGenLinkConstraints();
		Constraint sourceConstraint = constraints.getSourceEnd();
		if(sourceConstraint != null) {
			genConstraints.setSourceEnd(createGenConstraint(sourceConstraint));
		}
		Constraint targetConstraint = constraints.getTargetEnd();
		if(targetConstraint != null) {
			genConstraints.setTargetEnd(createGenConstraint(targetConstraint));
		}		
		return genConstraints; 
	}

	private TypeModelFacet setupModelFacet(EClass domainMetaElement, EStructuralFeature containmentFeature, EStructuralFeature childFeature) {
		TypeModelFacet mf = GMFGenFactory.eINSTANCE.createTypeModelFacet();
		mf.setMetaClass(findGenClass(domainMetaElement));
		mf.setContainmentMetaFeature(findGenFeature(containmentFeature));
		mf.setChildMetaFeature(childFeature == null ? mf.getContainmentMetaFeature() : findGenFeature(childFeature));
		return mf;
	}

	/**
	 * @@return typeModelFacet argument for convenience
	 */
	private TypeModelFacet setupAux(TypeModelFacet typeModelFacet, Constraint spec, ElementInitializer init) {
		// construct model element selector for domain EClass specializations if any exist
		if(spec != null) {
			typeModelFacet.setModelElementSelector(createGenConstraint(spec));
		}
		if(init != null) {
			typeModelFacet.setModelElementInitializer(createElementInitializer(init));			
		}
		return typeModelFacet;
	}

	private GenElementInitializer createElementInitializer(ElementInitializer elementInitializer) {
		if(elementInitializer instanceof FeatureSeqInitializer) {
			FeatureSeqInitializer fsInitializer = (FeatureSeqInitializer) elementInitializer;
			GenFeatureSeqInitializer genFsInitializer = GMFGenFactory.eINSTANCE.createGenFeatureSeqInitializer();
			for (FeatureInitializer next : fsInitializer.getInitializers()) {
				genFsInitializer.getInitializers().add(createGenFeatureInitializer(next));
			}
			if(fsInitializer.eIsSet(GMFMapPackage.eINSTANCE.getFeatureSeqInitializer_ElementClass())) {
				genFsInitializer.setElementClass(findGenClass(fsInitializer.getElementClass()));
			}			
			return genFsInitializer;
		}
		return null;
	}
	
	private GenFeatureInitializer createGenFeatureInitializer(FeatureInitializer featureInitializer) {
		if (featureInitializer instanceof FeatureValueSpec) {
			FeatureValueSpec featureValSpec = (FeatureValueSpec) featureInitializer;				
			GenFeatureValueSpec genFeatureValSpec = GMFGenFactory.eINSTANCE.createGenFeatureValueSpec();
			genFeatureValSpec.setFeature(findGenFeature(featureValSpec.getFeature()));
			ValueExpression value = GMFGenFactory.eINSTANCE.createValueExpression();
			value.setBody(featureValSpec.getValue().getBody());
			genFeatureValSpec.setValue(bindToProvider(featureValSpec.getValue(), value));

			return genFeatureValSpec;
		} else if (featureInitializer instanceof ReferenceNewElementSpec) {
			ReferenceNewElementSpec newElementSpec = (ReferenceNewElementSpec) featureInitializer;
			GenReferenceNewElementSpec genNewElementSpec = GMFGenFactory.eINSTANCE.createGenReferenceNewElementSpec();
			genNewElementSpec.setFeature(findGenFeature(newElementSpec.getFeature()));
			for (FeatureSeqInitializer next : newElementSpec.getNewElementInitializers()) { 
				GenFeatureSeqInitializer nextGenFeatureSeqInitializer = (GenFeatureSeqInitializer)createElementInitializer(next);
				genNewElementSpec.getNewElementInitializers().add(nextGenFeatureSeqInitializer);
			}
			return genNewElementSpec;
		}
		assert false : "Unrecognized FeatureInitializer type"; //$NON-NLS-1$
		return null;
	}

	private static GenLanguage detectGenLanguage(Language mapLang) {
		switch (mapLang.getValue()) {
		case Language.OCL:
			return GenLanguage.OCL_LITERAL;
		case Language.JAVA:
			return GenLanguage.JAVA_LITERAL;
		case Language.REGEXP:
			return GenLanguage.REGEXP_LITERAL;
		case Language.NREGEXP:
			return GenLanguage.NREGEXP_LITERAL;
		case Language.LITERAL :
			return GenLanguage.LITERAL_LITERAL;
		default:
			assert false : mapLang;
		}
		return GenLanguage.OCL_LITERAL;
	}
	
	private GenConstraint createGenConstraint(Constraint constraint) {
		if(constraint.getBody() == null) {
			return null;
		}
		GenConstraint genConstraint = GMFGenFactory.eINSTANCE.createGenConstraint();
		genConstraint.setBody(constraint.getBody());
		return bindToProvider(constraint, genConstraint);
	}
	
	private GenAuditRoot createGenAuditRoot(AuditContainer ac) {
		GenAuditRoot root = GMFGenFactory.eINSTANCE.createGenAuditRoot();
		LinkedList<AuditContainer> containers = new LinkedList<AuditContainer>();
		containers.add(ac);
		// parent container to it's path
		final HashMap<AuditContainer, LinkedList<GenAuditContainer>> pathMap = new HashMap<AuditContainer, LinkedList<GenAuditContainer>>();
		do {
			AuditContainer nextChild = containers.removeFirst();
			GenAuditContainer gac = GMFGenFactory.eINSTANCE.createGenAuditContainer();
			gac.setId(nextChild.getId());
			gac.setName(nextChild.getName());
			gac.setDescription(nextChild.getDescription());
			// FIXME setPath
			if (pathMap.containsKey(nextChild.getParentContainer())) {
				gac.getPath().addAll(pathMap.get(nextChild.getParentContainer()));
			}
			gac.getPath().add(gac);
			// collect next level
			if (nextChild.getChildContainers().size() > 0) {
				containers.addAll(nextChild.getChildContainers());
				pathMap.put(nextChild, new LinkedList<GenAuditContainer>(gac.getPath()));
			}
			root.getCategories().add(gac);
			for (AuditRule next : nextChild.getAudits()) {
				final GenAuditRule auditRule = createGenAudit(next);
				auditRule.setCategory(gac);
				root.getRules().add(auditRule);
				// Here's the logic used to be in GMFGen. Basically, all rules with targets != null
				// get a context (emf.validation), which is a scope or set of elements audit is evaluated against.
				// For certain cases, e.g. diagram elements as audit targets, special logic to select these
				// elements should get generated - to filter diagram views by visualID, and hence
				// there's another implementation of IClientSelector and dedicated context.
				if (auditRule.getTarget() instanceof GenDiagramElementTarget) {
					GenDiagramElementTarget gdet = (GenDiagramElementTarget) auditRule.getTarget();
					// Next used to live in GenDiagramElementTargetImpl#getClientContextID()
					//
					// Present approach relies on id matching not to create duplicating contexts,
					// however, smarter way is to match context's target and its elements.
					StringBuilder buf = new StringBuilder("Ctx"); //$NON-NLS-1$
					for (GenCommonBase nextElement : gdet.getElement()) {
						buf.append('_');
						int id = nextElement.getVisualID();
						if(id < 0) {
							buf.append('n');
						}
						buf.append(id);			
					}
					String clientContextID = buf.toString();
					GenAuditContext ctx = null;
					for (GenAuditContext x : root.getClientContexts()) {
						if (clientContextID.equals(x.getId())) {
							ctx = x;
							break;
						}
					}
					if (ctx == null) {
						ctx = GMFGenFactory.eINSTANCE.createGenAuditContext();
						ctx.setId(clientContextID);
						root.getClientContexts().add(ctx);
					}
					gdet.setContextSelector(ctx);
				} else if (auditRule.getTarget() != null) {
					if (myDefaultAuditContext == null) {
						myDefaultAuditContext = GMFGenFactory.eINSTANCE.createGenAuditContext();
						root.getClientContexts().add(myDefaultAuditContext);
					}
					auditRule.getTarget().setContextSelector(myDefaultAuditContext);
				}
			}
		} while (!containers.isEmpty());
		return root;
	}

	private GenAuditRule createGenAudit(AuditRule audit) {
		GenAuditRule genAudit = GMFGenFactory.eINSTANCE.createGenAuditRule();
		genAudit.setId(audit.getId());
		genAudit.setName(audit.getName());
		genAudit.setMessage(audit.getMessage());
		genAudit.setDescription(audit.getDescription());
		genAudit.setUseInLiveMode(audit.isUseInLiveMode());
		
		if(audit.getTarget() != null) {
			GenRuleTarget genTarget = createRuleTarget(audit.getTarget());
			assert genTarget instanceof GenAuditable;
			if(genTarget instanceof GenAuditable) {
				genAudit.setTarget((GenAuditable)genTarget);
			}
		}
		Constraint rule = audit.getRule();
		if(rule != null) {
			genAudit.setRule(createGenConstraint(rule));
		}

		Severity severity = audit.getSeverity();
		GenSeverity genSeverity = null;
		if(severity == Severity.INFO_LITERAL) {
			genSeverity = GenSeverity.INFO_LITERAL;
		} else if(severity == Severity.WARNING_LITERAL) {
			genSeverity = GenSeverity.WARNING_LITERAL;
		} else if(severity == Severity.ERROR_LITERAL) {
			genSeverity = GenSeverity.ERROR_LITERAL;
		}
		if(genSeverity != null) {
			genAudit.setSeverity(genSeverity);
		}
		return genAudit;
	} 
	
	private GenRuleTarget createRuleTarget(EObject ruleTarget) {		
		if (ruleTarget instanceof DomainElementTarget) {
			DomainElementTarget domainTarget = (DomainElementTarget)ruleTarget;
			GenDomainElementTarget genDomainTarget = GMFGenFactory.eINSTANCE.createGenDomainElementTarget();
			genDomainTarget.setElement(domainTarget.getElement() != null ? findGenClass(domainTarget.getElement()) : null);
			return genDomainTarget;
		} else if (ruleTarget instanceof NotationElementTarget) {
			NotationElementTarget notationTarget = (NotationElementTarget) ruleTarget;
			GenNotationElementTarget genNotationTarget = GMFGenFactory.eINSTANCE.createGenNotationElementTarget();
			genNotationTarget.setElement(notationTarget.getElement() != null ? findGenClass(notationTarget.getElement()) : null);
			return genNotationTarget;

		} else if (ruleTarget instanceof DiagramElementTarget) {
			GenDiagramElementTarget diagramTarget = GMFGenFactory.eINSTANCE.createGenDiagramElementTarget();
			MappingEntry mappingEntry = ((DiagramElementTarget) ruleTarget).getElement();
			if (mappingEntry != null) {
				LinkMapping lm = mappingEntry instanceof LinkMapping ? (LinkMapping) mappingEntry : null;
				GenCommonBase genBase = null;				
				if (lm != null) {
					genBase = myHistory.find(lm);
					assert genBase != null;
					if(genBase != null) {
						diagramTarget.getElement().add(genBase);
					}
				} else {
					NodeMapping nm = mappingEntry instanceof NodeMapping ? (NodeMapping) mappingEntry : null;
					// There may be few GenChildNodes corresponding to same mapping entry.					
					// @@see https://bugs.eclipse.org/bugs/show_bug.cgi?id=136701					
					genBase = myHistory.findTopNode(nm);
					if(genBase != null) {
						diagramTarget.getElement().add(genBase);
					}
					diagramTarget.getElement().addAll(Arrays.asList(myHistory.findChildNodes(nm)));					
				}				
			}
			return diagramTarget;
		} else if(ruleTarget instanceof AuditedMetricTarget) {			
			GenAuditedMetricTarget genMetricTarget = GMFGenFactory.eINSTANCE.createGenAuditedMetricTarget();
			AuditedMetricTarget metricTarget = (AuditedMetricTarget)ruleTarget;
			if(metricTarget.getMetric() != null) {
				genMetricTarget.setMetric(myHistory.find(metricTarget.getMetric()));
			}
			GenClassifier resultClassifier = myEcoreGenModelMatch.findGenClassifier(EcorePackage.eINSTANCE.getEDoubleObject());
			assert resultClassifier instanceof GenDataType;
			if(resultClassifier instanceof GenDataType) {
				genMetricTarget.setMetricValueContext((GenDataType)resultClassifier);
			}
			return genMetricTarget;
		} else if(ruleTarget instanceof DomainAttributeTarget) {
			DomainAttributeTarget attrTarget = (DomainAttributeTarget) ruleTarget;
			GenDomainAttributeTarget genAttrTarget = GMFGenFactory.eINSTANCE.createGenDomainAttributeTarget();
			if(attrTarget.getAttribute() != null) {
				genAttrTarget.setAttribute(findGenFeature(attrTarget.getAttribute()));
			}
			genAttrTarget.setNullAsError(attrTarget.isNullAsError());
			return genAttrTarget;				
		} else {
			assert false : "Uknown rule target type"; //$NON-NLS-1$
		}
		return null;
	}
	
	private GenMetricRule createGenMetric(MetricRule metric) {
		GenMetricRule genMetric = GMFGenFactory.eINSTANCE.createGenMetricRule();
		genMetric.setKey(metric.getKey());
		genMetric.setName(metric.getName());
		genMetric.setDescription(metric.getDescription());
		genMetric.setLowLimit(metric.getLowLimit());
		genMetric.setHighLimit(metric.getHighLimit());
		
		if(metric.getRule() != null) {
			ValueExpression valueExpression = GMFGenFactory.eINSTANCE.createValueExpression();
			valueExpression.setBody(metric.getRule().getBody());
			genMetric.setRule(bindToProvider(metric.getRule(), valueExpression));
		}
		
		if(metric.getTarget() != null) {		
			GenRuleTarget genTarget = createRuleTarget(metric.getTarget());
			assert genTarget instanceof GenMeasurable;
			if(genTarget instanceof GenMeasurable) {
				genMetric.setTarget((GenMeasurable)genTarget);
			}
		}
		myHistory.log(metric, genMetric);
		return genMetric;
	}

	/**
	 * ValueExpressions may be reused, as such clients should treat second argument as template and record return value
	 * as actual expression.
	 * @@return actual gmfgen::ValueExpression to reference
	 */
	private <T extends ValueExpression> T bindToProvider(org.eclipse.gmf.mappings.ValueExpression expression, T genExpression) {
		if(myProcessedExpressions.containsKey(expression)) {
			// Note: may have already been bound during transformation of reused node mapping
			@@SuppressWarnings("unchecked") T reuse = (T) myProcessedExpressions.get(expression);
			return reuse;
		}
		GenLanguage language = detectGenLanguage(expression.getLanguage());
		if(language == null) {
			return genExpression;
		}
		GenExpressionProviderContainer providerContainer = getGenEssence().getExpressionProviders();
		if(providerContainer == null) {
			providerContainer = GMFGenFactory.eINSTANCE.createGenExpressionProviderContainer();
			getGenEssence().setExpressionProviders(providerContainer);
		}
		GenExpressionProviderBase provider = null;
		for (GenExpressionProviderBase nextProvider : providerContainer.getProviders()) {
			if(language.equals(nextProvider.getLanguage())) {
				provider = nextProvider;
				break;
			}
		}
		if(provider == null) {
			provider = createExpressionProvider(language);
			providerContainer.getProviders().add(provider);			
		}
		provider.getExpressions().add(genExpression);
		myProcessedExpressions.put(expression, genExpression);
		return genExpression;
	}
	
	private GenExpressionProviderBase createExpressionProvider(GenLanguage language) {
		switch (language.getValue()) {
		case GenLanguage.JAVA :
			return  GMFGenFactory.eINSTANCE.createGenJavaExpressionProvider();
		case GenLanguage.OCL : 
		case GenLanguage.REGEXP :
		case GenLanguage.NREGEXP : {
			GenExpressionInterpreter regexpProvider = GMFGenFactory.eINSTANCE.createGenExpressionInterpreter();
			regexpProvider.setLanguage(language);
			return regexpProvider;
		}
		case GenLanguage.LITERAL :
			return GMFGenFactory.eINSTANCE.createGenLiteralExpressionProvider();
		default : {
			assert false : language;
			return GMFGenFactory.eINSTANCE.createGenExpressionInterpreter();
			// fake provider with no language set to fail validation (XXX perhaps, makes sense to add 'unrecognized' language?)
		}
		}
	}

	private void addPreferencePages(GenDiagram diagram) {
		GenPreferencePage general = createStandardPreferencePage(diagram, "general", diagram.getEditorGen().getModelID() + " Diagram", StandardPreferencePages.GENERAL_LITERAL);
		diagram.getPreferencePages().add(general);
		general.getChildren().add(createStandardPreferencePage(diagram, "appearance", "Appearance", StandardPreferencePages.APPEARANCE_LITERAL));
		general.getChildren().add(createStandardPreferencePage(diagram, "connections", "Connections", StandardPreferencePages.CONNECTIONS_LITERAL));
		general.getChildren().add(createStandardPreferencePage(diagram, "printing", "Printing", StandardPreferencePages.PRINTING_LITERAL));
		general.getChildren().add(createStandardPreferencePage(diagram, "rulersAndGrid", "Rulers And Grid", StandardPreferencePages.RULERS_AND_GRID_LITERAL));
	}

	private GenPreferencePage createStandardPreferencePage(GenDiagram diagram, String id, String name, StandardPreferencePages kind) {
		GenStandardPreferencePage page = GMFGenFactory.eINSTANCE.createGenStandardPreferencePage();
		page.setID(diagram.getEditorGen().getPlugin().getID() + '.' + id);
		page.setName(name);
		page.setKind(kind);
		return page;
	}

	private void addContributions(GenApplication application) {
		GenMenuManager mainMenu = GMFGenFactory.eINSTANCE.createGenMenuManager();
		mainMenu.getItems().add(createFileMenu(application.getSharedContributionItems()));
		mainMenu.getItems().add(createEditMenu(application.getSharedContributionItems()));
		mainMenu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.MB_ADDITIONS")); //$NON-NLS-1$
		mainMenu.getItems().add(createWindowMenu(application.getSharedContributionItems()));
		mainMenu.getItems().add(createHelpMenu(application.getSharedContributionItems()));
		application.setMainMenu(mainMenu);

		GenToolBarManager mainToolBar = GMFGenFactory.eINSTANCE.createGenToolBarManager();
		mainToolBar.getItems().add(createGroupMarker("\"group.file\"")); //$NON-NLS-1$
		mainToolBar.getItems().add(createFileToolBar(application.getSharedContributionItems()));
		mainToolBar.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.MB_ADDITIONS")); //$NON-NLS-1$
		mainToolBar.getItems().add(createGroupMarker("\"group.nav\"")); //$NON-NLS-1$
		mainToolBar.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.GROUP_EDITOR")); //$NON-NLS-1$
		mainToolBar.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.GROUP_HELP")); //$NON-NLS-1$
		mainToolBar.getItems().add(createHelpToolBar(application.getSharedContributionItems()));
		application.setMainToolBar(mainToolBar);
	}

	private GenGroupMarker createGroupMarker(String groupName) {
		GenGroupMarker gm = GMFGenFactory.eINSTANCE.createGenGroupMarker();
		gm.setGroupName(groupName);
		return gm;
	}

	private GenSeparator createSeparator(String groupName) {
		GenSeparator s = GMFGenFactory.eINSTANCE.createGenSeparator();
		s.setGroupName(groupName);
		return s;
	}

	private GenActionFactoryContributionItem createActionFactoryItem(String name) {
		GenActionFactoryContributionItem item = GMFGenFactory.eINSTANCE.createGenActionFactoryContributionItem();
		item.setName(name);
		return item;
	}

	private GenSharedContributionItem createSharedItem(List<GenContributionItem> sharedItems, GenContributionItem actualItem) {
		GenSharedContributionItem sitem = GMFGenFactory.eINSTANCE.createGenSharedContributionItem();
		if (actualItem instanceof GenActionFactoryContributionItem) {
			GenActionFactoryContributionItem afActualItem = (GenActionFactoryContributionItem) actualItem;
			for (GenContributionItem item : sharedItems) {
				if (item instanceof GenActionFactoryContributionItem) {
					GenActionFactoryContributionItem afItem = (GenActionFactoryContributionItem) item;
					if (afItem.getName().equals(afActualItem.getName())) {
						// shared action factory item is already contributed
						sitem.setActualItem(afItem);
						actualItem = null;
						break;
					}
				}
			}
		}
		if (actualItem != null) {
			sitem.setActualItem(actualItem);
			sharedItems.add(actualItem);
		}
		return sitem;
	}

	private GenMenuManager createFileMenu(List<GenContributionItem> sharedItems) {
		GenMenuManager menu = GMFGenFactory.eINSTANCE.createGenMenuManager();
		menu.setID("org.eclipse.ui.IWorkbenchActionConstants.M_FILE"); //$NON-NLS-1$
		menu.setName("&File"); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.FILE_START")); //$NON-NLS-1$
		GenMenuManager newMenu = GMFGenFactory.eINSTANCE.createGenMenuManager();
		newMenu.setID("\"new\""); //$NON-NLS-1$
		newMenu.setName("&New"); //$NON-NLS-1$
		newMenu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.MB_ADDITIONS")); //$NON-NLS-1$
		menu.getItems().add(newMenu);
		menu.getItems().add(GMFGenFactory.eINSTANCE.createGenSeparator());
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.MB_ADDITIONS")); //$NON-NLS-1$
		menu.getItems().add(GMFGenFactory.eINSTANCE.createGenSeparator());
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("CLOSE"))); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("CLOSE_ALL"))); //$NON-NLS-1$
		menu.getItems().add(GMFGenFactory.eINSTANCE.createGenSeparator());
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("SAVE"))); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("SAVE_AS"))); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("SAVE_ALL"))); //$NON-NLS-1$
		menu.getItems().add(GMFGenFactory.eINSTANCE.createGenSeparator());
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("QUIT"))); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.FILE_END")); //$NON-NLS-1$
		return menu;
	}

	private GenMenuManager createEditMenu(List<GenContributionItem> sharedItems) {
		GenMenuManager menu = GMFGenFactory.eINSTANCE.createGenMenuManager();
		menu.setID("org.eclipse.ui.IWorkbenchActionConstants.M_EDIT"); //$NON-NLS-1$
		menu.setName("&Edit"); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.EDIT_START")); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("UNDO"))); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("REDO"))); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.UNDO_EXT")); //$NON-NLS-1$
		menu.getItems().add(GMFGenFactory.eINSTANCE.createGenSeparator());
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("CUT"))); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("COPY"))); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("PASTE"))); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.CUT_EXT")); //$NON-NLS-1$
		menu.getItems().add(GMFGenFactory.eINSTANCE.createGenSeparator());
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("DELETE"))); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("SELECT_ALL"))); //$NON-NLS-1$
		menu.getItems().add(GMFGenFactory.eINSTANCE.createGenSeparator());
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.ADD_EXT")); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.EDIT_END")); //$NON-NLS-1$
		menu.getItems().add(createSeparator("org.eclipse.ui.IWorkbenchActionConstants.MB_ADDITIONS")); //$NON-NLS-1$
		return menu;
	}

	private GenMenuManager createWindowMenu(List<GenContributionItem> sharedItems) {
		GenMenuManager menu = GMFGenFactory.eINSTANCE.createGenMenuManager();
		menu.setID("org.eclipse.ui.IWorkbenchActionConstants.M_WINDOW"); //$NON-NLS-1$
		menu.setName("&Window"); //$NON-NLS-1$
		menu.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("OPEN_NEW_WINDOW"))); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.MB_ADDITIONS")); //$NON-NLS-1$
		// TODO : menu.add(ContributionItemFactory.OPEN_WINDOWS.create(window));
		return menu;
	}

	private GenMenuManager createHelpMenu(List<GenContributionItem> sharedItems) {
		GenMenuManager menu = GMFGenFactory.eINSTANCE.createGenMenuManager();
		menu.setID("org.eclipse.ui.IWorkbenchActionConstants.M_HELP"); //$NON-NLS-1$
		menu.setName("&Help"); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.HELP_START")); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.HELP_END")); //$NON-NLS-1$
		menu.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.MB_ADDITIONS")); //$NON-NLS-1$
		return menu;
	}

	private GenToolBarManager createFileToolBar(List<GenContributionItem> sharedItems) {
		GenToolBarManager toolBar = GMFGenFactory.eINSTANCE.createGenToolBarManager();
		toolBar.setID("org.eclipse.ui.IWorkbenchActionConstants.TOOLBAR_FILE"); //$NON-NLS-1$
		toolBar.getItems().add(createSeparator("org.eclipse.ui.IWorkbenchActionConstants.NEW_GROUP")); //$NON-NLS-1$
		toolBar.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.NEW_EXT")); //$NON-NLS-1$
		toolBar.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.SAVE_GROUP")); //$NON-NLS-1$
		toolBar.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("SAVE"))); //$NON-NLS-1$
		toolBar.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.SAVE_EXT")); //$NON-NLS-1$
		toolBar.getItems().add(createSharedItem(sharedItems, createActionFactoryItem("PRINT"))); //$NON-NLS-1$
		toolBar.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.PRINT_EXT")); //$NON-NLS-1$
		toolBar.getItems().add(createSeparator("org.eclipse.ui.IWorkbenchActionConstants.MB_ADDITIONS")); //$NON-NLS-1$
		return toolBar;
	}

	private GenToolBarManager createHelpToolBar(List<GenContributionItem> sharedItems) {
		GenToolBarManager toolBar = GMFGenFactory.eINSTANCE.createGenToolBarManager();
		toolBar.setID("org.eclipse.ui.IWorkbenchActionConstants.TOOLBAR_HELP"); //$NON-NLS-1$
		toolBar.getItems().add(createSeparator("org.eclipse.ui.IWorkbenchActionConstants.GROUP_HELP")); //$NON-NLS-1$
		toolBar.getItems().add(createGroupMarker("org.eclipse.ui.IWorkbenchActionConstants.GROUP_APP")); //$NON-NLS-1$
		return toolBar;
	}

	private GenParserImplementation getOrCreateParser(FeatureLabelMapping flMapping) {
		final LabelTextAccessMethod editMethod = LabelTextAccessMethod.get(flMapping.getEditMethod().getValue());
		final LabelTextAccessMethod viewMethod = LabelTextAccessMethod.get(flMapping.getViewMethod().getValue());
		for (GenParserImplementation pi : getGenParsers().getImplementations()) {
			if (pi instanceof PredefinedParser) {
				PredefinedParser pp = (PredefinedParser) pi;
				boolean same = pp.getEditMethod() == editMethod;
				same &= pp.getViewMethod() == viewMethod;
				if (same) {
					return pp;
				}
			}
		}
		PredefinedParser result = GMFGenFactory.eINSTANCE.createPredefinedParser();
		result.setEditMethod(editMethod);
		result.setViewMethod(viewMethod);
		getGenParsers().getImplementations().add(result);
		return result;
	}

	private GenParserImplementation getOrCreateParser(DesignLabelMapping flMapping) {
		if (myDesignLabelParser == null) {
			myDesignLabelParser = GMFGenFactory.eINSTANCE.createExternalParser();
			getGenParsers().getImplementations().add(myDesignLabelParser);
		}
		return myDesignLabelParser;
	}

	private GenParserImplementation getOrCreateParser(LabelMapping flMapping) {
		if (myAuxParser == null) {
			myAuxParser = GMFGenFactory.eINSTANCE.createExternalParser();
			getGenParsers().getImplementations().add(myAuxParser);
		}
		return myAuxParser;
	}
}@


1.43
log
@[247542] generate only actually used preference pages
@
text
@d106 1
d208 8
d258 7
@


1.42
log
@[235113] alternative parser access
@
text
@a1120 1
		general.getChildren().add(createStandardPreferencePage(diagram, "pathmaps", "Pathmaps", StandardPreferencePages.PATHMAPS_LITERAL));
@


1.41
log
@Refactoring to address [235113] alternative parser access and [244419] Support for custom parser:
no separate Parser implementations, rather tailored to specific view and edit methods used.
@
text
@d103 3
a105 1
	private final EcoreGenModelMatcher myEcoreGenModelMatch;	
a150 6
		// XXX meanwhile, we don't set any attributes to GenParsers (rather delegating to old, deprecated)
		if (myGenModel.getLabelParsers() == null) {
			myGenModel.setLabelParsers(GMFGenFactory.eINSTANCE.createGenParsers());
			// unless bug #235113 is fixed, always do ParserService
			myGenModel.getLabelParsers().setExtensibleViaService(true);
		}
d181 1
a181 1
	private Palette createGenPalette() {
d190 1
a190 1
	private GenPropertySheet createPropertySheet() {
d197 10
d213 1
a213 1
			myPaletteProcessor.initialize(createGenPalette());
d238 1
a238 1
		myPropertySheetProcessor.initialize(createPropertySheet());
d600 1
d603 6
a608 1
		return null;
d1286 1
a1286 1
		for (GenParserImplementation pi : getGenEssence().getLabelParsers().getImplementations()) {
d1299 1
a1299 1
		getGenEssence().getLabelParsers().getImplementations().add(result);
d1302 16
@


1.40
log
@[235113] alternative parser access, step 2: temp fix to use newly introduced GenParsers entity
@
text
@a105 1
	private ExternalParser myExternalParser;
a153 2
			myExternalParser = GMFGenFactory.eINSTANCE.createExternalParser();
			myGenModel.getLabelParsers().getImplementations().add(myExternalParser);
d588 1
a588 1
			modelFacet.setParser(myExternalParser);
d1270 20
@


1.39
log
@[231322] allow to specify editable features
@
text
@d106 1
d150 8
d590 3
@


1.38
log
@[227127] support literal values for feature initializers. step 3: respect literal expressions during map->gen transform, tests.
@
text
@d569 3
@


1.37
log
@[206348] tree branch option is true by default
@
text
@d821 2
d1070 6
a1075 8
		GenExpressionProviderBase newProvider = null;
		if(GenLanguage.JAVA_LITERAL.equals(language)) {
			newProvider = GMFGenFactory.eINSTANCE.createGenJavaExpressionProvider();			
		} else if(GenLanguage.OCL_LITERAL.equals(language)) {
			GenExpressionInterpreter oclProvider = GMFGenFactory.eINSTANCE.createGenExpressionInterpreter();
			oclProvider.setLanguage(language);
			newProvider = oclProvider;
		} else if(GenLanguage.REGEXP_LITERAL.equals(language) || GenLanguage.NREGEXP_LITERAL.equals(language)) {
d1078 7
a1084 3
			newProvider = regexpProvider;
		} else {
			newProvider = GMFGenFactory.eINSTANCE.createGenExpressionInterpreter();
d1087 1
a1087 2
		assert newProvider != null;
		return newProvider;
@


1.36
log
@[206348] enable tree by default
@
text
@a467 1
		gl.setTreeBranch(true);
@


1.35
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@d468 1
@


1.34
log
@[227505] Replace FeatureValueSpec generalization of ValueExpression with aggregation, as it's better approach to model such a concept
@
text
@a16 1
import java.util.HashSet;
a20 1
import java.util.Set;
d97 1
a97 1
	private final Set<org.eclipse.gmf.mappings.ValueExpression> myProcessedExpressions = new HashSet<org.eclipse.gmf.mappings.ValueExpression>();
d123 1
d790 1
a790 3
			GenFeatureValueSpec genFeatureValSpec = GMFGenFactory.eINSTANCE.createGenFeatureValueSpec();				
			genFeatureValSpec.setBody(featureValSpec.getValue().getBody());
			genFeatureValSpec.setLanguage(createGenLanguage(featureValSpec.getValue().getLanguage()));
d792 4
a795 2
			
			bindToProvider(featureValSpec.getValue(), genFeatureValSpec);
d811 1
a811 1
	private static GenLanguage createGenLanguage(Language mapLang) {
d831 3
a833 5
		GenConstraint modelElementSelector = GMFGenFactory.eINSTANCE.createGenConstraint();
		modelElementSelector.setBody(constraint.getBody());
		modelElementSelector.setLanguage(createGenLanguage(constraint.getLanguage()));
		bindToProvider(constraint, modelElementSelector);
		return modelElementSelector;
d1017 1
a1017 3
			valueExpression.setLanguage(createGenLanguage(metric.getRule().getLanguage()));
			bindToProvider(metric.getRule(), valueExpression);
			genMetric.setRule(valueExpression);
d1030 8
a1037 3
	
	private void bindToProvider(org.eclipse.gmf.mappings.ValueExpression expression, ValueExpression genExpression) {
		if(!myProcessedExpressions.add(expression)) {
d1039 2
a1040 1
			return;
d1042 1
a1042 2
		
		GenLanguage language = genExpression.getLanguage();
d1044 1
a1044 1
			return;
a1059 3
			if(provider == null) {
				return;
			}
d1063 2
d1079 3
d1083 1
@


1.33
log
@[226149] Refactor Validation/Constraints: explicit context groupings instead of ID matching, unused IClientSelectors implementations are no longer generated, less custom code in the model, odd approach with map (semanticCtxIdMap) replaced with in-place VisualID check.
@
text
@d792 2
a793 2
			genFeatureValSpec.setBody(featureValSpec.getBody());
			genFeatureValSpec.setLanguage(createGenLanguage(featureValSpec.getLanguage()));
d796 1
a796 1
			bindToProvider(featureValSpec, genFeatureValSpec);
@


1.32
log
@correct copyright year
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2007 Borland Software Corporation
d37 1
a37 69
import org.eclipse.gmf.codegen.gmfgen.DesignLabelModelFacet;
import org.eclipse.gmf.codegen.gmfgen.ElementType;
import org.eclipse.gmf.codegen.gmfgen.FeatureLabelModelFacet;
import org.eclipse.gmf.codegen.gmfgen.FeatureLinkModelFacet;
import org.eclipse.gmf.codegen.gmfgen.GMFGenFactory;
import org.eclipse.gmf.codegen.gmfgen.GenActionFactoryContributionItem;
import org.eclipse.gmf.codegen.gmfgen.GenApplication;
import org.eclipse.gmf.codegen.gmfgen.GenAuditContainer;
import org.eclipse.gmf.codegen.gmfgen.GenAuditRoot;
import org.eclipse.gmf.codegen.gmfgen.GenAuditRule;
import org.eclipse.gmf.codegen.gmfgen.GenAuditable;
import org.eclipse.gmf.codegen.gmfgen.GenAuditedMetricTarget;
import org.eclipse.gmf.codegen.gmfgen.GenChildContainer;
import org.eclipse.gmf.codegen.gmfgen.GenChildLabelNode;
import org.eclipse.gmf.codegen.gmfgen.GenChildNode;
import org.eclipse.gmf.codegen.gmfgen.GenChildSideAffixedNode;
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
import org.eclipse.gmf.codegen.gmfgen.GenCompartment;
import org.eclipse.gmf.codegen.gmfgen.GenConstraint;
import org.eclipse.gmf.codegen.gmfgen.GenContributionItem;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenDiagramElementTarget;
import org.eclipse.gmf.codegen.gmfgen.GenDomainAttributeTarget;
import org.eclipse.gmf.codegen.gmfgen.GenDomainElementTarget;
import org.eclipse.gmf.codegen.gmfgen.GenEditorGenerator;
import org.eclipse.gmf.codegen.gmfgen.GenElementInitializer;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionInterpreter;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionProviderBase;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionProviderContainer;
import org.eclipse.gmf.codegen.gmfgen.GenFeatureInitializer;
import org.eclipse.gmf.codegen.gmfgen.GenFeatureSeqInitializer;
import org.eclipse.gmf.codegen.gmfgen.GenFeatureValueSpec;
import org.eclipse.gmf.codegen.gmfgen.GenGroupMarker;
import org.eclipse.gmf.codegen.gmfgen.GenLanguage;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenLinkConstraints;
import org.eclipse.gmf.codegen.gmfgen.GenLinkLabel;
import org.eclipse.gmf.codegen.gmfgen.GenMeasurable;
import org.eclipse.gmf.codegen.gmfgen.GenMenuManager;
import org.eclipse.gmf.codegen.gmfgen.GenMetricContainer;
import org.eclipse.gmf.codegen.gmfgen.GenMetricRule;
import org.eclipse.gmf.codegen.gmfgen.GenNavigator;
import org.eclipse.gmf.codegen.gmfgen.GenNode;
import org.eclipse.gmf.codegen.gmfgen.GenNodeLabel;
import org.eclipse.gmf.codegen.gmfgen.GenNotationElementTarget;
import org.eclipse.gmf.codegen.gmfgen.GenPreferencePage;
import org.eclipse.gmf.codegen.gmfgen.GenPropertySheet;
import org.eclipse.gmf.codegen.gmfgen.GenReferenceNewElementSpec;
import org.eclipse.gmf.codegen.gmfgen.GenRuleTarget;
import org.eclipse.gmf.codegen.gmfgen.GenSeparator;
import org.eclipse.gmf.codegen.gmfgen.GenSeverity;
import org.eclipse.gmf.codegen.gmfgen.GenSharedContributionItem;
import org.eclipse.gmf.codegen.gmfgen.GenStandardPreferencePage;
import org.eclipse.gmf.codegen.gmfgen.GenToolBarManager;
import org.eclipse.gmf.codegen.gmfgen.GenTopLevelNode;
import org.eclipse.gmf.codegen.gmfgen.LabelModelFacet;
import org.eclipse.gmf.codegen.gmfgen.LabelOffsetAttributes;
import org.eclipse.gmf.codegen.gmfgen.LabelTextAccessMethod;
import org.eclipse.gmf.codegen.gmfgen.LinkLabelAlignment;
import org.eclipse.gmf.codegen.gmfgen.LinkModelFacet;
import org.eclipse.gmf.codegen.gmfgen.MetamodelType;
import org.eclipse.gmf.codegen.gmfgen.OpenDiagramBehaviour;
import org.eclipse.gmf.codegen.gmfgen.Palette;
import org.eclipse.gmf.codegen.gmfgen.ProviderPriority;
import org.eclipse.gmf.codegen.gmfgen.SpecializationType;
import org.eclipse.gmf.codegen.gmfgen.StandardPreferencePages;
import org.eclipse.gmf.codegen.gmfgen.TypeLinkModelFacet;
import org.eclipse.gmf.codegen.gmfgen.TypeModelFacet;
import org.eclipse.gmf.codegen.gmfgen.ValueExpression;
d107 2
d866 41
d911 1
a911 1
	
@


1.31
log
@FigureDescriptor with explicit means to access children introduced into gmfgraph
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
@


1.30
log
@[123240] clean gmfgen uses of required plugins
@
text
@d109 1
d113 1
d319 1
a319 1
		genNode.setViewmap(myViewmaps.create(nme.getDiagramNode()));
d423 1
a423 1
		} else if (childNodeMapping.getDiagramNode().getAffixedParentSide() != Direction.NONE_LITERAL){
d425 2
a426 2
			sideAffixedNode.setViewmap(myViewmaps.create(childNodeMapping.getDiagramNode()));
			String positionConstantName = getAffixedSideAsPositionConstantsName(childNodeMapping.getDiagramNode());
d432 1
a432 1
			childNode.setViewmap(myViewmaps.create(childNodeMapping.getDiagramNode()));
d570 1
a570 1
		if (Knowledge.isExternal(mapping.getDiagramLabel())) {
d594 2
a595 2
		if (mapping.getDiagramLabel().find(AlignmentFacet.class) != null) {
			AlignmentFacet af = (AlignmentFacet) mapping.getDiagramLabel().find(AlignmentFacet.class);
d599 1
a599 1
		LabelOffsetFacet lof = (LabelOffsetFacet) mapping.getDiagramLabel().find(LabelOffsetFacet.class);
d611 8
@


1.29
log
@move assumption about single-label nodes into Knowledge
@
text
@a1089 1
			oclProvider.getRequiredPluginIDs().add("org.eclipse.ocl.ecore"); //$NON-NLS-1$
@


1.28
log
@GenDiagramUpdater created in .gmfgen model
@
text
@d412 1
a412 1
		if (isPureLabelNode(childNodeMapping)) {
a472 12
	/**
	 * @@return whether nodeMapping has single label, no children and node's diagram 
	 * element is DiagramLabel equivalent that of it's label
	 */
	private boolean isPureLabelNode(NodeMapping childNodeMapping) {
		if (childNodeMapping.getLabelMappings().size() == 1 && childNodeMapping.getChildren().isEmpty()) {
			LabelMapping soleLabel = childNodeMapping.getLabelMappings().get(0);
			return childNodeMapping.getDiagramNode() == soleLabel.getDiagramLabel(); 
		}
		return false;
	}

@


1.27
log
@correct default value check
@
text
@d230 7
d289 1
@


1.26
log
@refactor message format parser; introduce editor pattern
@
text
@d633 1
a633 1
			if (flMapping.getViewMethod() != null) {
d636 1
a636 1
			if (flMapping.getEditMethod() != null) {
@


1.25
log
@update not to use deprecated ocl code
@
text
@d631 1
@


1.24
log
@combine label text access methods
@
text
@d1093 1
a1093 4
			oclProvider.getRequiredPluginIDs().addAll(Arrays.asList(new String[] {
				"org.eclipse.emf.ocl", //$NON-NLS-1$
				"org.eclipse.emf.query.ocl" //$NON-NLS-1$		
			}));
@


1.23
log
@additional methods to produce label text and parse user input
@
text
@a91 1
import org.eclipse.gmf.codegen.gmfgen.LabelEditMethod;
d94 1
a94 1
import org.eclipse.gmf.codegen.gmfgen.LabelViewMethod;
d633 1
a633 1
				modelFacet.setViewMethod(LabelViewMethod.get(flMapping.getViewMethod().getValue()));
d636 1
a636 1
				modelFacet.setEditMethod(LabelEditMethod.get(flMapping.getEditMethod().getValue()));
@


1.22
log
@[177571] reconcile properties of OpenDiagramBehavior
@
text
@d92 1
d95 1
d633 6
@


1.21
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d505 2
a506 2
				openDiagramPolicy.setDiagramKind("put GenEditorGenerator.modelID value here");
				openDiagramPolicy.setEditorID("put GenEditorView.id value here");
@


1.20
log
@remove extra double quotes
@
text
@a18 1
import java.util.Iterator;
d38 1
a153 1
@@SuppressWarnings("unchecked")
d163 2
a164 2
	private final Map myProcessedTypes = new IdentityHashMap(); // GenClass -> MetamodelType
	private final Set myProcessedExpressions = new HashSet();
d332 2
a333 2
			for (Iterator it = metrics.getMetrics().iterator(); it.hasNext();) {
				genMetricContainer.getMetrics().add(createGenMetric((MetricRule)it.next()));				
d404 1
a404 1
			LabelMapping soleLabel = (LabelMapping) childNodeMapping.getLabelMappings().get(0);
d470 1
a470 1
			LabelMapping soleLabel = (LabelMapping) childNodeMapping.getLabelMappings().get(0);
d477 2
a478 3
		Map compartments2GenCompartmentsMap = new HashMap();
		for (Iterator it = mapping.getCompartments().iterator(); it.hasNext();) {
			CompartmentMapping compartmentMapping = (CompartmentMapping) it.next();
d483 1
a483 2
		for (Iterator it = mapping.getChildren().iterator(); it.hasNext();) {
			ChildReference childNodeRef = (ChildReference) it.next();
d488 1
a488 1
				genChildContainer = (GenChildContainer) compartments2GenCompartmentsMap.get(compartmentMapping);
d494 1
a494 2
		for (Iterator labels = mapping.getLabelMappings().iterator(); labels.hasNext();) {
			LabelMapping labelMapping = (LabelMapping) labels.next();
d500 1
a500 2
		for (Iterator it = mapping.getRelatedDiagrams().iterator(); it.hasNext(); ) {
			CanvasMapping nextRelatedCanvas = (CanvasMapping) it.next();
d537 1
a537 2
		for (Iterator labels = lme.getLabelMappings().iterator(); labels.hasNext();) {
			LabelMapping labelMapping = (LabelMapping) labels.next();
d829 2
a830 2
			for (Iterator it = fsInitializer.getInitializers().iterator(); it.hasNext();) {
				genFsInitializer.getInitializers().add(createGenFeatureInitializer((FeatureInitializer)it.next()));
d854 2
a855 2
			for (Iterator newElemInitIt = newElementSpec.getNewElementInitializers().iterator(); newElemInitIt.hasNext();) { 
				GenFeatureSeqInitializer nextGenFeatureSeqInitializer = (GenFeatureSeqInitializer)createElementInitializer((FeatureSeqInitializer)newElemInitIt.next());
d914 2
a915 2
			for (Iterator it = nextChild.getAudits().iterator(); it.hasNext();) {
				final GenAuditRule auditRule = createGenAudit((AuditRule) it.next());
d1063 1
a1063 2
		for (Iterator it = providerContainer.getProviders().iterator(); it.hasNext();) {
			GenExpressionProviderBase nextProvider = (GenExpressionProviderBase) it.next();	
d1155 1
a1155 1
	private GenSharedContributionItem createSharedItem(List sharedItems, GenContributionItem actualItem) {
d1159 1
a1159 1
			for (GenContributionItem item : (List<GenContributionItem>) sharedItems) {
d1178 1
a1178 1
	private GenMenuManager createFileMenu(List sharedItems) {
d1203 1
a1203 1
	private GenMenuManager createEditMenu(List sharedItems) {
d1226 1
a1226 1
	private GenMenuManager createWindowMenu(List sharedItems) {
d1236 1
a1236 1
	private GenMenuManager createHelpMenu(List sharedItems) {
d1246 1
a1246 1
	private GenToolBarManager createFileToolBar(List sharedItems) {
d1260 1
a1260 1
	private GenToolBarManager createHelpToolBar(List sharedItems) {
@


1.19
log
@refactor GenAuditContainer: flatten hierarchy as it fits most for templates we write
@
text
@d1188 1
a1188 1
		menu.setName("\"&File\""); //$NON-NLS-1$
d1192 1
a1192 1
		newMenu.setName("\"&New\""); //$NON-NLS-1$
d1213 1
a1213 1
		menu.setName("\"&Edit\""); //$NON-NLS-1$
d1236 1
a1236 1
		menu.setName("\"&Window\""); //$NON-NLS-1$
d1246 1
a1246 1
		menu.setName("\"&Help\""); //$NON-NLS-1$
@


1.18
log
@provide default toolbar content
@
text
@d20 1
d45 1
d326 1
a326 1
			getGenEssence().setAudits(createGenAuditContainer(audits));	
d897 30
a926 13
	private GenAuditContainer createGenAuditContainer(AuditContainer ac) {
		GenAuditContainer gac = GMFGenFactory.eINSTANCE.createGenAuditContainer();
		gac.setId(ac.getId());
		gac.setName(ac.getName());
		gac.setDescription(ac.getDescription());
		for(Iterator it = ac.getChildContainers().iterator(); it.hasNext();) {
			AuditContainer nextChild = (AuditContainer) it.next();
			gac.getChildContainers().add(createGenAuditContainer(nextChild));
		}
		for (Iterator it = ac.getAudits().iterator(); it.hasNext();) {
			gac.getAudits().add(createGenAudit((AuditRule) it.next()));
		}
		return gac;
@


1.17
log
@rise provider priority so validate action appears in menu
@
text
@d1115 7
d1144 20
a1163 4
		GenSharedContributionItem item = GMFGenFactory.eINSTANCE.createGenSharedContributionItem();
		item.setActualItem(actualItem);
		sharedItems.add(actualItem);
		return item;
d1233 22
@


1.16
log
@avoid ampersand
@
text
@d270 1
@


1.15
log
@add default preference pages
@
text
@d1092 1
a1092 1
		general.getChildren().add(createStandardPreferencePage(diagram, "rulersAndGrid", "Rulers & Grid", StandardPreferencePages.RULERS_AND_GRID_LITERAL));
@


1.14
log
@allow to specify ui contributions for rcp application in genmodel
@
text
@d80 1
d87 1
d99 1
d282 1
d1086 18
@


1.13
log
@add option to produce genmodel for rcp application
@
text
@d20 1
d41 2
d54 1
d67 1
d73 1
d83 1
d85 2
d282 3
a284 1
				getGenEssence().setApplication(GMFGenFactory.eINSTANCE.createGenApplication());
d1081 106
@


1.12
log
@[161380] Inroduce label mapping subclasses
@
text
@d148 1
d160 1
a160 1
		this(drtHelper, namingStrategy, new InnerClassViewmapProducer(), new NaiveIdentifierDispenser());
d163 1
a163 1
	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, GenModelNamingMediator namingStrategy, ViewmapProducer viewmaps, VisualIdentifierDispenser visualIdD) {
d169 1
d248 3
a250 1
		myNavigatorProcessor.initialize(getGenDiagram(), genGenNavigator());
d270 7
a276 1

d301 3
a303 1
		myNavigatorProcessor.process(genNode);
d349 3
a351 1
		myNavigatorProcessor.process(childNode, container);
d545 3
a547 1
		myNavigatorProcessor.process(gl);
@


1.11
log
@Fixing a potential NPE in case of metrics without a target
@
text
@d15 1
d36 1
d111 1
d117 1
d595 2
a596 1
		if (mapping.getFeatures().size() > 0) {
d598 2
a599 2
			for (Iterator features = mapping.getFeatures().iterator(); features.hasNext();) {
				modelFacet.getMetaFeatures().add(findGenFeature((EAttribute) features.next()));
d601 2
a602 2
			modelFacet.setViewPattern(mapping.getViewPattern());
			modelFacet.setEditPattern(mapping.getEditPattern());
d605 3
a607 3
		if (!mapping.isReadOnly()) {
			// use design model facet if there are no features and label is editable
			//return GMFGenFactory.eINSTANCE.createDesignLabelModelFacet();
d690 9
a698 13
		boolean ok = true;
		for (Iterator it = entry.getLabelMappings().iterator(); ok && it.hasNext();) {
			ok = checkLabelFeatureValidity((LabelMapping) it.next());
		}
		return ok;
	}

	private static boolean checkLabelFeatureValidity(LabelMapping labelMapping) {
		final EClass domainElement = labelMapping.getMapEntry().getDomainContext(); 
		boolean isOk = true;
		for (Iterator it = labelMapping.getFeatures().iterator(); isOk && it.hasNext(); ) {
			EClass attrContainer = ((EAttribute) it.next()).getEContainingClass();
			isOk = attrContainer.isSuperTypeOf(domainElement);
d700 1
a700 1
		return isOk;
@


1.10
log
@#161380 simplify feature model facets
@
text
@d990 6
a995 4
		GenRuleTarget genTarget = createRuleTarget(metric.getTarget());
		assert genTarget instanceof GenMeasurable;
		if(genTarget instanceof GenMeasurable) {
			genMetric.setTarget((GenMeasurable)genTarget);
@


1.9
log
@#161380 move readOnly back to GenLabel
@
text
@a34 1
import org.eclipse.gmf.codegen.gmfgen.CompositeFeatureLabelModelFacet;
d591 1
a591 1
		if (mapping.getFeatures().size() == 1) {
a592 7
			modelFacet.setMetaFeature(findGenFeature((EAttribute) mapping.getFeatures().get(0)));
			modelFacet.setViewPattern(mapping.getViewPattern());
			modelFacet.setEditPattern(mapping.getEditPattern());
			return modelFacet;
		}
		if (mapping.getFeatures().size() > 1) {
			CompositeFeatureLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createCompositeFeatureLabelModelFacet();
@


1.8
log
@#160894 Move readOnly property from GenLabel to LabelFeatureModelFacet
@
text
@d374 1
d550 1
d562 1
a596 1
			modelFacet.setReadOnly(mapping.isReadOnly());
a605 1
			modelFacet.setReadOnly(mapping.isReadOnly());
d610 1
a610 1
			return GMFGenFactory.eINSTANCE.createDesignLabelModelFacet();
@


1.7
log
@[119465] support for diagram partitioning
@
text
@a373 1
			childLabelNode.setLabelReadOnly(soleLabel.isReadOnly());
a548 1
		label.setReadOnly(mapping.isReadOnly());
a559 1
		label.setReadOnly(mapping.isReadOnly());
d594 1
d604 1
d607 2
a608 2
		if (myGenModelMatch == null) {
			// pure design diagram
@


1.6
log
@#138440 Modify Feature Sequence initializer to support containment references to model elements
@
text
@d83 1
d469 11
@


1.5
log
@Generate PropertySheet pluged into tabbed page framework of Eclipse instead of plug-in as runtime provider.
Eases pages being added/removed/replaced/tuned
@
text
@d59 1
d74 1
d113 1
d116 1
d128 1
d795 1
a795 2
			GenFeatureSeqInitializer fSeqInitializer = GMFGenFactory.eINSTANCE.createGenFeatureSeqInitializer();
			
d797 1
a797 9
				FeatureValueSpec nextValSpec = (FeatureValueSpec) it.next();
				
				GenFeatureValueSpec nextGenValSpec = GMFGenFactory.eINSTANCE.createGenFeatureValueSpec();				
				nextGenValSpec.setBody(nextValSpec.getBody());
				nextGenValSpec.setLanguage(createGenLanguage(nextValSpec.getLanguage()));
				nextGenValSpec.setFeature(findGenFeature(nextValSpec.getFeature()));
				bindToProvider(nextValSpec, nextGenValSpec);				
				
				fSeqInitializer.getInitializers().add(nextGenValSpec);
d799 4
a802 1
			return fSeqInitializer;
d807 23
@


1.4
log
@Model navigator, initial version.
@
text
@d72 1
d146 1
d162 1
d221 7
d255 3
d514 7
@


1.3
log
@use generics wherever possible
@
text
@d68 1
d96 1
d144 1
d159 1
d201 7
d227 1
d268 2
d315 1
d498 1
@


1.2
log
@[124826] mgolubev - Support nodes with border items
@
text
@d128 1
@


1.1
log
@no api packages, classes are for internal use only
@
text
@d46 1
d88 1
d90 1
d343 7
d374 21
@


1.1.2.1
log
@[153901] Updated copyright date from 2005 to 2005, 2006 for those changed in CVS in 2006 (based on Tom/Anthony's script).
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
@


