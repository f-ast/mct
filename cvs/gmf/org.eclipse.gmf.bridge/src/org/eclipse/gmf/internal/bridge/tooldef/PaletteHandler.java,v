head	1.8;
access;
symbols
	v20081015-1925:1.8
	v20080917-1925:1.8
	v20080903-1520:1.8
	v20080827-1520:1.8
	v20080813-1520:1.8
	v20080722-1827:1.8
	v20080716-1642:1.8
	R2_1_maintenance:1.8.0.4
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080528-1052:1.8
	v20080507-1326:1.8
	v20080417-1610:1.8
	v20080222-1200:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	v20070621-0000:1.8
	RC3_20:1.8
	v20070608-1300:1.8
	v20070605-1400:1.8
	v20070601-1400:1.8
	v20070525-1500:1.8
	v20070518-1300:1.8
	v20070504-1000:1.8
	v20070427-0600:1.8
	v20070420-1000:1.8
	v20070413-1300:1.8
	v20070405-1100:1.8
	v20070330-1300:1.8
	v20070322-1100:1.8
	v20060316-0600:1.7
	v20070228-2000:1.7
	v20070208-1800:1.7
	M4_20:1.7
	v20061222-1800:1.7
	v20061214-0000:1.7
	M3_20:1.5
	v20061117-0800:1.5
	v20061013-1330:1.4
	v20060925-1700:1.3
	v20060919-0800:1.3
	M1_20:1.4
	v20060904-1500:1.4
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060626-1420:1.3
	v20060620-0400:1.3
	v20060616-1200:1.3
	v20060609-1400:1.3
	v20060531-1730:1.3
	v20060530-1930:1.3
	v20060526-1200:1.3
	v20060519-0800:1.3
	v20060512-1000:1.3
	I20060512-1000:1.3
	I20060505-1400:1.3
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2007.03.19.16.49.06;	author atikhomirov;	state Exp;
branches;
next	1.7;
commitid	5c9c45febf004567;

1.7
date	2006.11.28.17.30.28;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	3d1d456c72344567;

1.6
date	2006.11.22.20.09.48;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	29404564ae8c4567;

1.5
date	2006.10.31.14.56.49;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.04.15.11.59;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.20.17.38.33;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.19.20.52.53;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.19.19.42.08;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.8
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.tooldef;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.gmf.codegen.gmfgen.AbstractToolEntry;
import org.eclipse.gmf.codegen.gmfgen.EntryBase;
import org.eclipse.gmf.codegen.gmfgen.GMFGenFactory;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenNode;
import org.eclipse.gmf.codegen.gmfgen.Palette;
import org.eclipse.gmf.codegen.gmfgen.Separator;
import org.eclipse.gmf.codegen.gmfgen.StandardEntry;
import org.eclipse.gmf.codegen.gmfgen.StandardEntryKind;
import org.eclipse.gmf.codegen.gmfgen.ToolEntry;
import org.eclipse.gmf.codegen.gmfgen.ToolGroup;
import org.eclipse.gmf.codegen.gmfgen.ToolGroupItem;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.tooldef.AbstractTool;
import org.eclipse.gmf.tooldef.BundleImage;
import org.eclipse.gmf.tooldef.CreationTool;
import org.eclipse.gmf.tooldef.GenericTool;
import org.eclipse.gmf.tooldef.PaletteSeparator;
import org.eclipse.gmf.tooldef.StandardTool;
import org.eclipse.gmf.tooldef.StandardToolKind;
import org.eclipse.gmf.tooldef.ToolContainer;
import org.eclipse.gmf.tooldef.util.GMFToolSwitch;
import org.osgi.framework.Bundle;

/**
 * Invoke {@@link #initialize(Palette)} prior to use. Not intented to be reused, although may work.
 * Unless initialized, <code>process()</code> methods has no effect.
 * Mapping entries that reference tools from palette other than specified in the Mapping element,
 * will get into predefined group under genPalette. 
 * @@author artem
 */
public class PaletteHandler {
	private final HashMap<AbstractTool, ToolGroupItem> myToolHistory; // keeps track of tooldef-to-gmfgen tool transformations. Container maps to group as well
	private Palette myGenPalette;
	private ToolGroup myMisreferencedTools;

	public PaletteHandler() {
		myToolHistory = new HashMap<AbstractTool, ToolGroupItem>();
	}

	public void initialize(Palette genPalette) {
		assert genPalette != null; // TODO remove after debug
		myGenPalette = genPalette;
		myToolHistory.clear();
	}

	protected final Palette getGenPalette() {
		assert isInitialized(); // TODO remove after debug
		return myGenPalette;
	}

	/**
	 * There's nothing to do if handler was not initialized, 
	 * @@return
	 */
	protected final boolean isInitialized() {
		return myGenPalette != null;
	}	

	public void process(org.eclipse.gmf.tooldef.Palette palette) {
		if (!isInitialized()) {
			return;
		}
		// perhaps, moving this code to ToolSwitch and just doSwitch(palette) would be better?
		ArrayList<ToolGroup> groups = new ArrayList<ToolGroup>(palette.getTools().size());
		ArrayList<ToolGroupItem> topLevelTools = new ArrayList<ToolGroupItem>(palette.getTools().size());
		for (ToolGroupItem next : new ToolSwitch(myToolHistory).toGroupItems(palette.getTools())) {
			if (next instanceof ToolGroup) {
				groups.add((ToolGroup) next);
			} else {
				topLevelTools.add(next);
			}
		}
		if (!topLevelTools.isEmpty()) {
			ToolGroup defaultGroup = GMFGenFactory.eINSTANCE.createToolGroup();
			defaultGroup.setTitle("Default");
			defaultGroup.setDescription("Holds top-level non-container tools");
			defaultGroup.setCollapse(false);
			defaultGroup.getEntries().addAll(topLevelTools);
			getGenPalette().getGroups().add(defaultGroup);
		}
		getGenPalette().getGroups().addAll(groups);
		if (palette.getDefault() != null) {
			assert false == myToolHistory.get(palette.getDefault()) instanceof Separator;
			EntryBase eb = (EntryBase) myToolHistory.get(palette.getDefault());
			if (false == eb instanceof ToolEntry) {
				logWarning("There's default tool specified for palette, but can't find gmfgen counterpart");
			} else {
				((ToolEntry) eb).setDefault(true);
			}
		}
		getGenPalette().setFlyout(true); // FIXME option
	}

	public void process(NodeMapping nme, GenNode genNode) {
		if (!isInitialized() || nme.getTool() == null) {
			return;
		}
		ToolEntry te = toToolEntry(nme.getTool());
		if (te != null) {
			te.getGenNodes().add(genNode);
		}
	}

	public void process(LinkMapping lme, GenLink genLink) {
		if (!isInitialized() || lme.getTool() == null) {
			return;
		}
		ToolEntry te = toToolEntry(lme.getTool());
		if (te != null) {
			te.getGenLinks().add(genLink);
		}
	}

	/**
	 * Finds existing entry for tool or creates special 'missing' one if none found. 
	 */
	private ToolEntry toToolEntry(AbstractTool tool) {
		if (checkIsContainer(tool)) {
			return null;
		}
		ToolEntry te = findToolEntry(tool);
		if (te == null) {
			te = createMissingToolEntry(tool);
		}
		return te;
	}

	private static boolean checkIsContainer(AbstractTool tool) {
		if (tool instanceof ToolContainer) {
			logWarning("Can't use container here");
			return true;
		}
		return false;
	}

	private ToolEntry findToolEntry(AbstractTool tool) {
		assert !checkIsContainer(tool);
		return (ToolEntry) myToolHistory.get(tool);
	}

	private ToolEntry createMissingToolEntry(AbstractTool tool) {
		assert tool != null;
		if (myMisreferencedTools == null) {
			myMisreferencedTools = GMFGenFactory.eINSTANCE.createToolGroup();
			myMisreferencedTools.setCollapse(false);
			myMisreferencedTools.setStack(false);
			myMisreferencedTools.setTitle("-- Mis-referenced tools --");
			myMisreferencedTools.setDescription("Mapping element referenced tools from palette other than one specified in Mapping instance");
			getGenPalette().getGroups().add(myMisreferencedTools);
		}
		ToolEntry t = (ToolEntry) new ToolSwitch(myToolHistory).doSwitch(tool);
		if (t != null) {
			myToolHistory.put(tool, t);
			myMisreferencedTools.getEntries().add(t);
		}
		return t;
	}

	private static String constructIconPath(BundleImage icon) {
		assert icon != null;
		if (icon.getPath() == null || icon.getPath().trim().length() == 0) {
			// no idea why to go on
			return null;
		}
		if (icon.getBundle() == null || icon.getBundle().trim().length() == 0) {
			// Plugin.javajet#findImageDescriptor treats relative paths as bundle-local
			return new Path(icon.getPath()).makeRelative().toString();
		} else {
			// makeAbsolute on bundle segment only to avoid unwinding of ".." 
			return new Path(icon.getBundle()).makeAbsolute().append(icon.getPath()).toString();
		}
	}

	private static void logWarning(String message) {
		final Bundle b = Platform.getBundle("org.eclipse.gmf.bridge");
		Platform.getLog(b).log(new Status(IStatus.WARNING, b.getSymbolicName(), 0, message, null));
	}


	// XXX handle other tool types (action, whatever)
	private static class ToolSwitch extends GMFToolSwitch<ToolGroupItem> {
		private final Map<AbstractTool, ToolGroupItem> toolHistory;

		private ToolSwitch(Map<AbstractTool, ToolGroupItem> toolMap) {
			assert toolMap != null;
			toolHistory = toolMap;
		}

		public List<ToolGroupItem> toGroupItems(List<AbstractTool> toolDefinitions) {
			assert toolDefinitions != null;
			List<ToolGroupItem> rv = new LinkedList<ToolGroupItem>();
			for (AbstractTool next : toolDefinitions) {
				ToolGroupItem value = doSwitch(next);
				if (value == null) {
					logWarning("Can't transform '" + next + " to ToolGroupItem");
				} else {
					toolHistory.put(next, value);
					rv.add(value);
				}
			}
			return rv;
		}

		public ToolGroupItem casePaletteSeparator(PaletteSeparator object) {
			return GMFGenFactory.eINSTANCE.createSeparator();
		}
		
		public ToolGroupItem caseCreationTool(CreationTool tool) {
			ToolEntry ne = GMFGenFactory.eINSTANCE.createToolEntry();
			setupCommonToolEntry(ne, tool);
			return ne;
		}

		public ToolGroupItem caseStandardTool(StandardTool standardTool) {
			StandardEntry entry = GMFGenFactory.eINSTANCE.createStandardEntry();
			switch (standardTool.getToolKind().getValue()) {
				case StandardToolKind.SELECT : {
					entry.setKind(StandardEntryKind.SELECT_LITERAL);
					break;
				}
				case StandardToolKind.MARQUEE : {
					entry.setKind(StandardEntryKind.MARQUEE_LITERAL);
					break;
				}
				case StandardToolKind.ZOOM_PAN : {
					entry.setKind(StandardEntryKind.ZOOM_LITERAL);
					break;
				}
			}
			setupCommonToolEntry(entry, standardTool);
			return entry;
		}

		public ToolGroupItem caseGenericTool(GenericTool tool) {
			if (tool.getToolClass() == null) {
				logWarning("GenericTool element without a class, no palette entry createed");
				return null;
			}
			ToolEntry ne = GMFGenFactory.eINSTANCE.createToolEntry();
			ne.setQualifiedToolName(tool.getToolClass());
			setupCommonToolEntry(ne, tool);
			return ne;
		}

		public ToolGroupItem caseToolGroup(org.eclipse.gmf.tooldef.ToolGroup toolGroup) {
			ToolGroup tg = GMFGenFactory.eINSTANCE.createToolGroup();
			tg.setCollapse(toolGroup.isCollapsible());
			tg.setStack(toolGroup.isStack());
			setupCommonToolEntry(tg, toolGroup);
			tg.getEntries().addAll(toGroupItems(toolGroup.getTools()));
			if (toolGroup.getActive() != null) {
				assert false == toolHistory.get(toolGroup.getActive()) instanceof Separator;
				EntryBase eb = (EntryBase) toolHistory.get(toolGroup.getActive());
				if (eb == null || false == eb instanceof AbstractToolEntry) {
					logWarning("Can't find entry to became default in the group:" + toolGroup);
				} else {
					((AbstractToolEntry) eb).setDefault(true);
				}
			}
			return tg;
		}

		private static void setupCommonToolEntry(EntryBase te, AbstractTool tool) {
			te.setTitle(tool.getTitle() == null ? "" : tool.getTitle()); // same at (*1*)
			te.setDescription(tool.getDescription());
			// FIXME need to change this once better tooling definition is in place.
			// FIXME update gmfgen model to explicitly understand images from different bundles
			if (tool.getLargeIcon() instanceof BundleImage) {
				te.setLargeIconPath(constructIconPath((BundleImage) tool.getLargeIcon()));
			}
			if (tool.getSmallIcon() instanceof BundleImage) {
				te.setSmallIconPath(constructIconPath((BundleImage) tool.getSmallIcon()));
			}
		}
	}
}
@


1.7
log
@organized imports
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
d14 1
a15 1
import java.util.Iterator;
a23 2
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
a83 1
	@@SuppressWarnings("unchecked")
d89 6
a94 6
		List groupItems = new ToolSwitch(myToolHistory).toGroupItems(palette.getTools());
		EList topLevelTools = new BasicEList();
		for (Iterator it = groupItems.iterator(); it.hasNext(); ) {
			ToolGroupItem next = (ToolGroupItem) it.next();
			if (false == next instanceof ToolGroup) {
				it.remove();
d106 1
a106 1
		getGenPalette().getGroups().addAll(groupItems);
a118 1
	@@SuppressWarnings("unchecked")
a128 1
	@@SuppressWarnings("unchecked")
a165 1
	@@SuppressWarnings("unchecked")
d206 1
a206 1
	private static class ToolSwitch extends GMFToolSwitch {
d218 1
a218 1
				ToolGroupItem value = (ToolGroupItem) doSwitch(next);
d229 1
a229 1
		public Object casePaletteSeparator(PaletteSeparator object) {
d233 1
a233 1
		public Object caseCreationTool(CreationTool tool) {
d239 1
a239 1
		public Object caseStandardTool(StandardTool standardTool) {
d259 1
a259 1
		public Object caseGenericTool(GenericTool tool) {
d270 1
a270 2
		@@SuppressWarnings("unchecked")
		public Object caseToolGroup(org.eclipse.gmf.tooldef.ToolGroup toolGroup) {
@


1.6
log
@[164021] allow to choose standard tools
@
text
@a48 1
import org.eclipse.jdt.core.ToolFactory;
@


1.5
log
@[134121] mgolubev - Tools stack definition in the model
[162456] mgolubev - Change GenericTool#toolClass type from Class to String
@
text
@d26 1
d33 2
d46 1
d49 1
d246 18
a263 3
		public Object caseStandardTool(StandardTool object) {
			// FIXME
			return super.caseStandardTool(object);
d284 9
@


1.4
log
@use generics wherever possible
@
text
@d252 1
a252 1
			ne.setQualifiedToolName(tool.getToolClass().getName());
d261 1
a261 1
			tg.setStack(false);
@


1.3
log
@#133467 respect order and separators from tooldef, with tests
@
text
@d16 2
a25 1
import org.eclipse.emf.ecore.EObject;
d31 1
d55 1
a55 1
	private final HashMap/*<AbstractTool, EntryBase>*/ myToolHistory; // keeps track of tooldef-to-gmfgen tool transformations. Container maps to group as well
d60 1
a60 1
		myToolHistory = new HashMap();
d82 1
d88 1
a88 1
		EList groupItems = new ToolSwitch(myToolHistory).toGroupItems(palette.getTools());
d107 1
d118 1
d129 1
d167 1
d209 1
a209 1
		private final Map toolHistory;
d211 1
a211 1
		private ToolSwitch(Map toolMap) {
d216 1
a216 1
		public EList/*<ToolGroupItem>*/ toGroupItems(EList/*<AbstractTool>*/ toolDefinitions) {
d218 3
a220 4
			EList rv = new BasicEList();
			for (Iterator it = toolDefinitions.iterator(); it.hasNext();) {
				final EObject next = (EObject) it.next();
				Object value = doSwitch(next);
d257 1
@


1.2
log
@Tests to cover most of #131270 - Duplicated tool entries when same tool definition is referenced from gmfmap.
@
text
@d39 1
d225 3
@


1.1
log
@#131270 Duplicated tool entries when same tool definition is referenced from gmfmap.
@
text
@d168 1
@

