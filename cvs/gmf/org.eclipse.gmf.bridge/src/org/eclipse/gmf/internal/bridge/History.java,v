head	1.5;
access;
symbols
	v20081015-1925:1.5
	v20080917-1925:1.5
	v20080903-1520:1.5
	v20080827-1520:1.5
	v20080813-1520:1.5
	v20080722-1827:1.5
	v20080716-1642:1.5
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080528-1052:1.5
	v20080507-1326:1.5
	v20080417-1610:1.5
	v20080222-1200:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070608-1300:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070525-1500:1.5
	v20070518-1300:1.5
	v20070504-1000:1.5
	v20070427-0600:1.5
	v20070420-1000:1.5
	v20070413-1300:1.5
	v20070405-1100:1.5
	v20070330-1300:1.5
	v20070322-1100:1.5
	v20060316-0600:1.5
	v20070228-2000:1.5
	v20070208-1800:1.5
	M4_20:1.5
	v20061222-1800:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061117-0800:1.5
	v20061013-1330:1.5
	v20060925-1700:1.4
	v20060919-0800:1.4
	M1_20:1.5
	v20060904-1500:1.5
	v20060713-1700:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060626-1420:1.4
	v20060620-0400:1.4
	v20060616-1200:1.4
	v20060609-1400:1.4
	v20060531-1730:1.4
	v20060530-1930:1.4
	v20060526-1200:1.4
	v20060519-0800:1.4
	v20060512-1000:1.4
	I20060512-1000:1.4
	I20060505-1400:1.3
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.5
date	2006.09.04.15.11.59;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.11.18.37.44;	author radvorak;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.13.17.56.08;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.03.11.36.23;	author ashatalin;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.24.18.28.15;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.5
log
@use generics wherever possible
@
text
@/*
 * Copyright (c) 2006 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.eclipse.gmf.codegen.gmfgen.GenChildNode;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenMetricRule;
import org.eclipse.gmf.codegen.gmfgen.GenNode;
import org.eclipse.gmf.codegen.gmfgen.GenTopLevelNode;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.MetricRule;
import org.eclipse.gmf.mappings.NodeMapping;

/**
 * Keep track of gmfmap-to-gmfgen transformation elements.
 * @@author artem
 */
public class History {
	private final Map<NodeMapping, GenTopLevelNode> myTopNodeMap;	
	private final Map<NodeMapping, Set<GenChildNode>> myNodeMap;
	private final Map<LinkMapping, GenLink> myLinkMap;
	private final Map<MetricRule, GenMetricRule> myMetricMap;

	public History() {
		myTopNodeMap = new HashMap<NodeMapping, GenTopLevelNode>();		
		myNodeMap = new HashMap<NodeMapping, Set<GenChildNode>>();
		myLinkMap = new HashMap<LinkMapping, GenLink>();
		myMetricMap = new HashMap<MetricRule, GenMetricRule>();
	}

	/**
	 * No more then 1 GenTopLevelNode may be logged for node mapping 
	 */
	public void log(NodeMapping nodeMap, GenTopLevelNode genNode) {
		assert nodeMap != null && genNode != null && !myTopNodeMap.containsKey(nodeMap);
		myTopNodeMap.put(nodeMap, genNode);
	}	

	/**
	 * More than 1 GenChildNode may be logged for node mapping  
	 * (to handle children taken from different containment/children features)
	 */
	public void log(NodeMapping nodeMap, GenChildNode genNode) {
		assert nodeMap != null && genNode != null;
		Set<GenChildNode> genNodes = myNodeMap.get(nodeMap);
		if (genNodes == null) {
			genNodes = new HashSet<GenChildNode>();
			myNodeMap.put(nodeMap, genNodes);
		}
		genNodes.add(genNode);
	}

	/**
	 * No more than 1 GenLink is allowed for link mapping.
	 */
	public void log(LinkMapping linkMap, GenLink genLink) {
		assert linkMap != null && genLink != null && !myLinkMap.containsKey(linkMap);
		myLinkMap.put(linkMap, genLink);
	}
	
	public void log(MetricRule metric, GenMetricRule genMetric) {
		assert metric != null && genMetric != null;
		myMetricMap.put(metric, genMetric);
	}
	
	public GenMetricRule find(MetricRule metric) {
		assert metric != null;
		return myMetricMap.get(metric);
	}	
	

	public boolean isKnown(NodeMapping nodeMap) {
		return isKnownTopNode(nodeMap) || isKnownChildNode(nodeMap);
	}	
		
	public boolean isKnownTopNode(NodeMapping nodeMap) {
		assert nodeMap != null;
		return myTopNodeMap.containsKey(nodeMap);
	}	
	
	public boolean isKnownChildNode(NodeMapping nodeMap) {
		assert nodeMap != null;
		// We don't check stored collections as there's no means to remove element from this history,
		// thus, no way to get empty collection
		return myNodeMap.containsKey(nodeMap);
	}

	public boolean isKnown(LinkMapping linkMap) {
		assert linkMap != null;
		return myLinkMap.containsKey(linkMap);
	}

	/**
	 * @@return never <code>null</code>>
	 */
	public GenChildNode[] findChildNodes(NodeMapping nodeMap) {
		assert nodeMap != null;
		Set<GenChildNode> genNodes = myNodeMap.get(nodeMap);
		if (genNodes == null) {
			return new GenChildNode[0];
		}
		return genNodes.toArray(new GenChildNode[genNodes.size()]);
	}
	
	public GenTopLevelNode findTopNode(NodeMapping nodeMap) {
		assert nodeMap != null;
		return myTopNodeMap.get(nodeMap);
	}
	
	public GenNode[] find(NodeMapping nodeMap) {
		assert nodeMap != null;
		GenNode genNode = findTopNode(nodeMap);
		return genNode != null ? new GenNode[] {genNode} : findChildNodes(nodeMap);
	}

	public GenLink find(LinkMapping linkMap) {
		assert linkMap != null;
		return myLinkMap.get(linkMap);
	}

	public void purge() {
		myTopNodeMap.clear();
		myNodeMap.clear();
		myLinkMap.clear();
		myMetricMap.clear();
	}
}
@


1.4
log
@#141340  Audit rule targeted to a metric definition is not registered as valid constraint
@
text
@d33 4
a36 4
	private final Map/*<NodeMapping, GenTopLevelNode>*/ myTopNodeMap;	
	private final Map/*<NodeMapping, Set<GenChildNode>>*/ myNodeMap;
	private final Map/*<LinkMapping, GenLink>*/ myLinkMap;
	private final Map/*<MetricRule, GenMetricRule>*/ myMetricMap;
d39 4
a42 4
		myTopNodeMap = new HashMap();		
		myNodeMap = new HashMap();
		myLinkMap = new HashMap();
		myMetricMap = new HashMap();
d59 1
a59 1
		Set genNodes = (Set) myNodeMap.get(nodeMap);
d61 1
a61 1
			genNodes = new HashSet/*<GenChildNode>*/();
d82 1
a82 1
		return (GenMetricRule) myMetricMap.get(metric);
d112 1
a112 1
		Set genNodes = (Set) myNodeMap.get(nodeMap);
d116 1
a116 1
		return (GenChildNode[]) genNodes.toArray(new GenChildNode[genNodes.size()]);
d121 1
a121 1
		return (GenTopLevelNode) myTopNodeMap.get(nodeMap);
d132 1
a132 1
		return (GenLink) myLinkMap.get(linkMap);
@


1.3
log
@#129552 correctly handle reuse of node mappings with distinct containment references
@
text
@d21 1
d25 1
d36 1
d42 1
d74 11
d139 1
@


1.2
log
@#130009 Enable audit rules on diagram (notation model) elements in gmfmap model
@
text
@d15 1
d17 1
d27 1
a27 1
 * We don't suppose to reuse GenTopLevelNodes, thus API references GenChildNodes
d32 1
a32 1
	private final Map/*<NodeMapping, GenChildNode>*/ myNodeMap;
d41 3
a45 7
		// TODO leave only asserts
		if (nodeMap == null || genNode == null) {
			throw new NullPointerException();
		}
		if (myTopNodeMap.containsKey(nodeMap)) {
			throw new IllegalArgumentException(nodeMap.toString());
		}
d48 5
a52 1
	
d54 5
a58 4
		assert nodeMap != null && genNode != null && !myNodeMap.containsKey(nodeMap);
		// TODO leave only asserts
		if (nodeMap == null || genNode == null) {
			throw new NullPointerException();
d60 1
a60 4
		if (myNodeMap.containsKey(nodeMap)) {
			throw new IllegalArgumentException(nodeMap.toString());
		}
		myNodeMap.put(nodeMap, genNode);
d63 3
d72 1
a72 2
		assert nodeMap != null;
		return myTopNodeMap.containsKey(nodeMap) || myNodeMap.containsKey(nodeMap);
d82 2
d92 10
a101 3
	public GenChildNode findChildNode(NodeMapping nodeMap) {
		assert nodeMap != null;
		return (GenChildNode) myNodeMap.get(nodeMap);
d109 1
a109 1
	public GenNode find(NodeMapping nodeMap) {
d112 1
a112 1
		return genNode != null ? genNode : findChildNode(nodeMap);
@


1.1
log
@#128774 Keep history of mappings during transformation
@
text
@d19 2
d29 1
d34 1
d39 12
d70 10
d88 1
a88 1
	public GenChildNode find(NodeMapping nodeMap) {
d92 11
d110 1
@

