head	1.4;
access;
symbols
	v20081015-1925:1.4
	v20080917-1925:1.4
	v20080903-1520:1.4
	v20080827-1520:1.4
	v20080813-1520:1.4
	v20080722-1827:1.4
	v20080716-1642:1.4
	R2_1_maintenance:1.4.0.4
	Root_R2_1_maintenance:1.4
	R2_1_0:1.4
	v20080528-1052:1.4
	v20080507-1326:1.4
	v20080417-1610:1.4
	v20080222-1200:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.4
	v20070608-1300:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070525-1500:1.4
	v20070518-1300:1.4
	v20070504-1000:1.4
	v20070427-0600:1.4
	v20070420-1000:1.4
	v20070413-1300:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.4
date	2007.04.19.09.55.14;	author dstadnik;	state Exp;
branches;
next	1.3;
commitid	ad146273c814567;

1.3
date	2007.04.18.17.03.15;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	586b46264f524567;

1.2
date	2007.04.11.08.10.28;	author dstadnik;	state Exp;
branches;
next	1.1;
commitid	74a1461c97f44567;

1.1
date	2007.04.10.14.00.38;	author dstadnik;	state Exp;
branches;
next	;
commitid	2515461b98854567;


desc
@@


1.4
log
@use enum
@
text
@/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.naming.gen;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.gmf.codegen.gmfgen.GMFGenPackage;
import org.eclipse.gmf.codegen.gmfgen.GenChildContainer;
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
import org.eclipse.gmf.codegen.gmfgen.GenCompartment;
import org.eclipse.gmf.codegen.gmfgen.GenContainerBase;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenEditorGenerator;
import org.eclipse.gmf.codegen.gmfgen.GenLabel;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenNode;
import org.eclipse.gmf.codegen.gmfgen.MetamodelType;
import org.eclipse.gmf.codegen.gmfgen.SpecializationType;
import org.eclipse.gmf.internal.bridge.naming.ClassGenNamingStrategy;
import org.eclipse.gmf.internal.bridge.naming.DefaultGenNamingStrategy;
import org.eclipse.gmf.internal.bridge.naming.DesignGenNamingStrategy;
import org.eclipse.gmf.internal.bridge.naming.GenNamingStrategy;
import org.eclipse.gmf.internal.common.IncrementalNamesDispenser;
import org.eclipse.gmf.internal.common.NamesDispenser;

/**
 * @@author dstadnik
 */
public class GenNamingMediatorImpl implements GenNamingMediator {

	public enum Mode {
		COLLECT_NAMES,
		DISPENSE_NAMES
	}

	private final GMFGenPackage M = GMFGenPackage.eINSTANCE;

	private Mode mode;

	private NamesDispenser dispenser;

	private GenNamingStrategy viewFactory;

	private GenNamingStrategy editPart;

	private GenNamingStrategy itemSemanticPolicy;

	private GenNamingStrategy canonicalPolicy;

	private GenNamingStrategy nodeGraphicalPolicy;

	private GenNamingStrategy editHelper;

	private GenNamingStrategy editHelperAdvice;

	private GenNamingStrategy linkCreateCommand;

	private GenNamingStrategy nodeCreateCommand;

	private GenNamingStrategy linkReorientCommand;

	public GenNamingMediatorImpl() {
		this(new IncrementalNamesDispenser());
	}

	public GenNamingMediatorImpl(NamesDispenser dispenser) {
		this.dispenser = dispenser;
		mode = Mode.DISPENSE_NAMES;
		setViewFactory(createNamingStrategy(GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
		setEditPart(createNamingStrategy(GenCommonBase.EDIT_PART_SUFFIX));
		setItemSemanticPolicy(createNamingStrategy(GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
		setCanonicalPolicy(createNamingStrategy(GenChildContainer.CANONICAL_EDIT_POLICY_SUFFIX));
		setNodeGraphicalPolicy(createNamingStrategy(GenNode.GRAPHICAL_NODE_EDIT_POLICY_SUFFIX));
		setEditHelper(createNamingStrategy(MetamodelType.EDIT_HELPER_SUFFIX));
		setEditHelperAdvice(createNamingStrategy(SpecializationType.EDIT_HELPER_ADVICE_SUFFIX));
		setLinkCreateCommand(createNamingStrategy(GenLink.CREATE_COMMAND_SUFFIX));
		setNodeCreateCommand(createNamingStrategy(GenNode.CREATE_COMMAND_SUFFIX));
		setLinkReorientCommand(createNamingStrategy(GenLink.REORIENT_COMMAND_SUFFIX));
	}

	protected GenNamingStrategy createNamingStrategy(String suffixPart) {
		// prefix stack
		GenNamingStrategy pns = new DefaultGenNamingStrategy(null, null, null, null);
		pns = new DesignGenNamingStrategy(null, null, pns, null);
		pns = new ClassGenNamingStrategy(null, null, pns, null);
		// primary stack
		GenNamingStrategy ns = new DefaultGenNamingStrategy(suffixPart, dispenser, null, pns);
		ns = new DesignGenNamingStrategy(suffixPart, dispenser, ns, pns);
		ns = new ClassGenNamingStrategy(suffixPart, dispenser, ns, pns);
		return ns;
	}

	public void reset() {
		if (dispenser != null) {
			dispenser.clear();
		}
	}

	public final Mode getMode() {
		return mode;
	}

	public void setMode(Mode mode) {
		this.mode = mode;
	}

	protected void feedName(EObject element, EAttribute feature, GenNamingStrategy strategy, EObject refElement) {
		switch (getMode()) {
		case COLLECT_NAMES:
			if (element.eIsSet(feature)) {
				dispenser.add((String) element.eGet(feature));
			}
			break;
		case DISPENSE_NAMES:
			if (!element.eIsSet(feature)) {
				element.eSet(feature, getName(refElement, strategy));
			}
			break;
		}
	}

	protected void feedName(EObject element, EAttribute feature, GenNamingStrategy strategy) {
		feedName(element, feature, strategy, element);
	}

	public void feed(GenDiagram element) {
		dispenser.add(element.getBaseExternalNodeLabelEditPartClassName());
		dispenser.add(element.getBaseItemSemanticEditPolicyClassName());
		dispenser.add(element.getBaseGraphicalNodeEditPolicyClassName());
		dispenser.add(element.getBaseEditHelperClassName());

		feedContainer(element);
	}

	public void feed(GenNode element) {
		feedContainer(element);
		feedName(element, M.getGenNode_GraphicalNodeEditPolicyClassName(), getNodeGraphicalPolicy());
		feedName(element, M.getGenNode_CreateCommandClassName(), getNodeCreateCommand());
	}

	public void feed(GenCompartment element) {
		feedContainer(element);
	}

	public void feed(GenLink element) {
		feedCommon(element);
		feedName(element, M.getGenLink_CreateCommandClassName(), getLinkCreateCommand());
		feedName(element, M.getGenLink_ReorientCommandClassName(), getLinkReorientCommand());
	}

	public void feed(GenLabel element) {
		feedCommon(element);
	}

	protected void feedContainer(GenContainerBase element) {
		feedCommon(element);
		feedName(element, M.getGenContainerBase_CanonicalEditPolicyClassName(), getCanonicalPolicy());
	}

	protected void feedCommon(GenCommonBase element) {
		feedName(element, M.getGenCommonBase_NotationViewFactoryClassName(), getViewFactory());
		feedName(element, M.getGenCommonBase_EditPartClassName(), getEditPart());
		feedName(element, M.getGenCommonBase_ItemSemanticEditPolicyClassName(), getItemSemanticPolicy());
		if (element.getElementType() instanceof MetamodelType) {
			MetamodelType type = (MetamodelType) element.getElementType();
			feedName(type, M.getMetamodelType_EditHelperClassName(), getEditHelper(), element);
//		} else if (element.getElementType() instanceof SpecializationType) {
//			/*
//			 * Uncoment once we generate anything reasonable in the advice's body;
//			 * otherwise no reason to generate empty class
//			 */
//			SpecializationType type = (SpecializationType) element.getElementType();
//			feedName(type, M.getSpecializationType_EditHelperAdviceClassName(), getEditHelperAdvice(), element);
		}
	}

	protected String getName(EObject element, GenNamingStrategy strategy) {
		if (element instanceof GenDiagram) {
			return strategy.get((GenDiagram) element);
		} else if (element instanceof GenNode) {
			return strategy.get((GenNode) element);
		} else if (element instanceof GenCompartment) {
			return strategy.get((GenCompartment) element);
		} else if (element instanceof GenLink) {
			return strategy.get((GenLink) element);
		} else if (element instanceof GenLabel) {
			return strategy.get((GenLabel) element);
		}
		throw new IllegalArgumentException();
	}

	public void traverse(GenEditorGenerator gen) {
		GenDiagram diagram = gen.getDiagram();
		feed(diagram);
		for (GenNode node : diagram.getTopLevelNodes()) {
			feed(node);
			for (GenLabel label : node.getLabels()) {
				feed(label);
			}
		}
		for (GenNode node : diagram.getChildNodes()) {
			feed(node);
			for (GenLabel label : node.getLabels()) {
				feed(label);
			}
		}
		for (GenCompartment node : diagram.getCompartments()) {
			feed(node);
		}
		for (GenLink link : diagram.getLinks()) {
			feed(link);
			for (GenLabel label : link.getLabels()) {
				feed(label);
			}
		}
	}

	public GenNamingStrategy getViewFactory() {
		return viewFactory;
	}

	public void setViewFactory(GenNamingStrategy viewFactory) {
		this.viewFactory = viewFactory;
	}

	public GenNamingStrategy getEditPart() {
		return editPart;
	}

	public void setEditPart(GenNamingStrategy editPart) {
		this.editPart = editPart;
	}

	public GenNamingStrategy getItemSemanticPolicy() {
		return itemSemanticPolicy;
	}

	public void setItemSemanticPolicy(GenNamingStrategy itemSemanticPolicy) {
		this.itemSemanticPolicy = itemSemanticPolicy;
	}

	public GenNamingStrategy getCanonicalPolicy() {
		return canonicalPolicy;
	}

	public void setCanonicalPolicy(GenNamingStrategy canonicalPolicy) {
		this.canonicalPolicy = canonicalPolicy;
	}

	public GenNamingStrategy getNodeGraphicalPolicy() {
		return nodeGraphicalPolicy;
	}

	public void setNodeGraphicalPolicy(GenNamingStrategy nodeGraphicalPolicy) {
		this.nodeGraphicalPolicy = nodeGraphicalPolicy;
	}

	public GenNamingStrategy getEditHelper() {
		return editHelper;
	}

	public void setEditHelper(GenNamingStrategy editHelper) {
		this.editHelper = editHelper;
	}

	public GenNamingStrategy getEditHelperAdvice() {
		return editHelperAdvice;
	}

	public void setEditHelperAdvice(GenNamingStrategy editHelperAdvice) {
		this.editHelperAdvice = editHelperAdvice;
	}

	public GenNamingStrategy getLinkCreateCommand() {
		return linkCreateCommand;
	}

	public void setLinkCreateCommand(GenNamingStrategy linkCreateCommand) {
		this.linkCreateCommand = linkCreateCommand;
	}

	public GenNamingStrategy getNodeCreateCommand() {
		return nodeCreateCommand;
	}

	public void setNodeCreateCommand(GenNamingStrategy nodeCreateCommand) {
		this.nodeCreateCommand = nodeCreateCommand;
	}

	public GenNamingStrategy getLinkReorientCommand() {
		return linkReorientCommand;
	}

	public void setLinkReorientCommand(GenNamingStrategy linkReorientCommand) {
		this.linkReorientCommand = linkReorientCommand;
	}
}
@


1.3
log
@no reason to generate empty edithelper advices unless we do generate some meaningful code within. Those willing to get empty classes generated can specify advice class name in the model
@
text
@d40 4
a43 3
	public static final int COLLECT_NAMES_MODE = 0;

	public static final int DISPENSE_NAMES_MODE = 1;
d47 1
a47 1
	private int mode;
d77 1
a77 1
		mode = DISPENSE_NAMES_MODE;
d108 1
a108 1
	public final int getMode() {
d112 1
a112 4
	public void setMode(int mode) {
		if (mode != COLLECT_NAMES_MODE && mode != DISPENSE_NAMES_MODE) {
			throw new IllegalArgumentException();
		}
d118 1
a118 1
		case COLLECT_NAMES_MODE:
d123 1
a123 1
		case DISPENSE_NAMES_MODE:
@


1.2
log
@[181778] Generate standalone creation commands for reference based links
@
text
@a39 2
	private static final GMFGenPackage M = GMFGenPackage.eINSTANCE;

d44 2
d178 7
a184 3
		} else if (element.getElementType() instanceof SpecializationType) {
			SpecializationType type = (SpecializationType) element.getElementType();
			feedName(type, M.getSpecializationType_EditHelperAdviceClassName(), getEditHelperAdvice(), element);
@


1.1
log
@[155332] Reconcile edit part class names
@
text
@a27 1
import org.eclipse.gmf.codegen.gmfgen.TypeLinkModelFacet;
d64 1
a64 1
	private GenNamingStrategy typeLinkCreateCommand;
d84 1
a84 1
		setTypeLinkCreateCommand(createNamingStrategy(TypeLinkModelFacet.CREATE_COMMAND_SUFFIX));
d158 1
a158 4
		if (element.getModelFacet() instanceof TypeLinkModelFacet) {
			TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) element.getModelFacet();
			feedName(modelFacet, M.getTypeLinkModelFacet_CreateCommandClassName(), getTypeLinkCreateCommand(), element);
		}
d281 2
a282 2
	public GenNamingStrategy getTypeLinkCreateCommand() {
		return typeLinkCreateCommand;
d285 2
a286 2
	public void setTypeLinkCreateCommand(GenNamingStrategy typeLinkCreateCommand) {
		this.typeLinkCreateCommand = typeLinkCreateCommand;
@

