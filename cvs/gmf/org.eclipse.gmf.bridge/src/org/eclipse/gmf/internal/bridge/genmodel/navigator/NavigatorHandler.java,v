head	1.11;
access;
symbols
	v20081015-1925:1.11
	v20080917-1925:1.11
	v20080903-1520:1.11
	v20080827-1520:1.11
	v20080813-1520:1.11
	v20080722-1827:1.11
	v20080716-1642:1.11
	R2_1_maintenance:1.11.0.4
	Root_R2_1_maintenance:1.11
	R2_1_0:1.11
	v20080528-1052:1.11
	v20080507-1326:1.11
	v20080417-1610:1.11
	v20080222-1200:1.11
	v20070809-0000:1.11
	R2_0_maintenance:1.11.0.2
	R2_0:1.11
	R4_20:1.11
	v20070621-0000:1.11
	RC3_20:1.11
	v20070608-1300:1.11
	v20070605-1400:1.11
	v20070601-1400:1.11
	v20070525-1500:1.11
	v20070518-1300:1.11
	v20070504-1000:1.11
	v20070427-0600:1.11
	v20070420-1000:1.11
	v20070413-1300:1.11
	v20070405-1100:1.11
	v20070330-1300:1.11
	v20070322-1100:1.11
	v20060316-0600:1.9
	v20070228-2000:1.9
	v20070208-1800:1.9
	M4_20:1.6
	v20061222-1800:1.6
	v20061214-0000:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061013-1330:1.4;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2007.03.20.20.15.03;	author ashatalin;	state Exp;
branches;
next	1.10;
commitid	1c2d460040c74567;

1.10
date	2007.03.19.16.49.06;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	5c9c45febf004567;

1.9
date	2007.02.06.15.48.18;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	360e45c8a3414567;

1.8
date	2007.01.30.17.55.46;	author ashatalin;	state Exp;
branches;
next	1.7;
commitid	3b2545bf86a14567;

1.7
date	2007.01.17.13.12.37;	author ashatalin;	state Exp;
branches;
next	1.6;
commitid	3da945ae20c54567;

1.6
date	2006.11.02.14.12.19;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.18.11.08.31;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.18.19.17.08;	author ashatalin;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.15.21.44.45;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.14.18.08.56;	author ashatalin;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.11.18.21.40;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.11
log
@NavigatorReference type constant name corrected.
Generating wrapper for domain model navigator nodes to preserve navigator tree selection/expansion on model files reload.
@
text
@/**
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.genmodel.navigator;

import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.gmf.codegen.gmfgen.GMFGenFactory;
import org.eclipse.gmf.codegen.gmfgen.GenChildContainer;
import org.eclipse.gmf.codegen.gmfgen.GenChildNode;
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
import org.eclipse.gmf.codegen.gmfgen.GenCompartment;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenNavigator;
import org.eclipse.gmf.codegen.gmfgen.GenNavigatorChildReference;
import org.eclipse.gmf.codegen.gmfgen.GenNavigatorReferenceType;
import org.eclipse.gmf.codegen.gmfgen.GenNode;
import org.eclipse.gmf.codegen.gmfgen.GenTopLevelNode;

public class NavigatorHandler {

	private GenDiagram myDiagram;

	private GenNavigator myNavigator;

	private boolean myShowLinkTargets;

	private boolean myShowOutgoingLinks;

	private boolean myShowLinkSources;

	private boolean myShowIncomingLinks;
	
	public NavigatorHandler() {
		myShowIncomingLinks = true;
		myShowOutgoingLinks = true;
		myShowLinkSources = true;
		myShowLinkTargets = true;
	}

	public void initialize(GenDiagram genDiagram, GenNavigator genNavigator) {
		myDiagram = genDiagram;
		myNavigator = genNavigator;
		process(myDiagram);
	}

	public void process(GenDiagram diagram) {
		createChildReference(diagram, null, GenNavigatorReferenceType.CHILDREN_LITERAL);
	}

	public void process(GenTopLevelNode topLevelNode) {
		createChildNodeReference(topLevelNode, myDiagram);
	}

	public void process(GenChildNode childNode, GenChildContainer container) {
		GenNode parent = null;
		if (container instanceof GenCompartment) {
			parent = ((GenCompartment) container).getNode();
		} else if (container instanceof GenNode) {
			parent = (GenNode) container;
		}
		assert parent != null;
		createChildNodeReference(childNode, parent);
	}

	public void process(GenLink link) {
		GenNavigatorChildReference childReference = createChildReference(link, myDiagram, GenNavigatorReferenceType.CHILDREN_LITERAL);
		childReference.setGroupName("links");
		childReference.setGroupIcon("icons/linksNavigatorGroup.gif");


		Collection<GenNode> targetNodes = getTargetGenNodes(link);
		for (GenNode node : targetNodes) {
			if (myShowLinkTargets) {
				GenNavigatorChildReference reference = createChildReference(node, link, GenNavigatorReferenceType.OUT_TARGET_LITERAL);
				reference.setGroupName("target");
				reference.setGroupIcon("icons/linkTargetNavigatorGroup.gif");
			}
			
			if (myShowIncomingLinks) {
				GenNavigatorChildReference reference = createChildReference(link, node, GenNavigatorReferenceType.IN_SOURCE_LITERAL);
				reference.setGroupName("incoming links");
				reference.setGroupIcon("icons/incomingLinksNavigatorGroup.gif");
			}
		}

		Collection<GenNode> sourceNodes = getSourceGenNodes(link);
		for (GenNode node : sourceNodes) {
			if (myShowLinkSources) {
				GenNavigatorChildReference reference = createChildReference(node, link, GenNavigatorReferenceType.IN_SOURCE_LITERAL);
				reference.setGroupName("source");
				reference.setGroupIcon("icons/linkSourceNavigatorGroup.gif");
			}
			
			if (myShowOutgoingLinks) {
				GenNavigatorChildReference reference = createChildReference(link, node, GenNavigatorReferenceType.OUT_TARGET_LITERAL);
				reference.setGroupName("outgoing links");
				reference.setGroupIcon("icons/outgoingLinksNavigatorGroup.gif");
			}
		}
	}

	private Collection<GenNode> getTargetGenNodes(GenLink link) {
		if (link.getModelFacet() == null) {
			return myDiagram.getAllNodes();
		}
		return getAssignableGenNodes(link.getModelFacet().getTargetType());
	}

	private Collection<GenNode> getSourceGenNodes(GenLink link) {
		if (link.getModelFacet() == null) {
			return myDiagram.getAllNodes();
		}
		return getAssignableGenNodes(link.getModelFacet().getSourceType());
	}

	private Collection<GenNode> getAssignableGenNodes(GenClass genClass) {
		if (genClass == null) {
			return Collections.emptyList();
		}
		Collection<GenNode> result = new LinkedHashSet<GenNode>();
		for (GenNode nextNode : myDiagram.getAllNodes()) {
			if (genClass.getEcoreClass().isSuperTypeOf(nextNode.getDomainMetaClass().getEcoreClass())) {
				result.add(nextNode);
			}
		}
		return result;
	}

	private void createChildNodeReference(GenNode childNode, GenCommonBase parent) {
		createChildReference(childNode, parent, GenNavigatorReferenceType.CHILDREN_LITERAL);
	}

	private GenNavigatorChildReference createChildReference(GenCommonBase child, GenCommonBase parent, GenNavigatorReferenceType referenceType) {
		GenNavigatorChildReference childReference = GMFGenFactory.eINSTANCE.createGenNavigatorChildReference();
		if (parent != null) {
			childReference.setParent(parent);
		}
		childReference.setChild(child);
		childReference.setReferenceType(referenceType);
		myNavigator.getChildReferences().add(childReference);
		return childReference;
	}

}
@


1.10
log
@EMF 2.3 M5 and Java 5 cleanup
@
text
@d87 1
a87 1
				GenNavigatorChildReference reference = createChildReference(node, link, GenNavigatorReferenceType.OUT_TAGET_LITERAL);
d108 1
a108 1
				GenNavigatorChildReference reference = createChildReference(link, node, GenNavigatorReferenceType.OUT_TAGET_LITERAL);
@


1.9
log
@clear few warnings
@
text
@d15 1
a15 1
import java.util.Iterator;
a114 1
	@@SuppressWarnings("unchecked")
a121 1
	@@SuppressWarnings("unchecked")
d130 3
d134 1
a134 2
		for (Iterator genNodes = myDiagram.getAllNodes().iterator(); genClass != null && genNodes.hasNext();) {
			GenNode nextNode = (GenNode) genNodes.next();
a145 1
	@@SuppressWarnings("unchecked")
@


1.8
log
@Correcting navigator transformation.
@
text
@d115 1
d123 1
d146 1
@


1.7
log
@NodeItemSemanticEditPolicy template reimplemented using xpand.
@
text
@a134 1
				break;
@


1.6
log
@Linked elements are leafs by default.
@
text
@d119 1
a119 1
		return getAssignableGenNodes(link.getModelFacet().getTargetTypes());
d126 1
a126 1
		return getAssignableGenNodes(link.getModelFacet().getSourceTypes());
d129 1
a129 1
	private Collection<GenNode> getAssignableGenNodes(Collection<GenClass> genClasses) {
d131 1
a131 1
		for (Iterator genNodes = myDiagram.getAllNodes().iterator(); genNodes.hasNext();) {
d133 3
a135 5
			for (GenClass genClass : genClasses) {
				if (genClass.getEcoreClass().isSuperTypeOf(nextNode.getDomainMetaClass().getEcoreClass())) {
					result.add(nextNode);
					break;
				}
@


1.5
log
@[161376] - It should be possible to transform gmfmap to gmfgen model for design projects
@
text
@d60 1
a60 1
		createChildReference(diagram, null, GenNavigatorReferenceType.DEFAULT_LITERAL);
d79 1
a79 1
		GenNavigatorChildReference childReference = createChildReference(link, myDiagram, GenNavigatorReferenceType.DEFAULT_LITERAL);
@


1.4
log
@Using LinkedHashSet instead of HashSet.
@
text
@d116 3
d123 3
@


1.3
log
@NAvigator Labels are generated based on genmodel information.
@
text
@a14 1
import java.util.HashSet;
d16 1
d124 1
a124 1
		Collection<GenNode> result = new HashSet<GenNode>();
@


1.2
log
@Icons provided to Navigator
@
text
@a24 1
import org.eclipse.gmf.codegen.gmfgen.GenLabel;
a25 1
import org.eclipse.gmf.codegen.gmfgen.GenLinkLabel;
d79 1
a79 1
		GenNavigatorChildReference childReference = createChildLinkReference(link, myDiagram, GenNavigatorReferenceType.DEFAULT_LITERAL);
d87 1
a87 1
				GenNavigatorChildReference reference = createChildNodeReference(node, link, GenNavigatorReferenceType.OUT_TAGET_LITERAL);
d93 1
a93 1
				GenNavigatorChildReference reference = createChildLinkReference(link, node, GenNavigatorReferenceType.IN_SOURCE_LITERAL);
d102 1
a102 1
				GenNavigatorChildReference reference = createChildNodeReference(node, link, GenNavigatorReferenceType.IN_SOURCE_LITERAL);
d108 1
a108 1
				GenNavigatorChildReference reference = createChildLinkReference(link, node, GenNavigatorReferenceType.OUT_TAGET_LITERAL);
d138 1
a138 17
		createChildNodeReference(childNode, parent, GenNavigatorReferenceType.CHILDREN_LITERAL);
	}
	
	private GenNavigatorChildReference createChildNodeReference(GenNode childNode, GenCommonBase parent, GenNavigatorReferenceType referenceType) {
		GenNavigatorChildReference childReference = createChildReference(childNode, parent, referenceType);
		if (childNode.getLabels().size() > 0) {
			childReference.setLabel((GenLabel) childNode.getLabels().get(0));
		}
		return childReference;
	}
	
	private GenNavigatorChildReference createChildLinkReference(GenLink link, GenCommonBase parent, GenNavigatorReferenceType referenceType) {
		GenNavigatorChildReference childReference = createChildReference(link, parent, referenceType);
		if (link.getLabels().size() > 0) {
			childReference.setLabel((GenLinkLabel) link.getLabels().get(0));
		}
		return childReference;
@


1.1
log
@Model navigator, initial version.
@
text
@d83 1
a83 1
		childReference.setGroupIcon("/links.icon");
d91 1
a91 1
				reference.setGroupIcon("/linkTarget.icon");
d97 1
a97 1
				reference.setGroupIcon("/incomingLinks.icon");
d106 1
a106 1
				reference.setGroupIcon("/linkSource.icon");
d112 1
a112 1
				reference.setGroupIcon("/outgoingLinks.icon");
@

