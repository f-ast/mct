head	1.11;
access;
symbols
	v20081015-1925:1.11
	v20080917-1925:1.11
	v20080903-1520:1.11
	v20080827-1520:1.11
	v20080813-1520:1.11
	R1_0_maintenance:1.11.0.2
	R1_0:1.11
	v20060620-0400:1.10
	v20060616-1200:1.10
	v20060609-1400:1.10
	v20060531-1730:1.10
	v20060530-1930:1.10
	v20060526-1200:1.10
	v20060519-0800:1.10
	v20060512-1000:1.10
	I20060512-1000:1.10
	I20060505-1400:1.10
	I20060428-1300:1.10
	I20060424-0500:1.10
	I20060424-0300:1.10
	M6_10:1.10
	I20060407-1200:1.10
	I20060331-1000:1.10
	I20060324-0300:1.10
	I20060317-1300:1.10
	I20060317-1200:1.10
	I20060316-1300:1.10
	I20060309-1300:1.10
	M5_10:1.10
	S20060303-1600:1.10
	I20060227-1730:1.10
	I20060216-1945:1.8
	I20060210-1715:1.7
	I20060209-1815:1.7
	I20060203-0830:1.7
	I20060129-1145:1.7
	I20060127-0900:1.7
	I20060120-1530:1.7
	I20060113-1700:1.7
	M4_10:1.7
	I20060107-1100:1.7
	I20060105-1630:1.7
	I20051230-1230:1.7
	I20051223-1100:1.7
	I20051217-0925:1.7
	I20051208-2000:1.7
	I20051201-1800:1.7
	M3_10:1.7
	I20051118-1245:1.7
	I20051111-1800:1.7
	I20051106-0900:1.7
	v20051030:1.7
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2006.06.26.14.05.05;	author atikhomirov;	state dead;
branches;
next	1.10;

1.10
date	2006.02.23.15.45.36;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.22.22.01.15;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.14.10.11.26;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.26.13.48.47;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.19.17.27.34;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.07.11.04.20;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.06.18.58.23;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.06.15.51.03;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.04.18.28.27;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.19.10;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.11
log
@no api packages, classes are for internal use only
@
text
@/*
 * Copyright (c) 2005 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.bridge.genmodel;

import java.util.Iterator;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage;
import org.eclipse.gmf.mappings.CanvasMapping;
import org.eclipse.gmf.mappings.LabelMapping;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.runtime.notation.NotationPackage;

/**
 * Makes use of basic/standard classes for runtime presentation of diagram 
 * @@author artem
 */
public class BasicDiagramRunTimeModelHelper implements DiagramRunTimeModelHelper {
	private GenClass myNode;
	private GenClass myLink;
	private GenClass myCanvas;
	private boolean myIsLoaded = false;

	public BasicDiagramRunTimeModelHelper() {
	}

	public GenClass get(NodeMapping nodeMapping) {
		loadGenModel();
		return myNode;
	}

	public GenClass get(LinkMapping linkMapping) {
		loadGenModel();
		return myLink;
	}

	public GenClass get(CanvasMapping canvasMapping) {
		loadGenModel();
		return myCanvas;
	}

	public GenClass getChildContainerDefault() {
		loadGenModel();
		return myNode;
	}

	public GenClass get(LabelMapping labelMapping) {
		loadGenModel();
		return myNode;
	}

	private void loadGenModel() {
		if (myIsLoaded ) {
			return;
		}
		myIsLoaded = true;
		RuntimeGenModelAccess runtimeAccess = new RuntimeGenModelAccess();
		runtimeAccess.ensure(); 
		GenPackage gp = runtimeAccess.genPackage();
		for (Iterator it = gp.getGenClasses().iterator(); it.hasNext();) {
			GenClass next = (GenClass) it.next();
			if (NotationPackage.eINSTANCE.getNode().getName().equals(next.getName())) {
				myNode = next;
			} else if (NotationPackage.eINSTANCE.getEdge().getName().equals(next.getName())) {
				myLink = next;
			} else if (NotationPackage.eINSTANCE.getDiagram().getName().equals(next.getName())) {
				myCanvas = next;
			}
		}
		// my... become proxies on unload
		//runtimeAccess.unload();
		assert myNode != null && myLink != null && myCanvas != null;
	}
}
@


1.10
log
@#127464 unlimited hierarchies in the GMFMap with possible reuse of mapping entries
@
text
@@


1.9
log
@#129047 get rid of explicit edit/label features, use generic and feature-rich LabelMapping instead.
@
text
@a18 1
import org.eclipse.gmf.mappings.ChildNodeMapping;
a31 1
	private GenClass myChildNode;
a51 5
	public GenClass get(ChildNodeMapping childNodeMapping) {
		loadGenModel();
		return myChildNode;
	}

a73 1
				myChildNode = next;
d82 1
a82 1
		assert myNode != null && myLink != null && myCanvas != null && myChildNode != null;
@


1.8
log
@#127461 add label diagram element in gmfgraph model
@
text
@d20 1
a20 1
import org.eclipse.gmf.mappings.LinkLabelMapping;
a21 1
import org.eclipse.gmf.mappings.NodeLabelMapping;
d64 1
a64 16
	public GenClass getNodeLabelDefault() {
		loadGenModel();
		return myNode;
	}

	public GenClass getLinkLabelDefault() {
		loadGenModel();
		return myNode;
	}

	public GenClass get(LinkLabelMapping mapping) {
		loadGenModel();
		return myNode;
	}

	public GenClass get(NodeLabelMapping mapping) {
@


1.7
log
@[dstadnik] #113803 rt classes for child containers and labels
@
text
@d20 1
d22 1
d75 10
@


1.6
log
@refrain from unloading genmodel for rt to avoid proxy resolution
@
text
@d58 15
@


1.5
log
@#111884 NPE without vmargs=-ea on map->genmodel transform
@
text
@d77 2
a78 1
		runtimeAccess.unload();
@


1.4
log
@refactor GenModel access with dedicated hack to get Notation/Runtime GenModel
@
text
@d64 1
a64 1
		assert runtimeAccess.ensure().isOK();
@


1.3
log
@correct URI for runtime/notation model
@
text
@a16 1
import org.eclipse.emf.codegen.ecore.genmodel.GenModel;
a17 4
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.plugin.EcorePlugin;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
d63 3
a65 4
		URI diagramRTGenModelURI = (URI) EcorePlugin.getEPackageNsURIToGenModelLocationMap().get(NotationPackage.eNS_URI);
		Resource r = new ResourceSetImpl().getResource(diagramRTGenModelURI, true);
		GenModel drtModel = (GenModel) r.getContents().get(0);
		GenPackage gp = drtModel.findGenPackage(NotationPackage.eINSTANCE);
d77 1
a77 1
		r.unload();
@


1.2
log
@get rid of old diagramrt, use o.e.gmf.diagram.notation instead
@
text
@a33 1
	private static final String DIAGRAM_RT_URI = "http://www.eclipse.org/gmf/2005/diagramrt";
d68 1
a68 1
		URI diagramRTGenModelURI = (URI) EcorePlugin.getEPackageNsURIToGenModelLocationMap().get(DIAGRAM_RT_URI);
@


1.1
log
@*** empty log message ***
@
text
@a22 1
import org.eclipse.gmf.diagramrt.DiagramRTPackage;
d27 1
d72 1
a72 1
		GenPackage gp = drtModel.findGenPackage(DiagramRTPackage.eINSTANCE);
d75 1
a75 1
			if (DiagramRTPackage.eINSTANCE.getDiagramNode().getName().equals(next.getName())) {
d77 2
a78 1
			} else if (DiagramRTPackage.eINSTANCE.getDiagramLink().getName().equals(next.getName())) {
d80 1
a80 1
			} else if (DiagramRTPackage.eINSTANCE.getDiagramCanvas().getName().equals(next.getName())) {
a81 2
			} else if (DiagramRTPackage.eINSTANCE.getChildNode().getName().equals(next.getName())) {
				myChildNode = next;
d85 1
a85 1
		assert myNode != null && myLink != null && myCanvas != null;
@

