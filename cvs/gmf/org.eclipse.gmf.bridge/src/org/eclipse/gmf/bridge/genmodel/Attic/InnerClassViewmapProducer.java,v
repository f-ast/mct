head	1.22;
access;
symbols
	v20081015-1925:1.22
	v20080917-1925:1.22
	v20080903-1520:1.22
	v20080827-1520:1.22
	v20080813-1520:1.22
	R1_0_maintenance:1.22.0.2
	R1_0:1.22
	v20060620-0400:1.21
	v20060616-1200:1.20
	v20060609-1400:1.20
	v20060531-1730:1.20
	v20060530-1930:1.20
	v20060526-1200:1.19
	v20060519-0800:1.15
	v20060512-1000:1.13
	I20060512-1000:1.13
	I20060505-1400:1.13
	I20060428-1300:1.12
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.11
	I20060407-1200:1.9
	I20060331-1000:1.9
	I20060324-0300:1.9
	I20060317-1300:1.9
	I20060317-1200:1.9
	I20060316-1300:1.9
	I20060309-1300:1.8
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.7
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.22
date	2006.06.26.14.05.05;	author atikhomirov;	state dead;
branches;
next	1.21;

1.21
date	2006.06.19.12.41.57;	author ashatalin;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.30.13.15.00;	author atikhomirov;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.25.14.06.30;	author atikhomirov;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.24.18.05.26;	author atikhomirov;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.24.16.06.50;	author atikhomirov;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.23.21.09.42;	author atikhomirov;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.18.19.12.35;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.17.12.39.18;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.01.17.26.40;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.20.16.27.14;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.13.21.57.32;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.10.12.14.08;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.13.17.53.15;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.01.20.22.38;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.22.22.01.15;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.06.22.21.39;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.23.19.58.41;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.10.15.28.43;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.06.20.23.06;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.06.20.22.27;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.06.19.22.31;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.22
log
@no api packages, classes are for internal use only
@
text
@/*
 * Copyright (c) 2005 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.bridge.genmodel;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Set;

import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.gmf.codegen.gmfgen.FigureViewmap;
import org.eclipse.gmf.codegen.gmfgen.GMFGenFactory;
import org.eclipse.gmf.codegen.gmfgen.InnerClassViewmap;
import org.eclipse.gmf.codegen.gmfgen.ParentAssignedViewmap;
import org.eclipse.gmf.codegen.gmfgen.Viewmap;
import org.eclipse.gmf.common.codegen.ImportAssistant;
import org.eclipse.gmf.gmfgraph.Compartment;
import org.eclipse.gmf.gmfgraph.Connection;
import org.eclipse.gmf.gmfgraph.CustomFigure;
import org.eclipse.gmf.gmfgraph.DiagramLabel;
import org.eclipse.gmf.gmfgraph.Figure;
import org.eclipse.gmf.gmfgraph.FigureAccessor;
import org.eclipse.gmf.gmfgraph.FigureGallery;
import org.eclipse.gmf.gmfgraph.FigureHandle;
import org.eclipse.gmf.gmfgraph.GMFGraphPackage;
import org.eclipse.gmf.gmfgraph.Node;
import org.eclipse.gmf.gmfgraph.util.FigureQualifiedNameSwitch;
import org.eclipse.gmf.gmfgraph.util.RuntimeFQNSwitch;
import org.eclipse.gmf.graphdef.codegen.FigureGenerator;
import org.eclipse.gmf.graphdef.codegen.MapModeCodeGenStrategy;
import org.eclipse.gmf.graphdef.codegen.NamingStrategy;
import org.eclipse.gmf.internal.common.codegen.NullImportAssistant;

/**
 * Stateful. Don't reuse.
 * @@author artem
 */
public class InnerClassViewmapProducer extends DefaultViewmapProducer {

	private final FigureGenerator figureGenerator;
	private final FigureQualifiedNameSwitch fqnSwitch;
	private final Set/*<Figure>*/ processedFigures;

	public InnerClassViewmapProducer() {
		this(new RuntimeFQNSwitch(), new MapModeCodeGenStrategy.RuntimeUnspecifiedMapMode());
	}

	public InnerClassViewmapProducer(FigureQualifiedNameSwitch figureNameSwitch, MapModeCodeGenStrategy mapModeCodeGenStrategy) {
		assert figureNameSwitch != null;
		fqnSwitch = figureNameSwitch;
		processedFigures = new HashSet();
		figureGenerator = new FigureGenerator(fqnSwitch, mapModeCodeGenStrategy);
	}

	public Viewmap create(Node node) {
		if (node.getFigure() == null) {
			return super.create(node);
		}
		final Viewmap viewmap = createViewmap(node.getNodeFigure());
		setupResizeConstraints(viewmap, node);
		setupLayoutType(viewmap, node);
		return viewmap;
	}
	
	public Viewmap create(Connection link) {
		if (link.getFigure() == null) {
			return super.create(link);
		}
		return createViewmap(link.getConnectionFigure());
	}

	public Viewmap create(DiagramLabel label) {
		if (label.getFigure() == null) {
			return super.create(label);
		}
		return createViewmap(label.getFigure());
	}
	
	public Viewmap create(Compartment compartment) {
		FigureHandle handle = compartment.getFigure();
		if (handle == null){
			return super.create(compartment);
		}
		return createViewmap(compartment.getFigure());
	}
	
	private Viewmap createFigureViewmap(Figure figure) {
		Viewmap result;
		if (EcoreUtil.isAncestor(processedFigures, figure.getParent())) {
			// we generated code for parent, thus (if figure generation logic not changed)
			// all inner figures were generated as well (with accessors), thus, everything
			// we need here is just reference one
			ParentAssignedViewmap v = GMFGenFactory.eINSTANCE.createParentAssignedViewmap();
			// XXX yet another assumption - getter name
			// FIXME introduce feedback to FigureGenerator to let us know exact names
			v.setGetterName(NamingStrategy.INSTANCE.getChildFigureGetterName(figure));
			v.setFigureQualifiedClassName(fqnSwitch.get(figure));
			result = v;
		} else {
			if (isBareInstance(figure)) {
				FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
				v.setFigureQualifiedClassName(fqnSwitch.get(figure));
				result = v;
				// XXX perhaps, create SnippetViewmap when there are no children but some props
			} else {
				InnerClassViewmap v = GMFGenFactory.eINSTANCE.createInnerClassViewmap();
				ImportAssistant importManager = new NullImportAssistant(null, CodeGenUtil.validJavaIdentifier(figure.getName())); 
				v.setClassBody(figureGenerator.go(figure, importManager));
				v.setClassName(importManager.getCompilationUnitName());
				result = v;
			}
		}
		if (false == result instanceof ParentAssignedViewmap) {
			setupPluginDependencies(result, figure);
		} // otherwise, dependencies are already there
		processedFigures.add(figure);
		return result;
	}

	private Viewmap createViewmap(FigureHandle figure) {
		Viewmap result;
		if (figure instanceof Figure) {
			result = createFigureViewmap((Figure) figure);
		} else if (figure instanceof FigureAccessor) {
			result = createFigureAccessorViewmap((FigureAccessor) figure);
		} else {
			throw new IllegalStateException();
		}
		setupStyleAttributes(result, figure);
		return result;
	}

	private Viewmap createFigureAccessorViewmap(FigureAccessor figureAccess) {
		ParentAssignedViewmap v = GMFGenFactory.eINSTANCE.createParentAssignedViewmap();
		v.setGetterName(figureAccess.getAccessor());
		if (figureAccess.getTypedFigure() != null) {
			v.setFigureQualifiedClassName(figureAccess.getTypedFigure().getQualifiedClassName());
		}
		return v;
	}
	
	private void setupPluginDependencies(Viewmap viewmap, Figure figure){
		FigureGallery gallery = findAncestorFigureGallery(figure);
		if (gallery != null){
			viewmap.getRequiredPluginIDs().addAll(Arrays.asList(fqnSwitch.getDependencies(gallery)));
		}
	}
	
	public static FigureGallery findAncestorFigureGallery(Figure figure){
		EObject current = figure;
		while (true){
			EObject next = current.eContainer();
			if (next instanceof Figure){
				current = next;
			} else if (next instanceof FigureGallery){
				return (FigureGallery)next;
			} else {
				return null;
			}
		}
	}

	private static boolean isBareInstance(Figure figure){
		if (!figure.getChildren().isEmpty()) {
			return false;
		}
		final Collection featuresToCheck = new LinkedList(figure.eClass().getEAllStructuralFeatures());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getIdentity_Name());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getFigure_Children());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getFigureMarker_Parent());
		featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getFigureHandle_ReferencingElements());
		if (figure instanceof CustomFigure) {
			featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getCustomClass_BundleName());
			featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getCustomClass_QualifiedClassName());
			featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getCustomFigure_CustomChildren());
		}
		for(Iterator it = featuresToCheck.iterator(); it.hasNext();) {
			final EStructuralFeature next = (EStructuralFeature) it.next();
			if (next.isDerived()) {
				continue;
			}
			if (figure.eIsSet(next)) {
				return false;
			}
		}
		return true;
	}
}
@


1.21
log
@[mgolubev] #145863 Colors defined in the gmfgraph model should be used by the generated polyline connections
@
text
@@


1.20
log
@custom attributes do make figures different, correct feature to exclude was one holding FigureAccessors
@
text
@d101 1
a101 1
	private Viewmap createViewmap(Figure figure) {
d135 1
d137 1
a137 1
			return createViewmap((Figure) figure);
d139 3
a141 1
			return createViewmap((FigureAccessor) figure);
d143 2
a144 1
		throw new IllegalStateException();
d147 1
a147 1
	private Viewmap createViewmap(FigureAccessor figureAccess) {
@


1.19
log
@[mgolubev] #139148 Respect gmfgraph.compartment figure
[mgolubev] #143619 Temp fix for misassumption of ParentAssignedViewmap regarding generated getter name
@
text
@d185 1
a185 1
			featuresToCheck.remove(GMFGraphPackage.eINSTANCE.getCustomClass_Attributes());
@


1.18
log
@Do not generate unnecessary code, e.g. label figure, when parent gonna assign one.
Explicitly handle (and distinguish) figures assigned by parent (thus placed in predefined location inside parent) and those added as ordinary child figures
InnerClassViewmapProducer updated to guess uses of parent's sub-figure inside children. It's not really a InnerClassViewmapProducer and should be renamed to smth like GeneratingViewmapProducer
Tests updated to cover logic added to the producer
@
text
@d45 1
d94 3
a96 3
		Viewmap result = super.create(compartment);
		if (compartment.getFigure() instanceof Figure){
			setupPluginDependencies(result, (Figure) compartment.getFigure());
d98 1
a98 1
		return result;
d100 1
a100 1

d110 1
a110 1
			v.setGetterName("get" + CodeGenUtil.validJavaIdentifier(figure.getName()));
d138 1
a138 7
			final FigureAccessor figureAccess = (FigureAccessor) figure;
			ParentAssignedViewmap v = GMFGenFactory.eINSTANCE.createParentAssignedViewmap();
			v.setGetterName(figureAccess.getAccessor());
			if (figureAccess.getTypedFigure() != null) {
				v.setFigureQualifiedClassName(figureAccess.getTypedFigure().getQualifiedClassName());
			}
			return v;
d142 9
@


1.17
log
@testInnerViewmapProducerBareFigure turned on back (as I can't recall the original reason to turn it off, and the commit comment re PolylineConnectionEx hack doesn't help)
Besides, producer creates ParentAssignedViewmaps now
@
text
@d16 1
d19 1
d24 1
d48 1
d55 1
d64 1
d102 8
a109 2
		if (isBareInstance(figure)) {
			FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
a111 1
			// XXX perhaps, create SnippetViewmap when there are no children but some props
d113 12
a124 5
			InnerClassViewmap v = GMFGenFactory.eINSTANCE.createInnerClassViewmap();
			ImportAssistant importManager = new NullImportAssistant(null, CodeGenUtil.validJavaIdentifier(figure.getName())); 
			v.setClassBody(figureGenerator.go(figure, importManager));
			v.setClassName(importManager.getCompilationUnitName());
			result = v;
d126 4
a129 1
		setupPluginDependencies(result, figure);
@


1.16
log
@#140887 Remove Child interface from GMFGraph.
Although the need to reference child figures persist, thus FigureHandle was introduced, to allow diagramElements to reference either *generateable* figures (Figure subclasses) or *just-use* figures (like CustomFigure and FigureAccessor).
Refactoring performed with #131365 "Mirror GMFGraph model when generating standalone figure plugin" in mind
@
text
@d25 1
a25 1
import org.eclipse.gmf.codegen.gmfgen.SnippetViewmap;
d96 1
a96 1
		if ((figure instanceof CustomFigure) && isBareInstance(figure)) {
d117 6
a122 6
			// ParentAccessorViewmap
			SnippetViewmap v = GMFGenFactory.eINSTANCE.createSnippetViewmap();
			v.setBody(figureAccess.getAccessor());
			// if (figureAccess.getTypedFigure() != null) {
			//v.setClassName(figureAccess.getTypedFigure().getQualifiedClassName());
			//}
d154 3
d160 1
d163 5
a167 1
			if (figure.eIsSet((EStructuralFeature) it.next())) {
@


1.15
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@a18 2
import org.eclipse.core.runtime.Platform;
import org.eclipse.emf.codegen.jet.JETException;
d25 1
a27 1
import org.eclipse.gmf.gmfgraph.Child;
d33 1
d35 1
d66 4
a69 9
		try {
			final Viewmap viewmap = createViewmap(node.getFigure());
			setupResizeConstraints(viewmap, node);
			setupLayoutType(viewmap, node);
			return viewmap;
		} catch (JETException ex) {
			log(ex);
			return super.create(node);
		}
a71 12
	public Viewmap create(Child child) {
		if (child.getFigure() == null) {
			return super.create(child);
		}
		try {
			return createViewmap(child.getFigure());
		} catch (JETException ex) {
			log(ex);
			return super.create(child);
		}
	}

d76 1
a76 6
		try {
			return createViewmap(link.getFigure());
		} catch (JETException ex) {
			log(ex);
			return super.create(link);
		}
d83 1
a83 6
		try {
			return createViewmap(label.getFigure());
		} catch (JETException ex) {
			log(ex);
			return super.create(label);
		}
d88 2
a89 2
		if (compartment.getFigure() != null){
			setupPluginDependencies(result, compartment.getFigure());
d94 1
a94 1
	private Viewmap createViewmap(Figure figure) throws JETException {
d111 15
a164 4

	private static void log(JETException ex) {
		Platform.getLog(Platform.getBundle("org.eclipse.gmf.bridge")).log(ex.getStatus());
	}
@


1.14
log
@[mgolubev] #140186 XYLayoutEditPolicy should not be installed for editparts that have figure with non-XYLayout in the gmfgraph model
@
text
@d21 1
d28 1
a28 1
import org.eclipse.gmf.common.codegen.NullImportAssistant;
d42 1
d59 1
a59 1
		figureGenerator = new FigureGenerator(null, new NullImportAssistant(), fqnSwitch, mapModeCodeGenStrategy);
d130 3
a132 2
			v.setClassBody(figureGenerator.go(figure));
			v.setClassName(figure.getName()); // XXX parse instead?
@


1.13
log
@[bblajer] ##139022 Provide option to choose mapMode for figures
@
text
@d67 1
@


1.12
log
@[mgolubev] #129362 Respect plug-in dependencies imposed on figure code - fix missing support for inner-class case
@
text
@d40 1
d51 1
a51 1
		this(new RuntimeFQNSwitch());
d54 1
a54 1
	public InnerClassViewmapProducer(FigureQualifiedNameSwitch figureNameSwitch) {
d57 1
a57 1
		figureGenerator = new FigureGenerator(null, new NullImportAssistant(), fqnSwitch);
@


1.11
log
@refactor to facilitate reuse in codegen.lite
@
text
@d14 1
d21 1
d29 1
d34 1
d108 8
d118 1
d122 1
a122 1
			return v;
d128 24
a151 1
			return v;
@


1.10
log
@[mgolubev] #135017 Respect resize constraints defined in .gmfgraph
@
text
@d43 1
a43 1
	private final FigureQualifiedNameSwitch fqnSwitch = new RuntimeFQNSwitch();
d46 6
@


1.9
log
@explicit method names for fqn switch to better reflect it's intention
@
text
@d54 3
a56 1
			return createViewmap(node.getFigure());
@


1.8
log
@Split FQNSwitch into interface and rt-specific implementation
New requirement on the switch - to provide additional requiremens
@
text
@d100 1
a100 1
			v.setFigureQualifiedClassName(String.valueOf(fqnSwitch.doSwitch(figure)));
@


1.7
log
@#129047 get rid of explicit edit/label features, use generic and feature-rich LabelMapping instead.
@
text
@d34 1
d43 1
a43 1
	private final FigureQualifiedNameSwitch fqnSwitch = new FigureQualifiedNameSwitch();
@


1.6
log
@refactor - moved EmitterFactory/Dispatcher infrastructure to gmf.common to enable its use in oeg.codegen
@
text
@d18 1
d29 1
d55 1
a55 1
			ex.printStackTrace();
d67 1
a67 1
			ex.printStackTrace();
d79 1
a79 1
			ex.printStackTrace();
d84 12
d127 4
@


1.5
log
@Generating figures for Child
@
text
@d24 1
d43 1
a43 1
		figureGenerator = new FigureGenerator(null);
@


1.4
log
@hack to deal with PolylineConnectionEx
@
text
@d24 1
d56 12
@


1.3
log
@bit more sophisticated handling of bare fqn figure specifications
@
text
@d69 1
a69 1
		if (isBareInstance(figure)) {
@


1.2
log
@bit more sophisticated handling of bare fqn figure specifications
@
text
@d86 1
a86 1
		Collection featuresToCheck = new LinkedList(figure.eClass().getEAllStructuralFeatures());
d92 1
a92 1
		for(Iterator it = figure.eClass().getEAllStructuralFeatures().iterator(); it.hasNext();) {
@


1.1
log
@New plugin with IFigure codegeneration to support #114177 (graphical definition model) was added
@
text
@d14 4
d19 2
d25 1
d27 1
d29 1
a33 1
 *
d38 1
d49 1
a49 1
			return createInnerClassViewmap(node.getFigure());
d61 1
a61 1
			return createInnerClassViewmap(link.getFigure());
d68 30
a97 5
	private InnerClassViewmap createInnerClassViewmap(Figure figure) throws JETException {
		InnerClassViewmap v = GMFGenFactory.eINSTANCE.createInnerClassViewmap();
		v.setClassBody(figureGenerator.go(figure));
		v.setClassName(figure.getName()); // XXX parse instead?
		return v;
@

