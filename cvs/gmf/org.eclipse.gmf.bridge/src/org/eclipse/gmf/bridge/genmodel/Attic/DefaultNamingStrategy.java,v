head	1.12;
access;
symbols
	v20081015-1925:1.12
	v20080917-1925:1.12
	v20080903-1520:1.12
	v20080827-1520:1.12
	v20080813-1520:1.12
	R1_0_maintenance:1.12.0.2
	R1_0:1.12
	I20060113-1700:1.11
	M4_10:1.11
	I20060107-1100:1.8
	I20060105-1630:1.8
	I20051230-1230:1.8
	I20051223-1100:1.8
	I20051217-0925:1.8
	I20051208-2000:1.7
	I20051201-1800:1.6
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.3
	v20050828:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.12
date	2006.01.18.19.28.16;	author atikhomirov;	state dead;
branches;
next	1.11;

1.11
date	2006.01.10.20.40.15;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.10.19.01.16;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.10.18.45.26;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.13.17.11.20;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.06.22.21.18;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.30.13.49.18;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.28.16.09.36;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.02.17.53.07;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.25.10.42.14;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.19.16.39.43;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.19.10;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.12
log
@refactor NamingStrategy: extracted all className setters to provisional NamingMediator
@
text
@/*
 * Copyright (c) 2005 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.bridge.genmodel;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.gmf.gmfgraph.Compartment;
import org.eclipse.gmf.mappings.AbstractNodeMapping;
import org.eclipse.gmf.mappings.CanvasMapping;
import org.eclipse.gmf.mappings.ChildNodeMapping;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.tooldef.AbstractTool;
import org.eclipse.gmf.tooldef.CreationTool;
import org.eclipse.gmf.tooldef.ToolContainer;

/**
 * In most cases it should be sufficient to override <code>getXXXSuffix()</code>
 * methods to get nice and valid class names.
 * Implementation keeps track of produced names and tries to create unique name 
 * appending numerical suffix to it. Use {@@link #clearNamesCache()} to clean 
 * names cache in case you reuse the instance.
 * 
 * @@author artem
 */
public class DefaultNamingStrategy extends NamingStrategy {

	protected Set/* <String> */myNamesCache;
	
	private Set/* <String> */myPaletteFactoryMethodNamesCache;

	public DefaultNamingStrategy() {
		myNamesCache = new HashSet();
		myPaletteFactoryMethodNamesCache = new HashSet();
	}

	public DefaultNamingStrategy(Set namesCache) {
		myNamesCache = namesCache;
		if (myNamesCache == null) {
			myNamesCache = new HashSet();
		}
	}

	public void reset() {
		myNamesCache.clear();
	}

	public String createCanvasClassName(CanvasMapping mapping, String suffix) {
		if (mapping.getDomainMetaElement() == null) {
			return null;
		}
		return createClassName(mapping.getDomainMetaElement().getName(), getCanvasSuffix(suffix));
	}

	public String createNodeClassName(NodeMapping mapping, String suffix) {
		if (mapping.getDomainContext() == null) {
			return null;
		}
		return createClassName(mapping.getDomainContext().getName(), getNodeSuffix(suffix));
	}

	public String createChildNodeClassName(ChildNodeMapping mapping, String suffix) {
		if (mapping.getDomainContext() == null) {
			return null;
		}
		return createClassName(mapping.getDomainContext().getName(), getChildNodeSuffix(suffix));
	}

	public String createCompartmentClassName(AbstractNodeMapping mapping, Compartment compartment, String suffix) {
		if (mapping.getDomainContext() == null) {
			return null;
		}
		return createClassName(mapping.getDomainContext().getName() + '_' + compartment.getName(), getCompartmentSuffix(suffix));
	}

	public String createNodeLabelClassName(AbstractNodeMapping mapping, EStructuralFeature labelFeature, String suffix) {
		if (mapping.getDomainContext() == null) {
			return null;
		}
		return createClassName(mapping.getDomainContext().getName() + '_' + labelFeature.getName(), getCompartmentSuffix(suffix));
	}

	public String createLinkClassName(LinkMapping mapping, String suffix) {
		if (mapping.getDomainMetaElement() != null) {
			return createClassName(mapping.getDomainMetaElement().getName(), getLinkSuffix(suffix));
		} else if (mapping.getLinkMetaFeature() != null) {
			return createClassName(mapping.getLinkMetaFeature().getName(), getLinkSuffix(suffix));
		}
		return null;
	}

	public String createLinkLabelClassName(LinkMapping mapping, EStructuralFeature labelFeature, String suffix) {
		if (mapping.getDomainMetaElement() != null) {
			return createClassName(mapping.getDomainMetaElement().getName() + '_' + labelFeature.getName(), getLinkSuffix(suffix));
		} else if (mapping.getLinkMetaFeature() != null) {
			return createClassName(mapping.getLinkMetaFeature().getName() + '_' + labelFeature.getName(), getLinkSuffix(suffix));
		}
		return null;
	}

	public String createCreationMethodName(AbstractTool tool) {
		if (tool instanceof CreationTool) {
			return getUniquePaletteFactoryMethodName("create" + tool.getTitle() + "CreationTool");
		} else if (tool instanceof ToolContainer) {
			return getUniquePaletteFactoryMethodName("create" + tool.getTitle() + "Group");
		}
		return getUniquePaletteFactoryMethodName("create" + tool.getTitle() + "Unknown");
	}

	/**
	 * Returns specific class suffix instead of the specified default suffix.
	 * Returned value should be valid java class name suffix.
	 */
	protected String getCanvasSuffix(String suffix) {
		return suffix;
	}

	/**
	 * Returns specific class suffix instead of the specified default suffix.
	 * Returned value should be valid java class name suffix.
	 */
	protected String getNodeSuffix(String suffix) {
		return suffix;
	}

	/**
	 * Returns specific class suffix instead of the specified default suffix.
	 * Returned value should be valid java class name suffix.
	 */
	protected String getChildNodeSuffix(String suffix) {
		return suffix;
	}

	/**
	 * Returns specific class suffix instead of the specified default suffix.
	 * Returned value should be valid java class name suffix.
	 */
	protected String getCompartmentSuffix(String suffix) {
		return suffix;
	}

	/**
	 * Returns specific class suffix instead of the specified default suffix.
	 * Returned value should be valid java class name suffix.
	 */
	protected String getLinkSuffix(String suffix) {
		return suffix;
	}

	protected String createClassName(String name, String suffix) {
		name = CodeGenUtil.validJavaIdentifier(name);
		if (name.length() > 0) {
			name = Character.toUpperCase(name.charAt(0)) + name.substring(1);
		}
		String fullName = ensureUnique(name, suffix);
		myNamesCache.add(fullName);
		return fullName;
	}

	protected String ensureUnique(String name, String suffix) {
		int i = 2;
		String uniqueName = name;
		while (myNamesCache.contains(uniqueName + suffix)) {
			uniqueName = name + i++;
		}
		return uniqueName + suffix;
	}
	
	private String getUniquePaletteFactoryMethodName(String name) {
		name = CodeGenUtil.validJavaIdentifier(name);
		int i = 2;
		String uniqueName = name;
		while (myPaletteFactoryMethodNamesCache.contains(uniqueName)) {
			uniqueName = name + i++;
		}
		myPaletteFactoryMethodNamesCache.add(uniqueName);
		return uniqueName;
	}
}
@


1.11
log
@#114197 - tooling definition in place
@
text
@@


1.10
log
@Method renamed. Clearly (hah :) express intention of the method - it's merely describes surroundings/location of the element in the domain, rather then represent a metaClass
@
text
@d25 3
a27 1
import org.eclipse.gmf.mappings.ToolGroup;
d113 7
a119 10
	public String createToolCreationMethodName(AbstractNodeMapping nodeMapping) {
		return getUniquePaletteFactoryMethodName("create" + nodeMapping.getDomainContext().getName() + "NodeCreationTool");
	}

	public String createToolCreationMethodName(LinkMapping linkMapping) {
		return getUniquePaletteFactoryMethodName("create" + (linkMapping.getDomainMetaElement() != null ? linkMapping.getDomainMetaElement().getName() : linkMapping.getLinkMetaFeature().getName()) + "LinkCreationTool");
	}
	
	public String createToolGroupCreationMethodName(ToolGroup toolGroup) {
		return getUniquePaletteFactoryMethodName("create" + (toolGroup.getName() != null ? toolGroup.getName() : "") + "Group");
@


1.9
log
@actually, there's no need for getDomainMetaClass in the Link, and its former uses in namingStrategy/DGMT prove that.
@
text
@d66 1
a66 1
		if (mapping.getDomainMetaClass() == null) {
d69 1
a69 1
		return createClassName(mapping.getDomainMetaClass().getName(), getNodeSuffix(suffix));
d73 1
a73 1
		if (mapping.getDomainMetaClass() == null) {
d76 1
a76 1
		return createClassName(mapping.getDomainMetaClass().getName(), getChildNodeSuffix(suffix));
d80 1
a80 1
		if (mapping.getDomainMetaClass() == null) {
d83 1
a83 1
		return createClassName(mapping.getDomainMetaClass().getName() + '_' + compartment.getName(), getCompartmentSuffix(suffix));
d87 1
a87 1
		if (mapping.getDomainMetaClass() == null) {
d90 1
a90 1
		return createClassName(mapping.getDomainMetaClass().getName() + '_' + labelFeature.getName(), getCompartmentSuffix(suffix));
d112 1
a112 1
		return getUniquePaletteFactoryMethodName("create" + nodeMapping.getDomainMetaClass().getName() + "NodeCreationTool");
@


1.8
log
@#120553
- Adding accessors for the palette entries factory methods into genmodel
- Refreshing unit-tests
- Fixing some old problems found by this refreshment.
@
text
@d94 2
a95 2
		if (mapping.getDomainMetaClass() != null) {
			return createClassName(mapping.getDomainMetaClass().getName(), getLinkSuffix(suffix));
d103 2
a104 2
		if (mapping.getDomainMetaClass() != null) {
			return createClassName(mapping.getDomainMetaClass().getName() + '_' + labelFeature.getName(), getLinkSuffix(suffix));
d116 1
a116 1
		return getUniquePaletteFactoryMethodName("create" + (linkMapping.getDomainMetaClass() != null ? linkMapping.getDomainMetaClass().getName() : linkMapping.getLinkMetaFeature().getName()) + "LinkCreationTool");
@


1.7
log
@updated gmfmap to match newly introduced .gmfgraph model (replaces .diadef) #114177.
besides, rudimentary tooling model is introduced as part of gmfmap #115799, subject to further work
@
text
@d25 1
d39 2
d44 1
d111 12
d181 11
@


1.6
log
@DomainMetaElement property is optional, so using newly created method to get this information.
@
text
@d19 1
a19 1
import org.eclipse.gmf.diadef.Compartment;
@


1.5
log
@#117749 & #118040 generate unique names for the shared elements in mapping model
@
text
@d62 1
a62 1
		if (mapping.getDomainMetaElement() == null) {
d65 1
a65 1
		return createClassName(mapping.getDomainMetaElement().getName(), getNodeSuffix(suffix));
d69 1
a69 1
		if (mapping.getDomainMetaElement() == null) {
d72 1
a72 1
		return createClassName(mapping.getDomainMetaElement().getName(), getChildNodeSuffix(suffix));
d76 1
a76 1
		if (mapping.getDomainMetaElement() == null) {
d79 1
a79 1
		return createClassName(mapping.getDomainMetaElement().getName() + '_' + compartment.getName(), getCompartmentSuffix(suffix));
d83 1
a83 1
		if (mapping.getDomainMetaElement() == null) {
d86 1
a86 1
		return createClassName(mapping.getDomainMetaElement().getName() + '_' + labelFeature.getName(), getCompartmentSuffix(suffix));
d90 2
a91 2
		if (mapping.getDomainMetaElement() != null) {
			return createClassName(mapping.getDomainMetaElement().getName(), getLinkSuffix(suffix));
d99 2
a100 2
		if (mapping.getDomainMetaElement() != null) {
			return createClassName(mapping.getDomainMetaElement().getName() + '_' + labelFeature.getName(), getLinkSuffix(suffix));
@


1.4
log
@[ashatalin] #114750 annotate diagram runtime model elements with visual id to tell one from another during EP decision making
@
text
@d17 2
a18 1
import org.eclipse.core.runtime.IStatus;
d20 1
a20 1
import org.eclipse.gmf.diadef.Node;
a24 1
import org.eclipse.jdt.core.JavaConventions;
d30 2
a31 2
 * appending numerical suffix to it. Use {@@link #clearUniqueNameCache()} to clean 
 * names cache in case you reuse the instance. 
a35 1
	private final Set/* <String> */myNamesCache = new HashSet();
d37 4
a40 2
	public String createClassName(CanvasMapping mapping) {
		return translateNameToJavaIdentifier(mapping.getDiagramCanvas().getName() + getCanvasSuffix());
d42 6
a47 3
	
	public String createClassName(NodeMapping nme) {
		return translateNameToJavaIdentifier(nme.getDiagramNode().getName() + getNodeSuffix());
d50 2
a51 2
	public String createLableTextClassName(NodeMapping nme) {
		return translateNameToJavaIdentifier(nme.getDiagramNode().getName() + " " + (nme.getEditFeature() != null ? nme.getEditFeature().getName() : "LabelText" + nme.hashCode()) + getNodeLabelSuffix());
d53 6
a58 3
	
	public String createClassName(ChildNodeMapping chnme) {
		return translateNameToJavaIdentifier(chnme.getDiagramNode().getName() + getChildNodeSuffix());
d60 6
a65 3
	
	public String createLableTextClassName(ChildNodeMapping chnme) {
		return translateNameToJavaIdentifier(chnme.getDiagramNode().getName() + " " + (chnme.getEditFeature() != null ? chnme.getEditFeature().getName() : "LabelText" + chnme.hashCode()) + getChildNodeLabelSuffix());
d68 5
a72 2
	public String createClassName(LinkMapping lme) {
		return translateNameToJavaIdentifier(lme.getDiagramLink().getName() + getLinkSuffix());
d75 5
a79 2
	public String createLableClassName(LinkMapping lme) {
		return translateNameToJavaIdentifier(lme.getDiagramLink().getName() + " " + (lme.getLabelEditFeature() != null ? lme.getLabelEditFeature().getName() : "Label" + lme.hashCode()) + getLinkLabelSuffix());
d82 5
a86 2
	public String createLableTextClassName(LinkMapping lme) {
		return translateNameToJavaIdentifier(lme.getDiagramLink().getName() + " " + (lme.getLabelEditFeature() != null ? lme.getLabelEditFeature().getName() : "LabelText" + lme.hashCode()) + getLinkLabelTextSuffix());
d88 8
a95 15
	
	public String createClassName(Compartment compartment) {
		return translateNameToJavaIdentifier(((Node) compartment.eContainer()).getName() + " " + compartment.getName() + getCompartmentSuffix());
	}
	
	protected String getNodeLabelSuffix() {
		return "";
	}
	
	protected String getLinkLabelSuffix() {
		return "";
	}
	
	protected String getLinkLabelTextSuffix() {
		return "Text" + getLinkLabelSuffix();
d98 7
a104 2
	protected String getCompartmentSuffix() {
		return "";
d107 6
a112 2
	protected String getLinkSuffix() {
		return "";
d115 6
a120 2
	protected String getNodeSuffix() {
		return "";
d123 6
a128 2
	protected String getCanvasSuffix() {
		return "";
d131 6
a136 6
	protected String getChildNodeSuffix() {
		return "";
	}
	
	protected String getChildNodeLabelSuffix() {
		return "";
d139 6
a144 2
	public void clearUniqueNameCache() {
		myNamesCache.clear();
d147 4
a150 4
	protected String ensureUnique(String name) {
		int i = 2;
		while (myNamesCache.contains(name)) {
			name = name + String.valueOf(i++); 
d152 3
a154 1
		return name;
d157 5
a161 16
	protected String translateNameToJavaIdentifier(String name) {
		name = name.trim();
		IStatus s = JavaConventions.validateJavaTypeName(name);
		if (s.getSeverity() != IStatus.ERROR) {
			return name;
		}
		StringBuffer sb = new StringBuffer(name.length());
		if (!Character.isJavaIdentifierStart(name.charAt(0)) && Character.isJavaIdentifierPart(name.charAt(0))) {
			sb.append('_');
		}
		for (int i = 0; i < name.length(); i++) {
			if (Character.isJavaIdentifierPart(name.charAt(i))) {
				sb.append(name.charAt(i));
			} else {
				sb.append('_');
			}
d163 1
a163 1
		return ensureUnique(sb.toString());
@


1.3
log
@#113633 StringBuffer replaces StringBuilder
@
text
@d18 2
d41 1
a41 1

d46 4
d53 4
d62 28
d105 4
@


1.2
log
@keep track of names
@
text
@d86 1
a86 1
		StringBuilder sb = new StringBuilder(name.length());
@


1.1
log
@*** empty log message ***
@
text
@d14 3
d25 1
a25 1
 * In most cases it should be sufficient to override <code>getXXXSuffix()</code> 
d27 4
a30 1
 * FIXME track names and do not allow duplicates?
d34 1
d68 12
d97 1
a97 1
		return sb.toString();
@

