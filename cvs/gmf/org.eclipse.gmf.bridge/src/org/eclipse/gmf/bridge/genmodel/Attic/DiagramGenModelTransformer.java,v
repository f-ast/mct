head	1.99;
access;
symbols
	v20081015-1925:1.99
	v20080917-1925:1.99
	v20080903-1520:1.99
	v20080827-1520:1.99
	v20080813-1520:1.99
	R1_0_maintenance:1.99.0.2
	R1_0:1.99
	v20060620-0400:1.98
	v20060616-1200:1.97
	v20060609-1400:1.96
	v20060531-1730:1.91
	v20060530-1930:1.91
	v20060526-1200:1.88
	v20060519-0800:1.85
	v20060512-1000:1.79
	I20060512-1000:1.79
	I20060505-1400:1.76
	I20060428-1300:1.76
	I20060424-0500:1.74
	I20060424-0300:1.74
	M6_10:1.72
	I20060407-1200:1.66
	I20060331-1000:1.65
	I20060324-0300:1.65
	I20060317-1300:1.65
	I20060317-1200:1.65
	I20060316-1300:1.65
	I20060309-1300:1.64
	M5_10:1.63
	S20060303-1600:1.63
	I20060227-1730:1.56
	I20060216-1945:1.52
	I20060210-1715:1.49
	I20060209-1815:1.49
	I20060203-0830:1.45
	I20060129-1145:1.44
	I20060127-0900:1.44
	I20060120-1530:1.43
	I20060113-1700:1.39
	M4_10:1.39
	I20060107-1100:1.34
	I20060105-1630:1.33
	I20051230-1230:1.32
	I20051223-1100:1.32
	I20051217-0925:1.30
	I20051208-2000:1.29
	I20051201-1800:1.26
	M3_10:1.21
	I20051118-1245:1.21
	I20051111-1800:1.20
	I20051106-0900:1.20
	v20051030:1.19
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.99
date	2006.06.26.14.05.05;	author atikhomirov;	state dead;
branches;
next	1.98;

1.98
date	2006.06.19.14.11.28;	author dstadnik;	state Exp;
branches;
next	1.97;

1.97
date	2006.06.14.12.12.59;	author dstadnik;	state Exp;
branches;
next	1.96;

1.96
date	2006.06.09.09.02.41;	author dstadnik;	state Exp;
branches;
next	1.95;

1.95
date	2006.06.06.16.22.10;	author radvorak;	state Exp;
branches;
next	1.94;

1.94
date	2006.06.06.09.56.10;	author dstadnik;	state Exp;
branches;
next	1.93;

1.93
date	2006.06.02.11.43.02;	author radvorak;	state Exp;
branches;
next	1.92;

1.92
date	2006.06.01.12.44.41;	author atikhomirov;	state Exp;
branches;
next	1.91;

1.91
date	2006.05.30.19.09.11;	author radvorak;	state Exp;
branches;
next	1.90;

1.90
date	2006.05.29.20.07.55;	author radvorak;	state Exp;
branches;
next	1.89;

1.89
date	2006.05.29.18.04.05;	author atikhomirov;	state Exp;
branches;
next	1.88;

1.88
date	2006.05.26.14.16.26;	author dstadnik;	state Exp;
branches;
next	1.87;

1.87
date	2006.05.24.18.12.44;	author ashatalin;	state Exp;
branches;
next	1.86;

1.86
date	2006.05.23.21.09.43;	author atikhomirov;	state Exp;
branches;
next	1.85;

1.85
date	2006.05.18.12.36.11;	author dstadnik;	state Exp;
branches;
next	1.84;

1.84
date	2006.05.17.14.22.49;	author dstadnik;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.17.12.39.18;	author atikhomirov;	state Exp;
branches;
next	1.82;

1.82
date	2006.05.15.17.08.51;	author ashatalin;	state Exp;
branches;
next	1.81;

1.81
date	2006.05.15.12.45.04;	author dstadnik;	state Exp;
branches;
next	1.80;

1.80
date	2006.05.14.18.06.39;	author atikhomirov;	state Exp;
branches;
next	1.79;

1.79
date	2006.05.11.18.37.44;	author radvorak;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.11.09.42.06;	author dstadnik;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.10.15.12.36;	author dstadnik;	state Exp;
branches;
next	1.76;

1.76
date	2006.04.26.17.48.41;	author radvorak;	state Exp;
branches;
next	1.75;

1.75
date	2006.04.25.19.15.39;	author radvorak;	state Exp;
branches;
next	1.74;

1.74
date	2006.04.20.13.59.46;	author dstadnik;	state Exp;
branches;
next	1.73;

1.73
date	2006.04.19.19.42.08;	author atikhomirov;	state Exp;
branches;
next	1.72;

1.72
date	2006.04.14.18.06.25;	author atikhomirov;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.13.21.57.32;	author atikhomirov;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.13.18.36.49;	author atikhomirov;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.13.17.56.08;	author atikhomirov;	state Exp;
branches;
next	1.68;

1.68
date	2006.04.13.15.41.22;	author radvorak;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.12.08.48.13;	author dstadnik;	state Exp;
branches;
next	1.66;

1.66
date	2006.04.03.12.53.10;	author radvorak;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.10.21.21.34;	author atikhomirov;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.07.14.08.50;	author dstadnik;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.03.18.32.24;	author ashatalin;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.03.14.40.24;	author dstadnik;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.03.11.36.23;	author ashatalin;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.02.13.49.54;	author dstadnik;	state Exp;
branches;
next	1.59;

1.59
date	2006.02.28.18.02.33;	author atikhomirov;	state Exp;
branches;
next	1.58;

1.58
date	2006.02.28.16.27.04;	author atikhomirov;	state Exp;
branches;
next	1.57;

1.57
date	2006.02.27.15.59.09;	author ashatalin;	state Exp;
branches;
next	1.56;

1.56
date	2006.02.24.20.23.08;	author atikhomirov;	state Exp;
branches;
next	1.55;

1.55
date	2006.02.24.18.28.15;	author atikhomirov;	state Exp;
branches;
next	1.54;

1.54
date	2006.02.23.15.45.36;	author atikhomirov;	state Exp;
branches;
next	1.53;

1.53
date	2006.02.22.22.01.15;	author atikhomirov;	state Exp;
branches;
next	1.52;

1.52
date	2006.02.14.18.46.20;	author ashatalin;	state Exp;
branches;
next	1.51;

1.51
date	2006.02.14.10.11.26;	author dstadnik;	state Exp;
branches;
next	1.50;

1.50
date	2006.02.13.18.37.50;	author dstadnik;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.08.16.05.51;	author atikhomirov;	state Exp;
branches;
next	1.48;

1.48
date	2006.02.08.12.27.58;	author atikhomirov;	state Exp;
branches;
next	1.47;

1.47
date	2006.02.08.00.17.12;	author atikhomirov;	state Exp;
branches;
next	1.46;

1.46
date	2006.02.06.14.29.59;	author dstadnik;	state Exp;
branches;
next	1.45;

1.45
date	2006.02.03.12.37.45;	author dstadnik;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.26.13.36.52;	author atikhomirov;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.19.19.45.18;	author atikhomirov;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.19.14.59.32;	author ashatalin;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.19.00.10.39;	author ashatalin;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.18.19.28.16;	author atikhomirov;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.12.20.53.07;	author atikhomirov;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.10.20.40.15;	author atikhomirov;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.10.19.01.16;	author atikhomirov;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.10.18.45.26;	author atikhomirov;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.10.18.35.34;	author atikhomirov;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.06.19.22.31;	author atikhomirov;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.05.17.30.32;	author atikhomirov;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.22.17.24.11;	author dstadnik;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.22.16.10.21;	author ashatalin;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.13.17.11.20;	author ashatalin;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.07.19.23.18;	author ashatalin;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.07.17.03.34;	author ashatalin;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.06.22.21.18;	author atikhomirov;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.30.13.49.18;	author ashatalin;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.29.18.33.10;	author atikhomirov;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.28.16.09.36;	author dstadnik;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.25.14.22.58;	author ashatalin;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.25.12.21.50;	author dstadnik;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.14.12.55.57;	author atikhomirov;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.02.17.53.07;	author atikhomirov;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.27.16.11.20;	author atikhomirov;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.27.11.41.49;	author atikhomirov;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.26.18.43.51;	author atikhomirov;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.26.17.57.02;	author atikhomirov;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.26.17.33.11;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.26.13.48.47;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.26.11.27.01;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.24.14.58.48;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.24.13.32.03;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.21.13.32.08;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.20.16.04.38;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.18.10.58.25;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.07.13.01.16;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.06.19.40.11;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.06.15.54.48;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.04.13.18.12;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.03.19.09.16;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.26.14.26.28;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.19.10;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.99
log
@no api packages, classes are for internal use only
@
text
@/*
 * Copyright (c) 2005 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.bridge.genmodel;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.emf.codegen.ecore.genmodel.GenClassifier;
import org.eclipse.emf.codegen.ecore.genmodel.GenDataType;
import org.eclipse.emf.codegen.ecore.genmodel.GenFeature;
import org.eclipse.emf.codegen.ecore.genmodel.GenModel;
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EModelElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.gmf.codegen.gmfgen.CompositeFeatureLabelModelFacet;
import org.eclipse.gmf.codegen.gmfgen.FeatureLabelModelFacet;
import org.eclipse.gmf.codegen.gmfgen.FeatureLinkModelFacet;
import org.eclipse.gmf.codegen.gmfgen.GMFGenFactory;
import org.eclipse.gmf.codegen.gmfgen.GenAuditContainer;
import org.eclipse.gmf.codegen.gmfgen.GenAuditRule;
import org.eclipse.gmf.codegen.gmfgen.GenAuditable;
import org.eclipse.gmf.codegen.gmfgen.GenAuditedMetricTarget;
import org.eclipse.gmf.codegen.gmfgen.GenChildContainer;
import org.eclipse.gmf.codegen.gmfgen.GenChildLabelNode;
import org.eclipse.gmf.codegen.gmfgen.GenChildNode;
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
import org.eclipse.gmf.codegen.gmfgen.GenCompartment;
import org.eclipse.gmf.codegen.gmfgen.GenConstraint;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenDiagramElementTarget;
import org.eclipse.gmf.codegen.gmfgen.GenDomainAttributeTarget;
import org.eclipse.gmf.codegen.gmfgen.GenDomainElementTarget;
import org.eclipse.gmf.codegen.gmfgen.GenEditorGenerator;
import org.eclipse.gmf.codegen.gmfgen.GenElementInitializer;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionInterpreter;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionProviderBase;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionProviderContainer;
import org.eclipse.gmf.codegen.gmfgen.GenFeatureSeqInitializer;
import org.eclipse.gmf.codegen.gmfgen.GenFeatureValueSpec;
import org.eclipse.gmf.codegen.gmfgen.GenLanguage;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenLinkConstraints;
import org.eclipse.gmf.codegen.gmfgen.GenLinkLabel;
import org.eclipse.gmf.codegen.gmfgen.GenMeasurable;
import org.eclipse.gmf.codegen.gmfgen.GenMetricContainer;
import org.eclipse.gmf.codegen.gmfgen.GenMetricRule;
import org.eclipse.gmf.codegen.gmfgen.GenNode;
import org.eclipse.gmf.codegen.gmfgen.GenNodeLabel;
import org.eclipse.gmf.codegen.gmfgen.GenNotationElementTarget;
import org.eclipse.gmf.codegen.gmfgen.GenRuleTarget;
import org.eclipse.gmf.codegen.gmfgen.GenSeverity;
import org.eclipse.gmf.codegen.gmfgen.GenTopLevelNode;
import org.eclipse.gmf.codegen.gmfgen.LabelModelFacet;
import org.eclipse.gmf.codegen.gmfgen.LabelOffsetAttributes;
import org.eclipse.gmf.codegen.gmfgen.LinkLabelAlignment;
import org.eclipse.gmf.codegen.gmfgen.LinkModelFacet;
import org.eclipse.gmf.codegen.gmfgen.MetamodelType;
import org.eclipse.gmf.codegen.gmfgen.Palette;
import org.eclipse.gmf.codegen.gmfgen.ProviderPriority;
import org.eclipse.gmf.codegen.gmfgen.SpecializationType;
import org.eclipse.gmf.codegen.gmfgen.TypeLinkModelFacet;
import org.eclipse.gmf.codegen.gmfgen.TypeModelFacet;
import org.eclipse.gmf.codegen.gmfgen.ValueExpression;
import org.eclipse.gmf.gmfgraph.Alignment;
import org.eclipse.gmf.gmfgraph.AlignmentFacet;
import org.eclipse.gmf.gmfgraph.Compartment;
import org.eclipse.gmf.gmfgraph.LabelOffsetFacet;
import org.eclipse.gmf.internal.bridge.History;
import org.eclipse.gmf.internal.bridge.Knowledge;
import org.eclipse.gmf.internal.bridge.NaiveIdentifierDispenser;
import org.eclipse.gmf.internal.bridge.VisualIdentifierDispenser;
import org.eclipse.gmf.internal.bridge.naming.gen.GenModelNamingMediator;
import org.eclipse.gmf.internal.bridge.tooldef.PaletteHandler;
import org.eclipse.gmf.mappings.AuditContainer;
import org.eclipse.gmf.mappings.AuditRule;
import org.eclipse.gmf.mappings.AuditedMetricTarget;
import org.eclipse.gmf.mappings.CanvasMapping;
import org.eclipse.gmf.mappings.ChildReference;
import org.eclipse.gmf.mappings.CompartmentMapping;
import org.eclipse.gmf.mappings.Constraint;
import org.eclipse.gmf.mappings.DiagramElementTarget;
import org.eclipse.gmf.mappings.DomainAttributeTarget;
import org.eclipse.gmf.mappings.DomainElementTarget;
import org.eclipse.gmf.mappings.ElementInitializer;
import org.eclipse.gmf.mappings.FeatureSeqInitializer;
import org.eclipse.gmf.mappings.FeatureValueSpec;
import org.eclipse.gmf.mappings.LabelMapping;
import org.eclipse.gmf.mappings.Language;
import org.eclipse.gmf.mappings.LinkConstraints;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.Mapping;
import org.eclipse.gmf.mappings.MappingEntry;
import org.eclipse.gmf.mappings.MetricContainer;
import org.eclipse.gmf.mappings.MetricRule;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.NodeReference;
import org.eclipse.gmf.mappings.NotationElementTarget;
import org.eclipse.gmf.mappings.Severity;
import org.eclipse.gmf.mappings.TopNodeReference;

/**
 * Creates generation model from diagram definition.
 * @@author artem
 */
public class DiagramGenModelTransformer extends MappingTransformer {

	private GenEditorGenerator myGenModel;
	protected GenModelMatcher myGenModelMatch;
	private final DiagramRunTimeModelHelper myDRTHelper;
	private final ViewmapProducer myViewmaps;
	private final VisualIdentifierDispenser myVisualIDs;
	private final History myHistory;
	private final Map myProcessedTypes = new IdentityHashMap(); // GenClass -> MetamodelType
	private final Set myProcessedExpressions = new HashSet();

	private final GenModelNamingMediator myNamingStrategy;
	private final PaletteHandler myPaletteProcessor;
	private final EcoreGenModelMatcher myEcoreGenModelMatch;	

	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, GenModelNamingMediator namingStrategy) {
		this(drtHelper, namingStrategy, new InnerClassViewmapProducer(), new NaiveIdentifierDispenser());
	}

	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, GenModelNamingMediator namingStrategy, ViewmapProducer viewmaps, VisualIdentifierDispenser visualIdD) {
		assert drtHelper != null && namingStrategy != null && viewmaps != null;
		myDRTHelper = drtHelper;
		myNamingStrategy = namingStrategy;
		myViewmaps = viewmaps;
		myVisualIDs = visualIdD;
		myHistory = new History();
		myPaletteProcessor = new PaletteHandler();
		myEcoreGenModelMatch = new EcoreGenModelMatcher();
	}

	/**
	 * Optionally set GenModel to match ECore elements against. 
	 * Should be invoked prior to {@@link MappingTransformer#transform(Mapping)}, otherwise has no effect.
	 * Useful for tests (and other cases) when GenModel is not known to EMF 
	 * (and thus can't be obtained using EMF techniques).
	 * @@param emfGenModel EMF GenModel for domain model
	 */
	public void setEMFGenModel(GenModel emfGenModel) {
		myGenModelMatch = new GenModelMatcher(emfGenModel);
	}

	public GenEditorGenerator getResult() {
		return getGenEssence();
	}

	private GenEditorGenerator getGenEssence() {
		if (myGenModel == null) {
			myGenModel = GMFGenFactory.eINSTANCE.createGenEditorGenerator();
		}
		// init editor as well - transformer does not set any property to it, just make sure it's not null
		if (myGenModel.getEditor() == null) {
			myGenModel.setEditor(GMFGenFactory.eINSTANCE.createGenEditorView());
		}
		return myGenModel;
	}

	private GenDiagram getGenDiagram() {
		if (getGenEssence().getDiagram() == null) {
			getGenEssence().setDiagram(GMFGenFactory.eINSTANCE.createGenDiagram());
		}
		return getGenEssence().getDiagram();
	}

	private void initGenPlugin() {
		if (getGenEssence().getPlugin() == null) {
			getGenEssence().setPlugin(GMFGenFactory.eINSTANCE.createGenPlugin());
		}
	}

	private Palette createGenPalette() {
		Palette p = getGenDiagram().getPalette();
		if (p == null) {
			p = GMFGenFactory.eINSTANCE.createPalette();
			getGenDiagram().setPalette(p);
		}
		return p;
	}

	protected void process(CanvasMapping mapping) {
		if (myGenModelMatch == null && mapping.getDomainModel() != null) {
			myGenModelMatch = new GenModelMatcher(mapping.getDomainModel());
		}
		myHistory.purge();
		if (mapping.getPalette() != null) {
			myPaletteProcessor.initialize(createGenPalette());
			myPaletteProcessor.process(mapping.getPalette());
		}
		GenPackage primaryPackage = findGenPackage(mapping.getDomainModel());
		getGenEssence().setDomainGenModel(primaryPackage == null ? null : primaryPackage.getGenModel());
		getGenDiagram().setDomainDiagramElement(findGenClass(mapping.getDomainMetaElement()));
		getGenDiagram().setDiagramRunTimeClass(findRunTimeClass(mapping));
		getGenDiagram().setVisualID(myVisualIDs.get(getGenDiagram()));
		getGenDiagram().setViewmap(myViewmaps.create(mapping.getDiagramCanvas()));
		getGenDiagram().setIconProviderPriority(ProviderPriority.LOW_LITERAL); // override ElementTypeIconProvider
		if (getGenDiagram().getDomainDiagramElement() != null) {
			// since diagram is the first entity to process consider it defines metamodel type
			getGenDiagram().setElementType(GMFGenFactory.eINSTANCE.createMetamodelType());
			myProcessedTypes.put(getGenDiagram().getDomainDiagramElement(), getGenDiagram().getElementType());
		} else {
			getGenDiagram().setElementType(GMFGenFactory.eINSTANCE.createNotationType());
		}
		
		initGenPlugin();

		// set class names
		myNamingStrategy.feed(getGenDiagram(), mapping);
	}

	protected void process(TopNodeReference topNode) {
		final NodeMapping nme = topNode.getChild();
		assert nme != null;
		assertNodeMapping(nme);
		
		GenTopLevelNode genNode = GMFGenFactory.eINSTANCE.createGenTopLevelNode();
		getGenDiagram().getTopLevelNodes().add(genNode);
		genNode.setDiagramRunTimeClass(findRunTimeClass(nme));
		genNode.setModelFacet(createModelFacet(topNode));
		genNode.setVisualID(myVisualIDs.get(genNode));
		genNode.setViewmap(myViewmaps.create(nme.getDiagramNode()));
		setupElementType(genNode); 
		myPaletteProcessor.process(nme, genNode);

		// set class names
		myNamingStrategy.feed(genNode, nme);
		
		processAbstractNode(nme, genNode);
		myHistory.log(nme, genNode);
	}
	
	protected void process(AuditContainer audits) {
		if(audits != null) {
			getGenEssence().setAudits(createGenAuditContainer(audits));	
		}
	}	
	
	protected void process(MetricContainer metrics) {
		if(metrics != null) {
			GenMetricContainer genMetricContainer = GMFGenFactory.eINSTANCE.createGenMetricContainer();
			for (Iterator it = metrics.getMetrics().iterator(); it.hasNext();) {
				genMetricContainer.getMetrics().add(createGenMetric((MetricRule)it.next()));				
			}
			getGenEssence().setMetrics(genMetricContainer);
		}
	}

	private void process(ChildReference childNodeRef, GenChildContainer container) {
		final NodeMapping childNodeMapping = childNodeRef.getChild();
		assert childNodeMapping != null;
		assertNodeMapping(childNodeMapping);

		GenChildNode childNode;
		if (!myHistory.isKnownChildNode(childNodeMapping)) {
			childNode = createGenChildNode(childNodeRef);
		} else {
			GenChildNode[] alreadyKnownChildren = myHistory.findChildNodes(childNodeMapping);

			childNode = null;
			for (int i = 0; i < alreadyKnownChildren.length; i++) {
				if (matchChildReferenceFeatures(childNodeRef, alreadyKnownChildren[i])) {
					childNode = alreadyKnownChildren[i];
					break;
				}
			}
			if (childNode == null) { // no match
				childNode = createGenChildNode(childNodeRef);
			}
		}
		if (container instanceof GenCompartment && childNodeMapping.getChildren().size() > 0) {
			// TODO just layout from childNodeMapping.getDiagramNode()
			((GenCompartment)container).setListLayout(false);
		}
		container.getChildNodes().add(childNode);
	}

	/**
	 * Handle case when second-level ChildReference references existing nodemapping, but 
	 * with different containment/children reference. 
	 * @@see https://bugs.eclipse.org/bugs/show_bug.cgi?id=129552
	 */
	private static boolean matchChildReferenceFeatures(ChildReference childNodeRef, GenChildNode childNode) {
		final boolean containmentFeatureMatch;
		final boolean childrenFeatureMatch;
		if (childNode.getModelFacet() == null || childNode.getModelFacet().getContainmentMetaFeature() == null) {
			containmentFeatureMatch = (null == childNodeRef.getContainmentFeature());
		} else {
			// seems legal to use '==' because features should came from the same model
			containmentFeatureMatch = childNodeRef.getContainmentFeature() == childNode.getModelFacet().getContainmentMetaFeature().getEcoreFeature();
		}
		if (childNode.getModelFacet() == null || childNode.getModelFacet().getChildMetaFeature() == null) {
			childrenFeatureMatch = (null == childNodeRef.getChildrenFeature());
		} else {
			if (childNodeRef.getChildrenFeature() == null) {
				// likely, childMetaFeature in model facet was derived from containment feature 
				childrenFeatureMatch = childNode.getModelFacet().getChildMetaFeature() == childNode.getModelFacet().getContainmentMetaFeature();
			} else {
				// honest check
				childrenFeatureMatch = childNode.getModelFacet().getChildMetaFeature().getEcoreFeature() == childNodeRef.getChildrenFeature();
			}
		}
		return containmentFeatureMatch && childrenFeatureMatch;
	}

	private GenChildNode createGenChildNode(ChildReference childNodeRef) {
		final NodeMapping childNodeMapping = childNodeRef.getChild();
		final GenChildNode childNode;
		final boolean needCompartmentChildrenLabelProcessing;
		if (isPureLabelNode(childNodeMapping)) {
			LabelMapping soleLabel = (LabelMapping) childNodeMapping.getLabelMappings().get(0);
			GenChildLabelNode childLabelNode = GMFGenFactory.eINSTANCE.createGenChildLabelNode();
			childLabelNode.setViewmap(myViewmaps.create(soleLabel.getDiagramLabel()));
			childLabelNode.setLabelModelFacet(createLabelModelFacet(soleLabel));
			childLabelNode.setLabelReadOnly(soleLabel.isReadOnly());
			childLabelNode.setLabelElementIcon(soleLabel.getDiagramLabel().isElementIcon());
			childNode = childLabelNode;
			needCompartmentChildrenLabelProcessing = false;
		} else {
			childNode = GMFGenFactory.eINSTANCE.createGenChildNode();
			childNode.setViewmap(myViewmaps.create(childNodeMapping.getDiagramNode()));
			needCompartmentChildrenLabelProcessing = true;
		}
		myHistory.log(childNodeMapping, childNode);
		getGenDiagram().getChildNodes().add(childNode);

		childNode.setModelFacet(createModelFacet(childNodeRef));
		
		childNode.setDiagramRunTimeClass(findRunTimeClass(childNodeMapping));
		childNode.setVisualID(myVisualIDs.get(childNode));
		setupElementType(childNode); 

		// set class names
		myNamingStrategy.feed(childNode, childNodeMapping);

		myPaletteProcessor.process(childNodeMapping, childNode);
		if (needCompartmentChildrenLabelProcessing) {
			processAbstractNode(childNodeMapping, childNode);
		}
		return childNode;
	}
	
	/**
	 * @@return whether nodeMapping has single label, no children and node's diagram 
	 * element is DiagramLabel equivalent that of it's label
	 */
	private boolean isPureLabelNode(NodeMapping childNodeMapping) {
		if (childNodeMapping.getLabelMappings().size() == 1 && childNodeMapping.getChildren().isEmpty()) {
			LabelMapping soleLabel = (LabelMapping) childNodeMapping.getLabelMappings().get(0);
			return childNodeMapping.getDiagramNode() == soleLabel.getDiagramLabel(); 
		}
		return false;
	}

	private void processAbstractNode(NodeMapping mapping, GenNode genNode) {
		Map compartments2GenCompartmentsMap = new HashMap();
		for (Iterator it = mapping.getCompartments().iterator(); it.hasNext();) {
			CompartmentMapping compartmentMapping = (CompartmentMapping) it.next();
			GenCompartment compartmentGen = createGenCompartment(compartmentMapping, genNode);
			compartments2GenCompartmentsMap.put(compartmentMapping, compartmentGen);
		}

		for (Iterator it = mapping.getChildren().iterator(); it.hasNext();) {
			ChildReference childNodeRef = (ChildReference) it.next();
// Currently childNodeMapping should has compartment but we plan to make this reference optional
			CompartmentMapping compartmentMapping = childNodeRef.getCompartment();
			GenChildContainer genChildContainer;
			if (compartmentMapping != null && compartments2GenCompartmentsMap.containsKey(compartmentMapping)) {
				genChildContainer = (GenChildContainer) compartments2GenCompartmentsMap.get(compartmentMapping);
			} else {
				genChildContainer = genNode;
			}
			process(childNodeRef, genChildContainer);
		}
		for (Iterator labels = mapping.getLabelMappings().iterator(); labels.hasNext();) {
			LabelMapping labelMapping = (LabelMapping) labels.next();
			GenNodeLabel label = createNodeLabel(genNode, labelMapping);

			// set class names
			myNamingStrategy.feed(label, labelMapping);
		}
	}

	private GenCompartment createGenCompartment(CompartmentMapping mapping, GenNode genNode) {
		Compartment compartment = mapping.getCompartment(); 
		assert compartment != null;
		GenCompartment childCompartment = GMFGenFactory.eINSTANCE.createGenCompartment();
		getGenDiagram().getCompartments().add(childCompartment);
		genNode.getCompartments().add(childCompartment);
		childCompartment.setVisualID(myVisualIDs.get(childCompartment));
		childCompartment.setDiagramRunTimeClass(getChildContainerRunTimeClass());
		childCompartment.setViewmap(myViewmaps.create(mapping.getCompartment()));
		childCompartment.setCanCollapse(compartment.isCollapsible());
		childCompartment.setNeedsTitle(compartment.isNeedsTitle());
		childCompartment.setTitle(compartment.getName());

		// set class names
		myNamingStrategy.feed(childCompartment, mapping);
		return childCompartment;
	}

	protected void process(LinkMapping lme) {
		assertLinkMapping(lme);
		GenLink gl = GMFGenFactory.eINSTANCE.createGenLink();
		getGenDiagram().getLinks().add(gl);
		gl.setModelFacet(createModelFacet(lme));
		gl.setVisualID(myVisualIDs.get(gl));
		myPaletteProcessor.process(lme, gl);
		for (Iterator labels = lme.getLabelMappings().iterator(); labels.hasNext();) {
			LabelMapping labelMapping = (LabelMapping) labels.next();
			GenLinkLabel label = createLinkLabel(gl, labelMapping);

			// set class names
			myNamingStrategy.feed(label, labelMapping);
		}
		gl.setDiagramRunTimeClass(findRunTimeClass(lme));

		setupElementType(gl);

		// set class names
		myNamingStrategy.feed(gl, lme);

		gl.setViewmap(myViewmaps.create(lme.getDiagramLink()));

		if(lme.getCreationConstraints() != null) {
			gl.setCreationConstraints(createLinkCreationConstraints(lme.getCreationConstraints()));
		}
		
		myHistory.log(lme, gl);
	}

	private GenNodeLabel createNodeLabel(GenNode node, LabelMapping mapping) {
		GenNodeLabel label;
		if (Knowledge.isExternal(mapping.getDiagramLabel())) {
			label = GMFGenFactory.eINSTANCE.createGenExternalNodeLabel();
		} else {
			label = GMFGenFactory.eINSTANCE.createGenNodeLabel();
		}
		node.getLabels().add(label);
		label.setVisualID(myVisualIDs.get(label));
		label.setDiagramRunTimeClass(findRunTimeClass(mapping));
		label.setViewmap(myViewmaps.create(mapping.getDiagramLabel()));
		label.setModelFacet(createLabelModelFacet(mapping));
		label.setReadOnly(mapping.isReadOnly());
		label.setElementIcon(mapping.getDiagramLabel().isElementIcon());
		return label;
	}

	private GenLinkLabel createLinkLabel(GenLink link, LabelMapping mapping) {
		GenLinkLabel label = GMFGenFactory.eINSTANCE.createGenLinkLabel();
		link.getLabels().add(label);
		label.setVisualID(myVisualIDs.get(label));
		label.setDiagramRunTimeClass(findRunTimeClass(mapping));
		label.setViewmap(myViewmaps.create(mapping.getDiagramLabel()));
		label.setModelFacet(createLabelModelFacet(mapping));
		label.setReadOnly(mapping.isReadOnly());
		label.setElementIcon(mapping.getDiagramLabel().isElementIcon());
		if (mapping.getDiagramLabel().find(AlignmentFacet.class) != null) {
			AlignmentFacet af = (AlignmentFacet) mapping.getDiagramLabel().find(AlignmentFacet.class);
			label.setAlignment(getLinkLabelAlignment(af.getAlignment()));
		}
		LabelOffsetAttributes loa = GMFGenFactory.eINSTANCE.createLabelOffsetAttributes();
		LabelOffsetFacet lof = (LabelOffsetFacet) mapping.getDiagramLabel().find(LabelOffsetFacet.class);
		if (lof != null) {
			loa.setX(lof.getX());
			loa.setY(lof.getY());
		} else {
			// stack labels under link by default
			int weight = link.getLabels().size() + 1;
			loa.setY(weight * 20);
		}
		label.getViewmap().getAttributes().add(loa);
		return label;
	}

	private LinkLabelAlignment getLinkLabelAlignment(Alignment alignment) {
		switch (alignment.getValue()) {
		case Alignment.BEGINNING: return LinkLabelAlignment.SOURCE_LITERAL;
		case Alignment.CENTER: return LinkLabelAlignment.MIDDLE_LITERAL;
		case Alignment.END: return LinkLabelAlignment.TARGET_LITERAL;
		default: throw new IllegalArgumentException("Link doesn't support alignment:" + alignment.getName());
		}
	}

	private LabelModelFacet createLabelModelFacet(LabelMapping mapping) {
		if (mapping.getFeatures().size() == 1) {
			FeatureLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureLabelModelFacet();
			modelFacet.setMetaFeature(findGenFeature((EAttribute) mapping.getFeatures().get(0)));
			modelFacet.setViewPattern(mapping.getViewPattern());
			modelFacet.setEditPattern(mapping.getEditPattern());
			return modelFacet;
		}
		if (mapping.getFeatures().size() > 1) {
			CompositeFeatureLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createCompositeFeatureLabelModelFacet();
			for (Iterator features = mapping.getFeatures().iterator(); features.hasNext();) {
				modelFacet.getMetaFeatures().add(findGenFeature((EAttribute) features.next()));
			}
			modelFacet.setViewPattern(mapping.getViewPattern());
			modelFacet.setEditPattern(mapping.getEditPattern());
			return modelFacet;
		}
		if (myGenModelMatch == null) {
			// pure design diagram
			return GMFGenFactory.eINSTANCE.createDesignLabelModelFacet();
		}
		return null;
	}

	private void setupElementType(GenNode genNode) {
		if (genNode.getModelFacet() != null) {
			MetamodelType metamodelType = (MetamodelType) myProcessedTypes.get(genNode.getModelFacet().getMetaClass());
			if (metamodelType == null) {
				// this is the first metaclass encounter; consider metamodel type definition
				genNode.setElementType(GMFGenFactory.eINSTANCE.createMetamodelType());
				myProcessedTypes.put(genNode.getModelFacet().getMetaClass(), genNode.getElementType());
			} else {
				// all subsequent encounters lead to specialization definitions
				SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
				specializationType.setMetamodelType(metamodelType);
				genNode.setElementType(specializationType);
			}
		} else {
			genNode.setElementType(GMFGenFactory.eINSTANCE.createNotationType());
		}
	}

	private void setupElementType(GenLink gl) {
		if (gl.getModelFacet() != null) {
			if (gl.getModelFacet() instanceof TypeModelFacet) {
				GenClass metaClass = ((TypeModelFacet) gl.getModelFacet()).getMetaClass();
				MetamodelType metamodelType = (MetamodelType) myProcessedTypes.get(metaClass);
				if (metamodelType == null) {
					// this is the first metaclass encounter; consider metamodel type definition
					gl.setElementType(GMFGenFactory.eINSTANCE.createMetamodelType());
					myProcessedTypes.put(metaClass, gl.getElementType());
				} else {
					// all subsequent encounters lead to specialization definitions
					SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
					specializationType.setMetamodelType(metamodelType);
					gl.setElementType(specializationType);
				}
			} else {
				// ref-based link; specialize null
				SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
				gl.setElementType(specializationType);
			}
		} else {
			gl.setElementType(GMFGenFactory.eINSTANCE.createNotationType());
		}
	}

	private GenClass findRunTimeClass(NodeMapping nme) {
		return myDRTHelper.get(nme);
	}

	private GenClass findRunTimeClass(LinkMapping lme) {
		return myDRTHelper.get(lme);
	}

	private GenClass findRunTimeClass(CanvasMapping mapping) {
		return myDRTHelper.get(mapping);
	}

	private GenClass getChildContainerRunTimeClass() {
		return myDRTHelper.getChildContainerDefault();
	}

	private GenClass findRunTimeClass(LabelMapping mapping) {
		return myDRTHelper.get(mapping);
	}


	private void assertNodeMapping(NodeMapping mapping) {
		assert mapping.getDiagramNode() != null;
		assert checkLabelMappings(mapping);
	}

	private void assertLinkMapping(LinkMapping linkMapping) {
		assert linkMapping.getDiagramLink() != null;
		if (linkMapping.getDomainMetaElement() != null) {
			assert linkMapping.getLinkMetaFeature() != null;
		}
		assert checkLabelMappings(linkMapping);
	}

	private static boolean checkLabelMappings(MappingEntry entry) {
		boolean ok = true;
		for (Iterator it = entry.getLabelMappings().iterator(); ok && it.hasNext();) {
			ok = checkLabelFeatureValidity((LabelMapping) it.next());
		}
		return ok;
	}

	private static boolean checkLabelFeatureValidity(LabelMapping labelMapping) {
		final EClass domainElement = labelMapping.getMapEntry().getDomainContext(); 
		boolean isOk = true;
		for (Iterator it = labelMapping.getFeatures().iterator(); isOk && it.hasNext(); ) {
			EClass attrContainer = ((EAttribute) it.next()).getEContainingClass();
			isOk = attrContainer.isSuperTypeOf(domainElement);
		}
		return isOk;
	}

	private GenPackage findGenPackage(EPackage ePackage) {
		if (myGenModelMatch == null) {
			warnNoGenModelMatcher(ePackage);
			return null;
		}
		return myGenModelMatch.findGenPackage(ePackage);
	}

	private GenClass findGenClass(EClass eClass) {
		if (myGenModelMatch == null) {
			warnNoGenModelMatcher(eClass);
			return null;
		}
		return myGenModelMatch.findGenClass(eClass);
	}

	private GenFeature findGenFeature(EStructuralFeature feature) {
		if (myGenModelMatch == null) {
			warnNoGenModelMatcher(feature);
			return null;
		}
		return myGenModelMatch.findGenFeature(feature);
	}
	
	private void warnNoGenModelMatcher(EModelElement element) {
		// TODO : emit warning
	}
	
	private TypeModelFacet createModelFacet(NodeReference anm) {
		final NodeMapping nodeMapping = anm.getChild();
		if (nodeMapping.getDomainContext() == null) {
			return null;
		}
		TypeModelFacet typeModelFacet = setupModelFacet(nodeMapping.getDomainContext(), anm.getContainmentFeature(), anm.getChildrenFeature());
		return setupAux(typeModelFacet, nodeMapping.getDomainSpecialization(), nodeMapping.getDomainInitializer());
	}

	private LinkModelFacet createModelFacet(LinkMapping lme) {
		if (lme.getDomainMetaElement() != null) {
			TypeLinkModelFacet mf = GMFGenFactory.eINSTANCE.createTypeLinkModelFacet();
			mf.setMetaClass(findGenClass(lme.getDomainMetaElement()));
			mf.setContainmentMetaFeature(findGenFeature(lme.getContainmentFeature()));
			mf.setChildMetaFeature(mf.getContainmentMetaFeature());
			mf.setSourceMetaFeature(findGenFeature(lme.getSourceMetaFeature()));
			mf.setTargetMetaFeature(findGenFeature(lme.getLinkMetaFeature()));
			setupAux(mf, lme.getDomainSpecialization(), lme.getDomainInitializer());
			return mf;
		} else if (lme.getLinkMetaFeature() != null) {
			FeatureLinkModelFacet mf = GMFGenFactory.eINSTANCE.createFeatureLinkModelFacet();
			mf.setMetaFeature(findGenFeature(lme.getLinkMetaFeature()));
			return mf;
		}
		return null; // notation link
	}

	private GenLinkConstraints createLinkCreationConstraints(LinkConstraints constraints) {
		LinkMapping lme = constraints.getLinkMapping();
		if(lme == null) {
			return null;
		}				
		GenLinkConstraints genConstraints = GMFGenFactory.eINSTANCE.createGenLinkConstraints();
		Constraint sourceConstraint = constraints.getSourceEnd();
		if(sourceConstraint != null) {
			genConstraints.setSourceEnd(createGenConstraint(sourceConstraint));
		}
		Constraint targetConstraint = constraints.getTargetEnd();
		if(targetConstraint != null) {
			genConstraints.setTargetEnd(createGenConstraint(targetConstraint));
		}		
		return genConstraints; 
	}

	private TypeModelFacet setupModelFacet(EClass domainMetaElement, EStructuralFeature containmentFeature, EStructuralFeature childFeature) {
		TypeModelFacet mf = GMFGenFactory.eINSTANCE.createTypeModelFacet();
		mf.setMetaClass(findGenClass(domainMetaElement));
		mf.setContainmentMetaFeature(findGenFeature(containmentFeature));
		mf.setChildMetaFeature(childFeature == null ? mf.getContainmentMetaFeature() : findGenFeature(childFeature));
		return mf;
	}

	/**
	 * @@return typeModelFacet argument for convenience
	 */
	private TypeModelFacet setupAux(TypeModelFacet typeModelFacet, Constraint spec, ElementInitializer init) {
		// construct model element selector for domain EClass specializations if any exist
		if(spec != null) {
			typeModelFacet.setModelElementSelector(createGenConstraint(spec));
		}
		if(init != null) {
			typeModelFacet.setModelElementInitializer(createElementInitializer(init));			
		}
		return typeModelFacet;
	}

	private GenElementInitializer createElementInitializer(ElementInitializer elementInitializer) {
		if(elementInitializer instanceof FeatureSeqInitializer) {
			FeatureSeqInitializer fsInitializer = (FeatureSeqInitializer) elementInitializer;
			GenFeatureSeqInitializer fSeqInitializer = GMFGenFactory.eINSTANCE.createGenFeatureSeqInitializer();
			
			for (Iterator it = fsInitializer.getInitializers().iterator(); it.hasNext();) {
				FeatureValueSpec nextValSpec = (FeatureValueSpec) it.next();
				
				GenFeatureValueSpec nextGenValSpec = GMFGenFactory.eINSTANCE.createGenFeatureValueSpec();				
				nextGenValSpec.setBody(nextValSpec.getBody());
				nextGenValSpec.setLanguage(createGenLanguage(nextValSpec.getLanguage()));
				nextGenValSpec.setFeature(findGenFeature(nextValSpec.getFeature()));
				bindToProvider(nextValSpec, nextGenValSpec);				
				
				fSeqInitializer.getInitializers().add(nextGenValSpec);
			}
			return fSeqInitializer;
		}
		return null;
	}
	

	private static GenLanguage createGenLanguage(Language mapLang) {
		switch (mapLang.getValue()) {
		case Language.OCL:
			return GenLanguage.OCL_LITERAL;
		case Language.JAVA:
			return GenLanguage.JAVA_LITERAL;
		case Language.REGEXP:
			return GenLanguage.REGEXP_LITERAL;
		case Language.NREGEXP:
			return GenLanguage.NREGEXP_LITERAL;
		default:
			assert false : mapLang;
		}
		return GenLanguage.OCL_LITERAL;
	}
	
	private GenConstraint createGenConstraint(Constraint constraint) {
		if(constraint.getBody() == null) {
			return null;
		}
		GenConstraint modelElementSelector = GMFGenFactory.eINSTANCE.createGenConstraint();
		modelElementSelector.setBody(constraint.getBody());
		modelElementSelector.setLanguage(createGenLanguage(constraint.getLanguage()));
		bindToProvider(constraint, modelElementSelector);
		return modelElementSelector;
	}
	
	private GenAuditContainer createGenAuditContainer(AuditContainer ac) {
		GenAuditContainer gac = GMFGenFactory.eINSTANCE.createGenAuditContainer();
		gac.setId(ac.getId());
		gac.setName(ac.getName());
		gac.setDescription(ac.getDescription());
		for(Iterator it = ac.getChildContainers().iterator(); it.hasNext();) {
			AuditContainer nextChild = (AuditContainer) it.next();
			gac.getChildContainers().add(createGenAuditContainer(nextChild));
		}
		for (Iterator it = ac.getAudits().iterator(); it.hasNext();) {
			gac.getAudits().add(createGenAudit((AuditRule) it.next()));
		}
		return gac;
	}
	
	private GenAuditRule createGenAudit(AuditRule audit) {
		GenAuditRule genAudit = GMFGenFactory.eINSTANCE.createGenAuditRule();
		genAudit.setId(audit.getId());
		genAudit.setName(audit.getName());
		genAudit.setMessage(audit.getMessage());
		genAudit.setDescription(audit.getDescription());
		genAudit.setUseInLiveMode(audit.isUseInLiveMode());
		
		if(audit.getTarget() != null) {
			GenRuleTarget genTarget = createRuleTarget(audit.getTarget());
			assert genTarget instanceof GenAuditable;
			if(genTarget instanceof GenAuditable) {
				genAudit.setTarget((GenAuditable)genTarget);
			}
		}
		Constraint rule = audit.getRule();
		if(rule != null) {
			genAudit.setRule(createGenConstraint(rule));
		}

		Severity severity = audit.getSeverity();
		GenSeverity genSeverity = null;
		if(severity == Severity.INFO_LITERAL) {
			genSeverity = GenSeverity.INFO_LITERAL;
		} else if(severity == Severity.WARNING_LITERAL) {
			genSeverity = GenSeverity.WARNING_LITERAL;
		} else if(severity == Severity.ERROR_LITERAL) {
			genSeverity = GenSeverity.ERROR_LITERAL;
		}
		if(genSeverity != null) {
			genAudit.setSeverity(genSeverity);
		}
		return genAudit;
	} 
	
	private GenRuleTarget createRuleTarget(EObject ruleTarget) {		
		if (ruleTarget instanceof DomainElementTarget) {
			DomainElementTarget domainTarget = (DomainElementTarget)ruleTarget;
			GenDomainElementTarget genDomainTarget = GMFGenFactory.eINSTANCE.createGenDomainElementTarget();
			genDomainTarget.setElement(domainTarget.getElement() != null ? findGenClass(domainTarget.getElement()) : null);
			return genDomainTarget;
		} else if (ruleTarget instanceof NotationElementTarget) {
			NotationElementTarget notationTarget = (NotationElementTarget) ruleTarget;
			GenNotationElementTarget genNotationTarget = GMFGenFactory.eINSTANCE.createGenNotationElementTarget();
			genNotationTarget.setElement(notationTarget.getElement() != null ? findGenClass(notationTarget.getElement()) : null);
			return genNotationTarget;

		} else if (ruleTarget instanceof DiagramElementTarget) {
			GenDiagramElementTarget diagramTarget = GMFGenFactory.eINSTANCE.createGenDiagramElementTarget();
			MappingEntry mappingEntry = ((DiagramElementTarget) ruleTarget).getElement();
			if (mappingEntry != null) {
				LinkMapping lm = mappingEntry instanceof LinkMapping ? (LinkMapping) mappingEntry : null;
				GenCommonBase genBase = null;				
				if (lm != null) {
					genBase = myHistory.find(lm);
					assert genBase != null;
					if(genBase != null) {
						diagramTarget.getElement().add(genBase);
					}
				} else {
					NodeMapping nm = mappingEntry instanceof NodeMapping ? (NodeMapping) mappingEntry : null;
					// There may be few GenChildNodes corresponding to same mapping entry.					
					// @@see https://bugs.eclipse.org/bugs/show_bug.cgi?id=136701					
					genBase = myHistory.findTopNode(nm);
					if(genBase != null) {
						diagramTarget.getElement().add(genBase);
					}
					diagramTarget.getElement().addAll(Arrays.asList(myHistory.findChildNodes(nm)));					
				}				
			}
			return diagramTarget;
		} else if(ruleTarget instanceof AuditedMetricTarget) {			
			GenAuditedMetricTarget genMetricTarget = GMFGenFactory.eINSTANCE.createGenAuditedMetricTarget();
			AuditedMetricTarget metricTarget = (AuditedMetricTarget)ruleTarget;
			if(metricTarget.getMetric() != null) {
				genMetricTarget.setMetric(myHistory.find(metricTarget.getMetric()));
			}
			GenClassifier resultClassifier = myEcoreGenModelMatch.findGenClassifier(EcorePackage.eINSTANCE.getEDoubleObject());
			assert resultClassifier instanceof GenDataType;
			if(resultClassifier instanceof GenDataType) {
				genMetricTarget.setMetricValueContext((GenDataType)resultClassifier);
			}
			return genMetricTarget;
		} else if(ruleTarget instanceof DomainAttributeTarget) {
			DomainAttributeTarget attrTarget = (DomainAttributeTarget) ruleTarget;
			GenDomainAttributeTarget genAttrTarget = GMFGenFactory.eINSTANCE.createGenDomainAttributeTarget();
			if(attrTarget.getAttribute() != null) {
				genAttrTarget.setAttribute(findGenFeature(attrTarget.getAttribute()));
			}
			genAttrTarget.setNullAsError(attrTarget.isNullAsError());
			return genAttrTarget;				
		} else {
			assert false : "Uknown rule target type"; //$NON-NLS-1$
		}
		return null;
	}
	
	private GenMetricRule createGenMetric(MetricRule metric) {
		GenMetricRule genMetric = GMFGenFactory.eINSTANCE.createGenMetricRule();
		genMetric.setKey(metric.getKey());
		genMetric.setName(metric.getName());
		genMetric.setDescription(metric.getDescription());
		genMetric.setLowLimit(metric.getLowLimit());
		genMetric.setHighLimit(metric.getHighLimit());
		
		if(metric.getRule() != null) {
			ValueExpression valueExpression = GMFGenFactory.eINSTANCE.createValueExpression();
			valueExpression.setBody(metric.getRule().getBody());
			valueExpression.setLanguage(createGenLanguage(metric.getRule().getLanguage()));
			bindToProvider(metric.getRule(), valueExpression);
			genMetric.setRule(valueExpression);
		}
		
		GenRuleTarget genTarget = createRuleTarget(metric.getTarget());
		assert genTarget instanceof GenMeasurable;
		if(genTarget instanceof GenMeasurable) {
			genMetric.setTarget((GenMeasurable)genTarget);
		}
		myHistory.log(metric, genMetric);
		return genMetric;
	}
	
	private void bindToProvider(org.eclipse.gmf.mappings.ValueExpression expression, ValueExpression genExpression) {
		if(!myProcessedExpressions.add(expression)) {
			// Note: may have already been bound during transformation of reused node mapping
			return;
		}
		
		GenLanguage language = genExpression.getLanguage();
		if(language == null) {
			return;
		}
		GenExpressionProviderContainer providerContainer = getGenEssence().getExpressionProviders();
		if(providerContainer == null) {
			providerContainer = GMFGenFactory.eINSTANCE.createGenExpressionProviderContainer();
			getGenEssence().setExpressionProviders(providerContainer);
		}
		GenExpressionProviderBase provider = null;
		for (Iterator it = providerContainer.getProviders().iterator(); it.hasNext();) {
			GenExpressionProviderBase nextProvider = (GenExpressionProviderBase) it.next();	
			if(language.equals(nextProvider.getLanguage())) {
				provider = nextProvider;
				break;
			}
		}
		if(provider == null) {
			provider = createExpressionProvider(language);
			if(provider == null) {
				return;
			}
			providerContainer.getProviders().add(provider);			
		}
		provider.getExpressions().add(genExpression);
	}
	
	private GenExpressionProviderBase createExpressionProvider(GenLanguage language) {
		GenExpressionProviderBase newProvider = null;
		if(GenLanguage.JAVA_LITERAL.equals(language)) {
			newProvider = GMFGenFactory.eINSTANCE.createGenJavaExpressionProvider();			
		} else if(GenLanguage.OCL_LITERAL.equals(language)) {
			GenExpressionInterpreter oclProvider = GMFGenFactory.eINSTANCE.createGenExpressionInterpreter();
			oclProvider.setLanguage(language);
			oclProvider.getRequiredPluginIDs().addAll(Arrays.asList(new String[] {
				"org.eclipse.emf.ocl", //$NON-NLS-1$
				"org.eclipse.emf.query.ocl" //$NON-NLS-1$		
			}));
			newProvider = oclProvider;
		} else if(GenLanguage.REGEXP_LITERAL.equals(language) || GenLanguage.NREGEXP_LITERAL.equals(language)) {
			GenExpressionInterpreter regexpProvider = GMFGenFactory.eINSTANCE.createGenExpressionInterpreter();
			regexpProvider.setLanguage(language);
			newProvider = regexpProvider;
		}
		return newProvider;
	}
}@


1.98
log
@copy label properties
@
text
@@


1.97
log
@set design model facet for labels on pure design diagrams by default
@
text
@d477 2
@


1.96
log
@#146199 There should be no exceptions when child nodes are defined in pure design diagrams
@
text
@a203 1
		assert mapping.getDomainModel() != null;
d521 4
a592 1
		assert mapping.getDomainContext() != null;
@


1.95
log
@#145042 Introduce expression Language enumeration into gmfmap, gfmgen models  instead of plain text attribute
@
text
@d308 1
a308 1
		if (childNode.getModelFacet().getContainmentMetaFeature() == null) {
d314 1
a314 1
		if (childNode.getModelFacet().getChildMetaFeature() == null) {
@


1.94
log
@#145486 Ensure that edit helper names are unique after gmfgen model generation from gmfmap
@
text
@d60 1
d108 1
d725 1
a725 1
				nextGenValSpec.setLanguage(nextValSpec.getLangName());
d737 16
d759 1
a759 1
		modelElementSelector.setLanguage(constraint.getLangName());
d887 1
a887 1
			valueExpression.setLanguage(metric.getRule().getLangName());
d907 1
a907 1
		String language = genExpression.getLanguage();
d934 1
a934 1
	private GenExpressionProviderBase createExpressionProvider(String language) {
d936 1
a936 1
		if("java".equals(language)) { //$NON-NLS-1$
d938 1
a938 1
		} else if("ocl".equals(language)) { //$NON-NLS-1$
d946 1
a946 1
		} else if("regexp".equals(language) || "nregexp".equals(language)) { //$NON-NLS-1$ //$NON-NLS-2$
@


1.93
log
@#145042 Introduce expression Language enumeration into gmfmap, gfmgen models  instead of plain text attribute
@
text
@d243 1
a249 1
		setupElementType(genNode); 
d351 1
a359 1
		setupElementType(childNode); 
@


1.92
log
@[mgolubev] #144497 Preserve user-defined values for .gmfgen's dynamicTemplates, templateDirectory, creationWizardIconPath and iconPath options & #144304 Custom plugin name defined in gmfgen model is not retained on regeneration from gmfmap model
@
text
@d723 1
a723 1
				nextGenValSpec.setLanguage(nextValSpec.getLanguage());
d741 1
a741 1
		modelElementSelector.setLanguage(constraint.getLanguage());
d869 1
a869 1
			valueExpression.setLanguage(metric.getRule().getLanguage());
@


1.91
log
@#144518 Support negation of 'regexp' in gmf models expressions
@
text
@a68 1
import org.eclipse.gmf.codegen.gmfgen.GenPlugin;
d186 1
a186 1
	private GenPlugin getGenPlugin() {
a189 1
		return getGenEssence().getPlugin();
a215 5
		String pluginBaseName = "Diagram Editor";
		if (mapping.getDomainModel() != null) {
			pluginBaseName = mapping.getDomainModel().getName();
		}
		getGenPlugin().setName(pluginBaseName + " Plugin");
d225 2
@


1.90
log
@#136701 [GMFGen] GenDiagramElementTarget should allow to target more then one element
@
text
@d933 1
a933 1
		} else if("regexp".equals(language)) { //$NON-NLS-1$
@


1.89
log
@[mgolubev] #144203 Reconcile custom model id
@
text
@d16 1
d20 1
d133 1
d730 1
a730 1
				bindToProvider(nextGenValSpec);				
d747 1
a747 1
		bindToProvider(modelElementSelector);		
a816 1
				GenCommonBase genBase = null;
d818 1
d821 4
d827 8
a834 6
					genBase = myHistory.find(nm)[0]; // FIXME there may be few GenChildNodes corresponding to same mapping entry.
					// XXX @@see https://bugs.eclipse.org/bugs/show_bug.cgi?id=136701
				}
				
				assert genBase != null;				
				diagramTarget.setElement(genBase);
d875 1
a875 1
			bindToProvider(valueExpression);
d888 7
a894 2
	private void bindToProvider(ValueExpression expression) {
		String language = expression.getLanguage();
d918 1
a918 1
		provider.getExpressions().add(expression);
@


1.88
log
@#114175 allow to create diagram editor without domain model
@
text
@a211 3
		if (getGenEssence().getDomainGenModel() != null) {
			getGenEssence().setModelID(getGenEssence().getDomainGenModel().getModelName());
		}
@


1.87
log
@#139128 Preserve visualID of the .gmfgen model nodes on modifying .gmfmap model.
@
text
@d28 1
d202 1
a202 1
		if (myGenModelMatch == null) {
d218 5
a222 1
		getGenPlugin().setName(mapping.getDomainModel().getName() + " Plugin");
d625 4
d633 4
d641 4
d648 4
@


1.86
log
@#140887 Remove Child interface from GMFGraph.
Although the need to reference child figures persist, thus FigureHandle was introduced, to allow diagramElements to reference either *generateable* figures (Figure subclasses) or *just-use* figures (like CustomFigure and FigureAccessor).
Refactoring performed with #131365 "Mirror GMFGraph model when generating standalone figure plugin" in mind
@
text
@d136 1
a136 1
		this(drtHelper, namingStrategy, new InnerClassViewmapProducer());
d139 1
a139 1
	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, GenModelNamingMediator namingStrategy, ViewmapProducer viewmaps) {
d144 1
a144 1
		myVisualIDs = new NaiveIdentifierDispenser();
d379 1
a379 2
			GenCompartment compartmentGen = createGenCompartment(compartmentMapping);
			genNode.getCompartments().add(compartmentGen);
a400 2

			genNode.getLabels().add(label);
d404 1
a404 1
	private GenCompartment createGenCompartment(CompartmentMapping mapping) {
d409 1
a418 1

d427 1
a434 2

			gl.getLabels().add(label);
a436 1
		gl.setVisualID(myVisualIDs.get(gl));
d459 1
d471 1
d908 1
a908 1
}
@


1.85
log
@#114175 Allow a diagram definition to be mapped to zero or more domain models.
@
text
@d86 1
d459 1
a459 1
		if (mapping.getDiagramLabel().getFigure().getParent() == null) { // mapping.isExternal()
@


1.84
log
@#139127 Provide an option for labels to display node icon
@
text
@d635 3
@


1.83
log
@[mgolubev] #140186 XYLayoutEditPolicy should not be installed for editparts that have figure with non-XYLayout in the gmfgraph model
@
text
@d335 1
d468 1
@


1.82
log
@Refactoring
@
text
@d290 1
a290 1
		if (childNodeMapping.getChildren().size() > 0) {
d292 1
a292 1
			container.setListLayout(false);
@


1.81
log
@generate element types for label nodes
@
text
@d248 1
a355 2
		} else {
			setupElementType(childNode);
d357 1
a402 1
		setupElementType(genNode); // XXX does it make sense to do it for non-top-level nodes? Check gmfgen comments! 
@


1.80
log
@overriding recent changes introduced (along with fixing #133836) in GMFMap model, as it's merely a 'shortcut', quite frequent though. Still, adding few new concepts just for the sake of single usecase (I do admit it's popular) seems excessive to me.
GMFMap kept the same as old (no new notions introduced), GMFGraph got generalization from DiagramLabel to DiagramNode to make it possible to use DiagramLabels for NodeMappings (thus, it's possible to detect such nodes in the DGMT)
Tests added to make sure we generate correct genModel for both cases.
@
text
@d355 2
@


1.79
log
@#141340  Audit rule targeted to a metric definition is not registered as valid constraint
@
text
@a102 1
import org.eclipse.gmf.mappings.LabelFlavour;
a103 1
import org.eclipse.gmf.mappings.LabelNodeMapping;
d326 10
a335 6
		GenChildNode childNode;
		if (childNodeMapping instanceof LabelNodeMapping) {
			childNode = GMFGenFactory.eINSTANCE.createGenChildLabelNode();
			childNode.setViewmap(myViewmaps.create(((LabelNodeMapping) childNodeMapping).getDiagramLabel()));
			((GenChildLabelNode) childNode).setLabelModelFacet(createLabelModelFacet(((LabelNodeMapping) childNodeMapping)));
			((GenChildLabelNode) childNode).setLabelReadOnly(((LabelNodeMapping) childNodeMapping).isReadOnly());
d339 1
d353 3
a355 1
		processAbstractNode(childNodeMapping, childNode);
d359 12
d401 1
a401 15
		if (genNode.getModelFacet() != null) {
			MetamodelType metamodelType = (MetamodelType) myProcessedTypes.get(genNode.getModelFacet().getMetaClass());
			if (metamodelType == null) {
				// this is the first metaclass encounter; consider metamodel type definition
				genNode.setElementType(GMFGenFactory.eINSTANCE.createMetamodelType());
				myProcessedTypes.put(genNode.getModelFacet().getMetaClass(), genNode.getElementType());
			} else {
				// all subsequent encounters lead to specialization definitions
				SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
				specializationType.setMetamodelType(metamodelType);
				genNode.setElementType(specializationType);
			}
		} else {
			genNode.setElementType(GMFGenFactory.eINSTANCE.createNotationType());
		}
d440 1
a440 22
		if (gl.getModelFacet() != null) {
			if (gl.getModelFacet() instanceof TypeModelFacet) {
				GenClass metaClass = ((TypeModelFacet) gl.getModelFacet()).getMetaClass();
				MetamodelType metamodelType = (MetamodelType) myProcessedTypes.get(metaClass);
				if (metamodelType == null) {
					// this is the first metaclass encounter; consider metamodel type definition
					gl.setElementType(GMFGenFactory.eINSTANCE.createMetamodelType());
					myProcessedTypes.put(metaClass, gl.getElementType());
				} else {
					// all subsequent encounters lead to specialization definitions
					SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
					specializationType.setMetamodelType(metamodelType);
					gl.setElementType(specializationType);
				}
			} else {
				// ref-based link; specialize null
				SpecializationType specializationType = GMFGenFactory.eINSTANCE.createSpecializationType();
				gl.setElementType(specializationType);
			}
		} else {
			gl.setElementType(GMFGenFactory.eINSTANCE.createNotationType());
		}
d502 1
a502 1
	private LabelModelFacet createLabelModelFacet(LabelFlavour mapping) {
d522 43
d588 1
a588 6
		if (mapping instanceof LabelNodeMapping) {
			assert ((LabelNodeMapping) mapping).getDiagramLabel() != null;
			assert mapping.getDiagramNode() == null;
		} else {
			assert mapping.getDiagramNode() != null;
		}
@


1.78
log
@revert to gmfmap model compatibility
@
text
@d21 2
d31 1
d134 1
d148 1
d788 9
a796 1
			// TODO - no metrics logged in History return not initialized entity
d833 1
@


1.77
log
@#133836 Creating a child node without a label causes error
@
text
@a112 1
import org.eclipse.gmf.mappings.ShapeNodeMapping;
d238 1
a238 1
		genNode.setViewmap(myViewmaps.create(((ShapeNodeMapping) nme).getDiagramNode()));
d331 1
a331 1
			childNode.setViewmap(myViewmaps.create(((ShapeNodeMapping) childNodeMapping).getDiagramNode()));
d558 1
a558 3
		if (mapping instanceof ShapeNodeMapping) {
			assert ((ShapeNodeMapping) mapping).getDiagramNode() != null;
		} else if (mapping instanceof LabelNodeMapping) {
d560 3
@


1.76
log
@#138687 Add RegExpExpressionFactory JET template to the editor generation step
@
text
@d38 1
d100 1
d102 1
d113 1
d239 1
a239 1
		genNode.setViewmap(myViewmaps.create(nme.getDiagramNode()));
d324 10
a333 1
		final GenChildNode childNode = GMFGenFactory.eINSTANCE.createGenChildNode();
a339 1
		childNode.setViewmap(myViewmaps.create(childNodeMapping.getDiagramNode()));
d516 1
a516 1
	private LabelModelFacet createLabelModelFacet(LabelMapping mapping) {
d559 5
a563 1
		assert mapping.getDiagramNode() != null;
@


1.75
log
@#138464 Support EAttribute based target in AuditRule element
@
text
@d847 5
a851 1
		}		
@


1.74
log
@#136877 Provide inital offset from the host link for the link label
@
text
@d44 1
d94 1
d769 8
@


1.73
log
@#131270 Duplicated tool entries when same tool definition is referenced from gmfmap.
@
text
@d66 1
d79 1
d479 11
@


1.72
log
@#128404 palette factory ignores bundle name
@
text
@a19 1
import org.eclipse.core.runtime.Path;
a29 1
import org.eclipse.gmf.codegen.gmfgen.EntryBase;
a65 1
import org.eclipse.gmf.codegen.gmfgen.LinkEntry;
a68 1
import org.eclipse.gmf.codegen.gmfgen.NodeEntry;
a71 1
import org.eclipse.gmf.codegen.gmfgen.ToolGroup;
d82 1
a105 1
import org.eclipse.gmf.mappings.ToolOwner;
a106 4
import org.eclipse.gmf.tooldef.AbstractTool;
import org.eclipse.gmf.tooldef.BundleImage;
import org.eclipse.gmf.tooldef.CreationTool;
import org.eclipse.gmf.tooldef.ToolContainer;
d123 1
d136 1
d179 1
a179 1
	private Palette getGenPalette() {
d194 4
d232 1
a232 1
		handleNodeTool(nme, genNode);
d329 1
a329 1
		handleNodeTool(childNodeMapping, childNode);
d404 1
a404 7
		if (lme.getTool() instanceof CreationTool) {
			LinkEntry le = GMFGenFactory.eINSTANCE.createLinkEntry();
			le.setEntryID(myVisualIDs.get(le));
			findToolGroup(lme.getTool()).getLinkTools().add(le);
			le.getGenLink().add(gl);
			setupCommonToolEntry(le, lme.getTool());
		}
a528 23
	private void handleNodeTool(ToolOwner nme, GenNode genNode) {
		if (nme.getTool() != null && nme.getTool() instanceof CreationTool) {
			// XXX handle other tool types (action, whatever)
			NodeEntry ne = GMFGenFactory.eINSTANCE.createNodeEntry();
			ne.setEntryID(myVisualIDs.get(ne));
			findToolGroup(nme.getTool()).getNodeTools().add(ne);
			ne.getGenNode().add(genNode);
			setupCommonToolEntry(ne, nme.getTool());
		}
	}

	private void setupCommonToolEntry(EntryBase te, AbstractTool tool) {
		te.setTitleKey(tool.getTitle() == null ? "" : tool.getTitle()); // same at (*1*)
		te.setDescriptionKey(tool.getDescription());
		// FIXME need to change this once better tooling definition is in place.
		// FIXME update gmfgen model to explicitly understand images from different bundles
		if (tool.getLargeIcon() instanceof BundleImage) {
			te.setLargeIconPath(constructIconPath((BundleImage) tool.getLargeIcon()));
		}
		if (tool.getSmallIcon() instanceof BundleImage) {
			te.setSmallIconPath(constructIconPath((BundleImage) tool.getSmallIcon()));
		}
	}
a529 37
	private static String constructIconPath(BundleImage icon) {
		assert icon != null;
		if (icon.getPath() == null || icon.getPath().trim().length() == 0) {
			// no idea why to go on
			return null;
		}
		if (icon.getBundle() == null || icon.getBundle().trim().length() == 0) {
			// Plugin.javajet#findImageDescriptor treats relative paths as bundle-local
			return new Path(icon.getPath()).makeRelative().toString();
		} else {
			// makeAbsolute on bundle segment only to avoid unwinding of ".." 
			return new Path(icon.getBundle()).makeAbsolute().append(icon.getPath()).toString();
		}
	}

	/**
	 * TODO initialize palette with set of groups known from Mapping. Perhaps, don't even 
	 * create missed group in that case.
	 * FIXME and don't rely on title as unique key
	 */
	private ToolGroup findToolGroup(AbstractTool tool) {
		assert tool.eContainer() != null;
		ToolContainer tc = (ToolContainer) tool.eContainer();
		String groupName = tc.getTitle() == null ? "" : tc.getTitle(); // same at (*1*)
		for (Iterator it = getGenPalette().getGroups().iterator(); it.hasNext();) {
			ToolGroup next = (ToolGroup) it.next();
			if (groupName.equals(next.getTitleKey())) {
				return next;
			}
		}
		ToolGroup tg = GMFGenFactory.eINSTANCE.createToolGroup();
		tg.setEntryID(myVisualIDs.get(tg));
		getGenPalette().getGroups().add(tg);
		setupCommonToolEntry(tg, tc);
		return tg;
	}
	
@


1.71
log
@refactor to facilitate reuse in codegen.lite
@
text
@d20 1
d552 2
a553 1
		// FIXME need to change this once better tooling definition is in place. 
d555 1
a555 2
			// XXX assume same bundle
			te.setLargeIconPath(((BundleImage) tool.getLargeIcon()).getPath());
d558 16
a573 2
			// XXX assume same bundle
			te.setSmallIconPath(((BundleImage) tool.getSmallIcon()).getPath());
@


1.70
log
@#129552 correctly handle reuse of node mappings with distinct children references as well
@
text
@d125 1
a125 1
	private final ViewmapProducer myViewmaps = new InnerClassViewmapProducer();
d133 5
d140 1
@


1.69
log
@#129552 correctly handle reuse of node mappings with distinct containment references
@
text
@d266 1
a266 1
				if (matchContainmentFeatures(childNodeRef, alreadyKnownChildren[i])) {
d284 1
a284 1
	 * with different containment reference. 
a285 1
	 * XXX should we also check childrenFeature????
d287 3
a289 2
	private static boolean matchContainmentFeatures(ChildReference childNodeRef, GenChildNode childNode) {
		EStructuralFeature containmentFeature;
d291 1
a291 1
			containmentFeature = null;
d293 2
a294 1
			containmentFeature = childNode.getModelFacet().getContainmentMetaFeature().getEcoreFeature();
d296 12
a307 2
		// seems legal to use == because features should came from the same model
		return containmentFeature == childNodeRef.getContainmentFeature();
@


1.68
log
@[#134511] common access to expressions of different languages
@
text
@a256 1
		assert childNodeMapping.getDiagramNode() != null;
d259 2
a260 3
		if (myHistory.isKnownChildNode(childNodeMapping)) {
			// we can't reuse top-level GenNodes
			childNode = myHistory.findChildNode(childNodeMapping);
d262 1
a262 3
			childNode = GMFGenFactory.eINSTANCE.createGenChildNode();
			myHistory.log(childNodeMapping, childNode);
			getGenDiagram().getChildNodes().add(childNode);
d264 10
a273 11
			childNode.setModelFacet(createModelFacet(childNodeRef));
			
			childNode.setDiagramRunTimeClass(findRunTimeClass(childNodeMapping));
			childNode.setViewmap(myViewmaps.create(childNodeMapping.getDiagramNode()));
			childNode.setVisualID(myVisualIDs.get(childNode));

			// set class names
			myNamingStrategy.feed(childNode, childNodeMapping);

			handleNodeTool(childNodeMapping, childNode);
			processAbstractNode(childNodeMapping, childNode);
d281 37
d779 2
a780 1
					genBase = myHistory.find(nm);
@


1.67
log
@#126200 register element types in xml
@
text
@d14 1
d48 3
d654 1
d670 2
a671 1
		modelElementSelector.setLanguage(constraint.getLanguage());		
d776 1
d787 44
@


1.66
log
@#134085 Implement metrics transformation from gmfmap to gmfgen model
@
text
@d15 1
d66 1
d70 1
d124 1
d201 7
d313 15
d372 23
@


1.65
log
@respect read-only attribute
@
text
@d24 1
d51 3
d58 1
d71 1
a80 1
import org.eclipse.gmf.mappings.Auditable;
d96 2
d221 16
d644 5
a648 1
			genAudit.setTarget(createRuleTarget(audit.getTarget()));
d670 1
a670 1
	private GenAuditable createRuleTarget(Auditable ruleTarget) {		
d708 20
a727 4

	protected void process(AuditContainer audits) {
		if(audits != null) {
			getGenEssence().setAudits(createGenAuditContainer(audits));	
d729 1
@


1.64
log
@#130715 Use default label text defined in gmfgraph model
@
text
@d346 1
@


1.63
log
@[rdvorak] #114196 Allow for the definition of diagram validation rules
@
text
@a62 1
import org.eclipse.gmf.codegen.gmfgen.TextLabelModelFacet;
a371 6
		String text = mapping.getText();
		if (text != null && text.length() > 0) {
			TextLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createTextLabelModelFacet();
			modelFacet.setText(text);
			return modelFacet;
		}
a374 5
			String defaultText = mapping.getDefaultText();
			if (defaultText == null || defaultText.length() == 0) {
				defaultText = "<...>";
			}
			modelFacet.setDefaultText(defaultText);
d388 1
a388 1
		throw new IllegalArgumentException("Model facet of a label is undefined " + mapping);
@


1.62
log
@#114175 for links - mapping model
@
text
@d33 2
a53 1
import org.eclipse.gmf.codegen.gmfgen.GenRuleTarget;
d76 2
a94 1
import org.eclipse.gmf.mappings.RuleTarget;
d654 1
a654 1
	private GenRuleTarget createRuleTarget(RuleTarget ruleTarget) {		
d683 4
@


1.61
log
@#130009 Enable audit rules on diagram (notation model) elements in gmfmap model
@
text
@d476 3
a478 1
		assert linkMapping.getLinkMetaFeature() != null;
d528 1
a528 1
		} else {
d533 1
@


1.60
log
@override ElementTypeIconProvider to enable our icons
@
text
@d35 1
d39 1
d50 1
d52 1
d79 2
d91 2
a191 8
		
		// process audit rules
		if(mapping.eContainer() != null) {
			AuditContainer audits = ((Mapping)mapping.eContainer()).getAudits();
			if(audits != null) {
				getGenEssence().setAudits(createGenAuditContainer(audits));
			}
		}
d211 1
d221 1
a221 1
		if (myHistory.isKnown(childNodeMapping)) {
d223 1
a223 1
			childNode = myHistory.find(childNodeMapping);
d330 2
d627 1
a627 3
			GenDomainElementTarget target = GMFGenFactory.eINSTANCE.createGenDomainElementTarget();
			target.setElement(findGenClass(audit.getTarget()));
			genAudit.setTarget(target);
d648 41
@


1.59
log
@corrected whose superclasses are checked
@
text
@d57 1
d180 1
@


1.58
log
@use built-in superType check instead of custom code
@
text
@d488 1
a488 1
			isOk = domainElement.isSuperTypeOf(attrContainer);
@


1.57
log
@Correcting "isListLayout" property setting.
@
text
@a13 1
import java.util.ArrayList;
a23 1
import org.eclipse.emf.ecore.EClassifier;
d484 1
a484 3
		final ArrayList context = new ArrayList();
		context.add(labelMapping.getMapEntry().getDomainContext()); 
		context.addAll(labelMapping.getMapEntry().getDomainContext().getEAllSuperTypes());
d487 2
a488 2
			EClassifier attrContainer = ((EAttribute) it.next()).getEContainingClass();
			isOk = context.contains(attrContainer);
@


1.56
log
@[rdvorak] #127446 Enable audit rules on diagram (notation model) elements in gmfgen model
@
text
@d239 4
a242 5
			
			if (childNodeMapping.getChildren().size() > 0) {
				// TODO just layout from childNodeMapping.getDiagramNode()
				container.setListLayout(false);
			}
@


1.55
log
@#128774 Keep history of mappings during transformation
@
text
@d40 1
d627 3
a629 1
			genAudit.setTarget(findGenClass(audit.getTarget()));
@


1.54
log
@#127464 unlimited hierarchies in the GMFMap with possible reuse of mapping entries
@
text
@d65 1
d100 1
a100 1
	private GenModelMatcher myGenModelMatch;
d104 1
d112 1
d169 1
a211 1
	// FIXME keep track of processed ChildReferences and don't create two identical for referenced
d218 14
a231 6
		GenChildNode childNode = GMFGenFactory.eINSTANCE.createGenChildNode();
		childNode.setModelFacet(createModelFacet(childNodeRef));
		
		childNode.setDiagramRunTimeClass(findRunTimeClass(childNodeMapping));
		childNode.setViewmap(myViewmaps.create(childNodeMapping.getDiagramNode()));
		childNode.setVisualID(myVisualIDs.get(childNode));
d233 2
a234 2
		// set class names
		myNamingStrategy.feed(childNode, childNodeMapping);
d236 8
a244 8
		getGenDiagram().getChildNodes().add(childNode);
		handleNodeTool(childNodeMapping, childNode);
		processAbstractNode(childNodeMapping, childNode);
		
		if (childNodeMapping.getChildren().size() > 0) {
			// TODO just layout from childNodeMapping.getDiagramNode()
			container.setListLayout(false);
		}
@


1.53
log
@#129047 get rid of explicit edit/label features, use generic and feature-rich LabelMapping instead.
@
text
@a67 1
import org.eclipse.gmf.mappings.AbstractNodeMapping;
d71 1
a71 1
import org.eclipse.gmf.mappings.ChildNodeMapping;
d83 1
d86 1
d189 4
a192 3
	protected void process(NodeMapping nme) {
		assertAbstractNodeMapping(nme);
		assert nme.getDiagramNode() != null;
d197 1
a197 1
		genNode.setModelFacet(createModelFacet(nme));
d208 5
a212 2
	private void process(ChildNodeMapping childNodeMapping, GenChildContainer container) {
		assertAbstractNodeMapping(childNodeMapping);
d216 1
a216 1
		childNode.setModelFacet(createModelFacet(childNodeMapping));
d230 1
a230 1
		if (childNodeMapping.getChildMappings().size() > 0) {
d236 1
a236 1
	private void processAbstractNode(AbstractNodeMapping mapping, GenNode genNode) {
d238 1
a238 1
		for (Iterator it = mapping.getCompartmentMappings().iterator(); it.hasNext();) {
d245 2
a246 2
		for (Iterator it = mapping.getChildMappings().iterator(); it.hasNext();) {
			ChildNodeMapping childNodeMapping = (ChildNodeMapping) it.next();
d248 1
a248 1
			CompartmentMapping compartmentMapping = childNodeMapping.getCompartment();
d255 1
a255 1
			process(childNodeMapping, genChildContainer);
a390 4
	private GenClass findRunTimeClass(ChildNodeMapping childNodeMapping) {
		return myDRTHelper.get(childNodeMapping);
	}

d454 1
a454 1
	private void assertAbstractNodeMapping(AbstractNodeMapping mapping) {
d456 1
d498 4
a501 3
	private TypeModelFacet createModelFacet(AbstractNodeMapping anm) {
		TypeModelFacet typeModelFacet = setupModelFacet(anm.getDomainContext(), anm.getContainmentFeature(), null);
		return setupAux(typeModelFacet, anm.getDomainSpecialization(), anm.getDomainInitializer());
@


1.52
log
@[rdvorak] #127700 Rename genmodel::ModelElementSelector as a generic GenConstraint element
@
text
@d14 1
d62 2
a63 1
import org.eclipse.gmf.codegen.gmfgen.Viewmap;
a79 1
import org.eclipse.gmf.mappings.LinkLabelMapping;
d82 1
a82 1
import org.eclipse.gmf.mappings.NodeLabelMapping;
a196 14
		if (nme.getEditFeature() != null) {
			FeatureLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureLabelModelFacet();
			modelFacet.setMetaFeature(findGenFeature(nme.getEditFeature()));
			GenNodeLabel label = GMFGenFactory.eINSTANCE.createGenNodeLabel();
			label.setModelFacet(modelFacet);
			label.setVisualID(myVisualIDs.get(label));
			label.setDiagramRunTimeClass(getNodeLabelRunTimeClass());
			label.setViewmap(createLabelViewmap());

			// set class names
			myNamingStrategy.feed(label, nme, null);

			genNode.getLabels().add(label);
		}
a219 16
		if (childNodeMapping.getEditFeature() != null) {
			FeatureLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureLabelModelFacet();
			modelFacet.setMetaFeature(findGenFeature(childNodeMapping.getEditFeature()));
			modelFacet.setDefaultText("<...>");
			GenNodeLabel label = GMFGenFactory.eINSTANCE.createGenNodeLabel();
			label.setModelFacet(modelFacet);
			label.setVisualID(myVisualIDs.get(label));
			label.setDiagramRunTimeClass(getNodeLabelRunTimeClass());
			label.setViewmap(createLabelViewmap());

			// set class names
			myNamingStrategy.feed(label, childNodeMapping, null);

			childNode.getLabels().add(label);
		}

d253 1
a253 1
			NodeLabelMapping labelMapping = (NodeLabelMapping) labels.next();
d257 1
a257 1
			myNamingStrategy.feed(label, mapping, labelMapping);
d282 1
a282 2
		assert lme.getDiagramLink() != null;
		assert lme.getLinkMetaFeature() != null;
a292 15
		EAttribute editFeature = lme.getLabelEditFeature();
		if (editFeature != null) {
			FeatureLabelModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureLabelModelFacet();
			modelFacet.setMetaFeature(findGenFeature(lme.getLabelEditFeature()));
			GenLinkLabel label = GMFGenFactory.eINSTANCE.createGenLinkLabel();
			label.setModelFacet(modelFacet);
			label.setVisualID(myVisualIDs.get(label));
			label.setDiagramRunTimeClass(getLinkLabelRunTimeClass());
			label.setViewmap(createLabelViewmap());

			// set class names
			myNamingStrategy.feed(label, lme, null);

			gl.getLabels().add(label);
		}
d294 1
a294 1
			LinkLabelMapping labelMapping = (LinkLabelMapping) labels.next();
d298 1
a298 1
			myNamingStrategy.feed(label, lme, labelMapping);
d315 1
a315 1
	private GenNodeLabel createNodeLabel(GenNode node, NodeLabelMapping mapping) {
d317 1
a317 1
		if (mapping.isExternal()) {
d324 1
a324 1
		label.setViewmap(createLabelViewmap());
d329 1
a329 1
	private GenLinkLabel createLinkLabel(GenLink link, LinkLabelMapping mapping) {
d333 1
a333 1
		label.setViewmap(createLabelViewmap());
d335 4
a338 1
		label.setAlignment(getLinkLabelAlignment(mapping.getAlignment()));
d342 1
a342 1
	private LinkLabelAlignment getLinkLabelAlignment(org.eclipse.gmf.mappings.LinkLabelAlignment alignment) {
d344 4
a347 4
		case org.eclipse.gmf.mappings.LinkLabelAlignment.SOURCE: return LinkLabelAlignment.SOURCE_LITERAL;
		case org.eclipse.gmf.mappings.LinkLabelAlignment.MIDDLE: return LinkLabelAlignment.MIDDLE_LITERAL;
		case org.eclipse.gmf.mappings.LinkLabelAlignment.TARGET: return LinkLabelAlignment.TARGET_LITERAL;
		default: throw new IllegalStateException();
a381 8
	/**
	 * FIXME Use child from gmfgraph with dedicated figure
	 * @@return
	 */
	private Viewmap createLabelViewmap() {
		return DefaultViewmapProducer.createLabelViewmap();
	}

d402 1
a402 13
	private GenClass getNodeLabelRunTimeClass() {
		return myDRTHelper.getNodeLabelDefault();
	}

	private GenClass getLinkLabelRunTimeClass() {
		return myDRTHelper.getLinkLabelDefault();
	}

	private GenClass findRunTimeClass(NodeLabelMapping mapping) {
		return myDRTHelper.get(mapping);
	}

	private GenClass findRunTimeClass(LinkLabelMapping mapping) {
d455 15
a469 1
		assert checkDirectEditAttrValidity(mapping);
d472 8
a479 3
	private boolean checkDirectEditAttrValidity(AbstractNodeMapping nme) {
		if (nme.getEditFeature() == null) {
			return true;
d481 1
a481 2
		EClassifier attrContainer = nme.getEditFeature().getEContainingClass();
		return attrContainer == nme.getDomainContext() || nme.getDomainContext().getEAllSuperTypes().contains(attrContainer);
@


1.51
log
@#127461 add label diagram element in gmfgraph model
@
text
@d37 1
a54 1
import org.eclipse.gmf.codegen.gmfgen.ModelElementSelector;
a60 1
import org.eclipse.gmf.codegen.gmfgen.ValueExpression;
d570 1
a570 1
			genConstraints.setSourceEnd(createExpression(sourceConstraint.getBody(), sourceConstraint.getLanguage()));
d574 1
a574 1
			genConstraints.setTargetEnd(createExpression(targetConstraint.getBody(), targetConstraint.getLanguage()));
d593 1
a593 1
			typeModelFacet.setModelElementSelector(createModelElementSelector(spec));
d621 3
a623 2
	private ValueExpression createExpression(String body, String lang) {
		if(body == null) {
d626 3
a628 10
		ValueExpression valueExpression = GMFGenFactory.eINSTANCE.createValueExpression();
		valueExpression.setBody(body);
		valueExpression.setLanguage(lang);
		return valueExpression;
	}
	
	private static ModelElementSelector createModelElementSelector(Constraint metaElementConstraint) {
		ModelElementSelector modelElementSelector = GMFGenFactory.eINSTANCE.createModelElementSelector();
		modelElementSelector.setBody(metaElementConstraint.getBody());
		modelElementSelector.setLanguage(metaElementConstraint.getLanguage());		
d660 1
a660 1
			genAudit.setRule(createExpression(rule.getBody(), rule.getLanguage()));
@


1.50
log
@#127461 Support multiple labels definition in the mapping model
@
text
@d369 1
a369 1
		label.setDiagramRunTimeClass(getNodeLabelRunTimeClass());
d378 1
a378 1
		label.setDiagramRunTimeClass(getLinkLabelRunTimeClass());
d461 8
@


1.49
log
@GenEditorViewer incapsulates all Eclipse's IEditorPart-related info
@
text
@d27 1
d50 1
d52 1
d57 1
d77 1
d79 1
d82 1
d207 1
a207 1
			myNamingStrategy.feed(label, nme);
d245 1
a245 1
			myNamingStrategy.feed(label, childNodeMapping);
d282 9
d335 10
a344 1
			myNamingStrategy.feed(label, lme);
d361 64
@


1.48
log
@constant used throughout templates to identify diagram (genModel.getModelName) was extracted as explicit attribute
packagePrefix added
@
text
@d123 4
@


1.47
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d156 3
@


1.46
log
@#111949 Provide a possibility to invoke inplace for inner elements with empty name
@
text
@d37 1
d90 1
a90 1
	private GenDiagram myGenModel;
d115 2
a116 2
	public GenDiagram getResult() {
		return getGenDiagram();
d119 1
a119 1
	private GenDiagram getGenDiagram() {
d121 1
a121 1
			myGenModel = GMFGenFactory.eINSTANCE.createGenDiagram();
d126 7
d134 2
a135 2
		if (getGenDiagram().getPlugin() == null) {
			getGenDiagram().setPlugin(GMFGenFactory.eINSTANCE.createGenPlugin());
d137 1
a137 1
		return getGenDiagram().getPlugin();
d154 2
a155 1
		getGenDiagram().setDomainMetaModel(findGenPackage(mapping.getDomainModel()));
d169 1
a169 1
				getGenDiagram().setAudits(createGenAuditContainer(audits));
@


1.45
log
@refactor feature model facet; use distinct feature-based model facets for links and labels
@
text
@d214 1
@


1.44
log
@GenDiagram "slicing" goes on and this time attributes related to plugin activator class were moved into separate entity
@
text
@d28 2
a29 1
import org.eclipse.gmf.codegen.gmfgen.FeatureModelFacet;
d175 1
a175 1
			FeatureModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureModelFacet();
d212 1
a212 1
			FeatureModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureModelFacet();
d293 1
a293 1
			FeatureModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureModelFacet();
d443 1
a443 1
			FeatureModelFacet mf = GMFGenFactory.eINSTANCE.createFeatureModelFacet();
@


1.43
log
@visual id construction was factored out
@
text
@d44 1
d124 7
d149 1
a149 1
		getGenDiagram().setPluginName(mapping.getDomainModel().getName() + " Plugin");
@


1.42
log
@#124466
entryID attribute introduced to avoid duplicate names generation
@
text
@d57 2
a86 11
	private static final int CANVAS_COUNT_BASE = 79;
	private static final int NODE_COUNT_BASE = 1000;
	private static final int CHILD_COUNT_BASE = 2000;
	private static final int LINK_COUNT_BASE = 3000;
	private static final int LABEL_COUNT_BASE = 4000;
	private static final int COMPARTMENT_COUNT_BASE = 5000;
	
	private static final int TOOL_GROUP_COUNT_BASE = 0;
	private static final int TOOL_NODE_COUNT_BASE = 1000;
	private static final int TOOL_LINK_COUNT_BASE = 2000;

d91 1
a92 8
	private int myNodeCount = 0;
	private int myLinkCount = 0;
	private int myChildCount = 0;
	private int myLabelCount = 0;
	private int myCompartmentCount = 0;
	private int myToolGroupCount = 0;
	private int myToolNodeCount = 0;
	private int myToolLinkCount = 0;
d98 1
d140 1
a140 1
		getGenDiagram().setVisualID(CANVAS_COUNT_BASE);
d164 1
a164 1
		genNode.setVisualID(NODE_COUNT_BASE + (++myNodeCount));
d170 1
a170 1
			label.setVisualID(LABEL_COUNT_BASE + (++myLabelCount));
d197 1
a197 1
		childNode.setVisualID(CHILD_COUNT_BASE + (++myChildCount ));
d207 1
a207 1
			label.setVisualID(LABEL_COUNT_BASE + (++myLabelCount));
d256 1
a256 1
		childCompartment.setVisualID(COMPARTMENT_COUNT_BASE + (++myCompartmentCount));
d277 1
a277 1
			le.setEntryID(TOOL_LINK_COUNT_BASE + (++myToolLinkCount));
d288 1
a288 1
			label.setVisualID(LABEL_COUNT_BASE + (++myLabelCount));
d298 1
a298 1
		gl.setVisualID(LINK_COUNT_BASE + (++myLinkCount));
d350 1
a350 1
			ne.setEntryID(TOOL_NODE_COUNT_BASE + (++myToolNodeCount));
d387 1
a387 1
		tg.setEntryID(TOOL_GROUP_COUNT_BASE + (++myToolGroupCount));
@


1.41
log
@#124413
Allowing infinite hierarchy of GenChildNodes
@
text
@d91 4
d106 3
d292 1
d365 1
a374 1

d402 1
@


1.40
log
@refactor NamingStrategy: extracted all className setters to provisional NamingMediator
@
text
@a26 2
import org.eclipse.gmf.codegen.gmfgen.CompartmentLayoutKind;
import org.eclipse.gmf.codegen.gmfgen.CompartmentPlacementKind;
d45 1
d168 2
a169 2
		GenNode genNode = GMFGenFactory.eINSTANCE.createGenNode();
		getGenDiagram().getNodes().add(genNode);
a205 1
		childNode.setChildContainersPlacement(CompartmentPlacementKind.TOOLBAR_LITERAL);
d226 1
d232 1
a232 5
			if (container instanceof GenNode) {
				((GenNode) container).setChildContainersPlacement(CompartmentPlacementKind.FLOW_LITERAL);
			} else if (container instanceof GenCompartment) {
				((GenCompartment) container).setLayoutKind(CompartmentLayoutKind.XY_LITERAL);
			}
d263 1
a268 1
		childCompartment.setLayoutKind(CompartmentLayoutKind.TOOLBAR_LITERAL);
@


1.39
log
@[rdvorak] #123656 Added message and description to audit rule
@
text
@a35 1
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
d58 1
a95 1
	private final NamingStrategy myNamingStrategy;
d103 1
d105 1
a105 1
	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, NamingStrategy namingStrategy) {
d154 1
a154 4
		getGenDiagram().setNotationViewFactoryClassName(myNamingStrategy.createCanvasClassName(mapping, GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
		getGenDiagram().setEditPartClassName(myNamingStrategy.createCanvasClassName(mapping, GenCommonBase.EDIT_PART_SUFFIX));
		getGenDiagram().setItemSemanticEditPolicyClassName(myNamingStrategy.createCanvasClassName(mapping, GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
		getGenDiagram().setCanonicalEditPolicyClassName(myNamingStrategy.createCanvasClassName(mapping, GenChildContainer.CANONICAL_EDIT_POLICY_SUFFIX));
d184 1
a184 3
			label.setNotationViewFactoryClassName(myNamingStrategy.createNodeLabelClassName(nme, nme.getEditFeature(), GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
			label.setEditPartClassName(myNamingStrategy.createNodeLabelClassName(nme, nme.getEditFeature(), GenCommonBase.EDIT_PART_SUFFIX));
			label.setItemSemanticEditPolicyClassName(myNamingStrategy.createNodeLabelClassName(nme, nme.getEditFeature(), GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
d192 1
a192 5
		genNode.setNotationViewFactoryClassName(myNamingStrategy.createNodeClassName(nme, GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
		genNode.setEditPartClassName(myNamingStrategy.createNodeClassName(nme, GenCommonBase.EDIT_PART_SUFFIX));
		genNode.setItemSemanticEditPolicyClassName(myNamingStrategy.createNodeClassName(nme, GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
		genNode.setCanonicalEditPolicyClassName(myNamingStrategy.createNodeClassName(nme, GenChildContainer.CANONICAL_EDIT_POLICY_SUFFIX));
		genNode.setGraphicalNodeEditPolicyClassName(myNamingStrategy.createNodeClassName(nme, GenNode.GRAPHICAL_NODE_EDIT_POLICY_SUFFIX));
d210 1
a210 5
		childNode.setNotationViewFactoryClassName(myNamingStrategy.createChildNodeClassName(childNodeMapping, GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
		childNode.setEditPartClassName(myNamingStrategy.createChildNodeClassName(childNodeMapping, GenCommonBase.EDIT_PART_SUFFIX));
		childNode.setItemSemanticEditPolicyClassName(myNamingStrategy.createChildNodeClassName(childNodeMapping, GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
		childNode.setCanonicalEditPolicyClassName(myNamingStrategy.createChildNodeClassName(childNodeMapping, GenChildContainer.CANONICAL_EDIT_POLICY_SUFFIX));
		childNode.setGraphicalNodeEditPolicyClassName(myNamingStrategy.createChildNodeClassName(childNodeMapping, GenNode.GRAPHICAL_NODE_EDIT_POLICY_SUFFIX));
d222 1
a222 3
			label.setNotationViewFactoryClassName(myNamingStrategy.createNodeLabelClassName(childNodeMapping, childNodeMapping.getEditFeature(), GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
			label.setEditPartClassName(myNamingStrategy.createNodeLabelClassName(childNodeMapping, childNodeMapping.getEditFeature(), GenCommonBase.EDIT_PART_SUFFIX));
			label.setItemSemanticEditPolicyClassName(myNamingStrategy.createNodeLabelClassName(childNodeMapping, childNodeMapping.getEditFeature(), GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
d277 1
a277 4
		childCompartment.setNotationViewFactoryClassName(myNamingStrategy.createCompartmentClassName(mapping.getParentNodeMapping(), compartment, GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
		childCompartment.setEditPartClassName(myNamingStrategy.createCompartmentClassName(mapping.getParentNodeMapping(), compartment, GenCommonBase.EDIT_PART_SUFFIX));
		childCompartment.setItemSemanticEditPolicyClassName(myNamingStrategy.createCompartmentClassName(mapping.getParentNodeMapping(), compartment, GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
		childCompartment.setCanonicalEditPolicyClassName(myNamingStrategy.createCompartmentClassName(mapping.getParentNodeMapping(), compartment, GenChildContainer.CANONICAL_EDIT_POLICY_SUFFIX));
d305 1
a305 5
			label.setNotationViewFactoryClassName(myNamingStrategy.createLinkLabelClassName(lme, lme.getLabelEditFeature(), GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
			label.setTextNotationViewFactoryClassName(myNamingStrategy.createLinkLabelClassName(lme, lme.getLabelEditFeature(), GenLinkLabel.TEXT_NOTATION_VIEW_FACTORY_SUFFIX));
			label.setEditPartClassName(myNamingStrategy.createLinkLabelClassName(lme, lme.getLabelEditFeature(), GenCommonBase.EDIT_PART_SUFFIX));
			label.setTextEditPartClassName(myNamingStrategy.createLinkLabelClassName(lme, lme.getLabelEditFeature(), GenLinkLabel.TEXT_EDIT_PART_SUFFIX));
			label.setItemSemanticEditPolicyClassName(myNamingStrategy.createLinkLabelClassName(lme, lme.getLabelEditFeature(), GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
d313 1
a313 3
		gl.setNotationViewFactoryClassName(myNamingStrategy.createLinkClassName(lme, GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
		gl.setEditPartClassName(myNamingStrategy.createLinkClassName(lme, GenCommonBase.EDIT_PART_SUFFIX));
		gl.setItemSemanticEditPolicyClassName(myNamingStrategy.createLinkClassName(lme, GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
a371 3
		// FIXME - there's no need in createMethodName.
		te.setCreateMethodName(myNamingStrategy.createCreationMethodName(tool));

@


1.38
log
@#114197 - tooling definition in place
@
text
@d558 1
a558 1

d573 2
@


1.37
log
@Method renamed. Clearly (hah :) express intention of the method - it's merely describes surroundings/location of the element in the domain, rather then represent a metaClass
@
text
@d29 1
a52 1
import org.eclipse.gmf.codegen.gmfgen.ToolEntry;
a65 1
import org.eclipse.gmf.mappings.CreationTool;
d74 5
a78 1
import org.eclipse.gmf.mappings.Tool;
d310 1
a310 2
			le.setCreateMethodName(myNamingStrategy.createToolCreationMethodName(lme));
			setupCommonToolEntry(le, lme.getTool(), lme.getDomainMetaElement() != null ? lme.getDomainMetaElement().getName() : lme.getLinkMetaFeature().getName());
d382 1
a382 1
	private void handleNodeTool(AbstractNodeMapping nme, GenNode genNode) {
d388 1
a388 2
			ne.setCreateMethodName(myNamingStrategy.createToolCreationMethodName(nme));
			setupCommonToolEntry(ne, nme.getTool(), nme.getDomainContext().getName());
d392 7
a398 1
	private void setupCommonToolEntry(ToolEntry te, Tool tool, String elementName) {
d400 8
a407 4
		te.setLargeIconPath(null);
		te.setSmallIconPath(null);
		te.setTitleKey(elementName);
		te.setDescriptionKey(elementName);
d413 1
d415 4
a418 3
	private ToolGroup findToolGroup(Tool tool) {
		assert tool.getGroup() != null;
		String groupName = tool.getGroup().getName() == null ? "" : tool.getGroup().getName();
d427 1
a427 2
		tg.setTitleKey(groupName);
		tg.setCreateMethodName(myNamingStrategy.createToolGroupCreationMethodName(tool.getGroup()));
@


1.36
log
@actually, there's no need for getDomainMetaClass in the Link, and its former uses in namingStrategy/DGMT prove that.
@
text
@d387 1
a387 1
			setupCommonToolEntry(ne, nme.getTool(), nme.getDomainMetaClass().getName());
d420 1
a420 1
		assert mapping.getDomainMetaClass() != null;
d429 1
a429 1
		return attrContainer == nme.getDomainMetaClass() || nme.getDomainMetaClass().getEAllSuperTypes().contains(attrContainer);
d445 1
a445 1
		TypeModelFacet typeModelFacet = setupModelFacet(anm.getDomainMetaClass(), anm.getContainmentFeature(), null);
@


1.35
log
@[rdvorak] #123279 audits definition in gmfmap
@
text
@d308 1
a308 1
			setupCommonToolEntry(le, lme.getTool(), lme.getDomainMetaClass() != null ? lme.getDomainMetaClass().getName() : lme.getLinkMetaFeature().getName());
@


1.34
log
@New plugin with IFigure codegeneration to support #114177 (graphical definition model) was added
@
text
@d31 2
d46 1
d60 2
d74 1
d155 8
d452 1
a452 1
			mf.setMetaClass(findGenClass(lme.getDomainMetaClass()));
d541 44
@


1.33
log
@With #114177 in mind, viewmaps in genmodel should be simplistic as much as possible, no need to duplicate figure descriptions available in gmfgraph (and/or code generated from it)
@
text
@d88 1
a88 1
	private final ViewmapProducer myViewmaps = new ViewmapProducer();
d335 1
a335 1
		return myViewmaps.createLabelViewmap();
@


1.32
log
@#115461 provide source feature in mapping
@
text
@a26 2
import org.eclipse.gmf.codegen.gmfgen.BasicNodeViewmap;
import org.eclipse.gmf.codegen.gmfgen.ColorAttributes;
a28 1
import org.eclipse.gmf.codegen.gmfgen.DecoratedConnectionViewmap;
a43 1
import org.eclipse.gmf.codegen.gmfgen.LinkDecoration;
a48 1
import org.eclipse.gmf.codegen.gmfgen.ShapeAttributes;
a55 9
import org.eclipse.gmf.gmfgraph.Connection;
import org.eclipse.gmf.gmfgraph.ConnectionFigure;
import org.eclipse.gmf.gmfgraph.CustomConnection;
import org.eclipse.gmf.gmfgraph.DecorationFigure;
import org.eclipse.gmf.gmfgraph.Figure;
import org.eclipse.gmf.gmfgraph.PolylineConnection;
import org.eclipse.gmf.gmfgraph.Shape;
import org.eclipse.gmf.gmfgraph.util.FigureQualifiedNameSwitch;
import org.eclipse.gmf.gmfgraph.util.GMFGraphSwitch;
d88 1
a88 2

	private final GMFGraphSwitch myFiqureQualifiedNamesSwitch = new FigureQualifiedNameSwitch();
d142 1
a142 1
		getGenDiagram().setViewmap(GMFGenFactory.eINSTANCE.createDiagramViewmap());
d167 1
a167 1
			label.setViewmap(GMFGenFactory.eINSTANCE.createLabelViewmap());
d176 1
a176 1
		genNode.setViewmap(GMFGenFactory.eINSTANCE.createBasicNodeViewmap());
d197 1
a197 1
		childNode.setViewmap(GMFGenFactory.eINSTANCE.createBasicNodeViewmap());
d215 1
a215 1
			label.setViewmap(GMFGenFactory.eINSTANCE.createLabelViewmap());
d268 1
a268 1
		childCompartment.setViewmap(GMFGenFactory.eINSTANCE.createCompartmentViewmap());
d304 1
a304 1
			label.setViewmap(GMFGenFactory.eINSTANCE.createLabelViewmap());
d323 1
a323 1
		gl.setViewmap(createViewmap(lme.getDiagramLink()));
d330 6
a335 46
	private Viewmap createViewmap(Connection conn) {
		assert conn.getFigure() instanceof ConnectionFigure;
		Viewmap viewmap = null;
		if (conn.getFigure() instanceof PolylineConnection) {
			PolylineConnection pc = (PolylineConnection) conn.getFigure();
			DecoratedConnectionViewmap v = GMFGenFactory.eINSTANCE.createDecoratedConnectionViewmap();
			if (pc.getSourceDecoration() != null) {
				v.setSource(from(pc.getSourceDecoration()));
			}
			if (pc.getTargetDecoration() != null) {
				v.setTarget(from(pc.getTargetDecoration()));
			}
			viewmap = v;
		} else {
			assert conn.getFigure() instanceof CustomConnection;
			BasicNodeViewmap v = GMFGenFactory.eINSTANCE.createBasicNodeViewmap(); // FIXME rename BasicNodeV to just GenericV
			v.setFigureQualifiedClassName(qualifiedFigureName(conn.getFigure()));
			viewmap = v;
		}
		setupAttributes(conn.getFigure(), viewmap);
		return viewmap;
	}

	private void setupAttributes(Figure figure, Viewmap v) {
		if (figure.getColorStyle() != null) {
			ColorAttributes attrs = GMFGenFactory.eINSTANCE.createColorAttributes();
			attrs.setBackgroundColor(figure.getColorStyle().getBackgroundColor());
			attrs.setForegroundColor(figure.getColorStyle().getForegroundColor());
			v.getAttributes().add(attrs);
		}
		if (figure instanceof Shape) {
			ShapeAttributes attrs = GMFGenFactory.eINSTANCE.createShapeAttributes();
			attrs.setLineStyle(((Shape) figure).getLineKind().getLiteral());
			attrs.setLineWidth(((Shape) figure).getLineWidth());
			v.getAttributes().add(attrs);
		}
	}

	private LinkDecoration from(DecorationFigure df) {
		LinkDecoration ld = GMFGenFactory.eINSTANCE.createLinkDecoration();
		ld.setFigureQualifiedClassName(qualifiedFigureName(df));
		return ld;
	}

	private String qualifiedFigureName(Figure fig) {
		return (String) myFiqureQualifiedNamesSwitch.doSwitch(fig);
@


1.31
log
@#121888
One toolbar tool can create several elements.
@
text
@d496 1
@


1.30
log
@#120553
- Adding accessors for the palette entries factory methods into genmodel
- Refreshing unit-tests
- Fixing some old problems found by this refreshment.
@
text
@d307 1
a307 1
			le.setGenLink(gl);
d426 1
a426 1
			ne.setGenNode(genNode);
@


1.29
log
@#119709
Adding Compartment mapping
@
text
@d308 1
d427 1
d445 1
d456 1
d491 1
a491 1
		if (lme.getDomainMetaClass() != null) {
@


1.28
log
@Nullpointer for "reference only" links corrected.
@
text
@d14 1
d16 1
d73 1
d255 8
d265 5
a269 3
			GenChildContainer genChildContainer = createGenCompartment(childNodeMapping);
			if (genChildContainer != null) {
				genNode.getCompartments().add(genChildContainer);
d277 1
a277 1
	private GenCompartment createGenCompartment(ChildNodeMapping mapping) {
d279 1
a279 4
		if (compartment == null) {
			// how could this happen provided compartment is [1] ref?
			return null;
		}
d290 4
a293 4
		childCompartment.setNotationViewFactoryClassName(myNamingStrategy.createCompartmentClassName(mapping.getParentNode(), compartment, GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
		childCompartment.setEditPartClassName(myNamingStrategy.createCompartmentClassName(mapping.getParentNode(), compartment, GenCommonBase.EDIT_PART_SUFFIX));
		childCompartment.setItemSemanticEditPolicyClassName(myNamingStrategy.createCompartmentClassName(mapping.getParentNode(), compartment, GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
		childCompartment.setCanonicalEditPolicyClassName(myNamingStrategy.createCompartmentClassName(mapping.getParentNode(), compartment, GenChildContainer.CANONICAL_EDIT_POLICY_SUFFIX));
@


1.27
log
@updated gmfmap to match newly introduced .gmfgraph model (replaces .diadef) #114177.
besides, rudimentary tooling model is introduced as part of gmfmap #115799, subject to further work
@
text
@d298 1
a298 1
			setupCommonToolEntry(le, lme.getTool(), lme.getDomainMetaClass().getName());
@


1.26
log
@DomainMetaElement property is optional, so using newly created method to get this information.
@
text
@a13 1
import java.util.HashMap;
a14 1
import java.util.Map;
d25 2
d57 11
a67 5
import org.eclipse.gmf.diadef.AdornmentKind;
import org.eclipse.gmf.diadef.Compartment;
import org.eclipse.gmf.diadef.DiagramElement;
import org.eclipse.gmf.diadef.LineKind;
import org.eclipse.gmf.diadef.Node;
d72 1
d80 1
d100 2
d165 1
d189 1
a189 8
		// XXX nme.getDiagramNode.isSetDefaultWidth add DefaultSizeAttributes to viewmap
		Node nodeToolDef = nme.getDiagramNode();
		if (nodeToolDef.isNeedsTool()) {
			NodeEntry ne = GMFGenFactory.eINSTANCE.createNodeEntry();
			findToolGroup(nodeToolDef.getToolGroupID()).getNodeTools().add(ne);
			ne.setGenNode(genNode);
			setupCommonToolEntry(ne, nodeToolDef, myNamingStrategy.createNodeClassName(nme, ""));
		}
d200 1
a200 1
	
d203 1
d238 1
a238 7
		Node nodeToolDef = childNodeMapping.getDiagramNode();
		if (nodeToolDef.isNeedsTool()) {
			NodeEntry ne = GMFGenFactory.eINSTANCE.createNodeEntry();
			findToolGroup(nodeToolDef.getToolGroupID()).getNodeTools().add(ne);
			ne.setGenNode(childNode);
			setupCommonToolEntry(ne, nodeToolDef, myNamingStrategy.createChildNodeClassName(childNodeMapping, ""));
		}
d241 2
a242 1
		if (childNodeMapping.getDiagramNode().getCompartments().size() > 0 || childNodeMapping.getChildMappings().size() > 0) {
a251 22
		Map compartment2GenMap = new HashMap();
		for (Iterator it = mapping.getDiagramNode().getCompartments().iterator(); it.hasNext();) {
			Compartment compartment = (Compartment) it.next();
			GenCompartment childCompartment = GMFGenFactory.eINSTANCE.createGenCompartment();
			childCompartment.setVisualID(COMPARTMENT_COUNT_BASE + (++myCompartmentCount));
			childCompartment.setDiagramRunTimeClass(getChildContainerRunTimeClass());
			childCompartment.setViewmap(GMFGenFactory.eINSTANCE.createCompartmentViewmap());
			childCompartment.setCanCollapse(compartment.isCollapsible());
			childCompartment.setNeedsTitle(compartment.isNeedsTitle());
			childCompartment.setLayoutKind(CompartmentLayoutKind.TOOLBAR_LITERAL);
			childCompartment.setTitle(compartment.getName());

			// set class names
			childCompartment.setNotationViewFactoryClassName(myNamingStrategy.createCompartmentClassName(mapping, compartment, GenCommonBase.NOTATION_VIEW_FACTORY_SUFFIX));
			childCompartment.setEditPartClassName(myNamingStrategy.createCompartmentClassName(mapping, compartment, GenCommonBase.EDIT_PART_SUFFIX));
			childCompartment.setItemSemanticEditPolicyClassName(myNamingStrategy.createCompartmentClassName(mapping, compartment, GenCommonBase.ITEM_SEMANTIC_EDIT_POLICY_SUFFIX));
			childCompartment.setCanonicalEditPolicyClassName(myNamingStrategy.createCompartmentClassName(mapping, compartment, GenChildContainer.CANONICAL_EDIT_POLICY_SUFFIX));

			genNode.getCompartments().add(childCompartment);
			compartment2GenMap.put(compartment, childCompartment);
		}
		
d254 3
a256 4
			Compartment parentCompartment = childNodeMapping.getCompartment();
			GenChildContainer container;
			if (parentCompartment == null || !compartment2GenMap.containsKey(parentCompartment)) {
				container = genNode;
d258 1
a258 1
				container = (GenChildContainer) compartment2GenMap.get(parentCompartment);
d260 1
a260 1
			process(childNodeMapping, container);
d264 24
d294 1
a294 1
		if (lme.getDiagramLink().isNeedsTool()) {
d296 1
a296 1
			findToolGroup(lme.getDiagramLink().getToolGroupID()).getLinkTools().add(le);
d298 1
a298 1
			setupCommonToolEntry(le, lme.getDiagramLink(), myNamingStrategy.createLinkClassName(lme, ""));
d327 1
a327 1
		initViewmap(lme, gl);
a328 11
		LineKind lineKind = lme.getDiagramLink().getLineKind();
		if (lineKind != null) {
			ShapeAttributes attrs = GMFGenFactory.eINSTANCE.createShapeAttributes();
			switch (lineKind.getValue()) {
			case LineKind.SOLID : attrs.setLineStyle("LINE_SOLID"); break;
			case LineKind.DOT : attrs.setLineStyle("LINE_DOT"); break;
			case LineKind.DASH : attrs.setLineStyle("LINE_DASH"); break;
			}
			gl.getViewmap().getAttributes().add(attrs);
		}
		
d334 8
a341 6
	private void initViewmap(LinkMapping lme, GenLink gl) {
		if (lme.getDiagramLink().getSourceAdornment() != null || lme.getDiagramLink().getTargetAdornment() != null) {
			DecoratedConnectionViewmap viewmap = GMFGenFactory.eINSTANCE.createDecoratedConnectionViewmap();
			LinkDecoration d = decorationFromAdornment(lme.getDiagramLink().getSourceAdornment());
			if (d != null) {
				viewmap.setSource(d);
d343 2
a344 3
			d = decorationFromAdornment(lme.getDiagramLink().getTargetAdornment());
			if (d != null) {
				viewmap.setTarget(d);
d346 1
a346 1
			gl.setViewmap(viewmap);
d348 21
a368 2
			// XXX actually, another viewmap should be here
			gl.setViewmap(GMFGenFactory.eINSTANCE.createDecoratedConnectionViewmap());
d372 10
d410 7
a416 13
	private LinkDecoration decorationFromAdornment(AdornmentKind adornment) {
		String figureClassName = figureClassFromAdornment(adornment);
		if (figureClassName == null) {
			return null;
		}
		LinkDecoration d = GMFGenFactory.eINSTANCE.createLinkDecoration();
		d.setFigureQualifiedClassName(figureClassName);
		return d;
	}

	private String figureClassFromAdornment(AdornmentKind adornment) {
		if (adornment == null) {
			return null;
a417 7
		switch (adornment.getValue()) {
		case AdornmentKind.OPEN_TRIANGLE : return "org.eclipse.draw2d.PolylineDecoration";
		case AdornmentKind.FILLED_TRIANGLE : return "org.eclipse.draw2d.PolygonDecoration";
		case AdornmentKind.RHOMB : return "org.eclipse.gmf.draw2d.RhombDecoration";
		case AdornmentKind.FILLED_RHOMB : return "org.eclipse.gmf.draw2d.FilledRhombDecoration";
		}
		return null;
d420 4
a423 12
	private void setupCommonToolEntry(ToolEntry te, DiagramElement diagramElement, String elementName) {
		if (diagramElement.getLargeIconPath() == null) {
			te.setLargeIconPath("icons/large/" + elementName + ".gif");
		} else {
			te.setLargeIconPath(diagramElement.getLargeIconPath());
		}
		if (diagramElement.getSmallIconPath() == null) {
			// XXX never gets here as long the same code is inside DiagramElementImpl.getSmallIconPath()
			te.setSmallIconPath("icons/small/" + elementName + ".gif");
		} else {
			te.setSmallIconPath(diagramElement.getSmallIconPath());
		}
d428 6
a433 2
	private ToolGroup findToolGroup(String id) {
		id = id == null ? "" : id;
d436 1
a436 1
			if (id.equals(next.getTitleKey())) {
d442 1
a442 1
		tg.setTitleKey(id);
a447 1
		assert mapping.getDiagramNode() != null;
@


1.25
log
@[rdvorak] #117743 support for link creation constraints
@
text
@d154 2
a155 5
		assert nme.getDomainMetaElement() != null;
		assert nme.getDiagramNode() != null;
		assert checkDirectEditAttrValidity(nme);
// TODO: add this assertion?
//		assert nme.getContainmentFeature().getEType() instanceof EClass;
d198 2
d201 1
a201 10
		assert childNodeMapping.getContainmentFeature().getEType() instanceof EClass;
		assert childNodeMapping.getDiagramNode() != null;
//		TODO: add one mode assertion?
//		assert checkDirectEditAttrValidity(nme);
		
		if (childNodeMapping.getDomainMetaElement() != null) {
			childNode.setModelFacet(createModelFacet(childNodeMapping));
		} else {
			childNode.setModelFacet(setupModelFacet((EClass) childNodeMapping.getContainmentFeature().getEType(), childNodeMapping.getContainmentFeature(), null));
		}
d442 6
d449 1
a449 1
	private boolean checkDirectEditAttrValidity(NodeMapping nme) {
d454 1
a454 1
		return attrContainer == nme.getDomainMetaElement() || nme.getDomainMetaElement().getEAllSuperTypes().contains(attrContainer);
d470 1
a470 1
		TypeModelFacet typeModelFacet = setupModelFacet(anm.getDomainMetaElement(), anm.getContainmentFeature(), null);
d475 1
a475 1
		if (lme.getDomainMetaElement() != null) {
d477 1
a477 1
			mf.setMetaClass(findGenClass(lme.getDomainMetaElement()));
@


1.24
log
@#117749 & #118040 generate unique names for the shared elements in mapping model
@
text
@d41 1
d56 1
d69 1
d348 4
d494 17
d551 11
a561 1
	}	
@


1.23
log
@#118053
Infinite child mapping hierarchy in .gmfmap
@
text
@d34 1
d87 1
a87 2
	private final NamingStrategy myEditPartNamingStrategy;
	private final NamingStrategy myNotationViewFactoryNamingStrategy;
d95 1
a95 1
	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, NamingStrategy editPartNaming, NamingStrategy notationViewFactoryNaming) {
d97 1
a97 2
		myEditPartNamingStrategy = editPartNaming;
		myNotationViewFactoryNamingStrategy = notationViewFactoryNaming;
a137 1
		getGenDiagram().setEditPartClassName(createEditPartClassName(mapping));
d142 6
d169 6
a174 1
			label.setNotationViewFactoryClassName(createLabelTextNotationViewFactoryClassName(nme));
a176 2
		genNode.setEditPartClassName(createEditPartClassName(nme));
		genNode.setNotationViewFactoryClassName(createNotationViewFactoryClassName(nme));
d179 14
a192 1
		handleToolDef(nme.getDiagramNode(), genNode);
a211 2
		childNode.setEditPartClassName(createEditPartClassName(childNodeMapping));
		childNode.setNotationViewFactoryClassName(createNotationViewFactoryClassName(childNodeMapping));
d214 8
a221 1
		
d230 6
a235 1
			label.setNotationViewFactoryClassName(createLabelTextNotationViewFactoryClassName(childNodeMapping));
d240 7
a246 1
		handleToolDef(childNodeMapping.getDiagramNode(), childNode);
d270 7
a276 2
			childCompartment.setEditPartClassName(createEditPartClassName(compartment));
			childCompartment.setNotationViewFactoryClassName(createNotationViewFactoryClassName(compartment));
a293 9
	private void handleToolDef(Node nodeToolDef, GenNode genNode) {
		if (nodeToolDef.isNeedsTool()) {
			NodeEntry ne = GMFGenFactory.eINSTANCE.createNodeEntry();
			findToolGroup(nodeToolDef.getToolGroupID()).getNodeTools().add(ne);
			ne.setGenNode(genNode);
			setupCommonToolEntry(ne, nodeToolDef);
		}
	}

d304 1
a304 1
			setupCommonToolEntry(le, lme.getDiagramLink());
d315 8
a322 2
			label.setNotationViewFactoryClassName(createLabelNotationViewFactoryClassName(lme));
			label.setTextNotationViewFactoryClassName(createLabelTextNotationViewFactoryClassName(lme));
a325 2
		gl.setEditPartClassName(createEditPartClassName(lme));
		gl.setNotationViewFactoryClassName(createNotationViewFactoryClassName(lme));
d328 5
a364 58
	//

	private String createEditPartClassName(NodeMapping nme) {
		return myEditPartNamingStrategy.createClassName(nme);
	}
	
	private String createEditPartClassName(Compartment compartment) {
		return myEditPartNamingStrategy.createClassName(compartment);
	}

	private String createEditPartClassName(LinkMapping lme) {
		return myEditPartNamingStrategy.createClassName(lme);
	}

	private String createEditPartClassName(CanvasMapping mapping) {
		return myEditPartNamingStrategy.createClassName(mapping);
	}

	private String createEditPartClassName(ChildNodeMapping chnme) {
		return myEditPartNamingStrategy.createClassName(chnme);
	}

	//

	private String createNotationViewFactoryClassName(NodeMapping nme) {
		return myNotationViewFactoryNamingStrategy.createClassName(nme);
	}
	
	private String createLabelTextNotationViewFactoryClassName(NodeMapping nme) {
		return myNotationViewFactoryNamingStrategy.createLableTextClassName(nme);
	}	

	private String createLabelTextNotationViewFactoryClassName(ChildNodeMapping chnme) {
		return myNotationViewFactoryNamingStrategy.createLableTextClassName(chnme);
	}	
	
	private String createNotationViewFactoryClassName(Compartment compartment) {
		return myNotationViewFactoryNamingStrategy.createClassName(compartment);
	}
	
	private String createNotationViewFactoryClassName(LinkMapping lme) {
		return myNotationViewFactoryNamingStrategy.createClassName(lme);
	}

	private String createLabelNotationViewFactoryClassName(LinkMapping lme) {
		return myNotationViewFactoryNamingStrategy.createLableClassName(lme);
	}	
	
	private String createLabelTextNotationViewFactoryClassName(LinkMapping lme) {
		return myNotationViewFactoryNamingStrategy.createLableTextClassName(lme);
	}	

	private String createNotationViewFactoryClassName(ChildNodeMapping chnme) {
		return myNotationViewFactoryNamingStrategy.createClassName(chnme);
	}

	//

d416 1
a416 2
	private void setupCommonToolEntry(ToolEntry te, DiagramElement diagramElement) {
		final String elementName = diagramElement.getName();
@


1.22
log
@#115621 Support links with distinct source and containment features
@
text
@a25 1
import org.eclipse.emf.ecore.EReference;
d28 1
d59 1
d150 2
d174 49
d224 1
a224 1
		for (Iterator it = nme.getDiagramNode().getCompartments().iterator(); it.hasNext();) {
d239 2
a240 2

		for (Iterator it = nme.getChildMappings().iterator(); it.hasNext();) {
a241 28
			GenChildNode childNode = GMFGenFactory.eINSTANCE.createGenChildNode();
			assert childNodeMapping.getDomainChildrenFeature() instanceof EReference;
			assert childNodeMapping.getDomainChildrenFeature().getEType() instanceof EClass;
			
			if (childNodeMapping.getDomainMetaElement() != null) {
				childNode.setModelFacet(createModelFacet(childNodeMapping));
			} else {
				childNode.setModelFacet(setupModelFacet((EClass) childNodeMapping.getDomainChildrenFeature().getEType(), childNodeMapping.getDomainChildrenFeature(), null));
			}
			
			childNode.setDiagramRunTimeClass(findRunTimeClass(childNodeMapping));
			childNode.setViewmap(GMFGenFactory.eINSTANCE.createBasicNodeViewmap());
			childNode.setEditPartClassName(createEditPartClassName(childNodeMapping));
			childNode.setNotationViewFactoryClassName(createNotationViewFactoryClassName(childNodeMapping));
			childNode.setVisualID(CHILD_COUNT_BASE + (++myChildCount ));
			
			if (childNodeMapping.getEditFeature() != null) {
				FeatureModelFacet modelFacet = GMFGenFactory.eINSTANCE.createFeatureModelFacet();
				modelFacet.setMetaFeature(findGenFeature(childNodeMapping.getEditFeature()));
				GenNodeLabel label = GMFGenFactory.eINSTANCE.createGenNodeLabel();
				label.setModelFacet(modelFacet);
				label.setVisualID(LABEL_COUNT_BASE + (++myLabelCount));
				label.setDiagramRunTimeClass(getNodeLabelRunTimeClass());
				label.setViewmap(GMFGenFactory.eINSTANCE.createLabelViewmap());
				label.setNotationViewFactoryClassName(createLabelTextNotationViewFactoryClassName(childNodeMapping));
				childNode.getLabels().add(label);
			}
				
d249 1
a249 2
			container.getChildNodes().add(childNode);
			handleToolDef(childNodeMapping.getDiagramNode(), childNode);
d483 4
a486 4

	private TypeModelFacet createModelFacet(NodeMapping nme) {
		TypeModelFacet typeModelFacet = setupModelFacet(nme.getDomainMetaElement(), nme.getContainmentFeature(), null);
		return setupAux(typeModelFacet, nme.getDomainSpecialization(), nme.getDomainInitializer());
a504 6
	private TypeModelFacet createModelFacet(ChildNodeMapping nme) {
		// XXX domainChildrenFeature is NOT necessarily containment feature!!!
		TypeModelFacet mf = setupModelFacet(nme.getDomainMetaElement(), nme.getDomainChildrenFeature(), nme.getDomainChildrenFeature());
		return setupAux(mf, nme.getDomainSpecialization(), nme.getDomainInitializer());
	}

@


1.21
log
@spelling (Transofrmer -> Transformer)
@
text
@a471 2
			// TODO : source may be arbitrary feature
			mf.setSourceMetaFeature(findGenFeature(lme.getContainmentFeature()));
@


1.20
log
@[ashatalin] #114750 annotate diagram runtime model elements with visual id to tell one from another during EP decision making
@
text
@d73 1
a73 1
public class DiagramGenModelTransformer extends MappingTransofrmer {
d102 1
a102 1
	 * Should be invoked prior to {@@link MappingTransofrmer#transform(Mapping)}, otherwise has no effect.
@


1.19
log
@[ashatalin] #113892 flexible compartment hierarchy
@
text
@d162 1
d182 2
d214 1
d260 2
d306 4
d328 4
d333 8
d345 8
@


1.18
log
@[dsadnik] #113824 marker viewmaps for diagram, label and childcontainer
@
text
@d14 1
d16 1
d34 1
d169 2
d173 10
a182 10
			GenChildContainer childContainer = GMFGenFactory.eINSTANCE.createGenChildContainer();
			childContainer.setVisualID(COMPARTMENT_COUNT_BASE + (++myCompartmentCount));
			childContainer.setDiagramRunTimeClass(getChildContainerRunTimeClass());
			childContainer.setViewmap(GMFGenFactory.eINSTANCE.createCompartmentViewmap());
			childContainer.setGroupID(compartment.getName());
			childContainer.setCanCollapse(compartment.isCollapsible());
			childContainer.setNeedsTitle(compartment.isNeedsTitle());
			childContainer.setLayoutKind(CompartmentLayoutKind.TOOLBAR_LITERAL);
			childContainer.setTitleKey(compartment.getName());
			genNode.getChildContainers().add(childContainer);
a200 1
			childNode.setGroupID(childNodeMapping.getCompartment().getName());
d213 9
a221 2
						
			genNode.getChildNodes().add(childNode);
@


1.17
log
@[rdvorak] #113856 refactor features left in GenBaseElement to TypeModelFacet
@
text
@d71 1
d84 1
d139 1
a139 2
		// FIXME invalid viewmap class in use
		getGenDiagram().setViewmap(GMFGenFactory.eINSTANCE.createBasicNodeViewmap());
d158 1
d171 1
d193 1
d206 1
d244 1
@


1.16
log
@#113823 childMetaFeature moved to TypeModelFacet
@
text
@d204 1
a204 10
			
			// construct model element selector for domain EClass specializations if any exist
			if(childNodeMapping.getDomainSpecialization() != null) {
				childNode.setModelElementSelector(createModelElementSelector(childNodeMapping.getDomainSpecialization()));
			}
			
			if(childNodeMapping.getDomainInitializer() != null) {
				childNode.setModelElementInitializer(createElementInitializer(childNodeMapping.getDomainInitializer()));			
			}					
			
a207 9
		
		// construct model element selector for domain EClass specializations if any exist
		if(nme.getDomainSpecialization() != null) {
			genNode.setModelElementSelector(createModelElementSelector(nme.getDomainSpecialization()));
		}
		
		if(nme.getDomainInitializer() != null) {
			genNode.setModelElementInitializer(createElementInitializer(nme.getDomainInitializer()));			
		}		
a243 1
		//FIXME gl.setContainmentMetaFeature(findGenFeature(lme.getContainmentFeature()));
a257 8

		// construct model element selector for domain EClass specializations if any exist
		if(lme.getDomainSpecialization() != null) {
			gl.setModelElementSelector(createModelElementSelector(lme.getDomainSpecialization()));
		}
		if(lme.getDomainInitializer() != null) {
			gl.setModelElementInitializer(createElementInitializer(lme.getDomainInitializer()));			
		}
d415 2
a416 1
		return setupModelFacet(nme.getDomainMetaElement(), nme.getContainmentFeature(), null);
d428 1
d439 2
a440 1
		return setupModelFacet(nme.getDomainMetaElement(), nme.getDomainChildrenFeature(), nme.getDomainChildrenFeature());
d451 14
@


1.15
log
@#113823 childMetaFeature moved to TypeModelFacet
@
text
@d42 1
d242 1
a242 13
		if (lme.getDomainMetaElement() != null) {
			TypeLinkModelFacet mf = GMFGenFactory.eINSTANCE.createTypeLinkModelFacet();
			mf.setMetaClass(findGenClass(lme.getDomainMetaElement()));
			mf.setContainmentMetaFeature(findGenFeature(lme.getContainmentFeature()));
			// TODO : source may be arbitrary feature
			mf.setSourceMetaFeature(findGenFeature(lme.getContainmentFeature()));
			mf.setTargetMetaFeature(findGenFeature(lme.getLinkMetaFeature()));
			gl.setModelFacet(mf);
		} else {
			FeatureModelFacet mf = GMFGenFactory.eINSTANCE.createFeatureModelFacet();
			mf.setMetaFeature(findGenFeature(lme.getLinkMetaFeature()));
			gl.setModelFacet(mf);
		}
d445 17
@


1.14
log
@[dstadnik] #113803 rt classes for child containers and labels
@
text
@d185 1
a185 1
				childNode.setModelFacet(setupModelFacet((EClass) childNodeMapping.getDomainChildrenFeature().getEType(), childNodeMapping.getDomainChildrenFeature()));
d453 1
a453 1
		return setupModelFacet(nme.getDomainMetaElement(), nme.getContainmentFeature());
d458 1
a458 1
		return setupModelFacet(nme.getDomainMetaElement(), nme.getDomainChildrenFeature());
d461 1
a461 1
	private TypeModelFacet setupModelFacet(EClass domainMetaElement, EStructuralFeature containmentFeature) {
d465 1
@


1.13
log
@[dstadnik] #113786 visual ID for compartments
greater range for ids, no default generated id
@
text
@d155 1
d167 1
d200 1
d267 1
d366 12
@


1.12
log
@[dstadnik] #113525 Get rid of LinkWithClass/LinkWithReference, use parallel hierarchy of modelFacet instead
@
text
@d71 5
a75 4
	private static final int NODE_COUNT_BASE = 100;
	private static final int CHILD_COUNT_BASE = 200;
	private static final int LINK_COUNT_BASE = 300;
	private static final int LABEL_COUNT_BASE = 400;
d86 1
d165 1
@


1.11
log
@#112196 model facets in use for GenNode
@
text
@a37 2
import org.eclipse.gmf.codegen.gmfgen.GenLinkReferenceOnly;
import org.eclipse.gmf.codegen.gmfgen.GenLinkWithClass;
d48 1
d233 2
a234 1
		GenLink gl;
d236 7
a242 5
			GenLinkWithClass genLink = GMFGenFactory.eINSTANCE.createGenLinkWithClass();
			getGenDiagram().getLinks().add(genLink);
			genLink.setDomainMetaClass(findGenClass(lme.getDomainMetaElement()));
			genLink.setDomainLinkTargetFeature(findGenFeature(lme.getLinkMetaFeature()));
			gl = genLink;
d244 3
a246 4
			GenLinkReferenceOnly genLink = GMFGenFactory.eINSTANCE.createGenLinkReferenceOnly();
			getGenDiagram().getLinks().add(genLink);
			genLink.setDomainLinkTargetFeature(findGenFeature(lme.getLinkMetaFeature()));
			gl = genLink;
@


1.10
log
@[dstadnik] #112195 multiple labels for the node, facets introduced, genmodel cleaned and refactored
@
text
@d50 1
d146 1
a146 2
		genNode.setDomainMetaClass(findGenClass(nme.getDomainMetaElement()));
		//genNode.setContainmentMetaFeature(findGenFeature(nme.getContainmentFeature()));
a176 1
			//childNode.setContainmentMetaFeature(findGenFeature(childNodeMapping.getDomainChildrenFeature()));
d179 1
a179 1
				childNode.setDomainMetaClass(findGenClass(childNodeMapping.getDomainMetaElement()));
d181 1
a181 1
				childNode.setDomainMetaClass(findGenClass((EClass) childNodeMapping.getDomainChildrenFeature().getEType()));
d265 1
a265 1
		//gl.setContainmentMetaFeature(findGenFeature(lme.getContainmentFeature()));
d431 17
a447 1
	
@


1.9
log
@[rdvorak] #113224 Generate custom initialization code for domain model elements
@
text
@d20 1
d28 1
d37 1
d41 1
d74 1
d84 1
d134 2
d146 1
a146 1
		genNode.setContainmentMetaFeature(findGenFeature(nme.getContainmentFeature()));
d149 6
a154 1
			genNode.setDomainNameFeature(findGenFeature(nme.getEditFeature()));
d177 1
a177 1
			childNode.setContainmentMetaFeature(findGenFeature(childNodeMapping.getDomainChildrenFeature()));
d192 6
a197 1
				childNode.setDomainNameFeature(findGenFeature(childNodeMapping.getEditFeature()));
d254 9
a262 1
		gl.setDomainNameFeature(findGenFeature(lme.getLabelEditFeature()));
d266 1
a266 1
		gl.setContainmentMetaFeature(findGenFeature(lme.getContainmentFeature()));
@


1.8
log
@[rdvorak] #112505 constraint specification in gmfmap
@
text
@d31 3
d54 3
d185 4
d198 4
d260 3
d407 20
@


1.7
log
@#111775 stale properties in gmfgen
#111784 GenChildContainer extends GenCommonBase
@
text
@d37 1
d50 1
d176 5
d184 5
d241 5
d389 7
@


1.6
log
@refactor GenModel access with dedicated hack to get Notation/Runtime GenModel
@
text
@a66 1
	private final NamingStrategy myMetaInfoNamingStrategy;
d72 1
a72 1
	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, NamingStrategy editPartNaming, NamingStrategy metaInfoNaming, NamingStrategy notationViewFactoryNaming) {
a74 1
		myMetaInfoNamingStrategy = metaInfoNaming;
a116 1
		getGenDiagram().setMetaInfoProviderClassName(createMetaInfoProviderClassName(mapping));
a135 1
		genNode.setMetaInfoProviderClassName(createMetaInfoProviderClassName(nme));
a165 1
			childNode.setMetaInfoProviderClassName(createMetaInfoProviderClassName(childNodeMapping));
a212 1
		gl.setMetaInfoProviderClassName(createMetaInfoProviderClassName(lme));
a268 18
	private String createMetaInfoProviderClassName(NodeMapping nme) {
		return myMetaInfoNamingStrategy.createClassName(nme);
	}

	private String createMetaInfoProviderClassName(LinkMapping lme) {
		return myMetaInfoNamingStrategy.createClassName(lme);
	}

	private String createMetaInfoProviderClassName(CanvasMapping mapping) {
		return myMetaInfoNamingStrategy.createClassName(mapping);
	}

	private String createMetaInfoProviderClassName(ChildNodeMapping chnme) {
		return myMetaInfoNamingStrategy.createClassName(chnme);
	}
	
	//

@


1.5
log
@[ashatalin] #111769 NamingStrategy for ViewFactories
@
text
@a134 3
		if (getGenDiagram().getDomainMetaModel() != null) {
			assert getGenDiagram().getDomainMetaModel() == nme.getDomainMetaElement().getEPackage();
		}
@


1.4
log
@gmfgen ECore references were replaced with GenModel references to ease template coding and as alignment with overall "genmodel for GMF" concept
@
text
@d68 1
d73 1
a73 1
	public DiagramGenModelTransformer(DiagramRunTimeModelHelper drtHelper, NamingStrategy editPartNaming, NamingStrategy metaInfoNaming) {
d77 1
d143 1
d174 1
d222 1
d293 14
@


1.3
log
@figure class could be specified in .gmfgen along with dependent attributes. Notion of "Viewmap" captures that (visualization) information
@
text
@d17 3
d22 1
d24 1
d50 1
d64 1
d78 11
d111 5
a115 2
		getGenDiagram().setDomainMetaModel(mapping.getDomainModel());
		getGenDiagram().setDomainDiagramElement(mapping.getDomainMetaElement());
d130 2
a131 2
		genNode.setDomainMetaClass(nme.getDomainMetaElement());
		genNode.setContainmentMetaFeature(nme.getContainmentFeature());
d137 1
a137 1
			genNode.setDomainNameFeature(nme.getEditFeature());
d160 1
a160 1
			childNode.setContainmentMetaFeature((EReference) childNodeMapping.getDomainChildrenFeature());
d163 1
a163 1
				childNode.setDomainMetaClass(childNodeMapping.getDomainMetaElement());
d165 1
a165 1
				childNode.setDomainMetaClass((EClass) childNodeMapping.getDomainChildrenFeature().getEType());
d175 1
a175 1
				childNode.setDomainNameFeature(childNodeMapping.getEditFeature());
d199 2
a200 2
			genLink.setDomainMetaClass(lme.getDomainMetaElement());
			genLink.setDomainLinkTargetFeature(lme.getLinkMetaFeature());
d205 1
a205 1
			genLink.setDomainLinkTargetFeature(lme.getLinkMetaFeature());
d214 1
a214 1
		gl.setDomainNameFeature(lme.getLabelEditFeature());
d218 1
a218 1
		gl.setContainmentMetaFeature(lme.getContainmentFeature());
d368 12
@


1.2
log
@[ashatalin] Should be possible to specify editable feature and domain element for child nodes.
@
text
@d21 1
d30 1
d34 1
d120 2
d199 3
d204 1
d206 3
a208 3
			case LineKind.SOLID : gl.setLineStyle("LINE_SOLID"); break;
			case LineKind.DOT : gl.setLineStyle("LINE_DOT"); break;
			case LineKind.DASH : gl.setLineStyle("LINE_DASH"); break;
d210 1
d212 17
a228 7
		String decorationFigure = figureClassFromAdornment(lme.getDiagramLink().getSourceAdornment());
		if (decorationFigure != null) {
			gl.setSourceDecorationFigureQualifiedClassName(decorationFigure);
		}
		decorationFigure = figureClassFromAdornment(lme.getDiagramLink().getTargetAdornment());
		if (decorationFigure != null) {
			gl.setTargetDecorationFigureQualifiedClassName(decorationFigure);
d286 10
@


1.1
log
@*** empty log message ***
@
text
@d135 7
a141 1
			childNode.setDomainMetaClass((EClass) childNodeMapping.getDomainChildrenFeature().getEType());
d147 5
@

