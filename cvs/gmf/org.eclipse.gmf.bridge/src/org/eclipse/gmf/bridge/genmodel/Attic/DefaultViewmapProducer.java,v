head	1.9;
access;
symbols
	v20081015-1925:1.9
	v20080917-1925:1.9
	v20080903-1520:1.9
	v20080827-1520:1.9
	v20080813-1520:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060620-0400:1.8
	v20060616-1200:1.7
	v20060609-1400:1.7
	v20060531-1730:1.7
	v20060530-1930:1.7
	v20060526-1200:1.7
	v20060519-0800:1.6
	v20060512-1000:1.5
	I20060512-1000:1.5
	I20060505-1400:1.5
	I20060428-1300:1.4
	I20060424-0500:1.4
	I20060424-0300:1.4
	M6_10:1.3
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.1
	I20060210-1715:1.1
	I20060209-1815:1.1
	I20060203-0830:1.1
	I20060129-1145:1.1
	I20060127-0900:1.1
	I20060120-1530:1.1
	I20060113-1700:1.1
	M4_10:1.1
	I20060107-1100:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.9
date	2006.06.26.14.05.05;	author atikhomirov;	state dead;
branches;
next	1.8;

1.8
date	2006.06.19.12.41.57;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.23.21.09.42;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.17.12.39.18;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.04.17.54.12;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.20.12.16.54;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.10.12.14.08;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.22.22.01.15;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.06.19.22.31;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.9
log
@no api packages, classes are for internal use only
@
text
@/*
 * Copyright (c) 2005 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.bridge.genmodel;

import org.eclipse.gmf.codegen.gmfgen.FigureViewmap;
import org.eclipse.gmf.codegen.gmfgen.GMFGenFactory;
import org.eclipse.gmf.codegen.gmfgen.ResizeConstraints;
import org.eclipse.gmf.codegen.gmfgen.StyleAttributes;
import org.eclipse.gmf.codegen.gmfgen.Viewmap;
import org.eclipse.gmf.codegen.gmfgen.ViewmapLayoutType;
import org.eclipse.gmf.gmfgraph.Canvas;
import org.eclipse.gmf.gmfgraph.Compartment;
import org.eclipse.gmf.gmfgraph.Connection;
import org.eclipse.gmf.gmfgraph.DiagramLabel;
import org.eclipse.gmf.gmfgraph.Direction;
import org.eclipse.gmf.gmfgraph.Figure;
import org.eclipse.gmf.gmfgraph.FigureHandle;
import org.eclipse.gmf.gmfgraph.FlowLayout;
import org.eclipse.gmf.gmfgraph.Layout;
import org.eclipse.gmf.gmfgraph.Layoutable;
import org.eclipse.gmf.gmfgraph.Node;
import org.eclipse.gmf.gmfgraph.XYLayout;
import org.eclipse.gmf.gmfgraph.util.GMFGraphSwitch;

/**
 * @@author artem
 */
public class DefaultViewmapProducer extends ViewmapProducer {
	private final LayoutTypeSwitch myLayoutTypeSwitch = new LayoutTypeSwitch();
	
	public DefaultViewmapProducer() {
	}

	public Viewmap create(Canvas canvasElement) {
		FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
		v.setFigureQualifiedClassName("org.eclipse.draw2d.FreeformLayer");
		return v;
	}

	public Viewmap create(Node node) {
		FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
		v.setFigureQualifiedClassName("org.eclipse.draw2d.RoundedRectangle");
		return v;
	}

	public Viewmap create(Connection link) {
		FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
		v.setFigureQualifiedClassName("org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx");
		return v;
	}

	public Viewmap create(Compartment compartment) {
		FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
		// ShapeCompartmentFigure | NestedResizableCompartmentFigure
		v.setFigureQualifiedClassName("XXX");
		return v;
	}

	public Viewmap create(DiagramLabel label) {
		FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
		v.setFigureQualifiedClassName("org.eclipse.draw2d.Label");
		return v;
	}

	protected final void setupResizeConstraints(Viewmap viewmap, Node diagramNode){
		Direction direction = diagramNode.getResizeConstraint();
		if (direction == null || direction.getValue() == Direction.NSEW){
			return;
		}
		ResizeConstraints constraints = GMFGenFactory.eINSTANCE.createResizeConstraints();
		constraints.setResizeHandles(direction.getValue());
		viewmap.getAttributes().add(constraints);
	}
	
	protected final void setupLayoutType(Viewmap viewmap, Node diagramNode){
		FigureHandle figure = diagramNode.getFigure();
		if (false == figure instanceof Layoutable){
			return;
		}
		ViewmapLayoutType type = myLayoutTypeSwitch.getLayoutType(((Layoutable) figure).getLayout());
		viewmap.setLayoutType(type);
	}
	
	protected final void setupStyleAttributes(Viewmap viewmap, FigureHandle handle){
		if (viewmap == null || false == handle instanceof Figure){
			return;
		}
		Figure figure = (Figure)handle;
		StyleAttributes attributes = GMFGenFactory.eINSTANCE.createStyleAttributes();
		boolean fixedSomething = false;
		if (figure.getFont() != null){
			attributes.setFixedFont(true);
			fixedSomething = true;
		}
		if (figure.getForegroundColor() != null){
			attributes.setFixedForeground(true);
			fixedSomething = true;
		}
		if (figure.getBackgroundColor() != null){
			attributes.setFixedBackground(true);
			fixedSomething = true;
		}
		
		if (fixedSomething){
			viewmap.getAttributes().add(attributes);
		}
	}

	private static class LayoutTypeSwitch extends GMFGraphSwitch {
		
		public ViewmapLayoutType getLayoutType(Layout layout){
			return layout == null ? ViewmapLayoutType.UNKNOWN_LITERAL : (ViewmapLayoutType)doSwitch(layout);
		}
		
		public Object caseLayout(Layout object) {
			return ViewmapLayoutType.UNKNOWN_LITERAL;
		}
		
		public Object caseFlowLayout(FlowLayout layout) {
			return layout.isForceSingleLine() ? ViewmapLayoutType.TOOLBAR_LAYOUT_LITERAL : ViewmapLayoutType.FLOW_LAYOUT_LITERAL;
		}
		
		public Object caseXYLayout(XYLayout object) {
			return ViewmapLayoutType.XY_LAYOUT_LITERAL;
		}
	}
}
@


1.8
log
@[mgolubev] #145863 Colors defined in the gmfgraph model should be used by the generated polyline connections
@
text
@@


1.7
log
@#140887 Remove Child interface from GMFGraph.
Although the need to reference child figures persist, thus FigureHandle was introduced, to allow diagramElements to reference either *generateable* figures (Figure subclasses) or *just-use* figures (like CustomFigure and FigureAccessor).
Refactoring performed with #131365 "Mirror GMFGraph model when generating standalone figure plugin" in mind
@
text
@d17 1
d25 1
d92 25
@


1.6
log
@[mgolubev] #140186 XYLayoutEditPolicy should not be installed for editparts that have figure with non-XYLayout in the gmfgraph model
@
text
@a19 1
import org.eclipse.gmf.gmfgraph.Child;
d24 1
a24 1
import org.eclipse.gmf.gmfgraph.Figure;
d27 1
a58 4
	public Viewmap create(Child child) {
		return createLabelViewmap();
	}

d67 3
a69 1
		return createLabelViewmap();
d83 2
a84 2
		Figure figure = diagramNode.getFigure();
		if (figure == null){
d87 1
a87 1
		ViewmapLayoutType type = myLayoutTypeSwitch.getLayoutType(figure.getLayout());
a90 8
	// FIXME remove
	private static Viewmap createLabelViewmap() {
		FigureViewmap v = GMFGenFactory.eINSTANCE.createFigureViewmap();
		v.setFigureQualifiedClassName("org.eclipse.draw2d.Label");
		return v;
	}
	
	
@


1.5
log
@no need to add resize constraints if all handles should be added (which is default behaviour)
@
text
@d18 1
d25 3
d29 2
d36 1
d74 1
a74 1
	protected void setupResizeConstraints(Viewmap viewmap, Node diagramNode){
d83 9
d99 20
@


1.4
log
@#135017 use geographical constants from PositionConstants
@
text
@d69 1
a69 1
		if (direction == null){
@


1.3
log
@[mgolubev] #135017 Respect resize constraints defined in .gmfgraph
@
text
@a13 1
import org.eclipse.draw2d.PositionConstants;
a29 1
	private DirectionMapper myDirectionMapper; 
d73 1
a73 1
		constraints.setResizeHandles(getDirectionMapper().direction2resizeConstraint(direction));
a82 30
	
	protected DirectionMapper getDirectionMapper(){
		if (myDirectionMapper == null) {
			myDirectionMapper = new DirectionMapper();
		}
		return myDirectionMapper;
	}
	
	protected static class DirectionMapper {
		public int direction2resizeConstraint(Direction literal){
			int result = PositionConstants.NONE;
			
			int direction = literal.getValue();
			result |= returnIfBitMaskSet(direction, Direction.NORTH, PositionConstants.NORTH);
			result |= returnIfBitMaskSet(direction, Direction.SOUTH, PositionConstants.SOUTH);
			result |= returnIfBitMaskSet(direction, Direction.EAST, PositionConstants.EAST);
			result |= returnIfBitMaskSet(direction, Direction.WEST, PositionConstants.WEST);
			
			result |= returnIfBitMaskSet(direction, Direction.NORTH_EAST, PositionConstants.NORTH_EAST);
			result |= returnIfBitMaskSet(direction, Direction.NORTH_WEST, PositionConstants.NORTH_WEST);
			result |= returnIfBitMaskSet(direction, Direction.SOUTH_EAST, PositionConstants.SOUTH_EAST);
			result |= returnIfBitMaskSet(direction, Direction.SOUTH_WEST, PositionConstants.SOUTH_WEST);

			return result;
		}
		
		private static int returnIfBitMaskSet(int value, int mask, int result) {
			return ((value & mask) == mask) ? result : 0;
		}
	}
@


1.2
log
@#129047 get rid of explicit edit/label features, use generic and feature-rich LabelMapping instead.
@
text
@d14 1
d17 1
d24 1
d31 2
d69 10
d85 30
@


1.1
log
@New plugin with IFigure codegeneration to support #114177 (graphical definition model) was added
@
text
@d21 1
d60 4
d65 1
a65 1
	static Viewmap createLabelViewmap() {
@

