head	1.24;
access;
symbols
	v20081020-0700:1.24
	v20080813-1510:1.24
	v20080811-1546:1.24
	v20080722-1827:1.24
	v20080716-1600:1.24
	v20080716-1642:1.24
	R2_1_maintenance:1.24.0.2
	Root_R2_1_maintenance:1.24
	R2_1_0:1.24
	v20080603-1553:1.24
	v20080521:1.24
	v20080503-1740:1.24
	v20080425-1959:1.24
	v20080417-1610:1.24
	v20080409-1326:1.23
	v20080328-1605:1.23
	v20080222-1200:1.23
	v20080201-2010:1.23
	v20080118-1129:1.20.4.1
	v20080114-2222:1.20.4.1
	v20071222-1111:1.23
	v20071214-1111:1.23
	v20071207-1111:1.23
	v20071130-1111:1.22
	v20071124-0000:1.20.4.1
	v20071108-0000:1.21
	v20071003-0000:1.20
	v20070915-0000:1.20
	v20070809-0000:1.20
	R2_0_maintenance:1.20.0.4
	R2_0:1.20
	R4_20:1.20
	RC3_20:1.20
	v20070608-1300:1.20
	v20070601-1400:1.20
	v20070518-1300:1.20
	bugzilla111892_group_support:1.20.0.2
	Root_bugzilla111892_group_support:1.20
	v20070405-2000:1.20
	v20070330-1300:1.20
	v20070208-1800:1.20
	v20070202-0200:1.17.2.6
	v20070111-0800:1.17.2.6
	M4_20:1.19
	v20061218-1500:1.17.2.5
	v20061214-0000:1.19
	M3_20:1.18
	v20061013-1330:1.18
	v20061012-1100:1.17.2.4
	v20060919-0800:1.17.2.4
	M1_20:1.17
	v20060824-1600:1.17.2.3
	v20060803-1200:1.17.2.1
	v20060721-1130:1.17.2.1
	v20060713-1700:1.17.2.1
	R1_0_maintenance:1.17.0.2
	R1_0:1.17
	v20060627-1200:1.17
	v20060616-1200:1.17
	v20060609-1400:1.17
	v20060531-1730:1.17
	v20060530-1930:1.17
	I20060505-1400:1.17
	I20060428-1300:1.16
	I20060424-0500:1.13
	I20060424-0300:1.13
	M6_10:1.13
	I20060407-1200:1.13
	I20060331-1000:1.13
	I20060324-0300:1.13
	I20060317-1300:1.13
	I20060317-1200:1.13
	I20060316-1300:1.13
	I20060309-1300:1.13
	M5_10:1.13
	S20060303-1600:1.13
	I20060227-1730:1.12
	I20060216-1945:1.12
	I20060210-1715:1.12
	I20060209-1815:1.11
	I20060203-0830:1.11
	I20060129-1145:1.11
	I20060127-0900:1.11
	I20060120-1530:1.10
	I20060113-1700:1.9
	M4_10:1.9
	I20060107-1100:1.9
	I20060105-1630:1.9
	I20051230-1230:1.9
	I20051223-1100:1.9
	I20051217-0925:1.9
	I20051201-1800:1.9
	I20051124-2000:1.8
	M3_10:1.7
	I20051118-1245:1.7
	I20051111-1800:1.7
	I20051106-0900:1.7
	v20051030:1.6;
locks; strict;
comment	@# @;


1.24
date	2008.04.17.17.08.09;	author ahunter;	state Exp;
branches;
next	1.23;
commitid	f46480783f84567;

1.23
date	2007.12.06.21.18.58;	author ahunter;	state Exp;
branches;
next	1.22;
commitid	72b7475867424567;

1.22
date	2007.11.21.17.57.23;	author crevells;	state Exp;
branches;
next	1.21;
commitid	49be474471834567;

1.21
date	2007.11.06.13.59.49;	author crevells;	state Exp;
branches;
next	1.20;
commitid	44d1473073554567;

1.20
date	2007.01.09.21.41.51;	author ahunter;	state Exp;
branches
	1.20.2.1
	1.20.4.1;
next	1.19;
commitid	7f1745a40c1e4567;

1.19
date	2006.11.23.21.11.54;	author mmostafa;	state Exp;
branches;
next	1.18;
commitid	2a7345660e9a4567;

1.18
date	2006.10.03.15.02.59;	author ahunter;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.03.15.31.23;	author ahunter;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2006.04.28.01.57.48;	author ahunter;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.27.20.51.54;	author ahunter;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.27.18.39.17;	author ahunter;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.28.02.30.41;	author cmahoney;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.10.21.32.30;	author ahunter;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.26.22.27.12;	author cmahoney;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.16.19.48.59;	author sshaw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.25.19.38.18;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.21.15.06.20;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.02.23.30.40;	author sshaw;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.14.19.37.46;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.23.18.37.31;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.22.15.42.25;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.21.24.46;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.37;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.50;	author sshaw;	state Exp;
branches;
next	;

1.17.2.1
date	2006.07.11.15.10.31;	author cmahoney;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2006.08.21.16.02.09;	author cmahoney;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2006.08.24.15.00.57;	author cmahoney;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2006.09.13.16.43.23;	author ahunter;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2006.11.23.21.10.20;	author mmostafa;	state Exp;
branches;
next	1.17.2.6;
commitid	1fd045660e3c4567;

1.17.2.6
date	2007.01.09.21.41.00;	author ahunter;	state Exp;
branches;
next	;
commitid	7da245a40be94567;

1.20.2.1
date	2007.05.18.17.36.33;	author crevells;	state Exp;
branches;
next	;
commitid	17e3464de4214567;

1.20.4.1
date	2007.11.06.14.49.36;	author crevells;	state Exp;
branches;
next	;
commitid	542647307eff4567;


desc
@@


1.24
log
@[147497] gmf-head carson_li 080417 ROLLBACK [Properties] Buttons on the appearance tab should be DROP_DOWN style
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.properties.sections.appearance;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
import org.eclipse.gmf.runtime.diagram.ui.internal.util.FontHelper;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.l10n.DiagramUIPropertiesImages;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.l10n.DiagramUIPropertiesMessages;
import org.eclipse.gmf.runtime.diagram.ui.properties.sections.AbstractNotationPropertiesSection;
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
import org.eclipse.gmf.runtime.emf.core.util.PackageUtil;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.Style;
import org.eclipse.gmf.runtime.notation.View;
import org.eclipse.jface.dialogs.IDialogConstants;
import org.eclipse.jface.resource.CompositeImageDescriptor;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.swt.SWT;
import org.eclipse.swt.accessibility.AccessibleAdapter;
import org.eclipse.swt.accessibility.AccessibleEvent;
import org.eclipse.swt.custom.CCombo;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
import org.eclipse.swt.graphics.PaletteData;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Group;
import org.eclipse.swt.widgets.Label;
import org.eclipse.ui.IWorkbenchPart;

/**
 * Colors section to represent line and font properties of a shape or connection
 * 
 * @@author nbalaba
 * 
 */
public class ColorsAndFontsPropertySection
	extends AbstractNotationPropertiesSection {

	// properties
	protected static final String FONT_COLOR_COMMAND_NAME = DiagramUIPropertiesMessages.
		FontColor_commandText + StringStatics.SPACE 
		+ VALUE_CHANGED_STRING;

	protected static final String LINE_COLOR_COMMAND_NAME = DiagramUIPropertiesMessages.
		LineColor_commandText + StringStatics.SPACE 
		+ VALUE_CHANGED_STRING;

	// properties
	protected static final String FONT_COMMAND_NAME = DiagramUIPropertiesMessages.
		Font_commandText + StringStatics.SPACE 
		+ VALUE_CHANGED_STRING;


	static protected final String FILL_COLOR_COMMAND_NAME = DiagramUIPropertiesMessages.
		FillColor_commandText + StringStatics.SPACE 
		+ VALUE_CHANGED_STRING;
	
	protected static final String FONTS_AND_COLORS_LABEL = DiagramUIPropertiesMessages.
		FontAndColor_nameLabel;

	protected Button fillColorButton;

	protected RGB fillColor = null;

	// font family drop down
	protected CCombo fontFamilyCombo;

	// font size drop down
	private CCombo fontSizeCombo;

	private Button fontBoldButton;

	private Button fontItalicButton;
	
	/** the default preference color */
	protected static final RGB DEFAULT_PREF_COLOR = new RGB(0, 0, 0);

	protected Button fontColorButton;

    protected Button lineColorButton;

	protected RGB fontColor;

	protected RGB lineColor;

	protected Group colorsAndFontsGroup;

	protected int previousColor;

	protected static class ColorOverlayImageDescriptor
		extends CompositeImageDescriptor {

		/** default color icon width */
		private static final Point ICON_SIZE = new Point(16, 16);

		/** the basic icon */
		private ImageData basicImgData;

		/** the color of the thin color bar */
		private RGB rgb;

		/**
		 * Creates a new color menu image descriptor
		 * 
		 * @@param basicIcon
		 *            The basic Image data
		 * @@param rgb
		 *            The color bar RGB value
		 */
		public ColorOverlayImageDescriptor(ImageData basicImgData, RGB rgb) {
			this.basicImgData = basicImgData;
			this.rgb = rgb;
		}

		/**
		 * @@see org.eclipse.jface.resource.CompositeImageDescriptor#drawCompositeImage(int,
		 *      int)
		 */
		protected void drawCompositeImage(int width, int height) {

			// draw the thin color bar underneath
			if (rgb != null) {
				ImageData colorBar = new ImageData(width, height / 5, 1,
				
					new PaletteData(new RGB[] {rgb}));
				drawImage(colorBar, 0, height - height / 5);
				
			}
			// draw the base image
			drawImage(basicImgData, 0, 0);
		}

		/**
		 * @@see org.eclipse.jface.resource.CompositeImageDescriptor#getSize()
		 */
		protected Point getSize() {
			return ICON_SIZE;
		}
	}   	
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.properties.sections.AbstractNotationPropertiesSection#initializeControls(org.eclipse.swt.widgets.Composite)
	 */
	protected void initializeControls(Composite parent) {
		super.initializeControls(parent);
		createFontsAndColorsGroups(composite);		
	}

	/**
	 * Create  fonts and colors group
	 * 
	 * @@param parent - parent composite
	 */
	protected Group createFontsAndColorsGroups(Composite parent) {
		colorsAndFontsGroup = getWidgetFactory().createGroup(parent,
			FONTS_AND_COLORS_LABEL);
		GridLayout layout = new GridLayout(1, false);
		colorsAndFontsGroup.setLayout(layout);

		createFontsGroup(colorsAndFontsGroup);

		return colorsAndFontsGroup;

	}
	
	/**
	 * Create  font tool bar group
	 * 
	 * @@param parent - parent composite
	 * @@return - font tool bar
	 */
	protected Composite createFontsGroup(Composite parent) {
		Composite familySize = getWidgetFactory().createComposite(parent);
		GridLayout layout = new GridLayout(2, false);
		layout.horizontalSpacing = 0;
		layout.verticalSpacing = 0;
		layout.marginHeight = 0;
		layout.marginWidth = 0;
		familySize.setLayout(layout);

		fontFamilyCombo = getWidgetFactory().createCCombo(familySize,
			SWT.DROP_DOWN | SWT.READ_ONLY | SWT.BORDER);
		fontFamilyCombo.setItems(FontHelper.getFontNames());
		fontFamilyCombo.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {
				updateFontFamily();
			}
		});

		fontSizeCombo = getWidgetFactory().createCCombo(familySize,
			SWT.DROP_DOWN | SWT.READ_ONLY | SWT.BORDER);
		fontSizeCombo.setItems(FontHelper.getFontSizes());
		fontSizeCombo.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {
				updateFontSize();
			}
		});

		Composite toolBar = new Composite(parent, SWT.SHADOW_NONE);
		toolBar.setLayout(new GridLayout(7, false));
		toolBar.setBackground(parent.getBackground());

		fontBoldButton = new Button(toolBar, SWT.TOGGLE);
		fontBoldButton.setImage(DiagramUIPropertiesImages.get(DiagramUIPropertiesImages.IMG_BOLD));
        fontBoldButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontStyle_Bold;
            }
        });
	
		
		fontItalicButton = new Button(toolBar, SWT.TOGGLE );
		fontItalicButton.setImage(DiagramUIPropertiesImages.get(DiagramUIPropertiesImages.IMG_ITALIC));
        fontItalicButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontStyle_Italic;
            }
        });

		fontBoldButton.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {
				updateFontBold();
			}
		});

		fontItalicButton.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {
				updateFontItalic();
			}
		});

		new Label(toolBar, SWT.LEFT);

		fontColorButton = new Button(toolBar, SWT.PUSH);
		fontColorButton.setImage(DiagramUIPropertiesImages.get(DiagramUIPropertiesImages.IMG_FONT_COLOR));
        fontColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontColor;
            }
        });
		fontColorButton.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {
				changeFontColor(event);
			}
		});

		new Label(toolBar, SWT.LEFT);

		lineColorButton = new Button(toolBar, SWT.PUSH);
		lineColorButton.setImage(DiagramUIPropertiesImages.get(DiagramUIPropertiesImages.IMG_LINE_COLOR));
        lineColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_LineColor;
            }
        });
		lineColorButton.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {				
				changeLineColor(event);
			}
		});

		fillColorButton = new Button(toolBar, SWT.PUSH);
		fillColorButton.setImage(DiagramUIPropertiesImages.get(DiagramUIPropertiesImages.IMG_FILL_COLOR));
		fillColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FillColor;
            }
        });
		fillColorButton.setEnabled(false);

		return toolBar;
	}

	/**
	 * @@return - an itertor object to iterate over the selected/input edit parts
	 */
	protected Iterator getInputIterator() {
		return getInput().iterator();

	}

	/**
	 * Apply line color change
	 * 
	 * @@param event -
	 *            line color button selection event
	 */
	protected void changeLineColor(SelectionEvent event) {
		if (lineColor != null){
			previousColor = FigureUtilities.RGBToInteger(lineColor);	
		}	
		lineColor = changeColor(event, lineColorButton,
			IPreferenceConstants.PREF_LINE_COLOR, Properties.ID_LINECOLOR,
			LINE_COLOR_COMMAND_NAME, DiagramUIPropertiesImages.DESC_LINE_COLOR);
	}

	/**
	 * Apply font color change
	 * 
	 * @@param event -
	 *            font button selection event
	 */
	protected void changeFontColor(SelectionEvent event) {
		if (fontColor != null){
			previousColor = FigureUtilities.RGBToInteger(fontColor);
		}
		fontColor = changeColor(event, fontColorButton,
			IPreferenceConstants.PREF_FONT_COLOR, Properties.ID_FONTCOLOR,
			FONT_COLOR_COMMAND_NAME, DiagramUIPropertiesImages.DESC_FONT_COLOR);
	}

	/**
     * @@param event -
     *            selection event
     * @@param button -
     *            event source
     * @@param preferenceId -
     *            id of the preference of the default color value for that
     *            property
     * @@param propertyId -
     *            id of the property
     * @@param commandName -
     *            name of the command
     * @@param imageDescriptor -
     *            the image to draw overlay on the button after the new color is
     *            set
     * @@return - new RGB color, or null if none selected
     * @@deprecated The preference is not being retrieved from the correct
     *             preference store so it is not needed, use the other
     *             <code>changeColor</code> method.
     */
    protected RGB changeColor(SelectionEvent event, Button button,
            String preferenceId, final String propertyId, String commandName,
            ImageDescriptor imageDescriptor) {

        return changeColor(event, button, propertyId, commandName,
            imageDescriptor);
    }
    
    /**
     * @@param event -
     *            selection event
     * @@param button -
     *            event source
     * @@param propertyId -
     *            id of the property
     * @@param commandName -
     *            name of the command
     * @@param imageDescriptor -
     *            the image to draw overlay on the button after the new color is
     *            set
     * @@return - new RGB color, or null if none selected
     */
    protected RGB changeColor(SelectionEvent event, Button button,
            final String propertyId, String commandName,
            ImageDescriptor imageDescriptor) {

        ColorPalettePopup popup = new ColorPalettePopup(button.getParent()
            .getShell(), IDialogConstants.BUTTON_BAR_HEIGHT);        
        popup.setPreviousColor(previousColor);
        Rectangle r = button.getBounds();
        Point location = button.getParent().toDisplay(r.x, r.y);
        popup.open(new Point(location.x, location.y + r.height));        
        if (popup.getSelectedColor() == null && !popup.useDefaultColor()) {
            return null;
        }        
        // selectedColor should be null if we are to use the default color
        final RGB selectedColor = popup.getSelectedColor();

        final EStructuralFeature feature = (EStructuralFeature) PackageUtil
            .getElement(propertyId);

        // Update model in response to user

        List commands = new ArrayList();
        Iterator it = getInputIterator();

        RGB colorToReturn = selectedColor;
        RGB color = selectedColor;
        while (it.hasNext()) {
            final IGraphicalEditPart ep = (IGraphicalEditPart) it.next();

            color = selectedColor;
            if (popup.useDefaultColor()) {
                Object preferredValue = ep.getPreferredValue(feature);
                if (preferredValue instanceof Integer) {
                    color = FigureUtilities
                        .integerToRGB((Integer) preferredValue);
                }
            }
                
            // If we are using default colors, we want to return the color of the first selected element to be consistent
            if (colorToReturn == null) {
                colorToReturn = color;
            }

            if (color != null) {
                final RGB finalColor = color; // need a final variable
               commands.add(createCommand(commandName, ((View) ep.getModel())
                    .eResource(), new Runnable() {

                    public void run() {
                        ENamedElement element = PackageUtil
                            .getElement(propertyId);
                        if (element instanceof EStructuralFeature)
                            ep.setStructuralFeatureValue(feature,
                                FigureUtilities.RGBToInteger(finalColor));
                    }
                }));
            }
        }
        if (!commands.isEmpty()){
	        executeAsCompositeCommand(commandName, commands);
    	    Image overlyedImage = new ColorOverlayImageDescriptor(
            imageDescriptor.getImageData(), color).createImage();
        	disposeImage(button.getImage());
	        button.setImage(overlyedImage);
	    }
        return colorToReturn;
    }
    
	/**
     * Update font property
     */
	protected void updateFontBold() {

		// Update model in response to user

		List commands = new ArrayList();
		Iterator it = getInputIterator();

		while (it.hasNext()) {
			final IGraphicalEditPart ep = (IGraphicalEditPart) it.next();
			commands.add(createCommand(FONT_COMMAND_NAME,
				((View) ep.getModel()).eResource(), new Runnable() {

					public void run() {
						ep.setStructuralFeatureValue(NotationPackage.eINSTANCE.getFontStyle_Bold(),
							Boolean.valueOf(fontBoldButton.getSelection()));
					}
				}));
		}

		executeAsCompositeCommand(FONT_COMMAND_NAME, commands);

	}

	/**
	 * Update font property
	 */
	protected void updateFontItalic() {

		// Update model in response to user
		List commands = new ArrayList();
		Iterator it = getInputIterator();

		while (it.hasNext()) {
			final IGraphicalEditPart ep = (IGraphicalEditPart) it.next();
			commands.add(createCommand(FONT_COMMAND_NAME,
				((View) ep.getModel()).eResource(), new Runnable() {

					public void run() {
						ep.setStructuralFeatureValue(NotationPackage.eINSTANCE.getFontStyle_Italic(),
							new Boolean(fontItalicButton.getSelection()));
					}
				}));
		}

		executeAsCompositeCommand(FONT_COMMAND_NAME, commands);
	}

	/**
	 * Update font family property
	 */
	protected void updateFontFamily() {

		// Update model in response to user
		if (fontFamilyCombo.getText() != null
			|| !fontFamilyCombo.getText().equals("")) { //$NON-NLS-1$
			List commands = new ArrayList();
			Iterator it = getInputIterator();

			while (it.hasNext()) {
				final IGraphicalEditPart ep = (IGraphicalEditPart) it.next();
				commands.add(createCommand(FONT_COMMAND_NAME, ((View) ep
					.getModel()).eResource(), new Runnable() {

					public void run() {
						ep.setStructuralFeatureValue(NotationPackage.eINSTANCE.getFontStyle_FontName(),
							fontFamilyCombo.getText());
					}
				}));
			}

			executeAsCompositeCommand(FONT_COMMAND_NAME, commands);
		}
	}

	/**
	 * Update font size property
	 */
	protected void updateFontSize() {

		// Update model in response to user
		if (fontSizeCombo.getText() != null
			|| !fontSizeCombo.getText().equals("")) { //$NON-NLS-1$
			List commands = new ArrayList();
			Iterator it = getInputIterator();

			while (it.hasNext()) {
				final IGraphicalEditPart ep = (IGraphicalEditPart) it.next();
				commands.add(createCommand(FONT_COMMAND_NAME, ((View) ep
					.getModel()).eResource(), new Runnable() {

					public void run() {
						ep.setStructuralFeatureValue(NotationPackage.eINSTANCE.getFontStyle_FontHeight(),
							new Integer(fontSizeCombo.getText()));
					}
				}));
			}

			executeAsCompositeCommand(FONT_COMMAND_NAME, commands);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.ui.views.properties.tabbed.ISection#refresh()
	 */
	public void refresh() {
		if(!isDisposed()){
            Image overlyedImage = new ColorOverlayImageDescriptor(
				DiagramUIPropertiesImages.DESC_FONT_COLOR.getImageData(),
				fontColor).createImage();
            disposeImage(fontColorButton.getImage());
            fontColorButton.setImage(overlyedImage);

            overlyedImage = new ColorOverlayImageDescriptor(
				DiagramUIPropertiesImages.DESC_LINE_COLOR.getImageData(),
				lineColor).createImage();
            disposeImage(lineColorButton.getImage());
            lineColorButton.setImage(overlyedImage);

		executeAsReadAction(new Runnable() {

			public void run() {

				IGraphicalEditPart ep = getSingleInput();
				if (ep != null) {

                    boolean isReadOnly = isReadOnly();
                    lineColorButton.setEnabled(!isReadOnly);
                    fillColorButton.setEnabled(!isReadOnly);

					Style style = ep.getNotationView().getStyle(NotationPackage.eINSTANCE.getFontStyle());
					boolean enableFontWidgets = (style != null) && !isReadOnly;
                    
                    fontFamilyCombo.setEnabled(enableFontWidgets);
					fontSizeCombo.setEnabled(enableFontWidgets);
					fontBoldButton.setEnabled(enableFontWidgets);
					fontItalicButton.setEnabled(enableFontWidgets);
					fontColorButton.setEnabled(enableFontWidgets);
					
					fontFamilyCombo.setText((String) getSingleInput()
						.getStructuralFeatureValue(NotationPackage.eINSTANCE.getFontStyle_FontName()));
					fontSizeCombo.setText(Integer
						.toString(((Integer) getSingleInput().getStructuralFeatureValue(
							NotationPackage.eINSTANCE.getFontStyle_FontHeight())).intValue()));
					fontBoldButton.setSelection(((Boolean) getSingleInput()
						.getStructuralFeatureValue(NotationPackage.eINSTANCE.getFontStyle_Bold()))
						.booleanValue());
					fontItalicButton.setSelection(((Boolean) getSingleInput()
						.getStructuralFeatureValue(NotationPackage.eINSTANCE.getFontStyle_Italic()))
						.booleanValue());
				}
			}
		});
		}

	}

	/**
	 * Update if nessesary, upon receiving the model event. This event will only
	 * be processed when the reciever is visible (the default behavior is not to
	 * listen to the model events while not showing). Therefore it is safe to
	 * refresh the UI. Sublclasses, which will choose to override event
	 * listening behavior should take into account that the model events are
	 * sent all the time - regardless of the section visibility. Thus special
	 * care should be taken by the section that will choose to listen to such
	 * events all the time. Also, the default implementation of this method
	 * synchronizes on the GUI thread. The subclasses that overwrite it should
	 * do the same if they perform any GUI work (because events may be sent from
	 * a non-GUI thread).
	 * 
	 * @@see #aboutToBeShown()
	 * @@see #aboutToBeHidden()
	 * 
	 * @@param notification
	 *            notification object
	 * @@param element
	 *            element that has changed
	 */
	public void update(final Notification notification, final EObject element) {
		if (!isDisposed() && isCurrentSelection(notification, element)) {
			postUpdateRequest(new Runnable() {

				public void run() {
					if (!isDisposed()
						&& isCurrentSelection(notification, element)
						&& !isNotifierDeleted(notification))
						updateColorCache();
					refresh();

				}
			});
		}
	}

	/**
	 * react to selection or model change - updatye local cache
	 */
	protected void updateColorCache() {

		executeAsReadAction(new Runnable() {

			public void run() {

				IGraphicalEditPart ep = getSingleInput();
				if (ep != null) {
					fontColor = FigureUtilities.integerToRGB((Integer) ep
						.getStructuralFeatureValue(NotationPackage.eINSTANCE.getFontStyle_FontColor()));
					lineColor = FigureUtilities.integerToRGB((Integer) ep
						.getStructuralFeatureValue(NotationPackage.eINSTANCE.getLineStyle_LineColor()));
				}
			}
		});

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.ui.views.properties.tabbed.ISection#setInput(org.eclipse.ui.IWorkbenchPart,
	 *      org.eclipse.jface.viewers.ISelection)
	 */
	public void setInput(IWorkbenchPart part, ISelection selection) {
		super.setInput(part, selection);
		updateColorCache();
	}

    /**
     * Dispose the image if it was created locally to avoid a leak. Do not
     * dispose the images in the registry.
     * 
     * @@param image
     */
    protected void disposeImage(Image image) {
        if (image == null) {
            return;
        }
        
        if (image.equals(DiagramUIPropertiesImages
            .get(DiagramUIPropertiesImages.IMG_FILL_COLOR))
            || image.equals(DiagramUIPropertiesImages
                .get(DiagramUIPropertiesImages.IMG_LINE_COLOR))
            || image.equals(DiagramUIPropertiesImages
                .get(DiagramUIPropertiesImages.IMG_FONT_COLOR))) {
            return;
        }

        if (! image.isDisposed()) {
            image.dispose();
        }
    }

    public void dispose() {
        if (fontColorButton != null && ! fontColorButton.isDisposed()) {
            disposeImage(fontColorButton.getImage());
        }
        if (lineColorButton != null && ! lineColorButton.isDisposed()) {
            disposeImage(lineColorButton.getImage());
        }
        if (fillColorButton != null && ! fillColorButton.isDisposed()) {
            disposeImage(fillColorButton.getImage());
        }
        super.dispose();
    }
    
    protected boolean digIntoGroups() {
        return true;
    }
}
@


1.23
log
@[147497] gmf-head carson_li 071206 [Properties] Buttons on the appearance tab should be DROP_DOWN style
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2007 IBM Corporation and others.
a40 1
import org.eclipse.swt.accessibility.ACC;
d56 1
a56 2
import org.eclipse.swt.widgets.ToolBar;
import org.eclipse.swt.widgets.ToolItem;
d90 1
a90 1
	protected ToolItem fillColorButton;
d100 1
a100 3
	private ToolBar toolBar;
	
	private ToolItem fontBoldButton;
d102 1
a102 1
	private ToolItem fontItalicButton;
d107 1
a107 1
	protected ToolItem fontColorButton;
d109 1
a109 1
    protected ToolItem lineColorButton;
d230 1
a230 1
	    toolBar = new ToolBar(parent, SWT.FLAT);
d234 16
a249 1
		fontBoldButton = new ToolItem(toolBar, SWT.CHECK);
a250 1
		fontBoldButton.setImage(DiagramUIPropertiesImages.get(DiagramUIPropertiesImages.IMG_BOLD));
d252 1
d256 1
a256 2
		});		
		fontBoldButton.setToolTipText(DiagramUIMessages.FontStyleAction_bold_tooltip);		
a257 3
		fontItalicButton = new ToolItem(toolBar, SWT.CHECK );
		fontItalicButton.setImage(DiagramUIPropertiesImages.get(DiagramUIPropertiesImages.IMG_ITALIC));
		fontItalicButton.setToolTipText(DiagramUIMessages.PropertyDescriptorFactory_FontStyle_Italic);
d259 1
d265 3
a267 1
		fontColorButton = new ToolItem(toolBar, SWT.DROP_DOWN);
d269 5
a273 1
		fontColorButton.setToolTipText(DiagramUIMessages.PropertyDescriptorFactory_FontColor);
d275 1
d281 3
a283 1
		lineColorButton = new ToolItem(toolBar,  SWT.DROP_DOWN);
d285 5
a289 1
		lineColorButton.setToolTipText(DiagramUIMessages.PropertyDescriptorFactory_LineColor);
d291 1
d297 1
a297 1
		fillColorButton = new ToolItem(toolBar,  SWT.DROP_DOWN);
d299 5
a303 1
		fillColorButton.setToolTipText(DiagramUIMessages.PropertyDescriptorFactory_FillColor);
d305 1
a305 14
		
		toolBar.getAccessible().addAccessibleListener(new AccessibleAdapter() {	
			public void getName(AccessibleEvent e) {
				if (e.childID != ACC.CHILDID_SELF) {
					ToolItem item = toolBar.getItem(e.childID);
					if (item != null) {
						String toolTip = item.getToolTipText();
						if (toolTip != null) {
							e.result = toolTip;
						}
					}
				}
			}
		});		
a374 28
	/**
     * @@param event -
     *            selection event
     * @@param toolItem -
     *            event source
     * @@param preferenceId -
     *            id of the preference of the default color value for that
     *            property
     * @@param propertyId -
     *            id of the property
     * @@param commandName -
     *            name of the command
     * @@param imageDescriptor -
     *            the image to draw overlay on the button after the new color is
     *            set
     * @@return - new RGB color, or null if none selected
     * @@deprecated The preference is not being retrieved from the correct
     *             preference store so it is not needed, use the other
     *             <code>changeColor</code> method.
     */
    protected RGB changeColor(SelectionEvent event, ToolItem toolItem,
            String preferenceId, final String propertyId, String commandName,
            ImageDescriptor imageDescriptor) {

        return  changeColor(event, toolItem, propertyId, commandName,
            imageDescriptor);
    }
    
a456 82
    /**
     * @@param event -
     *            selection event
     * @@param toolItem -
     *            event source
     * @@param propertyId -
     *            id of the property
     * @@param commandName -
     *            name of the command
     * @@param imageDescriptor -
     *            the image to draw overlay on the button after the new color is
     *            set
     * @@return - new RGB color, or null if none selected
     */
    protected RGB changeColor(SelectionEvent event, ToolItem toolItem,
            final String propertyId, String commandName,
            ImageDescriptor imageDescriptor) {

        ColorPalettePopup popup = new ColorPalettePopup(toolItem.getParent()
            .getShell(), IDialogConstants.BUTTON_BAR_HEIGHT);        
        popup.setPreviousColor(previousColor);
        Rectangle r = toolItem.getBounds();
        Point location = toolItem.getParent().toDisplay(r.x, r.y);
        popup.open(new Point(location.x, location.y + r.height));        
        if (popup.getSelectedColor() == null && !popup.useDefaultColor()) {
            return null;
        }        
        // selectedColor should be null if we are to use the default color
        final RGB selectedColor = popup.getSelectedColor();

        final EStructuralFeature feature = (EStructuralFeature) PackageUtil
            .getElement(propertyId);

        // Update model in response to user

        List commands = new ArrayList();
        Iterator it = getInputIterator();

        RGB colorToReturn = selectedColor;
        RGB color = selectedColor;
        while (it.hasNext()) {
            final IGraphicalEditPart ep = (IGraphicalEditPart) it.next();

            color = selectedColor;
            if (popup.useDefaultColor()) {
                Object preferredValue = ep.getPreferredValue(feature);
                if (preferredValue instanceof Integer) {
                    color = FigureUtilities
                        .integerToRGB((Integer) preferredValue);
                }
            }
                
            // If we are using default colors, we want to return the color of the first selected element to be consistent
            if (colorToReturn == null) {
                colorToReturn = color;
            }

            if (color != null) {
                final RGB finalColor = color; // need a final variable
               commands.add(createCommand(commandName, ((View) ep.getModel())
                    .eResource(), new Runnable() {

                    public void run() {
                        ENamedElement element = PackageUtil
                            .getElement(propertyId);
                        if (element instanceof EStructuralFeature)
                            ep.setStructuralFeatureValue(feature,
                                FigureUtilities.RGBToInteger(finalColor));
                    }
                }));
            }
        }
        if (!commands.isEmpty()){
	        executeAsCompositeCommand(commandName, commands);
    	    Image overlyedImage = new ColorOverlayImageDescriptor(
            imageDescriptor.getImageData(), color).createImage();
        	disposeImage(toolItem.getImage());
        	toolItem.setImage(overlyedImage);
	    }
        return colorToReturn;
    }
    
@


1.22
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@d41 1
d57 2
a58 1
import org.eclipse.swt.widgets.Label;
d92 1
a92 1
	protected Button fillColorButton;
d102 3
a104 1
	private Button fontBoldButton;
d106 1
a106 1
	private Button fontItalicButton;
d111 1
a111 1
	protected Button fontColorButton;
d113 1
a113 1
    protected Button lineColorButton;
d234 1
a234 1
		Composite toolBar = new Composite(parent, SWT.SHADOW_NONE);
d238 2
a239 1
		fontBoldButton = new Button(toolBar, SWT.TOGGLE);
a240 15
        fontBoldButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontStyle_Bold;
            }
        });
	
		
		fontItalicButton = new Button(toolBar, SWT.TOGGLE );
		fontItalicButton.setImage(DiagramUIPropertiesImages.get(DiagramUIPropertiesImages.IMG_ITALIC));
        fontItalicButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontStyle_Italic;
            }
        });

a241 1

d245 2
a246 1
		});
d248 3
a251 1

d257 1
a257 3
		new Label(toolBar, SWT.LEFT);

		fontColorButton = new Button(toolBar, SWT.PUSH);
d259 1
a259 5
        fontColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontColor;
            }
        });
a260 1

d266 1
a266 3
		new Label(toolBar, SWT.LEFT);

		lineColorButton = new Button(toolBar, SWT.PUSH);
d268 1
a268 5
        lineColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_LineColor;
            }
        });
a269 1

d275 1
a275 1
		fillColorButton = new Button(toolBar, SWT.PUSH);
d277 1
a277 5
		fillColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FillColor;
            }
        });
d279 14
a292 1

d362 28
d472 82
@


1.21
log
@[183150] gmf_head crevells 071106 [RulersGrid] Properties view: Rulers and Grid page: Custom color dialog should use currently selected color
Contributed by:  Carson Li
@
text
@d724 4
@


1.20
log
@[166068] gmf_head wdiu 070109 ColorsAndFontsPropertySection is overwriting read only enablement on the refresh
@
text
@d103 15
a118 4
	/**
	 * An image descriptor that overlays two images: a basic icon and a thin
	 * color bar underneath it
	 */
d168 2
a169 17
	}

	/** the default preference color */
	protected static final RGB DEFAULT_PREF_COLOR = new RGB(0, 0, 0);

	protected Button fontColorButton;

    protected Button lineColorButton;

	protected RGB fontColor;

	protected RGB lineColor;

	protected Group colorsAndFontsGroup;



d292 1
a292 1
			public void widgetSelected(SelectionEvent event) {
d324 3
d339 3
d394 2
a395 2
            .getShell(), IDialogConstants.BUTTON_BAR_HEIGHT);

d398 1
a398 2
        popup.open(new Point(location.x, location.y + r.height));

d401 1
a401 2
        }

@


1.20.4.1
log
@[183150] gmf_R2_0_maintenance crevells 071106 [RulersGrid] Properties view: Rulers and Grid page: Custom color dialog should use currently selected color
Contributed by:  Carson Li
@
text
@a102 15
	
	/** the default preference color */
	protected static final RGB DEFAULT_PREF_COLOR = new RGB(0, 0, 0);

	protected Button fontColorButton;

    protected Button lineColorButton;

	protected RGB fontColor;

	protected RGB lineColor;

	protected Group colorsAndFontsGroup;

	protected int previousColor;
d104 4
d157 17
a173 2
	}   	
	
d296 1
a296 1
			public void widgetSelected(SelectionEvent event) {				
a327 3
		if (lineColor != null){
			previousColor = FigureUtilities.RGBToInteger(lineColor);	
		}	
a339 3
		if (fontColor != null){
			previousColor = FigureUtilities.RGBToInteger(fontColor);
		}
d392 2
a393 2
            .getShell(), IDialogConstants.BUTTON_BAR_HEIGHT);        
        popup.setPreviousColor(previousColor);
d396 2
a397 1
        popup.open(new Point(location.x, location.y + r.height));        
d400 2
a401 1
        }        
@


1.20.2.1
log
@[111892] gmf_head crevells 070518 First milestone of group/ungroup support (painting issues when grouping shapes with border items)
@
text
@a723 4
    
    protected boolean digIntoGroups() {
        return true;
    }
@


1.19
log
@ [162777]   gmf_head mmostafa 061123 diagram appearance properties : apply a color property change to diagram, all shapes updated, undo only works for one shape
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
a309 9
		if (isReadOnly()) {
			lineColorButton.setEnabled(false);
			fontFamilyCombo.setEnabled(false);
			fontSizeCombo.setEnabled(false);
			fontBoldButton.setEnabled(false);
			fontItalicButton.setEnabled(false);
			fontColorButton.setEnabled(false);
		}

d587 4
d592 3
a594 3
					boolean enableFontWidgets = style != null;
					
					fontFamilyCombo.setEnabled(enableFontWidgets);
@


1.18
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d423 1
a423 1

d427 1
a427 1
            RGB color = selectedColor;
a454 6

            executeAsCompositeCommand(commandName, commands);
            Image overlyedImage = new ColorOverlayImageDescriptor(
                imageDescriptor.getImageData(), color).createImage();
            disposeImage(button.getImage());
            button.setImage(overlyedImage);
d456 7
@


1.17
log
@[139970] gmf_head ahunter 060503 NPE in ColorsAndFontsPropertySection
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d26 1
d41 2
d240 5
d249 5
d273 5
a277 1

d289 5
a293 1

d303 5
a307 1

d355 61
a415 50
	 * @@param event -
	 *            selection event
	 * @@param button -
	 *            event source
	 * @@param preferenceId -
	 *            id of the preference of the default color value for that
	 *            property
	 * @@param propertyId -
	 *            id of the property
	 * @@param commandName -
	 *            name of the command
	 * @@param imageDescriptor -
	 *            the image to draw overlay on the button after the new
	 *            color is set
	 * @@return - new RGB color, or null if none selected
	 */
	protected RGB changeColor(SelectionEvent event, Button button,
			String preferenceId, final String propertyId, String commandName,
			ImageDescriptor imageDescriptor) {

		ColorPalettePopup popup = new ColorPalettePopup(button.getParent()
			.getShell(), preferenceId, IDialogConstants.BUTTON_BAR_HEIGHT);

		Rectangle r = button.getBounds();
		Point location = button.getParent().toDisplay(r.x, r.y);
		popup.open(new Point(location.x, location.y + r.height));
		if (popup.getSelectedColor() != null) {
			final RGB color = popup.getSelectedColor();

			// Update model in response to user

			if (color != null) {

				List commands = new ArrayList();
				Iterator it = getInputIterator();

				while (it.hasNext()) {
					final IGraphicalEditPart ep = (IGraphicalEditPart) it
						.next();
					commands.add(createCommand(commandName, ((View) ep
						.getModel()).eResource(), new Runnable() {

						public void run() {
							ENamedElement element = PackageUtil.getElement(propertyId);
							if (element instanceof EStructuralFeature)
								ep.setStructuralFeatureValue((EStructuralFeature)PackageUtil.getElement(propertyId), FigureUtilities
									.RGBToInteger(color));
						}
					}));
				}
d417 1
a417 6
				executeAsCompositeCommand(commandName, commands);
				Image overlyedImage = new ColorOverlayImageDescriptor(
					imageDescriptor.getImageData(), color).createImage();
                disposeImage(button.getImage());
				button.setImage(overlyedImage);
			}
d419 36
a454 3
			return color;
		}
		return null;
d456 9
a464 1
	}
d466 2
a467 2
	 * Update font property
	 */
a512 1
		getSingleInput().refresh();
@


1.17.2.1
log
@Bugzilla#146690 gmf_R1_0_maintenance cmahoney 060711 Inconsistent default colours
@
text
@d330 50
a379 22
     * @@param event -
     *            selection event
     * @@param button -
     *            event source
     * @@param preferenceId -
     *            id of the preference of the default color value for that
     *            property
     * @@param propertyId -
     *            id of the property
     * @@param commandName -
     *            name of the command
     * @@param imageDescriptor -
     *            the image to draw overlay on the button after the new color is
     *            set
     * @@return - new RGB color, or null if none selected
     * @@deprecated The preference is not being retrieved from the correct
     *             preference store so it is not needed, use the other
     *             <code>changeColor</code> method.
     */
    protected RGB changeColor(SelectionEvent event, Button button,
            String preferenceId, final String propertyId, String commandName,
            ImageDescriptor imageDescriptor) {
d381 6
a386 28
        return changeColor(event, button, propertyId, commandName,
            imageDescriptor);
    }
    
    /**
     * @@param event -
     *            selection event
     * @@param button -
     *            event source
     * @@param propertyId -
     *            id of the property
     * @@param commandName -
     *            name of the command
     * @@param imageDescriptor -
     *            the image to draw overlay on the button after the new color is
     *            set
     * @@return - new RGB color, or null if none selected
     */
    protected RGB changeColor(SelectionEvent event, Button button,
            final String propertyId, String commandName,
            ImageDescriptor imageDescriptor) {

        ColorPalettePopup popup = new ColorPalettePopup(button.getParent()
            .getShell(), IDialogConstants.BUTTON_BAR_HEIGHT);

        Rectangle r = button.getBounds();
        Point location = button.getParent().toDisplay(r.x, r.y);
        popup.open(new Point(location.x, location.y + r.height));
d388 3
a390 3
        if (popup.getSelectedColor() == null && !popup.useDefaultColor()) {
            return null;
        }
d392 1
a392 54
        // selectedColor should be null if we are to use the default color
        final RGB selectedColor = popup.getSelectedColor();

        final EStructuralFeature feature = (EStructuralFeature) PackageUtil
            .getElement(propertyId);

        // Update model in response to user

        List commands = new ArrayList();
        Iterator it = getInputIterator();

        RGB colorToReturn = selectedColor;

        while (it.hasNext()) {
            final IGraphicalEditPart ep = (IGraphicalEditPart) it.next();

            RGB color = selectedColor;
            if (popup.useDefaultColor()) {
                Object preferredValue = ep.getPreferredValue(feature);
                if (preferredValue instanceof Integer) {
                    color = FigureUtilities
                        .integerToRGB((Integer) preferredValue);
                }
            }
                
            // If we are using default colors, we want to return the color of the first selected element to be consistent
            if (colorToReturn == null) {
                colorToReturn = color;
            }

            if (color != null) {
                final RGB finalColor = color; // need a final variable
               commands.add(createCommand(commandName, ((View) ep.getModel())
                    .eResource(), new Runnable() {

                    public void run() {
                        ENamedElement element = PackageUtil
                            .getElement(propertyId);
                        if (element instanceof EStructuralFeature)
                            ep.setStructuralFeatureValue(feature,
                                FigureUtilities.RGBToInteger(finalColor));
                    }
                }));
            }

            executeAsCompositeCommand(commandName, commands);
            Image overlyedImage = new ColorOverlayImageDescriptor(
                imageDescriptor.getImageData(), color).createImage();
            disposeImage(button.getImage());
            button.setImage(overlyedImage);
        }
        return colorToReturn;
    }
    
d394 2
a395 2
     * Update font property
     */
@


1.17.2.2
log
@Bugzilla#153962 gmf_R1_0_maintenance cmahoney 060821
NPE thrown when trying to set font style on blank diagram [Contributed By: Syed Atif]
@
text
@d488 1
@


1.17.2.3
log
@Bugzilla#144685 gmf_R1_0_maintenance cmahoney 060824 Diagram property pages are not accessible
@
text
@a25 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
a39 2
import org.eclipse.swt.accessibility.AccessibleAdapter;
import org.eclipse.swt.accessibility.AccessibleEvent;
a236 5
        fontBoldButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontStyle_Bold;
            }
        });
a240 5
        fontItalicButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontStyle_Italic;
            }
        });
d260 1
a260 5
        fontColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FontColor;
            }
        });
d272 1
a272 5
        lineColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_LineColor;
            }
        });
d282 1
a282 5
		fillColorButton.getAccessible().addAccessibleListener(new AccessibleAdapter() {
            public void getName(AccessibleEvent e) {
                e.result = DiagramUIMessages.PropertyDescriptorFactory_FillColor;
            }
        });
@


1.17.2.4
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
@


1.17.2.5
log
@ [162777]   gmf_R1_0_maintenace mmostafa 061123 diagram appearance properties : apply a color property change to diagram, all shapes updated, undo only works for one shape
@
text
@d423 1
a423 1
        RGB color = selectedColor;
d427 1
a427 1
            color = selectedColor;
d455 6
a461 7
        if (!commands.isEmpty()){
	        executeAsCompositeCommand(commandName, commands);
    	    Image overlyedImage = new ColorOverlayImageDescriptor(
            imageDescriptor.getImageData(), color).createImage();
        	disposeImage(button.getImage());
	        button.setImage(overlyedImage);
	    }
@


1.17.2.6
log
@[166068] gmf_R1_0_maintenance wdiu 070109 ColorsAndFontsPropertySection is overwriting read only enablement on the refresh
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2007 IBM Corporation and others.
d310 9
a595 4
                    boolean isReadOnly = isReadOnly();
                    lineColorButton.setEnabled(!isReadOnly);
                    fillColorButton.setEnabled(!isReadOnly);

d597 3
a599 3
					boolean enableFontWidgets = (style != null) && !isReadOnly;
                    
                    fontFamilyCombo.setEnabled(enableFontWidgets);
@


1.16
log
@[126413] gmf_head ahunter 060427 ShapeColorsAndFontsPropertySection.refresh and ColorsAndFontsPropertySection.refresh leak image handles
@
text
@d646 1
a646 1
        if (! fontColorButton.isDisposed()) {
d649 1
a649 1
        if (! lineColorButton.isDisposed()) {
d652 1
a652 1
        if (! fillColorButton.isDisposed()) {
@


1.15
log
@[126413] gmf_head ndoyle 060427 ShapeColorsAndFontsPropertySection.refresh and ColorsAndFontsPropertySection.refresh leak image handles
@
text
@d161 1
a161 1
	protected Button lineColorButton;
d190 1
a190 1
		/*Composite toolBar = */createFontsGroup(colorsAndFontsGroup);
a191 8
		//CoolItem coolItem = new CoolItem(coolBar, SWT.NULL);
		// set the control of the coolItem
		//coolItem.setControl(toolBar);
		// You have to specify the size
		//Point size = toolBar.computeSize(SWT.DEFAULT, SWT.DEFAULT);
		//Point coolSize = coolItem.computeSize(size.x, size.y);
		//coolItem.setSize(coolSize);
		
d384 1
d505 1
a505 1
		Image overlyedImage = new ColorOverlayImageDescriptor(
d508 2
a509 1
		fontColorButton.setImage(overlyedImage);
d511 1
a511 1
		overlyedImage = new ColorOverlayImageDescriptor(
d514 2
a515 1
		lineColorButton.setImage(overlyedImage);
d620 37
@


1.14
log
@[126413] gmf_head ndoyle 060427 ShapeColorsAndFontsPropertySection.refresh and ColorsAndFontsPropertySection.refresh leak image handles
@
text
@a515 1
		overlyedImage.dispose();
a520 1
		overlyedImage.dispose();
@


1.13
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@a40 2
import org.eclipse.swt.events.PaintEvent;
import org.eclipse.swt.events.PaintListener;
a42 1
import org.eclipse.swt.graphics.GC;
d50 1
a51 2
import org.eclipse.swt.widgets.CoolBar;
import org.eclipse.swt.widgets.CoolItem;
d53 1
a53 2
import org.eclipse.swt.widgets.ToolBar;
import org.eclipse.swt.widgets.ToolItem;
d87 1
a87 1
	protected ToolItem fillColorButton;
d97 1
a97 1
	private ToolItem fontBoldButton;
d99 1
a99 1
	private ToolItem fontItalicButton;
d159 1
a159 1
	protected ToolItem fontColorButton;
d161 1
a161 1
	protected ToolItem lineColorButton;
a166 2
	private CoolBar coolBar;

d175 1
a175 1
		createPaintedSectionComposite(parent);
d190 1
a190 1
		ToolBar toolBar = createFontsGroup(colorsAndFontsGroup);
d192 1
a192 1
		CoolItem coolItem = new CoolItem(coolBar, SWT.NULL);
d194 1
a194 1
		coolItem.setControl(toolBar);
d196 3
a198 21
		Point size = toolBar.computeSize(SWT.DEFAULT, SWT.DEFAULT);
		Point coolSize = coolItem.computeSize(size.x, size.y);
		coolItem.setSize(coolSize);

		colorsAndFontsGroup.addPaintListener(new PaintListener() {

			public void paintControl(PaintEvent e) {
				Rectangle bounds = colorsAndFontsGroup.getClientArea();
				GC gc = e.gc;

				gc.setForeground(gc.getBackground());
				gc.setBackground(coolBar.getBackground());

				gc.fillGradientRectangle(1, bounds.height / 2,
					bounds.width + 3, bounds.height - 14, true);

			}

		}

		);
d210 1
a210 1
	protected ToolBar createFontsGroup(Composite parent) {
d239 3
a241 2
		coolBar = new CoolBar(parent, SWT.BORDER);
		ToolBar toolBar = new ToolBar(coolBar, SWT.FLAT);
d243 1
a243 1
		fontBoldButton = new ToolItem(toolBar, SWT.CHECK);
d247 1
a247 1
		fontItalicButton = new ToolItem(toolBar, SWT.CHECK );
d264 1
a264 1
		new ToolItem(toolBar, SWT.SEPARATOR);
d266 1
a266 1
		fontColorButton = new ToolItem(toolBar, SWT.DROP_DOWN);
d276 1
a276 1
		new ToolItem(toolBar, SWT.SEPARATOR);
d278 1
a278 1
		lineColorButton = new ToolItem(toolBar, SWT.DROP_DOWN);
d288 1
a288 1
		fillColorButton = new ToolItem(toolBar, SWT.DROP_DOWN);
d354 1
a354 1
	protected RGB changeColor(SelectionEvent event, ToolItem button,
d516 1
d522 1
@


1.12
log
@gmf_head ahunter 060210 Migrate GMF usage of tabbed properties view from WTP to Eclipse Core (org.eclipse.wst.common.ui.properties to org.eclipse.ui.views.properties.tabbed)
@
text
@d31 1
a31 2
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.emf.core.util.MetaModelUtil;
d405 1
a405 1
							ENamedElement element = MetaModelUtil.getElement(propertyId);
d407 1
a407 1
								ep.setStructuralFeatureValue((EStructuralFeature)MetaModelUtil.getElement(propertyId), FigureUtilities
d546 1
a546 1
		executeAsReadAction(new MRunnable() {
d548 1
a548 1
			public Object run() {
a573 2

				return null;
d622 1
a622 1
		executeAsReadAction(new MRunnable() {
d624 1
a624 1
			public Object run() {
a632 2

				return null;
@


1.11
log
@Bugzilla#109422 gmf_head cmahoney 060126 Deleting deprecated classes
@
text
@d533 1
a533 1
	 * @@see org.eclipse.wst.common.ui.properties.internal.provisional.ISection#refresh()
d646 1
a646 1
	 * @@see org.eclipse.wst.common.ui.properties.internal.provisional.ISection#setInput(org.eclipse.ui.IWorkbenchPart,
@


1.10
log
@bugzilla 123310 gmf-head sshaw 060116 FontSize is enabled while selecting a note attachment
@
text
@a373 66
	 * @@param imageName -
	 *            name of the image to draw overlay on the button after the new
	 *            color is set
	 * @@return - new RGB color, or null if none selected
	 * @@deprecated Use {@@link #changeColor(SelectionEvent, ToolItem, String, String, String, ImageDescriptor) instead and pass in the image descriptor itself.  To be removed on: 05/12/26
	 */
	protected RGB changeColor(SelectionEvent event, ToolItem button,
			String preferenceId, final String propertyId, String commandName,
			String imageName) {

		ColorPalettePopup popup = new ColorPalettePopup(button.getParent()
			.getShell(), preferenceId, IDialogConstants.BUTTON_BAR_HEIGHT);

		Rectangle r = button.getBounds();
		Point location = button.getParent().toDisplay(r.x, r.y);
		popup.open(new Point(location.x, location.y + r.height));
		if (popup.getSelectedColor() != null) {
			final RGB color = popup.getSelectedColor();

			// Update model in response to user

			if (color != null) {

				List commands = new ArrayList();
				Iterator it = getInputIterator();

				while (it.hasNext()) {
					final IGraphicalEditPart ep = (IGraphicalEditPart) it
						.next();
					commands.add(createCommand(commandName, ((View) ep
						.getModel()).eResource(), new Runnable() {

						public void run() {
							ENamedElement element = MetaModelUtil.getElement(propertyId);
							if (element instanceof EStructuralFeature)
								ep.setStructuralFeatureValue((EStructuralFeature)MetaModelUtil.getElement(propertyId), FigureUtilities
									.RGBToInteger(color));
						}
					}));
				}

				executeAsCompositeCommand(commandName, commands);
				Image overlyedImage = new ColorOverlayImageDescriptor(
					DiagramUIPropertiesImages.get(imageName)
						.getImageData(), color).createImage();
				button.setImage(overlyedImage);
			}

			return color;
		}
		return null;

	}

	/**
	 * @@param event -
	 *            selection event
	 * @@param button -
	 *            event source
	 * @@param preferenceId -
	 *            id of the preference of the default color value for that
	 *            property
	 * @@param propertyId -
	 *            id of the property
	 * @@param commandName -
	 *            name of the command
@


1.9
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d321 1
a321 1
			fontSizeCombo.setEditable(false);
d407 1
a407 1
							ENamedElement element = (EStructuralFeature)MetaModelUtil.getElement(propertyId);
d472 1
a472 1
							ENamedElement element = (EStructuralFeature)MetaModelUtil.getElement(propertyId);
d624 1
a624 1
					fontSizeCombo.setEditable(enableFontWidgets);
@


1.8
log
@bugzilla 112998 gmf-head sshaw 051117 FontSize, Italic, Bold, FontColor and Fill Color are enabled while selecting a note attachment
@
text
@d27 2
a28 1
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.l10n.ResourceManager;
d38 1
d72 2
a73 2
	protected static final String FONT_COLOR_COMMAND_NAME = ResourceManager
		.getI18NString("FontColor.commandText") + StringStatics.SPACE //$NON-NLS-1$
d76 2
a77 2
	protected static final String LINE_COLOR_COMMAND_NAME = ResourceManager
		.getI18NString("LineColor.commandText") + StringStatics.SPACE //$NON-NLS-1$
d81 2
a82 2
	protected static final String FONT_COMMAND_NAME = ResourceManager
		.getI18NString("Font.commandText") + StringStatics.SPACE //$NON-NLS-1$
d86 2
a87 2
	static protected final String FILL_COLOR_COMMAND_NAME = ResourceManager
		.getI18NString("FillColor.commandText") + StringStatics.SPACE //$NON-NLS-1$
a88 7

	// image names
	protected static final String FILL_COLOR_IMAGE_NAME = "fill_color.gif"; //$NON-NLS-1$

	protected static final String BOLD_IMAGE_NAME = "bold.gif"; //$NON-NLS-1$

	protected static final String ITALIC_IMAGE_NAME = "italic.gif"; //$NON-NLS-1$
d90 2
a91 2
	protected static final String FONTS_AND_COLORS_LABEL = ResourceManager
		.getI18NString("FontAndColor.nameLabel"); //$NON-NLS-1$
a164 6
	private static final String FONT_COLOR_IMAGE_NAME = "font_color.gif"; //$NON-NLS-1$

	private static final String LINE_COLOR_IMAGE_NAME = "line_color.gif"; //$NON-NLS-1$

	

d269 1
a269 2
		fontBoldButton.setImage(ResourceManager.getInstance().getImage(
			BOLD_IMAGE_NAME));
d273 1
a273 2
		fontItalicButton.setImage(ResourceManager.getInstance().getImage(
			ITALIC_IMAGE_NAME));
d292 1
a292 2
		fontColorButton.setImage(ResourceManager.getInstance().getImage(
			FONT_COLOR_IMAGE_NAME));
d304 1
a304 2
		lineColorButton.setImage(ResourceManager.getInstance().getImage(
			LINE_COLOR_IMAGE_NAME));
d314 1
a314 2
		fillColorButton.setImage(ResourceManager.getInstance().getImage(
			FILL_COLOR_IMAGE_NAME));
d347 1
a347 1
			LINE_COLOR_COMMAND_NAME, LINE_COLOR_IMAGE_NAME);
d359 1
a359 1
			FONT_COLOR_COMMAND_NAME, FONT_COLOR_IMAGE_NAME);
d378 1
d417 1
a417 1
					ResourceManager.getInstance().getImage(imageName)
d429 63
d603 3
a605 3
		Image overlyedImage = new ColorOverlayImageDescriptor(ResourceManager
			.getInstance().getImage(FONT_COLOR_IMAGE_NAME).getImageData(),
			fontColor).createImage();
d608 3
a610 3
		overlyedImage = new ColorOverlayImageDescriptor(ResourceManager
			.getInstance().getImage(LINE_COLOR_IMAGE_NAME).getImageData(),
			lineColor).createImage();
@


1.7
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d33 1
d572 9
@


1.6
log
@bugzilla 112685 gmf-head sshaw 051014 Sweep code for creation of Boolean objects
@
text
@a22 1
import org.eclipse.gmf.runtime.diagram.ui.IPreferenceConstants;
d26 1
d60 1
a60 1
 * Colors section to represent line and font properties of a shape or connector
@


1.5
log
@Bugzilla 109092: gmf_head sshaw 050923 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d459 1
a459 1
							new Boolean(fontBoldButton.getSelection()));
@


1.4
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d19 1
d21 13
a58 11
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.diagram.ui.IPreferenceConstants;
import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart;
import org.eclipse.gmf.runtime.diagram.ui.internal.properties.Properties;
import org.eclipse.gmf.runtime.diagram.ui.internal.util.FontHelper;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.l10n.ResourceManager;
import org.eclipse.gmf.runtime.diagram.ui.properties.sections.AbstractNotationPropertiesSection;
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.notation.View;

d421 4
a424 2
							ep.setPropertyValue(propertyId, FigureUtilities
								.RGBToInteger(color));
d458 1
a458 1
						ep.setPropertyValue(Properties.ID_FONTBOLD,
d483 1
a483 1
						ep.setPropertyValue(Properties.ID_FONTITALIC,
d510 1
a510 1
						ep.setPropertyValue(Properties.ID_FONTNAME,
d537 1
a537 1
						ep.setPropertyValue(Properties.ID_FONTSIZE,
d572 1
a572 1
						.getPropertyValue(Properties.ID_FONTNAME));
d574 2
a575 2
						.toString(((Integer) getSingleInput().getPropertyValue(
							Properties.ID_FONTSIZE)).intValue()));
d577 1
a577 1
						.getPropertyValue(Properties.ID_FONTBOLD))
d580 1
a580 1
						.getPropertyValue(Properties.ID_FONTITALIC))
d640 1
a640 1
						.getPropertyValue(Properties.ID_FONTCOLOR));
d642 1
a642 1
						.getPropertyValue(Properties.ID_LINECOLOR));
@


1.3
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d48 1
a49 1
import org.eclipse.gmf.runtime.diagram.ui.properties.Properties;
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d52 1
a52 1
import com.ibm.xtools.notation.View;
@

