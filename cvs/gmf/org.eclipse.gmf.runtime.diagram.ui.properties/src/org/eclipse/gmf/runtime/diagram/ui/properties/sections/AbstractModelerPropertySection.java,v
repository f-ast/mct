head	1.19;
access;
symbols
	v20081020-0700:1.19
	v20080813-1510:1.18.2.1
	v20080811-1546:1.19
	v20080722-1827:1.18
	v20080716-1600:1.18
	v20080716-1642:1.18
	R2_1_maintenance:1.18.0.2
	Root_R2_1_maintenance:1.18
	R2_1_0:1.18
	v20080603-1553:1.18
	v20080521:1.18
	v20080503-1740:1.18
	v20080425-1959:1.18
	v20080417-1610:1.18
	v20080409-1326:1.18
	v20080328-1605:1.18
	v20080222-1200:1.18
	v20080201-2010:1.18
	v20080118-1129:1.15.2.2
	v20080114-2222:1.15.2.1
	v20071222-1111:1.17
	v20071214-1111:1.17
	v20071207-1111:1.17
	v20071130-1111:1.17
	v20071124-0000:1.15.2.1
	v20071108-0000:1.16
	v20071003-0000:1.16
	v20070915-0000:1.15.2.1
	v20070809-0000:1.15
	R2_0_maintenance:1.15.0.2
	R2_0:1.15
	R4_20:1.15
	RC3_20:1.15
	v20070608-1300:1.15
	v20070601-1400:1.14
	v20070518-1300:1.14
	bugzilla111892_group_support:1.14.0.2
	Root_bugzilla111892_group_support:1.14
	v20070405-2000:1.14
	v20070330-1300:1.14
	v20070208-1800:1.14
	v20070202-0200:1.12.2.3
	v20070111-0800:1.12.2.3
	M4_20:1.14
	v20061218-1500:1.12.2.3
	v20061214-0000:1.14
	M3_20:1.14
	v20061013-1330:1.14
	v20061012-1100:1.12.2.3
	v20060919-0800:1.12.2.2
	M1_20:1.12
	v20060824-1600:1.12.2.1
	v20060803-1200:1.12.2.1
	v20060721-1130:1.12.2.1
	v20060713-1700:1.12
	R1_0_maintenance:1.12.0.2
	R1_0:1.12
	v20060627-1200:1.12
	v20060616-1200:1.12
	v20060609-1400:1.12
	v20060531-1730:1.11
	v20060530-1930:1.11
	I20060505-1400:1.11
	I20060428-1300:1.10
	I20060424-0500:1.10
	I20060424-0300:1.10
	M6_10:1.10
	I20060407-1200:1.10
	I20060331-1000:1.9
	I20060324-0300:1.9
	I20060317-1300:1.9
	I20060317-1200:1.9
	I20060316-1300:1.9
	I20060309-1300:1.9
	M5_10:1.9
	S20060303-1600:1.9
	I20060227-1730:1.7
	I20060216-1945:1.7
	I20060210-1715:1.6
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051201-1800:1.5
	I20051124-2000:1.5
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.5
	I20051106-0900:1.4
	v20051030:1.3;
locks; strict;
comment	@# @;


1.19
date	2008.08.08.21.30.20;	author aboyko;	state Exp;
branches;
next	1.18;
commitid	3493489cbaec4567;

1.18
date	2008.01.16.21.52.30;	author ahunter;	state Exp;
branches
	1.18.2.1;
next	1.17;
commitid	12e5478e7c9d4567;

1.17
date	2007.11.21.17.57.23;	author crevells;	state Exp;
branches;
next	1.16;
commitid	49be474471834567;

1.16
date	2007.09.13.19.58.00;	author ahunter;	state Exp;
branches;
next	1.15;
commitid	d3746e996474567;

1.15
date	2007.06.08.14.40.23;	author ahunter;	state Exp;
branches
	1.15.2.1;
next	1.14;
commitid	4ee346696a574567;

1.14
date	2006.10.10.21.25.30;	author ldamus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2006.10.03.15.02.59;	author ahunter;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.07.17.43.40;	author ahunter;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2006.05.02.18.00.45;	author cmahoney;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.06.20.30.22;	author ldamus;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.02.21.58.29;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.28.02.31.04;	author cmahoney;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.13.19.11.07;	author ldamus;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.10.21.32.30;	author ahunter;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.09.21.16.47;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.02.23.30.43;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.04.19.23.02;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.24.46;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.51;	author sshaw;	state Exp;
branches;
next	;

1.12.2.1
date	2006.07.20.20.23.50;	author ldamus;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2006.09.13.19.33.37;	author mmostafa;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2006.10.10.21.20.00;	author ldamus;	state Exp;
branches;
next	;

1.14.2.1
date	2007.05.18.17.36.33;	author crevells;	state Exp;
branches;
next	;
commitid	17e3464de4214567;

1.15.2.1
date	2007.09.13.19.55.35;	author ahunter;	state Exp;
branches;
next	1.15.2.2;
commitid	77fc46e995b74567;

1.15.2.2
date	2008.01.16.21.58.55;	author ahunter;	state Exp;
branches;
next	;
commitid	23e9478e7e1f4567;

1.18.2.1
date	2008.08.08.21.26.16;	author aboyko;	state Exp;
branches;
next	;
commitid	2e99489cb9f84567;


desc
@@


1.19
log
@[243596] gmf_head aboyko 080808 [Properties] NPE in properties section
@
text
@/******************************************************************************
 * Copyright (c) 2003, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.properties.sections;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.operations.IOperationHistory;
import org.eclipse.core.commands.operations.OperationHistoryFactory;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.transaction.DemultiplexingListener;
import org.eclipse.emf.transaction.NotificationFilter;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.services.properties.PropertiesServiceAdapterFactory;
import org.eclipse.gmf.runtime.diagram.ui.editparts.GroupEditPart;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.DiagramPropertiesDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.DiagramPropertiesPlugin;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.DiagramPropertiesStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.l10n.DiagramUIPropertiesMessages;
import org.eclipse.gmf.runtime.diagram.ui.properties.util.SectionUpdateRequestCollapser;
import org.eclipse.gmf.runtime.diagram.ui.properties.views.IReadOnlyDiagramPropertySheetPageContributor;
import org.eclipse.gmf.runtime.diagram.ui.properties.views.PropertiesBrowserPage;
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.graphics.GC;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.views.properties.tabbed.AbstractPropertySection;
import org.eclipse.ui.views.properties.tabbed.ITabbedPropertySheetPageContributor;
import org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage;

/**
 * An abstract implementation of a section in a tab in the tabbed property sheet
 * page for modeler.
 * 
 * @@author Anthony Hunter <a
 *         href="mailto:anthonyh@@ca.ibm.com">anthonyh@@ca.ibm.com </a>
 */
public abstract class AbstractModelerPropertySection
	extends AbstractPropertySection {

	private TabbedPropertySheetPage tabbedPropertySheetPage;
 
	/**
	 * model event listener
	 */
	protected DemultiplexingListener eventListener = new DemultiplexingListener(getFilter()) {

		protected void handleNotification(TransactionalEditingDomain domain,
				Notification notification) {
			update(domain, notification);
		}
	};

	// properties provider to obtain properties of the objects on the list
	protected static final PropertiesServiceAdapterFactory propertiesProvider = new PropertiesServiceAdapterFactory();

	private boolean bIsCommandInProgress = false;

	/** value changed string */
	static protected String VALUE_CHANGED_STRING = DiagramUIPropertiesMessages.AbstractPropertySection_UndoIntervalPropertyString;

	/** object currently selected on either a diagram or a ME - a view */
	protected List input;

	/** eObject should gradually replace EElement */
	protected EObject eObject;

	private List eObjectList = new ArrayList();

	/**
	 * a flag indicating if this property section got disposed
	 */
	protected boolean disposed = false;
    
    private TransactionalEditingDomain editingDomain = null;
	
    /* (non-Javadoc)
	 * @@see org.eclipse.ui.views.properties.tabbed.ISection#setInput(org.eclipse.ui.IWorkbenchPart, org.eclipse.jface.viewers.ISelection)
	 */
	public void setInput(IWorkbenchPart part, ISelection selection) {
		super.setInput(part, selection);

		if (!(selection instanceof IStructuredSelection)
			|| selection.equals(getInput()))
			return;

		input = new ArrayList();

		eObjectList = new ArrayList();
		for (Iterator it = ((IStructuredSelection) selection).iterator(); it
			.hasNext();) {
			Object next = it.next();
			
            if (digIntoGroups() && next instanceof GroupEditPart) {
                for (Iterator iter = ((GroupEditPart) next)
                    .getShapeChildren().iterator(); iter.hasNext();) {
                    Object childEP = iter.next();
                    // unwrap down to EObject and add to the eObjects list
                    if (addToEObjectList(childEP)) {
                        input.add(childEP);
                    }
                    continue;
                }
            }
            
            // unwrap down to EObject and add to the eObjects list
            if (addToEObjectList(next)) {
                input.add(next);
            }
		}


		// RATLC000524513 Sometimes there is no eobject. For example if user
		// creates a constraint,
		// on a class there will be a connection shown on the diagram which
		// connects the constraint
		// with the class. The user can select this connection, even though it
		// does not have an
		// underlying eobject. Comments are similar. In this case we show only
		// the appearanced tab.
		if (false == eObjectList.isEmpty())
			setEObject((EObject) eObjectList.get(0));

	}
	
    /**
     * Override to return true to have this property section work on the shapes
     * in a <code>GroupEditPart</code> as if the shapes were multi-selected.
     * 
     * @@return true if this property section is to dig into the shapes of groups
     */
    protected boolean digIntoGroups() {
        return false;
    }
    
	/**
	 * Add next object in the selection to the list of EObjects if this object 
	 * could be adapted to an <code>EObject</code>
	 * @@param object the object to add
	 * @@return - true if the object is added, false otherwise 
	 */
	protected boolean addToEObjectList(Object object) {
		EObject adapted = unwrap(object);
		if (adapted != null){
			getEObjectList().add(adapted);
			return true;
		}		
		return false;

	}

	/**
	 * Unwarp the ME or diagram object down to the underlaying UML element
	 * 
	 * @@param object -
	 *            object from a diagram or ME
	 * @@return - underlaying UML element
	 */
	protected EObject unwrap(Object object) {
		return adapt(object);
	}

	/**
	 * Adapt the object to an EObject - if possible
	 * 
	 * @@param object
	 *            object from a diagram or ME
	 * @@return EObject
	 */
	protected EObject adapt(Object object) {
		if (object instanceof IAdaptable) {
			return (EObject) ((IAdaptable) object).getAdapter(EObject.class);
		}

		return null;
	}

	/**
	 * Determines if the page is displaying properties for this element
	 * 
	 * @@param notification
	 *            The notification
	 * @@param element
	 *            The element to be tested
	 * @@return 'true' if the page is displaying properties for this element
	 */
	protected boolean isCurrentSelection(Notification notification,
			EObject element) {

		if (element == null)
			return false;

		if (eObjectList.contains(element))
			return true;

		if (eObjectList.size() > 0) {
			EObject eventObject = element;

			// check for annotations
			if (element instanceof EAnnotation) {
				eventObject = element.eContainer();
			} else {
				EObject container = element.eContainer();
				if (container != null && container instanceof EAnnotation) {
					eventObject = container.eContainer();
				}
			}

            if (notification.getFeature() == EcorePackage.Literals.EANNOTATION__EMODEL_ELEMENT) {
                Object oldObj = notification.getOldValue();
                Object newObj = notification.getNewValue();
                if (oldObj instanceof EObject && newObj == null) {
                    // the annotation has been removed - check the old owner
                    eventObject = (EObject) oldObj;
                }
            }

			if (eventObject != element) {
				return eObjectList.contains(eventObject);
			}

		}
		return false;
	}

	/**
	 * A utility method allows execute a piece of code wrapping it in the read
	 * call to the model.
	 * 
	 * @@param code -
	 *            Runnable code to execute
	 */
	protected void executeAsReadAction(final Runnable code) {
		try {
			TransactionalEditingDomain domain = getEditingDomain();
			
			if (domain != null) {
				getEditingDomain().runExclusive(code);
			} else {
				// if we are not in a transactional editing domain context, then
				//    there is no notion of exclusivity.  Just run
				code.run();
			}
		} catch (InterruptedException e) {
			Trace.catching(DiagramPropertiesPlugin.getDefault(),
				DiagramPropertiesDebugOptions.EXCEPTIONS_CATCHING, getClass(),
				"executeAsReadAction", e); //$NON-NLS-1$
		}
	}

	/**
	 * A utility method allows execute a list of commands by wrapping them\ in a
	 * composite command.
	 * 
	 * @@param commands -
	 *            List of commands to execute
	 */
	protected CommandResult executeAsCompositeCommand(String actionName,
			List commands) {
		
		if (true == bIsCommandInProgress)
			return null;

		bIsCommandInProgress = true;

        CompositeCommand command = new CompositeCommand(actionName, commands);
        IOperationHistory history = OperationHistoryFactory.getOperationHistory();

        try {
            IStatus status = history.execute(command,
                new NullProgressMonitor(), null);

			if (status.getCode() == DiagramPropertiesStatusCodes.CANCELLED
					|| status.getSeverity() == IStatus.CANCEL
					|| status.getSeverity() == IStatus.ERROR) {
				refresh();
			}

        } catch (ExecutionException e) {
            Trace.catching(DiagramPropertiesPlugin.getDefault(),
                DiagramPropertiesDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "executeAsCompositeCommand", e); //$NON-NLS-1$
            Log.error(DiagramPropertiesPlugin.getDefault(),
                DiagramPropertiesStatusCodes.IGNORED_EXCEPTION_WARNING, e
                    .getLocalizedMessage(), e);
        }

		bIsCommandInProgress = false;

		return command.getCommandResult();

	}

	/**
	 * Returns currently selected view object
	 * 
	 * @@return Returns the input.
	 */
	public List getInput() {
		return input;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.ui.views.properties.tabbed.ISection#aboutToBeHidden()
	 */
	public void aboutToBeHidden() {
		super.aboutToBeHidden();
        
        TransactionalEditingDomain theEditingDomain = getEditingDomain();
        if (theEditingDomain != null) {
            theEditingDomain.removeResourceSetListener(getEventListener());
        }
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.ui.views.properties.tabbed.ISection#aboutToBeShown()
	 */
	public void aboutToBeShown() {
        super.aboutToBeShown();

        TransactionalEditingDomain theEditingDomain = getEditingDomain();
        if (theEditingDomain != null) {
            theEditingDomain.addResourceSetListener(getEventListener());
        }
    }

	/* (non-Javadoc)
	 * @@see org.eclipse.ui.views.properties.tabbed.ISection#dispose()
	 */
	public void dispose() {
		super.dispose();
		/* 
		 * if (getUpdateRequestCollapser() != null) {
		 * getUpdateRequestCollapser().stop(); updateRequestCollapser = null; }
		 */
		if (eObjectList != null) {
			eObjectList.clear();
		}
		eObject = null;
		disposed = true;
	}
	
	/**
	 * Returns currently selected view object
	 * 
	 * @@return Returns the input.
	 */
	protected Object getPrimarySelection() {
		return (getInput() != null && !getInput().isEmpty() ? getInput().get(0)
			: null);
	}
	

	/**
	 * @@return Returns the eObject.
	 */
	protected EObject getEObject() {
		return eObject;
	}

	/**
	 * @@param object
	 *            The eObject to set.
	 */	
	protected void setEObject(EObject object) {
		this.eObject = object;
	}

	/**
	 * Subclasses overriding this method should remember to override
	 * {@@link #update(TransactionalEditingDomain, Notification)} as required.
	 * The default implementation of
	 * {@@link #update(TransactionalEditingDomain, Notification)} will only
	 * update if the notifier is an <code>EObject</code>.
	 * 
	 * @@return the filter for events used by my <code>eventListener</code>.
	 */
	public NotificationFilter getFilter() {
        return NotificationFilter.createEventTypeFilter(Notification.SET).or(
            NotificationFilter.createEventTypeFilter(Notification.UNSET)).and(
            NotificationFilter.createNotifierTypeFilter(EObject.class));
    }


	/**
	 * Update if nessesary, upon receiving the model event. This event will only
	 * be processed when the reciever is visible (the default behavior is not to
	 * listen to the model events while not showing). Therefore it is safe to
	 * refresh the UI. Sublclasses, which will choose to override event
	 * listening behavior should take into account that the model events are
	 * sent all the time - regardless of the section visibility. Thus special
	 * care should be taken by the section that will choose to listen to such
	 * events all the time. Also, the default implementation of this method
	 * synchronizes on the GUI thread. The subclasses that overwrite it should
	 * do the same if they perform any GUI work (because events may be sent from
	 * a non-GUI thread).
	 * 
	 * @@see #aboutToBeShown()
	 * @@see #aboutToBeHidden()
	 * 
	 * @@param notification notification object
	 * @@param element element that has changed
	 */
	public void update(final Notification notification, final EObject element) {
		if (!isDisposed() && isCurrentSelection(notification, element)
			&& !isNotifierDeleted(notification)) {
			postUpdateRequest(new Runnable() {

				public void run() {
					if (!isDisposed()
						&& isCurrentSelection(notification, element)
						&& !isNotifierDeleted(notification))
						refresh();

				}
			});
		}
	}
	
	/**
	 * Updates me if the notifier is an <code>EObject</code> by calling
	 * {@@link #update(Notification, EObject)}. Does nothing otherwise.
	 * Subclasses should override this method if they need to update based on
	 * non-EObject notifiers.
	 * 
	 * @@param domain
	 *            the editing domain
	 * @@param notification
	 *            the event notification
	 */
	protected void update(TransactionalEditingDomain domain, Notification notification) {

		Object notifier = notification.getNotifier();
		
		if (notifier instanceof EObject) {
			update(notification, (EObject) notifier);
		}
	}

	/**
	 * Returns whether or not the notifier for a particular notification has been
	 * deleted from its parent.
	 * 
	 * This is a fix for RATLC00535181.  What happens is that during deletion of
	 * an element from the diagram, the element first deletes related elements
	 * which causes a modification of the element itself.  When the modification occurs
	 * the event handling mechanism posts a request to the UI queue to refresh the UI.
	 * A race condition occurs where by the time the posted request runs, the element
	 * in question may or may not have already been deleted from its container.  If
	 * the element has been deleted from its container, we should not refresh the
	 * property section.
	 * 
	 * @@param notification
	 * @@return <code>true</code> if notification has been deleted from its parent, <code>false</code> otherwise
	 */
	protected boolean isNotifierDeleted(Notification notification) {
		if (!(notification.getNotifier() instanceof EObject)) {
			return false;
		}
		EObject obj = (EObject)notification.getNotifier();
		return obj.eResource() == null;
	}
	
	/**
	 * Use requset collapser to post update requests.
	 * 
	 * @@param updateRequest -
	 *            runnable update code
	 */
	protected void postUpdateRequest(Runnable updateRequest) {
		getUpdateRequestCollapser().postRequest(this, updateRequest);

	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleElementModifiedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.EObject)
	 */
	public void handleElementModifiedEvent(final Notification notification,
			final EObject element) {
		update(notification, element);
	}

	/**
	 * @@return Returns the eObjectList.
	 */
	protected List getEObjectList() {
		return eObjectList;
	}

	/**
	 * @@return Returns the disposed.
	 */
	protected boolean isDisposed() {
		return disposed;
	}

	/**
	 * @@return Returns the eventListener.
	 */
	protected DemultiplexingListener getEventListener() {
		return eventListener;
	}

	/**
	 * @@return Returns a command
	 */
	protected ICommand createCommand(String name, Resource res,
			final Runnable runnable) {

		return createCommandInternal(name, res, runnable);
	}

	/**
	 * @@return Returns a command
	 */
	protected ICommand createCommand(String name, EObject res,
			final Runnable runnable) {

		return createCommandInternal(name, res.eResource(), runnable);
	}

	/**
	 * @@return Returns a command
	 */
	private ICommand createCommandInternal(String name, Resource res,
			final Runnable runnable) {
		
		if (res == null) {
			return UnexecutableCommand.INSTANCE;
		}

        ICommand command = new AbstractTransactionalCommand(getEditingDomain(), name,
            Collections.singletonList(WorkspaceSynchronizer.getFile(res))) {

            protected CommandResult doExecuteWithResult(
                    IProgressMonitor monitor, IAdaptable info)
                throws ExecutionException {

				runnable.run();

                return CommandResult.newOKCommandResult();
			}
		};

		return command;
	}

    /**
     * Gets the editing domain from my EObject input.
     * 
     * @@return my editing domain
     */
    protected TransactionalEditingDomain getEditingDomain() {
        if (editingDomain == null) {
            EObject eObjectInput = getEObject();
            if (eObjectInput != null) {
                editingDomain = TransactionUtil.getEditingDomain(eObjectInput);
            } else if (!getEObjectList().isEmpty()) {
                editingDomain = TransactionUtil.getEditingDomain(getEObjectList().get(0));
            }
        }
        return editingDomain;
    }
    
    /**
     * Sets the editingDomain.
     * @@param editingDomain The editingDomain to set.
     */
    protected void setEditingDomain(TransactionalEditingDomain editingDomain) {
        this.editingDomain = editingDomain;
    }

    /* (non-Javadoc)
	 * @@see org.eclipse.ui.views.properties.tabbed.ISection#createControls(org.eclipse.swt.widgets.Composite, org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage)
	 */
	public void createControls(Composite parent,
			TabbedPropertySheetPage aTabbedPropertySheetPage) {
		super.createControls(parent, aTabbedPropertySheetPage);
		this.tabbedPropertySheetPage = aTabbedPropertySheetPage;

	}

	/**
	 * Determine if the property sheet page contributor is read only.
	 * 
	 * Topic and Browse diagrams have properties that are read only, even
	 * theough the selection may be modifiable.
	 * 
	 * @@return <code>true</code> if the contributor is read only.
	 */
	protected boolean isReadOnly() {
		if (tabbedPropertySheetPage instanceof PropertiesBrowserPage) {
			PropertiesBrowserPage propertiesBrowserPage = (PropertiesBrowserPage) tabbedPropertySheetPage;
			ITabbedPropertySheetPageContributor contributor = propertiesBrowserPage
				.getContributor();
            if (contributor instanceof IReadOnlyDiagramPropertySheetPageContributor
                    || (contributor instanceof DiagramEditor && !((DiagramEditor) contributor)
                        .isWritable())) {
                return true;
            }
		}
		return false;
	}

	/**
	 * Get the standard label width when labels for sections line up on the left
	 * hand side of the composite. We line up to a fixed position, but if a
	 * string is wider than the fixed position, then we use that widest string.
	 * 
	 * @@param parent
	 *            The parent composite used to create a GC.
	 * @@param labels
	 *            The list of labels.
	 * @@return the standard label width.
	 */
	protected int getStandardLabelWidth(Composite parent, String[] labels) {
		int standardLabelWidth = STANDARD_LABEL_WIDTH;
		GC gc = new GC(parent);
		int indent = gc.textExtent("XXX").x; //$NON-NLS-1$
		for (int i = 0; i < labels.length; i++) {
			int width = gc.textExtent(labels[i]).x;
			if (width + indent > standardLabelWidth) {
				standardLabelWidth = width + indent;
			}
		}
		gc.dispose();
		return standardLabelWidth;
	}

	/**
	 * @@return Returns the updateRequestCollapser.
	 */
	protected SectionUpdateRequestCollapser getUpdateRequestCollapser() {
		return DiagramPropertiesPlugin.getDefault()
			.getUpdateRequestCollapser();
	}
	
}@


1.18
log
@[191709] gmf-head ahunter 080116 AbstractModelerPropertySection should refresh if an executed command fails
@
text
@d39 1
d558 4
@


1.18.2.1
log
@[243596] gmf_R2_1_maitenance aboyko 080808 [Properties] NPE in properties section
@
text
@a38 1
import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;
a556 4
		
		if (res == null) {
			return UnexecutableCommand.INSTANCE;
		}
@


1.17
log
@[111892] gmf_head crevells 071121 Group/Ungroup support
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2007 IBM Corporation and others.
d304 2
a305 2
					|| status.getCode() == IStatus.CANCEL
					|| status.getCode() == IStatus.ERROR) {
@


1.16
log
@[203354] gmf_head ahunter 070913 AbstractModelerPropertySection#isCurrentSelection() uses obsolete assumptions regarding deleted annotations
@
text
@d42 1
d124 16
a139 4
			// unwrap down to EObject and add to the eObjects list
			if (addToEObjectList(next)) {
				input.add(next);
			}
d155 11
a165 1

@


1.15
log
@[191709] gmf-head ahunter 070608 AbstractModelerPropertySection should refresh if an executed command fails
@
text
@d29 1
d216 8
a223 9
			if (eventObject == null) {
				// the annotation has been removed - check the old owner
				Object tmpObj = notification.getOldValue();
				if (tmpObj != null && tmpObj instanceof EObject) {
					eventObject = (EObject) tmpObj;
				} else {
					return false;
				}
			}
@


1.15.2.1
log
@[203354] gmf_R2_0_maintenance ahunter 070913 AbstractModelerPropertySection#isCurrentSelection() uses obsolete assumptions regarding deleted annotations
@
text
@a28 1
import org.eclipse.emf.ecore.EcorePackage;
d215 9
a223 8
            if (notification.getFeature() == EcorePackage.Literals.EANNOTATION__EMODEL_ELEMENT) {
                Object oldObj = notification.getOldValue();
                Object newObj = notification.getNewValue();
                if (oldObj instanceof EObject && newObj == null) {
                    // the annotation has been removed - check the old owner
                    eventObject = (EObject) oldObj;
                }
            }
@


1.15.2.2
log
@[191709] gmf-R2_0_maintenance ahunter 080116 AbstractModelerPropertySection should refresh if an executed command fails
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2008 IBM Corporation and others.
d281 2
a282 2
					|| status.getSeverity() == IStatus.CANCEL
					|| status.getSeverity() == IStatus.ERROR) {
@


1.14
log
@[159375] gmf_head ldamus 061010 Memory Leak caused by AbstractModelerPropertiesSection
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2006 IBM Corporation and others.
d280 5
a284 3
            if (status.getCode() == DiagramPropertiesStatusCodes.CANCELLED) {
			refresh();
            }
@


1.14.2.1
log
@[111892] gmf_head crevells 070518 First milestone of group/ungroup support (painting issues when grouping shapes with border items)
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2007 IBM Corporation and others.
a40 1
import org.eclipse.gmf.runtime.diagram.ui.editparts.GroupEditPart;
d122 4
a125 16
            if (digIntoGroups() && next instanceof GroupEditPart) {
                for (Iterator iter = ((GroupEditPart) next)
                    .getFlattenedChildren().iterator(); iter.hasNext();) {
                    Object childEP = iter.next();
                    // unwrap down to EObject and add to the eObjects list
                    if (addToEObjectList(childEP)) {
                        input.add(childEP);
                    }
                    continue;
                }
            }
            // unwrap down to EObject and add to the eObjects list
            if (addToEObjectList(next)) {
                input.add(next);
            }
            
a637 10
    
    /**
     * Override to return true to have this property section work on the shapes
     * in a <code>GroupEditPart</code> as if the shapes were multi-selected.
     * 
     * @@return true if this property section is to dig into the shapes of groups
     */
    protected boolean digIntoGroups() {
        return false;
    }
@


1.13
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d341 4
a345 1

@


1.12
log
@[144561] gmf_head cdamus 060607 NPE in AbstractModelerPropertySection
@
text
@d41 1
d78 1
a78 1
			update(notification, (EObject) notification.getNotifier());
d371 8
a378 2
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#getFilter()
d421 20
d594 5
a598 3
			if (contributor instanceof IReadOnlyDiagramPropertySheetPageContributor) {
				return true;
			}
@


1.12.2.1
log
@[146059] gmf_R1_0_maintenance ldamus 060720 ClassCastException in AbstractModelerPropertySection when subclass uses filter not excluding EObjects
@
text
@d77 1
a77 1
			update(domain, notification);
d370 2
a371 8
	/**
	 * Subclasses overriding this method should remember to override
	 * {@@link #update(TransactionalEditingDomain, Notification)} as required.
	 * The default implementation of
	 * {@@link #update(TransactionalEditingDomain, Notification)} will only
	 * update if the notifier is an <code>EObject</code>.
	 * 
	 * @@return the filter for events used by my <code>eventListener</code>.
a413 20
	
	/**
	 * Updates me if the notifier is an <code>EObject</code> by calling
	 * {@@link #update(Notification, EObject)}. Does nothing otherwise.
	 * Subclasses should override this method if they need to update based on
	 * non-EObject notifiers.
	 * 
	 * @@param domain
	 *            the editing domain
	 * @@param notification
	 *            the event notification
	 */
	protected void update(TransactionalEditingDomain domain, Notification notification) {

		Object notifier = notification.getNotifier();
		
		if (notifier instanceof EObject) {
			update(notification, (EObject) notifier);
		}
	}
@


1.12.2.2
log
@[157023] gmf_R1_0_maintenace wdiu 060913  Cannot selectively enable or disable whether a properties contributor is read only with IReadOnlyDiagramPropertySheetPageContributor
@
text
@a40 1
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
d593 3
a595 5
            if (contributor instanceof IReadOnlyDiagramPropertySheetPageContributor
                    || (contributor instanceof DiagramEditor && !((DiagramEditor) contributor)
                        .isWritable())) {
                return true;
            }
@


1.12.2.3
log
@[159375] gmf_R1_0_maintenance ldamus 061010 Memory Leak caused by AbstractModelerPropertiesSection
@
text
@a340 4
		if (eObjectList != null) {
			eObjectList.clear();
		}
		eObject = null;
d342 1
@


1.11
log
@Bugzilla#130380 gmf_head cmahoney 050206 PropertySections will miss UNSET events
@
text
@d241 9
a249 1
			getEditingDomain().runExclusive(code);
@


1.10
log
@[135386] gmf_head ldamus 060406 Runtime plugin dependencies must specify required plugin versions
@
text
@d366 2
a367 1
		return NotificationFilter.createEventTypeFilter(Notification.SET).and(
d369 1
a369 1
	}
@


1.9
log
@Bugzilla#130176 gmf_head cmahoney 060302 Values of properties on advanced tab not refreshed after property is changed
@
text
@d44 1
a48 1
import org.eclipse.gmf.runtime.emf.ui.internal.l10n.EMFUIMessages;
d87 1
a87 1
	static protected String VALUE_CHANGED_STRING = EMFUIMessages.AbstractPropertySection_UndoIntervalPropertyString;
@


1.8
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d104 1
a104 1
	/* (non-Javadoc)
d304 4
a307 2
        if (editingDomain != null) {
            editingDomain.removeResourceSetListener(getEventListener());
d315 5
a319 4
		super.aboutToBeShown();
        editingDomain = getEditingDomain();
        if (editingDomain != null) {
            editingDomain.addResourceSetListener(getEventListener());
d321 1
a321 1
	}
d516 7
a522 5
        EObject eObjectInput = getEObject();
        if (eObjectInput != null) {
            return TransactionUtil.getEditingDomain(eObjectInput);
        } else if (!getEObjectList().isEmpty()) {
            return TransactionUtil.getEditingDomain(getEObjectList().get(0));
d524 9
a532 1
        return null;
@


1.7
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d30 2
a40 1
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
a47 6
import org.eclipse.gmf.runtime.emf.core.edit.DemuxingMListener;
import org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener;
import org.eclipse.gmf.runtime.emf.core.edit.MFilter;
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.emf.core.edit.MUndoInterval;
import org.eclipse.gmf.runtime.emf.core.exceptions.MSLActionAbandonedException;
d66 1
a66 2
	extends AbstractPropertySection
	implements IDemuxedMListener {
d69 1
a69 1

d73 7
a79 1
	protected DemuxingMListener eventListener = new DemuxingMListener(this);
d101 2
a102 1

d240 7
a246 7
		executeAsReadAction(new MRunnable() {

			public Object run() {
				code.run();
				return null;
			}
		});
a247 11
	
	/**
	 * A utility method allows execute a piece of code wrapping it in the read
	 * call to the model.
	 * 
	 * @@param code -
	 *            MRunnable code to execute
	 */
	protected Object executeAsReadAction(MRunnable code) {		
		return MEditingDomainGetter.getMEditingDomain(getEObjectList()).runAsRead(code);
	}	
d263 1
a263 1
        
d266 1
a266 1
       
d272 1
a272 1
                refresh();
d304 3
a306 1
		eventListener.stopListening();
d314 4
a317 1
		eventListener.startListening();
d325 1
a325 1
		/*
d362 3
a364 50
	public MFilter getFilter() {
		return MFilter.ELEMENT_MODIFIED_FILTER;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleResourceLoadedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.resource.Resource)
	 */
	public void handleResourceLoadedEvent(Notification notification,
			Resource resource) {
		/* not implemented */
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleResourceUnloadedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.resource.Resource, org.eclipse.emf.ecore.EObject)
	 */
	public void handleResourceUnloadedEvent(Notification notification,
			Resource resource, EObject modelRoot) {
		/* not implemented */
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleResourceDirtiedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.resource.Resource)
	 */
	public void handleResourceDirtiedEvent(Notification notification,
			Resource resource) {
		/* not implemented */
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleResourceSavedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.resource.Resource)
	 */
	public void handleResourceSavedEvent(Notification notification,
			Resource resource) {
		/* not implemented */
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleResourceImportedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.resource.Resource)
	 */
	public void handleResourceImportedEvent(Notification notification,
			Resource resource) {
		/* not implemented */
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleResourceExportedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.resource.Resource)
	 */
	public void handleResourceExportedEvent(Notification notification,
			Resource resource) {
		/* not implemented */
a366 15
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleElementCreatedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.EObject, org.eclipse.emf.ecore.EObject)
	 */
	public void handleElementCreatedEvent(Notification notification,
			EObject owner, EObject newElement) {
		/* not implemented */
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleElementDeletedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.emf.ecore.EObject, org.eclipse.emf.ecore.EObject)
	 */
	public void handleElementDeletedEvent(Notification notification,
			EObject owner, EObject oldElement) {
		/* not implemented */
	}
a446 31
	 * Handle the action abandoned exception
	 * 
	 * @@param exception
	 *            the action abandoned exception
	 */
	protected void handleException(MSLActionAbandonedException exception) {
		Trace.catching(DiagramPropertiesPlugin.getDefault(),
			DiagramPropertiesDebugOptions.EXCEPTIONS_CATCHING, getClass(),
			exception.getMessage(), exception);
		Log.warning(DiagramPropertiesPlugin.getDefault(),
			DiagramPropertiesStatusCodes.IGNORED_EXCEPTION_WARNING,
			exception.getMessage(), exception);
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleUndoIntervalClosedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.gmf.runtime.emf.core.edit.MUndoInterval)
	 */
	public void handleUndoIntervalClosedEvent(Notification notification,
			MUndoInterval undoInterval) {
		/* not implemented */
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.core.edit.IDemuxedMListener#handleUndoIntervalsFlushedEvent(org.eclipse.emf.common.notify.Notification, org.eclipse.gmf.runtime.emf.core.edit.MUndoInterval)
	 */
	public void handleUndoIntervalsFlushedEvent(Notification notification,
			MUndoInterval undoInterval) {
		/* not implemented */
	}

	/**
d463 1
a463 1
	protected DemuxingMListener getEventListener() {
d489 1
a489 1
            final Runnable runnable) {
d498 1
a498 1
                runnable.run();
d501 5
a505 2
            }
        };
a506 3
        return command;
    }
    
a512 1

a513 1

d516 2
a518 1

d522 1
a522 2
	
	/* (non-Javadoc)
d584 1
@


1.6
log
@gmf_head ahunter 060210 Migrate GMF usage of tabbed properties view from WTP to Eclipse Core (org.eclipse.wst.common.ui.properties to org.eclipse.ui.views.properties.tabbed)
@
text
@d2 1
a2 1
 * Copyright (c) 2003, 2005 IBM Corporation and others.
d15 1
d19 3
d24 2
d30 3
a32 10
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.graphics.GC;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.views.properties.tabbed.AbstractPropertySection;
import org.eclipse.ui.views.properties.tabbed.ITabbedPropertySheetPageContributor;
import org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage;

import org.eclipse.gmf.runtime.common.core.command.CommandManager;
a39 1
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.DiagramPropertiesStatusCodes;
d42 1
d46 1
a46 1
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractModelCommand;
d54 8
d273 20
a292 7

		CompositeCommand compCmd = new CompositeCommand(actionName, commands);

		CommandResult result = CommandManager.getDefault().execute(compCmd);

		if (result.getStatus().getCode() == DiagramPropertiesStatusCodes.CANCELLED)
			refresh();
d296 1
a296 1
		return result;
d580 1
a580 1
		return createCommandInternal(name, res, runnable);
d586 2
a587 2
	private ICommand createCommandInternal(String name, Object res,
			final Runnable runnable) {
d589 2
a590 1
		ICommand command = new AbstractModelCommand(name, res) {
d592 25
a616 2
			protected CommandResult doExecute(IProgressMonitor progressMonitor) {
				runnable.run();
d618 2
a619 6
				return newOKCommandResult();
			}
		};

		return command;
	}
@


1.5
log
@Bugzilla Bug 109445 gmf_head etworkow 051109 New Eclipse Resources Bundles Should Be Used
@
text
@d29 3
a31 3
import org.eclipse.wst.common.ui.properties.internal.provisional.AbstractPropertySection;
import org.eclipse.wst.common.ui.properties.internal.provisional.ITabbedPropertySheetPageContributor;
import org.eclipse.wst.common.ui.properties.internal.provisional.TabbedPropertySheetPage;
d97 1
a97 1
	 * @@see org.eclipse.wst.common.ui.properties.internal.provisional.ISection#setInput(org.eclipse.ui.IWorkbenchPart, org.eclipse.jface.viewers.ISelection)
d290 1
a290 1
	 * @@see org.eclipse.wst.common.ui.properties.internal.provisional.ISection#aboutToBeHidden()
d298 1
a298 1
	 * @@see org.eclipse.wst.common.ui.properties.internal.provisional.ISection#aboutToBeShown()
d306 1
a306 1
	 * @@see org.eclipse.wst.common.ui.properties.internal.provisional.ISection#dispose()
d583 1
a583 1
	 * @@see org.eclipse.wst.common.ui.properties.internal.provisional.ISection#createControls(org.eclipse.swt.widgets.Composite, org.eclipse.wst.common.ui.properties.internal.provisional.TabbedPropertySheetPage)
@


1.4
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d54 1
a54 1
import org.eclipse.gmf.runtime.emf.ui.internal.l10n.ResourceManager;
d80 1
a80 3
	static protected String VALUE_CHANGED_STRING = ResourceManager
		.getInstance().getString(
			"AbstractPropertySection.UndoIntervalPropertyString"); //$NON-NLS-1$
@


1.3
log
@Bugzilla Bug 111376 gmf_head ldamus 051004 AbstractModelerPropertySection refreshes when input deleted
@
text
@d41 3
a43 3
import org.eclipse.gmf.runtime.diagram.ui.properties.PresentationPropertiesStatusCodes;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.PresentationPropertiesDebugOptions;
import org.eclipse.gmf.runtime.diagram.ui.properties.internal.PresentationPropertiesPlugin;
d124 1
a124 1
		// on a class there will be a connector shown on the diagram which
d126 1
a126 1
		// with the class. The user can select this connector, even though it
d273 1
a273 1
		if (result.getStatus().getCode() == PresentationPropertiesStatusCodes.CANCELLED)
d502 2
a503 2
		Trace.catching(PresentationPropertiesPlugin.getDefault(),
			PresentationPropertiesDebugOptions.EXCEPTIONS_CATCHING, getClass(),
d505 2
a506 2
		Log.warning(PresentationPropertiesPlugin.getDefault(),
			PresentationPropertiesStatusCodes.IGNORED_EXCEPTION_WARNING,
d643 1
a643 1
		return PresentationPropertiesPlugin.getDefault()
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d473 1
a473 1
		return obj.eContainer() == null && obj.eResource() == null;
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2003, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

