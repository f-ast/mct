head	1.12;
access;
symbols
	v20081020-0700:1.12
	v20080722-1827:1.12
	R2_1_maintenance:1.12.0.2
	Root_R2_1_maintenance:1.12
	R2_1_0:1.12
	v20080507-2230:1.12
	v20080425-1959:1.11
	v20080222-1200:1.11
	v20070809-0000:1.11
	R2_0_maintenance:1.11.0.2
	R2_0:1.11
	R4_20:1.11
	RC3_20:1.11
	v20070601-1400:1.11
	v20070518-1300:1.11
	v20070504-1000:1.11
	v20070420-1000:1.10
	v20070330-1300:1.9
	v20070208-1800:1.9
	v20070119-1200:1.8.2.3
	M4_20:1.9
	v20061214-0000:1.9
	M3_20:1.9
	v20061013-1330:1.9
	v20060925-1700:1.8.2.3
	v20060919-0800:1.8.2.3
	v20060907-1100:1.8.2.1
	M1_20:1.8
	v20060810-1700:1.8.2.1
	v20060713-1700:1.8
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	v20060627-1200:1.8
	v20060616-1200:1.8
	v20060531-1730:1.7
	I20060424-0500:1.7
	I20060424-0300:1.7
	M6_10:1.7
	I20060407-1200:1.7
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.6
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.6
	I20060129-1145:1.6
	I20060127-0900:1.6
	I20060120-1530:1.6
	I20060113-1700:1.6
	M4_10:1.6
	I20060107-1100:1.6
	I20060105-1630:1.6
	I20051230-1230:1.6
	I20051223-1100:1.6
	I20051217-0925:1.6
	I20051124-2000:1.6
	M3_10:1.6
	I20051118-1245:1.6
	I20051111-1800:1.6
	I20051106-0900:1.6
	v20051030:1.6;
locks; strict;
comment	@# @;


1.12
date	2008.05.08.02.07.10;	author ahunter;	state Exp;
branches;
next	1.11;
commitid	293e4822604d4567;

1.11
date	2007.05.02.15.20.10;	author crevells;	state Exp;
branches;
next	1.10;
commitid	2f424638ac2a4567;

1.10
date	2007.04.17.18.08.04;	author crevells;	state Exp;
branches;
next	1.9;
commitid	173746250d044567;

1.9
date	2006.10.03.15.01.53;	author ahunter;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.14.19.51.42;	author ldamus;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2006.04.04.20.28.50;	author cmahoney;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.14.15.15.08;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.07.14.04.17;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.05.17.12.49;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.22.17.08.24;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.31.07;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.18;	author sshaw;	state Exp;
branches;
next	;

1.8.2.1
date	2006.08.10.18.39.10;	author ldamus;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2006.09.11.18.25.21;	author cmahoney;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2006.09.15.16.03.12;	author cmahoney;	state Exp;
branches;
next	;


desc
@@


1.12
log
@[230946] gmf-head ahunter 080507 ClassCastException when working with GMF popup menus
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.ui.services.action.contributionitem;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.gmf.runtime.common.core.service.AbstractProvider;
import org.eclipse.gmf.runtime.common.core.service.IOperation;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.action.AbstractActionHandler;
import org.eclipse.gmf.runtime.common.ui.action.IActionWithProgress;
import org.eclipse.gmf.runtime.common.ui.action.IDisposableAction;
import org.eclipse.gmf.runtime.common.ui.services.action.internal.CommonUIServicesActionDebugOptions;
import org.eclipse.gmf.runtime.common.ui.services.action.internal.CommonUIServicesActionPlugin;
import org.eclipse.gmf.runtime.common.ui.services.action.internal.CommonUIServicesActionStatusCodes;
import org.eclipse.gmf.runtime.common.ui.services.action.internal.contributionitem.ContributionItemConstants;
import org.eclipse.gmf.runtime.common.ui.services.action.internal.contributionitem.DisposeContributionsOperation;
import org.eclipse.gmf.runtime.common.ui.services.action.internal.contributionitem.IContributionDescriptorReader;
import org.eclipse.gmf.runtime.common.ui.services.action.internal.contributionitem.IContributionItemProvider;
import org.eclipse.gmf.runtime.common.ui.services.action.internal.contributionitem.ProviderContributionDescriptor;
import org.eclipse.gmf.runtime.common.ui.util.ActionGroupCache;
import org.eclipse.gmf.runtime.common.ui.util.ActivityUtil;
import org.eclipse.gmf.runtime.common.ui.util.IPartSelector;
import org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor;
import org.eclipse.gmf.runtime.common.ui.util.WorkbenchPartDescriptor;
import org.eclipse.jface.action.AbstractGroupMarker;
import org.eclipse.jface.action.ActionContributionItem;
import org.eclipse.jface.action.GroupMarker;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.action.IContributionItem;
import org.eclipse.jface.action.IContributionManager;
import org.eclipse.jface.action.IContributionManagerOverrides;
import org.eclipse.jface.action.IMenuListener;
import org.eclipse.jface.action.IMenuManager;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ISelectionProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.CoolBar;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.swt.widgets.ToolBar;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IPluginContribution;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.actions.ActionGroup;

/**
 * An abstract implementation of the IContributionItemProvider interface
 * This provider performs the contribution by reading its XML contribution
 * descriptor and parsing it in the correct format.
 * <P>
 * Contribution item providers wishing "not" to read an XML-based descriptor
 * but rather performs the contribution totally programatically should not
 * subclass this class but rather implement the <code>IContributionItemProvider</code>
 * interface directly. 
 * 
 * @@author melaasar, cmahoney
 */
public abstract class AbstractContributionItemProvider
	extends AbstractProvider
	implements IContributionItemProvider, IContributionDescriptorReader {

	/** the provider's contribution descriptor */
	private ProviderContributionDescriptor contributionDescriptor;
	/** the action registry cache by workbench part descriptor*/
	private Map actionCache = new HashMap();
	/** the Action Group registry cache by workbench part descriptor */
	private ActionGroupCache actionGroupCache = new ActionGroupCache();
	
	/**
	 * Identifies the plugin where the contributions were made so that these
	 * contributions can be filtered if an activity/capability associated with
	 * the plugin is disabled.
	 */
	private IPluginContribution pluginContribution;
    
	/**
	 * A list of part descriptors ids for which actionbar contributions have
	 * already been made.
	 */
	private Set partDescriptors = new HashSet();

	/**
	 * Gets the structured selection from the workbench part described by
	 * <code>partDescriptor</code>.
	 * 
	 * @@param partDescriptor
	 *            the part descriptor
	 * @@return the structured selection
	 */
	protected IStructuredSelection getStructuredSelection(IWorkbenchPartDescriptor partDescriptor) {
		
		IStructuredSelection selection = null;
		IWorkbenchPart activePart = partDescriptor.getPartPage().getActivePart();
		if(activePart != null) {
			ISelectionProvider selectionProvider = activePart.getSite().getSelectionProvider();
				
			if (selectionProvider != null
				&& selectionProvider.getSelection() instanceof IStructuredSelection) {
				selection = (IStructuredSelection) selectionProvider.getSelection();
			}
		}
		return (selection != null) ? selection : StructuredSelection.EMPTY;
	}
	
	/**
	 * Gets the first object in the selection in the workbench part described by
	 * <code>partDescriptor</code>.
	 * 
	 * @@param partDescriptor
	 *            the part descriptor
	 * @@return the first object in the selection
	 */
	protected Object getSelectedObject(IWorkbenchPartDescriptor partDescriptor)
	{
		IStructuredSelection ss = getStructuredSelection(partDescriptor);
		if(!ss.isEmpty())
			return ss.getFirstElement();
		return null;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.IContributionDescriptorReader#setContributionDescriptor(org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.ProviderContributionDescriptor)
	 */
	public final void setContributionDescriptor(ProviderContributionDescriptor descriptor) {
		contributionDescriptor = descriptor;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.IContributionItemProvider#contributeToActionBars(org.eclipse.ui.IActionBars, org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor)
	 */
	public final void contributeToActionBars(
		IActionBars actionBars,
		IWorkbenchPartDescriptor partDescriptor) {
		
		contributeToActionBars(actionBars, partDescriptor, false);
	}
	
	/**
	 * Contributes to the given action bars that belong to a part described with
	 * the given part descriptor.
	 * 
	 * <p>
	 * Note: There are currently issues with updating the main menu manager when
	 * multiple editors are open. If contributing to a menu manager that the
	 * contribution item service contributed (e.g. the diagram menu), when
	 * updating it does not always find the instance of the menu manager
	 * associated with the correct editor.
	 * 
	 * @@param actionBars
	 *            The target action bars
	 * @@param workbenchPartDescriptor
	 *            The context workbench part descriptor
	 * @@param updateOnly
	 *            If true, this is called when only updating the actionbars and
	 *            not when the editor is first opened.
	 */
	private void contributeToActionBars(IActionBars actionBars,
			IWorkbenchPartDescriptor partDescriptor, boolean updateOnly) {

		partDescriptors.add(partDescriptor);

		Iterator contributions =
			contributionDescriptor
				.getContributionsFor(
					partDescriptor.getPartId(),
					partDescriptor.getPartClass())
				.iterator();

		while (contributions.hasNext()) {
			Object c = contributions.next();

			if (c
				instanceof ProviderContributionDescriptor.PartMenuDescriptor) {
				ProviderContributionDescriptor.PartMenuDescriptor item =
					(ProviderContributionDescriptor.PartMenuDescriptor) c;

				if (!updateOnly) {
					contributeItem(
						new MenuContributionItemAdapter(
							item.getId(),
							partDescriptor),
						actionBars.getMenuManager(),
						item.getMenubarPath(),
						item.getMenubarGroup());
				}

				contributeItem(
					new MenuContributionItemAdapter(
						item.getId(),
						partDescriptor),
					actionBars.getToolBarManager(),
					item.getToolbarPath(),
					item.getToolbarGroup());
			} else if (
				c
					instanceof ProviderContributionDescriptor.PartMenuGroupDescriptor) {
				ProviderContributionDescriptor.PartMenuGroupDescriptor item =
					(ProviderContributionDescriptor.PartMenuGroupDescriptor) c;

				if (!updateOnly) {
					contributeItem(
						new MenuGroupContributionItemAdapter(
							item.getId(),
							item.isSeparator()),
						actionBars.getMenuManager(),
						item.getMenubarPath(),
						item.getMenubarGroup());
				}

				contributeItem(
					new MenuGroupContributionItemAdapter(
						item.getId(),
						item.isSeparator()),
					actionBars.getToolBarManager(),
					item.getToolbarPath(),
					item.getToolbarGroup());
			} else if (
				c
					instanceof ProviderContributionDescriptor.PartActionDescriptor) {
				ProviderContributionDescriptor.PartActionDescriptor item =
					(ProviderContributionDescriptor.PartActionDescriptor) c;

				if (!updateOnly) {
					contributeItem(
						new ActionContributionItemAdapter(
							item.getId(),
							partDescriptor, 
							item),
						actionBars.getMenuManager(),
						item.getMenubarPath(),
						item.getMenubarGroup());
				}

				contributeItem(
					new ActionContributionItemAdapter(
						item.getId(),
						partDescriptor, 
						item),
					actionBars.getToolBarManager(),
					item.getToolbarPath(),
					item.getToolbarGroup());

				if (item.isGlobal())
					actionBars.setGlobalActionHandler(
						item.getId(),
						getAction(item.getId(), partDescriptor, item));
			} else if (
				c
					instanceof ProviderContributionDescriptor.PartCustomDescriptor) {
				ProviderContributionDescriptor.PartCustomDescriptor item =
					(ProviderContributionDescriptor.PartCustomDescriptor) c;

				if (!updateOnly) {
					contributeItem(
						new CustomContributionItemAdapter(
							item.getId(),
							partDescriptor),
						actionBars.getMenuManager(),
						item.getMenubarPath(),
						item.getMenubarGroup());
				}

				contributeItem(
					new CustomContributionItemAdapter(
						item.getId(),
						partDescriptor),
					actionBars.getToolBarManager(),
					item.getToolbarPath(),
					item.getToolbarGroup());
			} else if (
					c
						instanceof ProviderContributionDescriptor.PartActionGroupDescriptor) {
					ProviderContributionDescriptor.PartActionGroupDescriptor item =
						(ProviderContributionDescriptor.PartActionGroupDescriptor) c;
					
					contributeItem(
						new ActionGroupContributionItemAdapter(
							item.getId(),
							partDescriptor),
							actionBars);
			}
		}
	}

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.common.ui.services.action.internal.contributionitem.IContributionItemProvider#updateActionBars(org.eclipse.ui.IActionBars,
     *      org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor)
     */
	public final void updateActionBars(IActionBars actionBars,
			IWorkbenchPartDescriptor partDescriptor) {

		if (!partDescriptors.contains(partDescriptor)) {
			contributeToActionBars(actionBars, partDescriptor, true);
		}
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.IContributionItemProvider#contributeToPopupMenu(org.eclipse.jface.action.IMenuManager, org.eclipse.ui.IWorkbenchPart)
	 */
	public final void contributeToPopupMenu(
		IMenuManager popupMenu,
		IWorkbenchPart workbenchPart) {

		ISelection selection =
			workbenchPart.getSite().getSelectionProvider().getSelection();

		IWorkbenchPartDescriptor partDescriptor =
			new WorkbenchPartDescriptor(
				workbenchPart.getSite().getId(),
				workbenchPart.getClass(),
				workbenchPart.getSite().getPage());

		Iterator contributions =
			contributionDescriptor
				.getContributionsFor(popupMenu, selection)
				.iterator();

		while (contributions.hasNext()) {
			Object c = contributions.next();

			if (c
				instanceof ProviderContributionDescriptor.PopupMenuDescriptor) {
				ProviderContributionDescriptor.PopupMenuDescriptor item =
					(ProviderContributionDescriptor.PopupMenuDescriptor) c;

				contributeItem(
					new MenuContributionItemAdapter(
						item.getId(),
						partDescriptor),
					popupMenu,
					item.getPath(),
					item.getGroup());

			} else if (
				c
					instanceof ProviderContributionDescriptor.PopupMenuGroupDescriptor) {
				ProviderContributionDescriptor.PopupMenuGroupDescriptor item =
					(ProviderContributionDescriptor.PopupMenuGroupDescriptor) c;

				contributeItem(
					new MenuGroupContributionItemAdapter(
						item.getId(),
						item.isSeparator()),
					popupMenu,
					item.getPath(),
					item.getGroup());
			} else if (
				c
					instanceof ProviderContributionDescriptor.PopupActionDescriptor) {
				ProviderContributionDescriptor.PopupActionDescriptor item =
					(ProviderContributionDescriptor.PopupActionDescriptor) c;

				contributeItem(
					new ActionContributionItemAdapter(
						item.getId(),
						partDescriptor,
						item),
					popupMenu,
					item.getPath(),
					item.getGroup());
			} else if (
				c
					instanceof ProviderContributionDescriptor.PopupCustomDescriptor) {
				ProviderContributionDescriptor.PopupCustomDescriptor item =
					(ProviderContributionDescriptor.PopupCustomDescriptor) c;

				contributeItem(
					new CustomContributionItemAdapter(
						item.getId(),
						partDescriptor),
					popupMenu,
					item.getPath(),
					item.getGroup());
			} else if (
					c
						instanceof ProviderContributionDescriptor.PopupActionGroupDescriptor) {
					ProviderContributionDescriptor.PopupActionGroupDescriptor item =
						(ProviderContributionDescriptor.PopupActionGroupDescriptor) c;

					contributeItem(
						new ActionGroupContributionItemAdapter(
							item.getId(),
							partDescriptor),
						popupMenu,
						item.getPath(),
						item.getGroup());
            } else if (c instanceof ProviderContributionDescriptor.PopupPredefinedItemDescriptor) {
                ProviderContributionDescriptor.PopupPredefinedItemDescriptor item = (ProviderContributionDescriptor.PopupPredefinedItemDescriptor) c;

                if (item.isToBeRemoved()) {
                    removeExistingItem(item.getId(), item.getPath(), popupMenu);
                }
			}
		}
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.IContributionItemProvider#disposeContributions(org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor)
	 */
	public final void disposeContributions(IWorkbenchPartDescriptor partDescriptor) {
		ActionRegistry registry = (ActionRegistry) actionCache.get(partDescriptor);
		if (registry != null) {
			registry.dispose();
		}
		actionCache.remove(partDescriptor);
		
		// dispose of the action group contributions
		actionGroupCache.dispose(partDescriptor);
		
		partDescriptors.remove(partDescriptor);
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.service.IProvider#provides(org.eclipse.gmf.runtime.common.core.service.IOperation)
	 */
	public final boolean provides(IOperation operation) {
		if (operation instanceof DisposeContributionsOperation) {
			IWorkbenchPartDescriptor partDescriptor =
				((DisposeContributionsOperation) operation)
					.getWorkbenchPartDescriptor();
			return actionCache.containsKey(partDescriptor) || actionGroupCache.contains(partDescriptor);
		}
		return false;
	}

	/**
	 * Returns the action with the given id that is created for the given part id.
	 * An action is created once and cached for each unique part's id.
	 * 
	 * @@param actionId The request action id
	 * @@param partDescriptor The workbench part descriptor
	 * @@return The action with the given id
	 */
	protected final IAction getAction(String actionId,
			IWorkbenchPartDescriptor partDescriptor) {
		ActionRegistry registry = (ActionRegistry) actionCache.get(partDescriptor);
		if (registry == null) {
			registry = new ActionRegistry();
			actionCache.put(partDescriptor, registry);
		}
		
		IAction action = getActionFromRegistry(actionId, partDescriptor, registry);
		if (action == null) {
			action = createAction(actionId, partDescriptor);
			if (action != null) {
				if (action instanceof IDisposableAction) {
					((IDisposableAction) action).init();
				}

				registry.registerAction(actionId, action);
			}
		}
		else {
			if ( action instanceof IActionWithProgress ) {
				((IActionWithProgress)action).refresh();
			}
		}
		return action;
	}

	/**
	 * Returns the action with the given id that is created for the given part
	 * id. An action is created once and cached for each unique part's id.
	 * <P>
	 * The part selector is used is when the new action is an
	 * <code>AbstractActionHandler</code> to determine whether or not the
	 * action is applicable to a given selected part. If the part is not
	 * applicable, the action will not be refreshed when selection changes in
	 * the part.
	 * 
	 * @@param actionId
	 *            The request action id
	 * @@param partDescriptor
	 *            The workbench part descriptor
	 * @@param partSelector
	 *            The part selector
	 * @@return The action with the given id
	 */
	protected final IAction getAction(String actionId,
			IWorkbenchPartDescriptor partDescriptor, IPartSelector partSelector) {

        boolean actionExistsAlready = false;
        ActionRegistry registry = (ActionRegistry) actionCache.get(partDescriptor);
        if (registry != null) {
            if (getActionFromRegistry(actionId, partDescriptor, registry) != null) {
                actionExistsAlready = true;
            }
        }
        
		IAction result = getAction(actionId, partDescriptor);
        
        // If the action already existed in the registry and this is a popup
        // menu contribution, we do not want to override the part selector
        // already set as we could override the part selector for a toolbar
        // action.  See bugzilla#157471.
        if (actionExistsAlready
            && partSelector instanceof ProviderContributionDescriptor.AbstractPopupContributionItemDescriptor) {
            return result;
        }
		
		if (result instanceof AbstractActionHandler && partSelector != null) {
			((AbstractActionHandler) result).setPartSelector(partSelector);
		}
		return result;
	}
	/**
	 * Returns the ActionGroup with the given id that is created for the given part id
	 * An ActionGroup is created once and cached for each unique part's id
	 * 
	 * @@param actionGroupId The request action group id
	 * @@param partDescriptor The workbench part descriptor
	 * @@return The ActionGroup with the given id
	 */
	protected final ActionGroup getActionGroup(String actionGroupId,
			IWorkbenchPartDescriptor partDescriptor) {
		ActionGroup actionGroup = actionGroupCache.getActionGroup(actionGroupId, partDescriptor);
		
		if (actionGroup == null) {
			actionGroup = createActionGroup(actionGroupId, partDescriptor);
			actionGroupCache.addActionGroup(actionGroupId, actionGroup, partDescriptor);
		}
		return actionGroup;
	}
	
	/**
	 * This method put in order to override the action registry caching. Used to
	 * get around unimplemented features of contribution item service.
	 * 
	 * @@param actionId
	 *            the action id
	 * @@param partDescriptor
	 *            the part descriptor
	 * @@param registry
	 *            the action registry
	 * @@return the action with <code>actionId</code> retrieved from the action
	 *         <code>registry</code>.
	 */
	protected IAction getActionFromRegistry(String actionId, IWorkbenchPartDescriptor partDescriptor, ActionRegistry registry){
		return registry.getAction(actionId);
	}

	/**
	 * Creates the action with the given id. By default, this method does
	 * nothing. Subclasses must override to provide their own implementation of
	 * action creation.
	 * 
	 * @@param actionId
	 *            The action id
	 * @@param partDescriptor
	 *            The workbench part descriptor
	 * @@return The action with the given id
	 */
	protected IAction createAction(
		String actionId,
		IWorkbenchPartDescriptor partDescriptor) {
		return null;
	}

	/**
	 * Creates the action group for the given id. By default, this method does
	 * nothing. Subclasses must override to provide their own implementation of
	 * action group creation.
	 * 
	 * @@param actionGroupId
	 *            The action group id
	 * @@param partDescriptor
	 *            The workbench part descriptor
	 * @@return Action Group for the given id
	 */
	protected ActionGroup createActionGroup(
		String actionGroupId,
		IWorkbenchPartDescriptor partDescriptor) {
		return null;
	}

	/**
	 * Creates the menu manager with the given id. By default, this method does
	 * nothing. Subclasses must override to provide their own implementation of
	 * menu manager creation.
	 * 
	 * @@param menuId
	 *            The menu manager id
	 * @@param partDescriptor
	 *            The workbench part descriptor
	 * @@return The menu manager with the given id
	 */
	protected IMenuManager createMenuManager(
		String menuId,
		IWorkbenchPartDescriptor partDescriptor) {
		return null;
	}

	/**
	 * Creates the custom contribution with the given id. By default, this
	 * method does nothing. Subclasses must override to provide their own
	 * implementation of custom contribution creation.
	 * 
	 * @@param customId
	 *            The custom contribution id
	 * @@param partDescriptor
	 *            The workbench part descriptor
	 * @@return The custom contribution with the given id
	 */
	protected IContributionItem createCustomContributionItem(
		String customId,
		IWorkbenchPartDescriptor partDescriptor) {
		return null;
	}

	/**
	 * Finds a menu manager using a '/' separated path.
	 * 
	 * @@param parent
	 *            The starting contribution manager
	 * @@param path
	 *            The '/' separated path
	 * @@return A menu manager described by the given path
	 */
	private IMenuManager findMenuUsingPath(
		IContributionManager parent,
		String path) {

		IContributionItem item = null;
		String id = path;
		String rest = null;
		int separator = path.indexOf('/');
		if (separator != -1) {
			id = path.substring(0, separator);
			rest = path.substring(separator + 1);
		} else {
			item = parent.find(path);
			if (item instanceof IMenuManager)
				return (IMenuManager) item;
		}

		item = parent.find(id);
		if (item instanceof IMenuManager) {
			IMenuManager manager = (IMenuManager) item;
			return manager.findMenuUsingPath(rest);
		}
		return null;
	}  
 
	/**
	 * Contributes the given item to the given manager in the given path/group.
	 * 
	 * @@param contributionItem
	 *            The item to be contributed
	 * @@param contributionManager
	 *            The manager to be contributed to
	 * @@param path
	 *            The path of contribution within the manager
	 * @@param group
	 *            The group of contribution within the path
	 */
	private void contributeItem(
		IAdaptable contributionItemAdapter,
		IContributionManager contributionManager,
		String path,
		String group) {

		// Find parent menu.
		if (path == null)
			return;
		IContributionManager parent = contributionManager;

		if (path.length() > 1) { // if path is more than '/'
			parent = findMenuUsingPath(parent, path.substring(1));
			if (parent == null) {
				Log.info(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionStatusCodes.SERVICE_FAILURE, "The contribution item path is invalid"); //$NON-NLS-1$
				return;
			}
		}

		//if contributing a menu group
		if (contributionItemAdapter
			instanceof MenuGroupContributionItemAdapter) {
			IContributionItem contributionItem =
				(IContributionItem) contributionItemAdapter.getAdapter(
					IContributionItem.class);
			parent.add(contributionItem);
			return;
		}
		
		//if contributing an action group
		if (contributionItemAdapter
			instanceof ActionGroupContributionItemAdapter) {

			try {
				ActionGroup actionGroup = 
					(ActionGroup) contributionItemAdapter.getAdapter(
						ActionGroup.class);
	
				if (parent instanceof IMenuManager) {
					actionGroup.fillContextMenu((IMenuManager) parent);
				}
			} catch (IllegalArgumentException e) {
				Trace.catching(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionDebugOptions.EXCEPTIONS_CATCHING, CommonUIServicesActionPlugin.getDefault().getClass(), "Error adding contribution item", e); //$NON-NLS-1$
				Log.error(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionStatusCodes.SERVICE_FAILURE, "Error adding contribution item", e); //$NON-NLS-1$
			}

			return;
		}
		
		// Find reference group.
		if (group == null)
			return;
		IContributionItem sep = parent.find(group);
		if (sep == null) {
			if (group.equals(ContributionItemConstants.GROUP_ADDITIONS)) {
				sep = new Separator(group);
				parent.add(sep);
			}
			if (sep == null) {
				Log.info(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionStatusCodes.SERVICE_FAILURE, "The contribution item group is invalid"); //$NON-NLS-1$
				return;
			}
		}

		// Add contribution to group
		try {
			IContributionItem contributionItem =
				(IContributionItem) contributionItemAdapter.getAdapter(
					IContributionItem.class);
			if (contributionItem != null) {
				if (sep.isGroupMarker())
					parent.appendToGroup(group, contributionItem);
				else
					parent.insertAfter(group, contributionItem);
			} else
				Log.info(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionStatusCodes.SERVICE_FAILURE, "Failed to create the contribution with id: " + (String) contributionItemAdapter.getAdapter(String.class)); //$NON-NLS-1$
		} catch (IllegalArgumentException e) {
			Trace.catching(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionDebugOptions.EXCEPTIONS_CATCHING, CommonUIServicesActionPlugin.getDefault().getClass(), "Error adding contribution item", e); //$NON-NLS-1$
			Log.error(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionStatusCodes.SERVICE_FAILURE, "Error adding contribution item", e); //$NON-NLS-1$
		}
	}

	/**
	 * Contributes the given item to the given manager in the given path/group.
	 * 
	 * @@param contributionItem
	 *            The item to be contributed
	 * @@param contributionManager
	 *            The manager to be contributed to
	 * @@param path
	 *            The path of contribution within the manager
	 * @@param group
	 *            The group of contribution within the path
	 */
	private void contributeItem(
		IAdaptable contributionItemAdapter,
		IActionBars actionBars) {

		//if contributing an action group
		if (contributionItemAdapter
			instanceof ActionGroupContributionItemAdapter) {

			try {
				ActionGroup actionGroup = 
					(ActionGroup) contributionItemAdapter.getAdapter(
						ActionGroup.class);
	
				actionGroup.fillActionBars(actionBars);
				return;
			} catch (IllegalArgumentException e) {
				Trace.catching(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionDebugOptions.EXCEPTIONS_CATCHING, CommonUIServicesActionPlugin.getDefault().getClass(), "Error adding contribution item", e); //$NON-NLS-1$
				Log.error(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionStatusCodes.SERVICE_FAILURE, "Error adding contribution item", e); //$NON-NLS-1$
			}
		}

		Log.info(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionStatusCodes.SERVICE_FAILURE, "Failed to create the contribution with id: " + (String) contributionItemAdapter.getAdapter(String.class)); //$NON-NLS-1$
	}

    /**
     * @@param id
     * @@param path
     * @@param contributionManager
     */
    private void removeExistingItem(String id, String path,
            IContributionManager contributionManager) {

        // Find the menu or action or group.
        if (id == null)
            return;
        
        IContributionManager parent = contributionManager;
        if (path.length() > 1) { // if path is more than '/'
            parent = findMenuUsingPath(contributionManager, path.substring(1));
            if (parent == null) {
                Log.info(CommonUIServicesActionPlugin.getDefault(), CommonUIServicesActionStatusCodes.SERVICE_FAILURE, "The contribution item path is invalid"); //$NON-NLS-1$
                return;
            }
        }

        IContributionItem predefinedItem = parent.find(id);
        if (predefinedItem == null) {
            Log.info(CommonUIServicesActionPlugin.getDefault(),
                CommonUIServicesActionStatusCodes.SERVICE_FAILURE,
                "The contribution item path is invalid"); //$NON-NLS-1$
            return;
        }

         if (predefinedItem instanceof AbstractGroupMarker) {
            IContributionItem allItems[] = parent.getItems();
            int groupIndex;
            for (groupIndex = 0; groupIndex < allItems.length; groupIndex++) {
                IContributionItem item = allItems[groupIndex];
                if (item.equals(predefinedItem)) {
                    break;
                }
            }
            for (int j = groupIndex + 1; j < allItems.length; j++) {
                IContributionItem item = allItems[j];
                if (item instanceof AbstractGroupMarker) {
                    break;
                }
                parent.remove(item);
            }

        }
        parent.remove(predefinedItem);

    }
    
	/**
     * An adapter for an action contribution item.
     */
	private class ActionContributionItemAdapter implements IAdaptable {
		private String actionId;
		private IWorkbenchPartDescriptor partDescriptor;
		private final IPartSelector partSelector;
		
		/**
		 * Creates an instance of <code>ActionContributionItemAdapter</code>.
		 * 
		 * @@param actionId attribute for action ID
		 * @@param partDescriptor attribute for partDescriptor
         * @@param partSelector selects parts that match this contribution item
		 */
		public ActionContributionItemAdapter(
			String actionId,
			IWorkbenchPartDescriptor partDescriptor,
			IPartSelector partSelector) {
			
			this.actionId = actionId;
			this.partDescriptor = partDescriptor;
			this.partSelector = partSelector;
		}

		public Object getAdapter(Class adapter) {
			if (adapter == IContributionItem.class) {
				IAction action = getAction(actionId, partDescriptor, partSelector);
				if (action != null) {
					return new PluginActionContributionItem(action);
				}
			} else if (adapter == String.class) {
				return actionId;
			}
			return null;
		}
	}
	
	/**
	 * An adapter for an action group contribution item.
	 */
	private class ActionGroupContributionItemAdapter implements IAdaptable {
		private String menuId;
		private IWorkbenchPartDescriptor partDescriptor;

		/**
		 * Creates an instance of <code>ActionGroupContributionItemAdapter</code>
		 * @@param menuId attribute for menu ID
		 * @@param partDescriptor attribute for partDescriptor
		 */
		public ActionGroupContributionItemAdapter(
			String menuId,
			IWorkbenchPartDescriptor partDescriptor) {
			this.menuId = menuId;
			this.partDescriptor = partDescriptor;
		}

		public Object getAdapter(Class adapter) {
			if (adapter == ActionGroup.class) {
				return getActionGroup(menuId, partDescriptor);
			} else if (adapter == String.class) {
				return menuId;
			}
			return null;
		}
	}

	/**
	 * An adapter for an menu contribution item.
	 */
	private class MenuContributionItemAdapter implements IAdaptable {
		private String menuId;
		private IWorkbenchPartDescriptor partDescriptor;

		/**
		 * Creates an instance of <code>MenuContributionItemAdapter</code>.
		 * 
		 * @@param menuId attribute for menuID
		 * @@param partDescriptor attribute for partDescriptor
		 */
		public MenuContributionItemAdapter(
			String menuId,
			IWorkbenchPartDescriptor partDescriptor) {
			this.menuId = menuId;
			this.partDescriptor = partDescriptor;
		}

		public Object getAdapter(Class adapter) {
			if (adapter == IContributionItem.class) {
                IMenuManager manager = createMenuManager(menuId, partDescriptor);
                if (manager != null) {
                    return new PluginMenuManager(manager);
                }
			} else if (adapter == String.class) {
				return menuId;
			}
			return null;
		}
	}

	/**
	 * An adapter for an menu group contribution item.
	 */
	private class MenuGroupContributionItemAdapter implements IAdaptable {
		private String groupId;
		private boolean isSeparator;

		/**
		 * Creates an instance of <code>MenuGroupContributionItemAdapter</code>.
		 * 
		 * @@param groupId attribute for groupID
		 * @@param isSeparator attribute for isSeparator
		 */
		public MenuGroupContributionItemAdapter(
			String groupId,
			boolean isSeparator) {
			this.groupId = groupId;
			this.isSeparator = isSeparator;
		}

		public Object getAdapter(Class adapter) {
			if (adapter == IContributionItem.class) {
				if (isSeparator)
					return new PluginSeparator(groupId);
				return new PluginGroupMarker(groupId);
			} else if (adapter == String.class) {
				return groupId;
			}
			return null;
		}
	}

	/**
	 * An adapter for an custom contribution item.
	 */
	private class CustomContributionItemAdapter implements IAdaptable {
		private String customId;
		private IWorkbenchPartDescriptor partDescriptor;

		/**
		 * Creates an instance of <code>CustomContributionItemAdapter</code>.
		 * 
		 * @@param customId attribute for customID
		 * @@param partDescriptor attribute for partDescriptor
		 */
		public CustomContributionItemAdapter(
			String customId,
			IWorkbenchPartDescriptor partDescriptor) {
			this.customId = customId;
			this.partDescriptor = partDescriptor;
		}

		public Object getAdapter(Class adapter) {
			if (adapter == IContributionItem.class) {
				IContributionItem item =
					createCustomContributionItem(customId, partDescriptor);
				return item;
			} else if (adapter == String.class) {
				return customId;
			}
			return null;
		}
	}
	
	/**
     * Checks if there are activities that have been matched to the plug-in or
     * id in which the item has been contributed and if at least one of those
     * matching activities are enabled.
     * 
     * @@return true if at least one matching activity is enabled
     */
    private boolean areActivitiesEnabled(final String itemID) {
        // check if the provider has been matched to a disabled activity id
        if (!ActivityUtil.isEnabled(getPluginContribution().getLocalId(),
            getPluginContribution().getPluginId())) {
            return false;
        }

        // now check if the item has been matched to a disabled activity id
        if (!ActivityUtil.isEnabled(itemID, getPluginContribution()
            .getPluginId())) {
            return false;
        }

        return true;
    }

	/**
	 * Sets the plugin contribution which identifies the plugin where the
	 * contributions were made so that these contributions can be filtered if an
	 * activity/capability associated with the plugin is disabled.
	 * 
	 * @@param pluginContribution
	 *            the plugin contribution
	 */
	void setPluginContribution(IPluginContribution pluginContribution) {
		this.pluginContribution = pluginContribution;
	}

	/**
	 * Gets the plugin contribution which identifies the plugin where the
	 * contributions were made so that these contributions can be filtered if an
	 * activity/capability associated with the plugin is disabled.
	 * 
	 * @@return the plugin contribution
	 */
	IPluginContribution getPluginContribution() {
		return pluginContribution;
	}

	/**
	 * An <code>IMenuManager</code> whose visibility is affected by
	 * activites/capabilities.
	 * 
	 * @@author cmahoney
	 */
	private class PluginMenuManager
		extends MenuManager {

		private IMenuManager realMenuManager;

		public PluginMenuManager(IMenuManager menuManager) {
			this.realMenuManager = menuManager;
		}

		public void add(IAction action) {
			realMenuManager.add(action);
		}

		public void add(IContributionItem item) {
			realMenuManager.add(item);
		}

		public void addMenuListener(IMenuListener listener) {
			realMenuManager.addMenuListener(listener);
		}

		public void appendToGroup(String groupName, IAction action) {
			realMenuManager.appendToGroup(groupName, action);
		}

		public void appendToGroup(String groupName, IContributionItem item) {
			realMenuManager.appendToGroup(groupName, item);
		}

		public void dispose() {
			realMenuManager.dispose();
		}

		public void fill(Composite parent) {
			realMenuManager.fill(parent);
		}

		public void fill(CoolBar parent, int index) {
			realMenuManager.fill(parent, index);
		}

		public void fill(Menu parent, int index) {
			realMenuManager.fill(parent, index);
		}

		public void fill(ToolBar parent, int index) {
			realMenuManager.fill(parent, index);
		}

		public IContributionItem find(String id) {
			return realMenuManager.find(id);
		}

		public IMenuManager findMenuUsingPath(String path) {
			return realMenuManager.findMenuUsingPath(path);
		}

		public IContributionItem findUsingPath(String path) {
			return realMenuManager.findUsingPath(path);
		}

		public String getId() {
			return realMenuManager.getId();
		}

		public IContributionItem[] getItems() {
			return realMenuManager.getItems();
		}

		public IContributionManagerOverrides getOverrides() {
			return realMenuManager.getOverrides();
		}

		public boolean getRemoveAllWhenShown() {
			return realMenuManager.getRemoveAllWhenShown();
		}

		public void insertAfter(String id, IAction action) {
			realMenuManager.insertAfter(id, action);
		}

		public void insertAfter(String id, IContributionItem item) {
			realMenuManager.insertAfter(id, item);
		}

		public void insertBefore(String id, IAction action) {
			realMenuManager.insertBefore(id, action);
		}

		public void insertBefore(String id, IContributionItem item) {
			realMenuManager.insertBefore(id, item);
		}

		public boolean isDirty() {
			return realMenuManager.isDirty();
		}

		public boolean isDynamic() {
			return realMenuManager.isDynamic();
		}

		public boolean isEmpty() {
			return realMenuManager.isEmpty();
		}

		public boolean isEnabled() {
			return realMenuManager.isEnabled();
		}

		public boolean isGroupMarker() {
			return realMenuManager.isGroupMarker();
		}

		public boolean isSeparator() {
			return realMenuManager.isSeparator();
		}

		public boolean isVisible() {
			if (!areActivitiesEnabled(getId())) {
				return false;
			}
			return realMenuManager.isVisible();
		}

		public void markDirty() {
			realMenuManager.markDirty();
		}

		public void prependToGroup(String groupName, IAction action) {
			realMenuManager.prependToGroup(groupName, action);
		}

		public void prependToGroup(String groupName, IContributionItem item) {
			realMenuManager.prependToGroup(groupName, item);
		}

		public IContributionItem remove(IContributionItem item) {
			return realMenuManager.remove(item);
		}

		public IContributionItem remove(String id) {
			return realMenuManager.remove(id);
		}

		public void removeAll() {
			realMenuManager.removeAll();
		}

		public void removeMenuListener(IMenuListener listener) {
			realMenuManager.removeMenuListener(listener);
		}

		public void saveWidgetState() {
			realMenuManager.saveWidgetState();
		}

		public void setParent(IContributionManager parent) {
			realMenuManager.setParent(parent);
		}

		public void setRemoveAllWhenShown(boolean removeAll) {
			realMenuManager.setRemoveAllWhenShown(removeAll);
		}

		public void setVisible(boolean visible) {
			realMenuManager.setVisible(visible);
		}

		public void update() {
			realMenuManager.update();
		}

		public void update(boolean force) {
			realMenuManager.update(force);
		}

		public void update(String id) {
			realMenuManager.update(id);
		}

		public void updateAll(boolean force) {
			realMenuManager.updateAll(force);
		}
	}

	/**
	 * A <code>Separator</code> whose visibility is affected by
	 * activites/capabilities.
	 * 
	 * @@author cmahoney
	 */
	private class PluginSeparator
		extends Separator {

		public PluginSeparator() {
			super();
		}

		public PluginSeparator(String groupName) {
			super(groupName);
		}

		public boolean isVisible() {
			if (!areActivitiesEnabled(getId())) {
				return false;
			}
			return super.isVisible();
		}

	}

	/**
	 * A <code>GroupMarker</code> whose visibility is affected by
	 * activites/capabilities.
	 * 
	 * @@author cmahoney
	 */
	private class PluginGroupMarker
		extends GroupMarker {

		public PluginGroupMarker(String groupName) {
			super(groupName);
		}

		public boolean isVisible() {
			if (!areActivitiesEnabled(getId())) {
				return false;
			}
			return super.isVisible();
		}

	}

	/**
	 * An <code>ActionContributionItem</code> whose visibility is affected by
	 * activites/capabilities.
	 * 
	 * @@author cmahoney
	 */
	private class PluginActionContributionItem
		extends ActionContributionItem {

		public PluginActionContributionItem(IAction action) {
			super(action);
		}

		public boolean isVisible() {
			if (!areActivitiesEnabled(getId())) {
				return false;
			}
			return super.isVisible();
		}
		
	}
    
    
}

@


1.11
log
@[181934] gmf_head crevells 070502 ContributionItemService does not filter actions on submenus of the context menu
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d50 1
d1063 1
a1063 1
		implements IMenuManager {
@


1.10
log
@[181934] gmf_head crevells 070417 Ability for DiagramContributionItemService to filter out individual actions based on capability enablement
@
text
@d37 1
a61 1
import org.eclipse.ui.PlatformUI;
a62 3
import org.eclipse.ui.activities.IIdentifier;
import org.eclipse.ui.activities.IWorkbenchActivitySupport;
import org.eclipse.ui.activities.WorkbenchActivityHelper;
a1016 6
        if (!WorkbenchActivityHelper.isFiltering())
            return true;

        IWorkbenchActivitySupport workbenchActivitySupport = PlatformUI
            .getWorkbench().getActivitySupport();

d1018 2
a1019 5
        IIdentifier id = workbenchActivitySupport.getActivityManager()
            .getIdentifier(
                WorkbenchActivityHelper
                    .createUnifiedId(getPluginContribution()));
        if (id != null && !id.isEnabled()) {
d1024 2
a1025 12
        id = workbenchActivitySupport.getActivityManager().getIdentifier(
            WorkbenchActivityHelper.createUnifiedId(new IPluginContribution() {

                public String getLocalId() {
                    return itemID;
                }

                public String getPluginId() {
                    return getPluginContribution().getPluginId();
                }
            }));
        if (id != null && !id.isEnabled()) {
@


1.9
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d96 1
a96 1
	
d1013 37
a1049 19
	 * Checks if there are activities that have been matched to the plug-in in
	 * which the provider has been contributed and if those activities are
	 * enabled.
	 * 
	 * @@return true if matching activities are enabled
	 */
	private boolean areActivitiesEnabled() {
		if (!WorkbenchActivityHelper.isFiltering())
			return true;

		IWorkbenchActivitySupport workbenchActivitySupport = PlatformUI
			.getWorkbench().getActivitySupport();
		IIdentifier id = workbenchActivitySupport.getActivityManager()
			.getIdentifier(
				WorkbenchActivityHelper
					.createUnifiedId(getPluginContribution()));
		if (id != null && !id.isEnabled()) {
			return false;
		}
d1051 2
a1052 2
		return true;
	}
d1201 1
a1201 1
			if (!areActivitiesEnabled()) {
d1286 1
a1286 1
			if (!areActivitiesEnabled()) {
d1308 1
a1308 1
			if (!areActivitiesEnabled()) {
d1330 1
a1330 1
			if (!areActivitiesEnabled()) {
d1337 2
@


1.8
log
@[144762] gmf_head ldamus 060614 ClassCastException on activating part that adapts to IEditingDomainProvider
@
text
@d267 1
a267 1
						getAction(item.getId(), partDescriptor));
d483 46
d875 1
a875 1
				IAction action = getAction(actionId, partDescriptor);
d877 1
a877 6
					PluginActionContributionItem item = new PluginActionContributionItem(action);
					// set the part selector to minimize action refresh on parts that are not relevant
					if (partSelector != null) {
						item.setPartSelector(partSelector);
					}
					return item;
d937 4
a940 1
				return new PluginMenuManager(createMenuManager(menuId, partDescriptor));
a1317 17
		/**
		 * Sets the part selector for this action. The part selector is used by
		 * the <code>AbstractActionHandler</code> to determine whether or not
		 * the action is applicable to a given selected part. If the part is not
		 * applicable, the action will not be refreshed when selection changes
		 * in the part.
		 * 
		 * @@param partSelector
		 *            the part selector
		 */
		public void setPartSelector(IPartSelector partSelector) {
			IAction action = getAction();
			
			if (action instanceof AbstractActionHandler) {
				((AbstractActionHandler) action).setPartSelector(partSelector);
			}
		}
@


1.8.2.1
log
@[132261] gmf_R1_0_maintenance ldamus 060810 Project explorer :  when you scroll using up/down keys, is slow : GMF tree selection change listener takes time
@
text
@d267 1
a267 1
						getAction(item.getId(), partDescriptor, item));
a482 29

	/**
	 * Returns the action with the given id that is created for the given part
	 * id. An action is created once and cached for each unique part's id.
	 * <P>
	 * The part selector is used is when the new action is an
	 * <code>AbstractActionHandler</code> to determine whether or not the
	 * action is applicable to a given selected part. If the part is not
	 * applicable, the action will not be refreshed when selection changes in
	 * the part.
	 * 
	 * @@param actionId
	 *            The request action id
	 * @@param partDescriptor
	 *            The workbench part descriptor
	 * @@param partSelector
	 *            The part selector
	 * @@return The action with the given id
	 */
	protected final IAction getAction(String actionId,
			IWorkbenchPartDescriptor partDescriptor, IPartSelector partSelector) {
		
		IAction result = getAction(actionId, partDescriptor);
		
		if (result instanceof AbstractActionHandler) {
			((AbstractActionHandler) result).setPartSelector(partSelector);
		}
		return result;
	}
@


1.8.2.2
log
@Bugzilla#156908 gmf_R1_0_maintenance cmahoney 060911 AbstractContributionItemProvider should not assume createMenuManager will not return null
@
text
@d925 1
a925 4
                IMenuManager manager = createMenuManager(menuId, partDescriptor);
                if (manager != null) {
                    return new PluginMenuManager(manager);
                }
@


1.8.2.3
log
@Bugzilla#157471 gmf_R1_0_maintenance cmahoney 060915 Toolbar buttons become out of sync with current diagram selection
@
text
@d504 1
a504 9

        boolean actionExistsAlready = false;
        ActionRegistry registry = (ActionRegistry) actionCache.get(partDescriptor);
        if (registry != null) {
            if (getActionFromRegistry(actionId, partDescriptor, registry) != null) {
                actionExistsAlready = true;
            }
        }
        
a505 9
        
        // If the action already existed in the registry and this is a popup
        // menu contribution, we do not want to override the part selector
        // already set as we could override the part selector for a toolbar
        // action.  See bugzilla#157471.
        if (actionExistsAlready
            && partSelector instanceof ProviderContributionDescriptor.AbstractPopupContributionItemDescriptor) {
            return result;
        }
d507 1
a507 1
		if (result instanceof AbstractActionHandler && partSelector != null) {
d858 1
a858 1
				IAction action = getAction(actionId, partDescriptor, partSelector);
d860 6
a865 1
					return new PluginActionContributionItem(action);
d1306 17
@


1.7
log
@Bugzilla#111221 gmf_head cmahoney 060404 Added ability to remove a previously contributed contribution item
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d25 1
d37 1
d248 2
a249 1
							partDescriptor),
d258 2
a259 1
						partDescriptor),
d379 2
a380 1
						partDescriptor),
d808 2
a809 1

d815 1
d819 3
a821 1
			IWorkbenchPartDescriptor partDescriptor) {
d824 1
d830 8
a837 2
				if (action != null)
					return new PluginActionContributionItem(action);
d1273 18
@


1.6
log
@Bugzilla 110815 gmf_head sshaw 051013 Zoom toolbar item not enabled until multiple diagrams are open
Contributed by: Cherie Mahoney
@
text
@d25 1
a26 1
import org.eclipse.gmf.runtime.common.ui.action.IActionWithProgress;
d38 1
d302 6
a307 3
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.ui.services.action.internal.contributionitem.IContributionItemProvider#updateActionBars(org.eclipse.ui.IActionBars, org.eclipse.gmf.runtime.common.ui.util.IWorkbenchPartDescriptor)
	 */
d405 2
d408 3
d614 2
a615 2
	}

d746 51
d798 2
a799 2
	 * An adapter for an action contribution item.
	 */
@


1.5
log
@Bugzilla 111651 gmf_head etworkow 051007 WorkbenchPartDescriptor is incorrectly spelled as WorkbenchPartDescirptor
@
text
@a883 1
				item.update();
@


1.4
log
@Bugzilla 111637 gmf_head ldamus 051005 IRepeatableAction should be deprecated
@
text
@d37 1
a37 1
import org.eclipse.gmf.runtime.common.ui.util.WorkbenchPartDescirptor;
d323 1
a323 1
			new WorkbenchPartDescirptor(
@


1.3
log
@Bugzilla 109904 gmf_head sshaw 050922 Capability support for Contribution Item Service
Contribution by: Cherie Mahoney
@
text
@d26 1
a26 1
import org.eclipse.gmf.runtime.common.ui.action.IRepeatableAction;
d463 2
a464 2
			if ( action instanceof IRepeatableAction ) {
				((IRepeatableAction)action).refresh();
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d15 1
d18 1
a20 15
import org.eclipse.jface.action.ActionContributionItem;
import org.eclipse.jface.action.GroupMarker;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.action.IContributionItem;
import org.eclipse.jface.action.IContributionManager;
import org.eclipse.jface.action.IMenuManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ISelectionProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.actions.ActionGroup;

d38 25
d74 1
a74 1
 * @@author melaasar
d86 13
d152 27
d195 9
a203 7
				contributeItem(
					new MenuContributionItemAdapter(
						item.getId(),
						partDescriptor),
					actionBars.getMenuManager(),
					item.getMenubarPath(),
					item.getMenubarGroup());
d218 9
a226 7
				contributeItem(
					new MenuGroupContributionItemAdapter(
						item.getId(),
						item.isSeparator()),
					actionBars.getMenuManager(),
					item.getMenubarPath(),
					item.getMenubarGroup());
d241 9
a249 7
				contributeItem(
					new ActionContributionItemAdapter(
						item.getId(),
						partDescriptor),
					actionBars.getMenuManager(),
					item.getMenubarPath(),
					item.getMenubarGroup());
d269 9
a277 7
				contributeItem(
					new CustomContributionItemAdapter(
						item.getId(),
						partDescriptor),
					actionBars.getMenuManager(),
					item.getMenubarPath(),
					item.getMenubarGroup());
d301 10
d418 2
d700 1
a700 1
	
d761 1
a761 1
					return new ActionContributionItem(action);
d820 1
a820 1
				return createMenuManager(menuId, partDescriptor);
d851 2
a852 2
					return new Separator(groupId);
				return new GroupMarker(groupId);
d892 78
d971 228
d1200 1
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

