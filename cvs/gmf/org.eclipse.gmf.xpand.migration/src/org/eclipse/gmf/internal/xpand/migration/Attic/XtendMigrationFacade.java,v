head	1.1;
access;
symbols
	ocl_qvt:1.1.0.2;
locks; strict;
comment	@# @;
expand	@k@;


1.1
date	2008.08.28.07.30.32;	author ashatalin;	state dead;
branches
	1.1.2.1;
next	;
commitid	5f8648b654184567;

1.1.2.1
date	2008.08.28.07.30.32;	author ashatalin;	state Exp;
branches;
next	1.1.2.2;
commitid	5f8648b654184567;

1.1.2.2
date	2008.08.28.15.51.01;	author ashatalin;	state Exp;
branches;
next	1.1.2.3;
commitid	35c448b6c95d4567;

1.1.2.3
date	2008.09.17.12.24.38;	author ashatalin;	state Exp;
branches;
next	1.1.2.4;
commitid	77f248d0f7054567;

1.1.2.4
date	2008.09.19.12.58.41;	author ashatalin;	state Exp;
branches;
next	1.1.2.5;
commitid	e12648d3a2014567;

1.1.2.5
date	2008.09.26.18.15.49;	author ashatalin;	state Exp;
branches;
next	1.1.2.6;
commitid	2780148dd26d24567;

1.1.2.6
date	2008.10.01.17.10.23;	author ashatalin;	state Exp;
branches;
next	1.1.2.7;
commitid	3bbdb48e3aefd4567;

1.1.2.7
date	2008.10.07.14.44.38;	author ashatalin;	state Exp;
branches;
next	1.1.2.8;
commitid	1997848eb75d34567;

1.1.2.8
date	2008.10.08.10.51.29;	author ashatalin;	state Exp;
branches;
next	1.1.2.9;
commitid	322ca48ec90b14567;

1.1.2.9
date	2008.10.08.12.10.42;	author ashatalin;	state Exp;
branches;
next	1.1.2.10;
commitid	3916648eca3424567;

1.1.2.10
date	2008.10.20.17.05.35;	author ashatalin;	state Exp;
branches;
next	1.1.2.11;
commitid	31f5648fcba5f4567;

1.1.2.11
date	2008.10.23.10.28.57;	author ashatalin;	state Exp;
branches;
next	;
commitid	3b4a6490051e84567;


desc
@@


1.1
log
@file XtendMigrationFacade.java was initially added on branch ocl_qvt.
@
text
@@


1.1.2.1
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Separate ExpressionMigrationFacade class was created covering expressions AST migration.
@
text
@a0 218
/**
 * Copyright (c) 2008 Borland Software Corp.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.xpand.migration;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Stack;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.gmf.internal.xpand.ResourceManager;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.EvaluationException;
import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;
import org.eclipse.gmf.internal.xpand.migration.MigrationException.Type;
import org.eclipse.gmf.internal.xpand.xtend.ast.CreateExtensionStatement;
import org.eclipse.gmf.internal.xpand.xtend.ast.ExpressionExtensionStatement;
import org.eclipse.gmf.internal.xpand.xtend.ast.Extension;
import org.eclipse.gmf.internal.xpand.xtend.ast.JavaExtensionStatement;
import org.eclipse.gmf.internal.xpand.xtend.ast.WorkflowSlotExtensionStatement;
import org.eclipse.gmf.internal.xpand.xtend.ast.XtendResource;

public class XtendMigrationFacade {

	private ResourceManager resourceManager;

	private StringBuilder output = new StringBuilder();

	private String resourceName;

	private StandardLibraryImports stdLibImportsManager;

	private boolean injectUnusedImports;

	private MigrationExecutionContext rootExecutionContext;

	private Stack<AbstractImportsManager> importsManagers = new Stack<AbstractImportsManager>();

	private TypeManager typeManager;

	private static String getLastSegment(String string, String separator) {
		int delimeterIndex = string.lastIndexOf(separator);
		if (delimeterIndex > 0) {
			return string.substring(delimeterIndex + separator.length());
		} else {
			return string;
		}
	}

	public XtendMigrationFacade(ResourceManager resourceManager, String xtendResourceName, boolean injectUnusedImports) {
		this(resourceManager, xtendResourceName);
		this.injectUnusedImports = injectUnusedImports;
	}

	public XtendMigrationFacade(ResourceManager resourceManager, String xtendResourceName, MigrationExecutionContext executionContext) {
		this(resourceManager, xtendResourceName);
		rootExecutionContext = executionContext;
	}

	public XtendMigrationFacade(ResourceManager resourceManager, String xtendResourceName) {
		this.resourceManager = resourceManager;
		this.resourceName = xtendResourceName;
	}

	public StringBuilder migrateXtendResource() throws MigrationException {
		XtendResource xtendResource = resourceManager.loadXtendResource(resourceName);
		if (xtendResource == null) {
			throw new MigrationException(Type.RESOURCE_NOT_FOUND, "Unable to load resource: " + resourceName);
		}
		MigrationExecutionContext ctx = (rootExecutionContext != null ? rootExecutionContext : new MigrationExecutionContextImpl(resourceManager)).cloneWithResource(xtendResource);
		Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
		xtendResource.analyze(ctx, issues);
		if (issues.size() > 0) {
			throw new MigrationException(issues);
		}

		String shortResourceName = getLastSegment(resourceName, SyntaxConstants.NS_DELIM);
		if (shortResourceName.length() == 0) {
			throw new MigrationException(Type.INCORRECT_RESOURCE_NAME, resourceName);
		}

		importsManagers.push(stdLibImportsManager = new StandardLibraryImports(output));
		addLibraryImports(xtendResource, false);
		if (xtendResource.getImportedExtensions().length > 0) {
			writeln("");
		}

		
		ModeltypeImports modeltypeImportsManger = new ModeltypeImports(output, injectUnusedImports);
		importsManagers.push(modeltypeImportsManger);
		for (String namespace : xtendResource.getImportedNamespaces()) {
			modeltypeImportsManger.registerModeltype(namespace);
		}
		typeManager = new TypeManager(modeltypeImportsManger);

		writeln("library " + shortResourceName + ";");
		writeln("");

		for (Iterator<Extension> it = xtendResource.getExtensions().iterator(); it.hasNext();) {
			Extension extension = it.next();
			migrateExtension(extension, ctx);
			if (it.hasNext()) {
				writeln("");
			}
		}
		while (!importsManagers.isEmpty()) {
			importsManagers.pop().injectImports();
		}
		return output;
	}

	private void addLibraryImports(XtendResource xtendResource, boolean reexportedOnly) throws MigrationException {
		for (String extension : xtendResource.getImportedExtensions()) {
			if (!reexportedOnly || xtendResource.isReexported(extension)) {
				writeln("import " + extension.replaceAll("::", ".") + ";");
				XtendResource referencedResource = resourceManager.loadXtendResource(extension);
				if (referencedResource == null) {
					throw new MigrationException(Type.RESOURCE_NOT_FOUND, "Unable to load extension file: " + extension);
				}
				addLibraryImports(referencedResource, true);
			}
		}
	}

	private void migrateExtension(Extension extension, MigrationExecutionContext ctx) throws MigrationException {
		try {
			extension.init(ctx);
		} catch (EvaluationException e) {
			throw new MigrationException(Type.ANALYZATION_PROBLEMS, e);
		}

		write("helper ");
		write(extension.getName());
		write("(");

		// assert extension.getParameterTypes().size() > 0;
		assert extension.getParameterNames().size() == extension.getParameterTypes().size();
		Iterator<String> parameterNames = extension.getParameterNames().iterator();
		Iterator<EClassifier> parameterTypes = extension.getParameterTypes().iterator();
		while (parameterNames.hasNext()) {
			write(parameterNames.next());
			write(" : ");
			write(typeManager.getQvtFQName(parameterTypes.next()));
			if (parameterNames.hasNext()) {
				write(", ");
			}
		}
		write(") : ");
		// TODO: check it!
		write(typeManager.getQvtFQName(getReturnType(extension, ctx)));
		writeln(" {");

		if (extension instanceof ExpressionExtensionStatement) {
			migrateExpressionExtension((ExpressionExtensionStatement) extension, ctx);
		} else if (extension instanceof JavaExtensionStatement) {
			migrateJavaExtension((JavaExtensionStatement) extension);
		} else if (extension instanceof CreateExtensionStatement) {
			migrateCreateExtension((CreateExtensionStatement) extension);
		} else if (extension instanceof WorkflowSlotExtensionStatement) {
			migrateWorkflowSlotExtension((WorkflowSlotExtensionStatement) extension);
		} else {
			throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
		}
		writeln("}");
	}

	private EClassifier getReturnType(Extension extension, MigrationExecutionContext ctx) throws MigrationException {
		Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
		EClassifier returnType = extension.getReturnType(extension.getParameterTypes().toArray(new EClassifier[extension.getParameterNames().size()]), ctx, issues);
		if (issues.size() > 0) {
			throw new MigrationException(issues);
		}
		if (returnType == null) {
			throw new MigrationException(Type.TYPE_NOT_FOUND, extension.getReturnTypeIdentifier().getValue());
		}
		return returnType;
	}

	private void migrateExpressionExtension(ExpressionExtensionStatement extension, MigrationExecutionContext ctx) throws MigrationException {
		write("\t");
		ExpressionMigrationFacade expressionMigrationFacade = new ExpressionMigrationFacade(extension.getExpression(), typeManager, stdLibImportsManager, new VariableNameDispatcher(extension), ctx);
		StringBuilder expressionContent = expressionMigrationFacade.migrate();
		writeln(expressionContent.insert(expressionMigrationFacade.getReturnPosition(), "return ").toString());
	}

	// TODO: java should be migrated separately from library - java class should
	// be created with the additional declaration in plugin.xml
	private void migrateJavaExtension(JavaExtensionStatement extension) throws MigrationException {
		throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
	}

	private void migrateCreateExtension(CreateExtensionStatement extension) throws MigrationException {
		throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
	}

	private void migrateWorkflowSlotExtension(WorkflowSlotExtensionStatement extension) throws MigrationException {
		throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
	}

	private void write(String word) {
		output.append(word);
	}

	private void writeln(String line) {
		output.append(line);
		output.append(ExpressionMigrationFacade.LF);
	}

}@


1.1.2.2
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 First step toward .xpt migration.
@
text
@d17 1
a17 1
import java.util.Map.Entry;
d46 2
a49 2
	private ModeltypeImports modeltypeImportsManger;

d91 1
a91 1
		stdLibImportsManager = new StandardLibraryImports(output);
d98 2
a99 1
		modeltypeImportsManger = new ModeltypeImports(output, injectUnusedImports);
d115 3
a117 2
		injectModeltypeImports();
		injectStdlibImports();
a120 30
	private void injectStdlibImports() {
		StringBuilder sb = new StringBuilder();
		for (String libraryName : stdLibImportsManager.getLibraries()) {
			sb.append("import library ");
			sb.append(libraryName);
			sb.append(";");
			sb.append(ExpressionMigrationFacade.LF);
		}
		if (sb.length() > 0) {
			sb.append(ExpressionMigrationFacade.LF);
			write(sb, stdLibImportsManager.getPlaceholderIndex());
		}
	}

	private void injectModeltypeImports() {
		StringBuilder sb = new StringBuilder();
		for (Entry<String, String> entry : modeltypeImportsManger.getModelTypes().entrySet()) {
			sb.append("modeltype ");
			sb.append(entry.getValue());
			sb.append(" uses \"");
			sb.append(entry.getKey());
			sb.append("\";");
			sb.append(ExpressionMigrationFacade.LF);
		}
		if (sb.length() > 0) {
			sb.append(ExpressionMigrationFacade.LF);
			write(sb, modeltypeImportsManger.getPlaceholderIndex());
		}
	}

d192 1
a192 1
		writeln(expressionContent.insert(expressionMigrationFacade.getReturnPosition(), "return "));
d209 2
a210 6
	private void write(CharSequence cs, int index) {
		output.insert(index, cs);
	}
	
	private void write(CharSequence cs) {
		output.append(cs);
d213 1
a213 1
	private void writeln(CharSequence line) {
@


1.1.2.3
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - ModelManager for model name substitutions was added
 - OclCs class added
 - FeatureCall positions calculation corrected
 - implicit/explicit extension first parameter migration with unit-tests
@
text
@a49 2
	private ModelManager modelManager;

a91 1
		modelManager = new ModelManager(stdLibImportsManager, false);
d218 1
a218 1
		ExpressionMigrationFacade expressionMigrationFacade = new ExpressionMigrationFacade(extension.getExpression(), typeManager, modelManager, new VariableNameDispatcher(extension), ctx);
@


1.1.2.4
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Problem with infix operation migration in expand corrected.
 - Skipping analyze warnings on migration.
@
text
@d84 1
a84 1
		if (MigrationException.hasErrors(issues)) {
d229 1
a229 1
//		throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
@


1.1.2.5
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - more gentle collection operations migration implemented
@
text
@d189 1
d221 1
a221 6
		ExpressionAnalyzeTrace expressionAnalyzeTrace = ctx.getTraces().get(extension);
		// TODO: resolve return type of ExpressionExtensionStatement using
		// corresponding identifier here in this context and use it as a desired
		// return type parameter
		ExpressionMigrationFacade expressionMigrationFacade = new ExpressionMigrationFacade(extension.getExpression(), expressionAnalyzeTrace.getResultType(), typeManager,
				modelManager, new VariableNameDispatcher(extension), ctx);
@


1.1.2.6
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Native library migration code added.
@
text
@a13 1
import java.util.ArrayList;
a15 1
import java.util.List;
a19 2
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
import org.eclipse.gmf.internal.xpand.BuiltinMetaModelExt;
a23 2
import org.eclipse.gmf.internal.xpand.expression.ast.DeclaredParameter;
import org.eclipse.gmf.internal.xpand.expression.ast.Identifier;
a33 4
	private static final String JAVA_ARRAY_TYPE_SUFFIX = ".List";

	private static final String JAVA_LANG_PACKAGE_PREFIX = "java.lang.";

d37 1
a37 1
	
a51 6
	private List<JavaExtensionDescriptor> javaExtensionDescriptors = new ArrayList<JavaExtensionDescriptor>();

	private String nativeLibraryClassName;

	private String nativeLibraryPackageName = "";

d100 1
a118 9
		
		nativeLibraryClassName = resourceName.replaceAll(SyntaxConstants.NS_DELIM, JavaCs.DOT);
		if (nativeLibraryClassName.lastIndexOf(JavaCs.DOT) > 0) {
			nativeLibraryPackageName = nativeLibraryClassName.substring(0, nativeLibraryClassName.lastIndexOf(JavaCs.DOT));
			nativeLibraryClassName = nativeLibraryClassName.substring(nativeLibraryClassName.lastIndexOf(JavaCs.DOT) + 1);
		}
		if (nativeLibraryClassName.length() == 0) {
			throw new MigrationException(Type.UNABLE_TO_DETECT_NATIVE_LIBRARY_CLASS_NAME, "Resource name: \"" + resourceName + "\"");
		}
a120 156
	
	/**
	 * This method should be executed only after migrateXtendResource() one
	 */
	public StringBuilder getNativeLibraryXmlDeclaration() {
		if (javaExtensionDescriptors.size() == 0) {
			return null;
		}
		StringBuilder result = new StringBuilder();
		result.append("<library class=\"");
		String nativeLibraryFullClassName = getNativeLibraryFullClassName();
		result.append(nativeLibraryFullClassName);
		result.append("\" id=\"");
		result.append(nativeLibraryFullClassName.replaceAll("\\.", "_"));
		result.append("\"/>");
		result.append(ExpressionMigrationFacade.LF);
		return result;
	}
	
	private String getNativeLibraryFullClassName() {
		return getNativeLibraryPackageName().length() == 0 ? getNativeLibraryClassName() : getNativeLibraryPackageName() + JavaCs.DOT + getNativeLibraryClassName();
	}

	/**
	 * This method should be executed only after migrateXtendResource() one
	 * @@throws MigrationException 
	 */
	public StringBuilder getNativeLibraryClassBody() throws MigrationException {
		if (javaExtensionDescriptors.size() == 0) {
			return null;
		}
		String lf = ExpressionMigrationFacade.LF;
		StringBuilder result = new StringBuilder();
		if (getNativeLibraryPackageName().length() > 0) {
			result.append("package ");
			result.append(getNativeLibraryPackageName());
			result.append(";");
			result.append(lf);
		}
		result.append("public class ");
		result.append(getNativeLibraryClassName());
		result.append(" {");
		result.append(lf);
		
		result.append("public static class Metainfo {");
		result.append(lf);
		for (JavaExtensionDescriptor descriptor : javaExtensionDescriptors) {
			addMetainfoMethod(descriptor, result);
			result.append(lf);
		}
		result.append("}");
		result.append(lf);
		
		for (JavaExtensionDescriptor descriptor : javaExtensionDescriptors) {
			addNativeMethod(descriptor, result);
			result.append(lf);
		}
		
		result.append("}");
		return result;
	}
	
	private void addNativeMethod(JavaExtensionDescriptor descriptor, StringBuilder result) throws MigrationException {
		result.append("public ");
		result.append(getJavaType(descriptor.getReturnType()));
		result.append(" ");
		result.append(descriptor.getMethodName());
		result.append("(");
		List<EClassifier> parameterTypes = descriptor.getParameterTypes();
		List<String> parameterNames = descriptor.getParameterNames();
		assert parameterTypes.size() == parameterNames.size();
		for (int i = 0; i < parameterTypes.size(); i++) {
			if (i > 0) {
				result.append(", ");
			}
			result.append(getJavaType(parameterTypes.get(i)));
			result.append(" ");
			result.append(parameterNames.get(i));
		}
		result.append(") { return ");
		result.append(descriptor.getClassName());
		result.append(JavaCs.DOT);
		result.append(descriptor.getMethodName());
		result.append("(");
		List<String> javaParameterTypes = descriptor.getJavaParameterTypes();
		for (int i = 0; i < parameterNames.size(); i++) {
			if (i > 0) {
				result.append(", ");
			}
			result.append(parameterNames.get(i));
			String javaParameterType = javaParameterTypes.get(i);
			if (javaParameterType.endsWith(JAVA_ARRAY_TYPE_SUFFIX)) {
				javaParameterType = javaParameterType.substring(0, javaParameterType.length() - JAVA_ARRAY_TYPE_SUFFIX.length());
				result.append(".toArray(new ");
				result.append(suppressJavaLang(javaParameterType));
				result.append("[");
				result.append(parameterNames.get(i));
				result.append(".size()]");
				result.append(")");
			}
		}
		result.append("); ");
		result.append("}");
	}

	private String getJavaType(EClassifier xpandType) throws MigrationException {
		if (xpandType == BuiltinMetaModel.VOID) {
			throw new MigrationException(Type.UNSUPPORTED_NATIVE_EXTENSION_TYPE, "Void type is not supported for native extensions");
		}
		if (xpandType.getInstanceClassName() != null) {
			String instanceClassName = xpandType.getInstanceClassName();
			return suppressJavaLang(instanceClassName);
		}
		if (BuiltinMetaModelExt.isSetType(xpandType)) {
			return "java.util.Set";
		} else if (BuiltinMetaModelExt.isListType(xpandType)) {
			return "java.util.List";
		} else if (BuiltinMetaModelExt.isCollectionType(xpandType)) {
			return "java.util.Collection";
		}
		throw new MigrationException(Type.UNSUPPORTED_NATIVE_EXTENSION_TYPE, "Metamodel types without instanceClassName set are not supported for native extensions: " + xpandType.getName());
	}

	private String suppressJavaLang(String instanceClassName) {
		// Suppressing "java.lang" package.
		if (instanceClassName.startsWith(JAVA_LANG_PACKAGE_PREFIX)) {
			String simpleClassName = instanceClassName.substring(JAVA_LANG_PACKAGE_PREFIX.length());
			if (simpleClassName.indexOf(JavaCs.DOT) == -1) {
				return simpleClassName;
			}
		}
		return instanceClassName;
	}

	private void addMetainfoMethod(JavaExtensionDescriptor descriptor, StringBuilder result) throws MigrationException {
		result.append("public static String[] ");
		result.append(descriptor.getMethodName());
		result.append("(");
		result.append(") { return new String[] {\"");
		result.append(typeManager.getQvtFQName(descriptor.getReturnType()));
		result.append("\"");
		for (EClassifier parameterType : descriptor.getParameterTypes()) {
			result.append(", \"");
			result.append(typeManager.getQvtFQName(parameterType));
			result.append("\"");
		}
		result.append("}; }");
	}

	public String getNativeLibraryClassName() {
		return nativeLibraryClassName;
	}
	
	public String getNativeLibraryPackageName() {
		return nativeLibraryPackageName;
	}
d155 1
a155 1
				writeln("import " + extension.replaceAll(SyntaxConstants.NS_DELIM, OclCs.NAMESPACE_SEPARATOR) + ";");
a165 5
		if (extension instanceof JavaExtensionStatement) {
			migrateJavaExtension((JavaExtensionStatement) extension, ctx);
			return;
		}
		
d194 2
d232 2
a233 2
	private void migrateJavaExtension(JavaExtensionStatement extension, MigrationExecutionContext ctx) throws MigrationException {
		javaExtensionDescriptors.add(new JavaExtensionDescriptor(extension, ctx));
a255 63
	
	class JavaExtensionDescriptor {

		private String extensionName;

		private String className;

		private String methodName;

		private EClassifier returnType;

		private List<EClassifier> parameterTypes = new ArrayList<EClassifier>();
		
		private List<String> parameterNames = new ArrayList<String>();
		
		private List<String> javaParameterTypes = new ArrayList<String>();

		public JavaExtensionDescriptor(JavaExtensionStatement javaExtension, MigrationExecutionContext ctx) {
			extensionName = javaExtension.getName();
			className = javaExtension.getJavaType().getValue();
			methodName = javaExtension.getJavaMethod().getValue();

			assert javaExtension.getReturnTypeIdentifier() != null;
			returnType = ctx.getTypeForName(javaExtension.getReturnTypeIdentifier().getValue());
			for (DeclaredParameter parameter : javaExtension.getFormalParameters()) {
				parameterTypes.add(ctx.getTypeForName(parameter.getType().getValue()));
				parameterNames.add(parameter.getName().getValue());
			}
			assert javaExtension.getFormalParameters().size() == javaExtension.getJavaParameterTypes().size();
			for (Identifier paramType : javaExtension.getJavaParameterTypes()) {
				javaParameterTypes.add(paramType.getValue());
			}
		}

		public String getExtensionName() {
			return extensionName;
		}

		public String getClassName() {
			return className;
		}

		public String getMethodName() {
			return methodName;
		}

		public EClassifier getReturnType() {
			return returnType;
		}

		public List<EClassifier> getParameterTypes() {
			return parameterTypes;
		}
		
		public List<String> getParameterNames() {
			return parameterNames;
		}
		
		public List<String> getJavaParameterTypes() {
			return javaParameterTypes;
		}

	}
@


1.1.2.7
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Project-wide migrate action handling native extensions was added.
@
text
@a21 1
import org.eclipse.emf.ecore.EcorePackage;
d211 14
a224 2
		addNativeMethodSignature(descriptor, result);
		result.append(" { return ");
a228 1
		List<String> parameterNames = descriptor.getParameterNames();
a253 4
//		//TODO: check if it is working for all the cases..
//		if (xpandType == EcorePackage.eINSTANCE.getEJavaObject()) {
//			return "org.eclipse.emf.ecore.EObject";
//		}
d281 3
a283 2
		addNativeMethodSignature(descriptor, result);
		result.append(" { return new String[] {\"");
a293 17
	private void addNativeMethodSignature(JavaExtensionDescriptor descriptor, StringBuilder result) throws MigrationException {
		result.append(descriptor.getMethodName());
		result.append("(");
		List<EClassifier> parameterTypes = descriptor.getParameterTypes();
		List<String> parameterNames = descriptor.getParameterNames();
		assert parameterTypes.size() == parameterNames.size();
		for (int i = 0; i < parameterTypes.size(); i++) {
			if (i > 0) {
				result.append(", ");
			}
			result.append(getJavaType(parameterTypes.get(i)));
			result.append(" ");
			result.append(parameterNames.get(i));
		}
		result.append(")");
	}

d424 1
a424 2
		write("return ");
		writeln(extension.getSlotName().getValue());
@


1.1.2.8
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Correcting native extensions migration.
@
text
@d22 1
d277 2
d280 3
a282 2
			result.append(typeManager.getQvtFQName(parameterType, true));
			result.append("\", \"");
a283 2
		result.append(typeManager.getQvtFQName(descriptor.getReturnType(), true));
		result.append("\"");
@


1.1.2.9
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Correcting native extensions migration.
@
text
@a36 1
import org.eclipse.ocl.types.VoidType;
a62 2
	
	private List<String> importedMetamodels = new ArrayList<String>();
a118 1
			importedMetamodels.add(namespace);
d159 1
a159 7
		result.append("\">");
		for (String	metamodel : importedMetamodels) {
			result.append("<inMetamodel uri=\"");
			result.append(metamodel);
			result.append("\"/>");
		}
		result.append("</library>");
d243 4
d275 1
a275 5
		result.append(" { return new String[] {\"oclstdlib::");
		result.append(VoidType.SINGLETON_NAME);
		result.append("\", \"");
		TypeManager nativeLibrariesTypeManager = new TypeManager();
		nativeLibrariesTypeManager.setUseFQNameForPrimitiveTypes(true);
d277 1
a277 1
			result.append(nativeLibrariesTypeManager.getQvtFQName(parameterType));
d280 1
a280 1
		result.append(nativeLibrariesTypeManager.getQvtFQName(descriptor.getReturnType()));
d286 1
a286 1
		result.append(descriptor.getExtensionName());
@


1.1.2.10
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Native libraries support modified
@
text
@a36 1
import org.eclipse.ocl.ecore.internal.OCLStandardLibraryImpl;
d162 1
a162 1
		result.append(getNativeLibraryID(nativeLibraryFullClassName));
a173 7
	private String getNativeLibraryID(String nativeLibraryFullClassName) {
		if (nativeLibraryFullClassName.indexOf(".") == -1) {
			return "_" + nativeLibraryClassName;
		}
		return nativeLibraryFullClassName.replaceAll("\\.", "_");
	}

d281 1
a281 3
		result.append(" { return new String[] {\"");
		result.append(OCLStandardLibraryImpl.stdlibPackage.getName());
		result.append(OclCs.PATH_SEPARATOR); 
@


1.1.2.11
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
- using "Boolean" insteadn of "boolean" in native extensions
@
text
@a21 1
import org.eclipse.emf.ecore.EcorePackage;
a260 3
		if (xpandType == EcorePackage.eINSTANCE.getEBoolean()) {
			return "Boolean";
		}
@


