head	1.1;
access;
symbols
	ocl_qvt:1.1.0.2;
locks; strict;
comment	@# @;
expand	@k@;


1.1
date	2008.08.28.07.30.32;	author ashatalin;	state dead;
branches
	1.1.2.1;
next	;
commitid	5f8648b654184567;

1.1.2.1
date	2008.08.28.07.30.32;	author ashatalin;	state Exp;
branches;
next	1.1.2.2;
commitid	5f8648b654184567;

1.1.2.2
date	2008.09.15.11.11.32;	author ashatalin;	state Exp;
branches;
next	1.1.2.3;
commitid	562548ce42e34567;

1.1.2.3
date	2008.09.17.12.24.38;	author ashatalin;	state Exp;
branches;
next	1.1.2.4;
commitid	77f248d0f7054567;

1.1.2.4
date	2008.09.26.18.15.49;	author ashatalin;	state Exp;
branches;
next	1.1.2.5;
commitid	2780148dd26d24567;

1.1.2.5
date	2008.10.08.10.51.29;	author ashatalin;	state Exp;
branches;
next	1.1.2.6;
commitid	322ca48ec90b14567;

1.1.2.6
date	2008.10.08.12.10.42;	author ashatalin;	state Exp;
branches;
next	1.1.2.7;
commitid	3916648eca3424567;

1.1.2.7
date	2008.10.20.17.07.16;	author ashatalin;	state Exp;
branches;
next	;
commitid	3202b48fcbac44567;


desc
@@


1.1
log
@file TypeManager.java was initially added on branch ocl_qvt.
@
text
@@


1.1.2.1
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Separate ExpressionMigrationFacade class was created covering expressions AST migration.
@
text
@a0 88
/**
 * Copyright (c) 2008 Borland Software Corp.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.xpand.migration;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
import org.eclipse.ocl.ecore.PrimitiveType;
import org.eclipse.ocl.types.AnyType;
import org.eclipse.ocl.types.VoidType;

public class TypeManager {

	private static final String OCL_PATH_SEPARATOR = "::";

	private ModeltypeImports modeltypeImportsManger;

	public static final boolean isListType(EClassifier classifier) {
		return classifier.getName().endsWith(BuiltinMetaModel.LIST);
	}

	public static final boolean isSetType(EClassifier classifier) {
		return classifier.getName().endsWith(BuiltinMetaModel.SET);
	}

	public TypeManager(ModeltypeImports modelImports) {
		modeltypeImportsManger = modelImports;
	}

	public String getQvtFQName(EEnumLiteral literal) {
		return modeltypeImportsManger.getModeltypeAlias(literal.getEEnum().getEPackage()) + OCL_PATH_SEPARATOR + literal.getEEnum().getName() + OCL_PATH_SEPARATOR + literal.getName();
	}

	public String getQvtFQName(EClassifier classifier) throws MigrationException {
		if (classifier == BuiltinMetaModel.VOID) {
			return VoidType.SINGLETON_NAME;
		}
		if (classifier instanceof EDataType) {
			/**
			 * Handling QVT primitive types here.
			 */
			if (EcorePackage.eINSTANCE.getEString() == classifier) {
				return PrimitiveType.STRING_NAME;
			} else if (EcorePackage.eINSTANCE.getEBoolean() == classifier) {
				return PrimitiveType.BOOLEAN_NAME;
			} else if (EcorePackage.eINSTANCE.getEInt() == classifier) {
				return PrimitiveType.INTEGER_NAME;
			} else if (EcorePackage.eINSTANCE.getEDouble() == classifier) {
				return PrimitiveType.REAL_NAME;
			} else if (EcorePackage.eINSTANCE.getEJavaObject() == classifier) {
				return AnyType.SINGLETON_NAME;
			}
		}
		if (BuiltinMetaModel.isCollectionType(classifier)) {
			StringBuilder sb = new StringBuilder();
			if (isSetType(classifier)) {
				sb.append("Set(");
			} else if (isListType(classifier)) {
				sb.append("Sequence(");
			} else {
				sb.append("Collection(");
			}
			// was: if (classifier ==
			// CollectionTypesSupport.COLLECTION_OF_OBJECT || classifier ==
			// CollectionTypesSupport.LIST_OF_OBJECT || classifier ==
			// CollectionTypesSupport.SET_OF_OBJECT) {
			sb.append(getQvtFQName(BuiltinMetaModel.getInnerType(classifier)));
			return sb.append(")").toString();
		}
		EPackage ePackage = classifier.getEPackage();
		assert ePackage != null;
		String alias = modeltypeImportsManger.getModeltypeAlias(ePackage);
		return alias + OCL_PATH_SEPARATOR + classifier.getName();
	}

}
@


1.1.2.2
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Definition parameters migration + tests.
@
text
@d28 1
a28 1
	private final ModeltypeImports modeltypeImportsManger;
a36 4
	
	public TypeManager() {
		modeltypeImportsManger = null;
	}
d43 1
a43 1
		return getPackageName(literal.getEEnum().getEPackage()) + OCL_PATH_SEPARATOR + literal.getEEnum().getName() + OCL_PATH_SEPARATOR + literal.getName();
d84 2
a85 5
		return getPackageName(ePackage) + OCL_PATH_SEPARATOR + classifier.getName();
	}
	
	private String getPackageName(EPackage ePackage) {
		return modeltypeImportsManger != null ? modeltypeImportsManger.getModeltypeAlias(ePackage) : ePackage.getName();
@


1.1.2.3
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - ModelManager for model name substitutions was added
 - OclCs class added
 - FeatureCall positions calculation corrected
 - implicit/explicit extension first parameter migration with unit-tests
@
text
@d20 1
a21 4
import org.eclipse.ocl.types.CollectionType;
import org.eclipse.ocl.types.PrimitiveType;
import org.eclipse.ocl.types.SequenceType;
import org.eclipse.ocl.types.SetType;
d26 2
d37 1
a37 1

d47 1
a47 1
		return getPackageName(literal.getEEnum().getEPackage()) + OclCs.PATH_SEPARATOR + literal.getEEnum().getName() + OclCs.PATH_SEPARATOR + literal.getName();
d73 1
a73 1
				sb.append(SetType.SINGLETON_NAME);
d75 1
a75 1
				sb.append(SequenceType.SINGLETON_NAME);
d77 1
a77 1
				sb.append(CollectionType.SINGLETON_NAME);
d79 4
a82 1
			sb.append(OclCs.OPEN_PAREN);
d84 1
a84 1
			return sb.append(OclCs.CLOSE_PAREN).toString();
d88 1
a88 1
		return getPackageName(ePackage) + OclCs.PATH_SEPARATOR + classifier.getName();
d90 1
a90 1

@


1.1.2.4
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - more gentle collection operations migration implemented
@
text
@a37 10
	
	public static final EClassifier getCollectionOfType(EClassifier originalCollection, EClassifier innerElementType) {
		if (isListType(originalCollection)) {
			return BuiltinMetaModel.getListType(innerElementType);
		} else if (isSetType(originalCollection)) {
			return BuiltinMetaModel.getSetType(innerElementType);
		} else {
			return BuiltinMetaModel.getCollectionType(innerElementType);
		}
	}
@


1.1.2.5
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Correcting native extensions migration.
@
text
@a19 1
import org.eclipse.ocl.ecore.internal.OCLStandardLibraryImpl;
d60 1
a60 1
	
a61 4
		return getQvtFQName(classifier, false);
	}

	public String getQvtFQName(EClassifier classifier, boolean useFQNameForPrimitiveTypes) throws MigrationException {
d70 1
a70 1
				return getPrimitiveTypeName(PrimitiveType.STRING_NAME, useFQNameForPrimitiveTypes);
d72 1
a72 1
				return getPrimitiveTypeName(PrimitiveType.BOOLEAN_NAME, useFQNameForPrimitiveTypes);
d74 1
a74 1
				return getPrimitiveTypeName(PrimitiveType.INTEGER_NAME, useFQNameForPrimitiveTypes);
d76 1
a76 1
				return getPrimitiveTypeName(PrimitiveType.REAL_NAME, useFQNameForPrimitiveTypes);
d78 1
a78 1
				return getPrimitiveTypeName(AnyType.SINGLETON_NAME, useFQNameForPrimitiveTypes);
a98 4
	private String getPrimitiveTypeName(String primitiveTypeName, boolean useFQNameForPrimitiveTypes) {
		return useFQNameForPrimitiveTypes ? OCLStandardLibraryImpl.stdlibPackage.getName() + OclCs.PATH_SEPARATOR + primitiveTypeName: primitiveTypeName;
	}

@


1.1.2.6
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Correcting native extensions migration.
@
text
@a30 2
	
	private boolean useFQNameForPrimitiveTypes = false;
d53 1
a53 1
	
a56 4
	
	public void setUseFQNameForPrimitiveTypes(boolean value) {
		useFQNameForPrimitiveTypes = value;
	}
d63 4
@


1.1.2.7
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Removing obsolete methods
@
text
@a19 1
import org.eclipse.gmf.internal.xpand.BuiltinMetaModelExt;
a22 1
import org.eclipse.ocl.types.OrderedSetType;
d34 18
d90 1
a90 1
			if (BuiltinMetaModelExt.isSetType(classifier)) {
d92 1
a92 1
			} else if (BuiltinMetaModelExt.isListType(classifier)) {
a93 2
			} else if (BuiltinMetaModelExt.isOrderedSetType(classifier)) { 
				sb.append(OrderedSetType.SINGLETON_NAME);
@


