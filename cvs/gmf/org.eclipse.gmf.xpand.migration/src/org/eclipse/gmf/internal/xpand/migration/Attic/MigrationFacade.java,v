head	1.1;
access;
symbols
	ocl_qvt:1.1.0.2;
locks; strict;
comment	@# @;
expand	@k@;


1.1
date	2008.08.01.09.16.53;	author ashatalin;	state dead;
branches
	1.1.2.1;
next	;
commitid	6e264892d4804567;

1.1.2.1
date	2008.08.01.09.16.53;	author ashatalin;	state Exp;
branches;
next	1.1.2.2;
commitid	6e264892d4804567;

1.1.2.2
date	2008.08.05.10.42.09;	author ashatalin;	state Exp;
branches;
next	1.1.2.3;
commitid	41ee48982e7f4567;

1.1.2.3
date	2008.08.05.19.27.01;	author ashatalin;	state Exp;
branches;
next	1.1.2.4;
commitid	2d344898a9834567;

1.1.2.4
date	2008.08.06.09.52.28;	author ashatalin;	state Exp;
branches;
next	1.1.2.5;
commitid	437c4899745a4567;

1.1.2.5
date	2008.08.06.12.03.12;	author ashatalin;	state Exp;
branches;
next	1.1.2.6;
commitid	104a489992fe4567;

1.1.2.6
date	2008.08.07.14.18.47;	author ashatalin;	state Exp;
branches;
next	1.1.2.7;
commitid	613d489b04464567;

1.1.2.7
date	2008.08.08.18.54.11;	author ashatalin;	state Exp;
branches;
next	1.1.2.8;
commitid	b5f489c96514567;

1.1.2.8
date	2008.08.13.09.24.39;	author ashatalin;	state Exp;
branches;
next	1.1.2.9;
commitid	1f3148a2a8554567;

1.1.2.9
date	2008.08.13.10.52.55;	author ashatalin;	state Exp;
branches;
next	1.1.2.10;
commitid	5a1d48a2bd054567;

1.1.2.10
date	2008.08.15.11.48.33;	author ashatalin;	state Exp;
branches;
next	1.1.2.11;
commitid	373748a56d0c4567;

1.1.2.11
date	2008.08.15.18.36.21;	author ashatalin;	state Exp;
branches;
next	1.1.2.12;
commitid	13e48a5cca14567;

1.1.2.12
date	2008.08.18.19.02.46;	author ashatalin;	state Exp;
branches;
next	1.1.2.13;
commitid	6c0e48a9c7514567;

1.1.2.13
date	2008.08.18.19.50.12;	author ashatalin;	state Exp;
branches;
next	1.1.2.14;
commitid	438348a9d2724567;

1.1.2.14
date	2008.08.19.15.18.37;	author ashatalin;	state Exp;
branches;
next	1.1.2.15;
commitid	32fd48aae4494567;

1.1.2.15
date	2008.08.19.16.56.42;	author ashatalin;	state Exp;
branches;
next	1.1.2.16;
commitid	14b548aafb484567;

1.1.2.16
date	2008.08.20.10.03.49;	author ashatalin;	state Exp;
branches;
next	1.1.2.17;
commitid	d1a48abec034567;

1.1.2.17
date	2008.08.21.12.22.18;	author ashatalin;	state Exp;
branches;
next	1.1.2.18;
commitid	348648ad5df34567;

1.1.2.18
date	2008.08.21.15.35.29;	author ashatalin;	state Exp;
branches;
next	1.1.2.19;
commitid	1a2548ad8b3d4567;

1.1.2.19
date	2008.08.22.10.28.39;	author ashatalin;	state Exp;
branches;
next	1.1.2.20;
commitid	21fa48ae94d54567;

1.1.2.20
date	2008.08.22.12.32.38;	author ashatalin;	state Exp;
branches;
next	1.1.2.21;
commitid	752448aeb1e44567;

1.1.2.21
date	2008.08.26.14.20.54;	author ashatalin;	state Exp;
branches;
next	1.1.2.22;
commitid	69bc48b411454567;

1.1.2.22
date	2008.08.26.16.14.20;	author ashatalin;	state Exp;
branches;
next	1.1.2.23;
commitid	615c48b42bdb4567;

1.1.2.23
date	2008.08.27.10.37.38;	author ashatalin;	state Exp;
branches;
next	1.1.2.24;
commitid	6f6b48b52e714567;

1.1.2.24
date	2008.08.28.07.30.33;	author ashatalin;	state dead;
branches;
next	;
commitid	5f8648b654184567;


desc
@@


1.1
log
@file MigrationFacade.java was initially added on branch ocl_qvt.
@
text
@@


1.1.2.1
log
@Migration implementation + unit-tests for basic extend elements.
@
text
@a0 301
/**
 * Copyright (c) 2008 Borland Software Corp.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.xpand.migration;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.gmf.internal.xpand.ResourceManager;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.EvaluationException;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContext;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContextImpl;
import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;
import org.eclipse.gmf.internal.xpand.expression.ast.BooleanLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.BooleanOperation;
import org.eclipse.gmf.internal.xpand.expression.ast.Cast;
import org.eclipse.gmf.internal.xpand.expression.ast.ChainExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.CollectionExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.ConstructorCallExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.Expression;
import org.eclipse.gmf.internal.xpand.expression.ast.FeatureCall;
import org.eclipse.gmf.internal.xpand.expression.ast.IfExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.IntegerLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.LetExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.ListLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.NullLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.OperationCall;
import org.eclipse.gmf.internal.xpand.expression.ast.RealLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.StringLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.SwitchExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.TypeSelectExpression;
import org.eclipse.gmf.internal.xpand.migration.MigrationException.Type;
import org.eclipse.gmf.internal.xpand.xtend.ast.CreateExtensionStatement;
import org.eclipse.gmf.internal.xpand.xtend.ast.ExpressionExtensionStatement;
import org.eclipse.gmf.internal.xpand.xtend.ast.Extension;
import org.eclipse.gmf.internal.xpand.xtend.ast.JavaExtensionStatement;
import org.eclipse.gmf.internal.xpand.xtend.ast.WorkflowSlotExtensionStatement;
import org.eclipse.gmf.internal.xpand.xtend.ast.XtendResource;
import org.eclipse.ocl.ecore.PrimitiveType;

public class MigrationFacade {

	static final String LF = System.getProperty("line.separator");

	private static final String OCL_PATH_SEPARATOR = "::";

	private ResourceManager resourceManager;

	private StringBuilder output = new StringBuilder();

	private String resourceName;

	private ModeltypeImports modeltypeImports;

	private boolean injectUnusedImports;
	
	public MigrationFacade(ResourceManager resourceManager, String xtendResourceName, boolean injectUnusedImports) {
		this(resourceManager, xtendResourceName);
		this.injectUnusedImports = injectUnusedImports;
	}

	public MigrationFacade(ResourceManager resourceManager, String xtendResourceName) {
		this.resourceManager = resourceManager;
		this.resourceName = xtendResourceName;
	}

	public StringBuilder migrateXtendResource() throws MigrationException {
		XtendResource xtendResource = resourceManager.loadXtendResource(resourceName);
		if (xtendResource == null) {
			throw new MigrationException(Type.RESOURCE_NOT_FOUND, "Unable to load resource: " + resourceName);
		}
		ExecutionContext ctx = new ExecutionContextImpl(resourceManager);
		ctx = ctx.cloneWithResource(xtendResource);
		Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
		xtendResource.analyze(ctx, issues);
		if (issues.size() > 0) {
			throw new MigrationException(issues);
		}

		String shortResourceName = getLastSegment(resourceName, SyntaxConstants.NS_DELIM);
		if (shortResourceName.length() == 0) {
			throw new MigrationException(Type.INCORRECT_RESOURCE_NAME, resourceName);
		}

		modeltypeImports = new ModeltypeImports(output, injectUnusedImports);

		for (String namespace : xtendResource.getImportedNamespaces()) {
			modeltypeImports.registerModeltype(namespace);
		}
		
		addLibraryImports(xtendResource, false);

		writeln("library " + shortResourceName + ";" + LF);

		for (Extension extension : xtendResource.getExtensions()) {
			migrateExtension(extension, ctx);
		}
		modeltypeImports.injectImports();
		return output;
	}

	private void addLibraryImports(XtendResource xtendResource, boolean reexportedOnly) throws MigrationException {
		for (String extension : xtendResource.getImportedExtensions()) {
			if (!reexportedOnly || xtendResource.isReexported(extension)) {
				writeln("import " + extension.replaceAll("::", ".") + ";");
				XtendResource referencedResource = resourceManager.loadXtendResource(extension);
	            if (referencedResource == null) {
	            	throw new MigrationException(Type.RESOURCE_NOT_FOUND, "Unable to load extension file: " + extension);
				}
	            addLibraryImports(referencedResource, true);
			}
		}
	}

	private void migrateExtension(Extension extension, ExecutionContext ctx) throws MigrationException {
		try {
			extension.init(ctx);
		} catch (EvaluationException e) {
			throw new MigrationException(Type.ANALYZATION_PROBLEMS, e);
		}

		write("helper ");
		write(extension.getName());
		write("(");

		assert extension.getParameterTypes().size() > 0;
		assert extension.getParameterNames().size() == extension.getParameterTypes().size();
		Iterator<String> parameterNames = extension.getParameterNames().iterator();
		Iterator<EClassifier> parameterTypes = extension.getParameterTypes().iterator();
		while (parameterNames.hasNext()) {
			write(parameterNames.next());
			write(" : ");
			write(getQvtFQName(parameterTypes.next()));
			if (parameterNames.hasNext()) {
				write(", ");
			}
		}
		write(") : ");
		// TODO: check it!
		write(getQvtFQName(getReturnType(extension, ctx)));
		writeln(" {");

		if (extension instanceof ExpressionExtensionStatement) {
			migrateExpressionExtension((ExpressionExtensionStatement) extension);
		} else if (extension instanceof JavaExtensionStatement) {
			migrateJavaExtension((JavaExtensionStatement) extension);
		} else if (extension instanceof CreateExtensionStatement) {
			migrateCreateExtension((CreateExtensionStatement) extension);
		} else if (extension instanceof WorkflowSlotExtensionStatement) {
			migrateWorkflowSlotExtension((WorkflowSlotExtensionStatement) extension);
		} else {
			throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
		}
		writeln("}");
	}

	private EClassifier getReturnType(Extension extension, ExecutionContext ctx) throws MigrationException {
		Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
		EClassifier returnType = extension.getReturnType(extension.getParameterTypes().toArray(new EClassifier[extension.getParameterNames().size()]), ctx, issues);
		if (issues.size() > 0) {
			throw new MigrationException(issues);
		}
		if (returnType == null) {
			throw new MigrationException(Type.EXTENSION_RETURN_TYPE_NOT_FOUND, extension.getReturnTypeIdentifier().getValue());
		}
		return returnType;
	}

	private String getQvtFQName(EClassifier classifier) throws MigrationException {
		if (classifier instanceof EDataType) {
			/**
			 * Handling QVT primitive types here.
			 */
			if (EcorePackage.eINSTANCE.getEString() == classifier) {
				return PrimitiveType.STRING_NAME;
			} else if (EcorePackage.eINSTANCE.getEBoolean() == classifier) {
				return PrimitiveType.BOOLEAN_NAME;
			} else if (EcorePackage.eINSTANCE.getEInt() == classifier) {
				return PrimitiveType.INTEGER_NAME;
			}
		}

		EPackage ePackage = classifier.getEPackage();
		assert ePackage != null;
		String alias = modeltypeImports.getModeltypeAlias(ePackage);
		return alias + OCL_PATH_SEPARATOR + classifier.getName();
	}

	private void migrateExpressionExtension(ExpressionExtensionStatement extension) throws MigrationException {
		write("return ");
		migrateExpression(extension.getExpression());
		write(" ");
	}

	// TODO: java should be migrated separately from library - java class should
	// be created with the additional declaration in plugin.xml
	private void migrateJavaExtension(JavaExtensionStatement extension) throws MigrationException {
		throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
	}

	private void migrateCreateExtension(CreateExtensionStatement extension) throws MigrationException {
		throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
	}

	private void migrateWorkflowSlotExtension(WorkflowSlotExtensionStatement extension) throws MigrationException {
		throw new MigrationException(Type.UNSUPPORTED_EXTENSION, extension.getClass().getName());
	}
	
	private void migrateExpression(Expression expression) throws MigrationException {
		if (expression instanceof BooleanOperation) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof Cast) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof ChainExpression) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof ConstructorCallExpression) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof CollectionExpression) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof OperationCall) {
			migrateOperationCall((OperationCall) expression);
		} else if (expression instanceof TypeSelectExpression) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof FeatureCall) {
			migrateFeatureCall((FeatureCall) expression);
		} else if (expression instanceof IfExpression) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof LetExpression) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof ListLiteral) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof BooleanLiteral) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof IntegerLiteral) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof NullLiteral) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof RealLiteral) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof StringLiteral) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else if (expression instanceof SwitchExpression) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		} else {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
		}
	}

	private void migrateOperationCall(OperationCall operationCall) throws MigrationException {
		migrateFeatureCall(operationCall);
		write("(");
		for (int i = 0; i < operationCall.getParams().length; i++) {
			if (i > 0) {
				write(", ");
			}
			migrateExpression(operationCall.getParams()[i]);
		}
		write(")");
	}

	private void migrateFeatureCall(FeatureCall featureCall) throws MigrationException {
		if (featureCall.getTarget() != null) {
			migrateExpression(featureCall.getTarget());
			write(".");
		}
		write(featureCall.getName().getValue());
	}

	private static String getLastSegment(String string, String separator) {
		int delimeterIndex = string.lastIndexOf(separator);
		if (delimeterIndex > 0) {
			return string.substring(delimeterIndex + separator.length());
		} else {
			return string;
		}
	}

	private void write(String word) {
		output.append(word);
	}

	private void writeln(String line) {
		output.append(line);
		output.append(LF);
	}

}
@


1.1.2.2
log
@Supporting:
- CollectionExpression
- FeatureCall
- OperationCall
- TypeSelect
@
text
@a16 1
import java.util.Stack;
a19 1
import org.eclipse.emf.ecore.EEnumLiteral;
a21 1
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
d70 1
a70 5

	private ExecutionContext rootExecutionContext;

	private Stack<Expression> expressionsStack = new Stack<Expression>();

a75 5
	public MigrationFacade(ResourceManager resourceManager, String xtendResourceName, ExecutionContext executionContext) {
		this(resourceManager, xtendResourceName);
		rootExecutionContext = executionContext;
	}

d86 2
a87 1
		ExecutionContext ctx = (rootExecutionContext != null ? rootExecutionContext : new ExecutionContextImpl(resourceManager)).cloneWithResource(xtendResource);
d104 1
a104 1

d121 2
a122 2
				if (referencedResource == null) {
					throw new MigrationException(Type.RESOURCE_NOT_FOUND, "Unable to load extension file: " + extension);
d124 1
a124 1
				addLibraryImports(referencedResource, true);
d158 1
a158 1
			migrateExpressionExtension((ExpressionExtensionStatement) extension, ctx);
d178 1
a178 1
			throw new MigrationException(Type.TYPE_NOT_FOUND, extension.getReturnTypeIdentifier().getValue());
d196 1
a196 12
		if (BuiltinMetaModel.isCollectionType(classifier)) {
			StringBuilder sb = new StringBuilder();
			if (classifier.getName().endsWith(BuiltinMetaModel.SET)) {
				sb.append("Set(");
			} else if (classifier.getName().endsWith(BuiltinMetaModel.LIST)) {
				sb.append("Sequence(");
			} else {
				sb.append("Collection(");
			}
			sb.append(getQvtFQName(BuiltinMetaModel.getInnerType(classifier)));
			return sb.append(")").toString();
		}
d203 1
a203 1
	private void migrateExpressionExtension(ExpressionExtensionStatement extension, ExecutionContext ctx) throws MigrationException {
d205 1
a205 1
		migrateExpression(extension.getExpression(), ctx);
d222 38
a259 43

	private void migrateExpression(Expression expression, ExecutionContext ctx) throws MigrationException {
		expressionsStack.push(expression);
		try {
			if (expression instanceof BooleanOperation) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof Cast) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof ChainExpression) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof ConstructorCallExpression) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof CollectionExpression) {
				migrateCollectionExpression((CollectionExpression) expression, ctx);
			} else if (expression instanceof OperationCall) {
				migrateOperationCall((OperationCall) expression, ctx);
			} else if (expression instanceof TypeSelectExpression) {
				migrateTypeSelectExpression((TypeSelectExpression) expression, ctx);
			} else if (expression instanceof FeatureCall) {
				migrateFeatureCall((FeatureCall) expression, ctx);
			} else if (expression instanceof IfExpression) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof LetExpression) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof ListLiteral) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof BooleanLiteral) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof IntegerLiteral) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof NullLiteral) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof RealLiteral) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof StringLiteral) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else if (expression instanceof SwitchExpression) {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			} else {
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, expression.getClass().getName());
			}
		} finally {
			expressionsStack.pop();
d263 2
a264 40
	private void migrateTypeSelectExpression(TypeSelectExpression typeSelectExpression, ExecutionContext ctx) throws MigrationException {
		migrateExpression(typeSelectExpression.getTarget(), ctx);
		EClassifier type = ctx.getTypeForName(typeSelectExpression.getTypeLiteral().getValue());
		if (type == null) {
			throw new MigrationException(Type.TYPE_NOT_FOUND, typeSelectExpression.getTypeLiteral().getValue());
		}
		write("->select(element | element.oclIsKindOf(");
		write(getQvtFQName(type));
		write("))->collect(element | element.oclAsType(");
		write(getQvtFQName(type));
		write("))");
	}

	private void migrateCollectionExpression(CollectionExpression collectionExpression, ExecutionContext ctx) throws MigrationException {
		if (collectionExpression.getTarget() == null) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, "Collection expression without target specified: " + collectionExpression.toString());
		}
		int placeHolder = getCurrentPosition();
		boolean hasNegation = false;
		migrateExpression(collectionExpression.getTarget(), ctx);
		write("->");
		// TODO: replace all these if() with single one +
		// write(collectionExpression.getName().getValue())?
		if (collectionExpression.getName().getValue().equals(SyntaxConstants.COLLECT)) {
			write("collect");
		} else if (collectionExpression.getName().getValue().equals(SyntaxConstants.SELECT)) {
			write("select");
		} else if (collectionExpression.getName().getValue().equals(SyntaxConstants.REJECT)) {
			write("reject");
		} else if (collectionExpression.getName().getValue().equals(SyntaxConstants.EXISTS)) {
			write("exists");
		} else if (collectionExpression.getName().getValue().equals(SyntaxConstants.NOT_EXISTS)) {
			hasNegation = true;
			write("not ", placeHolder);
			write("exists");
		} else if (collectionExpression.getName().getValue().equals(SyntaxConstants.FOR_ALL)) {
			write("forAll");
		} else {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, collectionExpression.getName().getValue());
		}
a265 43
		write(collectionExpression.getElementName());
		write(" | ");
		migrateExpression(collectionExpression.getClosure(), ctx);
		write(")");
		if (hasNegation) {
			addBraces(placeHolder);
		}
	}

	private void addBraces(int placeHolder) {
		if (expressionsStack.size() == 1) {
			return;
		}
		// TODO: check for the type of parent expression here + add braces
		// conditionaly
		// Expression parentExpression =
		// expressionsStack.get(expressionsStack.size() - 2);
		// check for the type of parent expression;
		write("(", placeHolder);
		write(")");
	}

	private void migrateOperationCall(OperationCall operationCall, ExecutionContext ctx) throws MigrationException {
		// TODO: if (target == null) then it can be a call to self.<operation>
		// in this case operation call call should be processed
		// specially (respecting self multiplicity).
		int placeholder = getCurrentPosition();
		if (operationCall.getTarget() != null) {
			// TODO: support different multiplicity of target - different
			// collections have to be created here. (->asList()..)
			migrateExpression(operationCall.getTarget(), ctx);
		}

		if (isInfixOperation(operationCall)) {
			insertInfixOperationCall(operationCall, placeholder);
		} else {
			if (operationCall.getTarget() != null) {
				write(".");
			}
			write(getQVTOperationName(operationCall));
			write("(");
		}

d270 1
a270 1
			migrateExpression(operationCall.getParams()[i], ctx);
d272 1
a272 17
		if (!isInfixOperation(operationCall)) {
			write(")");
		} else if (needsSurroundingBraces(operationCall)) {
			// Currently supported infix operations has 0 or 1 parameter
			// Enclosing with braces for "not" expression here
			addBraces(placeholder);
		}
	}

	private String getQVTOperationName(OperationCall operationCall) {
		String operationName = operationCall.getName().getValue();
		// TODO: In addition check target type (should be one of primitive
		// types) here
		if ("toFirstUpper".equals(operationName)) {
			return "firstToUpper";
		}
		return operationName;
d275 1
a275 34
	private boolean needsSurroundingBraces(OperationCall operationCall) {
		return "!".equals(operationCall.getName().getValue());
	}

	private void insertInfixOperationCall(OperationCall operationCall, int placeholder) throws MigrationException {
		// TODO: add other infix operations to this list
		if ("!".equals(operationCall.getName().getValue())) {
			write("not ", placeholder);
		} else {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, "Incorrect infix operation: " + operationCall.getName().getValue());
		}
	}

	private boolean isInfixOperation(OperationCall operationCall) {
		// TODO: add other infix operations to this list
		return "!".equals(operationCall.getName().getValue());
	}

	private void migrateFeatureCall(FeatureCall featureCall, ExecutionContext ctx) throws MigrationException {
		if (featureCall.getTarget() == null) {
			EEnumLiteral enumLiteral = featureCall.getEnumLiteral(ctx);
			if (enumLiteral != null) {
				String modelType = modeltypeImports.getModeltypeAlias(enumLiteral.getEEnum().getEPackage());
				write(modelType);
				write("::");
				write(enumLiteral.getEEnum().getName());
				write("::");
				write(enumLiteral.getName());
				return;
			}
			// TODO: It could be a call to environment variable or
			// self.<feature> in case of "self" this call should be processed
			// specially (respecting self multiplicity).
		}
d277 1
a277 3
			// TODO: support different multiplicity of target - different
			// collections have to be created here. (->asList()..)
			migrateExpression(featureCall.getTarget(), ctx);
a291 8
	private int getCurrentPosition() {
		return output.length();
	}

	private void write(String word, int index) {
		output.insert(index, word);
	}

@


1.1.2.3
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
@
text
@a77 2
	private int returnPosition;

a204 2
			} else if (EcorePackage.eINSTANCE.getEDouble() == classifier) {
				return PrimitiveType.REAL_NAME;
d226 1
a226 1
		markReturnPosition();
d228 1
a228 10
		injectReturn();
		writeln("");
	}

	private void injectReturn() {
		write("return ", returnPosition);
	}

	private void markReturnPosition() {
		returnPosition = getCurrentPosition();
d249 1
a249 1
				migrateBooleanOperation((BooleanOperation) expression, ctx);
d251 1
a251 1
				migrateCast((Cast) expression, ctx);
d253 1
a253 1
				migrateChainExpression((ChainExpression) expression, ctx);
d255 1
a255 1
				migrateConstructorCallExpression((ConstructorCallExpression) expression, ctx);
d265 1
a265 1
				migrateIfExpression((IfExpression) expression, ctx);
d267 1
a267 1
				migrateLetExpression((LetExpression) expression, ctx);
d269 1
a269 1
				migrateListLiteral((ListLiteral) expression, ctx);
d271 1
a271 1
				migrateBooleanLiteral((BooleanLiteral) expression, ctx);
d273 1
a273 1
				migrateIntegerLiteral((IntegerLiteral) expression, ctx);
d275 1
a275 1
				migrateNullLiteral((NullLiteral) expression, ctx);
d277 1
a277 1
				migrateRealLiteral((RealLiteral) expression, ctx);
d279 1
a279 1
				migrateStringLiteral((StringLiteral) expression, ctx);
a289 105
	private void migrateStringLiteral(StringLiteral expression, ExecutionContext ctx) {
		write("\"");
		write(expression.getValue());
		write("\"");
	}

	private void migrateRealLiteral(RealLiteral realLiteral, ExecutionContext ctx) {
		write(new Double(realLiteral.getLiteralValue()).toString());
	}

	private void migrateNullLiteral(NullLiteral expression, ExecutionContext ctx) {
		write("null");
	}

	private void migrateIntegerLiteral(IntegerLiteral integerLiteral, ExecutionContext ctx) {
		write(new Integer(integerLiteral.getLiteralValue()).toString());
	}

	private void migrateBooleanLiteral(BooleanLiteral booleanLiteral, ExecutionContext ctx) {
		write(Boolean.valueOf(booleanLiteral.getLiteralValue()) ? Boolean.TRUE.toString() : Boolean.FALSE.toString());
	}

	private void migrateListLiteral(ListLiteral listLiteral, ExecutionContext ctx) throws MigrationException {
		write("Sequence { ");
		for (int i = 0; i < listLiteral.getElements().length; i++) {
			if (i > 0) {
				write(", ");
			}
			migrateExpression(listLiteral.getElements()[i], ctx);
		}
		write(" }");
	}

	private void migrateLetExpression(LetExpression letExpression, ExecutionContext ctx) throws MigrationException {
		write("let ");
		write(letExpression.getVarName().getValue());
		write(" = ");
		migrateExpression(letExpression.getVarExpression(), ctx);
		write(" in ");
		migrateExpression(letExpression.getTargetExpression(), ctx);
	}

	private void migrateIfExpression(IfExpression ifExpression, ExecutionContext ctx) throws MigrationException {
		write("if ");
		migrateExpression(ifExpression.getCondition(), ctx);
		write(" then ");
		migrateExpression(ifExpression.getThenPart(), ctx);
		write(" else ");
		migrateExpression(ifExpression.getElsePart(), ctx);
		write(" endif");
	}

	private void migrateConstructorCallExpression(ConstructorCallExpression constructorCall, ExecutionContext ctx) throws MigrationException {
		write("object ");
		EClassifier type = ctx.getTypeForName(constructorCall.getType().getValue());
		if (type == null) {
			throw new MigrationException(Type.TYPE_NOT_FOUND, constructorCall.getType().getValue());
		}

		write(getQvtFQName(type));
		write(" {}");
	}

	private void migrateChainExpression(ChainExpression chainExpression, ExecutionContext ctx) throws MigrationException {
		// TODO: currently only top-level chain expressions are supported. We
		// have to develop a way to support inner chain expressions like:
		// if(a.b()->c.d()->e.f) then {...} else {...}
		// for now solution is to use separate helpers for each nested chain
		// expression
		if (expressionsStack.size() > 1 && false == expressionsStack.peek() instanceof ChainExpression) {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, "Inner " + chainExpression.getClass().getName());
		}
		migrateExpression(chainExpression.getFirst(), ctx);
		writeln(";");
		if (expressionsStack.size() == 1) {
			markReturnPosition();
		}
		migrateExpression(chainExpression.getNext(), ctx);
	}

	private void migrateBooleanOperation(BooleanOperation booleanOperation, ExecutionContext ctx) throws MigrationException {
		migrateExpression(booleanOperation.getLeft(), ctx);
		if (booleanOperation.isAndOperation()) {
			write(" and ");
		} else if (booleanOperation.isOrOperation()) {
			write(" or ");
		} else if (booleanOperation.isImpliesOperation()) {
			write(" implies ");
		} else {
			throw new MigrationException(Type.UNSUPPORTED_BOOLEAN_OPERATION, booleanOperation.getOperator());
		}
		migrateExpression(booleanOperation.getRight(), ctx);
	}

	private void migrateCast(Cast cast, ExecutionContext ctx) throws MigrationException {
		migrateExpression(cast.getTarget(), ctx);
		EClassifier type = ctx.getTypeForName(cast.getType().getValue());
		if (type == null) {
			throw new MigrationException(Type.TYPE_NOT_FOUND, cast.getType().getValue());
		}
		write(".oclAsType(");
		write(getQvtFQName(type));
		write(")");
	}

d307 1
a307 1
		int placeholder = getCurrentPosition();
d323 1
a323 1
			write("not ", placeholder);
d336 1
a336 1
			addBraces(placeholder);
d340 1
a340 1
	private void addBraces(int placeholder) {
d349 1
a349 1
		write("(", placeholder);
d405 1
a405 2
		String opName = operationCall.getName().getValue();
		if ("!".equals(opName)) {
a406 8
		} else if ("-".equals(opName)) {
			if (operationCall.getParams().length == 0) {
				write("-", placeholder);
			} else if (operationCall.getParams().length == 1) {
				write(" - ");
			} else {
				throw new MigrationException(Type.UNSUPPORTED_INFIX_OPERATION_PARAMETER, "\"" + opName + "\" only 0 or 1 parameters supported, passed: " + operationCall.getParams().length);
			}
d408 1
a408 1
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, "Incorrect infix operation: " + opName);
d414 1
a414 2
		String opName = operationCall.getName().getValue();
		return "!".equals(opName) || "-".equals(opName);
@


1.1.2.4
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
@
text
@a32 1
import org.eclipse.gmf.internal.xpand.expression.ast.Case;
d294 1
a294 1
				migrateSwitchExpression((SwitchExpression) expression, ctx);
a302 17
	private void migrateSwitchExpression(SwitchExpression switchExpression, ExecutionContext ctx) throws MigrationException {
		writeln("switch { ");
		for (Case caseExpression : switchExpression.getCases()) {
			write("(");
			migrateExpression(switchExpression.getSwitchExpr(), ctx);
			write(" = ");
			migrateExpression(caseExpression.getCondition(), ctx);
			write(") ? ");
			migrateExpression(caseExpression.getThenPart(), ctx);
			writeln(";");
		}
		write("else ? ");
		migrateExpression(switchExpression.getDefaultExpr(), ctx);
		writeln("");
		writeln(" }");
	}

d526 1
a526 1
		} else if ("-".equals(opName) || "+".equals(opName)) {
d528 1
a528 1
				write(opName, placeholder);
d530 1
a530 3
				write(" ");
				write(opName);
				write(" ");
d542 1
a542 1
		return "!".equals(opName) || "-".equals(opName) || "+".equals(opName);
@


1.1.2.5
log
@All .qvto files was validated with existing QVT implementation.
@
text
@d305 8
a312 15
		if (switchExpression.getCases().size() == 0) {
			migrateExpression(switchExpression.getDefaultExpr(), ctx);
		} else {
			writeln("switch { ");
			for (Case caseExpression : switchExpression.getCases()) {
				write("case (");
				migrateExpression(switchExpression.getSwitchExpr(), ctx);
				write(" = ");
				migrateExpression(caseExpression.getCondition(), ctx);
				write(") ");
				migrateExpression(caseExpression.getThenPart(), ctx);
				writeln(";");
			}
			write("else ");
			migrateExpression(switchExpression.getDefaultExpr(), ctx);
a313 1
			writeln(" }");
d315 4
d322 1
a322 1
		write("'");
d324 1
a324 1
		write("'");
@


1.1.2.6
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Unit-tests for migration escaped was strings added
@
text
@d123 1
a123 2
		for (Iterator<Extension> it = xtendResource.getExtensions().iterator(); it.hasNext();) {
			Extension extension = it.next();
a124 3
			if (it.hasNext()) {
				writeln("");
			}
a230 1
		write("\t");
d327 1
a327 1
		write(excape(expression.getValue()));
a330 13
	private String excape(String value) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < value.length(); i++) {
			char nextChar = value.charAt(i);
			if (nextChar == '\'') {
				// escaping single quote mark with one more single quote mark.
				sb.append(nextChar);
			}
			sb.append(nextChar);
		}
		return sb.toString();
	}

@


1.1.2.7
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Correctly transforming collection types on implicit collect operations for FeatureCall expression + unit-tests.
@
text
@a22 1
import org.eclipse.emf.ecore.EStructuralFeature;
d28 2
d75 1
a75 1
	private MigrationExecutionContext rootExecutionContext;
a80 8
	private static final boolean isListType(EClassifier classifier) {
		return classifier.getName().endsWith(BuiltinMetaModel.LIST);
	}

	private static final boolean isSetType(EClassifier classifier) {
		return classifier.getName().endsWith(BuiltinMetaModel.SET);
	}

d86 1
a86 1
	public MigrationFacade(ResourceManager resourceManager, String xtendResourceName, MigrationExecutionContext executionContext) {
d101 1
a101 1
		MigrationExecutionContext ctx = (rootExecutionContext != null ? rootExecutionContext : new MigrationExecutionContextImpl(resourceManager)).cloneWithResource(xtendResource);
d147 1
a147 1
	private void migrateExtension(Extension extension, MigrationExecutionContext ctx) throws MigrationException {
d189 1
a189 1
	private EClassifier getReturnType(Extension extension, MigrationExecutionContext ctx) throws MigrationException {
d218 1
a218 1
			if (isSetType(classifier)) {
d220 1
a220 1
			} else if (isListType(classifier)) {
d234 1
a234 1
	private void migrateExpressionExtension(ExpressionExtensionStatement extension, MigrationExecutionContext ctx) throws MigrationException {
d264 1
a264 1
	private void migrateExpression(Expression expression, MigrationExecutionContext ctx) throws MigrationException {
d309 1
a309 1
	private void migrateSwitchExpression(SwitchExpression switchExpression, MigrationExecutionContext ctx) throws MigrationException {
d330 1
a330 1
	private void migrateStringLiteral(StringLiteral expression, MigrationExecutionContext ctx) {
d349 1
a349 1
	private void migrateRealLiteral(RealLiteral realLiteral, MigrationExecutionContext ctx) {
d353 1
a353 1
	private void migrateNullLiteral(NullLiteral expression, MigrationExecutionContext ctx) {
d357 1
a357 1
	private void migrateIntegerLiteral(IntegerLiteral integerLiteral, MigrationExecutionContext ctx) {
d361 1
a361 1
	private void migrateBooleanLiteral(BooleanLiteral booleanLiteral, MigrationExecutionContext ctx) {
d365 1
a365 1
	private void migrateListLiteral(ListLiteral listLiteral, MigrationExecutionContext ctx) throws MigrationException {
d376 1
a376 1
	private void migrateLetExpression(LetExpression letExpression, MigrationExecutionContext ctx) throws MigrationException {
d385 1
a385 1
	private void migrateIfExpression(IfExpression ifExpression, MigrationExecutionContext ctx) throws MigrationException {
d395 1
a395 1
	private void migrateConstructorCallExpression(ConstructorCallExpression constructorCall, MigrationExecutionContext ctx) throws MigrationException {
d406 1
a406 1
	private void migrateChainExpression(ChainExpression chainExpression, MigrationExecutionContext ctx) throws MigrationException {
d423 1
a423 1
	private void migrateBooleanOperation(BooleanOperation booleanOperation, MigrationExecutionContext ctx) throws MigrationException {
d437 1
a437 1
	private void migrateCast(Cast cast, MigrationExecutionContext ctx) throws MigrationException {
d448 1
a448 1
	private void migrateTypeSelectExpression(TypeSelectExpression typeSelectExpression, MigrationExecutionContext ctx) throws MigrationException {
d461 1
a461 1
	private void migrateCollectionExpression(CollectionExpression collectionExpression, MigrationExecutionContext ctx) throws MigrationException {
d511 1
a511 1
	private void migrateOperationCall(OperationCall operationCall, MigrationExecutionContext ctx) throws MigrationException {
d587 15
a601 23
	private void migrateFeatureCall(FeatureCall featureCall, MigrationExecutionContext ctx) throws MigrationException {
		ExpressionAnalyzeTrace expressionTrace = ctx.getTraces().get(featureCall);
		if (false == expressionTrace instanceof FeatureCallTrace) {
			throw new MigrationException(Type.UNSUPPORTED_FEATURE_CALL_TRACE, String.valueOf(expressionTrace));
		}
		FeatureCallTrace trace = (FeatureCallTrace) expressionTrace;
		switch (trace.getType()) {
		case ENUM_LITERAL_REF:
			EEnumLiteral enumLiteral = trace.getEnumLiteral();
			assert enumLiteral != null;
			String modelType = modeltypeImports.getModeltypeAlias(enumLiteral.getEEnum().getEPackage());
			write(modelType);
			write("::");
			write(enumLiteral.getEEnum().getName());
			write("::");
			write(enumLiteral.getName());
			return;
		case ENV_VAR_REF:
			write(featureCall.getName().getValue());
			return;
		case UNDESOLVED_TARGET_TYPE:
		case UNSUPPORTED_CLASSIFIER_REF:
			throw new MigrationException(Type.UNSUPPORTED_FEATURE_CALL, trace.toString());
a602 1
		// featureCall.getTarget() == null for FeatureCall of implicit variable feature
d604 2
a609 25
		switch (trace.getType()) {
		case FEATURE_REF:
			EStructuralFeature feature = trace.getFeature();
			assert feature != null;
			EClassifier targetType = trace.getTargetType();
			assert targetType != null;
			if (BuiltinMetaModel.isParameterizedType(targetType)) {
				// TODO: check once more..
				// TODO: new type of exception - NotSupportedXPandConstruction exception.
				throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, "Attribute call is not supported for the collection types: " + targetType.toString() + "." + featureCall.getName().getValue());
			}
			if (feature.isMany() && feature.isOrdered() && feature.isUnique()) {
				write("->asSequence()");
			}
			return;
		case IMPLICIT_COLLECT_FEATURE_REF:
			EClassifier targetCollectionType = trace.getTargetType();
			assert targetCollectionType != null;
			if (!isListType(targetCollectionType)) {
				write("->asSequence()");
			}
			return;
		default:
			throw new MigrationException(Type.UNSUPPORTED_FEATURE_CALL_TRACE, "Incorrect type: " + trace.getType());
		}
@


1.1.2.8
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Correctly transforming collection types on implicit collect operations for OperationCall expression + unit-tests.
@
text
@a13 1
import java.util.Collections;
d23 1
a23 1
import org.eclipse.emf.ecore.ETypedElement;
d519 8
a526 3
		ExpressionAnalyzeTrace expressionTrace = ctx.getTraces().get(operationCall);
		if (false == expressionTrace instanceof OperationCallTrace) {
			throw new MigrationException(Type.UNSUPPORTED_OPERATION_CALL_TRACE, String.valueOf(expressionTrace));
d528 4
a531 38
		OperationCallTrace trace = (OperationCallTrace) expressionTrace;
		switch (trace.getType()) {
		case UNDESOLVED_PARAMETER_TYPE:
		case UNDESOLVED_TARGET_TYPE:
			throw new MigrationException(Type.UNSUPPORTED_OPERATION_CALL, trace.toString());
		case STATIC_EXTENSION_REF:
			write(operationCall.getName().getValue());
			write("(");
			migrateOperationCallParameters(operationCall, ctx);
			write(")");
			return;
		case OPERATION_REF:
			int placeholder = getCurrentPosition();
			// getTarget() == null if it is an implicit self operation.
			if (operationCall.getTarget() != null) {
				migrateExpression(operationCall.getTarget(), ctx);
			}
			if (isInfixOperation(operationCall)) {
				insertInfixOperationCall(operationCall, placeholder);
			} else {
				if (operationCall.getTarget() != null) {
					write(isCollectionOperation(operationCall) ? "->" : ".");
				}
				write(getQVTOperationName(operationCall));
				write("(");
			}
			migrateOperationCallParameters(operationCall, ctx);
			if (!isInfixOperation(operationCall)) {
				write(")");
			} else if (needsSurroundingBraces(operationCall)) {
				// Currently supported infix operations has 0 or 1 parameter
				// Enclosing with braces for "not" expression here
				addBraces(placeholder);
			}
			convertTypedElementCallProduct(trace.getEOperation());
			return;
		case IMPLICIT_COLLECT_OPERATION_REF:
			// getTarget() == null if it is an implicit self operation.
a532 1
				migrateExpression(operationCall.getTarget(), ctx);
a536 34
			migrateOperationCallParameters(operationCall, ctx);
			write(")");
			convertImplicitCollectProduct(trace.getTargetType());
			return;
		case EXTENSION_REF:
			assert operationCall.getTarget() != null;
			write(operationCall.getName().getValue());
			write("(");
			migrateExpression(operationCall.getTarget(), ctx);
			if (operationCall.getParams().length > 0) {
				write(", ");
				migrateOperationCallParameters(operationCall, ctx);
			}
			write(")");
			return;
		case IMPLICIT_COLLECT_EXTENSION_REF:
			assert operationCall.getTarget() != null;
			migrateExpression(operationCall.getTarget(), ctx);
			String iteratorName = getIteratorVarName(operationCall);
			write("->collect(");
			write(iteratorName);
			write(" | ");
			write(operationCall.getName().getValue());
			write("(");
			write(iteratorName);
			if (operationCall.getParams().length > 0) {
				write(", ");
				migrateOperationCallParameters(operationCall, ctx);
			}
			write(")");
			write(")");
			convertImplicitCollectProduct(trace.getTargetType());
			return;
		default:
a537 97
	}
	
	private boolean isCollectionOperation(OperationCall operationCall) {
		String operationName = operationCall.getName().getValue();
		return "toList".equals(operationName) || "first".equals(operationName);
	}

	private String getIteratorVarName(Expression expression) {
		Set<String> definedVariables = getDefinedVariables(expression);
		String prefix = "it";
		String varName = prefix;
		for (int i = 1; definedVariables.contains(varName); i++) {
			varName = prefix + "_" + i;
		}
		return varName;
	}

	private Set<String> getDefinedVariables(Expression expression) {
		Set<String> result = new HashSet<String>();
		if (expression instanceof BooleanOperation) {
			BooleanOperation booleanOperation = (BooleanOperation) expression;
			result.addAll(getDefinedVariables(booleanOperation.getLeft()));
			result.addAll(getDefinedVariables(booleanOperation.getRight()));
		} else if (expression instanceof Cast) {
			Cast cast = (Cast) expression;
			result.addAll(getDefinedVariables(cast.getTarget()));
		} else if (expression instanceof ChainExpression) {
			ChainExpression chainExpression = (ChainExpression) expression;
			result.addAll(getDefinedVariables(chainExpression.getFirst()));
			result.addAll(getDefinedVariables(chainExpression.getNext()));
		} else if (expression instanceof CollectionExpression) {
			CollectionExpression collectionExpression = (CollectionExpression) expression;
			result.addAll(getDefinedVariables(collectionExpression.getClosure()));
			result.addAll(getDefinedVariablesOfTarget(collectionExpression));
			result.add(collectionExpression.getElementName());
		} else if (expression instanceof OperationCall) {
			OperationCall operationCall = (OperationCall) expression;
			result.addAll(getDefinedVariablesOfTarget(operationCall));
			for (int i = 0; i < operationCall.getParams().length; i++) {
				result.addAll(getDefinedVariables(operationCall.getParams()[i]));
			}
		} else if (expression instanceof TypeSelectExpression) {
			TypeSelectExpression typeSelect = (TypeSelectExpression) expression;
			result.addAll(getDefinedVariablesOfTarget(typeSelect));
		} else if (expression instanceof FeatureCall) {
			FeatureCall featureCall = (FeatureCall) expression;
			result.addAll(getDefinedVariablesOfTarget(featureCall));
			if (featureCall.getTarget() == null) {
				result.add(featureCall.getName().getValue());
			}
		} else if (expression instanceof IfExpression) {
			IfExpression ifExpression = (IfExpression) expression;
			result.addAll(getDefinedVariables(ifExpression.getCondition()));
			result.addAll(getDefinedVariables(ifExpression.getThenPart()));
			result.addAll(getDefinedVariables(ifExpression.getElsePart()));
		} else if (expression instanceof LetExpression) {
			LetExpression letExpression = (LetExpression) expression;
			result.addAll(getDefinedVariables(letExpression.getVarExpression()));
			result.addAll(getDefinedVariables(letExpression.getTargetExpression()));
			result.add(letExpression.getVarName().getValue());
		} else if (expression instanceof ListLiteral) {
			ListLiteral listLiteral = (ListLiteral) expression;
			for (int i = 0; i < listLiteral.getElements().length; i++) {
				result.addAll(getDefinedVariables(listLiteral.getElements()[i]));
			}
		} else if (expression instanceof SwitchExpression) {
			SwitchExpression switchExpression = (SwitchExpression) expression;
			result.addAll(getDefinedVariables(switchExpression.getSwitchExpr()));
			result.addAll(getDefinedVariables(switchExpression.getDefaultExpr()));
			for (Case caseExpresion : switchExpression.getCases()) {
				result.addAll(getDefinedVariables(caseExpresion.getCondition()));
				result.addAll(getDefinedVariables(caseExpresion.getThenPart()));
			}
		}
		return result;
	}

	private Set<String> getDefinedVariablesOfTarget(FeatureCall featrueCall) {
		if (featrueCall.getTarget() != null) {
			return getDefinedVariables(featrueCall.getTarget());
		}
		return Collections.emptySet();
	}

	private void convertTypedElementCallProduct(ETypedElement typedElement) {
		assert typedElement != null;
		if (typedElement.isMany() && typedElement.isOrdered() && typedElement.isUnique()) {
			write("->asSequence()");
		}
	}

	private void convertImplicitCollectProduct(EClassifier targetType) {
		assert targetType != null;
		if (!isListType(targetType)) {
			write("->asSequence()");
		}
	}
a538 1
	private void migrateOperationCallParameters(OperationCall operationCall, MigrationExecutionContext ctx) throws MigrationException {
d545 7
a553 2
	// TODO: use OperationCallTrace as a parameter of this call + compare
	// associated operation with one from BMM using "=="
d556 2
a559 2
		} else if ("toList".equals(operationName)) {
			return "asSequence";
a563 2
	// TODO: use OperationCallTrace as a parameter of this call + compare
	// associated operation with one from BMM using "=="
a567 2
	// TODO: use OperationCallTrace as a parameter of this call + compare
	// associated operation with one from BMM using "=="
d618 1
a618 2
		// featureCall.getTarget() == null for FeatureCall of implicit variable
		// feature
d626 2
d631 2
d635 3
a637 1
			convertTypedElementCallProduct(trace.getFeature());
d640 5
a644 1
			convertImplicitCollectProduct(trace.getTargetType());
@


1.1.2.9
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Supporting inner implicit collect call for extensions.
@
text
@d586 1
a586 1
			String iteratorName = getUniqueVarName(getDefinedVariables(operationCall, ctx));
d604 1
a604 1

d610 2
a611 1
	private String getUniqueVarName(Set<String> definedVariables) {
d620 1
a620 13
	private Set<String> getDefinedVariablesForInnerExpression(Expression expression, MigrationExecutionContext ctx) {
		Set<String> definedVariables = getDefinedVariables(expression, ctx);
		ExpressionAnalyzeTrace expressionAnalyzeTrace = ctx.getTraces().get(expression);
		if (expressionAnalyzeTrace instanceof OperationCallTrace) {
			OperationCallTrace trace = (OperationCallTrace) expressionAnalyzeTrace;
			if (trace.getType() == OperationCallTrace.Type.IMPLICIT_COLLECT_EXTENSION_REF) {
				definedVariables.add(getUniqueVarName(definedVariables));
			}
		}
		return definedVariables;
	}

	private Set<String> getDefinedVariables(Expression expression, MigrationExecutionContext ctx) {
d624 2
a625 2
			result.addAll(getDefinedVariablesForInnerExpression(booleanOperation.getLeft(), ctx));
			result.addAll(getDefinedVariablesForInnerExpression(booleanOperation.getRight(), ctx));
d628 1
a628 1
			result.addAll(getDefinedVariablesForInnerExpression(cast.getTarget(), ctx));
d631 2
a632 2
			result.addAll(getDefinedVariablesForInnerExpression(chainExpression.getFirst(), ctx));
			result.addAll(getDefinedVariablesForInnerExpression(chainExpression.getNext(), ctx));
d635 2
a636 2
			result.addAll(getDefinedVariablesForInnerExpression(collectionExpression.getClosure(), ctx));
			result.addAll(getDefinedVariablesOfTarget(collectionExpression, ctx));
d640 1
a640 1
			result.addAll(getDefinedVariablesOfTarget(operationCall, ctx));
d642 1
a642 1
				result.addAll(getDefinedVariablesForInnerExpression(operationCall.getParams()[i], ctx));
d646 1
a646 1
			result.addAll(getDefinedVariablesOfTarget(typeSelect, ctx));
d649 1
a649 1
			result.addAll(getDefinedVariablesOfTarget(featureCall, ctx));
d655 3
a657 3
			result.addAll(getDefinedVariablesForInnerExpression(ifExpression.getCondition(), ctx));
			result.addAll(getDefinedVariablesForInnerExpression(ifExpression.getThenPart(), ctx));
			result.addAll(getDefinedVariablesForInnerExpression(ifExpression.getElsePart(), ctx));
d660 2
a661 2
			result.addAll(getDefinedVariablesForInnerExpression(letExpression.getVarExpression(), ctx));
			result.addAll(getDefinedVariablesForInnerExpression(letExpression.getTargetExpression(), ctx));
d666 1
a666 1
				result.addAll(getDefinedVariablesForInnerExpression(listLiteral.getElements()[i], ctx));
d670 2
a671 2
			result.addAll(getDefinedVariablesForInnerExpression(switchExpression.getSwitchExpr(), ctx));
			result.addAll(getDefinedVariablesForInnerExpression(switchExpression.getDefaultExpr(), ctx));
d673 2
a674 2
				result.addAll(getDefinedVariablesForInnerExpression(caseExpresion.getCondition(), ctx));
				result.addAll(getDefinedVariablesForInnerExpression(caseExpresion.getThenPart(), ctx));
d680 1
a680 1
	private Set<String> getDefinedVariablesOfTarget(FeatureCall featrueCall, MigrationExecutionContext ctx) {
d682 1
a682 1
			return getDefinedVariablesForInnerExpression(featrueCall.getTarget(), ctx);
@


1.1.2.10
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Supporting collection operation calls.
@
text
@a13 1
import java.util.Arrays;
a19 1
import org.eclipse.emf.ecore.EClass;
a22 1
import org.eclipse.emf.ecore.EOperation;
a57 1
import org.eclipse.ocl.types.AnyType;
a61 37
	
	private static final Set<EOperation> infixOperations = new HashSet<EOperation>(Arrays.asList(new EOperation[] {
			BuiltinMetaModel.Boolean_NE,
			BuiltinMetaModel.Int_Unary_Minus,
			BuiltinMetaModel.Double_Unary_Minus,
			BuiltinMetaModel.Int_Minus_Double, 
			BuiltinMetaModel.Int_Minus_Int, 
			BuiltinMetaModel.Double_Minus_Double, 
			BuiltinMetaModel.Double_Minus_Int,
			BuiltinMetaModel.Int_Plus_Double, 
			BuiltinMetaModel.Int_Plus_Int, 
			BuiltinMetaModel.Double_Plus_Double, 
			BuiltinMetaModel.Double_Plus_Int
		}));
	
	private static final Set<EOperation> collectionOperations = new HashSet<EOperation>(Arrays.asList(new EOperation[] {
			BuiltinMetaModel.Collection_Add,
			BuiltinMetaModel.Collection_AddAll,
			BuiltinMetaModel.Collection_Clear,
			BuiltinMetaModel.Collection_Contains,
			BuiltinMetaModel.Collection_ContainsAll, 
			BuiltinMetaModel.Collection_Flatten,
			BuiltinMetaModel.Collection_Intersect,
			BuiltinMetaModel.Collection_IsEmpty, 
			BuiltinMetaModel.Collection_Size, 
			BuiltinMetaModel.Collection_ToList,
			BuiltinMetaModel.Collection_ToSet,
			BuiltinMetaModel.Collection_Union,
			BuiltinMetaModel.Collection_Without,
			BuiltinMetaModel.List_First,
			BuiltinMetaModel.List_Get,
			BuiltinMetaModel.List_IndexOf,
			BuiltinMetaModel.List_Last,
			BuiltinMetaModel.List_PurgeDups,
			BuiltinMetaModel.List_WithoutFirst,
			BuiltinMetaModel.List_WithoutLast
	}));
d166 1
a166 1
//		assert extension.getParameterTypes().size() > 0;
a221 2
			} else if (EcorePackage.eINSTANCE.getEJavaObject() == classifier) {
				return AnyType.SINGLETON_NAME;
a232 1
			//was: if (classifier == CollectionTypesSupport.COLLECTION_OF_OBJECT || classifier == CollectionTypesSupport.LIST_OF_OBJECT || classifier == CollectionTypesSupport.SET_OF_OBJECT) {
d462 1
a462 1
		write("[");
d464 3
a466 1
		write("]");
d532 1
a532 1
			internalMigrateOperationCallParameters(operationCall, ctx);
d536 7
a542 4
			if (isInfixOperation(trace)) {
				internalMigrateInfixOperation(trace, operationCall, ctx);
			} else if (isCollectionOperation(trace)) {
				internalMigrateCollectionOperationCall(trace, operationCall, ctx);
d544 4
a547 3
				internalMigrateOperationCallTarget(operationCall, ctx);
				write(".");
				write(getQVTOperationName(trace));
d549 3
a551 1
				internalMigrateOperationCallParameters(operationCall, ctx);
d553 4
a556 1
				convertTypedElementCallProduct(trace.getEOperation());
d558 1
d561 6
a566 5
			internalMigrateOperationCallTarget(operationCall, ctx);
			write(".");
			// TODO: Implicit collect of collection operation result is not
			// supported now
			write(getQVTOperationName(trace));
d568 1
a568 1
			internalMigrateOperationCallParameters(operationCall, ctx);
d579 1
a579 1
				internalMigrateOperationCallParameters(operationCall, ctx);
d595 1
a595 1
				internalMigrateOperationCallParameters(operationCall, ctx);
a603 179
	
	private void internalMigrateInfixOperation(OperationCallTrace trace, OperationCall operationCall, MigrationExecutionContext ctx) throws MigrationException {
		EOperation eOperation = trace.getEOperation();
		assert eOperation != null;
		int placeholder = getCurrentPosition();
		internalMigrateOperationCallTarget(operationCall, ctx);
		// TODO: add other infix operations to this list
		String opName = eOperation.getName();
		if (BuiltinMetaModel.Boolean_NE == eOperation) {
			write("not ", placeholder);
		} else if (BuiltinMetaModel.Int_Unary_Minus == eOperation || BuiltinMetaModel.Double_Unary_Minus == eOperation) {
			write(opName, placeholder);
		} else if (BuiltinMetaModel.Int_Minus_Int == eOperation || BuiltinMetaModel.Int_Minus_Double == eOperation || BuiltinMetaModel.Double_Minus_Int == eOperation
				|| BuiltinMetaModel.Double_Minus_Double == eOperation || BuiltinMetaModel.Int_Plus_Int == eOperation || BuiltinMetaModel.Int_Plus_Double == eOperation
				|| BuiltinMetaModel.Double_Plus_Int == eOperation || BuiltinMetaModel.Double_Plus_Double == eOperation) {
			write(" ");
			write(opName);
			write(" ");
		} else {
			throw new MigrationException(Type.UNSUPPORTED_EXPRESSION, "Incorrect infix operation: " + opName);
		}
		internalMigrateOperationCallParameters(operationCall, ctx);
		if (BuiltinMetaModel.Boolean_NE == eOperation || BuiltinMetaModel.Int_Unary_Minus == eOperation || BuiltinMetaModel.Double_Unary_Minus == eOperation) {
			// Enclosing with braces for "not" expression here
			addBraces(placeholder);
		}
	}

	private void internalMigrateOperationCallTarget(OperationCall operationCall, MigrationExecutionContext ctx) throws MigrationException {
		if (operationCall.getTarget() != null) {
			migrateExpression(operationCall.getTarget(), ctx);
		} else {
			// getTarget() == null if it is an implicit self operation.
			// TODO: check if it is working with XPand
			write("self");
		}
	}

	private void internalMigrateCollectionOperationCall(OperationCallTrace trace, OperationCall operationCall, MigrationExecutionContext ctx) throws MigrationException {
		EOperation eOperation = trace.getEOperation();
		assert eOperation != null;
		EClassifier targetType = trace.getTargetType();
		assert targetType != null;
		
		if (BuiltinMetaModel.Collection_Clear != eOperation && BuiltinMetaModel.List_WithoutFirst != eOperation && BuiltinMetaModel.List_WithoutLast != eOperation) {
			internalMigrateOperationCallTarget(operationCall, ctx);
		}
		
		if (BuiltinMetaModel.Collection_Add == eOperation) {
			convertCollectionTypes(targetType, targetType, true);
			write("->including(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			write(")");
		} else if (BuiltinMetaModel.Collection_AddAll == eOperation) {
			convertCollectionTypes(targetType, targetType, true);
			write("->union");
			internalMigrateCollectionOperationCollectionParameter(trace, operationCall, targetType, ctx);
		} else if (BuiltinMetaModel.Collection_Clear == eOperation) {
			if (isSetType(targetType)) {
				write("Set{}");
			} else {
				write("Sequence{}");
			}
		} else if (BuiltinMetaModel.Collection_Flatten == eOperation) {
			convertCollectionTypes(targetType, targetType, true);
			write("->flatten()");
		} else if (BuiltinMetaModel.Collection_Union == eOperation) {
			EClass setType = BuiltinMetaModel.getSetType(EcorePackage.eINSTANCE.getEJavaObject());
			convertCollectionTypes(targetType, setType, true);
			write("->union");
			internalMigrateCollectionOperationCollectionParameter(trace, operationCall, setType, ctx);
		} else if (BuiltinMetaModel.Collection_Intersect == eOperation) {
			EClass setType = BuiltinMetaModel.getSetType(EcorePackage.eINSTANCE.getEJavaObject());
			convertCollectionTypes(targetType, setType, true);
			write("->intersection");
			internalMigrateCollectionOperationCollectionParameter(trace, operationCall, setType, ctx);
		} else if (BuiltinMetaModel.Collection_Without == eOperation) { 
			EClass setType = BuiltinMetaModel.getSetType(EcorePackage.eINSTANCE.getEJavaObject());
			convertCollectionTypes(targetType, setType, true);
			write("->-");
			internalMigrateCollectionOperationCollectionParameter(trace, operationCall, setType, ctx);
		} else if (BuiltinMetaModel.Collection_ToSet == eOperation) { 
			EClass setType = BuiltinMetaModel.getSetType(EcorePackage.eINSTANCE.getEJavaObject());
			convertCollectionTypes(targetType, setType, false);
		} else if (BuiltinMetaModel.Collection_ToList == eOperation) { 
			EClass listType = BuiltinMetaModel.getListType(EcorePackage.eINSTANCE.getEJavaObject());
			convertCollectionTypes(targetType, listType, false);
		} else if (BuiltinMetaModel.Collection_Contains == eOperation) { 
			write("[OclAny]");
			write("->includes(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			write(")");
		} else if (BuiltinMetaModel.Collection_ContainsAll == eOperation) { 
			write("[OclAny]");
			write("->includesAll(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			write(")");
		} else if (BuiltinMetaModel.List_Get == eOperation) { 
			write("->at(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			write(" + 1)");
		} else if (BuiltinMetaModel.List_WithoutFirst == eOperation) { 
			write("if ");
			internalMigrateOperationCallTarget(operationCall, ctx);
			write("->isEmpty() then Sequence{} else ");
			internalMigrateOperationCallTarget(operationCall, ctx);
			write("->subSequence(2, ");
			internalMigrateOperationCallTarget(operationCall, ctx);
			write("->size()) endif");
		} else if (BuiltinMetaModel.List_WithoutLast == eOperation) { 
			write("if ");
			internalMigrateOperationCallTarget(operationCall, ctx);
			write("->isEmpty() then Sequence{} else ");
			internalMigrateOperationCallTarget(operationCall, ctx);
			write("->subSequence(1, ");
			internalMigrateOperationCallTarget(operationCall, ctx);
			write("->size() - 1) endif");
		} else if (BuiltinMetaModel.List_PurgeDups == eOperation) { 
			write("->asOrderedSet()->asSequence()");
		} else if (BuiltinMetaModel.List_IndexOf == eOperation) {
			write("[OclAny]->indexOf(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			write(") - 1");
		} else {
			// TODO: remove this branch?
			write("->");
			write(eOperation.getName());
			write("(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			write(")");
		}
	}

	private void internalMigrateCollectionOperationCollectionParameter(OperationCallTrace trace, OperationCall operationCall, EClassifier targetType, MigrationExecutionContext ctx) throws MigrationException {
		EClassifier[] paramTypes = trace.getParamTypes();
		assert paramTypes != null && paramTypes.length == 1;
		assert operationCall.getParams().length == 1;
		write("(");
		migrateExpression(operationCall.getParams()[0], ctx);
		assert BuiltinMetaModel.isCollectionType(paramTypes[0]);
		convertCollectionTypes(paramTypes[0], targetType, false);
		write(")");
	}

	// TODO: make two separate methods from this one?
	private void convertCollectionTypes(EClassifier originalCollectionType, EClassifier targetType, boolean convertToAnyType) {
		if (isListType(originalCollectionType)) {
			if (convertToAnyType) {
				write("[OclAny]");
			}
			if (isSetType(targetType)) {
				write("->asSet()");
			} else if (!isListType(targetType)) {
				write("->asBag()");
			}
		} else if (isSetType(originalCollectionType)) {
			if (convertToAnyType) {
				write("[OclAny]");
			}
			if (isListType(targetType)) {
				write("->asSequence()");
			}
		} else {
			String iteratorName = "it";
			write("->collect(");
			write(iteratorName);
			write(" | ");
			write(iteratorName);
			if (convertToAnyType) {
				write(".oclAsType(OclAny)");
			}
			write(")");
			if (isListType(targetType)) {
				write("->asSequence()");
			} else if (isSetType(targetType)) {
				write("->asSet()");
			}
		}
	}
d605 3
a607 4
	private boolean isCollectionOperation(OperationCallTrace trace) {
		EOperation eOperation = trace.getEOperation();
		assert eOperation != null;
		return collectionOperations.contains(eOperation);
d712 1
a712 1
	private void internalMigrateOperationCallParameters(OperationCall operationCall, MigrationExecutionContext ctx) throws MigrationException {
d721 44
a764 13
	private String getQVTOperationName(OperationCallTrace trace) {
		EOperation eOperation = trace.getEOperation();
		assert eOperation != null;
		if (BuiltinMetaModel.EString_ToFirstUpper == eOperation) {
			return "firstToUpper";	
		}
		return eOperation.getName();
	}
	
	private boolean isInfixOperation(OperationCallTrace trace) {
		EOperation eOperation = trace.getEOperation();
		assert eOperation != null;
		return infixOperations.contains(eOperation);
d841 1
a841 1
}@


1.1.2.11
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Generating unique iterator variables.
@
text
@d15 1
d78 1
a78 2
			BuiltinMetaModel.Double_Plus_Int,
			BuiltinMetaModel.Object_EQ
a121 2
	private IteratorVariableNameDispatcher iteratorVariableDispatcher;

a173 1
			iteratorVariableDispatcher = new IteratorVariableNameDispatcher(extension);
d617 1
a617 1
			String iteratorName = iteratorVariableDispatcher.getNextName();
a652 2
		} else if (BuiltinMetaModel.Object_EQ == eOperation) { 
			write(" = ");
d798 1
a798 1
			String iteratorName = iteratorVariableDispatcher.getNextName();
d821 88
@


1.1.2.12
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Correctly migrating TypseSelect expresions.
@
text
@a503 1
		int placeholder = getCurrentPosition();
a504 1
		addBraces(placeholder, false);
d547 1
a547 1
			addBraces(placeholder, true);
d551 2
a552 2
	private void addBraces(int placeholder, boolean skipTopLevelExpressions) {
		if (skipTopLevelExpressions && expressionsStack.size() == 1) {
d664 1
a664 1
			addBraces(placeholder, true);
a683 1
		int placeholder = getCurrentPosition();
d689 1
a689 1
			convertCollectionTypes(targetType, targetType, true, placeholder);
d694 1
a694 1
			convertCollectionTypes(targetType, targetType, true, placeholder);
d704 1
a704 1
			convertCollectionTypes(targetType, targetType, true, placeholder);
d708 1
a708 1
			convertCollectionTypes(targetType, setType, true, placeholder);
d713 1
a713 1
			convertCollectionTypes(targetType, setType, true, placeholder);
d718 1
a718 1
			convertCollectionTypes(targetType, setType, true, placeholder);
d723 1
a723 1
			convertCollectionTypes(targetType, setType, false, placeholder);
d726 2
a727 3
			convertCollectionTypes(targetType, listType, false, placeholder);
		} else if (BuiltinMetaModel.Collection_Contains == eOperation) {
			addBraces(placeholder, false);
d732 1
a732 2
		} else if (BuiltinMetaModel.Collection_ContainsAll == eOperation) {
			addBraces(placeholder, false);
a759 1
			addBraces(placeholder, false);
a777 1
		int placeholder = getCurrentPosition();
d780 1
a780 1
		convertCollectionTypes(paramTypes[0], targetType, false, placeholder);
d785 1
a785 1
	private void convertCollectionTypes(EClassifier originalCollectionType, EClassifier targetType, boolean convertToAnyType, int expressionStartPosition) {
a787 1
				addBraces(expressionStartPosition, false);
a796 1
				addBraces(expressionStartPosition, false);				
@


1.1.2.13
log
@Minor refactoring
@
text
@d506 1
a510 9
		internalMigrateTypeSelect(getQvtFQName(type), placeholder);
	}

	private void internalMigrateTypeSelect(String typeName, int placeholder) {
		// TODO: This method should write braces around expression starting at
		// placeholder position conditionally depending on the last char in output
		// sequence.
		write("(", placeholder);
		write(")");
d512 1
a512 1
		write(typeName);
d549 1
a549 1
			addNegationBraces(placeholder);
d553 2
a554 2
	private void addNegationBraces(int placeholder) {
		if (expressionsStack.size() == 1) {
d666 1
a666 1
			addNegationBraces(placeholder);
d731 2
a732 1
			internalMigrateTypeSelect(AnyType.SINGLETON_NAME, placeholder);
d737 2
a738 1
			internalMigrateTypeSelect(AnyType.SINGLETON_NAME, placeholder);
d765 2
a766 2
			internalMigrateTypeSelect(AnyType.SINGLETON_NAME, placeholder);
			write("->indexOf(");
d795 2
a796 1
				internalMigrateTypeSelect(AnyType.SINGLETON_NAME, expressionStartPosition);
d805 2
a806 1
				internalMigrateTypeSelect(AnyType.SINGLETON_NAME, expressionStartPosition);
@


1.1.2.14
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Transforming Collection type on CollectionExpression migration.
@
text
@d532 11
a542 7
		ExpressionAnalyzeTrace expressionTrace = ctx.getTraces().get(collectionExpression);
		if (false == expressionTrace instanceof CollectionExpressionTrace) {
			throw new MigrationException(Type.UNSUPPORTED_COLLECTION_EXPRESSION_TRACE, String.valueOf(expressionTrace));
		}
		CollectionExpressionTrace trace = (CollectionExpressionTrace) expressionTrace;
		switch (trace.getType()) {
		case NOTEXISTS_REF:
d546 4
a549 13
			break;
		case COLLECT_REF:
		case SELECT_REF:
		case REJECT_REF:
		case EXISTS_REF:
		case FORALL_REF:
			write(collectionExpression.getName().getValue());
			break;
		case INCORRECT_EXPRESSION_TYPE:
		case UNDESOLVED_TARGET_TYPE:
			throw new MigrationException(Type.UNSUPPORTED_COLLECTION_EXPRESSION, trace.toString());
		default:
			throw new MigrationException(Type.UNSUPPORTED_COLLECTION_EXPRESSION_TRACE, "Incorrect type: " + trace.getType());
a555 5
		if (trace.getType() == CollectionExpressionTrace.Type.COLLECT_REF && isSetType(trace.getResultType())) {
			// Does not work now due to the bug in xpand implementation - see
			// "TODO [AS]" comment in CollectionExpression
			write("->asSet()");
		}
a645 1
			throw new MigrationException(Type.UNSUPPORTED_OPERATION_CALL_TRACE, "Incorrect type: " + trace.getType());
@


1.1.2.15
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Transforming Collection types on TypeSelectExpression migration.
@
text
@a509 9
		ExpressionAnalyzeTrace expressionTrace = ctx.getTraces().get(typeSelectExpression);
		if (false == expressionTrace instanceof TypeSelectExpressionTrace) {
			throw new MigrationException(Type.UNSUPPORTED_TYPE_SELECT_EXPRESSION_TRACE, String.valueOf(expressionTrace));
		}
		TypeSelectExpressionTrace trace = (TypeSelectExpressionTrace) expressionTrace;
		if (!trace.isValid()) {
			throw new MigrationException(Type.UNSUPPORTED_TYPE_SELECT_EXPRESSION, trace.toString());
		}
		convertCollectionTypes(trace.getTargetType(), trace.getTargetType(), false, placeholder);
a510 3
		if (!isListType(trace.getTargetType())) {
			write("->asSequence()");
		}
@


1.1.2.16
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 .withoutFirst()/.withoutLast() operations were corrected.
@
text
@d778 1
a778 1
			write("->size() < 2 then Sequence{} else ");
d786 1
a786 1
			write("->size() < 2 then Sequence{} else ");
@


1.1.2.17
log
@Buildin String operations migrated using additional qvto library.
@
text
@a77 1
			BuiltinMetaModel.EString_Plus_EJavaObject,
d112 1
a112 3
	private ModeltypeImports modeltypeImportsManger;

	private StandardLibraryImports stdLibImportsManager;
a123 2
	private Stack<AbstractImportsManager> importsManagers = new Stack<AbstractImportsManager>();

d164 1
a164 1
		importsManagers.push(modeltypeImportsManger = new ModeltypeImports(output, injectUnusedImports));
d167 1
a167 1
			modeltypeImportsManger.registerModeltype(namespace);
a169 1
		importsManagers.push(stdLibImportsManager = new StandardLibraryImports(output));
d172 1
a172 3
		writeln("");
		writeln("library " + shortResourceName + ";");
		writeln("");
d182 1
a182 3
		while (!importsManagers.isEmpty()) {
			importsManagers.pop().injectImports();
		}
d285 1
a285 1
		String alias = modeltypeImportsManger.getModeltypeAlias(ePackage);
d618 6
a623 1
				internalMigrateOperationCall(trace, operationCall, ctx);
d628 2
d632 4
a635 1
			internalMigrateOperationCall(trace, operationCall, ctx);
d685 1
a685 1
				|| BuiltinMetaModel.Double_Plus_Int == eOperation || BuiltinMetaModel.Double_Plus_Double == eOperation || BuiltinMetaModel.EString_Plus_EJavaObject == eOperation) {
d689 1
a689 1
		} else if (BuiltinMetaModel.Object_EQ == eOperation) {
d695 1
a695 6
		if (BuiltinMetaModel.EString_Plus_EJavaObject == eOperation) { 
			assert trace.getParamTypes().length == 1;
			if (trace.getParamTypes()[0] != EcorePackage.eINSTANCE.getEString()) {
				write(".repr()");
			}
		} else if (BuiltinMetaModel.Boolean_NE == eOperation || BuiltinMetaModel.Int_Unary_Minus == eOperation || BuiltinMetaModel.Double_Unary_Minus == eOperation) {
d885 1
a885 1
	private void internalMigrateOperationCall(OperationCallTrace trace, OperationCall operationCall, MigrationExecutionContext ctx) throws MigrationException {
d888 2
a889 6
		internalMigrateOperationCallTarget(operationCall, ctx);
		write(".");
		write(stdLibImportsManager.getOperationName(eOperation));
		write("(");
		if (BuiltinMetaModel.EString_SubString_StartEnd == eOperation) {
			write("1 + ");
d891 1
a891 2
		internalMigrateOperationCallParameters(operationCall, ctx);
		write(")");
d910 1
a910 1
			String modelType = modeltypeImportsManger.getModeltypeAlias(enumLiteral.getEEnum().getEPackage());
@


1.1.2.18
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Migration for OclAny operations
@
text
@d79 1
a79 2
			BuiltinMetaModel.Object_EQ,
			BuiltinMetaModel.Object_NotEQ
a167 3
		
		importsManagers.push(stdLibImportsManager = new StandardLibraryImports(output));
		addLibraryImports(xtendResource, false);
d170 1
d175 3
a690 2
		} else if (BuiltinMetaModel.Object_NotEQ == eOperation) { 
			write(" <> ");
@


1.1.2.19
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Integer Operations migration.
@
text
@a77 11
			BuiltinMetaModel.Int_Mult_Double, 
			BuiltinMetaModel.Int_Mult_Int, 
			BuiltinMetaModel.Double_Mult_Double, 
			BuiltinMetaModel.Double_Mult_Int,
			BuiltinMetaModel.Int_Div_Double,
			BuiltinMetaModel.Double_Div_Double,
			BuiltinMetaModel.Double_Div_Int,
			BuiltinMetaModel.Int_Less,
			BuiltinMetaModel.Int_LessOrEqual,
			BuiltinMetaModel.Int_Greater,
			BuiltinMetaModel.Int_GreatOrEqual,
d685 1
a685 5
				|| BuiltinMetaModel.Double_Plus_Int == eOperation || BuiltinMetaModel.Double_Plus_Double == eOperation || BuiltinMetaModel.Int_Mult_Int == eOperation
				|| BuiltinMetaModel.Int_Mult_Double == eOperation || BuiltinMetaModel.Double_Mult_Int == eOperation || BuiltinMetaModel.Double_Mult_Double == eOperation
				|| BuiltinMetaModel.Int_Div_Double == eOperation || BuiltinMetaModel.Double_Div_Double == eOperation || BuiltinMetaModel.Double_Div_Int == eOperation
				|| BuiltinMetaModel.Int_Less == eOperation || BuiltinMetaModel.Int_LessOrEqual == eOperation || BuiltinMetaModel.Int_Greater == eOperation
				|| BuiltinMetaModel.Int_GreatOrEqual == eOperation || BuiltinMetaModel.EString_Plus_EJavaObject == eOperation) {
@


1.1.2.20
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Formatting beautified.
@
text
@a182 3
		if (xtendResource.getImportedExtensions().length > 0) {
			writeln("");
		}
d189 1
@


1.1.2.21
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 REfactoring a way to migrate collection operations.
@
text
@a13 1
import java.util.ArrayList;
a16 1
import java.util.List;
d137 1
a137 1
	private VariableNameDispatcher variableDispatcher;
d197 1
a197 1
			variableDispatcher = new VariableNameDispatcher(extension);
d541 2
a542 1
		internalMigrateTypeSelectCastingCollectionToBag(trace.getTargetType(), getQvtFQName(type), placeholder);
d547 1
a547 10
	
	private void internalMigrateTypeSelectCastingCollectionToBag(EClassifier collectionType, String typeName, int placeholder) {
		assert BuiltinMetaModel.isCollectionType(collectionType);
		if (isListType(collectionType) || isSetType(collectionType)) {
			internalMigrateTypeSelect(typeName, placeholder);
		} else {
			internalMigrateCollectionToBag(typeName);
		}
	}
	
d549 3
a551 3
		// TODO: This method should write braces around expression starting
		// at placeholder position conditionally depending on the last char
		// in output sequence.
a557 15
	
	// TODO: use ->asSequence() here in addition?
	private void internalMigrateCollectionToBag(String typeName) {
		String iteratorName = variableDispatcher.getNextIteratorName();
		write("->collect(");
		write(iteratorName);
		write(" | ");
		write(iteratorName);
		if (typeName != null) {
			write(".oclAsType(");
			write(typeName);
			write(")");
		}
		write(")");
	}
d665 1
a665 1
			String iteratorName = variableDispatcher.getNextIteratorName();
d690 1
a739 2
		assert BuiltinMetaModel.isCollectionType(targetType);
		EClassifier elementType = BuiltinMetaModel.getInnerType(targetType);
d747 1
a747 2
			EClassifier commonSuperType = getCommonSuperType(elementType, getSingleParameterType(trace));
			internalMigrateToConcreteCollection(targetType, commonSuperType, placeholder);
d752 12
a763 6
			EClassifier commonSuperType = getCommonSuperType(elementType, getSingleCollectionParameterElementType(trace));
			internalMigrateToConcreteCollection(targetType, commonSuperType, placeholder);
			write("->union(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			internalMigrateParameterCollectionToMain(getSingleParameterType(trace), targetType);
			write(")");
d765 4
a768 6
			EClassifier commonSuperType = getCommonSuperType(elementType, getSingleCollectionParameterElementType(trace));
			internalMigrateToSet(targetType, commonSuperType, placeholder);
			write("->union(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			internalMigrateParameterCollectionToSet(getSingleParameterType(trace));
			write(")");
d770 15
a784 13
			EClassifier commonSuperType = getCommonSuperType(elementType, getSingleCollectionParameterElementType(trace));
			internalMigrateToSet(targetType, commonSuperType, placeholder);
			write("->intersection(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			internalMigrateParameterCollectionToSet(getSingleParameterType(trace));
			write(")");
		} else if (BuiltinMetaModel.Collection_Without == eOperation) {
			EClassifier commonSuperType = getCommonSuperType(elementType, getSingleCollectionParameterElementType(trace));
			internalMigrateToSet(targetType, commonSuperType, placeholder);
			write("->-(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			internalMigrateParameterCollectionToSet(getSingleParameterType(trace));
			write(")");
d786 1
a786 5
			EClassifier parameterType = getSingleParameterType(trace);
			if (!BuiltinMetaModel.isAssignableFrom(elementType, parameterType)) {
				EClassifier commonSuperType = getCommonSuperType(elementType, parameterType);
				internalMigrateTypeSelect(getQvtFQName(commonSuperType), placeholder);
			}
d791 1
a791 5
			EClassifier parameterElementType = getSingleCollectionParameterElementType(trace);
			if (!BuiltinMetaModel.isAssignableFrom(elementType, parameterElementType)) {
				EClassifier commonSuperType = getCommonSuperType(elementType, parameterElementType);
				internalMigrateTypeSelect(getQvtFQName(commonSuperType), placeholder);
			}
a794 31
		} else if (BuiltinMetaModel.List_IndexOf == eOperation) {
			EClassifier parameterType = getSingleParameterType(trace);
			if (!BuiltinMetaModel.isAssignableFrom(elementType, parameterType)) {
				EClassifier commonSuperType = getCommonSuperType(elementType, parameterType);
				internalMigrateTypeSelectCastingCollectionToBag(targetType, getQvtFQName(commonSuperType), placeholder);
			}
			write("->indexOf(");
			internalMigrateOperationCallParameters(operationCall, ctx);
			write(")");
			write("(", placeholder);
			write(" - 1)");
		} else if (BuiltinMetaModel.Collection_Clear == eOperation) {
			if (isSetType(targetType)) {
				write("Set{}");
			} else if (isListType(targetType)) {
				write("Sequence{}");
			} else {
				write("Bag{}");
			}
			if (elementType != EcorePackage.eINSTANCE.getEJavaObject()) {
				write("[");
				write(getQvtFQName(elementType));
				write("]");
			}
		} else if (BuiltinMetaModel.Collection_Flatten == eOperation) {
			internalMigrateToConcreteCollection(targetType, elementType, placeholder);
			write("->flatten()");
		} else if (BuiltinMetaModel.Collection_ToSet == eOperation) { 
			internalMigrateToSet(targetType, elementType, placeholder);
		} else if (BuiltinMetaModel.Collection_ToList == eOperation) {
			internalMigrateToList(targetType, elementType, placeholder);
d799 4
a802 5
		} else if (BuiltinMetaModel.List_WithoutFirst == eOperation) {
			String varName = variableDispatcher.getNextVariableName();
			write("let ");
			write(varName);
			write(" = ");
a803 11
			write(" in ");
			write("if ");
			write(varName);
			write("->size() < 2 then Sequence{}");
			if (elementType != EcorePackage.eINSTANCE.getEJavaObject()) {
				write("[");
				write(getQvtFQName(elementType));
				write("]");
			}
			write(" else ");
			write(varName);
d805 1
a805 1
			write(varName);
d807 4
a810 5
		} else if (BuiltinMetaModel.List_WithoutLast == eOperation) {
			String varName = variableDispatcher.getNextVariableName();
			write("let ");
			write(varName);
			write(" = ");
a811 11
			write(" in ");
			write("if ");
			write(varName);
			write("->size() < 2 then Sequence{}");
			if (elementType != EcorePackage.eINSTANCE.getEJavaObject()) {
				write("[");
				write(getQvtFQName(elementType));
				write("]");
			}
			write(" else ");
			write(varName);
d813 1
a813 1
			write(varName);
d817 5
d823 1
a823 4
			/**
			 * .isEmpty() .size() .first() .last()
			 */
			assert operationCall.getParams().length == 0;
d831 2
a832 26
	
	private EClassifier getCommonSuperType(EClassifier collectionElementType1, EClassifier collectionElementType2) {
		if (BuiltinMetaModel.isAssignableFrom(collectionElementType1, collectionElementType2)) {
			return collectionElementType1;
		}
		if (collectionElementType1 instanceof EClass) {
			EClass eClass = (EClass) collectionElementType1;
			for (EClass nextSuperType : getAllSuperTypes(eClass)) {
				if (BuiltinMetaModel.isAssignableFrom(nextSuperType, collectionElementType2)) {
					return nextSuperType;
				}
			}
		}
		return EcorePackage.eINSTANCE.getEJavaObject();
	}
	
	private List<EClass> getAllSuperTypes(EClass eClass) {
		List<EClass> result = new ArrayList<EClass>(eClass.getESuperTypes());
		for (int i = 1; i < result.size(); i++) {
			EClass nextSuperType = result.get(i);
			result.addAll(nextSuperType.getESuperTypes());
		}
		return result;
	}
	
	private EClassifier getSingleParameterType(OperationCallTrace trace) {
d835 7
a841 1
		return paramTypes[0];
d843 6
a848 41
	
	private EClassifier getSingleCollectionParameterElementType(OperationCallTrace trace) {
		EClassifier parameterType = getSingleParameterType(trace);
		assert BuiltinMetaModel.isCollectionType(parameterType);
		return BuiltinMetaModel.getInnerType(parameterType);
	}
	
	private void internalMigrateToConcreteCollection(EClassifier collectionType, EClassifier elementSuperType, int placeholder) throws MigrationException {
		assert BuiltinMetaModel.isCollectionType(collectionType);
		EClassifier elementType = BuiltinMetaModel.getInnerType(collectionType);
		String elementSuperTypeName = getQvtFQName(elementSuperType);
		if (elementSuperType != elementType) {
			internalMigrateTypeSelectCastingCollectionToBag(collectionType, elementSuperTypeName, placeholder);	
		} else if (!isListType(collectionType) && !isSetType(collectionType)) {
			internalMigrateCollectionToBag(null);
		}
	}
	
	private void internalMigrateToSet(EClassifier collectionType, EClassifier elementSuperType, int placeholder) throws MigrationException {
		internalMigrateToConcreteCollection(collectionType, elementSuperType, placeholder);
		if (!isSetType(collectionType)) {
			write("->asSet()");
		}
	}
	
	private void internalMigrateToList(EClassifier collectionType, EClassifier elementSuperType, int placeholder) throws MigrationException {
		internalMigrateToConcreteCollection(collectionType, elementSuperType, placeholder);
		if (!isListType(collectionType)) {
			write("->asSequence()");
		}
	}
	
	private void internalMigrateParameterCollectionToMain(EClassifier parameterCollectionType, EClassifier mainCollectionType) {
		assert BuiltinMetaModel.isCollectionType(parameterCollectionType);
		assert BuiltinMetaModel.isCollectionType(mainCollectionType);
		if (isListType(mainCollectionType)) {
			if (isSetType(parameterCollectionType)) {
				write("->asSequence()");
			} else if (!isListType(parameterCollectionType)) {
				internalMigrateCollectionToBag(null);
				write("->asSequence()");
d850 1
a850 5
		} else if (isSetType(mainCollectionType)) {
			if (isListType(parameterCollectionType)) {
				write("->asSet()");
			} else if (!isSetType(parameterCollectionType)) {
				internalMigrateCollectionToBag(null);
d852 9
d863 13
a875 4
			if (isSetType(parameterCollectionType) || isListType(parameterCollectionType)) {
				write("->asBag()");
			} else {
				internalMigrateCollectionToBag(null);
a878 10
	
	private void internalMigrateParameterCollectionToSet(EClassifier parameterCollectionType) {
		assert BuiltinMetaModel.isCollectionType(parameterCollectionType);
		if (isListType(parameterCollectionType)) {
			write("->asSet()");
		} else if (!isSetType(parameterCollectionType)) {
			internalMigrateCollectionToBag(null);
			write("->asSet()");
		}
	}
@


1.1.2.22
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Refactoring a way to migrate collection operations.
@
text
@a62 1
import org.eclipse.ocl.types.VoidType;
a278 3
		if (classifier == BuiltinMetaModel.VOID) {
			return VoidType.SINGLETON_NAME;
		}
a777 1
			internalMigrateToBag(targetType);
a784 1
			internalMigrateToBag(targetType);
a791 1
			internalMigrateToBag(targetType);
a798 1
			internalMigrateToBag(targetType);
a805 1
			internalMigrateToBag(targetType);
d836 7
a842 1
			write("Bag{}");
a850 1
			internalMigrateToBag(targetType);
a913 6
	private void internalMigrateToBag(EClassifier collectionType) {
		if (isListType(collectionType) || isSetType(collectionType)) {
			write("->asBag()");
		}
	}
	
a914 3
		if (BuiltinMetaModel.VOID == collectionElementType1) {
			return EcorePackage.eINSTANCE.getEJavaObject();
		}
d953 1
d955 1
a955 1
			internalMigrateTypeSelectCastingCollectionToBag(collectionType, getQvtFQName(elementSuperType), placeholder);	
@


1.1.2.23
log
@Temporarily commenting out migration to proper collection types.
@
text
@d782 1
a782 1
//			internalMigrateToBag(targetType);
d790 1
a790 1
//			internalMigrateToBag(targetType);
d798 1
a798 1
//			internalMigrateToBag(targetType);
d806 1
a806 1
//			internalMigrateToBag(targetType);
d814 1
a814 1
//			internalMigrateToBag(targetType);
d845 1
a845 8
			if (isSetType(targetType)) {
				write("Set{}");
			} else if (isListType(targetType)) {
				write("Sequence{}");
			} else {
				write("Bag{}");
			}
//			write("Bag{}");
d854 1
a854 1
//			internalMigrateToBag(targetType);
d918 5
a922 5
//	private void internalMigrateToBag(EClassifier collectionType) {
//		if (isListType(collectionType) || isSetType(collectionType)) {
//			write("->asBag()");
//		}
//	}
@


1.1.2.24
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Separate ExpressionMigrationFacade class was created covering expressions AST migration.
@
text
@@


