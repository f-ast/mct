head	1.1;
access;
symbols
	ocl_qvt:1.1.0.2;
locks; strict;
comment	@# @;
expand	@k@;


1.1
date	2008.07.29.15.57.46;	author ashatalin;	state dead;
branches
	1.1.2.1;
next	;
commitid	33cb488f3dd14567;

1.1.2.1
date	2008.07.29.15.57.46;	author ashatalin;	state Exp;
branches;
next	1.1.2.2;
commitid	33cb488f3dd14567;

1.1.2.2
date	2008.08.28.15.51.01;	author ashatalin;	state Exp;
branches;
next	1.1.2.3;
commitid	35c448b6c95d4567;

1.1.2.3
date	2008.09.17.18.09.46;	author ashatalin;	state Exp;
branches;
next	;
commitid	22c4f48d147e94567;


desc
@@


1.1
log
@file ExpressionFactory.java was initially added on branch ocl_qvt.
@
text
@@


1.1.2.1
log
@Xtend-based implementation of XPand extensions was separated into .migration plugin.
@
text
@a0 165
/*
 * <copyright>
 *
 * Copyright (c) 2005-2006 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.expression.parser;

import java.util.List;

import org.eclipse.gmf.internal.xpand.expression.ast.BooleanLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.BooleanOperation;
import org.eclipse.gmf.internal.xpand.expression.ast.Case;
import org.eclipse.gmf.internal.xpand.expression.ast.Cast;
import org.eclipse.gmf.internal.xpand.expression.ast.ChainExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.CollectionExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.ConstructorCallExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.DeclaredParameter;
import org.eclipse.gmf.internal.xpand.expression.ast.Expression;
import org.eclipse.gmf.internal.xpand.expression.ast.FeatureCall;
import org.eclipse.gmf.internal.xpand.expression.ast.Identifier;
import org.eclipse.gmf.internal.xpand.expression.ast.IfExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.IntegerLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.LetExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.ListLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.NullLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.OperationCall;
import org.eclipse.gmf.internal.xpand.expression.ast.RealLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.StringLiteral;
import org.eclipse.gmf.internal.xpand.expression.ast.SwitchExpression;
import org.eclipse.gmf.internal.xpand.expression.ast.SyntaxElement;
import org.eclipse.gmf.internal.xpand.expression.ast.TypeSelectExpression;

import lpg.lpgjavaruntime.IToken;

/**
 * @@author Sven Efftinge
 * @@author Arno Haase
 */
public class ExpressionFactory {

	private String fileName;

	public ExpressionFactory(final String string) {
		fileName = string;
	}

	protected static int end(final IToken c) {
		return c.getEndColumn();
	}

	protected static int start(final IToken c) {
		return c.getColumn() - 1;
	}

	protected static int line(final IToken c) {
		return c.getLine();
	}

	public StringLiteral createStringLiteral(final IToken t) {
		return handle(new StringLiteral(start(t), end(t), line(t), t.toString()));
	}

	public IntegerLiteral createIntegerLiteral(final IToken t) {
		return handle(new IntegerLiteral(start(t), end(t), line(t), t.toString()));
	}

	public BooleanLiteral createBooleanLiteral(final IToken t) {
		return handle(new BooleanLiteral(start(t), end(t), line(t), t.toString()));
	}

	public NullLiteral createNullLiteral(final IToken t) {
		return handle(new NullLiteral(start(t), end(t), line(t)));
	}

	public ListLiteral createListLiteral(final IToken start, final IToken end, final List<Expression> paramExpr) {
		return handle(new ListLiteral(start(start), end(end), line(start), paramExpr.toArray(new Expression[paramExpr.size()])));
	}

	public FeatureCall createFeatureCall(final Identifier name, final Expression target) {
		return handle(new FeatureCall(name.getStart(), name.getEnd(), name.getLine(), name, target));
	}

	public Identifier createIdentifier(IToken name) {
		return new Identifier(start(name), end(name), line(name), name.toString());
	}

	public OperationCall createOperationCall(final IToken endToken, final IToken name, final Expression target, final List<Expression> parameterExpressions) {
		final int start = start(name);
		final int line = line(name);
		final int end = end(endToken);
		final Expression[] params = parameterExpressions.toArray(new Expression[parameterExpressions.size()]);
		return handle(new OperationCall(start, end, line, createIdentifier(name), target, params));
	}

	// XXX
	public OperationCall createOperationCall(final int start, final int end, final int line, final IToken name, final Expression target, final List<Expression> parameterExpressions) {
		final Expression[] params = parameterExpressions.toArray(new Expression[parameterExpressions.size()]);
		return handle(new OperationCall(start, end, line, createIdentifier(name), target, params));
	}

	public IfExpression createIf(final Expression cond, final Expression then, final Expression elseExpr) {
		final int start = cond.getStart();
		final int line = cond.getLine();
		final int end = elseExpr.getEnd();
		return handle(new IfExpression(start, end, line, cond, then, elseExpr));
	}

	public CollectionExpression createCollectionExpression(final IToken opName, final IToken endToken, final IToken elementName, final Expression closure, final Expression target) {
		return handle(new CollectionExpression(end(endToken), createIdentifier(opName), elementName == null ? null : elementName.toString(), closure, target));
	}

	public DeclaredParameter createDeclaredParameter(final Identifier type, final Identifier name) {
		return handle(new DeclaredParameter(type.getStart(), name.getEnd(), type.getLine(), type, name));
	}

	public Expression createCast(final IToken start, final Identifier t, final Expression e) {
		return handle(new Cast(start(start), e.getEnd(), line(start), t, e));
	}

	protected <T extends SyntaxElement> T handle(final T expr) {
		expr.setFileName(fileName);
		return expr;
	}

	public Case createCase(final IToken start, final Expression cond, final Expression then) {
		return handle(new Case(start(start), then.getEnd(), line(start), cond, then));
	}

	public SwitchExpression createSwitchExpression(final IToken start, final IToken end, final Expression switchExpr, final List<Case> cases, final Expression defaultExpr) {
		return handle(new SwitchExpression(start(start), end(end), line(start), switchExpr, cases, defaultExpr));
	}

	public ChainExpression createChainExpression(final Expression head, final Expression next) {
		return handle(new ChainExpression(head.getStart(), next.getEnd(), head.getLine(), head, next));
	}

	public RealLiteral createRealLiteral(final IToken token) {
		return handle(new RealLiteral(start(token), end(token), line(token), token.toString()));
	}

	public FeatureCall createTypeSelectExpression(final IToken id, final IToken c1, final Identifier ident, final Expression e) {
		return handle(new TypeSelectExpression(end(c1), createIdentifier(id), ident, e));
	}

	public BooleanOperation createBooleanOperation(final int start, final int end, final int line, final IToken name, final Expression e, final Expression r) {
		return handle(new BooleanOperation(start, end, line, name.toString(), e, r));
	}

	public LetExpression createLetExpression(final IToken start, final IToken v, final Expression varExpr, final Expression target) {
		return handle(new LetExpression(start(start), target.getEnd(), line(start), createIdentifier(v), varExpr, target));
	}

	public Expression createConstructorCall(final IToken s, final Identifier type) {
		return handle(new ConstructorCallExpression(start(s), type.getEnd(), line(s), type));
	}
}
@


1.1.2.2
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 First step toward .xpt migration.
@
text
@d69 1
a69 1
		return handle(new StringLiteral(start(t), end(t), line(t), t.getStartOffset(), t.getEndOffset(), t.toString()));
d73 1
a73 1
		return handle(new IntegerLiteral(start(t), end(t), line(t), t.getStartOffset(), t.getEndOffset(), t.toString()));
d77 1
a77 1
		return handle(new BooleanLiteral(start(t), end(t), line(t), t.getStartOffset(), t.getEndOffset(), t.toString()));
d81 1
a81 1
		return handle(new NullLiteral(start(t), end(t), line(t), t.getStartOffset(), t.getEndOffset()));
d85 1
a85 1
		return handle(new ListLiteral(start(start), end(end), line(start), start.getStartOffset(), end.getEndOffset(), paramExpr.toArray(new Expression[paramExpr.size()])));
d89 1
a89 1
		return handle(new FeatureCall(name.getStart(), name.getEnd(), name.getLine(), name.getStartOffset(), name.getEndOffset(), name, target));
d93 1
a93 1
		return new Identifier(start(name), end(name), line(name), name.getStartOffset(), name.getEndOffset(), name.toString());
d101 1
a101 1
		return handle(new OperationCall(start, end, line, name.getStartOffset(), endToken.getEndOffset(), createIdentifier(name), target, params));
d105 1
a105 1
	public OperationCall createOperationCall(final int start, final int end, final int line, final int startOffset, final int endOffset, final IToken name, final Expression target, final List<Expression> parameterExpressions) {
d107 1
a107 1
		return handle(new OperationCall(start, end, line, startOffset, endOffset, createIdentifier(name), target, params));
d114 1
a114 1
		return handle(new IfExpression(start, end, line, cond.getStartOffset(), elseExpr.getEndOffset(),  cond, then, elseExpr));
d118 1
a118 1
		return handle(new CollectionExpression(end(endToken), endToken.getEndOffset(), createIdentifier(opName), elementName == null ? null : elementName.toString(), closure, target));
d122 1
a122 1
		return handle(new DeclaredParameter(type.getStart(), name.getEnd(), type.getLine(), type.getStartOffset(), name.getEndOffset(), type, name));
d126 1
a126 1
		return handle(new Cast(start(start), e.getEnd(), line(start), start.getStartOffset(), e.getEndOffset(), t, e));
d135 1
a135 1
		return handle(new Case(start(start), then.getEnd(), line(start), start.getStartOffset(), then.getEndOffset(), cond, then));
d139 1
a139 1
		return handle(new SwitchExpression(start(start), end(end), line(start), start.getStartOffset(), end.getEndOffset(), switchExpr, cases, defaultExpr));
d143 1
a143 1
		return handle(new ChainExpression(head.getStart(), next.getEnd(), head.getLine(), head.getStartOffset(), next.getEndOffset(), head, next));
d147 1
a147 1
		return handle(new RealLiteral(start(token), end(token), line(token), token.getStartOffset(), token.getEndOffset(), token.toString()));
d151 1
a151 1
		return handle(new TypeSelectExpression(end(c1), c1.getEndOffset(), createIdentifier(id), ident, e));
d154 2
a155 2
	public BooleanOperation createBooleanOperation(final int start, final int end, final int line, final int startOffset, final int endOffest, final IToken name, final Expression e, final Expression r) {
		return handle(new BooleanOperation(start, end, line, startOffset, endOffest, name.toString(), e, r));
d159 1
a159 1
		return handle(new LetExpression(start(start), target.getEnd(), line(start), start.getStartOffset(), target.getEndOffset(), createIdentifier(v), varExpr, target));
d163 1
a163 1
		return handle(new ConstructorCallExpression(start(s), type.getEnd(), line(s), s.getStartOffset(), type.getEndOffset(), type));
@


1.1.2.3
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Correctly initializing NullLiteral positions
 - Initializing VariableNameDispatcher
@
text
@d81 1
a81 1
		return handle(new NullLiteral(start(t), end(t), t.getStartOffset(), t.getEndOffset(), line(t)));
@


