head	1.1;
access;
symbols
	ocl_qvt:1.1.0.2;
locks; strict;
comment	@# @;
expand	@k@;


1.1
date	2008.08.01.09.16.53;	author ashatalin;	state dead;
branches
	1.1.2.1;
next	;
commitid	6e264892d4804567;

1.1.2.1
date	2008.08.01.09.16.53;	author ashatalin;	state Exp;
branches;
next	1.1.2.2;
commitid	6e264892d4804567;

1.1.2.2
date	2008.08.21.12.22.18;	author ashatalin;	state Exp;
branches;
next	1.1.2.3;
commitid	348648ad5df34567;

1.1.2.3
date	2008.08.22.12.32.38;	author ashatalin;	state Exp;
branches;
next	1.1.2.4;
commitid	752448aeb1e44567;

1.1.2.4
date	2008.08.28.15.51.01;	author ashatalin;	state Exp;
branches;
next	;
commitid	35c448b6c95d4567;


desc
@@


1.1
log
@file ModeltypeImports.java was initially added on branch ocl_qvt.
@
text
@@


1.1.2.1
log
@Migration implementation + unit-tests for basic extend elements.
@
text
@a0 103
/**
 * Copyright (c) 2008 Borland Software Corp.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.xpand.migration;

import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

import org.eclipse.emf.ecore.EPackage;

class ModeltypeImports {

	private static final String DEFAULT_ALIAS = "metaModelRef";

	private StringBuilder stringBuilder;

	private boolean injectUnusedImports;

	private int placeHolderIndex;

	private Set<String> modeltypeAliases = new HashSet<String>();

	private Map<String, String> nsURI2Aliases = new LinkedHashMap<String, String>();

	private Set<String> usedNsURIs = new HashSet<String>();

	ModeltypeImports(StringBuilder stringBuilder, boolean injectUnusedImports) {
		this.stringBuilder = stringBuilder;
		placeHolderIndex = stringBuilder.length();
		this.injectUnusedImports = injectUnusedImports;
	}

	void setInjectUnusedImports(boolean injectUnusedImports) {
		this.injectUnusedImports = injectUnusedImports;
	}

	void injectImports() {
		for (Entry<String, String> entry : nsURI2Aliases.entrySet()) {
			if (!injectUnusedImports && !usedNsURIs.contains(entry.getKey())) {
				// Skipping the entry if it was not used
				continue;
			}
			writeln("modeltype " + entry.getValue() + " uses \"" + entry.getKey() + "\";");
		}
	}

	void registerModeltype(String nsURI) {
		assert nsURI.length() > 0;
		String modeltypeAlias = getUniqueModeltypeAlias(nsURI);
		nsURI2Aliases.put(nsURI, modeltypeAlias);
	}

	String getModeltypeAlias(EPackage ePackage) {
		String nsURI = ePackage.getNsURI();
		// Now we are registering models even if they was not imported before..
		if (!nsURI2Aliases.containsKey(nsURI)) {
			registerModeltype(nsURI);
		}
		usedNsURIs.add(nsURI);
		return nsURI2Aliases.get(nsURI);
	}

	private void writeln(String line) {
		stringBuilder.insert(placeHolderIndex, line);
		placeHolderIndex += line.length();
		stringBuilder.insert(placeHolderIndex, MigrationFacade.LF);
		placeHolderIndex += MigrationFacade.LF.length();
	}

	private String getUniqueModeltypeAlias(String nsURI) {
		char[] charArray = nsURI.toCharArray();
		int i = charArray.length - 1;
		for (; i > -1 && Character.isJavaIdentifierPart(charArray[i]); i--) {
		}
		String aliasProposal;
		if (i < charArray.length - 1) {
			char[] alias = new char[charArray.length - 1 - i];
			System.arraycopy(charArray, i + 1, alias, 0, charArray.length - 1 - i);
			alias[0] = Character.toLowerCase(alias[0]);
			aliasProposal = new String(alias);
		} else {
			aliasProposal = DEFAULT_ALIAS;
		}
		String actualAlias = aliasProposal;
		for (int suffix = 1; modeltypeAliases.contains(actualAlias); suffix++) {
			actualAlias = aliasProposal + "_" + suffix;
		}
		modeltypeAliases.add(actualAlias);
		return actualAlias;
	}

}
@


1.1.2.2
log
@Buildin String operations migrated using additional qvto library.
@
text
@d22 1
a22 1
class ModeltypeImports extends AbstractImportsManager {
d26 2
d30 2
d39 2
a40 1
		super(stringBuilder);
d74 7
@


1.1.2.3
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Formatting beautified.
@
text
@a43 1
		boolean addEmptyLine = false;
a48 1
			addEmptyLine = true;
a50 3
		if (addEmptyLine) {
			writeln("");
		}
@


1.1.2.4
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 First step toward .xpt migration.
@
text
@a37 5
	
	ModeltypeImports(int placeholder, boolean injectUnusedImports) {
		super(placeholder);
		this.injectUnusedImports = injectUnusedImports;
	}
d43 2
a44 2
	Map<String, String> getModelTypes() {
		Map<String, String> result = new LinkedHashMap<String, String>();
d50 5
a54 1
			result.put(entry.getKey(), entry.getValue());
a55 1
		return result;
@


