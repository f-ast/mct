head	1.14;
access;
symbols
	ocl_qvt:1.13.0.2
	Root_ocl_qvt:1.13;
locks; strict;
comment	@# @;
expand	@k@;


1.14
date	2008.09.26.18.25.21;	author ashatalin;	state dead;
branches;
next	1.13;
commitid	2a33048dd29104567;

1.13
date	2008.09.19.13.59.21;	author ashatalin;	state Exp;
branches
	1.13.2.1;
next	1.12;
commitid	1174c48d3b0394567;

1.12
date	2008.09.19.12.58.41;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	e12648d3a2014567;

1.11
date	2008.09.17.17.14.24;	author ashatalin;	state Exp;
branches;
next	1.10;
commitid	1f23e48d13af04567;

1.10
date	2008.09.17.17.07.26;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	1ee5b48d1394d4567;

1.9
date	2008.09.17.16.39.49;	author ashatalin;	state Exp;
branches;
next	1.8;
commitid	1cca148d132d44567;

1.8
date	2008.09.17.16.20.01;	author ashatalin;	state Exp;
branches;
next	1.7;
commitid	1aa9148d12e304567;

1.7
date	2008.09.17.15.26.53;	author ashatalin;	state Exp;
branches;
next	1.6;
commitid	1558348d121bc4567;

1.6
date	2008.09.17.12.24.38;	author ashatalin;	state Exp;
branches;
next	1.5;
commitid	77f248d0f7054567;

1.5
date	2008.09.15.15.41.17;	author ashatalin;	state Exp;
branches;
next	1.4;
commitid	97e48ce821d4567;

1.4
date	2008.09.15.15.37.01;	author ashatalin;	state Exp;
branches;
next	1.3;
commitid	17248ce811c4567;

1.3
date	2008.09.15.12.44.44;	author ashatalin;	state Exp;
branches;
next	1.2;
commitid	1a9f48ce58bc4567;

1.2
date	2008.09.15.11.11.32;	author ashatalin;	state Exp;
branches;
next	1.1;
commitid	562548ce42e34567;

1.1
date	2008.08.28.15.51.01;	author ashatalin;	state Exp;
branches;
next	;
commitid	35c448b6c95d4567;

1.13.2.1
date	2008.09.26.18.15.49;	author ashatalin;	state Exp;
branches;
next	1.13.2.2;
commitid	2780148dd26d24567;

1.13.2.2
date	2008.09.29.14.53.27;	author ashatalin;	state Exp;
branches;
next	1.13.2.3;
commitid	6da48e0ebe64567;

1.13.2.3
date	2008.10.07.14.44.38;	author ashatalin;	state Exp;
branches;
next	1.13.2.4;
commitid	1997848eb75d34567;

1.13.2.4
date	2008.10.08.16.25.59;	author ashatalin;	state Exp;
branches;
next	1.13.2.5;
commitid	b10b48ecdf164567;

1.13.2.5
date	2008.10.20.17.06.29;	author ashatalin;	state Exp;
branches;
next	1.13.2.6;
commitid	31fd448fcba954567;

1.13.2.6
date	2008.10.23.10.25.22;	author ashatalin;	state Exp;
branches;
next	;
commitid	3aa1b490051104567;


desc
@@


1.14
log
@Removing incorrectly commited resources
@
text
@/**
 * Copyright (c) 2008 Borland Software Corp.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Shatalin (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.xpand.migration;

import java.io.IOException;
import java.io.Reader;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.gmf.internal.xpand.ResourceManager;
import org.eclipse.gmf.internal.xpand.ast.AbstractDefinition;
import org.eclipse.gmf.internal.xpand.ast.Advice;
import org.eclipse.gmf.internal.xpand.ast.ErrorStatement;
import org.eclipse.gmf.internal.xpand.ast.ExpandStatement;
import org.eclipse.gmf.internal.xpand.ast.ExpressionStatement;
import org.eclipse.gmf.internal.xpand.ast.FileStatement;
import org.eclipse.gmf.internal.xpand.ast.ForEachStatement;
import org.eclipse.gmf.internal.xpand.ast.IfStatement;
import org.eclipse.gmf.internal.xpand.ast.ImportDeclaration;
import org.eclipse.gmf.internal.xpand.ast.LetStatement;
import org.eclipse.gmf.internal.xpand.ast.NamespaceImport;
import org.eclipse.gmf.internal.xpand.ast.Statement;
import org.eclipse.gmf.internal.xpand.ast.Template;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.ast.DeclaredParameter;
import org.eclipse.gmf.internal.xpand.expression.ast.Expression;
import org.eclipse.gmf.internal.xpand.expression.ast.Identifier;
import org.eclipse.gmf.internal.xpand.expression.ast.SyntaxElement;
import org.eclipse.gmf.internal.xpand.migration.MigrationException.Type;
import org.eclipse.gmf.internal.xpand.model.XpandAdvice;
import org.eclipse.gmf.internal.xpand.model.XpandDefinition;
import org.eclipse.gmf.internal.xpand.model.XpandResource;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.Document;
import org.eclipse.text.edits.InsertEdit;
import org.eclipse.text.edits.MalformedTreeException;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.ReplaceEdit;

public class XpandMigrationFacade {

	private ResourceManager resourceManager;

	private String resourceName;

	private boolean migrateAspect;

	private Document document;

	private MigrationExecutionContext ctx;

	private MultiTextEdit edit;

	private ModelManager modelManager;

	private TypeManager typeManager;

	public XpandMigrationFacade(ResourceManager resourceManager, String xtendResourceName, boolean migrateAspect) {
		this.resourceManager = resourceManager;
		resourceName = xtendResourceName;
		this.migrateAspect = migrateAspect;
	}

	public String migrateXpandResource() throws MigrationException {
		StringBuilder originalContent = new StringBuilder();
		try {
			if (migrateAspect) {
				throw new MigrationException(Type.UNSUPPORTED_ASPECT, "Aspect migration is not supported now");
			}
			Reader[] readers = resourceManager.resolveMultiple(resourceName, XpandResource.TEMPLATE_EXTENSION);
			assert readers.length > 0;
			Reader mainReader = readers[0];
			for (int ch = mainReader.read(); ch != -1; ch = mainReader.read()) {
				originalContent.append((char) ch);
			}
		} catch (IOException e) {
			throw new MigrationException(Type.RESOURCE_NOT_FOUND, "Unable to load resource: " + resourceName);
		}

		XpandResource xpandResource = resourceManager.loadXpandResource(resourceName);
		if (xpandResource == null) {
			throw new MigrationException(Type.RESOURCE_NOT_FOUND, "Unable to load resource: " + resourceName);
		}
		ctx = new MigrationExecutionContextImpl(resourceManager).<MigrationExecutionContext>cloneWithResource(xpandResource);
		Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
		xpandResource.analyze(ctx, issues);
		if (MigrationException.hasErrors(issues)) {
			throw new MigrationException(issues);
		}
		// TODO: decompose xpand resource here and use only first one
		if (false == xpandResource instanceof Template) {
			throw new MigrationException(Type.UNSUPPORTED_XPAND_RESOURCE, "Only Template instances are supported, but loaded: " + xpandResource);
		}
		Template xpandTemplate = (Template) xpandResource;
		document = new Document(originalContent.toString());
		edit = new MultiTextEdit();
		
		migrate(xpandTemplate);
		try {
			edit.apply(document);
		} catch (MalformedTreeException e) {
			throw new MigrationException(Type.UNABLE_TO_APPLY_EDIT, e.getMessage());
		} catch (BadLocationException e) {
			throw new MigrationException(Type.UNABLE_TO_APPLY_EDIT, e.getMessage());
		}
		return document.get();
	}

	private void migrate(Template xpandTemplate) throws MigrationException {
		StandardLibraryImports stdLibImportsManager = new StandardLibraryImports(getStdLibImportsPosition(xpandTemplate));
		modelManager = new ModelManager(stdLibImportsManager, true);
		typeManager = new TypeManager();

		for (XpandDefinition definition : xpandTemplate.getDefinitions()) {
			assert definition instanceof AbstractDefinition;
			migrateDefinition((AbstractDefinition) definition);
		}

		for (XpandAdvice advice : xpandTemplate.getAdvices()) {
			assert advice instanceof Advice;
			migrateDefinition((Advice) advice);
		}

		injectStdlibImports(stdLibImportsManager);
	}

	// TODO: use RangeMarker instead?
	private int getStdLibImportsPosition(Template xpandTemplate) {
		int offset = 0;
		if (xpandTemplate.getExtensions().length > 0) {
			ImportDeclaration[] extensions = xpandTemplate.getExtensions();
			offset = extensions[extensions.length - 1].getEndOffset();
		} else if (xpandTemplate.getImports().length > 0) {
			NamespaceImport[] imports = xpandTemplate.getImports();
			offset =  imports[imports.length - 1].getEndOffset();
		}
		if (offset > 0) {
			try {
				for (; !"»".equals(document.get(offset, 1)); offset++) {
				}
				offset++;
			} catch (BadLocationException e) {
				offset = 0;
			}
		}
		return offset;
	}

	private void injectStdlibImports(StandardLibraryImports stdLibImportsManager) {
		if (stdLibImportsManager.getLibraries().length == 0) {
			return;
		}
		StringBuilder sb = new StringBuilder();
		if (stdLibImportsManager.getPlaceholderIndex() > 0) {
			sb.append(ExpressionMigrationFacade.LF);
		}
		for (String stdLib : stdLibImportsManager.getLibraries()) {
			sb.append("«EXTENSION ");
			sb.append(stdLib);
			sb.append("»");
		}
		if (stdLibImportsManager.getPlaceholderIndex() == 0) {
			sb.append(ExpressionMigrationFacade.LF);
		}
		insert(stdLibImportsManager.getPlaceholderIndex(), sb);
	}

	private void migrateDefinition(AbstractDefinition definition) throws MigrationException {
		for (DeclaredParameter parameter : definition.getParams()) {
			migrateParameter(parameter);
		}
		
		Identifier targetType = definition.getType();
		EClassifier qvtType = ctx.getTypeForName(targetType.getValue());
		replace(targetType, typeManager.getQvtFQName(qvtType));
		
		VariableNameDispatcher variableNameDispatcher = new VariableNameDispatcher(definition);
		for (Statement statement : definition.getBody()) {
			migrateStatement(statement, variableNameDispatcher);
		}
	}

	private void migrateStatement(Statement statement, VariableNameDispatcher variableNameDispatcher) throws MigrationException {
		if (statement instanceof ExpressionStatement) {
			ExpressionStatement expressionStatement = (ExpressionStatement) statement;
			migrateExpression(expressionStatement.getExpression(), variableNameDispatcher);
		} else if (statement instanceof ErrorStatement) {
			ErrorStatement errorStatement = (ErrorStatement) statement;
			migrateExpression(errorStatement.getMessage(), variableNameDispatcher);
		} else if (statement instanceof ExpandStatement) {
			ExpandStatement expandStatement = (ExpandStatement) statement;
			for (Expression parameter : expandStatement.getParameters()) {
				migrateExpression(parameter, variableNameDispatcher);
			}
			if (expandStatement.getTarget() != null) {
				migrateExpression(expandStatement.getTarget(), variableNameDispatcher);
			}
			if (expandStatement.getSeparator() != null) {
				migrateExpression(expandStatement.getSeparator(), variableNameDispatcher);
			}
		} else if (statement instanceof FileStatement) {
			FileStatement fileStatement = (FileStatement) statement;
			migrateExpression(fileStatement.getTargetFileName(), variableNameDispatcher);
			for (Statement bodyStatement : fileStatement.getBody()) {
				migrateStatement(bodyStatement, variableNameDispatcher);
			}
		} else if (statement instanceof ForEachStatement) {
			ForEachStatement forEach = (ForEachStatement) statement;
			migrateExpression(forEach.getTarget(), variableNameDispatcher);
			if (forEach.getSeparator() != null) {
				migrateExpression(forEach.getSeparator(), variableNameDispatcher);	
			}
			for (Statement bodyStatement : forEach.getBody()) {
				migrateStatement(bodyStatement, variableNameDispatcher);
			}
		} else if (statement instanceof IfStatement) {
			IfStatement ifStatement = (IfStatement) statement;
			if (ifStatement.getCondition() != null) {
				migrateExpression(ifStatement.getCondition(), variableNameDispatcher);
			}
			for (Statement thenStatement : ifStatement.getThenPart()) {
				migrateStatement(thenStatement, variableNameDispatcher);
			}
			if (ifStatement.getElseIf() != null) {
				migrateStatement(ifStatement.getElseIf(), variableNameDispatcher);
			}
		} else if (statement instanceof LetStatement) {
			LetStatement letStatement = (LetStatement) statement;
			migrateExpression(letStatement.getVarValue(), variableNameDispatcher);
			for (Statement bodyStatement : letStatement.getBody()) {
				migrateStatement(bodyStatement, variableNameDispatcher);
			}
		}
	}

	private void migrateParameter(DeclaredParameter parameter) throws MigrationException {
		EClassifier parameterType = ctx.getTypeForName(parameter.getType().getValue());
		replace(parameter, parameter.getName().getValue() + " : " + typeManager.getQvtFQName(parameterType));
	}

	private void migrateExpression(Expression expression, VariableNameDispatcher variableNameDispatcher) throws MigrationException {
		ExpressionMigrationFacade expressionMF = new ExpressionMigrationFacade(expression, typeManager, modelManager, variableNameDispatcher, ctx);
		StringBuilder result = expressionMF.migrate();
		replace(expression, result.toString());
	}

	private void replace(SyntaxElement syntaxElement, CharSequence replacement) {
		ReplaceEdit replaceEdit = new ReplaceEdit(syntaxElement.getStartOffset(), syntaxElement.getEndOffset() + 1 - syntaxElement.getStartOffset(), replacement.toString());
		edit.addChild(replaceEdit);
	}
	
	private void insert(int position, CharSequence text) {
		InsertEdit insertEdit = new InsertEdit(position, text.toString());
		edit.addChild(insertEdit);
	}

}
@


1.13
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Definition type migration added.
@
text
@@


1.13.2.1
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - more gentle collection operations migration implemented
@
text
@a19 1
import org.eclipse.emf.ecore.EcorePackage;
d196 1
a196 2
			ExpressionAnalyzeTrace trace = ctx.getTraces().get(expressionStatement);
			migrateExpression(expressionStatement.getExpression(), trace.getResultType(), variableNameDispatcher);
d199 1
a199 1
			migrateExpression(errorStatement.getMessage(), EcorePackage.eINSTANCE.getEString(), variableNameDispatcher);
a201 4
			ExpressionAnalyzeTrace trace = ctx.getTraces().get(expandStatement);
			assert trace instanceof ExpandAnalyzeTrace;
			ExpandAnalyzeTrace expTrace = (ExpandAnalyzeTrace) trace;

d203 1
a203 1
				migrateExpression(parameter, expTrace.getParameterType(parameter), variableNameDispatcher);
d206 1
a206 1
				migrateExpression(expandStatement.getTarget(), expTrace.getResultType(), variableNameDispatcher);
d209 1
a209 1
				migrateExpression(expandStatement.getSeparator(), expTrace.getSeparatorType(), variableNameDispatcher);
d213 1
a213 1
			migrateExpression(fileStatement.getTargetFileName(), EcorePackage.eINSTANCE.getEString(), variableNameDispatcher);
d219 1
a219 4
			ExpressionAnalyzeTrace trace = ctx.getTraces().get(forEach);
			assert trace instanceof ForEachAnalyzeTrace;
			ForEachAnalyzeTrace forEachTrace = (ForEachAnalyzeTrace) trace;
			migrateExpression(forEach.getTarget(), forEachTrace.getResultType(), variableNameDispatcher);
d221 1
a221 1
				migrateExpression(forEach.getSeparator(), forEachTrace.getSeparatorType(), variableNameDispatcher);	
d229 1
a229 2
				ExpressionAnalyzeTrace trace = ctx.getTraces().get(ifStatement);
				migrateExpression(ifStatement.getCondition(), trace.getResultType(), variableNameDispatcher);
d239 1
a239 2
			ExpressionAnalyzeTrace trace = ctx.getTraces().get(letStatement);
			migrateExpression(letStatement.getVarValue(), trace.getResultType(), variableNameDispatcher);
d251 2
a252 2
	private void migrateExpression(Expression expression, EClassifier expectedExpressionType, VariableNameDispatcher variableNameDispatcher) throws MigrationException {
		ExpressionMigrationFacade expressionMF = new ExpressionMigrationFacade(expression, expectedExpressionType, typeManager, modelManager, variableNameDispatcher, ctx);
@


1.13.2.2
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - EnumLiteral .literal and .value features removed during migration
@
text
@d198 1
a198 3
			// TODO: use EcorePackage.eINSTANCE.getEString() as a type parameter
			// to convert any result type to string explicitly.
			migrateExpression(expressionStatement.getExpression(), EcorePackage.eINSTANCE.getEString(), variableNameDispatcher);
@


1.13.2.3
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Project-wide migrate action handling native extensions was added.
@
text
@a43 1
import org.eclipse.gmf.internal.xpand.util.CompositeXpandResource;
a49 1
import org.eclipse.text.edits.TextEdit;
d101 1
a101 4
		// TODO: there should be more generic way to get first definition..
		while (xpandResource instanceof CompositeXpandResource) {
			xpandResource = ((CompositeXpandResource) xpandResource).getFirstDefinition();
		}
@


1.13.2.4
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Migrating string literals in import statements
@
text
@d51 1
a128 4
		
		for (NamespaceImport namespaceImport : xpandTemplate.getImports()) {
			migrateExpression(namespaceImport.getStringLiteral(), EcorePackage.eINSTANCE.getEString(), new VariableNameDispatcher());
		}
@


1.13.2.5
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Handling OCL keywords in <<define>> name and parameter names
@
text
@a23 1
import org.eclipse.gmf.internal.xpand.ast.Definition;
a35 1
import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;
a69 2
	private OclKeywordManager oclKeywordManager;

d126 1
a126 2
		oclKeywordManager = new OclKeywordManager();
		modelManager = new ModelManager(stdLibImportsManager, oclKeywordManager, true);
d176 1
a176 4
		for (int i = 0; i < stdLibImportsManager.getLibraries().length; i++) {
			if (i > 0) {
				sb.append(ExpressionMigrationFacade.LF);	
			}
d178 1
a178 1
			sb.append(stdLibImportsManager.getLibraries()[i]);
a180 1
		
a187 3
		assert definition instanceof Definition || definition instanceof Advice;
		migrateIdentifier(definition instanceof Definition ? ((Definition) definition).getDefName() : ((Advice) definition).getPointCut());
		
a201 6
	private void migrateIdentifier(Identifier definitionName) {
		if (oclKeywordManager.isOclKeyword(definitionName)) {
			replace(definitionName, oclKeywordManager.getValidIdentifierValue(definitionName));
		}
	}

d205 3
a213 1
			migrateExpandStatementDefinition(expandStatement);
a266 16
	private void migrateExpandStatementDefinition(ExpandStatement expandStatement) {
		Identifier definition = expandStatement.getDefinition();
		String fullQualifiedDefinitionName = definition.getValue();
		int lastSeparatorIndex = fullQualifiedDefinitionName.lastIndexOf(SyntaxConstants.NS_DELIM);
		if (lastSeparatorIndex == -1) {
			migrateIdentifier(definition);
			return;
		}
		// fullName
		String namePrefix = fullQualifiedDefinitionName.substring(0, lastSeparatorIndex);
		String shortName = fullQualifiedDefinitionName.substring(lastSeparatorIndex + SyntaxConstants.NS_DELIM.length());
		if (oclKeywordManager.isOclKeyword(shortName)) {
			replace(definition, namePrefix + SyntaxConstants.NS_DELIM + oclKeywordManager.getValidIdentifierValue(shortName));
		}
	}

d269 1
a269 1
		replace(parameter, oclKeywordManager.getValidIdentifierValue(parameter.getName()) + " : " + typeManager.getQvtFQName(parameterType));
@


1.13.2.6
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
- Explicitly importing extensions re-exported from other imported extensions
@
text
@a15 2
import java.util.ArrayList;
import java.util.Arrays;
a16 1
import java.util.List;
a46 1
import org.eclipse.gmf.internal.xpand.xtend.ast.XtendResource;
a73 7
	private MigrationExecutionContext rootExecutionContext;

	public XpandMigrationFacade(ResourceManager resourceManager, String xtendResourceName, boolean migrateAspect, MigrationExecutionContext executionContext) {
		this(resourceManager, xtendResourceName, migrateAspect);
		rootExecutionContext = executionContext;
	}

d100 1
a100 1
		ctx = rootExecutionContext != null ? rootExecutionContext : new MigrationExecutionContextImpl(resourceManager).<MigrationExecutionContext> cloneWithResource(xpandResource);
d116 1
a116 1

d133 1
a133 1

d148 1
a148 1
		injectStdlibImports(stdLibImportsManager, getAdditionalLibraries(xpandTemplate));
d159 1
a159 1
			offset = imports[imports.length - 1].getEndOffset();
d173 2
a174 26
	private List<String> getAdditionalLibraries(Template xpandTemplate) {
		List<String> result = new ArrayList<String>();
		for (ImportDeclaration extension : xpandTemplate.getExtensions()) {
			XtendResource xtendResource = resourceManager.loadXtendResource(extension.getImportString().getValue());
			if (xtendResource != null) {
				result.addAll(getReexportedExtensions(xtendResource));
			}
		}
		return result;
	}

	private List<String> getReexportedExtensions(XtendResource xtendResource) {
		List<String> result = new ArrayList<String>();
		for (String extension : xtendResource.getImportedExtensions()) {
			if (xtendResource.isReexported(extension)) {
				result.add(extension);
				XtendResource extensionResource = resourceManager.loadXtendResource(extension);
				result.addAll(getReexportedExtensions(extensionResource));
			}
		}
		return result;
	}

	private void injectStdlibImports(StandardLibraryImports stdLibImportsManager, List<String> list) {
		list.addAll(Arrays.asList(stdLibImportsManager.getLibraries()));
		if (list.isEmpty()) {
d181 1
a181 1
		for (int i = 0; i < list.size(); i++) {
d183 1
a183 1
				sb.append(ExpressionMigrationFacade.LF);
d186 1
a186 1
			sb.append(list.get(i));
d189 1
a189 1

d199 1
a199 1

d203 1
a203 1

d207 1
a207 1

d256 1
a256 1
				migrateExpression(forEach.getSeparator(), forEachTrace.getSeparatorType(), variableNameDispatcher);
d314 1
a314 1

@


1.12
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Problem with infix operation migration in expand corrected.
 - Skipping analyze warnings on migration.
@
text
@d37 1
d183 4
a186 1
		// TODO: implement variable name dispatcher constructor
@


1.11
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Let statement supported
@
text
@d96 1
a96 1
		if (issues.size() > 0) {
@


1.10
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - IF statement supported
@
text
@d30 1
d233 6
@


1.9
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - ForEach statement supported
@
text
@d28 1
d221 11
@


1.8
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - File statement supported
@
text
@d27 1
a31 1
import org.eclipse.gmf.internal.xpand.ast.TextStatement;
d211 9
@


1.7
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Error and Expand statements migration with unit-tests.
@
text
@d207 4
a210 1
			throw new MigrationException(Type.UNSUPPORTED_XPAND_STATEMENT, statement.getClass().getName()); 
@


1.6
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - ModelManager for model name substitutions was added
 - OclCs class added
 - FeatureCall positions calculation corrected
 - implicit/explicit extension first parameter migration with unit-tests
@
text
@d23 2
d26 1
d31 1
d34 1
a45 1
import org.eclipse.text.edits.TextEdit;
d57 8
d91 1
a91 1
		MigrationExecutionContext ctx = new MigrationExecutionContextImpl(resourceManager).<MigrationExecutionContext>cloneWithResource(xpandResource);
a101 1

d103 3
a105 1
		TextEdit edit = migrate(xpandTemplate, ctx);
d116 1
a116 2
	private TextEdit migrate(Template xpandTemplate, MigrationExecutionContext ctx) throws MigrationException {
		MultiTextEdit edit = new MultiTextEdit();
d118 2
a119 2
		ModelManager modelManager = new ModelManager(stdLibImportsManager, true);
		TypeManager typeManager = new TypeManager();
d123 1
a123 1
			migrateDefinition((AbstractDefinition) definition, typeManager, modelManager, ctx, edit);
d125 1
a125 1
		
d128 1
a128 1
			migrateDefinition((Advice) advice, typeManager, modelManager, ctx, edit);
d130 2
a131 3
		
		injectStdlibImports(stdLibImportsManager, edit);
		return edit;
d156 1
a156 1
	private void injectStdlibImports(StandardLibraryImports stdLibImportsManager, MultiTextEdit edit) {
d172 1
a172 1
		insert(stdLibImportsManager.getPlaceholderIndex(), sb, edit);
d175 1
a175 1
	private void migrateDefinition(AbstractDefinition definition, TypeManager typeManager, ModelManager modelManager, MigrationExecutionContext ctx, MultiTextEdit edit) throws MigrationException {
d177 1
a177 1
			migrateParameter(parameter, ctx, typeManager, edit);
d180 1
d183 21
a203 2
			if (statement instanceof ExpressionStatement) {
				migrateExpressionStatement((ExpressionStatement) statement, typeManager, modelManager, variableNameDispatcher, ctx, edit);
d205 3
d211 1
a211 1
	private void migrateParameter(DeclaredParameter parameter, MigrationExecutionContext ctx, TypeManager typeManager, MultiTextEdit edit) throws MigrationException {
d213 1
a213 1
		replace(parameter, parameter.getName().getValue() + " : " + typeManager.getQvtFQName(parameterType), edit);
d216 2
a217 2
	private void migrateExpressionStatement(ExpressionStatement statement, TypeManager typeManager, ModelManager modelManager, VariableNameDispatcher variableNameDispatcher, MigrationExecutionContext ctx, MultiTextEdit edit) throws MigrationException {
		ExpressionMigrationFacade expressionMF = new ExpressionMigrationFacade(statement.getExpression(), typeManager, modelManager, variableNameDispatcher, ctx);
d219 1
a219 1
		replace(statement, result.toString(), edit);
d222 1
a222 1
	private void replace(SyntaxElement syntaxElement, CharSequence replacement, MultiTextEdit edit) {
d227 1
a227 1
	private void insert(int position, CharSequence text, MultiTextEdit edit) {
@


1.5
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Standard library function migration + tests.
@
text
@d106 1
d111 1
a111 1
			migrateDefinition((AbstractDefinition) definition, typeManager, stdLibImportsManager, ctx, edit);
d116 1
a116 1
			migrateDefinition((Advice) advice, typeManager, stdLibImportsManager, ctx, edit);
d164 1
a164 1
	private void migrateDefinition(AbstractDefinition definition, TypeManager typeManager, StandardLibraryImports stdLibManager, MigrationExecutionContext ctx, MultiTextEdit edit) throws MigrationException {
d172 1
a172 1
				migrateExpressionStatement((ExpressionStatement) statement, typeManager, stdLibManager, variableNameDispatcher, ctx, edit);
d182 2
a183 2
	private void migrateExpressionStatement(ExpressionStatement statement, TypeManager typeManager, StandardLibraryImports stdLibManager, VariableNameDispatcher variableNameDispatcher, MigrationExecutionContext ctx, MultiTextEdit edit) throws MigrationException {
		ExpressionMigrationFacade expressionMF = new ExpressionMigrationFacade(statement.getExpression(), typeManager, stdLibManager, variableNameDispatcher, ctx);
d185 1
a185 1
		replace(statement.getExpression(), result.toString(), edit);
@


1.4
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Standard library function migration + tests.
@
text
@d122 1
@


1.3
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Around parameters migration + tests.
@
text
@d24 1
a36 1
import org.eclipse.jface.text.IDocument;
d51 2
d91 1
a91 1
		IDocument document = new Document(originalContent.toString());
d123 1
d125 5
a129 1
			return xpandTemplate.getExtensions()[0].getStartOffset();
d131 8
a138 3
		if (xpandTemplate.getImports().length > 0) {
			NamespaceImport[] imports = xpandTemplate.getImports();
			return imports[imports.length - 1].getEndOffset();
d140 1
a140 1
		return 0;
d148 3
a150 1
		sb.append(ExpressionMigrationFacade.LF);
d155 3
a157 1
			sb.append(ExpressionMigrationFacade.LF);	
@


1.2
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Definition parameters migration + tests.
@
text
@d22 1
d31 1
d111 5
@


1.1
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 First step toward .xpt migration.
@
text
@d19 1
a22 1
import org.eclipse.gmf.internal.xpand.ast.ImportDeclaration;
d27 1
a27 2
import org.eclipse.gmf.internal.xpand.expression.ast.Identifier;
import org.eclipse.gmf.internal.xpand.expression.ast.StringLiteral;
d35 1
a48 5
	// private Stack<AbstractImportsManager> importsManagers = new
	// Stack<AbstractImportsManager>();
	//	
	// private StandardLibraryImports stdLibImportsManager;

d75 1
a75 1
		MigrationExecutionContext ctx = new MigrationExecutionContextImpl(resourceManager).<MigrationExecutionContext> cloneWithResource(xpandResource);
a99 5
		StandardLibraryImports stdLibImportsManager = new StandardLibraryImports(0);
		ModeltypeImports modeltypeImportsManger = new ModeltypeImports(0, true);
		TypeManager typeManager = new TypeManager(modeltypeImportsManger);

		
d101 2
a102 4
		// importsManagers.push(stdLibImportsManager = new
		// StandardLibraryImports(getOutput()));
		addLibraryImports(xpandTemplate, edit);
		addNamespaceImports(xpandTemplate, edit);
d109 1
a109 2
		addStandardLibraries(stdLibImportsManager, edit);
		addModeltypes(modeltypeImportsManger, edit);
d113 24
a136 7
	private void addModeltypes(ModeltypeImports modeltypeImportsManger, MultiTextEdit edit) {
		// TODO Auto-generated method stub
		
	}

	private void addStandardLibraries(StandardLibraryImports stdLibImportsManager, MultiTextEdit edit) {
		// TODO Auto-generated method stub
d140 4
d152 5
d160 1
a160 1
		replaceInOriginalContent(statement.getExpression(), result.toString(), edit);
d163 1
a163 27
	private void addNamespaceImports(Template xpandTemplate, MultiTextEdit edit) {
		for (NamespaceImport importDeclaration : xpandTemplate.getImports()) {
			StringLiteral importString = importDeclaration.getStringLiteral();
			replaceInOriginalContent(importString, migrateNamespaceImport(importString), edit);
		}
	}

	private StringBuilder migrateNamespaceImport(StringLiteral importString) {
		// TODO: write migration code here
		StringBuilder result = new StringBuilder("\"" + importString.getValue() + "\"");
		return result;
	}

	private void addLibraryImports(Template xpandTemplate, MultiTextEdit edit) {
		for (ImportDeclaration importDeclaration : xpandTemplate.getExtensions()) {
			Identifier importString = importDeclaration.getImportString();
			replaceInOriginalContent(importString, migrateLibraryImport(importString), edit);
		}
	}

	private StringBuilder migrateLibraryImport(Identifier importString) {
		// TODO: write migration code here
		StringBuilder result = new StringBuilder(importString.getValue());
		return result;
	}

	private void replaceInOriginalContent(SyntaxElement syntaxElement, CharSequence replacement, MultiTextEdit edit) {
d167 5
@

