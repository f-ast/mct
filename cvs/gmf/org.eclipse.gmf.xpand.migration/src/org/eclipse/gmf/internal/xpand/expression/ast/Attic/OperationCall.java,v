head	1.1;
access;
symbols
	ocl_qvt:1.1.0.2;
locks; strict;
comment	@# @;
expand	@k@;


1.1
date	2008.07.29.15.57.41;	author ashatalin;	state dead;
branches
	1.1.2.1;
next	;
commitid	33cb488f3dd14567;

1.1.2.1
date	2008.07.29.15.57.41;	author ashatalin;	state Exp;
branches;
next	1.1.2.2;
commitid	33cb488f3dd14567;

1.1.2.2
date	2008.08.06.11.05.53;	author ashatalin;	state Exp;
branches;
next	1.1.2.3;
commitid	6b3c4899858e4567;

1.1.2.3
date	2008.08.13.09.24.39;	author ashatalin;	state Exp;
branches;
next	1.1.2.4;
commitid	1f3148a2a8554567;

1.1.2.4
date	2008.08.15.11.48.33;	author ashatalin;	state Exp;
branches;
next	1.1.2.5;
commitid	373748a56d0c4567;

1.1.2.5
date	2008.08.19.15.18.37;	author ashatalin;	state Exp;
branches;
next	1.1.2.6;
commitid	32fd48aae4494567;

1.1.2.6
date	2008.08.28.15.51.00;	author ashatalin;	state Exp;
branches;
next	1.1.2.7;
commitid	35c448b6c95d4567;

1.1.2.7
date	2008.09.26.18.15.48;	author ashatalin;	state Exp;
branches;
next	1.1.2.8;
commitid	2780148dd26d24567;

1.1.2.8
date	2008.10.01.17.10.23;	author ashatalin;	state Exp;
branches;
next	;
commitid	3bbdb48e3aefd4567;


desc
@@


1.1
log
@file OperationCall.java was initially added on branch ocl_qvt.
@
text
@@


1.1.2.1
log
@Xtend-based implementation of XPand extensions was separated into .migration plugin.
@
text
@a0 307
/*
 * <copyright>
 *
 * Copyright (c) 2005-2006 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.expression.ast;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel.Operation;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.EvaluationException;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContext;
import org.eclipse.gmf.internal.xpand.expression.Variable;
import org.eclipse.gmf.internal.xpand.xtend.ast.Extension;

/**
 * @@author Sven Efftinge
 * @@author Arno Haase
 */
public class OperationCall extends FeatureCall {

    private Expression[] params;

    public OperationCall(final int start, final int end, final int line, final Identifier name,
            final Expression target, final Expression[] params) {
        super(start, end, line, name, target);
        this.params = params;
    }

    public Expression[] getParams() {
        return params;
    }

    @@Override
    public Object evaluateInternal(final ExecutionContext ctx) {

        final Object[] params = new Object[getParams().length];
        final EClassifier[] paramTypes = new EClassifier[params.length];
        for (int i = 0; i < getParams().length; i++) {
            params[i] = getParams()[i].evaluate(ctx);
            paramTypes[i] = BuiltinMetaModel.getType(params[i]);
        }
        
        Object targetObj = null;
        if (getTarget() == null) {
            // extension
            final Extension f = ctx.getExtension(getName().getValue(), paramTypes);
            if (f != null) {
				return f.evaluate(params, ctx);
			}

            // implicite
            final Variable var = ctx.getVariable(ExecutionContext.IMPLICIT_VARIABLE);
            if (var == null) {
            	// FIXME "could not find *context*, not *extension*?
				throw new EvaluationException("Couldn't find extension '" + getName().getValue()
                        + getParamTypes(params, ctx) + "'!", this);
			}
            targetObj = var.getValue();
        } else {
            targetObj = getTarget().evaluate(ctx);
        }

        // operation
        Operation op = BuiltinMetaModel.executableOperation(getName().getValue(), params, targetObj);
        if (op != null) {
			return op.evaluate();
		}
        // extension as members
        EClassifier[] ps = new EClassifier[paramTypes.length + 1];
        ps[0] = BuiltinMetaModel.getType(targetObj);
        System.arraycopy(paramTypes, 0, ps, 1, paramTypes.length);
        Extension f = ctx.getExtension(getName().getValue(), ps);
        if (f != null) {
            try {
            	Object[] paramsAll = new Object[params.length + 1];
            	paramsAll[0] = targetObj;
            	System.arraycopy(params, 0, paramsAll, 1, params.length);
                return f.evaluate(paramsAll, ctx);
            } finally {

            }
        }

        if (targetObj instanceof Collection) {
            final List<Object> result = new ArrayList<Object>();
            final Collection col = (Collection) targetObj;
            for (final Iterator iter = col.iterator(); iter.hasNext();) {
                final Object element = iter.next();
                // operation
                op = BuiltinMetaModel.executableOperation(getName().getValue(), params, element);
                if (op != null) {
                    final Object r = op.evaluate();
                    if (r instanceof Collection) {
                        result.addAll((Collection<?>) r);
                    } else {
                        result.add(r);
                    }
                } else {
                    // extension as members
                    ps = new EClassifier[paramTypes.length + 1];
                    ps[0] = BuiltinMetaModel.getType(element);
                    System.arraycopy(paramTypes, 0, ps, 1, paramTypes.length);
                    f = ctx.getExtension(getName().getValue(), ps);
                    if (f != null) {
                    	Object[] paramsAll = new Object[params.length + 1];
                    	paramsAll[0] = element;
                    	System.arraycopy(params, 0, paramsAll, 1, params.length);
                        final Object r = f.evaluate(paramsAll, ctx);
                        if (r instanceof Collection) {
                            result.addAll((Collection<?>) r);
                        } else {
                            result.add(r);
                        }
                    } else {
						throw new EvaluationException("Couldn't find operation '" + getName().getValue()
                                + getParamTypes(params, ctx) + "' for " + BuiltinMetaModel.getType(targetObj).getName() + "!", this);
					}
                }
            }
            return result;
        }

        if ((targetObj != null) && (f == null) && (op == null)) {
			throw new EvaluationException("Couldn't find operation '" + getName().getValue()
                    + getParamTypes(params, ctx) + "' for " + BuiltinMetaModel.getType(targetObj).getName() + ".", this);
		} else {
			return null;
		}

    }

    @@Override
    public EClassifier analyze(final ExecutionContext ctx, final Set<AnalysationIssue> issues) {
        final EClassifier[] paramTypes = new EClassifier[getParams().length];
        for (int i = 0; i < getParams().length; i++) {
            paramTypes[i] = getParams()[i].analyze(ctx, issues);
            if (paramTypes[i] == null) {
				return null;
			}
        }

        // extension
        EClassifier targetType = null;
        if (getTarget() == null) {
        	Extension f = null;
            try {
                f = ctx.getExtension(getName().getValue(), paramTypes);
            } catch (final Exception e) {
                issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR, "Error parsing extensions : "
                        + e.getMessage(), this));
            }
            if (f != null) {
				return f.getReturnType(paramTypes, ctx, issues);
			}
            final Variable var = ctx.getVariable(ExecutionContext.IMPLICIT_VARIABLE);
            if (var != null) {
                targetType = (EClassifier) var.getValue();
            } else {
            	// FIXME could not find *this*
                issues.add(new AnalysationIssue(AnalysationIssue.Type.FEATURE_NOT_FOUND, "Couldn't find extensions : "
                        + toString(), this));
            }
        } else {
            targetType = getTarget().analyze(ctx, issues);
        }
        if (targetType == null) {
			return null;
		}
        // operation
        EOperation op = BuiltinMetaModel.findOperation(targetType, getName().getValue(), paramTypes);
        if (op != null) {
			return op.getEType() == null ? BuiltinMetaModel.VOID : BuiltinMetaModel.getTypedElementType(op);
		}
        // extension as members
        final int issueSize = issues.size();
        EClassifier rt = getExtensionsReturnType(ctx, issues, paramTypes, targetType);
        if (rt != null) {
			return rt;
		} else if (issueSize < issues.size()) {
			return null;
		}
        String additionalMsg = "";
        if (BuiltinMetaModel.isParameterizedType(targetType)) {
            final EClassifier innerType = BuiltinMetaModel.getInnerType(targetType);
            op = BuiltinMetaModel.findOperation(innerType, getName().getValue(), paramTypes);
            if (op != null) {
                rt = op.getEType() == null ? BuiltinMetaModel.VOID : op.getEType();
                if (BuiltinMetaModel.isParameterizedType(rt)) {
                    rt = BuiltinMetaModel.getInnerType(rt);
                }
                return BuiltinMetaModel.getListType(rt);
            }
            rt = getExtensionsReturnType(ctx, issues, paramTypes, innerType);
            if (rt != null) {
				return BuiltinMetaModel.getListType(rt);
			}
            additionalMsg = " or type '" + innerType + "'";
        }

        issues.add(new AnalysationIssue(AnalysationIssue.Type.FEATURE_NOT_FOUND, "Couldn't find operation '"
                + getName().getValue() + getParamsString(paramTypes) + "' for type '" + targetType.getName() + "'"
                + additionalMsg, this));
        return null;

    }

    private EClassifier getExtensionsReturnType(final ExecutionContext ctx, final Set<AnalysationIssue> issues, final EClassifier[] paramEClassifiers,
            final EClassifier targetEClassifier) {
        final EClassifier[] pts = new EClassifier[paramEClassifiers.length + 1];
        pts[0] = targetEClassifier;
        System.arraycopy(paramEClassifiers, 0, pts, 1, paramEClassifiers.length);
        Extension f = null;
        try {
            f = ctx.getExtension(getName().getValue(), pts);
        } catch (final Exception e) {
            issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR, "Error parsing extensions : "
                    + e.getMessage(), this));
        }
        if (f != null) {
            final Set<AnalysationIssue> temp = new HashSet<AnalysationIssue>();
            final EClassifier rt = f.getReturnType(pts, ctx, temp);
            if (rt == null) {
                issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR,
                        "couldn't resolve return type for extension " + f + "! Errors : " + temp.toString(), this));
            }
            return rt;
        } else if (getTarget() == null) { // try without implicite this
            try {
                f = ctx.getExtension(getName().getValue(), paramEClassifiers);
            } catch (final Exception e) {
                issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR, "Error parsing extensions : "
                        + e.getMessage(), this));
            }
            if (f != null) {
                final Set<AnalysationIssue> temp = new HashSet<AnalysationIssue>();
                // TODO: Use paramEClassifiers instead of pts here?
                final EClassifier rt = f.getReturnType(pts, ctx, temp);
                if (rt == null) {
                    issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR,
                            "couldn't resolve return type for extension " + f + "! Errors : " + temp.toString(), this));
                }
                return rt;
            }
        }
        return null;
    }

    private String getParamTypes(final Object[] params2, final ExecutionContext ctx) {
        final StringBuffer buff = new StringBuffer("(");
        for (int i = 0; i < params2.length; i++) {
            final EClassifier type = BuiltinMetaModel.getType(params2[i]);
            buff.append(type.getName());
            if (i + 1 < params2.length) {
                buff.append(",");
            }
        }
        return buff.append(")").toString();
    }

    private String getParamsString(final EClassifier[] paramTypes) {
        final StringBuffer buff = new StringBuffer("(");
        for (int i = 0; i < paramTypes.length; i++) {
            final EClassifier type = paramTypes[i];
            buff.append(type.getName());
            if (i + 1 < paramTypes.length) {
                buff.append(",");
            }
        }
        return buff.append(")").toString();
    }

    @@Override
    public String toString() {
        return (getTarget() != null ? getTarget().toString() + "." : "") + getName()
                + getParamsExpressionString(getParams());
    }

    private String getParamsExpressionString(final Expression[] params2) {
        final StringBuffer buff = new StringBuffer("(");
        for (int i = 0; i < params2.length; i++) {
            buff.append(params2[i]);
            if (i + 1 < params2.length) {
                buff.append(",");
            }
        }
        return buff.append(")").toString();
    }
}
@


1.1.2.2
log
@Copyrights updated.
@
text
@d4 1
a4 1
 * Copyright (c) 2005-2008 Sven Efftinge and others.
a11 1
 *     Alexander Shatalin (Borland)
@


1.1.2.3
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Correctly transforming collection types on implicit collect operations for OperationCall expression + unit-tests.
@
text
@a24 1
import org.eclipse.emf.ecore.EClass;
a32 2
import org.eclipse.gmf.internal.xpand.migration.OperationCallTrace;
import org.eclipse.gmf.internal.xpand.migration.OperationCallTrace.Type;
a157 1
            	createAnalyzeTrace(ctx, new OperationCallTrace(null, Type.UNDESOLVED_PARAMETER_TYPE));
d173 1
a173 3
				EClassifier result = f.getReturnType(paramTypes, ctx, issues);
				createAnalyzeTrace(ctx, new OperationCallTrace(result, Type.STATIC_EXTENSION_REF));
				return result;
a186 1
        	createAnalyzeTrace(ctx, new OperationCallTrace(null, Type.UNDESOLVED_TARGET_TYPE));
d192 1
a192 3
			EClassifier result = op.getEType() == null ? BuiltinMetaModel.VOID : BuiltinMetaModel.getTypedElementType(op);
			createAnalyzeTrace(ctx, new OperationCallTrace(result, op));
			return result;
a197 2
        	// [AS] This can be only "contextual" extension call - see comment below. 
        	createAnalyzeTrace(ctx, new OperationCallTrace(rt, Type.EXTENSION_REF));
d211 1
a211 3
                EClass result = BuiltinMetaModel.getListType(rt);
                createAnalyzeTrace(ctx, new OperationCallTrace(result, targetType, op));
                return result;
d215 1
a215 3
            	EClass result = BuiltinMetaModel.getListType(rt);
            	createAnalyzeTrace(ctx, new OperationCallTrace(result, targetType));
				return result;
a247 2
			// [AS]: looks like this case was already covered while looking for
			// static extension if target == null, so skipping it in a migration
@


1.1.2.4
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Supporting collection operation calls.
@
text
@d200 1
a200 1
			createAnalyzeTrace(ctx, new OperationCallTrace(result, targetType, op, paramTypes));
d223 1
a223 1
                createAnalyzeTrace(ctx, new OperationCallTrace(result, targetType, op, OperationCallTrace.Type.IMPLICIT_COLLECT_OPERATION_REF));
@


1.1.2.5
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 Transforming Collection type on CollectionExpression migration.
@
text
@d25 1
d161 2
a162 1
            	return createAnalyzeTrace(ctx, new OperationCallTrace(null, Type.UNDESOLVED_PARAMETER_TYPE));
d177 3
a179 1
				return createAnalyzeTrace(ctx, new OperationCallTrace(f.getReturnType(paramTypes, ctx, issues), Type.STATIC_EXTENSION_REF));
d193 2
a194 1
        	return createAnalyzeTrace(ctx, new OperationCallTrace(null, Type.UNDESOLVED_TARGET_TYPE));
d199 3
a201 1
			return createAnalyzeTrace(ctx, new OperationCallTrace(op.getEType() == null ? BuiltinMetaModel.VOID : BuiltinMetaModel.getTypedElementType(op), targetType, op, paramTypes));
d208 2
a209 1
        	return createAnalyzeTrace(ctx, new OperationCallTrace(rt, Type.EXTENSION_REF));
d222 3
a224 1
                return createAnalyzeTrace(ctx, new OperationCallTrace(BuiltinMetaModel.getListType(rt), targetType, op, OperationCallTrace.Type.IMPLICIT_COLLECT_OPERATION_REF));
d228 3
a230 1
            	return createAnalyzeTrace(ctx, new OperationCallTrace(BuiltinMetaModel.getListType(rt), targetType));
@


1.1.2.6
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 First step toward .xpt migration.
@
text
@d45 1
a45 1
    public OperationCall(final int start, final int end, final int line, final int startOffset, final int endOffset, final Identifier name,
d47 1
a47 1
        super(start, end, line, startOffset, endOffset, name, target);
@


1.1.2.7
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - more gentle collection operations migration implemented
@
text
@a24 1
import org.eclipse.emf.common.util.EList;
a26 1
import org.eclipse.emf.ecore.EParameter;
d160 1
a160 1
            	return createAnalyzeTrace(ctx, new OperationCallTrace(null, null, Type.UNDESOLVED_PARAMETER_TYPE));
d175 1
a175 1
				return createAnalyzeTrace(ctx, new OperationCallTrace(f.getReturnType(paramTypes, ctx, issues), getParamTypes(f, ctx), Type.STATIC_EXTENSION_REF));
d189 1
a189 1
        	return createAnalyzeTrace(ctx, new OperationCallTrace(null, null, Type.UNDESOLVED_TARGET_TYPE));
d194 1
a194 1
			return createAnalyzeTrace(ctx, new OperationCallTrace(op.getEType() == null ? BuiltinMetaModel.VOID : BuiltinMetaModel.getTypedElementType(op), getParamTypes(op), targetType, op));
d198 1
a198 3
        
        Extension extension = getStaticExtension(ctx, issues, paramTypes, targetType);
        EClassifier rt = getExtensionReturnType(extension, ctx, issues, paramTypes, targetType);
d201 1
a201 1
        	return createAnalyzeTrace(ctx, new OperationCallTrace(rt, getParamTypes(extension, ctx), Type.EXTENSION_REF));
d214 1
a214 1
                return createAnalyzeTrace(ctx, new OperationCallTrace(BuiltinMetaModel.getListType(rt), getParamTypes(op), targetType, op, OperationCallTrace.Type.IMPLICIT_COLLECT_OPERATION_REF));
d216 1
a216 2
            extension = getStaticExtension(ctx, issues, paramTypes, innerType);
            rt = getExtensionReturnType(extension, ctx, issues, paramTypes, innerType);
d218 1
a218 4
                if (BuiltinMetaModel.isParameterizedType(rt)) {
                    rt = BuiltinMetaModel.getInnerType(rt);
                }
            	return createAnalyzeTrace(ctx, new OperationCallTrace(BuiltinMetaModel.getListType(rt), getParamTypes(extension, ctx), targetType));
d230 1
a230 39
    private List<EClassifier> getParamTypes(EOperation op) {
    	EList<EParameter> parameters = op.getEParameters();
    	List<EClassifier> result = new ArrayList<EClassifier>();
    	for (int i = 0; i < parameters.size(); i++) {
    		result.add(BuiltinMetaModel.getTypedElementType(parameters.get(i)));
    	}
		return result;
	}

	private List<EClassifier> getParamTypes(Extension f, ExecutionContext ctx) {
		List<DeclaredParameter> formalParameters = f.getFormalParameters();
		List<EClassifier> result = new ArrayList<EClassifier>();
		for (int i = 0; i < formalParameters.size(); i++) {
			result.add(ctx.getTypeForName(formalParameters.get(i).getType().getValue()));
		}
		return result;
	}
	
	private EClassifier getExtensionReturnType(Extension extension, ExecutionContext ctx, Set<AnalysationIssue> issues, EClassifier[] paramEClassifiers, EClassifier targetEClassifier) {
		if (extension == null) {
			return null;
		}
		EClassifier[] pts = getStaticCallParameters(targetEClassifier, paramEClassifiers);
		Set<AnalysationIssue> temp = new HashSet<AnalysationIssue>();
		EClassifier rt = extension.getReturnType(pts, ctx, temp);
		if (rt == null) {
			issues.add(new AnalysationIssue(AnalysationIssue.Type.INTERNAL_ERROR, "couldn't resolve return type for extension " + extension + "! Errors : " + temp.toString(), this));
		}
		return rt;
	}

	private EClassifier[] getStaticCallParameters(EClassifier targetEClassifier, EClassifier[] paramEClassifiers) {
		EClassifier[] pts = new EClassifier[paramEClassifiers.length + 1];
		pts[0] = targetEClassifier;
		System.arraycopy(paramEClassifiers, 0, pts, 1, paramEClassifiers.length);
		return pts;
	}

	private Extension getStaticExtension(final ExecutionContext ctx, final Set<AnalysationIssue> issues, final EClassifier[] paramEClassifiers,
d232 3
a234 1
        final EClassifier[] pts = getStaticCallParameters(targetEClassifier, paramEClassifiers);
d243 7
a249 1
            return f;
d259 10
a268 1
            return f;
d273 1
a273 1
	private String getParamTypes(final Object[] params2, final ExecutionContext ctx) {
@


1.1.2.8
log
@[243157] - Develop automatic migration tool creating QVTO/OCL constructions having Xtend as an input
 - Native library migration code added.
@
text
@d25 1
d28 1
d162 1
a162 1
            	return createAnalyzeTrace(ctx, new OperationCallTrace(Type.UNDESOLVED_PARAMETER_TYPE));
d177 1
a177 2
				return createAnalyzeTrace(ctx, new OperationCallTrace(f.getReturnType(paramTypes, ctx, issues), OperationCallTrace.getParamTypes(f, ctx), OperationCallTrace.getNativeLibraryName(f),
						Type.STATIC_EXTENSION_REF));
d191 1
a191 1
        	return createAnalyzeTrace(ctx, new OperationCallTrace(Type.UNDESOLVED_TARGET_TYPE));
d196 1
a196 1
			return createAnalyzeTrace(ctx, new OperationCallTrace(op.getEType() == null ? BuiltinMetaModel.VOID : BuiltinMetaModel.getTypedElementType(op), OperationCallTrace.getParamTypes(op), targetType, op));
d205 1
a205 1
        	return createAnalyzeTrace(ctx, new OperationCallTrace(rt, OperationCallTrace.getParamTypes(extension, ctx), OperationCallTrace.getNativeLibraryName(extension), Type.EXTENSION_REF));
d218 1
a218 1
                return createAnalyzeTrace(ctx, new OperationCallTrace(BuiltinMetaModel.getListType(rt), OperationCallTrace.getParamTypes(op), targetType, op, OperationCallTrace.Type.IMPLICIT_COLLECT_OPERATION_REF));
d226 1
a226 1
            	return createAnalyzeTrace(ctx, new OperationCallTrace(BuiltinMetaModel.getListType(rt), OperationCallTrace.getParamTypes(extension, ctx), targetType, OperationCallTrace.getNativeLibraryName(extension)));
d238 18
@


