head	1.3;
access;
symbols
	v20081020-0700:1.3
	v20081015-1925:1.3
	v20081015-1755:1.3
	v20081008-1925:1.3
	v20081008-1755:1.3
	v20080903-1520:1.3
	v20080903-1510:1.3
	v20080807-1333:1.3
	v20080807-1325:1.3
	v20080731-1520:1.3
	v20080725-1738:1.3
	v20080722-1827:1.3
	R2_1_maintenance:1.3.0.2
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080425-1959:1.3
	v20080328-1605:1.3
	v20080222-1200:1.3
	v20080107-1111:1.3
	v20071214-1111:1.3
	v20071130-1111:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070915-0000:1.2.4.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.4
	R2_0:1.2
	R4_20:1.2
	RC3_20:1.2
	v20070601-1400:1.2
	v20070518-1300:1.2
	bugzilla111892_group_support:1.2.0.2
	Root_bugzilla111892_group_support:1.2
	v20070420-1000:1.2
	v20070405-2000:1.2
	v20070330-1300:1.2
	v20070208-1800:1.2
	M4_20:1.2
	v20061214-0000:1.2
	M3_20:1.2
	v20061027-1200:1.1.2.2
	v20061013-1330:1.2
	v20060919-0800:1.1.2.2
	v20060907-1100:1.1.2.2
	v20060831-1500:1.1.2.2
	v20060817-1500:1.1.2.1
	R1_0_maintenance:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2007.09.13.17.19.35;	author ahunter;	state Exp;
branches;
next	1.2;
commitid	21d946e971264567;

1.2
date	2006.10.03.15.01.44;	author ahunter;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2006.08.11.18.39.07;	author ldamus;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.08.11.18.39.07;	author ldamus;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.08.28.20.36.13;	author ldamus;	state Exp;
branches;
next	;

1.2.4.1
date	2007.09.13.17.17.06;	author ahunter;	state Exp;
branches;
next	1.2.4.2;
commitid	176846e970924567;

1.2.4.2
date	2007.09.13.17.19.19;	author ahunter;	state Exp;
branches;
next	;
commitid	1e1446e971174567;


desc
@@


1.3
log
@[203321] gmf_head ahunter 070913 AssertionException in RemoveBookmarksAdvice
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/
package org.eclipse.gmf.runtime.diagram.core.edithelpers;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.resources.IBookmark;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.commands.RemoveBookmarkCommand;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramDebugOptions;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramPlugin;
import org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditHelperAdvice;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyDependentsRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest;

/**
 * Edit helper advice that provides commands to remove associated bookmarks 
 * of all dependents as well as the main destructee.
 * 
 * @@author satif
 */

public class RemoveBookmarksAdvice extends AbstractEditHelperAdvice {

	/**
	 * @@param bookmarkedObject	the <code>EObject</code> to retrieve bookmarks for
	 * @@param fileResourceMap cache of EResource to IFile (avoids repeatedly finding IFile for EResource)
	 * @@return <code>Set</code> of <code>IMarker</code>s related to the <b>bookmarkedObject</b>
	 */
	private Set gatherSingleBookmark(EObject bookmarkedObject, Map fileResourceMap) {
		Resource eResource = null;
		
		if (bookmarkedObject == null || (eResource = bookmarkedObject.eResource()) == null)
			return null;
		
		IResource resource = null;
		
		if (fileResourceMap.containsKey(eResource))
			resource = (IFile)fileResourceMap.get(eResource);
		else {
			resource = WorkspaceSynchronizer.getFile(eResource);
			fileResourceMap.put(eResource, resource);
		}
		
		if (resource == null)
			return null;
		
		String elementID = ((XMLResource)eResource).getID(bookmarkedObject);
		
		IMarker[] bookmarks = new IMarker[0];
		
		try {
			bookmarks = resource.findMarkers(IBookmark.TYPE, true,
				IResource.DEPTH_INFINITE);
		} catch (CoreException e) {
			Trace.catching(DiagramPlugin.getInstance(), DiagramDebugOptions.EXCEPTIONS_CATCHING, 
					getClass(), "gatherSingleBookmark", e); //$NON-NLS-1$
			Log.error(DiagramPlugin.getInstance(), IStatus.ERROR, "gatherSingleBookmark"); //$NON-NLS-1$
		}
		
		Set retSet = new HashSet();

		for (int i = 0; i < bookmarks.length; i++) {
			
			IMarker bookmark = bookmarks[i];
			
			String bookmarkElementID = bookmark.getAttribute(IBookmark.ELEMENT_ID,StringStatics.BLANK);
			
			if (elementID.equals(bookmarkElementID))				
				retSet.add(bookmark);
		}
		
		return retSet;
	}
	
	/**
	 * @@param bookmarkedObjects the <code>Set</code> of <code>EObject</code>s to retrieve bookmarks for
	 * @@param fileResourceMap cache of EResource to IFile (avoids repeatedly finding IFile for EResource)
	 * @@return <code>Set</code> of <code>IMarker</code>s related to the <b>bookmarkedObjects</b>
	 */
	private Set gatherAllBookmarks(Set bookmarkedObjects, HashMap fileResourceMap) {
		
		Iterator iterBObjects = bookmarkedObjects.iterator();
		
		Set retSet = new HashSet();
		
		while (iterBObjects.hasNext()) {
			Object oElement = iterBObjects.next();
			
			if (oElement instanceof EObject) {
				Set tempSet = gatherSingleBookmark((EObject)oElement, fileResourceMap);
				if (tempSet != null) {
					retSet.addAll(tempSet);
				}
			}
		}
		
		return retSet;
	}
	
	
	public ICommand getBeforeEditCommand(IEditCommandRequest request) {		
		return null;
	}
	
	public ICommand getAfterEditCommand(IEditCommandRequest request) {
		if (request instanceof DestroyElementRequest) {
			return getAfterDestroyElementCommand((DestroyElementRequest) request);
		}
		return null;
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditHelperAdvice#getAfterDestroyElementCommand(org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest)
	 */
	protected ICommand getAfterDestroyElementCommand(DestroyElementRequest request) {

		ICommand result = null;
		
		Object oInitialDestructee = request.getParameter(DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER);
		
		if (oInitialDestructee != null && 
			oInitialDestructee instanceof EObject && 
			request.getElementToDestroy().equals(oInitialDestructee)) {
			
			Object oDependentElements = request.getParameter(DestroyElementRequest.DESTROY_DEPENDENTS_REQUEST_PARAMETER);
			
			if (oDependentElements == null)
				return null;
			
			HashMap fileResourceMap = new HashMap();
			Set	bookmarksItems = gatherAllBookmarks(
					((DestroyDependentsRequest)oDependentElements).getDependentElementsToDestroy(), fileResourceMap),
				bookmarksDestructee = gatherSingleBookmark(request.getElementToDestroy(), fileResourceMap);
			
			if (bookmarksDestructee != null) 
				bookmarksItems.addAll(bookmarksDestructee);
			
			if (!bookmarksItems.isEmpty()) {
				result = new RemoveBookmarkCommand(request.getEditingDomain(),
								request.getLabel(), bookmarksItems);
			}
			
		}
		
		return result;
	}
	
	
	
}
@


1.2
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
d76 1
a76 1
		IMarker[] bookmarks = null;
a85 1
		Assert.isNotNull(bookmarks);
@


1.2.4.1
log
@[203321] gmf_R2_0_maintenance ahunter 070913 AssertionException in RemoveBookmarksAdvice
@
text
@d76 1
a76 1
		IMarker[] bookmarks = new IMarker[0];
d86 1
@


1.2.4.2
log
@[203321] gmf_R2_0_maintenance ahunter 070913 AssertionException in RemoveBookmarksAdvice
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
@


1.1
log
@file RemoveBookmarksAdvice.java was initially added on branch R1_0_maintenance.
@
text
@d1 178
@


1.1.2.1
log
@[150982] gmf_R1_0_maintenance syedatif 060811 Bookmark view not sync with diagram eidtor
@
text
@a0 165
/******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/
package org.eclipse.gmf.runtime.diagram.core.edithelpers;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.resources.IBookmark;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.commands.RemoveBookmarkCommand;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramDebugOptions;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramPlugin;
import org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditHelperAdvice;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyDependentsRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest;

/**
 * Edit helper advice that provides commands to remove associated bookmarks 
 * of all dependents as well as the main destructee.
 * 
 * @@author satif
 */

public class RemoveBookmarksAdvice extends AbstractEditHelperAdvice {

	/**
	 * @@param bookmarkedObject	the <code>EObject</code> to retrieve bookmarks for
	 * @@param fileResourceMap cache of EResource to IFile (avoids repeatedly finding IFile for EResource)
	 * @@return <code>Set</code> of <code>IMarker</code>s related to the <b>bookmarkedObject</b>
	 */
	private Set gatherSingleBookmark(EObject bookmarkedObject, Map fileResourceMap) {
		Resource eResource = null;
		
		if (bookmarkedObject == null || (eResource = bookmarkedObject.eResource()) == null)
			return null;
		
		IResource resource = null;
		
		if (fileResourceMap.containsKey(eResource))
			resource = (IFile)fileResourceMap.get(eResource);
		else {
			resource = (IFile)WorkspaceSynchronizer.getFile(eResource);
			fileResourceMap.put(eResource, resource);
		}
		
		if (resource == null)
			return null;
		
		String elementID = ((XMLResource)eResource).getID(bookmarkedObject);
		
		IMarker[] bookmarks = null;
		
		try {
			bookmarks = resource.findMarkers(IBookmark.TYPE, true,
				IResource.DEPTH_INFINITE);
		} catch (CoreException e) {
			Trace.catching(DiagramPlugin.getInstance(), DiagramDebugOptions.EXCEPTIONS_CATCHING, 
					getClass(), "gatherSingleBookmark", e); //$NON-NLS-1$
			Log.error(DiagramPlugin.getInstance(), IStatus.ERROR, "gatherSingleBookmark"); //$NON-NLS-1$
		}
		Assert.isNotNull(bookmarks);
		
		Set retSet = new HashSet();

		for (int i = 0; i < bookmarks.length; i++) {
			
			IMarker bookmark = (IMarker) bookmarks[i];
			
			String bookmarkElementID = bookmark.getAttribute(IBookmark.ELEMENT_ID,StringStatics.BLANK);
			
			if (elementID.equals(bookmarkElementID))				
				retSet.add(bookmark);
		}
		
		return retSet;
	}
	
	/**
	 * @@param bookmarkedObjects the <code>Set</code> of <code>EObject</code>s to retrieve bookmarks for
	 * @@param fileResourceMap cache of EResource to IFile (avoids repeatedly finding IFile for EResource)
	 * @@return <code>Set</code> of <code>IMarker</code>s related to the <b>bookmarkedObjects</b>
	 */
	private Set gatherAllBookmarks(Set bookmarkedObjects, HashMap fileResourceMap) {
		
		Iterator iterBObjects = bookmarkedObjects.iterator();
		
		Set retSet = new HashSet();
		
		while (iterBObjects.hasNext()) {
			Object oElement = iterBObjects.next();
			
			if (oElement instanceof EObject) {
				Set tempSet = gatherSingleBookmark((EObject)oElement, fileResourceMap);
				if (tempSet != null) {
					retSet.addAll(tempSet);
				}
			}
		}
		
		return retSet;
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditHelperAdvice#getAfterDestroyElementCommand(org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest)
	 */
	protected ICommand getAfterDestroyElementCommand(DestroyElementRequest request) {

		ICommand result = null;
		
		Object oInitialDestructee = request.getParameter(DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER);
		
		if (oInitialDestructee != null && 
			oInitialDestructee instanceof EObject && 
			request.getElementToDestroy().equals((EObject)oInitialDestructee)) {
			
			Object oDependentElements = request.getParameter(DestroyElementRequest.DESTROY_DEPENDENTS_REQUEST_PARAMETER);
			
			if (oDependentElements == null)
				return null;
			
			HashMap fileResourceMap = new HashMap();
			Set	bookmarksItems = gatherAllBookmarks(
					(Set)((DestroyDependentsRequest)oDependentElements).getDependentElementsToDestroy(), fileResourceMap),
				bookmarksDestructee = gatherSingleBookmark(request.getElementToDestroy(), fileResourceMap);
			
			if (bookmarksDestructee != null) 
				bookmarksItems.addAll(bookmarksDestructee);
			
			if (!bookmarksItems.isEmpty()) {
				result = new RemoveBookmarkCommand(request.getEditingDomain(),
								request.getLabel(), bookmarksItems);
			}
			
		}
		
		return result;
	}
	
	
	
}
@


1.1.2.2
log
@[155233] gmf_R1_0_maintenance ylulu 060828 Deleting and element using the EditHelpers could be enhanced
@
text
@a39 1
import org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest;
d66 1
a66 1
			resource = WorkspaceSynchronizer.getFile(eResource);
d91 1
a91 1
			IMarker bookmark = bookmarks[i];
a126 12
	
	public ICommand getBeforeEditCommand(IEditCommandRequest request) {		
		return null;
	}
	
	public ICommand getAfterEditCommand(IEditCommandRequest request) {
		if (request instanceof DestroyElementRequest) {
			return getAfterDestroyElementCommand((DestroyElementRequest) request);
		}
		return null;
	}
	
d138 1
a138 1
			request.getElementToDestroy().equals(oInitialDestructee)) {
d147 1
a147 1
					((DestroyDependentsRequest)oDependentElements).getDependentElementsToDestroy(), fileResourceMap),
@


