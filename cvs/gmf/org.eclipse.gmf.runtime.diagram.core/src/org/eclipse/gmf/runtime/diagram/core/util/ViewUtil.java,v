head	1.21;
access;
symbols
	v20081020-0700:1.21
	v20081015-1925:1.21
	v20081015-1755:1.18.2.3
	v20081008-1925:1.21
	v20081008-1755:1.18.2.3
	v20080903-1520:1.21
	v20080903-1510:1.18.2.3
	v20080807-1333:1.20
	v20080807-1325:1.18.2.2
	v20080731-1520:1.19
	v20080725-1738:1.18.2.1
	v20080722-1827:1.18
	R2_1_maintenance:1.18.0.2
	Root_R2_1_maintenance:1.18
	R2_1_0:1.18
	v20080425-1959:1.18
	v20080328-1605:1.18
	v20080222-1200:1.18
	v20080107-1111:1.18
	v20071214-1111:1.18
	v20071130-1111:1.18
	v20071108-0000:1.18
	v20071003-0000:1.17
	v20070915-0000:1.17
	v20070809-0000:1.17
	R2_0_maintenance:1.17.0.4
	R2_0:1.17
	R4_20:1.17
	RC3_20:1.17
	v20070601-1400:1.17
	v20070518-1300:1.17
	bugzilla111892_group_support:1.17.0.2
	Root_bugzilla111892_group_support:1.17
	v20070420-1000:1.16
	v20070405-2000:1.16
	v20070330-1300:1.16
	v20070208-1800:1.16
	M4_20:1.16
	v20061214-0000:1.16
	M3_20:1.16
	v20061027-1200:1.15.2.4
	v20061013-1330:1.16
	v20060919-0800:1.15.2.4
	v20060907-1100:1.15.2.3
	M1_20:1.15
	v20060831-1500:1.15.2.3
	v20060817-1500:1.15.2.3
	v20060810-1700:1.15.2.3
	v20060803-1200:1.15.2.3
	v20060728-0500:1.15.2.2
	v20060721-1130:1.15.2.1
	v20060713-1700:1.15
	R1_0_maintenance:1.15.0.2
	R1_0:1.15
	v20060627-1200:1.15
	v20060616-1200:1.15
	v20060609-1400:1.15
	v20060531-1730:1.15
	v20060519-0800:1.15
	v20060512-1000:1.15
	I20060512-1000:1.15
	I20060505-1400:1.14
	I20060428-1300:1.13
	I20060424-0500:1.13
	I20060424-0300:1.13
	M6_10:1.13
	I20060407-1200:1.13
	I20060331-1000:1.13
	I20060324-0300:1.13
	I20060317-1300:1.11
	I20060317-1200:1.11
	I20060316-1300:1.11
	I20060309-1300:1.11
	M5_10:1.9
	S20060303-1600:1.9
	I20060227-1730:1.8
	I20060216-1945:1.8
	I20060210-1715:1.7
	I20060209-1815:1.7
	I20060203-0830:1.7
	I20060129-1145:1.7
	I20060127-0900:1.7
	I20060120-1530:1.7
	I20060113-1700:1.7
	M4_10:1.7
	I20060107-1100:1.7
	I20060105-1630:1.7
	I20051230-1230:1.7
	I20051223-1100:1.7
	I20051217-0925:1.7
	I20051201-1800:1.7
	I20051124-2000:1.6
	M3_10:1.6
	I20051118-1245:1.6
	I20051111-1800:1.6
	I20051106-0900:1.6
	v20051030:1.6;
locks; strict;
comment	@# @;


1.21
date	2008.08.27.20.50.30;	author ldamus;	state Exp;
branches;
next	1.20;
commitid	348048b5be164567;

1.20
date	2008.08.07.16.36.16;	author ahunter;	state Exp;
branches;
next	1.19;
commitid	458c489b24804567;

1.19
date	2008.07.25.21.40.41;	author aboyko;	state Exp;
branches;
next	1.18;
commitid	45df488a48594567;

1.18
date	2007.11.02.21.03.39;	author aboyko;	state Exp;
branches
	1.18.2.1;
next	1.17;
commitid	7624472b90aa4567;

1.17
date	2007.05.17.16.26.38;	author aboyko;	state Exp;
branches;
next	1.16;
commitid	716a464c823d4567;

1.16
date	2006.10.03.15.01.44;	author ahunter;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.09.19.45.09;	author cmahoney;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2006.04.28.21.21.42;	author mmostafa;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.20.21.06.44;	author ahunter;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.20.15.55.48;	author mmostafa;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.09.20.51.08;	author mmostafa;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.07.02.40.37;	author ldamus;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.28.02.31.23;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.13.19.12.29;	author ldamus;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.01.15.31.13;	author mmostafa;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.23.18.37.28;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.22.15.42.32;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.21.24.26;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.12.15.48.40;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.50;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.55;	author sshaw;	state Exp;
branches;
next	;

1.15.2.1
date	2006.07.17.20.27.57;	author ahunter;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2006.07.25.19.04.50;	author mmostafa;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2006.08.02.15.28.13;	author mmostafa;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2006.09.13.16.43.28;	author ahunter;	state Exp;
branches;
next	;

1.18.2.1
date	2008.07.25.21.23.41;	author aboyko;	state Exp;
branches;
next	1.18.2.2;
commitid	4cd1488a445d4567;

1.18.2.2
date	2008.08.07.16.24.43;	author ahunter;	state Exp;
branches;
next	1.18.2.3;
commitid	47c489b21cb4567;

1.18.2.3
date	2008.08.29.13.37.43;	author ldamus;	state Exp;
branches;
next	;
commitid	46f248b7fba74567;


desc
@@


1.21
log
@[242283] gmf_head mariot.chauvin 080827 NullPointerException from ViewUtil#getSourceConnectionsConnectingVisibleViews
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation
 *    Mariot Chauvin <mariot.chauvin@@obeo.fr> - patch 242283
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.core.util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramDebugOptions;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramPlugin;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramStatusCodes;
import org.eclipse.gmf.runtime.diagram.core.internal.commands.PersistElementCommand;
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;
import org.eclipse.gmf.runtime.emf.core.util.EObjectAdapter;
import org.eclipse.gmf.runtime.emf.core.util.PackageUtil;
import org.eclipse.gmf.runtime.emf.type.core.commands.DestroyElementCommand;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.gmf.runtime.notation.Edge;
import org.eclipse.gmf.runtime.notation.LayoutConstraint;
import org.eclipse.gmf.runtime.notation.Node;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.Style;
import org.eclipse.gmf.runtime.notation.View;

/**
 * provides different utility functions for the notation view
 * 
 * @@author mmostafa
 */
public class ViewUtil {

    /**
     * the append index, this is the index you should use to append a view to a
     * container
     */
    public static final int APPEND = -1;

    /**
     * create a list of View Adapters from a Notation View collection
     * 
     * @@param views
     *            a collection of Notation <code>View</code>s
     * @@return list of <code>EObjectAdapter</code>s
     */
    public static List makeViewsAdaptable(Collection views) {
        List list = new ArrayList();
        Iterator it = views.iterator();
        while (it.hasNext()) {
            list.add(new EObjectAdapter((View) it.next()));
        }
        return list;
    }

    /**
     * move the supplied view from, and all of its parents from the transient
     * collections to the persisted collections. This Api will modify the model
     * and make it dirty, it needs to run within a write action or unchecked
     * operation. A view will get persisted if the following conditions are met
     * <UL>
     * <LI> this method is invoked inside an UNDO interval
     * <LI> the supplied view is in a transient list or owned by a transient
     * container
     * </UL>
     * 
     * @@param view
     *            the <code>View</code> to persist
     */
    public static void persistElement(View view) {
        assert null != view : "null view in ViewUtil.persistElement";//$NON-NLS-1$

        TransactionalEditingDomain editingDomain = TransactionUtil
            .getEditingDomain(view);

        if (!view.isMutable()) {
            // get first view needs to get persisted
            View viewToPersist = getTopViewToPersist(view);
            if (viewToPersist != null) {
                // now create a command to persisted the view and exectue it
                PersistElementCommand pvc = new PersistElementCommand(
                    editingDomain, viewToPersist);
                try {
                    pvc.execute(new NullProgressMonitor(), null);
                } catch (ExecutionException e) {
                    Trace.catching(DiagramPlugin.getInstance(),
                        DiagramDebugOptions.EXCEPTIONS_CATCHING,
                        ViewUtil.class, "persistElement", e); //$NON-NLS-1$
                    Log.error(DiagramPlugin.getInstance(),
                        DiagramStatusCodes.IGNORED_EXCEPTION_WARNING, e
                            .getLocalizedMessage(), e);
                }

                CommandResult result = pvc.getCommandResult();
                view = (View) result.getReturnValue();
            }
        }
    }

    /**
     * Returns the top view that should be persisted, starting from the passed
     * view, it could return the passed view itself if it is a transient view,
     * other wise it will check its parent and so on ...
     * 
     * @@param view ,
     *            view to start from
     * @@return first view needs to get persisted
     */
    static public View getTopViewToPersist(View view) {
        EObject container = view.eContainer();
        // if the view had no container then it can not get persisted
        if (container == null)
            return null;
        // now edges are special case, becuase they do not exist in the
        // children lists, but in the edgs lists
        if (view instanceof Edge) {
            Diagram dContainer = (Diagram) container;
            // always make sure that the feature is set before calling get
            // to avoid creating unwanted EList that will stay in the memory
            // till the model is closed
            if (dContainer.eIsSet(NotationPackage.Literals
                .DIAGRAM__TRANSIENT_EDGES))
                return view;
            else
                return (getTopViewToPersist(dContainer));
        } else if (container instanceof View) {
            View vContainer = (View) container;
            // always make sure that the feature is set before calling get
            // to avoid creating unwanted EList that will stay in the memory
            // till the model is closed
            if (vContainer.eIsSet(NotationPackage.Literals
                .VIEW__TRANSIENT_CHILDREN))
                return view;
            else
                return (getTopViewToPersist(vContainer));
        }
        return null;
    }

    /**
     * Destroys the supplied view notational element and remove any references
     * this class may have to it.
     * 
     * @@param view
     *            view to destroy
     */
    public static void destroy(View view) {
        if (view == null)
            return;        
        Iterator it = new ArrayList(view.getChildren()).iterator();        
        while (it.hasNext()) {
            View child = (View) it.next();
            destroy(child);
        }
        DestroyElementCommand.destroy(view);
    }

    /**
     * Returns the container view, or null if the container is not a view or
     * null
     * 
     * @@param eObject
     *            a notation view
     * @@return the container <code>View</code>
     */
    static public View getContainerView(View eObject) {
        EObject container = eObject.eContainer();
        if (container instanceof View) {
            return (View) container;
        }
        return null;
    }

    /**
     * inserts a child <code>View</code> in a container. the view will be
     * inserted in the persisted collection if the <tt>persisted</tt> flag is
     * <tt>true</tt>; otherwise it will be added to the transied collection.
     * inserting a transient child does not dirty the model, inserting a
     * persisted child will dirty the model
     * 
     * @@param containerView
     *            the view's container
     * @@param childView
     *            notation <code>View</Code> to insert 
     * @@param index the view's position within the container's list
     * @@param persisted indicats the persisted state of the view
     *
     */
    public static void insertChildView(View containerView, View childView,
            int index, boolean persisted) {
        if (persisted) {
            insertPersistedElement(containerView, childView, index);
        } else {
            insertTransientElement(containerView, childView);
        }
    }

    /**
     * inserts a child into the transient list, inserting a transient child does
     * not dirty
     * 
     * @@param child ,
     *            the child to insert
     * @@param container
     *            notational element's container
     */
    static private void insertTransientElement(final View container,
            final View child) {
        if (child instanceof Edge) {
            Diagram diagram = (Diagram) container;
            diagram.insertEdge((Edge) child, false);
        } else {
            container.insertChild(child, false);
        }
        return;
    }

    /**
     * inserts a child into the persisted list
     * 
     * @@param container
     *            the notational element's container
     * @@param child ,
     *            the child to insert
     * @@param index
     *            the notational element's position within the container.
     */
    static private void insertPersistedElement(View container, View child,
            int index) {
        if (child instanceof Edge) {
            Diagram diagram = (Diagram) container;
            if (index == -1)
                diagram.insertEdge((Edge) child);
            else
                diagram.insertEdgeAt((Edge) child, index);
        } else {
            if (index == -1)
                container.insertChild(child);
            else
                container.insertChildAt(child, index);
        }
    }

    /**
     * checks if the passed view is transient or exists in a transient branch
     * 
     * @@param view
     *            <code>View</code> to check
     * @@return true if transient otherwise false
     */
    static public boolean isTransient(EObject view) {
        EStructuralFeature sFeature = view.eContainingFeature();
        // root element will have a null containing feature
        if (sFeature == null)
            return false;
        if (sFeature.isTransient()) {
            return true;
        }
        EObject container = view.eContainer();
        if (container != null) {
            return isTransient(container);
        }
        return false;
    }

    /**
     * gets a the first child in the passed <code>View</code> that had the
     * same type as the passed semantic hint.
     * 
     * @@param view
     *            the view to search inside
     * @@param semanticHint
     *            the semantic hint to look for
     * @@return the found view or null if none is found
     */
    public static View getChildBySemanticHint(View view, String semanticHint) {
        for (Iterator children = view.getChildren().iterator(); children
            .hasNext();) {
            View child = (View) children.next();
            if (semanticHint.equals(child.getType())) {
                return child;
            }
        }
        return null;
    }

    /**
     * checks if the passed property is supported bythe passed view
     * 
     * @@param view
     *            the view to use for the search
     * @@param id
     *            the property to look for
     * @@return boolean <tt>true</tt> if supported otherwise <tt>false</tt>
     */
    public static boolean isPropertySupported(View view, Object id) {
        if (id instanceof String) {
            EStructuralFeature feature = (EStructuralFeature) PackageUtil
                .getElement((String) id);
            if (feature != null) {
                return isPropertySupported(view, feature, feature
                    .getEContainingClass());
            }
        }
        return false;
    }

    /**
     * checks if the passed feature is supported by the passed view
     * 
     * @@param view
     *            the view to use for the search
     * @@param feature
     *            the feature to look for
     * @@return boolean <tt>true</tt> if supported otherwise <tt>false</tt>
     */
    public static boolean isFeatureSupported(View view,
            EStructuralFeature feature) {
        if (feature != null) {
            return isPropertySupported(view, feature, feature
                .getEContainingClass());
        }
        return false;
    }

    /**
     * checks if the passed feature is supported by the passed view
     * 
     * @@param view
     *            the view to use for the search
     * @@param feature
     *            the feature to look for
     * @@param featureClass
     *            the feature's <code>EClass</code>
     * @@return boolean <tt>true</tt> if supported otherwise <tt>false</tt>
     */
    public static boolean isPropertySupported(View view,
            EStructuralFeature feature, EClass featureClass) {
        // check if the id belongs to the view
        if (view.getStyle(featureClass) != null)
            return true;

        if (view instanceof Node) {
            LayoutConstraint constraint = ((Node) view).getLayoutConstraint();
            if (constraint != null && featureClass.isInstance(constraint))
                return true;
        }

        // check if the id belongs to a style owned by the view
        return featureClass.isInstance(view);
    }

    /**
     * Returns the value of the passed feature inside the passed view
     * 
     * @@param view
     *            the view to use to get the value
     * @@param feature
     *            the feature to use
     * @@return the value of the property, or <code>null</code>
     */
    static public final Object getStructuralFeatureValue(View view,
            EStructuralFeature feature) {
        if (feature != null) {
            return ViewUtil.getPropertyValue(view, feature, feature
                .getEContainingClass());
        }
        return null;
    }

    /**
     * Returns the value of the featrue inside a specific EClass within the
     * passed view
     * 
     * @@param view
     *            the view to use to get the value
     * @@param feature
     *            the featrue to use to get the value
     * @@param featureClass
     *            the <code>EClass</code> to use to get the feature
     * @@return the value of the feature, or <code>null</code>
     */
    public static Object getPropertyValue(View view,
            EStructuralFeature feature, EClass featureClass) {
        // check if the id belongs to a style owned by the view
        Style style = view.getStyle(featureClass);
        if (style != null)
            return style.eGet(feature);

        if (view instanceof Node) {
            LayoutConstraint constraint = ((Node) view).getLayoutConstraint();
            if (constraint != null && featureClass.isInstance(constraint))
                return constraint.eGet(feature);
        }

        // check if the id belongs to the view
        if (featureClass.isInstance(view))
            return view.eGet(feature);

        return feature.getDefaultValue(); // for extra robustness
    }

    /**
     * Sets the passed feature if possible on the passed view to the passed
     * value.
     * 
     * @@param view
     *            the view to set the value on
     * @@param feature
     *            the feature to use
     * @@param value
     *            the value of the property being set
     */
    public static void setStructuralFeatureValue(View view,
            EStructuralFeature feature, Object value) {
        if (feature != null) {
            ViewUtil.setPropertyValue(view, feature, feature
                .getEContainingClass(), value);
            return;
        }
    }

    /**
     * Sets the passed featrue on the passed EClass inside the passed view to
     * the new value if possible
     * 
     * @@param view
     *            the view to set the value on
     * @@param feature
     *            the feature to set
     * @@param featureClass
     *            <code> EClass </code> that owns the feature
     * @@param value
     *            the value of the feature being set
     */
    public static void setPropertyValue(View view, EStructuralFeature feature,
            EClass featureClass, Object value) {
        if (view == null)
            return;
        // check if the id belongs to a style owned by the view
        Style style = view.getStyle(featureClass);
        if (style != null) {
            style.eSet(feature, value);
            return;
        }

        if (view instanceof Node) {
            Node node = (Node) view;
            LayoutConstraint constraint = node.getLayoutConstraint();
            if (constraint != null & featureClass.isInstance(constraint)) {
                constraint.eSet(feature, value);
                return;
            }
        }

        // check if the id belongs to the view
        if (featureClass.isInstance(view)) {
            view.eSet(feature, value);
            return;
        }
    }

    /**
     * resolves the passed <code>View<code>'s semantic element, and returns it.
     * If the semantic element is unresolvable the method will returns <code>null</code>
     * @@param view the view to use to get the semantic element
     * @@return the semanticelement or null if there is no semantic element or if it is unresolvable
     */
    public static EObject resolveSemanticElement(View view) {
        EObject element = view.getElement();
        if (element != null && element.eIsProxy()) {
            TransactionalEditingDomain domain = TransactionUtil
                .getEditingDomain(view);
            if (domain != null) {
                return EMFCoreUtil.resolve(domain, element);
            }
        }
        return element;
    }

    /**
     * resolves the passed element, and returns it. If the element is
     * unresolvable the method will returns <code>null</code>
     * 
     * @@param the
     *            element to resolve
     * @@return the element or null if it is unresolvable
     */
    public static EObject resolve(EObject object) {
        if (object != null && object.eIsProxy()) {
            TransactionalEditingDomain domain = TransactionUtil
                .getEditingDomain(object);
            if (domain != null)
                return EMFCoreUtil.resolve(domain, object);
        }
        return object;
    }

    /**
     * gets the <code>View</code>'s semantic element Class Id, this could be
     * used to check the semantic element type
     * 
     * @@param view
     *            the owner of the semantic element
     * @@return the semantic element class Id
     */
    public static String getSemanticElementClassId(View view) {
        EObject element = view.getElement();
        return element == null ? null
            : PackageUtil.getID(EMFCoreUtil.getProxyClass(element));
    }

    /**
     * gets all the <code>Edge</code>'s whose source is this view
     * 
     * @@param view
     *            the view to use
     * @@return List the edges list
     */
    public static List getSourceConnections(View view) {
        if (!view.eIsSet(NotationPackage.Literals.VIEW__SOURCE_EDGES))
            return Collections.EMPTY_LIST;
        return view.getSourceEdges();
    }
    
    /**
     * gets all the <code>Edge</code>'s whose target is this view
     * 
     * @@param view
     *            the view to use
     * @@return List the edges list
     */
    public static List getTargetConnections(View view) {
        if (!view.eIsSet(NotationPackage.Literals.VIEW__TARGET_EDGES))
            return Collections.EMPTY_LIST;
        return view.getTargetEdges();
    }
    
    /**
     * gets all the <code>Edge</code>'s whose source is this view
     * 
     * @@param view
     *            the view to use
     * @@return List the edges list
     */
     public static List getSourceConnectionsConnectingVisibleViews(View view) {
        if (!view.eIsSet(NotationPackage.Literals.VIEW__SOURCE_EDGES))
            return Collections.EMPTY_LIST;
        List sourceConnections = new ArrayList();
        Iterator iter = view.getSourceEdges().iterator();
        while (iter.hasNext()) {
            Edge edge = (Edge)iter.next();
            View target = edge.getTarget();
            if (edge.isVisible() && isVisible(target)){
                sourceConnections.add(edge);
            }
            
        }
        return sourceConnections;
     }
    
    

     private static boolean isVisible(View target) {
        if (target != null && target.isVisible()){
            EObject parent = target.eContainer();
            if (parent instanceof View){
                return isVisible((View)parent);
            }
            return true;
        }
        return false;
    }
     
    /**
     * gets all the <code>Edge</code>'s whose target is this view
     * 
     * @@param view
     *            the view to use
     * @@return List the edges list
     */
     public static List getTargetConnectionsConnectingVisibleViews(View view) {
        if (!view.eIsSet(NotationPackage.Literals.VIEW__TARGET_EDGES))
            return Collections.EMPTY_LIST;
        List targteConnections = new ArrayList();
        Iterator iter = view.getTargetEdges().iterator();
        while (iter.hasNext()) {
            Edge edge = (Edge)iter.next();
            View source = edge.getSource();
            if (edge.isVisible() && isVisible(source)){
                targteConnections.add(edge);
            }
        }
        return targteConnections;
     }

    /**
     * return eClass Name of the view's semantic element, this method works only
     * if the semantic element is a NameElement, otherwise it will return an
     * Empty String
     * 
     * @@param view
     *            the view object
     * @@return the eClass name
     */
    public static String getSemanticEClassName(View view) {
        EObject eObject = view.getElement();
        if (eObject != null)
            return PackageUtil.getID(EMFCoreUtil.getProxyClass(eObject));
        return ""; //$NON-NLS-1$
    }

    /**
     * returns the unique GUID of the view
     * 
     * @@param view
     *            the view
     * @@return String the GUID of a view (constant)
     */
    public static String getIdStr(View view) {
        String id = ((XMLResource) view.eResource()).getID(view);
        if (id != null) {
            return id;
        }

        // Remain compatible with previous behavior.
        return StringStatics.BLANK;
    }

    /**
     * reorders the child at the oldIndex to the newIndex
     * 
     * @@param container
     *            the view's container
     * @@param child
     *            the child to reposition
     * @@param newIndex
     *            (zero-based)
     * @@throws IndexOutOfBoundsException
     *             if index is out of bounds
     * @@throws IllegalArgumentException
     *             if the child is not contianed by the container, or if the new
     *             position is the <code>ViewUtil.APPEND</code>position
     */
    static public void repositionChildAt(View container, View child,
            int newIndex) {
        ViewUtil.persistElement(child);
        if (child.eContainer() != container)
            throw new IllegalArgumentException(
                "child is not an existing child of the view"); //$NON-NLS-1$
        if (newIndex == APPEND)
            throw new IllegalArgumentException(
                "append position is not allowed for reposition"); //$NON-NLS-1$
        container.removeChild(child);
        container.insertChildAt(child, newIndex);
    }

    /**
     * returns the first child whose id matched the given id
     * 
     * @@param view
     *            the view to search in
     * @@param idStr
     *            the child's id
     * @@return View the first matching child or null if no one was found
     */
    static public View getChildByIdStr(View view, String idStr) {
        for (Iterator children = view.getChildren().iterator(); children
            .hasNext();) {
            View child = (View) children.next();
            if (idStr.equals(((XMLResource) child.eResource()).getID(child))) {
                return child;
            }
        }
        return null;
    }

    /**
     * Sets the property with the given id if possible on the passed view to the
     * passed value.
     * 
     * @@param view
     *            the view to set the value on
     * @@param id
     *            the id of the property being set
     * @@param value
     *            the value of the property being set
     * @@deprecated use
     *             {@@link ViewUtil#setStructuralFeatureValue(View, EStructuralFeature, Object}}
     *             instead
     */
    public static void setPropertyValue(View view, Object id, Object value) {
        if (id instanceof String) {
            EStructuralFeature feature = (EStructuralFeature) PackageUtil
                .getElement((String) id);
            if (feature != null) {
                ViewUtil.setPropertyValue(view, feature, feature
                    .getEContainingClass(), value);
                return;
            }
        }
    }

    /**
     * Returns the value of the property with the given id inside the passed
     * view
     * 
     * @@param view
     *            the view to use to get the value
     * @@param id
     *            the id of the property to get
     * @@return the value of the property, or <code>null</code>
     * @@deprecated use
     *             {@@link ViewUtil#getStructuralFeatureValue(View, EStructuralFeature)}
     *             instead
     */
    static public final Object getPropertyValue(View view, Object id) {
        if (id instanceof String) {
            EStructuralFeature feature = (EStructuralFeature) PackageUtil
                .getElement((String) id);
            if (feature != null) {
                return ViewUtil.getPropertyValue(view, feature, feature
                    .getEContainingClass());
            }
        }
        return null;
    }
    
    /**
	 * Goes up through the containers of the passed in <code>EObject</code>
	 * and returns the first container that is a <code>View</code>
	 * 
	 * @@param obj
	 *            the <code>EObject</code>
	 * @@return the first found <code>View</code> container of the object
	 */
	static public View getViewContainer(EObject obj) {
		while (obj != null) {
			if (obj.eContainer() instanceof View)
				return (View) obj.eContainer();
			obj = obj.eContainer();
		}
		return null;
	}

	/**
	 * Constructs a set of all source and target edges from a view and all its
	 * children down to the leaves of a view hierarchy
	 * 
	 * @@param view
	 * @@param allEdges
	 */
	static public void  getAllRelatedEdgesForView(View view, Set<Edge> allEdges) {
		allEdges.addAll(ViewUtil.getSourceConnections(view));
		allEdges.addAll(ViewUtil.getTargetConnections(view));
		for (Iterator itr = view.getChildren().iterator(); itr.hasNext();) {
			Object obj = itr.next();
			if (obj instanceof View) {
				getAllRelatedEdgesForView((View)obj, allEdges);
			}
		}
	}
	
	/**
	 * Constructs a set of all source and target edges from a list of view and all their
	 * children down to the leaves of a view hierarchy
	 * 
	 * @@param views
	 * @@param allEdges
	 */
	static public void getAllRelatedEdgesFromViews(List views, HashSet<Edge> allEdges) {
		for (Iterator itr = views.iterator(); itr.hasNext();) {
			Object obj = itr.next();
			if (obj instanceof View) {
				getAllRelatedEdgesForView((View)obj, allEdges);
			}
		}
	}
	
	static public Set<Edge> getAllInnerEdges(View view) {
		Set<View> allViews = new HashSet<View>();
		Set<Edge> edges = new HashSet<Edge>();
		Set<Edge> edgesConnectingViews = new HashSet<Edge>();
		getAllNestedViews(view, allViews);
		for (View v : allViews) {
			getAllEdgesFromView(v, edges);
		}
		Stack<Edge> connectionsPath = new Stack<Edge>();
		/*
		 * Create a set of connections constained within the given editpart
		 */
		while (!edges.isEmpty()) {
			/*
			 * Take the first connection and check whethe there is a path
			 * through that connection that leads to the target contained within
			 * the given editpart
			 */
			Edge edge = edges.iterator().next();
			edges.remove(edge);
			connectionsPath.add(edge);
			
			/*
			 * Initialize the target for the current path
			 */
			View target = edge.getTarget();
			while(edges.contains(target)) {
				/*
				 * If the target end is a connection, check if it's one of the
				 * connection's whose target is a connection and within the
				 * given editpart. Append it to the path if it is. Otherwise
				 * check if the target is within the actual connections or nodes
				 * contained within the given editpart
				 */
				Edge targetEdge = (Edge) target;
				edges.remove(targetEdge);
				connectionsPath.add(targetEdge);
				
				/*
				 * Update the target for the new path
				 */
				target = targetEdge.getTarget();
			}
			
			/*
			 * The path is built, check if it's target is a node or a connection
			 * contained within the given editpart
			 */
			if (allViews.contains(target) || edgesConnectingViews.contains(target)) {
				edgesConnectingViews.addAll(connectionsPath);
			}
			connectionsPath.clear();
		}
		return edgesConnectingViews;
	}
	
	static private void getAllNestedViews(View view, Set<View> allViews) {
		for (View childView : (List<View>) view.getChildren() ) {
			getAllNestedViews(childView, allViews);
			allViews.add(childView);
		}
	}
	
	static private void getAllEdgesFromView(View view, Set<Edge> edges) {
		for (Edge e : (List<Edge>) view.getSourceEdges()) {
			getAllEdgesFromView(e, edges);
			edges.add(e);
		}
	}
	
}
@


1.20
log
@[242124] gmf_head aboyko 080725 [CopyPaste] Edges that shouldn't be copied are being copied without source/target
@
text
@d9 2
a10 1
 *    IBM Corporation - initial API and implementation 
d590 1
a590 1
        if (target.isVisible()){
@


1.19
log
@[242124] gmf_head aboyko 080725 [CopyPaste] Edges that shouldn't be copied are being copied without source/target
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2007 IBM Corporation and others.
@


1.18
log
@[208622] gmf_HEAD aboyko 071102 Contents of Canonical compartments are duplicated incorrectly
@
text
@d21 1
d804 70
@


1.18.2.1
log
@[242124] gmf_R2_1_maintenance aboyko 080725 [CopyPaste] Edges that shouldn't be copied are being copied without source/target
@
text
@a20 1
import java.util.Stack;
a802 70
	static public Set<Edge> getAllInnerEdges(View view) {
		Set<View> allViews = new HashSet<View>();
		Set<Edge> edges = new HashSet<Edge>();
		Set<Edge> edgesConnectingViews = new HashSet<Edge>();
		getAllNestedViews(view, allViews);
		for (View v : allViews) {
			getAllEdgesFromView(v, edges);
		}
		Stack<Edge> connectionsPath = new Stack<Edge>();
		/*
		 * Create a set of connections constained within the given editpart
		 */
		while (!edges.isEmpty()) {
			/*
			 * Take the first connection and check whethe there is a path
			 * through that connection that leads to the target contained within
			 * the given editpart
			 */
			Edge edge = edges.iterator().next();
			edges.remove(edge);
			connectionsPath.add(edge);
			
			/*
			 * Initialize the target for the current path
			 */
			View target = edge.getTarget();
			while(edges.contains(target)) {
				/*
				 * If the target end is a connection, check if it's one of the
				 * connection's whose target is a connection and within the
				 * given editpart. Append it to the path if it is. Otherwise
				 * check if the target is within the actual connections or nodes
				 * contained within the given editpart
				 */
				Edge targetEdge = (Edge) target;
				edges.remove(targetEdge);
				connectionsPath.add(targetEdge);
				
				/*
				 * Update the target for the new path
				 */
				target = targetEdge.getTarget();
			}
			
			/*
			 * The path is built, check if it's target is a node or a connection
			 * contained within the given editpart
			 */
			if (allViews.contains(target) || edgesConnectingViews.contains(target)) {
				edgesConnectingViews.addAll(connectionsPath);
			}
			connectionsPath.clear();
		}
		return edgesConnectingViews;
	}
	
	static private void getAllNestedViews(View view, Set<View> allViews) {
		for (View childView : (List<View>) view.getChildren() ) {
			getAllNestedViews(childView, allViews);
			allViews.add(childView);
		}
	}
	
	static private void getAllEdgesFromView(View view, Set<Edge> edges) {
		for (Edge e : (List<Edge>) view.getSourceEdges()) {
			getAllEdgesFromView(e, edges);
			edges.add(e);
		}
	}
	
@


1.18.2.2
log
@[242124] gmf_R2_1_maintenance aboyko 080725 [CopyPaste] Edges that shouldn't be copied are being copied without source/target
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2008 IBM Corporation and others.
@


1.18.2.3
log
@[242283] gmf_R2_1_maintenance  mariot.chauvin 080827 NullPointerException from ViewUtil#getSourceConnectionsConnectingVisibleViews
@
text
@d9 1
a9 2
 *    IBM Corporation - initial API and implementation
 *    Mariot Chauvin <mariot.chauvin@@obeo.fr> - patch 242283
d589 1
a589 1
        if (target != null && target.isVisible()){
@


1.17
log
@gmf_head aboyko 070517 New styles for Notational Meta-Model + example of usage of a map style in Logic example + new junit
@
text
@d17 1
d20 1
d768 35
@


1.16
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
d749 17
@


1.15
log
@Bugzilla#109422 gmf_head cmahoney 060509 Removing deprecated classes from GMF diagram components
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
a11 1

d50 1
d53 51
a103 47
public class ViewUtil{
	
	/**
	 * the append index, this is the index you should use to append a view
	 * to a container
	 */
	public static final int APPEND = -1;
	
	
	/**
	 * create a list of View Adapters from a Notation View collection
	 * @@param views a collection of Notation <code>View</code>s
	 * @@return	list of <code>EObjectAdapter</code>s
	 */
	public static List makeViewsAdaptable(Collection views){
		List list = new ArrayList();
		Iterator it = views.iterator();
		while(it.hasNext()){
			list.add(new EObjectAdapter((View)it.next()));
		}
		return list;
	}

	/** 
	 * move the supplied view from, and all of its parents from the transient 
	 * collections to the persisted collections. This Api will modify the model
	 * and make it dirty, it needs to run within a write action or unchecked
	 * operation. 
	 * A view will get persisted if the following conditions are met
	 * <UL>
	 * <LI> this method is invoked inside an UNDO interval
	 * <LI> the supplied view is in a transient list or owned by a transient container
	 * </UL>
	 * @@param view the <code>View</code> to persist
	 */
	public static void persistElement(View view) {
		assert null != view: "null view in ViewUtil.persistElement";//$NON-NLS-1$
		
		TransactionalEditingDomain editingDomain = TransactionUtil.getEditingDomain(view);
        
		if (!view.isMutable()) {
			// get first view needs to get persisted
			View viewToPersist = getTopViewToPersist(view);
			if (viewToPersist!=null){
				// now create a command to persisted the view and exectue it
				PersistElementCommand pvc = 
					new PersistElementCommand(editingDomain, viewToPersist);
d105 1
a105 1
                    pvc.execute( new NullProgressMonitor(), null );
d114 381
a494 327
                
				CommandResult result = pvc.getCommandResult();
				view = (View)result.getReturnValue();
			}
		}
	}
	
	/**
	 * Returns the top view that should be persisted,
	 * starting from the passed view, it could return the passed view
	 * itself if it is a transient view, other wise it will check its
	 * parent and so on ...
	 * @@param view , view to start from
	 * @@return first view needs to get persisted
	 */
	static public View getTopViewToPersist(View view) {
		EObject container = view.eContainer();
		// if the view had no container then it can not get persisted
		if (container==null)
			return null;
		// now edges are special case, becuase they do not exist in the 
		// children lists, but in the edgs lists
		if (view instanceof Edge){
			Diagram dContainer = (Diagram)container;
			// always make sure that the feature is set before calling get
			// to avoid creating unwanted EList that will stay in the memory
			// till the model is closed
			if (dContainer.eIsSet(NotationPackage.eINSTANCE.getDiagram_TransientEdges()) &&
				dContainer.getTransientEdges().size()>0)
				return view;
			else
				return (getTopViewToPersist(dContainer)); 
		}
		else if (container instanceof View){
			View vContainer = (View)container;
			// always make sure that the feature is set before calling get
			// to avoid creating unwanted EList that will stay in the memory
			// till the model is closed
			if (vContainer.eIsSet(NotationPackage.eINSTANCE.getView_TransientChildren()) &&
				vContainer.getTransientChildren().size()>0)
				return view;
			else 
				return (getTopViewToPersist(vContainer));
		} 
		return null;
	}

	/**
	 * Destroys the supplied view notational element and remove any references
	 * this class may have to it.
	 *
	 * @@param view view to destroy
	 */
	public static void destroy(View view) {
		if (view==null)
			return;
		List children = view.getChildren();
		for ( int i = 0; i < children.size(); i++ ) {
			View child = (View)children.get(i);
			destroy(child);
		}
		DestroyElementCommand.destroy(view);
	}
	
	/**
	 * Returns the container view, or null if the container is not a view or null
	 * @@param eObject  a notation view
	 * @@return the container <code>View</code>
	 */
	static public View getContainerView(View eObject) {
		EObject container = eObject.eContainer();
		if ( container instanceof View ) {
			return (View)container;
		}
		return null;
	}
	
	
	/**
	 * inserts a child  <code>View</code> in a container. the view will be inserted
	 * in the persisted collection if the <tt>persisted</tt> flag is <tt>true</tt>;
	 * otherwise it will be added to the transied collection.
	 * inserting a transient child does not dirty the model, inserting a persisted
	 * child will dirty the model 
	 * 
	 * @@param containerView the view's container
	 * @@param childView notation <code>View</Code> to insert 
	 * @@param index the view's position within the container's list
	 * @@param persisted indicats the persisted state of the view
	 * 
	 */
	public static void insertChildView(
		View containerView,
		View childView,
		int index,
		boolean persisted) {
		if (persisted) {
			insertPersistedElement(containerView,childView,index);
		}
		else {
			insertTransientElement(containerView,childView);
		}
	}	
	
	/**
	 * inserts a child into the transient list, inserting a transient child
	 * does not dirty
	 * @@param child , the child to insert
	 * @@param container notational element's container
	 */
	static private void insertTransientElement(final View container,final View child) {
	  	if (child instanceof Edge){
	 		Diagram diagram = (Diagram)container;
	 		diagram.insertEdge((Edge)child,false);
	 	} else {
	 		container.insertChild(child,false);
	 	}
	 	return; 
	}

	/**
	 * inserts a child into the persisted list 
	 * @@param container the notational element's container
	 * @@param child , the child to insert
	 * @@param index the notational element's position within the container.
	 */
	static private void insertPersistedElement(View container,View child, int index) {
		if (child instanceof Edge){
	 		Diagram diagram = (Diagram)container;
	 		if (index==-1)
	 			diagram.insertEdge((Edge)child);
	 		else
	 			diagram.insertEdgeAt((Edge)child,index);
	 	} else {
	 		if (index==-1)
	 			container.insertChild(child);
	 		else
	 			container.insertChildAt(child,index);
	 	}
	}
	
	 /**
	  * checks if the passed view is transient or exists in a transient branch
	  * @@param view <code>View</code> to check
	  * @@return true if transient otherwise false
	  */
	static public boolean isTransient(EObject view) {
		EStructuralFeature sFeature = view.eContainingFeature();
		// root element will have a null containing feature
		if (sFeature==null)
			return false;
		if (sFeature.isTransient()){
			return true;
		}
		EObject container  = view.eContainer();
		if (container!=null){
			return isTransient(container);
		}
		return false;
	}
	
	/**
	 * gets a the first child in the passed <code>View</code> that had the same type as
	 * the passed semantic hint. 
	 * @@param view	the view to search inside
	 * @@param semanticHint	the semantic hint to look for
	 * @@return	the found view or null if none is found
	 */
	public static View getChildBySemanticHint(View view,String semanticHint) {
		for(Iterator children = view.getChildren().iterator();children.hasNext();) {
			View child = (View)children.next();
			if ( semanticHint.equals(child.getType())) {
				return child ;
			}
		}
		return null;
	}
	
	
	/**
	 * checks if the passed property is supported bythe passed view
	 * @@param view  the view to use for the search
	 * @@param id	the property to look for
	 * @@return boolean	<tt>true</tt> if supported otherwise <tt>false</tt>
	 */
	public static boolean isPropertySupported(View view,Object id) {
		if(id instanceof String){
			EStructuralFeature feature = (EStructuralFeature) PackageUtil.getElement((String)id);
			if (feature != null) {
				return isPropertySupported(view,feature, feature.getEContainingClass());
			}
		}
		return false;
	}
	
	/**
	 * checks if the passed feature is supported by the passed view
	 * @@param view  the view to use for the search
	 * @@param feature	the feature to look for
	 * @@return boolean	<tt>true</tt> if supported otherwise <tt>false</tt>
	 */
	public static boolean isFeatureSupported(View view,EStructuralFeature feature) {
		if (feature != null) {
			return isPropertySupported(view,feature, feature.getEContainingClass());
		}
		return false;
	}
	
	/**
	 * checks if the passed feature is supported by the passed view
	 * @@param view  the view to use for the search
	 * @@param feature the feature to look for
	 * @@param featureClass the feature's <code>EClass</code>
	 * @@return boolean	<tt>true</tt> if supported otherwise <tt>false</tt>
	 */
	public static  boolean isPropertySupported(View view,EStructuralFeature feature, EClass featureClass) {
		// check if the id belongs to the view
		if (view.getStyle(featureClass) != null)
			return true;
		
		if (view instanceof Node){
			LayoutConstraint constraint = ((Node)view).getLayoutConstraint();
			if (constraint != null && featureClass.isInstance(constraint))
				return true;
		}
		
		// check if the id belongs to a style owned by the view
		return featureClass.isInstance(view);
	}
	
	/**
	 * Returns the value of the passed feature inside the passed view
	 * @@param view the view to use to get the value
	 * @@param feature the feature to use
	 * @@return the value of the property, or <code>null</code>
	 */
	static public final Object getStructuralFeatureValue(View view, EStructuralFeature feature) {
		if (feature != null) {
				return ViewUtil.getPropertyValue(view,feature, feature.getEContainingClass());
		}
		return null;
	}
	
	/**
	 * Returns the value of the featrue inside a specific EClass within the passed view
	 * @@param view the view to use to get the value
	 * @@param feature the featrue to use to get the value
	 * @@param featureClass the <code>EClass</code> to use to get the feature
	 * @@return the value of the feature, or <code>null</code>
	 */
	public static  Object getPropertyValue(View view,EStructuralFeature feature, EClass featureClass) {
		// check if the id belongs to a style owned by the view
		Style style = view.getStyle(featureClass);
		if (style != null)
			return style.eGet(feature);
		
		if (view instanceof Node){
			LayoutConstraint constraint = ((Node)view).getLayoutConstraint();
			if (constraint != null && featureClass.isInstance(constraint))
				return constraint.eGet(feature);
		}
		
		// check if the id belongs to the view
		if (featureClass.isInstance(view))
			return view.eGet(feature);

		return feature.getDefaultValue(); // for extra robustness
	}
	
	/**
	 * Sets the passed feature if possible on the passed view
	 * to the passed value.
	 * @@param view the view to set the value on 
	 * @@param feature the feature to use
	 * @@param value  the value of the property being set
	 */
	public static void setStructuralFeatureValue(View view,EStructuralFeature feature,Object value) {
		if (feature != null) {
				ViewUtil.setPropertyValue(view,feature, feature.getEContainingClass(), value);
				return;
		}
	}

	/**
	 * Sets the passed featrue on the passed EClass inside the passed view
	 * to the new value if possible
	 * @@param view the view to set the value on 
	 * @@param feature the feature to set
	 * @@param featureClass <code> EClass </code> that owns the feature
	 * @@param value  the value of the feature being set
	 */
	public static void setPropertyValue(View view,EStructuralFeature feature, EClass featureClass, Object value) {
		if( view == null )
			return;
		// check if the id belongs to a style owned by the view
		Style style = view.getStyle(featureClass);
		if (style != null) {
			style.eSet(feature, value);
			return;
		} 
		
		if (view instanceof Node){
			Node node = (Node)view;
			LayoutConstraint constraint = node.getLayoutConstraint();
			if (constraint != null & featureClass.isInstance(constraint)) {
				constraint.eSet(feature, value);
				return;
			}
		}

		// check if the id belongs to the view
		if (featureClass.isInstance(view)) {
			view.eSet(feature, value);
			return;
		}
	}
	
	/**
	 * resolves the passed <code>View<code>'s semantic element, and returns it.
	 * If the semantic element is unresolvable the method will returns <code>null</code>
	 * @@param view the view to use to get the semantic element
	 * @@return the semanticelement or null if there is no semantic element or if it is unresolvable
	 */
	public static EObject resolveSemanticElement(View view) {
	    EObject element = view.getElement();
	    if (element!=null && element.eIsProxy()) {
            TransactionalEditingDomain domain = TransactionUtil.getEditingDomain(view);
d499 15
a513 12
	    return element;
	}
	
	/**
	 * resolves the passed element, and returns it.
	 * If the element is unresolvable the method will returns <code>null</code>
	 * @@param the element to resolve
	 * @@return the element or null if it is unresolvable
	 */
	public static EObject resolve(EObject object){
		if (object!=null && object.eIsProxy()){
            TransactionalEditingDomain domain = TransactionUtil.getEditingDomain(object);
d516 201
a716 112
		}
				return object;
		}
	
	/** 
	 * gets the <code>View</code>'s semantic element Class Id, this could be used to
	 * check the semantic element type
	 * @@param view the owner of the semantic element
	 * @@return the semantic element class Id
	 */
	public static String getSemanticElementClassId(View view) {
		EObject element = view.getElement();
	    return element == null ? null : PackageUtil.getID(EMFCoreUtil.getProxyClass(element));
	}
	
	/**
	 * gets all the <code>Edge</code>'s whose source is this view
	 * @@param view the view to use
	 * @@return List	the edges list
	 */
	public static List getSourceConnections(View view) {
		if (!view.eIsSet(NotationPackage.eINSTANCE.getView_SourceEdges()))
			return Collections.EMPTY_LIST;
		return view.getSourceEdges();
	}
	
	/**
	 * gets all the <code>Edge</code>'s whose target is this view
	 * @@param view the view to use
	 * @@return List	the edges list
	 */
	public static List getTargetConnections(View view) {
		if (!view.eIsSet(NotationPackage.eINSTANCE.getView_TargetEdges()))
			return Collections.EMPTY_LIST;
		return view.getTargetEdges();
	}
	
	/**
	 * return eClass Name of the view's semantic element, this method 
	 * works only if the semantic element is a NameElement, otherwise 
	 * it will return an Empty String 
	 * @@param  view	the view object
	 * @@return the eClass name
	 */
	public static String getSemanticEClassName(View view){
		EObject eObject = view.getElement();
		if (eObject != null)
			return PackageUtil.getID(EMFCoreUtil.getProxyClass(eObject));
		return ""; //$NON-NLS-1$
	}
	
	/**
	 * returns the unique GUID of the view
	 * @@param view the view
	 * @@return String the GUID of a view (constant)
	 */
	public static String getIdStr(View view) {
		String id = ((XMLResource) view.eResource()).getID(view);
		if (id != null) {
			return id;
		}
		
		// Remain compatible with previous behavior.
		return StringStatics.BLANK;
	}
	
	/**
	 * reorders the child at the oldIndex to the newIndex
	 * @@param container the view's container
	 * @@param child the child to reposition
	 * @@param newIndex (zero-based)
	 * @@throws IndexOutOfBoundsException if index is out of bounds
	 * @@throws IllegalArgumentException if the child is not contianed by the container,
	 * or if the new position is the <code>ViewUtil.APPEND</code>position 
	 */
	static public void repositionChildAt(View container , View child, int newIndex) {
		ViewUtil.persistElement(child);
		if (child.eContainer() != container)
			throw new IllegalArgumentException("child is not an existing child of the view"); //$NON-NLS-1$
		if (newIndex == APPEND)
			throw new IllegalArgumentException("append position is not allowed for reposition"); //$NON-NLS-1$
		container.removeChild(child);
		container.insertChildAt(child,newIndex);
	}
	
	/**
	 * returns the first child whose id matched the given id
	 * @@param view the view to search in 
	 * @@param idStr the child's id
	 * @@return View the first matching child or null if no one was found
	 */
	static public View getChildByIdStr(View view, String idStr) {
		for(Iterator children = view.getChildren().iterator();children.hasNext();) {
			View child = (View)children.next();
			if ( idStr.equals( ((XMLResource) child.eResource()).getID(child))) {
				return child;
			}
		}
		return null;
	}
	
    /**
     * Sets the property with the given id if possible on the passed view
     * to the passed value.
     * @@param view the view to set the value on 
     * @@param id  the id of the property being set
     * @@param value  the value of the property being set
     * @@deprecated use {@@link ViewUtil#setStructuralFeatureValue(View, EStructuralFeature, Object}} instead
     */
    public static void setPropertyValue(View view,Object id, Object value) {
        if(id instanceof String){
            EStructuralFeature feature = (EStructuralFeature) PackageUtil.getElement((String)id);
d718 2
a719 1
                ViewUtil.setPropertyValue(view,feature, feature.getEContainingClass(), value);
d724 1
a724 1
    
d726 7
a732 3
     * Returns the value of the property with the given id inside the passed view
     * @@param view the view to use to get the value
     * @@param id the id of the property to get
d734 3
a736 1
     * @@deprecated use {@@link ViewUtil#getStructuralFeatureValue(View, EStructuralFeature)} instead
d739 3
a741 2
        if(id instanceof String){
            EStructuralFeature feature = (EStructuralFeature) PackageUtil.getElement((String)id);
d743 2
a744 1
                return ViewUtil.getPropertyValue(view,feature, feature.getEContainingClass());
@


1.15.2.1
log
@[141061] gmf_r1_0_maintenance ylulu 060717 Performance: Notation metamodel can reduce its memory usage
@
text
@d12 1
a50 1
 * 
d53 47
a99 51
public class ViewUtil {

    /**
     * the append index, this is the index you should use to append a view to a
     * container
     */
    public static final int APPEND = -1;

    /**
     * create a list of View Adapters from a Notation View collection
     * 
     * @@param views
     *            a collection of Notation <code>View</code>s
     * @@return list of <code>EObjectAdapter</code>s
     */
    public static List makeViewsAdaptable(Collection views) {
        List list = new ArrayList();
        Iterator it = views.iterator();
        while (it.hasNext()) {
            list.add(new EObjectAdapter((View) it.next()));
        }
        return list;
    }

    /**
     * move the supplied view from, and all of its parents from the transient
     * collections to the persisted collections. This Api will modify the model
     * and make it dirty, it needs to run within a write action or unchecked
     * operation. A view will get persisted if the following conditions are met
     * <UL>
     * <LI> this method is invoked inside an UNDO interval
     * <LI> the supplied view is in a transient list or owned by a transient
     * container
     * </UL>
     * 
     * @@param view
     *            the <code>View</code> to persist
     */
    public static void persistElement(View view) {
        assert null != view : "null view in ViewUtil.persistElement";//$NON-NLS-1$

        TransactionalEditingDomain editingDomain = TransactionUtil
            .getEditingDomain(view);

        if (!view.isMutable()) {
            // get first view needs to get persisted
            View viewToPersist = getTopViewToPersist(view);
            if (viewToPersist != null) {
                // now create a command to persisted the view and exectue it
                PersistElementCommand pvc = new PersistElementCommand(
                    editingDomain, viewToPersist);
d101 1
a101 1
                    pvc.execute(new NullProgressMonitor(), null);
d110 327
a436 381

                CommandResult result = pvc.getCommandResult();
                view = (View) result.getReturnValue();
            }
        }
    }

    /**
     * Returns the top view that should be persisted, starting from the passed
     * view, it could return the passed view itself if it is a transient view,
     * other wise it will check its parent and so on ...
     * 
     * @@param view ,
     *            view to start from
     * @@return first view needs to get persisted
     */
    static public View getTopViewToPersist(View view) {
        EObject container = view.eContainer();
        // if the view had no container then it can not get persisted
        if (container == null)
            return null;
        // now edges are special case, becuase they do not exist in the
        // children lists, but in the edgs lists
        if (view instanceof Edge) {
            Diagram dContainer = (Diagram) container;
            // always make sure that the feature is set before calling get
            // to avoid creating unwanted EList that will stay in the memory
            // till the model is closed
            if (dContainer.eIsSet(NotationPackage.Literals
                .DIAGRAM__TRANSIENT_EDGES))
                return view;
            else
                return (getTopViewToPersist(dContainer));
        } else if (container instanceof View) {
            View vContainer = (View) container;
            // always make sure that the feature is set before calling get
            // to avoid creating unwanted EList that will stay in the memory
            // till the model is closed
            if (vContainer.eIsSet(NotationPackage.Literals
                .VIEW__TRANSIENT_CHILDREN))
                return view;
            else
                return (getTopViewToPersist(vContainer));
        }
        return null;
    }

    /**
     * Destroys the supplied view notational element and remove any references
     * this class may have to it.
     * 
     * @@param view
     *            view to destroy
     */
    public static void destroy(View view) {
        if (view == null)
            return;        
        Iterator it = new ArrayList(view.getChildren()).iterator();        
        while (it.hasNext()) {
            View child = (View) it.next();
            destroy(child);
        }
        DestroyElementCommand.destroy(view);
    }

    /**
     * Returns the container view, or null if the container is not a view or
     * null
     * 
     * @@param eObject
     *            a notation view
     * @@return the container <code>View</code>
     */
    static public View getContainerView(View eObject) {
        EObject container = eObject.eContainer();
        if (container instanceof View) {
            return (View) container;
        }
        return null;
    }

    /**
     * inserts a child <code>View</code> in a container. the view will be
     * inserted in the persisted collection if the <tt>persisted</tt> flag is
     * <tt>true</tt>; otherwise it will be added to the transied collection.
     * inserting a transient child does not dirty the model, inserting a
     * persisted child will dirty the model
     * 
     * @@param containerView
     *            the view's container
     * @@param childView
     *            notation <code>View</Code> to insert 
     * @@param index the view's position within the container's list
     * @@param persisted indicats the persisted state of the view
     *
     */
    public static void insertChildView(View containerView, View childView,
            int index, boolean persisted) {
        if (persisted) {
            insertPersistedElement(containerView, childView, index);
        } else {
            insertTransientElement(containerView, childView);
        }
    }

    /**
     * inserts a child into the transient list, inserting a transient child does
     * not dirty
     * 
     * @@param child ,
     *            the child to insert
     * @@param container
     *            notational element's container
     */
    static private void insertTransientElement(final View container,
            final View child) {
        if (child instanceof Edge) {
            Diagram diagram = (Diagram) container;
            diagram.insertEdge((Edge) child, false);
        } else {
            container.insertChild(child, false);
        }
        return;
    }

    /**
     * inserts a child into the persisted list
     * 
     * @@param container
     *            the notational element's container
     * @@param child ,
     *            the child to insert
     * @@param index
     *            the notational element's position within the container.
     */
    static private void insertPersistedElement(View container, View child,
            int index) {
        if (child instanceof Edge) {
            Diagram diagram = (Diagram) container;
            if (index == -1)
                diagram.insertEdge((Edge) child);
            else
                diagram.insertEdgeAt((Edge) child, index);
        } else {
            if (index == -1)
                container.insertChild(child);
            else
                container.insertChildAt(child, index);
        }
    }

    /**
     * checks if the passed view is transient or exists in a transient branch
     * 
     * @@param view
     *            <code>View</code> to check
     * @@return true if transient otherwise false
     */
    static public boolean isTransient(EObject view) {
        EStructuralFeature sFeature = view.eContainingFeature();
        // root element will have a null containing feature
        if (sFeature == null)
            return false;
        if (sFeature.isTransient()) {
            return true;
        }
        EObject container = view.eContainer();
        if (container != null) {
            return isTransient(container);
        }
        return false;
    }

    /**
     * gets a the first child in the passed <code>View</code> that had the
     * same type as the passed semantic hint.
     * 
     * @@param view
     *            the view to search inside
     * @@param semanticHint
     *            the semantic hint to look for
     * @@return the found view or null if none is found
     */
    public static View getChildBySemanticHint(View view, String semanticHint) {
        for (Iterator children = view.getChildren().iterator(); children
            .hasNext();) {
            View child = (View) children.next();
            if (semanticHint.equals(child.getType())) {
                return child;
            }
        }
        return null;
    }

    /**
     * checks if the passed property is supported bythe passed view
     * 
     * @@param view
     *            the view to use for the search
     * @@param id
     *            the property to look for
     * @@return boolean <tt>true</tt> if supported otherwise <tt>false</tt>
     */
    public static boolean isPropertySupported(View view, Object id) {
        if (id instanceof String) {
            EStructuralFeature feature = (EStructuralFeature) PackageUtil
                .getElement((String) id);
            if (feature != null) {
                return isPropertySupported(view, feature, feature
                    .getEContainingClass());
            }
        }
        return false;
    }

    /**
     * checks if the passed feature is supported by the passed view
     * 
     * @@param view
     *            the view to use for the search
     * @@param feature
     *            the feature to look for
     * @@return boolean <tt>true</tt> if supported otherwise <tt>false</tt>
     */
    public static boolean isFeatureSupported(View view,
            EStructuralFeature feature) {
        if (feature != null) {
            return isPropertySupported(view, feature, feature
                .getEContainingClass());
        }
        return false;
    }

    /**
     * checks if the passed feature is supported by the passed view
     * 
     * @@param view
     *            the view to use for the search
     * @@param feature
     *            the feature to look for
     * @@param featureClass
     *            the feature's <code>EClass</code>
     * @@return boolean <tt>true</tt> if supported otherwise <tt>false</tt>
     */
    public static boolean isPropertySupported(View view,
            EStructuralFeature feature, EClass featureClass) {
        // check if the id belongs to the view
        if (view.getStyle(featureClass) != null)
            return true;

        if (view instanceof Node) {
            LayoutConstraint constraint = ((Node) view).getLayoutConstraint();
            if (constraint != null && featureClass.isInstance(constraint))
                return true;
        }

        // check if the id belongs to a style owned by the view
        return featureClass.isInstance(view);
    }

    /**
     * Returns the value of the passed feature inside the passed view
     * 
     * @@param view
     *            the view to use to get the value
     * @@param feature
     *            the feature to use
     * @@return the value of the property, or <code>null</code>
     */
    static public final Object getStructuralFeatureValue(View view,
            EStructuralFeature feature) {
        if (feature != null) {
            return ViewUtil.getPropertyValue(view, feature, feature
                .getEContainingClass());
        }
        return null;
    }

    /**
     * Returns the value of the featrue inside a specific EClass within the
     * passed view
     * 
     * @@param view
     *            the view to use to get the value
     * @@param feature
     *            the featrue to use to get the value
     * @@param featureClass
     *            the <code>EClass</code> to use to get the feature
     * @@return the value of the feature, or <code>null</code>
     */
    public static Object getPropertyValue(View view,
            EStructuralFeature feature, EClass featureClass) {
        // check if the id belongs to a style owned by the view
        Style style = view.getStyle(featureClass);
        if (style != null)
            return style.eGet(feature);

        if (view instanceof Node) {
            LayoutConstraint constraint = ((Node) view).getLayoutConstraint();
            if (constraint != null && featureClass.isInstance(constraint))
                return constraint.eGet(feature);
        }

        // check if the id belongs to the view
        if (featureClass.isInstance(view))
            return view.eGet(feature);

        return feature.getDefaultValue(); // for extra robustness
    }

    /**
     * Sets the passed feature if possible on the passed view to the passed
     * value.
     * 
     * @@param view
     *            the view to set the value on
     * @@param feature
     *            the feature to use
     * @@param value
     *            the value of the property being set
     */
    public static void setStructuralFeatureValue(View view,
            EStructuralFeature feature, Object value) {
        if (feature != null) {
            ViewUtil.setPropertyValue(view, feature, feature
                .getEContainingClass(), value);
            return;
        }
    }

    /**
     * Sets the passed featrue on the passed EClass inside the passed view to
     * the new value if possible
     * 
     * @@param view
     *            the view to set the value on
     * @@param feature
     *            the feature to set
     * @@param featureClass
     *            <code> EClass </code> that owns the feature
     * @@param value
     *            the value of the feature being set
     */
    public static void setPropertyValue(View view, EStructuralFeature feature,
            EClass featureClass, Object value) {
        if (view == null)
            return;
        // check if the id belongs to a style owned by the view
        Style style = view.getStyle(featureClass);
        if (style != null) {
            style.eSet(feature, value);
            return;
        }

        if (view instanceof Node) {
            Node node = (Node) view;
            LayoutConstraint constraint = node.getLayoutConstraint();
            if (constraint != null & featureClass.isInstance(constraint)) {
                constraint.eSet(feature, value);
                return;
            }
        }

        // check if the id belongs to the view
        if (featureClass.isInstance(view)) {
            view.eSet(feature, value);
            return;
        }
    }

    /**
     * resolves the passed <code>View<code>'s semantic element, and returns it.
     * If the semantic element is unresolvable the method will returns <code>null</code>
     * @@param view the view to use to get the semantic element
     * @@return the semanticelement or null if there is no semantic element or if it is unresolvable
     */
    public static EObject resolveSemanticElement(View view) {
        EObject element = view.getElement();
        if (element != null && element.eIsProxy()) {
            TransactionalEditingDomain domain = TransactionUtil
                .getEditingDomain(view);
d441 12
a452 15
        return element;
    }

    /**
     * resolves the passed element, and returns it. If the element is
     * unresolvable the method will returns <code>null</code>
     * 
     * @@param the
     *            element to resolve
     * @@return the element or null if it is unresolvable
     */
    public static EObject resolve(EObject object) {
        if (object != null && object.eIsProxy()) {
            TransactionalEditingDomain domain = TransactionUtil
                .getEditingDomain(object);
d455 112
a566 143
        }
        return object;
    }

    /**
     * gets the <code>View</code>'s semantic element Class Id, this could be
     * used to check the semantic element type
     * 
     * @@param view
     *            the owner of the semantic element
     * @@return the semantic element class Id
     */
    public static String getSemanticElementClassId(View view) {
        EObject element = view.getElement();
        return element == null ? null
            : PackageUtil.getID(EMFCoreUtil.getProxyClass(element));
    }

    /**
     * gets all the <code>Edge</code>'s whose source is this view
     * 
     * @@param view
     *            the view to use
     * @@return List the edges list
     */
    public static List getSourceConnections(View view) {
        if (!view.eIsSet(NotationPackage.Literals.VIEW__SOURCE_EDGES))
            return Collections.EMPTY_LIST;
        return view.getSourceEdges();
    }

    /**
     * gets all the <code>Edge</code>'s whose target is this view
     * 
     * @@param view
     *            the view to use
     * @@return List the edges list
     */
    public static List getTargetConnections(View view) {
        if (!view.eIsSet(NotationPackage.Literals.VIEW__TARGET_EDGES))
            return Collections.EMPTY_LIST;
        return view.getTargetEdges();
    }

    /**
     * return eClass Name of the view's semantic element, this method works only
     * if the semantic element is a NameElement, otherwise it will return an
     * Empty String
     * 
     * @@param view
     *            the view object
     * @@return the eClass name
     */
    public static String getSemanticEClassName(View view) {
        EObject eObject = view.getElement();
        if (eObject != null)
            return PackageUtil.getID(EMFCoreUtil.getProxyClass(eObject));
        return ""; //$NON-NLS-1$
    }

    /**
     * returns the unique GUID of the view
     * 
     * @@param view
     *            the view
     * @@return String the GUID of a view (constant)
     */
    public static String getIdStr(View view) {
        String id = ((XMLResource) view.eResource()).getID(view);
        if (id != null) {
            return id;
        }

        // Remain compatible with previous behavior.
        return StringStatics.BLANK;
    }

    /**
     * reorders the child at the oldIndex to the newIndex
     * 
     * @@param container
     *            the view's container
     * @@param child
     *            the child to reposition
     * @@param newIndex
     *            (zero-based)
     * @@throws IndexOutOfBoundsException
     *             if index is out of bounds
     * @@throws IllegalArgumentException
     *             if the child is not contianed by the container, or if the new
     *             position is the <code>ViewUtil.APPEND</code>position
     */
    static public void repositionChildAt(View container, View child,
            int newIndex) {
        ViewUtil.persistElement(child);
        if (child.eContainer() != container)
            throw new IllegalArgumentException(
                "child is not an existing child of the view"); //$NON-NLS-1$
        if (newIndex == APPEND)
            throw new IllegalArgumentException(
                "append position is not allowed for reposition"); //$NON-NLS-1$
        container.removeChild(child);
        container.insertChildAt(child, newIndex);
    }

    /**
     * returns the first child whose id matched the given id
     * 
     * @@param view
     *            the view to search in
     * @@param idStr
     *            the child's id
     * @@return View the first matching child or null if no one was found
     */
    static public View getChildByIdStr(View view, String idStr) {
        for (Iterator children = view.getChildren().iterator(); children
            .hasNext();) {
            View child = (View) children.next();
            if (idStr.equals(((XMLResource) child.eResource()).getID(child))) {
                return child;
            }
        }
        return null;
    }

    /**
     * Sets the property with the given id if possible on the passed view to the
     * passed value.
     * 
     * @@param view
     *            the view to set the value on
     * @@param id
     *            the id of the property being set
     * @@param value
     *            the value of the property being set
     * @@deprecated use
     *             {@@link ViewUtil#setStructuralFeatureValue(View, EStructuralFeature, Object}}
     *             instead
     */
    public static void setPropertyValue(View view, Object id, Object value) {
        if (id instanceof String) {
            EStructuralFeature feature = (EStructuralFeature) PackageUtil
                .getElement((String) id);
d568 1
a568 2
                ViewUtil.setPropertyValue(view, feature, feature
                    .getEContainingClass(), value);
d573 1
a573 1

d575 3
a577 7
     * Returns the value of the property with the given id inside the passed
     * view
     * 
     * @@param view
     *            the view to use to get the value
     * @@param id
     *            the id of the property to get
d579 1
a579 3
     * @@deprecated use
     *             {@@link ViewUtil#getStructuralFeatureValue(View, EStructuralFeature)}
     *             instead
d582 2
a583 3
        if (id instanceof String) {
            EStructuralFeature feature = (EStructuralFeature) PackageUtil
                .getElement((String) id);
d585 1
a585 2
                return ViewUtil.getPropertyValue(view, feature, feature
                    .getEContainingClass());
@


1.15.2.2
log
@[149689] gmf_R1_0_maintenace mmostafa 060725  Canonical edipolicy does not refresh connectors if one compartment becomes invisible.
@
text
@d546 1
a546 1
    
a558 58
    
    /**
     * gets all the <code>Edge</code>'s whose source is this view
     * 
     * @@param view
     *            the view to use
     * @@return List the edges list
     */
     public static List getSourceConnectionsConnectingVisibleViews(View view) {
        if (!view.eIsSet(NotationPackage.Literals.VIEW__SOURCE_EDGES))
            return Collections.EMPTY_LIST;
        List sourceConnections = new ArrayList();
        Iterator iter = view.getSourceEdges().iterator();
        while (iter.hasNext()) {
            Edge edge = (Edge)iter.next();
            View target = edge.getTarget();
            if (isVisible(target)){
                sourceConnections.add(edge);
            }
            
        }
        return sourceConnections;
     }
    
    

     private static boolean isVisible(View target) {
        if (target.isVisible()){
            EObject parent = target.eContainer();
            if (parent instanceof View){
                return isVisible((View)parent);
            }
            return true;
        }
        return false;
    }
     
    /**
     * gets all the <code>Edge</code>'s whose target is this view
     * 
     * @@param view
     *            the view to use
     * @@return List the edges list
     */
     public static List getTargetConnectionsConnectingVisibleViews(View view) {
        if (!view.eIsSet(NotationPackage.Literals.VIEW__TARGET_EDGES))
            return Collections.EMPTY_LIST;
        List targteConnections = new ArrayList();
        Iterator iter = view.getTargetEdges().iterator();
        while (iter.hasNext()) {
            Edge edge = (Edge)iter.next();
            View source = edge.getSource();
            if (isVisible(source)){
                targteConnections.add(edge);
            }
        }
        return targteConnections;
     }
@


1.15.2.3
log
@[150976] gmf_R1_0_maintenance mmostafa  060802 Can not hide the connectores of non-top shape
@
text
@d575 1
a575 1
            if (edge.isVisible() && isVisible(target)){
d611 1
a611 1
            if (edge.isVisible() && isVisible(source)){
@


1.15.2.4
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
@


1.14
log
@bugzilla 133387 gmf-head mmostafa 060428 ViewUtil does not resolve proxies
@
text
@a338 17

	/**
	 * Returns the value of the property with the given id inside the passed view
	 * @@param view the view to use to get the value
	 * @@param id the id of the property to get
	 * @@return the value of the property, or <code>null</code>
	 * @@deprecated use {@@link ViewUtil#getStructuralFeatureValue(View, EStructuralFeature)} instead
	 */
	static public final Object getPropertyValue(View view, Object id) {
		if(id instanceof String){
			EStructuralFeature feature = (EStructuralFeature) PackageUtil.getElement((String)id);
			if (feature != null) {
				return ViewUtil.getPropertyValue(view,feature, feature.getEContainingClass());
			}
		}
		return null;
	}
a377 18

	/**
	 * Sets the property with the given id if possible on the passed view
	 * to the passed value.
	 * @@param view the view to set the value on 
	 * @@param id  the id of the property being set
	 * @@param value  the value of the property being set
	 * @@deprecated use {@@link ViewUtil#setStructuralFeatureValue(View, EStructuralFeature, Object}} instead
	 */
	public static void setPropertyValue(View view,Object id, Object value) {
		if(id instanceof String){
			EStructuralFeature feature = (EStructuralFeature) PackageUtil.getElement((String)id);
			if (feature != null) {
				ViewUtil.setPropertyValue(view,feature, feature.getEContainingClass(), value);
				return;
			}
		}
	}
d431 1
a431 1
     * @@return the semanticelement or null if there is no semantic element or if it is unresolvable
d448 1
a448 1
     * @@return the element or null if it is unresolvable
d456 2
a457 2
	    return object;
	}
d556 34
@


1.13
log
@[132592] gmf_head ahunter 060320 NPE in ViewUtil.resolveSemanticElement(View view)
@
text
@d466 1
a466 1
	 * @@return the semanticelement or null if there is no semantic element or if it is unresolvable
d483 1
a483 1
	 * @@return the element or null if it is unresolvable
d486 4
a489 5
		if (object!=null){
			if (object.eIsProxy())
				return EMFCoreUtil.resolve(TransactionUtil.getEditingDomain(object), object);
			else
				return object;
d491 1
a491 1
	    return null;
@


1.12
log
@bugzilla 128977 gmf-head mmostafa 060309 Adopt transaction API in diagram event broker API and CanonicalEditPolicy API
@
text
@d470 6
a475 2
	    if (element!=null && element.eIsProxy())
	    	return EMFCoreUtil.resolve(TransactionUtil.getEditingDomain(view), element);
@


1.11
log
@bugzilla 128977 gmf-head mmostafa 060309 Adopt transaction API in diagram event broker API and CanonicalEditPolicy API
@
text
@a19 1
import java.util.Map;
a26 1
import org.eclipse.emf.transaction.Transaction;
a97 2
				Map options = Collections.singletonMap(	Transaction.OPTION_UNPROTECTED, Boolean.TRUE);

d99 1
a99 2
					new PersistElementCommand(editingDomain, viewToPersist , options);
                
a101 1
                    
@


1.10
log
@[129773] gmf_head cdamus 060306 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@d97 1
a97 1
			View viewToPersist = getViewToPersist(view);
d103 1
a103 1
					new PersistElementCommand(editingDomain, viewToPersist, options);
d124 1
a124 1
	 * helper method used to get the first view needs to be persisted,
d131 1
a131 1
	static private View getViewToPersist(View view) {
d147 1
a147 1
				return (getViewToPersist(dContainer)); 
d158 1
a158 1
				return (getViewToPersist(vContainer));
@


1.9
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@a17 1
import java.util.HashMap;
d42 1
d177 1
a177 1
		EMFCoreUtil.destroy(view);
@


1.8
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d18 1
d21 1
d28 4
a31 1
import org.eclipse.emf.transaction.impl.InternalTransactionalEditingDomain;
d34 1
d40 1
a40 2
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;
d42 1
a42 3
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
import org.eclipse.gmf.runtime.emf.core.util.MetaModelUtil;
import org.eclipse.gmf.runtime.emf.core.util.ProxyUtil;
d77 1
a77 1
	
d92 2
a93 1
		MEditingDomain editingDomain = MEditingDomainGetter.getMEditingDomain(view);
d100 2
d103 1
a103 1
					new PersistElementCommand(editingDomain, viewToPersist);
a116 1
				editingDomain.setCanRedoCurrentInterval( false );
d122 1
a122 1

d177 1
a177 1
		EObjectUtil.destroy(view);
d303 1
a303 1
			EStructuralFeature feature = (EStructuralFeature) MetaModelUtil.getElement((String)id);
d355 1
a355 1
			EStructuralFeature feature = (EStructuralFeature) MetaModelUtil.getElement((String)id);
d412 1
a412 1
			EStructuralFeature feature = (EStructuralFeature) MetaModelUtil.getElement((String)id);
d477 1
a477 1
	    	return ProxyUtil.resolve(MEditingDomainGetter.getMEditingDomain(view), element);
d490 1
a490 1
				return ProxyUtil.resolve(MEditingDomainGetter.getMEditingDomain(object), object);
d505 1
a505 1
	    return element == null ? null : ProxyUtil.getProxyClassID(element);
d540 1
a540 1
			return ProxyUtil.getProxyClassID(eObject);
d550 7
a556 1
		return EObjectUtil.getID( view );
d587 1
a587 1
			if ( idStr.equals( EObjectUtil.getID(child))) {
@


1.7
log
@ bugzilla 111894 gmf-head mmostafa 051201 Improve memory consumption of opened notation diagram
@
text
@d21 1
d26 1
d28 5
d90 2
a91 2
		if (editingDomain.isUndoIntervalOpen() &&
			!view.isMutable()) {
d97 14
a110 2
					new PersistElementCommand(viewToPersist);
				pvc.execute( new NullProgressMonitor() );
@


1.6
log
@Bugzilla 109092: gmf_head sshaw 050923 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d457 16
@


1.5
log
@Bugzilla 109092: gmf_head sshaw 050922 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
Contributed by Mohammed Mostafa
@
text
@d327 1
a327 1
	 * @@deprecated use {@@link ViewUtil#getPropertyValue(View, EStructuralFeature, EClass)} instead
d340 13
d384 1
a384 1
	 * @@deprecated use {@@link ViewUtil#setPropertyValue(View, EStructuralFeature, EClass, Object)} instead
d395 14
@


1.4
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a24 1

a27 2
import org.eclipse.gmf.runtime.diagram.core.listener.PresentationListener;
import org.eclipse.gmf.runtime.diagram.core.listener.PropertyChangeNotifier;
d290 13
d327 1
d371 1
a441 11
	 * Retrieves the view's property change notifier object
	 * @@param view the view to use to get the notifier
	 * @@return the property change notifier
	 * @@deprecated the PropertyChangeNotifier is deprecated, to add a listner to the 
	 * <code>PresentationListener</code>use <code>PresentationListener.addPropertyChangeListener()</code>
	 */
	public static PropertyChangeNotifier getPropertyChangeNotifier(View view) {
		return PresentationListener.getNotifier(view);
	}
	
	/**
@


1.3
log
@Bugzilla109092 : rmp_head mmostafa 050912 : API Analysis: Diagram layer API.  Determine if all API is needed and/or has appropriate signatures
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d431 2
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d34 7
a40 7
import com.ibm.xtools.notation.Diagram;
import com.ibm.xtools.notation.Edge;
import com.ibm.xtools.notation.LayoutConstraint;
import com.ibm.xtools.notation.Node;
import com.ibm.xtools.notation.NotationPackage;
import com.ibm.xtools.notation.Style;
import com.ibm.xtools.notation.View;
@

