head	1.25;
access;
symbols
	v20081020-0700:1.25
	v20081015-1925:1.25
	v20081015-1755:1.25
	v20081008-1925:1.25
	v20081008-1755:1.25
	v20080903-1520:1.25
	v20080903-1510:1.25
	v20080807-1333:1.25
	v20080807-1325:1.25
	v20080731-1520:1.25
	v20080725-1738:1.25
	v20080722-1827:1.25
	R2_1_maintenance:1.25.0.2
	Root_R2_1_maintenance:1.25
	R2_1_0:1.25
	v20080425-1959:1.25
	v20080328-1605:1.25
	v20080222-1200:1.25
	v20080107-1111:1.25
	v20071214-1111:1.25
	v20071130-1111:1.25
	v20071108-0000:1.25
	v20071003-0000:1.25
	v20070915-0000:1.24.4.1
	v20070809-0000:1.24
	R2_0_maintenance:1.24.0.4
	R2_0:1.24
	R4_20:1.24
	RC3_20:1.24
	v20070601-1400:1.24
	v20070518-1300:1.24
	bugzilla111892_group_support:1.24.0.2
	Root_bugzilla111892_group_support:1.24
	v20070420-1000:1.23
	v20070405-2000:1.22
	v20070330-1300:1.22
	v20070208-1800:1.22
	M4_20:1.20
	v20061214-0000:1.20
	M3_20:1.19
	v20061027-1200:1.18.2.6
	v20061013-1330:1.19
	v20060919-0800:1.18.2.4
	v20060907-1100:1.18.2.4
	M1_20:1.18
	v20060831-1500:1.18.2.4
	v20060817-1500:1.18.2.3
	v20060810-1700:1.18.2.3
	v20060803-1200:1.18.2.3
	v20060728-0500:1.18.2.3
	v20060721-1130:1.18.2.1
	v20060713-1700:1.18.2.1
	R1_0_maintenance:1.18.0.2
	R1_0:1.18
	v20060627-1200:1.18
	v20060616-1200:1.18
	v20060609-1400:1.18
	v20060531-1730:1.16
	v20060519-0800:1.15
	v20060512-1000:1.14
	I20060512-1000:1.14
	I20060505-1400:1.13
	I20060428-1300:1.13
	I20060424-0500:1.13
	I20060424-0300:1.12
	M6_10:1.12
	I20060407-1200:1.12
	I20060331-1000:1.12
	I20060324-0300:1.11
	I20060317-1300:1.10
	I20060317-1200:1.10
	I20060316-1300:1.10
	I20060309-1300:1.10
	M5_10:1.9
	S20060303-1600:1.9
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.4
	I20060209-1815:1.4
	I20060203-0830:1.4
	I20060129-1145:1.4
	I20060127-0900:1.4
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.4
	I20051223-1100:1.4
	I20051217-0925:1.4
	I20051201-1800:1.3
	I20051124-2000:1.3
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.25
date	2007.09.13.16.48.26;	author ahunter;	state Exp;
branches;
next	1.24;
commitid	675246e969da4567;

1.24
date	2007.05.11.22.19.00;	author mmostafa;	state Exp;
branches
	1.24.4.1;
next	1.23;
commitid	45c34644ebd24567;

1.23
date	2007.04.13.20.48.50;	author mmostafa;	state Exp;
branches;
next	1.22;
commitid	26b1461fecae4567;

1.22
date	2007.01.31.18.26.39;	author mmostafa;	state Exp;
branches;
next	1.21;
commitid	5d2945c0df5f4567;

1.21
date	2007.01.03.16.26.14;	author ahunter;	state Exp;
branches;
next	1.20;
commitid	4d95459bd9244567;

1.20
date	2006.11.23.21.11.48;	author mmostafa;	state Exp;
branches;
next	1.19;
commitid	2a5945660e934567;

1.19
date	2006.10.03.15.01.44;	author ahunter;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.06.15.49.07;	author mmostafa;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2006.06.05.18.20.10;	author mmostafa;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.31.16.26.08;	author sshaw;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.12.21.21.10;	author sshaw;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.09.21.56.30;	author mmostafa;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.21.21.24.51;	author mmostafa;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.30.17.49.58;	author vramaswamy;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.23.22.05.22;	author vramaswamy;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.09.20.51.39;	author mmostafa;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.01.22.49.10;	author cmahoney;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.01.17.55.49;	author mmostafa;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.28.02.56.42;	author cmahoney;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.28.02.31.23;	author cmahoney;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.13.19.12.29;	author ldamus;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.14.19.17.06;	author mmostafa;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.21.16.11.41;	author cmahoney;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.09.23.38.45;	author mmostafa;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.02.23.29.21;	author sshaw;	state Exp;
branches;
next	;

1.18.2.1
date	2006.07.11.15.51.18;	author mmostafa;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2006.07.25.19.05.30;	author mmostafa;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2006.07.26.21.44.38;	author mmostafa;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2006.08.31.15.09.57;	author mmostafa;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2006.10.26.15.17.47;	author mmostafa;	state Exp;
branches;
next	1.18.2.6;

1.18.2.6
date	2006.10.27.14.24.13;	author ahunter;	state Exp;
branches;
next	;

1.24.4.1
date	2007.09.13.16.17.32;	author ahunter;	state Exp;
branches;
next	;
commitid	59b846e9629c4567;


desc
@@


1.25
log
@[203302] gmf_head ahunter 070913 DiagramEventBroker performance problems with handleNotificationOnAddedElement and handleNotificationOnDeletedElement
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.core.listener;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

import org.eclipse.emf.common.command.Command;
import org.eclipse.emf.common.command.CompoundCommand;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.transaction.NotificationFilter;
import org.eclipse.emf.transaction.ResourceSetChangeEvent;
import org.eclipse.emf.transaction.ResourceSetListenerImpl;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.workspace.EMFOperationCommand;
import org.eclipse.gmf.runtime.diagram.core.internal.commands.PersistViewsCommand;
import org.eclipse.gmf.runtime.diagram.core.services.DiagramEventBrokerService;
import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
import org.eclipse.gmf.runtime.notation.NotationPackage;
import org.eclipse.gmf.runtime.notation.View;



/**
 * A model server listener that broadcast EObject events to all registered
 * listeners.
 * 
 * @@author melaasar, mmostafa, cmahoney
 */
public class DiagramEventBroker
    extends ResourceSetListenerImpl {

    private static String LISTEN_TO_ALL_FEATURES = "*"; //$NON-NLS-1$

    /** listener map */
    private final NotifierToKeyToListenersSetMap preListeners = new NotifierToKeyToListenersSetMap();

    private final NotifierToKeyToListenersSetMap postListeners = new NotifierToKeyToListenersSetMap();

    private static final Map instanceMap = new WeakHashMap();
    
    private WeakReference editingDomainRef;
    
    /**
     * returns the pre commit listeners map
     * @@return pre commit listeners map
     */
    protected NotifierToKeyToListenersSetMap getPreCommitListenersMap() {
        return preListeners;
    }
    
    /**
     * returns the post commit listeners map
     * @@return post commit listeners map
     */
    protected NotifierToKeyToListenersSetMap getPostCommitListenersMap() {
        return postListeners;
    }

    /**
     * Utility class representing a Map of Notifier to a Map of Keys to a Set of
     * listener
     * 
     * @@author mmostafa
     */
    public final class NotifierToKeyToListenersSetMap {

        /**
         * internal map to hold the listeners
         */
        private final Map listenersMap = new WeakHashMap();

        /**
         * Adds a listener to the map
         * 
         * @@param notifier
         *            the notifier the listener will listen to
         * @@param key
         *            a key for the listener, this help in categorizing the
         *            listeners based on their interest
         * @@param listener
         *            the listener
         */
        public void addListener(EObject notifier, Object key, Object listener) {
            Map keys = (Map) listenersMap.get(notifier);
            if (keys == null) {
                keys = new HashMap(4);
                listenersMap.put(notifier, keys);
            }
            Map listenersSet = (Map) keys.get(key);
            if (listenersSet == null) {
                listenersSet = new LinkedHashMap(4);
                keys.put(key, listenersSet);
            }
            listenersSet.put(listener,null);
        }

        /**
         * Adds a listener to the notifier; this listener is added againest a
         * generic key, <code>LISTEN_TO_ALL_FEATURES<code>
         * so it can listen to all events on the notifier 
         * @@param notifier the notifier the listener will listen to
         * @@param listener the listener
         */
        public void addListener(EObject notifier, Object listener) {
            addListener(notifier, LISTEN_TO_ALL_FEATURES, listener);
        }

        /**
         * removes a listener from the map
         * 
         * @@param notifier
         * @@param key
         * @@param listener
         */
        public void removeListener(EObject notifier, Object key, Object listener) {
            Map keys = (Map) listenersMap.get(notifier);
            if (keys != null) {
                Map listenersSet = (Map) keys.get(key);
                if (listenersSet != null) {
                    listenersSet.remove(listener);
                    if (listenersSet.isEmpty()) {
                        keys.remove(key);
                    }
                }
                if (keys.isEmpty())
                    listenersMap.remove(notifier);
            }
        }

        /**
         * get listeners interested in the passed notifier and key
         * 
         * @@param notifier
         * @@param key
         * @@return <code>Set</code> of listeners
         */
        public Set getListeners(Object notifier, Object key) {
            Map keys = (Map) listenersMap.get(notifier);
            if (keys != null) {
                Map listenersSet = (Map) keys.get(key);
                if (listenersSet != null) {
                    return listenersSet.keySet();
                }
            }
            return Collections.EMPTY_SET;
        }

        /**
         * return all listeners interested in the passed notifier
         * 
         * @@param notifier
         * @@return
         */
        public Set getAllListeners(Object notifier) {
            Map keys = (Map) listenersMap.get(notifier);
            if (keys == null || keys.isEmpty()) {
                return Collections.EMPTY_SET;
            }
            Set listenersCollection = new LinkedHashSet();
            Set enteries = keys.entrySet();
            for (Iterator iter = enteries.iterator(); iter.hasNext();) {
                Map.Entry entry = (Map.Entry) iter.next();
                Map listenersSet = (Map) entry.getValue();
                if (listenersSet != null && !listenersSet.isEmpty())
                    listenersCollection.addAll(listenersSet.keySet());
            }
            return listenersCollection;
        }
        
        public boolean isEmpty() {
            return listenersMap.isEmpty();
        }
    }

    /**
     * Creates a <code>DiagramEventBroker</code> that listens to all
     * <code>EObject </code> notifications for the given editing domain.
     */
    protected DiagramEventBroker() {
        super(NotificationFilter.createNotifierTypeFilter(EObject.class));
    }    
    

    /**
     * Gets the diagmam event broker instance for the editing domain passed in.
     * There is one diagram event broker per editing domain.
     * 
     * @@param editingDomain
     * @@return Returns the diagram event broker.
     */
    public static DiagramEventBroker getInstance(
            TransactionalEditingDomain editingDomain) {
    	
    	return initializeDiagramEventBroker(editingDomain);
    }

    /**
     * Creates a new diagram event broker instance for the editing domain passed
     * in only if the editing domain does not already have a diagram event
     * broker. There is one diagram event broker per editing domain. Adds the
     * diagram event broker instance as a listener to the editing domain.
     * 
     * @@param editingDomain
     */
    public static void startListening(TransactionalEditingDomain editingDomain) {
    	initializeDiagramEventBroker(editingDomain);
    }

	private static DiagramEventBroker initializeDiagramEventBroker(TransactionalEditingDomain editingDomain) {
        WeakReference reference = (WeakReference) instanceMap.get(editingDomain);
        if (reference == null) {
            DiagramEventBroker diagramEventBroker = DiagramEventBrokerService.getInstance().createDiagramEventBroker(editingDomain);
            if (null == diagramEventBroker)
                diagramEventBroker = debFactory.createDiagramEventBroker(editingDomain);
            if (diagramEventBroker.editingDomainRef == null) {
				diagramEventBroker.editingDomainRef = new WeakReference(
					editingDomain);
			}
            editingDomain.addResourceSetListener(diagramEventBroker);
            reference = new WeakReference(diagramEventBroker);
            instanceMap.put(editingDomain, reference);
        }
        return (DiagramEventBroker) reference.get();
	}
    
    /**
     * Factory interface that can be used to create overrides of the DiagramEventBroker class
     * @@author sshaw
     */
    public static interface DiagramEventBrokerFactory {
    	/**
    	 * @@param editingDomain the <code>TransactionalEditingDomain</code> that is associated
    	 * with the <code>DiagramEventBroker</code> instance.
    	 * @@return the <code>DiagramEventBroker</code> instance.
    	 */
    	public DiagramEventBroker createDiagramEventBroker(TransactionalEditingDomain editingDomain); 
    }
    
    private static class DiagramEventBrokerFactoryImpl implements DiagramEventBrokerFactory {
    	public DiagramEventBroker createDiagramEventBroker(TransactionalEditingDomain editingDomain) {
            DiagramEventBroker diagramEventBroker =  new DiagramEventBroker();
            diagramEventBroker.editingDomainRef = new WeakReference(
                editingDomain);
            return diagramEventBroker;
    	}
    }
    
    private static DiagramEventBrokerFactory debFactory = new DiagramEventBrokerFactoryImpl();
    
    /**
     * @@param newDebFactory
     */
    public static void registerDiagramEventBrokerFactory(DiagramEventBrokerFactory newDebFactory) {
    	debFactory = newDebFactory;
    }

    /**
     * @@param editingDomain
     */
    public static void stopListening(TransactionalEditingDomain editingDomain) {
        DiagramEventBroker diagramEventBroker = getInstance(editingDomain);
        if (diagramEventBroker != null) {
            editingDomain.removeResourceSetListener(diagramEventBroker);
            instanceMap.remove(editingDomain);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.emf.transaction.ResourceSetListenerImpl#transactionAboutToCommit(org.eclipse.emf.transaction.ResourceSetChangeEvent)
     */
    public Command transactionAboutToCommit(ResourceSetChangeEvent event) {
        Set deletedObjects = NotificationUtil.getDeletedObjects(event);
        Set addedObjects = NotificationUtil.getAddedObjects(event);
        Set existingObjects = new HashSet();
        Set elementsInPersistQueue = new LinkedHashSet();
        CompoundCommand cc = new CompoundCommand();
        TransactionalEditingDomain editingDomain = (TransactionalEditingDomain) editingDomainRef
            .get();
        boolean hasPreListeners = (preListeners.isEmpty() == false);
        List viewsToPersistList = new ArrayList();
        boolean deleteElementCheckRequired = !deletedObjects.isEmpty();
        for (Iterator i = event.getNotifications().iterator(); i.hasNext();) {
            final Notification notification = (Notification) i.next();
            if (shouldIgnoreNotification(notification))
                continue;
            Object notifier = notification.getNotifier();            
            if (notifier instanceof EObject) {
                boolean deleted = false;
                if (deleteElementCheckRequired){
                    deleted = !existingObjects.contains(notifier);
                    if (deleted){
                        deleted = isDeleted(deletedObjects, (EObject)notifier);
                        if (!deleted)
                            existingObjects.add(notifier);
                    }
                }
                // see bugzilla [186637]
            	if (deleted || 
                     (addedObjects.contains(notifier) && NotationPackage.Literals.VIEW__ELEMENT.equals(notification.getFeature()))) {
                    continue;
                }
                if (editingDomain != null) {
                    View viewToPersist = getViewToPersist(notification,
                        elementsInPersistQueue);
                    if (viewToPersist != null) {
                        viewsToPersistList.add(viewToPersist);
                    }
                }
                if (hasPreListeners) {
                    Command cmd = fireTransactionAboutToCommit(notification);
                    if (cmd != null) {
                        cc.append(cmd);
                    }
                }
            }
        }

        if (viewsToPersistList.isEmpty() == false) {
            PersistViewsCommand persistCmd = new PersistViewsCommand(
                editingDomain, viewsToPersistList);
            cc.append(new EMFOperationCommand(editingDomain, persistCmd));
        }

        return cc.isEmpty() ? null
            : cc;
    }
    
    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.emf.transaction.ResourceSetListenerImpl#resourceSetChanged(org.eclipse.emf.transaction.ResourceSetChangeEvent)
     */
    public void resourceSetChanged(ResourceSetChangeEvent event) {
    	if (postListeners.isEmpty()) {
            return;
        }
        Set deletedObjects = NotificationUtil.getDeletedObjects(event);
        Set addedObjects = NotificationUtil.getAddedObjects(event);
        Set existingObjects = new HashSet();
        boolean deleteElementCheckRequired = !deletedObjects.isEmpty();
        boolean handleNotificationOnAddedElement = false;
        boolean handleNotificationOnDeletedElement = false;
        for (Iterator i = event.getNotifications().iterator(); i.hasNext();) {
            final Notification notification = (Notification) i.next();
            boolean customNotification = NotificationUtil.isCustomNotification(notification);
            if (!customNotification && shouldIgnoreNotification(notification))
                continue;
            Object notifier = notification.getNotifier();
            if (notifier instanceof EObject) {
                boolean deleted = false;
                if (deleteElementCheckRequired && !customNotification) {
                    deleted = !existingObjects.contains(notifier);
                    if (deleted) {
                        deleted = isDeleted(deletedObjects, (EObject) notifier);
                        if (!deleted)
                            existingObjects.add(notifier);
                    }
                }
                if (!customNotification) {
                    if (deleted) {
                        handleNotificationOnDeletedElement = true;
                        continue;
                    }// see bugzilla [186637]
                    else if (addedObjects.contains(notifier) && NotationPackage.Literals.VIEW__ELEMENT.equals(notification.getFeature())){
                        handleNotificationOnAddedElement = true;
                        continue;
                    }
                }
                fireNotification(notification);
            }
        }
        if (handleNotificationOnAddedElement) {
            handleNotificationOnAddedElement(event);
        }
        if (handleNotificationOnDeletedElement) {
            handleNotificationOnDeletedElement(event);
        }
    }

    /**
     * This method allows clients to customize the Diagram event broker behavior when
     * it comes to handling events on added objects.
     * The default behavior will just ignore them
     * @@param event being handled
     */
    protected void handleNotificationOnAddedElement(ResourceSetChangeEvent event) {
        // default implementation does nothing
        
    }

    /**
     * This method allows clients to customize the Diagram event broker behavior when
     * it comes to handling events on deleted objects.
     * The default behavior will just ignore them
     * @@param event event being handled
     */
    protected void handleNotificationOnDeletedElement(ResourceSetChangeEvent event) {
        // default implementation does nothing
        
    }


    /**
     * decide if the passed object is deleted or not; the decision is done by 
     * checking is the passed notifier or any of its ancestors exists in the passed
     * deletedObjects Set, if it find the obnject to be deleted it will add it 
     * to the deleted objects set.
     * @@param deletedObjects
     * @@param notifier
     * @@return
     */
    protected boolean isDeleted(Set deletedObjects, EObject notifier) {
        EObject object = notifier;
        while (object!=null){
            if (deletedObjects.contains(object)){
                if (object != notifier){
                    //so we do not waste time on the second call
                    addDeletedBranch(deletedObjects,notifier);
                }
                return true;
            }
            object = object.eContainer();
        }
        return false;
    }
    
    private void addDeletedBranch(Set deletedObjects, EObject notifier) {
        EObject object = notifier;
        while (object != null){
            if (!deletedObjects.add(object)){
                break;
            }
            object = object.eContainer();
        }
        
    }


    /**
     * determine if the passed notification can be ignored or not the default
     * implementation will ignore touch event if it is not a resolve event, also
     * it will ignore the mutable feature events
     * 
     * @@param notification
     *            the notification to check
     * @@return true if the notification should be ignored, otherwise false
     */
    protected boolean shouldIgnoreNotification(Notification notification) {
        if ((notification.isTouch() && notification.getEventType() != Notification.RESOLVE)
            || NotationPackage.eINSTANCE.getView_Mutable().equals(
                notification.getFeature())) {
            return true;
        }
        return false;
    }

    /**
     * Forward the supplied event to all listeners listening on the supplied
     * target element.
     * <P>
     * <B> Note, for the MSL migration effort, each listener will be forwarded 2
     * events. First, a MSL complient Notification event followed by an
     * ElementEvent (for backwards compatibility). The ElementEvent will be
     * removed one the MSL migration is complete.
     */
    protected void fireNotification(Notification event) {
        Collection listenerList = getInterestedNotificationListeners(event,
        	postListeners);
        if (!listenerList.isEmpty()) {			
			for (Iterator listenerIT = listenerList.iterator(); listenerIT
				.hasNext();) {
				NotificationListener listener = (NotificationListener) listenerIT
					.next();
				listener.notifyChanged(event);
			}
		}
    }

    /**
     * Forwards the event to all interested listeners.
     * 
     * @@param event
     *            the event to handle
     * @@p
     */
    private Command fireTransactionAboutToCommit(Notification event) {
        Collection listenerList = getInterestedNotificationListeners(event,
            preListeners);       
        if (!listenerList.isEmpty()) {
        	 CompoundCommand cc = new CompoundCommand();            
            for (Iterator listenerIT = listenerList.iterator(); listenerIT
                .hasNext();) {
                NotificationPreCommitListener listener = (NotificationPreCommitListener) listenerIT
                    .next();
                Command cmd = listener.transactionAboutToCommit(event);
                if (cmd != null) {
                    cc.append(cmd);
                }
            }
            return cc.isEmpty() ? null
            : cc;
        }
		return null;        
    }

    private View getViewToPersist(Notification event, Set elementsInPersistQueue) {
        if (!event.isTouch()) {
            EObject elementToPersist = (EObject) event.getNotifier();
            while (elementToPersist != null
                && !(elementToPersist instanceof View)) {
                elementToPersist = elementToPersist.eContainer();
            }
            if (elementToPersist != null
                && !elementsInPersistQueue.contains(elementToPersist)
                && ViewUtil.isTransient(elementToPersist)) {
                if (!NotificationFilter.READ.matches(event)) {
                    elementsInPersistQueue.add(elementToPersist);
                    View view = (View) elementToPersist;
                    if (!view.isMutable()) {
                        // get Top view needs to get persisted
                        View viewToPersist = ViewUtil.getTopViewToPersist(view);
                        if (viewToPersist != null) {                            
                            elementsInPersistQueue.add(viewToPersist);
                            return viewToPersist;
                        }
                    }
                }
            }
        }
        return null;
    }

    /**
     * Add the supplied <tt>listener</tt> to the listener list.
     * 
     * @@param target
     *            the traget to listen to
     * @@param listener
     *            the listener
     */
    public void addNotificationListener(EObject target,
            NotificationPreCommitListener listener) {
        if (target != null) {
            preListeners.addListener(target, LISTEN_TO_ALL_FEATURES, listener);
        }
    }

    /**
     * Add the supplied <tt>listener</tt> to the listener list.
     * 
     * @@param target
     *            the traget to listen to
     * @@param listener
     *            the listener
     */
    public void addNotificationListener(EObject target,
            NotificationListener listener) {
        if (target != null) {
            postListeners.addListener(target, LISTEN_TO_ALL_FEATURES, listener);
        }
    }

    /**
     * Add the supplied <tt>listener</tt> to the listener list.
     * 
     * @@param target
     *            the traget to listen to
     * @@param key
     *            the key for the listener
     * @@param listener
     *            the listener
     */
    public void addNotificationListener(EObject target,
            EStructuralFeature key, NotificationPreCommitListener listener) {
        if (target != null) {
            preListeners.addListener(target, key, listener);
        }
    }

    /**
     * Add the supplied <tt>listener</tt> to the listener list.
     * 
     * @@param target
     *            the traget to listen to
     * @@param key
     *            the key for the listener
     * @@param listener
     *            the listener
     */
    public void addNotificationListener(EObject target,
            EStructuralFeature key, NotificationListener listener) {
        if (target != null) {
            postListeners.addListener(target, key, listener);
        }
    }

    /**
     * remove the supplied <tt>listener</tt> from the listener list.
     * 
     * @@param target
     *            the traget to listen to
     * @@param listener
     *            the listener
     */
    public void removeNotificationListener(EObject target,
            NotificationPreCommitListener listener) {
        if (target != null) {
            preListeners.removeListener(target, LISTEN_TO_ALL_FEATURES,
                listener);
        }
    }

    /**
     * remove the supplied <tt>listener</tt> from the listener list.
     * 
     * @@param target
     *            the traget to listen to
     * @@param listener
     *            the listener
     */
    public void removeNotificationListener(EObject target,
            NotificationListener listener) {
        if (target != null) {
            postListeners.removeListener(target, LISTEN_TO_ALL_FEATURES,
                listener);
        }
    }

    /**
     * remove the supplied <tt>listener</tt> from the listener list.
     * 
     * @@param target
     *            the traget to listen to
     * @@param key
     *            the key for the listener
     * @@param listener
     *            the listener
     */
    public void removeNotificationListener(EObject target, Object key,
            NotificationPreCommitListener listener) {
        if (target != null) {
            preListeners.removeListener(target, key, listener);
        }
    }

    /**
     * remove the supplied <tt>listener</tt> from the listener list.
     * 
     * @@param target
     *            the traget to listen to
     * @@param key
     *            the key for the listener
     * @@param listener
     *            the listener
     */
    public void removeNotificationListener(EObject target, Object key,
            NotificationListener listener) {
        if (target != null) {
            postListeners.removeListener(target, key, listener);
        }
    }

    private Set getNotificationListeners(Object notifier, NotifierToKeyToListenersSetMap listeners) {       
        return listeners.getListeners(notifier, LISTEN_TO_ALL_FEATURES);
    }

    /**
     * @@param notifier
     * @@param key
     * @@param preCommit
     * @@return
     */
    private Set getNotificationListeners(Object notifier, Object key,
    		NotifierToKeyToListenersSetMap listeners) {
        if (key != null) {
            if (!key.equals(LISTEN_TO_ALL_FEATURES)) {
                Set listenersSet = new LinkedHashSet();
                Collection c = listeners.getListeners(notifier, key);
                if (c != null && !c.isEmpty())
                    listenersSet.addAll(c);
                c = listeners.getListeners(notifier, LISTEN_TO_ALL_FEATURES);
                if (c != null && !c.isEmpty())
                    listenersSet.addAll(c);
                return listenersSet;
            } else if (key.equals(LISTEN_TO_ALL_FEATURES)) {
                return listeners.getAllListeners(notifier);
            }
        }
        return listeners.getAllListeners(notifier);
    }

    /**
     * gets a subset of all the registered listeners who are interested in
     * receiving the supplied event.
     * 
     * @@param event
     *            the event to use
     * @@return the interested listeners in the event
     */
     protected Set getInterestedNotificationListeners(Notification event,
    		NotifierToKeyToListenersSetMap listeners) {
        Set listenerSet = new LinkedHashSet();

        Collection c = getNotificationListeners(event.getNotifier(), event
            .getFeature(), listeners);
        if (c != null) {
            listenerSet.addAll(c);
        }

        EObject notifier = (EObject) event.getNotifier();
        // the Visibility Event get fired to all interested listeners in the
        // container
        if (NotationPackage.eINSTANCE.getView_Visible().equals(
            event.getFeature())
            && notifier.eContainer() != null) {
            listenerSet.addAll(getNotificationListeners(notifier.eContainer(),
            	listeners));
        } else if (notifier instanceof EAnnotation) {
            addListenersOfNotifier(listenerSet, notifier.eContainer(), event,
            	listeners);
        } else if (!(notifier instanceof View)) {
            while (notifier != null && !(notifier instanceof View)) {
                notifier = notifier.eContainer();
            }
            addListenersOfNotifier(listenerSet, notifier, event, listeners);
        }
        return listenerSet;
    }
    
    public boolean isAggregatePrecommitListener() {
    	return true;
    }
    
    /**
     * Helper method to add all the listners of the given <code>notifier</code>
     * to the list of listeners
     * 
     * @@param listenerSet
     * @@param notifier
     */
    private void addListenersOfNotifier(Set listenerSet, EObject notifier,
            Notification event, NotifierToKeyToListenersSetMap listeners) {
        if (notifier != null) {
            Collection c = getNotificationListeners(notifier, event
                .getFeature(), listeners);
            if (c != null) {
                if (listenerSet.isEmpty())
                    listenerSet.addAll(c);
                else {
                    Iterator i = c.iterator();
                    while (i.hasNext()) {
                        Object o = i.next();
                        listenerSet.add(o);
                    }
                }
            }
        }
    }    
    
}
@


1.24
log
@[186637] gmf_head mmostafa 070511 View#setElement is not undone
@
text
@d367 2
d377 1
a377 1
                if (deleteElementCheckRequired && !customNotification){
d379 2
a380 2
                    if (deleted){
                        deleted = isDeleted(deletedObjects, (EObject)notifier);
d386 2
a387 2
                    if (deleted){
                        handleNotificationOnDeletedElement(event);
d391 1
a391 1
                        handleNotificationOnAddedElement(event);
d398 6
@


1.24.4.1
log
@[203302] gmf_R2_0_maintenance ahunter 070913 DiagramEventBroker performance problems with handleNotificationOnAddedElement and handleNotificationOnDeletedElement
@
text
@a366 2
        boolean handleNotificationOnAddedElement = false;
        boolean handleNotificationOnDeletedElement = false;
d375 1
a375 1
                if (deleteElementCheckRequired && !customNotification) {
d377 2
a378 2
                    if (deleted) {
                        deleted = isDeleted(deletedObjects, (EObject) notifier);
d384 2
a385 2
                    if (deleted) {
                        handleNotificationOnDeletedElement = true;
d389 1
a389 1
                        handleNotificationOnAddedElement = true;
a395 6
        if (handleNotificationOnAddedElement) {
            handleNotificationOnAddedElement(event);
        }
        if (handleNotificationOnDeletedElement) {
            handleNotificationOnDeletedElement(event);
        }
@


1.23
log
@[163393] gmf_head mmostafa 070413 Extensibility for DiagramEventBroker broken
@
text
@d299 1
d323 3
a325 1
            	if (deleted) {
d364 1
d383 9
a391 3
                if (!customNotification && deleted) {
                    handleNotificationOnDeletedElement(event);
                    continue;
a392 1

d398 10
@


1.22
log
@[163393]  gmf_head mmostafa 070131 Extensibility for DiagramEventBroker broken
@
text
@d40 1
d234 5
a238 3
		WeakReference reference = (WeakReference) instanceMap.get(editingDomain);
		if (reference == null) {
            DiagramEventBroker diagramEventBroker = debFactory.createDiagramEventBroker(editingDomain);
d247 1
a247 2
		
		return (DiagramEventBroker) reference.get();
@


1.21
log
@[162125] gmf_head ahunter 070103 Fix copyright
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d65 16
d88 1
a88 1
    private final class NotifierToKeyToListenersSetMap {
d378 1
d389 12
d409 1
a409 1
    private boolean isDeleted(Set deletedObjects, EObject notifier) {
d463 1
a463 1
    private void fireNotification(Notification event) {
d538 1
a538 1
    public final void addNotificationListener(EObject target,
d553 1
a553 1
    public final void addNotificationListener(EObject target,
d570 1
a570 1
    public final void addNotificationListener(EObject target,
d587 1
a587 1
    public final void addNotificationListener(EObject target,
d602 1
a602 1
    public final void removeNotificationListener(EObject target,
d618 1
a618 1
    public final void removeNotificationListener(EObject target,
d636 1
a636 1
    public final void removeNotificationListener(EObject target, Object key,
d653 1
a653 1
    public final void removeNotificationListener(EObject target, Object key,
d697 1
a697 1
    final protected Set getInterestedNotificationListeners(Notification event,
@


1.20
log
@[162125] gmf  gmf_head mmostafa 061123 DiagramEventBroker not handling undo creation properly.
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005, 2006 IBM Corporation and others.
@


1.19
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d19 1
d281 1
d288 1
d295 10
a304 1
            	if (deletedObjects.contains(notifier)) {
d343 2
d352 10
a361 1
                if (!customNotification && deletedObjects.contains(notifier)) {
d369 25
d395 12
@


1.18
log
@bugzilla 145352  gmf-head mmostafa 060606 Exceptions thrown when trying to delete elements in PE
@
text
@a18 1
import java.util.HashSet;
d20 2
a36 1
import org.eclipse.emf.transaction.util.TransactionUtil;
d38 1
a38 1
import org.eclipse.gmf.runtime.diagram.core.internal.commands.PersistElementCommand;
d43 2
d62 2
d95 1
a95 1
            Set listenersSet = (Set) keys.get(key);
d97 1
a97 1
                listenersSet = new HashSet(4);
d100 1
a100 1
            listenersSet.add(listener);
d124 1
a124 1
                Set listenersSet = (Set) keys.get(key);
d146 1
a146 1
                Set listenersSet = (Set) keys.get(key);
d148 1
a148 1
                    return listenersSet;
d165 1
a165 1
            Set listenersCollection = new HashSet();
d169 1
a169 1
                Set listenersSet = (Set) entry.getValue();
d171 1
a171 1
                    listenersCollection.addAll(listenersSet);
d175 4
d187 2
a188 1
    }
d219 4
d246 4
a249 1
    		return new DiagramEventBroker();
d280 1
a280 1
        Set elementsInPersistQueue = new HashSet();
d282 4
d290 1
a290 1
            Object notifier = notification.getNotifier();
d292 1
a292 1
                if (deletedObjects.contains(notification.getNotifier())) {
d295 12
a306 3
                Command cmd = handleTransactionAboutToCommitEvent(notification,elementsInPersistQueue);
                if (cmd != null) {
                    cc.append(cmd);
d310 7
a316 1
        elementsInPersistQueue.clear();
d327 3
d338 1
a338 2
                if (deletedObjects.contains(notification.getNotifier())&&
                    !customNotification) {
d342 1
a342 1
                handleElementEvent(notification);
d376 9
a384 12
            false);
        if (!listenerList.isEmpty()) {
            List listenersSnapShot = new ArrayList(listenerList);
            if (!listenerList.isEmpty()) {
                for (Iterator listenerIT = listenersSnapShot.iterator(); listenerIT
                    .hasNext();) {
                    NotificationListener listener = (NotificationListener) listenerIT
                        .next();
                    listener.notifyChanged(event);
                }
            }
        }
d387 8
a394 1
    private Command fireTransactionAboutToCommit(Notification event,Set elementsInPersistQueue) {
d396 1
a396 3
            true);
        CompoundCommand cc = new CompoundCommand();
        preparePersistCommand(event,cc,elementsInPersistQueue);
d398 8
a405 11
            List listenersSnapShot = new ArrayList(listenerList);
            if (!listenerList.isEmpty()) {
                
                for (Iterator listenerIT = listenersSnapShot.iterator(); listenerIT
                    .hasNext();) {
                    NotificationPreCommitListener listener = (NotificationPreCommitListener) listenerIT
                        .next();
                    Command cmd = listener.transactionAboutToCommit(event);
                    if (cmd != null) {
                        cc.append(cmd);
                    }
a406 2
                return cc.isEmpty() ? null
                    : cc;
d408 2
d411 1
a411 5
        
        if (cc.isEmpty())
            return null;
        
        return cc;
d414 1
a414 2
    private void preparePersistCommand(Notification event, CompoundCommand cc, Set elementsInPersistQueue) {
        PersistElementCommand persistCmd = null;
d417 2
a418 1
            while (elementToPersist != null && !(elementToPersist instanceof View)) {
d421 2
a422 1
            if (elementToPersist != null && !elementsInPersistQueue.contains(elementToPersist)
d426 9
a434 1
                    persistCmd = getPersistViewCommand((View)elementToPersist);
d438 1
a438 2
        if (persistCmd!=null && persistCmd.getEditingDomain()!=null)
            cc.append(new EMFOperationCommand(persistCmd.getEditingDomain(),persistCmd));
d571 1
a571 18
    public final void finalize() {
        try {
            for (Iterator iter = instanceMap.keySet().iterator(); iter
                .hasNext();) {
                TransactionalEditingDomain editingDomain = (TransactionalEditingDomain) iter
                    .next();
                editingDomain
                    .removeResourceSetListener((DiagramEventBroker) ((WeakReference) instanceMap
                        .get(editingDomain)).get());
            }
        } catch (Throwable ignored) {
            // intentionally ignored
        }
    }

    private Set getNotificationListeners(Object notifier, boolean preCommit) {
        NotifierToKeyToListenersSetMap listeners = preCommit ? preListeners
            : postListeners;
d582 1
a582 3
            boolean preCommit) {
        NotifierToKeyToListenersSetMap listeners = preCommit ? preListeners
            : postListeners;
d585 1
a585 1
                Set listenersSet = new HashSet();
d609 2
a610 2
            boolean preCommit) {
        HashSet listenerSet = new HashSet();
d613 1
a613 1
            .getFeature(), preCommit);
d625 1
a625 1
                preCommit));
d628 1
a628 1
                preCommit);
d633 1
a633 1
            addListenersOfNotifier(listenerSet, notifier, event, preCommit);
d650 1
a650 1
            Notification event, boolean preCommit) {
d653 1
a653 1
                .getFeature(), preCommit);
d666 1
a666 17
    }

    /**
     * Forwards the event to all interested listeners.
     * 
     * @@param event
     *            the event to handle
     * @@p
     */
    private Command handleTransactionAboutToCommitEvent(Notification event, Set elementsInPersistQueue) {
        EObject element = (EObject) event.getNotifier();
        if (element != null) {
            return fireTransactionAboutToCommit(event,elementsInPersistQueue);
        }
        return null;
    }
    
a667 36
    /**
     * Forwards the event to all interested listeners.
     * 
     * @@param event
     *            the event to handle
     * 
     */
    private void handleElementEvent(Notification event) {
        EObject element = (EObject) event.getNotifier();
        if (element != null) {
            fireNotification(event);
        }
    }

    /**
     * Returns a persisted view command. This command if executed will persisted
     * the passed view and all its required parents.
     * @@param view the view to persist
     * @@return the command to persist the view; the return value can be null
     */
    private PersistElementCommand getPersistViewCommand(View view) {
        PersistElementCommand pvc = null;
        // only immutable views can be persisted
        if (!view.isMutable()) {
            TransactionalEditingDomain editingDomain = TransactionUtil.getEditingDomain(view);
            // get Top view needs to get persisted
            View viewToPersist = ViewUtil.getTopViewToPersist(view);
            if (viewToPersist!=null){
                // now the command that will persist the view
                //Map options = Collections.singletonMap( Transaction.OPTION_UNPROTECTED, Boolean.TRUE);
                pvc = new PersistElementCommand(editingDomain, viewToPersist /*, options*/);
            }
        }
        return pvc;
        
    }
@


1.18.2.1
log
@ [144423] gmf_R1_0_maintenance mmostafa  060711 DiagramEventBroker$NotifierToKeyToListenerSetMap uses HashSet for storing the Listeners.
@
text
@d91 1
a91 1
            Map listenersSet = (Map) keys.get(key);
d93 1
a93 1
                listenersSet = new HashMap(4);
d96 1
a96 1
            listenersSet.put(listener,null);
d120 1
a120 1
                Map listenersSet = (Map) keys.get(key);
d142 1
a142 1
                Map listenersSet = (Map) keys.get(key);
d144 1
a144 1
                    return listenersSet.keySet();
d165 1
a165 1
                Map listenersSet = (Map) entry.getValue();
d167 1
a167 1
                    listenersCollection.addAll(listenersSet.keySet());
@


1.18.2.2
log
@[151230] gmf_R1_0_maintenace mmostafa 060725  Diagram event broker does not maintain the order of the Listeners
@
text
@d19 1
a20 2
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
d93 1
a93 1
                listenersSet = new LinkedHashMap(4);
d161 1
a161 1
            Set listenersCollection = new LinkedHashSet();
d264 1
a264 1
        Set elementsInPersistQueue = new LinkedHashSet();
d564 1
a564 1
                Set listenersSet = new LinkedHashSet();
d589 1
a589 1
        Set listenerSet = new LinkedHashSet();
@


1.18.2.3
log
@[150317] gmf_R1_0_maintenace ylulu 060726  DiagramEventBroker performance could be enhanced
@
text
@d37 1
d39 1
a39 1
import org.eclipse.gmf.runtime.diagram.core.internal.commands.PersistViewsCommand;
a43 2


a60 2
    
    private WeakReference editingDomainRef;
a171 4
        
        public boolean isEmpty() {
            return listenersMap.isEmpty();
        }
d180 1
a180 2
    }    
    
a210 4
            if (diagramEventBroker.editingDomainRef == null) {
				diagramEventBroker.editingDomainRef = new WeakReference(
					editingDomain);
			}
d234 1
a234 4
            DiagramEventBroker diagramEventBroker =  new DiagramEventBroker();
            diagramEventBroker.editingDomainRef = new WeakReference(
                editingDomain);
            return diagramEventBroker;
a266 4
        TransactionalEditingDomain editingDomain = (TransactionalEditingDomain) editingDomainRef
            .get();
        boolean hasPreListeners = (preListeners.isEmpty() == false);
        List viewsToPersistList = new ArrayList();
d271 1
a271 1
            Object notifier = notification.getNotifier();            
d273 1
a273 1
            	if (deletedObjects.contains(notifier)) {
d276 3
a278 12
                if (editingDomain != null) {
                    View viewToPersist = getViewToPersist(notification,
                        elementsInPersistQueue);
                    if (viewToPersist != null) {
                        viewsToPersistList.add(viewToPersist);
                    }
                }
                if (hasPreListeners) {
                    Command cmd = fireTransactionAboutToCommit(notification);
                    if (cmd != null) {
                        cc.append(cmd);
                    }
d282 1
a282 7

        if (viewsToPersistList.isEmpty() == false) {
            PersistViewsCommand persistCmd = new PersistViewsCommand(
                editingDomain, viewsToPersistList);
            cc.append(new EMFOperationCommand(editingDomain, persistCmd));
        }

a292 3
    	if (postListeners.isEmpty()) {
            return;
        }
d301 2
a302 1
                if (!customNotification && deletedObjects.contains(notifier)) {
d306 1
a306 1
                fireNotification(notification);
d340 12
a351 9
        	postListeners);
        if (!listenerList.isEmpty()) {			
			for (Iterator listenerIT = listenerList.iterator(); listenerIT
				.hasNext();) {
				NotificationListener listener = (NotificationListener) listenerIT
					.next();
				listener.notifyChanged(event);
			}
		}
d354 1
a354 8
    /**
     * Forwards the event to all interested listeners.
     * 
     * @@param event
     *            the event to handle
     * @@p
     */
    private Command fireTransactionAboutToCommit(Notification event) {
d356 3
a358 1
            preListeners);       
d360 11
a370 8
        	 CompoundCommand cc = new CompoundCommand();            
            for (Iterator listenerIT = listenerList.iterator(); listenerIT
                .hasNext();) {
                NotificationPreCommitListener listener = (NotificationPreCommitListener) listenerIT
                    .next();
                Command cmd = listener.transactionAboutToCommit(event);
                if (cmd != null) {
                    cc.append(cmd);
d372 2
a374 2
            return cc.isEmpty() ? null
            : cc;
d376 5
a380 1
		return null;        
d383 2
a384 1
    private View getViewToPersist(Notification event, Set elementsInPersistQueue) {
d387 1
a387 2
            while (elementToPersist != null
                && !(elementToPersist instanceof View)) {
d390 1
a390 2
            if (elementToPersist != null
                && !elementsInPersistQueue.contains(elementToPersist)
d394 1
a394 9
                    View view = (View) elementToPersist;
                    if (!view.isMutable()) {
                        // get Top view needs to get persisted
                        View viewToPersist = ViewUtil.getTopViewToPersist(view);
                        if (viewToPersist != null) {                            
                            elementsInPersistQueue.add(viewToPersist);
                            return viewToPersist;
                        }
                    }
d398 2
a399 1
        return null;
d547 3
a549 1
    private Set getNotificationListeners(Object notifier, NotifierToKeyToListenersSetMap listeners) {       
d560 3
a562 1
    		NotifierToKeyToListenersSetMap listeners) {
d589 1
a589 1
    		NotifierToKeyToListenersSetMap listeners) {
d593 1
a593 1
            .getFeature(), listeners);
d605 1
a605 1
            	listeners));
d608 1
a608 1
            	listeners);
d613 1
a613 1
            addListenersOfNotifier(listenerSet, notifier, event, listeners);
d630 1
a630 1
            Notification event, NotifierToKeyToListenersSetMap listeners) {
d633 1
a633 1
                .getFeature(), listeners);
d646 17
a662 1
    }    
d664 36
@


1.18.2.4
log
@[155836] gmf_R1_0_maintenace mmostafa 060831 Diagram event broker uses finalize to do clean up
@
text
@d571 15
@


1.18.2.5
log
@[162125] gmf  gmf_R1_0_maintenace mmostafa 061026 DiagramEventBroker not handling undo creation properly.
@
text
@a18 1
import java.util.HashSet;
a279 1
        Set existingObjects = new HashSet();
a285 1
        boolean deleteElementCheckRequired = !deletedObjects.isEmpty();
d292 1
a292 10
                boolean deleted = false;
                if (deleteElementCheckRequired){
                    deleted = !existingObjects.contains(notifier);
                    if (deleted){
                        deleted = isDeleted(deletedObjects, (EObject)notifier);
                        if (!deleted)
                            existingObjects.add(notifier);
                    }
                }
            	if (deleted) {
a330 2
        Set existingObjects = new HashSet();
        boolean deleteElementCheckRequired = !deletedObjects.isEmpty();
d338 1
a338 10
                boolean deleted = false;
                if (deleteElementCheckRequired && !customNotification){
                    deleted = !existingObjects.contains(notifier);
                    if (deleted){
                        deleted = isDeleted(deletedObjects, (EObject)notifier);
                        if (!deleted)
                            existingObjects.add(notifier);
                    }
                }
                if (!customNotification && deleted) {
a345 25


    /**
     * decide if the passed object is deleted or not; the decision is done by 
     * checking is the passed notifier or any of its ancestors exists in the passed
     * deletedObjects Set, if it find the obnject to be deleted it will add it 
     * to the deleted objects set.
     * @@param deletedObjects
     * @@param notifier
     * @@return
     */
    private boolean isDeleted(Set deletedObjects, EObject notifier) {
        EObject object = notifier;
        while (object!=null){
            if (deletedObjects.contains(object)){
                if (object != notifier){
                    //so we do not waste time on the second call
                    addDeletedBranch(deletedObjects,notifier);
                }
                return true;
            }
            object = object.eContainer();
        }
        return false;
    }
a346 12
    private void addDeletedBranch(Set deletedObjects, EObject notifier) {
        EObject object = notifier;
        while (object != null){
            if (!deletedObjects.add(object)){
                break;
            }
            object = object.eContainer();
        }
        
    }


@


1.18.2.6
log
@[162125] gmf  gmf_R1_0_maintenace mmostafa 061027 Fix copyright
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.17
log
@bugzilla 144693 gmf-head mmostafa 060606 Shape Edit Part does not handle the Unresolve Event any more
@
text
@d397 1
a397 1
        if (persistCmd!=null)
@


1.16
log
@bugzilla 142803 gmf-head sshaw 060531 Illegal Asynchronous Access to ResourceSetChangeEvent in DiagramEventBrokerThreadSafe
@
text
@d88 1
a88 1
                keys = new HashMap();
d93 1
a93 1
                listenersSet = new HashSet();
d295 2
a296 1
            if (shouldIgnoreNotification(notification))
d300 2
a301 1
                if (deletedObjects.contains(notification.getNotifier())) {
@


1.15
log
@bugzilla 140488 gmf-head sshaw 060512 Adding shapes to a diagarm on a different thread makes diagram unusable
@
text
@d190 2
a191 6
        WeakReference reference = (WeakReference) instanceMap
            .get(editingDomain);
        if (reference != null) {
            return (DiagramEventBroker) reference.get();
        }
        return null;
d203 32
a234 5
        DiagramEventBroker diagramEventBroker = getInstance(editingDomain);
        if (diagramEventBroker == null) {
            diagramEventBroker = new DiagramEventBroker();
            startListening(editingDomain, diagramEventBroker);
        }
d237 2
d240 1
a240 8
     * Creates a new diagram event broker instance for the editing domain passed
     * in only if the editing domain does not already have a diagram event
     * broker. There is one diagram event broker per editing domain. Adds the
     * diagram event broker instance as a listener to the editing domain.
     * 
     * @@param editingDomain
     * @@param diagramEventBroker the <code>DiagramEventBroker</code> to add as a listener to the 
     * <code>TransactionalEditingDomain</code>
d242 2
a243 4
    public static void startListening(TransactionalEditingDomain editingDomain, DiagramEventBroker diagramEventBroker) {
        stopListening(editingDomain);
        editingDomain.addResourceSetListener(diagramEventBroker);
        instanceMap.put(editingDomain, new WeakReference(diagramEventBroker));
d285 1
a285 1

d585 1
a585 1
    private Set getInterestedNotificationListeners(Notification event,
@


1.14
log
@bugzilla 140943 gmf-head mmostafa 060509 DiagramEventBroker fails to persist Transient views
@
text
@d177 1
a177 1
    private DiagramEventBroker() {
d210 1
a210 3
            editingDomain.addResourceSetListener(diagramEventBroker);
            instanceMap.put(editingDomain,
                new WeakReference(diagramEventBroker));
d213 16
@


1.13
log
@bugzilla 138064 gmf-head mmostafa 060421 Redo is broken on canonically created elements
@
text
@d358 1
a358 4
                && (NotationPackage.eINSTANCE.getView_TransientChildren() == elementToPersist
                    .eContainingFeature() || NotationPackage.eINSTANCE
                    .getDiagram_TransientEdges() == elementToPersist
                    .eContainingFeature())) {
@


1.12
log
@[132367],gmf_head, cbmcgee,060330,Provide specialized post commit listener that can open a write transaction
@
text
@d234 1
d245 1
a245 1
                Command cmd = handleTransactionAboutToCommitEvent(notification);
d251 1
a262 1

a266 1

d277 1
a277 1

d321 1
a321 1
    private Command fireTransactionAboutToCommit(Notification event) {
d325 1
a325 1
        preparePersistCommand(event,cc);
d350 1
a350 1
    private void preparePersistCommand(Notification event, CompoundCommand cc) {
d357 1
a357 1
            if (elementToPersist != null
d363 1
d591 1
a591 1

d623 1
d625 1
a625 1
    private Command handleTransactionAboutToCommitEvent(Notification event) {
d628 1
a628 1
            return fireTransactionAboutToCommit(event);
d639 1
d642 1
a642 1
       EObject element = (EObject) event.getNotifier();
@


1.11
log
@[132367] gmf_head cmcgee 060323 Provide specialized post commit listener that can open a write transaction
@
text
@a589 7
    
    public boolean isPrecommitOnly() {
    	// We aren't really a precommit only listener, the DiagramEditingDomain
    	//  has a special case for us to be a special postcommit listener
    	//  that can make changes while responding to batched events.
    	return true;
    }
@


1.10
log
@bugzilla 128977 gmf-head mmostafa 060309 Adopt transaction API in diagram event broker API and CanonicalEditPolicy API
@
text
@d586 1
a586 1

d588 8
a595 1
        return true;
@


1.9
log
@Bugzilla#129803 gmf_head cmahoney 060301 Deleting node leaves connection connected to space
@
text
@d36 3
a42 1

d49 100
a148 1
public class DiagramEventBroker extends ResourceSetListenerImpl {
d150 22
a171 1
	private static String LISTEN_TO_ALL_FEATURES = "*"; //$NON-NLS-1$
d173 7
a179 142
	/** listener map */
	private final NotifierToKeyToListenersSetMap preListeners = new NotifierToKeyToListenersSetMap();
	private final NotifierToKeyToListenersSetMap postListeners = new NotifierToKeyToListenersSetMap();
	
	private static final Map instanceMap = new WeakHashMap();

	/**
	 * Utility class representing a Map of Notifier to a Map of Keys to a Set of
	 * listener
	 * 
	 * @@author mmostafa
	 */
	private final class NotifierToKeyToListenersSetMap {

		/**
		 * internal map to hold the listeners
		 */
		private final Map listenersMap = new WeakHashMap();

		/**
		 * Adds a listener to the map
		 * 
		 * @@param notifier
		 *            the notifier the listener will listen to
		 * @@param key
		 *            a key for the listener, this help in categorizing the
		 *            listeners based on their interest
		 * @@param listener
		 *            the listener
		 */
		public void addListener(EObject notifier, Object key, Object listener) {
			Map keys = (Map) listenersMap.get(notifier);
			if (keys == null) {
				keys = new HashMap();
				listenersMap.put(notifier, keys);
			}
			Set listenersSet = (Set) keys.get(key);
			if (listenersSet == null) {
				listenersSet = new HashSet();
				keys.put(key, listenersSet);
			}
			listenersSet.add(listener);
		}

		/**
		 * Adds a listener to the notifier; this listener is added againest a
		 * generic key, <code>LISTEN_TO_ALL_FEATURES<code>
		 * so it can listen to all events on the notifier 
		 * @@param notifier the notifier the listener will listen to
		 * @@param listener the listener
		 */
		public void addListener(EObject notifier, Object listener) {
			addListener(notifier, LISTEN_TO_ALL_FEATURES, listener);
		}

		/**
		 * removes a listener from the map
		 * 
		 * @@param notifier
		 * @@param key
		 * @@param listener
		 */
		public void removeListener(EObject notifier, Object key, Object listener) {
			Map keys = (Map) listenersMap.get(notifier);
			if (keys != null) {
				Set listenersSet = (Set) keys.get(key);
				if (listenersSet != null) {
					listenersSet.remove(listener);
					if (listenersSet.isEmpty()) {
						keys.remove(key);
					}
				}
				if (keys.isEmpty())
					listenersMap.remove(notifier);
			}
		}

		/**
		 * get listeners interested in the passed notifier and key
		 * 
		 * @@param notifier
		 * @@param key
		 * @@return <code>Set</code> of listeners
		 */
		public Set getListeners(Object notifier, Object key) {
			Map keys = (Map) listenersMap.get(notifier);
			if (keys != null) {
				Set listenersSet = (Set) keys.get(key);
				if (listenersSet != null) {
					return listenersSet;
				}
			}
			return Collections.EMPTY_SET;
		}

		/**
		 * return all listeners interested in the passed notifier
		 * 
		 * @@param notifier
		 * @@return
		 */
		public Set getAllListeners(Object notifier) {
			Map keys = (Map) listenersMap.get(notifier);
			if (keys == null || keys.isEmpty()) {
				return Collections.EMPTY_SET;
			}
			Set listenersCollection = new HashSet();
			Set enteries = keys.entrySet();
			for (Iterator iter = enteries.iterator(); iter.hasNext();) {
				Map.Entry entry = (Map.Entry) iter.next();
				Set listenersSet = (Set) entry.getValue();
				if (listenersSet != null && !listenersSet.isEmpty())
					listenersCollection.addAll(listenersSet);
			}
			return listenersCollection;
		}
	}

	/**
	 * Creates a <code>DiagramEventBroker</code> that listens to all
	 * <code>EObject </code> notifications for the given editing domain.
	 */
	private DiagramEventBroker() {
		super(NotificationFilter.createNotifierTypeFilter(EObject.class));
	}
	
	/**
	 * Gets the diagmam event broker instance for the editing domain passed in.
	 * There is one diagram event broker per editing domain.
	 * 
	 * @@param editingDomain
	 * @@return Returns the diagram event broker.
	 */
	public static DiagramEventBroker getInstance(
			TransactionalEditingDomain editingDomain) {
		WeakReference reference = (WeakReference) instanceMap
			.get(editingDomain);
		if (reference != null) {
			return (DiagramEventBroker) reference.get();
		}
		return null;
	}
d181 18
a198 1
	/**
d206 9
a214 10
	public static void startListening(
			TransactionalEditingDomain editingDomain) {
		DiagramEventBroker diagramEventBroker = getInstance(editingDomain);
		if (diagramEventBroker == null) {
			diagramEventBroker = new DiagramEventBroker();
			editingDomain.addResourceSetListener(diagramEventBroker);
			instanceMap.put(editingDomain,
				new WeakReference(diagramEventBroker));
		}
	}
d219 1
a219 2
    public static void stopListening(
            TransactionalEditingDomain editingDomain) {
d226 6
a231 1
    
a233 1
 
d237 2
a238 9
            Object eventFeature = notification.getFeature();

            // ignore touch event if it is not a resolve event,and ignore the mutable feature
            // events
            if ((notification.isTouch() && notification.getEventType() != Notification.RESOLVE)||
                 NotationPackage.eINSTANCE.getView_Mutable().equals(eventFeature)){
                 continue;
            }
            
d250 2
a251 1
        return cc.isEmpty() ? null : cc;
d254 6
a259 1
	public void resourceSetChanged(ResourceSetChangeEvent event) {
d262 54
a315 15
		for (Iterator i = event.getNotifications().iterator(); i.hasNext();) {
			final Notification notification = (Notification) i.next();
			Object eventFeature = notification.getFeature();

			// ignore touch event if it is not a resolve event,and ignore the mutable feature
			// events
			if ((notification.isTouch() && notification.getEventType() != Notification.RESOLVE)||
			     NotationPackage.eINSTANCE.getView_Mutable().equals(eventFeature)){
				 continue;
			}
			
			Object notifier = notification.getNotifier();
			if (notifier instanceof EObject) {
				if (deletedObjects.contains(notification.getNotifier())) {
					continue;
d317 12
d330 256
a585 5
				handleElementEvent(notification);
			}
		}
	}
    
d587 3
d591 21
a611 313
	/**
	 * Forward the supplied event to all listeners listening on the supplied
	 * target element.
	 * <P>
	 * <B> Note, for the MSL migration effort, each listener will be forwarded 2
	 * events. First, a MSL complient Notification event followed by an
	 * ElementEvent (for backwards compatibility). The ElementEvent will be
	 * removed one the MSL migration is complete.
	 */
	private void fireNotification(Notification event) {
		Collection listenerList = getInterestedNotificationListeners(event, false);
		if (!listenerList.isEmpty()) {
			List listenersSnapShot = new ArrayList(listenerList);
			if (!listenerList.isEmpty()) {
				for (Iterator listenerIT = listenersSnapShot.iterator(); listenerIT
					.hasNext();) {
					NotificationListener listener = (NotificationListener) listenerIT
						.next();
					listener.notifyChanged(event);
				}
			}
		}
	}

	private Command fireTransactionAboutToCommit(Notification event) {
		Collection listenerList = getInterestedNotificationListeners(event,
			true);
		if (!listenerList.isEmpty()) {
			List listenersSnapShot = new ArrayList(listenerList);
			if (!listenerList.isEmpty()) {
				CompoundCommand cc = new CompoundCommand();
				for (Iterator listenerIT = listenersSnapShot.iterator(); listenerIT
					.hasNext();) {
					NotificationPreCommitListener listener = (NotificationPreCommitListener) listenerIT
						.next();
					Command cmd = listener.transactionAboutToCommit(event);
					if (cmd != null) {
						cc.append(cmd);
					}
				}
				return cc.isEmpty() ? null
					: cc;
			}
		}
		return null;
	}

	/**
	 * Add the supplied <tt>listener</tt> to the listener list.
	 * 
	 * @@param target
	 *            the traget to listen to
	 * @@param listener
	 *            the listener
	 */
	public final void addNotificationListener(EObject target,
			NotificationPreCommitListener listener) {
		if (target != null) {
			preListeners.addListener(target, LISTEN_TO_ALL_FEATURES, listener);
		}
	}

	/**
	 * Add the supplied <tt>listener</tt> to the listener list.
	 * 
	 * @@param target
	 *            the traget to listen to
	 * @@param listener
	 *            the listener
	 */
	public final void addNotificationListener(EObject target,
			NotificationListener listener) {
		if (target != null) {
			postListeners.addListener(target, LISTEN_TO_ALL_FEATURES, listener);
		}
	}
	
	/**
	 * Add the supplied <tt>listener</tt> to the listener list.
	 * 
	 * @@param target
	 *            the traget to listen to
	 * @@param key
	 *            the key for the listener
	 * @@param listener
	 *            the listener
	 */
	public final void addNotificationListener(EObject target,
			EStructuralFeature key, NotificationPreCommitListener listener) {
		if (target != null) {
			preListeners.addListener(target, key, listener);
		}
	}	
	/**
	 * Add the supplied <tt>listener</tt> to the listener list.
	 * 
	 * @@param target
	 *            the traget to listen to
	 * @@param key
	 *            the key for the listener
	 * @@param listener
	 *            the listener
	 */
	public final void addNotificationListener(EObject target,
			EStructuralFeature key, NotificationListener listener) {
		if (target != null) {
			postListeners.addListener(target, key, listener);
		}
	}

	/**
	 * remove the supplied <tt>listener</tt> from the listener list.
	 * 
	 * @@param target
	 *            the traget to listen to
	 * @@param listener
	 *            the listener
	 */
	public final void removeNotificationListener(EObject target,
			NotificationPreCommitListener listener) {
		if (target != null) {
			preListeners.removeListener(target, LISTEN_TO_ALL_FEATURES, listener);
		}
	}
	
	/**
	 * remove the supplied <tt>listener</tt> from the listener list.
	 * 
	 * @@param target
	 *            the traget to listen to
	 * @@param listener
	 *            the listener
	 */
	public final void removeNotificationListener(EObject target,
			NotificationListener listener) {
		if (target != null) {
			postListeners.removeListener(target, LISTEN_TO_ALL_FEATURES, listener);
		}
	}

	/**
	 * remove the supplied <tt>listener</tt> from the listener list.
	 * 
	 * @@param target
	 *            the traget to listen to
	 * @@param key
	 *            the key for the listener
	 * @@param listener
	 *            the listener
	 */
	public final void removeNotificationListener(EObject target, Object key,
			NotificationPreCommitListener listener) {
		if (target != null) {
			preListeners.removeListener(target, key, listener);
		}
	}

	/**
	 * remove the supplied <tt>listener</tt> from the listener list.
	 * 
	 * @@param target
	 *            the traget to listen to
	 * @@param key
	 *            the key for the listener
	 * @@param listener
	 *            the listener
	 */
	public final void removeNotificationListener(EObject target, Object key,
			NotificationListener listener) {
		if (target != null) {
			postListeners.removeListener(target, key, listener);
		}
	}
	public final void finalize() {
		try {
			for (Iterator iter = instanceMap.keySet().iterator(); iter
				.hasNext();) {
				TransactionalEditingDomain editingDomain = (TransactionalEditingDomain) iter
					.next();
				editingDomain
					.removeResourceSetListener((DiagramEventBroker) ((WeakReference) instanceMap
						.get(editingDomain)).get());
			}
		} catch (Throwable ignored) {
			// intentionally ignored
		}
	}
	
	private Set getNotificationListeners(Object notifier, boolean preCommit) {
		NotifierToKeyToListenersSetMap listeners = preCommit ? preListeners
			: postListeners;
		return listeners.getListeners(notifier, LISTEN_TO_ALL_FEATURES);
	}


	/**
	 * @@param notifier
	 * @@param key
	 * @@param preCommit
	 * @@return
	 */
	private Set getNotificationListeners(Object notifier, Object key, boolean preCommit) {
		NotifierToKeyToListenersSetMap listeners = preCommit ? preListeners : postListeners;
		if (key != null) {
			if (!key.equals(LISTEN_TO_ALL_FEATURES)) {
				Set listenersSet = new HashSet();
				Collection c = listeners.getListeners(notifier, key);
				if (c != null && !c.isEmpty())
					listenersSet.addAll(c);
				c = listeners.getListeners(notifier, LISTEN_TO_ALL_FEATURES);
				if (c != null && !c.isEmpty())
					listenersSet.addAll(c);
				return listenersSet;
			} else if (key.equals(LISTEN_TO_ALL_FEATURES)) {
				return listeners.getAllListeners(notifier);
			}
		}
		return listeners.getAllListeners(notifier);
	}
	
	/**
	 * gets a subset of all the registered listeners who are interested in
	 * receiving the supplied event.
	 * 
	 * @@param event
	 *            the event to use
	 * @@return the interested listeners in the event
	 */
	private Set getInterestedNotificationListeners(Notification event, boolean preCommit) {
		HashSet listenerSet = new HashSet();

		Collection c = getNotificationListeners(event.getNotifier(), event
			.getFeature(), preCommit);
		if (c != null) {
			listenerSet.addAll(c);
		}
		
		EObject notifier = (EObject) event.getNotifier();
		//the Visibility Event get fired to all interested listeners in the container
		if (NotationPackage.eINSTANCE.getView_Visible().equals(event.getFeature()) &&
			notifier.eContainer()!=null){
				listenerSet.addAll(getNotificationListeners(notifier.eContainer(), preCommit));
		}
		else if (notifier instanceof EAnnotation) {
			addListenersOfNotifier(listenerSet, notifier.eContainer(), event, preCommit);
		} else if (!(notifier instanceof View)) {
			while (notifier != null && !(notifier instanceof View)) {
				notifier = notifier.eContainer();
			}
			addListenersOfNotifier(listenerSet, notifier, event, preCommit);
		}
		return listenerSet;
	}
	
	/**
	 * Helper method to add all the listners of the given <code>notifier</code>
	 * to the list of listeners
	 * 
	 * @@param listenerSet
	 * @@param notifier
	 */
	private void addListenersOfNotifier(Set listenerSet, EObject notifier,
			Notification event, boolean preCommit) {
		if (notifier != null) {
			Collection c = getNotificationListeners(notifier, event
				.getFeature(), preCommit);
			if (c != null) {
				if (listenerSet.isEmpty())
					listenerSet.addAll(c);
				else {
					Iterator i = c.iterator();
					while (i.hasNext()) {
						Object o = i.next();
						listenerSet.add(o);
					}
				}
			}
		}
	}

	/**
	 * Forwards the event to all interested listeners.
	 * 
	 * @@param event
	 *            the event to handle
	 */
	private Command handleTransactionAboutToCommitEvent(Notification event) {
		EObject element = (EObject) event.getNotifier();
		if (element != null) {
			return fireTransactionAboutToCommit(event);
		}

		return null;
	}

	/**
	 * Forwards the event to all interested listeners.
	 * 
	 * @@param event
	 *            the event to handle
	 */
	private void handleElementEvent(Notification event) {
		
		if (!event.isTouch()) {
			EObject element = (EObject) event.getNotifier();
			while (element != null && !(element instanceof View)) {
				element = element.eContainer();
			}
			if (element != null && 
                (NotationPackage.eINSTANCE.getView_TransientChildren()==element.eContainingFeature() ||
                 NotationPackage.eINSTANCE.getDiagram_TransientEdges()==element.eContainingFeature())) {
                if (!NotificationFilter.READ.matches(event)) {
                    ViewUtil.persistElement((View) element);
d613 3
a615 2
			}
		}
d617 27
a643 5
		EObject element = (EObject) event.getNotifier();
		if (element != null) {
			fireNotification(event);
		}
	}
d645 22
@


1.8
log
@bugzilla 129699 gmf-head mmostafa 060301 DiagramEventBroker persists views that are detached
@
text
@d226 1
a226 1
        Set deletedObjects = getDeletedObjects(event);
d242 1
a242 1
                if (deletedObjects.contains(notification.getNotifier()) && !isDestroyEvent(notification))
d244 1
d255 1
a255 1
        Set deletedObjects = getDeletedObjects(event);
d270 1
a270 1
				if (deletedObjects.contains(notification.getNotifier())  && !isDestroyEvent(notification))
d272 2
a278 10
    private Set getDeletedObjects(ResourceSetChangeEvent event) {
        HashSet deletedObjects = new HashSet();
        // first collect the "destroyed" objects
        for (Iterator i = event.getNotifications().iterator(); i.hasNext();) {
            Notification notification = (Notification) i.next();
            if (isDestroyEvent(notification))
                deletedObjects.add(notification.getNotifier());
        }
        return deletedObjects;
    }
a279 14
	/**
	 * Returns true if this notification is the equivalent of what used to be a
	 * destroy event. Assumes the notifier is an <code>EObject</code>.
	 * 
	 * @@param notification
	 * @@return
	 */
	private boolean isDestroyEvent(Notification notification) {		
        return false;
        // TODO:  FIX THIS!
//		return (notification.getEventType() == Notification.REMOVE || notification
//			.getEventType() == Notification.REMOVE_MANY)
//			&& ((EObject) notification.getNotifier()).eContainer() == null;
	}
@


1.7
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d610 3
a612 1
			if (element != null) {
@


1.6
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d295 5
a299 3
		return (notification.getEventType() == Notification.REMOVE || notification
			.getEventType() == Notification.REMOVE_MANY)
			&& ((EObject) notification.getNotifier()).eContainer() == null;
@


1.5
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d14 1
d26 2
d33 3
a35 4
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramDebugOptions;
import org.eclipse.gmf.runtime.diagram.core.internal.DiagramPlugin;
import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
a36 4
import org.eclipse.gmf.runtime.emf.core.EventTypes;
import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;
import org.eclipse.gmf.runtime.emf.core.edit.MFilter;
import org.eclipse.gmf.runtime.emf.core.edit.MUniversalListener;
d40 1
d45 1
a45 1
 * @@author melaasar, mmostafa
d47 1
a47 2
public class DiagramEventBroker
	extends MUniversalListener {
d52 4
a55 1
	private final NotifierToKeyToListenersSetMap listeners = new NotifierToKeyToListenersSetMap();
d170 2
a171 2
	 * Start listening to the model server. {@@link MFilter.WildCard} is the
	 * default filter by this listener.
d173 2
a174 12
	public void startListening() {
		Trace.trace(DiagramPlugin.getInstance(), DiagramDebugOptions.EVENTS,
			this + "#startListening()"); //$NON-NLS-1$
		setFilter(new MFilter.NotifierType(EObject.class, false));
		super.startListening();
	}

	/** Stop listening to Model Server */
	public void stopListening() {
		Trace.trace(DiagramPlugin.getInstance(), DiagramDebugOptions.EVENTS,
			this + "#stopListening()"); //$NON-NLS-1$
		super.stopListening();
d176 1
a176 1

d178 2
a179 2
	 * Model Server event callback method. This method will redirect the events
	 * to their respective event type handler
d181 2
a182 2
	 * @@see #handleElementEvent(Notification)
	 * @@see #handleResourceEvent(Notification)
d184 75
a258 18
	public final void onEvent(List events) {
		List eventArray = new ArrayList(events);

		// if the events contain "uncreated" objects, remove all events related
		// to those
		// objects from the event list (except the "uncreate" events themselves)
		HashSet deletedObjects = new HashSet();
		// first collect the "destroyed" objects
		for (Iterator i = eventArray.iterator(); i.hasNext();) {
			Notification event = (Notification) i.next();
			if (event.getEventType() == EventTypes.UNCREATE
				|| event.getEventType() == EventTypes.DESTROY)
				deletedObjects.add(event.getNotifier());
		}

		for (Iterator i = eventArray.iterator(); i.hasNext();) {
			Notification event = (Notification) i.next();
			Object eventFeature = event.getFeature();
d262 1
a262 1
			if ((event.isTouch() && event.getEventType() != Notification.RESOLVE)||
d267 1
a267 1
			Object notifier = event.getNotifier();
d269 1
a269 4
				if (deletedObjects.contains(event.getNotifier())
					&& event.getEventType() != EventTypes.UNCREATE
					&& event.getEventType() != EventTypes.DESTROY
					&& event.getEventType() != EventTypes.UNRESOLVE)
d271 1
a271 1
				handleElementEvent(event);
d275 24
d309 2
a310 2
	protected void fireNotification(Notification event) {
		Collection listenerList = getInterestedNotificationListeners(event);
d324 38
d373 1
a373 1
			listeners.addListener(target, LISTEN_TO_ALL_FEATURES, listener);
d376 17
a392 1

d406 1
a406 1
			listeners.addListener(target, key, listener);
d419 15
d436 18
a453 1
			listeners.removeListener(target, LISTEN_TO_ALL_FEATURES, listener);
d470 1
a470 1
			listeners.removeListener(target, key, listener);
a472 1

d475 8
a482 1
			stopListening();
d487 4
a490 2

	protected Set getNotificationListeners(Object notifier) {
d494 9
a502 1
	protected Set getNotificationListeners(Object notifier, Object key) {
d519 1
a519 54

	/** SLOT_MODIFIED filter. */
	public final static MFilter SLOT_MODIFIED = new MFilter.And(
		new MFilter.NotifierType(EObject.class, false), new MFilter.And(
			new MFilter.EventType(EventTypes.SET), new MFilter.EventType(
				EventTypes.UNSET)));

	/** ELEMENT_INSERTED_INTO_SLOT filter. */
	public final static MFilter ELEMENT_INSERTED_INTO_SLOT = new MFilter.And(
		new MFilter.NotifierType(EObject.class, false), new MFilter.Or(
			new MFilter.EventType(EventTypes.ADD), new MFilter.EventType(
				EventTypes.ADD_MANY)));

	/** ELEMENT_REMOVED_FROM_SLOT filter. */
	public final static MFilter ELEMENT_REMOVED_FROM_SLOT = new MFilter.And(
		new MFilter.NotifierType(EObject.class, false), new MFilter.Or(
			new MFilter.EventType(EventTypes.REMOVE), new MFilter.EventType(
				EventTypes.REMOVE_MANY)));

	/** ELEMENT_CREATED filter. */
	public final static MFilter ELEMENT_CREATED = new MFilter.And(
		new MFilter.NotifierType(EObject.class, false), new MFilter.EventType(
			EventTypes.CREATE));

	/** ELEMENT_UNCREATED filter */
	public final static MFilter ELEMENT_UNCREATED = new MFilter.And(
		new MFilter.NotifierType(EObject.class, false), new MFilter.EventType(
			EventTypes.UNCREATE));

	/** ELEMENT_DELETED filter. */
	public final static MFilter ELEMENT_DELETED = new MFilter.And(
		new MFilter.NotifierType(EObject.class, false), new MFilter.EventType(
			EventTypes.DESTROY));

	/** ELEMENT_UNDELETED filter. */
	public final static MFilter ELEMENT_UNDELETED = new MFilter.And(
		new MFilter.NotifierType(EObject.class, false), new MFilter.EventType(
			EventTypes.UNDESTROY));

	/** The DiagramEventBroker singleton */
	private static DiagramEventBroker instance;

	/**
	 * gives access to the <code>DiagramEventBroker</code> singleton
	 * 
	 * @@return the <code>DiagramEventBroker</code> singleton
	 */
	public static DiagramEventBroker getInstance() {
		if (instance == null) {
			instance = new DiagramEventBroker();
		}
		return instance;
	}

d528 1
a528 1
	protected Set getInterestedNotificationListeners(Notification event) {
d532 1
a532 1
			.getFeature());
d541 1
a541 1
				listenerSet.addAll(getNotificationListeners(notifier.eContainer()));
d544 1
a544 1
			addListenersOfNotifier(listenerSet, notifier.eContainer(), event);
d549 1
a549 1
			addListenersOfNotifier(listenerSet, notifier, event);
d553 1
a553 1

d562 1
a562 1
			Notification event) {
d565 1
a565 1
				.getFeature());
d586 18
a603 5
	protected void handleElementEvent(Notification event) {
		MEditingDomain doamin = null;
		if (!event.isTouch()
			&& !(doamin = MEditingDomainGetter.getMEditingDomain(event))
				.isUndoNotification(event) && !doamin.isRedoNotification(event)) {
d614 1
d620 1
@


1.4
log
@111894  gmf-head mmostafa 051201 Improve memory consumption of opened notation diagram
@
text
@d29 1
d478 3
a480 1
				ViewUtil.persistElement((View) element);
@


1.3
log
@Bugzilla#115895 gmf_head cmahoney 051121 Clean up usage of new String("abc")
@
text
@d417 1
a417 1

d419 6
a424 1
		if (notifier instanceof EAnnotation) {
@


1.2
log
@bugzilla 114762  : gmf-head mmostafa 051109 : Exception thrown when closing a diagram
@
text
@d50 1
a50 1
	private static String LISTEN_TO_ALL_FEATURES = new String("*"); //$NON-NLS-1$
@


1.1
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d211 1
a211 2
			// ignore touch event who r not resolve events, ignor any
			// event that had no feature on it, and ignot the mutable feature
d213 5
a217 6
			if (eventFeature != null
				&& (eventFeature.equals(NotationPackage.eINSTANCE
					.getView_Mutable()) || (event.isTouch() && event
					.getEventType() != Notification.RESOLVE)))
				continue;

@

