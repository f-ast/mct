head	1.6;
access;
symbols
	v20080924-1925:1.6
	v20080722-1827:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.6.0.4
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080417-1610:1.6
	v20080322-0000:1.6
	v20080222-1200:1.6
	v20080215-1500:1.6
	v20080207-0207:1.6
	v20071124-0000:1.6
	v20071108-0000:1.6
	v20070903-0000:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	v20070621-0000:1.6
	RC3_20:1.5
	v20070608-1300:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070520-1200:1.5
	v20070518-1300:1.5
	v20070420-1000:1.5
	v20070413-1300:1.5
	v20070405-2000:1.5
	v20070330-1300:1.5
	v20070322-1100:1.5
	v20060316-0600:1.5
	v20070301-1200:1.4
	v20070228-2000:1.4
	v20070208-1800:1.4
	M4_20:1.4
	v20061214-0000:1.4
	M3_20:1.4
	v20061117-0800:1.4
	v20061013-1330:1.4
	v20060925-1700:1.2
	v20060919-0800:1.2
	M1_20:1.4
	v20060904-1500:1.4
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060626-1420:1.2
	v20060620-0400:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060526-1200:1.2
	v20060519-0800:1.2
	v20060512-1000:1.1
	I20060512-1000:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.6
date	2007.06.21.14.03.14;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	1176467a85204567;

1.5
date	2007.03.14.12.59.33;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	114b45f7f1b34567;

1.4
date	2006.09.04.14.47.44;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.01.19.43.09;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.16.16.12.26;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.28.19.07.41;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.6
log
@fix copyright years
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.wizards.strategy;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;

/**
 * FIXME Tests!!!
 * @@author artem
 */
public class Hierarchy {
	private final List<EReference> myRefs;
	private final EPackage myDomainModel;
	private final Map<EClass, Set<EClass>> myResult;
	private Set<EClass> myAccessibleLeaves;
	private Set<EClass> myAccessibleClasses = new HashSet<EClass>();
	/**
	 * EClasses that may suit as link
	 */
	private Set<EClass> myAccessibleLinkClasses = new HashSet<EClass>();
	/**
	 * Containment references to get to classes in myAccessibleLinkClasses set
	 */
	private Set<EReference> myLinkClassContainmentRefs = new HashSet<EReference>();

	private final EClass myDiagramContainer;

	/**
	 * 
	 * @@param eRefs
	 * @@param diagramContainer - can be <code>null</code> 
	 * @@param domainModel
	 */
	public Hierarchy(List<EReference> eRefs, EClass diagramContainer, EPackage domainModel) {
		myRefs = eRefs;
		myDiagramContainer = diagramContainer;
		myDomainModel = domainModel;
		myResult = new HashMap<EClass, Set<EClass>>();
		for (EReference element : eRefs) {
			myResult.put(element.getEReferenceType(), new HashSet<EClass>());
		}
	}

	public Hierarchy(EClass diagramContainer) {
		this(diagramContainer.getEAllContainments(), diagramContainer, diagramContainer.getEPackage());
	}

	public Hierarchy(EClass diagramContainer, EPackage domainModel) {
		this(diagramContainer.getEAllContainments(), diagramContainer, domainModel);
	}

	/**
	 * @@return domain element associated with diagram itself, or <code>null</code> if not specified.
	 */
	public EClass getDiagramContainer() {
		return myDiagramContainer;
	}

	public EReference nodeBackRef(EClass nodeElement) {
		for (EReference r : myRefs) {
			if (r.getEReferenceType().isSuperTypeOf(nodeElement)) {
				return r;
			}
		}
		return null;
	}

	public EReference linkBackRef(EClass linkElement) {
		ArrayList<EReference> compatible = new ArrayList<EReference>();
		for (EReference r : myLinkClassContainmentRefs) {
			if (r.getEReferenceType().isSuperTypeOf(linkElement)) {
				compatible.add(r);
			}
		}
		if (compatible.isEmpty()) {
			return null;
		}
		// try exact match
		for (int i = compatible.size() - 1; i >= 0; i--) {
			EReference r = compatible.get(i);
			if (r.getEReferenceType().equals(linkElement)) {
				return r;
			}
		}
		// just pick any 
		return compatible.get(0);
	}

	public boolean isLeaf(EClass element) {
		return myAccessibleLeaves.contains(element);
	}

	public EReference getLinkFeature(EClass element) {
		List<EReference> l = collectAllNonContainment(element);
		if (l.isEmpty()) {
			return null;
		}
		for (EReference ref : l) {
			if (element.isSuperTypeOf(ref.getEReferenceType())) {
				continue;
			}
			// check that target is accessible (part of the scope) 
			// i.e. link target could be either superclass or subclass of one of root classes.
			for (EClass c : myResult.keySet()) {
				if (c.isSuperTypeOf(ref.getEReferenceType()) || ref.getEReferenceType().isSuperTypeOf(c)) {
					return ref;
				}
			}
		}
		return null;
	}
	public void collect() {
		collect(true);
	}

	@@SuppressWarnings("unchecked")
	void collect(boolean recurse) {
		Set<EClass> nonLeaves = new HashSet<EClass>();
		final HashSet<EClass> leavesSet = new HashSet<EClass>();
		for (Iterator it = myDomainModel.getEClassifiers().iterator(); it.hasNext();) {
			Object next = it.next();
			if (next instanceof EClass) {
				EClass eClass = (EClass) next;
				for (Map.Entry<EClass, Set<EClass>> entry : myResult.entrySet()) {
					final EClass element = entry.getKey();
					if (element.isSuperTypeOf(eClass)) {
						entry.getValue().add(eClass);
						if (recurse) {
							Hierarchy h2 = new Hierarchy(eClass.getEAllContainments(), null, myDomainModel);
							h2.collect(false);
							myLinkClassContainmentRefs.addAll(eClass.getEAllContainments());
							myAccessibleLinkClasses .addAll(h2.getAccessibleClasses());
							leavesSet.addAll(h2.myAccessibleLeaves);
						}
						if (!eClass.isAbstract() &&  !eClass.isInterface()) {
							myAccessibleClasses.add(eClass);
						}
						nonLeaves.addAll(eClass.getESuperTypes());
					}
				}
			}
		}
		leavesSet.addAll(myAccessibleClasses);
		leavesSet.removeAll(nonLeaves);
		myAccessibleLeaves = Collections.unmodifiableSet(leavesSet);
		myAccessibleClasses = Collections.unmodifiableSet(myAccessibleClasses);
		myAccessibleLinkClasses = Collections.unmodifiableSet(myAccessibleLinkClasses);
	}

	public Set<EClass> getAllClasses() {
		HashSet<EClass> rv = new HashSet<EClass>();
		for (Set<EClass> next : myResult.values()) {
			rv.addAll(next);
		}
		return rv;
	}

	public Set<EClass> getAccessibleClasses() {
		return myAccessibleClasses;
	}

	public Set<EClass> getAccessibleLinkClasses() {
		return myAccessibleLinkClasses;
	}

	public Set<EReference> getAccessibleReferences() {
		return getAccessibleReferences(myAccessibleClasses.iterator());
	}

	public Set<EReference> getAccessibleReferences(Iterator<EClass> iter) {
		HashSet<EReference> rv = new HashSet<EReference>();
		for (; iter.hasNext();) {
			EClass element = iter.next();
			rv.addAll(collectAllNonContainment(element));
		}
		return rv;
	}

	@@SuppressWarnings({"unchecked" })
	List<EReference> collectAllNonContainment(EClass element) {
		List<EReference> l = new LinkedList<EReference>(element.getEAllReferences());
		l.removeAll(element.getEAllContainments());
		return l;
	}
}
@


1.5
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
d206 1
a206 1
}@


1.4
log
@use generics wherever possible
@
text
@d60 1
a60 2
		for (Iterator iter = eRefs.iterator(); iter.hasNext();) {
			EReference element = (EReference) iter.next();
a64 1
	@@SuppressWarnings("unchecked")
a68 1
	@@SuppressWarnings("unchecked")
d81 1
a81 2
		for (Iterator it2 = myRefs.iterator(); it2.hasNext();) {
			EReference r = (EReference) it2.next();
d91 1
a91 2
		for (Iterator it = myLinkClassContainmentRefs.iterator(); it.hasNext();) {
			EReference r = (EReference) it.next();
d119 1
a119 2
		for (Iterator iter = l.iterator(); iter.hasNext();) {
			EReference ref = (EReference) iter.next();
d125 1
a125 2
			for (Iterator it2 = myResult.keySet().iterator(); it2.hasNext();) {
				EClass c = (EClass) it2.next();
@


1.3
log
@use generics wherever possible
@
text
@d19 1
a23 1
import org.eclipse.emf.common.util.BasicEList;
d120 1
a120 1
		BasicEList l = collectAllNonContainment(element);
d144 1
d207 3
a209 2
	BasicEList collectAllNonContainment(EClass element) {
		BasicEList l = new BasicEList(element.getEAllReferences());
@


1.2
log
@detect containment features for links (represented with EClasses)
@
text
@d33 1
a33 1
	private final List/*<EReference>*/ myRefs;
d35 3
a37 3
	private final Map/*<EClass, Set<EClass>>*/ myResult;
	private Set myAccessibleLeaves;
	private Set myAccessibleClasses = new HashSet();
d41 1
a41 1
	private Set myAccessibleLinkClasses = new HashSet();
d45 2
a46 1
	private Set/*<EReference>*/ myLinkClassContainmentRefs = new HashSet();
d55 1
a55 1
	public Hierarchy(List/*<EReference>*/ eRefs, EClass diagramContainer, EPackage domainModel) {
d59 1
a59 1
		myResult = new HashMap();
d62 1
a62 1
			myResult.put(element.getEReferenceType(), new HashSet());
d66 1
d71 1
d94 1
a94 1
		ArrayList compatible = new ArrayList();
d106 1
a106 1
			EReference r = (EReference) compatible.get(i);
d112 1
a112 1
		return (EReference) compatible.get(0);
d145 2
a146 2
		Set nonLeaves = new HashSet();
		final HashSet leavesSet = new HashSet();
d151 2
a152 3
				for (Iterator it2 = myResult.entrySet().iterator(); it2.hasNext();) {
					Map.Entry entry = (Map.Entry) it2.next();
					EClass element = (EClass) entry.getKey();
d154 1
a154 1
						((Set) entry.getValue()).add(eClass);
d177 3
a179 4
	public Set/*<EClass>*/ getAllClasses() {
		HashSet rv = new HashSet();
		for (Iterator it = myResult.values().iterator(); it.hasNext();) {
			Set next = (Set) it.next();
d185 1
a185 1
	public Set/*<EClass>*/ getAccessibleClasses() {
d189 1
a189 1
	public Set/*<EClass>*/ getAccessibleLinkClasses() {
d193 1
a193 1
	public Set/*<EReference>*/ getAccessibleReferences() {
d197 2
a198 2
	public Set/*<EReference>*/ getAccessibleReferences(Iterator/*<EClass>*/ iter) {
		HashSet rv = new HashSet();
d200 1
a200 1
			EClass element = (EClass) iter.next();
@


1.1
log
@Introduced separate plugin for Tooling UI, moved mapping wizard of #114186 to this plugin.
Wizard got some NLS, respect selection, open-created-model-in-editor improvements as well as aligned with recent gmfmap changes.
Plus, some refactorings to address user-prioritized strategies to select nodes/links doubled number of classes we had.
@
text
@d14 1
d38 3
d42 4
d80 1
a80 1
	public EReference backRef(EClass element) {
d83 1
a83 1
			if (r.getEReferenceType().isSuperTypeOf(element)) {
d90 22
d126 2
d130 1
a130 1
				if (c.isSuperTypeOf(ref.getEReferenceType())) {
d156 1
@

