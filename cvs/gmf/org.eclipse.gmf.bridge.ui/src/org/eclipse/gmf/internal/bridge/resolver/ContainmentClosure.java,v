head	1.4;
access;
symbols
	v20080924-1925:1.4
	v20080722-1827:1.4
	v20080716-1642:1.4
	R2_1_maintenance:1.4.0.4
	Root_R2_1_maintenance:1.4
	R2_1_0:1.4
	v20080417-1610:1.4
	v20080322-0000:1.4
	v20080222-1200:1.4
	v20080215-1500:1.4
	v20080207-0207:1.4
	v20071124-0000:1.4
	v20071108-0000:1.4
	v20070903-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.4
	v20070608-1300:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070520-1200:1.4
	v20070518-1300:1.4
	v20070420-1000:1.4
	v20070413-1300:1.4
	v20070405-2000:1.4
	v20070330-1300:1.4
	v20070322-1100:1.4
	v20060316-0600:1.4
	v20070301-1200:1.4
	v20070228-2000:1.4
	v20070208-1800:1.3
	M4_20:1.3
	v20061214-0000:1.3
	M3_20:1.3
	v20061117-0800:1.3
	v20061013-1330:1.3
	v20060925-1700:1.1
	v20060919-0800:1.1
	M1_20:1.3
	v20060904-1500:1.3
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060626-1420:1.1
	v20060620-0400:1.1
	v20060616-1200:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.4
date	2007.02.22.20.26.23;	author dstadnik;	state Exp;
branches;
next	1.3;
commitid	151745ddfc6e4567;

1.3
date	2006.09.04.14.47.31;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.01.19.43.09;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.15.10.05.34;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.4
log
@use generics
@
text
@/*
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.resolver;

import java.lang.ref.WeakReference;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;

/**
 * @@author dstadnik
 */
public class ContainmentClosure {

	private WeakReference<EClass> rootRef = new WeakReference<EClass>(null); // : EClass

	private WeakReference<EPackage> scopeRef = new WeakReference<EPackage>(null); // : EPackage

	private WeakReference<Set<EClass>> closureRef = new WeakReference<Set<EClass>>(null); // : Set : EClass

	public ContainmentClosure() {
	}

	/**
	 * Checks whether type is contained within the containment closure of the root type.
	 */
	public synchronized boolean contains(EClass root, EClass type, EPackage scope) {
		assert root != null;
		assert type != null;
		assert scope != null;
		Set<EClass> closure = closureRef.get();
		if (rootRef.get() != root || scopeRef.get() != scope || closure == null) {
			closure = build(root, scope);
			rootRef = new WeakReference<EClass>(root);
			scopeRef = new WeakReference<EPackage>(scope);
			closureRef = new WeakReference<Set<EClass>>(closure);
		}
		return closure.contains(type);
	}

	private static Set<EClass> build(EClass type, EPackage scope) {
		assert type != null;
		Set<EClass> closure = new HashSet<EClass>();
		Set<EClass> roots = new HashSet<EClass>(); // types that should be investigated
		roots.add(type);
		while (!roots.isEmpty()) {
			Set<EClass> localRoots = roots;
			roots = new HashSet<EClass>();
			for (Iterator<EClass> it = localRoots.iterator(); it.hasNext();) {
				EClass root = it.next();
				for (Iterator<EReference> it1 = root.getEAllContainments().iterator(); it1.hasNext();) {
					EClass refType = it1.next().getEReferenceType();
					if (closure.contains(refType)) {
						continue; // do not traverse loops
					}
					closure.add(refType);
					roots.add(refType);
					Collection<EClass> subtypes = getSubtypes(refType, scope);
					if (subtypes != null) {
						for (Iterator<EClass> it2 = subtypes.iterator(); it2.hasNext();) {
							EClass subtype = it2.next();
							if (closure.contains(subtype)) {
								continue; // do not traverse loops
							}
							closure.add(subtype);
							roots.add(subtype);
						}
					}
				}
			}
		}
		return closure;
	}

	private static Collection<EClass> getSubtypes(EClass type, EPackage scope) {
		Collection<EClass> subtypes = null;
		for (Iterator<EObject> it = scope.eAllContents(); it.hasNext();) {
			EObject next = it.next();
			if (next instanceof EClass) {
				EClass nextType = (EClass) next;
				if (type != nextType && type.isSuperTypeOf(nextType)) {
					if (subtypes == null) {
						subtypes = new HashSet<EClass>();
					}
					subtypes.add(nextType);
				}
			}
		}
		return subtypes;
	}
}
@


1.3
log
@avoid static fields unless really needed
@
text
@d21 1
d62 1
a62 1
			Set localRoots = roots;
d64 4
a67 4
			for (Iterator it = localRoots.iterator(); it.hasNext();) {
				EClass root = (EClass) it.next();
				for (Iterator it1 = root.getEAllContainments().iterator(); it1.hasNext();) {
					EClass refType = ((EReference) it1.next()).getEReferenceType();
d73 1
a73 1
					Collection subtypes = getSubtypes(refType, scope);
d75 2
a76 2
						for (Iterator it2 = subtypes.iterator(); it2.hasNext();) {
							EClass subtype = (EClass) it2.next();
d92 2
a93 2
		for (Iterator it = scope.eAllContents(); it.hasNext();) {
			Object next = it.next();
@


1.2
log
@use generics wherever possible
@
text
@d29 1
a29 1
	private static WeakReference<EClass> rootRef = new WeakReference<EClass>(null); // : EClass
d31 1
a31 1
	private static WeakReference<EPackage> scopeRef = new WeakReference<EPackage>(null); // : EPackage
d33 1
a33 1
	private static WeakReference<Set<EClass>> closureRef = new WeakReference<Set<EClass>>(null); // : Set : EClass
d35 1
a35 1
	private ContainmentClosure() {
d41 1
a41 1
	public static synchronized boolean contains(EClass root, EClass type, EPackage scope) {
@


1.1
log
@refactor diagram element selector
@
text
@d29 1
a29 1
	private static WeakReference rootRef = new WeakReference(null); // : EClass
d31 1
a31 1
	private static WeakReference scopeRef = new WeakReference(null); // : EPackage
d33 1
a33 1
	private static WeakReference closureRef = new WeakReference(null); // : Set : EClass
d45 1
a45 1
		Set closure = (Set) closureRef.get();
d48 3
a50 3
			rootRef = new WeakReference(root);
			scopeRef = new WeakReference(scope);
			closureRef = new WeakReference(closure);
d55 1
a55 1
	private static Set build(EClass type, EPackage scope) {
d57 2
a58 2
		Set closure = new HashSet();
		Set roots = new HashSet(); // types that should be investigated
d62 1
a62 1
			roots = new HashSet();
d89 2
a90 2
	private static Collection getSubtypes(EClass type, EPackage scope) {
		Collection subtypes = null;
d97 1
a97 1
						subtypes = new HashSet();
@

