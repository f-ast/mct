head	1.5;
access;
symbols
	v20080924-1925:1.5
	v20060925-1700:1.2
	v20060919-0800:1.2
	M1_20:1.3
	v20060904-1500:1.3
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060626-1420:1.2
	v20060620-0400:1.2
	v20060616-1200:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.5
date	2006.09.19.12.19.40;	author dstadnik;	state dead;
branches;
next	1.4;

1.4
date	2006.09.07.15.35.40;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.01.19.43.09;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.19.08.13.43;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.15.10.05.34;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.5
log
@move pages and model of simple graph and tool wizards in dedicated package; provide i18n
@
text
@/*
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.wizards.pages;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.gmf.internal.bridge.resolver.NodePattern;
import org.eclipse.gmf.internal.bridge.resolver.ResolvedItem;
import org.eclipse.gmf.internal.bridge.resolver.TypeLinkPattern;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.events.SelectionListener;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Combo;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Label;

/**
 * @@deprecated move filtering functionality in DiagramElementSelectorExtension
 * 
 * @@author dstadnik
 */
class DiagramElementSelector {

	private ResolvedItem domainModel;

	Combo control;

	private Button excludeContainedNodesChoice;

	private Button excludeLinksChoice;

	public void createControl(Composite plate) {
		Label diagramElementLabel = new Label(plate, SWT.NONE);
		diagramElementLabel.setText("Diagram element:");
		diagramElementLabel.setLayoutData(new GridData());
		control = new Combo(plate, SWT.DROP_DOWN);
		control.setLayoutData(createFillHorzGridData());
		excludeContainedNodesChoice = createChoice(plate, "Exclude types that are resolved as nodes and have container");
		excludeLinksChoice = createChoice(plate, "Exclude types that are resolved as links");
	}

	private Button createChoice(Composite plate, String text) {
		Label dummy = new Label(plate, SWT.NONE);
		dummy.setLayoutData(new GridData());
		Button choice = new Button(plate, SWT.CHECK);
		choice.setText(text);
		choice.setLayoutData(createFillHorzGridData());
		choice.addSelectionListener(new SelectionListener() {

			public void widgetSelected(SelectionEvent e) {
				updateDiagramElements();
			}

			public void widgetDefaultSelected(SelectionEvent e) {
			}
		});
		return choice;
	}

	protected GridData createFillHorzGridData() {
		GridData data = new GridData();
		data.horizontalAlignment = GridData.FILL;
		data.grabExcessHorizontalSpace = true;
		return data;
	}

	public ResolvedItem getDiagramElement() {
		return domainModel == null ? null : findResolvedItemByTypeName(domainModel, control.getText());
	}

	public void setDomainModel(ResolvedItem domainModel) {
		this.domainModel = domainModel;
		updateDiagramElements();
	}

	private void updateDiagramElements() {
		Set<ResolvedItem> types = new TreeSet<ResolvedItem>(new Comparator<ResolvedItem>() {

			public int compare(ResolvedItem arg0, ResolvedItem arg1) {
				EClass type0 = (EClass) arg0.getDomainRef();
				EClass type1 = (EClass) arg1.getDomainRef();
				return type0.getName().compareToIgnoreCase(type1.getName());
			}
		});
		if (domainModel != null) {
			collectResolvedDomainTypes(types, domainModel);
		}
		String contents = control.getText();
		control.removeAll();
		for (Iterator it = types.iterator(); it.hasNext();) {
			EClass type = (EClass) ((ResolvedItem) it.next()).getDomainRef();
			control.add(type.getName());
			if (contents.equals(type.getName())) {
				control.setText(contents);
			}
		}
	}

	private void collectResolvedDomainTypes(Collection<ResolvedItem> types, ResolvedItem item) {
		if (item.getDomainRef() instanceof EClass) {
			boolean ignore = false;
			if (excludeContainedNodesChoice.getSelection()) {
				ignore |= item.getPattern() instanceof NodePattern;
			}
			if (excludeLinksChoice.getSelection()) {
				ignore |= item.getPattern() instanceof TypeLinkPattern;
			}
			if (!ignore) {
				types.add(item);
			}
		}
		for (Iterator it = item.getChildren().iterator(); it.hasNext();) {
			collectResolvedDomainTypes(types, (ResolvedItem) it.next());
		}
	}

	private ResolvedItem findResolvedItemByTypeName(ResolvedItem item, String typeName) {
		if (item.getDomainRef() instanceof EClass && ((EClass) item.getDomainRef()).getName().equals(typeName)) {
			return item;
		}
		for (Iterator it = item.getChildren().iterator(); it.hasNext();) {
			ResolvedItem result = findResolvedItemByTypeName((ResolvedItem) it.next(), typeName);
			if (result != null) {
				return result;
			}
		}
		return null;
	}
}
@


1.4
log
@#156342 Simple graph and tool def wizards should use common domain model selection page
@
text
@@


1.3
log
@use generics wherever possible
@
text
@d34 2
@


1.2
log
@#129322 Allow to select domain model element on definition page that will be used as diagram canvas element
@
text
@d91 1
a91 1
		Set types = new TreeSet(new Comparator() {
d93 3
a95 3
			public int compare(Object arg0, Object arg1) {
				EClass type0 = (EClass) ((ResolvedItem) arg0).getDomainRef();
				EClass type1 = (EClass) ((ResolvedItem) arg1).getDomainRef();
d113 1
a113 1
	private void collectResolvedDomainTypes(Collection types, ResolvedItem item) {
@


1.1
log
@refactor diagram element selector
@
text
@d40 1
a40 1
	private Combo diagramElementCombo;
d50 2
a51 12
		diagramElementCombo = new Combo(plate, SWT.DROP_DOWN);
		diagramElementCombo.setLayoutData(createFillHorzGridData());
		diagramElementCombo.addSelectionListener(new SelectionListener() {

			public void widgetSelected(SelectionEvent e) {
				System.err.println(diagramElementCombo.getText());
				// TODO : validate selection
			}

			public void widgetDefaultSelected(SelectionEvent e) {
			}
		});
d82 1
a82 1
		return domainModel == null ? null : findResolvedItemByTypeName(domainModel, diagramElementCombo.getText());
d102 2
a103 2
		String contents = diagramElementCombo.getText();
		diagramElementCombo.removeAll();
d106 1
a106 1
			diagramElementCombo.add(type.getName());
d108 1
a108 1
				diagramElementCombo.setText(contents);
a110 6
		if (diagramElementCombo.getText().length() == 0 && diagramElementCombo.getItemCount() > 0) {
			diagramElementCombo.setText(diagramElementCombo.getItem(0));
		}
		if (!contents.equals(diagramElementCombo.getText())) {
			// TODO : update resolution tree
		}
@

