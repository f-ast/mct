head	1.10;
access;
symbols
	v20080924-1925:1.10
	v20060925-1700:1.4
	v20060919-0800:1.4
	M1_20:1.5
	v20060904-1500:1.5
	v20060713-1700:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060626-1420:1.4
	v20060620-0400:1.4
	v20060616-1200:1.3
	v20060609-1400:1.2
	v20060531-1730:1.1
	v20060526-1200:1.1
	v20060519-0800:1.1
	v20060512-1000:1.1
	I20060512-1000:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.10
date	2006.09.19.12.19.41;	author dstadnik;	state dead;
branches;
next	1.9;

1.9
date	2006.09.18.18.12.41;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.15.12.18.10;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.12.16.50.15;	author dstadnik;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.05.12.18.28;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.04.14.47.31;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.19.08.13.43;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.15.10.05.34;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.05.10.18.25;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.01.12.46.08;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.10
log
@move pages and model of simple graph and tool wizards in dedicated package; provide i18n
@
text
@/*
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.resolver;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.gmf.internal.bridge.ui.Plugin;

/**
 * @@author dstadnik
 */
public class StructureBuilder {

	private final StructureResolver resolver;

	private final boolean withLabels;

	private final ContainmentClosure containmentClosure;

	public StructureBuilder(StructureResolver resolver, boolean withLabels) {
		this.resolver = resolver;
		this.withLabels = withLabels;
		containmentClosure = Plugin.getDefault().getContaintmentClosure();
	}

	public final boolean isWithLabels() {
		return withLabels;
	}

	public ResolvedItem process(DomainModelSource dms) {
		ResolvedItem item = new ResolvedItem(null, dms.getContents(), null, ResolvedItem.NO_RESOLUTIONS, false);
		for (Iterator it = dms.getContents().eAllContents(); it.hasNext();) {
			Object next = it.next();
			if (next instanceof EClass) {
				item.addChild(process((EClass) next, dms));
			}
		}
		return item;
	}

	protected ResolvedItem process(EClass domainClass, DomainModelSource dms) {
		final EClass diagramClass = dms.getDiagramElement();
		final EPackage domainPackage = dms.getContents();
		Resolution resolution;
		Resolution[] resolutions = ResolvedItem.NODE_LINK_RESOLUTIONS;
		TypePattern pattern = resolver.resolve(domainClass, domainPackage);
		if (pattern instanceof NodePattern) {
			resolution = Resolution.NODE;
			if (diagramClass != null && !containmentClosure.contains(diagramClass, domainClass, domainPackage)) {
				resolution = null;
			}
		} else if (pattern instanceof TypeLinkPattern) {
			resolution = Resolution.LINK;
			if (diagramClass != null) {
				TypeLinkPattern linkPattern = (TypeLinkPattern) pattern;
				if (linkPattern.getSource() != null && !containmentClosure.contains(diagramClass, linkPattern.getSource().getEReferenceType(), domainPackage)) {
					resolution = null;
				}
				if (linkPattern.getTarget() != null && !containmentClosure.contains(diagramClass, linkPattern.getTarget().getEReferenceType(), domainPackage)) {
					resolution = null;
				}
			}
		} else {
			resolution = null;
			if (domainClass.isAbstract() || domainClass.isInterface()) {
				resolutions = ResolvedItem.NO_RESOLUTIONS;
			}
		}
		ResolvedItem item = new ResolvedItem(resolution, domainClass, pattern, resolutions, dms.isDisabled(domainClass));
		addLabels(item, domainClass, dms);
		addRefLinks(item, domainClass, dms);
		return item;
	}

	protected void addLabels(ResolvedItem typeItem, EClass type, DomainModelSource dms) {
		if (!withLabels) {
			return;
		}
		Resolution baseResolution = typeItem.getResolution() == null ? null : Resolution.LABEL;
		Collection resolvedAttrs = Collections.emptyList();
		if (typeItem.getPattern() != null) {
			resolvedAttrs = Arrays.asList(typeItem.getPattern().getLabels());
		}
		Resolution[] possibleResolutions = Arrays.equals(typeItem.getPossibleResolutions(), ResolvedItem.NO_RESOLUTIONS) ? ResolvedItem.NO_RESOLUTIONS : ResolvedItem.LABEL_RESOLUTIONS;
		for (EAttribute attribute : (List<? extends EAttribute>) type.getEAllAttributes()) {
			Resolution resolution = resolvedAttrs.contains(attribute) ? baseResolution : null;
			typeItem.addChild(new ResolvedItem(resolution, attribute, null, possibleResolutions, dms.isDisabled(attribute)));
		}
	}

	protected void addRefLinks(ResolvedItem typeItem, EClass type, DomainModelSource dms) {
		Resolution baseResolution = typeItem.getResolution() != Resolution.NODE ? null : Resolution.LINK;
		Collection resolvedRefs = Collections.emptyList();
		if (typeItem.getPattern() instanceof NodePattern) {
			resolvedRefs = Arrays.asList(((NodePattern) typeItem.getPattern()).getRefLinks());
		}
		Resolution[] possibleResolutions = Arrays.equals(typeItem.getPossibleResolutions(), ResolvedItem.NO_RESOLUTIONS) ? ResolvedItem.NO_RESOLUTIONS : ResolvedItem.LINK_RESOLUTIONS;
		for (EReference reference : (List<? extends EReference>) type.getEAllReferences()) {
			Resolution resolution = resolvedRefs.contains(reference) ? baseResolution : null;
			typeItem.addChild(new ResolvedItem(resolution, reference, null, possibleResolutions, dms.isDisabled(reference)));
		}
	}
}
@


1.9
log
@do not provide unresolved features
@
text
@@


1.8
log
@#126531 Wizards that infer tooling and graph definitions should be able to add results to the existing models
@
text
@d15 2
d96 5
a100 1
		Resolution resolution = typeItem.getResolution() == null ? null : Resolution.LABEL;
d103 1
d109 5
a113 1
		Resolution resolution = typeItem.getResolution() != Resolution.NODE ? null : Resolution.LINK;
d116 1
@


1.7
log
@#148976 New GMFGraph/GMFTool Simple model Wizard: show references contained by recognized link nodes in model Definition page
@
text
@d14 1
d45 3
a47 3
	public ResolvedItem process(EPackage domainPackage, EClass diagramClass) {
		ResolvedItem item = new ResolvedItem(null, domainPackage, null, ResolvedItem.NO_RESOLUTIONS);
		for (Iterator it = domainPackage.eAllContents(); it.hasNext();) {
d50 1
a50 1
				item.addChild(process((EClass) next, domainPackage, diagramClass));
d56 3
a58 1
	public ResolvedItem process(EClass domainClass, EPackage domainPackage, EClass diagramClass) {
d84 3
a86 3
		ResolvedItem item = new ResolvedItem(resolution, domainClass, pattern, resolutions);
		addLabels(item, domainClass);
		addRefLinks(item, domainClass);
d90 1
a90 1
	protected void addLabels(ResolvedItem typeItem, EClass type) {
d95 1
d97 1
a97 1
			typeItem.addChild(new ResolvedItem(resolution, attribute, null, ResolvedItem.LABEL_RESOLUTIONS));
d101 1
a101 1
	protected void addRefLinks(ResolvedItem typeItem, EClass type) {
d103 1
d105 1
a105 1
			typeItem.addChild(new ResolvedItem(resolution, reference, null, ResolvedItem.LINK_RESOLUTIONS));
@


1.6
log
@#148810 There is no need to show labels in wizard that creates tooling definition
@
text
@d15 1
d17 1
d20 1
d45 1
a45 1
		ResolvedItem item = new ResolvedItem(null, domainPackage, null, ResolvedItem.DEFAULT_RESOLUTIONS);
d56 2
a57 1
		ResolvedItem item;
d60 1
a60 1
			Resolution resolution = Resolution.NODE;
a63 7
			item = new ResolvedItem(resolution, domainClass, pattern, ResolvedItem.NODE_LINK_RESOLUTIONS);
			NodePattern nodePattern = (NodePattern) pattern;
			addLabels(item, nodePattern);
			Resolution linkResolution = item.getResolution() == null ? null : Resolution.LINK;
			for (int i = 0; i < nodePattern.getRefLinks().length; i++) {
				item.addChild(new ResolvedItem(linkResolution, nodePattern.getRefLinks()[i], null, ResolvedItem.LINK_RESOLUTIONS));
			}
d65 1
a65 1
			Resolution resolution = Resolution.LINK;
a74 3
			item = new ResolvedItem(resolution, domainClass, pattern, ResolvedItem.NODE_LINK_RESOLUTIONS);
			TypeLinkPattern linkPattern = (TypeLinkPattern) pattern;
			addLabels(item, linkPattern);
d76 1
a76 1
			Resolution[] resolutions = ResolvedItem.NODE_LINK_RESOLUTIONS;
d78 1
a78 1
				resolutions = ResolvedItem.DEFAULT_RESOLUTIONS;
a79 1
			item = new ResolvedItem(null, domainClass, pattern, resolutions);
d81 3
d87 1
a87 1
	protected void addLabels(ResolvedItem typeItem, TypePattern pattern) {
d92 9
a100 2
		for (int i = 0; i < pattern.getLabels().length; i++) {
			typeItem.addChild(new ResolvedItem(resolution, pattern.getLabels()[i], null, ResolvedItem.LABEL_RESOLUTIONS));
@


1.5
log
@avoid static fields unless really needed
@
text
@d27 2
d31 1
a31 1
	public StructureBuilder(StructureResolver resolver) {
d33 1
d37 4
d92 3
@


1.4
log
@#129322 Allow to select domain model element on definition page that will be used as diagram canvas element
@
text
@d18 1
d25 3
a27 1
	private StructureResolver resolver;
d31 1
d50 1
a50 1
			if (diagramClass != null && !ContainmentClosure.contains(diagramClass, domainClass, domainPackage)) {
d64 1
a64 1
				if (linkPattern.getSource() != null && !ContainmentClosure.contains(diagramClass, linkPattern.getSource().getEReferenceType(), domainPackage)) {
d67 1
a67 1
				if (linkPattern.getTarget() != null && !ContainmentClosure.contains(diagramClass, linkPattern.getTarget().getEReferenceType(), domainPackage)) {
@


1.3
log
@refactor diagram element selector
@
text
@d43 1
a43 1
		TypePattern pattern = resolver.resolve(domainClass, domainPackage, diagramClass);
d45 5
a49 1
			item = new ResolvedItem(Resolution.NODE, domainClass, pattern, ResolvedItem.NODE_LINK_RESOLUTIONS);
d52 1
d54 1
a54 1
				item.addChild(new ResolvedItem(Resolution.LINK, nodePattern.getRefLinks()[i], null, ResolvedItem.LINK_RESOLUTIONS));
d57 11
a67 1
			item = new ResolvedItem(Resolution.LINK, domainClass, pattern, ResolvedItem.NODE_LINK_RESOLUTIONS);
d81 1
d83 1
a83 1
			typeItem.addChild(new ResolvedItem(Resolution.LABEL, pattern.getLabels()[i], null, ResolvedItem.LABEL_RESOLUTIONS));
@


1.2
log
@#141548 GMFGraph wizard failed to pick up elements defined in subpackages
@
text
@d30 1
a30 1
	public ResolvedItem process(EPackage domainPackage) {
d35 1
a35 1
				item.addChild(process((EClass) next, domainPackage));
d41 1
a41 1
	public ResolvedItem process(EClass domainClass, EPackage domainPackage) {
d43 1
a43 1
		TypePattern pattern = resolver.resolve(domainClass, domainPackage);
d56 5
a60 1
			item = new ResolvedItem(null, domainClass, pattern, ResolvedItem.DEFAULT_RESOLUTIONS);
@


1.1
log
@#129892 Move graphdef and tooldef wizards from codegen.ui to bridge.ui plugin
@
text
@d32 1
a32 1
		for (Iterator it = domainPackage.getEClassifiers().iterator(); it.hasNext();) {
d35 1
a35 1
				item.addChild(process((EClass) next));
d41 1
a41 1
	public ResolvedItem process(EClass domainClass) {
d43 1
a43 1
		TypePattern pattern = resolver.resolve(domainClass);
@

