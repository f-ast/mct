head	1.4;
access;
symbols
	v20080924-1925:1.4
	v20080722-1827:1.4
	v20080716-1642:1.4
	R2_1_maintenance:1.4.0.4
	Root_R2_1_maintenance:1.4
	R2_1_0:1.4
	v20080417-1610:1.4
	v20080322-0000:1.4
	v20080222-1200:1.4
	v20080215-1500:1.4
	v20080207-0207:1.4
	v20071124-0000:1.4
	v20071108-0000:1.4
	v20070903-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.4
	v20070608-1300:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070520-1200:1.4
	v20070518-1300:1.4
	v20070420-1000:1.4
	v20070413-1300:1.4
	v20070405-2000:1.3
	v20070330-1300:1.3
	v20070322-1100:1.3
	v20060316-0600:1.3
	v20070301-1200:1.3
	v20070228-2000:1.3
	v20070208-1800:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.4
date	2007.04.12.14.40.18;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	5f58461e44d04567;

1.3
date	2007.02.06.18.08.29;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	16f845c8c3f34567;

1.2
date	2007.01.29.19.13.08;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	14745be47444567;

1.1
date	2007.01.18.18.49.15;	author atikhomirov;	state Exp;
branches;
next	;
commitid	197b45afc1284567;


desc
@@


1.4
log
@[181896] afedorov - Allow transformation wizard to complete if there are errors in the resulting gmfgen model
refactored not to define extra strings for page names, titles and descriptions moved to owning pages.
@
text
@/**
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Alexander Fedorov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.transform;

import java.text.MessageFormat;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.jface.dialogs.IMessageProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.osgi.util.NLS;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.ui.dialogs.WizardNewFileCreationPage;

class GMFGenNewFileCreationPage extends WizardNewFileCreationPage {

	static final String EXT_GMFGEN = "gmfgen"; //$NON-NLS-1$
	
	private ResourceGroupEmulator resourceGroupEmulator;

	public GMFGenNewFileCreationPage(String pageId, IStructuredSelection selection) {
		super(pageId, selection);
		setTitle(Messages.TransformToGenModelWizard_title_gmfgen);
		setDescription(Messages.TransformToGenModelWizard_descr_gmfgen);
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.ui.dialogs.WizardNewFileCreationPage#createControl(org.eclipse.swt.widgets.Composite)
	 */
	@@Override
	public void createControl(Composite parent) {
		resourceGroupEmulator = new ResourceGroupEmulator();
		super.createControl(parent);
		validateFileExists();
	}

	protected boolean validatePage() {
		if (emulateValidate()) {
			// Make sure the file ends in ".gmfgen".
			//
			String enteredExt = new Path(getFileName()).getFileExtension();
			if (enteredExt == null || !enteredExt.equals(EXT_GMFGEN)) {
				String pattern = Messages.GMFGenNewFileCreationPage_e_filename;
				setErrorMessage(MessageFormat.format(pattern, new Object [] { EXT_GMFGEN }));
				return false;
			}
			else {
		        validateFileExists();
				return true;
			}
		}
		else {
			return false;
		}
	}

	private void validateFileExists() {
		IPath resourcePath = getContainerFullPath().append(
				getFileName());
		if (isFileExists(resourcePath)) {
			setMessage(Messages.ResourceGroup_nameExists, IMessageProvider.WARNING);
		}
	}

	public IFile getModelFile() {
		return ResourcesPlugin.getWorkspace().getRoot().getFile(getContainerFullPath().append(getFileName()));
	}
	
	private boolean emulateValidate() {
		boolean valid = true;

		if (!resourceGroupEmulator.validateControls()) {
			// if blank name then fail silently
			if (resourceGroupEmulator.getProblemType() == ResourceGroupEmulator.PROBLEM_RESOURCE_EMPTY
					|| resourceGroupEmulator.getProblemType() == ResourceGroupEmulator.PROBLEM_CONTAINER_EMPTY) {
				setMessage(resourceGroupEmulator.getProblemMessage());
				setErrorMessage(null);
			} else {
				setErrorMessage(resourceGroupEmulator.getProblemMessage());
			}
			valid = false;
		}

		String resourceName = getFileName();
		IWorkspace workspace = ResourcesPlugin.getWorkspace();
		IStatus result = workspace.validateName(resourceName, IResource.FILE);
		if (!result.isOK()) {
			setErrorMessage(result.getMessage());
			return false;
		}

		IStatus linkedResourceStatus = null;
		if (valid) {
			linkedResourceStatus = validateLinkedResource();
			if (linkedResourceStatus.getSeverity() == IStatus.ERROR) {
				valid = false;
			}
		}
		// validateLinkedResource sets messages itself
		if (valid
				&& (linkedResourceStatus == null || linkedResourceStatus.isOK())) {
			setMessage(null);
			setErrorMessage(null);
		}
		return valid;
	}

	boolean isFileExists(IPath resourcePath) {
		if (resourcePath == null) {
			return false;
		}
		IWorkspace workspace = ResourcesPlugin.getWorkspace();
		return (workspace.getRoot().getFolder(resourcePath).exists() || workspace
		        .getRoot().getFile(resourcePath).exists());
	}

	//XXX: remove after fix of https://bugs.eclipse.org/bugs/show_bug.cgi?id=172000
	private class ResourceGroupEmulator {
		
	    static final int PROBLEM_NONE = 0;
	    static final int PROBLEM_RESOURCE_EMPTY = 1;
	    static final int PROBLEM_RESOURCE_EXIST = 2;
	    static final int PROBLEM_PATH_INVALID = 4;
	    static final int PROBLEM_CONTAINER_EMPTY = 5;
	    static final int PROBLEM_PROJECT_DOES_NOT_EXIST = 6;
	    static final int PROBLEM_NAME_INVALID = 7;
	    static final int PROBLEM_PATH_OCCUPIED = 8;

	    private boolean allowExistingResources = true;
	    private String problemMessage = "";//$NON-NLS-1$
	    private int problemType = PROBLEM_NONE;
	    
	    
		ResourceGroupEmulator() {
			//just create
		}

		boolean validateControls() {
	        // don't attempt to validate controls until they have been created
			try {
				getFileName();
			} catch (Exception e) {
	            return false;
			}
	        problemType = PROBLEM_NONE;
	        problemMessage = "";//$NON-NLS-1$

	        if (!validateContainer() || !validateResourceName()) {
				return false;
			}

	        IPath path = getContainerFullPath().append(
	        		getFileName());
	        return validateFullResourcePath(path);
	    }

		private boolean validateContainer() {
	        IPath path = getContainerFullPath();
	        if (path == null) {
	            problemType = PROBLEM_CONTAINER_EMPTY;
	            problemMessage = Messages.ResourceGroup_folderEmpty;
	            return false;
	        }
	        IWorkspace workspace = ResourcesPlugin.getWorkspace();
	        String projectName = path.segment(0);
	        if (projectName == null
	                || !workspace.getRoot().getProject(projectName).exists()) {
	            problemType = PROBLEM_PROJECT_DOES_NOT_EXIST;
	            problemMessage = Messages.ResourceGroup_noProject;
	            return false;
	        }
	        //path is invalid if any prefix is occupied by a file
	        IWorkspaceRoot root = workspace.getRoot();
	        while (path.segmentCount() > 1) {
	        	if (root.getFile(path).exists()) {
	        		problemType = PROBLEM_PATH_OCCUPIED;
	        		problemMessage = NLS.bind(Messages.ResourceGroup_pathOccupied, path.makeRelative());
	        		return false;
	        	}
	        	path = path.removeLastSegments(1);
	        }
	        return true;
	    }

		private boolean validateResourceName() {
	        String resourceName = getFileName();

	        if (resourceName.length() == 0) {
	            problemType = PROBLEM_RESOURCE_EMPTY;
	            problemMessage = NLS.bind(Messages.ResourceGroup_emptyName, Messages.WizardNewFileCreationPage_file);
	            return false;
	        }

	        if (!Path.ROOT.isValidPath(resourceName)) {
	            problemType = PROBLEM_NAME_INVALID;
	            problemMessage = NLS.bind(Messages.ResourceGroup_invalidFilename, resourceName);
	            return false;
	        }
	        return true;
	    }

		private boolean validateFullResourcePath(IPath resourcePath) {
	        IWorkspace workspace = ResourcesPlugin.getWorkspace();

	        IStatus result = workspace.validatePath(resourcePath.toString(),
	                IResource.FOLDER);
	        if (!result.isOK()) {
	            problemType = PROBLEM_PATH_INVALID;
	            problemMessage = result.getMessage();
	            return false;
	        }

	        if (!allowExistingResources
	                && isFileExists(resourcePath)) {
	            problemType = PROBLEM_RESOURCE_EXIST;
	            problemMessage = Messages.ResourceGroup_nameExists;
	            return false;
	        }
	        return true;
	    }

		String getProblemMessage() {
	        return problemMessage;
	    }

		int getProblemType() {
	        return problemType;
	    }
	}
}
@


1.3
log
@[172194] afedorov - Preserve "Create generator model" wizard settings
@
text
@d30 1
a30 1
public class GMFGenNewFileCreationPage extends WizardNewFileCreationPage {
d38 2
@


1.2
log
@[172016] afedorov - "Create generator model" wizard should allow to reconcile existing gmfgen
@
text
@d47 1
d61 1
a61 5
		        IPath resourcePath = getContainerFullPath().append(
		        		getFileName());
		        if (isFileExists(resourcePath)) {
					setMessage(Messages.ResourceGroup_nameExists, IMessageProvider.WARNING);
				}
d70 8
@


1.1
log
@[148836] afedorov - Provide "Create generator model..." wizard instead of existing dialog sequence
@
text
@d17 3
d21 2
d24 1
d26 2
d33 2
d39 9
d50 1
a50 1
		if (super.validatePage()) {
d60 5
d76 162
@

