head	1.8;
access;
symbols
	v20080924-1925:1.8
	v20080722-1827:1.8
	v20080716-1642:1.8
	R2_1_maintenance:1.8.0.4
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080417-1610:1.8
	v20080322-0000:1.8
	v20080222-1200:1.8
	v20080215-1500:1.8
	v20080207-0207:1.8
	v20071124-0000:1.8
	v20071108-0000:1.8
	v20070903-0000:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	v20070621-0000:1.8
	RC3_20:1.8
	v20070608-1300:1.8
	v20070605-1400:1.8
	v20070601-1400:1.8
	v20070520-1200:1.8
	v20070518-1300:1.8
	v20070420-1000:1.8
	v20070413-1300:1.8
	v20070405-2000:1.8
	v20070330-1300:1.8
	v20070322-1100:1.8
	v20060316-0600:1.8
	v20070301-1200:1.8
	v20070228-2000:1.8
	v20070208-1800:1.6
	M4_20:1.6
	v20061214-0000:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061013-1330:1.6
	v20060925-1700:1.5
	v20060919-0800:1.5
	M1_20:1.6
	v20060904-1500:1.6
	v20060713-1700:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	v20060627-1200:1.5
	v20060626-1420:1.5
	v20060620-0400:1.5
	v20060616-1200:1.4
	v20060609-1400:1.3
	v20060531-1730:1.1
	v20060526-1200:1.1
	v20060519-0800:1.1
	v20060512-1000:1.1
	I20060512-1000:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2007.02.22.20.29.45;	author dstadnik;	state Exp;
branches;
next	1.7;
commitid	54f145ddfd384567;

1.7
date	2007.02.22.20.26.23;	author dstadnik;	state Exp;
branches;
next	1.6;
commitid	151745ddfc6e4567;

1.6
date	2006.09.01.19.43.09;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.19.08.13.43;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.15.10.05.34;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.05.10.18.25;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.01.13.38.58;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.01.12.46.08;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.8
log
@[169204] allow cyclic containment
@
text
@/*
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.resolver;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;

/**
 * @@author dstadnik
 */
public class StructureResolver {

	private Vocabulary nodeVocabulary;

	private Vocabulary linkVocabulary;

	private Vocabulary linkSourceVocabulary;

	private Vocabulary linkTargetVocabulary;

	public StructureResolver() {
		nodeVocabulary = new Vocabulary();
		nodeVocabulary.add(new String[] { "node", "item" }); //$NON-NLS-1$  //$NON-NLS-2$
		linkVocabulary = new Vocabulary();
		linkVocabulary.add(new String[] { "link", "connection", "relation", "dependency", "flow" }); //$NON-NLS-1$  //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
		linkSourceVocabulary = new Vocabulary();
		linkSourceVocabulary.add(new String[] { "source", "src", "from" }); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
		linkTargetVocabulary = new Vocabulary();
		linkTargetVocabulary.add(new String[] { "destination", "dst", "dest", "to" }); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
	}

	protected boolean guessNode(EClass type) {
		return nodeVocabulary.containsWords(type.getName());
	}

	protected boolean guessLink(EClass type) {
		return linkVocabulary.containsWords(type.getName());
	}

	protected EReference guessLinkSource(EReference[] refs) {
		for (int i = 0; i < refs.length; i++) {
			if (linkSourceVocabulary.containsWords(refs[i].getName())) {
				return refs[i];
			}
		}
		return null;
	}

	protected EReference guessLinkTarget(EReference[] refs) {
		for (int i = 0; i < refs.length; i++) {
			if (linkTargetVocabulary.containsWords(refs[i].getName())) {
				return refs[i];
			}
		}
		return null;
	}

	public TypePattern resolve(EClass type, EPackage scope) {
		if (type.isAbstract() || type.isInterface()) {
			return null;
		}
		EReference[] containments = getContainments(type, scope);
		if (containments.length == 0) {
			// skip diagram node and other unattached types
			return null;
		}
		EAttribute[] labels = getLabels(type);
		EReference[] refs = getEAllPotentialRefs(type, true);
		// heuristics : type without refs is a node
		// heuristics : type that has containment feature(s) is likely a node
		// heuristics : guess node by vocabulary
		if (refs.length == 0 || !type.getEAllContainments().isEmpty() || guessNode(type)) {
			refs = getEAllPotentialRefs(type, false);
			return new NodePattern(type, labels, refs);
		}
		EReference source;
		EReference target;
		if (refs.length == 1) {
			// heuristics : one ref is target; source is container
			source = null;
			target = refs[0];
		} else {
			// heuristics : guess source and target refs by vocabulary
			source = guessLinkSource(refs);
			target = guessLinkTarget(refs);
			if (source == null) {
				source = target == refs[0] ? refs[1] : refs[0];
			}
			if (target == null) {
				target = source == refs[1] ? refs[0] : refs[1];
			}
		}
		return new TypeLinkPattern(type, labels, source, target);
	}

	protected EAttribute[] getLabels(EClass type) {
		List<EAttribute> attrs = new ArrayList<EAttribute>();
		for (Iterator<EAttribute> it = type.getEAllAttributes().iterator(); it.hasNext();) {
			attrs.add(it.next());
		}
		return attrs.toArray(new EAttribute[attrs.size()]);
	}

	/**
	 * Finds all potential references. Such references are not containers, containments,
	 * derived and have type from the same package as the host type; thus they may
	 * connect types as links on diagram surface.
	 */
	protected EReference[] getEAllPotentialRefs(EClass type, boolean forLink) {
		List<EReference> refs = new ArrayList<EReference>();
		for (Iterator<EReference> it = type.getEAllReferences().iterator(); it.hasNext();) {
			EReference ref = it.next();
			EClass refType = ref.getEReferenceType();
			if (forLink && (refType.isSuperTypeOf(type) || ref.isMany())) {
				continue;
			}
			boolean samePackage = refType.getEPackage().equals(type.getEPackage());
			if (!ref.isDerived() && !ref.isContainer() && !ref.isContainment() && samePackage) {
				refs.add(ref);
			}
		}
		return refs.toArray(new EReference[refs.size()]);
	}

	/**
	 * Returns list of references that contain this type.
	 */
	protected EReference[] getContainments(EClass type, EPackage scope) {
		List<EReference> refs = new ArrayList<EReference>();
		for (Iterator<EObject> it = scope.eAllContents(); it.hasNext();) {
			EObject element = it.next();
			if (element instanceof EReference) {
				EReference ref = (EReference) element;
				if (ref.isContainment() && ref.getEReferenceType().isSuperTypeOf(type)) {
					refs.add(ref);
				}
			}
		}
		return refs.toArray(new EReference[refs.size()]);
	}
}
@


1.7
log
@use generics
@
text
@d150 1
a150 1
				if (ref.isContainment() && ref.getEReferenceType().isSuperTypeOf(type) && ref.getEContainingClass() != type) {
@


1.6
log
@use generics wherever possible
@
text
@d114 2
a115 3
		for (Iterator it = type.getEAllAttributes().iterator(); it.hasNext();) {
			EAttribute attr = (EAttribute) it.next();
			attrs.add(attr);
d127 2
a128 2
		for (Iterator it = type.getEAllReferences().iterator(); it.hasNext();) {
			EReference ref = (EReference) it.next();
d146 2
a147 2
		for (Iterator it = scope.eAllContents(); it.hasNext();) {
			EObject element = (EObject) it.next();
@


1.5
log
@#129322 Allow to select domain model element on definition page that will be used as diagram canvas element
@
text
@d113 1
a113 1
		List attrs = new ArrayList();
d118 1
a118 1
		return (EAttribute[]) attrs.toArray(new EAttribute[attrs.size()]);
d127 1
a127 1
		List refs = new ArrayList();
d139 1
a139 1
		return (EReference[]) refs.toArray(new EReference[refs.size()]);
d146 1
a146 1
		List refs = new ArrayList();
d156 1
a156 1
		return (EReference[]) refs.toArray(new EReference[refs.size()]);
@


1.4
log
@refactor diagram element selector
@
text
@d74 1
a74 1
	public TypePattern resolve(EClass type, EPackage domainPackage, EClass diagramClass) {
d78 1
a78 1
		EReference[] containments = getContainments(type, domainPackage);
a88 3
			if (diagramClass != null && !ContainmentClosure.contains(diagramClass, type, domainPackage)) {
				return null; // type can't be contained within the diagram class
			}
a108 8
		if (diagramClass != null) {
			if (source != null && !ContainmentClosure.contains(diagramClass, source.getEReferenceType(), domainPackage)) {
				return null; // source type can't be contained within the diagram class
			}
			if (target != null && !ContainmentClosure.contains(diagramClass, target.getEReferenceType(), domainPackage)) {
				return null; // target type can't be contained within the diagram class
			}
		}
d145 1
a145 1
	protected EReference[] getContainments(EClass type, EPackage domainPackage) {
d147 1
a147 1
		for (Iterator it = domainPackage.eAllContents(); it.hasNext();) {
@


1.3
log
@#141548 GMFGraph wizard failed to pick up elements defined in subpackages
@
text
@d74 1
a74 1
	public TypePattern resolve(EClass type, EPackage domainPackage) {
d89 3
d112 8
d133 3
a135 2
	 * Finds all potential references. Such references are not containers, containments, derived and have type from the same package as the host type; thus they may connect types as links on diagram
	 * surface.
@


1.2
log
@add nls markers
@
text
@d21 1
d74 1
a74 1
	public TypePattern resolve(EClass type) {
d78 1
a78 1
		EReference[] containments = getContainments(type);
d144 1
a144 1
	protected EReference[] getContainments(EClass type) {
d146 1
a146 1
		for (Iterator it = type.getEPackage().eAllContents(); it.hasNext();) {
@


1.1
log
@#129892 Move graphdef and tooldef wizards from codegen.ui to bridge.ui plugin
@
text
@d38 1
a38 1
		nodeVocabulary.add(new String[] { "node", "item" });
d40 1
a40 1
		linkVocabulary.add(new String[] { "link", "connection", "relation", "dependency", "flow" });
d42 1
a42 1
		linkSourceVocabulary.add(new String[] { "source", "src", "from" });
d44 1
a44 1
		linkTargetVocabulary.add(new String[] { "destination", "dst", "dest", "to" });
@

