head	1.14;
access;
symbols
	v20080924-1925:1.14
	v20080722-1827:1.14
	v20080716-1642:1.14
	R2_1_maintenance:1.14.0.2
	Root_R2_1_maintenance:1.14
	R2_1_0:1.14
	v20080417-1610:1.14
	v20080322-0000:1.14
	v20080222-1200:1.14
	v20080215-1500:1.14
	v20080207-0207:1.13.2.1
	v20071124-0000:1.13.2.1
	v20071108-0000:1.14
	v20070903-0000:1.13
	v20070809-0000:1.13
	R2_0_maintenance:1.13.0.2
	R2_0:1.13
	R4_20:1.13
	v20070621-0000:1.13
	RC3_20:1.12
	v20070608-1300:1.12
	v20070605-1400:1.12
	v20070601-1400:1.12
	v20070520-1200:1.12
	v20070518-1300:1.12
	v20070420-1000:1.12
	v20070413-1300:1.12
	v20070405-2000:1.12
	v20070330-1300:1.12
	v20070322-1100:1.12
	v20060316-0600:1.12
	v20070301-1200:1.11
	v20070228-2000:1.11
	v20070208-1800:1.11
	M4_20:1.11
	v20061214-0000:1.11
	M3_20:1.11
	v20061117-0800:1.11
	v20061013-1330:1.10
	v20060925-1700:1.9
	v20060919-0800:1.9
	M1_20:1.10
	v20060904-1500:1.10
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060626-1420:1.9
	v20060620-0400:1.9
	v20060616-1200:1.9
	v20060609-1400:1.9
	v20060531-1730:1.9
	v20060526-1200:1.9
	v20060519-0800:1.9
	v20060512-1000:1.8
	I20060512-1000:1.8
	I20060428-1300:1.6
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.5
	S20060303-1600:1.5;
locks; strict;
comment	@# @;
expand	@k@;


1.14
date	2007.10.23.13.24.54;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	640a471df6254567;

1.13
date	2007.06.21.14.03.14;	author atikhomirov;	state Exp;
branches
	1.13.2.1;
next	1.12;
commitid	1176467a85204567;

1.12
date	2007.03.14.12.59.33;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	114b45f7f1b34567;

1.11
date	2006.10.19.15.21.59;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.04.14.47.44;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.16.16.12.26;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.11.09.42.02;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.10.15.12.30;	author dstadnik;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.07.19.13.25;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.03.20.48.08;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.03.20.47.47;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.03.16.50.24;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.03.14.16.22;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.28.19.07.41;	author atikhomirov;	state Exp;
branches;
next	;

1.13.2.1
date	2007.11.20.12.56.22;	author dstadnik;	state Exp;
branches;
next	;
commitid	5e404742d9754567;


desc
@@


1.14
log
@make compilable with 3.3.1
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.wizards.pages;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.common.util.UniqueEList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.gmf.internal.bridge.wizards.strategy.AccessibleClassNodeStrategy;
import org.eclipse.gmf.internal.bridge.wizards.strategy.CompositeStrategy;
import org.eclipse.gmf.internal.bridge.wizards.strategy.Hierarchy;
import org.eclipse.gmf.internal.bridge.wizards.strategy.LeafNodeStrategy;
import org.eclipse.gmf.internal.bridge.wizards.strategy.Strategy;
import org.eclipse.gmf.mappings.FeatureLabelMapping;
import org.eclipse.gmf.mappings.GMFMapFactory;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.Mapping;
import org.eclipse.gmf.mappings.MappingEntry;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.NodeReference;
import org.eclipse.gmf.mappings.TopNodeReference;

/**
 * @@author artem
 */
public class MapDefFeeder {

	private final GraphDefLookup myGraphDefLookup;
	private final ToolDefSupplier myToolDefLookup;

	private Hierarchy myHierarchy;
	private final WizardInput myInputHolder;
	private List<EClass> myNodeCandidates;
	private List<EObject> myLinkCandidates;

	public MapDefFeeder(WizardInput holder, ToolDefSupplier toolDefSupplier) {
		assert holder != null;
		myInputHolder = holder;
		myGraphDefLookup = new GraphDefLookup(holder.getCanvasDef());
		myToolDefLookup = toolDefSupplier;
	}

	protected final Mapping getMapping() {
		return myInputHolder.getMapping();
	}

	@@SuppressWarnings("unchecked")
	public void feedDefaultMapping() {
		final Hierarchy hierarchy = getHierarchy();
		myNodeCandidates = new UniqueEList<EClass>(hierarchy.getAllClasses());
		createNodeFilter().filter(myNodeCandidates, hierarchy);

		myLinkCandidates = new LinkedList<EObject>();
		createLinkFilter().filter(myLinkCandidates, hierarchy);

		myLinkCandidates.addAll(hierarchy.getAccessibleReferences(myNodeCandidates.iterator()));

		getMapping().getNodes().clear();
		getMapping().getNodes().addAll(nodesFrom(myNodeCandidates));
		getMapping().getLinks().clear();
		getMapping().getLinks().addAll(linksFrom(myLinkCandidates));
		getMapping().getDiagram().setPalette(myInputHolder.getToolDef().getPalette());
	}

	private Hierarchy getHierarchy() {
		if (myHierarchy == null) {
			myHierarchy = new Hierarchy(getMapping().getDiagram().getDomainMetaElement());
			myHierarchy.collect();
		}
		return myHierarchy;
	}

	private Strategy<EClass> createNodeFilter() {
		// TODO add UI and instantiate strategies from descriptors
		return new CompositeStrategy<EClass>(new AccessibleClassNodeStrategy(), new LeafNodeStrategy());
	}

	private Strategy<EObject> createLinkFilter() {
		//MergingStrategy?
		// default: Accessible, Leaf
		return new Strategy<EObject>() {
			public String getID() {
				throw new UnsupportedOperationException("QuickHack");
			}
			public void filter(Collection<EObject> soFar, Hierarchy hierarchy) {
				Set<EClass> linkCandidates = new HashSet<EClass>(hierarchy.getAccessibleLinkClasses());
				for (Iterator<EClass> iter = linkCandidates.iterator(); iter.hasNext();) {
					EClass element = iter.next();
					if (!hierarchy.isLeaf(element)) {
						iter.remove();
					}
				}
				soFar.clear();
				soFar.addAll(linkCandidates);
			}
		};
	}

	private List<TopNodeReference> nodesFrom(List<EClass> candidates) {
		ArrayList<TopNodeReference> rv = new ArrayList<TopNodeReference>(candidates.size());
		for (EClass eClass : candidates) {
			NodeMapping nm = GMFMapFactory.eINSTANCE.createNodeMapping();
			nm.setDomainMetaElement(eClass); 
			nm.setDiagramNode(myGraphDefLookup.findSuitableNode(nm));
			addEditFeature(nm, eClass);
			nm.setTool(myToolDefLookup.findTool(nm));
			TopNodeReference tnr = GMFMapFactory.eINSTANCE.createTopNodeReference();
			tnr.setContainmentFeature(getHierarchy().nodeBackRef(eClass)); // FIXME [containment] !!!
			tnr.setOwnedChild(nm);
			rv.add(tnr);
		}
		return rv;
	}

	private List<LinkMapping> linksFrom(List<EObject> candidates) {
		ArrayList<LinkMapping> rv = new ArrayList<LinkMapping>(candidates.size());
		for (EObject next : candidates) {
			LinkMapping lm = GMFMapFactory.eINSTANCE.createLinkMapping();
			if (next instanceof EClass) {
				EClass eClass = (EClass) next;
				lm.setDomainMetaElement(eClass);
				lm.setContainmentFeature(getHierarchy().linkBackRef(eClass));
				addEditFeature(lm, eClass);
				lm.setLinkMetaFeature(getHierarchy().getLinkFeature(eClass));
			} else {
				lm.setLinkMetaFeature((EReference) next);
			}
			lm.setDiagramLink(myGraphDefLookup.findSuitableLink(lm));
			lm.setTool(myToolDefLookup.findTool(lm));
			rv.add(lm);
		}
		return rv;
	}

	@@SuppressWarnings("unchecked")
	private void addEditFeature(MappingEntry me, EClass class1) {
		for (Iterator it = class1.getEAllAttributes().iterator(); it.hasNext();) {
			EAttribute n = (EAttribute) it.next();
			// EDataType at = n.getEAttributeType();
			// at != null && at.getEPackage() != null && at.getEPackage().getNsURI().equals(EcorePackage.eNS_URI) && at.getName().equals(EcorePackage.eINSTANCE.getEString().getName())
			if (EcorePackage.eINSTANCE.getEString().equals(n.getEType())) {
				FeatureLabelMapping lm = GMFMapFactory.eINSTANCE.createFeatureLabelMapping();
				lm.getFeatures().add(n);
				me.getLabelMappings().add(lm);
				return;
			}
		}
	}

	public NodeReference[] getInitialNodes() {
		return nodesFrom(myNodeCandidates).toArray(new NodeReference[0]);
	}

	public LinkMapping[] getInitialLinks() {
		return linksFrom(myLinkCandidates).toArray(new LinkMapping[0]);
	}
}
@


1.13
log
@fix copyright years
@
text
@d18 1
d69 1
a69 1
		myNodeCandidates = new UniqueEList(hierarchy.getAllClasses());
d72 1
a72 1
		myLinkCandidates = new ArrayList();
d92 1
a92 1
	private Strategy createNodeFilter() {
d94 1
a94 1
		return new CompositeStrategy(new AccessibleClassNodeStrategy(), new LeafNodeStrategy());
d97 1
a97 1
	private Strategy createLinkFilter() {
d100 1
a100 1
		return new Strategy() {
@


1.13.2.1
log
@propagate changes from head to make compilable
@
text
@a17 1
import java.util.LinkedList;
d68 1
a68 1
		myNodeCandidates = new UniqueEList<EClass>(hierarchy.getAllClasses());
d71 1
a71 1
		myLinkCandidates = new LinkedList<EObject>();
d91 1
a91 1
	private Strategy<EClass> createNodeFilter() {
d93 1
a93 1
		return new CompositeStrategy<EClass>(new AccessibleClassNodeStrategy(), new LeafNodeStrategy());
d96 1
a96 1
	private Strategy<EObject> createLinkFilter() {
d99 1
a99 1
		return new Strategy<EObject>() {
@


1.12
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.11
log
@[161380] Inroduce label mapping subclasses
@
text
@d117 3
a119 4
	private List<NodeReference> nodesFrom(List<EClass> candidates) {
		ArrayList<NodeReference> rv = new ArrayList<NodeReference>(candidates.size());
		for (Iterator iter = candidates.iterator(); iter.hasNext();) {
			EClass eClass = (EClass) iter.next();
d135 1
a135 2
		for (Iterator iter = candidates.iterator(); iter.hasNext();) {
			Object next = iter.next();
@


1.10
log
@use generics wherever possible
@
text
@d32 1
a33 1
import org.eclipse.gmf.mappings.LabelMapping;
d162 1
a162 1
				LabelMapping lm = GMFMapFactory.eINSTANCE.createLabelMapping();
@


1.9
log
@detect containment features for links (represented with EClasses)
@
text
@d16 1
d19 1
a20 1
import org.eclipse.emf.common.util.BasicEList;
d24 1
d51 2
a52 2
	private List/*EClass*/ myNodeCandidates;
	private List/*EObject*/ myLinkCandidates;
d65 1
d93 1
a93 4
		return new CompositeStrategy(new Strategy[] {
				new AccessibleClassNodeStrategy(),
				new LeafNodeStrategy(),
		});
d103 4
a106 4
			public void filter(Collection soFar, Hierarchy hierarchy) {
				List linkCandidates = new UniqueEList(hierarchy.getAccessibleLinkClasses());
				for (Iterator iter = linkCandidates.iterator(); iter.hasNext();) {
					EClass element = (EClass) iter.next();
d117 2
a118 2
	private List/*<NodeReference>*/ nodesFrom(List candidates) {
		BasicEList rv = new BasicEList(candidates.size());
d134 2
a135 2
	private List/*<LinkMapping>*/ linksFrom(List candidates) {
		BasicEList rv = new BasicEList(candidates.size());
d155 1
d171 1
a171 1
		return (NodeReference[]) nodesFrom(myNodeCandidates).toArray(new NodeReference[0]);
d175 1
a175 1
		return (LinkMapping[]) linksFrom(myLinkCandidates).toArray(new LinkMapping[0]);
@


1.8
log
@revert to gmfmap model compatibility
@
text
@d127 1
a127 1
			tnr.setContainmentFeature(getHierarchy().backRef(eClass)); // FIXME [containment] !!!
d142 1
a142 1
				lm.setContainmentFeature(getHierarchy().backRef(eClass));
@


1.7
log
@#133836 Creating a child node without a label causes error
@
text
@d35 1
a36 1
import org.eclipse.gmf.mappings.ShapeNodeMapping;
d121 1
a121 1
			ShapeNodeMapping nm = GMFMapFactory.eINSTANCE.createShapeNodeMapping();
@


1.6
log
@ArrayStoreException on Restore
@
text
@a34 1
import org.eclipse.gmf.mappings.NodeMapping;
d36 1
d121 1
a121 1
			NodeMapping nm = GMFMapFactory.eINSTANCE.createNodeMapping();
@


1.5
log
@organized imports
@
text
@d170 1
a170 1
		return (NodeReference[]) nodesFrom(myNodeCandidates).toArray(new NodeMapping[0]);
@


1.4
log
@- speciy palette for canvas
- add created labelMappings
@
text
@a22 1
import org.eclipse.emf.ecore.EDataType;
@


1.3
log
@option to create tooling definition as part of mapping process
@
text
@d23 1
d78 1
d159 2
d164 1
@


1.2
log
@simple logic to handle tool definitions added. If two non-empty tool groups found in palette registry, then latest one is designated to serve as source of tools for links, and another group prior to it - as a source of node tools. If palette contains no toolgroups, then plain list of creation tools is expected as children of Palette. N NodeMappings will use first N tool definitions, LinkMappings will use rest.
Of course, 1..N mod toolGroup.length
@
text
@d45 1
a45 1
	private final ToolDefLookup myToolDefLookup;
d52 1
a52 1
	public MapDefFeeder(WizardInput holder) {
d56 1
a56 1
		myToolDefLookup = new ToolDefLookup(holder.getToolDef());
@


1.1
log
@Introduced separate plugin for Tooling UI, moved mapping wizard of #114186 to this plugin.
Wizard got some NLS, respect selection, open-created-model-in-editor improvements as well as aligned with recent gmfmap changes.
Plus, some refactorings to address user-prioritized strategies to select nodes/links doubled number of classes we had.
@
text
@d45 1
a45 1
	private final ToolDefLookup myToolDefLookup = new ToolDefLookup();
d55 2
a56 1
		myGraphDefLookup = new GraphDefLookup(holder.getMapping().getDiagram().getDiagramCanvas());
@

