head	1.6;
access;
symbols
	v20080924-1925:1.6
	v20080722-1827:1.6
	v20080716-1642:1.6
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080417-1610:1.5
	v20080322-0000:1.5
	v20080222-1200:1.5
	v20080215-1500:1.5
	v20080207-0207:1.5
	v20071124-0000:1.5
	v20071108-0000:1.5
	v20070903-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.4
	v20070608-1300:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070520-1200:1.4
	v20070518-1300:1.4
	v20070420-1000:1.4
	v20070413-1300:1.4
	v20070405-2000:1.4
	v20070330-1300:1.4
	v20070322-1100:1.4
	v20060316-0600:1.4
	v20070301-1200:1.3
	v20070228-2000:1.2
	v20070208-1800:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.6
date	2008.07.10.12.29.44;	author ashatalin;	state Exp;
branches;
next	1.5;
commitid	7c3e487600b74567;

1.5
date	2007.06.21.14.03.14;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	1176467a85204567;

1.4
date	2007.03.14.12.59.33;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	114b45f7f1b34567;

1.3
date	2007.03.01.16.35.17;	author atikhomirov;	state Exp;
branches;
next	1.2;
commitid	662c45e700c54567;

1.2
date	2007.02.07.12.11.12;	author atikhomirov;	state Exp;
branches;
next	1.1;
commitid	ff145c9c1e04567;

1.1
date	2007.01.18.18.49.15;	author atikhomirov;	state Exp;
branches;
next	;
commitid	197b45afc1284567;


desc
@@


1.6
log
@[217307] - "Add extension model" action: impossible use for additing nondeployed models
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 *    Alexander Fedorov (Borland) - #148836 - transform action as wizard
 */
package org.eclipse.gmf.internal.bridge.transform;

import java.io.IOException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.codegen.ecore.genmodel.GenModel;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.resource.ContentHandler;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.gmf.internal.bridge.genmodel.BasicGenModelAccess;
import org.eclipse.gmf.internal.bridge.genmodel.DummyGenModel;
import org.eclipse.gmf.internal.bridge.genmodel.FileGenModelAccess;
import org.eclipse.gmf.internal.bridge.genmodel.GenModelAccess;
import org.eclipse.gmf.internal.bridge.ui.Plugin;
import org.eclipse.gmf.mappings.Mapping;

/**
 * Interact with user to retrieve genmodel for the domain model. XXX detect
 * stale genmodels and reconcile them based on user's decision
 * 
 * @@author artem
 */
public class GenModelDetector {
	private final Mapping myMapping;
	private GenModelAccess myGMAccess;
	private Collection<EPackage> myPackages;

	public GenModelDetector(Mapping mapping) {
		if (mapping == null) {
			throw new IllegalArgumentException("Could not detect with null Mapping");
		}
		myMapping = mapping;
	}
	
	public IStatus detect() {
		myPackages = findEPackages(myMapping);
		if (myPackages.isEmpty()) {
			myGMAccess = new GenModelAccess.Adapter(null);
			return Status.OK_STATUS;
		} else if (myPackages.size() == 1) {
			final EPackage solePack = myPackages.iterator().next();
			BasicGenModelAccess gma = new BasicGenModelAccess(solePack);
			gma.initDefault();
			return apply(gma);
		} else {
			return Plugin.createError(Messages.GenModelDetector_e_not_found, null);
		}
	}

	public IStatus advise(URI genModelURI) {
		if (genModelURI == null) {
			throw new IllegalArgumentException("Null GenModel URI");
		}
		GenModelAccess gma = new FileGenModelAccess(genModelURI);
		return apply(gma);
	}

	public IStatus advise(IFile workspaceFile) {
		if (workspaceFile == null) {
			throw new IllegalArgumentException("Null GenModel file");
		}
		GenModelAccess gma = new FileGenModelAccess(workspaceFile);
		return apply(gma);
	}
	
	private Collection<EPackage> findEPackages(Mapping mapping) {
		Collection<EPackage> packages = new HashSet<EPackage>();
		for (EObject next : EcoreUtil.ExternalCrossReferencer.find(mapping).keySet()) {
			if (next instanceof EClass) {
				packages.add(((EClass) next).getEPackage());
			}
		}
		for (Iterator<EPackage> it = packages.iterator(); it.hasNext();) {
			EPackage next = it.next();
			if (next.getESuperPackage() != null && EcoreUtil.isAncestor(packages, next.getESuperPackage())) {
				it.remove();
			}
		}
		return packages;
	}

	private IStatus apply(GenModelAccess gma) {
		IStatus load = gma.load(new ResourceSetImpl());
		if (load.isOK()) {
			gma.unload();
			myGMAccess = gma;
			return Status.OK_STATUS;
		} else {
			return load;
		}
	}
	
	private EPackage getPrimaryPackage() {
		if (myPackages == null || myPackages.size() == 0) {
			return null;
		}
		return myPackages.iterator().next();
	}
	
	public boolean canCreateDefault() {
		return myPackages != null && myPackages.size() == 1;
	}
	
	public URI createDefault(String pluginID, IFile patternResource) throws CoreException {
		DummyGenModel gma = new DummyGenModel(getPrimaryPackage(), null);
		gma.setPluginID(pluginID);
		GenModel model = gma.create();
		IPath path = patternResource.getFullPath().removeFileExtension().addFileExtension("genmodel"); //$NON-NLS-1$
		URI uri = URI.createPlatformResourceURI(path.toString(), true);
		Resource res = new ResourceSetImpl().createResource(uri, ContentHandler.UNSPECIFIED_CONTENT_TYPE);
		res.getContents().add(model);
		try {
			res.save(null);
			return uri;
		} catch (IOException ex) {
			IStatus error = Plugin.createError(Messages.GenModelDetector_e_save, ex);
			throw new CoreException(error);
		}
	}

	public GenModel get(ResourceSet resSet) {
		if (myGMAccess == null) {
			throw new IllegalStateException(Messages.GenModelDetector_e_no_genmodelaccess);
		}
		IStatus s = myGMAccess.load(resSet);
		if (!s.isOK()) {
			throw new IllegalStateException(s.getMessage());
		}
		return myGMAccess.model();
	}
	
}
@


1.5
log
@fix copyright years
@
text
@d30 1
d135 1
a135 1
		Resource res = new ResourceSetImpl().createResource(uri);
@


1.4
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d2 1
a2 1
 * Copyright (c) 2006 Borland Software Corporation
@


1.3
log
@organized imports
@
text
@d28 1
d92 1
a92 2
		for (Iterator it = EcoreUtil.ExternalCrossReferencer.find(mapping).keySet().iterator(); it.hasNext();) {
			Object next = it.next();
d97 2
a98 2
		for (Iterator it = packages.iterator(); it.hasNext();) {
			EPackage next = (EPackage) it.next();
@


1.2
log
@[171593] afedorov - Tests for TransformToGenModelOperation
@
text
@a20 1
import org.eclipse.core.resources.ResourcesPlugin;
@


1.1
log
@[148836] afedorov - Provide "Create generator model..." wizard instead of existing dialog sequence
@
text
@d53 3
a55 1
		assert mapping != null;
d75 3
a77 1
		assert genModelURI != null;
d83 3
a85 1
		assert workspaceFile != null;
d129 1
a129 1
	public IFile createDefault(String pluginID, IFile patternResource) throws CoreException {
d134 2
a135 1
		Resource res = new ResourceSetImpl().createResource(URI.createPlatformResourceURI(path.toString(), true));
d139 1
a139 2
			IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(path);
			return file;
a156 4
	public boolean checkState() {
		return myGMAccess != null;
	}

@

