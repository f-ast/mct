head	1.11;
access;
symbols
	v20080924-1925:1.11
	v20080722-1827:1.11
	v20080716-1642:1.11
	R2_1_maintenance:1.10.0.4
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080417-1610:1.10
	v20080322-0000:1.10
	v20080222-1200:1.10
	v20080215-1500:1.10
	v20080207-0207:1.10
	v20071124-0000:1.10
	v20071108-0000:1.10
	v20070903-0000:1.10
	v20070809-0000:1.10
	R2_0_maintenance:1.10.0.2
	R2_0:1.10
	R4_20:1.10
	v20070621-0000:1.10
	RC3_20:1.10
	v20070608-1300:1.10
	v20070605-1400:1.10
	v20070601-1400:1.10
	v20070520-1200:1.10
	v20070518-1300:1.10
	v20070420-1000:1.10
	v20070413-1300:1.10
	v20070405-2000:1.10
	v20070330-1300:1.10
	v20070322-1100:1.10
	v20060316-0600:1.10
	v20070301-1200:1.10
	v20070228-2000:1.10
	v20070208-1800:1.10
	M4_20:1.10
	v20061214-0000:1.10
	M3_20:1.9
	v20061117-0800:1.9
	v20061013-1330:1.9
	v20060925-1700:1.6
	v20060919-0800:1.6
	M1_20:1.8
	v20060904-1500:1.8
	v20060713-1700:1.6
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060626-1420:1.6
	v20060620-0400:1.6
	v20060616-1200:1.6
	v20060609-1400:1.6
	v20060531-1730:1.6
	v20060526-1200:1.6
	v20060519-0800:1.6
	v20060512-1000:1.4
	I20060512-1000:1.4
	I20060428-1300:1.4
	I20060424-0500:1.4
	I20060424-0300:1.4
	M6_10:1.4
	I20060407-1200:1.4
	I20060331-1000:1.4
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.4
	M5_10:1.4
	S20060303-1600:1.4;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2008.07.10.12.29.44;	author ashatalin;	state Exp;
branches;
next	1.10;
commitid	7c3e487600b74567;

1.10
date	2006.11.22.17.34.12;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	112b45648a134567;

1.9
date	2006.09.22.18.32.21;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.04.14.47.44;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.01.19.43.09;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.16.14.59.29;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.16.13.45.40;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.03.16.50.24;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.03.15.14.02;	author rgronback;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.03.14.16.22;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.28.19.07.41;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.11
log
@[217307] - "Add extension model" action: impossible use for additing nondeployed models
@
text
@/*
 * Copyright (c) 2006 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.wizards.pages;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.resources.IFile;
import org.eclipse.emf.common.command.BasicCommandStack;
import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.resource.ContentHandler;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.emf.edit.provider.ComposedAdapterFactory;
import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;
import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;
import org.eclipse.gmf.gmfgraph.Canvas;
import org.eclipse.gmf.gmfgraph.provider.GMFGraphItemProviderAdapterFactory;
import org.eclipse.gmf.mappings.CanvasMapping;
import org.eclipse.gmf.mappings.GMFMapFactory;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.Mapping;
import org.eclipse.gmf.mappings.NodeReference;
import org.eclipse.gmf.mappings.provider.GMFMapItemProviderAdapterFactory;
import org.eclipse.gmf.tooldef.ToolRegistry;
import org.eclipse.gmf.tooldef.provider.GMFToolItemProviderAdapterFactory;

/**
 * @@author artem
 */
public abstract class WizardInput {

	public static final String TOOLDEF_FILE_EXT = "gmftool"; //$NON-NLS-1$
	public static final String GRAPHDEF_FILE_EXT = "gmfgraph"; //$NON-NLS-1$
	public static final String ECORE_FILE_EXT = "ecore"; //$NON-NLS-1$

	private Mapping mapInstance;
	private EditingDomain myEditingDomain;
	private AdapterFactory myAdapterFactory;
	private IFile myResultFile;
	private MapDefFeeder myFeeder;

	public AdapterFactory getAdapterFactory() {
		if (myAdapterFactory == null) {
			List<AdapterFactory> factories = new ArrayList<AdapterFactory>();
			factories.add(new ResourceItemProviderAdapterFactory());
			factories.add(new GMFMapItemProviderAdapterFactory());
			factories.add(new GMFGraphItemProviderAdapterFactory());
			factories.add(new GMFToolItemProviderAdapterFactory());
			factories.add(new ReflectiveItemProviderAdapterFactory());
			myAdapterFactory = new ComposedAdapterFactory(factories);
		}
		return myAdapterFactory;
	}
	
	public EditingDomain getEditingDomain() {
		if (myEditingDomain == null) {
			myEditingDomain = new AdapterFactoryEditingDomain(getAdapterFactory(), new BasicCommandStack());
		}
		return myEditingDomain;
	}

	public ResourceSet getResourceSet() {
		return getEditingDomain().getResourceSet();
	}

	public abstract EPackage getDomainModel();

	public abstract Canvas getCanvasDef();

	public abstract ToolRegistry getToolDef();

	public abstract boolean isNewBlankToolDef();

	public void setMappingFile(IFile resultFile) {
//		if (myResultFile != null && resultFile != myResultFile) {
//			// perhaps, no reason to allow even 'touch'?
//			throw new IllegalStateException("Did't expect file to be chosen more than once");
//		}
		myResultFile = resultFile;
	}

	public IFile getMappingFile() {
		return myResultFile;
	}

	@@SuppressWarnings("unchecked")
	public Mapping getMapping() {
		if (mapInstance == null) {
			mapInstance = GMFMapFactory.eINSTANCE.createMapping();
			URI res = URI.createPlatformResourceURI(getMappingFile().getFullPath().toString(), true);
			getResourceSet().createResource(res, ContentHandler.UNSPECIFIED_CONTENT_TYPE).getContents().add(mapInstance);
			CanvasMapping cm = GMFMapFactory.eINSTANCE.createCanvasMapping();
			mapInstance.setDiagram(cm);
		}
		return mapInstance;
	}

	public void selectCanvasElement(EClass eClass) {
		assert eClass.getEPackage() == getDomainModel();
		CanvasMapping cm = getMapping().getDiagram();
		cm.setDiagramCanvas(getCanvasDef());
		cm.setDomainMetaElement(eClass);
		cm.setDomainModel(eClass.getEPackage());
	}

	public void feedDefaultMapping() {
		myFeeder = new MapDefFeeder(this, createToolDefSupplier());
		myFeeder.feedDefaultMapping();
	}

	private ToolDefSupplier createToolDefSupplier() {
		if (isNewBlankToolDef()) {
			return new CreateToolDef(getToolDef());
		} else {
			return new ToolDefLookup(getToolDef());
		}
	}

	public NodeReference[] nodeCandidates() {
		return myFeeder.getInitialNodes();
	}

	public LinkMapping[] linkCandidates() {
		return myFeeder.getInitialLinks();
	}
}
@


1.10
log
@Removing warnings
@
text
@d23 1
d105 1
a105 1
			getResourceSet().createResource(res).getContents().add(mapInstance);
@


1.9
log
@#142460 Inconsistent buttons in GMFMap creation wizard
@
text
@d103 1
a103 1
			URI res = URI.createPlatformResourceURI(getMappingFile().getFullPath().toString());
@


1.8
log
@use generics wherever possible
@
text
@a14 1
import java.util.Iterator;
a17 4
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
a20 1
import org.eclipse.emf.common.util.UniqueEList;
a21 1
import org.eclipse.emf.ecore.EObject;
a30 1
import org.eclipse.gmf.internal.bridge.ui.Plugin;
a36 1
import org.eclipse.gmf.tooldef.GMFToolFactory;
a38 1
import org.eclipse.jface.dialogs.IMessageProvider;
d43 2
a44 1
public class WizardInput {
a48 3
	private EPackage myDomainModel;
	private Canvas myCanvas;
	private ToolRegistry myRegistry;
d52 1
a52 1
	private IFile myResultFile = null;
a53 4
	private String initialECoreFile = null;
	private String initialGraphFile = null;
	private String initialToolFile = null;
	private boolean myIsBlankToolDef = false;
a54 3
	public WizardInput() {
	}
	
a62 1

d79 1
a79 9
	public void setDomainModel(EPackage aPackage) {
		checkUnload(myDomainModel);
		myDomainModel = aPackage;
	}

	public void setGraphDef(Canvas canvas) {
		checkUnload(myCanvas);
		myCanvas = canvas;
	}
d81 1
a81 7
	public Canvas getCanvasDef() {
		return myCanvas;
	}

	public boolean isNewBlankToolDef() {
		return myIsBlankToolDef;
	}
d83 1
a83 25
	@@SuppressWarnings("unchecked")
	public URI createBlankToolDef() {
		checkUnload(myRegistry);
		myRegistry = null;
		IPath toolDefFile = getMappingFile().getFullPath().removeFileExtension().addFileExtension(TOOLDEF_FILE_EXT);
		String baseName = getMappingFile().getFullPath().removeFileExtension().lastSegment();
		int i = 1;
		final IWorkspace wr = getMappingFile().getProject().getWorkspace(); 
		while (wr.getRoot().findMember(toolDefFile) != null) {
			toolDefFile = toolDefFile.removeLastSegments(1).append(baseName + i).addFileExtension(TOOLDEF_FILE_EXT);
			i++;
		}
		URI toolDefURI = URI.createPlatformResourceURI(toolDefFile.toString());
		myRegistry = GMFToolFactory.eINSTANCE.createToolRegistry();
		myRegistry.setPalette(GMFToolFactory.eINSTANCE.createPalette());
		getResourceSet().createResource(toolDefURI).getContents().add(myRegistry);
		myIsBlankToolDef  = true;
		return toolDefURI;
	}

	public void setToolDef(ToolRegistry registry) {
		checkUnload(myRegistry);
		myRegistry = registry;
		myIsBlankToolDef = false;
	}
d85 1
a85 3
	public ToolRegistry getToolDef() {
		return myRegistry;
	}
d105 2
a110 39
	/**
	 * @@return status with code field set to constant from IMessageProvider
	 */
	public IStatus isReady2Go() {
		if (myDomainModel != null && myCanvas != null && myRegistry != null) {
			return Status.OK_STATUS;
		}
		if (myDomainModel == null) {
			return new Status(Status.WARNING, Plugin.getPluginID(), IMessageProvider.WARNING, Messages.inputNeedDomain, null);
		}
		if (myCanvas == null) {
			return new Status(Status.WARNING, Plugin.getPluginID(), IMessageProvider.WARNING, Messages.inputNeedCanvas, null);
		} else {
			return new Status(Status.WARNING, Plugin.getPluginID(), IMessageProvider.WARNING, Messages.inputNeedToolDef, null);
		}
	}

	private void checkUnload(EObject eobj) {
		if (eobj == null) {
			return;
		}
		if (eobj.eResource().getResourceSet() == getResourceSet() && eobj.eResource().isLoaded()) {
			eobj.eResource().unload();
		}
	}
	public List/*<EClass>*/ getCanvasElementCandidates() {
		UniqueEList rv = new UniqueEList();
		for (Iterator it = myDomainModel.getEClassifiers().iterator(); it.hasNext();) {
			Object next = it.next();
			if (next instanceof EClass) {
				EClass eClass = (EClass) next;
				if (!eClass.isAbstract() && !eClass.isInterface() && !eClass.getEAllContainments().isEmpty()) {
					rv.add(eClass);
				}
			}
		}
		return rv;
	}

d112 3
a114 9
		assert eClass.getEPackage() == myDomainModel;
		CanvasMapping cm;
		if (getMapping().getDiagram() == null) {
			cm =  GMFMapFactory.eINSTANCE.createCanvasMapping();
			cm.setDiagramCanvas(myCanvas);
			// +palette/gmfgraph.canvas
		} else {
			cm = getMapping().getDiagram();
		}
a116 1
		getMapping().setDiagram(cm);
a138 24
	
	public String getInitialECoreFile() {
		return initialECoreFile;
	}

	public void setInitialECoreFile(String initialECoreFile) {
		this.initialECoreFile = initialECoreFile;
	}

	public String getInitialGraphFile() {
		return initialGraphFile;
	}

	public void setInitialGraphFile(String initialGraphFile) {
		this.initialGraphFile = initialGraphFile;
	}

	public String getInitialToolFile() {
		return initialToolFile;
	}

	public void setInitialToolFile(String initialToolFile) {
		this.initialToolFile = initialToolFile;
	}
@


1.7
log
@use generics wherever possible
@
text
@d117 1
d159 1
@


1.6
log
@respect selection and set filenames according to existing files
@
text
@d76 1
a76 1
			List factories = new ArrayList();
@


1.5
log
@#136925 show reasons why Next is greyed out
@
text
@d54 4
d120 1
a120 1
		IPath toolDefFile = getMappingFile().getFullPath().removeFileExtension().addFileExtension("gmftool");
d125 1
a125 1
			toolDefFile = toolDefFile.removeLastSegments(1).append(baseName + i).addFileExtension("gmftool");
@


1.4
log
@option to create tooling definition as part of mapping process
@
text
@d21 2
d38 1
d48 1
d163 15
a177 2
	public boolean isReady2Go() {
		return myDomainModel != null && myCanvas != null && myRegistry != null;
@


1.3
log
@Changes to accomodate forthcoming tutorial cheatsheet.
@
text
@d19 2
d42 1
d61 1
d105 23
d131 1
d201 1
a201 1
		myFeeder = new MapDefFeeder(this);
d205 8
@


1.2
log
@simple logic to handle tool definitions added. If two non-empty tool groups found in palette registry, then latest one is designated to serve as source of tools for links, and another group prior to it - as a source of node tools. If palette contains no toolgroups, then plain list of creation tools is expected as children of Palette. N NodeMappings will use first N tool definitions, LinkMappings will use rest.
Of course, 1..N mod toolGroup.length
@
text
@d55 3
d184 24
@


1.1
log
@Introduced separate plugin for Tooling UI, moved mapping wizard of #114186 to this plugin.
Wizard got some NLS, respect selection, open-created-model-in-editor improvements as well as aligned with recent gmfmap changes.
Plus, some refactorings to address user-prioritized strategies to select nodes/links doubled number of classes we had.
@
text
@d94 4
d103 4
d129 1
a129 1
		return myDomainModel != null && myCanvas != null /*&& myRegistry != null*/;
@

