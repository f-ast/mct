head	1.10;
access;
symbols
	v20080924-1925:1.10
	v20080722-1827:1.10
	v20080716-1642:1.10
	R2_1_maintenance:1.10.0.4
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080417-1610:1.10
	v20080322-0000:1.10
	v20080222-1200:1.10
	v20080215-1500:1.10
	v20080207-0207:1.10
	v20071124-0000:1.10
	v20071108-0000:1.10
	v20070903-0000:1.10
	v20070809-0000:1.10
	R2_0_maintenance:1.10.0.2
	R2_0:1.10
	R4_20:1.10
	v20070621-0000:1.10
	RC3_20:1.10
	v20070608-1300:1.10
	v20070605-1400:1.10
	v20070601-1400:1.10
	v20070520-1200:1.10
	v20070518-1300:1.10
	v20070420-1000:1.10
	v20070413-1300:1.10
	v20070405-2000:1.10
	v20070330-1300:1.10
	v20070322-1100:1.10
	v20060316-0600:1.10
	v20070301-1200:1.10
	v20070228-2000:1.10
	v20070208-1800:1.9
	M4_20:1.9
	v20061214-0000:1.9
	M3_20:1.8
	v20061117-0800:1.8
	v20061013-1330:1.8
	v20060925-1700:1.2
	v20060919-0800:1.2
	M1_20:1.2
	v20060904-1500:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060626-1420:1.2
	v20060620-0400:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060526-1200:1.2
	v20060519-0800:1.2
	v20060512-1000:1.1
	I20060512-1000:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.10
date	2007.02.22.20.03.12;	author dstadnik;	state Exp;
branches;
next	1.9;
commitid	33a445ddf6fe4567;

1.9
date	2006.11.24.10.43.53;	author dstadnik;	state Exp;
branches;
next	1.8;
commitid	3c324566cce94567;

1.8
date	2006.09.19.12.46.57;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.19.12.19.41;	author dstadnik;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.18.18.13.15;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.15.19.24.23;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.15.12.18.10;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.12.16.50.15;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.16.14.59.29;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.28.19.07.41;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.10
log
@[170444] Use concrete class names for features
@
text
@/*
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Dmitry Stadnik - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.wizards;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.gmf.internal.bridge.ui.Plugin;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.wizard.IWizardContainer;
import org.eclipse.osgi.util.NLS;
import org.eclipse.ui.IWorkbench;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.actions.WorkspaceModifyOperation;
import org.eclipse.ui.part.FileEditorInput;
import org.eclipse.ui.part.ISetSelectionTarget;

/**
 * @@author dstadnik
 */
public class WizardUtil {

	private WizardUtil() {
	}

	public static String getDefaultFileName(IStructuredSelection selection, String defaultName, String extension) {
		if (selection != null && !selection.isEmpty()) {
			Object selected = selection.getFirstElement();
			if (selected instanceof IFile) {
				return getDefaultFileName((IFile) selected, extension);
			}
		}
		return defaultName + '.' + extension;
	}

	public static String getDefaultFileName(IFile file, String extension) {
		String fileNameBase = getFileBaseName(file);
		String modelFilename = fileNameBase + '.' + extension;
		for (int i = 1; file.getParent().findMember(modelFilename) != null; ++i) {
			modelFilename = fileNameBase + i + '.' + extension;
		}
		return modelFilename;
	}

	public static String getCapped(String s) {
		if (s == null) {
			return ""; //$NON-NLS-1$
		}
		s = s.trim();
		return s.length() > 1 ? Character.toUpperCase(s.charAt(0)) + s.substring(1) : s.toUpperCase();
	}

	public static String getCapName(EObject element) {
		if (element instanceof EClass) {
			return WizardUtil.getCapName((EClass) element);
		} else if (element instanceof EStructuralFeature) {
			return WizardUtil.getCapName((EStructuralFeature) element);
		} else {
			return null;
		}
	}

	public static String getCapName(EClass type) {
		return getCapped(type.getName());
	}

	public static String getCapName(EStructuralFeature feature) {
		EClass type = feature.getEContainingClass();
		return getCapped(type.getName()) + getCapped(feature.getName());
	}

	public static String getCapName(EStructuralFeature feature, EClass containingClass) {
		return getCapped(containingClass.getName()) + getCapped(feature.getName());
	}

	@@SuppressWarnings("unchecked")
	public static void saveModel(IWizardContainer container, final Resource resource) throws Exception {
		WorkspaceModifyOperation operation = new WorkspaceModifyOperation() {

			protected void execute(IProgressMonitor progressMonitor) {
				try {
					Map options = new HashMap();
					options.put(XMLResource.OPTION_ENCODING, "UTF-8"); //$NON-NLS-1$
					resource.save(options);
				} catch (Exception exception) {
					Plugin.log(exception);
				} finally {
					progressMonitor.done();
				}
			}
		};
		container.run(false, false, operation);
	}

	public static boolean openEditor(IFile modelFile) {
		IWorkbench workbench = PlatformUI.getWorkbench();

		// Select the new file resource in the current view.
		//
		IWorkbenchWindow workbenchWindow = workbench.getActiveWorkbenchWindow();
		IWorkbenchPage page = workbenchWindow.getActivePage();
		final IWorkbenchPart activePart = page.getActivePart();
		if (activePart instanceof ISetSelectionTarget) {
			final ISelection targetSelection = new StructuredSelection(modelFile);
			workbenchWindow.getShell().getDisplay().asyncExec(new Runnable() {

				public void run() {
					((ISetSelectionTarget) activePart).selectReveal(targetSelection);
				}
			});
		}

		// Open an editor on the new file.
		//
		try {
			page.openEditor(new FileEditorInput(modelFile), workbench.getEditorRegistry().getDefaultEditor(modelFile.getFullPath().toString()).getId());
		} catch (PartInitException exception) {
			MessageDialog.openError(workbenchWindow.getShell(), NLS.bind(Messages.WizardUtilUnableToOpenEditor, modelFile), exception.getMessage());
			return false;
		}

		return true;
	}

	public static void selectReveal(IWorkbench workbench, final ISelection selection) {
		IWorkbenchWindow workbenchWindow = workbench.getActiveWorkbenchWindow();
		IWorkbenchPage page = workbenchWindow.getActivePage();
		final IWorkbenchPart activePart = page.getActivePart();
		if (activePart instanceof ISetSelectionTarget) {
			workbench.getDisplay().asyncExec(new Runnable() {

				public void run() {
					((ISetSelectionTarget) activePart).selectReveal(selection);
				}
			});
		}
	}

	public static void openInEditor(IWorkbench workbench, IFile file) throws PartInitException {
		IWorkbenchWindow workbenchWindow = workbench.getActiveWorkbenchWindow();
		IWorkbenchPage page = workbenchWindow.getActivePage();
		page.openEditor(new FileEditorInput(file), workbench.getEditorRegistry().getDefaultEditor(file.getFullPath().toString()).getId());
	}

	/**
	 * In case selection points to file resource, tries to find file 
	 * with same name and specified extension.
	 * 
	 * @@param selection context to look at
	 * @@param fileExt filename extension to look for
	 * @@return 
	 */
	public static IFile findExistingFile(IStructuredSelection selection, String fileExt) {
		if (selection == null || selection.isEmpty() || false == selection.getFirstElement() instanceof IFile) {
			return null;
		}
		IFile selected = (IFile) selection.getFirstElement();
		String fileNameBase = getFileBaseName(selected);
		IResource candidate = selected.getParent().findMember(fileNameBase + '.' + fileExt);
		if (candidate != null && candidate.getType() == IResource.FILE && candidate.exists()) {
			return (IFile) candidate;
		}
		return null;
	}

	private static String getFileBaseName(IFile file) {
		String fileNameBase = file.getName();
		if (file.getFileExtension() != null) {
			fileNameBase = fileNameBase.substring(0, fileNameBase.length() - (file.getFileExtension().length() + 1));
		}
		return fileNameBase;
	}
}
@


1.9
log
@remove duplicate getFile() method; use the one from URIUtil
@
text
@d96 4
@


1.8
log
@simple wizards i18n
@
text
@a18 1
import org.eclipse.core.resources.ResourcesPlugin;
a19 2
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.common.util.URI;
a46 2
	// Wizard operation modes

a114 15
	public static IFile getFile(URI uri) {
		String fileName = uri.toFileString();
		if (fileName != null) {
			return ResourcesPlugin.getWorkspace().getRoot().getFileForLocation(new Path(fileName));
		}
		if (uri.toString().startsWith("platform:/resource")) { //$NON-NLS-1$
			String path = uri.toString().substring("platform:/resources".length()); //$NON-NLS-1$
			IResource workspaceResource = ResourcesPlugin.getWorkspace().getRoot().findMember(new Path(path));
			if (workspaceResource instanceof IFile) {
				return (IFile) workspaceResource;
			}
		}
		return null;
	}

@


1.7
log
@move pages and model of simple graph and tool wizards in dedicated package; provide i18n
@
text
@a28 1
import org.eclipse.gmf.internal.bridge.wizards.pages.Messages;
@


1.6
log
@return valid file on reconcile
@
text
@d29 1
d35 1
d126 2
a127 2
		if (uri.toString().startsWith("platform:/resource")) {
			String path = uri.toString().substring("platform:/resources".length());
d159 1
a159 1
			MessageDialog.openError(workbenchWindow.getShell(), "Unable to open editor for " + modelFile, exception.getMessage());
@


1.5
log
@#126531 allow to specify reconcile mode explicitly
@
text
@d119 1
a119 2
	public static void openEditor(URI uri) {
		IFile modelFile = null;
d122 1
a122 1
			modelFile = ResourcesPlugin.getWorkspace().getRoot().getFileForLocation(new Path(fileName));
d128 1
a128 1
				modelFile = (IFile) workspaceResource;
d131 1
a131 3
		if (modelFile != null) {
			openEditor(modelFile);
		}
@


1.4
log
@#126531 Wizards that infer tooling and graph definitions should be able to add results to the existing models
@
text
@d14 3
d20 1
d26 3
a28 1
import org.eclipse.gmf.gmfgraph.provider.GMFGraphEditPlugin;
d33 1
d40 1
a40 1
import org.eclipse.ui.internal.UIPlugin;
d49 2
d100 19
d173 1
@


1.3
log
@#148976 New GMFGraph/GMFTool Simple model Wizard: show references contained by recognized link nodes in model Definition page
@
text
@d16 3
d20 1
d22 2
d26 1
d32 2
d72 10
d91 48
@


1.2
log
@respect selection and set filenames according to existing files
@
text
@d55 12
d69 1
a69 8
		String name = type.getName();
		if (feature.getName().length() > 0) {
			name += Character.toUpperCase(feature.getName().charAt(0));
		}
		if (feature.getName().length() > 1) {
			name += feature.getName().substring(1);
		}
		return name;
@


1.1
log
@Introduced separate plugin for Tooling UI, moved mapping wizard of #114186 to this plugin.
Wizard got some NLS, respect selection, open-created-model-in-editor improvements as well as aligned with recent gmfmap changes.
Plus, some refactorings to address user-prioritized strategies to select nodes/links doubled number of classes we had.
@
text
@d15 1
d47 2
a48 5
		String fileNameBase = file.getName();
		if (file.getFileExtension() != null) {
			fileNameBase = fileNameBase.substring(0, fileNameBase.length() - (file.getFileExtension().length() + 1));
		}
		String modelFilename = fileNameBase + "." + extension;
d50 1
a50 1
			modelFilename = fileNameBase + i + "." + extension;
d85 29
@

