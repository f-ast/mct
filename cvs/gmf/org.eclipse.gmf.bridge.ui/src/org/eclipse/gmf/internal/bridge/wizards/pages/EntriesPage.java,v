head	1.10;
access;
symbols
	v20080924-1925:1.10
	v20080722-1827:1.10
	v20080716-1642:1.10
	R2_1_maintenance:1.10.0.4
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080417-1610:1.10
	v20080322-0000:1.10
	v20080222-1200:1.10
	v20080215-1500:1.10
	v20080207-0207:1.10
	v20071124-0000:1.10
	v20071108-0000:1.10
	v20070903-0000:1.10
	v20070809-0000:1.10
	R2_0_maintenance:1.10.0.2
	R2_0:1.10
	R4_20:1.10
	v20070621-0000:1.10
	RC3_20:1.10
	v20070608-1300:1.10
	v20070605-1400:1.10
	v20070601-1400:1.10
	v20070520-1200:1.10
	v20070518-1300:1.10
	v20070420-1000:1.10
	v20070413-1300:1.10
	v20070405-2000:1.10
	v20070330-1300:1.10
	v20070322-1100:1.10
	v20060316-0600:1.10
	v20070301-1200:1.9
	v20070228-2000:1.9
	v20070208-1800:1.9
	M4_20:1.9
	v20061214-0000:1.9
	M3_20:1.9
	v20061117-0800:1.9
	v20061013-1330:1.9
	v20060925-1700:1.8.2.1
	v20060919-0800:1.8.2.1
	M1_20:1.9
	v20060904-1500:1.9
	v20060713-1700:1.8
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	v20060627-1200:1.8
	v20060626-1420:1.8
	v20060620-0400:1.8
	v20060616-1200:1.8
	v20060609-1400:1.8
	v20060531-1730:1.8
	v20060526-1200:1.8
	v20060519-0800:1.8
	v20060512-1000:1.5
	I20060512-1000:1.5
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.2
	S20060303-1600:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.10
date	2007.03.14.12.59.33;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	114b45f7f1b34567;

1.9
date	2006.09.04.14.47.44;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.16.16.12.26;	author atikhomirov;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2006.05.16.11.56.04;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.14.18.06.27;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.11.09.42.02;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.10.15.12.30;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.07.19.13.06;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.03.20.33.20;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.28.19.07.41;	author atikhomirov;	state Exp;
branches;
next	;

1.8.2.1
date	2006.09.13.23.07.19;	author rgronback;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@/*
 * Copyright (c) 2005, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.bridge.wizards.pages;

import java.util.Arrays;
import java.util.Iterator;

import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.provider.EcoreItemProviderAdapterFactory;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.edit.ui.provider.AdapterFactoryContentProvider;
import org.eclipse.gmf.mappings.FeatureInitializer;
import org.eclipse.gmf.mappings.FeatureSeqInitializer;
import org.eclipse.gmf.mappings.GMFMapFactory;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.Mapping;
import org.eclipse.gmf.mappings.MappingEntry;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.NodeReference;
import org.eclipse.gmf.mappings.TopNodeReference;
import org.eclipse.jface.dialogs.Dialog;
import org.eclipse.jface.dialogs.IDialogConstants;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.IStructuredContentProvider;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.window.Window;
import org.eclipse.jface.wizard.WizardPage;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.events.SelectionListener;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.layout.RowLayout;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Event;
import org.eclipse.swt.widgets.Group;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Listener;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.dialogs.ListDialog;
import org.eclipse.ui.views.properties.PropertySheetPage;

/**
 * @@author artem
 *
 */
public class EntriesPage extends WizardPage {
	private final WizardInput myHolder;

	public EntriesPage(WizardInput input) {
		super("entriesPage"); //$NON-NLS-1$
		this.myHolder = input;
		setTitle(Messages.mapPageTitle);
		setDescription(Messages.mapPageDesc);
	}

	protected Mapping getMapInstance() {
		return myHolder.getMapping();
	}

	protected WizardInput getHolder() {
		return myHolder;
	}

	public void createControl(Composite parent) {
		setControl(new PageControl(parent));
	}

	public void setVisible(boolean visible) {
		super.setVisible(visible);
		if (visible) {
			((PageControl) getControl()).populate();
		}
	}

	private class PageControl extends Composite {

		private Group group = null;
		private List nodesList = null;
		private Group group1 = null;
		private List linksList = null;
		private Composite detailsPart = null;
		private Group groupStructure = null;
		private Group groupEdit = null;
		private Group groupVisual = null;
		private Composite composite2 = null;
		private Composite composite = null;
		private Button asNodeButton = null;
		private Button asLinkButton = null;
		private Button removeButton = null;
		private Button changeDetailsButton = null;
		private Button restoreButton = null;
		private Group groupConstaints = null;
		private Label specLabel = null;
		private Label initLabel = null;
		private Label diagramElementLabel = null;
		private Label metaElementLabel;
		private Label containmentLabel;
		private Label linkMetaFeatureLabel;

		private boolean isNodeInSelection;
		private NodeReference selectedNode;
		private LinkMapping selectedLink;

		private final ILabelProvider myLabelProvider = new LabelProvider() {
			final EcoreItemProviderAdapterFactory helperFactory = new EcoreItemProviderAdapterFactory();
			public String getText(Object element) {
				if (element instanceof LinkMapping) {
					LinkMapping next = (LinkMapping) element;
					final String linkName;
					if (next.getDomainMetaElement() == null) {
						if (next.getLinkMetaFeature() == null) {
							linkName = Messages.unspecifiedValue;
						} else {
							linkName = getLabel(next.getLinkMetaFeature());
						}
					} else {
						linkName = getLabel(next.getDomainMetaElement());
					}
					final String dlName = next.getDiagramLink() != null ? next.getDiagramLink().getName() : Messages.unspecifiedValue;
					final String featureName = next.getContainmentFeature() != null ? next.getContainmentFeature().getName() : Messages.unspecifiedValue;
					return Messages.bind(Messages.linkLabel, new Object[] {linkName, dlName, featureName});
				} else {
					NodeReference next = (NodeReference) element;
					final String nodeName = next.getChild().getDomainMetaElement() == null ? Messages.unspecifiedValue : getLabel(next.getChild().getDomainMetaElement());
					final String dnName = next.getChild().getDiagramNode() != null ? next.getChild().getDiagramNode().getName() : Messages.unspecifiedValue;
					final String featureName; 
					if (next.getContainmentFeature() != null) {
						featureName = next.getContainmentFeature().getName();
					} else if (next.getChildrenFeature() != null) {
						featureName = next.getChildrenFeature().getName();
					} else {
						featureName = Messages.unspecifiedValue;
					}
					return Messages.bind(Messages.nodeLabel, new Object[] {nodeName, dnName, featureName});
				}
			}
			private String getLabel(EObject ecoreElement) {
				IItemLabelProvider lp = (IItemLabelProvider) helperFactory.adapt((Object) ecoreElement, IItemLabelProvider.class);
				assert lp != null;
				return lp.getText(ecoreElement);
			}
		};

		private SelectionListener myListListener = new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				final boolean nodeSelected = e.widget == nodesList;
				removeButton.setEnabled(true);
				changeDetailsButton.setEnabled(true);
				restoreButton.setEnabled(true);
				if (nodeSelected) {
					handleNodesListSelectionChange();
					linksList.deselectAll();
				} else {
					// e.widget == linksList
					handleLinksListSelectionChange();
					nodesList.deselectAll();
				}
			}
			public void widgetDefaultSelected(SelectionEvent e) {
				widgetSelected(e);
			}
		};

		public PageControl(Composite parent) {
			super(parent, SWT.NONE);
			initialize();
		}

		public void populate() {
			populateNodesList();
			populateLinksList();
		}

		private void populateNodesList() {
			String[] items = new String[getMapInstance().getNodes().size()];
			int i = 0;
			for (Iterator<?> it = getMapInstance().getNodes().iterator(); it.hasNext(); i++) {
				items[i] = myLabelProvider.getText(it.next());
			}
			nodesList.setItems(items);
		}

		private void populateLinksList() {
			String[] items = new String[getMapInstance().getLinks().size()];
			int i = 0;
			for (Iterator<?> it = getMapInstance().getLinks().iterator(); it.hasNext(); i++) {
				items[i] = myLabelProvider.getText(it.next());
			}
			linksList.setItems(items);
		}

		private void initialize() {
			GridLayout gridLayout = new GridLayout();
			gridLayout.numColumns = 3;
			this.setLayout(gridLayout);
//			setSize(new org.eclipse.swt.graphics.Point(990,612));
			createNodesList();
			createButtonsPane();
			createLinksList();
			createDetailsPart();
		}

		private void createNodesList() {
			GridData gridData = new GridData();
			gridData.horizontalAlignment = GridData.FILL;
			gridData.grabExcessHorizontalSpace = true;
			gridData.grabExcessVerticalSpace = true;
			gridData.verticalAlignment = GridData.FILL;
			group = new Group(this, SWT.NONE);
			group.setLayout(new FillLayout());
			group.setLayoutData(gridData);
			group.setText(Messages.mapNodesList);
			nodesList = new List(group, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL);
			nodesList.addSelectionListener(myListListener);
		}

		private void createLinksList() {
			GridData gridData1 = new GridData();
			gridData1.grabExcessHorizontalSpace = true;
			gridData1.horizontalAlignment = GridData.FILL;
			gridData1.verticalAlignment = GridData.FILL;
			gridData1.grabExcessVerticalSpace = true;
			group1 = new Group(this, SWT.NONE);
			group1.setLayout(new FillLayout());
			group1.setLayoutData(gridData1);
			group1.setText(Messages.mapLinksList);
			linksList = new List(group1, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL);
			linksList.addSelectionListener(myListListener);
		}

		private void createDetailsPart() {
			GridData gridData3 = new GridData();
			gridData3.horizontalSpan = 5;
			gridData3.verticalAlignment = GridData.FILL;
			gridData3.grabExcessHorizontalSpace = true;
			gridData3.grabExcessVerticalSpace = false;
			gridData3.horizontalAlignment = GridData.FILL;
			detailsPart = new Composite(this, SWT.NONE);
			detailsPart.setLayoutData(gridData3);
			GridLayout gridLayout1 = new GridLayout();
			gridLayout1.numColumns = 7;
			gridLayout1.makeColumnsEqualWidth = true;
			detailsPart.setLayout(gridLayout1);
			createStructureGroup();
			createEditGroup();
			changeDetailsButton = new Button(detailsPart, SWT.NONE);
			changeDetailsButton.setText(Messages.mapChange);
			changeDetailsButton.addSelectionListener(new SelectionAdapter() {
				public void widgetSelected(SelectionEvent e) {
					final Object input =  isNodeInSelection ? (Object) selectedNode : (Object) selectedLink;
					ChangePropertiesDialog changePropertiesDialog = new ChangePropertiesDialog(getShell(), new Object[] {input});
					int result = changePropertiesDialog.open();
					if (result == Window.OK) {
// TODO: save values to the model here
					}
				}
			});
			GridData gridData8 = new GridData();
			gridData8.grabExcessHorizontalSpace = true;
			gridData8.verticalAlignment = GridData.CENTER;
			gridData8.verticalSpan = 2;
			gridData8.horizontalAlignment = GridData.CENTER;
			changeDetailsButton.setLayoutData(gridData8);
			createVisualGroup();
			createConstraintsGroup();
		}

		private void createStructureGroup() {
			groupStructure = new Group(detailsPart, SWT.SHADOW_OUT);
			groupStructure.setText(Messages.groupStructure);
			groupStructure.setLayoutData(newDetailGroupConstraint());
			groupStructure.setLayout(newDetailGroupLayout());
			Label l = new Label(groupStructure, SWT.NONE);
			l.setText(Messages.labelElement);
			metaElementLabel = new Label(groupStructure, SWT.NONE);
			metaElementLabel.setLayoutData(newDetailLabelConstraint());
			l = new Label(groupStructure, SWT.NONE);
			l.setText(Messages.labelContainment);
			containmentLabel = new Label(groupStructure, SWT.NONE);
			containmentLabel.setLayoutData(newDetailLabelConstraint());
			l = new Label(groupStructure, SWT.NONE);
			l.setText(Messages.labelTargetFeature);
			linkMetaFeatureLabel = new Label(groupStructure, SWT.NONE);
			linkMetaFeatureLabel.setLayoutData(newDetailLabelConstraint());
			
		}

		private void createEditGroup() {
			groupEdit = new Group(detailsPart, SWT.NONE);
			groupEdit.setText(Messages.groupEdit);
			groupEdit.setLayout(newDetailGroupLayout());
			groupEdit.setLayoutData(newDetailGroupConstraint());
		}

		private void createVisualGroup() {
			groupVisual = new Group(detailsPart, SWT.NONE);
			groupVisual.setText(Messages.groupVisual);
			groupVisual.setLayoutData(newDetailGroupConstraint());
			groupVisual.setLayout(newDetailGroupLayout());
			Label l = new Label(groupVisual, SWT.NONE);
			l.setText(Messages.labelDiagramElement);
			diagramElementLabel = new Label(groupVisual, SWT.NONE);
			diagramElementLabel.setLayoutData(newDetailLabelConstraint());
		}

		private void createButtonsPane() {
			GridData gridData2 = new GridData();
			gridData2.horizontalAlignment = GridData.FILL;
			gridData2.verticalAlignment = GridData.CENTER;
			composite2 = new Composite(this, SWT.NONE);
			composite2.setLayout(new FillLayout());
			composite2.setLayoutData(gridData2);
			createComposite();
		}

		private void createComposite() {
			RowLayout rowLayout = new RowLayout();
			rowLayout.type = org.eclipse.swt.SWT.VERTICAL;
			rowLayout.justify = true;
			rowLayout.marginHeight = 0;
			rowLayout.marginWidth = 0;
			rowLayout.pack = false;
			rowLayout.spacing = 6;
			rowLayout.marginLeft = 10;
			rowLayout.marginRight = 10;
			rowLayout.fill = false;
			composite = new Composite(composite2, SWT.NONE);
			composite.setLayout(rowLayout);
			asNodeButton = new Button(composite, SWT.NONE);
			asNodeButton.setText(Messages.mapAsNode);
			asNodeButton.setEnabled(false);
			asNodeButton.addListener(SWT.Selection, new Listener() {
				@@SuppressWarnings("unchecked")
				public void handleEvent(Event event) {
					TopNodeReference tnr = GMFMapFactory.eINSTANCE.createTopNodeReference();
					NodeMapping nm = GMFMapFactory.eINSTANCE.createNodeMapping();
					nm.setDomainMetaElement(selectedLink.getDomainMetaElement());
					nm.setDomainInitializer(selectedLink.getDomainInitializer());
					nm.setDomainSpecialization(selectedLink.getDomainSpecialization());
					nm.setTool(selectedLink.getTool());
					nm.setContextMenu(selectedLink.getContextMenu());
					nm.setAppearanceStyle(selectedLink.getAppearanceStyle());
					tnr.setContainmentFeature(selectedLink.getContainmentFeature());
					tnr.setOwnedChild(nm);
					getMapInstance().getNodes().add(tnr);
					getMapInstance().getLinks().remove(selectedLink);
					linksList.remove(linksList.getSelectionIndex());
					nodesList.add(myLabelProvider.getText(tnr));
					nodesList.setSelection(nodesList.getItemCount() - 1);
					handleNodesListSelectionChange();
				}
			});
			asLinkButton = new Button(composite, SWT.NONE);
			asLinkButton.setText(Messages.mapAsLink);
			asLinkButton.setEnabled(false);
			asLinkButton.addListener(SWT.Selection, new Listener() {
				@@SuppressWarnings("unchecked")
				public void handleEvent(Event event) {
					LinkMapping lm = GMFMapFactory.eINSTANCE.createLinkMapping();
					NodeMapping nodeMapping =  selectedNode.getChild();
					lm.setDomainMetaElement(nodeMapping.getDomainMetaElement());
					lm.setContainmentFeature(selectedNode.getContainmentFeature());
					lm.setDomainInitializer(nodeMapping.getDomainInitializer());
					lm.setDomainSpecialization(nodeMapping.getDomainSpecialization());
					lm.setTool(nodeMapping.getTool());
					lm.setContextMenu(nodeMapping.getContextMenu());
					lm.setAppearanceStyle(nodeMapping.getAppearanceStyle());
					getMapInstance().getLinks().add(lm);
					getMapInstance().getNodes().remove(selectedNode);
					nodesList.remove(nodesList.getSelectionIndex());
					linksList.add(myLabelProvider.getText(lm));
					linksList.setSelection(linksList.getItemCount() - 1);
					handleLinksListSelectionChange();
				}
			});
			removeButton = new Button(composite, SWT.NONE);
			removeButton.setText(Messages.mapRemove);
			removeButton.setEnabled(false);
			removeButton.addListener(SWT.Selection, new Listener() {
				public void handleEvent(Event event) {
					if (nodesList.getSelectionIndex() != -1) {
						int i = nodesList.getSelectionIndex();
						nodesList.remove(i);
						getMapInstance().getNodes().remove(i);
						if (i == nodesList.getItemCount() && i > 0) {
							i--;
						}
						nodesList.setSelection(i);
						if (nodesList.getItemCount() == 0) {
							asLinkButton.setEnabled(false);
							removeButton.setEnabled(false);
							changeDetailsButton.setEnabled(false);
						} else {
							handleNodesListSelectionChange();
						}
					}
					if (linksList.getSelectionIndex() != -1) {
						int i = linksList.getSelectionIndex();
						linksList.remove(i);
						getMapInstance().getLinks().remove(i);
						if (i == linksList.getItemCount() && i > 0) {
							i--;
						}
						linksList.setSelection(i);
						if (linksList.getItemCount() == 0) {
							asNodeButton.setEnabled(false);
							removeButton.setEnabled(false);
							changeDetailsButton.setEnabled(false);
						} else {
							handleLinksListSelectionChange();
						}
					}
				}
			});
			restoreButton = new Button(composite, SWT.NONE);
			restoreButton.setText(Messages.mapRestore);
			restoreButton.setEnabled(false);
			restoreButton.addListener(SWT.Selection, new Listener() {
				@@SuppressWarnings("unchecked")
				public void handleEvent(Event event) {
					ListDialog d = new ListDialog(getShell());
					d.setTitle(isNodeInSelection ? Messages.mapRestoreNode : Messages.mapRestoreLink);
					d.setMessage(Messages.mapRestoreText);
					d.setContentProvider(new IStructuredContentProvider() {
						public Object[] getElements(Object inputElement) {
							return (Object[]) inputElement;
						}
						public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
						}
						public void dispose() {
						}
					});
					d.setLabelProvider(PageControl.this.myLabelProvider);
					if (isNodeInSelection) {
						d.setInput(getHolder().nodeCandidates());
					} else {
						d.setInput(getHolder().linkCandidates());
					}
					if (d.open() == ListDialog.OK) {
						if (isNodeInSelection) {
							getMapInstance().getNodes().addAll(Arrays.asList((TopNodeReference[]) d.getResult()));
							nodesList.removeAll();
							populateNodesList();
						} else {
							getMapInstance().getLinks().addAll(Arrays.asList((LinkMapping[]) d.getResult()));
							linksList.removeAll();
							populateLinksList();
						}
					}
				}
			});
		}

		private void createConstraintsGroup() {
			groupConstaints = new Group(detailsPart, SWT.NONE);
			groupConstaints.setText(Messages.groupConstraints);
			groupConstaints.setLayout(newDetailGroupLayout());
			groupConstaints.setLayoutData(newDetailGroupConstraint());

			Label label = new Label(groupConstaints, SWT.NONE);
			label.setText(Messages.labelSpecialization);
			specLabel = new Label(groupConstaints, SWT.NONE);
			specLabel.setLayoutData(newDetailLabelConstraint());

			label = new Label(groupConstaints, SWT.NONE);
			label.setText(Messages.labelInitializer);
			initLabel = new Label(groupConstaints, SWT.NONE);
			initLabel.setLayoutData(newDetailLabelConstraint());
			// TODO link creation constraints
		}

		private GridLayout newDetailGroupLayout() {
			GridLayout gridLayout = new GridLayout();
			gridLayout.numColumns = 3;
			gridLayout.makeColumnsEqualWidth = true;
			return gridLayout;
		}

		private GridData newDetailGroupConstraint() {
			GridData groupGridData = new GridData();
			groupGridData.horizontalAlignment = GridData.FILL;
			groupGridData.grabExcessHorizontalSpace = true;
			groupGridData.grabExcessVerticalSpace = true;
			groupGridData.horizontalSpan = 3;
			groupGridData.verticalAlignment = GridData.FILL;
			return groupGridData;
		}

		private GridData newDetailLabelConstraint() {
			GridData labelGridData = new GridData();
			labelGridData.horizontalSpan = 2;
			labelGridData.grabExcessHorizontalSpace = true;
			labelGridData.horizontalAlignment = GridData.FILL;
			return labelGridData;
		}

		private void refreshCommonDetails(MappingEntry selectedEntry) {
			affix(metaElementLabel, selectedEntry.getDomainMetaElement());
			refreshDomainSpecialization(selectedEntry);
			refreshDomainInitializer(selectedEntry);
		}

		private void refreshDomainSpecialization(MappingEntry selectedEntry) {
			if (selectedEntry.getDomainSpecialization() == null) {
				specLabel.setText("");
				return;
			}
			specLabel.setText(selectedEntry.getDomainSpecialization().getBody());
		}

		private void refreshDomainInitializer(MappingEntry selectedEntry) {
			if (selectedEntry.getDomainInitializer() == null || false == selectedEntry.getDomainInitializer() instanceof FeatureSeqInitializer) {
				initLabel.setText("");
				return;
			}
			FeatureSeqInitializer fsi = (FeatureSeqInitializer) selectedEntry.getDomainInitializer();
			StringBuilder sb = new StringBuilder();
			for (FeatureInitializer next : fsi.getInitializers()) {
				sb.append(next.getFeature().getName());
				sb.append("; ");
			}
			initLabel.setText(sb.toString());
		}

		private void affix(Label l, ENamedElement el) {
			if (el != null) {
				l.setText(el.getName());
			} else {
				l.setText("");
			}
		}

		private void refreshNodeDetails() {
			refreshCommonDetails(selectedNode.getChild());
			NodeMapping m = selectedNode.getChild();
			affix(containmentLabel, selectedNode.getContainmentFeature());
			if (m.getDiagramNode() != null) {
				diagramElementLabel.setText(m.getDiagramNode().getName());
			} else {
				diagramElementLabel.setText("");
			}
			linkMetaFeatureLabel.setText("");
		}

		private void refreshLinkDetails() {
			refreshCommonDetails(selectedLink);
			affix(containmentLabel, selectedLink.getContainmentFeature());
			LinkMapping l = selectedLink;
			if (l.getDiagramLink() != null) {
				diagramElementLabel.setText(l.getDiagramLink().getName());
			} else {
				diagramElementLabel.setText("");
			}
			affix(linkMetaFeatureLabel, l.getLinkMetaFeature());
		}

		void handleNodesListSelectionChange() {
			asNodeButton.setEnabled(false);
			asLinkButton.setEnabled(true);
			assert nodesList.getSelectionIndex() != -1;
			selectedNode = getMapInstance().getNodes().get(nodesList.getSelectionIndex());
			isNodeInSelection = true;
			refreshNodeDetails();
		}

		void handleLinksListSelectionChange() {
			assert linksList.getSelectionIndex() != -1;
			asLinkButton.setEnabled(false);
			selectedLink = getMapInstance().getLinks().get(linksList.getSelectionIndex());
			asNodeButton.setEnabled(selectedLink.getDomainMetaElement() != null);
			isNodeInSelection = false;
			refreshLinkDetails();
		}
	}
	
	private class ChangePropertiesDialog extends Dialog {

		private Object[] mySelection;

		protected ChangePropertiesDialog(Shell parentShell, Object[] selection) {
			super(parentShell);
			setShellStyle(getShellStyle() | SWT.RESIZE);
			mySelection = selection;
		}

		protected Control createDialogArea(Composite parent) {
			Composite composite = (Composite) super.createDialogArea(parent);
			Composite frame = new Composite(composite, SWT.BORDER);
			GridData layoutData = new GridData(GridData.FILL_BOTH);
			layoutData.heightHint = 300;
			layoutData.widthHint = 400;
			frame.setLayoutData(layoutData);
			GridLayout layout = new GridLayout();
			layout.marginHeight = 0;
			layout.marginWidth = 0;
			frame.setLayout(layout);
			
			PropertySheetPage propertyPage = new PropertySheetPage();
			propertyPage.createControl(frame);
			propertyPage.setPropertySourceProvider(new AdapterFactoryContentProvider(myHolder.getAdapterFactory()));
			propertyPage.selectionChanged(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getPartService().getActivePart(), new StructuredSelection(mySelection));
			propertyPage.getControl().setLayoutData(new GridData(GridData.FILL_BOTH));
			return composite;
		}
		
		protected void createButtonsForButtonBar(Composite parent) {
			createButton(parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, true);
		}
		
	}
}
@


1.9
log
@use generics wherever possible
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
d22 1
a23 1
import org.eclipse.gmf.mappings.FeatureValueSpec;
d196 1
a196 1
			for (Iterator it = getMapInstance().getNodes().iterator(); it.hasNext(); i++) {
d205 1
a205 1
			for (Iterator it = getMapInstance().getLinks().iterator(); it.hasNext(); i++) {
d460 1
a460 1
							getMapInstance().getNodes().addAll(Arrays.asList(d.getResult()));
d464 1
a464 1
							getMapInstance().getLinks().addAll(Arrays.asList(d.getResult()));
d536 2
a537 3
			StringBuffer sb = new StringBuffer();
			for (Iterator it = fsi.getInitializers().iterator(); it.hasNext();) {
				FeatureValueSpec next = (FeatureValueSpec) it.next();
d580 1
a580 1
			selectedNode = (NodeReference) getMapInstance().getNodes().get(nodesList.getSelectionIndex());
d588 1
a588 1
			selectedLink =(LinkMapping) getMapInstance().getLinks().get(linksList.getSelectionIndex());
@


1.8
log
@detect containment features for links (represented with EClasses)
@
text
@d352 1
d376 1
d438 1
@


1.8.2.1
log
@[153901] Updated copyright date from 2005 to 2005, 2006 for those changed in CVS in 2006 (based on Tom/Anthony's script).
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
@


1.7
log
@externalize strings, #136929 hint what's expected as diagram root
@
text
@d564 1
@


1.6
log
@overriding recent changes introduced (along with fixing #133836) in GMFMap model, as it's merely a 'shortcut', quite frequent though. Still, adding few new concepts just for the sake of single usecase (I do admit it's popular) seems excessive to me.
GMFMap kept the same as old (no new notions introduced), GMFGraph got generalization from DiagramLabel to DiagramNode to make it possible to use DiagramLabels for NodeMappings (thus, it's possible to detect such nodes in the DGMT)
Tests added to make sure we generate correct genModel for both cases.
@
text
@d18 3
d124 1
d128 1
a128 1
					StringBuffer sb = new StringBuffer();
d131 1
a131 1
							sb.append("Link");
d133 1
a133 3
							sb.append(next.getLinkMetaFeature().getName());
							sb.append(" : ");
							sb.append(next.getLinkMetaFeature().getEContainingClass().getName());
d136 1
a136 1
						sb.append(next.getDomainMetaElement().getName());
d138 3
a140 12
					sb.append(" (");
					if (next.getDiagramLink() != null) {
						sb.append(next.getDiagramLink().getName());
						if (next.getContainmentFeature() != null) {
							sb.append(";  ");
						}
					}
					if (next.getContainmentFeature() != null) {
						sb.append(next.getContainmentFeature().getName());
					}
					sb.append(")");
					return sb.toString();
d143 3
a145 9
					StringBuffer sb = new StringBuffer();
					sb.append(next.getChild().getDomainMetaElement() == null ? "Node" : next.getChild().getDomainMetaElement().getName());
					sb.append(" (");
					if (next.getChild().getDiagramNode() != null) {
						sb.append(next.getChild().getDiagramNode().getName());
						if (next.getContainmentFeature() != null) {
							sb.append(";  ");
						}
					}
d147 5
a151 1
						sb.append(next.getContainmentFeature().getName());
d153 1
a153 2
					sb.append(")");
					return sb.toString();
d156 5
d231 1
a231 1
			group.setText("Nodes");
d245 1
a245 1
			group1.setText("Links");
d266 1
a266 1
			changeDetailsButton.setText("Change...");
d289 1
a289 1
			groupStructure.setText("Structure");
d293 1
a293 1
			l.setText("Element:");
d297 1
a297 1
			l.setText("Containment:");
d301 1
a301 1
			l.setText("Target Feature:");
d309 1
a309 1
			groupEdit.setText("Edit");
d316 1
a316 1
			groupVisual.setText("Visual");
d320 1
a320 1
			l.setText("Diagram Element:");
d349 1
a349 1
			asNodeButton.setText("As node <--");
d372 1
a372 1
			asLinkButton.setText("As link  -->");
d394 1
a394 1
			removeButton.setText("Remove");
d433 1
a433 1
			restoreButton.setText("Restore...");
d438 2
a439 2
					d.setTitle(isNodeInSelection ? "Restore nodes" : "Restore links");
					d.setMessage("Choose elements to revive");
d472 1
a472 1
			groupConstaints.setText("Constraints");
d477 1
a477 1
			label.setText("Specialization:");
d482 1
a482 1
			label.setText("Initializer:");
@


1.5
log
@revert to gmfmap model compatibility
@
text
@a21 1
import org.eclipse.gmf.mappings.LabelNodeMapping;
a157 5
					} else if (next.getChild() instanceof LabelNodeMapping && ((LabelNodeMapping) next.getChild()).getDiagramLabel() != null) {
						sb.append(((LabelNodeMapping) next.getChild()).getDiagramLabel().getName());
						if (next.getContainmentFeature() != null) {
							sb.append(";  ");
						}
@


1.4
log
@#133836 Creating a child node without a label causes error
@
text
@a27 1
import org.eclipse.gmf.mappings.ShapeNodeMapping;
d154 2
a155 2
					if (next.getChild() instanceof ShapeNodeMapping && ((ShapeNodeMapping) next.getChild()).getDiagramNode() != null) {
						sb.append(((ShapeNodeMapping) next.getChild()).getDiagramNode().getName());
d365 1
a365 1
					ShapeNodeMapping nm = GMFMapFactory.eINSTANCE.createShapeNodeMapping();
d565 2
a566 2
			if (m instanceof ShapeNodeMapping && ((ShapeNodeMapping) m).getDiagramNode() != null) {
				diagramElementLabel.setText(((ShapeNodeMapping) m).getDiagramNode().getName());
@


1.3
log
@CCE on As Node action
@
text
@d22 1
d28 1
d155 7
a161 2
					if (next.getChild().getDiagramNode() != null) {
						sb.append(next.getChild().getDiagramNode().getName());
d366 1
a366 1
					NodeMapping nm = GMFMapFactory.eINSTANCE.createNodeMapping();
d566 2
a567 2
			if (m.getDiagramNode() != null) {
				diagramElementLabel.setText(m.getDiagramNode().getName());
@


1.2
log
@AIOOBE when removing last element from list
@
text
@d371 1
a371 1
					nodesList.add(myLabelProvider.getText(nm));
d443 2
@


1.1
log
@Introduced separate plugin for Tooling UI, moved mapping wizard of #114186 to this plugin.
Wizard got some NLS, respect selection, open-created-model-in-editor improvements as well as aligned with recent gmfmap changes.
Plus, some refactorings to address user-prioritized strategies to select nodes/links doubled number of classes we had.
@
text
@d411 7
a417 1
						handleNodesListSelectionChange();
d427 7
a433 1
						handleLinksListSelectionChange();
@

