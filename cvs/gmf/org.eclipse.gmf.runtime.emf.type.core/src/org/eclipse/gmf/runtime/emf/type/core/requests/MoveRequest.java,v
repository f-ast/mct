head	1.7;
access;
symbols
	v20081020-0700:1.7
	v20080807-1333:1.7
	v20080807-1325:1.7
	v20080731-1520:1.7
	v20080725-1738:1.7
	v20080722-1827:1.7
	R2_1_maintenance:1.7.0.6
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080425-1959:1.7
	v20080328-1605:1.7
	v20080222-1200:1.7
	v20080114-2222:1.7
	v20080107-1111:1.7
	v20071130-1111:1.7
	v20071124-0000:1.7
	v20070809-0000:1.7
	R2_0_maintenance:1.7.0.4
	R2_0:1.7
	R4_20:1.7
	RC3_20:1.7
	v20070601-1400:1.7
	v20070518-1300:1.7
	v20070403-1500:1.7
	v20070330-1300:1.7
	v20070208-1800:1.7
	M4_20:1.7
	v20061214-0000:1.7
	M3_20:1.7
	v20061117-0800:1.7
	v20061013-1330:1.7
	v20060919-0800:1.7
	v20060907-1100:1.7
	M1_20:1.7
	v20060831-1500:1.7
	v20060817-1500:1.7
	v20060803-1200:1.7
	v20060721-1130:1.7
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060609-1400:1.7
	v20060531-1730:1.7
	v20060530-1930:1.7
	v20060526-1200:1.7
	v20060519-0800:1.7
	I20060505-1400:1.7
	I20060428-1300:1.7
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.6
	I20060216-1945:1.6
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.3
	I20051223-1100:1.3
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.7
date	2006.04.26.20.14.33;	author ldamus;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.13.19.12.20;	author ldamus;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.23.21.27.31;	author ldamus;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.04.15.55.28;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.22.19.02.01;	author ldamus;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.26.55;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.49;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.7
log
@[136760] gmf_head ldamus 060426  ElementTypeRegistry prevents deployment of different applications sharing the same metamodel
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.type.core.requests;

import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gmf.runtime.emf.type.core.EditHelperContext;
import org.eclipse.gmf.runtime.emf.type.core.IClientContext;
import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.EMFTypeCoreMessages;

/**
 * Request to move a collections of model elements from one location to another.
 * The request can specify the target features that should be used to contain
 * each of the elements being moved.
 * <P>
 * If the target feature is not specified for a given element being moved, then
 * a default feature is found in the target according to the following rules:
 * <UL>
 * <LI>If the feature fomerly containing the moved element exists in the target
 * element, it will be used.</LI>
 * <LI>Otherwise, the first feature in the target that can contain the moved
 * element will be used.</LI>
 * </UL>
 * 
 * @@author ldamus
 */
public class MoveRequest
    extends AbstractEditCommandRequest {

    /**
     * The map of <code>EObject</code>s to be moved. Keyed on
     * <code>EObject</code>. Each value is the <code>EReference</code>
     * feature in the target element into which the element should be moved.
     * <P>
     * If the feature is not specified for a given element, then a default
     * feature is found in the target.
     */
    private final Map elementsToMove;

    /**
     * The new container for the element to be moved.
     */
    private EObject targetContainer;

    /**
     * Constructs a new request to move a model element from one container to
     * another.
     * 
     * @@param editingDomain
     *            the editing domain in which I am requesting to make model
     * @@param targetContainer
     *            the target container
     * @@param targetFeature
     *            the target feature
     * @@param elementToMove
     *            the element to be moved
     */
    public MoveRequest(TransactionalEditingDomain editingDomain,
            EObject targetContainer, EReference targetFeature,
            EObject elementToMove) {

        super(editingDomain);
        this.targetContainer = targetContainer;
        this.elementsToMove = new HashMap();
        elementsToMove.put(elementToMove, targetFeature);
    }

    /**
     * Constructs a new request to move a model element from one container to
     * another.
     * 
     * @@param editingDomain
     *            the editing domain in which I am requesting to make model
     * @@param targetContainer
     *            the target container
     * @@param elementToMove
     *            the element to be moved.
     */
    public MoveRequest(TransactionalEditingDomain editingDomain,
            EObject targetContainer, EObject elementToMove) {

        this(editingDomain, targetContainer, null, elementToMove);
    }

    /**
     * Constructs a new request to move a collection of model element into a new
     * container. The features in the target used to contain the moved elements
     * will be derived as follows:
     * <UL>
     * <LI>If the feature fomerly containing the moved element exists in the
     * target element, it will be used.</LI>
     * <LI>Otherwise, the first feature in the target that can contain the
     * moved element will be used.</LI>
     * </UL>
     * 
     * @@param editingDomain
     *            the editing domain in which I am requesting to make model
     * @@param targetContainer
     *            the target container
     * @@param elementsToMove
     *            the list of <code>EObjects</code> to be moved.
     */
    public MoveRequest(TransactionalEditingDomain editingDomain,
            EObject targetContainer, List elementsToMove) {

        super(editingDomain);
        this.targetContainer = targetContainer;
        this.elementsToMove = new HashMap();

        for (Iterator i = elementsToMove.iterator(); i.hasNext();) {
            this.elementsToMove.put(i.next(), null);
        }
    }

    /**
     * Constructs a new request to move a collection of model element into
     * specific features of a new container.
     * 
     * @@param editingDomain
     *            the editing domain in which I am requesting to make model
     * @@param targetContainer
     *            the target container
     * @@param elementsToMove
     *            the map of <code>EObjects</code> to <code>EReference</code>
     *            features to be moved.
     */
    public MoveRequest(TransactionalEditingDomain editingDomain,
            EObject targetContainer, Map elementsToMove) {

        super(editingDomain);
        this.targetContainer = targetContainer;
        this.elementsToMove = elementsToMove;
    }

    /**
     * Constructs a new request to move a model element from one container to
     * another. The editing domain is derived from the
     * <code>targetContainer</code>.
     * 
     * @@param targetContainer
     *            the target container
     * @@param targetFeature
     *            the target feature
     * @@param elementToMove
     *            the element to be moved
     */
    public MoveRequest(EObject targetContainer, EReference targetFeature,
            EObject elementToMove) {

        this(TransactionUtil.getEditingDomain(targetContainer),
            targetContainer, targetFeature, elementToMove);
    }

    /**
     * Constructs a new request to move a model element from one container to
     * another. The editing domain is derived from the
     * <code>targetContainer</code>.
     * 
     * @@param targetContainer
     *            the target container
     * @@param elementToMove
     *            the element to be moved.
     */
    public MoveRequest(EObject targetContainer, EObject elementToMove) {

        this(TransactionUtil.getEditingDomain(targetContainer),
            targetContainer, null, elementToMove);
    }

    /**
     * Constructs a new request to move a collection of model element into a new
     * container. The features in the target used to contain the moved elements
     * will be derived as follows:
     * <UL>
     * <LI>If the feature fomerly containing the moved element exists in the
     * target element, it will be used.</LI>
     * <LI>Otherwise, the first feature in the target that can contain the
     * moved element will be used.</LI>
     * </UL>
     * <P>
     * The editing domain is derived from the <code>targetContainer</code>.
     * 
     * @@param targetContainer
     *            the target container
     * @@param elementsToMove
     *            the list of <code>EObjects</code> to be moved.
     */
    public MoveRequest(EObject targetContainer, List elementsToMove) {

        this(TransactionUtil.getEditingDomain(targetContainer),
            targetContainer, elementsToMove);
    }

    /**
     * Constructs a new request to move a collection of model element into
     * specific features of a new container. The editing domain is derived from
     * the <code>targetContainer</code>.
     * 
     * @@param targetContainer
     *            the target container
     * @@param elementsToMove
     *            the map of <code>EObjects</code> to <code>EReference</code>
     *            features to be moved.
     */
    public MoveRequest(EObject targetContainer, Map elementsToMove) {

        this(TransactionUtil.getEditingDomain(targetContainer),
            targetContainer, elementsToMove);
    }

    /**
     * Gets the map of elements to be moved. Each entry in the map consists of
     * an <code>EObject</code> key, which is the element to be moved to the
     * new target, and an <code>EReference</code> value, which is the feature
     * in the new target that should contain the moved element.
     * 
     * @@return the map of elements to be moved
     */
    public Map getElementsToMove() {
        return elementsToMove;
    }

    /**
     * Sets the container into which the element will be moved.
     * 
     * @@param targetContainer
     *            the target container
     */
    public void setTargetContainer(EObject targetContainer) {
        this.targetContainer = targetContainer;
    }

    /**
     * Gets the container into which the element will be moved.
     * 
     * @@return the container into which the element will be moved
     */
    public EObject getTargetContainer() {
        return targetContainer;
    }

    /**
     * Sets the reference feature into which an element should be moved.
     * 
     * @@param element
     *            the element to be moved
     * @@param targetFeature
     *            the target feature
     */
    public void setTargetFeature(EObject element, EReference targetFeature) {
        getElementsToMove().put(element, targetFeature);
    }

    /**
     * Gets the feature in the target element that should contain
     * <code>element</code> after it is moved.
     * 
     * @@param element
     *            the element to be moved
     * @@return the feature that will contain the element in the target
     */
    public EReference getTargetFeature(EObject element) {
        return (EReference) getElementsToMove().get(element);
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.IEditCommandRequest#getElementsToEdit()
     */
    public List getElementsToEdit() {

        if (targetContainer != null) {
            return Collections.singletonList(targetContainer);
        }

        return super.getElementsToEdit();
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditCommandRequest#getDefaultLabel()
     */
    protected String getDefaultLabel() {
        return EMFTypeCoreMessages.Request_Label_Move;
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.IEditCommandRequest#getEditHelperContext()
     */
    public Object getEditHelperContext() {
    	IClientContext context = getClientContext();
    	
    	if (context == null) {
    		return targetContainer;
    	} else {
    		return new EditHelperContext(targetContainer, context);
    	}
    }

}@


1.6
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d24 2
d312 7
a318 1
        return targetContainer;
@


1.5
log
@[112662] gmf_head ldamus 060123 MoveRequest should be able to deal with a list of elements
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d22 2
d42 2
a43 1
public class MoveRequest extends AbstractEditCommandRequest {
d45 267
a311 179
	/**
	 * The map of <code>EObject</code>s to be moved. Keyed on
	 * <code>EObject</code>. Each value is the <code>EReference</code>
	 * feature in the target element into which the element should be moved.
	 * <P>
	 * If the feature is not specified for a given element, then a default
	 * feature is found in the target.
	 */
	private final Map elementsToMove;

	/**
	 * The new container for the element to be moved.
	 */
	private EObject targetContainer;

	/**
	 * Constructs a new request to move a model element from one container to
	 * another.
	 * 
	 * @@param targetContainer
	 *            the target container
	 * @@param targetFeature
	 *            the target feature
	 * @@param elementToMove
	 *            the element to be moved
	 */
	public MoveRequest(EObject targetContainer, EReference targetFeature,
			EObject elementToMove) {

		super();
		this.targetContainer = targetContainer;
		this.elementsToMove = new HashMap();
		elementsToMove.put(elementToMove, targetFeature);
	}

	/**
	 * Constructs a new request to move a model element from one container to
	 * another.
	 * 
	 * @@param targetContainer
	 *            the target container
	 * @@param elementToMove
	 *            the element to be moved.
	 */
	public MoveRequest(EObject targetContainer, EObject elementToMove) {

		this(targetContainer, null, elementToMove);
	}

	/**
	 * Constructs a new request to move a collection of model element into a new
	 * container. The features in the target used to contain the moved elements
	 * will be derived as follows:
	 * <UL>
	 * <LI>If the feature fomerly containing the moved element exists in the
	 * target element, it will be used.</LI>
	 * <LI>Otherwise, the first feature in the target that can contain the
	 * moved element will be used.</LI>
	 * </UL>
	 * 
	 * @@param targetContainer
	 *            the target container
	 * @@param elementsToMove
	 *            the list of <code>EObjects</code> to be moved.
	 */
	public MoveRequest(EObject targetContainer, List elementsToMove) {

		super();
		this.targetContainer = targetContainer;
		this.elementsToMove = new HashMap();

		for (Iterator i = elementsToMove.iterator(); i.hasNext();) {
			this.elementsToMove.put(i.next(), null);
		}
	}

	/**
	 * Constructs a new request to move a collection of model element into
	 * specific features of a new container.
	 * 
	 * @@param targetContainer
	 *            the target container
	 * @@param elementsToMove
	 *            the map of <code>EObjects</code> to <code>EReference</code>
	 *            features to be moved.
	 */
	public MoveRequest(EObject targetContainer, Map elementsToMove) {

		super();
		this.targetContainer = targetContainer;
		this.elementsToMove = elementsToMove;
	}

	/**
	 * Gets the map of elements to be moved. Each entry in the map consists of
	 * an <code>EObject</code> key, which is the element to be moved to the
	 * new target, and an <code>EReference</code> value, which is the feature
	 * in the new target that should contain the moved element.
	 * 
	 * @@return the map of elements to be moved
	 */
	public Map getElementsToMove() {
		return elementsToMove;
	}

	/**
	 * Sets the container into which the element will be moved.
	 * 
	 * @@param targetContainer
	 *            the target container
	 */
	public void setTargetContainer(EObject targetContainer) {
		this.targetContainer = targetContainer;
	}

	/**
	 * Gets the container into which the element will be moved.
	 * 
	 * @@return the container into which the element will be moved
	 */
	public EObject getTargetContainer() {
		return targetContainer;
	}

	/**
	 * Sets the reference feature into which an element should be moved.
	 * 
	 * @@param element
	 *            the element to be moved
	 * @@param targetFeature
	 *            the target feature
	 */
	public void setTargetFeature(EObject element, EReference targetFeature) {
		getElementsToMove().put(element, targetFeature);
	}

	/**
	 * Gets the feature in the target element that should contain
	 * <code>element</code> after it is moved.
	 * 
	 * @@param element
	 *            the element to be moved
	 * @@return the feature that will contain the element in the target
	 */
	public EReference getTargetFeature(EObject element) {
		return (EReference) getElementsToMove().get(element);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.IEditCommandRequest#getElementsToEdit()
	 */
	public List getElementsToEdit() {

		if (targetContainer != null) {
			return Collections.singletonList(targetContainer);
		}

		return super.getElementsToEdit();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditCommandRequest#getDefaultLabel()
	 */
	protected String getDefaultLabel() {
		return EMFTypeCoreMessages.Request_Label_Move;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.IEditCommandRequest#getEditHelperContext()
	 */
	public Object getEditHelperContext() {
		return targetContainer;
	}
@


1.4
log
@[112662] gmf_head ldamus 060104 MoveRequest should be able to deal with a list of elements
@
text
@a135 21
	 * Gets the element to be moved.
	 * 
	 * @@return the element to be moved *
	 * @@deprecated The move request is now used to move more than one element at
	 *             a time. Use {@@link #getElementsToMove()} instead. Deprecated
	 *             on 12/22/2005 as per bugzilla
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=112662.
	 */
	public EObject getElementToMove() {
		// Assume that anyone using the deprecated API is using this request to
		// move a single element. Get the first (and presumed only) element in
		// the map.
		Iterator i = getElementsToMove().keySet().iterator();

		if (i.hasNext()) {
			return (EObject) i.next();
		}
		return null;
	}

	/**
a166 22
	 * Sets the reference feature into which the element should be moved.
	 * 
	 * @@param targetFeature
	 *            the target feature
	 * @@deprecated The move request is now used to move more than one element at
	 *             a time. Use {@@link #setTargetFeature(EObject, EReference)}
	 *             instead. Deprecated on 12/22/2005 as per bugzilla
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=112662.
	 */
	public void setTargetFeature(EReference targetFeature) {
		// Assume that anyone using the deprecated API is using this request to
		// move a single element. Set the first (and presumed only) feature in
		// the map.
		Iterator i = getElementsToMove().keySet().iterator();

		if (i.hasNext()) {
			Object key = i.next();
			getElementsToMove().put(key, targetFeature);
		}
	}

	/**
a178 21
	 * Gets the reference feature into which the element should be moved.
	 * 
	 * @@return the target feature
	 * @@deprecated The move request is now used to move more than one element at
	 *             a time. Use {@@link #getTargetFeature(EObject)} instead.
	 *             Deprecated on 12/22/2005 as per bugzilla
	 *             https://bugs.eclipse.org/bugs/show_bug.cgi?id=112662.
	 */
	public EReference getTargetFeature() {
		// Assume that anyone using the deprecated API is using this request to
		// move a single element. Return the first (and presumed only) feature
		// in the map.
		Iterator i = getElementsToMove().values().iterator();

		if (i.hasNext()) {
			return (EReference) i.next();
		}
		return null;
	}

	/**
@


1.3
log
@[120871] gmf_head ldamus 051222 org.eclipse.gmf.runtime.emf.type.core needs NLS sweep
@
text
@d15 2
d18 1
a21 1

d25 12
a36 2
 * Request to move a model element from one container to another or from one
 * reference feature to another.
d40 1
a40 2
public class MoveRequest
	extends AbstractEditCommandRequest {
d43 6
a48 1
	 * The element to be moved.
d50 1
a50 1
	private EObject elementToMove;
a57 5
	 * The new reference feature into which the element should be moved.
	 */
	private EReference targetFeature;

	/**
a71 1
		this.elementToMove = elementToMove;
d73 2
a74 1
		this.targetFeature = targetFeature;
d92 44
d138 5
a142 1
	 * @@return the element to be moved
d145 21
a165 1
		return elementToMove;
d192 4
d198 21
a218 1
		this.targetFeature = targetFeature;
d225 4
d231 21
a251 1
		return targetFeature;
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d20 1
a20 1
import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.ResourceManager;
d147 1
a147 1
		return ResourceManager.getInstance().getString("Request.Label.Move"); //$NON-NLS-1$
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

