head	1.16;
access;
symbols
	v20081020-0700:1.16
	v20080807-1333:1.16
	v20080807-1325:1.16
	v20080731-1520:1.16
	v20080725-1738:1.16
	v20080722-1827:1.16
	R2_1_maintenance:1.16.0.4
	Root_R2_1_maintenance:1.16
	R2_1_0:1.16
	v20080425-1959:1.16
	v20080328-1605:1.16
	v20080222-1200:1.16
	v20080114-2222:1.16
	v20080107-1111:1.16
	v20071130-1111:1.16
	v20071124-0000:1.16
	v20070809-0000:1.16
	R2_0_maintenance:1.16.0.2
	R2_0:1.16
	R4_20:1.16
	RC3_20:1.16
	v20070601-1400:1.16
	v20070518-1300:1.16
	v20070403-1500:1.16
	v20070330-1300:1.16
	v20070208-1800:1.16
	M4_20:1.16
	v20061214-0000:1.16
	M3_20:1.16
	v20061117-0800:1.16
	v20061013-1330:1.15
	v20060919-0800:1.14.2.3
	v20060907-1100:1.14.2.3
	M1_20:1.14
	v20060831-1500:1.14.2.2
	v20060817-1500:1.14.2.2
	v20060803-1200:1.14.2.2
	v20060721-1130:1.14.2.1
	v20060713-1700:1.14.2.1
	R1_0_maintenance:1.14.0.2
	R1_0:1.14
	v20060627-1200:1.14
	v20060616-1200:1.14
	v20060609-1400:1.14
	v20060531-1730:1.12
	v20060530-1930:1.12
	v20060526-1200:1.12
	v20060519-0800:1.11
	I20060505-1400:1.11
	I20060428-1300:1.11
	I20060424-0500:1.10
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.8
	I20060331-1000:1.8
	I20060324-0300:1.8
	I20060317-1300:1.7
	I20060317-1200:1.7
	I20060316-1300:1.7
	I20060309-1300:1.7
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.4;
locks; strict;
comment	@# @;


1.16
date	2006.10.23.17.45.52;	author ldamus;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.03.15.06.37;	author ahunter;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.08.20.35.54;	author ldamus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2006.06.01.18.56.51;	author ldamus;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.25.21.36.03;	author ldamus;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.26.20.14.33;	author ldamus;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.20.21.27.48;	author ashatalin;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.20.20.36.57;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.20.20.57.33;	author ldamus;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.09.23.49.14;	author ldamus;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.07.02.40.34;	author ldamus;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.22.19.02.01;	author ldamus;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.13.20.45.51;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.06.19.15.31;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.26.55;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.45;	author sshaw;	state Exp;
branches;
next	;

1.14.2.1
date	2006.07.07.16.03.53;	author ldamus;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2006.08.02.19.31.25;	author ldamus;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2006.09.01.13.46.31;	author ldamus;	state Exp;
branches;
next	;


desc
@@


1.16
log
@[157788] gmf_head ldamus 061023 ElementTypeRegistry fails to load element type in some particular case
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.type.core;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.dynamichelpers.ExtensionTracker;
import org.eclipse.core.runtime.dynamichelpers.IExtensionChangeHandler;
import org.eclipse.core.runtime.dynamichelpers.IExtensionTracker;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.emf.type.core.edithelper.IEditHelperAdvice;
import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePlugin;
import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePluginStatusCodes;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.ElementTypeDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.ElementTypeFactoryDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.ElementTypeXmlConfig;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.MetamodelDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.MetamodelTypeDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.SpecializationTypeDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.impl.DefaultMetamodelType;
import org.eclipse.gmf.runtime.emf.type.core.internal.impl.SpecializationTypeRegistry;
import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.EMFTypeCoreMessages;

/**
 * The registry of application element types, contributed by the
 * <code>org.eclipse.gmf.runtime.emf.type.core.elementTypes</code> extension
 * point, or registered directly through {@@link #register(IMetamodelType)} or
 * {@@link #register(ISpecializationType)}.
 * 
 * @@author ldamus
 */
public class ElementTypeRegistry {

	/**
	 * The name of the element type extension point.
	 */
	private static final String ELEMENT_TYPES_EXT_P_NAME = "elementTypes"; //$NON-NLS-1$

	/**
	 * Empty element type array for convenience.
	 */
	private static final IElementType[] EMPTY_ELEMENT_TYPE_ARRAY = new IElementType[] {};

	/**
	 * My specialization type registr. Keeps track of the specializations and
	 * advice bindings and provides methods for finding matching edit helper
	 * advice.
	 */
	private final SpecializationTypeRegistry specializationTypeRegistry;

	/**
	 * Metamodel type descriptors stored by nsURI. Each key is a namespace URI
	 * and each value is a map, whose key is an EClass name and whose value is a
	 * collection of MetamodelTypeDescriptors.
	 */
	private final Map metamodelTypeDescriptorsByNsURI;

	/**
	 * All metamodel type descriptors stored by ID. Each value is an instance of
	 * <code>MetamodelTypeDescriptor</code>.
	 */
	private final Map metamodelTypeDescriptorsById;

	/**
	 * ElementTypeFactories stored by kind. Each factory declares a string that
	 * describes the kind of element that it is responsible for creating. Each
	 * value is a single <code>ElementTypeFactory</code>.
	 */
	private final Map elementTypeFactoryMap;

	/**
	 * Listeners for changes to this registry.
	 */
	private final List elementTypeRegistryListeners;

	/**
	 * Singleton instance.
	 */
	private static ElementTypeRegistry INSTANCE;

	private ExtensionTracker extensionTracker;
	
	private IExtensionChangeHandler extensionListener;

	/**
	 * Constructs a new element type registry.
	 */
	private ElementTypeRegistry(IConfigurationElement[] configs) {
		super();

		specializationTypeRegistry = new SpecializationTypeRegistry();
		metamodelTypeDescriptorsByNsURI = new HashMap();
		metamodelTypeDescriptorsById = new HashMap();
		elementTypeFactoryMap = new HashMap();
		elementTypeRegistryListeners = new ArrayList();

		registerNullElementType();

		if (EMFTypePlugin.isDynamicAware()) {
			startExtensionTracking();
		}
		
		load(configs);
	}

	private void startExtensionTracking() {
		extensionListener = new IExtensionChangeHandler() {
			
			public void addExtension(IExtensionTracker tracker,
					IExtension extension) {
				load(extension.getConfigurationElements());
			}

			public void removeExtension(IExtension extension, Object[] objects) {
				// Extension removal not supported
			}
		};
		
		IExtensionPoint point = Platform.getExtensionRegistry()
				.getExtensionPoint(EMFTypePlugin.getPluginId(),
						ELEMENT_TYPES_EXT_P_NAME);
		
		extensionTracker = new ExtensionTracker();
		extensionTracker.registerHandler(extensionListener, ExtensionTracker
				.createExtensionPointFilter(point));
	}

	/**
	 * Gets the singleton element type registry.
	 * 
	 * @@return the singleton element type registry
	 */
	public static ElementTypeRegistry getInstance() {

		if (INSTANCE == null) {

			IConfigurationElement[] configs = Platform.getExtensionRegistry()
				.getConfigurationElementsFor(EMFTypePlugin.getPluginId(),
					ELEMENT_TYPES_EXT_P_NAME);

			INSTANCE = new ElementTypeRegistry(configs);
		}
		return INSTANCE;
	}

	/**
	 * Gets the edit helper advice for <code>type</code> in order of most
	 * general advice to most specific advice. This order is used so that the
	 * more specific advice can act on or modify the more general advice.
	 * <P>
	 * The client context is inferred from the <code>type</code>.
	 * 
	 * @@param type
	 *            the element type for which to obtain editing advice
	 * @@return the array of edit helper advice descriptors
	 */
	public IEditHelperAdvice[] getEditHelperAdvice(IElementType type) {
		
		IClientContext clientContext = ClientContextManager.getInstance()
				.getBinding(type);

		return getEditHelperAdvice(type, clientContext);
	}

	/**
	 * Gets the edit helper advice for <code>type</code> to which the
	 * <code>clientContext</code> has been bound, in order of most general
	 * advice to most specific advice. This order is used so that the more
	 * specific advice can act on or modify the more general advice.
	 * 
	 * @@param type
	 *            the element type for which to obtain editing advice
	 * @@param clientContext
	 *            the client context
	 * @@return the array of edit helper advice descriptors
	 */
	public IEditHelperAdvice[] getEditHelperAdvice(IElementType type, IClientContext clientContext) {
		
		IClientContext context = (clientContext == null) ? ClientContextManager
				.getDefaultClientContext() : clientContext;

		EClass eClass = type.getEClass();
		MetamodelTypeDescriptor metamodelType = (eClass != null) ? getMetamodelTypeDescriptor(
				eClass, context)
				: null;
		List result = specializationTypeRegistry.getEditHelperAdvice(type,
				metamodelType, context);

		return (IEditHelperAdvice[]) result.toArray(new IEditHelperAdvice[] {});
	}
	
	/**
	 * Gets the edit helper advice for <code>eObject</code> in order of most
	 * general advice to most specific advice. This order is used so that the
	 * more specific advice can act on or modify the more general advice.
	 * 
	 * @@param eObject
	 *            the model element for which to obtain editing advice
	 * @@param clientContext
	 *            the client context
	 * @@return the array of edit helper advice
	 */
	public IEditHelperAdvice[] getEditHelperAdvice(EObject eObject,
			IClientContext clientContext) {

		Collection result;
		MetamodelTypeDescriptor desc = getMetamodelTypeDescriptor(eObject, clientContext);
		if (desc == null) {
			result = specializationTypeRegistry.getEditHelperAdvice(
					eObject,
					DefaultMetamodelType.getDescriptorInstance(), clientContext);
		} else {
			result = specializationTypeRegistry.getEditHelperAdvice(eObject, desc, clientContext);
		}

		return (IEditHelperAdvice[]) result.toArray(new IEditHelperAdvice[] {});
	}
	
	/**
	 * Gets the edit helper advice for <code>eObject</code> in order of most
	 * general advice to most specific advice. This order is used so that the
	 * more specific advice can act on or modify the more general advice.
	 * <P>
	 * The client context will be inferred from the <code>eObject</code>.
	 * 
	 * @@param eObject
	 *            the model element for which to obtain editing advice
	 * @@return the array of edit helper advice
	 */
	public IEditHelperAdvice[] getEditHelperAdvice(EObject eObject) {
	
		IClientContext clientContext = ClientContextManager.getInstance()
				.getClientContextFor(eObject);
		
		return getEditHelperAdvice(eObject, clientContext);
	}

	/**
	 * Gets the edit helper advice registered for <code>o</code>, which can
	 * be either an EObject or an IElementType or an
	 * <code>IEditHelperContext</code>.
	 * 
	 * @@param o
	 *            the element or type
	 * @@return the edit helper advice, or <code>null</code> if none.
	 */
	public IEditHelperAdvice[] getEditHelperAdvice(Object o) {
		
		if (o instanceof EObject) {
			return getEditHelperAdvice((EObject) o);

		} else if (o instanceof IElementType) {
			return getEditHelperAdvice((IElementType) o);

		} else if (o instanceof IEditHelperContext) {
			IEditHelperContext editHelperContext = (IEditHelperContext) o;
			IClientContext clientContext = editHelperContext.getClientContext();
			IElementType elementType = editHelperContext.getElementType();
			EObject eObject = editHelperContext.getEObject();

			if (clientContext != null) {
				if (elementType != null) {
					return getEditHelperAdvice(elementType, clientContext);

				} else if (eObject != null) {
					return getEditHelperAdvice(eObject, clientContext);
				}
			} else {
				if (elementType != null) {
					return getEditHelperAdvice(elementType);

				} else if (eObject != null) {
					return getEditHelperAdvice(eObject);
				}
			}
		}
		return null;
	}
	
	/**
	 * Gets the array of types that can be contained in the structural
	 * <code>feature</code> of <code>eContainer</code>. The result will not
	 * include types that represent abstract EClasses.
	 * 
	 * @@param eContainer
	 *            the container
	 * @@param reference
	 *            the feature
	 * @@param clientContext
	 *            the client context
	 * @@return the array of types
	 */
	public IElementType[] getContainedTypes(EObject eContainer,
			EReference reference, IClientContext clientContext) {
		
		Set result = new HashSet();

		EClass containerEClass = eContainer.eClass();

		if (reference.isContainment()
			&& (containerEClass.getEAllReferences().contains(reference))) {

			// Get the reference type (eclass) and all of its subtypes
			EClass eType = (EClass) reference.getEType();
			Set types = getSubtypes(containerEClass.getEPackage(), eType);
			types.add(eType);

			// Get the metamodel types for the eclasses
			List metamodelTypeDescriptors = getMetamodelTypeDescriptors(types, clientContext);
			
			for (Iterator i = metamodelTypeDescriptors.iterator(); i.hasNext();) {

				MetamodelTypeDescriptor nextMetamodelTypeDescriptor = (MetamodelTypeDescriptor) i
					.next();
				IMetamodelType nextMetamodelType = (IMetamodelType) nextMetamodelTypeDescriptor
					.getElementType();

				if (nextMetamodelType != null
					&& !nextMetamodelType.getEClass().isAbstract()) {

					// Add the metamodel type
					result.add(nextMetamodelType);

					// Add the specialization types that match the given
					// container and reference
					Collection specializationDescriptors = specializationTypeRegistry
						.getMatchingSpecializations(
							nextMetamodelTypeDescriptor, eContainer, reference, clientContext);

					for (Iterator j = specializationDescriptors.iterator(); j
						.hasNext();) {
						ElementTypeDescriptor nextDescriptor = (ElementTypeDescriptor) j
							.next();
						IElementType nextElementType = nextDescriptor
							.getElementType();

						if (nextElementType != null) {
							result.add(nextElementType);
						}
					}
				}
			}
		}
		return (IElementType[]) result.toArray(EMPTY_ELEMENT_TYPE_ARRAY);
	}

	/**
	 * Gets the array of types that can be contained in the structural
	 * <code>feature</code> of <code>eContainer</code>.  The result will 
	 * not include types that represent abstract EClasses.
	 * <P>
	 * The client context will be inferred from the <code>eContainer</code>.
	 * 
	 * @@param eContainer
	 *            the container
	 * @@param reference
	 *            the feature
	 * @@return the array of types
	 */
	public IElementType[] getContainedTypes(EObject eContainer,
			EReference reference) {

		IClientContext clientContext = ClientContextManager.getInstance()
				.getClientContextFor(eContainer);
		
		return getContainedTypes(eContainer, reference, clientContext);
	}

	/**
	 * Gets the subtypes of <code>eType</code> in the <code>pkg</code>.
	 * 
	 * @@param pkg
	 *            the package in which to find matching classifiers
	 * @@param eType
	 *            the eClass for which to find subtypes
	 * @@return the matching subtypes
	 */
	private Set getSubtypes(EPackage pkg, final EClass eType) {

		Set result = new HashSet();
		List classifiers = pkg.getEClassifiers();

		for (Iterator i = classifiers.iterator(); i.hasNext();) {
			EClassifier nextClassifier = (EClassifier) i.next();

			if (nextClassifier instanceof EClass
				&& ((EClass) nextClassifier).getEAllSuperTypes()
					.contains(eType)) {
				result.add(nextClassifier);
			}
		}
		return result;
	}

	/**
	 * Gets the metamodel type for <code>eClass</code> in the client
	 * <code>context</code>. If there is none registered against the
	 * <code>eClass</code>, returns the metamodel type for the nearest
	 * supertype of <code>eClass/code> that has a metamodel type.
	 * 
	 * @@param eClass
	 *            the metaclass
	 * @@param context the client context
	 * @@return the metamodel type for this <code>eClass</code> in the client <code>context</code>, or <code>null</code> if none can be found.
	 */
	private IMetamodelType getMetamodelType(EClass eClass, IClientContext context) {
		
		MetamodelTypeDescriptor descriptor = getMetamodelTypeDescriptor(eClass, context);

		if (descriptor != null) {
			return (IMetamodelType) descriptor.getElementType();
		}
		return null;
	}

	/**
	 * Gets the metamodel type registered for <code>eObject</code>'s EClass.
	 * If there is none registered against the <code>eClass</code>, returns
	 * the metamodel type for the nearest supertype of
	 * <code>eClass/code> that has a metamodel type.
	 * 
	 * @@param eObject
	 *            the model element
	 * @@param clientContext the clientContext
	 * @@return the metamodel type for this <code>eObject</code>
	 */
	private IMetamodelType getMetamodelType(EObject eObject, IClientContext clientContext) {
		
		return getMetamodelType(eObject.eClass(), clientContext);
	}

	/**
	 * Convenience method to get an element type for <code>o</code>.
	 * <P>
	 * If <code>o</code> is an <code>IElementType</code>, returns
	 * <code>o</code>.
	 * <P>
	 * If <code>o</code> is an <code>EObject</code>, returns the metamodel
	 * type registered for <code>o</code>'s eClass in the client context that
	 * is bound to <code>o</code>.
	 * <P>
	 * If <code>o</code> is an <code>IEditHelperContext</code>, returns the
	 * element type in <code>o</code> if specified. Else, returns the
	 * metamodel type registered for the eClass of the EObject specified in
	 * <code>o</code> in the client context specified in <code>o</code>. If
	 * no client context is specified, then the client context bound to the
	 * EObject is used.
	 * <P>
	 * Use {@@link #getElementType(EClass, IClientContext)} to get metamodel
	 * types registered for a specific <code>EClass</code>.
	 * 
	 * @@param o
	 *            the object for which to find an element type.
	 * @@return <code>o</code> itself if it is an element type, otherwise
	 *         returns the registered metamodel type
	 */
	public IElementType getElementType(Object o) {

		if (o instanceof EObject) {
			return getElementType((EObject) o);

		} else if (o instanceof IElementType) {
			return (IElementType) o;
			
		} else if (o instanceof IEditHelperContext) {
			IEditHelperContext editHelperContext = (IEditHelperContext) o;
			IElementType elementType = editHelperContext.getElementType();
			
			if (elementType != null) {
				return elementType;
			}
			
			IClientContext clientContext = editHelperContext.getClientContext();
			EObject eObject = editHelperContext.getEObject();

			if (eObject != null) {
				if (clientContext != null) {
					return getElementType(eObject, clientContext);
				} else {
					return getElementType(eObject);
				}
			}
		}
		
		return null;
	}
	
	/**
	 * Gets the registered element type for <code>eClass</code> that 
	 * has no client contexts explicitly bound to it.
	 * 
	 * @@param eClass
	 *            the <code>EClass</code> whose element type is to be found.
	 * @@return the metamodel type registered for <code>eClass</code>
	 */
	public IElementType getElementType(EClass eClass) {

		return getElementType(eClass, null);
	}
	
	/**
	 * Gets the registered element type for <code>eClass</code>.
	 * 
	 * @@param eClass
	 *            the <code>EClass</code> whose element type is to be found.
	 * @@param clientContext
	 *            the client context
	 * @@return the metamodel type registered for <code>eClass</code>
	 */
	public IElementType getElementType(EClass eClass, IClientContext clientContext) {

		IElementType result = getMetamodelType(eClass, clientContext);
		if (result == null) {
			// at least provide the default type for default editing support
			result = DefaultMetamodelType.getInstance();
		}
		
		return result;
	}
	
	/**
	 * Gets the registered element type for <code>eObject</code>.
	 * <P>
	 * The client context will be inferred from the <code>eObject</code>.
	 * 
	 * @@param eObject
	 *            the <code>EObject</code> whose element type is to be found.
	 * @@return the metamodel type registered for <code>eObject</code>'s
	 *         <code>EClass</code>
	 */
	public IElementType getElementType(EObject eObject) {
		
		IClientContext clientContext = ClientContextManager.getInstance()
				.getClientContextFor(eObject);
		
		return getElementType(eObject, clientContext);
	}
	
	/**
	 * Gets the registered element type for <code>eObject</code> in the
	 * <code>clientContext</code>.
	 * 
	 * @@param eObject
	 *            the <code>EObject</code> whose element type is to be found.
	 * @@param clientContext
	 *            the client context
	 * @@return the metamodel type registered for <code>eObject</code>'s
	 *         <code>EClass</code>
	 */
	public IElementType getElementType(EObject eObject,
			IClientContext clientContext) {

		IElementType result = getMetamodelType(eObject, clientContext);
		if (result == null) {
			// at least provide the default type for default editing support
			result = DefaultMetamodelType.getInstance();
		}

		return result;
	}

	/**
	 * Gets the metamodel type descriptor for <code>eObject</code>'s EClass
	 * in the client <code>context</code>. If there is none registered
	 * against the <code>eClass</code> for that <code>context</code>,
	 * returns the metamodel type for the nearest supertype of
	 * <code>eClass</code> that has a metamodel type in that
	 * <code>context</code>.
	 * 
	 * @@param eObject
	 *            the model element
	 * @@param context
	 *            the client context
	 * @@return the metamodel type descriptor
	 */
	private MetamodelTypeDescriptor getMetamodelTypeDescriptor(EObject eObject,
			IClientContext context) {
		return getMetamodelTypeDescriptor(eObject.eClass(), context);
	}

	/**
	 * Gets the metamodel type descriptor for <code>eClass</code> in the
	 * client <code>context</code>. If there is none registered against the
	 * <code>eClass</code> for the client <code>context</code>, returns the
	 * metamodel type for the nearest supertype of <code>eClass</code> that
	 * has a metamodel type in the client <code>context</code>.
	 * 
	 * @@param eClass
	 *            the model element eclass
	 * @@param context
	 *            the client context
	 * @@return the metamodel type descriptor
	 */
	private MetamodelTypeDescriptor getMetamodelTypeDescriptor(EClass eClass,
			IClientContext context) {

		IClientContext clientContext = context;

		if (clientContext == null) {
			// use the default context
			clientContext = ClientContextManager.getDefaultClientContext();
		}
		
		Map metamodelTypeDescriptorsByEClass = (Map) metamodelTypeDescriptorsByNsURI
				.get(eClass.getEPackage().getNsURI());
		Collection descriptors = metamodelTypeDescriptorsByEClass != null ? (Collection) metamodelTypeDescriptorsByEClass
				.get(eClass.getName())
				: null;

		if (descriptors != null) {
			for (Iterator i = descriptors.iterator(); i.hasNext();) {
				MetamodelTypeDescriptor descriptor = (MetamodelTypeDescriptor) i
						.next();
	
				if (clientContext.includes(descriptor)) {
					return descriptor;
				}
			}
		} 
		// Find the metamodel type for the nearest supertype.
		List supertypes = eClass.getEAllSuperTypes();
		for (int i = supertypes.size() - 1; i >= 0; i--) {
			EClass nextEClass = (EClass) supertypes.get(i);

			// nsURI could be different in supertypes of the eclass
			metamodelTypeDescriptorsByEClass = (Map) metamodelTypeDescriptorsByNsURI.get(nextEClass.getEPackage().getNsURI());
			descriptors = metamodelTypeDescriptorsByEClass != null ? (Collection) metamodelTypeDescriptorsByEClass
					.get(nextEClass.getName())
					: null;

			if (descriptors != null) {
				for (Iterator j = descriptors.iterator(); j.hasNext();) {
					MetamodelTypeDescriptor descriptor = (MetamodelTypeDescriptor) j
							.next();
	
					if (clientContext.includes(descriptor)) {
						return descriptor;
					}
				}
			}
		}
		return null;
	}
	
	/**
	 * Gets all of the element types (metamodel type and specialization types)
	 * that match <code>eObject</code> in breadth-first order (specializations
	 * before metamodel types).
	 * 
	 * @@param eObject
	 *            the model element to match
	 * @@param clientContext
	 *            the client context
	 * @@return all of the element types that match the model element
	 */
	public IElementType[] getAllTypesMatching(EObject eObject, IClientContext clientContext) {
		
		List result = new ArrayList();
		IMetamodelType metamodelType = getMetamodelType(eObject, clientContext);

		if (metamodelType != null) {

			// Get the matching specializations
			Collection specializations;
			MetamodelTypeDescriptor desc = getMetamodelTypeDescriptor(eObject, clientContext);
			if (desc == null) {
				specializations = Collections.EMPTY_LIST;
			} else {
				specializations = specializationTypeRegistry
					.getSpecializationDescriptorsMatching(eObject, desc, clientContext);
			}

			for (Iterator i = specializations.iterator(); i.hasNext();) {
				SpecializationTypeDescriptor next = (SpecializationTypeDescriptor) i
					.next();
				IElementType elementType = next.getElementType();
				if (elementType != null) {
					result.add(elementType);
				}
			}
			// Add the metamodel type
			result.add(metamodelType);

			// Add the metamodel supertypes in reverse order
			IElementType[] superTypes = metamodelType.getAllSuperTypes();

			for (int i = superTypes.length - 1; i >= 0; i--) {
				result.add(superTypes[i]);
			}
		}
		
		if (result.isEmpty()) {
			// at least provide the default type for default editing behaviour
			result.add(DefaultMetamodelType.getInstance());
		}
		
		return (IElementType[]) result.toArray(EMPTY_ELEMENT_TYPE_ARRAY);
	}

	/**
	 * Gets all of the element types (metamodel type and specialization types)
	 * that match <code>eObject</code> in breadth-first order (specializations
	 * before metamodel types).
	 * <P>
	 * The client context will be inferred from the <code>eObject</code>.
	 * 
	 * @@param eObject
	 *            the model element to match
	 * @@return all of the element types that match the model element
	 */
	public IElementType[] getAllTypesMatching(EObject eObject) {

		IClientContext clientContext = ClientContextManager.getInstance()
				.getClientContextFor(eObject);
		
		return getAllTypesMatching(eObject, clientContext);
	}
	
	/**
	 * Gets an array containing all specializations of the element type for
	 * <code>id</code>, in breadth-first order.
	 * 
	 * @@param id
	 *            the element type ID
	 * @@return the list of all specializations of this element type
	 */
	public ISpecializationType[] getSpecializationsOf(String id) {
		
		IElementTypeDescriptor descriptor = getTypeDescriptor(id);
		
		if (descriptor == null) {
			return new ISpecializationType[] {};
		}
		
		IClientContext clientContext = ClientContextManager.getInstance()
				.getBinding(descriptor);

		return specializationTypeRegistry
				.getAllSpecializationTypes(descriptor, clientContext);
	}
	
	/**
	 * Gets the metamodel types in the registry that are bound to the
	 * <code>clientContext</code>.
	 * 
	 * @@param clientContext
	 *            the client context
	 * @@return the metamodel types
	 */
	public IMetamodelType[] getMetamodelTypes(IClientContext clientContext) {

		List result = new ArrayList();
		for (Iterator i = metamodelTypeDescriptorsById.values().iterator(); i
				.hasNext();) {
			MetamodelTypeDescriptor descriptor = (MetamodelTypeDescriptor) i
					.next();

			if (clientContext.includes(descriptor)) {
				result.add(descriptor.getElementType());
			}
		}

		return (IMetamodelType[]) result.toArray(new IMetamodelType[result.size()]);
	}
	
	/**
	 * Gets the specialization types in the registry that are bound to the
	 * <code>clientContext</code>.
	 * 
	 * @@param clientContext
	 *            the client context
	 * @@return the specialization types
	 */
	public ISpecializationType[] getSpecializationTypes(
			IClientContext clientContext) {

		List result = new ArrayList();
		Collection specializations = specializationTypeRegistry
				.getSpecializationTypeDescriptors(clientContext);
		
		for (Iterator i = specializations.iterator(); i.hasNext();) {
			result.add(((SpecializationTypeDescriptor) i.next())
					.getElementType());
		}

		return (ISpecializationType[]) result.toArray(new ISpecializationType[result.size()]);
	}
	
	/**
	 * Gets the element types (both metamodel types and specialization types) in
	 * the registry that are bound to the <code>clientContext</code>.
	 * 
	 * @@param clientContext
	 *            the client context
	 * @@return the element types
	 */
	public IElementType[] getElementTypes(IClientContext clientContext) {

		IMetamodelType[] metamodelTypes = getMetamodelTypes(clientContext);
		ISpecializationType[] specializationTypes = getSpecializationTypes(clientContext);

		IElementType[] result = new IElementType[metamodelTypes.length
				+ specializationTypes.length];
		
		for (int i = 0; i < metamodelTypes.length; i++) {
			result[i] = metamodelTypes[i];
		}
		
		for (int i = 0; i < specializationTypes.length; i++) {
			result[i + metamodelTypes.length] = specializationTypes[i];
		}
		return result;
	}

	/**
	 * Gets the element type for <code>id</code>. May return
	 * <code>null</code> if this element is not registered.
	 * 
	 * @@param id
	 *            the type ID
	 * @@return the registered type with this ID, or <code>null</code> if there
	 *         is none.
	 */
	public IElementType getType(String id) {

		ElementTypeDescriptor typeDescriptor = getTypeDescriptor(id);

		if (typeDescriptor != null) {
			return typeDescriptor.getElementType();
		} else if (DefaultMetamodelType.ID.equals(id)) {
			return DefaultMetamodelType.getInstance();
		}
		return null;
	}

	/**
	 * Gets the element type factory registered to create element types of kind
	 * <code>kindName</code>.
	 * 
	 * @@param kindName
	 *            the element type kind name
	 * @@return the element type factory for this kind, or
	 *         <code>null/code> if there is none
	 */
	public IElementTypeFactory getElementTypeFactory(String kindName) {
		ElementTypeFactoryDescriptor descriptor = (ElementTypeFactoryDescriptor) elementTypeFactoryMap
			.get(kindName);
		if (descriptor != null) {
			return descriptor.getElementTypeFactory();
		}
		return null;
	}

	/**
	 * Registers <code>metamodelType</code> with this registry, if its ID is
	 * unique in the registry. The type's EClass does not have to be unique in
	 * the registry. Metamodel types in the registry are distinguished by the
	 * client context that is bound to the type.
	 * <P>
	 * Notifies clients if the element type was added to the registry.
	 * 
	 * @@param metamodelType
	 *            the element type to register
	 * @@return <code>true</code> if the type was registered,
	 *         <code>false</code> otherwise
	 */
	public boolean register(IMetamodelType metamodelType) {

		if (metamodelType == null
			|| getType(metamodelType.getId()) != null) {

			return false;
		}

		MetamodelTypeDescriptor descriptor = new MetamodelTypeDescriptor(
			metamodelType);

		boolean result = register(descriptor);

		if (result) {
			fireElementTypeAddedEvent(new ElementTypeAddedEvent(
				metamodelType.getId()));
		}

		return result;
	}

	/**
	 * Registers <code>specializationType</code> with this registry, if its ID
	 * is unique in the registry.
	 * <P>
	 * Notifies clients if the element type was added to the registry.
	 * 
	 * @@param specializationType
	 *            the element type to register
	 * @@return <code>true</code> if the type was registered,
	 *         <code>false</code> otherwise
	 */
	public boolean register(ISpecializationType specializationType) {

		if (specializationType == null
			|| getType(specializationType.getId()) != null) {

			return false;
		}

		boolean result = specializationTypeRegistry
			.registerSpecializationType(specializationType);

		if (result) {
			fireElementTypeAddedEvent(new ElementTypeAddedEvent(
				specializationType.getId()));
		}

		return result;
	}

	/**
	 * Removes specialization types from the registry that specialize more than
	 * one metamodel type, or do not specialize any metamodel type.
	 * <P>
	 * Logs an error when an invalid specialization is found.
	 */
	private void removeInvalidSpecializations() {

		List specializationsToReject = new ArrayList();

		Collection specializationTypes = specializationTypeRegistry
			.getSpecializationTypeDescriptors();

		for (Iterator i = specializationTypes.iterator(); i.hasNext();) {
			SpecializationTypeDescriptor nextSpecialization = (SpecializationTypeDescriptor) i
				.next();
			MetamodelTypeDescriptor metamodelTypeDescriptor = getMetamodelTypeDescriptor(nextSpecialization);

			if (metamodelTypeDescriptor == null) {
				specializationsToReject.add(nextSpecialization);
			}
		}

		for (Iterator i = specializationsToReject.iterator(); i.hasNext();) {
			specializationTypeRegistry
				.removeSpecializationType((SpecializationTypeDescriptor) i
					.next());
		}
	}

	/**
	 * Loads the metamodel element <code>configElement</code>.
	 * 
	 * @@param configElement
	 *            the configuration element
	 * @@throws CoreException
	 *             on any problem accessing a configuration element
	 */
	private void loadMetamodel(IConfigurationElement configElement)
		throws CoreException {

		MetamodelDescriptor descriptor = new MetamodelDescriptor(configElement);

		IConfigurationElement[] typeConfigs = configElement.getChildren();

		for (int i = 0; i < typeConfigs.length; i++) {
			IConfigurationElement next = typeConfigs[i];

			String name = next.getName();
			if (name.equals(ElementTypeXmlConfig.E_METAMODEL_TYPE)) {
				registerMetamodelType(next, descriptor);

			} else if (name.equals(ElementTypeXmlConfig.E_SPECIALIZATION_TYPE)) {
				registerSpecializationType(next, descriptor);

			} else if (name.equals(ElementTypeXmlConfig.E_ADVICE_BINDING)) {
				specializationTypeRegistry.registerAdviceBinding(next,
					descriptor);
			}
		}
	}

	/**
	 * Registers the metamodel element type described by
	 * <code>configElement</code>.
	 * 
	 * @@param configElement
	 *            the configutation element
	 * @@param metamodelDescriptor
	 *            the descriptor for the metamodel containing the EClass for the
	 *            new element type
	 * 
	 * @@throws CoreException
	 *             on any problem accessing a configuration element
	 */
	private void registerMetamodelType(IConfigurationElement configElement,
			MetamodelDescriptor metamodelDescriptor)
		throws CoreException {

		MetamodelTypeDescriptor descriptor = new MetamodelTypeDescriptor(
			configElement, metamodelDescriptor);
		register(descriptor);

	}

	/**
	 * Registers the specialization element type described by
	 * <code>configElement</code>.
	 * 
	 * @@param configElement
	 *            the configutation element
	 * @@param metamodelDescriptor
	 *            the descriptor for the metamodel containing the EClass for the
	 *            new element type
	 * 
	 * @@throws CoreException
	 *             on any problem accessing a configuration element
	 */
	private SpecializationTypeDescriptor registerSpecializationType(
			IConfigurationElement configElement,
			MetamodelDescriptor metamodelDescriptor)
		throws CoreException {

		return specializationTypeRegistry.registerSpecializationType(
			configElement, metamodelDescriptor);
	}

	/**
	 * Adds the metamodel <code>type</code> to this registry. Logs an error if
	 * a metamodel type has already been registered for the same ID.
	 * 
	 * @@param typeDescriptor
	 *            the descriptor of the type to be added.
	 * @@return <code>true</code> if the type was added, <code>false</code>
	 *         otherwise.
	 */
	private boolean register(MetamodelTypeDescriptor typeDescriptor) {

		if (checkForDuplicate(typeDescriptor)) {
			return false;
		}
		
		String nsURI = typeDescriptor.getNsURI();
		String eClassName = typeDescriptor.getEClassName();

		Map metamodelTypeDescriptorsByEClass = (Map) metamodelTypeDescriptorsByNsURI
				.get(nsURI);

		if (metamodelTypeDescriptorsByEClass == null) {
			metamodelTypeDescriptorsByEClass = new HashMap();
			metamodelTypeDescriptorsByNsURI.put(nsURI, metamodelTypeDescriptorsByEClass);
		}
		
		Collection descriptors = (Collection) metamodelTypeDescriptorsByEClass.get(eClassName);
		
		if (descriptors == null) {
			descriptors = new ArrayList();
			metamodelTypeDescriptorsByEClass.put(eClassName, descriptors);
		}

		descriptors.add(typeDescriptor);

		metamodelTypeDescriptorsById
				.put(typeDescriptor.getId(), typeDescriptor);

		return true;
	}

	/**
	 * Loads the element type factory from <code>configElement</code>.
	 * 
	 * @@param configElement
	 *            the configuration element
	 * @@throws CoreException
	 *             on any problem accessing a configuration element
	 */
	private void loadElementTypeFactory(IConfigurationElement configElement)
		throws CoreException {

		ElementTypeFactoryDescriptor descriptor = new ElementTypeFactoryDescriptor(
			configElement);
		elementTypeFactoryMap.put(descriptor.getKindName(), descriptor);

	}

	/**
	 * Checks to see if an element type with the same ID as
	 * <code>typeDescriptor</code> has already been registered.
	 * 
	 * @@param typeDescriptor
	 * @@return <code>true</code> if there is no duplicate, <code>false</code>
	 *         otherwise.
	 */
	private boolean checkForDuplicate(ElementTypeDescriptor typeDescriptor) {

		if (metamodelTypeDescriptorsById.containsKey(typeDescriptor.getId())) {
			Log
					.error(
							EMFTypePlugin.getPlugin(),
							EMFTypePluginStatusCodes.TYPE_NOT_INITED,
							EMFTypeCoreMessages
									.bind(
											EMFTypeCoreMessages.type_not_init_WARN_,
											typeDescriptor.getId(),
											EMFTypeCoreMessages.type_reason_duplicate_id_WARN_));
			return true;
		}
		return false;
	}

	/**
	 * Gets the metamodel type descriptors that match the EClasses in
	 * <code>eClasses</code> for the client <code>context</code>.
	 * 
	 * @@param eClasses
	 *            a Set of <code>EClass</code> instances
	 * @@param context
	 *            the client context
	 * @@return a List of <code>modelType</code>s
	 */
	private List getMetamodelTypeDescriptors(Set eClasses,
			IClientContext context) {
		
		List result = new ArrayList();

		for (Iterator i = eClasses.iterator(); i.hasNext();) {
			EClass nextType = (EClass) i.next();

			MetamodelTypeDescriptor metamodelTypeDescriptor = getMetamodelTypeDescriptor(
					nextType, context);

			if (metamodelTypeDescriptor != null) {
				result.add(metamodelTypeDescriptor);
			}
		}
		return result;
	}

	/**
	 * Gets the type descriptor for the element type with <code>id</code>
	 * 
	 * @@param id
	 *            the type ID
	 * @@return the type descriptor, or <code>null</code> if none is registered
	 *         with that ID
	 */
	private ElementTypeDescriptor getTypeDescriptor(String id) {

		ElementTypeDescriptor typeDescriptor = (ElementTypeDescriptor) metamodelTypeDescriptorsById
			.get(id);

		if (typeDescriptor == null) {
			// Try the specialization types
			typeDescriptor = specializationTypeRegistry
				.getSpecializationTypeDescriptor(id);
		}
		return typeDescriptor;
	}

	/**
	 * Gets the descriptor for the metamodel type that the
	 * <code>specializationTypeDescriptor</code> specializes. There should
	 * only be one such metamodel type.
	 * 
	 * @@param specializationTypeDescriptor
	 * @@return descriptor for the metamodel type that the
	 *         <code>specializationTypeDescriptor</code> specializes, or
	 *         <code>null</code> if the doesn't specialize any metamodel type,
	 *         or it specializes more than one metamodel type.
	 */
	private MetamodelTypeDescriptor getMetamodelTypeDescriptor(
			SpecializationTypeDescriptor specializationTypeDescriptor) {

		MetamodelTypeDescriptor metamodelTypeDescriptor = null;

		String[] specializedTypeIds = specializationTypeDescriptor
			.getSpecializationTypeIds();

		for (int j = 0; j < specializedTypeIds.length; j++) {

			ElementTypeDescriptor nextSpecializedType = getTypeDescriptor(specializedTypeIds[j]);

			if (nextSpecializedType == null) {
				Log
						.error(
								EMFTypePlugin.getPlugin(),
								EMFTypePluginStatusCodes.SPECIALIZATION_TYPE_SPECIALIZES_INVALID_ID,
								EMFTypeCoreMessages
										.bind(
												EMFTypeCoreMessages.specializationType_specializes_invalid_id_ERROR_,
												specializationTypeDescriptor
														.getId(),
												specializedTypeIds[j]));
				return null;
			}
			
			MetamodelTypeDescriptor specializedMetamodelType = null;

			if (nextSpecializedType instanceof MetamodelTypeDescriptor) {
				specializedMetamodelType = (MetamodelTypeDescriptor) nextSpecializedType;

			} else if (nextSpecializedType instanceof SpecializationTypeDescriptor) {
				SpecializationTypeDescriptor nextSpecializationType = (SpecializationTypeDescriptor) nextSpecializedType;
				specializedMetamodelType = getMetamodelTypeDescriptor(nextSpecializationType);
			}

			if (specializedMetamodelType == null) {
				// I am specializing a type that doesn't have a metamodel
				// type. I will be removed from the element type registry.
				metamodelTypeDescriptor = null;
				break;

			} else if (metamodelTypeDescriptor == null) {
				// This is the first metamodel type.
				metamodelTypeDescriptor = specializedMetamodelType;

			} else if (metamodelTypeDescriptor != specializedMetamodelType) {
				// Found that I specialize two different metamodel types
				metamodelTypeDescriptor = null;
				break;
			}
		}
		
		if (metamodelTypeDescriptor == null) {
			Log
					.error(
							EMFTypePlugin.getPlugin(),
							EMFTypePluginStatusCodes.SPECIALIZATION_TYPE_SPECIALIZES_MULTIPLE_METAMODEL_TYPES,
							EMFTypeCoreMessages
									.bind(
											EMFTypeCoreMessages.specializationType_specializes_multiple_metamodel_types_ERROR_,
											specializationTypeDescriptor
													.getId()));
		}
		return metamodelTypeDescriptor;
	}

	/**
	 * Loads the element type definitions from the <code>elementTypes</code>
	 * extension point.
	 * 
	 * @@param configs
	 *            the configuration elements
	 */
	private synchronized void load(IConfigurationElement[] configs) {

		for (int i = 0; i < configs.length; i++) {

			IConfigurationElement next = configs[i];
			try {

				String name = next.getName();
				if (name.equals(ElementTypeXmlConfig.E_METAMODEL)) {
					loadMetamodel(next);

				} else if (name
					.equals(ElementTypeXmlConfig.E_ELEMENT_TYPE_FACTORY)) {
					loadElementTypeFactory(next);
					
				}  else if (name.equals(ElementTypeXmlConfig.E_SPECIALIZATION_TYPE)) {
					registerSpecializationType(next, null);
				} 

			} catch (CoreException ce) {

				String sourcePluginId = next.getDeclaringExtension()
					.getContributor().getName();
				Log.error(EMFTypePlugin.getPlugin(), ce.getStatus().getCode(),
						EMFTypeCoreMessages.bind(
								EMFTypeCoreMessages.xml_parsing_ERROR_,
								sourcePluginId, ce.getStatus().getMessage()),
						null);

			} catch (Exception e) {

				String sourcePluginId = next.getDeclaringExtension()
					.getContributor().getName();

				Log.error(EMFTypePlugin.getPlugin(),
						EMFTypePluginStatusCodes.ERROR_PARSING_XML,
						EMFTypeCoreMessages.bind(
								EMFTypeCoreMessages.xml_parsing_ERROR_,
								sourcePluginId, e.getMessage()), e);
			}
		}

		// Remove the specializations that aren't valid.
		removeInvalidSpecializations();
	}

	/**
	 * Adds <code>l</code> as a listener for changes to this registry. Does
	 * nothing if <code>l</code> is already registered as a listener.
	 * 
	 * @@param l
	 *            the new listener
	 */
	public void addElementTypeRegistryListener(IElementTypeRegistryListener l) {

		if (!elementTypeRegistryListeners.contains(l)) {
			elementTypeRegistryListeners.add(l);
		}
	}

	/**
	 * Removes <code>l</code> as a listener for changes to this registry. Does
	 * nothing if <code>l</code> is not registered as a listener.
	 * 
	 * @@param l
	 *            the listener to remove
	 */
	public void removeElementTypeRegistryListener(IElementTypeRegistryListener l) {

		if (elementTypeRegistryListeners.contains(l)) {
			elementTypeRegistryListeners.remove(l);
		}
	}

	/**
	 * Notifies registered listeners that the element type registry has changed.
	 * 
	 * @@param e
	 *            the change event
	 */
	private void fireElementTypeAddedEvent(ElementTypeAddedEvent e) {

		for (Iterator i = elementTypeRegistryListeners.iterator(); i.hasNext();) {
			IElementTypeRegistryListener nextListener = (IElementTypeRegistryListener) i
				.next();
			nextListener.elementTypeAdded(e);
		}
	}
	
	private void registerNullElementType() {
		register(NullElementType.getInstance());
	}
}@


1.15
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d646 16
a661 12
			
		} else {
			// Find the metamodel type for the nearest supertype.
			List supertypes = eClass.getEAllSuperTypes();
			for (int i = supertypes.size() - 1; i >= 0; i--) {
				EClass nextEClass = (EClass) supertypes.get(i);
	
				// nsURI could be different in supertypes of the eclass
				metamodelTypeDescriptorsByEClass = (Map) metamodelTypeDescriptorsByNsURI.get(nextEClass.getEPackage().getNsURI());
				descriptors = metamodelTypeDescriptorsByEClass != null ? (Collection) metamodelTypeDescriptorsByEClass
						.get(nextEClass.getName())
						: null;
d663 2
a664 8
				if (descriptors != null) {
					for (Iterator j = descriptors.iterator(); j.hasNext();) {
						MetamodelTypeDescriptor descriptor = (MetamodelTypeDescriptor) j
								.next();
		
						if (clientContext.includes(descriptor)) {
							return descriptor;
						}
@


1.14
log
@[146049] gmf_head lj 060608 ElementTypeRegistry assumes nsURI are the same inside one's type hierarchy
@
text
@a14 1
import java.util.Arrays;
d713 6
a718 4
			// Add the metamodel supertypes
			List superTypes = Arrays.asList(metamodelType.getAllSuperTypes());
			Collections.reverse(superTypes);
			result.addAll(superTypes);
d747 96
@


1.14.2.1
log
@[146097] gmf_R1_0_maintenance ldamus 060707 ElementTypeRegistry.getAllTypesMatching reverses superTypes array of metamodel type
@
text
@d15 1
d714 4
a717 6
			// Add the metamodel supertypes in reverse order
			IElementType[] superTypes = metamodelType.getAllSuperTypes();

			for (int i = superTypes.length - 1; i >= 0; i--) {
				result.add(superTypes[i]);
			}
@


1.14.2.2
log
@[151097] gmf_R1_0_maintenance ldamus 060802 Connections with semantic meaning can be incorrectly reoriented to shapes
@
text
@a746 23
	
	/**
	 * Gets an array containing all specializations of the element type for
	 * <code>id</code>, in breadth-first order.
	 * 
	 * @@param id
	 *            the element type ID
	 * @@return the list of all specializations of this element type
	 */
	public ISpecializationType[] getSpecializationsOf(String id) {
		
		IElementTypeDescriptor descriptor = getTypeDescriptor(id);
		
		if (descriptor == null) {
			return new ISpecializationType[] {};
		}
		
		IClientContext clientContext = ClientContextManager.getInstance()
				.getBinding(descriptor);

		return specializationTypeRegistry
				.getAllSpecializationTypes(descriptor, clientContext);
	}
@


1.14.2.3
log
@[155601] gmf_R1_0_maintenance ldamus 060901 ElementTypeRegistry should provide access to all types that are bound to a given client context
@
text
@a769 73
	
	/**
	 * Gets the metamodel types in the registry that are bound to the
	 * <code>clientContext</code>.
	 * 
	 * @@param clientContext
	 *            the client context
	 * @@return the metamodel types
	 */
	public IMetamodelType[] getMetamodelTypes(IClientContext clientContext) {

		List result = new ArrayList();
		for (Iterator i = metamodelTypeDescriptorsById.values().iterator(); i
				.hasNext();) {
			MetamodelTypeDescriptor descriptor = (MetamodelTypeDescriptor) i
					.next();

			if (clientContext.includes(descriptor)) {
				result.add(descriptor.getElementType());
			}
		}

		return (IMetamodelType[]) result.toArray(new IMetamodelType[result.size()]);
	}
	
	/**
	 * Gets the specialization types in the registry that are bound to the
	 * <code>clientContext</code>.
	 * 
	 * @@param clientContext
	 *            the client context
	 * @@return the specialization types
	 */
	public ISpecializationType[] getSpecializationTypes(
			IClientContext clientContext) {

		List result = new ArrayList();
		Collection specializations = specializationTypeRegistry
				.getSpecializationTypeDescriptors(clientContext);
		
		for (Iterator i = specializations.iterator(); i.hasNext();) {
			result.add(((SpecializationTypeDescriptor) i.next())
					.getElementType());
		}

		return (ISpecializationType[]) result.toArray(new ISpecializationType[result.size()]);
	}
	
	/**
	 * Gets the element types (both metamodel types and specialization types) in
	 * the registry that are bound to the <code>clientContext</code>.
	 * 
	 * @@param clientContext
	 *            the client context
	 * @@return the element types
	 */
	public IElementType[] getElementTypes(IClientContext clientContext) {

		IMetamodelType[] metamodelTypes = getMetamodelTypes(clientContext);
		ISpecializationType[] specializationTypes = getSpecializationTypes(clientContext);

		IElementType[] result = new IElementType[metamodelTypes.length
				+ specializationTypes.length];
		
		for (int i = 0; i < metamodelTypes.length; i++) {
			result[i] = metamodelTypes[i];
		}
		
		for (int i = 0; i < specializationTypes.length; i++) {
			result[i + metamodelTypes.length] = specializationTypes[i];
		}
		return result;
	}
@


1.13
log
@[136432] gmf_head ldamus 060601 ElementTypeRegistry doesn't respect dynamic plug-in loading
@
text
@d654 2
a655 1
				// same nsURI is assumed because we're looking at supertypes of the eclass
@


1.12
log
@[143695] gmf_head ldamus 060525 ElementTypeRegistry causes premature plugin loading
@
text
@d27 2
d30 3
d54 3
a56 1
 * <code>org.eclipse.gmf.runtime.emf.type.core.elementTypes</code> extension point.
d109 4
d126 5
d134 22
d1173 1
a1173 1
	private void load(IConfigurationElement[] configs) {
@


1.11
log
@[136760] gmf_head ldamus 060426  ElementTypeRegistry prevents deployment of different applications sharing the same metamodel
@
text
@d73 3
a75 2
	 * Metamodel type descriptors stored by EClass. Each value is a collection of
	 * MetamodelTypeDescriptors.
d77 1
a77 1
	private final Map metamodelTypeDescriptorsByEClass;
d109 1
a109 1
		metamodelTypeDescriptorsByEClass = new HashMap();
d593 6
a598 3

		Collection descriptors = (Collection) metamodelTypeDescriptorsByEClass
				.get(eClass);
d616 4
a619 2
				descriptors = (Collection) metamodelTypeDescriptorsByEClass
						.get(nextEClass);
d932 3
d936 2
a937 4
		EClass eClass = typeDescriptor.getEClass();

		Collection descriptors = (Collection) metamodelTypeDescriptorsByEClass
				.get(eClass);
d939 7
d948 1
a948 1
			metamodelTypeDescriptorsByEClass.put(eClass, descriptors);
@


1.10
log
@Rollback of mistaken changes.
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
a32 1

d73 2
a74 2
	 * Metamodel type descriptors stored by EClass. Each value is a single
	 * MetamodelTypeDescriptor.
d139 2
d147 23
d172 5
a176 2
		MetamodelTypeDescriptor metamodelType = (eClass != null) ? getMetamodelTypeDescriptor(eClass) : null;
		List result = specializationTypeRegistry.getEditHelperAdvice(type, metamodelType);
d180 1
a180 1

d188 2
d192 2
a193 1
	public IEditHelperAdvice[] getEditHelperAdvice(EObject eObject) {
d196 1
a196 1
		MetamodelTypeDescriptor desc = getMetamodelTypeDescriptor(eObject);
d200 1
a200 1
					DefaultMetamodelType.getDescriptorInstance());
d202 1
a202 1
			result = specializationTypeRegistry.getEditHelperAdvice(eObject, desc);
d207 19
d229 2
a230 1
	 * be either an EObject or an IElementType.
d237 1
a237 1

d243 22
d268 1
a268 1

d271 2
a272 2
	 * <code>feature</code> of <code>eContainer</code>.  The result will 
	 * not include types that represent abstract EClasses.
d278 2
d283 2
a284 2
			EReference reference) {

d298 1
a298 1
			List metamodelTypeDescriptors = getMetamodelTypeDescriptors(types);
d317 1
a317 1
							nextMetamodelTypeDescriptor, eContainer, reference);
d337 22
d385 4
a388 4
	 * Gets the metamodel type for <code>eClass</code>. If there is none
	 * registered against the <code>eClass</code>, returns the metamodel type
	 * for the nearest supertype of
	 * <code>eClass/code> that has a metamodel type.
d392 2
a393 1
	 * @@return the metamodel type for this <code>eClass</code>, or <code>null</code> if none can be found.
d395 3
a397 3
	private IMetamodelType getMetamodelType(EClass eClass) {

		MetamodelTypeDescriptor descriptor = getMetamodelTypeDescriptor(eClass);
d413 1
d416 3
a418 2
	private IMetamodelType getMetamodelType(EObject eObject) {
		return getMetamodelType(eObject.eClass());
d428 12
a439 4
	 * type registered for <code>o</code>'s eClass.
	 * <P>            
	 * Use {@@link #getElementType(EClass)} to get metamodel types registered
	 * for a specific <code>EClass</code>.
d453 19
d473 13
d487 1
a487 1
		return null;
d495 2
d499 1
a499 1
	public IElementType getElementType(EClass eClass) {
d501 1
a501 1
		IElementType result = getMetamodelType(eClass);
d512 2
d521 20
d542 1
a542 1
		IElementType result = getMetamodelType(eObject);
d547 1
a547 1
		
d552 11
a562 5
	 * Gets the metamodel type descriptor for <code>eObject</code>'s EClass.
	 * If there is none registered against the <code>eClass</code>, returns
	 * the metamodel type for the nearest supertype of
	 * <code>eClass/code> that has a metamodel type.
	 * @@param eObject the model element
d565 3
a567 2
	private MetamodelTypeDescriptor getMetamodelTypeDescriptor(EObject eObject) {
		return getMetamodelTypeDescriptor(eObject.eClass());
d571 5
a575 4
	 * Gets the metamodel type descriptor for <code>eClass</code>. If there
	 * is none registered against the <code>eClass</code>, returns the
	 * metamodel type for the nearest supertype of
	 * <code>eClass/code> that has a metamodel type.
d577 4
a580 1
	 * @@param eClass the model element eclass
d583 2
a584 1
	private MetamodelTypeDescriptor getMetamodelTypeDescriptor(EClass eClass) {
d586 1
a586 2
		MetamodelTypeDescriptor descriptor = (MetamodelTypeDescriptor) metamodelTypeDescriptorsByEClass
			.get(eClass);
d588 7
a594 2
		if (descriptor != null) {
			return descriptor;
d596 10
d611 13
a623 6
				MetamodelTypeDescriptor typeDescriptor = (MetamodelTypeDescriptor) metamodelTypeDescriptorsByEClass
					.get(nextEClass);

				if (typeDescriptor != null) {
					return typeDescriptor;

d629 1
a629 1

d637 2
d641 2
a642 2
	public IElementType[] getAllTypesMatching(EObject eObject) {

d644 1
a644 1
		IMetamodelType metamodelType = getMetamodelType(eObject);
d650 1
a650 1
			MetamodelTypeDescriptor desc = getMetamodelTypeDescriptor(eObject);
d655 1
a655 1
					.getSpecializationDescriptorsMatching(eObject, desc);
d684 19
d742 4
a745 2
	 * Registers <code>metamodelType</code> with this registry, if its ID and
	 * EClass are unique in the registry.
d757 1
a757 3
			|| getType(metamodelType.getId()) != null
			|| metamodelTypeDescriptorsByEClass.containsKey(metamodelType
				.getEClass())) {
d914 1
a914 1
	 * a metamodel type has already been registered for the same EClass.
d929 6
a934 3
		if (metamodelTypeDescriptorsByEClass.containsKey(eClass)) {
			// Log an error
			return false;
d937 2
a938 1
		metamodelTypeDescriptorsByEClass.put(eClass, typeDescriptor);
d940 1
a940 1
			.put(typeDescriptor.getId(), typeDescriptor);
d989 1
a989 1
	 * <code>eClasses</code>.
d993 3
a995 1
	 * @@return a List of <code>tamodelType</code> s
d997 3
a999 1
	private List getMetamodelTypeDescriptors(Set eClasses) {
d1004 3
a1006 2
			MetamodelTypeDescriptor metamodelTypeDescriptor = (MetamodelTypeDescriptor) metamodelTypeDescriptorsByEClass
				.get(nextType);
@


1.9
log
@#125900 Redundant annotations added to View in generated view factory
@
text
@a26 2
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
a27 3
import org.eclipse.core.runtime.dynamichelpers.ExtensionTracker;
import org.eclipse.core.runtime.dynamichelpers.IExtensionChangeHandler;
import org.eclipse.core.runtime.dynamichelpers.IExtensionTracker;
a101 3
	private ExtensionTracker extensionTracker;
	private IExtensionChangeHandler extensionListener;

a114 2

		startExtensionTracking();
a117 27
	private void startExtensionTracking() {
		extensionListener = new IExtensionChangeHandler() {
			public void addExtension(IExtensionTracker tracker, IExtension extension) {
				load(extension.getConfigurationElements());
			}

			public void removeExtension(IExtension extension, Object[] objects) {
				// FIXME implement extension removal
			}
		};
		final IExtensionPoint pt = Platform.getExtensionRegistry().getExtensionPoint(EMFTypePlugin.getPluginId(), ELEMENT_TYPES_EXT_P_NAME);
		extensionTracker = new ExtensionTracker();
		extensionTracker.registerHandler(extensionListener, ExtensionTracker.createExtensionPointFilter(pt));
	}

	private void stopExtensionTracking() {
		if (extensionTracker != null) {
			extensionTracker.unregisterHandler(extensionListener);
			extensionTracker = null;
			extensionListener = null;
		}
	}

	public void shutdown() {
		stopExtensionTracking();
	}

d895 1
a895 1
	private synchronized void load(IConfigurationElement[] configs) {
@


1.8
log
@[132588] gmf_head ldamus 060320 Fix deprecation warnings for IExtension#getNamespace
@
text
@d27 2
d30 3
d107 3
d123 2
d128 27
d932 1
a932 1
	private void load(IConfigurationElement[] configs) {
@


1.7
log
@[129773] gmf_head cdamus 060309 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@d917 1
a917 1
					.getNamespace();
d927 1
a927 1
					.getNamespace();
@


1.6
log
@[129773] gmf_head cdamus 060306 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@d44 1
@


1.5
log
@[120871] gmf_head ldamus 051222 org.eclipse.gmf.runtime.emf.type.core needs NLS sweep
@
text
@d164 9
a172 2
		List result = specializationTypeRegistry.getEditHelperAdvice(eObject,
			getMetamodelTypeDescriptor(eObject));
d359 7
a365 1
		return getMetamodelType(eClass);
d378 7
a384 1
		return getMetamodelType(eObject);
d450 8
a457 3
			Collection specializations = specializationTypeRegistry
				.getSpecializationDescriptorsMatching(eObject,
					getMetamodelTypeDescriptor(eObject));
d475 6
d499 2
@


1.4
log
@Bugzilla Bug 111642 gmf_head ldamus 051013 Correct ElementTypeRegistry to return valid IElementType in case of editing ECore model
@
text
@d45 1
a45 1
import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.ResourceManager;
d720 8
a727 10
				.error(
					EMFTypePlugin.getPlugin(),
					EMFTypePluginStatusCodes.TYPE_NOT_INITED,
					ResourceManager
						.getMessage(
							EMFTypePluginStatusCodes.TYPE_NOT_INITED_KEY,
							new Object[] {
								typeDescriptor.getId(),
								ResourceManager
									.getLocalizedString(EMFTypePluginStatusCodes.TYPE_DUPLICATE_KEY)}));
d802 9
a810 7
				.error(
					EMFTypePlugin.getPlugin(),
					EMFTypePluginStatusCodes.SPECIALIZATION_TYPE_SPECIALIZES_INVALID_ID,
					ResourceManager
						.getMessage(
							EMFTypePluginStatusCodes.SPECIALIZATION_TYPE_SPECIALIZES_INVALID_ID_KEY,
							new Object[] {specializationTypeDescriptor.getId(), specializedTypeIds[j]}));
d843 8
a850 7
			.error(
				EMFTypePlugin.getPlugin(),
				EMFTypePluginStatusCodes.SPECIALIZATION_TYPE_SPECIALIZES_MULTIPLE_METAMODEL_TYPES,
				ResourceManager
					.getMessage(
						EMFTypePluginStatusCodes.SPECIALIZATION_TYPE_SPECIALIZES_MULTIPLE_METAMODEL_TYPES_KEY,
						new Object[] {specializationTypeDescriptor.getId()}));
d886 4
a889 4
					ResourceManager.getMessage(
						EMFTypePluginStatusCodes.ERROR_PARSING_XML_KEY,
						new Object[] {sourcePluginId,
							ce.getStatus().getMessage()}), null);
d897 4
a900 4
					EMFTypePluginStatusCodes.ERROR_PARSING_XML, ResourceManager
						.getMessage(
							EMFTypePluginStatusCodes.ERROR_PARSING_XML_KEY,
							new Object[] {sourcePluginId, e.getMessage()}), e);
@


1.3
log
@Bugzilla 111642 gmf_head ldamus 051006 Correct ElementTypeRegistry to return valid IElementType in case of editing ECore model
@
text
@a319 3
	 * If <code>o</code> is an <code>EClass</code>, returns the metamodel
	 * type registered for <code>o</code>.
	 * <P>
d323 2
a324 2
	 * Use {@@link #getElementType(EObject)} to get metamodel types registered
	 * for instances of the Ecore package itself.
d333 1
a333 4
		if (o instanceof EClass) {
			return getElementType((EClass) o);
			
		} else if (o instanceof EObject) {
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d315 13
a327 1
	 * Gets the element type for <code>o</code>.
d331 2
a332 3
	 * @@return <code>o</code> itself if it is an element type, otherwise the
	 *         registered metamodel type if <code>o</code> is an
	 *         <code>EObject</code> or an <code>EClass</code>.
d337 2
a338 2
			return getMetamodelType((EClass) o);

d340 1
a340 1
			return getMetamodelType((EObject) o);
d348 25
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

