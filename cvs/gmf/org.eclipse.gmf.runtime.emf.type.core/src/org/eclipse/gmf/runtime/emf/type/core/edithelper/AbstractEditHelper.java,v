head	1.19;
access;
symbols
	v20081020-0700:1.19
	v20080807-1333:1.19
	v20080807-1325:1.19
	v20080731-1520:1.19
	v20080725-1738:1.19
	v20080722-1827:1.19
	R2_1_maintenance:1.19.0.2
	Root_R2_1_maintenance:1.19
	R2_1_0:1.19
	v20080425-1959:1.19
	v20080328-1605:1.19
	v20080222-1200:1.19
	v20080114-2222:1.17.2.2
	v20080107-1111:1.19
	v20071130-1111:1.18
	v20071124-0000:1.17.2.1
	v20070809-0000:1.17
	R2_0_maintenance:1.17.0.2
	R2_0:1.17
	R4_20:1.17
	RC3_20:1.17
	v20070601-1400:1.17
	v20070518-1300:1.17
	v20070403-1500:1.17
	v20070330-1300:1.17
	v20070208-1800:1.17
	M4_20:1.17
	v20061214-0000:1.17
	M3_20:1.17
	v20061117-0800:1.17
	v20061013-1330:1.17
	v20060919-0800:1.16.2.3
	v20060907-1100:1.16.2.3
	M1_20:1.16
	v20060831-1500:1.16.2.2
	v20060817-1500:1.16.2.1
	v20060803-1200:1.16.2.1
	v20060721-1130:1.16.2.1
	v20060713-1700:1.16.2.1
	R1_0_maintenance:1.16.0.2
	R1_0:1.16
	v20060627-1200:1.16
	v20060616-1200:1.16
	v20060609-1400:1.15
	v20060531-1730:1.15
	v20060530-1930:1.15
	v20060526-1200:1.14
	v20060519-0800:1.12
	I20060505-1400:1.11
	I20060428-1300:1.11
	I20060424-0500:1.10
	I20060424-0300:1.10
	M6_10:1.10
	I20060407-1200:1.10
	I20060331-1000:1.8
	I20060324-0300:1.7
	I20060317-1300:1.7
	I20060317-1200:1.7
	I20060316-1300:1.7
	I20060309-1300:1.7
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.6
	I20060216-1945:1.5
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.2
	I20051223-1100:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.19
date	2008.01.04.20.31.16;	author aboyko;	state Exp;
branches;
next	1.18;
commitid	797d477e97934567;

1.18
date	2007.11.21.21.24.15;	author aboyko;	state Exp;
branches;
next	1.17;
commitid	562d4744a1fe4567;

1.17
date	2006.10.03.15.06.38;	author ahunter;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2006.06.12.18.46.23;	author ldamus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2006.05.30.19.43.38;	author ldamus;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.23.17.29.44;	author ldamus;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.23.17.17.11;	author ldamus;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.17.14.00.28;	author ldamus;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.26.20.14.33;	author ldamus;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.05.21.04.44;	author ldamus;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.03.17.40.00;	author ldamus;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.27.21.12.51;	author ldamus;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.07.02.40.34;	author ldamus;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.22.14.13.14;	author ldamus;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.16.18.48.35;	author ldamus;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.13.19.12.20;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.04.15.53.49;	author ldamus;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.26.55;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.49;	author sshaw;	state Exp;
branches;
next	;

1.16.2.1
date	2006.07.13.15.10.02;	author mmostafa;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2006.08.28.20.36.12;	author ldamus;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2006.09.01.14.17.53;	author ldamus;	state Exp;
branches;
next	;

1.17.2.1
date	2007.11.21.21.25.34;	author aboyko;	state Exp;
branches;
next	1.17.2.2;
commitid	592b4744a24e4567;

1.17.2.2
date	2008.01.04.20.33.12;	author aboyko;	state Exp;
branches;
next	;
commitid	7dbb477e98074567;


desc
@@


1.19
log
@[214390] gmf_head aboyko 080104 [JUnit] Failure: org.eclipse.gmf.tests.runtime.emf.type.core.commands.DestroyElementCommandTest
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.type.core.edithelper;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.command.ICompositeCommand;
import org.eclipse.gmf.runtime.common.core.command.IdentityCommand;
import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;
import org.eclipse.gmf.runtime.emf.commands.core.command.CompositeTransactionalCommand;
import org.eclipse.gmf.runtime.emf.type.core.ElementTypeRegistry;
import org.eclipse.gmf.runtime.emf.type.core.IContainerDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.emf.type.core.ISpecializationType;
import org.eclipse.gmf.runtime.emf.type.core.commands.CreateElementCommand;
import org.eclipse.gmf.runtime.emf.type.core.commands.CreateRelationshipCommand;
import org.eclipse.gmf.runtime.emf.type.core.commands.DestroyElementCommand;
import org.eclipse.gmf.runtime.emf.type.core.commands.DestroyReferenceCommand;
import org.eclipse.gmf.runtime.emf.type.core.commands.GetEditContextCommand;
import org.eclipse.gmf.runtime.emf.type.core.commands.MoveElementsCommand;
import org.eclipse.gmf.runtime.emf.type.core.commands.SetValueCommand;
import org.eclipse.gmf.runtime.emf.type.core.internal.requests.RequestCacheEntries;
import org.eclipse.gmf.runtime.emf.type.core.requests.ConfigureRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.CreateElementRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.CreateRelationshipRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyDependentsRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyElementRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.DestroyReferenceRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.DuplicateElementsRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.GetEditContextRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.MoveRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.ReorientReferenceRelationshipRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.ReorientRelationshipRequest;
import org.eclipse.gmf.runtime.emf.type.core.requests.SetRequest;

/**
 * Abstract edit helper implementation. Implements the default edit command
 * algorithm, which returns a composite command containing the following:
 * <OL>
 * <LI>'before' commands from matching element types and  specializations</LI>
 * <LI>'instead' command from this edit helper</LI>
 * <LI>'after' commands from matching element types and specializations</LI>
 * </OL>
 * <P>
 * The before and after commands are obtained by consulting the edit helper advice that
 * is bound to the edit helper context in the edit request. Edit helper advice can
 * be inherited from supertypes.
 * <P>
 * Clients should subclass this class when creating new edit helpers.
 * 
 * @@author ldamus
 */
public abstract class AbstractEditHelper
	implements IEditHelper {
	
	/**
	 * Map of the default containment features keyed on EClass. Each value is an
	 * EReference.
	 */
	private Map defaultContainmentFeatures = new HashMap();
    
    /**
     * Checks that I can get an executable edit command.
     * <P>
     * Subclasses should override if they have a different way to decide whether
     * or not the edit is allowed.
     */
    public boolean canEdit(IEditCommandRequest req) {

        // Get the matching edit helper advice
        IEditHelperAdvice[] advice = getEditHelperAdvice(req);
        
        // Consult advisors to allow them to configure the request
        configureRequest(req, advice);
        
        // Consult advisors to allow them approve the request
        boolean approved = approveRequest(req, advice);
        
        if (!approved) {
            return false;
        }
        
        ICommand command = getEditCommand(req, advice);
        return command != null && command.canExecute();
    }

	/**
     * Builds and returns the edit command, which is a composite command
     * containing the following:
     * <OL>
     * <LI>'before' commands from matching element type specializations</LI>
     * <LI>'instead' command from this edit helper</LI>
     * <LI>'after' commands from matching element type specializations</LI>
     * </OL>
     * <P>
     * Verifies that the edit request is approved before constructing the edit
     * command.
     */
	public ICommand getEditCommand(IEditCommandRequest req) { 
		
		// Get the matching edit helper advice
		IEditHelperAdvice[] advice = getEditHelperAdvice(req);
        
		// Consult advisors to allow them to configure the request
        configureRequest(req, advice);
        
		// Consult advisors to allow them approve the request
        boolean approved = approveRequest(req, advice);
        
        if (!approved) {
            return null;
        }
        
        ICommand result = getEditCommand(req, advice);
        if (result != null) {
            return result.reduce();
        }
        return result;
	}
    
    /**
     * Template method that implements the default edit command algorithm, which
     * returns a composite command containing the following:
     * <OL>
     * <LI>'before' commands from matching element type specializations</LI>
     * <LI>'instead' command from this edit helper</LI>
     * <LI>'after' commands from matching element type specializations</LI>
     * </OL>
     */

	
    private ICommand getEditCommand(IEditCommandRequest req, IEditHelperAdvice[] advice) {
    
		ICompositeCommand command = createCommand(req);
   
        // Get 'before' commands from matching element type
        // specializations
        if (advice != null) {
            for (int i = 0; i < advice.length; i++) {
                IEditHelperAdvice nextAdvice = advice[i];

                // Before commands
                ICommand beforeAdvice = nextAdvice.getBeforeEditCommand(req);
                
                if (beforeAdvice != null) {

                    if (!beforeAdvice.canExecute()) {
                        // The operation is not permitted
                        return UnexecutableCommand.INSTANCE;
                    }
                    command.compose(beforeAdvice);
                }
            }
        }
        
        // Check if the parameter has been set to ignore the default edit command.
        Object replaceParam = req
                .getParameter(IEditCommandRequest.REPLACE_DEFAULT_COMMAND);

        if (replaceParam != Boolean.TRUE) {
            // Get 'instead' command from this edit helper
            ICommand insteadCommand = getInsteadCommand(req);

            if (insteadCommand != null) {
                
                if (!insteadCommand.canExecute()) {
                    // The operation is not permitted
                	return UnexecutableCommand.INSTANCE;
                }
                command.compose(insteadCommand);
            }
        }
        
        // Get 'after' commands from matching element type
        // specializations
        if (advice != null) {
            for (int i = 0; i < advice.length; i++) {
                IEditHelperAdvice nextAdvice = advice[i];

                // After commands
                ICommand afterAdvice = nextAdvice.getAfterEditCommand(req);

                if (afterAdvice != null) {
                    
                    if (!afterAdvice.canExecute()) {
                        // The operation is not permitted
                    	return UnexecutableCommand.INSTANCE;
                    }
                    command.compose(afterAdvice);
                }
            }
        }
        
        return command.isEmpty() ? null
            : command;
    }
    
    /**
     * Template method that consults the edit helper advice to configure the
     * edit request.
     * 
     * @@param req
     *            the edit request
     * @@param advice
     *            array of applicable edit helper advice
     */
    private void configureRequest(IEditCommandRequest req,
            IEditHelperAdvice[] advice) {

        if (advice != null) {

            for (int i = 0; i < advice.length; i++) {
                IEditHelperAdvice nextAdvice = advice[i];
                nextAdvice.configureRequest(req);
            }
        }
        // All advice has configured the request. Now consult this edit helper.
        configureRequest(req);
    }
    
    /**
     * Template method that consults the edit helper advice to see whether or
     * not they approve the request. If all advice approves the request, then
     * {@@link #approveRequest(IEditCommandRequest)} is called to determine if
     * this edit helper approves the request.
     * 
     * @@param req
     *            the edit request
     * @@param advice
     *            array of applicable edit helper advice
     * @@return <code>true</code> if the edit request is approved,
     *         <code>false</code> otherwise. No edit command will be
     *         constructed if the request is not approved.
     */
    private boolean approveRequest(IEditCommandRequest req,
            IEditHelperAdvice[] advice) {

        if (advice != null) {

            for (int i = 0; i < advice.length; i++) {
                IEditHelperAdvice nextAdvice = advice[i];
                boolean approved = nextAdvice.approveRequest(req);

                if (!approved) {
                    // An advice doesn't approve this request
                    return false;
                }
            }
        }
        // All advice has approved the request. Now consult this edit helper.
        return approveRequest(req);
    }
   
    /**
     * Approves the edit gesture described in the <code>request</code>. This
     * method will be consulted before the edit request is approved.
     * <P>
     * The default implementation does nothing. Subclasses should override if
     * they wish to change the request parameters.
     * 
     * @@param request
     *            the edit request
     */
    protected void configureRequest(IEditCommandRequest request) {
        // does nothing, by default
    }
    
    /**
     * Approves the edit gesture described in the <code>request</code>. This
     * method will be consulted before the edit command is constructed.
     * <P>
     * The default implementation returns <code>true</code>. Subclasses
     * should override if they wish to provide a different answer.
     * 
     * @@param req
     *            the edit request
     * @@return <code>true</code> if the edit request is approved,
     *         <code>false</code> otherwise. No edit command will be
     *         constructed if the request is not approved.
     */
    protected boolean approveRequest(IEditCommandRequest request) {
        return true;
    }
	
	/**
	 * Gets the array of edit helper advice for this request.
	 * 
	 * @@param req the edit request
	 * @@return the edit helper advice, or <code>null</code> if there is none
	 */
	protected IEditHelperAdvice[] getEditHelperAdvice(IEditCommandRequest req) {
		IEditHelperAdvice[] advices = null;
		Object editHelperContext = req.getEditHelperContext();
		Map cacheMaps = (Map) req
			.getParameter(RequestCacheEntries.Cache_Maps);
		if (cacheMaps != null) {
			Map contextMap = (Map) cacheMaps.get(editHelperContext);
			if (contextMap != null) {
				advices = (IEditHelperAdvice[]) contextMap.get(RequestCacheEntries.EditHelper_Advice);
			}			
		}		
		
		if (advices == null) {			
			advices = ElementTypeRegistry.getInstance().getEditHelperAdvice(
				editHelperContext);			
		}
		return advices;
	}

	/**
	 * Creates a new composite command.
	 * <P>
	 * Subclasses may override to provide their own kind of composite command.
	 * 
	 * @@param req the edit request
	 * @@return a new composite command
	 */
	protected ICompositeCommand createCommand(IEditCommandRequest req) {
		CompositeTransactionalCommand result = new CompositeTransactionalCommand(
			req.getEditingDomain(), req.getLabel()) {

			/**
			 * Extracts the first return value out of the collection of return
			 * values from the superclass command result.
			 */
			public CommandResult getCommandResult() {
				CommandResult _result = super.getCommandResult();

				IStatus status = (_result == null) ? null : _result.getStatus();

				if (status != null && status.getSeverity() == IStatus.OK) {
					Object returnObject = null;

					Object returnValue = _result.getReturnValue();

					if (returnValue instanceof Collection) {
						Collection collection = (Collection) returnValue;

						if (!collection.isEmpty()) {
							returnObject = collection.iterator().next();
						}

					} else {
						returnObject = returnValue;
					}
					_result = new CommandResult(status, returnObject);
				}

				return _result;
			};
		};

		// commands (esp. destroy) are expected to be large nested structures,
		//   because there can be many discrete particles of advice
		result.setTransactionNestingEnabled(false);
		return result;
	}

	/**
	 * Gets my command to do the work described in <code>req</code>.
	 * <P>
	 * Delegates to the more specific methods in this class to actually get the
	 * command. Subclasses should override these more specific methods.
	 * 
	 * @@param req
	 *            the edit request
	 * @@return the command to do the requested work, or <code>null</code> if I
	 *         don't support the requested work.
	 */
	protected ICommand getInsteadCommand(IEditCommandRequest req) {

		if (req instanceof CreateRelationshipRequest) {
			initializeDefaultFeature((CreateElementRequest) req);
			return getCreateRelationshipCommand((CreateRelationshipRequest) req);

		} else if (req instanceof CreateElementRequest) {
			initializeDefaultFeature((CreateElementRequest) req);
			return getCreateCommand((CreateElementRequest) req);

		} else if (req instanceof ConfigureRequest) {
			return getConfigureCommand((ConfigureRequest) req);

		} else if (req instanceof DestroyElementRequest) {
			return getDestroyElementCommand((DestroyElementRequest) req);
			
		} else if (req instanceof DestroyDependentsRequest) {
			return getDestroyDependentsCommand((DestroyDependentsRequest) req);
			
		} else if (req instanceof DestroyReferenceRequest) {
			return getDestroyReferenceCommand((DestroyReferenceRequest) req);

		} else if (req instanceof DuplicateElementsRequest) {
			return getDuplicateCommand((DuplicateElementsRequest) req);

		} else if (req instanceof GetEditContextRequest) {
			return getEditContextCommand((GetEditContextRequest) req);

		} else if (req instanceof MoveRequest) {
			return getMoveCommand((MoveRequest) req);

		} else if (req instanceof ReorientReferenceRelationshipRequest) {
			return getReorientReferenceRelationshipCommand((ReorientReferenceRelationshipRequest) req);

		} else if (req instanceof ReorientRelationshipRequest) {
			return getReorientRelationshipCommand((ReorientRelationshipRequest) req);

		} else if (req instanceof SetRequest) {
			return getSetCommand((SetRequest) req);
		}

		return null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.emf.core.type.IEditHelper#getContainedValues(org.eclipse.emf.ecore.EObject,
	 *      org.eclipse.emf.ecore.EReference)
	 */
	public List getContainedValues(EObject eContainer, EReference feature) {
		return Arrays.asList(ElementTypeRegistry.getInstance()
			.getContainedTypes(eContainer, feature));
	}

	/**
	 * Gets the command to configure a new element of my kind. By default,
	 * returns <code>null</code>. Subclasses may override to provide their
	 * command.
	 * 
	 * @@param req
	 *            the configure request
	 * @@return the configure command
	 */
	protected ICommand getConfigureCommand(ConfigureRequest req) {
		return null;
	}

	/**
     * Gets the command to create a new relationship in an element of my kind.
     * <P>
     * Returns the {@@link IdentityCommand} if the request does not have a source
     * or a target. This ensures that the create relationship gesture is enabled
     * until the request can be completely specified.
     * <P>
     * Subclasses may override to provide their own command.
     * 
     * @@param req
     *            the create relationship request
     * @@return the create relationship command
     */
	protected ICommand getCreateRelationshipCommand(
			CreateRelationshipRequest req) {
        
        EObject source = req.getSource();
        EObject target = req.getTarget();

        boolean noSourceOrTarget = (source == null || target == null);
        boolean noSourceAndTarget = (source == null && target == null);

        if (noSourceOrTarget && !noSourceAndTarget) {
            // The request isn't complete yet. Return the identity command so
            // that the create relationship gesture is enabled.
            return IdentityCommand.INSTANCE;
        }
        
		return new CreateRelationshipCommand(req);
	}

	/**
	 * Gets the command to create a new element in an element of my kind.
	 * Subclasses may override to provide their command.
	 * 
	 * @@param req
	 *            the create request
	 * @@return the create command
	 */
	protected ICommand getCreateCommand(CreateElementRequest req) {
		return new CreateElementCommand(req);
	}
	
	/**
	 * Sets the default feature in <code>req</code>, if there is no
	 * containment feature already in the request.
	 * 
	 * @@param req
	 *            the create request
	 */
	public void initializeDefaultFeature(CreateElementRequest req) {

		if (req.getContainmentFeature() == null) {

			// First, try to find the feature from the element type
			ISpecializationType specializationType = (ISpecializationType) req.getElementType().getAdapter(ISpecializationType.class);
			
			if (specializationType != null) {
				IContainerDescriptor containerDescriptor = specializationType.getEContainerDescriptor();

				if (containerDescriptor != null) {
					EReference[] features = containerDescriptor
						.getContainmentFeatures();
					
					if (features != null) {

						for (int i = 0; i < features.length; i++) {

							Object editHelperContext = req
								.getEditHelperContext();
							EClass eClass = null;

							if (editHelperContext instanceof EClass) {
								eClass = (EClass) editHelperContext;
								
							} else if (editHelperContext instanceof EObject) {
								eClass = ((EObject) editHelperContext).eClass();
								
							} else if (editHelperContext instanceof IElementType) {
								eClass = ((IElementType) editHelperContext)
									.getEClass();
							}

							if (eClass != null
								&& eClass.getEAllReferences().contains(
									features[i])) {
								// Use the first feature
								req.initializeContainmentFeature((features[i]));
								return;
							}
						}
					}
				}
			}

			// Next, try to get a default feature
			EClass eClass = req.getElementType().getEClass();
			
			if (eClass != null) {
				req.initializeContainmentFeature(getDefaultContainmentFeature(eClass));
			}
		}
	}
	
	/**
	 * Gets the default feature to contain the <code>eClass</code>.
	 * <P>
	 * Returns <code>null</code> by default. Subclasses should override to
	 * provide the default feature, if there is one.
	 * 
	 * @@param eClass
	 *            the EClass
	 * @@return the default feature
	 */
	protected EReference getDefaultContainmentFeature(EClass eClass) {
		EReference result = (EReference) getDefaultContainmentFeatures().get(
				eClass);

		if (result == null) {
			List superTypes = new ArrayList(eClass.getEAllSuperTypes());
			Collections.reverse(superTypes);

			Iterator i = superTypes.iterator();
			
			while (i.hasNext() && result == null) {
				EClass nextSuperType = (EClass) i.next();
				result = (EReference) getDefaultContainmentFeatures().get(
						nextSuperType);
			}
		}
		return result;
	}
	
	protected Map getDefaultContainmentFeatures() {
		return defaultContainmentFeatures;
	}

	/**
	 * Gets the command to set a value of an element of my kind. By default,
	 * returns <code>null</code>. Subclasses may override to provide their
	 * command.
	 * 
	 * @@param req
	 *            the set request
	 * @@return the set command
	 */
	protected ICommand getSetCommand(SetRequest req) {
		return new SetValueCommand(req);
	}

	/**
	 * Gets the command to create or return the edit context element for the
	 * creation of a new element of my kind (e.g., when creating a relationship,
	 * the relationship may be owned by the source or target, or some ancestor
	 * of one or the other, or both). By default, returns a command
	 * that returns a <code>null</code> edit context.
	 * Subclasses may override to provide their command.
	 * 
	 * @@param req
	 *            the get edit context request
	 * @@return the get edit context command
	 */
	protected ICommand getEditContextCommand(GetEditContextRequest req) {
		return new GetEditContextCommand(req);
	}

	/**
	 * Gets the command to destroy a single child of an element of my kind, and
	 * only it. By default, returns a {@@link DestroyElementCommand}. Subclasses
	 * may override to provide their own command.
	 * 
	 * @@param req
	 *            the destroy request
	 * @@return a command that destroys only the element specified as the request's
	 *    {@@linkplain DestroyElementRequest#getElementToDestroy() element to destroy}
	 */
	protected ICommand getBasicDestroyElementCommand(DestroyElementRequest req) {
		ICommand result = req.getBasicDestroyCommand();

		if (result == null) {
			result = new DestroyElementCommand(req);
		} else {
			// ensure that re-use of this request will not accidentally
			//    propagate this command, which would destroy the wrong object
			req.setBasicDestroyCommand(null);
		}

		return result;
	}
	
	
	
	/**
	 * Gets the command to destroy a single child of an element of my kind along
	 * with its dependents (not related by containment). By default, returns a
	 * composite that destroys the elements and zero or more dependents.
	 * 
	 * @@param req
	 *            the destroy request
	 * @@return a command that destroys the element specified as the request's
	 *    {@@linkplain DestroyElementRequest#getElementToDestroy() element to destroy}
	 *    and its non-containment dependents
	 */
	protected ICommand getDestroyElementWithDependentsCommand(
			DestroyElementRequest req) {
		ICommand result = getBasicDestroyElementCommand(req);

		EObject initial = (EObject) req
			.getParameter(DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER);

		if (initial == null) {
			// set the parameter to keep track of the initial element to destroy
			req.setParameter(
				DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER, req
					.getElementToDestroy());
		}

		//	 get elements dependent on the element we are destroying, that
		//   must also be destroyed
		DestroyDependentsRequest ddr = (DestroyDependentsRequest) req
			.getParameter(DestroyElementRequest.DESTROY_DEPENDENTS_REQUEST_PARAMETER);
		if (ddr == null) {
			// create the destroy-dependents request that will be propagated to
			//    destroy requests for all elements destroyed in this operation
			ddr = new DestroyDependentsRequest(req.getEditingDomain(), req
				.getElementToDestroy(), req.isConfirmationRequired());
			// propagate the parameters, including the initial element to
			//    destroy parameter
			ddr.addParameters(req.getParameters());
			ddr.setClientContext(req.getClientContext());
			req
				.setParameter(
					DestroyElementRequest.DESTROY_DEPENDENTS_REQUEST_PARAMETER,
					ddr);
		} else {
			ddr.setElementToDestroy(req.getElementToDestroy());
		}

		IElementType typeToDestroy = null;
		Map cacheMaps = (Map) req.getParameter(RequestCacheEntries.Cache_Maps);
		if (cacheMaps != null) {
			Map map = (Map) cacheMaps.get(req.getElementToDestroy());
			if (map != null) {
				typeToDestroy = (IElementType) map
					.get(RequestCacheEntries.Element_Type);
			}
		}

		if (typeToDestroy == null) {
			typeToDestroy = ElementTypeRegistry.getInstance().getElementType(
				req.getElementToDestroy());
		}

		if (typeToDestroy != null) {
			ICommand command = typeToDestroy.getEditCommand(ddr);

			if (command != null) {
				result = result.compose(command);
			}
		}

		return result;
	}
	
	/**
	 * Gets the command to destroy a child of an element of my kind. By
	 * default, returns a composite command that destroys the element specified
	 * by the request and all of its contents.
	 * 
	 * @@param req
	 *            the destroy request
	 * @@return a command that destroys the element specified as the request's
	 *    {@@link DestroyElementRequest#getElementToDestroy() element to destroy}
	 *    along with its contents and other dependents
	 */
	protected ICommand getDestroyElementCommand(DestroyElementRequest req) {
		ICommand result = null;	
		
		EObject parent = req.getElementToDestroy();
		
		if (req.getParameter(DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER) == null) {
			req.setParameter(DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER, parent);
		}
		
		IElementType parentType = null;	
		
		Map cacheMaps = (Map) req
			.getParameter(RequestCacheEntries.Cache_Maps);
		Set checkedElement = null;
		if (cacheMaps != null) {
			checkedElement = (Set) cacheMaps
			.get(RequestCacheEntries.Checked_Elements);
			checkedElement.add(parent);
			Map parentMap = (Map) cacheMaps.get(parent);
			if (parentMap != null) {
    			parentType = (IElementType) parentMap
    				.get(RequestCacheEntries.Element_Type);
			} else {
			    parentType = ElementTypeRegistry.getInstance().getElementType(
		                parent); 
			}
		} else {
			parentType = ElementTypeRegistry.getInstance().getElementType(
				parent);
		}

		if (parentType != null) {
			for (Iterator iter = parent.eContents().iterator(); iter.hasNext();) {
				EObject next = (EObject) iter.next();
				
				DestroyDependentsRequest ddr = (DestroyDependentsRequest) req.getParameter(
						DestroyElementRequest.DESTROY_DEPENDENTS_REQUEST_PARAMETER);
				
				// if another object is already destroying this one because it
				// is (transitively) a dependent, then don't destroy it again .
				if ((ddr == null) || ((checkedElement != null) && checkedElement.add(next)) || (!ddr.getDependentElementsToDestroy().contains(next))) {
					// set the element to be destroyed
					req.setElementToDestroy(next);
					
					ICommand command = parentType.getEditCommand(req);
				
					if (command != null) {
						if (result == null) {
							result = command;
						} else {
							result = result.compose(command);
						}
						
// Under normal circumstances the command is executable.
// Checking canExecute here slows down large scenarios and it is therefore
// better to skip this check.
//						if (!command.canExecute()) {
//							// no point in continuing if we're abandoning the works
//							break;
//						}
					}
				}
			}
		}

		// restore the elementToDestroy in the original request
        req.setElementToDestroy(parent);
        
		ICommand destroyParent = getDestroyElementWithDependentsCommand(req);
		
		//bottom-up destruction:  destroy children before parent
		if (result == null) {
			result = destroyParent;
		} else {
			result = result.compose(destroyParent);
		}
		
		return result;
	}

	/**
	 * Gets the command to destroy dependents of an element of my kind. By
	 * default, returns <code>null</code>. Subclasses may override to provide
	 * a command.
	 * 
	 * @@param req
	 *            the destroy dependents request
	 * @@return a command to destroy dependents, or <code>null</code>
	 */
	protected ICommand getDestroyDependentsCommand(DestroyDependentsRequest req) {
		return null;
	}

	/**
	 * Gets the command to remove a reference from an element of my kind. By
	 * default, returns <code>null</code>. Subclasses may override to provide
	 * their command.
	 * 
	 * @@param req
	 *            the destroy reference request
	 * @@return the destroy reference command
	 */
	protected ICommand getDestroyReferenceCommand(DestroyReferenceRequest req) {
		return new DestroyReferenceCommand(req);
	}

	/**
	 * Gets the command to duplicate a child in an element of my kind. By
	 * default, returns <code>null</code>. Subclasses may override to provide
	 * their command.
	 * 
	 * @@param req
	 *            the duplicate request
	 * @@return the duplicate command
	 */
	protected ICommand getDuplicateCommand(DuplicateElementsRequest req) {
		return null;
	}

	/**
	 * Gets the command to move an element into an element of my kind. By
	 * default, returns <code>null</code>. Subclasses may override to provide
	 * their command.
	 * 
	 * @@param req
	 *            the move request
	 * @@return the move command
	 */
	protected ICommand getMoveCommand(MoveRequest req) {
		return new MoveElementsCommand(req);
	}

	/**
	 * Gets the command to change the source or target of a reference in an
	 * element of my kind. By default, returns <code>null</code>. Subclasses
	 * may override to provide their command.
	 * 
	 * @@param req
	 *            the reorient reference request
	 * @@return the reorient reference command
	 */
	protected ICommand getReorientReferenceRelationshipCommand(
			ReorientReferenceRelationshipRequest req) {
		return null;
	}

	/**
	 * Gets the command to change the source or target of a relationship in an
	 * element of my kind. By default, returns <code>null</code>. Subclasses
	 * may override to provide their command.
	 * 
	 * @@param req
	 *            the reorient relationship request
	 * @@return the reorient relationship command
	 */
	protected ICommand getReorientRelationshipCommand(
			ReorientRelationshipRequest req) {
		return null;
	}
}@


1.18
log
@[209713] gmf_head aboyko 071121 Performance enhancements to AbstractEditHelper for large delete scenario
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 IBM Corporation and others.
d740 5
a744 1
		EObject parent = req.getElementToDestroy();		
@


1.17
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d138 5
a142 1
        return getEditCommand(req, advice);
a738 2

		ICommand destroyParent = getDestroyElementWithDependentsCommand(req);	
d752 7
a758 2
			parentType = (IElementType) parentMap
				.get(RequestCacheEntries.Element_Type);			
d786 7
a792 4
						if (!command.canExecute()) {
							// no point in continuing if we're abandoning the works
							break;
						}
d798 5
a809 3
		// restore the elementToDestroy in the original request
		req.setElementToDestroy(parent);
		
@


1.17.2.1
log
@[209713] gmf_R2_0_maintenance aboyko 071121 Performance enhancements to AbstractEditHelper for large delete scenario
@
text
@d138 1
a138 5
        ICommand result = getEditCommand(req, advice);
        if (result != null) {
            return result.reduce();
        }
        return result;
d735 2
d750 2
a751 7
			if (parentMap != null) {
    			parentType = (IElementType) parentMap
    				.get(RequestCacheEntries.Element_Type);
			} else {
			    parentType = ElementTypeRegistry.getInstance().getElementType(
		                parent); 
			}
d779 4
a782 7
// Under normal circumstances the command is executable.
// Checking canExecute here slows down large scenarios and it is therefore
// better to skip this check.
//						if (!command.canExecute()) {
//							// no point in continuing if we're abandoning the works
//							break;
//						}
a787 5
		// restore the elementToDestroy in the original request
        req.setElementToDestroy(parent);
        
		ICommand destroyParent = getDestroyElementWithDependentsCommand(req);
		
d795 3
@


1.17.2.2
log
@[214390] gmf_R2_0_maintenance aboyko 080104 [JUnit] Failure: org.eclipse.gmf.tests.runtime.emf.type.core.commands.DestroyElementCommandTest
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2008 IBM Corporation and others.
d740 1
a740 5
		EObject parent = req.getElementToDestroy();
		
		if (req.getParameter(DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER) == null) {
			req.setParameter(DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER, parent);
		}
@


1.16
log
@[146559] gmf_head ldamus 060612 Public access is required to the destroy dependents request and the initial element to be destroyed
@
text
@d22 1
d45 1
a149 2
    private ICommand getEditCommand(IEditCommandRequest req, IEditHelperAdvice[] advice) { 
        ICompositeCommand command = createCommand(req);
d151 5
d312 1
a312 1

d314 14
a327 2
		return ElementTypeRegistry.getInstance().getEditHelperAdvice(
			editHelperContext);
a338 1
		
d340 2
a341 3
				req.getEditingDomain(),
				req.getLabel()) {
			
d347 5
a351 5
				CommandResult result = super.getCommandResult();
				
				IStatus status = result.getStatus();
				
				if (status.getSeverity() == IStatus.OK) {
d353 3
a355 3
					
					Object returnValue = result.getReturnValue();
					
d358 1
a358 1
						
d362 1
a362 1
						
d366 1
a366 1
					result = new CommandResult(status, returnObject);
d368 2
a369 2
				
				return result;
d372 1
a372 1
		
a375 1
		
d636 1
a636 1
		
d644 1
a644 1
		
d648 2
d661 2
a662 1
	protected ICommand getDestroyElementWithDependentsCommand(DestroyElementRequest req) {
d664 4
a667 4
		
		EObject initial = (EObject) req.getParameter(
				DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER);
		
d671 2
a672 2
					DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER,
					req.getElementToDestroy());
d674 2
a675 2
		
		// get elements dependent on the element we are destroying, that
d677 2
a678 2
		DestroyDependentsRequest ddr = (DestroyDependentsRequest) req.getParameter(
				DestroyElementRequest.DESTROY_DEPENDENTS_REQUEST_PARAMETER);
d682 2
a683 4
			ddr = new DestroyDependentsRequest(
				req.getEditingDomain(),
				req.getElementToDestroy(),
				req.isConfirmationRequired());
d686 1
a686 1
			ddr.addParameters(req.getParameters()); 
d688 2
a689 1
			req.setParameter(
d695 13
a707 2
		
		IElementType typeToDestroy = ElementTypeRegistry.getInstance().getElementType(
d709 2
a710 1
		
d713 1
a713 1
		
d718 1
a718 1
		
d734 3
a736 1
		ICommand result = null;
d738 1
a738 1
		ICommand destroyParent = getDestroyElementWithDependentsCommand(req);
d740 14
a753 2
		EObject parent = req.getElementToDestroy();
		IElementType parentType = ElementTypeRegistry.getInstance().getElementType(
d755 1
d765 2
a766 2
				//    is (transitively) a dependent, then don't destroy it again
				if ((ddr == null) || !ddr.getDependentElementsToDestroy().contains(next)) {
d787 2
a788 2
		
		// bottom-up destruction:  destroy children before parent
@


1.16.2.1
log
@[110316] gmf_R1_0_maintenance mmostafa  060713 Compiler warning count should be 0 - runtime diagram layer components
@
text
@d332 1
a332 1
				CommandResult _result = super.getCommandResult();
d334 1
a334 1
				IStatus status = _result.getStatus();
d339 1
a339 1
					Object returnValue = _result.getReturnValue();
d351 1
a351 1
					_result = new CommandResult(status, returnObject);
d354 1
a354 1
				return _result;
@


1.16.2.2
log
@[155233] gmf_R1_0_maintenance ylulu 060828 Deleting and element using the EditHelpers could be enhanced
@
text
@a21 1
import java.util.Set;
a43 1
import org.eclipse.gmf.runtime.emf.type.core.internal.requests.RequestCacheEntries;
d148 2
a150 5
	
    private ICommand getEditCommand(IEditCommandRequest req, IEditHelperAdvice[] advice) {
    
		ICompositeCommand command = createCommand(req);
   
d307 1
a307 1
		IEditHelperAdvice[] advices = null;
d309 2
a310 14
		Map cacheMaps = (Map) req
			.getParameter(RequestCacheEntries.Cache_Maps);
		if (cacheMaps != null) {
			Map contextMap = (Map) cacheMaps.get(editHelperContext);
			if (contextMap != null) {
				advices = (IEditHelperAdvice[]) contextMap.get(RequestCacheEntries.EditHelper_Advice);
			}			
		}		
		
		if (advices == null) {			
			advices = ElementTypeRegistry.getInstance().getEditHelperAdvice(
				editHelperContext);			
		}
		return advices;
d322 1
d324 3
a326 2
			req.getEditingDomain(), req.getLabel()) {

d333 1
a333 1

d335 1
a335 1

d338 1
a338 1

d340 1
a340 1

d343 1
a343 1

d347 1
a347 1

d353 1
a353 1

d357 1
a357 1

d361 1
d622 1
a622 1

d630 1
a630 1

a633 2
	
	
d645 1
a645 2
	protected ICommand getDestroyElementWithDependentsCommand(
			DestroyElementRequest req) {
d647 4
a650 4

		EObject initial = (EObject) req
			.getParameter(DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER);

d654 2
a655 2
				DestroyElementRequest.INITIAL_ELEMENT_TO_DESTROY_PARAMETER, req
					.getElementToDestroy());
d657 2
a658 2

		//	 get elements dependent on the element we are destroying, that
d660 2
a661 2
		DestroyDependentsRequest ddr = (DestroyDependentsRequest) req
			.getParameter(DestroyElementRequest.DESTROY_DEPENDENTS_REQUEST_PARAMETER);
d665 4
a668 2
			ddr = new DestroyDependentsRequest(req.getEditingDomain(), req
				.getElementToDestroy(), req.isConfirmationRequired());
d671 1
a671 1
			ddr.addParameters(req.getParameters());
d673 1
a673 2
			req
				.setParameter(
d679 2
a680 13

		IElementType typeToDestroy = null;
		Map cacheMaps = (Map) req.getParameter(RequestCacheEntries.Cache_Maps);
		if (cacheMaps != null) {
			Map map = (Map) cacheMaps.get(req.getElementToDestroy());
			if (map != null) {
				typeToDestroy = (IElementType) map
					.get(RequestCacheEntries.Element_Type);
			}
		}

		if (typeToDestroy == null) {
			typeToDestroy = ElementTypeRegistry.getInstance().getElementType(
d682 1
a682 2
		}

d685 1
a685 1

d690 1
a690 1

d706 1
a706 3
		ICommand result = null;	

		ICommand destroyParent = getDestroyElementWithDependentsCommand(req);	
d708 1
a708 1
		EObject parent = req.getElementToDestroy();		
d710 2
a711 14
		IElementType parentType = null;	
		
		Map cacheMaps = (Map) req
			.getParameter(RequestCacheEntries.Cache_Maps);
		Set checkedElement = null;
		if (cacheMaps != null) {
			checkedElement = (Set) cacheMaps
			.get(RequestCacheEntries.Checked_Elements);
			checkedElement.add(parent);
			Map parentMap = (Map) cacheMaps.get(parent);
			parentType = (IElementType) parentMap
				.get(RequestCacheEntries.Element_Type);			
		} else {
			parentType = ElementTypeRegistry.getInstance().getElementType(
a712 1
		}
d722 2
a723 2
				// is (transitively) a dependent, then don't destroy it again .
				if ((ddr == null) || ((checkedElement != null) && checkedElement.add(next)) || (!ddr.getDependentElementsToDestroy().contains(next))) {
d744 2
a745 2

		//bottom-up destruction:  destroy children before parent
@


1.16.2.3
log
@[155418] gmf_R1_0_maintenance ldamus 060901 Read-only files are modifed because validate edit is not being called
@
text
@d349 1
a349 1
				IStatus status = (_result == null) ? null : _result.getStatus();
d351 1
a351 1
				if (status != null && status.getSeverity() == IStatus.OK) {
@


1.15
log
@[142808] gmf_head ldamus 060530 Consider using a flat transaction in CompositeTransactionalCommands
@
text
@a43 1
import org.eclipse.gmf.runtime.emf.type.core.internal.InternalRequestParameters;
d648 10
d661 1
a661 1
				InternalRequestParameters.DESTROY_DEPENDENTS_REQUEST_PARAMETER);
d669 3
a671 1
			ddr.addParameters(req.getParameters());
d674 1
a674 1
					InternalRequestParameters.DESTROY_DEPENDENTS_REQUEST_PARAMETER,
d719 1
a719 1
						InternalRequestParameters.DESTROY_DEPENDENTS_REQUEST_PARAMETER);
@


1.14
log
@[142561] gmf_head ldamus 060523 DestroyElementRequest#getElementToDestroy() altered between calls to EditHelper's getBeforeEditCommand() and getAfterEditCommand
@
text
@d324 3
a326 1
		return new CompositeTransactionalCommand(req.getEditingDomain(), req.getLabel()) {
d358 6
@


1.13
log
@[135676] gmf_head ldamus 060523 Logic shapes example does not prevent illegal reconnections
@
text
@d733 3
@


1.12
log
@[137749] gmf_head ldamus 060517 Transfer GEF Request's extended data into IEditCommandRequest's parameters
@
text
@d31 1
d165 1
a165 1
                        return null;
d184 1
a184 1
                    return null;
d203 1
a203 1
                        return null;
@


1.11
log
@[136760] gmf_head ldamus 060426  ElementTypeRegistry prevents deployment of different applications sharing the same metamodel
@
text
@d651 1
@


1.10
log
@[133160] gmf_head ldamus 060405 Support extensible element type request configuration
@
text
@d651 1
@


1.9
log
@[129582] gmf_head ldamus 060403 Edit helpers  second pass over getCreationEditContext() causes errors
[132253] gmf_head ldamus 060403 change CreateElementRequest.setContainer to not nullify edit context request
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d92 14
a105 1
        ICommand command = getEditCommand(req);
d110 2
a111 2
     * Implements the default edit command algorithm, which returns a composite
     * command containing the following:
d117 3
d121 1
a121 3
	public ICommand getEditCommand(IEditCommandRequest req) {

		ICompositeCommand command = createCommand(req);
d123 1
a123 2
		// Get 'before' commands from matching element type
		// specializations
d125 25
d151 5
a155 3
		if (advice != null) {
			for (int i = 0; i < advice.length; i++) {
				IEditHelperAdvice nextAdvice = advice[i];
d157 2
a158 2
				// Before commands
				ICommand beforeAdvice = nextAdvice.getBeforeEditCommand(req);
d160 1
a160 1
				if (beforeAdvice != null) {
d166 12
a177 12
					command.compose(beforeAdvice);
				}
			}
		}
		
		// Check if the parameter has been set to ignore the default edit command.
		Object replaceParam = req
				.getParameter(IEditCommandRequest.REPLACE_DEFAULT_COMMAND);

		if (replaceParam != Boolean.TRUE) {
			// Get 'instead' command from this edit helper
			ICommand insteadCommand = getInsteadCommand(req);
d179 1
a179 1
			if (insteadCommand != null) {
d185 9
a193 9
				command.compose(insteadCommand);
			}
		}
		
		// Get 'after' commands from matching element type
		// specializations
		if (advice != null) {
			for (int i = 0; i < advice.length; i++) {
				IEditHelperAdvice nextAdvice = advice[i];
d195 2
a196 2
				// After commands
				ICommand afterAdvice = nextAdvice.getAfterEditCommand(req);
d198 1
a198 1
				if (afterAdvice != null) {
d204 95
a298 8
					command.compose(afterAdvice);
				}
			}
		}
		
		return command.isEmpty() ? null
			: command;
	}
@


1.8
log
@[112826] gmf_head ldamus 060327 Adopt Eclipse 3.1 Operation History Framework - removing deprecated API
@
text
@d396 1
a396 1
								req.setContainmentFeature((features[i]));
d408 1
a408 1
				req.setContainmentFeature(getDefaultContainmentFeature(eClass));
@


1.7
log
@[129773] gmf_head cdamus 060306 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@a27 1
import org.eclipse.gmf.runtime.common.core.command.CompositeCommand;
a184 15
    
    /**
     * Creates a new composite command.
     * <P>
     * Subclasses may override to provide their own kind of composite command.
     * 
     * @@param label
     *            the command label
     * @@return a new composite command
     * @@deprecated Subclasses must implement
     *             {@@link #createComposite(IEditCommandRequest)} instead.
     */
    protected CompositeCommand createCompositeCommand(IEditCommandRequest req) {
        return null;
    }
a194 7
        
        // Delegate to the old API first
        // TODO remove this with deprecated method
        CompositeCommand command = createCompositeCommand(req);
        if (command != null) {
            return command;
        }
@


1.6
log
@[122771] gmf_head ldamus 060222 EditHelper framework should have canEdit methods
@
text
@d44 1
d48 1
d279 4
a282 1

d499 73
a571 3
	 * Gets the command to destroy a child of an element of my kind. By default,
	 * returns <code>null</code>. Subclasses may override to provide their
	 * command.
d575 3
a577 1
	 * @@return the destroy command
d580 60
a639 1
		return new DestroyElementCommand(req);
@


1.5
log
@[117922] gmf_head ldamus 060216 It should not be possible to start creating connection when semantic command that creates it is not executable
@
text
@d82 12
d96 8
a103 8
	 * Implements the default edit command algorithm, which returns a composite
	 * command containing the following:
	 * <OL>
	 * <LI>'before' commands from matching element type specializations</LI>
	 * <LI>'instead' command from this edit helper</LI>
	 * <LI>'after' commands from matching element type specializations</LI>
	 * </OL>
	 */
@


1.4
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d31 1
a31 1
import org.eclipse.gmf.runtime.common.core.command.UnexecutableCommand;
d106 2
d109 4
a112 1
				if (beforeAdvice != null) {
d126 6
a131 5
			if (insteadCommand == UnexecutableCommand.INSTANCE) {
				// The operation is not permitted
				return null;

			} else if (insteadCommand != null) {
d146 5
d316 12
a327 8
	 * Gets the command to create a new relationship in an element of my kind.
	 * By default, returns <code>null</code>. Subclasses may override to
	 * provide their command.
	 * 
	 * @@param req
	 *            the create relationship request
	 * @@return the create relationship command
	 */
d330 13
@


1.3
log
@[112658] gmf_head ldamus 060104 IEditHelperAdvice should enable implementors to overwrite the default editing behavior
@
text
@d16 1
d30 1
d32 1
d94 1
a94 1
		CompositeCommand command = createCompositeCommand(req);
d161 15
d182 1
a182 2
	 * @@param label
	 *            the command label
d185 8
a192 1
	protected CompositeCommand createCompositeCommand(IEditCommandRequest req) {
d194 1
a194 1
		return new CompositeCommand(req.getLabel()) {
d196 4
d203 3
a205 1
				if (result.getStatus().getSeverity() == IStatus.OK) {
d208 4
a211 2
					if (result.getReturnValue() instanceof List) {
						List returnValue = (List) result.getReturnValue();
d213 2
a214 2
						if (returnValue.size() > 0) {
							returnObject = returnValue.get(0);
d218 1
a218 1
						returnObject = result.getReturnValue();
d220 1
a220 1
					result = new CommandResult(result.getStatus(), returnObject);
d222 1
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a25 1

d39 1
a39 1
import org.eclipse.gmf.runtime.emf.type.core.commands.MoveElementCommand;
d110 16
a125 2
		// Get 'instead' command from this edit helper
		ICommand insteadCommand = getInsteadCommand(req);
a126 8
		if (insteadCommand == UnexecutableCommand.INSTANCE) {
			// The operation is not permitted
			return null;
			
		} else if (insteadCommand != null) {
			command.compose(insteadCommand);	
		}

d469 1
a469 1
		return new MoveElementCommand(req);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

