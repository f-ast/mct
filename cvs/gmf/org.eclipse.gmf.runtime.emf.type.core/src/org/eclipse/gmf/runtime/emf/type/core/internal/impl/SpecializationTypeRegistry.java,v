head	1.6;
access;
symbols
	v20081020-0700:1.6
	v20080807-1333:1.6
	v20080807-1325:1.6
	v20080731-1520:1.6
	v20080725-1738:1.6
	v20080722-1827:1.6
	R2_1_maintenance:1.6.0.4
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080425-1959:1.6
	v20080328-1605:1.6
	v20080222-1200:1.6
	v20080114-2222:1.6
	v20080107-1111:1.6
	v20071130-1111:1.6
	v20071124-0000:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	RC3_20:1.6
	v20070601-1400:1.6
	v20070518-1300:1.6
	v20070403-1500:1.6
	v20070330-1300:1.6
	v20070208-1800:1.6
	M4_20:1.6
	v20061214-0000:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061013-1330:1.6
	v20060919-0800:1.5.2.1
	v20060907-1100:1.5.2.1
	M1_20:1.5
	v20060831-1500:1.5.2.1
	v20060817-1500:1.5.2.1
	v20060803-1200:1.5.2.1
	v20060721-1130:1.5
	v20060713-1700:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	v20060627-1200:1.5
	v20060616-1200:1.5
	v20060609-1400:1.5
	v20060531-1730:1.5
	v20060530-1930:1.5
	v20060526-1200:1.5
	v20060519-0800:1.5
	I20060505-1400:1.5
	I20060428-1300:1.5
	I20060424-0500:1.4
	I20060424-0300:1.4
	M6_10:1.4
	I20060407-1200:1.4
	I20060331-1000:1.4
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.4
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.3
	I20060216-1945:1.3
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.6
date	2006.10.03.15.06.38;	author ahunter;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.26.20.14.33;	author ldamus;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2006.03.07.02.40.34;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.22.19.02.01;	author ldamus;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.26.55;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.46;	author sshaw;	state Exp;
branches;
next	;

1.5.2.1
date	2006.08.02.19.31.25;	author ldamus;	state Exp;
branches;
next	;


desc
@@


1.6
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.type.core.internal.impl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.emf.type.core.IClientContext;
import org.eclipse.gmf.runtime.emf.type.core.IContainerDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.IElementMatcher;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.emf.type.core.IElementTypeDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.IMetamodelType;
import org.eclipse.gmf.runtime.emf.type.core.ISpecializationType;
import org.eclipse.gmf.runtime.emf.type.core.ISpecializationTypeDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.edithelper.IEditHelperAdvice;
import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePlugin;
import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePluginStatusCodes;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.AdviceBindingDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.AdviceBindingInheritance;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.ElementTypeDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.IEditHelperAdviceDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.MetamodelDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.MetamodelTypeDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.descriptors.SpecializationTypeDescriptor;
import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.EMFTypeCoreMessages;

/**
 * Registry of specialization types populated by the
 * <code>ElementTypeRegistry</code>. Keeps track of the specializations and
 * advice bindings and provides methods for finding matching edit helper advice.
 * <P>
 * This class is for internal use only.
 * 
 * @@author ldamus
 */
public class SpecializationTypeRegistry {
	
	/**
	 * Set containing the ALL advice binding inheritance.
	 */
	private final static Set ALL = Collections
			.singleton(AdviceBindingInheritance.ALL);

	/**
	 * Set containing the ALL and NONE advice binding inheritance.
	 */
	private final static Set ALL_NONE = new HashSet(
			Arrays
					.asList(new AdviceBindingInheritance[] {
							AdviceBindingInheritance.NONE,
							AdviceBindingInheritance.ALL }));

	/**
	 * Specialization type descriptors stored by ID. Each value is a
	 * <code>SpecializationTypeDescriptor</code>.
	 */
	private final Map specializationTypeDescriptors;

	/**
	 * Specialization type descriptors stored by the ID of the type that has
	 * been specialized. Each value is a Set of type descriptors for the types
	 * that specialize the key type ID.
	 */
	private final Map specializationsForTypeId;

	/**
	 * Edit helper advice stored by target element type ID. Each value is a set
	 * of IEditHelperAdviceDescriptors.
	 */
	private final Map adviceBindings;

	/**
	 * Constructs a new specialization type registry.
	 */
	public SpecializationTypeRegistry() {
		super();

		specializationTypeDescriptors = new HashMap();
		specializationsForTypeId = new HashMap();
		adviceBindings = new HashMap();
	}
	
	/**
	 * Registers <code>specializationType</code> if it has a unique ID in the
	 * registry.
	 * 
	 * @@param specializationType
	 *            the element type
	 * @@return <code>true</code> if the element type was registered,
	 *         <code>false</code> otherwise.
	 */
	public boolean registerSpecializationType(ISpecializationType specializationType) {
		
		if (specializationType == null
			|| specializationTypeDescriptors.containsKey(specializationType
				.getId())) {

			return false;
		}
		
		SpecializationTypeDescriptor descriptor = new SpecializationTypeDescriptor(
			specializationType);
		
		return registerSpecializationType(descriptor);
	}

	/**
	 * Registers the specialization element type described by
	 * <code>configElement</code>.
	 * 
	 * @@param configElement
	 *            the configutation element
	 * @@param metamodelDescriptor
	 *            the descriptor for the metamodel containing the EClass for the
	 *            new element type
	 * @@return the new specialization type descriptor if it has been registered,
	 *         <code>null</code> otherwise.
	 * 
	 * @@throws CoreException
	 *             on any problem accessing a configuration element
	 */
	public SpecializationTypeDescriptor registerSpecializationType(
			IConfigurationElement configElement,
			MetamodelDescriptor metamodelDescriptor)
		throws CoreException {

		SpecializationTypeDescriptor descriptor = new SpecializationTypeDescriptor(
			configElement, metamodelDescriptor);

		boolean wasRegistered = registerSpecializationType(descriptor);

		return wasRegistered ? descriptor
			: null;
	}
	
	/**
	 * Registers <code>descriptor</code> if it has a unique ID in the
	 * registry.
	 * 
	 * @@param descriptor
	 * @@return <code>true</code> if the element was registered,
	 *         <code>false</code> otherwise.
	 */
	private boolean registerSpecializationType(
			SpecializationTypeDescriptor descriptor) {

		if (checkForDuplicate(descriptor)) {
			return false;
		}

		// Put the type in the main specialization map.
		specializationTypeDescriptors.put(descriptor.getId(), descriptor);

		// Register its edit helper advice
		IEditHelperAdviceDescriptor editHelperAdvice = descriptor
			.getEditHelperAdviceDescriptor();

		if (editHelperAdvice != null) {
			register(editHelperAdvice);
		}

		// Put the type in the map of specialized types for a given ID
		String[] specializedTypes = descriptor.getSpecializationTypeIds();
		for (int i = 0; i < specializedTypes.length; i++) {
			Set specializations = (Set) specializationsForTypeId
				.get(specializedTypes[i]);

			if (specializations == null) {
				specializations = new HashSet();
				specializationsForTypeId.put(specializedTypes[i],
					specializations);
			}
			specializations.add(descriptor);
		}
		return true;
	}

	/**
	 * Loads the edit helper advice binding described by
	 * <code>configElement</code>.
	 * 
	 * @@param configElement
	 *            the configutation element
	 * @@throws CoreException
	 *             on any problem accessing a configuration element
	 */
	public void registerAdviceBinding(IConfigurationElement configElement,
			MetamodelDescriptor metamodelDescriptor)
		throws CoreException {

		IEditHelperAdviceDescriptor descriptor = new AdviceBindingDescriptor(
			configElement, metamodelDescriptor);
		register(descriptor);
	}

	/**
	 * Registers the descriptor with the advice bindings for the target ID.
	 * 
	 * @@param descriptor
	 *            the edit helper advice descriptor
	 */
	private void register(IEditHelperAdviceDescriptor descriptor) {

		String targetId = descriptor.getTypeId();
		Set bindings = (Set) adviceBindings.get(targetId);

		if (bindings == null) {
			bindings = new HashSet();
			adviceBindings.put(targetId, bindings);
		}
		bindings.add(descriptor);
	}

	/**
	 * Removes the specialization type <code>specializationTypeDescriptor</code>.
	 * 
	 * @@param specializationTypeDescriptor
	 *            the specialization type to remove
	 */
	public void removeSpecializationType(
			SpecializationTypeDescriptor specializationTypeDescriptor) {

		specializationTypeDescriptors.remove(specializationTypeDescriptor.getId());
		
		String[] specializedTypes = specializationTypeDescriptor
			.getSpecializationTypeIds();

		for (int j = 0; j < specializedTypes.length; j++) {
			Set specializations = (Set) specializationsForTypeId
				.get(specializedTypes[j]);

			specializations.remove(specializationTypeDescriptor);
		}
	}

	/**
	 * Gets a list containing the immediate specializations of <code>type</code>.
	 * 
	 * @@param type
	 *            the element type for which to find specializations
	 * @@param clientContext
	 *            the client context
	 * @@return the list of all <code>SpecializationTypeDescriptor</code> s of
	 *         <code>type</code>
	 */
	private List getImmediateSpecializationTypeDescriptors(
			ElementTypeDescriptor type, IClientContext clientContext) {
		return getSpecializationTypeDescriptors(type, false, clientContext);
	}
	
	/**
	 * Gets a list containing all specializations of <code>type</code>, in
	 * breadth-first order.
	 * 
	 * @@param type
	 *            the element type
	 * @@param clientContext
	 *            the client context
	 * @@return the array of all specializations of <code>type</code>
	 */
	public ISpecializationType[] getAllSpecializationTypes(
			IElementTypeDescriptor type, IClientContext clientContext) {

		List descriptors = getSpecializationTypeDescriptors(type, true, clientContext);
		ISpecializationType[] result = new ISpecializationType[descriptors.size()];
		int index = 0;
		
		for (Iterator i = descriptors.iterator(); i.hasNext(); index++) {
			SpecializationTypeDescriptor next = (SpecializationTypeDescriptor) i.next();
			result[index] = (ISpecializationType) next.getElementType();
		}
		return result;
	}

	/**
	 * Gets a list containing all specializations of <code>type</code>, in
	 * breadth-first order.
	 * 
	 * @@param type
	 *            the element type
	 * @@param clientContext
	 *            the client context
	 * @@return the list of all specializations of <code>type</code>
	 */
	private List getAllSpecializationTypeDescriptors(
			IElementTypeDescriptor type, IClientContext clientContext) {

		return getSpecializationTypeDescriptors(type, true, clientContext);
	}

	/**
	 * Gets a list containing the descriptors for specializations of
	 * <code>type</code>, in breadth-first order. There are no duplicates in
	 * the list.
	 * 
	 * @@param type
	 *            the element type
	 * @@param deep
	 *            <code>true</code> if all specializations are to be found,
	 *            recursively, <code>false</code> if only the immediate
	 *            (direct) specializations are to be found.
	 * @@return the collection of <code>SpecializationTypeDescriptors</code> of
	 *         <code>type</code>
	 */
	private List getSpecializationTypeDescriptors(IElementTypeDescriptor type,
			boolean deep, IClientContext clientContext) {

		LinkedHashSet result = new LinkedHashSet();
		
		if (type != null) {
			// Get the immediate specializations
			Set specializationDescriptors = (Set) specializationsForTypeId.get(type
				.getId());
	
			if (specializationDescriptors != null) {
				Set specializations = new HashSet();
	
				for (Iterator i = specializationDescriptors.iterator(); i.hasNext();) {
					SpecializationTypeDescriptor nextDescriptor = (SpecializationTypeDescriptor) i
						.next();
	
					if (clientContext.includes(nextDescriptor)) {
						if (nextDescriptor != null) {
							specializations.add(nextDescriptor);
		
							if (deep) {
								// Recursively search for specializations
								result.addAll(getSpecializationTypeDescriptors(
									nextDescriptor, deep, clientContext));
							}
						}
					}
				}
				// Add the immediate specializations last, so that a breadth-first
				// order is maintained
				result.addAll(specializations);
			}
		}
		return new ArrayList(result);
	}

	/**
	 * Gets the array of specialization types that match <code>eObject</code>,
	 * in order of decreasing specialization.
	 * <P>
	 * Returns an empty list if the <code>clientContext</code> is not bound to
	 * the <code>metamodelTypeDescriptor</code>.
	 * 
	 * @@param eObject
	 *            the model element for which to find specializations
	 * @@param metamodelTypeDescriptor
	 *            the metamodel type descriptor for <code>eObject</code>
	 * @@return the list of <code>SpecializationTypeDescriptor</code> s that
	 *         match <code>eObject</code>
	 */
	public List getSpecializationDescriptorsMatching(EObject eObject,
			MetamodelTypeDescriptor metamodelTypeDescriptor, IClientContext clientContext) {
		
		List result = new ArrayList();

		// Get all of the specializations of the metamodel type that matches the
		// eObject
		List specializations = getAllSpecializationTypeDescriptors(
				metamodelTypeDescriptor, clientContext);

		// Get the edit helper specialization descriptors that have matching
		// advice
		for (Iterator i = specializations.iterator(); i.hasNext();) {
			SpecializationTypeDescriptor nextDescriptor = (SpecializationTypeDescriptor) i
				.next();
			IEditHelperAdviceDescriptor adviceDescriptor = nextDescriptor
				.getEditHelperAdviceDescriptor();

			if (adviceDescriptor != null) {
				// See if the advice from this descriptor matches the model
				// element
				if (adviceMatches(eObject, adviceDescriptor)) {
					result.add(nextDescriptor);
				}
			} else {
				// No restrictions
				result.add(nextDescriptor);
			}
		}
		return result;
	}

	/**
	 * Gets the list of specializations of <code>type</code> whose matching
	 * criteria match the given <code>eContainer</code> and
	 * <code>reference</code>.
	 * <P>
	 * Returns an empty list if the <code>clientContext</code> is not bound to
	 * the <code>type</code>.
	 * 
	 * @@param type
	 *            the element type
	 * @@param eContainer
	 *            the container
	 * @@param reference
	 *            the reference feature.
	 * @@param clientContext
	 *            the client context
	 * @@return the list of matching specializations
	 */
	public List getMatchingSpecializations(ElementTypeDescriptor type,
			EObject eContainer, EReference reference, IClientContext clientContext) {
		
		List result = new ArrayList();

		// Get the specializations of the element type that match the given
		// feature of the container
		List matchingSpecializations = getSpecializationDescriptorsMatching(
			type, eContainer, reference, clientContext);

		result.addAll(matchingSpecializations);

		// Repeat for only the matching specializations
		for (Iterator i = matchingSpecializations.iterator(); i.hasNext();) {
			result.addAll(getMatchingSpecializations((ElementTypeDescriptor) i
				.next(), eContainer, reference, clientContext));
		}
		return result;
	}

	/**
	 * Queries whether the specified edit helper advice descriptor matches an
	 * <code>eObject</code>.
	 * 
	 * @@param eObject
	 *            the model element for which to find matching advice
	 * @@param editHelperAdviceDescriptor
	 *            an advice descriptor that may opr may not match <code>eObject</code>
	 * @@return <code>true</code> if the advice matches; <code>false</code>, otherwise
	 */
	private boolean adviceMatches(EObject eObject,
			IEditHelperAdviceDescriptor editHelperAdviceDescriptor) {

		EReference containmentFeature = eObject.eContainmentFeature();

		IContainerDescriptor container = editHelperAdviceDescriptor
			.getContainerDescriptor();

		if (container != null) {
			IElementMatcher containerMatcher = container.getMatcher();

			if (containerMatcher != null
				&& !containerMatcher.matches(eObject.eContainer())) {
				return false;
			}
		}

		EReference[] features = null;
		if (container != null) {
			features = container.getContainmentFeatures();
		}

		if (features == null || features.length < 1) {
			// All features that can contain this type's EClass are valid
			IElementMatcher matcher = editHelperAdviceDescriptor.getMatcher();

			return (matcher == null) || matcher.matches(eObject);

		} else {

			for (int j = 0; j < features.length; j++) {

				if (features[j] == containmentFeature) {
					IElementMatcher matcher = editHelperAdviceDescriptor
						.getMatcher();

					return (matcher == null) || matcher.matches(eObject);
				}
			}
		}

		return false;
	}

	/**
	 * Gets the list descriptors of the specializations that match the
	 * <code>eContainer</code> and <code>feature</code>.
	 * 
	 * @@param eContainer
	 *            the container to match
	 * @@param feature
	 *            the containment feature to match
	 * @@param clientContext
	 *            the client context
	 * @@return the list of <code>SpecializationTypeDescriptor</code> s that
	 *         match
	 */
	private List getSpecializationDescriptorsMatching(
			ElementTypeDescriptor typeDescriptor, EObject eContainer,
			EReference feature, IClientContext clientContext) {

		List result = new ArrayList();
		Collection specializationDescriptors = getImmediateSpecializationTypeDescriptors(
				typeDescriptor, clientContext);

		for (Iterator i = specializationDescriptors.iterator(); i.hasNext();) {
			SpecializationTypeDescriptor nextDescriptor = (SpecializationTypeDescriptor) i
				.next();
			
			if (!clientContext.includes(nextDescriptor)) {
				// descriptor isn't bound to the client context
				continue;
			}
			
			IContainerDescriptor container = nextDescriptor
				.getContainerDescriptor();

			// First, match the container
			IElementMatcher containerMatcher = container != null ? container
				.getMatcher()
				: null;

			if (containerMatcher != null
				&& !containerMatcher.matches(eContainer)) {
				continue;
			}

			// Second, match the containing feature(s)
			EReference[] features = container != null ? container
				.getContainmentFeatures()
				: null;

			if (features == null || features.length < 1) {
				// All features that can contain this type's EClass are valid
				EClass specializedType = nextDescriptor.getElementType()
					.getEClass();

				if (canContain(eContainer.eClass(), feature, specializedType)) {
					result.add(nextDescriptor);
					continue;
				}
			} else {
				for (int j = 0; j < features.length; j++) {

					if (features[j] == feature) {
						result.add(nextDescriptor);
						break;
					}
				}
			}
		}

		return result;
	}

	/**
	 * Answers whether or not <code>container</code> can contain
	 * <code>contained</code> in its <code>reference</code> feature.
	 * 
	 * @@param container
	 *            the container
	 * @@param reference
	 *            the reference feature
	 * @@param contained
	 *            the element to be contained
	 * @@return <code>true</code> if <code>container</code> can contain
	 *         <code>contained</code> in its <code>reference</code> feature,
	 *         <code>false</code> otherwise.
	 */
	private boolean canContain(EClass container, EReference reference,
			EClass contained) {

		if ((reference.isContainment())
			&& (container.getEAllReferences().contains(reference))) {

			EClass eType = (EClass) reference.getEType();

			if ((eType.equals(contained)) || (eType.isSuperTypeOf(contained))) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Gets the edit helper advice bound to the <code>elementTypes</code> that
	 * match <code>eObject</code>. The advice will be that which is bound to
	 * the <code>clientContext</code>, and is ordered from most general
	 * advice (inherited from metamodel supertypes) to most specific advice
	 * (bound to specializations).
	 * <P>
	 * Returns an empty list if the <code>clientContext</code> is not bound to
	 * the <code>metamodelTypeDescriptor</code>.
	 * 
	 * @@param eObject
	 *            the model element to match
	 * @@param metamodelTypeDescriptor
	 *            the metamodel type descriptor for the model element
	 * @@param clientContext
	 *            the client context
	 * @@return the collection of matching <code>IEditHelperAdvice</code>.
	 */
	public List getEditHelperAdvice(EObject eObject,
			MetamodelTypeDescriptor metamodelTypeDescriptor, IClientContext clientContext) {

		LinkedHashSet result = new LinkedHashSet();

		// Look at advice bound to the metamodel supertypes
		IElementType[] metamodelSupertypes = metamodelTypeDescriptor
			.getElementType().getAllSuperTypes();
		for (int i = 0; i < metamodelSupertypes.length; i++) {
			IElementType nextSupertype = metamodelSupertypes[i];
			result.addAll(getMatchingAdvice(nextSupertype.getId(), eObject,
					ALL, clientContext));
		}

		// Add the advice bound to the metamodel type
		result.addAll(getMatchingAdvice(metamodelTypeDescriptor.getId(),
			eObject, ALL_NONE, clientContext));

		// Get the specializations that match
		List specializationDescriptors = getSpecializationDescriptorsMatching(
			eObject, metamodelTypeDescriptor, clientContext);
		Collections.reverse(specializationDescriptors);
		for (Iterator i = specializationDescriptors.iterator(); i.hasNext();) {
			SpecializationTypeDescriptor nextSpecialization = (SpecializationTypeDescriptor) i
				.next();

			// Look for advice bound to the matching specialization type
			result.addAll(getMatchingAdvice(nextSpecialization.getId(),
				eObject, ALL_NONE, clientContext));
		}

		return new ArrayList(result);
	}

	/**
	 * Gets the edit helper advice bound to the <code>elementType</code> and
	 * the inheritable advice bounds to its supertypes. The advice will be that
	 * which is bound to the <code>clientContext</code>, and is ordered from
	 * most general advice (inherited from metamodel supertypes) to most
	 * specific advice (bound to specializations).
	 * <P>
	 * Returns an empty list if the <code>clientContext</code> is not bound to
	 * the <code>elementType</code>.
	 * 
	 * @@param elementType
	 *            the element type whose bound edit helper advice will be
	 *            considered
	 * @@param metamodelTypeDescriptor
	 *            the metamodel type descriptor for the eClass
	 * @@param clientContext
	 *            the client context
	 * @@return the collection of matching <code>IEditHelperAdvice</code>.
	 */
	public List getEditHelperAdvice(IElementType elementType,
			MetamodelTypeDescriptor metamodelTypeDescriptor, IClientContext clientContext) {
		
		LinkedHashSet result = new LinkedHashSet();
		
		String metamodelTypeId = (metamodelTypeDescriptor != null) ? metamodelTypeDescriptor.getId() : null;

		// Look at advice bound to the supertypes
		IElementType[] metamodelSupertypes = elementType.getAllSuperTypes();
		for (int i = 0; i < metamodelSupertypes.length; i++) {
			IElementType nextSupertype = metamodelSupertypes[i];

			if (nextSupertype instanceof ISpecializationType || nextSupertype.getId().equals(metamodelTypeId)) {
				result
						.addAll(getMatchingAdvice(nextSupertype.getId(),
								ALL_NONE, clientContext));

			} else if (nextSupertype instanceof IMetamodelType) {
				result.addAll(getMatchingAdvice(nextSupertype.getId(), ALL, clientContext));
			}
		}

		// Add the advice bound to the element type itself
		result.addAll(getMatchingAdvice(elementType.getId(), ALL_NONE, clientContext));

		return new ArrayList(result);
	}

	/**
	 * Gets the edit helper advice bound to the element type with ID
	 * <code>elementTypeId</code> that matches <code>eObject</code>.
	 * 
	 * @@param elementTypeId
	 *            the element type id
	 * @@param eObject
	 *            the model element to match
	 * @@param considerApplicationToSubtypes
	 *            <code>true</code> if only those advice bindings that apply
	 *            to subtypes should be returned, <code>false</code>
	 *            otherwise.
	 * @@param clientContext
	 *            the client context
	 * @@return the list of matching <code>IEditHelperAdvice</code>
	 */
	private List getMatchingAdvice(String elementTypeId, EObject eObject,
			Set adviceInheritanceToConsider, IClientContext clientContext) {

		List result = new ArrayList();

		for (Iterator j = getAdviceBindings(elementTypeId); j.hasNext();) {
			IEditHelperAdviceDescriptor nextAdviceDescriptor = (IEditHelperAdviceDescriptor) j
				.next();

			if (clientContext.includes(nextAdviceDescriptor)) {
				// Filter out any of the bound advice that doesn't match
				if (!adviceMatches(eObject, nextAdviceDescriptor)) {
					continue;
				}
				
				if (adviceInheritanceToConsider.contains(nextAdviceDescriptor
						.getInheritance())) {
					
					IEditHelperAdvice nextAdvice = nextAdviceDescriptor
						.getEditHelperAdvice();
	
					if (nextAdvice != null) {
						result.add(nextAdvice);
					}
				}
			}
		}
		return result;
	}

	/**
	 * Gets the edit helper advice bound to the element type with ID
	 * <code>elementTypeId</code> that matches <code>eObject</code>.
	 * 
	 * @@param elementTypeId
	 *            the element type id
	 * @@param considerApplicationToSubtypes
	 *            <code>true</code> if only those advice bindings that apply
	 *            to subtypes should be returned, <code>false</code>
	 *            otherwise.
	 * @@param clientContext
	 *            the client context
	 * @@return the list of matching <code>IEditHelperAdvice</code>
	 */
	private List getMatchingAdvice(String elementTypeId,
			Set adviceInheritanceToConsider, IClientContext clientContext) {

		List result = new ArrayList();

		for (Iterator j = getAdviceBindings(elementTypeId); j.hasNext();) {
			IEditHelperAdviceDescriptor nextAdviceDescriptor = (IEditHelperAdviceDescriptor) j
				.next();
			
			if (clientContext.includes(nextAdviceDescriptor)) {

				if (adviceInheritanceToConsider.contains(nextAdviceDescriptor
						.getInheritance())) {
					
					IEditHelperAdvice nextAdvice = nextAdviceDescriptor
						.getEditHelperAdvice();
	
					if (nextAdvice != null) {
						result.add(nextAdvice);
					}
				}
			}
		}
		return result;
	}
	
	/**
	 * Obtains an iterator over the advices bound exactly to the specified element
	 * type ID and also to patterns matching the element type ID. Advice bindings
	 * are returned for all client contexts.  The caller should filter the list 
	 * by context.
	 * <p>
	 * <b>Note</b> for now, in the interest of simplicity and performance, the
	 * only pattern supported is <code>"*"</code> to match all element types.
	 * </p>
	 * 
	 * @@param elementTypeId the element type ID for which to get advice
	 * 
	 * @@return an immutable iterator of the advice bindings (cannot
	 *     {@@linkplain Iterator#remove() remove} from it)
	 */
	private Iterator getAdviceBindings(String elementTypeId) {
		class MultiIterator implements Iterator {
			private Iterator current;
			private Collection[] collections;
			private int index = 0;
			
			MultiIterator(Collection[] collections) {
				this.collections = collections;
				current = nextIterator();
			}
			
			public boolean hasNext() {
				while (current != null) {
					if (current.hasNext()) {
						return true;
					}
					
					current = nextIterator();
				}
				
				return false;
			}

			public Object next() {
				if (!hasNext()) {
					throw new NoSuchElementException();
				}
				
				return current.next();
			}

			public void remove() {
				throw new UnsupportedOperationException();
			}
			
			private Iterator nextIterator() {
				Iterator result = null;
				
				while ((result == null) && (index < collections.length)) {
					if (collections[index] != null) {
						result = collections[index].iterator();
						collections[index] = null; // free memory
					}
					
					index++;
				}
				
				return result;
			}
		}
		
		return new MultiIterator(new Collection[] {
				(Collection) adviceBindings.get(elementTypeId),
				(Collection) adviceBindings.get("*") //$NON-NLS-1$
		});
	}

	/**
	 * Gets the specialization type for a given ID.
	 * 
	 * @@param id
	 *            the type ID
	 * @@return the specialization type, or <code>null</code> if there is none
	 *         registered with this ID.
	 */
	public SpecializationTypeDescriptor getSpecializationTypeDescriptor(
			String id) {
		return (SpecializationTypeDescriptor) specializationTypeDescriptors
			.get(id);
	}

	/**
	 * Gets the collection of all registered specialization type descriptors.
	 * 
	 * @@return the registered specialization type descriptors. Each element in
	 *         the collection is a <code>SpecializationTypeDescriptor</code>.
	 */
	public Collection getSpecializationTypeDescriptors() {
		return specializationTypeDescriptors.values();
	}
	
	/**
	 * Gets the collection of all registered specialization type descriptors
	 * bound to the <code>clientContext</code>.
	 * 
	 * @@return the registered specialization type descriptors. Each element in
	 *         the collection is a <code>SpecializationTypeDescriptor</code>.
	 */
	public Collection getSpecializationTypeDescriptors(
			IClientContext clientContext) {

		Collection result = new ArrayList();

		for (Iterator i = getSpecializationTypeDescriptors().iterator(); i
				.hasNext();) {
			
			ISpecializationTypeDescriptor next = (ISpecializationTypeDescriptor) i
					.next();

			if (clientContext.includes(next)) {
				result.add(next);
			}
		}
		return result;
	}
	
	/**
	 * Checks to see if an element type with the same ID as
	 * <code>typeDescriptor</code> has already been registered.
	 * 
	 * @@param typeDescriptor
	 * @@return <code>true</code> if the element type is duplicated,
	 *         <code>false</code> otherwise.
	 */
	private boolean checkForDuplicate(ElementTypeDescriptor typeDescriptor) {
		if (specializationTypeDescriptors.containsKey(typeDescriptor.getId())) {
			Log
					.error(
							EMFTypePlugin.getPlugin(),
							EMFTypePluginStatusCodes.TYPE_NOT_INITED,
							EMFTypeCoreMessages
									.bind(
											EMFTypeCoreMessages.type_not_init_WARN_,
											typeDescriptor.getId(),
											EMFTypeCoreMessages.type_reason_duplicate_id_WARN_));
			return true;
		}
		return false;
	}
}@


1.5
log
@[136760] gmf_head ldamus 060426  ElementTypeRegistry prevents deployment of different applications sharing the same metamodel
@
text
@d37 1
d276 24
d312 1
a312 1
			ElementTypeDescriptor type, IClientContext clientContext) {
d331 1
a331 1
	private List getSpecializationTypeDescriptors(ElementTypeDescriptor type,
d335 22
a356 20

		// Get the immediate specializations
		Set specializationDescriptors = (Set) specializationsForTypeId.get(type
			.getId());

		if (specializationDescriptors != null) {
			Set specializations = new HashSet();

			for (Iterator i = specializationDescriptors.iterator(); i.hasNext();) {
				SpecializationTypeDescriptor nextDescriptor = (SpecializationTypeDescriptor) i
					.next();

				if (clientContext.includes(nextDescriptor)) {
					if (nextDescriptor != null) {
						specializations.add(nextDescriptor);
	
						if (deep) {
							// Recursively search for specializations
							result.addAll(getSpecializationTypeDescriptors(
								nextDescriptor, deep, clientContext));
d360 3
a363 3
			// Add the immediate specializations last, so that a breadth-first
			// order is maintained
			result.addAll(specializations);
@


1.5.2.1
log
@[151097] gmf_R1_0_maintenance ldamus 060802 Connections with semantic meaning can be incorrectly reoriented to shapes
@
text
@a36 1
import org.eclipse.gmf.runtime.emf.type.core.IElementTypeDescriptor;
a274 24
	
	/**
	 * Gets a list containing all specializations of <code>type</code>, in
	 * breadth-first order.
	 * 
	 * @@param type
	 *            the element type
	 * @@param clientContext
	 *            the client context
	 * @@return the array of all specializations of <code>type</code>
	 */
	public ISpecializationType[] getAllSpecializationTypes(
			IElementTypeDescriptor type, IClientContext clientContext) {

		List descriptors = getSpecializationTypeDescriptors(type, true, clientContext);
		ISpecializationType[] result = new ISpecializationType[descriptors.size()];
		int index = 0;
		
		for (Iterator i = descriptors.iterator(); i.hasNext(); index++) {
			SpecializationTypeDescriptor next = (SpecializationTypeDescriptor) i.next();
			result[index] = (ISpecializationType) next.getElementType();
		}
		return result;
	}
d287 1
a287 1
			IElementTypeDescriptor type, IClientContext clientContext) {
d306 1
a306 1
	private List getSpecializationTypeDescriptors(IElementTypeDescriptor type,
d310 20
a329 22
		
		if (type != null) {
			// Get the immediate specializations
			Set specializationDescriptors = (Set) specializationsForTypeId.get(type
				.getId());
	
			if (specializationDescriptors != null) {
				Set specializations = new HashSet();
	
				for (Iterator i = specializationDescriptors.iterator(); i.hasNext();) {
					SpecializationTypeDescriptor nextDescriptor = (SpecializationTypeDescriptor) i
						.next();
	
					if (clientContext.includes(nextDescriptor)) {
						if (nextDescriptor != null) {
							specializations.add(nextDescriptor);
		
							if (deep) {
								// Recursively search for specializations
								result.addAll(getSpecializationTypeDescriptors(
									nextDescriptor, deep, clientContext));
							}
a332 3
				// Add the immediate specializations last, so that a breadth-first
				// order is maintained
				result.addAll(specializations);
d334 3
@


1.4
log
@[129773] gmf_head cdamus 060306 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
a31 1

d33 1
d39 1
d262 1
a262 2
	 * Gets a list containing the immediate specializations of
	 * <code>type</code>.
d266 4
a269 2
	 * @@return the list of all <code>SpecializationTypeDescriptor</code>
	 *         s of <code>type</code>
d272 2
a273 2
			ElementTypeDescriptor type) {
		return getSpecializationTypeDescriptors(type, false);
d282 2
d287 1
a287 1
			ElementTypeDescriptor type) {
d289 1
a289 1
		return getSpecializationTypeDescriptors(type, true);
d307 1
a307 1
			boolean deep) {
d322 9
a330 7
				if (nextDescriptor != null) {
					specializations.add(nextDescriptor);

					if (deep) {
						// Recursively search for specializations
						result.addAll(getSpecializationTypeDescriptors(
							nextDescriptor, deep));
d344 3
d356 2
a357 2
			MetamodelTypeDescriptor metamodelTypeDescriptor) {

d362 2
a363 1
		List specializations = getAllSpecializationTypeDescriptors(metamodelTypeDescriptor);
d391 3
d401 2
d406 2
a407 2
			EObject eContainer, EReference reference) {

d413 1
a413 1
			type, eContainer, reference);
d420 1
a420 1
				.next(), eContainer, reference));
d487 2
d494 1
a494 1
			EReference feature) {
d497 2
a498 1
		Collection specializationDescriptors = getImmediateSpecializationTypeDescriptors(typeDescriptor);
d503 6
d581 2
a582 1
	 * match <code>eObject</code>. The advice is ordered from most general
d585 3
d593 2
d598 1
a598 1
			MetamodelTypeDescriptor metamodelTypeDescriptor) {
d608 1
a608 1
					ALL));
d613 1
a613 1
			eObject, ALL_NONE));
d617 1
a617 1
			eObject, metamodelTypeDescriptor);
d625 1
a625 1
				eObject, ALL_NONE));
d633 3
a635 2
	 * the inheritable advice bounds to its supertypes. The advice is ordered
	 * from most general advice (inherited from metamodel supertypes) to most
d637 3
d646 2
d651 2
a652 2
			MetamodelTypeDescriptor metamodelTypeDescriptor) {

d655 1
a655 1
		String metamodelTypeId = (metamodelTypeDescriptor != null) ?metamodelTypeDescriptor.getId() : null;
d665 1
a665 1
								ALL_NONE));
d668 1
a668 1
				result.addAll(getMatchingAdvice(nextSupertype.getId(), ALL));
d673 1
a673 1
		result.addAll(getMatchingAdvice(elementType.getId(), ALL_NONE));
d690 2
d695 1
a695 1
			Set adviceInheritanceToConsider) {
d703 5
a707 7
			// Filter out any of the bound advice that doesn't match
			if (!adviceMatches(eObject, nextAdviceDescriptor)) {
				continue;
			}
			
			if (adviceInheritanceToConsider.contains(nextAdviceDescriptor
					.getInheritance())) {
d709 9
a717 5
				IEditHelperAdvice nextAdvice = nextAdviceDescriptor
					.getEditHelperAdvice();

				if (nextAdvice != null) {
					result.add(nextAdvice);
d734 2
d739 1
a739 1
			Set adviceInheritanceToConsider) {
d746 2
d749 9
a757 8
			if (adviceInheritanceToConsider.contains(nextAdviceDescriptor
					.getInheritance())) {
				
				IEditHelperAdvice nextAdvice = nextAdviceDescriptor
					.getEditHelperAdvice();

				if (nextAdvice != null) {
					result.add(nextAdvice);
d766 3
a768 1
	 * type ID and also to patterns matching the element type ID.
d832 1
a832 1
				(Collection) adviceBindings.get("*"), //$NON-NLS-1$
d859 18
d878 7
@


1.3
log
@[120871] gmf_head ldamus 051222 org.eclipse.gmf.runtime.emf.type.core needs NLS sweep
@
text
@d24 1
d366 1
a366 4
				List matchingAdvice = getAdviceMatching(eObject, Collections
					.singletonList(adviceDescriptor));

				if (!matchingAdvice.isEmpty()) {
d411 2
a412 3
	 * Gets the list of edit helper advice descriptors that match
	 * <code>eObject</code>, from the collection of descriptors in
	 * <code>editHelperAdviceDescriptors</code>.
d416 3
a418 5
	 * @@param editHelperAdviceDescriptors
	 *            a collection of <code>IEditHelperAdviceDescriptor</code> s
	 *            from which to find the ones that match <code>eObject</code>
	 * @@return a list of <code>IEditHelperAdviceDescriptor</code> s that match
	 *         <code>eObject</code>
d420 2
a421 4
	private List getAdviceMatching(EObject eObject,
			Collection editHelperAdviceDescriptors) {

		List result = new ArrayList();
d425 2
a426 5
		for (Iterator i = editHelperAdviceDescriptors.iterator(); i.hasNext();) {
			IEditHelperAdviceDescriptor nextAdviceDescriptor = (IEditHelperAdviceDescriptor) i
				.next();
			IContainerDescriptor container = nextAdviceDescriptor
				.getContainerDescriptor();
d428 2
a429 2
			if (container != null) {
				IElementMatcher containerMatcher = container.getMatcher();
d431 3
a433 4
				if (containerMatcher != null
					&& !containerMatcher.matches(eObject.eContainer())) {
					continue;
				}
d435 6
d442 3
a444 4
			EReference[] features = null;
			if (container != null) {
				features = container.getContainmentFeatures();
			}
d446 1
a446 3
			if (features == null || features.length < 1) {
				// All features that can contain this type's EClass are valid
				IElementMatcher matcher = nextAdviceDescriptor.getMatcher();
d448 1
a448 4
				if (matcher == null
					|| (matcher != null && matcher.matches(eObject))) {
					result.add(nextAdviceDescriptor);
				}
d450 1
a450 1
			} else {
d452 3
a454 1
				for (int j = 0; j < features.length; j++) {
d456 1
a456 11
					if (features[j] == containmentFeature) {
						IElementMatcher matcher = nextAdviceDescriptor
							.getMatcher();

						if (matcher == null) {
							result.add(nextAdviceDescriptor);

						} else if (matcher.matches(eObject)) {
							result.add(nextAdviceDescriptor);
						}
					}
d461 1
a461 1
		return result;
d570 1
a570 1
		List result = new ArrayList();
d598 1
a598 1
		return result;
d661 3
a663 1
		Set adviceDescriptors = (Set) adviceBindings.get(elementTypeId);
a664 1
		if (adviceDescriptors != null) {
d666 9
a674 6
			List matchingAdviceDescriptors = getAdviceMatching(eObject,
				adviceDescriptors);

			for (Iterator j = matchingAdviceDescriptors.iterator(); j.hasNext();) {
				IEditHelperAdviceDescriptor nextAdviceDescriptor = (IEditHelperAdviceDescriptor) j
					.next();
d676 2
a677 9
				if (adviceInheritanceToConsider.contains(nextAdviceDescriptor
						.getInheritance())) {
					
					IEditHelperAdvice nextAdvice = nextAdviceDescriptor
						.getEditHelperAdvice();

					if (nextAdvice != null) {
						result.add(nextAdvice);
					}
d701 3
a703 1
		Set adviceDescriptors = (Set) adviceBindings.get(elementTypeId);
d705 5
a709 1
		if (adviceDescriptors != null) {
d711 43
a753 3
			for (Iterator j = adviceDescriptors.iterator(); j.hasNext();) {
				IEditHelperAdviceDescriptor nextAdviceDescriptor = (IEditHelperAdviceDescriptor) j
					.next();
d755 7
a761 5
				if (adviceInheritanceToConsider.contains(nextAdviceDescriptor
						.getInheritance())) {
					
					IEditHelperAdvice nextAdvice = nextAdviceDescriptor
						.getEditHelperAdvice();
d763 11
a773 2
					if (nextAdvice != null) {
						result.add(nextAdvice);
d775 2
d778 2
d782 5
a786 1
		return result;
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d48 1
a48 1
import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.ResourceManager;
d780 9
a788 5
			Log.error(EMFTypePlugin.getPlugin(),
				EMFTypePluginStatusCodes.TYPE_NOT_INITED, ResourceManager
					.getMessage(EMFTypePluginStatusCodes.TYPE_NOT_INITED_KEY,
						new String[] {typeDescriptor.getId(),
							EMFTypePluginStatusCodes.TYPE_DUPLICATE_KEY}));
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

