head	1.9;
access;
symbols
	v20081020-0700:1.9
	v20080807-1333:1.9
	v20080807-1325:1.9
	v20080731-1520:1.9
	v20080725-1738:1.9
	v20080722-1827:1.9
	R2_1_maintenance:1.9.0.6
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080425-1959:1.9
	v20080328-1605:1.9
	v20080222-1200:1.9
	v20080114-2222:1.9
	v20080107-1111:1.9
	v20071130-1111:1.9
	v20071124-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.4
	R2_0:1.9
	R4_20:1.9
	RC3_20:1.9
	v20070601-1400:1.9
	v20070518-1300:1.9
	v20070403-1500:1.9
	v20070330-1300:1.9
	v20070208-1800:1.9
	M4_20:1.9
	v20061214-0000:1.9
	M3_20:1.9
	v20061117-0800:1.9
	v20061013-1330:1.9
	v20060919-0800:1.9
	v20060907-1100:1.9
	M1_20:1.9
	v20060831-1500:1.9
	v20060817-1500:1.9
	v20060803-1200:1.9
	v20060721-1130:1.9
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060616-1200:1.9
	v20060609-1400:1.9
	v20060531-1730:1.9
	v20060530-1930:1.9
	v20060526-1200:1.9
	v20060519-0800:1.9
	I20060505-1400:1.8
	I20060428-1300:1.8
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.4
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.9
date	2006.05.17.14.00.28;	author ldamus;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.27.19.52.29;	author ldamus;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.26.20.14.33;	author ldamus;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.03.17.40.00;	author ldamus;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.15.17.33.08;	author ldamus;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.13.19.12.20;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.22.19.02.01;	author ldamus;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.26.55;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.49;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.9
log
@[137749] gmf_head ldamus 060517 Transfer GEF Request's extended data into IEditCommandRequest's parameters
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.type.core.requests;

import java.text.MessageFormat;
import java.util.Collections;
import java.util.List;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.common.core.command.ICommand;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.emf.type.core.ClientContextManager;
import org.eclipse.gmf.runtime.emf.type.core.IClientContext;
import org.eclipse.gmf.runtime.emf.type.core.IElementType;
import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypeDebugOptions;
import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePlugin;
import org.eclipse.gmf.runtime.emf.type.core.internal.EMFTypePluginStatusCodes;
import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.EMFTypeCoreMessages;

/**
 * Request to create a new model element.
 * <P>
 * If the request is not constructed with the editing domain through which to
 * create the new model element, it will be derived from the container element.
 * 
 * @@author ldamus
 */
public class CreateElementRequest extends AbstractEditCommandRequest {

	/**
	 * The container for the new model element.
	 */
	private EObject container;

	/**
	 * The feature in the container which will hold the new model element. Can
	 * be <code>null</code>, in which case a default feature will be used.
	 */
	private EReference containmentFeature;

	/**
	 * The element type of the new model element.
	 */
	private final IElementType elementType;

	/**
	 * The new model element. Will be <code>null</code> until the new element
	 * has been created. Once the new element has been created, it will be set
	 * so that 'after' advice can further manipulate the new element.
	 */
	private EObject newElement;

	/**
	 * The edit context command.
	 */
	private ICommand editContextCommand;
    
    /**
     * Flag indicating that we are in the process of making the request for the
     * edit context. The edit context request and command will not be
     * invalidated if the container or containment feature is set during this
     * time.
     */
    private boolean requestingEditContext;

	/**
	 * The edit context request.
	 */
	private GetEditContextRequest editContextRequest;

	/**
	 * Creates a request to create a new model element.
	 * 
	 * @@param editingDomain
	 *            the editing domain in which I am requesting to make model
	 *            changes.
	 * @@param container
	 *            the container for the new model element
	 * @@param elementType
	 *            the element type of the new model element
	 */
	public CreateElementRequest(TransactionalEditingDomain editingDomain,
			EObject container, IElementType elementType) {

		this(editingDomain, container, elementType, null);
	}
    
    /**
     * Creates a request to create a new model element. The editing domain will
     * be derived from the <code>container</code>.
     * 
     * @@param container
     *            the container for the new model element
     * @@param elementType
     *            the element type of the new model element
     */
    public CreateElementRequest(EObject container, IElementType elementType) {
        
        this(TransactionUtil.getEditingDomain(container), container, elementType, null);
    }
    
	/**
     * Creates a request to create a new model element. The editing domain will
     * be derived from the result of {@@link #getContainer()}.
     * 
     * @@param elementType
     *            the element type of the new model element
     */
    public CreateElementRequest(IElementType elementType) {

        this(null, null, elementType, null);
    }
    
    /**
     * Creates a request to create a new model element.
     * 
     * @@param editingDomain
     *            the editing domain in which I am requesting to make model
     *            changes.
     * @@param elementType
     *            the element type of the new model element
     */
    public CreateElementRequest(TransactionalEditingDomain editingDomain,
            IElementType elementType) {

        this(editingDomain, null, elementType, null);
    }

	/**
	 * Creates a request to create a new model element.
	 * 
	 * @@param editingDomain
	 *            the editing domain in which I am requesting to make model
	 *            changes.
	 * @@param container
	 *            the container for the new model element
	 * @@param elementType
	 *            the element type of the new model element
	 * @@param containmentFeature
	 *            The feature in the container which will hold the new model
	 *            element. Can be <code>null</code>, in which case a default
	 *            feature will be used.
	 */
	public CreateElementRequest(TransactionalEditingDomain editingDomain,
			EObject container, IElementType elementType,
			EReference containmentFeature) {

		super(editingDomain);
		this.container = container;
		this.elementType = elementType;
		this.containmentFeature = containmentFeature;
	}
    
    /**
     * Creates a request to create a new model element.  The editing domain will
     * be derived from the <code>container</code>.
     * 
     * @@param container
     *            the container for the new model element
     * @@param elementType
     *            the element type of the new model element
     * @@param containmentFeature
     *            The feature in the container which will hold the new model
     *            element. Can be <code>null</code>, in which case a default
     *            feature will be used.
     */
    public CreateElementRequest(EObject container, IElementType elementType,
            EReference containmentFeature) {

        this(TransactionUtil.getEditingDomain(container), container,
            elementType, containmentFeature);
    }

	/**
	 * Gets the new element that has been created by this request.
	 * 
	 * @@return the newly created element
	 */
	public EObject getNewElement() {
		return newElement;
	}

	/**
	 * Sets the element that has been created by this request.
	 * 
	 * @@param element
	 *            the newly created element
	 */
	public void setNewElement(EObject element) {
		this.newElement = element;
	}

	/**
	 * Gets the containment feature in which to create the new element. May be
	 * <code>null</code>.
	 * 
	 * @@return the containment feature or <code>null</code> if one has not
	 *         been specified.O
	 */
	public EReference getContainmentFeature() {
		return containmentFeature;
	}

	/**
	 * Sets the containment feature in which to create the new element.
	 * <p>
	 * Does nothing of the feature has not changed. Othewise, invalidates the
	 * edit helper context.
	 * 
	 * @@param containmentFeature
	 *            the containment feature
	 */
	public void setContainmentFeature(EReference containmentFeature) {
        if (this.containmentFeature != containmentFeature) {
            this.containmentFeature = containmentFeature;
            invalidateEditHelperContext();
        }
	}
    
    /**
     * Sets the containment feature in which to create the new element.
     * <p>
     * Does nothing of the feature has not changed. Does not invalidate the
     * edit helper context.
     * 
     * @@param containmentFeature
     *            the containment feature
     */
    public void initializeContainmentFeature(EReference feature) {
        if (this.containmentFeature != feature) {
            this.containmentFeature = feature;
        }
    }

	/**
	 * Gets the original context in which the new element will be created. This
	 * may not be the actual container of the new element until the
	 * <code>createContainer</code> method is called.
	 * 
	 * @@return the container for the new element.
	 */
	public EObject getContainer() {
		return container;
	}

	/**
	 * Sets the appropriate <code>container</code> for the new element. May
	 * prompt the user to create the container, so this method should only be
	 * called when the command honouring the request is executed.
	 * <P>
	 * Updates the value returned by the <code>getContainer</code>, if
	 * appropriate.
	 * 
	 * @@return the container for the new element
	 */
	public EObject createContainer() {

		Object result = null;

		ICommand contextCommand = getEditContextCommand();

		if (contextCommand != null && contextCommand.canExecute()) {
            try {
                contextCommand.execute(new NullProgressMonitor(), null);

                CommandResult commandResult = contextCommand.getCommandResult();

                if (commandResult.getStatus().getCode() == IStatus.OK) {
                    result = commandResult.getReturnValue();
                }
            } catch (ExecutionException e) {
                Trace.catching(EMFTypePlugin.getPlugin(),
                    EMFTypeDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                    "createContainer", e); //$NON-NLS-1$
                Log.error(EMFTypePlugin.getPlugin(),
                    EMFTypePluginStatusCodes.COMMAND_FAILURE, e
                        .getLocalizedMessage(), e);
            }
		}
		if (result == null || result instanceof EObject) {
			container = (EObject) result;
		}
		return getContainer();
	}

	/**
	 * Gets a command that will return the edit context for the request.
	 * 
	 * @@return the command
	 */
	private ICommand getEditContextCommand() {

		if (editContextCommand == null) {
            requestingEditContext = true;
            try {
    			editContextCommand = getElementType().getEditCommand(
    					getEditContextRequest());
            } finally {
                requestingEditContext = false;
            }
		}
		return editContextCommand;
	}

	/**
	 * Gets the edit context request.
	 * 
	 * @@return the edit context request
	 */
	private GetEditContextRequest getEditContextRequest() {

		if (editContextRequest == null) {
			editContextRequest = new GetEditContextRequest(getEditingDomain(), this,
					getElementType());
			// Initialize the context with the container and the client context
			editContextRequest.setEditContext(getContainer());
			editContextRequest.setClientContext(getClientContext());
			editContextRequest.addParameters(getParameters());
		}
		return editContextRequest;
	}

	/**
	 * Sets the container for the new element.
	 * <p>
	 * Does nothing of the container has not changed. Othewise, invalidates the
	 * edit helper context and containment feature.
	 * 
	 * @@param container
	 *            the container for the new element.
	 */
	public void setContainer(EObject container) {
		if (this.container != container) {
			this.container = container;
            
            if (!requestingEditContext) {
                editContextCommand = null;
                
                if (editContextRequest != null) {
                    editContextRequest.setEditContext(container);
                }
            }
            invalidateContainmentFeature();
		}
	}
	
	public void setClientContext(IClientContext clientContext) {
		super.setClientContext(clientContext);
		
		if (editContextRequest != null) {
            editContextRequest.setClientContext(clientContext);
        }
	}
	
	/**
	 * Infers the client context from {@@link #getElementType()} if the context
	 * has not be explicity set.
	 */
	public IClientContext getClientContext() {

		IClientContext result = super.getClientContext();
		IElementType type = getElementType();

		if (result == null && type != null) {
			result = ClientContextManager.getInstance().getBinding(type);
		}
		return result;
	}

	/**
	 * Gets the element type for the new model element.
	 * 
	 * @@return the element type
	 */
	public IElementType getElementType() {
		return elementType;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.IEditCommandRequest#getElementsToEdit()
	 */
	public List getElementsToEdit() {
		if (getContainer() != null) {
			return Collections.singletonList(getContainer());
		}
		return super.getElementsToEdit();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditCommandRequest#getDefaultLabel()
	 */
	protected String getDefaultLabel() {

		String label = MessageFormat.format(
				EMFTypeCoreMessages.Request_Label_Create,
				new Object[] { getElementType().getDisplayName() });

		return label;
	}

	/**
	 * Makes a request for the context of the new element from its element type.
	 * Allows specializations and advice bindings to return the appropriate
	 * context, if necessary.
	 * <P>
	 * The <code>GetContextCommand</code> will not be executed. This method
	 * relies on the command to return the new context element type until it is
	 * executed, at which point it can return the real context element, if a new
	 * one needs to be created.
	 * 
	 * @@return the edit helper context
	 */
	public Object getEditHelperContext() {
		
		// Get, but don't execute the command. Gives clients a chance to set the
		// edit context in the request, if they need to.
		ICommand contextCommand = getEditContextCommand();

		// The request should now have the correct edit context.
		if (contextCommand != null && contextCommand.canExecute()) {
			return getEditContextRequest().getEditContext();
		}
		return null;
	}

	public void setParameter(String parameterName, Object value) {
		super.setParameter(parameterName, value);
	}

	/**
	 * Invalidates the cached edit context request and command.
	 */
	protected void invalidateEditHelperContext() {
        if (!requestingEditContext) {
    		editContextCommand = null;
    		editContextRequest = null;
        }
	}

	/**
	 * Invalidates the cached containment feature.
	 */
	protected void invalidateContainmentFeature() {
        if (!requestingEditContext) {
            containmentFeature = null;
        }
	}
    
    public TransactionalEditingDomain getEditingDomain() {
        TransactionalEditingDomain result = super.getEditingDomain();

        EObject c = getContainer();
        if (result == null && c != null) {
            // get the editing domain from the container
            result = TransactionUtil.getEditingDomain(c);
        }
        return result;
    }
}@


1.8
log
@[136760] gmf_head ldamus 060427  Infer client context from element type in create request if not explicitly set
@
text
@d335 1
@


1.7
log
@[136760] gmf_head ldamus 060426  ElementTypeRegistry prevents deployment of different applications sharing the same metamodel
@
text
@d29 1
d370 15
@


1.6
log
@[129582] gmf_head ldamus 060403 Edit helpers  second pass over getCreationEditContext() causes errors
[132253] gmf_head ldamus 060403 change CreateElementRequest.setContainer to not nullify edit context request
@
text
@d29 1
d331 1
a331 1
			// Initialize the context with the container
d333 1
d361 8
d418 1
a418 1

@


1.5
log
@[131766] gmf_head ldamus 060315 M5 migration - java viz adding a note attachment causes NullPointer related to gmf SemanticEditPolicy
@
text
@d72 8
d229 4
a232 4
		if (this.containmentFeature != containmentFeature) {
			this.containmentFeature = containmentFeature;
			invalidateEditHelperContext();
		}
d234 15
d309 7
a315 2
			editContextCommand = getElementType().getEditCommand(
					getEditContextRequest());
d348 9
a356 2
			invalidateEditHelperContext();
			invalidateContainmentFeature();
d428 4
a431 2
		editContextCommand = null;
		editContextRequest = null;
d438 3
a440 1
		containmentFeature = null;
@


1.4
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d407 4
a410 2
        if (result == null) {
            result = TransactionUtil.getEditingDomain(getContainer());
@


1.3
log
@[120871] gmf_head ldamus 051222 org.eclipse.gmf.runtime.emf.type.core needs NLS sweep
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d18 1
d23 2
a24 1

d27 2
d30 3
d37 3
d43 1
a43 2
public class CreateElementRequest
	extends AbstractEditCommandRequest {
d81 3
d89 2
a90 1
	public CreateElementRequest(EObject container, IElementType elementType) {
d92 1
a92 1
		this(container, elementType, null);
d94 38
d133 2
a134 10
	/**
	 * Creates a request to create a new model element.
	 * 
	 * @@param elementType
	 *            the element type of the new model element
	 */
	public CreateElementRequest(IElementType elementType) {

		this(null, elementType, null);
	}
d139 3
d151 2
a152 1
	public CreateElementRequest(EObject container, IElementType elementType,
d155 1
a155 1
		super();
d160 20
d254 17
a270 7
		if (contextCommand != null && contextCommand.isExecutable()) {
			contextCommand.execute(new NullProgressMonitor());
			CommandResult commandResult = contextCommand.getCommandResult();

			if (commandResult.getStatus().getCode() == IStatus.OK) {
				result = commandResult.getReturnValue();
			}
d287 1
a287 1
				getEditContextRequest());
d300 2
a301 2
			editContextRequest = new GetEditContextRequest(this,
				getElementType());
d379 1
a379 1
		if (contextCommand != null && contextCommand.isExecutable()) {
d396 1
a396 1
	
d403 9
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d26 1
a26 1
import org.eclipse.gmf.runtime.emf.type.core.internal.l10n.ResourceManager;
d276 3
a278 5
		String createString = ResourceManager.getInstance().getString(
			"Request.Label.Create"); //$NON-NLS-1$

		String label = MessageFormat.format(createString,
			new Object[] {getElementType().getDisplayName()});
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

