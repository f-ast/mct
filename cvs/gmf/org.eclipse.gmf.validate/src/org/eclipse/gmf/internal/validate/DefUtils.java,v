head	1.7;
access;
symbols
	v20080722-1827:1.7
	R2_1_maintenance:1.7.0.4
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080603-1553:1.7
	v20080507-2230:1.7
	v20080425-1959:1.7
	v20080417-1610:1.7
	v20080322-0000:1.7
	v20080222-1200:1.7
	v20080215-1500:1.7
	v20070809-0000:1.7
	R2_0_maintenance:1.7.0.2
	R2_0:1.7
	R4_20:1.7
	v20070621-0000:1.7
	RC3_20:1.7
	v20070601-1400:1.7
	v20070520-1200:1.7
	v20070504-1000:1.6
	v20070405-1100:1.6
	v20070330-1300:1.6
	v20070322-1100:1.6
	v20060316-0600:1.5
	v20070208-1800:1.4
	M4_20:1.4
	v20061218-1200:1.4
	v20061214-0000:1.4
	v20061120-1300:1.4
	M3_20:1.3
	v20061117-0800:1.3
	v20061027-1200:1.2.2.2
	v20061013-1330:1.2
	v20060925-1700:1.2.2.1
	v20060919-0800:1.2.2.1
	M1_20:1.2
	v20060904-1500:1.2
	v20060831-1500:1.2
	v20060803-1200:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060626-1420:1.2
	v20060616-1200:1.2
	v20060531-1730:1.2;
locks; strict;
comment	@# @;


1.7
date	2007.05.18.22.54.18;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	29e3464e2e9a4567;

1.6
date	2007.03.21.23.23.57;	author radvorak;	state Exp;
branches;
next	1.5;
commitid	10c44601be8c4567;

1.5
date	2007.03.14.12.59.24;	author atikhomirov;	state Exp;
branches;
next	1.4;
commitid	110745f7f1aa4567;

1.4
date	2006.11.20.17.30.41;	author radvorak;	state Exp;
branches;
next	1.3;
commitid	1fc64561e63f4567;

1.3
date	2006.10.24.17.11.53;	author radvorak;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.25.14.37.56;	author radvorak;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.05.18.13.58.29;	author radvorak;	state Exp;
branches;
next	;

1.2.2.1
date	2006.09.13.23.07.18;	author rgronback;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2006.10.26.23.56.32;	author radvorak;	state Exp;
branches;
next	;


desc
@@


1.7
log
@minor beautify
@
text
@/*
 * Copyright (c) 2005, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors: 
 *    Radek Dvorak (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.validate;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.codegen.ecore.genmodel.GenClassifier;
import org.eclipse.emf.codegen.ecore.genmodel.GenModelPackage;
import org.eclipse.emf.common.util.BasicDiagnostic;
import org.eclipse.emf.common.util.Diagnostic;
import org.eclipse.emf.common.util.DiagnosticChain;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EModelElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.EcorePackage;

import org.eclipse.gmf.internal.validate.IDefElementProvider.ContextProvider;
import org.eclipse.gmf.internal.validate.IDefElementProvider.StringValProvider;
import org.eclipse.gmf.internal.validate.IDefElementProvider.TypeProvider;
import org.eclipse.gmf.internal.validate.expressions.IModelExpression;
import org.eclipse.gmf.internal.validate.expressions.IModelExpressionProvider;
import org.eclipse.ocl.ecore.EcoreEnvironmentFactory;

import org.eclipse.osgi.util.NLS;

public class DefUtils {
	
	/**
	 * Prevent from instantation 
	 */
	private DefUtils() {		
	}
	
	public static class FeatureValProvider extends AbstractProvider implements StringValProvider {
		private EStructuralFeature feature;
		
		public FeatureValProvider(EStructuralFeature feature) {
			if(feature == null) {
				throw new IllegalArgumentException("null feature passed"); //$NON-NLS-1$
			}
			this.feature = feature;
			setStatus(validateFeature(feature));			
		}
		
		public String getValue(EObject contextInstance) {
			if(!feature.getEContainingClass().isSuperTypeOf(contextInstance.eClass())) {
				throw new IllegalArgumentException("Invalid context instance"); //$NON-NLS-1$
			}
			if(!getStatus().isOK()) {
				return null;
			}
			Object value = contextInstance.eGet(feature);
			assert value == null || value instanceof String;
			return (String)contextInstance.eGet(feature);
		}
		
		public String toString() {
			StringBuffer buf = new StringBuffer();
			buf.append("lang: ") //$NON-NLS-1$
				.append(feature.getEContainingClass().getName()) 
				.append("::").append(feature.getName()); //$NON-NLS-1$			
			return buf.toString();
		}
		
		private static IStatus validateFeature(EStructuralFeature feature) {
			if(feature.getEType() == EcorePackage.eINSTANCE.getEString()) {
				return Status.OK_STATUS;
			}
			String requiredType = LabelProvider.INSTANCE.getObjectLabel(
					EcorePackage.eINSTANCE.getEString());
			String foundType = LabelProvider.INSTANCE.getObjectLabel(feature.getEType());
			String message = MessageFormat.format(
					Messages.incompatibleTypes, 
					new Object[] { requiredType, foundType });
			return GMFValidationPlugin.createStatus(IStatus.ERROR, 
					StatusCodes.INVALID_EXPRESSION_TYPE, message, null);
		}		
	}
	
	
	private abstract static class AbstractProvider implements IDefElementProvider {
		private IStatus status = Status.OK_STATUS;
		
		AbstractProvider() {}
		
		protected void setStatus(IStatus status) {
			if(status == null) {
				throw new IllegalArgumentException("Null status"); //$NON-NLS-1$
			}
			this.status = status;
		}
		public IStatus getStatus() {
			return status;
		}
	}
	

	private static class ExpressionBasedProvider extends AbstractProvider implements IDefElementProvider {
		private IModelExpression expression;
		private EClassifier requiredType;
	
		protected ExpressionBasedProvider(IModelExpression expression, EClassifier requiredType) {
			this.expression = expression;
			this.requiredType = requiredType;
			if(!expression.getStatus().isOK()) {
				setStatus(expression.getStatus());				
			} else {
				EClassifier queryResultType = expression.getResultType();
				assert queryResultType != null : "Expression must have type"; //$NON-NLS-1$
				assert requiredType != null : "Required type must be defined"; //$NON-NLS-1$
				if(!checkTypeAssignmentCompatibility(requiredType, queryResultType)) {
					setStatus(getIncompatibleTypesStatus(requiredType, queryResultType));
				}
			}
		}
		
		protected IModelExpression getExpression() {
			return expression;
		}
		
		protected EClassifier getRequiredType() {
			return requiredType;
		}
		
		public Object evaluate(EObject resolutionContext) {
			return expression.evaluate(resolutionContext);
		}
		
		public String toString() {
			return expression.toString();
		}
	}

	// Remark: Backward compatibility for String expression as qualified name of EClassifier
	// With MDT OCL, TypeLiteral expression can be used, having the its referred type as
	// the result of OCL expression evaluation
	// TODO - Can be replaced by <code>ExpressionContextProvider</code> as soon as definitions in GMF models 
	// using OCL to define contexts do not use qualified name (String)
	//       @@constraintsMeta(def="context", ocl="'ecore::EDoubleObject'") => @@constraintsMeta(def="context", ocl="ecore::EDoubleObject")	
	public static class LookupByNameContextProvider extends ExpressionBasedProvider implements ContextProvider {
		private Map<Object, EClassifier> contextCache = new HashMap<Object, EClassifier>(5);
		private EPackage.Registry registry;		
		
		public LookupByNameContextProvider(IModelExpression expression, EPackage.Registry registry) {
			super(expression, EcorePackage.eINSTANCE.getEString());
			this.registry = (registry != null) ? registry : EPackage.Registry.INSTANCE; 
		}
		
		public EClassifier getContextClassifier(EObject resolutionContext) {
			if(getStatus().isOK()) {
				Object typeNameObj = evaluate(resolutionContext);
				if(typeNameObj instanceof String) {
					if(contextCache.containsKey(typeNameObj)) {
						return contextCache.get(typeNameObj);
					}
					String[] typeName = ((String)typeNameObj).split("::"); //$NON-NLS-1$
					ArrayList<String> nameSeq = new ArrayList<String>(Arrays.asList(typeName));
					if(typeName.length > 1) {
						EClassifier contextClassifier = new EcoreEnvironmentFactory(registry).createEnvironment().lookupClassifier(nameSeq);
						contextCache.put(typeNameObj, contextClassifier);
						return contextClassifier;
					}
				}
			}
			return null;
		}
	}
	
	
	
	public static class GenClassifierContextAdapter extends ExpressionBasedProvider implements ContextProvider {

		public static boolean isGenClassifier(EClassifier eClassifier) {
			if(eClassifier.getEPackage() == null ||
				!GenModelPackage.eNS_URI.equals(eClassifier.getEPackage().getNsURI())) {				
				return false;
			}
			return GenModelPackage.eINSTANCE.getGenClass().getName().equals(eClassifier.getName()) ||
					GenModelPackage.eINSTANCE.getGenClassifier().getName().equals(eClassifier.getName());			
		}
		
		public GenClassifierContextAdapter(IModelExpression expression) {
			super(expression, expression.getResultType());
			if(!isGenClassifier(expression.getResultType())) {
				getIncompatibleTypesStatus(GenModelPackage.eINSTANCE
						.getGenClassifier(), expression.getResultType());			
			}
		}
		
		public EClassifier getContextClassifier(EObject resolutionContext) {	
			if(!getStatus().isOK()) {
				return null;
			}
			GenClassifier genClassifier = (GenClassifier)super.evaluate(resolutionContext);
			return genClassifier != null ? genClassifier.getEcoreClassifier() : null;
		}		
	}	

	
	public static class ExpressionContextProvider extends ExpressionBasedProvider implements ContextProvider {

		public ExpressionContextProvider(IModelExpression expression) {
			super(expression, EcorePackage.eINSTANCE.getEClassifier());			
		}
		
		public EClassifier getContextClassifier(EObject resolutionContext) {			
			return getStatus().isOK() ? (EClassifier)super.evaluate(resolutionContext) : null;
		}		
	}
	
		
	public static class ReferencedContextProvider extends AbstractProvider implements ContextProvider {
		private EReference contextRef;
		private Map<EClass, ContextProvider> referencedContexts = Collections.emptyMap();		
		
		public ReferencedContextProvider(EClass context, String referenceName, IModelExpressionProvider oclExprProvider, EPackage.Registry registry) {
			if(context == null) {
				throw new IllegalArgumentException("null context EClass"); //$NON-NLS-1$
			}
			if(referenceName != null) {
				EStructuralFeature eFeature = context.getEStructuralFeature(referenceName);   
				if(eFeature instanceof EReference) {
					this.contextRef = (EReference) eFeature;					
				} else {
					String message = NLS.bind(Messages.def_NoEReferenceFoundByName, 
							referenceName, LabelProvider.INSTANCE.getObjectLabel(context));
					setStatus(GMFValidationPlugin.createStatus(IStatus.ERROR, -1, message, null));
				}
			} else {
				String message = Messages.def_NoEReferenceInCtxBinding;
				setStatus(GMFValidationPlugin.createStatus(IStatus.ERROR, -1, message, null));				
			}
			
			if(contextRef != null) {
				EClass referencedClass = contextRef.getEReferenceType();
				List<EClass> subTypes  = getSubTypes(getRootEPackage(referencedClass.getEPackage()), referencedClass, new LinkedList<EClass>());
				
				referencedContexts = new HashMap<EClass, ContextProvider>(5);				
				for (Iterator<EClass> it = subTypes.iterator(); it.hasNext();) {
					EClass nextClass = it.next();
					ContextProvider referencedContext = DefUtils.getContextClass(nextClass, oclExprProvider, null, registry);
					if(referencedContext != null) {
						referencedContexts.put(nextClass, referencedContext);
						it.remove();
					}
				}
				// perform coverage check
				List<IStatus> statuses = new ArrayList<IStatus>();
				for (Iterator<EClass> it = subTypes.iterator(); it.hasNext();) {
					EClass nextClass = it.next();
					
					if(getProvider(nextClass) == null && !(nextClass.isInterface() || nextClass.isAbstract())) {
						String message = NLS.bind(Messages.def_NoCtxInProviderForCtxBinding, 
								LabelProvider.INSTANCE.getObjectLabel(nextClass),
								LabelProvider.INSTANCE.getFeatureLabel(contextRef));
						statuses.add(GMFValidationPlugin.createStatus(IStatus.ERROR, -1, message, null));
					}
				}
				if(statuses.size() == 1) {
					setStatus(statuses.get(0));					
				} else {
					setStatus(new MultiStatus(GMFValidationPlugin.getPluginId(), -1,
							statuses.toArray(new IStatus[statuses.size()]),
							Messages.def_MissingCtxDefInReferencedCtxProviders, null));
				}
			}
		}
				
		public EClassifier getContextClassifier(EObject resolutionContext) {
			if(getStatus().isOK()) {
				if(!contextRef.getEContainingClass().isSuperTypeOf(resolutionContext.eClass())) {
					throw new IllegalArgumentException("Requires instance of :" + contextRef.getEContainingClass()); //$NON-NLS-1$
				}
				assert resolutionContext.eClass().getEStructuralFeature(contextRef.getName()) != null;
				
				Object referencedEntity = resolutionContext.eGet(contextRef);
				if(referencedEntity instanceof EObject) {
					EObject eObject = (EObject)referencedEntity;	
					ContextProvider provider = getProvider(eObject.eClass());
					return (provider != null && provider.getStatus().isOK()) ? 
							provider.getContextClassifier(eObject) : null;
				}				
			}
			return null;
		}		
		
		private ContextProvider getProvider(EClass contextProviderEClass) {
			ContextProvider provider = referencedContexts.get(contextProviderEClass);
			if(provider == null) {
				for (EClass nextClass : contextProviderEClass.getESuperTypes()) {
					ContextProvider nextProvider = referencedContexts.get(nextClass);
					if(nextProvider != null) {
						return nextProvider;
					}
				}
			}
			return provider;
		}
	}	

	public static class ExpresssionTypeProvider extends ExpressionBasedProvider implements TypeProvider {
		
		public ExpresssionTypeProvider(IModelExpression expression) {
			super(expression, getRequiredResultType(expression));
		}
		
		public boolean hasTypedElement() {
			if(getStatus().isOK()) {
				EClassifier requiredType = getCanonicalEClassifier(getRequiredType());			
				return requiredType instanceof EClass && 
					EcorePackage.eINSTANCE.getETypedElement().isSuperTypeOf((EClass)requiredType);
			}
			return false;
		}
		
		public EClassifier getType(EObject context) {
			if(!getStatus().isOK()) {
				return null;
			}			
			Object val = evaluate(context);
			if(val instanceof ETypedElement) {
				return ((ETypedElement)val).getEType();
			} else if(val instanceof EClassifier) {
				return (EClassifier)val;
			}
			assert false;
			return null;
		}
		
		public ETypedElement getTypedElement(EObject context) {
			if(!getStatus().isOK()) {
				return null;
			}			
			Object val = evaluate(context);
			if(val instanceof ETypedElement) {
				return (ETypedElement)val;
			} 
			return null;
		}

		private static EClassifier getRequiredResultType(IModelExpression expression) {
			EClassifier type = expression.getResultType();
			if(type instanceof EClass) {
				if(DefUtils.isEcorePackageClassifier(type)) {
					EClassifier canonicalClassifier = DefUtils.getCanonicalEcorePackageClassifier(type);
					assert canonicalClassifier instanceof EClass;
					EClass canonicalClass = (EClass)canonicalClassifier;
					if(EcorePackage.eINSTANCE.getETypedElement().isSuperTypeOf(canonicalClass) ||
						EcorePackage.eINSTANCE.getEClassifier().isSuperTypeOf(canonicalClass)) {
						return type;					
					}
				}
			}
			return EcorePackage.eINSTANCE.getEClassifier();
		}
	}
	
	public static class TypedElementProvider extends AbstractProvider implements TypeProvider {
		private EStructuralFeature feature;
		
		public TypedElementProvider(EStructuralFeature feature) {
			this.feature = feature;
		}
		
		public boolean hasTypedElement() {
			return true;			
		}
		
		public EClassifier getType(EObject context) {
			return getTypedElement(context).getEType();
		}
		
		public ETypedElement getTypedElement(EObject context) {
			return (ETypedElement)context.eGet(feature);
		}
	}
	
	public static class ContextTypeAdapter extends AbstractProvider implements TypeProvider {
		private ContextProvider ctxProvider;
		
		public ContextTypeAdapter(ContextProvider contextProvider) {
			if(contextProvider == null) {
				throw new IllegalArgumentException("null contextProvider"); //$NON-NLS-1$
			}
			this.ctxProvider = contextProvider;
		}
		
		public EClassifier getType(EObject resolutionContext) {		
			return ctxProvider.getContextClassifier(resolutionContext);
		}
		
		public boolean hasTypedElement() {		
			return false;
		}
		
		public ETypedElement getTypedElement(EObject context) {
			return null;
		}
	}		
	
	public static Diagnostic statusToDiagnostic(IStatus status, String diagSource, Object destObj) {
		return statusToDiagnostic(status, diagSource, destObj, null);
	}
	
	public static DiagnosticChain mergeAndFlatten(Diagnostic diagnostic, DiagnosticChain diagnosticChain) {
		List<Diagnostic> children = diagnostic.getChildren();
		if(children == null || children.isEmpty()) {
			diagnosticChain.add(diagnostic);
		} else {
			for (Diagnostic next : children) {
				mergeAndFlatten(next, diagnosticChain);
			}
		}
		return diagnosticChain;
	}
	
	public static DiagnosticChain mergeAndFlatten(IStatus status, String diagSource, Object destObj, DiagnosticChain diagnosticChain) {
		Diagnostic diagnostic = statusToDiagnostic(status, diagSource, destObj);
		return mergeAndFlatten(diagnostic, diagnosticChain);
	}
	
	
	public static Diagnostic statusToDiagnostic(IStatus status, String diagSource, Object destObj, String prefixMessage) {
		int severity = IStatus.INFO;
		switch (status.getSeverity()) {
		case IStatus.ERROR:
			severity = Diagnostic.ERROR;
			break;
		case IStatus.WARNING:
			severity = Diagnostic.WARNING;
			break;
		case IStatus.INFO:
			severity = Diagnostic.INFO;
			break;					
		case IStatus.OK:
			severity = Diagnostic.OK;
			break;			
		case IStatus.CANCEL:
			severity = Diagnostic.CANCEL;
			break;
		}
		Object[] data = (destObj != null) ? new Object[] { destObj } : new Object[0];
		String message = (prefixMessage != null) ? prefixMessage + status.getMessage() : status.getMessage();

		BasicDiagnostic diagnostic = new BasicDiagnostic(severity, diagSource, status.getCode(), message, data);
		if(status.isMultiStatus()) {
			IStatus[] children = status.getChildren(); 
			for (int i = 0; i < children.length; i++) {
				diagnostic.add(statusToDiagnostic(children[i], diagSource, destObj, prefixMessage));
			}
		}
		return diagnostic;
	}

	
	public static boolean checkTypeAssignmentCompatibility(EClassifier leftClassifier, EClassifier rightClassifier) {
		EClassifier left = getCanonicalEClassifier(leftClassifier);		
		EClassifier right = getCanonicalEClassifier(rightClassifier);		
		if(left == right) {
			return true;
		}
		
		if(left instanceof EClass) { 
			if(right instanceof EClass &&
				((EClass)left).isSuperTypeOf(((EClass)right))) {
				return true;
			}
		} else {
			Class<?> rightClass = right.getInstanceClass();
			Class<?> leftClass = left.getInstanceClass();			
			if(leftClass != null && rightClass != null && leftClass.isAssignableFrom(rightClass)) {
				return true;
			} 
		}
		return false;
	}
	
	public static IStatus getIncompatibleTypesStatus(EClassifier leftClassifier, EClassifier rightClassifier) {
		String message = MessageFormat.format(
				Messages.incompatibleTypes, 
				new Object[] { 
					LabelProvider.INSTANCE.getObjectLabel(leftClassifier), 
					LabelProvider.INSTANCE.getObjectLabel(rightClassifier) } );
		
		return GMFValidationPlugin.createStatus(IStatus.ERROR, 
				StatusCodes.INVALID_EXPRESSION_TYPE, message, null);		
	}
	
	public static EAnnotation getAnnotationWithKey(EModelElement eModelElement, String sourceURI, String key) {
		for (EAnnotation nextAnnotation : eModelElement.getEAnnotations()) {
			if(sourceURI.equals(nextAnnotation.getSource()) && nextAnnotation.getDetails().containsKey(key)) {
				return nextAnnotation;
			}
		}
		return null;
	}
	
	public static Map.Entry<String, String> findAnnotationDetailEntry(EModelElement eModelElement, String sourceURI, String key, String val) {
		for (EAnnotation nextAnnotation : eModelElement.getEAnnotations()) {
			if(sourceURI.equals(nextAnnotation.getSource()) && nextAnnotation.getDetails().containsKey(key)) {
				for (Map.Entry<String, String> nextEntry  : nextAnnotation.getDetails()) {
					if(nextEntry.getValue() == val || nextEntry.getKey().equals(key)) {
						return nextEntry;
					}
				}
			}
		}
		return null;
	}
	
	
	public static Map.Entry<String, String> getKeyPrefixAnnotation(EAnnotation annotation, String keyPrefix) {
		for (Map.Entry<String, String> nextEntry : annotation.getDetails()) {
			if(nextEntry.getKey().startsWith(keyPrefix)) {
				return nextEntry;
			}
		}
		return null;
	}	
	
	public static List<EAnnotation> getAnnotationsWithKeyAndValue(EModelElement eModelElement, String sourceURI, String key, String value) {
		ArrayList<EAnnotation> annotations = null;
		for (EAnnotation nextAnnotation : eModelElement.getEAnnotations()) {
			if(sourceURI.equals(nextAnnotation.getSource())) {
				Object detailVal = nextAnnotation.getDetails().get(key);
				if((value != null && value.equals(detailVal)) || value == detailVal) {
					if(annotations == null) {
						annotations = new ArrayList<EAnnotation>(eModelElement.getEAnnotations().size());
					}
					annotations.add(nextAnnotation);					
				}
			}
		}
		if (annotations != null) {
			return annotations;
		}
		return Collections.emptyList();
	}	
	
	@@SuppressWarnings("unchecked")
	public static List getAnnotationValues(EModelElement eModelElement, String sourceURI, String key) {
		List annotations = null;
		for (Iterator it = eModelElement.getEAnnotations().iterator(); it.hasNext();) {
			EAnnotation nextAnnotation = (EAnnotation) it.next();
			if(sourceURI.equals(nextAnnotation.getSource())) {
				Object detailVal = nextAnnotation.getDetails().get(key);
				if((detailVal != null)) {
					if(annotations == null) {
						annotations = new ArrayList(eModelElement.getEAnnotations().size());
					}
					annotations.add(detailVal);					
				}
			}
		}
		return annotations != null ? annotations : Collections.EMPTY_LIST;
	}	

	public static boolean isEcorePackageClassifier(EClassifier classifier) {
		EPackage classifierPackage = classifier.getEPackage();
		return EcorePackage.eINSTANCE == classifierPackage || 
			(classifierPackage != null && EcorePackage.eINSTANCE.getNsURI().equals(classifierPackage.getNsURI()));
	}
	
	public static EClassifier getCanonicalEcorePackageClassifier(EClassifier classifier) {
		if(!isEcorePackageClassifier(classifier)) {
			return null;
		}
		return EcorePackage.eINSTANCE.getEClassifier(classifier.getName());
	}
	
	public static EClassifier getCanonicalEClassifier(EClassifier classifier) {
		EClassifier eCoreCanonical = getCanonicalEcorePackageClassifier(classifier);		
		return (eCoreCanonical == null) ? classifier : eCoreCanonical;
	}
	
	public static ContextProvider getContextClass(EClass resolutionContext, IModelExpressionProvider oclExprProvider, EStructuralFeature bindFeature, EPackage.Registry registry) {
		assert bindFeature == null || bindFeature.getEContainingClass().isSuperTypeOf(resolutionContext);

		EModelElement annotationTarget = (bindFeature != null) ? (EModelElement) bindFeature : resolutionContext;
		EAnnotation ctxAnnotation = annotationTarget.getEAnnotation(Annotations.CONSTRAINTS_META_URI);

		if (ctxAnnotation != null && Annotations.Meta.CONTEXT.equals(ctxAnnotation.getDetails().get(Annotations.Meta.DEF_KEY))) {
			for (Map.Entry<String, String> nextDetail : ctxAnnotation.getDetails()) {
				String key = nextDetail.getKey();
				String value = nextDetail.getValue() != null ? nextDetail.getValue() : ""; //$NON-NLS-1$

				if (Annotations.Meta.OCL_KEY.equals(key)) {
					if (value != null) {
						IModelExpression contextEpression = oclExprProvider.createExpression(value, resolutionContext);
						EClassifier resultType = contextEpression.getResultType();
						if (String.class.equals(resultType.getInstanceClass())) {
							return new LookupByNameContextProvider(contextEpression, registry);
						} 
						else if(GenClassifierContextAdapter.isGenClassifier(resultType)) {							
							return new GenClassifierContextAdapter(contextEpression);
						}					
						
						// TODO - support in general EClassifier, GenClassifier, or String typeName
						// report problem for expressions with any other result type
						return new ExpressionContextProvider(contextEpression);
					}
				} else if (Annotations.Meta.REF.equals(key)) {
					return new ReferencedContextProvider(resolutionContext, value, oclExprProvider, registry);
				}
			}
		}

		// no context found
		return null;
	}
		
	/**
	 * @@param ePackage
	 *            scope for searching the sub-types, including sub-packages
	 * @@param superType
	 *            the type of which the sub-types are to be found
	 * @@param foundSubTypes
	 *            placeholder for the collected sub-types
	 * @@return passed <code>foundSubTypes</code> list for convenience
	 */
	static List<EClass> getSubTypes(EPackage ePackage, EClass superType, List<EClass> foundSubTypes) {
		for (EClassifier classifier : ePackage.getEClassifiers()) {
			if(classifier instanceof EClass && (superType).isSuperTypeOf((EClass)classifier)) {
				foundSubTypes.add((EClass) classifier);
			}
		}
		for (EPackage next : ePackage.getESubpackages()) {
			getSubTypes(next, superType, foundSubTypes);			
		}
		return foundSubTypes;
	}
	
	static EPackage getRootEPackage(EPackage ePackage) {		
		EPackage root = ePackage;
		for (EPackage parent = ePackage; parent != null; parent = parent.getESuperPackage()) {
			root = parent;
		}
		return root;
	}
}@


1.6
log
@[178360] Get rid of deprecated code use in org.eclipse.gmf.validate plug-in
@
text
@d274 1
a274 1
				List<IStatus> statuses = Collections.emptyList();
a281 3
						if(statuses.isEmpty()) {
							statuses = new ArrayList<IStatus>();
						}
@


1.5
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d42 1
a42 1
import org.eclipse.emf.ocl.parser.EcoreEnvironment;
d48 2
d160 6
d185 3
a187 7
						nameSeq.remove(typeName.length - 1);
						EPackage ePackage = EcoreEnvironment.findPackage(nameSeq, registry);
						if(ePackage != null) {
							EClassifier contextClassifier = ePackage.getEClassifier(typeName[typeName.length - 1]);
							contextCache.put(typeNameObj, contextClassifier);
							return contextClassifier;
						}
a516 4

	public static EClassifier emfToOclType(EClassifier type) {
		return EcoreEnvironment.getOCLType(type);
	}
@


1.4
log
@[164840] Migrate 'org.eclipse.gmf.validate' plugin to Java 5
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
d20 1
a31 1
import org.eclipse.emf.common.util.EMap;
d175 1
a175 1
					List nameSeq = new ArrayList<String>(Arrays.asList(typeName));
d258 1
a258 1
				List<EClassifier> subTypes  = getSubTypes(getRootEPackage(referencedClass.getEPackage()), referencedClass, new ArrayList<EClassifier>());
d261 2
a262 2
				for (Iterator it = subTypes.iterator(); it.hasNext();) {
					EClass nextClass = (EClass) it.next();
d271 2
a272 2
				for (Iterator it = subTypes.iterator(); it.hasNext();) {
					EClass nextClass = (EClass) it.next();
d315 2
a316 2
				for(Iterator it = contextProviderEClass.getESuperTypes().iterator(); it.hasNext();) {
					ContextProvider nextProvider = referencedContexts.get(it.next());
d431 1
a431 1
		List children = diagnostic.getChildren();
d435 2
a436 2
			for (Iterator it = children.iterator(); it.hasNext();) {
				mergeAndFlatten((Diagnostic) it.next(), diagnosticChain);
d494 1
a494 1
			Class rightClass = right.getInstanceClass();
d519 1
a519 2
		for (Iterator it = eModelElement.getEAnnotations().iterator(); it.hasNext();) {
			EAnnotation nextAnnotation = (EAnnotation) it.next();
d527 2
a528 3
	public static Map.Entry findAnnotationDetailEntry(EModelElement eModelElement, String sourceURI, String key, String val) {
		for (Iterator it = eModelElement.getEAnnotations().iterator(); it.hasNext();) {
			EAnnotation nextAnnotation = (EAnnotation) it.next();
d530 1
a530 2
				for (Iterator entryIt = nextAnnotation.getDetails().iterator(); entryIt.hasNext();) {
					Map.Entry nextEntry = (Map.Entry)entryIt.next();
d541 3
a543 4
	public static Map.Entry getKeyPreffixAnnotation(EAnnotation annotation, String keyPrefix) {
		for (Iterator it = annotation.getDetails().entrySet().iterator(); it.hasNext();) {
			Map.Entry nextEntry = (Map.Entry)it.next();
			if(((String)nextEntry.getKey()).startsWith(keyPrefix)) {
d550 3
a552 5
	@@SuppressWarnings("unchecked")
	public static List getAnnotationsWithKeyAndValue(EModelElement eModelElement, String sourceURI, String key, String value) {
		List annotations = null;
		for (Iterator it = eModelElement.getEAnnotations().iterator(); it.hasNext();) {
			EAnnotation nextAnnotation = (EAnnotation) it.next();
d557 1
a557 1
						annotations = new ArrayList(eModelElement.getEAnnotations().size());
d563 4
a566 1
		return annotations != null ? annotations : Collections.EMPTY_LIST;
a604 13
	/**
	 * @@return String value associated with the given key in given detail map or
	 * <code>null</code> if not key is present in the value
	 */
	public static String getAnnotationDetailValue(EMap detail, String key) {
		if(detail == null || key == null) {
			throw new IllegalArgumentException("null detail map or key"); //$NON-NLS-1$
		}
		Object val = detail.get(key);
		return val instanceof String ? (String) val : null;
	}
	
	
d612 3
a614 4
			for (Iterator it = ctxAnnotation.getDetails().entrySet().iterator(); it.hasNext();) {
				Map.Entry nextDetail = (Map.Entry) it.next();
				Object key = nextDetail.getKey();
				String value = nextDetail.getValue() instanceof String ? (String) nextDetail.getValue() : ""; //$NON-NLS-1$
d650 2
a651 3
	static List<EClassifier> getSubTypes(EPackage ePackage, EClass superType, List<EClassifier> foundSubTypes) {
		for (Iterator it = ePackage.getEClassifiers().iterator(); it.hasNext();) {
			EClassifier classifier = (EClassifier) it.next();
d653 1
a653 1
				foundSubTypes.add(classifier);
d656 2
a657 2
		for (Iterator it = ePackage.getESubpackages().iterator(); it.hasNext();) {
			getSubTypes((EPackage) it.next(), superType, foundSubTypes);			
@


1.3
log
@[161971] Validation of gmfmap::FeatureInitializer should correctly handle multivalued features
@
text
@d159 1
a159 1
		private Map contextCache = new HashMap(5);
d172 1
a172 1
						return (EClassifier)contextCache.get(typeNameObj);
d175 1
a175 1
					List nameSeq = new ArrayList(Arrays.asList(typeName));
d236 1
a236 1
		private Map/*<EClass, ContextProvider>*/ referencedContexts = Collections.EMPTY_MAP;		
d258 1
a258 1
				List subTypes  = getSubTypes(getRootEPackage(referencedClass.getEPackage()), referencedClass, new ArrayList());
d260 1
a260 1
				referencedContexts = new HashMap(5);				
d270 1
a270 1
				List statuses = Collections.EMPTY_LIST;
d279 1
a279 1
							statuses = new ArrayList();
d285 1
a285 1
					setStatus((IStatus)statuses.get(0));					
d288 1
a288 1
							(IStatus[])statuses.toArray(new IStatus[statuses.size()]),
d313 1
a313 1
			ContextProvider provider = (ContextProvider)referencedContexts.get(contextProviderEClass);
d316 1
a316 1
					ContextProvider nextProvider = (ContextProvider)referencedContexts.get(it.next());
d495 1
a495 1
			Class leftClass = left.getInstanceClass();			
d554 1
d572 1
d667 1
a667 1
	static List getSubTypes(EPackage ePackage, EClass superType, List foundSubTypes) {
@


1.2
log
@Allow type providing expression return null, reported with diagnostic status
@
text
@d601 1
a601 1
	static EClassifier getCanonicalEClassifier(EClassifier classifier) {
@


1.2.2.1
log
@[153901] Updated copyright date from 2005 to 2005, 2006 for those changed in CVS in 2006 (based on Tom/Anthony's script).
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
@


1.2.2.2
log
@[162496] Validation of gmfmap::FeatureInitializer should correctly handle multivalued features
@
text
@d601 1
a601 1
	public static EClassifier getCanonicalEClassifier(EClassifier classifier) {
@


1.1
log
@gmf.validation plugin created
@
text
@d362 1
a362 4
			} else if(val instanceof EClassifier) {
				return null;
			} 			
			assert false;
@

