head	1.10;
access;
symbols
	v20080722-1827:1.10
	R2_1_maintenance:1.10.0.2
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080603-1553:1.10
	v20080507-2230:1.9
	v20080425-1959:1.9
	v20080417-1610:1.9
	v20080322-0000:1.9
	v20080222-1200:1.8
	v20080215-1500:1.8
	v20070809-0000:1.7
	R2_0_maintenance:1.7.0.2
	R2_0:1.7
	R4_20:1.7
	v20070621-0000:1.7
	RC3_20:1.6
	v20070601-1400:1.6
	v20070520-1200:1.6
	v20070504-1000:1.6
	v20070405-1100:1.6
	v20070330-1300:1.6
	v20070322-1100:1.6
	v20060316-0600:1.6
	v20070208-1800:1.5
	M4_20:1.5
	v20061218-1200:1.5
	v20061214-0000:1.5
	v20061120-1300:1.5
	M3_20:1.4
	v20061117-0800:1.4
	v20061027-1200:1.4.2.1
	v20061013-1330:1.4
	v20060925-1700:1.4.2.1
	v20060919-0800:1.4.2.1
	M1_20:1.4
	v20060904-1500:1.4
	v20060831-1500:1.4
	v20060803-1200:1.4
	v20060713-1700:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060626-1420:1.4
	v20060616-1200:1.3
	v20060531-1730:1.3;
locks; strict;
comment	@# @;


1.10
date	2008.06.02.15.37.06;	author ashatalin;	state Exp;
branches;
next	1.9;
commitid	56bd484413a14567;

1.9
date	2008.03.06.12.48.16;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	38347cfe8104567;

1.8
date	2008.02.15.17.47.11;	author radvorak;	state Exp;
branches;
next	1.7;
commitid	47c047b5d01f4567;

1.7
date	2007.06.21.14.09.59;	author atikhomirov;	state Exp;
branches;
next	1.6;
commitid	1941467a86b54567;

1.6
date	2007.03.14.12.59.24;	author atikhomirov;	state Exp;
branches;
next	1.5;
commitid	110745f7f1aa4567;

1.5
date	2006.11.20.17.30.41;	author radvorak;	state Exp;
branches;
next	1.4;
commitid	1fc64561e63f4567;

1.4
date	2006.06.26.13.57.35;	author radvorak;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2006.05.18.20.30.55;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.18.17.51.56;	author radvorak;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.18.13.58.30;	author radvorak;	state Exp;
branches;
next	;

1.4.2.1
date	2006.09.13.23.07.18;	author rgronback;	state Exp;
branches;
next	;


desc
@@


1.10
log
@[235151] - Correct compilation tests failure caused by legacy gmfgraph_2006.ecore meta-model existence
@
text
@/*
 * Copyright (c) 2005, 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors: 
 *    Radek Dvorak (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.validate;

import java.util.Collection;
import java.util.HashSet;
import java.util.Map;

import org.eclipse.emf.codegen.ecore.genmodel.GenClassifier;
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage;
import org.eclipse.emf.common.util.BasicDiagnostic;
import org.eclipse.emf.common.util.Diagnostic;
import org.eclipse.emf.common.util.DiagnosticChain;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EModelElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EValidator;
import org.eclipse.emf.ecore.EStructuralFeature.Setting;
import org.eclipse.emf.ecore.impl.EPackageRegistryImpl;
import org.eclipse.emf.ecore.plugin.EcorePlugin;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.osgi.util.NLS;

public class ExternModelImport {
	private static final String DIAGNOSTIC_SOURCE = "org.eclipse.gmf.validate.imports"; //$NON-NLS-1$ 
	
	private static final EValidator VALIDATOR = new AbstractValidator() {
		
		public boolean validate(EClass eClass, EObject eObject, DiagnosticChain diagnostics, Map<Object, Object> context) {
			super.validate(eClass, eObject, diagnostics, context);
			ExternModelImport importer = getImporter(context, eObject);
			if(eObject instanceof EAnnotation) {
				return importer.processAnnotation((EAnnotation)eObject, diagnostics);
			}
			
			EPackage ePackage = eObject.eClass().getEPackage();
			if(!importer.hasPackageImportsProcessed(ePackage)) {
				return importer.processAnnotations(eObject.eClass().getEPackage(), diagnostics);
			}
			return true;
		}
	};
	
	private ResourceSet importedModels;
	private EPackage.Registry registry = new EPackageRegistryImpl(EPackage.Registry.INSTANCE);
	private HashSet<URI> myProcessedMetaModels = new HashSet<URI>();
	private HashSet<EPackage> processedPackages;
	

	private ExternModelImport(EObject validatedObject) {
		this.importedModels = new ResourceSetImpl();
		Resource targetModel = validatedObject.eResource();		
		if(targetModel != null) {
			this.importedModels.setURIConverter(targetModel.getResourceSet().getURIConverter());
		}
		this.importedModels.getURIConverter().getURIMap().putAll(EcorePlugin.computePlatformURIMap());
		this.processedPackages = new HashSet<EPackage>();
	}
	
	public static EValidator getImportValidator() {
		return VALIDATOR;
	}
	
	@@SuppressWarnings("unchecked")
	public static ExternModelImport getImporter(Map context, EObject validatedEObject) {
		if(context != null) {
			Object value = context.get(ExternModelImport.class);
			if(value == null) {
				value = new ExternModelImport(validatedEObject);
				context.put(ExternModelImport.class, value);
			}
			assert value instanceof ExternModelImport;
			return (ExternModelImport)value;
		} 
		
		return new ExternModelImport(validatedEObject);
	}	
	
	/**
	 * @@return The import package registry associated with the context or <code>null</code> if there is no such registry 
	 */
	public static EPackage.Registry getPackageRegistry(Map<Object, Object> context) {
		Object value = context.get(ExternModelImport.class);
		assert value == null || value instanceof ExternModelImport : "incorrect object registered as ExternModelImport: " + value.getClass(); //$NON-NLS-1$
		if (value instanceof ExternModelImport) {
			return ((ExternModelImport) value).registry;
		}
		return null;
	}
	
	boolean hasPackageImportsProcessed(EPackage importingPackage) {
		return processedPackages.contains(importingPackage);
	}
	
	private boolean processAnnotations(EPackage importingPackage, DiagnosticChain diagnostics) {
		boolean result = true;
		for (EAnnotation next : importingPackage.getEAnnotations()) {
			result &= processAnnotation(next, diagnostics);
		}
		processedPackages.add(importingPackage);
		return result;
	}
	
	private boolean processAnnotation(EAnnotation annotation, DiagnosticChain diagnostics) {
		if(Annotations.CONSTRAINTS_URI.equals(annotation.getSource())) {
			return processImportEAnnotation(annotation, diagnostics);
		}
		return true;
	}
	
	public void intializeExternPackages(EObject root) {
		Resource metaModelResource = root.eClass().getEPackage().eResource();
		if (!myProcessedMetaModels.contains(metaModelResource.getURI())) {
			for (EObject nextResourceElement : metaModelResource.getContents()) {
				if (nextResourceElement instanceof EPackage) {
					registerLocally((EPackage) nextResourceElement);
				}
			}
			registerReferencedMetaModels(EcoreUtil.ExternalCrossReferencer.find(metaModelResource));
			myProcessedMetaModels.add(metaModelResource.getURI());
		}
		registerReferencedMetaModels(EcoreUtil.ExternalCrossReferencer.find(root));
	}
	
	private void registerReferencedMetaModels(Map<EObject, Collection<Setting>> externalCrossReferences) {
		for (EObject next : externalCrossReferences.keySet()) {
			EPackage nextPackage = null;
			if (next instanceof EClassifier) {
				nextPackage = ((EClassifier) next).getEPackage();
			} 
			else if(next instanceof EPackage) {
				nextPackage = (EPackage)next;
			}
			else if(next instanceof GenPackage) {
				nextPackage = ((GenPackage)next).getEcorePackage();				
			}
			else if(next instanceof GenClassifier) {
				GenClassifier genClassifier = (GenClassifier) next;
				if(genClassifier.getGenPackage() != null) {
					nextPackage = genClassifier.getGenPackage().getEcorePackage();
				}
			}
			if(nextPackage != null) {
				registerLocally(nextPackage);
			}
		}		
	}

	private void registerLocally(EPackage nextPackage) {
		// force the package to be initialized in registry, in case a package descriptor is registered
		// Note: this is required for successfull ocl environment lookup of EClassifiers from external meta-models
		registry.put(nextPackage.getNsURI(), registry.getEPackage(nextPackage.getNsURI()));
	}
	
	private boolean processImportEAnnotation(EAnnotation annotation, DiagnosticChain diagnostics) {
		boolean result = true;
		for (Map.Entry<String, String> nextEntry : annotation.getDetails()) {
			if(!nextEntry.getKey().equals(Annotations.Meta.IMPORT)) {
				continue;
			}			
			String importVal = nextEntry.getValue();
			if(importVal != null) {
				importVal = importVal.trim();
				EPackage p = registry.getEPackage(importVal);
				if (p != null) {
					registerLocally(p);
					return true;
				} 

				if (!loadAsResourceURI(importVal, annotation, diagnostics)) {
					result = false;
				}

			} else {
				result = false;				
				reportInvalidModelURI(importVal, annotation.getEModelElement(), diagnostics);					
			}			
		}
		return result;
	}
	
	/**
	 * @@return false if load failed
	 */
	private boolean loadAsResourceURI(String importValue, EAnnotation annotation, DiagnosticChain diagnostics) {
		try {
			URI modelURI = URI.createURI(importValue);
			try {
				importModelFromResource(modelURI);
			} catch (RuntimeException e) {
				reportModelLoadingError(importValue, annotation.getEModelElement(), diagnostics, e);
				return false;
			}						
		} catch (IllegalArgumentException e) {
			reportInvalidModelURI(importValue, annotation.getEModelElement(), diagnostics);
			return false;
		}
		return true;
	}
	
	private static void reportInvalidModelURI(String modelURIValue, EModelElement annotatedElement, DiagnosticChain diagnostics) {
		Object destObj = DefUtils.findAnnotationDetailEntry(annotatedElement, 
				Annotations.CONSTRAINTS_URI, Annotations.Meta.IMPORT, modelURIValue);
		assert destObj != null;
		
		Diagnostic diagnostic = new BasicDiagnostic(Diagnostic.ERROR,
				DIAGNOSTIC_SOURCE, StatusCodes.INVALID_MODEL_IMPORT_URI,
				NLS.bind(Messages.invalidModelImportUri, modelURIValue), new Object[] { destObj });
		diagnostics.add(diagnostic);
	}
	
	private static void reportModelLoadingError(String modelURIValue, EModelElement annotatedElement, DiagnosticChain diagnostics, RuntimeException error) {
		Object destObj = DefUtils.findAnnotationDetailEntry(annotatedElement, 
				Annotations.CONSTRAINTS_URI, Annotations.Meta.IMPORT, modelURIValue);
		assert destObj != null;
		
		String message = NLS.bind(Messages.modelImportResourceLoadingError, modelURIValue, error.getLocalizedMessage());		
		Diagnostic diagnostic = new BasicDiagnostic(Diagnostic.ERROR,
				DIAGNOSTIC_SOURCE, StatusCodes.INVALID_MODEL_IMPORT_URI, 
				message, new Object[] { destObj });		
		diagnostics.add(diagnostic);
		GMFValidationPlugin.log(diagnostic.getSeverity(), message, error);
	}
	
	private boolean importModelFromResource(URI modelURI) throws RuntimeException {
		EList<EObject> contents = importedModels.getResource(modelURI, true).getContents();
		for (EObject nextObj : contents) {
			if(nextObj instanceof EPackage) {
				EPackage ePackage = (EPackage)nextObj;
				if(ePackage.getNsURI() != null) {				
					registerLocally(ePackage);
				}
				return true;
			}
		}
		return false;
	}
	
}
@


1.9
log
@[220711] respect workspace resource models
@
text
@d14 1
d32 1
d62 2
a63 1
	private EPackage.Registry registry;
d100 6
a105 3
		Object registry = context.get(EPackageRegistryImpl.class);
		assert registry == null || registry instanceof EPackage.Registry : "registry must be EPackage.Registry"; //$NON-NLS-1$
		return (EPackage.Registry)registry;
d129 15
a143 2
		EPackage.Registry registryToInit = registry != null ? registry : EPackage.Registry.INSTANCE;
		for (EObject next : EcoreUtil.ExternalCrossReferencer.find(root).keySet()) {
a159 1
			
d161 1
a161 3
				// force the package to be initialized in registry, in case a package descriptor is registered
				// Note: this is required for successfull ocl environment lookup of EClassifiers from external meta-models
				registryToInit.getEPackage(nextPackage.getNsURI()); 
d165 6
a170 1
		
d181 1
a181 1
				EPackage p = EPackage.Registry.INSTANCE.getEPackage(importVal);
d183 1
d247 2
a248 3
				if(ePackage.getNsURI() != null) {					
					// force package initialization
					EPackage.Registry.INSTANCE.getEPackage(ePackage.getNsURI());
d254 2
a255 1
	}	
@


1.8
log
@[218423] Validate plug-in prevents workflow from being used for GMF model extension
@
text
@d32 1
d70 1
@


1.7
log
@fix copyright years
@
text
@d39 1
a39 1
	private static final String DIAGNOSTIC_SOURCE = GMFValidationPlugin.getDefault().getBundle().getSymbolicName() + ".imports"; //$NON-NLS-1$ 
@


1.6
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
d232 1
a232 1
}@


1.5
log
@[164840] Migrate 'org.eclipse.gmf.validate' plugin to Java 5
@
text
@a14 1
import java.util.Iterator;
d43 1
a43 2
		@@SuppressWarnings("synthetic-access")
		public boolean validate(EClass eClass, EObject eObject, DiagnosticChain diagnostics, Map context) {
d94 1
a94 1
	public static EPackage.Registry getPackageRegistry(Map context) {
d106 2
a107 2
		for (Iterator it = importingPackage.getEAnnotations().iterator(); it.hasNext();) {
			result &= processAnnotation((EAnnotation) it.next(), diagnostics);
d122 1
a122 2
		for (Iterator refIt = EcoreUtil.ExternalCrossReferencer.find(root).keySet().iterator(); refIt.hasNext();) {
			Object next = refIt.next();
d151 1
a151 2
		for (Iterator it = annotation.getDetails().entrySet().iterator(); it.hasNext();) {
			Map.Entry nextEntry = (Map.Entry)it.next();
d155 1
a155 1
			String importVal = (String) nextEntry.getValue();
d219 2
a220 3
		EList contents = importedModels.getResource(modelURI, true).getContents();
		for (Iterator it = contents.iterator(); it.hasNext();) {
			EObject nextObj = (EObject) it.next();
@


1.4
log
@#148642 gmf metamodel validation should not cause NPE for unresolved proxies
@
text
@d44 1
d62 1
a62 1
	private HashSet processedPackages;
d71 1
a71 1
		this.processedPackages = new HashSet();
d78 1
d165 4
a168 4
				} else {
					if (!loadAsResourceURI(importVal, annotation, diagnostics)) {
						result = false;
					}
d170 1
@


1.4.2.1
log
@[153901] Updated copyright date from 2005 to 2005, 2006 for those changed in CVS in 2006 (based on Tom/Anthony's script).
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
@


1.3
log
@use exhaustive validation constraints defined with our own annotation scheme
@
text
@a126 1
				registryToInit.getEPackage(((EClassifier) next).getEPackage().getNsURI());
@


1.2
log
@peform safety-check on getting EPackage from GenClassifier
@
text
@d160 6
a165 6
				URI modelURI = null;
				try {
					modelURI = URI.createURI(importVal.trim());
					try {
						importModelFromResource(modelURI);
					} catch (RuntimeException e) {
d167 1
a167 5
						reportModelLoadingError(importVal, annotation.getEModelElement(), diagnostics, e);						
					}						
				} catch (IllegalArgumentException e) {
					result = false;					
					reportInvalidModelURI(importVal, annotation.getEModelElement(), diagnostics);
d177 18
@


1.1
log
@gmf.validation plugin created
@
text
@d136 4
a139 1
				nextPackage = ((GenClassifier) next).getGenPackage().getEcorePackage();
@

