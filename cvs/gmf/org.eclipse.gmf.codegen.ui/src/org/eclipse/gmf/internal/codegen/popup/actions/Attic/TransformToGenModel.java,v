head	1.37;
access;
symbols
	v20061013-1330:1.33
	v20060919-0800:1.27.2.2
	M1_20:1.29
	v20060904-1500:1.29
	v20060713-1700:1.27.2.1
	R1_0_maintenance:1.27.0.2
	R1_0:1.27
	v20060627-1200:1.27
	v20060626-1420:1.27
	v20060616-1200:1.26
	v20060609-1400:1.26
	v20060531-1730:1.26
	v20060530-1930:1.26
	v20060526-1200:1.25
	v20060519-1300:1.23
	v20060519-0800:1.23
	I20060505-1400:1.21
	I20060424-0500:1.18
	I20060424-0300:1.18
	M6_10:1.18
	I20060407-1200:1.17
	I20060331-1000:1.17
	I20060324-0300:1.17
	I20060317-1300:1.17
	I20060317-1200:1.17
	I20060316-1300:1.17
	I20060309-1300:1.15
	M5_10:1.15
	S20060303-1600:1.15
	I20060227-1730:1.15
	I20060216-1945:1.15
	I20060210-1715:1.13
	I20060209-1815:1.13
	I20060203-0830:1.12
	I20060129-1145:1.12
	I20060127-0900:1.12
	I20060120-1530:1.12
	I20060113-1700:1.10
	M4_10:1.10
	I20060107-1100:1.9
	I20060105-1630:1.9
	I20051230-1230:1.9
	I20051223-1100:1.9
	I20051217-0925:1.9
	I20051201-1800:1.9
	M3_10:1.8
	I20051118-1245:1.8
	I20051111-1800:1.6
	I20051106-0900:1.5
	v20051030:1.5
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.37
date	2006.11.01.10.05.45;	author dstadnik;	state dead;
branches;
next	1.36;

1.36
date	2006.11.01.09.59.32;	author dstadnik;	state Exp;
branches;
next	1.35;

1.35
date	2006.10.31.18.02.06;	author radvorak;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.17.15.44.11;	author atikhomirov;	state Exp;
branches;
next	1.33;

1.33
date	2006.09.15.20.37.47;	author atikhomirov;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.13.10.58.14;	author atikhomirov;	state Exp;
branches;
next	1.31;

1.31
date	2006.09.11.12.53.33;	author atikhomirov;	state Exp;
branches;
next	1.30;

1.30
date	2006.09.06.18.22.33;	author atikhomirov;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.31.14.22.46;	author radvorak;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.10.18.05.59;	author ashatalin;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.26.14.05.01;	author atikhomirov;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2006.05.29.16.45.24;	author ashatalin;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.26.14.16.27;	author dstadnik;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.24.18.12.45;	author ashatalin;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.19.11.56.00;	author atikhomirov;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.17.15.24.20;	author atikhomirov;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.02.18.00.37;	author ashatalin;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.02.17.44.39;	author ashatalin;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.01.17.26.38;	author atikhomirov;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.14.19.22.55;	author atikhomirov;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.15.15.44.17;	author atikhomirov;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.13.12.02.45;	author atikhomirov;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.15.14.04.08;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.14.20.09.52;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.08.00.17.13;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.18.19.28.13;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.18.17.47.09;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.10.16.16.51;	author ashatalin;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.28.16.09.34;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.18.11.55.13;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.14.13.10.44;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.11.20.08.25;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.25.15.15.55;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.07.13.01.11;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.06.15.56.38;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.04.13.17.51;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.29.07;	author atikhomirov;	state Exp;
branches;
next	;

1.27.2.1
date	2006.07.11.12.35.51;	author ashatalin;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2006.09.13.23.07.23;	author rgronback;	state Exp;
branches;
next	;


desc
@@


1.37
log
@add 'Action' suffix to action class name
@
text
@/*
 * Copyright (c) 2005,2006 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.codegen.popup.actions;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.common.util.URI;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.dialogs.IInputValidator;
import org.eclipse.jface.dialogs.InputDialog;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.IObjectActionDelegate;
import org.eclipse.ui.IWorkbenchPart;

/**
 * .gmfmap to .gmfgen
 * 
 * @@author artem
 */
public class TransformToGenModel implements IObjectActionDelegate {

	private IWorkbenchPart myPart;

	private IFile myMapFile;

	private IFile myDestFile;

	public void setActivePart(IAction action, IWorkbenchPart targetPart) {
		myPart = targetPart;
	}

	public void selectionChanged(IAction action, ISelection selection) {
		myMapFile = (IFile) ((IStructuredSelection) selection).getFirstElement();
	}

	public void run(IAction action) {
		initDestinationFile();
		if (myDestFile == null) {
			return;
		}
		TransformToGenModelOperation op = new TransformToGenModelOperation();
		op.setName(action.getText());
		op.setShell(getShell());
		op.setMapModelURI(URI.createPlatformResourceURI(myMapFile.getFullPath().toString()));
		op.setGenModelURI(URI.createPlatformResourceURI(myDestFile.getFullPath().toString()));
		op.setUseRuntimeFigures(Boolean.TRUE);
		op.setUseMapMode(Boolean.TRUE);
		op.run();
	}

	private void initDestinationFile() {
		myDestFile = null;
		final IPath destPath = myMapFile.getFullPath().removeFileExtension().addFileExtension("gmfgen"); //$NON-NLS-1$
		final IPath destLocation = destPath.removeLastSegments(1);
		final String defFileName = destPath.lastSegment();
		InputDialog dlg = new InputDialog(getShell(), "Target model file", "Please specify name of the file to save diagram genmodel to", defFileName, new IInputValidator() {

			public String isValid(String newText) {
				IStatus s = ResourcesPlugin.getWorkspace().validatePath(destLocation.append(newText).toOSString(), IResource.FILE);
				return s.isOK() ? null : s.getMessage();
			}
		});
		if (dlg.open() != InputDialog.OK) {
			return;
		}
		myDestFile = ResourcesPlugin.getWorkspace().getRoot().getFile(destLocation.append(dlg.getValue()));
	}

	public IFile getGenModelFile() {
		return myDestFile;
	}

	private Shell getShell() {
		return myPart.getSite().getShell();
	}
}
@


1.36
log
@use uris instead of file names in dashboard
@
text
@@


1.35
log
@[162917] Improve gmf models validation involved in tooling related UI actions
@
text
@a13 6
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

a17 1
import org.eclipse.core.runtime.IProgressMonitor;
a18 7
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.emf.codegen.ecore.genmodel.GenModel;
import org.eclipse.emf.common.util.BasicDiagnostic;
import org.eclipse.emf.common.util.Diagnostic;
a19 22
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.XMIResource;
import org.eclipse.gmf.codegen.gmfgen.GenEditorGenerator;
import org.eclipse.gmf.gmfgraph.util.RuntimeFQNSwitch;
import org.eclipse.gmf.graphdef.codegen.MapModeCodeGenStrategy;
import org.eclipse.gmf.internal.bridge.VisualIdentifierDispenser;
import org.eclipse.gmf.internal.bridge.genmodel.BasicDiagramRunTimeModelHelper;
import org.eclipse.gmf.internal.bridge.genmodel.DiagramGenModelTransformer;
import org.eclipse.gmf.internal.bridge.genmodel.DiagramRunTimeModelHelper;
import org.eclipse.gmf.internal.bridge.genmodel.GenModelProducer;
import org.eclipse.gmf.internal.bridge.genmodel.InnerClassViewmapProducer;
import org.eclipse.gmf.internal.bridge.genmodel.SpecificDiagramRunTimeModelHelper;
import org.eclipse.gmf.internal.bridge.genmodel.ViewmapProducer;
import org.eclipse.gmf.internal.bridge.naming.gen.GenModelNamingMediatorImpl;
import org.eclipse.gmf.internal.codegen.CodeGenUIPlugin;
import org.eclipse.gmf.internal.codegen.GMFGenConfig;
import org.eclipse.gmf.internal.common.migrate.ModelLoadHelper;
import org.eclipse.gmf.internal.common.reconcile.Reconciler;
import org.eclipse.gmf.internal.graphdef.codegen.ui.FigureGeneratorOptionsDialog;
import org.eclipse.gmf.mappings.Mapping;
a20 1
import org.eclipse.jface.dialogs.IDialogConstants;
a22 4
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.dialogs.MessageDialogWithToggle;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.jface.preference.IPreferenceStore;
a27 1
import org.eclipse.ui.progress.IProgressService;
d31 1
d35 2
a36 1
	private static final String ASK_WARN = "ask_warn";
d39 1
a39 1
	private IWorkbenchPart myPart;
a40 3
	private static final Boolean THERE_IS_NO_SPECIFIC_RT = Boolean.TRUE;

	private ResourceSet myResourceSet;
d46 2
a47 9
	protected ResourceSet getResourceSet() {
		if (myResourceSet == null) {
			myResourceSet = new ResourceSetImpl();
		}
		return myResourceSet;
	}

	protected void forgetResourceSet() {
		myResourceSet = null;
d55 8
a62 270
		ModelLoadHelper loadHelper = new ModelLoadHelper(getResourceSet(), getMapModelURI());
		if(!canProcessMappingModel(loadHelper, action)) {			
			return;			
		}		

		final Mapping mapping = (Mapping) loadHelper.getContentsRoot();
		IStatus mapIsValid = validate(mapping);
		if (mapIsValid.matches(IStatus.CANCEL)) {
			return;
		}
		if (mapIsValid.matches(IStatus.ERROR)) {
			final String[] buttons = new String[] {IDialogConstants.PROCEED_LABEL, IDialogConstants.CANCEL_LABEL };
			final int[] buttonIDs = new int[] {IDialogConstants.PROCEED_ID, IDialogConstants.CANCEL_ID };
			final String msg = CodeGenUIPlugin.getBundleString("transform.err");
			ErrorDialogEx dlg = new ErrorDialogEx(getShell(), action.getText(), msg, mapIsValid, buttons, buttonIDs, 0);
			if (dlg.open() == IDialogConstants.CANCEL_ID) {
				return;
			}
		} else if ((mapIsValid.matches(IStatus.INFO | IStatus.WARNING))) {
			if (!MessageDialogWithToggle.ALWAYS.equals(getPreferences().getString(ASK_WARN))) {
				if (MessageDialogWithToggle.OK != MessageDialogWithToggle.openOkCancelConfirm(getShell(), action.getText(), CodeGenUIPlugin.getBundleString("transform.warn"), CodeGenUIPlugin.getBundleString("transform.neverwarn"), false, getPreferences(), ASK_WARN).getReturnCode()) {
					return;
				}
			}
		}

		final GenModelDetector gmDetector = new GenModelDetector(myMapFile);
		final IStatus findStatus = gmDetector.find(getShell(), mapping);
		if (findStatus.getSeverity() == IStatus.CANCEL) {
			return;
		}
		GenModel domainGenModel = null;
		if (findStatus.isOK()) {
			domainGenModel = gmDetector.get(getResourceSet());
		}

		if (domainGenModel != null) {
			StaleGenModelDetector staleDetector = new StaleGenModelDetector(domainGenModel);
			if (staleDetector.isStale()) {
				if (staleDetector.queryUser(getShell()).getSeverity() == IStatus.CANCEL) {
					return;
				}
				domainGenModel = staleDetector.refresh();
			}
		}

		final DiagramRunTimeModelHelper drtModelHelper = detectRunTimeModel();

		final ViewmapProducer viewmapProducer = detectViewmapProducer(getShell());
		if (viewmapProducer == null) {
			return;
		}

		final VisualIdentifierDispenserProvider idDispenser = getVisualIdDispenser();
		idDispenser.acquire();

		GenModelProducer t = createGenModelProducer(domainGenModel, drtModelHelper, viewmapProducer, idDispenser.get());

		final Job transformJob = createTransformJob(mapping, action.getText(), t);
		transformJob.schedule();
		try {
			transformJob.join();
			if (transformJob.getResult().getSeverity() != IStatus.CANCEL) {
				idDispenser.release();
			}
		} catch (InterruptedException ex) {
		}
		forgetResourceSet();
	}

	/**
	 * Job should not be async
	 */
	private Job createTransformJob(final Mapping mapping, String title, final GenModelProducer t) {
		//final ISchedulingRule rule = MultiRule.combine(myMapFile, myDestFile);
		return new Job(title) {
			{
				setUser(true);
				setPriority(SHORT);
				//setRule(rule); //  <crmcsi$8mi$1@@www.eclipse.org>
			}

			protected IStatus run(IProgressMonitor monitor) {
				monitor.beginTask(getName(), 4);
				try {
					GenEditorGenerator genEditor = t.process(mapping, new SubProgressMonitor(monitor, 1));
					if (monitor.isCanceled()) {
						return Status.CANCEL_STATUS;
					}
					
					if (CodeGenUIPlugin.needsReconcile()) {
						reconcile(genEditor);
					}
					monitor.worked(1);
					if (monitor.isCanceled()) {
						return Status.CANCEL_STATUS;
					}

					save(genEditor);
					monitor.worked(1);
					if (monitor.isCanceled()) {
						return Status.CANCEL_STATUS;
					}
					
					return validate(genEditor);
				} catch (IOException ex) {
					return CodeGenUIPlugin.createError(ex.getMessage(), ex);
				} catch (IllegalArgumentException ex) {
					return CodeGenUIPlugin.createError(ex.getMessage(), ex);
				} finally {
					monitor.done();
				}
			}

			private IStatus validate(GenEditorGenerator genBurdern) {
				Diagnostic d = ValidationHelper.validate(genBurdern, true);
				if (d.getSeverity() == Diagnostic.OK) {
					return Status.OK_STATUS;
				}
				if ((d.getSeverity() & Diagnostic.CANCEL) != 0) {
					return Status.CANCEL_STATUS;
				} else {
					return BasicDiagnostic.toIStatus(d);
				}
			}
			@@SuppressWarnings("unchecked")
			private void save(GenEditorGenerator genBurdern) throws IOException {
				Resource dgmmRes = getResourceSet().createResource(getGenModelURI());
				dgmmRes.getContents().add(genBurdern);				
				dgmmRes.save(getSaveOptions());
			}
			protected Map getSaveOptions() {
				HashMap<String, Object> saveOptions = new HashMap<String, Object>();
				saveOptions.put(XMIResource.OPTION_ENCODING, "UTF-8");
				return saveOptions;
			}
			private void reconcile(GenEditorGenerator genBurdern) {
				GenEditorGenerator old = null;
				Resource resource = null;
				try {
					resource = getResourceSet().getResource(getGenModelURI(), true);
					List contents = resource.getContents();
					if (!contents.isEmpty() && contents.get(0) instanceof GenEditorGenerator){
						old = (GenEditorGenerator)contents.get(0);
					}
					if (old != null){
						new Reconciler(new GMFGenConfig()).reconcileTree(genBurdern, old);
					}
				} catch (RuntimeException e){
					old = null;
				} finally {
					if (resource != null){
						resource.unload();
					}
				}
			}
		};
	}

	private GenModelProducer createGenModelProducer(GenModel domainGenModel, final DiagramRunTimeModelHelper drtModelHelper, final ViewmapProducer viewmapProducer, final VisualIdentifierDispenser idDespenser) {
		final DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new GenModelNamingMediatorImpl(), viewmapProducer, idDespenser);
		if (domainGenModel != null) {
			t.setEMFGenModel(domainGenModel);
		}
		return new GenModelProducer() {
			public GenEditorGenerator process(Mapping mapping, IProgressMonitor progress) {
				progress.beginTask(null, 1);
				try {
					t.transform(mapping);
					return t.getResult();
				} finally {
					progress.done();
				}
			}
		};
	}

	/**
	 * Checks if loaded mapping model can be processed further
	 * 
	 * @@param loadHelper helper used to load the mapping model
	 * @@param action the action in execution
	 * @@return <code>true</code> if mapping model is available with OK status or in case of 
	 * 	load problems, user decided to proceed. Returns <code>false</code> otherwise.
	 */
	private boolean canProcessMappingModel(ModelLoadHelper loadHelper, IAction action) {
		if(!loadHelper.getStatus().isOK()) {			
			String[] buttons = new String[] {IDialogConstants.PROCEED_LABEL, IDialogConstants.CANCEL_LABEL };
			int[] buttonIDs = new int[] {IDialogConstants.PROCEED_ID, IDialogConstants.CANCEL_ID };
			
			if(!(loadHelper.getContentsRoot() instanceof Mapping)) {
				// we cannot proceed further as there is no mapping, allow only cancel
				buttons = new String[] { buttons[1] };
				buttonIDs = new int[] { buttonIDs[1] };
			}
			ErrorDialogEx dlg = new ErrorDialogEx(getShell(), action.getText(), 
					CodeGenUIPlugin.getBundleString("transform.err"), 
					loadHelper.getStatus(), buttons, buttonIDs, 0);
			if (dlg.open() == IDialogConstants.CANCEL_ID) {
				return false;
			}
		}
		return true;
	}

	private VisualIdentifierDispenserProvider getVisualIdDispenser() {
		return new VisualIdentifierDispenserProvider(getGenModelURI());
	}

	private ViewmapProducer detectViewmapProducer(Shell shell) {
		if (!checkLiteOptionPresent()) {
			MapModeCodeGenStrategy strategy;
			final String msg = "Would you like to use IMapMode?";
			if (MessageDialog.openQuestion(shell, "Create Generator Model", msg)) {
				strategy = new MapModeCodeGenStrategy.RuntimeUnspecifiedMapMode();
			} else {
				strategy = new MapModeCodeGenStrategy.StaticIdentityMapMode();
			}
			return new InnerClassViewmapProducer(new RuntimeFQNSwitch(), strategy);
		}
		FigureGeneratorOptionsDialog dlg = new FigureGeneratorOptionsDialog(shell, "Create Generator Model", true, true);
		if (dlg.open() != IDialogConstants.OK_ID) {
			return null;
		}
		return new InnerClassViewmapProducer(dlg.getFigureQualifiedNameSwitch(), dlg.getMapModeCodeGenStrategy());
	}
	
	private static boolean checkLiteOptionPresent() {
		return Platform.getBundle("org.eclipse.gmf.codegen.lite") != null;
	}

	private DiagramRunTimeModelHelper detectRunTimeModel() {
		DiagramRunTimeModelHelper drtModelHelper = null;
		URI specificRTGenModelURI = decideOnRunTimeModel();
		if (specificRTGenModelURI != null) {
			Resource drtGenModelRes = getResourceSet().getResource(specificRTGenModelURI, true);
			if (drtGenModelRes != null) {
				GenModel drtGenModel = (GenModel) drtGenModelRes.getContents().get(0);
				drtModelHelper = new SpecificDiagramRunTimeModelHelper(drtGenModel);
			}
		}
		if (drtModelHelper == null) {
			drtModelHelper = new BasicDiagramRunTimeModelHelper();
		}
		return drtModelHelper;
	}

	private IStatus validate(final Mapping mapping) {
		IProgressService progressService = myPart.getSite().getWorkbenchWindow().getWorkbench().getProgressService();
		final Diagnostic[] result = new Diagnostic[1];
		try {
			progressService.run(false, true, new IRunnableWithProgress() {
				public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
					result[0] = ValidationHelper.validate(mapping, true, monitor);
					monitor.done();
				}
			});
			if (result[0] == null) {
				return Status.CANCEL_STATUS;
			}
			return BasicDiagnostic.toIStatus(result[0]);
		} catch (InvocationTargetException ex) {
			return Status.CANCEL_STATUS;
		} catch (InterruptedException ex) {
			return Status.CANCEL_STATUS;
		}
	}

	public void selectionChanged(IAction action, ISelection selection) {
		myMapFile = (IFile) ((IStructuredSelection) selection).getFirstElement();
d67 1
a67 1
		final IPath destPath = myMapFile.getFullPath().removeFileExtension().addFileExtension("gmfgen");
d71 1
a86 8
	URI getMapModelURI() {
		return URI.createPlatformResourceURI(myMapFile.getFullPath().toString());
	}
	
	URI getGenModelURI() {
		return URI.createPlatformResourceURI(myDestFile.getFullPath().toString());
	}
	
a89 17

	private URI decideOnRunTimeModel() {
		if (THERE_IS_NO_SPECIFIC_RT.booleanValue()) {
			return null;
		}
		IPath p = myMapFile.getFullPath();
		String defValue = p.removeLastSegments(1).append(p.removeFileExtension().lastSegment() + "-drt").addFileExtension("genmodel").toString();
		InputDialog dlg = new InputDialog(getShell(), "Diagram RunTime Model", "Please specify path to genmodel file that describes specific diagram runtime model, or press Cancel if you don't need one", defValue, null);
		if (dlg.open() == InputDialog.OK) {
			return URI.createPlatformResourceURI(dlg.getValue());
		}
		return null;
	}

	private static IPreferenceStore getPreferences() {
		return CodeGenUIPlugin.getDefault().getPreferenceStore();
	}
@


1.34
log
@[161206] NPE on pure design models
@
text
@a36 1
import org.eclipse.emf.ecore.util.Diagnostician;
d220 1
a220 1
				Diagnostic d = Diagnostician.INSTANCE.validate(genBurdern);
d358 1
a358 5
					// there's no real progress reporting in diagnostician (didn't find references to Monitor there), 
					// at least make them look like there's smth to happen
					monitor.beginTask("", 3);
					monitor.worked(1);
					result[0] = Diagnostician.INSTANCE.validate(mapping);
@


1.33
log
@modest progress reporting while validating
@
text
@d142 7
a148 4
		StaleGenModelDetector staleDetector = new StaleGenModelDetector(domainGenModel);
		if (staleDetector.isStale()) {
			if (staleDetector.queryUser(getShell()).getSeverity() == IStatus.CANCEL) {
				return;
a149 1
			domainGenModel = staleDetector.refresh();
@


1.32
log
@wait for job to end
@
text
@d15 1
d63 1
d70 1
d111 1
a111 1
		final Mapping mapping = (Mapping) loadHelper.getContentsRoot();		
d351 23
a373 2
	private IStatus validate(Mapping mapping) {
		return BasicDiagnostic.toIStatus(Diagnostician.INSTANCE.validate(mapping));
@


1.31
log
@quick'n'dirty check for stale genmodels
@
text
@d161 6
a166 2
		if (transformJob.getResult().getSeverity() != IStatus.CANCEL) {
			idDispenser.release();
@


1.30
log
@refactor Create GenModel action, added support for automated .genmodel creation and alternative to launch EMF wizard to do the same
@
text
@d139 8
@


1.29
log
@#154698 Support migration of GMF tooling models in case of backward incomatible changes
- adding migration action, save model loading to generate actions
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
a15 2
import java.util.HashSet;
import java.util.Iterator;
d27 1
a32 2
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EPackage;
a36 1
import org.eclipse.emf.ecore.util.EcoreUtil;
a40 2
import org.eclipse.gmf.internal.bridge.NaiveIdentifierDispenser;
import org.eclipse.gmf.internal.bridge.StatefulVisualIdentifierDispencer;
a42 1
import org.eclipse.gmf.internal.bridge.genmodel.BasicGenModelAccess;
d45 1
a45 2
import org.eclipse.gmf.internal.bridge.genmodel.FileGenModelAccess;
import org.eclipse.gmf.internal.bridge.genmodel.GenModelAccess;
a67 2
import org.eclipse.ui.dialogs.ResourceSelectionDialog;
import org.osgi.framework.Bundle;
a78 1
	private Map mySaveOptions = null;
d81 2
d86 12
a97 1
	
d103 1
a103 2
		final ResourceSet resSet = new ResourceSetImpl();
		ModelLoadHelper loadHelper = new ModelLoadHelper(resSet, getMapModelURI());
d129 1
a129 1
		final GenModelDetector gmDetector = new GenModelDetector();
d136 1
a136 1
			domainGenModel = gmDetector.get(resSet);
d139 1
a139 1
		final DiagramRunTimeModelHelper drtModelHelper = detectRunTimeModel(resSet);
d146 9
a154 5
		final VisualIdentifierDispenser idDespenser = getVisualIdDespenser(resSet);
		//final ISchedulingRule rule = MultiRule.combine(myMapFile, myDestFile);
		final DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new GenModelNamingMediatorImpl(), viewmapProducer, idDespenser);
		if (domainGenModel != null) {
			t.setEMFGenModel(domainGenModel);
d156 2
d159 6
a164 1
		new Job(action.getText()) {
d174 1
a174 2
					GenEditorGenerator genEditor = transform(mapping);
					monitor.worked(1);
d202 1
a202 4
			private GenEditorGenerator transform(Mapping m) {
				t.transform(m);
				return t.getResult();
			}
d214 1
d216 1
a216 1
				Resource dgmmRes = resSet.createResource(getGenModelURI());
a218 4
				
				if (idDespenser instanceof StatefulVisualIdentifierDispencer) {
					((StatefulVisualIdentifierDispencer) idDespenser).saveState();
				}
d220 5
a224 1
			
d229 1
a229 1
					resource = resSet.getResource(getGenModelURI(), true);
d245 19
a263 1
		}.schedule();
d293 3
a295 21
	
	private VisualIdentifierDispenser getVisualIdDespenser(ResourceSet resSet) {
		Bundle tracePluginBundle = Platform.getBundle("org.eclipse.gmf.bridge.trace");
		if (tracePluginBundle != null) {
			try {
				Class despenserClass = tracePluginBundle.loadClass("org.eclipse.gmf.internal.bridge.trace.MergingIdentifierDispenser");
				Object dispencer = despenserClass.newInstance();
				if (dispencer instanceof StatefulVisualIdentifierDispencer) {
					StatefulVisualIdentifierDispencer statefulDispencer = (StatefulVisualIdentifierDispencer) dispencer;
					statefulDispencer.loadState(getGenModelURI());
					return statefulDispencer;
				}
			} catch (ClassNotFoundException e) {
				CodeGenUIPlugin.getDefault().getLog().log(CodeGenUIPlugin.createError("MergingIdentifierDispenser was not found in org.eclipse.gmf.bridge.trace bundle", e));
			} catch (InstantiationException e) {
				CodeGenUIPlugin.getDefault().getLog().log(CodeGenUIPlugin.createError("MergingIdentifierDispenser was not instantiated", e));
			} catch (IllegalAccessException e) {
				CodeGenUIPlugin.getDefault().getLog().log(CodeGenUIPlugin.createError("IllegalAccessException while instantiating MergingIdentifierDispenser", e));
			}
		}
		return new NaiveIdentifierDispenser();
d316 1
a316 1
	private boolean checkLiteOptionPresent() {
d320 1
a320 1
	private DiagramRunTimeModelHelper detectRunTimeModel(final ResourceSet resSet) {
d324 1
a324 1
			Resource drtGenModelRes = resSet.getResource(specificRTGenModelURI, true);
a335 8
	protected Map getSaveOptions() {
		if (mySaveOptions == null) {
			mySaveOptions = new HashMap();
			mySaveOptions.put(XMIResource.OPTION_ENCODING, "UTF-8");
		}
		return mySaveOptions;
	}

a392 64

	private class GenModelDetector {
		private GenModelAccess myGMAccess;

		public IStatus find(Shell shell, Mapping mapping) { 
			HashSet packages = new HashSet();
			for (Iterator it = EcoreUtil.ExternalCrossReferencer.find(mapping).keySet().iterator(); it.hasNext();) {
				Object next = it.next();
				if (next instanceof EClass) {
					packages.add(((EClass) next).getEPackage());
				}
			}
			for (Iterator it = packages.iterator(); it.hasNext();) {
				EPackage next = (EPackage) it.next();
				if (next.getESuperPackage() != null && EcoreUtil.isAncestor(packages, next.getESuperPackage())) {
					it.remove();
				}
			}
			IFile workspaceFile;
			if (packages.isEmpty()) {
				myGMAccess = new GenModelAccess.Adapter(null);
				return Status.OK_STATUS;
			} else if (packages.size() == 1) {
				final EPackage solePack = (EPackage) packages.iterator().next();
				BasicGenModelAccess gma = new BasicGenModelAccess(solePack);
				gma.initDefault();
				if (gma.load(new ResourceSetImpl()).isOK()) {
					gma.unload();
					myGMAccess = gma;
					return Status.OK_STATUS;
				} else {
					workspaceFile = askGenModelFile(shell, "Can't find genmodel for package " + solePack.getName() + "(" + solePack.getNsURI() + ")");
				}
			} else {
				workspaceFile = askGenModelFile(shell, "Need genmodel to cover all referenced domain packages (" + packages.size() + ")");
			}
			if (workspaceFile == null) {
				return Status.CANCEL_STATUS;
			}
			myGMAccess = new FileGenModelAccess(workspaceFile);
			return Status.OK_STATUS;
		}

		private IFile askGenModelFile(Shell shell, String message) {
			ResourceSelectionDialog d = new ResourceSelectionDialog(shell, ResourcesPlugin.getWorkspace().getRoot(), message);
			if (ResourceSelectionDialog.OK != d.open()) {
				return null;
			}
			Object[] result = d.getResult();
			if (result == null || result.length != 1 || false == result[0] instanceof IFile) {
				MessageDialog.openError(shell, "GenModel selection", "Needs exactly one .genmodel file");
				return null;
			}
			return (IFile) result[0];
		}

		public GenModel get(ResourceSet resSet) {
			IStatus s = myGMAccess.load(resSet);
			if (!s.isOK()) {
				throw new IllegalStateException(s.getMessage());
			}
			return myGMAccess.model();
		}
	}
@


1.28
log
@#148651 Plugin bridge.trace uses wrong namespace
@
text
@d60 1
d95 1
a95 1

d102 4
d107 1
a107 3
		Resource mapRes = resSet.getResource(getMapModelURI(), true);
		final Mapping mapping = (Mapping) mapRes.getContents().get(0);

d239 28
@


1.27
log
@no api packages, classes are for internal use only
@
text
@d240 1
a240 1
				Class despenserClass = tracePluginBundle.loadClass("org.eclipse.gmf.bridge.internal.trace.MergingIdentifierDispenser");
@


1.27.2.1
log
@#148651 Plugin bridge.trace uses wrong namespace
@
text
@d240 1
a240 1
				Class despenserClass = tracePluginBundle.loadClass("org.eclipse.gmf.internal.bridge.trace.MergingIdentifierDispenser");
@


1.27.2.2
log
@[153901] Updated copyright date from 2005 to 2005, 2006 for those changed in CVS in 2006 (based on Tom/Anthony's script).
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
@


1.26
log
@#139128 Preserve visualID of the .gmfgen model nodes on modifying .gmfmap model.
- adding more traces
- default OCL queries changed - containment/child metafeatures checked for GenNodes
@
text
@a41 9
import org.eclipse.gmf.bridge.genmodel.BasicDiagramRunTimeModelHelper;
import org.eclipse.gmf.bridge.genmodel.BasicGenModelAccess;
import org.eclipse.gmf.bridge.genmodel.DiagramGenModelTransformer;
import org.eclipse.gmf.bridge.genmodel.DiagramRunTimeModelHelper;
import org.eclipse.gmf.bridge.genmodel.FileGenModelAccess;
import org.eclipse.gmf.bridge.genmodel.GenModelAccess;
import org.eclipse.gmf.bridge.genmodel.InnerClassViewmapProducer;
import org.eclipse.gmf.bridge.genmodel.SpecificDiagramRunTimeModelHelper;
import org.eclipse.gmf.bridge.genmodel.ViewmapProducer;
d48 9
@


1.25
log
@#114175 allow to create diagram editor without domain model
@
text
@d181 3
a183 1
					return CodeGenUIPlugin.createError("", ex);
@


1.24
log
@#139128 Preserve visualID of the .gmfgen model nodes on modifying .gmfmap model.
@
text
@d379 2
a380 2
				MessageDialog.openWarning(shell, "Mapping without domain model", "Sorry, don't know yet how to deal with mapping that has no domain model"); // FIXME
				return Status.CANCEL_STATUS;
@


1.23
log
@Provide option to proceed with transformation even when gmfmap is bad
@
text
@d54 3
d76 1
d142 1
d144 1
a144 1
		final DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new GenModelNamingMediatorImpl(), viewmapProducer);
d205 4
d234 22
a273 1

d334 1
a334 1

d338 1
a338 1

@


1.22
log
@run as user job
@
text
@a60 1
import org.eclipse.jface.dialogs.ErrorDialog;
d106 8
a113 4
			ErrorDialog.openError(getShell(), action.getText(), CodeGenUIPlugin.getBundleString("transform.err"), mapIsValid);
			return;
		}
		if ((mapIsValid.matches(IStatus.INFO | IStatus.WARNING))) {
@


1.21
log
@Rollback of the incorrect changes.
@
text
@d143 1
a143 1
				//setUser(true); // waiting for regression #115873 to be fixed
@


1.20
log
@Logic was corrected.
@
text
@d223 1
a223 1
		if (checkLiteOptionPresent()) {
@


1.19
log
@[bblajer] ##139022 Provide option to choose mapMode for figures
@
text
@d223 1
a223 1
		if (!checkLiteOptionPresent()) {
@


1.18
log
@allow to use pure-gef switch if codegen.lite present
@
text
@d53 1
a53 1
import org.eclipse.gmf.gmfgraph.util.RuntimeLiteFQNSwitch;
d58 1
d62 1
d130 4
a133 1
		final ViewmapProducer viewmapProducer = detectViewmapProducer(getShell()); 
d224 8
a231 1
			return new InnerClassViewmapProducer(new RuntimeFQNSwitch());
d233 3
a235 5
		final String msg = "Would you like to utilize enhanced features of GMF runtime (if no, only basic GEF capabilities will be used)";
		if (MessageDialog.openQuestion(shell, "Target runtime", msg)) {
			return new InnerClassViewmapProducer(new RuntimeFQNSwitch());
		} else {
			return new InnerClassViewmapProducer(new RuntimeLiteFQNSwitch());
d237 1
@


1.17
log
@allow to omit reconcile step
@
text
@d27 1
d48 1
d50 1
d52 2
d126 3
a128 1
		DiagramRunTimeModelHelper drtModelHelper = detectRunTimeModel(resSet);
d131 1
a131 1
		final DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new GenModelNamingMediatorImpl());
d217 17
@


1.16
log
@[mgolubev] #131355 Preserve modified gmfgen attributes which initialy had some default values
@
text
@d145 3
a147 1
					reconcile(genEditor);
@


1.15
log
@cons with two args is from 1.5 :(
@
text
@d18 1
d51 2
d137 1
a137 1
				monitor.beginTask(getName(), 3);
d144 6
d184 21
@


1.14
log
@#116432 - ask user to supply genmodel if we notice several domain packages
and #123608 to some extent - with genModel set, no more easy-to-get NPEs should occur while transforming
@
text
@d318 1
a318 1
				throw new IllegalStateException(s.getMessage(), s.getException());
@


1.13
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d16 2
d32 2
d38 1
d41 1
d44 2
d55 1
d63 1
d108 4
a111 8
		DiagramRunTimeModelHelper drtModelHelper = null;
		URI specificRTGenModelURI = decideOnRunTimeModel();
		if (specificRTGenModelURI != null) {
			Resource drtGenModelRes = resSet.getResource(specificRTGenModelURI, true);
			if (drtGenModelRes != null) {
				GenModel drtGenModel = (GenModel) drtGenModelRes.getContents().get(0);
				drtModelHelper = new SpecificDiagramRunTimeModelHelper(drtGenModel);
			}
d113 3
a115 2
		if (drtModelHelper == null) {
			drtModelHelper = new BasicDiagramRunTimeModelHelper();
d118 2
d122 3
d178 16
d259 64
@


1.12
log
@refactor NamingStrategy: extracted all className setters to provisional NamingMediator
@
text
@d39 1
a39 1
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
d124 1
a124 1
					GenDiagram genDiagram = transform(mapping);
d130 1
a130 1
					save(genDiagram);
d136 1
a136 1
					return validate(genDiagram);
d143 1
a143 1
			private GenDiagram transform(Mapping m) {
d147 2
a148 2
			private IStatus validate(GenDiagram gd) {
				Diagnostic d = Diagnostician.INSTANCE.validate(gd);
d158 1
a158 1
			private void save(GenDiagram gd) throws IOException {
d160 1
a160 1
				dgmmRes.getContents().add(gd);				
@


1.11
log
@set created file names in dashboard
@
text
@a35 1
import org.eclipse.gmf.bridge.genmodel.DefaultNamingStrategy;
d40 1
d112 1
a112 1
		final DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new DefaultNamingStrategy());
@


1.10
log
@As a part of implementstion
#114178,114179
"Shortcutting" diagram elements.
@
text
@d199 4
@


1.9
log
@#117749 & #118040 generate unique names for the shared elements in mapping model
@
text
@d15 2
a16 1
import java.util.Collections;
d34 1
d64 2
a65 1
	private IFile myDestFile; 
d160 2
a161 2
				dgmmRes.getContents().add(gd);
				dgmmRes.save(Collections.EMPTY_MAP);
d166 8
@


1.8
log
@get rid of 'never used locally' compilation warning
@
text
@d34 1
a36 2
import org.eclipse.gmf.bridge.genmodel.EditPartNamingStrategy;
import org.eclipse.gmf.bridge.genmodel.NotationViewFactoryNamingStrategy;
d109 1
a109 1
		final DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new EditPartNamingStrategy(), new NotationViewFactoryNamingStrategy());
@


1.7
log
@rule commented out till I resolve IllegalArgumentException
@
text
@a23 1
import org.eclipse.core.runtime.jobs.ISchedulingRule;
a24 1
import org.eclipse.core.runtime.jobs.MultiRule;
d109 1
a109 1
		final ISchedulingRule rule = MultiRule.combine(myMapFile, myDestFile);
d116 1
a116 1
				//setRule(rule);
@


1.6
log
@#115475 validate models prior to code generation
@
text
@d118 1
a118 1
				setRule(rule);
@


1.5
log
@#112300 don't mention 'specific' rt model till there's one, nice names for actions
@
text
@d18 2
d21 6
d28 2
d34 1
d42 1
d45 2
d48 2
d61 2
d65 2
a66 1
	private static final Boolean THERE_IS_NO_SPECIFIC_RT = Boolean.TRUE; 
d73 2
a74 2
		URI destinationModelURI = getDestPath();
		if (destinationModelURI == null) {
d78 1
d80 17
a96 1
		Mapping m = (Mapping) mapRes.getContents().get(0);
d110 58
a167 11
		DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new EditPartNamingStrategy(), new NotationViewFactoryNamingStrategy());
		t.transform(m);
		GenDiagram genDiagram = t.getResult();

		Resource dgmmRes = resSet.createResource(destinationModelURI);
		dgmmRes.getContents().add(genDiagram);
		try {
			dgmmRes.save(Collections.EMPTY_MAP);
		} catch (IOException ex) {
			ex.printStackTrace();
		}
d174 4
a177 2
	private URI getDestPath() {
		IPath destPath = myMapFile.getFullPath().removeFileExtension().addFileExtension("gmfgen");
d179 6
a184 1
		InputDialog dlg = new InputDialog(getShell(), "Target model file", "Please specify name of the file to save diagram genmodel to", defFileName, null);
d186 1
a186 1
			return null;
d188 1
a188 1
		return URI.createPlatformResourceURI(destPath.removeLastSegments(1).append(dlg.getValue()).toString());
d191 1
a191 1
	private URI getMapModelURI() {
d195 4
d215 4
@


1.4
log
@#111775 stale properties in gmfgen
#111784 GenChildContainer extends GenCommonBase
@
text
@d47 1
d110 3
@


1.3
log
@[ashatalin] #111769 NamingStrategy for ViewFactories
@
text
@a27 1
import org.eclipse.gmf.bridge.genmodel.MetaInfoProviderNamingStrategy;
d73 1
a73 1
		DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new EditPartNamingStrategy(), new MetaInfoProviderNamingStrategy(), new NotationViewFactoryNamingStrategy());
@


1.2
log
@gmfgen ECore references were replaced with GenModel references to ease template coding and as alignment with overall "genmodel for GMF" concept
@
text
@d29 1
d74 1
a74 1
		DiagramGenModelTransformer t = new DiagramGenModelTransformer(drtModelHelper, new EditPartNamingStrategy(), new MetaInfoProviderNamingStrategy());
@


1.1
log
@*** empty log message ***
@
text
@a20 2
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.plugin.EcorePlugin;
a24 1
import org.eclipse.gmf.bridge.genmodel.EditPartNamingStrategy;
d27 1
a76 4
		GenModel domainGenModel = findGenModel(genDiagram.getDomainMetaModel());
		if (domainGenModel != null) {
			genDiagram.setEmfGenModel(domainGenModel);
		}
a116 24

	private GenModel findGenModel(EPackage model) {
		URI genModelURI = (URI) EcorePlugin.getEPackageNsURIToGenModelLocationMap().get(model.getNsURI());
		if (genModelURI == null) {
			URI domainModelURI = model.eResource().getURI(); 
			genModelURI = domainModelURI.trimFileExtension().appendFileExtension("genmodel");
			if (genModelURI.equals(domainModelURI)) {
				genModelURI = null; // don't even try, then
			}
		}
		if (genModelURI == null) {
			return null;
		}
		ResourceSet rs = model.eResource().getResourceSet();
		// @@see org.eclipse.emf.importer.ModelImporter.getExternalGenModels()
		Resource genModelResource = rs.getResource(genModelURI, false);
		if (genModelResource == null) {
			genModelResource = rs.getResource(genModelURI, true);
			if (genModelResource != null) {
				return (GenModel) genModelResource.getContents().get(0);
			}
		}
		return null;
	}
@

