head	1.17;
access;
symbols
	v20080722-1827:1.17
	v20080716-1642:1.17
	R2_1_maintenance:1.17.0.4
	Root_R2_1_maintenance:1.17
	R2_1_0:1.17
	v20080512-1200:1.17
	v20080417-1610:1.17
	v20080322-0000:1.17
	v20080222-1200:1.17
	v20071108-0000:1.17
	v20070809-0000:1.17
	R2_0_maintenance:1.17.0.2
	R2_0:1.17
	R4_20:1.17
	v20070621-0000:1.17
	RC3_20:1.16
	v20070605-1400:1.16
	v20070601-1400:1.16
	v20070525-1500:1.16
	v20070520-1200:1.16
	v20070420-1000:1.16
	v20070405-2000:1.16
	v20070330-1300:1.16
	v20070228-2000:1.16
	v20070208-1800:1.16
	M4_20:1.16
	v20061222-1800:1.16
	v20061214-0000:1.16
	M3_20:1.15
	v20061117-0800:1.15
	v20061013-1330:1.14
	v20060919-0800:1.12.2.1
	M1_20:1.14
	v20060904-1500:1.14
	v20060713-1700:1.12
	R1_0_maintenance:1.12.0.2
	R1_0:1.12
	v20060627-1200:1.12
	v20060626-1420:1.12
	v20060616-1200:1.12
	v20060609-1400:1.12
	v20060531-1730:1.12
	v20060530-1930:1.12
	v20060526-1200:1.11
	v20060519-1300:1.11
	v20060519-0800:1.10
	I20060505-1400:1.10
	I20060424-0500:1.10
	I20060424-0300:1.10
	M6_10:1.10
	I20060407-1200:1.8
	I20060331-1000:1.8
	I20060324-0300:1.8
	I20060317-1300:1.8
	I20060317-1200:1.8
	I20060316-1300:1.8
	I20060309-1300:1.8
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.8
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051201-1800:1.5
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.5
	I20051106-0900:1.3
	v20051030:1.3
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.17
date	2007.06.21.14.06.07;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	14b5467a85ce4567;

1.16
date	2006.11.22.17.35.57;	author ashatalin;	state Exp;
branches;
next	1.15;
commitid	124a45648a7d4567;

1.15
date	2006.11.01.09.59.32;	author dstadnik;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.31.14.22.46;	author radvorak;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.28.17.20.16;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.30.13.45.34;	author dstadnik;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2006.05.19.13.09.29;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.14.12.53.37;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.11.19.53.51;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.23.15.29.44;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.23.12.21.24;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.08.00.17.13;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.11.20.08.25;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.09.20.57.16;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.04.13.17.51;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.06.14.15.46;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.29.07;	author atikhomirov;	state Exp;
branches;
next	;

1.12.2.1
date	2006.09.13.23.07.23;	author rgronback;	state Exp;
branches;
next	;


desc
@@


1.17
log
@fix copyright years
@
text
@/*
 * Copyright (c) 2005, 2006 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.codegen.popup.actions;

import org.eclipse.core.resources.IFile;
import org.eclipse.emf.common.util.URI;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.IObjectActionDelegate;
import org.eclipse.ui.IWorkbenchPart;

/**
 * Runs generation of diagram editor project
 * 
 * @@author artem
 */
public class ExecuteTemplatesAction implements IObjectActionDelegate {

	private IFile gmFile;

	private IWorkbenchPart myPart;

	public void setActivePart(IAction action, IWorkbenchPart targetPart) {
		myPart = targetPart;
	}

	public void selectionChanged(IAction action, ISelection selection) {
		gmFile = (IFile) ((IStructuredSelection) selection).getFirstElement();
	}

	public void run(IAction action) {
		ExecuteTemplatesOperation op = createOperation();
		op.setName(action.getText());
		op.setShell(getShell());
		op.setGenModelURI(URI.createPlatformResourceURI(gmFile.getFullPath().toString(), true));
		op.run();
	}

	protected ExecuteTemplatesOperation createOperation() {
		return new ExecuteTemplatesOperation();
	}

	private Shell getShell() {
		return myPart.getSite().getShell();
	}
}
@


1.16
log
@Removing warnings
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
@


1.15
log
@use uris instead of file names in dashboard
@
text
@d46 1
a46 1
		op.setGenModelURI(URI.createPlatformResourceURI(gmFile.getFullPath().toString()));
@


1.14
log
@#154698 Support migration of GMF tooling models in case of backward incomatible changes
- adding migration action, save model loading to generate actions
@
text
@a13 2
import java.lang.reflect.InvocationTargetException;

a14 5
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.util.BasicDiagnostic;
a15 8
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.Diagnostician;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenEditorGenerator;
import org.eclipse.gmf.codegen.util.Generator;
import org.eclipse.gmf.internal.codegen.CodeGenUIPlugin;
import org.eclipse.gmf.internal.common.migrate.ModelLoadHelper;
a16 6
import org.eclipse.jface.dialogs.ErrorDialog;
import org.eclipse.jface.dialogs.IDialogConstants;
import org.eclipse.jface.dialogs.MessageDialogWithToggle;
import org.eclipse.jface.dialogs.ProgressMonitorDialog;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.jface.preference.IPreferenceStore;
d28 1
a28 3
public class ExecuteTemplatesAction implements IObjectActionDelegate, IRunnableWithProgress {

	private static final String ASK_OK = "ask_ok";
d30 1
a30 1
	private IFile mySelection;
a33 3
	protected IStatus myRunStatus;
	private GenEditorGenerator myGenModel;

a37 91
	// TODO Jobs
	public void run(IAction action) {
		try {
			IStatus loadStatus = loadGenModel();
			if(!canProcessGMFGenModel(loadStatus, action)) {
				return;
			}
			
			assert getGenModel() != null;
			IStatus isGenModelValid = validateGenModel();
			if (!isGenModelValid.isOK()) {
				final String[] buttons = new String[] {IDialogConstants.PROCEED_LABEL, IDialogConstants.CANCEL_LABEL };
				final int[] buttonIDs = new int[] {IDialogConstants.PROCEED_ID, IDialogConstants.CANCEL_ID };
				final String msg = CodeGenUIPlugin.getBundleString("generatecode.badsrc");
				ErrorDialogEx dlg = new ErrorDialogEx(getShell(), action.getText(), msg, isGenModelValid, buttons, buttonIDs, 0);
				if (dlg.open() == IDialogConstants.CANCEL_ID) {
					return;
				}
			}
			
			doRunWithStatus();

			if (getRunStatus().isOK()) {
				if (!MessageDialogWithToggle.ALWAYS.equals(getPreferences().getString(ASK_OK))) {
					MessageDialogWithToggle.openInformation(getShell(), action.getText(), CodeGenUIPlugin.getBundleString("generatecode.ok"), CodeGenUIPlugin.getBundleString("generatecode.neveragain"), false, getPreferences(), ASK_OK);
				}
			} else if (myRunStatus.matches(IStatus.ERROR)) {
				CodeGenUIPlugin.getDefault().getLog().log(getRunStatus());
				ErrorDialog.openError(getShell(), action.getText(), CodeGenUIPlugin.getBundleString("generatecode.err"), getRunStatus());
			} else if (myRunStatus.matches(IStatus.WARNING)) {
				ErrorDialog.openError(getShell(), action.getText(), CodeGenUIPlugin.getBundleString("generatecode.warn"), getRunStatus());
			} else if (myRunStatus.matches(IStatus.INFO)) {
				ErrorDialog.openError(getShell(), action.getText(), CodeGenUIPlugin.getBundleString("generatecode.info"), getRunStatus());
			}
		} catch (InterruptedException ex) {
			// presumably, user canceled the operation, don't bother him with additional messages
		} finally {
			unloadGenModel();
		}
	}

	/**
	 * Checks if loaded gmfgen model can be processed further.<p>
	 * Note: Must be called after {@@link #loadGenModel()}.
	 * @@param loadStatus the result status of loading the gmfgen model
	 * @@param action the action in execution
	 * @@return <code>true</code> if gmfgen model is available with OK status or in case of load problems,
	 * 		user decided to proceed, <code>false</code> otherwise.
	 */
	private boolean canProcessGMFGenModel(IStatus loadStatus, IAction action) {
		if(!loadStatus.isOK()) {
			String[] buttons = new String[] {IDialogConstants.PROCEED_LABEL, IDialogConstants.CANCEL_LABEL };
			int[] buttonIDs = new int[] {IDialogConstants.PROCEED_ID, IDialogConstants.CANCEL_ID };
			if(myGenModel == null) {
				// we cannot proceed further as there is no gmfgen, allow only cancel
				buttons = new String[] { buttons[1] };
				buttonIDs = new int[] { buttonIDs[1] };
			}
			ErrorDialogEx dlg = new ErrorDialogEx(getShell(), action.getText(), 
					CodeGenUIPlugin.getBundleString("generatecode.badsrc"), //$NON-NLS-1$ 
					loadStatus, buttons, buttonIDs, 0);			
			if (dlg.open() == IDialogConstants.CANCEL_ID) {
				return false;
			}
		}
		return true;
	}	
	
	/**
	 * @@return
	 */
	private void doRunWithStatus() throws InterruptedException {
		myRunStatus = Status.CANCEL_STATUS;
		try {
			new ProgressMonitorDialog(getShell()).run(true, true, this);
		} catch (InvocationTargetException ex) {
			Throwable targetException = ex.getTargetException();
			if (targetException instanceof CoreException) {
				myRunStatus = ((CoreException)targetException).getStatus();
			} else {
				myRunStatus = new Status(IStatus.ERROR, CodeGenUIPlugin.getPluginID(), 0, "Exception occurred while generating code", targetException);
			}
		}
	}

	public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
		Generator g = new Generator(getGenModel(), CodeGenUIPlugin.getDefault().getEmitters(getGenModel()));
		g.run(monitor);
		myRunStatus = g.getRunStatus();
	}

d39 1
a39 7
		mySelection = null;
		action.setEnabled(false);
		if (selection instanceof IStructuredSelection == false) {
			return;
		}
		mySelection = (IFile) ((IStructuredSelection) selection).getFirstElement();
		action.setEnabled(true);
d42 6
a47 22
	private IStatus getRunStatus() {
		return myRunStatus;
	}

	protected final GenEditorGenerator getGenModel() {
		return myGenModel;
	}

	private IStatus loadGenModel() {
		URI selected = URI.createPlatformResourceURI(mySelection.getFullPath().toString());
		ResourceSet srcResSet = new ResourceSetImpl();
		ModelLoadHelper loadHelper = new ModelLoadHelper(srcResSet, selected);
		Object root = loadHelper.getContentsRoot();
		if (root instanceof GenDiagram) {
			myGenModel = ((GenDiagram) root).getEditorGen();
		} else if (root instanceof GenEditorGenerator) {
			myGenModel = (GenEditorGenerator) root;
		}
		if (myGenModel != null && myGenModel.getDomainGenModel() != null) {
			myGenModel.getDomainGenModel().reconcile();
		}
		return loadHelper.getStatus();
d50 2
a51 9
	private void unloadGenModel() {
		if (myGenModel != null && myGenModel.eResource() != null) {
			myGenModel.eResource().unload();
		}
		myGenModel = null;
	}

	private IStatus validateGenModel() {
		return BasicDiagnostic.toIStatus(Diagnostician.INSTANCE.validate(getGenModel()));
a56 4

	private static IPreferenceStore getPreferences() {
		return CodeGenUIPlugin.getDefault().getPreferenceStore();
	}
@


1.13
log
@caching behavior extracted to keep separate from *generation iterator* functionality
@
text
@a22 1
import org.eclipse.emf.ecore.resource.Resource;
d30 1
d67 5
a71 1
			loadGenModel();
d106 27
d173 1
a173 1
	private void loadGenModel() {
d176 2
a177 2
		Resource srcRes = srcResSet.getResource(selected, true);
		Object root = srcRes.getContents().get(0);
d186 1
@


1.12
log
@refactor deferred refs resolution option
@
text
@d119 1
a119 1
		Generator g = new Generator(getGenModel());
@


1.12.2.1
log
@[153901] Updated copyright date from 2005 to 2005, 2006 for those changed in CVS in 2006 (based on Tom/Anthony's script).
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2006 Borland Software Corporation
@


1.11
log
@better validation error reporting
@
text
@a26 1
import org.eclipse.emf.ecore.xmi.XMLResource;
a144 2
// [vano]: see https://bugs.eclipse.org/bugs/show_bug.cgi?id=128998 for a details		
		srcResSet.getLoadOptions().put(XMLResource.OPTION_DEFER_IDREF_RESOLUTION, Boolean.TRUE);
@


1.10
log
@[bblajer] #136702 Code generation targeting pure-GEF runtime
refactoring to reuse action from codegen.ui for now
@
text
@d33 2
a34 1
import org.eclipse.jface.dialogs.MessageDialog;
a51 1
	private static final String ASK_INFO = "ask_info";
d72 5
a76 1
				if (!MessageDialog.openConfirm(getShell(), action.getText(), formatMessage("generatecode.badsrc", isGenModelValid))) {
d89 1
a89 1
				MessageDialog.openError(getShell(), action.getText(), formatMessage("generatecode.err", getRunStatus()));
d91 1
a91 1
				MessageDialog.openWarning(getShell(), action.getText(), formatMessage("generatecode.warn", getRunStatus()));
d93 1
a93 3
				if (!MessageDialogWithToggle.ALWAYS.equals(getPreferences().getString(ASK_INFO))) {
					MessageDialogWithToggle.openInformation(getShell(), action.getText(), formatMessage("generatecode.info", getRunStatus()), CodeGenUIPlugin.getBundleString("generatecode.neveragain"), false, getPreferences(), ASK_INFO);
				}
a134 4
	private static String formatMessage(String bundleStringKey, IStatus status) {
		return CodeGenUIPlugin.formatMessage(bundleStringKey, status);
	}

@


1.9
log
@handle InvocationTargetException which may provide information about RuntimeException we didn't manage to handle in generator
@
text
@d58 1
a58 1
	private IStatus myRunStatus;
d141 1
a141 1
	private GenEditorGenerator getGenModel() {
@


1.8
log
@Correcting model to correctly load cross-references in the model.
Comment added
@
text
@d17 1
d77 1
a77 2
			myRunStatus = Status.CANCEL_STATUS;
			new ProgressMonitorDialog(getShell()).run(true, true, this);
a92 1
		} catch (InvocationTargetException ex) {
d94 1
d100 17
@


1.7
log
@Correcting model to correctly load cross-references in the model.
@
text
@d131 1
@


1.6
log
@major refactoring of .gmfgen - new top-level entity introduced,  erroneous domainMetaModel feature removed (was deprecated for a while)
moving towards support of domain models defined in different packages - each GenElement uses it's own genPackage.packageInterfaceName
@
text
@d26 1
d131 1
@


1.5
log
@#115475 validate models prior to code generation
@
text
@d27 1
d57 1
a57 1
	private GenDiagram myGenModel;
d123 1
a123 1
	private GenDiagram getGenModel() {
d131 9
a139 2
		myGenModel = (GenDiagram) srcRes.getContents().get(0);
		myGenModel.getEMFGenModel().reconcile();
@


1.4
log
@#115474 notify user if errors occured during code generation
@
text
@d20 1
d25 1
d56 1
d62 1
d65 9
d75 1
a75 1
			new ProgressMonitorDialog(myPart.getSite().getShell()).run(true, true, this);
d79 1
a79 1
					MessageDialogWithToggle.openInformation(getShell(), getStatusDialogTitle(), CodeGenUIPlugin.getBundleString("generatecode.ok"), CodeGenUIPlugin.getBundleString("generatecode.neveragain"), false, getPreferences(), ASK_OK);
d81 1
a81 1
			} else if ((myRunStatus.getSeverity() & IStatus.ERROR) != 0) {
d83 4
a86 4
				MessageDialog.openError(getShell(), getStatusDialogTitle(), formatMessage("generatecode.err", getRunStatus()));
			} else if ((myRunStatus.getSeverity() & IStatus.WARNING) != 0) {
				MessageDialog.openWarning(getShell(), getStatusDialogTitle(), formatMessage("generatecode.warn", getRunStatus()));
			} else if ((myRunStatus.getSeverity() & IStatus.INFO) != 0) {
d88 1
a88 1
					MessageDialogWithToggle.openInformation(getShell(), getStatusDialogTitle(), formatMessage("generatecode.info", getRunStatus()), CodeGenUIPlugin.getBundleString("generatecode.neveragain"), false, getPreferences(), ASK_INFO);
a91 1

d93 2
d99 1
a99 6
		URI selected = URI.createPlatformResourceURI(mySelection.getFullPath().toString());
		ResourceSet srcResSet = new ResourceSetImpl();
		Resource srcRes = srcResSet.getResource(selected, true);
		GenDiagram gd = (GenDiagram) srcRes.getContents().get(0);
		gd.getEMFGenModel().reconcile();
		Generator g = new Generator(gd);
a103 4
	private String getStatusDialogTitle() {
		return CodeGenUIPlugin.getBundleString("generatecode.status.title");
	}

d114 2
a115 15
	private String formatMessage(String bundleStringKey, IStatus status) {
		if (status.isMultiStatus()) {
			IStatus[] children = status.getChildren();
			StringBuffer sb = new StringBuffer();
			// don't care about too nested statuses just because will switch to
			// jobs soon, with
			// required support already in place
			for (int i = 0; i < children.length; i++) {
				sb.append(children[i].getMessage());
				sb.append('\n');
			}
			return CodeGenUIPlugin.getBundleString(bundleStringKey, new Object[] { sb.toString() });
		} else {
			return CodeGenUIPlugin.getBundleString(bundleStringKey, new Object[] { status.getMessage() });
		}
d122 21
a142 2
	private static IPreferenceStore getPreferences() {
		return CodeGenUIPlugin.getDefault().getPreferenceStore();
d148 4
@


1.3
log
@gmfgen ECore references were replaced with GenModel references to ease template coding and as alignment with overall "genmodel for GMF" concept
@
text
@d18 2
d26 1
d28 2
d32 1
d35 1
a38 1

d41 1
d45 4
d50 1
d53 2
d61 1
d63 15
d79 1
a79 1
			
d92 5
d109 28
@


1.2
log
@[vano] reconcile genModel for domain model
@
text
@d59 1
a59 1
		gd.getEmfGenModel().reconcile();
@


1.1
log
@*** empty log message ***
@
text
@d59 1
@

