head	1.6;
access;
symbols
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5;
locks; strict;
comment	@# @;
expand	@k@;


1.6
date	2006.03.01.12.46.04;	author dstadnik;	state dead;
branches;
next	1.5;

1.5
date	2006.01.13.17.02.36;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.13.16.32.32;	author dstadnik;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.13.15.05.37;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.13.14.42.03;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.13.13.26.42;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.6
log
@#129892 Move graphdef and tooldef wizards from codegen.ui to bridge.ui plugin
@
text
@/*
 * Copyright (c) 2006 Eclipse.org
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    dstadnik - initial API and implementation
 */
package org.eclipse.gmf.internal.codegen.resolver;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;

public class StructureResolver {

	private Vocabulary nodeVocabulary;

	private Vocabulary linkVocabulary;

	private Vocabulary linkSourceVocabulary;

	private Vocabulary linkTargetVocabulary;

	public StructureResolver() {
		nodeVocabulary = new Vocabulary();
		nodeVocabulary.add(new String[] { "node", "item" });
		linkVocabulary = new Vocabulary();
		linkVocabulary.add(new String[] { "link", "connection", "relation", "dependency", "flow" });
		linkSourceVocabulary = new Vocabulary();
		linkSourceVocabulary.add(new String[] { "source", "src", "from" });
		linkTargetVocabulary = new Vocabulary();
		linkTargetVocabulary.add(new String[] { "destination", "dst", "dest", "to" });
	}

	protected boolean guessNode(EClass type) {
		return nodeVocabulary.containsWords(type.getName());
	}

	protected boolean guessLink(EClass type) {
		return linkVocabulary.containsWords(type.getName());
	}

	protected EReference guessLinkSource(EReference[] refs) {
		for (int i = 0; i < refs.length; i++) {
			if (linkSourceVocabulary.containsWords(refs[i].getName())) {
				return refs[i];
			}
		}
		return null;
	}

	protected EReference guessLinkTarget(EReference[] refs) {
		for (int i = 0; i < refs.length; i++) {
			if (linkTargetVocabulary.containsWords(refs[i].getName())) {
				return refs[i];
			}
		}
		return null;
	}

	public TypePattern resolve(EClass type) {
		if (type.isAbstract() || type.isInterface()) {
			return null;
		}
		EReference[] containments = getContainments(type);
		if (containments.length == 0) {
			// skip diagram node and other unattached types
			return null;
		}
		EAttribute[] labels = getLabels(type);
		EReference[] refs = getEAllPotentialRefs(type, true);
		// heuristics : type without refs is a node
		// heuristics : type that has containment feature(s) is likely a node
		// heuristics : guess node by vocabulary
		if (refs.length == 0 || !type.getEAllContainments().isEmpty() || guessNode(type)) {
			refs = getEAllPotentialRefs(type, false);
			return new NodePattern(type, labels, refs);
		}
		EReference source;
		EReference target;
		if (refs.length == 1) {
			// heuristics : one ref is target; source is container
			source = null;
			target = refs[0];
		} else {
			// heuristics : guess source and target refs by vocabulary
			source = guessLinkSource(refs);
			target = guessLinkTarget(refs);
			if (source == null) {
				source = target == refs[0] ? refs[1] : refs[0];
			}
			if (target == null) {
				target = source == refs[1] ? refs[0] : refs[1];
			}
		}
		return new TypeLinkPattern(type, labels, source, target);
	}

	protected EAttribute[] getLabels(EClass type) {
		List attrs = new ArrayList();
		for (Iterator it = type.getEAllAttributes().iterator(); it.hasNext();) {
			EAttribute attr = (EAttribute) it.next();
			attrs.add(attr);
		}
		return (EAttribute[]) attrs.toArray(new EAttribute[attrs.size()]);
	}

	/**
	 * Finds all potential references. Such references are not containers,
	 * containments, derived and have type from the same package as the host
	 * type; thus they may connect types as links on diagram surface.
	 */
	protected EReference[] getEAllPotentialRefs(EClass type, boolean forLink) {
		List refs = new ArrayList();
		for (Iterator it = type.getEAllReferences().iterator(); it.hasNext();) {
			EReference ref = (EReference) it.next();
			EClass refType = ref.getEReferenceType();
			if (forLink && (refType.isSuperTypeOf(type) || ref.isMany())) {
				continue;
			}
			boolean samePackage = refType.getEPackage().equals(type.getEPackage());
			if (!ref.isDerived() && !ref.isContainer() && !ref.isContainment() && samePackage) {
				refs.add(ref);
			}
		}
		return (EReference[]) refs.toArray(new EReference[refs.size()]);
	}

	/**
	 * Returns list of references that contain this type.
	 */
	protected EReference[] getContainments(EClass type) {
		List refs = new ArrayList();
		for (Iterator it = type.getEPackage().eAllContents(); it.hasNext();) {
			EObject element = (EObject) it.next();
			if (element instanceof EReference) {
				EReference ref = (EReference) element;
				if (ref.isContainment() && ref.getEReferenceType().isSuperTypeOf(type) && ref.getEContainingClass() != type) {
					refs.add(ref);
				}
			}
		}
		return (EReference[]) refs.toArray(new EReference[refs.size()]);
	}
}
@


1.5
log
@skip diagram object and not attached objects
@
text
@@


1.4
log
@support ref-based links with multiplicity more then one
@
text
@d20 1
d74 5
d137 17
@


1.3
log
@resolve reference-based links
@
text
@d70 3
d79 1
d112 3
a114 3
	 * Finds all potential references. Such references are not containments,
	 * have multiplicity 1 and have type from the same package as the host type;
	 * thus they may connect types as links on diagram surface.
d116 1
a116 1
	protected EReference[] getEAllPotentialRefs(EClass type, boolean excludeSelf) {
d121 1
a121 1
			if (excludeSelf && refType.isSuperTypeOf(type)) {
d124 2
a125 1
			if (!ref.isContainment() && !ref.isMany() && refType.getEPackage().equals(type.getEPackage())) {
@


1.2
log
@better resolving code
@
text
@d76 1
a76 1
			return new NodePattern(type, labels);
d107 5
d116 2
a117 1
			if (excludeSelf && ref.getEReferenceType().isSuperTypeOf(type)) {
d120 1
a120 1
			if (!ref.isContainment() && !ref.isMany()) {
@


1.1
log
@#112297 add structure resolver
@
text
@d71 5
a75 2
		EReference[] refs = getEAllNonContainments(type, true);
		if (refs.length < 2 || guessNode(type)) {
d78 16
a93 7
		EReference source = guessLinkSource(refs);
		EReference target = guessLinkTarget(refs);
		if (source == null) {
			source = target == refs[0] ? refs[1] : refs[0];
		}
		if (target == null) {
			target = source == refs[1] ? refs[0] : refs[1];
d107 1
a107 1
	protected EReference[] getEAllNonContainments(EClass type, boolean excludeSelf) {
@

