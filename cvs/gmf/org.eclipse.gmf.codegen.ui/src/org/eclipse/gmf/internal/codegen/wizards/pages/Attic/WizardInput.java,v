head	1.8;
access;
symbols
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	I20060227-1730:1.7
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.4
	M4_10:1.4;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2006.02.28.19.07.38;	author atikhomirov;	state dead;
branches;
next	1.7;

1.7
date	2006.02.23.15.45.22;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.22.22.01.26;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.18.17.47.08;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.13.19.32.42;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.13.19.32.07;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.13.18.23.08;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.13.17.21.02;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Introduced separate plugin for Tooling UI, moved mapping wizard of #114186 to this plugin.
Wizard got some NLS, respect selection, open-created-model-in-editor improvements as well as aligned with recent gmfmap changes.
Plus, some refactorings to address user-prioritized strategies to select nodes/links doubled number of classes we had.
@
text
@/*
 * Copyright (c) 2006 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.codegen.wizards.pages;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.emf.common.command.BasicCommandStack;
import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.common.util.UniqueEList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.emf.edit.provider.ComposedAdapterFactory;
import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;
import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;
import org.eclipse.gmf.gmfgraph.Canvas;
import org.eclipse.gmf.gmfgraph.Connection;
import org.eclipse.gmf.gmfgraph.DiagramElement;
import org.eclipse.gmf.gmfgraph.Node;
import org.eclipse.gmf.gmfgraph.provider.GMFGraphItemProviderAdapterFactory;
import org.eclipse.gmf.mappings.CanvasMapping;
import org.eclipse.gmf.mappings.GMFMapFactory;
import org.eclipse.gmf.mappings.LabelMapping;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.Mapping;
import org.eclipse.gmf.mappings.MappingEntry;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.provider.GMFMapItemProviderAdapterFactory;
import org.eclipse.gmf.tooldef.AbstractTool;
import org.eclipse.gmf.tooldef.ToolRegistry;
import org.eclipse.gmf.tooldef.provider.GMFToolItemProviderAdapterFactory;

/**
 * @@author artem
 */
public class WizardInput {
	private EPackage myDomainModel;
	private Canvas myCanvas;
	private ToolRegistry myRegistry;
	private Mapping mapInstance;
	private List/*<EClass>*/ myNodeCandidates;
	private List/*<ENamedElement>*/ myLinkCandidates;
	private Hierarchy myHierarchy;
	private final IFile[] myResultContainer;
	private EditingDomain myEditingDomain;
	private AdapterFactory myAdapterFactory;

	public WizardInput(IFile[] resultContainer) {
		myResultContainer = resultContainer;
	}
	
	public AdapterFactory getAdapterFactory() {
		if (myAdapterFactory == null) {
			List factories = new ArrayList();
			factories.add(new ResourceItemProviderAdapterFactory());
			factories.add(new GMFMapItemProviderAdapterFactory());
			factories.add(new GMFGraphItemProviderAdapterFactory());
			factories.add(new GMFToolItemProviderAdapterFactory());
			factories.add(new ReflectiveItemProviderAdapterFactory());

			myAdapterFactory = new ComposedAdapterFactory(factories);
		}
		return myAdapterFactory;
	}
	
	public EditingDomain getEditingDomain() {
		if (myEditingDomain == null) {
			myEditingDomain = new AdapterFactoryEditingDomain(getAdapterFactory(), new BasicCommandStack());
		}
		return myEditingDomain;
	}

	public ResourceSet getResourceSet() {
		return getEditingDomain().getResourceSet();
	}

	public void setDomainModel(EPackage aPackage) {
		checkUnload(myDomainModel);
		myDomainModel = aPackage;
	}

	public void setGraphDef(Canvas canvas) {
		checkUnload(myCanvas);
		myCanvas = canvas;
	}

	public void setToolDef(ToolRegistry registry) {
		checkUnload(myRegistry);
		myRegistry = registry;
	}

	public IFile getMappingFile() {
		return myResultContainer[0];
	}

	public Mapping getMapping() {
		if (mapInstance == null) {
			mapInstance = GMFMapFactory.eINSTANCE.createMapping();
			URI res = URI.createPlatformResourceURI(getMappingFile().getFullPath().toString());
			getResourceSet().createResource(res).getContents().add(mapInstance);
		}
		return mapInstance;
	}

	public boolean isReady2Go() {
		return myDomainModel != null && myCanvas != null /*&& myRegistry != null*/;
	}

	private void checkUnload(EObject eobj) {
		if (eobj == null) {
			return;
		}
		if (eobj.eResource().getResourceSet() == getResourceSet() && eobj.eResource().isLoaded()) {
			eobj.eResource().unload();
		}
	}
	public List/*<EClass>*/ getCanvasElementCandidates() {
		UniqueEList rv = new UniqueEList();
		for (Iterator it = myDomainModel.getEClassifiers().iterator(); it.hasNext();) {
			Object next = it.next();
			if (next instanceof EClass) {
				EClass eClass = (EClass) next;
				if (!eClass.isAbstract() && !eClass.isInterface() && !eClass.getEAllContainments().isEmpty()) {
					rv.add(eClass);
				}
			}
		}
		return rv;
	}

	public void selectCanvasElement(EClass eClass) {
		assert eClass.getEPackage() == myDomainModel;
		CanvasMapping cm;
		if (getMapping().getDiagram() == null) {
			cm =  GMFMapFactory.eINSTANCE.createCanvasMapping();
			cm.setDiagramCanvas(myCanvas);
			// +palette/gmfgraph.canvas
		} else {
			cm = getMapping().getDiagram();
		}
		cm.setDomainMetaElement(eClass);
		cm.setDomainModel(eClass.getEPackage());
		getMapping().setDiagram(cm);
	}

	public void feedDefaultMapping() {
		final Hierarchy hierarchy = getHierarchy();
		myNodeCandidates = new UniqueEList(hierarchy.getAccessibleClasses());
		myLinkCandidates = new UniqueEList(hierarchy.getAccessibleLinkClasses());
		List/*<EClass>*/ nodeProposals = new UniqueEList();
		List/*<EClass>*/ linkProposals = new UniqueEList();
		for (Iterator iter = myNodeCandidates.iterator(); iter.hasNext();) {
			EClass element = (EClass) iter.next();
			if (hierarchy.isLeaf(element)) {
				nodeProposals.add(element);
			}
		}
		for (Iterator iter = myLinkCandidates.iterator(); iter.hasNext();) {
			EClass element = (EClass) iter.next();
			if (hierarchy.isLeaf(element)) {
				linkProposals.add(element);
			}
		}
		myLinkCandidates.addAll(hierarchy.getAccessibleReferences());
		linkProposals.addAll(hierarchy.getAccessibleReferences(nodeProposals.iterator()));
		getMapping().getNodes().clear();
		// FIXME CCE - TopNodeReference!!!
		getMapping().getNodes().addAll(nodesFrom(nodeProposals));
		getMapping().getLinks().clear();
		getMapping().getLinks().addAll(linksFrom(linkProposals));
	}

	private Hierarchy getHierarchy() {
		if (myHierarchy == null) {
			myHierarchy = new Hierarchy(getMapping().getDiagram().getDomainMetaElement().getEAllContainments(), myDomainModel);
			myHierarchy.collect();
		}
		return myHierarchy;
	}

	public NodeMapping[] nodeCandidates() {
		return (NodeMapping[]) nodesFrom(myNodeCandidates).toArray(new NodeMapping[0]);
	}

	public LinkMapping[] linkCandidates() {
		return (LinkMapping[]) linksFrom(myLinkCandidates).toArray(new LinkMapping[0]);
	}

	private List nodesFrom(List candidates) {
		BasicEList rv = new BasicEList(candidates.size());
		for (Iterator iter = candidates.iterator(); iter.hasNext();) {
			EClass eClass = (EClass) iter.next();
			NodeMapping nm = GMFMapFactory.eINSTANCE.createNodeMapping();
			nm.setDomainMetaElement(eClass);
			// FIXME [containment] !!! nm.setContainmentFeature(getHierarchy().backRef(eClass));
			nm.setDiagramNode(findSuitableNode(nm));
			addEditFeature(nm, eClass);
			nm.setTool(findTool(nm));
			rv.add(nm);
		}
		return rv;
	}

	private List/*<LinkMapping>*/ linksFrom(List candidates) {
		BasicEList rv = new BasicEList(candidates.size());
		for (Iterator iter = candidates.iterator(); iter.hasNext();) {
			Object next = iter.next();
			LinkMapping lm = GMFMapFactory.eINSTANCE.createLinkMapping();
			if (next instanceof EClass) {
				EClass eClass = (EClass) next;
				lm.setDomainMetaElement(eClass);
				lm.setContainmentFeature(getHierarchy().backRef(eClass));
				addEditFeature(lm, eClass);
				lm.setLinkMetaFeature(getHierarchy().getLinkFeature(eClass));
			} else {
				lm.setLinkMetaFeature((EReference) next);
			}
			lm.setDiagramLink(findSuitableLink(lm));
			lm.setTool(findTool(lm));
			rv.add(lm);
		}
		return rv;
	}

	private Node findSuitableNode(NodeMapping nm) {
		String name = nm.getDomainMetaElement() == null ? null : nm.getDomainMetaElement().getName();
		return (Node) doSearch(myCanvas.getNodes(), name);
	}

	private Connection findSuitableLink(LinkMapping lm) {
		String name = null;
		if (lm.getDomainMetaElement() != null) {
			name = lm.getDomainMetaElement().getName();
		} else if (lm.getLinkMetaFeature() != null) {
			name = lm.getLinkMetaFeature().getEContainingClass().getName();
		}
		return (Connection) doSearch(myCanvas.getConnections(), name);
	}

	private DiagramElement doSearch(List/*<DiagramElement>*/ elements, String namePart) {
		if (elements.isEmpty()) {
			return null;
		}
		if (namePart != null) {
			DiagramElement c = matchName(elements, namePart);
			if (c != null) {
				return c;
			}
		}
		return (DiagramElement) elements.get(0);
	}

	private DiagramElement matchName(List/*<DiagramElement>*/ elements, String namePart) {
		for (Iterator it = elements.iterator(); it.hasNext();) {
			DiagramElement next = (DiagramElement) it.next();
			if (next.getName() != null && next.getName().indexOf(namePart) >= 0) {
				return next;
			}
		}
		return null;
	}

	private AbstractTool findTool(NodeMapping nm) {
		return null;
	}

	private AbstractTool findTool(LinkMapping lm) {
		return null;
	}

	private void addEditFeature(MappingEntry me, EClass class1) {
		for (Iterator it = class1.getEAllAttributes().iterator(); it.hasNext();) {
			EAttribute n = (EAttribute) it.next();
			if (EcorePackage.eINSTANCE.getEString().equals(n.getEType())) {
				LabelMapping lm = GMFMapFactory.eINSTANCE.createLabelMapping();
				lm.getFeatures().add(n);
				return;
			}
		}
	}

	private static class Hierarchy {
		private final List/*<EReference>*/ myRefs;
		private final EPackage myDomainModel2;
		private final Map/*<EClass, Set<EClass>>*/ myResult;
		private Set myAccessibleLeaves;
		private Set myAccessibleClasses = new HashSet();
		private Set myAccessibleLinkClasses = new HashSet();

		public Hierarchy(List/*<EReference>*/ eRefs, EPackage domainModel) {
			myRefs = eRefs;
			myDomainModel2 = domainModel;
			myResult = new HashMap();
			for (Iterator iter = eRefs.iterator(); iter.hasNext();) {
				EReference element = (EReference) iter.next();
				myResult.put(element.getEReferenceType(), new HashSet());
			}
		}

		public EReference backRef(EClass element) {
			for (Iterator it2 = myRefs.iterator(); it2.hasNext();) {
				EReference r = (EReference) it2.next();
				if (r.getEReferenceType().isSuperTypeOf(element)) {
					return r;
				}
			}
			return null;
		}

		public boolean isLeaf(EClass element) {
			return myAccessibleLeaves.contains(element);
		}

		public EReference getLinkFeature(EClass element) {
			BasicEList l = collectAllNonContainment(element);
			if (l.isEmpty()) {
				return null;
			}
			for (Iterator iter = l.iterator(); iter.hasNext();) {
				EReference ref = (EReference) iter.next();
				if (element.isSuperTypeOf(ref.getEReferenceType())) {
					continue;
				}
				for (Iterator it2 = myResult.keySet().iterator(); it2.hasNext();) {
					EClass c = (EClass) it2.next();
					if (c.isSuperTypeOf(ref.getEReferenceType())) {
						return ref;
					}
				}
			}
			return null;
		}
		public void collect() {
			collect(true);
		}

		private void collect(boolean recurse) {
			Set nonLeaves = new HashSet();
			final HashSet leavesSet = new HashSet();
			for (Iterator it = myDomainModel2.getEClassifiers().iterator(); it.hasNext();) {
				Object next = it.next();
				if (next instanceof EClass) {
					EClass eClass = (EClass) next;
					for (Iterator it2 = myResult.entrySet().iterator(); it2.hasNext();) {
						Map.Entry entry = (Map.Entry) it2.next();
						EClass element = (EClass) entry.getKey();
						if (element.isSuperTypeOf(eClass)) {
							((Set) entry.getValue()).add(eClass);
							if (recurse) {
								Hierarchy h2 = new Hierarchy(eClass.getEAllContainments(), myDomainModel2);
								h2.collect(false);
								myAccessibleLinkClasses .addAll(h2.getAccessibleClasses());
								leavesSet.addAll(h2.myAccessibleLeaves);
							}
							if (!eClass.isAbstract() &&  !eClass.isInterface()) {
								myAccessibleClasses.add(eClass);
							}
							nonLeaves.addAll(eClass.getESuperTypes());
						}
					}
				}
			}
			leavesSet.addAll(myAccessibleClasses);
			leavesSet.removeAll(nonLeaves);
			myAccessibleLeaves = Collections.unmodifiableSet(leavesSet);
			myAccessibleClasses = Collections.unmodifiableSet(myAccessibleClasses);
			myAccessibleLinkClasses = Collections.unmodifiableSet(myAccessibleLinkClasses);
		}

		public Set/*<EClass>*/ getAccessibleClasses() {
			return myAccessibleClasses;
		}

		public Set/*<EClass>*/ getAccessibleLinkClasses() {
			return myAccessibleLinkClasses;
		}

		public Set/*<EReference>*/ getAccessibleReferences() {
			return getAccessibleReferences(myAccessibleClasses.iterator());
		}

		public Set/*<EReference>*/ getAccessibleReferences(Iterator/*<EClass>*/ iter) {
			HashSet rv = new HashSet();
			for (; iter.hasNext();) {
				EClass element = (EClass) iter.next();
				rv.addAll(collectAllNonContainment(element));
			}
			return rv;
		}

		private BasicEList collectAllNonContainment(EClass element) {
			BasicEList l = new BasicEList(element.getEAllReferences());
			l.removeAll(element.getEAllContainments());
			return l;
		}
	}
}
@


1.7
log
@#127464 unlimited hierarchies in the GMFMap with possible reuse of mapping entries
@
text
@@


1.6
log
@#129047 get rid of explicit edit/label features, use generic and feature-rich LabelMapping instead.
@
text
@d192 1
d220 1
a220 1
			nm.setContainmentFeature(getHierarchy().backRef(eClass));
@


1.5
log
@set created file names in dashboard
@
text
@d48 1
d51 1
d221 1
a221 1
			nm.setEditFeature(findEditFeature(eClass));
d237 1
a237 1
				lm.setLabelEditFeature(findEditFeature(eClass));
d295 1
a295 1
	private EAttribute findEditFeature(EClass class1) {
d299 3
a301 1
				return n;
a303 1
		return null;
@


1.4
log
@associate canvas
@
text
@d115 4
d122 1
a122 1
			URI res = URI.createPlatformResourceURI(myResultContainer[0].getFullPath().toString());
@


1.3
log
@#114186
@
text
@d155 1
@


1.2
log
@simple logic to get gmfgraph elements
@
text
@d14 1
d23 3
d27 1
d36 5
a40 1
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
d45 1
d51 1
d54 1
a59 1
	private ResourceSet resourceSet;
d67 27
a93 2

	public WizardInput() {
d97 1
a97 4
		if (resourceSet == null) {
			resourceSet = new ResourceSetImpl();
		}
		return resourceSet;
d118 2
d132 1
a132 1
		if (eobj.eResource().getResourceSet() == resourceSet && eobj.eResource().isLoaded()) {
@


1.1
log
@Moving towards #114186 - wizard to define map model (although almost no-op now)
@
text
@d34 1
d208 2
a209 1
		return null;
d213 29
@

