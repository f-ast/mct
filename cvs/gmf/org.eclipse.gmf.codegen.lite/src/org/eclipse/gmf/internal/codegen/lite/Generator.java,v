head	1.54;
access;
symbols
	v20080910-1520:1.54
	v20080722-1827:1.54
	v20080716-1642:1.54
	R2_1_maintenance:1.54.0.2
	Root_R2_1_maintenance:1.54
	R2_1_0:1.54
	v20080507-1326:1.54
	v20080501-1739:1.54
	v20080425-1959:1.54
	v20080322-0000:1.53
	v20071108-0000:1.53
	v20071003-0000:1.52
	v20070921-0000:1.49.2.1
	v20070915-0000:1.49
	v20070903-0000:1.51
	v20070809-0000:1.49
	R2_0_maintenance:1.49.0.2
	R2_0:1.49
	R4_20:1.49
	v20070621-0000:1.49
	RC3_20:1.46
	v20070614-1400:1.46
	v20070608-1300:1.46
	v20070601-1400:1.46
	v20070525-1500:1.46
	v20070520-1200:1.46
	v20070518-1300:1.46
	v20070504-1000:1.45
	v20070427-0600:1.45
	v20070420-1000:1.45
	v20070413-1300:1.45
	v20070405-1100:1.44
	v20070403-1500:1.43
	v20070330-1300:1.43
	v20060330-1300:1.43
	v20070322-1100:1.40
	v20060316-0600:1.38
	v20070307-0700:1.37
	v20070228-2000:1.34
	v20070221-1500:1.33
	v20070208-1800:1.33
	v20070103-0300:1.25
	M4_20:1.25
	v20061222-1800:1.24
	v20061214-0000:1.21
	v20061120-1300:1.19
	M3_20:1.19
	v20061117-0800:1.19
	v20061013-1330:1.15
	v20061005-1700:1.9
	M1_20:1.14
	v20060904-1500:1.14
	v20060824-1600:1.9
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060626-1420:1.9
	v20060620-0400:1.9
	v20060616-1400:1.8
	v20060616-1200:1.8
	v20060609-1400:1.8
	v20060531-1730:1.6
	v20060530-1930:1.5
	v20060526-1200:1.5
	v20060519-1300:1.4
	v20060519-0800:1.3
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.54
date	2008.04.14.14.20.36;	author atikhomirov;	state Exp;
branches;
next	1.53;
commitid	2a06480368334567;

1.53
date	2007.10.31.17.16.42;	author bblajer;	state Exp;
branches;
next	1.52;
commitid	79fa4728b8794567;

1.52
date	2007.09.18.10.18.54;	author bblajer;	state Exp;
branches;
next	1.51;
commitid	6ac646efa60d4567;

1.51
date	2007.08.13.14.11.02;	author bblajer;	state Exp;
branches;
next	1.50;
commitid	65c246c066754567;

1.50
date	2007.07.04.13.22.26;	author bblajer;	state Exp;
branches;
next	1.49;
commitid	405d468b9f0f4567;

1.49
date	2007.06.21.14.06.23;	author atikhomirov;	state Exp;
branches
	1.49.2.1;
next	1.48;
commitid	154a467a85de4567;

1.48
date	2007.06.20.10.16.10;	author bblajer;	state Exp;
branches;
next	1.47;
commitid	37dd4678fe694567;

1.47
date	2007.06.15.09.53.04;	author bblajer;	state Exp;
branches;
next	1.46;
commitid	2a0c4672617d4567;

1.46
date	2007.05.04.14.08.44;	author bblajer;	state Exp;
branches;
next	1.45;
commitid	464d463b3e6a4567;

1.45
date	2007.04.12.13.06.34;	author bblajer;	state Exp;
branches;
next	1.44;
commitid	2433461e2eda4567;

1.44
date	2007.04.04.11.05.01;	author bblajer;	state Exp;
branches;
next	1.43;
commitid	18c54613864d4567;

1.43
date	2007.03.28.19.32.48;	author ashatalin;	state Exp;
branches;
next	1.42;
commitid	6e51460ac2dd4567;

1.42
date	2007.03.22.20.48.52;	author ashatalin;	state Exp;
branches;
next	1.41;
commitid	14b54602ebb34567;

1.41
date	2007.03.22.17.15.32;	author bblajer;	state Exp;
branches;
next	1.40;
commitid	5d864602b9b34567;

1.40
date	2007.03.20.16.03.43;	author bblajer;	state Exp;
branches;
next	1.39;
commitid	5e40460005de4567;

1.39
date	2007.03.20.14.49.11;	author ashatalin;	state Exp;
branches;
next	1.38;
commitid	75dd45fff4664567;

1.38
date	2007.03.09.17.19.35;	author bblajer;	state Exp;
branches;
next	1.37;
commitid	22ed45f197244567;

1.37
date	2007.03.03.23.45.11;	author bblajer;	state Exp;
branches;
next	1.36;
commitid	2e3145ea08814567;

1.36
date	2007.03.02.21.35.39;	author bblajer;	state Exp;
branches;
next	1.35;
commitid	403a45e898a74567;

1.35
date	2007.03.02.21.21.16;	author bblajer;	state Exp;
branches;
next	1.34;
commitid	2b1945e895484567;

1.34
date	2007.02.23.16.19.36;	author bblajer;	state Exp;
branches;
next	1.33;
commitid	496945df14164567;

1.33
date	2007.02.08.16.35.07;	author bblajer;	state Exp;
branches;
next	1.32;
commitid	4b245cb513a4567;

1.32
date	2007.02.07.00.52.32;	author atikhomirov;	state Exp;
branches;
next	1.31;
commitid	13ed45c922cf4567;

1.31
date	2007.02.05.18.36.56;	author bblajer;	state Exp;
branches;
next	1.30;
commitid	7e2645c779484567;

1.30
date	2007.02.02.21.46.31;	author atikhomirov;	state Exp;
branches;
next	1.29;
commitid	44c45c3b1364567;

1.29
date	2007.02.02.21.38.25;	author bblajer;	state Exp;
branches;
next	1.28;
commitid	728e45c3af504567;

1.28
date	2007.02.02.17.14.32;	author bblajer;	state Exp;
branches;
next	1.27;
commitid	78d445c371764567;

1.27
date	2007.02.01.13.33.33;	author atikhomirov;	state Exp;
branches;
next	1.26;
commitid	18c045c1ec2d4567;

1.26
date	2007.01.04.16.29.03;	author bblajer;	state Exp;
branches;
next	1.25;
commitid	2165459d2b4d4567;

1.25
date	2006.12.25.12.00.12;	author bblajer;	state Exp;
branches;
next	1.24;
commitid	430d458fbd4b4567;

1.24
date	2006.12.21.21.01.00;	author bblajer;	state Exp;
branches;
next	1.23;
commitid	24c8458af60b4567;

1.23
date	2006.12.21.20.35.34;	author bblajer;	state Exp;
branches;
next	1.22;
commitid	bee458af0104567;

1.22
date	2006.12.19.19.11.42;	author bblajer;	state Exp;
branches;
next	1.21;
commitid	733e4588396c4567;

1.21
date	2006.12.12.12.54.48;	author bblajer;	state Exp;
branches;
next	1.20;
commitid	355b457ea6574567;

1.20
date	2006.11.23.18.57.16;	author bblajer;	state Exp;
branches;
next	1.19;
commitid	66934565ef0a4567;

1.19
date	2006.11.09.18.15.43;	author bblajer;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.27.12.29.05;	author bblajer;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.19.11.00.31;	author bblajer;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.17.14.50.08;	author bblajer;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.21.10.12.03;	author atikhomirov;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.01.16.14.09;	author atikhomirov;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.30.17.55.30;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.28.17.20.15;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.02.10.43.52;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.03.17.42.27;	author ashatalin;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.19.19.14.13;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.06.16.22.12;	author radvorak;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.05.13.35.59;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.31.15.54.57;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.22.18.22.10;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.19.14.30.20;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.18.19.12.41;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.10.12.04.25;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.13.21.20.16;	author atikhomirov;	state Exp;
branches;
next	;

1.49.2.1
date	2007.09.17.16.02.13;	author bblajer;	state Exp;
branches;
next	;
commitid	7b9846eea5004567;


desc
@@


1.54
log
@unused SupressWarnings
@
text
@/*
 * Copyright (c) 2005, 2008 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Artem Tikhomirov (Borland) - initial API and implementation
 */
package org.eclipse.gmf.internal.codegen.lite;

import java.lang.reflect.InvocationTargetException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.emf.common.util.EList;
import org.eclipse.gmf.codegen.gmfgen.GMFGenPackage;
import org.eclipse.gmf.codegen.gmfgen.GenApplication;
import org.eclipse.gmf.codegen.gmfgen.GenChildLabelNode;
import org.eclipse.gmf.codegen.gmfgen.GenChildSideAffixedNode;
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
import org.eclipse.gmf.codegen.gmfgen.GenCompartment;
import org.eclipse.gmf.codegen.gmfgen.GenContainerBase;
import org.eclipse.gmf.codegen.gmfgen.GenCustomPropertyTab;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenEditorGenerator;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionInterpreter;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionProviderBase;
import org.eclipse.gmf.codegen.gmfgen.GenExpressionProviderContainer;
import org.eclipse.gmf.codegen.gmfgen.GenLanguage;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenLinkLabel;
import org.eclipse.gmf.codegen.gmfgen.GenNavigatorChildReference;
import org.eclipse.gmf.codegen.gmfgen.GenNode;
import org.eclipse.gmf.codegen.gmfgen.GenNodeLabel;
import org.eclipse.gmf.codegen.gmfgen.GenPreferencePage;
import org.eclipse.gmf.codegen.gmfgen.GenPropertyTab;
import org.eclipse.gmf.codegen.gmfgen.GenStandardPreferencePage;
import org.eclipse.gmf.codegen.gmfgen.OpenDiagramBehaviour;
import org.eclipse.gmf.common.UnexpectedBehaviourException;
import org.eclipse.gmf.common.codegen.ImportAssistant;
import org.eclipse.gmf.internal.common.codegen.GeneratorBase;
import org.eclipse.gmf.internal.common.codegen.TextEmitter;
import org.eclipse.gmf.internal.common.codegen.TextMerger;

/**
 * Invokes templates to populate diagram editor project.
 * TODO reuse fullRT.Generator as much as possible
 * @@author artem
 */
public class Generator extends GeneratorBase implements Runnable {

	private final GenEditorGenerator myEditorGen; 

	private final GenDiagram myDiagram;

	private final CodegenEmitters myEmitters;

	public Generator(GenEditorGenerator genModel) {
		this(genModel, Activator.getInstance().getEmitters(genModel));
	}

	public Generator(GenEditorGenerator genModel, CodegenEmitters emitters) {
		assert genModel != null && emitters != null;
		myDiagram = genModel.getDiagram();
		myEditorGen = genModel;
		myEmitters = emitters;
	}

	@@Override
	protected TextMerger createMergeService() {
		return myEmitters.createMergeService();
	}

	@@SuppressWarnings("unchecked")
	protected void customRun() throws InterruptedException, UnexpectedBehaviourException {
		final String pluginID = myEditorGen.getPlugin().getID();
		final Path examplaryLocation = new Path(myEditorGen.getDomainGenModel().getModelDirectory());
		initializeEditorProject(pluginID, guessNewProjectLocation(examplaryLocation, pluginID));

		doGenerateFile(myEmitters.getManifestGenerator(), new Path("META-INF/MANIFEST.MF"), new Object[] { myEditorGen.getPlugin() });
		doGenerateFile(myEmitters.getBuildPropertiesGenerator(), new Path("build.properties"), new Object[] { myEditorGen.getPlugin() });
		doGenerateFile(myEmitters.getPluginXML(), new Path("plugin.xml"), new Object[] { myEditorGen.getPlugin() });
		doGenerateFile(myEmitters.getPluginPropertiesGenerator(), new Path("plugin.properties"), new Object[] { myEditorGen.getPlugin() });

		internalGenerateJavaClass(myEmitters.getCreationWizardGenerator(), myDiagram.getCreationWizardQualifiedClassName(), myDiagram);
		internalGenerateJavaClass(myEmitters.getCreationWizardPageGenerator(), myDiagram.getCreationWizardPageQualifiedClassName(), myDiagram);
		internalGenerateJavaClass(myEmitters.getPluginGenerator(), myEditorGen.getPlugin().getActivatorQualifiedClassName(), myEditorGen.getPlugin());
		internalGenerateJavaClass(myEmitters.getInitDiagramFileActionGenerator(), myDiagram.getInitDiagramFileActionQualifiedClassName(), myDiagram);
		internalGenerateJavaClass(myEmitters.getModelElementSelectionPageEmitter(), myEmitters.getModelElementSelectionPageQualifiedNameEmitter(), myDiagram);
		internalGenerateJavaClass(myEmitters.getNewDiagramFileWizardGenerator(), myDiagram.getNewDiagramFileWizardQualifiedClassName(), myDiagram);
		if (myEditorGen.getApplication() != null) {
			internalGenerateJavaClass(myEmitters.getURISelectorPageGenerator(), myEmitters.getURISelectorPageQualifiedClassNameGenerator(), myDiagram);
		}
		if (myDiagram.generateCreateShortcutAction()) {
			internalGenerateJavaClass(myEmitters.getCreateShortcutActionEmitter(), myDiagram.getCreateShortcutActionQualifiedClassName(), myDiagram);
			if (myEditorGen.getApplication() != null) {
				internalGenerateJavaClass(myEmitters.getShortcutCreationWizardEmitter(), myEmitters.getShortcutCreationWizardQualifiedClassNameEmitter(), myDiagram);
			} else {
				internalGenerateJavaClass(myEmitters.getElementChooserEmitter(), myDiagram.getElementChooserQualifiedClassName(), myDiagram);
			}
		}
		if (myDiagram.generateShortcutIcon()) {
			internalGenerateJavaClass(myEmitters.getShortcutProviderEmitter(), myEmitters.getShortcutProviderQualifiedClassNameEmitter(), myDiagram);
			internalGenerateJavaClass(myEmitters.getCreateShortcutNodeCommandEmitter(), myEmitters.getCreateShortcutNodeCommandQualifiedClassNameEmitter(), myDiagram);
			internalGenerateJavaClass(myEmitters.getCreateShortcutEdgeCommandEmitter(), myEmitters.getCreateShortcutEdgeCommandQualifiedClassNameEmitter(), myDiagram);
			generateShortcutIcon();
			if (myEditorGen.getApplication() == null) {
				internalGenerateJavaClass(myEmitters.getShortcutPropertyTesterEmitter(), myDiagram.getShortcutPropertyTesterQualifiedClassName(), myDiagram);
			}
		}
		internalGenerateJavaClass(myEmitters.getLoadResourceActionGenerator(), myDiagram.getLoadResourceActionQualifiedClassName(), myDiagram);
		internalGenerateJavaClass(myEmitters.getElementTypesGenerator(), myDiagram.getElementTypesQualifiedClassName(), myDiagram);

		internalGenerateJavaClass(myEmitters.getActionBarContributorGenerator(), myEditorGen.getEditor().getActionBarContributorQualifiedClassName(), myEditorGen.getEditor());
		internalGenerateJavaClass(myEmitters.getDiagramEditorUtilGenerator(), myDiagram.getDiagramEditorUtilQualifiedClassName(), myDiagram);
		internalGenerateJavaClass(myEmitters.getEditorGenerator(), myEditorGen.getEditor().getQualifiedClassName(), myEditorGen.getEditor());
		if (myEditorGen.getEditor().isEclipseEditor()) {
			internalGenerateJavaClass(myEmitters.getMatchingStrategyEmitter(), myDiagram.getMatchingStrategyQualifiedClassName(), myDiagram);
		}
		if (myEditorGen.getApplication() == null && !myEditorGen.getEditor().isEclipseEditor()) {
			internalGenerateJavaClass(myEmitters.getOpenDiagramInViewActionGenerator(), myEmitters.getOpenDiagramInViewActionQualifiedClassNameGenerator(), myEditorGen.getEditor());
		}
		if (myDiagram.getPalette() != null) {
			internalGenerateJavaClass(myEmitters.getPaletteFactoryGenerator(), myDiagram.getPalette().getFactoryQualifiedClassName(), myDiagram.getPalette());
		}
		internalGenerateJavaClass(myEmitters.getEditPartFactoryGenerator(), myDiagram.getEditPartFactoryQualifiedClassName(), myDiagram);
		internalGenerateJavaClass(myEmitters.getDiagramEditPartGenerator(), myDiagram.getEditPartQualifiedClassName(), myDiagram);
		HashSet<OpenDiagramBehaviour> openDiagramBehaviors = new HashSet<OpenDiagramBehaviour>();
		generateBehaviors(myDiagram, openDiagramBehaviors);
		generateLayoutEditPolicy(myDiagram);

		if (myDiagram.isValidationEnabled() || myEditorGen.hasAudits()) {
			generateValidationProvider();
			if (myDiagram.getEditorGen().getApplication() == null) {
				//Strictly non-RCP stuff
				generateMarkerNavigationProvider();
			}
		}
		if (myDiagram.getEditorGen().getMetrics() != null) {
			generateMetricProvider();
		}

		for (GenNode next : (List<? extends GenNode>) myDiagram.getAllNodes()) {
			if (!(next instanceof GenChildLabelNode)) {
				internalGenerateJavaClass(myEmitters.getNodeEditPartGenerator(), next.getEditPartQualifiedClassName(), next);
				generateGraphicalEditPolicy(next);
				for (Iterator it2 = next.getLabels().iterator(); it2.hasNext();) {
					final GenNodeLabel label = (GenNodeLabel) it2.next();
					internalGenerateJavaClass(myEmitters.getNodeLabelEditPartGenerator(), label.getEditPartQualifiedClassName(), label);
					internalGenerateJavaClass(myEmitters.getViewFactoryGenerator(), label.getNotationViewFactoryQualifiedClassName(), label);
				}
			} else {
				internalGenerateJavaClass(myEmitters.getChildNodeEditPartGenerator(), next.getEditPartQualifiedClassName(), next);
			}
			internalGenerateJavaClass(myEmitters.getViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
			generateBehaviors(next, openDiagramBehaviors);
			generateCommands(next);
			generateComponentEditPolicy(next);
			boolean shouldGenerateLayoutEditPolicy = false;
			boolean shouldGenerateSideAffixedLayoutEditPolicy = false;
			for (GenNode nextChild : next.getChildNodes()) {
				if (nextChild instanceof GenChildSideAffixedNode) {
					shouldGenerateSideAffixedLayoutEditPolicy = true;
				} else {
					shouldGenerateLayoutEditPolicy = true;
				}
			}
			if (shouldGenerateLayoutEditPolicy) {
				generateLayoutEditPolicy(next);
			}
			if (shouldGenerateSideAffixedLayoutEditPolicy) {
				generateSideAffixedLayoutEditPolicy(next);
			}
		}
		for (GenLink next : (List<? extends GenLink>) myDiagram.getLinks()) {
			internalGenerateJavaClass(myEmitters.getLinkEditPartGenerator(), next.getEditPartQualifiedClassName(), next);
			generateGraphicalEditPolicy(next);
			if (next.getLabels().size() > 0) {
				generateConnectionEndpointEditPolicy(next);
			}
			for (GenLinkLabel label : (List<? extends GenLinkLabel>) next.getLabels()) {
				internalGenerateJavaClass(myEmitters.getLinkLabelEditPartGenerator(), label.getEditPartQualifiedClassName(), label);
				internalGenerateJavaClass(myEmitters.getViewFactoryGenerator(), label.getNotationViewFactoryQualifiedClassName(), label);
			}
			internalGenerateJavaClass(myEmitters.getViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
			generateBehaviors(next, openDiagramBehaviors);
			generateCommands(next);
			generateComponentEditPolicy(next);
		}
		for (Iterator it = myDiagram.getCompartments().iterator(); it.hasNext(); ) {
			final GenCompartment next = (GenCompartment) it.next();
			internalGenerateJavaClass(myEmitters.getCompartmentEditPartGenerator(), next.getEditPartQualifiedClassName(), next);
			internalGenerateJavaClass(myEmitters.getViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
			generateLayoutEditPolicy(next);
		}
		internalGenerateJavaClass(myEmitters.getViewFactoryGenerator(), myDiagram.getNotationViewFactoryQualifiedClassName(), myDiagram);
		internalGenerateJavaClass(myEmitters.getDomainElementInitializerGenerator(), myEmitters.getDomainElementInitializerQualifiedNameGenerator(), myDiagram);
		internalGenerateJavaClass(myEmitters.getVisualIDRegistryGenerator(), myDiagram.getVisualIDRegistryQualifiedClassName(), myDiagram);
		if(myDiagram.getEditorGen().getExpressionProviders() != null) {
			generateExpressionProviders();
		}
		if (isPathInsideGenerationTarget(myDiagram.getCreationWizardIconPathX())) {
			// at the moment this may produce path that reference generated icon file, thus
			// skip generation if the path is relative
			generateDiagramIcon(myDiagram.getCreationWizardIconPathX());
		}
		if (isPathInsideGenerationTarget(myEditorGen.getEditor().getIconPathX())) {
			// at the moment this may produce path that reference generated icon file, thus
			// skip generation if the path is relative
			generateDiagramIcon(myEditorGen.getEditor().getIconPathX());
		}
		generateWizardBanner();
		if (myEditorGen.getApplication() == null && myEditorGen.getNavigator() != null) {
			generateNavigatorContentProvider();
			generateNavigatorLabelProvider();
			generateNavigatorLinkHelper();
			generateNavigatorSorter();
			generateNavigatorActionProvider();
			generateAbstractNavigatorItem();
			generateNavigatorGroup();
			generateNavigatorItem();
			generateNavigatorGroupIcons();
			if (myEditorGen.getDomainGenModel() != null && myEditorGen.getNavigator().isGenerateDomainModelNavigator()) {
				generateDomainNavigatorContentProvider();
				generateDomainNavigatorLabelProvider();
				generateDomainNavigatorItem();
				generateDomainModelElementTester();
				generateURIEditorInputTester();
			}
		}
		if (myEditorGen.getPropertySheet() != null) {
			generatePropertySheetSections();
		}
		generateApplication();
		generatePreferences();
		generateExternalizationSupport();
	}

	private static boolean isPathInsideGenerationTarget(String path) {
		assert path != null;
		Path p = new Path(path);
		return !p.isAbsolute() && !p.segment(0).equals(".."); //$NON-NLS-1$
	}

	private void generateExpressionProviders() throws UnexpectedBehaviourException, InterruptedException {
		GenExpressionProviderContainer providerContainer = myEditorGen.getExpressionProviders();
		internalGenerateJavaClass(
			myEmitters.getAbstractExpressionEmitter(),
			providerContainer.getExpressionsPackageName(), 
			providerContainer.getAbstractExpressionClassName(),
			myDiagram
		);

		for (GenExpressionProviderBase nextProvider : (List<? extends GenExpressionProviderBase>) providerContainer.getProviders()) {
			if(nextProvider instanceof GenExpressionInterpreter) {
				TextEmitter providerEmitter = null;
				if(GenLanguage.OCL_LITERAL.equals(nextProvider.getLanguage())) {
					providerEmitter = myEmitters.getOCLExpressionFactoryEmitter();
				} else if(GenLanguage.REGEXP_LITERAL.equals(nextProvider.getLanguage()) || GenLanguage.NREGEXP_LITERAL.equals(nextProvider.getLanguage())) {
					providerEmitter = myEmitters.getRegexpExpressionFactoryEmitter();
				}
				GenExpressionInterpreter interpreter = (GenExpressionInterpreter)nextProvider;
				if(providerEmitter != null) {
					internalGenerateJavaClass(
							providerEmitter,
							providerContainer.getExpressionsPackageName(),
							interpreter.getClassName(),
							interpreter);
				}
			}
		}
	}

	private void generateShortcutIcon() throws UnexpectedBehaviourException, InterruptedException {
		doGenerateBinaryFile(myEmitters.getShortcutImageEmitter(), new Path("icons/shortcut.gif"), null); //$NON-NLS-1$
	}
	
	private void generateDiagramIcon(String path) throws UnexpectedBehaviourException, InterruptedException {
		// use genModel.prefix if available to match colors of model icons and diagram icons
		// @@see GenPackageImpl#generateEditor - it passes prefix to ModelGIFEmitter 
		Object[] args = new Object[] {myDiagram.getDomainDiagramElement() == null ? myEditorGen.getDiagramFileExtension() : myDiagram.getDomainDiagramElement().getGenPackage().getPrefix() };
		doGenerateBinaryFile(myEmitters.getDiagramIconEmitter(), new Path(path), args);
	}

	private void generateWizardBanner() throws UnexpectedBehaviourException, InterruptedException {
		// @@see GenPackageImpl#generateEditor - it passes prefix to ModelWizardGIFEmitter
		try {
			Object[] args = new Object[] {myEmitters.getWizardBannerStemEmitter().generate(new NullProgressMonitor(), new Object[] {myDiagram}) };
			String path = myEmitters.getWizardBannerLocationEmitter().generate(new NullProgressMonitor(), new Object[] {myDiagram});
			doGenerateBinaryFile(myEmitters.getWizardBannerImageEmitter(), new Path(path), args);
		} catch (InvocationTargetException e) {
			handleException(e);
		}
	}

	private void generateBehaviors(GenCommonBase element, HashSet<OpenDiagramBehaviour> generatedBehaviors) throws UnexpectedBehaviourException, InterruptedException {
		for (OpenDiagramBehaviour behaviour : element.getBehaviour(OpenDiagramBehaviour.class)) {
			if (!generatedBehaviors.contains(behaviour)) {
				generatedBehaviors.add(behaviour);
				generateOpenDiagramEditPolicy(behaviour);
			}
		}
	}

	private void generateValidationProvider() throws UnexpectedBehaviourException, InterruptedException {
		internalGenerateJavaClass(
			myEmitters.getValidationProviderGenerator(),
			myDiagram.getProvidersPackageName(),
			myDiagram.getValidationProviderClassName(),
			myDiagram);
		internalGenerateJavaClass(myEmitters.getValidateActionGenerator(), myEmitters.getValidateActionQualifiedNameGenerator(), myDiagram);
	}

	private void generateMarkerNavigationProvider() throws UnexpectedBehaviourException, InterruptedException {
		internalGenerateJavaClass(
			myEmitters.getMarkerNavigationProviderEmitter(), 
			myDiagram.getProvidersPackageName(), 
			myDiagram.getMarkerNavigationProviderClassName(), 
			myDiagram);
	}

	private void generateMetricProvider() throws UnexpectedBehaviourException, InterruptedException {
		internalGenerateJavaClass(
			myEmitters.getMetricProviderEmitter(),
			myDiagram.getProvidersPackageName(),
			myDiagram.getMetricProviderClassName(),
			myDiagram);
		internalGenerateJavaClass(myEmitters.getMetricsActionEmitter(), myEmitters.getMetricsActionQualifiedNameEmitter(), myDiagram);
	}	

	private void generateOpenDiagramEditPolicy(OpenDiagramBehaviour behaviour) throws UnexpectedBehaviourException, InterruptedException {
		internalGenerateJavaClass(myEmitters.getOpenDiagramEditPolicyEmitter(), behaviour.getEditPolicyQualifiedClassName(), behaviour);
	}

	private void generateCommands(GenNode genNode) throws UnexpectedBehaviourException, InterruptedException {
		if (!genNode.getDomainMetaClass().isAbstract()) {
			internalGenerateJavaClass(myEmitters.getCreateNodeCommandEmitter(), myEmitters.getCreateNodeCommandQualifiedClassNameEmitter(), genNode);
		}
		internalGenerateJavaClass(myEmitters.getAddNodeCommandEmitter(), myEmitters.getAddNodeCommandQualifiedClassNameEmitter(), genNode);
		internalGenerateJavaClass(myEmitters.getCloneNodeCommandEmitter(), myEmitters.getCloneNodeCommandQualifiedClassNameEmitter(), genNode);
	}

	private void generateCommands(GenLink genLink) throws UnexpectedBehaviourException, InterruptedException {
		if (!genLink.isViewDirectionAlignedWithModel()) {
			return;
		}
		internalGenerateJavaClass(myEmitters.getCreateLinkStartCommandEmitter(), myEmitters.getCreateLinkStartCommandQualifiedClassNameEmitter(), genLink);
		internalGenerateJavaClass(myEmitters.getCreateLinkCompleteCommandEmitter(), myEmitters.getCreateLinkCompleteCommandQualifiedClassNameEmitter(), genLink);
		internalGenerateJavaClass(myEmitters.getReconnectLinkSourceCommandEmitter(), myEmitters.getReconnectLinkSourceCommandQualifiedClassNameEmitter(), genLink);
		internalGenerateJavaClass(myEmitters.getReconnectLinkTargetCommandEmitter(), myEmitters.getReconnectLinkTargetCommandQualifiedClassNameEmitter(), genLink);
	}

	private void generateLayoutEditPolicy(GenContainerBase containerBase) throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(myEmitters.getLayoutEditPolicyEmitter(), myEmitters.getLayoutEditPolicyQualifiedClassNameEmitter(), containerBase);
	}

	private void generateSideAffixedLayoutEditPolicy(GenNode node) throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(myEmitters.getSideAffixedLayoutEditPolicyEmitter(), myEmitters.getSideAffixedLayoutEditPolicyQualifiedClassNameEmitter(), node);
	}

	private void generateGraphicalEditPolicy(GenNode genNode) throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(myEmitters.getGraphicalEditPolicyEmitter(), genNode.getGraphicalNodeEditPolicyQualifiedClassName(), genNode);
	}

	private void generateGraphicalEditPolicy(GenLink genLink) throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(myEmitters.getGraphicalEditPolicyEmitter(), myEmitters.getGraphicalEditPolicyQualifiedClassNameEmitter(), genLink);
	}

	private void generateComponentEditPolicy(GenCommonBase genElement) throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(myEmitters.getComponentEditPolicyEmitter(), myEmitters.getComponentEditPolicyQualifiedClassNameEmitter(), genElement);
	}

	private void generateConnectionEndpointEditPolicy(GenLink genLink) throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(myEmitters.getConnectionEndpointEditPolicyEmitter(), myEmitters.getConnectionEndpointEditPolicyQualifiedClassNameEmitter(), genLink);
	}

	private void generateNavigatorContentProvider() throws InterruptedException {
		internalGenerateJavaClass(
				myEmitters.getNavigatorContentProviderEmitter(),
				myEditorGen.getNavigator().getPackageName(),
				myEditorGen.getNavigator().getContentProviderClassName(),
				myEditorGen.getNavigator()
			);
	}

	private void generateDomainNavigatorContentProvider() throws InterruptedException {
		doGenerateJavaClass(myEmitters.getDomainNavigatorContentProviderEmitter(), myEditorGen.getNavigator().getDomainContentProviderQualifiedClassName(), myEditorGen.getNavigator());
	}
	
	private void generateDomainNavigatorLabelProvider() throws InterruptedException {
		doGenerateJavaClass(myEmitters.getDomainNavigatorLabelProviderEmitter(), myEditorGen.getNavigator().getDomainLabelProviderQualifiedClassName(), myEditorGen.getNavigator());
	}
	
	private void generateDomainNavigatorItem() throws InterruptedException {
		doGenerateJavaClass(myEmitters.getDomainNavigatorItemEmitter(), myEditorGen.getNavigator().getDomainNavigatorItemQualifiedClassName(), myEditorGen.getNavigator());
	}
	
	private void generateDomainModelElementTester() throws InterruptedException {
		doGenerateJavaClass(myEmitters.getDomainModelElementTesterEmitter(), myEditorGen.getNavigator().getDomainModelElementTesterQualifiedClassName(), myEditorGen.getNavigator());
	}
	
	private void generateURIEditorInputTester() throws InterruptedException {
		doGenerateJavaClass(myEmitters.getURIEditorInputTesterEmitter(), myEditorGen.getNavigator().getUriInputTesterQualifiedClassName(), myEditorGen.getNavigator());
	}

	private void generateNavigatorLabelProvider() throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(
				myEmitters.getNavigatorLabelProviderEmitter(),
				myEditorGen.getNavigator().getPackageName(),
				myEditorGen.getNavigator().getLabelProviderClassName(),
				myEditorGen.getNavigator()
			);
	}
	
	private void generateNavigatorLinkHelper() throws InterruptedException {
		if (!myEditorGen.getEditor().isEclipseEditor()) {
			return;
		}
		internalGenerateJavaClass(
				myEmitters.getNavigatorLinkHelperEmitter(),
				myEditorGen.getNavigator().getPackageName(),
				myEditorGen.getNavigator().getLinkHelperClassName(), 
				myEditorGen.getNavigator()
			);
	}
	
	private void generateNavigatorSorter() throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(
				myEmitters.getNavigatorSorterEmitter(),
				myEditorGen.getNavigator().getPackageName(),
				myEditorGen.getNavigator().getSorterClassName(), 
				myEditorGen.getNavigator()
			);
	}
	
	private void generateNavigatorActionProvider() throws InterruptedException, UnexpectedBehaviourException {
		internalGenerateJavaClass(
				myEmitters.getNavigatorActionProviderEmitter(),
				myEditorGen.getNavigator().getPackageName(),
				myEditorGen.getNavigator().getActionProviderClassName(), 
				myEditorGen.getNavigator()
			);
	}
	
	private void generateAbstractNavigatorItem() throws InterruptedException, UnexpectedBehaviourException {
		doGenerateJavaClass(
				myEmitters.getAbstractNavigatorItemEmitter(),
				myEditorGen.getNavigator().getPackageName(),
				myEditorGen.getNavigator().getAbstractNavigatorItemClassName(),
				myEditorGen.getNavigator()
			);
	}
	
	private void generateNavigatorGroup() throws InterruptedException {
		internalGenerateJavaClass(
				myEmitters.getNavigatorGroupEmitter(),
				myEditorGen.getNavigator().getPackageName(),
				myEditorGen.getNavigator().getNavigatorGroupClassName(),
				myEditorGen.getNavigator()
			);
	}
	
	private void generateNavigatorItem() throws InterruptedException {
		internalGenerateJavaClass(
				myEmitters.getNavigatorItemEmitter(),
				myEditorGen.getNavigator().getPackageName(),
				myEditorGen.getNavigator().getNavigatorItemClassName(),
				myEditorGen.getNavigator()
			);
	}
	
	private void generateNavigatorGroupIcons() throws InterruptedException, UnexpectedBehaviourException {
		Set<String> groupIcons = new HashSet<String>();
		for (GenNavigatorChildReference nextReference : (List<? extends GenNavigatorChildReference>) myEditorGen.getNavigator().getChildReferences()) {
			if (nextReference.getGroupIcon() != null && nextReference.getGroupIcon().length() > 0) {
				groupIcons.add(nextReference.getGroupIcon());
			}
		}
		for (String iconPath : groupIcons) {
			generateGroupIcon(new Path(iconPath));
		}
	}
	
	private void generateGroupIcon(Path groupIconPath) throws InterruptedException, UnexpectedBehaviourException {
		doGenerateBinaryFile(myEmitters.getGroupIconEmitter(), groupIconPath, null);	
	}

	protected void generatePropertySheetSections() throws UnexpectedBehaviourException, InterruptedException {
		if (myEditorGen.getPropertySheet().isNeedsCaption()) {
			doGenerateJavaClass(
				myEmitters.getPropertySheetLabelProviderEmitter(), 
				myEditorGen.getPropertySheet().getLabelProviderQualifiedClassName(), 
				myEditorGen.getPropertySheet());
		}
		for (GenPropertyTab tab : (List<? extends GenPropertyTab>) myEditorGen.getPropertySheet().getTabs()) {
			if (tab instanceof GenCustomPropertyTab) {
				doGenerateJavaClass(
					myEmitters.getPropertySectionEmitter(),
					((GenCustomPropertyTab) tab).getQualifiedClassName(),
					tab);
			}
		}
	}

	private void generateApplication() throws UnexpectedBehaviourException, InterruptedException {
		GenApplication application = myEditorGen.getApplication();
		if (application != null) {
			doGenerateJavaClass(myEmitters.getApplicationEmitter(), application.getQualifiedClassName(), application);
			doGenerateJavaClass(myEmitters.getActionBarAdvisorEmitter(), application.getActionBarAdvisorQualifiedClassName(), application);
			doGenerateJavaClass(myEmitters.getPerspectiveEmitter(), application.getPerspectiveQualifiedClassName(), application);
			doGenerateJavaClass(myEmitters.getWorkbenchAdvisorEmitter(), application.getWorkbenchAdvisorQualifiedClassName(), application);
			doGenerateJavaClass(myEmitters.getWorkbenchWindowAdvisorEmitter(), application.getWorkbenchWindowAdvisorQualifiedClassName(), application);
		}
	}

	private void generatePreferences() throws UnexpectedBehaviourException, InterruptedException {
		generatePreferences(myDiagram.getPreferencePages());
	}

	private void generatePreferences(EList<GenPreferencePage> pages) throws UnexpectedBehaviourException, InterruptedException {
		for (GenPreferencePage preferencePage : pages) {
			if (preferencePage instanceof GenStandardPreferencePage) {
				generatePreferencePage((GenStandardPreferencePage) preferencePage);
			}
			generatePreferences(preferencePage.getChildren());
		}
	}

	private void generatePreferencePage(GenStandardPreferencePage preferencePage) throws UnexpectedBehaviourException, InterruptedException {
		switch (preferencePage.getKind()) {
		case APPEARANCE_LITERAL:
			internalGenerateJavaClass(myEmitters.getAppearancePreferencePageEmitter(), myEmitters.getAppearancePreferencePageQualifiedClassNameEmitter(), myDiagram);
			break;
		case GENERAL_LITERAL:
			internalGenerateJavaClass(myEmitters.getGeneralPreferencePageEmitter(), myEmitters.getGeneralPreferencePageQualifiedClassNameEmitter(), myDiagram);
			break;
		//TODO support more standard preference pages.
		}
	}

	private void generateExternalizationSupport() throws UnexpectedBehaviourException, InterruptedException {
        String packageName = myEditorGen.getEditor().getPackageName();
        String messagesClassName = "Messages";
        doGenerateJavaClass(myEmitters.getExternalizeEmitter(), packageName, messagesClassName, new Object[] { myEditorGen });
        doGenerateFile(myEmitters.getMessagesEmitter(), new Path(messagesClassName.toLowerCase()+".properties"), new Object[] { myEditorGen });
    }

	private void internalGenerateJavaClass(TextEmitter emitter, String qualifiedClassName, Object argument) throws InterruptedException {
		internalGenerateJavaClass(emitter, CodeGenUtil.getPackageName(qualifiedClassName), CodeGenUtil.getSimpleClassName(qualifiedClassName), argument);
	}

	private void internalGenerateJavaClass(TextEmitter emitter, TextEmitter qualifiedClassNameEmitter, Object argument) throws InterruptedException {
		String qualifiedClassName = null;
		try {
			qualifiedClassName = qualifiedClassNameEmitter.generate(new NullProgressMonitor(), new Object[] {argument});
		} catch (InvocationTargetException e) {
			handleException(e);
		} catch (UnexpectedBehaviourException e) {
			handleException(e);
		}
		internalGenerateJavaClass(emitter, qualifiedClassName, argument);
	}

	/**
	 * Passes initialized ImportManager as second template argument
	 */
	private void internalGenerateJavaClass(TextEmitter emitter, String packageName, String className, Object argument) throws InterruptedException {
		ImportAssistant importUtil = createImportAssistant(packageName, className);
		doGenerateJavaClass(emitter, packageName, className, argument, importUtil);
	}

	protected void setupProgressMonitor() {
		Counter c = new Counter();
		c.registerFactor(GMFGenPackage.eINSTANCE.getGenNode(), 2);
		c.registerFactor(GMFGenPackage.eINSTANCE.getGenCompartment(), 2);
		c.registerFactor(GMFGenPackage.eINSTANCE.getGenLink(), 2);
		c.registerFactor(GMFGenPackage.eINSTANCE.getGenNodeLabel(), 2);
		c.registerFactor(GMFGenPackage.eINSTANCE.getGenLinkLabel(), 2);
		int total = c.getTotal(myDiagram);
		total++; // init
		total += 4; // text files
		total += 15; // out-of-cycle doGenerateJava... <- genDiagram + genEditor
		setupProgressMonitor(null, total);
	}
}
@


1.53
log
@[208264]: [lite]: Implement border items
[208270]: [lite]: Feedback for element creation should show exactly where the element will be created
Move external label when a deep ancestor is moved;
NodeEditPart.xpt: add variation point to createEditPolicies;
AddNodeCommand.xpt: do not generate unused attribute
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2007 Borland Software Corporation
a252 1
	@@SuppressWarnings("unchecked")
a479 1
	@@SuppressWarnings("unchecked")
a495 1
	@@SuppressWarnings("unchecked")
@


1.52
log
@1. Preferences for fonts and colors
2. ResourceManager employed to reuse fonts and colors used for styles
3. Option to check the availability of the font name that is specified in the style
4. Styles are initialized with defaults from preferences
@
text
@d27 1
d167 15
a181 1
			generateLayoutEditPolicy(next);
d366 4
@


1.51
log
@1. Don't cache templates if dynamic templates option is on;
2. [199747] Support shortcuts in the Lite diagrams (including notation model update for links between alien shortcuts);
3. Decorations should be visible;
4. TransactionalUpdateManager: more notifications to be dispatched to parents, make it possible to add more in subclasses;
5. On element creation, it should be given an opportunity to contribute its notational update commands;
6. [199749]: Delete from View supported (request, edit policy, command, UI action);
7. Add @@generated tags where they were missing;
8. ChildNotationModelRefresher: if the child feature is derived transient, notation model refresher should listen to containment feature.
@
text
@d23 1
d42 1
d44 1
d228 1
d508 26
a533 1
    private void generateExternalizationSupport() throws UnexpectedBehaviourException, InterruptedException {
@


1.50
log
@Eliminated Jet templates in lite version;
i18n in lite RT;
For generated classes whose names are not directly modifiable via gmfgen file, consistent className/qualifiedClassName template is exposed (and used throughout the generation process, including the Generator);
Link labels and external node labels are not selectable, but movable;
Inner elements are not selectable with marquee tool;
Fixed copyright statements throughout the lite RT.
@
text
@d93 1
d95 20
d187 1
a187 1
		internalGenerateJavaClass(myEmitters.getDomainElementInitializerGenerator(), myEmitters.getDomainElementInitializerQualifiedNameGenerator(), myDiagram); // XXX: allow customization!
d264 4
@


1.49
log
@fix copyright years
@
text
@a21 1
import org.eclipse.emf.codegen.ecore.genmodel.GenFeature;
a22 1
import org.eclipse.gmf.codegen.gmfgen.FeatureLinkModelFacet;
a42 1
import org.eclipse.gmf.codegen.gmfgen.TypeLinkModelFacet;
d104 1
a104 4
			//See plugin.xmljet
			String className = "OpenDiagramIn" + myEditorGen.getDomainGenModel().getModelName() + "DiagramViewAction";
			className = CodeGenUtil.validJavaIdentifier(className);
			internalGenerateJavaClass(myEmitters.getOpenDiagramInViewActionGenerator(), myEditorGen.getEditor().getPackageName(), className, myEditorGen.getEditor());
d147 3
d276 1
d293 1
a300 1
		String commandNameInfix = genNode.getDomainMetaClass().getName() + genNode.getVisualID();
d302 4
a305 16
			internalGenerateJavaClass(myEmitters.getCreateNodeCommandEmitter(), 
					myDiagram.getEditCommandsPackageName(),
					"Create" + commandNameInfix + "Command",
					genNode
				);
		}
		internalGenerateJavaClass(myEmitters.getAddNodeCommandEmitter(), 
				myDiagram.getEditCommandsPackageName(),
				"Add" + commandNameInfix + "Command",
				genNode
			);
		internalGenerateJavaClass(myEmitters.getCloneNodeCommandEmitter(), 
				myDiagram.getEditCommandsPackageName(),
				"Clone" + commandNameInfix + "Command",
				genNode
			);
d312 4
a315 35
		String commandNameInfix;
		if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
			TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) genLink.getModelFacet();
			commandNameInfix = modelFacet.getMetaClass().getName();
		} else if (genLink.getModelFacet() instanceof FeatureLinkModelFacet) {
			GenFeature metaFeature = ((FeatureLinkModelFacet) genLink.getModelFacet()).getMetaFeature();
			commandNameInfix = metaFeature.getFeatureAccessorName();
		} else {
			return;
		}
		commandNameInfix += genLink.getVisualID();
		internalGenerateJavaClass(
				myEmitters.getCreateLinkStartCommandEmitter(),
				myDiagram.getEditCommandsPackageName(),
				"Create" + commandNameInfix + "StartCommand",
				genLink
			);
		internalGenerateJavaClass(
				myEmitters.getCreateLinkCompleteCommandEmitter(),
				myDiagram.getEditCommandsPackageName(),
				"Create" + commandNameInfix + "Command",
				genLink
			);
		internalGenerateJavaClass(
				myEmitters.getReconnectLinkSourceCommandEmitter(),
				myDiagram.getEditCommandsPackageName(),
				"Reconnect" + commandNameInfix + "SourceCommand",
				genLink
			);
		internalGenerateJavaClass(
				myEmitters.getReconnectLinkTargetCommandEmitter(),
				myDiagram.getEditCommandsPackageName(),
				"Reconnect" + commandNameInfix + "TargetCommand",
				genLink
			);
d319 1
a319 6
		String editPolicyClassName = containerBase.getEditPartClassName();
		if (editPolicyClassName.endsWith(GenCommonBase.EDIT_PART_SUFFIX)) {
			editPolicyClassName = editPolicyClassName.substring(0, editPolicyClassName.length() - GenCommonBase.EDIT_PART_SUFFIX.length());
		}
		editPolicyClassName += "LayoutEditPolicy";
		internalGenerateJavaClass(myEmitters.getLayoutEditPolicyEmitter(), myDiagram.getEditPoliciesPackageName(), editPolicyClassName, containerBase);
d327 1
a327 6
		String editPolicyClassName = genLink.getEditPartClassName();
		if (editPolicyClassName.endsWith(GenCommonBase.EDIT_PART_SUFFIX)) {
			editPolicyClassName = editPolicyClassName.substring(0, editPolicyClassName.length() - GenCommonBase.EDIT_PART_SUFFIX.length());
		}
		editPolicyClassName += "GraphicalNodeEditPolicy";
		internalGenerateJavaClass(myEmitters.getGraphicalEditPolicyEmitter(), myDiagram.getEditPoliciesPackageName(), editPolicyClassName, genLink);
d331 5
a335 7
		//Actually, next is expected to be either GenLink or GenNode
		String editPolicyClassName = genElement.getEditPartClassName();
		if (editPolicyClassName.endsWith(GenCommonBase.EDIT_PART_SUFFIX)) {
			editPolicyClassName = editPolicyClassName.substring(0, editPolicyClassName.length() - GenCommonBase.EDIT_PART_SUFFIX.length());
		}
		editPolicyClassName += "ComponentEditPolicy";
		internalGenerateJavaClass(myEmitters.getComponentEditPolicyEmitter(), myDiagram.getEditPoliciesPackageName(), editPolicyClassName, genElement);
@


1.49.2.1
log
@Eliminated Jet templates in lite version;
i18n in lite RT;
For generated classes whose names are not directly modifiable via gmfgen file, consistent className/qualifiedClassName template is exposed (and used throughout the generation process, including the Generator)
@
text
@d22 1
d24 1
d45 1
d107 4
a110 1
			internalGenerateJavaClass(myEmitters.getOpenDiagramInViewActionGenerator(), myEmitters.getOpenDiagramInViewActionQualifiedClassNameGenerator(), myEditorGen.getEditor());
a278 1
		internalGenerateJavaClass(myEmitters.getValidateActionGenerator(), myEmitters.getValidateActionQualifiedNameGenerator(), myDiagram);
a294 1
		internalGenerateJavaClass(myEmitters.getMetricsActionEmitter(), myEmitters.getMetricsActionQualifiedNameEmitter(), myDiagram);
d302 1
d304 16
a319 4
			internalGenerateJavaClass(myEmitters.getCreateNodeCommandEmitter(), myEmitters.getCreateNodeCommandQualifiedClassNameEmitter(), genNode);
		}
		internalGenerateJavaClass(myEmitters.getAddNodeCommandEmitter(), myEmitters.getAddNodeCommandQualifiedClassNameEmitter(), genNode);
		internalGenerateJavaClass(myEmitters.getCloneNodeCommandEmitter(), myEmitters.getCloneNodeCommandQualifiedClassNameEmitter(), genNode);
d326 35
a360 4
		internalGenerateJavaClass(myEmitters.getCreateLinkStartCommandEmitter(), myEmitters.getCreateLinkStartCommandQualifiedClassNameEmitter(), genLink);
		internalGenerateJavaClass(myEmitters.getCreateLinkCompleteCommandEmitter(), myEmitters.getCreateLinkCompleteCommandQualifiedClassNameEmitter(), genLink);
		internalGenerateJavaClass(myEmitters.getReconnectLinkSourceCommandEmitter(), myEmitters.getReconnectLinkSourceCommandQualifiedClassNameEmitter(), genLink);
		internalGenerateJavaClass(myEmitters.getReconnectLinkTargetCommandEmitter(), myEmitters.getReconnectLinkTargetCommandQualifiedClassNameEmitter(), genLink);
d364 6
a369 1
		internalGenerateJavaClass(myEmitters.getLayoutEditPolicyEmitter(), myEmitters.getLayoutEditPolicyQualifiedClassNameEmitter(), containerBase);
d377 6
a382 1
		internalGenerateJavaClass(myEmitters.getGraphicalEditPolicyEmitter(), myEmitters.getGraphicalEditPolicyQualifiedClassNameEmitter(), genLink);
d386 7
a392 1
		internalGenerateJavaClass(myEmitters.getComponentEditPolicyEmitter(), myEmitters.getComponentEditPolicyQualifiedClassNameEmitter(), genElement);
@


1.48
log
@Rewrite /editor/* templates in XPand;
Use common template to generate code that creates an editing domain in various places;
OpenDiagramEditPolicy: package statement was missing.
@
text
@d2 1
a2 1
 * Copyright (c) 2005,2006 Borland Software Corporation
@


1.47
log
@[192168]: Convert /providers/DomainElementInitializer.javajet lite template to Xpand
@
text
@d113 1
a113 1
			internalGenerateJavaClass(myEmitters.getPaletteFactoryGenerator(), myDiagram.getPalette().getFactoryQualifiedClassName(), myDiagram);
a253 1
		String stem = myDiagram.getDomainDiagramElement() == null ? "" : myDiagram.getDomainDiagramElement().getGenPackage().getPrefix(); //$NON-NLS-1$
d255 7
a261 2
		Object[] args = new Object[] {stem.length() == 0 ? myEditorGen.getDiagramFileExtension() : stem };
		doGenerateBinaryFile(myEmitters.getWizardBannerImageEmitter(), new Path("icons/wizban/New" + stem + "Wizard.gif"), args); //$NON-NLS-1$ //$NON-NLS-2$
@


1.46
log
@1. Links to links;
2. Exception from TreeEditPartViewer (in the outline) while closing the diagram editor (because unregister is not called, only deactivate) fixed;
3. instead of rerouting a link to an end that does not support it, remove the link
@
text
@d14 1
d20 1
d169 1
a169 1
		internalGenerateJavaClass(myEmitters.getDomainElementInitializerGenerator(), myDiagram.getNotationViewFactoriesPackageName(), "DomainElementInitializer",myDiagram); // XXX: allow customization!
d543 12
@


1.45
log
@[178836]: Generate IEditorMatchingStrategy implementation;
Lite Diagram Editor opened using New Editor popup menu item on editor tab should share the editing domain with the originating editor
@
text
@d150 1
d370 9
@


1.44
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@d101 3
@


1.43
log
@Implementing "link with editor" for URI editor input
@
text
@a34 1
import org.eclipse.gmf.codegen.gmfgen.GenExternalNodeLabel;
a126 1
		boolean hasExternalLabels = false;
a132 1
					hasExternalLabels |= label instanceof GenExternalNodeLabel;
a144 3
		if (hasExternalLabels) {
			internalGenerateJavaClass(myEmitters.getDiagramExternalNodeLabelEditPartEmitter(), myDiagram.getEditPartsPackageName(), myDiagram.getBaseExternalNodeLabelEditPartClassName(), myDiagram);
		}
@


1.42
log
@Fixing problems with NavigatorLinkHelper.
@
text
@d200 1
d406 4
@


1.41
log
@Domain model navigator from full-rt
@
text
@d415 1
a415 1
	private void generateNavigatorLinkHelper() throws InterruptedException, UnexpectedBehaviourException {
@


1.40
log
@[178259]: In RCP mode OpenDiagramIn???DiagramViewAction should not depend on IFile
The test for "isRCP" is now different than was before
@
text
@d195 6
d390 16
@


1.39
log
@Generating diagram file navigator updating code.
@
text
@d102 1
a102 1
		if (!myEditorGen.getDomainGenModel().isRichClientPlatform() && !myEditorGen.getEditor().isEclipseEditor()) {
d185 1
a185 1
		if (!myEditorGen.getDomainGenModel().isRichClientPlatform() && myEditorGen.getNavigator() != null) {
@


1.38
log
@[164018]: Command generation separated from Parts for layout edit policy and graphical node edit policy;
NewDiagramFileWizard: layout is not persisted if the diagram is closed right after initialization
@
text
@d375 1
a375 1
	private void generateNavigatorContentProvider() throws InterruptedException, UnexpectedBehaviourException {
d432 1
a432 1
	private void generateNavigatorGroup() throws InterruptedException, UnexpectedBehaviourException {
d441 1
a441 1
	private void generateNavigatorItem() throws InterruptedException, UnexpectedBehaviourException {
@


1.37
log
@Images should be reused across the editparts that represent same model element types (prevent SWTErrors when opening huge diagrams)
@
text
@d28 1
d115 2
d132 1
a138 1
				internalGenerateJavaClass(myEmitters.getViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
a140 1
				internalGenerateJavaClass(myEmitters.getViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d142 1
d146 1
d166 1
d352 13
@


1.36
log
@Generated diagram plugin should at least compile when there's a node with  an abstract underlying element.
@
text
@d96 1
@


1.35
log
@[164018]: Add<>Command and Clone<>Command moved to separate classes;
Common methods from edit policies moved to runtime superclasses
@
text
@d286 7
a292 5
		internalGenerateJavaClass(myEmitters.getCreateNodeCommandEmitter(), 
				myDiagram.getEditCommandsPackageName(),
				"Create" + commandNameInfix + "Command",
				genNode
			);
@


1.34
log
@ComponentEditPolicy separated into a top-level class;
CreateRequest now knows about the MODEL_ID;
All "Command" class references fully-qualified in templates to prevent compilation problems;
[170078]: Remove link with class from the domain model on deleting link's destination
@
text
@d291 10
@


1.33
log
@Rewritten View factories using xpand;
[173476]: Respect label offset attributes when generating code
@
text
@d141 1
d155 1
d334 10
@


1.32
log
@complete migration of plugin.xml template to xpand version - lite version updated to use same template
@
text
@d132 1
a132 1
					internalGenerateJavaClass(myEmitters.getLabelViewFactoryGenerator(), label.getNotationViewFactoryQualifiedClassName(), label);
d134 1
a134 1
				internalGenerateJavaClass(myEmitters.getNodeViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d137 1
a137 1
				internalGenerateJavaClass(myEmitters.getLabelViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d149 1
a149 1
				internalGenerateJavaClass(myEmitters.getLabelViewFactoryGenerator(), label.getNotationViewFactoryQualifiedClassName(), label);
d151 1
a151 1
			internalGenerateJavaClass(myEmitters.getLinkViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d158 1
a158 1
			internalGenerateJavaClass(myEmitters.getCompartmentViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d160 1
a160 1
		internalGenerateJavaClass(myEmitters.getDiagramViewFactoryGenerator(), myDiagram.getNotationViewFactoryQualifiedClassName(), myDiagram);
@


1.31
log
@[172660]: Load Resource doesn't exist in RCP-Lite;
Changed order of hooking and configuration of the graphical viewer to allow menu registration using objectContributions in plugin.xml.
@
text
@a13 1
import java.lang.reflect.InvocationTargetException;
a18 1
import org.eclipse.core.runtime.NullProgressMonitor;
a40 1
import org.eclipse.gmf.codegen.gmfgen.GenPlugin;
a471 6
	public static String getConstraintProviders(Object plugin) throws UnexpectedBehaviourException, InvocationTargetException, InterruptedException {
		GenEditorGenerator gen = ((GenPlugin) plugin).getEditorGen();
		org.eclipse.gmf.codegen.util.CodegenEmitters emitters = new org.eclipse.gmf.codegen.util.CodegenEmitters(!gen.isDynamicTemplates(), gen.getTemplateDirectory());
		return emitters.retrieve(org.eclipse.gmf.codegen.templates.editor.PluginXML.class).generate(new NullProgressMonitor(), new Object[] { plugin });
	}

@


1.30
log
@make use of strings externalized with #139733
@
text
@d98 1
@


1.29
log
@Automatic import manager is obsolete
@
text
@d194 1
d455 7
@


1.28
log
@[172664]: Provide audits and metrics for Lite diagrams (including view-based and RCP) + validation decorators + validation markers (for non-RCP case);
Several templates are rewritten with xpand;
lite-specific TextEmitter is back (otherwise importManager is sometimes passed to xpand templates)
@
text
@d462 2
a463 6
		if (emitter instanceof IAutomaticImportManager) {
			doGenerateJavaClass(emitter, packageName, className, argument);
		} else {
			ImportAssistant importUtil = createImportAssistant(packageName, className);
			doGenerateJavaClass(emitter, packageName, className, argument, importUtil);
		}
@


1.27
log
@move implementation-specific parameter wrapping logic to appropriate emitter
@
text
@d14 1
d20 1
d43 1
d115 10
d255 24
d470 6
@


1.26
log
@Rewrite NavigatorContentProvider using xpand (overriding the runtime-based template using aspects);
internalGenerateJavaClass() may be used instead of doGenerateJavaClass() for xpand-based templates (no import manager gets added to the template parameters)
@
text
@d426 1
a426 1
			doGenerateJavaClass(emitter, packageName, className, new Object[] {argument});
d429 1
a429 1
			doGenerateJavaClass(emitter, packageName, className, new Object[] { new Object[] {argument, importUtil } });
@


1.25
log
@[159567]: Use GenApplication element from gmfgen model to generate RCP code
Use as much of the runtime templates as possible (changes are isolated as aspects)
@
text
@d425 6
a430 2
		ImportAssistant importUtil = createImportAssistant(packageName, className);
		doGenerateJavaClass(emitter, packageName, className, new Object[] { new Object[] {argument, importUtil } });
@


1.24
log
@Compilation problems when property sheet is defined in RCP (no navigator support)
@
text
@d24 1
d180 1
d388 1
d406 11
@


1.23
log
@Tabbed property sheet provided for the lite runtime (if GenPropertySheet is not null);
IllegalStateException when closing editor fixed.
@
text
@d388 1
a388 1
			internalGenerateJavaClass(
@


1.22
log
@Generate support for Navigator
@
text
@d27 1
d40 1
d176 3
d386 17
@


1.21
log
@[164018]: Command generation separated from editparts for link commands (createStart, complete, reconnectSource, reconnectTarget) and nodes (create)
@
text
@d16 2
d36 1
d76 1
d111 1
a111 2
		for (Iterator it = myDiagram.getAllNodes().iterator(); it.hasNext(); ) {
			final GenNode next = (GenNode) it.next();
d131 1
a131 2
		for (Iterator it = myDiagram.getLinks().iterator(); it.hasNext();) {
			final GenLink next = (GenLink) it.next();
d133 1
a133 2
			for (Iterator it2 = next.getLabels().iterator(); it2.hasNext();) {
				final GenLinkLabel label = (GenLinkLabel) it2.next();
d163 11
d182 1
d192 1
a192 2
		for (Iterator it = providerContainer.getProviders().iterator(); it.hasNext();) {
			GenExpressionProviderBase nextProvider = (GenExpressionProviderBase) it.next();
d289 92
@


1.20
log
@[163214]: Lite runtime should support generation to a View
[164843]: Make it possible to specify the editing domain with which the editor/viewer should operate
@
text
@d18 1
d20 1
d37 1
d123 1
d138 1
d227 50
@


1.19
log
@[162579] Support diagram partitioning
+
1. CustomBehaviours;
2. LayoutDiagramAction: execute the command through the command stack;
3. WrappingCommand: Workaround for a problem with StrictCompoundCommand.canExecute() in transactional editing domains
@
text
@d89 6
@


1.18
log
@On regeneration, do not generate imports that conflict with those already present in the compilation unit, use FQNs instead (currently, only in Lite Generator to prove the concept) + Test
@
text
@d14 1
d21 1
d34 1
a37 1
import org.eclipse.gmf.internal.common.codegen.ImportUtil;
d69 1
a69 1
	
d94 2
d113 1
d127 1
d203 13
@


1.17
log
@#161253: External node labels should be attached to nodes correctly
Generate 2 icons if myDiagram.getCreationWizardIconPathX() and myEditorGen.getEditor().getIconPathX() specify different absolute paths
@
text
@d33 1
d205 1
a205 1
		ImportUtil importUtil = new ImportUtil(packageName, className);
@


1.16
log
@Correct icons in wizards and palette: generate images, recognize relative paths, fix incorrect paths in wizard code;
Make it possible to nest palette groups
@
text
@d26 1
d92 1
d99 1
d109 3
d133 9
a141 4
		if (isPathInsideGenerationTarget(myDiagram.getCreationWizardIconPathX()) || isPathInsideGenerationTarget(myEditorGen.getEditor().getIconPathX())) {
			// only these two at the moment may produce path that reference generated icon file, thus
			// skip generation if neither path specifies relative path
			generateDiagramIcon(isPathInsideGenerationTarget(myDiagram.getCreationWizardIconPathX()) ? myDiagram.getCreationWizardIconPathX() : myEditorGen.getEditor().getIconPathX());
a195 1

@


1.15
log
@[157859] bblajer - Diagram initialization from pre-existing domain models
@
text
@d127 12
d170 16
a185 1
	
@


1.14
log
@[155040] bblajer - Common Lite runtime functionality moved to dedicated plugin
@
text
@d79 2
@


1.13
log
@use same counter code to estimate amount of work
@
text
@a13 1
import java.net.URL;
d35 1
d61 3
a63 2
	protected URL getJMergeControlFile() {
		return myEmitters.getJMergeControlFile();
a82 1
		internalGenerateJavaClass(myEmitters.getPropertySourceProviderGenerator(), myDiagram.getPropertyProviderQualifiedClassName(), myDiagram);
a85 2
		internalGenerateJavaClass(myEmitters.getUpdatableEditPartGenerator(), myDiagram.getEditPartsPackageName(), "IUpdatableEditPart", myDiagram); // XXX: should be customizable
		internalGenerateJavaClass(myEmitters.getWrappingCommandGenerator(), myDiagram.getEditPartsPackageName(), "WrappingCommand", myDiagram); // XXX: should be customizable or moved to a lite-runtime plugin
a87 1
		internalGenerateJavaClass(myEmitters.getBendpointEditPolicyGenerator(), myDiagram.getEditPoliciesPackageName(), "BendpointEditPolicy", myDiagram);	//XXX: should be moved to a lite-runtime plugin
a103 1
		internalGenerateJavaClass(myEmitters.getAbstractParserGenerator(),myDiagram.getAbstractParserQualifiedClassName(), myDiagram);
a124 7
		internalGenerateJavaClass(myEmitters.getCreateNotationalElementCommandGenerator(), myDiagram.getEditCommandsPackageName(), "CreateNotationalElementCommand", myDiagram);
		internalGenerateJavaClass(myEmitters.getCreateNotationalEdgeCommandGenerator(), myDiagram.getEditCommandsPackageName(), "CreateNotationalEdgeCommand", myDiagram);
		internalGenerateJavaClass(myEmitters.getRemoveNotationalElementCommandGenerator(), myDiagram.getEditCommandsPackageName(), "RemoveNotationalElementCommand", myDiagram);
		internalGenerateJavaClass(myEmitters.getRemoveNotationalEdgeCommandGenerator(), myDiagram.getEditCommandsPackageName(), "RemoveNotationalEdgeCommand", myDiagram);
		internalGenerateJavaClass(myEmitters.getReplaceNotationalElementCommandGenerator(), myDiagram.getEditCommandsPackageName(), "ReplaceNotationalElementCommand", myDiagram);
		internalGenerateJavaClass(myEmitters.getReconnectNotationalEdgeSourceCommandGenerator(), myDiagram.getEditCommandsPackageName(), "ReconnectNotationalEdgeSourceCommand", myDiagram);
		internalGenerateJavaClass(myEmitters.getReconnectNotationalEdgeTargetCommandGenerator(), myDiagram.getEditCommandsPackageName(), "ReconnectNotationalEdgeTargetCommand", myDiagram);
@


1.12
log
@caching behavior extracted to keep separate from *generation iterator* functionality
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Borland Software Corporation
a14 1
import java.util.ArrayList;
a15 1
import java.util.List;
a18 2
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
d38 1
a38 1
 * Invokes JET templates to populate diagram editor project.
d182 6
a187 11
		c.curiousAbout(GMFGenPackage.eINSTANCE.getGenNode());
		c.curiousAbout(GMFGenPackage.eINSTANCE.getGenCompartment());
		c.curiousAbout(GMFGenPackage.eINSTANCE.getGenLink());
		c.curiousAbout(GMFGenPackage.eINSTANCE.getGenNodeLabel());
		c.curiousAbout(GMFGenPackage.eINSTANCE.getGenLinkLabel());
		c.count(myDiagram);
		int total = 2 * c.getCount(GMFGenPackage.eINSTANCE.getGenNode());
		total += 2 * c.getCount(GMFGenPackage.eINSTANCE.getGenCompartment());
		total += 2 * c.getCount(GMFGenPackage.eINSTANCE.getGenLink());
		total += 2 * c.getCount(GMFGenPackage.eINSTANCE.getGenNodeLabel());
		total += 2 * c.getCount(GMFGenPackage.eINSTANCE.getGenLinkLabel());
d191 1
a191 36
		setupProgressMonitor("Generation in progress...", total);
	}

	private static final class Counter {
		private final List/*<EClass>*/ myAttractions = new ArrayList();
		private int[] myHits;
		
		public void curiousAbout(EClass eClass) {
			myAttractions.add(eClass);
		}

		public void count(EObject start) {
			myHits = new int[myAttractions.size()];
			final EClass[] attractions = (EClass[]) myAttractions.toArray(new EClass[myAttractions.size()]);
			doCount(start.eClass(), attractions);
			for (Iterator it = start.eAllContents(); it.hasNext(); ) {
				EObject next = (EObject) it.next();
				doCount(next.eClass(), attractions);
			}
		}

		private void doCount(EClass eClass, EClass[] attractions) {
			for (int i = 0; i < attractions.length; i++) {
				if (attractions[i].isSuperTypeOf(eClass)) {
					myHits[i]++;
				}
			}
		}

		public int getCount(EClass eClass) {
			int index = myAttractions.indexOf(eClass);
			if (index == -1) {
				throw new IllegalArgumentException("No class " + eClass + " was previously registered with curiousAbout(EClass)");
			}
			return myHits[index];
		}
@


1.11
log
@[bblajer] #146009 Reflect changes in domain model links
@
text
@a13 1
import java.lang.ref.SoftReference;
a15 1
import java.util.HashMap;
a17 1
import java.util.Map;
a20 1
import org.eclipse.emf.common.util.URI;
d54 3
a56 1
	private static Map/*<URI, SoftReference>*/ myCachedURI2EmitterMap = new HashMap();
d58 2
a59 1
	public Generator(GenEditorGenerator genModel) {
d62 1
a62 13
		URI resourceURI = myEditorGen.eResource().getURI();
		if (myEditorGen.isDynamicTemplates()) {
			myCachedURI2EmitterMap.remove(resourceURI);
		}
		CodegenEmitters old = myCachedURI2EmitterMap.containsKey(resourceURI) ? (CodegenEmitters) ((SoftReference) myCachedURI2EmitterMap.get(resourceURI)).get() : null;
		if (old == null) {
			myEmitters = new CodegenEmitters(!myEditorGen.isDynamicTemplates(), myEditorGen.getTemplateDirectory());
			if (!myEditorGen.isDynamicTemplates()) {
				myCachedURI2EmitterMap.put(resourceURI, new SoftReference(myEmitters));
			}
		} else {
			myEmitters = old;
		}
@


1.10
log
@#149298 Lite Generator: Make it possible to reroute links
@
text
@d147 1
d149 1
@


1.9
log
@#146009 Lite Generator: Changes in the underlying domain model should be automatically reflected in the notational model
1,2,3 Parts commited.
@
text
@d149 2
@


1.8
log
@#145042 Introduce expression Language enumeration into gmfmap, gfmgen models  instead of plain text attribute
@
text
@d146 3
@


1.7
log
@#145101 Lite Generator: Support bendpoints in the same format as runtime-based generated diagrams
@
text
@d35 1
d161 1
a161 1
				if("ocl".equals(nextProvider.getLanguage())) { //$NON-NLS-1$
d163 1
a163 1
				} else if("regexp".equals(nextProvider.getLanguage()) || "nregexp".equals(nextProvider.getLanguage())) { //$NON-NLS-1$ //$NON-NLS-2$
@


1.6
log
@[bblajer] #144412 Allow non-OCL-based FeatureSeqInitializers, constraints and selectors
@
text
@d106 1
@


1.5
log
@[bblajer] #138430 Lite Generator: Generated code should make use of emf.transaction API
@
text
@d32 3
d141 3
d146 30
@


1.4
log
@#125964 match location of generated project with other EMF projects
@
text
@d100 1
@


1.3
log
@Emitter became top-level entity (TextEmitter), oddness of JetAdapter and Emitter api were cleared.
GeneratorBase lost knowledge about JET.
Parts of gmf.common made internal to avoid possible API issues.
ImportAssistant refactored to know name of compilation unit to avoid problems like #134506.
FigureGenerator's reuse of ImportAssistant removed.
[mgolubev] Tests for #134506 and 142553
@
text
@a16 1
import java.util.Collections;
d43 1
a43 1
 * 
d79 3
a81 1
		initializeEditorProject(myDiagram.getEditorGen().getPlugin().getID(), createReferencedProjectsList());
a169 4
	protected final List createReferencedProjectsList() {
		return Collections.EMPTY_LIST;
	}

@


1.2
log
@sync with changes in gmfgen
@
text
@d24 1
d38 3
a40 1
import org.eclipse.gmf.common.codegen.GeneratorBase;
d82 13
a94 13
		doGenerateFile(myEmitters.getManifestGenerator(), new Path("META-INF/MANIFEST.MF"), myEditorGen.getPlugin());
		doGenerateFile(myEmitters.getBuildPropertiesGenerator(), new Path("build.properties"), myEditorGen.getPlugin());
		doGenerateFile(myEmitters.getPluginXML(), new Path("plugin.xml"), myEditorGen.getPlugin());
		doGenerateFile(myEmitters.getPluginPropertiesGenerator(), new Path("plugin.properties"), myEditorGen.getPlugin());

		doGenerateJavaClass(myEmitters.getCreationWizardGenerator(), myDiagram.getCreationWizardQualifiedClassName(), myDiagram);
		doGenerateJavaClass(myEmitters.getCreationWizardPageGenerator(), myDiagram.getCreationWizardPageQualifiedClassName(), myDiagram);
		doGenerateJavaClass(myEmitters.getPluginGenerator(), myEditorGen.getPlugin().getActivatorQualifiedClassName(), myEditorGen.getPlugin());

		doGenerateJavaClass(myEmitters.getActionBarContributorGenerator(), myEditorGen.getEditor().getActionBarContributorQualifiedClassName(), myEditorGen.getEditor());
		doGenerateJavaClass(myEmitters.getDiagramEditorUtilGenerator(), myDiagram.getDiagramEditorUtilQualifiedClassName(), myDiagram);
		doGenerateJavaClass(myEmitters.getEditorGenerator(), myEditorGen.getEditor().getQualifiedClassName(), myEditorGen.getEditor());
		doGenerateJavaClass(myEmitters.getPropertySourceProviderGenerator(), myDiagram.getPropertyProviderQualifiedClassName(), myDiagram);
d96 1
a96 1
			doGenerateJavaClass(myEmitters.getPaletteFactoryGenerator(), myDiagram.getPalette().getFactoryQualifiedClassName(), myDiagram);
d98 3
a100 3
		doGenerateJavaClass(myEmitters.getUpdatableEditPartGenerator(), myDiagram.getEditPartsPackageName(), "IUpdatableEditPart", myDiagram); // XXX: should be customizable
		doGenerateJavaClass(myEmitters.getEditPartFactoryGenerator(), myDiagram.getEditPartFactoryQualifiedClassName(), myDiagram);
		doGenerateJavaClass(myEmitters.getDiagramEditPartGenerator(), myDiagram.getEditPartQualifiedClassName(), myDiagram);
d105 1
a105 1
				doGenerateJavaClass(myEmitters.getNodeEditPartGenerator(), next.getEditPartQualifiedClassName(), next);
d108 2
a109 2
					doGenerateJavaClass(myEmitters.getNodeLabelEditPartGenerator(), label.getEditPartQualifiedClassName(), label);
					doGenerateJavaClass(myEmitters.getLabelViewFactoryGenerator(), label.getNotationViewFactoryQualifiedClassName(), label);
d111 1
a111 1
				doGenerateJavaClass(myEmitters.getNodeViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d113 2
a114 2
				doGenerateJavaClass(myEmitters.getChildNodeEditPartGenerator(), next.getEditPartQualifiedClassName(), next);
				doGenerateJavaClass(myEmitters.getLabelViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d117 1
a117 1
		doGenerateJavaClass(myEmitters.getAbstractParserGenerator(),myDiagram.getAbstractParserQualifiedClassName(), myDiagram);
d120 1
a120 1
			doGenerateJavaClass(myEmitters.getLinkEditPartGenerator(), next.getEditPartQualifiedClassName(), next);
d123 2
a124 2
				doGenerateJavaClass(myEmitters.getLinkLabelEditPartGenerator(), label.getEditPartQualifiedClassName(), label);
				doGenerateJavaClass(myEmitters.getLabelViewFactoryGenerator(), label.getNotationViewFactoryQualifiedClassName(), label);
d126 1
a126 1
			doGenerateJavaClass(myEmitters.getLinkViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d130 2
a131 2
			doGenerateJavaClass(myEmitters.getCompartmentEditPartGenerator(), next.getEditPartQualifiedClassName(), next);
			doGenerateJavaClass(myEmitters.getCompartmentViewFactoryGenerator(), next.getNotationViewFactoryQualifiedClassName(), next);
d133 15
a147 3
		doGenerateJavaClass(myEmitters.getDiagramViewFactoryGenerator(), myDiagram.getNotationViewFactoryQualifiedClassName(), myDiagram);
		doGenerateJavaClass(myEmitters.getDomainElementInitializerGenerator(), myDiagram.getNotationViewFactoriesPackageName(), "DomainElementInitializer",myDiagram); // XXX: allow customization!
		doGenerateJavaClass(myEmitters.getVisualIDRegistryGenerator(), myDiagram.getVisualIDRegistryQualifiedClassName(), myDiagram);
@


1.1
log
@[bblajer] #136702 Code generation targeting pure-GEF runtime
@
text
@d28 1
d101 1
a101 1
			if (!next.isListContainerEntry()) {
@

