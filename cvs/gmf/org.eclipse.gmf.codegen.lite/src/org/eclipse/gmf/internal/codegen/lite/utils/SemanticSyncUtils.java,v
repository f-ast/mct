head	1.2;
access;
symbols
	v20080910-1520:1.2
	v20080722-1827:1.2
	v20080716-1642:1.2
	R2_1_maintenance:1.2.0.4
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080507-1326:1.2
	v20080501-1739:1.2
	v20080425-1959:1.2
	v20080322-0000:1.2
	v20071108-0000:1.2
	v20071003-0000:1.2
	v20070921-0000:1.2
	v20070915-0000:1.2
	v20070903-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	v20070621-0000:1.2
	RC3_20:1.2
	v20070614-1400:1.2
	v20070608-1300:1.2
	v20070601-1400:1.2
	v20070525-1500:1.2
	v20070520-1200:1.2
	v20070518-1300:1.2
	v20070504-1000:1.1
	v20070427-0600:1.1
	v20070420-1000:1.1
	v20070413-1300:1.1
	v20070405-1100:1.1;
locks; strict;
comment	@# @;


1.2
date	2007.05.04.14.08.43;	author bblajer;	state Exp;
branches;
next	1.1;
commitid	464d463b3e6a4567;

1.1
date	2007.04.04.11.04.48;	author bblajer;	state Exp;
branches;
next	;
commitid	18c54613864d4567;


desc
@@


1.2
log
@1. Links to links;
2. Exception from TreeEditPartViewer (in the outline) while closing the diagram editor (because unregister is not called, only deactivate) fixed;
3. instead of rerouting a link to an end that does not support it, remove the link
@
text
@/**
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bblajer - initial API and implementation
 */
package org.eclipse.gmf.internal.codegen.lite.utils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.WeakHashMap;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.emf.codegen.ecore.genmodel.GenFeature;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.gmf.codegen.gmfgen.FeatureLinkModelFacet;
import org.eclipse.gmf.codegen.gmfgen.GenChildContainer;
import org.eclipse.gmf.codegen.gmfgen.GenChildNode;
import org.eclipse.gmf.codegen.gmfgen.GenCommonBase;
import org.eclipse.gmf.codegen.gmfgen.GenCompartment;
import org.eclipse.gmf.codegen.gmfgen.GenContainerBase;
import org.eclipse.gmf.codegen.gmfgen.GenDiagram;
import org.eclipse.gmf.codegen.gmfgen.GenLink;
import org.eclipse.gmf.codegen.gmfgen.GenNode;
import org.eclipse.gmf.codegen.gmfgen.GenTopLevelNode;
import org.eclipse.gmf.codegen.gmfgen.TypeLinkModelFacet;
import org.eclipse.gmf.codegen.gmfgen.TypeModelFacet;
import org.eclipse.gmf.codegen.gmfgen.util.GMFGenSwitch;

/**
 * This class provides static utility methods for use with Xpand templates.
 * Although it is possible to implement these methods in Xtend, doing so would severely impact performance, 
 * since they would have to be called several times without the possibility to cache their results.
 */
public class SemanticSyncUtils {
	public static Collection<GenNode> getGenNodes(GenContainerBase genContainerBase, GenFeature genFeature) {
		Collection<GenNode> result = getGenChildFeature2genNodeMap(genContainerBase).get(genFeature);
		if (result == null) {
			return Collections.emptyList();
		}
		return result;
	}

	private static Map<GenFeature, Collection<GenNode>> getGenChildFeature2genNodeMap(GenContainerBase genContainerBase) {
		Map<GenFeature, Collection<GenNode>> result = myFeature2NodesCache.get(genContainerBase);
		if (result == null) {
			result = buildGenChildFeature2genNodeMap(genContainerBase);
			myFeature2NodesCache.put(genContainerBase, result);
		}
		return result;
	}

	private static Map<GenFeature, Collection<GenNode>> buildGenChildFeature2genNodeMap(GenContainerBase genContainerBase) {
		Map<GenFeature, Collection<GenNode>> result = new LinkedHashMap<GenFeature, Collection<GenNode>>();
		Collection<? extends GenNode> childNodes = new GMFGenSwitch<Collection<? extends GenNode>>() {
			@@Override
			public Collection<? extends GenNode> caseGenDiagram(GenDiagram object) {
				return object.getTopLevelNodes();
			}
			@@Override
			public Collection<? extends GenNode> caseGenChildContainer(GenChildContainer object) {
				return object.getChildNodes();
			}
		}.doSwitch(genContainerBase);
		for (GenNode nextNode : childNodes) {
			TypeModelFacet typeModelFacet = nextNode.getModelFacet();
			if (typeModelFacet == null) {
				continue;
			}
			GenFeature childMetaFeature = typeModelFacet.getChildMetaFeature();
			if (!result.containsKey(childMetaFeature)) {
				result.put(childMetaFeature, new ArrayList<GenNode>());
			}
			result.get(childMetaFeature).add(nextNode);
		}
		return result;
	}

	public static Collection<GenLink> getTypeGenLinks(GenCommonBase container, GenFeature feature, Collection<GenLink> containedLinks) {
		Collection<GenLink> result = getGenChildFeature2TypeGenLinkMap(container, containedLinks).get(feature);
		if (result == null) {
			return Collections.emptyList();
		}
		return result;
	}

	public static Collection<GenLink> getFeatureGenLinks(GenCommonBase container, GenFeature feature, Collection<GenLink> containedLinks) {
		Collection<GenLink> result = getGenChildFeature2FeatureGenLinkMap(container, containedLinks).get(feature);
		if (result == null) {
			return Collections.emptyList();
		}
		return result;
	}

	private static Map<GenFeature, Collection<GenLink>> getGenChildFeature2TypeGenLinkMap(GenCommonBase container, Collection<GenLink> containedLinks) {
		if (!myFeature2TypeLinksCache.containsKey(container)) {
			buildGenChildFeature2LinkMaps(container, containedLinks);
		}
		return myFeature2TypeLinksCache.get(container);
	}

	private static Map<GenFeature, Collection<GenLink>> getGenChildFeature2FeatureGenLinkMap(GenCommonBase container, Collection<GenLink> containedLinks) {
		if (!myFeature2FeatureLinksCache.containsKey(container)) {
			buildGenChildFeature2LinkMaps(container, containedLinks);
		}
		return myFeature2FeatureLinksCache.get(container);
	}

	private static void buildGenChildFeature2LinkMaps(GenCommonBase container, Collection<GenLink> containedLinks) {
		final Map<GenFeature, Collection<GenLink>> genFeature2TypeGenLinkMap = new LinkedHashMap<GenFeature, Collection<GenLink>>();
		final Map<GenFeature, Collection<GenLink>> genFeature2FeatureGenLinkMap = new LinkedHashMap<GenFeature, Collection<GenLink>>();
		for(final GenLink genLink : containedLinks) {
			new GMFGenSwitch<Object>() {
				@@Override
				public Object caseTypeLinkModelFacet(TypeLinkModelFacet modelFacet) {
					GenFeature metaFeature = modelFacet.getChildMetaFeature();
					if (!genFeature2TypeGenLinkMap.containsKey(metaFeature)) {
						genFeature2TypeGenLinkMap.put(metaFeature, new ArrayList<GenLink>());
					}
					genFeature2TypeGenLinkMap.get(metaFeature).add(genLink);
					return null;
				}
				@@Override
				public Object caseFeatureLinkModelFacet(FeatureLinkModelFacet modelFacet) {
					GenFeature metaFeature = modelFacet.getMetaFeature();
					if (!genFeature2FeatureGenLinkMap.containsKey(metaFeature)) {
						genFeature2FeatureGenLinkMap.put(metaFeature, new ArrayList<GenLink>());
					}
					genFeature2FeatureGenLinkMap.get(metaFeature).add(genLink);
					return null;
				}
			}.doSwitch(genLink.getModelFacet());
		}
		myFeature2TypeLinksCache.put(container, genFeature2TypeGenLinkMap);
		myFeature2FeatureLinksCache.put(container, genFeature2FeatureGenLinkMap);
	}

	public static Collection<GenCommonBase> buildAncestorClosure(Collection<GenCommonBase> elements) {
		Collection<GenCommonBase> result = new LinkedHashSet<GenCommonBase>(elements);
		for(GenCommonBase next : elements) {
			addAncestors(result, next);
		}
		return result;
	}

	private static void addAncestors(Collection<GenCommonBase> result, GenCommonBase next) {
		Collection<? extends GenCommonBase> ancestors = new GMFGenSwitch<Collection<? extends GenCommonBase>>() {
			@@Override
			public Collection<? extends GenCommonBase> caseGenTopLevelNode(GenTopLevelNode object) {
				return Collections.singleton(object.getDiagram());
			}
			@@Override
			public Collection<? extends GenCommonBase> caseGenCompartment(GenCompartment object) {
				return Collections.singleton(object.getNode());
			}
			@@Override
			public Collection<? extends GenCommonBase> caseGenChildNode(GenChildNode object) {
				return object.getContainers();
			}
			@@Override
			public Collection<? extends GenCommonBase> caseGenLink(GenLink object) {
				return getPossibleContainers(object);
			}
			@@Override
			public Collection<? extends GenCommonBase> defaultCase(EObject object) {
				return Collections.emptyList();
			}
		}.doSwitch(next);
		for(GenCommonBase nextAncestor : ancestors) {
			if (!result.contains(nextAncestor)) {
				result.add(nextAncestor);
				addAncestors(result, nextAncestor);
			}
		}
	}

	private static Collection<? extends GenCommonBase> getPossibleContainers(GenLink link) {
		//XXX: NB: Implementation here must be synchronized with xpt::diagram::LinkFinder::getPossibleContainers(gmfgen::GenLink link)
		EClass containerClass = null;
		if (link.getModelFacet() instanceof TypeLinkModelFacet) {
			TypeLinkModelFacet facet = ((TypeLinkModelFacet) link.getModelFacet());
			if (facet.getContainmentMetaFeature() != null && facet.getContainmentMetaFeature().getGenClass() != null) {
				containerClass = ((TypeLinkModelFacet) link.getModelFacet()).getContainmentMetaFeature().getGenClass().getEcoreClass();
			}
		} else if (link.getModelFacet() instanceof FeatureLinkModelFacet) {
			FeatureLinkModelFacet facet = (FeatureLinkModelFacet) link.getModelFacet();
			if (facet.getMetaFeature() != null && facet.getMetaFeature().getGenClass() != null) {
				containerClass = facet.getMetaFeature().getGenClass().getEcoreClass();
			}
		}
		if (containerClass == null) {
			return Collections.emptyList();
		}
		Collection<GenCommonBase> result = new ArrayList<GenCommonBase>();
		result.add(link.getDiagram());
		result.addAll(link.getDiagram().getAllNodes());
		result.addAll(link.getDiagram().getLinks());
		for (Iterator<GenCommonBase> it = result.iterator(); it.hasNext(); ) {
			GenCommonBase next = it.next();
			GenClass effectiveMetaClass = getEffectiveMetaClass(next);
			if (effectiveMetaClass == null || !containerClass.isSuperTypeOf(effectiveMetaClass.getEcoreClass())) {
				it.remove();
			}
		}
		return result;
	}

	private static GenClass getEffectiveMetaClass(GenCommonBase element) {
		//XXX: NB: Implementation here must be synchronized with xpt::diagram::LinkFinder::getEffectiveMetaClass(...) methods
		return new GMFGenSwitch<GenClass>() {
			@@Override
			public GenClass caseGenDiagram(GenDiagram object) {
				return object.getDomainDiagramElement();
			}
			@@Override
			public GenClass caseGenNode(GenNode object) {
				return object.getDomainMetaClass();
			}
			@@Override
			public GenClass caseGenLink(GenLink object) {
				return doSwitch(object.getModelFacet());
			}
			@@Override
			public GenClass caseTypeLinkModelFacet(TypeLinkModelFacet object) {
				return object.getMetaClass();
			}
		}.doSwitch(element);
	}

	private static WeakHashMap<GenContainerBase, Map<GenFeature, Collection<GenNode>>> myFeature2NodesCache = new WeakHashMap<GenContainerBase, Map<GenFeature,Collection<GenNode>>>();
	private static WeakHashMap<GenCommonBase, Map<GenFeature, Collection<GenLink>>> myFeature2TypeLinksCache = new WeakHashMap<GenCommonBase, Map<GenFeature,Collection<GenLink>>>();
	private static WeakHashMap<GenCommonBase, Map<GenFeature, Collection<GenLink>>> myFeature2FeatureLinksCache = new WeakHashMap<GenCommonBase, Map<GenFeature,Collection<GenLink>>>();
}
@


1.1
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@d17 1
d23 1
d25 1
d30 1
d90 1
a90 1
	public static Collection<GenLink> getTypeGenLinks(GenContainerBase container, GenFeature feature, Collection<GenLink> containedLinks) {
d98 1
a98 1
	public static Collection<GenLink> getFeatureGenLinks(GenContainerBase container, GenFeature feature, Collection<GenLink> containedLinks) {
d106 1
a106 1
	private static Map<GenFeature, Collection<GenLink>> getGenChildFeature2TypeGenLinkMap(GenContainerBase container, Collection<GenLink> containedLinks) {
d113 1
a113 1
	private static Map<GenFeature, Collection<GenLink>> getGenChildFeature2FeatureGenLinkMap(GenContainerBase container, Collection<GenLink> containedLinks) {
d120 1
a120 1
	private static void buildGenChildFeature2LinkMaps(GenContainerBase container, Collection<GenLink> containedLinks) {
d149 3
a151 3
	public static Collection<GenContainerBase> buildAncestorClosure(Collection<GenContainerBase> elements) {
		Collection<GenContainerBase> result = new LinkedHashSet<GenContainerBase>(elements);
		for(GenContainerBase next : elements) {
d157 2
a158 2
	private static void addAncestors(Collection<GenContainerBase> result, GenContainerBase next) {
		Collection<? extends GenContainerBase> ancestors = new GMFGenSwitch<Collection<? extends GenContainerBase>>() {
d160 1
a160 1
			public Collection<? extends GenContainerBase> caseGenTopLevelNode(GenTopLevelNode object) {
d164 1
a164 1
			public Collection<? extends GenContainerBase> caseGenCompartment(GenCompartment object) {
d168 1
a168 1
			public Collection<? extends GenContainerBase> caseGenChildNode(GenChildNode object) {
d172 5
a176 1
			public Collection<? extends GenContainerBase> defaultCase(EObject object) {
d180 1
a180 1
		for(GenContainerBase nextAncestor : ancestors) {
d188 53
d242 2
a243 2
	private static WeakHashMap<GenContainerBase, Map<GenFeature, Collection<GenLink>>> myFeature2TypeLinksCache = new WeakHashMap<GenContainerBase, Map<GenFeature,Collection<GenLink>>>();
	private static WeakHashMap<GenContainerBase, Map<GenFeature, Collection<GenLink>>> myFeature2FeatureLinksCache = new WeakHashMap<GenContainerBase, Map<GenFeature,Collection<GenLink>>>();
@

