head	1.10;
access;
symbols
	v20080910-1520:1.10
	v20080722-1827:1.10
	v20080716-1642:1.10
	R2_1_maintenance:1.10.0.2
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080507-1326:1.10
	v20080501-1739:1.9
	v20080425-1959:1.9
	v20080322-0000:1.9
	v20071108-0000:1.9
	v20071003-0000:1.8
	v20070921-0000:1.4
	v20070915-0000:1.4
	v20070903-0000:1.7
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.4
	v20070614-1400:1.4
	v20070608-1300:1.4
	v20070601-1400:1.4
	v20070525-1500:1.4
	v20070520-1200:1.4
	v20070518-1300:1.3
	v20070504-1000:1.2
	v20070427-0600:1.2
	v20070420-1000:1.1
	v20070413-1300:1.1
	v20070405-1100:1.1;
locks; strict;
comment	@# @;


1.10
date	2008.05.07.13.55.37;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	388c4821b4d44567;

1.9
date	2007.10.31.17.16.42;	author bblajer;	state Exp;
branches;
next	1.8;
commitid	79fa4728b8794567;

1.8
date	2007.09.18.10.18.54;	author bblajer;	state Exp;
branches;
next	1.7;
commitid	6ac646efa60d4567;

1.7
date	2007.08.31.17.56.39;	author bblajer;	state Exp;
branches;
next	1.6;
commitid	72b646d856574567;

1.6
date	2007.08.13.14.11.02;	author bblajer;	state Exp;
branches;
next	1.5;
commitid	65c246c066754567;

1.5
date	2007.07.04.13.22.25;	author bblajer;	state Exp;
branches;
next	1.4;
commitid	405d468b9f0f4567;

1.4
date	2007.05.18.21.17.25;	author atikhomirov;	state Exp;
branches;
next	1.3;
commitid	25e5464e17e24567;

1.3
date	2007.05.04.14.08.44;	author bblajer;	state Exp;
branches;
next	1.2;
commitid	464d463b3e6a4567;

1.2
date	2007.04.24.14.16.48;	author bblajer;	state Exp;
branches;
next	1.1;
commitid	4264462e114e4567;

1.1
date	2007.04.04.11.04.48;	author bblajer;	state Exp;
branches;
next	;
commitid	18c54613864d4567;


desc
@@


1.10
log
@[228913] updated ValueExpression use in GMFGen to better accomodate codegen needs (items 1,2,3)
@
text
@/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    bblajer (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2008/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«EXTENSION xpt::diagram::parts::Common»
«EXTENSION xpt::diagram::parts::LabelController»
«EXTENSION xpt::diagram::ViewmapAttributesUtils»

«DEFINE refresher FOR gmfgen::GenCommonBase-»
«EXPAND updatableEditPartRefresher-»
«EXPAND refreshMethods-»
«EXPAND refreshVisuals-»
«ENDDEFINE»

«DEFINE updatableEditPartRefresher FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.gmf.runtime.lite.edit.parts.update.RefreshersRegistry myRefreshersRegistry;

«EXPAND xpt::Common::generatedMemberComment»
public Refresher getRefresher(org.eclipse.emf.ecore.EStructuralFeature feature, org.eclipse.emf.common.notify.Notification msg) {
	if (myRefreshersRegistry == null) {
		createRefreshers();
	}
	return myRefreshersRegistry.getRefresher(feature, msg);
}

«EXPAND xpt::Common::generatedMemberComment»
private void createRefreshers() {
	myRefreshersRegistry = new org.eclipse.gmf.runtime.lite.edit.parts.update.RefreshersRegistry();
	«EXPAND fillRefreshers-»
}
«ENDDEFINE»

«DEFINE updatableEditPartRefresher FOR gmfgen::GenLabel»«ENDDEFINE»

«DEFINE fillRefreshers FOR gmfgen::GenCommonBase»«ENDDEFINE»

«DEFINE fillRefreshers FOR gmfgen::GenDiagram-»
«EXPAND children-»
«ENDDEFINE»

«DEFINE fillRefreshers FOR gmfgen::GenCompartment-»
«EXPAND children-»
«EXPAND visibility-»
«ENDDEFINE»

/*
 * By default, nodes have FontStyle installed. However, the color part of this style is only used by its child labels.
 * Otherwise, there is a conflict between the font color and the foreground color.
 */
«DEFINE fillRefreshers FOR gmfgen::GenNode-»
«EXPAND children-»
«EXPAND visibility-»
«EXPAND sourceEdges-»
«EXPAND targetEdges-»
«EXPAND bounds-»
«EXPAND font-»
«EXPAND fillColor-»
«EXPAND lineColor-»
«EXPAND shortcutAnnotation-»
«ENDDEFINE»

«DEFINE fillRefreshers FOR gmfgen::GenChildLabelNode-»
«EXPAND visibility-»
«EXPAND font-»
«EXPAND fontColor-»
«ENDDEFINE»

/*
 * By default, links have FontStyle installed. However, this style is only used by its child labels.
 */
«DEFINE fillRefreshers FOR gmfgen::GenLink-»
«EXPAND children-»
«EXPAND visibility-»
«EXPAND sourceEdges-»
«EXPAND targetEdges-»
«EXPAND bendpoints-»
«EXPAND fillColor-»
«EXPAND lineColor-»
«ENDDEFINE»

«DEFINE children FOR gmfgen::GenCommonBase-»
Refresher childrenRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshChildren();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_PersistedChildren() == msg.getFeature() || 
				org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_TransientChildren() == msg.getFeature() ||
				org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getDrawerStyle_Collapsed() == msg.getFeature()) {
			return true;
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles() == msg.getFeature()) {
			return org.eclipse.gmf.runtime.lite.edit.parts.update.UpdaterUtil.affects(msg, org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getDrawerStyle());
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Visible() == msg.getFeature()) {
			return msg.getNotifier() != «EXPAND xpt::diagram::parts::Common::getViewCode»;
		}
		if (org.eclipse.emf.ecore.EcorePackage.eINSTANCE.getEModelElement_EAnnotations() == msg.getFeature()) {
			return msg.getNotifier() != «EXPAND xpt::diagram::parts::Common::getViewCode»;
		}
		return false;
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_PersistedChildren(), childrenRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_TransientChildren(), childrenRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles(), childrenRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getDrawerStyle_Collapsed(), childrenRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Visible(), childrenRefresher);
myRefreshersRegistry.add(org.eclipse.emf.ecore.EcorePackage.eINSTANCE.getEModelElement_EAnnotations(), childrenRefresher);
«ENDDEFINE»

«DEFINE visibility FOR gmfgen::GenCommonBase-»
Refresher visibilityRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshVisibility();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Visible() == msg.getFeature()) {
			return msg.getNotifier() == «EXPAND xpt::diagram::parts::Common::getViewCode»;
		}
		return false;
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Visible(), visibilityRefresher);
«ENDDEFINE»

«DEFINE bendpoints FOR gmfgen::GenLink-»
Refresher bendpointsRefresher = new Refresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshBendpoints();
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getEdge_Bendpoints(), bendpointsRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getRelativeBendpoints_Points(), bendpointsRefresher);
«ENDDEFINE»

«DEFINE bounds FOR gmfgen::GenCommonBase-»
Refresher boundsRefresher = new Refresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshBounds();
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getNode_LayoutConstraint(), boundsRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getSize_Width(), boundsRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getSize_Height(), boundsRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLocation_X(), boundsRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLocation_Y(), boundsRefresher);
«ENDDEFINE»

«DEFINE sourceEdges FOR gmfgen::GenCommonBase-»
Refresher sourceEdgesRefresher = new Refresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshSourceConnections();
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_SourceEdges(), sourceEdgesRefresher);
«ENDDEFINE»

«DEFINE targetEdges FOR gmfgen::GenCommonBase-»
Refresher targetEdgesRefresher = new Refresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshTargetConnections();
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_TargetEdges(), targetEdgesRefresher);
«ENDDEFINE»

«DEFINE fillColor FOR gmfgen::GenCommonBase-»
«IF !viewmap.isFixedBackground()-»
Refresher backgroundColorRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshBackgroundColor();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFillStyle_FillColor() == msg.getFeature()) {
			return true;
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles() == msg.getFeature()) {
			return org.eclipse.gmf.runtime.lite.edit.parts.update.UpdaterUtil.affects(msg, org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFillStyle());
		}
		return false;
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFillStyle_FillColor(), backgroundColorRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles(), backgroundColorRefresher);
«ENDIF-»
«ENDDEFINE»

«DEFINE lineColor FOR gmfgen::GenCommonBase-»
«IF !viewmap.isFixedForeground()-»
Refresher foregroundColorRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshForegroundColor();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLineStyle_LineColor() == msg.getFeature()) {
			return true;
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles() == msg.getFeature()) {
			return org.eclipse.gmf.runtime.lite.edit.parts.update.UpdaterUtil.affects(msg, org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLineStyle());
		}
		return false;
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLineStyle_LineColor(), foregroundColorRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles(), foregroundColorRefresher);
«ENDIF-»
«ENDDEFINE»

«DEFINE font FOR gmfgen::GenCommonBase-»
«IF !viewmap.isFixedFont()-»
Refresher fontRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshFont();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle().getEStructuralFeatures().contains(msg.getFeature())) {
			return true;
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles() == msg.getFeature()) {
			return org.eclipse.gmf.runtime.lite.edit.parts.update.UpdaterUtil.affects(msg, org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle());
		}
		return false;
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_FontHeight(), fontRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_FontName(), fontRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_Bold(), fontRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_Italic(), fontRefresher);
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles(), fontRefresher);
«ENDIF-»
«ENDDEFINE»

«DEFINE fontColor FOR gmfgen::GenCommonBase-»
«IF !viewmap.isFixedFont()-»
Refresher fontColorRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshFontColor();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_FontColor() == msg.getFeature()) {
			return true;
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles() == msg.getFeature()) {
			return org.eclipse.gmf.runtime.lite.edit.parts.update.UpdaterUtil.affects(msg, org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle());
		}
		return false;
	}
};
myRefreshersRegistry.add(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_FontColor(), fontColorRefresher);
«ENDIF-»
«ENDDEFINE»

«DEFINE shortcutAnnotation FOR gmfgen::GenNode-»
«IF getDiagram().shortcutsProvidedFor.size() > 0-»
Refresher shortcutPropertyRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshShortcutDecoration();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.emf.ecore.EcorePackage.eINSTANCE.getEModelElement_EAnnotations() == msg.getFeature()) {
			java.util.Collection affectedAnnotations = org.eclipse.gmf.runtime.lite.edit.parts.update.UpdaterUtil.getAffectedValues(msg, org.eclipse.emf.ecore.EcorePackage.eINSTANCE.getEAnnotation());
			for (java.util.Iterator it = affectedAnnotations.iterator(); it.hasNext(); ) {
				org.eclipse.emf.ecore.EAnnotation nextAnnotation = (org.eclipse.emf.ecore.EAnnotation) it.next();
				if ("Shortcut".equals(nextAnnotation.getSource())) {	«EXPAND xpt::Common::nonNLS»
					return true;
				}
			}
		}
		return false;
	}
};
myRefreshersRegistry.add(org.eclipse.emf.ecore.EcorePackage.eINSTANCE.getEModelElement_EAnnotations(), shortcutPropertyRefresher);
«ENDIF-»
«ENDDEFINE»

«DEFINE labelRefresher FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher labelRefresher;

«EXPAND xpt::Common::generatedMemberComment»
protected org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher getLabelRefresher() {
	if (labelRefresher == null && getDiagramNode() != null) {
		labelRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelController.ExternalRefresherAdapter(this, «EXPAND xpt::diagram::parts::Common::getViewCode».getElement());
	}
	return labelRefresher;
}
«ENDDEFINE»

«DEFINE refreshMethods FOR gmfgen::GenCommonBase»«ENDDEFINE»

«DEFINE refreshMethods FOR gmfgen::GenCompartment-»
«EXPAND refreshVisibility-»
«ENDDEFINE»

«DEFINE refreshMethods FOR gmfgen::GenNode-»
«EXPAND refreshVisibility-»
«EXPAND refreshBounds-»
«EXPAND refreshFont-»
«EXPAND refreshBackgroundColor-»
«EXPAND refreshForegroundColor-»
«EXPAND refreshShortcutDecoration-»
«ENDDEFINE»

«DEFINE refreshMethods FOR gmfgen::GenChildLabelNode-»
«EXPAND refreshVisibility-»
«EXPAND refreshFont-»
«EXPAND refreshFontColor-»
«EXPAND refreshLabel-»
«EXPAND labelRefresher-»
«ENDDEFINE»

«DEFINE refreshMethods FOR gmfgen::GenLabel-»
«EXPAND refreshFont-»
«EXPAND refreshFontColor-»
«EXPAND refreshLabel-»
«EXPAND labelRefresher-»
«EXPAND externalFontRefresher-»
«EXPAND externalFontColorRefresher-»
«ENDDEFINE»

«DEFINE refreshMethods FOR gmfgen::GenLink-»
«EXPAND refreshVisibility-»
«EXPAND refreshBendpoints-»
«EXPAND refreshBackgroundColor-»
«EXPAND refreshForegroundColor-»
«ENDDEFINE»

«DEFINE externalFontColorRefresher FOR gmfgen::GenLabel-»
«IF !viewmap.isFixedFont()-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher fontColorRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshFontColor();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_FontColor() == msg.getFeature()) {
			return true;
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles() == msg.getFeature()) {
			return org.eclipse.gmf.runtime.lite.edit.parts.update.UpdaterUtil.affects(msg, org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle());
		}
		return false;
	}
};
«ENDIF-»
«ENDDEFINE»

«DEFINE externalFontRefresher FOR gmfgen::GenLabel-»
«IF !viewmap.isFixedFont()-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher fontRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshFont();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle().getEStructuralFeatures().contains(msg.getFeature())) {
			return true;
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles() == msg.getFeature()) {
			return org.eclipse.gmf.runtime.lite.edit.parts.update.UpdaterUtil.affects(msg, org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle());
		}
		return false;
	}
};
«ENDIF-»
«ENDDEFINE»

«DEFINE refreshVisibility FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshVisibility() {
	boolean isVisible = «EXPAND xpt::diagram::parts::Common::getViewCode».isVisible();
	boolean wasVisible = getFigure().isVisible();
	if (isVisible == wasVisible) {
		return;
	}
«IF isSelectable()-»
	if (!isVisible && (getSelected() != SELECTED_NONE)) {
		getViewer().deselect(this);
	}
«ENDIF-»
	getFigure().setVisible(isVisible);
	getFigure().revalidate();
}
«ENDDEFINE»

«DEFINE refreshBendpoints FOR gmfgen::GenLink-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshBendpoints() {
	org.eclipse.gmf.runtime.notation.RelativeBendpoints bendpoints = (org.eclipse.gmf.runtime.notation.RelativeBendpoints) getDiagramEdge().getBendpoints();
	if (bendpoints == null) {
		getConnectionFigure().setRoutingConstraint(java.util.Collections.EMPTY_LIST);
		return;
	}
	java.util.List modelConstraint = bendpoints.getPoints();
	java.util.List figureConstraint = new java.util.ArrayList();
	for (int i = 0; i < modelConstraint.size(); i++) {
		org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint wbp = (org.eclipse.gmf.runtime.notation.datatype.RelativeBendpoint) modelConstraint.get(i);
		org.eclipse.draw2d.RelativeBendpoint rbp = new org.eclipse.draw2d.RelativeBendpoint(getConnectionFigure());
		rbp.setRelativeDimensions(new org.eclipse.draw2d.geometry.Dimension(wbp.getSourceX(), wbp.getSourceY()), new org.eclipse.draw2d.geometry.Dimension(wbp.getTargetX(), wbp.getTargetY()));
		rbp.setWeight((i + 1) / ((float) modelConstraint.size() + 1));
		figureConstraint.add(rbp);
	}
	getConnectionFigure().setRoutingConstraint(figureConstraint);
}
«ENDDEFINE»

«DEFINE refreshBounds FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshBounds() {
	org.eclipse.gmf.runtime.notation.Node node = «EXPAND xpt::diagram::parts::Common::getViewCode»;
	if (node.getLayoutConstraint() == null) {
		return;
	}
	assert node.getLayoutConstraint() instanceof org.eclipse.gmf.runtime.notation.Bounds;
	org.eclipse.gmf.runtime.notation.Bounds bounds = (org.eclipse.gmf.runtime.notation.Bounds) node.getLayoutConstraint();
	int x = bounds.getX();
	int y = bounds.getY();
	int width = bounds.getWidth();
	int height = bounds.getHeight();
	if (width < 0) {
		x -= width;
		width = -width;
	}
	if (height < 0) {
		y -= height;
		height = -height;
	}
	«EXPAND setLayoutConstraint-»
}
«ENDDEFINE»

«DEFINE setLayoutConstraint FOR gmfgen::GenCommonBase-»
((org.eclipse.gef.GraphicalEditPart) getParent()).setLayoutConstraint(this, getFigure(), new org.eclipse.draw2d.geometry.Rectangle(x, y, width, height));
«ENDDEFINE»

«DEFINE setLayoutConstraint FOR gmfgen::GenChildSideAffixedNode-»
org.eclipse.draw2d.IFigure parentFigure = getFigure().getParent();
if (parentFigure != null && parentFigure.getLayoutManager() != null) {
	Object constraint = parentFigure.getLayoutManager().getConstraint(getFigure());
	org.eclipse.gmf.runtime.lite.figures.BorderItemLocator locator;
	if (constraint instanceof org.eclipse.gmf.runtime.lite.figures.BorderItemLocator) {
		locator = (org.eclipse.gmf.runtime.lite.figures.BorderItemLocator) constraint;
	} else {
		locator = new org.eclipse.gmf.runtime.lite.figures.BorderItemLocator(this);
		parentFigure.getLayoutManager().setConstraint(getFigure(), locator);
	}
	locator.setModelConstraint(new org.eclipse.draw2d.geometry.Rectangle(x, y, width, height));
}
«ENDDEFINE»

«DEFINE refreshFont FOR gmfgen::GenCommonBase-»
«IF !isFixedFont(viewmap)-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshFont() {
	org.eclipse.gmf.runtime.notation.FontStyle style = (org.eclipse.gmf.runtime.notation.FontStyle) «EXPAND getStyleHolderCode».getStyle(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle());
	org.eclipse.jface.resource.FontDescriptor toDispose = createdFontDescriptor;
	if (style != null) {
		String fontName = style.getFontName();
		if (fontName != null && «getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().isStrictFont()) {
			org.eclipse.swt.graphics.FontData[] matchingDatas = getViewer().getControl().getDisplay().getFontList(fontName, true);
			if (matchingDatas == null || matchingDatas.length == 0) {
				fontName = null;
			}
		}
		int fontHeight = style.getFontHeight();
		if (fontName == null || fontHeight <= 0) {
			org.eclipse.swt.graphics.FontData defaultFont = org.eclipse.jface.preference.PreferenceConverter.getFontData(«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getPreferenceStore(), org.eclipse.gmf.runtime.lite.preferences.IPreferenceConstants.DEFAULT_FONT);
			if (fontName == null) {
				fontName = defaultFont.getName();
			}
			if (fontHeight <= 0) {
				fontHeight = defaultFont.getHeight();
			}
		}
		int fontStyle = org.eclipse.swt.SWT.NORMAL;
		if (style.isBold()) {
			fontStyle |= org.eclipse.swt.SWT.BOLD;
		}
		if (style.isItalic()) {
			fontStyle |= org.eclipse.swt.SWT.ITALIC;
		}
		org.eclipse.swt.graphics.Font currentFont = getFigure().getFont();
		if (currentFont != null) {
			org.eclipse.swt.graphics.FontData currentFontData = currentFont.getFontData()[0];
			if (currentFontData.getName().equals(fontName) && currentFontData.getHeight() == fontHeight && currentFontData.getStyle() == fontStyle) {
				return;
			}
		}
		createdFontDescriptor = org.eclipse.jface.resource.FontDescriptor.createFrom(fontName, fontHeight, fontStyle);
		getFigure().setFont(getViewer().getResourceManager().createFont(createdFontDescriptor));
	} else {
		//revert to the default font
		getFigure().setFont(getViewer().getControl().getFont());
		createdFontDescriptor = null;
	}
	if (toDispose != null) {
		getViewer().getResourceManager().destroyFont(toDispose);
	}
}

«EXPAND xpt::Common::generatedMemberComment("The font descriptor (created by {@@link #refreshFont()}) currently assigned to the label (unless the default font is assigned).\n" + 
 "Whenever another non-default font is assigned to it, the previous one should be destroyed through the resource manager.")»
private org.eclipse.jface.resource.FontDescriptor createdFontDescriptor;
«ENDIF-»
«ENDDEFINE»

«DEFINE refreshFontColor FOR gmfgen::GenCommonBase-»
«IF !isFixedFont(viewmap)-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshFontColor() {
	org.eclipse.gmf.runtime.notation.FontStyle style = (org.eclipse.gmf.runtime.notation.FontStyle)  «EXPAND getStyleHolderCode».getStyle(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle());
	org.eclipse.jface.resource.ColorDescriptor toDispose = createdFontColorDescriptor;
	if (style != null) {
		int fontColor = style.getFontColor();
		int red = fontColor & 0x000000FF;
		int green = (fontColor & 0x0000FF00) >> 8;
		int blue = (fontColor & 0x00FF0000) >> 16;
		org.eclipse.swt.graphics.Color currentColor = getFigure().getForegroundColor();
		if (currentColor != null && currentColor.getRed() == red && currentColor.getGreen() == green && currentColor.getBlue() == blue) {
			return;
		}
		createdFontColorDescriptor = org.eclipse.jface.resource.ColorDescriptor.createFrom(new org.eclipse.swt.graphics.RGB(red, green, blue));
	} else {
		createdFontColorDescriptor = org.eclipse.jface.resource.ColorDescriptor.createFrom(«EXPAND defaultColor("FONT_COLOR")»);
	}
	getFigure().setForegroundColor(getViewer().getResourceManager().createColor(createdFontColorDescriptor));
	if (toDispose != null) {
		getViewer().getResourceManager().destroyColor(toDispose);
	}
}

«EXPAND xpt::Common::generatedMemberComment("The color descriptor (created by {@@link #refreshFontColor()}) currently assigned to the label.\n" + 
 "Whenever another color is assigned to it, the previous one should be destroyed through the resource manager.")»
private org.eclipse.jface.resource.ColorDescriptor createdFontColorDescriptor;
«ENDIF-»
«ENDDEFINE»

«DEFINE refreshForegroundColor FOR gmfgen::GenCommonBase-»
«IF !viewmap.isFixedForeground()-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshForegroundColor() {
	org.eclipse.gmf.runtime.notation.LineStyle style = (org.eclipse.gmf.runtime.notation.LineStyle)  «EXPAND getStyleHolderCode».getStyle(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLineStyle());
	org.eclipse.jface.resource.ColorDescriptor toDispose = createdForegroundColorDescriptor;
	if (style != null) {
		int foregroundColor = style.getLineColor();
		int red = foregroundColor & 0x000000FF;
		int green = (foregroundColor & 0x0000FF00) >> 8;
		int blue = (foregroundColor & 0x00FF0000) >> 16;
		org.eclipse.swt.graphics.Color currentColor = getFigure().getForegroundColor();
		if (currentColor != null && currentColor.getRed() == red && currentColor.getGreen() == green && currentColor.getBlue() == blue) {
			return;
		}
		createdForegroundColorDescriptor = org.eclipse.jface.resource.ColorDescriptor.createFrom(new org.eclipse.swt.graphics.RGB(red, green, blue));
	} else {
		createdForegroundColorDescriptor = org.eclipse.jface.resource.ColorDescriptor.createFrom(«EXPAND defaultColor("LINE_COLOR")»);
	}
	getFigure().setForegroundColor(getViewer().getResourceManager().createColor(createdForegroundColorDescriptor));
	if (toDispose != null) {
		getViewer().getResourceManager().destroyColor(toDispose);
	}
}

«EXPAND xpt::Common::generatedMemberComment("The color descriptor (created by {@@link #refreshForegroundColor()}) currently assigned to the figure.\n" + 
 "Whenever another color is assigned to it, the previous one should be destroyed through the resource manager.")»
private org.eclipse.jface.resource.ColorDescriptor createdForegroundColorDescriptor;
«ENDIF-»
«ENDDEFINE»

«DEFINE refreshBackgroundColor FOR gmfgen::GenCommonBase-»
«IF !viewmap.isFixedBackground()-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshBackgroundColor() {
	org.eclipse.gmf.runtime.notation.FillStyle style = (org.eclipse.gmf.runtime.notation.FillStyle)  «EXPAND getStyleHolderCode».getStyle(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFillStyle());
	org.eclipse.jface.resource.ColorDescriptor toDispose = createdBackgroundColorDescriptor;
	if (style != null) {
		int backgroundColor = style.getFillColor();
		int red = backgroundColor & 0x000000FF;
		int green = (backgroundColor & 0x0000FF00) >> 8;
		int blue = (backgroundColor & 0x00FF0000) >> 16;
		org.eclipse.swt.graphics.Color currentColor = getFigure().getBackgroundColor();
		if (currentColor != null && currentColor.getRed() == red && currentColor.getGreen() == green && currentColor.getBlue() == blue) {
			return;
		}
		createdBackgroundColorDescriptor = org.eclipse.jface.resource.ColorDescriptor.createFrom(new org.eclipse.swt.graphics.RGB(red, green, blue));
	} else {
		createdBackgroundColorDescriptor = org.eclipse.jface.resource.ColorDescriptor.createFrom(«EXPAND defaultColor("FILL_COLOR")»);
	}
	getFigure().setBackgroundColor(getViewer().getResourceManager().createColor(createdBackgroundColorDescriptor));
	if (toDispose != null) {
		getViewer().getResourceManager().destroyColor(toDispose);
	}
}

«EXPAND xpt::Common::generatedMemberComment("The color descriptor (created by {@@link #refreshBackgroundColor()}) currently assigned to the figure.\n" + 
 "Whenever another color is assigned to it, the previous one should be destroyed through the resource manager.")»
private org.eclipse.jface.resource.ColorDescriptor createdBackgroundColorDescriptor;
«ENDIF-»
«ENDDEFINE»

«DEFINE refreshLabel FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshLabel() {
	getLabel().setText(getLabelText());
	getLabel().setIcon(getLabelIcon());
}
«ENDDEFINE»

«DEFINE refreshShortcutDecoration FOR gmfgen::GenNode-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshShortcutDecoration() {
	org.eclipse.gmf.runtime.lite.edit.parts.decorations.IDecorationManager decorationManager = getDecorationManager();
	if (decorationManager == null) {
		return;
	}
	org.eclipse.draw2d.Label decorationFigure = null;
	org.eclipse.emf.ecore.EAnnotation annotation = «EXPAND xpt::diagram::parts::Common::getViewCode».getEAnnotation("Shortcut"); «EXPAND xpt::Common::nonNLS»
	if (annotation != null) {
		org.eclipse.swt.graphics.Image image = «getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getBundledImage("icons/shortcut.gif"); «EXPAND xpt::Common::nonNLS»
		decorationFigure = new org.eclipse.draw2d.Label(image);
	}
	decorationManager.installDecoration("Shortcut", decorationFigure);
}
«ENDDEFINE»

«DEFINE refreshVisuals FOR gmfgen::GenCommonBase»«ENDDEFINE»

«DEFINE refreshVisuals FOR gmfgen::GenCompartment-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshVisuals() {
	super.refreshVisuals();
	refreshVisibility();
}
«ENDDEFINE»

«DEFINE refreshVisuals FOR gmfgen::GenNode-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshVisuals() {
	super.refreshVisuals();
	refreshVisibility();
	refreshBounds();
«IF !viewmap.isFixedFont()-»
	refreshFont();
«ENDIF-»
«IF !viewmap.isFixedBackground()-»
	refreshBackgroundColor();
«ENDIF-»
«IF !viewmap.isFixedForeground()-»
	refreshForegroundColor();
«ENDIF-»
«IF getDiagram().shortcutsProvidedFor.size() > 0-»
	refreshShortcutDecoration();
«ENDIF-»
}
«ENDDEFINE»

«DEFINE refreshVisuals FOR gmfgen::GenChildLabelNode-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshVisuals() {
	super.refreshVisuals();
	refreshVisibility();
	refreshLabel();
«IF !viewmap.isFixedFont()-»
	refreshFont();
	refreshFontColor();
«ENDIF-»
}
«ENDDEFINE»

«DEFINE refreshVisuals FOR gmfgen::GenLabel-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshVisuals() {
	super.refreshVisuals();
	refreshLabel();
«IF !viewmap.isFixedFont()-»
	refreshFont();
	refreshFontColor();
«ENDIF-»
}
«ENDDEFINE»

«DEFINE refreshVisuals FOR gmfgen::GenLink-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshVisuals() {
	super.refreshVisuals();
	refreshVisibility();
	refreshBendpoints();
«IF !viewmap.isFixedBackground()-»
	refreshBackgroundColor();
«ENDIF-»
«IF !viewmap.isFixedForeground()-»
	refreshForegroundColor();
«ENDIF-»
}
«ENDDEFINE»

«DEFINE externalRefreshers FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::generatedMemberComment»
private java.util.Collection externalRefreshers = new java.util.ArrayList();

«EXPAND xpt::Common::generatedMemberComment»
public java.util.Collection getExternalRefreshers() {
	return externalRefreshers;
}

«EXPAND xpt::Common::generatedMemberComment»
public void addExternalRefresher(org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher externalRefresher) {
	if (externalRefresher != null && !externalRefreshers.contains(externalRefresher)) {
		externalRefreshers.add(externalRefresher);
	}
}

«EXPAND xpt::Common::generatedMemberComment»
public void removeExternalRefresher(org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher externalRefresher) {
	externalRefreshers.remove(externalRefresher);
}
«ENDDEFINE»

«DEFINE getStyleHolderCode FOR gmfgen::GenCommonBase»«EXPAND xpt::diagram::parts::Common::getViewCode»«ENDDEFINE»

«DEFINE getStyleHolderCode FOR gmfgen::GenNodeLabel»getUpdatableParent().«EXPAND xpt::diagram::parts::Common::getViewCode FOR node»«ENDDEFINE»

«DEFINE getStyleHolderCode FOR gmfgen::GenLinkLabel»getUpdatableParent().«EXPAND xpt::diagram::parts::Common::getViewCode FOR link»«ENDDEFINE»

«DEFINE ignoreIfInactive FOR GenCommonBase-»
if (!isActive()) {
	return;
}
«ENDDEFINE»

«DEFINE defaultColor(String colorConstant) FOR gmfgen::GenCommonBase»org.eclipse.jface.preference.PreferenceConverter.getColor(«getDiagram().editorGen.plugin.getActivatorQualifiedClassName()».getInstance().getPreferenceStore(), org.eclipse.gmf.runtime.lite.preferences.IPreferenceConstants.«colorConstant»)«ENDDEFINE»
@


1.9
log
@[208264]: [lite]: Implement border items
[208270]: [lite]: Feedback for element creation should show exactly where the element will be created
Move external label when a deep ancestor is moved;
NodeEditPart.xpt: add variation point to createEditPolicies;
AddNodeCommand.xpt: do not generate unused attribute
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
@


1.8
log
@1. Preferences for fonts and colors
2. ResourceManager employed to reuse fonts and colors used for styles
3. Option to check the availability of the font name that is specified in the style
4. Styles are initialized with defaults from preferences
@
text
@d454 20
a473 2
	((org.eclipse.gef.GraphicalEditPart) getParent()).setLayoutConstraint(this, getFigure(), 
		new org.eclipse.draw2d.geometry.Rectangle(x, y, width, height));
@


1.7
log
@[201937]: Provide means to modify fonts and colors of a view in Lite diagrams;
Correct the styles attached to each of the diagram element type (make consistent with the code that refreshes them);
IllegalArgumentException when FontStyle specifies null font family name or a negative font size: default font name/size is now used instead;
Correct test to match the new logic of default color used for links;
Include schema for the oeg.runtime.lite in the builds
@
text
@d464 1
a464 1
	org.eclipse.swt.graphics.Font toDispose = createdFont;
d467 6
d475 1
a475 1
			org.eclipse.swt.graphics.FontData defaultFont = getViewer().getControl().getFont().getFontData()[0];
d497 2
a498 2
		createdFont = new org.eclipse.swt.graphics.Font(null, fontName, fontHeight, fontStyle);
		getFigure().setFont(createdFont);
d502 1
a502 1
		createdFont = null;
d505 1
a505 1
		toDispose.dispose();
d509 3
a511 3
«EXPAND xpt::Common::generatedMemberComment("The font (created by {@@link #refreshFont()}) currently assigned to the label (unless the default font is assigned).\n" + 
 "Whenever another non-default font is assigned to it, it is safe to dispose the previous one.")»
private org.eclipse.swt.graphics.Font createdFont;
d520 1
a520 1
	org.eclipse.swt.graphics.Color toDispose = createdFontColor;
d530 1
a530 2
		createdFontColor = new org.eclipse.swt.graphics.Color(null, red, green, blue);
		getFigure().setForegroundColor(createdFontColor);
d532 1
a532 2
		getFigure().setForegroundColor(getViewer().getControl().getForeground());
		createdFontColor = null;
d534 1
d536 1
a536 1
		toDispose.dispose();
d540 3
a542 3
«EXPAND xpt::Common::generatedMemberComment("The color (created by {@@link #refreshFontColor()}) currently assigned to the label.\n" + 
 "Whenever another color is assigned to it, it is safe to dispose the previous one.")»
private org.eclipse.swt.graphics.Color createdFontColor;
d551 1
a551 1
	org.eclipse.swt.graphics.Color toDispose = createdForegroundColor;
d561 1
a561 2
		createdForegroundColor = new org.eclipse.swt.graphics.Color(null, red, green, blue);
		getFigure().setForegroundColor(createdForegroundColor);
d563 1
a563 2
		getFigure().setForegroundColor(getViewer().getControl().getForeground());
		createdForegroundColor = null;
d565 1
d567 1
a567 1
		toDispose.dispose();
d571 3
a573 3
«EXPAND xpt::Common::generatedMemberComment("The color (created by {@@link #refreshForegroundColor()}) currently assigned to the figure.\n" + 
 "Whenever another color is assigned to it, it is safe to dispose the previous one.")»
private org.eclipse.swt.graphics.Color createdForegroundColor;
d582 1
a582 1
	org.eclipse.swt.graphics.Color toDispose = createdBackgroundColor;
d592 1
a592 2
		createdBackgroundColor = new org.eclipse.swt.graphics.Color(null, red, green, blue);
		getFigure().setBackgroundColor(createdBackgroundColor);
d594 1
a594 1
		getFigure().setBackgroundColor(getViewer().getControl().getBackground());
d596 1
d598 1
a598 1
		toDispose.dispose();
d602 3
a604 3
«EXPAND xpt::Common::generatedMemberComment("The color (created by {@@link #refreshBackgroundColor()}) currently assigned to the figure.\n" + 
  "Whenever another color is assigned to it, it is safe to dispose the previous one.")»
private org.eclipse.swt.graphics.Color createdBackgroundColor;
d737 2
@


1.6
log
@1. Don't cache templates if dynamic templates option is on;
2. [199747] Support shortcuts in the Lite diagrams (including notation model update for links between alien shortcuts);
3. Decorations should be visible;
4. TransactionalUpdateManager: more notifications to be dispatched to parents, make it possible to add more in subclasses;
5. On element creation, it should be given an opportunity to contribute its notational update commands;
6. [199749]: Delete from View supported (request, edit policy, command, UI action);
7. Add @@generated tags where they were missing;
8. ChildNotationModelRefresher: if the child feature is derived transient, notation model refresher should listen to containment feature.
@
text
@d58 4
a68 1
«EXPAND fontColor-»
d80 3
a88 1
«EXPAND font-»
d256 1
d273 1
a322 1
«EXPAND refreshFontColor-»
a347 1
«EXPAND refreshFont-»
d352 1
a352 1
«DEFINE externalFontRefresher FOR gmfgen::GenLabel-»
d355 1
a355 1
private org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher fontRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
d358 1
a358 1
		refreshFont();
d373 2
a374 1
«DEFINE externalFontColorRefresher FOR gmfgen::GenLabel-»
d376 1
a376 1
private org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher fontColorRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
d379 1
a379 1
		refreshFontColor();
d391 1
d468 9
d510 1
d538 1
a647 1
	refreshFontColor();
d668 1
a669 1
	refreshFontColor();
d680 1
a681 1
	refreshFontColor();
a690 3
«IF !viewmap.isFixedFont()-»
	refreshFont();
«ENDIF-»
@


1.5
log
@Eliminated Jet templates in lite version;
i18n in lite RT;
For generated classes whose names are not directly modifiable via gmfgen file, consistent className/qualifiedClassName template is exposed (and used throughout the generation process, including the Generator);
Link labels and external node labels are not selectable, but movable;
Inner elements are not selectable with marquee tool;
Fixed copyright statements throughout the lite RT.
@
text
@d68 1
d106 3
d117 1
d251 1
a251 1
Refresher fontColorRefresher = new Refresher() {
d269 24
d319 1
d594 17
d637 3
@


1.4
log
@switching to nsURI format which uses year to denote model version (same way EMF does)
@
text
@a306 8
«EXPAND moreRefreshMethods-»
«ENDDEFINE»

«DEFINE moreRefreshMethods FOR gmfgen::GenLabel»«ENDDEFINE»

«DEFINE moreRefreshMethods FOR gmfgen::GenLinkLabel-»
«EXPAND refreshLocation-»
«EXPAND externalLocationRefresher-»
a356 19
«DEFINE externalLocationRefresher FOR gmfgen::GenLinkLabel-»
«EXPAND xpt::Common::generatedMemberComment»
private org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher locationRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart.ExternalRefresher() {
	public void refresh() {
		«EXPAND ignoreIfInactive-»
		refreshLocation();
	}
	public boolean isAffectingEvent(org.eclipse.emf.common.notify.Notification msg) {
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLocation().getEStructuralFeatures().contains(msg.getFeature())) {
			return true;
		}
		if (org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getNode_LayoutConstraint() == msg.getFeature()) {
			return true;
		}
		return false;
	}
};
«ENDDEFINE»

a395 17
«DEFINE refreshLocation FOR gmfgen::GenLinkLabel-»
«EXPAND xpt::Common::generatedMemberComment»
protected void refreshLocation() {
	org.eclipse.gmf.runtime.notation.Node node = «EXPAND xpt::diagram::parts::Common::getViewCode»;
	assert node.getLayoutConstraint() instanceof org.eclipse.gmf.runtime.notation.Location;
	final org.eclipse.gmf.runtime.notation.Location location = (org.eclipse.gmf.runtime.notation.Location) node.getLayoutConstraint();
	«getLabelHostQualifiedClassName()» parent = getUpdatableParent();
	org.eclipse.draw2d.Connection connection = (org.eclipse.draw2d.Connection) parent.getFigure();
	((org.eclipse.gef.GraphicalEditPart) getParent()).setLayoutConstraint(this,
			getFigure(), new org.eclipse.draw2d.ConnectionLocator(connection, org.eclipse.draw2d.ConnectionLocator.«alignment.literal») {
				protected org.eclipse.draw2d.geometry.Point getReferencePoint() {
					return super.getReferencePoint().translate(location.getX(), location.getY());
				}
			});
}
«ENDDEFINE»

a614 1
	«EXPAND moreRefreshVisuals-»
a617 6
«DEFINE moreRefreshVisuals FOR gmfgen::GenLabel»«ENDDEFINE»

«DEFINE moreRefreshVisuals FOR gmfgen::GenLinkLabel-»
refreshLocation();
«ENDDEFINE»

@


1.3
log
@1. Links to links;
2. Exception from TreeEditPartViewer (in the outline) while closing the diagram editor (because unregister is not called, only deactivate) fixed;
3. instead of rerouting a link to an end that does not support it, remove the link
@
text
@d13 1
a13 1
«IMPORT "http://www.eclipse.org/gmf/2005/GenModel/2.0"»
@


1.2
log
@CanonicalStyle is taken into account while refreshing notational model to reflect changes in underlying domain model;
Update is now centralized and transactional;
Changes to visibility are dispatched to the parent of the affected view as well (was: only to the view itself);
Save options are not reused, for easy modification of the generated code;
Side-affixed children are not considered direct children;
Empty edit-patterns are treated the same way as null patterns (view pattern is used instead).
@
text
@d79 2
@


1.1
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@d28 1
a28 1
private java.util.HashMap structuralFeatures2Refresher;
d32 1
a32 1
	if (structuralFeatures2Refresher == null) {
d35 1
a35 1
	return (Refresher) structuralFeatures2Refresher.get(feature);
d40 1
a40 1
	structuralFeatures2Refresher = new java.util.HashMap();
a70 1
«EXPAND children-»
d86 1
a86 1
Refresher childrenRefresher = new Refresher() {
d88 1
d91 14
d106 5
a110 4
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_PersistedChildren(), childrenRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_TransientChildren(), childrenRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Styles(), childrenRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getDrawerStyle_Collapsed(), childrenRefresher);
d114 1
a114 1
Refresher visibilityRefresher = new Refresher() {
d116 1
d119 6
d126 1
a126 1
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_Visible(), visibilityRefresher);
d132 1
d136 2
a137 2
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getEdge_Bendpoints(), bendpointsRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getRelativeBendpoints_Points(), bendpointsRefresher);
d143 1
d147 5
a151 5
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getNode_LayoutConstraint(), boundsRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getSize_Width(), boundsRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getSize_Height(), boundsRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLocation_X(), boundsRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLocation_Y(), boundsRefresher);
d157 1
d161 1
a161 1
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_SourceEdges(), sourceEdgesRefresher);
d167 1
d171 1
a171 1
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getView_TargetEdges(), targetEdgesRefresher);
d176 1
a176 1
Refresher backgroundColorRefresher = new Refresher() {
d178 1
d181 9
d191 2
a192 1
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFillStyle_FillColor(), backgroundColorRefresher);
d198 1
a198 1
Refresher foregroundColorRefresher = new Refresher() {
d200 1
d203 9
d213 2
a214 1
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getLineStyle_LineColor(), foregroundColorRefresher);
d220 1
a220 1
Refresher fontRefresher = new Refresher() {
d222 1
d225 9
d235 5
a239 4
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_FontHeight(), fontRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_FontName(), fontRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_Bold(), fontRefresher);
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_Italic(), fontRefresher);
d246 1
d249 9
d259 1
a259 1
structuralFeatures2Refresher.put(org.eclipse.gmf.runtime.notation.NotationPackage.eINSTANCE.getFontStyle_FontColor(), fontColorRefresher);
d326 1
a326 1
private org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart.Refresher fontRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart.Refresher() {
d328 1
d331 9
d346 1
a346 1
private org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart.Refresher fontColorRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart.Refresher() {
d348 1
d351 9
d364 2
a365 1
private org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart.Refresher locationRefresher = new org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart.Refresher() {
d367 1
d370 9
a706 31
«DEFINE addRemove FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::generatedMemberComment»
public void addRefresher(org.eclipse.emf.ecore.EStructuralFeature feature, Refresher refresher) {
	CompositeRefresher compositeRefresher = getCompositeRefresher(feature);
	compositeRefresher.addRefresher(refresher);
}

«EXPAND xpt::Common::generatedMemberComment»
public void removeRefresher(org.eclipse.emf.ecore.EStructuralFeature feature, Refresher refresher) {
	CompositeRefresher compositeRefresher = getCompositeRefresher(feature);
	compositeRefresher.removeRefresher(refresher);
}

«EXPAND xpt::Common::generatedMemberComment»
private CompositeRefresher getCompositeRefresher(org.eclipse.emf.ecore.EStructuralFeature feature) {
	if (structuralFeatures2Refresher == null) {
		createRefreshers();
	}
	Refresher refresher = (Refresher) structuralFeatures2Refresher.get(feature);
	if (refresher instanceof CompositeRefresher) {
		return (CompositeRefresher) refresher;
	}
	CompositeRefresher result = new CompositeRefresher();
	if (refresher != null) {
		result.addRefresher(refresher);
	}
	structuralFeatures2Refresher.put(feature, result);
	return result;
}
«ENDDEFINE»

d712 6
@

