head	1.20;
access;
symbols
	v20080910-1520:1.20
	v20070403-1500:1.19
	v20070330-1300:1.19
	v20060330-1300:1.19
	v20070322-1100:1.19
	v20060316-0600:1.19
	v20070307-0700:1.18
	v20070228-2000:1.17
	v20070221-1500:1.17
	v20070208-1800:1.17
	v20070103-0300:1.16
	M4_20:1.16
	v20061222-1800:1.16
	v20061214-0000:1.16
	v20061120-1300:1.16
	M3_20:1.16
	v20061117-0800:1.16
	v20061013-1330:1.10
	v20061005-1700:1.5
	M1_20:1.9
	v20060904-1500:1.9
	v20060824-1600:1.5
	v20060713-1700:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	v20060627-1200:1.5
	v20060626-1420:1.5
	v20060620-0400:1.4
	v20060616-1400:1.4
	v20060616-1200:1.4
	v20060609-1400:1.4
	v20060531-1730:1.4
	v20060530-1930:1.4
	v20060526-1200:1.4
	v20060519-1300:1.3
	v20060519-0800:1.3
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.20
date	2007.04.04.11.04.48;	author bblajer;	state dead;
branches;
next	1.19;
commitid	18c54613864d4567;

1.19
date	2007.03.15.16.43.30;	author bblajer;	state Exp;
branches;
next	1.18;
commitid	617845f977b04567;

1.18
date	2007.03.03.23.45.10;	author bblajer;	state Exp;
branches;
next	1.17;
commitid	2e3145ea08814567;

1.17
date	2007.02.08.16.44.13;	author bblajer;	state Exp;
branches;
next	1.16;
commitid	af945cb535c4567;

1.16
date	2006.11.09.18.15.42;	author bblajer;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.19.11.00.31;	author bblajer;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.18.16.29.03;	author bblajer;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.18.14.35.15;	author dstadnik;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.18.09.56.59;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.17.13.08.27;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.11.15.45.01;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.01.16.14.09;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.04.17.05.48;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.02.10.43.51;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.03.18.07.48;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.21.15.22.43;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.22.18.22.10;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.15.11.19.18;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.26.11.58.48;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.13.21.20.15;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.20
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.lite.parts" class="NodeLabelEditPartGenerator"
	imports="java.util.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.emf.ecore.*"%>
<%
final GenCommonBase genElement = (GenCommonBase) ((Object[]) argument)[0];
final GenNodeLabel genLabel = (GenNodeLabel) genElement;
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
GenNode genHost = genLabel.getNode();
GenClass underlyingMetaClass = genHost.getDomainMetaClass();
GenDiagram genDiagram = genLabel.getDiagram();
LabelModelFacet labelModelFacet = genLabel.getModelFacet();
final boolean isReadOnly = genLabel.isReadOnly();
%>
<%@@ include file="../copyright4java.jetinc"%>

<%@@ include file="../common/featureGetAccessor.jetinc"%>

<%importManager.emitPackageStatement(stringBuffer);%>

<%
importManager.addImport("org.eclipse.gef.EditPart");
importManager.addImport("org.eclipse.gef.EditPolicy");
importManager.addImport("org.eclipse.gmf.runtime.notation.View");
importManager.markImportLocation(stringBuffer);
%>

/**
 * @@generated
 */
 <%
 	boolean isExternal;
 	String baseClass;
 	if (genLabel instanceof GenExternalNodeLabel) {
 		isExternal = true;
 		baseClass = genDiagram.getBaseExternalNodeLabelEditPartQualifiedClassName();
 	} else {
 		isExternal = false;
 		baseClass = "org.eclipse.gef.editparts.AbstractGraphicalEditPart";
 	}
 %>
public class <%=genLabel.getEditPartClassName()%> extends <%=importManager.getImportedName(baseClass)%> implements <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelController")%> {
<%{
GenCommonBase genCommonBase = genLabel;%>
<%@@ include file="visualID.jetinc"%>
<%}%>
<%@@ include file="textAwareFields.jetinc"%>

	/**
	 * @@generated
	 */
	public <%=genLabel.getEditPartClassName()%>(View view) {
<%
if (isExternal) {
%>
		super(view);
<%
} else {
%>
		setModel(view);
<%
}
%>
	}

<%
if (!isExternal) {
%>
	/**
	 * @@generated
	 */
	public boolean isSelectable() {
		return false;
	}
<%
}
%>

	/**
	 * @@generated
	 */
	public <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Node")%> getDiagramNode() {
		return (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Node")%>) getModel();
	}

	/**
	 * @@generated
	 */
	protected void createEditPolicies() {
<%
	final String primaryView = "getUpdatableParent().getDiagramNode()";
	final String resolvedSemanticElement = "resolveSemanticElement()";
	if (!isReadOnly) {
%>
<%@@ include file="directEditPolicy.javajetinc"%>
<%
	}
%>
<%{
GenCommonBase genCommonBase = genLabel;%>
<%@@ include file="customBehaviour.jetinc"%>
<%@@include file="openEditPolicy.jetinc"%>
<%}%>
	}

<%@@ include file="labelPerformRequest.jetinc"%>
<%
	if (!isReadOnly) {
%>
<%@@ include file="directEdit.javajetinc"%>
<%
	}
%>

	/**
	 * @@generated
	 */
	protected void refreshVisuals() {
		super.refreshVisuals();
		refreshLabel();
		refreshFont();
		refreshFontColor();
	}

	/**
	 * @@generated
	 */
	protected void refreshLabel() {
		getLabel().setText(getLabelText());
		getLabel().setIcon(getLabelIcon());
	}

<%@@ include file="labelText.javajetinc"%>
<%@@ include file="refreshMethods/font.javajetinc"%>
<%@@ include file="refreshMethods/fontColor.javajetinc"%>

	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.swt.graphics.Image")%> getLabelIcon() {
<%
if (genLabel.isElementIcon()) {
%>
		<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> semanticElement = <%if (genHost.getDomainMetaClass().isExternalInterface()) {%>(<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%>) <%}%>resolveSemanticElement();
		if (semanticElement != null) {
			return <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.getImage(semanticElement.eClass());
		}
<%
}
%>
		return null;
	}

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName(genHost.getDomainMetaClass().getQualifiedInterfaceName())%> resolveSemanticElement() {
		View view = (View) getModel();
		return (view.getElement() instanceof <%=importManager.getImportedName(genHost.getDomainMetaClass().getQualifiedInterfaceName())%>) ? (<%=importManager.getImportedName(genHost.getDomainMetaClass().getQualifiedInterfaceName())%>) view.getElement() : null;
	}

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> getUpdatableParent() {
		for(EditPart editPart = getParent(); editPart != null; editPart = editPart.getParent()) {
			if (editPart instanceof <%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%>) {
				return (<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%>) editPart;
			}
		}
		return null;
	}

	/**
	 * @@generated
	 */
	public void activate() {
		super.activate();
		<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> updatableParent = getUpdatableParent();
		if (updatableParent != null) {
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontColor(), fontColorRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontHeight(), fontRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontName(), fontRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_Bold(), fontRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_Italic(), fontRefresher);
<%
if (isExternal) {
%>
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getLocation_X(), boundsRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getLocation_Y(), boundsRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getSize_Width(), boundsRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getSize_Height(), boundsRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getNode_LayoutConstraint(), boundsRefresher);
<%
}
%>
			updatableParent.addExternalRefresher(getLabelRefresher());
		}
	}

	/**
	 * @@generated
	 */
	public void deactivate() {
		super.deactivate();
		<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> updatableParent = getUpdatableParent();
		if (updatableParent != null) {
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontColor(), fontColorRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontHeight(), fontRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontName(), fontRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_Bold(), fontRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_Italic(), fontRefresher);
<%
if (isExternal) {
%>
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getLocation_X(), boundsRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getLocation_Y(), boundsRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getSize_Width(), boundsRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getSize_Height(), boundsRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getNode_LayoutConstraint(), boundsRefresher);
<%
}
%>
			updatableParent.removeExternalRefresher(getLabelRefresher());
		}
	}

<%@@ include file="refreshers.javajetinc/labelRefresher.jetinc"%>

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher fontColorRefresher = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher() {
		public void refresh() {
			refreshFontColor();
		}
	};

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher fontRefresher = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher() {
		public void refresh() {
			refreshFont();
		}
	};
<%
final Viewmap viewmap = genLabel.getViewmap();
%>
<%@@ include file="labelFigure.jetinc"%>
}
<%importManager.emitSortedImports();%>
@


1.19
log
@[164018] Command generation seperated from Parts for commands that operate with labels;
API to display label text, apply modifications and update after (external) modifications isolated from generated code;
Moved as much common generated code as possible to BaseTreeEditPart;
[165700] Support diagrams in read-only mode: all EMF commands that are not composed of standard EMF commands, but modify EMF models directly should query the editing domain for read-onliness of the resource they operate on.
@
text
@@


1.18
log
@Images should be reused across the editparts that represent same model element types (prevent SWTErrors when opening huge diagrams)
@
text
@d40 1
a40 1
public class <%=genLabel.getEditPartClassName()%> extends <%=importManager.getImportedName(baseClass)%> {
d80 7
a91 1
		String editPatternCode = "EDIT_PATTERN";	//declared in labelText.javajetinc, used in directEditCommand.jetinc.
a193 9
if (labelModelFacet instanceof FeatureLabelModelFacet) {
	FeatureLabelModelFacet featureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = featureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
		GenFeature next = (GenFeature) it.next();
%>
			updatableParent.addRefresher(<%=importManager.getImportedName(next.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=next.getFeatureAccessorName()%>(), labelRefresher);
<%
	}
}
d195 1
a220 9
if (labelModelFacet instanceof FeatureLabelModelFacet) {
	FeatureLabelModelFacet featureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = featureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
		GenFeature next = (GenFeature) it.next();
%>
			updatableParent.removeRefresher(<%=importManager.getImportedName(next.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=next.getFeatureAccessorName()%>(), labelRefresher);
<%
	}
}
d222 1
d226 1
a226 9
	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher labelRefresher = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher() {
		public void refresh() {
			refreshLabel();
		}
	};

@


1.17
log
@Ensure unselectability of the inner auxiliary edit parts by more standard GEF means (isSelectable() returns false instead of using EditPolicy with getHost() delegation)
@
text
@d136 3
a138 4
		<%=importManager.getImportedName(genHost.getDomainMetaClass().getQualifiedInterfaceName())%> element = resolveSemanticElement();
		<%=importManager.getImportedName("org.eclipse.jface.resource.ImageDescriptor")%> imageDescriptor = <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getItemImageDescriptor(element);
		if (imageDescriptor != null) {
			return imageDescriptor.createImage();
@


1.16
log
@[162579] Support diagram partitioning
+
1. CustomBehaviours;
2. LayoutDiagramAction: execute the command through the command stack;
3. WrappingCommand: Workaround for a problem with StrictCompoundCommand.canExecute() in transactional editing domains
@
text
@d64 13
@


1.15
log
@#161253: External node labels should be attached to nodes correctly
Generate 2 icons if myDiagram.getCreationWizardIconPathX() and myEditorGen.getEditor().getIconPathX() specify different absolute paths
@
text
@d78 5
d85 1
@


1.14
log
@Fix compilation problems introduced by recent fix of https://bugs.eclipse.org/bugs/show_bug.cgi?id=161380
@
text
@d29 12
a40 1
public class <%=genLabel.getEditPartClassName()%> extends <%=importManager.getImportedName("org.eclipse.gef.editparts.AbstractGraphicalEditPart")%> {
d51 7
d59 3
d161 9
d196 9
@


1.13
log
@#161380 simplify feature model facets
@
text
@d141 2
a142 2
	FeatureLabelModelFacet compositeFeatureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = compositeFeatureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
d167 2
a168 2
	FeatureLabelModelFacet compositeFeatureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = compositeFeatureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
@


1.12
log
@#161380 move readOnly back to GenLabel
@
text
@d141 1
a141 6
	GenFeature feature = ((FeatureLabelModelFacet)labelModelFacet).getMetaFeature();
%>
			updatableParent.addRefresher(<%=importManager.getImportedName(feature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=feature.getFeatureAccessorName()%>(), labelRefresher);
<%
} else if (labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	CompositeFeatureLabelModelFacet compositeFeatureLabelModelFacet = (CompositeFeatureLabelModelFacet) labelModelFacet;
d167 1
a167 6
	GenFeature feature = ((FeatureLabelModelFacet)labelModelFacet).getMetaFeature();
%>
			updatableParent.removeRefresher(<%=importManager.getImportedName(feature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=feature.getFeatureAccessorName()%>(), labelRefresher);
<%
} else if (labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	CompositeFeatureLabelModelFacet compositeFeatureLabelModelFacet = (CompositeFeatureLabelModelFacet) labelModelFacet;
@


1.11
log
@#160894 Move readOnly property from GenLabel to LabelFeatureModelFacet
@
text
@d11 1
a11 1
final boolean isReadOnly = genLabel.getModelFacet() != null && genLabel.getModelFacet().isReadOnly();
@


1.10
log
@[156358] bblajer - Diagram overview with Lite runtime
@
text
@d11 1
a11 1
final boolean isReadOnly = genLabel.isReadOnly();
@


1.9
log
@[155040] bblajer - Common Lite runtime functionality moved to dedicated plugin
@
text
@d51 1
@


1.8
log
@[bblajer] #152774 Compilable code when EClass has instance class attribute set
@
text
@d191 1
a191 1
	private IUpdatableEditPart.Refresher labelRefresher = new IUpdatableEditPart.Refresher() {
d201 1
a201 1
	private IUpdatableEditPart.Refresher fontColorRefresher = new IUpdatableEditPart.Refresher() {
d210 1
a210 1
	private IUpdatableEditPart.Refresher fontRefresher = new IUpdatableEditPart.Refresher() {
@


1.7
log
@[bblajer] #146009 Reflect changes in domain model links
@
text
@d6 1
a6 1
ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
d14 3
@


1.6
log
@#149455 Lite Generation: Respect option for labels to display node icon
@
text
@d107 2
a108 7
		for(EditPart editPart = this; editPart != null; editPart = editPart.getParent()) {
			View view = (View)editPart.getModel();
			if (view != null && view.getElement() != null) {
				return (<%=importManager.getImportedName(genHost.getDomainMetaClass().getQualifiedInterfaceName())%>) view.getElement();
			}
		}
		return null;
@


1.5
log
@[mgolubev] #147853 Fonts defined in the gmfgraph model should be used by the generated labels
@
text
@d89 3
d97 4
a100 1
		return <%=importManager.getImportedName("org.eclipse.jface.resource.ImageDescriptor")%>.getMissingImageDescriptor().createImage();
@


1.4
log
@[bblajer] #138430 Lite Generator: Generated code should make use of emf.transaction API
@
text
@d4 2
a5 1
GenNodeLabel genLabel = (GenNodeLabel) ((Object[]) argument)[0];
@


1.3
log
@[bblajer] #141280 Support child nodes without label
@
text
@d10 1
d46 1
a46 1
	final boolean isReadOnly = genLabel.isReadOnly();
d49 3
d54 3
d58 3
@


1.2
log
@[bblajer] #138415 Update Lite generator to use VISUAL_ID as view type scheme instead of annotations
@
text
@d45 1
d200 3
@


1.1
log
@[bblajer] #136702 Code generation targeting pure-GEF runtime
@
text
@d25 4
@

