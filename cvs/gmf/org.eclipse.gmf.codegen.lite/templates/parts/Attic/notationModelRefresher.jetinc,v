head	1.7;
access;
symbols
	v20080910-1520:1.7
	v20070403-1500:1.6
	v20070330-1300:1.6
	v20060330-1300:1.6
	v20070322-1100:1.6
	v20060316-0600:1.6
	v20070307-0700:1.6
	v20070228-2000:1.6
	v20070221-1500:1.6
	v20070208-1800:1.6
	v20070103-0300:1.6
	M4_20:1.6
	v20061222-1800:1.6
	v20061214-0000:1.6
	v20061120-1300:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061013-1330:1.6
	v20061005-1700:1.1.2.1
	M1_20:1.5
	v20060904-1500:1.5
	v20060824-1600:1.1.2.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060626-1420:1.1
	v20060620-0400:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.7
date	2007.04.04.11.04.48;	author bblajer;	state dead;
branches;
next	1.6;
commitid	18c54613864d4567;

1.6
date	2006.09.21.10.12.03;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.01.16.14.08;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.09.14.34.54;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.04.17.05.48;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.02.10.43.51;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.19.19.14.13;	author ashatalin;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.08.24.12.09.01;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@	/**
	 * @@generated
	 */
	private void installNotationModelRefresher() {
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ChildNotationModelRefresher")%> refresher = getNotationModelRefresher();
		if (refresher.isInstalled()) {
			return;
		}
		<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> domainModelEditDomain = <%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(<%=_getDiagramCode%>.getElement());
		refresher.install(domainModelEditDomain);
		refreshNotationModel();
	}

	/**
	 * @@generated
	 */
	private void uninstallNotationModelRefresher() {
		getNotationModelRefresher().uninstall();
	}

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ChildNotationModelRefresher")%> notationModelRefresher;

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ChildNotationModelRefresher")%> getNotationModelRefresher() {
		if (notationModelRefresher == null) {
			notationModelRefresher = new NotationModelRefresher();
		}
		return notationModelRefresher;
	}

	/**
	 * @@generated
	 */
	private class NotationModelRefresher extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ChildNotationModelRefresher")%> {
<%
boolean hasConstraintsInChildren = false;
for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenNode nextNode = (GenNode) it.next();
	TypeModelFacet typeModelFacet = nextNode.getModelFacet();
	if (typeModelFacet != null && typeModelFacet.getMetaClass() != null && typeModelFacet.getModelElementSelector() != null) {
		hasConstraintsInChildren = true;
		break;
	}
}
%>
<%
if (hasConstraintsInChildren) {
%>

		/**
		 * NB: Children of this element are selected based on constraint declared in <%=genDiagram.getVisualIDRegistryQualifiedClassName()%>. 
		 * Since no assumptions may be made concerning the runtime behavior of the constraint, <b>any</b> non-touch notification may result in 
		 * notational model having to be updated.
		 * <p/>User is encouraged to change implementation of this method to provide an optimization if it is safe to assume that not all notifications
		 * result in such an update.
		 * @@generated
		 */
		private <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> getConstrainedChildrenFilter() {
			return <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.NOT_TOUCH;
		}
<%
}
%>

		/**
		 * Creates a notification filter which filters notifications that may possibly affect the notational model
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> createFilter() {
<%
{
	boolean hasDeclaredFilter = false;
	Set genChildFeatures = new LinkedHashSet();
	for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
		GenNode nextNode = (GenNode) it.next();
		TypeModelFacet typeModelFacet = nextNode.getModelFacet();
		if (typeModelFacet == null) {
			continue;
		}
		GenFeature childMetaFeature = typeModelFacet.getChildMetaFeature();
		if (genChildFeatures.contains(childMetaFeature)) {
			continue;
		}
		genChildFeatures.add(childMetaFeature);
		if (!hasDeclaredFilter) {
			hasDeclaredFilter = true;
%>
			<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createFeatureFilter(<%=importManager.getImportedName(childMetaFeature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=childMetaFeature.getFeatureAccessorName()%>());
<%
		} else {
%>
			filter = filter.or(<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createFeatureFilter(<%=importManager.getImportedName(childMetaFeature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=childMetaFeature.getFeatureAccessorName()%>()));
<%
		}
	}	//for
%>
<%
	if (hasDeclaredFilter) {
%>
			filter = filter.and(<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getViewCode%>.getElement()));
<%
	} else {
		hasDeclaredFilter = true;
%>
			<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getViewCode%>.getElement());
<%
	}
%>
<%
	if (hasConstraintsInChildren) {
		if (hasDeclaredFilter) {
			hasDeclaredFilter = true;
%>
			filter = getConstrainedChildrenFilter().or(filter);
<%
		} else {
%>
			<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter = getConstrainedChildrenFilter();
<%
		}
	}
	if (!hasDeclaredFilter) {
%>
			<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.NOT_TOUCH;
<%
	}
%>
			return filter;
<%
}	//local declaration of hasDeclaredFilter
%>
		}

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.commands.CreateNotationalElementCommand")%> getCreateNotationalElementCommand(<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ElementDescriptor")%> descriptor) {
<%
{
	String _parentNode = "getHost()";
%>
<%@@include file="../common/createNotationalNodeCommand.jetinc" %>
<%
}
%>
		}

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("java.util.List")%> getSemanticChildNodes() {
<%@@ include file="../common/semanticChildren.jetinc" %>
		}

		/**
		 * Returns whether a notational element should be created for the given domain element. 
		 * The generated code always returns <%=genDiagram.isSynchronized()%>. 
		 * User can change implementation of this method to handle a more sophisticated logic.
		 * @@generated
		 */
		protected boolean shouldCreateView(<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.ElementDescriptor")%> descriptor) {
			return <%=genDiagram.isSynchronized()%>;
		}

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> getHost() {
			return <%=_getViewCode%>;
		}
	}

	/**
	 * @@generated
	 */
	protected void refreshNotationModel() {
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.canonical.AbstractNotationModelRefresher")%> childRefresher = getNotationModelRefresher();
		if (!childRefresher.isInstalled()) {
			return;
		}
		<%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> command = childRefresher.buildRefreshNotationModelCommand();
		if (command == null) {
			return;
		}
		<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> domainModelEditDomain = <%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(<%=_getDiagramCode%>.getElement());
		getViewer().getEditDomain().getCommandStack().execute(new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.commands.WrappingCommand")%>(domainModelEditDomain, command));
	}

@


1.6
log
@[157859] bblajer - Diagram initialization from pre-existing domain models
@
text
@@


1.5
log
@[155040] bblajer - Common Lite runtime functionality moved to dedicated plugin
@
text
@a142 3
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> domainElement = descriptor.getElement();
			int nodeVisualID = descriptor.getVisualID();
			switch (nodeVisualID) {
d144 2
a145 7
for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenNode nextNode = (GenNode) it.next();
	TypeModelFacet typeModelFacet = nextNode.getModelFacet();
	if (typeModelFacet == null) {
		continue;
	}
	String childNodeInterfaceName = importManager.getImportedName(nextNode.getDomainMetaClass().getQualifiedInterfaceName());
d147 1
a147 5
			case <%=importManager.getImportedName(nextNode.getEditPartQualifiedClassName())%>.VISUAL_ID:
				if (domainElement instanceof <%=childNodeInterfaceName%>) {
					return new Create<%=nextNode.getDomainMetaClass().getName()%><%=nextNode.getVisualID()%>NotationCommand(getHost(), domainElement<%if (!isListLayout) {%>, new Rectangle(0, 0, 0, 0)<%}%>);
				}
				return null;
a150 3
			default:
				return null;
			}
d157 1
a157 1
<%@@ include file="semanticChildren.jetinc" %>
@


1.4
log
@[152859] bblajer - add missing @@generated tags
@
text
@d5 1
a5 1
		NotationModelRefresher refresher = getNotationModelRefresher();
d24 1
a24 1
	private NotationModelRefresher notationModelRefresher;
d29 1
a29 1
	private NotationModelRefresher getNotationModelRefresher() {
d39 1
a39 16
	private class NotationModelRefresher extends <%=importManager.getImportedName("org.eclipse.emf.transaction.ResourceSetListenerImpl")%> {
		/**
		 * @@generated
		 */
		private <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> filter;
		/**
		 * @@generated
		 */
		private <%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> editingDomain;

		/**
		 * @@generated
		 */
		public NotationModelRefresher() {
			createFilter();
		}
d74 1
a74 1
		private void createFilter() {
d93 1
a93 1
			filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createFeatureFilter(<%=importManager.getImportedName(childMetaFeature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=childMetaFeature.getFeatureAccessorName()%>());
d108 1
d110 1
a110 1
			filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getViewCode%>.getElement());
a112 1
}	//local declaration of hasDeclaredFilter
d115 3
a117 1
if (hasConstraintsInChildren) {
d121 15
a135 1
}
d138 1
d142 23
a164 3
		public void install(<%=importManager.getImportedName("org.eclipse.emf.transaction.TransactionalEditingDomain")%> editingDomain) {
			if (this.editingDomain != null && !this.editingDomain.equals(editingDomain)) {
				throw new IllegalStateException("Already listening to another editing domain");
a165 2
			this.editingDomain = editingDomain;
			this.editingDomain.addResourceSetListener(this);
d171 2
a172 2
		public boolean isInstalled() {
			return editingDomain != null;
d176 3
d181 2
a182 5
		public void uninstall() {
			if (isInstalled()) {
				editingDomain.removeResourceSetListener(this);
				editingDomain = null;
			}
d188 2
a189 14
		public boolean isPrecommitOnly() {
			return true;
		}
		/**
		 * @@generated
		 */
		public <%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> transactionAboutToCommit(<%=importManager.getImportedName("org.eclipse.emf.transaction.ResourceSetChangeEvent")%> event) {
			return getRefreshNotationModelCommand();
		}
		/**
		 * @@generated
		 */
		public <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%> getFilter() {
			return filter;
d197 5
a201 1
		<%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> command = getRefreshNotationModelCommand();
d206 1
a206 39
		getViewer().getEditDomain().getCommandStack().execute(new WrappingCommand(domainModelEditDomain, command));
	}

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> getRefreshNotationModelCommand() {
		<%=importManager.getImportedName("java.util.List")%> semanticChildren = getSemanticChildren();
		<%=importManager.getImportedName("java.util.List")%> notationalChildren = <%=_getViewCode%>.getChildren();
		final <%=importManager.getImportedName("java.util.Map")%> semanticToNotational = new <%=importManager.getImportedName("java.util.HashMap")%>();
		for(<%=importManager.getImportedName("java.util.Iterator")%> it = notationalChildren.iterator(); it.hasNext(); ) {
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> next = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) it.next();
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> nextSemantic = next.getElement();
			if (nextSemantic != null) {
				semanticToNotational.put(nextSemantic, next);
			}
		}
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> parentView = <%=_getViewCode%>;
		<%=importManager.getImportedName("org.eclipse.emf.common.command.CompoundCommand")%> command = new <%=importManager.getImportedName("org.eclipse.emf.common.command.CompoundCommand")%>();
		for(<%=importManager.getImportedName("java.util.Iterator")%> it = semanticChildren.iterator(); it.hasNext(); ) {
			<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> next = (<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%>) it.next();
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> currentView = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) semanticToNotational.remove(next);
			int nodeVisualID = <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.INSTANCE.getNodeVisualID(parentView, next);
			if (currentView == null) {
				if (shouldCreateView(next)) {
					command.appendIfCanExecute(getCreateNotationalElementCommand(parentView, next, nodeVisualID));
				}
			} else if (nodeVisualID != <%=importManager.getImportedName(genDiagram.getVisualIDRegistryQualifiedClassName())%>.getVisualID(currentView)) {
				<%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".CreateNotationalElementCommand")%> notationalCommand = getCreateNotationalElementCommand(parentView, next, nodeVisualID);
				if (notationalCommand != null) {
					command.appendIfCanExecute(new <%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".ReplaceNotationalElementCommand")%>(parentView, notationalCommand, currentView));
				}
			}
		}
		for(<%=importManager.getImportedName("java.util.Iterator")%> it = semanticToNotational.values().iterator(); it.hasNext(); ) {
			<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> obsoleteView = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) it.next();
			command.appendIfCanExecute(new <%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".RemoveNotationalElementCommand")%>(parentView, obsoleteView));
		}
		return command.getCommandList().isEmpty() ? null : command;
a208 43
	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".CreateNotationalElementCommand")%> getCreateNotationalElementCommand(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> parentView, <%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> domainElement, int nodeVisualID) {
		switch (nodeVisualID) {
<%
for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenNode nextNode = (GenNode) it.next();
	TypeModelFacet typeModelFacet = nextNode.getModelFacet();
	if (typeModelFacet == null) {
		continue;
	}
	String childNodeInterfaceName = importManager.getImportedName(nextNode.getDomainMetaClass().getQualifiedInterfaceName());
%>
		case <%=importManager.getImportedName(nextNode.getEditPartQualifiedClassName())%>.VISUAL_ID:
			if (domainElement instanceof <%=childNodeInterfaceName%>) {
				return new Create<%=nextNode.getDomainMetaClass().getName()%><%=nextNode.getVisualID()%>NotationCommand(parentView, domainElement<%if (!isListLayout) {%>, new Rectangle(0, 0, 0, 0)<%}%>);
			}
			return null;
<%
}
%>
		default:
			return null;
		}
	}

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("java.util.List")%> getSemanticChildren() {
<%@@ include file="semanticChildren.jetinc" %>
	}

	/**
	 * Returns whether a notational element should be created for the given domain element. 
	 * The generated code always returns <%=genDiagram.isSynchronized()%>. 
	 * User can change implementation of this method to handle a more sophisticated logic.
	 * @@generated
	 */
	private boolean shouldCreateView(EObject domainElement) {
		return <%=genDiagram.isSynchronized()%>;
	}
@


1.3
log
@[bblajer] #152774 Compilable code when EClass has instance class attribute set
@
text
@d235 3
@


1.2
log
@[bblajer] #146009 Reflect changes in domain model links
@
text
@d120 1
a120 1
			filter = filter.and(<%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getSemanticElementCode%>));
d124 1
a124 1
			filter = <%=importManager.getImportedName("org.eclipse.emf.transaction.NotificationFilter")%>.createNotifierFilter(<%=_getSemanticElementCode%>);
@


1.1
log
@#146009 Lite Generator: Changes in the underlying domain model should be automatically reflected in the notational model
1,2,3 Parts commited.
@
text
@d91 16
a106 15
boolean hasDeclaredFilter = false;
Set genChildFeatures = new LinkedHashSet();
for (Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenNode nextNode = (GenNode) it.next();
	TypeModelFacet typeModelFacet = nextNode.getModelFacet();
	if (typeModelFacet == null) {
		continue;
	}
	GenFeature childMetaFeature = typeModelFacet.getChildMetaFeature();
	if (genChildFeatures.contains(childMetaFeature)) {
		continue;
	}
	genChildFeatures.add(childMetaFeature);
	if (!hasDeclaredFilter) {
		hasDeclaredFilter = true;
d110 1
a110 1
	} else {
d114 2
a115 2
	}
}	//for
d118 1
a118 1
if (hasDeclaredFilter) {
d122 1
a122 1
} else {
d126 2
a127 1
}
@


1.1.2.1
log
@[152859] bblajer - Lite Generator: All generated methods should be marked as @@generated
[152854] bblajer - Lite Generator: Allow shape nodes to be placed inside list-layout compartments
@
text
@a232 3
	/**
	 * @@generated
	 */
@


