head	1.24;
access;
symbols
	v20080910-1520:1.24
	v20070403-1500:1.23
	v20070330-1300:1.23
	v20060330-1300:1.23
	v20070322-1100:1.23
	v20060316-0600:1.23
	v20070307-0700:1.21
	v20070228-2000:1.19
	v20070221-1500:1.18
	v20070208-1800:1.18
	v20070103-0300:1.17
	M4_20:1.17
	v20061222-1800:1.17
	v20061214-0000:1.17
	v20061120-1300:1.16
	M3_20:1.16
	v20061117-0800:1.16
	v20061013-1330:1.13
	v20061005-1700:1.5
	M1_20:1.8
	v20060904-1500:1.8
	v20060824-1600:1.5
	v20060713-1700:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	v20060627-1200:1.5
	v20060626-1420:1.5
	v20060620-0400:1.5
	v20060616-1400:1.4
	v20060616-1200:1.4
	v20060609-1400:1.4
	v20060531-1730:1.4
	v20060530-1930:1.4
	v20060526-1200:1.4
	v20060519-1300:1.2
	v20060519-0800:1.2
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.24
date	2007.04.04.11.04.48;	author bblajer;	state dead;
branches;
next	1.23;
commitid	18c54613864d4567;

1.23
date	2007.03.15.16.43.30;	author bblajer;	state Exp;
branches;
next	1.22;
commitid	617845f977b04567;

1.22
date	2007.03.09.17.19.35;	author bblajer;	state Exp;
branches;
next	1.21;
commitid	22ed45f197244567;

1.21
date	2007.03.02.21.35.39;	author bblajer;	state Exp;
branches;
next	1.20;
commitid	403a45e898a74567;

1.20
date	2007.03.02.21.21.16;	author bblajer;	state Exp;
branches;
next	1.19;
commitid	2b1945e895484567;

1.19
date	2007.02.23.16.19.36;	author bblajer;	state Exp;
branches;
next	1.18;
commitid	496945df14164567;

1.18
date	2007.01.11.19.16.11;	author bblajer;	state Exp;
branches;
next	1.17;
commitid	6c2845a68cf94567;

1.17
date	2006.12.12.12.54.47;	author bblajer;	state Exp;
branches;
next	1.16;
commitid	355b457ea6574567;

1.16
date	2006.11.09.18.15.42;	author bblajer;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.31.15.58.12;	author bblajer;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.18.14.22.07;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.12.10.23.43;	author atikhomirov;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.09.17.03.14;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.11.15.45.01;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.06.20.09.23;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.04.19.27.26;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.01.16.14.08;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.04.17.05.48;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.02.10.43.51;	author atikhomirov;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.19.19.14.13;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.24.18.18.05;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.22.18.22.10;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.26.11.58.48;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.13.21.20.15;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.24
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.lite.parts" class="DiagramEditPartGenerator"
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.* java.util.* org.eclipse.emf.codegen.ecore.genmodel.*"%>
<%
GenDiagram genDiagram = (GenDiagram) ((Object[]) argument)[0];
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
importManager.registerInnerClass("NotationModelRefresher");	//from notationModelRefresher.jetinc
importManager.registerInnerClass("LinkNotationModelRefresher");	//from linkNotationModelRefresher.jetinc
importManager.registerInnerClass("TreeEditPartAdapter");
List childNodes = genDiagram.getTopLevelNodes();
%>

<%@@ include file="../common/featureGetAccessor.jetinc"%>

<%
class DiagramEditPartHelper {
	private final List myContainedFeatureModelFacetLinks = new LinkedList();
	private final List myContainedTypeModelFacetLinks = new LinkedList();
	public DiagramEditPartHelper(GenDiagram diagram) {
		for(Iterator it = diagram.getLinks().iterator(); it.hasNext(); ) {
			GenLink genLink = (GenLink)it.next();
			if (!genLink.isViewDirectionAlignedWithModel() || genLink.getModelFacet() == null) {
				continue;
			}
			GenClass containerClass;
			if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
				TypeLinkModelFacet modelFacet = (TypeLinkModelFacet) genLink.getModelFacet();
				if (modelFacet.getSourceMetaFeature() == null && modelFacet.getTargetMetaFeature() == null) {
					//if one link feature is null, the element is treated as this end of the link. If both are null, we cannot do anything about such a link.
					containerClass = null;
				} else {
					containerClass = modelFacet.getContainmentMetaFeature().getGenClass();
				}
			} else if (genLink.getModelFacet() instanceof FeatureLinkModelFacet) {
				GenFeature metaFeature = ((FeatureLinkModelFacet) genLink.getModelFacet()).getMetaFeature();
				containerClass = metaFeature.getGenClass();
			} else {
				continue;
			}
			if (containerClass.getEcoreClass().isSuperTypeOf(diagram.getDomainDiagramElement().getEcoreClass())) {
				if (genLink.getModelFacet() instanceof TypeLinkModelFacet) {
					myContainedTypeModelFacetLinks.add(genLink);
				} else {
					myContainedFeatureModelFacetLinks.add(genLink);
				}
			}
		}
	}

	public boolean containsLinks() {
		return containsFeatureModelFacetLinks() || containsTypeModelFacetLinks();
	}

	public boolean containsFeatureModelFacetLinks() {
		return !myContainedFeatureModelFacetLinks.isEmpty();
	}

	public boolean containsTypeModelFacetLinks() {
		return !myContainedTypeModelFacetLinks.isEmpty();
	}

	public Iterator getContainedFeatureModelFacetLinks() {
		return myContainedFeatureModelFacetLinks.iterator();
	}

	public Iterator getContainedTypeModelFacetLinks() {
		return myContainedTypeModelFacetLinks.iterator();
	}
}
final DiagramEditPartHelper myHelper = new DiagramEditPartHelper(genDiagram);
%>

<%
importManager.emitPackageStatement(stringBuffer);
importManager.addImport("org.eclipse.gef.editparts.AbstractGraphicalEditPart");
importManager.addImport("org.eclipse.draw2d.IFigure");
importManager.addImport("org.eclipse.draw2d.FreeformLayer");
importManager.addImport("org.eclipse.draw2d.FreeformLayout");
importManager.addImport("org.eclipse.draw2d.MarginBorder");
importManager.addImport("org.eclipse.gef.EditPolicy");
importManager.addImport("org.eclipse.draw2d.geometry.Dimension");
importManager.addImport("org.eclipse.draw2d.geometry.Point");
importManager.addImport("org.eclipse.gef.EditPart");
importManager.addImport("org.eclipse.gef.SnapToGrid");
importManager.addImport("org.eclipse.gef.SnapToHelper");
importManager.addImport("org.eclipse.gef.editpolicies.RootComponentEditPolicy");
importManager.addImport("org.eclipse.gef.requests.ChangeBoundsRequest");
importManager.addImport("org.eclipse.gef.requests.CreateRequest");
importManager.addImport("org.eclipse.gmf.runtime.notation.Bounds");
importManager.addImport("org.eclipse.gmf.runtime.notation.Diagram");
importManager.addImport("org.eclipse.gmf.runtime.notation.Node");
importManager.addImport("org.eclipse.gmf.runtime.notation.NotationPackage");
importManager.addImport("org.eclipse.gmf.runtime.notation.View");
importManager.addImport("java.util.List");

importManager.markImportLocation(stringBuffer);
%>

/**
 * @@generated
 */
public class <%=genDiagram.getEditPartClassName()%> extends AbstractGraphicalEditPart implements <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%> {
	/**
	 * @@generated
	 */
	public static String MODEL_ID = "<%=genDiagram.getEditorGen().getModelID()%>";

<%{
GenCommonBase genCommonBase = genDiagram;%>
<%@@ include file="visualID.jetinc"%>
<%}%>

	/**
	 * @@generated
	 */
	public <%=genDiagram.getEditPartClassName()%>(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Diagram")%> model) {
		setModel(model);
	}

	/**
	 * @@generated
	 */
	public <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Diagram")%> getDiagram() {
		return (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Diagram")%>) getModel();
	}

<%@@ include file="registerModel.jetinc"%>

	/**
	 * @@generated
	 */
	public void addNotify() {
		super.addNotify();
		getDiagram().eAdapters().add(getUpdateManager());
		getDiagram().getElement().eAdapters().add(domainModelRefresher);
	}

	/**
	 * @@generated
	 */
	protected void createEditPolicies() {
		installEditPolicy(EditPolicy.COMPONENT_ROLE, new RootComponentEditPolicy());
<%{
GenCommonBase genCommonBase = genDiagram;%>
<%@@ include file="layoutEditPolicy.jetinc"%>
<%@@ include file="customBehaviour.jetinc"%>
<%}%>
		installNotationModelRefresher();
<%
//link notation model refresher should always be installed for the diagram edit part, because it tracks the uncontained links
//if (myHelper.containsLinks()) {
%>
		installLinkNotationModelRefresher();
<%
//}
%>
	}

	/**
	 * @@generated
	 */
	protected IFigure createFigure() {
		IFigure f = new FreeformLayer();
		f.setBorder(new MarginBorder(5));
		f.setLayoutManager(new FreeformLayout());
		return f;
	}

	/**
	 * @@generated
	 */
	public Object getAdapter(Class key) {
		if (<%=importManager.getImportedName("org.eclipse.gef.SnapToHelper")%>.class == key) {
			return new <%=importManager.getImportedName("org.eclipse.gef.SnapToGrid")%>(this);
		}
		if (<%=importManager.getImportedName("org.eclipse.gef.TreeEditPart")%>.class == key) {
			return getTreeEditPartAdapter();
		}
<%/*@@ include file="adapters/propertySource.javajetinc"*/%>
		return super.getAdapter(key);
	}

	/**
	 * @@generated
	 */
	private TreeEditPartAdapter myTreeEditPartAdapter;

	/**
	 * @@generated
	 */
	private TreeEditPartAdapter getTreeEditPartAdapter() {
		if (myTreeEditPartAdapter == null) {
			myTreeEditPartAdapter = new TreeEditPartAdapter();
		}
		return myTreeEditPartAdapter;
	}

	/**
	 * @@generated
	 */
	protected List getModelChildren() {
		return getDiagram().getVisibleChildren();
	}

<%@@ include file="refresher.javajetinc"%>

	/**
	 * @@generated
	 */
	private void createRefreshers() {
		structuralFeatures2Refresher = new HashMap();
<%@@ include file="refreshers.javajetinc/children.javajetinc"%>
	}

	/**
	 * @@generated
	 */
	public void activate() {
		super.activate();
		if (!getDiagram().eAdapters().contains(getUpdateManager())) {
			getDiagram().eAdapters().add(getUpdateManager());
		}
		if (!getDiagram().getElement().eAdapters().contains(domainModelRefresher)) {
			getDiagram().getElement().eAdapters().add(domainModelRefresher);
		}
		installNotationModelRefresher();
<%
//link notation model refresher should always be installed for the diagram edit part, because it tracks the uncontained links
//if (myHelper.containsLinks()) {
%>
		installLinkNotationModelRefresher();
<%
//}
%>
	}

	/**
	 * @@generated
	 */
	public void deactivate() {
<%
//link notation model refresher should always be installed/uninstalled for the diagram edit part, because it tracks the uncontained links
//if (myHelper.containsLinks()) {
%>
		uninstallLinkNotationModelRefresher();
<%
//}
%>
		uninstallNotationModelRefresher();
		getDiagram().getElement().eAdapters().remove(domainModelRefresher);
		getDiagram().eAdapters().remove(getUpdateManager());
		super.deactivate();
	}

<%
{
String _getDiagramCode = "getDiagram()";
String _getViewCode = "getDiagram()";
boolean isListLayout = false;
final boolean _includeUncontainedLinks = true;
%>
<%@@ include file="notationModelRefresher.jetinc"%>

<%@@ include file="linkNotationModelRefresher.jetinc"%>
<%
}
%>

<%@@ include file="refreshers.javajetinc/domainModelRefresher.javajetinc"%>

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.UpdateManager")%> updateManager;

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.UpdateManager")%> getUpdateManager() {
		if (updateManager == null) {
			updateManager = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.UpdateManager")%>(getViewer());
		}
		return updateManager;
	}

	/**
	 * @@generated
	 */
	private class TreeEditPartAdapter extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.tree.BaseTreeEditPart")%> {
		/**
		 * @@generated
		 */
		public TreeEditPartAdapter() {
			super(getDiagram(), <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getItemProvidersAdapterFactory());
		}

		/**
		 * @@generated
		 */
		protected void createEditPolicies() {
			installEditPolicy(EditPolicy.COMPONENT_ROLE, new RootComponentEditPolicy());
		}

		/**
		 * @@generated
		 */
		public void activate() {
			super.activate();
			if (!getDiagram().eAdapters().contains(getTreeUpdateManager())) {
				getDiagram().eAdapters().add(getTreeUpdateManager());
			}
		}

		/**
		 * @@generated
		 */
		public void deactivate() {
			getDiagram().eAdapters().remove(getTreeUpdateManager());
			super.deactivate();
		}

		/**
		 * @@generated
		 */
		private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.UpdateManager")%> treeUpdateManager;

		/**
		 * @@generated
		 */
		private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.UpdateManager")%> getTreeUpdateManager() {
			if (treeUpdateManager == null) {
				treeUpdateManager = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.UpdateManager")%>(getViewer());
			}
			return treeUpdateManager;
		}
	}
}
<%importManager.emitSortedImports();%>
@


1.23
log
@[164018] Command generation seperated from Parts for commands that operate with labels;
API to display label text, apply modifications and update after (external) modifications isolated from generated code;
Moved as much common generated code as possible to BaseTreeEditPart;
[165700] Support diagrams in read-only mode: all EMF commands that are not composed of standard EMF commands, but modify EMF models directly should query the editing domain for read-onliness of the resource they operate on.
@
text
@@


1.22
log
@[164018]: Command generation separated from Parts for layout edit policy and graphical node edit policy;
NewDiagramFileWizard: layout is not persisted if the diagram is closed right after initialization
@
text
@a78 1
importManager.addImport("org.eclipse.gef.commands.Command");
a84 1
importManager.addImport("org.eclipse.gef.commands.UnexecutableCommand");
a310 3
			if (!getDiagram().getElement().eAdapters().contains(domainModelRefresher)) {
				getDiagram().getElement().eAdapters().add(domainModelRefresher);
			}
a316 1
			getDiagram().getElement().eAdapters().remove(domainModelRefresher);
a320 2
<%@@ include file="refreshers.javajetinc/domainModelRefresher.javajetinc"%>

@


1.21
log
@Generated diagram plugin should at least compile when there's a node with  an abstract underlying element.
@
text
@a143 52
		installEditPolicy(EditPolicy.LAYOUT_ROLE, new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.policies.XYLayoutEditPolicyEx")%>() {
			protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> getCreateCommand(CreateRequest request) {
<%if (null != genDiagram.getPalette()) {%>
				if (request instanceof <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.requests.CreateRequestEx")%>) {
					<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.requests.CreateRequestEx")%> requestEx = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.requests.CreateRequestEx")%>) request;
					if (!<%=importManager.getImportedName(genDiagram.getEditPartQualifiedClassName())%>.MODEL_ID.equals(requestEx.getModelID())) {
						return null;
					}
					int[] visualIds = requestEx.getVisualIds();
					<%=importManager.getImportedName("org.eclipse.emf.common.command.CompoundCommand")%> result = new <%=importManager.getImportedName("org.eclipse.emf.common.command.CompoundCommand")%>();
					for(int i = 0; i < visualIds.length; i++) {
						int nextVisualId = visualIds[i];
						switch (nextVisualId) {
<%
for(Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenTopLevelNode next = (GenTopLevelNode)it.next();
	if (next.isSansDomain() || next.getDomainMetaClass().isAbstract()) {
		continue;
	}
%>
						case <%=importManager.getImportedName(next.getEditPartQualifiedClassName())%>.VISUAL_ID:
							result.append(new <%=importManager.getImportedName(genDiagram.getEditCommandsPackageName() + ".Create" + next.getDomainMetaClass().getName() + next.getVisualID() + "Command")%>(getDiagram(), requestEx, (<%=importManager.getImportedName("org.eclipse.draw2d.geometry.Rectangle")%>)getConstraintFor(request)));
							break;
<%
}
%>
						}
					}
					return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.commands.WrappingCommand")%>(<%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(getDiagram().getElement()), result);
				}
<%}/*when there's palette*/%>
				return null;
			}
<%
{
	String _getViewCode = "getDiagram()";
	boolean isListLayout = false;
%>
<%@@include file="createAddCommand.jetinc"%>
<%@@include file="createCloneCommand.jetinc"%>
<%
}
%>
			protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> createChangeConstraintCommand(final <%=importManager.getImportedName("org.eclipse.gef.requests.ChangeBoundsRequest")%> request, final <%=importManager.getImportedName("org.eclipse.gef.EditPart")%> child, Object constraint) {
<%@@include file="changeConstraintCommand.jetinc"%>
			}
			protected <%=importManager.getImportedName("org.eclipse.gef.commands.Command")%> createChangeConstraintCommand(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> child, Object constraint) {
				assert false;
				return <%=importManager.getImportedName("org.eclipse.gef.commands.UnexecutableCommand")%>.INSTANCE;
			}
<%@@include file="preservePrimaryDragEditPolicy.jetinc"%>
		});
d146 1
@


1.20
log
@[164018]: Add<>Command and Clone<>Command moved to separate classes;
Common methods from edit policies moved to runtime superclasses
@
text
@d160 3
@


1.19
log
@ComponentEditPolicy separated into a top-level class;
CreateRequest now knows about the MODEL_ID;
All "Command" class references fully-qualified in templates to prevent compilation problems;
[170078]: Remove link with class from the domain model on deleting link's destination
@
text
@a12 1
<%@@ include file="../common/relatedNodesFinder.jetinc"%>
a85 1
importManager.addImport("org.eclipse.gef.editpolicies.RootComponentEditPolicy");
a87 1
importManager.addImport("org.eclipse.gef.editpolicies.XYLayoutEditPolicy");
d144 1
a144 1
		installEditPolicy(EditPolicy.LAYOUT_ROLE, new XYLayoutEditPolicy() {
@


1.18
log
@[170248]: Beautify compartments generated for the lite version
@
text
@d148 1
a148 1
			protected Command getCreateCommand(CreateRequest request) {
d152 3
d190 1
a190 1
			protected Command createChangeConstraintCommand(<%=importManager.getImportedName("org.eclipse.gef.EditPart")%> child, Object constraint) {
@


1.17
log
@[164018]: Command generation separated from editparts for link commands (createStart, complete, reconnectSource, reconnectTarget) and nodes (create)
@
text
@d191 1
@


1.16
log
@[162579] Support diagram partitioning
+
1. CustomBehaviours;
2. LayoutDiagramAction: execute the command through the command stack;
3. WrappingCommand: Workaround for a problem with StrictCompoundCommand.canExecute() in transactional editing domains
@
text
@d162 1
a162 1
							result.append(new Create<%=next.getDomainMetaClass().getName()%><%=next.getVisualID()%>Command(getDiagram(), requestEx, (<%=importManager.getImportedName("org.eclipse.draw2d.geometry.Rectangle")%>)getConstraintFor(request)));
a252 11
<%
for(Iterator it = childNodes.iterator(); it.hasNext(); ) {
	GenTopLevelNode next = (GenTopLevelNode)it.next();
	boolean isStatic = true;
	boolean isListLayout = false;
%>
<%@@ include file="createNodeCommand.javajetinc"%>
<%
}
%>

@


1.15
log
@[162778]: DiagramEditor fails trying to add a null child caused by reentrant calls to AbstractEditPart.refreshChildren.
Registering updateManager AFTER notationModelRefreshers have executed their operations fixes reentrance
@
text
@d192 4
@


1.14
log
@#161380 simplify feature model facets
@
text
@d137 1
a139 1
		super.addNotify();
@


1.13
log
@[160225] bblajer - Respect EStructuralFeature cardinality in commands that create/move/clone elements
@
text
@d34 2
a35 2
			} else if (genLink.getModelFacet() instanceof FeatureModelFacet) {
				GenFeature metaFeature = ((FeatureModelFacet) genLink.getModelFacet()).getMetaFeature();
@


1.12
log
@[160205] bblajer - move and clone elements on diagram
@
text
@a253 1
	String resolvedSemanticElement = "parent.getElement()";
@


1.11
log
@[156358] bblajer - Diagram overview with Lite runtime
@
text
@d13 1
d174 10
@


1.10
log
@[155955] bblajer -  Allow creation of child nodes directly in parent elements
@
text
@d8 1
d209 3
d219 15
d330 58
@


1.9
log
@clean compilation warnings
@
text
@d172 2
a173 38
			protected Command createChangeConstraintCommand(final ChangeBoundsRequest request, EditPart child, Object constraint) {
				final Node node = (Node) child.getModel();
				<%=importManager.getImportedName("org.eclipse.emf.common.command.Command")%> emfCommand = new <%=importManager.getImportedName("org.eclipse.emf.common.command.AbstractCommand")%>("Change node position/size") {
					private Point moveDelta;
					private Dimension resizeDelta;

					public boolean canUndo() {
						return canExecute();
					}
					protected boolean prepare() {
						if (node.getLayoutConstraint() instanceof Bounds == false) {
							return false;
						}
						Bounds bounds = (Bounds) node.getLayoutConstraint();
						<%=importManager.getImportedName("org.eclipse.draw2d.geometry.Rectangle")%> original = new <%=importManager.getImportedName("org.eclipse.draw2d.geometry.Rectangle")%>(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());
						<%=importManager.getImportedName("org.eclipse.draw2d.geometry.Rectangle")%> transformed = request.getTransformedRectangle(original);
						resizeDelta = transformed.getSize().expand(original.getSize().negate());
						moveDelta = transformed.getTopLeft().translate(original.getTopLeft().negate());
						return true;
					}
					public void undo() {
						execute(moveDelta.getNegated(), resizeDelta.getNegated());
					}
					public void execute() {
						execute(moveDelta, resizeDelta);
					}
					public void redo() {
						execute();
					}
					private void execute(Point move, Dimension resize) {
						Bounds bounds = (Bounds) node.getLayoutConstraint();
						bounds.setX(bounds.getX() + move.x);
						bounds.setY(bounds.getY() + move.y);
						bounds.setWidth(bounds.getWidth() + resize.width);
						bounds.setHeight(bounds.getHeight() + resize.height);
					}
				};
				return new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.commands.WrappingCommand")%>(<%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(getDiagram().getElement()), emfCommand);
d175 1
a175 1
			protected Command createChangeConstraintCommand(EditPart child, Object constraint) {
d177 1
a177 1
				return UnexecutableCommand.INSTANCE;
@


1.8
log
@[155040] bblajer - Common Lite runtime functionality moved to dedicated plugin
@
text
@d147 1
a147 2
<%if (null != genDiagram.getPalette()) {
final Palette palette = genDiagram.getPalette();%>
@


1.7
log
@[bblajer] #152774 Compilable code when EClass has instance class attribute set
@
text
@a7 1
importManager.registerInnerClass("LinkDescriptor");	//from linkNotationModelRefresher.jetinc
d104 1
a104 1
public class <%=genDiagram.getEditPartClassName()%> extends AbstractGraphicalEditPart implements IUpdatableEditPart {
d135 1
a135 1
		getDiagram().eAdapters().add(updateManager);
d149 2
a150 2
				if (request instanceof <%=importManager.getImportedName(palette.getFactoryQualifiedClassName())%>.CreateRequestEx) {
					<%=importManager.getImportedName(palette.getFactoryQualifiedClassName())%>.CreateRequestEx requestEx = (<%=importManager.getImportedName(palette.getFactoryQualifiedClassName())%>.CreateRequestEx) request;
d168 1
a168 1
					return new WrappingCommand(<%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(getDiagram().getElement()), result);
d210 1
a210 1
				return new WrappingCommand(<%=importManager.getImportedName("org.eclipse.emf.transaction.util.TransactionUtil")%>.getEditingDomain(getDiagram().getElement()), emfCommand);
a280 50
	private class UpdateManager extends <%=importManager.getImportedName("org.eclipse.emf.ecore.util.EContentAdapter")%> {
		/**
		 * @@generated
		 */
		public void notifyChanged(<%=importManager.getImportedName("org.eclipse.emf.common.notify.Notification")%> msg) {
			super.notifyChanged(msg);
			if (msg.isTouch()) {
				return;
			}
			<%=importManager.getImportedName("java.util.Collection")%> affectedEditParts = findAffectedParts(msg);
			for(<%=importManager.getImportedName("java.util.Iterator")%> it = affectedEditParts.iterator(); it.hasNext(); ) {
				IUpdatableEditPart next = (IUpdatableEditPart) it.next();
				IUpdatableEditPart.Refresher refresher = next.getRefresher((<%=importManager.getImportedName("org.eclipse.emf.ecore.EStructuralFeature")%>)msg.getFeature(), msg);
				if (refresher != null) {
					refresher.refresh();
				}
			}
		}

		/**
		 * @@generated
		 */
		private <%=importManager.getImportedName("java.util.Collection")%>/*<IUpdatableEditPart>*/ findAffectedParts(<%=importManager.getImportedName("org.eclipse.emf.common.notify.Notification")%> msg) {
			Object notifier = msg.getNotifier();
			if (notifier instanceof <%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%>) {
				<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> view = getView((EObject) notifier);
				if (view != null) {
					EditPart affectedEditPart = (EditPart) getViewer().getEditPartRegistry().get(view);
					if (affectedEditPart != null) {
						return <%=importManager.getImportedName("java.util.Collections")%>.singleton(affectedEditPart);
					}
				}
			}
			return <%=importManager.getImportedName("java.util.Collections")%>.EMPTY_LIST;
		}

		/**
		 * @@generated
		 */
		private <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> getView(EObject offspring) {
			while (offspring != null && offspring instanceof View == false) {
				offspring = offspring.eContainer();
			}
			return (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) offspring;
		}
	}

	/**
	 * @@generated
	 */
d283 2
a284 2
		if (!getDiagram().eAdapters().contains(updateManager)) {
			getDiagram().eAdapters().add(updateManager);
d314 1
a314 1
		getDiagram().eAdapters().remove(updateManager);
d337 11
a347 1
	private UpdateManager updateManager = new UpdateManager();
@


1.6
log
@[bblajer] #146009 Reflect changes in domain model links
@
text
@d5 1
a5 1
ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
d10 3
d14 1
a372 1
String _getSemanticElementCode = "getDiagram().getElement()";
@


1.5
log
@#146009 Lite Generator: Changes in the underlying domain model should be automatically reflected in the notational model
1,2,3 Parts commited.
@
text
@d7 2
d10 56
d126 11
d215 8
d330 6
a335 2
		getDiagram().eAdapters().add(updateManager);
		getDiagram().getElement().eAdapters().add(domainModelRefresher);
d337 8
d351 8
d371 1
d374 2
@


1.4
log
@[bblajer] #143168 Make Align actions work
@
text
@d6 2
d85 1
a85 1
for(Iterator it = genDiagram.getTopLevelNodes().iterator(); it.hasNext(); ) {
d145 1
d177 1
a177 1
for(Iterator it = genDiagram.getTopLevelNodes().iterator(); genDiagram.getPalette() != null && it.hasNext(); ) {
d255 1
d262 1
d268 12
@


1.3
log
@[bblajer] #138430 Lite Generator: Generated code should make use of emf.transaction API
@
text
@a15 1
importManager.addImport("org.eclipse.gef.commands.CompoundCommand");
d102 2
a103 2
					private Point moveDelta = request.getMoveDelta();
					private Dimension resizeDelta = request.getSizeDelta();
d108 10
a117 2
					public boolean canExecute() {
						return node.getLayoutConstraint() instanceof Bounds;
@


1.2
log
@[bblajer] #138415 Update Lite generator to use VISUAL_ID as view type scheme instead of annotations
@
text
@d79 1
a79 1
					CompoundCommand result = new CompoundCommand();
d88 1
a88 1
							result.add(new Create<%=next.getDomainMetaClass().getName()%><%=next.getVisualID()%>Command(getDiagram(), requestEx, (<%=importManager.getImportedName("org.eclipse.draw2d.geometry.Rectangle")%>)getConstraintFor(request)));
d95 1
a95 1
					return result.unwrap();
d102 1
a102 1
				return new Command("Change node position/size") {
d118 3
d129 1
@


1.1
log
@[bblajer] #136702 Code generation targeting pure-GEF runtime
@
text
@d46 10
d87 1
a87 1
						case <%=next.getVisualID()%>:
@

