head	1.18;
access;
symbols
	v20080910-1520:1.18
	v20070403-1500:1.17
	v20070330-1300:1.17
	v20060330-1300:1.17
	v20070322-1100:1.17
	v20060316-0600:1.17
	v20070307-0700:1.16
	v20070228-2000:1.15
	v20070221-1500:1.15
	v20070208-1800:1.15
	v20070103-0300:1.15
	M4_20:1.15
	v20061222-1800:1.15
	v20061214-0000:1.15
	v20061120-1300:1.15
	M3_20:1.15
	v20061117-0800:1.15
	v20061013-1330:1.11
	v20061005-1700:1.6
	M1_20:1.10
	v20060904-1500:1.10
	v20060824-1600:1.6
	v20060713-1700:1.6
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060626-1420:1.6
	v20060620-0400:1.5
	v20060616-1400:1.5
	v20060616-1200:1.5
	v20060609-1400:1.5
	v20060531-1730:1.4
	v20060530-1930:1.4
	v20060526-1200:1.4
	v20060519-1300:1.3
	v20060519-0800:1.3
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.18
date	2007.04.04.11.04.48;	author bblajer;	state dead;
branches;
next	1.17;
commitid	18c54613864d4567;

1.17
date	2007.03.15.16.43.30;	author bblajer;	state Exp;
branches;
next	1.16;
commitid	617845f977b04567;

1.16
date	2007.03.03.23.45.10;	author bblajer;	state Exp;
branches;
next	1.15;
commitid	2e3145ea08814567;

1.15
date	2006.11.09.18.15.42;	author bblajer;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.18.16.29.03;	author bblajer;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.18.09.56.59;	author dstadnik;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.17.13.08.27;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.11.15.45.01;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.01.16.14.09;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.04.17.05.48;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.02.10.43.51;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.03.18.07.48;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.21.15.22.43;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.08.16.01.40;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.22.18.22.10;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.15.11.19.18;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.26.11.58.48;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.13.21.20.15;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.18
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.lite.parts" class="LinkLabelEditPartGenerator"
	imports="org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.* java.util.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.emf.ecore.*"%>
<%
final GenCommonBase genElement = (GenCommonBase) ((Object[]) argument)[0];
final GenLinkLabel genLabel = (GenLinkLabel)genElement;
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
GenLink genHost = genLabel.getLink();
GenDiagram genDiagram = genLabel.getDiagram();
LabelModelFacet labelModelFacet = genLabel.getModelFacet();
GenClass underlyingMetaClass;
if (genHost.getModelFacet() instanceof TypeLinkModelFacet) {
	TypeLinkModelFacet typeLinkModelFacet = (TypeLinkModelFacet) genHost.getModelFacet();
	underlyingMetaClass = typeLinkModelFacet.getMetaClass();
} else if (genHost.getModelFacet() instanceof FeatureLinkModelFacet) {
	FeatureLinkModelFacet featureLinkModelFacet = (FeatureLinkModelFacet) genHost.getModelFacet();
	underlyingMetaClass = featureLinkModelFacet.getMetaFeature().getTypeGenClass();
} else {
	underlyingMetaClass = null;
}
final boolean isReadOnly = genLabel.isReadOnly();
%>
<%@@ include file="../copyright4java.jetinc"%>

<%@@ include file="../common/featureGetAccessor.jetinc"%>

<%importManager.emitPackageStatement(stringBuffer);
importManager.addImport("org.eclipse.draw2d.geometry.Point");
importManager.addImport("org.eclipse.gef.EditPart");
importManager.addImport("org.eclipse.gef.EditPolicy");
importManager.addImport("org.eclipse.gmf.runtime.notation.Location");
importManager.addImport("org.eclipse.gmf.runtime.notation.Node");
importManager.addImport("org.eclipse.gmf.runtime.notation.View");

importManager.markImportLocation(stringBuffer);
%>

/**
 * @@generated
 */
public class <%=genLabel.getEditPartClassName()%> extends <%=importManager.getImportedName("org.eclipse.gef.editparts.AbstractGraphicalEditPart")%> implements <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelController")%> {
<%{
GenCommonBase genCommonBase = genLabel;%>
<%@@ include file="visualID.jetinc"%>
<%}%>

<%@@ include file="textAwareFields.jetinc"%>

	/**
	 * @@generated
	 */
	public <%=genLabel.getEditPartClassName()%>(View view) {
		assert view instanceof Node;
		setModel(view);
	}

	/**
	 * @@generated
	 */
	private Node getDiagramNode() {
		return (Node)getModel();
	}

	/**
	 * @@generated
	 */
	protected void createEditPolicies() {
<%
final String primaryView = "getUpdatableParent().getDiagramEdge()";
final String resolvedSemanticElement = "resolveSemanticElement()";
%>
		installEditPolicy(EditPolicy.CONNECTION_ENDPOINTS_ROLE, new <%=importManager.getImportedName("org.eclipse.gef.editpolicies.ConnectionEndpointEditPolicy")%>() {
			public EditPart getHost() {
				return getUpdatableParent();
			}
		});
<%
if (labelModelFacet instanceof FeatureLabelModelFacet && !isReadOnly) {
%>
<%@@ include file="directEditPolicy.javajetinc"%>
<%
}
%>
<%{
GenCommonBase genCommonBase = genLabel;%>
<%@@ include file="customBehaviour.jetinc"%>
<%@@include file="openEditPolicy.jetinc"%>
<%}%>
	}

<%@@ include file="labelPerformRequest.jetinc"%>
<%
if (!isReadOnly) {
%>
<%@@ include file="directEdit.javajetinc"%>
<%
}
%>

	/**
	 * @@generated
	 */
	protected void refreshVisuals() {
		super.refreshVisuals();
		refreshLabel();
		refreshFont();
		refreshFontColor();
		refreshBounds();
	}

	/**
	 * @@generated
	 */
	protected void refreshBounds() {
		Node node = getDiagramNode();
		assert node.getLayoutConstraint() instanceof Location;
		final Location location = (Location) node.getLayoutConstraint();
		<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> parent = getUpdatableParent();
		<%=importManager.getImportedName("org.eclipse.draw2d.Connection")%> connection = (<%=importManager.getImportedName("org.eclipse.draw2d.Connection")%>) parent.getFigure();
<%
	final String alignment;
	LinkLabelAlignment genAlignment = genLabel.getAlignment();
	if (genAlignment == null) {
		alignment = "MIDDLE";
	} else {
		switch (genAlignment.getValue()) {
		case LinkLabelAlignment.MIDDLE:
			alignment = "MIDDLE";
			break;
		case LinkLabelAlignment.TARGET:
			alignment = "TARGET";
			break;
		case LinkLabelAlignment.SOURCE:
			alignment = "SOURCE";
			break;
		default:
			alignment = "MIDDLE";
			break;
		}
	}
%>
		((<%=importManager.getImportedName("org.eclipse.gef.GraphicalEditPart")%>) getParent()).setLayoutConstraint(this,
				getFigure(), new <%=importManager.getImportedName("org.eclipse.draw2d.ConnectionLocator")%>(connection, <%=importManager.getImportedName("org.eclipse.draw2d.ConnectionLocator")%>.<%=alignment%>) {
					protected <%=importManager.getImportedName("org.eclipse.draw2d.geometry.Point")%> getReferencePoint() {
						return super.getReferencePoint().translate(location.getX(), location.getY());
					}
				});
	}

	/**
	 * @@generated
	 */
	protected void refreshLabel() {
		getLabel().setText(getLabelText());
		getLabel().setIcon(getLabelIcon());
	}

<%@@ include file="labelText.javajetinc"%>
<%@@ include file="refreshMethods/font.javajetinc"%>
<%@@ include file="refreshMethods/fontColor.javajetinc"%>

	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.swt.graphics.Image")%> getLabelIcon() {
<%
if (genLabel.isElementIcon()) {
%>
		<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%> semanticElement = <%if (underlyingMetaClass.isExternalInterface()) {%>(<%=importManager.getImportedName("org.eclipse.emf.ecore.EObject")%>) <%}%>resolveSemanticElement();
		if (semanticElement != null) {
			return <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.getImage(semanticElement.eClass());
		}
<%
}
%>
		return null;
	}

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%> resolveSemanticElement() {
		<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> parent = getUpdatableParent();
		if (parent == null || parent.getModel() instanceof <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Edge")%> == false) {
			return null;
		}
<%
if (genHost.getModelFacet() instanceof TypeLinkModelFacet) {
%>
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> view = (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%>) parent.getModel();
		return (<%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%>) view.getElement();
<%
} else if (genHost.getModelFacet() instanceof FeatureLinkModelFacet) {
%>
		<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.View")%> target = ((<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Edge")%>) parent.getModel()).getTarget();
		return (target != null && target.getElement() instanceof <%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%>) ? (<%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%>) target.getElement() : null;
<%
} else {
%>
		return null;
<%
}
%>
	}

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> getUpdatableParent() {
		for(EditPart editPart = getParent(); editPart != null; editPart = editPart.getParent()) {
			if (editPart instanceof <%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%>) {
				return (<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%>) editPart;
			}
		}
		return null;
	}

	/**
	 * @@generated
	 */
	public void activate() {
		super.activate();
		<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> updatableParent = getUpdatableParent();
		if (updatableParent != null) {
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontColor(), fontColorRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontHeight(), fontRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontName(), fontRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_Bold(), fontRefresher);
			updatableParent.addRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_Italic(), fontRefresher);
			updatableParent.addExternalRefresher(getLabelRefresher());
		}
	}

	/**
	 * @@generated
	 */
	public void deactivate() {
		super.deactivate();
		<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> updatableParent = getUpdatableParent();
		if (updatableParent != null) {
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontColor(), fontColorRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontHeight(), fontRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_FontName(), fontRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_Bold(), fontRefresher);
			updatableParent.removeRefresher(<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.NotationPackage")%>.eINSTANCE.getFontStyle_Italic(), fontRefresher);
			updatableParent.removeExternalRefresher(getLabelRefresher());
		}
	}

<%@@ include file="refreshers.javajetinc/labelRefresher.jetinc"%>

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher fontColorRefresher = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher() {
		public void refresh() {
			refreshFontColor();
		}
	};

	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher fontRefresher = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher() {
		public void refresh() {
			refreshFont();
		}
	};

<%
final Viewmap viewmap = genLabel.getViewmap();
%>
<%@@ include file="labelFigure.jetinc"%>
}
<%importManager.emitSortedImports();%>
@


1.17
log
@[164018] Command generation seperated from Parts for commands that operate with labels;
API to display label text, apply modifications and update after (external) modifications isolated from generated code;
Moved as much common generated code as possible to BaseTreeEditPart;
[165700] Support diagrams in read-only mode: all EMF commands that are not composed of standard EMF commands, but modify EMF models directly should query the editing domain for read-onliness of the resource they operate on.
@
text
@@


1.16
log
@Images should be reused across the editparts that represent same model element types (prevent SWTErrors when opening huge diagrams)
@
text
@d40 1
a40 1
public class <%=genLabel.getEditPartClassName()%> extends <%=importManager.getImportedName("org.eclipse.gef.editparts.AbstractGraphicalEditPart")%> {
a77 1
		String editPatternCode = "EDIT_PATTERN";	//declared in labelText.javajetinc, used in directEditCommand.jetinc.
d229 1
a229 11
<%
if (labelModelFacet instanceof FeatureLabelModelFacet) {
	FeatureLabelModelFacet featureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = featureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
		GenFeature next = (GenFeature) it.next();
%>
			updatableParent.addRefresher(<%=importManager.getImportedName(next.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=next.getFeatureAccessorName()%>(), labelRefresher);
<%
	}
}
%>
d245 1
a245 11
<%
if (labelModelFacet instanceof FeatureLabelModelFacet) {
	FeatureLabelModelFacet featureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = featureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
		GenFeature next = (GenFeature) it.next();
%>
			updatableParent.removeRefresher(<%=importManager.getImportedName(next.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=next.getFeatureAccessorName()%>(), labelRefresher);
<%
	}
}
%>
d249 1
a249 9
	/**
	 * @@generated
	 */
	private <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher labelRefresher = new <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>.Refresher() {
		public void refresh() {
			refreshLabel();
		}
	};

@


1.15
log
@[162579] Support diagram partitioning
+
1. CustomBehaviours;
2. LayoutDiagramAction: execute the command through the command stack;
3. WrappingCommand: Workaround for a problem with StrictCompoundCommand.canExecute() in transactional editing domains
@
text
@d169 3
a171 3
		<%=importManager.getImportedName("org.eclipse.jface.resource.ImageDescriptor")%> imageDescriptor = <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getItemImageDescriptor(resolveSemanticElement());
		if (imageDescriptor != null) {
			return imageDescriptor.createImage();
@


1.14
log
@Fix compilation problems introduced by recent fix of https://bugs.eclipse.org/bugs/show_bug.cgi?id=161380
@
text
@d84 5
d91 1
d93 1
a93 1
if (labelModelFacet instanceof FeatureLabelModelFacet && !isReadOnly) {
@


1.13
log
@#161380 move readOnly back to GenLabel
@
text
@d77 1
a77 1
if (labelModelFacet instanceof FeatureLabelModelFacet || labelModelFacet instanceof CompositeFeatureLabelModelFacet && !isReadOnly) {
d87 1
a87 1
if (labelModelFacet instanceof FeatureLabelModelFacet || labelModelFacet instanceof CompositeFeatureLabelModelFacet && !isReadOnly) {
d226 2
a227 7
	GenFeature feature = ((FeatureLabelModelFacet)labelModelFacet).getMetaFeature();
%>
			updatableParent.addRefresher(<%=importManager.getImportedName(feature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=feature.getFeatureAccessorName()%>(), labelRefresher);
<%
} else if (labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	CompositeFeatureLabelModelFacet compositeFeatureLabelModelFacet = (CompositeFeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = compositeFeatureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
d252 2
a253 7
	GenFeature feature = ((FeatureLabelModelFacet)labelModelFacet).getMetaFeature();
%>
			updatableParent.removeRefresher(<%=importManager.getImportedName(feature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=feature.getFeatureAccessorName()%>(), labelRefresher);
<%
} else if (labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	CompositeFeatureLabelModelFacet compositeFeatureLabelModelFacet = (CompositeFeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = compositeFeatureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
@


1.12
log
@#160894 Move readOnly property from GenLabel to LabelFeatureModelFacet
@
text
@d20 1
a20 1
final boolean isReadOnly = genLabel.getModelFacet() != null && genLabel.getModelFacet().isReadOnly();
@


1.11
log
@[156358] bblajer - Diagram overview with Lite runtime
@
text
@d20 1
a20 1
final boolean isReadOnly = genLabel.isReadOnly();
@


1.10
log
@[155040] bblajer - Common Lite runtime functionality moved to dedicated plugin
@
text
@d78 1
@


1.9
log
@[bblajer] #152774 Compilable code when EClass has instance class attribute set
@
text
@d276 1
a276 1
	private IUpdatableEditPart.Refresher labelRefresher = new IUpdatableEditPart.Refresher() {
d286 1
a286 1
	private IUpdatableEditPart.Refresher fontColorRefresher = new IUpdatableEditPart.Refresher() {
d295 1
a295 1
	private IUpdatableEditPart.Refresher fontRefresher = new IUpdatableEditPart.Refresher() {
@


1.8
log
@[bblajer] #146009 Reflect changes in domain model links
@
text
@d6 1
a6 1
ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
d23 3
@


1.7
log
@#149455 Lite Generation: Respect option for labels to display node icon
@
text
@d173 3
a175 5
		for(EditPart editPart = this; editPart != null; editPart = editPart.getParent()) {
			View view = (View)editPart.getModel();
			if (view != null && view.getElement() != null) {
				return (<%=importManager.getImportedName(underlyingMetaClass.getQualifiedInterfaceName())%>) view.getElement();
			}
d177 13
d191 3
@


1.6
log
@[mgolubev] #147853 Fonts defined in the gmfgraph model should be used by the generated labels
@
text
@d145 1
d155 17
@


1.5
log
@[bblajer] #146004 Lite Generator: Respect link label alignment
@
text
@d4 2
a5 1
GenLinkLabel genLabel = (GenLinkLabel) ((Object[]) argument)[0];
@


1.4
log
@[bblajer] #138430 Lite Generator: Generated code should make use of emf.transaction API
@
text
@d107 24
d132 1
a132 1
				getFigure(), new <%=importManager.getImportedName("org.eclipse.draw2d.AbstractLocator")%>() {
d134 1
a134 5
						<%=importManager.getImportedName(genHost.getEditPartQualifiedClassName())%> parent = getUpdatableParent();
						<%=importManager.getImportedName("org.eclipse.draw2d.Connection")%> connection = (<%=importManager.getImportedName("org.eclipse.draw2d.Connection")%>) parent.getFigure();
						<%=importManager.getImportedName("org.eclipse.draw2d.geometry.Point")%> midPoint = connection.getPoints().getMidpoint().getCopy();
						connection.translateToAbsolute(midPoint);
						return midPoint.translate(new <%=importManager.getImportedName("org.eclipse.draw2d.geometry.Point")%>(location.getX(), location.getY()));
@


1.3
log
@[bblajer] #141280 Support child nodes without label
@
text
@d19 1
d73 1
a73 2
if (labelModelFacet instanceof FeatureLabelModelFacet == true || labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	boolean isReadOnly = genLabel.isReadOnly();
d82 1
a82 1
if (labelModelFacet instanceof FeatureLabelModelFacet == true || labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
@


1.2
log
@[bblajer] #138415 Update Lite generator to use VISUAL_ID as view type scheme instead of annotations
@
text
@d73 1
d245 3
@


1.1
log
@[bblajer] #136702 Code generation targeting pure-GEF runtime
@
text
@d36 5
@

