head	1.19;
access;
symbols
	v20080910-1520:1.19
	v20070403-1500:1.18
	v20070330-1300:1.18
	v20060330-1300:1.18
	v20070322-1100:1.18
	v20060316-0600:1.18
	v20070307-0700:1.17
	v20070228-2000:1.15
	v20070221-1500:1.15
	v20070208-1800:1.15
	v20070103-0300:1.15
	M4_20:1.15
	v20061222-1800:1.15
	v20061214-0000:1.15
	v20061120-1300:1.15
	M3_20:1.15
	v20061117-0800:1.15
	v20061013-1330:1.10
	v20061005-1700:1.5
	M1_20:1.9
	v20060904-1500:1.9
	v20060824-1600:1.5
	v20060713-1700:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	v20060627-1200:1.5
	v20060626-1420:1.5
	v20060620-0400:1.4
	v20060616-1400:1.4
	v20060616-1200:1.4
	v20060609-1400:1.4
	v20060531-1730:1.4
	v20060530-1930:1.4
	v20060526-1200:1.4
	v20060519-1300:1.3
	v20060519-0800:1.3
	v20060512-1000:1.2
	I20060512-1000:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.19
date	2007.04.04.11.04.48;	author bblajer;	state dead;
branches;
next	1.18;
commitid	18c54613864d4567;

1.18
date	2007.03.15.16.43.30;	author bblajer;	state Exp;
branches;
next	1.17;
commitid	617845f977b04567;

1.17
date	2007.03.05.12.58.41;	author bblajer;	state Exp;
branches;
next	1.16;
commitid	437c45ec14004567;

1.16
date	2007.03.03.23.45.10;	author bblajer;	state Exp;
branches;
next	1.15;
commitid	2e3145ea08814567;

1.15
date	2006.11.09.18.15.42;	author bblajer;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.18.16.29.03;	author bblajer;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.18.14.35.15;	author dstadnik;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.18.09.56.59;	author dstadnik;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.17.13.08.27;	author dstadnik;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.11.15.45.01;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.01.16.14.09;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.04.17.05.48;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.02.10.43.51;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.03.18.07.48;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.21.15.22.44;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.22.18.22.10;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.15.11.19.18;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.26.11.58.48;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.13.21.20.15;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.19
log
@[176696]: InitDiagramContents: do not create notational edges to and from child label nodes;
Rewrite editpart templates in xpt;
Unify what is refreshed for each edit part type;
Preparation for side-affixed elements.
@
text
@<%@@ jet package="org.eclipse.gmf.codegen.templates.lite.parts" class="ChildNodeEditPartGenerator"
	imports="java.util.* org.eclipse.gmf.codegen.gmfgen.* org.eclipse.gmf.common.codegen.* org.eclipse.emf.codegen.ecore.genmodel.* org.eclipse.emf.ecore.*"%>
<%
final GenCommonBase genElement = (GenCommonBase) ((Object[]) argument)[0];
final GenChildLabelNode genChildNode = (GenChildLabelNode)genElement;
GenNode genHost = genChildNode;
GenNode genNode = genChildNode;	/*var used by componentEditPolicy.javajetinc*/
GenClass underlyingMetaClass = genHost.getDomainMetaClass();
GenDiagram genDiagram = genChildNode.getDiagram();
final ImportAssistant importManager = (ImportAssistant) ((Object[]) argument)[1];
LabelModelFacet labelModelFacet = genChildNode.getLabelModelFacet();
final boolean isReadOnly = genChildNode.isLabelReadOnly();
%>
<%@@ include file="../copyright4java.jetinc"%>

<%@@ include file="../common/featureGetAccessor.jetinc"%>

<%importManager.emitPackageStatement(stringBuffer);
importManager.registerInnerClass("TreeEditPartAdapter");

importManager.addImport("org.eclipse.gef.EditPolicy");
importManager.addImport("org.eclipse.gef.Request");
importManager.addImport("org.eclipse.gmf.runtime.notation.View");
importManager.addImport("org.eclipse.gmf.runtime.notation.NotationPackage");
importManager.addImport("java.util.List");

importManager.markImportLocation(stringBuffer);
%>

/**
 * @@generated
 */
public class <%=genChildNode.getEditPartClassName()%> extends <%=importManager.getImportedName("org.eclipse.gef.editparts.AbstractGraphicalEditPart")%> implements <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%>, <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart")%>, <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelController")%> {
<%{
GenCommonBase genCommonBase = genChildNode;%>
<%@@ include file="visualID.jetinc"%>
<%}%>

<%@@ include file="textAwareFields.jetinc"%>

	/**
	 * @@generated
	 */
	public <%=genChildNode.getEditPartClassName()%>(View view) {
		setModel(view);
	}

	/**
	 * @@generated
	 */
	public <%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Node")%> getDiagramNode() {
		return (<%=importManager.getImportedName("org.eclipse.gmf.runtime.notation.Node")%>) getModel();
	}

<%@@ include file="registerModel.jetinc"%>

	/**
	 * @@generated
	 */
	protected void createEditPolicies() {
<%
	String resolvedSemanticElement = "(" + importManager.getImportedName(genHost.getDomainMetaClass().getQualifiedInterfaceName()) + ") getDiagramNode().getElement()";
	final String primaryView = "getDiagramNode()";
%>
<%
if (!isReadOnly) {
%>
<%@@ include file="directEditPolicy.javajetinc"%>
<%
}
%>
<%@@ include file="componentEditPolicy.javajetinc"%>
<%{
GenCommonBase genCommonBase = genChildNode;%>
<%@@ include file="customBehaviour.jetinc"%>
<%@@include file="openEditPolicy.jetinc"%>
<%}%>
	}

<%@@ include file="labelPerformRequest.jetinc"%>
<%
if (!isReadOnly) {
%>
<%@@ include file="directEdit.javajetinc"%>
<%
}
%>
<%@@ include file="refreshers.javajetinc/external.jetinc"%>
	/**
	 * @@generated
	 */
	protected List getModelChildren() {
		return ((View)getModel()).getVisibleChildren();
	}

	/**
	 * @@generated
	 */
	protected List getModelSourceConnections() {
		return ((View)getModel()).getSourceEdges();
	}

	/**
	 * @@generated
	 */
	protected List getModelTargetConnections() {
		return ((View)getModel()).getTargetEdges();
	}

	/**
	 * @@generated
	 */
	protected void refreshVisuals() {
		super.refreshVisuals();
		refreshLabel();
		refreshFont();
		refreshFontColor();
		refreshVisibility();
	}

	/**
	 * @@generated
	 */
	protected void refreshLabel() {
		getLabel().setText(getLabelText());
		getLabel().setIcon(getLabelIcon());
	}
<%@@ include file="labelText.javajetinc"%>
<%@@ include file="refreshMethods/font.javajetinc"%>
<%@@ include file="refreshMethods/fontColor.javajetinc"%>

	/**
	 * @@generated
	 */
	protected <%=importManager.getImportedName("org.eclipse.swt.graphics.Image")%> getLabelIcon() {
<%
if (genChildNode.isLabelElementIcon()) {
%>
		return <%=importManager.getImportedName(genDiagram.getElementTypesQualifiedClassName())%>.getImage(getDiagramNode().getElement().eClass());
<%
} else {
%>
		return null;
<%
}
%>
	}

	/**
	 * @@generated
	 */
	protected void refreshVisibility() {
		boolean isVisible = getDiagramNode().isVisible();
		boolean wasVisible = getFigure().isVisible();
		if (isVisible == wasVisible) {
			return;
		}
		if (!isVisible && (getSelected() != SELECTED_NONE)) {
			getViewer().deselect(this);
		}

		getFigure().setVisible(isVisible);
		getFigure().revalidate();
	}

	/**
	 * @@generated
	 */
	public Object getAdapter(Class key) {
		if (<%=importManager.getImportedName("org.eclipse.gef.TreeEditPart")%>.class == key) {
			return getTreeEditPartAdapter();
		}
<%/*@@ include file="adapters/propertySource.javajetinc"*/%>
		return super.getAdapter(key);
	}

	/**
	 * @@generated
	 */
	private TreeEditPartAdapter myTreeEditPartAdapter;

	/**
	 * @@generated
	 */
	private TreeEditPartAdapter getTreeEditPartAdapter() {
		if (myTreeEditPartAdapter == null) {
			myTreeEditPartAdapter = new TreeEditPartAdapter();
		}
		return myTreeEditPartAdapter;
	}

	/**
	 * @@generated
	 */
	public void activate() {
		super.activate();
		addExternalRefresher(getLabelRefresher());
		getDiagramNode().getElement().eAdapters().add(domainModelRefresher);
	}

	/**
	 * @@generated
	 */
	public void deactivate() {
		getDiagramNode().getElement().eAdapters().remove(domainModelRefresher);
		removeExternalRefresher(getLabelRefresher());
		super.deactivate();
	}

<%@@ include file="refreshers.javajetinc/domainModelRefresher.javajetinc"%>

<%@@ include file="refresher.javajetinc"%>

<%@@ include file="refreshers.javajetinc/labelRefresher.jetinc"%>

	/**
	 * @@generated
	 */
	private void createRefreshers() {
		structuralFeatures2Refresher = new HashMap();
<%@@ include file="refreshers.javajetinc/children.javajetinc"%>
<%@@ include file="refreshers.javajetinc/visibility.javajetinc"%>
<%@@ include file="refreshers.javajetinc/font.javajetinc"%>
<%@@ include file="refreshers.javajetinc/fontColor.javajetinc"%>
	}

<%
final Viewmap viewmap = genChildNode.getViewmap();
%>
<%@@ include file="labelFigure.jetinc"%>

	/**
	 * @@generated
	 */
	private class TreeEditPartAdapter extends <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.tree.BaseTreeEditPart")%> {
		/**
		 * @@generated
		 */
		public TreeEditPartAdapter() {
			super(getDiagramNode(), <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getItemProvidersAdapterFactory());
		}

		/**
		 * @@generated
		 */
		protected void createEditPolicies() {
<%@@ include file="treeComponentEditPolicy.javajetinc"%>
<%
if (!isReadOnly) {
%>
<%@@ include file="directEditPolicy.javajetinc"%>
<%
}
%>
		}

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelTextDisplayer")%> createLabelTextDisplayer() {
			return <%=genChildNode.getEditPartClassName()%>.this.getLabelTextDisplayer();
		}

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("org.eclipse.swt.graphics.Image")%> getImage() {
			return getLabelIcon();
		}

		/**
		 * @@generated
		 */
		protected <%=importManager.getImportedName("java.util.List")%> getModelChildren() {
			return <%=importManager.getImportedName("java.util.Collections")%>.EMPTY_LIST;
		}
	}
}
<%importManager.emitSortedImports();%>
@


1.18
log
@[164018] Command generation seperated from Parts for commands that operate with labels;
API to display label text, apply modifications and update after (external) modifications isolated from generated code;
Moved as much common generated code as possible to BaseTreeEditPart;
[165700] Support diagrams in read-only mode: all EMF commands that are not composed of standard EMF commands, but modify EMF models directly should query the editing domain for read-onliness of the resource they operate on.
@
text
@@


1.17
log
@[176362]: ClassCastException while selecting items in tree outline of the generated diagram + test to reproduce;
ComponentEditPolicy.xpt: replace int constant with a reference thereto to facilitate readability
@
text
@d33 1
a33 1
public class <%=genChildNode.getEditPartClassName()%> extends <%=importManager.getImportedName("org.eclipse.gef.editparts.AbstractGraphicalEditPart")%> implements <%=importManager.getImportedName("org.eclipse.gmf.runtime.lite.edit.parts.update.IUpdatableEditPart")%> {
a66 1
		String editPatternCode = "EDIT_PATTERN";	//declared in labelText.javajetinc, used in directEditCommand.jetinc.
d88 1
d197 1
d206 1
d214 2
a222 16
		Refresher labelRefresher = new Refresher() {
			public void refresh() {
				refreshLabel();
			}
		};
<%
if (labelModelFacet instanceof FeatureLabelModelFacet) {
	FeatureLabelModelFacet featureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = featureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
		GenFeature next = (GenFeature) it.next();
%>
			structuralFeatures2Refresher.put(<%=importManager.getImportedName(next.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=next.getFeatureAccessorName()%>(), labelRefresher);
<%
	}
}
%>
a249 1
		String editPatternCode = "EDIT_PATTERN";	//declared in labelText.javajetinc, used in directEditCommand.jetinc.
d251 1
a251 1
<%@@ include file="treeDirectEditPolicy.jetinc"%>
a256 50
<%@@include file="treeDirectEdit.jetinc" %>

		/**
		 * @@generated
		 */
		protected String getEditText() {
			return getLabelEditText();
		}

		/**
		 * @@generated
		 */
		public void activate() {
			super.activate();
			getDiagramNode().getElement().eAdapters().add(domainModelRefresher);
		}

		/**
		 * @@generated
		 */
		public void deactivate() {
			getDiagramNode().getElement().eAdapters().remove(domainModelRefresher);
			super.deactivate();
		}

<%@@ include file="refreshers.javajetinc/domainModelRefresher.javajetinc"%>

		/**
		 * @@generated
		 */
		protected void createRefreshers() {
			super.createRefreshers();
			Refresher labelRefresher = new Refresher() {
				public void refresh() {
					refreshVisuals();
				}
			};
<%
if (labelModelFacet instanceof FeatureLabelModelFacet) {
	FeatureLabelModelFacet featureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = featureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
		GenFeature next = (GenFeature) it.next();
%>
			registerRefresher(<%=importManager.getImportedName(next.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=next.getFeatureAccessorName()%>(), labelRefresher);
<%
	}
}
%>
		}

d260 2
a261 2
		protected String getText() {
			return getLabelText();
a271 1
		 * Since compartments and labels are not selectable edit parts, they are filtered from the overview as well.
@


1.16
log
@Images should be reused across the editparts that represent same model element types (prevent SWTErrors when opening huge diagrams)
@
text
@d259 1
a259 1
<%@@ include file="componentEditPolicy.javajetinc"%>
@


1.15
log
@[162579] Support diagram partitioning
+
1. CustomBehaviours;
2. LayoutDiagramAction: execute the command through the command stack;
3. WrappingCommand: Workaround for a problem with StrictCompoundCommand.canExecute() in transactional editing domains
@
text
@d139 5
a143 4
		<%=importManager.getImportedName("org.eclipse.jface.resource.ImageDescriptor")%> imageDescriptor = <%=importManager.getImportedName(genDiagram.getEditorGen().getPlugin().getActivatorQualifiedClassName())%>.getInstance().getItemImageDescriptor(getDiagramNode().getElement());
		if (imageDescriptor != null) {
			return imageDescriptor.createImage();
		}
a146 1
		return null;
d328 7
@


1.14
log
@Fix compilation problems introduced by recent fix of https://bugs.eclipse.org/bugs/show_bug.cgi?id=161380
@
text
@d74 5
d81 1
@


1.13
log
@#161380 simplify feature model facets
@
text
@d220 2
a221 2
	FeatureLabelModelFacet compositeFeatureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = compositeFeatureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
d303 2
a304 2
	FeatureLabelModelFacet compositeFeatureLabelModelFacet = (FeatureLabelModelFacet) labelModelFacet;
	for(Iterator it = compositeFeatureLabelModelFacet.getMetaFeatures().iterator(); it.hasNext(); ) {
@


1.12
log
@#161380 move readOnly back to GenLabel
@
text
@d220 1
a220 6
	GenFeature feature = ((FeatureLabelModelFacet)labelModelFacet).getMetaFeature();
%>
			structuralFeatures2Refresher.put(<%=importManager.getImportedName(feature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=feature.getFeatureAccessorName()%>(), labelRefresher);
<%
} else if (labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	CompositeFeatureLabelModelFacet compositeFeatureLabelModelFacet = (CompositeFeatureLabelModelFacet) labelModelFacet;
d303 1
a303 6
	GenFeature feature = ((FeatureLabelModelFacet)labelModelFacet).getMetaFeature();
%>
			registerRefresher(<%=importManager.getImportedName(feature.getGenPackage().getQualifiedPackageInterfaceName())%>.eINSTANCE.get<%=feature.getFeatureAccessorName()%>(), labelRefresher);
<%
} else if (labelModelFacet instanceof CompositeFeatureLabelModelFacet) {
	CompositeFeatureLabelModelFacet compositeFeatureLabelModelFacet = (CompositeFeatureLabelModelFacet) labelModelFacet;
@


1.11
log
@#160894 Move readOnly property from GenLabel to LabelFeatureModelFacet
@
text
@d12 1
a12 1
final boolean isReadOnly = genChildNode.getLabelModelFacet() != null && genChildNode.getLabelModelFacet().isReadOnly();
@


1.10
log
@[156358] bblajer - Diagram overview with Lite runtime
@
text
@d12 1
a12 1
final boolean isReadOnly = genChildNode.isLabelReadOnly();
@


1.9
log
@[155040] bblajer - Common Lite runtime functionality moved to dedicated plugin
@
text
@d19 1
a60 1
		//XXX: install correct edit policies!
d67 1
d164 3
d174 15
d242 97
@


1.8
log
@[bblajer] #152774 Compilable code when EClass has instance class attribute set
@
text
@d32 1
a32 1
public class <%=genChildNode.getEditPartClassName()%> extends <%=importManager.getImportedName("org.eclipse.gef.editparts.AbstractGraphicalEditPart")%> implements IUpdatableEditPart {
@


1.7
log
@[bblajer] #146009 Reflect changes in domain model links
@
text
@d16 2
@


1.6
log
@#149455 Lite Generation: Respect option for labels to display node icon
@
text
@d52 2
@


1.5
log
@[mgolubev] #147853 Fonts defined in the gmfgraph model should be used by the generated labels
@
text
@d125 10
@


1.4
log
@[bblajer] #138430 Lite Generator: Generated code should make use of emf.transaction API
@
text
@d4 2
a5 1
GenChildLabelNode genChildNode = (GenChildLabelNode) ((Object[]) argument)[0];
@


1.3
log
@[bblajer] #141280 Support child nodes without label
@
text
@d11 1
d61 1
a61 2
{
boolean isReadOnly = genChildNode.isLabelReadOnly();
d70 3
d74 3
a76 1

@


1.2
log
@[bblajer] #138415 Update Lite generator to use VISUAL_ID as view type scheme instead of annotations
@
text
@d4 1
a4 2
GenNode genChildNode = (GenNode) ((Object[]) argument)[0];
GenNodeLabel genLabel = (GenNodeLabel) genChildNode.getLabels().get(0);
d10 1
a10 1
LabelModelFacet labelModelFacet = genLabel.getModelFacet();
d59 4
d64 3
d199 3
@


1.1
log
@[bblajer] #136702 Code generation targeting pure-GEF runtime
@
text
@d30 5
@

