head	1.12;
access;
symbols
	v20080813-1520:1.12
	v20080722-1827:1.12
	v20080716-1600:1.12
	v20080716-1642:1.12
	R2_1_maintenance:1.12.0.4
	Root_R2_1_maintenance:1.12
	R2_1_0:1.12
	v20080610-1132:1.12
	v20080528-1052:1.12
	v20080425-1959:1.12
	v20080417-1610:1.12
	v20080322-0000:1.12
	v20080222-1200:1.12
	v20070809-0000:1.12
	R2_0_maintenance:1.12.0.2
	R2_0:1.12
	R4_20:1.12
	v20070621-0000:1.12
	RC3_20:1.12
	v20070614-1400:1.12
	v20070608-1300:1.11
	v20070601-1400:1.11
	v20070520-1200:1.11
	v20070518-1300:1.11
	v20070504-1000:1.10
	v20070427-0600:1.10
	v20070420-1000:1.10
	v20070403-1500:1.10
	v20070330-1300:1.10
	v20060316-0600:1.10
	v20070208-1800:1.9
	M4_20:1.9
	v20061214-0000:1.9
	M3_20:1.9
	v20061117-0800:1.9
	v20061013-1330:1.7
	M1_20:1.7
	v20060904-1500:1.7
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060609-1400:1.6
	v20060531-1730:1.6
	v20060519-1300:1.5
	v20060519-0800:1.4
	v20060512-1000:1.4
	I20060512-1000:1.4
	I20060505-1400:1.2
	I20060428-1300:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.12
date	2007.06.09.16.16.15;	author ashatalin;	state Exp;
branches;
next	1.11;
commitid	2e3466ad24f4567;

1.11
date	2007.05.10.17.12.28;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	23424643527b4567;

1.10
date	2007.03.14.13.00.14;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	12fa45f7f1db4567;

1.9
date	2006.10.23.17.50.16;	author dstadnik;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.17.10.29.44;	author radvorak;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.12.15.53.55;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.31.15.48.07;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.19.16.01.46;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.11.16.57.54;	author ashatalin;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.11.12.17.24;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.27.11.26.56;	author ashatalin;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.26.17.55.01;	author ashatalin;	state Exp;
branches;
next	;


desc
@@


1.12
log
@[150117] - GMFMAP: List of available elements for "Domain meta information -> Element" should be restricted
@
text
@/*
 * Copyright (c) 2006, 2007 Borland Software Corp
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    vano - initial API and implementation
 */
package org.eclipse.gmf.mappings.presentation;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.gmf.mappings.CanvasMapping;
import org.eclipse.gmf.mappings.ChildReference;
import org.eclipse.gmf.mappings.CompartmentMapping;
import org.eclipse.gmf.mappings.FeatureInitializer;
import org.eclipse.gmf.mappings.FeatureSeqInitializer;
import org.eclipse.gmf.mappings.LinkMapping;
import org.eclipse.gmf.mappings.Mapping;
import org.eclipse.gmf.mappings.MappingEntry;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.NodeReference;
import org.eclipse.gmf.mappings.TopNodeReference;

public class FilterUtil {

	public static <T> List<T> sort(Collection<T> eObjects) {
		ArrayList<T> result = new ArrayList<T>(eObjects);
		Collections.sort(result, new EObjectsComparator());
		return result;
	}

	public static <T extends EObject> List<T> filterByResourceSet(Collection<T> eClasses, ResourceSet resourceSet) {
		return sort(filterValidEObjectsFrom(eClasses, resourceSet));
	}

	public static List<EClass> filterByContainmentFeature(Collection<EClass> eClasses, MappingEntry mappingEntry) {
		EClass superType = null;
		if (mappingEntry instanceof NodeMapping) {
			NodeReference nodeReference = (NodeReference) mappingEntry.eContainer();
			if (nodeReference != null) {
				EReference modelReference = nodeReference.getChildrenFeature() != null ? nodeReference.getChildrenFeature() : nodeReference.getContainmentFeature();
				if (modelReference != null) {
					superType = modelReference.getEReferenceType();
				}
			}
		} else if (mappingEntry instanceof LinkMapping) {
			if (((LinkMapping) mappingEntry).getContainmentFeature() != null) {
				superType = ((LinkMapping) mappingEntry).getContainmentFeature().getEReferenceType();
			}
		}
		return sort(getConcreteEClasses(getSubtypesOf(filterValidEObjectsFrom(eClasses, mappingEntry.eResource().getResourceSet()), superType)));
	}

	public static List<EStructuralFeature> filterByContainerMetaclass(Collection<EStructuralFeature> eReferences, MappingEntry mappingEntry) {
		EClass containerMetaClass = mappingEntry.getDomainMetaElement();
		return sort(getEStructuralFeaturesOf(eReferences, containerMetaClass));
	}

	public static List<EReference> filterByContainerMetaclass(Collection<EReference> eReferences, NodeReference nodeReference, boolean containmentOnly) {
		EClass containerMetaClass = null;
		EClass targetMetaClass = null;
		if (nodeReference instanceof ChildReference) {
			containerMetaClass = ((ChildReference) nodeReference).getParentNode().getDomainMetaElement();
		} else if (nodeReference instanceof TopNodeReference) {
			CanvasMapping diagram = ((Mapping) nodeReference.eContainer()).getDiagram();
			if (diagram != null) {
				containerMetaClass = diagram.getDomainMetaElement();
			}
		}
		if (nodeReference.isSetChild()) {
			targetMetaClass = nodeReference.getChild().getDomainMetaElement();
		}
		List<EReference> fromHierarchy = sort(getEReferences(getEStructuralFeaturesOf(eReferences, containerMetaClass), containmentOnly));
		if (targetMetaClass == null) {
			// no child known, thus can take references from metaelement's hierarchy only
			return fromHierarchy;
		}
		List<EReference> targetsToChild = sort(getEReferences(getEReferencesOfType(eReferences, targetMetaClass), containmentOnly));
		for (Iterator<EReference> it = targetsToChild.iterator(); it.hasNext();) {
			if (fromHierarchy.contains(it.next())) {
				it.remove();
			}
		}
		ArrayList<EReference> rv = new ArrayList<EReference>(fromHierarchy.size() + targetsToChild.size());
		rv.addAll(fromHierarchy);
		rv.addAll(targetsToChild);
		return rv;
	}

	public static List<EReference> filterByReferenceType(Collection<EReference> eReferences, LinkMapping linkMapping) {
		EClass referenceType = linkMapping.getDomainMetaElement();
		return sort(getEReferences(getEReferencesOfType(eReferences, referenceType), true));
	}

	public static Collection<EObject> filterByNodeMapping(Collection<EObject> childReferences, CompartmentMapping mapping) {
		return sort(getChildrenOf(childReferences, mapping.getParentNode(), false));
	}
	
	public static Collection<EObject> filterByNodeMapping(Collection<EObject> compartments, ChildReference childReference) {
		return getChildrenOf(compartments, childReference.getParentNode(), true);
	}
	
	public static Collection<?> filterBySuperClasses(Collection<?> instances, Class<?>[] classes) {
		return sort(getSubClassesOf(instances, classes));
	}
	
	public static Collection<EStructuralFeature> filterByFeatureInitializer(Collection<EStructuralFeature> features, FeatureInitializer featureInitializer) {
		if(featureInitializer.getFeatureSeqInitializer() == null ||
			featureInitializer.getFeatureSeqInitializer().getElementClass() == null) {
			return features;
		}
		EClass eClass = featureInitializer.getFeatureSeqInitializer().getElementClass();		
		List<EStructuralFeature> result = new ArrayList<EStructuralFeature>(getEStructuralFeaturesOf(features, eClass));
		for (Iterator<EStructuralFeature> it = result.iterator(); it.hasNext();) {
			EStructuralFeature nextFeature = it.next();
			if(nextFeature == null || !nextFeature.isChangeable()) {
				it.remove();
			}
		}
		return result;
	}
	
	public static Collection<EClass> filterByFeatureSeqInitializer(Collection<EClass> eClasses, FeatureSeqInitializer featureSeqInitializer) {
		if(featureSeqInitializer.getCreatingInitializer() != null) {
			EStructuralFeature feature = featureSeqInitializer.getCreatingInitializer().getFeature();
			if(feature != null && feature.getEType() instanceof EClass) {
				for (Iterator<EClass> it = eClasses.iterator(); it.hasNext();) {
					EClass nextEClass = it.next();
					EClass typeEClass = (EClass)feature.getEType();
					if(nextEClass == null || nextEClass.isAbstract() || nextEClass.isInterface() || !typeEClass.isSuperTypeOf(nextEClass)) {
						it.remove();
					}
				}
			}
		} else if(featureSeqInitializer.getElementClass() != null) {
			return Collections.singleton(featureSeqInitializer.getElementClass());
		} 
				
		return eClasses;
	}	

	private static Collection<EClass> getSubtypesOf(Collection<EClass> eClasses, EClass superType) {
		if (superType == null) {
			return eClasses;
		}
		for (Iterator<EClass> it = eClasses.iterator(); it.hasNext();) {
			EClass nextEClass = it.next();
			if (nextEClass != null && !superType.isSuperTypeOf(nextEClass)) {
				it.remove();
			}
		}
		return eClasses;
	}
	
	private static Collection<EClass> getConcreteEClasses(Collection<EClass> eClasses) {
		for (Iterator<EClass> it = eClasses.iterator(); it.hasNext();) {
			EClass nextEClass = it.next();
			if (nextEClass != null && (nextEClass.isAbstract() || nextEClass.isInterface())) {
				it.remove();
			}
			
		}
		return eClasses;
	}

	private static Collection<EReference> getEReferences(Collection<EReference> eReferences, boolean containmentOnly) {
		if (!containmentOnly) {
			return eReferences;
		}
		for (Iterator<EReference> it = eReferences.iterator(); it.hasNext();) {
			EReference nextReference = it.next();
			if (nextReference != null && !nextReference.isContainment()) {
				it.remove();
			}
		}
		return eReferences;
	}

	private static <T extends EStructuralFeature> Collection<T> getEStructuralFeaturesOf(Collection<T> structuralFeatures, EClass featureContainerEClass) {
		Collection<T> result = getValidEStructuralFeatures(structuralFeatures);
		if (featureContainerEClass == null) {
			return result;
		}
		for (Iterator<T> it = result.iterator(); it.hasNext();) {
			EStructuralFeature nextFeature = it.next();
			if (nextFeature != null && !nextFeature.getEContainingClass().isSuperTypeOf(featureContainerEClass)) {
				it.remove();
			}
		}
		return result;
	}

	private static Collection<EReference> getEReferencesOfType(Collection<EReference> references, EClass referenceType) {
		Collection<EReference> result = getValidEStructuralFeatures(references);
		if (referenceType == null) {
			return result;
		}
		for (Iterator<EReference> it = result.iterator(); it.hasNext();) {
			EReference nextFeature = it.next();
			if (nextFeature != null && !nextFeature.getEReferenceType().isSuperTypeOf(referenceType)) {
				it.remove();
			}
		}
		return result;
	}

	private static <T extends EStructuralFeature> Collection<T> getValidEStructuralFeatures(Collection<T> structuralFeatures) {
		Collection<T> result = getValidEObjects(structuralFeatures);
		for (Iterator<T> it = result.iterator(); it.hasNext();) {
			EStructuralFeature nextFeature = it.next();
			if (nextFeature != null && (nextFeature.getEContainingClass() == null)) {
				it.remove();
			}
		}
		return result;
	}

	private static <T extends EObject> Collection<T> filterValidEObjectsFrom(Collection<T> eClasses, ResourceSet resourceSet) {
		Collection<T> result = getValidEObjects(eClasses);
		for (Iterator<T> it = result.iterator(); it.hasNext();) {
			EObject nextEClass = it.next();
			if (nextEClass == null) {
				continue;
			}
			if (nextEClass.eResource().getResourceSet() != resourceSet) {
				it.remove();
			}
		}
		return result;
	}

	private static <T extends EObject> Collection<T> getValidEObjects(Collection<T> eObjects) {
		LinkedList<T> result = new LinkedList<T>();
		for (T nextEObject : eObjects) {
			if (nextEObject != null && (nextEObject.eContainer() == null)) {
				continue;
			}
			result.add(nextEObject);
		}
		return result;
	}
	
	private static <T extends EObject> Collection<T> getChildrenOf(Collection<T> elements, EObject container, boolean addNull) {
		LinkedList<T> result = new LinkedList<T>();
		for (T nextEObject : elements) {
			if (nextEObject == null ? addNull : nextEObject.eContainer() == container) {
				result.add(nextEObject);
			}
		}
		return result;
	}

	private static Collection<?> getSubClassesOf(Collection<?> instances, Class<?>[] classes) {
		LinkedList<Object> result = new LinkedList<Object>();
		for (Object nextInstance : instances) {
			for (int i = 0; i < classes.length; i++) {
				if (nextInstance == null || classes[i].isAssignableFrom(nextInstance.getClass())) {
					result.add(nextInstance);
					break;
				}
			}
		}
		return result;
	}
	
	private static class EObjectsComparator implements Comparator<Object> {

		public int compare(Object o1, Object o2) {
			if (o1 instanceof EObject && o2 instanceof EObject) {
				EObject firstEObject = (EObject) o1;
				EObject secondEObject = (EObject) o2;
				return compareLabels(firstEObject, secondEObject);
			}
			return compareObjects(o1, o2);
		}

		private int compareObjects(Object o1, Object o2) {
			if (o1 == null) {
				return o2 == null ? 0 : 1;
			} else {
				return o2 == null ? -1 : 0;
			}
		}

		private int compareLabels(EObject firstEObject, EObject secondEObject) {
			String firstLabel = getLabel(firstEObject);
			String secondLabel = getLabel(secondEObject);
			return firstLabel == null ? (secondLabel == null ? 0 : 1) : (secondLabel == null ? -1 : firstLabel.compareTo(secondLabel));
		}

		private String getLabel(EObject eObject) {
			AdapterFactory adapterFactory = getAdapterFactory(eObject);
			if (adapterFactory == null) {
				return "";
			}
			IItemLabelProvider itemLabelProvider = (IItemLabelProvider) adapterFactory.adapt(eObject, IItemLabelProvider.class);
			return itemLabelProvider != null ? itemLabelProvider.getText(eObject) : eObject == null ? "" : eObject.toString();
		}

		private AdapterFactory getAdapterFactory(EObject eObject) {
			EditingDomain editingDomain = AdapterFactoryEditingDomain.getEditingDomainFor(eObject);
			if (editingDomain instanceof AdapterFactoryEditingDomain) {
				return ((AdapterFactoryEditingDomain) editingDomain).getAdapterFactory();
			}
			return null;
		}

	}

}
@


1.11
log
@avoid java5 warnings
@
text
@d70 1
a70 1
		return sort(getSubtypesOf(filterValidEObjectsFrom(eClasses, mappingEntry.eResource().getResourceSet()), superType));
d173 11
@


1.10
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@a35 1
import org.eclipse.gmf.mappings.LabelMapping;
d51 2
a52 2
	public static <T> List<T> filterByResourceSet(Collection<T> eClasses, ResourceSet resourceSet) {
		return sort(getValidEClassesFrom(eClasses, resourceSet));
d55 1
a55 1
	public static List filterByContainmentFeature(Collection eClasses, MappingEntry mappingEntry) {
d70 1
a70 1
		return sort(getSubtypesOf(getValidEClassesFrom(eClasses, mappingEntry.eResource().getResourceSet()), superType));
d73 1
a73 1
	public static List filterByContainerMetaclass(Collection eReferences, LinkMapping mappingEntry) {
d78 1
a78 11
	public static List filterByContainerMetaclass(Collection eAttributes, LabelMapping labelMapping) {
		EClass containerMetaClass = labelMapping.getMapEntry().getDomainMetaElement();
		return sort(getEStructuralFeaturesOf(eAttributes, containerMetaClass));
	}
	
	public static List filterByContainerMetaclass(Collection eAttributes, MappingEntry mappingEntry) {
		EClass containerMetaClass = mappingEntry.getDomainMetaElement();
		return sort(getEStructuralFeaturesOf(eAttributes, containerMetaClass));
	}

	public static List filterByContainerMetaclass(Collection eReferences, NodeReference nodeReference, boolean containmentOnly) {
d92 1
a92 3
		// XXX hmm, outcome from getEStructuralFeaturesOf passed to getEReferences - 
		// neither implementation filters out elements of other types. just assumes and casts 
		List fromHierarchy = sort(getEReferences(getEStructuralFeaturesOf(eReferences, containerMetaClass), containmentOnly));
d97 2
a98 2
		List targetsToChild = sort(getEReferences(getEReferencesOfType(eReferences, targetMetaClass), containmentOnly));
		for (Iterator it = targetsToChild.iterator(); it.hasNext();) {
d103 1
a103 1
		ArrayList rv = new ArrayList(fromHierarchy.size() + targetsToChild.size());
d109 1
a109 1
	public static List filterByReferenceType(Collection eReferences, LinkMapping linkMapping) {
d114 1
a114 1
	public static Collection filterByNodeMapping(Collection childReferences, CompartmentMapping mapping) {
d118 1
a118 1
	public static Collection filterByNodeMapping(Collection compartments, ChildReference childReference) {
d122 1
a122 1
	public static Collection filterBySuperClasses(Collection instances, Class[] classes) {
d146 2
a147 2
				for (Iterator it = eClasses.iterator(); it.hasNext();) {
					EClass nextEClass = (EClass) it.next();
d161 1
a161 1
	private static Collection getSubtypesOf(Collection eClasses, EClass superType) {
d165 2
a166 2
		for (Iterator it = eClasses.iterator(); it.hasNext();) {
			EClass nextEClass = (EClass) it.next();
d174 1
a174 1
	private static Collection getEReferences(Collection eReferences, boolean containmentOnly) {
d178 2
a179 2
		for (Iterator it = eReferences.iterator(); it.hasNext();) {
			EReference nextReference = (EReference) it.next();
d187 2
a188 2
	private static Collection getEStructuralFeaturesOf(Collection structuralFeatures, EClass featureContainerEClass) {
		Collection result = getValidEStructuralFeatures(structuralFeatures);
d192 2
a193 2
		for (Iterator it = result.iterator(); it.hasNext();) {
			EStructuralFeature nextFeature = (EStructuralFeature) it.next();
d201 2
a202 2
	private static Collection getEReferencesOfType(Collection references, EClass referenceType) {
		Collection result = getValidEStructuralFeatures(references);
d206 2
a207 2
		for (Iterator it = result.iterator(); it.hasNext();) {
			EReference nextFeature = (EReference) it.next();
d215 4
a218 4
	private static Collection<EStructuralFeature> getValidEStructuralFeatures(Collection structuralFeatures) {
		Collection result = getValidEObjects(structuralFeatures);
		for (Iterator it = result.iterator(); it.hasNext();) {
			EStructuralFeature nextFeature = (EStructuralFeature) it.next();
d226 4
a229 4
	private static <T> Collection<T> getValidEClassesFrom(Collection<T> eClasses, ResourceSet resourceSet) {
		Collection result = getValidEObjects(eClasses);
		for (Iterator it = result.iterator(); it.hasNext();) {
			EClass nextEClass = (EClass) it.next();
d240 3
a242 4
	private static Collection<EObject> getValidEObjects(Collection<?> eObjects) {
		LinkedList<EObject> result = new LinkedList<EObject>();
		for (Iterator it = eObjects.iterator(); it.hasNext();) {
			EObject nextEObject = (EObject) it.next();
d251 3
a253 4
	private static Collection getChildrenOf(Collection elements, EObject container, boolean addNull) {
		List result = new ArrayList();
		for (Iterator it = elements.iterator(); it.hasNext();) {
			EObject nextEObject = (EObject) it.next();
d261 3
a263 4
	private static Collection getSubClassesOf(Collection instances, Class[] classes) {
		List result = new ArrayList();
		for (Iterator it = instances.iterator(); it.hasNext();) {
			Object nextInstance = it.next();
@


1.9
log
@prevent NPE
@
text
@d1 2
a2 2
/**
 * Copyright (c) 2006 Eclipse.org
d19 1
d46 3
a48 5
	private static Comparator EOBJECTS_COMPARATOR = new EObjectsComparator();

	public static List sort(Collection eObjects) {
		List result = new ArrayList(eObjects);
		Collections.sort(result, EOBJECTS_COMPARATOR);
d52 1
a52 1
	public static List filterByResourceSet(Collection eClasses, ResourceSet resourceSet) {
d228 1
a228 1
	private static Collection getValidEStructuralFeatures(Collection structuralFeatures) {
d239 1
a239 1
	private static Collection getValidEClassesFrom(Collection eClasses, ResourceSet resourceSet) {
d253 2
a254 2
	private static Collection getValidEObjects(Collection eObjects) {
		List result = new ArrayList();
d290 1
a290 1
	private static class EObjectsComparator implements Comparator {
@


1.8
log
@[161201] Restrict ItemPropertyDescriptor.getChoiceOfValues for ElementInitializer related editing in gmfmap.edit
@
text
@d61 5
a65 3
			EReference modelReference = nodeReference.getChildrenFeature() != null ? nodeReference.getChildrenFeature() : nodeReference.getContainmentFeature();
			if (modelReference != null) {
				superType = modelReference.getEReferenceType();
@


1.7
log
@#144197 [gmfmap] Only creation and custom tools should be available in dropdown menu of the node and link mapping Tool property
@
text
@d33 2
d137 35
@


1.6
log
@#144694 gmfmap editor: Show EClasses from all the loaded ecore model in meta-element choosers for Node/CanvasMappings
@
text
@d131 4
d238 14
@


1.5
log
@#128013 let user choose not only features from domain element's hierarchy, but also those that target specified child
@
text
@a23 1
import org.eclipse.emf.ecore.EPackage;
d26 1
d51 2
a52 2
	public static List filterByModel(Collection eClasses, CanvasMapping canvasMapping) {
		return sort(getValidEClassesFrom(eClasses, canvasMapping.getDomainModel()));
a56 1
		CanvasMapping canvasMapping = null;
a62 1
			canvasMapping = getMapping(nodeReference).getDiagram();
a66 1
			canvasMapping = ((Mapping) mappingEntry.eContainer()).getDiagram();
d68 1
a68 1
		return sort(getSubtypesOf(getValidEClassesFrom(eClasses, canvasMapping != null ? canvasMapping.getDomainModel() : null), superType));
d197 1
a197 1
	private static Collection getValidEClassesFrom(Collection eClasses, EPackage ePackage) {
a198 3
		if (ePackage == null) {
			return result;
		}
d204 1
a204 4
			EPackage eClassPackage = nextEClass.getEPackage();
			for (; eClassPackage != null && eClassPackage != ePackage; eClassPackage = eClassPackage.getESuperPackage()) {
			}
			if (eClassPackage == null) {
a221 7

	private static Mapping getMapping(NodeReference nodeReference) {
		if (nodeReference instanceof TopNodeReference) {
			return (Mapping) nodeReference.eContainer();
		}
		return getMapping((NodeReference) ((ChildReference) nodeReference).getParentNode().eContainer());
	}
@


1.4
log
@Filtering out unnecessary compartments.
@
text
@d91 1
d100 20
a119 1
		return sort(getEReferences(getEStructuralFeaturesOf(eReferences, containerMetaClass), containmentOnly));
@


1.3
log
@Corercting property sheet for LabelNodeMappings
@
text
@d108 5
a112 1
		return sort(getChildReferencesOf(childReferences, mapping.getParentNode()));
d218 2
a219 2

	private static Collection getChildReferencesOf(Collection childReferences, NodeMapping parentNode) {
d221 4
a224 4
		for (Iterator it = childReferences.iterator(); it.hasNext();) {
			ChildReference nextChildReference = (ChildReference) it.next();
			if (nextChildReference != null && nextChildReference.getParentNode() == parentNode) {
				result.add(nextChildReference);
@


1.2
log
@#119034 Show only valid feature in "containment feature" property of ChildNodeMapping
#138606 hide inappropriate entries in selection dialogs
@
text
@d50 1
a50 1
	
d83 5
d183 7
a189 1
			if (nextEClass != null && nextEClass.getEPackage() != ePackage) {
a195 1

d207 1
a207 1
	
@


1.1
log
@#119034 Show only valid feature in "containment feature" property of ChildNodeMapping
#138606 hide inappropriate entries in selection dialogs
@
text
@d24 1
d27 2
a28 1
import org.eclipse.emf.edit.provider.ComposedAdapterFactory;
a29 3
import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;
import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;
import org.eclipse.gmf.gmfgraph.provider.GMFGraphItemProviderAdapterFactory;
a39 2
import org.eclipse.gmf.mappings.provider.GMFMapItemProviderAdapterFactory;
import org.eclipse.gmf.tooldef.provider.GMFToolItemProviderAdapterFactory;
d45 2
a46 2
	public static List sort(Collection eNamedElements) {
		List result = new ArrayList(eNamedElements);
d50 4
d57 1
d64 1
d69 1
d71 1
a71 1
		return sort(getSubtypesOf(eClasses, superType));
a109 1
		Collection result = new ArrayList();
d112 2
a113 2
			if (nextEClass == null || superType.isSuperTypeOf(nextEClass)) {
				result.add(nextEClass);
d116 1
a116 1
		return result;
d161 2
a162 2
		List result = new ArrayList();
		for (Iterator it = structuralFeatures.iterator(); it.hasNext();) {
d165 26
d193 1
a193 1
			result.add(nextFeature);
d197 7
d209 1
a209 1
			if (nextChildReference.getParentNode() == parentNode) {
a217 2
		private AdapterFactory myAdapterFactory;

d251 5
a255 15
			if (myAdapterFactory == null) {
				List factories = new ArrayList();
				factories.add(new ResourceItemProviderAdapterFactory());
				factories.add(new GMFMapItemProviderAdapterFactory());
				factories.add(new GMFGraphItemProviderAdapterFactory());
				factories.add(new GMFToolItemProviderAdapterFactory());
				factories.add(new ReflectiveItemProviderAdapterFactory());
				myAdapterFactory = new ComposedAdapterFactory(factories);
			}
			return myAdapterFactory;
//			EditingDomain editingDomain = AdapterFactoryEditingDomain.getEditingDomainFor(eObject);
//			if (editingDomain instanceof AdapterFactoryEditingDomain) {
//				return ((AdapterFactoryEditingDomain) editingDomain).getAdapterFactory();
//			}
//			return null;
@

