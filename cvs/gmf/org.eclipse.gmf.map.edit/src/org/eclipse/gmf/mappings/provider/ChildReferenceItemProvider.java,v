head	1.14;
access;
symbols
	v20080813-1520:1.14
	v20080722-1827:1.14
	v20080716-1600:1.14
	v20080716-1642:1.14
	R2_1_maintenance:1.14.0.2
	Root_R2_1_maintenance:1.14
	R2_1_0:1.14
	v20080610-1132:1.14
	v20080528-1052:1.14
	v20080425-1959:1.14
	v20080417-1610:1.14
	v20080322-0000:1.14
	v20080222-1200:1.13
	v20070809-0000:1.13
	R2_0_maintenance:1.13.0.2
	R2_0:1.13
	R4_20:1.13
	v20070621-0000:1.13
	RC3_20:1.13
	v20070614-1400:1.13
	v20070608-1300:1.13
	v20070601-1400:1.13
	v20070520-1200:1.13
	v20070518-1300:1.13
	v20070504-1000:1.12
	v20070427-0600:1.12
	v20070420-1000:1.12
	v20070403-1500:1.12
	v20070330-1300:1.11
	v20060316-0600:1.11
	v20070208-1800:1.10
	M4_20:1.10
	v20061214-0000:1.10
	M3_20:1.10
	v20061117-0800:1.10
	v20061013-1330:1.9
	M1_20:1.9
	v20060904-1500:1.9
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060616-1200:1.9
	v20060609-1400:1.9
	v20060531-1730:1.9
	v20060519-1300:1.9
	v20060519-0800:1.9
	v20060512-1000:1.8
	I20060512-1000:1.8
	I20060505-1400:1.5
	I20060428-1300:1.5
	I20060424-0500:1.4
	I20060424-0300:1.4
	M6_10:1.4
	I20060407-1200:1.4
	I20060331-1000:1.4
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.14
date	2008.03.03.17.45.10;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	161147cc39254567;

1.13
date	2007.05.10.17.12.28;	author atikhomirov;	state Exp;
branches;
next	1.12;
commitid	23424643527b4567;

1.12
date	2007.04.03.16.29.19;	author atikhomirov;	state Exp;
branches;
next	1.11;
commitid	5dfa461280d64567;

1.11
date	2007.03.14.13.00.14;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	12fa45f7f1db4567;

1.10
date	2006.11.01.12.12.15;	author dstadnik;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.14.18.06.28;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.11.16.57.54;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.11.09.42.01;	author dstadnik;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.10.15.12.28;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.26.17.55.01;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.10.16.56.23;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.02.12.52.53;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.24.18.51.23;	author ashatalin;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.23.15.45.39;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.14
log
@regenerated with EMF 2.4M5
@
text
@/**
 * <copyright>
 * </copyright>
 *
 * $Id$
 */
package org.eclipse.gmf.mappings.provider;


import java.util.Collection;
import java.util.List;

import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.edit.provider.ComposeableAdapterFactory;
import org.eclipse.emf.edit.provider.IEditingDomainItemProvider;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.edit.provider.IItemPropertyDescriptor;
import org.eclipse.emf.edit.provider.IItemPropertySource;
import org.eclipse.emf.edit.provider.IStructuredItemContentProvider;
import org.eclipse.emf.edit.provider.ITreeItemContentProvider;
import org.eclipse.emf.edit.provider.ItemPropertyDescriptor;
import org.eclipse.emf.edit.provider.ViewerNotification;
import org.eclipse.gmf.mappings.ChildReference;
import org.eclipse.gmf.mappings.GMFMapFactory;
import org.eclipse.gmf.mappings.GMFMapPackage;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.NodeReference;
import org.eclipse.gmf.mappings.presentation.FilterUtil;

/**
 * This is the item provider adapter for a {@@link org.eclipse.gmf.mappings.ChildReference} object.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @@generated
 */
public class ChildReferenceItemProvider
	extends NodeReferenceItemProvider
	implements	
		IEditingDomainItemProvider,	
		IStructuredItemContentProvider,	
		ITreeItemContentProvider,	
		IItemLabelProvider,	
		IItemPropertySource {
	/**
	 * This constructs an instance from a factory and a notifier.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public ChildReferenceItemProvider(AdapterFactory adapterFactory) {
		super(adapterFactory);
	}

	/**
	 * This returns the property descriptors for the adapted class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public List<IItemPropertyDescriptor> getPropertyDescriptors(Object object) {
		if (itemPropertyDescriptors == null) {
			super.getPropertyDescriptors(object);

			addCompartmentPropertyDescriptor(object);
			addReferencedChildPropertyDescriptor(object);
		}
		return itemPropertyDescriptors;
	}

	/**
	 * This adds a property descriptor for the Compartment feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	protected void addCompartmentPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(new ItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_ChildReference_compartment_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_ChildReference_compartment_feature", "_UI_ChildReference_type"),
				 GMFMapPackage.eINSTANCE.getChildReference_Compartment(),
				 true,
				 null,
				 null,
				 null) {
						protected Collection<?> getComboBoxObjects(Object object) {
							@@SuppressWarnings("unchecked")
							Collection<EObject> original = (Collection<EObject>) super.getComboBoxObjects(object);
							return FilterUtil.filterByNodeMapping(original, (ChildReference) object);
						}
			});
	}

	/**
	 * This adds a property descriptor for the Referenced Child feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	protected void addReferencedChildPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(new ItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_ChildReference_referencedChild_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_ChildReference_referencedChild_feature", "_UI_ChildReference_type"),
				 GMFMapPackage.eINSTANCE.getChildReference_ReferencedChild(),
				 true,
				 null,
				 null,
				 null) {
						protected Collection<?> getComboBoxObjects(Object object) {
							return FilterUtil.sort(super.getComboBoxObjects(object));
						}
			});
	}

	/**
	 * This specifies how to implement {@@link #getChildren} and is used to deduce an appropriate feature for an
	 * {@@link org.eclipse.emf.edit.command.AddCommand}, {@@link org.eclipse.emf.edit.command.RemoveCommand} or
	 * {@@link org.eclipse.emf.edit.command.MoveCommand} in {@@link #createCommand}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public Collection<? extends EStructuralFeature> getChildrenFeatures(Object object) {
		if (childrenFeatures == null) {
			super.getChildrenFeatures(object);
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getChildReference_OwnedChild());
		}
		return childrenFeatures;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	protected EStructuralFeature getChildFeature(Object object, Object child) {
		// Check the type of the specified child object and return the proper feature to use for
		// adding (see {@@link AddCommand}) it as a child.

		return super.getChildFeature(object, child);
	}

	/**
	 * This returns ChildReference.gif.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public Object getImage(Object object) {
		return overlayImage(object, getResourceLocator().getImage("full/obj16/ChildReference"));
	}

	/**
	 * This returns the label text for the adapted class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	public String getText(Object object) {
        if (object instanceof NodeReference) { 
        	NodeReference reference = (NodeReference) object;
            String result = " <"; 
            if (reference.getContainmentFeature() != null) { 
                 result += reference.getContainmentFeature().getName(); 
            } 
            if (reference.getChildrenFeature() != null) {
            	result += "|";
            	result += reference.getChildrenFeature().getName();
            }
            if (reference.isSetChild()) {
            	NodeMapping mapping = reference.getChild();
                if (mapping.getDomainMetaElement() != null) {
                	result += ":";
                	result += mapping.getDomainMetaElement().getName();
                }
                result += "/";
                if (mapping.getDiagramNode() != null) { 
                    result += reference.getChild().getDiagramNode().getName(); 
                } 
            }
            result += ">"; 
            return getString("_UI_ChildReference_type") + result; 

        }
		return getString("_UI_ChildReference_type");
	}

	/**
	 * This handles model notifications by calling {@@link #updateChildren} to update any cached
	 * children and by creating a viewer notification, which it passes to {@@link #fireNotifyChanged}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void notifyChangedGen(Notification notification) {
		updateChildren(notification);

		switch (notification.getFeatureID(ChildReference.class)) {
			case GMFMapPackage.CHILD_REFERENCE__OWNED_CHILD:
				fireNotifyChanged(new ViewerNotification(notification, notification.getNotifier(), true, false));
				return;
		}
		super.notifyChanged(notification);
	}

	public void notifyChanged(Notification notification) {
		switch (notification.getFeatureID(NodeMapping.class)) {
		case GMFMapPackage.NODE_REFERENCE__CONTAINMENT_FEATURE:
		case GMFMapPackage.NODE_REFERENCE__CHILDREN_FEATURE:
			fireNotifyChanged(new ViewerNotification(notification, null));
			break;
		}
		notifyChangedGen(notification);
	}

	/**
	 * This adds {@@link org.eclipse.emf.edit.command.CommandParameter}s describing the children
	 * that can be created under this object.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	protected void collectNewChildDescriptors(Collection<Object> newChildDescriptors, Object object) {
		super.collectNewChildDescriptors(newChildDescriptors, object);

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getChildReference_OwnedChild(),
				 GMFMapFactory.eINSTANCE.createNodeMapping()));
	}

}
@


1.13
log
@avoid java5 warnings
@
text
@a14 1
import org.eclipse.emf.common.util.ResourceLocator;
a244 11
	/**
	 * Return the resource locator for this item provider's resources.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public ResourceLocator getResourceLocator() {
		return GMFMapEditPlugin.INSTANCE;
	}

@


1.12
log
@EMF.Edit and editor were regenerated with EMF M6
@
text
@d16 1
d94 3
a96 1
							return FilterUtil.filterByNodeMapping(super.getComboBoxObjects(object), (ChildReference) object);
@


1.11
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@a16 1
import org.eclipse.emf.edit.command.CommandParameter;
d227 2
a228 2
	 * This adds to the collection of {@@link org.eclipse.emf.edit.command.CommandParameter}s
	 * describing all of the children that can be created under this object.
d234 1
a234 1
	protected void collectNewChildDescriptors(Collection<CommandParameter> newChildDescriptors, Object object) {
@


1.10
log
@[163045] Provide a better distinguishable Mapping labels in .gmfmap editor
@
text
@d16 2
d21 1
d64 2
a65 1
	public List getPropertyDescriptors(Object object) {
d93 1
a93 1
						protected Collection getComboBoxObjects(Object object) {
d117 1
a117 1
						protected Collection getComboBoxObjects(Object object) {
d131 2
a132 1
	public Collection getChildrenFeatures(Object object) {
d141 13
d159 1
d234 2
a235 1
	protected void collectNewChildDescriptors(Collection newChildDescriptors, Object object) {
d250 1
@


1.9
log
@overriding recent changes introduced (along with fixing #133836) in GMFMap model, as it's merely a 'shortcut', quite frequent though. Still, adding few new concepts just for the sake of single usecase (I do admit it's popular) seems excessive to me.
GMFMap kept the same as old (no new notions introduced), GMFGraph got generalization from DiagramLabel to DiagramNode to make it possible to use DiagramLabels for NodeMappings (thus, it's possible to detect such nodes in the DGMT)
Tests added to make sure we generate correct genModel for both cases.
@
text
@d165 1
a165 1
                	result += "(";
a166 1
                	result += ")";
@


1.8
log
@Filtering out unnecessary compartments.
@
text
@a26 1
import org.eclipse.gmf.mappings.LabelNodeMapping;
d171 2
a172 4
                    result += mapping.getDiagramNode().getName(); 
                } else if (mapping instanceof LabelNodeMapping && ((LabelNodeMapping) mapping).getDiagramLabel() != null) { 
                    result += ((LabelNodeMapping) mapping).getDiagramLabel().getName(); 
                }
a222 5

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getChildReference_OwnedChild(),
				 GMFMapFactory.eINSTANCE.createLabelNodeMapping()));
@


1.7
log
@revert to gmfmap model compatibility
@
text
@d76 1
a76 1
	 * @@generated
d80 1
a80 1
			(createItemPropertyDescriptor
d89 5
a93 1
				 null));
@


1.6
log
@#133836 Creating a child node without a label causes error
@
text
@a29 1
import org.eclipse.gmf.mappings.ShapeNodeMapping;
d167 2
a168 2
                if (mapping instanceof ShapeNodeMapping && ((ShapeNodeMapping) mapping).getDiagramNode() != null) { 
                    result += ((ShapeNodeMapping) mapping).getDiagramNode().getName(); 
d221 1
a221 1
				 GMFMapFactory.eINSTANCE.createShapeNodeMapping()));
@


1.5
log
@#119034 Show only valid feature in "containment feature" property of ChildNodeMapping
#138606 hide inappropriate entries in selection dialogs
@
text
@d27 1
d30 1
d168 5
a172 3
                if (mapping.getDiagramNode() != null) { 
                    result += reference.getChild().getDiagramNode().getName(); 
                } 
d222 6
a227 1
				 GMFMapFactory.eINSTANCE.createNodeMapping()));
@


1.4
log
@feature is better than operation
@
text
@d22 1
d29 1
d95 1
a95 1
	 * @@generated
d99 1
a99 1
			(createItemPropertyDescriptor
d108 5
a112 1
				 null));
@


1.3
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@d152 1
a152 1
            if (reference.getChild() != null) {
@


1.2
log
@Some decorators added to the mapping model entries
@
text
@d132 1
a132 1
		return getResourceLocator().getImage("full/obj16/ChildReference");
d188 1
a188 1
	
@


1.1
log
@#127464 unlimited hierarchies in the GMFMap with possible reuse of mapping entries
@
text
@a14 1

a15 1

a22 1

d26 2
d139 1
a139 1
	 * @@generated
d142 26
d178 1
a178 1
	public void notifyChanged(Notification notification) {
d188 10
@

