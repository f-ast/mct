head	1.24;
access;
symbols
	v20080813-1520:1.24
	v20080722-1827:1.24
	v20080716-1600:1.24
	v20080716-1642:1.24
	R2_1_maintenance:1.24.0.2
	Root_R2_1_maintenance:1.24
	R2_1_0:1.24
	v20080610-1132:1.24
	v20080528-1052:1.24
	v20080425-1959:1.24
	v20080417-1610:1.24
	v20080322-0000:1.24
	v20080222-1200:1.23
	v20070809-0000:1.23
	R2_0_maintenance:1.23.0.2
	R2_0:1.23
	R4_20:1.23
	v20070621-0000:1.23
	RC3_20:1.23
	v20070614-1400:1.23
	v20070608-1300:1.23
	v20070601-1400:1.23
	v20070520-1200:1.23
	v20070518-1300:1.23
	v20070504-1000:1.23
	v20070427-0600:1.23
	v20070420-1000:1.23
	v20070403-1500:1.23
	v20070330-1300:1.22
	v20060316-0600:1.22
	v20070208-1800:1.21
	M4_20:1.21
	v20061214-0000:1.21
	M3_20:1.21
	v20061117-0800:1.21
	v20061013-1330:1.21
	M1_20:1.21
	v20060904-1500:1.21
	v20060713-1700:1.21
	R1_0_maintenance:1.21.0.2
	R1_0:1.21
	v20060627-1200:1.21
	v20060616-1200:1.21
	v20060609-1400:1.20
	v20060531-1730:1.20
	v20060519-1300:1.20
	v20060519-0800:1.20
	v20060512-1000:1.18
	I20060512-1000:1.18
	I20060505-1400:1.15
	I20060428-1300:1.15
	I20060424-0500:1.14
	I20060424-0300:1.14
	M6_10:1.14
	I20060407-1200:1.14
	I20060331-1000:1.14
	I20060324-0300:1.14
	I20060317-1300:1.14
	I20060317-1200:1.14
	I20060316-1300:1.14
	I20060309-1300:1.14
	M5_10:1.14
	S20060303-1600:1.14
	I20060227-1730:1.13
	I20060216-1945:1.11
	I20060210-1715:1.11
	I20060209-1815:1.11
	I20060203-0830:1.11
	I20060129-1145:1.11
	I20060127-0900:1.11
	I20060120-1530:1.11
	I20060113-1700:1.11
	M4_10:1.11
	I20060107-1100:1.11
	I20060105-1630:1.11
	I20051230-1230:1.11
	I20051223-1100:1.11
	I20051217-0925:1.10
	I20051208-2000:1.10
	I20051201-1800:1.8
	I20051124-2000:1.5
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.3
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.24
date	2008.03.03.17.45.10;	author atikhomirov;	state Exp;
branches;
next	1.23;
commitid	161147cc39254567;

1.23
date	2007.04.03.16.29.19;	author atikhomirov;	state Exp;
branches;
next	1.22;
commitid	5dfa461280d64567;

1.22
date	2007.03.14.13.00.15;	author atikhomirov;	state Exp;
branches;
next	1.21;
commitid	12fa45f7f1db4567;

1.21
date	2006.06.12.15.53.55;	author ashatalin;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.19.10.11.56;	author dstadnik;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.14.18.06.28;	author atikhomirov;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.11.12.17.24;	author ashatalin;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.11.09.42.01;	author dstadnik;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.10.15.12.28;	author dstadnik;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.26.17.55.01;	author ashatalin;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.02.12.52.53;	author dstadnik;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.24.18.51.23;	author ashatalin;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.23.15.45.39;	author atikhomirov;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.20.16.12.06;	author atikhomirov;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.06.22.21.16;	author atikhomirov;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.02.15.35.07;	author ashatalin;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.30.12.49.26;	author ashatalin;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.25.14.23.01;	author ashatalin;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.25.13.52.48;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.24.16.31.33;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.21.14.53.05;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.20.14.07.18;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.18.10.58.27;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.29.10;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.24
log
@regenerated with EMF 2.4M5
@
text
@/**
 * <copyright>
 * </copyright>
 *
 * $Id$
 */
package org.eclipse.gmf.mappings.provider;


import java.util.Collection;
import java.util.List;

import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.edit.provider.ComposeableAdapterFactory;
import org.eclipse.emf.edit.provider.IEditingDomainItemProvider;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.edit.provider.IItemPropertyDescriptor;
import org.eclipse.emf.edit.provider.IItemPropertySource;
import org.eclipse.emf.edit.provider.IStructuredItemContentProvider;
import org.eclipse.emf.edit.provider.ITreeItemContentProvider;
import org.eclipse.emf.edit.provider.ItemPropertyDescriptor;
import org.eclipse.emf.edit.provider.ViewerNotification;
import org.eclipse.gmf.mappings.GMFMapFactory;
import org.eclipse.gmf.mappings.GMFMapPackage;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.presentation.FilterUtil;
import org.eclipse.gmf.tooldef.CreationTool;
import org.eclipse.gmf.tooldef.GenericTool;

/**
 * This is the item provider adapter for a {@@link org.eclipse.gmf.mappings.NodeMapping} object.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @@generated
 */
public class NodeMappingItemProvider
	extends MappingEntryItemProvider
	implements	
		IEditingDomainItemProvider,	
		IStructuredItemContentProvider,	
		ITreeItemContentProvider,	
		IItemLabelProvider,	
		IItemPropertySource {
	/**
	 * This constructs an instance from a factory and a notifier.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public NodeMappingItemProvider(AdapterFactory adapterFactory) {
		super(adapterFactory);
	}

	/**
	 * This returns the property descriptors for the adapted class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public List<IItemPropertyDescriptor> getPropertyDescriptors(Object object) {
		if (itemPropertyDescriptors == null) {
			super.getPropertyDescriptors(object);

			addContextMenuPropertyDescriptor(object);
			addToolPropertyDescriptor(object);
			addAppearanceStylePropertyDescriptor(object);
			addDiagramNodePropertyDescriptor(object);
		}
		return itemPropertyDescriptors;
	}

	/**
	 * This adds a property descriptor for the Context Menu feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void addContextMenuPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(createItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_MenuOwner_contextMenu_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_MenuOwner_contextMenu_feature", "_UI_MenuOwner_type"),
				 GMFMapPackage.eINSTANCE.getMenuOwner_ContextMenu(),
				 true,
				 false,
				 false,
				 null,
				 getString("_UI_VisualrepresentationPropertyCategory"),
				 null));
	}

	/**
	 * This adds a property descriptor for the Tool feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	protected void addToolPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(new ItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_ToolOwner_tool_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_ToolOwner_tool_feature", "_UI_ToolOwner_type"),
				 GMFMapPackage.eINSTANCE.getToolOwner_Tool(),
				 true,
				 null,
				 getString("_UI_VisualrepresentationPropertyCategory"),
				 null) {
						protected Collection<?> getComboBoxObjects(Object object) {
							return FilterUtil.filterBySuperClasses(super.getComboBoxObjects(object), new Class[] {CreationTool.class, GenericTool.class});
						}
			});
	}

	/**
	 * This adds a property descriptor for the Appearance Style feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void addAppearanceStylePropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(createItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_AppearanceSteward_appearanceStyle_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_AppearanceSteward_appearanceStyle_feature", "_UI_AppearanceSteward_type"),
				 GMFMapPackage.eINSTANCE.getAppearanceSteward_AppearanceStyle(),
				 true,
				 false,
				 false,
				 null,
				 getString("_UI_VisualrepresentationPropertyCategory"),
				 null));
	}

	/**
	 * This adds a property descriptor for the Diagram Node feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	protected void addDiagramNodePropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(new ItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_NodeMapping_diagramNode_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_NodeMapping_diagramNode_feature", "_UI_NodeMapping_type"),
				 GMFMapPackage.eINSTANCE.getNodeMapping_DiagramNode(),
				 true,
				 null,
				 getString("_UI_VisualrepresentationPropertyCategory"),
				 null) {
						protected Collection<?> getComboBoxObjects(Object object) {
							return FilterUtil.sort(super.getComboBoxObjects(object));
						}
			});
	}

	/**
	 * This specifies how to implement {@@link #getChildren} and is used to deduce an appropriate feature for an
	 * {@@link org.eclipse.emf.edit.command.AddCommand}, {@@link org.eclipse.emf.edit.command.RemoveCommand} or
	 * {@@link org.eclipse.emf.edit.command.MoveCommand} in {@@link #createCommand}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public Collection<? extends EStructuralFeature> getChildrenFeatures(Object object) {
		if (childrenFeatures == null) {
			super.getChildrenFeatures(object);
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getNodeMapping_Children());
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getNodeMapping_Compartments());
		}
		return childrenFeatures;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	protected EStructuralFeature getChildFeature(Object object, Object child) {
		// Check the type of the specified child object and return the proper feature to use for
		// adding (see {@@link AddCommand}) it as a child.

		return super.getChildFeature(object, child);
	}

	/**
	 * This returns NodeMapping.gif.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public Object getImage(Object object) {
		return overlayImage(object, getResourceLocator().getImage("full/obj16/NodeMapping"));
	}

	/**
	 * This returns the label text for the adapted class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	public String getText(Object object) {
		if (object instanceof NodeMapping) {
			NodeMapping mapping = (NodeMapping) object;
			String result = " <";
			if (mapping.getDomainMetaElement() != null) {
				result += mapping.getDomainMetaElement().getName();
			}
			result += "/";
			if (mapping.getDiagramNode() != null) {
				result += mapping.getDiagramNode().getName();
			}
			result += ">";
			return getString("_UI_NodeMapping_type") + result;
		}
		return getString("_UI_NodeMapping_type");
	}

	/**
	 * This handles model notifications by calling {@@link #updateChildren} to update any cached
	 * children and by creating a viewer notification, which it passes to {@@link #fireNotifyChanged}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void notifyChangedGen(Notification notification) {
		updateChildren(notification);

		switch (notification.getFeatureID(NodeMapping.class)) {
			case GMFMapPackage.NODE_MAPPING__CHILDREN:
			case GMFMapPackage.NODE_MAPPING__COMPARTMENTS:
				fireNotifyChanged(new ViewerNotification(notification, notification.getNotifier(), true, false));
				return;
		}
		super.notifyChanged(notification);
	}

	public void notifyChanged(Notification notification) {
		switch (notification.getFeatureID(NodeMapping.class)) {
		case GMFMapPackage.NODE_MAPPING__DIAGRAM_NODE:
		case GMFMapPackage.NODE_MAPPING__DOMAIN_META_ELEMENT:
			fireNotifyChanged(new ViewerNotification(notification, null));
			break;
		}
		notifyChangedGen(notification);
	}

	/**
	 * This adds {@@link org.eclipse.emf.edit.command.CommandParameter}s describing the children
	 * that can be created under this object.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	protected void collectNewChildDescriptors(Collection<Object> newChildDescriptors, Object object) {
		super.collectNewChildDescriptors(newChildDescriptors, object);

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getNodeMapping_Children(),
				 GMFMapFactory.eINSTANCE.createChildReference()));

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getNodeMapping_Compartments(),
				 GMFMapFactory.eINSTANCE.createCompartmentMapping()));
	}

}
@


1.23
log
@EMF.Edit and editor were regenerated with EMF M6
@
text
@a14 1
import org.eclipse.emf.common.util.ResourceLocator;
a282 11
	/**
	 * Return the resource locator for this item provider's resources.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public ResourceLocator getResourceLocator() {
		return GMFMapEditPlugin.INSTANCE;
	}

@


1.22
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@a16 1
import org.eclipse.emf.edit.command.CommandParameter;
d263 2
a264 2
	 * This adds to the collection of {@@link org.eclipse.emf.edit.command.CommandParameter}s
	 * describing all of the children that can be created under this object.
d270 1
a270 1
	protected void collectNewChildDescriptors(Collection<CommandParameter> newChildDescriptors, Object object) {
@


1.21
log
@#144197 [gmfmap] Only creation and custom tools should be available in dropdown menu of the node and link mapping Tool property
@
text
@d17 1
d21 1
d64 2
a65 1
	public List getPropertyDescriptors(Object object) {
d117 1
a117 1
						protected Collection getComboBoxObjects(Object object) {
d163 1
a163 1
						protected Collection getComboBoxObjects(Object object) {
d177 2
a178 1
	public Collection getChildrenFeatures(Object object) {
d192 1
d206 1
d270 2
a271 1
	protected void collectNewChildDescriptors(Collection newChildDescriptors, Object object) {
d291 1
@


1.20
log
@#114175 Allow a diagram definition to be mapped to zero or more domain models.
@
text
@d29 2
d115 1
a115 1
							return FilterUtil.sort(super.getComboBoxObjects(object));
@


1.19
log
@overriding recent changes introduced (along with fixing #133836) in GMFMap model, as it's merely a 'shortcut', quite frequent though. Still, adding few new concepts just for the sake of single usecase (I do admit it's popular) seems excessive to me.
GMFMap kept the same as old (no new notions introduced), GMFGraph got generalization from DiagramLabel to DiagramNode to make it possible to use DiagramLabels for NodeMappings (thus, it's possible to detect such nodes in the DGMT)
Tests added to make sure we generate correct genModel for both cases.
@
text
@d87 2
d133 2
@


1.18
log
@Corercting property sheet for LabelNodeMappings
@
text
@d140 1
a140 1
	 * @@generated
d144 1
a144 1
			(createItemPropertyDescriptor
d152 6
a157 2
				 null,
				 null));
d243 1
@


1.17
log
@revert to gmfmap model compatibility
@
text
@a26 1
import org.eclipse.gmf.mappings.LabelNodeMapping;
a210 2
			} else if (mapping instanceof LabelNodeMapping && ((LabelNodeMapping) mapping).getDiagramLabel() != null) {
				result += ((LabelNodeMapping) mapping).getDiagramLabel().getName();
@


1.16
log
@#133836 Creating a child node without a label causes error
@
text
@a28 1
import org.eclipse.gmf.mappings.ShapeNodeMapping;
d68 1
d138 20
d210 2
a211 2
			if (mapping instanceof ShapeNodeMapping && ((ShapeNodeMapping) mapping).getDiagramNode() != null) {
				result += ((ShapeNodeMapping) mapping).getDiagramNode().getName();
@


1.15
log
@#119034 Show only valid feature in "containment feature" property of ChildNodeMapping
#138606 hide inappropriate entries in selection dialogs
@
text
@d27 1
d29 1
a68 1
			addDiagramNodePropertyDescriptor(object);
a137 24
	 * This adds a property descriptor for the Diagram Node feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	protected void addDiagramNodePropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(new ItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_NodeMapping_diagramNode_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_NodeMapping_diagramNode_feature", "_UI_NodeMapping_type"),
				 GMFMapPackage.eINSTANCE.getNodeMapping_DiagramNode(),
				 true,
				 null,
				 getString("_UI_VisualrepresentationPropertyCategory"),
				 null) {
						protected Collection getComboBoxObjects(Object object) {
							return FilterUtil.sort(super.getComboBoxObjects(object));
						}
			});
	}

	/**
d190 4
a193 2
			if (mapping.getDiagramNode() != null) {
				result += mapping.getDiagramNode().getName();
a221 1
		case GMFMapPackage.NODE_MAPPING__DIAGRAM_NODE:
@


1.14
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@a16 1

d23 1
a24 1

a26 1

d28 1
d96 1
a96 1
	 * @@generated
d100 1
a100 1
			(createItemPropertyDescriptor
d109 5
a113 1
				 null));
d140 1
a140 1
	 * @@generated
d144 1
a144 1
			(createItemPropertyDescriptor
d153 5
a157 1
				 null));
@


1.13
log
@Some decorators added to the mapping model entries
@
text
@d189 1
a189 1
		return getResourceLocator().getImage("full/obj16/NodeMapping");
d196 1
a196 1
	 * @@generated
d233 1
a233 1
	
@


1.12
log
@#127464 unlimited hierarchies in the GMFMap with possible reuse of mapping entries
@
text
@d202 4
d222 1
a222 1
	public void notifyChanged(Notification notification) {
d233 10
@


1.11
log
@#121565 property categories and simplified names to ease mapping definition.
Some outdated properties removed as well
@
text
@d16 2
d24 3
d29 2
d38 1
a38 1
	extends AbstractNodeMappingItemProvider
d65 3
d74 60
d154 29
d199 9
d220 7
d239 10
@


1.10
log
@updated gmfmap to match newly introduced .gmfgraph model (replaces .diadef) #114177.
besides, rudimentary tooling model is introduced as part of gmfmap #115799, subject to further work
@
text
@d79 1
a79 1
				 null,
@


1.9
log
@#119034

Moving not generated property descriptors to the abstract super-class.
@
text
@d16 1
d22 1
d58 1
d64 20
@


1.8
log
@Adding method to get DomainElementMetaClass for the transformation code.
@
text
@a10 3
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
a11 1
import java.util.Set;
a15 2
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.edit.provider.ComposeableAdapterFactory;
a20 3
import org.eclipse.emf.edit.provider.ItemPropertyDescriptor;
import org.eclipse.gmf.mappings.GMFMapPackage;
import org.eclipse.gmf.mappings.NodeMapping;
a60 70
	 * This adds a property descriptor for the Containment Feature feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	protected void addContainmentFeaturePropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(new ItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_NodeMapping_containmentFeature_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_NodeMapping_containmentFeature_feature", "_UI_NodeMapping_type"),
				 GMFMapPackage.eINSTANCE.getAbstractNodeMapping_ContainmentFeature(),
				 true,
				 null,
				 null,
				 null) {
				protected Collection getComboBoxObjects(Object object) {
					if (object instanceof NodeMapping) {
						NodeMapping nm = (NodeMapping) object;
						if (nm.getDomainMetaElement() != null) {
							Set features = new HashSet();
							for (Iterator it = nm.getDomainMetaElement().getEPackage().eAllContents(); it.hasNext(); ) {
								Object next = it.next();
								if (next instanceof EReference) {
									EReference ref = (EReference) next;
									if (ref.isContainment() && nm.getDomainMetaElement().equals(ref.getEType())) {
										features.add(ref);
									}
								}
							}
							return features;
						}
					}
					return Collections.EMPTY_LIST;
				}
		});
	}

	/**
	 * This adds a property descriptor for the Edit Feature feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	protected void addEditFeaturePropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(new ItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_NodeMapping_editFeature_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_NodeMapping_editFeature_feature", "_UI_NodeMapping_type"),
				 GMFMapPackage.eINSTANCE.getAbstractNodeMapping_EditFeature(),
				 true,
				 null,
				 null,
				 null) {
				protected Collection getComboBoxObjects(Object object) {
					if (object instanceof NodeMapping) {
						NodeMapping nm = (NodeMapping) object;
						if (nm.getDomainMetaElement() != null) {
							return nm.getDomainMetaElement().getEAllAttributes();
						}
					}
					return Collections.EMPTY_LIST;
				}
			});
	}

	/**
@


1.7
log
@#118053
Infinite child mapping hierarchy in .gmfmap
@
text
@a20 1
import org.eclipse.emf.ecore.EStructuralFeature;
a27 2
import org.eclipse.emf.edit.provider.ViewerNotification;
import org.eclipse.gmf.mappings.GMFMapFactory;
d38 1
a38 1
	extends MappingEntryItemProvider
a64 4
			addDiagramNodePropertyDescriptor(object);
			addDomainMetaElementPropertyDescriptor(object);
			addContainmentFeaturePropertyDescriptor(object);
			addEditFeaturePropertyDescriptor(object);
a69 40
	 * This adds a property descriptor for the Diagram Node feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void addDiagramNodePropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(createItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_AbstractNodeMapping_diagramNode_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_AbstractNodeMapping_diagramNode_feature", "_UI_AbstractNodeMapping_type"),
				 GMFMapPackage.eINSTANCE.getAbstractNodeMapping_DiagramNode(),
				 true,
				 null,
				 null,
				 null));
	}

	/**
	 * This adds a property descriptor for the Domain Meta Element feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void addDomainMetaElementPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(createItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_AbstractNodeMapping_domainMetaElement_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_AbstractNodeMapping_domainMetaElement_feature", "_UI_AbstractNodeMapping_type"),
				 GMFMapPackage.eINSTANCE.getAbstractNodeMapping_DomainMetaElement(),
				 true,
				 null,
				 null,
				 null));
	}

	/**
a139 30
	 * This specifies how to implement {@@link #getChildren} and is used to deduce an appropriate feature for an
	 * {@@link org.eclipse.emf.edit.command.AddCommand}, {@@link org.eclipse.emf.edit.command.RemoveCommand} or
	 * {@@link org.eclipse.emf.edit.command.MoveCommand} in {@@link #createCommand}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public Collection getChildrenFeatures(Object object) {
		if (childrenFeatures == null) {
			super.getChildrenFeatures(object);
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getAbstractNodeMapping_DomainSpecialization());
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getAbstractNodeMapping_DomainInitializer());
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getAbstractNodeMapping_ChildMappings());
		}
		return childrenFeatures;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected EStructuralFeature getChildFeature(Object object, Object child) {
		// Check the type of the specified child object and return the proper feature to use for
		// adding (see {@@link AddCommand}) it as a child.

		return super.getChildFeature(object, child);
	}

	/**
a167 8

		switch (notification.getFeatureID(NodeMapping.class)) {
			case GMFMapPackage.NODE_MAPPING__DOMAIN_SPECIALIZATION:
			case GMFMapPackage.NODE_MAPPING__DOMAIN_INITIALIZER:
			case GMFMapPackage.NODE_MAPPING__CHILD_MAPPINGS:
				fireNotifyChanged(new ViewerNotification(notification, notification.getNotifier(), true, false));
				return;
		}
a179 15

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getAbstractNodeMapping_DomainSpecialization(),
				 GMFMapFactory.eINSTANCE.createConstraint()));

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getAbstractNodeMapping_DomainInitializer(),
				 GMFMapFactory.eINSTANCE.createFeatureSeqInitializer()));

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getAbstractNodeMapping_ChildMappings(),
				 GMFMapFactory.eINSTANCE.createChildNodeMapping()));
@


1.6
log
@#118053 update models
@
text
@d129 1
a129 1
				 GMFMapPackage.eINSTANCE.getNodeMapping_ContainmentFeature(),
d169 1
a169 1
				 GMFMapPackage.eINSTANCE.getNodeMapping_EditFeature(),
@


1.5
log
@provide correct list of containment features
@
text
@d87 3
a89 3
				 getString("_UI_NodeMapping_diagramNode_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_NodeMapping_diagramNode_feature", "_UI_NodeMapping_type"),
				 GMFMapPackage.eINSTANCE.getNodeMapping_DiagramNode(),
d107 3
a109 3
				 getString("_UI_NodeMapping_domainMetaElement_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_NodeMapping_domainMetaElement_feature", "_UI_NodeMapping_type"),
				 GMFMapPackage.eINSTANCE.getNodeMapping_DomainMetaElement(),
d197 3
a199 3
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getNodeMapping_DomainSpecialization());
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getNodeMapping_DomainInitializer());
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getNodeMapping_ChildMappings());
d268 1
a268 1
				(GMFMapPackage.eINSTANCE.getNodeMapping_DomainSpecialization(),
d273 1
a273 1
				(GMFMapPackage.eINSTANCE.getNodeMapping_DomainInitializer(),
d278 1
a278 1
				(GMFMapPackage.eINSTANCE.getNodeMapping_ChildMappings(),
@


1.4
log
@hardcode filtering of containment and edit metafeatures to reduce dropdown size
@
text
@d12 2
d15 1
d20 1
d138 11
a148 1
							return nm.getDomainMetaElement().getEAllContainments();
@


1.3
log
@[rdvorak] #112773 specify init expressions while relating diagram elements with domain
@
text
@d11 1
a17 1

d24 1
d116 1
a116 1
	 * @@generated
d120 1
a120 1
			(createItemPropertyDescriptor
d129 11
a139 1
				 null));
d146 1
a146 1
	 * @@generated
d150 1
a150 1
			(createItemPropertyDescriptor
d159 11
a169 1
				 null));
@


1.2
log
@[rdvorak] #112505 constraint specification in gmfmap
@
text
@d163 1
d213 1
d238 5
@


1.1
log
@*** empty log message ***
@
text
@d5 1
a5 1
 * $Id: NodeMappingItemProvider.java,v 1.4 2005/08/02 13:11:51 artem Exp $
d16 2
d162 1
d169 12
d211 1
d231 5
@

