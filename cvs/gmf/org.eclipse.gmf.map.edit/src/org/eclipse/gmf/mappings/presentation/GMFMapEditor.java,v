head	1.23;
access;
symbols
	v20080813-1520:1.23
	v20080722-1827:1.23
	v20080716-1600:1.21.2.1
	v20080716-1642:1.23
	R2_1_maintenance:1.21.0.2
	Root_R2_1_maintenance:1.21
	R2_1_0:1.21
	v20080610-1132:1.21
	v20080528-1052:1.20
	v20080425-1959:1.20
	v20080417-1610:1.20
	v20080322-0000:1.19
	v20080222-1200:1.17
	v20070809-0000:1.17
	R2_0_maintenance:1.17.0.2
	R2_0:1.17
	R4_20:1.17
	v20070621-0000:1.17
	RC3_20:1.17
	v20070614-1400:1.17
	v20070608-1300:1.17
	v20070601-1400:1.17
	v20070520-1200:1.16
	v20070518-1300:1.16
	v20070504-1000:1.15
	v20070427-0600:1.15
	v20070420-1000:1.15
	v20070403-1500:1.15
	v20070330-1300:1.14
	v20060316-0600:1.14
	v20070208-1800:1.13
	M4_20:1.13
	v20061214-0000:1.13
	M3_20:1.13
	v20061117-0800:1.13
	v20061013-1330:1.12
	M1_20:1.11
	v20060904-1500:1.11
	v20060713-1700:1.11
	R1_0_maintenance:1.11.0.2
	R1_0:1.11
	v20060627-1200:1.11
	v20060616-1200:1.11
	v20060609-1400:1.10
	v20060531-1730:1.9
	v20060519-1300:1.9
	v20060519-0800:1.9
	v20060512-1000:1.8
	I20060512-1000:1.8
	I20060505-1400:1.8
	I20060428-1300:1.7
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.5
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.4
	I20060209-1815:1.4
	I20060203-0830:1.4
	I20060129-1145:1.4
	I20060127-0900:1.4
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051208-2000:1.2
	I20051201-1800:1.1
	I20051124-2000:1.1
	M3_10:1.1
	I20051118-1245:1.1
	I20051111-1800:1.1
	I20051106-0900:1.1
	v20051030:1.1
	v20050828:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.23
date	2008.07.01.11.40.10;	author atikhomirov;	state Exp;
branches;
next	1.22;
commitid	7b52486a17994567;

1.22
date	2008.06.27.15.48.39;	author atikhomirov;	state Exp;
branches;
next	1.21;
commitid	5be748650bd64567;

1.21
date	2008.06.05.14.39.23;	author atikhomirov;	state Exp;
branches
	1.21.2.1;
next	1.20;
commitid	55044847fa9b4567;

1.20
date	2008.04.17.09.43.47;	author atikhomirov;	state Exp;
branches;
next	1.19;
commitid	546b48071bd34567;

1.19
date	2008.03.05.20.45.03;	author atikhomirov;	state Exp;
branches;
next	1.18;
commitid	2ef447cf064e4567;

1.18
date	2008.03.03.17.45.10;	author atikhomirov;	state Exp;
branches;
next	1.17;
commitid	161147cc39254567;

1.17
date	2007.05.28.13.44.12;	author atikhomirov;	state Exp;
branches;
next	1.16;
commitid	3f9b465adcac4567;

1.16
date	2007.05.11.09.41.36;	author atikhomirov;	state Exp;
branches;
next	1.15;
commitid	5a0346443a4f4567;

1.15
date	2007.04.03.16.29.19;	author atikhomirov;	state Exp;
branches;
next	1.14;
commitid	5dfa461280d64567;

1.14
date	2007.03.14.13.00.14;	author atikhomirov;	state Exp;
branches;
next	1.13;
commitid	12fa45f7f1db4567;

1.13
date	2006.11.09.13.28.42;	author radvorak;	state Exp;
branches;
next	1.12;

1.12
date	2006.09.28.18.21.36;	author radvorak;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.12.14.02.50;	author ashatalin;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.02.11.43.00;	author radvorak;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.16.16.44.12;	author atikhomirov;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.03.13.59.06;	author atikhomirov;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.25.19.15.43;	author radvorak;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.13.17.28.28;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.08.14.10.30;	author atikhomirov;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.10.20.40.13;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.10.18.35.33;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.06.22.21.16;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.03.22.29.10;	author atikhomirov;	state Exp;
branches;
next	;

1.21.2.1
date	2008.06.27.15.53.03;	author atikhomirov;	state Exp;
branches;
next	;
commitid	5eb748650cde4567;


desc
@@


1.23
log
@[227127] support literal values for feature initializers. step 1: models updated to specify new possible values
@
text
@/**
 * <copyright>
 * </copyright>
 *
 * $Id$
 */
package org.eclipse.gmf.mappings.presentation;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.EventObject;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IStorage;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.emf.common.command.BasicCommandStack;
import org.eclipse.emf.common.command.Command;
import org.eclipse.emf.common.command.CommandStack;
import org.eclipse.emf.common.command.CommandStackListener;
import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.ui.MarkerHelper;
import org.eclipse.emf.common.ui.ViewerPane;
import org.eclipse.emf.common.ui.editor.ProblemEditorPart;
import org.eclipse.emf.common.ui.viewer.IViewerProvider;
import org.eclipse.emf.common.util.BasicDiagnostic;
import org.eclipse.emf.common.util.Diagnostic;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EValidator;
import org.eclipse.emf.ecore.plugin.EcorePlugin;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EContentAdapter;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.emf.edit.domain.IEditingDomainProvider;
import org.eclipse.emf.edit.provider.AdapterFactoryItemDelegator;
import org.eclipse.emf.edit.provider.ComposedAdapterFactory;
import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory;
import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory;
import org.eclipse.emf.edit.ui.action.EditingDomainActionBarContributor;
import org.eclipse.emf.edit.ui.celleditor.AdapterFactoryTreeEditor;
import org.eclipse.emf.edit.ui.dnd.EditingDomainViewerDropAdapter;
import org.eclipse.emf.edit.ui.dnd.LocalTransfer;
import org.eclipse.emf.edit.ui.dnd.ViewerDragAdapter;
import org.eclipse.emf.edit.ui.provider.AdapterFactoryContentProvider;
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider;
import org.eclipse.emf.edit.ui.provider.UnwrappingSelectionProvider;
import org.eclipse.emf.edit.ui.util.EditUIMarkerHelper;
import org.eclipse.emf.edit.ui.util.EditUIUtil;
import org.eclipse.emf.edit.ui.view.ExtendedPropertySheetPage;
import org.eclipse.gmf.gmfgraph.provider.GMFGraphItemProviderAdapterFactory;
import org.eclipse.gmf.mappings.provider.EcoreItemProviderAdapterFactoryEx;
import org.eclipse.gmf.mappings.provider.GMFMapEditPlugin;
import org.eclipse.gmf.mappings.provider.GMFMapItemProviderAdapterFactory;
import org.eclipse.gmf.tooldef.provider.GMFToolItemProviderAdapterFactory;
import org.eclipse.jface.action.IMenuListener;
import org.eclipse.jface.action.IMenuManager;
import org.eclipse.jface.action.IStatusLineManager;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.dialogs.ProgressMonitorDialog;
import org.eclipse.jface.viewers.ColumnWeightData;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.ISelectionProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.ListViewer;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.StructuredViewer;
import org.eclipse.jface.viewers.TableLayout;
import org.eclipse.jface.viewers.TableViewer;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.CTabFolder;
import org.eclipse.swt.dnd.DND;
import org.eclipse.swt.dnd.Transfer;
import org.eclipse.swt.events.ControlAdapter;
import org.eclipse.swt.events.ControlEvent;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.swt.widgets.Tree;
import org.eclipse.swt.widgets.TreeColumn;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IEditorSite;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.ui.IPartListener;
import org.eclipse.ui.IStorageEditorInput;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.actions.WorkspaceModifyOperation;
import org.eclipse.ui.dialogs.SaveAsDialog;
import org.eclipse.ui.ide.IGotoMarker;
import org.eclipse.ui.part.FileEditorInput;
import org.eclipse.ui.part.MultiPageEditorPart;
import org.eclipse.ui.views.contentoutline.ContentOutline;
import org.eclipse.ui.views.contentoutline.ContentOutlinePage;
import org.eclipse.ui.views.contentoutline.IContentOutlinePage;
import org.eclipse.ui.views.properties.IPropertySheetPage;
import org.eclipse.ui.views.properties.PropertySheet;
import org.eclipse.ui.views.properties.PropertySheetPage;


/**
 * This is an example of a GMFMap model editor.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @@generated
 */
public class GMFMapEditor
	extends MultiPageEditorPart
	implements IEditingDomainProvider, ISelectionProvider, IMenuListener, IViewerProvider, IGotoMarker {
	/**
	 * This keeps track of the editing domain that is used to track all changes to the model.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected AdapterFactoryEditingDomain editingDomain;

	/**
	 * This is the one adapter factory used for providing views of the model.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected ComposedAdapterFactory adapterFactory;

	/**
	 * This is the content outline page.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected IContentOutlinePage contentOutlinePage;

	/**
	 * This is a kludge...
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected IStatusLineManager contentOutlineStatusLineManager;

	/**
	 * This is the content outline page's viewer.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected TreeViewer contentOutlineViewer;

	/**
	 * This is the property sheet page.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected PropertySheetPage propertySheetPage;

	/**
	 * This is the viewer that shadows the selection in the content outline.
	 * The parent relation must be correctly defined for this to work.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected TreeViewer selectionViewer;

	/**
	 * This inverts the roll of parent and child in the content provider and show parents as a tree.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected TreeViewer parentViewer;

	/**
	 * This shows how a tree view works.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected TreeViewer treeViewer;

	/**
	 * This shows how a list view works.
	 * A list viewer doesn't support icons.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected ListViewer listViewer;

	/**
	 * This shows how a table view works.
	 * A table can be used as a list with icons.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected TableViewer tableViewer;

	/**
	 * This shows how a tree view with columns works.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected TreeViewer treeViewerWithColumns;

	/**
	 * This keeps track of the active viewer pane, in the book.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected ViewerPane currentViewerPane;

	/**
	 * This keeps track of the active content viewer, which may be either one of the viewers in the pages or the content outline viewer.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected Viewer currentViewer;

	/**
	 * This listens to which ever viewer is active.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected ISelectionChangedListener selectionChangedListener;

	/**
	 * This keeps track of all the {@@link org.eclipse.jface.viewers.ISelectionChangedListener}s that are listening to this editor.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected Collection<ISelectionChangedListener> selectionChangedListeners = new ArrayList<ISelectionChangedListener>();

	/**
	 * This keeps track of the selection of the editor as a whole.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected ISelection editorSelection = StructuredSelection.EMPTY;

	/**
	 * The MarkerHelper is responsible for creating workspace resource markers presented
	 * in Eclipse's Problems View.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected MarkerHelper markerHelper = new EditUIMarkerHelper();

	/**
	 * This listens for when the outline becomes active
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected IPartListener partListener =
		new IPartListener() {
			public void partActivated(IWorkbenchPart p) {
				if (p instanceof ContentOutline) {
					if (((ContentOutline)p).getCurrentPage() == contentOutlinePage) {
						getActionBarContributor().setActiveEditor(GMFMapEditor.this);

						setCurrentViewer(contentOutlineViewer);
					}
				}
				else if (p instanceof PropertySheet) {
					if (((PropertySheet)p).getCurrentPage() == propertySheetPage) {
						getActionBarContributor().setActiveEditor(GMFMapEditor.this);
						handleActivate();
					}
				}
				else if (p == GMFMapEditor.this) {
					handleActivate();
				}
			}
			public void partBroughtToTop(IWorkbenchPart p) {
				// Ignore.
			}
			public void partClosed(IWorkbenchPart p) {
				// Ignore.
			}
			public void partDeactivated(IWorkbenchPart p) {
				// Ignore.
			}
			public void partOpened(IWorkbenchPart p) {
				// Ignore.
			}
		};

	/**
	 * Resources that have been removed since last activation.
	 * @@generated
	 */
	protected Collection<Resource> removedResources = new ArrayList<Resource>();

	/**
	 * Resources that have been changed since last activation.
	 * @@generated
	 */
	protected Collection<Resource> changedResources = new ArrayList<Resource>();

	/**
	 * Resources that have been saved.
	 * @@generated
	 */
	protected Collection<Resource> savedResources = new ArrayList<Resource>();

	/**
	 * Map to store the diagnostic associated with a resource.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected Map<Resource, Diagnostic> resourceToDiagnosticMap = new LinkedHashMap<Resource, Diagnostic>();
	
	/**
	 * Controls whether the problem indication should be updated.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */	
	protected boolean updateProblemIndication = true;

	/**
	 * Adapter used to update the problem indication when resources are demanded loaded.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */	
	protected EContentAdapter problemIndicationAdapter = 
		new EContentAdapter() {
			@@Override
			public void notifyChanged(Notification notification) {
				if (notification.getNotifier() instanceof Resource) {
					switch (notification.getFeatureID(Resource.class)) {
						case Resource.RESOURCE__IS_LOADED:
						case Resource.RESOURCE__ERRORS:
						case Resource.RESOURCE__WARNINGS: {
							Resource resource = (Resource)notification.getNotifier();
							Diagnostic diagnostic = analyzeResourceProblems(resource, null);
							if (diagnostic.getSeverity() != Diagnostic.OK) {
								resourceToDiagnosticMap.put(resource, diagnostic);
							}
							else {
								resourceToDiagnosticMap.remove(resource);
							}

							if (updateProblemIndication) {
								getSite().getShell().getDisplay().asyncExec
									(new Runnable() {
										 public void run() {
											 updateProblemIndication();
										 }
									 });
							}
							break;
						}
					}
				}
				else {
					super.notifyChanged(notification);
				}
			}

			@@Override
			protected void setTarget(Resource target) {
				basicSetTarget(target);
			}

			@@Override
			protected void unsetTarget(Resource target) {
				basicUnsetTarget(target);
			}
		};

	/**
	 * This listens for workspace changes.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected IResourceChangeListener resourceChangeListener =
		new IResourceChangeListener() {
			public void resourceChanged(IResourceChangeEvent event) {
				IResourceDelta delta = event.getDelta();
				try {
					class ResourceDeltaVisitor implements IResourceDeltaVisitor {
						protected ResourceSet resourceSet = editingDomain.getResourceSet();
						protected Collection<Resource> changedResources = new ArrayList<Resource>();
						protected Collection<Resource> removedResources = new ArrayList<Resource>();

						public boolean visit(IResourceDelta delta) {
							if (delta.getResource().getType() == IResource.FILE) {
								if (delta.getKind() == IResourceDelta.REMOVED ||
								    delta.getKind() == IResourceDelta.CHANGED && delta.getFlags() != IResourceDelta.MARKERS) {
									Resource resource = resourceSet.getResource(URI.createURI(delta.getFullPath().toString()), false);
									if (resource != null) {
										if (delta.getKind() == IResourceDelta.REMOVED) {
											removedResources.add(resource);
										}
										else if (!savedResources.remove(resource)) {
											changedResources.add(resource);
										}
									}
								}
							}

							return true;
						}

						public Collection<Resource> getChangedResources() {
							return changedResources;
						}

						public Collection<Resource> getRemovedResources() {
							return removedResources;
						}
					}

					ResourceDeltaVisitor visitor = new ResourceDeltaVisitor();
					delta.accept(visitor);

					if (!visitor.getRemovedResources().isEmpty()) {
						removedResources.addAll(visitor.getRemovedResources());
						if (!isDirty()) {
							getSite().getShell().getDisplay().asyncExec
								(new Runnable() {
									 public void run() {
										 getSite().getPage().closeEditor(GMFMapEditor.this, false);
									 }
								 });
						}
					}

					if (!visitor.getChangedResources().isEmpty()) {
						changedResources.addAll(visitor.getChangedResources());
						if (getSite().getPage().getActiveEditor() == GMFMapEditor.this) {
							getSite().getShell().getDisplay().asyncExec
								(new Runnable() {
									 public void run() {
										 handleActivate();
									 }
								 });
						}
					}
				}
				catch (CoreException exception) {
					GMFMapEditPlugin.INSTANCE.log(exception);
				}
			}
		};

	/**
	 * Handles activation of the editor or it's associated views.
	 * @@generated
	 */
	protected void handleActivate() {
		// Recompute the read only state.
		//
		if (editingDomain.getResourceToReadOnlyMap() != null) {
		  editingDomain.getResourceToReadOnlyMap().clear();

		  // Refresh any actions that may become enabled or disabled.
		  //
		  setSelection(getSelection());
		}

		if (!removedResources.isEmpty()) {
			if (handleDirtyConflict()) {
				getSite().getPage().closeEditor(GMFMapEditor.this, false);
			}
			else {
				removedResources.clear();
				changedResources.clear();
				savedResources.clear();
			}
		}
		else if (!changedResources.isEmpty()) {
			changedResources.removeAll(savedResources);
			handleChangedResources();
			changedResources.clear();
			savedResources.clear();
		}
	}

	/**
	 * Handles what to do with changed resources on activation.
	 * @@generated
	 */
	protected void handleChangedResources() {
		if (!changedResources.isEmpty() && (!isDirty() || handleDirtyConflict())) {
			if (isDirty()) {
				changedResources.addAll(editingDomain.getResourceSet().getResources());
			}
			editingDomain.getCommandStack().flush();

			updateProblemIndication = false;
			for (Resource resource : changedResources) {
				if (resource.isLoaded()) {
					resource.unload();
					try {
						resource.load(Collections.EMPTY_MAP);
					}
					catch (IOException exception) {
						if (!resourceToDiagnosticMap.containsKey(resource)) {
							resourceToDiagnosticMap.put(resource, analyzeResourceProblems(resource, exception));
						}
					}
				}
			}

			if (AdapterFactoryEditingDomain.isStale(editorSelection)) {
				setSelection(StructuredSelection.EMPTY);
			}

			updateProblemIndication = true;
			updateProblemIndication();
		}
	}
  
	/**
	 * Updates the problems indication with the information described in the specified diagnostic.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void updateProblemIndication() {
		if (updateProblemIndication) {
			BasicDiagnostic diagnostic =
				new BasicDiagnostic
					(Diagnostic.OK,
					 "org.eclipse.gmf.map.edit",
					 0,
					 null,
					 new Object [] { editingDomain.getResourceSet() });
			for (Diagnostic childDiagnostic : resourceToDiagnosticMap.values()) {
				if (childDiagnostic.getSeverity() != Diagnostic.OK) {
					diagnostic.add(childDiagnostic);
				}
			}

			int lastEditorPage = getPageCount() - 1;
			if (lastEditorPage >= 0 && getEditor(lastEditorPage) instanceof ProblemEditorPart) {
				((ProblemEditorPart)getEditor(lastEditorPage)).setDiagnostic(diagnostic);
				if (diagnostic.getSeverity() != Diagnostic.OK) {
					setActivePage(lastEditorPage);
				}
			}
			else if (diagnostic.getSeverity() != Diagnostic.OK) {
				ProblemEditorPart problemEditorPart = new ProblemEditorPart();
				problemEditorPart.setDiagnostic(diagnostic);
				problemEditorPart.setMarkerHelper(markerHelper);
				try {
					addPage(++lastEditorPage, problemEditorPart, getEditorInput());
					setPageText(lastEditorPage, problemEditorPart.getPartName());
					setActivePage(lastEditorPage);
					showTabs();
				}
				catch (PartInitException exception) {
					GMFMapEditPlugin.INSTANCE.log(exception);
				}
			}

			if (markerHelper.hasMarkers(editingDomain.getResourceSet())) {
				markerHelper.deleteMarkers(editingDomain.getResourceSet());
				if (diagnostic.getSeverity() != Diagnostic.OK) {
					try {
						markerHelper.createMarkers(diagnostic);
					}
					catch (CoreException exception) {
						GMFMapEditPlugin.INSTANCE.log(exception);
					}
				}
			}
		}
	}

	/**
	 * Shows a dialog that asks if conflicting changes should be discarded.
	 * @@generated
	 */
	protected boolean handleDirtyConflict() {
		return
			MessageDialog.openQuestion
				(getSite().getShell(),
				 getString("_UI_FileConflict_label"),
				 getString("_WARN_FileConflict"));
	}

	/**
	 * This creates a model editor.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public GMFMapEditor() {
		super();
		initializeEditingDomain();
	}

	/**
	 * This sets up the editing domain for the model editor.
	 * <!-- begin-user-doc -->
	 * Do not forget to use EcoreItemProviderAdapterFactoryEx
	 * instead of default
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void initializeEditingDomainGen() {
		// Create an adapter factory that yields item providers.
		//
		adapterFactory = new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE);

		adapterFactory.addAdapterFactory(new ResourceItemProviderAdapterFactory());
		adapterFactory.addAdapterFactory(new GMFMapItemProviderAdapterFactory());
		adapterFactory.addAdapterFactory(new GMFGraphItemProviderAdapterFactory());
		adapterFactory.addAdapterFactory(new GMFToolItemProviderAdapterFactory());
		adapterFactory.addAdapterFactory(new EcoreItemProviderAdapterFactoryEx());
		adapterFactory.addAdapterFactory(new ReflectiveItemProviderAdapterFactory());

		// Create the command stack that will notify this editor as commands are executed.
		//
		BasicCommandStack commandStack = new BasicCommandStack();

		// Add a listener to set the most recent command's affected objects to be the selection of the viewer with focus.
		//
		commandStack.addCommandStackListener
			(new CommandStackListener() {
				 public void commandStackChanged(final EventObject event) {
					 getContainer().getDisplay().asyncExec
						 (new Runnable() {
							  public void run() {
								  firePropertyChange(IEditorPart.PROP_DIRTY);

								  // Try to select the affected objects.
								  //
								  Command mostRecentCommand = ((CommandStack)event.getSource()).getMostRecentCommand();
								  if (mostRecentCommand != null) {
									  setSelectionToViewer(mostRecentCommand.getAffectedObjects());
								  }
								  if (propertySheetPage != null && !propertySheetPage.getControl().isDisposed()) {
									  propertySheetPage.refresh();
								  }
							  }
						  });
				 }
			 });

		// Create the editing domain with a special command stack.
		//
		editingDomain = new AdapterFactoryEditingDomain(adapterFactory, commandStack, new HashMap<Resource, Boolean>());
	}

	protected void initializeEditingDomain() {
		initializeEditingDomainGen();
		editingDomain.getResourceSet().getURIConverter().getURIMap().putAll(EcorePlugin.computePlatformURIMap());
	}

	/**
	 * This is here for the listener to be able to call it.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	protected void firePropertyChange(int action) {
		super.firePropertyChange(action);
	}

	/**
	 * This sets the selection into whichever viewer is active.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void setSelectionToViewer(Collection<?> collection) {
		final Collection<?> theSelection = collection;
		// Make sure it's okay.
		//
		if (theSelection != null && !theSelection.isEmpty()) {
			// I don't know if this should be run this deferred
			// because we might have to give the editor a chance to process the viewer update events
			// and hence to update the views first.
			//
			//
			Runnable runnable =
				new Runnable() {
					public void run() {
						// Try to select the items in the current content viewer of the editor.
						//
						if (currentViewer != null) {
							currentViewer.setSelection(new StructuredSelection(theSelection.toArray()), true);
						}
					}
				};
			runnable.run();
		}
	}

	/**
	 * This returns the editing domain as required by the {@@link IEditingDomainProvider} interface.
	 * This is important for implementing the static methods of {@@link AdapterFactoryEditingDomain}
	 * and for supporting {@@link org.eclipse.emf.edit.ui.action.CommandAction}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public EditingDomain getEditingDomain() {
		return editingDomain;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public class ReverseAdapterFactoryContentProvider extends AdapterFactoryContentProvider {
		public ReverseAdapterFactoryContentProvider(AdapterFactory adapterFactory) {
			super(adapterFactory);
		}

		public Object [] getElements(Object object) {
			Object parent = super.getParent(object);
			return (parent == null ? Collections.EMPTY_SET : Collections.singleton(parent)).toArray();
		}

		public Object [] getChildren(Object object) {
			Object parent = super.getParent(object);
			return (parent == null ? Collections.EMPTY_SET : Collections.singleton(parent)).toArray();
		}

		public boolean hasChildren(Object object) {
			Object parent = super.getParent(object);
			return parent != null;
		}

		public Object getParent(Object object) {
			return null;
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void setCurrentViewerPane(ViewerPane viewerPane) {
		if (currentViewerPane != viewerPane) {
			if (currentViewerPane != null) {
				currentViewerPane.showFocus(false);
			}
			currentViewerPane = viewerPane;
		}
		setCurrentViewer(currentViewerPane.getViewer());
	}

	/**
	 * This makes sure that one content viewer, either for the current page or the outline view, if it has focus,
	 * is the current one.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void setCurrentViewer(Viewer viewer) {
		// If it is changing...
		//
		if (currentViewer != viewer) {
			if (selectionChangedListener == null) {
				// Create the listener on demand.
				//
				selectionChangedListener =
					new ISelectionChangedListener() {
						// This just notifies those things that are affected by the section.
						//
						public void selectionChanged(SelectionChangedEvent selectionChangedEvent) {
							setSelection(selectionChangedEvent.getSelection());
						}
					};
			}

			// Stop listening to the old one.
			//
			if (currentViewer != null) {
				currentViewer.removeSelectionChangedListener(selectionChangedListener);
			}

			// Start listening to the new one.
			//
			if (viewer != null) {
				viewer.addSelectionChangedListener(selectionChangedListener);
			}

			// Remember it.
			//
			currentViewer = viewer;

			// Set the editors selection based on the current viewer's selection.
			//
			setSelection(currentViewer == null ? StructuredSelection.EMPTY : currentViewer.getSelection());
		}
	}

	/**
	 * This returns the viewer as required by the {@@link IViewerProvider} interface.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public Viewer getViewer() {
		return currentViewer;
	}

	/**
	 * This creates a context menu for the viewer and adds a listener as well registering the menu for extension.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void createContextMenuFor(StructuredViewer viewer) {
		MenuManager contextMenu = new MenuManager("#PopUp");
		contextMenu.add(new Separator("additions"));
		contextMenu.setRemoveAllWhenShown(true);
		contextMenu.addMenuListener(this);
		Menu menu= contextMenu.createContextMenu(viewer.getControl());
		viewer.getControl().setMenu(menu);
		getSite().registerContextMenu(contextMenu, new UnwrappingSelectionProvider(viewer));

		int dndOperations = DND.DROP_COPY | DND.DROP_MOVE | DND.DROP_LINK;
		Transfer[] transfers = new Transfer[] { LocalTransfer.getInstance() };
		viewer.addDragSupport(dndOperations, transfers, new ViewerDragAdapter(viewer));
		viewer.addDropSupport(dndOperations, transfers, new EditingDomainViewerDropAdapter(editingDomain, viewer));
	}

	public void createModel() {
		if (getEditorInput() instanceof IFileEditorInput) {
			createModelGen();
		} else {
			Exception exception = null;
			Resource resource = null;
			IStorageEditorInput storageEditorInput = (IStorageEditorInput)getEditorInput();
			try
			{
				IStorage storage = storageEditorInput.getStorage();
				resource = editingDomain.createResource("*.gmfmap");
				resource.setURI(URI.createURI(storage.getFullPath().toString()));
				resource.load(storage.getContents(), null);
			}
			catch (Exception e)
			{
				exception = e;
			}

			Diagnostic diagnostic = analyzeResourceProblems(resource, exception);
			if (diagnostic.getSeverity() != Diagnostic.OK)
			{
				resourceToDiagnosticMap.put(resource,  analyzeResourceProblems(resource, exception));
			}
			editingDomain.getResourceSet().eAdapters().add(problemIndicationAdapter);      
		}
		
	}

	/**
	 * This is the method called to load a resource into the editing domain's resource set based on the editor's input.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void createModelGen() {
		URI resourceURI = EditUIUtil.getURI(getEditorInput());
		Exception exception = null;
		Resource resource = null;
		try {
			// Load the resource through the editing domain.
			//
			resource = editingDomain.getResourceSet().getResource(resourceURI, true);
		}
		catch (Exception e) {
			exception = e;
			resource = editingDomain.getResourceSet().getResource(resourceURI, false);
		}

		Diagnostic diagnostic = analyzeResourceProblems(resource, exception);
		if (diagnostic.getSeverity() != Diagnostic.OK) {
			resourceToDiagnosticMap.put(resource,  analyzeResourceProblems(resource, exception));
		}
		editingDomain.getResourceSet().eAdapters().add(problemIndicationAdapter);
	}

	/**
	 * Returns a diagnostic describing the errors and warnings listed in the resource
	 * and the specified exception (if any).
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public Diagnostic analyzeResourceProblems(Resource resource, Exception exception) {
		if (!resource.getErrors().isEmpty() || !resource.getWarnings().isEmpty()) {
			BasicDiagnostic basicDiagnostic =
				new BasicDiagnostic
					(Diagnostic.ERROR,
					 "org.eclipse.gmf.map.edit",
					 0,
					 getString("_UI_CreateModelError_message", resource.getURI()),
					 new Object [] { exception == null ? (Object)resource : exception });
			basicDiagnostic.merge(EcoreUtil.computeDiagnostic(resource, true));
			return basicDiagnostic;
		}
		else if (exception != null) {
			return
				new BasicDiagnostic
					(Diagnostic.ERROR,
					 "org.eclipse.gmf.map.edit",
					 0,
					 getString("_UI_CreateModelError_message", resource.getURI()),
					 new Object[] { exception });
		}
		else {
			return Diagnostic.OK_INSTANCE;
		}
	}

	/**
	 * This is the method used by the framework to install your own controls.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public void createPages() {
		// Creates the model from the editor input
		//
		createModel();

		// Only creates the other pages if there is something that can be edited
		//
		if (!getEditingDomain().getResourceSet().getResources().isEmpty()) {
			// Create a page for the selection tree view.
			//
			{
				ViewerPane viewerPane =
					new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
						@@Override
						public Viewer createViewer(Composite composite) {
							Tree tree = new Tree(composite, SWT.MULTI);
							TreeViewer newTreeViewer = new TreeViewer(tree);
							return newTreeViewer;
						}
						@@Override
						public void requestActivation() {
							super.requestActivation();
							setCurrentViewerPane(this);
						}
					};
				viewerPane.createControl(getContainer());

				selectionViewer = (TreeViewer)viewerPane.getViewer();
				selectionViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));

				selectionViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));
				selectionViewer.setInput(editingDomain.getResourceSet());
				selectionViewer.setSelection(new StructuredSelection(editingDomain.getResourceSet().getResources().get(0)), true);
				viewerPane.setTitle(editingDomain.getResourceSet());

				new AdapterFactoryTreeEditor(selectionViewer.getTree(), adapterFactory);

				createContextMenuFor(selectionViewer);
				int pageIndex = addPage(viewerPane.getControl());
				setPageText(pageIndex, getString("_UI_SelectionPage_label"));
			}

			// Create a page for the parent tree view.
			//
			{
				ViewerPane viewerPane =
					new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
						@@Override
						public Viewer createViewer(Composite composite) {
							Tree tree = new Tree(composite, SWT.MULTI);
							TreeViewer newTreeViewer = new TreeViewer(tree);
							return newTreeViewer;
						}
						@@Override
						public void requestActivation() {
							super.requestActivation();
							setCurrentViewerPane(this);
						}
					};
				viewerPane.createControl(getContainer());

				parentViewer = (TreeViewer)viewerPane.getViewer();
				parentViewer.setAutoExpandLevel(30);
				parentViewer.setContentProvider(new ReverseAdapterFactoryContentProvider(adapterFactory));
				parentViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));

				createContextMenuFor(parentViewer);
				int pageIndex = addPage(viewerPane.getControl());
				setPageText(pageIndex, getString("_UI_ParentPage_label"));
			}

			// This is the page for the list viewer
			//
			{
				ViewerPane viewerPane =
					new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
						@@Override
						public Viewer createViewer(Composite composite) {
							return new ListViewer(composite);
						}
						@@Override
						public void requestActivation() {
							super.requestActivation();
							setCurrentViewerPane(this);
						}
					};
				viewerPane.createControl(getContainer());
				listViewer = (ListViewer)viewerPane.getViewer();
				listViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
				listViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));

				createContextMenuFor(listViewer);
				int pageIndex = addPage(viewerPane.getControl());
				setPageText(pageIndex, getString("_UI_ListPage_label"));
			}

			// This is the page for the tree viewer
			//
			{
				ViewerPane viewerPane =
					new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
						@@Override
						public Viewer createViewer(Composite composite) {
							return new TreeViewer(composite);
						}
						@@Override
						public void requestActivation() {
							super.requestActivation();
							setCurrentViewerPane(this);
						}
					};
				viewerPane.createControl(getContainer());
				treeViewer = (TreeViewer)viewerPane.getViewer();
				treeViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
				treeViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));

				new AdapterFactoryTreeEditor(treeViewer.getTree(), adapterFactory);

				createContextMenuFor(treeViewer);
				int pageIndex = addPage(viewerPane.getControl());
				setPageText(pageIndex, getString("_UI_TreePage_label"));
			}

			// This is the page for the table viewer.
			//
			{
				ViewerPane viewerPane =
					new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
						@@Override
						public Viewer createViewer(Composite composite) {
							return new TableViewer(composite);
						}
						@@Override
						public void requestActivation() {
							super.requestActivation();
							setCurrentViewerPane(this);
						}
					};
				viewerPane.createControl(getContainer());
				tableViewer = (TableViewer)viewerPane.getViewer();

				Table table = tableViewer.getTable();
				TableLayout layout = new TableLayout();
				table.setLayout(layout);
				table.setHeaderVisible(true);
				table.setLinesVisible(true);

				TableColumn objectColumn = new TableColumn(table, SWT.NONE);
				layout.addColumnData(new ColumnWeightData(3, 100, true));
				objectColumn.setText(getString("_UI_ObjectColumn_label"));
				objectColumn.setResizable(true);

				TableColumn selfColumn = new TableColumn(table, SWT.NONE);
				layout.addColumnData(new ColumnWeightData(2, 100, true));
				selfColumn.setText(getString("_UI_SelfColumn_label"));
				selfColumn.setResizable(true);

				tableViewer.setColumnProperties(new String [] {"a", "b"});
				tableViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
				tableViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));

				createContextMenuFor(tableViewer);
				int pageIndex = addPage(viewerPane.getControl());
				setPageText(pageIndex, getString("_UI_TablePage_label"));
			}

			// This is the page for the table tree viewer.
			//
			{
				ViewerPane viewerPane =
					new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
						@@Override
						public Viewer createViewer(Composite composite) {
							return new TreeViewer(composite);
						}
						@@Override
						public void requestActivation() {
							super.requestActivation();
							setCurrentViewerPane(this);
						}
					};
				viewerPane.createControl(getContainer());

				treeViewerWithColumns = (TreeViewer)viewerPane.getViewer();

				Tree tree = treeViewerWithColumns.getTree();
				tree.setLayoutData(new FillLayout());
				tree.setHeaderVisible(true);
				tree.setLinesVisible(true);

				TreeColumn objectColumn = new TreeColumn(tree, SWT.NONE);
				objectColumn.setText(getString("_UI_ObjectColumn_label"));
				objectColumn.setResizable(true);
				objectColumn.setWidth(250);

				TreeColumn selfColumn = new TreeColumn(tree, SWT.NONE);
				selfColumn.setText(getString("_UI_SelfColumn_label"));
				selfColumn.setResizable(true);
				selfColumn.setWidth(200);

				treeViewerWithColumns.setColumnProperties(new String [] {"a", "b"});
				treeViewerWithColumns.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
				treeViewerWithColumns.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));

				createContextMenuFor(treeViewerWithColumns);
				int pageIndex = addPage(viewerPane.getControl());
				setPageText(pageIndex, getString("_UI_TreeWithColumnsPage_label"));
			}

			getSite().getShell().getDisplay().asyncExec
				(new Runnable() {
					 public void run() {
						 setActivePage(0);
					 }
				 });
		}

		// Ensures that this editor will only display the page's tab
		// area if there are more than one page
		//
		getContainer().addControlListener
			(new ControlAdapter() {
				boolean guard = false;
				@@Override
				public void controlResized(ControlEvent event) {
					if (!guard) {
						guard = true;
						hideTabs();
						guard = false;
					}
				}
			 });

		getSite().getShell().getDisplay().asyncExec
			(new Runnable() {
				 public void run() {
					 updateProblemIndication();
				 }
			 });
	}

	/**
	 * If there is just one page in the multi-page editor part,
	 * this hides the single tab at the bottom.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void hideTabs() {
		if (getPageCount() <= 1) {
			setPageText(0, "");
			if (getContainer() instanceof CTabFolder) {
				((CTabFolder)getContainer()).setTabHeight(1);
				Point point = getContainer().getSize();
				getContainer().setSize(point.x, point.y + 6);
			}
		}
	}

	/**
	 * If there is more than one page in the multi-page editor part,
	 * this shows the tabs at the bottom.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void showTabs() {
		if (getPageCount() > 1) {
			setPageText(0, getString("_UI_SelectionPage_label"));
			if (getContainer() instanceof CTabFolder) {
				((CTabFolder)getContainer()).setTabHeight(SWT.DEFAULT);
				Point point = getContainer().getSize();
				getContainer().setSize(point.x, point.y - 6);
			}
		}
	}

	/**
	 * This is used to track the active viewer.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	protected void pageChange(int pageIndex) {
		super.pageChange(pageIndex);

		if (contentOutlinePage != null) {
			handleContentOutlineSelection(contentOutlinePage.getSelection());
		}
	}

	/**
	 * This is how the framework determines which interfaces we implement.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@SuppressWarnings("unchecked")
		@@Override
	public Object getAdapter(Class key) {
		if (key.equals(IContentOutlinePage.class)) {
			return showOutlineView() ? getContentOutlinePage() : null;
		}
		else if (key.equals(IPropertySheetPage.class)) {
			return getPropertySheetPage();
		}
		else if (key.equals(IGotoMarker.class)) {
			return this;
		}
		else {
			return super.getAdapter(key);
		}
	}

	/**
	 * This accesses a cached version of the content outliner.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public IContentOutlinePage getContentOutlinePage() {
		if (contentOutlinePage == null) {
			// The content outline is just a tree.
			//
			class MyContentOutlinePage extends ContentOutlinePage {
				@@Override
				public void createControl(Composite parent) {
					super.createControl(parent);
					contentOutlineViewer = getTreeViewer();
					contentOutlineViewer.addSelectionChangedListener(this);

					// Set up the tree viewer.
					//
					contentOutlineViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
					contentOutlineViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));
					contentOutlineViewer.setInput(editingDomain.getResourceSet());

					// Make sure our popups work.
					//
					createContextMenuFor(contentOutlineViewer);

					if (!editingDomain.getResourceSet().getResources().isEmpty()) {
					  // Select the root object in the view.
					  //
					  contentOutlineViewer.setSelection(new StructuredSelection(editingDomain.getResourceSet().getResources().get(0)), true);
					}
				}

				@@Override
				public void makeContributions(IMenuManager menuManager, IToolBarManager toolBarManager, IStatusLineManager statusLineManager) {
					super.makeContributions(menuManager, toolBarManager, statusLineManager);
					contentOutlineStatusLineManager = statusLineManager;
				}

				@@Override
				public void setActionBars(IActionBars actionBars) {
					super.setActionBars(actionBars);
					getActionBarContributor().shareGlobalActions(this, actionBars);
				}
			}

			contentOutlinePage = new MyContentOutlinePage();

			// Listen to selection so that we can handle it is a special way.
			//
			contentOutlinePage.addSelectionChangedListener
				(new ISelectionChangedListener() {
					 // This ensures that we handle selections correctly.
					 //
					 public void selectionChanged(SelectionChangedEvent event) {
						 handleContentOutlineSelection(event.getSelection());
					 }
				 });
		}

		return contentOutlinePage;
	}

	/**
	 * This accesses a cached version of the property sheet.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public IPropertySheetPage getPropertySheetPage() {
		if (propertySheetPage == null) {
			propertySheetPage =
				new ExtendedPropertySheetPage(editingDomain) {
					@@Override
					public void setSelectionToViewer(List<?> selection) {
						GMFMapEditor.this.setSelectionToViewer(selection);
						GMFMapEditor.this.setFocus();
					}

					@@Override
					public void setActionBars(IActionBars actionBars) {
						super.setActionBars(actionBars);
						getActionBarContributor().shareGlobalActions(this, actionBars);
					}
				};
			propertySheetPage.setPropertySourceProvider(new AdapterFactoryContentProvider(adapterFactory));
		}

		return propertySheetPage;
	}

	/**
	 * This deals with how we want selection in the outliner to affect the other views.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void handleContentOutlineSelection(ISelection selection) {
		if (currentViewerPane != null && !selection.isEmpty() && selection instanceof IStructuredSelection) {
			Iterator<?> selectedElements = ((IStructuredSelection)selection).iterator();
			if (selectedElements.hasNext()) {
				// Get the first selected element.
				//
				Object selectedElement = selectedElements.next();

				// If it's the selection viewer, then we want it to select the same selection as this selection.
				//
				if (currentViewerPane.getViewer() == selectionViewer) {
					ArrayList<Object> selectionList = new ArrayList<Object>();
					selectionList.add(selectedElement);
					while (selectedElements.hasNext()) {
						selectionList.add(selectedElements.next());
					}

					// Set the selection to the widget.
					//
					selectionViewer.setSelection(new StructuredSelection(selectionList));
				}
				else {
					// Set the input to the widget.
					//
					if (currentViewerPane.getViewer().getInput() != selectedElement) {
						currentViewerPane.getViewer().setInput(selectedElement);
						currentViewerPane.setTitle(selectedElement);
					}
				}
			}
		}
	}

	/**
	 * This is for implementing {@@link IEditorPart} and simply tests the command stack.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public boolean isDirty() {
		return ((BasicCommandStack)editingDomain.getCommandStack()).isSaveNeeded();
	}

	/**
	 * This is for implementing {@@link IEditorPart} and simply saves the model file.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public void doSave(IProgressMonitor progressMonitor) {
		// Save only resources that have actually changed.
		//
		final Map<Object, Object> saveOptions = new HashMap<Object, Object>();
		saveOptions.put(Resource.OPTION_SAVE_ONLY_IF_CHANGED, Resource.OPTION_SAVE_ONLY_IF_CHANGED_MEMORY_BUFFER);

		// Do the work within an operation because this is a long running activity that modifies the workbench.
		//
		WorkspaceModifyOperation operation =
			new WorkspaceModifyOperation() {
				// This is the method that gets invoked when the operation runs.
				//
				@@Override
				public void execute(IProgressMonitor monitor) {
					// Save the resources to the file system.
					//
					boolean first = true;
					for (Resource resource : editingDomain.getResourceSet().getResources()) {
						if ((first || !resource.getContents().isEmpty() || isPersisted(resource)) && !editingDomain.isReadOnly(resource)) {
							try {
								long timeStamp = resource.getTimeStamp();
								resource.save(saveOptions);
								if (resource.getTimeStamp() != timeStamp) {
									savedResources.add(resource);
								}
							}
							catch (Exception exception) {
								resourceToDiagnosticMap.put(resource, analyzeResourceProblems(resource, exception));
							}
							first = false;
						}
					}
				}
			};

		updateProblemIndication = false;
		try {
			// This runs the options, and shows progress.
			//
			new ProgressMonitorDialog(getSite().getShell()).run(true, false, operation);

			// Refresh the necessary state.
			//
			((BasicCommandStack)editingDomain.getCommandStack()).saveIsDone();
			firePropertyChange(IEditorPart.PROP_DIRTY);
		}
		catch (Exception exception) {
			// Something went wrong that shouldn't.
			//
			GMFMapEditPlugin.INSTANCE.log(exception);
		}
		updateProblemIndication = true;
		updateProblemIndication();
	}

	/**
	 * This returns whether something has been persisted to the URI of the specified resource.
	 * The implementation uses the URI converter from the editor's resource set to try to open an input stream. 
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected boolean isPersisted(Resource resource) {
		boolean result = false;
		try {
			InputStream stream = editingDomain.getResourceSet().getURIConverter().createInputStream(resource.getURI());
			if (stream != null) {
				result = true;
				stream.close();
			}
		}
		catch (IOException e) {
			// Ignore
		}
		return result;
	}

	/**
	 * This always returns true because it is not currently supported.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public boolean isSaveAsAllowed() {
		return true;
	}

	/**
	 * This also changes the editor's input.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public void doSaveAs() {
		SaveAsDialog saveAsDialog = new SaveAsDialog(getSite().getShell());
		saveAsDialog.open();
		IPath path = saveAsDialog.getResult();
		if (path != null) {
			IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(path);
			if (file != null) {
				doSaveAs(URI.createPlatformResourceURI(file.getFullPath().toString(), true), new FileEditorInput(file));
			}
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void doSaveAs(URI uri, IEditorInput editorInput) {
		(editingDomain.getResourceSet().getResources().get(0)).setURI(uri);
		setInputWithNotify(editorInput);
		setPartName(editorInput.getName());
		IProgressMonitor progressMonitor =
			getActionBars().getStatusLineManager() != null ?
				getActionBars().getStatusLineManager().getProgressMonitor() :
				new NullProgressMonitor();
		doSave(progressMonitor);
	}

	/**
	 * <!-- begin-user-doc -->
	 * Ensures that the tree editor page is selected for the marker target navigation
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	public void gotoMarker(IMarker marker) {
		updateProblemIndication = false;
		try {
			setActivePage(0);
			gotoMarkerGen(marker);
		} finally {
			updateProblemIndication = true;
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */	
	public void gotoMarkerGen(IMarker marker) {
		try {
			if (marker.getType().equals(EValidator.MARKER)) {
				String uriAttribute = marker.getAttribute(EValidator.URI_ATTRIBUTE, null);
				if (uriAttribute != null) {
					URI uri = URI.createURI(uriAttribute);
					EObject eObject = editingDomain.getResourceSet().getEObject(uri, true);
					if (eObject != null) {
					  setSelectionToViewer(Collections.singleton(editingDomain.getWrapper(eObject)));
					}
				}
			}
		}
		catch (CoreException exception) {
			GMFMapEditPlugin.INSTANCE.log(exception);
		}
	}

	/**
	 * This is called during startup.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public void init(IEditorSite site, IEditorInput editorInput) {
		setSite(site);
		setInputWithNotify(editorInput);
		setPartName(editorInput.getName());
		site.setSelectionProvider(this);
		site.getPage().addPartListener(partListener);
		ResourcesPlugin.getWorkspace().addResourceChangeListener(resourceChangeListener, IResourceChangeEvent.POST_CHANGE);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public void setFocus() {
		if (currentViewerPane != null) {
			currentViewerPane.setFocus();
		}
		else {
			getControl(getActivePage()).setFocus();
		}
	}

	/**
	 * This implements {@@link org.eclipse.jface.viewers.ISelectionProvider}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void addSelectionChangedListener(ISelectionChangedListener listener) {
		selectionChangedListeners.add(listener);
	}

	/**
	 * This implements {@@link org.eclipse.jface.viewers.ISelectionProvider}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void removeSelectionChangedListener(ISelectionChangedListener listener) {
		selectionChangedListeners.remove(listener);
	}

	/**
	 * This implements {@@link org.eclipse.jface.viewers.ISelectionProvider} to return this editor's overall selection.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public ISelection getSelection() {
		return editorSelection;
	}

	/**
	 * This implements {@@link org.eclipse.jface.viewers.ISelectionProvider} to set this editor's overall selection.
	 * Calling this result will notify the listeners.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void setSelection(ISelection selection) {
		editorSelection = selection;

		for (ISelectionChangedListener listener : selectionChangedListeners) {
			listener.selectionChanged(new SelectionChangedEvent(this, selection));
		}
		setStatusLineManager(selection);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void setStatusLineManager(ISelection selection) {
		IStatusLineManager statusLineManager = currentViewer != null && currentViewer == contentOutlineViewer ?
			contentOutlineStatusLineManager : getActionBars().getStatusLineManager();

		if (statusLineManager != null) {
			if (selection instanceof IStructuredSelection) {
				Collection<?> collection = ((IStructuredSelection)selection).toList();
				switch (collection.size()) {
					case 0: {
						statusLineManager.setMessage(getString("_UI_NoObjectSelected"));
						break;
					}
					case 1: {
						String text = new AdapterFactoryItemDelegator(adapterFactory).getText(collection.iterator().next());
						statusLineManager.setMessage(getString("_UI_SingleObjectSelected", text));
						break;
					}
					default: {
						statusLineManager.setMessage(getString("_UI_MultiObjectSelected", Integer.toString(collection.size())));
						break;
					}
				}
			}
			else {
				statusLineManager.setMessage("");
			}
		}
	}

	/**
	 * This looks up a string in the plugin's plugin.properties file.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	private static String getString(String key) {
		return GMFMapEditPlugin.INSTANCE.getString(key);
	}

	/**
	 * This looks up a string in plugin.properties, making a substitution.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	private static String getString(String key, Object s1) {
		return GMFMapEditPlugin.INSTANCE.getString(key, new Object [] { s1 });
	}

	/**
	 * This implements {@@link org.eclipse.jface.action.IMenuListener} to help fill the context menus with contributions from the Edit menu.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void menuAboutToShow(IMenuManager menuManager) {
		((IMenuListener)getEditorSite().getActionBarContributor()).menuAboutToShow(menuManager);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public EditingDomainActionBarContributor getActionBarContributor() {
		return (EditingDomainActionBarContributor)getEditorSite().getActionBarContributor();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public IActionBars getActionBars() {
		return getActionBarContributor().getActionBars();
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public AdapterFactory getAdapterFactory() {
		return adapterFactory;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public void dispose() {
		updateProblemIndication = false;

		ResourcesPlugin.getWorkspace().removeResourceChangeListener(resourceChangeListener);

		getSite().getPage().removePartListener(partListener);

		adapterFactory.dispose();

		if (getActionBarContributor().getActiveEditor() == this) {
			getActionBarContributor().setActiveEditor(null);
		}

		if (propertySheetPage != null) {
			propertySheetPage.dispose();
		}

		if (contentOutlinePage != null) {
			contentOutlinePage.dispose();
		}

		super.dispose();
	}

	/**
	 * Returns whether the outline view should be presented to the user.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected boolean showOutlineView() {
		return true;
	}
}
@


1.22
log
@[163079] help identify domain features in mapping model
@
text
@d1455 1
a1455 1
								savedResources.add(resource);
d1457 3
@


1.21
log
@[235797] SWT Exception and unstable workbench after model file rename
@
text
@a8 1

a49 1
import org.eclipse.emf.ecore.provider.EcoreItemProviderAdapterFactory;
d73 1
d645 2
d659 1
a659 1
		adapterFactory.addAdapterFactory(new EcoreItemProviderAdapterFactory());
@


1.21.2.1
log
@[163079] help identify domain features in mapping model. Merge from HEAD
@
text
@d9 1
d51 1
a74 1
import org.eclipse.gmf.mappings.provider.EcoreItemProviderAdapterFactoryEx;
a645 2
	 * Do not forget to use EcoreItemProviderAdapterFactoryEx
	 * instead of default
d658 1
a658 1
		adapterFactory.addAdapterFactory(new EcoreItemProviderAdapterFactoryEx());
@


1.20
log
@regenerated with EMF M6
@
text
@a471 1
										 GMFMapEditor.this.dispose();
a512 1
				GMFMapEditor.this.dispose();
@


1.19
log
@[220711] respect workspace resource models
@
text
@d979 1
a979 2
		if (!getEditingDomain().getResourceSet().getResources().isEmpty() &&
		    !(getEditingDomain().getResourceSet().getResources().get(0)).getContents().isEmpty()) {
@


1.18
log
@regenerated with EMF 2.4M5
@
text
@d50 1
d651 1
a651 1
	protected void initializeEditingDomain() {
d696 5
@


1.17
log
@regenerated with latest emf
@
text
@d71 1
d426 18
a443 22
				// Only listening to these.
				// if (event.getType() == IResourceDelta.POST_CHANGE)
				{
					IResourceDelta delta = event.getDelta();
					try {
						class ResourceDeltaVisitor implements IResourceDeltaVisitor {
							protected ResourceSet resourceSet = editingDomain.getResourceSet();
							protected Collection<Resource> changedResources = new ArrayList<Resource>();
							protected Collection<Resource> removedResources = new ArrayList<Resource>();

							public boolean visit(IResourceDelta delta) {
								if (delta.getFlags() != IResourceDelta.MARKERS &&
								    delta.getResource().getType() == IResource.FILE) {
									if ((delta.getKind() & (IResourceDelta.CHANGED | IResourceDelta.REMOVED)) != 0) {
										Resource resource = resourceSet.getResource(URI.createURI(delta.getFullPath().toString()), false);
										if (resource != null) {
											if ((delta.getKind() & IResourceDelta.REMOVED) != 0) {
												removedResources.add(resource);
											}
											else if (!savedResources.remove(resource)) {
												changedResources.add(resource);
											}
d447 1
d449 2
a450 2
								return true;
							}
d452 3
a454 3
							public Collection<Resource> getChangedResources() {
								return changedResources;
							}
d456 2
a457 3
							public Collection<Resource> getRemovedResources() {
								return removedResources;
							}
d459 1
d461 2
a462 2
						ResourceDeltaVisitor visitor = new ResourceDeltaVisitor();
						delta.accept(visitor);
d464 10
a473 11
						if (!visitor.getRemovedResources().isEmpty()) {
							removedResources.addAll(visitor.getRemovedResources());
							if (!isDirty()) {
								getSite().getShell().getDisplay().asyncExec
									(new Runnable() {
										 public void run() {
											 getSite().getPage().closeEditor(GMFMapEditor.this, false);
											 GMFMapEditor.this.dispose();
										 }
									 });
							}
d475 1
d477 9
a485 10
						if (!visitor.getChangedResources().isEmpty()) {
							changedResources.addAll(visitor.getChangedResources());
							if (getSite().getPage().getActiveEditor() == GMFMapEditor.this) {
								getSite().getShell().getDisplay().asyncExec
									(new Runnable() {
										 public void run() {
											 handleActivate();
										 }
									 });
							}
d488 3
a490 3
					catch (CoreException exception) {
						GMFMapEditPlugin.INSTANCE.log(exception);
					}
d535 3
d554 5
d906 1
a906 4
		// Assumes that the input is a file object.
		//
		IFileEditorInput modelFile = (IFileEditorInput)getEditorInput();
		URI resourceURI = URI.createPlatformResourceURI(modelFile.getFile().getFullPath().toString(), true);
d927 1
a927 1
	 * Returns a dignostic describing the errors and warnings listed in the resource
d1176 6
a1181 1
			setActivePage(0);
d1200 6
a1205 1
		updateProblemIndication();
d1484 1
a1484 1
	 * This returns wether something has been persisted to the URI of the specified resource.
@


1.16
log
@[186401] better labels for ecore element comboboxes
@
text
@d69 1
d636 2
d639 7
d648 1
a648 7
		List<AdapterFactory> factories = new ArrayList<AdapterFactory>();
		factories.add(new ResourceItemProviderAdapterFactory());
		factories.add(new GMFMapItemProviderAdapterFactory());
		factories.add(new GMFGraphItemProviderAdapterFactory());
		factories.add(new GMFToolItemProviderAdapterFactory());
		factories.add(new EcoreItemProviderAdapterFactory());
		factories.add(new ReflectiveItemProviderAdapterFactory());
d650 6
a655 1
		adapterFactory = new ComposedAdapterFactory(factories);
d857 1
a857 1
		getSite().registerContextMenu(contextMenu, viewer);
d1420 5
d1440 1
a1440 1
								resource.save(Collections.EMPTY_MAP);
@


1.15
log
@EMF.Edit and editor were regenerated with EMF M6
@
text
@d50 1
d643 1
@


1.14
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@d378 1
a378 1
							Diagnostic diagnostic = analyzeResourceProblems((Resource)notification.getNotifier(), null);
@


1.13
log
@Ensure that the tree editor page is selected for the marker's target navigation
@
text
@d269 1
a269 1
	protected Collection selectionChangedListeners = new ArrayList();
d315 1
d318 1
d321 1
d324 1
d332 1
a332 1
	protected Collection removedResources = new ArrayList();
d338 1
a338 1
	protected Collection changedResources = new ArrayList();
d344 1
a344 1
	protected Collection savedResources = new ArrayList();
d352 1
a352 1
	protected Map resourceToDiagnosticMap = new LinkedHashMap();
d370 1
d394 1
d403 1
d408 1
d430 2
a431 2
							protected Collection changedResources = new ArrayList();
							protected Collection removedResources = new ArrayList();
d452 1
a452 1
							public Collection getChangedResources() {
d456 1
a456 1
							public Collection getRemovedResources() {
d539 1
a539 2
			for (Iterator i = changedResources.iterator(); i.hasNext(); ) {
				Resource resource = (Resource)i.next();
d572 1
a572 2
			for (Iterator i = resourceToDiagnosticMap.values().iterator(); i.hasNext(); ) {
				Diagnostic childDiagnostic = (Diagnostic)i.next();
d637 1
a637 1
		List factories = new ArrayList();
d676 1
a676 1
		editingDomain = new AdapterFactoryEditingDomain(adapterFactory, commandStack, new HashMap());
d685 1
d696 2
a697 2
	public void setSelectionToViewer(Collection collection) {
		final Collection theSelection = collection;
d893 1
a893 1
		URI resourceURI = URI.createPlatformResourceURI(modelFile.getFile().getFullPath().toString());;
d952 1
d961 1
a961 1
		    !((Resource)getEditingDomain().getResourceSet().getResources().get(0)).getContents().isEmpty()) {
d967 1
d973 1
d986 1
d1001 1
d1007 1
d1030 1
d1034 1
d1055 1
d1059 1
d1082 1
d1086 1
d1125 1
d1129 1
d1172 1
d1227 1
d1242 2
d1270 1
d1289 1
a1289 3
					  ArrayList selection = new ArrayList();
					  selection.add(editingDomain.getResourceSet().getResources().get(0));
					  contentOutlineViewer.setSelection(new StructuredSelection(selection), true);
d1293 1
d1299 1
d1333 2
a1334 1
					public void setSelectionToViewer(List selection) {
d1339 1
d1359 1
a1359 1
			Iterator selectedElements = ((IStructuredSelection)selection).iterator();
d1368 1
a1368 1
					ArrayList selectionList = new ArrayList();
d1396 1
d1407 1
d1415 1
d1420 1
a1420 2
					for (Iterator i = editingDomain.getResourceSet().getResources().iterator(); i.hasNext(); ) {
						Resource resource = (Resource)i.next();
d1472 1
d1483 1
d1494 1
d1496 1
a1496 1
		SaveAsDialog saveAsDialog= new SaveAsDialog(getSite().getShell());
d1498 1
a1498 1
		IPath path= saveAsDialog.getResult();
d1502 1
a1502 1
				doSaveAs(URI.createPlatformResourceURI(file.getFullPath().toString()), new FileEditorInput(file));
d1513 1
a1513 1
		((Resource)editingDomain.getResourceSet().getResources().get(0)).setURI(uri);
d1568 1
d1583 1
d1633 1
a1633 2
		for (Iterator listeners = selectionChangedListeners.iterator(); listeners.hasNext(); ) {
			ISelectionChangedListener listener = (ISelectionChangedListener)listeners.next();
d1650 1
a1650 1
				Collection collection = ((IStructuredSelection)selection).toList();
d1735 1
@


1.12
log
@#138440 Modify Feature Sequence initializer to support containment references to model elements
@
text
@a11 1

d18 1
a19 1

a20 1
import java.util.LinkedHashMap;
a38 3
import org.eclipse.emf.common.util.BasicDiagnostic;
import org.eclipse.emf.common.util.Diagnostic;

d41 1
a41 1

d45 2
d52 1
a53 2
import org.eclipse.emf.ecore.util.EContentAdapter;

d68 1
a69 3
import org.eclipse.emf.common.ui.MarkerHelper;
import org.eclipse.emf.edit.ui.util.EditUIMarkerHelper;

a117 1

d1492 1
d1494 1
a1494 1
	 * @@generated
d1497 15
@


1.11
log
@#144264 ClassCastException when opening remote file
@
text
@d853 1
a853 1
	
@


1.10
log
@#145042 Introduce expression Language enumeration into gmfmap, gfmgen models  instead of plain text attribute
@
text
@d31 1
d121 1
d853 29
d889 1
a889 1
	public void createModel() {
@


1.9
log
@regenerated with EMF RC3 to fix illegal thread access issue
@
text
@d589 1
a589 3
					showTabs();
					addPage(getPageCount(), problemEditorPart, getEditorInput());
					lastEditorPage++;
d592 1
d1140 2
a1141 2
	 * If there is just one page in the multi-page editor part, this hides
	 * the single tab at the bottom.
d1158 2
a1159 2
	 * If there is just one page in the multi-page editor part, this shows
	 * the single tab at the bottom.
d1165 1
a1165 1
		if (getPageCount() == 1) {
d1662 2
@


1.8
log
@regenerated with EMF RC2
@
text
@d385 9
a393 1
							updateProblemIndication();
d401 8
d566 1
a566 1
					 "org.eclipse.gmf.map.edit", 
d576 1
a576 1
			
d589 1
d666 1
a666 1
								  if (propertySheetPage != null) {
d873 1
a873 1
			resource = editingDomain.getResourceSet().getResource(resourceURI, false);			
d880 1
a880 1
		editingDomain.getResourceSet().eAdapters().add(problemIndicationAdapter);		
d882 1
a882 1
	
d895 1
a895 1
					 "org.eclipse.gmf.map.edit", 
d897 1
a897 1
					 getString("_UI_CreateModelError_message", resource.getURI()), 
d906 1
a906 1
					 "org.eclipse.gmf.map.edit", 
d908 1
a908 1
					 getString("_UI_CreateModelError_message", resource.getURI()), 
d915 1
a915 1
	
d1121 1
a1121 1
		
d1124 1
a1124 1
		//		
d1135 1
a1135 1
			 });		
d1159 18
d1198 1
a1198 1
			return getContentOutlinePage();
a1398 1
		
d1450 1
a1450 1
	
d1574 1
a1574 1
	
d1684 9
@


1.7
log
@#138464 Support EAttribute based target in AuditRule element
@
text
@d21 3
d40 3
d44 2
d47 1
d54 3
d72 3
d121 2
d285 9
d333 1
a333 1
	Collection removedResources = new ArrayList();
d339 1
a339 1
	Collection changedResources = new ArrayList();
d345 49
a393 1
	Collection savedResources = new ArrayList();
d416 1
a416 1
								      delta.getResource().getType() == IResource.FILE) {
a510 1

d517 1
a517 1
		  editingDomain.getCommandStack().flush();
d519 1
d528 62
d843 1
a843 1
		// I assume that the input is a file object.
d846 3
a848 1

d852 41
a892 1
			editingDomain.loadResource(URI.createPlatformResourceURI(modelFile.getFile().getFullPath().toString()).toString());
d894 2
a895 2
		catch (Exception exception) {
			GMFMapEditPlugin.INSTANCE.log(exception);
d898 1
a898 1

d910 1
a910 1
		// Create a page for the selection tree view.
d912 21
a932 14
		{
			ViewerPane viewerPane =
				new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
					public Viewer createViewer(Composite composite) {
						Tree tree = new Tree(composite, SWT.MULTI);
						TreeViewer newTreeViewer = new TreeViewer(tree);
						return newTreeViewer;
					}
					public void requestActivation() {
						super.requestActivation();
						setCurrentViewerPane(this);
					}
				};
			viewerPane.createControl(getContainer());
d934 3
a936 2
			selectionViewer = (TreeViewer)viewerPane.getViewer();
			selectionViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
d938 1
a938 3
			selectionViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));
			selectionViewer.setInput(editingDomain.getResourceSet());
			viewerPane.setTitle(editingDomain.getResourceSet());
d940 4
a943 1
			new AdapterFactoryTreeEditor(selectionViewer.getTree(), adapterFactory);
d945 16
a960 4
			createContextMenuFor(selectionViewer);
			int pageIndex = addPage(viewerPane.getControl());
			setPageText(pageIndex, getString("_UI_SelectionPage_label"));
		}
d962 4
a965 16
		// Create a page for the parent tree view.
		//
		{
			ViewerPane viewerPane =
				new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
					public Viewer createViewer(Composite composite) {
						Tree tree = new Tree(composite, SWT.MULTI);
						TreeViewer newTreeViewer = new TreeViewer(tree);
						return newTreeViewer;
					}
					public void requestActivation() {
						super.requestActivation();
						setCurrentViewerPane(this);
					}
				};
			viewerPane.createControl(getContainer());
d967 4
a970 4
			parentViewer = (TreeViewer)viewerPane.getViewer();
			parentViewer.setAutoExpandLevel(30);
			parentViewer.setContentProvider(new ReverseAdapterFactoryContentProvider(adapterFactory));
			parentViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));
d972 17
a988 4
			createContextMenuFor(parentViewer);
			int pageIndex = addPage(viewerPane.getControl());
			setPageText(pageIndex, getString("_UI_ParentPage_label"));
		}
d990 4
a993 17
		// This is the page for the list viewer
		//
		{
			ViewerPane viewerPane =
				new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
					public Viewer createViewer(Composite composite) {
						return new ListViewer(composite);
					}
					public void requestActivation() {
						super.requestActivation();
						setCurrentViewerPane(this);
					}
				};
			viewerPane.createControl(getContainer());
			listViewer = (ListViewer)viewerPane.getViewer();
			listViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
			listViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));
d995 17
a1011 4
			createContextMenuFor(listViewer);
			int pageIndex = addPage(viewerPane.getControl());
			setPageText(pageIndex, getString("_UI_ListPage_label"));
		}
d1013 1
a1013 17
		// This is the page for the tree viewer
		//
		{
			ViewerPane viewerPane =
				new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
					public Viewer createViewer(Composite composite) {
						return new TreeViewer(composite);
					}
					public void requestActivation() {
						super.requestActivation();
						setCurrentViewerPane(this);
					}
				};
			viewerPane.createControl(getContainer());
			treeViewer = (TreeViewer)viewerPane.getViewer();
			treeViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
			treeViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));
d1015 4
a1018 1
			new AdapterFactoryTreeEditor(treeViewer.getTree(), adapterFactory);
d1020 15
a1034 4
			createContextMenuFor(treeViewer);
			int pageIndex = addPage(viewerPane.getControl());
			setPageText(pageIndex, getString("_UI_TreePage_label"));
		}
d1036 24
a1059 15
		// This is the page for the table viewer.
		//
		{
			ViewerPane viewerPane =
				new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
					public Viewer createViewer(Composite composite) {
						return new TableViewer(composite);
					}
					public void requestActivation() {
						super.requestActivation();
						setCurrentViewerPane(this);
					}
				};
			viewerPane.createControl(getContainer());
			tableViewer = (TableViewer)viewerPane.getViewer();
d1061 14
a1074 24
			Table table = tableViewer.getTable();
			TableLayout layout = new TableLayout();
			table.setLayout(layout);
			table.setHeaderVisible(true);
			table.setLinesVisible(true);

			TableColumn objectColumn = new TableColumn(table, SWT.NONE);
			layout.addColumnData(new ColumnWeightData(3, 100, true));
			objectColumn.setText(getString("_UI_ObjectColumn_label"));
			objectColumn.setResizable(true);

			TableColumn selfColumn = new TableColumn(table, SWT.NONE);
			layout.addColumnData(new ColumnWeightData(2, 100, true));
			selfColumn.setText(getString("_UI_SelfColumn_label"));
			selfColumn.setResizable(true);

			tableViewer.setColumnProperties(new String [] {"a", "b"});
			tableViewer.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
			tableViewer.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));

			createContextMenuFor(tableViewer);
			int pageIndex = addPage(viewerPane.getControl());
			setPageText(pageIndex, getString("_UI_TablePage_label"));
		}
d1076 1
a1076 14
		// This is the page for the table tree viewer.
		//
		{
			ViewerPane viewerPane =
				new ViewerPane(getSite().getPage(), GMFMapEditor.this) {
					public Viewer createViewer(Composite composite) {
						return new TreeViewer(composite);
					}
					public void requestActivation() {
						super.requestActivation();
						setCurrentViewerPane(this);
					}
				};
			viewerPane.createControl(getContainer());
d1078 4
a1081 1
			treeViewerWithColumns = (TreeViewer)viewerPane.getViewer();
d1083 4
a1086 4
			Tree tree = treeViewerWithColumns.getTree();
			tree.setLayoutData(new FillLayout());
			tree.setHeaderVisible(true);
			tree.setLinesVisible(true);
d1088 4
a1091 4
			TreeColumn objectColumn = new TreeColumn(tree, SWT.NONE);
			objectColumn.setText(getString("_UI_ObjectColumn_label"));
			objectColumn.setResizable(true);
			objectColumn.setWidth(250);
d1093 3
a1095 4
			TreeColumn selfColumn = new TreeColumn(tree, SWT.NONE);
			selfColumn.setText(getString("_UI_SelfColumn_label"));
			selfColumn.setResizable(true);
			selfColumn.setWidth(200);
d1097 4
a1100 3
			treeViewerWithColumns.setColumnProperties(new String [] {"a", "b"});
			treeViewerWithColumns.setContentProvider(new AdapterFactoryContentProvider(adapterFactory));
			treeViewerWithColumns.setLabelProvider(new AdapterFactoryLabelProvider(adapterFactory));
d1102 1
a1102 3
			createContextMenuFor(treeViewerWithColumns);
			int pageIndex = addPage(viewerPane.getControl());
			setPageText(pageIndex, getString("_UI_TreeWithColumnsPage_label"));
d1104 4
a1107 3

		setActivePage(0);

d1118 3
a1120 1
			 });
d1328 7
a1334 7
					try {
						// Save the resources to the file system.
						//
						boolean first = true;
						for (Iterator i = editingDomain.getResourceSet().getResources().iterator(); i.hasNext(); ) {
							Resource resource = (Resource)i.next();
							if ((first || !resource.getContents().isEmpty() || isPersisted(resource)) && !editingDomain.isReadOnly(resource)) {
d1338 3
a1343 3
					catch (Exception exception) {
						GMFMapEditPlugin.INSTANCE.log(exception);
					}
d1347 1
d1363 3
d1384 2
a1385 2
		catch (IOException e) { }

@


1.6
log
@[rdvorak] #131340 Update constraint annotations in gmfmap meta-model to the latest changes
@
text
@d11 2
d349 1
a349 1
											else {
d386 8
d1146 1
a1146 1
							if ((first || !resource.getContents().isEmpty()) && !editingDomain.isReadOnly(resource)) {
d1177 21
@


1.5
log
@use Ecore item providers to better distinguish equaly named references from different metaclasses (partly #121565)
@
text
@a40 1
import org.eclipse.emf.ecore.provider.EcoreItemProviderAdapterFactory;
a478 1
		factories.add(new EcoreItemProviderAdapterFactory());
d1131 1
a1131 1
						// Save the resource to the file system.
d1133 9
a1141 3
						Resource savedResource = (Resource)editingDomain.getResourceSet().getResources().get(0);
						savedResources.add(savedResource);
						savedResource.save(Collections.EMPTY_MAP);
@


1.4
log
@#114197 - tooling definition in place
@
text
@d41 1
d480 1
@


1.3
log
@[rdvorak] #123279 audits definition in gmfmap
@
text
@a57 1

d61 1
a91 1
import org.eclipse.swt.widgets.Control;
d478 1
@


1.2
log
@updated gmfmap to match newly introduced .gmfgraph model (replaces .diadef) #114177.
besides, rudimentary tooling model is introduced as part of gmfmap #115799, subject to further work
@
text
@d57 2
a951 8
		// This is a temporary workaround... EATM
		//
		Control control = getControl(pageIndex);
		if (control != null) {
			control.setVisible(true);
			control.setFocus();
		}

d1050 4
a1053 3
				new PropertySheetPage() {
					public void makeContributions(IMenuManager menuManager, IToolBarManager toolBarManager, IStatusLineManager statusLineManager) {
						super.makeContributions(menuManager, toolBarManager, statusLineManager);
d1195 1
a1195 1
		setInput(editorInput);
d1235 1
a1235 1
		setInput(editorInput);
d1248 6
a1253 1
		getControl(getActivePage()).setFocus();
@


1.1
log
@*** empty log message ***
@
text
@d57 1
a57 1
import org.eclipse.gmf.diadef.provider.DiagramDefinitionItemProviderAdapterFactory;
d476 1
a476 1
		factories.add(new DiagramDefinitionItemProviderAdapterFactory());
@

