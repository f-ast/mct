head	1.11;
access;
symbols
	v20080813-1520:1.11
	v20080722-1827:1.11
	v20080716-1600:1.11
	v20080716-1642:1.11
	R2_1_maintenance:1.11.0.2
	Root_R2_1_maintenance:1.11
	R2_1_0:1.11
	v20080610-1132:1.11
	v20080528-1052:1.11
	v20080425-1959:1.11
	v20080417-1610:1.11
	v20080322-0000:1.11
	v20080222-1200:1.10
	v20070809-0000:1.10
	R2_0_maintenance:1.10.0.2
	R2_0:1.10
	R4_20:1.10
	v20070621-0000:1.10
	RC3_20:1.10
	v20070614-1400:1.10
	v20070608-1300:1.10
	v20070601-1400:1.10
	v20070520-1200:1.10
	v20070518-1300:1.10
	v20070504-1000:1.10
	v20070427-0600:1.10
	v20070420-1000:1.10
	v20070403-1500:1.10
	v20070330-1300:1.9
	v20060316-0600:1.9
	v20070208-1800:1.8
	M4_20:1.8
	v20061214-0000:1.8
	M3_20:1.8
	v20061117-0800:1.8
	v20061013-1330:1.7
	M1_20:1.7
	v20060904-1500:1.7
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060609-1400:1.7
	v20060531-1730:1.7
	v20060519-1300:1.7
	v20060519-0800:1.7
	v20060512-1000:1.6
	I20060512-1000:1.6
	I20060505-1400:1.4
	I20060428-1300:1.4
	I20060424-0500:1.4
	I20060424-0300:1.4
	M6_10:1.4
	I20060407-1200:1.4
	I20060331-1000:1.4
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2008.03.03.17.45.10;	author atikhomirov;	state Exp;
branches;
next	1.10;
commitid	161147cc39254567;

1.10
date	2007.04.03.16.29.19;	author atikhomirov;	state Exp;
branches;
next	1.9;
commitid	5dfa461280d64567;

1.9
date	2007.03.14.13.00.14;	author atikhomirov;	state Exp;
branches;
next	1.8;
commitid	12fa45f7f1db4567;

1.8
date	2006.11.01.12.12.15;	author dstadnik;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.14.18.06.28;	author atikhomirov;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.11.09.42.01;	author dstadnik;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.10.15.12.28;	author dstadnik;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.10.16.56.23;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.02.12.52.53;	author dstadnik;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.24.18.51.23;	author ashatalin;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.23.15.45.39;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.11
log
@regenerated with EMF 2.4M5
@
text
@/**
 * <copyright>
 * </copyright>
 *
 * $Id$
 */
package org.eclipse.gmf.mappings.provider;


import java.util.Collection;
import java.util.List;

import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.edit.provider.IEditingDomainItemProvider;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.edit.provider.IItemPropertyDescriptor;
import org.eclipse.emf.edit.provider.IItemPropertySource;
import org.eclipse.emf.edit.provider.IStructuredItemContentProvider;
import org.eclipse.emf.edit.provider.ITreeItemContentProvider;
import org.eclipse.emf.edit.provider.ViewerNotification;
import org.eclipse.gmf.mappings.GMFMapFactory;
import org.eclipse.gmf.mappings.GMFMapPackage;
import org.eclipse.gmf.mappings.NodeMapping;
import org.eclipse.gmf.mappings.NodeReference;
import org.eclipse.gmf.mappings.TopNodeReference;

/**
 * This is the item provider adapter for a {@@link org.eclipse.gmf.mappings.TopNodeReference} object.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @@generated
 */
public class TopNodeReferenceItemProvider
	extends NodeReferenceItemProvider
	implements	
		IEditingDomainItemProvider,	
		IStructuredItemContentProvider,	
		ITreeItemContentProvider,	
		IItemLabelProvider,	
		IItemPropertySource {
	/**
	 * This constructs an instance from a factory and a notifier.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public TopNodeReferenceItemProvider(AdapterFactory adapterFactory) {
		super(adapterFactory);
	}

	/**
	 * This returns the property descriptors for the adapted class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public List<IItemPropertyDescriptor> getPropertyDescriptors(Object object) {
		if (itemPropertyDescriptors == null) {
			super.getPropertyDescriptors(object);

		}
		return itemPropertyDescriptors;
	}

	/**
	 * This specifies how to implement {@@link #getChildren} and is used to deduce an appropriate feature for an
	 * {@@link org.eclipse.emf.edit.command.AddCommand}, {@@link org.eclipse.emf.edit.command.RemoveCommand} or
	 * {@@link org.eclipse.emf.edit.command.MoveCommand} in {@@link #createCommand}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public Collection<? extends EStructuralFeature> getChildrenFeatures(Object object) {
		if (childrenFeatures == null) {
			super.getChildrenFeatures(object);
			childrenFeatures.add(GMFMapPackage.eINSTANCE.getTopNodeReference_OwnedChild());
		}
		return childrenFeatures;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	protected EStructuralFeature getChildFeature(Object object, Object child) {
		// Check the type of the specified child object and return the proper feature to use for
		// adding (see {@@link AddCommand}) it as a child.

		return super.getChildFeature(object, child);
	}

	/**
	 * This returns TopNodeReference.gif.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public Object getImage(Object object) {
		return overlayImage(object, getResourceLocator().getImage("full/obj16/TopNodeReference"));
	}

	/**
	 * This returns the label text for the adapted class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	public String getText(Object object) {
        if (object instanceof NodeReference) { 
        	NodeReference reference = (NodeReference) object;
            String result = " <"; 
            if (reference.getContainmentFeature() != null) { 
                 result += reference.getContainmentFeature().getName(); 
            } 
            if (reference.getChildrenFeature() != null) {
            	result += "|";
            	result += reference.getChildrenFeature().getName();
            }
            if (reference.isSetChild()) {
            	NodeMapping mapping = reference.getChild();
                if (mapping.getDomainMetaElement() != null) {
                	result += ":";
                	result += mapping.getDomainMetaElement().getName();
                }
                result += "/";
                if (mapping.getDiagramNode() != null) { 
                    result += reference.getChild().getDiagramNode().getName(); 
                } 
            }
            result += ">"; 
            return getString("_UI_TopNodeReference_type") + result; 

        }
		return getString("_UI_TopNodeReference_type");
	}

	/**
	 * This handles model notifications by calling {@@link #updateChildren} to update any cached
	 * children and by creating a viewer notification, which it passes to {@@link #fireNotifyChanged}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void notifyChangedGen(Notification notification) {
		updateChildren(notification);

		switch (notification.getFeatureID(TopNodeReference.class)) {
			case GMFMapPackage.TOP_NODE_REFERENCE__OWNED_CHILD:
				fireNotifyChanged(new ViewerNotification(notification, notification.getNotifier(), true, false));
				return;
		}
		super.notifyChanged(notification);
	}

	public void notifyChanged(Notification notification) {
		switch (notification.getFeatureID(NodeMapping.class)) {
		case GMFMapPackage.NODE_REFERENCE__CONTAINMENT_FEATURE:
		case GMFMapPackage.NODE_REFERENCE__CHILDREN_FEATURE:
			fireNotifyChanged(new ViewerNotification(notification, null));
			break;
		}
		notifyChangedGen(notification);
	}

	/**
	 * This adds {@@link org.eclipse.emf.edit.command.CommandParameter}s describing the children
	 * that can be created under this object.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	protected void collectNewChildDescriptors(Collection<Object> newChildDescriptors, Object object) {
		super.collectNewChildDescriptors(newChildDescriptors, object);

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getTopNodeReference_OwnedChild(),
				 GMFMapFactory.eINSTANCE.createNodeMapping()));
	}

}
@


1.10
log
@EMF.Edit and editor were regenerated with EMF M6
@
text
@a14 1
import org.eclipse.emf.common.util.ResourceLocator;
a188 11
	/**
	 * Return the resource locator for this item provider's resources.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	@@Override
	public ResourceLocator getResourceLocator() {
		return GMFMapEditPlugin.INSTANCE;
	}

@


1.9
log
@Regenerated graphdef, tooldef and gmfmap models with EMF 2.3 M5 Generics, updated code to be "generified"
@
text
@a16 1
import org.eclipse.emf.edit.command.CommandParameter;
d174 2
a175 2
	 * This adds to the collection of {@@link org.eclipse.emf.edit.command.CommandParameter}s
	 * describing all of the children that can be created under this object.
d181 1
a181 1
	protected void collectNewChildDescriptors(Collection<CommandParameter> newChildDescriptors, Object object) {
@


1.8
log
@[163045] Provide a better distinguishable Mapping labels in .gmfmap editor
@
text
@d16 2
d20 1
d61 2
a62 1
	public List getPropertyDescriptors(Object object) {
d78 2
a79 1
	public Collection getChildrenFeatures(Object object) {
d88 13
d106 1
d181 2
a182 1
	protected void collectNewChildDescriptors(Collection newChildDescriptors, Object object) {
d197 1
@


1.7
log
@overriding recent changes introduced (along with fixing #133836) in GMFMap model, as it's merely a 'shortcut', quite frequent though. Still, adding few new concepts just for the sake of single usecase (I do admit it's popular) seems excessive to me.
GMFMap kept the same as old (no new notions introduced), GMFGraph got generalization from DiagramLabel to DiagramNode to make it possible to use DiagramLabels for NodeMappings (thus, it's possible to detect such nodes in the DGMT)
Tests added to make sure we generate correct genModel for both cases.
@
text
@d112 1
a112 1
                	result += "(";
a113 1
                	result += ")";
@


1.6
log
@revert to gmfmap model compatibility
@
text
@a23 1
import org.eclipse.gmf.mappings.LabelNodeMapping;
d118 2
a119 4
                    result += mapping.getDiagramNode().getName(); 
                } else if (mapping instanceof LabelNodeMapping && ((LabelNodeMapping) mapping).getDiagramLabel() != null) { 
                    result += ((LabelNodeMapping) mapping).getDiagramLabel().getName(); 
                }
a169 5

		newChildDescriptors.add
			(createChildParameter
				(GMFMapPackage.eINSTANCE.getTopNodeReference_OwnedChild(),
				 GMFMapFactory.eINSTANCE.createLabelNodeMapping()));
@


1.5
log
@#133836 Creating a child node without a label causes error
@
text
@a26 1
import org.eclipse.gmf.mappings.ShapeNodeMapping;
d118 2
a119 2
                if (mapping instanceof ShapeNodeMapping && ((ShapeNodeMapping) mapping).getDiagramNode() != null) { 
                    result += ((ShapeNodeMapping) mapping).getDiagramNode().getName(); 
d172 1
a172 1
				 GMFMapFactory.eINSTANCE.createShapeNodeMapping()));
@


1.4
log
@feature is better than operation
@
text
@d24 1
d27 1
d119 5
a123 3
                if (mapping.getDiagramNode() != null) { 
                    result += reference.getChild().getDiagramNode().getName(); 
                } 
d173 6
a178 1
				 GMFMapFactory.eINSTANCE.createNodeMapping()));
@


1.3
log
@#125492 Cannot generate editors whose canvas does not map to a domain element
@
text
@d109 1
a109 1
            if (reference.getChild() != null) {
@


1.2
log
@Some decorators added to the mapping model entries
@
text
@d89 1
a89 1
		return getResourceLocator().getImage("full/obj16/TopNodeReference");
d145 1
a145 1
	
@


1.1
log
@#127464 unlimited hierarchies in the GMFMap with possible reuse of mapping entries
@
text
@a14 1

a15 1

a21 1

d24 2
d96 1
a96 1
	 * @@generated
d99 26
d135 1
a135 1
	public void notifyChanged(Notification notification) {
d145 10
@

