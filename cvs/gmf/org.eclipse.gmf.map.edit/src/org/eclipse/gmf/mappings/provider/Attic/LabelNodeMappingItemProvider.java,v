head	1.4;
access;
symbols
	v20080813-1520:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060512-1000:1.3
	I20060512-1000:1.3;
locks; strict;
comment	@# @;
expand	@k@;


1.4
date	2006.05.14.18.06.28;	author atikhomirov;	state dead;
branches;
next	1.3;

1.3
date	2006.05.11.12.17.24;	author ashatalin;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.11.09.42.01;	author dstadnik;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.10.15.12.28;	author dstadnik;	state Exp;
branches;
next	;


desc
@@


1.4
log
@overriding recent changes introduced (along with fixing #133836) in GMFMap model, as it's merely a 'shortcut', quite frequent though. Still, adding few new concepts just for the sake of single usecase (I do admit it's popular) seems excessive to me.
GMFMap kept the same as old (no new notions introduced), GMFGraph got generalization from DiagramLabel to DiagramNode to make it possible to use DiagramLabels for NodeMappings (thus, it's possible to detect such nodes in the DGMT)
Tests added to make sure we generate correct genModel for both cases.
@
text
@/**
 * <copyright>
 * </copyright>
 *
 * $Id$
 */
package org.eclipse.gmf.mappings.provider;


import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.common.notify.AdapterFactory;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.util.ResourceLocator;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.edit.provider.ComposeableAdapterFactory;
import org.eclipse.emf.edit.provider.IEditingDomainItemProvider;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.edit.provider.IItemPropertySource;
import org.eclipse.emf.edit.provider.IStructuredItemContentProvider;
import org.eclipse.emf.edit.provider.ITreeItemContentProvider;
import org.eclipse.emf.edit.provider.ItemPropertyDescriptor;
import org.eclipse.emf.edit.provider.ViewerNotification;
import org.eclipse.gmf.mappings.GMFMapPackage;
import org.eclipse.gmf.mappings.LabelNodeMapping;
import org.eclipse.gmf.mappings.presentation.FilterUtil;

/**
 * This is the item provider adapter for a {@@link org.eclipse.gmf.mappings.LabelNodeMapping} object.
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @@generated
 */
public class LabelNodeMappingItemProvider
	extends NodeMappingItemProvider
	implements	
		IEditingDomainItemProvider,	
		IStructuredItemContentProvider,	
		ITreeItemContentProvider,	
		IItemLabelProvider,	
		IItemPropertySource {
	/**
	 * This constructs an instance from a factory and a notifier.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public LabelNodeMappingItemProvider(AdapterFactory adapterFactory) {
		super(adapterFactory);
	}

	/**
	 * This returns the property descriptors for the adapted class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public List getPropertyDescriptors(Object object) {
		if (itemPropertyDescriptors == null) {
			super.getPropertyDescriptors(object);

			addDiagramLabelPropertyDescriptor(object);
			addFeaturesPropertyDescriptor(object);
			addReadOnlyPropertyDescriptor(object);
			addViewPatternPropertyDescriptor(object);
			addEditPatternPropertyDescriptor(object);
		}
		return itemPropertyDescriptors;
	}

	/**
	 * This adds a property descriptor for the Diagram Label feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void addDiagramLabelPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(createItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_LabelFlavour_diagramLabel_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_LabelFlavour_diagramLabel_feature", "_UI_LabelFlavour_type"),
				 GMFMapPackage.eINSTANCE.getLabelFlavour_DiagramLabel(),
				 true,
				 null,
				 null,
				 null));
	}

	/**
	 * This adds a property descriptor for the Features feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	protected void addFeaturesPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(new ItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_LabelFlavour_features_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_LabelFlavour_features_feature", "_UI_LabelFlavour_type"),
				 GMFMapPackage.eINSTANCE.getLabelFlavour_Features(),
				 true,
				 null,
				 null,
				 null) {
						protected  Collection getComboBoxObjects(Object object) {
							return FilterUtil.filterByContainerMetaclass(super.getComboBoxObjects(object), (LabelNodeMapping) object);
						}
			});
	}

	/**
	 * This adds a property descriptor for the Read Only feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void addReadOnlyPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(createItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_LabelFlavour_readOnly_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_LabelFlavour_readOnly_feature", "_UI_LabelFlavour_type"),
				 GMFMapPackage.eINSTANCE.getLabelFlavour_ReadOnly(),
				 true,
				 ItemPropertyDescriptor.BOOLEAN_VALUE_IMAGE,
				 null,
				 null));
	}

	/**
	 * This adds a property descriptor for the View Pattern feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void addViewPatternPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(createItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_LabelFlavour_viewPattern_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_LabelFlavour_viewPattern_feature", "_UI_LabelFlavour_type"),
				 GMFMapPackage.eINSTANCE.getLabelFlavour_ViewPattern(),
				 true,
				 ItemPropertyDescriptor.GENERIC_VALUE_IMAGE,
				 null,
				 null));
	}

	/**
	 * This adds a property descriptor for the Edit Pattern feature.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void addEditPatternPropertyDescriptor(Object object) {
		itemPropertyDescriptors.add
			(createItemPropertyDescriptor
				(((ComposeableAdapterFactory)adapterFactory).getRootAdapterFactory(),
				 getResourceLocator(),
				 getString("_UI_LabelFlavour_editPattern_feature"),
				 getString("_UI_PropertyDescriptor_description", "_UI_LabelFlavour_editPattern_feature", "_UI_LabelFlavour_type"),
				 GMFMapPackage.eINSTANCE.getLabelFlavour_EditPattern(),
				 true,
				 ItemPropertyDescriptor.GENERIC_VALUE_IMAGE,
				 null,
				 null));
	}

	/**
	 * This returns LabelNodeMapping.gif.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public Object getImage(Object object) {
		return overlayImage(object, getResourceLocator().getImage("full/obj16/LabelNodeMapping"));
	}

	/**
	 * This returns the label text for the adapted class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated NOT
	 */
	public String getText(Object object) {
		if (object instanceof LabelNodeMapping) {
			LabelNodeMapping mapping = (LabelNodeMapping) object;
			String result = " <";
			if (mapping.getDomainMetaElement() != null) {
				result += mapping.getDomainMetaElement().getName();
			}
			result += ".";
			for (Iterator it = mapping.getFeatures().iterator(); it.hasNext();) {
				EAttribute nextAttribute = (EAttribute) it.next();
				result += nextAttribute.getName();
				if (it.hasNext()) {
					result += ",";
				}
			}
			result += "/";
			if (mapping.getDiagramLabel() != null) {
				result += mapping.getDiagramLabel().getName();
			}
			result += ">";
			return getString("_UI_LabelNodeMapping_type") + result;
		}
		return getString("_UI_LabelNodeMapping_type");
		
	}

	/**
	 * This handles model notifications by calling {@@link #updateChildren} to update any cached
	 * children and by creating a viewer notification, which it passes to {@@link #fireNotifyChanged}.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public void notifyChanged(Notification notification) {
		updateChildren(notification);

		switch (notification.getFeatureID(LabelNodeMapping.class)) {
			case GMFMapPackage.LABEL_NODE_MAPPING__READ_ONLY:
			case GMFMapPackage.LABEL_NODE_MAPPING__VIEW_PATTERN:
			case GMFMapPackage.LABEL_NODE_MAPPING__EDIT_PATTERN:
				fireNotifyChanged(new ViewerNotification(notification, notification.getNotifier(), false, true));
				return;
		}
		super.notifyChanged(notification);
	}

	/**
	 * This adds to the collection of {@@link org.eclipse.emf.edit.command.CommandParameter}s
	 * describing all of the children that can be created under this object.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	protected void collectNewChildDescriptors(Collection newChildDescriptors, Object object) {
		super.collectNewChildDescriptors(newChildDescriptors, object);
	}

	/**
	 * Return the resource locator for this item provider's resources.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @@generated
	 */
	public ResourceLocator getResourceLocator() {
		return GMFMapEditPlugin.INSTANCE;
	}

}
@


1.3
log
@Corercting property sheet for LabelNodeMappings
@
text
@@


1.2
log
@revert to gmfmap model compatibility
@
text
@d11 1
a15 1

d17 1
a17 1

a25 1

d28 1
d97 1
a97 1
	 * @@generated
d101 1
a101 1
			(createItemPropertyDescriptor
d110 5
a114 1
				 null));
d191 1
a191 1
	 * @@generated
d194 23
a216 2
		LabelNodeMapping labelNodeMapping = (LabelNodeMapping)object;
		return getString("_UI_LabelNodeMapping_type") + " " + labelNodeMapping.isReadOnly();
@


1.1
log
@#133836 Creating a child node without a label causes error
@
text
@a28 1
import org.eclipse.gmf.mappings.presentation.FilterUtil;
d81 1
a81 1
			(new ItemPropertyDescriptor
d90 1
a90 5
				 null) {
				protected Collection getComboBoxObjects(Object object) {
					return FilterUtil.sort(super.getComboBoxObjects(object));
				}
	});
@

