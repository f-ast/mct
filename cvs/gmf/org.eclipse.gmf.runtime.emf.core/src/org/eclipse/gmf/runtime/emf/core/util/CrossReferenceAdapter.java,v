head	1.14;
access;
symbols
	v20081020-0700:1.14
	v20080722-1827:1.14
	v20080716-1600:1.14
	v20080716-1642:1.14
	R2_1_maintenance:1.14.0.4
	Root_R2_1_maintenance:1.14
	R2_1_0:1.14
	v20080425-1959:1.14
	v20080407-0930:1.14
	v20080404-1111:1.14
	v20080401-1425:1.14
	v20080222-1200:1.14
	v20080215-1500:1.14
	v20080201-2010:1.14
	v20080201-0201:1.14
	v20080114-2222:1.14
	v20080114-1111:1.14
	v20070809-0000:1.14
	R2_0_maintenance:1.14.0.2
	R2_0:1.14
	R4_20:1.14
	RC3_20:1.14
	v20070601-1400:1.14
	v20070330-1300:1.14
	v20070208-1800:1.14
	v20070105-1200:1.10.2.10
	v20070103-0300:1.14
	M4_20:1.14
	v20061218-1500:1.10.2.9
	v20061214-0000:1.13
	M3_20:1.11
	v20061013-1330:1.11
	v20060919-0800:1.10.2.7
	M1_20:1.10
	v20060831-1500:1.10.2.7
	v20060728-0500:1.10.2.7
	v20060721-1130:1.10.2.7
	v20060713-1700:1.10.2.6
	R1_0_maintenance:1.10.0.2
	R1_0:1.10
	v20060627-1200:1.10
	v20060616-1200:1.10
	v20060531-1730:1.10
	v20060530-1930:1.10
	v20060526-1200:1.10
	v20060519-0800:1.10
	I20060505-1400:1.9
	I20060428-1300:1.8
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.7
	I20060331-1000:1.5
	I20060324-0300:1.4
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1;
locks; strict;
comment	@# @;


1.14
date	2007.01.02.22.06.57;	author ahunter;	state Exp;
branches;
next	1.13;
commitid	6bf3459ad77e4567;

1.13
date	2006.12.11.14.55.08;	author crevells;	state Exp;
branches;
next	1.12;
commitid	6db3457d714b4567;

1.12
date	2006.11.23.21.20.43;	author mmostafa;	state Exp;
branches;
next	1.11;
commitid	6123456610ab4567;

1.11
date	2006.10.03.15.05.22;	author ahunter;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.16.20.20.19;	author vramaswamy;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2006.05.04.19.49.37;	author vramaswamy;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.12.19.48.00;	author vramaswamy;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.01.17.11.25;	author vramaswamy;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.31.16.15.53;	author vramaswamy;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.24.20.13.55;	author vramaswamy;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.24.03.20.53;	author vramaswamy;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.23.20.02.05;	author vramaswamy;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.23.14.57.13;	author vramaswamy;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.15.19.15.37;	author vramaswamy;	state Exp;
branches;
next	;

1.10.2.1
date	2006.07.11.16.09.24;	author ahunter;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2006.07.11.18.41.32;	author ahunter;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2006.07.11.20.45.18;	author ldamus;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2006.07.12.14.24.39;	author ldamus;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2006.07.12.18.02.11;	author ldamus;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2006.07.13.15.10.04;	author mmostafa;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2006.07.18.18.35.47;	author ahunter;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2006.11.23.21.23.14;	author mmostafa;	state Exp;
branches;
next	1.10.2.9;
commitid	7ba8456611424567;

1.10.2.9
date	2006.12.11.14.52.54;	author crevells;	state Exp;
branches;
next	1.10.2.10;
commitid	6b29457d70c64567;

1.10.2.10
date	2007.01.02.22.06.40;	author ahunter;	state Exp;
branches;
next	;
commitid	5910459ad7704567;


desc
@@


1.14
log
@[167297] gmf_head ahunter 070102 Update copyright to indicate change in 2006
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.core.util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.common.notify.Adapter;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.Notifier;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.EStructuralFeature.Setting;
import org.eclipse.emf.ecore.impl.EClassImpl;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EContentsEList;
import org.eclipse.emf.ecore.util.ECrossReferenceAdapter;
import org.eclipse.emf.ecore.util.ECrossReferenceEList;
import org.eclipse.emf.ecore.util.ExtendedMetaData;
import org.eclipse.emf.ecore.util.FeatureMapUtil;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * An adapter that maintains itself as an adapter for all contained objects. It
 * can be installed for an {@@link EObject}, a {@@link Resource}, or a
 * {@@link ResourceSet}.
 * <p>
 * This adapter maintain information on inverse references, resource imports,
 * and resource exports.
 * 
 * @@author Christian Vogt (cvogt)
 * @@author Christian W. Damus (cdamus)
 */
public class CrossReferenceAdapter extends ECrossReferenceAdapter {

	private Map imports = new HashMap();

	private Map exports = new HashMap();

	private boolean resolve = true;
	
    private static Map eClassToChangeableFeatures = new HashMap();

    private static List nullList = new ArrayList(1);

	/**
	 * Initializes me.
	 */
	public CrossReferenceAdapter() {
		this(true);
	}

	/**
	 * Initializes me.
	 * 
	 * @@param resolve
	 *            flag to determine if the proxies need to be resolved
	 */
	public CrossReferenceAdapter(boolean resolve) {
		super();

		this.resolve = resolve;
	}

	/**
	 * Updates imports and exports maps.
	 * 
	 * @@param notification
	 *            the event notification
	 */
	public void selfAdapt(Notification notification) {
		super.selfAdapt(notification);
		Object notifier = notification.getNotifier();
		Object feature = notification.getFeature();

		// update import / export information when a resource
		// is unloaded or loaded
		if (notifier instanceof Resource) {
			if (notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_LOADED) {
				if (!notification.getNewBooleanValue()) {
					deregisterReferences((Resource) notifier);
				} else {
					for (Iterator i = ((Resource) notifier).getContents()
							.iterator(); i.hasNext();) {
						EObject child = (EObject) i.next();
						if (child != null) {
							updateImportsAndExports((Resource) notifier, child,
									true);
						}
					}
				}
			}

			return;
		}

		// interested in maintaining import / export information
		// when the notifier is an EObject and the feature is a
		// non-containment EReference
		if (!(notifier instanceof EObject) || !(feature instanceof EReference)) {
			return;
		}

		EReference reference = (EReference) feature;
		if (!isImportExportCapable(reference, (EObject) notifier)) {
			return;
		}

		switch (notification.getEventType()) {
		case Notification.RESOLVE:
		case Notification.SET:
		case Notification.UNSET: {
			EObject oldValue = (EObject) notification.getOldValue();
			if (oldValue != null) {
				deregisterReference(((EObject) notification.getNotifier())
						.eResource(), oldValue.eResource());
			}
			EObject newValue = (EObject) notification.getNewValue();
			if (newValue != null) {
				registerReference(((EObject) notification.getNotifier())
						.eResource(), newValue.eResource());
			}
			break;
		}
		case Notification.ADD: {
			EObject newValue = (EObject) notification.getNewValue();
			if (newValue != null) {
				registerReference(((EObject) notification.getNotifier())
						.eResource(), newValue.eResource());
			}
			break;
		}
		case Notification.ADD_MANY: {
			Collection newValues = (Collection) notification.getNewValue();
			for (Iterator i = newValues.iterator(); i.hasNext();) {
				EObject newValue = (EObject) i.next();
				registerReference(((EObject) notification.getNotifier())
						.eResource(), newValue.eResource());
			}
			break;
		}
		case Notification.REMOVE: {
			EObject oldValue = (EObject) notification.getOldValue();
			if (oldValue != null) {
				deregisterReference(((EObject) notification.getNotifier())
						.eResource(), oldValue.eResource());
			}
			break;
		}
		case Notification.REMOVE_MANY: {
			Collection oldValues = (Collection) notification.getOldValue();
			for (Iterator i = oldValues.iterator(); i.hasNext();) {
				EObject oldValue = (EObject) i.next();
				deregisterReference(((EObject) notification.getNotifier())
						.eResource(), oldValue.eResource());
			}
			break;
		}
		}
	}

	/**
	 * Extends the superclass method to handle the removal cases of containment,
	 * to tear down aggregate (resource-level) cross-references.
	 */
	protected void handleContainment(Notification notification) {
		super.handleContainment(notification);

		Object notifier = notification.getNotifier();
		if (notifier instanceof ResourceSet) {
			// not interested in removal of resources from the resource set
			return;
		}

		switch (notification.getEventType()) {
		case Notification.ADD: {
			EObject newValue = (EObject) notification.getNewValue();

			if (newValue != null) {
				Resource resource;
				if (notifier instanceof Resource) {
					resource = (Resource) notifier;
				} else {
					resource = ((EObject) notification.getNotifier())
							.eResource();
				}

				// handle processing of the new value that has been added
				updateImportsAndExports(resource, newValue, true);
			}

			break;
		}
		case Notification.ADD_MANY: {
			Resource resource;
			if (notifier instanceof Resource) {
				resource = (Resource) notifier;
			} else {
				resource = ((EObject) notification.getNotifier()).eResource();
			}

			Collection newValues = (Collection) notification.getNewValue();

			for (Iterator iter = newValues.iterator(); iter.hasNext();) {
				EObject next = (EObject) iter.next();

				if (next != null) {
					// handle processing of the new value that has been added
					updateImportsAndExports(resource, next, true);
				}
			}
			break;
		}

		case Notification.REMOVE: {
			EObject oldValue = (EObject) notification.getOldValue();

			if (oldValue != null) {
				Resource resource;
				if (notifier instanceof Resource) {
					resource = (Resource) notifier;
				} else {
					resource = ((EObject) notification.getNotifier())
							.eResource();
				}

				// handle processing of the old value that has been removed
				updateImportsAndExports(resource, oldValue, false);
			}
			break;
		}
		case Notification.REMOVE_MANY: {
			Resource resource;
			if (notifier instanceof Resource) {
				resource = (Resource) notifier;
                
                if (!resource.isLoaded()) {
                    // purge the resource from the imports/exports map
                    deregisterReferences(resource);
                    return;
                }
			} else {
				resource = ((EObject) notification.getNotifier()).eResource();
			}

			Collection oldValues = (Collection) notification.getOldValue();

			for (Iterator iter = oldValues.iterator(); iter.hasNext();) {
				EObject next = (EObject) iter.next();

				if (next != null) {
					// handle processing of the old value that has been removed
					updateImportsAndExports(resource, next, false);
				}
			}
			break;
		}
		}
	}

	/**
	 * Updates the imports and exports map for the specified eObject
	 * 
	 * @@param resource
	 *            a resource
	 * @@param eObject
	 *            the specified eObject
	 * @@param register
	 *            boolean flag to indicate whether to register imports or
	 *            unregister imports
	 */
	public void updateImportsAndExports(Resource resource, EObject value,
			boolean register) {
		CrossReferenceAdapter adapter = getExistingCrossReferenceAdapter(value);

		if (register) {
			if (adapter != null) {
				// now, register incoming unidirectional references and
				// opposites
				for (Iterator iter = adapter.getInverseReferences(value).iterator();
                        iter.hasNext();) {
                    EStructuralFeature.Setting next = (EStructuralFeature.Setting) iter.next();
                    EReference ref = (EReference) next.getEStructuralFeature();
                    EObject owner = next.getEObject();
                    
                    if (isImportExportCapable(ref, owner)) {
                        registerReference(owner.eResource(), resource);
                    }
				}
			}
		} else {
			// deregister the outgoing references and incoming bidirectionals
            EContentsEList.FeatureIterator crossReferences = getOptimizedCrossReferenceIterator(
            		value);
            
			while (crossReferences.hasNext()) {
				EObject referent = (EObject) crossReferences.next();

				if (referent != null) {
					EReference eReference = (EReference) crossReferences
							.feature();

					if (isImportExportCapable(eReference, referent)) {
						Resource referencedResource = referent.eResource();
						deregisterReference(resource, referencedResource);
					}
				}
			}

			// now, deregister incoming unidirectional references and opposites
			if (adapter != null) {
                for (Iterator iter = adapter.getInverseReferences(value).iterator();
                        iter.hasNext();) {
                    EStructuralFeature.Setting next = (EStructuralFeature.Setting) iter.next();
                    EReference ref = (EReference) next.getEStructuralFeature();
                    EObject owner = next.getEObject();
                    
                    if (isImportExportCapable(ref, owner)) {
                        deregisterReference(owner.eResource(), resource);
                    }
                }
			}
		}

		// process contents
		if (adapter != null) {
			adapter.updateImportsAndExportsForContents(resource, value,
					register);
		}
	}

	/**
	 * Updates the imports and exports map for the contents of the specified
	 * eObject
	 * 
	 * @@param resource
	 *            a resource
	 * @@param eObject
	 *            the specified eObject
	 * @@param register
	 *            boolean flag to indicate whether to register imports or
	 *            unregister imports
	 */
	public void updateImportsAndExportsForContents(Resource resource,
			EObject value, boolean register) {
		// go through the children of the eObject
		for (Iterator i = resolve() ? value.eContents().iterator()
				: ((InternalEList) value.eContents()).basicIterator(); i
				.hasNext();) {
			updateImportsAndExports(resource, (EObject) i.next(), register);
		}
	}

	/**
	 * @@see org.eclipse.emf.ecore.util.ECrossReferenceAdapter#setTarget(org.eclipse.emf.common.notify.Notifier)
	 */
	public void setTarget(Notifier target) {
		super.setTarget(target);

		if (target instanceof EObject) {
			EObject eObject = (EObject) target;
			Resource resource = eObject.eResource();

			// register the outgoing references and incoming bidirectionals
			EContentsEList.FeatureIterator crossReferences = getOptimizedCrossReferenceIterator(
					eObject);
			
			while (crossReferences.hasNext()) {
				EObject referent = (EObject) crossReferences.next();

				if (referent != null) {
					EReference eReference = (EReference) crossReferences
							.feature();

					if (isImportExportCapable(eReference, referent)) {
						Resource referencedResource = referent.eResource();
						registerReference(resource, referencedResource);
					}
				}
			}
		}
	}

	/**
	 * @@see org.eclipse.emf.ecore.util.ECrossReferenceAdapter#unsetTarget(org.eclipse.emf.common.notify.Notifier)
	 */
	public void unsetTarget(Notifier notifier) {
		super.unsetTarget(notifier);
		if (notifier instanceof Resource) {
			deregisterReferences((Resource) notifier);
		}
	}

	/**
	 * Gets the imports of a resource.
	 * 
	 * @@param referencer
	 *            the resource to retrieve imports for
	 * @@return a Set of resource imports
	 */
	public Set getImports(Resource referencer) {

		Map importsMap = getImportsMap(referencer);

		if (importsMap != null) {
			return Collections.unmodifiableSet(importsMap.keySet());
		} else {
			return Collections.EMPTY_SET;
		}
	}

	/**
	 * Gets the exports of a resource.
	 * 
	 * @@param referenced
	 *            the resource to retrieve exports for
	 * @@return a Set of resource exports
	 */
	public Set getExports(Resource referenced) {

		Map exportsMap = getExportsMap(referenced);

		if (exportsMap != null) {
			return Collections.unmodifiableSet(exportsMap.keySet());
		} else {
			return Collections.EMPTY_SET;
		}
	}

	/**
	 * Returns the imports map of the given resource.
	 * 
	 * @@param resource
	 * @@return imports map of the given resource
	 */
	private Map getImportsMap(Resource resource) {
		return (Map) imports.get(resource);
	}

	/**
	 * Returns the exports map of the given resource.
	 * 
	 * @@param resource
	 * @@return exports map of the given resource
	 */
	private Map getExportsMap(Resource resource) {
		return (Map) exports.get(resource);
	}

	/**
	 * Registers a reference updating the imports and exports maps accordingly.
	 * 
	 * @@param referencer
	 *            the referencing resource
	 * @@param referenced
	 *            the referenced resouce
	 */
	private void registerReference(final Resource referencer,
			final Resource referenced) {

		if ((referencer != null) && (referenced != null)
				&& (referencer != referenced)) {

			Map importsMap = getImportsMap(referencer);

			if (importsMap == null) {
				importsMap = new HashMap();
				imports.put(referencer, importsMap);
			}

			Counter importsCount = (Counter) importsMap.get(referenced);

			if (importsCount == null) {

				importsCount = new Counter();
				importsMap.put(referenced, importsCount);

				importAdded(referencer, referenced);
			} else {
				importsCount.inc();
			}

			Map exportsMap = getExportsMap(referenced);

			if (exportsMap == null) {
				exportsMap = new HashMap();
				exports.put(referenced, exportsMap);
			}

			Counter exportsCount = (Counter) exportsMap.get(referencer);

			if (exportsCount == null) {

				exportsCount = new Counter();
				exportsMap.put(referencer, exportsCount);

				exportAdded(referenced, referencer);
			} else {
				exportsCount.inc();
			}
		}
	}

	/**
	 * Hook to be implemented by subclasses upon the establishment of a new
	 * import of the <code>referenced</code> resource by the
	 * <code>referencer</code>. This implementation does nothing; subclasses
	 * need not call <code>super</code>.
	 * 
	 * @@param referencer
	 *            the referencing resource (doing the importing)
	 * @@param referenced
	 *            the resource that it references
	 */
	protected void importAdded(Resource referencer, Resource referenced) {
		// subclass hook
	}

	/**
	 * Hook to be implemented by subclasses upon the elimination of an import of
	 * the <code>referenced</code> resource by the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call
	 * <code>super</code>.
	 * 
	 * @@param referencer
	 *            the formerly referencing resource (doing the importing)
	 * @@param referenced
	 *            the resource that it had referenced
	 */
	protected void importRemoved(Resource referencer, Resource referenced) {
		// subclass hook
	}

	/**
	 * Hook to be implemented by subclasses upon the establishment of a new
	 * export of the <code>referenced</code> resource to the
	 * <code>referencer</code>. This implementation does nothing; subclasses
	 * need not call <code>super</code>.
	 * 
	 * @@param referenced
	 *            the resource being referenced (doing the exporting)
	 * @@param referencer
	 *            the referencing resource
	 */
	protected void exportAdded(Resource referenced, Resource referencer) {
		// subclass hook
	}

	/**
	 * Hook to be implemented by subclasses upon the elimination of an export of
	 * the <code>referenced</code> resource to the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call
	 * <code>super</code>.
	 * 
	 * @@param referenced
	 *            the resource formerly being referenced (doing the exporting)
	 * @@param referencer
	 *            the formerly referencing resource
	 */
	protected void exportRemoved(Resource referenced, Resource referencer) {
		// subclass hook
	}

	/**
	 * Deregisters a reference updating the imports and exports maps
	 * accordingly.
	 * 
	 * @@param referencer
	 *            the referencing resource
	 * @@param referenced
	 *            the referenced resource
	 */
	private void deregisterReference(final Resource referencer,
			final Resource referenced) {

		if ((referencer != null) && (referenced != null)
				&& (referencer != referenced)) {

			Map importsMap = getImportsMap(referencer);

			if (importsMap != null) {

				Counter importsCount = (Counter) importsMap.get(referenced);

				if ((importsCount != null) && importsCount.dec()) {

					importsMap.remove(referenced);

					importRemoved(referencer, referenced);

					if (importsMap.isEmpty()) {
						imports.remove(referencer);
					}
				}
			}

			Map exportsMap = getExportsMap(referenced);

			if (exportsMap != null) {

				Counter exportsCount = (Counter) exportsMap.get(referencer);

				if ((exportsCount != null) && exportsCount.dec()) {

					exportsMap.remove(referencer);

					exportRemoved(referenced, referencer);

					if (exportsMap.isEmpty()) {
						exports.remove(referenced);
					}
				}
			}
		}
	}

	/**
	 * Cleans up a resource from the imports and exports maps.
	 * 
	 * @@param referencer
	 *            the referencing resource
	 */
	private void deregisterReferences(final Resource referencer) {

		Object[] resImports = getImports(referencer).toArray();

		for (int i = 0; i < resImports.length; i++) {

			final Resource referenced = (Resource) resImports[i];

			Map importsMap = getImportsMap(referencer);

			if (importsMap != null) {

				importsMap.remove(referenced);

				importRemoved(referencer, referenced);

				if (importsMap.isEmpty()) {
					imports.remove(referencer);
				}
			}

			Map exportsMap = getExportsMap(referenced);

			if (exportsMap != null) {

				exportsMap.remove(referencer);

				exportRemoved(referenced, referencer);

				if (exportsMap.isEmpty()) {
					exports.remove(referenced);
				}
			}
		}
	}

	/**
	 * Returns a Set of EObjects that reference the given EObject. If an
	 * EReference is specified, the scope of the search is limited only to that
	 * EReference. To include all references specify a value of null. If an
	 * EClass type is specified, the returned Set will only include those
	 * referencers that match the given type. To include all types specify a
	 * value of null.
	 * 
	 * @@param referenced
	 *            the referenced EObject
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
	 * @@return a Set of referencers
	 */
	public Set getInverseReferencers(EObject referenced, EReference reference,
			EClass type) {
		return getReferencers(getInverseReferences(referenced), reference, type);
	}

	/**
     * Like the {@@link #getInverseReferencers(EObject, EReference, EClass)} method,
     * obtains referencing objects (optionally filtered by reference and type),
     * except that it additionally only considers references that are
     * {@@linkplain EStructuralFeature#isChangeable() changeable} and can
     * {@@linkplain EReference#isResolveProxies() reference other resources}.
     * 
     * @@param referenced
     *            the referenced EObject
     * @@param reference
     *            the reference to find referencers on, null for any reference
     * @@param type
     *            the type of the referencers, use null for any type
     * @@return a Set of referencers on potentially cross-resource references
     */
    public Set getInverseReferencersCrossResource(EObject referenced, EReference reference,
            EClass type) {
        return getReferencers(getInverseReferencesCrossResource(referenced), reference, type);
    }
    

	/**
     * Like the {@@link #getInverseReferences(EObject)} method,
     * obtains settings implementing references to the specified object,
     * except that it only considers references that are
     * {@@linkplain EStructuralFeature#isChangeable() changeable} and can
     * {@@linkplain EReference#isResolveProxies() reference other resources}.
     * 
     * @@param eObject the referenced EObject
     * 
     * @@return a collection of {@@link EStructuralFeature.Setting}s on
     *     potentially cross-resource references
     */
    public Collection getInverseReferencesCrossResource(EObject eObject) {
        return getInverseReferencesCrossResource(eObject, !resolve());
    }

	/**
	 * Returns a Set of EObjects that reference the given EObject through a uni
	 * directional EReferences. If an EReference is specified, the scope of the
	 * search is limited only to that EReference. To include all references
	 * specify a value of null. If an EClass type is specified, the returned Set
	 * will only include those referencers that match the given type. To include
	 * all types specify a value of null.
	 * 
	 * @@param referenced
	 *            the referenced EObject
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
	 * @@return a Set of referencers
	 */
	public Set getNonNavigableInverseReferencers(EObject referenced,
			EReference reference, EClass type) {
		return getReferencers(getNonNavigableInverseReferences(referenced),
				reference, type);
	}

	/**
	 * Extracts the EObjects from the EStructuralFeature.Setting references and
	 * returns a filtered Set based on the given reference and type.
	 * 
	 * @@param references
	 *            a collection of EStructuralFeature.Setting
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
	 * @@return a Set of referencers
	 */
	private Set getReferencers(Collection references, EReference reference,
			EClass type) {
		Set set = new HashSet();
		if (!references.isEmpty()) {
			for (Iterator iter = references.iterator(); iter.hasNext();) {
				Setting setting = (Setting) iter.next();
				if (reference == null
						|| reference == setting.getEStructuralFeature()) {
					EObject referencer = setting.getEObject();
					if (referencer != null
							&& (type == null || type.isInstance(referencer))) {
						set.add(referencer);
					}
				}
			}
		}
		return set;
	}

	/**
	 * Searches the adapter list of the given Notifier for a
	 * CrossReferenceAdapter. If not found, returns null.
	 * 
	 * @@param notifier
	 *            the notifier to search
	 * @@return the CrossReferenceAdapter if found, otherwise null
	 */
	public static CrossReferenceAdapter getExistingCrossReferenceAdapter(
			Notifier notifier) {
		if (notifier == null) {
			return null;
		}

		List adapters = notifier.eAdapters();

		for (int i = 0, size = adapters.size(); i < size; ++i) {
			Adapter adapter = (Adapter) adapters.get(i);
			if (adapter instanceof CrossReferenceAdapter) {
				return (CrossReferenceAdapter) adapter;
			}
		}
		return null;
	}

	/**
	 * Obtains the cross-reference adapter for the specified resource set, if
	 * necessary creating it and attaching it.
	 * 
	 * @@param resourceSet
	 *            the resource set
	 * 
	 * @@return the resourceSet's cross-reference adapter
	 */
	public static CrossReferenceAdapter getCrossReferenceAdapter(
			ResourceSet resourceSet) {
		if (resourceSet == null) {
			return null;
		}

		CrossReferenceAdapter result = getExistingCrossReferenceAdapter(resourceSet);

		if (result == null) {
			result = new CrossReferenceAdapter();
			resourceSet.eAdapters().add(result);
		}

		return result;
	}

	/**
	 * A mutable integer used to count number of object-level references between
	 * two resources.
	 * 
	 * @@author Christian W. Damus (cdamus)
	 */
	private static final class Counter {
		private int value = 1;

		Counter() {
			super();
		}

		/**
		 * Obtains my value.
		 * 
		 * @@return my count
		 */
		int getValue() {
			return value;
		}

		/**
		 * Increments me.
		 */
		void inc() {
			value++;
		}

		/**
		 * Decrements me.
		 * 
		 * @@return <code>true</code> if I am now zero; <code>false</code>,
		 *         otherwise
		 */
		boolean dec() {
			return --value <= 0;
		}
	}

	protected boolean resolve() {
		return this.resolve;
	}

	public Collection getInverseReferences(EObject eObject, boolean _resolve) {
		Collection result = new ArrayList();

		if (_resolve) {
			resolveAll(eObject);
		}

		EObject eContainer = eObject.eContainer();
		if (eContainer != null) {
			result.add(((InternalEObject) eContainer).eSetting(eObject
					.eContainmentFeature()));
		}

		Collection nonNavigableInverseReferences = (Collection) inverseCrossReferencer
				.get(eObject);
		if (nonNavigableInverseReferences != null) {
			result.addAll(nonNavigableInverseReferences);
		}

		for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i
				.hasNext();) {
			EReference eReference = (EReference) i.next();
			EReference eOpposite = eReference.getEOpposite();
			if (eOpposite != null && !eReference.isContainer()
					&& !eReference.isContainment()
					&& eObject.eIsSet(eReference)) {
				if (FeatureMapUtil.isMany(eObject, eReference)) {
					Object collection = eObject.eGet(eReference);
					for (Iterator j = resolve() ? ((Collection) collection)
							.iterator() : ((InternalEList) collection)
							.basicIterator(); j.hasNext();) {
						InternalEObject referencingEObject = (InternalEObject) j
								.next();
						result.add(referencingEObject.eSetting(eOpposite));
					}
				} else {
					// although the reference is set, the value could be null
					InternalEObject referencingEObject = ((InternalEObject) eObject
							.eGet(eReference, resolve()));
					if (referencingEObject != null) {
						result.add(referencingEObject.eSetting(eOpposite));
					}
				}
			}
		}

		return result;
	}

	/**
	 * Computes the references defined by the specified EClass that are
	 * {@@linkplain EStructuralFeature#isChangeable() changeable}.
	 * 
	 * @@param eCls an EClass
	 * @@return a list of its {@@link EReference}s that are changeable
	 */
    private static List getCrossReferencesChangeableFeatures(EClass eCls) {
        List features = (List) eClassToChangeableFeatures.get(eCls);
        if (features == null) {
            features = nullList;
            EStructuralFeature[] crossReferenceFeatures =

            ((EClassImpl.FeatureSubsetSupplier) eCls
                .getEAllStructuralFeatures()).crossReferences();
            if (crossReferenceFeatures != null) {
                features = new ArrayList(crossReferenceFeatures.length);
                for (int i = 0; i < crossReferenceFeatures.length; i++) {
                    EStructuralFeature feature = crossReferenceFeatures[i];
                    if (isMutable(feature))
                        features.add(feature);
                }
            }
            eClassToChangeableFeatures.put(eCls, features);
        }
        return features != nullList ? features
            : null;
    }

    /**
     * Queries whether a feature is mutable.  A feature is considered
     * mutable if and only if it is changeable and it is either not derived
     * or it is a member of a feature map (though not itself a feature map).
     * 
     * @@param feature the feature to test
     * 
     * @@return <code>true</code> if the reference is mutable;
     *     <code>false</code>, otherwise
     */
    static boolean isMutable(EStructuralFeature feature) {
        boolean result = feature.isChangeable();
        
        if (result) {
            if (feature.isDerived()) {
                // check whether it is a feature-map member that is not, itself,
                //    a feature map
                EStructuralFeature group = ExtendedMetaData.INSTANCE.getGroup(feature);
                
                result = (group != null) && !FeatureMapUtil.isFeatureMap(feature);
            }
        }
        
        return result;
    }

	/**
	 * An iterator over the references defined by the specified EObject that
	 * are {@@linkplain EStructuralFeature#isChangeable() changeable}.
	 * 
	 * @@param eObj an EObject
	 * @@return an iterator over its {@@link EReference}s that are changeable
	 */
    private EContentsEList.FeatureIterator getOptimizedCrossReferenceIterator(
            EObject eObj) {
        List features = getCrossReferencesChangeableFeatures(eObj.eClass());
        if (features != null) {
            EContentsEList list = null;
            if (features.size() > 0) {
                list = new ECrossReferenceEList(eObj,
                    (EStructuralFeature[]) features
                        .toArray(new EStructuralFeature[features.size()])) {
                    // to get to the protected constructor
                };
            } else {
                list = ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST;
            }

            return (EContentsEList.FeatureIterator) (resolve() ? list
                .iterator()
                : ((InternalEList) list).basicIterator());
        }
        return (EContentsEList.FeatureIterator) ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST
            .iterator();
    }

	/**
     * Like the {@@link #getInverseReferences(EObject, boolean)} method,
     * obtains settings implementing references to the specified object,
     * except that it only considers references that are
     * {@@linkplain EStructuralFeature#isChangeable() changeable} and can
     * {@@linkplain EReference#isResolveProxies() reference other resources}.
     * 
     * @@param eObject the referenced EObject
     * @@param resolve whether to resolve proxies or not
     * 
     * @@return a collection of {@@link EStructuralFeature.Setting}s on
     *     potentially cross-resource references
     */
    public Collection getInverseReferencesCrossResource(EObject eObject, boolean resolve) {
        Collection result = new ArrayList();

        if (resolve) {
            resolveAll(eObject);
        }

        EObject eContainer = eObject.eContainer();
        if (eContainer != null) {
            result.add(((InternalEObject) eContainer).eSetting(eObject
                    .eContainmentFeature()));
        }

        Collection nonNavigableInverseReferences = (Collection) inverseCrossReferencer
                .get(eObject);
        if (nonNavigableInverseReferences != null) {
            result.addAll(nonNavigableInverseReferences);
        }

        for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i
                .hasNext();) {
            EReference eReference = (EReference) i.next();
            EReference eOpposite = eReference.getEOpposite();
            
            if (eOpposite != null
            		&& isImportExportCapable(eReference, eObject)
            		&& eObject.eIsSet(eReference)) {
                if (FeatureMapUtil.isMany(eObject, eReference)) {
                    Object collection = eObject.eGet(eReference);
                    for (Iterator j = resolve() ? ((Collection) collection)
                            .iterator() : ((InternalEList) collection)
                            .basicIterator(); j.hasNext();) {
                        InternalEObject referencingEObject = (InternalEObject) j
                                .next();
                        result.add(referencingEObject.eSetting(eOpposite));
                    }
                } else {
                    // although the reference is set, the value could be null
                    InternalEObject referencingEObject = ((InternalEObject) eObject
                            .eGet(eReference, resolve()));
                    if (referencingEObject != null) {
                        result.add(referencingEObject.eSetting(eOpposite));
                    }
                }
            }
        }

        return result;
    }
    
    /**
     * Queries whether the specified reference, applied to the given owner
     * object, is capable of establishing a resource import or export by
     * virtue of being a mutable cross-resource reference.
     * <p>
     * A reference is considered to support resource imports and exports if
     * all of the following apply:
     * </p>
     * <ul>
     *   <li>the reference is not a container or containment reference.  Note
     *       that this excludes cross-resource containment from registering
     *       as an import/export dependency</li>
     *   <li>the reference resolves proxies</li>
     *   <li>the reference is changeable</li>
     * </ul>
     * 
     * @@param reference a reference feature
     * @@param owner an object under consideration that defines this reference.
     *     Subclasses may need to introspect the object or its EClass to further
     *     refine their criteria
     * 
     * @@return <code>true</code> if this reference in the context of this
     *     owner should be counted for resource imports and exports;
     *     false, otherwise
     */
   protected boolean isImportExportCapable(EReference reference, EObject owner) {
    	return !reference.isContainer()
        	&& !reference.isContainment()
        	&& reference.isResolveProxies() // can be cross-resource
        	&& reference.isChangeable();    // not computed
    }
}@


1.13
log
@[167297] gmf_head crevells 061211 CrossReferenceAdapter may trigger a resolve because it calls eIsSet on derived features
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
@


1.12
log
@ [160927]   gmf_head mmostafa 061123 CrossReferenceAdapter takes to long to clean up imports/exports on unload
Contributed by : Christian Damus
@
text
@d39 1
d952 1
a952 1
                    if (feature.isChangeable())
d962 26
@


1.11
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d255 6
@


1.10
log
@[142080], gmf_head, vramaswa, 060516, Adopt the updated ECrossReferenceAdapter within the GMF CrossReferenceAdapter
@
text
@d30 1
d33 1
d38 1
d60 4
d124 1
a124 1
		if (reference.isContainment()) {
d293 9
a301 4
				for (Iterator iter = adapter.getInverseReferencers(value, null,
						null).iterator(); iter.hasNext();) {
					registerReference(((EObject) iter.next()).eResource(),
							resource);
d306 3
a308 4
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? value
					.eCrossReferences().iterator()
					: ((InternalEList) value.eCrossReferences())
							.basicIterator());
d316 1
a316 2
					// we ignore unchangeable references
					if (eReference.isChangeable()) {
d325 10
a334 5
				for (Iterator iter = adapter.getInverseReferencers(value, null,
						null).iterator(); iter.hasNext();) {
					deregisterReference(((EObject) iter.next()).eResource(),
							resource);
				}
d378 3
a380 4
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? eObject
					.eCrossReferences().iterator()
					: ((InternalEList) eObject.eCrossReferences())
							.basicIterator());
d388 1
a388 2
					// we ignore unchangeable references
					if (eReference.isChangeable()) {
d694 37
d877 1
a877 1
	public Collection getInverseReferences(EObject eObject, boolean resolve) {
d880 1
a880 1
		if (resolve) {
d925 154
@


1.10.2.1
log
@[146411] gmf_R1_0_maintenance mgoyal 060711 CrossReferenceAdapter is consuming too time iterating over derived features and never uses the values of these features
@
text
@a29 1
import org.eclipse.emf.ecore.EStructuralFeature;
a31 1
import org.eclipse.emf.ecore.impl.EClassImpl;
a35 1
import org.eclipse.emf.ecore.util.ECrossReferenceEList;
a57 4
    private static Map eClassToChangeableFeatures = new HashMap();

    private static List nullList = new ArrayList(1);
    
d294 2
a295 2
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() 
                    ? getOptimizedCrossReferenceIterator(value)
d363 2
a364 2
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() 
                    ? getOptimizedCrossReferenceIterator(eObject)
a874 45
    
    private static List getCrossReferencesChangeableFeatures(EClass eCls) {
        List features = (List) eClassToChangeableFeatures.get(eCls);
        if (features == null) {
            features = nullList;
            EStructuralFeature[] crossReferenceFeatures =

            ((EClassImpl.FeatureSubsetSupplier) eCls
                .getEAllStructuralFeatures()).crossReferences();
            if (crossReferenceFeatures != null) {
                features = new ArrayList(crossReferenceFeatures.length);
                for (int i = 0; i < crossReferenceFeatures.length; i++) {
                    EStructuralFeature feature = crossReferenceFeatures[i];
                    if (feature.isChangeable())
                        features.add(feature);
                }
            }
            eClassToChangeableFeatures.put(eCls, features);
        }
        return features != nullList ? features
            : null;
    }

    private EContentsEList.FeatureIterator getOptimizedCrossReferenceIterator(
            EObject eObj) {
        List features = getCrossReferencesChangeableFeatures(eObj.eClass());
        if (features != null) {
            EContentsEList list = null;
            if (features.size() > 0) {
                list = new ECrossReferenceEList(eObj,
                    (EStructuralFeature[]) features
                        .toArray(new EStructuralFeature[features.size()])) {
                    // to get to the protected constructor
                };
            } else {
                list = ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST;
            }

            return (EContentsEList.FeatureIterator) (resolve() ? list
                .iterator()
                : ((InternalEList) list).basicIterator());
        }
        return (EContentsEList.FeatureIterator) ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST
            .iterator();
    }
@


1.10.2.2
log
@[147312] gmf_R1_0_maintenance mgoyal 060711 CrossReferenceAdapter updateImportsAndExports performance can be improved by 10%
@
text
@d55 1
a55 1
    private Map imports = new HashMap();
d57 1
a57 1
    private Map exports = new HashMap();
d59 1
a59 1
    private boolean resolve = true;
d61 1
a61 6
    /**
     * Initializes me.
     */
    public CrossReferenceAdapter() {
        this(true);
    }
d63 816
a878 249
    /**
     * Initializes me.
     * 
     * @@param resolve
     *            flag to determine if the proxies need to be resolved
     */
    public CrossReferenceAdapter(boolean resolve) {
        super();

        this.resolve = resolve;
    }

    /**
     * Updates imports and exports maps.
     * 
     * @@param notification
     *            the event notification
     */
    public void selfAdapt(Notification notification) {
        super.selfAdapt(notification);
        Object notifier = notification.getNotifier();
        Object feature = notification.getFeature();

        // update import / export information when a resource
        // is unloaded or loaded
        if (notifier instanceof Resource) {
            if (notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_LOADED) {
                if (!notification.getNewBooleanValue()) {
                    deregisterReferences((Resource) notifier);
                } else {
                    for (Iterator i = ((Resource) notifier).getContents()
                            .iterator(); i.hasNext();) {
                        EObject child = (EObject) i.next();
                        if (child != null) {
                            updateImportsAndExports((Resource) notifier, child,
                                    true);
                        }
                    }
                }
            }

            return;
        }

        // interested in maintaining import / export information
        // when the notifier is an EObject and the feature is a
        // non-containment EReference
        if (!(notifier instanceof EObject) || !(feature instanceof EReference)) {
            return;
        }

        EReference reference = (EReference) feature;
        if (reference.isContainment()) {
            return;
        }

        switch (notification.getEventType()) {
        case Notification.RESOLVE:
        case Notification.SET:
        case Notification.UNSET: {
            EObject oldValue = (EObject) notification.getOldValue();
            if (oldValue != null) {
                deregisterReference(((EObject) notification.getNotifier())
                        .eResource(), oldValue.eResource());
            }
            EObject newValue = (EObject) notification.getNewValue();
            if (newValue != null) {
                registerReference(((EObject) notification.getNotifier())
                        .eResource(), newValue.eResource());
            }
            break;
        }
        case Notification.ADD: {
            EObject newValue = (EObject) notification.getNewValue();
            if (newValue != null) {
                registerReference(((EObject) notification.getNotifier())
                        .eResource(), newValue.eResource());
            }
            break;
        }
        case Notification.ADD_MANY: {
            Collection newValues = (Collection) notification.getNewValue();
            for (Iterator i = newValues.iterator(); i.hasNext();) {
                EObject newValue = (EObject) i.next();
                registerReference(((EObject) notification.getNotifier())
                        .eResource(), newValue.eResource());
            }
            break;
        }
        case Notification.REMOVE: {
            EObject oldValue = (EObject) notification.getOldValue();
            if (oldValue != null) {
                deregisterReference(((EObject) notification.getNotifier())
                        .eResource(), oldValue.eResource());
            }
            break;
        }
        case Notification.REMOVE_MANY: {
            Collection oldValues = (Collection) notification.getOldValue();
            for (Iterator i = oldValues.iterator(); i.hasNext();) {
                EObject oldValue = (EObject) i.next();
                deregisterReference(((EObject) notification.getNotifier())
                        .eResource(), oldValue.eResource());
            }
            break;
        }
        }
    }

    /**
     * Extends the superclass method to handle the removal cases of containment,
     * to tear down aggregate (resource-level) cross-references.
     */
    protected void handleContainment(Notification notification) {
        super.handleContainment(notification);

        Object notifier = notification.getNotifier();
        if (notifier instanceof ResourceSet) {
            // not interested in removal of resources from the resource set
            return;
        }

        switch (notification.getEventType()) {
        case Notification.ADD: {
            EObject newValue = (EObject) notification.getNewValue();

            if (newValue != null) {
                Resource resource;
                if (notifier instanceof Resource) {
                    resource = (Resource) notifier;
                } else {
                    resource = ((EObject) notification.getNotifier())
                            .eResource();
                }

                // handle processing of the new value that has been added
                updateImportsAndExports(resource, newValue, true);
            }

            break;
        }
        case Notification.ADD_MANY: {
            Resource resource;
            if (notifier instanceof Resource) {
                resource = (Resource) notifier;
            } else {
                resource = ((EObject) notification.getNotifier()).eResource();
            }

            Collection newValues = (Collection) notification.getNewValue();

            for (Iterator iter = newValues.iterator(); iter.hasNext();) {
                EObject next = (EObject) iter.next();

                if (next != null) {
                    // handle processing of the new value that has been added
                    updateImportsAndExports(resource, next, true);
                }
            }
            break;
        }

        case Notification.REMOVE: {
            EObject oldValue = (EObject) notification.getOldValue();

            if (oldValue != null) {
                Resource resource;
                if (notifier instanceof Resource) {
                    resource = (Resource) notifier;
                } else {
                    resource = ((EObject) notification.getNotifier())
                            .eResource();
                }

                // handle processing of the old value that has been removed
                updateImportsAndExports(resource, oldValue, false);
            }
            break;
        }
        case Notification.REMOVE_MANY: {
            Resource resource;
            if (notifier instanceof Resource) {
                resource = (Resource) notifier;
            } else {
                resource = ((EObject) notification.getNotifier()).eResource();
            }

            Collection oldValues = (Collection) notification.getOldValue();

            for (Iterator iter = oldValues.iterator(); iter.hasNext();) {
                EObject next = (EObject) iter.next();

                if (next != null) {
                    // handle processing of the old value that has been removed
                    updateImportsAndExports(resource, next, false);
                }
            }
            break;
        }
        }
    }

    /**
     * Updates the imports and exports map for the specified eObject
     * 
     * @@param resource
     *            a resource
     * @@param eObject
     *            the specified eObject
     * @@param register
     *            boolean flag to indicate whether to register imports or
     *            unregister imports
     */
    public void updateImportsAndExports(Resource resource, EObject value,
            boolean register) {
        CrossReferenceAdapter adapter = getExistingCrossReferenceAdapter(value);

        if (register) {
            if (adapter != null) {
                // now, register incoming unidirectional references and
                // opposites
                for (Iterator iter = adapter.getInverseReferencersCrossResource(value, null,
                        null).iterator(); iter.hasNext();) {
                    registerReference(((EObject) iter.next()).eResource(),
                            resource);
                }
            }
        } else {
            // deregister the outgoing references and incoming bidirectionals
//          EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? value
//                  .eCrossReferences().iterator()
//                  : ((InternalEList) value.eCrossReferences())
//                          .basicIterator());
            EContentsEList.FeatureIterator crossReferences = getOptimizedCrossReferenceIterator(value);
            
            while (crossReferences.hasNext()) {
                EObject referent = (EObject) crossReferences.next();

                if (referent != null) {
                    EReference eReference = (EReference) crossReferences
                            .feature();

                    // we ignore unchangeable references
                    if (eReference.isChangeable()) {
                        Resource referencedResource = referent.eResource();
                        deregisterReference(resource, referencedResource);
                    }
                }
            }
d880 2
a881 16
            // now, deregister incoming unidirectional references and opposites
            if (adapter != null) {
                for (Iterator iter = adapter.getInverseReferencersCrossResource(value, null,
                        null).iterator(); iter.hasNext();) {
                    deregisterReference(((EObject) iter.next()).eResource(),
                            resource);
                }
            }
        }

        // process contents
        if (adapter != null) {
            adapter.updateImportsAndExportsForContents(resource, value,
                    register);
        }
    }
a882 2
    private static Map eClassToChangeableFeatures = new HashMap();
    private static List nullList = new ArrayList(1);
d884 2
a885 2
        List features = (List)eClassToChangeableFeatures.get(eCls);
        if(features == null) {
d887 5
a891 3
            EStructuralFeature [] crossReferenceFeatures = 
                ((EClassImpl.FeatureSubsetSupplier)eCls.getEAllStructuralFeatures()).crossReferences();
            if(crossReferenceFeatures != null) {
d893 1
a893 1
                for(int i=0; i<crossReferenceFeatures.length; i++) {
d895 1
a895 1
                    if(feature.isChangeable())
d901 2
a902 1
        return features != nullList ? features : null;
d904 3
a906 2
    
    private EContentsEList.FeatureIterator getOptimizedCrossReferenceIterator(EObject eObj) {
d908 1
a908 1
        if(features != null) {
d910 4
a913 2
            if(features.size() > 0) {
                list = new ECrossReferenceEList(eObj, (EStructuralFeature[])features.toArray(new EStructuralFeature[features.size()])) {
a918 586
    
            return (EContentsEList.FeatureIterator) (resolve() ? list.iterator()
                : ((InternalEList) list)
                        .basicIterator());
        }
        return (EContentsEList.FeatureIterator)ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST.iterator();
    }

    /**
     * Updates the imports and exports map for the contents of the specified
     * eObject
     * 
     * @@param resource
     *            a resource
     * @@param eObject
     *            the specified eObject
     * @@param register
     *            boolean flag to indicate whether to register imports or
     *            unregister imports
     */
    public void updateImportsAndExportsForContents(Resource resource,
            EObject value, boolean register) {
        // go through the children of the eObject
        for (Iterator i = resolve() ? value.eContents().iterator()
                : ((InternalEList) value.eContents()).basicIterator(); i
                .hasNext();) {
            updateImportsAndExports(resource, (EObject) i.next(), register);
        }
    }

    /**
     * @@see org.eclipse.emf.ecore.util.ECrossReferenceAdapter#setTarget(org.eclipse.emf.common.notify.Notifier)
     */
    public void setTarget(Notifier target) {
        super.setTarget(target);

        if (target instanceof EObject) {
            EObject eObject = (EObject) target;
            Resource resource = eObject.eResource();

            // register the outgoing references and incoming bidirectionals
//          EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? eObject
//                  .eCrossReferences().iterator()
//                  : ((InternalEList) eObject.eCrossReferences())
//                          .basicIterator());
            EContentsEList.FeatureIterator crossReferences = getOptimizedCrossReferenceIterator(eObject);
            while (crossReferences.hasNext()) {
                EObject referent = (EObject) crossReferences.next();

                if (referent != null) {
                    EReference eReference = (EReference) crossReferences
                            .feature();

                    // we ignore unchangeable references
                    if (eReference.isChangeable()) {
                        Resource referencedResource = referent.eResource();
                        registerReference(resource, referencedResource);
                    }
                }
            }
        }
    }

    /**
     * @@see org.eclipse.emf.ecore.util.ECrossReferenceAdapter#unsetTarget(org.eclipse.emf.common.notify.Notifier)
     */
    public void unsetTarget(Notifier notifier) {
        super.unsetTarget(notifier);
        if (notifier instanceof Resource) {
            deregisterReferences((Resource) notifier);
        }
    }

    /**
     * Gets the imports of a resource.
     * 
     * @@param referencer
     *            the resource to retrieve imports for
     * @@return a Set of resource imports
     */
    public Set getImports(Resource referencer) {

        Map importsMap = getImportsMap(referencer);

        if (importsMap != null) {
            return Collections.unmodifiableSet(importsMap.keySet());
        } else {
            return Collections.EMPTY_SET;
        }
    }

    /**
     * Gets the exports of a resource.
     * 
     * @@param referenced
     *            the resource to retrieve exports for
     * @@return a Set of resource exports
     */
    public Set getExports(Resource referenced) {

        Map exportsMap = getExportsMap(referenced);

        if (exportsMap != null) {
            return Collections.unmodifiableSet(exportsMap.keySet());
        } else {
            return Collections.EMPTY_SET;
        }
    }

    /**
     * Returns the imports map of the given resource.
     * 
     * @@param resource
     * @@return imports map of the given resource
     */
    private Map getImportsMap(Resource resource) {
        return (Map) imports.get(resource);
    }

    /**
     * Returns the exports map of the given resource.
     * 
     * @@param resource
     * @@return exports map of the given resource
     */
    private Map getExportsMap(Resource resource) {
        return (Map) exports.get(resource);
    }

    /**
     * Registers a reference updating the imports and exports maps accordingly.
     * 
     * @@param referencer
     *            the referencing resource
     * @@param referenced
     *            the referenced resouce
     */
    private void registerReference(final Resource referencer,
            final Resource referenced) {

        if ((referencer != null) && (referenced != null)
                && (referencer != referenced)) {

            Map importsMap = getImportsMap(referencer);

            if (importsMap == null) {
                importsMap = new HashMap();
                imports.put(referencer, importsMap);
            }

            Counter importsCount = (Counter) importsMap.get(referenced);

            if (importsCount == null) {

                importsCount = new Counter();
                importsMap.put(referenced, importsCount);

                importAdded(referencer, referenced);
            } else {
                importsCount.inc();
            }

            Map exportsMap = getExportsMap(referenced);

            if (exportsMap == null) {
                exportsMap = new HashMap();
                exports.put(referenced, exportsMap);
            }

            Counter exportsCount = (Counter) exportsMap.get(referencer);

            if (exportsCount == null) {

                exportsCount = new Counter();
                exportsMap.put(referencer, exportsCount);

                exportAdded(referenced, referencer);
            } else {
                exportsCount.inc();
            }
        }
    }

    /**
     * Hook to be implemented by subclasses upon the establishment of a new
     * import of the <code>referenced</code> resource by the
     * <code>referencer</code>. This implementation does nothing; subclasses
     * need not call <code>super</code>.
     * 
     * @@param referencer
     *            the referencing resource (doing the importing)
     * @@param referenced
     *            the resource that it references
     */
    protected void importAdded(Resource referencer, Resource referenced) {
        // subclass hook
    }

    /**
     * Hook to be implemented by subclasses upon the elimination of an import of
     * the <code>referenced</code> resource by the <code>referencer</code>.
     * This implementation does nothing; subclasses need not call
     * <code>super</code>.
     * 
     * @@param referencer
     *            the formerly referencing resource (doing the importing)
     * @@param referenced
     *            the resource that it had referenced
     */
    protected void importRemoved(Resource referencer, Resource referenced) {
        // subclass hook
    }

    /**
     * Hook to be implemented by subclasses upon the establishment of a new
     * export of the <code>referenced</code> resource to the
     * <code>referencer</code>. This implementation does nothing; subclasses
     * need not call <code>super</code>.
     * 
     * @@param referenced
     *            the resource being referenced (doing the exporting)
     * @@param referencer
     *            the referencing resource
     */
    protected void exportAdded(Resource referenced, Resource referencer) {
        // subclass hook
    }

    /**
     * Hook to be implemented by subclasses upon the elimination of an export of
     * the <code>referenced</code> resource to the <code>referencer</code>.
     * This implementation does nothing; subclasses need not call
     * <code>super</code>.
     * 
     * @@param referenced
     *            the resource formerly being referenced (doing the exporting)
     * @@param referencer
     *            the formerly referencing resource
     */
    protected void exportRemoved(Resource referenced, Resource referencer) {
        // subclass hook
    }

    /**
     * Deregisters a reference updating the imports and exports maps
     * accordingly.
     * 
     * @@param referencer
     *            the referencing resource
     * @@param referenced
     *            the referenced resource
     */
    private void deregisterReference(final Resource referencer,
            final Resource referenced) {

        if ((referencer != null) && (referenced != null)
                && (referencer != referenced)) {

            Map importsMap = getImportsMap(referencer);

            if (importsMap != null) {

                Counter importsCount = (Counter) importsMap.get(referenced);

                if ((importsCount != null) && importsCount.dec()) {

                    importsMap.remove(referenced);

                    importRemoved(referencer, referenced);

                    if (importsMap.isEmpty()) {
                        imports.remove(referencer);
                    }
                }
            }

            Map exportsMap = getExportsMap(referenced);

            if (exportsMap != null) {

                Counter exportsCount = (Counter) exportsMap.get(referencer);

                if ((exportsCount != null) && exportsCount.dec()) {

                    exportsMap.remove(referencer);

                    exportRemoved(referenced, referencer);

                    if (exportsMap.isEmpty()) {
                        exports.remove(referenced);
                    }
                }
            }
        }
    }

    /**
     * Cleans up a resource from the imports and exports maps.
     * 
     * @@param referencer
     *            the referencing resource
     */
    private void deregisterReferences(final Resource referencer) {

        Object[] resImports = getImports(referencer).toArray();

        for (int i = 0; i < resImports.length; i++) {

            final Resource referenced = (Resource) resImports[i];

            Map importsMap = getImportsMap(referencer);

            if (importsMap != null) {

                importsMap.remove(referenced);

                importRemoved(referencer, referenced);

                if (importsMap.isEmpty()) {
                    imports.remove(referencer);
                }
            }

            Map exportsMap = getExportsMap(referenced);

            if (exportsMap != null) {

                exportsMap.remove(referencer);

                exportRemoved(referenced, referencer);

                if (exportsMap.isEmpty()) {
                    exports.remove(referenced);
                }
            }
        }
    }

    /**
     * Returns a Set of EObjects that reference the given EObject. If an
     * EReference is specified, the scope of the search is limited only to that
     * EReference. To include all references specify a value of null. If an
     * EClass type is specified, the returned Set will only include those
     * referencers that match the given type. To include all types specify a
     * value of null.
     * 
     * @@param referenced
     *            the referenced EObject
     * @@param reference
     *            the reference to find referencers on, null for any reference
     * @@param type
     *            the type of the referencers, use null for any type
     * @@return a Set of referencers
     */
    public Set getInverseReferencers(EObject referenced, EReference reference,
            EClass type) {
        return getReferencers(getInverseReferences(referenced), reference, type);
    }
    
    /**
     * Returns a Set of EObjects that reference the given EObject. If an
     * EReference is specified, the scope of the search is limited only to that
     * EReference. To include all references specify a value of null. If an
     * EClass type is specified, the returned Set will only include those
     * referencers that match the given type. To include all types specify a
     * value of null.
     * 
     * @@param referenced
     *            the referenced EObject
     * @@param reference
     *            the reference to find referencers on, null for any reference
     * @@param type
     *            the type of the referencers, use null for any type
     * @@return a Set of referencers
     */
    public Set getInverseReferencersCrossResource(EObject referenced, EReference reference,
            EClass type) {
        return getReferencers(getInverseReferencesCrossResource(referenced), reference, type);
    }
    
    public Collection getInverseReferencesCrossResource(EObject eObject) {
        return getInverseReferencesCrossResource(eObject, !resolve());
    }

    /**
     * Returns a Set of EObjects that reference the given EObject through a uni
     * directional EReferences. If an EReference is specified, the scope of the
     * search is limited only to that EReference. To include all references
     * specify a value of null. If an EClass type is specified, the returned Set
     * will only include those referencers that match the given type. To include
     * all types specify a value of null.
     * 
     * @@param referenced
     *            the referenced EObject
     * @@param reference
     *            the reference to find referencers on, null for any reference
     * @@param type
     *            the type of the referencers, use null for any type
     * @@return a Set of referencers
     */
    public Set getNonNavigableInverseReferencers(EObject referenced,
            EReference reference, EClass type) {
        return getReferencers(getNonNavigableInverseReferences(referenced),
                reference, type);
    }

    /**
     * Extracts the EObjects from the EStructuralFeature.Setting references and
     * returns a filtered Set based on the given reference and type.
     * 
     * @@param references
     *            a collection of EStructuralFeature.Setting
     * @@param reference
     *            the reference to find referencers on, null for any reference
     * @@param type
     *            the type of the referencers, use null for any type
     * @@return a Set of referencers
     */
    private Set getReferencers(Collection references, EReference reference,
            EClass type) {
        Set set = new HashSet();
        if (!references.isEmpty()) {
            for (Iterator iter = references.iterator(); iter.hasNext();) {
                Setting setting = (Setting) iter.next();
                if (reference == null
                        || reference == setting.getEStructuralFeature()) {
                    EObject referencer = setting.getEObject();
                    if (referencer != null
                            && (type == null || type.isInstance(referencer))) {
                        set.add(referencer);
                    }
                }
            }
        }
        return set;
    }

    /**
     * Searches the adapter list of the given Notifier for a
     * CrossReferenceAdapter. If not found, returns null.
     * 
     * @@param notifier
     *            the notifier to search
     * @@return the CrossReferenceAdapter if found, otherwise null
     */
    public static CrossReferenceAdapter getExistingCrossReferenceAdapter(
            Notifier notifier) {
        if (notifier == null) {
            return null;
        }

        List adapters = notifier.eAdapters();

        for (int i = 0, size = adapters.size(); i < size; ++i) {
            Adapter adapter = (Adapter) adapters.get(i);
            if (adapter instanceof CrossReferenceAdapter) {
                return (CrossReferenceAdapter) adapter;
            }
        }
        return null;
    }

    /**
     * Obtains the cross-reference adapter for the specified resource set, if
     * necessary creating it and attaching it.
     * 
     * @@param resourceSet
     *            the resource set
     * 
     * @@return the resourceSet's cross-reference adapter
     */
    public static CrossReferenceAdapter getCrossReferenceAdapter(
            ResourceSet resourceSet) {
        if (resourceSet == null) {
            return null;
        }

        CrossReferenceAdapter result = getExistingCrossReferenceAdapter(resourceSet);

        if (result == null) {
            result = new CrossReferenceAdapter();
            resourceSet.eAdapters().add(result);
        }

        return result;
    }

    /**
     * A mutable integer used to count number of object-level references between
     * two resources.
     * 
     * @@author Christian W. Damus (cdamus)
     */
    private static final class Counter {
        private int value = 1;

        Counter() {
            super();
        }

        /**
         * Obtains my value.
         * 
         * @@return my count
         */
        int getValue() {
            return value;
        }

        /**
         * Increments me.
         */
        void inc() {
            value++;
        }

        /**
         * Decrements me.
         * 
         * @@return <code>true</code> if I am now zero; <code>false</code>,
         *         otherwise
         */
        boolean dec() {
            return --value <= 0;
        }
    }

    protected boolean resolve() {
        return this.resolve;
    }

    public Collection getInverseReferences(EObject eObject, boolean resolve) {
        Collection result = new ArrayList();

        if (resolve) {
            resolveAll(eObject);
        }

        EObject eContainer = eObject.eContainer();
        if (eContainer != null) {
            result.add(((InternalEObject) eContainer).eSetting(eObject
                    .eContainmentFeature()));
        }

        Collection nonNavigableInverseReferences = (Collection) inverseCrossReferencer
                .get(eObject);
        if (nonNavigableInverseReferences != null) {
            result.addAll(nonNavigableInverseReferences);
        }

        for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i
                .hasNext();) {
            EReference eReference = (EReference) i.next();
            EReference eOpposite = eReference.getEOpposite();
            if (eOpposite != null && !eReference.isContainer()
                    && !eReference.isContainment()
                    && eObject.eIsSet(eReference)) {
                if (FeatureMapUtil.isMany(eObject, eReference)) {
                    Object collection = eObject.eGet(eReference);
                    for (Iterator j = resolve() ? ((Collection) collection)
                            .iterator() : ((InternalEList) collection)
                            .basicIterator(); j.hasNext();) {
                        InternalEObject referencingEObject = (InternalEObject) j
                                .next();
                        result.add(referencingEObject.eSetting(eOpposite));
                    }
                } else {
                    // although the reference is set, the value could be null
                    InternalEObject referencingEObject = ((InternalEObject) eObject
                            .eGet(eReference, resolve()));
                    if (referencingEObject != null) {
                        result.add(referencingEObject.eSetting(eOpposite));
                    }
                }
            }
        }

        return result;
    }

    public Collection getInverseReferencesCrossResource(EObject eObject, boolean resolve) {
        Collection result = new ArrayList();

        if (resolve) {
            resolveAll(eObject);
        }
d920 3
a922 4
        EObject eContainer = eObject.eContainer();
        if (eContainer != null) {
            result.add(((InternalEObject) eContainer).eSetting(eObject
                    .eContainmentFeature()));
d924 2
a925 36

        Collection nonNavigableInverseReferences = (Collection) inverseCrossReferencer
                .get(eObject);
        if (nonNavigableInverseReferences != null) {
            result.addAll(nonNavigableInverseReferences);
        }

        for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i
                .hasNext();) {
            EReference eReference = (EReference) i.next();
            EReference eOpposite = eReference.getEOpposite();
            
            if (eOpposite != null && !eReference.isContainer()
                    && !eReference.isContainment() && eReference.isResolveProxies() && !eReference.isDerived()
                    && eObject.eIsSet(eReference)) {
                if (FeatureMapUtil.isMany(eObject, eReference)) {
                    Object collection = eObject.eGet(eReference);
                    for (Iterator j = resolve() ? ((Collection) collection)
                            .iterator() : ((InternalEList) collection)
                            .basicIterator(); j.hasNext();) {
                        InternalEObject referencingEObject = (InternalEObject) j
                                .next();
                        result.add(referencingEObject.eSetting(eOpposite));
                    }
                } else {
                    // although the reference is set, the value could be null
                    InternalEObject referencingEObject = ((InternalEObject) eObject
                            .eGet(eReference, resolve()));
                    if (referencingEObject != null) {
                        result.add(referencingEObject.eSetting(eOpposite));
                    }
                }
            }
        }

        return result;
@


1.10.2.3
log
@[146411, 147312] gmf_R1_0_maintenance ldamus 060710 Rolling back fixes for these bugs.  Further investigation required, since they may have broken cross references involving feature maps.
@
text
@d30 1
d33 1
d38 1
d55 1
a55 1
	private Map imports = new HashMap();
d57 1
a57 1
	private Map exports = new HashMap();
d59 1
a59 1
	private boolean resolve = true;
d61 932
a992 814
	/**
	 * Initializes me.
	 */
	public CrossReferenceAdapter() {
		this(true);
	}

	/**
	 * Initializes me.
	 * 
	 * @@param resolve
	 *            flag to determine if the proxies need to be resolved
	 */
	public CrossReferenceAdapter(boolean resolve) {
		super();

		this.resolve = resolve;
	}

	/**
	 * Updates imports and exports maps.
	 * 
	 * @@param notification
	 *            the event notification
	 */
	public void selfAdapt(Notification notification) {
		super.selfAdapt(notification);
		Object notifier = notification.getNotifier();
		Object feature = notification.getFeature();

		// update import / export information when a resource
		// is unloaded or loaded
		if (notifier instanceof Resource) {
			if (notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_LOADED) {
				if (!notification.getNewBooleanValue()) {
					deregisterReferences((Resource) notifier);
				} else {
					for (Iterator i = ((Resource) notifier).getContents()
							.iterator(); i.hasNext();) {
						EObject child = (EObject) i.next();
						if (child != null) {
							updateImportsAndExports((Resource) notifier, child,
									true);
						}
					}
				}
			}

			return;
		}

		// interested in maintaining import / export information
		// when the notifier is an EObject and the feature is a
		// non-containment EReference
		if (!(notifier instanceof EObject) || !(feature instanceof EReference)) {
			return;
		}

		EReference reference = (EReference) feature;
		if (reference.isContainment()) {
			return;
		}

		switch (notification.getEventType()) {
		case Notification.RESOLVE:
		case Notification.SET:
		case Notification.UNSET: {
			EObject oldValue = (EObject) notification.getOldValue();
			if (oldValue != null) {
				deregisterReference(((EObject) notification.getNotifier())
						.eResource(), oldValue.eResource());
			}
			EObject newValue = (EObject) notification.getNewValue();
			if (newValue != null) {
				registerReference(((EObject) notification.getNotifier())
						.eResource(), newValue.eResource());
			}
			break;
		}
		case Notification.ADD: {
			EObject newValue = (EObject) notification.getNewValue();
			if (newValue != null) {
				registerReference(((EObject) notification.getNotifier())
						.eResource(), newValue.eResource());
			}
			break;
		}
		case Notification.ADD_MANY: {
			Collection newValues = (Collection) notification.getNewValue();
			for (Iterator i = newValues.iterator(); i.hasNext();) {
				EObject newValue = (EObject) i.next();
				registerReference(((EObject) notification.getNotifier())
						.eResource(), newValue.eResource());
			}
			break;
		}
		case Notification.REMOVE: {
			EObject oldValue = (EObject) notification.getOldValue();
			if (oldValue != null) {
				deregisterReference(((EObject) notification.getNotifier())
						.eResource(), oldValue.eResource());
			}
			break;
		}
		case Notification.REMOVE_MANY: {
			Collection oldValues = (Collection) notification.getOldValue();
			for (Iterator i = oldValues.iterator(); i.hasNext();) {
				EObject oldValue = (EObject) i.next();
				deregisterReference(((EObject) notification.getNotifier())
						.eResource(), oldValue.eResource());
			}
			break;
		}
		}
	}

	/**
	 * Extends the superclass method to handle the removal cases of containment,
	 * to tear down aggregate (resource-level) cross-references.
	 */
	protected void handleContainment(Notification notification) {
		super.handleContainment(notification);

		Object notifier = notification.getNotifier();
		if (notifier instanceof ResourceSet) {
			// not interested in removal of resources from the resource set
			return;
		}

		switch (notification.getEventType()) {
		case Notification.ADD: {
			EObject newValue = (EObject) notification.getNewValue();

			if (newValue != null) {
				Resource resource;
				if (notifier instanceof Resource) {
					resource = (Resource) notifier;
				} else {
					resource = ((EObject) notification.getNotifier())
							.eResource();
				}

				// handle processing of the new value that has been added
				updateImportsAndExports(resource, newValue, true);
			}

			break;
		}
		case Notification.ADD_MANY: {
			Resource resource;
			if (notifier instanceof Resource) {
				resource = (Resource) notifier;
			} else {
				resource = ((EObject) notification.getNotifier()).eResource();
			}

			Collection newValues = (Collection) notification.getNewValue();

			for (Iterator iter = newValues.iterator(); iter.hasNext();) {
				EObject next = (EObject) iter.next();

				if (next != null) {
					// handle processing of the new value that has been added
					updateImportsAndExports(resource, next, true);
				}
			}
			break;
		}

		case Notification.REMOVE: {
			EObject oldValue = (EObject) notification.getOldValue();

			if (oldValue != null) {
				Resource resource;
				if (notifier instanceof Resource) {
					resource = (Resource) notifier;
				} else {
					resource = ((EObject) notification.getNotifier())
							.eResource();
				}

				// handle processing of the old value that has been removed
				updateImportsAndExports(resource, oldValue, false);
			}
			break;
		}
		case Notification.REMOVE_MANY: {
			Resource resource;
			if (notifier instanceof Resource) {
				resource = (Resource) notifier;
			} else {
				resource = ((EObject) notification.getNotifier()).eResource();
			}

			Collection oldValues = (Collection) notification.getOldValue();

			for (Iterator iter = oldValues.iterator(); iter.hasNext();) {
				EObject next = (EObject) iter.next();

				if (next != null) {
					// handle processing of the old value that has been removed
					updateImportsAndExports(resource, next, false);
				}
			}
			break;
		}
		}
	}

	/**
	 * Updates the imports and exports map for the specified eObject
	 * 
	 * @@param resource
	 *            a resource
	 * @@param eObject
	 *            the specified eObject
	 * @@param register
	 *            boolean flag to indicate whether to register imports or
	 *            unregister imports
	 */
	public void updateImportsAndExports(Resource resource, EObject value,
			boolean register) {
		CrossReferenceAdapter adapter = getExistingCrossReferenceAdapter(value);

		if (register) {
			if (adapter != null) {
				// now, register incoming unidirectional references and
				// opposites
				for (Iterator iter = adapter.getInverseReferencers(value, null,
						null).iterator(); iter.hasNext();) {
					registerReference(((EObject) iter.next()).eResource(),
							resource);
				}
			}
		} else {
			// deregister the outgoing references and incoming bidirectionals
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? value
					.eCrossReferences().iterator()
					: ((InternalEList) value.eCrossReferences())
							.basicIterator());
			while (crossReferences.hasNext()) {
				EObject referent = (EObject) crossReferences.next();

				if (referent != null) {
					EReference eReference = (EReference) crossReferences
							.feature();

					// we ignore unchangeable references
					if (eReference.isChangeable()) {
						Resource referencedResource = referent.eResource();
						deregisterReference(resource, referencedResource);
					}
				}
			}

			// now, deregister incoming unidirectional references and opposites
			if (adapter != null) {
				for (Iterator iter = adapter.getInverseReferencers(value, null,
						null).iterator(); iter.hasNext();) {
					deregisterReference(((EObject) iter.next()).eResource(),
							resource);
				}
			}
		}

		// process contents
		if (adapter != null) {
			adapter.updateImportsAndExportsForContents(resource, value,
					register);
		}
	}

	/**
	 * Updates the imports and exports map for the contents of the specified
	 * eObject
	 * 
	 * @@param resource
	 *            a resource
	 * @@param eObject
	 *            the specified eObject
	 * @@param register
	 *            boolean flag to indicate whether to register imports or
	 *            unregister imports
	 */
	public void updateImportsAndExportsForContents(Resource resource,
			EObject value, boolean register) {
		// go through the children of the eObject
		for (Iterator i = resolve() ? value.eContents().iterator()
				: ((InternalEList) value.eContents()).basicIterator(); i
				.hasNext();) {
			updateImportsAndExports(resource, (EObject) i.next(), register);
		}
	}

	/**
	 * @@see org.eclipse.emf.ecore.util.ECrossReferenceAdapter#setTarget(org.eclipse.emf.common.notify.Notifier)
	 */
	public void setTarget(Notifier target) {
		super.setTarget(target);

		if (target instanceof EObject) {
			EObject eObject = (EObject) target;
			Resource resource = eObject.eResource();

			// register the outgoing references and incoming bidirectionals
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? eObject
					.eCrossReferences().iterator()
					: ((InternalEList) eObject.eCrossReferences())
							.basicIterator());
			while (crossReferences.hasNext()) {
				EObject referent = (EObject) crossReferences.next();

				if (referent != null) {
					EReference eReference = (EReference) crossReferences
							.feature();

					// we ignore unchangeable references
					if (eReference.isChangeable()) {
						Resource referencedResource = referent.eResource();
						registerReference(resource, referencedResource);
					}
				}
			}
		}
	}

	/**
	 * @@see org.eclipse.emf.ecore.util.ECrossReferenceAdapter#unsetTarget(org.eclipse.emf.common.notify.Notifier)
	 */
	public void unsetTarget(Notifier notifier) {
		super.unsetTarget(notifier);
		if (notifier instanceof Resource) {
			deregisterReferences((Resource) notifier);
		}
	}

	/**
	 * Gets the imports of a resource.
	 * 
	 * @@param referencer
	 *            the resource to retrieve imports for
	 * @@return a Set of resource imports
	 */
	public Set getImports(Resource referencer) {

		Map importsMap = getImportsMap(referencer);

		if (importsMap != null) {
			return Collections.unmodifiableSet(importsMap.keySet());
		} else {
			return Collections.EMPTY_SET;
		}
	}

	/**
	 * Gets the exports of a resource.
	 * 
	 * @@param referenced
	 *            the resource to retrieve exports for
	 * @@return a Set of resource exports
	 */
	public Set getExports(Resource referenced) {

		Map exportsMap = getExportsMap(referenced);

		if (exportsMap != null) {
			return Collections.unmodifiableSet(exportsMap.keySet());
		} else {
			return Collections.EMPTY_SET;
		}
	}

	/**
	 * Returns the imports map of the given resource.
	 * 
	 * @@param resource
	 * @@return imports map of the given resource
	 */
	private Map getImportsMap(Resource resource) {
		return (Map) imports.get(resource);
	}

	/**
	 * Returns the exports map of the given resource.
	 * 
	 * @@param resource
	 * @@return exports map of the given resource
	 */
	private Map getExportsMap(Resource resource) {
		return (Map) exports.get(resource);
	}

	/**
	 * Registers a reference updating the imports and exports maps accordingly.
	 * 
	 * @@param referencer
	 *            the referencing resource
	 * @@param referenced
	 *            the referenced resouce
	 */
	private void registerReference(final Resource referencer,
			final Resource referenced) {

		if ((referencer != null) && (referenced != null)
				&& (referencer != referenced)) {

			Map importsMap = getImportsMap(referencer);

			if (importsMap == null) {
				importsMap = new HashMap();
				imports.put(referencer, importsMap);
			}

			Counter importsCount = (Counter) importsMap.get(referenced);

			if (importsCount == null) {

				importsCount = new Counter();
				importsMap.put(referenced, importsCount);

				importAdded(referencer, referenced);
			} else {
				importsCount.inc();
			}

			Map exportsMap = getExportsMap(referenced);

			if (exportsMap == null) {
				exportsMap = new HashMap();
				exports.put(referenced, exportsMap);
			}

			Counter exportsCount = (Counter) exportsMap.get(referencer);

			if (exportsCount == null) {

				exportsCount = new Counter();
				exportsMap.put(referencer, exportsCount);

				exportAdded(referenced, referencer);
			} else {
				exportsCount.inc();
			}
		}
	}

	/**
	 * Hook to be implemented by subclasses upon the establishment of a new
	 * import of the <code>referenced</code> resource by the
	 * <code>referencer</code>. This implementation does nothing; subclasses
	 * need not call <code>super</code>.
	 * 
	 * @@param referencer
	 *            the referencing resource (doing the importing)
	 * @@param referenced
	 *            the resource that it references
	 */
	protected void importAdded(Resource referencer, Resource referenced) {
		// subclass hook
	}

	/**
	 * Hook to be implemented by subclasses upon the elimination of an import of
	 * the <code>referenced</code> resource by the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call
	 * <code>super</code>.
	 * 
	 * @@param referencer
	 *            the formerly referencing resource (doing the importing)
	 * @@param referenced
	 *            the resource that it had referenced
	 */
	protected void importRemoved(Resource referencer, Resource referenced) {
		// subclass hook
	}

	/**
	 * Hook to be implemented by subclasses upon the establishment of a new
	 * export of the <code>referenced</code> resource to the
	 * <code>referencer</code>. This implementation does nothing; subclasses
	 * need not call <code>super</code>.
	 * 
	 * @@param referenced
	 *            the resource being referenced (doing the exporting)
	 * @@param referencer
	 *            the referencing resource
	 */
	protected void exportAdded(Resource referenced, Resource referencer) {
		// subclass hook
	}

	/**
	 * Hook to be implemented by subclasses upon the elimination of an export of
	 * the <code>referenced</code> resource to the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call
	 * <code>super</code>.
	 * 
	 * @@param referenced
	 *            the resource formerly being referenced (doing the exporting)
	 * @@param referencer
	 *            the formerly referencing resource
	 */
	protected void exportRemoved(Resource referenced, Resource referencer) {
		// subclass hook
	}

	/**
	 * Deregisters a reference updating the imports and exports maps
	 * accordingly.
	 * 
	 * @@param referencer
	 *            the referencing resource
	 * @@param referenced
	 *            the referenced resource
	 */
	private void deregisterReference(final Resource referencer,
			final Resource referenced) {

		if ((referencer != null) && (referenced != null)
				&& (referencer != referenced)) {

			Map importsMap = getImportsMap(referencer);

			if (importsMap != null) {

				Counter importsCount = (Counter) importsMap.get(referenced);

				if ((importsCount != null) && importsCount.dec()) {

					importsMap.remove(referenced);

					importRemoved(referencer, referenced);

					if (importsMap.isEmpty()) {
						imports.remove(referencer);
					}
				}
			}

			Map exportsMap = getExportsMap(referenced);

			if (exportsMap != null) {

				Counter exportsCount = (Counter) exportsMap.get(referencer);

				if ((exportsCount != null) && exportsCount.dec()) {

					exportsMap.remove(referencer);

					exportRemoved(referenced, referencer);

					if (exportsMap.isEmpty()) {
						exports.remove(referenced);
					}
				}
			}
		}
	}

	/**
	 * Cleans up a resource from the imports and exports maps.
	 * 
	 * @@param referencer
	 *            the referencing resource
	 */
	private void deregisterReferences(final Resource referencer) {

		Object[] resImports = getImports(referencer).toArray();

		for (int i = 0; i < resImports.length; i++) {

			final Resource referenced = (Resource) resImports[i];

			Map importsMap = getImportsMap(referencer);

			if (importsMap != null) {

				importsMap.remove(referenced);

				importRemoved(referencer, referenced);

				if (importsMap.isEmpty()) {
					imports.remove(referencer);
				}
			}

			Map exportsMap = getExportsMap(referenced);

			if (exportsMap != null) {

				exportsMap.remove(referencer);

				exportRemoved(referenced, referencer);

				if (exportsMap.isEmpty()) {
					exports.remove(referenced);
				}
			}
		}
	}

	/**
	 * Returns a Set of EObjects that reference the given EObject. If an
	 * EReference is specified, the scope of the search is limited only to that
	 * EReference. To include all references specify a value of null. If an
	 * EClass type is specified, the returned Set will only include those
	 * referencers that match the given type. To include all types specify a
	 * value of null.
	 * 
	 * @@param referenced
	 *            the referenced EObject
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
	 * @@return a Set of referencers
	 */
	public Set getInverseReferencers(EObject referenced, EReference reference,
			EClass type) {
		return getReferencers(getInverseReferences(referenced), reference, type);
	}

	/**
	 * Returns a Set of EObjects that reference the given EObject through a uni
	 * directional EReferences. If an EReference is specified, the scope of the
	 * search is limited only to that EReference. To include all references
	 * specify a value of null. If an EClass type is specified, the returned Set
	 * will only include those referencers that match the given type. To include
	 * all types specify a value of null.
	 * 
	 * @@param referenced
	 *            the referenced EObject
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
	 * @@return a Set of referencers
	 */
	public Set getNonNavigableInverseReferencers(EObject referenced,
			EReference reference, EClass type) {
		return getReferencers(getNonNavigableInverseReferences(referenced),
				reference, type);
	}

	/**
	 * Extracts the EObjects from the EStructuralFeature.Setting references and
	 * returns a filtered Set based on the given reference and type.
	 * 
	 * @@param references
	 *            a collection of EStructuralFeature.Setting
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
	 * @@return a Set of referencers
	 */
	private Set getReferencers(Collection references, EReference reference,
			EClass type) {
		Set set = new HashSet();
		if (!references.isEmpty()) {
			for (Iterator iter = references.iterator(); iter.hasNext();) {
				Setting setting = (Setting) iter.next();
				if (reference == null
						|| reference == setting.getEStructuralFeature()) {
					EObject referencer = setting.getEObject();
					if (referencer != null
							&& (type == null || type.isInstance(referencer))) {
						set.add(referencer);
					}
				}
			}
		}
		return set;
	}

	/**
	 * Searches the adapter list of the given Notifier for a
	 * CrossReferenceAdapter. If not found, returns null.
	 * 
	 * @@param notifier
	 *            the notifier to search
	 * @@return the CrossReferenceAdapter if found, otherwise null
	 */
	public static CrossReferenceAdapter getExistingCrossReferenceAdapter(
			Notifier notifier) {
		if (notifier == null) {
			return null;
		}

		List adapters = notifier.eAdapters();

		for (int i = 0, size = adapters.size(); i < size; ++i) {
			Adapter adapter = (Adapter) adapters.get(i);
			if (adapter instanceof CrossReferenceAdapter) {
				return (CrossReferenceAdapter) adapter;
			}
		}
		return null;
	}

	/**
	 * Obtains the cross-reference adapter for the specified resource set, if
	 * necessary creating it and attaching it.
	 * 
	 * @@param resourceSet
	 *            the resource set
	 * 
	 * @@return the resourceSet's cross-reference adapter
	 */
	public static CrossReferenceAdapter getCrossReferenceAdapter(
			ResourceSet resourceSet) {
		if (resourceSet == null) {
			return null;
		}

		CrossReferenceAdapter result = getExistingCrossReferenceAdapter(resourceSet);

		if (result == null) {
			result = new CrossReferenceAdapter();
			resourceSet.eAdapters().add(result);
		}

		return result;
	}

	/**
	 * A mutable integer used to count number of object-level references between
	 * two resources.
	 * 
	 * @@author Christian W. Damus (cdamus)
	 */
	private static final class Counter {
		private int value = 1;

		Counter() {
			super();
		}

		/**
		 * Obtains my value.
		 * 
		 * @@return my count
		 */
		int getValue() {
			return value;
		}

		/**
		 * Increments me.
		 */
		void inc() {
			value++;
		}

		/**
		 * Decrements me.
		 * 
		 * @@return <code>true</code> if I am now zero; <code>false</code>,
		 *         otherwise
		 */
		boolean dec() {
			return --value <= 0;
		}
	}

	protected boolean resolve() {
		return this.resolve;
	}

	public Collection getInverseReferences(EObject eObject, boolean resolve) {
		Collection result = new ArrayList();

		if (resolve) {
			resolveAll(eObject);
		}

		EObject eContainer = eObject.eContainer();
		if (eContainer != null) {
			result.add(((InternalEObject) eContainer).eSetting(eObject
					.eContainmentFeature()));
		}

		Collection nonNavigableInverseReferences = (Collection) inverseCrossReferencer
				.get(eObject);
		if (nonNavigableInverseReferences != null) {
			result.addAll(nonNavigableInverseReferences);
		}

		for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i
				.hasNext();) {
			EReference eReference = (EReference) i.next();
			EReference eOpposite = eReference.getEOpposite();
			if (eOpposite != null && !eReference.isContainer()
					&& !eReference.isContainment()
					&& eObject.eIsSet(eReference)) {
				if (FeatureMapUtil.isMany(eObject, eReference)) {
					Object collection = eObject.eGet(eReference);
					for (Iterator j = resolve() ? ((Collection) collection)
							.iterator() : ((InternalEList) collection)
							.basicIterator(); j.hasNext();) {
						InternalEObject referencingEObject = (InternalEObject) j
								.next();
						result.add(referencingEObject.eSetting(eOpposite));
					}
				} else {
					// although the reference is set, the value could be null
					InternalEObject referencingEObject = ((InternalEObject) eObject
							.eGet(eReference, resolve()));
					if (referencingEObject != null) {
						result.add(referencingEObject.eSetting(eOpposite));
					}
				}
			}
		}
d994 2
a995 2
		return result;
	}
@


1.10.2.4
log
@[147722] gmf_R1_0_maintenance cdamus 060712 CrossReferenceAdapter incorrectly computes resource exports from derived features
@
text
@a29 1
import org.eclipse.emf.ecore.EStructuralFeature;
d286 4
a289 10
				for (Iterator iter = adapter.getInverseReferences(value).iterator();
                        iter.hasNext();) {
                    EStructuralFeature.Setting next = (EStructuralFeature.Setting) iter.next();
                    EReference ref = (EReference) next.getEStructuralFeature();
                    
                    // we ignore unchangeable references.  
                    if (ref.isChangeable()) {
    					registerReference(next.getEObject().eResource(),
    							resource);
                    }
d315 5
a319 11
                for (Iterator iter = adapter.getInverseReferences(value).iterator();
                        iter.hasNext();) {
                    EStructuralFeature.Setting next = (EStructuralFeature.Setting) iter.next();
                    EReference ref = (EReference) next.getEStructuralFeature();
                    
                    // we ignore unchangeable references
                    if (ref.isChangeable()) {
    					deregisterReference(next.getEObject().eResource(),
    							resource);
    				}
                }
@


1.10.2.5
log
@[146411] gmf_R1_0_maintenance ldamus 060712 Re-instating the fix
@
text
@a32 1
import org.eclipse.emf.ecore.impl.EClassImpl;
a36 1
import org.eclipse.emf.ecore.util.ECrossReferenceEList;
a57 4
	
    private static Map eClassToChangeableFeatures = new HashMap();

    private static List nullList = new ArrayList(1);
d301 2
a302 2
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() 
                    ? getOptimizedCrossReferenceIterator(value)
d376 2
a377 2
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() 
                    ? getOptimizedCrossReferenceIterator(eObject)
a887 46

    private static List getCrossReferencesChangeableFeatures(EClass eCls) {
        List features = (List) eClassToChangeableFeatures.get(eCls);
        if (features == null) {
            features = nullList;
            EStructuralFeature[] crossReferenceFeatures =

            ((EClassImpl.FeatureSubsetSupplier) eCls
                .getEAllStructuralFeatures()).crossReferences();
            if (crossReferenceFeatures != null) {
                features = new ArrayList(crossReferenceFeatures.length);
                for (int i = 0; i < crossReferenceFeatures.length; i++) {
                    EStructuralFeature feature = crossReferenceFeatures[i];
                    if (feature.isChangeable())
                        features.add(feature);
                }
            }
            eClassToChangeableFeatures.put(eCls, features);
        }
        return features != nullList ? features
            : null;
    }

    private EContentsEList.FeatureIterator getOptimizedCrossReferenceIterator(
            EObject eObj) {
        List features = getCrossReferencesChangeableFeatures(eObj.eClass());
        if (features != null) {
            EContentsEList list = null;
            if (features.size() > 0) {
                list = new ECrossReferenceEList(eObj,
                    (EStructuralFeature[]) features
                        .toArray(new EStructuralFeature[features.size()])) {
                    // to get to the protected constructor
                };
            } else {
                list = ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST;
            }

            return (EContentsEList.FeatureIterator) (resolve() ? list
                .iterator()
                : ((InternalEList) list).basicIterator());
        }
        return (EContentsEList.FeatureIterator) ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST
            .iterator();
    }

@


1.10.2.6
log
@[110316] gmf_R1_0_maintenance mmostafa  060713 Compiler warning count should be 0 - runtime diagram layer components
@
text
@d846 1
a846 1
	public Collection getInverseReferences(EObject eObject, boolean _resolve) {
d849 1
a849 1
		if (_resolve) {
@


1.10.2.7
log
@[147312] gmf_R1_0_maintenance mgoyal/cdamus 070618 CrossReferenceAdapter updateImportsAndExports performance can be improved by 10%
@
text
@d124 1
a124 1
		if (!isImportExportCapable(reference, (EObject) notifier)) {
a296 1
                    EObject owner = next.getEObject();
d298 4
a301 2
                    if (isImportExportCapable(ref, owner)) {
                        registerReference(owner.eResource(), resource);
d307 4
a310 3
            EContentsEList.FeatureIterator crossReferences = getOptimizedCrossReferenceIterator(
            		value);
            
d318 2
a319 1
					if (isImportExportCapable(eReference, referent)) {
a331 1
                    EObject owner = next.getEObject();
d333 5
a337 3
                    if (isImportExportCapable(ref, owner)) {
                        deregisterReference(owner.eResource(), resource);
                    }
d382 4
a385 3
			EContentsEList.FeatureIterator crossReferences = getOptimizedCrossReferenceIterator(
					eObject);
			
d393 2
a394 1
					if (isImportExportCapable(eReference, referent)) {
a699 37
     * Like the {@@link #getInverseReferencers(EObject, EReference, EClass)} method,
     * obtains referencing objects (optionally filtered by reference and type),
     * except that it additionally only considers references that are
     * {@@linkplain EStructuralFeature#isChangeable() changeable} and can
     * {@@linkplain EReference#isResolveProxies() reference other resources}.
     * 
     * @@param referenced
     *            the referenced EObject
     * @@param reference
     *            the reference to find referencers on, null for any reference
     * @@param type
     *            the type of the referencers, use null for any type
     * @@return a Set of referencers on potentially cross-resource references
     */
    public Set getInverseReferencersCrossResource(EObject referenced, EReference reference,
            EClass type) {
        return getReferencers(getInverseReferencesCrossResource(referenced), reference, type);
    }
    

	/**
     * Like the {@@link #getInverseReferences(EObject)} method,
     * obtains settings implementing references to the specified object,
     * except that it only considers references that are
     * {@@linkplain EStructuralFeature#isChangeable() changeable} and can
     * {@@linkplain EReference#isResolveProxies() reference other resources}.
     * 
     * @@param eObject the referenced EObject
     * 
     * @@return a collection of {@@link EStructuralFeature.Setting}s on
     *     potentially cross-resource references
     */
    public Collection getInverseReferencesCrossResource(EObject eObject) {
        return getInverseReferencesCrossResource(eObject, !resolve());
    }

	/**
a894 7
	/**
	 * Computes the references defined by the specified EClass that are
	 * {@@linkplain EStructuralFeature#isChangeable() changeable}.
	 * 
	 * @@param eCls an EClass
	 * @@return a list of its {@@link EReference}s that are changeable
	 */
a916 7
	/**
	 * An iterator over the references defined by the specified EObject that
	 * are {@@linkplain EStructuralFeature#isChangeable() changeable}.
	 * 
	 * @@param eObj an EObject
	 * @@return an iterator over its {@@link EReference}s that are changeable
	 */
a939 94
	/**
     * Like the {@@link #getInverseReferences(EObject, boolean)} method,
     * obtains settings implementing references to the specified object,
     * except that it only considers references that are
     * {@@linkplain EStructuralFeature#isChangeable() changeable} and can
     * {@@linkplain EReference#isResolveProxies() reference other resources}.
     * 
     * @@param eObject the referenced EObject
     * @@param resolve whether to resolve proxies or not
     * 
     * @@return a collection of {@@link EStructuralFeature.Setting}s on
     *     potentially cross-resource references
     */
    public Collection getInverseReferencesCrossResource(EObject eObject, boolean resolve) {
        Collection result = new ArrayList();

        if (resolve) {
            resolveAll(eObject);
        }

        EObject eContainer = eObject.eContainer();
        if (eContainer != null) {
            result.add(((InternalEObject) eContainer).eSetting(eObject
                    .eContainmentFeature()));
        }

        Collection nonNavigableInverseReferences = (Collection) inverseCrossReferencer
                .get(eObject);
        if (nonNavigableInverseReferences != null) {
            result.addAll(nonNavigableInverseReferences);
        }

        for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i
                .hasNext();) {
            EReference eReference = (EReference) i.next();
            EReference eOpposite = eReference.getEOpposite();
            
            if (eOpposite != null
            		&& isImportExportCapable(eReference, eObject)
            		&& eObject.eIsSet(eReference)) {
                if (FeatureMapUtil.isMany(eObject, eReference)) {
                    Object collection = eObject.eGet(eReference);
                    for (Iterator j = resolve() ? ((Collection) collection)
                            .iterator() : ((InternalEList) collection)
                            .basicIterator(); j.hasNext();) {
                        InternalEObject referencingEObject = (InternalEObject) j
                                .next();
                        result.add(referencingEObject.eSetting(eOpposite));
                    }
                } else {
                    // although the reference is set, the value could be null
                    InternalEObject referencingEObject = ((InternalEObject) eObject
                            .eGet(eReference, resolve()));
                    if (referencingEObject != null) {
                        result.add(referencingEObject.eSetting(eOpposite));
                    }
                }
            }
        }

        return result;
    }
    
    /**
     * Queries whether the specified reference, applied to the given owner
     * object, is capable of establishing a resource import or export by
     * virtue of being a mutable cross-resource reference.
     * <p>
     * A reference is considered to support resource imports and exports if
     * all of the following apply:
     * </p>
     * <ul>
     *   <li>the reference is not a container or containment reference.  Note
     *       that this excludes cross-resource containment from registering
     *       as an import/export dependency</li>
     *   <li>the reference resolves proxies</li>
     *   <li>the reference is changeable</li>
     * </ul>
     * 
     * @@param reference a reference feature
     * @@param owner an object under consideration that defines this reference.
     *     Subclasses may need to introspect the object or its EClass to further
     *     refine their criteria
     * 
     * @@return <code>true</code> if this reference in the context of this
     *     owner should be counted for resource imports and exports;
     *     false, otherwise
     */
   protected boolean isImportExportCapable(EReference reference, EObject owner) {
    	return !reference.isContainer()
        	&& !reference.isContainment()
        	&& reference.isResolveProxies() // can be cross-resource
        	&& reference.isChangeable();    // not computed
    }
@


1.10.2.8
log
@ [160927]   gmf_R1_0_maintenace mmostafa 061123 CrossReferenceAdapter takes to long to clean up imports/exports on unload
Contibuted by : Christian Damus
@
text
@a254 6
                
                if (!resource.isLoaded()) {
                    // purge the resource from the imports/exports map
                    deregisterReferences(resource);
                    return;
                }
@


1.10.2.9
log
@[167297] gmf_R1_0_maintenance crevells 061211 CrossReferenceAdapter may trigger a resolve because it calls eIsSet on derived features
@
text
@a38 1
import org.eclipse.emf.ecore.util.ExtendedMetaData;
d951 1
a951 1
                    if (isMutable(feature))
a960 26
    /**
     * Queries whether a feature is mutable.  A feature is considered
     * mutable if and only if it is changeable and it is either not derived
     * or it is a member of a feature map (though not itself a feature map).
     * 
     * @@param feature the feature to test
     * 
     * @@return <code>true</code> if the reference is mutable;
     *     <code>false</code>, otherwise
     */
    static private boolean isMutable(EStructuralFeature feature) {
        boolean result = feature.isChangeable();
        
        if (result) {
            if (feature.isDerived()) {
                // check whether it is a feature-map member that is not, itself,
                //    a feature map
                EStructuralFeature group = ExtendedMetaData.INSTANCE.getGroup(feature);
                
                result = (group != null) && !FeatureMapUtil.isFeatureMap(feature);
            }
        }
        
        return result;
    }

@


1.10.2.10
log
@[167297] gmf_R1_0_maintenance ahunter 070102 Update copyright to indicate change in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2006 IBM Corporation and others.
@


1.9
log
@[131094] gmf_head cmcgee 060504 Sweep Code for EReference.isMany() calls
@
text
@d827 1
a827 1
	public Collection getInverseReferences(EObject eObject) {
d830 4
d853 1
a853 1
				if (FeatureMapUtil.isMany(eObject,eReference)) {
@


1.8
log
@Support for updating imports and exports map when EObjects are added and their contents, gmf_head, vramaswa, 060412
@
text
@d36 1
d849 1
a849 1
				if (eReference.isMany()) {
@


1.7
log
@[131995],gmf_head, vramaswa,060401, The CrossReferenceAdapter was modified to handle updates to  the imports/exports when resources are loaded
@
text
@d98 2
a99 1
							add((Resource) notifier, child);
d199 2
a200 1
				add(resource, newValue);
d202 1
d219 2
a220 1
					add(resource, next);
d238 2
a239 1
				remove(resource, oldValue);
d257 2
a258 1
					remove(resource, next);
d267 1
a267 2
	 * Adds all aggregate cross-references for the specified resource, due to
	 * attachment of an eObject.
d272 47
a318 9
	 *            an object being removed from it
	 */
	protected void add(Resource resource, EObject eObject) {
		// now, register incoming unidirectional references and opposites
		CrossReferenceAdapter adapter = getExistingCrossReferenceAdapter(eObject);
		if (adapter != null) {
			for (Iterator iter = adapter.getInverseReferencers(eObject, null,
					null).iterator(); iter.hasNext();) {
				registerReference(((EObject) iter.next()).eResource(), resource);
d322 4
a325 6
		// go through the children of the eObject
		for (Iterator i = resolve() ? eObject.eContents().iterator()
				: ((InternalEList) eObject.eContents()).basicIterator(); i
				.hasNext();) {
			EObject notifier = (EObject) i.next();
			add(resource, notifier);
d330 2
a331 2
	 * Removes all aggregate cross-references for the specified resource, due to
	 * detachment of an eObject.
d336 4
a339 1
	 *            an object being removed from it
d341 2
a342 29
	protected void remove(Resource resource, EObject eObject) {
		// deregister the outgoing references and incoming bidirectionals
		EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? eObject
				.eCrossReferences().iterator()
				: ((InternalEList) eObject.eCrossReferences()).basicIterator());
		while (crossReferences.hasNext()) {
			EObject referent = (EObject) crossReferences.next();

			if (referent != null) {
				EReference eReference = (EReference) crossReferences.feature();

				// we ignore unchangeable references
				if (eReference.isChangeable()) {
					Resource referencedResource = referent.eResource();
					deregisterReference(resource, referencedResource);
				}
			}
		}

		// now, deregister incoming unidirectional references and opposites
		CrossReferenceAdapter adapter = getExistingCrossReferenceAdapter(eObject);
		if (adapter != null) {
			for (Iterator iter = adapter.getInverseReferencers(eObject, null,
					null).iterator(); iter.hasNext();) {
				deregisterReference(((EObject) iter.next()).eResource(),
						resource);
			}
		}

d344 2
a345 2
		for (Iterator i = resolve() ? eObject.eContents().iterator()
				: ((InternalEList) eObject.eContents()).basicIterator(); i
d347 1
a347 2
			EObject notifier = (EObject) i.next();
			remove(resource, notifier);
@


1.6
log
@[131995],gmf_head, vramaswa,060331,The CrossReferenceAdapter needs to public for applications to extend the functionality. The CrossReferenceAdapter was modified to handle containment changes and recursively update the imports/exports for the child objects
@
text
@d88 1
a88 1
		// is unloaded
d90 12
a101 3
			if (notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_LOADED
					&& !notification.getNewBooleanValue()) {
				deregisterReferences((Resource) notifier);
d103 1
@


1.5
log
@gmf_head, vramaswa,060324,Updated the cross reference adpater to include the resolve check within the getInverseReferences method to avoid resolution of proxies
@
text
@a35 1
import org.eclipse.emf.ecore.util.EcoreUtil;
d39 3
a41 2
 * An adapter that maintains itself as an adapter for all contained objects.
 * It can be installed for an {@@link EObject}, a {@@link Resource}, or a {@@link ResourceSet}.
d43 2
a44 2
 * This adapter maintain information on inverse references, resource imports, and resource
 * exports.
d56 1
a56 7
	
	/**
	 * Flag used to check if the invocations of the setTarget are occuring
	 * due to containment change notifications.
	 */
	private boolean isProcessingNotification = false;
	
d67 2
a68 1
	 * @@param resolve flag to determine if the proxies need to be resolved
d72 1
a72 1
		
d75 1
a75 1
	
d79 2
a80 1
	 * @@param notification the event notification
d92 1
a92 1
				deregisterReferences((Resource)notifier);
d100 1
a100 2
		if (!(notifier instanceof EObject)
				|| !(feature instanceof EReference)) {
d104 1
a104 1
		EReference reference = (EReference)feature;
d110 46
a155 54
			case Notification.RESOLVE: 
			case Notification.SET:
			case Notification.UNSET: {
				EObject oldValue = (EObject) notification.getOldValue();
				if (oldValue != null) {
					deregisterReference(
							((EObject)notification.getNotifier()).eResource(),
							oldValue.eResource());
				}
				EObject newValue = (EObject) notification.getNewValue();
				if (newValue != null) {
					registerReference(
							((EObject)notification.getNotifier()).eResource(),
							newValue.eResource());
				}
				break;
			}
			case Notification.ADD: {
				EObject newValue = (EObject) notification.getNewValue();
				if (newValue != null) {
					registerReference(
							((EObject)notification.getNotifier()).eResource(),
							newValue.eResource());
				}
				break;
			}
			case Notification.ADD_MANY: {
				Collection newValues = (Collection) notification.getNewValue();
				for (Iterator i = newValues.iterator(); i.hasNext();) {
					EObject newValue = (EObject) i.next();
					registerReference(
							((EObject)notification.getNotifier()).eResource(),
							newValue.eResource());
				}
				break;
			}
			case Notification.REMOVE: {
				EObject oldValue = (EObject) notification.getOldValue();
				if (oldValue != null) {
					deregisterReference(
							((EObject)notification.getNotifier()).eResource(),
							oldValue.eResource());
				}
				break;
			}
			case Notification.REMOVE_MANY: {
				Collection oldValues = (Collection) notification.getOldValue();
				for (Iterator i = oldValues.iterator(); i.hasNext();) {
					EObject oldValue = (EObject) i.next();
					deregisterReference(
							((EObject)notification.getNotifier()).eResource(),
							oldValue.eResource());
				}
				break;
d157 2
d161 1
a161 1
	
d168 1
a168 1
		
d174 38
a211 4
		
	    switch (notification.getEventType()) {
		case Notification.SET:
		case Notification.UNSET:
d214 1
a214 1
			
d220 2
a221 1
					resource = ((EObject) notification.getNotifier()).eResource();
d223 1
a223 1
				
d235 1
a235 1
			
d237 1
a237 1
			
d240 1
a240 1
				
d249 29
a277 1
	
d288 14
a301 22
		for (Iterator allContents = EcoreUtil.getAllContents(Collections.singleton(eObject)); allContents.hasNext();) {
			EObject next = (EObject) allContents.next();
			
			// deregister the outgoing references and incoming bidirectionals
		    EContentsEList.FeatureIterator crossReferences =
		    	(EContentsEList.FeatureIterator) next.eCrossReferences().iterator();
			while (crossReferences.hasNext()) {
				EObject referent = (EObject) crossReferences.next();
				
				if (referent != null) {
					EReference eReference = (EReference) crossReferences.feature();
					
					// we ignore unchangeable references
					if (eReference.isChangeable()) {
						Resource referencedResource = referent.eResource();
						deregisterReference(resource, referencedResource);
						
						if (eReference.getEOpposite() != null) {
							// implied incoming reference
							deregisterReference(referencedResource, resource);
						}
					}
d304 9
a312 4
			
			// now, deregister incoming unidirectional references
			for (Iterator iter = getNonNavigableInverseReferencers(next, null, null).iterator(); iter.hasNext();) {
				deregisterReference(((EObject)iter.next()).eResource(), resource);
d315 8
d324 1
a324 1
	
d330 1
a330 1
		
d334 1
a334 1
			
d342 1
a342 1
				
d344 3
a346 2
					EReference eReference = (EReference) crossReferences.feature();
					
a353 9
			
			// need to process containment changes. This will compute references
			// from existing EObjects to the added EObjects. This would happen when detached
			// EObjects are referenced by the existing EObjects
			if (isProcessingNotification) {
				for (Iterator iter = getInverseReferencers(eObject, null, null).iterator(); iter.hasNext();) {
					registerReference(((EObject)iter.next()).eResource(), resource);
				}
			}
d363 2
a364 2
			deregisterReferences((Resource)notifier);
	    }
d370 2
a371 1
	 * @@param referencer the resource to retrieve imports for
d388 2
a389 1
	 * @@param referenced the resource to retrieve exports for
d424 6
a429 5
	 * Registers a reference updating the imports and exports maps
	 * accordingly.
	 *
	 * @@param referencer the referencing resource
	 * @@param referenced the referenced resouce
d435 1
a435 1
			&& (referencer != referenced)) {
d476 1
a476 1
	
d479 8
a486 5
	 * import of the <code>referenced</code> resource by the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call <code>super</code>.
	 * 
	 * @@param referencer the referencing resource (doing the importing)
	 * @@param referenced the resource that it references
d493 9
a501 6
	 * Hook to be implemented by subclasses upon the elimination of an
	 * import of the <code>referenced</code> resource by the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call <code>super</code>.
	 * 
	 * @@param referencer the formerly referencing resource (doing the importing)
	 * @@param referenced the resource that it had referenced
d506 1
a506 1
	
d509 8
a516 5
	 * export of the <code>referenced</code> resource to the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call <code>super</code>.
	 * 
	 * @@param referenced the resource being referenced (doing the exporting)
	 * @@param referencer the referencing resource
d523 9
a531 6
	 * Hook to be implemented by subclasses upon the elimination of an
	 * export of the <code>referenced</code> resource to the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call <code>super</code>.
	 * 
	 * @@param referenced the resource formerly being referenced (doing the exporting)
	 * @@param referencer the formerly referencing resource
d541 4
a544 2
	 * @@param referencer the referencing resource
	 * @@param referenced the referenced resource
d550 1
a550 1
			&& (referencer != referenced)) {
d581 1
a581 1
					
d593 2
a594 1
	 * @@param referencer the referencing resource
a630 1
	
d633 13
a645 9
	 * Returns a Set of EObjects that reference the given EObject.
	 * If an EReference is specified, the scope of the search is limited
	 * only to that EReference. To include all references specify a value of null.
	 * If an EClass type is specified, the returned Set will only include those
	 * referencers that match the given type. To include all types specify a value of null.
	 * 
	 * @@param referenced the referenced EObject
	 * @@param reference the reference to find referencers on, null for any reference
	 * @@param type the type of the referencers, use null for any type
d648 2
a649 1
	public Set getInverseReferencers(EObject referenced, EReference reference, EClass type) {
d656 11
a666 8
	 * search is limited only to that EReference. To include all references specify
	 * a value of null. If an EClass type is specified, the returned Set will only
	 * include those referencers that match the given type. To include all types
	 * specify a value of null.
	 * 
	 * @@param referenced the referenced EObject
	 * @@param reference the reference to find referencers on, null for any reference
	 * @@param type the type of the referencers, use null for any type
d669 4
a672 2
	public Set getNonNavigableInverseReferencers(EObject referenced, EReference reference, EClass type) {
		return getReferencers(getNonNavigableInverseReferences(referenced), reference, type);
d676 9
a684 6
	 * Extracts the EObjects from the EStructuralFeature.Setting references
	 * and returns a filtered Set based on the given reference and type.
	 * 
	 * @@param references a collection of EStructuralFeature.Setting
	 * @@param reference the reference to find referencers on, null for any reference
	 * @@param type the type of the referencers, use null for any type
d687 2
a688 1
	private Set getReferencers(Collection references, EReference reference, EClass type) {
d691 1
a691 1
			for (Iterator iter = references.iterator(); iter.hasNext(); ) {
d693 2
a694 1
				if (reference == null || reference == setting.getEStructuralFeature()) {
d696 2
a697 1
					if (referencer != null && (type == null || type.isInstance(referencer))) {
d707 2
a708 2
	 * Searches the adapter list of the given Notifier for a CrossReferenceAdapter.
	 * If not found, returns null.
d710 2
a711 1
	 * @@param notifier the notifier to search
d714 3
a716 2
	public static CrossReferenceAdapter getExistingCrossReferenceAdapter(Notifier notifier) {
		if (notifier == null ) {
d719 1
a719 1
		
d721 1
a721 1
		
d723 1
a723 1
			Adapter adapter = (Adapter)adapters.get(i);
d725 1
a725 1
				return (CrossReferenceAdapter)adapter;
d732 2
a733 2
	 * Obtains the cross-reference adapter for the specified resource set,
	 * if necessary creating it and attaching it.
d735 2
a736 1
	 * @@param resourceSet the resource set
d740 3
a742 2
	public static CrossReferenceAdapter getCrossReferenceAdapter(ResourceSet resourceSet) {
		if ( resourceSet == null ) {
d745 3
a747 4
		
		CrossReferenceAdapter result = getExistingCrossReferenceAdapter(
			resourceSet);
		
d752 1
a752 1
		
d759 1
a759 1
	 *
d764 1
a764 1
		
d768 1
a768 1
		
d777 1
a777 1
		
d784 1
a784 1
		
d788 2
a789 1
		 * @@return <code>true</code> if I am now zero; <code>false</code>, otherwise
d799 1
a799 1
	
d801 39
a839 49
	    Collection result = new ArrayList();
	    
	    EObject eContainer = eObject.eContainer();
	    if (eContainer != null)
	    {
	      result.add(((InternalEObject)eContainer).eSetting(eObject.eContainmentFeature()));
	    }
	    
	    Collection nonNavigableInverseReferences = (Collection)inverseCrossReferencer.get(eObject);
	    if (nonNavigableInverseReferences != null)
	    {
	      result.addAll(nonNavigableInverseReferences);
	    }
	    
	    for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i.hasNext(); )
	    {
	      EReference eReference = (EReference)i.next();
	      EReference eOpposite = eReference.getEOpposite();
	      if (eOpposite != null && !eReference.isContainer() && !eReference.isContainment() && eObject.eIsSet(eReference))
	      {
	        if (eReference.isMany())
	        {
	          Object collection = eObject.eGet(eReference);
	          for (Iterator j = resolve() ? ((Collection)collection).iterator() : ((InternalEList)collection).basicIterator(); j.hasNext(); )
	          {
	            InternalEObject referencingEObject = (InternalEObject)j.next();
	            result.add(referencingEObject.eSetting(eOpposite));
	          }
	        }
	        else
	        {
	        	// although the reference is set, the value could be null
	        	InternalEObject referencingEObject = ((InternalEObject)eObject.eGet(eReference, resolve()));
	        	if ( referencingEObject != null ) {
	        		result.add(referencingEObject.eSetting(eOpposite));
	        	}
	        }
	      }
	    }
	    
	    return result;
	}

	public final void notifyChanged(Notification notification) {
		try {
			isProcessingNotification = true;
			super.notifyChanged(notification);
		} finally {
			isProcessingNotification = false;
d841 4
a844 2
	}	
}
@


1.4
log
@gmf_head, vramaswa,060323,Updated the cross reference adpater to handle the null check when computing references from opposites
@
text
@d737 2
a738 1
	          for (Iterator j = ((Collection)eObject.eGet(eReference)).iterator(); j.hasNext(); )
d747 1
a747 1
	        	InternalEObject referencingEObject = ((InternalEObject)eObject.eGet(eReference));
@


1.3
log
@gmf_head, vramaswa,060323,Updated the cross reference adpater to handle the null check when computing references from opposites
@
text
@d40 2
a41 3
 * An adapter that maintains itself as an adapter for all contained objects. It
 * can be installed for an {@@link EObject}, a {@@link Resource}, or a
 * {@@link ResourceSet}.
d43 2
a44 2
 * This adapter maintain information on inverse references, resource imports,
 * and resource exports.
d56 7
a62 1

d73 1
a73 2
	 * @@param resolve
	 *            flag to determine if the proxies need to be resolved
d77 1
a77 1

d80 1
a80 1

d84 1
a84 2
	 * @@param notification
	 *            the event notification
d94 3
a96 6
			if (notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_LOADED ) {
				if ( notification.getNewBooleanValue() ) {
					updateImportsAndExports((Resource) notifier);
				} else {
					deregisterReferences((Resource) notifier);
				}
a97 1

d104 2
a105 1
		if (!(notifier instanceof EObject) || !(feature instanceof EReference)) {
d109 4
a112 1
		EReference reference = (EReference) feature;
d115 15
a129 4
		case Notification.RESOLVE:
		case Notification.SET:
		case Notification.UNSET: {
			if (reference.isContainment()) {
d132 6
a137 21

			EObject oldValue = (EObject) notification.getOldValue();
			if (oldValue != null) {
				deregisterReference(((EObject) notification.getNotifier())
						.eResource(), oldValue.eResource());
			}
			EObject newValue = (EObject) notification.getNewValue();
			if (newValue != null) {
				registerReference(((EObject) notification.getNotifier())
						.eResource(), newValue.eResource());
			}
			break;
		}
		case Notification.ADD: {
			EObject newValue = (EObject) notification.getNewValue();
			if (newValue != null) {
				if (!reference.isContainment()) {
					registerReference(((EObject) notification.getNotifier())
							.eResource(), newValue.eResource());
				} else {
					updateImportsAndExports(newValue, true);
d139 1
d141 7
a147 11
			break;
		}
		case Notification.ADD_MANY: {
			Collection newValues = (Collection) notification.getNewValue();
			for (Iterator i = newValues.iterator(); i.hasNext();) {
				EObject newValue = (EObject) i.next();
				if (!reference.isContainment()) {
					registerReference(((EObject) notification.getNotifier())
							.eResource(), newValue.eResource());
				} else {
					updateImportsAndExports(newValue, true);
d149 1
d151 6
a156 10
			break;
		}
		case Notification.REMOVE: {
			EObject oldValue = (EObject) notification.getOldValue();
			if (oldValue != null) {
				if (!reference.isContainment()) {
					deregisterReference(((EObject) notification.getNotifier())
							.eResource(), oldValue.eResource());
				} else {
					updateImportsAndExports(oldValue, false);
d158 1
d160 7
a166 11
			break;
		}
		case Notification.REMOVE_MANY: {
			Collection oldValues = (Collection) notification.getOldValue();
			for (Iterator i = oldValues.iterator(); i.hasNext();) {
				EObject oldValue = (EObject) i.next();
				if (!reference.isContainment()) {
					deregisterReference(((EObject) notification.getNotifier())
							.eResource(), oldValue.eResource());
				} else {
					updateImportsAndExports(oldValue, false);
d168 1
a169 2
			break;
		}
d172 1
a172 1

d179 1
a179 1

d185 2
a186 2

		switch (notification.getEventType()) {
d191 1
a191 1

d197 1
a197 2
					resource = ((EObject) notification.getNotifier())
							.eResource();
d199 1
a199 1

d211 1
a211 1

d213 1
a213 1

d216 1
a216 1

d225 1
a225 1

d235 2
a236 3
	private void remove(Resource resource, EObject eObject) {
		for (Iterator allContents = EcoreUtil.getAllContents(Collections
				.singleton(eObject)); allContents.hasNext();) {
d238 1
a238 1

d240 2
a241 2
			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) next
					.eCrossReferences().iterator();
d244 1
a244 1

d246 2
a247 3
					EReference eReference = (EReference) crossReferences
							.feature();

d252 1
a252 1

d260 1
a260 1

d262 2
a263 4
			for (Iterator iter = getNonNavigableInverseReferencers(next, null,
					null).iterator(); iter.hasNext();) {
				deregisterReference(((EObject) iter.next()).eResource(),
						resource);
d267 1
a267 1

d273 1
a273 1

d277 1
a277 1

d285 1
a285 1

d287 2
a288 3
					EReference eReference = (EReference) crossReferences
							.feature();

d296 9
d314 2
a315 2
			deregisterReferences((Resource) notifier);
		}
d321 1
a321 2
	 * @@param referencer
	 *            the resource to retrieve imports for
d338 1
a338 2
	 * @@param referenced
	 *            the resource to retrieve exports for
d373 5
a377 6
	 * Registers a reference updating the imports and exports maps accordingly.
	 * 
	 * @@param referencer
	 *            the referencing resource
	 * @@param referenced
	 *            the referenced resouce
d383 1
a383 1
				&& (referencer != referenced)) {
d424 1
a424 1

d427 5
a431 8
	 * import of the <code>referenced</code> resource by the
	 * <code>referencer</code>. This implementation does nothing; subclasses
	 * need not call <code>super</code>.
	 * 
	 * @@param referencer
	 *            the referencing resource (doing the importing)
	 * @@param referenced
	 *            the resource that it references
d438 6
a443 9
	 * Hook to be implemented by subclasses upon the elimination of an import of
	 * the <code>referenced</code> resource by the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call
	 * <code>super</code>.
	 * 
	 * @@param referencer
	 *            the formerly referencing resource (doing the importing)
	 * @@param referenced
	 *            the resource that it had referenced
d448 1
a448 1

d451 5
a455 8
	 * export of the <code>referenced</code> resource to the
	 * <code>referencer</code>. This implementation does nothing; subclasses
	 * need not call <code>super</code>.
	 * 
	 * @@param referenced
	 *            the resource being referenced (doing the exporting)
	 * @@param referencer
	 *            the referencing resource
d462 6
a467 9
	 * Hook to be implemented by subclasses upon the elimination of an export of
	 * the <code>referenced</code> resource to the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call
	 * <code>super</code>.
	 * 
	 * @@param referenced
	 *            the resource formerly being referenced (doing the exporting)
	 * @@param referencer
	 *            the formerly referencing resource
d477 2
a478 4
	 * @@param referencer
	 *            the referencing resource
	 * @@param referenced
	 *            the referenced resource
d484 1
a484 1
				&& (referencer != referenced)) {
d515 1
a515 1

a524 52
	 * Updates the imports and exports by walking the contents of the specified
	 * resource and finding any referencers to these EObjects. This is for the
	 * cross reference adapter to synchronize the imports and exports when
	 * resources are loaded after the adapter is already attached
	 */
	private void updateImportsAndExports(Resource resource) {
		for (Iterator i = EcoreUtil.getAllContents(resource, resolve()); i
				.hasNext();) {
			EObject next = (EObject) i.next();
			for (Iterator iter = getInverseReferencers(next, null, null)
					.iterator(); iter.hasNext();) {
				registerReference(((EObject) iter.next()).eResource(), resource);
			}
		}
	}

	/**
	 * Updates the imports and exports by walking the contents of the specified
	 * EObject and finding any referencers to these EObjects. This is for the
	 * cross reference adapter to synchronize the imports and exports when
	 * eObjects are added or removed
	 */
	private void updateImportsAndExports(EObject eObject, boolean register) {
		Resource resource = eObject.eResource();

		for (Iterator iter = getInverseReferencers(eObject, null, null)
				.iterator(); iter.hasNext();) {
			if (register) {
				registerReference(((EObject) iter.next()).eResource(), resource);
			} else {
				deregisterReference(((EObject) iter.next()).eResource(),
						resource);
			}
		}

		for (Iterator i = EcoreUtil.getAllContents(eObject, resolve()); i
				.hasNext();) {
			EObject next = (EObject) i.next();
			for (Iterator iter = getInverseReferencers(next, null, null)
					.iterator(); iter.hasNext();) {
				if (register) {
					registerReference(((EObject) iter.next()).eResource(),
							resource);
				} else {
					deregisterReference(((EObject) iter.next()).eResource(),
							resource);
				}
			}
		}
	}

	/**
d527 1
a527 2
	 * @@param referencer
	 *            the referencing resource
d564 1
d567 9
a575 13
	 * Returns a Set of EObjects that reference the given EObject. If an
	 * EReference is specified, the scope of the search is limited only to that
	 * EReference. To include all references specify a value of null. If an
	 * EClass type is specified, the returned Set will only include those
	 * referencers that match the given type. To include all types specify a
	 * value of null.
	 * 
	 * @@param referenced
	 *            the referenced EObject
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
d578 1
a578 2
	public Set getInverseReferencers(EObject referenced, EReference reference,
			EClass type) {
d585 8
a592 11
	 * search is limited only to that EReference. To include all references
	 * specify a value of null. If an EClass type is specified, the returned Set
	 * will only include those referencers that match the given type. To include
	 * all types specify a value of null.
	 * 
	 * @@param referenced
	 *            the referenced EObject
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
d595 2
a596 4
	public Set getNonNavigableInverseReferencers(EObject referenced,
			EReference reference, EClass type) {
		return getReferencers(getNonNavigableInverseReferences(referenced),
				reference, type);
d600 6
a605 9
	 * Extracts the EObjects from the EStructuralFeature.Setting references and
	 * returns a filtered Set based on the given reference and type.
	 * 
	 * @@param references
	 *            a collection of EStructuralFeature.Setting
	 * @@param reference
	 *            the reference to find referencers on, null for any reference
	 * @@param type
	 *            the type of the referencers, use null for any type
d608 1
a608 2
	private Set getReferencers(Collection references, EReference reference,
			EClass type) {
d611 1
a611 1
			for (Iterator iter = references.iterator(); iter.hasNext();) {
d613 1
a613 2
				if (reference == null
						|| reference == setting.getEStructuralFeature()) {
d615 1
a615 2
					if (referencer != null
							&& (type == null || type.isInstance(referencer))) {
d625 2
a626 2
	 * Searches the adapter list of the given Notifier for a
	 * CrossReferenceAdapter. If not found, returns null.
d628 1
a628 2
	 * @@param notifier
	 *            the notifier to search
d631 2
a632 3
	public static CrossReferenceAdapter getExistingCrossReferenceAdapter(
			Notifier notifier) {
		if (notifier == null) {
d635 1
a635 1

d637 1
a637 1

d639 1
a639 1
			Adapter adapter = (Adapter) adapters.get(i);
d641 1
a641 1
				return (CrossReferenceAdapter) adapter;
d648 2
a649 2
	 * Obtains the cross-reference adapter for the specified resource set, if
	 * necessary creating it and attaching it.
d651 1
a651 2
	 * @@param resourceSet
	 *            the resource set
d655 2
a656 3
	public static CrossReferenceAdapter getCrossReferenceAdapter(
			ResourceSet resourceSet) {
		if (resourceSet == null) {
d659 4
a662 3

		CrossReferenceAdapter result = getExistingCrossReferenceAdapter(resourceSet);

d667 1
a667 1

d674 1
a674 1
	 * 
d679 1
a679 1

d683 1
a683 1

d692 1
a692 1

d699 1
a699 1

d703 1
a703 2
		 * @@return <code>true</code> if I am now zero; <code>false</code>,
		 *         otherwise
d713 1
a713 1

d729 24
a752 11
	    EContentsEList.FeatureIterator crossReferences =
	    	(EContentsEList.FeatureIterator) eObject.eCrossReferences().iterator();
		while (crossReferences.hasNext()) {
			InternalEObject referent = (InternalEObject) crossReferences.next();
			EReference eReference = (EReference) crossReferences.feature();
			EReference eOpposite = eReference.getEOpposite();
			
			if (referent != null && eOpposite != null) {
				result.add(referent.eSetting(eOpposite));
			}
		}
d756 9
@


1.2
log
@[132995],gmf_head, vramaswa,060323,The CrossReferenceAdapter computes the imports twice when adapter is attached to the resource set
@
text
@d14 1
d30 1
d810 30
@


1.1
log
@[131995],gmf_head, vramaswa,060315,The CrossReferenceAdapter needs to public for applications to extend the functionality
@
text
@d35 1
d38 3
a40 2
 * An adapter that maintains itself as an adapter for all contained objects.
 * It can be installed for an {@@link EObject}, a {@@link Resource}, or a {@@link ResourceSet}.
d42 2
a43 2
 * This adapter maintain information on inverse references, resource imports, and resource
 * exports.
d55 1
a55 1
	
d66 2
a67 1
	 * @@param resolve flag to determine if the proxies need to be resolved
d71 1
a71 1
		
d74 1
a74 1
	
d78 2
a79 1
	 * @@param notification the event notification
d89 6
a94 3
			if (notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_LOADED
					&& !notification.getNewBooleanValue()) {
				deregisterReferences((Resource)notifier);
d96 1
d103 1
a103 2
		if (!(notifier instanceof EObject)
				|| !(feature instanceof EReference)) {
d107 1
a107 4
		EReference reference = (EReference)feature;
		if (reference.isContainment()) {
			return;
		}
d110 4
a113 15
			case Notification.RESOLVE: 
			case Notification.SET:
			case Notification.UNSET: {
				EObject oldValue = (EObject) notification.getOldValue();
				if (oldValue != null) {
					deregisterReference(
							((EObject)notification.getNotifier()).eResource(),
							oldValue.eResource());
				}
				EObject newValue = (EObject) notification.getNewValue();
				if (newValue != null) {
					registerReference(
							((EObject)notification.getNotifier()).eResource(),
							newValue.eResource());
				}
d116 21
a136 6
			case Notification.ADD: {
				EObject newValue = (EObject) notification.getNewValue();
				if (newValue != null) {
					registerReference(
							((EObject)notification.getNotifier()).eResource(),
							newValue.eResource());
a137 1
				break;
d139 11
a149 7
			case Notification.ADD_MANY: {
				Collection newValues = (Collection) notification.getNewValue();
				for (Iterator i = newValues.iterator(); i.hasNext();) {
					EObject newValue = (EObject) i.next();
					registerReference(
							((EObject)notification.getNotifier()).eResource(),
							newValue.eResource());
a150 1
				break;
d152 10
a161 6
			case Notification.REMOVE: {
				EObject oldValue = (EObject) notification.getOldValue();
				if (oldValue != null) {
					deregisterReference(
							((EObject)notification.getNotifier()).eResource(),
							oldValue.eResource());
a162 1
				break;
d164 11
a174 7
			case Notification.REMOVE_MANY: {
				Collection oldValues = (Collection) notification.getOldValue();
				for (Iterator i = oldValues.iterator(); i.hasNext();) {
					EObject oldValue = (EObject) i.next();
					deregisterReference(
							((EObject)notification.getNotifier()).eResource(),
							oldValue.eResource());
a175 1
				break;
d177 2
d181 1
a181 1
	
d188 1
a188 1
		
d194 2
a195 2
		
	    switch (notification.getEventType()) {
d200 1
a200 1
			
d206 2
a207 1
					resource = ((EObject) notification.getNotifier()).eResource();
d209 1
a209 1
				
d221 1
a221 1
			
d223 1
a223 1
			
d226 1
a226 1
				
d235 1
a235 1
	
d246 2
a247 1
		for (Iterator allContents = EcoreUtil.getAllContents(Collections.singleton(eObject)); allContents.hasNext();) {
d249 1
a249 1
			
d251 2
a252 2
		    EContentsEList.FeatureIterator crossReferences =
		    	(EContentsEList.FeatureIterator) next.eCrossReferences().iterator();
d255 1
a255 1
				
d257 3
a259 2
					EReference eReference = (EReference) crossReferences.feature();
					
d264 1
a264 1
						
d272 1
a272 1
			
d274 4
a277 2
			for (Iterator iter = getNonNavigableInverseReferencers(next, null, null).iterator(); iter.hasNext();) {
				deregisterReference(((EObject)iter.next()).eResource(), resource);
d281 1
a281 1
	
d287 1
a287 1
		
d291 1
a291 1
			
d293 4
a296 2
		    EContentsEList.FeatureIterator crossReferences =
		    	(EContentsEList.FeatureIterator) eObject.eCrossReferences().iterator();
d299 1
a299 1
				
d301 3
a303 2
					EReference eReference = (EReference) crossReferences.feature();
					
a307 5
						
						if (eReference.getEOpposite() != null) {
							// implied incoming reference
							registerReference(referencedResource, resource);
						}
a310 5
			
			// now, register incoming unidirectional references
			for (Iterator iter = getNonNavigableInverseReferencers(eObject, null, null).iterator(); iter.hasNext();) {
				registerReference(((EObject)iter.next()).eResource(), resource);
			}
d320 2
a321 2
			deregisterReferences((Resource)notifier);
	    }
d327 2
a328 1
	 * @@param referencer the resource to retrieve imports for
d345 2
a346 1
	 * @@param referenced the resource to retrieve exports for
d381 6
a386 5
	 * Registers a reference updating the imports and exports maps
	 * accordingly.
	 *
	 * @@param referencer the referencing resource
	 * @@param referenced the referenced resouce
d392 1
a392 1
			&& (referencer != referenced)) {
d433 1
a433 1
	
d436 8
a443 5
	 * import of the <code>referenced</code> resource by the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call <code>super</code>.
	 * 
	 * @@param referencer the referencing resource (doing the importing)
	 * @@param referenced the resource that it references
d450 9
a458 6
	 * Hook to be implemented by subclasses upon the elimination of an
	 * import of the <code>referenced</code> resource by the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call <code>super</code>.
	 * 
	 * @@param referencer the formerly referencing resource (doing the importing)
	 * @@param referenced the resource that it had referenced
d463 1
a463 1
	
d466 8
a473 5
	 * export of the <code>referenced</code> resource to the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call <code>super</code>.
	 * 
	 * @@param referenced the resource being referenced (doing the exporting)
	 * @@param referencer the referencing resource
d480 9
a488 6
	 * Hook to be implemented by subclasses upon the elimination of an
	 * export of the <code>referenced</code> resource to the <code>referencer</code>.
	 * This implementation does nothing; subclasses need not call <code>super</code>.
	 * 
	 * @@param referenced the resource formerly being referenced (doing the exporting)
	 * @@param referencer the formerly referencing resource
d498 4
a501 2
	 * @@param referencer the referencing resource
	 * @@param referenced the referenced resource
d507 1
a507 1
			&& (referencer != referenced)) {
d538 1
a538 1
					
d548 52
d602 2
a603 1
	 * @@param referencer the referencing resource
a639 1
	
d642 13
a654 9
	 * Returns a Set of EObjects that reference the given EObject.
	 * If an EReference is specified, the scope of the search is limited
	 * only to that EReference. To include all references specify a value of null.
	 * If an EClass type is specified, the returned Set will only include those
	 * referencers that match the given type. To include all types specify a value of null.
	 * 
	 * @@param referenced the referenced EObject
	 * @@param reference the reference to find referencers on, null for any reference
	 * @@param type the type of the referencers, use null for any type
d657 2
a658 1
	public Set getInverseReferencers(EObject referenced, EReference reference, EClass type) {
d665 11
a675 8
	 * search is limited only to that EReference. To include all references specify
	 * a value of null. If an EClass type is specified, the returned Set will only
	 * include those referencers that match the given type. To include all types
	 * specify a value of null.
	 * 
	 * @@param referenced the referenced EObject
	 * @@param reference the reference to find referencers on, null for any reference
	 * @@param type the type of the referencers, use null for any type
d678 4
a681 2
	public Set getNonNavigableInverseReferencers(EObject referenced, EReference reference, EClass type) {
		return getReferencers(getNonNavigableInverseReferences(referenced), reference, type);
d685 9
a693 6
	 * Extracts the EObjects from the EStructuralFeature.Setting references
	 * and returns a filtered Set based on the given reference and type.
	 * 
	 * @@param references a collection of EStructuralFeature.Setting
	 * @@param reference the reference to find referencers on, null for any reference
	 * @@param type the type of the referencers, use null for any type
d696 2
a697 1
	private Set getReferencers(Collection references, EReference reference, EClass type) {
d700 1
a700 1
			for (Iterator iter = references.iterator(); iter.hasNext(); ) {
d702 2
a703 1
				if (reference == null || reference == setting.getEStructuralFeature()) {
d705 2
a706 1
					if (referencer != null && (type == null || type.isInstance(referencer))) {
d716 2
a717 2
	 * Searches the adapter list of the given Notifier for a CrossReferenceAdapter.
	 * If not found, returns null.
d719 2
a720 1
	 * @@param notifier the notifier to search
d723 3
a725 2
	public static CrossReferenceAdapter getExistingCrossReferenceAdapter(Notifier notifier) {
		if (notifier == null ) {
d728 1
a728 1
		
d730 1
a730 1
		
d732 1
a732 1
			Adapter adapter = (Adapter)adapters.get(i);
d734 1
a734 1
				return (CrossReferenceAdapter)adapter;
d741 2
a742 2
	 * Obtains the cross-reference adapter for the specified resource set,
	 * if necessary creating it and attaching it.
d744 2
a745 1
	 * @@param resourceSet the resource set
d749 3
a751 2
	public static CrossReferenceAdapter getCrossReferenceAdapter(ResourceSet resourceSet) {
		if ( resourceSet == null ) {
d754 3
a756 4
		
		CrossReferenceAdapter result = getExistingCrossReferenceAdapter(
			resourceSet);
		
d761 1
a761 1
		
d768 1
a768 1
	 *
d773 1
a773 1
		
d777 1
a777 1
		
d786 1
a786 1
		
d793 1
a793 1
		
d797 2
a798 1
		 * @@return <code>true</code> if I am now zero; <code>false</code>, otherwise
d807 1
a807 1
	}	
@

