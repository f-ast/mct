head	1.4;
access;
symbols
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051201-1800:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.4
date	2006.02.08.14.52.09;	author ldamus;	state dead;
branches;
next	1.3;

1.3
date	2006.01.24.16.46.34;	author vramaswamy;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.25.11;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.45;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.4
log
@[121508] gmf_head cdamus 060208 Refactor MSL using the new transaction API
@
text
@/******************************************************************************
 * Copyright (c) 2003, 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.core.internal.commands;

import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.Set;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.emf.core.internal.domain.MSLEditingDomain;
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;

/**
 * A proxy command makes an EObject proxy.
 * 
 * @@author rafikj
 */
public class MSLProxyCommand
	extends MSLAbstractCommand {

	private EObject eObject = null;

	private URI proxyURI = null;

	/**
	 * Creates a proxy command.
	 */
	public static MCommand create(MSLEditingDomain domain, EObject eObject,
			URI proxyURI) {
		return new MSLProxyCommand(domain, eObject, proxyURI);
	}

	/**
	 * Constructor.
	 */
	private MSLProxyCommand(MSLEditingDomain domain, EObject eObject,
			URI proxyURI) {
		super(domain);
		this.eObject = eObject;
		this.proxyURI = proxyURI;
	}

	/**
	 * @@see org.eclipse.emf.common.command.Command#dispose()
	 */
	public void dispose() {

		super.dispose();

		eObject = null;
		proxyURI = null;
	}

	/**
	 * @@see org.eclipse.emf.common.command.Command#execute()
	 */
	public void execute() {
		((InternalEObject) eObject).eSetProxyURI(proxyURI);
	}

	/**
	 * @@see org.eclipse.emf.common.command.Command#undo()
	 */
	public void undo() {
		if (eObject.eIsProxy()) {

			// attempt a resolve.
			final EObject resolved = EcoreUtil.resolve(eObject, domain
				.getResourceSet());

			if ((resolved != null) && (!resolved.eIsProxy())
				&& (resolved != eObject)) {

				final EClass eClass = resolved.eClass();

				assert eClass == eObject.eClass();

				if (eClass == eObject.eClass()) {

					// copy the guts of the resolved object to the proxy
					// object.
					domain.runSilent(new MRunnable() {

						public Object run() {

							for (Iterator i = eClass
								.getEAllStructuralFeatures().iterator(); i
								.hasNext();) {

								EStructuralFeature feature = (EStructuralFeature) i
									.next();

								if ((!feature.isChangeable())
									|| (feature.isDerived()))
									continue;

								if ((feature instanceof EReference)
									&& (((EReference) feature)
										.isContainer()))
									continue;

								if (feature.isMany()) {

									if (resolved.eIsSet(feature)) {

										Collection list = (Collection) resolved
											.eGet(feature);

										Collection newList = (Collection) eObject
											.eGet(feature);

										newList.clear();
										newList.addAll(list);

									} else if (eObject.eIsSet(feature)) {

										eObject.eUnset(feature);
									}

								} else if (resolved.eIsSet(feature)) {

									Object object = resolved.eGet(feature);

									eObject.eSet(feature, object);

								} else
									eObject.eUnset(feature);
							}

							// make the proxy object non proxy.
							((InternalEObject) eObject).eSetProxyURI(null);

							// remove the resolved object from its
							// container.
							EObject container = resolved.eContainer();

							if (container != null) {

								EReference reference = resolved
									.eContainmentFeature();

								if (reference.isMany())
									((Collection) container.eGet(reference))
										.remove(resolved);
								else
									container.eSet(reference, null);
							}

							// make the resolved object a proxy.
							((InternalEObject) resolved)
								.eSetProxyURI(proxyURI);

							return null;
						}
					});
				}
			}
		}
	}

	/**
	 * @@see org.eclipse.emf.common.command.Command#redo()
	 */
	public void redo() {
		((InternalEObject) eObject).eSetProxyURI(proxyURI);
	}

	/**
	 * @@see org.eclipse.gmf.runtime.emf.core.internal.commands.MCommand#getParticipantTypes()
	 */
	public Set getParticipantTypes() {
		return eObject == null ? Collections.EMPTY_SET
			: Collections.singleton(EObjectUtil.getType(eObject));
	}

	/**
	 * @@see org.eclipse.gmf.runtime.emf.core.internal.commands.MCommand#getType()
	 */
	public Type getType() {
		return MCommand.PROXY;
	}
}@


1.3
log
@[120369], gmf_head,Contributed by cvogt, 060124, MSLConstants Class Contains References to Non-GMF
@
text
@@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a25 1

a27 1
import org.eclipse.gmf.runtime.emf.core.internal.util.MSLConstants;
d82 1
d84 3
a86 14
		if (MSLConstants.PROXY_HACK) {

			if (eObject.eIsProxy()) {

				// attempt a resolve.
				final EObject resolved = EcoreUtil.resolve(eObject, domain
					.getResourceSet());

				if ((resolved != null) && (!resolved.eIsProxy())
					&& (resolved != eObject)) {

					final EClass eClass = resolved.eClass();

					assert eClass == eObject.eClass();
d88 2
a89 1
					if (eClass == eObject.eClass()) {
d91 1
a91 3
						// copy the guts of the resolved object to the proxy
						// object.
						domain.runSilent(new MRunnable() {
d93 1
a93 1
							public Object run() {
d95 1
a95 3
								for (Iterator i = eClass
									.getEAllStructuralFeatures().iterator(); i
									.hasNext();) {
d97 3
a99 2
									EStructuralFeature feature = (EStructuralFeature) i
										.next();
d101 1
a101 3
									if ((!feature.isChangeable())
										|| (feature.isDerived()))
										continue;
d103 3
a105 4
									if ((feature instanceof EReference)
										&& (((EReference) feature)
											.isContainer()))
										continue;
d107 2
a108 1
									if (feature.isMany()) {
d110 3
a112 1
										if (resolved.eIsSet(feature)) {
d114 4
a117 2
											Collection list = (Collection) resolved
												.eGet(feature);
d119 1
a119 2
											Collection newList = (Collection) eObject
												.eGet(feature);
d121 1
a121 2
											newList.clear();
											newList.addAll(list);
d123 2
a124 1
										} else if (eObject.eIsSet(feature)) {
d126 2
a127 2
											eObject.eUnset(feature);
										}
d129 2
a130 1
									} else if (resolved.eIsSet(feature)) {
d132 1
a132 1
										Object object = resolved.eGet(feature);
a133 3
										eObject.eSet(feature, object);

									} else
d135 1
a135 1
								}
d137 1
a137 2
								// make the proxy object non proxy.
								((InternalEObject) eObject).eSetProxyURI(null);
d139 1
a139 3
								// remove the resolved object from its
								// container.
								EObject container = resolved.eContainer();
d141 1
a141 1
								if (container != null) {
d143 3
a145 2
									EReference reference = resolved
										.eContainmentFeature();
d147 2
a148 6
									if (reference.isMany())
										((Collection) container.eGet(reference))
											.remove(resolved);
									else
										container.eSet(reference, null);
								}
d150 15
a164 3
								// make the resolved object a proxy.
								((InternalEObject) resolved)
									.eSetProxyURI(proxyURI);
d166 7
a172 4
								return null;
							}
						});
					}
d175 1
a175 3

		} else
			eObject = EcoreUtil.resolve(eObject, domain.getResourceSet());
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2003, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

