head	1.9;
access;
symbols
	v20081020-0700:1.9
	v20080722-1827:1.9
	v20080716-1600:1.9
	v20080716-1642:1.9
	R2_1_maintenance:1.9.0.2
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080425-1959:1.9
	v20080407-0930:1.9
	v20080404-1111:1.9
	v20080401-1425:1.9
	v20080222-1200:1.9
	v20080215-1500:1.9
	v20080201-2010:1.9
	v20080201-0201:1.8.2.1
	v20080114-2222:1.8
	v20080114-1111:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	RC3_20:1.8
	v20070601-1400:1.8
	v20070330-1300:1.8
	v20070208-1800:1.8
	v20070105-1200:1.7.2.2
	v20070103-0300:1.8
	M4_20:1.8
	v20061218-1500:1.7.2.2
	v20061214-0000:1.8
	M3_20:1.8
	v20061013-1330:1.8
	v20060919-0800:1.7.2.2
	M1_20:1.7
	v20060831-1500:1.7.2.2
	v20060728-0500:1.7.2.1
	v20060721-1130:1.7.2.1
	v20060713-1700:1.7.2.1
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060531-1730:1.7
	v20060530-1930:1.7
	v20060526-1200:1.7
	v20060519-0800:1.7
	I20060505-1400:1.7
	I20060428-1300:1.6
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.4
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.1
	I20060210-1715:1.1
	I20060209-1815:1.1;
locks; strict;
comment	@# @;


1.9
date	2008.01.23.19.10.29;	author ahunter;	state Exp;
branches;
next	1.8;
commitid	41a5479791254567;

1.8
date	2006.10.03.15.05.22;	author ahunter;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2006.05.04.19.49.37;	author vramaswamy;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.04.04.00.25.16;	author vramaswamy;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.15.19.15.37;	author vramaswamy;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.09.01.15.33;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.07.02.40.43;	author ldamus;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.22.17.55.34;	author vramaswamy;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.08.14.52.11;	author ldamus;	state Exp;
branches;
next	;

1.7.2.1
date	2006.07.11.16.07.41;	author mmostafa;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2006.08.28.20.36.10;	author ldamus;	state Exp;
branches;
next	;

1.8.2.1
date	2008.01.23.19.08.59;	author ahunter;	state Exp;
branches;
next	;
commitid	3f9f479790cb4567;


desc
@@


1.9
log
@[216326] gmf-head ahunter 080123 NPE opening diagrams after migrating to GMF 2.0.2
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.core.util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.EStructuralFeature.Setting;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.FeatureMapUtil;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCoreDebugOptions;
import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCorePlugin;
import org.eclipse.gmf.runtime.emf.core.internal.util.EMFCoreConstants;
import org.eclipse.gmf.runtime.emf.core.internal.util.Util;
import org.eclipse.gmf.runtime.emf.core.resources.IExtendedResourceFactory;
import org.eclipse.gmf.runtime.emf.core.resources.IResourceHelper;


/**
 * Static utilities for working with EMF objects and resources in the GMF
 * environment.
 *
 * @@author Christian W. Damus (cdamus)
 */
public class EMFCoreUtil {

	/**
	 * Creates an object at a given containment reference whose
	 * <code>EClass</code> is eClass.
	 * 
	 * @@param container
	 *            The container of the new object.
	 * @@param reference
	 *            The feature containing the object.
	 * @@param eClass
	 *            The <code>EClass</code>.
	 * @@return The new <code>EObject</code>.
	 */
	public static EObject create(EObject container, EReference reference,
			EClass eClass) {

		EObject result = null;

		IResourceHelper helper = Util.getHelper(container.eResource());
		
		if (helper != null) {

			result = helper.create(eClass);

		} else {
			result = eClass.getEPackage().getEFactoryInstance().create(eClass);
		}
		
		if (FeatureMapUtil.isMany(container,reference)) {
			((Collection) container.eGet(reference)).add(result);
		} else {
			container.eSet(reference, result);
		}
		
		return result;
	}

	/**
	 * Gets the first container with the specified EClass.
	 * 
	 * @@param eObject
	 *            The <code>EObject</code>.
	 * @@param eClass
	 *            The eClass.
	 * @@return The container.
	 */
	public static EObject getContainer(EObject eObject, EClass eClass) {

		for (EObject parent = eObject; parent != null; parent = parent
			.eContainer())
			if (eClass.isInstance(parent))
				return parent;

		return null;
	}

	/**
	 * Finds the first common container of a collection of objects.
	 * 
	 * @@param objects
	 *            The <code>EObject</code>s.
	 * @@param desiredContainerType
	 *            The desired <code>EClass</code> of the container.
	 * @@return The least common container.
	 */
	public static EObject getLeastCommonContainer(Collection objects,
			EClass desiredContainerType) {

		EObject commonContainer = null;

		List prevContainers = new ArrayList();

		Iterator i = objects.iterator();

		while (i.hasNext()) {

			EObject element = (EObject) i.next();
			List containers = new ArrayList();

			boolean found = false;

			EObject container = element;

			while (container != null) {

				EClass containerClass = container.eClass();

				if ((desiredContainerType == containerClass)
					|| (desiredContainerType.isSuperTypeOf(containerClass))) {

					containers.add(container);

					if (!found) {

						if ((prevContainers.isEmpty())
							|| (commonContainer == null)) {
							commonContainer = container;
							found = true;

						} else if ((prevContainers.contains(container))
							&& (EcoreUtil.isAncestor(container, commonContainer))) {

							commonContainer = container;
							found = true;
						}
					}
				}

				container = container.eContainer();
			}

			if (!found)
				return null;

			prevContainers = containers;
		}

		return commonContainer;
	}

	/**
	 * Uses a reverse reference map that is maintained by the MSL service to
	 * find all referencers of a particular element. The search can be narrowed
	 * down by passing the list of Reference features to match.
	 * <code>features</code> can be null.
	 * 
	 * @@param eObject
	 *            The referenced object.
	 * @@param features
	 *            The reference features.
	 * @@return The collection of referencers.
	 */
	public static Collection getReferencers(EObject eObject,
			EReference[] features) {

		CrossReferenceAdapter crossReferenceAdapter =
				CrossReferenceAdapter.getExistingCrossReferenceAdapter(eObject);

		if (crossReferenceAdapter == null) {
			TransactionalEditingDomain domain = TransactionUtil.getEditingDomain(
				eObject);
			
			if (domain != null) {
				crossReferenceAdapter = CrossReferenceAdapter.getCrossReferenceAdapter(
					domain.getResourceSet());
			}
			
			if (crossReferenceAdapter == null) {
				// still null?  Give up
				return Collections.EMPTY_LIST;
			}
		}
		
		Collection settings  = crossReferenceAdapter.getInverseReferences(eObject);
		
		if (settings.isEmpty() == false) {
			ArrayList referencers = new ArrayList();
			int count;
			if ((features != null) && ((count = features.length) != 0)) {				
				Iterator it = settings.iterator();
				while (it.hasNext()) {
					Setting setting = (Setting) it.next();
					EStructuralFeature feature = setting
					.getEStructuralFeature();
					for(int i = 0; i< count;++i){
						if (feature == features[i]) {
							referencers.add(setting.getEObject());
							break;
						}						
					}					
				}
			} else {
				Iterator it = settings.iterator();
				while (it.hasNext()) {
					referencers.add(((Setting) it.next()).getEObject());
				}
			}
			return referencers;
		}
		return Collections.EMPTY_LIST;
	}
	
	/**
	 * Gets the imports of a resource.  These are the resources to which this
	 * <code>resource</code> has references.
	 * 
	 * @@param resource a resource.
	 * @@return the imports of the resource
	 */
	public static Collection getImports(Resource resource) {
		TransactionalEditingDomain domain = TransactionUtil.getEditingDomain(resource);
		
		if (domain != null) {
			return CrossReferenceAdapter.getCrossReferenceAdapter(domain.getResourceSet()).getImports(resource);
		}
		
		return Collections.EMPTY_SET;
	}

	/**
	 * Gets the exports of a resource.  These are the resources that have
	 * references to the <code>resource</code>.
	 * 
	 * @@param resource a resource.
	 * @@return the exports of the resource
	 */
	public static Collection getExports(Resource resource) {
		TransactionalEditingDomain domain = TransactionUtil.getEditingDomain(resource);
		
		if (domain != null) {
			return CrossReferenceAdapter.getCrossReferenceAdapter(domain.getResourceSet()).getExports(resource);
		}
		
		return Collections.EMPTY_SET;
	}

	/**
	 * Gets the transitive closure of the imports of a resource.  This obtains
	 * those resources that import the <code>resource</code>, the resources
	 * that import those, etc.
	 * 
	 * @@param resource a resource.
	 * @@return the transitive imports of the resource
	 */
	public static Collection getTransitiveImports(Resource resource) {
		Collection result = new HashSet();
		Collection unload = new HashSet();

		getTransitiveImports(resource, result, unload);

		for (Iterator i = unload.iterator(); i.hasNext();) {
			((Resource) i.next()).unload();
		}
		
		return result;
	}

	/**
	 * Helper method to recursively compute transitive imports of a resource.
	 */
	private static void getTransitiveImports(Resource resource, Collection imports,
			Collection unload) {

		if (!resource.isLoaded()) {

			try {
				resource.load(Collections.EMPTY_MAP);
			} catch (Exception e) {
				// ignore resources that fail to load.
			}

			unload.add(resource);
		}

		Collection directImports = getImports(resource);

		for (Iterator i = directImports.iterator(); i.hasNext();) {

			Resource directImport = (Resource) i.next();

			if (!imports.contains(directImport)) {

				imports.add(directImport);

				getTransitiveImports(directImport, imports, unload);
			}
		}
	}

	/**
	 * Gets the transitive closure of the exports of a resource.  This obtains
	 * those resources that export the <code>resource</code>, the resources
	 * that export those, etc.
	 * 
	 * @@param resource a resource.
	 * @@return the transitive exports of the resource
	 */
	public static Collection getTransitiveExports(Resource resource) {
		Collection result = new HashSet();
		Collection unload = new HashSet();

		getTransitiveExports(resource, result, unload);

		for (Iterator i = unload.iterator(); i.hasNext();) {
			((Resource) i.next()).unload();
		}
		
		return result;
	}

	/**
	 * Helper method to recursively compute transitive imports of a resource.
	 */
	private static void getTransitiveExports(Resource resource, Collection exports,
			Collection unload) {

		if (!resource.isLoaded()) {

			try {
				resource.load(Collections.EMPTY_MAP);
			} catch (Exception e) {
				// ignore resources that fail to load.
			}

			unload.add(resource);
		}

		Collection directExports = getExports(resource);

		for (Iterator i = directExports.iterator(); i.hasNext();) {

			Resource directExport = (Resource) i.next();

			if (!exports.contains(directExport)) {

				exports.add(directExport);

				getTransitiveExports(directExport, exports, unload);
			}
		}
	}

	/**
	 * Gets the name of an object if the object has name, returns an empty
	 * string otherwise.
	 * 
	 * @@param eObject
	 *            The object.
	 * @@return The object's name.
	 */
	public static String getName(EObject eObject) {
		
		if (eObject == null) {
			return EMFCoreConstants.EMPTY_STRING;
		}

		if (eObject.eIsProxy())
			return getProxyName(eObject);

		EAttribute nameAttribute = PackageUtil.getNameAttribute(eObject
			.eClass());

		if (nameAttribute != null) {

			String name = (String) eObject.eGet(nameAttribute);

			if (name != null)
				return name;
		}

		return EMFCoreConstants.EMPTY_STRING;
	}
	
	private static String getProxyName(EObject proxy) {

		URI uri = EcoreUtil.getURI(proxy);

		Resource.Factory factory = Resource.Factory.Registry.INSTANCE
			.getFactory(uri);

		String result = null;
		
		if (factory instanceof IExtendedResourceFactory) {
			result = ((IExtendedResourceFactory) factory).getProxyName(proxy);
		}
		
		if (result == null) {
			// default algorithm
			
			result = EMFCoreConstants.EMPTY_STRING;
		}
		
		return result;
	}

	/**
	 * Sets the name of an object if the object can be assigned a name.
	 * 
	 * @@param eObject
	 *            The object.
	 * @@param name
	 *            The object's new name.
	 *            
	 * @@throws IllegalArgumentException if the <code>eObject</code> does not
	 *     have a name attribute
	 */
	public static void setName(EObject eObject, String name) {

		EAttribute nameAttribute = PackageUtil.getNameAttribute(eObject
			.eClass());

		if (nameAttribute != null) {

			eObject.eSet(nameAttribute, name);

		} else {

			RuntimeException e = new IllegalArgumentException(
				"object has no name attribute"); //$NON-NLS-1$

			Trace.throwing(EMFCorePlugin.getDefault(),
				EMFCoreDebugOptions.EXCEPTIONS_THROWING, EMFCoreUtil.class,
				"setName", e); //$NON-NLS-1$

			throw e;
		}
	}

	/**
	 * Gets the fully qualified name of an object.
	 * 
	 * @@param eObject
	 *            The object.
	 * @@param formatted
	 *            if True, unnamed parents will be listed using their meta-class
	 *            name.
	 * @@return The object's qualified name.
	 */
	public static String getQualifiedName(EObject eObject, boolean formatted) {

		if (eObject.eIsProxy())
			return getProxyQualifiedName(eObject);

		if (!formatted) {

			EAttribute qNameAttribute = PackageUtil.getQualifiedNameAttribute(
				eObject.eClass());

			if (qNameAttribute != null) {

				String qualifiedName = (String) eObject.eGet(qNameAttribute);

				if (qualifiedName != null)
					return qualifiedName;
				else
					return EMFCoreConstants.EMPTY_STRING;
			}
		}

		String prefix = EMFCoreConstants.EMPTY_STRING;

		EObject eContainer = eObject.eContainer();

		while ((eContainer != null) && (eContainer instanceof EAnnotation))
			eContainer = eContainer.eContainer();

		if (eContainer != null)
			prefix = getQualifiedName(eContainer, formatted);

		String name = getName(eObject);

		if ((formatted) && (name.equals(EMFCoreConstants.EMPTY_STRING)))
			name = EMFCoreConstants.META_CLASS_BEGIN
				+ PackageUtil.getLocalizedName(eObject.eClass())
				+ EMFCoreConstants.META_CLASS_END;

		return (prefix.length() == 0) ? name
			: (prefix + ((name.equals(EMFCoreConstants.EMPTY_STRING)) ? EMFCoreConstants.EMPTY_STRING
				: (EMFCoreConstants.QUALIFIED_NAME_SEPARATOR + name)));
	}

	private static String getProxyQualifiedName(EObject proxy) {

		URI uri = EcoreUtil.getURI(proxy);

		Resource.Factory factory = Resource.Factory.Registry.INSTANCE
			.getFactory(uri);

		String result = null;
		
		if (factory instanceof IExtendedResourceFactory) {
			result = ((IExtendedResourceFactory) factory).getProxyQualifiedName(proxy);
		}
		
		if (result == null) {
			// default algorithm
			
			result = EMFCoreConstants.EMPTY_STRING;
		}
		
		return result;
	}
	
	/**
	 * Gets the proxy ID by parsing the proxy URI.
	 * 
	 * @@param proxy
	 *            The proxy object.
	 * @@return The ID.
	 */
	public static String getProxyID(EObject proxy) {

		if (proxy == null) {
			return EMFCoreConstants.EMPTY_STRING;
		}
		
		if (!proxy.eIsProxy() && (proxy.eResource() instanceof XMLResource)) {
			XMLResource res = (XMLResource) proxy.eResource();
			
			if (res == null) {
				return EMFCoreConstants.EMPTY_STRING;
			} else {
                String id =  res.getID(proxy);
                // if the object had no ID then the best we can do is to return the URI Fragment
                if (id ==null || id.length() ==0){
                    return res.getURIFragment(proxy);
                }
            }
		}
		
		URI uri = EcoreUtil.getURI(proxy);

		Resource.Factory factory = Resource.Factory.Registry.INSTANCE
			.getFactory(uri);

		String result = null;
		
		if (factory instanceof IExtendedResourceFactory) {
			result = ((IExtendedResourceFactory) factory).getProxyID(proxy);
		}

		if (result == null) {
			// default implementation
			
			result = Util.getProxyID(proxy);
		}
		
		return result;
	}

	/**
	 * Gets the proxy class by parsing the proxy URI.
	 * 
	 * @@param proxy
	 *            The proxy object.
	 * @@return The class.
	 */
	public static EClass getProxyClass(EObject proxy) {

		if (proxy == null) {
			return null;
		}
		
		if (!proxy.eIsProxy()) {
			return proxy.eClass();
		}
		
		URI uri = EcoreUtil.getURI(proxy);

		Resource.Factory factory = Resource.Factory.Registry.INSTANCE
			.getFactory(uri);

		String id = null;
		
		if (factory instanceof IExtendedResourceFactory) {
			id = ((IExtendedResourceFactory) factory).getProxyClassID(proxy);
		}
		
		if (id == null) {
			// default algorithm
			
			id = PackageUtil.getID(proxy.eClass());
		}

		if (id != null) {

			ENamedElement element = PackageUtil.getElement(id);

			if ((element != null) && (element instanceof EClass))
				return (EClass) element;
		}

		return null;
	}

	/**
	 * Creates a proxy of the specified type with the specified proxy URI.
	 * 
	 * @@param classID
	 *            The type of proxy to create.
	 * @@param uri
	 *            The URI for the new proxy.
	 * @@return The new proxy.
	 */
	public static EObject createProxy(EClass eClass, URI uri) {
		InternalEObject proxy = (InternalEObject) eClass.getEPackage()
			.getEFactoryInstance().create(eClass);
		proxy.eSetProxyURI(uri);

		return proxy;
	}

	/**
	 * Attempts to resolve the specified <code>proxy</code> object, returning
	 * <code>null</code> (rather than the original proxy) if it is unresolvable.
	 * 
	 * @@param domain
	 *            Th editing domain.
	 * @@param proxy
	 *            The proxy object.
	 * @@return The resolved object, or <code>null</code> if not resolved
	 */
	public static EObject resolve(TransactionalEditingDomain domain,
			EObject proxy) {

		if (proxy == null)
			return null;

		if (!proxy.eIsProxy())
			return proxy;

		URI uri = EcoreUtil.getURI(proxy);

		Resource.Factory factory = Resource.Factory.Registry.INSTANCE
			.getFactory(uri);

		if (factory instanceof IExtendedResourceFactory) {
			return ((IExtendedResourceFactory) factory).resolve(domain, proxy);
		}
		
		// the default algorithm
		
		return Util.resolve(domain, proxy);
	}
}
@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
d384 4
@


1.8.2.1
log
@[216326] gmf-R2_0_maintenance ahunter 080123 NPE opening diagrams after migrating to GMF 2.0.2
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2008 IBM Corporation and others.
a383 4
		
		if (eObject == null) {
			return EMFCoreConstants.EMPTY_STRING;
		}
@


1.7
log
@[131094] gmf_head cmcgee 060504 Sweep Code for EReference.isMany() calls
@
text
@d28 1
d30 1
d206 22
a227 16
		if ((features != null) && (features.length != 0)) {

			Collection referencers = new ArrayList();

			for (int i = 0, count = features.length; i < count; i++) {

				EReference feature = features[i];

				Iterator j = crossReferenceAdapter.getInverseReferencers(eObject,
						feature, null).iterator();

				while (j.hasNext()) {

					EObject referencer = (EObject) j.next();

					referencers.add(referencer);
a229 1

d231 2
a232 3

		} else
			return crossReferenceAdapter.getInverseReferencers(eObject, null, null);
d551 6
a556 2
				return res.getID(proxy);
			}
@


1.7.2.1
log
@ [128167] gmf_R1_0_maintenance mmostafa  060711 Mapping of semantic elements to editparts doesn't work
@
text
@d545 2
a546 6
                String id =  res.getID(proxy);
                // if the object had no ID then the best we can do is to return the URI Fragment
                if (id ==null || id.length() ==0){
                    return res.getURIFragment(proxy);
                }
            }
@


1.7.2.2
log
@[155233] gmf_R1_0_maintenance ylulu 060828 Deleting and element using the EditHelpers could be enhanced
@
text
@a27 1
import org.eclipse.emf.ecore.EStructuralFeature;
a28 1
import org.eclipse.emf.ecore.EStructuralFeature.Setting;
d204 16
a219 22
		Collection settings  = crossReferenceAdapter.getInverseReferences(eObject);
		
		if (settings.isEmpty() == false) {
			ArrayList referencers = new ArrayList();
			int count;
			if ((features != null) && ((count = features.length) != 0)) {				
				Iterator it = settings.iterator();
				while (it.hasNext()) {
					Setting setting = (Setting) it.next();
					EStructuralFeature feature = setting
					.getEStructuralFeature();
					for(int i = 0; i< count;++i){
						if (feature == features[i]) {
							referencers.add(setting.getEObject());
							break;
						}						
					}					
				}
			} else {
				Iterator it = settings.iterator();
				while (it.hasNext()) {
					referencers.add(((Setting) it.next()).getEObject());
d222 1
d224 3
a226 2
		}
		return Collections.EMPTY_LIST;
@


1.6
log
@[134605],gmf_head, vramaswa, 060403, ClassCastException in EMFCoreUtil
@
text
@d31 1
d79 1
a79 1
		if (reference.isMany()) {
@


1.5
log
@[131995],gmf_head, vramaswa,060315,The CrossReferenceAdapter needs to public for applications to extend the functionality
@
text
@d538 1
a538 1
		if (!proxy.eIsProxy()) {
@


1.4
log
@[130981] gmf_head cdamus 060308 CrossReferenceAdapter ignores references from containment notification
@
text
@a34 1
import org.eclipse.gmf.runtime.emf.core.internal.index.CrossReferenceAdapter;
d194 1
a194 1
					domain);
d239 1
a239 1
			return CrossReferenceAdapter.getCrossReferenceAdapter(domain).getImports(resource);
d256 1
a256 1
			return CrossReferenceAdapter.getCrossReferenceAdapter(domain).getExports(resource);
@


1.3
log
@[129773] gmf_head cdamus 060306 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@d362 1
a362 1
				directExports.add(directExport);
@


1.2
log
@[126761] gmf_head cdamus 060222 MSLResource requires referenced resources to encode and decode urls
@
text
@a88 24
	 * Destroys the object by removing it from its container and severing all
	 * references from and to the object. it is also recursive, i.e., it gets
	 * called on the children. Calling destroy on an already detached object
	 * will do nothing.
	 * 
	 * @@param eObject
	 *            The object to destroy.
	 */
	public static void destroy(EObject eObject) {
		Resource resource = eObject.eResource();
		
		if (resource != null) {

			IResourceHelper helper = Util.getHelper(resource);
			
			if (helper != null) {
				helper.destroy(eObject);
			} else {
				Util.destroy(eObject);
			}
		}
	}

	/**
@


1.1
log
@[121508] gmf_head cdamus 060208 Refactor MSL using the new transaction API
@
text
@d69 1
a69 1
		IResourceHelper helper = getHelper(container.eResource());
d102 1
a102 1
			IResourceHelper helper = getHelper(resource);
a112 20
	 * Gets the helper for the specified resource, if any.
	 * 
	 * @@param resource a resource (may be <code>null</code>)
	 * 
	 * @@return the helper, if one is attached, or <code>null</code> if none
	 *     or if no resource is specified
	 */
	private static IResourceHelper getHelper(Resource resource) {
		IResourceHelper result = null;
		
		if (resource != null) {
			result = (IResourceHelper) EcoreUtil.getExistingAdapter(
				resource,
				IResourceHelper.class);
		}
		
		return result;
	}

	/**
d436 1
a436 1
			result = Util.getProxyName(proxy);
d544 1
a544 1
			result = Util.getProxyQualifiedName(proxy);
@

