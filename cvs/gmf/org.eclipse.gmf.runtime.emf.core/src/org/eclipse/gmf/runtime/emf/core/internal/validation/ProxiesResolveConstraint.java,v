head	1.4;
access;
symbols
	v20081020-0700:1.4
	v20080722-1827:1.4
	v20080716-1600:1.4
	v20080716-1642:1.4
	R2_1_maintenance:1.4.0.4
	Root_R2_1_maintenance:1.4
	R2_1_0:1.4
	v20080425-1959:1.4
	v20080407-0930:1.4
	v20080404-1111:1.4
	v20080401-1425:1.4
	v20080222-1200:1.4
	v20080215-1500:1.4
	v20080201-2010:1.4
	v20080201-0201:1.4
	v20080114-2222:1.4
	v20080114-1111:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	RC3_20:1.4
	v20070601-1400:1.4
	v20070330-1300:1.4
	v20070208-1800:1.4
	v20070105-1200:1.3.2.1
	v20070103-0300:1.4
	M4_20:1.4
	v20061218-1500:1.3.2.1
	v20061214-0000:1.4
	M3_20:1.4
	v20061013-1330:1.4
	v20060919-0800:1.3.2.1
	M1_20:1.3
	v20060831-1500:1.3
	v20060728-0500:1.3
	v20060721-1130:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1200:1.3
	v20060531-1730:1.3
	v20060530-1930:1.3
	v20060526-1200:1.3
	v20060519-0800:1.3
	I20060505-1400:1.3
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.3
	I20060216-1945:1.3
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051201-1800:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.4
date	2006.10.03.15.05.22;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.08.14.52.13;	author ldamus;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2005.09.12.21.25.12;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.50;	author sshaw;	state Exp;
branches;
next	;

1.3.2.1
date	2006.09.13.16.46.17;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.4
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/


package org.eclipse.gmf.runtime.emf.core.internal.validation;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EContentsEList;

import org.eclipse.emf.validation.AbstractModelConstraint;
import org.eclipse.emf.validation.IValidationContext;
import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCorePlugin;
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;

/**
 * Implements a validator that collects model reference errors and forwards them on to
 * the EMF model validation service.
 *
 * @@author Steve Gutz (sgutz)
 */
public class ProxiesResolveConstraint
	extends AbstractModelConstraint {
	
	/** The rule ID for resource file path errors */
	public static final String	RESOURCE_RULE_ID	= "org.eclipse.gmf.runtime.emf.core.ResourceFixup"; //$NON-NLS-1$
	/** The rule ID for element ID errors */
	public static final String	ELEMENT_RULE_ID		= "org.eclipse.gmf.runtime.emf.core.IdFixup"; //$NON-NLS-1$

	public static final String DIAGNOSTIC_SOURCE = EMFCorePlugin.getPluginId();
	
	/**
	 * Initializes me.
	 */
	public ProxiesResolveConstraint() {
		super();
	}

	private String getObjectLabel(EObject eObject)
	{
		return EMFCoreUtil.getQualifiedName(eObject,true);
	}
	
	private String getFeatureLabel(EStructuralFeature eStructuralFeature)
	{
		return eStructuralFeature.getName();
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.emf.validation.AbstractModelConstraint#validate(org.eclipse.emf.validation.IValidationContext)
	 */
	public IStatus validate(IValidationContext ctx) {
    	EObject target = ctx.getTarget();
    	
    	EStructuralFeature feature = null;
    	EObject proxyObject = null;
    	
		for (EContentsEList.FeatureIterator i = (EContentsEList.FeatureIterator) target
			.eCrossReferences().iterator(); i.hasNext();) {
			
			EObject eCrossReferenceObject = (EObject) i.next();
			
			if (!i.feature().isDerived() && eCrossReferenceObject.eIsProxy()) {
				feature = i.feature();
				proxyObject = eCrossReferenceObject;
				ctx.addResult(proxyObject);
				break;
			}
		}
		
		if (feature != null) {
			ResourceSet rSet = target.eResource().getResourceSet();
			
			// Load the resource for the broken element
			URI proxyURI = ((InternalEObject)proxyObject).eProxyURI().trimFragment();
			Resource resource = rSet.getResource(proxyURI, false);

			// If we found a resource and it is loaded then the ID must be
			// incorrect
			if (resource != null && resource.isLoaded()) {
				
				// If we have been asked to find this case through the element fixup
				//  constraint then we will report this problem.
				if (ctx.getCurrentConstraintId().equals(ELEMENT_RULE_ID)) {
					return ctx.createFailureStatus(new Object[] {
						getFeatureLabel(feature), getObjectLabel(target),
						getObjectLabel(proxyObject)});
				}
				
				return ctx.createSuccessStatus();
			}
			// If we have been asked to find this case through the resource fixup
			//  constraint then we will report this problem.
			else if (ctx.getCurrentConstraintId().equals(RESOURCE_RULE_ID)) {
				return ctx.createFailureStatus(new Object[] {
					getFeatureLabel(feature), getObjectLabel(target),
					getObjectLabel(proxyObject)});
			}
		}
    	return ctx.createSuccessStatus();
	}

// cmcgee: KEEPING THIS CODE AROUND FOR FUTURE INSPECTION
//	/**
//	 * A simple status implementation to convert an EMF disagnostic
//	 *
//	 * @@author Steve Gutz (sgutz)
//	 */
//	private final class FixupStatus implements IConstraintStatus {
//		
//		Diagnostic diagnostic;
//		IModelConstraint constraint;
//
//		public FixupStatus(Diagnostic diagnostic, IModelConstraint constraint) {
//			this.diagnostic = diagnostic;
//			this.constraint = constraint;
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#getChildren()
//		 */
//		public IStatus[] getChildren() {
//			List l = diagnostic.getChildren();
//			List paredList = new ArrayList();
//			for (int iCtr = l.size() - 1; iCtr >= 0; iCtr--) {
//				Diagnostic child = (Diagnostic) l.get(iCtr);
//
//				// Only collect diagnostic errors for things we care about
//				if (child.getData().size() == 3) {
//					paredList.add(child);
//				}
//			}
//
//			IStatus[] converted = new FixupStatus[paredList.size()];
//			int iCtr = 0;
//			for (Iterator it = paredList.iterator(); it.hasNext();) {
//				converted[iCtr++] = new FixupStatus((Diagnostic) it.next(), constraint);
//			}
//			return converted;
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#getCode()
//		 */
//		public int getCode() {
//			return diagnostic.getCode();
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#getMessage()
//		 */
//		public String getMessage() {
//			String msg = diagnostic.getMessage();
//			String source = ProxyUtil.getProxyQName( (InternalEObject)diagnostic.getData().get(0));
//			String target = ProxyUtil.getProxyQName( (InternalEObject)diagnostic.getData().get(2));
//
//			boolean foundSource = false;
//			int index = 0;
//			while ( index != -1 && index < msg.length()) {
//				
//				index = msg.indexOf('\'', index);
//				if (index > -1) {
//					int nextQuoteIndex = msg.indexOf('\'', index+1);
//					if( nextQuoteIndex != -1 ) {
//						String sub = msg.substring(index, nextQuoteIndex);
//						
//						if( sub.indexOf( '@@') != -1 && sub.indexOf( '}') != -1) {
//							if( !foundSource ) {
//								msg = msg.substring(0, index+1)
//										+ source + msg.substring(nextQuoteIndex);
//								nextQuoteIndex = index+source.length()+1;
//								foundSource = true;
//							} else {
//								msg = msg.substring(0, index+1)
//								+ target + msg.substring(nextQuoteIndex);
//								nextQuoteIndex = index+target.length()+1;
//							}
//						}
//						index = nextQuoteIndex+1;
//					}
//				}
//			}
//			return msg;
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#getSeverity()
//		 */
//		public int getSeverity() {
//			return diagnostic.getSeverity();
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#getException()
//		 */
//		public Throwable getException() {
//			return null;
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#getPlugin()
//		 */
//		public String getPlugin() {
//			return MSLPlugin.getPluginId();
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#isMultiStatus()
//		 */
//		public boolean isMultiStatus() {
//			List l = diagnostic.getChildren();
//			if (l == null || l.size() == 0)
//				return false;
//			return true;
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#isOK()
//		 */
//		public boolean isOK() {
//			return false;
//		}
//	
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.core.runtime.IStatus#matches(int)
//		 */
//		public boolean matches(int severityMask) {
//			return (diagnostic.getSeverity() & severityMask) != 0;
//		}
//
//		/* (non-Javadoc)
//		 * @@see org.eclipse.gmf.runtime.emf.core.IValidationStatus#getTarget()
//		 */
//		public EObject getTarget() {
//			if (diagnostic.getData() == null)
//				return null;
//
//			Object obj = diagnostic.getData().get(0);
//			if (obj instanceof EObject)
//				return (EObject) obj;
//			return null;
//		}
//
//		/*
//		 * (non-Javadoc)
//		 * 
//		 * @@see org.eclipse.gmf.runtime.emf.core.IValidationStatus#getRelatedObjects()
//		 */
//		public Set getRelatedObjects() {
//			HashSet set = new HashSet();
//			set.add(diagnostic.getData().get(2));
//			return set;
//		}
//
//		/* (non-Javadoc)
//		 * @@see org.eclipse.emf.validation.model.IConstraintStatus#getConstraint()
//		 */
//		public IModelConstraint getConstraint() {
//			return constraint;
//		}
//
//		/* (non-Javadoc)
//		 * @@see org.eclipse.emf.validation.model.IConstraintStatus#getResultLocus()
//		 */
//		public Set getResultLocus() {
//			if (diagnostic.getData() == null || diagnostic.getData().size() > 0) {
//				Object o = diagnostic.getData().get(0);
//				
//				// If the first object is an EObject, then we assume that this
//				//  is the EObject for which there is a problem. See the
//				//  javadoc for emf.common.util.Diagnostic.getData() for more
//				//  information.
//				if (o instanceof EObject) {
//					return Collections.singleton(o);
//				}
//			}
//			
//			return Collections.EMPTY_SET;
//		}
//	}
//	
//	/**
//	 * Overrides the basic EObjectValidator's proxy-resolvableness constraint
//	 * to check only those features that are not derived.
//	 *
//	 * @@author Christian W. Damus (cdamus)
//	 */
//	private static final class EFixupValidator
//		extends EObjectValidator {
//
//		public boolean validate_EveryProxyResolves(EObject eObject,
//				DiagnosticChain diagnostics, Map context) {
//			boolean result = true;
//			for (EContentsEList.FeatureIterator i = (EContentsEList.FeatureIterator) eObject
//				.eCrossReferences().iterator(); i.hasNext();) {
//				
//				EObject eCrossReferenceObject = (EObject) i.next();
//				
//				if (!i.feature().isDerived() && eCrossReferenceObject.eIsProxy()) {
//					result = false;
//					if (diagnostics != null) {
//						diagnostics.add(new BasicDiagnostic(Diagnostic.ERROR,
//							ProxiesResolveConstraint.DIAGNOSTIC_SOURCE,
//							EObjectValidator.EOBJECT__EVERY_PROXY_RESOLVES,
//							EcorePlugin.INSTANCE.getString(
//								"_UI_UnresolvedProxy_diagnostic", //$NON-NLS-1$
//								new Object[] {
//									getFeatureLabel(i.feature(), context),
//									getObjectLabel(eObject, context),
//									getObjectLabel(
//										eCrossReferenceObject,
//										context)}),
//								new Object[] {
//									eObject,
//									i.feature(),
//									eCrossReferenceObject}));
//					} else {
//						break;
//					}
//				}
//			}
//			return result;
//		}
//	}
}
@


1.3
log
@[121508] gmf_head cdamus 060208 Refactor MSL using the new transaction API
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
@


1.3.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a23 2
import org.eclipse.gmf.runtime.emf.core.internal.plugin.MSLPlugin;
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
d26 2
d43 1
a43 1
	public static final String DIAGNOSTIC_SOURCE = MSLPlugin.getPluginId();
d54 1
a54 1
		return EObjectUtil.getQName(eObject,true);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

