head	1.9;
access;
symbols
	v20081020-0700:1.9
	v20080722-1827:1.9
	v20080716-1600:1.9
	v20080716-1642:1.9
	R2_1_maintenance:1.9.0.4
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080425-1959:1.9
	v20080407-0930:1.9
	v20080404-1111:1.9
	v20080401-1425:1.9
	v20080222-1200:1.9
	v20080215-1500:1.9
	v20080201-2010:1.9
	v20080201-0201:1.9
	v20080114-2222:1.9
	v20080114-1111:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	RC3_20:1.9
	v20070601-1400:1.9
	v20070330-1300:1.9
	v20070208-1800:1.9
	v20070105-1200:1.7.2.2
	v20070103-0300:1.9
	M4_20:1.9
	v20061218-1500:1.7.2.2
	v20061214-0000:1.9
	M3_20:1.8
	v20061013-1330:1.8
	v20060919-0800:1.7.2.1
	M1_20:1.7
	v20060831-1500:1.7
	v20060728-0500:1.7
	v20060721-1130:1.7
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060531-1730:1.7
	v20060530-1930:1.7
	v20060526-1200:1.7
	v20060519-0800:1.7
	I20060505-1400:1.7
	I20060428-1300:1.7
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.5
	I20060216-1945:1.4
	I20060210-1715:1.4
	I20060209-1815:1.4
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051201-1800:1.3
	I20051124-2000:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;


1.9
date	2006.11.22.22.41.37;	author crevells;	state Exp;
branches;
next	1.8;
commitid	7e424564d2214567;

1.8
date	2006.10.03.15.05.22;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.28.00.28.31;	author vramaswamy;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.04.25.12.48.27;	author vramaswamy;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.24.14.56.32;	author vramaswamy;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.08.14.52.14;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.12.20.14.30;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.25.12;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.42;	author sshaw;	state Exp;
branches;
next	;

1.7.2.1
date	2006.09.07.21.33.41;	author ldamus;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2006.11.22.22.39.56;	author crevells;	state Exp;
branches;
next	;
commitid	75214564d1bc4567;


desc
@@


1.9
log
@[162200] gmf_head gmf_head crevells 061122 CopyingResource blindly appends URI fragment queries
Contributed by: David Cummings
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.core.clipboard;

import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.Map;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.ecore.xmi.XMLHelper;
import org.eclipse.emf.ecore.xmi.XMLLoad;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipse.emf.ecore.xmi.XMLSave;
import org.eclipse.emf.ecore.xmi.impl.XMIHelperImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceImpl;
import org.eclipse.emf.ecore.xmi.impl.XMISaveImpl;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCoreDebugOptions;
import org.eclipse.gmf.runtime.emf.core.internal.plugin.EMFCorePlugin;
import org.eclipse.gmf.runtime.emf.core.internal.util.EMFCoreConstants;
import org.eclipse.gmf.runtime.emf.core.internal.util.Util;
import org.eclipse.gmf.runtime.emf.core.util.EMFCoreUtil;

/**
 * @@author Yasser Lulu
 */
public class CopyingResource
	extends XMIResourceImpl {

	private XMLResource xmlResource;
	
	private CopyingResourceSet copyingResourceSet;

	public CopyingResource(XMLResource resource, URI uri,
			CopyingResourceSet copyingResourceSet) {
		this(resource, uri, copyingResourceSet, true);
	}

	public CopyingResource(XMLResource resource, URI uri,
			CopyingResourceSet copyingResourceSet, boolean regenerateIds) {
		super(uri);
		this.xmlResource = resource;
		this.copyingResourceSet = copyingResourceSet;
		setEncoding(resource.getEncoding());
		//needed to allow calls to unload() to proceed
		setLoaded(true);
		getDefaultSaveOptions().putAll(resource.getDefaultSaveOptions());
		copyingResourceSet.getResources().add(this);
		copyingResourceSet.getResourcesMap().put(resource, this);
		if (regenerateIds) {
			createNewIDs();
		} else {
			copyIDs();
		}
	}

	/**
	 *  
	 */
	private void createNewIDs() {
		// OK to get all contents because we have to copy
		//    the entire model content of this resource
		Iterator it = getXMLResource().getAllContents();
		while (it.hasNext()) {
			setID((EObject) it.next(), EcoreUtil.generateUUID());
		}
	}

	protected XMLLoad createXMLLoad() {
		throwUnsupportedOperationException("createXMLLoad", //$NON-NLS-1$
			new UnsupportedOperationException(
				"Can't call load on CopyingResource resource"));//$NON-NLS-1$
		return null;
	}

	protected XMLHelper createXMLHelper() {
		return new CopyingHelper(this);
	}

	protected void unloaded(InternalEObject internalEObject) {
		//disable parent
	}

	/**
	 * @@see org.eclipse.emf.common.notify.impl.NotifierImpl#eNotificationRequired()
	 */
	public boolean eNotificationRequired() {
		return false;
	}

	private void throwUnsupportedOperationException(String methodName,
			UnsupportedOperationException ex) {
		Trace.throwing(EMFCorePlugin.getDefault(),
			EMFCoreDebugOptions.EXCEPTIONS_THROWING, getClass(), methodName, ex);
		throw ex;
	}

	/**
	 * @@return Returns the resourcesMap.
	 */
	private Map getResourcesMap() {
		return getMslCopyingResourceSet().getResourcesMap();
	}

	public void doLoad(InputStream inputStream, Map options)
		throws IOException {
		throwUnsupportedOperationException("doLoad", //$NON-NLS-1$
			new UnsupportedOperationException(
				"Can't call load on CopyingResource resource"));//$NON-NLS-1$
	}

	protected XMLSave createXMLSave() {
		return new CopyingSave(createXMLHelper());
	}

	private boolean isInResource(EObject eObject) {
		// in case of cross-resource containment, the 'eObject' may be in a
		//     different resource than xmlResource, though one of its containers
		//     may be
		while (eObject != null) {
			if (((InternalEObject) eObject).eDirectResource() == getXMLResource()) {
				return true;
			}
			
			eObject = eObject.eContainer();
		}
		
		return false;
	}

	public EList getContents() {
		return getXMLResource().getContents();
	}

	/**
	 * @@see org.eclipse.emf.ecore.resource.impl.ResourceImpl#doUnload()
	 */
	protected void doUnload() {
		//disable parent's
	}

	public EObject getEObject(String uriFragment) {
		int index = uriFragment.indexOf('?');
		if (-1 != index) {
			uriFragment = uriFragment.substring(0, index);
		}
		return super.getEObject(uriFragment);
	}

	/**
	 * Returns the object based on the fragment as an ID.
	 */
	protected EObject getEObjectByID(String id) {
		EObject eObj = getXMLResource().getEObject(id);
		if (eObj == null) {
			return super.getEObjectByID(id);
		}
		return eObj;
	}

	/**
	 * @@return Returns the CopyingResourceSet.
	 */
	public CopyingResourceSet getMslCopyingResourceSet() {
		return copyingResourceSet;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.emf.ecore.resource.impl.ResourceImpl#getResourceSet()
	 */
	public ResourceSet getResourceSet() {
		return getMslCopyingResourceSet();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.emf.ecore.resource.Resource.Internal#attached(org.eclipse.emf.ecore.EObject)
	 */
	public void attached(EObject eObject) {
		//disable
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.emf.ecore.resource.Resource.Internal#detached(org.eclipse.emf.ecore.EObject)
	 */
	public void detached(EObject eObject) {
		//disable
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.emf.ecore.xmi.XMLResource#getEObjectToExtensionMap()
	 */
	public Map getEObjectToExtensionMap() {
		return getXMLResource().getEObjectToExtensionMap();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.emf.ecore.resource.Resource#isTrackingModification()
	 */
	public boolean isTrackingModification() {
		return false;
	}

	private void copyIDs() {
		// OK to get all contents because we have to copy
		//    the entire model content of this resource
		XMLResource lastRes = null;
		
		for (Iterator iter = getXMLResource().getAllContents(); iter.hasNext(); ) {
			InternalEObject eObject = (InternalEObject)iter.next();
			
			if (eObject.eDirectResource() != null) {
				// ensure that we only ask the resource that actually contains
				//    an object for that object's ID
				lastRes = (XMLResource) eObject.eDirectResource();
			}
			
			getEObjectToIDMap().put(eObject, lastRes.getID(eObject));
			getIDToEObjectMap().put(lastRes.getID(eObject), eObject);
		}
	}
	
	/**
	 * Gets the XML resource that contains the model content to be copied.
	 * 
	 * @@return the XML resource
	 */
	protected XMLResource getXMLResource() {
		return xmlResource;
	}
	
	/**
	 * Helper implementation for the CopyingResource.
	 */
	protected class CopyingHelper extends XMIHelperImpl {
		
		public CopyingHelper() {
			super();
		}
		  
		public CopyingHelper(XMLResource resource) {
		    super(resource);
		}

		/**
		 * @@see org.eclipse.emf.ecore.xmi.XMLHelper#deresolve(org.eclipse.emf.common.util.URI)
		 */
		public URI deresolve(URI anUri) {

			// if this both target and container are within a platform resource and
			// projects
			// or plugins are different then do not deresolve.
			if (((EMFCoreConstants.PLATFORM_SCHEME.equals(anUri.scheme())) && (EMFCoreConstants.PLATFORM_SCHEME
				.equals(resourceURI.scheme())))
				&& ((anUri.segmentCount() > 2) && (resourceURI.segmentCount() > 2))
				&& ((!anUri.segments()[0].equals(resourceURI.segments()[0])) || (!anUri
					.segments()[1].equals(resourceURI.segments()[1]))))
				return anUri;

			return super.deresolve(anUri);
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @@see org.eclipse.emf.ecore.xmi.impl.XMLHelperImpl#getHREF(org.eclipse.emf.ecore.EObject)
		 */
		public String getHREF(EObject obj) {
			EObject eObj = obj;
			
			if (obj.eIsProxy()) {
				eObj = EcoreUtil.resolve(obj, getXMLResource());
				if (eObj == obj) {
					// use super.getHREF() if we can't resolve the proxy
					eObj = null;
				}
			}
			
			if (eObj != null) {
				Resource resource = eObj.eResource();
				if (resource != null) {
					URI objectURI = getHREF(resource, eObj);
					objectURI = deresolve(objectURI);
					return objectURI.toString();
				}
			}
			
			return super.getHREF(obj);
		}

		protected URI getHREF(Resource otherResource, EObject obj) {
			if (!(otherResource instanceof CopyingResource)) {
				CopyingResource copyingResource = (CopyingResource) getResourcesMap()
					.get(otherResource);
				if (copyingResource != null) {
					otherResource = copyingResource;
				}
			}
			
			return super.getHREF(otherResource, obj);
		}
	};
	
	/**
	 * Save implementation for the CopyingResource.
	 */
	public class CopyingSave extends XMISaveImpl {
		
		public CopyingSave(XMLHelper helper) {
			super(helper);
		}
		
		public CopyingSave(Map options, XMLHelper helper, String encoding) {
			super(options, helper, encoding);
		}

		public CopyingSave(Map options, XMLHelper helper, String encoding,
				String xmlVersion) {
			super(options, helper, encoding, xmlVersion);
		}

		/**
		 * @@see org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl#sameDocMany(org.eclipse.emf.ecore.EObject,
		 *      org.eclipse.emf.ecore.EStructuralFeature)
		 */
		protected int sameDocMany(EObject o, EStructuralFeature f) {
			InternalEList values = (InternalEList) helper.getValue(o, f);
			if (values.isEmpty()) {
				return SKIP;
			}

			for (Iterator i = values.basicIterator(); i.hasNext();) {
				EObject value = (EObject) i.next();
				if (value.eIsProxy() || (isInResource(value) == false)) {
					return CROSS_DOC;
				}
			}

			return SAME_DOC;
		}

		/**
		 * @@see org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl#sameDocSingle(org.eclipse.emf.ecore.EObject,
		 *      org.eclipse.emf.ecore.EStructuralFeature)
		 */
		protected int sameDocSingle(EObject o, EStructuralFeature f) {
			EObject value = (EObject) helper.getValue(o, f);
			if (value == null) {
				return SKIP;
			} else if (value.eIsProxy()) {
				return CROSS_DOC;
			} else {
				return (isInResource(value)) ? SAME_DOC
					: CROSS_DOC;
			}
		}

	};
}@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@a325 11

			String qName = EMFCoreUtil.getQualifiedName(obj, true);
			if (qName.length() > 0) {
				StringBuffer buffer = new StringBuffer(otherResource
					.getURIFragment(obj));
				buffer.append(EMFCoreConstants.FRAGMENT_SEPARATOR);
				buffer.append(Util.encodeQualifiedName(qName));
				buffer.append(EMFCoreConstants.FRAGMENT_SEPARATOR);
				return otherResource.getURI().appendFragment(
					buffer.toString());
			}
@


1.7
log
@[139049], gmf_head, contributed  by cdamus, 060425, Runtime EMF API must be aware of cross-resource containment
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2005 IBM Corporation and others.
a37 1
import org.eclipse.gmf.runtime.emf.core.resources.GMFResource;
d49 2
d52 3
a54 5
	private CopyingResourceSet mslCopyingResourceSet;

	public CopyingResource(XMLResource mslResource, URI uri,
			CopyingResourceSet mslCopyingResourceSet) {
		this(mslResource, uri, mslCopyingResourceSet, true);
d57 2
a58 2
	public CopyingResource(XMLResource mslResource, URI uri,
			CopyingResourceSet mslCopyingResourceSet, boolean regenerateIds) {
d60 3
a62 3
		this.xmlResource = mslResource;
		this.mslCopyingResourceSet = mslCopyingResourceSet;
		setEncoding(mslResource.getEncoding());
d65 3
a67 3
		getDefaultSaveOptions().putAll(mslResource.getDefaultSaveOptions());
		mslCopyingResourceSet.getResources().add(this);
		mslCopyingResourceSet.getResourcesMap().put(mslResource, this);
d81 1
a81 1
		Iterator it = xmlResource.getAllContents();
d90 1
a90 1
				"Can't call load on MSLCopyingResource resource"));//$NON-NLS-1$
d95 1
a95 66
		return new XMIHelperImpl(this) {

			/**
			 * @@see org.eclipse.emf.ecore.xmi.XMLHelper#deresolve(org.eclipse.emf.common.util.URI)
			 */
			public URI deresolve(URI anUri) {

				// if this both target and container are within a platform resource and
				// projects
				// or plugins are different then do not deresolve.
				if (((EMFCoreConstants.PLATFORM_SCHEME.equals(anUri.scheme())) && (EMFCoreConstants.PLATFORM_SCHEME
					.equals(resourceURI.scheme())))
					&& ((anUri.segmentCount() > 2) && (resourceURI.segmentCount() > 2))
					&& ((!anUri.segments()[0].equals(resourceURI.segments()[0])) || (!anUri
						.segments()[1].equals(resourceURI.segments()[1]))))
					return anUri;

				return super.deresolve(anUri);
			}

			/*
			 * (non-Javadoc)
			 * 
			 * @@see org.eclipse.emf.ecore.xmi.impl.XMLHelperImpl#getHREF(org.eclipse.emf.ecore.EObject)
			 */
			public String getHREF(EObject obj) {
				EObject eObj = obj;
				
				if (obj.eIsProxy()) {
					eObj = EcoreUtil.resolve(obj, xmlResource);
					if (eObj == null) {
						eObj = null;
					}
				}
				
				if ((eObj != null) && (eObj.eResource() != null)) {
					URI objectURI = getHREF(eObj.eResource(), eObj);
					objectURI = deresolve(objectURI);
					return objectURI.toString();
				}
				return super.getHREF(obj);
			}

			protected URI getHREF(Resource otherResource, EObject obj) {
				if ((otherResource instanceof CopyingResource) == false) {
					CopyingResource copyingResource = (CopyingResource) getResourcesMap()
						.get(otherResource);
					if (copyingResource != null) {
						otherResource = copyingResource;
					}
				}
				if (otherResource instanceof GMFResource) {
					String qName = EMFCoreUtil.getQualifiedName(obj, true);
					if (qName.length() > 0) {
						StringBuffer buffer = new StringBuffer(otherResource
							.getURIFragment(obj));
						buffer.append(EMFCoreConstants.FRAGMENT_SEPARATOR);
						buffer.append(Util.encodeQualifiedName(qName));
						return otherResource.getURI().appendFragment(
							buffer.toString());
					}
				}
				
				return super.getHREF(otherResource, obj);
			}
		};
d127 1
a127 1
				"Can't call load on MSLCopyingResource resource"));//$NON-NLS-1$
d131 1
a131 39
		return new XMISaveImpl(createXMLHelper()) {

			/**
			 * @@see org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl#sameDocMany(org.eclipse.emf.ecore.EObject,
			 *      org.eclipse.emf.ecore.EStructuralFeature)
			 */
			protected int sameDocMany(EObject o, EStructuralFeature f) {
				InternalEList values = (InternalEList) helper.getValue(o, f);
				if (values.isEmpty()) {
					return SKIP;
				}

				for (Iterator i = values.basicIterator(); i.hasNext();) {
					EObject value = (EObject) i.next();
					if (value.eIsProxy() || (isInResource(value) == false)) {
						return CROSS_DOC;
					}
				}

				return SAME_DOC;
			}

			/**
			 * @@see org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl#sameDocSingle(org.eclipse.emf.ecore.EObject,
			 *      org.eclipse.emf.ecore.EStructuralFeature)
			 */
			protected int sameDocSingle(EObject o, EStructuralFeature f) {
				EObject value = (EObject) helper.getValue(o, f);
				if (value == null) {
					return SKIP;
				} else if (value.eIsProxy()) {
					return CROSS_DOC;
				} else {
					return (isInResource(value)) ? SAME_DOC
						: CROSS_DOC;
				}
			}

		};
d139 1
a139 1
			if (((InternalEObject) eObject).eDirectResource() == xmlResource) {
d150 1
a150 1
		return xmlResource.getContents();
d172 1
a172 1
		EObject eObj = xmlResource.getEObject(id);
d180 1
a180 1
	 * @@return Returns the mslCopyingResourceSet.
d183 1
a183 1
		return mslCopyingResourceSet;
d219 1
a219 1
		return xmlResource.getEObjectToExtensionMap();
d236 1
a236 1
		for (Iterator iter = xmlResource.getAllContents(); iter.hasNext(); ) {
d249 148
@


1.7.2.1
log
@[155548] gmf_R1_0_maintenance ldamus 060907 Problems with CopyingResource
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
d38 1
a49 2
	
	private CopyingResourceSet copyingResourceSet;
d51 5
a55 3
	public CopyingResource(XMLResource resource, URI uri,
			CopyingResourceSet copyingResourceSet) {
		this(resource, uri, copyingResourceSet, true);
d58 2
a59 2
	public CopyingResource(XMLResource resource, URI uri,
			CopyingResourceSet copyingResourceSet, boolean regenerateIds) {
d61 3
a63 3
		this.xmlResource = resource;
		this.copyingResourceSet = copyingResourceSet;
		setEncoding(resource.getEncoding());
d66 3
a68 3
		getDefaultSaveOptions().putAll(resource.getDefaultSaveOptions());
		copyingResourceSet.getResources().add(this);
		copyingResourceSet.getResourcesMap().put(resource, this);
d82 1
a82 1
		Iterator it = getXMLResource().getAllContents();
d91 1
a91 1
				"Can't call load on CopyingResource resource"));//$NON-NLS-1$
d96 66
a161 1
		return new CopyingHelper(this);
d193 1
a193 1
				"Can't call load on CopyingResource resource"));//$NON-NLS-1$
d197 39
a235 1
		return new CopyingSave(createXMLHelper());
d243 1
a243 1
			if (((InternalEObject) eObject).eDirectResource() == getXMLResource()) {
d254 1
a254 1
		return getXMLResource().getContents();
d276 1
a276 1
		EObject eObj = getXMLResource().getEObject(id);
d284 1
a284 1
	 * @@return Returns the CopyingResourceSet.
d287 1
a287 1
		return copyingResourceSet;
d323 1
a323 1
		return getXMLResource().getEObjectToExtensionMap();
d340 1
a340 1
		for (Iterator iter = getXMLResource().getAllContents(); iter.hasNext(); ) {
a352 148
	
	/**
	 * Gets the XML resource that contains the model content to be copied.
	 * 
	 * @@return the XML resource
	 */
	protected XMLResource getXMLResource() {
		return xmlResource;
	}
	
	/**
	 * Helper implementation for the CopyingResource.
	 */
	protected class CopyingHelper extends XMIHelperImpl {
		
		public CopyingHelper() {
			super();
		}
		  
		public CopyingHelper(XMLResource resource) {
		    super(resource);
		}

		/**
		 * @@see org.eclipse.emf.ecore.xmi.XMLHelper#deresolve(org.eclipse.emf.common.util.URI)
		 */
		public URI deresolve(URI anUri) {

			// if this both target and container are within a platform resource and
			// projects
			// or plugins are different then do not deresolve.
			if (((EMFCoreConstants.PLATFORM_SCHEME.equals(anUri.scheme())) && (EMFCoreConstants.PLATFORM_SCHEME
				.equals(resourceURI.scheme())))
				&& ((anUri.segmentCount() > 2) && (resourceURI.segmentCount() > 2))
				&& ((!anUri.segments()[0].equals(resourceURI.segments()[0])) || (!anUri
					.segments()[1].equals(resourceURI.segments()[1]))))
				return anUri;

			return super.deresolve(anUri);
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @@see org.eclipse.emf.ecore.xmi.impl.XMLHelperImpl#getHREF(org.eclipse.emf.ecore.EObject)
		 */
		public String getHREF(EObject obj) {
			EObject eObj = obj;
			
			if (obj.eIsProxy()) {
				eObj = EcoreUtil.resolve(obj, getXMLResource());
				if (eObj == obj) {
					// use super.getHREF() if we can't resolve the proxy
					eObj = null;
				}
			}
			
			if (eObj != null) {
				Resource resource = eObj.eResource();
				if (resource != null) {
					URI objectURI = getHREF(resource, eObj);
					objectURI = deresolve(objectURI);
					return objectURI.toString();
				}
			}
			
			return super.getHREF(obj);
		}

		protected URI getHREF(Resource otherResource, EObject obj) {
			if (!(otherResource instanceof CopyingResource)) {
				CopyingResource copyingResource = (CopyingResource) getResourcesMap()
					.get(otherResource);
				if (copyingResource != null) {
					otherResource = copyingResource;
				}
			}

			String qName = EMFCoreUtil.getQualifiedName(obj, true);
			if (qName.length() > 0) {
				StringBuffer buffer = new StringBuffer(otherResource
					.getURIFragment(obj));
				buffer.append(EMFCoreConstants.FRAGMENT_SEPARATOR);
				buffer.append(Util.encodeQualifiedName(qName));
				buffer.append(EMFCoreConstants.FRAGMENT_SEPARATOR);
				return otherResource.getURI().appendFragment(
					buffer.toString());
			}
			
			return super.getHREF(otherResource, obj);
		}
	};
	
	/**
	 * Save implementation for the CopyingResource.
	 */
	public class CopyingSave extends XMISaveImpl {
		
		public CopyingSave(XMLHelper helper) {
			super(helper);
		}
		
		public CopyingSave(Map options, XMLHelper helper, String encoding) {
			super(options, helper, encoding);
		}

		public CopyingSave(Map options, XMLHelper helper, String encoding,
				String xmlVersion) {
			super(options, helper, encoding, xmlVersion);
		}

		/**
		 * @@see org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl#sameDocMany(org.eclipse.emf.ecore.EObject,
		 *      org.eclipse.emf.ecore.EStructuralFeature)
		 */
		protected int sameDocMany(EObject o, EStructuralFeature f) {
			InternalEList values = (InternalEList) helper.getValue(o, f);
			if (values.isEmpty()) {
				return SKIP;
			}

			for (Iterator i = values.basicIterator(); i.hasNext();) {
				EObject value = (EObject) i.next();
				if (value.eIsProxy() || (isInResource(value) == false)) {
					return CROSS_DOC;
				}
			}

			return SAME_DOC;
		}

		/**
		 * @@see org.eclipse.emf.ecore.xmi.impl.XMLSaveImpl#sameDocSingle(org.eclipse.emf.ecore.EObject,
		 *      org.eclipse.emf.ecore.EStructuralFeature)
		 */
		protected int sameDocSingle(EObject o, EStructuralFeature f) {
			EObject value = (EObject) helper.getValue(o, f);
			if (value == null) {
				return SKIP;
			} else if (value.eIsProxy()) {
				return CROSS_DOC;
			} else {
				return (isInResource(value)) ? SAME_DOC
					: CROSS_DOC;
			}
		}

	};
@


1.7.2.2
log
@[162200] gmf_head gmf_R1_0_maintenance crevells 061122 CopyingResource blindly appends URI fragment queries
Contributed by: David Cummings
@
text
@d326 11
@


1.6
log
@[137063], gmf_head, contributed  by cdamus, 060425, GMFResource's abort on error load option is internal API
@
text
@d80 2
d239 12
a250 1
		return (eObject.eResource() == xmlResource);
d336 4
d341 10
a350 3
			EObject eObject = (EObject)iter.next();
			getEObjectToIDMap().put(eObject, xmlResource.getID(eObject));
			getIDToEObjectMap().put(xmlResource.getID(eObject), eObject);
@


1.5
log
@[122234] gmf_head cbmcgee 060224 MSL Editor:  bug in MSLSave.Escape.convert(String input) - escape strings overwrite input
@
text
@d38 1
a38 1
import org.eclipse.gmf.runtime.emf.core.internal.resources.GMFResource;
@


1.4
log
@[121508] gmf_head cdamus 060208 Refactor MSL using the new transaction API
@
text
@d34 1
a38 1
import org.eclipse.gmf.runtime.emf.core.internal.resources.GMFSave;
d195 1
a195 1
		return new GMFSave(createXMLHelper()) {
@


1.3
log
@Bugzilla 110318 gmf_head cvogt 051012 Compiler warning count should be 0 - runtime diagram model services components
@
text
@a33 1

d35 7
a41 9
import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;
import org.eclipse.gmf.runtime.emf.core.internal.domain.MSLEditingDomain;
import org.eclipse.gmf.runtime.emf.core.internal.plugin.MSLDebugOptions;
import org.eclipse.gmf.runtime.emf.core.internal.plugin.MSLPlugin;
import org.eclipse.gmf.runtime.emf.core.internal.resources.MSLResource;
import org.eclipse.gmf.runtime.emf.core.internal.resources.MSLSave;
import org.eclipse.gmf.runtime.emf.core.internal.util.MSLConstants;
import org.eclipse.gmf.runtime.emf.core.internal.util.MSLUtil;
import org.eclipse.gmf.runtime.emf.core.util.EObjectUtil;
d104 1
a104 1
				if (((MSLConstants.PLATFORM_SCHEME.equals(anUri.scheme())) && (MSLConstants.PLATFORM_SCHEME
d120 9
a128 2
				EObject eObj = MSLUtil.resolve((MSLEditingDomain)MEditingDomain.getEditingDomain(xmlResource),
					obj, true);
d145 2
a146 2
				if (otherResource instanceof MSLResource) {
					String qName = EObjectUtil.getQName(obj, true);
d150 2
a151 2
						buffer.append(MSLConstants.FRAGMENT_SEPARATOR);
						buffer.append(MSLUtil.encodeQName(qName));
d175 2
a176 2
		Trace.throwing(MSLPlugin.getDefault(),
			MSLDebugOptions.EXCEPTIONS_THROWING, getClass(), methodName, ex);
d195 1
a195 1
		return new MSLSave(createXMLHelper()) {
d325 2
a326 2
			getEObjectToIDMap().put(eObject, EObjectUtil.getID(eObject));
			getIDToEObjectMap().put(EObjectUtil.getID(eObject), eObject);
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d259 1
a259 1
		EObject eObj = (EObject) xmlResource.getIDToEObjectMap().get(id);
d319 5
a323 2
		getEObjectToIDMap().putAll(xmlResource.getEObjectToIDMap());
		getIDToEObjectMap().putAll(xmlResource.getIDToEObjectMap());
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

