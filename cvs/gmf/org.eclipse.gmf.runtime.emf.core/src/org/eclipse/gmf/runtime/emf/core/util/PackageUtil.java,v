head	1.2;
access;
symbols
	v20081020-0700:1.2
	v20080722-1827:1.2
	v20080716-1600:1.2
	v20080716-1642:1.2
	R2_1_maintenance:1.2.0.4
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080425-1959:1.2
	v20080407-0930:1.2
	v20080404-1111:1.2
	v20080401-1425:1.2
	v20080222-1200:1.2
	v20080215-1500:1.2
	v20080201-2010:1.2
	v20080201-0201:1.2
	v20080114-2222:1.2
	v20080114-1111:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	RC3_20:1.2
	v20070601-1400:1.2
	v20070330-1300:1.2
	v20070208-1800:1.2
	v20070105-1200:1.1.2.1
	v20070103-0300:1.2
	M4_20:1.2
	v20061218-1500:1.1.2.1
	v20061214-0000:1.2
	M3_20:1.2
	v20061013-1330:1.2
	v20060919-0800:1.1.2.1
	M1_20:1.1
	v20060831-1500:1.1
	v20060728-0500:1.1
	v20060721-1130:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060616-1200:1.1
	v20060531-1730:1.1
	v20060530-1930:1.1
	v20060526-1200:1.1
	v20060519-0800:1.1
	I20060505-1400:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1
	I20060216-1945:1.1
	I20060210-1715:1.1
	I20060209-1815:1.1;
locks; strict;
comment	@# @;


1.2
date	2006.10.03.15.05.22;	author ahunter;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.08.14.52.11;	author ldamus;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.09.13.16.46.17;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.2
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.core.util;

import java.lang.ref.WeakReference;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.gmf.runtime.emf.core.internal.util.MetamodelManager;
import org.eclipse.gmf.runtime.emf.core.internal.util.Util;

/**
 * Some utility functions that work at the meta-class level.
 * 
 * @@author rafikj
 */
public class PackageUtil {
	/**
	 * Mapping of {@@link EClass} ==&gt; name {@@link EAttribute}.  Use a weak
	 * map to allow reclamation of dynamically-generated Ecore models; in order
	 * for this to work, the keys are also weak refs.
	 */
	private static final Map NAME_ATTRIBUTES = new java.util.WeakHashMap();
	
	/**
	 * Mapping of {@@link EClass} ==&gt; qualified name {@@link EAttribute}.
	 * Use a weak map to allow reclamation of dynamically-generated Ecore
	 * models; in order for this to work, the keys are also weak refs.
	 */
	private static final Map QNAME_ATTRIBUTES = new java.util.WeakHashMap();
	
	/**
	 * Gets the ID of a meta-model element. The ID of a meta-model element is
	 * the fully qualified name of the element going up to the root EPackage.
	 * 
	 * @@param element
	 *            The Meta-model element.
	 * @@return The ID.
	 */
	public static String getID(ENamedElement element) {
		return MetamodelManager.getID(element);
	}

	/**
	 * Gets meta-model element by ID.
	 * 
	 * @@param id
	 *            The element ID.
	 * @@return The meta-model element.
	 */
	public static ENamedElement getElement(String id) {
		return MetamodelManager.getElement(id);
	}

	/**
	 * Gets the localized name of a meta-model element. The name will not
	 * contain spaces.
	 * 
	 * @@param element
	 *            The meta-model element.
	 * @@return The localized name of the meta-model element.
	 */
	public static String getLocalizedName(ENamedElement element) {
		return MetamodelManager.getLocalName(element);
	}

	/**
	 * Gets the localized display name of a meta-model element. Display name may
	 * contain spaces.
	 * <p>
	 * NOTE: This should be used to make model changes (e.g. name an element).
	 * When displaying strings in the UI (menus, dialogs, etc.) get the string
	 * from one of our resource managers.
	 * </p>
	 * 
	 * @@param element
	 *            The meta-model element.
	 * @@return The localized name of the meta-model element.
	 */
	public static String getDisplayName(ENamedElement element) {
		return MetamodelManager.getDisplayName(element);
	}

	/**
	 * Checks if a container <code>EClass</code> can contain another
	 * <code>EClass</code>. The check can be recursive.
	 * 
	 * @@param class1
	 *            The container <code>EClass</code>.
	 * @@param class2
	 *            The contained <code>EClass</code>.
	 * @@param recursive
	 *            True if recursive.
	 * @@return True if an object can contain other objects of a given type.
	 */
	public static boolean canContain(EClass class1, EClass class2,
			boolean recursive) {
		return Util.canContain(class1, class2, recursive ? (new HashSet())
			: null);
	}

	/**
	 * Checks if a container <code>EClass</code> can contain another
	 * <code>EClass</code> at a given containment reference. The check can be
	 * recursive.
	 * 
	 * @@param class1
	 *            The container <code>EClass</code>.
	 * @@param reference
	 *            The reference.
	 * @@param class2
	 *            The contained <code>EClass</code>.
	 * @@param recursive
	 *            True if recursive.
	 * @@return True if an object can contain other objects of a given type.
	 */
	public static boolean canContain(EClass class1, EReference reference,
			EClass class2, boolean recursive) {

		if ((reference.isContainment())
			&& (class1.getEAllReferences().contains(reference))) {

			EClass eType = (EClass) reference.getEType();

			if ((eType.equals(class2)) || (eType.isSuperTypeOf(class2))) {

				return true;
			}
		}

		if (recursive) {

			if (reference.isContainment()) {

				EClass eType = (EClass) reference.getEType();

				if (canContain(eType, class2, true))
					return true;
			}
		}

		return false;
	}

	/**
	 * Checks if a container <code>EClass</code> can reference another
	 * <code>EClass</code>.
	 * 
	 * @@param class1
	 *            The referencer <code>EClass</code>.
	 * @@param class2
	 *            The referenced <code>EClass</code>.
	 * @@return True if an object can contain other objects of a given type.
	 */
	public static boolean canReference(EClass class1, EClass class2) {

		Iterator i = class1.getEAllReferences().iterator();

		while (i.hasNext()) {

			EReference reference = (EReference) i.next();

			if (!reference.isContainment()) {

				EClass eType = (EClass) reference.getEType();

				if ((eType.equals(class2)) || (eType.isSuperTypeOf(class2))) {

					return true;
				}
			}
		}

		return false;
	}

	/**
	 * Checks if a container <code>EClass</code> can reference another
	 * <code>EClass</code> at a given non-containment reference.
	 * 
	 * @@param class1
	 *            The referencer <code>EClass</code>.
	 * @@param reference
	 *            The reference.
	 * @@param class2
	 *            The referenced <code>EClass</code>.
	 * @@return True if an object can contain other objects of a given type.
	 */
	public static boolean canReference(EClass class1, EReference reference,
			EClass class2) {

		if ((!reference.isContainment())
			&& (class1.getEAllReferences().contains(reference))) {

			EClass eType = (EClass) reference.getEType();

			if ((eType.equals(class2)) || (eType.isSuperTypeOf(class2))) {

				return true;
			}
		}

		return false;
	}

	/**
	 * Finds a feature that can contain an object of type eClass.
	 * 
	 * @@param container
	 *            The container <code>EClass</code>.
	 * @@param eClass
	 *            The contained <code>EClass</code>.
	 * @@return The found feature.
	 */
	public static EReference findFeature(EClass container, EClass eClass) {

		Iterator i = container.getEAllReferences().iterator();

		while (i.hasNext()) {

			EReference reference = (EReference) i.next();

			if (canContain(container, reference, eClass, false))
				return reference;
		}

		return null;
	}

	/**
	 * Gets the name attribute of an <code>EClass</code>.
	 * 
	 * @@param eClass
	 *            The <code>EClass</code>.
	 * @@return The name attribute.
	 */
	public static EAttribute getNameAttribute(EClass eClass) {
		
		EAttribute nameAttribute = null;

		// first, try to get the cached attribute
		WeakReference ref = (WeakReference) NAME_ATTRIBUTES.get(eClass);
		if (ref != null) {
			
			nameAttribute = (EAttribute) ref.get();
		} else {

			EStructuralFeature feature = eClass.getEStructuralFeature("name"); //$NON-NLS-1$

			if (feature != null) {

				if (feature instanceof EAttribute) {
					EClassifier type = feature.getEType();

					if (type != null) {

						if (type.getInstanceClass() == String.class)
							nameAttribute = (EAttribute) feature;
					}
				}
			}
			
			// cache the result, whatever it is.  As long as the key (EClass)
			//    isn't GCed, then the value (WeakRef) will remain to indicate
			//    that we have at least cached a null
			NAME_ATTRIBUTES.put(eClass, new WeakReference(nameAttribute));
		}

		return nameAttribute;
	}

	/**
	 * Gets the qualified name attribute of an <code>EClass</code>.
	 * 
	 * @@param eClass
	 *            The <code>EClass</code>.
	 * @@return The qualified name attribute.
	 */
	public static EAttribute getQualifiedNameAttribute(EClass eClass) {

		EAttribute nameAttribute = null;

		// first, try to get the cached attribute
		WeakReference ref = (WeakReference) QNAME_ATTRIBUTES.get(eClass);
		if (ref != null) {
			
			nameAttribute = (EAttribute) ref.get();
		} else  {

			EStructuralFeature feature = eClass
				.getEStructuralFeature("qualifiedName"); //$NON-NLS-1$

			if (feature != null) {

				if ((feature instanceof EAttribute)
					&& (feature.getEType().getInstanceClass() == String.class))
					nameAttribute = (EAttribute) feature;
			}
			
			// cache the result, whatever it is.  As long as the key (EClass)
			//    isn't GCed, then the value (WeakRef) will remain to indicate
			//    that we have at least cached a null
			QNAME_ATTRIBUTES.put(eClass, new WeakReference(nameAttribute));
		}

		return nameAttribute;
	}

	private PackageUtil() {
		// private
	}
}@


1.1
log
@[121508] gmf_head cdamus 060208 Refactor MSL using the new transaction API
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
@


1.1.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@

