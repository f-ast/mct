head	1.2;
access;
symbols
	v20080813-1520:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.2
date	2006.01.12.14.01.31;	author atikhomirov;	state dead;
branches;
next	1.1;

1.1
date	2006.01.10.20.40.09;	author atikhomirov;	state Exp;
branches;
next	;


desc
@@


1.2
log
@mistakenly added file
@
text
@@@EmfaticAnnotationMap(
	constraints="http://www.eclipse.org/gmf/2005/constraints",
	constraintsMeta="http://www.eclipse.org/gmf/2005/constraints/meta")

@@namespace(uri="http://www.eclipse.org/gmf/2005/mappings", prefix="gmfmap")
package mappings;

import "platform:/resource/org.eclipse.gmf.graphdef/models/gmfgraph.ecore";
import "platform:/resource/org.eclipse.gmf.tooldef/models/tooldef.ecore";


class Mapping {
	!resolve val NodeMapping[+] nodes;
	!resolve val LinkMapping[*] links;
	!resolve val CanvasMapping[1] diagram; // [1] ? 0..1?
	val tooldef.StyleSelector[*] appearanceStyles;

	@@genmodel(documentation="Domain meta-model audit rules definitions")
	val AuditContainer audits;
}

abstract class MappingEntry {
	ref ecore.EClass[?] domainMetaElement;
	op ecore.EClass getDomainContext();
	
	@@genmodel(documentation="Specializes further the domain meta element EClass associated with this mapping and should be evaluated in this EClass context")
	@@constraintsMeta(def="context", ocl="self.getDomainContext()")
	val Constraint domainSpecialization;

	@@genmodel(documentation="Initializer for the domain model element associated with mapping")
	@@constraints(
		ocl="let i : FeatureSeqInitializer = domainInitializer.oclAsType( FeatureSeqInitializer) in i.oclIsUndefined() or i.initializers.feature.eContainingClass->forAll(c|c.isSuperTypeOf(domainMetaElement))"
	)
	@@constraintsMeta(def="context", ocl="self.getDomainContext()")
	val ElementInitializer domainInitializer;

	@@constraints(
		ocl="containmentFeature.oclIsUndefined() or (containmentFeature.containment and containmentFeature.eReferenceType.isSuperTypeOf(domainMetaElement))"
	)
	ref ecore.EReference[?] containmentFeature;

	// ref ecore.EClass drtClass; -> extract to interface NotationInstanceAspect, and use it in CanvasMapping
}

abstract class AbstractNodeMapping extends MappingEntry, MenuOwner, ToolOwner, AppearanceSteward {
	@@constraints(
		ocl="editFeature.oclIsUndefined() or (not domainMetaElement.oclIsUndefined() and editFeature.eContainingClass.isSuperTypeOf(domainMetaElement)) or containmentFeature.eType.oclAsType(ecore::EClass).eAllAttributes->includes(editFeature)"
	)
	ref ecore.EAttribute[?] editFeature;
	
	val ChildNodeMapping[*]#parentNode childMappings;
	
	val CompartmentMapping[*]#parentNodeMapping compartmentMappings;
}

@@genmodel(documentation="Top-level diagram node")
class NodeMapping extends AbstractNodeMapping {
	ref gmfgraph.Node[1] diagramNode;
}

@@genmodel(documentation="Inner element")
class ChildNodeMapping extends AbstractNodeMapping {
	ref gmfgraph.Child[1] diagramNode;

	ref CompartmentMapping[?]#childNodes compartment;

	readonly ref AbstractNodeMapping[1]#childMappings parentNode;
}

class CompartmentMapping {
	readonly ref AbstractNodeMapping[1]#compartmentMappings parentNodeMapping;

	ref gmfgraph.Compartment[1] compartment;
	ref ChildNodeMapping[*]#compartment childNodes;
}

@@genmodel(documentation="Connection element")
class LinkMapping extends MappingEntry, MenuOwner, ToolOwner, AppearanceSteward {
	ref gmfgraph.Connection[1] diagramLink;

	@@constraints(
		ocl="labelEditFeature.oclIsUndefined() or labelEditFeature.eContainingClass.isSuperTypeOf(domainMetaElement)"
	)
	ref ecore.EAttribute[?] labelEditFeature;
	@@genmodel(documentation="By default, same as editFeature, once latter is set")
	@@constraints(
		ocl="labelDisplayFeature.oclIsUndefined() or labelDisplayFeature.eContainingClass.isSuperTypeOf(domainMetaElement)"
	)
	ref ecore.EAttribute[?] labelDisplayFeature;
	@@constraints(
		ocl="domainMetaElement.oclIsUndefined() or sourceMetaFeature.eContainingClass.isSuperTypeOf(domainMetaElement)"
	)
	ref ecore.EStructuralFeature sourceMetaFeature;
	// rename linkMetaFeature to linkTargetMetaReference;
	@@constraints(
		ocl="domainMetaElement.oclIsUndefined() or linkMetaFeature.eContainingClass.isSuperTypeOf(domainMetaElement)"
	)
	ref ecore.EStructuralFeature[1] linkMetaFeature; // XXX EReference? Links only to classes, not to datatypes/enums (i.e. attributes)
	// super.drtClass isSubtypeOf(diagramrt.DiagramLink)
	@@genmodel(documentation="Specifies additional restrictions on link creation")
	val LinkConstraints#linkMapping creationConstraints;
}

class CanvasMapping {
	ref gmfgraph.Canvas[1] diagramCanvas;
	ref ecore.EPackage domainModel;
	ref ecore.EClass domainMetaElement;
	ref tooldef.Palette[?] palette;
	ordered ref tooldef.MainMenu[*] menuContributions;
	ordered ref tooldef.Toolbar[*] toolbarContributions;
	// ref ecore.EPackage drtPackage;
	// super.drtClass isSubtypeOf(diagramrt.DiagramCanvas)
}

//////////////
// Constraints
//

@@genmodel(documentation="Boolean type value expression which is to be evaluated in a context")
@@constraintsMeta(def="Constraint")
class Constraint extends ValueExpression {
}

@@genmodel(documentation="Groups constraints on the link source and target end")
class LinkConstraints {

  @@genmodel(documentation="References the link mapping restricted by these constraints")
  readonly ref LinkMapping[1]#creationConstraints linkMapping;

  @@genmodel(documentation="Restriction enforced by the the source end, may reference variable 'oppositeEnd' pointing to targetEnd domainMetaElement instance if available.")
  @@constraintsMeta(def="context", ocl="if linkMapping.domainMetaElement.oclIsUndefined() then linkMapping.linkMetaFeature.eContainingClass else linkMapping.containmentFeature.eContainingClass endif")
  @@constraintsMeta(def="variable", name="oppositeEnd", type.ocl="linkMapping.linkMetaFeature.eType")
  val Constraint sourceEnd;

  @@genmodel(documentation="Restriction enforced by the the target end, may reference variable 'oppositeEnd' pointing to sourceEnd domainMetaElement instance.")
  @@constraintsMeta(def="context", ocl="linkMapping.linkMetaFeature.eType.oclAsType(ecore::EClass)")
  @@constraintsMeta(def="variable", name="oppositeEnd", type.ocl="if linkMapping.domainMetaElement.oclIsUndefined() then linkMapping.linkMetaFeature.eContainingClass else linkMapping.containmentFeature.eContainingClass endif")
  val Constraint targetEnd;
}

@@constraintsMeta(def="ValueSpec")
@@genmodel(documentation="Expression as a textual statement which results in a value when evaluated in a context")
class ValueExpression {
	@@genmodel(documentation="The text of the expression")
	@@constraintsMeta(def="body")
	attr String[1] body;
	@@genmodel(documentation="Specifies the language in which the expression is stated")
	@@constraintsMeta(def="lang")
	attr String language = "ocl";
}
@@genmodel(documentation="Base class for initializers of domain model elements")
interface ElementInitializer {
}

@@genmodel(documentation="Feature sequence initializer")
class FeatureSeqInitializer extends ElementInitializer {
	@@genmodel(documentation="Value specifications as initializers for individual features which should be initialized in the order given by this list")
	val FeatureValueSpec[+] initializers;
}

@@genmodel(documentation="Value specification associated with a specific feature")
@@constraintsMeta(def="ValueSpec")
class FeatureValueSpec extends ValueExpression {
	@@genmodel(documentation="Denotes the feature for which this value expression is specified. Its containing EClass is the context for evaluation.")
	@@constraintsMeta(def="type")
	ref ecore.EStructuralFeature[1] feature;
}

/////////////////////////
// Tooling Aspects/Facets
//

interface MenuOwner {
	ref tooldef.ContextMenu contextMenu;
}

interface ToolOwner {
	// constraint: canvasMapping.palette contains this tool
	@@genmodel(documentation="Way to create this element")
	ref tooldef.AbstractTool tool;
}

interface AppearanceSteward {
	ref tooldef.StyleSelector appearanceStyle;
}

/////////
// Audits
//

@@genmodel(documentation="Container for audit rules representing a hierarchical organization of audits in the constraint category hierarchy of emft.validation framework")
class AuditContainer {
	@@genmodel(documentation="Identifier which is unique within the scope of its parent container.")
	attr String[1] ~id;

	@@genmodel(documentation="A human readable name for the category of audits organized in this container")
	attr String name;
	@@genmodel(documentation="The detailed description of this audit container")
	attr String description;

	ref AuditContainer#childContainers parentContainer;

	@@genmodel(documentation="The audit rules organized in this container")
	val AuditRule[*]#container audits;
	val AuditContainer[*]#parentContainer childContainers;
}

class AuditRule {
	@@genmodel(documentation="Unique identifier of this audit rule")
	attr String[1] ~id;

	@@genmodel(documentation="A boolean type condition which if not satisfied indicates this audit rule violation. It is evaluated in the context of the target")
	@@constraintsMeta(def="context", ocl="target")
	val Constraint[1] rule;

	@@genmodel(documentation="Model class to which this rules is targeted and is the context for rule expression evaluation")
	ref EClass[1] target;

	@@genmodel(documentation="A human readable name")
	attr String name;

	@@genmodel(documentation="Describes the severity of this audit rule violation")
	attr Severity severity = "ERROR";

	@@genmodel(documentation="Indicates if this audit should be evaluated also in Live mode. If 'false', only Batch mode is applicable")
	attr boolean useInLiveMode = false;

	@@genmodel(documentation="The text message to be reported in case of this audit violation")
	attr String message;

	@@genmodel(documentation="The detailed description of this audit semantics")
	attr String description;

	@@genmodel(documentation="The containing audit container of this audit rule")
	ref AuditContainer[1]#audits container;
}

enum Severity {
	INFO = 0;
	WARNING = 1;
	ERROR = 2;
}@


1.1
log
@#114197 - tooling definition in place
@
text
@@

