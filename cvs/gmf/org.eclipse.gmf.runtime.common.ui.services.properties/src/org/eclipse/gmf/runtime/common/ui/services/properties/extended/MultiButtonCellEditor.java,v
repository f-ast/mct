head	1.3;
access;
symbols
	v20081020-0700:1.3
	v20080722-1827:1.3
	R2_1_maintenance:1.3.0.4
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080425-1959:1.3
	v20080222-1200:1.3
	v20071124-0000:1.3
	v20071108-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	RC3_20:1.3
	v20070601-1400:1.3
	v20070330-1300:1.3
	M4_20:1.3
	v20061214-0000:1.3
	M3_20:1.3
	v20061013-1330:1.3
	v20060919-0800:1.2.2.1
	M1_20:1.2
	v20060824-1600:1.2.2.1
	v20060817-1500:1.2.2.1
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1200:1.2
	v20060531-1730:1.2
	v20060526-1200:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.3
date	2006.10.03.15.01.54;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.26.40;	author sshaw;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.08.30.03.16.18;	author sshaw;	state Exp;
branches;
next	;

1.2.2.1
date	2006.08.17.15.46.22;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.3
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.ui.services.properties.extended;

import java.text.MessageFormat;
import java.util.ArrayList;

import org.eclipse.jface.viewers.CellEditor;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.KeyAdapter;
import org.eclipse.swt.events.KeyEvent;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Layout;
import org.eclipse.swt.widgets.Text;

/**
 * Cell editor that provides for a read-only label representation of the value
 * and multiple buttons at the end. The last button receives the focus. The
 * subclasses have to override the initButtons() method. The implementation of
 * that method should only make calls to the method addButton() to initialize
 * the desired buttons.
 * 
 * @@author dmisic
 */
public abstract class MultiButtonCellEditor
	extends CellEditor {

	/**
	 * The cell editor control itself
	 */
	private Composite editor;

	/**
	 * Font used by all controls
	 */
	private Font font;

	/**
	 * The label part of the editor
	 */
	private Control label;

	/**
	 * Array of the editor's buttons
	 */
	private ArrayList buttonList;

	/**
	 * The value of the cell editor; initially null
	 */
	private Object value = null;

	/**
	 * Internal layout manager for multi button cell editors
	 */
	private class MultiButtonCellLayout
		extends Layout {

		/**
		 * @@see org.eclipse.swt.widgets.Layout#computeSize(org.eclipse.swt.widgets.Composite,
		 *      int, int, boolean)
		 */
		protected Point computeSize(Composite composite, int wHint, int hHint,
				boolean flushCache) {

			// check the hints
			if (wHint != SWT.DEFAULT && hHint != SWT.DEFAULT) {
				return new Point(wHint, hHint);
			}

			// calculate size of the buttons area
			int height = 0;
			int sumWidth = 0;
			int count = buttonList.size();
			for (int i = 0; i < count; i++) {
				Point size = ((Button) buttonList.get(i)).computeSize(
					SWT.DEFAULT, SWT.DEFAULT, flushCache);
				sumWidth += size.x;
				height = Math.max(height, size.y);
			}

			// label size
			Point labelSize = label.computeSize(SWT.DEFAULT, SWT.DEFAULT,
				flushCache);

			return new Point(sumWidth, Math.max(labelSize.y, height));
		}

		/**
		 * @@see org.eclipse.swt.widgets.Layout#layout(org.eclipse.swt.widgets.Composite,
		 *      boolean)
		 */
		protected void layout(Composite composite, boolean flushCache) {
			Rectangle bounds = editor.getClientArea();
			int count = buttonList.size();
			int sumWidth = 0;
			int[] widthArray = new int[count];
			int start = 0;

			// calculate the aggregate width of the buttons
			for (int i = 0; i < count; i++) {
				Point size = ((Button) buttonList.get(i)).computeSize(
					SWT.DEFAULT, SWT.DEFAULT, flushCache);
				sumWidth += size.x;
				widthArray[i] = size.x;
			}

			// set the size for the label
			if (label != null) {
				label.setBounds(0, 0, bounds.width - sumWidth, bounds.height);
				start = bounds.width - sumWidth;
			}

			// set the size for the buttons
			for (int i = 0; i < count; i++) {
				Button button = (Button) buttonList.get(i);
				button.setBounds(start, 0, widthArray[i], bounds.height);
				start += widthArray[i];
			}
		}
	}

	/**
	 * @@param parent
	 *            The parent control
	 */
	public MultiButtonCellEditor(Composite parent) {
		this(parent, SWT.NONE);
	}

	/**
	 * @@param parent
	 *            The parent control
	 * @@param style
	 *            The style bits
	 */
	public MultiButtonCellEditor(Composite parent, int style) {
		super(parent, style);
	}

	/**
	 * @@see org.eclipse.jface.viewers.CellEditor#createControl(org.eclipse.swt.widgets.Composite)
	 */
	protected Control createControl(Composite parent) {
		buttonList = new ArrayList();
		font = parent.getFont();
		Color bg = parent.getBackground();

		// create the cell editor
		editor = new Composite(parent, getStyle());
		editor.setFont(font);
		editor.setBackground(bg);
		editor.setLayout(new MultiButtonCellLayout());

		// create the label
        if (isModifiable()) {
            label = (new Text(editor, SWT.LEFT));
        } else {
            label = (new Label(editor, SWT.LEFT));
        }
		label.setFont(font);
		label.setBackground(bg);
		updateLabel(value);

		// init the buttons (there must be at least one)
		initButtons();
		assert buttonList.size() > 0 : "button list size must > 0"; //$NON-NLS-1$

		setValueValid(true);

		return editor;
	}

    /**
     * Determine if the label in the cell editor is modifiable. The default is a
     * read-only label representation of the value.
     * 
     * @@return <code>true</code> if the label is modifiable
     */
    protected boolean isModifiable() {
        return false;
    }
    
	/**
	 * @@see org.eclipse.jface.viewers.CellEditor#doGetValue()
	 */
	protected Object doGetValue() {
		return value;
	}

	/**
	 * This implementations sets focus on the last button
	 * 
	 * @@see org.eclipse.jface.viewers.CellEditor#doSetFocus()
	 */
	protected void doSetFocus() {
		((Button) buttonList.get(buttonList.size() - 1)).setFocus();
	}

	/**
	 * @@see org.eclipse.jface.viewers.CellEditor#doSetValue(java.lang.Object)
	 */
	protected void doSetValue(Object val) {
		this.value = val;
		updateLabel(val);
	}

	/**
	 * Creates and adds the button to the cell editor
	 * 
	 * @@param buttonLabel
	 *            Button label
	 * @@param buttonAction
	 *            The action to be executed when the button is invoked
	 */
	protected void addButton(String buttonLabel,
			final IPropertyAction buttonAction) {

		// create button
		Button button = new Button(editor, SWT.DOWN);
		button.setText(buttonLabel);
		button.setFont(font);

		// selection listener
		button.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {
				Object newValue = buttonAction.execute(editor);
				if (newValue != null) {
					boolean newValidState = isCorrect(newValue);
					if (newValidState) {
						markDirty();
						doSetValue(newValue);
					} else {
						setErrorMessage(MessageFormat.format(getErrorMessage(),
							new Object[] {newValue.toString()}));
					}
					fireApplyEditorValue();
				}
			}
		});

		// key listener
		button.addKeyListener(new KeyAdapter() {

			public void keyReleased(KeyEvent e) {
				if (e.character == '\u001b') { // Escape char
					fireCancelEditor();
				}
			}
		});

		buttonList.add(button);
	}

	/**
	 * Updates the label showing the value. The default implementation converts
	 * the passed object to a string using <code>toString</code> and sets this
	 * as the text of the label widget.
	 * 
	 * @@param val
	 *            The new value
	 */
	protected void updateLabel(Object val) {
		if (label == null)
			return;

		String text = ""; //$NON-NLS-1$
		if (val != null) {
			text = val.toString();
		}
        if (label instanceof Label) {
            ((Label)label).setText(text);
        } else if (label instanceof Text) {
            ((Text)label).setText(text);
        }
	}

	/**
	 * The subclasses have to override this method. The implementation should
	 * only make calls to the method addButton() to initialize the desired
	 * buttons. Note: the implementation of the IPropertyAction's execute method
	 * should return the new value for the editor or null if the value has not
	 * changed.
	 */
	protected abstract void initButtons();

	/**
     * Get the label widget.
	 * @@return the label widget.
	 */
	protected Label getLabel() {
        return (label != null && label instanceof Label) ? (Label) label
            : null;
	}
	
    /**
     * Get the text widget in the case where the label is modifiable.
     * @@return the label widget.
     */
	protected Text getText() {
	    return (label != null && label instanceof Text) ? (Text) label
            : null;
    }
}@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d32 1
d59 1
a59 1
	private Label label;
d174 5
a178 1
		label = new Label(editor, SWT.LEFT);
d192 10
d290 5
a294 1
		label.setText(text);
d307 2
a308 1
	 * @@return Returns the label.
d311 2
a312 1
		return label;
d314 9
@


1.2.2.1
log
@[153988] gmf_R1_0_maintenance ahunter 060817 Need editable label capability in MultiButtonCellEditor
@
text
@a31 1
import org.eclipse.swt.widgets.Text;
d58 1
a58 1
	private Control label;
d173 1
a173 5
        if (isModifiable()) {
            label = (new Text(editor, SWT.LEFT));
        } else {
            label = (new Label(editor, SWT.LEFT));
        }
a186 10
    /**
     * Determine if the label in the cell editor is modifiable. The default is a
     * read-only label representation of the value.
     * 
     * @@return <code>true</code> if the label is modifiable
     */
    protected boolean isModifiable() {
        return false;
    }
    
d275 1
a275 5
        if (label instanceof Label) {
            ((Label)label).setText(text);
        } else if (label instanceof Text) {
            ((Text)label).setText(text);
        }
d288 1
a288 2
     * Get the label widget.
	 * @@return the label widget.
d291 1
a291 2
        return (label != null && label instanceof Label) ? (Label) label
            : null;
a292 9
	
    /**
     * Get the text widget in the case where the label is modifiable.
     * @@return the label widget.
     */
	protected Text getText() {
	    return (label != null && label instanceof Text) ? (Text) label
            : null;
    }
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

