head	1.5;
access;
symbols
	v20081020-0700:1.5
	v20080722-1827:1.5
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080425-1959:1.5
	v20080222-1200:1.5
	v20071124-0000:1.5
	v20071108-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	RC3_20:1.5
	v20070601-1400:1.5
	v20070330-1300:1.5
	M4_20:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061013-1330:1.5
	v20060919-0800:1.4.2.3
	M1_20:1.4
	v20060824-1600:1.4.2.2
	v20060817-1500:1.4.2.1
	v20060721-1130:1.4.2.1
	v20060713-1700:1.4.2.1
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060616-1200:1.4
	v20060531-1730:1.3
	v20060526-1200:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.3
	I20060216-1945:1.3
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.2;
locks; strict;
comment	@# @;


1.5
date	2006.10.03.15.01.54;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.14.20.25.25;	author ahunter;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2005.11.01.18.32.29;	author ldamus;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.26.40;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.18;	author sshaw;	state Exp;
branches;
next	;

1.4.2.1
date	2006.07.13.15.10.08;	author mmostafa;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2006.08.24.19.06.28;	author mmostafa;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2006.09.13.16.41.27;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.5
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.ui.services.properties.extended;

import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.ui.dialogs.PropertiesDialog;
import org.eclipse.gmf.runtime.common.ui.services.properties.PropertiesService;
import org.eclipse.jface.preference.PreferenceManager;
import org.eclipse.jface.preference.PreferenceNode;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.ui.dialogs.PropertyPage;
import org.eclipse.ui.views.properties.IPropertyDescriptor;
import org.eclipse.ui.views.properties.IPropertySource;

/**
 * Cell editor for properties that can be modified via a property page.
 * This cell editor is composed of an elipsis button for editing via
 * a property page.
 * 
 * @@author ldamus
 */
public class PropertyPageCellEditor extends MultiButtonCellEditor {

    /**
	 * My property descriptor
	 */
	private final PropertyPagePropertyDescriptor propertyDescriptor;

	/**
	 * Creates a new property page cell editor parented under the given control.
	 * The cell editor value is <code>null</code> initially, and has no 
	 * validator.
	 *
	 * @@param parent The parent control
	 * @@param descriptor The property descriptor for this cell
	 */
	public PropertyPageCellEditor(
		Composite parent,
		PropertyPagePropertyDescriptor descriptor) {
		this(parent, descriptor, SWT.NONE);
	}

	/**
	 * Creates a new property page cell editor parented under the given control.
	 * The cell editor value is <code>null</code> initially, and has no 
	 * validator.
	 *
	 * @@param parent The parent control
	 * @@param descriptor The property descriptor for this cell
	 * @@param style the style bits
	 */
	public PropertyPageCellEditor(
		Composite parent,
		PropertyPagePropertyDescriptor descriptor,
		int style) {
		super(parent, style);
		propertyDescriptor = descriptor;
	}

	/**
	 * Gets the property descriptor for this cell editor.
	 * 
	 * @@return the property descriptor
	 */
	private PropertyPagePropertyDescriptor getPropertyDescriptor() {
		return propertyDescriptor;
	}

	/**
	 * Opens the {@@link org.eclipse.gmf.runtime.common.ui.dialogs.PropertiesDialog}. Always
	 * returns null. The UI is updated by the model event when the property
	 * is modified by the property dialog.
	 * 
	 * @@see org.eclipse.jface.viewers.DialogCellEditor#openDialogBox(org.eclipse.swt.widgets.Control)
	 */
	protected Object openDialogBox(Control cellEditorWindow) {

		// Invoke the property dialog
		PropertiesDialog dialog =
			new PropertiesDialog(
				getControl().getShell(),
				new PreferenceManager());

		// handle invokation of cell editor from collection editor
		PropertyPagePropertyDescriptor realDescriptor = null;
		if (getValue() instanceof ElementValue) {
			Object element = ((ElementValue) getValue()).getElement();
			if (element instanceof PropertyPagePropertyDescriptor) {
				realDescriptor = (PropertyPagePropertyDescriptor) element;
			}
		}

		List pages = null;
		if (realDescriptor != null) {
			pages = realDescriptor.createPropertyPages();
		} else {
			pages = getPropertyDescriptor().createPropertyPages();
		}

		for (Iterator i = pages.iterator(); i.hasNext();) {
			PropertyPage page = (PropertyPage) i.next();

			// handle invokation of cell editor from collection editor
			if (realDescriptor != null) {
				final IPropertySource source =
					realDescriptor.getPropertySource();
				page.setElement(new IAdaptable() {
					public Object getAdapter(Class adapter) {
						if (adapter.equals(IPropertySource.class)) {
							return source;
						}
						return null;
					}
				});
			}

			dialog.getPreferenceManager().addToRoot(
				new PreferenceNode(StringStatics.BLANK, page));
		}

		dialog.create();
		dialog.open();

		// refresh property for collection editor
		for (Iterator i = pages.iterator(); i.hasNext();) {
			PropertyPage page = (PropertyPage) i.next();
			IAdaptable adaptable = page.getElement();
			if (adaptable != null) {
				IPropertySource source =
					(IPropertySource) adaptable.getAdapter(
						IPropertySource.class);
				if (source instanceof IExtendedPropertySource) {
					Object element =
						((IExtendedPropertySource) source).getElement();

					IPropertySource propertySource =
						PropertiesService.getInstance().getPropertySource(
						
							element);
					assert null != propertySource;

					for (Iterator j =
						Arrays
							.asList(propertySource.getPropertyDescriptors())
							.iterator();
						j.hasNext();
						) {
						IPropertyDescriptor descriptor =
							(IPropertyDescriptor) j.next();
						if (descriptor
							.getId()
							.equals(getPropertyDescriptor().getId())) {
							// apply new value in cell editor
							setValue(
								new ElementValue(
									source,
									propertySource.getPropertyValue(
										descriptor.getId())));
							fireApplyEditorValue();
							break;
						}
					}
				}
			}
		}

		return null;
	}

	/**
	 * Determines if there is text to copy.
	 * 
	 * @@return <code>true</code> if the text selection is not empty, 
	 * <code>false</code>otherwise
     */
	public boolean isCopyEnabled() {
		return false;
	}

	/**
	 * Determines if there is text to cut
	 * 
	 * @@return <code>true</code> if the text selection is not empty, 
	 * <code>false</code>otherwise
     */
	public boolean isCutEnabled() {
		return false;
	}

	/**
	 * Determines if there is text to delete
	 * 
	 * @@return <code>true</code> if the text selection is not empty, 
	 * <code>false</code>otherwise
     */
	public boolean isDeleteEnabled() {
		return false;
	}

	/**
	 * Determines if there is a text widget on which text can be pasted
	 * 
	 * @@return <code>true</code> if the text selection is not empty, 
	 * <code>false</code>otherwise
     */
	public boolean isPasteEnabled() {
		return false;
	}

	/**
	 * Determines if there is a text widget in which text can be saved
	 * 
	 * @@return <code>true</code> if the text widget is not disposed, 
	 * <code>false</code>otherwise
     */
	public boolean isSaveAllEnabled() {
        return false;
	}

	/**
	 * Determines if there is text to be selected.
	 * 
	 * @@return <code>true</code> if select all is possible,
	 *  <code>false</code> otherwise
     */
	public boolean isSelectAllEnabled() {
        return false;
	}

	/**
	 * Copies the selected text
     */
	public void performCopy() {
        // default implementation do nothing
	}

	/**
	 * Cuts the selected text to the clipboard. 
     */
	public void performCut() {
        /* not suppoerted */
	}

	/**
	 * Deletes the selected text or, if there is no selection,
	 * the character next character from the current position. 
     */
	public void performDelete() {
        /* not suppoerted */
	}

	/**
	 * Pastes the the clipboard contents over the selected text. 
     */
	public void performPaste() {
        /* not suppoerted */
	}

	/**
	 * Selects all of the text
     */
	public void performSelectAll() {
        /* not suppoerted */
	}
	
	/**
	 * Getter method for value
	 * @@return the value of this cell editor
     */
	protected Object getCellObjectValue() {
		return super.doGetValue();
	}

    /**
     * @@see org.eclipse.gmf.runtime.common.ui.services.properties.extended.MultiButtonCellEditor#initButtons()
     */
    protected void initButtons() {
        // 'set' button
        IPropertyAction setAction = new IPropertyAction() {

            public Object execute(Control owner) {
                return openDialogBox(owner);
            }
        };
        addButton("...", setAction); //$NON-NLS-1$
    }

}
@


1.4
log
@[146055] gmf_head ahunter 060614 SWTException exception caused by PropertyPageCellEditor
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
a26 1
import org.eclipse.swt.widgets.Text;
a186 8
	 * Returns the text widget
	 * @@return the text widget
     */
	protected Text getText() {
		return null;
	}

	/**
d250 1
@


1.4.2.1
log
@[110316] gmf_R1_0_maintenance mmostafa  060713 Compiler warning count should be 0 - runtime diagram layer components
@
text
@a258 1
        // default implementation do nothing
@


1.4.2.2
log
@[154612] gmf_R1_0_maintenance mmostafa  060824  PropertyPageCellEditor should not override getText() to return null
@
text
@d27 1
d188 8
@


1.4.2.3
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.3
log
@Bugzilla Bug 114387 gmf_head ldamus 051101 Need getter method for PropertyPageCellEditor's value attribute
@
text
@a13 1
import java.text.MessageFormat;
d19 3
a23 2
import org.eclipse.jface.viewers.DialogCellEditor;
import org.eclipse.jface.viewers.ISelectionProvider;
a24 8
import org.eclipse.swt.events.KeyAdapter;
import org.eclipse.swt.events.KeyEvent;
import org.eclipse.swt.events.ModifyEvent;
import org.eclipse.swt.events.ModifyListener;
import org.eclipse.swt.events.MouseAdapter;
import org.eclipse.swt.events.MouseEvent;
import org.eclipse.swt.events.TraverseEvent;
import org.eclipse.swt.events.TraverseListener;
a27 1
import org.eclipse.ui.dialogs.PropertyDialogAction;
a31 4
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.ui.dialogs.PropertiesDialog;
import org.eclipse.gmf.runtime.common.ui.services.properties.PropertiesService;

d35 1
a35 1
 * a property page, and a text widget for editing directly.
d39 1
a39 18
public class PropertyPageCellEditor extends DialogCellEditor {

	/**
	 * The text widget
	 */
	private Text text;

	/**
	 * My modify listener for modifications to the text
	 */
	private ModifyListener modifyListener;

	/**
	 * Flag which is <code>true</code> if there is a selection in the text
	 * widget, <code>false</code> otherwise. Used to notify that the
	 * copy/paste menu item enablement has changed
	 */
	private boolean isSelection = false;
d41 1
a41 21
	/**
	 * Flag which is <code>true</code> if the text is deletable, 
	 * <code>false</code> otherwise. Used to notify that the
	 * delete menu item enablement has changed
	 */
	private boolean isDeleteable = false;

	/**
	 * Flag which is <code>true</code> if the text is selectable, 
	 * <code>false</code> otherwise. Used to notify that the
	 * select all menu item enablement has changed
	 */
	private boolean isSelectable = false;

	/**
	 * My selection provider which provides a selection to the
	 * {@@link PropertyDialogAction}
	 */
	ISelectionProvider selectionProvider;

	/**
a46 5
	 * The value of this cell editor; initially <code>null</code>.
	 */
	private Object value = null;

	/**
a86 71
	 * Creates a text widget in the cell editor
	 * 
	 * @@see org.eclipse.jface.viewers.DialogCellEditor#createContents(Composite)
	 */
	protected Control createContents(Composite cell) {
		setText(new Text(cell, getStyle()));

		// Add a key listener to the text widget
		text.addKeyListener(new KeyAdapter() {

			// On key pressed, check the menu item enablement
			public void keyPressed(KeyEvent e) {
				keyReleaseOccured(e);
				if ((getControl() == null) || getControl().isDisposed())
					return;
				checkSelection();
				checkDeleteable();
				checkSelectable();
			}
		});

		// Add a traverse listener to the text widget
		text.addTraverseListener(new TraverseListener() {

			// On key traversed, disable the escape and return operations
			public void keyTraversed(TraverseEvent e) {
				if (e.detail == SWT.TRAVERSE_ESCAPE
					|| e.detail == SWT.TRAVERSE_RETURN) {
					e.doit = false;
				}
			}
		});

		// Add a mouse listener to the text widget
		text.addMouseListener(new MouseAdapter() {

			// On mouse up, check the menu item enablement
			public void mouseUp(MouseEvent e) {
				checkSelection();
				checkDeleteable();
				checkSelectable();
			}
		});

		text.setFont(cell.getFont());
		text.setBackground(cell.getBackground());
		text.setText(StringStatics.BLANK);
		text.addModifyListener(getModifyListener());

		return getText();
	}

	/**
	 * Updates the contents of the text field with <code>aValue</code>.
	 * 
	 * @@see org.eclipse.jface.viewers.DialogCellEditor#updateContents(Object)
	 */
	protected void updateContents(Object aValue) {

		if (getText() == null) {
			return;
		}

		String aText = StringStatics.BLANK;
		if (aValue != null) {
			aText = aValue.toString();
		}
		getText().setText(aText);
	}

	/**
d190 1
a190 1
	 */
d192 1
a192 139
		return text;
	}

	/**
	 * Sets the text widget
	 * @@param text The text widget to set
	 */
	private void setText(Text text) {
		this.text = text;
	}

	/**
	 * Notifies that this cell editor has focus. Put focus on my text widget
	 * and calculate the the menu item enablement.
	 */
	protected void doSetFocus() {
		if (getText() != null) {
			getText().selectAll();
			getText().setFocus();
			checkSelection();
			checkDeleteable();
			checkSelectable();
		}
	}

	/**
	 * Gets the text value in my text widget
	 * 
	 * @@return The text in my text widget
	 */
	protected Object doGetValue() {
		String aText = getText().getText();

		// handle value from collection editor dialog
		if (value instanceof ElementValue) {
			((ElementValue) value).setValue(aText);
			return value;
		}

		return aText;
	}

	/**
	 * Sets the text value in my text widget. <code>value</code> must be
	 * a <code>String</code>.
	 *
	 * @@param aValue a text string (type <code>String</code>)
	 */
	protected void doSetValue(Object aValue) {
		this.value = aValue;

		assert null != getText();
		getText().removeModifyListener(getModifyListener());
		getText().setText(aValue.toString());
		getText().addModifyListener(getModifyListener());
	}

	/**
	 * Returns my modify listener.
	 * 
	 * @@return my modify listener
	 */
	private ModifyListener getModifyListener() {
		if (modifyListener == null) {
			modifyListener = new ModifyListener() {
				public void modifyText(ModifyEvent e) {
					editOccured(e);
				}
			};
		}
		return modifyListener;
	}

	/**
	 * Processes a modify event that occurred in my text widget.
	 * Performs validation and sets the error message
	 * accordingly, and then reports a change using <code>fireEditorValueChanged</code>.
	 *
	 * @@param e The modify event
	 */
	protected void editOccured(ModifyEvent e) {

		String aValue = text.getText();
		if (aValue == null) {
			aValue = StringStatics.BLANK;
		}
		Object typedValue = aValue;
		boolean oldValidState = isValueValid();
		boolean newValidState = isCorrect(typedValue);
		if (typedValue == null && newValidState) {
			assert (false) : "Validator isn't limiting the cell editor's type range"; //$NON-NLS-1$
		}
		if (!newValidState) {
			// try to insert the current value into the error message.
			setErrorMessage(
				MessageFormat.format(
					getErrorMessage(),
					new Object[] { aValue }));
		}
		valueChanged(oldValidState, newValidState);
	}

	/**
	 * Checks to see if the "deleteable" state (can delete/
	 * nothing to delete) has changed and if so fire an
	 * enablement changed notification.
	 */
	private void checkDeleteable() {
		boolean oldIsDeleteable = isDeleteable;
		isDeleteable = isDeleteEnabled();
		if (oldIsDeleteable != isDeleteable) {
			fireEnablementChanged(DELETE);
		}
	}

	/**
	 * Checks to see if the "selectable" state (can select)
	 * has changed and if so fire an enablement changed notification.
	 */
	private void checkSelectable() {
		boolean oldIsSelectable = isSelectable;
		isSelectable = isSelectAllEnabled();
		if (oldIsSelectable != isSelectable) {
			fireEnablementChanged(SELECT_ALL);
		}
	}

	/**
	 * Checks to see if the selection state (selection /
	 * no selection) has changed and if so fire an
	 * enablement changed notification.
	 */
	private void checkSelection() {
		boolean oldIsSelection = isSelection;
		isSelection = text.getSelectionCount() > 0;
		if (oldIsSelection != isSelection) {
			fireEnablementChanged(COPY);
			fireEnablementChanged(CUT);
		}
d200 1
a200 1
	 */
d202 1
a202 3
		if (text == null || text.isDisposed())
			return false;
		return text.getSelectionCount() > 0;
d210 1
a210 1
	 */
d212 1
a212 3
		if (text == null || text.isDisposed())
			return false;
		return text.getSelectionCount() > 0;
d220 1
a220 1
	 */
d222 1
a222 4
		if (text == null || text.isDisposed())
			return false;
		return text.getSelectionCount() > 0
			|| text.getCaretPosition() < text.getCharCount();
d230 1
a230 1
	 */
d232 1
a232 3
		if (text == null || text.isDisposed())
			return false;
		return true;
d240 1
a240 1
	 */
d242 1
a242 3
		if (text == null || text.isDisposed())
			return false;
		return true;
d250 1
a250 1
	 */
d252 1
a252 3
		if (text == null || text.isDisposed())
			return false;
		return text.getCharCount() > 0;
d257 1
a257 1
	 */
a258 1
		text.copy();
d263 1
a263 1
	 */
d265 1
a265 4
		text.cut();
		checkSelection();
		checkDeleteable();
		checkSelectable();
d271 1
a271 1
	 */
d273 1
a273 13
		if (text.getSelectionCount() > 0)
			text.insert(StringStatics.BLANK);
		else {
			// remove the next character
			int pos = text.getCaretPosition();
			if (pos < text.getCharCount()) {
				text.setSelection(pos, pos + 1);
				text.insert(StringStatics.BLANK);
			}
		}
		checkSelection();
		checkDeleteable();
		checkSelectable();
d278 1
a278 1
	 */
d280 1
a280 4
		text.paste();
		checkSelection();
		checkDeleteable();
		checkSelectable();
d285 1
a285 1
	 */
d287 1
a287 3
		text.selectAll();
		checkSelection();
		checkDeleteable();
d293 1
a293 1
	 */
d295 1
a295 1
		return value;
d297 15
a311 1
	
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d317 1
a317 1
	private Text getText() {
d587 9
a595 1

@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

