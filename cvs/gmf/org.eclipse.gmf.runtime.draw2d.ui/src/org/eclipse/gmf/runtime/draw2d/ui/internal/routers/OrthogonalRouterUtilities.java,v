head	1.7;
access;
symbols
	v20081023-2107:1.7
	v20081022-1925:1.7
	v20081021-1810:1.7
	v20081020-0700:1.7
	v20080911-1728:1.7
	v20080911-1506:1.7
	v20080910-1520:1.7
	v20080910-1510:1.7
	v20080903-1520:1.7
	v20080903-1510:1.7
	v20080722-1827:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080610-1132:1.7
	v20080603-1553:1.7
	v20080512-1200:1.7
	v20080503-1740:1.7
	v20080501-1739:1.7
	v20080425-1959:1.7
	v20080417-1610:1.7
	v20080407-2250:1.7
	v20080407-0930:1.7
	v20080404-1111:1.7
	v20080222-1200:1.7
	v20080215-1500:1.7
	v20080215-1200:1.4
	v20080201-2010:1.7
	v20080114-1111:1.7
	v20071108-0000:1.4
	v20071003-0000:1.4
	v20070928-0000:1.4
	v20070915-0000:1.4
	v20070903-0000:1.4
	v20070830-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070518-1300:1.4
	v20070330-1300:1.4
	v20070221-1500:1.4
	v20070208-1800:1.4
	v20070202-0200:1.3.2.1
	M4_20:1.3
	v20061218-1200:1.3
	v20061214-0000:1.3
	M3_20:1.3
	v20061013-1330:1.3
	v20060925-1700:1.3
	v20060919-0800:1.3
	M1_20:1.3
	v20060824-1600:1.3
	v20060817-1500:1.3
	v20060810-1700:1.3
	v20060803-1200:1.3
	v20060728-0500:1.3
	v20060721-1130:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1200:1.3
	v20060609-1400:1.3
	v20060531-1730:1.3
	v20060519-0800:1.3
	RC2_10:1.3
	I20060505-1400:1.3
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.3
	I20060407-1200:1.3
	I20060331-1000:1.3
	I20060324-0300:1.3
	I20060317-1300:1.3
	I20060317-1200:1.3
	I20060316-1300:1.3
	I20060309-1300:1.3
	M5_10:1.3
	S20060303-1600:1.3
	I20060227-1730:1.3
	I20060216-1945:1.3
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051208-2000:1.3
	I20051201-1800:1.3
	I20051124-2000:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;


1.7
date	2008.01.10.23.02.30;	author aboyko;	state Exp;
branches;
next	1.6;
commitid	6a814786a4064567;

1.6
date	2008.01.03.17.42.57;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	3284477d1ea04567;

1.5
date	2008.01.02.20.06.57;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	5a64477beede4567;

1.4
date	2007.01.26.22.04.17;	author crevells;	state Exp;
branches;
next	1.3;
commitid	2e9545ba7ae14567;

1.3
date	2005.10.25.13.51.49;	author sshaw;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2005.09.12.21.27.43;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.52;	author sshaw;	state Exp;
branches;
next	;

1.3.2.1
date	2007.01.26.22.40.36;	author crevells;	state Exp;
branches;
next	;
commitid	19fe45ba83644567;


desc
@@


1.7
log
@Commit back [194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.draw2d.ui.figures.OrthogonalConnectionAnchor;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;


/**
 * @@author sshaw
 *
 */
public class OrthogonalRouterUtilities {
	
	/**
	 * Calculates the center point that is aligned vertically or 
	 * horizontally with the given reference point.
	 * 
	 * @@param rect the <code>Rectangle</code> whose center point is used as 
	 * the location point to be adjusted versus the outside reference point.
	 * @@param ref the <code>Point</code> that is used as the reference to
	 * readjust the center point of the given <code>Rectangle</code>
	 * @@return a <code>Point</code> that is adjusted horizontally or vertically
	 * with respect to the given reference point.
	 */
	public static Point getAdjustedCenterPoint(
		final Rectangle rect,
		final Point ref) {
		Point ptNewCenter = new Point(rect.getCenter());

		if (ref.x < rect.getRight().x && ref.x > rect.getLeft().x) {
			ptNewCenter.x = ref.x;
		} else if (ref.y < rect.getBottom().y && ref.y > rect.getTop().y) {
			ptNewCenter.y = ref.y;
		}

		return ptNewCenter;
	}

	/**
	 * Resets both of the end points in the polyline to be close to the center point
	 * of the figure.
	 * 
	 * @@param conn the <code>Connection</code> that is used to retrieve the ends and map the coordinates 
	 * of the end owners into absolute coordinates.
	 * @@param newLine the <code>PointList</code> whose end points are modified to be inside the end owners
	 * bounding boxes.
	 */
	public static void resetEndPointsToCenter(
		Connection conn,
		PointList newLine) {
        
        Rectangle startRect = getBounds(conn.getSourceAnchor().getOwner());
        conn.getSourceAnchor().getOwner().translateToAbsolute(startRect);

		Point ptStart = newLine.getPoint(1);
		conn.translateToAbsolute(ptStart);
		ptStart = getAdjustedCenterPoint(startRect, ptStart);
		conn.translateToRelative(ptStart);
		newLine.setPoint(ptStart, 0);
        
        Rectangle endRect = getBounds(conn.getTargetAnchor().getOwner());
        conn.getTargetAnchor().getOwner().translateToAbsolute(endRect);

		Point ptEnd = newLine.getPoint(newLine.size() - 2);
		conn.translateToAbsolute(ptEnd);
		ptEnd = getAdjustedCenterPoint(endRect, ptEnd);
		conn.translateToRelative(ptEnd);
		newLine.setPoint(ptEnd, newLine.size() - 1);
	}
	
	/**
	 * getEdgePoint
	 * Utility method used to calculate the edge point of the source of target shape.
	 * 
	 * @@param conn Connection figure used to translate the point coordinates
	 * @@param anchor ConnectionAnchor to get the source / target bounds.
	 * @@param ptRef Point Reference point from which the edge point is calculated
	 * @@return Point that is on the edge of the Source / Target shape.
	 */
	private static Point getEdgePoint(
		Connection conn,
		ConnectionAnchor anchor,
		Point ptRef) {
		Rectangle rect = getBounds(anchor.getOwner());
		anchor.getOwner().translateToAbsolute(rect);
		conn.translateToRelative(rect);
		
        Point ptRef2 = new Point(ptRef);
        Point ptRef1 = getAdjustedCenterPoint(rect, ptRef2);

        Point ptAbsRef2 = new Point(ptRef2);
        conn.translateToAbsolute(ptAbsRef2);
        Point ptEdge = anchor.getLocation(ptAbsRef2);
		conn.translateToRelative(ptEdge);

		LineSeg lineSeg = new LineSeg(ptRef1, ptRef2);
		Point ptProj = lineSeg.perpIntersect(ptEdge.x, ptEdge.y);

		// account for possible rounding errors and ensure the
		// resulting line is straight
		if (Math.abs(ptProj.x - ptRef2.x) < Math.abs(ptProj.y - ptRef2.y))
			ptProj.x = ptRef2.x;
		else
			ptProj.y = ptRef2.y;
		
		return ptProj;
	}
	
	/**
	 * Utility method used to calculate the orthongaol line segment that connects to the
	 * given anchor location from a reference point.
	 * 
	 * @@param conn <code>Connection</code> figure used to translate the point coordinates
	 * @@param anchor the <code>ConnectionAnchor</code> to retrieve the location given a reference 
	 * point
	 * @@param ref the <code>Point</code> that is a reference from which the edge point is 
	 * calculated
	 * @@return <code>Point</code> that is on a legitimate connection location of the 
	 * <code>ConnectionAnchor</code> owner shape.
	 */	
	public static LineSeg getOrthogonalLineSegToAnchorLoc(
			Connection conn,
			ConnectionAnchor anchor,
			Point ref) {
			
			assert anchor != null && anchor.getOwner() != null;
			
			if (anchor instanceof OrthogonalConnectionAnchor) {
				PrecisionPoint refAbs = new PrecisionPoint(ref);
				conn.translateToAbsolute(refAbs);
				PrecisionPoint anchorPoint = new PrecisionPoint(((OrthogonalConnectionAnchor)anchor).getOrthogonalLocation(refAbs));
				conn.translateToRelative(anchorPoint);
				return new LineSeg(anchorPoint, ref);
			}
			
			Point ptAbsRef = getEdgePoint(conn, anchor, ref);
			conn.translateToAbsolute(ptAbsRef);
			Point ptEdge = anchor.getLocation(ptAbsRef);
			conn.translateToRelative(ptEdge);
			
			LineSeg result = new LineSeg(ptEdge, ref);
			if (!result.isHorizontal() && !result.isVertical()) {
				if (Math.abs(result.getOrigin().x - result.getTerminus().x) < 
					Math.abs(result.getOrigin().y - result.getTerminus().y)) {
					result.setTerminus(new Point(result.getOrigin().x, result.getTerminus().y));
				}
				else {
					result.setTerminus(new Point(result.getTerminus().x, result.getOrigin().y));
				}
			}
			
			return result;
	}
    
    /**
     * Returns a copy of the bounds of this figure or if the figure is a
     * <code>Connection</code> the bounds of the pointlist will be returned.
     * 
     * @@param figure
     * @@return a copy of the bounds
     */
    private static Rectangle getBounds(IFigure figure) {
        return figure instanceof Connection ? ((Connection) figure).getPoints()
            .getBounds().getCopy()
            : figure.getBounds().getCopy();
    }

	/**
	 * Returns true if the points form a rectilinear line.
	 * 
	 * @@param points polyline's points
	 * @@return
	 */
	public static boolean isRectilinear(PointList points) {
		for (int i = 1; i < points.size(); i++) {
			Point currentPt = points.getPoint(i);
			Point previousPt = points.getPoint(i - 1);
			if (currentPt.x != previousPt.x && currentPt.y != previousPt.y) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Polylines points are modified to form a rectilinear polyline (or connection in perspective).
	 * Essentially extra points are added and list of points will form a rectilinear polyline.
	 * The method has options for specifying orientation of start and end segments of a rectilinear
	 * polyline  
	 * 
	 * @@param points points list to be made rectilinear
	 * @@param offStartDirection orientation of the start segment
	 * @@param offEndDirection orientation of the end segment
	 */
	public static void transformToOrthogonalPointList(PointList points, int offStartDirection, int offEndDirection) {
		if (points.size() > 1) {
			PointList startPoints = new PointList(points.size());
			PointList endPoints = new PointList(points.size());
			boolean isOffSourceDirectionSet = offStartDirection == PositionConstants.HORIZONTAL || offStartDirection == PositionConstants.VERTICAL;
			boolean isOffTargetDirectionSet = offEndDirection == PositionConstants.VERTICAL || offEndDirection == PositionConstants.HORIZONTAL;
			if (!isOffSourceDirectionSet && !isOffTargetDirectionSet) {
				/*
				 * If there is no off start and off end direction passed in, determine
				 * the off start direction.
				 */
				Point first = points.getPoint(0);
				Point second = points.getPoint(1);
				offStartDirection = Math.abs(first.x - second.x) < Math
						.abs(first.y - second.y) ? PositionConstants.HORIZONTAL
						: PositionConstants.VERTICAL;
				isOffSourceDirectionSet = true;
			}
			startPoints.addPoint(points.removePoint(0));
			endPoints.addPoint(points.removePoint(points.size() - 1));
			while (points.size() != 0) {
				if (isOffSourceDirectionSet) {
					Point nextPt = points.removePoint(0);
					Point lastStartPt = startPoints.getLastPoint();
					if (nextPt.x != lastStartPt.x && nextPt.y != lastStartPt.y) {
						/*
						 * If segment is not rectilinear insert a point to make it
						 * rectilinear
						 */
						if (offStartDirection == PositionConstants.VERTICAL) {
							startPoints.addPoint(new Point(lastStartPt.x, nextPt.y));
							offStartDirection = PositionConstants.HORIZONTAL;
						} else {
							startPoints.addPoint(new Point(nextPt.x, lastStartPt.y));
							offStartDirection = PositionConstants.VERTICAL;
						}
					} else {
						offStartDirection = nextPt.x == lastStartPt.x ? PositionConstants.VERTICAL
								: PositionConstants.HORIZONTAL;
					}
					startPoints.addPoint(nextPt);
				}
				if (isOffTargetDirectionSet && points.size() != 0) {
					Point nextPt = points.removePoint(points.size() - 1);
					Point firstEndPt = endPoints.getFirstPoint();
					if (nextPt.x != firstEndPt.x && nextPt.y != firstEndPt.y) {
						/*
						 * If segment is not rectilinear insert a point to make it
						 * rectilinear
						 */
						if (offEndDirection == PositionConstants.VERTICAL) {
							endPoints.insertPoint(new Point(firstEndPt.x, nextPt.y), 0);
							offEndDirection = PositionConstants.HORIZONTAL;
						} else {
							endPoints.insertPoint(new Point(nextPt.x, firstEndPt.y), 0);
							offEndDirection = PositionConstants.VERTICAL;
						}
					} else {
						offEndDirection = nextPt.x == firstEndPt.x ? PositionConstants.VERTICAL
								: PositionConstants.HORIZONTAL;
					}
					endPoints.insertPoint(nextPt, 0);
				}
			}
			/*
			 * Now we need to merge the two point lists such that the polyline formed by the
			 * points is still rectilinear. Hence there is a chance that one more point needs
			 * to be added.
			 */
			Point lastStartPt = startPoints.getLastPoint();
			Point firstEndPt = endPoints.getFirstPoint();
			if (lastStartPt.x != firstEndPt.x && lastStartPt.y != firstEndPt.y) {
				/*
				 * We need to add extra point. Now there is a dilemma: Should we
				 * use off source orientation or off target? We'll use off
				 * target orientation in 2 cases: 
				 * 1. Off source direction has not been set and off target direction was 
				 * 2. Off target direction is set, but the start points list has more points
				 * than the end points list.
				 * Otherwise off start direction will be used.
				 */
				if ((!isOffSourceDirectionSet && isOffTargetDirectionSet) || (isOffTargetDirectionSet && endPoints.size() < startPoints.size())) {
					if (offEndDirection == PositionConstants.VERTICAL) {
						startPoints.addPoint(new Point(firstEndPt.x, lastStartPt.y));
					} else {
						startPoints.addPoint(new Point(lastStartPt.x, firstEndPt.y));
					}
				}
				else if (offStartDirection == PositionConstants.VERTICAL) {
					startPoints.addPoint(new Point(lastStartPt.x, firstEndPt.y));
				} else {
					startPoints.addPoint(new Point(firstEndPt.x, lastStartPt.y));
				}
			}
			points.addAll(startPoints);
			points.addAll(endPoints);
		}
	}
	
}
@


1.6
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d17 1
d20 1
d22 1
d31 1
d146 8
d185 127
@


1.5
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@a16 1
import org.eclipse.draw2d.PositionConstants;
a18 1
import org.eclipse.draw2d.geometry.PrecisionPoint;
a19 1
import org.eclipse.gmf.runtime.draw2d.ui.figures.OrthogonalConnectionAnchor;
a27 1
	
a141 8
			if (anchor instanceof OrthogonalConnectionAnchor) {
				PrecisionPoint refAbs = new PrecisionPoint(ref);
				conn.translateToAbsolute(refAbs);
				PrecisionPoint anchorPoint = new PrecisionPoint(((OrthogonalConnectionAnchor)anchor).getOrthogonalLocation(refAbs));
				conn.translateToRelative(anchorPoint);
				return new LineSeg(anchorPoint, ref);
			}
			
a172 127

	/**
	 * Returns true if the points form a rectilinear line.
	 * 
	 * @@param points polyline's points
	 * @@return
	 */
	public static boolean isRectilinear(PointList points) {
		for (int i = 1; i < points.size(); i++) {
			Point currentPt = points.getPoint(i);
			Point previousPt = points.getPoint(i - 1);
			if (currentPt.x != previousPt.x && currentPt.y != previousPt.y) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Polylines points are modified to form a rectilinear polyline (or connection in perspective).
	 * Essentially extra points are added and list of points will form a rectilinear polyline.
	 * The method has options for specifying orientation of start and end segments of a rectilinear
	 * polyline  
	 * 
	 * @@param points points list to be made rectilinear
	 * @@param offStartDirection orientation of the start segment
	 * @@param offEndDirection orientation of the end segment
	 */
	public static void transformToOrthogonalPointList(PointList points, int offStartDirection, int offEndDirection) {
		if (points.size() > 1) {
			PointList startPoints = new PointList(points.size());
			PointList endPoints = new PointList(points.size());
			boolean isOffSourceDirectionSet = offStartDirection == PositionConstants.HORIZONTAL || offStartDirection == PositionConstants.VERTICAL;
			boolean isOffTargetDirectionSet = offEndDirection == PositionConstants.VERTICAL || offEndDirection == PositionConstants.HORIZONTAL;
			if (!isOffSourceDirectionSet && !isOffTargetDirectionSet) {
				/*
				 * If there is no off start and off end direction passed in, determine
				 * the off start direction.
				 */
				Point first = points.getPoint(0);
				Point second = points.getPoint(1);
				offStartDirection = Math.abs(first.x - second.x) < Math
						.abs(first.y - second.y) ? PositionConstants.HORIZONTAL
						: PositionConstants.VERTICAL;
				isOffSourceDirectionSet = true;
			}
			startPoints.addPoint(points.removePoint(0));
			endPoints.addPoint(points.removePoint(points.size() - 1));
			while (points.size() != 0) {
				if (isOffSourceDirectionSet) {
					Point nextPt = points.removePoint(0);
					Point lastStartPt = startPoints.getLastPoint();
					if (nextPt.x != lastStartPt.x && nextPt.y != lastStartPt.y) {
						/*
						 * If segment is not rectilinear insert a point to make it
						 * rectilinear
						 */
						if (offStartDirection == PositionConstants.VERTICAL) {
							startPoints.addPoint(new Point(lastStartPt.x, nextPt.y));
							offStartDirection = PositionConstants.HORIZONTAL;
						} else {
							startPoints.addPoint(new Point(nextPt.x, lastStartPt.y));
							offStartDirection = PositionConstants.VERTICAL;
						}
					} else {
						offStartDirection = nextPt.x == lastStartPt.x ? PositionConstants.VERTICAL
								: PositionConstants.HORIZONTAL;
					}
					startPoints.addPoint(nextPt);
				}
				if (isOffTargetDirectionSet && points.size() != 0) {
					Point nextPt = points.removePoint(points.size() - 1);
					Point firstEndPt = endPoints.getFirstPoint();
					if (nextPt.x != firstEndPt.x && nextPt.y != firstEndPt.y) {
						/*
						 * If segment is not rectilinear insert a point to make it
						 * rectilinear
						 */
						if (offEndDirection == PositionConstants.VERTICAL) {
							endPoints.insertPoint(new Point(firstEndPt.x, nextPt.y), 0);
							offEndDirection = PositionConstants.HORIZONTAL;
						} else {
							endPoints.insertPoint(new Point(nextPt.x, firstEndPt.y), 0);
							offEndDirection = PositionConstants.VERTICAL;
						}
					} else {
						offEndDirection = nextPt.x == firstEndPt.x ? PositionConstants.VERTICAL
								: PositionConstants.HORIZONTAL;
					}
					endPoints.insertPoint(nextPt, 0);
				}
			}
			/*
			 * Now we need to merge the two point lists such that the polyline formed by the
			 * points is still rectilinear. Hence there is a chance that one more point needs
			 * to be added.
			 */
			Point lastStartPt = startPoints.getLastPoint();
			Point firstEndPt = endPoints.getFirstPoint();
			if (lastStartPt.x != firstEndPt.x && lastStartPt.y != firstEndPt.y) {
				/*
				 * We need to add extra point. Now there is a dilemma: Should we
				 * use off source orientation or off target? We'll use off
				 * target orientation in 2 cases: 
				 * 1. Off source direction has not been set and off target direction was 
				 * 2. Off target direction is set, but the start points list has more points
				 * than the end points list.
				 * Otherwise off start direction will be used.
				 */
				if ((!isOffSourceDirectionSet && isOffTargetDirectionSet) || (isOffTargetDirectionSet && endPoints.size() < startPoints.size())) {
					if (offEndDirection == PositionConstants.VERTICAL) {
						startPoints.addPoint(new Point(firstEndPt.x, lastStartPt.y));
					} else {
						startPoints.addPoint(new Point(lastStartPt.x, firstEndPt.y));
					}
				}
				else if (offStartDirection == PositionConstants.VERTICAL) {
					startPoints.addPoint(new Point(lastStartPt.x, firstEndPt.y));
				} else {
					startPoints.addPoint(new Point(firstEndPt.x, lastStartPt.y));
				}
			}
			points.addAll(startPoints);
			points.addAll(endPoints);
		}
	}
	
@


1.4
log
@[112996] gmf_R1_0_maintenance crevells 070126 Attaching a rectilinear routed line to a connection connects to space
@
text
@d17 1
d20 1
d22 1
d31 1
d146 8
d185 127
@


1.3
log
@bugzilla 113003 gmf-head sshaw 051020 Cannot reorient rectilinear routed line that contains bendpoints...
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d16 1
a19 1

d65 3
a67 3
		Rectangle startRect =
			new Rectangle(conn.getSourceAnchor().getOwner().getBounds());
		conn.getSourceAnchor().getOwner().translateToAbsolute(startRect);
d74 3
a76 4

		Rectangle endRect =
			new Rectangle(conn.getTargetAnchor().getOwner().getBounds());
		conn.getTargetAnchor().getOwner().translateToAbsolute(endRect);
d98 1
a98 1
		Rectangle rect = new Rectangle(anchor.getOwner().getBounds());
d160 13
@


1.3.2.1
log
@[112996] gmf_R1_0_maintenance crevells 070126 Attaching a rectilinear routed line to a connection connects to space
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2007 IBM Corporation and others.
a15 1
import org.eclipse.draw2d.IFigure;
d19 1
d65 3
a67 3
        
        Rectangle startRect = getBounds(conn.getSourceAnchor().getOwner());
        conn.getSourceAnchor().getOwner().translateToAbsolute(startRect);
d74 4
a77 3
        
        Rectangle endRect = getBounds(conn.getTargetAnchor().getOwner());
        conn.getTargetAnchor().getOwner().translateToAbsolute(endRect);
d99 1
a99 1
		Rectangle rect = getBounds(anchor.getOwner());
a160 13
    
    /**
     * Returns a copy of the bounds of this figure or if the figure is a
     * <code>Connection</code> the bounds of the pointlist will be returned.
     * 
     * @@param figure
     * @@return a copy of the bounds
     */
    private static Rectangle getBounds(IFigure figure) {
        return figure instanceof Connection ? ((Connection) figure).getPoints()
            .getBounds().getCopy()
            : figure.getBounds().getCopy();
    }
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d141 2
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

