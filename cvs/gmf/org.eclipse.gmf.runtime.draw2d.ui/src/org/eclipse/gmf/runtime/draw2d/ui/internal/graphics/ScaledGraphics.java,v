head	1.12;
access;
symbols
	v20081023-2107:1.11.2.1
	v20081022-1925:1.12
	v20081021-1810:1.11.2.1
	v20081020-0700:1.12
	v20080911-1728:1.12
	v20080911-1506:1.11.2.1
	v20080910-1520:1.12
	v20080910-1510:1.11.2.1
	v20080903-1520:1.12
	v20080903-1510:1.11.2.1
	v20080722-1827:1.11
	R2_1_maintenance:1.11.0.2
	Root_R2_1_maintenance:1.11
	R2_1_0:1.11
	v20080610-1132:1.11
	v20080603-1553:1.11
	v20080512-1200:1.10
	v20080503-1740:1.10
	v20080501-1739:1.9
	v20080425-1959:1.9
	v20080417-1610:1.9
	v20080407-2250:1.9
	v20080407-0930:1.9
	v20080404-1111:1.9
	v20080222-1200:1.9
	v20080215-1500:1.9
	v20080215-1200:1.9
	v20080201-2010:1.9
	v20080114-1111:1.9
	v20071108-0000:1.9
	v20071003-0000:1.9
	v20070928-0000:1.9
	v20070915-0000:1.9
	v20070903-0000:1.9
	v20070830-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	v20070621-0000:1.9
	RC3_20:1.9
	v20070605-1400:1.9
	v20070601-1400:1.9
	v20070518-1300:1.9
	v20070330-1300:1.9
	v20070221-1500:1.9
	v20070208-1800:1.8
	v20070202-0200:1.7.2.1
	M4_20:1.8
	v20061218-1200:1.8
	v20061214-0000:1.8
	M3_20:1.8
	v20061013-1330:1.8
	v20060925-1700:1.7.2.1
	v20060919-0800:1.7.2.1
	M1_20:1.7
	v20060824-1600:1.7
	v20060817-1500:1.7
	v20060810-1700:1.7
	v20060803-1200:1.7
	v20060728-0500:1.7
	v20060721-1130:1.7
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060609-1400:1.7
	v20060531-1730:1.7
	v20060519-0800:1.7
	RC2_10:1.7
	I20060505-1400:1.7
	I20060428-1300:1.7
	I20060424-0500:1.7
	I20060424-0300:1.7
	M6_10:1.7
	I20060407-1200:1.7
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051208-2000:1.5
	I20051201-1800:1.5
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.4;
locks; strict;
comment	@# @;


1.12
date	2008.08.28.01.35.59;	author aboyko;	state Exp;
branches;
next	1.11;
commitid	28f248b600ff4567;

1.11
date	2008.05.29.20.32.17;	author ahunter;	state Exp;
branches
	1.11.2.1;
next	1.10;
commitid	6f16483f12d14567;

1.10
date	2008.05.03.20.09.32;	author ahunter;	state Exp;
branches;
next	1.9;
commitid	2dba481cc67b4567;

1.9
date	2007.02.09.20.53.14;	author crevells;	state Exp;
branches;
next	1.8;
commitid	6cc445ccdf3a4567;

1.8
date	2006.10.03.15.04.52;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.04.20.18.24;	author sshaw;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.03.07.22.14.01;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.25.19.37.57;	author cmahoney;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.12.22.25.23;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.05.20.30.44;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.27.43;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.51;	author sshaw;	state Exp;
branches;
next	;

1.7.2.1
date	2006.09.13.16.46.18;	author ahunter;	state Exp;
branches;
next	;

1.11.2.1
date	2008.08.28.16.09.31;	author aboyko;	state Exp;
branches;
next	;
commitid	151c48b6cdba4567;


desc
@@


1.12
log
@[244297] gmf_head aboyko 080827 ScaledGraphics should allow one to set background and foregroud patterns
@
text
@/******************************************************************************
 * Copyright (c) 2000, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation
 *    Mariot Chauvin <mariot.chauvin@@obeo.fr> - patch 244297
 ****************************************************************************/


package org.eclipse.gmf.runtime.draw2d.ui.internal.graphics;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.draw2d.FigureUtilities;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.draw2d.ui.graphics.GCUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dPlugin;
import org.eclipse.jface.window.Window;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.FontData;
import org.eclipse.swt.graphics.FontMetrics;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.Pattern;
import org.eclipse.swt.graphics.TextLayout;
import org.eclipse.swt.graphics.TextStyle;
import org.eclipse.swt.widgets.Display;


/**
 * @@canBeSeenBy %partners
 *  
 * Subclass of Graphics that uses resource manager for its font cache and 
 * scales graphics/fonts by a specified scale factor
 *
 * <p>
 * Code taken from Eclipse reference bugzilla #77403
 * See also bugzilla #111454
 * See also bugzilla #230056 setLineWidth in ScaledGraphics does not support the 
 * zoom factor.
 */
/**
 * A Graphics object able to scale all operations based on the current scale factor.
 */
public class ScaledGraphics
	extends Graphics
{

private static class FontHeightCache {
	Font font;
	int height;
}

static class FontKey {
	Font font;
	int height;
	protected FontKey() {/* empty constructor */ }
	protected FontKey(Font font, int height) {
		this.font = font;
		this.height = height;
	}
	
	public boolean equals(Object obj) {
		return (((FontKey)obj).font.equals(font) 
				&& ((FontKey)obj).height == height);
	}

	public int hashCode() {
		return font.hashCode() ^ height;
	}

	protected void setValues(Font font, int height) {
		this.font = font;
		this.height = height;
	}
}

/**
 * The internal state of the scaled graphics.
 */
protected static class State {
	private double appliedX;
	private double appliedY;
	private Font font;
	private int lineWidth;
	private double zoom; 

	/**
	 * Constructs a new, uninitialized State object.
	 */
	protected State() {/* empty constructor */}
	
	/**
	 * Constructs a new State object and initializes the properties based on the given 
	 * values.
	 * 
	 * @@param zoom the zoom factor
	 * @@param x the x offset
	 * @@param y the y offset
	 * @@param font the font
	 * @@param lineWidth the line width
	 */
	protected State(double zoom, double x, double y, Font font, int lineWidth) {
		this.zoom = zoom;
		this.appliedX = x;
		this.appliedY = y;
		this.font = font;
		this.lineWidth = lineWidth;
	}
	
	/**
	 * Sets all the properties of the state object.
	 * @@param zoom the zoom factor
	 * @@param x the x offset
	 * @@param y the y offset
	 * @@param font the font
	 * @@param lineWidth the line width
	 */
	protected void setValues(double zoom, double x, double y, 
								Font font, int lineWidth) {
		this.zoom = zoom;
		this.appliedX = x;
		this.appliedY = y;
		this.font = font;
		this.lineWidth = lineWidth;
	}
}

static private boolean advancedGraphicsWarningLogged = false;

private static int[][] intArrayCache = new int[8][];
private final Rectangle tempRECT = new Rectangle();

static {
	for (int i = 0; i < intArrayCache.length; i++)
		intArrayCache[i] = new int[i + 1];
}

private boolean allowText = true;
//private static final Point PT = new Point();
//private Map fontCache = new HashMap();
private Map fontDataCache = new HashMap();
private FontKey fontKey = new FontKey();
private double fractionalX;
private double fractionalY;
private Graphics graphics;
private FontHeightCache localCache = new FontHeightCache();
private Font localFont;
private int localLineWidth;
private List stack = new ArrayList();
private int stackPointer = 0;
private FontHeightCache targetCache = new FontHeightCache();

double zoom = 1.0;

/**
 * Constructs a new ScaledGraphics based on the given Graphics object.
 * @@param g the base graphics object
 */
public ScaledGraphics(Graphics g) {
	graphics = g;
	localFont = g.getFont();
	localLineWidth = g.getLineWidth();
}

/** @@see Graphics#clipRect(Rectangle) */
public void clipRect(Rectangle r) {
	graphics.clipRect(zoomClipRect(r));
}

Font createFont(FontData data) {
	return new Font(Display.getCurrent(), data);
}

/** @@see Graphics#dispose() */
public void dispose() {
	//Remove all states from the stack
	while (stackPointer > 0) {
		popState();
	}
	
	//	 Resource manager handles fonts 
}

/** @@see Graphics#drawArc(int, int, int, int, int, int) */
public void drawArc(int x, int y, int w, int h, int offset, int sweep) {
	Rectangle z = zoomRect(x, y, w, h);
	if (z.isEmpty() || sweep == 0)
		return;
	graphics.drawArc(z, offset, sweep);
}

/** @@see Graphics#drawFocus(int, int, int, int) */
public void drawFocus(int x, int y, int w, int h) {
	graphics.drawFocus(zoomRect(x, y, w, h));
}

/** @@see Graphics#drawImage(Image, int, int) */
public void drawImage(Image srcImage, int x, int y) {
	org.eclipse.swt.graphics.Rectangle size = srcImage.getBounds();
    Dimension sizeLPDim = new Dimension(size.width, size.height);
    if (graphics instanceof MapModeGraphics) {
        ((MapModeGraphics)graphics).getMapMode().DPtoLP(sizeLPDim);
    }
    
    Rectangle z = new Rectangle((int)(Math.floor((x * zoom + fractionalX))), 
        (int)(Math.floor((y * zoom + fractionalY))),
        (int)(Math.floor((sizeLPDim.width * zoom + fractionalX))), 
        (int)(Math.floor((sizeLPDim.height * zoom + fractionalY))));
    
	graphics.drawImage(srcImage, 0, 0, size.width, size.height,
		z.x, z.y, z.width, z.height);
}

/** @@see Graphics#drawImage(Image, int, int, int, int, int, int, int, int) */
public void drawImage(Image srcImage, int sx, int sy, int sw, int sh,
										int tx, int ty, int tw, int th) {
	//"t" == target rectangle, "s" = source
			 
	Rectangle t = zoomRect(tx, ty, tw, th);
	if (!t.isEmpty())
		graphics.drawImage(srcImage, sx, sy, sw, sh, t.x, t.y, t.width, t.height);
}

/** @@see Graphics#drawLine(int, int, int, int) */
public void drawLine(int x1, int y1, int x2, int y2) {
	graphics.drawLine(
		(int)(Math.floor((x1 * zoom + fractionalX))),
		(int)(Math.floor((y1 * zoom + fractionalY))),
		(int)(Math.floor((x2 * zoom + fractionalX))),
		(int)(Math.floor((y2 * zoom + fractionalY))));
}

/** @@see Graphics#drawOval(int, int, int, int) */
public void drawOval(int x, int y, int w, int h) {
	graphics.drawOval(zoomRect(x, y, w, h));
}

/** @@see Graphics#drawPoint(int, int) */
public void drawPoint(int x, int y) {
	graphics.drawPoint((int)Math.floor(x * zoom + fractionalX),
			(int)Math.floor(y * zoom + fractionalY));
}

/**
 * @@see Graphics#drawPolygon(int[])
 */
public void drawPolygon(int[] points) {
	graphics.drawPolygon(zoomPointList(points));
}

/** @@see Graphics#drawPolygon(PointList) */
public void drawPolygon(PointList points) {
	graphics.drawPolygon(zoomPointList(points.toIntArray()));
}

/**
 * @@see Graphics#drawPolyline(int[])
 */
public void drawPolyline(int[] points) {
	graphics.drawPolyline(zoomPointList(points));
}

/** @@see Graphics#drawPolyline(PointList) */
public void drawPolyline(PointList points) {
	graphics.drawPolyline(zoomPointList(points.toIntArray()));
}

/** @@see Graphics#drawRectangle(int, int, int, int) */
public void drawRectangle(int x, int y, int w, int h) {
	graphics.drawRectangle(zoomRect(x, y, w, h));
}

/** @@see Graphics#drawRoundRectangle(Rectangle, int, int) */
public void drawRoundRectangle(Rectangle r, int arcWidth, int arcHeight) {
	graphics.drawRoundRectangle(zoomRect(r.x, r.y, r.width, r.height),
		(int)(arcWidth * zoom),
		(int)(arcHeight * zoom));
}

/** @@see Graphics#drawString(String, int, int) */
public void drawString(String s, int x, int y) {
	if (allowText)
		graphics.drawString(s, zoomTextPoint(x, y));
}

/** @@see Graphics#drawText(String, int, int) */
public void drawText(String s, int x, int y) {
	if (allowText)
		graphics.drawText(s, zoomTextPoint(x, y));
}

/**
 * @@see Graphics#drawText(String, int, int, int)
 */
public void drawText(String s, int x, int y, int style) {
	if (allowText)
		graphics.drawText(s, zoomTextPoint(x, y), style);
}

/**
 * @@see Graphics#drawTextLayout(TextLayout, int, int, int, int, Color, Color)
 */
public void drawTextLayout(TextLayout layout, int x, int y, int selectionStart,
		int selectionEnd, Color selectionForeground, Color selectionBackground) {
	TextLayout scaled = zoomTextLayout(layout);
	graphics.drawTextLayout(scaled,
			(int)Math.floor(x * zoom + fractionalX),
			(int)Math.floor(y * zoom + fractionalY),
			selectionStart, selectionEnd, selectionBackground, selectionForeground);
	scaled.dispose();
}

/** @@see Graphics#fillArc(int, int, int, int, int, int) */
public void fillArc(int x, int y, int w, int h, int offset, int sweep) {
	Rectangle z = zoomFillRect(x, y, w, h);
	if (z.isEmpty() || sweep == 0)
		return;
	graphics.fillArc(z, offset, sweep);
}

/** @@see Graphics#fillGradient(int, int, int, int, boolean) */
public void fillGradient(int x, int y, int w, int h, boolean vertical) {
	graphics.fillGradient(zoomFillRect(x, y, w, h), vertical);
}

/** @@see Graphics#fillOval(int, int, int, int) */
public void fillOval(int x, int y, int w, int h) {
	graphics.fillOval(zoomFillRect(x, y, w, h));
}

/**
 * @@see Graphics#fillPolygon(int[])
 */
public void fillPolygon(int[] points) {
	graphics.fillPolygon(zoomPointList(points));
}

/** @@see Graphics#fillPolygon(PointList) */
public void fillPolygon(PointList points) {
	graphics.fillPolygon(zoomPointList(points.toIntArray()));
}

/** @@see Graphics#fillRectangle(int, int, int, int) */
public void fillRectangle(int x, int y, int w, int h) {
	graphics.fillRectangle(zoomFillRect(x, y, w, h));
}

/** @@see Graphics#fillRoundRectangle(Rectangle, int, int) */
public void fillRoundRectangle(Rectangle r, int arcWidth, int arcHeight) {
	graphics.fillRoundRectangle(zoomFillRect(r.x, r.y, r.width, r.height),
		(int)(arcWidth * zoom),
		(int)(arcHeight * zoom));
}

/** @@see Graphics#fillString(String, int, int) */
public void fillString(String s, int x, int y) {
	if (allowText)
		graphics.fillString(s, zoomTextPoint(x, y));
}

/** @@see Graphics#fillText(String, int, int) */
public void fillText(String s, int x, int y) {
	if (allowText)
		graphics.fillText(s, zoomTextPoint(x, y));
}

/**
 * @@see Graphics#getAbsoluteScale()
 */
public double getAbsoluteScale() {
	return zoom * graphics.getAbsoluteScale();
}

/**
 * @@see Graphics#getAlpha()
 */
public int getAlpha() {
	return graphics.getAlpha();
}

/**
 * @@see Graphics#getAntialias()
 */
public int getAntialias() {
	return graphics.getAntialias();
}

/** @@see Graphics#getBackgroundColor() */
public Color getBackgroundColor() {
	return graphics.getBackgroundColor();
}

Font getCachedFont(FontKey key) {
	FontData data = key.font.getFontData()[0];		
	data.setHeight(key.height);
	return FontRegistry.getInstance().getFont(Display.getCurrent(), data);
}

/**
 * Allows clients to reset the font cache utilized by the ScaledGraphics in
 * order to avoid caching more objects then necessary.
 */
static public void resetFontCache() {
	FontRegistry.getInstance().clearFontCache();
}

FontData getCachedFontData(Font f) {
	FontData data = (FontData)fontDataCache.get(f);
	if (data != null)
		return data;
	data = getLocalFont().getFontData()[0];
	fontDataCache.put(f, data);
	return data;
}

/** @@see Graphics#getClip(Rectangle) */
public Rectangle getClip(Rectangle rect) {
	graphics.getClip(rect);
	int x = (int)(rect.x / zoom);
	int y = (int)(rect.y / zoom);
	/*
	 * If the clip rectangle is queried, perform an inverse zoom, and take the ceiling of
	 * the resulting double. This is necessary because forward scaling essentially performs
	 * a floor() function. Without this, figures will think that they don't need to paint
	 * when actually they do.
	 */
	rect.width = (int)Math.ceil(rect.right() / zoom) - x;
	rect.height = (int)Math.ceil(rect.bottom() / zoom) - y;
	rect.x = x;
	rect.y = y;
	return rect;
}

/**
 * @@see Graphics#getFillRule()
 */
public int getFillRule() {
	return graphics.getFillRule();
}

/** @@see Graphics#getFont() */
public Font getFont() {
	return getLocalFont();
}

/** @@see Graphics#getFontMetrics() */
public FontMetrics getFontMetrics() {
	return FigureUtilities.getFontMetrics(localFont);
}

/** @@see Graphics#getForegroundColor() */
public Color getForegroundColor() {
	return graphics.getForegroundColor();
}

/**
 * @@see Graphics#getInterpolation()
 */
public int getInterpolation() {
	return graphics.getInterpolation();
}

/**
 * @@see Graphics#getLineCap()
 */
public int getLineCap() {
	return graphics.getLineCap();
}

/**
 * @@see Graphics#getLineJoin()
 */
public int getLineJoin() {
	return graphics.getLineJoin();
}

/** @@see Graphics#getLineStyle() */
public int getLineStyle() {
	return graphics.getLineStyle();
}

/** @@see Graphics#getLineWidth() */
public int getLineWidth() {
	return getLocalLineWidth();
}

private Font getLocalFont() {
	return localFont;
}

private int getLocalLineWidth() {
	return localLineWidth;
}

/**
 * @@see Graphics#getTextAntialias()
 */
public int getTextAntialias() {
	return graphics.getTextAntialias();
}

/** @@see Graphics#getXORMode() */
public boolean getXORMode() {
	return graphics.getXORMode();
}

/** @@see Graphics#popState() */
public void popState() {
	graphics.popState();
	stackPointer--;
	restoreLocalState((State)stack.get(stackPointer));
}

/** @@see Graphics#pushState() */
public void pushState() {
	State s;
	if (stack.size() > stackPointer) {
		s = (State)stack.get(stackPointer);
		s.setValues(zoom, fractionalX, fractionalY, getLocalFont(), localLineWidth);
	} else {
		stack.add(new State(zoom, fractionalX, fractionalY, getLocalFont(), 
								localLineWidth));
	}
	stackPointer++;

	graphics.pushState();
}

private void restoreLocalState(State state) {
	this.fractionalX = state.appliedX;
	this.fractionalY = state.appliedY;
	setScale(state.zoom);
	setLocalFont(state.font);
	setLocalLineWidth(state.lineWidth);
}

/** @@see Graphics#restoreState() */
public void restoreState() {
	graphics.restoreState();
	restoreLocalState((State)stack.get(stackPointer - 1));
}

/** @@see Graphics#scale(double) */
public void scale(double amount) {
	setScale(zoom * amount);
}

/**
 * This method requires advanced graphics support. A check should be made to
 * ensure advanced graphics is supported in the user's environment before
 * calling this method. See {@@link GCUtilities#supportsAdvancedGraphics()}.
 * 
 * @@see Graphics#setAlpha(int)
 */
public void setAlpha(int alpha) {
    if (!GCUtilities.supportsAdvancedGraphics()) { 
        logAdvancedGraphicsWarning();
        return;
    }
	graphics.setAlpha(alpha);
}

/**
 * This method requires advanced graphics support. A check should be made to
 * ensure advanced graphics is supported in the user's environment before
 * calling this method. See {@@link GCUtilities#supportsAdvancedGraphics()}.
 * 
 * @@see Graphics#setAntialias(int)
 */
public void setAntialias(int value) {
    if (!GCUtilities.supportsAdvancedGraphics()) { 
        logAdvancedGraphicsWarning();
        return;
    }
	graphics.setAntialias(value);
}

/** @@see Graphics#setBackgroundColor(Color) */
public void setBackgroundColor(Color rgb) {
	graphics.setBackgroundColor(rgb);
}

/**
 * @@see Graphics#setBackgroundPattern(Pattern)
 */
public void setBackgroundPattern(Pattern pattern) {
	graphics.setBackgroundPattern(pattern);  
}

/** @@see Graphics#setClip(Rectangle) */
public void setClip(Rectangle r) {
	graphics.setClip(zoomClipRect(r));
}

/**
 * @@see Graphics#setFillRule(int)
 */
public void setFillRule(int rule) {
	graphics.setFillRule(rule);
}

/** @@see Graphics#setFont(Font) */
public void setFont(Font f) {
	setLocalFont(f);
}

/** @@see Graphics#setForegroundColor(Color) */
public void setForegroundColor(Color rgb) {
	graphics.setForegroundColor(rgb);
}

/**
 * @@see Graphics#setForegroundPattern(Pattern)
 */
public void setForegroundPattern(Pattern pattern) {
	graphics.setForegroundPattern(pattern);
}

/**
 * This method requires advanced graphics support. A check should be made to
 * ensure advanced graphics is supported in the user's environment before
 * calling this method. See {@@link GCUtilities#supportsAdvancedGraphics()}.
 * 
 * @@see org.eclipse.draw2d.Graphics#setInterpolation(int)
 */
public void setInterpolation(int interpolation) {
    if (!GCUtilities.supportsAdvancedGraphics()) { 
        logAdvancedGraphicsWarning();
        return;
    }
	graphics.setInterpolation(interpolation);
}

/**
 * @@see Graphics#setLineCap(int)
 */
public void setLineCap(int cap) {
	graphics.setLineCap(cap);
}

/**
 * @@see Graphics#setLineDash(int[])
 */
public void setLineDash(int[] dash) {
	graphics.setLineDash(dash);
}

/**
 * @@see Graphics#setLineJoin(int)
 */
public void setLineJoin(int join) {
	graphics.setLineJoin(join);
}

/** @@see Graphics#setLineStyle(int) */
public void setLineStyle(int style) {
	graphics.setLineStyle(style);
}

/** @@see Graphics#setLineWidth(int) */
public void setLineWidth(int width) {
	setLocalLineWidth(width);
}

private void setLocalFont(Font f) {
	localFont = f;
	graphics.setFont(zoomFont(f));
}

private void setLocalLineWidth(int width) {
	localLineWidth = width;
	graphics.setLineWidth(zoomLineWidth(width));
}

void setScale(double value) {
	if (zoom == value)
		return;
	this.zoom = value;
	graphics.setFont(zoomFont(getLocalFont()));
	graphics.setLineWidth(zoomLineWidth(localLineWidth));
}

/**
 * This method requires advanced graphics support. A check should be made to
 * ensure advanced graphics is supported in the user's environment before
 * calling this method. See {@@link GCUtilities#supportsAdvancedGraphics()}.
 * 
 * @@see Graphics#setTextAntialias(int)
 */
public void setTextAntialias(int value) {
    if (!GCUtilities.supportsAdvancedGraphics()) { 
        logAdvancedGraphicsWarning();
        return;
    }
	graphics.setTextAntialias(value);
}	

/** @@see Graphics#setXORMode(boolean) */
public void setXORMode(boolean b) {
	graphics.setXORMode(b);
}

/** @@see Graphics#translate(int, int) */
public void translate(int dx, int dy) {
	// fractionalX/Y is the fractional part left over from previous 
	// translates that gets lost in the integer approximation.
	double dxFloat = dx * zoom + fractionalX;
	double dyFloat = dy * zoom + fractionalY;
	fractionalX = dxFloat - Math.floor(dxFloat);
	fractionalY = dyFloat - Math.floor(dyFloat);
	graphics.translate((int)Math.floor(dxFloat), (int)Math.floor(dyFloat));
}

private Rectangle zoomClipRect(Rectangle r) {
	tempRECT.x = (int)(Math.floor(r.x * zoom + fractionalX));
	tempRECT.y = (int)(Math.floor(r.y * zoom + fractionalY));
	tempRECT.width = (int)(Math.ceil(((r.x + r.width) * zoom + fractionalX))) - tempRECT.x;
	tempRECT.height = (int)(Math.ceil(((r.y + r.height) * zoom + fractionalY))) - tempRECT.y;
	return tempRECT;
}

private Rectangle zoomFillRect(int x, int y, int w, int h) {
	tempRECT.x = (int)(Math.floor((x * zoom + fractionalX)));
	tempRECT.y = (int)(Math.floor((y * zoom + fractionalY)));
	tempRECT.width = (int)(Math.floor(((x + w - 1) * zoom + fractionalX))) - tempRECT.x + 1;
	tempRECT.height = (int)(Math.floor(((y + h - 1) * zoom + fractionalY))) - tempRECT.y + 1;
	return tempRECT;
}

Font zoomFont(Font f) {
	if (f == null)
		f = Display.getCurrent().getSystemFont();
	FontData data = getCachedFontData(f);
	int zoomedFontHeight = zoomFontHeight(data.getHeight());
	allowText = zoomedFontHeight > 0;
	fontKey.setValues(f, zoomedFontHeight);
	return getCachedFont(fontKey);
}

int zoomFontHeight(int height) {
	return (int)(zoom * height);
}

int zoomLineWidth(int w) {
	/*
	 * We introduced line width zoom in GMF 2.1.
	 * Unfortunately GMF 2.0 clients used HiMetric map mode and called
	 * setLineWidth(1) rather than setLineWidth(getMapMode().LPtoDP(1)).
	 * This small piece of code detects this case and simply returns the
	 * line width.
	 */
	if (zoom < 0.04 && w <= 5) {
		return w;
	}
	/*
	 * We interestingly add 0.1 to eliminate rounding errors with HiMetric
	 * map mode. This has no effect with identity/pixel map mode.
	 */
	return (int) ((zoom * w) + 0.1);
}

private int[] zoomPointList(int[] points) {
	int[] scaled = null;

	// Look in cache for a integer array with the same length as 'points'
	for (int i = 0; i < intArrayCache.length; i++) {
		if (intArrayCache[i].length == points.length) {
			scaled = intArrayCache[i];
			
			// Move this integer array up one notch in the array
			if (i != 0) {
				int[] temp = intArrayCache[i - 1];
				intArrayCache[i - 1] = scaled;
				intArrayCache[i] = temp;	
			}
		}
	}
	
	// If no match is found, take the one that is last and resize it.
	if (scaled == null) {
		intArrayCache[intArrayCache.length - 1] = new int[points.length];
		scaled = intArrayCache[intArrayCache.length - 1];
	}
	
	// Scale the points
	for (int i = 0; (i + 1) < points.length; i += 2) {
		scaled[i] = (int)(Math.floor((points[i] * zoom + fractionalX)));
		scaled[i + 1] = (int)(Math.floor((points[i + 1] * zoom + fractionalY)));
	}
	return scaled;
}	

protected Rectangle zoomRect(int x, int y, int w, int h) {
	tempRECT.x = (int)(Math.floor(x * zoom + fractionalX));
	tempRECT.y = (int)(Math.floor(y * zoom + fractionalY));
	tempRECT.width = (int)(Math.floor(((x + w) * zoom + fractionalX))) - tempRECT.x;
	tempRECT.height = (int)(Math.floor(((y + h) * zoom + fractionalY))) - tempRECT.y;
	return tempRECT;
}

private TextLayout zoomTextLayout(TextLayout layout) {
	TextLayout zoomed = new TextLayout(Display.getCurrent());
	zoomed.setText(layout.getText());
	
	int zoomWidth = -1;
	
	if (layout.getWidth() != -1)
		zoomWidth = ((int)(layout.getWidth() * zoom));
		
	if (zoomWidth < -1 || zoomWidth == 0)
		return null;
	
	zoomed.setFont(zoomFont(layout.getFont()));
	zoomed.setAlignment(layout.getAlignment());
	zoomed.setAscent(layout.getAscent());
	zoomed.setDescent(layout.getDescent());
	zoomed.setOrientation(layout.getOrientation());
	zoomed.setSegments(layout.getSegments());
	zoomed.setSpacing(layout.getSpacing());
	zoomed.setTabs(layout.getTabs());
	
	zoomed.setWidth(zoomWidth);
	int length = layout.getText().length();
	if (length > 0) {
		int start = 0, offset = 1;
		TextStyle style = null, lastStyle = layout.getStyle(0);
		for (; offset <= length; offset++) {
			if (offset != length
					&& (style = layout.getStyle(offset)) == lastStyle)
				continue;
			int end = offset - 1;
			
			if (lastStyle != null) {
				TextStyle zoomedStyle = new TextStyle(zoomFont(lastStyle.font),
						lastStyle.foreground, lastStyle.background);
                zoomedStyle.metrics = lastStyle.metrics;
                zoomedStyle.rise = lastStyle.rise;
                zoomedStyle.strikeout = lastStyle.strikeout;
                zoomedStyle.underline = lastStyle.underline;
				zoomed.setStyle(zoomedStyle, start, end);
			}
			lastStyle = style;
			start = offset;
		}
	}
	return zoomed;
}

Point zoomTextPoint(int x, int y) {
	if (localCache.font != localFont) {
		//Font is different, re-calculate its height
		FontMetrics metric = FigureUtilities.getFontMetrics(localFont); 
		localCache.height = metric.getHeight() - metric.getDescent();
		localCache.font = localFont;
	}
	if (targetCache.font != graphics.getFont()) {
		FontMetrics metric = graphics.getFontMetrics();
		targetCache.font = graphics.getFont();
		targetCache.height = metric.getHeight() - metric.getDescent();
	}
	return new Point(((int)(Math.floor((x * zoom) + fractionalX))),
						(int)(Math.floor((y + localCache.height - 1) * zoom 
											- targetCache.height + 1 + fractionalY)));
}


protected Graphics getGraphics() {
	return graphics;
}

/**
 * Logs a warning once if advanced graphics support is not available.
 */
private void logAdvancedGraphicsWarning() {
    if (!advancedGraphicsWarningLogged) {
        if (Window.getDefaultOrientation() == SWT.RIGHT_TO_LEFT) {
            Log
                .warning(
                    Draw2dPlugin.getInstance(),
                    IStatus.WARNING,
                    "Advanced graphics support is not available in right-to-left mode.  Diagrams might not look as nice as they could in left-to-right mode."); //$NON-NLS-1$
        } else {
            Log
                .warning(
                    Draw2dPlugin.getInstance(),
                    IStatus.WARNING,
                    "Unable to load advanced graphics library.  Diagrams might not look as nice as they could with an advanced graphics library installed (e.g. Cairo or GDI+)"); //$NON-NLS-1$
        }
        advancedGraphicsWarningLogged = true;
    }
}
}
@


1.11
log
@[234716] gmf-head ahunter 080529 Note and Geoshape edge thickness visually increases when zoom is < 100%
@
text
@d9 2
a10 1
 *    IBM Corporation - initial API and implementation 
d38 1
d598 7
d628 7
@


1.11.2.1
log
@[244297] gmf_R2_1_maintenance aboyko 080828 ScaledGraphics should allow one to set background and foregroud patterns
@
text
@d9 1
a9 2
 *    IBM Corporation - initial API and implementation
 *    Mariot Chauvin <mariot.chauvin@@obeo.fr> - patch 244297
a36 1
import org.eclipse.swt.graphics.Pattern;
a595 7
/**
 * @@see Graphics#setBackgroundPattern(Pattern)
 */
public void setBackgroundPattern(Pattern pattern) {
	graphics.setBackgroundPattern(pattern);  
}

a618 7
 * @@see Graphics#setForegroundPattern(Pattern)
 */
public void setForegroundPattern(Pattern pattern) {
	graphics.setForegroundPattern(pattern);
}

/**
@


1.10
log
@[230056] gmf-head ahunter 080503 setLineWidth in ScaledGraphics does not support the zoom factor
@
text
@d751 1
a751 1
	if (zoom < 0.04 && w < 25) {
@


1.9
log
@[173686] gmf_head crevells 070209 Clients of ScaledGraphics have issues when using setAlpha() and the advanced graphics library isn't present
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2007 IBM Corporation and others.
d51 2
a52 1
 * 
d744 15
a758 1
	return w;
@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2006 IBM Corporation and others.
d20 1
d27 5
d140 2
d561 4
d568 4
d576 4
d583 4
d618 4
d625 4
d682 4
d689 4
d855 21
@


1.7
log
@bugzilla 130382 gef-head gmf-head sshaw 060404 ScaledGraphics does not copy all TextStyle properties in zoomTextLayout
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2005  IBM Corporation and others.
@


1.7.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2006 IBM Corporation and others.
@


1.6
log
@bugzilla 130796 gmf-head sshaw 060307 Icons disappear with Zoom level other then 100%
@
text
@d780 4
@


1.5
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d22 1
d204 10
d215 1
a215 4
		(int)(Math.floor((x * zoom + fractionalX))), 
		(int)(Math.floor((y * zoom + fractionalY))),
		(int)(Math.floor((size.width * zoom + fractionalX))), 
		(int)(Math.floor((size.height * zoom + fractionalY))));
@


1.4
log
@bugzilla 111210 gmf-head sshaw 051012 Running out of SWT handles / Excessive GDI handles
@
text
@a24 1
import org.eclipse.gmf.runtime.draw2d.ui.internal.l10n.Draw2dResourceManager;
d392 1
a392 1
	return Draw2dResourceManager.getInstance().getFont(Display.getCurrent(), data);
d400 1
a400 1
	Draw2dResourceManager.getInstance().clearFontCache();
@


1.3
log
@bugzilla 110242 gmf-head sshaw 051005 Inconsistencies in MapModeGraphics and IMapMode
@
text
@d396 8
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d25 1
a34 2
import org.eclipse.gmf.runtime.draw2d.ui.internal.l10n.Draw2dResourceManager;

d44 1
d47 3
d51 2
a52 53
	extends Graphics {
	/**
	 * The internal state of the scaled graphics.
	 */
	protected static class State {
		private double zoom;
		private double appliedX;
		private double appliedY;
		private Font font;
		private int lineWidth; 

		/**
		 * Constructs a new, uninitialized State object.
		 */
		protected State() {
			// Empty block
		}
		
		/**
		 * Constructs a new State object and initializes the properties based on the given 
		 * values.
		 * 
		 * @@param zoom the zoom factor
		 * @@param x the x offset
		 * @@param y the y offset
		 * @@param font the font
		 * @@param lineWidth the line width
		 */
		protected State(double zoom, double x, double y, Font font, int lineWidth) {
			this.zoom = zoom;
			this.appliedX = x;
			this.appliedY = y;
			this.font = font;
			this.lineWidth = lineWidth;
		}
		
		/**
		 * Sets all the properties of the state object.
		 * @@param zoom the zoom factor
		 * @@param x the x offset
		 * @@param y the y offset
		 * @@param font the font
		 * @@param lineWidth the line width
		 */
		protected void setValues(double zoom, double x, double y, 
									Font font, int lineWidth) {
			this.zoom = zoom;
			this.appliedX = x;
			this.appliedY = y;
			this.font = font;
			this.lineWidth = lineWidth;
		}
	}
d54 4
a57 26
	static class FontKey {
		Font font;
		int height;
		
		/**
		 * Default constructor
		 */
		protected FontKey() {
			// Empty block
		}
		
		/**
		 * Constructor
		 * 
		 * @@param font the <code>Font</code> to be stored in the key
		 * @@param height the height of the font
		 */
		protected FontKey(Font font, int height) {
			this.font = font;
			this.height = height;
		}
		
		public boolean equals(Object obj) {
			return (((FontKey)obj).font.equals(font) 
					&& ((FontKey)obj).height == height);
		}
d59 13
a71 3
		public int hashCode() {
			return font.hashCode() ^ height;
		}
d73 2
a74 10
		/**
		 * Sets the values that the key utilizes to calculate the hash value.
		 * 
		 * @@param font the <code>Font</code> to be stored in the key
		 * @@param height the height of the font
		 */
		protected void setValues(Font font, int height) {
			this.font = font;
			this.height = height;
		}
d77 3
a79 25
	private static class FontHeightCache {
		Font font;
		int height;
	}

	private static final Rectangle TEMP = new Rectangle();
	private Map fontDataCache = new HashMap();

	private FontHeightCache localCache = new FontHeightCache();
	private FontHeightCache targetCache = new FontHeightCache();
	private Graphics graphics;
	private Font localFont;
	private int localLineWidth;
	private double fractionalX;
	private double fractionalY;
	double zoom = 1.0;
	private List stack = new ArrayList();
	private int stackPointer = 0;
	private FontKey fontKey = new FontKey();
	private boolean allowText = true;
	private static int[][] intArrayCache = new int[8][];

	static {
		for (int i = 0; i < intArrayCache.length; i++)
			intArrayCache[i] = new int[i + 1];
d81 11
d94 29
a122 2
	 * Constructs a new ScaledGraphics based on the given Graphics object.
	 * @@param g the base graphics object
d124 7
a130 19
	public ScaledGraphics(Graphics g) {
		graphics = g;
		localFont = g.getFont();
		localLineWidth = g.getLineWidth();
	}

	/** @@see Graphics#clipRect(Rectangle) */
	public void clipRect(Rectangle r) {
		graphics.clipRect(zoomClipRect(r));
	}

	/** @@see Graphics#dispose() */
	public void dispose() {
		//Remove all states from the stack
		while (stackPointer > 0) {
			popState();
		}
		
		// Resource manager handles fonts 
d132 41
d174 9
a182 6
	/** @@see Graphics#drawArc(int, int, int, int, int, int) */
	public void drawArc(int x, int y, int w, int h, int offset, int sweep) {
		Rectangle z = zoomRect(x, y, w, h);
		if (z.isEmpty() || sweep == 0)
			return;
		graphics.drawArc(z, offset, sweep);
d184 63
d248 91
a338 7
	/** @@see Graphics#fillArc(int, int, int, int, int, int) */
	public void fillArc(int x, int y, int w, int h, int offset, int sweep) {
		Rectangle z = zoomFillRect(x, y, w, h);
		if (z.isEmpty() || sweep == 0)
			return;
		graphics.fillArc(z, offset, sweep);
	}
d340 4
a343 4
	/** @@see Graphics#fillGradient(int, int, int, int, boolean) */
	public void fillGradient(int x, int y, int w, int h, boolean vertical) {
		graphics.fillGradient(zoomFillRect(x, y, w, h), vertical);
	}
d345 6
a350 4
	/** @@see Graphics#drawFocus(int, int, int, int) */
	public void drawFocus(int x, int y, int w, int h) {
		graphics.drawFocus(zoomRect(x, y, w, h));
	}
d352 5
a356 9
	/** @@see Graphics#drawImage(Image, int, int) */
	public void drawImage(Image srcImage, int x, int y) {
		org.eclipse.swt.graphics.Rectangle size = srcImage.getBounds();
		graphics.drawImage(srcImage, 0, 0, size.width, size.height,
			(int)(Math.floor((x * zoom + fractionalX))), 
			(int)(Math.floor((y * zoom + fractionalY))),
			(int)(Math.floor((size.width * zoom + fractionalX))), 
			(int)(Math.floor((size.height * zoom + fractionalY))));
	}
d358 5
a362 9
	/** @@see Graphics#drawImage(Image, int, int, int, int, int, int, int, int) */
	public void drawImage(Image srcImage, int sx, int sy, int sw, int sh,
											int tx, int ty, int tw, int th) {
		//"t" == target rectangle, "s" = source
				 
		Rectangle t = zoomRect(tx, ty, tw, th);
		if (!t.isEmpty())
			graphics.drawImage(srcImage, sx, sy, sw, sh, t.x, t.y, t.width, t.height);
	}
d364 6
a369 8
	/** @@see Graphics#drawLine(int, int, int, int) */
	public void drawLine(int x1, int y1, int x2, int y2) {
		graphics.drawLine(
			(int)(Math.floor((x1 * zoom + fractionalX))),
			(int)(Math.floor((y1 * zoom + fractionalY))),
			(int)(Math.floor((x2 * zoom + fractionalX))),
			(int)(Math.floor((y2 * zoom + fractionalY))));
	}
d371 6
a376 4
	/** @@see Graphics#drawOval(int, int, int, int) */
	public void drawOval(int x, int y, int w, int h) {
		graphics.drawOval(zoomRect(x, y, w, h));
	}
d378 6
a383 4
	/** @@see Graphics#fillOval(int, int, int, int) */
	public void fillOval(int x, int y, int w, int h) {
		graphics.fillOval(zoomFillRect(x, y, w, h));
	}
d385 4
a388 6
	/**
	 * @@see Graphics#drawPolygon(int[])
	 */
	public void drawPolygon(int[] points) {
		graphics.drawPolygon(zoomPointList(points));
	}
d390 5
a394 4
	/** @@see Graphics#drawPolygon(PointList) */
	public void drawPolygon(PointList points) {
		graphics.drawPolygon(zoomPointList(points.toIntArray()));
	}
d396 8
a403 4
	/** @@see Graphics#drawPoint(int, int) */
	public void drawPoint(int x, int y) {
		graphics.drawPoint((int)Math.floor(x * zoom + fractionalX),(int)Math.floor(y * zoom + fractionalY));
	}
d405 10
a414 2
	/**
	 * @@see Graphics#fillPolygon(int[])
d416 18
a433 3
	public void fillPolygon(int[] points) {
		graphics.fillPolygon(zoomPointList(points));
	}
d435 4
a438 4
	/** @@see Graphics#fillPolygon(PointList) */
	public void fillPolygon(PointList points) {
		graphics.fillPolygon(zoomPointList(points.toIntArray()));
	}
d440 4
a443 6
	/**
	 * @@see Graphics#drawPolyline(int[])
	 */
	public void drawPolyline(int[] points) {
		graphics.drawPolyline(zoomPointList(points));
	}
d445 6
a450 4
	/** @@see Graphics#drawPolyline(PointList) */
	public void drawPolyline(PointList points) {
		graphics.drawPolyline(zoomPointList(points.toIntArray()));
	}
d452 6
a457 4
	/** @@see Graphics#drawRectangle(int, int, int, int) */
	public void drawRectangle(int x, int y, int w, int h) {
		graphics.drawRectangle(zoomRect(x, y, w, h));
	}
d459 6
a464 4
	/** @@see Graphics#fillRectangle(int, int, int, int) */
	public void fillRectangle(int x, int y, int w, int h) {
		graphics.fillRectangle(zoomFillRect(x, y, w, h));
	}
d466 4
a469 6
	/** @@see Graphics#drawRoundRectangle(Rectangle, int, int) */
	public void drawRoundRectangle(Rectangle r, int arcWidth, int arcHeight) {
		graphics.drawRoundRectangle(zoomRect(r.x, r.y, r.width, r.height),
			(int)(arcWidth * zoom),
			(int)(arcHeight * zoom));
	}
d471 4
a474 6
	/** @@see Graphics#fillRoundRectangle(Rectangle, int, int) */
	public void fillRoundRectangle(Rectangle r, int arcWidth, int arcHeight) {
		graphics.fillRoundRectangle(zoomFillRect(r.x, r.y, r.width, r.height),
			(int)(arcWidth * zoom),
			(int)(arcHeight * zoom));
	}
d476 3
a478 5
	/** @@see Graphics#drawString(String, int, int) */
	public void drawString(String s, int x, int y) {
		if (allowText)
			graphics.drawString(s, zoomTextPoint(x, y));
	}
d480 3
a482 5
	/** @@see Graphics#fillString(String, int, int) */
	public void fillString(String s, int x, int y) {
		if (allowText)
			graphics.fillString(s, zoomTextPoint(x, y));
	}
d484 6
a489 5
	/** @@see Graphics#drawText(String, int, int) */
	public void drawText(String s, int x, int y) {
		if (allowText)
			graphics.drawText(s, zoomTextPoint(x, y));
	}
d491 4
a494 7
	/**
	 * @@see org.eclipse.draw2d.Graphics#drawText(java.lang.String, int, int, int)
	 */
	public void drawText(String s, int x, int y, int style) {
		if (allowText)
			graphics.drawText(s, zoomTextPoint(x, y), style);
	}
d496 6
a501 12
	/**
	 * @@see Graphics#drawTextLayout(TextLayout, int, int, int, int, Color, Color)
	 */
	public void drawTextLayout(TextLayout layout, int x, int y, int selectionStart,
			int selectionEnd, Color selectionForeground, Color selectionBackground) {
		TextLayout scaled = zoomTextLayout(layout);
		graphics.drawTextLayout(scaled,
				(int)Math.floor(x * zoom + fractionalX),
				(int)Math.floor(y * zoom + fractionalY),
				selectionStart, selectionEnd, selectionBackground, selectionForeground);
		scaled.dispose();
	}
d503 9
a511 4
	/** @@see Graphics#fillText(String, int, int) */
	public void fillText(String s, int x, int y) {
		if (allowText)
			graphics.fillText(s, zoomTextPoint(x, y));
d513 1
d515 2
a516 4
	/** @@see Graphics#getBackgroundColor() */
	public Color getBackgroundColor() {
		return graphics.getBackgroundColor();
	}
d518 7
a524 17
	/** @@see Graphics#getClip(Rectangle) */
	public Rectangle getClip(Rectangle rect) {
		graphics.getClip(rect);
		int x = (int)(rect.x / zoom);
		int y = (int)(rect.y / zoom);
		/*
		 * If the clip rectangle is queried, perform an inverse zoom, and take the ceiling of
		 * the resulting double. This is necessary because forward scaling essentially performs
		 * a floor() function. Without this, figures will think that they don't need to paint
		 * when actually they do.
		 */
		rect.width = (int)Math.ceil(rect.right() / zoom) - x;
		rect.height = (int)Math.ceil(rect.bottom() / zoom) - y;
		rect.x = x;
		rect.y = y;
		return rect;
	}
d526 5
a530 4
	/** @@see Graphics#getFont() */
	public Font getFont() {
		return getLocalFont();
	}
d532 4
a535 4
	/** @@see Graphics#getFontMetrics() */
	public FontMetrics getFontMetrics() {
		return FigureUtilities.getFontMetrics(localFont);
	}
d537 6
a542 4
	/** @@see Graphics#getForegroundColor() */
	public Color getForegroundColor() {
		return graphics.getForegroundColor();
	}
d544 6
a549 4
	/** @@see Graphics#getLineStyle() */
	public int getLineStyle() {
		return graphics.getLineStyle();
	}
d551 4
a554 4
	/** @@see Graphics#getLineWidth() */
	public int getLineWidth() {
		return getLocalLineWidth();
	}
d556 4
a559 3
	private Font getLocalFont() {
		return localFont;
	}
d561 6
a566 3
	private int getLocalLineWidth() {
		return localLineWidth;
	}
d568 4
a571 6
	/**
	 * @@see org.eclipse.draw2d.Graphics#getAbsoluteScale()
	 */
	public double getAbsoluteScale() {
		return zoom * graphics.getAbsoluteScale();
	}
d573 4
a576 23
	/** @@see Graphics#getXORMode() */
	public boolean getXORMode() {
		return graphics.getXORMode();
	}

	/** @@see Graphics#popState() */
	public void popState() {
		graphics.popState();
		stackPointer--;
		restoreLocalState((State)stack.get(stackPointer));
	}

	/** @@see Graphics#pushState() */
	public void pushState() {
		State s;
		if (stack.size() > stackPointer) {
			s = (State)stack.get(stackPointer);
			s.setValues(zoom, fractionalX, fractionalY, getLocalFont(), localLineWidth);
		} else {
			stack.add(new State(zoom, fractionalX, fractionalY, getLocalFont(), 
									localLineWidth));
		}
		stackPointer++;
d578 6
a583 2
		graphics.pushState();
	}
d585 6
a590 7
	private void restoreLocalState(State state) {
		this.fractionalX = state.appliedX;
		this.fractionalY = state.appliedY;
		setScale(state.zoom);
		setLocalFont(state.font);
		setLocalLineWidth(state.lineWidth);
	}
d592 6
a597 5
	/** @@see Graphics#restoreState() */
	public void restoreState() {
		graphics.restoreState();
		restoreLocalState((State)stack.get(stackPointer - 1));
	}
d599 6
a604 4
	/** @@see Graphics#scale(double) */
	public void scale(double amount) {
		setScale(zoom * amount);
	}
d606 4
a609 7
	void setScale(double value) {
		if (zoom == value)
			return;
		this.zoom = value;
		graphics.setFont(zoomFont(getLocalFont()));
		graphics.setLineWidth(zoomLineWidth(localLineWidth));
	}
d611 4
a614 14
	Font getCachedFont(FontKey key) {
		FontData data = key.font.getFontData()[0];		
		data.setHeight(key.height);
		return Draw2dResourceManager.getInstance().getFont(Display.getCurrent(), data);
	}
	
	FontData getCachedFontData(Font f) {
		FontData data = (FontData)fontDataCache.get(f);
		if (data != null)
			return data;
		data = getLocalFont().getFontData()[0];
		fontDataCache.put(f, data);
		return data;
	}
d616 4
a619 3
	Font createFont(FontData data) {
		return new Font(Display.getCurrent(), data);
	}
d621 4
a624 4
	/** @@see Graphics#setBackgroundColor(Color) */
	public void setBackgroundColor(Color rgb) {
		graphics.setBackgroundColor(rgb);
	}
d626 7
a632 4
	/** @@see Graphics#setClip(Rectangle) */
	public void setClip(Rectangle r) {
		graphics.setClip(zoomClipRect(r));
	}
d634 11
a644 4
	/** @@see Graphics#setFont(Font) */
	public void setFont(Font f) {
		setLocalFont(f);
	}
d646 10
a655 4
	/** @@see Graphics#setForegroundColor(Color) */
	public void setForegroundColor(Color rgb) {
		graphics.setForegroundColor(rgb);
	}
d657 7
a663 4
	/** @@see Graphics#setLineStyle(int) */
	public void setLineStyle(int style) {
		graphics.setLineStyle(style);
	}
d665 7
a671 4
	/** @@see Graphics#setLineWidth(int) */
	public void setLineWidth(int width) {
		setLocalLineWidth(width);
	}
d673 9
a681 4
	private void setLocalFont(Font f) {
		localFont = f;
		graphics.setFont(zoomFont(f));
	}
d683 3
a685 4
	private void setLocalLineWidth(int width) {
		localLineWidth = width;
		graphics.setLineWidth(zoomLineWidth(width));
	}	
d687 3
a689 4
	/** @@see Graphics#setXORMode(boolean) */
	public void setXORMode(boolean b) {
		graphics.setXORMode(b);
	}
d691 2
a692 10
	/** @@see Graphics#translate(int, int) */
	public void translate(int dx, int dy) {
		// fractionalX/Y is the fractional part left over from previous 
		// translates that gets lost in the integer approximation.
		double dxFloat = dx * zoom + fractionalX;
		double dyFloat = dy * zoom + fractionalY;
		fractionalX = dxFloat - Math.floor(dxFloat);
		fractionalY = dyFloat - Math.floor(dyFloat);
		graphics.translate((int)Math.floor(dxFloat), (int)Math.floor(dyFloat));
	}
d694 4
a697 8
	private TextLayout zoomTextLayout(TextLayout layout) {
		TextLayout zoomed = new TextLayout(Display.getCurrent());
		zoomed.setText(layout.getText());
		
		int zoomWidth = -1;
		
		if (layout.getWidth() != -1)
			zoomWidth = ((int)(layout.getWidth() * zoom));
d699 5
a703 30
		if (zoomWidth < -1 || zoomWidth == 0)
			return null;
		
		zoomed.setFont(zoomFont(layout.getFont()));
		zoomed.setAlignment(layout.getAlignment());
		zoomed.setAscent(layout.getAscent());
		zoomed.setDescent(layout.getDescent());
		zoomed.setOrientation(layout.getOrientation());
		zoomed.setSegments(layout.getSegments());
		zoomed.setSpacing(layout.getSpacing());
		zoomed.setTabs(layout.getTabs());
		
		zoomed.setWidth(zoomWidth);
		int length = layout.getText().length();
		if (length > 0) {
			int start = 0, offset = 1;
			TextStyle style = null, lastStyle = layout.getStyle(0);
			for (; offset <= length; offset++) {
				if (offset != length
						&& (style = layout.getStyle(offset)) == lastStyle)
					continue;
				int end = offset - 1;
				
				if (lastStyle != null) {
					TextStyle zoomedStyle = new TextStyle(zoomFont(lastStyle.font),
							lastStyle.foreground, lastStyle.background);
					zoomed.setStyle(zoomedStyle, start, end);
				}
				lastStyle = style;
				start = offset;
a705 1
		return zoomed;
d707 22
d730 36
a765 31
	private Point zoomTextPoint(int x, int y) {
		if (localCache.font != localFont) {
			//Font is different, re-calculate its height
			FontMetrics metric = FigureUtilities.getFontMetrics(localFont); 
			localCache.height = metric.getHeight() - metric.getDescent();
			localCache.font = localFont;
		}
		if (targetCache.font != graphics.getFont()) {
			FontMetrics metric = graphics.getFontMetrics();
			targetCache.font = graphics.getFont();
			targetCache.height = metric.getHeight() - metric.getDescent();
		}
		return new Point(((int)(Math.floor((x * zoom) + fractionalX))),
							(int)(Math.floor((y + localCache.height - 1) * zoom 
												- targetCache.height + 1 + fractionalY)));
	}

	private int[] zoomPointList(int[] points) {
		int[] scaled = null;

		// Look in cache for a integer array with the same length as 'points'
		for (int i = 0; i < intArrayCache.length; i++) {
			if (intArrayCache[i].length == points.length) {
				scaled = intArrayCache[i];
				
				// Move this integer array up one notch in the array
				if (i != 0) {
					int[] temp = intArrayCache[i - 1];
					intArrayCache[i - 1] = scaled;
					intArrayCache[i] = temp;	
				}
d767 2
a769 13
		
		// If no match is found, take the one that is last and resize it.
		if (scaled == null) {
			intArrayCache[intArrayCache.length - 1] = new int[points.length];
			scaled = intArrayCache[intArrayCache.length - 1];
		}
		
		// Scale the points
		for (int i = 0; (i + 1) < points.length; i+= 2) {
			scaled[i] = (int)(Math.floor((points[i] * zoom + fractionalX)));
			scaled[i + 1] = (int)(Math.floor((points[i + 1] * zoom + fractionalY)));
		}
		return scaled;
d771 19
a790 45
	private Rectangle zoomFillRect(int x, int y, int w, int h) {
		TEMP.x = (int)(Math.floor((x * zoom + fractionalX)));
		TEMP.y = (int)(Math.floor((y * zoom + fractionalY)));
		TEMP.width = (int)(Math.floor(((x + w - 1) * zoom + fractionalX))) - TEMP.x + 1;
		TEMP.height = (int)(Math.floor(((y + h - 1) * zoom + fractionalY))) - TEMP.y + 1;
		return TEMP;
	}

	Font zoomFont(Font f) {
		if (f == null)
			f = Display.getCurrent().getSystemFont();
		FontData data = getCachedFontData(f);
		int zoomedFontHeight = zoomFontHeight(data.getHeight());
		allowText = zoomedFontHeight > 0;
		fontKey.setValues(f, zoomedFontHeight);
		return getCachedFont(fontKey);
	}

	int zoomFontHeight(int height) {
		return (int)(zoom * height);
	}	

	private Rectangle zoomClipRect(Rectangle r) {
		TEMP.x = (int)(Math.floor(r.x * zoom + fractionalX));
		TEMP.y = (int)(Math.floor(r.y * zoom + fractionalY));
		TEMP.width = (int)(Math.ceil(((r.x + r.width) * zoom + fractionalX))) - TEMP.x;
		TEMP.height = (int)(Math.ceil(((r.y + r.height) * zoom + fractionalY))) - TEMP.y;
		return TEMP;
	}

	private Rectangle zoomRect(int x, int y, int w, int h) {
		TEMP.x = (int)(Math.floor(x * zoom + fractionalX));
		TEMP.y = (int)(Math.floor(y * zoom + fractionalY));
		TEMP.width = (int)(Math.floor(((x + w) * zoom + fractionalX))) - TEMP.x;
		TEMP.height = (int)(Math.floor(((y + h) * zoom + fractionalY))) - TEMP.y;
		return TEMP;
	}

//	private Rectangle zoomRect(Rectangle r) {
//		TEMP.x = (int)(Math.floor((r.x * zoom + fractionalX)));
//		TEMP.y = (int)(Math.floor((r.y * zoom + fractionalY)));
//		TEMP.width = (int)(Math.floor((r.right() * zoom + fractionalX))) - TEMP.x;
//		TEMP.height = (int)(Math.floor((r.bottom() * zoom + fractionalY))) - TEMP.y;
//		return TEMP;
//	}
d792 4
a795 11
	int zoomLineWidth(int w) {
		return w;
	}
	
	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.draw2d.Graphics#setLineDash(int[])
	 */
	public void setLineDash(int[] dash) {
		graphics.setLineDash(dash);
	}
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 2
a2 2
/*******************************************************************************
 * Copyright (c) 2000, 2005 IBM Corporation and others.
d9 3
a11 2
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
@

