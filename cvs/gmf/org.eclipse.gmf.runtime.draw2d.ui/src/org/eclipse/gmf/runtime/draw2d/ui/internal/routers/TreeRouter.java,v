head	1.5;
access;
symbols
	v20081023-2107:1.5
	v20081022-1925:1.5
	v20081021-1810:1.5
	v20081020-0700:1.5
	v20080911-1728:1.5
	v20080911-1506:1.5
	v20080910-1520:1.5
	v20080910-1510:1.5
	v20080903-1520:1.5
	v20080903-1510:1.5
	v20080722-1827:1.5
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080610-1132:1.5
	v20080603-1553:1.5
	v20080512-1200:1.5
	v20080503-1740:1.5
	v20080501-1739:1.5
	v20080425-1959:1.5
	v20080417-1610:1.5
	v20080407-2250:1.5
	v20080407-0930:1.5
	v20080404-1111:1.5
	v20080222-1200:1.5
	v20080215-1500:1.5
	v20080215-1200:1.5
	v20080201-2010:1.5
	v20080114-1111:1.5
	v20071108-0000:1.5
	v20071003-0000:1.5
	v20070928-0000:1.5
	v20070915-0000:1.5
	v20070903-0000:1.5
	v20070830-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	v20070621-0000:1.5
	RC3_20:1.5
	v20070605-1400:1.5
	v20070601-1400:1.5
	v20070518-1300:1.5
	v20070330-1300:1.5
	v20070221-1500:1.5
	v20070208-1800:1.5
	v20070202-0200:1.4.2.1
	M4_20:1.5
	v20061218-1200:1.5
	v20061214-0000:1.5
	M3_20:1.5
	v20061013-1330:1.5
	v20060925-1700:1.4.2.1
	v20060919-0800:1.4.2.1
	M1_20:1.4
	v20060824-1600:1.4.2.1
	v20060817-1500:1.4.2.1
	v20060810-1700:1.4.2.1
	v20060803-1200:1.4.2.1
	v20060728-0500:1.4
	v20060721-1130:1.4
	v20060713-1700:1.4
	R1_0_maintenance:1.4.0.2
	R1_0:1.4
	v20060627-1200:1.4
	v20060616-1200:1.4
	v20060609-1400:1.4
	v20060531-1730:1.4
	v20060519-0800:1.4
	RC2_10:1.4
	I20060505-1400:1.4
	I20060428-1300:1.4
	I20060424-0500:1.4
	I20060424-0300:1.4
	M6_10:1.4
	I20060407-1200:1.4
	I20060331-1000:1.4
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.4
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.4
	I20060209-1815:1.4
	I20060203-0830:1.4
	I20060129-1145:1.4
	I20060127-0900:1.4
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.4
	I20051223-1100:1.4
	I20051217-0925:1.4
	I20051208-2000:1.4
	I20051201-1800:1.3
	I20051124-2000:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.2;
locks; strict;
comment	@# @;


1.5
date	2006.10.03.15.04.52;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.07.20.35.08;	author sshaw;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2005.11.04.21.27.59;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.27.43;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.52;	author sshaw;	state Exp;
branches;
next	;

1.4.2.1
date	2006.08.02.17.08.00;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.5
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/


package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

import org.eclipse.draw2d.AbsoluteBendpoint;
import org.eclipse.draw2d.Bendpoint;
import org.eclipse.draw2d.BendpointConnectionRouter;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dDebugOptions;
import org.eclipse.gmf.runtime.draw2d.ui.internal.Draw2dPlugin;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;


/**
 * @@author sshaw
 *
 * This class is a top level router for managing the individual branches in a set of
 * tree routed connections.
 */
public class TreeRouter extends BendpointConnectionRouter implements OrthogonalRouter {

	private BranchRouter branchRouter = new BranchRouter(this);
	private ArrayList connectionList = new ArrayList();
	private Dimension trunkVertex;
	private Orientation trunkOrientation;
	private boolean updatingPeers = false;
	
	static private class Orientation {

		private Orientation() {
			// Empty constructor
		}
		
		/**
		 * Constant for the top orientation 
		 */
		static public Orientation TOP = new Orientation();
		
		/**
		 * Constant for the bottom orientation 
		 */
		static public Orientation BOTTOM = new Orientation();
		
		/**
		 * Constant for the right orientation 
		 */
		static public Orientation RIGHT = new Orientation(); 
		
		/**
		 * Constant for the left orientation 
		 */
		static public Orientation LEFT = new Orientation(); 
		
		/**
		 * getEdge
		 * Method to return the edge point of the given Rectangle representative
		 * of the orientation value of the instance.
		 * 
		 * @@param bounds Rectangle to retrieve the edge value from.
		 * @@return Point that is the edge of the rectangle for the orientation of this.
		 */
		public Point getEdge(Rectangle bounds) {
			if (this == TOP)
				return bounds.getTop();
			else if (this == BOTTOM)
				return bounds.getBottom();
			else if (this == RIGHT)
				return bounds.getRight();

			return bounds.getLeft();
		}
	}
	
	/**
	 * 
	 */
	public TreeRouter() {
		super();
	}

	
	/**
	 * @@see org.eclipse.draw2d.ConnectionRouter#invalidate(Connection)
	 */
	public void invalidate(Connection conn) {
		if (conn.getSourceAnchor() == null || conn.getSourceAnchor().getOwner() == null ||
			conn.getTargetAnchor() == null || conn.getTargetAnchor().getOwner() == null)
			return;

		ListIterator li = connectionList.listIterator();
		while (li.hasNext()) {
			Connection connNext = (Connection)li.next();
			
			if (!trunkVertexEqual(connNext, conn)) {
				updateConstraint(connNext);
			}
		}
	}
	
	private boolean trunkVertexEqual(Connection connMaster, Connection connSlave) {
		PointList cmPts = connMaster.getPoints();
		PointList csPts = connSlave.getPoints();
		if (cmPts.size() > 2 && csPts.size() > 2)
			return cmPts.getPoint(2).equals(csPts.getPoint(2));
		
		return false;
	}
	
	/**
	 * getTrunkLocation
	 * Method to retrieve the trunk location in relative coordinates based on 
	 * current tree state.
	 * 
	 * @@param conn Connection being routed
	 * @@return Point that is the trunk location in relative coordinates.
	 */
	public Point getTrunkLocation(Connection conn) {
		Dimension vertex = getTrunkVertex();
		Point target = getTrunkOrientation().getEdge(conn.getTargetAnchor().getOwner().getBounds());

		Point ptTrunkLoc = new Point(vertex.width, vertex.height);
		ptTrunkLoc = ptTrunkLoc.getTranslated(target);
		
		return ptTrunkLoc;
	}
	
	/**
	 * setTrunkLocation
	 * Setter method to set the trunk location.  Translates the point into a relative
	 * point from the target edge.
	 * 
	 * @@param conn Connection being routed
	 * @@param ptTrunkLoc Point that is the trunk location in relative coordinates.
	 */
	public void setTrunkLocation(Connection conn, Point ptTrunkLoc) {
		Point ptRelTrunkLoc = new Point(ptTrunkLoc);
		
		// update orientation
		if (isTopDown(conn)) {
			if (ptTrunkLoc.y < conn.getTargetAnchor().getOwner().getBounds().getCenter().y)
				setTrunkOrientation(Orientation.TOP);
			else
				setTrunkOrientation(Orientation.BOTTOM);
		}
		else {
			if (ptTrunkLoc.x < conn.getTargetAnchor().getOwner().getBounds().getCenter().x)
				setTrunkOrientation(Orientation.LEFT);
			else
				setTrunkOrientation(Orientation.RIGHT);
		}

		Point target = getTrunkOrientation().getEdge(conn.getTargetAnchor().getOwner().getBounds());
		
		Dimension currentVertex = ptRelTrunkLoc.getDifference(target);
		setTrunkVertex(currentVertex);
	}
	
	/**
	 * updateConstraint
	 * Updates the constraint value for the connection based on the tree vertex
	 *
	 * @@param conn Connection whose constraint is to be updated.
	 */
	protected void updateConstraint(Connection conn) {
		if (isUpdatingPeers())
			return;
		
		List bendpoints = (List)conn.getRoutingConstraint(); 
		if (bendpoints == null)
			bendpoints = new ArrayList(conn.getPoints().size());
		
		if (bendpoints != null) {
			Point sourceRefPoint = conn.getSourceAnchor().getReferencePoint();
			conn.translateToRelative(sourceRefPoint);

			Point targetRefPoint = conn.getTargetAnchor().getReferencePoint();
			conn.translateToRelative( targetRefPoint);

			Point ptTrunk = getTrunkLocation(conn);
			Point ptSource = getBranchRouter().getSourceLocation(conn, ptTrunk);
			
			bendpoints.clear();
			PointList pts = getBranchRouter().recreateBranch(conn, ptSource, ptTrunk);
			for (int i=0; i<pts.size(); i++) {
				Bendpoint bp = new AbsoluteBendpoint(pts.getPoint(i));
				bendpoints.add(bp);
			}
		}
		
		setUpdatingPeers(true);
		
		try {
			setConstraint(conn, bendpoints);
			conn.invalidate();
			conn.validate();
		}
		catch (Exception e) {
			Trace.catching(Draw2dPlugin.getInstance(), Draw2dDebugOptions.EXCEPTIONS_CATCHING, TreeRouter.class, "updateConstraint", //$NON-NLS-1$
				e);
		}
		finally {
			setUpdatingPeers(false);
		}
	}
	
	/**
	 * getPointsFromConstraint
	 * Utility method retrieve the PointList equivalent of the bendpoint constraint
	 * set in the Connection.
	 * 
	 * @@param conn Connection to retrieve the constraint from.
	 * @@return PointList list of points that is the direct equivalent of the set constraint.
	 */
	public PointList getPointsFromConstraint(Connection conn) {
		List bendpoints = (List)conn.getRoutingConstraint();
		if (bendpoints == null)
			return new PointList();
		
		PointList points = new PointList(bendpoints.size());
		for (int i = 0; i < bendpoints.size(); i++) {
			Bendpoint bp = (Bendpoint) bendpoints.get(i);
			points.addPoint(bp.getLocation());
		}
		
		straightenPoints(points, MapModeUtil.getMapMode(conn).DPtoLP(3));
		return points;
	}
	
    /**
     * straightenPoints
     * This is a simpler version of the @@see updateIfNotRectilinear that simply ensures
     * that the lines are horizontal or vertical without any intelligence in terms of 
     * shortest distance around a rectangle.
     * 
	 * @@param newLine PointList to check for rectilinear qualities and change if necessary.
	 * @@param tolerance int tolerance value by which points will be straightened in HiMetrics
	 */
	static protected void straightenPoints(PointList newLine, int tolerance) {
        for (int i=0; i<newLine.size()-1; i++) {
            Point ptCurrent = newLine.getPoint(i);
            Point ptNext = newLine.getPoint(i+1);
            
            int xDelta = Math.abs(ptNext.x - ptCurrent.x);
            int yDelta = Math.abs(ptNext.y - ptCurrent.y);
            
            if (xDelta < yDelta) {
            	if (xDelta > tolerance)
            		return;
                ptNext.x = ptCurrent.x;
            } else {
            	if (yDelta > tolerance)
            		return;
                ptNext.y = ptCurrent.y;
            }
            
            newLine.setPoint(ptNext, i+1);
        }
    }
	
	/**
	 * Returns the branch router in the chain.
	 * @@return The getBranchRouter router
	 * 
	 */
	protected BranchRouter getBranchRouter() {
		return branchRouter;
	}

	/**
	 * @@see org.eclipse.draw2d.ConnectionRouter#remove(Connection)
	 */
	public void remove(Connection conn) {
		if (conn.getSourceAnchor() == null || conn.getTargetAnchor() == null)
			return;
		
		int index = connectionList.indexOf(conn);
		connectionList.remove(conn);
		for (int i = index + 1; i < connectionList.size(); i++)
			((Connection)connectionList.get(i)).revalidate();
	
		getBranchRouter().remove(conn);
	}

	/**
	 * isTopDown
	 * Utility method to determine if the connection should routed in a top-down fashion
	 * or in a horizontal fashion.
     * 
	 * @@param conn Connection to query
	 * @@return boolean true if connection should be routed top-down, false otherwise.
	 */
	public boolean isTopDown(Connection conn) {
		boolean vertical = true;
		if (conn instanceof ITreeConnection) {
			vertical = ((ITreeConnection)conn).getOrientation().equals(ITreeConnection.Orientation.VERTICAL) ? vertical = true : false;
		}
		
		return vertical;
	}
	
	private int DEFAULT_TRUNK_HEIGHT = 32;
	
	/**
	 * checkTrunkVertex
	 * Method to initialize the trunk vertex to a default value if not already set
	 * 
	 * @@param conn Connection to be routed.
	 */
	private void checkTrunkVertex(Connection conn) {
		if (getTrunkVertex() == null) {
			Rectangle sourceRect = conn.getSourceAnchor().getOwner().getBounds();
			Rectangle targetRect = conn.getTargetAnchor().getOwner().getBounds();
			
			Dimension default_trunk = new Dimension(0, DEFAULT_TRUNK_HEIGHT);
			conn.translateToRelative(default_trunk);
			
			if (isTopDown(conn)) {
				if (sourceRect.getCenter().y < targetRect.getCenter().y) {
					setTrunkVertex(new Dimension(0, -default_trunk.height));
					setTrunkOrientation(Orientation.TOP);
				}
				else {
					setTrunkVertex(new Dimension(0, default_trunk.height));
					setTrunkOrientation(Orientation.BOTTOM);
				}
			}
			else {
				if (sourceRect.getCenter().x < targetRect.getCenter().x) {
					setTrunkVertex(new Dimension(-default_trunk.height, 0));
					setTrunkOrientation(Orientation.LEFT);
				}
				else {
					setTrunkVertex(new Dimension(default_trunk.height, 0));
					setTrunkOrientation(Orientation.RIGHT);
				}
			}
		}
	}
	
	/* (non-Javadoc)
	 * Routes the given connection.  Calls the 'getBranchRouter' router method first
	 * @@see org.eclipse.draw2d.ConnectionRouter#route(org.eclipse.draw2d.Connection)
	 */
	public void route(Connection conn) {
		
		if (conn.getSourceAnchor() == null || conn.getSourceAnchor().getOwner() == null ||
			conn.getTargetAnchor() == null || conn.getTargetAnchor().getOwner() == null) {
			super.route(conn);
			return;
		}
		
		if (!connectionList.contains(conn)) {
			connectionList.add(conn);
		}
		
		checkTrunkVertex(conn);
		
		getBranchRouter().route(conn);
		invalidate(conn);
	}

	/**
	 * @@return Returns the truckVertex.
	 */
	protected Dimension getTrunkVertex() {
		return trunkVertex;
	}

	/**
	 * @@param trunkVertex The trunkVertex to set.
	 */
	protected void setTrunkVertex(Dimension trunkVertex) {
		this.trunkVertex = trunkVertex;
	}
	
	/**
	 * @@return Returns the trunkOrientation.
	 */
	protected Orientation getTrunkOrientation() {
		return trunkOrientation;
	}
	
	/**
	 * @@param trunkOrientation The trunkOrientation to set.
	 */
	protected void setTrunkOrientation(Orientation trunkOrientation) {
		this.trunkOrientation = trunkOrientation;
	}
	
	/**
	 * Utility method to determine if the given set of points conforms to the constraints
	 * of being an orthogonal connection tree-branch.
	 * 1. Points size must be 4.
	 * 2. Source point resides with-in boundary of source shape based on orientation
	 * 3. Target point resides with-in boundary of target shape based on orientation
	 * 4. Middle line is perpendicular to the 2 end lines.
	 * 
	 * @@param conn the <code>Connection</code> to test
	 * @@param points <code>PointList</code> to test constraints against
	 * @@return <code>boolean</code> <code>true</code> if points represent valid orthogaonl tree 
	 * branch, <code>false</code> otherwise.
	 */
	public boolean isOrthogonalTreeBranch(Connection conn, PointList points) {
		if (isTreeBranch(conn, points)) {
			LineSeg branch = new LineSeg(points.getPoint(0), points.getPoint(1));
			LineSeg trunkShoulder = new LineSeg(points.getPoint(1), points.getPoint(2));
			LineSeg trunk = new LineSeg(points.getPoint(2), points.getPoint(3));
			
			if (isTopDown(conn))
				return branch.isVertical() && trunkShoulder.isHorizontal() && trunk.isVertical();
			else
				return branch.isHorizontal() && trunkShoulder.isVertical() && trunk.isHorizontal();
		}
		
		return false;
	}
	
	/**
	 * Utility method to determine if the given set of points conforms to the constraints
	 * of being a connection tree-branch.
	 * 1. Points size must be 4.
	 * 2. Source point resides with-in boundary of source shape based on orientation
	 * 3. Target point resides with-in boundary of target shape based on orientation
	 * 
	 * @@param conn the <code>Connection</code> to test
	 * @@param points the <code>PointList</code> to test constraints against
	 * @@return <code>boolean</code> <code>true</code> if points represent valid tree branch, 
	 * <code>false</code> otherwise.
	 */
	public boolean isTreeBranch(Connection conn, PointList points) {
		if (points.size() == 4) {
			// just check if ends are with-in the owner bounding box
			Rectangle targetBounds = conn.getTargetAnchor().getOwner().getBounds();
			Rectangle sourceBounds = conn.getSourceAnchor().getOwner().getBounds();
			
			if (isTopDown(conn)) {
				return (points.getPoint(0).x > sourceBounds.x && 
					    points.getPoint(0).x < sourceBounds.x + sourceBounds.width) &&
					   (points.getPoint(3).x > targetBounds.x && 
						points.getPoint(3).x < targetBounds.x + targetBounds.width);
			}
			else
			{
				return (points.getPoint(0).y > sourceBounds.y && 
					    points.getPoint(0).y < sourceBounds.y + sourceBounds.height) &&
					   (points.getPoint(3).y > targetBounds.y && 
						points.getPoint(3).y < targetBounds.y + targetBounds.height);
			}
		}
		
		return false;
	}
	
	/**
	 * @@return Returns the connectionList List which is a copy of the internal list.
	 */
	public List getConnectionList() {
		return (List)connectionList.clone();
	}
	/**
	 * @@return Returns the updatingPeers.
	 */
	protected boolean isUpdatingPeers() {
		return updatingPeers;
	}
	/**
	 * @@param updatingPeers The updatingPeers to set.
	 */
	protected void setUpdatingPeers(boolean updatingPeers) {
		this.updatingPeers = updatingPeers;
	}
}
@


1.4
log
@bugzilla 110316 gmf-head 051207 Compiler warning count should be 0 - runtime diagram layer
@
text
@d283 1
a283 1
	 * @@since 2.0
@


1.4.2.1
log
@[148078] gmf_R_1_0_maintenance aboyko 060802 @@since 3.0/3.1 tags in Javadocs in DiagramDocumentEditor class
@
text
@d283 1
a283 1
	 * 
@


1.3
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d57 1
a57 1
		static public Orientation TOP = new Orientation();//$NON-NLS-1$
d62 1
a62 1
		static public Orientation BOTTOM = new Orientation();//$NON-NLS-1$
d67 1
a67 1
		static public Orientation RIGHT = new Orientation(); //$NON-NLS-1$
d72 1
a72 1
		static public Orientation LEFT = new Orientation(); //$NON-NLS-1$
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a26 1

d31 1
a31 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d245 1
a245 1
		straightenPoints(points, MapMode.DPtoLP(3));
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

