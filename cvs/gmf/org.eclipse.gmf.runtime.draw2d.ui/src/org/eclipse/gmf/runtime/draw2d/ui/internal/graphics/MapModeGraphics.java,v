head	1.9;
access;
symbols
	v20081023-2107:1.9
	v20081022-1925:1.9
	v20081021-1810:1.9
	v20081020-0700:1.9
	v20080911-1728:1.9
	v20080911-1506:1.9
	v20080910-1520:1.9
	v20080910-1510:1.9
	v20080903-1520:1.9
	v20080903-1510:1.9
	v20080722-1827:1.9
	R2_1_maintenance:1.9.0.4
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080610-1132:1.9
	v20080603-1553:1.9
	v20080512-1200:1.9
	v20080503-1740:1.9
	v20080501-1739:1.9
	v20080425-1959:1.9
	v20080417-1610:1.9
	v20080407-2250:1.9
	v20080407-0930:1.9
	v20080404-1111:1.9
	v20080222-1200:1.9
	v20080215-1500:1.9
	v20080215-1200:1.9
	v20080201-2010:1.9
	v20080114-1111:1.9
	v20071108-0000:1.9
	v20071003-0000:1.9
	v20070928-0000:1.9
	v20070915-0000:1.9
	v20070903-0000:1.9
	v20070830-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	v20070621-0000:1.9
	RC3_20:1.9
	v20070605-1400:1.9
	v20070601-1400:1.9
	v20070518-1300:1.9
	v20070330-1300:1.9
	v20070221-1500:1.9
	v20070208-1800:1.9
	v20070202-0200:1.8.2.1
	M4_20:1.9
	v20061218-1200:1.9
	v20061214-0000:1.9
	M3_20:1.9
	v20061013-1330:1.9
	v20060925-1700:1.8.2.1
	v20060919-0800:1.8.2.1
	M1_20:1.8
	v20060824-1600:1.8
	v20060817-1500:1.8
	v20060810-1700:1.8
	v20060803-1200:1.8
	v20060728-0500:1.8
	v20060721-1130:1.8
	v20060713-1700:1.8
	R1_0_maintenance:1.8.0.2
	R1_0:1.8
	v20060627-1200:1.8
	v20060616-1200:1.8
	v20060609-1400:1.8
	v20060531-1730:1.8
	v20060519-0800:1.8
	RC2_10:1.8
	I20060505-1400:1.8
	I20060428-1300:1.8
	I20060424-0500:1.8
	I20060424-0300:1.8
	M6_10:1.8
	I20060407-1200:1.8
	I20060331-1000:1.8
	I20060324-0300:1.8
	I20060317-1300:1.8
	I20060317-1200:1.8
	I20060316-1300:1.8
	I20060309-1300:1.8
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.8
	I20060216-1945:1.8
	I20060210-1715:1.8
	I20060209-1815:1.8
	I20060203-0830:1.8
	I20060129-1145:1.8
	I20060127-0900:1.8
	I20060120-1530:1.8
	I20060113-1700:1.7
	M4_10:1.7
	I20060107-1100:1.7
	I20060105-1630:1.7
	I20051230-1230:1.7
	I20051223-1100:1.7
	I20051217-0925:1.7
	I20051208-2000:1.6
	I20051201-1800:1.5
	I20051124-2000:1.5
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.5
	I20051106-0900:1.5
	v20051030:1.4;
locks; strict;
comment	@# @;


1.9
date	2006.10.03.15.04.52;	author ahunter;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.17.18.12.24;	author sshaw;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2005.12.14.19.01.26;	author mmostafa;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.05.19.18.10;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.04.21.27.59;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.28.14.29.46;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.05.20.30.44;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.27.43;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.51;	author sshaw;	state Exp;
branches;
next	;

1.8.2.1
date	2006.09.13.16.46.18;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.9
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/


package org.eclipse.gmf.runtime.draw2d.ui.internal.graphics;

import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.gmf.runtime.draw2d.ui.internal.mapmode.DiagramMapModeUtil;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Display;


/**
 * The MapModeGraphics class is used to translate the various map modes.
 *
 * @@author sshaw
 */
public class MapModeGraphics extends ScaledGraphics {

	private IMapMode mm;
	
	/**
	 * Constructs a new ScaledGraphics based on the given Graphics object.
	 * @@param g the base graphics object
	 * @@param mm <code>IMapMode</code> to retrieve the scale factor from.
	 */
	public MapModeGraphics(Graphics g, IMapMode mm) {
		super(g);
		setScale(DiagramMapModeUtil.getScale(mm));
		this.mm = mm;
	}

	/**
	 * @@return <code>IMapMode</code>
	 */
	public IMapMode getMapMode() {
		return mm;
	}

	/** @@see Graphics#drawImage(Image, int, int) */
	public void drawImage(Image srcImage, int x, int y) {
		org.eclipse.swt.graphics.Rectangle size = srcImage.getBounds();
		drawImage(srcImage, 0, 0, size.width, size.height, x, y, getMapMode().DPtoLP(size.width), getMapMode().DPtoLP(size.height));
	}
	
	/** @@see Graphics#scale(double) */
	public void scale(double amount) {
		getGraphics().scale(amount);
	}
	
	/**
	 * Override to prevent zooming of the font height.
	 */
	int zoomFontHeight(int height) {
		return height;
	}

	Point zoomTextPoint(int x, int y) {
		return zoomRect(x, y, 0, 0).getTopLeft();
	}
	
	Font zoomFont(Font f) {
		if (f == null)
			f = Display.getCurrent().getSystemFont();
		return f;
	}
		
}
@


1.8
log
@bugzilla 110316 gmf-head sshaw 060117 Compiler warning count should be 0 - runtime diagram laye...
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
@


1.8.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@


1.7
log
@bugzilla 119869 gmf-head mmostafa 051214 (Performance) MapModeGraphics calls inherit the zoom font functionality from ScaledGraphics
@
text
@a19 1
import org.eclipse.swt.graphics.FontData;
@


1.6
log
@bugzilla 111436 gmf-head sshaw 051205 Improve performance of SVG transcoder
@
text
@d19 2
d22 1
d73 7
@


1.5
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d52 1
a52 7
		drawImage(srcImage, 0, 0, size.width, size.height, x, y, size.width, size.height);
	}

	/** @@see Graphics#drawImage(Image, int, int, int, int, int, int, int, int) */
	public void drawImage(Image srcImage, int sx, int sy, int sw, int sh,
											int tx, int ty, int tw, int th) {
		super.drawImage(srcImage, sx, sy, sw, sh, tx, ty, getMapMode().DPtoLP(tw), getMapMode().DPtoLP(th));
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051029 API: Encapsulate MapMode / HiMetric coordinate system from clients

First phase delivery...
@
text
@a18 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d29 2
d39 8
d58 1
a58 1
		super.drawImage(srcImage, sx, sy, sw, sh, tx, ty, MapMode.DPtoLP(tw), MapMode.DPtoLP(th));
@


1.3
log
@bugzilla 110242 gmf-head sshaw 051005 Inconsistencies in MapModeGraphics and IMapMode
@
text
@d17 2
d33 1
d35 1
a35 1
	public MapModeGraphics(Graphics g) {
d37 1
a37 1
		setScale(MapMode.getScale());
d52 5
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a14 3
import java.util.ArrayList;
import java.util.List;

d17 1
a17 6
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.jface.util.Assert;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.FontMetrics;
a19 2
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;

d24 1
a24 1
 * @@author jschofie
d26 1
a26 60
public class MapModeGraphics
	extends Graphics {

	/**
	 * The internal state of the MapMode graphics.
	 */
	protected static class State {
		private double appliedX;
		private double appliedY;


		/**
		 * Constructs a new, uninitialized State object.
		 */
		protected State() {
			// intentionally left blank
		}
		
		/**
		 * Constructs a new State object and initializes the properties based on the given 
		 * values.
		 *
		 * @@param x the x offset
		 * @@param y the y offset
		 */
		protected State(double x, double y) {
			this.appliedX = x;
			this.appliedY = y;
		}

		/**
		 * Sets all the properties of the state object.
		 * @@param x the x offset
		 * @@param y the y offset
		 */
		protected void setValues(double x, double y) {
			this.appliedX = x;
			this.appliedY = y;
		}
	}
	
	private List stack = new ArrayList();
	private int stackPointer = 0;


	private static final Rectangle TEMP = new Rectangle();

	private Graphics graphics;
	private double fractionalX;
	private double fractionalY;
	private double mapModeScale = 1.0;

	/**
	 * Private Constructor used to prevent clients from accidently creating
	 * objects via the default constructor
	 */
	private MapModeGraphics() {
		// Prevent clients from creating objects of this class with 
		// the default constructor
	}
d33 2
a34 42
		// Force an exception if the Graphics is null
		Assert.isNotNull(g);

		graphics = g;
		mapModeScale = MapMode.getScale();
	}

	/** @@see Graphics#clipRect(Rectangle) */
	public void clipRect(Rectangle r) {
		graphics.clipRect(mapClipRect(r));
	}

	/** @@see Graphics#dispose() */
	public void dispose() {

		stack.clear();
	}

	/** @@see Graphics#drawArc(int, int, int, int, int, int) */
	public void drawArc(int x, int y, int w, int h, int offset, int sweep) {
		Rectangle z = mapRect(x, y, w, h);
		if (z.isEmpty() || sweep == 0)
			return;
		graphics.drawArc(z, offset, sweep);
	}

	/** @@see Graphics#fillArc(int, int, int, int, int, int) */
	public void fillArc(int x, int y, int w, int h, int offset, int sweep) {
		Rectangle z = mapFillRect(x, y, w, h);
		if (z.isEmpty() || sweep == 0)
			return;
		graphics.fillArc(z, offset, sweep);
	}

	/** @@see Graphics#fillGradient(int, int, int, int, boolean) */
	public void fillGradient(int x, int y, int w, int h, boolean vertical) {
		graphics.fillGradient(mapFillRect(x, y, w, h), vertical);
	}

	/** @@see Graphics#drawFocus(int, int, int, int) */
	public void drawFocus(int x, int y, int w, int h) {
		graphics.drawFocus(mapRect(x, y, w, h));
d40 1
a40 8
		
		int targetWidth  = MapMode.DPtoLP( size.width );
		int targetHeight = MapMode.DPtoLP( size.height );
		graphics.drawImage(srcImage, 0, 0, size.width, size.height,
			(int)(Math.floor((x * mapModeScale + fractionalX))), 
			(int)(Math.floor((y * mapModeScale + fractionalY))),
			(int)(Math.floor((targetWidth * mapModeScale + fractionalX))), 
			(int)(Math.floor((targetHeight * mapModeScale + fractionalY))));
d46 1
a46 310
		//"t" == t, "s" = source
		tw = MapMode.DPtoLP(tw);
		th = MapMode.DPtoLP(th);
		Rectangle t = mapRect(tx, ty, tw, th);
		graphics.drawImage(srcImage, sx, sy, sw, sh, t.x, t.y, t.width, t.height);
	}

	/** @@see Graphics#drawLine(int, int, int, int) */
	public void drawLine(int x1, int y1, int x2, int y2) {
		graphics.drawLine(
			(int)(Math.floor((x1 * mapModeScale + fractionalX))),
			(int)(Math.floor((y1 * mapModeScale + fractionalY))),
			(int)(Math.floor((x2 * mapModeScale + fractionalX))),
			(int)(Math.floor((y2 * mapModeScale + fractionalY))));
	}

	/** @@see Graphics#drawOval(int, int, int, int) */
	public void drawOval(int x, int y, int w, int h) {
		graphics.drawOval(mapRect(x, y, w, h));
	}

	/** @@see Graphics#fillOval(int, int, int, int) */
	public void fillOval(int x, int y, int w, int h) {
		graphics.fillOval(mapFillRect(x, y, w, h));
	}

	/**
	 * @@see Graphics#drawPolygon(int[])
	 */
	public void drawPolygon(int[] points) {
		graphics.drawPolygon(mapPointList(points));
	}

	/** @@see Graphics#drawPolygon(PointList) */
	public void drawPolygon(PointList points) {
		Assert.isNotNull(points);
		graphics.drawPolygon(mapPointList(points.toIntArray()));
	}

	/** @@see Graphics#drawPoint(int, int) */
	public void drawPoint(int x, int y) {
		graphics.drawPoint((int)Math.floor(x * mapModeScale + fractionalX),(int)Math.floor(y * mapModeScale + fractionalY));
	}

	/**
	 * @@see Graphics#fillPolygon(int[])
	 */
	public void fillPolygon(int[] points) {
		graphics.fillPolygon(mapPointList(points));
	}

	/** @@see Graphics#fillPolygon(PointList) */
	public void fillPolygon(PointList points) {
		Assert.isNotNull(points);
		graphics.fillPolygon(mapPointList(points.toIntArray()));
	}

	/**
	 * @@see Graphics#drawPolyline(int[])
	 */
	public void drawPolyline(int[] points) {
		graphics.drawPolyline(mapPointList(points));
	}

	/** @@see Graphics#drawPolyline(PointList) */
	public void drawPolyline(PointList points) {
		Assert.isNotNull(points);
		graphics.drawPolyline(mapPointList(points.toIntArray()));
	}

	/** @@see Graphics#drawRectangle(int, int, int, int) */
	public void drawRectangle(int x, int y, int w, int h) {
		graphics.drawRectangle(mapRect(x, y, w, h));
	}

	/** @@see Graphics#fillRectangle(int, int, int, int) */
	public void fillRectangle(int x, int y, int w, int h) {
		graphics.fillRectangle(mapFillRect(x, y, w, h));
	}

	/** @@see Graphics#drawRoundRectangle(Rectangle, int, int) */
	public void drawRoundRectangle(Rectangle r, int arcWidth, int arcHeight) {
		Assert.isNotNull(r);
		graphics.drawRoundRectangle(mapRect(r.x, r.y, r.width, r.height),
			(int)(arcWidth * mapModeScale),
			(int)(arcHeight * mapModeScale));
	}

	/** @@see Graphics#fillRoundRectangle(Rectangle, int, int) */
	public void fillRoundRectangle(Rectangle r, int arcWidth, int arcHeight) {
		Assert.isNotNull(r);
		graphics.fillRoundRectangle(mapFillRect(r.x, r.y, r.width, r.height),
			(int)(arcWidth * mapModeScale),
			(int)(arcHeight * mapModeScale));
	}

	/** @@see Graphics#drawString(String, int, int) */
	public void drawString(String s, int x, int y) {
		Assert.isNotNull(s);
		graphics.drawString(s, mapPoint(x, y));
	}

	/** @@see Graphics#fillString(String, int, int) */
	public void fillString(String s, int x, int y) {
		Assert.isNotNull(s);
		graphics.fillString(s, mapPoint(x, y));
	}

	/** @@see Graphics#drawText(String, int, int) */
	public void drawText(String s, int x, int y) {
		Assert.isNotNull(s);
		graphics.drawText(s, mapPoint(x, y));
	}

	/** @@see Graphics#fillText(String, int, int) */
	public void fillText(String s, int x, int y) {
		Assert.isNotNull(s);
		graphics.fillText(s, mapPoint(x, y));
	}

	/** @@see Graphics#getBackgroundColor() */
	public Color getBackgroundColor() {
		return graphics.getBackgroundColor();
	}

	/** @@see Graphics#getClip(Rectangle) */
	public Rectangle getClip(Rectangle rect) {
		graphics.getClip(rect);
		int x = (int)(rect.x / mapModeScale);
		int y = (int)(rect.y / mapModeScale);
		/*
		 * If the clip rectangle is queried, perform an inverse zoom, and take the ceiling of
		 * the resulting double. This is necessary because forward scaling essentially performs
		 * a floor() function. Without this, figures will think that they don't need to paint
		 * when actually they do.
		 */
		rect.width = (int)Math.ceil(rect.right() / mapModeScale) - x;
		rect.height = (int)Math.ceil(rect.bottom() / mapModeScale) - y;
		rect.x = x;
		rect.y = y;
		return rect;
	}

	/** @@see Graphics#getFont() */
	public Font getFont() {
		return graphics.getFont();
	}

	/** @@see Graphics#getFontMetrics() */
	public FontMetrics getFontMetrics() {
		return graphics.getFontMetrics();
	}

	/** @@see Graphics#getForegroundColor() */
	public Color getForegroundColor() {
		return graphics.getForegroundColor();
	}

	/** @@see Graphics#getLineStyle() */
	public int getLineStyle() {
		return graphics.getLineStyle();
	}

	/** @@see Graphics#getLineWidth() */
	public int getLineWidth() {
		return graphics.getLineWidth();
	}

	/** @@see Graphics#getXORMode() */
	public boolean getXORMode() {
		return graphics.getXORMode();
	}

	/** @@see Graphics#popState() */
	public void popState() {
		graphics.popState();
		stackPointer--;
		restoreLocalState((State)stack.get(stackPointer));
	}

	/** @@see Graphics#pushState() */
	public void pushState() {
		State s;
		if (stack.size() > stackPointer) {
			s = (State)stack.get(stackPointer);
			s.setValues(fractionalX, fractionalY);
		} else {
			stack.add(new State(fractionalX, fractionalY));
		}
		stackPointer++;

		graphics.pushState();
	}

	/** @@see Graphics#restoreState() */
	public void restoreState() {
		graphics.restoreState();
		restoreLocalState((State)stack.get(stackPointer - 1));
	}

	private void restoreLocalState(State state) {
		this.fractionalX = state.appliedX;
		this.fractionalY = state.appliedY;
	}

	/** @@see Graphics#scale(double) */
	public void scale(double amount) {
		graphics.scale(amount);
	}

	/** @@see Graphics#setBackgroundColor(Color) */
	public void setBackgroundColor(Color rgb) {
		graphics.setBackgroundColor(rgb);
	}

	/** @@see Graphics#setClip(Rectangle) */
	public void setClip(Rectangle r) {
		graphics.setClip(mapClipRect(r));
	}

	/** @@see Graphics#setFont(Font) */
	public void setFont(Font f) {
		graphics.setFont(f);
	}

	/** @@see Graphics#setForegroundColor(Color) */
	public void setForegroundColor(Color rgb) {
		graphics.setForegroundColor(rgb);
	}

	/** @@see Graphics#setLineStyle(int) */
	public void setLineStyle(int style) {
		graphics.setLineStyle(style);
	}

	/** @@see Graphics#setLineWidth(int) */
	public void setLineWidth(int width) {
		graphics.setLineWidth(width);
	}

	/** @@see Graphics#setXORMode(boolean) */
	public void setXORMode(boolean b) {
		graphics.setXORMode(b);
	}

	/** @@see Graphics#translate(int, int) */
	public void translate(int dx, int dy) {
		// fractionalX/Y is the fractional part left over from previous 
		// translates that gets lost in the integer approximation.
		double dxFloat = dx * mapModeScale + fractionalX;
		double dyFloat = dy * mapModeScale + fractionalY;
		fractionalX = dxFloat - Math.floor(dxFloat);
		fractionalY = dyFloat - Math.floor(dyFloat);
		graphics.translate((int)Math.floor(dxFloat), (int)Math.floor(dyFloat));
	}

	
	
	private Point mapPoint(int x, int y) {
		return new Point(((int)(Math.floor((x * mapModeScale) + fractionalX))),
						  (int)(Math.floor((y * mapModeScale) + fractionalY)));
	}

	private int[] mapPointList(int[] points) {

		if( points == null || points.length < 2 )
			return points;
		
		int[] mapped = new int[points.length];

		// Scale the points
		for (int i = 0; (i + 1) < points.length; i+= 2) {
			mapped[i] = (int)(Math.floor((points[i] * mapModeScale + fractionalX)));
			mapped[i + 1] = (int)(Math.floor((points[i + 1] * mapModeScale + fractionalY)));
		}
		return mapped;
	}

	private Rectangle mapFillRect(int x, int y, int w, int h) {
		TEMP.x = (int)(Math.floor((x * mapModeScale + fractionalX)));
		TEMP.y = (int)(Math.floor((y * mapModeScale + fractionalY)));
		TEMP.width = (int)(Math.floor(((x + w - 1) * mapModeScale + fractionalX))) - TEMP.x + 1;
		TEMP.height = (int)(Math.floor(((y + h - 1) * mapModeScale + fractionalY))) - TEMP.y + 1;
		return TEMP;
	}

	private Rectangle mapClipRect(Rectangle r) {
		TEMP.x = (int)(Math.floor(r.x * mapModeScale + fractionalX));
		TEMP.y = (int)(Math.floor(r.y * mapModeScale + fractionalY));
		TEMP.width = (int)(Math.ceil(((r.x + r.width) * mapModeScale + fractionalX))) - TEMP.x;
		TEMP.height = (int)(Math.ceil(((r.y + r.height) * mapModeScale + fractionalY))) - TEMP.y;
		return TEMP;
	}

	/**
	 * Maps the given rectangle through the map mode scaling factor and returns a new
	 * <code>Rectangle</code>.
	 * 
	 * @@param x the top left x coordinate of the rectangle
	 * @@param y the top left y coordinate of the rectangle
	 * @@param w the width of the rectangle
	 * @@param h the height of the rectangle
	 * @@return a <code>Rectangle</code> that has been scaled by the map mode scaling factor.
	 */
	final protected Rectangle mapRect(int x, int y, int w, int h) {
		TEMP.x = (int)(Math.floor(x * mapModeScale + fractionalX));
		TEMP.y = (int)(Math.floor(y * mapModeScale + fractionalY));
		TEMP.width = (int)(Math.floor(((x + w) * mapModeScale + fractionalX))) - TEMP.x;
		TEMP.height = (int)(Math.floor(((y + h) * mapModeScale + fractionalY))) - TEMP.y;
		return TEMP;
d50 1
a50 7
	 * @@return Returns the graphics.
	 */
	final protected Graphics getGraphics() {
		return graphics;
	}
	/**
	 * @@return Returns the mapModeScale.
d52 2
a53 2
	final protected double getMapModeScale() {
		return mapModeScale;
d56 2
a57 6
	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.draw2d.Graphics#setLineDash(int[])
	 */
	public void setLineDash(int[] dash) {
		getGraphics().setLineDash(dash);
a58 1

@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 7
/****************************************************************************
  Licensed Materials - Property of IBM
  (C) Copyright IBM Corp. 2004. All Rights Reserved.
 
  US Government Users Restricted Rights - Use, duplication or disclosure
  restricted by GSA ADP Schedule Contract with IBM Corp.
*****************************************************************************/
@

