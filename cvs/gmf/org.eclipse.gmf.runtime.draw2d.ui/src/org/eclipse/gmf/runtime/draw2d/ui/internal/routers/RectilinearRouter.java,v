head	1.15;
access;
symbols
	v20081023-2107:1.15
	v20081022-1925:1.15
	v20081021-1810:1.15
	v20081020-0700:1.15
	v20080911-1728:1.15
	v20080911-1506:1.15
	v20080910-1520:1.15
	v20080910-1510:1.15
	v20080903-1520:1.15
	v20080903-1510:1.15
	v20080722-1827:1.15
	R2_1_maintenance:1.15.0.2
	Root_R2_1_maintenance:1.15
	R2_1_0:1.15
	v20080610-1132:1.15
	v20080603-1553:1.15
	v20080512-1200:1.15
	v20080503-1740:1.15
	v20080501-1739:1.15
	v20080425-1959:1.15
	v20080417-1610:1.15
	v20080407-2250:1.15
	v20080407-0930:1.15
	v20080404-1111:1.15
	v20080222-1200:1.14
	v20080215-1500:1.14
	v20080215-1200:1.10.2.1
	v20080201-2010:1.14
	v20080114-1111:1.14
	v20071108-0000:1.11
	v20071003-0000:1.11
	v20070928-0000:1.10.2.1
	v20070915-0000:1.10.2.1
	v20070903-0000:1.11
	v20070830-0000:1.10.2.1
	v20070809-0000:1.10
	R2_0_maintenance:1.10.0.2
	R2_0:1.10
	R4_20:1.10
	v20070621-0000:1.10
	RC3_20:1.10
	v20070605-1400:1.10
	v20070601-1400:1.10
	v20070518-1300:1.10
	v20070330-1300:1.9
	v20070221-1500:1.9
	v20070208-1800:1.9
	v20070202-0200:1.7.2.2
	M4_20:1.8
	v20061218-1200:1.8
	v20061214-0000:1.8
	M3_20:1.8
	v20061013-1330:1.8
	v20060925-1700:1.7.2.1
	v20060919-0800:1.7.2.1
	M1_20:1.7
	v20060824-1600:1.7
	v20060817-1500:1.7
	v20060810-1700:1.7
	v20060803-1200:1.7
	v20060728-0500:1.7
	v20060721-1130:1.7
	v20060713-1700:1.7
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060609-1400:1.7
	v20060531-1730:1.7
	v20060519-0800:1.7
	RC2_10:1.7
	I20060505-1400:1.7
	I20060428-1300:1.7
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.6
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051208-2000:1.5
	I20051201-1800:1.5
	I20051124-2000:1.5
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.5
	I20051106-0900:1.5
	v20051030:1.3;
locks; strict;
comment	@# @;


1.15
date	2008.04.03.16.30.11;	author aboyko;	state Exp;
branches;
next	1.14;
commitid	3e0347f506114567;

1.14
date	2008.01.10.23.02.30;	author aboyko;	state Exp;
branches;
next	1.13;
commitid	6a814786a4064567;

1.13
date	2008.01.03.17.42.57;	author aboyko;	state Exp;
branches;
next	1.12;
commitid	3284477d1ea04567;

1.12
date	2008.01.02.20.06.57;	author aboyko;	state Exp;
branches;
next	1.11;
commitid	5a64477beede4567;

1.11
date	2007.08.15.15.35.19;	author aboyko;	state Exp;
branches;
next	1.10;
commitid	255e46c31d364567;

1.10
date	2007.05.16.19.47.01;	author mmostafa;	state Exp;
branches
	1.10.2.1;
next	1.9;
commitid	24f4464b5fb34567;

1.9
date	2007.01.26.22.04.17;	author crevells;	state Exp;
branches;
next	1.8;
commitid	2e9545ba7ae14567;

1.8
date	2006.10.03.15.04.52;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.26.21.40.36;	author sshaw;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.02.07.15.18.45;	author mmostafa;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.04.22.13.08;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.04.21.27.59;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.25.13.51.49;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.27.43;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.52;	author sshaw;	state Exp;
branches;
next	;

1.7.2.1
date	2006.09.13.16.46.18;	author ahunter;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2007.01.26.22.40.36;	author crevells;	state Exp;
branches;
next	;
commitid	19fe45ba83644567;

1.10.2.1
date	2007.08.15.15.49.10;	author aboyko;	state Exp;
branches;
next	;
commitid	3cd646c320764567;


desc
@@


1.15
log
@[225437] gmf_head aboyko 080403 Layout improvements
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.PrecisionRectangle;
import org.eclipse.draw2d.geometry.Ray;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.draw2d.ui.figures.BaseSlidableAnchor;
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.figures.OrthogonalConnectionAnchor;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;


/**
 * @@author sshaw/aboyko
 * @@canBeSeenBy org.eclipse.gmf.runtime.draw2d.ui.*
 *
 * RectilinearRouter which routes the Connection so that the lines
 * are always vertical or horizontal.
 */
public class RectilinearRouter extends ObliqueRouter implements OrthogonalRouter {

	private static int maxNestedRoutingDepth = 1;
	
	/**
     * Overridden method from ObliqueRouter that will perform the conversion of the
     * polyline to a rectilinear version.
     * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#routeLine(org.eclipse.draw2d.Connection, int, org.eclipse.draw2d.geometry.PointList)
	 */
	public void routeLine(
		Connection conn,
		int nestedRoutingDepth,
		PointList newLine) {
		boolean skipNormalization =
			(routerFlags & ROUTER_FLAG_SKIPNORMALIZATION) != 0;
			
		// if we are reorienting, then just default to the super class implementation and
		// don't try to do rectilinear routing.
		if (isReorienting(conn)) {
			super.routeLine(conn, nestedRoutingDepth, newLine);
			return;
		}

		// Handle special routing: self connections and intersecting shapes connections
		if (checkSelfRelConnection(conn, newLine)
				|| checkShapesIntersect(conn, newLine)) {
			super.resetEndPointsToEdge(conn, newLine);
			OrthogonalRouterUtilities
					.transformToOrthogonalPointList(newLine,
							getOffShapeDirection(getAnchorOffRectangleDirection(
									newLine.getFirstPoint(),
									sourceBoundsRelativeToConnection(conn))),
							getOffShapeDirection(getAnchorOffRectangleDirection(
									newLine.getLastPoint(),
									targetBoundsRelativeToConnection(conn))));
			return;
		}
		
		/*
		 * Remove and store former anchor points. Anchor points will be re-calculated anyway.
		 * However, the old anchor points may be useful if connection didn't have any bend points
		 * except the anchor points.
		 */
		Point lastStartAnchor = newLine.removePoint(0);
		Point lastEndAnchor = newLine.removePoint(newLine.size() - 1);
		    	
		/*
		 * Check if connection is rectilinear and if not make it rectilinear
		 */
		if (!OrthogonalRouterUtilities.isRectilinear(newLine)) {
	    	OrthogonalRouterUtilities.transformToOrthogonalPointList(newLine, PositionConstants.NONE, PositionConstants.NONE);
		}
		
		removeRedundantPoints(newLine);
		
		/*
		 * Remove unnecessary points that are contained within source and/or target shapes
		 * as well as insert extra points if all points are within source and/or target shapes
		 */
    	removePointsInViews(conn, newLine, lastStartAnchor, lastEndAnchor);
    	
		Dimension tolerance = new Dimension(3, 0);
		if (!RouterHelper.getInstance().isFeedback(conn))
			tolerance = (Dimension)MapModeUtil.getMapMode(conn).DPtoLP(tolerance);
		
		/*
		 * Normalize polyline to eliminate extra segments. (This makes 3 segments collapsing into
		 * one, while line segments are moved)
		 */
		if (!skipNormalization) {			
            if (PointListUtilities.normalizeSegments(newLine, tolerance.width)) {
            	/*
            	 * Normalization can make our polyline not rectilinear. Hence, we need to normalize
            	 * segments of polyline to straight line tolerance.
            	 */
            	normalizeToStraightLineTolerance(newLine, tolerance.width);
            }
		}
				
		/*
		 * Normalization is not touching the end points, hence we'd like to handle this here.
		 * If distance between start and end (which are the only points in a polyline) points
		 * is too short we'll remove one of the points  
		 */
		if (newLine.size() == 2) {
			Ray middleSeg = new Ray(newLine.getFirstPoint(), newLine.getLastPoint());
			if (middleSeg.length() <= tolerance.width) {
				newLine.removePoint(0);
			}
		}
    	
		/*
		 * Calculate connection anchor points and possibly some extra routing work to keep
		 * the connection rectilinear if anchor points make it not rectilinear.  
		 */
		resetEndPointsToEdge(conn, newLine);
		
		if (nestedRoutingDepth < maxNestedRoutingDepth && !isValidRectilinearLine(conn, newLine)) {
			routeLine(conn, ++nestedRoutingDepth, newLine);
		}
	}
	
	/**
	 * Rectilinear polyline is invalid if:
	 * 1. First bend point is within the source
	 * 2. Last bend point is within the target
	 * 3. First bend point and source anchor are on different sides of the source shape
	 * 4. Last bend point and target anchor are on different sides of the target shape
	 * 
	 * @@param conn connection
	 * @@param line rectilinear polyline
	 * @@return <code>true</code> if the line is valid
	 */
	private boolean isValidRectilinearLine(Connection conn, PointList line) {
		if (!(conn.getSourceAnchor().getOwner() instanceof Connection)) {
			Rectangle source = new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(conn.getSourceAnchor().getOwner()));
			conn.getSourceAnchor().getOwner().translateToAbsolute(source);
			conn.translateToRelative(source);
			if (source.contains(line.getPoint(1))) {
				return false;
			}
			int firstSegmentOrientation = line.getFirstPoint().x == line.getPoint(1).x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
			if (getOutisePointOffRectanglePosition(line.getPoint(1), source) != getAnchorLocationBasedOnSegmentOrientation(line.getFirstPoint(), source, firstSegmentOrientation)) {
				return false;
			}			
		}
		if (!(conn.getTargetAnchor().getOwner() instanceof Connection)) {
			Rectangle target = new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(conn.getTargetAnchor().getOwner()));
			conn.getTargetAnchor().getOwner().translateToAbsolute(target);
			conn.translateToRelative(target);
			if (target.contains(line.getPoint(line.size() - 2))) {
				return false;
			}
			int lastSegmentOrientation = line.getLastPoint().x == line.getPoint(line.size() - 2).x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
			if (getOutisePointOffRectanglePosition(line.getPoint(line.size() - 2), target) != getAnchorLocationBasedOnSegmentOrientation(line.getLastPoint(), target, lastSegmentOrientation)) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Removes consecutive points contained within the source shape and removes consecutive
	 * points contained within the target shape. If all points have been removed an extra point
	 * outside source and target shapes will be added.
	 * 
	 * @@param conn connection
	 * @@param newLine polyline of the connection (routed connection)
	 * @@param start old start anchor point
	 * @@param end old end anchor point
	 */
	private void removePointsInViews(Connection conn, PointList newLine,
			Point start, Point end) {
		/*
		 * Get the bounds of anchorable figure of the source and target and translate it to
		 * connection relative coordinates.
		 */
		PrecisionRectangle source = conn.getSourceAnchor().getOwner() != null ? new PrecisionRectangle(
				FigureUtilities.getAnchorableFigureBounds(conn
						.getSourceAnchor().getOwner()))
				: null;
		PrecisionRectangle target = conn.getTargetAnchor().getOwner() != null ? new PrecisionRectangle(
				FigureUtilities.getAnchorableFigureBounds(conn
						.getTargetAnchor().getOwner()))
				: null;
		if (source != null) {
			conn.getSourceAnchor().getOwner().translateToAbsolute(source);
			conn.translateToRelative(source);
		}
		if (target != null) {
			conn.getTargetAnchor().getOwner().translateToAbsolute(target);
			conn.translateToRelative(target);
		}
		
		Point lastRemovedFromSource = null;
		Point lastRemovedFromTarget = null;
		
		/*
		 * Starting from the first point of polyline remove points that are contained
		 * within the source shape until the first point outside is found.
		 * Remember the point that was removed from the source shape last for a possible
		 * case of all points removed from polyline.
		 */
		if (!(conn.getSourceAnchor().getOwner() instanceof Connection)
				&& newLine.size() != 0
				&& source.contains(new PrecisionPoint(newLine.getFirstPoint()))) {
			lastRemovedFromSource = newLine.removePoint(0);
			for (int i = 0; i < newLine.size()
					&& source.contains(new PrecisionPoint(newLine.getPoint(i))); i++) {
				lastRemovedFromSource = newLine.removePoint(i--);
			}
		}
		
		/*
		 * Starting from the end point of polyline remove points that are contained
		 * within the target shape until the first point outside is found.
		 * Remember the point that was removed from the target shape last for a possible
		 * case of all points removed from polyline.
		 */
		if (!(conn.getTargetAnchor().getOwner() instanceof Connection)
				&& newLine.size() != 0
				&& target.contains(new PrecisionPoint(newLine.getLastPoint()))) {
			lastRemovedFromTarget = newLine.removePoint(newLine.size() - 1);
			for (int i = newLine.size(); i > 0
					&& target.contains(new PrecisionPoint(newLine
							.getPoint(i - 1))); i--) {
				lastRemovedFromTarget = newLine.removePoint(i - 1);
			}
		}
		
		/*
		 * Handle the special case of all points removed from polyline.
		 */
		if (newLine.size() == 0) {
			Dimension tolerance = new Dimension(1, 0);
			if (!RouterHelper.getInstance().isFeedback(conn))
				tolerance = (Dimension)MapModeUtil.getMapMode(conn).DPtoLP(tolerance);
			int toleranceValue = tolerance.width;
			if (lastRemovedFromSource == null) {
				lastRemovedFromSource = start;
			}
			if (lastRemovedFromTarget == null) {
				lastRemovedFromTarget = end;
			}
			/*
			 * If last point removed from source and the points removed from target form
			 * a vertical or horizontal line we'll find a point located on this line and is
			 * outside of source and target shape and insert it in the polyline.
			 * The check for vertical and horizontal segment is using tolerance value, because
			 * bend point location extracted from RelativeBendpoint can have precision errors due
			 * to non-integer weight factors.  
			 */
			if (Math.abs(lastRemovedFromSource.x - lastRemovedFromTarget.x) < toleranceValue) {
				// Vertical
				if (source.preciseY < target.preciseY) {
					newLine.addPoint(lastRemovedFromSource.x, (source
							.getBottom().y + target.getTop().y) / 2);
				} else {
					newLine.addPoint(lastRemovedFromSource.x,
							(source.getTop().y + target.getBottom().y) / 2);
				}
			} else if (Math.abs(lastRemovedFromSource.y - lastRemovedFromTarget.y) < toleranceValue) {
				// Horizontal
				if (source.preciseX < target.preciseX) {
					newLine.addPoint(
							(source.getRight().x + target.getLeft().x) / 2,
							lastRemovedFromSource.y);
				} else {
					newLine.addPoint(
							(source.getLeft().x + target.getRight().x) / 2,
							lastRemovedFromSource.y);
				}
			} else if ((conn.getSourceAnchor() instanceof BaseSlidableAnchor
					&& StringStatics.BLANK.equals(((BaseSlidableAnchor) conn
							.getSourceAnchor()).getTerminal()) && (conn
					.getTargetAnchor() instanceof BaseSlidableAnchor && StringStatics.BLANK
					.equals(((BaseSlidableAnchor) conn.getTargetAnchor())
							.getTerminal())))) {
				/*
				 * This a special case for old diagrams with rectilinear connections routed by
				 * the old router to look good with the new router
				 */
				double startX = Math.max(source.preciseX, target.preciseX);
				double endX = Math.min(source.preciseX + source.preciseWidth,
						target.preciseX + target.preciseWidth);
				double startY = Math.max(source.preciseY, target.preciseY);
				double endY = Math.min(source.preciseY + source.preciseHeight,
						target.preciseY + target.preciseHeight);
				if (startX < endX) {
					if (source.preciseY < target.preciseY) {
						newLine.addPoint((int) Math
								.round((startX + endX) / 2.0), (source
								.getBottom().y + target.getTop().y) / 2);
					} else {
						newLine.addPoint((int) Math
								.round((startX + endX) / 2.0),
								(source.getTop().y + target.getBottom().y) / 2);
					}
				} else if (startY < endY) {
					if (source.preciseX < target.preciseX) {
						newLine.addPoint((source.getRight().x + target
								.getLeft().x) / 2, (int) Math
								.round((startY + endY) / 2.0));
					} else {
						newLine.addPoint((source.getLeft().x + target
								.getRight().x) / 2, (int) Math
								.round((startY + endY) / 2.0));
					}
				}
			}
		}
	}
	
	/**
	 * Determines the relative to rectangle geographic location of a point.
	 * Example: If shape is closer to the the top edge of the rectangle location
	 * would be north.
	 * Method used to determine which side of shape's bounding rectangle is closer
	 * to connection's anchor point.
	 * All geometric quantities must be in the same coordinate system. 
	 * 
	 * @@param anchorPoint location of the anchor point
	 * @@param rect bounding rectangle of the shape
	 * @@return
	 */
	private int getAnchorOffRectangleDirection(Point anchorPoint, Rectangle rect) {
		int position = PositionConstants.NORTH;
		int criteriaValue = Math.abs(anchorPoint.y - rect.y);
		int tempCriteria = Math.abs(anchorPoint.y - rect.y - rect.height);
		if (tempCriteria < criteriaValue) {
			criteriaValue = tempCriteria;
			position = PositionConstants.SOUTH;
		}
		
		tempCriteria = Math.abs(anchorPoint.x - rect.x);
		if (tempCriteria < criteriaValue) {
			criteriaValue = tempCriteria;
			position = PositionConstants.WEST;
		}
		
		tempCriteria = Math.abs(anchorPoint.x - rect.x - rect.width);
		if (tempCriteria < criteriaValue) {
			criteriaValue = tempCriteria;
			position = PositionConstants.EAST;
		}
		
		return position; 		
	}
	
	/**
	 * Returns a translation dimension for the anchor point. Translation dimension
	 * translates the anchor point off the shape. The off shape direction
	 * is specified by the relative to the shape geographic position of the anchor  
	 * 
	 * @@param position relative to the shape geographic position of the anchor
	 * @@param xFactorValue translation value along x-axis
	 * @@param yFactorValue translation value along y-axis
	 * @@return
	 */
	private Dimension getTranslationValue(int position, int xFactorValue, int yFactorValue) {
		Dimension translationDimension = new Dimension();
		if (position == PositionConstants.EAST) {
			translationDimension.width = xFactorValue;
		} else if (position == PositionConstants.SOUTH) {
			translationDimension.height = yFactorValue;
		} else if (position == PositionConstants.WEST) {
			translationDimension.width = -xFactorValue;
		} else if (position == PositionConstants.NORTH) {
			translationDimension.height = -yFactorValue;
		}
		return translationDimension;
	}
	
	/**
	 * Determines whether the rectilinear line segment coming out of the shape should be
	 * horizontal or vertical based on the anchor geographic position relative to the shape 
	 * 
	 * @@param anchorRelativeLocation
	 * @@return
	 */
	private int getOffShapeDirection(int anchorRelativeLocation) {
		if (anchorRelativeLocation == PositionConstants.EAST || anchorRelativeLocation == PositionConstants.WEST) {
			return PositionConstants.HORIZONTAL;
		} else if (anchorRelativeLocation == PositionConstants.NORTH || anchorRelativeLocation == PositionConstants.SOUTH) {
			return PositionConstants.VERTICAL;
		}
		return PositionConstants.NONE;
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#resetEndPointsToEdge(org.eclipse.draw2d.Connection, org.eclipse.draw2d.geometry.PointList)
	 */
	protected void resetEndPointsToEdge(Connection conn, PointList line) {
		if (isReorienting(conn)) {
			/*
			 * If the connection doesn't have a shape as a source or target we'll
			 * let the oblique router to do the work. The connection doesn't need to
			 * be rectilinear at this point. There is no support for making a rectilinear
			 * connection for which one of the ends is not connected to anything. 
			 */
			super.resetEndPointsToEdge(conn, line);
			return;
		}
    	PrecisionRectangle source = sourceBoundsRelativeToConnection(conn);
    	PrecisionRectangle target = targetBoundsRelativeToConnection(conn);
    	int offSourceDirection = PositionConstants.NONE;
    	int offTargetDirection = PositionConstants.NONE;
		int sourceAnchorRelativeLocation = PositionConstants.NONE;
		int targetAnchorRelativeLocation = PositionConstants.NONE;
    	if (line.size() == 0) {
    		/*
    		 * If there are no valid bend points, we'll use the oblique connection anchor points
    		 * and just convert the polyline from oblique to rectilinear. 
    		 */
    		// Need to add 2 dumb points to ensure that RouterHelper#resetEndPointsToEdge works
    		line.addPoint(new Point());
    		line.addPoint(new Point());
    		super.resetEndPointsToEdge(conn, line);
    		sourceAnchorRelativeLocation = getAnchorOffRectangleDirection(line.getFirstPoint(), source);
    		targetAnchorRelativeLocation = getAnchorOffRectangleDirection(line.getLastPoint(), target);
    		/*
    		 * We need to find two points offset from the source and target anchors outside the shapes
    		 * such that when the polyline is converted to rectilinear from oblique we won't have
    		 * rectilinear line segments alligned with source or target shapes edges.
    		 */
    		Point offStart = line.getFirstPoint();
    		Point offEnd = line.getLastPoint();
    		Dimension offsetDim = offStart.getDifference(offEnd).scale(0.5);
    		offStart.translate(getTranslationValue(sourceAnchorRelativeLocation, Math.abs(offsetDim.width), Math.abs(offsetDim.height)));
    		offEnd.translate(getTranslationValue(targetAnchorRelativeLocation, Math.abs(offsetDim.width), Math.abs(offsetDim.height)));
    		line.insertPoint(offStart, 1);
    		line.insertPoint(offEnd, 2);
    		offSourceDirection = getOffShapeDirection(sourceAnchorRelativeLocation);
    		offTargetDirection = getOffShapeDirection(targetAnchorRelativeLocation);
    	} else {
	        Point start = line.getFirstPoint();
	        Point end = line.getLastPoint();
	    	if (conn.getSourceAnchor() instanceof OrthogonalConnectionAnchor) {
	            line.insertPoint(OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, conn.getSourceAnchor(), start).getOrigin(), 0);
	    	} else {
	    		/*
	    		 * If anchor is not supporting orthogonal connections we'll use the oblique connection
	    		 * anchors and then convert it to rectilinear.
	    		 */
	    		PrecisionPoint reference = new PrecisionPoint(start);
	    		conn.getSourceAnchor().getOwner().translateToAbsolute(reference);
	    		PrecisionPoint anchorLocation = new PrecisionPoint(conn.getSourceAnchor().getLocation(reference));
				conn.translateToRelative(anchorLocation);
				line.insertPoint(anchorLocation, 0);
	    	}
	    	if (conn.getTargetAnchor() instanceof OrthogonalConnectionAnchor) {
	            line.addPoint(OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, conn.getTargetAnchor(), end).getOrigin());
	    	} else {
	    		/*
	    		 * If anchor is not supporting orthogonal connections we'll use the oblique connection
	    		 * anchors and then convert it to rectilinear.
	    		 */
	    		PrecisionPoint reference = new PrecisionPoint(end);
	    		conn.getSourceAnchor().getOwner().translateToAbsolute(reference);
	    		PrecisionPoint anchorLocation = new PrecisionPoint(conn.getTargetAnchor().getLocation(reference));
				conn.translateToRelative(anchorLocation);
				line.addPoint(anchorLocation);
	    	}
	    	sourceAnchorRelativeLocation = getAnchorOffRectangleDirection(line.getFirstPoint(), source);
            offSourceDirection = getOffShapeDirection(sourceAnchorRelativeLocation);
	    	targetAnchorRelativeLocation = getAnchorOffRectangleDirection(line.getLastPoint(), target);
            offTargetDirection = getOffShapeDirection(targetAnchorRelativeLocation);
    	}

    	/*
    	 * Convert the polyline to rectilinear. If the connection is rectilinear already then the
    	 * connection will remain as it is.
    	 */
		OrthogonalRouterUtilities.transformToOrthogonalPointList(line, offSourceDirection, offTargetDirection);
		removeRedundantPoints(line);
	}
	
    /**
     * Goes through line segments of a polyline and makes strict straight segments
     * from nearly straight segments.
     * 
     * @@param line polyline
     * @@param tolerance tolerance value specifying nearly straight lines.
     */
    private void normalizeToStraightLineTolerance(PointList line, int tolerance) {
    	for (int i = 0; i < line.size() - 1; i++) {
    		Point pt1 = line.getPoint(i);
    		Point pt2 = line.getPoint(i + 1);
    		if (Math.abs(pt1.x - pt2.x) < tolerance) {
    			line.setPoint(new Point(pt1.x, pt2.y), i + 1);
    		} else if (Math.abs(pt1.y - pt2.y) < tolerance) {
    			line.setPoint(new Point(pt2.x, pt1.y), i + 1);
    		}
    	}
    }
        
    /**
     * Source bounding rectangle relative to connection figure coordinates
     * 
     * @@param conn connection
     * @@return <code>PrecisionRectangle</code> source bounds relative to connection's coordinate
     * system
     */
    private PrecisionRectangle sourceBoundsRelativeToConnection(Connection conn) {
    	PrecisionRectangle source = new PrecisionRectangle(conn.getSourceAnchor().getOwner().getBounds());
    	conn.getSourceAnchor().getOwner().translateToAbsolute(source);
    	conn.translateToRelative(source);
    	return source;
    }
    
    /**
     * Target bounding rectangle relative to connection figure coordinates
     * 
     * @@param conn connection
     * @@return <code>PrecisionRectangle</code> target bounds relative to connection's coordinate
     * system
     */
    private PrecisionRectangle targetBoundsRelativeToConnection(Connection conn) {
    	PrecisionRectangle target = new PrecisionRectangle(conn.getTargetAnchor().getOwner().getBounds());
    	conn.getTargetAnchor().getOwner().translateToAbsolute(target);
    	conn.translateToRelative(target);
    	return target;
    }
    
    /**
     * Calculates geographic position of a point located outside the given rectangle relative
     * to the rectangle 
     * 
     * @@param p point outside of rectangle
     * @@param r the rectangle
     * @@return geographic position of the point relative to the recatangle
     */
    private int getOutisePointOffRectanglePosition(Point p, Rectangle r) {
    	int position = PositionConstants.NONE;
    	if (r.x > p.x) {
    		position |= PositionConstants.WEST;
    	} else if (r.x + r.width < p.x) {
    		position |= PositionConstants.EAST;
    	}
    	if (r.y > p.y) {
    		position |= PositionConstants.NORTH;
    	} else if (r.y + r.height < p.y) {
    		position |= PositionConstants.SOUTH;
    	}
    	return position;
    }
    
    /**
     * Given the coordinates of the connection anchor point the shape's rectangle and the
     * orientation of the first rectilinear connection segment that comes out from the anchor
     * point the method detemines on which geographic side of the rectangle the anchor point
     * is located on. 
     * 
     * @@param anchorPoint coordinates of the anchor point
     * @@param rectangle the shape's bounding rectangle
     * @@param segmentOrientation orinetation of the segment coming out from the anchor point
     * @@return geographic position of the anchor point relative to the rectangle
     */
    private int getAnchorLocationBasedOnSegmentOrientation(Point anchorPoint, Rectangle rectangle, int segmentOrientation) {
    	if (segmentOrientation == PositionConstants.VERTICAL) {
    		if (Math.abs(anchorPoint.y - rectangle.y) < Math.abs(anchorPoint.y - rectangle.y - rectangle.height)) {
    			return PositionConstants.NORTH;
    		} else {
    			return PositionConstants.SOUTH;
    		}
    	} else if (segmentOrientation == PositionConstants.HORIZONTAL) {
    		if (Math.abs(anchorPoint.x - rectangle.x) < Math.abs(anchorPoint.x - rectangle.x - rectangle.width)) {
    			return PositionConstants.WEST;
    		} else {
    			return PositionConstants.EAST;
    		}
    	}
    	return PositionConstants.NONE;
    }
    
	/**
	 * Iterates through points of a polyline and does the following:
	 * if 3 points lie on the same line the middle point is removed
	 * 
	 * @@param line polyline's points
	 */
	private boolean removeRedundantPoints(PointList line) {
		int initialNumberOfPoints = line.size();
		if (line.size() > 2) {
			PointList newLine = new PointList(line.size()); 
			newLine.addPoint(line.removePoint(0));
			while (line.size() >= 2) {
				Point p0 = newLine.getLastPoint();
				Point p1 = line.getPoint(0);
				Point p2 = line.getPoint(1);
				if (p0.x == p1.x && p0.x == p2.x) {
					// Have two vertical segments in a row
					// get rid of the point between
					line.removePoint(0);
				} else if (p0.y == p1.y && p0.y == p2.y) {
					// Have two horizontal segments in a row
					// get rid of the point between
					line.removePoint(0);
				} else {
					newLine.addPoint(line.removePoint(0));
				}
			}
			while (line.size() > 0) {
				newLine.addPoint(line.removePoint(0));
			}
			line.removeAllPoints();
			line.addAll(newLine);
		}
		return line.size() != initialNumberOfPoints;
	}
    
}
@


1.14
log
@Commit back [194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
d445 1
a445 1
    		Dimension offsetDim = offStart.getDifference(offEnd).scale(0.3);
@


1.13
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d15 1
a15 2
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.IFigure;
d19 1
d23 4
a26 2

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
d32 1
a32 1
 * @@author sshaw
d40 2
d43 3
a45 8
     * removeSegmentsInViews
     * This method will parse through all the line segments in the given 
     * polyline and remove any of the segments that intersect with the 
     * start and end figures.
     * 
	 * @@param conn Connection figure that is used to access anchors
	 * @@param newLine PointList that will be modified by the routine.
	 * @@return boolean true if method change newLine PointList, false otherwise
d47 12
a58 8
	protected boolean removeSegmentsInViews(Connection conn, PointList newLine) {
		// Ignore the first and last points
		PointList newPoints = new PointList(newLine.size());
		Point ptStart = new Point(newLine.getFirstPoint());
		Point ptEnd = new Point(newLine.getLastPoint());
		for (int i = 0; i < newLine.size(); i++) {
			if (i != 0 && i != newLine.size() - 1)
				newPoints.addPoint(new Point(newLine.getPoint(i)));
d61 14
a74 13
		if (newPoints.size() < 3)
			return false;

		int lastIntersect = 0;
		int count = 0;
		boolean found = false;
        boolean bChanged = false;
        IFigure sourceFigure = conn.getSourceAnchor().getOwner();

		if (sourceFigure == null)
			return false;

		PointList startPolygon = getFigurePolygon(sourceFigure,conn);
d76 13
a88 11
		for (int i = 0; i < newPoints.size() - 1; i++) {
            boolean in1 = PointListUtilities.containsPoint(startPolygon, newPoints.getPoint(i));
 			boolean in2 = PointListUtilities.containsPoint(startPolygon, newPoints.getPoint(i+1));
 			if (in1 != in2) {
				lastIntersect = count;
				found = true;
			} else if (!(in1 || in2)) // Neither intersect, so skip out
				{
				break;
			}
			++count;
d90 24
a113 7

		// remove segments before the one that finally
		// intersects:
		if (found) {
			for (int i = 0; i <= lastIntersect; ++i) {
				newPoints.removePoint(0);
                bChanged = true;
d116 10
a125 17

		lastIntersect = count = newLine.size() - 1;
		found = false;
		IFigure targetFigure = conn.getTargetAnchor().getOwner();
		if (targetFigure == null)
			return false;

        PointList endPolygon = getFigurePolygon(targetFigure,conn);
		for (int i = newPoints.size() - 1; i > 0; i--) {
		    boolean in1 = PointListUtilities.containsPoint(endPolygon,newPoints.getPoint(i));
			boolean in2 = PointListUtilities.containsPoint(endPolygon,newPoints.getPoint(i - 1));
			if (in1 != in2) {
				lastIntersect = count;
				found = true;
			} else if (!(in1 || in2)) // Neither intersect, so skip out
				{
				break;
a126 1
			--count;
d128 9
a136 8

		// remove segments after the one that finally
		// intersects:
		if (found) {
			for (int i = newPoints.size() - 1; i >= lastIntersect; --i) {
				newPoints.removePoint(newPoints.size() - 1);
                bChanged = true;
            }
a137 10

		if (newPoints.size() != newLine.size()) {
			newLine.removeAllPoints();
			newLine.addPoint(ptStart);
			for (int i = 0; i < newPoints.size(); i++)
				newLine.addPoint(new Point(newPoints.getPoint(i)));
			newLine.addPoint(ptEnd);
		}
        
        return bChanged;
d139 1
a139 1
    
d141 9
a149 9
     * updateToBiTerminal
     * Determines if the polyline has only two bendpoints (endpoints) and if so,
     * updates the connection to be consistent with the Rectilinear router - i.e.
     * vertical or horizontal alignment.
     * 
	 * @@param conn Connection that is being routed.
	 * @@param newLine PointList to be checked and modified if bi-terminal routing is
     * possible
	 * @@return true if PointList is a candidate for bi-terminal routing, false otherwise
d151 7
a157 73
	protected boolean updateToBiTerminal(Connection conn, PointList newLine) {
		boolean retVal = false;

		if (newLine.size() == 2) {
			Point ptOrig = new Point(newLine.getPoint(0));
			Point ptTerm = new Point(newLine.getPoint(1));

			Dimension offsets = new Dimension(10, 10);
			conn.translateToRelative(offsets);
			
			Rectangle bBoxF, bBoxT;
			if (conn.getSourceAnchor().getOwner() != null) {
				bBoxF = getBounds(conn.getSourceAnchor().getOwner());
				conn.getSourceAnchor().getOwner().translateToAbsolute(bBoxF);
				conn.translateToRelative(bBoxF);
			} else
				bBoxF = new Rectangle(ptOrig.x - offsets.width / 2, ptOrig.y - offsets.height / 2, 
											offsets.width, offsets.height);

            if (conn.getTargetAnchor().getOwner() != null) {
                bBoxT = getBounds(conn.getTargetAnchor().getOwner());
				conn.getTargetAnchor().getOwner().translateToAbsolute(bBoxT);
				conn.translateToRelative(bBoxT);
			} else
				bBoxT = new Rectangle(ptTerm.x - offsets.width / 2, ptTerm.y - offsets.height / 2, 
											offsets.width, offsets.height);

			int ix1 = Math.max(bBoxF.getLeft().x, bBoxT.getLeft().x);
			int ix2 = Math.min(bBoxF.getRight().x, bBoxT.getRight().x);

			Point posF = bBoxF.getCenter();
			Point posT = bBoxT.getCenter();

			Ray origSeg = new Ray(ptOrig, ptTerm);
			boolean isOblique = (origSeg.y != 0 && origSeg.x != 0);

			if (ix1 <= ix2) {
				// The two boundboxes overlap each other so we can create a single
				// segment that goes between them, but only if we have a nonrectilinear line
				// or the existing segment is already is routed between the two icons
				if (isOblique || ptOrig.x < ix1 || ptOrig.x > ix2) {
					if (isOblique && ptOrig.x > ix1 && ptOrig.x < ix2) 
						posF.x = ptOrig.x;
					else
						posF.x = ix1 + (ix2 - ix1) / 2;
					
					posT.x = posF.x;

					newLine.removeAllPoints();
					newLine.addPoint(posF);
					newLine.addPoint(posT);
					retVal = true;
				}
			} else {
				int iy1 = Math.max(bBoxF.getTop().y, bBoxT.getTop().y);
				int iy2 = Math.min(bBoxF.getBottom().y, bBoxT.getBottom().y);
				if (iy1 <= iy2) {
					// The two boundboxes overlap each other so we can create a single
					// segment that goes between them, but only if we have a nonrectilinear line
					// or the existing segment is already is routed between the two icons
					if (isOblique || ptOrig.y < iy1 || ptOrig.y > iy2) {
						if (isOblique && ptOrig.y > iy1 && ptOrig.y < iy2) 
							posF.y = ptOrig.y;
						else
							posF.y = iy1 + (iy2 - iy1) / 2;
						posT.y = posF.y;

						newLine.removeAllPoints();
						newLine.addPoint(posF);
						newLine.addPoint(posT);
						retVal = true;
					}
				}
d159 4
d164 11
a174 77

		return retVal;
	}
    
	/**
     * resetEndPointsToEdge
     * Resets both of the end points in the polyline to be anchored properly on the
     * edge of the start and end figures.
     * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#resetEndPointsToEdge(org.eclipse.draw2d.Connection, org.eclipse.draw2d.geometry.PointList)
     */   
    protected void resetEndPointsToEdge(Connection conn, PointList newLine) {

        // if we are reorienting, then just default to the super class implementation and
        // don't try to do rectilinear routing.
        if (isReorienting(conn)) {
            super.resetEndPointsToEdge(conn, newLine);
            return;
        }
        
        Point origin = null;
        if (conn.getSourceAnchor().getOwner() instanceof Connection) {
            origin = getIntersectionPoint((Connection) conn.getSourceAnchor()
                .getOwner(), new LineSeg(newLine.getPoint(1), newLine
                .getPoint(0)));
        }
        if (origin == null) {
            LineSeg edgeLine1 = OrthogonalRouterUtilities
                .getOrthogonalLineSegToAnchorLoc(conn, conn.getSourceAnchor(),
                    newLine.getPoint(1));
            origin = edgeLine1.getOrigin();
        }

        Point terminus = null;
        if (conn.getTargetAnchor().getOwner() instanceof Connection) {
            int numPoints = newLine.size();
            terminus = getIntersectionPoint((Connection) conn.getTargetAnchor()
                .getOwner(), new LineSeg(newLine.getPoint(numPoints - 2),
                newLine.getPoint(numPoints - 1)));
        }
        if (terminus == null) {
            LineSeg edgeLine2 = OrthogonalRouterUtilities
                .getOrthogonalLineSegToAnchorLoc(conn, conn.getTargetAnchor(),
                    newLine.getPoint(newLine.size() - 2));
            terminus = edgeLine2.getOrigin();
        }

        if (origin != null && terminus != null) {
            newLine.setPoint(origin, 0);
            if (newLine.size() > 2) {
                for (int i=0; i<2; i++) {
                    Point ptCurrent = newLine.getPoint(i);
                    Point ptNext = newLine.getPoint(i+1);
                    makeOrthogonal(ptCurrent, ptNext);
                    
                    newLine.setPoint(ptNext, i+1);
                }
            }
            
            newLine.setPoint(terminus, newLine.size() - 1);
            if (newLine.size() > 2) {
                for (int i=newLine.size() - 1; i>=newLine.size() - 2; i--) {
                    Point ptCurrent = newLine.getPoint(i);
                    Point ptNext = newLine.getPoint(i-1);
                    makeOrthogonal(ptCurrent, ptNext);
                    
                    newLine.setPoint(ptNext, i-1);
                }
            }
        } else
            super.resetEndPointsToEdge(conn, newLine);
    }

	private void makeOrthogonal(Point ptCurrent, Point ptNext) {
		if (Math.abs(ptNext.x - ptCurrent.x) < Math.abs(ptNext.y - ptCurrent.y)) {
		    ptNext.x = ptCurrent.x;
		} else {
		    ptNext.y = ptCurrent.y;
d176 1
d178 1
a178 3

	private static int CONNECTION_OFFSET = 26;

d180 8
a187 6
     * updateIfNotRectilinear
     * This is the core method that will calculate the rectilinear version of the
     * polyline points.
     * 
	 * @@param conn Connection that is the owner of the PointList
	 * @@param newLine PointList to be checked and modified
d189 56
a244 10
	protected void updateIfNotRectilinear(Connection conn, PointList newLine) {
		boolean isRectilinear = true;

		for (int i = 0; i < newLine.size() - 1; i++) {
			Ray segVector =
				new Ray(newLine.getPoint(i), newLine.getPoint(i + 1));

			if (segVector.x != 0 && segVector.y != 0) {
				isRectilinear = false;
				break;
d247 31
a277 39
        
        // first see if it is already rectilinear already
        if (isRectilinear && areEndsInBounds(conn, newLine)) {
            return;
        }

        // now try to turn it into a biterminal (i.e. one straight line)
        if (updateToBiTerminal(conn, newLine) && areEndsInBounds(conn, newLine)) {
            return;
        }

		// We've got a line that isn't rectilinear, so let's route
		// General rules based on number of segments starting with
		// if starting with two points (one segment) take shortest distance first.
		// if starting with three points (two segments) put longest segment
		//	as the middle segment
		OrthogonalRouterUtilities.resetEndPointsToCenter(conn, newLine);

		PointList oldPoints = PointListUtilities.copyPoints(newLine);

		PointList newPoints = new PointList();
		newPoints.addPoint(oldPoints.removePoint(0));
		while (oldPoints.size() > 0) {
			if (oldPoints.size() >= 2) {
				// This starts at point where last left off,
				// or the starting point if first time through.
				Point p0 = newPoints.getLastPoint();
				Point p1 = oldPoints.removePoint(0);
				Point p2 = oldPoints.removePoint(0);

				// make the shortest segment first.
				if (Math.abs(p2.y - p0.y) > Math.abs(p2.x - p0.x)) {
					// x has shortest segment
					newPoints.addPoint(new Point(p1.x, p0.y));
					newPoints.addPoint(new Point(p1.x, p2.y));
				} else // y has shortest segment first. 
					{
					newPoints.addPoint(new Point(p0.x, p1.y));
					newPoints.addPoint(new Point(p2.x, p1.y));
d279 6
a284 6
				newPoints.addPoint(p2);
			} else if (oldPoints.size() == 1) {
				Point p0 = newPoints.getLastPoint();
				Point p1 = oldPoints.removePoint(0);
				if (Math.abs(p1.y - p0.y) > Math.abs(p1.x - p0.x)) {
					newPoints.addPoint(new Point(p1.x, p0.y));
d286 40
a325 1
					newPoints.addPoint(new Point(p0.x, p1.y));
a326 1
				newPoints.addPoint(p1);
a327 1

d329 27
a355 18
		oldPoints.removeAllPoints();
		// Now make a pass through to collapse any redundent segments.
		oldPoints.addPoint(newPoints.removePoint(0));
		while (newPoints.size() >= 2) {
			Point p0 = oldPoints.getLastPoint();
			Point p1 = newPoints.getPoint(0);
			Point p2 = newPoints.getPoint(1);
			if (p0.x == p1.x && p0.x == p2.x) {
				// Have two vertical segments in a row
				// get rid of the point between
				newPoints.removePoint(0);
			} else if (p0.y == p1.y && p0.y == p2.y) {
				// Have two horizontal segments in a row
				// get rid of the point between
				newPoints.removePoint(0);
			} else {
				oldPoints.addPoint(newPoints.removePoint(0));
			}
d357 5
a361 2
		while (newPoints.size() > 0) {
			oldPoints.addPoint(newPoints.removePoint(0));
d363 2
a364 5

		// set the newly routed line back into newLine
		newLine.removeAllPoints();
		for (int i = 0; i < oldPoints.size(); i++)
			newLine.addPoint(oldPoints.getPoint(i));
d366 1
a366 1

d368 19
a386 39
     * checkEndSegments
     * This method is useful to ensure that the arrow heads and / or tail adornments
     * are always visible irrespective of any routing that occurs.  This is accomplished
     * by assert a minimum length of the line segments that are at the beginning and end
     * of the PointList. 
     * 
	 * @@param conn Connection to check the end segments of
	 * @@param newLine PointList to modify
     * @@return boolean true if end segments are ok, false otherwise.
	 */ 
	protected boolean checkEndSegments(Connection conn, PointList newLine) {
		boolean bOk = true;
        
		Dimension connection_offset = new Dimension(CONNECTION_OFFSET, 0);
		conn.translateToRelative(connection_offset);
		
        // now check for end segments length and fix up after.
		if (newLine.size() > 2) {
			Point ptFix = new Point(newLine.getPoint(1));
			if (!checkEndSegment(conn, conn.getSourceAnchor(), ptFix, connection_offset.width / 2)) {
				newLine.setPoint(ptFix, 1);
				// check next point to ensure rectilinear
				Point ptNext = newLine.getPoint(2);
				makeOrthogonal(ptFix, ptNext);
                
                newLine.setPoint(ptNext, 2);
                bOk = false;
			}

			ptFix = new Point(newLine.getPoint(newLine.size() - 2));
			if (!checkEndSegment(conn, conn.getTargetAnchor(), ptFix, connection_offset.width / 2)) {
				newLine.setPoint(ptFix, newLine.size() - 2);
				// check next point to ensure rectilinear
				Point ptNext = newLine.getPoint(newLine.size() - 3);
				makeOrthogonal(ptFix, ptNext);
                
                newLine.setPoint(ptNext, newLine.size() - 3);
                bOk = false;
			}
d388 1
a388 2
        
        return bOk;
d390 1
a390 19
    
    /**
     * straightenPoints
     * This is a simpler version of the @@see updateIfNotRectilinear that simply ensures
     * that the lines are horizontal or vertical without any intelligence in terms of 
     * shortest distance around a rectangle.
     * 
	 * @@param newLine PointList to check for rectilinear qualities and change if necessary.
	 */
	protected void straightenPoints(PointList newLine) {
        for (int i=0; i<newLine.size()-1; i++) {
            Point ptCurrent = newLine.getPoint(i);
            Point ptNext = newLine.getPoint(i+1);
            makeOrthogonal(ptCurrent, ptNext);
            
            newLine.setPoint(ptNext, i+1);
        }
    }

d392 2
a393 5
	 * checkEndSegment
	 * This method is useful to ensure that the arrow heads and / or tail adornments
	 * are always visible irrespective of any routing that occurs.  This is accomplished
	 * by assert a minimum length of the line segments that are at the beginning and end
	 * of the PointList. 
d395 2
a396 6
	 * @@param conn Connection that is used to reference the source / target anchors
	 * @@param anchor ConnectionAnchor used to calculate the edge point
	 * @@param ptNext Point that is checked against the edge to see if it's in violation.  It will
	 * be modified to a correct value if the method returns false.
     * @@param offset int value representing the offset allowed from the shape edge.
	 * @@return boolean true if end segment is ok, false otherwise.
d398 5
a402 12
	protected boolean checkEndSegment(
		Connection conn,
		ConnectionAnchor anchor,
		Point ptNext,
        int offset) {
		LineSeg seg = OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, anchor, ptNext);
		if (seg != null) {
			// ensure target line segments is bigger then a tolerance level (average arrow size)
			if (seg.length() < offset) {
				seg.pointOn(offset, LineSeg.KeyPoint.ORIGIN, ptNext);
				return false;
			}
d404 1
a404 2

		return true;
d406 3
a408 7

	private static final int maxRoutingDepth = 10;

	/**
     * Overridden method from ObliqueRouter that will perform the conversion of the
     * polyline to a rectilinear version.
     * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#routeLine(org.eclipse.draw2d.Connection, int, org.eclipse.draw2d.geometry.PointList)
d410 1
a410 11
	public void routeLine(
		Connection conn,
		int nestedRoutingDepth,
		PointList newLine) {
		boolean skipNormalization =
			(routerFlags & ROUTER_FLAG_SKIPNORMALIZATION) != 0;
			
        int nStartSize = newLine.size();
        
		// if we are reorienting, then just default to the super class implementation and
		// don't try to do rectilinear routing.
d412 7
a418 15
			super.routeLine(conn, nestedRoutingDepth, newLine);
			resetEndPointsToEdge(conn, newLine);
			return;
		}

		// get the original line
		if (checkSelfRelConnection(conn, newLine)) {
			 checkEndSegments(conn, newLine);
			 resetEndPointsToEdge(conn, newLine);
			return;
		}
		
		if (checkShapesIntersect(conn, newLine)) {
			 checkEndSegments(conn, newLine);
			 resetEndPointsToEdge(conn, newLine);
d421 72
a492 75

		// We've eliminated any unnecessary segments,
		// Now let's make sure everything is rectilinear
		updateIfNotRectilinear(conn, newLine);

		// Because we have created a polyline, it may have multiple
        // points of intersection with the originating and
        // terminating views.  We need to find the last intersection
        // point.
        boolean normalizationChangedLine = false;
		if (!skipNormalization) {
			normalizationChangedLine = removeSegmentsInViews(conn, newLine);
	    	normalizationChangedLine |= removePointsInViews(conn, newLine); 
            
            // Normalize the polyline to remove unwanted segments
			Dimension tolerance = new Dimension(3, 0);
			if (!RouterHelper.getInstance().isFeedback(conn))
				tolerance = (Dimension)MapModeUtil.getMapMode(conn).DPtoLP(tolerance);
			
            normalizationChangedLine |= PointListUtilities.normalizeSegments(newLine, tolerance.width);
		}
		
        // check the end segments to ensure they conform to a minimum distance.
        checkEndSegments(conn, newLine);
          
		resetEndPointsToEdge(conn, newLine); 
                
        // final fix-up to ensure straight lines  
        straightenPoints(newLine);
         
		if (normalizationChangedLine) {
			// May need to reposition endpoints again, so recurse. It must be
			// the case that normalization reduces the complexity of the line,
			// so that the recursion terminates.
			if (nestedRoutingDepth < maxRoutingDepth) {
				nestedRoutingDepth++; 
				routeLine(conn, nestedRoutingDepth, newLine);
				// If unwinding from setting to 0, then don't decrement.
				if (nestedRoutingDepth != 0)
					nestedRoutingDepth--;
			}
		}
        else {
            Rectangle startRect = getBounds(conn.getSourceAnchor().getOwner());
            conn.getSourceAnchor().getOwner().translateToAbsolute(startRect);
            conn.translateToRelative(startRect);
            
            Dimension buffer = new Dimension(2, 2);
    		conn.translateToRelative(buffer);
    		
            startRect.expand(buffer.width, buffer.height);
              
            Rectangle endRect = getBounds(conn.getTargetAnchor().getOwner());
            conn.getTargetAnchor().getOwner().translateToAbsolute(endRect);
            conn.translateToRelative(endRect);
            endRect.expand(buffer.width, buffer.height);
            
            if (!startRect.contains(newLine.getPoint(0)) ||
                !endRect.contains(newLine.getPoint(newLine.size() - 1)) ||
                newLine.size() - nStartSize >= 2) {
             
                newLine.removeAllPoints();
                Point r1 = conn.getSourceAnchor().getReferencePoint();
                conn.translateToRelative(r1);
                newLine.addPoint(r1);

                Point r2 = conn.getTargetAnchor().getReferencePoint();
                conn.translateToRelative(r2);
                newLine.addPoint(r2);
                
                updateIfNotRectilinear(conn, newLine);
                resetEndPointsToEdge(conn, newLine); 
            }
        }
		//## end RectRouter::routeLine%803842153.body
d494 33
d529 1
a529 2
     * Returns true if the ends of the line passed in our within the bounds of
     * the connection's source and target ends.
d531 3
a533 6
     * @@param connection
     *            the connection whose source and target ends will be looked at
     * @@param line
     *            the line in question
     * @@return true if the two ends of the lines are within the bounds; false
     *         otherwise
d535 5
a539 16
    private boolean areEndsInBounds(Connection connection, PointList line) {
        Rectangle startRect = new PrecisionRectangle(getBounds(connection
            .getSourceAnchor().getOwner()));
        connection.getSourceAnchor().getOwner().translateToAbsolute(startRect);
        connection.translateToRelative(startRect);

        Rectangle endRect = new PrecisionRectangle(getBounds(connection
            .getTargetAnchor().getOwner()));
        connection.getTargetAnchor().getOwner().translateToAbsolute(endRect);
        connection.translateToRelative(endRect);

        if (!startRect.contains(line.getPoint(0))
            || !endRect.contains(line.getPoint(line.size() - 1))) {
            return false;
        }
        return true;
d541 1
a541 1

d543 2
a544 2
     * Returns a copy of the bounds of this figure or if the figure is a
     * <code>Connection</code> the bounds of the pointlist will be returned.
d546 3
a548 2
     * @@param figure
     * @@return a copy of the bounds
d550 13
a562 4
    private Rectangle getBounds(IFigure figure) {
        return figure instanceof Connection ? ((Connection) figure).getPoints()
            .getBounds().getCopy()
            : figure.getBounds().getCopy();
d564 1
a564 1

d566 4
a569 2
     * Returns the closest intersection point from the line segment given that
     * will extend to hit the connection passed in.
d571 4
a574 6
     * @@param connection
     *            the connection
     * @@param lineSeg
     *            the line segment to extend to find intersections with the
     *            connection
     * @@return the closeest intersecting point or null if there are none
d576 15
a590 10
    private Point getIntersectionPoint(Connection connection, LineSeg lineSeg) {

        PointList intersections = lineSeg
            .getLineIntersectionsWithLineSegs(connection.getPoints());
        if (intersections.size() > 0) {
            return PointListUtilities.pickClosestPoint(intersections, lineSeg
                .getOrigin());
        }

        return null;
d592 37
a628 1
   
@


1.12
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d15 2
a16 1
import org.eclipse.draw2d.PositionConstants;
a19 1
import org.eclipse.draw2d.geometry.PrecisionPoint;
d23 2
a24 4
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.draw2d.ui.figures.BaseSlidableAnchor;
import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.figures.OrthogonalConnectionAnchor;
d30 1
a30 1
 * @@author sshaw/aboyko
a37 2
	private static int maxNestedRoutingDepth = 1;
	
d39 8
a46 3
     * Overridden method from ObliqueRouter that will perform the conversion of the
     * polyline to a rectilinear version.
     * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#routeLine(org.eclipse.draw2d.Connection, int, org.eclipse.draw2d.geometry.PointList)
d48 8
a55 12
	public void routeLine(
		Connection conn,
		int nestedRoutingDepth,
		PointList newLine) {
		boolean skipNormalization =
			(routerFlags & ROUTER_FLAG_SKIPNORMALIZATION) != 0;
			
		// if we are reorienting, then just default to the super class implementation and
		// don't try to do rectilinear routing.
		if (isReorienting(conn)) {
			super.routeLine(conn, nestedRoutingDepth, newLine);
			return;
d58 13
a70 14
		// Handle special routing: self connections and intersecting shapes connections
		if (checkSelfRelConnection(conn, newLine)
				|| checkShapesIntersect(conn, newLine)) {
			super.resetEndPointsToEdge(conn, newLine);
			OrthogonalRouterUtilities
					.transformToOrthogonalPointList(newLine,
							getOffShapeDirection(getAnchorOffRectangleDirection(
									newLine.getFirstPoint(),
									sourceBoundsRelativeToConnection(conn))),
							getOffShapeDirection(getAnchorOffRectangleDirection(
									newLine.getLastPoint(),
									targetBoundsRelativeToConnection(conn))));
			return;
		}
d72 11
a82 13
		/*
		 * Remove and store former anchor points. Anchor points will be re-calculated anyway.
		 * However, the old anchor points may be useful if connection didn't have any bend points
		 * except the anchor points.
		 */
		Point lastStartAnchor = newLine.removePoint(0);
		Point lastEndAnchor = newLine.removePoint(newLine.size() - 1);
		    	
		/*
		 * Check if connection is rectilinear and if not make it rectilinear
		 */
		if (!OrthogonalRouterUtilities.isRectilinear(newLine)) {
	    	OrthogonalRouterUtilities.transformToOrthogonalPointList(newLine, PositionConstants.NONE, PositionConstants.NONE);
d84 7
a90 24
		
		removeRedundantPoints(newLine);
		
		/*
		 * Remove unnecessary points that are contained within source and/or target shapes
		 * as well as insert extra points if all points are within source and/or target shapes
		 */
    	removePointsInViews(conn, newLine, lastStartAnchor, lastEndAnchor);
    	
		Dimension tolerance = new Dimension(3, 0);
		if (!RouterHelper.getInstance().isFeedback(conn))
			tolerance = (Dimension)MapModeUtil.getMapMode(conn).DPtoLP(tolerance);
		
		/*
		 * Normalize polyline to eliminate extra segments. (This makes 3 segments collapsing into
		 * one, while line segments are moved)
		 */
		if (!skipNormalization) {			
            if (PointListUtilities.normalizeSegments(newLine, tolerance.width)) {
            	/*
            	 * Normalization can make our polyline not rectilinear. Hence, we need to normalize
            	 * segments of polyline to straight line tolerance.
            	 */
            	normalizeToStraightLineTolerance(newLine, tolerance.width);
d93 17
a109 10
				
		/*
		 * Normalization is not touching the end points, hence we'd like to handle this here.
		 * If distance between start and end (which are the only points in a polyline) points
		 * is too short we'll remove one of the points  
		 */
		if (newLine.size() == 2) {
			Ray middleSeg = new Ray(newLine.getFirstPoint(), newLine.getLastPoint());
			if (middleSeg.length() <= tolerance.width) {
				newLine.removePoint(0);
d111 1
d113 16
a128 9
    	
		/*
		 * Calculate connection anchor points and possibly some extra routing work to keep
		 * the connection rectilinear if anchor points make it not rectilinear.  
		 */
		resetEndPointsToEdge(conn, newLine);
		
		if (nestedRoutingDepth < maxNestedRoutingDepth && !isValidRectilinearLine(conn, newLine)) {
			routeLine(conn, ++nestedRoutingDepth, newLine);
d130 2
d133 1
a133 1
	
d135 9
a143 9
	 * Rectilinear polyline is invalid if:
	 * 1. First bend point is within the source
	 * 2. Last bend point is within the target
	 * 3. First bend point and source anchor are on different sides of the source shape
	 * 4. Last bend point and target anchor are on different sides of the target shape
	 * 
	 * @@param conn connection
	 * @@param line rectilinear polyline
	 * @@return <code>true</code> if the line is valid
d145 73
a217 7
	private boolean isValidRectilinearLine(Connection conn, PointList line) {
		if (!(conn.getSourceAnchor().getOwner() instanceof Connection)) {
			Rectangle source = new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(conn.getSourceAnchor().getOwner()));
			conn.getSourceAnchor().getOwner().translateToAbsolute(source);
			conn.translateToRelative(source);
			if (source.contains(line.getPoint(1))) {
				return false;
a218 4
			int firstSegmentOrientation = line.getFirstPoint().x == line.getPoint(1).x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
			if (getOutisePointOffRectanglePosition(line.getPoint(1), source) != getAnchorLocationBasedOnSegmentOrientation(line.getFirstPoint(), source, firstSegmentOrientation)) {
				return false;
			}			
d220 77
a296 11
		if (!(conn.getTargetAnchor().getOwner() instanceof Connection)) {
			Rectangle target = new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(conn.getTargetAnchor().getOwner()));
			conn.getTargetAnchor().getOwner().translateToAbsolute(target);
			conn.translateToRelative(target);
			if (target.contains(line.getPoint(line.size() - 2))) {
				return false;
			}
			int lastSegmentOrientation = line.getLastPoint().x == line.getPoint(line.size() - 2).x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
			if (getOutisePointOffRectanglePosition(line.getPoint(line.size() - 2), target) != getAnchorLocationBasedOnSegmentOrientation(line.getLastPoint(), target, lastSegmentOrientation)) {
				return false;
			}
a297 1
		return true;
d299 3
a301 1
	
d303 6
a308 8
	 * Removes consecutive points contained within the source shape and removes consecutive
	 * points contained within the target shape. If all points have been removed an extra point
	 * outside source and target shapes will be added.
	 * 
	 * @@param conn connection
	 * @@param newLine polyline of the connection (routed connection)
	 * @@param start old start anchor point
	 * @@param end old end anchor point
d310 10
a319 39
	private void removePointsInViews(Connection conn, PointList newLine,
			Point start, Point end) {
		/*
		 * Get the bounds of anchorable figure of the source and target and translate it to
		 * connection relative coordinates.
		 */
		PrecisionRectangle source = conn.getSourceAnchor().getOwner() != null ? new PrecisionRectangle(
				FigureUtilities.getAnchorableFigureBounds(conn
						.getSourceAnchor().getOwner()))
				: null;
		PrecisionRectangle target = conn.getTargetAnchor().getOwner() != null ? new PrecisionRectangle(
				FigureUtilities.getAnchorableFigureBounds(conn
						.getTargetAnchor().getOwner()))
				: null;
		if (source != null) {
			conn.getSourceAnchor().getOwner().translateToAbsolute(source);
			conn.translateToRelative(source);
		}
		if (target != null) {
			conn.getTargetAnchor().getOwner().translateToAbsolute(target);
			conn.translateToRelative(target);
		}
		
		Point lastRemovedFromSource = null;
		Point lastRemovedFromTarget = null;
		
		/*
		 * Starting from the first point of polyline remove points that are contained
		 * within the source shape until the first point outside is found.
		 * Remember the point that was removed from the source shape last for a possible
		 * case of all points removed from polyline.
		 */
		if (!(conn.getSourceAnchor().getOwner() instanceof Connection)
				&& newLine.size() != 0
				&& source.contains(new PrecisionPoint(newLine.getFirstPoint()))) {
			lastRemovedFromSource = newLine.removePoint(0);
			for (int i = 0; i < newLine.size()
					&& source.contains(new PrecisionPoint(newLine.getPoint(i))); i++) {
				lastRemovedFromSource = newLine.removePoint(i--);
d322 39
a360 48
		
		/*
		 * Starting from the end point of polyline remove points that are contained
		 * within the target shape until the first point outside is found.
		 * Remember the point that was removed from the target shape last for a possible
		 * case of all points removed from polyline.
		 */
		if (!(conn.getTargetAnchor().getOwner() instanceof Connection)
				&& newLine.size() != 0
				&& target.contains(new PrecisionPoint(newLine.getLastPoint()))) {
			lastRemovedFromTarget = newLine.removePoint(newLine.size() - 1);
			for (int i = newLine.size(); i > 0
					&& target.contains(new PrecisionPoint(newLine
							.getPoint(i - 1))); i--) {
				lastRemovedFromTarget = newLine.removePoint(i - 1);
			}
		}
		
		/*
		 * Handle the special case of all points removed from polyline.
		 */
		if (newLine.size() == 0) {
			Dimension tolerance = new Dimension(1, 0);
			if (!RouterHelper.getInstance().isFeedback(conn))
				tolerance = (Dimension)MapModeUtil.getMapMode(conn).DPtoLP(tolerance);
			int toleranceValue = tolerance.width;
			if (lastRemovedFromSource == null) {
				lastRemovedFromSource = start;
			}
			if (lastRemovedFromTarget == null) {
				lastRemovedFromTarget = end;
			}
			/*
			 * If last point removed from source and the points removed from target form
			 * a vertical or horizontal line we'll find a point located on this line and is
			 * outside of source and target shape and insert it in the polyline.
			 * The check for vertical and horizontal segment is using tolerance value, because
			 * bend point location extracted from RelativeBendpoint can have precision errors due
			 * to non-integer weight factors.  
			 */
			if (Math.abs(lastRemovedFromSource.x - lastRemovedFromTarget.x) < toleranceValue) {
				// Vertical
				if (source.preciseY < target.preciseY) {
					newLine.addPoint(lastRemovedFromSource.x, (source
							.getBottom().y + target.getTop().y) / 2);
				} else {
					newLine.addPoint(lastRemovedFromSource.x,
							(source.getTop().y + target.getBottom().y) / 2);
d362 6
a367 6
			} else if (Math.abs(lastRemovedFromSource.y - lastRemovedFromTarget.y) < toleranceValue) {
				// Horizontal
				if (source.preciseX < target.preciseX) {
					newLine.addPoint(
							(source.getRight().x + target.getLeft().x) / 2,
							lastRemovedFromSource.y);
d369 1
a369 40
					newLine.addPoint(
							(source.getLeft().x + target.getRight().x) / 2,
							lastRemovedFromSource.y);
				}
			} else if ((conn.getSourceAnchor() instanceof BaseSlidableAnchor
					&& StringStatics.BLANK.equals(((BaseSlidableAnchor) conn
							.getSourceAnchor()).getTerminal()) && (conn
					.getTargetAnchor() instanceof BaseSlidableAnchor && StringStatics.BLANK
					.equals(((BaseSlidableAnchor) conn.getTargetAnchor())
							.getTerminal())))) {
				/*
				 * This a special case for old diagrams with rectilinear connections routed by
				 * the old router to look good with the new router
				 */
				double startX = Math.max(source.preciseX, target.preciseX);
				double endX = Math.min(source.preciseX + source.preciseWidth,
						target.preciseX + target.preciseWidth);
				double startY = Math.max(source.preciseY, target.preciseY);
				double endY = Math.min(source.preciseY + source.preciseHeight,
						target.preciseY + target.preciseHeight);
				if (startX < endX) {
					if (source.preciseY < target.preciseY) {
						newLine.addPoint((int) Math
								.round((startX + endX) / 2.0), (source
								.getBottom().y + target.getTop().y) / 2);
					} else {
						newLine.addPoint((int) Math
								.round((startX + endX) / 2.0),
								(source.getTop().y + target.getBottom().y) / 2);
					}
				} else if (startY < endY) {
					if (source.preciseX < target.preciseX) {
						newLine.addPoint((source.getRight().x + target
								.getLeft().x) / 2, (int) Math
								.round((startY + endY) / 2.0));
					} else {
						newLine.addPoint((source.getLeft().x + target
								.getRight().x) / 2, (int) Math
								.round((startY + endY) / 2.0));
					}
d371 21
d394 8
d403 1
a403 1
	
d405 15
a419 19
	 * Determines the relative to rectangle geographic location of a point.
	 * Example: If shape is closer to the the top edge of the rectangle location
	 * would be north.
	 * Method used to determine which side of shape's bounding rectangle is closer
	 * to connection's anchor point.
	 * All geometric quantities must be in the same coordinate system. 
	 * 
	 * @@param anchorPoint location of the anchor point
	 * @@param rect bounding rectangle of the shape
	 * @@return
	 */
	private int getAnchorOffRectangleDirection(Point anchorPoint, Rectangle rect) {
		int position = PositionConstants.NORTH;
		int criteriaValue = Math.abs(anchorPoint.y - rect.y);
		int tempCriteria = Math.abs(anchorPoint.y - rect.y - rect.height);
		if (tempCriteria < criteriaValue) {
			criteriaValue = tempCriteria;
			position = PositionConstants.SOUTH;
		}
d421 23
a443 4
		tempCriteria = Math.abs(anchorPoint.x - rect.x);
		if (tempCriteria < criteriaValue) {
			criteriaValue = tempCriteria;
			position = PositionConstants.WEST;
d445 2
a446 8
		
		tempCriteria = Math.abs(anchorPoint.x - rect.x - rect.width);
		if (tempCriteria < criteriaValue) {
			criteriaValue = tempCriteria;
			position = PositionConstants.EAST;
		}
		
		return position; 		
d448 19
a466 1
	
d468 5
a472 3
	 * Returns a translation dimension for the anchor point. Translation dimension
	 * translates the anchor point off the shape. The off shape direction
	 * is specified by the relative to the shape geographic position of the anchor  
d474 6
a479 4
	 * @@param position relative to the shape geographic position of the anchor
	 * @@param xFactorValue translation value along x-axis
	 * @@param yFactorValue translation value along y-axis
	 * @@return
d481 12
a492 10
	private Dimension getTranslationValue(int position, int xFactorValue, int yFactorValue) {
		Dimension translationDimension = new Dimension();
		if (position == PositionConstants.EAST) {
			translationDimension.width = xFactorValue;
		} else if (position == PositionConstants.SOUTH) {
			translationDimension.height = yFactorValue;
		} else if (position == PositionConstants.WEST) {
			translationDimension.width = -xFactorValue;
		} else if (position == PositionConstants.NORTH) {
			translationDimension.height = -yFactorValue;
d494 2
a495 1
		return translationDimension;
d497 3
a499 1
	
d501 3
a503 5
	 * Determines whether the rectilinear line segment coming out of the shape should be
	 * horizontal or vertical based on the anchor geographic position relative to the shape 
	 * 
	 * @@param anchorRelativeLocation
	 * @@return
d505 22
a526 5
	private int getOffShapeDirection(int anchorRelativeLocation) {
		if (anchorRelativeLocation == PositionConstants.EAST || anchorRelativeLocation == PositionConstants.WEST) {
			return PositionConstants.HORIZONTAL;
		} else if (anchorRelativeLocation == PositionConstants.NORTH || anchorRelativeLocation == PositionConstants.SOUTH) {
			return PositionConstants.VERTICAL;
d528 4
a531 15
		return PositionConstants.NONE;
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#resetEndPointsToEdge(org.eclipse.draw2d.Connection, org.eclipse.draw2d.geometry.PointList)
	 */
	protected void resetEndPointsToEdge(Connection conn, PointList line) {
		if (isReorienting(conn)) {
			/*
			 * If the connection doesn't have a shape as a source or target we'll
			 * let the oblique router to do the work. The connection doesn't need to
			 * be rectilinear at this point. There is no support for making a rectilinear
			 * connection for which one of the ends is not connected to anything. 
			 */
			super.resetEndPointsToEdge(conn, line);
d534 75
a608 72
    	PrecisionRectangle source = sourceBoundsRelativeToConnection(conn);
    	PrecisionRectangle target = targetBoundsRelativeToConnection(conn);
    	int offSourceDirection = PositionConstants.NONE;
    	int offTargetDirection = PositionConstants.NONE;
		int sourceAnchorRelativeLocation = PositionConstants.NONE;
		int targetAnchorRelativeLocation = PositionConstants.NONE;
    	if (line.size() == 0) {
    		/*
    		 * If there are no valid bend points, we'll use the oblique connection anchor points
    		 * and just convert the polyline from oblique to rectilinear. 
    		 */
    		// Need to add 2 dumb points to ensure that RouterHelper#resetEndPointsToEdge works
    		line.addPoint(new Point());
    		line.addPoint(new Point());
    		super.resetEndPointsToEdge(conn, line);
    		sourceAnchorRelativeLocation = getAnchorOffRectangleDirection(line.getFirstPoint(), source);
    		targetAnchorRelativeLocation = getAnchorOffRectangleDirection(line.getLastPoint(), target);
    		/*
    		 * We need to find two points offset from the source and target anchors outside the shapes
    		 * such that when the polyline is converted to rectilinear from oblique we won't have
    		 * rectilinear line segments alligned with source or target shapes edges.
    		 */
    		Point offStart = line.getFirstPoint();
    		Point offEnd = line.getLastPoint();
    		Dimension offsetDim = offStart.getDifference(offEnd).scale(0.3);
    		offStart.translate(getTranslationValue(sourceAnchorRelativeLocation, Math.abs(offsetDim.width), Math.abs(offsetDim.height)));
    		offEnd.translate(getTranslationValue(targetAnchorRelativeLocation, Math.abs(offsetDim.width), Math.abs(offsetDim.height)));
    		line.insertPoint(offStart, 1);
    		line.insertPoint(offEnd, 2);
    		offSourceDirection = getOffShapeDirection(sourceAnchorRelativeLocation);
    		offTargetDirection = getOffShapeDirection(targetAnchorRelativeLocation);
    	} else {
	        Point start = line.getFirstPoint();
	        Point end = line.getLastPoint();
	    	if (conn.getSourceAnchor() instanceof OrthogonalConnectionAnchor) {
	            line.insertPoint(OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, conn.getSourceAnchor(), start).getOrigin(), 0);
	    	} else {
	    		/*
	    		 * If anchor is not supporting orthogonal connections we'll use the oblique connection
	    		 * anchors and then convert it to rectilinear.
	    		 */
	    		PrecisionPoint reference = new PrecisionPoint(start);
	    		conn.getSourceAnchor().getOwner().translateToAbsolute(reference);
	    		PrecisionPoint anchorLocation = new PrecisionPoint(conn.getSourceAnchor().getLocation(reference));
				conn.translateToRelative(anchorLocation);
				line.insertPoint(anchorLocation, 0);
	    	}
	    	if (conn.getTargetAnchor() instanceof OrthogonalConnectionAnchor) {
	            line.addPoint(OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, conn.getTargetAnchor(), end).getOrigin());
	    	} else {
	    		/*
	    		 * If anchor is not supporting orthogonal connections we'll use the oblique connection
	    		 * anchors and then convert it to rectilinear.
	    		 */
	    		PrecisionPoint reference = new PrecisionPoint(end);
	    		conn.getSourceAnchor().getOwner().translateToAbsolute(reference);
	    		PrecisionPoint anchorLocation = new PrecisionPoint(conn.getTargetAnchor().getLocation(reference));
				conn.translateToRelative(anchorLocation);
				line.addPoint(anchorLocation);
	    	}
	    	sourceAnchorRelativeLocation = getAnchorOffRectangleDirection(line.getFirstPoint(), source);
            offSourceDirection = getOffShapeDirection(sourceAnchorRelativeLocation);
	    	targetAnchorRelativeLocation = getAnchorOffRectangleDirection(line.getLastPoint(), target);
            offTargetDirection = getOffShapeDirection(targetAnchorRelativeLocation);
    	}

    	/*
    	 * Convert the polyline to rectilinear. If the connection is rectilinear already then the
    	 * connection will remain as it is.
    	 */
		OrthogonalRouterUtilities.transformToOrthogonalPointList(line, offSourceDirection, offTargetDirection);
		removeRedundantPoints(line);
a609 33
	
    /**
     * Goes through line segments of a polyline and makes strict straight segments
     * from nearly straight segments.
     * 
     * @@param line polyline
     * @@param tolerance tolerance value specifying nearly straight lines.
     */
    private void normalizeToStraightLineTolerance(PointList line, int tolerance) {
    	for (int i = 0; i < line.size() - 1; i++) {
    		Point pt1 = line.getPoint(i);
    		Point pt2 = line.getPoint(i + 1);
    		if (Math.abs(pt1.x - pt2.x) < tolerance) {
    			line.setPoint(new Point(pt1.x, pt2.y), i + 1);
    		} else if (Math.abs(pt1.y - pt2.y) < tolerance) {
    			line.setPoint(new Point(pt2.x, pt1.y), i + 1);
    		}
    	}
    }
        
    /**
     * Source bounding rectangle relative to connection figure coordinates
     * 
     * @@param conn connection
     * @@return <code>PrecisionRectangle</code> source bounds relative to connection's coordinate
     * system
     */
    private PrecisionRectangle sourceBoundsRelativeToConnection(Connection conn) {
    	PrecisionRectangle source = new PrecisionRectangle(conn.getSourceAnchor().getOwner().getBounds());
    	conn.getSourceAnchor().getOwner().translateToAbsolute(source);
    	conn.translateToRelative(source);
    	return source;
    }
d612 2
a613 1
     * Target bounding rectangle relative to connection figure coordinates
d615 6
a620 3
     * @@param conn connection
     * @@return <code>PrecisionRectangle</code> target bounds relative to connection's coordinate
     * system
d622 16
a637 5
    private PrecisionRectangle targetBoundsRelativeToConnection(Connection conn) {
    	PrecisionRectangle target = new PrecisionRectangle(conn.getTargetAnchor().getOwner().getBounds());
    	conn.getTargetAnchor().getOwner().translateToAbsolute(target);
    	conn.translateToRelative(target);
    	return target;
d639 1
a639 1
    
d641 2
a642 2
     * Calculates geographic position of a point located outside the given rectangle relative
     * to the rectangle 
d644 2
a645 3
     * @@param p point outside of rectangle
     * @@param r the rectangle
     * @@return geographic position of the point relative to the recatangle
d647 4
a650 13
    private int getOutisePointOffRectanglePosition(Point p, Rectangle r) {
    	int position = PositionConstants.NONE;
    	if (r.x > p.x) {
    		position |= PositionConstants.WEST;
    	} else if (r.x + r.width < p.x) {
    		position |= PositionConstants.EAST;
    	}
    	if (r.y > p.y) {
    		position |= PositionConstants.NORTH;
    	} else if (r.y + r.height < p.y) {
    		position |= PositionConstants.SOUTH;
    	}
    	return position;
d652 1
a652 1
    
d654 2
a655 4
     * Given the coordinates of the connection anchor point the shape's rectangle and the
     * orientation of the first rectilinear connection segment that comes out from the anchor
     * point the method detemines on which geographic side of the rectangle the anchor point
     * is located on. 
d657 6
a662 4
     * @@param anchorPoint coordinates of the anchor point
     * @@param rectangle the shape's bounding rectangle
     * @@param segmentOrientation orinetation of the segment coming out from the anchor point
     * @@return geographic position of the anchor point relative to the rectangle
d664 10
a673 15
    private int getAnchorLocationBasedOnSegmentOrientation(Point anchorPoint, Rectangle rectangle, int segmentOrientation) {
    	if (segmentOrientation == PositionConstants.VERTICAL) {
    		if (Math.abs(anchorPoint.y - rectangle.y) < Math.abs(anchorPoint.y - rectangle.y - rectangle.height)) {
    			return PositionConstants.NORTH;
    		} else {
    			return PositionConstants.SOUTH;
    		}
    	} else if (segmentOrientation == PositionConstants.HORIZONTAL) {
    		if (Math.abs(anchorPoint.x - rectangle.x) < Math.abs(anchorPoint.x - rectangle.x - rectangle.width)) {
    			return PositionConstants.WEST;
    		} else {
    			return PositionConstants.EAST;
    		}
    	}
    	return PositionConstants.NONE;
d675 1
a675 37
    
	/**
	 * Iterates through points of a polyline and does the following:
	 * if 3 points lie on the same line the middle point is removed
	 * 
	 * @@param line polyline's points
	 */
	private boolean removeRedundantPoints(PointList line) {
		int initialNumberOfPoints = line.size();
		if (line.size() > 2) {
			PointList newLine = new PointList(line.size()); 
			newLine.addPoint(line.removePoint(0));
			while (line.size() >= 2) {
				Point p0 = newLine.getLastPoint();
				Point p1 = line.getPoint(0);
				Point p2 = line.getPoint(1);
				if (p0.x == p1.x && p0.x == p2.x) {
					// Have two vertical segments in a row
					// get rid of the point between
					line.removePoint(0);
				} else if (p0.y == p1.y && p0.y == p2.y) {
					// Have two horizontal segments in a row
					// get rid of the point between
					line.removePoint(0);
				} else {
					newLine.addPoint(line.removePoint(0));
				}
			}
			while (line.size() > 0) {
				newLine.addPoint(line.removePoint(0));
			}
			line.removeAllPoints();
			line.addAll(newLine);
		}
		return line.size() != initialNumberOfPoints;
	}
    
@


1.11
log
@[198455] gmf_head aboyko 070815 [Layout] Connection between 2 intersecting shapes is often drawn within the intersection of the shapes
@
text
@d15 1
a15 2
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.IFigure;
d19 1
d23 4
a26 2

import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
d32 1
a32 1
 * @@author sshaw
d40 2
d43 3
a45 8
     * removeSegmentsInViews
     * This method will parse through all the line segments in the given 
     * polyline and remove any of the segments that intersect with the 
     * start and end figures.
     * 
	 * @@param conn Connection figure that is used to access anchors
	 * @@param newLine PointList that will be modified by the routine.
	 * @@return boolean true if method change newLine PointList, false otherwise
d47 12
a58 8
	protected boolean removeSegmentsInViews(Connection conn, PointList newLine) {
		// Ignore the first and last points
		PointList newPoints = new PointList(newLine.size());
		Point ptStart = new Point(newLine.getFirstPoint());
		Point ptEnd = new Point(newLine.getLastPoint());
		for (int i = 0; i < newLine.size(); i++) {
			if (i != 0 && i != newLine.size() - 1)
				newPoints.addPoint(new Point(newLine.getPoint(i)));
d61 14
a74 13
		if (newPoints.size() < 3)
			return false;

		int lastIntersect = 0;
		int count = 0;
		boolean found = false;
        boolean bChanged = false;
        IFigure sourceFigure = conn.getSourceAnchor().getOwner();

		if (sourceFigure == null)
			return false;

		PointList startPolygon = getFigurePolygon(sourceFigure,conn);
d76 13
a88 11
		for (int i = 0; i < newPoints.size() - 1; i++) {
            boolean in1 = PointListUtilities.containsPoint(startPolygon, newPoints.getPoint(i));
 			boolean in2 = PointListUtilities.containsPoint(startPolygon, newPoints.getPoint(i+1));
 			if (in1 != in2) {
				lastIntersect = count;
				found = true;
			} else if (!(in1 || in2)) // Neither intersect, so skip out
				{
				break;
			}
			++count;
d90 24
a113 7

		// remove segments before the one that finally
		// intersects:
		if (found) {
			for (int i = 0; i <= lastIntersect; ++i) {
				newPoints.removePoint(0);
                bChanged = true;
d116 10
a125 17

		lastIntersect = count = newLine.size() - 1;
		found = false;
		IFigure targetFigure = conn.getTargetAnchor().getOwner();
		if (targetFigure == null)
			return false;

        PointList endPolygon = getFigurePolygon(targetFigure,conn);
		for (int i = newPoints.size() - 1; i > 0; i--) {
		    boolean in1 = PointListUtilities.containsPoint(endPolygon,newPoints.getPoint(i));
			boolean in2 = PointListUtilities.containsPoint(endPolygon,newPoints.getPoint(i - 1));
			if (in1 != in2) {
				lastIntersect = count;
				found = true;
			} else if (!(in1 || in2)) // Neither intersect, so skip out
				{
				break;
a126 1
			--count;
d128 9
a136 8

		// remove segments after the one that finally
		// intersects:
		if (found) {
			for (int i = newPoints.size() - 1; i >= lastIntersect; --i) {
				newPoints.removePoint(newPoints.size() - 1);
                bChanged = true;
            }
a137 10

		if (newPoints.size() != newLine.size()) {
			newLine.removeAllPoints();
			newLine.addPoint(ptStart);
			for (int i = 0; i < newPoints.size(); i++)
				newLine.addPoint(new Point(newPoints.getPoint(i)));
			newLine.addPoint(ptEnd);
		}
        
        return bChanged;
d139 1
a139 1
    
d141 9
a149 9
     * updateToBiTerminal
     * Determines if the polyline has only two bendpoints (endpoints) and if so,
     * updates the connection to be consistent with the Rectilinear router - i.e.
     * vertical or horizontal alignment.
     * 
	 * @@param conn Connection that is being routed.
	 * @@param newLine PointList to be checked and modified if bi-terminal routing is
     * possible
	 * @@return true if PointList is a candidate for bi-terminal routing, false otherwise
d151 7
a157 73
	protected boolean updateToBiTerminal(Connection conn, PointList newLine) {
		boolean retVal = false;

		if (newLine.size() == 2) {
			Point ptOrig = new Point(newLine.getPoint(0));
			Point ptTerm = new Point(newLine.getPoint(1));

			Dimension offsets = new Dimension(10, 10);
			conn.translateToRelative(offsets);
			
			Rectangle bBoxF, bBoxT;
			if (conn.getSourceAnchor().getOwner() != null) {
				bBoxF = getBounds(conn.getSourceAnchor().getOwner());
				conn.getSourceAnchor().getOwner().translateToAbsolute(bBoxF);
				conn.translateToRelative(bBoxF);
			} else
				bBoxF = new Rectangle(ptOrig.x - offsets.width / 2, ptOrig.y - offsets.height / 2, 
											offsets.width, offsets.height);

            if (conn.getTargetAnchor().getOwner() != null) {
                bBoxT = getBounds(conn.getTargetAnchor().getOwner());
				conn.getTargetAnchor().getOwner().translateToAbsolute(bBoxT);
				conn.translateToRelative(bBoxT);
			} else
				bBoxT = new Rectangle(ptTerm.x - offsets.width / 2, ptTerm.y - offsets.height / 2, 
											offsets.width, offsets.height);

			int ix1 = Math.max(bBoxF.getLeft().x, bBoxT.getLeft().x);
			int ix2 = Math.min(bBoxF.getRight().x, bBoxT.getRight().x);

			Point posF = bBoxF.getCenter();
			Point posT = bBoxT.getCenter();

			Ray origSeg = new Ray(ptOrig, ptTerm);
			boolean isOblique = (origSeg.y != 0 && origSeg.x != 0);

			if (ix1 <= ix2) {
				// The two boundboxes overlap each other so we can create a single
				// segment that goes between them, but only if we have a nonrectilinear line
				// or the existing segment is already is routed between the two icons
				if (isOblique || ptOrig.x < ix1 || ptOrig.x > ix2) {
					if (isOblique && ptOrig.x > ix1 && ptOrig.x < ix2) 
						posF.x = ptOrig.x;
					else
						posF.x = ix1 + (ix2 - ix1) / 2;
					
					posT.x = posF.x;

					newLine.removeAllPoints();
					newLine.addPoint(posF);
					newLine.addPoint(posT);
					retVal = true;
				}
			} else {
				int iy1 = Math.max(bBoxF.getTop().y, bBoxT.getTop().y);
				int iy2 = Math.min(bBoxF.getBottom().y, bBoxT.getBottom().y);
				if (iy1 <= iy2) {
					// The two boundboxes overlap each other so we can create a single
					// segment that goes between them, but only if we have a nonrectilinear line
					// or the existing segment is already is routed between the two icons
					if (isOblique || ptOrig.y < iy1 || ptOrig.y > iy2) {
						if (isOblique && ptOrig.y > iy1 && ptOrig.y < iy2) 
							posF.y = ptOrig.y;
						else
							posF.y = iy1 + (iy2 - iy1) / 2;
						posT.y = posF.y;

						newLine.removeAllPoints();
						newLine.addPoint(posF);
						newLine.addPoint(posT);
						retVal = true;
					}
				}
d159 4
d164 11
a174 77

		return retVal;
	}
    
	/**
     * resetEndPointsToEdge
     * Resets both of the end points in the polyline to be anchored properly on the
     * edge of the start and end figures.
     * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#resetEndPointsToEdge(org.eclipse.draw2d.Connection, org.eclipse.draw2d.geometry.PointList)
     */   
    protected void resetEndPointsToEdge(Connection conn, PointList newLine) {

        // if we are reorienting, then just default to the super class implementation and
        // don't try to do rectilinear routing.
        if (isReorienting(conn)) {
            super.resetEndPointsToEdge(conn, newLine);
            return;
        }
        
        Point origin = null;
        if (conn.getSourceAnchor().getOwner() instanceof Connection) {
            origin = getIntersectionPoint((Connection) conn.getSourceAnchor()
                .getOwner(), new LineSeg(newLine.getPoint(1), newLine
                .getPoint(0)));
        }
        if (origin == null) {
            LineSeg edgeLine1 = OrthogonalRouterUtilities
                .getOrthogonalLineSegToAnchorLoc(conn, conn.getSourceAnchor(),
                    newLine.getPoint(1));
            origin = edgeLine1.getOrigin();
        }

        Point terminus = null;
        if (conn.getTargetAnchor().getOwner() instanceof Connection) {
            int numPoints = newLine.size();
            terminus = getIntersectionPoint((Connection) conn.getTargetAnchor()
                .getOwner(), new LineSeg(newLine.getPoint(numPoints - 2),
                newLine.getPoint(numPoints - 1)));
        }
        if (terminus == null) {
            LineSeg edgeLine2 = OrthogonalRouterUtilities
                .getOrthogonalLineSegToAnchorLoc(conn, conn.getTargetAnchor(),
                    newLine.getPoint(newLine.size() - 2));
            terminus = edgeLine2.getOrigin();
        }

        if (origin != null && terminus != null) {
            newLine.setPoint(origin, 0);
            if (newLine.size() > 2) {
                for (int i=0; i<2; i++) {
                    Point ptCurrent = newLine.getPoint(i);
                    Point ptNext = newLine.getPoint(i+1);
                    makeOrthogonal(ptCurrent, ptNext);
                    
                    newLine.setPoint(ptNext, i+1);
                }
            }
            
            newLine.setPoint(terminus, newLine.size() - 1);
            if (newLine.size() > 2) {
                for (int i=newLine.size() - 1; i>=newLine.size() - 2; i--) {
                    Point ptCurrent = newLine.getPoint(i);
                    Point ptNext = newLine.getPoint(i-1);
                    makeOrthogonal(ptCurrent, ptNext);
                    
                    newLine.setPoint(ptNext, i-1);
                }
            }
        } else
            super.resetEndPointsToEdge(conn, newLine);
    }

	private void makeOrthogonal(Point ptCurrent, Point ptNext) {
		if (Math.abs(ptNext.x - ptCurrent.x) < Math.abs(ptNext.y - ptCurrent.y)) {
		    ptNext.x = ptCurrent.x;
		} else {
		    ptNext.y = ptCurrent.y;
d176 1
d178 1
a178 3

	private static int CONNECTION_OFFSET = 26;

d180 8
a187 6
     * updateIfNotRectilinear
     * This is the core method that will calculate the rectilinear version of the
     * polyline points.
     * 
	 * @@param conn Connection that is the owner of the PointList
	 * @@param newLine PointList to be checked and modified
d189 56
a244 10
	protected void updateIfNotRectilinear(Connection conn, PointList newLine) {
		boolean isRectilinear = true;

		for (int i = 0; i < newLine.size() - 1; i++) {
			Ray segVector =
				new Ray(newLine.getPoint(i), newLine.getPoint(i + 1));

			if (segVector.x != 0 && segVector.y != 0) {
				isRectilinear = false;
				break;
d247 31
a277 39
        
        // first see if it is already rectilinear already
        if (isRectilinear && areEndsInBounds(conn, newLine)) {
            return;
        }

        // now try to turn it into a biterminal (i.e. one straight line)
        if (updateToBiTerminal(conn, newLine) && areEndsInBounds(conn, newLine)) {
            return;
        }

		// We've got a line that isn't rectilinear, so let's route
		// General rules based on number of segments starting with
		// if starting with two points (one segment) take shortest distance first.
		// if starting with three points (two segments) put longest segment
		//	as the middle segment
		OrthogonalRouterUtilities.resetEndPointsToCenter(conn, newLine);

		PointList oldPoints = PointListUtilities.copyPoints(newLine);

		PointList newPoints = new PointList();
		newPoints.addPoint(oldPoints.removePoint(0));
		while (oldPoints.size() > 0) {
			if (oldPoints.size() >= 2) {
				// This starts at point where last left off,
				// or the starting point if first time through.
				Point p0 = newPoints.getLastPoint();
				Point p1 = oldPoints.removePoint(0);
				Point p2 = oldPoints.removePoint(0);

				// make the shortest segment first.
				if (Math.abs(p2.y - p0.y) > Math.abs(p2.x - p0.x)) {
					// x has shortest segment
					newPoints.addPoint(new Point(p1.x, p0.y));
					newPoints.addPoint(new Point(p1.x, p2.y));
				} else // y has shortest segment first. 
					{
					newPoints.addPoint(new Point(p0.x, p1.y));
					newPoints.addPoint(new Point(p2.x, p1.y));
d279 6
a284 6
				newPoints.addPoint(p2);
			} else if (oldPoints.size() == 1) {
				Point p0 = newPoints.getLastPoint();
				Point p1 = oldPoints.removePoint(0);
				if (Math.abs(p1.y - p0.y) > Math.abs(p1.x - p0.x)) {
					newPoints.addPoint(new Point(p1.x, p0.y));
d286 40
a325 1
					newPoints.addPoint(new Point(p0.x, p1.y));
a326 1
				newPoints.addPoint(p1);
a327 1

d329 27
a355 18
		oldPoints.removeAllPoints();
		// Now make a pass through to collapse any redundent segments.
		oldPoints.addPoint(newPoints.removePoint(0));
		while (newPoints.size() >= 2) {
			Point p0 = oldPoints.getLastPoint();
			Point p1 = newPoints.getPoint(0);
			Point p2 = newPoints.getPoint(1);
			if (p0.x == p1.x && p0.x == p2.x) {
				// Have two vertical segments in a row
				// get rid of the point between
				newPoints.removePoint(0);
			} else if (p0.y == p1.y && p0.y == p2.y) {
				// Have two horizontal segments in a row
				// get rid of the point between
				newPoints.removePoint(0);
			} else {
				oldPoints.addPoint(newPoints.removePoint(0));
			}
d357 5
a361 2
		while (newPoints.size() > 0) {
			oldPoints.addPoint(newPoints.removePoint(0));
d363 2
a364 5

		// set the newly routed line back into newLine
		newLine.removeAllPoints();
		for (int i = 0; i < oldPoints.size(); i++)
			newLine.addPoint(oldPoints.getPoint(i));
d366 1
a366 1

d368 19
a386 39
     * checkEndSegments
     * This method is useful to ensure that the arrow heads and / or tail adornments
     * are always visible irrespective of any routing that occurs.  This is accomplished
     * by assert a minimum length of the line segments that are at the beginning and end
     * of the PointList. 
     * 
	 * @@param conn Connection to check the end segments of
	 * @@param newLine PointList to modify
     * @@return boolean true if end segments are ok, false otherwise.
	 */ 
	protected boolean checkEndSegments(Connection conn, PointList newLine) {
		boolean bOk = true;
        
		Dimension connection_offset = new Dimension(CONNECTION_OFFSET, 0);
		conn.translateToRelative(connection_offset);
		
        // now check for end segments length and fix up after.
		if (newLine.size() > 2) {
			Point ptFix = new Point(newLine.getPoint(1));
			if (!checkEndSegment(conn, conn.getSourceAnchor(), ptFix, connection_offset.width / 2)) {
				newLine.setPoint(ptFix, 1);
				// check next point to ensure rectilinear
				Point ptNext = newLine.getPoint(2);
				makeOrthogonal(ptFix, ptNext);
                
                newLine.setPoint(ptNext, 2);
                bOk = false;
			}

			ptFix = new Point(newLine.getPoint(newLine.size() - 2));
			if (!checkEndSegment(conn, conn.getTargetAnchor(), ptFix, connection_offset.width / 2)) {
				newLine.setPoint(ptFix, newLine.size() - 2);
				// check next point to ensure rectilinear
				Point ptNext = newLine.getPoint(newLine.size() - 3);
				makeOrthogonal(ptFix, ptNext);
                
                newLine.setPoint(ptNext, newLine.size() - 3);
                bOk = false;
			}
d388 1
a388 2
        
        return bOk;
d390 1
a390 19
    
    /**
     * straightenPoints
     * This is a simpler version of the @@see updateIfNotRectilinear that simply ensures
     * that the lines are horizontal or vertical without any intelligence in terms of 
     * shortest distance around a rectangle.
     * 
	 * @@param newLine PointList to check for rectilinear qualities and change if necessary.
	 */
	protected void straightenPoints(PointList newLine) {
        for (int i=0; i<newLine.size()-1; i++) {
            Point ptCurrent = newLine.getPoint(i);
            Point ptNext = newLine.getPoint(i+1);
            makeOrthogonal(ptCurrent, ptNext);
            
            newLine.setPoint(ptNext, i+1);
        }
    }

d392 2
a393 5
	 * checkEndSegment
	 * This method is useful to ensure that the arrow heads and / or tail adornments
	 * are always visible irrespective of any routing that occurs.  This is accomplished
	 * by assert a minimum length of the line segments that are at the beginning and end
	 * of the PointList. 
d395 2
a396 6
	 * @@param conn Connection that is used to reference the source / target anchors
	 * @@param anchor ConnectionAnchor used to calculate the edge point
	 * @@param ptNext Point that is checked against the edge to see if it's in violation.  It will
	 * be modified to a correct value if the method returns false.
     * @@param offset int value representing the offset allowed from the shape edge.
	 * @@return boolean true if end segment is ok, false otherwise.
d398 5
a402 12
	protected boolean checkEndSegment(
		Connection conn,
		ConnectionAnchor anchor,
		Point ptNext,
        int offset) {
		LineSeg seg = OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, anchor, ptNext);
		if (seg != null) {
			// ensure target line segments is bigger then a tolerance level (average arrow size)
			if (seg.length() < offset) {
				seg.pointOn(offset, LineSeg.KeyPoint.ORIGIN, ptNext);
				return false;
			}
d404 1
a404 2

		return true;
d406 3
a408 7

	private static final int maxRoutingDepth = 10;

	/**
     * Overridden method from ObliqueRouter that will perform the conversion of the
     * polyline to a rectilinear version.
     * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#routeLine(org.eclipse.draw2d.Connection, int, org.eclipse.draw2d.geometry.PointList)
d410 1
a410 11
	public void routeLine(
		Connection conn,
		int nestedRoutingDepth,
		PointList newLine) {
		boolean skipNormalization =
			(routerFlags & ROUTER_FLAG_SKIPNORMALIZATION) != 0;
			
        int nStartSize = newLine.size();
        
		// if we are reorienting, then just default to the super class implementation and
		// don't try to do rectilinear routing.
d412 7
a418 15
			super.routeLine(conn, nestedRoutingDepth, newLine);
			resetEndPointsToEdge(conn, newLine);
			return;
		}

		// get the original line
		if (checkSelfRelConnection(conn, newLine)) {
			 checkEndSegments(conn, newLine);
			 resetEndPointsToEdge(conn, newLine);
			return;
		}
		
		if (checkShapesIntersect(conn, newLine)) {
			 checkEndSegments(conn, newLine);
			 resetEndPointsToEdge(conn, newLine);
d421 72
a492 75

		// We've eliminated any unnecessary segments,
		// Now let's make sure everything is rectilinear
		updateIfNotRectilinear(conn, newLine);

		// Because we have created a polyline, it may have multiple
        // points of intersection with the originating and
        // terminating views.  We need to find the last intersection
        // point.
        boolean normalizationChangedLine = false;
		if (!skipNormalization) {
			normalizationChangedLine = removeSegmentsInViews(conn, newLine);
	    	normalizationChangedLine |= removePointsInViews(conn, newLine); 
            
            // Normalize the polyline to remove unwanted segments
			Dimension tolerance = new Dimension(3, 0);
			if (!RouterHelper.getInstance().isFeedback(conn))
				tolerance = (Dimension)MapModeUtil.getMapMode(conn).DPtoLP(tolerance);
			
            normalizationChangedLine |= PointListUtilities.normalizeSegments(newLine, tolerance.width);
		}
		
        // check the end segments to ensure they conform to a minimum distance.
        checkEndSegments(conn, newLine);
          
		resetEndPointsToEdge(conn, newLine); 
                
        // final fix-up to ensure straight lines  
        straightenPoints(newLine);
         
		if (normalizationChangedLine) {
			// May need to reposition endpoints again, so recurse. It must be
			// the case that normalization reduces the complexity of the line,
			// so that the recursion terminates.
			if (nestedRoutingDepth < maxRoutingDepth) {
				nestedRoutingDepth++; 
				routeLine(conn, nestedRoutingDepth, newLine);
				// If unwinding from setting to 0, then don't decrement.
				if (nestedRoutingDepth != 0)
					nestedRoutingDepth--;
			}
		}
        else {
            Rectangle startRect = getBounds(conn.getSourceAnchor().getOwner());
            conn.getSourceAnchor().getOwner().translateToAbsolute(startRect);
            conn.translateToRelative(startRect);
            
            Dimension buffer = new Dimension(2, 2);
    		conn.translateToRelative(buffer);
    		
            startRect.expand(buffer.width, buffer.height);
              
            Rectangle endRect = getBounds(conn.getTargetAnchor().getOwner());
            conn.getTargetAnchor().getOwner().translateToAbsolute(endRect);
            conn.translateToRelative(endRect);
            endRect.expand(buffer.width, buffer.height);
            
            if (!startRect.contains(newLine.getPoint(0)) ||
                !endRect.contains(newLine.getPoint(newLine.size() - 1)) ||
                newLine.size() - nStartSize >= 2) {
             
                newLine.removeAllPoints();
                Point r1 = conn.getSourceAnchor().getReferencePoint();
                conn.translateToRelative(r1);
                newLine.addPoint(r1);

                Point r2 = conn.getTargetAnchor().getReferencePoint();
                conn.translateToRelative(r2);
                newLine.addPoint(r2);
                
                updateIfNotRectilinear(conn, newLine);
                resetEndPointsToEdge(conn, newLine); 
            }
        }
		//## end RectRouter::routeLine%803842153.body
d494 33
d529 1
a529 2
     * Returns true if the ends of the line passed in our within the bounds of
     * the connection's source and target ends.
d531 3
a533 6
     * @@param connection
     *            the connection whose source and target ends will be looked at
     * @@param line
     *            the line in question
     * @@return true if the two ends of the lines are within the bounds; false
     *         otherwise
d535 5
a539 16
    private boolean areEndsInBounds(Connection connection, PointList line) {
        Rectangle startRect = new PrecisionRectangle(getBounds(connection
            .getSourceAnchor().getOwner()));
        connection.getSourceAnchor().getOwner().translateToAbsolute(startRect);
        connection.translateToRelative(startRect);

        Rectangle endRect = new PrecisionRectangle(getBounds(connection
            .getTargetAnchor().getOwner()));
        connection.getTargetAnchor().getOwner().translateToAbsolute(endRect);
        connection.translateToRelative(endRect);

        if (!startRect.contains(line.getPoint(0))
            || !endRect.contains(line.getPoint(line.size() - 1))) {
            return false;
        }
        return true;
d541 1
a541 1

d543 2
a544 2
     * Returns a copy of the bounds of this figure or if the figure is a
     * <code>Connection</code> the bounds of the pointlist will be returned.
d546 3
a548 2
     * @@param figure
     * @@return a copy of the bounds
d550 13
a562 4
    private Rectangle getBounds(IFigure figure) {
        return figure instanceof Connection ? ((Connection) figure).getPoints()
            .getBounds().getCopy()
            : figure.getBounds().getCopy();
d564 1
a564 1

d566 4
a569 2
     * Returns the closest intersection point from the line segment given that
     * will extend to hit the connection passed in.
d571 4
a574 6
     * @@param connection
     *            the connection
     * @@param lineSeg
     *            the line segment to extend to find intersections with the
     *            connection
     * @@return the closeest intersecting point or null if there are none
d576 15
a590 10
    private Point getIntersectionPoint(Connection connection, LineSeg lineSeg) {

        PointList intersections = lineSeg
            .getLineIntersectionsWithLineSegs(connection.getPoints());
        if (intersections.size() > 0) {
            return PointListUtilities.pickClosestPoint(intersections, lineSeg
                .getOrigin());
        }

        return null;
d592 37
a628 1
   
@


1.10
log
@[187341] gmf_head mmostafa 070516 Rectilinear router does not consider Border Items
@
text
@d528 6
@


1.10.2.1
log
@[198455] gmf_R2_0_maintenance aboyko 070815 [Layout] Connection between 2 intersecting shapes is often drawn within the intersection of the shapes
@
text
@a527 6
		
		if (checkShapesIntersect(conn, newLine)) {
			 checkEndSegments(conn, newLine);
			 resetEndPointsToEdge(conn, newLine);
			return;
		}
@


1.9
log
@[112996] gmf_R1_0_maintenance crevells 070126 Attaching a rectilinear routed line to a connection connects to space
@
text
@d65 1
d67 1
a67 1
		if (conn.getSourceAnchor().getOwner() == null)
d70 2
a71 5
		Rectangle startRect =
			new Rectangle(conn.getSourceAnchor().getOwner().getBounds());
		conn.getSourceAnchor().getOwner().translateToAbsolute(startRect);
		conn.translateToRelative(startRect);

d73 3
a75 3
			boolean in1 = startRect.contains(newPoints.getPoint(i));
			boolean in2 = startRect.contains(newPoints.getPoint(i + 1));
			if (in1 != in2) {
d96 2
a97 2

		if (conn.getTargetAnchor().getOwner() == null)
d100 1
a100 5
		Rectangle endRect =
			new Rectangle(conn.getTargetAnchor().getOwner().getBounds());
		conn.getTargetAnchor().getOwner().translateToAbsolute(endRect);
		conn.translateToRelative(endRect);

d102 2
a103 2
			boolean in1 = endRect.contains(newPoints.getPoint(i));
			boolean in2 = endRect.contains(newPoints.getPoint(i - 1));
d511 1
a511 1
        
d669 1
@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d16 1
d20 1
d163 1
a163 3
				bBoxF =
					new Rectangle(
						conn.getSourceAnchor().getOwner().getBounds());
d170 2
a171 4
			if (conn.getTargetAnchor().getOwner() != null) {
				bBoxT =
					new Rectangle(
						conn.getTargetAnchor().getOwner().getBounds());
d229 1
a229 1

d235 2
a236 2
	 */
	protected void resetEndPointsToEdge(Connection conn, PointList newLine) {
d238 6
a243 9
		// if we are reorienting, then just default to the super class implementation and
		// don't try to do rectilinear routing.
		if (isReorienting(conn)) {
			super.resetEndPointsToEdge(conn, newLine);
			return;
		}
 
		LineSeg edgeLine1 =
			OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, conn.getSourceAnchor(), newLine.getPoint(1));
d245 26
a270 2
		LineSeg edgeLine2 =
			OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, conn.getTargetAnchor(), newLine.getPoint(newLine.size() - 2));
d272 25
a296 25
		if (edgeLine1 != null && edgeLine2 != null) {
			newLine.setPoint(edgeLine1.getOrigin(), 0);
			if (newLine.size() > 2) {
				for (int i=0; i<2; i++) {
		            Point ptCurrent = newLine.getPoint(i);
		            Point ptNext = newLine.getPoint(i+1);
		            makeOrthogonal(ptCurrent, ptNext);
		            
		            newLine.setPoint(ptNext, i+1);
		        }
			}
			
			newLine.setPoint(edgeLine2.getOrigin(), newLine.size() - 1);
			if (newLine.size() > 2) {
				for (int i=newLine.size() - 1; i>=newLine.size() - 2; i--) {
		            Point ptCurrent = newLine.getPoint(i);
		            Point ptNext = newLine.getPoint(i-1);
		            makeOrthogonal(ptCurrent, ptNext);
		            
		            newLine.setPoint(ptNext, i-1);
		        }
			}
		} else
			super.resetEndPointsToEdge(conn, newLine);
	}
d328 5
d334 33
a366 42
		// If this thing isn't rectilinear, then first try to turn it into a
		// biterminal and if that doesn't work, then try to route it.
		if (!isRectilinear && !updateToBiTerminal(conn, newLine)) {
			// We've got a line that isn't rectilinear, so let's route
			// General rules based on number of segments starting with
			// if starting with two points (one segment) take shortest distance first.
			// if starting with three points (two segments) put longest segment
			//	as the middle segment
			OrthogonalRouterUtilities.resetEndPointsToCenter(conn, newLine);

			PointList oldPoints = PointListUtilities.copyPoints(newLine);

			PointList newPoints = new PointList();
			newPoints.addPoint(oldPoints.removePoint(0));
			while (oldPoints.size() > 0) {
				if (oldPoints.size() >= 2) {
					// This starts at point where last left off,
					// or the starting point if first time through.
					Point p0 = newPoints.getLastPoint();
					Point p1 = oldPoints.removePoint(0);
					Point p2 = oldPoints.removePoint(0);

					// make the shortest segment first.
					if (Math.abs(p2.y - p0.y) > Math.abs(p2.x - p0.x)) {
						// x has shortest segment
						newPoints.addPoint(new Point(p1.x, p0.y));
						newPoints.addPoint(new Point(p1.x, p2.y));
					} else // y has shortest segment first. 
						{
						newPoints.addPoint(new Point(p0.x, p1.y));
						newPoints.addPoint(new Point(p2.x, p1.y));
					}
					newPoints.addPoint(p2);
				} else if (oldPoints.size() == 1) {
					Point p0 = newPoints.getLastPoint();
					Point p1 = oldPoints.removePoint(0);
					if (Math.abs(p1.y - p0.y) > Math.abs(p1.x - p0.x)) {
						newPoints.addPoint(new Point(p1.x, p0.y));
					} else {
						newPoints.addPoint(new Point(p0.x, p1.y));
					}
					newPoints.addPoint(p1);
d368 6
a373 17

			}
			oldPoints.removeAllPoints();
			// Now make a pass through to collapse any redundent segments.
			oldPoints.addPoint(newPoints.removePoint(0));
			while (newPoints.size() >= 2) {
				Point p0 = oldPoints.getLastPoint();
				Point p1 = newPoints.getPoint(0);
				Point p2 = newPoints.getPoint(1);
				if (p0.x == p1.x && p0.x == p2.x) {
					// Have two vertical segments in a row
					// get rid of the point between
					newPoints.removePoint(0);
				} else if (p0.y == p1.y && p0.y == p2.y) {
					// Have two horizontal segments in a row
					// get rid of the point between
					newPoints.removePoint(0);
d375 1
a375 1
					oldPoints.addPoint(newPoints.removePoint(0));
d377 1
d379 18
a396 1
			while (newPoints.size() > 0) {
d399 4
d404 4
a407 5
			// set the newly routed line back into newLine
			newLine.removeAllPoints();
			for (int i = 0; i < oldPoints.size(); i++)
				newLine.addPoint(oldPoints.getPoint(i));
		}
d517 1
a517 1

d558 1
a558 1
                 
d560 1
a560 1
        
d577 1
a577 1
            Rectangle startRect = new Rectangle(conn.getSourceAnchor().getOwner().getBounds());
d585 2
a586 2
            
            Rectangle endRect = new Rectangle(conn.getTargetAnchor().getOwner().getBounds());
d610 65
@


1.7
log
@bugzilla 111075 gmf-head sshaw 060425 AvoidObstructions needs to be nested figure aware
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
@


1.7.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.7.2.2
log
@[112996] gmf_R1_0_maintenance crevells 070126 Attaching a rectilinear routed line to a connection connects to space
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2007 IBM Corporation and others.
a15 1
import org.eclipse.draw2d.IFigure;
a18 1
import org.eclipse.draw2d.geometry.PrecisionRectangle;
d161 3
a163 1
				bBoxF = getBounds(conn.getSourceAnchor().getOwner());
d170 4
a173 2
            if (conn.getTargetAnchor().getOwner() != null) {
                bBoxT = getBounds(conn.getTargetAnchor().getOwner());
d231 1
a231 1
    
d237 2
a238 2
     */   
    protected void resetEndPointsToEdge(Connection conn, PointList newLine) {
d240 9
a248 6
        // if we are reorienting, then just default to the super class implementation and
        // don't try to do rectilinear routing.
        if (isReorienting(conn)) {
            super.resetEndPointsToEdge(conn, newLine);
            return;
        }
d250 2
a251 12
        Point origin = null;
        if (conn.getSourceAnchor().getOwner() instanceof Connection) {
            origin = getIntersectionPoint((Connection) conn.getSourceAnchor()
                .getOwner(), new LineSeg(newLine.getPoint(1), newLine
                .getPoint(0)));
        }
        if (origin == null) {
            LineSeg edgeLine1 = OrthogonalRouterUtilities
                .getOrthogonalLineSegToAnchorLoc(conn, conn.getSourceAnchor(),
                    newLine.getPoint(1));
            origin = edgeLine1.getOrigin();
        }
d253 25
a277 39
        Point terminus = null;
        if (conn.getTargetAnchor().getOwner() instanceof Connection) {
            int numPoints = newLine.size();
            terminus = getIntersectionPoint((Connection) conn.getTargetAnchor()
                .getOwner(), new LineSeg(newLine.getPoint(numPoints - 2),
                newLine.getPoint(numPoints - 1)));
        }
        if (terminus == null) {
            LineSeg edgeLine2 = OrthogonalRouterUtilities
                .getOrthogonalLineSegToAnchorLoc(conn, conn.getTargetAnchor(),
                    newLine.getPoint(newLine.size() - 2));
            terminus = edgeLine2.getOrigin();
        }

        if (origin != null && terminus != null) {
            newLine.setPoint(origin, 0);
            if (newLine.size() > 2) {
                for (int i=0; i<2; i++) {
                    Point ptCurrent = newLine.getPoint(i);
                    Point ptNext = newLine.getPoint(i+1);
                    makeOrthogonal(ptCurrent, ptNext);
                    
                    newLine.setPoint(ptNext, i+1);
                }
            }
            
            newLine.setPoint(terminus, newLine.size() - 1);
            if (newLine.size() > 2) {
                for (int i=newLine.size() - 1; i>=newLine.size() - 2; i--) {
                    Point ptCurrent = newLine.getPoint(i);
                    Point ptNext = newLine.getPoint(i-1);
                    makeOrthogonal(ptCurrent, ptNext);
                    
                    newLine.setPoint(ptNext, i-1);
                }
            }
        } else
            super.resetEndPointsToEdge(conn, newLine);
    }
a308 5
        
        // first see if it is already rectilinear already
        if (isRectilinear && areEndsInBounds(conn, newLine)) {
            return;
        }
d310 43
a352 4
        // now try to turn it into a biterminal (i.e. one straight line)
        if (updateToBiTerminal(conn, newLine) && areEndsInBounds(conn, newLine)) {
            return;
        }
d354 16
a369 35
		// We've got a line that isn't rectilinear, so let's route
		// General rules based on number of segments starting with
		// if starting with two points (one segment) take shortest distance first.
		// if starting with three points (two segments) put longest segment
		//	as the middle segment
		OrthogonalRouterUtilities.resetEndPointsToCenter(conn, newLine);

		PointList oldPoints = PointListUtilities.copyPoints(newLine);

		PointList newPoints = new PointList();
		newPoints.addPoint(oldPoints.removePoint(0));
		while (oldPoints.size() > 0) {
			if (oldPoints.size() >= 2) {
				// This starts at point where last left off,
				// or the starting point if first time through.
				Point p0 = newPoints.getLastPoint();
				Point p1 = oldPoints.removePoint(0);
				Point p2 = oldPoints.removePoint(0);

				// make the shortest segment first.
				if (Math.abs(p2.y - p0.y) > Math.abs(p2.x - p0.x)) {
					// x has shortest segment
					newPoints.addPoint(new Point(p1.x, p0.y));
					newPoints.addPoint(new Point(p1.x, p2.y));
				} else // y has shortest segment first. 
					{
					newPoints.addPoint(new Point(p0.x, p1.y));
					newPoints.addPoint(new Point(p2.x, p1.y));
				}
				newPoints.addPoint(p2);
			} else if (oldPoints.size() == 1) {
				Point p0 = newPoints.getLastPoint();
				Point p1 = oldPoints.removePoint(0);
				if (Math.abs(p1.y - p0.y) > Math.abs(p1.x - p0.x)) {
					newPoints.addPoint(new Point(p1.x, p0.y));
d371 1
a371 1
					newPoints.addPoint(new Point(p0.x, p1.y));
a372 1
				newPoints.addPoint(p1);
d374 1
a374 18

		}
		oldPoints.removeAllPoints();
		// Now make a pass through to collapse any redundent segments.
		oldPoints.addPoint(newPoints.removePoint(0));
		while (newPoints.size() >= 2) {
			Point p0 = oldPoints.getLastPoint();
			Point p1 = newPoints.getPoint(0);
			Point p2 = newPoints.getPoint(1);
			if (p0.x == p1.x && p0.x == p2.x) {
				// Have two vertical segments in a row
				// get rid of the point between
				newPoints.removePoint(0);
			} else if (p0.y == p1.y && p0.y == p2.y) {
				// Have two horizontal segments in a row
				// get rid of the point between
				newPoints.removePoint(0);
			} else {
d377 5
a382 8
		while (newPoints.size() > 0) {
			oldPoints.addPoint(newPoints.removePoint(0));
		}

		// set the newly routed line back into newLine
		newLine.removeAllPoints();
		for (int i = 0; i < oldPoints.size(); i++)
			newLine.addPoint(oldPoints.getPoint(i));
d492 1
a492 1
        
d533 1
a533 1
          
d535 1
a535 1
                
d552 1
a552 1
            Rectangle startRect = getBounds(conn.getSourceAnchor().getOwner());
d560 2
a561 2
              
            Rectangle endRect = getBounds(conn.getTargetAnchor().getOwner());
a584 65
    
    /**
     * Returns true if the ends of the line passed in our within the bounds of
     * the connection's source and target ends.
     * 
     * @@param connection
     *            the connection whose source and target ends will be looked at
     * @@param line
     *            the line in question
     * @@return true if the two ends of the lines are within the bounds; false
     *         otherwise
     */
    private boolean areEndsInBounds(Connection connection, PointList line) {
        Rectangle startRect = new PrecisionRectangle(getBounds(connection
            .getSourceAnchor().getOwner()));
        connection.getSourceAnchor().getOwner().translateToAbsolute(startRect);
        connection.translateToRelative(startRect);

        Rectangle endRect = new PrecisionRectangle(getBounds(connection
            .getTargetAnchor().getOwner()));
        connection.getTargetAnchor().getOwner().translateToAbsolute(endRect);
        connection.translateToRelative(endRect);

        if (!startRect.contains(line.getPoint(0))
            || !endRect.contains(line.getPoint(line.size() - 1))) {
            return false;
        }
        return true;
    }

    /**
     * Returns a copy of the bounds of this figure or if the figure is a
     * <code>Connection</code> the bounds of the pointlist will be returned.
     * 
     * @@param figure
     * @@return a copy of the bounds
     */
    private Rectangle getBounds(IFigure figure) {
        return figure instanceof Connection ? ((Connection) figure).getPoints()
            .getBounds().getCopy()
            : figure.getBounds().getCopy();
    }

    /**
     * Returns the closest intersection point from the line segment given that
     * will extend to hit the connection passed in.
     * 
     * @@param connection
     *            the connection
     * @@param lineSeg
     *            the line segment to extend to find intersections with the
     *            connection
     * @@return the closeest intersecting point or null if there are none
     */
    private Point getIntersectionPoint(Connection connection, LineSeg lineSeg) {

        PointList intersections = lineSeg
            .getLineIntersectionsWithLineSegs(connection.getPoints());
        if (intersections.size() > 0) {
            return PointListUtilities.pickClosestPoint(intersections, lineSeg
                .getOrigin());
        }

        return null;
    }
@


1.6
log
@bugzilla 117592 gmf-head mmostafa 060207 Eroneous references to xtools in diagram plugins
@
text
@d525 1
a525 1
			if (!isFeedback(conn))
@


1.5
log
@Bugzilla#113157 gmf_head cmahoney 051104 Updating tutorial guides and some comments with name changes
@
text
@d232 1
a232 1
	/* 
d236 1
a236 2
     * 
	 * @@see com.ibm.xtools.draw2d.ObliqueRouter#resetEndPointsToEdge(org.eclipse.draw2d.Connection, org.eclipse.draw2d.geometry.PointList)
d481 1
a481 1
	/* 
d484 1
a484 2
     * 
	 * @@see com.ibm.xtools.draw2d.ObliqueRouter#routeLine(org.eclipse.draw2d.Connection, int, org.eclipse.draw2d.geometry.PointList)
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@d21 1
d31 1
a31 1
 * RectilinearRouter which routes the Connector so that the lines
@


1.3
log
@bugzilla 113003 gmf-head sshaw 051020 Cannot reorient rectilinear routed line that contains bendpoints...
@
text
@a20 1

d23 1
a23 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;
d527 1
a527 1
				tolerance = (Dimension)MapMode.translateToLP(tolerance);
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a500 1
			checkEndSegments(conn, newLine);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2003.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

