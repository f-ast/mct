head	1.8;
access;
symbols
	v20081023-2107:1.8
	v20081022-1925:1.8
	v20081021-1810:1.8
	v20081020-0700:1.8
	v20080911-1728:1.8
	v20080911-1506:1.8
	v20080910-1520:1.8
	v20080910-1510:1.8
	v20080903-1520:1.8
	v20080903-1510:1.8
	v20080722-1827:1.8
	R2_1_maintenance:1.8.0.2
	Root_R2_1_maintenance:1.8
	R2_1_0:1.8
	v20080610-1132:1.8
	v20080603-1553:1.8
	v20080512-1200:1.8
	v20080503-1740:1.7
	v20080501-1739:1.7
	v20080425-1959:1.7
	v20080417-1610:1.7
	v20080407-2250:1.7
	v20080407-0930:1.7
	v20080404-1111:1.7
	v20080222-1200:1.7
	v20080215-1500:1.7
	v20080215-1200:1.3
	v20080201-2010:1.7
	v20080114-1111:1.7
	v20071108-0000:1.4
	v20071003-0000:1.4
	v20070928-0000:1.3
	v20070915-0000:1.3
	v20070903-0000:1.3
	v20070830-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	v20070621-0000:1.3
	RC3_20:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070518-1300:1.3
	v20070330-1300:1.1
	v20070221-1500:1.1
	v20070208-1800:1.1
	v20070202-0200:1.1
	M4_20:1.1
	v20061218-1200:1.1
	v20061214-0000:1.1
	M3_20:1.1
	v20061013-1330:1.1
	v20060925-1700:1.1
	v20060919-0800:1.1
	M1_20:1.1
	v20060824-1600:1.1
	v20060817-1500:1.1
	v20060810-1700:1.1
	v20060803-1200:1.1
	v20060728-0500:1.1
	v20060721-1130:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060616-1200:1.1
	v20060609-1400:1.1
	v20060531-1730:1.1
	v20060519-0800:1.1
	RC2_10:1.1
	I20060505-1400:1.1
	I20060428-1300:1.1;
locks; strict;
comment	@# @;


1.8
date	2008.05.09.20.27.23;	author aboyko;	state Exp;
branches;
next	1.7;
commitid	67614824b3aa4567;

1.7
date	2008.01.10.23.02.30;	author aboyko;	state Exp;
branches;
next	1.6;
commitid	6a814786a4064567;

1.6
date	2008.01.03.17.42.57;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	3284477d1ea04567;

1.5
date	2008.01.02.20.06.57;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	5a64477beede4567;

1.4
date	2007.09.26.18.44.05;	author aboyko;	state Exp;
branches;
next	1.3;
commitid	d9846faa8754567;

1.3
date	2007.05.17.19.46.47;	author crevells;	state Exp;
branches;
next	1.2;
commitid	45e3464cb1274567;

1.2
date	2007.05.16.17.10.04;	author ahunter;	state Exp;
branches;
next	1.1;
commitid	4eaf464b3aeb4567;

1.1
date	2006.04.26.21.40.36;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.8
log
@[[231365] gmf_head aboyko 080509 [Layout] Support routing of invalid connections
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

import org.eclipse.draw2d.Bendpoint;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.FigureUtilities;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.ShortestPathConnectionRouter;
import org.eclipse.draw2d.XYLayout;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.Ray;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

/**
 * Manager class which determines which shortest path connection router to use
 * for a given <code>Connection</code>.
 * 
 * @@author sshaw
 * 
 */
class RouterHelper {

    static private RouterHelper sprm = new RouterHelper(false);

    /**
     * @@return the <code>RouterHelper</code> singleton instance
     */
    static public RouterHelper getInstance() {
        return sprm;
    }
    
    private Map routers = new WeakHashMap();

    private Map lastUsedRouter = new WeakHashMap();

    private boolean useGEFRouter = false;

    private RouterHelper(boolean useGEFRouter) {
        super();
        this.useGEFRouter = useGEFRouter;
    }

    /**
     * @@param conn
     * @@param constraint
     */
    public void setConstraint(Connection conn, Object constraint) {
        if (useGEFRouter) {
            ShortestPathConnectionRouter spcr = getRouter(conn);
            if (spcr != null)
                spcr.setConstraint(conn, constraint);
        }
    }

    /**
     * @@param conn
     */
    public void remove(Connection conn) {
        if (useGEFRouter) {
            ShortestPathConnectionRouter spcr = getRouter(conn);
            if (spcr != null)
                spcr.remove(conn);
        }
    }

    /**
     * @@param conn
     */
    public void invalidate(Connection conn) {
        if (useGEFRouter) {
            ShortestPathConnectionRouter spcr = getRouter(getSourceContainer(conn));
            if (spcr != null)
                spcr.invalidate(conn);
        }
    }
    
    /**
     * @@param conn the <code>Connection</code> that is to be check if it is a feedback
     * connection or not.
     * @@return <code>true</code> is it is a feedback connection, <code>false</code> otherwise.
     */
    public boolean isFeedback(Connection conn) {
        Dimension dim = new Dimension(100, 100);
        Dimension dimCheck = dim.getCopy();
        conn.translateToRelative(dimCheck);
        return dim.equals(dimCheck);
    }
    
    /**
     * @@param conn the <code>Connection</code> that is to be routed.
     * @@return the <code>PointList</code> that is the list of points that are
     * a direct mapping of the constraint points.
     */
    public PointList routeFromConstraint(Connection conn) {
        List bendpoints = (List)conn.getConnectionRouter().getConstraint(conn);
        if (bendpoints == null)
            bendpoints = Collections.EMPTY_LIST;
        
        PointList points = new PointList(bendpoints.size());

        for (int i = 0; i < bendpoints.size(); i++) {
            Bendpoint bp = (Bendpoint) bendpoints.get(i);
            points.addPoint(bp.getLocation());
        }

        if (bendpoints.size() == 0) {
            Point r1 = conn.getSourceAnchor().getReferencePoint().getCopy();
            conn.translateToRelative(r1);
            points.addPoint(r1);
            
            Point r2 = conn.getTargetAnchor().getReferencePoint().getCopy();
            conn.translateToRelative(r2);
            points.addPoint(r2);
        }
        
        return points;
    }

    /**
     * @@param conn the <code>Connection</code> that is to be routed.
     * @@return the <code>PointList</code> that is the list of points that represent
     * the closest distance possible to route the line.
     */
    public PointList routeClosestDistance(Connection conn) {
        PointList newLine = routeFromConstraint(conn);
        
        Point ptOrig = new Point(newLine.getFirstPoint());
        Point ptTerm = new Point(newLine.getLastPoint());

        newLine.removeAllPoints();
        newLine.addPoint(ptOrig);
        newLine.addPoint(ptTerm);
        
        return newLine;
    }
    
    /**
     * @@param conn the <code>Connection</code> that is to be routed.
     * @@return the <code>PointList</code> that is the list of points that are
     * avoiding all the possible obstructions in the container for the connection.
     */
    public PointList routeAroundObstructions(Connection conn) {
        PointList newLine = null;
        
        if (useGEFRouter) {
            newLine = new PointList();
            
            ShortestPathConnectionRouter spcr = RouterHelper.getInstance().getRouter(conn);
            if (spcr == null)
                newLine = routeFromConstraint(conn);
            else {
                spcr.route(conn);
                newLine.removeAllPoints();
                newLine.addAll(conn.getPoints());
            }
        } else {
        newLine = routeClosestDistance(conn);
        
        Point infimumPoint = PointListUtilities.getPointsInfimum(newLine);
        Point supremumPoint = PointListUtilities.getPointsSupremum(newLine);

        Ray diameter = new Ray(infimumPoint, supremumPoint);
        Rectangle rPoly = new Rectangle(infimumPoint.x, infimumPoint.y,
            diameter.x, diameter.y);

        List collectObstructs = new LinkedList();

        IFigure parent = getRouterContainerFigure(conn);     

        // don't bother routing if there is no attachments
        if (parent == null)
            return routeFromConstraint(conn);

        // set the end points back to the reference points - this will avoid
        // errors, where
        // an edge point is erroneously aligned with a specific edge, even
        // though the avoid
        // obstructions would suggest attachment to another edge is more
        // appropriate
        Point ptRef = conn.getSourceAnchor().getReferencePoint();
        conn.translateToRelative(ptRef);
        newLine.setPoint(ptRef, 0);
        ptRef = conn.getTargetAnchor().getReferencePoint();
        conn.translateToRelative(ptRef);
        newLine.setPoint(ptRef, newLine.size() - 1);

        // TBD - optimize this
        // increase connect view rect by width or height of diagram
        // to maximize views included in the obstruction calculation
        // without including all views in the diagram
        Rectangle rBoundingRect = new Rectangle(parent.getBounds());
        parent.translateToAbsolute(rBoundingRect);
        conn.translateToRelative(rBoundingRect);

        if (rPoly.width > rPoly.height) {
            rPoly.y = rBoundingRect.y;
            rPoly.setSize(rPoly.width, rBoundingRect.height);
        } else {
            rPoly.x = rBoundingRect.x;
            rPoly.setSize(rBoundingRect.width, rPoly.height);
        }
        
        collectObstructions(conn, rPoly, collectObstructs);

        // parse through obstruction collect and combine rectangle that
        // intersect with each other
        if (collectObstructs.size() > 0) {
            Dimension buffer = new Dimension(ROUTER_OBSTRUCTION_BUFFER + 1,
                0);
            if (!isFeedback(conn))
                buffer = (Dimension) MapModeUtil.getMapMode(conn).DPtoLP(
                    buffer);
            final int inflate = buffer.width;

            List collapsedRects = collapseRects(collectObstructs, inflate);
            collectObstructs.clear();

            // Loop through the collapsedRects list until there are no more
            // intersections
            boolean bRouted = true;
            while (bRouted && !collapsedRects.isEmpty()) {
                ListIterator listIter = collapsedRects.listIterator();
                bRouted = false;

                while (listIter.hasNext()) {
                    Rectangle rObstruct = (Rectangle) listIter.next();
                    PointList routedPoly = PointListUtilities
                        .routeAroundRect(newLine, rObstruct, 0, false,
                            inflate);

                    if (routedPoly != null) {
                        bRouted = true;
                        newLine.removeAllPoints();
                        newLine.addAll(routedPoly);
                    } else
                        collectObstructs.add(rObstruct);
                }

                List tempList = collapsedRects;
                collapsedRects = collectObstructs;
                tempList.clear();
                collectObstructs = tempList;

                if (bRouted && !collapsedRects.isEmpty())
                    resetEndPointsToEdge(conn, newLine);
            }
        }
        }
        
        return newLine;
        }
    
    /**
     * Finds all the children shapes of the parent figure passed in that are in
     * the way of the connection. This method will dig into children of
     * container shapes if one of the connection ends is also in that container.
     * 
     * @@param connection
     *            the connection being routed
     * @@param connectionRect
     *            the rectangle representing the connection bounds that is used
     *            to determine if a shape intersects with the connection
     * @@param obstructionsToReturn
     *            the list of figures that the connection should be routed
     *            around
     */
    protected void collectObstructions(Connection connection,
            Rectangle connectionRect, List obstructionsToReturn) {

        Set containerFiguresToSearch = new HashSet();
        Set figuresToExclude = new HashSet();

        IFigure figure = connection.getSourceAnchor().getOwner();
        figuresToExclude.add(figure);
        figure = figure.getParent();
        while (figure != null) {
            if (figure.getLayoutManager() instanceof XYLayout) {
                containerFiguresToSearch.add(figure);
            }
            figuresToExclude.add(figure);
            figure = figure.getParent();
        }

        figure = connection.getTargetAnchor().getOwner();
        figuresToExclude.add(figure);
        figure = figure.getParent();
        while (figure != null) {
            if (figure.getLayoutManager() instanceof XYLayout) {
                containerFiguresToSearch.add(figure);
            }
            figuresToExclude.add(figure);
            figure = figure.getParent();
        }

        for (Iterator iter = containerFiguresToSearch.iterator(); iter
            .hasNext();) {
            IFigure containerFigure = (IFigure) iter.next();

            for (Iterator iterator = containerFigure.getChildren().iterator(); iterator
                .hasNext();) {
                IFigure childFigure = (IFigure) iterator.next();

                if (!figuresToExclude.contains(childFigure)) {

                    Rectangle rObstruct = new Rectangle(childFigure.getBounds());
                    childFigure.translateToAbsolute(rObstruct);
                    connection.translateToRelative(rObstruct);

                    // inflate slightly
                    rObstruct.expand(1, 1);

                    if (connectionRect.intersects(rObstruct)) {
                        obstructionsToReturn.add(rObstruct);
                    }
                }
            }
        }
    }
    
    /**
     * @@param conn
     *            the <code>Connection</code> that is to have used to
     *            determine the end points for reseting the <code>newLine</code>
     *            parameter.
     * @@param newLine
     *            the <code>PointList</code> to reset the end points of to be
     *            on the edge of the connection source and target nodes.
     */
    public void resetEndPointsToEdge(Connection conn, PointList newLine) {
    	if (newLine.size() < 2) {
    		/*
			 * Connection must have at least 2 points in the list: the source
			 * and target anchor points. Otherwise it's invalid connection.
			 * Invalid connection case: add a dumb point at the start of the
			 * list and at the end of the list. The first and the last point in
			 * the list are replaced by the new source and target anchor points
			 * in this method
			 */
    		newLine.addPoint(0, 0);
    		newLine.insertPoint(new Point(), 0);
    	}
    	
        PrecisionPoint sourceAnchorPoint, targetAnchorPoint;
        if (newLine.size() > 2) {
        	/*
        	 * First bend point is the outside reference point for the source anchor.
        	 * Last bend point is the outside reference point for the target anchor.
        	 */
	        PrecisionPoint sourceReference = new PrecisionPoint(newLine.getPoint(1));
	        PrecisionPoint targetReference = new PrecisionPoint(newLine.getPoint(newLine.size() - 2));
	        conn.translateToAbsolute(sourceReference);
	        conn.translateToAbsolute(targetReference);
	        sourceAnchorPoint = getAnchorLocation(conn.getSourceAnchor(), sourceReference);
	        targetAnchorPoint = getAnchorLocation(conn.getTargetAnchor(), targetReference);
        } else {
        	/*
        	 * We need to take target anchor reference point as an outside reference point
        	 * for the source anchor location. The outside reference point for the target
        	 * anchor would the source anchor location. 
        	 */
        	PrecisionPoint sourceReference = getAnchorReference(conn.getTargetAnchor());
	        sourceAnchorPoint = getAnchorLocation(conn.getSourceAnchor(), sourceReference);
	        targetAnchorPoint = getAnchorLocation(conn.getTargetAnchor(), sourceAnchorPoint);
        }
        
        
        conn.translateToRelative(sourceAnchorPoint);
        conn.translateToRelative(targetAnchorPoint);
        
        newLine.setPoint(new Point(Math.round(sourceAnchorPoint.preciseX), Math.round(sourceAnchorPoint.preciseY)), 0);
        newLine.setPoint(new Point(Math.round(targetAnchorPoint.preciseX), Math.round(targetAnchorPoint.preciseY)), newLine.size() - 1);
    }

    private final static int ROUTER_OBSTRUCTION_BUFFER = 12;

    /**
     * This method will collapse all the rectangles together that intersect in
     * the given List. It utilizes a recursive implementation.
     */
    private List collapseRects(List collectRect, int inflate) {
        if (collectRect.size() == 0)
            return new LinkedList();

        Rectangle rCompare = new Rectangle((Rectangle) collectRect.remove(0));
        List collapsedRects = collapseRects(rCompare, collectRect, inflate);
        collapsedRects.add(rCompare);

        return collapsedRects;
    }

    /**
     * Recursively called method called by collapseRects(List collectRect).
     */
    private List collapseRects(Rectangle rCompare, List collectRect, int inflate) {
        List newCollect = new LinkedList();
        Rectangle rCompare1 = new Rectangle(rCompare);

        // compare rectangle with each rectangle in the rest of the list
        boolean intersectionOccurred = false;
        ListIterator listIter = collectRect.listIterator();
        while (listIter.hasNext()) {
            Rectangle rCompare2 = new Rectangle((Rectangle) listIter.next());

            Rectangle rExpandRect1 = new Rectangle(rCompare1);
            Rectangle rExpandRect2 = new Rectangle(rCompare2);

            // inflate the rect by the obstruction buffer for the intersection
            // calculation so that we won't try to route through a space smaller
            // then necessary
            rExpandRect1.expand(inflate, inflate);
            rExpandRect2.expand(inflate, inflate);

            if (rExpandRect1.intersects(rExpandRect2)) {
                rCompare1.union(rCompare2);
                intersectionOccurred = true;
            } else {
                newCollect.add(rCompare2);
            }
        }

        rCompare.setBounds(rCompare1);

        if (newCollect.size() > 0) {
            if (intersectionOccurred) {
                return collapseRects(rCompare, newCollect, inflate);
            } else {
                Rectangle rFirst = new Rectangle((Rectangle) newCollect
                    .remove(0));
                List finalCollapse = collapseRects(rFirst, newCollect, inflate);
                finalCollapse.add(rFirst);

                return finalCollapse;
            }
        } else {
            return newCollect;
        }
    }

    /**
     * @@param conn
     * @@return
     */
    private IFigure getRouterContainerFigure(Connection conn) {
        IFigure sourcefigContainer = getSourceContainer(conn);
        IFigure targetfigContainer = getTargetContainer(conn);
        IFigure commonFig = FigureUtilities.findCommonAncestor(
            sourcefigContainer, targetfigContainer);

        IFigure routerContainer = null;

        if (sourcefigContainer == null || targetfigContainer == null)
            return null;

        if (sourcefigContainer == targetfigContainer) {
            routerContainer = sourcefigContainer;
        } else if (commonFig != sourcefigContainer
            && commonFig != targetfigContainer) {
            routerContainer = commonFig;
        } else {
            // find the end that isn't the common ancestor and use it's bounds
            // to find
            // the optimal end for the avoid obstructions algorithm
            IFigure checkFig = sourcefigContainer;
            if (commonFig == sourcefigContainer)
                checkFig = targetfigContainer;

            // decide which end of the connection exists more in it's container
            // relative
            // to the other end, and use that container to determine which
            // router to
            // return.
            Rectangle checkRect = checkFig.getBounds().getCopy();
            checkFig.translateToAbsolute(checkRect);
            conn.translateToRelative(checkRect);
            int sourceDistance = findDistanceToEndRect(conn.getPoints(),
                checkRect);
            int targetDistance = (int) PointListUtilities.getPointsLength(conn
                .getPoints())
                - sourceDistance;

            if (sourceDistance > targetDistance)
                routerContainer = sourcefigContainer;
            else
                routerContainer = targetfigContainer;
        }

        return routerContainer;
    }

    /**
     * @@param conn
     * @@return
     */
    private ShortestPathConnectionRouter getRouter(Connection conn) {
        IFigure container = getRouterContainerFigure(conn);
        if (container == null)
            return null;

        ShortestPathConnectionRouter spcr = getRouter(container);
        ShortestPathConnectionRouter lur = (ShortestPathConnectionRouter) lastUsedRouter
            .get(conn);
        if (lur != spcr) {
            if (lur != null)
                lur.remove(conn);
            spcr.setConstraint(conn, conn.getRoutingConstraint());
        }
        lastUsedRouter.put(conn, spcr);

        return spcr;
    }

    private IFigure getSourceContainer(Connection conn) {
        if (conn.getSourceAnchor() != null)
            return findContainerFigure(conn.getSourceAnchor().getOwner());
        
        return null;
    }

    private IFigure getTargetContainer(Connection conn) {
        if (conn.getTargetAnchor() != null)
            return findContainerFigure(conn.getTargetAnchor().getOwner());
        
        return null;
    }

    /**
     * findContainerFigure Recursive method to find the figure that owns the
     * children the connection is connecting to.
     * 
     * @@param fig
     *            IFigure to find the shape container figure parent of.
     * @@return Container figure
     */
    private IFigure findContainerFigure(IFigure fig) {
        if (fig == null)
            return null;

        if (fig.getLayoutManager() instanceof XYLayout)
            return fig;

        return findContainerFigure(fig.getParent());
    }

    private int findDistanceToEndRect(PointList points, Rectangle endRect) {
        PointList intersections = new PointList();
        PointList distances = new PointList();
        boolean foundSourceDistance = PointListUtilities.findIntersections(
            points, PointListUtilities.createPointsFromRect(endRect),
            intersections, distances);

        int sourceDistance = foundSourceDistance ? distances.getFirstPoint().x
            : 0;
        return sourceDistance;
}
    private ShortestPathConnectionRouter getRouter(IFigure figContainer) {
        ShortestPathConnectionRouter shortestPathRouter = (ShortestPathConnectionRouter) routers
            .get(figContainer);
        if (shortestPathRouter == null) {
            shortestPathRouter = new ShortestPathConnectionRouter(figContainer);
            shortestPathRouter.setSpacing(MapModeUtil.getMapMode(figContainer)
                .DPtoLP(10));
            routers.put(figContainer, shortestPathRouter);
        }

        return shortestPathRouter;
    }
    
    /**
     * Returns anchor location as <code>PrecisionPoint</code>
     * 
     * @@param anchor connection anchor object
     * @@param reference outside reference point
     * @@return <code>PrecisionPoint</code> for anchor location
     */
    private PrecisionPoint getAnchorLocation(ConnectionAnchor anchor, Point reference) {
    	return new PrecisionPoint(anchor.getLocation(reference));
    }
    
    /**
     * Returns anchor reference point as <code>PrecisionPoint</code>
     * 
     * @@param anchor connection anchor object
     * @@return <code>PrecisionPoint</code> for anchor reference
     */
    private PrecisionPoint getAnchorReference(ConnectionAnchor anchor) {
   		return new PrecisionPoint(anchor.getReferencePoint());
    }
}
@


1.7
log
@Commit back [194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
d356 13
a368 3
        if (newLine.size() < 2)
            return;
        
@


1.6
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d26 1
d124 1
a124 1

d136 1
a136 1

d356 1
a356 1
        if (newLine.size() <= 1)
d358 22
a379 27

        PrecisionPoint ptS2 = new PrecisionPoint(newLine.getPoint(1));
        PrecisionPoint ptAbsS2 = new PrecisionPoint(ptS2);
        conn.translateToAbsolute(ptAbsS2);
        if (newLine.size() == 2)
            ptAbsS2 = new PrecisionPoint(conn.getTargetAnchor().getReferencePoint());
        PrecisionPoint ptAbsS1 = new PrecisionPoint(conn.getSourceAnchor().getLocation(ptAbsS2));
        PrecisionPoint ptS1 = new PrecisionPoint(ptAbsS1);
        conn.translateToRelative(ptS1);
        PrecisionPoint ptE2 = new PrecisionPoint(newLine.getPoint(newLine.size() - 2));
        PrecisionPoint ptAbsE2 = new PrecisionPoint(ptE2);
        conn.translateToAbsolute(ptAbsE2);
        if (newLine.size() == 2)
            ptAbsE2 = ptAbsS1;
        PrecisionPoint ptE1 = new PrecisionPoint(conn.getTargetAnchor().getLocation(ptAbsE2));
        conn.translateToRelative(ptE1);
        newLine.setPoint(new PrecisionPoint(Math.round(ptS1.preciseX), Math.round(ptS1.preciseY)), 0);
        
        // convert reference points back to relative to avoid rounding issues.
        newLine.setPoint(new PrecisionPoint(Math.round(ptE1.preciseX), Math.round(ptE1.preciseY)), newLine.size() - 1);
        if (newLine.size() != 2) {
            ptS2 = ptAbsS2;
            conn.translateToRelative(ptS2);
            newLine.setPoint(new PrecisionPoint(Math.round(ptS2.preciseX), Math.round(ptS2.preciseY)), 1);
            ptE2 = ptAbsE2;
            conn.translateToRelative(ptE2);
            newLine.setPoint(new PrecisionPoint(Math.round(ptE2.preciseX), Math.round(ptE2.preciseY)), newLine.size() - 2);
d381 7
d583 21
@


1.5
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@a25 1
import org.eclipse.draw2d.ConnectionAnchor;
d123 1
a123 1
        
d135 1
a135 1
            
d355 1
a355 1
        if (newLine.size() < 2)
d357 27
a383 22
        
        PrecisionPoint sourceAnchorPoint, targetAnchorPoint;
        if (newLine.size() > 2) {
        	/*
        	 * First bend point is the outside reference point for the source anchor.
        	 * Last bend point is the outside reference point for the target anchor.
        	 */
	        PrecisionPoint sourceReference = new PrecisionPoint(newLine.getPoint(1));
	        PrecisionPoint targetReference = new PrecisionPoint(newLine.getPoint(newLine.size() - 2));
	        conn.translateToAbsolute(sourceReference);
	        conn.translateToAbsolute(targetReference);
	        sourceAnchorPoint = getAnchorLocation(conn.getSourceAnchor(), sourceReference);
	        targetAnchorPoint = getAnchorLocation(conn.getTargetAnchor(), targetReference);
        } else {
        	/*
        	 * We need to take target anchor reference point as an outside reference point
        	 * for the source anchor location. The outside reference point for the target
        	 * anchor would the source anchor location. 
        	 */
        	PrecisionPoint sourceReference = getAnchorReference(conn.getTargetAnchor());
	        sourceAnchorPoint = getAnchorLocation(conn.getSourceAnchor(), sourceReference);
	        targetAnchorPoint = getAnchorLocation(conn.getTargetAnchor(), sourceAnchorPoint);
a384 7
        
        
        conn.translateToRelative(sourceAnchorPoint);
        conn.translateToRelative(targetAnchorPoint);
        
        newLine.setPoint(new Point(Math.round(sourceAnchorPoint.preciseX), Math.round(sourceAnchorPoint.preciseY)), 0);
        newLine.setPoint(new Point(Math.round(targetAnchorPoint.preciseX), Math.round(targetAnchorPoint.preciseY)), newLine.size() - 1);
a579 21
    
    /**
     * Returns anchor location as <code>PrecisionPoint</code>
     * 
     * @@param anchor connection anchor object
     * @@param reference outside reference point
     * @@return <code>PrecisionPoint</code> for anchor location
     */
    private PrecisionPoint getAnchorLocation(ConnectionAnchor anchor, Point reference) {
    	return new PrecisionPoint(anchor.getLocation(reference));
    }
    
    /**
     * Returns anchor reference point as <code>PrecisionPoint</code>
     * 
     * @@param anchor connection anchor object
     * @@return <code>PrecisionPoint</code> for anchor reference
     */
    private PrecisionPoint getAnchorReference(ConnectionAnchor anchor) {
   		return new PrecisionPoint(anchor.getReferencePoint());
    }
@


1.4
log
@[110863] gmf_HEAD jbruck 070926 [Connections] Lines are not correctly meeting the shape border
@
text
@d26 1
d124 1
a124 1

d136 1
a136 1

d356 1
a356 1
        if (newLine.size() <= 1)
d358 22
a379 27

        PrecisionPoint ptS2 = new PrecisionPoint(newLine.getPoint(1));
        PrecisionPoint ptAbsS2 = new PrecisionPoint(ptS2);
        conn.translateToAbsolute(ptAbsS2);
        if (newLine.size() == 2)
            ptAbsS2 = new PrecisionPoint(conn.getTargetAnchor().getReferencePoint());
        PrecisionPoint ptAbsS1 = new PrecisionPoint(conn.getSourceAnchor().getLocation(ptAbsS2));
        PrecisionPoint ptS1 = new PrecisionPoint(ptAbsS1);
        conn.translateToRelative(ptS1);
        PrecisionPoint ptE2 = new PrecisionPoint(newLine.getPoint(newLine.size() - 2));
        PrecisionPoint ptAbsE2 = new PrecisionPoint(ptE2);
        conn.translateToAbsolute(ptAbsE2);
        if (newLine.size() == 2)
            ptAbsE2 = ptAbsS1;
        PrecisionPoint ptE1 = new PrecisionPoint(conn.getTargetAnchor().getLocation(ptAbsE2));
        conn.translateToRelative(ptE1);
        newLine.setPoint(new PrecisionPoint(Math.round(ptS1.preciseX), Math.round(ptS1.preciseY)), 0);
        
        // convert reference points back to relative to avoid rounding issues.
        newLine.setPoint(new PrecisionPoint(Math.round(ptE1.preciseX), Math.round(ptE1.preciseY)), newLine.size() - 1);
        if (newLine.size() != 2) {
            ptS2 = ptAbsS2;
            conn.translateToRelative(ptS2);
            newLine.setPoint(new PrecisionPoint(Math.round(ptS2.preciseX), Math.round(ptS2.preciseY)), 1);
            ptE2 = ptAbsE2;
            conn.translateToRelative(ptE2);
            newLine.setPoint(new PrecisionPoint(Math.round(ptE2.preciseX), Math.round(ptE2.preciseY)), newLine.size() - 2);
d381 7
d583 21
@


1.3
log
@[187623] gmf_head crevells 070517 Avoid Obstructions doesn't always work in container figures
@
text
@d33 1
d358 2
a359 2
        Point ptS2 = newLine.getPoint(1);
        Point ptAbsS2 = new Point(ptS2);
d362 3
a364 3
            ptAbsS2 = conn.getTargetAnchor().getReferencePoint();
        Point ptAbsS1 = conn.getSourceAnchor().getLocation(ptAbsS2);
        Point ptS1 = new Point(ptAbsS1);
d366 2
a367 3

        Point ptE2 = newLine.getPoint(newLine.size() - 2);
        Point ptAbsE2 = new Point(ptE2);
d371 1
a371 1
        Point ptE1 = new Point(conn.getTargetAnchor().getLocation(ptAbsE2));
d373 2
a374 2

        newLine.setPoint(ptS1, 0);
d376 1
a376 1
        newLine.setPoint(ptE1, newLine.size() - 1);
d380 1
a380 1
            newLine.setPoint(ptS2, 1);
d383 1
a383 1
            newLine.setPoint(ptE2, newLine.size() - 2);
@


1.2
log
@gmf-head ahunter 070516 Add missing Copyright
@
text
@d15 2
d21 1
d55 1
a55 1

d181 126
a306 4
            newLine = routeClosestDistance(conn);
            
            Point infimumPoint = PointListUtilities.getPointsInfimum(newLine);
            Point supremumPoint = PointListUtilities.getPointsSupremum(newLine);
d308 6
a313 39
            Ray diameter = new Ray(infimumPoint, supremumPoint);
            Rectangle rPoly = new Rectangle(infimumPoint.x, infimumPoint.y,
                diameter.x, diameter.y);

            List collectObstructs = new LinkedList();

            IFigure parent = getRouterContainerFigure(conn);

            // don't bother routing if there is no attachments
            if (parent == null)
                return routeFromConstraint(conn);

            // set the end points back to the reference points - this will avoid
            // errors, where
            // an edge point is erroneously aligned with a specific edge, even
            // though the avoid
            // obstructions would suggest attachment to another edge is more
            // appropriate
            Point ptRef = conn.getSourceAnchor().getReferencePoint();
            conn.translateToRelative(ptRef);
            newLine.setPoint(ptRef, 0);
            ptRef = conn.getTargetAnchor().getReferencePoint();
            conn.translateToRelative(ptRef);
            newLine.setPoint(ptRef, newLine.size() - 1);

            // TBD - optimize this
            // increase connect view rect by width or height of diagram
            // to maximize views included in the obstruction calculation
            // without including all views in the diagram
            Rectangle rBoundingRect = new Rectangle(parent.getBounds());
            parent.translateToAbsolute(rBoundingRect);
            conn.translateToRelative(rBoundingRect);

            if (rPoly.width > rPoly.height) {
                rPoly.y = rBoundingRect.y;
                rPoly.setSize(rPoly.width, rBoundingRect.height);
            } else {
                rPoly.x = rBoundingRect.x;
                rPoly.setSize(rBoundingRect.width, rPoly.height);
d315 11
d327 5
a331 11
            List children = parent.getChildren();
            for (int i = 0; i < children.size(); i++) {
                IFigure child = (IFigure) children.get(i);

                if (child != conn.getSourceAnchor().getOwner() 
                    && child != conn.getTargetAnchor().getOwner() 
                    && !FigureUtilities.isAncestor(child, conn.getSourceAnchor().getOwner())
                    && !FigureUtilities.isAncestor(child, conn.getTargetAnchor().getOwner())) {
                    Rectangle rObstruct = new Rectangle(child.getBounds());
                    child.translateToAbsolute(rObstruct);
                    conn.translateToRelative(rObstruct);
d336 2
a337 38
                    if (rPoly.intersects(rObstruct)) {
                        collectObstructs.add(rObstruct);
                    }
                }
            }

            // parse through obstruction collect and combine rectangle that
            // intersect with each other
            if (collectObstructs.size() > 0) {
                Dimension buffer = new Dimension(ROUTER_OBSTRUCTION_BUFFER + 1,
                    0);
                if (!isFeedback(conn))
                    buffer = (Dimension) MapModeUtil.getMapMode(conn).DPtoLP(
                        buffer);
                final int inflate = buffer.width;

                List collapsedRects = collapseRects(collectObstructs, inflate);
                collectObstructs.clear();

                // Loop through the collapsedRects list until there are no more
                // intersections
                boolean bRouted = true;
                while (bRouted && !collapsedRects.isEmpty()) {
                    ListIterator listIter = collapsedRects.listIterator();
                    bRouted = false;

                    while (listIter.hasNext()) {
                        Rectangle rObstruct = (Rectangle) listIter.next();
                        PointList routedPoly = PointListUtilities
                            .routeAroundRect(newLine, rObstruct, 0, false,
                                inflate);

                        if (routedPoly != null) {
                            bRouted = true;
                            newLine.removeAllPoints();
                            newLine.addAll(routedPoly);
                        } else
                            collectObstructs.add(rObstruct);
a338 8

                    List tempList = collapsedRects;
                    collapsedRects = collectObstructs;
                    tempList.clear();
                    collectObstructs = tempList;

                    if (bRouted && !collapsedRects.isEmpty())
                        resetEndPointsToEdge(conn, newLine);
a341 2
        
        return newLine;
d343 1
a343 1

d345 7
a351 4
     * @@param conn the <code>Connection</code> that is to have used to determine the end
     * points for reseting the <code>newLine</code> parameter.
     * @@param newLine the <code>PointList</code> to reset the end points of to be on the
     * edge of the connection source and target nodes.
d567 1
a567 2
    }

@


1.1
log
@bugzilla 111075 gmf-head sshaw 060425 AvoidObstructions needs to be nested figure aware
@
text
@d1 11
@

