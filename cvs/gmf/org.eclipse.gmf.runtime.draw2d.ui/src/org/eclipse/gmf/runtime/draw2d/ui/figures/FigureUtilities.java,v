head	1.7;
access;
symbols
	v20081023-2107:1.7
	v20081022-1925:1.7
	v20081021-1810:1.7
	v20081020-0700:1.7
	v20080911-1728:1.7
	v20080911-1506:1.7
	v20080910-1520:1.7
	v20080910-1510:1.7
	v20080903-1520:1.7
	v20080903-1510:1.7
	v20080722-1827:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080610-1132:1.7
	v20080603-1553:1.7
	v20080512-1200:1.7
	v20080503-1740:1.7
	v20080501-1739:1.7
	v20080425-1959:1.7
	v20080417-1610:1.7
	v20080407-2250:1.7
	v20080407-0930:1.7
	v20080404-1111:1.7
	v20080222-1200:1.7
	v20080215-1500:1.7
	v20080215-1200:1.4
	v20080201-2010:1.7
	v20080114-1111:1.7
	v20071108-0000:1.4
	v20071003-0000:1.4
	v20070928-0000:1.4
	v20070915-0000:1.4
	v20070903-0000:1.4
	v20070830-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	v20070621-0000:1.4
	RC3_20:1.4
	v20070605-1400:1.4
	v20070601-1400:1.4
	v20070518-1300:1.4
	v20070330-1300:1.4
	v20070221-1500:1.4
	v20070208-1800:1.4
	v20070202-0200:1.3.2.2
	M4_20:1.4
	v20061218-1200:1.4
	v20061214-0000:1.4
	M3_20:1.4
	v20061013-1330:1.4
	v20060925-1700:1.3.2.2
	v20060919-0800:1.3.2.2
	M1_20:1.3
	v20060824-1600:1.3.2.1
	v20060817-1500:1.3
	v20060810-1700:1.3
	v20060803-1200:1.3
	v20060728-0500:1.3
	v20060721-1130:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1200:1.3
	v20060609-1400:1.3
	v20060531-1730:1.3
	v20060519-0800:1.3
	RC2_10:1.3
	I20060505-1400:1.3
	I20060428-1300:1.3
	I20060424-0500:1.3
	I20060424-0300:1.3
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051208-2000:1.2
	I20051201-1800:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.7
date	2008.01.10.23.02.31;	author aboyko;	state Exp;
branches;
next	1.6;
commitid	6a814786a4064567;

1.6
date	2008.01.03.17.42.57;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	3284477d1ea04567;

1.5
date	2008.01.02.20.06.57;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	5a64477beede4567;

1.4
date	2006.10.03.15.04.52;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.18.20.51.17;	author cmahoney;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2005.09.12.21.27.42;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.49;	author sshaw;	state Exp;
branches;
next	;

1.3.2.1
date	2006.08.18.18.55.09;	author mmostafa;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2006.09.13.16.46.18;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Commit back [194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.figures;

import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.RGB;

/**
 * A set of methods that are useful when manipulating figures.  These are often
 * used in the paint routines or locators of IFigure implementors to do complex 
 * geometry calculations that may be common across different parts of a hierarchy.
 * 
 * @@author sshaw
 * @@canBeSeenBy %partners
 */
public class FigureUtilities extends org.eclipse.draw2d.FigureUtilities {

	/**
	 * Method colorToInteger.
	 * converts from a Color to an Integer representation
	 * @@param c
	 * @@return Integer
	 */
	public static Integer colorToInteger(Color c) {
		return new Integer(
			(c.getBlue() << 16) | (c.getGreen() << 8) | c.getRed());
	}

	/**
	 * Method integerToColor.
	 * converts from an Integer to a Color representation
	 * 
	 * Note: Normally, colors should be instantiated 
	 * using the AbstractResourceManager.
	 * 
	 * @@param i
	 * @@return Color
	 */
	public static Color integerToColor(Integer i) {
		if (i == null)
			return null;
		int color = i.intValue();
		return new Color(
			null,
			(color & 0x000000FF),
			(color & 0x0000FF00) >> 8,
			(color & 0x00FF0000) >> 16);
	}

	/**
	 * Method RGBToInteger
	 * converts from an RGB to an Integer representation
	 * @@param rgb
	 * @@return Integer
	 */
	public static Integer RGBToInteger(RGB rgb) {
		return new Integer((rgb.blue << 16) | (rgb.green << 8) | rgb.red);
	}


	/**
	 * Method integerToRGB
	 * converts from an Integer to an RGB representation
	 * @@param color
	 * @@return RGB
	 */
	public static RGB integerToRGB(Integer color) {
		int n = color.intValue();
		return new RGB(			
				(n & 0x000000FF),
				(n & 0x0000FF00) >> 8,
				(n & 0x00FF0000) >> 16);
	}

	/** 
	 * Return the location within the supplied constraint the supplied rectangle requires to be
	 * positioned according to the alignment parameter <i>pos</i>.  
	 * 
	 * <pre>
	 * NW-----N------NE
	 * |              |
	 * W    NS/EW     E
	 * |              |
	 * SW-----S------SE
	 * 
	 * </pre>
	 * <P>
	 * @@param pos a geographic PositionConstant (N,E,W,S,NW,NW,NS,EW)
	 * @@param topos the rectangle to be (re)positioned.
	 * @@param constraint the containing bounds.
	 * @@return a new location.
	 */
	public static Point getLocation(
		int pos,
		final Rectangle topos,
		final Rectangle constraint) {
		Rectangle b = constraint.getCopy();
		Point svb = new Point(b.x, b.y);

		switch (pos) {
			case PositionConstants.NORTH :
				svb.x += b.width / 2;
				break;

			case PositionConstants.SOUTH :
				svb.x += b.width / 2;
				svb.y += b.height;
				break;

			case PositionConstants.WEST :
				svb.y += b.height / 2 - topos.height / 2;
				break;

			case PositionConstants.EAST :
				svb.x += b.width;
				svb.y += b.height / 2 - topos.height / 2;
				break;

			case PositionConstants.NORTH_EAST : //top right
				svb.x += b.width - topos.width;
				break;

			case PositionConstants.SOUTH_EAST : //bottom right
				svb.x += b.width - topos.width;
				svb.y += b.height - topos.height;
				break;

			case PositionConstants.SOUTH_WEST : //bottom left
				svb.x += b.width;
				svb.y += topos.height;
				break;

			case PositionConstants.NORTH_SOUTH : // center of bounds area
			case PositionConstants.EAST_WEST :
				svb.x += b.width / 2 - topos.width / 2;
				svb.y += b.height / 2 - topos.height / 2;
				break;

			case PositionConstants.NORTH_WEST : //top left
			default :
				break;
		}
		return svb;
	}

	/**
	 * Return the location within the supplied constraint of an object of dimension  <i>dim</i> 
	 * according to the alignment parameter. 
	 * @@see #getLocation(int, Rectangle, Rectangle)
	 * @@param pos a geographic PositionConstant (N,E,W,S,NW,NW,NS,EW)
	 * @@param dim some dimension.
	 * @@param constraint the containing bounds.
	 * @@return a new location.
	 */
	public static Point getLocation(
		int pos,
		final Dimension dim,
		final Rectangle constraint) {
		return getLocation(
			pos,
			new Rectangle(0, 0, dim.width, dim.height),
			constraint);
	}

	
	/**
	 * Helper method to paint a grid.  Painting is optimized as it is restricted to the
	 * Graphics' clip.
	 * 
	 * @@param	g			The Graphics object to be used for painting
	 * @@param	f			The figure in which the grid is to be painted
	 * @@param	origin		Any point where the grid lines are expected to intersect
	 * @@param	distanceX	Distance between vertical grid lines; if 0 or less, vertical grid
	 * 						lines will not be drawn
	 * @@param	distanceY	Distance between horizontal grid lines; if 0 or less, horizontal
	 * 						grid lines will not be drawn
	 * @@param	lineStyle   Line style to be used for painting the grid lines
	 * @@param   dashes      Dash pattern to be used for the grid line (ignored if lineStyle != LINE_CUSTOM)
	 * 
	 */
	public static void paintGridWithStyle(Graphics g, IFigure f, 
			org.eclipse.draw2d.geometry.Point origin, int distanceX, int distanceY, int lineStyle, int[] dashes) {
		Rectangle clip = g.getClip(Rectangle.SINGLETON);
		
		int origLineStyle = g.getLineStyle();		
		
		if (distanceX > 0) {
			if (origin.x >= clip.x)
				while (origin.x - distanceX >= clip.x)
					origin.x -= distanceX;
			else
				while (origin.x < clip.x)
					origin.x += distanceX;
			for (int i = origin.x; i < clip.x + clip.width; i += distanceX) {
				g.setLineStyle(lineStyle);
				if ((dashes != null) && (lineStyle == SWT.LINE_CUSTOM)) g.setLineDash(dashes);
				g.drawLine(i, clip.y, i, clip.y + clip.height);
				g.setLineStyle(origLineStyle);
			}
		}
		
		if (distanceY > 0) {
			if (origin.y >= clip.y)
				while (origin.y - distanceY >= clip.y)
					origin.y -= distanceY;
			else
				while (origin.y < clip.y)
					origin.y += distanceY;
			for (int i = origin.y; i < clip.y + clip.height; i += distanceY) {
				g.setLineStyle(lineStyle);
				if ((dashes != null) && (lineStyle == SWT.LINE_CUSTOM)) g.setLineDash(dashes);
				g.drawLine(clip.x, i, clip.x + clip.width, i);
				g.setLineStyle(origLineStyle);
			}
		}
	}

	/**
	 * Calculates the anchorable figure bounds. There could be cases that a figure
	 * implements both <code>IOvalAnchorableFigure</code> and <code>IPolygonAnchorableFigure</code>
	 * interfaces. The latter interface is more popular because any figure can be approximated
	 * with line segments including ellipse. Therefore, we need to check first if it's an
	 * ellipse like figure and then if it's some kind of a polygon.
	 * 
	 * @@param figure the figure
	 * @@return the bounding <code>Rectangle</code> of the anchorable part of the figure
	 */
	public static Rectangle getAnchorableFigureBounds(IFigure figure) {
		if (figure instanceof IOvalAnchorableFigure) {
			return ((IOvalAnchorableFigure)figure).getOvalBounds().getCopy();
		} else if (figure instanceof IPolygonAnchorableFigure) {
			return ((IPolygonAnchorableFigure)figure).getPolygonPoints().getBounds();
		} else if (figure instanceof IFigure) {
			return figure.getBounds().getCopy();
		}
		return null;
	}
	
}
@


1.6
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d234 20
a253 2
	
	
@


1.5
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d234 2
a235 20
	/**
	 * Calculates the anchorable figure bounds. There could be cases that a figure
	 * implements both <code>IOvalAnchorableFigure</code> and <code>IPolygonAnchorableFigure</code>
	 * interfaces. The latter interface is more popular because any figure can be approximated
	 * with line segments including ellipse. Therefore, we need to check first if it's an
	 * ellipse like figure and then if it's some kind of a polygon.
	 * 
	 * @@param figure the figure
	 * @@return the bounding <code>Rectangle</code> of the anchorable part of the figure
	 */
	public static Rectangle getAnchorableFigureBounds(IFigure figure) {
		if (figure instanceof IOvalAnchorableFigure) {
			return ((IOvalAnchorableFigure)figure).getOvalBounds().getCopy();
		} else if (figure instanceof IPolygonAnchorableFigure) {
			return ((IPolygonAnchorableFigure)figure).getPolygonPoints().getBounds();
		} else if (figure instanceof IFigure) {
			return figure.getBounds().getCopy();
		}
		return null;
	}
@


1.4
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d234 20
a253 2
	
	
@


1.3
log
@Bugzilla#109422 gmf_head cmahoney 060418 Remove deprecated API
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2004 IBM Corporation and others.
d14 2
d20 1
d181 56
@


1.3.2.1
log
@[147361] gmf_R1_0_maintenance tmacdoug 060818 Cell editor border is rendered with a dotted line when the grid
@
text
@a13 2
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.IFigure;
a17 1
import org.eclipse.swt.SWT;
a177 56
	
	/**
	 * Helper method to paint a grid.  Painting is optimized as it is restricted to the
	 * Graphics' clip.
	 * 
	 * @@param	g			The Graphics object to be used for painting
	 * @@param	f			The figure in which the grid is to be painted
	 * @@param	origin		Any point where the grid lines are expected to intersect
	 * @@param	distanceX	Distance between vertical grid lines; if 0 or less, vertical grid
	 * 						lines will not be drawn
	 * @@param	distanceY	Distance between horizontal grid lines; if 0 or less, horizontal
	 * 						grid lines will not be drawn
	 * @@param	lineStyle   Line style to be used for painting the grid lines
	 * @@param   dashes      Dash pattern to be used for the grid line (ignored if lineStyle != LINE_CUSTOM)
	 * 
	 */
	public static void paintGridWithStyle(Graphics g, IFigure f, 
			org.eclipse.draw2d.geometry.Point origin, int distanceX, int distanceY, int lineStyle, int[] dashes) {
		Rectangle clip = g.getClip(Rectangle.SINGLETON);
		
		int origLineStyle = g.getLineStyle();		
		
		if (distanceX > 0) {
			if (origin.x >= clip.x)
				while (origin.x - distanceX >= clip.x)
					origin.x -= distanceX;
			else
				while (origin.x < clip.x)
					origin.x += distanceX;
			for (int i = origin.x; i < clip.x + clip.width; i += distanceX) {
				g.setLineStyle(lineStyle);
				if ((dashes != null) && (lineStyle == SWT.LINE_CUSTOM)) g.setLineDash(dashes);
				g.drawLine(i, clip.y, i, clip.y + clip.height);
				g.setLineStyle(origLineStyle);
			}
		}
		
		if (distanceY > 0) {
			if (origin.y >= clip.y)
				while (origin.y - distanceY >= clip.y)
					origin.y -= distanceY;
			else
				while (origin.y < clip.y)
					origin.y += distanceY;
			for (int i = origin.y; i < clip.y + clip.height; i += distanceY) {
				g.setLineStyle(lineStyle);
				if ((dashes != null) && (lineStyle == SWT.LINE_CUSTOM)) g.setLineDash(dashes);
				g.drawLine(clip.x, i, clip.x + clip.width, i);
				g.setLineStyle(origLineStyle);
			}
		}
	}

	
	
	
@


1.3.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a13 2
import java.util.List;

a16 1
import org.eclipse.draw2d.geometry.PointList;
a20 3
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;

a177 48

	/**
	 * Method getLineSegments.
	 * Converts the points of this polyline into a list of <code>LineSeg</code> 
	 *      objects
	 * 
	 * @@param points PointList to get LineSeg equivalents of.
	 * @@return List of LineSeg objects.
	 * @@deprecated replace with {@@link PointListUtilities#getLineSegments(PointList)}
	 */
	public static List getLineSegments(PointList points) {
		return PointListUtilities.getLineSegments(points);
	}

	/**
	 * Static utility method to get the nearest segment in the polyline 
	 * from the given coordinates.
	 * 
	 * @@param mySegments the <code>List</code> of <code>LineSeg</code> objects
	 * @@param xCoord the <code>int</code> x coordinate of the point
	 * @@param yCoord the <code>int</code> y coordinate of the point
	 * @@return the <code>LineSeg</code> by reference which is closest to the given coordinates.
	 * @@deprecated replace with (@@link PointListUtilities#getNearestSegment(List, int, int)}
	 */
	public static LineSeg getNearestSegment(
		List mySegments,
		final int xCoord,
		final int yCoord) {
		
		return PointListUtilities.getNearestSegment(mySegments, xCoord, yCoord);
	}

	/**
	 * Method findNearestLineSegIndexOfPoint.
	 * Calculate the nearest line segment index distance wise to the given point.
	 * 
	 * @@param points PointList to calculate the nearest line segment of.
	 * @@param ptCoord the <code>Point</code> to test containment of.
	 * @@return int Index of line segment that is nearest in the polyline to the given point.
	 * The index is 1 based where 1 represents the first segment.
	 * @@deprecated replace with {@@link PointListUtilities#findNearestLineSegIndexOfPoint(PointList, Point)}
	 */
	static public int findNearestLineSegIndexOfPoint(
		PointList points,
		final Point ptCoord) {
		
		return PointListUtilities.findNearestLineSegIndexOfPoint(points, ptCoord);
	}
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
t *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

