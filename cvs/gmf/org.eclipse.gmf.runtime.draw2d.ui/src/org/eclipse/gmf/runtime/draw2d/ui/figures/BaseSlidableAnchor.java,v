head	1.7;
access;
symbols
	v20081023-2107:1.7
	v20081022-1925:1.7
	v20081021-1810:1.7
	v20081020-0700:1.7
	v20080911-1728:1.7
	v20080911-1506:1.7
	v20080910-1520:1.7
	v20080910-1510:1.7
	v20080903-1520:1.7
	v20080903-1510:1.7
	v20080722-1827:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080610-1132:1.7
	v20080603-1553:1.6
	v20080512-1200:1.6
	v20080503-1740:1.6
	v20080501-1739:1.6
	v20080425-1959:1.6
	v20080417-1610:1.6
	v20080407-2250:1.6
	v20080407-0930:1.6
	v20080404-1111:1.6
	v20080222-1200:1.6
	v20080215-1500:1.6
	v20080215-1200:1.2.2.1
	v20080201-2010:1.6
	v20080114-1111:1.6
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070928-0000:1.2.2.1
	v20070915-0000:1.2.2.1
	v20070903-0000:1.3
	v20070830-0000:1.2.2.1
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	v20070621-0000:1.2
	RC3_20:1.2
	v20070605-1400:1.2
	v20070601-1400:1.2
	v20070518-1300:1.2
	v20070330-1300:1.2
	v20070221-1500:1.2
	v20070208-1800:1.2
	v20070202-0200:1.1.2.1
	M4_20:1.1
	v20061218-1200:1.1
	v20061214-0000:1.1
	M3_20:1.1
	v20061013-1330:1.1
	v20060925-1700:1.1
	v20060919-0800:1.1
	M1_20:1.1
	v20060824-1600:1.1
	v20060817-1500:1.1
	v20060810-1700:1.1
	v20060803-1200:1.1
	v20060728-0500:1.1
	v20060721-1130:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060616-1200:1.1
	v20060609-1400:1.1
	v20060531-1730:1.1
	v20060519-0800:1.1
	RC2_10:1.1
	I20060505-1400:1.1
	I20060428-1300:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1;
locks; strict;
comment	@# @;


1.7
date	2008.06.05.18.41.26;	author aboyko;	state Exp;
branches;
next	1.6;
commitid	652c484833554567;

1.6
date	2008.01.10.23.02.31;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	6a814786a4064567;

1.5
date	2008.01.03.17.42.57;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	3284477d1ea04567;

1.4
date	2008.01.02.20.06.57;	author aboyko;	state Exp;
branches;
next	1.3;
commitid	5a64477beede4567;

1.3
date	2007.08.15.15.43.08;	author aboyko;	state Exp;
branches;
next	1.2;
commitid	334b46c31f0b4567;

1.2
date	2007.01.26.22.04.17;	author crevells;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	2e9545ba7ae14567;

1.1
date	2006.04.21.21.14.49;	author sshaw;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2007.01.26.22.40.36;	author crevells;	state Exp;
branches;
next	;
commitid	19fe45ba83644567;

1.2.2.1
date	2007.08.15.15.49.38;	author aboyko;	state Exp;
branches;
next	;
commitid	3d5546c320914567;


desc
@@


1.7
log
@[235875] gmf_head aboyko 080605 [Layout] BaseSlidableAnchor can return an invalid anchor relative location
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.figures;

import org.eclipse.draw2d.AbstractConnectionAnchor;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionPoint;
import org.eclipse.draw2d.geometry.PrecisionRectangle;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PrecisionPointList;


/**
 * Provides the implementation of Slidable anchor
 * 
 * @@author oboyko / sshaw
 *
 */
public class BaseSlidableAnchor
	extends AbstractConnectionAnchor implements OrthogonalConnectionAnchor {
	
	final private static char TERMINAL_START_CHAR = '(';
	final private static char TERMINAL_DELIMITER_CHAR = ',';
	final private static char TERMINAL_END_CHAR = ')'; 

	// The connection anchor reference point (sometimes the same as anchor location)
	private PrecisionPoint relativeReference;

	/**
	 * Empty constructor 
	 */
	public BaseSlidableAnchor() {
		// empty constructor
	}
	
	/**
	 * Default constructor. The anchor will have the center of the figure as the
	 * reference point 
	 * 
	 * @@param f <code>IFigure</code> that this anchor is associated with.
	 */
	public BaseSlidableAnchor(IFigure f) {
		super(f);
	}

	/**
	 * Constructor. Takes point p to store the reference point 
	 * 
	 * @@param f <code>IFigure</code> that this anchor is associated with.
	 * @@param p the <code>PrecisionPoint</code> that the anchor will initially attach to.
	 */
	public BaseSlidableAnchor(IFigure f, PrecisionPoint p) {
		super(f);
		this.relativeReference = new PrecisionPoint(p.preciseX, p.preciseY);
	}
	
	/**
	 * Creates terminal string for slidable anchor
	 * 
	 * @@return <code>String</code> terminal for slidable anchor
	 */
	public String getTerminal() {
		if (isDefaultAnchor())
			return StringStatics.BLANK;
		return composeTerminalString(relativeReference);
	}

	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.draw2d.ConnectionAnchor#getReferencePoint()
	 */
	public Point getReferencePoint() {
		return getAnchorPosition();
	}
	
	/**
	 * Creates a terminal string for any reference point passed in the format understandable by
	 * slidable anchors
	 * 
	 * @@param p - a <Code>PrecisionPoint</Code> that must be represented as a unique
	 * <Code>String</Code>, namely as "(preciseX,preciseY)"
	 * @@return <code>String</code> terminal composed from specified <code>PrecisionPoint</code>  
	 */
	private String composeTerminalString(PrecisionPoint p) {
		StringBuffer s = new StringBuffer(24);
		s.append(TERMINAL_START_CHAR); 		// 1 char
		s.append((float)p.preciseX);		// 10 chars
		s.append(TERMINAL_DELIMITER_CHAR);	// 1 char
		s.append((float)p.preciseY);		// 10 chars
		s.append(TERMINAL_END_CHAR);		// 1 char
		return s.toString();				// 24 chars max (+1 for safety, i.e. for string termination)
	}

	/**
	 * From relative reference returns the relative coordinates of the anchor
	 * Method's visibility can be changed as needed
	 */
	private Point getAnchorPosition() {
		PrecisionRectangle rBox = new PrecisionRectangle(getBox());
		if (isDefaultAnchor())
			return rBox.getCenter();
		return new PrecisionPoint(relativeReference.preciseX * rBox.preciseWidth
				+ rBox.preciseX, relativeReference.preciseY * rBox.preciseHeight
				+ rBox.preciseY);
	}
	
	/**
	 * Calculates the location of the anchor depending on the anchors own reference
	 * and foreign reference points
	 * 
	 * @@param ownReference - the own reference of the anchor
	 * @@param foreignReference - foreign reference that comes in 
	 * @@return the location of the anchor depending on the anchors own reference
	 * and foreign reference points
	 */
	protected Point getLocation(Point ownReference, Point foreignReference) {
		PointList intersections = getIntersectionPoints(ownReference, foreignReference);
		if (intersections!=null && intersections.size()!=0) {
			Point location = PointListUtilities.pickClosestPoint(intersections, foreignReference);
			return location;
		}
		return null;
	}

	static private int STRAIGHT_LINE_TOLERANCE = 3;

	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.draw2d.ConnectionAnchor#getLocation(org.eclipse.draw2d.geometry.Point)
	 */
	public Point getLocation(Point reference) {
		Point ownReference = normalizeToStraightlineTolerance(reference, getReferencePoint(), STRAIGHT_LINE_TOLERANCE);
		
		Point location = getLocation(ownReference, reference);
		if (location == null) {
			location = getLocation(new PrecisionPoint(getBox().getCenter()), reference);
			if (location == null) {
				location = getBox().getCenter();
			}
		}
		
		return location;
	}

	
	/**
	 * Returns a new owned reference point that is normalized to be with-in a straight-line 
	 * tolerance value.
	 * 
	 * @@param foreignReference <code>Point</code> that is the foreign reference point used to calculate
	 * the interfection anchor point on the shape in absolute coordinates.
	 * @@param ownReference <code>Point</code> that is the reference point with-in the shape in 
	 * absolute coordinates
	 * @@param tolerance <code>int</code> value that is the difference in absolute coordinates where the
	 * two points would be considered straight and then adjusted.
	 * @@return <code>Point</code> that is the normalized owned reference to be with-in a given
	 * straight-line tolerance value of the foreign reference point.
	 */
	protected Point normalizeToStraightlineTolerance(Point foreignReference, Point ownReference, int tolerance) {
		PrecisionPoint preciseOwnReference = new PrecisionPoint(ownReference);
		PrecisionPoint normalizedReference = (PrecisionPoint)preciseOwnReference.getCopy();
		PrecisionPoint preciseForeignReference = new PrecisionPoint(foreignReference);
		if (Math.abs(preciseForeignReference.preciseX - preciseOwnReference.preciseX) < tolerance) {
			normalizedReference.preciseX = preciseForeignReference.preciseX;
			normalizedReference.updateInts();
			return normalizedReference;
		}
		if (Math.abs(preciseForeignReference.preciseY - preciseOwnReference.preciseY) < tolerance) {
			normalizedReference.preciseY = preciseForeignReference.preciseY;
			normalizedReference.updateInts();
		}
		return normalizedReference;
	}

	/**
	 * Calculates intersection points of the figure and the line that passes through 
	 * ownReference and foreignReference points
	 * 
	 * @@param ownReference the reference <code>Point</code> on or inside the shape that is being
	 * anchored to.
	 * @@param foreignReference the outside reference <code>Point</code> point that is the terminal
	 * end of the line formed by the two parameters.
	 * @@return intersection points of the figure and the line that passes through 
	 * ownReference and foreignReference points
	 */
	protected PointList getIntersectionPoints(Point ownReference, Point foreignReference) {
		final PointList polygon = getPolygonPoints();
		return (new LineSeg(ownReference, foreignReference)).getLineIntersectionsWithLineSegs(polygon); 
	}

	
	/**
	 * Returns the list of all the vertices of the figure.
	 * The created list must form a polygon, i.e. closed polyline, for figures
	 * hence the starting and ending points must be the same
	 * 
	 * @@return the <code>PointList</code> list of all the vertices of the figure.
	 */
	protected PointList getPolygonPoints() {
		if (getOwner() instanceof IPolygonAnchorableFigure) {
			PrecisionPointList polyList = new PrecisionPointList(((IPolygonAnchorableFigure) getOwner()).getPolygonPoints());
			getOwner().translateToAbsolute(polyList);
			return polyList;
		}
		PrecisionRectangle r = new PrecisionRectangle(getBox());
		PrecisionPointList ptList = new PrecisionPointList(5);
		ptList.addPoint(new PrecisionPoint(r.preciseX, r.preciseY));
		ptList.addPoint(new PrecisionPoint(r.preciseX + r.preciseWidth, r.preciseY));
		ptList.addPoint(new PrecisionPoint(r.preciseX + r.preciseWidth, r.preciseY + r.preciseHeight));
		ptList.addPoint(new PrecisionPoint(r.preciseX, r.preciseY + r.preciseHeight));
		ptList.addPoint(new PrecisionPoint(r.preciseX, r.preciseY));
		return ptList;
	}

	/**
	 * Calculates the relative location of the reference point with respect to the bounds
	 * of the figure. If point p is not inside of the figure's bounds then the point
	 * is mapped on the bounds and the point relative location is calculated 
	 * 
	 * @@param p the <code>Point</code> that is relative coordinates of the point
	 * @@return <Code>PrecisionPoint</Code>, i.e. the relative reference for
	 * <Code>SlidableAnchor</Code>
	 */
	static public PrecisionPoint getAnchorRelativeLocation(Point p, Rectangle bounds) {
		if (bounds.width == 0 || bounds.height == 0) {
			/*
			 * If figure hasn't been laid out yet, we don't want to fail the slidable anchor creation.
			 * Hence, we'll just return the (0.5, 0.5) meaning that the anchor reference point is the center of the figure.
			 */
			return new PrecisionPoint(0.5, 0.5);
		}
		PrecisionPoint relLocation;
		Point temp = new Point(p);
		if (p.x < bounds.x || p.x > bounds.x + bounds.width
			|| p.y < bounds.y || p.y > bounds.y + bounds.height) {
			if (p.x < bounds.x || p.x > bounds.x + bounds.width) {
				temp.x = p.x < bounds.x ? bounds.x
					: bounds.x + bounds.width;
			}
			if (p.y < bounds.y || p.y > bounds.y + bounds.height) {
				temp.y = p.y < bounds.y ? bounds.y
					: bounds.y + bounds.height;
			}
			relLocation = new PrecisionPoint((double) (temp.x - bounds.x)
				/ bounds.width, (double) (temp.y - bounds.y)
				/ bounds.height);
		} else {

		relLocation = new PrecisionPoint((double) (temp.x - bounds.x)
				/ bounds.width, (double) (temp.y - bounds.y)
				/ bounds.height);
		}
		return relLocation;
	}
	
	/**
	 * Gets the anchors associated figure's bounding box in absolute coordinates.
	 * 
	 * @@return a <code>Rectangle</code> that is the bounding box of the owner figure 
	 * in absolute coordinates
	 */
	protected Rectangle getBox() {
        Rectangle rBox = (getOwner() instanceof Connection) ? ((Connection) getOwner())
            .getPoints().getBounds()
            : getOwner().getBounds();
        PrecisionRectangle box = new PrecisionRectangle(rBox);
        getOwner().translateToAbsolute(box);
        return box;
	}
	
	/**
	 * Returns true if the <Code>SlidableAnchor</Code> is default one with a reference at the center
	 * 
	 * @@return <code>boolean</code> <code>true</code> is the <code>SlidableAnchor</code> is default one, <code>false</code> otherwise
	 */
	public boolean isDefaultAnchor() {
		return relativeReference == null;
	}
	
	/**
	 * Parses anchors terminal string and returns the relative reference icorporated
	 * in the terminal string
	 * 
	 * @@param terminal - the terminal string containing relative reference
	 * @@return returns the relative reference incorporated in the terminal string
	 */
	public static PrecisionPoint parseTerminalString(String terminal) {
		try {
			return new PrecisionPoint(Float.parseFloat(terminal.substring(
				terminal.indexOf(BaseSlidableAnchor.TERMINAL_START_CHAR) + 1,
				terminal.indexOf(BaseSlidableAnchor.TERMINAL_DELIMITER_CHAR))),
				Float.parseFloat(terminal.substring(terminal
					.indexOf(BaseSlidableAnchor.TERMINAL_DELIMITER_CHAR) + 1,
					terminal.indexOf(BaseSlidableAnchor.TERMINAL_END_CHAR))));
		} catch (Exception e) {
			return null;
		}
	}
	
	public Point getOrthogonalLocation(Point orthoReference) {
		PrecisionPoint ownReference = new PrecisionPoint(getReferencePoint());
//		PrecisionRectangle bounds = new PrecisionRectangle(getBox());
		PrecisionRectangle bounds = new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getOwner()));
		getOwner().translateToAbsolute(bounds);
		bounds.expand(0.000001, 0.000001);
		PrecisionPoint preciseOrthoReference = new PrecisionPoint(orthoReference);
		int orientation = PositionConstants.NONE;
		if (preciseOrthoReference.preciseX >= bounds.preciseX && preciseOrthoReference.preciseX <= bounds.preciseX + bounds.preciseWidth) {
			ownReference.preciseX = preciseOrthoReference.preciseX;
			orientation = PositionConstants.VERTICAL;
		} else if (preciseOrthoReference.preciseY >= bounds.preciseY && preciseOrthoReference.preciseY <= bounds.preciseY + bounds.preciseHeight) {
			ownReference.preciseY = preciseOrthoReference.preciseY;
			orientation = PositionConstants.HORIZONTAL;
		}
		ownReference.updateInts();
		
		Point location = getLocation(ownReference, preciseOrthoReference);
		if (location == null) {
			location = getLocation(orthoReference);
			orientation = PositionConstants.NONE;
		}
		
		if (orientation != PositionConstants.NONE) {
			PrecisionPoint loc = new PrecisionPoint(location);
			if (orientation == PositionConstants.VERTICAL) {
				loc.preciseX = preciseOrthoReference.preciseX;
			} else {
				loc.preciseY = preciseOrthoReference.preciseY;
			}
			loc.updateInts();
			location = loc;
		}
		
		return location;
	}

}
@


1.6
log
@Commit back [194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d241 7
@


1.5
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d17 1
d26 1
d36 1
a36 1
	extends AbstractConnectionAnchor {
d42 1
a42 1
	// The connection anchor refrence point (sometimes the same as anchor location)
d115 1
a115 1
		Rectangle rBox = getBox();
d118 3
a120 3
		return new Point(Math.round(relativeReference.preciseX * rBox.width
			+ rBox.x), Math.round(relativeReference.preciseY
			* rBox.height + rBox.y));
d141 1
a141 1
	static private int STRAIGHT_LINE_TOLERANCE = 10;
d148 1
a148 2
		Point foreignReference = reference.getCopy();
		Point ownReference = getReferencePoint().getCopy();
d150 6
a155 10
		ownReference = normalizeToStraightlineTolerance(foreignReference, ownReference, STRAIGHT_LINE_TOLERANCE);
		
		Point location = getLocation(ownReference, foreignReference);
		if (location == null || 
			getBox().expand(1, 1).contains(foreignReference) &&
			!getBox().shrink(1, 1).contains(foreignReference))
			location = getLocation(getBox().getCenter(), foreignReference);
		
		if (location==null) {
			location = getBox().getCenter();
d159 2
a160 2
	}	
	
d176 11
a186 13
		Point normalizedReference = ownReference.getCopy();
		if (Math.abs(foreignReference.x - ownReference.x) < tolerance || 
			Math.abs(foreignReference.y - ownReference.y) < tolerance) {
			LineSeg lineSeg = new LineSeg(ownReference, foreignReference);
				
			normalizedReference = lineSeg.perpIntersect(ownReference.x, ownReference.y);
			
			// account for possible rounding errors and ensure the
			// resulting line is straight
			if (Math.abs(normalizedReference.x - foreignReference.x) < Math.abs(normalizedReference.y - foreignReference.y))
				normalizedReference.x = foreignReference.x;
			else
				normalizedReference.y = foreignReference.y;
d204 1
a204 1
		return (new LineSeg(ownReference,foreignReference)).getLineIntersectionsWithLineSegs(polygon);
d217 1
a217 1
			PointList polyList = ((IPolygonAnchorableFigure) getOwner()).getPolygonPoints();
d221 7
a227 7
		Rectangle rBox = getBox();
		PointList ptList = new PointList();
		ptList.addPoint(rBox.getTopLeft());
		ptList.addPoint(rBox.getTopRight());
		ptList.addPoint(rBox.getBottomRight());
		ptList.addPoint(rBox.getBottomLeft());
		ptList.addPoint(rBox.getTopLeft());
d273 2
a274 2
            .getPoints().getBounds().getCopy()
            : getOwner().getBounds().getCopy();
d278 1
a278 1
    }
d309 37
@


1.4
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@a16 1
import org.eclipse.draw2d.PositionConstants;
a24 1
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PrecisionPointList;
d34 1
a34 1
	extends AbstractConnectionAnchor implements OrthogonalConnectionAnchor {
d40 1
a40 1
	// The connection anchor reference point (sometimes the same as anchor location)
d113 1
a113 1
		PrecisionRectangle rBox = new PrecisionRectangle(getBox());
d116 3
a118 3
		return new PrecisionPoint(relativeReference.preciseX * rBox.preciseWidth
				+ rBox.preciseX, relativeReference.preciseY * rBox.preciseHeight
				+ rBox.preciseY);
d139 1
a139 1
	static private int STRAIGHT_LINE_TOLERANCE = 3;
d146 2
a147 1
		Point ownReference = normalizeToStraightlineTolerance(reference, getReferencePoint(), STRAIGHT_LINE_TOLERANCE);
d149 10
a158 6
		Point location = getLocation(ownReference, reference);
		if (location == null) {
			location = getLocation(new PrecisionPoint(getBox().getCenter()), reference);
			if (location == null) {
				location = getBox().getCenter();
			}
d162 2
a163 2
	}

d179 13
a191 11
		PrecisionPoint preciseOwnReference = new PrecisionPoint(ownReference);
		PrecisionPoint normalizedReference = (PrecisionPoint)preciseOwnReference.getCopy();
		PrecisionPoint preciseForeignReference = new PrecisionPoint(foreignReference);
		if (Math.abs(preciseForeignReference.preciseX - preciseOwnReference.preciseX) < tolerance) {
			normalizedReference.preciseX = preciseForeignReference.preciseX;
			normalizedReference.updateInts();
			return normalizedReference;
		}
		if (Math.abs(preciseForeignReference.preciseY - preciseOwnReference.preciseY) < tolerance) {
			normalizedReference.preciseY = preciseForeignReference.preciseY;
			normalizedReference.updateInts();
d209 1
a209 1
		return (new LineSeg(ownReference, foreignReference)).getLineIntersectionsWithLineSegs(polygon); 
d222 1
a222 1
			PrecisionPointList polyList = new PrecisionPointList(((IPolygonAnchorableFigure) getOwner()).getPolygonPoints());
d226 7
a232 7
		PrecisionRectangle r = new PrecisionRectangle(getBox());
		PrecisionPointList ptList = new PrecisionPointList(5);
		ptList.addPoint(new PrecisionPoint(r.preciseX, r.preciseY));
		ptList.addPoint(new PrecisionPoint(r.preciseX + r.preciseWidth, r.preciseY));
		ptList.addPoint(new PrecisionPoint(r.preciseX + r.preciseWidth, r.preciseY + r.preciseHeight));
		ptList.addPoint(new PrecisionPoint(r.preciseX, r.preciseY + r.preciseHeight));
		ptList.addPoint(new PrecisionPoint(r.preciseX, r.preciseY));
d278 2
a279 2
            .getPoints().getBounds()
            : getOwner().getBounds();
d283 1
a283 1
	}
a313 37
	public Point getOrthogonalLocation(Point orthoReference) {
		PrecisionPoint ownReference = new PrecisionPoint(getReferencePoint());
//		PrecisionRectangle bounds = new PrecisionRectangle(getBox());
		PrecisionRectangle bounds = new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getOwner()));
		getOwner().translateToAbsolute(bounds);
		bounds.expand(0.000001, 0.000001);
		PrecisionPoint preciseOrthoReference = new PrecisionPoint(orthoReference);
		int orientation = PositionConstants.NONE;
		if (preciseOrthoReference.preciseX >= bounds.preciseX && preciseOrthoReference.preciseX <= bounds.preciseX + bounds.preciseWidth) {
			ownReference.preciseX = preciseOrthoReference.preciseX;
			orientation = PositionConstants.VERTICAL;
		} else if (preciseOrthoReference.preciseY >= bounds.preciseY && preciseOrthoReference.preciseY <= bounds.preciseY + bounds.preciseHeight) {
			ownReference.preciseY = preciseOrthoReference.preciseY;
			orientation = PositionConstants.HORIZONTAL;
		}
		ownReference.updateInts();
		
		Point location = getLocation(ownReference, preciseOrthoReference);
		if (location == null) {
			location = getLocation(orthoReference);
			orientation = PositionConstants.NONE;
		}
		
		if (orientation != PositionConstants.NONE) {
			PrecisionPoint loc = new PrecisionPoint(location);
			if (orientation == PositionConstants.VERTICAL) {
				loc.preciseX = preciseOrthoReference.preciseX;
			} else {
				loc.preciseY = preciseOrthoReference.preciseY;
			}
			loc.updateInts();
			location = loc;
		}
		
		return location;
	}

@


1.3
log
@[200053] gmf_HEAD aboyko 070815 [Layout] Need to introduce BorderItemObliqueRouter similiar to BorderItemRectilinearRouter to improve drawing connections to/from border items
@
text
@d17 1
d26 1
d36 1
a36 1
	extends AbstractConnectionAnchor {
d42 1
a42 1
	// The connection anchor refrence point (sometimes the same as anchor location)
d115 1
a115 1
		Rectangle rBox = getBox();
d118 3
a120 3
		return new Point(Math.round(relativeReference.preciseX * rBox.width
			+ rBox.x), Math.round(relativeReference.preciseY
			* rBox.height + rBox.y));
d141 1
a141 1
	static private int STRAIGHT_LINE_TOLERANCE = 10;
d148 1
a148 2
		Point foreignReference = reference.getCopy();
		Point ownReference = getReferencePoint().getCopy();
d150 6
a155 10
		ownReference = normalizeToStraightlineTolerance(foreignReference, ownReference, STRAIGHT_LINE_TOLERANCE);
		
		Point location = getLocation(ownReference, foreignReference);
		if (location == null || 
			getBox().expand(1, 1).contains(foreignReference) &&
			!getBox().shrink(1, 1).contains(foreignReference))
			location = getLocation(getBox().getCenter(), foreignReference);
		
		if (location==null) {
			location = getBox().getCenter();
d159 2
a160 2
	}	
	
d176 11
a186 13
		Point normalizedReference = ownReference.getCopy();
		if (Math.abs(foreignReference.x - ownReference.x) < tolerance || 
			Math.abs(foreignReference.y - ownReference.y) < tolerance) {
			LineSeg lineSeg = new LineSeg(ownReference, foreignReference);
				
			normalizedReference = lineSeg.perpIntersect(ownReference.x, ownReference.y);
			
			// account for possible rounding errors and ensure the
			// resulting line is straight
			if (Math.abs(normalizedReference.x - foreignReference.x) < Math.abs(normalizedReference.y - foreignReference.y))
				normalizedReference.x = foreignReference.x;
			else
				normalizedReference.y = foreignReference.y;
d204 1
a204 1
		return (new LineSeg(ownReference,foreignReference)).getLineIntersectionsWithLineSegs(polygon);
d217 1
a217 1
			PointList polyList = ((IPolygonAnchorableFigure) getOwner()).getPolygonPoints();
d221 7
a227 7
		Rectangle rBox = getBox();
		PointList ptList = new PointList();
		ptList.addPoint(rBox.getTopLeft());
		ptList.addPoint(rBox.getTopRight());
		ptList.addPoint(rBox.getBottomRight());
		ptList.addPoint(rBox.getBottomLeft());
		ptList.addPoint(rBox.getTopLeft());
d273 2
a274 2
            .getPoints().getBounds().getCopy()
            : getOwner().getBounds().getCopy();
d278 1
a278 1
    }
d309 37
@


1.2
log
@[112996] gmf_R1_0_maintenance crevells 070126 Attaching a rectilinear routed line to a connection connects to space
@
text
@d20 1
a21 1

d280 3
a282 2
        getOwner().translateToAbsolute(rBox);
        return rBox;
@


1.2.2.1
log
@[200053] gmf_R2_0_maintenance aboyko 070815 [Layout] Need to introduce BorderItemObliqueRouter similiar to BorderItemRectilinearRouter to improve drawing connections to/from border items
@
text
@a19 1
import org.eclipse.draw2d.geometry.PrecisionRectangle;
d21 1
d280 2
a281 3
        PrecisionRectangle box = new PrecisionRectangle(rBox);
        getOwner().translateToAbsolute(box);
        return box;
@


1.1
log
@bugzilla 137787 gmf-head sshaw 060421 API propogation for SlidableAnchor's getLocation()
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
d15 1
d277 6
a282 5
		Rectangle rBox = getOwner().getBounds().getCopy();
		
		getOwner().translateToAbsolute(rBox);
		return rBox;
	}
@


1.1.2.1
log
@[112996] gmf_R1_0_maintenance crevells 070126 Attaching a rectilinear routed line to a connection connects to space
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
a14 1
import org.eclipse.draw2d.Connection;
d276 5
a280 6
        Rectangle rBox = (getOwner() instanceof Connection) ? ((Connection) getOwner())
            .getPoints().getBounds().getCopy()
            : getOwner().getBounds().getCopy();
        getOwner().translateToAbsolute(rBox);
        return rBox;
    }
@


