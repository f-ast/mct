head	1.10;
access;
symbols
	v20081023-2107:1.10
	v20081022-1925:1.10
	v20081021-1810:1.10
	v20081020-0700:1.10
	v20080911-1728:1.10
	v20080911-1506:1.10
	v20080910-1520:1.10
	v20080910-1510:1.10
	v20080903-1520:1.10
	v20080903-1510:1.10
	v20080722-1827:1.10
	R2_1_maintenance:1.10.0.2
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080610-1132:1.10
	v20080603-1553:1.10
	v20080512-1200:1.10
	v20080503-1740:1.10
	v20080501-1739:1.10
	v20080425-1959:1.10
	v20080417-1610:1.10
	v20080407-2250:1.10
	v20080407-0930:1.10
	v20080404-1111:1.9
	v20080222-1200:1.7
	v20080215-1500:1.7
	v20080215-1200:1.2.2.1
	v20080201-2010:1.6
	v20080114-1111:1.6
	v20071108-0000:1.3
	v20071003-0000:1.2
	v20070928-0000:1.2
	v20070915-0000:1.2
	v20070903-0000:1.2
	v20070830-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	v20070621-0000:1.2
	RC3_20:1.2
	v20070605-1400:1.2
	v20070601-1400:1.2
	v20070518-1300:1.2;
locks; strict;
comment	@# @;


1.10
date	2008.04.05.07.34.47;	author aboyko;	state Exp;
branches;
next	1.9;
commitid	57c147f72b964567;

1.9
date	2008.04.04.18.33.19;	author aboyko;	state Exp;
branches;
next	1.8;
commitid	698947f6746f4567;

1.8
date	2008.04.04.18.23.21;	author aboyko;	state Exp;
branches;
next	1.7;
commitid	56a047f672194567;

1.7
date	2008.02.04.21.03.03;	author aboyko;	state Exp;
branches;
next	1.6;
commitid	50f847a77d874567;

1.6
date	2008.01.10.23.02.30;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	6a814786a4064567;

1.5
date	2008.01.03.17.42.57;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	3284477d1ea04567;

1.4
date	2008.01.02.20.06.57;	author aboyko;	state Exp;
branches;
next	1.3;
commitid	5a64477beede4567;

1.3
date	2007.10.19.17.45.12;	author aboyko;	state Exp;
branches;
next	1.2;
commitid	728f4718ed284567;

1.2
date	2007.05.18.14.42.19;	author mmostafa;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	6d5c464dbb4a4567;

1.1
date	2007.05.16.19.47.01;	author mmostafa;	state Exp;
branches;
next	;
commitid	24f4464b5fb34567;

1.2.2.1
date	2008.02.11.21.55.34;	author aboyko;	state Exp;
branches;
next	;
commitid	799147b0c4554567;


desc
@@


1.10
log
@[225793] gmf_head aboyko 080404 BorderItemRectilinearRouter conflicts with RectilinearRouter (improved condition)
@
text
@/******************************************************************************
 * Copyright (c) 2007, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.internal.routers;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.draw2d.AbsoluteBendpoint;
import org.eclipse.draw2d.AnchorListener;
import org.eclipse.draw2d.Bendpoint;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.ConnectionAnchor;
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.LayoutManager;
import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Geometry;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.draw2d.geometry.PrecisionRectangle;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.draw2d.graph.Path;
import org.eclipse.draw2d.graph.ShortestPathRouter;
import org.eclipse.gmf.runtime.draw2d.ui.figures.IBorderItemLocator;
import org.eclipse.gmf.runtime.draw2d.ui.figures.PolylineConnectionEx;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;

/**
 * @@author mmostafa
 *
 * RectilinearRouter which is aware of border items
 * This router, will make sure that it connects to teh correct side of teh border item
 * Also, it willmake sure that it never overlape the border item container
 * 
 */

public class BorderItemRectilinearRouter
    extends RectilinearRouter {

    private static int OFFSET = 15;

    /* (non-Javadoc)
     * @@see org.eclipse.gmf.runtime.draw2d.ui.internal.routers.ObliqueRouter#calculateBendPoints(org.eclipse.draw2d.Connection)
     */
    protected PointList calculateBendPoints(Connection conn) {
        IFigure source = conn.getSourceAnchor().getOwner();
        IFigure target = conn.getTargetAnchor().getOwner();
        PointList bends = super.calculateBendPoints(conn);
        if (source == null || target == null || isAvoidingObstructions(conn) || isClosestDistance(conn)
        		|| bends.size() > 2) {
            // reorient
            return bends;
        }

        int sourcePosition = getBorderFigurePosition(source);
        int targetPosition = getBorderFigurePosition(target);
        
        if (sourcePosition == PositionConstants.NONE && targetPosition == PositionConstants.NONE) {
        	return bends;
        }
        
        PolylineConnectionEx fakeConnection = new PolylineConnectionEx() {

            public void validate() {
                // no need to validate
            }

            public void paintFigure(Graphics graphics) {
                // nothing to paint
            }
        };
        Rectangle sourceParentRect = getObstacle(source, conn, (sourcePosition != PositionConstants.NONE));
        Rectangle targetParentRect = getObstacle(target, conn, (targetPosition != PositionConstants.NONE));
        if (bends.size() == 2
        		&& (sourcePosition == PositionConstants.NONE || (sourcePosition != PositionConstants.NONE && !lineIntersectRectangle(bends.getFirstPoint(), bends.getLastPoint(), sourceParentRect)))
        		&& (targetPosition == PositionConstants.NONE || (targetPosition != PositionConstants.NONE && !lineIntersectRectangle(bends.getFirstPoint(), bends.getLastPoint(), targetParentRect)))) {
           	return bends;
        }
        if (sourceParentRect.contains(targetParentRect)) {
            sourcePosition = reversePosition(sourcePosition);
        } else if (targetParentRect.contains(sourceParentRect)) {
            targetPosition = reversePosition(targetPosition);
        }

        fakeConnection.setSourceAnchor(new BorderItemConnectionAnchor(conn
            .getSourceAnchor(), sourcePosition, OFFSET));
        fakeConnection.setTargetAnchor(new BorderItemConnectionAnchor(conn
            .getTargetAnchor(), targetPosition, OFFSET));

        fakeConnection.setConnectionRouter(conn.getConnectionRouter());
        List originalbendpoints = (ArrayList) conn.getConnectionRouter()
            .getConstraint(conn);
        // protection code to prevent NPE while creating the connection
        if (originalbendpoints == null || originalbendpoints.size() == 0) {
            // reorient
            return bends;
        }

        fakeConnection.setParent(conn.getParent());
        if (conn instanceof PolylineConnectionEx) {
            PolylineConnectionEx connection = (PolylineConnectionEx) conn;
            fakeConnection.setRoutingStyles(connection
                .isClosestDistanceRouting(), connection
                .isAvoidObstacleRouting());
        }
        List constraint = new ArrayList();
        for (Iterator itr = originalbendpoints.iterator(); itr.hasNext();) {
            Bendpoint bp = (Bendpoint) itr.next();
            constraint.add(new AbsoluteBendpoint(bp.getLocation()));
        }
        AbsoluteBendpoint startPoint = (AbsoluteBendpoint) constraint.get(0);
        if (sourcePosition != PositionConstants.NONE) {
            BorderItemConnectionAnchor anchor = (BorderItemConnectionAnchor) fakeConnection
                .getSourceAnchor();
            Point startBendpoint = anchor.getReferencePoint();
            conn.translateToRelative(startBendpoint);
            constraint.remove(0);
            startPoint = new AbsoluteBendpoint(startBendpoint);
            constraint.add(0, startPoint);
        }
        AbsoluteBendpoint endPoint = (AbsoluteBendpoint) constraint
            .get(constraint.size() - 1);
        if (targetPosition != PositionConstants.NONE) {
            BorderItemConnectionAnchor anchor = (BorderItemConnectionAnchor) fakeConnection
                .getTargetAnchor();
            Point endBendpoint = anchor.getReferencePoint();
            conn.translateToRelative(endBendpoint);
            constraint.remove(constraint.size() - 1);
            endPoint = new AbsoluteBendpoint(endBendpoint);
            constraint.add(endPoint);
        }
        avoidOverlappingWithParent(startPoint, endPoint, sourceParentRect,
            targetParentRect, constraint, conn);
        fakeConnection.setRoutingConstraint(constraint);
        PointList points = super.calculateBendPoints(fakeConnection);
        if (sourcePosition != PositionConstants.NONE) {
            BorderItemConnectionAnchor anchor = (BorderItemConnectionAnchor) fakeConnection
                .getSourceAnchor();
            Point startPoint1 = anchor.getAnchorPoint();
            conn.translateToRelative(startPoint1);
            points.insertPoint(startPoint1, 0);
        }

        if (targetPosition != PositionConstants.NONE) {
            BorderItemConnectionAnchor anchor = (BorderItemConnectionAnchor) fakeConnection
                .getTargetAnchor();
            Point endPoint1 = anchor.getAnchorPoint();
            conn.translateToRelative(endPoint1);
            points.addPoint(endPoint1);
        }
        fakeConnection.setParent(null);
        return points;
    }

    /**
     * utility method to revers the position
     * @@param position the position to reverse
     * @@return  teh reversed position
     */
    private int reversePosition(int position) {
        int newPosition = position;
        if (position == PositionConstants.SOUTH)
            newPosition = PositionConstants.NORTH;
        else if (position == PositionConstants.NORTH)
            newPosition = PositionConstants.SOUTH;
        else if (position == PositionConstants.WEST)
            newPosition = PositionConstants.EAST;
        else if (position == PositionConstants.EAST)
            newPosition = PositionConstants.WEST;
        return newPosition;
    }

    /**
     * @@author MMostafa
     *  Border Item aware Anchor, this anchor will make sure that the anchor point
     *  and the reference point are on the correct side
     */
    private class BorderItemConnectionAnchor
        implements ConnectionAnchor {

        private ConnectionAnchor anchor;

        private int position;

        private int offset;

        public BorderItemConnectionAnchor(ConnectionAnchor anchor,
                int position, int offset) {
            this.anchor = anchor;
            this.position = position;
            this.offset = offset;
        }

        public void setPosition(int position) {
            this.position = position;
        }

        public Point getReferencePoint() {
            Point referencePoint = getAnchorPoint();
            if (position == PositionConstants.SOUTH)
                referencePoint.y += offset;
            else if (position == PositionConstants.NORTH)
                referencePoint.y -= offset;
            else if (position == PositionConstants.WEST)
                referencePoint.x -= offset;
            else if (position == PositionConstants.EAST)
                referencePoint.x += offset;
            return referencePoint;
        }

        public Point getAnchorPoint() {
            Rectangle ownerBounds = getOwner().getBounds().getCopy();
            getOwner().translateToAbsolute(ownerBounds);
            if (position == PositionConstants.SOUTH)
                return ownerBounds.getBottom();
            else if (position == PositionConstants.NORTH)
                return ownerBounds.getTop();
            else if (position == PositionConstants.WEST)
                return ownerBounds.getLeft();
            else if (position == PositionConstants.EAST)
                return ownerBounds.getRight();
            return ownerBounds.getCenter();
        }

        public void addAnchorListener(AnchorListener listener) {
            // nothing to do
        }

        public Point getLocation(Point reference) {
            return reference;
        }

        public IFigure getOwner() {
            return anchor.getOwner();
        }

        public void removeAnchorListener(AnchorListener listener) {
            // nothing to do
        }

        public ConnectionAnchor getAnchor() {
            return anchor;
        }

    }

    /**
     * Returns the position of the border item with respect to its parent
     * Clients can override this method to change the way postions is
     * calculated for border items
     * @@param borderFigure  Figure to use to get the position
     * @@return  the border item position, see <code>PositionConstants</code>
     */
    protected int getBorderFigurePosition(IFigure borderFigure) {
        IFigure child = borderFigure;
        IFigure parent = borderFigure.getParent();
        if (parent != null && parent.getLayoutManager() != null) {
            LayoutManager layoutManager = parent.getLayoutManager();
            Object layoutConstraint = layoutManager.getConstraint(child);
            if (layoutConstraint instanceof IBorderItemLocator) {
                return ((IBorderItemLocator) layoutConstraint)
                    .getCurrentSideOfParent();
            }
        }
        return PositionConstants.NONE;
    }
    
    

    /**
     * Utility method that adjust the constrinat to avoid overlapping with 
     * Source or target parents, this method should be called only in case
     * of routing connections connecting to border items 
     * @@param startPoint        start point or the route
     * @@param endPoint          end point of the route
     * @@param sourceParentRect  the rectangle of the source element parent
     * @@param targetParentRect  the rectangle of the target element parent
     * @@param constraint        the constraint to modify
     * @@param conn              the connection to route
     */
    private void avoidOverlappingWithParent(AbsoluteBendpoint startPoint,
            AbsoluteBendpoint endPoint, Rectangle sourceParentRect,
            Rectangle targetParentRect, List constraint, Connection conn) {
        if (sourceParentRect.intersects(targetParentRect)) {
            return;
        }
        IMapMode mapMode = MapModeUtil.getMapMode(conn);
        int logicalOffset = mapMode.DPtoLP(OFFSET);
        // use GEF's shortest path router to get reference bend points
        ShortestPathRouter router = new ShortestPathRouter();
        Path path = new Path(startPoint, endPoint);
        router.addPath(path);
        router.addObstacle(sourceParentRect);
        router.addObstacle(targetParentRect);
        router.setSpacing(logicalOffset);
        router.solve();
        PointList points = path.getPoints();
        // remove the start and end points
        points.removePoint(0);
        points.removePoint(points.size() - 1);
        // deal with the remaining points
        if (points.size() > 0) {
            Point refrencePoint = points.getFirstPoint();
            AbsoluteBendpoint startPointGuidePoint = new AbsoluteBendpoint(startPoint);
            adjustPointUsingReferencePointAndObstacle(startPointGuidePoint,refrencePoint,sourceParentRect,  logicalOffset);
            constraint.add(1, startPointGuidePoint);
            points.removePoint(0);
            // this means we had only one reference point, we will use this point
            // to adjust poth source and target
            if (points.size() == 0) {
                AbsoluteBendpoint endPointGuidePoint = new AbsoluteBendpoint(endPoint);
                adjustPointUsingReferencePointAndObstacle(endPointGuidePoint,refrencePoint,targetParentRect,  logicalOffset);
                if (endPointGuidePoint.y == endPoint.y)
                    endPointGuidePoint.x = startPointGuidePoint.x;
                else
                    endPointGuidePoint.y = startPointGuidePoint.y;
                constraint.add(2, endPointGuidePoint);
            }
        }
        if (points.size() > 0) {
            Point referencePoint = points.getLastPoint();
            AbsoluteBendpoint endPointGuidePoint = new AbsoluteBendpoint(endPoint);
            adjustPointUsingReferencePointAndObstacle(endPointGuidePoint,referencePoint,targetParentRect , logicalOffset);
            constraint.add(constraint.size() - 1, endPointGuidePoint);
        }
    }

    /**
     * Modify a guide point based on a reference point to avoid collision with the
     * passed obstacle, the offset had to be in logical coordinates
     * @@param guidePoint, the point to adjust
     * @@param referencePoint, reference point to use during the adjust process
     * @@param obstacle, obstable to consider
     * @@param offSet, the offset had to be in logical coordinate
     */
    private void adjustPointUsingReferencePointAndObstacle(AbsoluteBendpoint guidePoint, Point referencePoint,
            Rectangle obstacle, int offSet ) {
        // check if the y of the starting point is in the rectangle range (point
        // will be west or east or the rectangle)
        boolean changeY = (guidePoint.y >= obstacle.y && guidePoint.y <= (obstacle.y + obstacle.height));

        if (changeY) {
            if (referencePoint.y < guidePoint.y)
                guidePoint.y = obstacle.y - offSet;
            else
                guidePoint.y = obstacle.y + obstacle.height
                    + offSet;
        } else {
            if (referencePoint.x < guidePoint.x)
                guidePoint.x = obstacle.x - offSet;
            else
                guidePoint.x = obstacle.x + obstacle.width
                    + offSet;
        }
    }

    /**
     * Returns the obstacle that the route should try to avoid, for example if the isBordereItem 
     * flag is ON, it will return the rectangle of the border item parent.
     * This method can be overriden by clients to provide a client specific way to find the obstacle
     * @@param figure, figure to get the obstacle for
     * @@param conn, the connection the router is routing
     * @@param isBorderItem, indicates if the passed figure is a border item figrue or not
     * @@return obstacle
     */
    protected Rectangle getObstacle(IFigure figure, Connection conn,
            boolean isBorderItem) {
        IFigure parent = null;
        if (isBorderItem)
            parent = getBorderItemParent(figure);
        else
            parent = figure;
        Rectangle rect = new PrecisionRectangle(parent.getBounds());
        parent.translateToAbsolute(rect);
        conn.translateToRelative(rect);
        return rect;
    }

    /**
     * return the parent of a border item figure
     * clients can override this method to find the 
     * @@param figure, the border item figure
     * @@return teh parent of the border item
     */
    protected IFigure getBorderItemParent(IFigure figure) {
        return figure.getParent().getParent();
    }
    
    private boolean lineIntersectRectangle(Point start, Point end, Rectangle rect) {
    	return Geometry.linesIntersect(start.x, start.y, end.x, end.y, rect.x, rect.y, rect.x + rect.width, rect.y)
    		|| Geometry.linesIntersect(start.x, start.y, end.x, end.y, rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height)
    		|| Geometry.linesIntersect(start.x, start.y, end.x, end.y, rect.x + rect.width, rect.y + rect.height, rect.x, rect.y + rect.height)
    		|| Geometry.linesIntersect(start.x, start.y, end.x, end.y, rect.x, rect.y + rect.height, rect.x, rect.y);
    }
}
@


1.9
log
@[225793] gmf_head aboyko 080404 BorderItemRectilinearRouter conflicts with RectilinearRouter
@
text
@d85 4
a88 7
        if (bends.size() == 2) {
        	if (sourcePosition != PositionConstants.NONE && !lineIntersectRectangle(bends.getFirstPoint(), bends.getLastPoint(), sourceParentRect)) {
        		return bends;
        	}
        	if (targetPosition != PositionConstants.NONE && !lineIntersectRectangle(bends.getFirstPoint(), bends.getLastPoint(), targetParentRect)) {
            	return bends;
        	}
@


1.8
log
@[225793] gmf_head aboyko 080404 BorderItemRectilinearRouter conflicts with RectilinearRouter
@
text
@d85 7
a91 3
        if (bends.size() == 2 && !lineIntersectRectangle(bends.getFirstPoint(), bends.getLastPoint(), sourceParentRect)
        		&& !lineIntersectRectangle(bends.getFirstPoint(), bends.getLastPoint(), targetParentRect)) {
        	return bends;
@


1.7
log
@[217749] gmf_head aboyko 080204 [Layout] Layout providers using Draw2D graph layout don't deliver the exact results to the diagram
@
text
@d27 1
d30 1
d59 1
d61 1
a61 1
        		|| super.calculateBendPoints(conn).size() > 2) {
d63 1
a63 1
            return super.calculateBendPoints(conn);
d70 1
a70 1
        	return super.calculateBendPoints(conn);
d85 4
d106 1
a106 1
            return super.calculateBendPoints(conn);
d383 1
a383 1
        Rectangle rect = parent.getBounds().getCopy();
d398 7
@


1.6
log
@Commit back [194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d2 1
a2 1
 * Copyright (c) 2007 IBM Corporation and others.
d65 5
@


1.5
log
@Roll back fix to bug 194482 (to be committed in M5)
@
text
@d57 2
a58 1
        if (source == null || target == null || isAvoidingObstructions(conn) || isClosestDistance(conn)) {
@


1.4
log
@[194482] gmf_head aboyko 080102 [Connections] Unexpected behavior while moving the end point of a rectilinear connection
@
text
@d57 1
a57 2
        if (source == null || target == null || isAvoidingObstructions(conn) || isClosestDistance(conn)
        		|| super.calculateBendPoints(conn).size() > 2) {
@


1.3
log
@[206763] gmf_HEAD aboyko 071019 BorderItemRectilinearRouter throws IndexOutOfBoundsException
@
text
@d57 2
a58 1
        if (source == null || target == null || isAvoidingObstructions(conn) || isClosestDistance(conn)) {
@


1.2
log
@*** empty log message ***
@
text
@d91 1
a91 1
        if (originalbendpoints == null) {
@


1.2.2.1
log
@[218567] gmf_R2_maintenance aboyko 080211 BorderItemRectilinearRouter fixes from HEAD need to go in R2_maintenance too
@
text
@d2 1
a2 1
 * Copyright (c) 2007, 2008 IBM Corporation and others.
d57 1
a57 2
        if (source == null || target == null || isAvoidingObstructions(conn) || isClosestDistance(conn)
        		|| super.calculateBendPoints(conn).size() > 2) {
a63 5
        
        if (sourcePosition == PositionConstants.NONE && targetPosition == PositionConstants.NONE) {
        	return super.calculateBendPoints(conn);
        }
        
d91 1
a91 1
        if (originalbendpoints == null || originalbendpoints.size() == 0) {
@


1.1
log
@[187341] gmf_head mmostafa 070516 Rectilinear router does not consider Border Items
@
text
@d57 1
a57 1
        if (source == null || target == null) {
d253 1
a253 1
        IFigure parent = borderFigure.getParent().getParent();
@

