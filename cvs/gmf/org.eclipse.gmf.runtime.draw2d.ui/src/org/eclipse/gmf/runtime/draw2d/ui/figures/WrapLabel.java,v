head	1.14;
access;
symbols
	v20081023-2107:1.14
	v20081022-1925:1.14
	v20081021-1810:1.14
	v20081020-0700:1.14
	v20080911-1728:1.14
	v20080911-1506:1.14
	v20080910-1520:1.14
	v20080910-1510:1.14
	v20080903-1520:1.14
	v20080903-1510:1.14
	v20080722-1827:1.14
	R2_1_maintenance:1.14.0.2
	Root_R2_1_maintenance:1.14
	R2_1_0:1.14
	v20080610-1132:1.14
	v20080603-1553:1.14
	v20080512-1200:1.14
	v20080503-1740:1.14
	v20080501-1739:1.14
	v20080425-1959:1.14
	v20080417-1610:1.14
	v20080407-2250:1.14
	v20080407-0930:1.14
	v20080404-1111:1.14
	v20080222-1200:1.14
	v20080215-1500:1.14
	v20080215-1200:1.13
	v20080201-2010:1.14
	v20080114-1111:1.14
	v20071108-0000:1.14
	v20071003-0000:1.13
	v20070928-0000:1.13
	v20070915-0000:1.13
	v20070903-0000:1.13
	v20070830-0000:1.13
	v20070809-0000:1.13
	R2_0_maintenance:1.13.0.2
	R2_0:1.13
	R4_20:1.13
	v20070621-0000:1.13
	RC3_20:1.13
	v20070605-1400:1.13
	v20070601-1400:1.12
	v20070518-1300:1.11
	v20070330-1300:1.11
	v20070221-1500:1.11
	v20070208-1800:1.11
	v20070202-0200:1.9.2.3
	M4_20:1.11
	v20061218-1200:1.11
	v20061214-0000:1.11
	M3_20:1.10
	v20061013-1330:1.10
	v20060925-1700:1.9.2.3
	v20060919-0800:1.9.2.2
	M1_20:1.9
	v20060824-1600:1.9.2.1
	v20060817-1500:1.9.2.1
	v20060810-1700:1.9.2.1
	v20060803-1200:1.9.2.1
	v20060728-0500:1.9
	v20060721-1130:1.9
	v20060713-1700:1.9
	R1_0_maintenance:1.9.0.2
	R1_0:1.9
	v20060627-1200:1.9
	v20060616-1200:1.9
	v20060609-1400:1.9
	v20060531-1730:1.8
	v20060519-0800:1.8
	RC2_10:1.8
	I20060505-1400:1.7
	I20060428-1300:1.6
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.6
	I20060324-0300:1.6
	I20060317-1300:1.6
	I20060317-1200:1.6
	I20060316-1300:1.6
	I20060309-1300:1.6
	M5_10:1.6
	S20060303-1600:1.6
	I20060227-1730:1.6
	I20060216-1945:1.6
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.6
	I20060129-1145:1.6
	I20060127-0900:1.6
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051208-2000:1.4
	I20051201-1800:1.4
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.3;
locks; strict;
comment	@# @;


1.14
date	2007.10.16.14.12.15;	author crevells;	state Exp;
branches;
next	1.13;
commitid	2c374714c6be4567;

1.13
date	2007.06.01.15.56.04;	author mmostafa;	state Exp;
branches;
next	1.12;
commitid	332e466041934567;

1.12
date	2007.05.31.19.12.06;	author mmostafa;	state Exp;
branches;
next	1.11;
commitid	6d0f465f1e054567;

1.11
date	2006.11.24.20.12.40;	author crevells;	state Exp;
branches;
next	1.10;
commitid	5c3e456752384567;

1.10
date	2006.10.03.15.04.52;	author ahunter;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.05.18.20.39;	author mmostafa;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2006.05.05.20.39.50;	author mmostafa;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.03.18.25.43;	author mmostafa;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.26.15.37.27;	author ahunter;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.12.15.47.56;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.04.21.27.59;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.11.21.36.26;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.27.42;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.49;	author sshaw;	state Exp;
branches;
next	;

1.9.2.1
date	2006.07.31.18.07.51;	author sshaw;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2006.09.13.16.46.18;	author ahunter;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2006.09.19.19.09.21;	author cmahoney;	state Exp;
branches;
next	;


desc
@@


1.14
log
@[162932] gmf_head crevells 071016 [NoteTextLabel] WrapLabel should use Gef's text layout
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2007 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.figures;

import org.eclipse.draw2d.FigureUtilities;
import org.eclipse.draw2d.IFigure;
import org.eclipse.draw2d.geometry.Dimension;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.Rectangle;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.FontMetrics;
import org.eclipse.swt.graphics.Image;

import com.ibm.icu.text.BreakIterator;
import com.ibm.icu.util.StringTokenizer;

/**
 * An extended label that has the following extra features:
 * 
 * 1- It is capable of showing selection and focus feedback (primary or
 * secondary) 2- It is capable of optionally underlining the label's text 3- It
 * is capable of wrapping the label's text at a given width with a given
 * alignment 4- It is capable of supporting multiple label icons (temporary
 * feature)
 * 
 * This class was originally deriving off Draw2d's <code>Label</code> class
 * but with the introduction of the auto-wrapping feature, a copy had to be made
 * overriding was not straightforward. Hopefully, this extended version can be
 * pushed to opensource
 * 
 * <p>
 * Code taken from Eclipse reference bugzilla #98820
 * 
 * @@author melaasar, crevells
 * @@deprecated This class has been deprecated and may be removed in the future.
 *             Use <code>WrappingLabel</code> instead. This class now extends
 *             from <code>WrappingLabel</code> so the behavior should be the
 *             same. If client code is calling one of the methods on
 *             <code>WrapLabel</code> that no longer exists, evaluate whether
 *             this is necessary or not.
 */
public class WrapLabel
    extends WrappingLabel {

    /** the label's text used in painting after applying required styles */
    private String subStringText;

    /**
     * Construct an empty Label.
     * 
     * @@since 2.0
     */
    public WrapLabel() {
        super();
    }

    /**
     * Construct a Label with passed String as its text.
     * 
     * @@param s
     *            the label text
     * @@since 2.0
     */
    public WrapLabel(String s) {
        super(s);
 
        // Compensate for the fact that the original wraplabel never called the
        // default constructor to set the default layout values.
        setTextWrapAlignment(CENTER);
    }

    /**
     * Construct a Label with passed Image as its icon.
     * 
     * @@param i
     *            the label image
     * @@since 2.0
     */
    public WrapLabel(Image i) {
        super(i);
        
        // Compensate for the fact that the original wraplabel never called the
        // default constructor to set the default layout values.
        setTextWrapAlignment(CENTER);
    }

    /**
     * Construct a Label with passed String as text and passed Image as its
     * icon.
     * 
     * @@param s
     *            the label text
     * @@param i
     *            the label image
     * @@since 2.0
     */
    public WrapLabel(String s, Image i) {
        super(s, i);
        
        // Compensate for the fact that the original wraplabel never called the
        // default constructor to set the default layout values.
        setTextWrapAlignment(CENTER);
    }

    /**
     * Calculates the size of the Label's text size. The text size calculated
     * takes into consideration if the Label's text is currently truncated. If
     * text size without considering current truncation is desired, use
     * {@@link #calculateTextSize(int, int)}.
     * 
     * @@return the size of the label's text, taking into account truncation
     * @@since 2.0
     * @@deprecated If this behavior is required then a request can be made (with
     *             justification) for the WrappingLabel.
     */
    protected Dimension calculateSubStringTextSize() {
        Font f = getFont();
		return getTextExtents(getSubStringText(), f, getFigureMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight())); 
    }

    /**
     * Calculates and returns the size of the Label's text. Note that this
     * Dimension is calculated using the Label's full text, regardless of
     * whether or not its text is currently truncated. If text size considering
     * current truncation is desired, use {@@link #calculateSubStringTextSize()}.
     * 
	 * @@param wHint a width hint
	 * @@param hHint a height hint
     * @@return the size of the label's text, ignoring truncation
     * @@since 2.0
     * @@deprecated If this behavior is required then a request can be made (with
     *             justification) for the WrappingLabel.
     */
    protected Dimension calculateTextSize(int wHint, int hHint) {
        return getTextFlow().getPreferredSize(wHint, hHint);
    }

    /**
     * Returns the bounds of the Label's icon.
     * 
     * @@return the icon's bounds
     * @@since 2.0
     * @@deprecated The icon location can be retrieved with
     *             {@@link #getIconLocation()} and the icon(s) size can be
     *             retrieved with {@@link #getTotalIconSize()}.
     */
    public Rectangle getIconBounds() {
        if (hasIcons()) {
            return new Rectangle(getBounds().getLocation().translate(
                getIconLocation()), getTotalIconSize());
        }
        return new Rectangle(0, 0, 0, 0);
    }

    /**
     * Calculates the amount of the Label's current text will fit in the Label,
     * including an elipsis "..." if truncation is required.
     * 
     * @@return the substring
     * @@since 2.0
     * @@deprecated If this behavior is required then a request can be made (with
     *             justification) for the WrappingLabel.
     */
    public String getSubStringText() {
        if (subStringText != null)
            return subStringText;

        String theText = getText();
        int textLen = theText.length();
        if (textLen == 0) {
            return subStringText = "";//$NON-NLS-1$;;
        }
        Dimension size = getSize();
        Dimension shrink = getPreferredSize(size.width, size.height)
            .getDifference(size);
        Dimension effectiveSize = getTextSize().getExpanded(-shrink.width,
            -shrink.height);

        if (effectiveSize.height == 0) {
            return subStringText = "";//$NON-NLS-1$;
        }

        Font f = getFont();
        FontMetrics metrics = FigureUtilities.getFontMetrics(f);
        IMapMode mm = getFigureMapMode();
        int fontHeight = mm.DPtoLP(metrics.getHeight());
        int charAverageWidth = mm.DPtoLP(metrics.getAverageCharWidth());
        int maxLines = (int) (effectiveSize.height / (double) fontHeight);
        if (maxLines == 0) {
            return subStringText = "";//$NON-NLS-1$
        }

        StringBuffer accumlatedText = new StringBuffer();
        StringBuffer remainingText = new StringBuffer(theText);

        int effectiveSizeWidth = effectiveSize.width;
        int widthHint = Math.max(effectiveSizeWidth
            - getTruncationStringSize().width, 0);
        int i = 0, j = 0;
        while (remainingText.length() > 0 && j++ < maxLines) {
            i = getLineWrapPosition(remainingText.toString(), f,
                effectiveSizeWidth, fontHeight);

            if (accumlatedText.length() > 0)
                accumlatedText.append('\n');

            if (i == 0 || (remainingText.length() > i && j == maxLines)) {
                i = getLargestSubstringConfinedTo(remainingText.toString(), f,
                    widthHint, fontHeight, charAverageWidth);
                accumlatedText.append(remainingText.substring(0, i));
                accumlatedText.append(getEllipse());
            } else
                accumlatedText.append(remainingText.substring(0, i));
            remainingText.delete(0, i);
        }
        return subStringText = accumlatedText.toString();
    }

    /**
     * Returns the size of the Label's current text. If the text is currently
     * truncated, the truncated text with its ellipsis is used to calculate the
     * size.
     * 
     * @@return the size of this label's text, taking into account truncation
     * @@since 2.0 
     * @@deprecated If this behavior is required then a request can be made (with
     *             justification) for the WrappingLabel.
     */
    protected Dimension getSubStringTextSize() {
        return calculateSubStringTextSize();
    }

    /**
     * Returns the location of the label's text relative to the label.
     * 
     * @@return the text location
     * @@since 2.0
     * @@deprecated Use <code>getTextBounds().getLocation()</code> instead.
     */
    protected Point getTextLocation() {
        return getTextBounds().getLocation();
    }

    /**
     * Returns the size of the label's complete text. Note that the text used to
     * make this calculation is the label's full text, regardless of whether the
     * label's text is currently being truncated and is displaying an ellipsis.
     * If the size considering current truncation is desired, call
     * {@@link #getSubStringTextSize()}.
     * 
     * @@param wHint
     *            a width hint
     * @@param hHint
     *            a height hint
     * @@return the size of this label's complete text
     * @@since 2.0
     * @@deprecated If this behavior is required then a request can be made (with
     *             justification) for the WrappingLabel.
     */
    protected Dimension getTextSize(int wHint, int hHint) {
        return getTextFlow().getPreferredSize(wHint, hHint);
    }

    /**
     * Gets the text size given the current size as a width hint
     */
    private final Dimension getTextSize() {
        Rectangle r = getBounds();
        return getTextSize(r.width, r.height);
    }

    /**
     * @@see IFigure#invalidate()
     */
    public void invalidate() {
        subStringText = null;
        super.invalidate();
    }

    /**
     * Returns <code>true</code> if the label's text is currently truncated
     * and is displaying an ellipsis, <code>false</code> otherwise.
     * 
     * @@return <code>true</code> if the label's text is truncated
     * @@since 2.0
     * @@deprecated If this behavior is required then a request can be made (with
     *             justification) for the WrappingLabel.
     */
    public boolean isTextTruncated() {
        return !getSubStringTextSize().equals(getTextSize());
    }

    /**
     * Return the ellipse string.
     * 
     * @@return the <code>String</code> that represents the fact that the text
     *         has been truncated and that more text is available but hidden.
     *         Usually this is represented by "...".
     *         @@deprecated Renamed to {@@link #getTruncationString()}
     */
    protected String getEllipse() {
        return ELLIPSIS;
    }
    
    protected String getTruncationString() {
        if (getEllipse() != null) {
            return getEllipse();
        }
        return ELLIPSIS;
    }

    /**
     * @@return whether the label text wrap is on
     * @@deprecated Use {@@link #isTextWrapOn()} instead. This method was renamed
     *             because it never indicated if the text was actually wrapped,
     *             but whether text wrapping was turned on in the label.
     */
    public boolean isTextWrapped() {
        return isTextWrapOn();
    }

    /**
     * Sets the wrapping width of the label text. This is only valid if text
     * wrapping is turned on
     * 
     * @@param i
     *            The label text wrapping width
     * @@deprecated this method was empty and never called
     */
    public void setTextWrapWidth(int i) {
        // do nothing
    }

    /**
     * Sets the wrapping width of the label text. This is only valid if text
     * wrapping is turned on
     * 
     * @@param i
     *            The label text wrapping width
     * @@deprecated Call {@@link #setTextJustification(int)} and
     *             {@@link #setAlignment(int)} instead. This method was somewhat
     *             controlling text justification and label alignment, but they
     *             are really two independent settings. Previously,
     *             setTextWrapAlignment(CENTER) would not only center-justifies
     *             the text, but also put the label in the center. Now, you need
     *             to call {@@link #setTextJustification(int)} to justify the
     *             text (this only affects text when it is wrapped) and
     *             {@@link #setAlignment(int)} to position the text correctly in
     *             the label. If you want the text in the center of the label
     *             than call <code>setAlignment(PositionConstants.CENTER)</code>.
     *             Look at the implementation of this method to see how your
     *             code needs to be migrated.
     */
    public void setTextWrapAlignment(int i) {
        setTextJustification(i);

        // The old WrapLabel's Text Wrap Alignment (i.e. justification) and
        // Label Alignment did not work properly. They worked together
        // previously so we need to compensate for this here.
        switch (i) {
            case LEFT:
                 setAlignment(TOP | LEFT);
                break;
            case CENTER:
                setAlignment(TOP);
                break;
            case RIGHT:
                setAlignment(TOP | RIGHT);
                break;
            default:
                break;
        }
    }

    /**
     * @@deprecated This never worked properly anyways. Call
     *             {@@link #setAlignment(int)} instead to position the icon and
     *             text within the label.
     */
    public void setLabelAlignment(int alignment) {
        // setLabelAlignment() never worked properly instead the label alignment
        // seemed to be based on the text justification. Therefore, if it was
        // set it will be ignored.
    }

    /**
     * @@return the label text wrapping width
     * @@deprecated Renamed to {@@link #getTextJustification()}
     */
    public int getTextWrapAlignment() {
        return getTextJustification();
    }

    /**
     * returns the position of last character within the supplied text that will
     * fit within the supplied width.
     * 
     * @@param s
     *            a text string
     * @@param f
     *            font used to draw the text string
     * @@param w
     *            width in pixles.
     * @@param fontHeight
     *            int <b>mapped already to logical units</b>.
     */
    private int getLineWrapPosition(String s, Font f, int w, int fontHeight) {
        if (getTextExtents(s, f, fontHeight).width <= w) {
            return s.length();
        }
        // create an iterator for line breaking positions
        BreakIterator iter = BreakIterator.getLineInstance();
        iter.setText(s);
        int start = iter.first();
        int end = iter.next();

        // if the first line segment does not fit in the width,
        // determine the position within it where we need to cut
        if (getTextExtents(s.substring(start, end), f, fontHeight).width > w) {
            iter = BreakIterator.getCharacterInstance();
            iter.setText(s);
            start = iter.first();
        }

        // keep iterating as long as width permits
        do
            end = iter.next();
        while (end != BreakIterator.DONE
            && getTextExtents(s.substring(start, end), f, fontHeight).width <= w);
        return (end == BreakIterator.DONE) ? iter.last()
            : iter.previous();
    }

    /**
     * Returns the largest substring of <i>s </i> in Font <i>f </i> that can be
     * confined to the number of pixels in <i>availableWidth <i>.
     * 
     * @@param s
     *            the original string
     * @@param f
     *            the font
     * @@param w
     *            the available width
     * @@param fontHeight
     *            int <b>mapped already to logical units</b>.
     * @@param charAverageWidth
     *            int <b>mapped already to logical units</b>.
     * @@return the largest substring that fits in the given width
     * @@since 2.0
     */
    private int getLargestSubstringConfinedTo(String s, Font f, int w,
            int fontHeight, int charAverageWidth) {
        float avg = charAverageWidth;
        int min = 0;
        int max = s.length() + 1;

        // The size of the current guess
        int guess = 0, guessSize = 0;
        while ((max - min) > 1) {
            // Pick a new guess size
            // New guess is the last guess plus the missing width in pixels
            // divided by the average character size in pixels
            guess = guess + (int) ((w - guessSize) / avg);

            if (guess >= max)
                guess = max - 1;
            if (guess <= min)
                guess = min + 1;

            // Measure the current guess
            guessSize = getTextExtents(s.substring(0, guess), f, fontHeight).width;

            if (guessSize < w)
                // We did not use the available width
                min = guess;
            else
                // We exceeded the available width
                max = guess;
        }
        return min;
    }

    /**
     * Gets the tex extent scaled to the mapping mode
     */
    private Dimension getTextExtents(String s, Font f, int fontHeight) {
        if (s.length() == 0) {
            return getMapModeConstants().dimension_nDPtoLP_0;
        } else {
            // height should be set using the font height and the number of
            // lines in the string
            Dimension d = FigureUtilities.getTextExtents(s, f);
            IMapMode mapMode = getFigureMapMode();
            d.width = mapMode.DPtoLP(d.width);
            d.height = fontHeight * new StringTokenizer(s, "\n").countTokens();//$NON-NLS-1$
            return d;
        }
    }

}@


1.13
log
@[190079] gmf_head mmostafa 070531 WrapLabel's  center alignment  makes text cuf-off
@
text
@a13 7
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Map;
import java.util.WeakHashMap;

import org.eclipse.draw2d.ColorConstants;
import org.eclipse.draw2d.Figure;
d15 1
a15 3
import org.eclipse.draw2d.Graphics;
import org.eclipse.draw2d.LayoutManager;
import org.eclipse.draw2d.PositionConstants;
a16 1
import org.eclipse.draw2d.geometry.Insets;
a18 2

import org.eclipse.gmf.runtime.draw2d.ui.internal.mapmode.IMapModeHolder;
a19 1
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
a26 1

d44 7
a50 1
 * @@author melaasar
d53 1
a53 6
	extends Figure
	implements PositionConstants {	

	private static final String _ellipse = "..."; //$NON-NLS-1$

	private static final Dimension EMPTY_DIMENSION = new Dimension(0, 0);
d55 2
a56 1
	private static final Map mapModeConstantsMap = new WeakHashMap();
d58 70
a127 589
	private static class MapModeConstants {

		private static final int MAX_IMAGE_INFO = 12;

		public final WeakReference mapModeRef;

		public final int nDPtoLP_3;

		public final int nDPtoLP_2;

		public final int nDPtoLP_0;

		public final Dimension dimension_nDPtoLP_0;

		public final WeakHashMap fontToEllipseTextSize = new WeakHashMap();

		public final SingleIconInfo[] singleIconInfos = new SingleIconInfo[MAX_IMAGE_INFO];

		public MapModeConstants(IMapMode mapMode) {
			this.mapModeRef = new WeakReference(mapMode);
			nDPtoLP_2 = mapMode.DPtoLP(2);
			nDPtoLP_3 = mapMode.DPtoLP(3);
			nDPtoLP_0 = mapMode.DPtoLP(0);
			dimension_nDPtoLP_0 = new Dimension(nDPtoLP_0, nDPtoLP_0);
		}

		public Dimension getEllipseTextSize(Font f) {
			Dimension d = (Dimension) fontToEllipseTextSize.get(f);
			if (d == null) {
				IMapMode mapMode = (IMapMode) mapModeRef.get();
				d = FigureUtilities.getTextExtents(_ellipse, f);
				d.height = FigureUtilities.getFontMetrics(f).getHeight();
				d = new Dimension(mapMode.DPtoLP(d.width), mapMode
					.DPtoLP(d.height));
				fontToEllipseTextSize.put(f, d);
			}
			return d;
		}

		public SingleIconInfo getSingleIconInfo(Image image) {
			if (image == null) {
				return SingleIconInfo.NULL_INFO;
			}
			SingleIconInfo info;
			for (int i = 0; i < MAX_IMAGE_INFO; ++i) {
				info = singleIconInfos[i];
				if (info == null) {
					info = new SingleIconInfo(image);
					singleIconInfos[i] = info;
					return info;
				}
				if (info.icon == image) {
					return info;
				}
			}
			int index = SingleIconInfo.count % MAX_IMAGE_INFO;
			info = new SingleIconInfo(image);
			singleIconInfos[index] = info;
			return info;
		}
	}

	// reserve 1 bit
	private static int FLAG_SELECTED = MAX_FLAG << 1;

	private static int FLAG_HASFOCUS = MAX_FLAG << 2;

	private static int FLAG_UNDERLINED = MAX_FLAG << 3;

	private static int FLAG_STRIKEDTHROUGH = MAX_FLAG << 4;

	private static int FLAG_WRAP = MAX_FLAG << 5;

	// reserve 3 bits
	private static int FLAG_TEXT_ALIGN = MAX_FLAG << 6;

	private static int FLAG_WRAP_ALIGN = MAX_FLAG << 9;

	private static int FLAG_ICON_ALIGN = MAX_FLAG << 12;

	private static int FLAG_LABEL_ALIGN = MAX_FLAG << 15;

	private static int FLAG_TEXT_PLACEMENT = MAX_FLAG << 18;

	private MapModeConstants mapModeConstants;

	/** the original label's text */
	private String text;

	/** the label's text used in painting after applying required styles */
	private String subStringText;

	/** the size of text */
	private Dimension textSize;	

	private Dimension ellipseTextSize;

	/** the location of text */
	private Point textLocation;

	/** the cached hint used to calculate text size */
	private int cachedPrefSizeHint_width;

	private int cachedPrefSizeHint_height;

	/** the icon location */
	private Point iconLocation;

	private static abstract class IconInfo {
		/**
		 * Gets the icon at the index location.
		 * 
		 * @@param i
		 *            the index to retrieve the icon of
		 * @@return <code>Image</code> that corresponds to the given index.
		 */
		public abstract Image getIcon(int i);
		
		/**
		 * Gets the icon size of the icon at the given index.
		 * 
		 * @@param i
		 * @@return the <code>Dimension</code> that is the size of the icon at
		 *         the given index.
		 */
		public abstract Dimension getIconSize(IMapMode mapMode, int i);

		/**
		 * @@return the number of icons
		 */
		public abstract int getNumberofIcons();
		
		/**
		 * @@return the <code>Dimension</code> that is the total size of all
		 *         the icons.
		 */
		public abstract Dimension getTotalIconSize(IMapMode mapMode);

		public abstract void invalidate();
		
		/**
		 * Sets the icon at the index location.
		 * 
		 * @@param icon
		 * @@param i
		 */
		public abstract void setIcon(Image icon, int i);
		
		/**
		 * 
		 */
		public abstract int getMaxIcons();

	}	

	private static class SingleIconInfo
		extends IconInfo {	

		static int count;
		
		public static final SingleIconInfo NULL_INFO = new SingleIconInfo(){
			public int getNumberofIcons() {
				return 0;
			}
		};

		final Image icon;

		/** total icon size */
		private Dimension totalIconSize;

		private SingleIconInfo() {
			icon = null;//don't increment count, used only for NULL_INFO
		}

		public SingleIconInfo(Image icon) {
			this.icon = icon;
			++count;
		}

		public final int getMaxIcons() {
			return 1;
		}

		
		public Image getIcon(int i) {
			if (i == 0) {
				return icon;
			} else if (i > 0) {
				return null;
			}
			throw new IndexOutOfBoundsException();
		}

		
		public void setIcon(Image img, int i) {
			throw new UnsupportedOperationException();
		}

		
		public Dimension getIconSize(IMapMode mapMode, int i) {
			if (i == 0) {
				return getTotalIconSize(mapMode);
			}

			throw new IndexOutOfBoundsException();
		}

		
		public int getNumberofIcons() {
			return 1;
		}

		
		public Dimension getTotalIconSize(IMapMode mapMode) {
			if (totalIconSize != null)
				return totalIconSize;

			if (icon != null && !icon.isDisposed()) {
				org.eclipse.swt.graphics.Rectangle imgBounds = icon.getBounds();
				totalIconSize = new Dimension(mapMode.DPtoLP(imgBounds.width),
					mapMode.DPtoLP(imgBounds.height));
			} else {
				totalIconSize = EMPTY_DIMENSION;
			}

			return totalIconSize;
		}

		
		public void invalidate() {
			totalIconSize = null;
		}

	}

	private static class MultiIconInfo
		extends IconInfo {

		/** the label icons */
		private ArrayList icons = new ArrayList(2);

		/** total icon size */
		private Dimension totalIconSize;

		public MultiIconInfo() {
			super();
		}

		public int getMaxIcons() {
			return -1;
		}

		/**
		 * Gets the icon at the index location.
		 * 
		 * @@param i
		 *            the index to retrieve the icon of
		 * @@return <code>Image</code> that corresponds to the given index.
		 */
		public Image getIcon(int i) {
			if (i >= icons.size())
				return null;

			return (Image) icons.get(i);
		}

		/**
		 * Sets the icon at the index location.
		 * 
		 * @@param icon
		 * @@param i
		 */
		public void setIcon(Image icon, int i) {
			int size = icons.size();
			if (i >= size) {
				for (int j = size; j < i; j++)
					icons.add(null);
				icons.add(icon);
				icons.trimToSize();
			} else
				icons.set(i, icon);
		}

		/**
		 * Gets the icon size of the icon at the given index.
		 * 
		 * @@param i
		 * @@return the <code>Dimension</code> that is the size of the icon at
		 *         the given index.
		 */
		public Dimension getIconSize(IMapMode mapMode, int i) {
			Image img = getIcon(i);
			if (img != null && !img.isDisposed()) {
				org.eclipse.swt.graphics.Rectangle imgBounds = img.getBounds();				
				return new Dimension(mapMode.DPtoLP(imgBounds.width), mapMode
					.DPtoLP(imgBounds.height));
			}
			return EMPTY_DIMENSION;
		}

		/**
		 * @@return the number of icons
		 */
		public int getNumberofIcons() {
			return icons.size();
		}

		/**
		 * @@return the <code>Dimension</code> that is the total size of all
		 *         the icons.
		 */
		public Dimension getTotalIconSize(IMapMode mapMode) {
			if (totalIconSize != null)
				return totalIconSize;
			int iconNum = getNumberofIcons();
			if (iconNum == 0) {
				return totalIconSize = EMPTY_DIMENSION;
			}

			totalIconSize = new Dimension();
			for (int i = 0; i < iconNum; i++) {
				Dimension iconSize = getIconSize(mapMode, i);
				totalIconSize.width += iconSize.width;
				if (iconSize.height > totalIconSize.height)
					totalIconSize.height = iconSize.height;
			}

			return totalIconSize;
		}

		/**
		 * 
		 */
		public void invalidate() {
			totalIconSize = null;
		}
	}

	private IconInfo iconInfo;

	/** the cached hint used to calculate text size */	
	private int cachedTextSizeHint_width;

	private int cachedTextSizeHint_height;
	
	
	
	/**
	 * Construct an empty Label.
	 * 
	 * @@since 2.0
	 */
	public WrapLabel() {
		text = "";//$NON-NLS-1$
		// set defaults
		setAlignmentFlags(CENTER, FLAG_TEXT_ALIGN);
		setAlignmentFlags(CENTER, FLAG_ICON_ALIGN);
		setAlignmentFlags(CENTER, FLAG_LABEL_ALIGN);
		setAlignmentFlags(LEFT, FLAG_WRAP_ALIGN);
		setPlacementFlags(EAST, FLAG_TEXT_PLACEMENT);
	}

	/**
	 * Construct a Label with passed String as its text.
	 * 
	 * @@param s the label text
	 * @@since 2.0
	 */
	public WrapLabel(String s) {
		if (s != null) {
			text = s;
		} else {
			text = "";//$NON-NLS-1$
		}
//		setBorder(new LineBorderEx(ColorConstants.red,3));
	}

	/**
	 * Construct a Label with passed Image as its icon.
	 * 
	 * @@param i the label image
	 * @@since 2.0
	 */
	public WrapLabel(Image i) {
		text = "";//$NON-NLS-1$
		iconInfo = new SingleIconInfo(i);
	}

	/**
	 * Construct a Label with passed String as text and passed Image as its
	 * icon.
	 * 
	 * @@param s the label text
	 * @@param i the label image
	 * @@since 2.0
	 */
	public WrapLabel(String s, Image i) {
		if (s != null) {
			text = s;
		} else {
			text = "";//$NON-NLS-1$
		}
		iconInfo = new SingleIconInfo(i);
	}
	
	/**
	 * @@return <code>IMapMode</code> used by this figure.
	 *         <code>IMapMode</code> that allows for the coordinate mapping
	 *         from device to logical units.
	 */
	private IMapMode getFigureMapMode() {
		return (IMapMode) getMapModeConstants().mapModeRef.get();
	}

	private MapModeConstants getMapModeConstants() {
		if (mapModeConstants == null) {
			IMapMode mapMode = MapModeUtil.getMapMode(this);
			while (mapMode instanceof IMapModeHolder) {
				mapMode = ((IMapModeHolder) mapMode).getMapMode();
			}
			mapModeConstants = (MapModeConstants) mapModeConstantsMap
				.get(mapMode);
			if (mapModeConstants == null) {
				mapModeConstants = new MapModeConstants(mapMode);
				mapModeConstantsMap.put(mapMode, mapModeConstants);
			}
		}
		return mapModeConstants;
	}

	private void alignOnHeight(Point loc, Dimension size, int alignment) {
		switch (alignment) {
			case TOP:
				loc.y = getInsets().top;
				break;
			case BOTTOM:
				loc.y = bounds.height - size.height - getInsets().bottom;
				break;
			default:
				loc.y = (bounds.height - size.height) / 2;
		}
	}

	private void alignOnWidth(Point loc, Dimension size, int alignment) {
		switch (alignment) {
			case LEFT:
				loc.x = getInsets().left;
				break;
			case RIGHT:
				loc.x = bounds.width - size.width - getInsets().right;
				break;
			default:
				loc.x = (bounds.width - size.width) / 2;
		}
	}

	private void calculateAlignment(Dimension iconSize, int textPlacement) {
		switch (textPlacement) {
			case EAST:
			case WEST:
				alignOnHeight(textLocation, getTextSize(), getTextAlignment());
				alignOnHeight(getIconLocation(), iconSize, getIconAlignment());
				break;
			case NORTH:
			case SOUTH:
				alignOnWidth(textLocation, getSubStringTextSize(),
					getTextAlignment());
				alignOnWidth(getIconLocation(), iconSize, getIconAlignment());
				break;
		}
	}

	/**
	 * Calculates the size of the Label using the passed Dimension as the size
	 * of the Label's text.
	 * 
	 * @@param txtSize the precalculated size of the label's text
	 * @@return the label's size
	 * @@since 2.0
	 */
	protected Dimension calculateLabelSize(Dimension txtSize) {
		Dimension iconSize = getTotalIconSize();
		boolean isEmpty = (iconSize.width == 0 && iconSize.height == 0);
		int len = getText().length();
		if (len == 0 && isEmpty) {
			return new Dimension(txtSize.width, txtSize.height);
		}
		int gap = (len == 0 || isEmpty) ? 0
			: getIconTextGap();
		int placement = getTextPlacement();
		if (placement == WEST || placement == EAST) {
			return new Dimension(iconSize.width + gap + txtSize.width, Math
				.max(iconSize.height, txtSize.height));
		} else {
			return new Dimension(Math.max(iconSize.width, txtSize.width),
				iconSize.height + gap + txtSize.height);
		}
	}

	private void calculateLocations() {
		textLocation = new Point();
		iconLocation = new Point();
		Dimension iconSize = getTotalIconSize();
		int textPlacement = getTextPlacement();
		calculatePlacement(iconSize, textPlacement);
		calculateAlignment(iconSize, textPlacement);
		Rectangle r = getBounds();
		Dimension ps = getPreferredSize(r.width, r.height);
		int w = (r.width - ps.width)
			+ (getTextSize().width - getSubStringTextSize().width);
		int h = r.height - ps.height;
		if (w == 0 && h == 0) {
			return;
		}

		Dimension offset = new Dimension(w, h);
		switch (getLabelAlignment()) {
			case CENTER:
				offset.scale(0.5f);
				break;
			case LEFT:
				offset.scale(0.0f);
				break;
			case RIGHT:
				offset.scale(1.0f);
				break;
			case TOP:
				offset.height = 0;
				offset.scale(0.5f);
				break;
			case BOTTOM:
				offset.height = offset.height * 2;
				offset.scale(0.5f);
				break;
			default:
				offset.scale(0.5f);
				break;
		}

		switch (textPlacement) {
			case EAST:
			case WEST:
				offset.height = 0;
				break;
			case NORTH:
			case SOUTH:
				offset.width = 0;
				break;
		}

		textLocation.translate(offset);
		iconLocation.translate(offset);
	}

	private void calculatePlacement(Dimension iconSize, int textPlacement) {
		int gap = (getText().length() == 0 || (iconSize.width == 0 && iconSize.height == 0)) ? 0
			: getIconTextGap();
		Insets insets = getInsets();
		switch (textPlacement) {
			case EAST:
				iconLocation.x = insets.left;
				textLocation.x = iconSize.width + gap + insets.left;
				break;
			case WEST:
				textLocation.x = insets.left;
				iconLocation.x = getSubStringTextSize().width + gap
					+ insets.left;
				break;
			case NORTH:
				textLocation.y = insets.top;
				iconLocation.y = getTextSize().height + gap + insets.top;
				break;
			case SOUTH:
				textLocation.y = iconSize.height + gap + insets.top;
				iconLocation.y = insets.top;
		}
	}
	/**
	 * Calculates the size of the Label's text size. The text size calculated
	 * takes into consideration if the Label's text is currently truncated. If
	 * text size without considering current truncation is desired, use
	 * {@@link #calculateTextSize(int, int)}.
	 * 
	 * @@return the size of the label's text, taking into account truncation
	 * @@since 2.0
	 */
	protected Dimension calculateSubStringTextSize() {
		Font f = getFont();
d129 1
a129 1
	}
d131 6
a136 6
	/**
	 * Calculates and returns the size of the Label's text. Note that this
	 * Dimension is calculated using the Label's full text, regardless of
	 * whether or not its text is currently truncated. If text size considering
	 * current truncation is desired, use {@@link #calculateSubStringTextSize()}.
	 * 
d139 370
a508 1042
	 * @@return the size of the label's text, ignoring truncation
	 * @@since 2.0
	 */
	protected Dimension calculateTextSize(int wHint, int hHint) {
		Font f = getFont();
		return getTextExtents(getWrappedText(wHint, hHint), f,getFigureMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight()));
	}

	private void clearLocations() {
		iconLocation = textLocation = null;
	}

	/**
	 * Returns the Label's icon.
	 * 
	 * @@return the label icon
	 * @@since 2.0
	 */
	public Image getIcon() {
		return getIcon(0);
	}

	/**
	 * Gets the label's icon at the given index
	 * 
	 * @@param index The icon index
	 * @@return the <code>Image</code> that is the icon for the given index.
	 */
	public Image getIcon(int index) {
		if (iconInfo == null)
			return null;
		return iconInfo.getIcon(index);
	}

	/**
	 * Determines if there is any icons by checking if icon size is zeros.
	 * 
	 * @@return true if icons are present, false otherwise 
	 */
	protected boolean hasIcons() {
		return (getNumberofIcons() > 0);
	}

	/**
	 * Returns the current alignment of the Label's icon. The default is
	 * {@@link PositionConstants#CENTER}.
	 * 
	 * @@return the icon alignment
	 * @@since 2.0
	 */
	public int getIconAlignment() {
		return getAlignment(FLAG_ICON_ALIGN);
	}

	/**
	 * Returns the bounds of the Label's icon.
	 * 
	 * @@return the icon's bounds
	 * @@since 2.0
	 */
	public Rectangle getIconBounds() {
		return new Rectangle(getBounds().getLocation().translate(
			getIconLocation()), getTotalIconSize());
	}

	/**
	 * Returns the location of the Label's icon relative to the Label.
	 * 
	 * @@return the icon's location
	 * @@since 2.0
	 */
	protected Point getIconLocation() {
		if (iconLocation == null)
			calculateLocations();
		return iconLocation;
	}

	/**
	 * Returns the gap in pixels between the Label's icon and its text.
	 * 
	 * @@return the gap
	 * @@since 2.0
	 */
	public int getIconTextGap() {
		return getMapModeConstants().nDPtoLP_3;
	}

	/**
	 * @@see IFigure#getMinimumSize(int, int)
	 */
	public Dimension getMinimumSize(int w, int h) {
		if (minSize != null)
			return minSize;
		minSize = new Dimension();
		LayoutManager layoutManager = getLayoutManager();
		if (layoutManager != null)
			minSize.setSize(layoutManager.getMinimumSize(this, w, h));
		Font f = getFont();
		Dimension d = getEllipseTextSize().getIntersected(
			getTextExtents(getText(), f, getFigureMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight())));		
		
		Dimension labelSize = calculateLabelSize(d);
		Insets insets = getInsets();
		labelSize.expand(insets.getWidth(), insets.getHeight());
		minSize.union(labelSize);
		return minSize;
	}

	/* 
	 * (non-Javadoc)
	 * @@see org.eclipse.draw2d.IFigure#getPreferredSize(int, int)
	 */
	public Dimension getPreferredSize(int wHint, int hHint) {
		if (prefSize == null || wHint != cachedPrefSizeHint_width || hHint != cachedPrefSizeHint_height) {
			prefSize = calculateLabelSize(getTextSize(wHint, hHint));
			Insets insets = getInsets();
			prefSize.expand(insets.getWidth(), insets.getHeight());
			LayoutManager layoutManager = getLayoutManager();
			if (layoutManager != null) {
				prefSize.union(layoutManager.getPreferredSize(this, wHint,
					hHint));
			}
			prefSize.union(getMinimumSize(wHint, hHint));
			cachedPrefSizeHint_width = wHint;
			cachedPrefSizeHint_height = hHint;
		}
		return prefSize;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.draw2d.IFigure#getMaximumSize()
	 */
	public Dimension getMaximumSize() {
		// this assumes that getPreferredSize(wHint, hHint) is called before
		return prefSize;   
	}

	/**
	 * Calculates the amount of the Label's current text will fit in the Label,
	 * including an elipsis "..." if truncation is required.
	 * 
	 * @@return the substring
	 * @@since 2.0
	 */
	public String getSubStringText() {
		if (subStringText != null)
			return subStringText;
		
		String theText = getText();
		int textLen = theText.length();
		if (textLen == 0) {
			return subStringText = "";//$NON-NLS-1$;;
		}
		Dimension size = getSize();
		Dimension shrink = getPreferredSize(size.width, size.height).getDifference(size);
		Dimension effectiveSize = getTextSize().getExpanded(-shrink.width, -shrink.height);
		
		if (effectiveSize.height == 0) {
			return subStringText = "";//$NON-NLS-1$;
		}
		
		Font f = getFont();
		FontMetrics metrics = FigureUtilities.getFontMetrics(f);
		IMapMode mm = getFigureMapMode();
		int fontHeight = mm.DPtoLP(metrics.getHeight());
		int charAverageWidth = mm.DPtoLP(metrics.getAverageCharWidth());
		int maxLines = (int) (effectiveSize.height / (double) fontHeight);
		if (maxLines == 0) {
			return subStringText = "";//$NON-NLS-1$
		}

		StringBuffer accumlatedText = new StringBuffer();
		StringBuffer remainingText = new StringBuffer(theText);
		
		int effectiveSizeWidth = effectiveSize.width;
		int widthHint = Math.max(effectiveSizeWidth
			- getEllipseTextSize().width, 0);
		int i = 0, j = 0;
		while (remainingText.length() > 0 && j++ < maxLines) {
			i = getLineWrapPosition(remainingText.toString(), f, effectiveSizeWidth, fontHeight);

			if (accumlatedText.length() > 0)
				accumlatedText.append('\n');

			if (i == 0 || (remainingText.length() > i && j == maxLines)) {				
				i = getLargestSubstringConfinedTo(remainingText.toString(), f, widthHint, fontHeight, charAverageWidth);
				accumlatedText.append(remainingText.substring(0, i));
				accumlatedText.append(getEllipse());
			} else
				accumlatedText.append(remainingText.substring(0, i));
			remainingText.delete(0, i);
		}
		return subStringText = accumlatedText.toString();
	}
	
	
	
	
	/**
	 * Creates an equivalent text to that of the label's but with "\n"(s)
	 * inserted at the wrapping positions. This method assumes unlimited
	 * bounding box and is used by <code>calculateTextSize()</code> to
	 * calculate the perfect size of the text with wrapping
	 * 
	 * @@return the wrapped text
	 */	
	private String getWrappedText(int wHint, int hHint) {
		String theText = getText();		
		if (wHint == -1 || theText.length() == 0 || !isTextWrapped())
			return theText;

		Dimension iconSize = getTotalIconSize();
		if (!(iconSize.width == 0 && iconSize.height == 0)) {
			switch(getTextPlacement()) {
				case EAST:
				case WEST:
					wHint -= iconSize.width + getIconTextGap();
					break;
				case NORTH:
				case SOUTH:
					if (hHint != -1)
						hHint -= iconSize.height + getIconTextGap();
					break;
			}
		}
		
		
		if ((hHint == 0)||(wHint == 0)) {
			return "";//$NON-NLS-1$;
		}
		
		Font f = getFont();
		int fontHeight = getFigureMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight());
		int maxLines = Integer.MAX_VALUE;
		if (hHint != -1) {			
			maxLines = (int) (hHint / (double) fontHeight);
			if (maxLines == 0) {
				return "";//$NON-NLS-1$;;
			}
		}	
		
		StringBuffer accumlatedText = new StringBuffer();
		StringBuffer remainingText = new StringBuffer(theText);
		int i = 0, j = 0;

		while (remainingText.length() > 0 && j++  < maxLines) {
			if ((i = getLineWrapPosition(remainingText.toString(), f, wHint, fontHeight)) == 0)
				break;

			if (accumlatedText.length() > 0)
				accumlatedText.append('\n');
			accumlatedText.append(remainingText.substring(0, i));
			remainingText.delete(0, i);
		}
		return accumlatedText.toString();
	}

	/**
	 * Returns the size of the Label's current text. If the text is currently
	 * truncated, the truncated text with its ellipsis is used to calculate the
	 * size.
	 * 
	 * @@return the size of this label's text, taking into account truncation
	 * @@since 2.0
	 */
	protected Dimension getSubStringTextSize() {
		return calculateSubStringTextSize();
	}
	
	/**
	 * Returns the size of the String constant "..." the ellipse based on
	 * the currently used Map mode
	 * size.
	 * 
	 * @@return the size of ellipse text
	 * 
	 */
	private Dimension getEllipseTextSize() {
		if (ellipseTextSize == null) {
			ellipseTextSize = getMapModeConstants().getEllipseTextSize(
				getFont());
		}
		return ellipseTextSize;
	}

	/**
	 * Returns the text of the label. Note that this is the complete text of the
	 * label, regardless of whether it is currently being truncated. Call
	 * {@@link #getSubStringText()}to return the label's current text contents
	 * with truncation considered.
	 * 
	 * @@return the complete text of this label
	 * @@since 2.0
	 */
	public String getText() {
		return text;
	}

	/**
	 * Returns the current alignment of the Label's text. The default text
	 * alignment is {@@link PositionConstants#CENTER}.
	 * 
	 * @@return the text alignment
	 */
	public int getTextAlignment() {
		return getAlignment(FLAG_TEXT_ALIGN);
	}

	/**
	 * Returns the current alignment of the entire Label. The default label
	 * alignment is {@@link PositionConstants#LEFT}.
	 * 
	 * @@return the label alignment
	 */
	private int getLabelAlignment() {
		return getAlignment(FLAG_LABEL_ALIGN);
	}
	
	/**
	 * Returns the bounds of the label's text. Note that the bounds are
	 * calculated using the label's complete text regardless of whether the
	 * label's text is currently truncated.
	 * 
	 * @@return the bounds of this label's complete text
	 * @@since 2.0
	 */
	public Rectangle getTextBounds() {
		return new Rectangle(getBounds().getLocation().translate(
			getTextLocation()), getTextSize());
	}

	/**
	 * Returns the location of the label's text relative to the label.
	 * 
	 * @@return the text location
	 * @@since 2.0
	 */
	protected Point getTextLocation() {
		if (textLocation != null)
			return textLocation;
		calculateLocations();
		return textLocation;
	}

	/**
	 * Returns the current placement of the label's text relative to its icon.
	 * The default text placement is {@@link PositionConstants#EAST}.
	 * 
	 * @@return the text placement
	 * @@since 2.0
	 */
	public int getTextPlacement() {
		return getPlacement(FLAG_TEXT_PLACEMENT);
	}

	/**
	 * Returns the size of the label's complete text. Note that the text used to
	 * make this calculation is the label's full text, regardless of whether the
	 * label's text is currently being truncated and is displaying an ellipsis.
	 * If the size considering current truncation is desired, call
	 * {@@link #getSubStringTextSize()}.
	 * 
	 * @@param wHint a width hint
	 * @@param hHint a height hint
	 * @@return the size of this label's complete text
	 * @@since 2.0
	 */
	protected Dimension getTextSize(int wHint, int hHint) {
		if (textSize == null || wHint != cachedTextSizeHint_width || hHint != cachedTextSizeHint_height) {
			textSize = calculateTextSize(wHint, hHint);
			cachedTextSizeHint_width = wHint;
			cachedTextSizeHint_height= hHint;
		}
		return textSize;
	}

	/**
	 * Gets the text size given the current size as a width hint
	 */
	private final Dimension getTextSize() {		
		Rectangle r = getBounds();
		return getTextSize(r.width, r.height);		
	}
	
	/**
	 * @@see IFigure#invalidate()
	 */
	public void invalidate() {
		prefSize = null;
		minSize = null;
		clearLocations();
		ellipseTextSize = null;
		textSize = null;
		subStringText = null;
		if (iconInfo != null)
			iconInfo.invalidate();
		super.invalidate();
	}

	/**
	 * Returns <code>true</code> if the label's text is currently truncated
	 * and is displaying an ellipsis, <code>false</code> otherwise.
	 * 
	 * @@return <code>true</code> if the label's text is truncated
	 * @@since 2.0
	 */
	public boolean isTextTruncated() {
		return !getSubStringTextSize().equals(getTextSize());
	}

	/**
	 * @@see org.eclipse.draw2d.Figure#paintFigure(org.eclipse.draw2d.Graphics)
	 */
	public void paintFigure(Graphics graphics) {
		if (isSelected()) {
			graphics.pushState();
			graphics.setBackgroundColor(ColorConstants.menuBackgroundSelected);
			graphics.fillRectangle(getSelectionRectangle());
			graphics.popState();
			graphics.setForegroundColor(ColorConstants.white);
		}
		if (hasFocus()) {
			graphics.pushState();
			graphics.setXORMode(true);
			graphics.setForegroundColor(ColorConstants.menuBackgroundSelected);
			graphics.setBackgroundColor(ColorConstants.white);
			graphics.drawFocus(getSelectionRectangle().resize(-1, -1));
			graphics.popState();
		}
		if (isOpaque())
			super.paintFigure(graphics);
		Rectangle figBounds = getBounds();

		graphics.translate(figBounds.x, figBounds.y);
		if (hasIcons())
			paintIcons(graphics);

		String subString = getSubStringText();
		if (subString.length() > 0) {
			if (!isEnabled()) {
				graphics.translate(1, 1);
				graphics.setForegroundColor(ColorConstants.buttonLightest);
				paintText(graphics, subString);
				graphics.translate(-1, -1);
				graphics.setForegroundColor(ColorConstants.buttonDarker);
			} else {
				paintText(graphics, subString);
			}
		}
		graphics.translate(-figBounds.x, -figBounds.y);
	}

	/**
	 * Paints the text and optioanally underlines it
	 * 
	 * @@param graphics The graphics context
	 * @@param subString The string to draw
	 */	
	private void paintText(Graphics graphics, String subString) {		
		StringTokenizer tokenizer = new StringTokenizer(subString, "\n"); //$NON-NLS-1$
		Font f = getFont();
		FontMetrics fontMetrics = FigureUtilities.getFontMetrics(f);
		int fontHeight = getFigureMapMode().DPtoLP(fontMetrics.getHeight());
		int fontHeightHalf = fontHeight / 2;
		int textWidth = getTextExtents(subString, f, fontHeight).width;
		Point p = getTextLocation();
		int y = p.y;
		int x = p.x;
		final int wrapAlignment = getTextWrapAlignment();
		boolean isUnderlined = isTextUnderlined();
		boolean isStrikedThrough = isTextStrikedThrough();
		Rectangle clipRect = new Rectangle();
		graphics.getClip(clipRect);
		int clipRectTopRight_x = clipRect.getTopRight().x;
		// If the font's leading area is 0 then we need to add an offset to
		// avoid truncating at the top (e.g. Korean fonts)
		if (0 == fontMetrics.getLeading()) {
			y +=  getMapModeConstants().nDPtoLP_2; // 2 is the leading area for default English			
		}				

		while (tokenizer.hasMoreTokens()) {
            x = p.x;
			String token = tokenizer.nextToken();
			int tokenWidth = getTextExtents(token, f, fontHeight).width;
			
			switch (wrapAlignment) {
				case CENTER:
					x += (textWidth - tokenWidth) / 2;
					break;
				case RIGHT:
					x += textWidth - tokenWidth;
					break;
			}
			
			// increase the clipping rectangle by a small amount to account for font overhang
			// from italic / irregular characters etc.
			
			
			if (tokenWidth + x <= clipRectTopRight_x) {
				Rectangle newClipRect = new Rectangle(clipRect);
				newClipRect.width += (tokenWidth / token.length()) / 2;
				graphics.setClip(newClipRect);
			}
				
			graphics.drawText(token, x, y);
			graphics.setClip(clipRect);
			
			y += fontHeight;

			if (isUnderlined)
				graphics.drawLine(x, y - 1, x + tokenWidth, y - 1);
			if (isStrikedThrough)
				graphics.drawLine(x, y - fontHeightHalf + 1, x + tokenWidth, y
					- fontHeightHalf + 1);
		}
	}

	/**
	 * Paints the icon(s)
	 * 
	 * @@param graphics The graphics context
	 */
	private void paintIcons(Graphics graphics) {
		Point p = Point.SINGLETON;
		p.setLocation(getIconLocation());

		int num = getNumberofIcons();
		for (int i = 0; i < num; i++) {
			Image icon = getIcon(i); 
			if (icon != null) {
				graphics.drawImage(icon, p);
				p.x += getIconSize(i).width;
			}
		}
	}

	/**
	 * Sets the label's icon to the passed image.
	 * 
	 * @@param image the new label image
	 * @@since 2.0
	 */
	public void setIcon(Image image) {
		setIcon(image, 0);
	}

	/**
	 * Sets the label's icon at given index
	 * 
	 * @@param image The icon image or null to remove the icon
	 * @@param index The icon index
	 */
	public void setIcon(Image image, int index) {
		if (iconInfo == null) {
			if (index == 0) {
				iconInfo = getMapModeConstants().getSingleIconInfo(image);
			} else {
				iconInfo = new MultiIconInfo();
				iconInfo.setIcon(image, index);
			}
			revalidate();
			repaint();// Call repaint, in case the image dimensions are the same.           
		} else if (iconInfo.getIcon(index) != image) {
			if (iconInfo.getMaxIcons() == 1) {
				if (index == 0) {
					iconInfo = getMapModeConstants().getSingleIconInfo(image);
					revalidate();
					repaint();// Call repaint, in case the image dimensions are the same.
					return;
				}
				IconInfo oldIconInfo = iconInfo;
				iconInfo = new MultiIconInfo();
				iconInfo.setIcon(oldIconInfo.getIcon(0), 0);
			}
			iconInfo.setIcon(image, index);
			revalidate();
			repaint();// Call repaint, in case the image dimensions are the same.
		}	
	}


	/**
	 * Sets the icon alignment relative to the .abel's alignment to the passed
	 * value. The default is {@@link PositionConstants#CENTER}. Other possible
	 * values are {@@link PositionConstants#TOP},
	 * {@@link PositionConstants#BOTTOM},{@@link PositionConstants#LEFT}and
	 * {@@link PositionConstants#RIGHT}.
	 * 
	 * @@param align the icon alignment
	 * @@since 2.0
	 */
	public void setIconAlignment(int align) {
		if (getIconAlignment() == align)
			return;
		setAlignmentFlags(align, FLAG_ICON_ALIGN);
		clearLocations();
		repaint();
	}

	/**
	 * getIconSize
	 * @@param index of icon to retrieve size of.
	 * @@return Dimension representing the icon size.
	 */
	protected Dimension getIconSize(int index) {
		if (iconInfo == null)
			return EMPTY_DIMENSION;
		return iconInfo.getIconSize(getFigureMapMode(), index);
	}
	
	/**
	 * getIconNumber
	 * @@return int number of icons in the wrap label
	 */
	protected int getNumberofIcons() {
		if (iconInfo == null)
			return 0;
		return iconInfo.getNumberofIcons();
	}
	
	/**
	 * getTotalIconSize
	 * Calculates the total union of icon sizes
	 * @@return Dimension that is the union of icon sizes
	 */
	protected Dimension getTotalIconSize() {
		if (iconInfo == null)
			return EMPTY_DIMENSION;
		return iconInfo.getTotalIconSize(getFigureMapMode());
	}

	/**
	 * Sets the Label's alignment to the passed value. The default is
	 * {@@link PositionConstants#CENTER}. Other possible values are
	 * {@@link PositionConstants#TOP},{@@link PositionConstants#BOTTOM},
	 * {@@link PositionConstants#LEFT}and {@@link PositionConstants#RIGHT}.
	 * 
	 * @@param align label alignment
	 */
	public void setLabelAlignment(int align) {
		if (getLabelAlignment() == align)
			return;
		setAlignmentFlags(align, FLAG_LABEL_ALIGN);
		clearLocations();
		repaint();
	}

	/**
	 * Return the ellipse string.
	 * 
	 * @@return the <code>String</code> that represents the fact that the
	 * text has been truncated and that more text is available but hidden. 
	 * Usually this is represented by "...".
	 */
	protected String getEllipse() {
		return _ellipse;
	}
	
	/**
	 * Sets the label's text.
	 * 
	 * @@param s the new label text
	 * @@since 2.0
	 */
	public void setText(String s) {
		//"text" will never be null.
		if (s == null)
			s = "";//$NON-NLS-1$
		if (text.equals(s))
			return;
		text = s;
		revalidate();
		repaint(); //If the new text does not cause a new size, we still need
		// to paint.
	}

	/**
	 * Sets the text alignment of the Label relative to the label alignment. The
	 * default is {@@link PositionConstants#CENTER}. Other possible values are
	 * {@@link PositionConstants#TOP},{@@link PositionConstants#BOTTOM},
	 * {@@link PositionConstants#LEFT}and {@@link PositionConstants#RIGHT}.
	 * 
	 * @@param align the text alignment
	 * @@since 2.0
	 */
	public void setTextAlignment(int align) {
		if (getTextAlignment() == align)
			return;
		setAlignmentFlags(align, FLAG_TEXT_ALIGN);
		clearLocations();
		repaint();
	}

	/**
	 * Sets the text placement of the label relative to its icon. The default is
	 * {@@link PositionConstants#EAST}. Other possible values are
	 * {@@link PositionConstants#NORTH},{@@link PositionConstants#SOUTH}and
	 * {@@link PositionConstants#WEST}.
	 * 
	 * @@param where the text placement
	 * @@since 2.0
	 */
	public void setTextPlacement(int where) {
		if (getTextPlacement() == where)
			return;
		setPlacementFlags(where, FLAG_TEXT_PLACEMENT);
		revalidate();
		repaint();
	}

	/**
	 * Sets whether the label text should be underlined
	 * 
	 * @@param b Wether the label text should be underlined
	 */
	public void setTextUnderline(boolean b) {
		if (isTextUnderlined() == b)
			return;
		setFlag(FLAG_UNDERLINED, b);
		repaint();
	}

	/**
	 * @@return whether the label text is underlined
	 */
	public boolean isTextUnderlined() {
		return (flags & FLAG_UNDERLINED) != 0;
	}
	
	/**
	 * Sets whether the label text should be striked-through
	 * 
	 * @@param b Wether the label text should be stricked-through
	 */
	public void setTextStrikeThrough(boolean b) {
		if (isTextStrikedThrough() == b)
			return;
		setFlag(FLAG_STRIKEDTHROUGH, b);
		repaint();
	}

	/**
	 * @@return wether the label text is stricked-through
	 */
	public boolean isTextStrikedThrough() {
		return (flags & FLAG_STRIKEDTHROUGH) != 0;
	}

	/**
	 * Sets whether the label text should wrap
	 * 
	 * @@param b whether the label text should wrap
	 */
	public void setTextWrap(boolean b) {
		if (isTextWrapped() == b)
			return;
		setFlag(FLAG_WRAP, b);
		revalidate();
		repaint();
	}

	/**
	 * @@return wether the label text wrap is on
	 */
	public boolean isTextWrapped() {
		return (flags & FLAG_WRAP) != 0;
	}

	/**
	 * Sets the wrapping width of the label text. This is only valid if text
	 * wrapping is turned on
	 * 
	 * @@param i The label text wrapping width
	 */
	public void setTextWrapWidth(int i) {
		/*
		 * if (this.wrapWidth == i) return; this.wrapWidth = i; revalidate();
		 * repaint();
		 */
	}

	/**
	 * Sets the wrapping width of the label text. This is only valid if text
	 * wrapping is turned on
	 * 
	 * @@param i The label text wrapping width
	 */
	public void setTextWrapAlignment(int i) {
		if (getTextWrapAlignment() == i)
			return;
		
		setAlignmentFlags(i, FLAG_WRAP_ALIGN);
		repaint();
	}

	/**
	 * @@return the label text wrapping width
	 */
	public int getTextWrapAlignment() {
		return getAlignment(FLAG_WRAP_ALIGN);
	}
	
	/**
	 * setPlacementFlags
	 * @@param align 
	 * @@param flagOffset
	 */
	private void setPlacementFlags(int align, int flagOffset) {
		flags &= ~(0x7 * flagOffset);
		switch (align) {
			case EAST:
				flags |= 0x1 * flagOffset;
				break;
			case WEST:
				flags |= 0x2 * flagOffset;
				break;
			case NORTH:
				flags |= 0x3 * flagOffset;
				break;
			case SOUTH:
				flags |= 0x4 * flagOffset;
				break;
		}
	}

	/**
	 * getPlacement
	 * 
	 * @@param flagOffset
	 * @@return PositionConstant representing the placement
	 */
	private int getPlacement(int flagOffset) {
		int wrapValue = flags & (0x7 * flagOffset);
		if (wrapValue == 0x1 * flagOffset)
			return EAST;
		else if (wrapValue == 0x2 * flagOffset)
			return WEST;
		else if (wrapValue == 0x3 * flagOffset)
			return NORTH;
		else if (wrapValue == 0x4 * flagOffset)
			return SOUTH;
		
		return EAST;
	}
	
	/**
	 * setAlignmentFlags
	 * @@param align 
	 * @@param flagOffset
	 */
	private void setAlignmentFlags(int align, int flagOffset) {
		flags &= ~(0x7 * flagOffset);
		switch (align) {
			case CENTER:
				flags |= 0x1 * flagOffset;
				break;
			case TOP:
				flags |= 0x2 * flagOffset;
				break;
			case LEFT:
				flags |= 0x3 * flagOffset;
				break;
			case RIGHT:
				flags |= 0x4 * flagOffset;
				break;
			case BOTTOM:
				flags |= 0x5 * flagOffset;
				break;
		}
	}

	/**
	 * Retrieves the alignment value from the flags member.
	 * 
	 * @@param flagOffset that is the bitwise value representing the offset.
	 * @@return PositionConstant representing the alignment
	 */
	private int getAlignment(int flagOffset) {
		int wrapValue = flags & (0x7 * flagOffset);
		if (wrapValue == 0x1 * flagOffset)
			return CENTER;
		else if (wrapValue == 0x2 * flagOffset)
			return TOP;
		else if (wrapValue == 0x3 * flagOffset)
			return LEFT;
		else if (wrapValue == 0x4 * flagOffset)
			return RIGHT;
		else if (wrapValue == 0x5 * flagOffset)
			return BOTTOM;
		
		return CENTER;
	}
	

	/**
	 * Sets the selection state of this label
	 * 
	 * @@param b true will cause the label to appear selected
	 */
	public void setSelected(boolean b) {
		if (isSelected() == b)
			return;
		setFlag(FLAG_SELECTED, b);
		repaint();
	}

	/**
	 * @@return the selection state of this label
	 */
	public boolean isSelected() {
		return (flags & FLAG_SELECTED) != 0;
	}

	/**
	 * Sets the focus state of this label
	 * 
	 * @@param b true will cause a focus rectangle to be drawn around the text
	 *            of the Label
	 */
	public void setFocus(boolean b) {
		if (hasFocus() == b)
			return;
		setFlag(FLAG_HASFOCUS, b);
		repaint();
	}

	/**
	 * @@return the focus state of this label
	 */
	public boolean hasFocus() {
		return (flags & FLAG_HASFOCUS) != 0;
	}

	/**
	 * Returns the bounds of the text selection
	 * 
	 * @@return The bounds of the text selection
	 */
	private Rectangle getSelectionRectangle() {
		Rectangle figBounds = getTextBounds();
		int expansion = getMapModeConstants().nDPtoLP_2;
		figBounds.resize(expansion, expansion);
		translateToParent(figBounds);
		figBounds.intersect(getBounds());
		return figBounds;
	}

	/**
	 * returns the position of last character within the supplied text that will
	 * fit within the supplied width.
	 * 
	 * @@param s a text string
	 * @@param f font used to draw the text string
	 * @@param w width in pixles.
	 * @@param fontHeight int <b>mapped already to logical units</b>.
	 */
	private int getLineWrapPosition(String s, Font f, int w, int fontHeight) {
		if (getTextExtents(s, f, fontHeight).width <= w) {
			return s.length();
		}
		// create an iterator for line breaking positions
		BreakIterator iter = BreakIterator.getLineInstance();
		iter.setText(s);
		int start = iter.first();
		int end = iter.next();

		// if the first line segment does not fit in the width,
		// determine the position within it where we need to cut
		if (getTextExtents(s.substring(start, end), f, fontHeight).width > w) {
			iter = BreakIterator.getCharacterInstance();
			iter.setText(s);
			start = iter.first();
		}

		// keep iterating as long as width permits
		do
			end = iter.next();
		while (end != BreakIterator.DONE
			&& getTextExtents(s.substring(start, end), f, fontHeight).width <= w);
		return (end == BreakIterator.DONE) ? iter.last()
			: iter.previous();
	}	

	/**
	 * Returns the largest substring of <i>s </i> in Font <i>f </i> that can be
	 * confined to the number of pixels in <i>availableWidth <i>.
	 * 
	 * @@param s the original string
	 * @@param f the font
	 * @@param w the available width
	 * @@param fontHeight int <b>mapped already to logical units</b>.
	 * @@param charAverageWidth int <b>mapped already to logical units</b>.
	 * @@return the largest substring that fits in the given width
	 * @@since 2.0
	 */
	private int getLargestSubstringConfinedTo(String s, Font f, int w, int fontHeight, int charAverageWidth) {		
		float avg = charAverageWidth;
		int min = 0;
		int max = s.length() + 1;

		//The size of the current guess
		int guess = 0, guessSize = 0;
		while ((max - min) > 1) {
			//Pick a new guess size
			//	New guess is the last guess plus the missing width in pixels
			//	divided by the average character size in pixels
			guess = guess + (int) ((w - guessSize) / avg);

			if (guess >= max)
				guess = max - 1;
			if (guess <= min)
				guess = min + 1;

			//Measure the current guess
			guessSize = getTextExtents(s.substring(0, guess), f, fontHeight).width;

			if (guessSize < w)
				//We did not use the available width
				min = guess;
			else
				//We exceeded the available width
				max = guess;
		}
		return min;
	}

	/**
	 * Gets the tex extent scaled to the mapping mode
	 */
	private Dimension getTextExtents(String s, Font f, int fontHeight) {
		if (s.length() == 0) {
			return getMapModeConstants().dimension_nDPtoLP_0;
		} else {
			// height should be set using the font height and the number of
			// lines in the string			
			Dimension d = FigureUtilities.getTextExtents(s, f);
			IMapMode mapMode = getFigureMapMode();
			d.width = mapMode.DPtoLP(d.width);
			d.height = fontHeight * new StringTokenizer(s, "\n").countTokens();//$NON-NLS-1$
			return d;			
		}
	}
a509 2
    
	
@


1.12
log
@[190079] gmf_head mmostafa 070531 WrapLabel's  center alignment  makes text cuf-off
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.11
log
@[160663] gmf_head crevells 061124 WrapLabel.getMapMode() conflicts with generated code
@
text
@d1151 1
@


1.10
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d481 1
a481 1
	private IMapMode getMapMode() {
d659 1
a659 1
		return getTextExtents(getSubStringText(), f, getMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight())); 
d675 1
a675 1
		return getTextExtents(getWrappedText(wHint, hHint), f,getMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight()));
d769 1
a769 1
			getTextExtents(getText(), f, getMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight())));		
d833 1
a833 1
		IMapMode mm = getMapMode();
d902 1
a902 1
		int fontHeight = getMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight());
d1132 1
a1132 1
		int fontHeight = getMapMode().DPtoLP(fontMetrics.getHeight());
d1276 1
a1276 1
		return iconInfo.getIconSize(getMapMode(), index);
d1297 1
a1297 1
		return iconInfo.getTotalIconSize(getMapMode());
d1705 1
a1705 1
			IMapMode mapMode = getMapMode();
@


1.9
log
@bugzilla 124976  gmf-head mmostafa 060606 Bad compartment scroller icons on hover
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005  IBM Corporation and others.
d14 1
d16 2
d23 1
d29 3
d34 1
d62 3
a64 1
	implements PositionConstants {
a65 1
	private static String _ellipse = "..."; //$NON-NLS-1$
d68 64
d134 1
d136 1
d138 1
d140 1
d142 2
a143 2
	
	// reserve 3 bits 
d145 1
d147 1
d149 1
d151 1
d153 3
a155 2
	
	
d157 1
a157 1
	private String text = "";//$NON-NLS-1$
d163 3
a165 1
	private Dimension textSize;
d171 1
a171 4
	private Dimension cachedPrefSizeHint = new Dimension(-1, -1);

	/** the cached hint used to calculate text size */
	private Dimension cachedTextSizeHint = new Dimension(-1, -1);
d173 1
d178 131
a308 1
	private class IconInfo {
d310 2
a311 1
		private ArrayList icons = new ArrayList();
d315 8
d326 2
a327 1
		 * @@param i the index to retrieve the icon of
d333 1
a333 1
			
d336 1
a336 1
		
d344 3
a346 3
			if (i >= icons.size())
			{
				for (int j=icons.size(); j<i; j++)
d350 1
a350 2
			}
			else
d353 1
a353 1
		
d356 1
d358 2
a359 1
		 * @@return the <code>Dimension</code> that is the size of the icon at the given index.
d361 1
a361 1
		public Dimension getIconSize(int i) {
d364 3
a366 3
				org.eclipse.swt.graphics.Rectangle imgBounds = img.getBounds();
				return new Dimension(MapModeUtil.getMapMode(WrapLabel.this).DPtoLP(imgBounds.width), 
									MapModeUtil.getMapMode(WrapLabel.this).DPtoLP(imgBounds.height));
d370 1
a370 1
		
d379 2
a380 1
		 * @@return the <code>Dimension</code> that is the total size of all the icons.
d382 1
a382 1
		public Dimension getTotalIconSize() {
d385 11
a395 10
			
			totalIconSize = new Dimension(0, 0);
			
			for (int i = 0; i < getNumberofIcons(); i++) {
				Dimension iconSize = getIconSize(i);
				if (iconSize != null) {
					totalIconSize.width += iconSize.width;
					if (iconSize.height > totalIconSize.height)
						totalIconSize.height = iconSize.height;
				}
d397 1
a397 1
			
d408 8
a416 1
	private IconInfo iconInfo = null;
d424 1
d426 5
a430 5
		setTextAlignment(CENTER);
		setIconAlignment(CENTER);
		setLabelAlignment(CENTER);
		setTextWrapAlignment(LEFT);
		setTextPlacement(EAST);
d440 5
a444 1
		setText(s);
d455 2
a456 1
		setIcon(i);
d468 31
a498 2
		setText(s);
		setIcon(i);
a501 1
		Insets insets = getInsets();
d504 1
a504 1
				loc.y = insets.top;
d507 1
a507 1
				loc.y = bounds.height - size.height - insets.bottom;
a514 1
		Insets insets = getInsets();
d517 1
a517 1
				loc.x = insets.left;
d520 1
a520 1
				loc.x = bounds.width - size.width - insets.right;
d527 2
a528 3
	private void calculateAlignment() {
		Dimension iconSize = getTotalIconSize();
		switch (getTextPlacement()) {
a551 4
		int gap = getIconTextGap();
		if (!hasIcons() || getText().equals("")) //$NON-NLS-1$
			gap = 0;
		Dimension d = new Dimension(0, 0);
d553 11
a563 3
		if (getTextPlacement() == WEST || getTextPlacement() == EAST) {
			d.width = iconSize.width + gap + txtSize.width;
			d.height = Math.max(iconSize.height, txtSize.height);
d565 2
a566 2
			d.width = Math.max(iconSize.width, txtSize.width);
			d.height = iconSize.height + gap + txtSize.height;
a567 1
		return d;
d573 12
d586 1
a586 5
		calculatePlacement();
		calculateAlignment();
		Dimension offset = getSize().getDifference(
			getPreferredSize(getSize().width, getSize().height));
		offset.width += getTextSize().width - getSubStringTextSize().width;
d610 1
a610 1
		switch (getTextPlacement()) {
d625 3
a627 4
	private void calculatePlacement() {
		int gap = getIconTextGap();
		if (!hasIcons() || text.equals("")) //$NON-NLS-1$
			gap = 0;
d629 1
a629 3
		Dimension iconSize = getTotalIconSize();
		
		switch (getTextPlacement()) {
a647 1

d658 2
a659 1
		return getTextExtents(getSubStringText(), getFont()); 
d674 2
a675 1
		return getTextExtents(getWrappedText(wHint, hHint), getFont());
d710 1
a710 1
		return !Dimension.SINGLETON.equals(getTotalIconSize());
d754 1
a754 1
		return MapModeUtil.getMapMode(this).DPtoLP(3);
d764 7
a770 5
		if (getLayoutManager() != null)
			minSize.setSize(getLayoutManager().getMinimumSize(this, w, h));

		Dimension d = getTextExtents(getEllipse(), getFont()).intersect(
			getTextExtents(getText(), getFont()));
d783 1
a783 1
		if (prefSize == null || wHint != cachedPrefSizeHint.width || hHint != cachedPrefSizeHint.height) {
d787 3
a789 2
			if (getLayoutManager() != null)
				prefSize.union(getLayoutManager().getPreferredSize(this, wHint,
d791 1
d793 2
a794 2
			cachedPrefSizeHint.width = wHint;
			cachedPrefSizeHint.height= hHint;
d817 8
a824 2

		Dimension shrink = getPreferredSize(getSize().width, getSize().height).getDifference(getSize());
d827 4
d832 4
a835 1
		int fontHeight = MapModeUtil.getMapMode(this).DPtoLP(FigureUtilities.getFontMetrics(f).getHeight());
d837 3
d842 5
a846 1
		StringBuffer remainingText = new StringBuffer(getText());
a847 1

d849 1
a849 1
			i = getLineWrapPosition(remainingText.toString(), f, effectiveSize.width);
d852 1
a852 1
				accumlatedText.append("\n"); //$NON-NLS-1$
d854 2
a855 3
			if (i == 0 || (remainingText.length() > i && j == maxLines)) {
				int dotsWidth = getTextExtents(getEllipse(), f).width;
				i = getLargestSubstringConfinedTo(remainingText.toString(), f, Math.max(effectiveSize.width - dotsWidth, 0));
d864 4
a867 1

d875 1
a875 1
	 */
d877 3
a879 2
		if (!isTextWrapped() || wHint == -1)
			return getText();
d882 1
a882 1
		if (hasIcons()) {
d896 5
d902 1
d904 1
a904 2
		if (hHint != -1) {
			int fontHeight = MapModeUtil.getMapMode(this).DPtoLP(FigureUtilities.getFontMetrics(f).getHeight());
d906 5
a910 2
		}

d912 1
a912 1
		StringBuffer remainingText = new StringBuffer(getText());
d916 1
a916 1
			if ((i = getLineWrapPosition(remainingText.toString(), f, wHint)) == 0)
d920 1
a920 1
				accumlatedText.append("\n"); //$NON-NLS-1$
d938 16
d1038 1
a1038 1
		if (textSize == null || wHint != cachedTextSizeHint.width || hHint != cachedTextSizeHint.height) {
d1040 2
a1041 2
			cachedTextSizeHint.width = wHint;
			cachedTextSizeHint.height= hHint;
d1049 3
a1051 2
	private final Dimension getTextSize() {
		return getTextSize(getSize().width, getSize().height);
d1061 1
d1107 11
a1117 6
		if (!isEnabled()) {
			graphics.translate(1, 1);
			graphics.setForegroundColor(ColorConstants.buttonLightest);
			paintText(graphics);
			graphics.translate(-1, -1);
			graphics.setForegroundColor(ColorConstants.buttonDarker);
a1118 1
		paintText(graphics);
d1126 3
a1128 3
	 */
	private void paintText(Graphics graphics) {
		String subString = getSubStringText();
a1129 1

d1131 13
a1143 5
		int fontHeight = MapModeUtil.getMapMode(this).DPtoLP(FigureUtilities.getFontMetrics(f)
			.getHeight());
		int textWidth = getTextExtents(subString, f).width;
		int y = getTextLocation().y;
		
d1146 2
a1147 3
		if (0 == FigureUtilities.getFontMetrics(f).getLeading()) {
			int offset = MapModeUtil.getMapMode(this).DPtoLP(2); // 2 is the leading area for default English
			y += offset;
d1152 3
a1154 3
			int tokenWidth = getTextExtents(token, f).width;
			int x = getTextLocation().x;
			switch (getTextWrapAlignment()) {
a1164 2
			Rectangle clipRect = new Rectangle();
			graphics.getClip(clipRect);
d1166 2
a1167 1
			if (tokenWidth + x <= clipRect.getTopRight().x) {
d1178 1
a1178 1
			if (isTextUnderlined())
d1180 3
a1182 3
			if (isTextStrikedThrough())
				graphics.drawLine(x, y - fontHeight / 2 + 1, x + tokenWidth, y
					- fontHeight / 2 + 1);
d1222 25
a1246 9
		if (iconInfo == null)
			iconInfo = new IconInfo();
			
		if (iconInfo.getIcon(index) == image)
			return;
		
		iconInfo.setIcon(image, index);
		revalidate();
		repaint();// Call repaint, in case the image dimensions are the same.
d1276 1
a1276 1
		return iconInfo.getIconSize(index);
d1297 1
a1297 1
		return iconInfo.getTotalIconSize();
d1447 2
a1448 1
		 */}
d1609 2
a1610 3
		figBounds
			.expand(new Insets(MapModeUtil.getMapMode(this).DPtoLP(2), 
							MapModeUtil.getMapMode(this).DPtoLP(2), 0, 0));
d1623 1
d1625 4
a1628 1
	private int getLineWrapPosition(String s, Font f, int w) {
d1637 1
a1637 1
		if (getTextExtents(s.substring(start, end), f).width > w) {
d1647 1
a1647 1
			&& getTextExtents(s.substring(start, end), f).width <= w);
d1650 1
a1650 1
	}
d1659 2
d1664 4
a1667 6
	private int getLargestSubstringConfinedTo(String s, Font f, int w) {
		int min, max;
		float avg = MapModeUtil.getMapMode(this).DPtoLP(FigureUtilities.getFontMetrics(f)
			.getAverageCharWidth());
		min = 0;
		max = s.length() + 1;
d1683 1
a1683 1
			guessSize = getTextExtents(s.substring(0, guess), f).width;
d1698 12
a1709 8
	private Dimension getTextExtents(String s, Font f) {
		Dimension d = FigureUtilities.getTextExtents(s, f);
        // height should be set using the font height and the number of lines
        // in the string 
        int lineCount = getLineCount(s);
        d.height = FigureUtilities.getFontMetrics(f).getHeight()*lineCount;
     	return new Dimension(MapModeUtil.getMapMode(this).DPtoLP(d.width), 
							MapModeUtil.getMapMode(this).DPtoLP(d.height));
d1712 1
a1712 4
    private int getLineCount(String s) {
        StringTokenizer tokenizer = new StringTokenizer(s, "\n"); //$NON-NLS-1$
        return tokenizer.countTokens();
    }
@


1.9.2.1
log
@bugzilla 141621 sshaw gmf-R1_0_maintenance 060731 WrapLabel performance improvements

Contributed by: Yaser Lulu
@
text
@a13 1
import java.lang.ref.WeakReference;
a14 2
import java.util.Map;
import java.util.WeakHashMap;
a19 1
import org.eclipse.draw2d.LayoutManager;
a24 3

import org.eclipse.gmf.runtime.draw2d.ui.internal.mapmode.IMapModeHolder;
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
a26 1
import org.eclipse.swt.graphics.FontMetrics;
d54 1
a54 3
	implements PositionConstants {	

	private static final String _ellipse = "..."; //$NON-NLS-1$
d56 1
a58 64
	private static final Map mapModeConstantsMap = new WeakHashMap();

	private static class MapModeConstants {

		private static final int MAX_IMAGE_INFO = 12;

		public final WeakReference mapModeRef;

		public final int nDPtoLP_3;

		public final int nDPtoLP_2;

		public final int nDPtoLP_0;

		public final Dimension dimension_nDPtoLP_0;

		public final WeakHashMap fontToEllipseTextSize = new WeakHashMap();

		public final SingleIconInfo[] singleIconInfos = new SingleIconInfo[MAX_IMAGE_INFO];

		public MapModeConstants(IMapMode mapMode) {
			this.mapModeRef = new WeakReference(mapMode);
			nDPtoLP_2 = mapMode.DPtoLP(2);
			nDPtoLP_3 = mapMode.DPtoLP(3);
			nDPtoLP_0 = mapMode.DPtoLP(0);
			dimension_nDPtoLP_0 = new Dimension(nDPtoLP_0, nDPtoLP_0);
		}

		public Dimension getEllipseTextSize(Font f) {
			Dimension d = (Dimension) fontToEllipseTextSize.get(f);
			if (d == null) {
				IMapMode mapMode = (IMapMode) mapModeRef.get();
				d = FigureUtilities.getTextExtents(_ellipse, f);
				d.height = FigureUtilities.getFontMetrics(f).getHeight();
				d = new Dimension(mapMode.DPtoLP(d.width), mapMode
					.DPtoLP(d.height));
				fontToEllipseTextSize.put(f, d);
			}
			return d;
		}

		public SingleIconInfo getSingleIconInfo(Image image) {
			if (image == null) {
				return SingleIconInfo.NULL_INFO;
			}
			SingleIconInfo info;
			for (int i = 0; i < MAX_IMAGE_INFO; ++i) {
				info = singleIconInfos[i];
				if (info == null) {
					info = new SingleIconInfo(image);
					singleIconInfos[i] = info;
					return info;
				}
				if (info.icon == image) {
					return info;
				}
			}
			int index = SingleIconInfo.count % MAX_IMAGE_INFO;
			info = new SingleIconInfo(image);
			singleIconInfos[index] = info;
			return info;
		}
	}

a60 1

a61 1

a62 1

a63 1

d65 2
a66 2

	// reserve 3 bits
a67 1

a68 1

a69 1

a70 1

d72 2
a73 3

	private MapModeConstants mapModeConstants;

d75 1
a75 1
	private String text;
d81 1
a81 3
	private Dimension textSize;	

	private Dimension ellipseTextSize;
d87 4
a90 1
	private int cachedPrefSizeHint_width;
a91 1
	private int cachedPrefSizeHint_height;
d96 1
a96 131
	private static abstract class IconInfo {
		/**
		 * Gets the icon at the index location.
		 * 
		 * @@param i
		 *            the index to retrieve the icon of
		 * @@return <code>Image</code> that corresponds to the given index.
		 */
		public abstract Image getIcon(int i);
		
		/**
		 * Gets the icon size of the icon at the given index.
		 * 
		 * @@param i
		 * @@return the <code>Dimension</code> that is the size of the icon at
		 *         the given index.
		 */
		public abstract Dimension getIconSize(IMapMode mapMode, int i);

		/**
		 * @@return the number of icons
		 */
		public abstract int getNumberofIcons();
		
		/**
		 * @@return the <code>Dimension</code> that is the total size of all
		 *         the icons.
		 */
		public abstract Dimension getTotalIconSize(IMapMode mapMode);

		public abstract void invalidate();
		
		/**
		 * Sets the icon at the index location.
		 * 
		 * @@param icon
		 * @@param i
		 */
		public abstract void setIcon(Image icon, int i);
		
		/**
		 * 
		 */
		public abstract int getMaxIcons();

	}	

	private static class SingleIconInfo
		extends IconInfo {	

		static int count;
		
		public static final SingleIconInfo NULL_INFO = new SingleIconInfo(){
			public int getNumberofIcons() {
				return 0;
			}
		};

		final Image icon;

		/** total icon size */
		private Dimension totalIconSize;

		private SingleIconInfo() {
			icon = null;//don't increment count, used only for NULL_INFO
		}

		public SingleIconInfo(Image icon) {
			this.icon = icon;
			++count;
		}

		public final int getMaxIcons() {
			return 1;
		}

		
		public Image getIcon(int i) {
			if (i == 0) {
				return icon;
			} else if (i > 0) {
				return null;
			}
			throw new IndexOutOfBoundsException();
		}

		
		public void setIcon(Image img, int i) {
			throw new UnsupportedOperationException();
		}

		
		public Dimension getIconSize(IMapMode mapMode, int i) {
			if (i == 0) {
				return getTotalIconSize(mapMode);
			}

			throw new IndexOutOfBoundsException();
		}

		
		public int getNumberofIcons() {
			return 1;
		}

		
		public Dimension getTotalIconSize(IMapMode mapMode) {
			if (totalIconSize != null)
				return totalIconSize;

			if (icon != null && !icon.isDisposed()) {
				org.eclipse.swt.graphics.Rectangle imgBounds = icon.getBounds();
				totalIconSize = new Dimension(mapMode.DPtoLP(imgBounds.width),
					mapMode.DPtoLP(imgBounds.height));
			} else {
				totalIconSize = EMPTY_DIMENSION;
			}

			return totalIconSize;
		}

		
		public void invalidate() {
			totalIconSize = null;
		}

	}

	private static class MultiIconInfo
		extends IconInfo {

d98 1
a98 2
		private ArrayList icons = new ArrayList(2);

a101 8
		public MultiIconInfo() {
			super();
		}

		public int getMaxIcons() {
			return -1;
		}

d105 1
a105 2
		 * @@param i
		 *            the index to retrieve the icon of
d111 1
a111 1

d114 1
a114 1

d122 3
a124 3
			int size = icons.size();
			if (i >= size) {
				for (int j = size; j < i; j++)
d128 2
a129 1
			} else
d132 1
a132 1

a134 1
		 * 
d136 1
a136 2
		 * @@return the <code>Dimension</code> that is the size of the icon at
		 *         the given index.
d138 1
a138 1
		public Dimension getIconSize(IMapMode mapMode, int i) {
d141 3
a143 3
				org.eclipse.swt.graphics.Rectangle imgBounds = img.getBounds();				
				return new Dimension(mapMode.DPtoLP(imgBounds.width), mapMode
					.DPtoLP(imgBounds.height));
d147 1
a147 1

d156 1
a156 2
		 * @@return the <code>Dimension</code> that is the total size of all
		 *         the icons.
d158 1
a158 1
		public Dimension getTotalIconSize(IMapMode mapMode) {
d161 10
a170 3
			int iconNum = getNumberofIcons();
			if (iconNum == 0) {
				return totalIconSize = EMPTY_DIMENSION;
d172 1
a172 9

			totalIconSize = new Dimension();
			for (int i = 0; i < iconNum; i++) {
				Dimension iconSize = getIconSize(mapMode, i);
				totalIconSize.width += iconSize.width;
				if (iconSize.height > totalIconSize.height)
					totalIconSize.height = iconSize.height;
			}

a182 8

	private IconInfo iconInfo;

	/** the cached hint used to calculate text size */	
	private int cachedTextSizeHint_width;

	private int cachedTextSizeHint_height;
	
d184 1
a191 1
		text = "";//$NON-NLS-1$
d193 5
a197 5
		setAlignmentFlags(CENTER, FLAG_TEXT_ALIGN);
		setAlignmentFlags(CENTER, FLAG_ICON_ALIGN);
		setAlignmentFlags(CENTER, FLAG_LABEL_ALIGN);
		setAlignmentFlags(LEFT, FLAG_WRAP_ALIGN);
		setPlacementFlags(EAST, FLAG_TEXT_PLACEMENT);
d207 1
a207 5
		if (s != null) {
			text = s;
		} else {
			text = "";//$NON-NLS-1$
		}
d218 1
a218 2
		text = "";//$NON-NLS-1$
		iconInfo = new SingleIconInfo(i);
d230 2
a231 31
		if (s != null) {
			text = s;
		} else {
			text = "";//$NON-NLS-1$
		}
		iconInfo = new SingleIconInfo(i);
	}
	
	/**
	 * @@return <code>IMapMode</code> used by this figure.
	 *         <code>IMapMode</code> that allows for the coordinate mapping
	 *         from device to logical units.
	 */
	private IMapMode getMapMode() {
		return (IMapMode) getMapModeConstants().mapModeRef.get();
	}

	private MapModeConstants getMapModeConstants() {
		if (mapModeConstants == null) {
			IMapMode mapMode = MapModeUtil.getMapMode(this);
			while (mapMode instanceof IMapModeHolder) {
				mapMode = ((IMapModeHolder) mapMode).getMapMode();
			}
			mapModeConstants = (MapModeConstants) mapModeConstantsMap
				.get(mapMode);
			if (mapModeConstants == null) {
				mapModeConstants = new MapModeConstants(mapMode);
				mapModeConstantsMap.put(mapMode, mapModeConstants);
			}
		}
		return mapModeConstants;
d235 1
d238 1
a238 1
				loc.y = getInsets().top;
d241 1
a241 1
				loc.y = bounds.height - size.height - getInsets().bottom;
d249 1
d252 1
a252 1
				loc.x = getInsets().left;
d255 1
a255 1
				loc.x = bounds.width - size.width - getInsets().right;
d262 3
a264 2
	private void calculateAlignment(Dimension iconSize, int textPlacement) {
		switch (textPlacement) {
d288 4
d293 3
a295 11
		boolean isEmpty = (iconSize.width == 0 && iconSize.height == 0);
		int len = getText().length();
		if (len == 0 && isEmpty) {
			return new Dimension(txtSize.width, txtSize.height);
		}
		int gap = (len == 0 || isEmpty) ? 0
			: getIconTextGap();
		int placement = getTextPlacement();
		if (placement == WEST || placement == EAST) {
			return new Dimension(iconSize.width + gap + txtSize.width, Math
				.max(iconSize.height, txtSize.height));
d297 2
a298 2
			return new Dimension(Math.max(iconSize.width, txtSize.width),
				iconSize.height + gap + txtSize.height);
d300 1
a305 12
		Dimension iconSize = getTotalIconSize();
		int textPlacement = getTextPlacement();
		calculatePlacement(iconSize, textPlacement);
		calculateAlignment(iconSize, textPlacement);
		Rectangle r = getBounds();
		Dimension ps = getPreferredSize(r.width, r.height);
		int w = (r.width - ps.width)
			+ (getTextSize().width - getSubStringTextSize().width);
		int h = r.height - ps.height;
		if (w == 0 && h == 0) {
			return;
		}
d307 5
a311 1
		Dimension offset = new Dimension(w, h);
d335 1
a335 1
		switch (textPlacement) {
d350 4
a353 3
	private void calculatePlacement(Dimension iconSize, int textPlacement) {
		int gap = (getText().length() == 0 || (iconSize.width == 0 && iconSize.height == 0)) ? 0
			: getIconTextGap();
d355 3
a357 1
		switch (textPlacement) {
d376 1
d387 1
a387 2
		Font f = getFont();
		return getTextExtents(getSubStringText(), f, getMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight())); 
d402 1
a402 2
		Font f = getFont();
		return getTextExtents(getWrappedText(wHint, hHint), f,getMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight()));
d437 1
a437 1
		return (getNumberofIcons() > 0);
d481 1
a481 1
		return getMapModeConstants().nDPtoLP_3;
d491 5
a495 7
		LayoutManager layoutManager = getLayoutManager();
		if (layoutManager != null)
			minSize.setSize(layoutManager.getMinimumSize(this, w, h));
		Font f = getFont();
		Dimension d = getEllipseTextSize().intersect(
			getTextExtents(getText(), f, getMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight())));		
		
d508 1
a508 1
		if (prefSize == null || wHint != cachedPrefSizeHint_width || hHint != cachedPrefSizeHint_height) {
d512 2
a513 3
			LayoutManager layoutManager = getLayoutManager();
			if (layoutManager != null) {
				prefSize.union(layoutManager.getPreferredSize(this, wHint,
a514 1
			}
d516 2
a517 2
			cachedPrefSizeHint_width = wHint;
			cachedPrefSizeHint_height = hHint;
d540 2
a541 8
		
		String theText = getText();
		int textLen = theText.length();
		if (textLen == 0) {
			return subStringText = "";//$NON-NLS-1$;;
		}
		Dimension size = getSize();
		Dimension shrink = getPreferredSize(size.width, size.height).getDifference(size);
a543 4
		if (effectiveSize.height == 0) {
			return subStringText = "";//$NON-NLS-1$;
		}
		
d545 1
a545 4
		FontMetrics metrics = FigureUtilities.getFontMetrics(f);
		IMapMode mm = getMapMode();
		int fontHeight = mm.DPtoLP(metrics.getHeight());
		int charAverageWidth = mm.DPtoLP(metrics.getAverageCharWidth());
a546 3
		if (maxLines == 0) {
			return subStringText = "";//$NON-NLS-1$
		}
d549 1
a549 5
		StringBuffer remainingText = new StringBuffer(theText);
		
		int effectiveSizeWidth = effectiveSize.width;
		int widthHint = Math.max(effectiveSizeWidth
			- getEllipseTextSize().width, 0);
d551 1
d553 1
a553 1
			i = getLineWrapPosition(remainingText.toString(), f, effectiveSizeWidth, fontHeight);
d556 1
a556 1
				accumlatedText.append('\n');
d558 3
a560 2
			if (i == 0 || (remainingText.length() > i && j == maxLines)) {				
				i = getLargestSubstringConfinedTo(remainingText.toString(), f, widthHint, fontHeight, charAverageWidth);
d569 1
a569 4
	
	
	
	
d577 1
a577 1
	 */	
d579 2
a580 3
		String theText = getText();		
		if (wHint == -1 || theText.length() == 0 || !isTextWrapped())
			return theText;
d583 1
a583 1
		if (!(iconSize.width == 0 && iconSize.height == 0)) {
a596 5
		
		if ((hHint == 0)||(wHint == 0)) {
			return "";//$NON-NLS-1$;
		}
		
a597 1
		int fontHeight = getMapMode().DPtoLP(FigureUtilities.getFontMetrics(f).getHeight());
d599 2
a600 1
		if (hHint != -1) {			
d602 2
a603 5
			if (maxLines == 0) {
				return "";//$NON-NLS-1$;;
			}
		}	
		
d605 1
a605 1
		StringBuffer remainingText = new StringBuffer(theText);
d609 1
a609 1
			if ((i = getLineWrapPosition(remainingText.toString(), f, wHint, fontHeight)) == 0)
d613 1
a613 1
				accumlatedText.append('\n');
a630 16
	
	/**
	 * Returns the size of the String constant "..." the ellipse based on
	 * the currently used Map mode
	 * size.
	 * 
	 * @@return the size of ellipse text
	 * 
	 */
	private Dimension getEllipseTextSize() {
		if (ellipseTextSize == null) {
			ellipseTextSize = getMapModeConstants().getEllipseTextSize(
				getFont());
		}
		return ellipseTextSize;
	}
d715 1
a715 1
		if (textSize == null || wHint != cachedTextSizeHint_width || hHint != cachedTextSizeHint_height) {
d717 2
a718 2
			cachedTextSizeHint_width = wHint;
			cachedTextSizeHint_height= hHint;
d726 2
a727 3
	private final Dimension getTextSize() {		
		Rectangle r = getBounds();
		return getTextSize(r.width, r.height);		
a736 1
		ellipseTextSize = null;
d782 6
a787 11
		String subString = getSubStringText();
		if (subString.length() > 0) {
			if (!isEnabled()) {
				graphics.translate(1, 1);
				graphics.setForegroundColor(ColorConstants.buttonLightest);
				paintText(graphics, subString);
				graphics.translate(-1, -1);
				graphics.setForegroundColor(ColorConstants.buttonDarker);
			} else {
				paintText(graphics, subString);
			}
d789 1
d797 3
a799 3
	 * @@param subString The string to draw
	 */	
	private void paintText(Graphics graphics, String subString) {		
d801 1
d803 5
a807 13
		FontMetrics fontMetrics = FigureUtilities.getFontMetrics(f);
		int fontHeight = getMapMode().DPtoLP(fontMetrics.getHeight());
		int fontHeightHalf = fontHeight / 2;
		int textWidth = getTextExtents(subString, f, fontHeight).width;
		Point p = getTextLocation();
		int y = p.y;
		int x = p.x;
		final int wrapAlignment = getTextWrapAlignment();
		boolean isUnderlined = isTextUnderlined();
		boolean isStrikedThrough = isTextStrikedThrough();
		Rectangle clipRect = new Rectangle();
		graphics.getClip(clipRect);
		int clipRectTopRight_x = clipRect.getTopRight().x;
d810 3
a812 2
		if (0 == fontMetrics.getLeading()) {
			y +=  getMapModeConstants().nDPtoLP_2; // 2 is the leading area for default English			
d817 3
a819 3
			int tokenWidth = getTextExtents(token, f, fontHeight).width;
			
			switch (wrapAlignment) {
d830 2
d833 1
a833 2
			
			if (tokenWidth + x <= clipRectTopRight_x) {
d844 1
a844 1
			if (isUnderlined)
d846 3
a848 3
			if (isStrikedThrough)
				graphics.drawLine(x, y - fontHeightHalf + 1, x + tokenWidth, y
					- fontHeightHalf + 1);
d888 9
a896 25
		if (iconInfo == null) {
			if (index == 0) {
				iconInfo = getMapModeConstants().getSingleIconInfo(image);
			} else {
				iconInfo = new MultiIconInfo();
				iconInfo.setIcon(image, index);
			}
			revalidate();
			repaint();// Call repaint, in case the image dimensions are the same.           
		} else if (iconInfo.getIcon(index) != image) {
			if (iconInfo.getMaxIcons() == 1) {
				if (index == 0) {
					iconInfo = getMapModeConstants().getSingleIconInfo(image);
					revalidate();
					repaint();// Call repaint, in case the image dimensions are the same.
					return;
				}
				IconInfo oldIconInfo = iconInfo;
				iconInfo = new MultiIconInfo();
				iconInfo.setIcon(oldIconInfo.getIcon(0), 0);
			}
			iconInfo.setIcon(image, index);
			revalidate();
			repaint();// Call repaint, in case the image dimensions are the same.
		}	
d926 1
a926 1
		return iconInfo.getIconSize(getMapMode(), index);
d947 1
a947 1
		return iconInfo.getTotalIconSize(getMapMode());
d1097 1
a1097 2
		 */
	}
d1258 3
a1260 2
		int expansion = getMapModeConstants().nDPtoLP_2;
		figBounds.resize(expansion, expansion);
a1272 1
	 * @@param fontHeight int <b>mapped already to logical units</b>.
d1274 1
a1274 4
	private int getLineWrapPosition(String s, Font f, int w, int fontHeight) {
		if (getTextExtents(s, f, fontHeight).width <= w) {
			return s.length();
		}
d1283 1
a1283 1
		if (getTextExtents(s.substring(start, end), f, fontHeight).width > w) {
d1293 1
a1293 1
			&& getTextExtents(s.substring(start, end), f, fontHeight).width <= w);
d1296 1
a1296 1
	}	
a1304 2
	 * @@param fontHeight int <b>mapped already to logical units</b>.
	 * @@param charAverageWidth int <b>mapped already to logical units</b>.
d1308 6
a1313 4
	private int getLargestSubstringConfinedTo(String s, Font f, int w, int fontHeight, int charAverageWidth) {		
		float avg = charAverageWidth;
		int min = 0;
		int max = s.length() + 1;
d1329 1
a1329 1
			guessSize = getTextExtents(s.substring(0, guess), f, fontHeight).width;
d1344 8
a1351 12
	private Dimension getTextExtents(String s, Font f, int fontHeight) {
		if (s.length() == 0) {
			return getMapModeConstants().dimension_nDPtoLP_0;
		} else {
			// height should be set using the font height and the number of
			// lines in the string			
			Dimension d = FigureUtilities.getTextExtents(s, f);
			IMapMode mapMode = getMapMode();
			d.width = mapMode.DPtoLP(d.width);
			d.height = fontHeight * new StringTokenizer(s, "\n").countTokens();//$NON-NLS-1$
			return d;			
		}
d1354 4
a1357 1
    
@


1.9.2.2
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.9.2.3
log
@Bugzilla#157880 gmf_R1_0_maintenance crevells 060919 WrapLabel returns incorrect minimum size
@
text
@d768 1
a768 1
		Dimension d = getEllipseTextSize().getIntersected(
@


1.8
log
@bugzilla 135968 gmf-head mmostafa 060505 Multi-line text not working with WrapLabel
@
text
@d1356 1
a1356 4
        int count = tokenizer.countTokens();
        if(count==0 && s.length()>0)
            count++;
        return count;
@


1.7
log
@bugzilla 137155 gmf-head mmostafa 060503 DBCS3.2: DBCS note is not displayed on RHEL4
@
text
@d1346 5
a1350 3
        // hieght should be set using the font hight not the string height
        d.height = FigureUtilities.getFontMetrics(f).getHeight();
		return new Dimension(MapModeUtil.getMapMode(this).DPtoLP(d.width), 
d1353 8
@


1.6
log
@[112794] gmf_head etworkowska 060126 Adopt ICU4J as part of Eclipse 3.2
@
text
@d1346 2
@


1.5
log
@bugzilla 110316 gmf-head 051212 Compiler warning count should be 0 - runtime diagram layer
@
text
@a13 1
import java.text.BreakIterator;
a14 1
import java.util.StringTokenizer;
d29 3
@


1.4
log
@bugzilla 112788 gmf-head sshaw 051104 API: Encapsulate MapMode / HiMetric coordinate system from clients
@
text
@a21 1
import org.eclipse.draw2d.IFigure;
@


1.3
log
@bugzilla 111830 gmf-head sshaw 051007 Text is clipped when setting to Italic with certain last characters
@
text
@d28 1
a31 2
import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapMode;

d96 1
a96 1
	private static class IconInfo {
d141 3
a143 2
				org.eclipse.swt.graphics.Rectangle bounds = img.getBounds();
				return new Dimension(MapMode.DPtoLP(bounds.width), MapMode.DPtoLP(bounds.height));
d481 1
a481 1
		return MapMode.DPtoLP(3);
d545 1
a545 1
		int fontHeight = MapMode.DPtoLP(FigureUtilities.getFontMetrics(f).getHeight());
d600 1
a600 1
			int fontHeight = MapMode.DPtoLP(FigureUtilities.getFontMetrics(f).getHeight());
d803 1
a803 1
		int fontHeight = MapMode.DPtoLP(FigureUtilities.getFontMetrics(f)
d811 1
a811 1
			int offset = MapMode.DPtoLP(2); // 2 is the leading area for default English
d832 2
a833 1
			if (getTextExtents(token, f).width + x <= clipRect.getTopRight().x) {
d835 1
a835 1
				newClipRect.width += getTextExtents(token.substring(token.length() - 1), f).width / 2;
d1259 2
a1260 1
			.expand(new Insets(MapMode.DPtoLP(2), MapMode.DPtoLP(2), 0, 0));
d1274 1
a1274 1
	private static int getLineWrapPosition(String s, Font f, int w) {
d1308 1
a1308 1
	private static int getLargestSubstringConfinedTo(String s, Font f, int w) {
d1310 1
a1310 1
		float avg = MapMode.DPtoLP(FigureUtilities.getFontMetrics(f)
d1344 1
a1344 1
	private static Dimension getTextExtents(String s, Font f) {
d1346 2
a1347 1
		return new Dimension(MapMode.DPtoLP(d.width), MapMode.DPtoLP(d.height));
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d827 11
d839 2
d1343 1
a1343 1
		Dimension d = FigureUtilities.getTextExtents(s, f).expand(-1, 0);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 2
a2 2
/*******************************************************************************
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d9 3
a11 2
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
@

