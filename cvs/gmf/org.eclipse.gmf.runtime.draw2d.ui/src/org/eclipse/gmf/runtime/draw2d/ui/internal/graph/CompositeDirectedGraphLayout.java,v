head	1.6;
access;
symbols
	v20081023-2107:1.6
	v20081022-1925:1.6
	v20081021-1810:1.6
	v20081020-0700:1.6
	v20080911-1728:1.6
	v20080911-1506:1.6
	v20080910-1520:1.6
	v20080910-1510:1.6
	v20080903-1520:1.6
	v20080903-1510:1.6
	v20080722-1827:1.6
	R2_1_maintenance:1.6.0.2
	Root_R2_1_maintenance:1.6
	R2_1_0:1.6
	v20080610-1132:1.6
	v20080603-1553:1.6
	v20080512-1200:1.6
	v20080503-1740:1.6
	v20080501-1739:1.6
	v20080425-1959:1.6
	v20080417-1610:1.6
	v20080407-2250:1.6
	v20080407-0930:1.6
	v20080404-1111:1.6
	v20080222-1200:1.5
	v20080215-1500:1.5
	v20080215-1200:1.3
	v20080201-2010:1.4
	v20080114-1111:1.3
	v20071108-0000:1.3
	v20071003-0000:1.3
	v20070928-0000:1.3
	v20070915-0000:1.3
	v20070903-0000:1.3
	v20070830-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	v20070621-0000:1.3
	RC3_20:1.3
	v20070605-1400:1.3
	v20070601-1400:1.3
	v20070518-1300:1.3
	v20070330-1300:1.3
	v20070221-1500:1.3
	v20070208-1800:1.3
	v20070202-0200:1.2.2.1
	M4_20:1.3
	v20061218-1200:1.3
	v20061214-0000:1.3
	M3_20:1.3
	v20061013-1330:1.3
	v20060925-1700:1.2.2.1
	v20060919-0800:1.2.2.1
	M1_20:1.2
	v20060824-1600:1.2.2.1
	v20060817-1500:1.2.2.1
	v20060810-1700:1.2.2.1
	v20060803-1200:1.2.2.1
	v20060728-0500:1.2
	v20060721-1130:1.2
	v20060713-1700:1.2
	R1_0_maintenance:1.2.0.2
	R1_0:1.2
	v20060627-1200:1.2
	v20060616-1200:1.2
	v20060609-1400:1.2
	v20060531-1730:1.2
	v20060519-0800:1.2
	RC2_10:1.2
	I20060505-1400:1.2
	I20060428-1300:1.2
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.1;
locks; strict;
comment	@# @;


1.6
date	2008.04.03.16.30.10;	author aboyko;	state Exp;
branches;
next	1.5;
commitid	3e0347f506114567;

1.5
date	2008.02.04.21.03.03;	author aboyko;	state Exp;
branches;
next	1.4;
commitid	50f847a77d874567;

1.4
date	2008.01.14.20.43.02;	author crevells;	state Exp;
branches;
next	1.3;
commitid	4961478bc9564567;

1.3
date	2006.10.03.15.04.52;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.01.16.02.37;	author mmostafa;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.02.24.23.29.28;	author mmostafa;	state Exp;
branches;
next	;

1.2.2.1
date	2006.08.01.18.18.16;	author mmostafa;	state Exp;
branches;
next	;


desc
@@


1.6
log
@[225437] gmf_head aboyko 080403 Layout improvements
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.draw2d.ui.internal.graph;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.draw2d.PositionConstants;
import org.eclipse.draw2d.geometry.Insets;
import org.eclipse.draw2d.graph.DirectedGraph;
import org.eclipse.draw2d.graph.DirectedGraphLayout;
import org.eclipse.draw2d.graph.Edge;
import org.eclipse.draw2d.graph.EdgeList;
import org.eclipse.draw2d.graph.Node;
import org.eclipse.draw2d.graph.NodeList;
import org.eclipse.draw2d.graph.Subgraph;
import org.eclipse.gmf.runtime.draw2d.ui.graph.GMFDirectedGraphLayout;



/**
 * @@author mmostafa
 * 
 * Composite layout that layout the passed graph in a recursive fashion 
 *
 */
public class CompositeDirectedGraphLayout
    extends DirectedGraphLayout {
	
	private int graphDirection = PositionConstants.SOUTH;

    /* (non-Javadoc)
     * @@see org.eclipse.draw2d.graph.DirectedGraphLayout#visit(org.eclipse.draw2d.graph.DirectedGraph)
     */
    public void visit(DirectedGraph graph) {
		graphDirection = graph.getDirection();
		layoutNodes(graph.nodes, false);
	}
    
    private void layoutNodes(NodeList nodes, boolean virtualPass) {
        EdgeList edges = new EdgeList();
        for (Iterator iter = nodes.iterator(); iter.hasNext();) {
            Node element = (Node) iter.next();
            if (element instanceof Subgraph && !(element instanceof VirtualNode)){
                layoutNodes(((Subgraph)element).members,virtualPass);
            }
            for (Iterator edgesIter = element.outgoing.iterator(); edgesIter.hasNext();) {
                Edge edge = (Edge)edgesIter.next();
                if (nodes.contains(edge.target)){
                    edges.add(edge);
                }
            }
        }
        if (!virtualPass){
            virtualNodesToNodes virtualNodesNodes = new virtualNodesToNodes();
            createVirtualNodes(nodes, edges, virtualNodesNodes);
            NodeList vituralNodes = virtualNodesNodes.getVirtualNodes();
            int size = vituralNodes.size();
            if (size > 0){
                edges = virtualNodesNodes.getEdges();
                for (Iterator iter = vituralNodes.iterator(); iter.hasNext();) {
                    Subgraph virtualNode = (Subgraph) iter.next();
                    layoutNodes(virtualNode.members, true);
                }
                adjustVirtualNodesWidthAndHeight(vituralNodes);
            }
        }
        Map nodeToOutGoing = new HashMap();
        Map nodeToIncomingGoing = new HashMap();
        removeDisconnectedEdges(nodes, nodeToOutGoing, nodeToIncomingGoing);
        if (nodes.size() > 0){
            Node parent  = getParent(nodes.getNode(0));
            DirectedGraph g = new DirectedGraph();
            g.nodes = nodes;
            g.edges = edges;
            AdvancedSubGraph advancedSubgraphParent = parent instanceof AdvancedSubGraph ? (AdvancedSubGraph)parent : null;
            if (advancedSubgraphParent != null) {
           		g.setDirection(advancedSubgraphParent.getDirection());
            } else {
            	g.setDirection(graphDirection);            	
            }
            DirectedGraphLayout layout = new GMFDirectedGraphLayout();
            layout.visit(g);
            if (advancedSubgraphParent != null && advancedSubgraphParent.isAutoSize()) {
                advancedSubgraphParent.width = g.getLayoutSize().width;
                advancedSubgraphParent.height = g.getLayoutSize().height;
            }
        }
        
        restoreDisconnectedEdges(nodeToOutGoing, nodeToIncomingGoing);
    }

    private void restoreDisconnectedEdges(Map nodeToOutGoing, Map nodeToIncomingGoing) {
        restoreEdges(nodeToOutGoing.entrySet(),true);
        restoreEdges(nodeToIncomingGoing.entrySet(),false);
    }

    private void removeDisconnectedEdges(NodeList nodes, Map nodeToOutGoing, Map nodeToIncomingGoing) {
        for (Iterator iter = nodes.iterator(); iter.hasNext();) {
            Node element = (Node) iter.next();
            pushExtraEdges(nodes, nodeToOutGoing, element, element.outgoing,false);
            pushExtraEdges(nodes, nodeToIncomingGoing, element, element.incoming,true);
        }
    }

    private void createVirtualNodes(NodeList nodes, EdgeList edges, virtualNodesToNodes virtualNodesNodes) {
        Set handledEdges = new HashSet();
        recursiveHandleVirtualNode(nodes, edges, virtualNodesNodes, handledEdges, new HashSet(nodes));
    }

    private void recursiveHandleVirtualNode(NodeList nodes, EdgeList edges, virtualNodesToNodes virtualNodesNodes, Set handledEdges, Set nodesSnapeShot) {
        for (Iterator edgeIter = edges.iterator(); edgeIter.hasNext();) {
            Edge element = (Edge) edgeIter.next();
            if (handledEdges.contains(element))
                continue;
            handledEdges.add(element);
            if (!nodesSnapeShot.contains(element.source) || !nodesSnapeShot.contains(element.target))
                continue;
            Node source = element.source;
            Node target = element.target;
            boolean sourceHandled = true;
            boolean targetHandled = true;
            Subgraph sg = virtualNodesNodes.getVirtualContainer(source);
            Subgraph sg1 = virtualNodesNodes.getVirtualContainer(target);
            if (sg==null){
                sourceHandled = false;
                sg = sg1;
            }
            if (sg1==null)
                targetHandled = false;
            if (sourceHandled == false && targetHandled==false){
                sg = new VirtualNode(null,source.getParent());
                sg.setPadding(new Insets(30));
                if (source.getParent()==null)
                    nodes.add(sg);
            }
            if (!sourceHandled){
                addNode(sg, source, nodes);
                virtualNodesNodes.addNode(sg, source);
            }
            if (!targetHandled){
                addNode(sg, target, nodes);
                virtualNodesNodes.addNode(sg, target);
            }
            // order is important; so we should start handling the outgoing and the incoming
            // edges only after the source and target had been handled
            if (!sourceHandled){
                recursiveHandleVirtualNode(nodes,source.outgoing,virtualNodesNodes,handledEdges,nodesSnapeShot);
                recursiveHandleVirtualNode(nodes,source.incoming,virtualNodesNodes,handledEdges,nodesSnapeShot);
            }
            if (!targetHandled){
                recursiveHandleVirtualNode(nodes,target.outgoing,virtualNodesNodes,handledEdges,nodesSnapeShot);
                recursiveHandleVirtualNode(nodes,target.incoming,virtualNodesNodes,handledEdges,nodesSnapeShot);
            }
        }
    }

    private void pushExtraEdges(NodeList nodes, Map nodeToIncomingGoing, Node element, List list,boolean sourceCheck) {
        List edges = new ArrayList();
        for (Iterator iterator = list.iterator() ; iterator.hasNext();) {
            Edge edge = (Edge) iterator.next();
            Node nodeToCheck = sourceCheck ? edge.source : edge.target;
            if (!nodes.contains(nodeToCheck)){
                edges.add(edge);
                iterator.remove();
                Node sourceNode = null;
                Node targetNode = null;
                sourceNode = getParent(edge.source);
                targetNode = getParent(edge.target);
                sourceNode = (!sourceCheck || sourceNode!=null )? sourceNode : edge.source;
                targetNode = ( sourceCheck || targetNode!=null)? targetNode : edge.target;
                if (!sourceCheck &&
                    sourceNode!= null && targetNode!=null && sourceNode!=targetNode &&
                    (edge.source!=sourceNode || edge.target!=targetNode)){
                    Edge virtualEdge = new Edge(sourceNode,
                                                targetNode,
                                                edge.getDelta(),
                                                edge.weight);
                    virtualEdge.setPadding(edge.getPadding());
                }
            }
        }
        if (!edges.isEmpty())
            nodeToIncomingGoing.put(element,edges);
    }

    private Node getParent(Node node) {
        Node parent  = node.getParent();
        if (parent != null && parent instanceof VirtualNode)
            parent = parent.getParent();
        return parent;
    }

    private void restoreEdges(Set entries, boolean outgoing) {
        for (Iterator iter = entries.iterator(); iter.hasNext();) {
            Map.Entry entry =   (Map.Entry) iter.next();
            Node node = (Node)entry.getKey();
            List edgesList = (List)entry.getValue();
            for (Iterator iterator = edgesList.iterator(); iterator.hasNext();) {
                Edge edgeToRestore = (Edge) iterator.next();
                if (outgoing)
                    node.outgoing.add(edgeToRestore);
                else
                    node.incoming.add(edgeToRestore);
            }
            
        }
    }

    private void adjustVirtualNodesWidthAndHeight(NodeList vituralNodes) {
        for (Iterator iter = vituralNodes.iterator(); iter.hasNext();) {
            Subgraph subGraph = (Subgraph) iter.next();
            adjustVirtualNodeWidthAndHeight(subGraph);
        }
        
    }

    private void adjustVirtualNodeWidthAndHeight(Subgraph subGraph) {
       NodeList nodes = subGraph.members;
       if (nodes.isEmpty())
           return;
       int size = nodes.size();
       Node node = nodes.getNode(0);
       int top=node.y,left=node.x,bottom = top + node.height ,right = left+node.width;
       for (int index = 1 ; index<size; index++) {
           node = (Node)nodes.get(index);
           if (top>node.y)
               top = node.y;
           if (bottom < (node.y+node.height))
               bottom = node.y+node.height;
           if (left>node.x)
               left = node.x;
           if (right<(node.x+node.width))
               right = node.x+node.width;
       }
       subGraph.width = right - left;
       subGraph.height = bottom - top;
     }
    
    /**
     * If the node passed in is in autosize mode, then this method will set the
     * width and height of this node based on how its children/members were
     * arranged.
     * 
     * @@param subGraph
     *            the node whose size will be adjusted
     */
//    private void adjustAutoSizeNodeWidthAndHeight(AdvancedSubGraph subGraph) {
//    	if (!subGraph.isAutoSize()) {
//    	    return;
//    	}
//        NodeList nodes = subGraph.members;
//        if (nodes.isEmpty())
//            return;
//        int size = nodes.size();
//        Node node = nodes.getNode(0);
//        int top=node.y,left=node.x,bottom = top + node.height ,right = left+node.width;
//        Node topNode, leftNode;
//        topNode = leftNode = node;
//        for (int index = 1 ; index<size; index++) {
//            node = (Node)nodes.get(index);
//            if (top>node.y){
//                top = node.y;
//                topNode = node;
//            }
//            if (bottom < (node.y+node.height))
//                bottom = node.y+node.height;
//            if (left>node.x){
//                left = node.x;
//                leftNode = node;
//            }
//            if (right<(node.x+node.width))
//                right = node.x+node.width;
//        }
//        int xDiff = 0 ;
//        int yDiff = 0 ;
//        if (subGraph.isHasBufferedZone()){
//             xDiff = leftNode.x;
//             yDiff = topNode.y ;
//        }
//        subGraph.width = right - left + xDiff;
//        subGraph.height = bottom - top + yDiff;
//        
//    }

    private void addNode(Subgraph parent, Node node, NodeList nodes) {
        if (node.getParent()!=null)
            node.getParent().members.remove(node);
        node.setParent(parent);
        parent.addMember(node);
        nodes.remove(node);
    }
    
    private class virtualNodesToNodes extends HashMap{
        Set virtualNodes = new HashSet();
        public void addNode(Subgraph sg, Node node){
            virtualNodes.add(sg);
            put(node, sg);
        }
        
        public EdgeList getEdges() {
            EdgeList edges = new EdgeList();
            for (Iterator iter = virtualNodes.iterator(); iter.hasNext();) {
                Node element = (Node) iter.next();
                for (Iterator iterator = element.outgoing.iterator(); iterator
                    .hasNext();) {
                    Edge edge = (Edge) iterator.next();
                    if (virtualNodes.contains(edge.target))
                        edges.add(edge);
                    
                }
            }
            return edges;
        }

        public Subgraph getVirtualContainer(Node node){
            return (Subgraph)get(node);
        }
        
        public NodeList getVirtualNodes(){
            NodeList nodeList = new NodeList();
            nodeList.addAll(virtualNodes);
            return nodeList;
        }
    }
}
@


1.5
log
@[217749] gmf_head aboyko 080204 [Layout] Layout providers using Draw2D graph layout don't deliver the exact results to the diagram
@
text
@d31 1
d91 1
a91 1
            if (advancedSubgraphParent != null && advancedSubgraphParent.getDirection() != PositionConstants.NONE) {
d96 1
a96 1
            DirectedGraphLayout layout = new DirectedGraphLayout();
d98 3
a100 2
            if (advancedSubgraphParent != null) {
                adjustAutoSizeNodeWidthAndHeight(advancedSubgraphParent);
d262 37
a298 37
    private void adjustAutoSizeNodeWidthAndHeight(AdvancedSubGraph subGraph) {
    	if (!subGraph.isAutoSize()) {
    	    return;
    	}
        NodeList nodes = subGraph.members;
        if (nodes.isEmpty())
            return;
        int size = nodes.size();
        Node node = nodes.getNode(0);
        int top=node.y,left=node.x,bottom = top + node.height ,right = left+node.width;
        Node topNode, leftNode;
        topNode = leftNode = node;
        for (int index = 1 ; index<size; index++) {
            node = (Node)nodes.get(index);
            if (top>node.y){
                top = node.y;
                topNode = node;
            }
            if (bottom < (node.y+node.height))
                bottom = node.y+node.height;
            if (left>node.x){
                left = node.x;
                leftNode = node;
            }
            if (right<(node.x+node.width))
                right = node.x+node.width;
        }
        int xDiff = 0 ;
        int yDiff = 0 ;
        if (subGraph.isHasBufferedZone()){
             xDiff = leftNode.x;
             yDiff = topNode.y ;
        }
        subGraph.width = right - left + xDiff;
        subGraph.height = bottom - top + yDiff;
        
    }
@


1.4
log
@[151214] gmf_head crevells 080114 [Layout] Arrange All should be a projection (P*P = P)
@
text
@d22 1
d42 2
d49 3
a51 2
            layoutNodes(graph.nodes, false);
    }
d89 6
d97 3
a99 2
            if (parent instanceof AdvancedSubGraph)
                adjustAutoSizeNodeWidthAndHeight((AdvancedSubGraph)parent);
@


1.3
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
a76 1
        int nodesSize = nodes.size();
d80 1
a80 1
        if (nodesSize >= 2){
a88 4
        }else if (nodesSize==1){
            Node parent  = getParent(nodes.getNode(0));
            if (parent instanceof AdvancedSubGraph)
                adjustAutoSizeNodeWidthAndHeight((AdvancedSubGraph)parent);
d241 8
d250 3
a252 1
    	
d283 1
a283 1
        subGraph.width = right - left + yDiff;
@


1.2
log
@bugzilla 129798 gmf-head mmostafa 060301 CompositeLayout: Connecting cycle to other node causes layout to fail
@
text
@d68 1
a68 3
/*            if (size==1 && nodes.size()==1){
                nodes = ((VirtualNode)vituralNodes.get(0)).members;
            }else*/ if (size > 0){
a80 1
                 
d82 1
d88 6
d245 36
@


1.2.2.1
log
@[130329] gmf_R1_0_maintenance mmostafa  060801 CompositeLayoutProvider: auto-sized containers new size doesn't get considered
@
text
@d68 3
a70 1
            if (size > 0){
d83 1
a84 1
            Node parent  = getParent(nodes.getNode(0));
a89 6
            if (parent instanceof AdvancedSubGraph)
                adjustAutoSizeNodeWidthAndHeight((AdvancedSubGraph)parent);
        }else if (nodesSize==1){
            Node parent  = getParent(nodes.getNode(0));
            if (parent instanceof AdvancedSubGraph)
                adjustAutoSizeNodeWidthAndHeight((AdvancedSubGraph)parent);
a240 36
    
    private void adjustAutoSizeNodeWidthAndHeight(AdvancedSubGraph subGraph) {
    	
        NodeList nodes = subGraph.members;
        if (nodes.isEmpty())
            return;
        int size = nodes.size();
        Node node = nodes.getNode(0);
        int top=node.y,left=node.x,bottom = top + node.height ,right = left+node.width;
        Node topNode, leftNode;
        topNode = leftNode = node;
        for (int index = 1 ; index<size; index++) {
            node = (Node)nodes.get(index);
            if (top>node.y){
                top = node.y;
                topNode = node;
            }
            if (bottom < (node.y+node.height))
                bottom = node.y+node.height;
            if (left>node.x){
                left = node.x;
                leftNode = node;
            }
            if (right<(node.x+node.width))
                right = node.x+node.width;
        }
        int xDiff = 0 ;
        int yDiff = 0 ;
        if (subGraph.isHasBufferedZone()){
             xDiff = leftNode.x;
             yDiff = topNode.y ;
        }
        subGraph.width = right - left + xDiff;
        subGraph.width = right - left + yDiff;
        
    }
@


1.1
log
@bugzilla 110698 gmf-head mmostafa 060224 Auto-layout doesn't layout out connections between nested nodes and top level nodes
@
text
@d53 1
a53 1
            if (element instanceof Subgraph){
d65 1
a65 29
            for (Iterator edgeIter = edges.iterator(); edgeIter.hasNext();) {
                Edge element = (Edge) edgeIter.next();
                Node source = element.source;
                Node target = element.target;
                boolean sourceHandled = true;
                boolean targetHandled = true;
                Subgraph sg = virtualNodesNodes.getVirtualContainer(source);
                Subgraph sg1 = virtualNodesNodes.getVirtualContainer(target);
                if (sg==null){
                    sourceHandled = false;
                    sg = sg1;
                }
                if (sg1==null)
                    targetHandled = false;
                if (sourceHandled == false && targetHandled==false){
                    sg = new VirtualNode(null,source.getParent());
                    sg.setPadding(new Insets(30));
                    if (source.getParent()==null)
                        nodes.add(sg);
                }
                if (!sourceHandled){
                    addNode(sg, source, nodes);
                    virtualNodesNodes.addNode(sg, source);
                }
                if (!targetHandled){
                    addNode(sg, target, nodes);
                    virtualNodesNodes.addNode(sg, target);
                }
            }
d68 1
a68 2
            // todo consider the commented out optimization later
            /*if (size==1 && nodes.size()==1){
d70 6
a75 4
            }else */
            if (size > 0){
                edges.clear();
                layoutNodes(vituralNodes, true);
a76 1
                
d79 1
a79 1
        
d82 1
a82 7
        int nodesSize = nodes.size();
        for (Iterator iter = nodes.iterator(); iter.hasNext();) {
            Node element = (Node) iter.next();
            pushExtraEdges(nodes, nodeToOutGoing, element, element.outgoing,false);
            if (nodesSize>0)
                pushExtraEdges(nodes, nodeToIncomingGoing, element, element.incoming,true);
        }
d84 1
a84 2
        if (nodesSize >= 2 ||
            (nodesSize==1 && nodes.get(0) instanceof Subgraph )){
d86 2
a87 2
            g.nodes = nodes/*cloneNodeList(nodes)*/;
            g.edges = edges/*cloneEdgeList(edges)*/;
d92 4
d97 61
a157 2
        if (nodesSize>0)
            restoreEdges(nodeToIncomingGoing.entrySet(),false);
d168 6
d175 4
a178 3
                    edge.source.getParent()!=  edge.target.getParent()){
                    Edge virtualEdge = new Edge(edge.source.getParent(),
                                                edge.target.getParent(),
a183 1
            
d189 7
d257 15
a281 57
    
/*    private NodeList cloneNodeList(NodeList source){
        NodeList list = new NodeList();
        for (Iterator iter = source.iterator(); iter.hasNext();) {
            Node element = (Node) iter.next();
            Node newNode = null;
            if (element instanceof Subgraph)
                newNode = cloneSubgraph((Subgraph)element);
            else
                newNode = cloneNode(element);
            list.add(newNode);
        }
        return list;
    }
    
    private Node cloneSubgraph(Subgraph element) {
        Subgraph sg = null;
        if (element instanceof VirtualNode)
            sg = new VirtualNode(element.data);
        else
            sg = new Subgraph(element.data);
        sg.x = element.x;
        sg.y = element.y;
        sg.height = element.height;
        sg.width = element.width;
        sg.setPadding(element.getPadding());
        return sg;
    }

    private Node cloneNode(Node element) {
        Node node = null;
        node = new Node(element.data);
        node.x = element.x;
        node.y = element.y;
        node.height = element.height;
        node.width = element.width;
        node.setPadding(element.getPadding());
        return node;
    }

    private EdgeList cloneEdgeList(EdgeList source){
        EdgeList list = new EdgeList();
        for (Iterator iter = source.iterator(); iter.hasNext();) {
            Edge element = (Edge) iter.next();
            list.add(cloneEdge(element));
        }
        return list;
    }

    private Edge cloneEdge(Edge element) {
        Edge edge = new Edge(element.source,element.target,element.getDelta(),element.weight);
        edge.data = element.data;
        edge.setPadding(element.getPadding());
        edge.setSourceOffset(element.getSourceOffset());
        edge.setTargetOffset(element.getTargetOffset());
        return edge;
    }*/
@

