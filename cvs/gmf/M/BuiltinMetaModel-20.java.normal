package org.eclipse.gmf.internal.xpand;

public class BuiltinMetaModel {
    private static CollectionTypesSupport collectionTypes = new CollectionTypesSupport ();
    private static EAttribute PT_INNER_TYPE_ATTR = EcoreFactory.eINSTANCE.createEAttribute ();
    private static EClass PARAMETERIZED_TYPE = EcoreFactory.eINSTANCE.createEClass ();
    private static EPackage XECORE = EcoreFactory.eINSTANCE.createEPackage ();
    private static EReference PT_INNER_TYPE_REF = EcoreFactory.eINSTANCE.createEReference ();

    private static EStructuralFeature findInternalAttr (EClassifier type, String name);
    private static List < EOperation > findInternalOp (EClassifier targetType); private static Map < String, String > attrNameSubsts = new TreeMap < String, String > ();
    abstract private static class InternalOperation < T > {

        abstract public Object evaluate (T target, Object [] params);
    }

    private static boolean hasBuiltinSupport (EClassifier type);
    private static boolean isCompatibleDataTypes (EDataType dt1, EDataType dt2);
    private static boolean primEquals (EClassifier c1, EClassifier obj); private static class OperationFactory {

        EOperation create (String name, Class returnType, Class...params);
        EOperation create (String name, EClassifier returnType, EClassifier...params);
        InternalOperation createReflective (Class targetType, String methodName, Class...params);
        private EClassifier toEClassifier (Class targetType);
    }

    final private static Map < EClassifier, List < InternalOperation > > internalOperationsMap = new HashMap < EClassifier, List < InternalOperation > > ();
    final private static Map < EOperation, Method > externalOpImplementations = new HashMap < EOperation, Method > ();
    final public static String LIST = "List";
    final public static String SET = "Set";

    public static EClass cloneParametrizedType (EClassifier parameterizedTypeM1, EClassifier innerTypeM1);
    public static EClass getCollectionType (EClassifier innerType);
    public static EClass getCollectionType (String metaTypeName, EClassifier innerType);
    public static EClass getListType (EClassifier innerType);
    public static EClass getSetType (EClassifier innerType);
    public static EClassifier getInnerType (EClassifier parameterizedTypeM1);
    public static EClassifier getReturnType (EEnumLiteral sp);
    public static EClassifier getType (Object obj);
    public static EClassifier getTypedElementType (ETypedElement p);
    public static EOperation findOperation (EClassifier targetType, String name, EClassifier [] args);
    public static EStructuralFeature getAttribute (EClassifier type, String name);
    public static List < EOperation > getAllOperation (EClassifier targetType);
    public static List < EStructuralFeature > getAllFeatures (EClassifier targetType);
    public static Object getValue (EStructuralFeature prop, Object instance);
    public static Object newInstance (EClassifier t);
    public static Operation executableOperation (String name, Object [] args, Object instance);
    public static boolean isAssignableFrom (EClassifier c1, EClassifier t);
    public static boolean isCollectionMetaType (String name);
    public static boolean isCollectionType (EClassifier parameterizedTypeM1);
    public static boolean isParameterizedType (EClassifier parameterizedTypeM1); public static class Operation {
        final protected EOperation metaOp;
        final protected Object [] args;
        final protected Object targetObject;

        public Object evaluate ();
    }

    public static class OperationEx extends Operation {

        public Object evaluate ();
    }

    final public static EClass DEFINITION_TYPE = EcoreFactory.eINSTANCE.createEClass ();
    final public static EClass ITERATOR_TYPE = EcoreFactory.eINSTANCE.createEClass ();
    final public static EClass VOID = EcoreFactory.eINSTANCE.createEClass ();

    public static void registerOperationImpl (EOperation metaOp, Method implementation);
    static EClass internalNewParameterizedType (EClass parameterizedTypeM2, EClassifier inner);
    static {
        DEFINITION_TYPE.setName ("xpand2::Definition");
        DEFINITION_TYPE.getESuperTypes ().add (EcorePackage.eINSTANCE.getEClass ());
        XECORE.getEClassifiers ().add (DEFINITION_TYPE);
    }

    static {
        ITERATOR_TYPE.setName ("xpand2::Iterator");
        ITERATOR_TYPE.getESuperTypes ().add (EcorePackage.eINSTANCE.getEClass ());
        XECORE.getEClassifiers ().add (ITERATOR_TYPE);
    }

    static {
        PARAMETERIZED_TYPE.setName ("ParameterizedType");
        PARAMETERIZED_TYPE.getESuperTypes ().add (EcorePackage.eINSTANCE.getEClass ());
        PARAMETERIZED_TYPE.setAbstract (true);
        PT_INNER_TYPE_REF.setName ("innerType");
        PT_INNER_TYPE_REF.setContainment (false);
        PT_INNER_TYPE_REF.setEType (EcorePackage.eINSTANCE.getEClass ());
        PARAMETERIZED_TYPE.getEStructuralFeatures ().add (PT_INNER_TYPE_REF);
        PT_INNER_TYPE_ATTR.setName ("innerDataType");
        PT_INNER_TYPE_ATTR.setEType (EcorePackage.eINSTANCE.getEDataType ());
        PARAMETERIZED_TYPE.getEStructuralFeatures ().add (PT_INNER_TYPE_ATTR);
        XECORE.getEClassifiers ().add (PARAMETERIZED_TYPE);
    }

    static {
        VOID.setName ("void");
        XECORE.getEClassifiers ().add (VOID);
    }

    static {
        XECORE.setName ("xecore");
        XECORE.setNsPrefix ("xecore");
        XECORE.setNsURI ("uri:org.eclipse.modeling/m2t/xpand/xecore/1.0");
    }

    static {
        attrNameSubsts.put ("default_", "default");
    }

    static {
        collectionTypes.init (XECORE, PARAMETERIZED_TYPE);
    }

    static {
        final EcorePackage ecorePkg = EcorePackage.eINSTANCE;
        final OperationFactory opf = new OperationFactory ();
        final List < InternalOperation > objectOps = new LinkedList < InternalOperation > ();
        objectOps.add (new InternalOperation < Object > (opf.create ("compareTo", ecorePkg.getEBoolean (), ecorePkg.getEJavaObject ())) {

            public Object evaluate (Object target, Object [] params);
        }

        );
        objectOps.add (new InternalOperation < Object > (opf.create ("toString", ecorePkg.getEString ())) {

            public Object evaluate (Object target, Object [] params);
        }

        );
        objectOps.add (new InternalOperation < Object > (opf.create ("==", boolean.class, Object.class)) {

            public Object evaluate (Object target, Object [] params);
        }

        );
        objectOps.add (new InternalOperation < Object > (opf.create ("!=", boolean.class, Object.class)) {

            public Object evaluate (Object target, Object [] params);
        }

        );
        List < InternalOperation > unmodifiableObjectOps = Collections.unmodifiableList (objectOps);
        internalOperationsMap.put (ecorePkg.getEJavaObject (), unmodifiableObjectOps);
        internalOperationsMap.put (ecorePkg.getEEnumerator (), unmodifiableObjectOps);
        final List < InternalOperation > stringOps = new LinkedList < InternalOperation > ();
        stringOps.add (new InternalOperation < String > (opf.create ("+", ecorePkg.getEString (), ecorePkg.getEJavaObject ())) {

            public Object evaluate (String target, Object [] params);
        }

        );
        stringOps.add (new InternalOperation < String > (opf.create ("toFirstUpper", ecorePkg.getEString ())) {

            public Object evaluate (String target, Object [] params);
        }

        );
        stringOps.add (new InternalOperation < String > (opf.create ("toFirstLower", ecorePkg.getEString ())) {

            public Object evaluate (String target, Object [] params);
        }

        );
        stringOps.add (new InternalOperation < String > (opf.create ("toCharList", collectionTypes.getListType (ecorePkg.getEString ()))) {

            public Object evaluate (String target, Object [] params);
        }

        );
        stringOps.add (opf.createReflective (String.class, "startsWith", String.class));
        stringOps.add (opf.createReflective (String.class, "endsWith", String.class));
        InternalOperation subStringOp = opf.createReflective (String.class, "substring", int.class, int.class);
        subStringOp.metaOp.setName ("subString");
        stringOps.add (subStringOp);
        subStringOp = opf.createReflective (String.class, "substring", int.class);
        subStringOp.metaOp.setName ("subString");
        stringOps.add (subStringOp);
        stringOps.add (opf.createReflective (String.class, "toUpperCase"));
        stringOps.add (opf.createReflective (String.class, "toLowerCase"));
        stringOps.add (opf.createReflective (String.class, "replaceAll", String.class, String.class));
        stringOps.add (opf.createReflective (String.class, "replaceFirst", String.class, String.class));
        stringOps.add (opf.createReflective (String.class, "split", String.class));
        stringOps.add (opf.createReflective (String.class, "matches", String.class));
        stringOps.add (opf.createReflective (String.class, "trim"));
        stringOps.add (opf.createReflective (String.class, "length"));
        stringOps.addAll (unmodifiableObjectOps);
        internalOperationsMap.put (ecorePkg.getEString (), Collections.unmodifiableList (stringOps));
        final List < InternalOperation > booleanOps = new LinkedList < InternalOperation > ();
        booleanOps.add (new InternalOperation < Boolean > (opf.create ("!", boolean.class)) {

            public Object evaluate (Boolean target, Object [] params);
        }

        );
        booleanOps.addAll (unmodifiableObjectOps);
        internalOperationsMap.put (ecorePkg.getEBoolean (), Collections.unmodifiableList (booleanOps));
        final List < InternalOperation > voidOps = new LinkedList < InternalOperation > ();
        voidOps.addAll (unmodifiableObjectOps);
        internalOperationsMap.put (VOID, Collections.unmodifiableList (voidOps));
        class InternalSumOp extends InternalOperation < Number > {

            public Object evaluate (Number target, Object [] params);
        };

        class InternalSubOp extends InternalOperation < Number > {

            public Object evaluate (Number target, Object [] params);
        };

        class InternalMulOp extends InternalOperation < Number > {

            public Object evaluate (Number target, Object [] params);
        };

        class InternalDivOp extends InternalOperation < Number > {

            public Object evaluate (Number target, Object [] params);
        };

        class InternalNegateOp extends InternalOperation < Number > {

            public Object evaluate (Number target, Object [] params);
        }

        final List < InternalOperation > intOps = new LinkedList < InternalOperation > ();
        intOps.add (new InternalSumOp (opf.create ("+", int.class, int.class)));
        intOps.add (new InternalSumOp (opf.create ("+", int.class, double.class)));
        intOps.add (new InternalSubOp (opf.create ("-", int.class, int.class)));
        intOps.add (new InternalSubOp (opf.create ("-", int.class, double.class)));
        intOps.add (new InternalMulOp (opf.create ("*", int.class, int.class)));
        intOps.add (new InternalMulOp (opf.create ("*", int.class, double.class)));
        intOps.add (new InternalDivOp (opf.create ("/", int.class, int.class)));
        intOps.add (new InternalDivOp (opf.create ("/", int.class, double.class)));
        intOps.add (new InternalNegateOp (opf.create ("-", int.class)));
        intOps.add (new InternalOperation < Number > (opf.create (">=", boolean.class, int.class)) {

            public Object evaluate (Number target, Object [] params);
        }

        );
        intOps.add (new InternalOperation < Number > (opf.create ("<=", boolean.class, int.class)) {

            public Object evaluate (Number target, Object [] params);
        }

        );
        intOps.add (new InternalOperation < Number > (opf.create ("<", boolean.class, int.class)) {

            public Object evaluate (Number target, Object [] params);
        }

        );
        intOps.add (new InternalOperation < Number > (opf.create (">", boolean.class, int.class)) {

            public Object evaluate (Number target, Object [] params);
        }

        );
        intOps.add (new InternalOperation < Number > (opf.create ("upTo", collectionTypes.getListType (ecorePkg.getEInt ()), ecorePkg.getEInt ())) {

            public Object evaluate (Number target, Object [] params);
        }

        );
        intOps.addAll (unmodifiableObjectOps);
        List < InternalOperation > unmodifiableListIntOps = Collections.unmodifiableList (intOps);
        internalOperationsMap.put (ecorePkg.getEIntegerObject (), unmodifiableListIntOps);
        internalOperationsMap.put (ecorePkg.getEInt (), unmodifiableListIntOps);
        final List < InternalOperation > doubleOps = new LinkedList < InternalOperation > ();
        doubleOps.add (new InternalSumOp (opf.create ("+", double.class, double.class)));
        doubleOps.add (new InternalSumOp (opf.create ("+", double.class, int.class)));
        doubleOps.add (new InternalSubOp (opf.create ("-", double.class, double.class)));
        doubleOps.add (new InternalSubOp (opf.create ("-", double.class, int.class)));
        doubleOps.add (new InternalMulOp (opf.create ("*", double.class, double.class)));
        doubleOps.add (new InternalMulOp (opf.create ("*", double.class, int.class)));
        doubleOps.add (new InternalDivOp (opf.create ("/", double.class, double.class)));
        doubleOps.add (new InternalDivOp (opf.create ("/", double.class, int.class)));
        doubleOps.add (new InternalNegateOp (opf.create ("-", int.class)));
        doubleOps.addAll (unmodifiableObjectOps);
        internalOperationsMap.put (ecorePkg.getEDouble (), doubleOps);
        final List < InternalOperation > collectionOps = new LinkedList < InternalOperation > ();
        collectionOps.add (new InternalOperation < List > (opf.create ("isEmpty", ecorePkg.getEBoolean ())) {

            public Object evaluate (List target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("add", CollectionTypesSupport.COLLECTION_OF_OBJECT, ecorePkg.getEJavaObject ())) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("addAll", CollectionTypesSupport.COLLECTION_OF_OBJECT, CollectionTypesSupport.COLLECTION_OF_OBJECT)) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("flatten", CollectionTypesSupport.COLLECTION_OF_OBJECT)) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("size", ecorePkg.getEInt ())) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("union", CollectionTypesSupport.COLLECTION_OF_OBJECT, CollectionTypesSupport.COLLECTION_OF_OBJECT)) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("intersect", CollectionTypesSupport.COLLECTION_OF_OBJECT, CollectionTypesSupport.COLLECTION_OF_OBJECT)) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("without", CollectionTypesSupport.COLLECTION_OF_OBJECT, CollectionTypesSupport.COLLECTION_OF_OBJECT)) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("toSet", CollectionTypesSupport.SET_OF_OBJECT)) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("toList", CollectionTypesSupport.LIST_OF_OBJECT)) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("contains", ecorePkg.getEBoolean (), ecorePkg.getEJavaObject ())) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        collectionOps.add (new InternalOperation < Collection > (opf.create ("containsAll", ecorePkg.getEBoolean (), CollectionTypesSupport.COLLECTION_OF_OBJECT)) {

            public Object evaluate (Collection target, Object [] params);
        }

        );
        List < InternalOperation > unmodifiableListCollectionOps = Collections.unmodifiableList (collectionOps);
        internalOperationsMap.put (CollectionTypesSupport.COLLECTION_TYPE, unmodifiableListCollectionOps);
        internalOperationsMap.put (CollectionTypesSupport.SET_TYPE, unmodifiableListCollectionOps);
        final List < InternalOperation > listOps = new LinkedList < InternalOperation > (unmodifiableListCollectionOps);
        listOps.add (new InternalOperation < List > (opf.create ("get", ecorePkg.getEJavaObject (), ecorePkg.getEInt ())) {

            public Object evaluate (List target, Object [] params);
        }

        );
        listOps.add (new InternalOperation < List > (opf.create ("first", ecorePkg.getEJavaObject ())) {

            public Object evaluate (List target, Object [] params);
        }

        );
        listOps.add (new InternalOperation < List > (opf.create ("last", ecorePkg.getEJavaObject ())) {

            public Object evaluate (List target, Object [] params);
        }

        );
        listOps.add (new InternalOperation < List > (opf.create ("withoutFirst", CollectionTypesSupport.LIST_OF_OBJECT)) {

            public Object evaluate (List target, Object [] params);
        }

        );
        listOps.add (new InternalOperation < List > (opf.create ("withoutLast", CollectionTypesSupport.LIST_OF_OBJECT)) {

            public Object evaluate (List target, Object [] params);
        }

        );
        listOps.add (new InternalOperation < List > (opf.create ("purgeDups", CollectionTypesSupport.LIST_OF_OBJECT)) {

            public Object evaluate (List target, Object [] params);
        }

        );
        internalOperationsMap.put (CollectionTypesSupport.LIST_TYPE, Collections.unmodifiableList (listOps));
        final List < InternalOperation > definitionOps = new LinkedList < InternalOperation > ();
        definitionOps.add (new InternalOperation < XpandDefinitionWrap > (opf.create ("proceed", VOID)) {

            public Object evaluate (XpandDefinitionWrap target, Object [] params);
        }

        );
        internalOperationsMap.put (DEFINITION_TYPE, Collections.unmodifiableList (definitionOps));
        final List < InternalOperation > iteratorOps = new LinkedList < InternalOperation > ();
        iteratorOps.add (new InternalOperation < XpandIterator > (opf.create ("isFirstIteration", ecorePkg.getEBoolean ())) {

            public Object evaluate (XpandIterator target, Object [] params);
        }

        );
        internalOperationsMap.put (ITERATOR_TYPE, Collections.unmodifiableList (iteratorOps));
    }

}

