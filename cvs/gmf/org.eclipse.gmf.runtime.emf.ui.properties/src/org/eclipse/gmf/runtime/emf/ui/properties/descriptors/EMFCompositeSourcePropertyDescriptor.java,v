head	1.11;
access;
symbols
	v20081020-0700:1.11
	v20080722-1827:1.11
	R2_1_maintenance:1.11.0.4
	Root_R2_1_maintenance:1.11
	R2_1_0:1.11
	v20080425-1959:1.11
	v20080222-1200:1.11
	v20070809-0000:1.11
	R2_0_maintenance:1.11.0.2
	R2_0:1.11
	R4_20:1.11
	RC3_20:1.11
	v20070601-1400:1.11
	v20070330-1300:1.11
	M4_20:1.11
	v20061214-0000:1.11
	M3_20:1.11
	v20061013-1330:1.11
	v20061012-1100:1.10.2.3
	v20060925-1700:1.10.2.3
	v20060919-0800:1.10.2.3
	M1_20:1.10
	v20060810-1700:1.10.2.2
	v20060713-1700:1.10
	R1_0_maintenance:1.10.0.2
	R1_0:1.10
	v20060627-1200:1.10
	v20060616-1200:1.10
	v20060531-1730:1.10
	I20060505-1400:1.10
	I20060424-0500:1.9
	I20060424-0300:1.9
	M6_10:1.9
	I20060407-1200:1.9
	I20060331-1000:1.9
	I20060324-0300:1.8
	I20060317-1300:1.8
	I20060317-1200:1.8
	I20060316-1300:1.8
	I20060309-1300:1.8
	M5_10:1.8
	S20060303-1600:1.8
	I20060227-1730:1.7
	I20060216-1945:1.7
	I20060210-1715:1.6
	I20060209-1815:1.6
	I20060203-0830:1.6
	I20060129-1145:1.6
	I20060127-0900:1.4
	I20060120-1530:1.4
	I20060113-1700:1.4
	M4_10:1.4
	I20060107-1100:1.4
	I20060105-1630:1.4
	I20051230-1230:1.4
	I20051223-1100:1.4
	I20051217-0925:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;


1.11
date	2006.10.03.15.06.35;	author ahunter;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.04.19.49.45;	author vramaswamy;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2006.03.24.19.17.43;	author ldamus;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.02.21.59.15;	author cmahoney;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.16.16.59.42;	author ldamus;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.27.21.07.11;	author ashatalin;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.27.20.54.27;	author ashatalin;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.09.21.16.55;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.12.15.57.24;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.24.06;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.26.55;	author sshaw;	state Exp;
branches;
next	;

1.10.2.1
date	2006.08.08.14.27.17;	author ldamus;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2006.08.08.14.35.00;	author ldamus;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2006.09.12.18.35.56;	author cmahoney;	state Exp;
branches;
next	;


desc
@@


1.11
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.emf.ui.properties.descriptors;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.common.ui.celleditor.ExtendedComboBoxCellEditor;
import org.eclipse.emf.common.ui.celleditor.ExtendedDialogCellEditor;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain;
import org.eclipse.emf.edit.provider.IItemLabelProvider;
import org.eclipse.emf.edit.provider.IItemPropertyDescriptor;
import org.eclipse.emf.edit.provider.IItemPropertySource;
import org.eclipse.emf.edit.ui.celleditor.FeatureEditorDialog;
import org.eclipse.emf.edit.ui.provider.ExtendedImageRegistry;
import org.eclipse.emf.edit.ui.provider.PropertyDescriptor;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.emf.transaction.util.TransactionUtil;
import org.eclipse.gmf.runtime.common.ui.services.properties.descriptors.ICompositeSourcePropertyDescriptor;
import org.eclipse.jface.viewers.CellEditor;
import org.eclipse.jface.viewers.ICellEditorValidator;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.ui.views.properties.IPropertyDescriptor;

/**
 * The descriptor that works with the <code>EMFCompositePropertySource</code>
 * object.
 * <P>
 * When the property value is set while an EMF transaction is open on the
 * editing domain, I will not execute the set command through the editing domain
 * command stack. In this case, I rely on whoever opened the EMF transaction to
 * put their operation on the operation history.
 * 
 * @@author nbalaba
 */
public class EMFCompositeSourcePropertyDescriptor extends PropertyDescriptor
        implements ICompositeSourcePropertyDescriptor {

    protected String category = null;

    protected String[] filterFlags;

    protected boolean readOnly = false;

    protected CellEditor propertyEditor = null;

    /**
     * The object to validate the values in the cell editor, or
     * <code>null</code> if none (the default).
     */
    protected ICellEditorValidator validator;

    /**
     * A convinience method to create an instance of a ILabelProvider using
     * IItemPropertyDescriptor
     * 
     * @@param itemPropertyDescriptor
     * @@return label provider
     */
    public static ILabelProvider createLabelProvider(
            IItemPropertyDescriptor itemPropertyDescriptor) {
        final IItemLabelProvider itemLabelProvider = itemPropertyDescriptor
                .getLabelProvider(null);
        return new LabelProvider() {
            public String getText(Object object) {
                return itemLabelProvider.getText(object);
            }

            public Image getImage(Object object) {
                return ExtendedImageRegistry.getInstance().getImage(
                        itemLabelProvider.getImage(object));
            }
        };
    }

    /**
     * @@param object
     * @@param itemPropertyDescriptor
     */
    public EMFCompositeSourcePropertyDescriptor(Object object,
            IItemPropertyDescriptor itemPropertyDescriptor) {
        super(object, itemPropertyDescriptor);

        filterFlags = itemPropertyDescriptor.getFilterFlags(object);
        filterFlags = filterFlags == null ? new String[0] : filterFlags;

    }

    /**
     * Creates an instance of <code>EMFCompositeSourcePropertyDescriptor</code>.
     * 
     * @@param object
     * @@param itemPropertyDescriptor
     * @@param category 
     */
    public EMFCompositeSourcePropertyDescriptor(Object object,
            IItemPropertyDescriptor itemPropertyDescriptor, String category) {
        this(object, itemPropertyDescriptor);
        setCategory(category);
    }

    /**
     * Sets the category.
     * 
     * @@param category The category to set.
     */
    public void setCategory(String category) {
        this.category = category;
    }

    /*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.ui.views.properties.IPropertyDescriptor#getCategory()
     */
    public String getCategory() {

        String aCategory = super.getCategory();
        return aCategory == null ? this.category : aCategory;

    }

    /**
     * @@return Returns the filterFlags.
     */
    public String[] getFilterFlags() {
        return filterFlags;
    }

    /**
     * Add filter flag (@@see IPropertySheetEntry.FILTER_ID_EXPERT)
     * 
     * @@param flag
     */
    public void addFilterFlag(String flag) {
        if (!Arrays.asList(filterFlags).contains(flag)) {
            String[] flags = new String[filterFlags.length + 1];
            System.arraycopy(filterFlags, 0, flags, 0, filterFlags.length);
            flags[filterFlags.length] = flag;
            filterFlags = flags;
        }
    }

    /**
     * This returns the cell editor that will be used to edit the value of this
     * property. This default implementation determines the type of cell editor
     * from the nature of the structural feature.
     */
    public CellEditor createPropertyEditor(Composite composite) {

        if (isReadOnly())
            return null;

        if (getPropertyEditor() != null)
            return getPropertyEditor();

        return doCreateEditor(composite);
    }

    /*
     * A cxell editor creation method - after the assertions. Allows subclasses
     * override just the part where the editor actually is created, without
     * having to repeat preliminary assertions in every subclass
     * 
     * @@param composite @@return
     */
    protected CellEditor doCreateEditor(Composite composite) {
        CellEditor result = null;
        Object genericFeature = getFeature();

        if (genericFeature instanceof EReference[]) {
            result = createComboBoxCellEditor(composite);
        } else if (genericFeature instanceof EStructuralFeature) {

            final EStructuralFeature feature = (EStructuralFeature) genericFeature;
            final EClassifier eType = feature.getEType();
            final List choiceOfValues = getChoiceOfValues();

            if (!choiceOfValues.isEmpty()) {
            	if (getItemDescriptor().isMany(getObject())) {
                    boolean valid = true;
                    for (Iterator i = choiceOfValues.iterator(); i.hasNext();) {
                        Object choice = i.next();
                        if (!eType.isInstance(choice)) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid) {
                    	result = createDialogCellEditor(composite, feature, choiceOfValues);
					}
                }
                if (result == null)
                    result = createComboBoxCellEditor(composite);

            } else {
                if (eType instanceof EDataType) {

                    EDataType eDataType = (EDataType) eType;
                    if (eDataType.isSerializable()) {
                        if (getItemDescriptor().isMany(getObject())) {
                        	result = createDialogCellEditor(composite, feature, choiceOfValues);
                        } else if (eDataType == EcorePackage.eINSTANCE
                                .getEBoolean()
                                || eDataType == EcorePackage.eINSTANCE
                                        .getEBooleanObject()
                                || eDataType.getInstanceClass() == EcorePackage.eINSTANCE
                                        .getEBoolean().getInstanceClass())

                        {
                            result = createBooleanCellEditor(composite);
                        } else {
                            result = createDataTypeCellEditor(composite);
                        }
                    }
                }
            }
        }

        return result == null ? super.createPropertyEditor(composite) : result;
    }

    /**
     * Returns boolean - an indicator either or not this property can be set or
     * re-set. It was either inherited from our IItemPropertyDescriptor or set
     * in the context of the application
     * 
     * @@return - true if either IItemPropertyDescriptor can not set it or our
     *         descriptor
     */
    public boolean isReadOnly() {
        return (!itemPropertyDescriptor.canSetProperty(object)) || readOnly;
    }

    /**
     * Sets the specified value to be read only.
     * 
     * @@param value
     *            The readOnly to set.
     */
    public void setReadOnly(boolean value) {
        this.readOnly = value;
    }

    /**
     * @@see org.eclipse.ui.views.properties.IPropertyDescriptor#isCompatibleWith(IPropertyDescriptor)
     */

    public boolean isCompatibleWith(IPropertyDescriptor anotherProperty) {

        if (this == anotherProperty)
            return true;

        if (!(anotherProperty instanceof EMFCompositeSourcePropertyDescriptor))
            return false;

        EMFCompositeSourcePropertyDescriptor descriptor = (EMFCompositeSourcePropertyDescriptor) anotherProperty;

        if (getFeature() == descriptor.getFeature())
            //   && isCompatibleTypes(descriptor))
            return (getCategory().equals(descriptor.getCategory()));

        return false;

    }

/*    private boolean isCompatibleTypes(
            EMFCompositeSourcePropertyDescriptor descriptor) {
        return ((EObject) getObject()).eClass().isInstance(
                (descriptor.getObject()))
                || ((EObject) descriptor.getObject()).eClass().isInstance(
                        (getObject()));
    }
*/
    /**
     * Retrieve an object for which this class is a property source.
     * 
     * @@return <code>Object</code> for which this class is a property source 
     */
    protected Object getObject() {
        return object;
    }

    /**
     * @@return the item descriptor
     */
    public IItemPropertyDescriptor getItemDescriptor() {
        return itemPropertyDescriptor;
    }

    /**
     * Retrieves the feature.
     * 
     * @@return feature
     */
    public Object getFeature() {
        return itemPropertyDescriptor.getFeature(getObject());
    }

    /**
     * @@return Returns the propertyEditor.
     */
    protected CellEditor getPropertyEditor() {
        return propertyEditor;
    }

    /**
     * @@param propertyEditor
     *            The propertyEditor to set.
     */
    public void setPropertyEditor(CellEditor propertyEditor) {
        this.propertyEditor = propertyEditor;
    }

    /**
     * @@return Returns the validator.
     */
    public ICellEditorValidator getValidator() {
        return validator;
    }

    /**
     * @@param validator
     *            The validator to set.
     */
    public void setValidator(ICellEditorValidator validator) {
        this.validator = validator;
    }

    /*
     * @@param composite @@return
     */
    protected CellEditor createComboBoxCellEditor(Composite composite) {

        return new ExtendedComboBoxCellEditor(composite, new ArrayList(
                getChoiceOfValues()), getLabelProvider(), true);

    }
    
    /**
	 * Creates a dialog cell editor for editing multivalued features.
	 * 
	 * @@param composite
	 *            the composite to contain the new cell editor
	 * @@param feature
	 *            the feature being edited
	 * @@param choiceOfValues
	 *            the possible values for that feature
	 * @@return the new cell editor
	 */
    protected CellEditor createDialogCellEditor(Composite composite,
			final EStructuralFeature feature, final List choiceOfValues) {
    	
		return new ExtendedDialogCellEditor(composite, getEditLabelProvider()) {
			protected Object openDialogBox(Control cellEditorWindow) {
				FeatureEditorDialog dialog = new FeatureEditorDialog(
						cellEditorWindow.getShell(), getLabelProvider(),
						getObject(), feature.getEType(),
						(List) ((IItemPropertySource) itemPropertyDescriptor
								.getPropertyValue(object))
								.getEditableValue(object), getDisplayName(),
						choiceOfValues);
				dialog.open();
				return dialog.getResult();
			}
		};
	}

    /*
	 * @@param composite @@return
	 */
    protected CellEditor createBooleanCellEditor(Composite composite) {
        return new ExtendedComboBoxCellEditor(composite,
                Arrays.asList(new Object[] { Boolean.FALSE,
                          Boolean.TRUE }), getLabelProvider(), true);
    }

    /*
     * @@param composite @@return
     */
    protected CellEditor createDataTypeCellEditor(Composite composite) {
        Object genericFeature = itemPropertyDescriptor.getFeature(object);
        if (genericFeature instanceof EStructuralFeature) {

            EClassifier eType = ((EStructuralFeature) genericFeature)
                    .getEType();
            if (eType instanceof EDataType) {
                return new EDataTypeCellEditor((EDataType) eType, composite) {
                    protected void focusLost() {
                        if (isActivated()) {                     
                            deactivate();
                        }
                    }
                };
            }
        }
        return null;
    }

    /**
     * @@return - value of the property stored in the EMF descriptor
     */
    public Object getPropertyValue() {

        return getEditableValue(); //getItemDescriptor().getPropertyValue(getObject());//
    }

    /**
     * This is a temporary method. If we want to keep the recursive properties
     * this become getPropertyValue().
     * 
     * @@return the editable value
     */
    protected Object getEditableValue() {
        Object aValue = getItemDescriptor().getPropertyValue(getObject());
        //		 see if we should convert the value to an editable value

        IItemPropertySource itemSource = getPropertySource(aValue);
        if (itemSource != null) {
            aValue = itemSource.getEditableValue(aValue);
        }

        return aValue;
    }

    /**
     * @@param value
     *            value of the property
     */
    public void setPropertyValue(final Object value) {
        //if (value == null) // hack - due to the bug in EMF
        //return;

        Object oldValue = getEditableValue();

        // here we get into the infinite recursive loop
        // because of the emf edit even generation - need to stop
        // if the new value is the same as the old one
        if ((oldValue != null && oldValue.equals(value))
                || (oldValue == null && value == null))
            return;
        
        getItemDescriptor().setPropertyValue(getObject(), value);
    }

    /**
     * 
     */
    public void resetPropertyValue() {

        getItemDescriptor().resetPropertyValue(getObject());

    }

    /**
     * Returns an property source for the given value.
     * 
     * @@object an object for which to obtain a property source or
     *         <code>null</code> if a property source is not available
     * @@return an property source for the given object
     */
    protected IItemPropertySource getPropertySource(Object value) {
        if (value instanceof IItemPropertySource) {
            return (IItemPropertySource) value;
        }
        
        TransactionalEditingDomain editingDomain = TransactionUtil
            .getEditingDomain(getObject());

        if (editingDomain instanceof AdapterFactoryEditingDomain) {
            return (IItemPropertySource) ((AdapterFactoryEditingDomain) editingDomain)
                .getAdapterFactory().adapt(value, IItemPropertySource.class);
        }
        return null;
    }

    /*
     * Override superclass behavior by returning a feature as a property id. The
     * superclass takes ItemPropertyDescritor id as property id. The
     * ItemPropertyDescriptor returns a display name as a property id. The
     * Notation properties will contain Styles - which is a list of style
     * objects. The Styles are presented as a single object with flattened
     * properties - each style object on the list contributes to the properties
     * of the Style. For that each property must have a unique id. This is why
     * we need to override and return a feature - since feature objects are
     * singletons and quaranteed to be unique.
     * 
     * (non-Javadoc)
     * 
     * @@see org.eclipse.ui.views.properties.IPropertyDescriptor#getId()
     */
    public Object getId() {
        return getFeature();
    }

    /**
     * Return choice of values for the given property.
     * 
     * @@return list containing list of values
     */
    public List getChoiceOfValues() {
        Collection types = itemPropertyDescriptor
                .getChoiceOfValues(getObject());
        return types == null ? new ArrayList() : new ArrayList(types);
    }

    /**
     * Resets the property to specified value.
     * 
     * @@param value the new property value
     */
    public void resetPropertyValue(Object value) {
      getItemDescriptor().resetPropertyValue(getObject());
        
    }
}@


1.10
log
@[131094] gmf_head cmcgee 060504 Sweep Code for EReference.isMany() calls
@
text
@d21 1
d31 1
d43 1
d198 1
a198 1
            final Collection choiceOfValues = getChoiceOfValues();
d201 1
a201 3

            	// TODO We need to properly handle unspecified multiplicities on the structural feature
                if (feature.isMany()) {
d210 3
a212 2
                    if (valid)
                        result = createComboBoxCellEditor(composite);
d222 2
a223 3
                    	// TODO We need to properly handle unspecified multiplicities on the structural feature
                        if (feature.isMany()) {
                            result = createComboBoxCellEditor(composite);
d360 29
d391 2
a392 2
     * @@param composite @@return
     */
d484 4
@


1.10.2.1
log
@[125459] gmf_R1_0_maintenance ldamus 060808 Ecore editor :  EClass Generalization problem across two different ecore models
@
text
@a20 1
import org.eclipse.emf.common.ui.celleditor.ExtendedDialogCellEditor;
a29 1
import org.eclipse.emf.edit.ui.celleditor.FeatureEditorDialog;
a40 1
import org.eclipse.swt.widgets.Control;
d195 1
a195 1
            final List choiceOfValues = getChoiceOfValues();
d209 2
a210 3
                    if (valid) {
                    	result = createDialogCellEditor(composite, feature, choiceOfValues);
					}
d220 1
a220 1
                        // TODO We need to properly handle unspecified multiplicities on the structural feature
d222 1
a222 1
                        	result = createDialogCellEditor(composite, feature, choiceOfValues);
a358 29
    
    /**
	 * Creates a dialog cell editor for editing multivalued features.
	 * 
	 * @@param composite
	 *            the composite to contain the new cell editor
	 * @@param feature
	 *            the feature being edited
	 * @@param choiceOfValues
	 *            the possible values for that feature
	 * @@return the new cell editor
	 */
    protected CellEditor createDialogCellEditor(Composite composite,
			final EStructuralFeature feature, final List choiceOfValues) {
    	
		return new ExtendedDialogCellEditor(composite, getEditLabelProvider()) {
			protected Object openDialogBox(Control cellEditorWindow) {
				FeatureEditorDialog dialog = new FeatureEditorDialog(
						cellEditorWindow.getShell(), getLabelProvider(),
						getObject(), feature.getEType(),
						(List) ((IItemPropertySource) itemPropertyDescriptor
								.getPropertyValue(object))
								.getEditableValue(object), getDisplayName(),
						choiceOfValues);
				dialog.open();
				return dialog.getResult();
			}
		};
	}
d361 2
a362 2
	 * @@param composite @@return
	 */
@


1.10.2.2
log
@[140070] gmf_R1_0_maintenance ldamus 060808 EMFCompositeSourcePropertyDescriptor class must handle feature map cases
@
text
@d201 3
a203 1
            	if (getItemDescriptor().isMany(getObject())) {
d224 2
a225 1
                        if (getItemDescriptor().isMany(getObject())) {
@


1.10.2.3
log
@Bugzilla#156886 gmf_R1_0_maintenance cmahoney 060912 EMFCompositeSourcePropertyDescriptor returns null in getProipertySource while it should do more testing
@
text
@a483 4
        if (value instanceof IItemPropertySource) {
            return (IItemPropertySource) value;
        }
        
@


1.9
log
@[127528] gmf_head ldamus 060324 Can't undo changes from advanced properties tab
@
text
@d199 1
d220 1
@


1.8
log
@Bugzilla#130176 gmf_head cmahoney 060302 Values of properties on advanced tab not refreshed after property is changed
@
text
@a19 2
import org.eclipse.emf.common.command.Command;
import org.eclipse.emf.common.command.CompoundCommand;
a22 1
import org.eclipse.emf.ecore.EObject;
a25 1
import org.eclipse.emf.edit.command.SetCommand;
a26 1
import org.eclipse.emf.edit.domain.EditingDomain;
a29 2
import org.eclipse.emf.edit.provider.ItemPropertyDescriptor;
import org.eclipse.emf.edit.provider.ItemPropertyDescriptorDecorator;
a32 2
import org.eclipse.emf.transaction.impl.InternalTransaction;
import org.eclipse.emf.transaction.impl.InternalTransactionalEditingDomain;
a34 1
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand;
d432 1
a432 28
        
        // TODO Temporary fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=127528
        // 
        // Once https://bugs.eclipse.org/bugs/show_bug.cgi?id=128117 is fixed, 
        // TransactionalOperationItemPropertyDescriptor can be deleted and the 
        // following line can be used instead:
        //
        // getItemDescriptor().setPropertyValue(getObject(), value);
        //
        
        InternalTransactionalEditingDomain editingDomain = (InternalTransactionalEditingDomain) TransactionUtil
            .getEditingDomain(getObject());

        InternalTransaction transaction = editingDomain.getActiveTransaction();

        if (transaction != null && !transaction.isReadOnly()) {
            // we're executing an EMF transactional operation, so use a property
            // descriptor that won't execute the EMF set command through the
            // editing domain command stack
            ItemPropertyDescriptorDecorator decorator = new TransactionalOperationItemPropertyDescriptor(
                editingDomain, getObject(), itemPropertyDescriptor);
            decorator.setPropertyValue(getObject(), value);

        } else {
            // no transaction open so execute the EMF set command through the
            // editing domain command stack
            getItemDescriptor().setPropertyValue(getObject(), value);
        } 
a500 116
    
    /**
     * Property descriptor decorator that overrides
     * {@@link #setPropertyValue(Object, Object)} to execute the EMF commands
     * directly, rather than through the EMF command stack.
     * <P>
     * This decorator should only be used when the properties are being changed
     * through an {@@link AbstractTransactionalCommand}.
     * 
     * @@author ldamus
     */
    protected class TransactionalOperationItemPropertyDescriptor
        extends ItemPropertyDescriptorDecorator {

        private final EditingDomain editingDomain;

        /**
         * Initializes me with my editing domain, the object whose properties I
         * describe and my item property descriptor delegate.
         * 
         * @@param editingDomain
         *            the editing domain
         * @@param object
         *            the object whose properties I describe
         * @@param itemPropertyDescriptor
         *            the delegate
         */
        public TransactionalOperationItemPropertyDescriptor(
                EditingDomain editingDomain, Object object,
                IItemPropertyDescriptor itemPropertyDescriptor) {

            super(object, itemPropertyDescriptor);
            this.editingDomain = editingDomain;
        }

        /**
         * Sets the property value without executing commands on the editing
         * domain command stack.
         */
        public void setPropertyValue(Object thisObject, Object newValue) {

            if (editingDomain == null) {
                // no editing domain, so no my delegate will not execute a
                // command through the command stack
                itemPropertyDescriptor.setPropertyValue(thisObject, newValue);
                return;
            }

            EObject eObject = (EObject) this.object;

            Object owner = null;

            if (getItemDescriptor() instanceof ItemPropertyDescriptor) {
                owner = ((ItemPropertyDescriptor) getItemDescriptor())
                    .getCommandOwner();
            }

            Object commandOwner = (owner != null) ? owner
                : eObject;

            Object featureObject = getFeature(eObject);

            if (featureObject instanceof EReference[]) {
                EReference[] parentReferences = (EReference[]) featureObject;
                Command removeCommand = null;

                for (int i = 0; i < parentReferences.length; ++i) {
                    Object formerValue = eObject.eGet(parentReferences[i]);

                    if (formerValue != null) {
                        final EReference parentReference = parentReferences[i];

                        if (formerValue == newValue) {
                            return;

                        } else if (parentReference.getEType().isInstance(
                            newValue)) {

                            SetCommand.create(editingDomain, commandOwner,
                                parentReference, newValue).execute();
                            return;

                        } else {
                            removeCommand = SetCommand.create(editingDomain,
                                commandOwner, parentReference, null);
                            break;
                        }
                    }
                }

                for (int i = 0; i < parentReferences.length; ++i) {
                    final EReference parentReference = parentReferences[i];

                    if (parentReference.getEType().isInstance(newValue)) {
                        if (removeCommand != null) {
                            final CompoundCommand compoundCommand = new CompoundCommand(
                                CompoundCommand.LAST_COMMAND_ALL);
                            compoundCommand.append(removeCommand);
                            compoundCommand.append(SetCommand.create(
                                editingDomain, commandOwner, parentReference,
                                newValue));
                            compoundCommand.execute();

                        } else {
                            SetCommand.create(editingDomain, commandOwner,
                                parentReference, newValue).execute();
                        }
                        break;
                    }
                }
            } else {
                SetCommand.create(editingDomain, commandOwner, featureObject,
                    newValue).execute();
            }
        }
    }
@


1.7
log
@[127528] gmf_head ldamus 060216 Can't undo changes from advanced properties tab
@
text
@d30 1
d39 1
a44 1
import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;
d489 2
d492 2
a493 1
        return (IItemPropertySource) MSLAdapterFactoryManager
d495 2
a496 1

@


1.6
log
@Rollback of the mistakenly commited changes
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
d20 2
d25 1
d29 2
d34 2
d38 6
a51 3
import org.eclipse.gmf.runtime.common.ui.services.properties.descriptors.ICompositeSourcePropertyDescriptor;
import org.eclipse.gmf.runtime.emf.core.internal.util.MSLAdapterFactoryManager;

a52 2
 * @@author nbalaba
 * 
d55 7
d440 13
d454 1
a454 1
        getItemDescriptor().setPropertyValue(getObject(), value);
d456 13
d472 1
a472 1
     *  
d533 116
@


1.5
log
@#124806
Loading Resource action added into the Diagram Editor popup menu.
@
text
@a20 1
import org.eclipse.emf.common.ui.celleditor.ExtendedDialogCellEditor;
a28 1
import org.eclipse.emf.edit.ui.celleditor.FeatureEditorDialog;
a36 1
import org.eclipse.swt.widgets.Control;
d202 2
a203 18
                    if (valid) {
                        result = new ExtendedDialogCellEditor(composite, getEditLabelProvider()) 
                        {
                          protected Object openDialogBox(Control cellEditorWindow)
                          {
                            FeatureEditorDialog dialog = new FeatureEditorDialog(
                              cellEditorWindow.getShell(),
                              getEditLabelProvider(),
                              object,
                              feature.getEType(),
                              (List)((IItemPropertySource)itemPropertyDescriptor.getPropertyValue(object)).getEditableValue(object),
                              getDisplayName(),
                              new ArrayList(choiceOfValues));
                            dialog.open();
                            return dialog.getResult();
                          }
                        };
                    }
@


1.4
log
@Bugzilla Bug 109445 gmf_head etworkow 051109 New Eclipse Resources Bundles Should Be Used
@
text
@d21 1
d30 1
d39 1
d205 18
a222 2
                    if (valid)
                        result = createComboBoxCellEditor(composite);
@


1.3
log
@Bugzilla 112348 gmf_head anthonyh 051012 Sweep code for creation of Boolean objects
@
text
@a40 1
import org.eclipse.gmf.runtime.emf.ui.properties.internal.l10n.EMFPropertiesResourceManager;
a50 6
	/** Name of the undo property change command. */
    public static final String UNDO_PROPERTY = EMFPropertiesResourceManager
            .getInstance()
            .getString(
                    "EMFCompositeSourcePropertyDescriptor.undoProperty.commandName"); //$NON-NLS-1$

@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d364 2
a365 2
                Arrays.asList(new Object[] { new Boolean(false),
                        new Boolean(true) }), getLabelProvider(), true);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

