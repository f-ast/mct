head	1.3;
access;
symbols
	v20081020-0700:1.3
	v20080903-1520:1.3
	v20080903-1510:1.2.4.1
	v20080722-1827:1.2
	R2_1_maintenance:1.2.0.4
	Root_R2_1_maintenance:1.2
	R2_1_0:1.2
	v20080603-1553:1.2
	v20080527-1255:1.2
	v20080507-2230:1.2
	v20080425-1959:1.2
	v20080328-1605:1.2
	v20080322-0000:1.2
	v20080222-1200:1.2
	v20071003-0000:1.2
	v20070928-0000:1.2
	v20070809-0000:1.2
	R2_0_maintenance:1.2.0.2
	R2_0:1.2
	R4_20:1.2
	RC3_20:1.2
	v20070614-1400:1.2
	v20070608-1300:1.2
	v20070601-1400:1.2
	v20070504-1000:1.2
	v20070330-1300:1.2
	v20070221-1500:1.2
	v20070208-1800:1.2
	v20070105-1200:1.1.2.1
	M4_20:1.2
	v20061218-1500:1.1.2.1
	v20061214-0000:1.2
	M3_20:1.2
	v20061013-1330:1.2
	v20060919-0800:1.1.2.1
	v20060907-1100:1.1
	M1_20:1.1
	v20060803-1200:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060616-1200:1.1
	v20060609-1400:1.1
	v20060531-1730:1.1
	I20060505-1400:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1
	I20060216-1945:1.1
	I20060210-1715:1.1;
locks; strict;
comment	@# @;


1.3
date	2008.08.29.21.00.35;	author aboyko;	state Exp;
branches;
next	1.2;
commitid	19a448b863734567;

1.2
date	2006.10.03.15.05.27;	author ahunter;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2006.02.10.15.42.04;	author sshaw;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.09.13.16.44.42;	author ahunter;	state Exp;
branches;
next	;

1.2.4.1
date	2008.08.29.20.17.56;	author aboyko;	state Exp;
branches;
next	;
commitid	2c548b859734567;


desc
@@


1.3
log
@[238858] gmf_head aboyko [ImageSupport] Icons discoloured in exporting diagrams to PNG, SVG, JPEG on Linux
@
text
@/******************************************************************************
 * Copyright (c) 2004, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/


package org.eclipse.gmf.runtime.draw2d.ui.render.awt.internal.image;

import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;

import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.ImageData;
import org.eclipse.swt.graphics.PaletteData;
import org.eclipse.swt.graphics.RGB;
import org.eclipse.ui.PlatformUI;

/**
 * This is a helper class used to convert an SWT Image into an AWT
 * BufferedImage.
 * 
 * @@author Jody Schofield / sshaw
 *
 */
public class ImageConverter {

	private static final PaletteData PALETTE_DATA = new PaletteData(0xFF0000, 0xFF00, 0xFF);
	
	/**
	 * Converts an AWT based buffered image into an SWT <code>Image</code>.  This will always return an
	 * <code>Image</code> that has 24 bit depth regardless of the type of AWT buffered image that is 
	 * passed into the method.
	 * 
	 * @@param srcImage the {@@link java.awt.image.BufferedImage} to be converted to an <code>Image</code>
	 * @@return an <code>Image</code> that represents the same image data as the AWT 
	 * <code>BufferedImage</code> type.
	 */
	public static Image convert( BufferedImage srcImage) {
		// We can force bitdepth to be 24 bit because BufferedImage getRGB allows us to always
		// retrieve 24 bit data regardless of source color depth.
		ImageData swtImageData =
			new ImageData(srcImage.getWidth(), srcImage.getHeight(), 24, PALETTE_DATA);

		// ensure scansize is aligned on 32 bit.
		int scansize = (((srcImage.getWidth() * 3) + 3) * 4) / 4;
		
		WritableRaster alphaRaster = srcImage.getAlphaRaster();
		byte[] alphaBytes = new byte[srcImage.getWidth()];
			
		for (int y=0; y<srcImage.getHeight(); y++) {
			int[] buff = srcImage.getRGB(0, y, srcImage.getWidth(), 1, null, 0, scansize);
			swtImageData.setPixels(0, y, srcImage.getWidth(), buff, 0);
			
			// check for alpha channel
			if (alphaRaster != null) {
				int[] alpha = alphaRaster.getPixels(0, y, srcImage.getWidth(), 1, (int[])null);
				for (int i=0; i<srcImage.getWidth(); i++)
					alphaBytes[i] = (byte)alpha[i];
				swtImageData.setAlphas(0, y, srcImage.getWidth(), alphaBytes, 0);
			}
		}
	
		return new Image(PlatformUI.getWorkbench().getDisplay(), swtImageData);
	}
	
	/**
	 * Converts an swt based image into an AWT <code>BufferedImage</code>.  This will always return a
	 * <code>BufferedImage</code> that is of type <code>BufferedImage.TYPE_INT_ARGB</code> regardless of
	 * the type of swt image that is passed into the method.
	 * 
	 * @@param srcImage the {@@link org.eclipse.swt.graphics.Image} to be converted to a <code>BufferedImage</code>
	 * @@return a <code>BufferedImage</code> that represents the same image data as the swt <code>Image</code>
	 */
	public static BufferedImage convert( Image srcImage ) {
		
		ImageData imageData = srcImage.getImageData();
		int width = imageData.width;
		int height = imageData.height;
		ImageData maskData = null;
		int alpha[] = new int[1];
		
		if (imageData.alphaData == null)
			maskData = imageData.getTransparencyMask();
		
		// now we should have the image data for the bitmap, decompressed in imageData[0].data.
		// Convert that to a Buffered Image.
		BufferedImage image = new BufferedImage( imageData.width, imageData.height, BufferedImage.TYPE_INT_ARGB );
	    
	    WritableRaster alphaRaster = image.getAlphaRaster();

		// loop over the imagedata and set each pixel in the BufferedImage to the appropriate color.
		for( int y = 0; y < height; y++ )
		{
			for( int x = 0; x < width; x++ )
			{
				RGB color = imageData.palette.getRGB(imageData.getPixel(x, y));
				image.setRGB( x, y, new java.awt.Color(color.red, color.green, color.blue).getRGB());
		
				// check for alpha channel
				if (alphaRaster != null) {
					if( imageData.alphaData != null) {
						alpha[0] = imageData.getAlpha( x, y );
						alphaRaster.setPixel( x, y, alpha );
					}
					else {
						// check for transparency mask
						if( maskData != null) {
							alpha[0] = maskData.getPixel( x, y ) == 0 ? 0 : 255;
							alphaRaster.setPixel( x, y, alpha );
						}
					}
				}
			}
		}

		return image;
	}

}
@


1.2
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
d102 2
a103 4
				int color = imageData.getPixel( x, y );

				color = translateColor( imageData, color );
				image.setRGB( x, y, color );
a124 112

	private static int translateColor( ImageData imageData, int color ) {

		int bitCount = imageData.depth;
		RGB[] rgb = imageData.getRGBs();

		if( bitCount == 1 || bitCount == 4 || bitCount == 8 )
		{
			// Look up actual rgb value in the rgb array.
			if( rgb != null )
			{
				java.awt.Color foo = new java.awt.Color( rgb[color].red, rgb[color].green, rgb[color].blue );
				color = foo.getRGB();
			}
			else
			{
				color = 0;
			}
		}
		else if( bitCount == 16 )
		{
			int		BLUE_MASK					= 0x1f;
			int		GREEN_MASK					= 0x3e0;
			int		RED_MASK					= 0x7C00;
			
			// Each word in the bitmap array represents a single pixels, 5 bits for each
			// red, green and blue.
			color = applyRGBMask( color, RED_MASK, GREEN_MASK, BLUE_MASK );
		}
		else if( bitCount == 24 )
		{
			// 3 8 bit color values.
			int blue = (color & 0x00ff0000) >> 16;
			int green = (color & 0x0000ff00) >> 8;
			int red = (color & 0x000000ff);

			java.awt.Color foo = new java.awt.Color( red, green, blue );
			color = foo.getRGB();
		}
		else if( bitCount == 32 )
		{	
			int blue = (color & 0xff000000) >>> 24;
			int green = (color & 0x00ff0000) >> 16;
			int red = (color & 0x0000ff00) >> 8;

			java.awt.Color foo = new java.awt.Color( red, green, blue );
			color = foo.getRGB();
		}

		return color;
	}

	private static int applyRGBMask( int color, int redMask, int greenMask, int blueMask )
	{
		int shiftCount;
		int maskSize;
		int red;
		int green;
		int blue;
		
		shiftCount = getShiftCount( redMask );
		maskSize = countBits( redMask );
		red = ( color & redMask ) >>> shiftCount;
		// Scale the color value to something between 0 and 255.
		red = red * 255 / ( (int) Math.pow( 2, maskSize ) - 1 );
		
		shiftCount = getShiftCount( greenMask );
		maskSize = countBits( greenMask );
		green = ( color & greenMask ) >>> shiftCount;
		// Scale the color value to something between 0 and 255.
		green = green * 255 / ( (int) Math.pow( 2, maskSize ) - 1 );

		shiftCount = getShiftCount( blueMask );
		maskSize = countBits( blueMask );
		blue = ( color & blueMask ) >>> shiftCount;
		// Scale the color value to something between 0 and 255.
		blue = blue * 255 / ( (int) Math.pow( 2, maskSize ) - 1 );
		
		java.awt.Color foo = new java.awt.Color( red, green, blue );
		color = foo.getRGB();

		return color;
	}
	
	private static int getShiftCount( int mask )
	{
		int count = 0;
		
		while( mask != 0 && ( ( mask & 0x1 ) == 0 ) )
		{
			mask = mask >>> 1;
			count++;
		}
		
		return count;
	}
	
	private static int countBits( int mask )
	{
		int count = 0;
		for( int index = 0; index < 32; index++ )
		{
			if( ( mask & 0x1 ) != 0 )
			{
				count++;
			}
			mask = mask >>> 1;
		}
		
		return count;
	}

@


1.2.4.1
log
@[238858] gmf_R2_1_maintenance aboyko [ImageSupport] Icons discoloured in exporting diagrams to PNG, SVG, JPEG on Linux
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2008 IBM Corporation and others.
d102 4
a105 2
				RGB color = imageData.palette.getRGB(imageData.getPixel(x, y));
				image.setRGB( x, y, new java.awt.Color(color.red, color.green, color.blue).getRGB());
d127 112
@


1.1
log
@bugzilla 119319 gmf-head sshaw 060210 Support extensibility for RenderedImageFactory
@
text
@d2 1
a2 1
 * Copyright (c) 2004 IBM Corporation and others.
@


1.1.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2004, 2006 IBM Corporation and others.
@

