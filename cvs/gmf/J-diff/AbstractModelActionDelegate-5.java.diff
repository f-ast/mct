2c2
<  * Copyright (c) 2002, 2004 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2006 IBM Corporation and others.
13a14,15
> import org.eclipse.core.commands.ExecutionException;
> import org.eclipse.core.runtime.IAdaptable;
15c17,22
< 
---
> import org.eclipse.core.runtime.IStatus;
> import org.eclipse.core.runtime.NullProgressMonitor;
> import org.eclipse.core.runtime.Status;
> import org.eclipse.emf.transaction.TransactionalEditingDomain;
> import org.eclipse.emf.workspace.AbstractEMFOperation;
> import org.eclipse.gmf.runtime.common.core.util.Log;
19,20d25
< import org.eclipse.gmf.runtime.emf.core.exceptions.MSLActionAbandonedException;
< import org.eclipse.gmf.runtime.emf.core.util.OperationUtil;
22a28
> import org.eclipse.gmf.runtime.emf.ui.internal.MslUIStatusCodes;
28a35,43
>  * <P>
>  * Subclasses that execute a command must return <code>false</code>from
>  * {@link #isReadOnly()}. The superclass performs the
>  * {@link #doRun(IProgressMonitor)} method in an EMF operation executed on the
>  * operation history. Subclasses should set the action delegate status using
>  * {@link #setStatus(IStatus)} to their command execution status.
>  * <P>
>  * Subclasses that only want to read from the model must return
>  * <code>true</code> from {@link #isReadOnly()}.
34a50,51
>     private IStatus status;
>     
36c53
< 	 * Constructs a new model action delegate.
---
>      * Intializes me with the singleton editing domain.
47a65,67
> 
>         if (isReadOnly()) {
>             // run exclusive so that subclasses can only read from the model
49c69
< 			OperationUtil.runAsRead(new Runnable() {
---
>                 getEditingDomain().runExclusive(new Runnable() {
55,59c75,110
< 		} catch (MSLActionAbandonedException e) {
< 			// This is not expected to happen.
< 			Trace.trace(MslUIPlugin.getDefault(),
< 				MslUIDebugOptions.MODEL_OPERATIONS,
< 				"MSLActionAbandonedException"); //$NON-NLS-1$
---
>             } catch (InterruptedException e) {
>                 Trace
>                     .catching(MslUIPlugin.getDefault(),
>                         MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
>                         "run", e); //$NON-NLS-1$
>             }
> 
>         } else {
>             // run in an EMF operation so that subclasses can both read and
>             // write to the model
>             AbstractEMFOperation operation = new AbstractEMFOperation(
>                 getEditingDomain(), getLabel()) {
> 
>                 protected IStatus doExecute(IProgressMonitor monitor,
>                         IAdaptable info)
>                     throws ExecutionException {
> 
>                     AbstractModelActionDelegate.super.run(progressMonitor);
>                     return getStatus();
>                 };
>             };
> 
>             try {
>                 getActionManager().getOperationHistory().execute(operation,
>                     new NullProgressMonitor(), null);
> 
>             } catch (ExecutionException e) {
>                 Trace
>                     .catching(MslUIPlugin.getDefault(),
>                         MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
>                         "run", e); //$NON-NLS-1$
>                 Log.error(MslUIPlugin.getDefault(),
>                     MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
>                         .getLocalizedMessage(), e);
>             }
>         }
60a112,151
>     
>     /**
>      * Gets my editing domain. Can be <code>null</code> if I don't modify
>      * model resources.
>      * 
>      * @return my editing domain.
>      */
>     protected abstract TransactionalEditingDomain getEditingDomain();
>     
>     /**
>      * Answers whether or not I am a read-only action. Returns
>      * <code>false</code> by default. Subclasses may override.
>      * 
>      * @return <code>false</code>
>      */
>     protected boolean isReadOnly() {
>         return false;
>     }
>     
>     /**
>      * Gets the status of running this action delegate.
>      * 
>      * @return my status
>      */
>     protected IStatus getStatus() {
>         if (status == null) {
>             return Status.OK_STATUS;
>         }
>         return status;
>     }
>     
>     /**
>      * Sets the action delegate status. Subclasses should set the status when they
>      * execute a command.
>      * 
>      * @param status
>      *            the new status
>      */
>     protected void setStatus(IStatus status) {
>         this.status = status;
