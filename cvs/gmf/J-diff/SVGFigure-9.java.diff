15a16
> import java.awt.image.WritableRaster;
31d31
< import org.eclipse.core.runtime.IStatus;
38d37
< import org.eclipse.gmf.internal.runtime.lite.svg.SVGGraphics2D;
39a39
> import org.eclipse.swt.graphics.Device;
40a41,42
> import org.eclipse.swt.graphics.ImageData;
> import org.eclipse.swt.graphics.PaletteData;
52,53d53
< 	private boolean safeRendering;
< 	private boolean directRenderingSucceeded;
170,195d169
< 		directRenderingSucceeded = false;
< 		if (safeRendering) {
< 			paintUsingAWT(graphics, document);
< 		} else {
< 			// Try to paint directly on provided graphics with fallback to
< 			// safe routine.
< 			try {
< 				graphics.pushState();
< 				paintDirectly(graphics, document);
< 				directRenderingSucceeded = true;
< 			} catch (RuntimeException e) {
< 				Activator.log(IStatus.INFO, "Failed to paint SVG image directly", e);
< 				graphics.restoreState();
< 				paintUsingAWT(graphics, document);
< 			} finally {
< 				graphics.popState();
< 			}
< 		}
< 	}
< 
< 	private void paintDirectly(final Graphics graphics, Document document) {
< 		transcoder.setDraw2DGraphics(graphics);
< 		renderDocument(transcoder, document);
< 	}
< 
< 	private void paintUsingAWT(Graphics graphics, Document document) {
198d171
< 			transcoder.setDraw2DGraphics(null);
202c175
< 				image = SVGGraphics2D.toSWT(Display.getCurrent(), awtImage);
---
> 				image = toSWT(Display.getCurrent(), awtImage);
213,214c186,208
< 	public final boolean isDirectRenderingSucceeded() {
< 		return directRenderingSucceeded;
---
> 	/**
> 	 * Converts an AWT based buffered image into an SWT <code>Image</code>. This will always return an <code>Image</code> that
> 	 * has 24 bit depth regardless of the type of AWT buffered image that is passed into the method.
> 	 * 
> 	 * @param awtImage the {@link java.awt.image.BufferedImage} to be converted to an <code>Image</code>
> 	 * @return an <code>Image</code> that represents the same image data as the AWT <code>BufferedImage</code> type.
> 	 */
> 	private static org.eclipse.swt.graphics.Image toSWT(Device device, BufferedImage awtImage) {
> 		// We can force bitdepth to be 24 bit because BufferedImage getRGB
> 		// allows us to always retrieve 24 bit data regardless of source color depth.
> 		PaletteData palette = new PaletteData(0xFF0000, 0xFF00, 0xFF);
> 		ImageData swtImageData = new ImageData(awtImage.getWidth(), awtImage.getHeight(), 24, palette);
> 		// Ensure scansize is aligned on 32 bit.
> 		int scansize = (((awtImage.getWidth() * 3) + 3) * 4) / 4;
> 		WritableRaster alphaRaster = awtImage.getAlphaRaster();
> 		byte[] alphaBytes = new byte[awtImage.getWidth()];
> 		for (int y = 0; y < awtImage.getHeight(); y++) {
> 			int[] buff = awtImage.getRGB(0, y, awtImage.getWidth(), 1, null, 0, scansize);
> 			swtImageData.setPixels(0, y, awtImage.getWidth(), buff, 0);
> 			if (alphaRaster != null) {
> 				int[] alpha = alphaRaster.getPixels(0, y, awtImage.getWidth(), 1, (int[]) null);
> 				for (int i = 0; i < awtImage.getWidth(); i++) {
> 					alphaBytes[i] = (byte) alpha[i];
216,218c210
< 
< 	public final boolean isSafeRendering() {
< 		return safeRendering;
---
> 				swtImageData.setAlphas(0, y, awtImage.getWidth(), alphaBytes, 0);
220,223c212,213
< 
< 	public void setSafeRendering(boolean safeRendering) {
< 		this.safeRendering = safeRendering;
< 		repaint();
---
> 		}
> 		return new org.eclipse.swt.graphics.Image(device, swtImageData);
