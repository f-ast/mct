41a42
> import org.eclipse.gef.EditPartViewer;
72d72
< import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.DefaultEditableEditPart;
78d77
< import org.eclipse.gmf.runtime.diagram.ui.internal.l10n.DiagramFontRegistry;
80a80
> import org.eclipse.gmf.runtime.diagram.ui.internal.type.NotationTypeUtil;
82a83
> import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
84a86
> import org.eclipse.gmf.runtime.diagram.ui.preferences.IPreferenceConstants;
86a89
> import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
108a112,117
> import org.eclipse.jface.preference.IPreferenceStore;
> import org.eclipse.jface.preference.PreferenceConverter;
> import org.eclipse.jface.resource.DeviceResourceException;
> import org.eclipse.jface.resource.FontDescriptor;
> import org.eclipse.jface.resource.JFaceResources;
> import org.eclipse.jface.resource.ResourceManager;
113a123
> import org.eclipse.swt.graphics.Font;
115d124
< import org.eclipse.swt.widgets.Display;
134a144,148
>     /**
>      * Flag to indicate if the edit part is in edit mode
>      */
>     private boolean isEditable = true;
> 
142a157,169
>      
>     /**
>      * Cache the font data when a font is created so that it can be
>      * disposed later.
>      */
>     private FontData cachedFontData;
>     
>     /**
> 	 * Cache the answer to whether or not this is a semantic connection after it
> 	 * is retrieved.
> 	 */
>     private Boolean semanticConnection;
>     
162,164d188
< 	/** Used for handling the editable status of the edit part */
< 	private final IEditableEditPart editableEditPart;
< 
181c205,206
< 		EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(), semanticProxy);
---
>         EObject semanticElement = EMFCoreUtil.resolve(getEditingDomain(),
>             semanticProxy);
213,214c238
< 		getDiagramEventBroker().addNotificationListener(element,
< 			listener);
---
>         getDiagramEventBroker().addNotificationListener(element, listener);
241,242c265,266
< 		getDiagramEventBroker().addNotificationListener(element,
< 			feature, listener);
---
>         getDiagramEventBroker().addNotificationListener(element, feature,
>             listener);
325a350,359
>     public void removeNotify() {
>         super.removeNotify();
>         
>         if (cachedFontData != null) {
>             getResourceManager().destroyFont(
>                 FontDescriptor.createFrom(cachedFontData));
>             cachedFontData = null;
>         }
>     }
> 
453c487
< 		if (adapter == SnapToHelper.class) {
---
>         if (key == SnapToHelper.class) {
456,458c490,492
< 
< 			Boolean val = (Boolean) getViewer().getProperty(
< 				RulerProvider.PROPERTY_RULER_VISIBILITY);
---
>             EditPartViewer viewer = getViewer();
>             Boolean val = (Boolean) viewer
>                 .getProperty(RulerProvider.PROPERTY_RULER_VISIBILITY);
462,463c496,497
< 			val = (Boolean) getViewer().getProperty(
< 				SnapToGeometry.PROPERTY_SNAP_ENABLED);
---
>             val = (Boolean) viewer
>                 .getProperty(SnapToGeometry.PROPERTY_SNAP_ENABLED);
482c516
< 			return getModel();
---
>             return model;
540c574,575
< 			Log.error(DiagramUIPlugin.getInstance(),
---
>             Log
>                 .error(DiagramUIPlugin.getInstance(),
613a649,657
>         EObject eObj = ((View) getModel()).getElement();
>         if (eObj == null) {
>             return null;
>         }
> 
>         if (!eObj.eIsProxy()) {
>             return eObj;
>         }
> 
619c663,664
< 					setResult(ViewUtil.resolveSemanticElement((View) getModel()));
---
>                         setResult(ViewUtil
>                             .resolveSemanticElement((View) getModel()));
631d675
< 
671,672c715,716
< 	 * Handles the property changed event.  Clients should override to
< 	 * respond to the specific notification events they are interested.
---
>      * Handles the property changed event. Clients should override to respond to
>      * the specific notification events they are interested.
676,679c720,723
< 	 * unsupported calls (i.e. Display.getCurrent() ) assuming they are on
< 	 * the main thread.  Alternatively if this is not possible, then the
< 	 * client can wrap their handler within the Display.synchExec runnable
< 	 * to ensure synchronization and subsequent execution on the main thread.
---
>      * unsupported calls (i.e. Display.getCurrent() ) assuming they are on the
>      * main thread. Alternatively if this is not possible, then the client can
>      * wrap their handler within the Display.synchExec runnable to ensure
>      * synchronization and subsequent execution on the main thread.
682c726,727
< 	 *            the <code>Notification</code> object that is the property changed event
---
>      *            the <code>Notification</code> object that is the property
>      *            changed event
749c794
< 			NotationPackage.eINSTANCE.getLineStyle());
---
>             NotationPackage.Literals.LINE_STYLE);
751,752c796,797
< 			setForegroundColor(DiagramColorRegistry
< 				.getInstance().getColor(new Integer(style.getLineColor())));
---
>             setForegroundColor(DiagramColorRegistry.getInstance().getColor(
>                 new Integer(style.getLineColor())));
778c823
< 			DiagramEventBroker.getInstance(getEditingDomain()).removeNotificationListener(
---
>             getDiagramEventBroker().removeNotificationListener(
837,839c882,885
< 	 * This method adds all listeners to the semantic element behind this EditPart 
< 	 * Override this method to add more semantic listeners down the hierarchy
< 	 * This method is called only if the semantic element is resolvable
---
>      * This method adds all listeners to the semantic element behind this
>      * EditPart Override this method to add more semantic listeners down the
>      * hierarchy This method is called only if the semantic element is
>      * resolvable
858,860c904,906
< 	 * This method removes all listeners to the semantic element behind this EditPart
< 	 * Override this method to remove semantic listeners
< 	 * down the hierarchy
---
>      * This method removes all listeners to the semantic element behind this
>      * EditPart Override this method to remove semantic listeners down the
>      * hierarchy
890d935
< 		this.editableEditPart = new DefaultEditableEditPart(this);
977c1022
< 			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
---
>             .getStyle(NotationPackage.Literals.ROUTING_STYLE);
1032a1078
> 
1063c1109
< 			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
---
>             .getStyle(NotationPackage.Literals.ROUTING_STYLE);
1089c1135
< 			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
---
>             .getStyle(NotationPackage.Literals.ROUTING_STYLE);
1128c1174
< 			.getStyle(NotationPackage.eINSTANCE.getRoutingStyle());
---
>             .getStyle(NotationPackage.Literals.ROUTING_STYLE);
1134a1181,1186
>             
> 			if (avoidObstruction)
> 				installEditPolicy(EditPolicy.CONNECTION_BENDPOINTS_ROLE,null);
> 			else
> 				installBendpointEditPolicy();
> 
1159c1211
< 			NotationPackage.eINSTANCE.getFontStyle());
---
>             NotationPackage.Literals.FONT_STYLE);
1178,1180c1230,1238
< 		getFigure().setFont(
< 			DiagramFontRegistry.getInstance().getFont(Display.getDefault(),
< 				fontData));
---
>         if (cachedFontData != null && cachedFontData.equals(fontData)) {
>             // the font was previously set and has not changed; do nothing.
>             return;
>         }
> 
>         try {
>             Font newFont = getResourceManager().createFont(
>                 FontDescriptor.createFrom(fontData));
>             getFigure().setFont(newFont);
1181a1240,1252
> 
>             if (cachedFontData != null) {
>                 getResourceManager().destroyFont(
>                     FontDescriptor.createFrom(cachedFontData));
>             }
>             cachedFontData = fontData;
>         } catch (DeviceResourceException e) {
>             Trace.catching(DiagramUIPlugin.getInstance(),
>                 DiagramUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
>                 "setFont", e); //$NON-NLS-1$
>             Log.error(DiagramUIPlugin.getInstance(),
>                 DiagramUIStatusCodes.IGNORED_EXCEPTION_WARNING, "setFont", e); //$NON-NLS-1$
>         }
1330c1401,1423
< 		this.editableEditPart.disableEditMode();
---
>         if (isEditable == false) {
>             return;
>         }
> 
>         List l = getSourceConnections();
>         int size = l.size();
>         for (int i = 0; i < size; i++) {
>             Object obj = l.get(i);
>             if (obj instanceof IEditableEditPart) {
>                 ((IEditableEditPart) obj).disableEditMode();
>             }
>         }
> 
>         List c = getChildren();
>         size = c.size();
>         for (int i = 0; i < size; i++) {
>             Object obj = c.get(i);
>             if (obj instanceof IEditableEditPart) {
>                 ((IEditableEditPart) obj).disableEditMode();
>             }
>         }
> 
>         isEditable = false;
1337c1430,1450
< 		this.editableEditPart.enableEditMode();
---
>         if (isEditable) {
>             return;
>         }
>         isEditable = true;
>         List c = getChildren();
>         int size = c.size();
>         for (int i = 0; i < size; i++) {
>             Object obj = c.get(i);
>             if (obj instanceof IEditableEditPart) {
>                 ((IEditableEditPart) obj).enableEditMode();
>             }
>         }
> 
>         List l = getSourceConnections();
>         size = l.size();
>         for (int i = 0; i < size; i++) {
>             Object obj = l.get(i);
>             if (obj instanceof IEditableEditPart) {
>                 ((IEditableEditPart) obj).enableEditMode();
>             }
>         }
1344c1457,1458
< 		// protect against deadlock - don't allow any action while write transaction
---
>         // protect against deadlock - don't allow any action while write
>         // transaction
1348,1349c1462
< 		
< 		return this.editableEditPart.isEditModeEnabled();
---
>         return isEditable;
1413,1414c1526,1528
< 		if (getRoot() instanceof IDiagramPreferenceSupport) {
< 			return ((IDiagramPreferenceSupport) getRoot()).getPreferencesHint();
---
>         RootEditPart root = getRoot();
>         if (root instanceof IDiagramPreferenceSupport) {
>             return ((IDiagramPreferenceSupport) root).getPreferencesHint();
1438c1552
< 		if (NotationPackage.eINSTANCE.getView_PersistedChildren().equals(
---
>         if (NotationPackage.Literals.VIEW__PERSISTED_CHILDREN.equals(
1440c1554
< 			|| NotationPackage.eINSTANCE.getView_TransientChildren().equals(
---
>             || NotationPackage.Literals.VIEW__TRANSIENT_CHILDREN.equals(
1443c1557
< 		} else if (NotationPackage.eINSTANCE.getView_Visible().equals(feature)) {
---
>         } else if (NotationPackage.Literals.VIEW__VISIBLE.equals(feature)) {
1450c1564
< 		} else if (NotationPackage.eINSTANCE.getRoutingStyle_Routing().equals(
---
>         } else if (NotationPackage.Literals.ROUTING_STYLE__ROUTING.equals(
1453c1567
< 		} else if (NotationPackage.eINSTANCE.getRoutingStyle_Smoothness()
---
>         } else if (NotationPackage.Literals.ROUTING_STYLE__SMOOTHNESS
1455c1569
< 			|| NotationPackage.eINSTANCE.getRoutingStyle_AvoidObstructions()
---
>             || NotationPackage.Literals.ROUTING_STYLE__AVOID_OBSTRUCTIONS
1457c1571
< 			|| NotationPackage.eINSTANCE.getRoutingStyle_ClosestDistance()
---
>             || NotationPackage.Literals.ROUTING_STYLE__CLOSEST_DISTANCE
1459c1573
< 			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkStatus()
---
>             || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINK_STATUS
1461c1575
< 			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinkType().equals(
---
>             || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINK_TYPE.equals(
1463c1577
< 			|| NotationPackage.eINSTANCE.getRoutingStyle_JumpLinksReverse()
---
>             || NotationPackage.Literals.ROUTING_STYLE__JUMP_LINKS_REVERSE
1466c1580
< 		} else if (NotationPackage.eINSTANCE.getLineStyle_LineColor().equals(
---
>         } else if (NotationPackage.Literals.LINE_STYLE__LINE_COLOR.equals(
1469,1471c1583,1584
< 			setForegroundColor(DiagramColorRegistry
< 				.getInstance().getColor(c));
< 		} else if (NotationPackage.eINSTANCE.getRelativeBendpoints_Points()
---
>             setForegroundColor(DiagramColorRegistry.getInstance().getColor(c));
>         } else if (NotationPackage.Literals.RELATIVE_BENDPOINTS__POINTS
1474,1476c1587,1592
< 		} else if (event.getFeature() == NotationPackage.eINSTANCE
< 			.getView_Element()
< 			&& ((EObject) event.getNotifier()) == getNotationView())
---
>         } else if (event.getFeature() == NotationPackage.Literals
>             .VIEW__ELEMENT
>             && ((EObject) event.getNotifier()) == getNotationView()){
>             handleMajorSemanticChange();
>        } else if (event.getEventType() == EventType.UNRESOLVE
>                 && event.getNotifier() == ((View) getModel()).getElement())
1481,1482c1597,1598
< 	 * @return <code>IMapMode</code> that allows for the coordinate mapping from device to
< 	 * logical units. 
---
>      * @return <code>IMapMode</code> that allows for the coordinate mapping
>      *         from device to logical units.
1484c1600
< 	final protected IMapMode getMapMode() {
---
>     protected IMapMode getMapMode() {
1505c1621,1622
<                 editingDomain = TransactionUtil.getEditingDomain(getDiagramView());
---
>                 editingDomain = TransactionUtil
>                     .getEditingDomain(getDiagramView());
1522a1640,1707
>     
>     
>     public Object getPreferredValue(EStructuralFeature feature) {
>         Object preferenceStore = getDiagramPreferencesHint()
>             .getPreferenceStore();
>         if (preferenceStore instanceof IPreferenceStore) {            
>             if (feature == NotationPackage.eINSTANCE.getLineStyle_LineColor()) {
>                 
>                 return FigureUtilities.RGBToInteger(PreferenceConverter
>                     .getColor((IPreferenceStore) preferenceStore,
>                         IPreferenceConstants.PREF_LINE_COLOR));
>                 
>             } else if (feature == NotationPackage.eINSTANCE
>                 .getFontStyle_FontColor()) {
>                 
>                 return FigureUtilities.RGBToInteger(PreferenceConverter
>                     .getColor((IPreferenceStore) preferenceStore,
>                         IPreferenceConstants.PREF_FONT_COLOR));
>                 
>             }
>         }
>         return getStructuralFeatureValue(feature);
>     }
>     
>     
>     /**
>      * Gets the resource manager to remember the resources allocated for this
>      * graphical viewer. All resources will be disposed when the graphical
>      * viewer is closed if they have not already been disposed.
>      * 
>      * @return the resource manager
>      */
>     protected ResourceManager getResourceManager() {
>         EditPartViewer viewer = getViewer();
>         if (viewer instanceof DiagramGraphicalViewer) {
>             return ((DiagramGraphicalViewer) viewer).getResourceManager();
>         }
>         return JFaceResources.getResources();
>     } 
>     
>     /**
> 	 * Answers whether or not this connection represents a part of the semantic
> 	 * model.
> 	 * 
> 	 * @return <code>true</code> if this connection has semantic meaning,
> 	 *         <code>false</code> otherwise.
> 	 */
> 	public boolean isSemanticConnection() {
> 
> 		if (semanticConnection == null) {
> 			if (getEdge() != null && (getEdge().getElement() != null
> 					|| !NotationTypeUtil.hasNotationType(getEdge()))) {
> 				semanticConnection = Boolean.TRUE;
> 			} else {
> 				semanticConnection = Boolean.FALSE;
> 			}
> 		}
> 		return semanticConnection.booleanValue();
> 	}
> 	
> 	/**
> 	 * Clear the semantic connection value when the model changes.
> 	 */
> 	public void setModel(Object model) {
> 		super.setModel(model);
> 		semanticConnection = null;
> 	}
>   
