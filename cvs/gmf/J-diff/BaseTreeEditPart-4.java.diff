2c2
<  * Copyright (c) 2006 Eclipse.org
---
>  * Copyright (c) 2006, 2007 Borland Software Corporation
13a14,15
> import java.util.Collection;
> import java.util.Collections;
20a23
> import org.eclipse.emf.ecore.resource.Resource;
22a26,27
> import org.eclipse.emf.transaction.TransactionalEditingDomain;
> import org.eclipse.emf.transaction.util.TransactionUtil;
23a29,33
> import org.eclipse.gef.tools.CellEditorLocator;
> import org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelTextDisplayer;
> import org.eclipse.gmf.runtime.lite.edit.parts.labels.ILabelController;
> import org.eclipse.gmf.runtime.lite.edit.parts.labels.ItemProviderLabelTextDisplayer;
> import org.eclipse.gmf.runtime.lite.edit.parts.update.IExternallyUpdatableEditPart;
24a35,36
> import org.eclipse.gmf.runtime.lite.edit.parts.update.RefreshAdapter;
> import org.eclipse.gmf.runtime.lite.services.TreeDirectEditManager;
27a40,41
> import org.eclipse.jface.viewers.CellEditor;
> import org.eclipse.jface.viewers.TextCellEditor;
28a43
> import org.eclipse.swt.widgets.TreeItem;
33c48
< public class BaseTreeEditPart extends AbstractTreeEditPart implements IUpdatableEditPart {
---
> public class BaseTreeEditPart extends AbstractTreeEditPart implements IUpdatableEditPart, IExternallyUpdatableEditPart, ILabelController {
37a53,57
> 	private ILabelTextDisplayer myLabelTextDisplayer;
> 
> 	private RefreshAdapter myDomainModelRefresher = new RefreshAdapter(this);
> 
> 	private TreeDirectEditManager directEditManager;
51a72,87
> 	@Override
> 	public void activate() {
> 		super.activate();
> 		if (getElement() != null) {
> 			getElement().eAdapters().add(myDomainModelRefresher);
> 		}
> 	}
> 
> 	@Override
> 	public void deactivate() {
> 		if (getElement() != null) {
> 			getElement().eAdapters().remove(myDomainModelRefresher);
> 		}
> 		super.deactivate();
> 	}
> 
73a110,124
> 	public final ILabelTextDisplayer getLabelTextDisplayer() {
> 		if (myLabelTextDisplayer == null) {
> 			myLabelTextDisplayer = createLabelTextDisplayer();
> 		}
> 		return myLabelTextDisplayer;
> 	}
> 
> 	protected ILabelTextDisplayer createLabelTextDisplayer() {
> 		return new ItemProviderLabelTextDisplayer(myAdapterFactory);
> 	}
> 
> 	public void setLabelText(String text) {
> 		setWidgetText(text == null ? "" : text);	//$NON-NLS-1$
> 	}
> 
107,114c158,159
< 		if (getElement() == null) {
< 			return "";
< 		}
< 		IItemLabelProvider labelProvider = (IItemLabelProvider) myAdapterFactory.adapt(getElement(), IItemLabelProvider.class);
< 		if (labelProvider != null) {
< 			return labelProvider.getText(getElement());
< 		}
< 		return "";
---
> 		String result = getLabelTextDisplayer().getDisplayText(getElement());
> 		return result == null ? "" : result;
117c162
< 	private HashMap structuralFeatures2Refresher;
---
> 	private HashMap<EStructuralFeature, Refresher> structuralFeatures2Refresher;
127c172
< 		structuralFeatures2Refresher = new HashMap();
---
> 		structuralFeatures2Refresher = new HashMap<EStructuralFeature, Refresher>();
141a187,199
> 	private Collection<ExternalRefresher> myExternalRefreshers;
> 
> 	public Collection<ExternalRefresher> getExternalRefreshers() {
> 		if (myExternalRefreshers == null) {
> 			myExternalRefreshers = createExternalRefreshers();
> 		}
> 		return myExternalRefreshers;
> 	}
> 
> 	protected Collection<ExternalRefresher> createExternalRefreshers() {
> 		return Collections.<ExternalRefresher>singleton(new ILabelController.ExternalRefresherAdapter(this, getElement()));
> 	}
> 
152a211,269
> 
> 	public void performRequest(org.eclipse.gef.Request req) {
> 		if (org.eclipse.gef.RequestConstants.REQ_DIRECT_EDIT == req.getType() && understandsRequest(req)) {
> 			performDirectEdit();
> 		} else {
> 			super.performRequest(req);
> 		}
> 	}
> 
> 	protected TreeDirectEditManager getDirectEditManager() {
> 		if (directEditManager == null) {
> 			directEditManager = new TreeDirectEditManager(this, getCellEditorClass(), new CellEditorLocator() {
> 				public void relocate(CellEditor celleditor) {
> 					if (checkTreeItem()) {
> 						celleditor.getControl().setFont(((TreeItem) getWidget()).getFont());
> 						celleditor.getControl().setBounds(((TreeItem) getWidget()).getBounds());
> 					}
> 				}
> 			}) {
> 				protected void initCellEditor() {
> 					getCellEditor().setValue(getLabelTextDisplayer().getEditText(getElement()));
> 				}
> 			};
> 		}
> 		return directEditManager;
> 	}
> 
> 	protected Class<? extends CellEditor> getCellEditorClass() {
> 		return TextCellEditor.class;
> 	}
> 
> 	protected void performDirectEdit() {
> 		if (isReadOnly()) {
> 			return;
> 		}
> 		getDirectEditManager().show();
> 	}
> 
> 	/**
> 	 * Returns whether the element is read only. This is used to determine if direct edit should be invoked or not.
> 	 */
> 	protected boolean isReadOnly() {
> 		if (getElement() == null) {
> 			return true;
> 		}
> 		Resource notationResource = getNotationView().eResource();
> 		TransactionalEditingDomain editingDomain = TransactionUtil.getEditingDomain(notationResource);
> 		if (editingDomain == null) {
> 			return true;
> 		}
> 		if (editingDomain.isReadOnly(notationResource)) {
> 			return true;
> 		}
> 		Resource domainResource = getElement().eResource();
> 		if (domainResource == null) {
> 			return true;
> 		}
> 		return editingDomain.isReadOnly(domainResource);
> 	}
