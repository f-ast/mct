2c2
<  * Copyright (c) 2006 Borland Software Corporation
---
>  * Copyright (c) 2006, 2008 Borland Software Corporation
21,26c21
< 	private EClass myOwner;
< 	private Reflector myReflector;
< 	
< 	public interface Reflector {
< 		public Object reflect(EObject target);
< 	}
---
> 	private final EStructuralFeature myFeature;
29,34c24,25
< 		this(feature.getEContainingClass(), new StructuralFeatureReflector(feature));
< 	}
< 
< 	public ReflectiveMatcher(EClass reflectorOwner, Reflector reflector) {
< 		myOwner = reflectorOwner;
< 		myReflector = reflector;
---
> 		assert feature != null;
> 		myFeature = feature;
40c31
< 		Object currentValue = myReflector.reflect(current);
---
> 		Object currentValue = current.eGet(myFeature);
42c33
< 		return currentValue != null && currentValue.equals(myReflector.reflect(old));
---
> 		return currentValue != null && currentValue.equals(old.eGet(myFeature));
52c43
< 		if (!myOwner.isSuperTypeOf(eClass)) {
---
> 		if (!myFeature.getEContainingClass().isSuperTypeOf(eClass)) {
55,68c46
< 			throw new IllegalStateException(MessageFormat.format("EClass {0} is not compatible with expected class {1} ", new Object[] {eClass, myOwner}));
< 		}
< 	}
< 
< 	public static class StructuralFeatureReflector implements Reflector {
< 		private final EStructuralFeature myFeature;
< 		
< 		public StructuralFeatureReflector(EStructuralFeature feature) {
< 			assert feature != null;
< 			myFeature = feature;
< 		}
< 		
< 		public Object reflect(EObject target) {
< 			return target.eGet(myFeature);
---
> 			throw new IllegalStateException(MessageFormat.format("EClass {0} is not compatible with expected class {1} ", new Object[] {eClass, myFeature.getEContainingClass()}));
