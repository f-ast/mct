17c17
< import java.util.HashMap;
---
> import java.util.Hashtable;
21d20
< import java.util.Map;
34a34
> import org.eclipse.draw2d.geometry.PrecisionPoint;
37a38
> import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.BaseSlidableAnchor;
40d40
< import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.PolylineAnchor;
121c121,122
<     private Map connectionAnchors;
---
>     private Hashtable connectionAnchors;
> 	
158,167d158
< 	 * Returns the connectionAnchors.
< 	 * @return Hashtable
< 	 */
< 	protected Map getConnectionAnchors() {
< 		if (connectionAnchors == null)
< 			connectionAnchors = new HashMap(1);
< 		return connectionAnchors;
< 	}
<     
<     /**
998,1129d988
<     /**
<      * Contains location data about a point in relation
<      * with the polyline.
<      * See getPointInfo for more information.
<      */
<     static public class PointInfo {
<         /**
<          * orthogonal distance from line
<          */
<         public int      fromLine;
<         
<         /**
<          * distance from the end of the line
<          */
<         public int      fromEnd;
<         
<         /**
<          * are the values stored as a percentage value instead of relative coordinates.
<          */
<         public boolean  isPercentage = true;
<         
<         /**
<          * Defines a sign which encodes the positive or negative position of the point
<          * as defined in {@link LineSeg#positionRelativeTo}
<          */
<         public double   proj = 0.0;
<     }
< 
< 
<     private static boolean projIn( double proj ) {
<         return proj > 0 && proj < 1;
<     }
<     
<     /**
<      * returns a measure of how much proj is away from 0
<      * when negative of from 1 when positive
<      * returns 0 when proj is between 0 and 1
<      * intended to be called when proj is not between 0 and 1
<      */
<     private static double projFactor(double proj) {
<         if (proj < 0 )
<             return -proj;
<         else if (proj > 1.0)
<             return proj - 1.0;
<         else
<             return 0;
<     }
<     
<     private boolean atLeastOneProjectionCovers(Point p) {
<         boolean oneProjIn = false;
<         
<         List segments = PointListUtilities.getLineSegments(getPoints());
<         
<         ListIterator segIter = segments.listIterator();
<         while (segIter.hasNext() && !oneProjIn) {
<             LineSeg segment = (LineSeg) segIter.next();
<             double proj = segment.projection( p.x, p.y );
<             if (projIn(proj)) {
<                 oneProjIn = true;
<             }
<         }
<         
<         return oneProjIn;
<     }
< 
<     /**
<      * Returns a structure PointInfo that contains the following information:
<      * 1) perpendicular distance from the point p to the nearest segment 
<      * 2) percentage distance from the projection of point p to the nearest segment
<      * to the beginning of the polyline
<      * NOTE:
<      * 1) has a sign which encodes the positive or negative position of the point
<      * as defined in LineSeg.positionRelativeTo()
<      */
<     private PointInfo getPointInfo( Point p ) {
<         
<         PointInfo pointInfo = new PointInfo();
<         pointInfo.fromLine = Integer.MAX_VALUE;
<         pointInfo.fromEnd  = 0;
<         pointInfo.proj = Double.NEGATIVE_INFINITY;// so that initially projFactor is maximal
<         
<         List segments = PointListUtilities.getLineSegments(getPoints());
<         
<         int accumulatedLength = 0;
<         
<         boolean isCovered = atLeastOneProjectionCovers(p);
<         
<         ListIterator segIter = segments.listIterator();
<         while (segIter.hasNext()) {
<             LineSeg segment = (LineSeg) segIter.next();
<             double proj = segment.projection( p.x, p.y );
<             Point pt = segment.perpIntersect( p.x, p.y );
<             int perpDist = (int)Math.round(p.getDistance(pt));
<             if (isCovered) {
<                 // when covered we pick the smallest perpendicular distance
<                 if (perpDist < Math.abs(pointInfo.fromLine)) {
<                     if (proj > 0 && proj < 1 ) {
<                         pointInfo.fromLine = (segment.positionRelativeTo(p) == LineSeg.Sign.POSITIVE ? perpDist : -perpDist);
<                         Point origin = segment.getOrigin();             
<                         int inSegmentDistance = (int)Math.round(origin.getDistance(pt));
<                         double fractionDistance = ((double)(accumulatedLength + inSegmentDistance))/((double)PointListUtilities.getPointsLength(getPoints()));
<                         pointInfo.fromEnd = (int)Math.round(100*fractionDistance);
<                     }
<                 }
<             }
<             else {
<                 // when not covered we pick the smallest projFactor
<                 if (projFactor(proj) < projFactor(pointInfo.proj)) {
<                     pointInfo.fromLine = (segment.positionRelativeTo(p) == LineSeg.Sign.POSITIVE ? perpDist : -perpDist);
<                     Point origin = segment.getOrigin();             
<                     // we enforce the point to stay on a perpendicular position with regard to the segment
<                     int inSegmentDistance = proj>0 ? 
<                         Math.min((int)Math.round(origin.getDistance(pt)), (int)segment.length()) 
<                         : 0;
<                         
<                     double fractionDistance = ((double)(accumulatedLength + inSegmentDistance))/((double)PointListUtilities.getPointsLength(getPoints()));
<                     pointInfo.fromEnd = (int)Math.round(100*fractionDistance);
<                     if (pointInfo.fromEnd > 0 && pointInfo.fromEnd < 100)
<                         pointInfo.fromEnd += ((inSegmentDistance == (int)segment.length()) ? -1 : 1);// to avoid corners
<                     pointInfo.proj = proj;
<                 }
<             }
<             accumulatedLength += segment.length();
<         }
<             
<         // sanity check
<         if (pointInfo.fromLine == Integer.MAX_VALUE)
<             pointInfo.fromLine = 0;// we should never get here 
<                 
<         return pointInfo;
<     }
<     
1138,1139c997
< 	/* 
<      * (non-Javadoc)
---
> 	/* (non-Javadoc)
1143d1000
<         ConnectionAnchor connectionAnchor = (ConnectionAnchor)getConnectionAnchors().get(terminal);
1145,1146c1002,1013
<         if (connectionAnchor == null)
<             connectionAnchor = new PolylineAnchor(this, terminal);
---
> 		ConnectionAnchor connectAnchor =
> 			(ConnectionAnchor) getConnectionAnchors().get(terminal);
> 		if (connectAnchor == null) {
> 			if (terminal.equals(szAnchor)) {
> 				// get a new one - this figure doesn't support static anchors
> 				connectAnchor = createDefaultAnchor();
> 				getConnectionAnchors().put(terminal,connectAnchor);
> 			}
> 			else {
> 				connectAnchor = createAnchor(BaseSlidableAnchor.parseTerminalString(terminal));
> 			}
> 		}
1148c1015
<         return connectionAnchor;
---
> 		return connectAnchor;
1151,1152c1018
<     /* 
<      * (non-Javadoc)
---
> 	/* (non-Javadoc)
1155a1022,1024
> 		if (c instanceof BaseSlidableAnchor) {
> 			return ((BaseSlidableAnchor) c).getTerminal();
> 		}
1165c1034,1035
<         return null;
---
> 		getConnectionAnchor(szAnchor);
> 		return szAnchor;
1183,1185c1053,1056
<      * Returns a new anchor for this node figure.
<      * @param p Point on the figure that gives a hint which anchor to return.
<      * @return ConnectionAnchor reference to an anchor associated with the given point on the figure.
---
> 	 * Creates the default Slidable anchor with a reference point at the center
> 	 * of the figure's bounds
> 	 * 
> 	 * @return - default SlidableAnchor, relative reference the center of the figure
1187c1058,1060
<     protected ConnectionAnchor createConnectionAnchor(Point p) {
---
> 	protected ConnectionAnchor createDefaultAnchor() {
> 		return new BaseSlidableAnchor(this);
> 	}
1189,1190c1062,1075
<         ConnectionAnchor connectionAnchor = null;
<         int fromEnd = 0;
---
> 	/**
> 	 * Creates a slidable anchor at the specified point (from the ratio of the
> 	 * reference's coordinates and bounds of the figure
> 	 * 
> 	 * @param p - relative reference for the <Code>SlidableAnchor</Code>
> 	 * @return a <code>SlidableAnchor</code> for this figure with relative reference at p
> 	 */
> 	protected ConnectionAnchor createAnchor(PrecisionPoint p) {
> 		if (p==null)
> 			// If the old terminal for the connection anchor cannot be resolved (by SlidableAnchor) a null
> 			// PrecisionPoint will passed in - this is handled here
> 			return createDefaultAnchor();
> 		return new BaseSlidableAnchor(this, p);
> 	}
1192,1193c1077,1086
<         if (p.x < 0) {  // if negative - return an anchor at the center
<             connectionAnchor = new PolylineAnchor(this, fromEnd = 50);
---
> 	/**
> 	 * Returns a new anchor for this node figure.
> 	 * 
> 	 * @param p <code>Point</code> on the figure that gives a hint which anchor to return.
> 	 * @return <code>ConnectionAnchor</code> reference to an anchor associated with the 
> 	 * given point on the figure.
> 	 */
> 	protected ConnectionAnchor createConnectionAnchor(Point p) {
> 		if (p == null) {
> 			return getConnectionAnchor(szAnchor);
1196,1197c1089,1093
<             PointInfo pInfo = getPointInfo(p);
<             connectionAnchor = new PolylineAnchor(this, fromEnd = pInfo.fromEnd);
---
> 			Point temp = p.getCopy();
> 			translateToRelative(temp);
> 			PrecisionPoint pt = BaseSlidableAnchor.getAnchorRelativeLocation(temp, getBounds());
> 			return createAnchor(pt);
> 		}
1200,1202c1096,1107
<         if (connectionAnchor != null) {
<             String szKey = szAnchor + fromEnd;
<             getConnectionAnchors().put(szKey, connectionAnchor);
---
> 	/**
> 	 * Checks whether the <PrecisionPoint> p which is a candidate for a relative reference
> 	 * for the <Code>SlidableAnchor</Code> belongs to the area where the default anchor
> 	 * must be created
> 	 * 
> 	 * @param p
> 	 * @return <code>boolean</code> <code>true</code> if <PrecisionPoint> belongs to the area where the default anchor must be 
> 	 * created, <code>false</code> otherwise
> 	 */
> 	protected boolean isDefaultAnchorArea(PrecisionPoint p) {
> 		return p.preciseX >= getSlidableAnchorArea()/2 && p.preciseX <= 1 - getSlidableAnchorArea()/2 &&
> 			p.preciseY >= getSlidableAnchorArea()/2 && p.preciseY <= 1 - getSlidableAnchorArea()/2;
1205c1110,1127
<         return connectionAnchor;
---
> 	/**
> 	 * Returns the connectionAnchors.
> 	 * @return Hashtable
> 	 */
> 	protected Hashtable getConnectionAnchors() {
> 		if (connectionAnchors == null)
> 			connectionAnchors = new Hashtable(1);
> 		return connectionAnchors;
> 	}
> 	
> 	/**
> 	 * Specifies how large the area of the figure's bounds where <Code>SlidableAnchor</Code>
> 	 * will be created. The result number: 0<=result<=1
> 	 * 
> 	 * @return  the size of the area of the figure's bounds
> 	 */
> 	protected double getSlidableAnchorArea() {
> 		return 0.25;
