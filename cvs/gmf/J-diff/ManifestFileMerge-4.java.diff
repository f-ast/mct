17c17
< import java.util.Iterator;
---
> import java.util.Enumeration;
85c85
< 	protected String format(Map<String, String> oldHeaders) {
---
> 	protected String format(Map<String, String> oldHeaders) throws BundleException {
91c91
< 			sb.append(formatValue(e.getValue()));
---
> 			sb.append(formatValue(e.getKey(), e.getValue()));
97c97
< 	protected CharSequence formatValue(String value) {
---
> 	protected CharSequence formatValue(String headerHint, String value) throws BundleException {
101c101
< 		String[] values = ManifestElement.getArrayFromList(value);
---
> 		ManifestElement[] values = ManifestElement.parseHeader(headerHint, value);
104c104
< 		sb.append(values[0]);
---
> 		sb.append(formatValue(values[0]));
109c109,140
< 			sb.append(values[i]);
---
> 			sb.append(formatValue(values[i]));
> 		}
> 		return sb;
> 	}
> 
> 	protected CharSequence formatValue(ManifestElement element) {
> 		StringBuilder sb = new StringBuilder(element.getValue());
> 		// using tokens for directives and quoted strings for attributes
> 		// seems to be PDE convention, though I didn't find exact code that does that.
> 		// Without such a convention, it's very hard to tell whether original
> 		// directive or attribute was quoted or not - specialized Tokenizer from 
> 		// ManifestElement rips this information out.
> 		for (Enumeration<?> en = element.getDirectiveKeys(); en != null && en.hasMoreElements();) {
> 			final String directiveKey = (String) en.nextElement();
> 			for (String v : element.getDirectives(directiveKey)) {
> 				sb.append(';');
> 				sb.append(directiveKey);
> 				sb.append(':');
> 				sb.append('=');
> 				sb.append(v);
> 			}
> 		}
> 		for (Enumeration<?> en = element.getKeys(); en != null && en.hasMoreElements();) {
> 			final String attrKey = (String) en.nextElement();
> 			for (String v : element.getAttributes(attrKey)) {
> 				sb.append(';');
> 				sb.append(attrKey);
> 				sb.append('=');
> 				sb.append('"');
> 				sb.append(v);
> 				sb.append('"');
> 			}
143c174,175
< 		// ManifestElement.getArrayFromList(value).length > 1;
---
> 		// quick-and-dirty way. in rare cases may give false answer (i.e. when ;att="[1.0,2.0)"
> 		// but it's ok
146a179,182
> 	/**
> 	 * TODO rewrite to return ManifestElements instead of serializing result to String
> 	 * which will be parsed once again at {@link #format(Map)}. 
> 	 */
148,149c184,187
< 		String[] oldValues = ManifestElement.getArrayFromList(oldValue);
< 		LinkedList<String> returnValue = new LinkedList<String>();
---
> 		ManifestElement[] oldValues = ManifestElement.parseHeader(header, oldValue);
> 		if (oldValues == null || oldValues.length == 0) {
> 			return newValue;
> 		}
152,155c190
< 			returnValue.add(oldValues[i]);
< 			ManifestElement[] parsed = ManifestElement.parseHeader(header, oldValues[i]);
< 			assert parsed != null && parsed.length > 0;
< 			lookupValues[i] = parsed.length == 1 ? parsed[0].getValue() : oldValues[i];
---
> 			lookupValues[i] = oldValues[i].getValue();
158,168c193,196
< 		for (String n : ManifestElement.getArrayFromList(newValue)) {
< 			ManifestElement[] parsed = ManifestElement.parseHeader(header, n);
< 			assert parsed != null && parsed.length > 0;
< 			String toLookUp;
< 			if (parsed.length == 1) {
< 				toLookUp = parsed[0].getValue(); // look for directive-less part
< 			} else {
< 				toLookUp = n; // try the string itself
< 			}
< 			if (Arrays.binarySearch(lookupValues, toLookUp) < 0) {
< 				returnValue.add(n);
---
> 		LinkedList<ManifestElement> additionalElements = new LinkedList<ManifestElement>();
> 		for (ManifestElement n :  ManifestElement.parseHeader(header, newValue)) {
> 			if (Arrays.binarySearch(lookupValues, n.getValue()) < 0) {
> 				additionalElements.add(n);
172,174c200,202
< 		for (Iterator<String> it = returnValue.iterator(); it.hasNext();) {
< 			sb.append(it.next());
< 			if (it.hasNext()) {
---
> 		// we don't care about newlines as this is intermediate result
> 		for (ManifestElement me : oldValues) {
> 			sb.append(formatValue(me));
176a205,207
> 		for (ManifestElement me : additionalElements) {
> 			sb.append(formatValue(me));
> 			sb.append(',');
177a209,210
> 		assert sb.charAt(sb.length() - 1) == ',';
> 		sb.setLength(sb.length() - 1);
