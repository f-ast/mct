14a15
> import org.eclipse.core.commands.operations.IUndoableOperation;
21d21
< import org.eclipse.emf.workspace.AbstractEMFOperation;
45a46
>  * @auther ldamus
83,90c84,87
<             // run in an EMF operation so that subclasses can both read and
<             // write to the model
<             AbstractEMFOperation operation = new AbstractEMFOperation(
<                 getEditingDomain(), getLabel()) {
< 
<                 protected IStatus doExecute(IProgressMonitor monitor,
<                         IAdaptable info)
<                     throws ExecutionException {
---
>             // Run in a composite transactional operation so that subclasses can
> 			// both read and write to the model. Commands executed by subclasses
> 			// to modify the model will be appended to this composite
> 			// transactional operation.
92,94c89,93
<                     AbstractModelActionDelegate.super.run(progressMonitor);
<                     return getStatus();
<                 };
---
>         	Runnable runnable = new Runnable() {
> 				public void run() {
> 					AbstractModelActionDelegate.super
> 							.run(progressMonitor);
> 				}
97,99c96,98
<             try {
<                 getActionManager().getOperationHistory().execute(operation,
<                     new NullProgressMonitor(), null);
---
>         	WriteCommand write = new WriteCommand(getEditingDomain(),
> 					getLabel(), getActionManager().getOperationHistory(),
> 					runnable) {
101,108c100,101
<             } catch (ExecutionException e) {
<                 Trace
<                     .catching(MslUIPlugin.getDefault(),
<                         MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
<                         "run", e); //$NON-NLS-1$
<                 Log.error(MslUIPlugin.getDefault(),
<                     MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
<                         .getLocalizedMessage(), e);
---
> 				public IStatus getStatus() {
> 					return AbstractModelActionDelegate.this.getStatus();
109a103,105
> 			};
> 
>             execute(write, new NullProgressMonitor(), null);
153a150,183
>     /**
> 	 * Convenience method for subclasses to execute an undoable operation on the
> 	 * action manager's operation history. Sets my status to the status of the
> 	 * operation execution, and returns that status.
> 	 * 
> 	 * @param operation
> 	 *            the operation to be executed
> 	 * @param progressMonitor
> 	 *            the progress monitor
> 	 * @param info
> 	 *            the adaptable info, may be <code>null</code>
> 	 * @return the status of the operation execution.
> 	 */
> 	protected IStatus execute(IUndoableOperation operation,
> 			IProgressMonitor progressMonitor, IAdaptable info) {
> 
> 		try {
> 			setStatus(getActionManager().getOperationHistory().execute(
> 					operation, progressMonitor, info));
> 
> 		} catch (ExecutionException e) {
> 			setStatus(new Status(Status.ERROR, MslUIPlugin.getPluginId(),
> 					MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
> 							.getLocalizedMessage(), e));
> 			Trace
> 					.catching(MslUIPlugin.getDefault(),
> 							MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
> 							"run", e); //$NON-NLS-1$
> 			Log.error(MslUIPlugin.getDefault(),
> 					MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
> 							.getLocalizedMessage(), e);
> 		}
> 		return getStatus();
> 	}
