2c2
<  * Copyright (c) 2002, 2004 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2006 IBM Corporation and others.
13a14,15
> import org.eclipse.core.commands.ExecutionException;
> import org.eclipse.core.runtime.IAdaptable;
15,17c17,22
< import org.eclipse.ui.IWorkbenchPage;
< import org.eclipse.ui.IWorkbenchPart;
< 
---
> import org.eclipse.core.runtime.IStatus;
> import org.eclipse.core.runtime.NullProgressMonitor;
> import org.eclipse.core.runtime.Status;
> import org.eclipse.emf.transaction.TransactionalEditingDomain;
> import org.eclipse.emf.workspace.AbstractEMFOperation;
> import org.eclipse.gmf.runtime.common.core.util.Log;
21,22d25
< import org.eclipse.gmf.runtime.emf.core.exceptions.MSLActionAbandonedException;
< import org.eclipse.gmf.runtime.emf.core.util.OperationUtil;
24a28,30
> import org.eclipse.gmf.runtime.emf.ui.internal.MslUIStatusCodes;
> import org.eclipse.ui.IWorkbenchPage;
> import org.eclipse.ui.IWorkbenchPart;
36a43,44
>     private IStatus status;
> 
69a78,80
>         
>         if (isReadOnly()) {
>             // run exclusive so that subclasses can only read from the model
71c82
< 			OperationUtil.runAsRead(new Runnable() {
---
>                 getEditingDomain().runExclusive(new Runnable() {
77,81c88,142
< 		} catch (MSLActionAbandonedException e) {
< 			// This is not expected to happen.
< 			Trace.trace(MslUIPlugin.getDefault(),
< 				MslUIDebugOptions.MODEL_OPERATIONS,
< 				"MSLActionAbandonedException"); //$NON-NLS-1$
---
>             } catch (InterruptedException e) {
>                 Trace
>                     .catching(MslUIPlugin.getDefault(),
>                         MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
>                         "run", e); //$NON-NLS-1$
>             }
> 
>         } else {
>             // run in an EMF operation so that subclasses can both read and
>             // write to the model
>             AbstractEMFOperation operation = new AbstractEMFOperation(
>                 getEditingDomain(), getLabel()) {
> 
>                 protected IStatus doExecute(IProgressMonitor monitor,
>                         IAdaptable info)
>                     throws ExecutionException {
> 
>                     AbstractModelActionHandler.super.run(progressMonitor);
>                     return getStatus();
>                 };
>             };
> 
>             try {
>                 getActionManager().getOperationHistory().execute(operation,
>                     new NullProgressMonitor(), null);
> 
>             } catch (ExecutionException e) {
>                 Trace
>                     .catching(MslUIPlugin.getDefault(),
>                         MslUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
>                         "run", e); //$NON-NLS-1$
>                 Log.error(MslUIPlugin.getDefault(),
>                     MslUIStatusCodes.IGNORED_EXCEPTION_WARNING, e
>                         .getLocalizedMessage(), e);
>             }
>         }
>         
> 	}
>     
>     /**
>      * Gets my editing domain. Can be <code>null</code> if I don't modify
>      * model resources.
>      * 
>      * @return my editing domain.
>      */
>     protected abstract TransactionalEditingDomain getEditingDomain();
>     
>     /**
>      * Answers whether or not I am a read-only action. Returns
>      * <code>false</code> by default. Subclasses may override.
>      * 
>      * @return <code>false</code>
>      */
>     protected boolean isReadOnly() {
>         return false;
82a144,165
>     
>     /**
>      * Gets the status of running this action delegate.
>      * 
>      * @return my status
>      */
>     protected IStatus getStatus() {
>         if (status == null) {
>             return Status.OK_STATUS;
>         }
>         return status;
>     }
>     
>     /**
>      * Sets the action delegate status. Subclasses should set the status when they
>      * execute a command.
>      * 
>      * @param status
>      *            the new status
>      */
>     protected void setStatus(IStatus status) {
>         this.status = status;
