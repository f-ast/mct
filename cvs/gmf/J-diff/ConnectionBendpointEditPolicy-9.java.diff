2c2
<  * Copyright (c) 2002, 2005 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2007 IBM Corporation and others.
18a19
> import org.eclipse.core.runtime.Assert;
19a21
> import org.eclipse.draw2d.AutomaticRouter;
22a25,26
> import org.eclipse.draw2d.ConnectionAnchor;
> import org.eclipse.draw2d.geometry.Dimension;
25c29,30
< import org.eclipse.draw2d.geometry.Rectangle;
---
> import org.eclipse.draw2d.geometry.PrecisionPoint;
> import org.eclipse.draw2d.geometry.PrecisionRectangle;
31a37
> import org.eclipse.gef.handles.BendpointCreationHandle;
33a40
> import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
37d43
< import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.OrthogonalRouterUtilities;
39a46
> import org.eclipse.gmf.runtime.gef.ui.internal.handles.BendpointMoveHandleEx;
41d47
< import org.eclipse.jface.util.Assert;
152c158
< 				new BendpointMoveHandle(
---
> 				new BendpointMoveHandleEx(
336c342
< 			OrthogonalRouterUtilities.resetEndPointsToCenter(getConnection(), pts);
---
> 			//OrthogonalRouterUtilities.resetEndPointsToCenter(getConnection(), pts);
559,560c565
< 			if (REQ_CREATE_BENDPOINT.equals(request.getType())
< 				|| REQ_MOVE_BENDPOINT.equals(request.getType())) {
---
> 			if (REQ_CREATE_BENDPOINT.equals(request.getType())) {
561a567,568
> 			} else if (REQ_MOVE_BENDPOINT.equals(request.getType())) {
> 				showMoveOrthogonalBenspointFeedback((BendpointRequest) request);
562a570
> 			
636,638c644,645
< 		Rectangle startRect =
< 			new Rectangle(
< 				getConnection().getSourceAnchor().getOwner().getBounds());
---
> 		PrecisionRectangle startRect =
> 			new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getConnection().getSourceAnchor().getOwner()));
641,644c648,654
< 		getConnection().translateToRelative(startRect);
< 		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED))
< 			startRect.expand(MapModeUtil.getMapMode(getConnection()).DPtoLP(-2), 
< 							MapModeUtil.getMapMode(getConnection()).DPtoLP(-2));
---
> 		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
> 			if (line.isHorizontal()) {
> 				startRect.shrink(0, 2);
> 			} else {
> 				startRect.shrink(2, 0);
> 			}
> 		}
646c656,661
< 		if (!startRect.contains(line.getOrigin())) {
---
> 		getConnection().translateToRelative(startRect);
> 		/*
> 		 * Rectangle needs to be expanded by the "odd" number below because the number after
> 		 * translations could be N.999999999... 
> 		 */
> 		if (!startRect.expand(0.000001, 0.000001).contains(new PrecisionPoint(line.getOrigin()))) {
655c670
< 	* Utility method to determine if the constraint needs to be adjusted becauase the line is
---
> 	* Utility method to determine if the constraint needs to be adjusted because the line is
664,666c679,680
< 		Rectangle endRect =
< 			new Rectangle(
< 				getConnection().getTargetAnchor().getOwner().getBounds());
---
> 		PrecisionRectangle endRect =
> 			new PrecisionRectangle(FigureUtilities.getAnchorableFigureBounds(getConnection().getTargetAnchor().getOwner()));
669,672c683,689
< 		getConnection().translateToRelative(endRect);
< 		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED))
< 			endRect.expand(MapModeUtil.getMapMode(getConnection()).DPtoLP(-2), 
< 						MapModeUtil.getMapMode(getConnection()).DPtoLP(-2)); 
---
> 		if (getLineSegMode().equals(LineMode.ORTHOGONAL_CONSTRAINED)) {
> 			if (line.isHorizontal()) {
> 				endRect.shrink(0, 2);
> 			} else {
> 				endRect.shrink(2, 0);
> 			}
> 		}
674c691,696
< 		if (!endRect.contains(line.getTerminus())) {
---
> 		/*
> 		 * Rectangle needs to be expanded by the "odd" number below because the number after
> 		 * translations could be N.999999999... 
> 		 */
> 		getConnection().translateToRelative(endRect);
> 		if (!endRect.expand(0.00001, 0.00001).contains(new PrecisionPoint(line.getTerminus()))) {
702,703c724
< 	* Method showOutsideSourceFeedback.
< 	* Adds a bendpoint to the beginning of the constraint.
---
> 	 * Draws feedback for moving a bend point of a rectilinear connection
705c726
< 	* @param constraint List of bendpoints that the source point will be added too.
---
> 	 * @param request Benndpoint request
707,710c728,730
< 	protected void showOutsideSourceFeedback(List constraint) {
< 		Point ptAdd = ((Bendpoint) constraint.get(0)).getLocation();
< 		Bendpoint bp = new AbsoluteBendpoint(ptAdd);
< 		constraint.add(0, bp);
---
> 	private void showMoveOrthogonalBenspointFeedback(BendpointRequest request) {
> 		if (getFeedbackState().originalConstraint == null) {
> 			saveOriginalConstraint();
713,724c733,756
< 	/**
< 	* Method showOutsideTargetFeedback.
< 	* Adds a bendpoint to the end of the constraint.
< 	* 
< 	* @param constraint List of bendpoints that the target point will be added too.
< 	*/
< 	protected void showOutsideTargetFeedback(List constraint) {
< 		Point ptAdd =
< 			((Bendpoint) constraint.get(constraint.size() - 1))
< 				.getLocation();
< 		Bendpoint bp = new AbsoluteBendpoint(ptAdd);
< 		constraint.add(constraint.size() - 1, bp);
---
> 		Point ptLoc = new Point(request.getLocation());
> 		List constraint = (List)
> 			getConnection().getRoutingConstraint();
> 		
> 		getConnection().translateToRelative(ptLoc);
> 		
> 		int index =
> 		getFeedbackState().isOutsideSource ? request.getIndex() + 1 : request.getIndex();
> 		
> 		Point previous = ((Bendpoint)constraint.get(index - 1)).getLocation();
> 		Point moving = ((Bendpoint)constraint.get(index)).getLocation();
> 		Point next = ((Bendpoint)constraint.get(index + 1)).getLocation();
> 		
> 		LineSeg originalFirst = new LineSeg(previous.getCopy(), moving.getCopy());
> 		LineSeg originalSecond = new LineSeg(moving.getCopy(), next.getCopy());
> 		
> 		Dimension diff = ptLoc.getDifference(moving);
> 		
> 		if (originalFirst.isHorizontal()) {
> 			previous.y += diff.height;
> 			next.x += diff.width;
> 		} else {
> 			previous.x += diff.width;
> 			next.y += diff.height;
726a759,770
> 		LineSeg movedFirst = new LineSeg(previous, ptLoc.getCopy());
> 		LineSeg movedSecond = new LineSeg(ptLoc.getCopy(), next);
> 		
> 		index = adjustOutsideBoundsLineFeedback(movedFirst, index - 1, constraint, originalFirst);
> 		constraint.set(index, new AbsoluteBendpoint(movedFirst.getOrigin()));
> 		constraint.set(index + 1, new AbsoluteBendpoint(movedFirst.getTerminus()));
> 		
> 		index = adjustOutsideBoundsLineFeedback(movedSecond, index + 1, constraint, originalSecond);
> 		constraint.set(index + 1, new AbsoluteBendpoint(movedSecond.getTerminus()));
> 		
> 		getConnection().setRoutingConstraint(constraint);	}
> 
751,759d794
< 		if (!newLine.isHorizontal() && !newLine.isVertical()) {
< 			if (Math.abs(newLine.getOrigin().x - newLine.getTerminus().x) < 
< 				Math.abs(newLine.getOrigin().y - newLine.getTerminus().y)) {
< 				newLine.setTerminus(new Point(newLine.getOrigin().x, newLine.getTerminus().y));
< 			}
< 			else {
< 				newLine.setTerminus(new Point(newLine.getTerminus().x, newLine.getOrigin().y));
< 			}
< 		}
761c796
< 		index = adjustOutsideBoundsLineFeedback(request, constraint, index, newLine);
---
> 		index = adjustOutsideBoundsLineFeedback(newLine, index, constraint, moveLine);
763a799
> 		
771,773d806
< 	 * @param request BendpointRequest that triggered the gesture
< 	 * @param constraint List of Bendpoint objects that is the constraint to the gesture.
< 	 * @param index int index of the line that the user is currently manipulating.
774a808,810
> 	 * @param index the index
> 	 * @param constraint List of Bendpoint objects that is the constraint to the gesture.
> 	 * @param moveLine original segment that is being manipulated
777,778c813
< 	protected int adjustOutsideBoundsLineFeedback(BendpointRequest request, List constraint, int index, LineSeg newLine) {
< 		
---
> 	private int adjustOutsideBoundsLineFeedback(LineSeg newLine, int index, List constraint, LineSeg moveLine) {
783d817
< 				LineSeg moveLine = getLineSeg(constraint, index + 1);
797c831
< 		if (request.getIndex() == 0 && lineOutsideSource(newLine)) {
---
> 		if (index == 0 && lineOutsideSource(newLine)) {
802c836
< 		} else if (getFeedbackState().isOutsideSource) {
---
> 		} else if (index == 1 && getFeedbackState().isOutsideSource && !lineOutsideSource(newLine)) {
815c849,850
< 		} else if (getFeedbackState().isOutsideTarget) {
---
> 		} else if (checkTargetIndex == constraint.size() - 2 && getFeedbackState().isOutsideTarget
> 				&& !lineOutsideTarget(newLine)) {
819d853
< 
822c856
< 			index = request.getIndex();
---
> 			index--;
830,831c864,865
< 			showOutsideSourceFeedback(constraint);
< 			index = request.getIndex() + 1;
---
> 			showOutsideSourceFeedback(newLine, moveLine, constraint);
> 			index++;
835c869
< 			showOutsideTargetFeedback(constraint);
---
> 			showOutsideTargetFeedback(newLine, moveLine, constraint);
840a875,927
> 	* Method showOutsideSourceFeedback.
> 	* Adds a bendpoint to the beginning of the constraint.
> 	* Also adjusts the new segment with respect to added constraint
> 	* 
> 	* @param constraint List of bendpoints that the source point will be added too.
> 	*/
> 	private void showOutsideSourceFeedback(LineSeg newLine, LineSeg moveLine, List constraint) {
> 		Connection conn = (Connection)getHostFigure();
> 		ConnectionAnchor anchor = conn.getSourceAnchor();
> 		PrecisionPoint startPoint = new PrecisionPoint(anchor.getOwner().getBounds().getCenter());
> 		anchor.getOwner().translateToAbsolute(startPoint);
> 		conn.translateToRelative(startPoint);
> 		PrecisionRectangle bounds = new PrecisionRectangle(anchor.getOwner().getBounds());
> 		anchor.getOwner().translateToAbsolute(bounds);
> 		conn.translateToRelative(bounds);
> 		Point origin = new Point(newLine.getOrigin());
> 		if (moveLine.isHorizontal()) {
> 			origin.x = startPoint.x;
> 		} else {
> 			origin.y = startPoint.y;
> 		}
> 		newLine.setOrigin(origin);
> 		constraint.add(0, new AbsoluteBendpoint(startPoint));
> 		
> 	}
> 
> 	/**
> 	* Method showOutsideTargetFeedback.
> 	* Adds a bendpoint to the end of the constraint.
> 	* Also adjusts the new segment with respect to added constraint
> 	* 
> 	* @param constraint List of bendpoints that the target point will be added too.
> 	*/
> 	private void showOutsideTargetFeedback(LineSeg newLine, LineSeg moveLine, List constraint) {
> 		Connection conn = (Connection)getHostFigure();
> 		ConnectionAnchor anchor = conn.getTargetAnchor();
> 		PrecisionPoint endPoint = new PrecisionPoint(anchor.getOwner().getBounds().getCenter());
> 		anchor.getOwner().translateToAbsolute(endPoint);
> 		conn.translateToRelative(endPoint);
> 		PrecisionRectangle bounds = new PrecisionRectangle(anchor.getOwner().getBounds());
> 		anchor.getOwner().translateToAbsolute(bounds);
> 		conn.translateToRelative(bounds);
> 		Point terminus = new Point(newLine.getTerminus()); 
> 		if (moveLine.isHorizontal()) {
> 			terminus.x = endPoint.x;
> 		} else {
> 			terminus.y = endPoint.y;
> 		}
> 		newLine.setTerminus(terminus);
> 		constraint.add(new AbsoluteBendpoint(endPoint));
> 	}
> 
> 	/**
