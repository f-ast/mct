54a55,56
> 	private int interval;
> 	
66a69
> 	 * @param interval interval between border items used in collision resolving (must be > 0)
69c72,73
< 	public BorderItemLocator(IFigure parentFigure) {
---
> 	public BorderItemLocator(int interval, IFigure parentFigure) {
> 		Assert.isTrue(interval > 0);
71a76,85
> 		this.interval = interval;
> 	}
> 
> 	/**
> 	 * The preferred side determines placement of figure.
> 	 * 
> 	 * @param parentFigure
> 	 */
> 	public BorderItemLocator(IFigure parentFigure) {
> 		this(MapModeUtil.getMapMode(parentFigure).DPtoLP(8), parentFigure);
87a102,115
> 	 * The preferred side determines placement of figure.
> 	 * 
> 	 * @param parentFigure
> 	 * @param preferredSide
> 	 *            the preferred side of the parent figure on which to place this
> 	 *            border item as defined in {@link PositionConstants}
> 	 * @param interval interval between border items used in collision resolving (must be > 0)
> 	 */
> 	public BorderItemLocator(IFigure parentFigure, int preferredSide, int interval) {
> 		this(interval, parentFigure);
> 		this.preferredSide = preferredSide;
> 	}
> 	
> 	/**
98a127,139
> 	/**
> 	 * The preferred location overrides the preferred side.
> 	 * 
> 	 * @param parentFigure
> 	 * @param constraint
> 	 * @param interval interval between border items used in collision resolving (must be > 0)
> 	 */
> 	public BorderItemLocator(IFigure borderItem, IFigure parentFigure,
> 			Rectangle constraint, int interval) {
> 		this(interval, parentFigure);
> 		setConstraint(constraint);
> 	}
> 
294,296d334
< 		int vertical_gap = MapModeUtil.getMapMode(getParentFigure()).DPtoLP(8);
< 		int horizontal_gap = MapModeUtil.getMapMode(getParentFigure())
< 			.DPtoLP(8);
304,306c342,343
< 					recommendedLocation.y = calculateNextNonConflictingPosition(
< 							conflictingBorderItem.getBounds().getBottomLeft().y,
< 							vertical_gap, suggestedSide, borderItem);
---
> 					calculateNextNonConflictingPosition(recommendedLocation,
> 							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
321,323c358,359
< 					recommendedLocation.x = calculateNextNonConflictingPosition(
< 							conflictingBorderItem.getBounds().getTopRight().x,
< 							horizontal_gap, suggestedSide, borderItem);
---
> 					calculateNextNonConflictingPosition(recommendedLocation,
> 							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
338,340c374,375
< 					recommendedLocation.y = calculateNextNonConflictingPosition(
< 							conflictingBorderItem.getBounds().getLocation().y,
< 							vertical_gap, suggestedSide, borderItem);
---
> 					calculateNextNonConflictingPosition(recommendedLocation,
> 							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
354,356c389,390
< 					recommendedLocation.x = calculateNextNonConflictingPosition(
< 							conflictingBorderItem.getBounds().getLocation().x,
< 							horizontal_gap, suggestedSide, borderItem);
---
> 					calculateNextNonConflictingPosition(recommendedLocation,
> 							interval, suggestedSide, borderItem, conflictingBorderItem.getBounds());
372,382c406,425
< 	 * Default behavior is to simply check in a counter clockwise direction.
< 	 * Note:  if the currentSide is EAST or WEST, the y co-oridinate is passed as the current position.  Otherwise,
< 	 * if NORTH or SOUTH is the currentSide, then the x co-oridinate of the borderitem is passed.
< 	 * 
< 	 * @param currentPosition	The current x or y co-ordinate of the border item
< 	 * @param interval			The suggested spacing to try to find the next non-conflicting position
< 	 * @param currentSide		The current side of the border item 
< 	 * @param borderItem 		The borderItem being relocated (here to be used by subclasses if needed)
< 	 * @return the next possible non-conflicting position
< 	 */
< 	protected int calculateNextNonConflictingPosition(int currentPosition, int interval, int currentSide, IFigure borderItem) {
---
> 	 * Modifies the location of the border item (currentLocation) to avoid
> 	 * overlapping with the obstacle rectangle (another border item bounds)
> 	 * 
> 	 * @param currentLocation
> 	 *            The current location of the border item
> 	 * @param interval
> 	 *            The suggested spacing to try to find the next non-conflicting
> 	 *            position
> 	 * @param currentSide
> 	 *            The current side of the border item
> 	 * @param borderItem
> 	 *            The borderItem being relocated (here to be used by subclasses
> 	 *            if needed)
> 	 * @param obstacle
> 	 *            The bounds of the border item conflicting with the border item
> 	 *            currently being relocated
> 	 */
> 	protected void calculateNextNonConflictingPosition(Point currentLocation,
> 			int interval, int currentSide, IFigure borderItem,
> 			Rectangle obstacle) {
384c427,429
< 			case PositionConstants.WEST:  // Fall through  -- Move down the west side
---
> 		case PositionConstants.WEST:
> 			currentLocation.y = obstacle.getBottomLeft().y + interval;
> 			break;
386,390c431,445
< 				return currentPosition + interval;
< 			case PositionConstants.EAST:  // Fall through - Move towards the north side
< 			case PositionConstants.NORTH: // Fall through - Move towards the west side
< 			default: /* Should never get here, but if we do, we'll default to subtraction */
< 				return currentPosition - interval;
---
> 			currentLocation.x = obstacle.getBottomRight().x + interval;
> 			break;
> 		case PositionConstants.EAST:
> 			currentLocation.y = obstacle.getTopRight().y - interval
> 					- borderItem.getBounds().height;
> 			break;
> 		case PositionConstants.NORTH: // Move towards the west side
> 			currentLocation.x = obstacle.getTopLeft().x - interval
> 					- borderItem.getBounds().width;
> 			break;
> 		default:
> 			throw new IllegalArgumentException(
> 					"Invalid side argument: " //$NON-NLS-1$
> 							+ currentSide
> 							+ ". Should be the value from PositionConstants: WEST, EAST, NORTH or SOUTH"); //$NON-NLS-1$
