2c2
<  * Copyright (c) 2006 Borland Software Corp.
---
>  * Copyright (c) 2006 Borland Software Corporation
14,15d13
< import java.io.IOException;
< import java.util.ArrayList;
17d14
< import java.util.Collections;
23,29c20,21
< import org.eclipse.core.runtime.IStatus;
< import org.eclipse.core.runtime.NullProgressMonitor;
< import org.eclipse.core.runtime.Status;
< import org.eclipse.draw2d.LightweightSystem;
< import org.eclipse.draw2d.Viewport;
< import org.eclipse.draw2d.parts.ScrollableThumbnail;
< import org.eclipse.draw2d.parts.Thumbnail;
---
> import org.eclipse.draw2d.ColorConstants;
> import org.eclipse.draw2d.IFigure;
39a32,34
> import org.eclipse.gef.EditDomain;
> import org.eclipse.gef.EditPart;
> import org.eclipse.gef.GraphicalEditPart;
41,44d35
< import org.eclipse.gef.KeyHandler;
< import org.eclipse.gef.KeyStroke;
< import org.eclipse.gef.LayerConstants;
< import org.eclipse.gef.RootEditPart;
48,51d38
< import org.eclipse.gef.editparts.FreeformGraphicalRootEditPart;
< import org.eclipse.gef.editparts.RootTreeEditPart;
< import org.eclipse.gef.editparts.ScalableFreeformRootEditPart;
< import org.eclipse.gef.editparts.ScalableRootEditPart;
55d41
< import org.eclipse.gef.ui.actions.GEFActionConstants;
58d43
< import org.eclipse.gef.ui.actions.UpdateAction;
60,66c45
< import org.eclipse.gef.ui.parts.ContentOutlinePage;
< import org.eclipse.gef.ui.parts.GraphicalEditorWithFlyoutPalette;
< import org.eclipse.gef.ui.parts.TreeViewer;
< import org.eclipse.gmf.internal.runtime.lite.Activator;
< import org.eclipse.gmf.runtime.lite.edit.parts.tree.DiagramTreeEditPartFactory;
< import org.eclipse.gmf.runtime.lite.properties.PropertySourceProvider;
< import org.eclipse.gmf.runtime.lite.properties.UndoablePropertySheetEntry;
---
> import org.eclipse.gef.ui.views.palette.PalettePage;
69d47
< import org.eclipse.jface.action.Action;
71,78d48
< import org.eclipse.jface.action.IToolBarManager;
< import org.eclipse.jface.viewers.ISelection;
< import org.eclipse.jface.viewers.ISelectionChangedListener;
< import org.eclipse.jface.viewers.StructuredSelection;
< import org.eclipse.swt.SWT;
< import org.eclipse.swt.events.DisposeEvent;
< import org.eclipse.swt.events.DisposeListener;
< import org.eclipse.swt.widgets.Canvas;
80,81d49
< import org.eclipse.swt.widgets.Control;
< import org.eclipse.ui.IActionBars;
83d50
< import org.eclipse.ui.IEditorPart;
85,86d51
< import org.eclipse.ui.ISelectionListener;
< import org.eclipse.ui.IWorkbenchPart;
88,91c53
< import org.eclipse.ui.actions.ActionFactory;
< import org.eclipse.ui.part.IPageSite;
< import org.eclipse.ui.part.Page;
< import org.eclipse.ui.part.PageBook;
---
> import org.eclipse.ui.part.EditorPart;
94d55
< import org.eclipse.ui.views.properties.PropertySheetPage;
97c58,59
<  * Common functionality of all diagram editors generated with the lite generator.
---
>  * This class serves as the base class for the generated diagram editors. 
>  * @author bblajer
99,101c61,63
< public abstract class DiagramEditor extends GraphicalEditorWithFlyoutPalette {
< 	protected static final int ID_OVERVIEW = 0;
< 	protected static final int ID_OUTLINE = 1;
---
> public abstract class DiagramEditor extends EditorPart implements IDiagramManager {
> 	private DiagramDisplayer myDiagramDisplayer;
> 	private boolean myIsDirty = false;
103,127c65,67
< 	protected class DiagramContentOutlinePage extends Page implements IContentOutlinePage {
< 		private ContentOutlinePage myOutlinePage;
< 		private Canvas myOverview;
< 		private PageBook myPageBook;
< 		private IAction myShowOutlineAction;
< 		private IAction myShowOverviewAction;
< 		private Thumbnail myThumbnail;
< 		private TreeViewer myTreeViewer;
< 		private DisposeListener myDisposeListener;
< 
< 		@Override
< 		public void init(IPageSite pageSite) {
< 			super.init(pageSite);
< 			ActionRegistry registry = getActionRegistry();
< 			IActionBars bars = pageSite.getActionBars();
< 			String id = ActionFactory.UNDO.getId();
< 			bars.setGlobalActionHandler(id, registry.getAction(id));
< 			id = ActionFactory.REDO.getId();
< 			bars.setGlobalActionHandler(id, registry.getAction(id));
< 			id = ActionFactory.DELETE.getId();
< 			bars.setGlobalActionHandler(id, registry.getAction(id));
< 			bars.updateActionBars();
< 			
< 			// Toolbar refresh to solve linux defect RATLC525198
< 			bars.getToolBarManager().markDirty();
---
> 	private CommandStackListener commandStackListener = new CommandStackListener() {
> 		public void commandStackChanged(EventObject event) {
> 			setDirty(((CommandStack) event.getSource()).isDirty());
128a69
> 	};
130,133c71,72
< 		public void addSelectionChangedListener(ISelectionChangedListener listener) {
< 			if (myOutlinePage != null) {
< 				myOutlinePage.addSelectionChangedListener(listener);
< 			}
---
> 	protected void save(IProgressMonitor monitor) throws CoreException {
> 		myDiagramDisplayer.save(monitor);
136,139c75,76
< 		public void removeSelectionChangedListener(ISelectionChangedListener listener) {
< 			if (myOutlinePage != null) {
< 				myOutlinePage.removeSelectionChangedListener(listener);
< 			}
---
> 	protected final TransactionalEditingDomain getEditingDomain() {
> 		return myDiagramDisplayer.getEditingDomain();
142,146c79,80
< 		public ISelection getSelection() {
< 			if (myOutlinePage != null) {
< 				return myOutlinePage.getSelection();
< 			}
< 			return StructuredSelection.EMPTY;
---
> 	protected final EditDomain getEditDomain() {
> 		return myDiagramDisplayer.getEditDomain();
149,152c83,84
< 		public void setSelection(ISelection selection) {
< 			if (myOutlinePage != null) {
< 				myOutlinePage.setSelection(selection);
< 			}
---
> 	protected final CommandStack getCommandStack() {
> 		return getEditDomain().getCommandStack();
155,168c87,88
< 		@Override
< 		public void createControl(Composite parent) {
< 			myPageBook = new PageBook(parent, SWT.NONE);
< 			myTreeViewer = new TreeViewer();
< 			myTreeViewer.setRootEditPart(new RootTreeEditPart());
< 			myTreeViewer.setEditDomain(getEditDomain());
< 			myTreeViewer.setEditPartFactory(new DiagramTreeEditPartFactory(getGraphicalViewer()));
< 			configureTreeViewer(myTreeViewer);
< 			myOutlinePage = new ContentOutlinePage(myTreeViewer);
< 			myOutlinePage.createControl(myPageBook);
< 			myTreeViewer.setContents(getGraphicalViewer().getContents().getModel());
< 			hookOutlineViewer(myTreeViewer);
< 			configureOutlinePage();
< 			showPage(getDefaultOutlineViewMode());
---
> 	protected final ZoomManager getZoomManager() {
> 		return myDiagramDisplayer.getZoomManager();
171,172c91,92
< 		protected void hookOutlineViewer(TreeViewer viewer) {
< 			getSelectionSynchronizer().addViewer(viewer);
---
> 	protected final ActionRegistry getActionRegistry() {
> 		return myDiagramDisplayer.getActionRegistry();
175,176c95,96
< 		protected void unhookOutlineViewer(TreeViewer viewer) {
< 			getSelectionSynchronizer().removeViewer(viewer);
---
> 	protected final GraphicalViewer getGraphicalViewer() {
> 		return myDiagramDisplayer.getGraphicalViewer();
179,227c99,100
< 		protected void configureOutlinePage() {
< 			IToolBarManager tbm = this.getSite().getActionBars().getToolBarManager();
< 			myShowOutlineAction = new Action() {
< 				public void run() {
< 					showPage(ID_OUTLINE);
< 				}
< 			};
< 			myShowOutlineAction.setImageDescriptor(Activator.getImageDescriptor("icons/outline.gif"));	//$NON-NLS-1$
< 			myShowOutlineAction.setToolTipText("Show Outline");
< 			tbm.add(myShowOutlineAction);
< 			myShowOverviewAction = new Action() {
< 				public void run() {
< 					showPage(ID_OVERVIEW);
< 				}
< 			};
< 			myShowOverviewAction.setImageDescriptor(Activator.getImageDescriptor("icons/overview.gif"));	//$NON-NLS-1$
< 			myShowOverviewAction.setToolTipText("Show Overview");
< 			tbm.add(myShowOverviewAction);
< 		}
< 
< 		protected void configureTreeViewer(TreeViewer treeViewer) {
< 			KeyHandler keyHandler = new KeyHandler();
< 			keyHandler.put(KeyStroke.getPressed(SWT.DEL, 127, 0),
< 					getActionRegistry().getAction(ActionFactory.DELETE.getId()));
< 			keyHandler.put(KeyStroke.getPressed(SWT.F2, 0), getActionRegistry()
< 					.getAction(GEFActionConstants.DIRECT_EDIT));
< 			treeViewer.setKeyHandler(keyHandler);
< 		}
< 
< 		protected void showPage(int pageId) {
< 			switch (pageId) {
< 			case ID_OUTLINE:
< 				myShowOutlineAction.setChecked(true);
< 				myShowOverviewAction.setChecked(false);
< 				myPageBook.showPage(myOutlinePage.getControl());
< 				if (myThumbnail != null) {
< 					myThumbnail.setVisible(false);
< 				}
< 				break;
< 			case ID_OVERVIEW:
< 				myShowOutlineAction.setChecked(false);
< 				myShowOverviewAction.setChecked(true);
< 				if (myOverview == null || myOverview.isDisposed()) {
< 					initializeOverview();
< 				}
< 				myPageBook.showPage(myOverview);
< 				if (myThumbnail != null) {
< 					myThumbnail.setVisible(true);
< 				}
---
> 	protected IPropertySheetPage getPropertySheetPage() {
> 		return myDiagramDisplayer.getPropertySheetPage();
228a102,104
> 
> 	protected IContentOutlinePage getOutlinePage() {
> 		return new DiagramContentOutlinePage(myDiagramDisplayer, getDefaultOutlineViewMode());
231,242c107,108
< 		protected void initializeOverview() {
< 			myOverview = new Canvas(myPageBook, SWT.NONE);
< 			LightweightSystem lws = new LightweightSystem(myOverview);
< 			FreeformGraphicalRootEditPart root = (FreeformGraphicalRootEditPart) getGraphicalViewer().getRootEditPart();
< 			myThumbnail = new ScrollableThumbnail((Viewport) root.getFigure());
< 			myThumbnail.setSource(root.getLayer(LayerConstants.SCALABLE_LAYERS));
< 			lws.setContents(myThumbnail);
< 			myDisposeListener = new DisposeListener() {
< 				public void widgetDisposed(DisposeEvent e) {
< 					if (myThumbnail != null) {
< 						myThumbnail.deactivate();
< 						myThumbnail = null;
---
> 	protected IDiagramLayouter getDiagramLayouter() {
> 		return new DefaultDiagramLayouter();
243a110,117
> 
> 	/**
> 	 * Returns the initial display mode for the outline page to be shown. Possible values are <code>DiagramContentOutlinePage.ID_OUTLINE</code> and 
> 	 * <code>DiagramContentOutlinePage.ID_OVERVIEW</code>.
> 	 * By default, the outline page starts in the overview mode. Subclasses may reimplement.
> 	 */
> 	protected int getDefaultOutlineViewMode() {
> 		return DiagramContentOutlinePage.ID_OVERVIEW;
245,246c119,123
< 			};
< 			getGraphicalControl().addDisposeListener(myDisposeListener);
---
> 
> 	@Override
> 	public boolean isSaveAsAllowed() {
> 		// TODO: should be allowed.
> 		return false;
250,251c127,128
< 		public Control getControl() {
< 			return myPageBook;
---
> 	public void doSaveAs() {
> 		// TODO: Implement.
255,257c132,136
< 		public void setFocus() {
< 			if (myOutlinePage != null) {
< 				myOutlinePage.setFocus();
---
> 	public void init(IEditorSite site, IEditorInput input) throws PartInitException {
> 		setSite(site);
> 		TransactionalEditingDomain editingDomain = getEditingDomain(input);
> 		if (editingDomain == null) {
> 			editingDomain = createEditingDomain();
258a138,140
> 		myDiagramDisplayer = new DiagramDisplayer(this, createEditDomain(), editingDomain);
> 		getCommandStack().addCommandStackListener(commandStackListener);
> 		setInput(input);
263,269c145,148
< 			if (myOutlinePage != null) {
< 				myOutlinePage.dispose();
< 			}
< 			unhookOutlineViewer(myTreeViewer);
< 			if (myThumbnail != null) {
< 				myThumbnail.deactivate();
< 				myThumbnail = null;
---
> 		if (myDiagramDisplayer != null) {
> 			getCommandStack().removeCommandStackListener(commandStackListener);
> 			myDiagramDisplayer.dispose();
> 			myDiagramDisplayer = null;
271,274d149
< 			if (myDisposeListener != null) {
< 				getGraphicalControl().removeDisposeListener(myDisposeListener);
< 			}
< 			myOverview = null;
277,287d151
< 	}
< 
< 	private static class UpdatableActionGroup {
< 		public void addAction(UpdateAction action) {
< 			assert action != null;
< 			myActions.add(action);
< 		}
< 
< 		public void removeAction(UpdateAction action) {
< 			myActions.remove(action);
< 		}
289,292c153,174
< 		public void update() {
< 			for (Iterator it = myActions.iterator(); it.hasNext();) {
< 				UpdateAction next = (UpdateAction) it.next();
< 				next.update();
---
> 	@Override
> 	public Object getAdapter(Class type) {
> 		if (type == IPropertySheetPage.class) {
> 			return getPropertySheetPage();
> 		} else if (type == IContentOutlinePage.class) {
> 			return getOutlinePage();
> 		} else if (type == ZoomManager.class) {
> 			return getZoomManager();
> 		} else if (type == IDiagramLayouter.class) {
> 			return getDiagramLayouter();
> 		} else if (type == PalettePage.class) {
> 			return myDiagramDisplayer.getPalettePage();
> 		} else if (type == GraphicalViewer.class) {
> 			return getGraphicalViewer();
> 		} else if (type == CommandStack.class) {
> 			return getCommandStack();
> 		} else if (type == ActionRegistry.class) {
> 			return getActionRegistry();
> 		} else if (type == EditPart.class && getGraphicalViewer() != null) {
> 			return getGraphicalViewer().getRootEditPart();
> 		} else if (type == IFigure.class && getGraphicalViewer() != null) {
> 			return ((GraphicalEditPart)getGraphicalViewer().getRootEditPart()).getFigure();
293a176
> 		return super.getAdapter(type);
296c179,182
< 		private ArrayList myActions = new ArrayList();
---
> 	private void setDirty(boolean isDirty) {
> 		if (isDirty != myIsDirty) {
> 			myIsDirty = isDirty;
> 			firePropertyChange(PROP_DIRTY);
298,312d183
< 
< 	private TransactionalEditingDomain editingDomain;
< 
< 	private boolean isDirty = false;
< 
< 	private PaletteRoot paletteRoot;
< 
< 	private PropertySheetPage undoablePropertySheetPage;
< 
< 	private UpdatableActionGroup stackActions = new UpdatableActionGroup();
< 
< 	private CommandStackListener commandStackListener = new CommandStackListener() {
< 		public void commandStackChanged(EventObject event) {
< 			stackActions.update();
< 			setDirty(((CommandStack) event.getSource()).isDirty());
314,316d184
< 	};
< 
< 	private UpdatableActionGroup editPartActions = new UpdatableActionGroup();
318,328c186,188
< 	private ISelectionListener selectionListener = new ISelectionListener() {
< 		public void selectionChanged(IWorkbenchPart part, ISelection selection) {
< 			editPartActions.update();
< 		}
< 	};
< 
< 	private UpdatableActionGroup editorActions = new UpdatableActionGroup();
< 
< 	protected void firePropertyChange(int propertyId) {
< 		super.firePropertyChange(propertyId);
< 		editorActions.update();
---
> 	@Override
> 	public boolean isDirty() {
> 		return myIsDirty;
339c199
< 		getActionRegistry().registerAction(action);
---
> 		myDiagramDisplayer.addAction(action);
352,353c212
< 		getActionRegistry().registerAction(action);
< 		editorActions.addAction(action);
---
> 		myDiagramDisplayer.addEditorAction(action);
367,368c226
< 		getActionRegistry().registerAction(action);
< 		editPartActions.addAction(action);
---
> 		myDiagramDisplayer.addEditPartAction(action);
382,383c240
< 		getActionRegistry().registerAction(action);
< 		stackActions.addAction(action);
---
> 		myDiagramDisplayer.addStackAction(action);
386,387c243,284
< 	public void init(IEditorSite site, IEditorInput input) throws PartInitException {
< 		setSite(site);
---
> 	@Override
> 	public void createPartControl(Composite parent) {
> 		myDiagramDisplayer.createViewer(parent);
> 		createActions();
> 	}
> 
> 	@Override
> 	public void setFocus() {
> 		myDiagramDisplayer.setFocus();
> 	}
> 
> 	/**
> 	 * Returns the editing domain instance to be used for the specified input. If this method returns <code>null</code>, 
> 	 * a {@link #createEditDomain() default instance} will be created and used.
> 	 * By default, return <code>null</code>. Subclasses may reimplement.
> 	 */
> 	protected TransactionalEditingDomain getEditingDomain(IEditorInput editorInput) {
> 		return null;
> 	}
> 
> 	/**
> 	 * Returns the editing domain instance to be used for the diagram if none may be {@link #getEditingDomain(IEditorInput) inferred} from the input.
> 	 * Subclasses may extend or reimplement.
> 	 */
> 	protected TransactionalEditingDomain createEditingDomain() {
> 		TransactionalEditingDomain editingDomain = WorkspaceEditingDomainFactory.INSTANCE.createEditingDomain();
> 		editingDomain.getResourceSet().eAdapters().add(new AdapterFactoryEditingDomain.EditingDomainProvider(editingDomain));
> 		editingDomain.getResourceSet().eAdapters().add(new ForceTrackingModificationAdapter());
> 		return editingDomain;
> 	}
> 
> 	public void configureGraphicalViewer() {
> 		getGraphicalViewer().getControl().setBackground(ColorConstants.listBackground);
> 	}
> 
> 	public abstract void configurePalette(PaletteRoot paletteRoot);
> 
> 	/**
> 	 * Creates edit domain that will be used for the editor. 
> 	 * Subclasses may extend.
> 	 */
> 	protected EditDomain createEditDomain() {
424,431c321
< 		setEditDomain(domain);
< 
< 		// add CommandStackListener
< 		getCommandStack().addCommandStackListener(getStackActionsListener());
< 
< 		// add selection change listener
< 		getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(getSelectionListener());
< 		setInput(input);
---
> 		return domain;
434,443c324
< 	public void dispose() {
< 		// remove CommandStackListener
< 		getCommandStack().removeCommandStackListener(getStackActionsListener());
< 
< 		// remove selection listener
< 		getSite().getWorkbenchWindow().getSelectionService().removeSelectionListener(getSelectionListener());
< 
< 		// dispose the ActionRegistry (will dispose all actions)
< 		getActionRegistry().dispose();
< 	}
---
> 	public abstract void initializeGraphicalViewer();
445,464c326
< 	protected void save(IProgressMonitor progressMonitor) throws CoreException {
< 		if (progressMonitor == null) {
< 			progressMonitor = new NullProgressMonitor();
< 		}
< 		progressMonitor.beginTask("Saving", getEditingDomain().getResourceSet().getResources().size());
< 		try {
< 			for(Iterator it = getEditingDomain().getResourceSet().getResources().iterator(); it.hasNext(); ) {
< 				Resource next = (Resource)it.next();
< 				if (next.isLoaded() && (next.isModified() || !next.isTrackingModification())) {
< 					next.save(Collections.EMPTY_MAP);
< 				}
< 				progressMonitor.worked(1);
< 			}
< 		} catch (IOException e) {
< 			IStatus status = new Status(IStatus.ERROR, Activator.getDefault().getBundle().getSymbolicName(), 0, "Error writing file.", e);
< 			throw new CoreException(status);
< 		} finally {
< 			progressMonitor.done();
< 		}
< 	}
---
> 	public abstract AdapterFactory getDomainAdapterFactory();
466,490c328
< 	public boolean isSaveAsAllowed() {
< 		// TODO: should be allowed.
< 		return false;
< 	}
< 
< 	public void doSaveAs() {
< 		// TODO: Implement.
< 	}
< 
< 	public Object getAdapter(Class type) {
< 		if (type == IPropertySheetPage.class) {
< 			return getPropertySheetPage();
< 		} else if (type == IContentOutlinePage.class) {
< 			return getOutlinePage();
< 		} else if (type == ZoomManager.class) {
< 			return getZoomManager();
< 		} else if (type == IDiagramLayouter.class) {
< 			return getDiagramLayouter();
< 		}
< 		return super.getAdapter(type);
< 	}
< 
< 	protected IDiagramLayouter getDiagramLayouter() {
< 		return new DefaultDiagramLayouter();
< 	}
---
> 	public abstract boolean isFlyoutPalette();
492,581c330
< 	protected ZoomManager getZoomManager() {
< 		return getZoomManager(getGraphicalViewer());
< 	}
< 
< 	private ZoomManager getZoomManager(GraphicalViewer viewer) {
< 		// get zoom manager from root edit part
< 		RootEditPart rootEditPart = viewer.getRootEditPart();
< 		ZoomManager zoomManager = null;
< 		if (rootEditPart instanceof ScalableFreeformRootEditPart) {
< 			zoomManager = ((ScalableFreeformRootEditPart) rootEditPart).getZoomManager();
< 		} else if (rootEditPart instanceof ScalableRootEditPart) {
< 			zoomManager = ((ScalableRootEditPart) rootEditPart).getZoomManager();
< 		}
< 		return zoomManager;
< 	}
< 
< 	protected PaletteRoot getPaletteRoot() {
< 		if (paletteRoot == null) {
< 			paletteRoot = new PaletteRoot();
< 			configurePalette(paletteRoot);
< 		}
< 		return paletteRoot;
< 	}
< 
< 	protected abstract void configurePalette(PaletteRoot paletteRoot);
< 
< 	protected CommandStackListener getStackActionsListener() {
< 		return commandStackListener;
< 	}
< 
< 	protected IContentOutlinePage getOutlinePage() {
< 		return new DiagramContentOutlinePage();
< 	}
< 
< 	/**
< 	 * Returns the initial display mode for the outline page to be shown. Possible values are <code>ID_OUTLINE</code> and <code>ID_OVERVIEW</code>.
< 	 * By default, the outline page starts in the overview mode. Subclasses may reimplement.
< 	 */
<     protected int getDefaultOutlineViewMode() {
<         return ID_OVERVIEW;
<     }
< 
< 
< 	protected PropertySheetPage getPropertySheetPage() {
< 		if (undoablePropertySheetPage == null) {
< 			undoablePropertySheetPage = new PropertySheetPage();
< 			UndoablePropertySheetEntry rootEntry = new UndoablePropertySheetEntry(getCommandStack());
< 			rootEntry.setPropertySourceProvider(new PropertySourceProvider(getDomainAdapterFactory()));
< 			undoablePropertySheetPage.setRootEntry(rootEntry);
< 		}
< 
< 		return undoablePropertySheetPage;
< 	}
< 
< 	private ISelectionListener getSelectionListener() {
< 		return selectionListener;
< 	}
< 
< 	public boolean isDirty() {
< 		return isDirty;
< 	}
< 
< 	private void setDirty(boolean dirty) {
< 		if (isDirty != dirty) {
< 			isDirty = dirty;
< 			firePropertyChange(IEditorPart.PROP_DIRTY);
< 		}
< 	}
< 
< 	protected TransactionalEditingDomain getEditingDomain() {
< 		if (editingDomain == null) {
< 			editingDomain = WorkspaceEditingDomainFactory.INSTANCE.createEditingDomain();
< 			//editingDomain.setAdapterFactory(getDomainAdapterFactory());
< 			editingDomain.getResourceSet().eAdapters().add(new AdapterFactoryEditingDomain.EditingDomainProvider(editingDomain));
< 			editingDomain.getResourceSet().eAdapters().add(new ForceTrackingModificationAdapter());
< 		}
< 		return editingDomain;
< 	}
< 
< 	protected abstract AdapterFactory getDomainAdapterFactory();
< 
< 	public void setFocus() {
< 		getGraphicalViewer().getControl().setFocus();
< 	}
< 
< 	public final void createPartControl(Composite parent) {
< 		super.createPartControl(parent);
< 		// initialize actions
< 		createActions();
< 	}
---
> 	protected abstract void createActions();
