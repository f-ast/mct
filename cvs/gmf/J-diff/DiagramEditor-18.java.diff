19a20
> import java.util.Set;
20a22,28
> import org.eclipse.core.commands.operations.IOperationHistory;
> import org.eclipse.core.commands.operations.IOperationHistoryListener;
> import org.eclipse.core.commands.operations.IUndoContext;
> import org.eclipse.core.commands.operations.IUndoableOperation;
> import org.eclipse.core.commands.operations.ObjectUndoContext;
> import org.eclipse.core.commands.operations.OperationHistoryEvent;
> import org.eclipse.core.commands.operations.OperationHistoryFactory;
31a40,46
> import org.eclipse.emf.ecore.resource.Resource;
> import org.eclipse.emf.ecore.resource.ResourceSet;
> import org.eclipse.emf.edit.domain.EditingDomain;
> import org.eclipse.emf.edit.domain.IEditingDomainProvider;
> import org.eclipse.emf.transaction.TransactionalEditingDomain;
> import org.eclipse.emf.transaction.util.TransactionUtil;
> import org.eclipse.emf.workspace.ResourceUndoContext;
32a48
> import org.eclipse.gef.DefaultEditDomain;
41a58
> import org.eclipse.gef.commands.CommandStack;
52d68
< import org.eclipse.gmf.runtime.common.core.command.CommandManager;
83a100
> import org.eclipse.gmf.runtime.emf.commands.core.command.EditingDomainUndoContext;
355a373,382
>     /**
>      * My editing domain provider.
>      */
>     private IEditingDomainProvider domainProvider = new IEditingDomainProvider() {
> 
>         public EditingDomain getEditingDomain() {
>             return DiagramEditor.this.getEditingDomain();
>         }
>     };
> 
371a399,410
>      * My undo context.
>      */
>     private IUndoContext undoContext;
>     
>     /**
>      * My operation history listener. By default it adds my undo context to
>      * operations that have affected my editing domain. Subclasses may override
>      * {@link #createHistoryListener()} to do something different.
>      */
>     private IOperationHistoryListener historyListener;
> 
> 	/**
396a436,510
>         
>         // add my operation history listener, if I have one
>         historyListener = createHistoryListener();
>         if (historyListener != null) {
>             getOperationHistory().addOperationHistoryListener(historyListener);
>         }
> 	}
>     
>     /**
>      * Gets my operation history listener. By default it adds my undo context to
>      * operations that have affected my editing domain.
>      * <P>
>      * Subclasses may override this method to return a different history
>      * listener, or to return <code>null</code> if they do not want to listen
>      * to the operation history.
>      * 
>      * @return my operation history listener
>      */
>     protected IOperationHistoryListener createHistoryListener() {
> 
>         return new IOperationHistoryListener() {
> 
>             public void historyNotification(final OperationHistoryEvent event) {
> 
>                 if (event.getEventType() == OperationHistoryEvent.DONE) {
>                     IUndoableOperation operation = event.getOperation();
>                     
>                     if (shouldAddUndoContext(operation)) {
>                         // add my undo context to populate my undo
>                         // menu
>                         operation.addContext(getUndoContext());
>                     }
>                 }
>             }
>         };
>     }
>         
>     /**
>      * Answers whether or not I should add my undo context to the undoable
>      * <code>operation</code>, thereby making the operation available from my
>      * undo menu.
>      * <P>
>      * The default implementation adds my context to any operation that affected
>      * the same editing domain that has loaded the resource that contains my
>      * diagram element. Subclasses can override this method if they wish to add
>      * their context to operations for different reasons.
>      * 
>      * @param operation
>      *            the operation
>      * @return <code>true</code> if the operation should appear on my undo
>      *         menu, <code>false</code> otherwise.
>      */
>     protected boolean shouldAddUndoContext(IUndoableOperation operation) {
>         EditingDomain domain = getEditingDomain();
> 
>         if (domain != null) {
>             Set affectedResources = ResourceUndoContext
>                 .getAffectedResources(operation);
> 
>             for (Iterator i = affectedResources.iterator(); i.hasNext();) {
>                 Resource nextResource = (Resource) i.next();
> 
>                 ResourceSet resourceSet = nextResource.getResourceSet();
> 
>                 if (resourceSet != null) {
>                     TransactionalEditingDomain editingDomain = TransactionalEditingDomain.Factory.INSTANCE
>                         .getEditingDomain(resourceSet);
> 
>                     if (domain.equals(editingDomain)) {
>                         return true;
>                     }
>                 }
>             }
>         }
>         return false;
438,439d551
< 		if (type == CommandManager.class)
< 			return getCommandManager();
445a558,569
>         
>         if (type == IUndoContext.class) {
>             return getUndoContext();
>         }
>         if (type == IOperationHistory.class) {
>             return getOperationHistory();
>         }
>         if (type == IEditingDomainProvider.class) {
>             return domainProvider;
>         }
>         
>         
490a615,626
>         
>         // Dispose my GEF command stack
>         getEditDomain().getCommandStack().dispose();
> 
>         // stop listening to the history
>         if (historyListener != null) {
>             getOperationHistory().removeOperationHistoryListener(
>                 historyListener);
>         }
>         // dispose my undo context
>         getOperationHistory().dispose(getUndoContext(), true, true, true);
> 
622,623c758,760
< 		setEditDomain(new DiagramEditDomain(this));
< 		configureDiagramEditDomain();
---
>         DiagramEditDomain editDomain = new DiagramEditDomain(this);
>         editDomain.setActionManager(createActionManager());
> 		setEditDomain(editDomain);
627c764
< 	 * Configures a diagram edit domain
---
>      * Configures my diagram edit domain with its command stack.
630,631c767,802
< 		getEditDomain().setCommandStack(
< 			new DiagramCommandStack(getDiagramEditDomain()));
---
> 
>         DefaultEditDomain editDomain = getEditDomain();
> 
>         if (editDomain != null) {
>             CommandStack stack = editDomain.getCommandStack();
> 
>             if (stack != null) {
>                 // dispose the old stack
>                 stack.dispose();
>             }
> 
>             // create and assign the new stack
>             DiagramCommandStack diagramStack = new DiagramCommandStack(getDiagramEditDomain());
>             diagramStack.setOperationHistory(getOperationHistory());
> 
>             // changes made on the stack can be undone from this editor
>             diagramStack.setUndoContext(getUndoContext());
> 
>             editDomain.setCommandStack(diagramStack);
>         }
>     }
>     
>     /**
>      * @overridable
>      */
>     protected ActionManager createActionManager() {
>         return new ActionManager(createOperationHistory());
>     }
>     
>     /**
>      * Create my operation history.
>      * 
>      * @return my operation history
>      */
>     protected IOperationHistory createOperationHistory() {
>         return OperationHistoryFactory.getOperationHistory();
644a816,817
>         // dispose the old command stack and create a new one
>         configureDiagramEditDomain();
730,732c903
< 	 * Convenience method to access the command manager associated with my
< 	 * action manager. This command manager is used by my edit domain's 
< 	 * command stack when executing commands.
---
>      * Returns the operation history from my action manager.
734c905
< 	 * @return the command manager
---
>      * @return the operation history
736,737c907,952
< 	protected CommandManager getCommandManager() {
< 		return getActionManager().getCommandManager();
---
>     protected IOperationHistory getOperationHistory() {
>         return getActionManager().getOperationHistory();
>     }
>     
>     /**
>      * Gets my editing domain derived from my diagram editor input.
>      * <P>
>      * If subclasses have a known editing domain, they should override this method
>      * to return that editing domain as that will be more efficient that the
>      * generic implementation provided here.
>      * 
>      * @return my editing domain
>      */
>     protected EditingDomain getEditingDomain() {
>         return TransactionUtil.getEditingDomain(getDiagram());
>     }
>     
>     /**
>      * Gets my undo context. Lazily initializes my undo context if it has not
>      * been set.
>      * 
>      * @return my undo context
>      */
>     protected IUndoContext getUndoContext() {
> 
>         if (undoContext == null) {
>             TransactionalEditingDomain domain = (TransactionalEditingDomain) getEditingDomain();
> 
>             if (domain != null) {
>                 undoContext = new EditingDomainUndoContext(domain);
> 
>             } else {
>                 undoContext = new ObjectUndoContext(this);
>             }
>         }
>         return undoContext;
>     }
>     
>     /**
>      * Sets my undo context
>      * 
>      * @param context
>      *            the undo context
>      */
>     protected void setUndoContext(IUndoContext context) {
>         this.undoContext = context;
742c957,959
< 	 * @param marker marker to use
---
>      * 
>      * @param marker
>      *            marker to use
976c1193
< 			DiagramRulerProvider vertProvider = new DiagramRulerProvider(
---
> 			DiagramRulerProvider vertProvider = new DiagramRulerProvider((TransactionalEditingDomain) getEditingDomain(),
986c1203
< 			DiagramRulerProvider horzProvider = new DiagramRulerProvider(
---
> 			DiagramRulerProvider horzProvider = new DiagramRulerProvider((TransactionalEditingDomain) getEditingDomain(),
1092a1310
>    
