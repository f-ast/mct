2c2
<  * Copyright (c) 2002, 2007 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2008 IBM Corporation and others.
15d14
< import java.util.Iterator;
17d15
< import org.eclipse.core.runtime.Assert;
19d16
< import org.eclipse.draw2d.SWTGraphics;
21d17
< import org.eclipse.gef.LayerConstants;
24d19
< import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
29,34d23
< import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper;
< import org.eclipse.gmf.runtime.diagram.ui.internal.pagesetup.PageInfoHelper.PageMargins;
< import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;
< import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor;
< import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramGraphicalViewer;
< import org.eclipse.gmf.runtime.diagram.ui.util.DiagramEditorUtil;
36,37d24
< import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.PrinterGraphics;
< import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;
39d25
< import org.eclipse.gmf.runtime.draw2d.ui.mapmode.MapModeUtil;
41,47d26
< import org.eclipse.jface.preference.IPreferenceStore;
< import org.eclipse.jface.resource.JFaceResources;
< import org.eclipse.swt.SWT;
< import org.eclipse.swt.graphics.Font;
< import org.eclipse.swt.graphics.FontData;
< import org.eclipse.swt.graphics.GC;
< import org.eclipse.swt.graphics.Image;
49,52d27
< import org.eclipse.swt.printing.Printer;
< import org.eclipse.swt.widgets.Display;
< import org.eclipse.swt.widgets.Shell;
< import org.eclipse.ui.PlatformUI;
54,86d28
< /*
<  * @canBeSeenBy %level1
<  */
< public class DiagramPrinter
<     implements Runnable {
< 
<     protected Printer printer;
< 
<     private Point display_dpi;
< 
<     private boolean isScaledPercent = false;
< 
<     private int rows = 1;
< 
<     private int columns = 1;
<     
<     private boolean printRangePageSelection = false;
<     
<     private int pageFrom = 1, pageTo = 1;
< 
<     private GC gc;
<     
<     private Graphics swtGraphics;
<     
<     private Graphics graphics;
<     
<     private PrinterGraphics printerGraphics;
<     
<     protected Point printerOffset;
< 
<     protected Rectangle logicalClientArea;
< 
<     private float userScale;
89,90c31,34
<      * Used when a Collection of Diagram objects are passed in instead of an
<      * IEditorPart.
---
>  * Basic page calculation operations have been factored out into this class.
>  * This class was derived from the previous DiagramPrinter.
>  * 
>  * @author James Bruck (jbruck)
92c36
<     protected Collection diagrams;
---
> public abstract class DiagramPrinter implements Runnable {
94,98c38,42
<     /**
<      * The initial amount that the diagram should be translated, set by
<      * printToScale or printToPages which calls drawToFitRowsColumns.
<      */
<     private Point translated = null;
---
> 	protected Point display_dpi;
> 	protected Collection<Diagram> diagrams;
> 	protected PreferencesHint preferencesHint;
> 	protected IMapMode mapMode;
> 	protected Point translated;
100,107c44,47
<     /**
<      * The hint used to find the appropriate preference store from which general
<      * diagramming preference values for properties of shapes, connections, and
<      * diagrams can be retrieved. This hint is mapped to a preference store in
<      * the {@link DiagramPreferencesRegistry}.
<      */
<     private PreferencesHint preferencesHint;
<     private IMapMode mm;
---
> 	protected float userScale;
> 	protected boolean isScaledPercent = false;
> 	protected boolean fitToPage = false;
> 	protected boolean printRangePageSelection = false;
109c49,50
<     private boolean fitToPage = false;
---
> 	protected int pageFrom = 1, pageTo = 1;
> 	protected int rows = 1;
111,117c52,55
<     /**
<      * change the fit to page state
<      * @param fitToPage the new fit to page state
<      */
<     public void setFitToPage(boolean fitToPage){
<         this.fitToPage = fitToPage;
<     }
---
> 	protected int columns = 1;
> 
> 	protected Graphics swtGraphics;
> 	protected Graphics graphics;
119,126d56
<     /**
<      * Creates a new instance. The following variables must be initialized
<      * before calling <code>run()</code>:
<      * <li><code>printer</code></li>
<      * <li><code>display_dpi</code></li>
<      * <li><code>diagrams</code></li>
<      * @param mm <code>IMapMode</code> to do the coordinate mapping
<      */
130,221c60
<         this.mm = mm;
<     }
<     
<     /**
<      * Creates a new instance. The following variables must be initialized
<      * before calling <code>run()</code>:
<      * <li><code>printer</code></li>
<      * <li><code>display_dpi</code></li>
<      * <li><code>diagrams</code></li>
<      * @param mm <code>IMapMode</code> to do the coordinate mapping
<      */
<     public DiagramPrinter(PreferencesHint preferencesHint) {
<         this(preferencesHint, MapModeUtil.getMapMode());
<     }
<     
<     /**
<      * @return <code>IMapMode</code> to do the coordinate mapping
<      */
<     protected IMapMode getMapMode() {
<         return mm;
<     }
<     
<     /**
<      * Sets the columns.
<      * 
<      * @param columns
<      *            The columns to set.
<      */
<     public void setColumns(int columns) {
<         this.columns = columns;
<     }
< 
<     /**
<      * Sets the diagrams.
<      * 
<      * @param diagrams
<      *            a Collection of Diagram objects
<      */
<     public void setDiagrams(Collection diagrams) {
<         this.diagrams = diagrams;
<     }
< 
<     /**
<      * Sets the display DPI.
<      * 
<      * @param display_dpi
<      *            The display_dpi to set.
<      */
<     public void setDisplayDPI(Point display_dpi) {
<         this.display_dpi = new Point(display_dpi.x, display_dpi.y);
<     }
< 
<     /**
<      * Sets the printer.
<      * 
<      * @param printer
<      *            The printer to set.
<      */
<     public void setPrinter(Printer printer) {
<         this.printer = printer;
<     }
<     
<     public void setPrintRangePageSelection(boolean isPrintRangePageSelected) {
<         this.printRangePageSelection = isPrintRangePageSelected;
<     }
<     
<     public void setPrintRangePages(int pageFrom, int pageTo) {
<         assert pageFrom > 0 : "From page in print range page selection must be bigger than zero."; //$NON-NLS-1$
<         assert (pageTo > 0 && pageTo >= pageFrom) : "To page in print range page selection must be bigger than zero and from page.";  //$NON-NLS-1$
<         this.pageFrom = pageFrom;
<         this.pageTo = pageTo;
<     }
< 
<     /**
<      * Sets the rows.
<      * 
<      * @param rows
<      *            The rows to set.
<      */
<     public void setRows(int rows) {
<         this.rows = rows;
<     }
< 
<     /**
<      * Sets the scaled percent.
<      * 
<      * @param scalePercent
<      */
<     public void setScaledPercent(int scalePercent) {
<         this.isScaledPercent = true;
<         this.userScale = (scalePercent) / 100.0f;
< 
---
> 		this.mapMode = mm;
225c64,67
<      * Prints the contents of the diagram editor part.
---
> 	 * Obtains the total number of pages that span columns and rows
> 	 * @param dgrmEP
> 	 * @return Point.x contains the total number of pages that span in a column
> 	 *         Point.y contains the total number of pages that span in a row
227,254c69,72
<     public void run() {
<         assert null != printer : "printer must be set"; //$NON-NLS-1$
<         if (!(printer.startJob("Printing"))) { //$NON-NLS-1$
<           return;
<         }
<         
<         assert diagrams != null;
<         Iterator it = diagrams.iterator();
< 
<         Shell shell = new Shell();
<         try {
<             while (it.hasNext()) {
<                 Object obj = it.next();
<                 //the diagrams List is only supposed to have Diagram objects
<                 Assert.isTrue(obj instanceof Diagram);
<                 Diagram diagram = (Diagram)obj;
<                 DiagramEditor openedDiagramEditor = DiagramEditorUtil
< 						.findOpenedDiagramEditorForID(ViewUtil
< 								.getIdStr(diagram));
< 				DiagramEditPart dgrmEP = openedDiagramEditor == null ? PrintHelper
< 						.createDiagramEditPart(diagram, preferencesHint, shell)
< 						: openedDiagramEditor.getDiagramEditPart();
<                 
<                 boolean loadedPreferences = openedDiagramEditor != null || PrintHelper.initializePreferences(dgrmEP, preferencesHint);
< 
<                 RootEditPart rep = dgrmEP.getRoot();
<                 if (rep instanceof DiagramRootEditPart) 
<                     this.mm = ((DiagramRootEditPart)rep).getMapMode();
---
> 	protected org.eclipse.draw2d.geometry.Point getPageCount(
> 			DiagramEditPart dgrmEP, Rectangle figureBounds,
> 			org.eclipse.draw2d.geometry.Point pageSize, boolean applyUserScale) {
> 		RootEditPart rootEditPart = dgrmEP.getRoot();
256c74
<                 initialize();
---
> 		if (rootEditPart instanceof DiagramRootEditPart) {
257a76,78
> 			DiagramRootEditPart diagramRootEditPart = (DiagramRootEditPart) rootEditPart;
> 			PageBreakEditPart pageBreakEditPart = diagramRootEditPart
> 					.getPageBreakEditPart();
259c80,86
<                 IPreferenceStore pref = null;
---
> 			float fNumCols = ((PageBreaksFigure) pageBreakEditPart.getFigure())
> 					.getPageCount().y
> 					* (applyUserScale ? userScale : 1);
> 
> 			float fNumRows = ((PageBreaksFigure) pageBreakEditPart.getFigure())
> 					.getPageCount().x
> 					* (applyUserScale ? userScale : 1);
261c88,89
<                 assert dgrmEP.getViewer() instanceof DiagramGraphicalViewer;
---
> 			int numCols = (int) Math.ceil(fNumCols);
> 			int numRows = (int) Math.ceil(fNumRows);
263c91
<                 pref = ((DiagramGraphicalViewer)dgrmEP.getViewer()).getWorkspaceViewerPreferenceStore();
---
> 			return new org.eclipse.draw2d.geometry.Point(numCols, numRows);
265c93
<                 if (pref.getBoolean(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS)) {
---
> 		} else {
267,270c95,98
<                     //get workspace settings...
<                     if (dgrmEP.getDiagramPreferencesHint().getPreferenceStore() != null)
<                         pref = (IPreferenceStore)dgrmEP.getDiagramPreferencesHint().getPreferenceStore(); 
<                 }
---
> 			float fNumRows = (figureBounds.height * (applyUserScale ? userScale
> 					: 1))
> 					/ pageSize.y;
> 			int numRows = (int) Math.ceil(fNumRows);
272c100,103
<                 doPrintDiagram(dgrmEP, loadedPreferences, pref);
---
> 			float fNumCols = (figureBounds.width * (applyUserScale ? userScale
> 					: 1))
> 					/ pageSize.x;
> 			int numCols = (int) Math.ceil(fNumCols);
274,278c105
<                 dispose();
<             }
<             printer.endJob();
<         } finally {
<             shell.dispose();
---
> 			return new org.eclipse.draw2d.geometry.Point(numCols, numRows);
295c122
<     private int calculateRowFromPage(int pageNum, int totalNumColumns) {
---
> 	protected int calculateRowFromPage(int pageNum, int totalNumColumns) {
297c124
<         if (pageNum % totalNumColumns != 0)
---
> 		if (pageNum % totalNumColumns != 0) {
298a126
> 		}
316,338c144,145
<     private int calculateColumnFromPage(int pageNum, int totalNumColumns, int cRow) {
<         int col = pageNum - ((cRow - 1) * totalNumColumns);
<         return col;
<     }
<     
<     /**
<      * Obtains the total number of pages that span columns and rows
<      * @param dgrmEP
<      * @return Point.x contains the total number of pages that span in a column
<      *         Point.y contains the total number of pages that span in a row
<      */
<     private org.eclipse.draw2d.geometry.Point getPageCount(DiagramEditPart dgrmEP, Rectangle figureBounds, org.eclipse.draw2d.geometry.Point pageSize, boolean applyUserScale) {
<         RootEditPart rootEditPart = dgrmEP.getRoot();
<         if (rootEditPart instanceof DiagramRootEditPart) {
<             //this is the most accurate way to obtain total rows and columns...
<             
<             DiagramRootEditPart diagramRootEditPart = (DiagramRootEditPart) rootEditPart;
<             PageBreakEditPart pageBreakEditPart = diagramRootEditPart
<                 .getPageBreakEditPart();
<             float fNumCols = ((PageBreaksFigure)pageBreakEditPart.getFigure()).getPageCount().y * 
<                 (applyUserScale ? userScale : 1);
<             float fNumRows = ((PageBreaksFigure)pageBreakEditPart.getFigure()).getPageCount().x * 
<                 (applyUserScale ? userScale : 1);
---
> 	protected int calculateColumnFromPage(int pageNum, int totalNumColumns,
> 			int cRow) {
340,343c147
<             int numCols = (int) Math.ceil(fNumCols);
<             int numRows = (int) Math.ceil(fNumRows);
<             
<             return new org.eclipse.draw2d.geometry.Point(numCols,numRows);
---
> 		return (pageNum - ((cRow - 1) * totalNumColumns));
345,350d148
<         else {
<             //otherwise, calculate manually...
<             
<             float fNumRows = (figureBounds.height * (applyUserScale ? userScale : 1))
<                 / pageSize.y;
<             int numRows = (int) Math.ceil(fNumRows);
352,358d149
<             float fNumCols = (figureBounds.width * (applyUserScale ? userScale : 1))
<                 / pageSize.x;
<             int numCols = (int) Math.ceil(fNumCols);
<             
<             return new org.eclipse.draw2d.geometry.Point(numCols, numRows);
<         }
<     }
361c152
<      * Prints to scale or prints to rows x columns pages
---
> 	 * Disposes of the resources.
363,368c154,161
<     private void doPrintDiagram(DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {
<         this.graphics.pushState();
<         if (isScaledPercent) {
<             printToScale(dgrmEP, loadedPreferences, fPreferences);
<         } else {
<             printToPages(dgrmEP, loadedPreferences, fPreferences);
---
> 	protected void dispose() {
> 		if (this.graphics != null) {
> 			try {
> 				this.graphics.dispose();
> 			} catch (NullPointerException e) {
> 				//do nothing
> 			} finally {
> 				this.graphics = null;
370d162
<         this.graphics.popState();
373,393c165,171
<     private void initialize() {
< 
<         assert null != printer : "printer must be set"; //$NON-NLS-1$
<         
<         //check for rtl orientation...
<         int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();
<         if ((style & SWT.MIRRORED) != 0)
<             this.gc = new GC(printer, SWT.RIGHT_TO_LEFT);
<         else
<             this.gc = new GC(printer);
< 
<         gc.setXORMode(false);
< 
<         this.swtGraphics = new SWTGraphics(gc);
<         this.printerGraphics = createPrinterGraphics(swtGraphics);
<         this.graphics = createMapModeGraphics(printerGraphics);
<         this.graphics.scale(computePrinterDisplayScale());
<         
<         this.logicalClientArea = this.graphics.getClip(new Rectangle(
<             this.printer.getClientArea()));
<         
---
> 		if (this.swtGraphics != null) {
> 			try {
> 				this.swtGraphics.dispose();
> 			} catch (NullPointerException e) {
> 				//do nothing
> 			} finally {
> 				this.swtGraphics = null;
395,420d172
<     
<     /**
<      * Usually, the printable area is less than the page.
<      * This method returns the offset for each x margin and each y margin.
<      * x margins are left and right
<      * y margins are top and bottom
<      * 
<      * We'll assume the left and right offsets are the same and the
<      * top and bottom offsets are the same.
<      * 
<      * @return Point with x and y offsets
<      */
<     protected Point getPrinterOffset() {
<         if (printerOffset == null) {
<             int offsetX = this.printer.getBounds().width
<             - this.printer.getClientArea().width;
<             int offsetY = this.printer.getBounds().height
<             - this.printer.getClientArea().height;
<         
<             // assume half on each side
<             offsetX = (int) (getMapMode()
<                 .DPtoLP((int) (offsetX / 2.0f * display_dpi.x / printer.getDPI().x)) / userScale);
<             offsetY = (int) (getMapMode()
<                 .DPtoLP((int) (offsetY / 2.0f * display_dpi.y / printer.getDPI().y)) / userScale);
<             
<             printerOffset = new Point(offsetX, offsetY);
422,423d173
<         
<         return printerOffset;
427c177
<      * Print the diagram figure using specified scale factor.
---
>      * Creates the <code>MapModeGraphics</code>.
429,434c179,181
<      * @param dgrmEP the DiagramEditPart that will be printed
<      * @param loadedPreferences true if existing prefs could be loaded
<      * successfully, false if not and defaults are being used.  This parameter
<      * is important to obtain the correct page break bounds.
<      * @param fPreferences the preferenceStore that could either contain
<      * existing preferences or defaults
---
>      * @param theGraphics
>      *            the <code>PrinterGraphics</code> object
>      * @return the new <code>MapModeGraphics</code>
436,470c183,184
<     protected void printToScale(DiagramEditPart dgrmEP, boolean loadedPreferences, IPreferenceStore fPreferences) {
< 
<         assert null != printer : "printer must be set"; //$NON-NLS-1$
<         Rectangle figureBounds = PrintHelper.getPageBreakBounds(dgrmEP, loadedPreferences);
<         org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper.getPageSize(fPreferences, getMapMode());
< 
<         //translate to offset initial figure position
<         translated = new Point((int) (-figureBounds.x * userScale), (int) (-figureBounds.y * userScale));
<         
<         //calculate the number of page rows and columns
<         int numRows = 0, numCols = 0;
<         
<         PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
<         adjustMargins(margins, userScale, getPrinterOffset());
< 
<         GC gc_ = new GC(Display.getDefault(),this.gc.getStyle());
<         gc_.setAntialias(this.gc.getAntialias());
< 
<         FontData fontData = JFaceResources.getDefaultFont().getFontData()[0];
<         Font font = new Font(printer, fontData);
<         
<         org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageBounds, true);
<         numCols = pageCount.x;
<         numRows = pageCount.y;
< 
<         //finalRow and finalColumn will be used if we are printing within a page range...
<         int row = 1, col = 1, finalRow = 0, finalColumn = 0;
<         
<         if (this.printRangePageSelection) {
<             //print only the pages specified in the page range...
<             row = calculateRowFromPage(this.pageFrom, numCols);
<             col = calculateColumnFromPage(this.pageFrom, numCols, row);
<             
<             finalRow = calculateRowFromPage(this.pageTo, numCols);
<             finalColumn = calculateColumnFromPage(this.pageTo, numCols, finalRow);
---
>     protected MapModeGraphics createMapModeGraphics(Graphics theGraphics) {
>         return new MapModeGraphics(theGraphics, getMapMode());
473,482c187,191
<         try {
<             //print the pages in row, column order
<             for (; row <= numRows; row++) {
<                 for (; col <= numCols; col++) {
<                     printer.startPage();
<                     drawPage(gc_, dgrmEP, fPreferences, figureBounds, margins, font, row, col);
<                     printer.endPage();
<                     
<                     if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
<                         break;
---
> 	public void setPrintRangePages(int pageFrom, int pageTo) {
> 		assert pageFrom > 0 : "From page in print range page selection must be bigger than zero."; //$NON-NLS-1$
> 		assert (pageTo > 0 && pageTo >= pageFrom) : "To page in print range page selection must be bigger than zero and from page."; //$NON-NLS-1$
> 		this.pageFrom = pageFrom;
> 		this.pageTo = pageTo;
485,493c194,195
<                 if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
<                     break;
<                 
<                 col = 1;
<             }
<         } finally {
<             //must dispose resources
<             font.dispose();
<             gc_.dispose();
---
> 	public Point getDisplayDPI() {
> 		return display_dpi;
495,540d196
<     }
< 
<     /**
<      * Draw the header and footer
<      * 
<      * @param gc_,
<      *            a graphics context that is not null which this method will use
<      *            for figuring ouyt the font's extent
<      * @param figureBounds,
<      *            Rectangle with the bounds of the figure
<      * @param rowIndex,
<      *            int
<      * @param colIndex,
<      *            int
<      */
<     protected void drawHeaderAndFooter(GC gc_, DiagramEditPart dgrmEP, Rectangle figureBounds,
<             Font font, int rowIndex, int colIndex) {
< 
<         int width = this.logicalClientArea.width;
<         int height = this.logicalClientArea.height;
< 
<         this.graphics.pushState(); //draw text, don't make it too small or big
<         this.graphics.setFont(font);
< 
<         this.graphics.scale(1.0f / userScale);
<         this.graphics.translate(-translated.x, -translated.y);
< 
<         String headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString(
<             WorkspaceViewerProperties.HEADER_PREFIX, rowIndex, colIndex,
<             dgrmEP);
< 
<         this.graphics.drawText(headerOrFooter,
<             getMapMode().DPtoLP(HeaderAndFooterHelper.LEFT_MARGIN_DP)
<                 + (width - getMapMode().DPtoLP(gc_.textExtent(headerOrFooter).x))
<                 / 2, getMapMode().DPtoLP(HeaderAndFooterHelper.TOP_MARGIN_DP));
< 
<         headerOrFooter = HeaderAndFooterHelper.makeHeaderOrFooterString(
<             WorkspaceViewerProperties.FOOTER_PREFIX, rowIndex, colIndex,
<             dgrmEP);
< 
<         this.graphics.drawText(headerOrFooter,
<             getMapMode().DPtoLP(HeaderAndFooterHelper.LEFT_MARGIN_DP)
<                 + (width - getMapMode().DPtoLP(gc_.textExtent(headerOrFooter).x))
<                 / 2, height - getMapMode().DPtoLP(HeaderAndFooterHelper.BOTTOM_MARGIN_DP));
< 
<         this.graphics.popState(); //for drawing the text
541a198,199
> 	public void setDisplayDPI(Point display_dpi) {
> 		this.display_dpi = display_dpi;
544,606c202,203
<     /**
<      * This method paints a portion of the diagram. (The area painted
<      * representing one page.)
<      * 
<      * @param gc_ a graphics context that is not null which this method will use
<      * for figuring out the font's extent
<      * @param dgrmEP the DiagramEditPart that will be printed
<      * @param fPreferences the preferenceStore that could either contain
<      * existing preferences or defaults
<      * @param figureBounds the page break bounds we'll have to offset by
<      * @param font the Font to print the header or footer with
<      * @param rowIndex index of row we're printing
<      * @param colIndex index of column we're priniting
<      * to check if it is the first time the method is getting called for the current
<      * print.
<      */
<     protected void drawPage(GC gc_, DiagramEditPart dgrmEP,
<             IPreferenceStore fPreferences, Rectangle figureBounds,
<             PageMargins margins, Font font, int rowIndex, int colIndex) {
< 
<         org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
<             .getPageSize(fPreferences, false, getMapMode());
<         boolean rtlEnabled = ((this.gc.getStyle() & SWT.MIRRORED) != 0);
<         if (rtlEnabled) 
<         {
<             // draw everything on an offscreen image first and then draw that image
<             // onto the printer gc...this takes care of certain drawing bugs.
<             // This causes issues with printing resolution as it uses a display image
<             // which is typically 72dpi
<             // This code should be removed when a resolution to Bugzilla 162459 is found
< 
<             Image image = new Image(Display.getDefault(), getMapMode().LPtoDP(pageSize.x), getMapMode().LPtoDP(pageSize.y));
< 
<             GC imgGC = new GC(image, (rtlEnabled) ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT);
<             imgGC.setXORMode(false);
<       
<             SWTGraphics sg = new SWTGraphics(imgGC);
<               
<             //for scaling
<             ScaledGraphics g1 = new ScaledGraphics(sg);
<           
<             //for himetrics and svg
<             MapModeGraphics mmg = createMapModeGraphics(g1);
<               
<             //if mmg's font is null, gc.setFont will use a default font
<             imgGC.setFont(mmg.getFont());
<               
<             internalDrawPage(dgrmEP,figureBounds,fPreferences,margins,mmg,rowIndex, colIndex,true);
<             
<             this.graphics.pushState();
<         
<             this.graphics.drawImage(image, 0, 0);
<               
<             this.graphics.popState();
< 
<             //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
<             drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
<             disposeImageVars(imgGC, image, sg, g1, mmg);
<         } else {
<             internalDrawPage(dgrmEP,figureBounds,fPreferences,margins,this.graphics,rowIndex, colIndex,false);
<             //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
<             drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
<         }
---
> 	public PreferencesHint getPreferencesHint() {
> 		return preferencesHint;
609,638c206,207
<     private void internalDrawPage(DiagramEditPart dgrmEP,
<             Rectangle figureBounds, IPreferenceStore fPreferences,
<             PageMargins margins, Graphics g, int rowIndex, int colIndex,
<             boolean RTL_ENABLED) {
<         org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper
<             .getPageSize(fPreferences, false, getMapMode());
< 
<         int width = pageSize.x, height = pageSize.y;
< 
<         g.pushState();
< 
<         g.translate(translated.x, translated.y);
<         g.scale(userScale);
< 
<         int translateX = -(width * (colIndex - 1));
<         int translateY = -(height * (rowIndex - 1));
< 
<         int scaledTranslateX = (int) (translateX / userScale);
<         int scaledTranslateY = (int) (translateY / userScale);
< 
<         int scaledWidth = (int) (width / userScale);
<         int scaledHeight = (int) (height / userScale);
< 
<         if (RTL_ENABLED) {
<             scaledTranslateX += (margins.left * (colIndex - 1))
<                 + (margins.right * (colIndex));
<             scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
<         } else {
<             scaledTranslateX += ((margins.left * colIndex) + (margins.right * (colIndex - 1)));
<             scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
---
> 	public void setPreferencesHint(PreferencesHint preferencesHint) {
> 		this.preferencesHint = preferencesHint;
641,652c210,211
<         g.translate(scaledTranslateX, scaledTranslateY);
< 
<         Rectangle clip = new Rectangle(
<             (scaledWidth - margins.left - margins.right) * (colIndex - 1)
<                 + figureBounds.x, (scaledHeight - margins.bottom - margins.top)
<                 * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right
<                 - margins.left, scaledHeight - margins.top - margins.bottom);
<         g.clipRect(clip);
< 
<         dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(g);
< 
<         g.popState();
---
> 	public IMapMode getMapMode() {
> 		return mapMode;
655,689c214,215
<     /**
<      * Print the diagram figure to fit the number and rows and columns
<      * specified by the user.
<      * 
<      * @param dgrmEP the DiagramEditPart that will be printed
<      * @param loadedPreferences true if existing prefs could be loaded
<      * successfully, false if not and defaults are being used.  This parameter
<      * is important to obtain the correct page break bounds.
<      * @param fPreferences the preferenceStore that could either contain
<      * existing preferences or defaults
<      */
<     protected void printToPages(DiagramEditPart dgrmEP,
<             boolean loadedPreferences, IPreferenceStore fPreferences) {
<         assert null != printer : "printer must be set"; //$NON-NLS-1$
< 
<         Rectangle figureBounds = PrintHelper.getPageBreakBounds(dgrmEP,
<             loadedPreferences);
<         
<         PageMargins margins = PageInfoHelper.getPageMargins(fPreferences, getMapMode());
<         //do not include margins
<         org.eclipse.draw2d.geometry.Point pageBounds = PageInfoHelper
<             .getPageSize(fPreferences, getMapMode());
<         org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageBounds, false);
<         int numCols = pageCount.x;
<         int numRows = pageCount.y;
<         
<         float actualWidth = 0;
<         float actualHeight = 0;
<         if (this.rows==1 && this.columns==1 && fitToPage){
<         	figureBounds = dgrmEP.getChildrenBounds();
<             actualWidth = figureBounds.width;
<             actualHeight = figureBounds.height;
<         }else {
<             actualWidth = numCols * pageBounds.x;
<             actualHeight = numRows * pageBounds.y;
---
> 	public void setMapMode(IMapMode mm) {
> 		this.mapMode = mm;
692,720c218,219
<         int totalHeight = (this.rows * pageBounds.y);
<         int totalWidth  = (this.columns * pageBounds.x);
< 
<         float vScale =  totalHeight / actualHeight;
<         float hScale = totalWidth / actualWidth;
< 
<         this.userScale = Math.min(hScale, vScale);
< 
<         // translate to offset figure position
<         translated = new Point((int) (-figureBounds.x * userScale),
<             (int) (-figureBounds.y * userScale));
< 
<         adjustMargins(margins, userScale, getPrinterOffset());
< 
<         GC gc_ = new GC(Display.getDefault());
< 
<         FontData fontData = JFaceResources.getDefaultFont().getFontData()[0];
<         Font font = new Font(printer, fontData);
< 
<         int row = 1, col = 1, finalRow = 0, finalColumn = 0;
<         
<         if (this.printRangePageSelection) {
<             //print only the pages specified in the page range
<             //this corresponds to the physical pages, not the print range of pages on one physical page.
<             row = calculateRowFromPage(this.pageFrom, this.columns);
<             col = calculateColumnFromPage(this.pageFrom, this.columns, row);
<             
<             finalRow = calculateRowFromPage(this.pageTo, this.columns);
<             finalColumn = calculateColumnFromPage(this.pageTo, this.columns, finalRow);
---
> 	public Point getTranslated() {
> 		return translated;
723,733c222,223
<         try {
<             // print the pages in row, column order
<             for (; row <= rows; row++) {
<                 for (; col <= columns; col++) {
<                     printer.startPage();
<                     drawPage(gc_, dgrmEP, fPreferences, figureBounds, margins,
<                         font, row, col);
<                     printer.endPage();
<                     
<                     if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
<                         break;
---
> 	public void setTranslated(Point translated) {
> 		this.translated = translated;
736,745c226,227
<                 if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
<                     break;
<                 
<                 col = 1;
<             }
<         } finally {
<             // must dispose resources
<             font.dispose();
<             gc_.dispose();
<         }
---
> 	public float getUserScale() {
> 		return userScale;
748,760c230,232
<     /**
<      * Return scale factor between printer and display.
<      * 
<      * @return float
<      */
<     private float computePrinterDisplayScale() {
<         assert null != printer : "printer must be set"; //$NON-NLS-1$
<         assert null != display_dpi : "display_dpi must be set"; //$NON-NLS-1$
< 
<         Point dpi = printer.getDPI();
<         float scale = dpi.x / (float) display_dpi.x;
<         
<         return scale;
---
> 	public void setScaledPercent(int scalePercent) {
> 		this.isScaledPercent = true;
> 		this.userScale = (scalePercent) / 100.0f;
763,776c235,236
<     /**
<      * Disposes of the resources.
<      */
<     private void dispose() {
<         if (this.graphics != null) {
<             try {
<                 this.graphics.dispose();
<             }
<             catch (NullPointerException e) {
<                 //do nothing
<             }
<             finally {
<                 this.graphics = null;                
<             }
---
> 	public void setScaledPercent(boolean isScaledPercent) {
> 		this.isScaledPercent = isScaledPercent;
779,788c239,240
<         if (this.printerGraphics != null) {
<             try {
<                 this.printerGraphics.dispose();
<             }
<             catch (NullPointerException e) {
<                 //do nothing
<             }
<             finally {
<                 this.printerGraphics = null;
<             }
---
> 	public boolean isFitToPage() {
> 		return fitToPage;
791,800c243,244
<         if (this.swtGraphics != null) {
<             try {
<                 this.swtGraphics.dispose();
<             }
<             catch (NullPointerException e) {
<                 //do nothing
<             }
<             finally {
<                 this.swtGraphics = null;
<             }
---
> 	public void setFitToPage(boolean fitToPage) {
> 		this.fitToPage = fitToPage;
803,812c247,248
<         if (this.gc != null) {
<             try {
<                 this.gc.dispose();
<             }
<             catch (NullPointerException e) {
<                 //do nothing
<             }
<             finally {
<                 this.gc = null;
<             }
---
> 	public boolean isPrintRangePageSelection() {
> 		return printRangePageSelection;
815,818c251,252
<         //reset the printer offset, just in case the next diagram to be printed 
<         //uses a different map mode.
<         printerOffset = null;
<         
---
> 	public void setPrintRangePageSelection(boolean printRangePageSelection) {
> 		this.printRangePageSelection = printRangePageSelection;
821,833c255,256
<     private void disposeImageVars(GC imgGC, Image image, SWTGraphics sg, 
<             ScaledGraphics g1, MapModeGraphics mmg) {
<         
<         if (mmg != null) {
<             try {
<                 mmg.dispose();
<             }
<             catch (NullPointerException e) {
<                 //do nothing
<             }
<             finally {
<                 mmg = null;                
<             }
---
> 	public int getPageFrom() {
> 		return pageFrom;
836,845c259,260
<         if (g1 != null) {
<             try {
<                 g1.dispose();
<             }
<             catch (NullPointerException e) {
<                 //do nothing
<             }
<             finally {
<                 g1 = null;                
<             }
---
> 	public void setPageFrom(int pageFrom) {
> 		this.pageFrom = pageFrom;
848,857c263,264
<         if (sg != null) {
<             try {
<                 sg.dispose();
<             }
<             catch (NullPointerException e) {
<                 //do nothing
<             }
<             finally {
<                 sg = null;                
<             }
---
> 	public int getPageTo() {
> 		return pageTo;
860,868c267,268
<         if (imgGC != null) {
<             try {
<                 imgGC.dispose();
<             }
<             catch (NullPointerException e) {
<                 //do nothing
<             }
<             finally {
<                 imgGC = null;                
---
> 	public void setPageTo(int pageTo) {
> 		this.pageTo = pageTo;
869a270,272
> 
> 	public int getRows() {
> 		return rows;
872,874c275,276
<         if (image != null) {
<             try {
<                 image.dispose();
---
> 	public void setRows(int rows) {
> 		this.rows = rows;
876,877c278,280
<             catch (NullPointerException e) {
<                 //do nothing
---
> 
> 	public int getColumns() {
> 		return columns;
879,880c282,284
<             finally {
<                 image = null;                
---
> 
> 	public void setColumns(int columns) {
> 		this.columns = columns;
881a286,288
> 
> 	public Graphics getSwtGraphics() {
> 		return swtGraphics;
882a290,292
> 
> 	public void setSwtGraphics(Graphics swtGraphics) {
> 		this.swtGraphics = swtGraphics;
885,893c295,296
<     /**
<      * Creates the <code>MapModeGraphics</code>.
<      * 
<      * @param theGraphics
<      *            the <code>PrinterGraphics</code> object
<      * @return the new <code>MapModeGraphics</code>
<      */
<     protected MapModeGraphics createMapModeGraphics(Graphics theGraphics) {
<         return new MapModeGraphics(theGraphics, getMapMode());
---
> 	public Graphics getGraphics() {
> 		return graphics;
896,904c299,300
<     /**
<      * Creates the <code>PrinterGraphics</code>.
<      * 
<      * @param theGraphics
<      *          the <code>Graphics</code> object
<      * @return the new <code>PrinterGraphics</code>
<      */
<     protected PrinterGraphics createPrinterGraphics(Graphics theGraphics) {
<         return new PrinterGraphics(theGraphics, printer, true);
---
> 	public void setGraphics(Graphics graphics) {
> 		this.graphics = graphics;
907,916c303,304
<     /**
<      * Gets the preferences hint that is to be used to find the appropriate
<      * preference store from which to retrieve diagram preference values. The
<      * preference hint is mapped to a preference store in the preference
<      * registry <@link DiagramPreferencesRegistry>.
<      * 
<      * @return the preferences hint
<      */
<     protected PreferencesHint getPreferencesHint() {
<         return preferencesHint;
---
> 	public void setDiagrams(Collection<Diagram> diagrams) {
> 		this.diagrams = diagrams;
919,947c307,308
<     /**
<      * Adjust the given PageMargins by the scale and offset
<      * 
<      * @param margins PageMargins to adjust
<      * @param scale margins will be scaled by this amount
<      * @param offset to adjust margins by
<      */
<     protected void adjustMargins(PageMargins margins, float scale, Point offset) {
<         //scale
<         margins.left /= scale;
<         margins.top /= scale;
<         margins.right /= scale;
<         margins.bottom /= scale;
<         
<         //offsets
<         margins.left -= offset.x; 
<         margins.right += offset.x;
<         margins.top -= offset.y;
<         margins.bottom += offset.y;
<         
<         // this is more readable than doing Math.min for all the above
<         if (margins.left < 0)
<             margins.left = 0;
<         if (margins.right < 0)
<             margins.right = 0;
<         if (margins.top < 0)
<             margins.top = 0;
<         if (margins.bottom < 0)
<             margins.bottom = 0;
---
> 	public Collection<Diagram> getDiagrams() {
> 		return diagrams;
948a310
> 
