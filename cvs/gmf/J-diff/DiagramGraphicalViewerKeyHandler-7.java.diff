14a15
> import java.util.Collections;
92a94
> 				break;
194d195
< 		figure.translateToAbsolute(bounds);
207c208,227
< 		List editParts =
---
> 	    if (epStart instanceof DiagramEditPart) {
> 	        Point location = viewport.getViewLocation().getCopy();
> 	        switch (direction) {
> 	            case PositionConstants.NORTH :
> 	                location.translate(0, -pageDistance);
> 	                break;              
> 	            case PositionConstants.SOUTH :
> 	                location.translate(0, pageDistance);
> 	                break;
> 	            case PositionConstants.EAST :
> 	                location.translate(pageDistance, 0);
> 	                break;
> 	            case PositionConstants.WEST :
>                     location.translate(-pageDistance, 0);
> 	                break;
> 	        }
> 	        viewport.setViewLocation(location);
>         }
> 
> 		List<GraphicalEditPart> editParts =
217c237
< 			Iterator parts = editParts.iterator();
---
> 			Iterator<GraphicalEditPart> parts = editParts.iterator();
219c239
< 				navigateToPart((EditPart) parts.next(), event);
---
> 				navigateToPart(parts.next(), event);
221c241
< 			EditPart part = (EditPart) editParts.get(editParts.size() - 1);
---
> 			EditPart part = editParts.get(editParts.size() - 1);
234a255,274
> 		
> 		// go to top-left or bottom-right corner if nothing is selected
> 		if (epStart instanceof DiagramEditPart) {
>             Viewport viewport = findViewport(epStart);
>             switch (direction) {
>                 case PositionConstants.NORTH:
>                 case PositionConstants.WEST:
>                     viewport.setViewLocation(viewport.getHorizontalRangeModel()
>                         .getMinimum(), viewport.getVerticalRangeModel()
>                         .getMinimum());
>                     break;
>                 case PositionConstants.SOUTH:
>                 case PositionConstants.EAST:
>                     viewport.setViewLocation(viewport.getHorizontalRangeModel()
>                         .getMaximum(), viewport.getVerticalRangeModel()
>                         .getMaximum());
>                     break;
>             }
>         }
> 		
238c278
< 		List editParts =
---
> 		List<GraphicalEditPart> editParts =
247c287
< 			Iterator parts = editParts.iterator();
---
> 			Iterator<GraphicalEditPart> parts = editParts.iterator();
249c289
< 				navigateToPart((EditPart) parts.next(), event);
---
> 				navigateToPart(parts.next(), event);
251c291
< 			EditPart part = (EditPart) editParts.get(editParts.size() - 1);
---
> 			EditPart part = editParts.get(editParts.size() - 1);
265c305
< 	private List findPageSibling(
---
> 	private List<GraphicalEditPart> findPageSibling(
270a311
> 	    
273c314,315
< 		List selection = new ArrayList();
---
> 		GraphicalEditPart epFurthest = null;  // in case there is not a full pageDistance left to scroll
> 		List<GraphicalEditPart> selection = new ArrayList<GraphicalEditPart>();
276c318,319
< 		int distance = 0;
---
> 		int distance = Integer.MAX_VALUE;
> 		int furthestDistance = 0;
288c331
< 			if (pStart.getPosition(pCurrent) != direction)
---
> 			if (!isInDirection(direction, pStart, pCurrent))
292c335
< 			if (d <= pageDistance) {
---
> 			if (d >= pageDistance) {
294c337
< 				if (d > distance) {
---
> 				if (d < distance) {
298a342,344
> 			if (d > furthestDistance) {
> 			    epFurthest = epCurrent;
> 			}
303a350,352
> 		if (selection.isEmpty() && epFurthest != null) {
> 		    return Collections.singletonList(epFurthest);
> 		}
314c363
< 	private List findEndSibling(
---
> 	private List<GraphicalEditPart> findEndSibling(
321c370
< 		List selection = new ArrayList();
---
> 		List<GraphicalEditPart> selection = new ArrayList<GraphicalEditPart>();
336c385
< 			if (pStart.getPosition(pCurrent) != direction)
---
> 			if (!isInDirection(direction, pStart, pCurrent))
468a518,544
>     /**
>      * Returns true if the point in question is in the given direction from the
>      * starting point.
>      * 
>      * @param direction
>      *            the direction
>      * @param start
>      *            the starting point
>      * @param point
>      *            the point in question
>      * @return true if the point in question is in the given direction from the
>      *         starting point; false otherwise
>      */
>     private boolean isInDirection(int direction, Point start, Point point) {
>         switch (direction) {
>             case PositionConstants.WEST:
>                 return start.x > point.x;
>             case PositionConstants.EAST:
>                 return start.x < point.x;
>             case PositionConstants.NORTH:
>                 return start.y > point.y;
>             case PositionConstants.SOUTH:
>                 return start.y < point.y;
>         }
>         return false;
>     }
>     
