2c2
<  * Copyright (c) 2002, 2004 IBM Corporation and others.
---
>  * Copyright (c) 2006 IBM Corporation and others.
16d15
< import java.util.Collections;
18a18
> import java.util.ListIterator;
19a20,25
> import org.eclipse.core.commands.ExecutionException;
> import org.eclipse.core.commands.operations.ICompositeOperation;
> import org.eclipse.core.commands.operations.IUndoContext;
> import org.eclipse.core.commands.operations.IUndoableOperation;
> import org.eclipse.core.resources.IFile;
> import org.eclipse.core.runtime.IAdaptable;
26c32
< 
---
> import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;
29a36,37
> import org.eclipse.gmf.runtime.common.core.util.Log;
> import org.eclipse.gmf.runtime.common.core.util.Trace;
32,34c40,49
<  * A command that is composed of other
<  * {@link org.eclipse.gmf.runtime.common.core.command.ICommand}s which can be
<  * undone and redone in a single step.
---
>  * An undoable command that is composed of child {@link IUndoableOperation}s
>  * that are not known to modify EMF model resources, but can contain
>  * model-affecting children. Execute, undo, redo and dispose result in execute,
>  * undo, redo and dispose on each child operation. The operation provides a list
>  * of {@link IFile}s that may be modified when the operation is executed,
>  * undone or redone.
>  * <P>
>  * The children are explicitly composed by a client before the composite is
>  * executed. Children cannot be added or removed after the composite has been
>  * executed.
36,38c51,52
<  * A <code>CompositeCommand</code> can only be executed, undone or redone if
<  * all of the {@link org.eclipse.gmf.runtime.common.core.command.ICommand}s
<  * with which it is composed are executable, undoable or redoable, respectively.
---
>  * The undo contexts of the composite are a union of the undo contexts of its
>  * children.
40,42c54,56
<  * When a <code>CompositeCommand</code> is executed, its commands are not
<  * executed independently of one another. This means that if one command
<  * execution fails, the remaining commands will not be executed.
---
>  * If a child command returns a cancel or an error status during execution, undo
>  * or redo, the remaining child commands are not processed and those that have
>  * already been executed are rolled back.
44,45c58
<  * @author khussey
<  * @canBeSeenBy %partners
---
>  * @author ldamus
48c61,62
< 	implements ICommand {
---
>     extends AbstractCommand
>     implements ICompositeCommand {
50,53c64,66
< 	/**
< 	 * The empty string.
< 	 */
< 	protected static final String EMPTY_STRING = ""; //$NON-NLS-1$
---
>     private final List children;
> 
>     private boolean executed;
56c69,72
< 	 * The commands of which this composite command is composed.
---
>      * Initializes me with a label.
>      * 
>      * @param label
>      *            a user-readable label
58c74,76
< 	private final List commands = new ArrayList();
---
>     public CompositeCommand(String label) {
>         this(label, null);
>     }
61c79,84
< 	 * The label for this composite command.
---
>      * Initializes me with a label and a list of child operations.
>      * 
>      * @param label
>      *            a user-readable label
>      * @param children
>      *            a list of child {@link IUndoableOperation}s
63c86,94
< 	private final String label;
---
>     public CompositeCommand(String label, List children) {
>         super(label, null);
> 
>         if (children != null) {
>             this.children = new ArrayList(children);
>         } else {
>             this.children = new ArrayList();
>         }
>     }
66,67c97,100
< 	 * Flag to indicate whether or not this command was canceled in its last
< 	 * execution.
---
>      * Answers whether or not this composite operation has children.
>      * 
>      * @return <code>true</code> if the operation does not have children,
>      *         <code>false</code> otherwise.
69c102,104
< 	private boolean canceled = false;
---
>     public final boolean isEmpty() {
>         return size() < 1;
>     }
72c107,112
< 	 * Creates a new composite command with the specified label.
---
>      * Obtains my nested operations. Note that the return result is mutable and
>      * is identical to my child-operation storage, so subclasses should be
>      * careful of adding or removing contents. This should ordinarily be done
>      * only via the {@link #add(IUndoableOperation)} and
>      * {@link #remove(IUndoableOperation)} methods because these maintain the
>      * undo contexts (or, equivalently, using the iterators).
74,75c114,119
< 	 * @param label
< 	 *            The label for the new composite command.
---
>      * @return my list of children
>      * 
>      * @see #add(IUndoableOperation)
>      * @see #remove(IUndoableOperation)
>      * @see #iterator()
>      * @see #listIterator(int)
77,78c121,123
< 	public CompositeCommand(String label) {
< 		super();
---
>     protected List getChildren() {
>         return children;
>     }
80c125,127
< 		this.label = label;
---
>     // Documentation copied from interface
>     public int size() {
>         return getChildren().size();
84,85c131,132
< 	 * Creates a new composite command with the specified label and list of
< 	 * commands.
---
>      * Adds a child operation to me. This should only be done before I am
>      * executed. Has no effect if I already contain this operation as a child.
87,90c134,138
< 	 * @param label
< 	 *            The label for the new composite command.
< 	 * @param commands
< 	 *            The initial list of commands
---
>      * @param operation
>      *            a new child operation
>      * 
>      * @throws IllegalStateException
>      *             if I have already been successfully executed
92,93c140
< 	public CompositeCommand(String label, List commands) {
< 		super();
---
>     public void add(IUndoableOperation operation) {
95c142
< 		this.label = label;
---
>         assertNotExecuted();
97,101c144,146
< 		assert null != commands : "null commands"; //$NON-NLS-1$
< 
< 		for (Iterator i = commands.iterator(); i.hasNext();) {
< 			ICommand command = (ICommand) i.next();
< 			compose(command);
---
>         if (!getChildren().contains(operation)) {
>             getChildren().add(operation);
>             didAdd(operation);
106c151
< 	 * Retrieves the commands with which this command has been composed.
---
>      * Updates my undo contexts for the addition of a new child operation.
108c153,154
< 	 * @return The commands with which this command has been composed.
---
>      * @param operation
>      *            a new child operation
110,112c156,157
< 	public final List getCommands() {
< 		return commands;
< 	}
---
>     private void didAdd(IUndoableOperation operation) {
>         IUndoContext[] childContexts = operation.getContexts();
114,123c159,164
< 	/* (non-Javadoc)
< 	 * @see org.eclipse.gmf.runtime.common.core.command.ICommand#getLabel()
< 	 */
< 	public final String getLabel() {
< 		if (label == null)
< 			if (getCommands().isEmpty())
< 				return null;
< 		if (label != null)
< 			return label;
< 		return ((ICommand) getCommands().get(0)).getLabel();
---
>         for (int i = 0; i < childContexts.length; i++) {
> 
>             if (!hasContext(childContexts[i])) {
>                 addContext(childContexts[i]);
>             }
>         }
127,128c168,178
< 	 * Retrieves the composite result of executing, undoing, or redoing this
< 	 * composite command.
---
>      * Removes a child operation from me. This should only be done before I am
>      * executed. Has no effect if I do not contain this operation as a child.
>      * <p>
>      * <b>Note</b> that I do not dispose an operation when it is removed from
>      * me. Although this is specified in the contract of the
>      * {@link ICompositeOperation} interface, this would not be correct, as I
>      * did not create that operation.
>      * </p>
>      * 
>      * @param operation
>      *            a child operation to remove
130,132c180,181
< 	 * @return A command result composed of the results of
< 	 *         executing, undoing or redoing the commands of which this composite
< 	 *         command is composed.
---
>      * @throws IllegalStateException
>      *             if I have already been successfully executed
134c183
< 	public CommandResult getCommandResult() {
---
>     public void remove(IUndoableOperation operation) {
136,137c185,189
< 		if (isCanceled()) {
< 			return newCancelledCommandResult();
---
>         assertNotExecuted();
> 
>         if (getChildren().remove(operation)) {
>             didRemove(operation);
>         }
140,141c192,199
< 		List statuses = new ArrayList();
< 		List returnValues = new ArrayList();
---
>     /**
>      * Updates my undo contexts for the removal of a child operation.
>      * 
>      * @param operation
>      *            the child operation that was removed
>      */
>     private void didRemove(IUndoableOperation operation) {
>         IUndoContext[] childContexts = operation.getContexts();
143c201
< 		int severity = IStatus.OK;
---
>         for (int i = 0; i < childContexts.length; i++) {
145,148c203,207
< 		String plugin = CommonCorePlugin.getPluginId();
< 		int code = CommonCoreStatusCodes.OK;
< 		String message = EMPTY_STRING;
< 		Throwable exception = null;
---
>             if (!anyChildHasContext(childContexts[i])) {
>                 removeContext(childContexts[i]);
>             }
>         }
>     }
150,151c209,219
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
< 			ICommand command = (ICommand) i.next();
---
>     /**
>      * Queries whether any of my children has the specified context.
>      * 
>      * @param ctx
>      *            a context
>      * 
>      * @return <code>false</code> if none of my children has the specified
>      *         context; <code>true</code>, otherwise
>      */
>     private boolean anyChildHasContext(IUndoContext ctx) {
>         boolean result = false;
153c221,223
< 			CommandResult result = command.getCommandResult();
---
>         for (Iterator iter = iterator(); !result && iter.hasNext();) {
>             result = ((IUndoableOperation) iter.next()).hasContext(ctx);
>         }
155,158c225
< 			if (result == null) {
< 				// the result can be null if only some of the commands have been
< 				// executed (e.g., the action was abandoned)
< 				break;
---
>         return result;
161,162c228,232
< 			IStatus status = result.getStatus();
< 			statuses.add(result.getStatus());
---
>     /**
>      * I can execute if all of my children can execute.
>      */
>     public boolean canExecute() {
>         boolean result = super.canExecute();
164,169c234,235
< 			if (severity < status.getSeverity()) {
< 				severity = status.getSeverity();
< 				plugin = status.getPlugin();
< 				code = status.getCode();
< 				message = status.getMessage();
< 				exception = status.getException();
---
>         for (Iterator iter = iterator(); result && iter.hasNext();) {
>             result = ((IUndoableOperation) iter.next()).canExecute();
172,182c238
< 			Object returnValue = result.getReturnValue();
< 			if (returnValue != null) {
< 				if (getClass().isInstance(command)) {
< 					if (returnValue != null && returnValue instanceof Collection) {
< 						returnValues.addAll((Collection) returnValue);
< 					} else {
< 						returnValues.add(returnValue);
< 					}
< 				} else {
< 					returnValues.add(returnValue);
< 				}
---
>         return result;
183a240,248
> 
>     /**
>      * I can redo if all my children can all be redone.
>      */
>     public boolean canRedo() {
>         boolean result = super.canRedo();
> 
>         for (Iterator iter = iterator(); result && iter.hasNext();) {
>             result = ((IUndoableOperation) iter.next()).canRedo();
186,188c251
< 		return new CommandResult(
< 			new MultiStatus(plugin, code, (IStatus[]) statuses
< 				.toArray(new IStatus[] {}), message, exception), returnValues);
---
>         return result;
192,196c255
< 	 * Retrieves the collection of objects that would be affected if this
< 	 * composite command were executed, undone, or redone.
< 	 * 
< 	 * @return A collection containing the affected objects of all of the
< 	 *         commands of which this composite command is composed.
---
>      * I can undo if all my children can all be undone.
198,201c257,258
< 	public final Collection getAffectedObjects() {
< 		List affectedObjects = new ArrayList();
< 
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
---
>     public boolean canUndo() {
>         boolean result = super.canUndo();
203,206c260,261
< 			Collection coll = ((ICommand) i.next()).getAffectedObjects();
< 			if (coll != null) {
< 				affectedObjects.addAll(coll);
< 			}
---
>         for (Iterator iter = iterator(); result && iter.hasNext();) {
>             result = ((IUndoableOperation) iter.next()).canUndo();
209c264
< 		return affectedObjects;
---
>         return result;
212,213c267,268
< 	/* (non-Javadoc)
< 	 * @see org.eclipse.gmf.runtime.common.core.command.ICommand#involvesReadOnlyNonWorkSpaceFiles()
---
>     /**
>      * Disposes of each of my children.
215,218c270,274
< 	public boolean involvesReadOnlyNonWorkSpaceFiles() {
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
< 			if (((ICommand) i.next()).involvesReadOnlyNonWorkSpaceFiles())
< 				return true;
---
>     public void dispose() {
> 
>         for (Iterator iter = iterator(); iter.hasNext();) {
>             IUndoableOperation nextOperation = (IUndoableOperation) iter.next();
>             nextOperation.dispose();
220d275
< 		return false;
227c282
< 	 * @param command
---
>      * @param operation
231,233c286,290
< 	public final ICommand compose(ICommand command) {
< 		if (command != null)
< 			getCommands().add(command);
---
>     public final ICommand compose(IUndoableOperation operation) {
> 
>         if (operation != null) {
>             add(operation);
>         }
238,239c295,299
< 	 * Answers whether this composite command can
< 	 * be executed.
---
>      * Returns the simplest form of this command that is equivalent. This is
>      * useful for removing unnecessary nesting of commands.
>      * <P>
>      * If the composite has a single command, it returns the reduction of that
>      * single command. Otherwise, it returns itself.
241,243c301
< 	 * @return <code>false</code> if any of the commands of which this
< 	 *         composite command is composed cannot be executed;
< 	 *         <code>true</code> otherwise.
---
>      * @return the simplest form of this command that is equivalent
245,248c303,307
< 	public final boolean isExecutable() {
< 		if (getCommands().isEmpty())
< 			return false;
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
---
>     public ICommand reduce() {
>         switch (size()) {
>             case 1:
>                 IUndoableOperation child = (IUndoableOperation) iterator()
>                     .next();
250,251c309,310
< 			if (!((ICommand) i.next()).isExecutable()) {
< 				return false;
---
>                 if (child instanceof ICommand) {
>                     return ((ICommand) child).reduce();
254,255c313
< 
< 		return true;
---
>         return this;
259,264c317,318
< 	 * Answers whether this composite command can
< 	 * be redone.
< 	 * 
< 	 * @return <code>false</code> if any of the commands of which this
< 	 *         composite command is composed cannot be redone; <code>true</code>
< 	 *         otherwise.
---
>      * Returns a list containing all of the return values from
>      * <code>ICommand</code> children.
266,269c320,341
< 	public final boolean isRedoable() {
< 		if (getCommands().isEmpty())
< 			return false;
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
---
>     protected List getReturnValues() {
> 
>         List returnValues = new ArrayList();
> 
>         for (Iterator i = iterator(); i.hasNext();) {
>             IUndoableOperation operation = (IUndoableOperation) i.next();
> 
>             if (operation instanceof ICommand) {
>                 ICommand command = (ICommand) operation;
> 
>                 CommandResult result = command.getCommandResult();
> 
>                 if (result != null) {
>                     Object returnValue = result.getReturnValue();
> 
>                     if (returnValue != null) {
> 
>                         if (getClass().isInstance(command)) {
>                             // unwrap the values from other composites
>                             if (returnValue != null
>                                 && returnValue instanceof Collection) {
>                                 returnValues.addAll((Collection) returnValue);
271,272c343,351
< 			if (!((ICommand) i.next()).isRedoable()) {
< 				return false;
---
>                             } else {
>                                 returnValues.add(returnValue);
>                             }
> 
>                         } else {
>                             returnValues.add(returnValue);
>                         }
>                     }
>                 }
276c355
< 		return true;
---
>         return returnValues;
280,285c359
< 	 * Answers whether this composite command can
< 	 * be undone.
< 	 * 
< 	 * @return <code>false</code> if any of the commands of which this
< 	 *         composite command is composed cannot be undone; <code>true</code>
< 	 *         otherwise.
---
>      * Implements the execution logic by sequential execution of my children.
287,290c361,363
< 	public final boolean isUndoable() {
< 		if (getCommands().isEmpty())
< 			return false;
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
---
>     protected CommandResult doExecuteWithResult(
>             IProgressMonitor progressMonitor, IAdaptable info)
>         throws ExecutionException {
292,293c365,368
< 			if (!((ICommand) i.next()).isUndoable()) {
< 				return false;
---
>         List result = new ArrayList(size());
> 
>         if (progressMonitor == null) {
>             progressMonitor = new NullProgressMonitor();
294a370,413
> 
>         progressMonitor.beginTask(getLabel(), size());
> 
>         try {
> 
>             for (ListIterator iter = listIterator(); iter.hasNext();) {
>                 IUndoableOperation next = (IUndoableOperation) iter.next();
> 
>                 try {
>                     IStatus status = next.execute(new SubProgressMonitor(
>                         progressMonitor, 1), info);
>                     result.add(status);
>                     int severity = status.getSeverity();
> 
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
> 
>                         // Undo the operation to date, excluding the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(
>                                 CommonCorePlugin.getDefault(),
>                                 "Composite operation execution recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
>                         // back-track over the operation that failed
>                         iter.previous();
>                         unwindFailedExecute(iter, info);
>                         break;
> 
>                     } else if (progressMonitor.isCanceled()) {
>                         // Undo the operation to date, including the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation redo recovery: child command monitor is cancelled."); //$NON-NLS-1$
> 
>                         CommandResult cancelResult = CommandResult
>                             .newCancelledCommandResult();
>                         result.add(cancelResult.getStatus());
> 
>                         unwindFailedExecute(iter, info);
>                         break;
> 
>                     } else {
>                         progressMonitor.worked(1);
>                         executed = true;
297c416,425
< 		return true;
---
>                 } catch (ExecutionException e) {
>                     // Undo the operation to date, and re-throw the exception
>                     // back-track over the operation that failed
>                     iter.previous();
>                     unwindFailedExecute(iter, info);
>                     Trace.throwing(CommonCorePlugin.getDefault(),
>                         CommonCoreDebugOptions.EXCEPTIONS_THROWING,
>                         CompositeCommand.class, "execute", e); //$NON-NLS-1$
>                     throw e;
>                 }
300,306c428,432
< 	/**
< 	 * Returns whether the composite command has no child commands.
< 	 * 
< 	 * @return whether the composite command has no child commands.
< 	 */
< 	public final boolean isEmpty() {
< 		return getCommands().size() == 0;
---
>         } finally {
>             progressMonitor.done();
>         }
> 
>         return new CommandResult(aggregateStatuses(result), getReturnValues());
310,318c436
< 	 * Returns the simplest form of this command that is equivalent. This is
< 	 * useful for removing unnecessary nesting of commands.
< 	 * <UL>
< 	 * <LI>if the composite had no sub-commands, it returns <code>null</code>
< 	 * </LI>
< 	 * <LI>if the composite had a single command, it returns the single command
< 	 * </LI>
< 	 * <LI>otherwise, it returns itself</LI>
< 	 * </UL>
---
>      * Undoes the previous operations in the iterator.
320c438,441
< 	 * @return the simplest form of this command that is equivalent
---
>      * @param iter
>      *            the execution iterator
>      * @param info
>      *            the execution info
322,329c443,468
< 	public ICommand unwrap() {
< 		switch (commands.size()) {
< 			case 0:
< 				return UnexecutableCommand.INSTANCE;
< 			case 1:
< 				return (ICommand) commands.get(0);
< 			default:
< 				return this;
---
>     private void unwindFailedExecute(ListIterator iter, IAdaptable info) {
> 
>         while (iter.hasPrevious()) {
>             // unwind the child operations
>             IUndoableOperation prev = (IUndoableOperation) iter.previous();
>             if (!prev.canUndo()) {
>                 // Can't unwind
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.EXECUTE_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.executeRecoveryFailed,
>                         CommonCoreMessages.cannotUndoExecuted));
>                 break;
>             }
> 
>             try {
>                 prev.undo(new NullProgressMonitor(), info);
> 
>             } catch (ExecutionException inner) {
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.EXECUTE_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.executeRecoveryFailed, inner
>                             .getLocalizedMessage()));
>                 break;
>             }
334,351c473
< 	 * Executes this composite command by executing all of the commands with
< 	 * which it is composed. If one command execution fails, the remaining
< 	 * commands will not be executed.
< 	 * <P>
< 	 * The result of executing this command can be obtained by calling
< 	 * {@link #getCommandResult()}after the command has been executed.
< 	 * <P>
< 	 * The progress of this command execution is measured in the following way:
< 	 * each of <code>n</code> subcommands is allocated 1 of <code>n</code>
< 	 * work units from <code>progressMonitor</code>. Each sub-command
< 	 * execution is given a {@link SubProgressMonitor}and can futher divide its
< 	 * 1/<code>n</code> th into <code>m</code> work units. Command
< 	 * execution will stop when the progress monitor is cancelled and a
< 	 * {@link CommonCoreStatusCodes#CANCELLED}status code will be returned in
< 	 * the command result. All of the previously executed sub-commands will be
< 	 * undone as a result of cancelling.
< 	 * 
< 	 * @param progressMonitor @see org.eclipse.core.runtime.IProgressMonitor
---
>      * I redo by asking my children to redo, in forward order.
353c475,477
< 	public void execute(IProgressMonitor progressMonitor) {
---
>     protected CommandResult doRedoWithResult(IProgressMonitor progressMonitor,
>             IAdaptable info)
>         throws ExecutionException {
355,356c479
< 		if (!getValidator().okToEdit(this)) {
< 			setCanceled(true);
---
>         final List result = new ArrayList(size());
358c481,483
< 		} else {
---
>         if (progressMonitor == null) {
>             progressMonitor = new NullProgressMonitor();
>         }
360,361c485
< 			IProgressMonitor monitor = (progressMonitor == null) ? new NullProgressMonitor()
< 				: progressMonitor;
---
>         progressMonitor.beginTask(getLabel(), size());
363,364c487
< 			setCanceled(false);
< 			List executedCommands = new ArrayList(getCommands().size());
---
>         try {
366,367c489,490
< 			int totalWork = getCommands().size();
< 			monitor.beginTask(getLabel(), totalWork);
---
>             for (ListIterator iter = listIterator(); iter.hasNext();) {
>                 IUndoableOperation next = (IUndoableOperation) iter.next();
369c492
< 			for (Iterator i = getCommands().iterator(); i.hasNext();) {
---
>                 try {
371,372c494,497
< 				SubProgressMonitor subprogressMonitor = new SubProgressMonitor(
< 					monitor, 1, SubProgressMonitor.SUPPRESS_SUBTASK_LABEL);
---
>                     IStatus status = next.redo(new SubProgressMonitor(
>                         progressMonitor, 1), info);
>                     result.add(status);
>                     int severity = status.getSeverity();
374,375c499,508
< 				ICommand nextCommand = (ICommand) i.next();
< 				nextCommand.execute(subprogressMonitor);
---
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
>                         // Undo the operation to date, excluding the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation redo recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
>                         // back-track over the operation that failed
>                         iter.previous();
>                         unwindFailedRedo(iter, info);
>                         break;
377,383c510,554
< 				CommandResult result = nextCommand.getCommandResult();
< 				if (result != null) {
< 					if (result.getStatus().getSeverity() == IStatus.ERROR) {
< 						/*
< 						 * myee - RATLC00518953: error executing one of the
< 						 * composed commands: cancel all of the executed
< 						 * commands
---
>                     } else if (progressMonitor.isCanceled()) {
>                         // Undo the operation to date, including the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation redo recovery: child command monitor is cancelled."); //$NON-NLS-1$
> 
>                         CommandResult cancelResult = CommandResult
>                             .newCancelledCommandResult();
>                         result.add(cancelResult.getStatus());
> 
>                         unwindFailedRedo(iter, info);
>                         break;
> 
>                     } else {
>                         progressMonitor.worked(1);
>                         executed = true;
>                     }
> 
>                 } catch (ExecutionException e) {
>                     // Undo the operation to date, and re-throw the exception
>                     // back-track over the operation that failed
>                     iter.previous();
>                     unwindFailedRedo(iter, info);
>                     Trace.throwing(CommonCorePlugin.getDefault(),
>                         CommonCoreDebugOptions.EXCEPTIONS_THROWING,
>                         CompositeCommand.class, "redo", e); //$NON-NLS-1$
>                     throw e;
>                 }
>             }
> 
>         } finally {
>             progressMonitor.done();
>         }
> 
>         return new CommandResult(aggregateStatuses(result), getReturnValues());
>     }
> 
>     /**
>      * Undoes the previous operations in the iterator.
>      * 
>      * @param iter
>      *            the execution iterator
>      * @param info
>      *            the execution info
385,386c556,580
< 						undoCancelledCommands(executedCommands);
< 						return;
---
>     private void unwindFailedRedo(ListIterator iter, IAdaptable info) {
> 
>         while (iter.hasPrevious()) {
>             // unwind the child operations
>             IUndoableOperation prev = (IUndoableOperation) iter.previous();
>             if (!prev.canUndo()) {
>                 // Can't unwind
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.REDO_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.redoRecoveryFailed,
>                         CommonCoreMessages.cannotUndo));
>                 break;
>             }
> 
>             try {
>                 prev.undo(new NullProgressMonitor(), info);
> 
>             } catch (ExecutionException inner) {
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.REDO_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.redoRecoveryFailed, inner
>                             .getLocalizedMessage()));
>                 break;
389c583,590
< 				monitor.worked(1);
---
>     }
> 
>     /**
>      * I undo by asking my children to undo, in reverse order.
>      */
>     protected CommandResult doUndoWithResult(IProgressMonitor progressMonitor,
>             IAdaptable info)
>         throws ExecutionException {
391,395c592,595
< 				if (monitor.isCanceled()) {
< 					undoCancelledCommands(executedCommands);
< 					monitor.done();
< 					setCanceled(true);
< 					return;
---
>         final List result = new ArrayList(size());
> 
>         if (progressMonitor == null) {
>             progressMonitor = new NullProgressMonitor();
397c597,639
< 				executedCommands.add(nextCommand);
---
> 
>         progressMonitor.beginTask(getLabel(), size());
> 
>         try {
> 
>             for (ListIterator iter = listIterator(size()); iter.hasPrevious();) {
>                 IUndoableOperation prev = (IUndoableOperation) iter.previous();
> 
>                 try {
>                     IStatus status = prev.undo(new SubProgressMonitor(
>                         progressMonitor, 1), info);
>                     result.add(status);
>                     int severity = status.getSeverity();
> 
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
>                         // Redo the operation to date, excluding the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation undo recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
>                         // back-track over the operation that failed or was
>                         // cancelled
>                         iter.next();
>                         unwindFailedUndo(iter, info);
>                         break;
> 
>                     } else if (progressMonitor.isCanceled()) {
>                         // Redo the operation to date, including the current
>                         // child, and don't proceed
>                         Trace
>                             .trace(CommonCorePlugin.getDefault(),
>                                 "Composite operation undo recovery: child command monitor is cancelled."); //$NON-NLS-1$
> 
>                         CommandResult cancelResult = CommandResult
>                             .newCancelledCommandResult();
>                         result.add(cancelResult.getStatus());
> 
>                         unwindFailedUndo(iter, info);
>                         break;
> 
>                     } else {
>                         progressMonitor.worked(1);
>                         executed = true;
400c642,652
< 			monitor.done();
---
>                 } catch (ExecutionException e) {
>                     // Redo the operation to date, and re-throw the exception
>                     // back-track over the operation that failed
>                     iter.next();
>                     unwindFailedUndo(iter, info);
>                     Trace.throwing(CommonCorePlugin.getDefault(),
>                         CommonCoreDebugOptions.EXCEPTIONS_THROWING,
>                         CompositeCommand.class, "undo", e); //$NON-NLS-1$
>                     throw e;
>                 }
>             }
401a654,655
>         } finally {
>             progressMonitor.done();
402a657,658
> 
>         return new CommandResult(aggregateStatuses(result), getReturnValues());
406,408c662
< 	 * Cancels the command execution by calling <code>undo()</code> on all of
< 	 * the undoable commands that were executed before the composite command was
< 	 * cancelled. The commands are undone in the reverse order of execution.
---
>      * Redoes the next operations in the iterator.
410,414c664,667
< 	 * @param executedCommands
< 	 *            the commands that have been executed and need to be undone.
< 	 *            This method expects that the commands in the list are in the
< 	 *            order in which the commands were executed. They will be undone
< 	 *            in the reverse order.
---
>      * @param iter
>      *            the execution iterator
>      * @param info
>      *            the execution info
416c669
< 	protected void undoCancelledCommands(List executedCommands) {
---
>     private void unwindFailedUndo(ListIterator iter, IAdaptable info) {
418c671,682
< 		Collections.reverse(executedCommands);
---
>         while (iter.hasNext()) {
>             // unwind the child operations
>             IUndoableOperation next = (IUndoableOperation) iter.next();
>             if (!next.canRedo()) {
>                 // Can't unwind
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.UNDO_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.undoRecoveryFailed,
>                         CommonCoreMessages.cannotRedo));
>                 break;
>             }
420,423c684,693
< 		for (Iterator i = executedCommands.iterator(); i.hasNext();) {
< 			ICommand nextCommand = (ICommand) i.next();
< 			if (nextCommand.isUndoable()) {
< 				nextCommand.undo();
---
>             try {
>                 next.redo(new NullProgressMonitor(), info);
> 
>             } catch (ExecutionException inner) {
>                 Log.error(CommonCorePlugin.getDefault(),
>                     CommonCoreStatusCodes.UNDO_RECOVERY_FAILED,
>                     CommonCoreMessages.bind(
>                         CommonCoreMessages.undoRecoveryFailed, inner
>                             .getLocalizedMessage()));
>                 break;
429,441c699,727
< 	 * Redoes this composite command by redoing each of the commands of which
< 	 * this composite command is composed.
< 	 */
< 	public void redo() {
< 		// First check if we have the needed units available.
< 		// We are forced to do this at the composite command level
< 		// because some individual commands do not properly set their
< 		// affectedObject. For example, create a class and notice that
< 		// the SetBounds command will not have its affected object set
< 		// even though it clearly modifies a unit.
< 		if (!getValidator().okToEdit(this)) {
< 			setCanceled(true);
< 			return;
---
>      * Creates a suitable aggregate from these statuses. If there are no
>      * statuses to aggregate, then an OK status is returned. If there is a
>      * single status to aggregate, then it is returned. Otherwise, a
>      * multi-status is returned with the provided statuses as children.
>      * 
>      * @param statuses
>      *            the statuses to aggregate. May have zero, one, or more
>      *            elements (all must be {@link IStatus}es)
>      * 
>      * @return the multi-status
>      */
>     protected IStatus aggregateStatuses(List statuses) {
>         final IStatus result;
> 
>         if (statuses.isEmpty()) {
>             result = Status.OK_STATUS;
>         } else if (statuses.size() == 1) {
>             result = ((IStatus) statuses.get(0));
>         } else {
>             // find the most severe status, to use its plug-in, code, and
>             // message
>             IStatus[] statusArray = (IStatus[]) statuses
>                 .toArray(new IStatus[statuses.size()]);
> 
>             IStatus worst = statusArray[0];
>             for (int i = 1; i < statusArray.length; i++) {
>                 if (statusArray[i].getSeverity() > worst.getSeverity()) {
>                     worst = statusArray[i];
>                 }
444c730,732
< 		Collections.reverse(getCommands());
---
>             result = new MultiStatus(worst.getPlugin(), worst.getCode(),
>                 statusArray, worst.getMessage(), null);
>         }
446,447c734
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
< 			((ICommand) i.next()).redo();
---
>         return result;
448a736,744
> 
>     /**
>      * Answers whether or not I have been executed.
>      * 
>      * @return <code>true</code> if I have been executed, <code>false</code>
>      *         otherwise.
>      */
>     protected final boolean isExecuted() {
>         return executed;
452,453c748,749
< 	 * Undoes this composite command by undoing each of the commands of which
< 	 * this composite command is composed.
---
>      * Asserts that I have not yet been executed. Changes to my children are not
>      * permitted after I have been executed.
455,464c751,759
< 	public void undo() {
< 		// First check if we have the needed units available.
< 		// We are forced to do this at the composite command level
< 		// because some individual commands do not properly set their
< 		// affectedObject. For example, create a class and notice that
< 		// the SetBounds command will not have its affected object set
< 		// even though it clearly modifies a unit.
< 		if (!getValidator().okToEdit(this)) {
< 			setCanceled(true);
< 			return;
---
>     protected final void assertNotExecuted() {
>         if (isExecuted()) {
>             IllegalStateException exc = new IllegalStateException(
>                 "Operation already executed"); //$NON-NLS-1$
>             Trace.throwing(CommonCorePlugin.getDefault(),
>                 CommonCoreDebugOptions.EXCEPTIONS_THROWING,
>                 CompositeCommand.class, "assertNotExecuted", exc); //$NON-NLS-1$
>             throw exc;
>         }
467c762,771
< 		Collections.reverse(getCommands());
---
>     /**
>      * Returns a list containing all of the affected files from
>      * <code>ICommand</code> children.
>      */
>     public List getAffectedFiles() {
> 
>         List result = new ArrayList();
> 
>         for (Iterator i = iterator(); i.hasNext();) {
>             IUndoableOperation nextOperation = (IUndoableOperation) i.next();
469,470c773,779
< 		for (Iterator i = getCommands().iterator(); i.hasNext();) {
< 			((ICommand) i.next()).undo();
---
>             if (nextOperation instanceof ICommand) {
>                 List nextAffected = ((ICommand) nextOperation)
>                     .getAffectedFiles();
> 
>                 if (nextAffected != null) {
>                     result.addAll(nextAffected);
>                 }
472a782,783
>         return result;
>     }
475,476c786,787
< 	 * Retrieves the plug-in identifier to be used in command results produced
< 	 * by this command.
---
>      * Obtains an iterator to traverse my child operations. Removing children
>      * via this iterator correctly maintains my undo contexts.
478,479c789
< 	 * @return The plug-in identifier to be used in command results produced by
< 	 *         this command.
---
>      * @return an iterator of my children
481,482c791,792
< 	protected String getPluginId() {
< 		return CommonCorePlugin.getPluginId();
---
>     public Iterator iterator() {
>         return new ChildIterator();
486,487c796,805
< 	 * Creates a new command result with an ERROR status, a CANCELLED status
< 	 * code and no return value.
---
>      * Obtains an iterator to traverse my child operations in either direction.
>      * Adding and removing children via this iterator correctly maintains my
>      * undo contexts.
>      * <p>
>      * <b>Note</b> that, unlike list iterators generally, this implementation
>      * does not permit the addition of an operation that I already contain (the
>      * composite does not permit duplicates). Moreover, only
>      * {@link IUndoableOperation}s may be added, otherwise
>      * <code>ClassCastException</code>s will result.
>      * </p>
489,490c807
< 	 * @return A new command result with an ERROR status and a CANCELLED status
< 	 *         code.
---
>      * @return an iterator of my children
492,494c809,810
< 	protected CommandResult newCancelledCommandResult() {
< 		return new CommandResult(new Status(IStatus.ERROR, getPluginId(),
< 			CommonCoreStatusCodes.CANCELLED, CommonCoreMessages.AbstractCommand__INFO__cancelOperation, null), null);
---
>     public ListIterator listIterator() {
>         return new ChildListIterator(0);
498c814,823
< 	 * Sets the canceled state of this command.
---
>      * Obtains an iterator to traverse my child operations in either direction,
>      * starting from the specified <code>index</code>. Adding and removing
>      * children via this iterator correctly maintains my undo contexts.
>      * <p>
>      * <b>Note</b> that, unlike list iterators generally, this implementation
>      * does not permit the addition of an operation that I already contain (the
>      * composite does not permit duplicates). Moreover, only
>      * {@link IUndoableOperation}s may be added, otherwise
>      * <code>ClassCastException</code>s will result.
>      * </p>
500,502c825,828
< 	 * @param canceled
< 	 *            <code>true</code> if the command was canceled,
< 	 *            <code>false</code> otherwise.
---
>      * @param index
>      *            the index in my children at which to start iterating
>      * 
>      * @return an iterator of my children
504,505c830,831
< 	protected void setCanceled(boolean canceled) {
< 		this.canceled = canceled;
---
>     public ListIterator listIterator(int index) {
>         return new ChildListIterator(index);
509c835,836
< 	 * Gets the canceled state of this command.
---
>      * Custom iterator implementation that maintains my undo contexts correctly
>      * when elements are removed.
511,512c838
< 	 * @return <code>true</code> if the command was canceled,
< 	 *         <code>false</code> otherwise.
---
>      * @author ldamus
514,515c840,870
< 	protected boolean isCanceled() {
< 		return canceled;
---
>     private class ChildIterator
>         implements Iterator {
> 
>         protected Object last;
> 
>         protected final ListIterator iter;
> 
>         ChildIterator() {
>             this(0);
>         }
> 
>         ChildIterator(int index) {
>             iter = getChildren().listIterator(index);
>         }
> 
>         public void remove() {
>             assertNotExecuted();
> 
>             iter.remove();
>             didRemove((IUndoableOperation) last);
>             last = null;
>         }
> 
>         public Object next() {
>             last = iter.next();
>             return last;
>         }
> 
>         public boolean hasNext() {
>             return iter.hasNext();
>         }
519,520c874,875
< 	 * Return a validator which can be used to check whether the units being
< 	 * modified by a command are writable.
---
>      * Custom list-iterator implementation that maintains my undo contexts
>      * correctly, as well as uniqueness of the list contents.
522c877
< 	 * @return CMValidator
---
>      * @author ldamus
524,525c879,884
< 	public CMValidator getValidator() {
< 		return new CMValidator();
---
>     private class ChildListIterator
>         extends ChildIterator
>         implements ListIterator {
> 
>         ChildListIterator(int index) {
>             super(index);
527a887,923
>         public void add(Object o) {
>             assertNotExecuted();
> 
>             if (!getChildren().contains(o)) {
>                 iter.add(o);
>                 didAdd((IUndoableOperation) o);
>             }
>         }
> 
>         public void set(Object o) {
>             assertNotExecuted();
> 
>             if (!getChildren().contains(o)) {
>                 didRemove((IUndoableOperation) last);
>                 iter.set(o);
>                 last = o;
>                 didAdd((IUndoableOperation) o);
>             }
>         }
> 
>         public int previousIndex() {
>             return iter.previousIndex();
>         }
> 
>         public int nextIndex() {
>             return iter.nextIndex();
>         }
> 
>         public Object previous() {
>             last = iter.previous();
>             return last;
>         }
> 
>         public boolean hasPrevious() {
>             return iter.hasPrevious();
>         }
>     }
