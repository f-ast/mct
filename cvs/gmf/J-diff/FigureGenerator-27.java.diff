2c2
<  * Copyright (c) 2005 Borland Software Corporation
---
>  * Copyright (c) 2006 Borland Software Corporation
14a15,17
> import java.util.ArrayList;
> import java.util.HashMap;
> import java.util.Map;
17d19
< import org.eclipse.core.runtime.Platform;
20,26d21
< import org.eclipse.gmf.gmfgraph.BorderLayout;
< import org.eclipse.gmf.gmfgraph.BorderLayoutData;
< import org.eclipse.gmf.gmfgraph.CompoundBorder;
< import org.eclipse.gmf.gmfgraph.CustomBorder;
< import org.eclipse.gmf.gmfgraph.CustomFigure;
< import org.eclipse.gmf.gmfgraph.CustomLayout;
< import org.eclipse.gmf.gmfgraph.CustomLayoutData;
28,40d22
< import org.eclipse.gmf.gmfgraph.FlowLayout;
< import org.eclipse.gmf.gmfgraph.GridLayout;
< import org.eclipse.gmf.gmfgraph.GridLayoutData;
< import org.eclipse.gmf.gmfgraph.Label;
< import org.eclipse.gmf.gmfgraph.LineBorder;
< import org.eclipse.gmf.gmfgraph.MarginBorder;
< import org.eclipse.gmf.gmfgraph.PolygonDecoration;
< import org.eclipse.gmf.gmfgraph.Polyline;
< import org.eclipse.gmf.gmfgraph.PolylineConnection;
< import org.eclipse.gmf.gmfgraph.PolylineDecoration;
< import org.eclipse.gmf.gmfgraph.RoundedRectangle;
< import org.eclipse.gmf.gmfgraph.Shape;
< import org.eclipse.gmf.gmfgraph.XYLayoutData;
42,77d23
< import org.eclipse.gmf.graphdef.codegen.templates.CustomClassAttributesGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.CustomFigureAttrGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.FigureAttrGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.FigureChildrenGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.InitBorderLayoutDataGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.InitBorderLayoutGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.InitCustomLayoutDataGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.InitCustomLayoutGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.InitFlowLayoutGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.InitGridLayoutDataGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.InitGridLayoutGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.InitXYLayoutDataGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.LabelAttrGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.NewCompoundBorderExpressionGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.NewCustomBorderExpressionGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.NewFigureGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.NewLayoutDataGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.NewLayoutGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.NewLineBorderExpressionGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.NewMarginBorderExpressionGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.PolygonDecorationAttrGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.PolylineAttrGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.PolylineDecorationAttrGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.RoundedRectAttrGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.ShapeAttrGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.TopConnectionGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.TopFigureGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.TopGenerator;
< import org.eclipse.gmf.internal.codegen.dispatch.CachingEmitterFactory;
< import org.eclipse.gmf.internal.codegen.dispatch.EmitterFactory;
< import org.eclipse.gmf.internal.codegen.dispatch.EmitterFactoryImpl;
< import org.eclipse.gmf.internal.codegen.dispatch.HierarchyKeyMap;
< import org.eclipse.gmf.internal.codegen.dispatch.KeyChain;
< import org.eclipse.gmf.internal.codegen.dispatch.KeyMap;
< import org.eclipse.gmf.internal.codegen.dispatch.StaticTemplateRegistry;
< import org.eclipse.gmf.internal.codegen.dispatch.TemplateRegistry;
79c25,28
< import org.osgi.framework.Bundle;
---
> import org.eclipse.gmf.internal.graphdef.codegen.Activator;
> import org.eclipse.gmf.internal.xpand.BufferOutput;
> import org.eclipse.gmf.internal.xpand.XpandFacade;
> import org.eclipse.gmf.internal.xpand.expression.Variable;
81,84d29
< /**
<  * @author artem
<  *
<  */
86c31,37
< 	private static final String ENTRY_POINT = "main";
---
> 	private final XpandFacade xpandFacade;
> 
> 	private final StringBuilder result;
> 
> 	private Variable packageStatement;
> 
> 	private StringBuilder additionalMethods;
88,89d38
< 	private final GraphDefDispatcher myTopDispatcher;
< 	private final GraphDefDispatcher myInnerDispatcher;
92,94c41
< 	public FigureGenerator(FigureQualifiedNameSwitch figureNameSwitch, boolean asInnerClass) {
< 		this(figureNameSwitch, MapModeCodeGenStrategy.DYNAMIC, asInnerClass);
< 	}
---
> 	private StringBuilder additionalFields;
96,166c43,45
< 	public FigureGenerator(FigureQualifiedNameSwitch figureNameSwitch, MapModeCodeGenStrategy mapModeStrategy, boolean placeStaticFieldsOutsideClassBody) {
< 		myIsInnerClassCode = placeStaticFieldsOutsideClassBody;
< 		final Bundle thisBundle = Platform.getBundle("org.eclipse.gmf.graphdef.codegen");
< 		final String[] variables = new String[] {
< 				"org.eclipse.gmf.graphdef",
< 				"org.eclipse.emf.ecore",
< 				"org.eclipse.emf.common",
< 				"org.eclipse.gmf.common",
< 				"org.eclipse.gmf.graphdef.codegen"
< 		};
< 
< 		KeyMap keyMap = new ClassesOrStringsKeyMap();
< 		String[] templatePath = new String[] {thisBundle.getEntry("/templates/").toString()};
< 		EmitterFactory topFactory = new CachingEmitterFactory(new EmitterFactoryImpl(templatePath, fillTopLevel(), true, variables));
< 		myTopDispatcher = new GraphDefDispatcher(topFactory, keyMap, figureNameSwitch, mapModeStrategy);
< 		EmitterFactory innerFactory = new CachingEmitterFactory(new EmitterFactoryImpl(templatePath, fillAttrs(), true, variables));
< 		myInnerDispatcher = new GraphDefDispatcher(innerFactory, keyMap, figureNameSwitch, mapModeStrategy);
< 	}
< 
< 	private static TemplateRegistry fillTopLevel() {
< 		StaticTemplateRegistry tr = new StaticTemplateRegistry(FigureGenerator.class.getClassLoader());
< 		tr.put(ENTRY_POINT, "/top/Top.javajet", TopGenerator.class);
< 		tr.put(PolylineConnection.class, "/top/PolylineConnection.javajet", TopConnectionGenerator.class);
< 		tr.put(Figure.class, "/top/Figure.javajet", TopFigureGenerator.class);
< 		return tr;
< 	}
< 	
< 	// XXX NOTE, the fact we use "instantiate" and "Children" strings
< 	// helps us to postpone resolution of the next problem (one we make these twwo overridable):
< 	// it's not possible to tell from single dispatcher.dispatch(Figure, args) what's the intention - 
< 	// whether to instantiate, look for children or initialize attributes
< 	// Perhaps, we should have distinct methods in the Dispatcher, or add "hint" as another argument
< 	private static TemplateRegistry fillAttrs() {
< 		StaticTemplateRegistry tr = new StaticTemplateRegistry(FigureGenerator.class.getClassLoader());
< 		tr.put(Figure.class, "/attr/Figure.javajet", FigureAttrGenerator.class);
< 		tr.put(Shape.class, "/attr/Shape.javajet", ShapeAttrGenerator.class);
< 		tr.put(Label.class, "/attr/Label.javajet", LabelAttrGenerator.class);
< 		tr.put(Polyline.class, "/attr/Polyline.javajet", PolylineAttrGenerator.class);
< 		tr.put(RoundedRectangle.class, "/attr/RoundedRectangle.javajet", RoundedRectAttrGenerator.class);
< 		tr.put(PolygonDecoration.class, "/attr/PolygonDecoration.javajet", PolygonDecorationAttrGenerator.class);
< 		tr.put(PolylineDecoration.class, "/attr/PolylineDecoration.javajet", PolylineDecorationAttrGenerator.class);
< 		tr.put(CustomFigure.class, "/attr/CustomFigure.javajet", CustomFigureAttrGenerator.class);
< 		// instantiation templates - only single one now. FIXME - make it overridable
< 		tr.put("instantiate", "/new/Figure.javajet", NewFigureGenerator.class);
< 		// children templates - only single one now. FIXME - make it overridable
< 		tr.put("Children", "/children/Figure.javajet", FigureChildrenGenerator.class);
< 		// FIXME same template is registered twice
< 		tr.put("Shape", "/attr/Shape.javajet", ShapeAttrGenerator.class);
< 		tr.put("Figure", "/attr/Figure.javajet", FigureAttrGenerator.class);
< 		tr.put("PolylineDecoration", "/attr/PolylineDecoration.javajet", PolylineDecorationAttrGenerator.class);
< 
< 		// Custom attributes support
< 		tr.put("customAttributes", "/attr/CustomConfigurableClass.javajet", CustomClassAttributesGenerator.class);
< 		// Layout related dispatching chain.  
< 		tr.put("createLayout", "/new/Layout.javajet", NewLayoutGenerator.class);
< 		tr.put(GridLayout.class, "/layout/GridLayout.javajet", InitGridLayoutGenerator.class);
< 		tr.put(BorderLayout.class, "/layout/BorderLayout.javajet", InitBorderLayoutGenerator.class);
< 		tr.put(CustomLayout.class, "/layout/CustomLayout.javajet", InitCustomLayoutGenerator.class);
< 		tr.put(FlowLayout.class, "/layout/FlowLayout.javajet", InitFlowLayoutGenerator.class);
< 		
< 		tr.put("createLayoutData", "/new/LayoutData.javajet", NewLayoutDataGenerator.class);
< 		tr.put(GridLayoutData.class, "/layoutData/GridLayoutData.javajet", InitGridLayoutDataGenerator.class);
< 		tr.put(BorderLayoutData.class, "/layoutData/BorderLayoutData.javajet", InitBorderLayoutDataGenerator.class);
< 		tr.put(CustomLayoutData.class, "/layoutData/CustomLayoutData.javajet", InitCustomLayoutDataGenerator.class);
< 		tr.put(XYLayoutData.class, "/layoutData/XYLayoutData.javajet", InitXYLayoutDataGenerator.class);
< 		
< 		//Borders 
< 		tr.put(LineBorder.class, "/new/LineBorder.javajet", NewLineBorderExpressionGenerator.class);
< 		tr.put(MarginBorder.class, "/new/MarginBorder.javajet", NewMarginBorderExpressionGenerator.class);
< 		tr.put(CompoundBorder.class, "/new/CompoundBorder.javajet", NewCompoundBorderExpressionGenerator.class);
< 		tr.put(CustomBorder.class, "/new/CustomBorder.javajet", NewCustomBorderExpressionGenerator.class);
---
> 	public FigureGenerator(FigureQualifiedNameSwitch fqnSwitch, boolean asInnerClass) {
> 		this(fqnSwitch, MapModeCodeGenStrategy.DYNAMIC, "getMapMode().", asInnerClass);
> 	}
168c47,90
< 		return tr;
---
> 	public FigureGenerator(FigureQualifiedNameSwitch fqnSwitch, MapModeCodeGenStrategy mapModeStrategy, String mapModeAccessor, boolean asInnerClass) {
> 		myIsInnerClassCode = asInnerClass;
> 		if (mapModeStrategy == MapModeCodeGenStrategy.STATIC) {
> 			if (mapModeAccessor != null && mapModeAccessor.trim().length() > 0) {
> 				throw new IllegalArgumentException("Can't use map mode accessor with identity map mode");
> 			}
> 		}
> 		final ArrayList<Variable> globals = new ArrayList<Variable>();
> 		if (mapModeStrategy == MapModeCodeGenStrategy.DYNAMIC) {
> 			globals.add(new Variable("mapModeAccessor", mapModeAccessor == null ? "" : mapModeAccessor));
> 		}
> 		globals.add(new Variable(FigureQualifiedNameSwitch.class.getSimpleName(), fqnSwitch));
> 		packageStatement = new Variable("packageStatement", "");
> 		globals.add(packageStatement);
> 		additionalMethods = new StringBuilder();
> 		globals.add(new Variable("outputAdditionalMethods", "") {
> 			public Object getValue() {
> 				return additionalMethods.toString();
> 			}
> 		});
> 		additionalFields = new StringBuilder();
> 		globals.add(new Variable("outputStaticFields", "") {
> 			public Object getValue() {
> 				return additionalFields.toString();
> 			}
> 		});
> 		result = new StringBuilder(200);
> 		Map<String, StringBuilder> slots = new HashMap<String, StringBuilder>();
> 		slots.put("additionalMethods", additionalMethods);
> 		slots.put("staticFields", additionalFields);
> 		BufferOutput bufferOutput = new BufferOutput(result, slots);
> 		xpandFacade = Activator.createTemplateEngine(mapModeStrategy, bufferOutput, globals);
> 	}
> 
> 	public String go(Figure figure, ImportAssistant importAssistant) {
> 		result.setLength(0);
> 		additionalMethods.setLength(0);
> 		additionalFields.setLength(0);
> 		StringBuffer ss = new StringBuffer();
> 		importAssistant.emitPackageStatement(ss);
> 		packageStatement.setValue(ss.toString());
> 		xpandFacade.evaluate("top::Figure::FigureClass", figure, new Object[] {myIsInnerClassCode});
> 		final String resultString = result.toString();
> 		return resultString;
177,208d98
< 
< 	public String go(Figure fig, ImportAssistant importManager/*, Feedback feedback*/) {
< 		String res = null;
< 		myTopDispatcher.resetForNewClass(importManager);
< 		myInnerDispatcher.resetForNewClass(importManager);
< 		Object args = new Object[] {fig, myInnerDispatcher, myTopDispatcher, Boolean.valueOf(myIsInnerClassCode)};
< 		res = myTopDispatcher.dispatch(ENTRY_POINT, args);
< 		if (res == null) {
< 			throw new IllegalStateException();
< 		}
< 		return res;
< 	}
< 	
< 	private static class ClassesOrStringsKeyMap extends HierarchyKeyMap {
< 		/*
< 		 * Capture knowledge that we use classes and strings as keys
< 		 */
< 		public KeyChain map(Object key) {
< 			if (key instanceof String) {
< 				return super.map(key);
< 			} else {
< 				return super.map(key.getClass());
< 			}
< 		}
< 	}
< /*
< 	public static class Feedback {
< 		void registerChildAccessor(Figure parent, Figure child, String getterName, String setterName) {
< 			// do nothing
< 		}
< 	}
< */
