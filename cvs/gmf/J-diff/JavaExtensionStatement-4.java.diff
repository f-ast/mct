29a30
> import org.eclipse.gmf.internal.xpand.expression.Variable;
41,43c42,45
<     public JavaExtensionStatement(final int start, final int end, final int line, final Identifier name,
<             final List<DeclaredParameter> formalParameters, final Identifier returnType, final Identifier defaultImplementation,
<             final Identifier javaMethod, final List<Identifier> javaParamTypes, final boolean cached, final boolean isPrivate) {
---
> 	protected final Identifier instanceSlot;
> 
> 	public JavaExtensionStatement(final int start, final int end, final int line, final Identifier name, final List<DeclaredParameter> formalParameters, final Identifier returnType, final Identifier defaultImplementation, final Identifier javaMethod, final List<Identifier> javaParamTypes,
> 			final boolean cached, final boolean isPrivate, final Identifier instanceSlot) {
47a50
> 		this.instanceSlot = instanceSlot;
65a69
> 			if (Modifier.isStatic(method.getModifiers())) {
66a71,83
> 			} else {
> 				if (instanceSlot == null) {
> 					throw new EvaluationException("Non-static method may be invoked only when slot with instance object is specified", this);
> 				}
> 				Variable variable = ctx.getGlobalVariable(instanceSlot.getValue());
> 				if (variable == null || variable.getValue() == null) {
> 					throw new EvaluationException("The method '" + javaMethodToString() + "' is not static in " + javaType.getValue() + ", and there's no global variable '" + instanceSlot + "' to obtain instance from", this);
> 				}
> 				if (!method.getDeclaringClass().isInstance(variable.getValue())) {
> 					throw new EvaluationException("Instance available in global vars as '" + instanceSlot + "' is not compatible with " + javaType.getValue(), this);
> 				}
> 				return method.invoke(variable.getValue(), parameters);
> 			}
88c105
<     public Method getJavaMethod(final ExecutionContext ctx, final Set<AnalysationIssue> issues) {
---
> 	private Method getJavaMethod(final ExecutionContext ctx, final Set<AnalysationIssue> issues) {
117,118c134,135
<             if (!Modifier.isStatic(m.getModifiers())) {
<                 issues.add(new AnalysationIssue(AnalysationIssue.FEATURE_NOT_FOUND, javaMethod.getValue() + " must be static!", javaMethod));
---
> 			if (instanceSlot == null && !Modifier.isStatic(m.getModifiers())) {
> 				issues.add(new AnalysationIssue(AnalysationIssue.FEATURE_NOT_FOUND, javaMethod.getValue() + " must be static (unless slot to get instance from is specified)!", javaMethod));
120d136
< 
