32d31
< import org.eclipse.gmf.runtime.draw2d.ui.render.internal.factory.RenderInfoImpl;
38c37
< 
---
> import org.eclipse.swt.graphics.RGB;
45a45
> 
74a75,76
> 	 * @deprecated use
> 	 *             {@link RenderedImageFactory#createInfo(int, int, RGB, RGB, boolean, boolean)}
76,89c78,81
< 	static public RenderInfo createInfo(
< 		int width,
< 		int height,
< 		Color fill,
< 		Color outline,
< 		boolean maintainAspectRatio,
< 		boolean antialias) {
< 		RenderInfoImpl svgInfo = new RenderInfoImpl();
< 		svgInfo.setValues(
< 			width,
< 			height,
< 			fill,
< 			outline,
< 			maintainAspectRatio,
---
> 	static public RenderInfo createInfo(int width, int height, Color fill,
> 			Color outline, boolean maintainAspectRatio, boolean antialias) {
> 		RenderedImageKey svgInfo = new RenderedImageKey();
> 		svgInfo.setValues(width, height, fill, outline, maintainAspectRatio,
94a87,122
> 	 * createInfo static Utility to create a RenderInfo object.
> 	 * 
> 	 * @param width
> 	 *            the width of the rendered image to set
> 	 * @param height
> 	 *            the height of the rendered image to set
> 	 * @param maintainAspectRatio
> 	 *            <code>boolean</code> <code>true</code> if aspect ratio of
> 	 *            original vector file is maintained, <code>false</code>
> 	 *            otherwise
> 	 * @param antialias
> 	 *            <code>boolean</code> <code>true</code> if the image is to
> 	 *            be rendered using anti-aliasing (removing "jaggies" producing
> 	 *            smoother lines), <code>false</code> otherwise
> 	 * @param fill
> 	 *            the <code>RGB</code> of the fill that could instrumented
> 	 *            into image formats that support dynamic color replacement.
> 	 *            Typically, this would replace colors in the image which are
> 	 *            "white" i.e. RGB(255,255,255)
> 	 * @param outline
> 	 *            the <code>RGB</code> of the outline that could
> 	 *            instrumented into image formats that support dynamic color
> 	 *            replacement. Typically, this would replace colors in the image
> 	 *            which are "black" i.e. RGB(0,0,0)
> 	 * @return <code>RenderInfo</code> object that contains information about
> 	 *         the rendered image.
> 	 */
> 	static public RenderInfo createInfo(int width, int height, boolean maintainAspectRatio, boolean antialias,
> 			RGB fill, RGB outline ) {
> 		RenderedImageKey svgInfo = new RenderedImageKey();
> 		svgInfo.setValues(width, height, maintainAspectRatio,
> 			antialias, fill, outline);
> 		return svgInfo;
> 	}
> 	
> 	/**
105c133
< 		return getInstance(theURL, new RenderInfoImpl());
---
> 		return getInstance(theURL, new RenderedImageKey());
136c164,166
< 			Trace.throwing(Draw2dRenderPlugin.getInstance(), Draw2dRenderDebugOptions.EXCEPTIONS_THROWING, RenderedImage.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
---
> 			Trace.throwing(Draw2dRenderPlugin.getInstance(),
> 				Draw2dRenderDebugOptions.EXCEPTIONS_THROWING,
> 				RenderedImage.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
153c183
< 		return getInstance(szFilePath, new RenderInfoImpl());
---
> 		return getInstance(szFilePath, new RenderedImageKey());
181c211,214
< 			Trace.throwing(Draw2dRenderPlugin.getInstance(), Draw2dRenderDebugOptions.EXCEPTIONS_THROWING, RenderedImageFactory.class, "RenderedImageFactory.getInstance()", //$NON-NLS-1$
---
> 			Trace.throwing(Draw2dRenderPlugin.getInstance(),
> 				Draw2dRenderDebugOptions.EXCEPTIONS_THROWING,
> 				RenderedImageFactory.class,
> 				"RenderedImageFactory.getInstance()", //$NON-NLS-1$
199c232
< 		return getInstance(buffer, new RenderInfoImpl());
---
> 		return getInstance(buffer, new RenderedImageKey());
211,212c244,246
< 	 *            <code>RenderInfo</code> object containing information about the size 
< 	 *            and general data regarding how the image will be rendered.
---
> 	 *            <code>RenderInfo</code> object containing information about
> 	 *            the size and general data regarding how the image will be
> 	 *            rendered.
217c251,252
< 	static public RenderedImage getRelatedInstance(RenderedImage image, RenderInfo info) {
---
> 	static public RenderedImage getRelatedInstance(RenderedImage image,
> 			RenderInfo info) {
220c255
< 			RenderedImageKey key = new RenderedImageKey(oldKey.getChecksum(), info, oldKey.getExtraData());
---
> 			RenderedImageKey key = new RenderedImageKey(info, oldKey.getChecksum(), oldKey.getExtraData());
224,226c259,261
< 			}
< 			else {
< 				return autodetectImage(((AbstractRenderedImage)image).getBuffer(), key);
---
> 			} else {
> 				return autodetectImage(((AbstractRenderedImage) image)
> 					.getBuffer(), key);
251c286
< 		final RenderedImageKey key = new RenderedImageKey(checksum.getValue(), info, null);
---
> 		final RenderedImageKey key = new RenderedImageKey(info, checksum.getValue(), null);
255c290,291
< 			image = (RenderedImage)(((WeakReference) instanceMap.get(key)).get());
---
> 			image = (RenderedImage) (((WeakReference) instanceMap.get(key))
> 				.get());
262c298,299
< 	private static RenderedImage autodetectImage(byte[] buffer, final RenderedImageKey key) {
---
> 	private static RenderedImage autodetectImage(byte[] buffer,
> 			final RenderedImageKey key) {
278c315,316
< 	        	   	ByteArrayInputStream input = new ByteArrayInputStream(buffer);
---
> 					ByteArrayInputStream input = new ByteArrayInputStream(
> 						buffer);
