19a20,22
> import org.eclipse.gmf.runtime.diagram.core.internal.util.MEditingDomainGetter;
> import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil;
> import org.eclipse.gmf.runtime.diagram.ui.editparts.GraphicalEditPart;
20a24,27
> import org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart;
> import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
> import org.eclipse.gmf.runtime.notation.View;
> import org.eclipse.jface.preference.IPreferenceStore;
21a29,32
> import org.eclipse.ui.IWorkbenchPage;
> import org.eclipse.ui.IWorkbenchPart;
> import org.eclipse.ui.IWorkbenchWindow;
> import org.eclipse.ui.PlatformUI;
62a74
> 				if (shouldShowDiagramAssistant()) {
66a79
> 	}
101c114
< 			if (part.hasFocus()) {
---
> 			if (part.hasFocus() && shouldShowDiagramAssistant()) {
183a197,291
> 	 * Returns true if the diagram assistant should be shown; false otherwise.
> 	 * This can be overridden to check any other conditions which must be met
> 	 * prior to showing the diagram assistant.
> 	 * 
> 	 * @return true if the diagram assistant should be shown; false otherwise.
> 	 */
> 	protected boolean shouldShowDiagramAssistant() {
> 		return isPreferenceOn() && getHost().isActive() && isHostEditable()
> 			&& isHostResolvable() && isDiagramPartActive();
> 	}
> 
> 	/**
> 	 * Returns true if the preference to show this diagram assistant is on or if
> 	 * there is no applicable preference; false otherwise.
> 	 */
> 	protected boolean isPreferenceOn() {
> 		String prefName = getPreferenceName();
> 		if (prefName == null) {
> 			return true;
> 		}
> 		IPreferenceStore preferenceStore = (IPreferenceStore) ((IGraphicalEditPart) getHost())
> 			.getDiagramPreferencesHint().getPreferenceStore();
> 		return preferenceStore.getBoolean(prefName);
> 	}
> 
> 	/**
> 	 * The preference name indicating if the preference should be on or off.
> 	 * This preference must be a boolean preference stored in the diagram
> 	 * preferences.
> 	 * 
> 	 * @return the preference name if applicable; null otherwise
> 	 */
> 	String getPreferenceName() {
> 		return null;
> 	}
> 	
> 	/**
> 	 * Checks if the host editpart is editable.
> 	 * 
> 	 * @return True if the host is editable; false otherwise.
> 	 */
> 	private boolean isHostEditable() {
> 		if (getHost() instanceof GraphicalEditPart) {
> 			return ((GraphicalEditPart) getHost()).isEditModeEnabled();
> 		}
> 		return true;
> 	}
> 
> 	/**
> 	 * Is the host's semantic reference resolvable (if applicable)?
> 	 * 
> 	 * @return true if the semantic reference is resolvable, true if there is no
> 	 *         semantic reference, and false otherwise
> 	 */
> 	private boolean isHostResolvable() {
> 		final View view = (View) getHost().getModel();
> 		if (view.getElement() != null) {
> 			Boolean retval = (Boolean) MEditingDomainGetter.getMEditingDomain(
> 				view).runAsRead(new MRunnable() {
> 
> 				public Object run() {
> 					return ViewUtil.resolveSemanticElement(view) != null ? Boolean.TRUE
> 						: Boolean.FALSE;
> 				}
> 			});
> 			return retval.booleanValue();
> 		}
> 		return true;
> 	}
> 	
> 	
> 	/**
> 	 * Checks if the diagram part is active.
> 	 * 
> 	 * @return True if the diagram part is active; false otherwise.
> 	 */
> 	private boolean isDiagramPartActive() {
> 		IWorkbenchWindow window = PlatformUI.getWorkbench()
> 			.getActiveWorkbenchWindow();
> 
> 		if (window != null) {
> 			IWorkbenchPage page = window.getActivePage();
> 			if (page != null) {
> 				IWorkbenchPart activePart = page.getActivePart();
> 				if (activePart instanceof IDiagramWorkbenchPart) {
> 					return ((IDiagramWorkbenchPart) activePart)
> 						.getDiagramEditPart().getRoot().equals(
> 							((IGraphicalEditPart) getHost()).getRoot());
> 				}
> 			}
> 		}
> 		return false;
> 	}
> 	
> 	/**
189a298
> 		if (shouldShowDiagramAssistant()) {
192a302
> 	}
