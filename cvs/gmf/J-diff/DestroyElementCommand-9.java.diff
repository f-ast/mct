13a14
> import java.util.Collection;
15d15
< import java.util.List;
22a23
> import org.eclipse.emf.ecore.EStructuralFeature.Setting;
30c31
< import org.eclipse.gmf.runtime.emf.core.internal.util.ReferenceVisitor;
---
> import org.eclipse.gmf.runtime.emf.core.util.CrossReferenceAdapter;
91c92
< 			if (command != null) {
---
> 			if (command != null && command.canExecute()) {
107a109,111
> 	/* (non-Javadoc)
> 	 * @see org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand#doExecuteWithResult(org.eclipse.core.runtime.IProgressMonitor, org.eclipse.core.runtime.IAdaptable)
> 	 */
142,144c146,170
< 		TearDownVisitor visitor = new TearDownVisitor(getElementToDestroy());
< 		visitor.visitReferencers();    // gather the tear-down actions
< 		visitor.tearDownReferences();  // execute them
---
> 		CrossReferenceAdapter crossReferencer = CrossReferenceAdapter
> 			.getExistingCrossReferenceAdapter(destructee);
> 		if (crossReferencer != null) {
> 			Collection inverseReferences = crossReferencer
> 				.getInverseReferences(destructee);
> 			if (inverseReferences != null) {
> 				int size = inverseReferences.size();
> 				if (size > 0) {
> 					Setting setting;
> 					EReference eRef;
> 					Setting[] settings = (Setting[]) inverseReferences
> 						.toArray(new Setting[size]);
> 					for (int i = 0; i < size; ++i) {
> 						setting = settings[i];
> 						eRef = (EReference) setting.getEStructuralFeature();
> 						if (eRef.isChangeable() && (eRef.isDerived() == false)
> 							&& (eRef.isContainment() == false)
> 							&& (eRef.isContainer() == false)) {
> 							EcoreUtil.remove(setting.getEObject(), eRef,
> 								destructee);
> 						}
> 					}
> 				}
> 			}
> 		}
183,234d208
< 	/**
< 	 * A reference visitor that creates a list of deferred tear-down actions,
< 	 * to tear down references to the element being destroyed.  These actions
< 	 * are deferred to avoid concurrently updating the cross-reference map while
< 	 * we are walking the cross-references.
< 	 *
< 	 * @author Christian W. Damus (cdamus)
< 	 */
< 	private static class TearDownVisitor extends ReferenceVisitor {
< 		private List tearDownActions = null;
< 		
< 		TearDownVisitor(EObject elementToRemove) {
< 			super(elementToRemove);
< 		}
< 		
< 		/**
< 		 * Gather up the list of deferred tear-down actions.
< 		 */
< 		protected void visitedReferencer(final EReference reference,
< 				final EObject referencer) {
< 
< 			// container references will be handled by recursive detachment of
< 			//   the contents, and unchangeable/derived features can't be
< 			//   updated directly
< 			if (reference.isChangeable() && !reference.isDerived()
< 					&& !reference.isContainer()) {
< 				
< 				if (tearDownActions == null) {
< 					tearDownActions = new java.util.ArrayList();
< 				}
< 				
< 				tearDownActions.add(new Runnable() {
< 					public void run() {
< 						// remove the referenced object from the reference
< 						EcoreUtil.remove(referencer, reference, referencedObject);
< 					}});
< 			}
< 		}
< 		
< 		/**
< 		 * Execute the list of deferred tear-down actions, if any, to actually
< 		 * delete references.
< 		 */
< 		void tearDownReferences() {
< 			if (tearDownActions != null) {
< 				for (Iterator iter = tearDownActions.iterator(); iter.hasNext();) {
< 					((Runnable) iter.next()).run();
< 				}
< 			}
< 		}
< 	}
< 
