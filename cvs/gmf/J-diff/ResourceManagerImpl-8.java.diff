2c2
<  * Copyright (c) 2006 Eclipse.org
---
>  * Copyright (c) 2006, 2007 Eclipse.org
18a19
> import org.eclipse.gmf.internal.xpand.expression.SyntaxConstants;
28,29d28
< 		Reader r = null;
< 		try {
33,35c32,33
< 			r = resolve(fullyQualifiedName, XtendResource.FILE_EXTENSION);
< 			assert r != null;
< 			final XtendResource loaded = loadXtendResource(r, fullyQualifiedName);
---
> 		try {
> 			final XtendResource loaded = doLoadXtendResource(fullyQualifiedName);
42c40
< 			return delegateLoadXtendResource(fullyQualifiedName);
---
> 			return null;	//Missing resource is an anticipated situation, not a error that should be handled
46a45,58
> 		}
> 		return null;
> 	}
> 
> 	private XtendResource doLoadXtendResource(String fullyQualifiedName) throws IOException, ParserException {
> 		Reader[] rs = resolveMultiple(fullyQualifiedName, XtendResource.FILE_EXTENSION);
> 		assert rs != null && rs.length > 0;
> 		XtendResource[] result = new XtendResource[rs.length];
> 		for (int i = 0; i < rs.length; i++) {
> 			Reader r = rs[i];
> 			assert r != null;
> 			try {
> 				result[i] = loadXtendResource(r, fullyQualifiedName);
> 				assert result[i] != null; // this is the contract of loadXpandResource
48d59
< 			if (r != null) {
54c65,68
< 		return null;
---
> 		if (result.length == 1) {
> 			return result[0];
> 		}
> 		return new CompositeXtendResource(this, result);
58,59d71
< 		Reader r = null;
< 		try {
63,66c75,76
< 			r = resolve(fullyQualifiedName, XpandResource.TEMPLATE_EXTENSION);
< 			assert r != null; // exception should be thrown to indicate issues with resolve
< 			final XpandResource loaded = loadXpandResource(r, fullyQualifiedName);
< 			assert loaded != null; // this is the contract of loadXpandResource
---
> 		try {
> 			final XpandResource loaded = doLoadXpandResource(fullyQualifiedName);
72c82
< 			return delegateLoadXpandResource(fullyQualifiedName);
---
> 			return null;	//Missing resource is an anticipated situation, not a error that should be handled
78,83d87
< 		} finally {
< 			if (r != null) {
< 				try {
< 					r.close();
< 				} catch (Exception ex) {/*IGNORE*/}
< 			}
88,92c92,106
< 	protected XtendResource delegateLoadXtendResource(String fullyQualifiedName) {
< 		for (ResourceManager next : getDependenies()) {
< 			XtendResource r = next.loadXtendResource(fullyQualifiedName);
< 			if (r != null) {
< 				return r;
---
> 	private XpandResource doLoadXpandResource(String fullyQualifiedName) throws IOException, ParserException {
> 		XpandResource[] unadvised = internalLoadXpandResources(fullyQualifiedName);
> 		XpandResource[] advices = null;
> 		try {
> 	    	String aspectsTemplateName = getAspectsTemplateName(fullyQualifiedName);
> 	    	advices = internalLoadXpandResources(aspectsTemplateName);
> 		} catch (FileNotFoundException e) {
> 		} catch (IOException ex) {
> 			// XXX come up with better handling
> 			Activator.logWarn(ex.getMessage());
> 		} catch (ParserException ex) {
> 			handleParserException(fullyQualifiedName, ex);
> 		}
> 		if (advices == null && unadvised.length == 1) {
> 			return unadvised[0];
93a108
> 		return new CompositeXpandResource(this, unadvised, advices);
94a110,123
> 
> 	/**
> 	 * XXX: only to simplify tests, should be private or inlined
> 	 */
> 	protected String getAspectsTemplateName(String fullyQualifiedName) {
> 		return ASPECT_PREFIX + fullyQualifiedName;
> 	}
> 
> 	/**
> 	 * If the given fully-qualified name is an aspect, transforms it to its "host" fully-qualified name. Otherwise,
> 	 * returns the given fully-qualified name.
> 	 */
> 	protected String getNonAspectsTemplateName(String possiblyAspectedFullyQualifiedName) {
> 		if (possiblyAspectedFullyQualifiedName == null) {
96a126,130
> 		if (possiblyAspectedFullyQualifiedName.startsWith(ASPECT_PREFIX)) {
> 			return possiblyAspectedFullyQualifiedName.substring(ASPECT_PREFIX.length());
> 		}
> 		return possiblyAspectedFullyQualifiedName;
> 	}
98,102c132,145
< 	protected XpandResource delegateLoadXpandResource(String fullyQualifiedName) {
< 		for (ResourceManager next : getDependenies()) {
< 			XpandResource r = next.loadXpandResource(fullyQualifiedName);
< 			if (r != null) {
< 				return r;
---
> 	private XpandResource[] internalLoadXpandResources(String fullyQualifiedName) throws IOException, ParserException {
> 		Reader[] rs = resolveMultiple(fullyQualifiedName, XpandResource.TEMPLATE_EXTENSION);
> 		assert rs != null && rs.length > 0; // exception should be thrown to indicate issues with resolve
> 		XpandResource[] result = new XpandResource[rs.length];
> 		for (int i = 0; i < rs.length; i++) {
> 			Reader r = rs[i];
> 			assert r != null;
> 			try {
> 				result[i] = loadXpandResource(r, fullyQualifiedName);
> 				assert result[i] != null; // this is the contract of loadXpandResource
> 			} finally {
> 				try {
> 					r.close();
> 				} catch (Exception ex) {/*IGNORE*/}
105c148
< 		return null;
---
> 		return result;
114a158
> 	 * @deprecated use {@link #resolveMultiple(String, String)} instead.
115a160
> 	@Deprecated
119,120c164,169
< 	 * Override if your implementation supports dependenices
< 	 * @return never null
---
> 	 * Returns an array of resolutions, in the order from newest to oldest. 
> 	 * This is to enable one template to partially override only a subset of parent templates. 
> 	 * By default, returns an array consisting of one Reader, the one that {@link #resolve(String, String)} returns.
> 	 * Subclasses should override.
> 	 * @return never return <code>null</code> or an empty array, throw exception instead
> 	 * @throws IOException in case resource can't be read. Throw {@link java.io.FileNotFoundException} to indicate resource was not found. 
122,123c171,172
< 	protected ResourceManager[] getDependenies() {
< 		return new ResourceManager[0];
---
> 	protected Reader[] resolveMultiple(String fullyQualifiedName, String extension) throws IOException {
> 		return new Reader[] {resolve(fullyQualifiedName, extension)};
151a201,202
> 
> 	private static final String ASPECT_PREFIX = "aspects" + SyntaxConstants.NS_DELIM;	//$NON-NLS-1$
