35d34
< import org.eclipse.gmf.runtime.common.core.util.Trace;
47,48d45
< import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderDebugOptions;
< import org.eclipse.gmf.runtime.diagram.ui.render.internal.DiagramUIRenderPlugin;
144c141,144
< 	abstract public Image createAWTImageForParts(List editparts);
---
> 	public Image createAWTImageForParts(List editparts) {
> 		org.eclipse.swt.graphics.Rectangle diagramArea = calculateImageRectangle(editparts);
> 		return createAWTImageForParts(editparts, diagramArea);
> 	}
169,215c169
< 
< 		// initialize imageDesc to the error icon
< 		ImageDescriptor imageDesc = new ImageDescriptor() {
< 
< 			/*
< 			 * (non-Javadoc)
< 			 * 
< 			 * @see org.eclipse.jface.resource.ImageDescriptor#getImageData()
< 			 */
< 			public ImageData getImageData() {
< 				return SharedImages.get(
< 					SharedImages.IMG_ERROR).getImageData();
< 			}
< 		};
< 
< 		Graphics graphics = null;
< 		try {
< 			IMapMode mm = getMapMode();
< 			
< 			// Create the graphics and wrap it with the HiMetric graphics object
< 			graphics = setUpGraphics(mm.LPtoDP(sourceRect.width), mm
< 				.LPtoDP(sourceRect.height));
< 
< 			RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics(
< 				graphics, getMapMode());
< 
< 			renderToGraphics(mapModeGraphics, new Point(sourceRect.x, sourceRect.y), editparts);
< 			imageDesc = getImageDescriptor(graphics);
< 		} catch (Error e) {
< 			// log the Error but allow execution to continue
< 			Trace.catching(DiagramUIRenderPlugin.getInstance(),
< 				DiagramUIRenderDebugOptions.EXCEPTIONS_THROWING, getClass(),
< 				"createSWTImageDescriptorForParts() failed to generate image", //$NON-NLS-1$
< 				e);
< 
< 		} catch (Exception ex) {
< 			// log the Exception but allow execution to continue
< 			Trace.catching(DiagramUIRenderPlugin.getInstance(),
< 				DiagramUIRenderDebugOptions.EXCEPTIONS_THROWING, getClass(),
< 				"createSWTImageDescriptorForParts() failed to generate image", //$NON-NLS-1$
< 				ex);
< 		}
< 
< 		if (graphics != null)
< 			disposeGraphics(graphics);
< 
< 		return imageDesc;
---
> 		return createSWTImageDescriptorForParts(editparts, sourceRect);
233,234c187,189
< 	 * 			  a <code>Point</code> that the value the <code>graphics</code> object
< 	 * 		   	  will be translated by in relative coordinates.
---
> 	 *            a <code>Point</code> that the value the
> 	 *            <code>graphics</code> object will be translated by in
> 	 *            relative coordinates.
305c260,261
<             relBounds = ((IExpandableFigure)figure).getExtendedBounds().getCopy();
---
> 			relBounds = ((IExpandableFigure) figure).getExtendedBounds()
> 					.getCopy();
554c510
< 	protected org.eclipse.swt.graphics.Rectangle calculateImageRectangle(
---
> 	public org.eclipse.swt.graphics.Rectangle calculateImageRectangle(
659,660c615
< 			}
< 			else if (part instanceof ConnectionEditPart) {
---
> 			} else if (part instanceof ConnectionEditPart) {
674c629,630
< 					List envelopingPts = calculateEnvelopingPolyline(mainPts, new Point(imageRect.x, imageRect.y));
---
> 					List envelopingPts = calculateEnvelopingPolyline(mainPts,
> 							new Point(imageRect.x, imageRect.y));
719,720c675,676
< 	 * On the figure above: AB is a given polyline. E1E2E3E4 is enveloping polyline
< 	 * built around AB perimeter using margin MARGIN.
---
> 	 * On the figure above: AB is a given polyline. E1E2E3E4 is enveloping
> 	 * polyline built around AB perimeter using margin MARGIN.
724,725c680,682
< 	 * @param origin location of the main diagram bounding box used to shift coordinates 
< 	 * 				to be relative against diagram
---
> 	 * @param origin
> 	 *            location of the main diagram bounding box used to shift
> 	 *            coordinates to be relative against diagram
727c684,685
< 	 * @return List of Point type objects (that carry X and Y coordinate pair) representing the polyline
---
> 	 * @return List of Point type objects (that carry X and Y coordinate pair)
> 	 *         representing the polyline
743c701,702
< 			orthoPoint1 = segment.locatePoint(0.0, getImageMargin(), Sign.POSITIVE);
---
> 			orthoPoint1 = segment.locatePoint(0.0, getImageMargin(),
> 					Sign.POSITIVE);
745c704,705
< 			orthoPoint2 = segment.locatePoint(1.0, getImageMargin(), Sign.POSITIVE);
---
> 			orthoPoint2 = segment.locatePoint(1.0, getImageMargin(),
> 					Sign.POSITIVE);
763c723,724
< 		// add first point to close the polyline per "poly" area type HTML requirements
---
> 		// add first point to close the polyline per "poly" area type HTML
> 		// requirements
774c735,736
< 	 * @return List of Point type objects (that carry X and Y coordinate pair) representing the polyline
---
> 	 * @return List of Point type objects (that carry X and Y coordinate pair)
> 	 *         representing the polyline
792d753
< 	
794c755,756
< 	 * @return <code>int</code> value that is the margin around the generated image in logical coordinates.
---
> 	 * @return <code>int</code> value that is the margin around the generated
> 	 *         image in logical coordinates.
798a761,811
> 
> 	/**
> 	 * Generates AWT image of specified editparts on the specified rectangle.
> 	 * 
> 	 * @param editParts editparts
> 	 * @param diagramArea clipping rectangle
> 	 * @return AWT image
> 	 */
> 	public Image createAWTImageForParts(List editParts,
> 			org.eclipse.swt.graphics.Rectangle diagramArea) {
> 		return null;
> 	}
> 
> 	final public ImageDescriptor createSWTImageDescriptorForParts(
> 			List editparts, org.eclipse.swt.graphics.Rectangle sourceRect) {
> 
> 		// initialize imageDesc to the error icon
> 		ImageDescriptor imageDesc = new ImageDescriptor() {
> 
> 			/*
> 			 * (non-Javadoc)
> 			 * 
> 			 * @see org.eclipse.jface.resource.ImageDescriptor#getImageData()
> 			 */
> 			public ImageData getImageData() {
> 				return SharedImages.get(SharedImages.IMG_ERROR).getImageData();
> 			}
> 		};
> 
> 		Graphics graphics = null;
> 		try {
> 			IMapMode mm = getMapMode();
> 
> 			// Create the graphics and wrap it with the HiMetric graphics object
> 			graphics = setUpGraphics(mm.LPtoDP(sourceRect.width), mm
> 					.LPtoDP(sourceRect.height));
> 
> 			RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics(
> 					graphics, getMapMode());
> 
> 			renderToGraphics(mapModeGraphics, new Point(sourceRect.x,
> 					sourceRect.y), editparts);
> 			imageDesc = getImageDescriptor(graphics);
> 		} finally {
> 			if (graphics != null)
> 				disposeGraphics(graphics);
> 		}
> 
> 		return imageDesc;
> 	}
> 
