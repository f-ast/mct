636,637c636,637
< 		List result = new ArrayList();
< 		List editParts = new ArrayList();
---
> 		List<PartPositionInfo> result = new ArrayList<PartPositionInfo>();
> 		List<IGraphicalEditPart> editParts = new ArrayList<IGraphicalEditPart>();
639c639
< 		List children = diagramEditPart.getPrimaryEditParts();
---
> 		List<IGraphicalEditPart> children = (List<IGraphicalEditPart>) diagramEditPart.getPrimaryEditParts();
648,650c648
< 		Iterator li = children.iterator();
< 		while (li.hasNext()) {
< 			IGraphicalEditPart part = (IGraphicalEditPart) li.next();
---
> 		for (IGraphicalEditPart part : children) {
655,657c653
< 		Iterator iter = editParts.iterator();
< 		while (iter.hasNext()) {
< 			IGraphicalEditPart part = (IGraphicalEditPart) iter.next();
---
> 		for (IGraphicalEditPart part : editParts) {
694c690
< 					List envelopingPts = calculateEnvelopingPolyline(mainPts,
---
> 					List<Point> envelopingPts = calculateEnvelopingPolyline(mainPts,
696c692,774
< 					List transformedPts = convertPolylineUnits(envelopingPts);
---
> 					List<Point> transformedPts = convertPolylineUnits(envelopingPts);
> 
> 					position.setPolyline(transformedPts);
> 					result.add(0, position);
> 				}
> 			}
> 		}
> 		return result;
> 	}
> 	
> 	public List<PartPositionInfo> getConstrainedDiagramPartInfo(int maxWidth, int maxHeight, boolean useMargins) {
> 		return getConstrainedDiagramPartInfo(_dgrmEP, maxWidth, maxHeight, useMargins);
> 	}
> 	
> 	public List<PartPositionInfo> getConstrainedDiagramPartInfo(DiagramEditPart diagramEditPart, int maxWidth, int maxHeight, boolean useMargins) {
> 		List<PartPositionInfo> result = new ArrayList<PartPositionInfo>();
> 		List<IGraphicalEditPart> editParts = new ArrayList<IGraphicalEditPart>();
> 
> 		List<IGraphicalEditPart> children = (List<IGraphicalEditPart>) diagramEditPart.getPrimaryEditParts();
> 		IMapMode mm = getMapMode();
> 
> 		// We will use the diagram generate that was used to generate the image
> 		// to figure out the outer-bound rectangle so that we are calculating
> 		// the
> 		// image positions using the same box as was used to create the image.
> 		ConstrainedImageRenderingData data = getConstrainedImageRenderingData(children, maxWidth, maxHeight, useMargins);
> 		Rectangle imageRect = data.imageOriginalBounds.getCopy();
> 		mm.DPtoLP(imageRect);
> 		if (useMargins) {
> 			imageRect.shrink(getImageMargin(), getImageMargin());
> 		}
> 		imageRect.performScale(data.scalingFactor);
> 		if (useMargins) {
> 			imageRect.expand(getImageMargin(), getImageMargin());
> 		}
> 
> 		for (IGraphicalEditPart part : children) {
> 			editParts.add(part);
> 			getNestedEditParts(part, editParts);
> 		}
> 
> 		for (IGraphicalEditPart part : editParts) {
> 			IFigure figure = part.getFigure();
> 
> 			// RATLC00139941: Need to support any kind of shape edit part
> 			// and shape compartments, too, because these sometimes
> 			// correspond to distinct semantic elements
> 			if (part instanceof ShapeEditPart
> 					|| part instanceof ShapeCompartmentEditPart) {
> 
> 				PartPositionInfo position = new PartPositionInfo();
> 
> 				position.setSemanticElement(ViewUtil
> 						.resolveSemanticElement((View) part.getModel()));
> 
> 				Rectangle bounds = figure.getBounds().getCopy();
> 				translateToPrintableLayer(figure, bounds);
> 				bounds.performScale(data.scalingFactor);
> 				bounds.translate(-imageRect.x, -imageRect.y);
> 
> 				position.setPartHeight(mm.LPtoDP(bounds.height));
> 				position.setPartWidth(mm.LPtoDP(bounds.width));
> 				position.setPartX(mm.LPtoDP(bounds.x));
> 				position.setPartY(mm.LPtoDP(bounds.y));
> 				result.add(0, position);
> 			} else if (part instanceof ConnectionEditPart) {
> 				// find a way to get (P1, P2, ... PN) for connection edit part
> 				// add MARGIN and calculate "stripe" for the polyline instead of
> 				// bounding box.
> 				PartPositionInfo position = new PartPositionInfo();
> 
> 				position.setSemanticElement(ViewUtil
> 						.resolveSemanticElement((View) part.getModel()));
> 
> 				if (figure instanceof PolylineConnection) {
> 					PolylineConnection mainPoly = (PolylineConnection) figure;
> 					PointList mainPts = mainPoly.getPoints();
> 					mainPts.performScale(data.scalingFactor);
> 
> 					translateToPrintableLayer(figure, mainPts);
> 					List<Point> envelopingPts = calculateEnvelopingPolyline(mainPts,
> 							new Point(imageRect.x, imageRect.y));
> 					List<Point> transformedPts = convertPolylineUnits(envelopingPts);
753,755c831,833
< 	private List calculateEnvelopingPolyline(PointList polyPts, Point origin) {
< 		ArrayList result = new ArrayList();
< 		List mainSegs = PointListUtilities.getLineSegments(polyPts);
---
> 	private List<Point> calculateEnvelopingPolyline(PointList polyPts, Point origin) {
> 		List<Point> result = new ArrayList<Point>();
> 		List<LineSeg> mainSegs = (List<LineSeg>) PointListUtilities.getLineSegments(polyPts);
790,791c868
< 		Object first = result.get(0);
< 		result.add(first);
---
> 		result.add(result.get(0));
804,807c881,882
< 	private List convertPolylineUnits(List polyPts) {
< 		ArrayList result = new ArrayList();
< 		Iterator iter = polyPts.iterator();
< 
---
> 	private List<Point> convertPolylineUnits(List<Point> polyPts) {
> 		List<Point> result = new ArrayList<Point>();
809,811c884
< 
< 		while (iter.hasNext()) {
< 			Point point = (Point) iter.next();
---
> 		for (Point point : polyPts) {
815d887
< 
904,929c976
< 			Rectangle originalBounds = new PrecisionRectangle(new Rectangle(calculateImageRectangle(editParts)));
< 			getMapMode().LPtoDP(originalBounds);
< 			
< 			int deviceMargins = mm.LPtoDP(getImageMargin());
< 			int threshold = useMargins ? deviceMargins : 0; 
< 			double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
< 			
< 			originalBounds.shrink(deviceMargins, deviceMargins);
< 			
< 			if (maxDeviceWidth > threshold) {
< 				xScalingFactor = (maxDeviceWidth  - threshold - threshold)/ (originalBounds.preciseWidth());
< 			}
< 			if (maxDeviceHeight > threshold) {
< 				yScalingFactor = (maxDeviceHeight - threshold - threshold) / (originalBounds.preciseHeight());
< 			}
< 			
< 			double scalingFactor = Math.min(Math.min(xScalingFactor, yScalingFactor), 1);
< 			
< 			int imageWidth = originalBounds.width + threshold + threshold;
< 			int imageHeight = originalBounds.height + threshold + threshold;
< 			
< 			if (scalingFactor < 1) {
< 				imageWidth = (int) Math.round(originalBounds.preciseWidth() * scalingFactor) + threshold + threshold;
< 				imageHeight = (int) Math.round(originalBounds.preciseHeight() * scalingFactor) + threshold + threshold;
< 			}
< 			
---
> 			ConstrainedImageRenderingData data = getConstrainedImageRenderingData(editParts, maxDeviceWidth, maxDeviceHeight, useMargins);
932c979
< 			graphics = setUpGraphics(imageWidth, imageHeight);
---
> 			graphics = setUpGraphics(data.imageWidth, data.imageHeight);
939,940c986,987
< 			graphics.translate(threshold, threshold);
< 			mapModeGraphics.scale(scalingFactor);
---
> 			graphics.translate(data.margin, data.margin);
> 			mapModeGraphics.scale(data.scalingFactor);
942c989
< 			Point location = new PrecisionPoint(originalBounds.preciseX(), originalBounds.preciseY());
---
> 			Point location = new PrecisionPoint(data.imageOriginalBounds.preciseX(), data.imageOriginalBounds.preciseY());
953a1001,1042
> 	class ConstrainedImageRenderingData {
> 		double scalingFactor;
> 		int imageWidth; // in pixels
> 		int imageHeight; // in pixels
> 		Rectangle imageOriginalBounds; // in pixels
> 		int margin; // margins size in pixels
> 	}
> 	
> 	ConstrainedImageRenderingData getConstrainedImageRenderingData(List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
> 		ConstrainedImageRenderingData data = new ConstrainedImageRenderingData();
> 		IMapMode mm = getMapMode();
> 		
> 		data.imageOriginalBounds = new PrecisionRectangle(new Rectangle(calculateImageRectangle(editParts)));
> 		mm.LPtoDP(data.imageOriginalBounds);
> 		
> 		int deviceMargins = mm.LPtoDP(getImageMargin());
> 		data.margin = useMargins ? deviceMargins : 0; 
> 		double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
> 		
> 		data.imageOriginalBounds.shrink(deviceMargins, deviceMargins);
> 		
> 		if (maxDeviceWidth > data.margin) {
> 			xScalingFactor = (maxDeviceWidth  - data.margin - data.margin)/ (data.imageOriginalBounds.preciseWidth());
> 		}
> 		if (maxDeviceHeight > data.margin) {
> 			yScalingFactor = (maxDeviceHeight - data.margin - data.margin) / (data.imageOriginalBounds.preciseHeight());
> 		}
> 		
> 		data.scalingFactor = Math.min(Math.min(xScalingFactor, yScalingFactor), 1);
> 		
> 		data.imageWidth = data.imageOriginalBounds.width + data.margin + data.margin;
> 		data.imageHeight = data.imageOriginalBounds.height + data.margin + data.margin;
> 				
> 		if (data.scalingFactor < 1) {
> 			data.imageWidth = (int) Math.round(data.imageOriginalBounds.preciseWidth() * data.scalingFactor) + data.margin + data.margin;
> 			data.imageHeight = (int) Math.round(data.imageOriginalBounds.preciseHeight() * data.scalingFactor) + data.margin + data.margin;
> 		} else {
> 			data.scalingFactor = 1;
> 		}
> 		return data;
> 	}
> 	
