17d16
< import org.eclipse.emf.codegen.jet.JETEmitter;
19,20c18
< import org.eclipse.emf.common.util.BasicMonitor;
< import org.eclipse.gmf.common.UnexpectedBehaviourException;
---
> import org.eclipse.gmf.common.codegen.ImportAssistant;
22,23d19
< import org.eclipse.gmf.gmfgraph.CustomFigure;
< import org.eclipse.gmf.gmfgraph.DecorationFigure;
25a22,23
> import org.eclipse.gmf.gmfgraph.PolygonDecoration;
> import org.eclipse.gmf.gmfgraph.Polyline;
26a25,26
> import org.eclipse.gmf.gmfgraph.PolylineDecoration;
> import org.eclipse.gmf.gmfgraph.RoundedRectangle;
28,33c28,39
< import org.eclipse.gmf.graphdef.codegen.templates.ConnectionGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.CustomFigureGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.DecorationFigureGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.LabelGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.ShapeAttrsGenerator;
< import org.eclipse.gmf.graphdef.codegen.templates.ShapeGenerator;
---
> import org.eclipse.gmf.graphdef.codegen.templates.FigureAttrGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.FigureChildrenGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.LabelAttrGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.NewFigureGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.PolygonDecorationAttrGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.PolylineAttrGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.PolylineDecorationAttrGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.RoundedRectAttrGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.ShapeAttrGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.TopConnectionGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.TopFigureGenerator;
> import org.eclipse.gmf.graphdef.codegen.templates.TopShapeGenerator;
35c41,43
< import org.eclipse.gmf.internal.graphdef.codegen.NoSuchTemplateException;
---
> import org.eclipse.gmf.internal.graphdef.codegen.HierarchyKeyMap;
> import org.eclipse.gmf.internal.graphdef.codegen.KeyChain;
> import org.eclipse.gmf.internal.graphdef.codegen.KeyMap;
47,48c55,56
< 	private YAEmitterFactory myFactory;
< 	private Dispatcher myDispatcher;
---
> 	private Dispatcher myTopDispatcher;
> 	private Dispatcher myInnerDispatcher;
64,65c72,87
< 		myFactory = new YAEmitterFactory(thisBundle.getEntry("/"), fill(), true, variables, true);
< 		myDispatcher = new DispatcherImpl(myFactory);
---
> 		KeyMap keyMap = new HierarchyKeyMap() {
> 			/*
> 			 * Capture knowledge that we use classes and strings as keys
> 			 */
> 			public KeyChain map(Object key) {
> 				if (key instanceof String) {
> 					return super.map(key);
> 				} else {
> 					return super.map(key.getClass());
> 				}
> 			}
> 		};
> 		YAEmitterFactory topFactory = new YAEmitterFactory(thisBundle.getEntry("/"), fillTopLevel(), true, variables, true);
> 		myTopDispatcher = new DispatcherImpl(topFactory, keyMap);
> 		YAEmitterFactory innerFactory = new YAEmitterFactory(thisBundle.getEntry("/"), fillAttrs(), true, variables, true);
> 		myInnerDispatcher = new DispatcherImpl(innerFactory, keyMap);
75c97,110
< 	private static TemplateRegistry fill() {
---
> 	private static TemplateRegistry fillTopLevel() {
> 		StaticTemplateRegistry tr = new StaticTemplateRegistry();
> 		tr.put(PolylineConnection.class, "/templates/PolylineConnection.javajet", TopConnectionGenerator.class);
> 		tr.put(Shape.class, "/templates/top/Shape.javajet", TopShapeGenerator.class);
> 		tr.put(Figure.class, "/templates/top/Figure.javajet", TopFigureGenerator.class);
> 		return tr;
> 	}
> 
> 	// XXX NOTE, the fact we use "instantiate" and "Children" strings
> 	// helps us to postpone resolution of the next problem (one we make these twwo overridable):
> 	// it's not possible to tell from single dispatcher.dispatch(Figure, args) what's the intention - 
> 	// whether to instantiate, look for children or initialize attributes
> 	// Perhaps, we should have distinct methods in the Dispatcher, or add "hint" as another argument
> 	private static TemplateRegistry fillAttrs() {
77,82c112,126
< 		tr.put(PolylineConnection.class, "/templates/PolylineConnection.javajet", ConnectionGenerator.class);
< 		tr.put(DecorationFigure.class, "/templates/DecorationFigure.javajet", DecorationFigureGenerator.class);
< 		tr.put(Shape.class, "/templates/ConcreteShape.javajet", ShapeGenerator.class);
< 		tr.put(Label.class, "/templates/Label.javajet", LabelGenerator.class);
< 		tr.put(CustomFigure.class, "/templates/CustomFigure.javajet", CustomFigureGenerator.class);
< 		tr.put("ShapeAttrs", "/templates/ShapeAttrs.javajet", ShapeAttrsGenerator.class);
---
> 		tr.put(Figure.class, "/templates/attr/Figure.javajet", FigureAttrGenerator.class);
> 		tr.put(Shape.class, "/templates/attr/Shape.javajet", ShapeAttrGenerator.class);
> 		tr.put(Label.class, "/templates/attr/Label.javajet", LabelAttrGenerator.class);
> 		tr.put(Polyline.class, "/templates/attr/Polyline.javajet", PolylineAttrGenerator.class);
> 		tr.put(RoundedRectangle.class, "/templates/attr/RoundedRectangle.javajet", RoundedRectAttrGenerator.class);
> 		tr.put(PolygonDecoration.class, "/templates/attr/PolygonDecoration.javajet", PolygonDecorationAttrGenerator.class);
> 		tr.put(PolylineDecoration.class, "/templates/attr/PolylineDecoration.javajet", PolylineDecorationAttrGenerator.class);
> 		// instantiation templates - only single one now. FIXME - make it overridable
> 		tr.put("instantiate", "/templates/new/Figure.javajet", NewFigureGenerator.class);
> 		// children templates - only single one now. FIXME - make it overridable
> 		tr.put("Children", "/templates/children/Figure.javajet", FigureChildrenGenerator.class);
> 		// FIXME same template is registered twice
> 		tr.put("Shape", "/templates/attr/Shape.javajet", ShapeAttrGenerator.class);
> 		tr.put("Figure", "/templates/attr/Figure.javajet", FigureAttrGenerator.class);
> 		tr.put("PolylineDecoration", "/templates/attr/PolylineDecoration.javajet", PolylineDecorationAttrGenerator.class);
87,98c131
< 		String res = null;
< 		try {
< 		if (fig instanceof PolylineConnection) {
< 			res = generate(fig, myFactory.acquireEmitter(PolylineConnection.class));
< 		} else if (fig instanceof DecorationFigure) {
< 			res = generate(fig, myFactory.acquireEmitter(DecorationFigure.class));
< 		} else if (fig instanceof Shape) {
< 			res = generate(fig, myFactory.acquireEmitter(Shape.class));
< 		} else if (fig instanceof CustomFigure) {
< 			res = generate(fig, myFactory.acquireEmitter(CustomFigure.class));
< 		} else if (fig instanceof Label) {
< 			res = generate(fig, myFactory.acquireEmitter(Label.class));
---
> 		return go(fig, new NullImportAssistant());
100c133,136
< // TODO: } else if (fig instanceof LabeledContainer) {
---
> 
> 	public String go(Figure fig, ImportAssistant importManager) {
> 		String res = null;
> 		res = myTopDispatcher.dispatch(fig, new Object[] {fig, importManager, myInnerDispatcher});
104,108d139
< 		} catch (UnexpectedBehaviourException ex) {
< 			throw new IllegalStateException(ex);
< 		} catch (NoSuchTemplateException ex) {
< 			throw new IllegalStateException(ex);
< 		}
111,115d141
< 
< 	private String generate(Figure fig, JETEmitter emitter) throws JETException {
< 		Object argument = new Object[] {fig, new NullImportAssistant(), myDispatcher};
< 		return emitter.generate(new BasicMonitor.Printing(System.out), new Object[] {argument});
< 	}
