1,2c1,2
< /*******************************************************************************
<  * Copyright (c) 2006, 2007 Eclipse.org
---
> /*
>  * Copyright (c) 2006, 2008 Borland Software Corporation
8c8,12
<  *******************************************************************************/
---
>  * 
>  * Contributors:
>  *     Artem Tikhomirov (Borland)
>  *     Boris Blajer (Borland) - support for composite resources
>  */
29,31d32
< 		if (hasCachedXtend(fullyQualifiedName)) {
< 			return cachedXtend.get(fullyQualifiedName);
< 		}
33,38c34
< 			final XtendResource loaded = doLoadXtendResource(fullyQualifiedName);
< 			assert loaded != null; // this is the contract of loadXtendResource
< 			if (shouldCache()) {
< 				cachedXtend.put(fullyQualifiedName, loaded);
< 			}
< 			return loaded;
---
> 			return loadXtendThroughCache(fullyQualifiedName);
44c40
< 			handleParserException(fullyQualifiedName, ex);
---
> 			handleParserException(ex);
48a45,56
> 	protected XtendResource loadXtendThroughCache(String qualifiedName) throws IOException, ParserException {
> 		if (hasCachedXtend(qualifiedName)) {
> 			return cachedXtend.get(qualifiedName);
> 		}
> 		final XtendResource loaded = doLoadXtendResource(qualifiedName);
> 		assert loaded != null; // this is the contract of loadXtendResource
> 		if (shouldCache()) {
> 			cachedXtend.put(qualifiedName, loaded);
> 		}
> 		return loaded;
> 	}
> 	
52,64c60
< 		XtendResource[] result = new XtendResource[rs.length];
< 		for (int i = 0; i < rs.length; i++) {
< 			Reader r = rs[i];
< 			assert r != null;
< 			try {
< 				result[i] = loadXtendResource(r, fullyQualifiedName);
< 				assert result[i] != null; // this is the contract of loadXpandResource
< 			} finally {
< 				try {
< 					r.close();
< 				} catch (Exception ex) {/*IGNORE*/}
< 			}
< 		}
---
> 		XtendResource[] result = loadXtendResources(rs, fullyQualifiedName);
72,74d67
< 		if (hasCachedXpand(fullyQualifiedName)) {
< 			return cachedXpand.get(fullyQualifiedName);
< 		}
76,80c69
< 			final XpandResource loaded = doLoadXpandResource(fullyQualifiedName);
< 			if (shouldCache()) {
< 				cachedXpand.put(fullyQualifiedName, loaded);
< 			}
< 			return loaded;
---
> 			return loadXpandThroughCache(fullyQualifiedName);
87c76
< 			handleParserException(fullyQualifiedName, ex);
---
> 			handleParserException(ex);
91a81,91
> 	protected XpandResource loadXpandThroughCache(String qualifiedName) throws IOException, ParserException {
> 		if (hasCachedXpand(qualifiedName)) {
> 			return cachedXpand.get(qualifiedName);
> 		}
> 		final XpandResource loaded = doLoadXpandResource(qualifiedName);
> 		if (shouldCache()) {
> 			cachedXpand.put(qualifiedName, loaded);
> 		}
> 		return loaded;
> 	}
> 
93c93,95
< 		XpandResource[] unadvised = internalLoadXpandResources(fullyQualifiedName);
---
> 		Reader[] rs1 = resolveMultiple(fullyQualifiedName, XpandResource.TEMPLATE_EXTENSION);
> 		assert rs1 != null && rs1.length > 0; // exception should be thrown to indicate issues with resolve
> 		XpandResource[] unadvised = loadXpandResources(rs1, fullyQualifiedName);
97c99,101
< 	    	advices = internalLoadXpandResources(aspectsTemplateName);
---
> 	    	Reader[] rs2 = resolveMultiple(aspectsTemplateName, XpandResource.TEMPLATE_EXTENSION);
> 	    	// XXX relax resolveMultiple to return empty array and use length==0 here instead of exception
> 	    	advices = loadXpandResources(rs2, aspectsTemplateName);
103c107
< 			handleParserException(fullyQualifiedName, ex);
---
> 			handleParserException(ex);
132,138c136,153
< 	private XpandResource[] internalLoadXpandResources(String fullyQualifiedName) throws IOException, ParserException {
< 		Reader[] rs = resolveMultiple(fullyQualifiedName, XpandResource.TEMPLATE_EXTENSION);
< 		assert rs != null && rs.length > 0; // exception should be thrown to indicate issues with resolve
< 		XpandResource[] result = new XpandResource[rs.length];
< 		for (int i = 0; i < rs.length; i++) {
< 			Reader r = rs[i];
< 			assert r != null;
---
> 	protected abstract void handleParserException(ParserException ex);
> 
> 	/**
> 	 * Returns an array of resolutions, in the order from newest to oldest. 
> 	 * This is to enable one template to partially override only a subset of parent templates.
> 	 *  
> 	 * @return never return <code>null</code> or an empty array, throw exception instead
> 	 * @throws IOException in case resource can't be read. Throw {@link java.io.FileNotFoundException} to indicate resource was not found. 
> 	 */
> 	protected abstract Reader[] resolveMultiple(String fullyQualifiedName, String extension) throws IOException;
> 
> 	/**
> 	 * Readers get closed after parse attempt. 
> 	 */
> 	protected XtendResource[] loadXtendResources(Reader[] readers, String fullyQualifiedName) throws IOException, ParserException {
> 		XtendResource[] result = new XtendResource[readers.length];
> 		for (int i = 0; i < readers.length; i++) {
> 			assert readers[i] != null;
140c155
< 				result[i] = loadXpandResource(r, fullyQualifiedName);
---
> 				result[i] = new XtendResourceParser().parse(readers[i], fullyQualifiedName);
144c159
< 					r.close();
---
> 					readers[i].close();
151,154d165
< 	protected void handleParserException(String name, ParserException ex) {
< 		Activator.logWarn(name + ":" + ex.getClass().getName());
< 	}
< 
156,158c167
< 	 * @return never return <code>null</code>, throw exception instead
< 	 * @throws IOException in case resource can't be read. Throw {@link java.io.FileNotFoundException} to indicate resource was not found. 
< 	 * @deprecated use {@link #resolveMultiple(String, String)} instead.
---
> 	 * Readers get closed after parse attempt.
160,172c169,179
< 	@Deprecated
< 	protected abstract Reader resolve(String fullyQualifiedName, String extension) throws IOException;
< 
< 	/**
< 	 * Returns an array of resolutions, in the order from newest to oldest. 
< 	 * This is to enable one template to partially override only a subset of parent templates. 
< 	 * By default, returns an array consisting of one Reader, the one that {@link #resolve(String, String)} returns.
< 	 * Subclasses should override.
< 	 * @return never return <code>null</code> or an empty array, throw exception instead
< 	 * @throws IOException in case resource can't be read. Throw {@link java.io.FileNotFoundException} to indicate resource was not found. 
< 	 */
< 	protected Reader[] resolveMultiple(String fullyQualifiedName, String extension) throws IOException {
< 		return new Reader[] {resolve(fullyQualifiedName, extension)};
---
> 	protected XpandResource[] loadXpandResources(Reader[] readers, String fullyQualifiedName) throws IOException, ParserException {
> 		XpandResource[] result = new XpandResource[readers.length];
> 		for (int i = 0; i < readers.length; i++) {
> 			assert readers[i] != null;
> 			try {
> 				result[i] = new XpandResourceParser().parse(readers[i], fullyQualifiedName);
> 				assert result[i] != null; // this is the contract of parse
> 			} finally {
> 				try {
> 					readers[i].close();
> 				} catch (Exception ex) {/*IGNORE*/}
174,176d180
< 
< 	protected XtendResource loadXtendResource(Reader reader, String fullyQualifiedName) throws IOException, ParserException {
< 		return new XtendResourceParser().parse(reader, fullyQualifiedName);
178,180c182
< 
< 	protected XpandResource loadXpandResource(Reader reader, String fullyQualifiedName) throws IOException, ParserException {
< 		return new XpandResourceParser().parse(reader, fullyQualifiedName);
---
> 		return result;
