13a14,16
> import java.io.File;
> import java.util.Arrays;
> import java.util.HashMap;
15a19
> import java.util.Map;
18,19d21
< import org.eclipse.core.resources.IPathVariableChangeEvent;
< import org.eclipse.core.resources.IPathVariableChangeListener;
21a24
> import org.eclipse.core.runtime.CoreException;
23c26
< import org.eclipse.emf.common.CommonPlugin;
---
> import org.eclipse.core.runtime.Path;
27a31
> import org.eclipse.jface.dialogs.ErrorDialog;
28a33,35
> import org.eclipse.jface.viewers.CheckStateChangedEvent;
> import org.eclipse.jface.viewers.CheckboxTableViewer;
> import org.eclipse.jface.viewers.ICheckStateListener;
30a38
> import org.eclipse.jface.viewers.ISelection;
39a48
> import org.eclipse.osgi.util.NLS;
42,45c51
< import org.eclipse.swt.events.ControlAdapter;
< import org.eclipse.swt.events.ControlEvent;
< import org.eclipse.swt.events.MouseEvent;
< import org.eclipse.swt.events.MouseTrackAdapter;
---
> import org.eclipse.swt.events.SelectionAdapter;
47d52
< import org.eclipse.swt.events.SelectionListener;
50d54
< import org.eclipse.swt.graphics.Point;
57,58c61
< import org.eclipse.swt.widgets.TableColumn;
< import org.eclipse.swt.widgets.TableItem;
---
> import org.eclipse.ui.ISharedImages;
67c70
<  * <P>
---
>  * <p>
69a73,77
>  * </p>
>  * <p>
>  * This class may be instantiated by clients, but is not intended to be
>  * subclassed.
>  * </p>
71a80
>  * @autor Christian W. Damus (cdamus)
74c83,89
< 	extends PreferencePage implements IWorkbenchPreferencePage {
---
>     extends PreferencePage
>     implements IWorkbenchPreferencePage {
> 
>     private static final String NAME_ATTRIBUTE = "name"; //$NON-NLS-1$
> 
>     private IPathVariableManager pathVariableManager = ResourcesPlugin
>         .getWorkspace().getPathVariableManager();
76,78d90
< 	private ScrolledComposite referencedPathVariablesScroll;
< 	private TableViewer referencedPathVariables;
< 	private StringsContentProvider referencedPathVariablesContent;
80,85c92,110
< 	private TableViewer pathVariables;
< 	private StringsContentProvider pathVariablesContent;
< 	private Button add;
< 	private Button remove;
< 	private IPathVariableChangeListener pathVariableChangeListener;
< 	private boolean disposed = true;
---
> 
>     private CheckboxTableViewer pathVariables;
> 
>     private PathVariableContentProvider pathVariablesContent;
> 
>     private Button newVariable;
> 
>     private Button editVariable;
> 
>     private Button removeVariable;
> 
>     /** Path variable changes since last time the Apply button was pressed. */
>     private Map variableChanges = new HashMap();
> 
>     private Object addedToken = new Object();
> 
>     private Object changedToken = new Object();
> 
>     private Object removedToken = new Object();
96,100c121
< 		composite.setLayout(new GridLayout(3, false));
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.horizontalSpan = 2;
< 		composite.setLayoutData(gridData);
---
>         composite.setLayout(new GridLayout(2, false));
105c126,127
<             "org.eclipse.ui.preferencePages.LinkedResources", EMFUIMessages.PathmapsPreferencePage_mainDescription, //$NON-NLS-1$
---
>             "org.eclipse.ui.preferencePages.LinkedResources", //$NON-NLS-1$
>             EMFUIMessages.PathmapsPreferencePage_mainDescription,
107c129,130
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
---
>         gridData = new GridData(GridData.FILL_HORIZONTAL
>             | GridData.FILL_VERTICAL);
110c133
< 		gridData.horizontalSpan = 3;
---
>         gridData.horizontalSpan = 2;
113,122c136,138
< 		Composite pathVariablesComposite = new Composite(composite, SWT.NONE);
< 		pathVariablesComposite.setLayout(new GridLayout(1, false));
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = true;
< 		gridData.horizontalSpan = 1;
< 		pathVariablesComposite.setLayoutData(gridData);
< 		
< 		Label pathVariablesLabel = new Label(pathVariablesComposite, SWT.LEFT);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
---
>         Label pathVariablesLabel = new Label(composite, SWT.LEFT);
>         gridData = new GridData(GridData.FILL_HORIZONTAL
>             | GridData.FILL_VERTICAL);
128c144,145
< 		pathVariablesLabel.setText(EMFUIMessages.PathmapsPreferencePage_availablePathVariables);
---
>         pathVariablesLabel
>             .setText(EMFUIMessages.PathmapsPreferencePage_availablePathVariables);
130,131c147,148
< 		pathVariablesScroll = new ScrolledComposite(
< 				pathVariablesComposite, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
---
>         pathVariablesScroll = new ScrolledComposite(composite, SWT.BORDER
>             | SWT.H_SCROLL | SWT.V_SCROLL);
134c151,152
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
---
>         gridData = new GridData(GridData.FILL_HORIZONTAL
>             | GridData.FILL_VERTICAL);
139c157,159
< 		pathVariables = new TableViewer(pathVariablesScroll, SWT.MULTI);
---
> 
>         pathVariables = CheckboxTableViewer.newCheckList(pathVariablesScroll,
>             SWT.MULTI);
142,150c162
< 		TableColumn column = new TableColumn(pathVariables.getTable(), SWT.LEFT);
< 		column.setMoveable(false);
< 		column.setResizable(false);
< 		pathVariables.getTable().addControlListener(new ControlAdapter() {
< 			public void controlResized(ControlEvent e) {
< 				pathVariables.getTable().getColumn(0).setWidth(
< 						pathVariables.getTable().getClientArea().width);
< 			}});
< 		pathVariablesContent = new StringsContentProvider();
---
>         pathVariablesContent = new PathVariableContentProvider();
152,153c164,165
< 		pathVariables.setLabelProvider(new StringsLabelProvider());
< 		pathVariables.setComparator(new StringsViewerComparator());
---
>         pathVariables.setLabelProvider(new PathVariableLabelProvider());
>         pathVariables.setComparator(new PathVariableViewerComparator());
157,185d168
< 		add = new Button(buttonComposite, SWT.CENTER);
< 		add.setText(EMFUIMessages.PathmapsPreferencePage_addChevron);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		gridData.horizontalSpan = 1;
< 		add.setLayoutData(gridData);
< 		Button addAll = new Button(buttonComposite, SWT.CENTER);
< 		addAll.setText(EMFUIMessages.PathmapsPreferencePage_addAllChevron);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		addAll.setLayoutData(gridData);
< 		remove = new Button(buttonComposite,SWT.CENTER);
< 		remove.setText(EMFUIMessages.PathmapsPreferencePage_removeChevron);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		gridData.horizontalSpan = 1;
< 		gridData.verticalIndent = 10;
< 		remove.setLayoutData(gridData);
< 		Button removeAll = new Button(buttonComposite, SWT.CENTER);
< 		removeAll.setText(EMFUIMessages.PathmapsPreferencePage_removeAllChevron);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		gridData.horizontalSpan=1;
< 		removeAll.setLayoutData(gridData);
< 		
189a173
>         gridData.verticalAlignment = GridData.BEGINNING;
192,198c176,187
< 		Composite referencedPathVariablesComposite = new Composite(composite, SWT.NONE);
< 		referencedPathVariablesComposite.setLayout(new GridLayout(1, false));
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = true;
< 		gridData.horizontalSpan = 1;
< 		referencedPathVariablesComposite.setLayoutData(gridData);
---
>         newVariable = new Button(buttonComposite, SWT.CENTER);
>         newVariable.setText(EMFUIMessages.PathmapsPreferencePage_newVariable);
>         setButtonLayoutData(newVariable);
> 
>         editVariable = new Button(buttonComposite, SWT.CENTER);
>         editVariable.setText(EMFUIMessages.PathmapsPreferencePage_editVariable);
>         setButtonLayoutData(editVariable);
> 
>         removeVariable = new Button(buttonComposite, SWT.CENTER);
>         removeVariable
>             .setText(EMFUIMessages.PathmapsPreferencePage_removeVariable);
>         setButtonLayoutData(removeVariable);
200,207c189,190
< 		Label referencedPathVariablesLabel = new Label(referencedPathVariablesComposite, SWT.LEFT);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = false;
< 		gridData.horizontalSpan = 1;
< 		gridData.verticalIndent = 20;
< 		referencedPathVariablesLabel.setLayoutData(gridData);
< 		referencedPathVariablesLabel.setText(EMFUIMessages.PathmapsPreferencePage_pathVariablesUsedInModeling);
---
>         pathVariables
>             .addSelectionChangedListener(new ISelectionChangedListener() {
209,247c192,193
< 		referencedPathVariablesScroll = new ScrolledComposite(
< 				referencedPathVariablesComposite, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
< 		referencedPathVariablesScroll.setExpandHorizontal(true);
< 		referencedPathVariablesScroll.setExpandVertical(true);
< 		gridData = new GridData(GridData.FILL_HORIZONTAL | GridData.FILL_VERTICAL);
< 		gridData.grabExcessHorizontalSpace = true;
< 		gridData.grabExcessVerticalSpace = true;
< 		gridData.horizontalSpan = 1;
< 		referencedPathVariablesScroll.setLayoutData(gridData);
< 		referencedPathVariables = new TableViewer(referencedPathVariablesScroll, SWT.MULTI);
< 		referencedPathVariablesScroll.setContent(referencedPathVariables.getTable());
< 		
< 		column = new TableColumn(referencedPathVariables.getTable(), SWT.LEFT);
< 		column.setMoveable(false);
< 		column.setResizable(false);
< 		referencedPathVariables.getTable().addControlListener(new ControlAdapter() {
< 			public void controlResized(ControlEvent e) {
< 				referencedPathVariables.getTable().getColumn(0).setWidth(
< 						referencedPathVariables.getTable().getClientArea().width);
< 			}});
< 		referencedPathVariablesContent = new StringsContentProvider();
< 		referencedPathVariables.setContentProvider(referencedPathVariablesContent);
< 		referencedPathVariables.setLabelProvider(new StringsLabelProvider(true));
< 		referencedPathVariables.setComparator(new StringsViewerComparator());
< 		
< 		// adjust the scroll bars whenever the preference page is resized
< 		composite.addControlListener(new ControlAdapter() {
< 			public void controlResized(ControlEvent e) {
< 				adjustScrollpanes();
< 			}});
< 		
< 		pathVariables.getTable().addMouseTrackListener(new MouseTrackAdapter() {
< 			public void mouseHover(MouseEvent e) {
< 				TableItem item = pathVariables.getTable().getItem(new Point(e.x, e.y));
< 				String tip = null;
< 				
< 				if (item != null) {
< 					String var = item.getText(0);
< 					tip = getValue(var, false);
---
>                 public void selectionChanged(SelectionChangedEvent event) {
>                     pathVariableSelected(event.getSelection());
248a195
>             });
250,257c197
< 				pathVariables.getTable().setToolTipText(tip);
< 			}});
< 		
< 		pathVariables.addSelectionChangedListener(new ISelectionChangedListener() {
< 			public void selectionChanged(SelectionChangedEvent event) {
< 				if (!event.getSelection().isEmpty()) { // prevent oscillation
< 					referencedPathVariables.setSelection(new StructuredSelection());
< 					remove.setEnabled(true);
---
>         pathVariables.addCheckStateListener(new ICheckStateListener() {
259,263c199,201
< 					if (!validateAdditions((IStructuredSelection) event.getSelection(), true)) {
< 						add.setEnabled(false);
< 					} else {
< 						setMessage(null);
< 						add.setEnabled(true);
---
>             public void checkStateChanged(CheckStateChangedEvent event) {
>                 pathVariableChecked(event, (PathVariableEntry) event
>                     .getElement());
264a203,208
>         });
> 
>         newVariable.addSelectionListener(new SelectionAdapter() {
> 
>             public void widgetSelected(SelectionEvent e) {
>                 addPathVariable();
265a210,215
>         });
> 
>         editVariable.addSelectionListener(new SelectionAdapter() {
> 
>             public void widgetSelected(SelectionEvent e) {
>                 editPathVariable(pathVariables.getSelection());
269,273c219
< 		referencedPathVariables.getTable().addMouseTrackListener(new MouseTrackAdapter() {
< 			public void mouseHover(MouseEvent e) {
< 				TableItem item = referencedPathVariables.getTable().getItem(
< 						new Point(e.x, e.y));
< 				String tip = null;
---
>         removeVariable.addSelectionListener(new SelectionAdapter() {
275,277c221,222
< 				if (item != null) {
< 					String var = item.getText(0);
< 					tip = getValue(var, true);
---
>             public void widgetSelected(SelectionEvent e) {
>                 removePathVariable(pathVariables.getSelection());
278a224,226
>         });
> 
>         initializeContents();
280,281c228
< 				referencedPathVariables.getTable().setToolTipText(tip);
< 			}});
---
>         applyDialogFont(composite);
283,287c230,233
< 		referencedPathVariables.addSelectionChangedListener(new ISelectionChangedListener() {
< 			public void selectionChanged(SelectionChangedEvent event) {
< 				if (!event.getSelection().isEmpty()) { // prevent oscillation
< 					add.setEnabled(true);
< 					pathVariables.setSelection(new StructuredSelection());
---
>         pathVariableSelected(pathVariables.getSelection());
> 
>         return composite;
>     }
289,290c235,255
< 					if (!validateRemovals((IStructuredSelection) event.getSelection(), true)) {
< 						remove.setEnabled(false);
---
>     /**
>      * Responds to the user's gesture to either check or uncheck the specified
>      * <code>entry</code> in the path variables list. This may, according to
>      * the status of the path variable entry, result in the user's change being
>      * reverted (e.g., in the case of attempting to uncheck a variable
>      * registered on the extension point). This works around the inability in
>      * SWT to disable the checkbox of an item in a check-table (see <a
>      * href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=76509">bug 76509</a>
>      * for details).
>      * 
>      * @param event
>      *            the (un)check event
>      * @param entry
>      *            the path variable entry that was (un)checked
>      */
>     private void pathVariableChecked(CheckStateChangedEvent event,
>             PathVariableEntry entry) {
>         if (event.getChecked()) {
>             // validate the check
>             if (validateSelection(entry, false)) {
>                 entry.setSelected(true);
292,293c257,264
< 						setMessage(null);
< 						remove.setEnabled(true);
---
>                 event.getCheckable().setChecked(entry, false);
>             }
>         } else {
>             // validate the uncheck
>             if (validateDeselection(entry, false)) {
>                 entry.setSelected(false);
>             } else {
>                 event.getCheckable().setChecked(entry, true);
297d267
< 		});
299,302c269,277
< 		add.addSelectionListener(new SelectionListener() {
< 			public void widgetSelected(SelectionEvent e) {
< 				IStructuredSelection selection =
< 					(IStructuredSelection) pathVariables.getSelection();
---
>     /**
>      * Handles the selection of zero or more path variables in the list,
>      * updating the enablement state of the "Edit..." and "Remove" buttons.
>      * 
>      * @param selection
>      *            the new path variables list selection
>      */
>     private void pathVariableSelected(ISelection selection) {
>         IStructuredSelection ssel = (IStructuredSelection) selection;
304,309c279,280
< 				for (Iterator iter = selection.iterator(); iter.hasNext();) {
< 					String name = (String) iter.next();
< 					pathVariablesContent.remove(name);
< 					referencedPathVariablesContent.add(name);
< 					adjustScrollpanes();
< 				}
---
>         editVariable.setEnabled(validateEdit(ssel, false));
>         removeVariable.setEnabled(validateRemove(ssel, false));
312,313c283,300
< 			public void widgetDefaultSelected(SelectionEvent e) {
< 				// No action is necessary
---
>     /**
>      * Updates the map of pending path variable changes to indicate that the
>      * specified variable has been added by the user.
>      * 
>      * @param variableName
>      *            the name of the added variable
>      */
>     private void markAdded(String variableName) {
>         Object currentChange = variableChanges.get(variableName);
> 
>         if (currentChange == removedToken) {
>             // if we previously removed this variable's value, then it will
>             // appear to be a change when we sync on apply
>             variableChanges.put(variableName, changedToken);
>         } else if (currentChange != changedToken) {
>             // shouldn't have been a "changed" if we thought we were adding
>             variableChanges.put(variableName, addedToken);
>         }
315d301
< 		});
317,319c303,313
< 		addAll.addSelectionListener(new SelectionListener() {
< 			public void widgetDefaultSelected(SelectionEvent e) {
< 				// No action necessary
---
>     /**
>      * Queries whether the specified path variable has an add change pending, to
>      * be applied when the OK/Apply button is pressed.
>      * 
>      * @param variableName
>      *            the path variable name
>      * @return <code>true</code> if the variable has a pending change that is
>      *         an add; <code>false</code>, otherwise
>      */
>     boolean isAdded(String variableName) {
>         return variableChanges.get(variableName) == addedToken;
322,323c316,324
< 			public void widgetSelected(SelectionEvent e) {
< 				Object[] items = pathVariablesContent.getElements(null);
---
>     /**
>      * Updates the map of pending path variable changes to indicate that the
>      * specified variable has been removed by the user.
>      * 
>      * @param variableName
>      *            the name of the removed variable
>      */
>     private void markRemoved(String variableName) {
>         Object currentChange = variableChanges.get(variableName);
325,330c326,330
< 				for (int i=items.length - 1; i >= 0; i--) {
< 					if (validateAdditions(new StructuredSelection(items[i]), false)) {
< 						String name = (String) items[i];
< 						pathVariablesContent.remove(name);
< 						referencedPathVariablesContent.add(name);
< 						adjustScrollpanes();
---
>         if (currentChange == addedToken) {
>             // it was added since the last apply? Just forget about it, then
>             variableChanges.remove(variableName);
>         } else {
>             variableChanges.put(variableName, removedToken);
332a333,344
> 
>     /**
>      * Queries whether the specified path variable has a remove change pending,
>      * to be applied when the OK/Apply button is pressed.
>      * 
>      * @param variableName
>      *            the path variable name
>      * @return <code>true</code> if the variable has a pending change that is
>      *         a removal; <code>false</code>, otherwise
>      */
>     boolean isRemoved(String variableName) {
>         return variableChanges.get(variableName) == removedToken;
334d345
< 		});
336,339c347,355
< 		remove.addSelectionListener(new SelectionListener() {
< 			public void widgetSelected(SelectionEvent e) {
< 				IStructuredSelection selection =
< 					(IStructuredSelection) referencedPathVariables.getSelection();
---
>     /**
>      * Updates the map of pending path variable changes to indicate that the
>      * specified variable's value has been changed by the user.
>      * 
>      * @param variableName
>      *            the name of the changed variable
>      */
>     private void markChanged(String variableName) {
>         Object currentChange = variableChanges.get(variableName);
341,345c357,361
< 				for (Iterator iter = selection.iterator(); iter.hasNext();) {
< 					String name = (String) iter.next();
< 					referencedPathVariablesContent.remove(name);
< 					pathVariablesContent.add(name);
< 					adjustScrollpanes();
---
>         if (currentChange == addedToken) {
>             // do nothing in this case. If it was added, changing it doesn't
>             // change the fact that it's a new variable
>         } else {
>             variableChanges.put(variableName, changedToken);
349,350c365,375
< 			public void widgetDefaultSelected(SelectionEvent e) {
< 				// No action is necessary
---
>     /**
>      * Queries whether the specified path variable has a change of value
>      * pending, to be applied when the OK/Apply button is pressed.
>      * 
>      * @param variableName
>      *            the path variable name
>      * @return <code>true</code> if the variable has a pending change that is
>      *         a value change; <code>false</code>, otherwise
>      */
>     boolean isChanged(String variableName) {
>         return variableChanges.get(variableName) == changedToken;
352d376
< 		});
354,356c378,397
< 		removeAll.addSelectionListener(new SelectionListener() {
< 			public void widgetDefaultSelected(SelectionEvent e) {
< 				// No action is necessary
---
>     /**
>      * Queries whether the current pending path variables (not yet applied to
>      * the workspace and GMF path map manager) has a variable referencing the
>      * specified location. Note that this does not consider path variables that
>      * are pending removal or others that are currently defined in the workspace
>      * and/or GMF that are not visible.
>      * 
>      * @param location
>      *            a location
>      * @return <code>true</code> if any of the path variables showing in the
>      *         preference page has the specified location; <code>false</code>,
>      *         otherwise
>      */
>     boolean isLocationDefined(IPath location) {
>         for (Iterator iter = pathVariablesContent.entries.iterator(); iter
>             .hasNext();) {
>             if (location.equals(((PathVariableEntry) iter.next())
>                 .getLocationPath())) {
>                 return true;
>             }
359,367c400
< 			public void widgetSelected(SelectionEvent e) {
< 				Object[] items = referencedPathVariablesContent.getElements(null);
< 				
< 				for (int i=items.length - 1; i >= 0; i--) {
< 					if (validateRemovals(new StructuredSelection(items[i]), false)) {
< 						String name = (String) items[i];
< 						referencedPathVariablesContent.remove(name);
< 						pathVariablesContent.add(name);
< 						adjustScrollpanes();
---
>         return false;
368a402,424
> 
>     /**
>      * Handles the pushing of the "New..." button, to create a new path map
>      * variable.
>      */
>     private void addPathVariable() {
>         NewPathVariableDialog dlg = NewPathVariableDialog.openNew(this);
>         if (dlg != null) {
>             String name = dlg.getVariableName();
>             IPath location = dlg.getVariableLocation();
> 
>             // prepare data for synchronization on apply
>             markAdded(name);
> 
>             // by default, check the variable (if the user created it in this
>             // pref page, assume that it should be used for GMF modeling)
>             PathVariableEntry entry = new PathVariableEntry(name, location);
>             entry.setSelected(true);
>             pathVariablesContent.add(entry);
>             pathVariables.setChecked(entry, true);
> 
>             // select the new path variable
>             pathVariables.setSelection(new StructuredSelection(entry));
371d426
< 		});
373c428,437
< 		initializeContents();
---
>     /**
>      * Handles the pushing of the "Edit..." button, to edit the path variable
>      * contained in the specified <code>selection</code>.
>      * 
>      * @param selection
>      *            the current selection in the path variables list (should
>      *            contain a single {@link PathVariableEntry})
>      */
>     private void editPathVariable(ISelection selection) {
>         PathVariableEntry entry = null;
375,383c439,443
< 		// In case of any changes to the path variables, we will refresh ourselves to show
< 		//  the up-to-date information.
< 		pathVariableChangeListener = new IPathVariableChangeListener() {
< 			public void pathVariableChanged(IPathVariableChangeEvent event) {
< 				referencedPathVariables.getTable().getDisplay().asyncExec(new Runnable() {
< 					public void run() {
< 						if (!PathmapsPreferencePage.this.disposed) {
< 							performDefaults();
< 						}
---
>         if (selection instanceof IStructuredSelection) {
>             IStructuredSelection ssel = (IStructuredSelection) selection;
> 
>             if (!ssel.isEmpty()) {
>                 entry = (PathVariableEntry) ssel.getFirstElement();
385d444
< 				});
387,388d445
< 		};
< 		ResourcesPlugin.getWorkspace().getPathVariableManager().addChangeListener(pathVariableChangeListener);
390c447,450
< 		disposed = false;
---
>         if (entry != null) {
>             String oldName = entry.getName();
>             NewPathVariableDialog dlg = NewPathVariableDialog.openEdit(this,
>                 oldName, entry.getLocation());
392c452,455
< 		applyDialogFont(composite);
---
>             if (dlg != null) {
>                 String newName = dlg.getVariableName();
>                 IPath newLocation = dlg.getVariableLocation();
>                 boolean nameChanged = !oldName.equals(newName);
394c457,466
< 		return composite;
---
>                 if (nameChanged) {
>                     // changing the name is like removing the old name
>                     // and adding the new name
> 
>                     // prepare data for synchronization on apply
>                     markAdded(newName);
>                     markRemoved(oldName);
>                 } else {
>                     // prepare data for synchronization on apply
>                     markChanged(oldName);
397,414c469,470
< 	private void adjustScrollpanes() {
< 		pathVariablesScroll.setMinSize(
< 				pathVariables.getTable().computeSize(SWT.DEFAULT, SWT.DEFAULT));
< 		pathVariablesScroll.layout();
< 		referencedPathVariablesScroll.setMinSize(
< 				referencedPathVariables.getTable().computeSize(SWT.DEFAULT, SWT.DEFAULT));
< 		referencedPathVariablesScroll.layout();
< 	}
< 	
< 	private String getValue(String pathVariable, boolean includeRegistered) {
< 		String result = null;
< 		
< 		if (includeRegistered && PathmapManager.isRegisteredPathVariable(pathVariable)) {
< 			String path = PathmapManager.getRegisteredValue(pathVariable);
< 			
< 			if (path != null) {
< 				URI uri = URI.createURI(path);
< 				uri = CommonPlugin.resolve(uri);
---
>                 entry.setName(newName);
>                 entry.setLocation(newLocation);
416,419c472,476
< 				if (uri.isFile()) {
< 					path = uri.toFileString();
< 				} else {
< 					path = uri.toString();
---
>                 pathVariables.update(entry,
>                     nameChanged ? new String[] {NAME_ATTRIBUTE}
>                         : null);
>             }
>         }
422c479,495
< 				result = path;
---
>     /**
>      * Handles the pushing of the "Remove" button, to remove the path
>      * variable(s) contained in the specified <code>selection</code>.
>      * 
>      * @param selection
>      *            the current selection in the path variables list (should
>      *            contain one or more {@link PathVariableEntry}s of which none
>      *            is registered on the extension point)
>      */
>     private void removePathVariable(ISelection selection) {
>         Iterator entries = null;
> 
>         if (selection instanceof IStructuredSelection) {
>             IStructuredSelection ssel = (IStructuredSelection) selection;
> 
>             if (!ssel.isEmpty()) {
>                 entries = ssel.iterator();
424,426c497,502
< 		} else {
< 			IPathVariableManager pathVarMgr =
< 				ResourcesPlugin.getWorkspace().getPathVariableManager();
---
>         }
> 
>         if (entries != null) {
>             while (entries.hasNext()) {
>                 PathVariableEntry entry = (PathVariableEntry) entries.next();
>                 String name = entry.getName();
428c504,505
< 			IPath path = pathVarMgr.getValue(pathVariable);
---
>                 // prepare data for synchronization on apply
>                 markRemoved(name);
430,431c507,508
< 			if (path != null) {
< 				result = path.toOSString();
---
>                 pathVariablesContent.remove(entry);
>             }
435c512,532
< 		return result;
---
>     /**
>      * Validates an attempt to check a previously unchecked path variable in the
>      * list, optionally showing an error explaining the reason why this is not
>      * permitted.
>      * 
>      * @param entry
>      *            a path variable that the user attempted to check
>      * @param showError
>      *            whether to show any potential error message in the title area
>      * @return whether the checking of this variable is permitted
>      */
>     private boolean validateSelection(PathVariableEntry entry, boolean showError) {
>         String name = entry.getName();
> 
>         if (!PathmapManager.isCompatiblePathVariable(name)) {
>             if (showError) {
>                 setMessage(
>                     EMFUIMessages.PathmapsPreferencePage_incompatiblePathVariableErrorMessage,
>                     ERROR);
>             }
>             return false;
438,439c535,540
< 	private boolean validateAdditions(IStructuredSelection selection, boolean showError) {
< 		if (selection.isEmpty())
---
>         if (PathmapManager.isRegisteredPathVariable(name)) {
>             if (showError) {
>                 setMessage(
>                     EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
>                     ERROR);
>             }
440a542
>         }
442,443c544,545
< 		for (Iterator iter = selection.iterator(); iter.hasNext();) {
< 			String name = (String) iter.next();
---
>         return true;
>     }
445c547,560
< 			if (!PathmapManager.isCompatiblePathVariable(name)) {
---
>     /**
>      * Validates an attempt to uncheck a previously checked path variable in the
>      * list, optionally showing an error explaining the reason why this is not
>      * permitted.
>      * 
>      * @param entry
>      *            a path variable that the user attempted to uncheck
>      * @param showError
>      *            whether to show any potential error message in the title area
>      * @return whether the unchecking of this variable is permitted
>      */
>     private boolean validateDeselection(PathVariableEntry entry,
>             boolean showError) {
>         if (entry.isRequired()) {
447c562,564
< 					setMessage(EMFUIMessages.PathmapsPreferencePage_incompatiblePathVariableErrorMessage,ERROR);
---
>                 setMessage(
>                     EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
>                     ERROR);
451a569,591
>         return true;
>     }
> 
>     /**
>      * Queries whether it is permitted to edit the specified
>      * <code>selection</code> of path variables. Editing is only permitted for
>      * a single selection that is not a registered path variable.
>      * 
>      * @param selection
>      *            the current selection in the path variables list
>      * @param showError
>      *            whether to show any potential error message in the title area
>      * @return whether the editing of this selection is permitted
>      */
>     private boolean validateEdit(IStructuredSelection selection,
>             boolean showError) {
>         if (selection.isEmpty() || (selection.size() > 1)) {
>             return false;
>         }
> 
>         String name = ((PathVariableEntry) selection.getFirstElement())
>             .getName();
> 
454c594,596
< 					setMessage(EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,ERROR);
---
>                 setMessage(
>                     EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
>                     ERROR);
455a598
> 
458c601
< 		}
---
> 
462,463c605,619
< 	private boolean validateRemovals(IStructuredSelection selection, boolean showError) {
< 		if (selection.isEmpty())
---
>     /**
>      * Queries whether it is permitted to remove the specified
>      * <code>selection</code> of path variables. Removal is only permitted
>      * when the selection is not empty and does not contain any registered path
>      * variable.
>      * 
>      * @param selection
>      *            the current selection in the path variables list
>      * @param showError
>      *            whether to show any potential error message in the title area
>      * @return whether the editing of this selection is permitted
>      */
>     private boolean validateRemove(IStructuredSelection selection,
>             boolean showError) {
>         if (selection.isEmpty()) {
464a621
>         }
467c624
< 			String name = (String) iter.next();
---
>             String name = ((PathVariableEntry) iter.next()).getName();
471c628,630
< 					setMessage(EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,ERROR);
---
>                     setMessage(
>                         EMFUIMessages.PathmapsPreferencePage_registeredPathVariableErrorMessage,
>                         ERROR);
472a632
> 
475a636
> 
478a640,643
>     /**
>      * Loads the contents of the Path Variables list, additionally setting the
>      * check state of each variable.
>      */
481,482d645
< 		add.setEnabled(true);
< 		remove.setEnabled(true);
484c647
< 		referencedPathVariables.setInput(new HashSet(PathmapManager.getAllPathVariables()));
---
>         variableChanges.clear();
488,492c651,694
< 		Set available = new HashSet();
< 		String[] pathVariableNames = ResourcesPlugin.getWorkspace().getPathVariableManager().getPathVariableNames();
< 		for (int i=0; i<pathVariableNames.length; i++) {
< 			if (!currentVariables.contains(pathVariableNames[i])) {
< 				available.add(pathVariableNames[i]);
---
>         Set allVariables = new HashSet();
>         Set checkedVariables = new HashSet();
> 
>         Set pathVariableNames = new HashSet();
>         pathVariableNames.addAll(Arrays.asList(pathVariableManager
>             .getPathVariableNames()));
>         pathVariableNames.addAll(PathmapManager.getAllPathVariables());
> 
>         for (Iterator iter = pathVariableNames.iterator(); iter.hasNext();) {
>             String name = (String) iter.next();
>             PathVariableEntry entry;
> 
>             if (PathmapManager.isRegisteredPathVariable(name)) {
>                 String value = PathmapManager.getRegisteredValue(name);
> 
>                 try {
>                     URI uri = URI.createURI(value);
> 
>                     if (uri.isFile()) {
>                         // show the user a familiar file system path instead
>                         // of a URI
>                         value = uri.toFileString();
>                     }
>                 } catch (RuntimeException e) {
>                     // the value is not a valid URI. Nothing for us to
>                     // do; that is a problem for the plug-in developer
>                     // who registered this path map. We'll show the
>                     // value as is
>                 }
> 
>                 entry = new PathVariableEntry(name, value);
>                 checkedVariables.add(entry);
>                 allVariables.add(entry);
>             } else if (PathmapManager.isCompatiblePathVariable(name)) {
> 
>                 entry = new PathVariableEntry(name, pathVariableManager
>                     .getValue(name));
> 
>                 if (currentVariables.contains(entry.getName())) {
>                     checkedVariables.add(entry);
>                     entry.setSelected(true);
>                 }
> 
>                 allVariables.add(entry);
496c698,699
< 		pathVariables.setInput(available);
---
>         pathVariables.setInput(allVariables);
>         pathVariables.setCheckedElements(checkedVariables.toArray());
507a711,715
>     /**
>      * Applies the current check state of every path variable to the GMF
>      * {@link PathmapManager}'s list of path variable references and saves the
>      * preference store.
>      */
509,512c717,727
< 		Object[] nonReferencedPathVariables = pathVariablesContent.getElements(null);
< 		for (int i=0; i<nonReferencedPathVariables.length; i++) {
< 			String variableName = (String) nonReferencedPathVariables[i];
< 			PathmapManager.removePathVariableReference(variableName);
---
>         Set currentVariables = PathmapManager.getPathVariableReferences();
> 
>         try {
>             // first, process the removed workspace path variables
>             for (Iterator iter = variableChanges.keySet().iterator(); iter
>                 .hasNext();) {
>                 String name = (String) iter.next();
> 
>                 if (isRemoved(name)) {
>                     if (pathVariableManager.isDefined(name)) {
>                         pathVariableManager.setValue(name, null);
515,518c730
< 		Set currentVariables = PathmapManager.getAllPathVariables();
< 		Object[] variablesToReference = referencedPathVariablesContent.getElements(null);
< 		for (int i=0; i<variablesToReference.length; i++) {
< 			String variableName = (String) variablesToReference[i];
---
>                     PathmapManager.removePathVariableReference(name);
520,521c732
< 			if (!currentVariables.contains(variableName)) {
< 				PathmapManager.addPathVariableReference(variableName);
---
>                     iter.remove(); // successfully processed this change
525c736,741
< 		PathmapManager.updatePreferenceStore();
---
>             // next, process the current set of path variable references to
>             // add/remove them according to the user's preferences
>             Object[] variables = pathVariablesContent.getElements(null);
>             for (int i = 0; i < variables.length; i++) {
>                 PathVariableEntry entry = (PathVariableEntry) variables[i];
>                 String name = entry.getName();
527c743,750
< 		return true;
---
>                 if (isChanged(name) || isAdded(name)
>                     && !pathVariableManager.isDefined(name)) {
>                     // set the workspace path variable's new value, now
>                     pathVariableManager.setValue(name, new Path(entry
>                         .getLocation()));
> 
>                     // successfully processed this change
>                     variableChanges.remove(name);
530,534c753,757
< 	public void dispose() {
< 		disposed = true;
< 		if (pathVariableChangeListener != null) {
< 			ResourcesPlugin.getWorkspace().getPathVariableManager().removeChangeListener(pathVariableChangeListener);
< 			pathVariableChangeListener = null;
---
>                 if (entry.isSelected() && !currentVariables.contains(name)) {
>                     PathmapManager.addPathVariableReference(name);
>                 } else if (!entry.isSelected()
>                     && currentVariables.contains(name)) {
>                     PathmapManager.removePathVariableReference(name);
536d758
< 		super.dispose();
539,540c761,780
< 	private static class StringsContentProvider implements IStructuredContentProvider {
< 		private Set strings;
---
>             PathmapManager.updatePreferenceStore();
> 
>             return true;
>         } catch (CoreException e) {
>             ErrorDialog.openError(getShell(),
>                 EMFUIMessages.PathmapsPreferencePage_promptTitle,
>                 EMFUIMessages.PathmapsPreferencePage_updateFailed, e
>                     .getStatus());
>             return false;
>         }
>     }
> 
>     /**
>      * A content provider for the Path Variables list.
>      */
>     private static class PathVariableContentProvider
>         implements IStructuredContentProvider {
> 
>         private Set entries;
> 
543,544c783,784
< 		StringsContentProvider() {
< 			strings = new HashSet();
---
>         PathVariableContentProvider() {
>             entries = new HashSet();
547,550c787,796
< 		void add(String string) {
< 			if (!strings.contains(string)) {
< 				strings.add(string);
< 				table.add(string);
---
>         /**
>          * Adds a path variable to the list.
>          * 
>          * @param entry
>          *            the new path variable
>          */
>         void add(PathVariableEntry entry) {
>             if (!entries.contains(entry)) {
>                 entries.add(entry);
>                 table.add(entry);
554,557c800,809
< 		void remove(String string) {
< 			if (strings.contains(string)) {
< 				strings.remove(string);
< 				table.remove(string);
---
>         /**
>          * Removes a path variable from the list.
>          * 
>          * @param entry
>          *            the path variable to remove
>          */
>         void remove(PathVariableEntry entry) {
>             if (entries.contains(entry)) {
>                 entries.remove(entry);
>                 table.remove(entry);
562c814
< 			return strings.toArray();
---
>             return entries.toArray();
566c818
< 			strings = (Set) newInput;
---
>             entries = (Set) newInput;
575,576c827,831
< 	private static class StringsLabelProvider implements ITableLabelProvider, IColorProvider {
< 		private final boolean isReferencedPathVariables;
---
>     /**
>      * A label provider for the Path Variables list.
>      */
>     private static class PathVariableLabelProvider
>         implements ITableLabelProvider, IColorProvider {
580,585c835,836
< 		StringsLabelProvider() {
< 			this(false);
< 		}
< 		
< 		StringsLabelProvider(boolean isReferencedPathVariables) {
< 			this.isReferencedPathVariables = isReferencedPathVariables;
---
>         PathVariableLabelProvider() {
>             super();
587a839,841
>         /**
>          * Shows a lock icon for registered path variables.
>          */
589c843,846
<             if (isReferencedPathVariables && PathmapManager.isRegisteredPathVariable((String) element)) {
---
>             PathVariableEntry entry = (PathVariableEntry) element;
>             String name = entry.getName();
> 
>             if (PathmapManager.isRegisteredPathVariable(name)) {
590a848,851
>             } else if (!isDirectory(entry.getLocation())) {
>                 return MslUIPlugin.getDefault().getWorkbench()
>                     .getSharedImages()
>                     .getImage(ISharedImages.IMG_OBJS_WARN_TSK);
595a857,876
>         /**
>          * Queries whether the specified location references a directory that
>          * exists.
>          * 
>          * @param location
>          *            a location
>          * @return <code>true</code> if the location exists in the filesystem
>          *         and is a directory
>          */
>         private boolean isDirectory(String location) {
>             File file = new File(location);
> 
>             return file.exists() && file.isDirectory();
>         }
> 
>         /**
>          * Obtains the lazily-initialized lock image.
>          * 
>          * @return the lock image
>          */
598,599c879,881
<                 lockImage = MslUIPlugin.imageDescriptorFromPlugin(
<                     MslUIPlugin.getPluginId(), "/icons/full/lock.gif").createImage(); //$NON-NLS-1$
---
>                 lockImage = MslUIPlugin
>                     .imageDescriptorFromPlugin(MslUIPlugin.getPluginId(),
>                         "/icons/full/lock.gif").createImage(); //$NON-NLS-1$
604a887,890
>         /**
>          * Path variables are displayed in the same way as in the Linked
>          * Resources preference page.
>          */
606c892,899
< 			return (columnIndex == 0) ? (String) element : null;
---
>             if (columnIndex != 0) {
>                 return null;
>             }
> 
>             PathVariableEntry entry = (PathVariableEntry) element;
>             return NLS.bind(
>                 EMFUIMessages.PathmapsPreferencePage_variablePattern, entry
>                     .getName(), entry.getLocation());
637,638c930,937
< 	private static class StringsViewerComparator extends ViewerComparator {
< 		StringsViewerComparator() {
---
>     /**
>      * A sorter for the Path Variables list. All registered path maps sort to
>      * the bottom of the list to keep them out of the user's way.
>      */
>     private static class PathVariableViewerComparator
>         extends ViewerComparator {
> 
>         PathVariableViewerComparator() {
641a941,950
>         /**
>          * We sort by <code>name</code>.
>          */
>         public boolean isSorterProperty(Object element, String property) {
>             return NAME_ATTRIBUTE.equals(property);
>         }
> 
>         /**
>          * Registered variables are in a higher category than user variables.
>          */
644c953,1098
< 			return PathmapManager.isRegisteredPathVariable((String) element)? 1 : 0;
---
>             return PathmapManager
>                 .isRegisteredPathVariable(((PathVariableEntry) element)
>                     .getName()) ? 1
>                 : 0;
>         }
>     }
> 
>     /**
>      * Data model for a path variable in the Path Variables list.
>      */
>     private static final class PathVariableEntry {
> 
>         private String name;
> 
>         private String location;
> 
>         private IPath locationPath;
> 
>         private final boolean required;
> 
>         private boolean selected;
> 
>         /**
>          * Initializes a user-defined path variable with the name and location
>          * path.
>          * 
>          * @param name
>          *            the variable name
>          * @param location
>          *            the location
>          */
>         PathVariableEntry(String name, IPath location) {
>             this(name, location.toPortableString(), false);
> 
>             this.locationPath = location;
>         }
> 
>         /**
>          * Initializes a registered path variable with the name and location
>          * derived from the URI.
>          * 
>          * @param name
>          *            the variable name
>          * @param location
>          *            the location URI
>          */
>         PathVariableEntry(String name, String location) {
>             this(name, location, true);
>         }
> 
>         private PathVariableEntry(String name, String location, boolean required) {
>             this.name = name;
>             this.location = location;
>             this.required = required;
>             selected = required;
>         }
> 
>         /**
>          * Queries whether this path variable is required (a registered path
>          * variable that the user cannot edit, remove, or uncheck).
>          * 
>          * @return whether I am required
>          */
>         boolean isRequired() {
>             return required;
>         }
> 
>         /**
>          * Obtains the path variable name.
>          * 
>          * @return my name
>          */
>         String getName() {
>             return name;
>         }
> 
>         /**
>          * Sets the path variable name, if it is editable.
>          * 
>          * @param name
>          *            the new name
>          */
>         void setName(String name) {
>             if (!isRequired()) {
>                 this.name = name;
>             }
>         }
> 
>         /**
>          * Obtains the path variable location.
>          * 
>          * @return my location
>          */
>         String getLocation() {
>             return location;
>         }
> 
>         /**
>          * Obtains the path variable location, as an {@link IPath}.
>          * 
>          * @return my location
>          */
>         IPath getLocationPath() {
>             return locationPath;
>         }
> 
>         /**
>          * Sets the path variable name, if it is editable.
>          * 
>          * @param location
>          *            the new location
>          */
>         void setLocation(IPath location) {
>             if (!isRequired()) {
>                 this.locationPath = location;
>                 this.location = location.toPortableString();
>             }
>         }
> 
>         /**
>          * Queries whether the path variable is checked. Required (registered)
>          * path variables are always checked.
>          * 
>          * @return whether I am checked
>          */
>         boolean isSelected() {
>             return selected;
>         }
> 
>         /**
>          * Sets whether the path variable is checked, if it is not registered.
>          * 
>          * @param selected
>          *            whether I am checked
>          */
>         void setSelected(boolean selected) {
>             if (!isRequired()) {
>                 this.selected = selected;
>             }
>         }
> 
>         /**
>          * Displays path variable's debug string.
>          */
>         public String toString() {
>             return getName() + " - " + getLocation(); //$NON-NLS-1$
