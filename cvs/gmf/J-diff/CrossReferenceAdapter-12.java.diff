29a30
> import org.eclipse.emf.ecore.EStructuralFeature;
31a33
> import org.eclipse.emf.ecore.impl.EClassImpl;
35a38
> import org.eclipse.emf.ecore.util.ECrossReferenceEList;
57a61,64
>     private static Map eClassToChangeableFeatures = new HashMap();
> 
>     private static List nullList = new ArrayList(1);
> 
117c124
< 		if (reference.isContainment()) {
---
> 		if (!isImportExportCapable(reference, (EObject) notifier)) {
286,289c293,301
< 				for (Iterator iter = adapter.getInverseReferencers(value, null,
< 						null).iterator(); iter.hasNext();) {
< 					registerReference(((EObject) iter.next()).eResource(),
< 							resource);
---
> 				for (Iterator iter = adapter.getInverseReferences(value).iterator();
>                         iter.hasNext();) {
>                     EStructuralFeature.Setting next = (EStructuralFeature.Setting) iter.next();
>                     EReference ref = (EReference) next.getEStructuralFeature();
>                     EObject owner = next.getEObject();
>                     
>                     if (isImportExportCapable(ref, owner)) {
>                         registerReference(owner.eResource(), resource);
>                     }
294,297c306,308
< 			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? value
< 					.eCrossReferences().iterator()
< 					: ((InternalEList) value.eCrossReferences())
< 							.basicIterator());
---
>             EContentsEList.FeatureIterator crossReferences = getOptimizedCrossReferenceIterator(
>             		value);
>             
305,306c316
< 					// we ignore unchangeable references
< 					if (eReference.isChangeable()) {
---
> 					if (isImportExportCapable(eReference, referent)) {
315,318c325,333
< 				for (Iterator iter = adapter.getInverseReferencers(value, null,
< 						null).iterator(); iter.hasNext();) {
< 					deregisterReference(((EObject) iter.next()).eResource(),
< 							resource);
---
>                 for (Iterator iter = adapter.getInverseReferences(value).iterator();
>                         iter.hasNext();) {
>                     EStructuralFeature.Setting next = (EStructuralFeature.Setting) iter.next();
>                     EReference ref = (EReference) next.getEStructuralFeature();
>                     EObject owner = next.getEObject();
>                     
>                     if (isImportExportCapable(ref, owner)) {
>                         deregisterReference(owner.eResource(), resource);
>                     }
363,366c378,380
< 			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) (resolve() ? eObject
< 					.eCrossReferences().iterator()
< 					: ((InternalEList) eObject.eCrossReferences())
< 							.basicIterator());
---
> 			EContentsEList.FeatureIterator crossReferences = getOptimizedCrossReferenceIterator(
> 					eObject);
> 			
374,375c388
< 					// we ignore unchangeable references
< 					if (eReference.isChangeable()) {
---
> 					if (isImportExportCapable(eReference, referent)) {
680a694,730
>      * Like the {@link #getInverseReferencers(EObject, EReference, EClass)} method,
>      * obtains referencing objects (optionally filtered by reference and type),
>      * except that it additionally only considers references that are
>      * {@linkplain EStructuralFeature#isChangeable() changeable} and can
>      * {@linkplain EReference#isResolveProxies() reference other resources}.
>      * 
>      * @param referenced
>      *            the referenced EObject
>      * @param reference
>      *            the reference to find referencers on, null for any reference
>      * @param type
>      *            the type of the referencers, use null for any type
>      * @return a Set of referencers on potentially cross-resource references
>      */
>     public Set getInverseReferencersCrossResource(EObject referenced, EReference reference,
>             EClass type) {
>         return getReferencers(getInverseReferencesCrossResource(referenced), reference, type);
>     }
>     
> 
> 	/**
>      * Like the {@link #getInverseReferences(EObject)} method,
>      * obtains settings implementing references to the specified object,
>      * except that it only considers references that are
>      * {@linkplain EStructuralFeature#isChangeable() changeable} and can
>      * {@linkplain EReference#isResolveProxies() reference other resources}.
>      * 
>      * @param eObject the referenced EObject
>      * 
>      * @return a collection of {@link EStructuralFeature.Setting}s on
>      *     potentially cross-resource references
>      */
>     public Collection getInverseReferencesCrossResource(EObject eObject) {
>         return getInverseReferencesCrossResource(eObject, !resolve());
>     }
> 
> 	/**
827c877
< 	public Collection getInverseReferences(EObject eObject, boolean resolve) {
---
> 	public Collection getInverseReferences(EObject eObject, boolean _resolve) {
830c880
< 		if (resolve) {
---
> 		if (_resolve) {
874a925,1078
> 
> 	/**
> 	 * Computes the references defined by the specified EClass that are
> 	 * {@linkplain EStructuralFeature#isChangeable() changeable}.
> 	 * 
> 	 * @param eCls an EClass
> 	 * @return a list of its {@link EReference}s that are changeable
> 	 */
>     private static List getCrossReferencesChangeableFeatures(EClass eCls) {
>         List features = (List) eClassToChangeableFeatures.get(eCls);
>         if (features == null) {
>             features = nullList;
>             EStructuralFeature[] crossReferenceFeatures =
> 
>             ((EClassImpl.FeatureSubsetSupplier) eCls
>                 .getEAllStructuralFeatures()).crossReferences();
>             if (crossReferenceFeatures != null) {
>                 features = new ArrayList(crossReferenceFeatures.length);
>                 for (int i = 0; i < crossReferenceFeatures.length; i++) {
>                     EStructuralFeature feature = crossReferenceFeatures[i];
>                     if (feature.isChangeable())
>                         features.add(feature);
>                 }
>             }
>             eClassToChangeableFeatures.put(eCls, features);
>         }
>         return features != nullList ? features
>             : null;
>     }
> 
> 	/**
> 	 * An iterator over the references defined by the specified EObject that
> 	 * are {@linkplain EStructuralFeature#isChangeable() changeable}.
> 	 * 
> 	 * @param eObj an EObject
> 	 * @return an iterator over its {@link EReference}s that are changeable
> 	 */
>     private EContentsEList.FeatureIterator getOptimizedCrossReferenceIterator(
>             EObject eObj) {
>         List features = getCrossReferencesChangeableFeatures(eObj.eClass());
>         if (features != null) {
>             EContentsEList list = null;
>             if (features.size() > 0) {
>                 list = new ECrossReferenceEList(eObj,
>                     (EStructuralFeature[]) features
>                         .toArray(new EStructuralFeature[features.size()])) {
>                     // to get to the protected constructor
>                 };
>             } else {
>                 list = ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST;
>             }
> 
>             return (EContentsEList.FeatureIterator) (resolve() ? list
>                 .iterator()
>                 : ((InternalEList) list).basicIterator());
>         }
>         return (EContentsEList.FeatureIterator) ECrossReferenceEList.EMPTY_CROSS_REFERENCE_ELIST
>             .iterator();
>     }
> 
> 	/**
>      * Like the {@link #getInverseReferences(EObject, boolean)} method,
>      * obtains settings implementing references to the specified object,
>      * except that it only considers references that are
>      * {@linkplain EStructuralFeature#isChangeable() changeable} and can
>      * {@linkplain EReference#isResolveProxies() reference other resources}.
>      * 
>      * @param eObject the referenced EObject
>      * @param resolve whether to resolve proxies or not
>      * 
>      * @return a collection of {@link EStructuralFeature.Setting}s on
>      *     potentially cross-resource references
>      */
>     public Collection getInverseReferencesCrossResource(EObject eObject, boolean resolve) {
>         Collection result = new ArrayList();
> 
>         if (resolve) {
>             resolveAll(eObject);
>         }
> 
>         EObject eContainer = eObject.eContainer();
>         if (eContainer != null) {
>             result.add(((InternalEObject) eContainer).eSetting(eObject
>                     .eContainmentFeature()));
>         }
> 
>         Collection nonNavigableInverseReferences = (Collection) inverseCrossReferencer
>                 .get(eObject);
>         if (nonNavigableInverseReferences != null) {
>             result.addAll(nonNavigableInverseReferences);
>         }
> 
>         for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i
>                 .hasNext();) {
>             EReference eReference = (EReference) i.next();
>             EReference eOpposite = eReference.getEOpposite();
>             
>             if (eOpposite != null
>             		&& isImportExportCapable(eReference, eObject)
>             		&& eObject.eIsSet(eReference)) {
>                 if (FeatureMapUtil.isMany(eObject, eReference)) {
>                     Object collection = eObject.eGet(eReference);
>                     for (Iterator j = resolve() ? ((Collection) collection)
>                             .iterator() : ((InternalEList) collection)
>                             .basicIterator(); j.hasNext();) {
>                         InternalEObject referencingEObject = (InternalEObject) j
>                                 .next();
>                         result.add(referencingEObject.eSetting(eOpposite));
>                     }
>                 } else {
>                     // although the reference is set, the value could be null
>                     InternalEObject referencingEObject = ((InternalEObject) eObject
>                             .eGet(eReference, resolve()));
>                     if (referencingEObject != null) {
>                         result.add(referencingEObject.eSetting(eOpposite));
>                     }
>                 }
>             }
>         }
> 
>         return result;
>     }
>     
>     /**
>      * Queries whether the specified reference, applied to the given owner
>      * object, is capable of establishing a resource import or export by
>      * virtue of being a mutable cross-resource reference.
>      * <p>
>      * A reference is considered to support resource imports and exports if
>      * all of the following apply:
>      * </p>
>      * <ul>
>      *   <li>the reference is not a container or containment reference.  Note
>      *       that this excludes cross-resource containment from registering
>      *       as an import/export dependency</li>
>      *   <li>the reference resolves proxies</li>
>      *   <li>the reference is changeable</li>
>      * </ul>
>      * 
>      * @param reference a reference feature
>      * @param owner an object under consideration that defines this reference.
>      *     Subclasses may need to introspect the object or its EClass to further
>      *     refine their criteria
>      * 
>      * @return <code>true</code> if this reference in the context of this
>      *     owner should be counted for resource imports and exports;
>      *     false, otherwise
>      */
>    protected boolean isImportExportCapable(EReference reference, EObject owner) {
>     	return !reference.isContainer()
>         	&& !reference.isContainment()
>         	&& reference.isResolveProxies() // can be cross-resource
>         	&& reference.isChangeable();    // not computed
>     }
