2c2
<  * Copyright (c) 2002, 2003 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2008 IBM Corporation and others.
38c38,40
<  * to mean another request.
---
>  * to mean another request. Note that some transfers on different OS's occur at the drop time, hence
>  * live feedback cannot be provided for these transfers (i.e. command created). If this is the case then to enable
>  * drag and drop on different platforms {@link #isDataTransfered()} needs to be implemented.
43c45
<  * @author melaasar
---
>  * @author melaasar, aboyko
53a56
>         setEnablementDeterminedByCommand(true);
62a66
>         setEnablementDeterminedByCommand(true);
70,73c74
< 		DropObjectsRequest request =  new DropObjectsRequest();
< 		request.setObjects(getObjectsBeingDropped());
< 		request.setAllowedDetail(getCurrentEvent().operations);
< 		return request;
---
>         return  new DropObjectsRequest();
112a114,120
>         /*
>          * The edit policies creating the command for the drop request may modify the
>          * required detail field, so it's being set for the event here. However, if the command
>          * can't be created due to the fact that data hasn't been transfered yet then the request will
>          * contain DND.DROP_NONE required detail that we don't want to set for the event.  
>          */
>         if (getDropObjectsRequest().getRequiredDetail() != DND.DROP_NONE) {
114a123
>     }
122a132,138
>         /*
>          * The edit policies creating the command for the drop request may modify the
>          * required detail field, so it's being set for the event here. However, if the command
>          * can't be created due to the fact that data hasn't been transfered yet then the request will
>          * contain DND.DROP_NONE required detail that we don't want to set for the event.  
>          */
>         if (getDropObjectsRequest().getRequiredDetail() != DND.DROP_NONE) {
123a140
>         }
167c184,191
< 	 * Assumes that the target request is a {@link DropObjectsRequest}. 
---
> 	 * Assumes that the target request is a {@link DropObjectsRequest}. GEF
> 	 * wipes out the request in {@link #isEnabled(DropTargetEvent)} method, we
> 	 * don't. Hence we just update the necessary fields: <li>the mouse location
> 	 * <li>the objects being dropped <li>the allowed detail that comes from the
> 	 * DND event
> 	 * 
> 	 * @see org.eclipse.gef.dnd.AbstractTransferDropTargetListener#
> 	 * 	updateTargetRequest()
171a196,197
>         request.setObjects(getObjectsBeingDropped());
>         request.setAllowedDetail(getCurrentEvent().operations);
174,175c200,201
< 	/**
< 	 * Make sure the target can produce a command
---
>     /* (non-Javadoc)
>      * @see org.eclipse.gef.dnd.AbstractTransferDropTargetListener#isEnabled(org.eclipse.swt.dnd.DropTargetEvent)
178,186c204,205
< 		if (super.isEnabled(event)){
< 			boolean result = calculateTargetEditPart() != null;
< 			return result;
< 		}
< 		return false;
< 	}
< 
< 	/**
< 	 * @see org.eclipse.gef.dnd.AbstractTransferDropTargetListener#updateTargetEditPart()
---
>     	/*
>     	 * Cache the current event 
188,190c207
< 	protected void updateTargetEditPart() {
< 		setTargetEditPart(calculateTargetEditPart());
< 	}
---
>         setCurrentEvent(event);
192,193c209,210
< 	/**
< 	 * @return an edit part that can produce an executable command for the target request
---
>         /*
>          * Update the target request and target editpart
195d211
< 	private EditPart calculateTargetEditPart() {
197,203c213,223
< 		EditPart ep = getViewer()
< 			.findObjectAtExcluding(
< 				getDropLocation(),
< 				getExclusionSet(),
< 				new EditPartViewer.Conditional() {
< 					public boolean evaluate(EditPart editpart) {
< 						Command command = editpart.getCommand(getTargetRequest());
---
>         updateTargetEditPart();
>         
>         if (getTargetEditPart() == null) {
>             return false;
>         } else if (isEnablementDeterminedByCommand() && isDataTransfered()) {
>         	/*
>         	 * Check the command only if:
>         	 * 1) The data has been transfered from the drag source to the event
>         	 * 2) The "ask for command" option is on. (It's "on" by default)
>         	 */
>             Command command = getCommand();
204a225,230
>         } else {
>         	/*
>         	 * Otherwise we should enable the drop. Executable command needs to be created at the drop time anyway.
>         	 * Hence, we'll fail the drop there if there is no target editpart or no data transfered. 
>         	 */
>             return true;
206,209d231
< 				});
< 		if (ep != null) {
< 			Command command = ep.getCommand(getTargetRequest());
< 			return (command != null && command.canExecute())? ep : null;
211c233,247
< 		return ep;
---
> 
>     /**
> 	 * It is not a common use case to have the transfered data at the drag time,
> 	 * hence live feedback cannot be provided for all types of DnD. Since the
> 	 * occurrence of the data transfer at the drag time depends mostly on the
> 	 * used OS and the the type of data transfer, clients are responsible to
> 	 * experiment with their DnD and come up with the appropriate implementation
> 	 * of this method for their specific DnD support. By default the method
> 	 * returns <code>true</code>, which means that we assume that the data has
> 	 * been transfered at the start of the drag
> 	 * 
> 	 * @return <code>true</code> if data has been transfered.
> 	 */
>     protected boolean isDataTransfered() {
>         return true;
