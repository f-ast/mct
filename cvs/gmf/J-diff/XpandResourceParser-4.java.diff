11a12
>  *     Artem Tikhomirov - LPG lexer/parser and error reporting
18c19,20
< import java.io.UnsupportedEncodingException;
---
> import java.io.Reader;
> import java.util.ArrayList;
20,22d21
< import org.eclipse.core.resources.IFile;
< import org.eclipse.core.runtime.CoreException;
< import org.eclipse.gmf.internal.xpand.Activator;
30c29,30
< 	public XpandResource parse(final IFile file) {
---
> 	// XXX everything except exact lexer and parser instances are the same as n XtendResourceParser
> 	public XpandResource parse(final Reader source, final String qualifiedTemplateName) throws IOException, ParserException {
34c34,35
< 		char[] buffer;
---
> 		final ArrayList<ParserException.ErrorLocationInfo> errors = new ArrayList<ParserException.ErrorLocationInfo>();
> 		final char[] buffer = new StreamConverter().toCharArray(source);
36,46c37,42
< 			StreamConverter sc = new StreamConverter();
< 			buffer = sc.toCharArray(file);
< 		} catch (final CoreException ex) {
< 			Activator.log(ex.getStatus());
< 			return null;
< 		} catch (UnsupportedEncodingException ex) {
< 			Activator.logError(ex);
< 			return null;
< 		} catch (IOException ex) {
< 			Activator.logError(ex);
< 			return null;
---
> 			scanner = new XpandLexer(buffer, qualifiedTemplateName) {
>         		// FIXME move to XpandLexer.g template
>             	@Override
>             	public void reportError(int left_loc, int right_loc) {
>                     errors.add(XtendResourceParser.createError(this, left_loc, right_loc));
>             		super.reportError(left_loc, right_loc);
48,49c44
< 		try {
< 			scanner = new XpandLexer(buffer, file.getName());
---
> 			};
53,64c48
< 			// FIXME handle errors
< //		} catch (final MismatchedTokenException e) {
< //			final Token t = e.token;
< //			final int offSet = t.getColumn() - 1;
< //			OawMarkerManager.deleteMarkers(file);
< //			OawMarkerManager.addErrorMarker(file, e.getMessage(), IMarker.SEVERITY_ERROR, offSet, offSet + t.getText().length());
< //		} catch (final NoViableAltException e) {
< //			final Token t = e.token;
< //			final int offSet = t.getColumn() - 1;
< //			final int length = t.getText() == null ? offSet : offSet + t.getText().length();
< //			OawMarkerManager.deleteMarkers(file);
< //			OawMarkerManager.addErrorMarker(file, e.getMessage(), IMarker.SEVERITY_ERROR, offSet, length);
---
> 			// FIXME handle errors if find out how to force generated parser to throw exception instead of consuming it
66,69c50,54
< 			final int start = scanner.getStreamIndex() - 1;
< 			final int end = start + 1;
< 			OawMarkerManager.deleteMarkers(file);
< 			OawMarkerManager.addErrorMarker(file, e.getMessage(), start, end);
---
>         	if (errors.isEmpty()) {
>         		throw new IOException("Unexpected exception while parsing");
>         	} else {
>         		throw new ParserException(errors);
>         	}
72c57,60
< 			tpl.setFullyQualifiedName(Activator.getQualifiedName(file));
---
> 			// XXX two choices here - 
> 			// (1) pass any name into parse method, do not assume it's fqn and move setFQN outside of this method
> 			// (2) assume fqn is passed into parse() as it's now.
> 			tpl.setFullyQualifiedName(qualifiedTemplateName);
