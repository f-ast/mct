184c184
< 	 * side takes precendence.
---
> 	 * side takes precedence.
190c190
< 	private Point locateOnParent(Point suggestedLocation,
---
> 	protected Point locateOnParent(Point suggestedLocation,
254c254
< 	 * existing borderItemFigure.
---
> 	 * existing borderItemFigure and returns the conflicting border item figure
257c257
< 	 * @return <code>ture</code> or <code>false</code>
---
> 	 * @return the conflicting border item figure
259c259
< 	private boolean conflicts(Point recommendedLocation,
---
> 	protected IFigure getConflictingBorderItemFigure(Point recommendedLocation,
273c273
< 					return true;
---
> 					return borderItem;
277c277
< 		return false;
---
> 		return null;
281c281
< 	 * The preferred side takes precendence.
---
> 	 * The preferred side takes precedence.
289c289
< 	private Point locateOnBorder(Point suggestedLocation,
---
> 	protected Point locateOnBorder(Point suggestedLocation,
299c299,301
< 		if (circuitCount < 4 && conflicts(recommendedLocation, borderItem)) {
---
> 		IFigure conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
> 
> 		if (circuitCount < 4 && conflictingBorderItem != null) {
302,304c304,308
< 					recommendedLocation.y += borderItemSize.height
< 						+ vertical_gap;
< 				} while (conflicts(recommendedLocation, borderItem));
---
> 					recommendedLocation.y = calculateNextNonConflictingPosition(
> 							conflictingBorderItem.getBounds().getBottomLeft().y,
> 							vertical_gap, suggestedSide, borderItem);
> 					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
> 				} while (conflictingBorderItem != null);
309a314,317
> 				} else if (recommendedLocation.y < getParentBorder().getTopLeft().y
> 					- borderItemSize.height) { // off the top, wrap north
> 					return locateOnBorder(recommendedLocation,
> 						PositionConstants.NORTH, circuitCount + 1, borderItem);
313,315c321,325
< 					recommendedLocation.x += borderItemSize.width
< 						+ horizontal_gap;
< 				} while (conflicts(recommendedLocation, borderItem));
---
> 					recommendedLocation.x = calculateNextNonConflictingPosition(
> 							conflictingBorderItem.getBounds().getTopRight().x,
> 							horizontal_gap, suggestedSide, borderItem);
> 					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
> 				} while (conflictingBorderItem != null);
319a330,333
> 				} else if (recommendedLocation.x < getParentBorder().getBottomLeft().x
> 					- borderItemSize.width) {
> 					return locateOnBorder(recommendedLocation,
> 						PositionConstants.WEST, circuitCount + 1, borderItem);
324,325c338,342
< 					recommendedLocation.y -= (borderItemSize.height + vertical_gap);
< 				} while (conflicts(recommendedLocation, borderItem));
---
> 					recommendedLocation.y = calculateNextNonConflictingPosition(
> 							conflictingBorderItem.getBounds().getLocation().y,
> 							vertical_gap, suggestedSide, borderItem);
> 					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
> 				} while (conflictingBorderItem != null);
329a347,350
> 				} else if (recommendedLocation.y > getParentBorder().getBottomRight().y) {
> 					// east is full, try south.
> 					return locateOnBorder(recommendedLocation,
> 						PositionConstants.SOUTH, circuitCount + 1, borderItem);
333,334c354,358
< 					recommendedLocation.x -= (borderItemSize.width + horizontal_gap);
< 				} while (conflicts(recommendedLocation, borderItem));
---
> 					recommendedLocation.x = calculateNextNonConflictingPosition(
> 							conflictingBorderItem.getBounds().getLocation().x,
> 							horizontal_gap, suggestedSide, borderItem);
> 					conflictingBorderItem = getConflictingBorderItemFigure(recommendedLocation, borderItem);
> 				} while (conflictingBorderItem != null);
337a362,364
> 				} else if (recommendedLocation.x > getParentBorder().getTopRight().x) {
> 					return locateOnBorder(recommendedLocation,
> 							PositionConstants.EAST, circuitCount + 1, borderItem);
344a372,394
> 	 * Default behavior is to simply check in a counter clockwise direction.
> 	 * Note:  if the currentSide is EAST or WEST, the y co-oridinate is passed as the current position.  Otherwise,
> 	 * if NORTH or SOUTH is the currentSide, then the x co-oridinate of the borderitem is passed.
> 	 * 
> 	 * @param currentPosition	The current x or y co-ordinate of the border item
> 	 * @param interval			The suggested spacing to try to find the next non-conflicting position
> 	 * @param currentSide		The current side of the border item 
> 	 * @param borderItem 		The borderItem being relocated (here to be used by subclasses if needed)
> 	 * @return the next possible non-conflicting position
> 	 */
> 	protected int calculateNextNonConflictingPosition(int currentPosition, int interval, int currentSide, IFigure borderItem) {
> 		switch (currentSide) {
> 			case PositionConstants.WEST:  // Fall through  -- Move down the west side
> 			case PositionConstants.SOUTH: // Move towards the east side
> 				return currentPosition + interval;
> 			case PositionConstants.EAST:  // Fall through - Move towards the north side
> 			case PositionConstants.NORTH: // Fall through - Move towards the west side
> 			default: /* Should never get here, but if we do, we'll default to subtraction */
> 				return currentPosition - interval;
> 		}
> 	}
> 	
> 	/**
