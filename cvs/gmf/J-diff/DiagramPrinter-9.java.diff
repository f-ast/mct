2c2
<  * Copyright (c) 2002 - 2005 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2006 IBM Corporation and others.
20a21
> import org.eclipse.gef.RootEditPart;
22a24,27
> import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.editparts.IDiagramPreferenceSupport;
> import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.PageBreakEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.internal.figures.PageBreaksFigure;
28a34
> import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;
34a41
> import org.eclipse.swt.SWT;
37a45
> import org.eclipse.swt.graphics.Image;
40a49
> import org.eclipse.ui.PlatformUI;
57a67,70
>     private boolean printRangePageSelection = false;
>     
>     private int pageFrom = 1, pageTo = 1;
> 
165a179,189
>     public void setPrintRangePageSelection(boolean isPrintRangePageSelected) {
>         this.printRangePageSelection = isPrintRangePageSelected;
>     }
>     
>     public void setPrintRangePages(int pageFrom, int pageTo) {
>         assert pageFrom > 0 : "From page in print range page selection must be bigger than zero."; //$NON-NLS-1$
>         assert (pageTo > 0 && pageTo >= pageFrom) : "To page in print range page selection must be bigger than zero and from page.";  //$NON-NLS-1$
>         this.pageFrom = pageFrom;
>         this.pageTo = pageTo;
>     }
> 
196,197d219
< 		initialize();
< 
205c227,236
< 			DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart((Diagram) obj, preferencesHint);
---
>             DiagramEditPart dgrmEP = PrintHelper.createDiagramEditPart((Diagram) obj, null);
>             
>             RootEditPart rep = dgrmEP.getRoot();
>             if (rep instanceof DiagramRootEditPart) 
>                 this.mm = ((DiagramRootEditPart)rep).getMapMode();
>             if (rep instanceof IDiagramPreferenceSupport)
>                 this.preferencesHint = ((IDiagramPreferenceSupport)rep).getPreferencesHint();
>             
>             initialize();
>             
206a238,240
>             
>             IPreferenceStore pref = null;
>             
208,209c242,249
< 			IPreferenceStore fPreferences = ((DiagramGraphicalViewer)dgrmEP.getViewer()).getWorkspaceViewerPreferenceStore();
< 			doPrintDiagram(dgrmEP, loadedPreferences, fPreferences);
---
>     
>             pref = ((DiagramGraphicalViewer)dgrmEP.getViewer()).getWorkspaceViewerPreferenceStore();
>             
>             if (pref.getBoolean(WorkspaceViewerProperties.PREF_USE_WORKSPACE_SETTINGS)) {
>                 
>                 //get workspace settings...
>                 if (dgrmEP.getDiagramPreferencesHint().getPreferenceStore() != null)
>                     pref = (IPreferenceStore)dgrmEP.getDiagramPreferencesHint().getPreferenceStore(); 
212c252,253
< 		printer.endJob();
---
>             doPrintDiagram(dgrmEP, loadedPreferences, pref);
>             
214a256,336
>         printer.endJob();
>         
>     }
>     
>     /**
>      * Calculates the row in a grid, given a page number.
>      * | 1 | 2 | 3 |
>      * | 4 | 5 | 6 |
>      * | 7 | 8 | 9 |
>      * 
>      * Given pageNum=5 and totalNumColumns=3, will return 2
>      * (2nd row).
>      * 
>      * @param pageNum the page number in the grid.
>      * @param totalNumColumns total number of columns of the grid.
>      * @return row number corresponding to the page number.
>      */
>     private int calculateRowFromPage(int pageNum, int totalNumColumns) {
>         int row = pageNum / totalNumColumns;
>         if (pageNum % totalNumColumns != 0)
>             row++;
>         return row;
>     }
>     
>     /**
>      * Calculates the column in a grid, given a page number.
>      * | 1 | 2 | 3 |
>      * | 4 | 5 | 6 |
>      * | 7 | 8 | 9 |
>      * 
>      * Given pageNum=5 and totalNumColumns=3, will return 2
>      * (2nd column).
>      *  
>      * @param pageNum the page number in the grid.
>      * @param totalNumColumns total number of columns of the grid.
>      * @param cRow the corresponding row of the page number.
>      * @return row number corresponding to the page number.
>      */
>     private int calculateColumnFromPage(int pageNum, int totalNumColumns, int cRow) {
>         int col = pageNum - ((cRow - 1) * totalNumColumns);
>         return col;
>     }
>     
>     /**
>      * Obtains the total number of pages that span columns and rows
>      * @param dgrmEP
>      * @return Point.x contains the total number of pages that span in a column
>      *         Point.y contains the total number of pages that span in a row
>      */
>     private org.eclipse.draw2d.geometry.Point getPageCount(DiagramEditPart dgrmEP, Rectangle figureBounds, org.eclipse.draw2d.geometry.Point pageSize, boolean applyUserScale) {
>         RootEditPart rootEditPart = dgrmEP.getRoot();
>         if (rootEditPart instanceof DiagramRootEditPart) {
>             //this is the most accurate way to obtain total rows and columns...
>             
>             DiagramRootEditPart diagramRootEditPart = (DiagramRootEditPart) rootEditPart;
>             PageBreakEditPart pageBreakEditPart = diagramRootEditPart
>                 .getPageBreakEditPart();
>             float fNumCols = ((PageBreaksFigure)pageBreakEditPart.getFigure()).getPageCount().y * 
>                 (applyUserScale ? userScale : 1);
>             float fNumRows = ((PageBreaksFigure)pageBreakEditPart.getFigure()).getPageCount().x * 
>                 (applyUserScale ? userScale : 1);
>             
>             int numCols = (int) Math.ceil(fNumCols);
>             int numRows = (int) Math.ceil(fNumRows);
>             
>             return new org.eclipse.draw2d.geometry.Point(numCols,numRows);
>         }
>         else {
>             //otherwise, calculate manually...
>             
>             float fNumRows = (figureBounds.height * (applyUserScale ? userScale : 1))
>                 / pageSize.y;
>             int numRows = (int) Math.ceil(fNumRows);
> 
>             float fNumCols = (figureBounds.width * (applyUserScale ? userScale : 1))
>                 / pageSize.x;
>             int numCols = (int) Math.ceil(fNumCols);
>             
>             return new org.eclipse.draw2d.geometry.Point(numCols, numRows);
>         }
>     }
232a355,359
>         //check for rtl orientation...
>         int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();
>         if ((style & SWT.MIRRORED) != 0)
>             this.gc = new GC(printer, SWT.RIGHT_TO_LEFT);
>         else
233a361
> 
289a418
>         org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize(fPreferences, false, getMapMode());
292,295c421
< 		translated = new Point(-figureBounds.x, -figureBounds.y);
< 		this.graphics.translate(translated.x, translated.y);
< 
< 		this.graphics.scale(userScale);
---
>         translated = new Point((int) (-figureBounds.x * userScale), (int) (-figureBounds.y * userScale));
298,307c424
< 		
< 		org.eclipse.draw2d.geometry.Point pageSize = PageInfoHelper.getPageSize(fPreferences, false, getMapMode());
< 		
< 		float fNumRows = (figureBounds.height * userScale)
< 			/ pageSize.y;
< 		int numRows = (int) Math.ceil(fNumRows);
< 
< 		float fNumCols = (figureBounds.width * userScale)
< 			/ pageSize.x;
< 		int numCols = (int) Math.ceil(fNumCols);
---
>         int numRows = 0, numCols = 0;
312c429,430
< 		GC gc_ = new GC(Display.getDefault());
---
>         GC gc_ = new GC(Display.getDefault(),this.gc.getStyle());
>         gc_.setAntialias(this.gc.getAntialias());
316a435,450
>         org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageSize, true);
>         numCols = pageCount.x;
>         numRows = pageCount.y;
> 
>         //finalRow and finalColumn will be used if we are printing within a page range...
>         int row = 1, col = 1, finalRow = 0, finalColumn = 0;
>         
>         if (this.printRangePageSelection) {
>             //print only the pages specified in the page range...
>             row = calculateRowFromPage(this.pageFrom, numCols);
>             col = calculateColumnFromPage(this.pageFrom, numCols, row);
>             
>             finalRow = calculateRowFromPage(this.pageTo, numCols);
>             finalColumn = calculateColumnFromPage(this.pageTo, numCols, finalRow);
>         }
>         
319,320c453,454
< 			for (int row = 1; row <= numRows; row++) {
< 				for (int col = 1; col <= numCols; col++) {
---
>             for (; row <= numRows; row++) {
>                 for (; col <= numCols; col++) {
323a458,460
>                     
>                     if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
>                         break;
324a462,466
>                 
>                 if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
>                     break;
>                 
>                 col = 1;
385c527
< 	 * for figuring ouyt the font's extent
---
>      * for figuring out the font's extent
392a535,536
>      * to check if it is the first time the method is getting called for the current
>      * print.
399a544,546
>         
>         boolean rtlEnabled = ((this.gc.getStyle() & SWT.MIRRORED) != 0);
>         
401a549,572
>         //draw everything on an offscreen image first and then draw that image
>         //onto the printer gc...this takes care of certain drawing bugs.
>         
>         Image image = new Image(Display.getDefault(), getMapMode().LPtoDP(pageSize.x), getMapMode().LPtoDP(pageSize.y));
>         
>         GC imgGC = new GC(image, (rtlEnabled) ? SWT.RIGHT_TO_LEFT : SWT.LEFT_TO_RIGHT);
>         imgGC.setXORMode(false);
> 
>         SWTGraphics sg = new SWTGraphics(imgGC);
>         
>         //for scaling
>         ScaledGraphics g1 = new ScaledGraphics(sg);
>     
>         //for himetrics and svg
>         MapModeGraphics mmg = createMapModeGraphics(g1);
>         
>         //if mmg's font is null, gc.setFont will use a default font
>         imgGC.setFont(mmg.getFont());
>         
>         mmg.translate(translated.x,translated.y);
>         mmg.scale(userScale);
>         
>         mmg.pushState();
>         
410a582,586
>         if (rtlEnabled) {
>             scaledTranslateX += (margins.left * (colIndex - 1)) + (margins.right * (colIndex));
>             scaledTranslateY += ((margins.top * rowIndex) + (margins.bottom * (rowIndex - 1)));
>         }
>         else {
412a589
>         }
414c591
< 		drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
---
>         mmg.translate(scaledTranslateX, scaledTranslateY);
416c593,597
< 		this.graphics.pushState();
---
>         Rectangle clip = new Rectangle((scaledWidth - margins.left - margins.right) 
>             * (colIndex - 1) + figureBounds.x, (scaledHeight - margins.bottom - margins.top) 
>             * (rowIndex - 1) + figureBounds.y, scaledWidth - margins.right - margins.left, 
>             scaledHeight - margins.top - margins.bottom);
>         mmg.clipRect(clip);
418c599
< 		this.graphics.translate(scaledTranslateX, scaledTranslateY);
---
>         dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(mmg);
420,424c601,603
< 		Rectangle r = new Rectangle((scaledWidth - margins.left - margins.right)
< 			* (colIndex - 1) + figureBounds.x, (scaledHeight - margins.top - margins.bottom)
< 			* (rowIndex - 1) + figureBounds.y, scaledWidth - margins.left - margins.right,
< 			scaledHeight - margins.top - margins.bottom);
< 		this.graphics.clipRect(r);
---
>         mmg.popState();
>         
>         this.graphics.pushState();
426c605
< 		dgrmEP.getLayer(LayerConstants.PRINTABLE_LAYERS).paint(this.graphics);
---
>         this.graphics.drawImage(image, 0, 0);
428a608,612
>         
>         //draw the header and footer after drawing the image to avoid getting the image getting drawn over them
>         drawHeaderAndFooter(gc_, dgrmEP, figureBounds, font, rowIndex, colIndex);
>         
>         disposeImageVars(imgGC, image, sg, g1, mmg);
452,456d635
< 		Rectangle translate = new Rectangle(Math.min(0, figureBounds.x), Math
< 			.min(0, figureBounds.y),
< 			Math.max(pageBounds.x, figureBounds.width), Math.max(pageBounds.y,
< 				figureBounds.height));
< 
459c638
< 			.getPageSize(fPreferences, true, getMapMode());
---
>             .getPageSize(fPreferences, false, getMapMode());
461,466c640,642
< 		// there's usually a difference between the total page area and the
< 		// actual printable area
< 		int offsetX = this.printer.getBounds().width
< 			- this.printer.getClientArea().width;
< 		int offsetY = this.printer.getBounds().height
< 			- this.printer.getClientArea().height;
---
>         org.eclipse.draw2d.geometry.Point pageCount = getPageCount(dgrmEP, figureBounds, pageSize, false);
>         int numCols = pageCount.x;
>         int numRows = pageCount.y;
468,469c644,647
< 		pageSize.x -= offsetX * columns;
< 		pageSize.y -= offsetY * rows;
---
>         Rectangle translate = new Rectangle(Math.min(0, figureBounds.x), Math
>             .min(0, figureBounds.y),
>             Math.max(pageBounds.x, numCols * pageSize.x), Math.max(pageBounds.y,
>                 numRows * pageSize.y));
471,472c649,653
< 		float vScale = ((float) (this.rows * pageSize.y)) / translate.height;
< 		float hScale = ((float) (this.columns * pageSize.x)) / translate.width;
---
>         int totalHeight = (this.rows * pageSize.y);
>         int totalWidth  = (this.columns * pageSize.x);
> 
>         float vScale = ((float) totalHeight) / ((float)(numRows * pageSize.y));
>         float hScale = ((float) totalWidth) / ((float)(numCols * pageSize.x));
479,481d659
< 		this.graphics.translate(translated.x, translated.y);
< 
< 		this.graphics.scale(this.userScale);
490a669,680
>         int row = 1, col = 1, finalRow = 0, finalColumn = 0;
>         
>         if (this.printRangePageSelection) {
>             //print only the pages specified in the page range
>             //this corresponds to the physical pages, not the print range of pages on one physical page.
>             row = calculateRowFromPage(this.pageFrom, this.columns);
>             col = calculateColumnFromPage(this.pageFrom, this.columns, row);
>             
>             finalRow = calculateRowFromPage(this.pageTo, this.columns);
>             finalColumn = calculateColumnFromPage(this.pageTo, this.columns, finalRow);
>         }
>         
493,494c683,684
< 			for (int row = 1; row <= rows; row++) {
< 				for (int col = 1; col <= columns; col++) {
---
>             for (; row <= rows; row++) {
>                 for (; col <= columns; col++) {
498a689,691
>                     
>                     if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
>                         break;
499a693,697
>                 
>                 if (row == finalRow && col == finalColumn && this.printRangePageSelection == true)
>                     break;
>                 
>                 col = 1;
527,529c725,734
< 	    if (graphics != null) {
< 	        graphics.dispose();
<             graphics = null;
---
>         if (this.graphics != null) {
>             try {
>                 this.graphics.dispose();
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
>                 this.graphics = null;                
>             }
532,534c737,746
<         if (printerGraphics != null) {
<             printerGraphics.dispose();
<             printerGraphics = null;
---
>         if (this.printerGraphics != null) {
>             try {
>                 this.printerGraphics.dispose();
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
>                 this.printerGraphics = null;
>             }
537,539c749,758
<         if (swtGraphics != null) {
<             swtGraphics.dispose();
<             swtGraphics = null;
---
>         if (this.swtGraphics != null) {
>             try {
>                 this.swtGraphics.dispose();
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
>                 this.swtGraphics = null;
>             }
542a762
>             try {
543a764,768
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
547a773,842
>         //reset the printer offset, just in case the next diagram to be printed 
>         //uses a different map mode.
>         printerOffset = null;
>         
>     }
>     
>     private void disposeImageVars(GC imgGC, Image image, SWTGraphics sg, 
>             ScaledGraphics g1, MapModeGraphics mmg) {
>         
>         if (mmg != null) {
>             try {
>                 mmg.dispose();
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
>                 mmg = null;                
>             }
>         }
>         
>         if (g1 != null) {
>             try {
>                 g1.dispose();
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
>                 g1 = null;                
>             }
>         }
>         
>         if (sg != null) {
>             try {
>                 sg.dispose();
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
>                 sg = null;                
>             }
>         }
>         
>         if (imgGC != null) {
>             try {
>                 imgGC.dispose();
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
>                 imgGC = null;                
>             }
>         }
>         
>         if (image != null) {
>             try {
>                 image.dispose();
>             }
>             catch (NullPointerException e) {
>                 //do nothing
>             }
>             finally {
>                 image = null;                
>             }
>         }
>     }
> 
612d906
< 
