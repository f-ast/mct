2c2
<  * Copyright (c) 2002, 2006 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2008 IBM Corporation and others.
22a23,25
> import org.eclipse.draw2d.geometry.PrecisionPoint;
> import org.eclipse.draw2d.geometry.PrecisionRectangle;
> import org.eclipse.draw2d.geometry.Rectangle;
24a28
> import org.eclipse.gmf.runtime.draw2d.ui.internal.graphics.ScaledGraphics;
33d36
< import org.eclipse.swt.graphics.Rectangle;
67c70
< 		image = new Image(display, new Rectangle(0, 0, width, height));
---
> 		image = new Image(display, new org.eclipse.swt.graphics.Rectangle(0, 0, width, height));
166a170,246
> 	/* (non-Javadoc)
> 	 * @see org.eclipse.gmf.runtime.diagram.ui.render.clipboard.DiagramGenerator#createConstrainedAWTImageForParts(java.util.List, int, int, boolean)
> 	 */
> 	public java.awt.Image createConstrainedAWTImageForParts(List editParts,
> 			int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
> 		BufferedImage awtImage = null;
> 		IMapMode mm = getMapMode();
> 		Rectangle originalBounds = new PrecisionRectangle(new Rectangle(calculateImageRectangle(editParts)));
> 		mm.LPtoDP(originalBounds);
> 		
> 		int deviceMargins = mm.LPtoDP(getImageMargin());
> 		int threshold = useMargins ? deviceMargins : 0; 
> 		double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
> 		
> 		originalBounds.shrink(deviceMargins, deviceMargins);
> 		
> 		if (maxDeviceWidth > threshold) {
> 			xScalingFactor = (maxDeviceWidth  - threshold - threshold)/ (originalBounds.preciseWidth());
> 		}
> 		if (maxDeviceHeight > threshold) {
> 			yScalingFactor = (maxDeviceHeight - threshold - threshold) / (originalBounds.preciseHeight());
> 		}
> 		
> 		double scalingFactor = Math.min(Math.min(xScalingFactor, yScalingFactor), 1);
> 		
> 		int imageWidth = originalBounds.width + threshold + threshold;
> 		int imageHeight = originalBounds.height + threshold + threshold;
> 		
> 		if (scalingFactor < 1) {
> 			imageWidth = (int) Math.round(originalBounds.preciseWidth() * scalingFactor) + threshold + threshold;
> 			imageHeight = (int) Math.round(originalBounds.preciseHeight() * scalingFactor) + threshold + threshold;
> 		}
> 		
> 		awtImage = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_4BYTE_ABGR_PRE);
> 
> 		Graphics2D g2d = awtImage.createGraphics();
> 		g2d.setColor(Color.white);
> 		g2d.fillRect(0, 0, awtImage.getWidth(), awtImage.getHeight());
> 
> 		// Check anti-aliasing preference
> 		IPreferenceStore preferenceStore = (IPreferenceStore) getDiagramEditPart()
> 				.getDiagramPreferencesHint().getPreferenceStore();
> 
> 		if (preferenceStore
> 				.getBoolean(IPreferenceConstants.PREF_ENABLE_ANTIALIAS)) {
> 			g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
> 					RenderingHints.VALUE_ANTIALIAS_ON);
> 		} else {
> 			g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
> 					RenderingHints.VALUE_ANTIALIAS_OFF);
> 		}
> 
> 		g2d.clip(new java.awt.Rectangle(0, 0, awtImage.getWidth(), awtImage
> 				.getHeight()));
> 
> 		
> 		Graphics graphics = new GraphicsToGraphics2DAdaptor(g2d,
> 				new org.eclipse.swt.graphics.Rectangle(0, 0, imageWidth, imageHeight));
> 		
> 		ScaledGraphics scaledGraphics = new ScaledGraphics(graphics);
> 
> 		RenderedMapModeGraphics mapModeGraphics = new RenderedMapModeGraphics(
> 				scaledGraphics, mm);
> 
> 		g2d.translate(threshold, threshold);
> 		mapModeGraphics.scale(scalingFactor);
> 		
> 		Point location = new PrecisionPoint(originalBounds.preciseX(), originalBounds.preciseY());
> 		mm.DPtoLP(location);
> 		renderToGraphics(mapModeGraphics,
> 				location, editParts);
> 
> 		graphics.dispose();
> 		g2d.dispose();
> 		return awtImage;
> 	}
> 
