16a17
> import java.util.HashSet;
17a19
> import java.util.Iterator;
20a23
> import java.util.Set;
33a37
> import org.eclipse.draw2d.graph.Subgraph;
43a48,49
> import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderItemEditPart;
> import org.eclipse.gmf.runtime.diagram.ui.editparts.IBorderedShapeEditPart;
70,71c76,81
<     private int layoutDefaultMargin = 0;
<     private IMapMode mm;
---
>     protected int layoutDefaultMargin = 0;
>     protected IMapMode mm;
> 	
> 	protected static final int NODE_PADDING = 30;
>     protected static final int MIN_EDGE_PADDING = 5;
>     protected static final int MAX_EDGE_PADDING = NODE_PADDING * 3;
73,75d82
< 	private static final int NODE_PADDING = 30;
< 	private static final int MIN_EDGE_PADDING = 5;
< 	private static final int MAX_EDGE_PADDING = NODE_PADDING * 3;
107,108d113
< 
< 		mm = MapModeUtil.getMapMode(containerEditPart.getFigure());
117c122
< 
---
> 		mm = MapModeUtil.getMapMode(containerEditPart.getFigure());
119c124
< 		DirectedGraph g = new DirectedGraph();
---
> 		DirectedGraph g = createGraph();
121c126
< 		new DirectedGraphLayout().visit(g);
---
> 		createGraphLayout().visit(g);
146c151
< 		DirectedGraph g = new DirectedGraph();
---
> 		DirectedGraph g = createGraph();
148c153
< 		new DirectedGraphLayout().visit(g);
---
>         createGraphLayout().visit(g);
182c187
< 	private NodeList build_nodes(List selectedObjects, Map editPartToNodeDict) {
---
> 	protected NodeList build_nodes(List selectedObjects, Map editPartToNodeDict, Subgraph root) {
250,251c255,265
< 	final protected Rectangle getNodeMetrics(Node n) {
< 		return translateFromGraph(new Rectangle(n.x, n.y, n.width, n.height));
---
> 	 protected Rectangle getNodeMetrics(Node n) {
>         Rectangle rect = null;
>         Node parent = n.getParent();
>         while (parent!=null &&!(parent.data instanceof IGraphicalEditPart))
>             parent = parent.getParent();
>         if (parent!=null){
>             rect = new Rectangle(n.x - parent.x, n.y - parent.y, n.width, n.height);
>         }
>         else
>             rect = new Rectangle(n.x, n.y, n.width, n.height);
>         return translateFromGraph(rect);
292c306
< 	private EdgeList build_edges(List selectedObjects, Map editPartToNodeDict) {
---
> 	protected EdgeList build_edges(List selectedObjects, Map editPartToNodeDict) {
309a324
>         ArrayList notTopDownEdges = new ArrayList();
318c333,336
< 
---
> 					if (from instanceof IBorderItemEditPart)
>                         from = from.getParent();
>                     if (to instanceof IBorderItemEditPart)
>                         to = to.getParent();
325a344,345
> 				}else{
>                     notTopDownEdges.add(poly);
331c351
< 		li = objects.listIterator();
---
> 		li = notTopDownEdges.listIterator();
333,337c353
< 			EditPart gep = (EditPart) li.next();
< 			if (gep instanceof ConnectionEditPart) {
< 				ConnectionEditPart poly = (ConnectionEditPart) gep;
< 
< 				if (!layoutTopDown(poly)) {
---
> 			ConnectionEditPart poly = (ConnectionEditPart) li.next();
340c356,359
< 
---
>             if (from instanceof IBorderItemEditPart)
>                 from = from.getParent();
>             if (to instanceof IBorderItemEditPart)
>                 to = to.getParent();
349,351d367
< 			}
< 		}
< 
453,458c469,477
< 			ShapeEditPart shapeEP = (ShapeEditPart) e;
< 			List sourceConnections = shapeEP.getSourceConnections();
< 			for (int i = 0; i < sourceConnections.size(); i++) {
< 				ConnectionEditPart connectionEP = (ConnectionEditPart) sourceConnections
< 					.get(i);
< 				EditPart target = connectionEP.getTarget();
---
> 			GraphicalEditPart shapeEP = (GraphicalEditPart) e;
>             Set sourceConnections = new HashSet(shapeEP.getSourceConnections());
>             if (shapeEP instanceof IBorderedShapeEditPart){
>                 List borderItems = getBorderItemEditParts(shapeEP);
>                 for (Iterator iter = borderItems.iterator(); iter.hasNext();) {
>                     GraphicalEditPart element = (GraphicalEditPart) iter.next();
>                     sourceConnections.addAll(element.getSourceConnections());
>                 }
>             }
459a479,482
> 			for (Iterator iter = sourceConnections.iterator();
>                     iter.hasNext();) {
> 				ConnectionEditPart connectionEP = (ConnectionEditPart) iter.next();
> 				EditPart target = connectionEP.getTarget();
461a485,486
> 				if (target instanceof IBorderItemEditPart)
>                     target = target.getParent();
472a498,514
>      * This method searches an edit part for a child that is a border item edit part
>      * @param parent part needed to search
>      * @param set to be modified of border item edit parts that are direct children of the parent
>      */
>     private List getBorderItemEditParts(EditPart parent) {
>         Iterator iter = parent.getChildren().iterator();
>         List list = new ArrayList();
>         while(iter.hasNext()) {
>             EditPart child = (EditPart)iter.next();
>             if( child instanceof IBorderItemEditPart ) {
>                 list.add(child);
>             }
>         }
>         return list;
>     }
> 
> 	/**
483c525
< 	private void build_graph(DirectedGraph g, List selectedObjects) {
---
> 	protected void build_graph(DirectedGraph g, List selectedObjects) {
485d526
< 
488,489c529
< 
< 		NodeList nodes = build_nodes(selectedObjects, editPartToNodeDict);
---
>         NodeList nodes = build_nodes(selectedObjects, editPartToNodeDict,null);
495d534
< 
497d535
< 
499a538,540
>         postProcessGraph(g,editPartToNodeDict);
>         //printGraph(g);
>      }
501,505c542,543
< 		//new BreakCycles().visit(g);
< 				
< 		// this has to be called after - BreakCycles to ensure we are fully
< 		// connected.
< 		//connectNonConnectedSubgraphs(nodes, edges);
---
>     protected void postProcessGraph(DirectedGraph g, Hashtable editPartToNodeDict) {
>         //default do nothing
599c637
< 	Command update_diagram(GraphicalEditPart diagramEP, DirectedGraph g,
---
> 	protected Command update_diagram(GraphicalEditPart diagramEP, DirectedGraph g,
606c644
< 		Command cmd = getShapesPositionCommand(g, diff);
---
> 		Command cmd = createNodeChangeBoundCommands(g, diff);
610c648
< 		cmd = getConnectionPositionCommand(g, diff);
---
> 		cmd = createEdgesChangeBoundsCommands(g, diff);
624c662
< 	private Command getConnectionPositionCommand(DirectedGraph g, Point diff) {
---
> 	protected Command createEdgesChangeBoundsCommands(DirectedGraph g, Point diff) {
633c671
< 			if (edge.data == null)
---
> 			if (edge.data == null || edge.getPoints()==null)
662,663c700,703
< 		Point startpt = edge.getPoints().getFirstPoint();
< 		Rectangle start = translateFromGraph(new Rectangle(startpt.x, startpt.y, 0, 0));
---
>         PointList pointList = edge.getPoints();
>         Rectangle start = translateFromGraph(
>             new Rectangle(pointList.getFirstPoint().x,
>                           pointList.getFirstPoint().y, 0, 0));
665d704
< 
677,679c716,717
< 
< 		Point endpt = edge.getPoints().getLastPoint();
< 		Rectangle end = translateFromGraph(new Rectangle(endpt.x, endpt.y, 0, 0));
---
>         Rectangle end = translateFromGraph(new Rectangle(pointList.getLastPoint().x,
>             pointList.getLastPoint().y, 0, 0));
683c721
< 	private Command getShapesPositionCommand(DirectedGraph g, Point diff) {
---
> 	protected Command createNodeChangeBoundCommands(DirectedGraph g, Point diff) {
685d722
< 
686a724,728
> 		createSubCommands(diff, vi, cc);
> 	    if (cc.isEmpty())
> 			return null;
> 		return cc;
> 	}
687a730
>     protected void createSubCommands(Point diff, ListIterator vi, CompoundCommand cc) {
712c755
< 				if (cmd != null)
---
> 				if (cmd != null && cmd.canExecute())
716,719d758
< 		
< 		if (cc.isEmpty())
< 			return null;
< 		return cc;
748a788,857
>     
>     /**
>      * Creates the graph that will be used by the layouy provider
>      * Clients can override this method create different kind of graphs
>      * This method is called by {@link DefaultProvider#layoutEditParts(GraphicalEditPart, IAdaptable) } 
>      * and {@link DefaultProvider#layoutEditParts(List, IAdaptable)}  
>      * @return the Graph that will be used by the layout algorithm
>      */
>     protected DirectedGraph createGraph(){
>         return new DirectedGraph();
>     }
>     
>     /**
>      * Creates the graph layout algorithm that will be used to layout the diagram
>      * This method is called by {@link DefaultProvider#layoutEditParts(GraphicalEditPart, IAdaptable) } 
>      * and {@link DefaultProvider#layoutEditParts(List, IAdaptable)}  
>      * @return the graph layout 
>      */
>     protected DirectedGraphLayout createGraphLayout() {
>         return new DirectedGraphLayout();
>     }
>     
>    /* private void printGraph(DirectedGraph g){
>         int depth = 0;
>         if (g instanceof CompoundDirectedGraph){
>             NodeList subGraphs = ((CompoundDirectedGraph)g).nodes;
>             for (Iterator iter = subGraphs.iterator(); iter.hasNext();) {
>                 Node node = (Node)iter.next();
>                 if (node.getParent()!=null)
>                     continue;
>                 if (node instanceof Subgraph){
>                     printSubGraph((Subgraph)node,depth);
>                 }else {
>                     printNode(node,depth);
>                 }
>             }
>         }
>     }
> 
>     private void printNode(Node node, int depth) {
>         StringBuffer buffer = new StringBuffer();
>         for (int i =0 ; i<depth ; i++)
>             buffer.append("\t");
>         buffer.append("Node");
>         System.out.println(buffer);
>     }
> 
>     private void printSubGraph(Subgraph subgraph, int depth) {
>         StringBuffer buffer = new StringBuffer();
>         for (int i =0 ; i<depth ; i++)
>             buffer.append("\t");
>         buffer.append("SubGraph");
>         if (!subgraph.members.isEmpty()){
>             buffer.append(" : ");
>             System.out.println(buffer);
>             NodeList nodes = subgraph.members;
>             depth++;
>             for (Iterator iter = nodes.iterator(); iter.hasNext();) {
>                 Node element = (Node) iter.next();
>                 if (element instanceof Subgraph){
>                     printSubGraph((Subgraph)element,depth);
>                 }else {
>                     printNode(element,depth);
>                 }
>             }
>         }else {
>             System.out.println(buffer);
>         }
>             
>     }*/
