40,42c40,41
<  * An adapter that maintains itself as an adapter for all contained objects. It
<  * can be installed for an {@link EObject}, a {@link Resource}, or a
<  * {@link ResourceSet}.
---
>  * An adapter that maintains itself as an adapter for all contained objects.
>  * It can be installed for an {@link EObject}, a {@link Resource}, or a {@link ResourceSet}.
44,45c43,44
<  * This adapter maintain information on inverse references, resource imports,
<  * and resource exports.
---
>  * This adapter maintain information on inverse references, resource imports, and resource
>  * exports.
58a58,63
> 	 * Flag used to check if the invocations of the setTarget are occuring
> 	 * due to containment change notifications.
> 	 */
> 	private boolean isProcessingNotification = false;
> 	
> 	/**
68,69c73
< 	 * @param resolve
< 	 *            flag to determine if the proxies need to be resolved
---
> 	 * @param resolve flag to determine if the proxies need to be resolved
80,81c84
< 	 * @param notification
< 	 *            the event notification
---
> 	 * @param notification the event notification
91,94c94,95
< 			if (notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_LOADED ) {
< 				if ( notification.getNewBooleanValue() ) {
< 					updateImportsAndExports((Resource) notifier);
< 				} else {
---
> 			if (notification.getFeatureID(Resource.class) == Resource.RESOURCE__IS_LOADED
> 					&& !notification.getNewBooleanValue()) {
97,98d97
< 			}
< 
105c104,105
< 		if (!(notifier instanceof EObject) || !(feature instanceof EReference)) {
---
> 		if (!(notifier instanceof EObject)
> 				|| !(feature instanceof EReference)) {
109a110,112
> 		if (reference.isContainment()) {
> 			return;
> 		}
115,118d117
< 			if (reference.isContainment()) {
< 				break;
< 			}
< 
121,122c120,122
< 				deregisterReference(((EObject) notification.getNotifier())
< 						.eResource(), oldValue.eResource());
---
> 					deregisterReference(
> 							((EObject)notification.getNotifier()).eResource(),
> 							oldValue.eResource());
126,127c126,128
< 				registerReference(((EObject) notification.getNotifier())
< 						.eResource(), newValue.eResource());
---
> 					registerReference(
> 							((EObject)notification.getNotifier()).eResource(),
> 							newValue.eResource());
134,139c135,137
< 				if (!reference.isContainment()) {
< 					registerReference(((EObject) notification.getNotifier())
< 							.eResource(), newValue.eResource());
< 				} else {
< 					updateImportsAndExports(newValue, true);
< 				}
---
> 					registerReference(
> 							((EObject)notification.getNotifier()).eResource(),
> 							newValue.eResource());
147,152c145,147
< 				if (!reference.isContainment()) {
< 					registerReference(((EObject) notification.getNotifier())
< 							.eResource(), newValue.eResource());
< 				} else {
< 					updateImportsAndExports(newValue, true);
< 				}
---
> 					registerReference(
> 							((EObject)notification.getNotifier()).eResource(),
> 							newValue.eResource());
159,164c154,156
< 				if (!reference.isContainment()) {
< 					deregisterReference(((EObject) notification.getNotifier())
< 							.eResource(), oldValue.eResource());
< 				} else {
< 					updateImportsAndExports(oldValue, false);
< 				}
---
> 					deregisterReference(
> 							((EObject)notification.getNotifier()).eResource(),
> 							oldValue.eResource());
172,177c164,166
< 				if (!reference.isContainment()) {
< 					deregisterReference(((EObject) notification.getNotifier())
< 							.eResource(), oldValue.eResource());
< 				} else {
< 					updateImportsAndExports(oldValue, false);
< 				}
---
> 					deregisterReference(
> 							((EObject)notification.getNotifier()).eResource(),
> 							oldValue.eResource());
208,209c197
< 					resource = ((EObject) notification.getNotifier())
< 							.eResource();
---
> 					resource = ((EObject) notification.getNotifier()).eResource();
247,249c235,236
< 	private void remove(Resource resource, EObject eObject) {
< 		for (Iterator allContents = EcoreUtil.getAllContents(Collections
< 				.singleton(eObject)); allContents.hasNext();) {
---
> 	protected void remove(Resource resource, EObject eObject) {
> 		for (Iterator allContents = EcoreUtil.getAllContents(Collections.singleton(eObject)); allContents.hasNext();) {
253,254c240,241
< 			EContentsEList.FeatureIterator crossReferences = (EContentsEList.FeatureIterator) next
< 					.eCrossReferences().iterator();
---
> 		    EContentsEList.FeatureIterator crossReferences =
> 		    	(EContentsEList.FeatureIterator) next.eCrossReferences().iterator();
259,260c246
< 					EReference eReference = (EReference) crossReferences
< 							.feature();
---
> 					EReference eReference = (EReference) crossReferences.feature();
276,279c262,263
< 			for (Iterator iter = getNonNavigableInverseReferencers(next, null,
< 					null).iterator(); iter.hasNext();) {
< 				deregisterReference(((EObject) iter.next()).eResource(),
< 						resource);
---
> 			for (Iterator iter = getNonNavigableInverseReferencers(next, null, null).iterator(); iter.hasNext();) {
> 				deregisterReference(((EObject)iter.next()).eResource(), resource);
303,304c287
< 					EReference eReference = (EReference) crossReferences
< 							.feature();
---
> 					EReference eReference = (EReference) crossReferences.feature();
312a296,304
> 			
> 			// need to process containment changes. This will compute references
> 			// from existing EObjects to the added EObjects. This would happen when detached
> 			// EObjects are referenced by the existing EObjects
> 			if (isProcessingNotification) {
> 				for (Iterator iter = getInverseReferencers(eObject, null, null).iterator(); iter.hasNext();) {
> 					registerReference(((EObject)iter.next()).eResource(), resource);
> 				}
> 			}
329,330c321
< 	 * @param referencer
< 	 *            the resource to retrieve imports for
---
> 	 * @param referencer the resource to retrieve imports for
347,348c338
< 	 * @param referenced
< 	 *            the resource to retrieve exports for
---
> 	 * @param referenced the resource to retrieve exports for
383c373,374
< 	 * Registers a reference updating the imports and exports maps accordingly.
---
> 	 * Registers a reference updating the imports and exports maps
> 	 * accordingly.
385,388c376,377
< 	 * @param referencer
< 	 *            the referencing resource
< 	 * @param referenced
< 	 *            the referenced resouce
---
> 	 * @param referencer the referencing resource
> 	 * @param referenced the referenced resouce
438,445c427,431
< 	 * import of the <code>referenced</code> resource by the
< 	 * <code>referencer</code>. This implementation does nothing; subclasses
< 	 * need not call <code>super</code>.
< 	 * 
< 	 * @param referencer
< 	 *            the referencing resource (doing the importing)
< 	 * @param referenced
< 	 *            the resource that it references
---
> 	 * import of the <code>referenced</code> resource by the <code>referencer</code>.
> 	 * This implementation does nothing; subclasses need not call <code>super</code>.
> 	 * 
> 	 * @param referencer the referencing resource (doing the importing)
> 	 * @param referenced the resource that it references
452,460c438,443
< 	 * Hook to be implemented by subclasses upon the elimination of an import of
< 	 * the <code>referenced</code> resource by the <code>referencer</code>.
< 	 * This implementation does nothing; subclasses need not call
< 	 * <code>super</code>.
< 	 * 
< 	 * @param referencer
< 	 *            the formerly referencing resource (doing the importing)
< 	 * @param referenced
< 	 *            the resource that it had referenced
---
> 	 * Hook to be implemented by subclasses upon the elimination of an
> 	 * import of the <code>referenced</code> resource by the <code>referencer</code>.
> 	 * This implementation does nothing; subclasses need not call <code>super</code>.
> 	 * 
> 	 * @param referencer the formerly referencing resource (doing the importing)
> 	 * @param referenced the resource that it had referenced
468,475c451,455
< 	 * export of the <code>referenced</code> resource to the
< 	 * <code>referencer</code>. This implementation does nothing; subclasses
< 	 * need not call <code>super</code>.
< 	 * 
< 	 * @param referenced
< 	 *            the resource being referenced (doing the exporting)
< 	 * @param referencer
< 	 *            the referencing resource
---
> 	 * export of the <code>referenced</code> resource to the <code>referencer</code>.
> 	 * This implementation does nothing; subclasses need not call <code>super</code>.
> 	 * 
> 	 * @param referenced the resource being referenced (doing the exporting)
> 	 * @param referencer the referencing resource
482,490c462,467
< 	 * Hook to be implemented by subclasses upon the elimination of an export of
< 	 * the <code>referenced</code> resource to the <code>referencer</code>.
< 	 * This implementation does nothing; subclasses need not call
< 	 * <code>super</code>.
< 	 * 
< 	 * @param referenced
< 	 *            the resource formerly being referenced (doing the exporting)
< 	 * @param referencer
< 	 *            the formerly referencing resource
---
> 	 * Hook to be implemented by subclasses upon the elimination of an
> 	 * export of the <code>referenced</code> resource to the <code>referencer</code>.
> 	 * This implementation does nothing; subclasses need not call <code>super</code>.
> 	 * 
> 	 * @param referenced the resource formerly being referenced (doing the exporting)
> 	 * @param referencer the formerly referencing resource
500,503c477,478
< 	 * @param referencer
< 	 *            the referencing resource
< 	 * @param referenced
< 	 *            the referenced resource
---
> 	 * @param referencer the referencing resource
> 	 * @param referenced the referenced resource
550,601d524
< 	 * Updates the imports and exports by walking the contents of the specified
< 	 * resource and finding any referencers to these EObjects. This is for the
< 	 * cross reference adapter to synchronize the imports and exports when
< 	 * resources are loaded after the adapter is already attached
< 	 */
< 	private void updateImportsAndExports(Resource resource) {
< 		for (Iterator i = EcoreUtil.getAllContents(resource, resolve()); i
< 				.hasNext();) {
< 			EObject next = (EObject) i.next();
< 			for (Iterator iter = getInverseReferencers(next, null, null)
< 					.iterator(); iter.hasNext();) {
< 				registerReference(((EObject) iter.next()).eResource(), resource);
< 			}
< 		}
< 	}
< 
< 	/**
< 	 * Updates the imports and exports by walking the contents of the specified
< 	 * EObject and finding any referencers to these EObjects. This is for the
< 	 * cross reference adapter to synchronize the imports and exports when
< 	 * eObjects are added or removed
< 	 */
< 	private void updateImportsAndExports(EObject eObject, boolean register) {
< 		Resource resource = eObject.eResource();
< 
< 		for (Iterator iter = getInverseReferencers(eObject, null, null)
< 				.iterator(); iter.hasNext();) {
< 			if (register) {
< 				registerReference(((EObject) iter.next()).eResource(), resource);
< 			} else {
< 				deregisterReference(((EObject) iter.next()).eResource(),
< 						resource);
< 			}
< 		}
< 
< 		for (Iterator i = EcoreUtil.getAllContents(eObject, resolve()); i
< 				.hasNext();) {
< 			EObject next = (EObject) i.next();
< 			for (Iterator iter = getInverseReferencers(next, null, null)
< 					.iterator(); iter.hasNext();) {
< 				if (register) {
< 					registerReference(((EObject) iter.next()).eResource(),
< 							resource);
< 				} else {
< 					deregisterReference(((EObject) iter.next()).eResource(),
< 							resource);
< 				}
< 			}
< 		}
< 	}
< 
< 	/**
604,605c527
< 	 * @param referencer
< 	 *            the referencing resource
---
> 	 * @param referencer the referencing resource
642a565
> 
644,656c567,575
< 	 * Returns a Set of EObjects that reference the given EObject. If an
< 	 * EReference is specified, the scope of the search is limited only to that
< 	 * EReference. To include all references specify a value of null. If an
< 	 * EClass type is specified, the returned Set will only include those
< 	 * referencers that match the given type. To include all types specify a
< 	 * value of null.
< 	 * 
< 	 * @param referenced
< 	 *            the referenced EObject
< 	 * @param reference
< 	 *            the reference to find referencers on, null for any reference
< 	 * @param type
< 	 *            the type of the referencers, use null for any type
---
> 	 * Returns a Set of EObjects that reference the given EObject.
> 	 * If an EReference is specified, the scope of the search is limited
> 	 * only to that EReference. To include all references specify a value of null.
> 	 * If an EClass type is specified, the returned Set will only include those
> 	 * referencers that match the given type. To include all types specify a value of null.
> 	 * 
> 	 * @param referenced the referenced EObject
> 	 * @param reference the reference to find referencers on, null for any reference
> 	 * @param type the type of the referencers, use null for any type
659,660c578
< 	public Set getInverseReferencers(EObject referenced, EReference reference,
< 			EClass type) {
---
> 	public Set getInverseReferencers(EObject referenced, EReference reference, EClass type) {
667,677c585,592
< 	 * search is limited only to that EReference. To include all references
< 	 * specify a value of null. If an EClass type is specified, the returned Set
< 	 * will only include those referencers that match the given type. To include
< 	 * all types specify a value of null.
< 	 * 
< 	 * @param referenced
< 	 *            the referenced EObject
< 	 * @param reference
< 	 *            the reference to find referencers on, null for any reference
< 	 * @param type
< 	 *            the type of the referencers, use null for any type
---
> 	 * search is limited only to that EReference. To include all references specify
> 	 * a value of null. If an EClass type is specified, the returned Set will only
> 	 * include those referencers that match the given type. To include all types
> 	 * specify a value of null.
> 	 * 
> 	 * @param referenced the referenced EObject
> 	 * @param reference the reference to find referencers on, null for any reference
> 	 * @param type the type of the referencers, use null for any type
680,683c595,596
< 	public Set getNonNavigableInverseReferencers(EObject referenced,
< 			EReference reference, EClass type) {
< 		return getReferencers(getNonNavigableInverseReferences(referenced),
< 				reference, type);
---
> 	public Set getNonNavigableInverseReferencers(EObject referenced, EReference reference, EClass type) {
> 		return getReferencers(getNonNavigableInverseReferences(referenced), reference, type);
687,695c600,605
< 	 * Extracts the EObjects from the EStructuralFeature.Setting references and
< 	 * returns a filtered Set based on the given reference and type.
< 	 * 
< 	 * @param references
< 	 *            a collection of EStructuralFeature.Setting
< 	 * @param reference
< 	 *            the reference to find referencers on, null for any reference
< 	 * @param type
< 	 *            the type of the referencers, use null for any type
---
> 	 * Extracts the EObjects from the EStructuralFeature.Setting references
> 	 * and returns a filtered Set based on the given reference and type.
> 	 * 
> 	 * @param references a collection of EStructuralFeature.Setting
> 	 * @param reference the reference to find referencers on, null for any reference
> 	 * @param type the type of the referencers, use null for any type
698,699c608
< 	private Set getReferencers(Collection references, EReference reference,
< 			EClass type) {
---
> 	private Set getReferencers(Collection references, EReference reference, EClass type) {
704,705c613
< 				if (reference == null
< 						|| reference == setting.getEStructuralFeature()) {
---
> 				if (reference == null || reference == setting.getEStructuralFeature()) {
707,708c615
< 					if (referencer != null
< 							&& (type == null || type.isInstance(referencer))) {
---
> 					if (referencer != null && (type == null || type.isInstance(referencer))) {
718,719c625,626
< 	 * Searches the adapter list of the given Notifier for a
< 	 * CrossReferenceAdapter. If not found, returns null.
---
> 	 * Searches the adapter list of the given Notifier for a CrossReferenceAdapter.
> 	 * If not found, returns null.
721,722c628
< 	 * @param notifier
< 	 *            the notifier to search
---
> 	 * @param notifier the notifier to search
725,726c631
< 	public static CrossReferenceAdapter getExistingCrossReferenceAdapter(
< 			Notifier notifier) {
---
> 	public static CrossReferenceAdapter getExistingCrossReferenceAdapter(Notifier notifier) {
743,744c648,649
< 	 * Obtains the cross-reference adapter for the specified resource set, if
< 	 * necessary creating it and attaching it.
---
> 	 * Obtains the cross-reference adapter for the specified resource set,
> 	 * if necessary creating it and attaching it.
746,747c651
< 	 * @param resourceSet
< 	 *            the resource set
---
> 	 * @param resourceSet the resource set
751,752c655
< 	public static CrossReferenceAdapter getCrossReferenceAdapter(
< 			ResourceSet resourceSet) {
---
> 	public static CrossReferenceAdapter getCrossReferenceAdapter(ResourceSet resourceSet) {
757c660,661
< 		CrossReferenceAdapter result = getExistingCrossReferenceAdapter(resourceSet);
---
> 		CrossReferenceAdapter result = getExistingCrossReferenceAdapter(
> 			resourceSet);
799,800c703
< 		 * @return <code>true</code> if I am now zero; <code>false</code>,
< 		 *         otherwise
---
> 		 * @return <code>true</code> if I am now zero; <code>false</code>, otherwise
826,830c729,731
< 	    EContentsEList.FeatureIterator crossReferences =
< 	    	(EContentsEList.FeatureIterator) eObject.eCrossReferences().iterator();
< 		while (crossReferences.hasNext()) {
< 			InternalEObject referent = (InternalEObject) crossReferences.next();
< 			EReference eReference = (EReference) crossReferences.feature();
---
> 	    for (Iterator i = eObject.eClass().getEAllReferences().iterator(); i.hasNext(); )
> 	    {
> 	      EReference eReference = (EReference)i.next();
832,834c733,750
< 			
< 			if (referent != null && eOpposite != null) {
< 				result.add(referent.eSetting(eOpposite));
---
> 	      if (eOpposite != null && !eReference.isContainer() && !eReference.isContainment() && eObject.eIsSet(eReference))
> 	      {
> 	        if (eReference.isMany())
> 	        {
> 	          for (Iterator j = ((Collection)eObject.eGet(eReference)).iterator(); j.hasNext(); )
> 	          {
> 	            InternalEObject referencingEObject = (InternalEObject)j.next();
> 	            result.add(referencingEObject.eSetting(eOpposite));
> 	          }
> 	        }
> 	        else
> 	        {
> 	        	// although the reference is set, the value could be null
> 	        	InternalEObject referencingEObject = ((InternalEObject)eObject.eGet(eReference));
> 	        	if ( referencingEObject != null ) {
> 	        		result.add(referencingEObject.eSetting(eOpposite));
> 	        	}
> 	        }
839a756,764
> 
> 	public final void notifyChanged(Notification notification) {
> 		try {
> 			isProcessingNotification = true;
> 			super.notifyChanged(notification);
> 		} finally {
> 			isProcessingNotification = false;
> 		}
> 	}	
