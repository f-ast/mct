35a36,38
> import org.eclipse.emf.transaction.util.TransactionUtil;
> import org.eclipse.emf.workspace.EMFOperationCommand;
> import org.eclipse.gmf.runtime.diagram.core.internal.commands.PersistElementCommand;
40d42
< 
47c49,50
< public class DiagramEventBroker extends ResourceSetListenerImpl {
---
> public class DiagramEventBroker
>     extends ResourceSetListenerImpl {
52a56
> 
202,203c206
< 	public static void startListening(
< 			TransactionalEditingDomain editingDomain) {
---
>     public static void startListening(TransactionalEditingDomain editingDomain) {
216,217c219
<     public static void stopListening(
<             TransactionalEditingDomain editingDomain) {
---
>     public static void stopListening(TransactionalEditingDomain editingDomain) {
224a227,231
>     /*
>      * (non-Javadoc)
>      * 
>      * @see org.eclipse.emf.transaction.ResourceSetListenerImpl#transactionAboutToCommit(org.eclipse.emf.transaction.ResourceSetChangeEvent)
>      */
227d233
<  
231,236c237
<             Object eventFeature = notification.getFeature();
< 
<             // ignore touch event if it is not a resolve event,and ignore the mutable feature
<             // events
<             if ((notification.isTouch() && notification.getEventType() != Notification.RESOLVE)||
<                  NotationPackage.eINSTANCE.getView_Mutable().equals(eventFeature)){
---
>             if (shouldIgnoreNotification(notification))
238,239d238
<             }
<             
251c250,251
<         return cc.isEmpty() ? null : cc;
---
>         return cc.isEmpty() ? null
>             : cc;
253a254,258
>     /*
>      * (non-Javadoc)
>      * 
>      * @see org.eclipse.emf.transaction.ResourceSetListenerImpl#resourceSetChanged(org.eclipse.emf.transaction.ResourceSetChangeEvent)
>      */
259,264c264
< 			Object eventFeature = notification.getFeature();
< 
< 			// ignore touch event if it is not a resolve event,and ignore the mutable feature
< 			// events
< 			if ((notification.isTouch() && notification.getEventType() != Notification.RESOLVE)||
< 			     NotationPackage.eINSTANCE.getView_Mutable().equals(eventFeature)){
---
>             if (shouldIgnoreNotification(notification))
266d265
< 			}
279c278,294
< 
---
>     /**
>      * determine if the passed notification can be ignored or not the default
>      * implementation will ignore touch event if it is not a resolve event, also
>      * it will ignore the mutable feature events
>      * 
>      * @param notification
>      *            the notification to check
>      * @return true if the notification should be ignored, otherwise false
>      */
>     protected boolean shouldIgnoreNotification(Notification notification) {
>         if ((notification.isTouch() && notification.getEventType() != Notification.RESOLVE)
>             || NotationPackage.eINSTANCE.getView_Mutable().equals(
>                 notification.getFeature())) {
>             return true;
>         }
>         return false;
>     }
291c306,307
< 		Collection listenerList = getInterestedNotificationListeners(event, false);
---
>         Collection listenerList = getInterestedNotificationListeners(event,
>             false);
307a324,325
>         CompoundCommand cc = new CompoundCommand();
>         preparePersistCommand(event,cc);
311c329
< 				CompoundCommand cc = new CompoundCommand();
---
>                 
324a343,344
>         
>         if (cc.isEmpty())
325a346,368
>         
>         return cc;
>     }
> 
>     private void preparePersistCommand(Notification event, CompoundCommand cc) {
>         PersistElementCommand persistCmd = null;
>         if (!event.isTouch()) {
>             EObject elementToPersist = (EObject) event.getNotifier();
>             while (elementToPersist != null && !(elementToPersist instanceof View)) {
>                 elementToPersist = elementToPersist.eContainer();
>             }
>             if (elementToPersist != null
>                 && (NotationPackage.eINSTANCE.getView_TransientChildren() == elementToPersist
>                     .eContainingFeature() || NotationPackage.eINSTANCE
>                     .getDiagram_TransientEdges() == elementToPersist
>                     .eContainingFeature())) {
>                 if (!NotificationFilter.READ.matches(event)) {
>                     persistCmd = getPersistViewCommand((View)elementToPersist);
>                 }
>             }
>         }
>         if (persistCmd!=null)
>             cc.append(new EMFOperationCommand(persistCmd.getEditingDomain(),persistCmd));
373a417
> 
402c446,447
< 			preListeners.removeListener(target, LISTEN_TO_ALL_FEATURES, listener);
---
>             preListeners.removeListener(target, LISTEN_TO_ALL_FEATURES,
>                 listener);
417c462,463
< 			postListeners.removeListener(target, LISTEN_TO_ALL_FEATURES, listener);
---
>             postListeners.removeListener(target, LISTEN_TO_ALL_FEATURES,
>                 listener);
453a500
> 
475d521
< 
482,483c528,531
< 	private Set getNotificationListeners(Object notifier, Object key, boolean preCommit) {
< 		NotifierToKeyToListenersSetMap listeners = preCommit ? preListeners : postListeners;
---
>     private Set getNotificationListeners(Object notifier, Object key,
>             boolean preCommit) {
>         NotifierToKeyToListenersSetMap listeners = preCommit ? preListeners
>             : postListeners;
509c557,558
< 	private Set getInterestedNotificationListeners(Notification event, boolean preCommit) {
---
>     private Set getInterestedNotificationListeners(Notification event,
>             boolean preCommit) {
519,525c568,577
< 		//the Visibility Event get fired to all interested listeners in the container
< 		if (NotationPackage.eINSTANCE.getView_Visible().equals(event.getFeature()) &&
< 			notifier.eContainer()!=null){
< 				listenerSet.addAll(getNotificationListeners(notifier.eContainer(), preCommit));
< 		}
< 		else if (notifier instanceof EAnnotation) {
< 			addListenersOfNotifier(listenerSet, notifier.eContainer(), event, preCommit);
---
>         // the Visibility Event get fired to all interested listeners in the
>         // container
>         if (NotationPackage.eINSTANCE.getView_Visible().equals(
>             event.getFeature())
>             && notifier.eContainer() != null) {
>             listenerSet.addAll(getNotificationListeners(notifier.eContainer(),
>                 preCommit));
>         } else if (notifier instanceof EAnnotation) {
>             addListenersOfNotifier(listenerSet, notifier.eContainer(), event,
>                 preCommit);
534a587,590
>     public boolean isAggregatePrecommitListener() {
>         return true;
>     }
> 
572d627
< 
575a631
>     
583,584d638
< 		
< 		if (!event.isTouch()) {
586,594c640,641
< 			while (element != null && !(element instanceof View)) {
< 				element = element.eContainer();
< 			}
< 			if (element != null && 
<                 (NotationPackage.eINSTANCE.getView_TransientChildren()==element.eContainingFeature() ||
<                  NotationPackage.eINSTANCE.getDiagram_TransientEdges()==element.eContainingFeature())) {
<                 if (!NotificationFilter.READ.matches(event)) {
<                     ViewUtil.persistElement((View) element);
<                 }
---
>         if (element != null) {
>             fireNotification(event);
598,600c645,661
< 		EObject element = (EObject) event.getNotifier();
< 		if (element != null) {
< 			fireNotification(event);
---
>     /**
>      * Returns a persisted view command. This command if executed will persisted
>      * the passed view and all its required parents.
>      * @param view the view to persist
>      * @return the command to persist the view; the return value can be null
>      */
>     private PersistElementCommand getPersistViewCommand(View view) {
>         PersistElementCommand pvc = null;
>         // only immutable views can be persisted
>         if (!view.isMutable()) {
>             TransactionalEditingDomain editingDomain = TransactionUtil.getEditingDomain(view);
>             // get Top view needs to get persisted
>             View viewToPersist = ViewUtil.getTopViewToPersist(view);
>             if (viewToPersist!=null){
>                 // now the command that will persist the view
>                 //Map options = Collections.singletonMap( Transaction.OPTION_UNPROTECTED, Boolean.TRUE);
>                 pvc = new PersistElementCommand(editingDomain, viewToPersist /*, options*/);
602a664
>         return pvc;
604a667
> }
