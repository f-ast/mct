2c2
<  * Copyright (c) 2002, 2006 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2007 IBM Corporation and others.
15a16
> import org.eclipse.draw2d.IFigure;
18a20
> import org.eclipse.draw2d.geometry.PrecisionRectangle;
161,163c163
< 				bBoxF =
< 					new Rectangle(
< 						conn.getSourceAnchor().getOwner().getBounds());
---
> 				bBoxF = getBounds(conn.getSourceAnchor().getOwner());
171,173c171
< 				bBoxT =
< 					new Rectangle(
< 						conn.getTargetAnchor().getOwner().getBounds());
---
>                 bBoxT = getBounds(conn.getTargetAnchor().getOwner());
247,251c245,270
< 		LineSeg edgeLine1 =
< 			OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, conn.getSourceAnchor(), newLine.getPoint(1));
<         
< 		LineSeg edgeLine2 =
< 			OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc(conn, conn.getTargetAnchor(), newLine.getPoint(newLine.size() - 2));
---
>         Point origin = null;
>         if (conn.getSourceAnchor().getOwner() instanceof Connection) {
>             origin = getIntersectionPoint((Connection) conn.getSourceAnchor()
>                 .getOwner(), new LineSeg(newLine.getPoint(1), newLine
>                 .getPoint(0)));
>         }
>         if (origin == null) {
>             LineSeg edgeLine1 = OrthogonalRouterUtilities
>                 .getOrthogonalLineSegToAnchorLoc(conn, conn.getSourceAnchor(),
>                     newLine.getPoint(1));
>             origin = edgeLine1.getOrigin();
>         }
> 
>         Point terminus = null;
>         if (conn.getTargetAnchor().getOwner() instanceof Connection) {
>             int numPoints = newLine.size();
>             terminus = getIntersectionPoint((Connection) conn.getTargetAnchor()
>                 .getOwner(), new LineSeg(newLine.getPoint(numPoints - 2),
>                 newLine.getPoint(numPoints - 1)));
>         }
>         if (terminus == null) {
>             LineSeg edgeLine2 = OrthogonalRouterUtilities
>                 .getOrthogonalLineSegToAnchorLoc(conn, conn.getTargetAnchor(),
>                     newLine.getPoint(newLine.size() - 2));
>             terminus = edgeLine2.getOrigin();
>         }
253,254c272,273
< 		if (edgeLine1 != null && edgeLine2 != null) {
< 			newLine.setPoint(edgeLine1.getOrigin(), 0);
---
>         if (origin != null && terminus != null) {
>             newLine.setPoint(origin, 0);
265c284
< 			newLine.setPoint(edgeLine2.getOrigin(), newLine.size() - 1);
---
>             newLine.setPoint(terminus, newLine.size() - 1);
310,312c329,338
< 		// If this thing isn't rectilinear, then first try to turn it into a
< 		// biterminal and if that doesn't work, then try to route it.
< 		if (!isRectilinear && !updateToBiTerminal(conn, newLine)) {
---
>         // first see if it is already rectilinear already
>         if (isRectilinear && areEndsInBounds(conn, newLine)) {
>             return;
>         }
> 
>         // now try to turn it into a biterminal (i.e. one straight line)
>         if (updateToBiTerminal(conn, newLine) && areEndsInBounds(conn, newLine)) {
>             return;
>         }
> 
383d408
< 	}
552c577
<             Rectangle startRect = new Rectangle(conn.getSourceAnchor().getOwner().getBounds());
---
>             Rectangle startRect = getBounds(conn.getSourceAnchor().getOwner());
561c586
<             Rectangle endRect = new Rectangle(conn.getTargetAnchor().getOwner().getBounds());
---
>             Rectangle endRect = getBounds(conn.getTargetAnchor().getOwner());
584a610,674
>     
>     /**
>      * Returns true if the ends of the line passed in our within the bounds of
>      * the connection's source and target ends.
>      * 
>      * @param connection
>      *            the connection whose source and target ends will be looked at
>      * @param line
>      *            the line in question
>      * @return true if the two ends of the lines are within the bounds; false
>      *         otherwise
>      */
>     private boolean areEndsInBounds(Connection connection, PointList line) {
>         Rectangle startRect = new PrecisionRectangle(getBounds(connection
>             .getSourceAnchor().getOwner()));
>         connection.getSourceAnchor().getOwner().translateToAbsolute(startRect);
>         connection.translateToRelative(startRect);
> 
>         Rectangle endRect = new PrecisionRectangle(getBounds(connection
>             .getTargetAnchor().getOwner()));
>         connection.getTargetAnchor().getOwner().translateToAbsolute(endRect);
>         connection.translateToRelative(endRect);
> 
>         if (!startRect.contains(line.getPoint(0))
>             || !endRect.contains(line.getPoint(line.size() - 1))) {
>             return false;
>         }
>         return true;
>     }
> 
>     /**
>      * Returns a copy of the bounds of this figure or if the figure is a
>      * <code>Connection</code> the bounds of the pointlist will be returned.
>      * 
>      * @param figure
>      * @return a copy of the bounds
>      */
>     private Rectangle getBounds(IFigure figure) {
>         return figure instanceof Connection ? ((Connection) figure).getPoints()
>             .getBounds().getCopy()
>             : figure.getBounds().getCopy();
>     }
> 
>     /**
>      * Returns the closest intersection point from the line segment given that
>      * will extend to hit the connection passed in.
>      * 
>      * @param connection
>      *            the connection
>      * @param lineSeg
>      *            the line segment to extend to find intersections with the
>      *            connection
>      * @return the closeest intersecting point or null if there are none
>      */
>     private Point getIntersectionPoint(Connection connection, LineSeg lineSeg) {
> 
>         PointList intersections = lineSeg
>             .getLineIntersectionsWithLineSegs(connection.getPoints());
>         if (intersections.size() > 0) {
>             return PointListUtilities.pickClosestPoint(intersections, lineSeg
>                 .getOrigin());
>         }
> 
>         return null;
>     }
