2c2
<  * Copyright (c) 2002, 2006 IBM Corporation and others.
---
>  * Copyright (c) 2002, 2007 IBM Corporation and others.
19c19,20
< import org.eclipse.draw2d.FigureUtilities;
---
> import org.eclipse.core.runtime.Assert;
> import org.eclipse.draw2d.AncestorListener;
21d21
< import org.eclipse.draw2d.Label;
33d32
< import org.eclipse.gmf.runtime.diagram.ui.editparts.TextCompartmentEditPart;
36a36
> import org.eclipse.gmf.runtime.diagram.ui.label.ILabelDelegate;
37a38
> import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
39c40
< import org.eclipse.gmf.runtime.draw2d.ui.mapmode.IMapMode;
---
> import org.eclipse.gmf.runtime.draw2d.ui.figures.WrappingLabel;
49d49
< import org.eclipse.jface.util.Assert;
55d54
< import org.eclipse.swt.graphics.Image;
57a57
> import org.eclipse.swt.widgets.Composite;
69d68
< import com.ibm.icu.util.StringTokenizer;
94d92
< 
104a103
> 
105a105
> 
110,111d109
<     private CellEditorLocator locator;
<         
113,115c111,113
<      * the text cell editor locator
<      * @author mmostafa
<      *
---
>      * The superclass only relocates the cell editor when the location of the
>      * editpart's figure moves, but we need to also relocate the cell editor
>      * when the text figure's location changes.
117c115
<     static private class TextCellEditorLocator implements CellEditorLocator {
---
>     private AncestorListener textFigureListener;
119c117,120
<         private WrapLabel wrapLabel;
---
>     /**
>      * Cache locally so we can check if the user specified an editorType.
>      */
>     private Class editorType;
121,123c122,132
<         public TextCellEditorLocator(WrapLabel wrapLabel) {
<             super();
<             this.wrapLabel = wrapLabel;
---
>     /**
>      * constructor
>      * 
>      * @param source
>      *            <code>GraphicalEditPart</code> to support direct edit of.
>      *            The figure of the <code>source</code> edit part must be of
>      *            type <code>WrapLabel</code>.
>      */
>     public TextDirectEditManager(ITextAwareEditPart source) {
>         this(source, null,
>             getTextCellEditorLocator(source));
126,128c135,143
<         
<         public WrapLabel getWrapLabel() {
<             return wrapLabel;
---
>     /**
>      * @param source
>      * @param editorType
>      * @param locator
>      */
>     public TextDirectEditManager(GraphicalEditPart source, Class editorType,
>             CellEditorLocator locator) {
>         super(source, editorType, locator);
>         this.editorType = editorType;
130a146,160
>     /**
>      * @param source
>      *            the <code>ITextAwareEditPart</code> to determine the cell
>      *            editor for
>      * @return the <code>CellEditorLocator</code> that is appropriate for the
>      *         source <code>EditPart</code>
>      */
>     public static CellEditorLocator getTextCellEditorLocator(
>             final ITextAwareEditPart source) {
> 
>         final ILabelDelegate label = (ILabelDelegate) source
>             .getAdapter(ILabelDelegate.class);
>         if (label != null) {
>             return new CellEditorLocator() {
> 
133,136d162
<             WrapLabel fig = getWrapLabel();
<             
<             Rectangle rect = fig.getTextBounds().getCopy();
<             fig.translateToAbsolute(rect);
138,157c164,178
<             int avrWidth = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
<             
<             
<             if (fig.isTextWrapped() && fig.getText().length() > 0)
<                 rect.setSize(new Dimension(rect.width, rect.height + FigureUtilities.getFontMetrics(text.getFont()).getDescent()));
<             else
<                 rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avrWidth*2, 0));
<             
<             org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
<             
<             Rectangle textBounds = new Rectangle(text.getBounds());
<             if (!newRect.equals(textBounds)) {
<                 if (!(fig.getTextWrapAlignment() == PositionConstants.LEFT || fig.getTextAlignment() == PositionConstants.LEFT))
<                     text.setBounds(newRect.x, newRect.y, newRect.width + avrWidth*3, newRect.height);
<                 else {
<                     if (text.getBounds().x == 0 || Math.abs(text.getBounds().x - newRect.x) >= avrWidth)
<                         text.setBounds(newRect.x, newRect.y, newRect.width + avrWidth*3, newRect.height);
<                     else
<                         text.setBounds(text.getBounds().x, newRect.y, newRect.width + avrWidth*3, newRect.height);
<                 }   
---
>                     Rectangle rect = label.getTextBounds().getCopy();
>                     if (label.getText().length() <= 0) {
>                         // if there is no text, let's assume a default size
>                         // because it looks silly when the cell editor it tiny.
>                         rect.setSize(new Dimension(text.computeSize(
>                             SWT.DEFAULT, SWT.DEFAULT)));
> 
>                         if (label.isTextWrapOn()) {
>                             // adjust the location of the cell editor based on text
>                             // justification (i.e. where the cursor will be
>                             if (label.getTextJustification() == PositionConstants.RIGHT) {
>                                 rect.translate(-rect.width, 0);
>                             } else 
>                                 if (label.getTextJustification() == PositionConstants.CENTER) {
>                                 rect.translate(-rect.width / 2, 0);
162c183,192
<     private static class LabelCellEditorLocator implements CellEditorLocator {
---
>                     if (label.isTextWrapOn()) {
>                         // When zoomed in, the height of this rectangle is not
>                         // sufficient because the text is shifted downwards a
>                         // little bit. Add some to the height to compensate for
>                         // this. I'm not sure why this is happening, but I can
>                         // see the text shifting down even in a label on a GEF
>                         // logic diagram when zoomed into 400%.
>                         int charHeight = FigureUtilities.getFontMetrics(
>                             text.getFont()).getHeight();
>                         rect.resize(0, charHeight / 2);
164c194
<         private Label label;
---
>                     } else {
166,168c196,197
<         public LabelCellEditorLocator(Label label) {
<             this.label = label;
<         }
---
>                       rect.setSize(new Dimension(text.computeSize(
>                             SWT.DEFAULT, SWT.DEFAULT)));
170,171c199,208
<         public Label getLabel() {
<             return label;
---
>                         // If SWT.WRAP is not passed in as a style of the
>                         // TextCellEditor, then for some reason the first
>                         // character disappears upon entering the second 
>                         // character. This should be investigated and an 
>                         // SWT bug logged.
>                         int avr = FigureUtilities
>                             .getFontMetrics(text.getFont())
>                             .getAverageCharWidth();
>                         rect.setSize(new Dimension(text.computeSize(
>                             SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));
174,184c211,215
<         public void relocate(CellEditor celleditor) {
<             Text text = (Text) celleditor.getControl();
<             Rectangle rect = getLabel().getTextBounds().getCopy();
<             getLabel().translateToAbsolute(rect);
< 
<             int avr = FigureUtilities.getFontMetrics(text.getFont()).getAverageCharWidth();
<             rect.setSize(new Dimension(text.computeSize(SWT.DEFAULT, SWT.DEFAULT)).expand(avr * 2, 0));
< 
<             org.eclipse.swt.graphics.Rectangle newRect = text.computeTrim(rect.x, rect.y, rect.width, rect.height);
<             if (!newRect.equals(new Rectangle(text.getBounds())))
<                 text.setBounds(newRect.x, newRect.y, newRect.width, newRect.height);
---
>                     org.eclipse.swt.graphics.Rectangle newRect = text
>                         .computeTrim(rect.x, rect.y, rect.width, rect.height);
>                     if (!newRect.equals(text.getBounds())) {
>                         text.setBounds(newRect.x, newRect.y, newRect.width,
>                             newRect.height);
187,195c218
< 
<     /**
<      * constructor
<      * 
<      * @param source <code>GraphicalEditPart</code> to support direct edit of.  The figure of
<      * the <code>source</code> edit part must be of type <code>WrapLabel</code>.
<      */
<     public TextDirectEditManager(ITextAwareEditPart source) {
<         this(source, getTextCellEditorClass(source), getTextCellEditorLocator(source));
---
>             };
198,205c221,228
<     /**
<      * @param source
<      * @param editorType
<      * @param locator
<      */
<     public TextDirectEditManager(GraphicalEditPart source, Class editorType, CellEditorLocator locator) {
<         super(source, editorType, locator);
<         this.locator = locator;
---
>         // return a default figure locator
>         return new CellEditorLocator() {
>             public void relocate(CellEditor celleditor) {
>                 Text text = (Text) celleditor.getControl();
>                 Rectangle rect = source.getFigure().getBounds().getCopy();
>                 source.getFigure().translateToAbsolute(rect);
>                 if (!rect.equals(new Rectangle(text.getBounds()))) {
>                     text.setBounds(rect.x, rect.y, rect.width, rect.height);
207,219d229
< 
<     /**
<      * @param source the <code>ITextAwareEditPart</code> to determine the cell editor for
<      * @return the <code>CellEditorLocator</code> that is appropriate for the source <code>EditPart</code>
<      */
<     public static CellEditorLocator getTextCellEditorLocator(ITextAwareEditPart source){
<                
<         if (source instanceof TextCompartmentEditPart)
<             return new TextCellEditorLocator(((TextCompartmentEditPart)source).getLabel());
<         else {
<             IFigure figure = source.getFigure();
<             assert figure instanceof Label;
<             return new LabelCellEditorLocator((Label)figure);
220a231
>         };
224,226c235,243
<      * @param source the <code>GraphicalEditPart</code> that is used to determine which
<      * <code>CellEditor</code> class to use.
<      * @return the <code>Class</code> of the <code>CellEditor</code> to use for the text editing.
---
>      * @param source
>      *            the <code>GraphicalEditPart</code> that is used to determine
>      *            which <code>CellEditor</code> class to use.
>      * @return the <code>Class</code> of the <code>CellEditor</code> to use
>      *         for the text editing.
>      * @deprecated to override the cell editor class, use
>      *             {@link #createCellEditorOn(Composite)}, this provides the
>      *             flexibility necessary to initialize the cell editor with a
>      *             style.
236a254,291
>     /**
>      * This method is overridden so that the editor class can have a style as
>      * the style needs to be passed into the editor class when it is created. It
>      * will default to the super behavior if an <code>editorType</code> was
>      * passed into the constructor.
>      * @since 2.1
>      */
>     protected CellEditor createCellEditorOn(Composite composite) {
> 
>         // if the client has overridden this class and provided their own editor
>         // type, then we should use that
>         if (editorType != null) {
>             return super.createCellEditorOn(composite);
>         }
> 
>         ILabelDelegate label = (ILabelDelegate) getEditPart().getAdapter(
>             ILabelDelegate.class);
>         if (label != null && label.isTextWrapOn()) {
>             int style = SWT.WRAP | SWT.MULTI;
>             
>             switch (label.getTextJustification()) {
>                 case PositionConstants.LEFT:
>                     style = style | SWT.LEAD;
>                     break;
>                 case PositionConstants.RIGHT:
>                     style = style | SWT.TRAIL;
>                     break;
>                 case PositionConstants.CENTER:
>                     style = style | SWT.CENTER;
>                     break;
>                 default:
>                     break;
>             }
>             return new WrapTextCellEditor(composite, style);
>         } else {
>             return new TextCellEditorEx(composite);
>         }
>     }
239c294
<      * Given a <code>WrapLabel</code> object, this will calculate the 
---
>      * Given a label figure object, this will calculate the 
245c300
<      * @param label the <code>WrapLabel</code> to use for the font calculation
---
>      * @param label the label to use for the font calculation
485,502d539
<     /**
<      * Gets the tex extent scaled to the mapping mode
<      */
<     private Dimension getTextExtents(String s, Font font, IMapMode mm) {
<         Dimension d = FigureUtilities.getTextExtents(s, font);
<         // height should be set using the font height and the number of lines
<         // in the string 
<         int lineCount = getLineCount(s);
<         d.height = FigureUtilities.getFontMetrics(font).getHeight()*lineCount;
<         
<         return new Dimension(mm.DPtoLP(d.width), mm.DPtoLP(d.height));
<     }
< 
<     private int getLineCount(String s) {
<         StringTokenizer tokenizer = new StringTokenizer(s, "\n"); //$NON-NLS-1$
<         return tokenizer.countTokens();
<     }
< 
514c551
<         locator.relocate(getCellEditor());
---
>         getLocator().relocate(getCellEditor());
530,552d566
<         
<         Rectangle iconBounds;
<         Image icon;
<         int textPlacement;
<         String subStringText;
<         String text;
< 
<         IFigure fig = getEditPart().getFigure();
<         if (fig instanceof WrapLabel) {
<             WrapLabel label = (WrapLabel) fig;
<             iconBounds = label.getIconBounds().getCopy();
<             icon = label.getIcon();
<             textPlacement = label.getTextPlacement();
<             subStringText = label.getSubStringText();
<             text = label.getText();
<         } else if (fig instanceof Label) {
<             Label label = (Label) fig;
<             iconBounds = label.getIconBounds().getCopy();
<             icon = label.getIcon();
<             textPlacement = label.getTextPlacement();
<             subStringText = label.getSubStringText();
<             text = label.getText();
<         } else {
554,636d567
<             return;
<         }
< 
<         Text textControl = (Text)getCellEditor().getControl();
<         
<         //we need to restore our wraplabel figure bounds after we are done
<         Rectangle restoreRect = fig.getBounds().getCopy();
<         
<         Rectangle rect = fig.getBounds();
<         fig.translateToAbsolute(rect);
<         
<         if (!rect.contains(new org.eclipse.draw2d.geometry.Point(location.x,location.y))) {
<             textControl.setSelection(0, textControl.getText().length());
<             fig.setBounds(restoreRect);
<             return;
<         }
<         
<         fig.translateToAbsolute(iconBounds);
< 
<         double avrLines =  fig.getBounds().height / (double)FigureUtilities.getFontMetrics(this.zoomLevelFont).getHeight();
<         
<         int xWidth = location.x - rect.x;
<         
<         if (icon != null && textPlacement == PositionConstants.EAST) 
<             xWidth -= iconBounds.width;
<         
<         double yPercentage = (location.y - rect.y) / (double)rect.height;
<         
<         //calculate the line number the mouse clicked on.
<         int lineNum = (int)Math.ceil(avrLines * yPercentage);
<         
<         //character count for caret positioning...
<         int charCount = 0;
<         
<         StringTokenizer tokenizer = new StringTokenizer(subStringText, "\n"); //$NON-NLS-1$
< 
<         //calculate the total characters before linePos...
<         for (int lineCount = 1; lineCount < lineNum; lineCount++) {
<             if (tokenizer.hasMoreTokens()) {
<                 charCount += tokenizer.nextToken().length();
<                 
<                 if (charCount >= text.length())
<                     break;
<                 
<                 //check if there is a user-inserted new line which will be accounted in the Text control...
<                 String newLineCheck = text.substring(charCount,charCount+1); 
<                 if (newLineCheck.equals("\r") || newLineCheck.equals("\n")) //$NON-NLS-1$ //$NON-NLS-2$
<                     charCount++;
<             }
<             else {
<                 //our linePos calculation was wrong...revert to sending a mouse click...
<                 sendClickToCellEditor(location);
<                 fig.setBounds(restoreRect);
<                 return;
<             }
<         }
<         
<         //now count the last line's characters till the point where the mouse clicked...
<         if (tokenizer.hasMoreTokens()) {
<             String currentLineText = tokenizer.nextToken();
<             
<             IMapMode mm = MapModeUtil.getMapMode(fig);
<             
<             for (int i = 1; i <= currentLineText.length(); i++) {
<                 Dimension textExtent = getTextExtents(currentLineText.substring(0, i), this.zoomLevelFont, mm);
<                 fig.translateToAbsolute(textExtent);
<                 
<                 charCount++;
<                 
<                 if (textExtent.width >= xWidth)
<                     break;
<             }
<             
<             textControl.setSelection(charCount);
<             
<             fig.setBounds(restoreRect);
<             
<         }
<         else {
<             //our linePos calculation was wrong...revert to sending a mouse click...
<             sendClickToCellEditor(location);
<             fig.setBounds(restoreRect);
<         }
673a605,627
>     protected void hookListeners() {
>         super.hookListeners();
> 
>         // TODO: This gets around the problem of the cell editor not growing big
>         // enough when in autosize mode because it doesn't listen to textflow
>         // size changes. The superclass should be modified to not assume we want
>         // to listen to the editpart's figure.
>         ILabelDelegate label = (ILabelDelegate) getEditPart().getAdapter(
>             ILabelDelegate.class);
>         if (label != null && getEditPart().getFigure() instanceof WrappingLabel) {
> 
>             textFigureListener = new AncestorListener.Stub() {
> 
>                 public void ancestorMoved(IFigure ancestor) {
>                     getLocator().relocate(getCellEditor());
>                 }
>             };
>             ((IFigure) ((WrappingLabel) getEditPart().getFigure())
>                 .getTextFigure().getChildren().get(0))
>                 .addAncestorListener(textFigureListener);
>         }
>     }
> 
675,676c629,630
<      * Overrides super unhookListeners to set listeners attached flag
<      * This method prevents unhooking listeners twice if the UI thread is blocked.
---
>      * Overrides super unhookListeners to set listeners attached flag This
>      * method prevents unhooking listeners twice if the UI thread is blocked.
682a637,645
> 
>             ILabelDelegate label = (ILabelDelegate) getEditPart().getAdapter(
>                 ILabelDelegate.class);
>             if (label != null && textFigureListener != null) {
>                 ((IFigure) ((WrappingLabel) getEditPart().getFigure())
>                     .getTextFigure().getChildren().get(0))
>                     .removeAncestorListener(textFigureListener);
>                 textFigureListener = null;
>             }
739,743d701
<     public void setLocator(CellEditorLocator locator) {
<         super.setLocator(locator);
<         this.locator = locator;
<     }
< 
