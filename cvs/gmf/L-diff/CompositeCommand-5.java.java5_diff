7,8d6
< import java.util.Collections;
< 
12a11,24
> import java.util.ListIterator;
> 
> import org.eclipse.core.commands.ExecutionException;
> 
> import org.eclipse.core.commands.operations.ICompositeOperation;
> 
> import org.eclipse.core.commands.operations.IUndoContext;
> 
> import org.eclipse.core.commands.operations.IUndoableOperation;
> 
> import org.eclipse.core.resources.IFile;
> 
> import org.eclipse.core.runtime.IAdaptable;
> 
24a37,38
> import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;
> 
31,35c45,51
< public class CompositeCommand implements ICommand {
<     protected static final String EMPTY_STRING = "";
<     private final List commands = new ArrayList ();
<     private final String label;
<     private boolean canceled = false;
---
> import org.eclipse.gmf.runtime.common.core.util.Log;
> 
> import org.eclipse.gmf.runtime.common.core.util.Trace;
> 
> public class CompositeCommand extends AbstractCommand implements ICompositeCommand {
>     private final List children;
>     private boolean executed;
38,39c54
<         super ();
<         this.label = label;
---
>         this (label, null);
42,49c57,62
<     public CompositeCommand (String label, List commands) {
<         super ();
<         this.label = label;
<         assert null != commands : "null commands";
<         for (Iterator i = commands.iterator ();
<         i.hasNext ();) {
<             ICommand command = (ICommand) i.next ();
<             compose (command);
---
>     public CompositeCommand (String label, List children) {
>         super (label, null);
>         if (children != null) {
>             this.children = new ArrayList (children);
>         } else {
>             this.children = new ArrayList ();
53,54c66,67
<     public final List getCommands () {
<         return commands;
---
>     public final boolean isEmpty () {
>         return size () < 1;
57,58c70,72
<     public final String getLabel () {
<         if (label == null) if (getCommands ().isEmpty ()) return null;
---
>     protected List getChildren () {
>         return children;
>     }
60c74,76
<         if (label != null) return label;
---
>     public int size () {
>         return getChildren ().size ();
>     }
62c78,119
<         return ((ICommand) getCommands ().get (0)).getLabel ();
---
>     public void add (IUndoableOperation operation) {
>         assertNotExecuted ();
>         if (! getChildren ().contains (operation)) {
>             getChildren ().add (operation);
>             didAdd (operation);
>         }
>     }
> 
>     private void didAdd (IUndoableOperation operation) {
>         IUndoContext [] childContexts = operation.getContexts ();
>         for (int i = 0;
>         i < childContexts.length; i ++) {
>             if (! hasContext (childContexts [i])) {
>                 addContext (childContexts [i]);
>             }
>         }
>     }
> 
>     public void remove (IUndoableOperation operation) {
>         assertNotExecuted ();
>         if (getChildren ().remove (operation)) {
>             didRemove (operation);
>         }
>     }
> 
>     private void didRemove (IUndoableOperation operation) {
>         IUndoContext [] childContexts = operation.getContexts ();
>         for (int i = 0;
>         i < childContexts.length; i ++) {
>             if (! anyChildHasContext (childContexts [i])) {
>                 removeContext (childContexts [i]);
>             }
>         }
>     }
> 
>     private boolean anyChildHasContext (IUndoContext ctx) {
>         boolean result = false;
>         for (Iterator iter = iterator ();
>         ! result && iter.hasNext ();) {
>             result = ((IUndoableOperation) iter.next ()).hasContext (ctx);
>         }
>         return result;
65,67c122,126
<     public CommandResult getCommandResult () {
<         if (isCanceled ()) {
<             return newCancelledCommandResult ();
---
>     public boolean canExecute () {
>         boolean result = super.canExecute ();
>         for (Iterator iter = iterator ();
>         result && iter.hasNext ();) {
>             result = ((IUndoableOperation) iter.next ()).canExecute ();
69c128,175
<         List statuses = new ArrayList ();
---
>         return result;
>     }
> 
>     public boolean canRedo () {
>         boolean result = super.canRedo ();
>         for (Iterator iter = iterator ();
>         result && iter.hasNext ();) {
>             result = ((IUndoableOperation) iter.next ()).canRedo ();
>         }
>         return result;
>     }
> 
>     public boolean canUndo () {
>         boolean result = super.canUndo ();
>         for (Iterator iter = iterator ();
>         result && iter.hasNext ();) {
>             result = ((IUndoableOperation) iter.next ()).canUndo ();
>         }
>         return result;
>     }
> 
>     public void dispose () {
>         for (Iterator iter = iterator ();
>         iter.hasNext ();) {
>             IUndoableOperation nextOperation = (IUndoableOperation) iter.next ();
>             nextOperation.dispose ();
>         }
>     }
> 
>     public final ICommand compose (IUndoableOperation operation) {
>         if (operation != null) {
>             add (operation);
>         }
>         return this;
>     }
> 
>     public ICommand reduce () {
>         switch (size ()) {
>             case 1 :
>                 IUndoableOperation child = (IUndoableOperation) iterator ().next ();
>                 if (child instanceof ICommand) {
>                     return ((ICommand) child).reduce ();
>                 }
>         }
>         return this;
>     }
> 
>     protected List getReturnValues () {
71,76c177
<         int severity = IStatus.OK;
<         String plugin = CommonCorePlugin.getPluginId ();
<         int code = CommonCoreStatusCodes.OK;
<         String message = EMPTY_STRING;
<         Throwable exception = null;
<         for (Iterator i = getCommands ().iterator ();
---
>         for (Iterator i = iterator ();
78c179,181
<             ICommand command = (ICommand) i.next ();
---
>             IUndoableOperation operation = (IUndoableOperation) i.next ();
>             if (operation instanceof ICommand) {
>                 ICommand command = (ICommand) operation;
80,91c183
<             if (result == null) {
<                 break;
<             }
<             IStatus status = result.getStatus ();
<             statuses.add (result.getStatus ());
<             if (severity < status.getSeverity ()) {
<                 severity = status.getSeverity ();
<                 plugin = status.getPlugin ();
<                 code = status.getCode ();
<                 message = status.getMessage ();
<                 exception = status.getException ();
<             }
---
>                 if (result != null) {
105d196
<         return new CommandResult (new MultiStatus (plugin, code, (IStatus []) statuses.toArray (new IStatus [] {}), message, exception), returnValues);
107,114d197
< 
<     public final Collection getAffectedObjects () {
<         List affectedObjects = new ArrayList ();
<         for (Iterator i = getCommands ().iterator ();
<         i.hasNext ();) {
<             Collection coll = ((ICommand) i.next ()).getAffectedObjects ();
<             if (coll != null) {
<                 affectedObjects.addAll (coll);
116,117c199
<         }
<         return affectedObjects;
---
>         return returnValues;
120,123c202,230
<     public boolean involvesReadOnlyNonWorkSpaceFiles () {
<         for (Iterator i = getCommands ().iterator ();
<         i.hasNext ();) {
<             if (((ICommand) i.next ()).involvesReadOnlyNonWorkSpaceFiles ()) return true;
---
>     protected CommandResult doExecuteWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
>         List result = new ArrayList (size ());
>         if (progressMonitor == null) {
>             progressMonitor = new NullProgressMonitor ();
>         }
>         progressMonitor.beginTask (getLabel (), size ());
>         try {
>             for (ListIterator iter = listIterator ();
>             iter.hasNext ();) {
>                 IUndoableOperation next = (IUndoableOperation) iter.next ();
>                 try {
>                     IStatus status = next.execute (new SubProgressMonitor (progressMonitor, 1), info);
>                     result.add (status);
>                     int severity = status.getSeverity ();
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
>                         Trace.trace (CommonCorePlugin.getDefault (), "Composite operation execution recovery: child command status is CANCEL or ERROR.");
>                         iter.previous ();
>                         unwindFailedExecute (iter, info);
>                         break;
>                     } else if (progressMonitor.isCanceled ()) {
>                         Trace.trace (CommonCorePlugin.getDefault (), "Composite operation redo recovery: child command monitor is cancelled.");
>                         CommandResult cancelResult = CommandResult.newCancelledCommandResult ();
>                         result.add (cancelResult.getStatus ());
>                         unwindFailedExecute (iter, info);
>                         break;
>                     } else {
>                         progressMonitor.worked (1);
>                         executed = true;
>                     }
124a232,237
>                 } catch (ExecutionException e) {
>                     iter.previous ();
>                     unwindFailedExecute (iter, info);
>                     Trace.throwing (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.EXCEPTIONS_THROWING, CompositeCommand.class, "execute", e);
>                     throw e;
>                 }
126c239,242
<         return false;
---
>         } finally {
>             progressMonitor.done ();
>         }
>         return new CommandResult (aggregateStatuses (result), getReturnValues ());
129,130c245,259
<     public final ICommand compose (ICommand command) {
<         if (command != null) getCommands ().add (command);
---
>     private void unwindFailedExecute (ListIterator iter, IAdaptable info) {
>         while (iter.hasPrevious ()) {
>             IUndoableOperation prev = (IUndoableOperation) iter.previous ();
>             if (! prev.canUndo ()) {
>                 Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.EXECUTE_RECOVERY_FAILED, CommonCoreMessages.bind (CommonCoreMessages.executeRecoveryFailed, CommonCoreMessages.cannotUndoExecuted));
>                 break;
>             }
>             try {
>                 prev.undo (new NullProgressMonitor (), info);
>             } catch (ExecutionException inner) {
>                 Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.EXECUTE_RECOVERY_FAILED, CommonCoreMessages.bind (CommonCoreMessages.executeRecoveryFailed, inner.getLocalizedMessage ()));
>                 break;
>             }
>         }
>     }
132c261,288
<         return this;
---
>     protected CommandResult doRedoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
>         final List result = new ArrayList (size ());
>         if (progressMonitor == null) {
>             progressMonitor = new NullProgressMonitor ();
>         }
>         progressMonitor.beginTask (getLabel (), size ());
>         try {
>             for (ListIterator iter = listIterator ();
>             iter.hasNext ();) {
>                 IUndoableOperation next = (IUndoableOperation) iter.next ();
>                 try {
>                     IStatus status = next.redo (new SubProgressMonitor (progressMonitor, 1), info);
>                     result.add (status);
>                     int severity = status.getSeverity ();
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
>                         Trace.trace (CommonCorePlugin.getDefault (), "Composite operation redo recovery: child command status is CANCEL or ERROR.");
>                         iter.previous ();
>                         unwindFailedRedo (iter, info);
>                         break;
>                     } else if (progressMonitor.isCanceled ()) {
>                         Trace.trace (CommonCorePlugin.getDefault (), "Composite operation redo recovery: child command monitor is cancelled.");
>                         CommandResult cancelResult = CommandResult.newCancelledCommandResult ();
>                         result.add (cancelResult.getStatus ());
>                         unwindFailedRedo (iter, info);
>                         break;
>                     } else {
>                         progressMonitor.worked (1);
>                         executed = true;
135,136c291,302
<     public final boolean isExecutable () {
<         if (getCommands ().isEmpty ()) return false;
---
>                 } catch (ExecutionException e) {
>                     iter.previous ();
>                     unwindFailedRedo (iter, info);
>                     Trace.throwing (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.EXCEPTIONS_THROWING, CompositeCommand.class, "redo", e);
>                     throw e;
>                 }
>             }
>         } finally {
>             progressMonitor.done ();
>         }
>         return new CommandResult (aggregateStatuses (result), getReturnValues ());
>     }
138,141c304,315
<         for (Iterator i = getCommands ().iterator ();
<         i.hasNext ();) {
<             if (! ((ICommand) i.next ()).isExecutable ()) {
<                 return false;
---
>     private void unwindFailedRedo (ListIterator iter, IAdaptable info) {
>         while (iter.hasPrevious ()) {
>             IUndoableOperation prev = (IUndoableOperation) iter.previous ();
>             if (! prev.canUndo ()) {
>                 Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.REDO_RECOVERY_FAILED, CommonCoreMessages.bind (CommonCoreMessages.redoRecoveryFailed, CommonCoreMessages.cannotUndo));
>                 break;
>             }
>             try {
>                 prev.undo (new NullProgressMonitor (), info);
>             } catch (ExecutionException inner) {
>                 Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.REDO_RECOVERY_FAILED, CommonCoreMessages.bind (CommonCoreMessages.redoRecoveryFailed, inner.getLocalizedMessage ()));
>                 break;
144d317
<         return true;
147,148c320,348
<     public final boolean isRedoable () {
<         if (getCommands ().isEmpty ()) return false;
---
>     protected CommandResult doUndoWithResult (IProgressMonitor progressMonitor, IAdaptable info) throws ExecutionException {
>         final List result = new ArrayList (size ());
>         if (progressMonitor == null) {
>             progressMonitor = new NullProgressMonitor ();
>         }
>         progressMonitor.beginTask (getLabel (), size ());
>         try {
>             for (ListIterator iter = listIterator (size ());
>             iter.hasPrevious ();) {
>                 IUndoableOperation prev = (IUndoableOperation) iter.previous ();
>                 try {
>                     IStatus status = prev.undo (new SubProgressMonitor (progressMonitor, 1), info);
>                     result.add (status);
>                     int severity = status.getSeverity ();
>                     if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
>                         Trace.trace (CommonCorePlugin.getDefault (), "Composite operation undo recovery: child command status is CANCEL or ERROR.");
>                         iter.next ();
>                         unwindFailedUndo (iter, info);
>                         break;
>                     } else if (progressMonitor.isCanceled ()) {
>                         Trace.trace (CommonCorePlugin.getDefault (), "Composite operation undo recovery: child command monitor is cancelled.");
>                         CommandResult cancelResult = CommandResult.newCancelledCommandResult ();
>                         result.add (cancelResult.getStatus ());
>                         unwindFailedUndo (iter, info);
>                         break;
>                     } else {
>                         progressMonitor.worked (1);
>                         executed = true;
>                     }
150,153c350,354
<         for (Iterator i = getCommands ().iterator ();
<         i.hasNext ();) {
<             if (! ((ICommand) i.next ()).isRedoable ()) {
<                 return false;
---
>                 } catch (ExecutionException e) {
>                     iter.next ();
>                     unwindFailedUndo (iter, info);
>                     Trace.throwing (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.EXCEPTIONS_THROWING, CompositeCommand.class, "undo", e);
>                     throw e;
156c357,360
<         return true;
---
>         } finally {
>             progressMonitor.done ();
>         }
>         return new CommandResult (aggregateStatuses (result), getReturnValues ());
159,160c363,377
<     public final boolean isUndoable () {
<         if (getCommands ().isEmpty ()) return false;
---
>     private void unwindFailedUndo (ListIterator iter, IAdaptable info) {
>         while (iter.hasNext ()) {
>             IUndoableOperation next = (IUndoableOperation) iter.next ();
>             if (! next.canRedo ()) {
>                 Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.UNDO_RECOVERY_FAILED, CommonCoreMessages.bind (CommonCoreMessages.undoRecoveryFailed, CommonCoreMessages.cannotRedo));
>                 break;
>             }
>             try {
>                 next.redo (new NullProgressMonitor (), info);
>             } catch (ExecutionException inner) {
>                 Log.error (CommonCorePlugin.getDefault (), CommonCoreStatusCodes.UNDO_RECOVERY_FAILED, CommonCoreMessages.bind (CommonCoreMessages.undoRecoveryFailed, inner.getLocalizedMessage ()));
>                 break;
>             }
>         }
>     }
162,165c379,391
<         for (Iterator i = getCommands ().iterator ();
<         i.hasNext ();) {
<             if (! ((ICommand) i.next ()).isUndoable ()) {
<                 return false;
---
>     protected IStatus aggregateStatuses (List statuses) {
>         final IStatus result;
>         if (statuses.isEmpty ()) {
>             result = Status.OK_STATUS;
>         } else if (statuses.size () == 1) {
>             result = ((IStatus) statuses.get (0));
>         } else {
>             IStatus [] statusArray = (IStatus []) statuses.toArray (new IStatus [statuses.size ()]);
>             IStatus worst = statusArray [0];
>             for (int i = 1;
>             i < statusArray.length; i ++) {
>                 if (statusArray [i].getSeverity () > worst.getSeverity ()) {
>                     worst = statusArray [i];
168c394
<         return true;
---
>             result = new MultiStatus (worst.getPlugin (), worst.getCode (), statusArray, worst.getMessage (), null);
171,172c397
<     public final boolean isEmpty () {
<         return getCommands ().size () == 0;
---
>         return result;
175,182c400,408
<     public ICommand unwrap () {
<         switch (commands.size ()) {
<             case 0 :
<                 return UnexecutableCommand.INSTANCE;
<             case 1 :
<                 return (ICommand) commands.get (0);
<             default :
<                 return this;
---
>     protected final boolean isExecuted () {
>         return executed;
>     }
> 
>     protected final void assertNotExecuted () {
>         if (isExecuted ()) {
>             IllegalStateException exc = new IllegalStateException ("Operation already executed");
>             Trace.throwing (CommonCorePlugin.getDefault (), CommonCoreDebugOptions.EXCEPTIONS_THROWING, CompositeCommand.class, "assertNotExecuted", exc);
>             throw exc;
186,195c412,414
<     public void execute (IProgressMonitor progressMonitor) {
<         if (! getValidator ().okToEdit (this)) {
<             setCanceled (true);
<         } else {
<             IProgressMonitor monitor = (progressMonitor == null) ? new NullProgressMonitor () : progressMonitor;
<             setCanceled (false);
<             List executedCommands = new ArrayList (getCommands ().size ());
<             int totalWork = getCommands ().size ();
<             monitor.beginTask (getLabel (), totalWork);
<             for (Iterator i = getCommands ().iterator ();
---
>     public List getAffectedFiles () {
>         List result = new ArrayList ();
>         for (Iterator i = iterator ();
197,204c416,422
<                 SubProgressMonitor subprogressMonitor = new SubProgressMonitor (monitor, 1, SubProgressMonitor.SUPPRESS_SUBTASK_LABEL);
<                 ICommand nextCommand = (ICommand) i.next ();
<                 nextCommand.execute (subprogressMonitor);
<                 CommandResult result = nextCommand.getCommandResult ();
<                 if (result != null) {
<                     if (result.getStatus ().getSeverity () == IStatus.ERROR) {
<                         undoCancelledCommands (executedCommands);
<                         return;
---
>             IUndoableOperation nextOperation = (IUndoableOperation) i.next ();
>             if (nextOperation instanceof ICommand) {
>                 List nextAffected = ((ICommand) nextOperation).getAffectedFiles ();
>                 if (nextAffected != null) {
>                     result.addAll (nextAffected);
>                 }
>             }
205a424
>         return result;
207,212c426,428
<                 monitor.worked (1);
<                 if (monitor.isCanceled ()) {
<                     undoCancelledCommands (executedCommands);
<                     monitor.done ();
<                     setCanceled (true);
<                     return;
---
> 
>     public Iterator iterator () {
>         return new ChildIterator ();
214c430,432
<                 executedCommands.add (nextCommand);
---
> 
>     public ListIterator listIterator () {
>         return new ChildListIterator (0);
216c434,436
<             monitor.done ();
---
> 
>     public ListIterator listIterator (int index) {
>         return new ChildListIterator (index);
217a438,444
> 
>     private class ChildIterator implements Iterator {
>         protected Object last;
>         protected final ListIterator iter;
> 
>         ChildIterator () {
>             this (0);
220,226c447,448
<     protected void undoCancelledCommands (List executedCommands) {
<         Collections.reverse (executedCommands);
<         for (Iterator i = executedCommands.iterator ();
<         i.hasNext ();) {
<             ICommand nextCommand = (ICommand) i.next ();
<             if (nextCommand.isUndoable ()) {
<                 nextCommand.undo ();
---
>         ChildIterator (int index) {
>             iter = getChildren ().listIterator (index);
227a450,455
> 
>         public void remove () {
>             assertNotExecuted ();
>             iter.remove ();
>             didRemove ((IUndoableOperation) last);
>             last = null;
228a457,460
> 
>         public Object next () {
>             last = iter.next ();
>             return last;
231,234c463,464
<     public void redo () {
<         if (! getValidator ().okToEdit (this)) {
<             setCanceled (true);
<             return;
---
>         public boolean hasNext () {
>             return iter.hasNext ();
236,239c466
<         Collections.reverse (getCommands ());
<         for (Iterator i = getCommands ().iterator ();
<         i.hasNext ();) {
<             ((ICommand) i.next ()).redo ();
---
> 
240a468,472
> 
>     private class ChildListIterator extends ChildIterator implements ListIterator {
> 
>         ChildListIterator (int index) {
>             super (index);
243,246c475,479
<     public void undo () {
<         if (! getValidator ().okToEdit (this)) {
<             setCanceled (true);
<             return;
---
>         public void add (Object o) {
>             assertNotExecuted ();
>             if (! getChildren ().contains (o)) {
>                 iter.add (o);
>                 didAdd ((IUndoableOperation) o);
248,251c481,489
<         Collections.reverse (getCommands ());
<         for (Iterator i = getCommands ().iterator ();
<         i.hasNext ();) {
<             ((ICommand) i.next ()).undo ();
---
>         }
> 
>         public void set (Object o) {
>             assertNotExecuted ();
>             if (! getChildren ().contains (o)) {
>                 didRemove ((IUndoableOperation) last);
>                 iter.set (o);
>                 last = o;
>                 didAdd ((IUndoableOperation) o);
255,256c493,494
<     protected String getPluginId () {
<         return CommonCorePlugin.getPluginId ();
---
>         public int previousIndex () {
>             return iter.previousIndex ();
259,260c497,498
<     protected CommandResult newCancelledCommandResult () {
<         return new CommandResult (new Status (IStatus.ERROR, getPluginId (), CommonCoreStatusCodes.CANCELLED, CommonCoreMessages.AbstractCommand__INFO__cancelOperation, null), null);
---
>         public int nextIndex () {
>             return iter.nextIndex ();
263,264c501,503
<     protected void setCanceled (boolean canceled) {
<         this.canceled = canceled;
---
>         public Object previous () {
>             last = iter.previous ();
>             return last;
267,268c506,507
<     protected boolean isCanceled () {
<         return canceled;
---
>         public boolean hasPrevious () {
>             return iter.hasPrevious ();
271,272d509
<     public CMValidator getValidator () {
<         return new CMValidator ();
