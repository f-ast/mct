26a27,28
> import org.eclipse.gmf.internal.xpand.expression.Variable;
> 
34a37
>     protected final Identifier instanceSlot;
36c39
<     public JavaExtensionStatement (final int start, final int end, final int line, final Identifier name, final List < DeclaredParameter > formalParameters, final Identifier returnType, final Identifier defaultImplementation, final Identifier javaMethod, final List < Identifier > javaParamTypes, final boolean cached, final boolean isPrivate) {
---
>     public JavaExtensionStatement (final int start, final int end, final int line, final Identifier name, final List < DeclaredParameter > formalParameters, final Identifier returnType, final Identifier defaultImplementation, final Identifier javaMethod, final List < Identifier > javaParamTypes, final boolean cached, final boolean isPrivate, final Identifier instanceSlot) {
40a44
>         this.instanceSlot = instanceSlot;
58a63
>             if (Modifier.isStatic (method.getModifiers ())) {
59a65,77
>             } else {
>                 if (instanceSlot == null) {
>                     throw new EvaluationException ("Non-static method may be invoked only when slot with instance object is specified", this);
>                 }
>                 Variable variable = ctx.getGlobalVariable (instanceSlot.getValue ());
>                 if (variable == null || variable.getValue () == null) {
>                     throw new EvaluationException ("The method '" + javaMethodToString () + "' is not static in " + javaType.getValue () + ", and there's no global variable '" + instanceSlot + "' to obtain instance from", this);
>                 }
>                 if (! method.getDeclaringClass ().isInstance (variable.getValue ())) {
>                     throw new EvaluationException ("Instance available in global vars as '" + instanceSlot + "' is not compatible with " + javaType.getValue (), this);
>                 }
>                 return method.invoke (variable.getValue (), parameters);
>             }
81c99
<     public Method getJavaMethod (final ExecutionContext ctx, final Set < AnalysationIssue > issues) {
---
>     private Method getJavaMethod (final ExecutionContext ctx, final Set < AnalysationIssue > issues) {
108,109c126,127
<             if (! Modifier.isStatic (m.getModifiers ())) {
<                 issues.add (new AnalysationIssue (AnalysationIssue.FEATURE_NOT_FOUND, javaMethod.getValue () + " must be static!", javaMethod));
---
>             if (instanceSlot == null && ! Modifier.isStatic (m.getModifiers ())) {
>                 issues.add (new AnalysationIssue (AnalysationIssue.FEATURE_NOT_FOUND, javaMethod.getValue () + " must be static (unless slot to get instance from is specified)!", javaMethod));
