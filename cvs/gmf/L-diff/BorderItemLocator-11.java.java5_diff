26a27
>     private int interval;
32c33,34
<     public BorderItemLocator (IFigure parentFigure) {
---
>     public BorderItemLocator (int interval, IFigure parentFigure) {
>         Assert.isTrue (interval > 0);
34a37,41
>         this.interval = interval;
>     }
> 
>     public BorderItemLocator (IFigure parentFigure) {
>         this (MapModeUtil.getMapMode (parentFigure).DPtoLP (8), parentFigure);
41a49,53
>     public BorderItemLocator (IFigure parentFigure, int preferredSide, int interval) {
>         this (interval, parentFigure);
>         this.preferredSide = preferredSide;
>     }
> 
46a59,63
>     public BorderItemLocator (IFigure borderItem, IFigure parentFigure, Rectangle constraint, int interval) {
>         this (interval, parentFigure);
>         setConstraint (constraint);
>     }
> 
175,176d191
<         int vertical_gap = MapModeUtil.getMapMode (getParentFigure ()).DPtoLP (8);
<         int horizontal_gap = MapModeUtil.getMapMode (getParentFigure ()).DPtoLP (8);
182c197
<                     recommendedLocation.y = calculateNextNonConflictingPosition (conflictingBorderItem.getBounds ().getBottomLeft ().y, vertical_gap, suggestedSide, borderItem);
---
>                     calculateNextNonConflictingPosition (recommendedLocation, interval, suggestedSide, borderItem, conflictingBorderItem.getBounds ());
193c208
<                     recommendedLocation.x = calculateNextNonConflictingPosition (conflictingBorderItem.getBounds ().getTopRight ().x, horizontal_gap, suggestedSide, borderItem);
---
>                     calculateNextNonConflictingPosition (recommendedLocation, interval, suggestedSide, borderItem, conflictingBorderItem.getBounds ());
204c219
<                     recommendedLocation.y = calculateNextNonConflictingPosition (conflictingBorderItem.getBounds ().getLocation ().y, vertical_gap, suggestedSide, borderItem);
---
>                     calculateNextNonConflictingPosition (recommendedLocation, interval, suggestedSide, borderItem, conflictingBorderItem.getBounds ());
215c230
<                     recommendedLocation.x = calculateNextNonConflictingPosition (conflictingBorderItem.getBounds ().getLocation ().x, horizontal_gap, suggestedSide, borderItem);
---
>                     calculateNextNonConflictingPosition (recommendedLocation, interval, suggestedSide, borderItem, conflictingBorderItem.getBounds ());
230c245
<     protected int calculateNextNonConflictingPosition (int currentPosition, int interval, int currentSide, IFigure borderItem) {
---
>     protected void calculateNextNonConflictingPosition (Point currentLocation, int interval, int currentSide, IFigure borderItem, Rectangle obstacle) {
232a248,249
>                 currentLocation.y = obstacle.getBottomLeft ().y + interval;
>                 break;
234c251,252
<                 return currentPosition + interval;
---
>                 currentLocation.x = obstacle.getBottomRight ().x + interval;
>                 break;
235a254,255
>                 currentLocation.y = obstacle.getTopRight ().y - interval - borderItem.getBounds ().height;
>                 break;
236a257,258
>                 currentLocation.x = obstacle.getTopLeft ().x - interval - borderItem.getBounds ().width;
>                 break;
238c260
<                 return currentPosition - interval;
---
>                 throw new IllegalArgumentException ("Invalid side argument: " + currentSide + ". Should be the value from PositionConstants: WEST, EAST, NORTH or SOUTH");
