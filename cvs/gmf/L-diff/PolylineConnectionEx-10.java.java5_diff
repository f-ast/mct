9c9
< import java.util.HashMap;
---
> import java.util.Hashtable;
17,18d16
< import java.util.Map;
< 
42a41,42
> import org.eclipse.draw2d.geometry.PrecisionPoint;
> 
48a49,50
> import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.BaseSlidableAnchor;
> 
53,54d54
< import org.eclipse.gmf.runtime.draw2d.ui.internal.figures.PolylineAnchor;
< 
84c84
<     private Map connectionAnchors;
---
>     private Hashtable connectionAnchors;
100,105d99
<     protected Map getConnectionAnchors () {
<         if (connectionAnchors == null) connectionAnchors = new HashMap (1);
< 
<         return connectionAnchors;
<     }
< 
555,629d548
<     static public class PointInfo {
<         public int fromLine;
<         public int fromEnd;
<         public boolean isPercentage = true;
<         public double proj = 0.0;
<     }
< 
<     private static boolean projIn (double proj) {
<         return proj > 0 && proj < 1;
<     }
< 
<     private static double projFactor (double proj) {
<         if (proj < 0) return - proj;
<         else if (proj > 1.0) return proj - 1.0;
<         else return 0;
< 
<     }
< 
<     private boolean atLeastOneProjectionCovers (Point p) {
<         boolean oneProjIn = false;
<         List segments = PointListUtilities.getLineSegments (getPoints ());
<         ListIterator segIter = segments.listIterator ();
<         while (segIter.hasNext () && ! oneProjIn) {
<             LineSeg segment = (LineSeg) segIter.next ();
<             double proj = segment.projection (p.x, p.y);
<             if (projIn (proj)) {
<                 oneProjIn = true;
<             }
<         }
<         return oneProjIn;
<     }
< 
<     private PointInfo getPointInfo (Point p) {
<         PointInfo pointInfo = new PointInfo ();
<         pointInfo.fromLine = Integer.MAX_VALUE;
<         pointInfo.fromEnd = 0;
<         pointInfo.proj = Double.NEGATIVE_INFINITY;
<         List segments = PointListUtilities.getLineSegments (getPoints ());
<         int accumulatedLength = 0;
<         boolean isCovered = atLeastOneProjectionCovers (p);
<         ListIterator segIter = segments.listIterator ();
<         while (segIter.hasNext ()) {
<             LineSeg segment = (LineSeg) segIter.next ();
<             double proj = segment.projection (p.x, p.y);
<             Point pt = segment.perpIntersect (p.x, p.y);
<             int perpDist = (int) Math.round (p.getDistance (pt));
<             if (isCovered) {
<                 if (perpDist < Math.abs (pointInfo.fromLine)) {
<                     if (proj > 0 && proj < 1) {
<                         pointInfo.fromLine = (segment.positionRelativeTo (p) == LineSeg.Sign.POSITIVE ? perpDist : - perpDist);
<                         Point origin = segment.getOrigin ();
<                         int inSegmentDistance = (int) Math.round (origin.getDistance (pt));
<                         double fractionDistance = ((double) (accumulatedLength + inSegmentDistance)) / ((double) PointListUtilities.getPointsLength (getPoints ()));
<                         pointInfo.fromEnd = (int) Math.round (100 * fractionDistance);
<                     }
<                 }
<             } else {
<                 if (projFactor (proj) < projFactor (pointInfo.proj)) {
<                     pointInfo.fromLine = (segment.positionRelativeTo (p) == LineSeg.Sign.POSITIVE ? perpDist : - perpDist);
<                     Point origin = segment.getOrigin ();
<                     int inSegmentDistance = proj > 0 ? Math.min ((int) Math.round (origin.getDistance (pt)), (int) segment.length ()) : 0;
<                     double fractionDistance = ((double) (accumulatedLength + inSegmentDistance)) / ((double) PointListUtilities.getPointsLength (getPoints ()));
<                     pointInfo.fromEnd = (int) Math.round (100 * fractionDistance);
<                     if (pointInfo.fromEnd > 0 && pointInfo.fromEnd < 100) pointInfo.fromEnd += ((inSegmentDistance == (int) segment.length ()) ? - 1 : 1);
< 
<                     pointInfo.proj = proj;
<                 }
<             }
<             accumulatedLength += segment.length ();
<         }
<         if (pointInfo.fromLine == Integer.MAX_VALUE) pointInfo.fromLine = 0;
< 
<         return pointInfo;
<     }
< 
635,638c554,563
<         ConnectionAnchor connectionAnchor = (ConnectionAnchor) getConnectionAnchors ().get (terminal);
<         if (connectionAnchor == null) connectionAnchor = new PolylineAnchor (this, terminal);
< 
<         return connectionAnchor;
---
>         ConnectionAnchor connectAnchor = (ConnectionAnchor) getConnectionAnchors ().get (terminal);
>         if (connectAnchor == null) {
>             if (terminal.equals (szAnchor)) {
>                 connectAnchor = createDefaultAnchor ();
>                 getConnectionAnchors ().put (terminal, connectAnchor);
>             } else {
>                 connectAnchor = createAnchor (BaseSlidableAnchor.parseTerminalString (terminal));
>             }
>         }
>         return connectAnchor;
641a567,569
>         if (c instanceof BaseSlidableAnchor) {
>             return ((BaseSlidableAnchor) c).getTerminal ();
>         }
651c579,580
<         return null;
---
>         getConnectionAnchor (szAnchor);
>         return szAnchor;
661a591,600
>     protected ConnectionAnchor createDefaultAnchor () {
>         return new BaseSlidableAnchor (this);
>     }
> 
>     protected ConnectionAnchor createAnchor (PrecisionPoint p) {
>         if (p == null) return createDefaultAnchor ();
> 
>         return new BaseSlidableAnchor (this, p);
>     }
> 
663,666c602,603
<         ConnectionAnchor connectionAnchor = null;
<         int fromEnd = 0;
<         if (p.x < 0) {
<             connectionAnchor = new PolylineAnchor (this, fromEnd = 50);
---
>         if (p == null) {
>             return getConnectionAnchor (szAnchor);
668,669c605,608
<             PointInfo pInfo = getPointInfo (p);
<             connectionAnchor = new PolylineAnchor (this, fromEnd = pInfo.fromEnd);
---
>             Point temp = p.getCopy ();
>             translateToRelative (temp);
>             PrecisionPoint pt = BaseSlidableAnchor.getAnchorRelativeLocation (temp, getBounds ());
>             return createAnchor (pt);
671,673d609
<         if (connectionAnchor != null) {
<             String szKey = szAnchor + fromEnd;
<             getConnectionAnchors ().put (szKey, connectionAnchor);
675c611,623
<         return connectionAnchor;
---
> 
>     protected boolean isDefaultAnchorArea (PrecisionPoint p) {
>         return p.preciseX >= getSlidableAnchorArea () / 2 && p.preciseX <= 1 - getSlidableAnchorArea () / 2 && p.preciseY >= getSlidableAnchorArea () / 2 && p.preciseY <= 1 - getSlidableAnchorArea () / 2;
>     }
> 
>     protected Hashtable getConnectionAnchors () {
>         if (connectionAnchors == null) connectionAnchors = new Hashtable (1);
> 
>         return connectionAnchors;
>     }
> 
>     protected double getSlidableAnchorArea () {
>         return 0.25;
