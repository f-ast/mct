2a3,4
> import java.util.ArrayList;
> 
4a7,8
> import java.util.HashSet;
> 
6a11,14
> import java.util.LinkedList;
> 
> import java.util.List;
> 
13a22,23
>     private static final int PAIRS_POOL_SIZE = 100;
>     private static final int STORAGE_POOL_SIZE = 10;
14a25,26
>     private final MatchingSession myMatchingSession;
>     private final StoragePool myStoragePool;
17a30,31
>         myMatchingSession = new MatchingSession (new PairsPool (PAIRS_POOL_SIZE));
>         myStoragePool = new StoragePool (STORAGE_POOL_SIZE);
22a37,41
>     protected EObject handleNotMatchedOld (EObject currentParent, EObject notMatchedOld) {
>         Copier copier = myConfig.getCopier (notMatchedOld.eClass ());
>         return copier.copyToCurrent (currentParent, notMatchedOld);
>     }
> 
24c43
<         reconcileContents (current.getContents (), old.getContents ());
---
>         reconcileContents (null, current.getContents (), old.getContents ());
29c48
<         reconcileContents (currentRoot.eContents (), oldRoot.eContents ());
---
>         reconcileContents (currentRoot, currentRoot.eContents (), oldRoot.eContents ());
43,50c62,80
<     private void reconcileContents (Collection allCurrents, Collection allOlds) {
<         for (Iterator currentContents = allCurrents.iterator ();
<         currentContents.hasNext ();) {
<             EObject nextCurrent = (EObject) currentContents.next ();
<             EObject nextOld = findMatched (nextCurrent, allOlds);
<             if (nextOld == null) {
<                 handleNotMatchedCurrent (nextCurrent);
<             } else {
---
>     private void reconcileContents (EObject currentParent, Collection allCurrents, Collection allOlds) {
>         if (allCurrents.isEmpty () && allOlds.isEmpty ()) {
>             return;
>         }
>         List storage = myStoragePool.acquireList ();
>         myMatchingSession.match (allCurrents, allOlds, storage);
>         for (Iterator pairs = storage.iterator ();
>         pairs.hasNext ();) {
>             Pair next = (Pair) pairs.next ();
>             EObject nextCurrent = next.current;
>             EObject nextOld = next.old;
>             assert (nextCurrent != null || nextOld != null);
>             myMatchingSession.releasePair (next);
>             if (nextCurrent == null) {
>                 if (currentParent != null) {
>                     nextCurrent = handleNotMatchedOld (currentParent, nextOld);
>                 }
>             }
>             if (nextCurrent != null && nextOld != null) {
51a82,83
>             } else if (nextOld == null) {
>                 handleNotMatchedCurrent (nextCurrent);
52a85
> 
53a87
>         myStoragePool.release (storage);
56c90,147
<     private EObject findMatched (EObject current, Collection allOld) {
---
>     private static class Pair {
>         public EObject current;
>         public EObject old;
> 
>         public void reset () {
>             current = null;
>             old = null;
>         }
> 
>     }
> 
>     private class MatchingSession {
>         private final Collection myCurrents;
>         private final Collection myOlds;
>         private final PairsPool myPool;
>         private boolean myIsMatching;
> 
>         public MatchingSession (PairsPool pool) {
>             myPool = pool;
>             myCurrents = new LinkedList ();
>             myOlds = new HashSet ();
>         }
> 
>         public void match (Collection currents, Collection olds, Collection output) {
>             assert ! myIsMatching;
>             assert myOlds.isEmpty ();
>             assert myCurrents.isEmpty ();
>             if (myIsMatching) {
>                 throw new IllegalStateException ("FIXME: remove me");
>             }
>             try {
>                 myIsMatching = true;
>                 myCurrents.addAll (currents);
>                 myOlds.addAll (olds);
>                 for (Iterator currentContents = myCurrents.iterator ();
>                 ! myOlds.isEmpty () && currentContents.hasNext ();) {
>                     EObject nextCurrent = (EObject) currentContents.next ();
>                     Pair nextPair = acquirePair ();
>                     nextPair.current = nextCurrent;
>                     nextPair.old = removeMatched (nextCurrent, myOlds);
>                     output.add (nextPair);
>                     currentContents.remove ();
>                 }
>                 for (Iterator notMatchedOlds = myOlds.iterator ();
>                 notMatchedOlds.hasNext ();) {
>                     Pair nextPair = acquirePair ();
>                     nextPair.current = null;
>                     nextPair.old = (EObject) notMatchedOlds.next ();
>                     output.add (nextPair);
>                 }
>             } finally {
>                 myIsMatching = false;
>                 myCurrents.clear ();
>                 myOlds.clear ();
>             }
>         }
> 
>         private EObject removeMatched (EObject current, Collection allOld) {
62c153
<             result == null && all.hasNext ();) {
---
>                 all.hasNext ();) {
65a157,158
>                         all.remove ();
>                         break;
71a165,217
>         private Pair acquirePair () {
>             return myPool.acquire ();
>         }
> 
>         public void releasePair (Pair pair) {
>             myPool.release (pair);
>         }
> 
>     }
> 
>     private static class PairsPool extends AbstractPool {
> 
>         public PairsPool (int capacity) {
>             super (capacity);
>         }
> 
>         public Pair acquire () {
>             return (Pair) internalAcquire ();
>         }
> 
>         public void release (Pair pair) {
>             pair.current = null;
>             pair.old = null;
>             internalRelease (pair);
>         }
> 
>         protected Object createNew () {
>             return new Pair ();
>         }
> 
>     }
> 
>     private static class StoragePool extends AbstractPool {
> 
>         public StoragePool (int capacity) {
>             super (capacity);
>         }
> 
>         public List acquireList () {
>             return (List) internalAcquire ();
>         }
> 
>         public void release (List list) {
>             list.clear ();
>             internalRelease (list);
>         }
> 
>         protected Object createNew () {
>             return new ArrayList ();
>         }
> 
>     }
> 
