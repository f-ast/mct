12,18c12
<     private EClass myOwner;
<     private Reflector myReflector;
<     public interface Reflector {
< 
<         public Object reflect (EObject target);
< 
<     }
---
>     private final EStructuralFeature myFeature;
21,26c15,16
<         this (feature.getEContainingClass (), new StructuralFeatureReflector (feature));
<     }
< 
<     public ReflectiveMatcher (EClass reflectorOwner, Reflector reflector) {
<         myOwner = reflectorOwner;
<         myReflector = reflector;
---
>         assert feature != null;
>         myFeature = feature;
32,33c22,23
<         Object currentValue = myReflector.reflect (current);
<         return currentValue != null && currentValue.equals (myReflector.reflect (old));
---
>         Object currentValue = current.eGet (myFeature);
>         return currentValue != null && currentValue.equals (old.eGet (myFeature));
43,45c33,34
<         if (! myOwner.isSuperTypeOf (eClass)) {
<             throw new IllegalStateException (MessageFormat.format ("EClass {0} is not compatible with expected class {1} ", new Object [] {eClass, myOwner}));
<         }
---
>         if (! myFeature.getEContainingClass ().isSuperTypeOf (eClass)) {
>             throw new IllegalStateException (MessageFormat.format ("EClass {0} is not compatible with expected class {1} ", new Object [] {eClass, myFeature.getEContainingClass ()}));
47,59d35
< 
<     public static class StructuralFeatureReflector implements Reflector {
<         private final EStructuralFeature myFeature;
< 
<         public StructuralFeatureReflector (EStructuralFeature feature) {
<             assert feature != null;
<             myFeature = feature;
<         }
< 
<         public Object reflect (EObject target) {
<             return target.eGet (myFeature);
<         }
< 
