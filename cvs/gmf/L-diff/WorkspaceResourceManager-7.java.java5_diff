3,4d2
< import java.io.BufferedReader;
< 
8a7,8
> import java.io.InputStream;
> 
13c13
< import java.util.ArrayList;
---
> import java.net.URL;
15c15
< import java.util.LinkedList;
---
> import java.nio.charset.Charset;
17c17
< import org.eclipse.core.resources.ICommand;
---
> import java.util.ArrayList;
24a25,26
> import org.eclipse.core.resources.ResourcesPlugin;
> 
31,33c33
< import org.eclipse.gmf.internal.xpand.Activator;
< 
< import org.eclipse.gmf.internal.xpand.ResourceManager;
---
> import org.eclipse.core.runtime.Platform;
46a47,48
> import org.osgi.framework.Bundle;
> 
49,50c51
<     private long configStamp = IResource.NULL_STAMP;
<     private IPath [] configuredRoots;
---
>     private final IPath [] myConfiguredRoots;
52c53
<     public WorkspaceResourceManager (IProject context) {
---
>     public WorkspaceResourceManager (IProject context, IPath [] configuredRoots) {
53a55
>         myConfiguredRoots = configuredRoots;
60,68c62,64
<         assert file.getProject () == contextProject;
<         Reader r = null;
<         try {
<             r = new StreamConverter ().toContentsReader (file);
<             return super.loadXtendResource (r, toFullyQualifiedName (file));
<         } finally {
<             if (r != null) {
<                 r.close ();
<             }
---
>         String fullyQualifiedName = toFullyQualifiedName (file);
>         if (fullyQualifiedName == null) {
>             return null;
69a66
>         return super.loadXtendResource (fullyQualifiedName);
76,84c73,75
<         assert file.getProject () == contextProject;
<         Reader r = null;
<         try {
<             r = new StreamConverter ().toContentsReader (file);
<             return super.loadXpandResource (r, toFullyQualifiedName (file));
<         } finally {
<             if (r != null) {
<                 r.close ();
<             }
---
>         String fullyQualifiedName = toFullyQualifiedName (file);
>         if (fullyQualifiedName == null) {
>             return null;
85a77,78
>         fullyQualifiedName = getNonAspectsTemplateName (fullyQualifiedName);
>         return super.loadXpandResource (fullyQualifiedName);
117,125c110,118
<     private IPath [] getResolutions (IPath p) {
<         IPath [] configured = getConfiguredRoots ();
<         IPath [] rv = new IPath [configured.length + 1];
<         rv [0] = p;
<         for (int i = 0;
<         i < configured.length; i ++) {
<             rv [i + 1] = configured [i].append (p);
<         }
<         return rv;
---
>     @Override
>     protected Reader [] resolveMultiple (String fqn, String ext) throws IOException {
>         IPath fp = new Path (fqn.replaceAll (SyntaxConstants.NS_DELIM, "/")).addFileExtension (ext);
>         IPath [] resolutions = getResolutions (fp);
>         ArrayList < Reader > result = new ArrayList < Reader > (resolutions.length);
>         for (IPath p : getResolutions (fp)) {
>             Reader nextReader = getReader (p);
>             if (nextReader != null) {
>                 result.add (nextReader);
127,143d119
< 
<     private IPath [] getConfiguredRoots () {
<         IFile config = contextProject.getFile (".xpand-root");
<         if (! config.exists ()) {
<             return new IPath [] {new Path ("templates/")};
<         }
<         if (config.getModificationStamp () != configStamp) {
<             configuredRoots = new IPath [0];
<             final ArrayList < IPath > read = new ArrayList < IPath > ();
<             BufferedReader in = null;
<             try {
<                 in = new BufferedReader (new InputStreamReader (config.getContents (), config.getCharset ()));
<                 String line;
<                 while ((line = in.readLine ()) != null) {
<                     line = line.trim ();
<                     if (line.length () > 0 && line.charAt (0) != '#') {
<                         read.add (new Path (line));
144a121,122
>         if (result.isEmpty ()) {
>             throw new FileNotFoundException (fp.toString ());
146,152c124
<             } catch (CoreException ex) {
<             } catch (IOException ex) {
<             } finally {
<                 if (in != null) {
<                     try {
<                         in.close ();
<                     } catch (IOException ex) {
---
>         return result.toArray (new Reader [result.size ()]);
153a126,139
> 
>     private Reader getReader (IPath p) throws IOException {
>         if (p.isAbsolute ()) {
>             assert p.segmentCount () > 1;
>             IProject project = ResourcesPlugin.getWorkspace ().getRoot ().getProject (p.segment (0));
>             if (project.isAccessible ()) {
>                 return getWorkspaceFileReader (project, p.removeFirstSegments (1));
>             }
>             Bundle platformBundle = Platform.getBundle (p.segment (0));
>             if (platformBundle != null) {
>                 URL url = platformBundle.getEntry (p.removeFirstSegments (1).toString ());
>                 if (url != null) {
>                     InputStream is = url.openStream ();
>                     return new InputStreamReader (is, Charset.forName ("ISO-8859-1"));
156,157c142,143
<             configuredRoots = read.toArray (new IPath [read.size ()]);
<             configStamp = config.getModificationStamp ();
---
>         } else {
>             return getWorkspaceFileReader (contextProject, p);
159c145
<         return configuredRoots;
---
>         return null;
162,163c148,150
<     protected ResourceManager [] getDependenies () {
<         LinkedList < ResourceManager > rv = new LinkedList < ResourceManager > ();
---
>     private Reader getWorkspaceFileReader (IProject project, IPath path) throws IOException {
>         IResource r = project.findMember (path);
>         if (r instanceof IFile) {
165,170c152,156
<             IProject [] referencedProjects = contextProject.getReferencedProjects ();
<             for (IProject next : referencedProjects) {
<                 if (! next.isAccessible () || ! hasXpandBuilder (next)) {
<                     continue;
<                 }
<                 rv.add (Activator.getResourceManager (next));
---
>                 return new StreamConverter ().toContentsReader ((IFile) r);
>             } catch (CoreException ex) {
>                 IOException wrap = new IOException (ex.getStatus ().getMessage ());
>                 wrap.initCause (ex);
>                 throw wrap;
172d157
<         } catch (CoreException e) {
174c159
<         return rv.toArray (new ResourceManager [rv.size ()]);
---
>         return null;
177,180c162,167
<     private static boolean hasXpandBuilder (IProject p) throws CoreException {
<         for (ICommand c : p.getDescription ().getBuildSpec ()) {
<             if (OawBuilder.getBUILDER_ID ().equals (c.getBuilderName ())) {
<                 return true;
---
>     private IPath [] getResolutions (IPath p) {
>         IPath [] configured = getConfiguredRoots ();
>         IPath [] rv = new IPath [configured.length];
>         for (int i = 0;
>         i < configured.length; i ++) {
>             rv [i] = configured [i].append (p);
181a169
>         return rv;
183c171,173
<         return false;
---
> 
>     private IPath [] getConfiguredRoots () {
>         return myConfiguredRoots;
187c177,192
<         return file.getProjectRelativePath ().toString ().replaceAll ("/", SyntaxConstants.NS_DELIM);
---
>         for (IPath nextRoot : getConfiguredRoots ()) {
>             if (! nextRoot.isAbsolute ()) {
>                 if (file.getProject ().equals (contextProject) && nextRoot.isPrefixOf (file.getProjectRelativePath ())) {
>                     return toFullyQualifiedName (file.getProjectRelativePath ().removeFirstSegments (nextRoot.segmentCount ()));
>                 }
>             } else {
>                 if (nextRoot.isPrefixOf (file.getFullPath ())) {
>                     return toFullyQualifiedName (file.getFullPath ().removeFirstSegments (nextRoot.segmentCount ()));
>                 }
>             }
>         }
>         return null;
>     }
> 
>     private String toFullyQualifiedName (IPath filePath) {
>         return filePath.removeFileExtension ().toString ().replace ("/", SyntaxConstants.NS_DELIM);
