5,7c5
< import org.eclipse.draw2d.ConnectionAnchor;
< 
< import org.eclipse.draw2d.IFigure;
---
> import org.eclipse.draw2d.PositionConstants;
14a13,14
> import org.eclipse.draw2d.geometry.PrecisionPoint;
> 
21c21,27
< import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
---
> import org.eclipse.gmf.runtime.common.core.util.StringStatics;
> 
> import org.eclipse.gmf.runtime.draw2d.ui.figures.BaseSlidableAnchor;
> 
> import org.eclipse.gmf.runtime.draw2d.ui.figures.FigureUtilities;
> 
> import org.eclipse.gmf.runtime.draw2d.ui.figures.OrthogonalConnectionAnchor;
27a34
>     private static int maxNestedRoutingDepth = 1;
29,36c36,40
<     protected boolean removeSegmentsInViews (Connection conn, PointList newLine) {
<         PointList newPoints = new PointList (newLine.size ());
<         Point ptStart = new Point (newLine.getFirstPoint ());
<         Point ptEnd = new Point (newLine.getLastPoint ());
<         for (int i = 0;
<         i < newLine.size (); i ++) {
<             if (i != 0 && i != newLine.size () - 1) newPoints.addPoint (new Point (newLine.getPoint (i)));
< 
---
>     public void routeLine (Connection conn, int nestedRoutingDepth, PointList newLine) {
>         boolean skipNormalization = (routerFlags & ROUTER_FLAG_SKIPNORMALIZATION) != 0;
>         if (isReorienting (conn)) {
>             super.routeLine (conn, nestedRoutingDepth, newLine);
>             return;
38,56c42,45
<         if (newPoints.size () < 3) return false;
< 
<         int lastIntersect = 0;
<         int count = 0;
<         boolean found = false;
<         boolean bChanged = false;
<         IFigure sourceFigure = conn.getSourceAnchor ().getOwner ();
<         if (sourceFigure == null) return false;
< 
<         PointList startPolygon = getFigurePolygon (sourceFigure, conn);
<         for (int i = 0;
<         i < newPoints.size () - 1; i ++) {
<             boolean in1 = PointListUtilities.containsPoint (startPolygon, newPoints.getPoint (i));
<             boolean in2 = PointListUtilities.containsPoint (startPolygon, newPoints.getPoint (i + 1));
<             if (in1 != in2) {
<                 lastIntersect = count;
<                 found = true;
<             } else if (! (in1 || in2)) {
<                 break;
---
>         if (checkSelfRelConnection (conn, newLine) || checkShapesIntersect (conn, newLine)) {
>             super.resetEndPointsToEdge (conn, newLine);
>             OrthogonalRouterUtilities.transformToOrthogonalPointList (newLine, getOffShapeDirection (getAnchorOffRectangleDirection (newLine.getFirstPoint (), sourceBoundsRelativeToConnection (conn))), getOffShapeDirection (getAnchorOffRectangleDirection (newLine.getLastPoint (), targetBoundsRelativeToConnection (conn))));
>             return;
58,59c47,50
< 
<             ++ count;
---
>         Point lastStartAnchor = newLine.removePoint (0);
>         Point lastEndAnchor = newLine.removePoint (newLine.size () - 1);
>         if (! OrthogonalRouterUtilities.isRectilinear (newLine)) {
>             OrthogonalRouterUtilities.transformToOrthogonalPointList (newLine, PositionConstants.NONE, PositionConstants.NONE);
61,98c52,55
<         if (found) {
<             for (int i = 0;
<             i <= lastIntersect; ++ i) {
<                 newPoints.removePoint (0);
<                 bChanged = true;
<             }
<         }
<         lastIntersect = count = newLine.size () - 1;
<         found = false;
<         IFigure targetFigure = conn.getTargetAnchor ().getOwner ();
<         if (targetFigure == null) return false;
< 
<         PointList endPolygon = getFigurePolygon (targetFigure, conn);
<         for (int i = newPoints.size () - 1;
<         i > 0; i --) {
<             boolean in1 = PointListUtilities.containsPoint (endPolygon, newPoints.getPoint (i));
<             boolean in2 = PointListUtilities.containsPoint (endPolygon, newPoints.getPoint (i - 1));
<             if (in1 != in2) {
<                 lastIntersect = count;
<                 found = true;
<             } else if (! (in1 || in2)) {
<                 break;
<             }
< 
<             -- count;
<         }
<         if (found) {
<             for (int i = newPoints.size () - 1;
<             i >= lastIntersect; -- i) {
<                 newPoints.removePoint (newPoints.size () - 1);
<                 bChanged = true;
<             }
<         }
<         if (newPoints.size () != newLine.size ()) {
<             newLine.removeAllPoints ();
<             newLine.addPoint (ptStart);
<             for (int i = 0;
<             i < newPoints.size (); i ++) newLine.addPoint (new Point (newPoints.getPoint (i)));
---
>         removeRedundantPoints (newLine);
>         removePointsInViews (conn, newLine, lastStartAnchor, lastEndAnchor);
>         Dimension tolerance = new Dimension (3, 0);
>         if (! RouterHelper.getInstance ().isFeedback (conn)) tolerance = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (tolerance);
100c57,59
<             newLine.addPoint (ptEnd);
---
>         if (! skipNormalization) {
>             if (PointListUtilities.normalizeSegments (newLine, tolerance.width)) {
>                 normalizeToStraightLineTolerance (newLine, tolerance.width);
102d60
<         return bChanged;
104,106d61
< 
<     protected boolean updateToBiTerminal (Connection conn, PointList newLine) {
<         boolean retVal = false;
108,140c63,71
<             Point ptOrig = new Point (newLine.getPoint (0));
<             Point ptTerm = new Point (newLine.getPoint (1));
<             Dimension offsets = new Dimension (10, 10);
<             conn.translateToRelative (offsets);
<             Rectangle bBoxF, bBoxT;
<             if (conn.getSourceAnchor ().getOwner () != null) {
<                 bBoxF = getBounds (conn.getSourceAnchor ().getOwner ());
<                 conn.getSourceAnchor ().getOwner ().translateToAbsolute (bBoxF);
<                 conn.translateToRelative (bBoxF);
<             } else bBoxF = new Rectangle (ptOrig.x - offsets.width / 2, ptOrig.y - offsets.height / 2, offsets.width, offsets.height);
< 
<             if (conn.getTargetAnchor ().getOwner () != null) {
<                 bBoxT = getBounds (conn.getTargetAnchor ().getOwner ());
<                 conn.getTargetAnchor ().getOwner ().translateToAbsolute (bBoxT);
<                 conn.translateToRelative (bBoxT);
<             } else bBoxT = new Rectangle (ptTerm.x - offsets.width / 2, ptTerm.y - offsets.height / 2, offsets.width, offsets.height);
< 
<             int ix1 = Math.max (bBoxF.getLeft ().x, bBoxT.getLeft ().x);
<             int ix2 = Math.min (bBoxF.getRight ().x, bBoxT.getRight ().x);
<             Point posF = bBoxF.getCenter ();
<             Point posT = bBoxT.getCenter ();
<             Ray origSeg = new Ray (ptOrig, ptTerm);
<             boolean isOblique = (origSeg.y != 0 && origSeg.x != 0);
<             if (ix1 <= ix2) {
<                 if (isOblique || ptOrig.x < ix1 || ptOrig.x > ix2) {
<                     if (isOblique && ptOrig.x > ix1 && ptOrig.x < ix2) posF.x = ptOrig.x;
<                     else posF.x = ix1 + (ix2 - ix1) / 2;
< 
<                     posT.x = posF.x;
<                     newLine.removeAllPoints ();
<                     newLine.addPoint (posF);
<                     newLine.addPoint (posT);
<                     retVal = true;
---
>             Ray middleSeg = new Ray (newLine.getFirstPoint (), newLine.getLastPoint ());
>             if (middleSeg.length () <= tolerance.width) {
>                 newLine.removePoint (0);
>             }
>         }
>         resetEndPointsToEdge (conn, newLine);
>         if (nestedRoutingDepth < maxNestedRoutingDepth && ! isValidRectilinearLine (conn, newLine)) {
>             routeLine (conn, ++ nestedRoutingDepth, newLine);
>         }
142,148d72
<             } else {
<                 int iy1 = Math.max (bBoxF.getTop ().y, bBoxT.getTop ().y);
<                 int iy2 = Math.min (bBoxF.getBottom ().y, bBoxT.getBottom ().y);
<                 if (iy1 <= iy2) {
<                     if (isOblique || ptOrig.y < iy1 || ptOrig.y > iy2) {
<                         if (isOblique && ptOrig.y > iy1 && ptOrig.y < iy2) posF.y = ptOrig.y;
<                         else posF.y = iy1 + (iy2 - iy1) / 2;
150,154c74,80
<                         posT.y = posF.y;
<                         newLine.removeAllPoints ();
<                         newLine.addPoint (posF);
<                         newLine.addPoint (posT);
<                         retVal = true;
---
>     private boolean isValidRectilinearLine (Connection conn, PointList line) {
>         if (! (conn.getSourceAnchor ().getOwner () instanceof Connection)) {
>             Rectangle source = new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (conn.getSourceAnchor ().getOwner ()));
>             conn.getSourceAnchor ().getOwner ().translateToAbsolute (source);
>             conn.translateToRelative (source);
>             if (source.contains (line.getPoint (1))) {
>                 return false;
155a82,84
>             int firstSegmentOrientation = line.getFirstPoint ().x == line.getPoint (1).x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
>             if (getOutisePointOffRectanglePosition (line.getPoint (1), source) != getAnchorLocationBasedOnSegmentOrientation (line.getFirstPoint (), source, firstSegmentOrientation)) {
>                 return false;
157a87,92
>         if (! (conn.getTargetAnchor ().getOwner () instanceof Connection)) {
>             Rectangle target = new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (conn.getTargetAnchor ().getOwner ()));
>             conn.getTargetAnchor ().getOwner ().translateToAbsolute (target);
>             conn.translateToRelative (target);
>             if (target.contains (line.getPoint (line.size () - 2))) {
>                 return false;
159c94,96
<         return retVal;
---
>             int lastSegmentOrientation = line.getLastPoint ().x == line.getPoint (line.size () - 2).x ? PositionConstants.VERTICAL : PositionConstants.HORIZONTAL;
>             if (getOutisePointOffRectanglePosition (line.getPoint (line.size () - 2), target) != getAnchorLocationBasedOnSegmentOrientation (line.getLastPoint (), target, lastSegmentOrientation)) {
>                 return false;
161,165d97
< 
<     protected void resetEndPointsToEdge (Connection conn, PointList newLine) {
<         if (isReorienting (conn)) {
<             super.resetEndPointsToEdge (conn, newLine);
<             return;
167,186c99,116
<         Point origin = null;
<         if (conn.getSourceAnchor ().getOwner () instanceof Connection) {
<             origin = getIntersectionPoint ((Connection) conn.getSourceAnchor ().getOwner (), new LineSeg (newLine.getPoint (1), newLine.getPoint (0)));
<         }
<         if (origin == null) {
<             LineSeg edgeLine1 = OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc (conn, conn.getSourceAnchor (), newLine.getPoint (1));
<             origin = edgeLine1.getOrigin ();
<         }
<         Point terminus = null;
<         if (conn.getTargetAnchor ().getOwner () instanceof Connection) {
<             int numPoints = newLine.size ();
<             terminus = getIntersectionPoint ((Connection) conn.getTargetAnchor ().getOwner (), new LineSeg (newLine.getPoint (numPoints - 2), newLine.getPoint (numPoints - 1)));
<         }
<         if (terminus == null) {
<             LineSeg edgeLine2 = OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc (conn, conn.getTargetAnchor (), newLine.getPoint (newLine.size () - 2));
<             terminus = edgeLine2.getOrigin ();
<         }
<         if (origin != null && terminus != null) {
<             newLine.setPoint (origin, 0);
<             if (newLine.size () > 2) {
---
>         return true;
>     }
> 
>     private void removePointsInViews (Connection conn, PointList newLine, Point start, Point end) {
>         PrecisionRectangle source = conn.getSourceAnchor ().getOwner () != null ? new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (conn.getSourceAnchor ().getOwner ())) : null;
>         PrecisionRectangle target = conn.getTargetAnchor ().getOwner () != null ? new PrecisionRectangle (FigureUtilities.getAnchorableFigureBounds (conn.getTargetAnchor ().getOwner ())) : null;
>         if (source != null) {
>             conn.getSourceAnchor ().getOwner ().translateToAbsolute (source);
>             conn.translateToRelative (source);
>         }
>         if (target != null) {
>             conn.getTargetAnchor ().getOwner ().translateToAbsolute (target);
>             conn.translateToRelative (target);
>         }
>         Point lastRemovedFromSource = null;
>         Point lastRemovedFromTarget = null;
>         if (! (conn.getSourceAnchor ().getOwner () instanceof Connection) && newLine.size () != 0 && source.contains (new PrecisionPoint (newLine.getFirstPoint ()))) {
>             lastRemovedFromSource = newLine.removePoint (0);
188,192c118,119
<                 i < 2; i ++) {
<                     Point ptCurrent = newLine.getPoint (i);
<                     Point ptNext = newLine.getPoint (i + 1);
<                     makeOrthogonal (ptCurrent, ptNext);
<                     newLine.setPoint (ptNext, i + 1);
---
>             i < newLine.size () && source.contains (new PrecisionPoint (newLine.getPoint (i))); i ++) {
>                 lastRemovedFromSource = newLine.removePoint (i --);
195,202c122,126
<             newLine.setPoint (terminus, newLine.size () - 1);
<             if (newLine.size () > 2) {
<                 for (int i = newLine.size () - 1;
<                 i >= newLine.size () - 2; i --) {
<                     Point ptCurrent = newLine.getPoint (i);
<                     Point ptNext = newLine.getPoint (i - 1);
<                     makeOrthogonal (ptCurrent, ptNext);
<                     newLine.setPoint (ptNext, i - 1);
---
>         if (! (conn.getTargetAnchor ().getOwner () instanceof Connection) && newLine.size () != 0 && target.contains (new PrecisionPoint (newLine.getLastPoint ()))) {
>             lastRemovedFromTarget = newLine.removePoint (newLine.size () - 1);
>             for (int i = newLine.size ();
>             i > 0 && target.contains (new PrecisionPoint (newLine.getPoint (i - 1))); i --) {
>                 lastRemovedFromTarget = newLine.removePoint (i - 1);
205c129,131
<         } else super.resetEndPointsToEdge (conn, newLine);
---
>         if (newLine.size () == 0) {
>             Dimension tolerance = new Dimension (1, 0);
>             if (! RouterHelper.getInstance ().isFeedback (conn)) tolerance = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (tolerance);
206a133,144
>             int toleranceValue = tolerance.width;
>             if (lastRemovedFromSource == null) {
>                 lastRemovedFromSource = start;
>             }
>             if (lastRemovedFromTarget == null) {
>                 lastRemovedFromTarget = end;
>             }
>             if (Math.abs (lastRemovedFromSource.x - lastRemovedFromTarget.x) < toleranceValue) {
>                 if (source.preciseY < target.preciseY) {
>                     newLine.addPoint (lastRemovedFromSource.x, (source.getBottom ().y + target.getTop ().y) / 2);
>                 } else {
>                     newLine.addPoint (lastRemovedFromSource.x, (source.getTop ().y + target.getBottom ().y) / 2);
208,211c146,148
< 
<     private void makeOrthogonal (Point ptCurrent, Point ptNext) {
<         if (Math.abs (ptNext.x - ptCurrent.x) < Math.abs (ptNext.y - ptCurrent.y)) {
<             ptNext.x = ptCurrent.x;
---
>             } else if (Math.abs (lastRemovedFromSource.y - lastRemovedFromTarget.y) < toleranceValue) {
>                 if (source.preciseX < target.preciseX) {
>                     newLine.addPoint ((source.getRight ().x + target.getLeft ().x) / 2, lastRemovedFromSource.y);
213c150,167
<             ptNext.y = ptCurrent.y;
---
>                     newLine.addPoint ((source.getLeft ().x + target.getRight ().x) / 2, lastRemovedFromSource.y);
>                 }
>             } else if ((conn.getSourceAnchor () instanceof BaseSlidableAnchor && StringStatics.BLANK.equals (((BaseSlidableAnchor) conn.getSourceAnchor ()).getTerminal ()) && (conn.getTargetAnchor () instanceof BaseSlidableAnchor && StringStatics.BLANK.equals (((BaseSlidableAnchor) conn.getTargetAnchor ()).getTerminal ())))) {
>                 double startX = Math.max (source.preciseX, target.preciseX);
>                 double endX = Math.min (source.preciseX + source.preciseWidth, target.preciseX + target.preciseWidth);
>                 double startY = Math.max (source.preciseY, target.preciseY);
>                 double endY = Math.min (source.preciseY + source.preciseHeight, target.preciseY + target.preciseHeight);
>                 if (startX < endX) {
>                     if (source.preciseY < target.preciseY) {
>                         newLine.addPoint ((int) Math.round ((startX + endX) / 2.0), (source.getBottom ().y + target.getTop ().y) / 2);
>                     } else {
>                         newLine.addPoint ((int) Math.round ((startX + endX) / 2.0), (source.getTop ().y + target.getBottom ().y) / 2);
>                     }
>                 } else if (startY < endY) {
>                     if (source.preciseX < target.preciseX) {
>                         newLine.addPoint ((source.getRight ().x + target.getLeft ().x) / 2, (int) Math.round ((startY + endY) / 2.0));
>                     } else {
>                         newLine.addPoint ((source.getLeft ().x + target.getRight ().x) / 2, (int) Math.round ((startY + endY) / 2.0));
217,226d170
<     private static int CONNECTION_OFFSET = 26;
< 
<     protected void updateIfNotRectilinear (Connection conn, PointList newLine) {
<         boolean isRectilinear = true;
<         for (int i = 0;
<         i < newLine.size () - 1; i ++) {
<             Ray segVector = new Ray (newLine.getPoint (i), newLine.getPoint (i + 1));
<             if (segVector.x != 0 && segVector.y != 0) {
<                 isRectilinear = false;
<                 break;
227a172
> 
229,230d173
<         if (isRectilinear && areEndsInBounds (conn, newLine)) {
<             return;
232,233c175,182
<         if (updateToBiTerminal (conn, newLine) && areEndsInBounds (conn, newLine)) {
<             return;
---
> 
>     private int getAnchorOffRectangleDirection (Point anchorPoint, Rectangle rect) {
>         int position = PositionConstants.NORTH;
>         int criteriaValue = Math.abs (anchorPoint.y - rect.y);
>         int tempCriteria = Math.abs (anchorPoint.y - rect.y - rect.height);
>         if (tempCriteria < criteriaValue) {
>             criteriaValue = tempCriteria;
>             position = PositionConstants.SOUTH;
235,249c184,187
<         OrthogonalRouterUtilities.resetEndPointsToCenter (conn, newLine);
<         PointList oldPoints = PointListUtilities.copyPoints (newLine);
<         PointList newPoints = new PointList ();
<         newPoints.addPoint (oldPoints.removePoint (0));
<         while (oldPoints.size () > 0) {
<             if (oldPoints.size () >= 2) {
<                 Point p0 = newPoints.getLastPoint ();
<                 Point p1 = oldPoints.removePoint (0);
<                 Point p2 = oldPoints.removePoint (0);
<                 if (Math.abs (p2.y - p0.y) > Math.abs (p2.x - p0.x)) {
<                     newPoints.addPoint (new Point (p1.x, p0.y));
<                     newPoints.addPoint (new Point (p1.x, p2.y));
<                 } else {
<                     newPoints.addPoint (new Point (p0.x, p1.y));
<                     newPoints.addPoint (new Point (p2.x, p1.y));
---
>         tempCriteria = Math.abs (anchorPoint.x - rect.x);
>         if (tempCriteria < criteriaValue) {
>             criteriaValue = tempCriteria;
>             position = PositionConstants.WEST;
251,258c189,192
<                 newPoints.addPoint (p2);
<             } else if (oldPoints.size () == 1) {
<                 Point p0 = newPoints.getLastPoint ();
<                 Point p1 = oldPoints.removePoint (0);
<                 if (Math.abs (p1.y - p0.y) > Math.abs (p1.x - p0.x)) {
<                     newPoints.addPoint (new Point (p1.x, p0.y));
<                 } else {
<                     newPoints.addPoint (new Point (p0.x, p1.y));
---
>         tempCriteria = Math.abs (anchorPoint.x - rect.x - rect.width);
>         if (tempCriteria < criteriaValue) {
>             criteriaValue = tempCriteria;
>             position = PositionConstants.EAST;
260c194
<                 newPoints.addPoint (p1);
---
>         return position;
263,275c197,206
<         }
<         oldPoints.removeAllPoints ();
<         oldPoints.addPoint (newPoints.removePoint (0));
<         while (newPoints.size () >= 2) {
<             Point p0 = oldPoints.getLastPoint ();
<             Point p1 = newPoints.getPoint (0);
<             Point p2 = newPoints.getPoint (1);
<             if (p0.x == p1.x && p0.x == p2.x) {
<                 newPoints.removePoint (0);
<             } else if (p0.y == p1.y && p0.y == p2.y) {
<                 newPoints.removePoint (0);
<             } else {
<                 oldPoints.addPoint (newPoints.removePoint (0));
---
>     private Dimension getTranslationValue (int position, int xFactorValue, int yFactorValue) {
>         Dimension translationDimension = new Dimension ();
>         if (position == PositionConstants.EAST) {
>             translationDimension.width = xFactorValue;
>         } else if (position == PositionConstants.SOUTH) {
>             translationDimension.height = yFactorValue;
>         } else if (position == PositionConstants.WEST) {
>             translationDimension.width = - xFactorValue;
>         } else if (position == PositionConstants.NORTH) {
>             translationDimension.height = - yFactorValue;
277a209
>         return translationDimension;
279,280c211,216
<         while (newPoints.size () > 0) {
<             oldPoints.addPoint (newPoints.removePoint (0));
---
> 
>     private int getOffShapeDirection (int anchorRelativeLocation) {
>         if (anchorRelativeLocation == PositionConstants.EAST || anchorRelativeLocation == PositionConstants.WEST) {
>             return PositionConstants.HORIZONTAL;
>         } else if (anchorRelativeLocation == PositionConstants.NORTH || anchorRelativeLocation == PositionConstants.SOUTH) {
>             return PositionConstants.VERTICAL;
282,284d217
<         newLine.removeAllPoints ();
<         for (int i = 0;
<         i < oldPoints.size (); i ++) newLine.addPoint (oldPoints.getPoint (i));
285a219
>         return PositionConstants.NONE;
288,299c222,225
<     protected boolean checkEndSegments (Connection conn, PointList newLine) {
<         boolean bOk = true;
<         Dimension connection_offset = new Dimension (CONNECTION_OFFSET, 0);
<         conn.translateToRelative (connection_offset);
<         if (newLine.size () > 2) {
<             Point ptFix = new Point (newLine.getPoint (1));
<             if (! checkEndSegment (conn, conn.getSourceAnchor (), ptFix, connection_offset.width / 2)) {
<                 newLine.setPoint (ptFix, 1);
<                 Point ptNext = newLine.getPoint (2);
<                 makeOrthogonal (ptFix, ptNext);
<                 newLine.setPoint (ptNext, 2);
<                 bOk = false;
---
>     protected void resetEndPointsToEdge (Connection conn, PointList line) {
>         if (isReorienting (conn)) {
>             super.resetEndPointsToEdge (conn, line);
>             return;
301,307c227,258
<             ptFix = new Point (newLine.getPoint (newLine.size () - 2));
<             if (! checkEndSegment (conn, conn.getTargetAnchor (), ptFix, connection_offset.width / 2)) {
<                 newLine.setPoint (ptFix, newLine.size () - 2);
<                 Point ptNext = newLine.getPoint (newLine.size () - 3);
<                 makeOrthogonal (ptFix, ptNext);
<                 newLine.setPoint (ptNext, newLine.size () - 3);
<                 bOk = false;
---
>         PrecisionRectangle source = sourceBoundsRelativeToConnection (conn);
>         PrecisionRectangle target = targetBoundsRelativeToConnection (conn);
>         int offSourceDirection = PositionConstants.NONE;
>         int offTargetDirection = PositionConstants.NONE;
>         int sourceAnchorRelativeLocation = PositionConstants.NONE;
>         int targetAnchorRelativeLocation = PositionConstants.NONE;
>         if (line.size () == 0) {
>             line.addPoint (new Point ());
>             line.addPoint (new Point ());
>             super.resetEndPointsToEdge (conn, line);
>             sourceAnchorRelativeLocation = getAnchorOffRectangleDirection (line.getFirstPoint (), source);
>             targetAnchorRelativeLocation = getAnchorOffRectangleDirection (line.getLastPoint (), target);
>             Point offStart = line.getFirstPoint ();
>             Point offEnd = line.getLastPoint ();
>             Dimension offsetDim = offStart.getDifference (offEnd).scale (0.3);
>             offStart.translate (getTranslationValue (sourceAnchorRelativeLocation, Math.abs (offsetDim.width), Math.abs (offsetDim.height)));
>             offEnd.translate (getTranslationValue (targetAnchorRelativeLocation, Math.abs (offsetDim.width), Math.abs (offsetDim.height)));
>             line.insertPoint (offStart, 1);
>             line.insertPoint (offEnd, 2);
>             offSourceDirection = getOffShapeDirection (sourceAnchorRelativeLocation);
>             offTargetDirection = getOffShapeDirection (targetAnchorRelativeLocation);
>         } else {
>             Point start = line.getFirstPoint ();
>             Point end = line.getLastPoint ();
>             if (conn.getSourceAnchor () instanceof OrthogonalConnectionAnchor) {
>                 line.insertPoint (OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc (conn, conn.getSourceAnchor (), start).getOrigin (), 0);
>             } else {
>                 PrecisionPoint reference = new PrecisionPoint (start);
>                 conn.getSourceAnchor ().getOwner ().translateToAbsolute (reference);
>                 PrecisionPoint anchorLocation = new PrecisionPoint (conn.getSourceAnchor ().getLocation (reference));
>                 conn.translateToRelative (anchorLocation);
>                 line.insertPoint (anchorLocation, 0);
308a260,272
>             if (conn.getTargetAnchor () instanceof OrthogonalConnectionAnchor) {
>                 line.addPoint (OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc (conn, conn.getTargetAnchor (), end).getOrigin ());
>             } else {
>                 PrecisionPoint reference = new PrecisionPoint (end);
>                 conn.getSourceAnchor ().getOwner ().translateToAbsolute (reference);
>                 PrecisionPoint anchorLocation = new PrecisionPoint (conn.getTargetAnchor ().getLocation (reference));
>                 conn.translateToRelative (anchorLocation);
>                 line.addPoint (anchorLocation);
>             }
>             sourceAnchorRelativeLocation = getAnchorOffRectangleDirection (line.getFirstPoint (), source);
>             offSourceDirection = getOffShapeDirection (sourceAnchorRelativeLocation);
>             targetAnchorRelativeLocation = getAnchorOffRectangleDirection (line.getLastPoint (), target);
>             offTargetDirection = getOffShapeDirection (targetAnchorRelativeLocation);
310c274,275
<         return bOk;
---
>         OrthogonalRouterUtilities.transformToOrthogonalPointList (line, offSourceDirection, offTargetDirection);
>         removeRedundantPoints (line);
313c278
<     protected void straightenPoints (PointList newLine) {
---
>     private void normalizeToStraightLineTolerance (PointList line, int tolerance) {
315,320c280,286
<         i < newLine.size () - 1; i ++) {
<             Point ptCurrent = newLine.getPoint (i);
<             Point ptNext = newLine.getPoint (i + 1);
<             makeOrthogonal (ptCurrent, ptNext);
<             newLine.setPoint (ptNext, i + 1);
<         }
---
>         i < line.size () - 1; i ++) {
>             Point pt1 = line.getPoint (i);
>             Point pt2 = line.getPoint (i + 1);
>             if (Math.abs (pt1.x - pt2.x) < tolerance) {
>                 line.setPoint (new Point (pt1.x, pt2.y), i + 1);
>             } else if (Math.abs (pt1.y - pt2.y) < tolerance) {
>                 line.setPoint (new Point (pt2.x, pt1.y), i + 1);
323,328d288
<     protected boolean checkEndSegment (Connection conn, ConnectionAnchor anchor, Point ptNext, int offset) {
<         LineSeg seg = OrthogonalRouterUtilities.getOrthogonalLineSegToAnchorLoc (conn, anchor, ptNext);
<         if (seg != null) {
<             if (seg.length () < offset) {
<                 seg.pointOn (offset, LineSeg.KeyPoint.ORIGIN, ptNext);
<                 return false;
331,334d290
<         return true;
<     }
< 
<     private static final int maxRoutingDepth = 10;
336,342c292,296
<     public void routeLine (Connection conn, int nestedRoutingDepth, PointList newLine) {
<         boolean skipNormalization = (routerFlags & ROUTER_FLAG_SKIPNORMALIZATION) != 0;
<         int nStartSize = newLine.size ();
<         if (isReorienting (conn)) {
<             super.routeLine (conn, nestedRoutingDepth, newLine);
<             resetEndPointsToEdge (conn, newLine);
<             return;
---
>     private PrecisionRectangle sourceBoundsRelativeToConnection (Connection conn) {
>         PrecisionRectangle source = new PrecisionRectangle (conn.getSourceAnchor ().getOwner ().getBounds ());
>         conn.getSourceAnchor ().getOwner ().translateToAbsolute (source);
>         conn.translateToRelative (source);
>         return source;
344,347c298,303
<         if (checkSelfRelConnection (conn, newLine)) {
<             checkEndSegments (conn, newLine);
<             resetEndPointsToEdge (conn, newLine);
<             return;
---
> 
>     private PrecisionRectangle targetBoundsRelativeToConnection (Connection conn) {
>         PrecisionRectangle target = new PrecisionRectangle (conn.getTargetAnchor ().getOwner ().getBounds ());
>         conn.getTargetAnchor ().getOwner ().translateToAbsolute (target);
>         conn.translateToRelative (target);
>         return target;
349,352c305,311
<         if (checkShapesIntersect (conn, newLine)) {
<             checkEndSegments (conn, newLine);
<             resetEndPointsToEdge (conn, newLine);
<             return;
---
> 
>     private int getOutisePointOffRectanglePosition (Point p, Rectangle r) {
>         int position = PositionConstants.NONE;
>         if (r.x > p.x) {
>             position |= PositionConstants.WEST;
>         } else if (r.x + r.width < p.x) {
>             position |= PositionConstants.EAST;
354,360d312
<         updateIfNotRectilinear (conn, newLine);
<         boolean normalizationChangedLine = false;
<         if (! skipNormalization) {
<             normalizationChangedLine = removeSegmentsInViews (conn, newLine);
<             normalizationChangedLine |= removePointsInViews (conn, newLine);
<             Dimension tolerance = new Dimension (3, 0);
<             if (! RouterHelper.getInstance ().isFeedback (conn)) tolerance = (Dimension) MapModeUtil.getMapMode (conn).DPtoLP (tolerance);
362c314,317
<             normalizationChangedLine |= PointListUtilities.normalizeSegments (newLine, tolerance.width);
---
>         if (r.y > p.y) {
>             position |= PositionConstants.NORTH;
>         } else if (r.y + r.height < p.y) {
>             position |= PositionConstants.SOUTH;
364,371d318
<         checkEndSegments (conn, newLine);
<         resetEndPointsToEdge (conn, newLine);
<         straightenPoints (newLine);
<         if (normalizationChangedLine) {
<             if (nestedRoutingDepth < maxRoutingDepth) {
<                 nestedRoutingDepth ++;
<                 routeLine (conn, nestedRoutingDepth, newLine);
<                 if (nestedRoutingDepth != 0) nestedRoutingDepth --;
372a320
>         return position;
373a322,326
> 
>     private int getAnchorLocationBasedOnSegmentOrientation (Point anchorPoint, Rectangle rectangle, int segmentOrientation) {
>         if (segmentOrientation == PositionConstants.VERTICAL) {
>             if (Math.abs (anchorPoint.y - rectangle.y) < Math.abs (anchorPoint.y - rectangle.y - rectangle.height)) {
>                 return PositionConstants.NORTH;
375,394c328
<             Rectangle startRect = getBounds (conn.getSourceAnchor ().getOwner ());
<             conn.getSourceAnchor ().getOwner ().translateToAbsolute (startRect);
<             conn.translateToRelative (startRect);
<             Dimension buffer = new Dimension (2, 2);
<             conn.translateToRelative (buffer);
<             startRect.expand (buffer.width, buffer.height);
<             Rectangle endRect = getBounds (conn.getTargetAnchor ().getOwner ());
<             conn.getTargetAnchor ().getOwner ().translateToAbsolute (endRect);
<             conn.translateToRelative (endRect);
<             endRect.expand (buffer.width, buffer.height);
<             if (! startRect.contains (newLine.getPoint (0)) || ! endRect.contains (newLine.getPoint (newLine.size () - 1)) || newLine.size () - nStartSize >= 2) {
<                 newLine.removeAllPoints ();
<                 Point r1 = conn.getSourceAnchor ().getReferencePoint ();
<                 conn.translateToRelative (r1);
<                 newLine.addPoint (r1);
<                 Point r2 = conn.getTargetAnchor ().getReferencePoint ();
<                 conn.translateToRelative (r2);
<                 newLine.addPoint (r2);
<                 updateIfNotRectilinear (conn, newLine);
<                 resetEndPointsToEdge (conn, newLine);
---
>                 return PositionConstants.SOUTH;
395a330,334
>         } else if (segmentOrientation == PositionConstants.HORIZONTAL) {
>             if (Math.abs (anchorPoint.x - rectangle.x) < Math.abs (anchorPoint.x - rectangle.x - rectangle.width)) {
>                 return PositionConstants.WEST;
>             } else {
>                 return PositionConstants.EAST;
399,409c338
<     private boolean areEndsInBounds (Connection connection, PointList line) {
<         Rectangle startRect = new PrecisionRectangle (getBounds (connection.getSourceAnchor ().getOwner ()));
<         connection.getSourceAnchor ().getOwner ().translateToAbsolute (startRect);
<         connection.translateToRelative (startRect);
<         Rectangle endRect = new PrecisionRectangle (getBounds (connection.getTargetAnchor ().getOwner ()));
<         connection.getTargetAnchor ().getOwner ().translateToAbsolute (endRect);
<         connection.translateToRelative (endRect);
<         if (! startRect.contains (line.getPoint (0)) || ! endRect.contains (line.getPoint (line.size () - 1))) {
<             return false;
<         }
<         return true;
---
>         return PositionConstants.NONE;
412,413c341,355
<     private Rectangle getBounds (IFigure figure) {
<         return figure instanceof Connection ? ((Connection) figure).getPoints ().getBounds ().getCopy () : figure.getBounds ().getCopy ();
---
>     private boolean removeRedundantPoints (PointList line) {
>         int initialNumberOfPoints = line.size ();
>         if (line.size () > 2) {
>             PointList newLine = new PointList (line.size ());
>             newLine.addPoint (line.removePoint (0));
>             while (line.size () >= 2) {
>                 Point p0 = newLine.getLastPoint ();
>                 Point p1 = line.getPoint (0);
>                 Point p2 = line.getPoint (1);
>                 if (p0.x == p1.x && p0.x == p2.x) {
>                     line.removePoint (0);
>                 } else if (p0.y == p1.y && p0.y == p2.y) {
>                     line.removePoint (0);
>                 } else {
>                     newLine.addPoint (line.removePoint (0));
416,419d357
<     private Point getIntersectionPoint (Connection connection, LineSeg lineSeg) {
<         PointList intersections = lineSeg.getLineIntersectionsWithLineSegs (connection.getPoints ());
<         if (intersections.size () > 0) {
<             return PointListUtilities.pickClosestPoint (intersections, lineSeg.getOrigin ());
421c359,365
<         return null;
---
>             while (line.size () > 0) {
>                 newLine.addPoint (line.removePoint (0));
>             }
>             line.removeAllPoints ();
>             line.addAll (newLine);
>         }
>         return line.size () != initialNumberOfPoints;
