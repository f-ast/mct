372,374c372,374
<         List result = new ArrayList ();
<         List editParts = new ArrayList ();
<         List children = diagramEditPart.getPrimaryEditParts ();
---
>         List < PartPositionInfo > result = new ArrayList < PartPositionInfo > ();
>         List < IGraphicalEditPart > editParts = new ArrayList < IGraphicalEditPart > ();
>         List < IGraphicalEditPart > children = (List < IGraphicalEditPart >) diagramEditPart.getPrimaryEditParts ();
377,379c377
<         Iterator li = children.iterator ();
<         while (li.hasNext ()) {
<             IGraphicalEditPart part = (IGraphicalEditPart) li.next ();
---
>         for (IGraphicalEditPart part : children) {
383,385c381
<         Iterator iter = editParts.iterator ();
<         while (iter.hasNext ()) {
<             IGraphicalEditPart part = (IGraphicalEditPart) iter.next ();
---
>         for (IGraphicalEditPart part : editParts) {
405,406c401,458
<                     List envelopingPts = calculateEnvelopingPolyline (mainPts, new Point (imageRect.x, imageRect.y));
<                     List transformedPts = convertPolylineUnits (envelopingPts);
---
>                     List < Point > envelopingPts = calculateEnvelopingPolyline (mainPts, new Point (imageRect.x, imageRect.y));
>                     List < Point > transformedPts = convertPolylineUnits (envelopingPts);
>                     position.setPolyline (transformedPts);
>                     result.add (0, position);
>                 }
>             }
> 
>         }
>         return result;
>     }
> 
>     public List < PartPositionInfo > getConstrainedDiagramPartInfo (int maxWidth, int maxHeight, boolean useMargins) {
>         return getConstrainedDiagramPartInfo (_dgrmEP, maxWidth, maxHeight, useMargins);
>     }
> 
>     public List < PartPositionInfo > getConstrainedDiagramPartInfo (DiagramEditPart diagramEditPart, int maxWidth, int maxHeight, boolean useMargins) {
>         List < PartPositionInfo > result = new ArrayList < PartPositionInfo > ();
>         List < IGraphicalEditPart > editParts = new ArrayList < IGraphicalEditPart > ();
>         List < IGraphicalEditPart > children = (List < IGraphicalEditPart >) diagramEditPart.getPrimaryEditParts ();
>         IMapMode mm = getMapMode ();
>         ConstrainedImageRenderingData data = getConstrainedImageRenderingData (children, maxWidth, maxHeight, useMargins);
>         Rectangle imageRect = data.imageOriginalBounds.getCopy ();
>         mm.DPtoLP (imageRect);
>         if (useMargins) {
>             imageRect.shrink (getImageMargin (), getImageMargin ());
>         }
>         imageRect.performScale (data.scalingFactor);
>         if (useMargins) {
>             imageRect.expand (getImageMargin (), getImageMargin ());
>         }
>         for (IGraphicalEditPart part : children) {
>             editParts.add (part);
>             getNestedEditParts (part, editParts);
>         }
>         for (IGraphicalEditPart part : editParts) {
>             IFigure figure = part.getFigure ();
>             if (part instanceof ShapeEditPart || part instanceof ShapeCompartmentEditPart) {
>                 PartPositionInfo position = new PartPositionInfo ();
>                 position.setSemanticElement (ViewUtil.resolveSemanticElement ((View) part.getModel ()));
>                 Rectangle bounds = figure.getBounds ().getCopy ();
>                 translateToPrintableLayer (figure, bounds);
>                 bounds.performScale (data.scalingFactor);
>                 bounds.translate (- imageRect.x, - imageRect.y);
>                 position.setPartHeight (mm.LPtoDP (bounds.height));
>                 position.setPartWidth (mm.LPtoDP (bounds.width));
>                 position.setPartX (mm.LPtoDP (bounds.x));
>                 position.setPartY (mm.LPtoDP (bounds.y));
>                 result.add (0, position);
>             } else if (part instanceof ConnectionEditPart) {
>                 PartPositionInfo position = new PartPositionInfo ();
>                 position.setSemanticElement (ViewUtil.resolveSemanticElement ((View) part.getModel ()));
>                 if (figure instanceof PolylineConnection) {
>                     PolylineConnection mainPoly = (PolylineConnection) figure;
>                     PointList mainPts = mainPoly.getPoints ();
>                     mainPts.performScale (data.scalingFactor);
>                     translateToPrintableLayer (figure, mainPts);
>                     List < Point > envelopingPts = calculateEnvelopingPolyline (mainPts, new Point (imageRect.x, imageRect.y));
>                     List < Point > transformedPts = convertPolylineUnits (envelopingPts);
425,427c477,479
<     private List calculateEnvelopingPolyline (PointList polyPts, Point origin) {
<         ArrayList result = new ArrayList ();
<         List mainSegs = PointListUtilities.getLineSegments (polyPts);
---
>     private List < Point > calculateEnvelopingPolyline (PointList polyPts, Point origin) {
>         List < Point > result = new ArrayList < Point > ();
>         List < LineSeg > mainSegs = (List < LineSeg >) PointListUtilities.getLineSegments (polyPts);
452,453c504
<         Object first = result.get (0);
<         result.add (first);
---
>         result.add (result.get (0));
457,459c508,509
<     private List convertPolylineUnits (List polyPts) {
<         ArrayList result = new ArrayList ();
<         Iterator iter = polyPts.iterator ();
---
>     private List < Point > convertPolylineUnits (List < Point > polyPts) {
>         List < Point > result = new ArrayList < Point > ();
461,462c511
<         while (iter.hasNext ()) {
<             Point point = (Point) iter.next ();
---
>         for (Point point : polyPts) {
514,533c563,564
<             Rectangle originalBounds = new PrecisionRectangle (new Rectangle (calculateImageRectangle (editParts)));
<             getMapMode ().LPtoDP (originalBounds);
<             int deviceMargins = mm.LPtoDP (getImageMargin ());
<             int threshold = useMargins ? deviceMargins : 0;
<             double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
<             originalBounds.shrink (deviceMargins, deviceMargins);
<             if (maxDeviceWidth > threshold) {
<                 xScalingFactor = (maxDeviceWidth - threshold - threshold) / (originalBounds.preciseWidth ());
<             }
<             if (maxDeviceHeight > threshold) {
<                 yScalingFactor = (maxDeviceHeight - threshold - threshold) / (originalBounds.preciseHeight ());
<             }
<             double scalingFactor = Math.min (Math.min (xScalingFactor, yScalingFactor), 1);
<             int imageWidth = originalBounds.width + threshold + threshold;
<             int imageHeight = originalBounds.height + threshold + threshold;
<             if (scalingFactor < 1) {
<                 imageWidth = (int) Math.round (originalBounds.preciseWidth () * scalingFactor) + threshold + threshold;
<                 imageHeight = (int) Math.round (originalBounds.preciseHeight () * scalingFactor) + threshold + threshold;
<             }
<             graphics = setUpGraphics (imageWidth, imageHeight);
---
>             ConstrainedImageRenderingData data = getConstrainedImageRenderingData (editParts, maxDeviceWidth, maxDeviceHeight, useMargins);
>             graphics = setUpGraphics (data.imageWidth, data.imageHeight);
536,538c567,569
<             graphics.translate (threshold, threshold);
<             mapModeGraphics.scale (scalingFactor);
<             Point location = new PrecisionPoint (originalBounds.preciseX (), originalBounds.preciseY ());
---
>             graphics.translate (data.margin, data.margin);
>             mapModeGraphics.scale (data.scalingFactor);
>             Point location = new PrecisionPoint (data.imageOriginalBounds.preciseX (), data.imageOriginalBounds.preciseY ());
548a580,614
>     class ConstrainedImageRenderingData {
>         double scalingFactor;
>         int imageWidth;
>         int imageHeight;
>         Rectangle imageOriginalBounds;
>         int margin;
>     }
> 
>     ConstrainedImageRenderingData getConstrainedImageRenderingData (List editParts, int maxDeviceWidth, int maxDeviceHeight, boolean useMargins) {
>         ConstrainedImageRenderingData data = new ConstrainedImageRenderingData ();
>         IMapMode mm = getMapMode ();
>         data.imageOriginalBounds = new PrecisionRectangle (new Rectangle (calculateImageRectangle (editParts)));
>         mm.LPtoDP (data.imageOriginalBounds);
>         int deviceMargins = mm.LPtoDP (getImageMargin ());
>         data.margin = useMargins ? deviceMargins : 0;
>         double xScalingFactor = 1.0, yScalingFactor = xScalingFactor;
>         data.imageOriginalBounds.shrink (deviceMargins, deviceMargins);
>         if (maxDeviceWidth > data.margin) {
>             xScalingFactor = (maxDeviceWidth - data.margin - data.margin) / (data.imageOriginalBounds.preciseWidth ());
>         }
>         if (maxDeviceHeight > data.margin) {
>             yScalingFactor = (maxDeviceHeight - data.margin - data.margin) / (data.imageOriginalBounds.preciseHeight ());
>         }
>         data.scalingFactor = Math.min (Math.min (xScalingFactor, yScalingFactor), 1);
>         data.imageWidth = data.imageOriginalBounds.width + data.margin + data.margin;
>         data.imageHeight = data.imageOriginalBounds.height + data.margin + data.margin;
>         if (data.scalingFactor < 1) {
>             data.imageWidth = (int) Math.round (data.imageOriginalBounds.preciseWidth () * data.scalingFactor) + data.margin + data.margin;
>             data.imageHeight = (int) Math.round (data.imageOriginalBounds.preciseHeight () * data.scalingFactor) + data.margin + data.margin;
>         } else {
>             data.scalingFactor = 1;
>         }
>         return data;
>     }
> 
