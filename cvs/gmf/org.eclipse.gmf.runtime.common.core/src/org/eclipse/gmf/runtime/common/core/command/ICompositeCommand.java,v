head	1.1;
access;
symbols
	v20081020-0700:1.1
	v20080722-1827:1.1
	R2_1_maintenance:1.1.0.6
	Root_R2_1_maintenance:1.1
	R2_1_0:1.1
	v20080425-1959:1.1
	v20080402-1725:1.1
	v20080328-1605:1.1
	v20080222-1200:1.1
	v20080215-1500:1.1
	v20080201-2010:1.1
	v20080118-1415:1.1
	v20080118-1129:1.1
	v20071108-0000:1.1
	v20070809-0000:1.1
	R2_0_maintenance:1.1.0.4
	R2_0:1.1
	R4_20:1.1
	RC3_20:1.1
	v20070601-1400:1.1
	v20070518-1300:1.1
	v20070420-1000:1.1
	v20070330-1300:1.1
	v20070221-1500:1.1
	v20070209-1900:1.1
	v20060209-1900:1.1
	v20070208-1800:1.1
	v20070119-1200:1.1
	M4_20:1.1
	v20061214-0000:1.1
	M3_20:1.1
	v20061117-0800:1.1
	v20061020-1000:1.1
	v20061013-1330:1.1
	v20060925-1700:1.1
	v20060919-0800:1.1
	v20060907-1100:1.1
	M1_20:1.1
	v20060824-1600:1.1
	v20060810-1700:1.1
	v20060803-1200:1.1
	v20060728-0500:1.1
	v20060721-1130:1.1
	v20060713-1700:1.1
	R1_0_maintenance:1.1.0.2
	R1_0:1.1
	v20060627-1200:1.1
	v20060616-1200:1.1
	v20060531-1730:1.1
	v20060526-1200:1.1
	I20060505-1400:1.1
	I20060424-0500:1.1
	I20060424-0300:1.1
	M6_10:1.1
	I20060407-1200:1.1
	I20060331-1000:1.1
	I20060324-0300:1.1
	I20060317-1300:1.1
	I20060317-1200:1.1
	I20060316-1300:1.1
	I20060309-1300:1.1
	M5_10:1.1
	S20060303-1600:1.1
	I20060227-1730:1.1
	I20060216-1945:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.1
date	2006.02.13.19.11.59;	author ldamus;	state Exp;
branches;
next	;


desc
@@


1.1
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@/******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.core.command;

import java.util.Iterator;
import java.util.ListIterator;

import org.eclipse.core.commands.operations.ICompositeOperation;
import org.eclipse.core.commands.operations.IUndoableOperation;
import org.eclipse.core.resources.IFile;

/**
 * A self-composing undoable operation that is has a {@@link CommandResult}, a
 * list of affected {@@link IFile}s, and is composed of child operations.
 * <P>
 * Does not extend <code>ICompositeOperation</code> because
 * <UL>
 * <LI> {@@link #remove(IUndoableOperation)} does not dispose the removed
 * operation</LI>
 * <LI> Children are explicitely composed by the client. Adding to an open
 * composite through the operation history is not supported.</LI>
 * </UL>
 * 
 * @@author ldamus
 */
public interface ICompositeCommand
    extends ICommand {

    /**
     * <p>
     * Add the specified operation as a child of this operation.
     * </p>
     * 
     * @@param operation
     *            the operation to be added. If the operation instance has
     *            already been added, this method will have no effect.
     */
    public abstract void add(IUndoableOperation operation);

    /**
     * <p>
     * Remove the specified operation from this operation.
     * </p>
     * <p>
     * Unlike {@@link ICompositeOperation}, this does not dispose of the removed
     * operation since the composite did not create the operation.
     * </p>
     * 
     * @@param operation
     *            the operation to be removed. The operation should be disposed
     *            by the receiver. This method will have no effect if the
     *            operation instance is not already a child.
     */
    public abstract void remove(IUndoableOperation operation);

    /**
     * Answers whether or not this composite operation has children.
     * 
     * @@return <code>true</code> if the operation does not have children,
     *         <code>false</code> otherwise.
     */
    public abstract boolean isEmpty();

    /**
     * Queries the number of child operations that I contain.
     * 
     * @@return my size
     */
    public abstract int size();

    /**
     * Obtains an iterator to traverse my child operations. Removing children
     * via this iterator correctly maintains my undo contexts.
     * 
     * @@return an iterator of my children
     */
    public abstract Iterator iterator();

    /**
     * Obtains an iterator to traverse my child operations in either direction.
     * Adding and removing children via this iterator correctly maintains my
     * undo contexts.
     * <p>
     * <b>Note</b> that, unlike list iterators generally, this one does not
     * permit the addition of an operation that I already contain (the composite
     * does not permit duplicates). Moreover, only {@@link IUndoableOperation}s
     * may be added, otherwise <code>ClassCastException</code>s will result.
     * </p>
     * 
     * @@return an iterator of my children
     */
    public abstract ListIterator listIterator();

    /**
     * Obtains an iterator to traverse my child operations in either direction,
     * starting from the specified <code>index</code>. Adding and removing
     * children via this iterator correctly maintains my undo contexts.
     * <p>
     * <b>Note</b> that, unlike list iterators generally, this one does not
     * permit the addition of an operation that I already contain (the composite
     * does not permit duplicates). Moreover, only {@@link IUndoableOperation}s
     * may be added, otherwise <code>ClassCastException</code>s will result.
     * </p>
     * 
     * @@param index
     *            the index in my children at which to start iterating
     * 
     * @@return an iterator of my children
     */
    public abstract ListIterator listIterator(int index);
}
@
