head	1.5;
access;
symbols
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.4
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.5
date	2006.03.27.21.12.44;	author ldamus;	state dead;
branches;
next	1.4;

1.4
date	2006.02.13.19.11.59;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.13.20.32.05;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.25.25;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.16;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.5
log
@[112826] gmf_head ldamus 060327 Adopt Eclipse 3.1 Operation History Framework - removing deprecated API
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.core.command;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.operations.IOperationHistory;
import org.eclipse.core.commands.operations.IUndoContext;
import org.eclipse.core.commands.operations.IUndoableOperation;
import org.eclipse.core.commands.operations.ObjectUndoContext;
import org.eclipse.core.commands.operations.OperationHistoryFactory;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;
import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreStatusCodes;
import org.eclipse.gmf.runtime.common.core.util.EnumeratedType;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;

/**
 * Manages the execution of
 * {@@link org.eclipse.gmf.runtime.common.core.command.ICommand}s.
 * <P>
 * Applications can channel their command executions through a command manager
 * which will maintain a history of the commands that it has executed that are
 * eligible to be undone and redone. The number of commands that are remembered
 * by the command manager is finite, and defined by the
 * {@@link #setFlushThreshold(int)} method. When this threshold is reached the
 * command manager will flush a certain number of commands from its memory
 * (defined by the {@@link #setFlushCount(int)} method).
 * <P>
 * A command manager has a state, which is one of CLEARING, EXECUTING, IDLE,
 * REDOING or UNDOING. When the command manager transitions from one state to
 * another, it will notify any registered
 * {@@link org.eclipse.gmf.runtime.common.core.command.ICommandManagerChangeListener}s
 * of the operation that just occurred which caused it to change state.
 * <P>
 * The command manager does not support nested command execution. Clients should
 * never ask the command manager to execute a command while it is already in the
 * process of executing a command. An exception will occur in this case.
 * 
 * @@author khussey
 * @@author ldamus
 * 
 * @@deprecated Use the {@@link OperationHistoryFactory#getOperationHistory()}
 *             instead.
 * 
 * @@canBeSeenBy %partners
 */
public class CommandManager {

	/**
	 * An enumeration of command manager states.
	 * 
	 * @@author khussey
	 */
	public static class State extends EnumeratedType {

		private static final long serialVersionUID = 1L;

		/**
		 * The command manager is clearing its list of commands.
		 */
		public static final State CLEARING = new State("Clearing"); //$NON-NLS-1$

		/**
		 * The command manager is executing a command.
		 */
		public static final State EXECUTING = new State("Executing"); //$NON-NLS-1$

		/**
		 * The command manager is idle.
		 */
		public static final State IDLE = new State("Idle"); //$NON-NLS-1$

		/**
		 * The command manager is redoing a command.
		 */
		public static final State REDOING = new State("Redoing"); //$NON-NLS-1$

		/**
		 * The command manager is undoing a command.
		 */
		public static final State UNDOING = new State("Undoing"); //$NON-NLS-1$

		/**
		 * The command manager is flushing down to a command
		 */
		public static final State FLUSHING = new State("Flushing"); //$NON-NLS-1$

		/**
		 * The list of values for this enumerated type.
		 */
		private static final State[] VALUES = { CLEARING, EXECUTING, IDLE,
				REDOING, UNDOING, FLUSHING };

		/**
		 * An internal unique identifier for command manager states.
		 */
		private static int nextOrdinal = 0;

		/**
		 * Constructs a new command manager state with the specified name.
		 * 
		 * @@param name
		 *            The name of the new command manager state.
		 */
		private State(String name) {
			super(name, nextOrdinal++);
		}

		/**
		 * Retrieves the list of constants for this enumerated type.
		 * 
		 * @@return The list of constants for this enumerated type.
		 * 
		 * @@see EnumeratedType#getValues()
		 */
		protected List getValues() {
			return Collections.unmodifiableList(Arrays.asList(VALUES));
		}

	}

	/**
	 * The default flush threshold. This is the maximum number of undoable
	 * commands that will be remembered by this command manager.
	 */
	protected static int DEFAULT_FLUSH_THRESHOLD = 20;

	/**
	 * The default flush count. This is the number of commands that are fluxhed
	 * from this command manager's memory when the flush threshold is exceeded.
	 */
	protected static int DEFAULT_FLUSH_COUNT = 1;

	/**
	 * The default command manager.
	 */
	private static CommandManager commandManager = null;

	/**
	 * The command manager change listeners.
	 */
	private final List listeners = Collections
			.synchronizedList(new ArrayList());

	/**
	 * The state of this command manager.
	 */
	private State state = State.IDLE;

	/**
	 * The currently executing command.
	 */
	private ICommand currentlyExecutingCommand = null;

	/**
	 * My undo context.
	 */
	private IUndoContext undoContext;

	/**
	 * My operation history delegate.
	 */
	private final IOperationHistory delegate;
    
    /**
     * The number of commands to flush from the undo stack.
     */
    protected int flushCount = 0;

	/**
	 * Constructs a new command manager.
	 */
	public CommandManager() {
		super();
		delegate = OperationHistoryFactory.getOperationHistory();
	}
    
    /**
     * Initializes me with an operation history.
     */
    public CommandManager(IOperationHistory operationHistory) {
        super();
        delegate = operationHistory;
    }

	/**
	 * Retrieves the default command manager.
	 * 
	 * @@return The default command manager.
	 */
	public static CommandManager getDefault() {
		if (null == commandManager) {
			commandManager = new CommandManager();
			commandManager.setFlushThreshold(DEFAULT_FLUSH_THRESHOLD);
			commandManager.setFlushCount(DEFAULT_FLUSH_COUNT);
		}

		return commandManager;
	}
    
    /**
     * Returns my delegate operation history.
     * 
     * @@return my delegate operation history
     */
    public final IOperationHistory getOperationHistory() {
        return delegate;
    }

	/**
	 * Retrieves the list of commands being managed.
	 * 
	 * @@return The list of commands being managed.
	 */
	protected final List getCommands() {

		List result = new ArrayList();

		IUndoableOperation[] undoHistory = delegate
				.getUndoHistory(getUndoContext());

		result.addAll(Arrays.asList(undoHistory));

		IUndoableOperation[] redoHistory = delegate
				.getRedoHistory(getUndoContext());

		result.addAll(Arrays.asList(redoHistory));

		return result;
	}

	/**
	 * Retrieves the list of clisteners listening for changes to this command
	 * manager.
	 * 
	 * @@return The listeners.
	 */
	protected final List getListeners() {
		return listeners;
	}

	/**
	 * Retrieves the state of this command manager.
	 * 
	 * @@return The state of this command manager.
	 */
	public final State getState() {
		return state;
	}

	/**
	 * Sets the state of this command manager.
	 * 
	 * @@param state
	 *            The new state.
	 */
	protected final void setState(State state) {
		this.state = state;
	}

	/**
	 * Retrieves the index of the command that can be undone.
	 * 
	 * @@return The index of the command that can be undone.
	 * 
	 * @@deprecated Undo index no longer maintained. Returns 0.
	 */
	protected final int getUndoIndex() {
		return 0;
	}

	/**
	 * Sets the index of the command that can be undone.
	 * 
	 * @@param undoIndex
	 *            The new index of the command that can be undone.
	 * @@deprecated Undo index no longer maintained. Does nothing.
	 */
	protected final void setUndoIndex(int undoIndex) {
		// does nothing
	}

	/**
	 * Retrieves the maximum number of undoable commands that will be remembered
	 * by this command manager.
	 * 
	 * @@return The maximum number of undoable commands that will be remembered
	 *         by this command manager.
	 */
	public final int getFlushThreshold() {
		return delegate.getLimit(getUndoContext());
	}

	/**
	 * Sets the maximum number of undoable commands that will be remembered by
	 * this command manager.
	 * 
	 * @@param flushThreshold
	 *            The new maximum number of undoable commands that will be
	 *            remembered by this command manager.
	 */
	public final void setFlushThreshold(int flushThreshold) {
		assert (0 < flushThreshold);

		delegate.setLimit(getUndoContext(), flushThreshold);

		fireCommandManagerChange(new CommandManagerChangeEvent(this));
		Trace
				.trace(
						CommonCorePlugin.getDefault(),
						CommonCoreDebugOptions.COMMANDS_ADMIN,
						"Command manager flush threshold set to " + String.valueOf(flushThreshold) + "."); //$NON-NLS-1$ //$NON-NLS-2$
	}

	/**
	 * Retrieves the number of undoable commands that are flushed from this
	 * command manager's memory when the flush threshold is exceeded.
	 * 
	 * @@return The number of undoable commands that are flushed from this
	 *         command manager's memory when the flush threshold is exceeded.
	 * @@deprecated Flush count is fixed at 1.
	 */
	public final int getFlushCount() {
        return flushCount;
	}

	/**
	 * Sets the number of undoable commands that are flushed from this command
	 * manager's memory when the flush threshold is exceeded.
	 * 
	 * @@param flushCount
	 *            The new number of undoable commands that are flushed from this
	 *            command manager's memory when the flush threshold is exceeded.
	 * @@deprecated Flush count is fixed at 1. This method has no effect.
	 */
	public final void setFlushCount(int flushCount) {
        assert (0 <= flushCount);
        
        this.flushCount = flushCount;
        
        fireCommandManagerChange(new CommandManagerChangeEvent(this));
        Trace
            .trace(
                CommonCorePlugin.getDefault(),
                CommonCoreDebugOptions.COMMANDS_ADMIN,
                "Command manager flush count set to " + String.valueOf(flushCount) + "."); //$NON-NLS-1$ //$NON-NLS-2$
	}

	/**
	 * Adds the specified <code>listener</code> to the list of command manager
	 * change listeners for this command manager.
	 * 
	 * @@param listener
	 *            The listener to be added.
	 */
	public void addCommandManagerChangeListener(
			ICommandManagerChangeListener listener) {

		assert null != listener : "null listener"; //$NON-NLS-1$
		getListeners().add(listener);
	}

	/**
	 * Removes the specified <code>listener</code> from the list of command
	 * manager change listeners for this command manager.
	 * 
	 * @@param listener
	 *            The listener to be removed.
	 */
	public void removeCommandManagerChangeListener(
			ICommandManagerChangeListener listener) {

		assert null != listener : "null listener"; //$NON-NLS-1$
		getListeners().remove(listener);
	}

	/**
	 * Notifies the listeners for this command manager that the specified event
	 * has occurred.
	 * 
	 * @@param event
	 *            The command manager change event to be fired.
	 */
	protected void fireCommandManagerChange(CommandManagerChangeEvent event) {
		assert null != event : "null event"; //$NON-NLS-1$

		List targets = null;
		synchronized (getListeners()) {
			targets = new ArrayList(getListeners());
		}

		for (Iterator i = targets.iterator(); i.hasNext();) {
			((ICommandManagerChangeListener) i.next())
					.commandManagerChanged(event);
		}
	}

	/**
	 * Delegates to the operation history.
	 */
	protected void addCommand(ICommand command) {
        
	    // Add the command manager context
        command.addContext(getUndoContext());
        
		delegate.add(command);
	}

	/**
	 * Clears the redo stack.
	 */
	protected void clearRedoCommands() {

		if (canRedo()) {
			State originalState = getState();

			try {

				setState(State.CLEARING);

				IUndoableOperation firstCleared = delegate
						.getRedoOperation(getUndoContext());
				clearRedo();

				if (firstCleared instanceof ICommand) {
					fireCommandManagerChange(new CommandManagerChangeEvent(
							this, (ICommand) firstCleared));
				}

				Trace.trace(CommonCorePlugin.getDefault(),
						CommonCoreDebugOptions.COMMANDS_ADMIN,
						"Command manager redo cleared."); //$NON-NLS-1$

			} finally {
				setState(originalState);
			}
		}
	}

	/**
	 * Clears the redo stack starting at a specified command.
	 * 
	 * @@param command
	 *            the command to clear
	 */
	protected void clearRedoCommands(ICommand command) {

		// clear the entire redo stack
		delegate.dispose(getUndoContext(), false, true, false);
	}

	/**
	 * Clears the redo stack starting at <code>index</code> and clearing to
	 * the top (end) of the command list.
	 * 
	 * @@param index
	 *            the starting index
	 * @@deprecated Clears the entire redo stack.
	 */
	protected void clearRedo(int index) {
		delegate.dispose(getUndoContext(), false, true, false);
	}

	/**
	 * Clears the redo stack.
	 */
	public void clearRedo() {
		delegate.dispose(getUndoContext(), false, true, false);
	}

	/**
	 * Clears the redo stack starting at <code>command</code>, clearing to
	 * the top of the stack.
	 * 
	 * @@param command
	 *            the command to be cleared
	 * @@deprecated Clears the entire redo stack.
	 */
	public void clearRedoCommand(ICommand command) {
		State originalState = getState();
		try {
			setState(State.CLEARING);

			clearRedoCommands(command);

			fireCommandManagerChange(new CommandManagerChangeEvent(this,
					command));
			Trace.trace(CommonCorePlugin.getDefault(),
					CommonCoreDebugOptions.COMMANDS_ADMIN,
					"Command manager redo cleared."); //$NON-NLS-1$

		} finally {
			setState(originalState);
		}
	}

	/**
	 * Clears the undo stack.
	 */
	protected void clearUndoCommands() {
		delegate.dispose(getUndoContext(), true, false, false);
	}

	/**
	 * Removes commands on the command stack down to, and including, the given
	 * <code>command</code>.
	 * 
	 * @@param command
	 *            the command to flush down to
	 * @@deprecated Flushes the entire undo stack.
	 */
	protected void flushCommands(ICommand command) {

		flush(1);
	}

	/**
	 * Clears this command manager by emptying its list of undoable and redoable
	 * commands.
	 */
	public final void clear() {
		try {
			setState(State.CLEARING);

			clearRedoCommands();
			clearUndoCommands();

			fireCommandManagerChange(new CommandManagerChangeEvent(this));
			Trace.trace(CommonCorePlugin.getDefault(),
					CommonCoreDebugOptions.COMMANDS_ADMIN,
					"Command manager cleared."); //$NON-NLS-1$

		} finally {
			setState(State.IDLE);
		}
	}

	/**
	 * Removes commands on the command stack down to, and including, the given
	 * <code>command</code>.
	 * 
	 * @@param command
	 *            the command to flush down to
	 * @@deprecated Flushes the entire undo stack.
	 */
	public final void flush(ICommand command) {

		flushCommands(command);
	}

	/**
	 * Removes <code>flushCount</code> commands from the bottom of the undo
	 * stack.
	 * 
	 * @@deprecated Flushes the entire undo stack.
	 */
	protected void flush() {
		flush(getFlushCount());
	}

	/**
	 * Removes <code>count</code> commands from the bottom of the undo stack.
	 * 
	 * @@param count
	 *            number of commands to remove from the bottom of the undo stack
	 * @@deprecated Flushes the entire undo stack.
	 */
	protected void flush(int count) {

		if (count < 1) {
			return;
		}

		State originalState = getState();

		try {
			setState(State.FLUSHING);

			IUndoableOperation command = delegate
					.getUndoOperation(getUndoContext());

			delegate.dispose(getUndoContext(), true, false, false);

			if (command instanceof ICommand) {
				fireCommandManagerChange(new CommandManagerChangeEvent(this,
						(ICommand) command));
			}

			Trace.trace(CommonCorePlugin.getDefault(),
					CommonCoreDebugOptions.COMMANDS_ADMIN,
					"Command manager flushed up to " + command.getLabel()); //$NON-NLS-1$

		} finally {
			setState(originalState);
		}
	}

	/**
	 * Delegates to the operation history.
	 */
	public boolean canRedo() {
		return delegate.canRedo(getUndoContext());
	}

	/**
	 * Delegates to the operation history.
	 */
	public boolean canUndo() {
		return delegate.canUndo(getUndoContext());
	}

	/**
	 * Retrieves a label for the command that can be redone.
	 * 
	 * @@return A label for the command that can be redone.
	 */
	public String getRedoLabel() {
		IUndoableOperation redoOperation = delegate
				.getRedoOperation(getUndoContext());

		if (redoOperation != null) {
			return redoOperation.getLabel();
		}
		return null;
	}

	/**
	 * Retrieves a label for the command that can be undone.
	 * 
	 * @@return A label for the command that can be undone.
	 */
	public String getUndoLabel() {
		IUndoableOperation undoOperation = delegate
				.getUndoOperation(getUndoContext());

		if (undoOperation != null) {
			return undoOperation.getLabel();
		}
		return null;
	}

	/**
	 * Executes the specified <code>command</code> without monitoring its
	 * progress.
	 * <P>
	 * The command manager does not support nested command execution. Clients
	 * should never ask the command manager to execute a command while it is
	 * already in the process of executing a command. An exception will occur in
	 * this case.
	 * 
	 * @@param command
	 *            The command to be executed.
	 * @@return The result of executing the command.
	 * 
	 * @@exception UnsupportedOperationException
	 *                If the command cannot be executed.
	 * @@exception IllegalStateException
	 *                If the command manager is already in the EXECUTING state.
	 */
	public CommandResult execute(ICommand command) {
		return execute(command, new NullProgressMonitor());
	}

	/**
	 * Executes the specified command while monitoring its progress.
	 * <P>
	 * The <code>progressMonitor</code> must not be <code>null</code>. To
	 * execute a command without a progress, use {@@link #execute(ICommand)}.
	 * <P>
	 * The command manager does not support nested command execution. Clients
	 * should never ask the command manager to execute a command while it is
	 * already in the process of executing a command. An exception will occur in
	 * this case.
	 * 
	 * @@param command
	 *            The command to be executed.
	 * @@param progressMonitor
	 *            The object that monitors the progress of this command
	 *            execution.
	 * @@return The result of executing the command.
	 * @@exception UnsupportedOperationException
	 *                If the command cannot be executed.
	 * @@exception IllegalStateException
	 *                If the command manager is already in the EXECUTING state.
	 */
	public CommandResult execute(ICommand command,
			IProgressMonitor progressMonitor) {

		assert null != progressMonitor;

		if (getState() == State.EXECUTING) {
			throw new IllegalStateException(
					"Command Manager cannot perform the nested command execution while it is already in the process of executing a command."); //$NON-NLS-1$
		}
        
        // Add the command manager context
        command.addContext(getUndoContext());

		if (!command.canExecute()) {
			UnsupportedOperationException uoe = new UnsupportedOperationException(
					"Trying to execute an unexecutable command (" + command.getLabel() + ")"); //$NON-NLS-1$ //$NON-NLS-2$
			Trace.throwing(CommonCorePlugin.getDefault(),
					CommonCoreDebugOptions.EXCEPTIONS_THROWING, getClass(),
					"execute", uoe); //$NON-NLS-1$
			throw uoe;
		}

		Log.info(CommonCorePlugin.getDefault(), CommonCoreStatusCodes.OK,
				"Executing command '" + command.getLabel() + "'..."); //$NON-NLS-1$ //$NON-NLS-2$

		CommandResult result = null;

		try {
			setState(State.EXECUTING);
			setCurrentlyExecutingCommand(command);

			delegate.execute(command, progressMonitor, null);

			result = command.getCommandResult();

			if (IStatus.ERROR != result.getStatus().getSeverity()) {

				if (!command.canUndo()) {

					if (!command.getAffectedFiles().isEmpty()) {
						clearUndoCommands();
					}
				}

				fireCommandManagerChange(new CommandManagerChangeEvent(this,
						command));

			} else if (CommonCoreStatusCodes.CANCELLED == result.getStatus()
					.getCode()) {
				// RATLC00529649 - temporary fix - clear redo command when a
				// command is cancelled
				clearRedoCommand(command);
			}

		} catch (ExecutionException e) {
			Log
					.error(
							CommonCorePlugin.getDefault(),
							CommonCoreStatusCodes.COMMAND_FAILURE,
							"Command execution failed: '" + command.getLabel() + "'.", e); //$NON-NLS-1$ //$NON-NLS-2$

		} finally {
			setCurrentlyExecutingCommand(null);
			setState(State.IDLE);
		}

		Trace.trace(CommonCorePlugin.getDefault(),
				CommonCoreDebugOptions.COMMANDS_EXECUTE,
				"Command '" + String.valueOf(command) + "' executed."); //$NON-NLS-1$ //$NON-NLS-2$

		return result;
	}

	/**
	 * Returns the command that is currently being executed, if I am in the
	 * EXECUTING state, or <code>null</code> if I am not executing.
	 * 
	 * @@return the command that I am currently executing
	 */
	public ICommand getCurrentlyExecutingCommand() {
		if (getState() == State.EXECUTING) {
			return currentlyExecutingCommand;
		}
		return null;
	}

	/**
	 * Sets the command that I am currently executing if my state is EXECUTING.
	 * Does nothing if I am not in the EXECUTING state.
	 * 
	 * @@param command
	 *            the currently executing command
	 */
	private void setCurrentlyExecutingCommand(ICommand command) {
		if (getState() == State.EXECUTING) {
			currentlyExecutingCommand = command;
		}
	}

	/**
	 * Redoes the command on the top of the redo stack.
	 * 
	 * @@return The result of redoing the command.
	 * @@exception UnsupportedOperationException
	 *                If a command cannot be redone.
	 */
	public CommandResult redo() {

		if (getState() == State.REDOING) {
			// RATLC00138974- Ignore redo() requests while we are already
			// redoing.
			return null;
		}

		if (!canRedo()) {
			UnsupportedOperationException uoe = new UnsupportedOperationException();
			Trace.throwing(CommonCorePlugin.getDefault(),
					CommonCoreDebugOptions.EXCEPTIONS_THROWING, getClass(),
					"redo", uoe); //$NON-NLS-1$
			throw uoe;
		}

		ICommand command = null;
		CommandResult result = null;

		try {
			setState(State.REDOING);

			command = (ICommand) delegate.getRedoOperation(getUndoContext());
			Log.info(CommonCorePlugin.getDefault(), CommonCoreStatusCodes.OK,
					"Redoing command '" + command.getLabel() + "'..."); //$NON-NLS-1$ //$NON-NLS-2$
			delegate.redo(getUndoContext(), new NullProgressMonitor(), null);
			result = command.getCommandResult();

			if (IStatus.ERROR != result.getStatus().getSeverity()) {

				if (!command.canUndo()) {

					if (!command.getAffectedFiles().isEmpty()) {
						clearUndoCommands();
					}
				}

				fireCommandManagerChange(new CommandManagerChangeEvent(this,
						command));
			}
		} catch (ExecutionException e) {
			Log.error(CommonCorePlugin.getDefault(),
					CommonCoreStatusCodes.COMMAND_FAILURE,
					"Command redo failed: '" + command.getLabel() + "'.", e); //$NON-NLS-1$ //$NON-NLS-2$

		} finally {
			setState(State.IDLE);
		}

		Trace.trace(CommonCorePlugin.getDefault(),
				CommonCoreDebugOptions.COMMANDS_REDO,
				"Command '" + String.valueOf(command) + "' redone."); //$NON-NLS-1$ //$NON-NLS-2$
		return result;
	}

	/**
	 * Undoes the command on the top of the undo stack.
	 * 
	 * @@return The result of undoing the command.
	 * @@exception UnsupportedOperationException
	 *                If a command cannot be undone.
	 */
	public CommandResult undo() {

		if (getState() == State.UNDOING) {
			// RATLC00138974 - Ignore undo() requests while we are already
			// undoing.
			return null;
		}

		if (!canUndo()) {
			UnsupportedOperationException uoe = new UnsupportedOperationException();
			Trace.throwing(CommonCorePlugin.getDefault(),
					CommonCoreDebugOptions.EXCEPTIONS_THROWING, getClass(),
					"undo", uoe); //$NON-NLS-1$
			throw uoe;
		}

		ICommand command = null;
		CommandResult result = null;

		try {
			setState(State.UNDOING);

			command = (ICommand) delegate.getUndoOperation(getUndoContext());
			Log.info(CommonCorePlugin.getDefault(), CommonCoreStatusCodes.OK,
					"Undoing command '" + command.getLabel() + "'..."); //$NON-NLS-1$ //$NON-NLS-2$

			delegate.undo(getUndoContext(), new NullProgressMonitor(), null);

			result = command.getCommandResult();

			if (IStatus.ERROR != result.getStatus().getSeverity()) {

				if (!command.canRedo()) {

					if (!command.getAffectedFiles().isEmpty()) {
						clearRedoCommands();
					}
				}

				fireCommandManagerChange(new CommandManagerChangeEvent(this,
						command));
			}

		} catch (ExecutionException e) {
			Log.error(CommonCorePlugin.getDefault(),
					CommonCoreStatusCodes.COMMAND_FAILURE,
					"Command undo failed: '" + command.getLabel() + "'.", e); //$NON-NLS-1$ //$NON-NLS-2$

		} finally {
			setState(State.IDLE);
		}

		Trace.trace(CommonCorePlugin.getDefault(),
				CommonCoreDebugOptions.COMMANDS_UNDO,
				"Command '" + String.valueOf(command) + "' undone."); //$NON-NLS-1$ //$NON-NLS-2$

		return result;
	}

	/**
	 * Undoes the every command down to, and including, the given command.
	 * 
	 * @@param command
	 *            the command to undo to
	 */
	public void undo(ICommand command) {

		List undoHistory = Arrays.asList(delegate
				.getUndoHistory(getUndoContext()));

		int index = undoHistory.indexOf(command);
		assert (index != -1);

		for (int i = 0; i <= index; i++) {
			undo();
		}
	}

	/**
	 * Redoes the every command up to, and including, the given command.
	 * 
	 * @@param command
	 *            the command to redo to
	 */
	public void redo(ICommand command) {

		List redoHistory = Arrays.asList(delegate
				.getRedoHistory(getUndoContext()));

		int index = redoHistory.indexOf(command);
		assert (index != -1);

		for (int i = 0; i <= index; i++) {
			redo();
		}
	}

	/**
	 * Gets my undo context. I add my context to all commands executed through
	 * me.
	 * 
	 * @@return my undo context
	 */
	public IUndoContext getUndoContext() {
		if (undoContext == null) {
			undoContext = new ObjectUndoContext(this);
		}
		return undoContext;
	}

}@


1.4
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@@


1.3
log
@[110317] gmf_head ahunter 051312 Compiler warning count should be 0 - runtime foundation layer components
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
a18 1
import java.util.ListIterator;
d20 6
a28 1

d51 1
a51 1
 * {@@link org.eclipse.gmf.runtime.common.core.command.ICommandManagerChangeListener}s 
d59 5
d73 1
a73 2
	public static class State
		extends EnumeratedType {
d110 2
a111 2
		private static final State[] VALUES = {CLEARING, EXECUTING, IDLE,
			REDOING, UNDOING, FLUSHING};
d152 1
a152 1
	
a158 5
	 * The list of commands being managed.
	 */
	private final List commands = new ArrayList();

	/**
d162 1
a162 1
		.synchronizedList(new ArrayList());
d170 1
a170 1
	 * The index of the command that can be undone.
d172 1
a172 1
	private int undoIndex = -1;
d175 1
a175 1
	 * The maximum size of the undo stack.
d177 1
a177 1
	protected int flushThreshold = Integer.MAX_VALUE;
d180 1
a180 1
	 * The number of commands to flush from the undo stack.
d182 6
a187 6
	protected int flushCount = 0;

	/**
	 * The currently executing command.
	 */
	private ICommand currentlyExecutingCommand = null;
d194 1
d196 8
d219 9
d235 14
a248 1
		return commands;
d284 2
d288 1
a288 1
		return undoIndex;
d296 1
d299 1
a299 1
		this.undoIndex = undoIndex;
d310 1
a310 1
		return flushThreshold;
d324 1
a324 1
		this.flushThreshold = flushThreshold;
d328 4
a331 4
			.trace(
				CommonCorePlugin.getDefault(),
				CommonCoreDebugOptions.COMMANDS_ADMIN,
				"Command manager flush threshold set to " + String.valueOf(flushThreshold) + "."); //$NON-NLS-1$ //$NON-NLS-2$
d340 1
d343 1
a343 1
		return flushCount;
d353 1
d356 10
a365 10
		assert (0 <= flushCount);

		this.flushCount = flushCount;

		fireCommandManagerChange(new CommandManagerChangeEvent(this));
		Trace
			.trace(
				CommonCorePlugin.getDefault(),
				CommonCoreDebugOptions.COMMANDS_ADMIN,
				"Command manager flush count set to " + String.valueOf(flushCount) + "."); //$NON-NLS-1$ //$NON-NLS-2$
d377 1
a377 1
		
d391 1
a391 1
		
d413 1
a413 1
				.commandManagerChanged(event);
d418 1
a418 5
	 * Adds the specified command to the list of commands managed by this
	 * command manager.
	 * 
	 * @@param command
	 *            The command to be added.
d421 5
a425 8
		assert (getCommands().size() - 1 == getUndoIndex());

		getCommands().add(command);
		setUndoIndex(getUndoIndex() + 1);

		if (getUndoIndex() >= getFlushThreshold()) {
			flush();
		}
d435 1
a435 1
			
d437 1
a437 1
				
a438 4
				
				int redoIndex = getUndoIndex() + 1;
				ICommand firstCleared = (ICommand) getCommands().get(redoIndex);
				clearRedo(redoIndex);
d440 9
a448 1
				fireCommandManagerChange(new CommandManagerChangeEvent(this, firstCleared));
d450 2
a451 2
					CommonCoreDebugOptions.COMMANDS_ADMIN,
					"Command manager redo cleared."); //$NON-NLS-1$
d467 2
a468 12
		int index = getCommands().indexOf(command);

		if (index < 0) {
			// Could not find the command, so clear the entire redo stack to be safe
			if (canRedo()) {
				index = getUndoIndex() + 1;
			} else {
				return;
			}
		}

		clearRedo(index);
d477 1
d480 1
a480 10

		if (index <= getUndoIndex()) {
			setUndoIndex(-1);
		}

		for (ListIterator li = getCommands().listIterator(index); li.hasNext(); li
			.remove()) {
			
			li.next();
		}
d487 1
a487 4
		if (canRedo()) {
			ICommand command = (ICommand) getCommands().get(getUndoIndex() + 1);
			clearRedoCommand(command);
		}
d496 1
d505 2
a506 1
			fireCommandManagerChange(new CommandManagerChangeEvent(this, command));
d508 2
a509 2
				CommonCoreDebugOptions.COMMANDS_ADMIN,
				"Command manager redo cleared."); //$NON-NLS-1$
d520 1
a520 11
		if (canUndo()) {
			int redoIndex = getUndoIndex() + 1;

			for (ListIterator li = getCommands().listIterator(); 0 < redoIndex; li
				.remove(), redoIndex--) {

				li.next();
			}

			setUndoIndex(-1);
		}
d529 1
d533 1
a533 7
		int index = getCommands().indexOf(command);

		if (index < 0) {
			return;
		}

		flush(index + 1);
d549 2
a550 2
				CommonCoreDebugOptions.COMMANDS_ADMIN,
				"Command manager cleared."); //$NON-NLS-1$
d563 1
d573 2
d583 3
a585 1
	 * @@param count number of commands to remove from the bottom of the undo stack
d598 4
a601 2
			int numberToFlush = count;
			ICommand command = (ICommand) getCommands().get(numberToFlush - 1);
d603 3
a605 3
			for (ListIterator li = getCommands().listIterator(); 0 < count; li
				.remove(), count--) {
				li.next();
a606 5
			int newUndoIdx = getUndoIndex() - numberToFlush;
			if (newUndoIdx < -1) {
				newUndoIdx = -1;
			}
			setUndoIndex(newUndoIdx);
a607 2
			fireCommandManagerChange(new CommandManagerChangeEvent(this,
				command));
d609 2
a610 2
				CommonCoreDebugOptions.COMMANDS_ADMIN,
				"Command manager flushed up to " + command.getLabel()); //$NON-NLS-1$
d618 1
a618 4
	 * Answers whether a command can be redone.
	 * 
	 * @@return <code>true</code> is a command can be redone;
	 *         <code>false</code> otherwise.
d621 1
a621 1
		return getUndoIndex() < getCommands().size() - 1;
d625 1
a625 4
	 * Answers whether a command can be undone.
	 * 
	 * @@return <code>true</code> is a command can be undone;
	 *         <code>false</code> otherwise.
d628 1
a628 1
		return getUndoIndex() > -1;
d637 5
a641 3
		if (canRedo()) {
			return ((ICommand) getCommands().get(
				getUndoIndex() + 1)).getLabel();
a642 1

d652 5
a656 3
		if (canUndo()) {
			return ((ICommand) getCommands().get(getUndoIndex()))
				.getLabel();
a657 1

d708 1
a708 1
		assert null!=progressMonitor;
d712 1
a712 1
				"Command Manager cannot perform the nested command execution while it is already in the process of executing a command."); //$NON-NLS-1$
d714 3
d718 1
a718 1
		if (!command.isExecutable()) {
d720 1
a720 1
				"Trying to execute an unexecutable command (" + command.getLabel() + ")"); //$NON-NLS-1$ //$NON-NLS-2$
d722 2
a723 2
				CommonCoreDebugOptions.EXCEPTIONS_THROWING, getClass(),
				"execute", uoe); //$NON-NLS-1$
d728 1
a728 1
			"Executing command '" + command.getLabel() + "'..."); //$NON-NLS-1$ //$NON-NLS-2$
d736 2
a737 1
			command.execute(progressMonitor);
d742 1
a742 6
				if (command.isUndoable()) {
					// RATLC00524872 - only clear redo if the command is
					// undoable
					clearRedoCommands();
					addCommand(command);
				} else {
d744 1
a744 1
					if (!command.getAffectedObjects().isEmpty()) {
d750 6
a755 4
					command));
				
			} else if (CommonCoreStatusCodes.CANCELLED == result.getStatus().getCode()) {
				// RATLC00529649 - temporary fix - clear redo command when a command is cancelled
d759 7
d772 2
a773 2
			CommonCoreDebugOptions.COMMANDS_EXECUTE,
			"Command '" + String.valueOf(command) + "' executed."); //$NON-NLS-1$ //$NON-NLS-2$
d822 2
a823 2
				CommonCoreDebugOptions.EXCEPTIONS_THROWING, getClass(),
				"redo", uoe); //$NON-NLS-1$
d833 1
a833 1
			command = (ICommand) getCommands().get(getUndoIndex() + 1);
d835 2
a836 2
				"Redoing command '" + command.getLabel() + "'..."); //$NON-NLS-1$ //$NON-NLS-2$
			command.redo();
d838 1
d841 1
a841 4
				if (command.isUndoable()) {
					setUndoIndex(getUndoIndex() + 1);
				} else {
					clearRedoCommands();
d843 1
a843 1
					if (!command.getAffectedObjects().isEmpty()) {
d849 1
a849 1
					command));
d851 4
d861 2
a862 2
			CommonCoreDebugOptions.COMMANDS_REDO,
			"Command '" + String.valueOf(command) + "' redone."); //$NON-NLS-1$ //$NON-NLS-2$
d884 2
a885 2
				CommonCoreDebugOptions.EXCEPTIONS_THROWING, getClass(),
				"undo", uoe); //$NON-NLS-1$
d895 1
a895 1
			command = (ICommand) getCommands().get(getUndoIndex());
d897 4
a900 2
				"Undoing command '" + command.getLabel() + "'..."); //$NON-NLS-1$ //$NON-NLS-2$
			command.undo();
a903 1
				setUndoIndex(getUndoIndex() - 1);
d905 1
a905 2
				if (!command.isRedoable()) {
					clearRedoCommands();
d907 2
a908 2
					if (!command.getAffectedObjects().isEmpty()) {
						clearUndoCommands();
d913 1
a913 1
					command));
d916 5
d926 2
a927 2
			CommonCoreDebugOptions.COMMANDS_UNDO,
			"Command '" + String.valueOf(command) + "' undone."); //$NON-NLS-1$ //$NON-NLS-2$
d939 5
a943 1
		int index = getCommands().indexOf(command);
d946 2
a947 4
		if (index <= getUndoIndex()) {
			for (int i = getUndoIndex(); i >= index; i--) {
				undo();
			}
d958 5
a962 1
		int index = getCommands().indexOf(command);
d965 14
a978 4
		if (index > getUndoIndex()) {
			for (int i = getUndoIndex() + 1; i <= index; i++) {
				redo();
			}
d980 1
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d67 2
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

