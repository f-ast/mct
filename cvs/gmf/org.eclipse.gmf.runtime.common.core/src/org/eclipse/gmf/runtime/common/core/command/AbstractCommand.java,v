head	1.10;
access;
symbols
	v20081020-0700:1.10
	v20080722-1827:1.10
	R2_1_maintenance:1.10.0.2
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080425-1959:1.10
	v20080402-1725:1.9
	v20080328-1605:1.8
	v20080222-1200:1.8
	v20080215-1500:1.8
	v20080201-2010:1.8
	v20080118-1415:1.8
	v20080118-1129:1.8
	v20071108-0000:1.8
	v20070809-0000:1.8
	R2_0_maintenance:1.8.0.2
	R2_0:1.8
	R4_20:1.8
	RC3_20:1.8
	v20070601-1400:1.8
	v20070518-1300:1.8
	v20070420-1000:1.8
	v20070330-1300:1.8
	v20070221-1500:1.8
	v20070209-1900:1.6.2.3
	v20060209-1900:1.6.2.3
	v20070208-1800:1.8
	v20070119-1200:1.6.2.3
	M4_20:1.8
	v20061214-0000:1.8
	M3_20:1.8
	v20061117-0800:1.8
	v20061020-1000:1.6.2.3
	v20061013-1330:1.7
	v20060925-1700:1.6.2.2
	v20060919-0800:1.6.2.2
	v20060907-1100:1.6.2.2
	M1_20:1.6
	v20060824-1600:1.6.2.2
	v20060810-1700:1.6.2.2
	v20060803-1200:1.6.2.2
	v20060728-0500:1.6.2.2
	v20060721-1130:1.6.2.2
	v20060713-1700:1.6.2.1
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060616-1200:1.6
	v20060531-1730:1.5
	v20060526-1200:1.5
	I20060505-1400:1.5
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.4
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.4
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051124-2000:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;


1.10
date	2008.04.25.18.39.43;	author ahunter;	state Exp;
branches;
next	1.9;
commitid	270d4812256e4567;

1.9
date	2008.04.02.21.01.20;	author ahunter;	state Exp;
branches;
next	1.8;
commitid	12d047f3f41f4567;

1.8
date	2006.10.13.21.56.22;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.03.14.47.23;	author ahunter;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.12.19.21.43;	author ldamus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2006.03.27.21.12.44;	author ldamus;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.13.19.11.59;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.28.19.58.18;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.25.25;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.16;	author sshaw;	state Exp;
branches;
next	;

1.6.2.1
date	2006.07.07.20.11.40;	author ldamus;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2006.07.20.21.01.29;	author ldamus;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2006.10.13.21.33.54;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.10
log
@[228915] gmf-head ahunter 080425 Non-externalized string literal; it should be followed by //$NON-NLS-<n>
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.core.command;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.operations.AbstractOperation;
import org.eclipse.core.commands.operations.IOperationApprover;
import org.eclipse.core.commands.operations.IUndoContext;
import org.eclipse.core.commands.operations.IUndoableOperation;
import org.eclipse.core.commands.operations.OperationHistoryFactory;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Status;
import org.eclipse.gmf.runtime.common.core.internal.command.ICommandWithSettableResult;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;

/**
 * An abstract superclass for GMF {@@link IUndoableOperation}s that do not
 * modify EMF model resources.
 * <p>
 * The operation provides a list of {@@link IFile}s that are expected to be modified when
 * the operation is executed, undone or redone. An {@@link IOperationApprover} is
 * registered with the {@@link OperationHistoryFactory#getOperationHistory()} to
 * validate the modification to these resources.
 * <p>
 * This class is meant to be extended by clients.
 * 
 * @@author khussey
 * @@author ldamus
 *
 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand
 * @@canBeSeenBy %partners
 */
public abstract class AbstractCommand extends AbstractOperation
		implements ICommand, ICommandWithSettableResult {

	private final List affectedFiles;

	private CommandResult commandResult;
    
    /**
     * Initializes me with a label.
     * 
     * @@param label
     *            the operation label, should never be <code>null</code>.
     */
    public AbstractCommand(String label) {
        this(label, null);
    }

	/**
	 * Initializes me with a label and a list of {@@link IFile}s that anticipate modifying
	 * when I am executed, undone or redone.
	 * 
	 * @@param label
	 *            the operation label, should never be <code>null</code>.
	 * @@param affectedFiles
	 *            the list of affected {@@link IFile}s; may be <code>null</code>
	 */
	public AbstractCommand(String label, List affectedFiles) {
		super((label == null) ? StringStatics.BLANK : label);

		if (affectedFiles == null) {
			this.affectedFiles = new ArrayList(2);

		} else {
			this.affectedFiles = affectedFiles;
		}
	}

	/**
	 * Returns the {@@link IFile}s that may be modified when the operation is
	 * executed, undone or redone.
	 */
	public List getAffectedFiles() {
		return affectedFiles;
	}

	// Documentation copied from the interface
	public CommandResult getCommandResult() {
		return commandResult;
	}

	/**
	 * Sets the command result.
	 * 
	 * @@param result
	 *            the new result for this command.
	 */
	protected final void setResult(CommandResult result) {
		this.commandResult = result;
	}

	// Documentation copied from the interface
	public ICommand compose(IUndoableOperation operation) {

		if (operation != null) {

			return new CompositeCommand(getLabel()).compose(this)
					.compose(operation);
		}
		return this;
	}
    
	// Documentation copied from the interface
    public ICommand reduce() {
        return this;
    }

	/**
	 * Delegates to {@@link #doExecuteWithResult(IProgressMonitor, IAdaptable)} and sets
	 * the command result.
	 */
	public IStatus execute(IProgressMonitor progressMonitor, IAdaptable info)
			throws ExecutionException {
		
		IProgressMonitor monitor = progressMonitor != null ? progressMonitor
				: new NullProgressMonitor();

		CommandResult result = doExecuteWithResult(monitor, info);
		setResult(result);
		return result != null ? result.getStatus()
	            : Status.OK_STATUS;
	}

	/**
	 * Performs the actual work of executing this command. Subclasses must
	 * implement this method to perform some operation.
	 * 
	 * @@param progressMonitor
	 *            the progress monitor provided by the operation history. Must
	 *            never be <code>null</code>.
	 * @@param info
	 *            the IAdaptable (or <code>null</code>) provided by the
	 *            caller in order to supply UI information for prompting the
	 *            user if necessary. When this parameter is not
	 *            <code>null</code>, it should minimally contain an adapter
	 *            for the org.eclipse.swt.widgets.Shell.class.
	 * 
	 * @@return The result of executing this command. May be <code>null</code>
	 *         if the execution status is OK, but there is no meaningful result
	 *         to be returned.
	 * 
	 * @@throws ExecutionException
	 *             if, for some reason, I fail to complete the operation
	 */
	protected abstract CommandResult doExecuteWithResult(
			IProgressMonitor progressMonitor, IAdaptable info)
			throws ExecutionException;

	/**
	 * Delegates to {@@link #doRedoWithResult(IProgressMonitor, IAdaptable)} and sets the
	 * command result.
	 */
	public IStatus redo(IProgressMonitor progressMonitor, IAdaptable info)
			throws ExecutionException {

		IProgressMonitor monitor = progressMonitor != null ? progressMonitor
				: new NullProgressMonitor();
		
		CommandResult result = doRedoWithResult(monitor, info);
		setResult(result);
		return result != null ? result.getStatus()
	            : Status.OK_STATUS;
	}

	/**
	 * Performs the actual work of redoing this command. Subclasses must
	 * implement this method to perform the redo.
	 * 
	 * @@param progressMonitor
	 *            the progress monitor provided by the operation history. Must
	 *            never be <code>null</code>.
	 * @@param info
	 *            the IAdaptable (or <code>null</code>) provided by the
	 *            caller in order to supply UI information for prompting the
	 *            user if necessary. When this parameter is not
	 *            <code>null</code>, it should minimally contain an adapter
	 *            for the org.eclipse.swt.widgets.Shell.class.
	 * 
	 * @@return The result of redoing this command. May be <code>null</code>
	 *         if the execution status is OK, but there is no meaningful result
	 *         to be returned.
	 * 
	 * @@throws ExecutionException
	 *             on failure to redo
	 */
	protected abstract CommandResult doRedoWithResult(IProgressMonitor progressMonitor,
			IAdaptable info) throws ExecutionException;

	/**
	 * Delegates to {@@link #doUndoWithResult(IProgressMonitor, IAdaptable)} and sets the
	 * command result.
	 */
	public IStatus undo(IProgressMonitor progressMonitor, IAdaptable info)
			throws ExecutionException {
		
		IProgressMonitor monitor = progressMonitor != null ? progressMonitor
				: new NullProgressMonitor();

		CommandResult result = doUndoWithResult(monitor, info);
		setResult(result);
		return result != null ? result.getStatus()
	            : Status.OK_STATUS;
	}

	/**
	 * Performs the actual work of undoing this command. Subclasses must
	 * implement this method to perform the undo.
	 * 
	 * @@param progressMonitor
	 *            the progress monitor provided by the operation history. Must
	 *            never be <code>null</code>.
	 * @@param info
	 *            the IAdaptable (or <code>null</code>) provided by the
	 *            caller in order to supply UI information for prompting the
	 *            user if necessary. When this parameter is not
	 *            <code>null</code>, it should minimally contain an adapter
	 *            for the org.eclipse.swt.widgets.Shell.class.
	 * 
	 * @@return The result of undoing this command. May be <code>null</code>
	 *         if the execution status is OK, but there is no meaningful result
	 *         to be returned.
	 * 
	 * @@throws ExecutionException
	 *             on failure to undo
	 */
	protected abstract CommandResult doUndoWithResult(IProgressMonitor progressMonitor,
			IAdaptable info) throws ExecutionException;

    public void dispose() {
        super.dispose();
        
        // clear my contexts
        IUndoContext[] contexts = getContexts();
        for (int i = 0; i < contexts.length; i++) {
            removeContext(contexts[i]);
        }
    }
    
    /**
     * Internal method to set the command result.
     * 
     * @@param result CommandResult to set
     * @@deprecated internal API
     */
    public void internalSetResult(CommandResult result) {
        this.commandResult = result;
    }
}
@


1.9
log
@[224706] gmf-head ahunter 080402 IUndoableOperation changes in the platform cause AssertionFailedException
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d30 1
d76 1
a76 1
		super((label == null) ? "" : label);
@


1.8
log
@[160541] gmf_head ahunter 061013 Merge 1.0.2 fix to HEAD
@
text
@d59 1
a59 1
     *            the operation label
d70 1
a70 1
	 *            the operation label
d75 1
a75 1
		super(label);
@


1.7
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d29 1
d49 1
a49 1
		implements ICommand {
d254 10
@


1.6
log
@[146064] gmf_head ldamus 060612 DestroyEObjectCommand prevents deletion of elements in some resources
@
text
@d27 1
d77 1
a77 1
			this.affectedFiles = new ArrayList();
d127 1
a127 1
	public IStatus execute(IProgressMonitor monitor, IAdaptable info)
d129 3
d144 2
a145 1
	 *            the progress monitor provided by the operation history
d168 1
a168 1
	public IStatus redo(IProgressMonitor monitor, IAdaptable info)
d171 3
d185 2
a186 1
	 *            the progress monitor provided by the operation history
d208 1
a208 1
	public IStatus undo(IProgressMonitor monitor, IAdaptable info)
d210 3
d225 2
a226 1
	 *            the progress monitor provided by the operation history
@


1.6.2.1
log
@[149057] gmf_R1_0_maintenance ldamus 060707 AbstractCommand subclasses do not respect API inherited from IUndoableOperation
@
text
@a26 1
import org.eclipse.core.runtime.NullProgressMonitor;
d126 1
a126 1
	public IStatus execute(IProgressMonitor progressMonitor, IAdaptable info)
a127 3
		
		IProgressMonitor monitor = progressMonitor != null ? progressMonitor
				: new NullProgressMonitor();
d140 1
a140 2
	 *            the progress monitor provided by the operation history. Must
	 *            never be <code>null</code>.
d163 1
a163 1
	public IStatus redo(IProgressMonitor progressMonitor, IAdaptable info)
a165 3
		IProgressMonitor monitor = progressMonitor != null ? progressMonitor
				: new NullProgressMonitor();
		
d177 1
a177 2
	 *            the progress monitor provided by the operation history. Must
	 *            never be <code>null</code>.
d199 1
a199 1
	public IStatus undo(IProgressMonitor progressMonitor, IAdaptable info)
a200 3
		
		IProgressMonitor monitor = progressMonitor != null ? progressMonitor
				: new NullProgressMonitor();
d213 1
a213 2
	 *            the progress monitor provided by the operation history. Must
	 *            never be <code>null</code>.
@


1.6.2.2
log
@[144397] gmf_R1_0_maintenance ldamus 060720 AbstractCommand's affectedfiles default size of 10 when reduced to 2, reduces memory usage from 2,886,984 to 2,860,440
@
text
@d77 1
a77 1
			this.affectedFiles = new ArrayList(2);
@


1.6.2.3
log
@[160541] gmf_R1_0_maintenance wdiu 061013 When commands are executed using DefaultOperationHistory, unapproved commands will not be executed and CommandResult including IStatus will not be set
@
text
@a28 1
import org.eclipse.gmf.runtime.common.core.internal.command.ICommandWithSettableResult;
d48 1
a48 1
		implements ICommand, ICommandWithSettableResult {
a252 10
    
    /**
     * Internal method to set the command result.
     * 
     * @@param result CommandResult to set
     * @@deprecated internal API
     */
    public void internalSetResult(CommandResult result) {
        this.commandResult = result;
    }
@


1.5
log
@[112826] gmf_head ldamus 060327 Adopt Eclipse 3.1 Operation History Framework - removing deprecated API
@
text
@d27 1
d131 2
a132 1
		return result.getStatus();
d148 3
a150 1
	 * @@return The result of executing this command.
d168 2
a169 1
		return result.getStatus();
d185 3
a187 1
	 * @@return The result of redoing this command.
d204 2
a205 1
		return result.getStatus();
d221 3
a223 1
	 * @@return The result of undoing this command.
@


1.4
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@a14 1
import java.util.Collection;
a26 5
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;
import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;
a229 137
    
    //
    // TODO The following methods to be removed when deprecated API on ICommand
    // is removed. Deprecated API must be implemented to comply with deprecated
    // methods on the ICommand interface.
    // 

    /**
     * Returns the affected {@@link IFile}s.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #getAffectedFiles()} instead.
     */
    public Collection getAffectedObjects() {
        return getAffectedFiles();
    }

    /**
     * Returns <code>null</code>.
     * 
     * @@deprecated File validation is now done through a
     *             {@@link IOperationApprover} registered with with the
     *             {@@link OperationHistoryFactory#getOperationHistory()}. No
     *             need to return a validator for backwards compatilibity.
     */
    public CMValidator getValidator() {
        return null;
    }

    /**
     * Returns <code>false</code>.
     * 
     * @@deprecated File validation is now done through a
     *             {@@link IOperationApprover} registered with with the
     *             {@@link OperationHistoryFactory#getOperationHistory()}. No
     *             need to calculate the answer for backwards compatilibity.
     */
    public boolean involvesReadOnlyNonWorkSpaceFiles() {
        return false;
    }

    /**
     * Delegates to {@@link #canExecute()}.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canExecute()} instead.
     */
    public boolean isExecutable() {
        return canExecute();
    }

    /**
     * Delegates to {@@link #canRedo()}.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canRedo()} instead.
     */
    public boolean isRedoable() {
        return canRedo();
    }

    /**
     * Delegates to {@@link #canUndo()}.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #canUndo()} instead.
     */
    public boolean isUndoable() {
        return canUndo();
    }

    /**
     * Delegates to {@@link #execute(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #execute(IProgressMonitor, IAdaptable)} instead.
     */
    public void execute(IProgressMonitor progressMonitor) {

        try {
            execute(progressMonitor, null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Delegates to {@@link #redo(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #redo(IProgressMonitor, IAdaptable)} instead.
     */
    public void redo() {
        try {
            redo(new NullProgressMonitor(), null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Delegates to {@@link #undo(IProgressMonitor, IAdaptable)} and logs any
     * {@@link ExecutionException} that occurs.
     * 
     * @@deprecated Implemented for backwards compatibility. Use
     *             {@@link #undo(IProgressMonitor, IAdaptable)} instead.
     */
    public void undo() {
        try {
            undo(new NullProgressMonitor(), null);

        } catch (ExecutionException e) {
            handle(e);
        }
    }

    /**
     * Handles the specified exception by logging, tracing and setting the
     * command result to an error.
     * 
     * @@param exception
     *            The exception to be handled.
     * @@deprecated Supports deprecated implementation
     */
    protected void handle(Exception exception) {
        Trace.catching(CommonCorePlugin.getDefault(),
                CommonCoreDebugOptions.EXCEPTIONS_CATCHING, getClass(),
                "handle", exception); //$NON-NLS-1$

        setResult(CommandResult.newErrorCommandResult(exception));

        Log.log(CommonCorePlugin.getDefault(), getCommandResult().getStatus());
    }
@


1.3
log
@Bugzilla Bug 109445 gmf_head etworkow 051028 New Eclipse Resources Bundles Should Be Used
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2004 IBM Corporation and others.
d14 1
d16 1
a16 1
import java.util.Collections;
d18 8
a28 2
import org.eclipse.core.runtime.Status;

a30 2
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreStatusCodes;
import org.eclipse.gmf.runtime.common.core.internal.l10n.CommonCoreMessages;
d35 9
a43 12
 * An abstract implementation of the
 * {@@link org.eclipse.gmf.runtime.common.core.command.ICommand} interface.
 * Logging, exception handling and file edit validation are done in a uniform
 * way in the {@@link #execute(IProgressMonitor)} method.
 * <P>
 * Concrete subclasses must implement the <code>doExecute(IProgressMonitor)</code>
 * method to perform their task.
 * <P>
 * By default this command is neither redoable nor undoable. Subclasses must
 * override the {@@link #isUndoable()}and {@@link #isRedoable()} methods to allow
 * the command to be undone or redone and implement the {@@link #redo()}and
 * {@@link #undo()}methods.
d46 2
a47 1
 * 
d51 2
a52 1
public abstract class AbstractCommand implements ICommand {
d54 1
a54 4
	/**
	 * The empty string.
	 */
	protected static final String EMPTY_STRING = ""; //$NON-NLS-1$
d56 20
a75 2
	/**
	 * The label for this command.
d77 2
a78 1
	private final String label;
d80 2
a81 4
	/**
	 * The result of executing, undoing, or redoing this command.
	 */
	private CommandResult result = null;
d83 3
a85 9
	/**
	 * Creates a new command with the specified label.
	 * 
	 * @@param label The label for the new command.
	 */
	protected AbstractCommand(String label) {
		super();

		this.label = label;
d89 2
a90 1
	 * {@@inheritDoc}
d92 2
a93 2
	public String getLabel() {
		return label;
d96 3
a98 5
	/**
	 * {@@inheritDoc}
	 */
	public final CommandResult getCommandResult() {
		return result;
d102 1
a102 1
	 * Sets the <code>result</code> instance variable to the specified value.
d104 2
a105 2
	 * @@param result The new value for the <code>result</code> instance
	 *                variable.
d108 1
a108 56
		this.result = result;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#getAffectedObjects()
	 */
	public Collection getAffectedObjects() {
		return Collections.EMPTY_LIST;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#involvesReadOnlyNonWorkSpaceFiles()
	 */
	public boolean involvesReadOnlyNonWorkSpaceFiles() {
		return false;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#getValidator()
	 */
	public CMValidator getValidator() {
		return new CMValidator();
	}
	
	/**
	 * Retrieves the plug-in identifier to be used in command results produced
	 * by this command.
	 * 
	 * @@return The plug-in identifier to be used in command results produced by
	 *          this command.
	 */
	protected String getPluginId() {
		return CommonCorePlugin.getPluginId();
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#compose(org.eclipse.gmf.runtime.common.core.command.ICommand)
	 */
	public ICommand compose(ICommand command) {
		assert null != command : "null command"; //$NON-NLS-1$

		return new CompositeCommand(getLabel()).compose(this).compose(command);
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#isExecutable()
	 */
	public boolean isExecutable() {
		return true;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#isRedoable()
	 */
	public boolean isRedoable() {
		return false;
d111 2
a112 31
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#isUndoable()
	 */
	public boolean isUndoable() {
		return false;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#execute(org.eclipse.core.runtime.IProgressMonitor)
	 */
	public void execute(IProgressMonitor progressMonitor) {

		IProgressMonitor monitor =
			(progressMonitor == null)
				? new NullProgressMonitor()
				: progressMonitor;

		try {
			if (getValidator().okToEdit(this)) { 
				setResult(doExecute(monitor));
			} else {
				// We are not going to do the undo/redo.
				// We do not want the stack affected so we must return an appropriate result.
				// This way the caller will know that the undo/redo was not sucessful and will
				// not adjust the stack.
				setResult(newCancelledCommandResult());	
			}
		} catch (Exception e) {
			handle(e);
		}
	}
d114 1
a114 4
	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#redo()
	 */
	public void redo() {
d116 2
a117 13
		try {
			// First check if we have access to the units to be modified.
			if (getValidator().okToEdit(this)) {
				setResult(doRedo());
			} else {
				// We are not going to do the undo/redo.
				// We do not want the stack affected so we must return an appropriate result.
				// This way the caller will know that the undo/redo was not sucessful and will
				// not adjust the stack.
				setResult(newCancelledCommandResult());
			}
		} catch (Exception e) {
			handle(e);
d119 1
d121 5
d128 2
a129 1
	 * {@@inheritDoc}
d131 2
a132 1
	public void undo() {
d134 3
a136 14
		try {
			// First check if we have access to the units to be modified.
			if (getValidator().okToEdit(this)) {
				setResult(doUndo());
			} else {
				// We are not going to do the undo/redo.
				// We do not want the stack affected so we must return an appropriate result.
				// This way the caller will know that the undo/redo was not sucessful and will
				// not adjust the stack.
				setResult(newCancelledCommandResult());
			}
		} catch (Exception e) {
			handle(e);
		}
d140 2
a141 1
	 * Creates a new command result with an OK status.
d143 8
a150 1
	 * @@return A new command result with an OK status.
d152 4
d157 3
a159 9
	protected CommandResult newOKCommandResult() {
		return new CommandResult(
			new Status(
				IStatus.OK,
				getPluginId(),
				CommonCoreStatusCodes.OK,
				EMPTY_STRING,
				null));
	}
d162 2
a163 6
	 * Creates a new command result with an OK status and the specified return
	 * value.
	 * 
	 * @@return A new command result with an OK status.
	 * @@param returnValue The return value for the new command result.
	 * 
d165 6
a170 9
	protected CommandResult newOKCommandResult(Object returnValue) {
		return new CommandResult(
			new Status(
				IStatus.OK,
				getPluginId(),
				CommonCoreStatusCodes.OK,
				EMPTY_STRING,
				null),
			returnValue);
d172 1
a172 1
	
d174 2
a175 2
	 * Creates a new command result with an ERROR status , a CANCELLED status
	 * code and no return value.
d177 8
a184 16
	 * @@return A new command result with an ERROR status.
	 */
	protected CommandResult newCancelledCommandResult() {
		return new CommandResult(
			new Status(
				IStatus.ERROR,
				getPluginId(),
				CommonCoreStatusCodes.CANCELLED,
				CommonCoreMessages.AbstractCommand__INFO__cancelOperation,
				null),
			null);
	}
	
	/**
	 * Creates a new command result with an ERROR status, a COMMAND_FAILURE
	 * status code, and no return value.
d186 1
a186 16
	 * @@param errorMessage error message
	 * @@return A new command result with an ERROR status.
	 */
	protected CommandResult newErrorCommandResult(String errorMessage) {
		return new CommandResult(
			new Status(
				IStatus.ERROR,
				getPluginId(),
				CommonCoreStatusCodes.COMMAND_FAILURE,
				errorMessage,
				null));
	}
	
	/**
	 * Creates a new command result with an WARNING status, a OK
	 * status code, and no return value.
d188 2
a189 3
	 * @@param warningMessage the warning
	 * @@param returnValue the return value for the new command result
	 * @@return A new command result with a WARNING status.
d191 3
a193 6
	protected CommandResult newWarningCommandResult(String warningMessage,
			Object returnValue) {
		return new CommandResult(new Status(IStatus.WARNING, getPluginId(),
			CommonCoreStatusCodes.OK, warningMessage, null), returnValue);
	}
	
d195 2
a196 4
	 * Handles the specified exception.
	 * 
	 * @@param exception
	 *            The exception to be handled.
d198 2
a199 11
	protected void handle(Exception exception) {
		Trace.catching(CommonCorePlugin.getDefault(), CommonCoreDebugOptions.EXCEPTIONS_CATCHING, getClass(), "handle", exception); //$NON-NLS-1$

		setResult(
			new CommandResult(
				new Status(
					IStatus.ERROR,
					getPluginId(),
					CommonCoreStatusCodes.COMMAND_FAILURE,
					String.valueOf(exception.getMessage()),
					exception)));
d201 3
a203 1
		Log.log(CommonCorePlugin.getDefault(), getCommandResult().getStatus());
d207 2
a208 2
	 * Performs the actual work of executing this command. Subclasses must
	 * implement this method to perform some operation.
d211 12
a222 5
	 *            The object that monitors the progress of this command
	 *            execution. May be
	 *            {@@link org.eclipse.core.runtime.NullProgressMonitor}if the
	 *            command should be executed without monitoring its progress.
	 * @@return The result of executing this command.
d224 2
a225 1
	protected abstract CommandResult doExecute(IProgressMonitor progressMonitor);
d227 141
a367 13
	/**
	 * Performs the actual work of redoing this command. Subclasses must
	 * override this method if the command is to be redoable.
	 * 
	 * @@return The result of redoing this command.
	 * @@exception UnsupportedOperationException
	 *                If this command isn't redoable.
	 */
	protected CommandResult doRedo() {
		UnsupportedOperationException uoe = new UnsupportedOperationException();
		Trace.throwing(CommonCorePlugin.getDefault(), CommonCoreDebugOptions.EXCEPTIONS_THROWING, getClass(), "doRedo", uoe); //$NON-NLS-1$
		throw uoe;
	}
d369 1
a369 13
	/**
	 * Performs the actual work of undoing this command. Subclasses must
	 * override this method if the command is to be undoable.
	 * 
	 * @@return The result of undoing this command.
	 * @@exception UnsupportedOperationException
	 *                If this command isn't undoable.
	 */
	protected CommandResult doUndo() {
		UnsupportedOperationException uoe = new UnsupportedOperationException();
		Trace.throwing(CommonCorePlugin.getDefault(), CommonCoreDebugOptions.EXCEPTIONS_THROWING, getClass(), "doUndo", uoe); //$NON-NLS-1$
		throw uoe;
	}
d371 2
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d25 1
a25 1
import org.eclipse.gmf.runtime.common.core.internal.l10n.ResourceManager;
a55 5
	 * The status message for a cancelled command.
	 */
	protected static final String CANCELLED_MESSAGE = ResourceManager.getInstance().getString("AbstractCommand._INFO_.cancelOperation"); //$NON-NLS-1$
	
	/**
d276 1
a276 1
				CANCELLED_MESSAGE,
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

