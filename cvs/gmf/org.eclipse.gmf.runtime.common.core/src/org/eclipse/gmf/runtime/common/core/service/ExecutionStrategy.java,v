head	1.7;
access;
symbols
	v20081020-0700:1.7
	v20080722-1827:1.7
	R2_1_maintenance:1.7.0.4
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080425-1959:1.7
	v20080402-1725:1.7
	v20080328-1605:1.7
	v20080222-1200:1.7
	v20080215-1500:1.7
	v20080201-2010:1.7
	v20080118-1415:1.7
	v20080118-1129:1.7
	v20071108-0000:1.7
	v20070809-0000:1.7
	R2_0_maintenance:1.7.0.2
	R2_0:1.7
	R4_20:1.7
	RC3_20:1.7
	v20070601-1400:1.7
	v20070518-1300:1.7
	v20070420-1000:1.7
	v20070330-1300:1.7
	v20070221-1500:1.7
	v20070209-1900:1.6.2.3
	v20060209-1900:1.6.2.3
	v20070208-1800:1.7
	v20070119-1200:1.6.2.3
	M4_20:1.7
	v20061214-0000:1.7
	M3_20:1.7
	v20061117-0800:1.7
	v20061020-1000:1.6.2.3
	v20061013-1330:1.7
	v20060925-1700:1.6.2.3
	v20060919-0800:1.6.2.3
	v20060907-1100:1.6.2.1
	M1_20:1.6
	v20060824-1600:1.6
	v20060810-1700:1.6
	v20060803-1200:1.6
	v20060728-0500:1.6
	v20060721-1130:1.6
	v20060713-1700:1.6
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060616-1200:1.6
	v20060531-1730:1.6
	v20060526-1200:1.6
	I20060505-1400:1.5
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051124-2000:1.4
	M3_10:1.4
	I20051118-1245:1.4
	I20051111-1800:1.4
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;


1.7
date	2006.10.03.14.47.23;	author ahunter;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.23.17.07.53;	author ldamus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2005.12.13.20.32.05;	author ahunter;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.07.20.46.42;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.04.19.41.46;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.25.25;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.21;	author sshaw;	state Exp;
branches;
next	;

1.6.2.1
date	2006.09.05.21.07.48;	author ldamus;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2006.09.08.14.25.42;	author ldamus;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2006.09.13.16.41.26;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.7
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.core.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.eclipse.gmf.runtime.common.core.service.Service.ProviderDescriptor;
import org.eclipse.gmf.runtime.common.core.util.EnumeratedType;

/**
 * An enumeration of provider execution strategies.
 * <P>
 * Each service provider has a <code>ProviderPriority</code> that is declared
 * in its extension descriptor. It is the
 * {@@link org.eclipse.gmf.runtime.common.core.service.ExecutionStrategy} that
 * determines how service provider priorities are used to select a provider to
 * service each client request. For example, if the
 * {@@link org.eclipse.gmf.runtime.common.core.service.ExecutionStrategy#FIRST} 
 * is used, the provider with the highest priority will give an answer to the
 * request.
 * 
 * @@see org.eclipse.gmf.runtime.common.core.service
 * 
 * @@author khussey
 * @@canBeSeenBy %partners
 */
public abstract class ExecutionStrategy extends EnumeratedType {

	/**
	 * The list of pre-defined provider priorities.
	 */
	public static final ProviderPriority[] PRIORITIES =
		{
			ProviderPriority.HIGHEST,
			ProviderPriority.HIGH,
			ProviderPriority.MEDIUM,
			ProviderPriority.LOW,
			ProviderPriority.LOWEST };

	/**
	 * An internal unique identifier for provider execution strategies.
	 */
	private static int nextOrdinal = 0;

	/**
	 * Executes an operation on the first provider of the highest priority
	 * that provides the operation.
	 */
	public static final ExecutionStrategy FIRST =
		new ExecutionStrategy("First") { //$NON-NLS-1$
		
		private static final long serialVersionUID = 1L;

		public List execute(Service service, IOperation operation) {
			for (int i = 0; i < PRIORITIES.length; ++i) {
				List providers = service.getProviders(this, PRIORITIES[i], operation);

				if (providers.size() != 0) {
					return Collections.singletonList(operation.execute((IProvider) providers.get(0)));
				}
			}

			return Collections.EMPTY_LIST;
		}

		public List getUncachedProviders(
			Service service,
			ProviderPriority priority,
			IOperation operation) {

			List descriptors = service.getProviders(priority);
			int size = descriptors.size();

			for (int i = 0; i < size; ++i) {
				ProviderDescriptor descriptor = (ProviderDescriptor)descriptors.get(i);

				if (Service.safeProvides(descriptor, operation)) {
					return Collections.singletonList(descriptor.getProvider());
				}
			}

			return Collections.EMPTY_LIST;
		}
	};

	/**
	 * Executes an operation on the last provider of the lowest priority
	 * that provides the operation.
	 */
	public static final ExecutionStrategy LAST =
		new ExecutionStrategy("Last") { //$NON-NLS-1$

		private static final long serialVersionUID = 1L;

		public List execute(Service service, IOperation operation) {
			for (int i = PRIORITIES.length; --i >= 0;) {
				List providers = service.getProviders(this, PRIORITIES[i], operation);
				int size = providers.size();

				if (size != 0) {
					return Collections.singletonList(
						operation.execute(
							(IProvider) providers.get(size - 1)));
				}
			}

			return Collections.EMPTY_LIST;
		}

		public List getUncachedProviders(
				Service service,
				ProviderPriority priority,
				IOperation operation) {

			List descriptors = service.getProviders(priority);

			for (int i = descriptors.size(); --i >= 0;) {
				ProviderDescriptor descriptor = (ProviderDescriptor)descriptors.get(i);

				if (Service.safeProvides(descriptor, operation)) {
					return Collections.singletonList(descriptor.getProvider());
				}
			}

			return Collections.EMPTY_LIST;
		}
	};

	/**
	 * Executes an operation on all providers that provide the operation, in
	 * order from highest to lowest priority.
	 */
	public static final ExecutionStrategy FORWARD =
		new ExecutionStrategy("Forward") { //$NON-NLS-1$
		
		private static final long serialVersionUID = 1L;

		public List execute(Service service, IOperation operation) {
			List results = new ArrayList();

			for (int i = 0; i < PRIORITIES.length; ++i) {
				List providers = service.getProviders(this, PRIORITIES[i], operation);
				int size = providers.size();

				for (int j = 0; j < size; ++j) {
					results.add(operation.execute((IProvider) providers.get(j)));
				}
			}

			return results;
		}
	};

	/**
	 * Executes an operation on all providers that provide the operation, in
	 * reverse order from lowest to highest priority.
	 */
	public static final ExecutionStrategy REVERSE =
		new ExecutionStrategy("Reverse") { //$NON-NLS-1$
		
		private static final long serialVersionUID = 1L;

		public List execute(Service service, IOperation operation) {
			List results = new ArrayList();

			for (int i = PRIORITIES.length; --i >= 0;) {
				List providers = service.getProviders(this, PRIORITIES[i], operation);

				for (int j = providers.size(); --j >= 0;) {
					results.add(operation.execute((IProvider) providers.get(j)));
				}
			}

			return results;
		}
	};

	/**
	 * The list of values for this enumerated type.
	 */
	private static final ExecutionStrategy[] VALUES =
		{ FIRST, LAST, FORWARD, REVERSE };

	/**
	 * Constructs a new execution strategy with the specified name.
	 *
	 * @@param name The name of the new execution strategy.
	 */
	protected ExecutionStrategy(String name) {
		super(name, nextOrdinal++);
	}

	/**
	 * Constructs a new execution strategy with the specified name and ordinal.
	 *
	 * @@param name The name of the new execution strategy.
	 * @@param ordinal The ordinal for the new execution strategy.
	 */
	protected ExecutionStrategy(String name, int ordinal) {
		super(name, ordinal);
	}

	/**
	 * Retrieves the list of constants for this enumerated type.
	 *
	 * @@return The list of constants for this enumerated type.
	 */
	protected List getValues() {
		return Collections.unmodifiableList(Arrays.asList(VALUES));
	}

	/**
	 * Executes the specified operation on providers obtained from the
	 * specified service, according to this execution strategy.
	 *
	 * @@param service The service from which to obtain the providers.
	 * @@param operation The operation to be executed.
	 * @@return The list of results.
	 */
	public abstract List execute(Service service, IOperation operation);

	/**
	 * Retrieves a list of providers of the specified priority that provide the
	 * specified operation.
	 * 
	 * @@param service The service used by the strategy
	 * @@param priority The priority of providers to be retrieved.
	 * @@param operation The operation that the provides must provide.
	 * @@return A list of uncached providers.
	 */
	public List getUncachedProviders(
		Service service,
		ProviderPriority priority,
		IOperation operation) {

		List descriptors = service.getProviders(priority);
		int size = descriptors.size();
		List providers = new ArrayList(size);

		for (int i = 0; i < size; ++i) {
			ProviderDescriptor descriptor = (ProviderDescriptor)descriptors.get(i);

			if (Service.safeProvides(descriptor, operation)) {
				providers.add(descriptor.getProvider());
			}
		}

		return providers;
	}

	/**
	 * Retrieves a list of providers of the specified priority.
	 * 
	 * @@param service The service used by the strategy
	 * @@param priority The priority of providers to be retrieved.
	 * @@return A list of providers of the specified priority.
	 */
	protected final List getProviders(Service service, ProviderPriority priority) {
		return service.getProviders(priority); 
	}

	/**
	 * Retrieves a list of providers of the specified priority that provide the
	 * specified operation. If this service is optimized, the result will be
	 * cached the first time it is retrieved. If caching is pessimistic, the 
	 * providers from the cache will be checked first. 
	 * 
	 * @@param service The service used by the strategy
	 * @@param strategy The strategy used by the service
	 * @@param priority The priority of providers to be retrieved.
	 * @@param operation The operation that the provides must provide.
	 * @@return A list of providers (from the cache, if appropriate).
	 */
	protected final List getProviders(
		Service service,
		ExecutionStrategy strategy,
		ProviderPriority priority,
		IOperation operation) {
		return service.getProviders(strategy, priority, operation); 
	}	
}
@


1.6
log
@[118327] gmf_head ldamus 060523  Service provider and policy error log message requires more detail
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
a18 3
import org.eclipse.core.runtime.IStatus;
import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreStatusCodes;
a20 1
import org.eclipse.gmf.runtime.common.core.util.Log;
d89 1
a89 1
				if (safeProvides(descriptor, operation)) {
d132 1
a132 1
				if (safeProvides(descriptor, operation)) {
d255 1
a255 1
			if (safeProvides(descriptor, operation)) {
a291 44
	}
	
	/**
	 * Safely calls a provider's provides() method.
	 * 
	 * The provider must not be null.
	 * 
	 * Returns true if there were no exceptions thrown and the provides() method
	 * returns true.  Returns false if an exception was thrown or the provides()
	 * method returns false.
	 * 
	 * An entry is added to the log if the provider threw an exception.  
	 * 
	 * @@param provider to safely execute the provides() method
	 * @@param operation passed into the provider's provides() method
	 * @@return true if there were no exceptions thrown and the provides() method
	 * returns true.  Returns false if an exception was thrown or the provides()
	 * method returns false.
	 */
	private static boolean safeProvides(IProvider provider, IOperation operation) {
		assert provider != null;
		
		try {
			return provider.provides(operation);
		}
		catch (Exception e) {
			
			List ignoredProviders = Service.getIgnoredProviders();
			String providerClassName = provider.getClass().getName();
			
			if (!ignoredProviders.contains(providerClassName)) {
				// remember the ignored provider so that the error is only logged once per provider
				ignoredProviders.add(providerClassName);
				
				Log.log(
					CommonCorePlugin.getDefault(),
					IStatus.ERROR,
					CommonCoreStatusCodes.SERVICE_FAILURE,
					"Ignoring provider " + provider + " since it threw an exception in the provides() method",  //$NON-NLS-1$ //$NON-NLS-2$
					e);
			}
			return false;
		}
		
@


1.6.2.1
log
@[117391] gmf_R1_0_maintenance ldamus 060905 Make ExecutionStrategy even safer
@
text
@d321 1
a321 1
		catch (Throwable e) {
@


1.6.2.2
log
@[117391] gmf_R1_0_maintenance ldamus 060908 Make ExecutionStrategy even safer
@
text
@d19 3
d24 1
d93 1
a93 1
				if (Service.safeProvides(descriptor, operation)) {
d136 1
a136 1
				if (Service.safeProvides(descriptor, operation)) {
d259 1
a259 1
			if (Service.safeProvides(descriptor, operation)) {
d296 44
@


1.6.2.3
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.5
log
@[110317] gmf_head ahunter 051312 Compiler warning count should be 0 - runtime foundation layer components
@
text
@d322 15
a336 6
			Log.log(
				CommonCorePlugin.getDefault(),
				IStatus.ERROR,
				CommonCoreStatusCodes.SERVICE_FAILURE,
				"Ignoring provider " + provider + " since it threw an exception in the provides() method",  //$NON-NLS-1$ //$NON-NLS-2$
				e);
@


1.4
log
@Bugzilla Bug 114759 gmf_head wdiu 051107 Runtime should not fail on querying providers which throws an exceptions
@
text
@d67 3
d108 3
d151 3
d176 3
@


1.3
log
@Bugzilla 110485 gmf_head keithc 051004 Improve performance of Service & ExecutionStrategy
@
text
@d19 3
d24 1
d90 1
a90 1
				if (descriptor.provides(operation)) {
d130 1
a130 1
				if (descriptor.provides(operation)) {
d247 1
a247 1
			if (descriptor.provides(operation)) {
d285 35
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@a16 1
import java.util.Iterator;
a17 1
import java.util.ListIterator;
d64 2
a65 1
			List results = Collections.EMPTY_LIST;
d67 2
a68 6
			for (int i = 0; i < PRIORITIES.length; i++) {
				List targets = getProviders(service, this, PRIORITIES[i], operation);

				if (!targets.isEmpty()) {
					results = Collections.singletonList(operation.execute((IProvider) targets.get(0)));
					break;
d71 2
a72 1
			return results;
d74 1
d80 5
a84 1
			List providers = getProviders(service, priority);
a85 2
			for (ListIterator i = providers.listIterator(); i.hasNext();) {
				ProviderDescriptor descriptor = (ProviderDescriptor) i.next();
d90 1
d102 3
a104 5
			List results = Collections.EMPTY_LIST;

			for (int i = PRIORITIES.length - 1; i >= 0; i--) {
				List targets = getProviders(service, this, PRIORITIES[i], operation);
				int size = targets.size();
d107 1
a107 1
					results = Collections.singletonList(
d109 1
a109 2
							(IProvider) targets.get(size - 1)));
					break;
d112 2
a113 1
			return results;
d115 1
d121 4
a124 1
				List providers = getProviders(service, priority);
d126 2
a127 5
				for (ListIterator i = providers.listIterator(providers.size()); i.hasPrevious();) {
					ProviderDescriptor descriptor = (ProviderDescriptor) i.previous();
					if (descriptor.provides(operation)) {
						return Collections.singletonList(descriptor.getProvider());
					}
a128 1
				return Collections.EMPTY_LIST;
d130 3
d144 3
a146 2
			for (int i = 0; i < PRIORITIES.length; i++) {
				List targets = getProviders(service, this, PRIORITIES[i], operation);
d148 2
a149 2
				for (int j = 0; j < targets.size(); j++) {
					results.add(operation.execute((IProvider) targets.get(j)));
d152 1
d166 2
a167 2
			for (int i = PRIORITIES.length - 1; i >= 0; i--) {
				List targets = getProviders(service, this, PRIORITIES[i], operation);
d169 2
a170 2
				for (int j = targets.size() - 1; j >= 0; j--) {
					results.add(operation.execute((IProvider) targets.get(j)));
d173 1
d236 6
a241 1
		List targets = new ArrayList();
a242 2
		for (Iterator i = getProviders(service, priority).iterator(); i.hasNext();) {
			ProviderDescriptor descriptor = (ProviderDescriptor) i.next();
d244 1
a244 1
				targets.add(descriptor.getProvider());
d247 2
a248 1
		return targets;
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

