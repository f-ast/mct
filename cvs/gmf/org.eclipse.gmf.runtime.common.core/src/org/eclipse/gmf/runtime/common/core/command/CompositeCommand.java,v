head	1.10;
access;
symbols
	v20081020-0700:1.10
	v20080722-1827:1.10
	R2_1_maintenance:1.10.0.2
	Root_R2_1_maintenance:1.10
	R2_1_0:1.10
	v20080425-1959:1.10
	v20080402-1725:1.10
	v20080328-1605:1.10
	v20080222-1200:1.10
	v20080215-1500:1.10
	v20080201-2010:1.10
	v20080118-1415:1.9.2.1
	v20080118-1129:1.9.2.1
	v20071108-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	RC3_20:1.9
	v20070601-1400:1.9
	v20070518-1300:1.9
	v20070420-1000:1.9
	v20070330-1300:1.9
	v20070221-1500:1.9
	v20070209-1900:1.6.2.4
	v20060209-1900:1.6.2.4
	v20070208-1800:1.8
	v20070119-1200:1.6.2.3
	M4_20:1.7
	v20061214-0000:1.7
	M3_20:1.7
	v20061117-0800:1.7
	v20061020-1000:1.6.2.2
	v20061013-1330:1.7
	v20060925-1700:1.6.2.2
	v20060919-0800:1.6.2.2
	v20060907-1100:1.6.2.2
	M1_20:1.6
	v20060824-1600:1.6.2.2
	v20060810-1700:1.6.2.2
	v20060803-1200:1.6.2.2
	v20060728-0500:1.6.2.2
	v20060721-1130:1.6.2.2
	v20060713-1700:1.6.2.1
	R1_0_maintenance:1.6.0.2
	R1_0:1.6
	v20060627-1200:1.6
	v20060616-1200:1.6
	v20060531-1730:1.6
	v20060526-1200:1.6
	I20060505-1400:1.6
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051124-2000:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;


1.10
date	2008.01.16.17.48.43;	author aboyko;	state Exp;
branches;
next	1.9;
commitid	43d7478e437a4567;

1.9
date	2007.02.09.14.30.06;	author crevells;	state Exp;
branches
	1.9.2.1;
next	1.8;
commitid	65cf45cc856e4567;

1.8
date	2007.01.11.18.32.59;	author aboyko;	state Exp;
branches;
next	1.7;
commitid	7b1d45a682da4567;

1.7
date	2006.10.03.14.47.23;	author ahunter;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.11.19.59.38;	author ldamus;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2006.03.07.02.40.41;	author ldamus;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.13.19.11.59;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.28.19.58.18;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.25.25;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.16;	author sshaw;	state Exp;
branches;
next	;

1.6.2.1
date	2006.07.07.20.11.40;	author ldamus;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2006.07.20.21.04.27;	author ldamus;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2007.01.11.18.17.25;	author aboyko;	state Exp;
branches;
next	1.6.2.4;
commitid	38e045a67f344567;

1.6.2.4
date	2007.02.09.14.08.06;	author crevells;	state Exp;
branches;
next	;
commitid	40b345cc80464567;

1.9.2.1
date	2008.01.16.18.19.59;	author aboyko;	state Exp;
branches;
next	;
commitid	608a478e4acf4567;


desc
@@


1.10
log
@[215408] gmf_head aboyko 080116 Wrong command label for compartment auto-size
@
text
@/******************************************************************************
 * Copyright (c) 2006, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.core.command;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.operations.ICompositeOperation;
import org.eclipse.core.commands.operations.IUndoContext;
import org.eclipse.core.commands.operations.IUndoableOperation;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreDebugOptions;
import org.eclipse.gmf.runtime.common.core.internal.CommonCorePlugin;
import org.eclipse.gmf.runtime.common.core.internal.CommonCoreStatusCodes;
import org.eclipse.gmf.runtime.common.core.internal.l10n.CommonCoreMessages;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.Trace;

/**
 * An undoable command that is composed of child {@@link IUndoableOperation}s
 * that are not known to modify EMF model resources, but can contain
 * model-affecting children. Execute, undo, redo and dispose result in execute,
 * undo, redo and dispose on each child operation. The operation provides a list
 * of {@@link IFile}s that may be modified when the operation is executed,
 * undone or redone.
 * <P>
 * The children are explicitly composed by a client before the composite is
 * executed. Children cannot be added or removed after the composite has been
 * executed.
 * <P>
 * The undo contexts of the composite are a union of the undo contexts of its
 * children.
 * <P>
 * If a child command returns a cancel or an error status during execution, undo
 * or redo, the remaining child commands are not processed and those that have
 * already been executed are rolled back.
 * 
 * @@author ldamus
 */
public class CompositeCommand
    extends AbstractCommand
    implements ICompositeCommand {

    private final List children;

    private boolean executed;

    /**
     * Initializes me with a label.
     * 
     * @@param label
     *            a user-readable label
     */
    public CompositeCommand(String label) {
        this(label, null);
    }

    /**
     * Initializes me with a label and a list of child operations.
     * 
     * @@param label
     *            a user-readable label
     * @@param children
     *            a list of child {@@link IUndoableOperation}s
     */
    public CompositeCommand(String label, List children) {
        super(label, null);

        if (children != null) {
            this.children = new ArrayList(children);
        } else {
            this.children = new ArrayList(4);
        }
    }

    /**
     * Answers whether or not this composite operation has children.
     * 
     * @@return <code>true</code> if the operation does not have children,
     *         <code>false</code> otherwise.
     */
    public final boolean isEmpty() {
        return size() < 1;
    }

    /**
     * Obtains my nested operations. Note that the return result is mutable and
     * is identical to my child-operation storage, so subclasses should be
     * careful of adding or removing contents. This should ordinarily be done
     * only via the {@@link #add(IUndoableOperation)} and
     * {@@link #remove(IUndoableOperation)} methods because these maintain the
     * undo contexts (or, equivalently, using the iterators).
     * 
     * @@return my list of children
     * 
     * @@see #add(IUndoableOperation)
     * @@see #remove(IUndoableOperation)
     * @@see #iterator()
     * @@see #listIterator(int)
     */
    protected List getChildren() {
        return children;
    }

    // Documentation copied from interface
    public int size() {
        return getChildren().size();
    }

    /**
     * Adds a child operation to me. This should only be done before I am
     * executed. Has no effect if I already contain this operation as a child.
     * 
     * @@param operation
     *            a new child operation
     * 
     * @@throws IllegalStateException
     *             if I have already been successfully executed
     */
    public void add(IUndoableOperation operation) {

        assertNotExecuted();

        if (!getChildren().contains(operation)) {
            getChildren().add(operation);
            didAdd(operation);
        }
    }

    /**
     * Updates my undo contexts for the addition of a new child operation.
     * 
     * @@param operation
     *            a new child operation
     */
    private void didAdd(IUndoableOperation operation) {
        IUndoContext[] childContexts = operation.getContexts();

        for (int i = 0; i < childContexts.length; i++) {

            if (!hasContext(childContexts[i])) {
                addContext(childContexts[i]);
            }
        }
    }

    /**
     * Removes a child operation from me. This should only be done before I am
     * executed. Has no effect if I do not contain this operation as a child.
     * <p>
     * <b>Note</b> that I do not dispose an operation when it is removed from
     * me. Although this is specified in the contract of the
     * {@@link ICompositeOperation} interface, this would not be correct, as I
     * did not create that operation.
     * </p>
     * 
     * @@param operation
     *            a child operation to remove
     * 
     * @@throws IllegalStateException
     *             if I have already been successfully executed
     */
    public void remove(IUndoableOperation operation) {

        assertNotExecuted();

        if (getChildren().remove(operation)) {
            didRemove(operation);
        }
    }

    /**
     * Updates my undo contexts for the removal of a child operation.
     * 
     * @@param operation
     *            the child operation that was removed
     */
    private void didRemove(IUndoableOperation operation) {
        IUndoContext[] childContexts = operation.getContexts();

        for (int i = 0; i < childContexts.length; i++) {

            if (!anyChildHasContext(childContexts[i])) {
                removeContext(childContexts[i]);
            }
        }
    }

    /**
     * Queries whether any of my children has the specified context.
     * 
     * @@param ctx
     *            a context
     * 
     * @@return <code>false</code> if none of my children has the specified
     *         context; <code>true</code>, otherwise
     */
    private boolean anyChildHasContext(IUndoContext ctx) {
        boolean result = false;

        for (Iterator iter = iterator(); !result && iter.hasNext();) {
            result = ((IUndoableOperation) iter.next()).hasContext(ctx);
        }

        return result;
    }

    /**
     * I can execute if I am not empty and all of my children can execute.
     */
    public boolean canExecute() {
        boolean result = !isEmpty() && super.canExecute();

        for (Iterator iter = iterator(); result && iter.hasNext();) {
            result = ((IUndoableOperation) iter.next()).canExecute();
        }

        return result;
    }

    /**
     * I can redo if I am not empty and all my children can all be redone.
     */
    public boolean canRedo() {
        boolean result = !isEmpty() && super.canRedo();

        for (Iterator iter = iterator(); result && iter.hasNext();) {
            result = ((IUndoableOperation) iter.next()).canRedo();
        }

        return result;
    }

    /**
     * I can undo if I am not empty and all my children can all be undone.
     */
    public boolean canUndo() {
        boolean result = !isEmpty() && super.canUndo();

        for (Iterator iter = iterator(); result && iter.hasNext();) {
            result = ((IUndoableOperation) iter.next()).canUndo();
        }

        return result;
    }

    /**
     * Disposes of each of my children.
     */
    public void dispose() {

        for (Iterator iter = iterator(); iter.hasNext();) {
            IUndoableOperation nextOperation = (IUndoableOperation) iter.next();
            nextOperation.dispose();
        }
    }

    /**
     * Adds <code>command</code> to the list of commands with which this
     * composite is composed.
     * 
     * @@param operation
     *            The command with which to compose this command.
     * @@return <code>this</code>.
     */
    public final ICommand compose(IUndoableOperation operation) {

        if (operation != null) {
            add(operation);
        }
        return this;
    }
    
	/**
	 * Appends a command onto a (possibly) existing composeite of commands.
	 * 
	 * @@param command an existing command, which may be a composite, a single
	 *     command, or <code>null</code>
	 * @@param next a command to append to the composite (may also be
	 *     <code>null</code>, which produces no effect)
	 * 
	 * @@return the new composite, which is just <code>next</code> if
	 *     <code>command</code> was <code>null</code>
	 */
	public static ICommand compose(ICommand command, ICommand next) {
		if (command == null) {
			return next;
		} else if (next != null) {
			return command.compose(next);
		} else {
			return command;
		}
	}

    /**
	 * Returns the simplest form of this command that is equivalent. This is
	 * useful for removing unnecessary nesting of commands.
	 * <P>
	 * If the composite has a single command, it returns the reduction of that
	 * single command. Otherwise, it returns itself.
	 * 
	 * @@return the simplest form of this command that is equivalent
	 */
	public ICommand reduce() {
		switch (size()) {
		case 1:
			IUndoableOperation child = (IUndoableOperation) iterator().next();

			if (child instanceof ICommand) {
				ICommand cmd = ((ICommand) child).reduce();
				/*
				 * Propagate the label of the original command to the reduced.
				 */
				if (getLabel() != null && getLabel().length() > 0) {
					cmd.setLabel(getLabel());
				}
				return cmd;
			}
		}
		return this;
	}

    /**
	 * Returns a list containing all of the return values from
	 * <code>ICommand</code> children.
	 */
    protected List getReturnValues() {

        List returnValues = new ArrayList();

        for (Iterator i = iterator(); i.hasNext();) {
            IUndoableOperation operation = (IUndoableOperation) i.next();

            if (operation instanceof ICommand) {
                ICommand command = (ICommand) operation;

                CommandResult result = command.getCommandResult();

                if (result != null) {
                    Object returnValue = result.getReturnValue();

                    if (returnValue != null) {

                        if (getClass().isInstance(command)) {
                            // unwrap the values from other composites
                            if (returnValue != null
                                && returnValue instanceof Collection) {
                                returnValues.addAll((Collection) returnValue);

                            } else {
                                returnValues.add(returnValue);
                            }

                        } else {
                            returnValues.add(returnValue);
                        }
                    }
                }
            }
        }

        return returnValues;
    }

    /**
     * Implements the execution logic by sequential execution of my children.
     */
    protected CommandResult doExecuteWithResult(
            IProgressMonitor progressMonitor, IAdaptable info)
        throws ExecutionException {

        List result = new ArrayList(size());

        progressMonitor.beginTask(getLabel(), size());

        try {

            for (ListIterator iter = listIterator(); iter.hasNext();) {
                IUndoableOperation next = (IUndoableOperation) iter.next();

                try {
                    IStatus status = next.execute(new SubProgressMonitor(
                        progressMonitor, 1), info);
                    result.add(status);
                    int severity = status.getSeverity();

                    if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {

                        // Undo the operation to date, excluding the current
                        // child, and don't proceed
                        Trace
                            .trace(
                                CommonCorePlugin.getDefault(),
                                "Composite operation execution recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
                        // back-track over the operation that failed
                        iter.previous();
                        unwindFailedExecute(iter, info);
                        break;

                    } else if (progressMonitor.isCanceled()) {
                        // Undo the operation to date, including the current
                        // child, and don't proceed
                        Trace
                            .trace(CommonCorePlugin.getDefault(),
                                "Composite operation redo recovery: child command monitor is cancelled."); //$NON-NLS-1$

                        CommandResult cancelResult = CommandResult
                            .newCancelledCommandResult();
                        result.add(cancelResult.getStatus());

                        unwindFailedExecute(iter, info);
                        break;

                    } else {
                        progressMonitor.worked(1);
                        executed = true;
                    }

                } catch (ExecutionException e) {
                    // Undo the operation to date, and re-throw the exception
                    // back-track over the operation that failed
                    iter.previous();
                    unwindFailedExecute(iter, info);
                    Trace.throwing(CommonCorePlugin.getDefault(),
                        CommonCoreDebugOptions.EXCEPTIONS_THROWING,
                        CompositeCommand.class, "execute", e); //$NON-NLS-1$
                    throw e;
                }
            }

        } finally {
            progressMonitor.done();
        }

        return new CommandResult(aggregateStatuses(result), getReturnValues());
    }

    /**
     * Undoes the previous operations in the iterator.
     * 
     * @@param iter
     *            the execution iterator
     * @@param info
     *            the execution info
     */
    private void unwindFailedExecute(ListIterator iter, IAdaptable info) {

        while (iter.hasPrevious()) {
            // unwind the child operations
            IUndoableOperation prev = (IUndoableOperation) iter.previous();
            if (!prev.canUndo()) {
                // Can't unwind
                Log.error(CommonCorePlugin.getDefault(),
                    CommonCoreStatusCodes.EXECUTE_RECOVERY_FAILED,
                    CommonCoreMessages.bind(
                        CommonCoreMessages.executeRecoveryFailed,
                        CommonCoreMessages.cannotUndoExecuted));
                break;
            }

            try {
                prev.undo(new NullProgressMonitor(), info);

            } catch (ExecutionException inner) {
                Log.error(CommonCorePlugin.getDefault(),
                    CommonCoreStatusCodes.EXECUTE_RECOVERY_FAILED,
                    CommonCoreMessages.bind(
                        CommonCoreMessages.executeRecoveryFailed, inner
                            .getLocalizedMessage()));
                break;
            }
        }
    }

    /**
     * I redo by asking my children to redo, in forward order.
     */
    protected CommandResult doRedoWithResult(IProgressMonitor progressMonitor,
            IAdaptable info)
        throws ExecutionException {

        final List result = new ArrayList(size());

        progressMonitor.beginTask(getLabel(), size());

        try {

            for (ListIterator iter = listIterator(); iter.hasNext();) {
                IUndoableOperation next = (IUndoableOperation) iter.next();

                try {

                    IStatus status = next.redo(new SubProgressMonitor(
                        progressMonitor, 1), info);
                    result.add(status);
                    int severity = status.getSeverity();

                    if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
                        // Undo the operation to date, excluding the current
                        // child, and don't proceed
                        Trace
                            .trace(CommonCorePlugin.getDefault(),
                                "Composite operation redo recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
                        // back-track over the operation that failed
                        iter.previous();
                        unwindFailedRedo(iter, info);
                        break;

                    } else if (progressMonitor.isCanceled()) {
                        // Undo the operation to date, including the current
                        // child, and don't proceed
                        Trace
                            .trace(CommonCorePlugin.getDefault(),
                                "Composite operation redo recovery: child command monitor is cancelled."); //$NON-NLS-1$

                        CommandResult cancelResult = CommandResult
                            .newCancelledCommandResult();
                        result.add(cancelResult.getStatus());

                        unwindFailedRedo(iter, info);
                        break;

                    } else {
                        progressMonitor.worked(1);
                        executed = true;
                    }

                } catch (ExecutionException e) {
                    // Undo the operation to date, and re-throw the exception
                    // back-track over the operation that failed
                    iter.previous();
                    unwindFailedRedo(iter, info);
                    Trace.throwing(CommonCorePlugin.getDefault(),
                        CommonCoreDebugOptions.EXCEPTIONS_THROWING,
                        CompositeCommand.class, "redo", e); //$NON-NLS-1$
                    throw e;
                }
            }

        } finally {
            progressMonitor.done();
        }

        return new CommandResult(aggregateStatuses(result), getReturnValues());
    }

    /**
     * Undoes the previous operations in the iterator.
     * 
     * @@param iter
     *            the execution iterator
     * @@param info
     *            the execution info
     */
    private void unwindFailedRedo(ListIterator iter, IAdaptable info) {

        while (iter.hasPrevious()) {
            // unwind the child operations
            IUndoableOperation prev = (IUndoableOperation) iter.previous();
            if (!prev.canUndo()) {
                // Can't unwind
                Log.error(CommonCorePlugin.getDefault(),
                    CommonCoreStatusCodes.REDO_RECOVERY_FAILED,
                    CommonCoreMessages.bind(
                        CommonCoreMessages.redoRecoveryFailed,
                        CommonCoreMessages.cannotUndo));
                break;
            }

            try {
                prev.undo(new NullProgressMonitor(), info);

            } catch (ExecutionException inner) {
                Log.error(CommonCorePlugin.getDefault(),
                    CommonCoreStatusCodes.REDO_RECOVERY_FAILED,
                    CommonCoreMessages.bind(
                        CommonCoreMessages.redoRecoveryFailed, inner
                            .getLocalizedMessage()));
                break;
            }
        }
    }

    /**
     * I undo by asking my children to undo, in reverse order.
     */
    protected CommandResult doUndoWithResult(IProgressMonitor progressMonitor,
            IAdaptable info)
        throws ExecutionException {

        final List result = new ArrayList(size());

        progressMonitor.beginTask(getLabel(), size());

        try {

            for (ListIterator iter = listIterator(size()); iter.hasPrevious();) {
                IUndoableOperation prev = (IUndoableOperation) iter.previous();

                try {
                    IStatus status = prev.undo(new SubProgressMonitor(
                        progressMonitor, 1), info);
                    result.add(status);
                    int severity = status.getSeverity();

                    if (severity == IStatus.CANCEL || severity == IStatus.ERROR) {
                        // Redo the operation to date, excluding the current
                        // child, and don't proceed
                        Trace
                            .trace(CommonCorePlugin.getDefault(),
                                "Composite operation undo recovery: child command status is CANCEL or ERROR."); //$NON-NLS-1$
                        // back-track over the operation that failed or was
                        // cancelled
                        iter.next();
                        unwindFailedUndo(iter, info);
                        break;

                    } else if (progressMonitor.isCanceled()) {
                        // Redo the operation to date, including the current
                        // child, and don't proceed
                        Trace
                            .trace(CommonCorePlugin.getDefault(),
                                "Composite operation undo recovery: child command monitor is cancelled."); //$NON-NLS-1$

                        CommandResult cancelResult = CommandResult
                            .newCancelledCommandResult();
                        result.add(cancelResult.getStatus());

                        unwindFailedUndo(iter, info);
                        break;

                    } else {
                        progressMonitor.worked(1);
                        executed = true;
                    }

                } catch (ExecutionException e) {
                    // Redo the operation to date, and re-throw the exception
                    // back-track over the operation that failed
                    iter.next();
                    unwindFailedUndo(iter, info);
                    Trace.throwing(CommonCorePlugin.getDefault(),
                        CommonCoreDebugOptions.EXCEPTIONS_THROWING,
                        CompositeCommand.class, "undo", e); //$NON-NLS-1$
                    throw e;
                }
            }

        } finally {
            progressMonitor.done();
        }

        return new CommandResult(aggregateStatuses(result), getReturnValues());
    }

    /**
     * Redoes the next operations in the iterator.
     * 
     * @@param iter
     *            the execution iterator
     * @@param info
     *            the execution info
     */
    private void unwindFailedUndo(ListIterator iter, IAdaptable info) {

        while (iter.hasNext()) {
            // unwind the child operations
            IUndoableOperation next = (IUndoableOperation) iter.next();
            if (!next.canRedo()) {
                // Can't unwind
                Log.error(CommonCorePlugin.getDefault(),
                    CommonCoreStatusCodes.UNDO_RECOVERY_FAILED,
                    CommonCoreMessages.bind(
                        CommonCoreMessages.undoRecoveryFailed,
                        CommonCoreMessages.cannotRedo));
                break;
            }

            try {
                next.redo(new NullProgressMonitor(), info);

            } catch (ExecutionException inner) {
                Log.error(CommonCorePlugin.getDefault(),
                    CommonCoreStatusCodes.UNDO_RECOVERY_FAILED,
                    CommonCoreMessages.bind(
                        CommonCoreMessages.undoRecoveryFailed, inner
                            .getLocalizedMessage()));
                break;
            }
        }
    }

    /**
     * Creates a suitable aggregate from these statuses. If there are no
     * statuses to aggregate, then an OK status is returned. If there is a
     * single status to aggregate, then it is returned. Otherwise, a
     * multi-status is returned with the provided statuses as children.
     * 
     * @@param statuses
     *            the statuses to aggregate. May have zero, one, or more
     *            elements (all must be {@@link IStatus}es)
     * 
     * @@return the multi-status
     */
    protected IStatus aggregateStatuses(List statuses) {
        final IStatus result;

        if (statuses.isEmpty()) {
            result = Status.OK_STATUS;
        } else if (statuses.size() == 1) {
            result = ((IStatus) statuses.get(0));
        } else {
            // find the most severe status, to use its plug-in, code, and
            // message
            IStatus[] statusArray = (IStatus[]) statuses
                .toArray(new IStatus[statuses.size()]);

            IStatus worst = statusArray[0];
            for (int i = 1; i < statusArray.length; i++) {
                if (statusArray[i].getSeverity() > worst.getSeverity()) {
                    worst = statusArray[i];
                }
            }

            result = new MultiStatus(worst.getPlugin(), worst.getCode(),
                statusArray, worst.getMessage(), null);
        }

        return result;
    }

    /**
     * Answers whether or not I have been executed.
     * 
     * @@return <code>true</code> if I have been executed, <code>false</code>
     *         otherwise.
     */
    protected final boolean isExecuted() {
        return executed;
    }

    /**
     * Asserts that I have not yet been executed. Changes to my children are not
     * permitted after I have been executed.
     */
    protected final void assertNotExecuted() {
        if (isExecuted()) {
            IllegalStateException exc = new IllegalStateException(
                "Operation already executed"); //$NON-NLS-1$
            Trace.throwing(CommonCorePlugin.getDefault(),
                CommonCoreDebugOptions.EXCEPTIONS_THROWING,
                CompositeCommand.class, "assertNotExecuted", exc); //$NON-NLS-1$
            throw exc;
        }
    }

    /**
     * Returns a list containing all of the affected files from
     * <code>ICommand</code> children.
     */
    public List getAffectedFiles() {

        HashSet result = new HashSet();

        for (Iterator i = iterator(); i.hasNext();) {
            IUndoableOperation nextOperation = (IUndoableOperation) i.next();

            if (nextOperation instanceof ICommand) {
                List nextAffected = ((ICommand) nextOperation)
                    .getAffectedFiles();

                if (nextAffected != null) {
                    result.addAll(nextAffected);
                }
            }
        }
        return new ArrayList(result);
    }

    /**
     * Obtains an iterator to traverse my child operations. Removing children
     * via this iterator correctly maintains my undo contexts.
     * 
     * @@return an iterator of my children
     */
    public Iterator iterator() {
        return new ChildIterator();
    }

    /**
     * Obtains an iterator to traverse my child operations in either direction.
     * Adding and removing children via this iterator correctly maintains my
     * undo contexts.
     * <p>
     * <b>Note</b> that, unlike list iterators generally, this implementation
     * does not permit the addition of an operation that I already contain (the
     * composite does not permit duplicates). Moreover, only
     * {@@link IUndoableOperation}s may be added, otherwise
     * <code>ClassCastException</code>s will result.
     * </p>
     * 
     * @@return an iterator of my children
     */
    public ListIterator listIterator() {
        return new ChildListIterator(0);
    }

    /**
     * Obtains an iterator to traverse my child operations in either direction,
     * starting from the specified <code>index</code>. Adding and removing
     * children via this iterator correctly maintains my undo contexts.
     * <p>
     * <b>Note</b> that, unlike list iterators generally, this implementation
     * does not permit the addition of an operation that I already contain (the
     * composite does not permit duplicates). Moreover, only
     * {@@link IUndoableOperation}s may be added, otherwise
     * <code>ClassCastException</code>s will result.
     * </p>
     * 
     * @@param index
     *            the index in my children at which to start iterating
     * 
     * @@return an iterator of my children
     */
    public ListIterator listIterator(int index) {
        return new ChildListIterator(index);
    }

    /**
     * Custom iterator implementation that maintains my undo contexts correctly
     * when elements are removed.
     * 
     * @@author ldamus
     */
    private class ChildIterator
        implements Iterator {

        protected Object last;

        protected final ListIterator iter;

        ChildIterator() {
            this(0);
        }

        ChildIterator(int index) {
            iter = getChildren().listIterator(index);
        }

        public void remove() {
            assertNotExecuted();

            iter.remove();
            didRemove((IUndoableOperation) last);
            last = null;
        }

        public Object next() {
            last = iter.next();
            return last;
        }

        public boolean hasNext() {
            return iter.hasNext();
        }
    }

    /**
     * Custom list-iterator implementation that maintains my undo contexts
     * correctly, as well as uniqueness of the list contents.
     * 
     * @@author ldamus
     */
    private class ChildListIterator
        extends ChildIterator
        implements ListIterator {

        ChildListIterator(int index) {
            super(index);
        }

        public void add(Object o) {
            assertNotExecuted();

            if (!getChildren().contains(o)) {
                iter.add(o);
                didAdd((IUndoableOperation) o);
            }
        }

        public void set(Object o) {
            assertNotExecuted();

            if (!getChildren().contains(o)) {
                didRemove((IUndoableOperation) last);
                iter.set(o);
                last = o;
                didAdd((IUndoableOperation) o);
            }
        }

        public int previousIndex() {
            return iter.previousIndex();
        }

        public int nextIndex() {
            return iter.nextIndex();
        }

        public Object previous() {
            last = iter.previous();
            return last;
        }

        public boolean hasPrevious() {
            return iter.hasPrevious();
        }
    }
}
@


1.9
log
@[163131] gmf_head crevells 070208 Duplicate affected files in composite commands
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
d333 1
a333 3
				 * If label is missing on the resultant reduced command
				 * and it is present on this command, then just copy the label
				 * from this command to the resultant.
d335 1
a335 2
				if ((cmd.getLabel() == null || cmd.getLabel().length() == 0)
						&& getLabel() != null && getLabel().length() > 0) {
@


1.9.2.1
log
@[215408] gmf_R2_0_maintenance 080116 Wrong command label for compartment auto-size
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2008 IBM Corporation and others.
d333 3
a335 1
				 * Propagate the label of the original command to the reduced.
d337 2
a338 1
				if (getLabel() != null && getLabel().length() > 0) {
@


1.8
log
@[170224] gmf_head aboyko 070111 CompositeCommand#reduce() should propogate command label
@
text
@d16 1
d787 1
a787 1
        List result = new ArrayList();
d801 1
a801 1
        return result;
@


1.7
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2006 IBM Corporation and others.
d316 29
a344 20
     * Returns the simplest form of this command that is equivalent. This is
     * useful for removing unnecessary nesting of commands.
     * <P>
     * If the composite has a single command, it returns the reduction of that
     * single command. Otherwise, it returns itself.
     * 
     * @@return the simplest form of this command that is equivalent
     */
    public ICommand reduce() {
        switch (size()) {
            case 1:
                IUndoableOperation child = (IUndoableOperation) iterator()
                    .next();

                if (child instanceof ICommand) {
                    return ((ICommand) child).reduce();
                }
        }
        return this;
    }
d347 3
a349 3
     * Returns a list containing all of the return values from
     * <code>ICommand</code> children.
     */
@


1.6
log
@[133091] gmf_head ldamus 060411 canExecute() on CompositeCommand should return false if contains no children
@
text
@d92 1
a92 1
            this.children = new ArrayList();
a387 4
        if (progressMonitor == null) {
            progressMonitor = new NullProgressMonitor();
        }

a497 4
        if (progressMonitor == null) {
            progressMonitor = new NullProgressMonitor();
        }

a606 4
        if (progressMonitor == null) {
            progressMonitor = new NullProgressMonitor();
        }

@


1.6.2.1
log
@[149057] gmf_R1_0_maintenance ldamus 060707 AbstractCommand subclasses do not respect API inherited from IUndoableOperation
@
text
@d388 4
d502 4
d615 4
@


1.6.2.2
log
@[144420] gmf_R1_0_maintenance ldamus 060720 CompositeCommand children list shouldn't use default size of 10
@
text
@d92 1
a92 1
            this.children = new ArrayList(4);
@


1.6.2.3
log
@[170224] gmf_R1_maintenance aboyko 070111 CompositeCommand#reduce() should propogate command label
@
text
@d2 1
a2 1
 * Copyright (c) 2006, 2007 IBM Corporation and others.
d316 20
a335 33
	 * Returns the simplest form of this command that is equivalent. This is
	 * useful for removing unnecessary nesting of commands.
	 * <P>
	 * If the composite has a single command, it returns the reduction of that
	 * single command. Otherwise, it returns itself.
	 * 
	 * @@return the simplest form of this command that is equivalent
	 */
	public ICommand reduce() {
		switch (size()) {
		case 1:
			IUndoableOperation child = (IUndoableOperation) iterator().next();

			if (child instanceof ICommand) {
				ICommand cmd = ((ICommand) child).reduce();
				/*
				 * TODO: If label is missing on the resultant reduced command
				 * and it is present on this command, then just copy the label
				 * from this command to the resultant. Currently there is no
				 * setLabel method on the ICommand, hence, as workaround, we add
				 * resultant command to this command and return this command.
				 */
				if ((cmd.getLabel() == null || cmd.getLabel().length() == 0)
						&& getLabel() != null && getLabel().length() > 0) {
					children.clear();
					add(cmd);
				} else {
					return cmd;
				}
			}
		}
		return this;
	}
d338 3
a340 3
	 * Returns a list containing all of the return values from
	 * <code>ICommand</code> children.
	 */
@


1.6.2.4
log
@[163131] gmf_R1_0_maintenance crevells 070208 Duplicate affected files in composite commands
@
text
@a15 1
import java.util.HashSet;
d790 1
a790 1
        HashSet result = new HashSet();
d804 1
a804 1
        return new ArrayList(result);
@


1.5
log
@[129773] gmf_head cdamus 060306 EMFCoreUtil.destroy() cannot destroy non-contained dependents
@
text
@d229 1
a229 1
     * I can execute if all of my children can execute.
d232 1
a232 1
        boolean result = super.canExecute();
d242 1
a242 1
     * I can redo if all my children can all be redone.
d245 1
a245 1
        boolean result = super.canRedo();
d255 1
a255 1
     * I can undo if all my children can all be undone.
d258 1
a258 1
        boolean result = super.canUndo();
@


1.4
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d293 21
@


1.3
log
@Bugzilla Bug 109445 gmf_head etworkow 051028 New Eclipse Resources Bundles Should Be Used
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2004 IBM Corporation and others.
a15 1
import java.util.Collections;
d18 1
d20 6
d32 1
a32 1

d36 2
d40 10
a49 3
 * A command that is composed of other
 * {@@link org.eclipse.gmf.runtime.common.core.command.ICommand}s which can be
 * undone and redone in a single step.
d51 2
a52 3
 * A <code>CompositeCommand</code> can only be executed, undone or redone if
 * all of the {@@link org.eclipse.gmf.runtime.common.core.command.ICommand}s
 * with which it is composed are executable, undoable or redoable, respectively.
d54 3
a56 3
 * When a <code>CompositeCommand</code> is executed, its commands are not
 * executed independently of one another. This means that if one command
 * execution fails, the remaining commands will not be executed.
d58 1
a58 2
 * @@author khussey
 * @@canBeSeenBy %partners
d61 4
a64 1
	implements ICommand {
d66 1
a66 477
	/**
	 * The empty string.
	 */
	protected static final String EMPTY_STRING = ""; //$NON-NLS-1$

	/**
	 * The commands of which this composite command is composed.
	 */
	private final List commands = new ArrayList();

	/**
	 * The label for this composite command.
	 */
	private final String label;

	/**
	 * Flag to indicate whether or not this command was canceled in its last
	 * execution.
	 */
	private boolean canceled = false;

	/**
	 * Creates a new composite command with the specified label.
	 * 
	 * @@param label
	 *            The label for the new composite command.
	 */
	public CompositeCommand(String label) {
		super();

		this.label = label;
	}

	/**
	 * Creates a new composite command with the specified label and list of
	 * commands.
	 * 
	 * @@param label
	 *            The label for the new composite command.
	 * @@param commands
	 *            The initial list of commands
	 */
	public CompositeCommand(String label, List commands) {
		super();

		this.label = label;

		assert null != commands : "null commands"; //$NON-NLS-1$

		for (Iterator i = commands.iterator(); i.hasNext();) {
			ICommand command = (ICommand) i.next();
			compose(command);
		}
	}

	/**
	 * Retrieves the commands with which this command has been composed.
	 * 
	 * @@return The commands with which this command has been composed.
	 */
	public final List getCommands() {
		return commands;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#getLabel()
	 */
	public final String getLabel() {
		if (label == null)
			if (getCommands().isEmpty())
				return null;
		if (label != null)
			return label;
		return ((ICommand) getCommands().get(0)).getLabel();
	}

	/**
	 * Retrieves the composite result of executing, undoing, or redoing this
	 * composite command.
	 * 
	 * @@return A command result composed of the results of
	 *         executing, undoing or redoing the commands of which this composite
	 *         command is composed.
	 */
	public CommandResult getCommandResult() {

		if (isCanceled()) {
			return newCancelledCommandResult();
		}

		List statuses = new ArrayList();
		List returnValues = new ArrayList();

		int severity = IStatus.OK;

		String plugin = CommonCorePlugin.getPluginId();
		int code = CommonCoreStatusCodes.OK;
		String message = EMPTY_STRING;
		Throwable exception = null;

		for (Iterator i = getCommands().iterator(); i.hasNext();) {
			ICommand command = (ICommand) i.next();

			CommandResult result = command.getCommandResult();

			if (result == null) {
				// the result can be null if only some of the commands have been
				// executed (e.g., the action was abandoned)
				break;
			}

			IStatus status = result.getStatus();
			statuses.add(result.getStatus());

			if (severity < status.getSeverity()) {
				severity = status.getSeverity();
				plugin = status.getPlugin();
				code = status.getCode();
				message = status.getMessage();
				exception = status.getException();
			}

			Object returnValue = result.getReturnValue();
			if (returnValue != null) {
				if (getClass().isInstance(command)) {
					if (returnValue != null && returnValue instanceof Collection) {
						returnValues.addAll((Collection) returnValue);
					} else {
						returnValues.add(returnValue);
					}
				} else {
					returnValues.add(returnValue);
				}
			}
		}

		return new CommandResult(
			new MultiStatus(plugin, code, (IStatus[]) statuses
				.toArray(new IStatus[] {}), message, exception), returnValues);
	}

	/**
	 * Retrieves the collection of objects that would be affected if this
	 * composite command were executed, undone, or redone.
	 * 
	 * @@return A collection containing the affected objects of all of the
	 *         commands of which this composite command is composed.
	 */
	public final Collection getAffectedObjects() {
		List affectedObjects = new ArrayList();

		for (Iterator i = getCommands().iterator(); i.hasNext();) {

			Collection coll = ((ICommand) i.next()).getAffectedObjects();
			if (coll != null) {
				affectedObjects.addAll(coll);
			}
		}

		return affectedObjects;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.core.command.ICommand#involvesReadOnlyNonWorkSpaceFiles()
	 */
	public boolean involvesReadOnlyNonWorkSpaceFiles() {
		for (Iterator i = getCommands().iterator(); i.hasNext();) {
			if (((ICommand) i.next()).involvesReadOnlyNonWorkSpaceFiles())
				return true;
		}
		return false;
	}

	/**
	 * Adds <code>command</code> to the list of commands with which this
	 * composite is composed.
	 * 
	 * @@param command
	 *            The command with which to compose this command.
	 * @@return <code>this</code>.
	 */
	public final ICommand compose(ICommand command) {
		if (command != null)
			getCommands().add(command);
		return this;
	}

	/**
	 * Answers whether this composite command can
	 * be executed.
	 * 
	 * @@return <code>false</code> if any of the commands of which this
	 *         composite command is composed cannot be executed;
	 *         <code>true</code> otherwise.
	 */
	public final boolean isExecutable() {
		if (getCommands().isEmpty())
			return false;
		for (Iterator i = getCommands().iterator(); i.hasNext();) {

			if (!((ICommand) i.next()).isExecutable()) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Answers whether this composite command can
	 * be redone.
	 * 
	 * @@return <code>false</code> if any of the commands of which this
	 *         composite command is composed cannot be redone; <code>true</code>
	 *         otherwise.
	 */
	public final boolean isRedoable() {
		if (getCommands().isEmpty())
			return false;
		for (Iterator i = getCommands().iterator(); i.hasNext();) {

			if (!((ICommand) i.next()).isRedoable()) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Answers whether this composite command can
	 * be undone.
	 * 
	 * @@return <code>false</code> if any of the commands of which this
	 *         composite command is composed cannot be undone; <code>true</code>
	 *         otherwise.
	 */
	public final boolean isUndoable() {
		if (getCommands().isEmpty())
			return false;
		for (Iterator i = getCommands().iterator(); i.hasNext();) {

			if (!((ICommand) i.next()).isUndoable()) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Returns whether the composite command has no child commands.
	 * 
	 * @@return whether the composite command has no child commands.
	 */
	public final boolean isEmpty() {
		return getCommands().size() == 0;
	}

	/**
	 * Returns the simplest form of this command that is equivalent. This is
	 * useful for removing unnecessary nesting of commands.
	 * <UL>
	 * <LI>if the composite had no sub-commands, it returns <code>null</code>
	 * </LI>
	 * <LI>if the composite had a single command, it returns the single command
	 * </LI>
	 * <LI>otherwise, it returns itself</LI>
	 * </UL>
	 * 
	 * @@return the simplest form of this command that is equivalent
	 */
	public ICommand unwrap() {
		switch (commands.size()) {
			case 0:
				return UnexecutableCommand.INSTANCE;
			case 1:
				return (ICommand) commands.get(0);
			default:
				return this;
		}
	}

	/**
	 * Executes this composite command by executing all of the commands with
	 * which it is composed. If one command execution fails, the remaining
	 * commands will not be executed.
	 * <P>
	 * The result of executing this command can be obtained by calling
	 * {@@link #getCommandResult()}after the command has been executed.
	 * <P>
	 * The progress of this command execution is measured in the following way:
	 * each of <code>n</code> subcommands is allocated 1 of <code>n</code>
	 * work units from <code>progressMonitor</code>. Each sub-command
	 * execution is given a {@@link SubProgressMonitor}and can futher divide its
	 * 1/<code>n</code> th into <code>m</code> work units. Command
	 * execution will stop when the progress monitor is cancelled and a
	 * {@@link CommonCoreStatusCodes#CANCELLED}status code will be returned in
	 * the command result. All of the previously executed sub-commands will be
	 * undone as a result of cancelling.
	 * 
	 * @@param progressMonitor @@see org.eclipse.core.runtime.IProgressMonitor
	 */
	public void execute(IProgressMonitor progressMonitor) {

		if (!getValidator().okToEdit(this)) {
			setCanceled(true);

		} else {

			IProgressMonitor monitor = (progressMonitor == null) ? new NullProgressMonitor()
				: progressMonitor;

			setCanceled(false);
			List executedCommands = new ArrayList(getCommands().size());

			int totalWork = getCommands().size();
			monitor.beginTask(getLabel(), totalWork);

			for (Iterator i = getCommands().iterator(); i.hasNext();) {

				SubProgressMonitor subprogressMonitor = new SubProgressMonitor(
					monitor, 1, SubProgressMonitor.SUPPRESS_SUBTASK_LABEL);

				ICommand nextCommand = (ICommand) i.next();
				nextCommand.execute(subprogressMonitor);

				CommandResult result = nextCommand.getCommandResult();
				if (result != null) {
					if (result.getStatus().getSeverity() == IStatus.ERROR) {
						/*
						 * myee - RATLC00518953: error executing one of the
						 * composed commands: cancel all of the executed
						 * commands
						 */
						undoCancelledCommands(executedCommands);
						return;
					}
				}
				monitor.worked(1);

				if (monitor.isCanceled()) {
					undoCancelledCommands(executedCommands);
					monitor.done();
					setCanceled(true);
					return;
				}
				executedCommands.add(nextCommand);
			}

			monitor.done();

		}
	}

	/**
	 * Cancels the command execution by calling <code>undo()</code> on all of
	 * the undoable commands that were executed before the composite command was
	 * cancelled. The commands are undone in the reverse order of execution.
	 * 
	 * @@param executedCommands
	 *            the commands that have been executed and need to be undone.
	 *            This method expects that the commands in the list are in the
	 *            order in which the commands were executed. They will be undone
	 *            in the reverse order.
	 */
	protected void undoCancelledCommands(List executedCommands) {

		Collections.reverse(executedCommands);

		for (Iterator i = executedCommands.iterator(); i.hasNext();) {
			ICommand nextCommand = (ICommand) i.next();
			if (nextCommand.isUndoable()) {
				nextCommand.undo();
			}
		}
	}

	/**
	 * Redoes this composite command by redoing each of the commands of which
	 * this composite command is composed.
	 */
	public void redo() {
		// First check if we have the needed units available.
		// We are forced to do this at the composite command level
		// because some individual commands do not properly set their
		// affectedObject. For example, create a class and notice that
		// the SetBounds command will not have its affected object set
		// even though it clearly modifies a unit.
		if (!getValidator().okToEdit(this)) {
			setCanceled(true);
			return;
		}

		Collections.reverse(getCommands());

		for (Iterator i = getCommands().iterator(); i.hasNext();) {
			((ICommand) i.next()).redo();
		}
	}

	/**
	 * Undoes this composite command by undoing each of the commands of which
	 * this composite command is composed.
	 */
	public void undo() {
		// First check if we have the needed units available.
		// We are forced to do this at the composite command level
		// because some individual commands do not properly set their
		// affectedObject. For example, create a class and notice that
		// the SetBounds command will not have its affected object set
		// even though it clearly modifies a unit.
		if (!getValidator().okToEdit(this)) {
			setCanceled(true);
			return;
		}

		Collections.reverse(getCommands());

		for (Iterator i = getCommands().iterator(); i.hasNext();) {
			((ICommand) i.next()).undo();
		}
	}

	/**
	 * Retrieves the plug-in identifier to be used in command results produced
	 * by this command.
	 * 
	 * @@return The plug-in identifier to be used in command results produced by
	 *         this command.
	 */
	protected String getPluginId() {
		return CommonCorePlugin.getPluginId();
	}

	/**
	 * Creates a new command result with an ERROR status, a CANCELLED status
	 * code and no return value.
	 * 
	 * @@return A new command result with an ERROR status and a CANCELLED status
	 *         code.
	 */
	protected CommandResult newCancelledCommandResult() {
		return new CommandResult(new Status(IStatus.ERROR, getPluginId(),
			CommonCoreStatusCodes.CANCELLED, CommonCoreMessages.AbstractCommand__INFO__cancelOperation, null), null);
	}

	/**
	 * Sets the canceled state of this command.
	 * 
	 * @@param canceled
	 *            <code>true</code> if the command was canceled,
	 *            <code>false</code> otherwise.
	 */
	protected void setCanceled(boolean canceled) {
		this.canceled = canceled;
	}

	/**
	 * Gets the canceled state of this command.
	 * 
	 * @@return <code>true</code> if the command was canceled,
	 *         <code>false</code> otherwise.
	 */
	protected boolean isCanceled() {
		return canceled;
	}

	/**
	 * Return a validator which can be used to check whether the units being
	 * modified by a command are writable.
	 * 
	 * @@return CMValidator
	 */
	public CMValidator getValidator() {
		return new CMValidator();
	}
d68 857
a924 1
}@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d29 1
a29 1
import org.eclipse.gmf.runtime.common.core.internal.l10n.ResourceManager;
a55 6
	 * The status message for a cancelled command.
	 */
	protected static final String CANCELLED_MESSAGE = ResourceManager
		.getInstance().getString("AbstractCommand._INFO_.cancelOperation"); //$NON-NLS-1$

	/**
d494 1
a494 1
			CommonCoreStatusCodes.CANCELLED, CANCELLED_MESSAGE, null), null);
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2004.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

