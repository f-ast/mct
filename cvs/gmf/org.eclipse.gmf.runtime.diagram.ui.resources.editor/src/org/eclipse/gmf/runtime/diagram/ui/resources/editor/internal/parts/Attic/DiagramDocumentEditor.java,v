head	1.13;
access;
symbols
	R1_0_maintenance:1.13.0.2
	R1_0:1.13
	I20060428-1300:1.12
	I20060424-0500:1.12
	I20060424-0300:1.12
	M6_10:1.12
	I20060407-1200:1.11
	I20060331-1000:1.11
	I20060324-0300:1.11
	I20060317-1300:1.11
	I20060317-1200:1.11
	I20060316-1300:1.11
	I20060309-1300:1.11
	M5_10:1.11
	S20060303-1600:1.11
	I20060227-1730:1.9
	I20060216-1945:1.9
	I20060210-1715:1.8
	I20060209-1815:1.8
	I20060203-0830:1.8
	I20060129-1145:1.8
	I20060127-0900:1.8
	I20060120-1530:1.8
	I20060113-1700:1.8
	M4_10:1.8
	I20060107-1100:1.8
	I20060105-1630:1.8
	I20051230-1230:1.8
	I20051223-1100:1.8
	I20051217-0925:1.8
	I20051201-1800:1.7
	I20051124-2000:1.6
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.5
	I20051106-0900:1.5
	v20051030:1.4;
locks; strict;
comment	@# @;


1.13
date	2006.05.03.14.46.09;	author ldamus;	state dead;
branches;
next	1.12;

1.12
date	2006.04.10.20.33.44;	author ldamus;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.01.22.49.05;	author cmahoney;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.28.02.31.07;	author cmahoney;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.13.19.10.53;	author ldamus;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.13.21.58.52;	author sshaw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.25.19.37.53;	author cmahoney;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.21.16.55.54;	author sshaw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.02.23.30.36;	author sshaw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.12.21.26.19;	author sshaw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.06.18.41.56;	author sshaw;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.30.18.48.55;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.18.54;	author sshaw;	state Exp;
branches;
next	;


desc
@@


1.13
log
@[136110] gmf_head ldamus 060503 Remove deprecated DiagramDocumentEditor  and CreateViewRequestFactory
@
text
@/******************************************************************************
 * Copyright (c) 2005, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.parts;



/**
 * A Diagram Editor with optional flyout palette.
 * 
 * @@author mgoyal
 * @@deprecated This class had been made public. Use
 *             {@@link org.eclipse.gmf.runtime.diagram.ui.resources.editor.parts.DiagramDocumentEditor}
 *             instead.
 */
public class DiagramDocumentEditor
	extends org.eclipse.gmf.runtime.diagram.ui.resources.editor.parts.DiagramDocumentEditor {
	
	/**
	 * @@deprecated This class had been made public. Use
	 *             {@@link org.eclipse.gmf.runtime.diagram.ui.resources.editor.parts.DiagramDocumentEditor}
	 *             instead.
	 */
	public DiagramDocumentEditor(boolean hasFlyoutPalette) {
		super(hasFlyoutPalette);
	}
}
@


1.12
log
@[135584] gmf_head ldamus 060410 Classes and methods required by clients should be made public
@
text
@@


1.11
log
@Bugzilla#129803 gmf_head cmahoney 060301 Deleting node leaves connection connected to space
@
text
@a13 64
import java.lang.reflect.InvocationTargetException;

import org.eclipse.core.commands.operations.IOperationHistory;
import org.eclipse.core.commands.operations.OperationHistoryFactory;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.ILog;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.GraphicalViewer;
import org.eclipse.gmf.runtime.common.ui.action.ActionManager;
import org.eclipse.gmf.runtime.diagram.core.DiagramEditingDomainFactory;
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramUIMessages;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditDomain;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditorWithFlyOutPalette;
import org.eclipse.gmf.runtime.diagram.ui.properties.views.PropertiesBrowserPage;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DocumentProviderRegistry;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocumentProvider;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocumentEditor;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocumentProvider;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IElementStateListener;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.MEditingDomainElement;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DocumentProviderRegistry.IDocumentProviderSelector;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.EditorPlugin;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.l10n.EditorMessages;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.palette.EditorInputPaletteContent;
import org.eclipse.gmf.runtime.notation.Diagram;
import org.eclipse.jface.action.IStatusLineManager;
import org.eclipse.jface.dialogs.ErrorDialog;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.swt.custom.BusyIndicator;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorActionBarContributor;
import org.eclipse.ui.IEditorDescriptor;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IEditorRegistry;
import org.eclipse.ui.IEditorSite;
import org.eclipse.ui.IPartListener;
import org.eclipse.ui.IPartService;
import org.eclipse.ui.IReusableEditor;
import org.eclipse.ui.IWindowListener;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchPartSite;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.part.EditorActionBarContributor;
import org.eclipse.ui.views.properties.IPropertySheetPage;
import org.osgi.framework.Bundle;
d20 3
a22 1
 *
d25 1
a25 1
	extends DiagramEditorWithFlyOutPalette implements IDocumentEditor, IReusableEditor {
d28 3
a30 3
	 * Constructs a diagram editor with optional flyout palette.
	 * 
	 * @@param hasFlyoutPalette creates a palette if true, else no palette
a34 1362

	/* (non-Javadoc)
	 * @@see org.eclipse.core.runtime.IAdaptable#getAdapter(java.lang.Class)
	 */
	public Object getAdapter(Class type) {
		if (type == IPropertySheetPage.class) {
			return new PropertiesBrowserPage(this);
		}
		return super.getAdapter(type);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.ui.IEditorPart#init(org.eclipse.ui.IEditorSite,
	 *      org.eclipse.ui.IEditorInput)
	 */
	public void init(final IEditorSite site, final IEditorInput input)
		throws PartInitException {
		super.init(site, input);

		IRunnableWithProgress runnable= new IRunnableWithProgress() {
			public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
				getDocumentProvider().setProgressMonitor(monitor);
			}
		};

		try {
//			When using the progress service always a modal dialog pops up. The site should be asked for a runnable context
//			which could be the workbench window or the progress service, depending on what the site represents.
//			getSite().getWorkbenchWindow().getWorkbench().getProgressService().run(false, true, runnable);

			getSite().getWorkbenchWindow().run(false, true, runnable);

		} catch (InterruptedException x) {
			// ignore
		} catch (InvocationTargetException x) {
			Throwable t= x.getTargetException();
			if (t instanceof CoreException) {
                /*
                /* XXX: Remove unpacking of CoreException once the following bug is
                 *		fixed: https://bugs.eclipse.org/bugs/show_bug.cgi?id=81640
                 */
                CoreException e= (CoreException)t;
                IStatus status= e.getStatus();
                if (status.getException() != null)
                    throw new PartInitException(status);
               	throw new PartInitException(new Status(status.getSeverity(), status.getPlugin(), status.getCode(), status.getMessage(), t));
            }
			throw new PartInitException(new Status(IStatus.ERROR, EditorPlugin.getPluginId(), IStatus.OK, EditorMessages.Editor_error_init, t));
		}
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.ui.part.WorkbenchPart#setSite(org.eclipse.ui.IWorkbenchPartSite)
	 */
	protected final void setSite(IWorkbenchPartSite site) {
		super.setSite(site);
		fActivationListener= new ActivationListener(site.getWorkbenchWindow().getPartService());
		fActivationListener.activate();
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.ui.IWorkbenchPart#dispose()
	 */
	public void dispose() {
		if (fActivationListener != null) {
			fActivationListener.deactivate();
			fActivationListener.dispose();
			fActivationListener= null;
		}

		if (fTitleImage != null) {
			fTitleImage.dispose();
			fTitleImage= null;
		}

		disposeDocumentProvider();
		super.setInput(null);
		
		super.dispose();
	}
	

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.parts.IDiagramWorkbenchPart#getDiagram()
	 */
	public Diagram getDiagram() {
		if (getDocumentProvider() != null) {
			IDiagramDocument document = ((IDiagramDocument) getDocumentProvider()
				.getDocument(getEditorInput()));
			if (document != null)
				return document.getDiagram();
		}
		return null;
	}
	
	public IDiagramDocument getDiagramDocument() {
		return (IDiagramDocument)getDocumentProvider().getDocument(getEditorInput());
	}

	// Save Overwrite Dialog (Yes/No) true for OK and false for otherwise
	public boolean askUserSaveOverwrite() {
		String title = DiagramUIMessages.DiagramEditor_save_outofsync_dialog_title;
		String msg = DiagramUIMessages.DiagramEditor_save_outofsync_dialog_message;
		Shell shell = getSite().getShell();
		return MessageDialog.openQuestion(shell, title, msg);
	}
	
	// Save/Close Dialog
	// 0 -- Save, 1 -- Close, -1 -- Cancel
	public int askUserSaveClose() {
		String title = DiagramUIMessages.DiagramEditor_handleDeleteEvent_dialog_title;
		String message = DiagramUIMessages.DiagramEditor_handleDeleteEvent_dialog_message;
		String[] buttons = { DiagramUIMessages.DiagramEditor_handleDeleteEvent_dialog_button_save,
			DiagramUIMessages.DiagramEditor_handleDeleteEvent_dialog_button_close};
		MessageDialog dialog =
			new MessageDialog(
				getSite().getShell(),
				title,
				null,
				message,
				MessageDialog.QUESTION,
				buttons,
				0);
		return dialog.open();
	}
	
	// Refresh Contents Dialog (Yes/No) true for OK and false for otherwise
	public boolean askUserReload() {
		String title = DiagramUIMessages.DiagramEditor_activated_outofsync_dialog_title;
		String msg = DiagramUIMessages.DiagramEditor_activated_outofsync_dialog_message;
		Shell shell = getSite().getShell();
		return MessageDialog.openQuestion(shell, title, msg);
	}
	
	/**
	 * @@see org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditor#configureDiagramEditDomain()
	 */
	protected void configureDiagramEditDomain() {
		super.configureDiagramEditDomain();
		DiagramEditDomain editDomain =
			(DiagramEditDomain) getDiagramEditDomain();
		editDomain.setActionManager(createActionManager());
	}
	
	/**
	 * @@overridable
	 */
	protected ActionManager createActionManager() {
		return new ActionManager(createOperationHistory());
	}
    
    /**
     * Create my operation history.
     * 
     * @@return my operation history
     */
    protected IOperationHistory createOperationHistory() {
        return OperationHistoryFactory.getOperationHistory();
    }

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditorWithFlyOutPalette#getDefaultPaletteContent()
	 */
	protected Object getDefaultPaletteContent() {
		EditorInputPaletteContent defPaletteContent = null;
		if(getDiagram() != null) {
			defPaletteContent = new EditorInputPaletteContent(getEditorInput(), getDiagramDocument());
		}
		return defPaletteContent;
	}

	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
		super.selectionChanged(part, selection);
//		updateStatusLine();
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.editor.IDiagramEditor#getDocumentProvider()
	 */
	public IDocumentProvider getDocumentProvider() {
		return fExplicitDocumentProvider;
	}

	/**
	 * Sets this editor's document provider. This method must be
	 * called before the editor's control is created.
	 *
	 * @@param provider the document provider
	 */
	protected void setDocumentProvider(IDocumentProvider provider) {
		assert provider != null;
		fExplicitDocumentProvider= provider;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.diagramdocument.IDiagramEditor#isEditable()
	 */
	public boolean isEditable() {
		IDocumentProvider provider= getDocumentProvider();
		return provider.isModifiable(getEditorInput());
	}

	/**
	 * Hook method for setting the document provider for the given input.
	 * This default implementation does nothing. Clients may
	 * reimplement.
	 *
	 * @@param input the input of this editor.
	 * @@since 3.0
	 */
	protected void setDocumentProvider(IEditorInput input) {
		IDocumentProvider provider = DocumentProviderRegistry.getDefault().getDocumentProvider(input, new IDocumentProviderSelector() {
			public boolean select(String documentType) {
				// Only checking of the interface name
				return documentType.equals(IDiagramDocument.class.getName());
			}
		});
		setDocumentProvider(provider);
	}

	/**
	 * Hook method for setting the document provider for the given input.
	 * This default implementation does nothing. Clients may
	 * reimplement.
	 *
	 * @@param input the input of this editor.
	 * @@since 3.0
	 */
	protected IDocumentProvider getDocumentProvider(IEditorInput input) {
		IDocumentProvider provider = DocumentProviderRegistry.getDefault().getDocumentProvider(input, new IDocumentProviderSelector() {
			public boolean select(String documentType) {
				// Only checking of the interface name
				return documentType.equals(IDiagramDocument.class.getName());
			}
		});
		return provider;
	}

	/**
	 * If there is no explicit document provider set, the implicit one is
	 * re-initialized based on the given editor input.
	 *
	 * @@param input the editor input.
	 */
	private void updateDocumentProvider(IEditorInput input) {

		IProgressMonitor rememberedProgressMonitor= null;

		IDocumentProvider provider= getDocumentProvider();
		if (provider != null) {
			provider.removeElementStateListener(fElementStateListener);
			rememberedProgressMonitor= provider.getProgressMonitor();
			provider.setProgressMonitor(null);
		}

		setDocumentProvider(input);

		provider= getDocumentProvider();
		if (provider != null) {
			provider.addElementStateListener(fElementStateListener);
			provider.setProgressMonitor(rememberedProgressMonitor);
		}
	}

	/**
	 * refreshes the editor with the given file by: 0 - resets resource
	 * modification stamp 1- Flushing the command stack 2- Clearing the
	 * graphical viewer's contents 3- Setting the new File input 4- Setting the
	 * new graphical viewer's contents 5- Clearing the graphical viewer's
	 * selection
	 * 
	 * @@param file
	 *            The new file editor input
	 */
	protected void releaseInput() {
		getCommandStack().flush();
		clearGraphicalViewerContents();
	}
	
	/* (non-Javadoc)
	 * @@see org.eclipse.ui.part.EditorPart#setInput(org.eclipse.ui.IEditorInput)
	 */
	public void setInput(IEditorInput input) {

		try {
			doSetInput(input, true);
		} catch (CoreException x) {
			String title= EditorMessages.Editor_error_setinput_title;
			String msg= EditorMessages.Editor_error_setinput_message;
			Shell shell= getSite().getShell();
			ErrorDialog.openError(shell, title, msg, x.getStatus());
		}
	}
	/*
	 * @@see EditorPart#setInput(org.eclipse.ui.IEditorInput)
	 */
	public void doSetInput(IEditorInput input, boolean releaseEditorContents) throws CoreException {
		if (input == null)

			close(isSaveOnCloseNeeded());

		else {

			IEditorInput oldInput= getEditorInput();
			if (oldInput != null) {
				getDocumentProvider().disconnect(oldInput);
				if(releaseEditorContents)
					releaseInput();
			}
			
			updateDocumentProvider(input);

			IDocumentProvider provider= getDocumentProvider();
			if (provider == null || !(provider instanceof IDiagramDocumentProvider)) {
				IStatus s= new Status(IStatus.ERROR, EditorPlugin.getPluginId(), IStatus.OK, EditorMessages.Editor_error_no_provider, null);
				throw new CoreException(s);
			}

			if (!(input instanceof MEditingDomainElement)) {
				input = ((IDiagramDocumentProvider)provider).createInputWithEditingDomain(input, createEditingDomain());
			}

			provider.connect(input);

			try {
				super.setInput(input);
			} catch(Throwable e) {
				if(getDiagram() == null) {
					IStatus status = provider.getStatus(input);
					if(status != null)
						throw new CoreException(status);
					else {
						IStatus s= new Status(IStatus.ERROR, EditorPlugin.getPluginId(), IStatus.OK, EditorMessages.Editor_error_init, null);
						throw new CoreException(s);
					}
				}
			}

			initializeTitle(input);
			
			if(oldInput != null && releaseEditorContents)
				initializeGraphicalViewerContents();
		}
		/*
		 * The following bugs explain why we fire this property change:
		 * 	https://bugs.eclipse.org/bugs/show_bug.cgi?id=90283
		 * 	https://bugs.eclipse.org/bugs/show_bug.cgi?id=92049
		 * 	https://bugs.eclipse.org/bugs/show_bug.cgi?id=92286
		 */
		firePropertyChange(IEditorPart.PROP_INPUT);
	}

	public void close(final boolean save) {

		enableSanityChecking(false);

		Display display= getSite().getShell().getDisplay();
		display.asyncExec(new Runnable() {
			public void run() {
				if (getGraphicalViewer() != null)
					getSite().getPage().closeEditor(DiagramDocumentEditor.this, save);
			}
		});
	}

	/**
	 * Disposes of the connection with the document provider. Subclasses
	 * may extend.
	 *
	 * @@since 3.0
	 */
	protected void disposeDocumentProvider() {
		IDocumentProvider provider= getDocumentProvider();
		if (provider != null) {

			IEditorInput input= getEditorInput();
			if (input != null)
				provider.disconnect(input);

			if (fElementStateListener != null) {
				provider.removeElementStateListener(fElementStateListener);
				fElementStateListener= null;
			}

			fExplicitDocumentProvider= null;
		}
	}

	/**
	 * Returns the progress monitor related to this editor. It should not be
	 * necessary to extend this method.
	 *
	 * @@return the progress monitor related to this editor
	 * @@since 2.1
	 */
	protected IProgressMonitor getProgressMonitor() {

		IProgressMonitor pm= null;
		IStatusLineManager manager= getStatusLineManager();
		if (manager != null)
			pm= manager.getProgressMonitor();

		return pm != null ? pm : new NullProgressMonitor();
	}

	/**
	 * Handles an external change of the editor's input element. Subclasses may
	 * extend.
	 */
	protected void handleEditorInputChanged() {

		String title;
		String msg;
		Shell shell= getSite().getShell();

		final IDocumentProvider provider= getDocumentProvider();
		if (provider == null) {
			// fix for http://dev.eclipse.org/bugs/show_bug.cgi?id=15066
			close(false);
			return;
		}

		final IEditorInput input= getEditorInput();
		if (provider.isDeleted(input)) {

			if (isSaveAsAllowed()) {

				title= EditorMessages.Editor_error_activated_deleted_save_title;
				msg= EditorMessages.Editor_error_activated_deleted_save_message;

				String[] buttons= {
					EditorMessages.Editor_error_activated_deleted_save_button_save,
					EditorMessages.Editor_error_activated_deleted_save_button_close,
				};

				MessageDialog dialog= new MessageDialog(shell, title, null, msg, MessageDialog.QUESTION, buttons, 0);

				if (dialog.open() == 0) {
					IProgressMonitor pm= getProgressMonitor();
					performSaveAs(pm);
					if (pm.isCanceled())
						handleEditorInputChanged();
				} else {
					close(false);
				}

			} else {

				title= EditorMessages.Editor_error_activated_deleted_close_title;
				msg= EditorMessages.Editor_error_activated_deleted_close_message;
				if (MessageDialog.openConfirm(shell, title, msg))
					close(false);
			}

		} else {

			title= EditorMessages.Editor_error_activated_outofsync_title;
			msg= EditorMessages.Editor_error_activated_outofsync_message;

			if (MessageDialog.openQuestion(shell, title, msg)) {


				try {
					provider.synchronize(input);
//					if (provider instanceof IDocumentProviderExtension) {
//						IDocumentProviderExtension extension= (IDocumentProviderExtension) provider;
//						extension.synchronize(input);
//					} else {
//						setInput(input);
//					}
				} catch (CoreException x) {
					IStatus status= x.getStatus();
					if (status == null || status.getSeverity() != IStatus.CANCEL) {
						title= EditorMessages.Editor_error_refresh_outofsync_title;
						msg= EditorMessages.Editor_error_refresh_outofsync_message;
						ErrorDialog.openError(shell, title, msg, x.getStatus());
					}
				}
			}
		}
	}

	/**
	 * The <code>AbstractDiagramEditor</code> implementation of this
	 * <code>IEditorPart</code> method calls <code>performSaveAs</code>.
	 * Subclasses may reimplement.
	 */
	public void doSaveAs() {
		/*
		 * 1GEUSSR: ITPUI:ALL - User should never loose changes made in the editors.
		 * Changed Behavior to make sure that if called inside a regular save (because
		 * of deletion of input element) there is a way to report back to the caller.
		 */
		performSaveAs(getProgressMonitor());
	}

	/**
	 * Performs a save as and reports the result state back to the
	 * given progress monitor. This default implementation does nothing.
	 * Subclasses may reimplement.
	 *
	 * @@param progressMonitor the progress monitor for communicating result state or <code>null</code>
	 */
	protected void performSaveAs(IProgressMonitor progressMonitor) {
		// for subclasses
	}

	/**
	 * The <code>AbstractDiagramEditor</code> implementation of this
	 * <code>IEditorPart</code> method may be extended by subclasses.
	 *
	 * @@param progressMonitor the progress monitor for communicating result state or <code>null</code>
	 */
	public void doSave(IProgressMonitor progressMonitor) {

		IDocumentProvider p= getDocumentProvider();
		if (p == null)
			return;

		if (p.isDeleted(getEditorInput())) {

			if (isSaveAsAllowed()) {

				/*
				 * 1GEUSSR: ITPUI:ALL - User should never loose changes made in the editors.
				 * Changed Behavior to make sure that if called inside a regular save (because
				 * of deletion of input element) there is a way to report back to the caller.
				 */
				performSaveAs(progressMonitor);

			} else {

				Shell shell= getSite().getShell();
				String title= EditorMessages.Editor_error_save_deleted_title;
				String msg= EditorMessages.Editor_error_save_deleted_message;
				MessageDialog.openError(shell, title, msg);
			}

		} else {
			updateState(getEditorInput());
			validateState(getEditorInput());
			performSave(false, progressMonitor);
		}
	}

	/**
	 * Enables/disables sanity checking.
	 * @@param enable <code>true</code> if sanity checking should be enabled, <code>false</code> otherwise
	 * @@since 2.0
	 */
	protected void enableSanityChecking(boolean enable) {
		synchronized (this) {
			fIsSanityCheckEnabled= enable;
		}
	}

	/**
	 * Checks the state of the given editor input if sanity checking is enabled.
	 * @@param input the editor input whose state is to be checked
	 * @@since 2.0
	 */
	protected void safelySanityCheckState(IEditorInput input) {
		boolean enabled= false;

		synchronized (this) {
			enabled= fIsSanityCheckEnabled;
		}

		if (enabled)
			sanityCheckState(input);
	}

	/**
	 * Checks the state of the given editor input.
	 * @@param input the editor input whose state is to be checked
	 * @@since 2.0
	 */
	protected void sanityCheckState(IEditorInput input) {

		IDocumentProvider p= getDocumentProvider();
		if (p == null)
			return;

		long stamp= p.getModificationStamp(input);
		if (stamp != fModificationStamp) {
			fModificationStamp= stamp;
			if (!p.isSynchronized(input))
				handleEditorInputChanged();
		}
		updateState(getEditorInput());
	}

	/**
	 * Enables/disables state validation.
	 * @@param enable <code>true</code> if state validation should be enabled, <code>false</code> otherwise
	 * @@since 2.1
	 */
	protected void enableStateValidation(boolean enable) {
		synchronized (this) {
			fIsStateValidationEnabled= enable;
		}
	}

	/**
	 * Validates the state of the given editor input. The predominate intent
	 * of this method is to take any action probably necessary to ensure that
	 * the input can persistently be changed.
	 *
	 * @@param input the input to be validated
	 * @@since 2.0
	 */
	protected void validateState(IEditorInput input) {

		IDocumentProvider provider= getDocumentProvider();

		try {

			provider.validateState(input, getSite().getShell());

		} catch (CoreException x) {
			IStatus status= x.getStatus();
			if (status == null || status.getSeverity() != IStatus.CANCEL) {
				Bundle bundle= Platform.getBundle(PlatformUI.PLUGIN_ID);
				ILog log= Platform.getLog(bundle);
				log.log(x.getStatus());

				Shell shell= getSite().getShell();
				String title= EditorMessages.Editor_error_validateEdit_title;
				String msg= EditorMessages.Editor_error_validateEdit_message;
				ErrorDialog.openError(shell, title, msg, x.getStatus());
			}
			return;
		}

		
		if (getDiagramEditPart() != null) {
			if(isEditable())
				getDiagramEditPart().enableEditMode();
			else
				getDiagramEditPart().disableEditMode();
		}
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.diagramdocument.IDiagramEditor#validateEditorInputState()
	 */
	public boolean validateEditorInputState() {

		boolean enabled= false;

		synchronized (this) {
			enabled= fIsStateValidationEnabled;
		}

		if (enabled) {

			GraphicalViewer viewer= getGraphicalViewer();
			if (viewer == null)
				return false;

			final IEditorInput input= getEditorInput();
			BusyIndicator.showWhile(getSite().getShell().getDisplay(), new Runnable() {
				/*
				 * @@see java.lang.Runnable#run()
				 */
				public void run() {
					validateState(input);
				}
			});
			sanityCheckState(input);
			return !isEditorInputReadOnly();
		}

		return !isEditorInputReadOnly();
	}

	/**
	 * Updates the state of the given editor input such as read-only flag.
	 *
	 * @@param input the input to be validated
	 * @@since 2.0
	 */
	protected void updateState(IEditorInput input) {
		IDocumentProvider provider= getDocumentProvider();
		try {

//			boolean wasReadOnly= isEditorInputReadOnly();
			provider.updateStateCache(input);

			if (getDiagramEditPart() != null) {
				if(isEditable())
					getDiagramEditPart().enableEditMode();
				else
					getDiagramEditPart().disableEditMode();
			}

		} catch (CoreException x) {
			Bundle bundle= Platform.getBundle(PlatformUI.PLUGIN_ID);
			ILog log= Platform.getLog(bundle);
			log.log(x.getStatus());
		}
	}

	/**
	 * Performs the save and handles errors appropriately.
	 *
	 * @@param overwrite indicates whether or not overwriting is allowed
	 * @@param progressMonitor the monitor in which to run the operation
	 * @@since 3.0
	 */
	protected void performSave(boolean overwrite, IProgressMonitor progressMonitor) {

		IDocumentProvider provider= getDocumentProvider();
		if (provider == null)
			return;

		try {

			provider.aboutToChange(getEditorInput());
			IEditorInput input= getEditorInput();
			provider.saveDocument(progressMonitor, input, getDocumentProvider().getDocument(input), overwrite);
			editorSaved();

		} catch (CoreException x) {
			IStatus status= x.getStatus();
			if (status == null || status.getSeverity() != IStatus.CANCEL)
				handleExceptionOnSave(x, progressMonitor);
		} finally {
			provider.changed(getEditorInput());
		}
	}

	/**
	 * The number of re-entrances into error correction code while saving.
	 * @@since 2.0
	 */
	private int fErrorCorrectionOnSave;

	/**
	 * Handles the given exception. If the exception reports an out-of-sync
	 * situation, this is reported to the user. Otherwise, the exception
	 * is generically reported.
	 *
	 * @@param exception the exception to handle
	 * @@param progressMonitor the progress monitor
	 */
	protected void handleExceptionOnSave(CoreException exception, IProgressMonitor progressMonitor) {

		try {
			++ fErrorCorrectionOnSave;

			Shell shell= getSite().getShell();

			boolean isSynchronized= false;
			IDocumentProvider p= getDocumentProvider();

			isSynchronized= p.isSynchronized(getEditorInput());

			if (isNotSynchronizedException(exception) && fErrorCorrectionOnSave == 1 && !isSynchronized) {
				String title= EditorMessages.Editor_error_save_outofsync_title;
				String msg= EditorMessages.Editor_error_save_outofsync_message;

				if (MessageDialog.openQuestion(shell, title, msg))
					performSave(true, progressMonitor);
				else {
					/*
					 * 1GEUPKR: ITPJUI:ALL - Loosing work with simultaneous edits
					 * Set progress monitor to canceled in order to report back
					 * to enclosing operations.
					 */
					if (progressMonitor != null)
						progressMonitor.setCanceled(true);
				}
			} else {
				String title= EditorMessages.Editor_error_save_title;
				String msg= EditorMessages.Editor_error_save_message;
				ErrorDialog.openError(shell, title, msg, exception.getStatus());

				/*
				 * 1GEUPKR: ITPJUI:ALL - Loosing work with simultaneous edits
				 * Set progress monitor to canceled in order to report back
				 * to enclosing operations.
				 */
				if (progressMonitor != null)
					progressMonitor.setCanceled(true);
			}
		} finally {
			-- fErrorCorrectionOnSave;
		}
	}
	
	/**
	 * Tells whether the given core exception is exactly the
	 * exception which is thrown for a non-synchronized element.
	 * <p>
	 * XXX: After 3.1 this method must be delegated to the document provider
	 * 		see 
	 * </p>
	 * 
	 * @@param ex the core exception
	 * @@return <code>true</code> iff the given core exception is exactly the
	 *			exception which is thrown for a non-synchronized element
	 * @@since 3.1
	 */
	private boolean isNotSynchronizedException(CoreException ex) {
		if (ex == null)
			return false;
		
		IStatus status= ex.getStatus(); 
		if (status == null || status instanceof MultiStatus)
			return false;
		
		if (status.getException() != null)
			return false;
		
		// Can't access IResourceStatus.OUT_OF_SYNC_LOCAL, using value: 274
		return status.getCode() == 274;
	}

	/**
	 * The <code>AbstractDiagramEditor</code> implementation of this
	 * <code>IEditorPart</code> method returns <code>false</code>.
	 * Subclasses may override.
	 *
	 * @@return <code>false</code>
	 */
	public boolean isSaveAsAllowed() {
		return false;
	}

	/*
	 * @@see EditorPart#isDirty()
	 */
	public boolean isDirty() {
		IDocumentProvider p= getDocumentProvider();
		return p == null ? false : p.canSaveDocument(getEditorInput());
	}

	/**
	 * Performs any additional action necessary to perform after the input
	 * document's content has been replaced.
	 * <p>
	 * Clients may extended this method.
	 *
	 * @@since 3.0
	 */
	protected void handleElementContentReplaced() {
		initializeGraphicalViewerContents();
	}

	/**
	 * Performs any additional action necessary to perform after the input
	 * document's content has been replaced.
	 * <p>
	 * Clients may extended this method.
	 *
	 * @@since 3.0
	 */
	protected void handleElementContentAboutToBeReplaced() {
		releaseInput();
	}

	/**
	 * Returns the status line manager of this editor.
	 * @@return the status line manager of this editor
	 * @@since 2.0
	 */
	private IStatusLineManager getStatusLineManager() {

		IEditorActionBarContributor contributor= getEditorSite().getActionBarContributor();
		if (!(contributor instanceof EditorActionBarContributor))
			return null;

		IActionBars actionBars= ((EditorActionBarContributor) contributor).getActionBars();
		if (actionBars == null)
			return null;

		return actionBars.getStatusLineManager();
	}
	/**
	 * Hook which gets called when the editor has been saved.
	 * Subclasses may extend.
	 * @@since 2.1
	 */
	protected void editorSaved() {
		// nothing to do
	}

	/*
	 * @@see WorkbenchPart#firePropertyChange(int)
	 */
	protected void firePropertyChange(int property) {
		super.firePropertyChange(property);
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.diagramdocument.IDiagramEditor#isEditorInputReadOnly()
	 */
	public boolean isEditorInputReadOnly() {
		IDocumentProvider provider= getDocumentProvider();
		return provider.isReadOnly(getEditorInput());
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.diagramdocument.IDiagramEditor#isEditorInputModifiable()
	 */
	public boolean isEditorInputModifiable() {
		IDocumentProvider provider= getDocumentProvider();
		return provider.isModifiable(getEditorInput());
	}

	/**
	 * The editor's activation listener.
	 * @@since 2.0
	 */
	private ActivationListener fActivationListener;
//	private final String fReadOnlyLabel= EditorMessages.Editor_statusline_state_readonly_label;
//	private final String fWritableLabel= EditorMessages.Editor_statusline_state_writable_label;
	/** The error message shown in the status line in case of failed information look up. */
	protected final String fErrorLabel= EditorMessages.Editor_statusline_error_label;
	/** The editor's element state listener. */
	private IElementStateListener fElementStateListener= new ElementStateListener();
	/** The editor's explicit document provider. */
	private IDocumentProvider fExplicitDocumentProvider;
	/**
	 * Indicates whether sanity checking in enabled.
	 * @@since 2.0
	 */
	private boolean fIsSanityCheckEnabled= true;
	/**
	 * Indicates whether state validation is enabled.
	 * @@since 2.1
	 */
	private boolean fIsStateValidationEnabled= true;
	/**
	 * Cached modification stamp of the editor's input.
	 * @@since 2.0
	 */
	private long fModificationStamp= IResource.NULL_STAMP;
	/**
	 * Internal part and shell activation listener for triggering state validation.
	 * @@since 2.0
	 */
	class ActivationListener implements IPartListener, IWindowListener {

		/** Cache of the active workbench part. */
		private IWorkbenchPart fActivePart;
		/** Indicates whether activation handling is currently be done. */
		private boolean fIsHandlingActivation= false;
		/**
		 * The part service.
		 * @@since 3.1
		 */
		private IPartService fPartService;

		/**
		 * Creates this activation listener.
		 *
		 * @@param partService the part service on which to add the part listener
		 * @@since 3.1
		 */
		public ActivationListener(IPartService partService) {
			fPartService= partService;
		}
		
		/**
		 * Disposes this activation listener.
		 *
		 * @@since 3.1
		 */
		public void dispose() {
			fPartService= null;
		}
		
		public void activate() {
			fPartService.addPartListener(this);
			PlatformUI.getWorkbench().addWindowListener(this);
		}
		
		public void deactivate() {
			fPartService.removePartListener(this);
			PlatformUI.getWorkbench().removeWindowListener(this);
		}

		/*
		 * @@see IPartListener#partActivated(org.eclipse.ui.IWorkbenchPart)
		 */
		public void partActivated(IWorkbenchPart part) {
			fActivePart= part;
			handleActivation();
		}

		/*
		 * @@see IPartListener#partBroughtToTop(org.eclipse.ui.IWorkbenchPart)
		 */
		public void partBroughtToTop(IWorkbenchPart part) {
			// nothing to do
		}

		/*
		 * @@see IPartListener#partClosed(org.eclipse.ui.IWorkbenchPart)
		 */
		public void partClosed(IWorkbenchPart part) {
			// nothing to do
		}

		/*
		 * @@see IPartListener#partDeactivated(org.eclipse.ui.IWorkbenchPart)
		 */
		public void partDeactivated(IWorkbenchPart part) {
			fActivePart= null;
		}

		/*
		 * @@see IPartListener#partOpened(org.eclipse.ui.IWorkbenchPart)
		 */
		public void partOpened(IWorkbenchPart part) {
			// nothing to do
		}

		/**
		 * Handles the activation triggering a element state check in the editor.
		 */
		private void handleActivation() {
			if (fIsHandlingActivation)
				return;

			if (fActivePart == DiagramDocumentEditor.this) {
				fIsHandlingActivation= true;
				try {
					safelySanityCheckState(getEditorInput());
				} finally {
					fIsHandlingActivation= false;
				}
			}
		}

		/*
		 * @@see org.eclipse.ui.IWindowListener#windowActivated(org.eclipse.ui.IWorkbenchWindow)
		 * @@since 3.1
		 */
		public void windowActivated(IWorkbenchWindow window) {
			if (window == getEditorSite().getWorkbenchWindow()) {
				/*
				 * Workaround for problem described in
				 * http://dev.eclipse.org/bugs/show_bug.cgi?id=11731
				 * Will be removed when SWT has solved the problem.
				 */
				window.getShell().getDisplay().asyncExec(new Runnable() {
					public void run() {
						handleActivation();
					}
				});
			}
		}

		/*
		 * @@see org.eclipse.ui.IWindowListener#windowDeactivated(org.eclipse.ui.IWorkbenchWindow)
		 * @@since 3.1
		 */
		public void windowDeactivated(IWorkbenchWindow window) {
			// nothing to do
		}

		/*
		 * @@see org.eclipse.ui.IWindowListener#windowClosed(org.eclipse.ui.IWorkbenchWindow)
		 * @@since 3.1
		 */
		public void windowClosed(IWorkbenchWindow window) {
			// nothing to do
		}

		/*
		 * @@see org.eclipse.ui.IWindowListener#windowOpened(org.eclipse.ui.IWorkbenchWindow)
		 * @@since 3.1
		 */
		public void windowOpened(IWorkbenchWindow window) {
			// nothing to do
		}
	}

	/**
	 * Internal element state listener.
	 */
	class ElementStateListener implements IElementStateListener {

		/**
		 * The display used for posting runnable into the UI thread.
		 * @@since 3.0
		 */
		private Display fDisplay;

		/* (non-Javadoc)
		 * @@see org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.document.IElementStateListener#elementStateValidationChanged(java.lang.Object, boolean)
		 */
		public void elementStateValidationChanged(final Object element, final boolean isStateValidated) {
			if (element != null && element.equals(getEditorInput())) {
				Runnable r= new Runnable() {
					public void run() {
						enableSanityChecking(true);
						if (isStateValidated) {
							GraphicalViewer viewer= getGraphicalViewer();
							if (viewer != null) {
								enableStateValidation(false);
							}
						} else {
							GraphicalViewer viewer= getGraphicalViewer();
							if (viewer != null) {
								enableStateValidation(true);
							}
						}
					}
				};
				execute(r, false);
			}
		}


		/* (non-Javadoc)
		 * @@see org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.document.IElementStateListener#elementDirtyStateChanged(java.lang.Object, boolean)
		 */
		public void elementDirtyStateChanged(Object element, boolean isDirty) {
			if (element != null && element.equals(getEditorInput())) {
				Runnable r= new Runnable() {
					public void run() {
						enableSanityChecking(true);
						firePropertyChange(PROP_DIRTY);
					}
				};
				execute(r, false);
			}
		}

		/* (non-Javadoc)
		 * @@see org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.document.IElementStateListener#elementContentAboutToBeReplaced(java.lang.Object)
		 */
		public void elementContentAboutToBeReplaced(Object element) {
			if (element != null && element.equals(getEditorInput())) {
				Runnable r= new Runnable() {
					public void run() {
						enableSanityChecking(true);
						handleElementContentAboutToBeReplaced();
					}
				};
				execute(r, false);
			}
		}

		/* (non-Javadoc)
		 * @@see org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.document.IElementStateListener#elementContentReplaced(java.lang.Object)
		 */
		public void elementContentReplaced(Object element) {
			if (element != null && element.equals(getEditorInput())) {
				Runnable r= new Runnable() {
					public void run() {
						enableSanityChecking(true);
						firePropertyChange(PROP_DIRTY);
						handleElementContentReplaced();
					}
				};
				execute(r, false);
			}
		}

		/*
		 * @@see IElementStateListener#elementDeleted(Object)
		 */
		public void elementDeleted(Object deletedElement) {
			if (deletedElement != null && deletedElement.equals(getEditorInput())) {
				Runnable r= new Runnable() {
					public void run() {
						enableSanityChecking(true);
						close(false);
					}
				};
				execute(r, false);
			}
		}

		/*
		 * @@see IElementStateListener#elementMoved(Object, Object)
		 */
		public void elementMoved(final Object originalElement, final Object movedElement) {
			if (originalElement != null && originalElement.equals(getEditorInput())) {
				final boolean doValidationAsync= Display.getCurrent() != null;
				Runnable r= new Runnable() {
					public void run() {
						enableSanityChecking(true);

						if (getGraphicalViewer() == null)
							return;

						if (!canHandleMove((IEditorInput) originalElement, (IEditorInput) movedElement)) {
							close(true);
							return;
						}

						if (movedElement == null || movedElement instanceof IEditorInput) {
							final IDocumentProvider d= getDocumentProvider();
							final Object previousContent;
							IDocument changed= null;
							IEditorInput oldInput= getEditorInput();
							if (isDirty()) {
								changed= d.getDocument(oldInput);
								if (changed != null) {
									if(changed instanceof IDiagramDocument)
										previousContent = ((IDiagramDocument)changed).detachDiagram();
									else
										previousContent= changed.getContent();
								} else
									previousContent= null;
							} else
								previousContent= null;

							try {
								doSetInput((IEditorInput) movedElement, !(changed != null));
							} catch (CoreException e) {
								String title= EditorMessages.Editor_error_setinput_title;
								String msg= EditorMessages.Editor_error_setinput_message;
								Shell shell= getSite().getShell();
								ErrorDialog.openError(shell, title, msg, e.getStatus());
							}

							if (changed != null) {
								Runnable r2= new Runnable() {
									public void run() {
										validateState(getEditorInput());
										getDocumentProvider().getDocument(getEditorInput()).setContent(previousContent);
									}
								};
								execute(r2, doValidationAsync);
							}

						}
					}
				};
				execute(r, false);
			}
		}

		/**
		 * Returns whether this editor can handle the move of the original element
		 * so that it ends up being the moved element. By default this method
		 * returns <code>true</code>. Subclasses may reimplement.
		 *
		 * @@param originalElement the original element
		 * @@param movedElement the moved element
		 * @@return whether this editor can handle the move of the original element
		 *         so that it ends up being the moved element
		 * @@since 2.0
		 */
		protected boolean canHandleMove(IEditorInput originalElement, IEditorInput movedElement) {
			return true;
		}

		/*
		 * @@see IElementStateListenerExtension#elementStateChanging(Object)
		 * @@since 2.0
		 */
		public void elementStateChanging(Object element) {
			if (element != null && element.equals(getEditorInput()))
				enableSanityChecking(false);
		}

		/*
		 * @@see IElementStateListenerExtension#elementStateChangeFailed(Object)
		 * @@since 2.0
		 */
		public void elementStateChangeFailed(Object element) {
			if (element != null && element.equals(getEditorInput()))
				enableSanityChecking(true);
		}

		/**
		 * Executes the given runnable in the UI thread.
		 * <p>
		 * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=76765 for details
		 * about why the parameter <code>postAsync</code> has been
		 * introduced in the course of 3.1.
		 *
		 * @@param runnable runnable to be executed
		 * @@param postAsync <code>true</code> if the runnable must be posted asynchronous, <code>false</code> otherwise
		 * @@since 3.0
		 */
		private void execute(Runnable runnable, boolean postAsync) {
			if (postAsync || Display.getCurrent() == null) {
				if (fDisplay == null)
					fDisplay= getSite().getShell().getDisplay();
				fDisplay.asyncExec(runnable);
			} else
				runnable.run();
		}
	}
	/** Title image to be disposed. */
	private Image fTitleImage;
	/**
	 * Initializes the editor's title based on the given editor input.
	 *
	 * @@param input the editor input to be used
	 */
	private void initializeTitle(IEditorInput input) {

		Image oldImage= fTitleImage;
		fTitleImage= null;
		String title= ""; //$NON-NLS-1$

		if (input != null) {
			IEditorDescriptor editorDesc = getEditorDescriptor();
			ImageDescriptor imageDesc= editorDesc != null ? editorDesc.getImageDescriptor() : null;

			fTitleImage= imageDesc != null ? imageDesc.createImage() : null;
			title= input.getName();
		}

		setTitleImage(fTitleImage);
		setPartName(title);

		firePropertyChange(PROP_DIRTY);

		if (oldImage != null && !oldImage.isDisposed())
			oldImage.dispose();
	}

	/**
	 * Retrieves the descriptor for this editor
	 * 
	 * @@return the editor descriptor
	 */
	final protected IEditorDescriptor getEditorDescriptor() {
		IEditorRegistry editorRegistry= PlatformUI.getWorkbench().getEditorRegistry();
		IEditorDescriptor editorDesc= editorRegistry.findEditor(getSite().getId());
		return editorDesc;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.ui.IWorkbenchPart#createPartControl(org.eclipse.swt.widgets.Composite)
	 */
	public void createPartControl(Composite parent) {
		IDocumentProvider provider = getDocumentProvider();
		IStatus status = provider.getStatus(getEditorInput());
		if(status != null && !status.isOK())
			throw new RuntimeException(new CoreException(status));
		super.createPartControl(parent);
	}
    
    // Documentation copied from superclass
    public TransactionalEditingDomain getEditingDomain() {
        return getEditorInput() instanceof MEditingDomainElement ? ((MEditingDomainElement)getEditorInput()).getEditingDomain() : super.getEditingDomain();
    }
    
	/**
     * Clients may override this if they wish to re-use an existing editing
     * domain for this editor. The default behavior is to create a new editing
     * domain is created for each diagram that is opened.
     * 
     * @@return the editing domain
     */
	protected TransactionalEditingDomain createEditingDomain() {
		return DiagramEditingDomainFactory.getInstance().createEditingDomain();
	}
@


1.10
log
@Bugzilla#113850 gmf_head cmahoney 060227 Diagram plug-in adoption of EMF transaction API enhancements
@
text
@d30 1
a46 1
import org.eclipse.gmf.runtime.emf.core.GMFEditingDomainFactory;
d1457 1
a1457 1
		return GMFEditingDomainFactory.INSTANCE.createEditingDomain();
@


1.9
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d27 1
a27 1
import org.eclipse.emf.edit.domain.EditingDomain;
d46 1
a46 2
import org.eclipse.gmf.runtime.emf.commands.core.command.EditingDomainUndoContext;
import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;
a87 1
	private MEditingDomain fEditingDomain;
a91 1
	 * @@param domain Editing Domain for the diagram.
d94 1
a94 1
	public DiagramDocumentEditor(MEditingDomain domain, boolean hasFlyoutPalette) {
a95 11
		fEditingDomain = domain;
        setUndoContext(new EditingDomainUndoContext(domain));
	}

	/**
	 * Constructs a diagram editor with optional flyout palette.
	 * This uses default editing domain.
	 * @@param hasFlyoutPalette creates a palette if true, else no palette
	 */
	public DiagramDocumentEditor(boolean hasFlyoutPalette) {
		this(MEditingDomain.INSTANCE, hasFlyoutPalette);
d417 3
a419 2
			if(!(input instanceof MEditingDomainElement))
				input = ((IDiagramDocumentProvider)provider).createInputWithEditingDomain(input, fEditingDomain);
d1445 2
a1446 2
    public EditingDomain getEditingDomain() {
        return fEditingDomain;
d1448 11
@


1.8
log
@bugzilla 120737 gmf-head sshaw 051213 Diagrams not opening from cvs repositories view.Contribution by Maneesh Goyal
@
text
@d2 1
a2 1
 * Copyright (c) 2005 IBM Corporation and others.
d16 2
d27 1
a28 1
import org.eclipse.gmf.runtime.common.core.command.CommandManager;
d46 1
d100 1
d261 1
a261 8
		return new ActionManager(createCommandManager());
	}
	
	/**
	 * @@overridable
	 */
	protected CommandManager createCommandManager() {
		return CommandManager.getDefault();
d263 9
d1456 5
@


1.7
log
@Bugzilla#113812 gmf_head cmahoney 051125 Deprecating DiagramResourceManager
@
text
@d328 18
@


1.6
log
@Bugzilla 116247 gmf_head 051121 tmacdoug - AbstractDocumentProvider allows Save as to a document that already opened
@
text
@d28 1
a28 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.DiagramResourceManager;
d210 2
a211 2
		String title = DiagramResourceManager.getI18NString("DiagramEditor.save.outofsync.dialog.title"); //$NON-NLS-1$
		String msg = DiagramResourceManager.getI18NString("DiagramEditor.save.outofsync.dialog.message"); //$NON-NLS-1$
d219 4
a222 4
		String title = DiagramResourceManager.getI18NString("DiagramEditor.handleDeleteEvent.dialog.title"); //$NON-NLS-1$
		String message = DiagramResourceManager.getI18NString("DiagramEditor.handleDeleteEvent.dialog.message"); //$NON-NLS-1$
		String[] buttons = { DiagramResourceManager.getI18NString("DiagramEditor.handleDeleteEvent.dialog.button.save"), //$NON-NLS-1$
			DiagramResourceManager.getI18NString("DiagramEditor.handleDeleteEvent.dialog.button.close")}; //$NON-NLS-1$
d237 2
a238 2
		String title = DiagramResourceManager.getI18NString("DiagramEditor.activated.outofsync.dialog.title"); //$NON-NLS-1$
		String msg = DiagramResourceManager.getI18NString("DiagramEditor.activated.outofsync.dialog.message"); //$NON-NLS-1$
@


1.5
log
@Bugzilla#113157 gmf_head cmahoney 051102 GMF Diagram Layer Public API Name Changes
@
text
@d1395 1
a1395 2
			IEditorRegistry editorRegistry= PlatformUI.getWorkbench().getEditorRegistry();
			IEditorDescriptor editorDesc= editorRegistry.findEditor(getSite().getId());
d1411 11
@


1.4
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d28 1
a28 1
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
d210 2
a211 2
		String title = PresentationResourceManager.getI18NString("DiagramEditor.save.outofsync.dialog.title"); //$NON-NLS-1$
		String msg = PresentationResourceManager.getI18NString("DiagramEditor.save.outofsync.dialog.message"); //$NON-NLS-1$
d219 4
a222 4
		String title = PresentationResourceManager.getI18NString("DiagramEditor.handleDeleteEvent.dialog.title"); //$NON-NLS-1$
		String message = PresentationResourceManager.getI18NString("DiagramEditor.handleDeleteEvent.dialog.message"); //$NON-NLS-1$
		String[] buttons = { PresentationResourceManager.getI18NString("DiagramEditor.handleDeleteEvent.dialog.button.save"), //$NON-NLS-1$
			PresentationResourceManager.getI18NString("DiagramEditor.handleDeleteEvent.dialog.button.close")}; //$NON-NLS-1$
d237 2
a238 2
		String title = PresentationResourceManager.getI18NString("DiagramEditor.activated.outofsync.dialog.title"); //$NON-NLS-1$
		String msg = PresentationResourceManager.getI18NString("DiagramEditor.activated.outofsync.dialog.message"); //$NON-NLS-1$
@


1.3
log
@Bugzilla 108849 gmf_head sshaw 050906 Capability support for Modeling Assistant and Palette Services
Contribution by: Cherie Mahoney
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2005.  All Rights Reserved.                    |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@


1.2
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@a12 1
import java.util.Iterator;
d24 20
a43 2
import org.eclipse.gef.palette.PaletteContainer;
import org.eclipse.gef.palette.PaletteRoot;
a74 23
import org.eclipse.gmf.runtime.common.core.command.CommandManager;
import org.eclipse.gmf.runtime.common.ui.action.ActionManager;
import org.eclipse.gmf.runtime.diagram.ui.l10n.PresentationResourceManager;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditDomain;
import org.eclipse.gmf.runtime.diagram.ui.parts.DiagramEditorWithFlyOutPalette;
import org.eclipse.gmf.runtime.diagram.ui.properties.views.PropertiesBrowserPage;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DocumentProviderRegistry;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocument;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDiagramDocumentProvider;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocument;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocumentEditor;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IDocumentProvider;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.IElementStateListener;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.MEditingDomainElement;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.document.DocumentProviderRegistry.IDocumentProviderSelector;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.EditorPlugin;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.l10n.EditorMessages;
import org.eclipse.gmf.runtime.diagram.ui.resources.editor.internal.palette.EditorInputPaletteContent;
import org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteService;
import org.eclipse.gmf.runtime.diagram.ui.services.palette.PaletteType;
import org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain;
import org.eclipse.gmf.runtime.notation.Diagram;

d116 5
a120 35
	/* Will create the palette for the diagram based on the type of project
	 * the diagram is in.  In additional it will uncollapsed the palette drawer 
	 * that are applicable to this diagram type.
	 * @@see org.eclipse.gef.ui.parts.GraphicalEditorWithPalette#getPaletteRoot()
	 */
	protected PaletteRoot getPaletteRoot() {
		PaletteRoot paletteRoot = null;
		String defaultDrawerToHaveOpen;

		paletteRoot =
			PaletteService.createPalette(
				this,
				getDefaultPaletteContent(),
				PaletteType.UMLVIEWER);
		defaultDrawerToHaveOpen = PaletteType.UMLVIEWER.getName();

		Iterator iter = paletteRoot.getChildren().iterator();

		//looping through and uncollapsing the drawer that is applicable to this
		//diagram
		while (iter.hasNext()) {
			PaletteContainer container = (PaletteContainer) iter.next();

			if (container instanceof org.eclipse.gmf.runtime.gef.ui.palette.PaletteDrawer) {
				org.eclipse.gmf.runtime.gef.ui.palette.PaletteDrawer drawer = (org.eclipse.gmf.runtime.gef.ui.palette.PaletteDrawer) container;
				if (drawer.getId().equals(defaultDrawerToHaveOpen)) {
					drawer.setInitialState(org.eclipse.gmf.runtime.gef.ui.palette.PaletteDrawer.INITIAL_STATE_OPEN);
				}
			}
		}
		return paletteRoot;
	}

	/* (non-Javadoc)
	 * @@see org.eclipse.ui.IEditorPart#init(org.eclipse.ui.IEditorSite, org.eclipse.ui.IEditorInput)
d193 6
a198 3
		IDiagramDocument document = ((IDiagramDocument)getDocumentProvider().getDocument(getEditorInput()));
		if(document != null)
			return document.getDiagram();
d265 2
a266 3
	/**
	 * @@overridable
	 * @@return
d268 1
a268 1
	protected EditorInputPaletteContent getDefaultPaletteContent() {
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d79 1
a79 1
import com.ibm.xtools.notation.Diagram;
@

