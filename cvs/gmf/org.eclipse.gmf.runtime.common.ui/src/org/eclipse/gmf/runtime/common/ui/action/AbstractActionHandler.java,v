head	1.9;
access;
symbols
	v20081023-2107:1.9
	v20081022-1925:1.9
	v20081022-1104:1.9
	v20081020-0700:1.9
	v20080722-1827:1.9
	R2_1_maintenance:1.9.0.4
	Root_R2_1_maintenance:1.9
	R2_1_0:1.9
	v20080512-1200:1.9
	v20080503-1740:1.9
	v20080501-1739:1.9
	v20080425-1959:1.9
	v20080407-2250:1.9
	v20080222-1200:1.9
	v20080215-1500:1.9
	v20071003-0000:1.9
	v20070921-0000:1.9
	v20070915-0000:1.9
	v20070809-0000:1.9
	R2_0_maintenance:1.9.0.2
	R2_0:1.9
	R4_20:1.9
	RC3_20:1.9
	v20070601-1400:1.9
	v20070504-1000:1.9
	v20070330-1300:1.9
	v20070208-1800:1.9
	M4_20:1.9
	v20061218-1200:1.9
	v20061214-0000:1.9
	M3_20:1.8
	v20061117-0800:1.8
	v20061020-1000:1.7.2.3
	v20061013-1330:1.8
	v20061012-1100:1.7.2.3
	v20060925-1700:1.7.2.3
	v20060919-0800:1.7.2.3
	M1_20:1.7
	v20060824-1600:1.7.2.2
	v20060803-1200:1.7.2.1
	v20060728-0500:1.7.2.1
	v20060721-1130:1.7.2.1
	v20060713-1700:1.7.2.1
	R1_0_maintenance:1.7.0.2
	R1_0:1.7
	v20060627-1200:1.7
	v20060616-1200:1.7
	v20060531-1730:1.6
	v20060526-1200:1.6
	I20060424-0500:1.6
	I20060424-0300:1.6
	M6_10:1.6
	I20060407-1200:1.6
	I20060331-1000:1.6
	I20060324-0300:1.5
	I20060317-1300:1.4
	I20060317-1200:1.4
	I20060316-1300:1.4
	I20060309-1300:1.4
	M5_10:1.4
	S20060303-1600:1.4
	I20060227-1730:1.4
	I20060216-1945:1.4
	I20060210-1715:1.3
	I20060209-1815:1.3
	I20060203-0830:1.3
	I20060129-1145:1.3
	I20060127-0900:1.3
	I20060120-1530:1.3
	I20060113-1700:1.3
	M4_10:1.3
	I20060107-1100:1.3
	I20060105-1630:1.3
	I20051230-1230:1.3
	I20051223-1100:1.3
	I20051217-0925:1.3
	I20051124-2000:1.3
	M3_10:1.3
	I20051118-1245:1.3
	I20051111-1800:1.3
	I20051106-0900:1.3
	v20051030:1.3;
locks; strict;
comment	@# @;


1.9
date	2006.11.29.19.20.08;	author crevells;	state Exp;
branches;
next	1.8;
commitid	4d65456ddd684567;

1.8
date	2006.10.03.14.51.25;	author ahunter;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.14.19.51.47;	author ldamus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2006.03.27.21.12.46;	author ldamus;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.23.20.00.05;	author ldamus;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.13.19.10.46;	author ldamus;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.05.17.12.46;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.23.49;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.13;	author sshaw;	state Exp;
branches;
next	;

1.7.2.1
date	2006.07.12.17.57.00;	author ldamus;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2006.08.18.18.55.17;	author mmostafa;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2006.09.15.16.03.13;	author cmahoney;	state Exp;
branches;
next	;


desc
@@


1.9
log
@[152706] gmf_head crevells 061129 "Ctrl+D" key stroke should be prohibited in outline view
Contributed by: Alex Boyko
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.ui.action;

import org.eclipse.core.commands.operations.IOperationHistory;
import org.eclipse.core.commands.operations.IOperationHistoryListener;
import org.eclipse.core.commands.operations.IUndoContext;
import org.eclipse.core.commands.operations.IUndoableOperation;
import org.eclipse.core.commands.operations.OperationHistoryEvent;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.internal.CommonUIDebugOptions;
import org.eclipse.gmf.runtime.common.ui.internal.CommonUIPlugin;
import org.eclipse.gmf.runtime.common.ui.internal.CommonUIStatusCodes;
import org.eclipse.gmf.runtime.common.ui.util.IPartSelector;
import org.eclipse.gmf.runtime.common.ui.util.PartListenerAdapter;
import org.eclipse.gmf.runtime.common.ui.util.StatusLineUtil;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.dialogs.ErrorDialog;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.ISelectionProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Event;
import org.eclipse.ui.IPartListener;
import org.eclipse.ui.IPropertyListener;
import org.eclipse.ui.ISelectionService;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.PlatformUI;

/**
 * The abstract parent of all concrete action handlers that execute commands.
 * Logging and exception handling are done in a uniform way in the
 * <code>run()</code> method. Concrete subclasses must provide a definition of
 * the <code>doRun()</code> method to gather any required input and execute a
 * command. As an implementer of the <code>IRepeatableAction</code> interface,
 * this class implements the <code>isRepeatable()</code> method to return
 * <code>true</code> if it is enabled, and implements the
 * <code>repeat()</code> method to run itself. Subclasses that aren't
 * repeatable or require special repeat behavior must override the default
 * implementations of these interface methods.
 * 
 * This action handler supports life cycle methods by implementing the
 * <code>IDisposableAction</code> interface. Therefore, clients need to call
 * the <code>init()</code> method to initialize the action, and the
 * <code>dispose()</code> method when the action is no longer needed.
 * 
 * @@author khussey
 */
public abstract class AbstractActionHandler
	extends Action
	implements IDisposableAction, IActionWithProgress, ISelectionChangedListener,
	IOperationHistoryListener, IPropertyListener {

	/**
	 * Flag to indicate whether or not this action has been set up.
	 */
	private boolean setup;

	/**
	 * My disposed state.
	 */
	private boolean disposed;

	/**
	 * The workbench part to which this action handler applies.
	 */
	private IWorkbenchPart workbenchPart;

	/**
	 * The workbench page this action is associated to
	 */
	private IWorkbenchPage workbenchPage;

	/**
	 * The part listener of this action
	 */
	private IPartListener partListener;
	
	/**
	 * Selects workbench parts that match the part criteria with which I was
	 * contributed. I will refresh myself when the selection changes on parts
	 * that match this criteria, and when such parts are activated.
	 */
	private IPartSelector partSelector;

	/**
	 * Constructs a new action handler for the specified workbench part.
	 * 
	 * @@param workbenchPart
	 *            The workbench part to which this action handler applies.
	 */
	protected AbstractActionHandler(IWorkbenchPart workbenchPart) {
		super();

		assert null != workbenchPart : "null workbenchPart"; //$NON-NLS-1$

		setWorkbenchPart(workbenchPart);

		this.workbenchPage = workbenchPart.getSite().getPage();

		// This is needed for backward compatibility in case the creator
		// of the action (using this constructor) did not dispose of it
		this.partListener = new PartListenerAdapter() {

			/**
			 * when the part closes, remove the listener to the workbench page
			 * and remove all listeners.
			 */
			public void partClosed(IWorkbenchPart part) {
				if (getWorkbenchPart() == part) {
					dispose();
				}
			}
		};
		workbenchPage.addPartListener(partListener);
	}

	/**
	 * Constructs a new action handler that gets its workbench part by listening
	 * to the given workbench page
	 * 
	 * @@param workbenchPage
	 *            The workbench page associated with this action handler
	 */
	protected AbstractActionHandler(final IWorkbenchPage workbenchPage) {
		super();

		assert null != workbenchPage : "null workbenchPage"; //$NON-NLS-1$

		this.workbenchPage = workbenchPage;

		this.partListener = new PartListenerAdapter() {

			/**
			 * Listens to part activation and updates the active workbench
			 */
			public void partActivated(IWorkbenchPart part) {
				setWorkbenchPart(part);
				if (part != null && contributedToPart(part))
					refresh();
			}

			/**
			 * Listens to part deactivation and disables the action
			 * Could be improved to only consider toolbar actions
			 */
			public void partDeactivated(IWorkbenchPart part) {
				if (part != null && contributedToPart(part)) {
					setEnabled(false);
				}
			}
			
		};
		workbenchPage.addPartListener(partListener);
	}

	/**
	 * The basic implementation sets the workbenchpart if not already set and
	 * refreshes the action if the current part is not null.
	 * <P>
	 * Any subclass that overrided this method should ensure that the disposed
	 * state of this action is maintained by calling
	 * <code>setDisposed(false)</code> or calling <code>super.init()</code>.
	 */
	public void init() {

		setDisposed(false);

		if (getWorkbenchPart() == null)
			setWorkbenchPart(getWorkbenchPage().getActivePart());
		if (getWorkbenchPart() != null)
			refresh();
	}

	/**
	 * Default implementation of dispose. Any subclass that overrided this
	 * method should ensure that the disposed state of this action is maintained
	 * by calling <code>setDisposed(true)</code> or calling
	 * <code>super.dispose()</code>.
	 */
	public void dispose() {
		setWorkbenchPart(null);

		if (partListener != null && workbenchPage != null) {
			workbenchPage.removePartListener(partListener);
			workbenchPage = null;
			partListener = null;
		}
		setDisposed(true);
	}

	/**
	 * Sets the current workbencgPart
	 * 
	 * @@param workbenchPart
	 *            The current workbenchPart
	 */
	protected void setWorkbenchPart(IWorkbenchPart workbenchPart) {
		if (getWorkbenchPart() == workbenchPart)
			return;

		if (getWorkbenchPart() != null) {
			if (isSelectionListener()) {
				ISelectionProvider provider = getWorkbenchPart().getSite()
					.getSelectionProvider();
				if (provider != null) {
					provider.removeSelectionChangedListener(this);
				}
			}
			if (isPropertyListener()) {
				getWorkbenchPart().removePropertyListener(this);
			}
			if (isOperationHistoryListener()) {
                getOperationHistory().removeOperationHistoryListener(this);
			}
		}

		this.workbenchPart = workbenchPart;

		if (workbenchPart != null) {
			
			if (contributedToPart(workbenchPart)) {
				
				if (isSelectionListener()) {
					ISelectionProvider provider = getWorkbenchPart().getSite()
							.getSelectionProvider();
					if (provider != null) {
						provider.addSelectionChangedListener(this);
					}
				}
				if (isPropertyListener()) {
					getWorkbenchPart().addPropertyListener(this);
				}
				if (isOperationHistoryListener()) {
					getOperationHistory().addOperationHistoryListener(this);
				}
			}
		}
	}
	
	/**
	 * Answers whether or not I am contributed to <code>part</code>.
	 * 
	 * @@param part
	 *            the workbench part to be tested
	 * @@return <code>true</code> if I am contributed to this part,
	 *         <code>false</code> otherwise.
	 */
	protected boolean contributedToPart(IWorkbenchPart part) {
		return partSelector == null || partSelector.selects(part);
	}
	
	/**
	 * Sets my part selector. If my current workbench part doesn't match the
	 * part selector, I stop listening to selection, property and operation
	 * history changes on that part.
	 * 
	 * @@param partSelector
	 *            my new part selector
	 */
	public final void setPartSelector(IPartSelector partSelector) {
		
		if (this.partSelector == partSelector) {
			return;
		}
		
		this.partSelector = partSelector;
		IWorkbenchPart part = getWorkbenchPart();
		
		if (part != null && !partSelector.selects(part)) {
			if (isSelectionListener()) {
				ISelectionProvider provider = getWorkbenchPart().getSite()
					.getSelectionProvider();
				if (provider != null) {
					provider.removeSelectionChangedListener(this);
				}
			}
			if (isPropertyListener()) {
				getWorkbenchPart().removePropertyListener(this);
			}
			if (isOperationHistoryListener()) {
                getOperationHistory().removeOperationHistoryListener(this);
			}
		}
	}


	/**
	 * Retrieves the value of the <code>workbenchPart</code> instance
	 * variable.
	 * 
	 * @@return The value of the <code>workbenchPart</code> instance variable.
	 */
	protected final IWorkbenchPart getWorkbenchPart() {
		return workbenchPart;
	}

	/**
	 * Retrieves the action manager for this action handler from its workbench
	 * part.
	 * 
	 * @@return The action manager for this action handler.
	 */
	protected ActionManager getActionManager() {
		ActionManager manager = null;
		IWorkbenchPart wbPart = getWorkbenchPart();
		if (wbPart != null) {
			manager = (ActionManager) wbPart.getAdapter(
				ActionManager.class);			
		}
		
		return null == manager ? ActionManager.getDefault()
			: manager;
	}
	
    /**
     * Returns the operation history for this action handler from its action
     * manager.
     * 
     * @@return the operation history
     */
    protected IOperationHistory getOperationHistory() {
        return getActionManager().getOperationHistory();
    }

	/* (non-Javadoc)
	 * @@see org.eclipse.jface.action.IAction#run()
	 */
	public void run() {
		getActionManager().run(this);
	}

	/**
	 * Runs this action handler.
	 */
	public void run(IProgressMonitor progressMonitor) {
		if (isSetup() || !needsSetup()) {
			try {
				StatusLineUtil.outputErrorMessage(getWorkbenchPart(),
					StringStatics.BLANK);
				doRun(progressMonitor);
			} catch (Exception e) {
				handle(e);
			}
			setSetup(false);
		} else {
			throw new IllegalStateException(
				"action must be setup before it is run"); //$NON-NLS-1$
		}
	}

	/**
	 * Runs this action handler, passing the triggering SWT event.
	 * 
	 * @@param event
	 *            The SWT event which triggered this action being run.
	 */
	public void runWithEvent(Event event) {
		getActionManager().run(this);
	}

	/**
	 * Notifies this action handler that the selection has changed.
	 * 
	 * @@param event
	 *            Event object describing the change.
	 */
	public final void selectionChanged(SelectionChangedEvent event) {
		refresh();
	}

	/**
	 * Property change event handler; does nothing by default. Subclasses should
	 * override if they are interested in handling property change events.
	 */
	public void propertyChanged(Object source, int propId) {
		// Do nothing by default
	}
	
	/**
	 * Retrieves the label for this action handler.
	 * 
	 * @@return The label for this action handler.
	 */
	public String getLabel() {
		return getText();
	}

	/**
	 * Retrieves the current selection.
	 * 
	 * @@return The current selection.
	 */
	protected ISelection getSelection() {
        ISelection selection = null;
        ISelectionService selectionService = null;
        if (getWorkbenchPart() != null && getWorkbenchPart().getSite().getWorkbenchWindow() != null) {
            selectionService = getWorkbenchPart().getSite()
                .getWorkbenchWindow().getSelectionService();
        }

        if (selectionService != null) {
            selection = selectionService.getSelection();
        }

        return (selection != null) ? selection
            : StructuredSelection.EMPTY;
    }

	/**
	 * Retrieves the current structured selection.
	 * 
	 * @@return The current structured selection.
	 */
	protected IStructuredSelection getStructuredSelection() {
        ISelection selection = getSelection();
        return (selection instanceof StructuredSelection) ? (StructuredSelection) selection
            : StructuredSelection.EMPTY;
    }

	/**
	 * Retrieves a Boolean indicating whether this action handler can be run.
	 * 
	 * @@return <code>true</code> if this action handler is enabled;
	 *         <code>false</code> otherwise.
	 */
	public boolean isRunnable() {
		return isEnabled();
	}

	/**
	 * Retrieves a Boolean indicating whether this action handler is interested
	 * in selection events.
	 * 
	 * @@return <code>true</code> if this action handler is interested;
	 *         <code>false</code> otherwise.
	 */
	protected boolean isSelectionListener() {
		return false;
	}

	/**
	 * Answers whether of not this action handler is interested in property
	 * change events.
	 * <P>
	 * This default implementation always returns <code>false</code>.
	 * Subclasses must override if they are interested in property change
	 * events.
	 * 
	 * @@return <code>true</code> if this action handler is interested;
	 *         <code>false</code> otherwise.
	 */
	protected boolean isPropertyListener() {
		return false;
	}
	
    /**
     * Retrieves a Boolean indicating whether this action handler is interested
     * in operation history changed events.
     * 
     * @@return <code>true</code> if this action handler is interested;
     *         <code>false</code> otherwise.
     */
    protected boolean isOperationHistoryListener() {
        return false;
    }

	/**
	 * Handles the specified exception.
	 * 
	 * @@param exception
	 *            The exception to be handled.
	 */
	protected void handle(Exception exception) {
		Trace.catching(CommonUIPlugin.getDefault(),
			CommonUIDebugOptions.EXCEPTIONS_CATCHING, getClass(),
			"handle", exception); //$NON-NLS-1$

		IStatus status = new Status(IStatus.ERROR,
			CommonUIPlugin.getPluginId(), CommonUIStatusCodes.ACTION_FAILURE,
			String.valueOf(exception.getMessage()), exception);

		Log.log(CommonUIPlugin.getDefault(), status);
		openErrorDialog(status);
	}

	/**
	 * Opens an error dialog for the specified status object.
	 * 
	 * @@param status
	 *            The status object for which to open an error dialog.
	 *  
	 */
	protected void openErrorDialog(final IStatus status) {
        
        final Display workbenchDisplay = PlatformUI.getWorkbench().getDisplay();

        if (workbenchDisplay.getThread() == Thread.currentThread()) {
            // we're already on the UI thread
            ErrorDialog.openError(workbenchDisplay.getActiveShell(),
                removeMnemonics(getLabel()), null, status);

        } else {
            // we're not on the UI thread
            workbenchDisplay.asyncExec(new Runnable() {

                public void run() {
                    ErrorDialog.openError(workbenchDisplay.getActiveShell(),
                        removeMnemonics(getLabel()), null, status);
                }
            });
        }
    }

	/**
	 * Performs the actual work when this action handler is run. Subclasses must
	 * override this method to do some work.
	 * 
	 * @@param progressMonitor
	 *            the progress monitor for tracking the progress of this action
	 *            when it is run.
	 */
	protected abstract void doRun(IProgressMonitor progressMonitor);


	/* (non-Javadoc)
	 * @@see org.eclipse.gmf.runtime.common.ui.action.IRepeatableAction#getWorkIndicatorType()
	 */
	public WorkIndicatorType getWorkIndicatorType() {
		return WorkIndicatorType.BUSY;
	}

	/**
	 * Returns the part listener
	 * 
	 * @@return The part listener
	 */
	protected IPartListener getPartListener() {
		return partListener;
	}

	/**
	 * Returns the workbench page
	 * 
	 * @@return The workbench page
	 */
	protected IWorkbenchPage getWorkbenchPage() {
		return workbenchPage;
	}
    
    /**
	 * Refreshes me if the history event has my workbench part's context, and
	 * the event is one of:
	 * <UL>
	 * <LI>{@@link OperationHistoryEvent#UNDONE}</LI>
	 * <LI>{@@link OperationHistoryEvent#REDONE}</LI>
	 * <LI>{@@link OperationHistoryEvent#OPERATION_ADDED}</LI>
	 * <LI>{@@link OperationHistoryEvent#OPERATION_CHANGED}</LI>
	 * <LI>{@@link OperationHistoryEvent#OPERATION_NOT_OK}</LI>
	 * <LI>{@@link OperationHistoryEvent#OPERATION_REMOVED}</LI>
	 * </UL>
	 * The other operation history events are ignored because they are
	 * intermediate events that will be followed by one of those listed above.
	 * We only want to refresh the action handler once for each change to the
	 * operation history.
	 */
    public void historyNotification(OperationHistoryEvent event) {

    	int type = event.getEventType();
    	if (type == OperationHistoryEvent.UNDONE
				|| type == OperationHistoryEvent.REDONE
				|| type == OperationHistoryEvent.OPERATION_ADDED
				|| type == OperationHistoryEvent.OPERATION_CHANGED
				|| type == OperationHistoryEvent.OPERATION_NOT_OK
				|| type == OperationHistoryEvent.OPERATION_REMOVED) {
        
    		IUndoableOperation operation = event.getOperation();
        
	        if (operation != null) {
	            IUndoContext partContext = getUndoContext();
	
	            if (partContext != null && operation.hasContext(partContext)) {
	                refresh();
	            }
	        }
    	}
    }
    
    /**
     * Gets the undo context from my workbench part.
     * 
     * @@return the undo context
     */
    protected IUndoContext getUndoContext() {
        IWorkbenchPart part = getWorkbenchPart();

        if (part != null) {
            return (IUndoContext) part.getAdapter(IUndoContext.class);
        }

        return null;
    }

	/*
     * (non-Javadoc)
     * 
     * @@see org.eclipse.gmf.runtime.common.ui.action.IDisposableAction#isDisposed()
     */
	public boolean isDisposed() {
		return disposed;
	}

	/**
	 * Sets my disposed state.
	 * 
	 * @@param b
	 *            <code>true</code> if I am disposed, <code>false</code>
	 *            otherwise.
	 */
	protected void setDisposed(boolean b) {
		disposed = b;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.common.ui.action.IRepeatableAction#setup()
	 */
	public boolean setup() {
		setSetup(true);
		return true;
	}

	/**
	 * Returns the setup state of this action.
	 * 
	 * @@return <code>true</code> if the action has been setup,
	 *         <code>false</code> otherwise.
	 */
	public boolean isSetup() {
		return setup;
	}

	/**
	 * Sets the setup state of this action.
	 * 
	 * @@param setup
	 *            <code>true</code> if the action has been setup,
	 *            <code>false</code> otherwise.
	 */
	protected void setSetup(boolean setup) {
		this.setup = setup;
	}

	/**
	 * Answers whether or not this action should be setup before it is run.
	 * Subclasses should override if they provide vital behaviour in the setup
	 * method.
	 * 
	 * @@return <code>true</code> if the action has a setup, <code>false</code>
	 *         otherwise.
	 */
	protected boolean needsSetup() {
		return false;
	}
	
}@


1.8
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d43 1
d413 6
a418 3
		ISelection selection = null;
		ISelectionProvider selectionProvider = getWorkbenchPart().getSite()
			.getSelectionProvider();
d420 3
a422 3
		if (selectionProvider != null) {
			selection = selectionProvider.getSelection();
		}
d424 3
a426 3
		return (selection != null) ? selection
			: StructuredSelection.EMPTY;
	}
d434 4
a437 14
		IStructuredSelection selection = null;
		ISelectionProvider selectionProvider = null;
		if (getWorkbenchPart() != null) {
			selectionProvider = getWorkbenchPart().getSite()
				.getSelectionProvider();
		}

		if (selectionProvider != null
			&& selectionProvider.getSelection() instanceof IStructuredSelection) {
			selection = (IStructuredSelection) selectionProvider.getSelection();
		}
		return (selection != null) ? selection
			: StructuredSelection.EMPTY;
	}
@


1.7
log
@[144762] gmf_head ldamus 060614 ClassCastException on activating part that adapts to IEditingDomainProvider
@
text
@d159 11
d267 1
a267 1
		return partSelector == null || partSelector.selects(workbenchPart);
d576 15
a590 2
     * Refreshes me if the history event has my workbench part's context.
     */
d593 18
a610 9
        IUndoableOperation operation = event.getOperation();

        if (operation != null) {
            IUndoContext partContext = getUndoContext();

            if (partContext != null && operation.hasContext(partContext)) {
                refresh();
            }
        }
@


1.7.2.1
log
@[149185] gmf_R1_0_maintenance ldamus 060712 performance: AbstractActionHandler refreshes action on every OperationHistoryEvents
@
text
@d565 2
a566 15
	 * Refreshes me if the history event has my workbench part's context, and
	 * the event is one of:
	 * <UL>
	 * <LI>{@@link OperationHistoryEvent#UNDONE}</LI>
	 * <LI>{@@link OperationHistoryEvent#REDONE}</LI>
	 * <LI>{@@link OperationHistoryEvent#OPERATION_ADDED}</LI>
	 * <LI>{@@link OperationHistoryEvent#OPERATION_CHANGED}</LI>
	 * <LI>{@@link OperationHistoryEvent#OPERATION_NOT_OK}</LI>
	 * <LI>{@@link OperationHistoryEvent#OPERATION_REMOVED}</LI>
	 * </UL>
	 * The other operation history events are ignored because they are
	 * intermediate events that will be followed by one of those listed above.
	 * We only want to refresh the action handler once for each change to the
	 * operation history.
	 */
d569 9
a577 18
    	int type = event.getEventType();
    	if (type == OperationHistoryEvent.UNDONE
				|| type == OperationHistoryEvent.REDONE
				|| type == OperationHistoryEvent.OPERATION_ADDED
				|| type == OperationHistoryEvent.OPERATION_CHANGED
				|| type == OperationHistoryEvent.OPERATION_NOT_OK
				|| type == OperationHistoryEvent.OPERATION_REMOVED) {
        
    		IUndoableOperation operation = event.getOperation();
        
	        if (operation != null) {
	            IUndoContext partContext = getUndoContext();
	
	            if (partContext != null && operation.hasContext(partContext)) {
	                refresh();
	            }
	        }
    	}
@


1.7.2.2
log
@[149244] gmf_R1_0_maintenance tmacdoug 060816 NullPointerException in ArrangeAction
@
text
@a158 11

			/**
			 * Listens to part deactivation and disables the action
			 * Could be improved to only consider toolbar actions
			 */
			public void partDeactivated(IWorkbenchPart part) {
				if (part != null && contributedToPart(part)) {
					setEnabled(false);
				}
			}
			
@


1.7.2.3
log
@Bugzilla#157471 gmf_R1_0_maintenance cmahoney 060915 Toolbar buttons become out of sync with current diagram selection
@
text
@d267 1
a267 1
		return partSelector == null || partSelector.selects(part);
@


1.6
log
@[112826] gmf_head ldamus 060327 Adopt Eclipse 3.1 Operation History Framework - removing deprecated API
@
text
@d28 1
d95 7
d156 1
a156 1
				if (part != null)
d227 50
d281 1
a281 1
					provider.addSelectionChangedListener(this);
d285 1
a285 1
				getWorkbenchPart().addPropertyListener(this);
d288 1
a288 1
                getOperationHistory().addOperationHistoryListener(this);
d293 1
@


1.5
log
@[132143] gmf_head ldamus 060323 AbstractActionHandler causes SWTException when reporting errors
@
text
@a21 1
import org.eclipse.gmf.runtime.common.core.command.CommandManager;
a261 11

	/**
	 * Retrieves the command manager for this action handler from its action
	 * manager.
	 * 
	 * @@return The command manager for this action handler.
     * @@deprecated Use {@@link #getOperationHistory()} instead.
	 */
	protected CommandManager getCommandManager() {
		return CommandManager.getDefault();
	}
a409 12
    	
	/**
	 * Retrieves a Boolean indicating whether this action handler is interested
	 * in commnd stack changed events.
	 * 
	 * @@return <code>true</code> if this action handler is interested;
	 *         <code>false</code> otherwise.
     * @@deprecated Subclasses must implement {@@link #isOperationHistoryListener()}.
	 */
	protected boolean isCommandStackListener() {
		return false;
	}
@


1.4
log
@[112826] gmf_head ldamus 060213 Adopt Eclipse 3.1 Operation History Framework
@
text
@d39 1
d45 1
d472 20
a491 4
	protected void openErrorDialog(IStatus status) {
		ErrorDialog.openError(getWorkbenchPart().getSite().getShell(),
			removeMnemonics(getLabel()), null, status);
	}
@


1.3
log
@Bugzilla 111637 gmf_head ldamus 051005 IRepeatableAction should be deprecated
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2005 IBM Corporation and others.
d14 5
d22 9
a44 12
import org.eclipse.gmf.runtime.common.core.command.CommandManager;
import org.eclipse.gmf.runtime.common.core.command.CommandManagerChangeEvent;
import org.eclipse.gmf.runtime.common.core.command.ICommandManagerChangeListener;
import org.eclipse.gmf.runtime.common.core.util.Log;
import org.eclipse.gmf.runtime.common.core.util.StringStatics;
import org.eclipse.gmf.runtime.common.core.util.Trace;
import org.eclipse.gmf.runtime.common.ui.internal.CommonUIDebugOptions;
import org.eclipse.gmf.runtime.common.ui.internal.CommonUIPlugin;
import org.eclipse.gmf.runtime.common.ui.internal.CommonUIStatusCodes;
import org.eclipse.gmf.runtime.common.ui.util.PartListenerAdapter;
import org.eclipse.gmf.runtime.common.ui.util.StatusLineUtil;

d67 1
a67 1
	ICommandManagerChangeListener, IPropertyListener {
d210 2
a211 2
			if (isCommandStackListener()) {
				getCommandManager().removeCommandManagerChangeListener(this);
d228 2
a229 2
			if (isCommandStackListener()) {
				getCommandManager().addCommandManagerChangeListener(this);
d267 1
d270 1
a270 1
		return getActionManager().getCommandManager();
d272 10
d420 1
a420 1
	
d427 1
d432 11
d510 28
d539 2
a540 9
	/**
	 * Handles an event indicating that a command manager has changed.
	 * 
	 * @@param event
	 *            The command manager change event to be handled.
	 */
	public final void commandManagerChanged(CommandManagerChangeEvent event) {
		refresh();
	}
d543 4
a546 4
	 * (non-Javadoc)
	 * 
	 * @@see org.eclipse.gmf.runtime.common.ui.action.IDisposableAction#isDisposed()
	 */
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d64 1
a64 1
	implements IDisposableAction, IRepeatableAction, ISelectionChangedListener,
a372 11
	 * Retrieves a Boolean indicating whether this action handler can be
	 * repeated.
	 * 
	 * @@return <code>true</code> if this action handler is enabled;
	 *         <code>false</code> otherwise.
	 */
	public boolean isRepeatable() {
		return isEnabled();
	}

	/**
a419 7
	 * Re-runs this action handler.
	 */
	public void repeat(IProgressMonitor progressMonitor) {
		run(progressMonitor);
	}

	/**
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2005.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

