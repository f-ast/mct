head	1.6;
access;
symbols
	v20081023-2107:1.5.2.1
	v20081022-1925:1.6
	v20081022-1104:1.5.2.1
	v20081020-0700:1.5
	v20080722-1827:1.5
	R2_1_maintenance:1.5.0.2
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080512-1200:1.5
	v20080503-1740:1.4
	v20080501-1739:1.4
	v20080425-1959:1.4
	v20080407-2250:1.4
	v20080222-1200:1.4
	v20080215-1500:1.4
	v20071003-0000:1.4
	v20070921-0000:1.4
	v20070915-0000:1.4
	v20070809-0000:1.4
	R2_0_maintenance:1.4.0.2
	R2_0:1.4
	R4_20:1.4
	RC3_20:1.4
	v20070601-1400:1.4
	v20070504-1000:1.4
	v20070330-1300:1.4
	v20070208-1800:1.4
	M4_20:1.4
	v20061218-1200:1.4
	v20061214-0000:1.4
	M3_20:1.4
	v20061117-0800:1.4
	v20061020-1000:1.3.2.1
	v20061013-1330:1.4
	v20061012-1100:1.3.2.1
	v20060925-1700:1.3.2.1
	v20060919-0800:1.3.2.1
	M1_20:1.3
	v20060824-1600:1.3
	v20060803-1200:1.3
	v20060728-0500:1.3
	v20060721-1130:1.3
	v20060713-1700:1.3
	R1_0_maintenance:1.3.0.2
	R1_0:1.3
	v20060627-1200:1.3
	v20060616-1200:1.3
	v20060531-1730:1.3
	v20060526-1200:1.3
	I20060424-0500:1.2
	I20060424-0300:1.2
	M6_10:1.2
	I20060407-1200:1.2
	I20060331-1000:1.2
	I20060324-0300:1.2
	I20060317-1300:1.2
	I20060317-1200:1.2
	I20060316-1300:1.2
	I20060309-1300:1.2
	M5_10:1.2
	S20060303-1600:1.2
	I20060227-1730:1.2
	I20060216-1945:1.2
	I20060210-1715:1.2
	I20060209-1815:1.2
	I20060203-0830:1.2
	I20060129-1145:1.2
	I20060127-0900:1.2
	I20060120-1530:1.2
	I20060113-1700:1.2
	M4_10:1.2
	I20060107-1100:1.2
	I20060105-1630:1.2
	I20051230-1230:1.2
	I20051223-1100:1.2
	I20051217-0925:1.2
	I20051124-2000:1.2
	M3_10:1.2
	I20051118-1245:1.2
	I20051111-1800:1.2
	I20051106-0900:1.2
	v20051030:1.2;
locks; strict;
comment	@# @;


1.6
date	2008.10.22.14.33.07;	author ahunter;	state Exp;
branches;
next	1.5;
commitid	1dca648ff39a34567;

1.5
date	2008.05.09.20.45.38;	author ahunter;	state Exp;
branches
	1.5.2.1;
next	1.4;
commitid	22384824b7f24567;

1.4
date	2006.10.03.14.51.25;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.24.16.00.12;	author ahunter;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2005.09.12.21.23.50;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.26;	author sshaw;	state Exp;
branches;
next	;

1.3.2.1
date	2006.09.13.16.41.24;	author ahunter;	state Exp;
branches;
next	;

1.5.2.1
date	2008.10.22.14.30.03;	author ahunter;	state Exp;
branches;
next	;
commitid	1d75048ff38e94567;


desc
@@


1.6
log
@[247364] gmf_head ahunter 081022 Error in FileObserverFilter#matches
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.ui.internal.resources;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.content.IContentType;


/**
 * Utility class that describes a file observer filter.
 * 
 * @@author Anthony Hunter <a
 *         href="mailto:ahunter@@rational.com">ahunter@@rational.com </a>
 */
public class FileObserverFilter {

	/**
	 * the filter type.
	 */
	private FileObserverFilterType filterType;

	/**
	 * the filter.
	 */
	private Object filter;

	/**
	 * Create a file observer filter that will not filter out any events.
	 * 
	 * @@param aFilterType
	 *            The filter type, all.
	 */
	public FileObserverFilter(FileObserverFilterType aFilterType) {
		assert (aFilterType == FileObserverFilterType.ALL);
		setFilterType(aFilterType);
		setFilter(null);
	}

	/**
	 * Create a file observer filter that will filter out any events not for the
	 * provided file extension.
	 * 
	 * @@param aFilterType
	 *            The filter type, extension.
	 * @@param extension
	 *            The file extension array filter.
	 */
	public FileObserverFilter(FileObserverFilterType aFilterType,
			String[] extension) {
		assert (aFilterType == FileObserverFilterType.EXTENSION);
		setFilterType(aFilterType);
		setFilter(extension);
	}

	/**
	 * Create a file observer filter that will filter out any events not for the
	 * provided content types.
	 * 
	 * @@param aFilterType
	 *            The filter type, content type.
	 * @@param extension
	 *            The file content type array filter.
	 */
	public FileObserverFilter(FileObserverFilterType aFilterType,
			IContentType[] contentType) {
		assert (aFilterType == FileObserverFilterType.CONTENT_TYPE);
		setFilterType(aFilterType);
		setFilter(contentType);
	}

	/**
	 * Create a file observer filter that will filter out any events not for
	 * children files under the provided folder.
	 * 
	 * @@param aFilterType
	 *            The filter type, folder.
	 * @@param folder
	 *            The folder filter.
	 */
	public FileObserverFilter(FileObserverFilterType aFilterType, IFolder folder) {
		assert (aFilterType == FileObserverFilterType.FOLDER);
		setFilterType(aFilterType);
		setFilter(folder);
	}

	/**
	 * Create a file observer filter that will filter out any events not for the
	 * provided file.
	 * 
	 * @@param aFilterType
	 *            The filter type, all.
	 * @@param file
	 *            The file filter.
	 */
	public FileObserverFilter(FileObserverFilterType aFilterType, IFile file) {
		assert (aFilterType == FileObserverFilterType.FILE);
		setFilterType(aFilterType);
		setFilter(file);
	}

	/**
	 * Determines if the filter matches the provided resource.
	 * 
	 * @@param resource
	 *            the resource.
	 * @@return true if the filter matches the provided resource and the event
	 *         should be given to the file change observer.
	 */
	public boolean matches(IResource resource) {
		if (getFilterType() == FileObserverFilterType.ALL) {
			return true;
		}
		if (getFilterType() == FileObserverFilterType.FILE
			&& resource instanceof IFile
			&& getAbsolutePath(getFileFilter()).equals(
				getAbsolutePath(resource))) {
			return true;

		}
		if (getFilterType() == FileObserverFilterType.FOLDER
				&& resource instanceof IFile
				&& getAbsolutePath(resource).startsWith(
					getAbsolutePath(getFolderFilter()))) {
				return true;
			}
		if (getFilterType() == FileObserverFilterType.CONTENT_TYPE
				&& resource instanceof IFile
				&& matchesContentType(((IFile)resource).getName())) {
				return true;
			}
		if (getFilterType() == FileObserverFilterType.EXTENSION
			&& resource instanceof IFile) {
			String fileExtension = resource.getFullPath().getFileExtension();
			if (matchesExtension(fileExtension)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Determines if the filter matches the provided path.
	 * 
	 * @@param path
	 *            the path.
	 * @@return true if the filter matches the provided path and the event should
	 *         be given to the file change observer.
	 */
	public boolean matches(IPath path) {
		if (getFilterType() == FileObserverFilterType.ALL) {
			return true;
		}
		if (getFilterType() == FileObserverFilterType.FILE
			&& getFileFilter().getFullPath().equals(path)) {
			return true;
		}
		if (getFilterType() == FileObserverFilterType.FOLDER
				&& path.isPrefixOf(getFolderFilter().getFullPath())) {
				return true;
			}
		if (getFilterType() == FileObserverFilterType.CONTENT_TYPE
				&& matchesContentType(path.segment(path.segmentCount()-1))) {
				return true;
			}
		if (getFilterType() == FileObserverFilterType.EXTENSION
			&& matchesExtension(path.getFileExtension())) {
			return true;
		}
		return false;
	}

	/**
	 * Determines if the file name matches observed content types
	 * 
	 * @@param fileName
	 *            file name to be matched
	 * @@return true if the file name matches observed content types
	 */
	private boolean matchesContentType(String fileName) {
		IContentType[] contentTypes = getContentTypeFilter();
		for (int i = 0; i < contentTypes.length; i++) {
			if (contentTypes[i].isAssociatedWith(fileName)) {
				return true;
			}
		}
		return false;
	}
	/**
	 * Determines if the extension matches observed extensions
	 * 
	 * @@param extension
	 *            Extension to be matched
	 * @@return true if the extension matches observed extensions
	 */
	private boolean matchesExtension(String extension) {
		String[] extensions = getExtensionFilter();
		for (int i = 0; i < extensions.length; i++) {
			if (extensions[i].equals(extension)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Get the file filter.
	 * 
	 * @@return the file filter.
	 */
	private IFile getFileFilter() {
		assert (filterType == FileObserverFilterType.FILE);
		return (IFile) filter;
	}

	/**
	 * Get the folder filter.
	 * 
	 * @@return the folder filter.
	 */
	private IFolder getFolderFilter() {
		assert (filterType == FileObserverFilterType.FOLDER);
		return (IFolder) filter;
	}

	/**
	 * Get the file extension filter.
	 * 
	 * @@return the file extension array filter.
	 */
	private String[] getExtensionFilter() {
		assert (filterType == FileObserverFilterType.EXTENSION);
		return (String[]) filter;
	}

	/**
	 * Get the content type filter.
	 * 
	 * @@return the content type array filter.
	 */
	private IContentType[] getContentTypeFilter() {
		assert (filterType == FileObserverFilterType.CONTENT_TYPE);
		return (IContentType[]) filter;
	}

	/**
	 * Get the file observer filter type.
	 * 
	 * @@return the file observer filter type.
	 */
	private FileObserverFilterType getFilterType() {
		return filterType;
	}

	/**
	 * Set the filter.
	 * 
	 * @@param object
	 *            the filter.
	 */
	private void setFilter(Object object) {
		filter = object;
	}

	/**
	 * Set the file observer filter type.
	 * 
	 * @@param type
	 *            the file observer filter type.
	 */
	private void setFilterType(FileObserverFilterType type) {
		filterType = type;
	}

	/**
	 * Get the path for a resource. In the case of a moved or deleted resource,
	 * resource.getLocation() returns null since it does not exist in the
	 * workspace. The workaround is below.
	 * 
	 * @@param resource
	 *            the resource.
	 * @@return the path for a resource.
	 */
	private String getAbsolutePath(IResource resource) {
		if (resource.getLocationURI() == null) {
			return resource.getFullPath().toString();
		} else {
			return resource.getLocationURI().toString();
		}
	}
}@


1.5
log
@[227658] gmf-head cvogt 080509 Update file observer to support resource links to non local file system resources
@
text
@d166 1
a166 1
			&& getFileFilter().getFullPath().equals(path.toString())) {
@


1.5.2.1
log
@[247364] gmf_R2_1_maintenance ahunter 081022 Error in FileObserverFilter#matches
@
text
@d166 1
a166 1
			&& getFileFilter().getFullPath().equals(path)) {
@


1.4
log
@gmf_head ahunter 061003 Merge 1.0.1 Runtime to HEAD 2.0
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
a16 1
import org.eclipse.core.resources.ResourcesPlugin;
d145 2
a146 2
			String FileExtension = resource.getFullPath().getFileExtension();
			if (matchesExtension(FileExtension)) {
d166 1
a166 1
			&& getAbsolutePath(getFileFilter()).equals(path.toOSString())) {
d170 1
a170 1
				&& getAbsolutePath(getFolderFilter()).startsWith(path.toOSString())) {
d174 1
a174 1
				&& matchesContentType(path.toFile().getName())) {
d296 2
a297 4
		if (resource.getLocation() == null) {
			IPath root = ResourcesPlugin.getWorkspace().getRoot().getLocation();
			IPath path = root.append(resource.getFullPath());
			return path.toOSString();
d299 1
a299 1
			return resource.getLocation().toOSString();
@


1.3
log
@[117778] gmf_head ahunter 060524 IFileChangeManager does not support filtering of Resource Change Events based on Content Type
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
@


1.3.2.1
log
@[153901] gmf_R1_0_maintenance tmacdoug 060913 Sweep copyright files for anything changed in 2006
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d19 1
d69 16
d134 10
a143 5
			&& resource instanceof IFile
			&& getAbsolutePath(resource).startsWith(
				getAbsolutePath(getFolderFilter()))) {
			return true;
		}
d171 7
a177 3
			&& getAbsolutePath(getFolderFilter()).startsWith(path.toOSString())) {
			return true;
		}
d186 16
d249 10
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2003.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

