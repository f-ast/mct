head	1.7;
access;
symbols
	v20081023-2107:1.7
	v20081022-1925:1.7
	v20081022-1104:1.7
	v20081020-0700:1.7
	v20080722-1827:1.7
	R2_1_maintenance:1.7.0.2
	Root_R2_1_maintenance:1.7
	R2_1_0:1.7
	v20080512-1200:1.7
	v20080503-1740:1.7
	v20080501-1739:1.7
	v20080425-1959:1.7
	v20080407-2250:1.7
	v20080222-1200:1.7
	v20080215-1500:1.7
	v20071003-0000:1.6
	v20070921-0000:1.6
	v20070915-0000:1.6
	v20070809-0000:1.6
	R2_0_maintenance:1.6.0.2
	R2_0:1.6
	R4_20:1.6
	RC3_20:1.6
	v20070601-1400:1.6
	v20070504-1000:1.6
	v20070330-1300:1.6
	v20070208-1800:1.6
	M4_20:1.6
	v20061218-1200:1.6
	v20061214-0000:1.6
	M3_20:1.6
	v20061117-0800:1.6
	v20061020-1000:1.5.2.2
	v20061013-1330:1.5
	v20061012-1100:1.5.2.1
	v20060925-1700:1.5
	v20060919-0800:1.5
	M1_20:1.5
	v20060824-1600:1.5
	v20060803-1200:1.5
	v20060728-0500:1.5
	v20060721-1130:1.5
	v20060713-1700:1.5
	R1_0_maintenance:1.5.0.2
	R1_0:1.5
	v20060627-1200:1.5
	v20060616-1200:1.5
	v20060531-1730:1.5
	v20060526-1200:1.5
	I20060424-0500:1.5
	I20060424-0300:1.5
	M6_10:1.5
	I20060407-1200:1.5
	I20060331-1000:1.5
	I20060324-0300:1.5
	I20060317-1300:1.5
	I20060317-1200:1.5
	I20060316-1300:1.5
	I20060309-1300:1.5
	M5_10:1.5
	S20060303-1600:1.5
	I20060227-1730:1.5
	I20060216-1945:1.5
	I20060210-1715:1.5
	I20060209-1815:1.5
	I20060203-0830:1.5
	I20060129-1145:1.5
	I20060127-0900:1.5
	I20060120-1530:1.5
	I20060113-1700:1.5
	M4_10:1.5
	I20060107-1100:1.5
	I20060105-1630:1.5
	I20051230-1230:1.5
	I20051223-1100:1.5
	I20051217-0925:1.5
	I20051124-2000:1.5
	M3_10:1.5
	I20051118-1245:1.5
	I20051111-1800:1.4
	I20051106-0900:1.4
	v20051030:1.4;
locks; strict;
comment	@# @;


1.7
date	2008.02.08.21.42.40;	author ldamus;	state Exp;
branches;
next	1.6;
commitid	38e747acccd04567;

1.6
date	2006.10.13.19.53.22;	author ahunter;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.14.21.05.32;	author ahunter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2005.10.28.19.58.48;	author ahunter;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.28.17.50.33;	author ahunter;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.12.21.23.49;	author sshaw;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.30.03.16.20;	author sshaw;	state Exp;
branches;
next	;

1.5.2.1
date	2006.10.05.21.44.47;	author ahunter;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2006.10.13.19.28.44;	author ahunter;	state Exp;
branches;
next	;


desc
@@


1.7
log
@[212178] gmf_head jbruck 080208 GMF validation enhancements
@
text
@/******************************************************************************
 * Copyright (c) 2002, 2008 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.gmf.runtime.common.ui.resources;

import java.io.File;
import java.sql.Timestamp;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFileModificationValidator;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.gmf.runtime.common.ui.internal.CommonUIPlugin;
import org.eclipse.gmf.runtime.common.ui.internal.l10n.CommonUIMessages;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.osgi.util.NLS;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.team.core.RepositoryProvider;
import org.eclipse.ui.PlatformUI;

/**
 * A wrapper around the Eclipse IFileModificationValidator.
 * 
 * @@author Anthony Hunter <a
 *         href="mailto:ahunter@@rational.com">ahunter@@rational.com </a>
 */
public class FileModificationValidator {

	/**
	 * singleton instance of this class
	 */
	private static FileModificationValidator INSTANCE = new FileModificationValidator();

	/**
	 * get the singleton instance of this class
	 * 
	 * @@return singleton instance of the FileModificationValidator class
	 */
	public static FileModificationValidator getInstance() {
		return INSTANCE;
	}

	/**
	 * Private constructor for the singleton instance of this class.
	 */
	private FileModificationValidator() {
		super();
	}

	/**
	 * Validates that the given files can be modified using the Team
	 * validateEdit support.
	 * 
	 * @@param files
	 *            files that are to be modified; these files must all exist in
	 *            the workspace.
	 * @@param modificationReason
	 *            a String describing the reason for modifying the file, usually
	 *            the command text.
	 * @@return true if it is OK to edit the files.
	 * @@see org.eclipse.core.resources.IFileModificationValidator#validateEdit
	 */
	public boolean okToEdit(final IFile[] files, final String modificationReason) {
        return okToEdit(files, modificationReason, null);
    }

    /**
     * Validates that the given files can be modified using the Team
     * validateEdit support.
     * 
     * @@param files
     *            files that are to be modified; these files must all exist in
     *            the workspace.
     * @@param modificationReason
     *            a String describing the reason for modifying the file, usually
     *            the command text.
     * @@param shell
     *            UI context for UI that could be presented to the user to
     *            determine whether the file may be edited.
     * @@return true if it is OK to edit the files.
     * @@see org.eclipse.core.resources.IFileModificationValidator#validateEdit
     */
    public boolean okToEdit(final IFile[] files,
			final String modificationReason, final Shell shell) {

		final IStatus fileStatus = validateEdit(files, shell);
		
		if (!fileStatus.isOK()) {
			// Similar to the DefaultUIFileModificationValidator we check if the shell is not null before 
			// displaying messages.
			if(shell != null){
				PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
					public void run() {
						MessageDialog
								.openError(
										shell,
										NLS.bind(CommonUIMessages.FileModificationValidator_EditProblemDialogTitle,
												modificationReason),
										NLS.bind(CommonUIMessages.FileModificationValidator_EditProblemDialogMessage,
												modificationReason,
												fileStatus.getMessage()));
					}
				});
			}
			return false;
		}
		return true;
	}

	/**
	 * Validates that the given file can be saved using the Team validateSave
	 * support.
	 * 
	 * @@param file
	 *            the file that is to be saved; this file must exist in the
	 *            workspace.
	 * @@return true if it is OK to save the file.
	 * @@see org.eclipse.core.resources.IFileModificationValidator#validateSave
	 */
	public boolean okToSave(IFile file) {
		IStatus status = null;
		RepositoryProvider provider = RepositoryProvider.getProvider(file
			.getProject());

		IFileModificationValidator validator = null;

		// if no provider or no validator use the default validator
		if (provider != null) {
			validator = provider.getFileModificationValidator();
		}

		if (validator == null) {
			status = getDefaultStatus(file);
		} else {
			status = validator.validateSave(file);
		}

		if (status.isOK()) {
			return true;
		} else {
			MessageDialog
				.openError(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow()
						.getShell(),
					CommonUIMessages.FileModificationValidator_SaveProblemDialogTitle,
					NLS
						.bind(
							CommonUIMessages.FileModificationValidator_SaveProblemDialogMessage,
							status.getMessage(), status.getMessage()));
			return false;
		}
	}

	/**
	 * return the default status for the file.
	 * 
	 * @@param file
	 *            the <code>IFile</code> that is to be validated.
	 * @@return IStatus OK, otherwise ERROR if the file is read-only.
	 */
	private IStatus getDefaultStatus(IFile file) {
		if (file.isReadOnly()) {
			String message = NLS
				.bind(
					CommonUIMessages.FileModificationValidator_FileIsReadOnlyErrorMessage,
					file.getFullPath().toString());
			return new Status(Status.ERROR, CommonUIPlugin.getPluginId(),
				Status.ERROR, message, null);
		} else {
			return new Status(Status.OK, CommonUIPlugin.getPluginId(),
				Status.OK, CommonUIMessages.FileModificationValidator_OK, null);
		}
	}

	/**
	 * Validates changes to the specified array of IFiles using the specified shell as a UI context.
	 * This code delegates the bulk of its processing to the {@@link IWorkspace#validateEdit(IFile[], Object)
	 * method, but additionally checks to see if the specified IFiles are out of synchronization with
	 * the filesystem, and if so, returns an error status.
	 * 
	 * @@param files the array of files for which edit validation is requested
	 * @@param shell a UI context (SWT shell) for the validation.  Typed as object to avoid SWT dependency.
	 * @@return IStatus, {@@link IStatus#OK} if edit of the specified files may proceed, {@@link IStatus#ERROR}
	 * or {@@link IStatus#CANCEL} otherwise.
	 */
	public IStatus validateEdit(IFile[] files, Object shell) {
		IStatus status = Status.OK_STATUS;
		if (files == null || files.length == 0) {
			return status;
		}
		Set<IFile> unsynchedFiles = new HashSet<IFile>();
		Map<IFile, ModificationStamp> filesToModificationStamps = new HashMap<IFile, ModificationStamp>();

		for (int i = 0; i < files.length; i++) {
			IFile file = files[i];
			filesToModificationStamps.put(file, new ModificationStamp(file));
			boolean inSync = file.isSynchronized(IResource.DEPTH_ZERO);
			if (!inSync) {
				unsynchedFiles.add(file);
			}
		}
		if (!unsynchedFiles.isEmpty()) {
			status = buildOutOfSyncStatus(unsynchedFiles);
		}

		if (status.isOK()) {
			status = ResourcesPlugin.getWorkspace().validateEdit(files, shell);

			for (Map.Entry<IFile, ModificationStamp> entry : filesToModificationStamps.entrySet()) {
				IFile file = entry.getKey();
				ModificationStamp stamp = entry.getValue();
				if (stamp.hasFileChanged()) {
					unsynchedFiles.add(file);
				}
			}
			if (!unsynchedFiles.isEmpty()) {
				status = buildOutOfSyncStatus(unsynchedFiles);
			}

		}
		return status;
	}

	/**
	 *  Helper method to create a status for out of sync files.
	 *  
	 * @@param unsynchedFiles Files that may be out of sync.
	 * @@return A status for out of sync files.
	 */
	private IStatus buildOutOfSyncStatus(Set<IFile> unsynchedFiles) {
		StringBuffer buf = new StringBuffer(
				CommonUIMessages.FileModificationValidator_OutOfSyncMessage);
		buf.append("\n"); //$NON-NLS-1$
		for (Iterator<IFile> unsynched = unsynchedFiles.iterator(); unsynched
				.hasNext();) {
			IFile file = unsynched.next();
			buf.append(file.getFullPath().toString());
			buf.append("\n"); //$NON-NLS-1$
		}
		return new Status(IStatus.ERROR, CommonUIPlugin.getPluginId(), 0, buf
				.toString(), null);
	}

	private static class ModificationStamp {

		/**
		 * The file that the modification stamp applies to.
		 */
		private IFile file;
		/**
		 * Last modified date and time of the file
		 */
		private Timestamp lastModified = null;
		/**
		 * The file's length.
		 */
		private long fileLength = 0L;

		public ModificationStamp(IFile file) {
			assert file != null;
			this.file = file;
			IPath path = file.getLocation();
			if (path != null) {
				File ioFile = path.toFile();
				if (ioFile != null) {
					// new timestamp
					lastModified = new Timestamp(ioFile.lastModified());
					lastModified.setNanos(0);
					fileLength = ioFile.length();
				} else {
					lastModified = new Timestamp(file.getModificationStamp());
					lastModified.setNanos(0);
				}
			} else {
				lastModified = new Timestamp(file.getModificationStamp());
				lastModified.setNanos(0);
			}

		}

		public Timestamp getLastModified() {
			return lastModified;
		}

		public long getFileLength() {
			return fileLength;
		}

		public IFile getFile() {
			return file;
		}

		/**
		 * Used in determining if two timestamps are equivalent 
		 */
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			} else if (obj instanceof ModificationStamp) {
				ModificationStamp stamp = (ModificationStamp) obj;
				return file.equals(stamp.getFile())
						&& fileLength == stamp.getFileLength()
						&& lastModified.equals(stamp.getLastModified());
			}

			return false;
		}

		public int hashCode() {
			return file.hashCode() + lastModified.hashCode()
					+ (int) (fileLength ^ (fileLength >>> 32));

		}

		/**
		 * Determines if the file has changed.
		 * 
		 * @@return true if the file has changed.
		 */
		public boolean hasFileChanged() {
			IPath path = file.getLocation();
			if (path == null) {
				return false;
			}
			File ioFile = path.toFile();
			if (ioFile == null) {
				return false;
			}

			// new timestamp
			Timestamp newTimestamp = new Timestamp(ioFile.lastModified());
			newTimestamp.setNanos(0);

			return !(lastModified.getTime() == newTimestamp.getTime() && fileLength == ioFile
					.length());
		}
	}
	    
}@


1.6
log
@[160385] gmf_head ahunter 061013 Merge 1.0.2 fix to HEAD
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d14 8
d24 2
d27 1
a33 1
import org.eclipse.swt.widgets.Display;
d100 2
a101 5
    public boolean okToEdit(final IFile[] files, final String modificationReason, Shell shell) {
		if (PlatformUI.getWorkbench().getActiveWorkbenchWindow() != null && Display.getCurrent() != null) {
			shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow()
				.getShell();
		}
d103 19
a121 22
		final IStatus status = ResourcesPlugin.getWorkspace().validateEdit(
			files, shell);
		if (status.isOK()) {
			return true;
		} else {
			PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {

				public void run() {
					MessageDialog
						.openError(
							PlatformUI.getWorkbench()
								.getActiveWorkbenchWindow().getShell(),
							NLS
								.bind(
									CommonUIMessages.FileModificationValidator_EditProblemDialogTitle,
									modificationReason),
							NLS
								.bind(
									CommonUIMessages.FileModificationValidator_EditProblemDialogMessage,
									modificationReason, status.getMessage()));
				}
			});
d124 1
d191 165
@


1.5
log
@Bugzilla Bug 112829 gmf_head ahunter 051114 Progress Monitor Dialog usage in GMF: Changes to FileModificationValidator.
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2003 IBM Corporation and others.
d71 20
a90 1
		Shell shell = null;
d161 1
a161 1
							status.getMessage()));
@


1.5.2.1
log
@[158802] gmf_R1_0_maintenance ahunter 061005 Wrong {parameter} in CommonUIMessages.properties string
@
text
@d142 1
a142 1
							status.getMessage(), status.getMessage()));
@


1.5.2.2
log
@[160385] gmf_R1_0_maintenance wdiu 061013 Validation for file modification is missing the UI context
@
text
@d2 1
a2 1
 * Copyright (c) 2002, 2006 IBM Corporation and others.
d71 1
a71 20
        return okToEdit(files, modificationReason, null);
    }

    /**
     * Validates that the given files can be modified using the Team
     * validateEdit support.
     * 
     * @@param files
     *            files that are to be modified; these files must all exist in
     *            the workspace.
     * @@param modificationReason
     *            a String describing the reason for modifying the file, usually
     *            the command text.
     * @@param shell
     *            UI context for UI that could be presented to the user to
     *            determine whether the file may be edited.
     * @@return true if it is OK to edit the files.
     * @@see org.eclipse.core.resources.IFileModificationValidator#validateEdit
     */
    public boolean okToEdit(final IFile[] files, final String modificationReason, Shell shell) {
@


1.4
log
@Bugzilla Bug 109445 gmf_head etworkow 051028 New Eclipse Resources Bundles Should Be Used
@
text
@a13 2
import java.text.MessageFormat;

d22 1
d24 1
d71 5
a75 1
		final boolean result[] = new boolean[] {false};
d77 6
a82 10
		PlatformUI.getWorkbench().getDisplay().syncExec(new Runnable() {

			public void run() {
				IStatus status = ResourcesPlugin.getWorkspace().validateEdit(
					files,
					PlatformUI.getWorkbench().getActiveWorkbenchWindow()
						.getShell());
				if (status.isOK()) {
					result[0] = true;
				} else {
d84 1
d89 2
a90 2
							MessageFormat
								.format(
d92 5
a96 13
									new Object[] {modificationReason}),
							MessageFormat
								.format(
									CommonUIMessages.FileModificationValidator_EditProblemDialogMessage_part1,
									new Object[] {modificationReason})
								+ "\n\n" //$NON-NLS-1$
								+ CommonUIMessages.FileModificationValidator_EditProblemDialogMessage_part2
								+ "\n" //$NON-NLS-1$
								+ MessageFormat
									.format(
										CommonUIMessages.FileModificationValidator_EditProblemDialogMessage_part3,
										new Object[] {status.getMessage()}));
					result[0] = false;
d98 3
a100 3
			}
		});
		return result[0];
d136 2
a137 1
					Display.getCurrent().getActiveShell(),
d139 4
a142 8
					CommonUIMessages.FileModificationValidator_SaveProblemDialogMessage_part1
						+ "\n\n" //$NON-NLS-1$
						+ CommonUIMessages.FileModificationValidator_SaveProblemDialogMessage_part2
						+ "\n" //$NON-NLS-1$
						+ MessageFormat
							.format(
								CommonUIMessages.FileModificationValidator_SaveProblemDialogMessage_part3,
								new Object[] {status.getMessage()}));
d156 2
a157 2
			String message = MessageFormat
				.format(
d159 1
a159 1
					new Object[] {file.getFullPath().toString()});
@


1.3
log
@Bugzilla Bug 112829 gmf_head ahunter 051028 Progress Monitor Dialog usage in GMF
@
text
@d21 2
a27 3
import org.eclipse.gmf.runtime.common.ui.internal.CommonUIPlugin;
import org.eclipse.gmf.runtime.common.ui.internal.l10n.ResourceManager;

a36 70
	 * IStatus is fileIsReadOnly
	 */
	private static String FILE_IS_READ_ONLY = ResourceManager.getInstance()
		.getString("FileModificationValidator.FileIsReadOnlyErrorMessage"); //$NON-NLS-1$

	/**
	 * IStatus is ok
	 */
	private static String OK = ResourceManager.getInstance().getString(
		"FileModificationValidator.OK"); //$NON-NLS-1$

	/**
	 * title for edit problems dialog
	 */
	private String editProblemDialogTitle = ResourceManager.getInstance()
		.getString("FileModificationValidator.EditProblemDialogTitle"); //$NON-NLS-1$

	/**
	 * part 1 of message for edit problems dialog
	 */
	// Fragmenting the following message so as to not use hard return characters
	// ("\n") in translatable strings
	private String editProblemDialogMessage_part1 = ResourceManager
		.getInstance().getString(
			"FileModificationValidator.EditProblemDialogMessage.part1"); //$NON-NLS-1$

	/**
	 * part 2 of message for edit problems dialog
	 */
	private String editProblemDialogMessage_part2 = ResourceManager
		.getInstance().getString(
			"FileModificationValidator.EditProblemDialogMessage.part2"); //$NON-NLS-1$

	/**
	 * part 3 of message for edit problems dialog
	 */
	private String editProblemDialogMessage_part3 = ResourceManager
		.getInstance().getString(
			"FileModificationValidator.EditProblemDialogMessage.part3"); //$NON-NLS-1$

	/**
	 * title for save problems dialog
	 */
	private String saveProblemDialogTitle = ResourceManager.getInstance()
		.getString("FileModificationValidator.SaveProblemDialogTitle"); //$NON-NLS-1$

	/**
	 * part 1 of message for save problems dialog
	 */
	// Fragmenting the following message so as to not use hard return characters
	// ("\n") in translatable strings
	private String saveProblemDialogMessage_part1 = ResourceManager
		.getInstance().getString(
			"FileModificationValidator.SaveProblemDialogMessage.part1"); //$NON-NLS-1$

	/**
	 * part 2 of message for save problems dialog
	 */
	private String saveProblemDialogMessage_part2 = ResourceManager
		.getInstance().getString(
			"FileModificationValidator.SaveProblemDialogMessage.part2"); //$NON-NLS-1$

	/**
	 * part 3 of message for save problems dialog
	 */
	private String saveProblemDialogMessage_part3 = ResourceManager
		.getInstance().getString(
			"FileModificationValidator.SaveProblemDialogMessage.part3"); //$NON-NLS-1$

	/**
d84 19
a102 11
					MessageDialog.openError(PlatformUI.getWorkbench()
						.getActiveWorkbenchWindow().getShell(), MessageFormat
						.format(editProblemDialogTitle,
							new Object[] {modificationReason}), MessageFormat
						.format(editProblemDialogMessage_part1,
							new Object[] {modificationReason})
						+ "\n\n" //$NON-NLS-1$
						+ editProblemDialogMessage_part2
						+ "\n" //$NON-NLS-1$
						+ MessageFormat.format(editProblemDialogMessage_part3,
							new Object[] {status.getMessage()}));
d141 12
a152 7
			MessageDialog.openError(Display.getCurrent().getActiveShell(),
				saveProblemDialogTitle, saveProblemDialogMessage_part1
					+ "\n\n" //$NON-NLS-1$
					+ saveProblemDialogMessage_part2
					+ "\n" //$NON-NLS-1$
					+ MessageFormat.format(saveProblemDialogMessage_part3,
						new Object[] {status.getMessage()}));
d166 4
a169 2
			String message = MessageFormat.format(FILE_IS_READ_ONLY,
				new Object[] {file.getFullPath().toString()});
d174 1
a174 1
				Status.OK, OK, null);
@


1.2
log
@Bugzilla 108765 gmf_head tmacdoug 050912 - Update copyrights of GMF and EMFT plugins content to Eclipse copyright (EPL)
@
text
@d24 1
d114 1
d141 30
a170 18
	public boolean okToEdit(IFile[] files, String modificationReason) {
		IStatus status = ResourcesPlugin.getWorkspace().validateEdit(files,
			Display.getCurrent().getActiveShell());
		if (status.isOK()) {
			return true;
		} else {
			MessageDialog.openError(Display.getCurrent().getActiveShell(),
				MessageFormat.format(editProblemDialogTitle,
					new Object[] {modificationReason}), MessageFormat.format(
					editProblemDialogMessage_part1,
					new Object[] {modificationReason})
					+ "\n\n" //$NON-NLS-1$
					+ editProblemDialogMessage_part2
					+ "\n" //$NON-NLS-1$
					+ MessageFormat.format(editProblemDialogMessage_part3,
						new Object[] {status.getMessage()}));
			return false;
		}
d190 1
a190 1
		//if no provider or no validator use the default validator
@


1.1
log
@Refactoring of the IBM gmf runtime contribution to the org.eclipse.gmf.runtime namespace.
@
text
@d1 11
a11 9
/*
 *+------------------------------------------------------------------------+
 *| Licensed Materials - Property of IBM                                   |
 *| (C) Copyright IBM Corp. 2002, 2003.  All Rights Reserved.              |
 *|                                                                        |
 *| US Government Users Restricted Rights - Use, duplication or disclosure |
 *| restricted by GSA ADP Schedule Contract with IBM Corp.                 |
 *+------------------------------------------------------------------------+
 */
@

