head	1.1;
access;
symbols
	v20080813-1520:1.1
	v20080812-2100:1.1
	ocl_qvt:1.1.0.6
	Root_ocl_qvt:1.1
	v20080722-1827:1.1
	v20080716-1600:1.1
	v20080716-1642:1.1
	R2_1_maintenance:1.1.0.4
	Root_R2_1_maintenance:1.1
	R2_1_0:1.1
	v20080425-1959:1.1
	v20071108-0000:1.1
	v20070809-0000:1.1
	R2_0_maintenance:1.1.0.2
	R2_0:1.1
	R4_20:1.1
	RC3_20:1.1
	v20070601-1400:1.1
	v20070518-1300:1.1
	v20070330-1300:1.1
	v20070228-2000:1.1
	M4_20:1.1
	M3_20:1.1;
locks; strict;
comment	@# @;


1.1
date	2006.10.18.20.33.08;	author atikhomirov;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2008.08.19.15.56.03;	author atikhomirov;	state Exp;
branches;
next	;
commitid	746548aaed124567;


desc
@@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2006 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.expression.codeassist;

import lpg.lpgjavaruntime.IToken;
import lpg.lpgjavaruntime.PrsStream;

import org.eclipse.gmf.internal.xpand.expression.parser.ExpressionLexer;
import org.eclipse.gmf.internal.xpand.expression.parser.ExpressionParsersym;

public class ReverseScanner {

	private String internal;

	private int offset;

	public ReverseScanner(final String s) {
		internal = s;
		offset = internal.length();
	}

	public int getOffset() {
		return offset;
	}

	public IToken previousToken() {

		int os = offset - 1;
		if (os < 0) {
			return null;
		}
		IToken t = null;
		while (os >= 0) {
			final String temp = internal.substring(os--, offset);
			if (isEndOfString(temp)) {
				final String wholeString = getString(internal.substring(0, offset));
				offset = internal.substring(0, offset).lastIndexOf(wholeString);
				return lexToTokenStream(wholeString).getTokenAt(1);
			} else if (temp.trim().length() > 0) {
				final PrsStream tokenStream = lexToTokenStream(temp);
				final IToken tempToken = tokenStream.getTokenAt(1);
				if (tempToken.getKind() == 0) { //bad token
					offset = os + 2;
					return t;
				}
				if ((t == null) || (tempToken.toString().length() > t.toString().length())) {
					t = tempToken;
				} else {
					offset = os + 2;
					return t;
				}
			}
		}
		offset = 0;
		return t;

	}

	protected String getString(final String string) {
		final String t = string.trim();
		if (t.length() > 0) {
			if (t.endsWith("\"")) {
				int i = t.substring(0, t.length() - 1).lastIndexOf('"');
				while ((i > 0) && (t.charAt(i - 1) == '\\')) {
					i = t.substring(0, t.length() - i).lastIndexOf('"');
				}
				return string.substring(i);
			} else if (t.endsWith("'")) {
				int i = t.substring(0, t.length() - 1).lastIndexOf('\'');
				while ((i > 0) && (t.charAt(i - 1) == '\\')) {
					i = t.substring(0, i).lastIndexOf('\'');
				}
				if (i >= 0) {
					return t.substring(i);
				}
			}
		}
		return null;
	}

	private boolean isEndOfString(final String temp) {
		final String t = temp.trim();
		return (t.length() > 0) && ((t.charAt(t.length() - 1) == '"') || (t.charAt(t.length() - 1) == '\''));
	}

	public IToken nextToken() {
		final String temp = internal.substring(offset);
		final IToken tempToken = lexToTokenStream(temp).getTokenAt(1);
		if (tempToken.getKind() == ExpressionParsersym.TK_EOF_TOKEN) {
			return null;
		}
		final String tokenText = tempToken.toString();
		offset = temp.indexOf(tokenText) + tokenText.length() + offset;
		return tempToken;
	}

	private static PrsStream lexToTokenStream(String sequence) {
		ExpressionLexer scanner = new ExpressionLexer(sequence.toCharArray(), "nofile");
		;
		scanner.lexer(new PrsStream(scanner));
		// there are at least bad token in the head and eof in the tail
		assert scanner.getPrsStream().getSize() >= 2;
		return scanner.getPrsStream();
	}
}
@


1.1.6.1
log
@[243154] Use OCL instead of home-grown expression language - editor and its tests made compilable
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
d20 2
a21 2
import org.eclipse.gmf.internal.xpand.parser.XpandLexer;
import org.eclipse.gmf.internal.xpand.parser.XpandParsersym;
a22 1
@@SuppressWarnings("restriction")
d101 1
a101 1
		if (tempToken.getKind() == XpandParsersym.TK_EOF_TOKEN) {
d110 2
a111 1
		XpandLexer scanner = new XpandLexer(sequence.toCharArray(), "nofile");
@

