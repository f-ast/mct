head	1.3;
access;
symbols
	v20080813-1520:1.3
	v20080812-2100:1.3
	ocl_qvt:1.3.0.6
	Root_ocl_qvt:1.3
	v20080722-1827:1.3
	v20080716-1600:1.3
	v20080716-1642:1.3
	R2_1_maintenance:1.3.0.4
	Root_R2_1_maintenance:1.3
	R2_1_0:1.3
	v20080425-1959:1.3
	v20071108-0000:1.3
	v20070809-0000:1.3
	R2_0_maintenance:1.3.0.2
	R2_0:1.3
	R4_20:1.3
	RC3_20:1.3
	v20070601-1400:1.3
	v20070518-1300:1.3
	v20070330-1300:1.3
	v20070228-2000:1.3
	M4_20:1.3
	M3_20:1.3;
locks; strict;
comment	@# @;


1.3
date	2006.11.02.18.30.46;	author atikhomirov;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2006.10.23.16.13.12;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.08;	author atikhomirov;	state Exp;
branches;
next	;

1.3.6.1
date	2008.07.24.16.21.37;	author ashatalin;	state Exp;
branches;
next	1.3.6.2;
commitid	7c594888ac104567;

1.3.6.2
date	2008.08.19.15.56.03;	author atikhomirov;	state Exp;
branches;
next	1.3.6.3;
commitid	746548aaed124567;

1.3.6.3
date	2008.08.19.17.25.20;	author atikhomirov;	state Exp;
branches;
next	;
commitid	37f348ab01ff4567;


desc
@@


1.3
log
@changed ids not to clash with oaw plugins (just in case), get rid of nature nobody seemed to be really using
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2006 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.expression.codeassist;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lpg.lpgjavaruntime.IToken;

import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
import org.eclipse.gmf.internal.xpand.codeassist.LazyVar;
import org.eclipse.gmf.internal.xpand.expression.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.expression.ExecutionContext;
import org.eclipse.gmf.internal.xpand.expression.ExpressionFacade;
import org.eclipse.gmf.internal.xpand.expression.Variable;
import org.eclipse.gmf.internal.xpand.expression.parser.ExpressionParsersym;
import org.eclipse.gmf.internal.xpand.xtend.ast.Extension;
import org.eclipse.jface.text.contentassist.ICompletionProposal;

public class ExpressionProposalComputer implements ProposalComputer {

	private final static Set<Integer> operators = new HashSet<Integer>();
	static {
		operators.add(ExpressionParsersym.TK_AND);
		operators.add(ExpressionParsersym.TK_DIV);
		operators.add(ExpressionParsersym.TK_DOT);
		operators.add(ExpressionParsersym.TK_EQ);
		operators.add(ExpressionParsersym.TK_GE);
		operators.add(ExpressionParsersym.TK_GT);
		operators.add(ExpressionParsersym.TK_LE);
		operators.add(ExpressionParsersym.TK_LT);
		operators.add(ExpressionParsersym.TK_MINUS);
		operators.add(ExpressionParsersym.TK_MULTI);
		operators.add(ExpressionParsersym.TK_NE);
		operators.add(ExpressionParsersym.TK_NOT);
		operators.add(ExpressionParsersym.TK_OR);
		operators.add(ExpressionParsersym.TK_PLUS);
	}

	private final static Set<Integer> stopper = new HashSet<Integer>();
	static {
		stopper.add(ExpressionParsersym.TK_LPAREN);
		stopper.add(ExpressionParsersym.TK_COLON);
		stopper.add(ExpressionParsersym.TK_QUESTION_MARK);
		stopper.add(ExpressionParsersym.TK_BAR);
		stopper.add(ExpressionParsersym.TK_LCURLY);
		stopper.add(ExpressionParsersym.TK_COMMA);
	}

	private final static Set<Integer> methodNames = new HashSet<Integer>();
	static {
		methodNames.add(ExpressionParsersym.TK_IDENT);
		methodNames.add(ExpressionParsersym.TK_collect);
		methodNames.add(ExpressionParsersym.TK_exists);
		methodNames.add(ExpressionParsersym.TK_notExists);
		methodNames.add(ExpressionParsersym.TK_forAll);
		methodNames.add(ExpressionParsersym.TK_reject);
		methodNames.add(ExpressionParsersym.TK_select);
		methodNames.add(ExpressionParsersym.TK_typeSelect);
	}

	private final static Set<Integer> operands = new HashSet<Integer>();
	static {
		operands.add(ExpressionParsersym.TK_IDENT);
		operands.add(ExpressionParsersym.TK_collect);
		operands.add(ExpressionParsersym.TK_exists);
		operands.add(ExpressionParsersym.TK_notExists);
		operands.add(ExpressionParsersym.TK_false);
		operands.add(ExpressionParsersym.TK_forAll);
		operands.add(ExpressionParsersym.TK_null);
		operands.add(ExpressionParsersym.TK_reject);
		operands.add(ExpressionParsersym.TK_select);
		operands.add(ExpressionParsersym.TK_true);
		operands.add(ExpressionParsersym.TK_typeSelect);
		operands.add(ExpressionParsersym.TK_INT_CONST);
		operands.add(ExpressionParsersym.TK_REAL_CONST);
		operands.add(ExpressionParsersym.TK_STRING);
	}

	private final static Map<Integer, Integer> blockTokens = new HashMap<Integer, Integer>();

	static {
		blockTokens.put(ExpressionParsersym.TK_LPAREN, ExpressionParsersym.TK_RPAREN);
		blockTokens.put(ExpressionParsersym.TK_LCURLY, ExpressionParsersym.TK_RCURLY);
	}

	private ExecutionContext executionContext;

	private ProposalFactory proposalFactory;

	public ExpressionProposalComputer() {
	}

	/**
	 * @@param ctx
	 * @@return
	 */
	public List<ICompletionProposal> computeProposals(final String txt, final ExecutionContext context, final ProposalFactory factory) {
		this.proposalFactory = factory;
		try {
			final String[] s = computePrefixAndTargetExpression(txt);
			final String prefix = s[0];
			final String expressionString = s[1];
			this.executionContext = computeExecutionContext(txt, context);
			final List<ICompletionProposal> proposals = new ArrayList<ICompletionProposal>();

			if ((prefix.length() > 0) && (expressionString == null)) {
				proposals.addAll(new TypeProposalComputer().computeProposals(txt, executionContext, factory));
			}

			EClassifier targetType = null;
			if (expressionString != null) {
				final Set<AnalysationIssue> issues = new HashSet<AnalysationIssue>();
				targetType = new ExpressionFacade(executionContext).analyze(expressionString, issues);
				if (targetType == null) {
					return Collections.emptyList();
				}
			}
			if (targetType == null) {
				// variables
				for (Variable v : executionContext.getVisibleVariables()) {
					String varName = v.getName();
					if (varName.toLowerCase().startsWith(prefix.toLowerCase())) {
						final Object o = executionContext.getVariable(varName).getValue();
						proposals.add(factory.createVariableProposal(varName, (EClassifier) o, prefix));
					}
				}
				// members and extensions on this
				final Variable v = executionContext.getVariable(ExecutionContext.IMPLICIT_VARIABLE);
				if (v != null) {
					targetType = (EClassifier) v.getValue();
					proposals.addAll(getAllMemberProposals(targetType, prefix));
				}

				final Set<? extends Extension> exts = executionContext.getAllExtensions();
				for (Extension extension : exts) {
					if (extension.getName().toLowerCase().startsWith(prefix.toLowerCase())) {
						proposals.add(factory.createExtensionProposal(extension, prefix));
					}
				}
			} else {
				// members and extensions on targetType
				proposals.addAll(getAllMemberProposals(targetType, prefix));
			}
			return proposals;
		} finally {
			proposalFactory = null;
			executionContext = null;
		}
	}

	private final static Pattern COL_OP = Pattern.compile("((select|collect|exists|notExists|reject|forEach)\\s*\\(\\s*(\\w+)\\s*\\|)|(\\()|(\\))");

	private final static Pattern LET = Pattern.compile(".*let\\s*(\\w+)\\s*=\\s*([^:]+):([^:]*)");

	protected final static ExecutionContext computeExecutionContext(final String txt, ExecutionContext ctx) {
		final Stack<LazyVar> vars = new Stack<LazyVar>();
		Matcher m = LET.matcher(txt);
		while (m.find()) {
			final LazyVar v = new LazyVar();
			v.name = m.group(1);
			v.forEach = false;
			v.expression = m.group(2).trim();
			vars.push(v);
		}
		m = COL_OP.matcher(txt);
		while (m.find()) {
			if (m.group(1) != null) {
				final String[] s = computePrefixAndTargetExpression(txt.substring(0, m.start()));
				final String expressionString = s[1];
				final LazyVar v = new LazyVar();
				v.name = m.group(3);
				v.forEach = true;
				v.expression = expressionString;
				vars.push(v);
			} else if (m.group(4) != null) {
				vars.push(null);
			} else if (m.group(5) != null) {
				vars.pop();
			} else {
				throw new IllegalStateException("Match:" + m.group());
			}
		}
		for (LazyVar v : vars) {
			if (v != null) {
				EClassifier targetType = null;
				final String expressionString = v.expression;
				if (expressionString == null) {
					final Variable var = ctx.getVariable(ExecutionContext.IMPLICIT_VARIABLE);
					if ((var != null) && (var.getValue() instanceof EClassifier)) {
						EClassifier value = (EClassifier) var.getValue();
						if (BuiltinMetaModel.isParameterizedType(value)) {
							targetType = BuiltinMetaModel.getInnerType(value);
						}
					}
				} else {
					targetType = new ExpressionFacade(ctx).analyze(expressionString, new HashSet<AnalysationIssue>());
					if (v.forEach) {
						if (BuiltinMetaModel.isParameterizedType(targetType)) {
							targetType = BuiltinMetaModel.getInnerType(targetType);
						} else {
							targetType = null; // XXX EJavaObject as in other
							// code snippets?
						}
					}
				}

				if (targetType != null) {
					ctx = ctx.cloneWithVariable(new Variable(v.name, targetType));
				}
			}
		}
		return ctx;
	}

	/**
	 * @@param targetType
	 * @@param prefix
	 * @@param ctx
	 * @@param factory
	 * @@return
	 */
	private List<ICompletionProposal> getAllMemberProposals(EClassifier targetType, final String prefix) {
		if (targetType == null) {
			return Collections.emptyList();
		}
		final List<ICompletionProposal> result = new ArrayList<ICompletionProposal>();

		result.addAll(internalGetAllMemberProposals(targetType, prefix, false));
		if (BuiltinMetaModel.isParameterizedType(targetType)) {
			result.addAll(getAllCollectionOperations(prefix, proposalFactory));
			targetType = BuiltinMetaModel.getInnerType(targetType);
			result.addAll(internalGetAllMemberProposals(targetType, prefix, true));
		}
		return result;
	}

	private List<ICompletionProposal> internalGetAllMemberProposals(EClassifier targetType, String prefix, boolean onCollection) {
		final List<ICompletionProposal> result = new LinkedList<ICompletionProposal>();
		final String prefixLowerCase = prefix.toLowerCase();
		for (EStructuralFeature f : BuiltinMetaModel.getAllFeatures(targetType)) {
			if (f.getName().toLowerCase().startsWith(prefixLowerCase)) {
				result.add(proposalFactory.createPropertyProposal(f, prefix, onCollection));
			}
		}
		for (EOperation op : BuiltinMetaModel.getAllOperation(targetType)) {
			if (op.getName().toLowerCase().startsWith(prefixLowerCase) && Character.isJavaIdentifierStart(op.getName().charAt(0))) {
				result.add(proposalFactory.createOperationProposal(op, prefix, onCollection));
			}
		}
		for (Extension e : executionContext.getAllExtensions()) {
			if (e.getName().toLowerCase().startsWith(prefixLowerCase) && (e.getParameterTypes().size() >= 1) && BuiltinMetaModel.isAssignableFrom(e.getParameterTypes().get(0), targetType)) {
				result.add(proposalFactory.createExtensionOnMemberPositionProposal(e, prefix, onCollection));
			}
		}
		return result;
	}

	// XXX could use ExpressionParsersym.orderedTerminalSymbols[TK_xx] to get
	// values like 'select', 'reject', etc
	private static List<ICompletionProposal> getAllCollectionOperations(final String prefix, final ProposalFactory f) {
		final List<ICompletionProposal> result = new ArrayList<ICompletionProposal>();
		final String marked = "expression-with-e";

		String s = "select(e|" + marked + ")";
		if (s.startsWith(prefix)) {
			result.add(f.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
		}

		s = "reject(e|" + marked + ")";
		if (s.startsWith(prefix)) {
			result.add(f.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
		}

		s = "collect(e|" + marked + ")";
		if (s.startsWith(prefix)) {
			result.add(f.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
		}

		s = "exists(e|" + marked + ")";
		if (s.startsWith(prefix)) {
			result.add(f.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
		}

		s = "notExists(e|" + marked + ")";
		if (s.startsWith(prefix)) {
			result.add(f.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
		}

		s = "forAll(e|" + marked + ")";
		if (s.startsWith(prefix)) {
			result.add(f.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
		}

		s = "typeSelect(EClassifier)";
		if (s.startsWith(prefix)) {
			result.add(f.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf("EClassifier"), "EClassifier".length()));
		}

		return result;
	}

	/**
	 * @@param ctx
	 * @@return
	 */
	protected final static String[] computePrefixAndTargetExpression(final String str) {
		final ReverseScanner scanner = new ReverseScanner(str);
		String prefix = "";
		final String expr = null;

		IToken t = scanner.previousToken();
		if (t != null) {
			// prefix consists of identifier parts
			if (!Character.isWhitespace(str.charAt(str.length() - 1))) {
				if (Character.isJavaIdentifierStart(t.toString().charAt(0))) {
					prefix = t.toString();
					t = scanner.previousToken(); // go to operator
				}
			}

			final int exprEnd = scanner.getOffset();
			// if t is a dot there is a target expression
			if ((t != null) && (t.getKind() == ExpressionParsersym.TK_DOT)) {
				boolean lastWasOperator = true;
				boolean stop = false;
				while (!stop && ((t = scanner.previousToken()) != null)) {
					if (isOperand(t)) {
						if (lastWasOperator) {
							lastWasOperator = false;
						} else { // two operands in sequence -> stopper!
							scanner.nextToken();
							stop = true;
						}
					} else if (t.getKind() == ExpressionParsersym.TK_DOT) {
						if (!lastWasOperator) {
							lastWasOperator = true;
						} else {
							// errorneous expression
							return new String[] { prefix, expr };
						}
					} else if (isBlockCloser(t) && lastWasOperator) {
						lastWasOperator = false;
						final Stack<IToken> s = new Stack<IToken>();
						s.push(t);
						while (!s.isEmpty()) {
							final IToken temp = scanner.previousToken();
							if (temp == null) {
								return new String[] { prefix, expr };
							}
							if (temp.getKind() == t.getKind()) {
								s.push(temp);
							} else if (isOpposite(temp, t)) {
								s.pop();
							}
						}
						if (t.getKind() == ExpressionParsersym.TK_RPAREN) {
							// we have an unambigous syntax here
							// a.method(with.param)
							// but also
							// anIdentifier
							// (another.parenthesized.expressions)
							final IToken temp = scanner.previousToken();
							if (!isMethodName(temp)) {
								scanner.nextToken();
							}
						}
					} else {
						scanner.nextToken(); // go one forward
						stop = true;
					}
				}
				return new String[] { prefix, str.substring(scanner.getOffset(), exprEnd).trim() };
			}
		}
		return new String[] { prefix, expr };
	}

	private final static boolean isMethodName(final IToken temp) {
		return methodNames.contains(temp.getKind());
	}

	private final static boolean isOpposite(final IToken left, final IToken right) {
		final Integer temp = blockTokens.get(left.getKind());
		return (temp != null) && (right.getKind() == temp.intValue());
	}

	private final static boolean isBlockCloser(final IToken t) {
		return blockTokens.values().contains(t.getKind());
	}

	private final static boolean isOperand(final IToken t) {
		return operands.contains(t.getKind());
	}

}
@


1.3.6.1
log
@Initial commit of extend->qvt migration in xpand.
@
text
@d41 1
a41 1
import org.eclipse.gmf.internal.xpand.xtend.ast.GenericExtension;
d159 2
a160 2
				final Set<? extends GenericExtension> exts = executionContext.getAllExtensions();
				for (GenericExtension extension : exts) {
d275 1
a275 1
		for (GenericExtension e : executionContext.getAllExtensions()) {
@


1.3.6.2
log
@[243154] Use OCL instead of home-grown expression language - editor and its tests made compilable
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
d26 2
a30 1
import org.eclipse.emf.ecore.EClass;
a32 1
import org.eclipse.emf.ecore.EParameter;
d35 6
a40 4
import org.eclipse.gmf.internal.xpand.model.AnalysationIssue;
import org.eclipse.gmf.internal.xpand.model.ExecutionContext;
import org.eclipse.gmf.internal.xpand.model.Variable;
import org.eclipse.gmf.internal.xpand.parser.XpandParsersym;
a42 3
import org.eclipse.ocl.ecore.CollectionType;
import org.eclipse.ocl.lpg.AbstractFormattingHelper;
import org.eclipse.ocl.utilities.PredefinedType;
a43 1
@@SuppressWarnings("restriction")
d48 14
a61 14
		operators.add(XpandParsersym.TK_and);
		operators.add(XpandParsersym.TK_DIVIDE);
		operators.add(XpandParsersym.TK_DOT);
		operators.add(XpandParsersym.TK_EQUAL);
		operators.add(XpandParsersym.TK_GREATER_EQUAL);
		operators.add(XpandParsersym.TK_GREATER);
		operators.add(XpandParsersym.TK_LESS_EQUAL);
		operators.add(XpandParsersym.TK_LESS);
		operators.add(XpandParsersym.TK_MINUS);
		operators.add(XpandParsersym.TK_MULTIPLY);
		operators.add(XpandParsersym.TK_NOT_EQUAL);
		operators.add(XpandParsersym.TK_not);
		operators.add(XpandParsersym.TK_or);
		operators.add(XpandParsersym.TK_PLUS);
d66 6
a71 6
		stopper.add(XpandParsersym.TK_LPAREN);
		stopper.add(XpandParsersym.TK_COLON);
		stopper.add(XpandParsersym.TK_QUESTIONMARK);
		stopper.add(XpandParsersym.TK_BAR);
		stopper.add(XpandParsersym.TK_LBRACE);
		stopper.add(XpandParsersym.TK_COMMA);
d76 8
a83 22
		methodNames.add(XpandParsersym.TK_IDENTIFIER);
		methodNames.add(XpandParsersym.TK_collect);
		methodNames.add(XpandParsersym.TK_exists);
		methodNames.add(XpandParsersym.TK_forAll);
		methodNames.add(XpandParsersym.TK_reject);
		methodNames.add(XpandParsersym.TK_select);
//		methodNames.add(XpandParsersym.TK_typeSelect);
		methodNames.add(XpandParsersym.TK_closure);
		methodNames.add(XpandParsersym.TK_any);
		methodNames.add(XpandParsersym.TK_one);
		methodNames.add(XpandParsersym.TK_collectNested);
		methodNames.add(XpandParsersym.TK_sortedBy);
		methodNames.add(XpandParsersym.TK_isUnique);
		methodNames.add(XpandParsersym.TK_iterate);
		methodNames.add(XpandParsersym.TK_oclIsKindOf);
		methodNames.add(XpandParsersym.TK_oclIsTypeOf);
		methodNames.add(XpandParsersym.TK_oclAsType);
		methodNames.add(XpandParsersym.TK_oclIsNew);
		methodNames.add(XpandParsersym.TK_oclIsUndefined);
		methodNames.add(XpandParsersym.TK_oclIsInvalid);
		methodNames.add(XpandParsersym.TK_oclIsInState);
		methodNames.add(XpandParsersym.TK_allInstances);
d88 14
a101 13
		operands.add(XpandParsersym.TK_IDENTIFIER);
		operands.add(XpandParsersym.TK_collect);
		operands.add(XpandParsersym.TK_exists);
		operands.add(XpandParsersym.TK_false);
		operands.add(XpandParsersym.TK_forAll);
		operands.add(XpandParsersym.TK_null);
		operands.add(XpandParsersym.TK_reject);
		operands.add(XpandParsersym.TK_select);
		operands.add(XpandParsersym.TK_true);
//		operands.add(XpandParsersym.TK_typeSelect);
		operands.add(XpandParsersym.TK_INTEGER_LITERAL);
		operands.add(XpandParsersym.TK_REAL_LITERAL);
		operands.add(XpandParsersym.TK_STRING_LITERAL);
d107 2
a108 2
		blockTokens.put(XpandParsersym.TK_LPAREN, XpandParsersym.TK_RPAREN);
		blockTokens.put(XpandParsersym.TK_LBRACE, XpandParsersym.TK_RBRACE); // XXX braces as block tokens?
d113 1
a113 1
	private final ProposalFactory proposalFactory;
d115 1
a115 3
	public ExpressionProposalComputer(ProposalFactory factory) {
		assert factory != null;
		proposalFactory = factory;
d122 2
a123 1
	public List<ICompletionProposal> computeProposals(final String txt, final ExecutionContext context) {
d132 1
a132 1
				proposals.addAll(new TypeProposalComputer(proposalFactory).computeProposals(txt, executionContext));
d138 1
a138 1
				targetType = null;// FIXME new ExpressionHelper(expressionString).analyze(executionContext, issues);
d145 1
a145 1
				for (org.eclipse.ocl.expressions.Variable<EClassifier, EParameter> v : executionContext.getOCLEnvironment().getVariables()) {
d148 2
a149 3
						EClassifier t = executionContext.getVariable(varName).getType();
						String typeName = AbstractFormattingHelper.INSTANCE.formatType(t);
						proposals.add(proposalFactory.createVariableProposal(varName, typeName, prefix));
d162 1
a162 1
						proposals.add(proposalFactory.createExtensionProposal(extension, prefix));
d171 1
d176 4
d181 56
a242 1
	 * @@param context 
d254 3
a256 3
		if (targetType instanceof CollectionType) {
			result.addAll(getAllCollectionOperations(prefix));
			targetType = ((CollectionType) targetType).getElementType();
d265 1
a265 1
		for (EStructuralFeature f : getAllFeatures(targetType, executionContext)) {
d270 1
a270 1
		for (EOperation op : getAllOperation(targetType, executionContext)) {
d276 1
a276 1
			if (e.getName().toLowerCase().startsWith(prefixLowerCase) && (e.getParameterTypes().size() >= 1) && BuiltinMetaModel.isAssignableFrom(executionContext, e.getParameterTypes().get(0), targetType)) {
d283 1
a283 32
	private static List<EStructuralFeature> getAllFeatures(EClassifier targetType, ExecutionContext ctx) {
		List<EStructuralFeature> r2 = ctx.getOCLEnvironment().getTypeResolver().getAdditionalAttributes(targetType);
		if (targetType instanceof EClass) {
			List<EStructuralFeature> r1 = ((EClass) targetType).getEAllStructuralFeatures();
			ArrayList<EStructuralFeature> rv = new ArrayList<EStructuralFeature>(r1.size() + r2.size());
			rv.addAll(r1);
			rv.addAll(r2);
			return rv;
		}
		return r2;
	}

	private static List<EOperation> getAllOperation(EClassifier targetType, ExecutionContext ctx) {
		List<EOperation> r2 = ctx.getOCLEnvironment().getTypeResolver().getAdditionalOperations(targetType);
		if (targetType instanceof PredefinedType) {
			PredefinedType<EOperation> t = (PredefinedType<EOperation>) targetType;
			List<EOperation> r1 = t.oclOperations();
			ArrayList<EOperation> rv = new ArrayList<EOperation>(r1.size() + r2.size());
			rv.addAll(r1);
			rv.addAll(r2);
			return rv;
		} else if (targetType instanceof EClass) {
			List<EOperation> r1 = ((EClass) targetType).getEAllOperations();
			ArrayList<EOperation> rv = new ArrayList<EOperation>(r1.size() + r2.size());
			rv.addAll(r1);
			rv.addAll(r2);
			return rv;
		}
		return r2;
	}

	// XXX could use XpandParsersym.orderedTerminalSymbols[TK_xx] to get
d285 1
a285 1
	private List<ICompletionProposal> getAllCollectionOperations(final String prefix) {
d291 1
a291 1
			result.add(proposalFactory.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
d296 1
a296 1
			result.add(proposalFactory.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
d301 1
a301 1
			result.add(proposalFactory.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
d306 1
a306 1
			result.add(proposalFactory.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
d311 1
a311 1
			result.add(proposalFactory.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
d316 1
a316 1
			result.add(proposalFactory.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf(marked), marked.length()));
d321 1
a321 1
			result.add(proposalFactory.createCollectionSpecificOperationProposal(s, s, prefix, s.indexOf("EClassifier"), "EClassifier".length()));
d348 1
a348 1
			if ((t != null) && (t.getKind() == XpandParsersym.TK_DOT)) {
d359 1
a359 1
					} else if (t.getKind() == XpandParsersym.TK_DOT) {
d381 1
a381 1
						if (t.getKind() == XpandParsersym.TK_RPAREN) {
@


1.3.6.3
log
@[243154] Use OCL instead of home-grown expression language - moving towards no explicit use of 'this' keyword
@
text
@d160 1
a160 1
						EClassifier t = v.getType();
d166 1
a166 1
				final Variable v = executionContext.getImplicitVariable();
@


1.2
log
@refactored use of variables (no need to expose Map)
@
text
@a17 1
import java.util.Collection;
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@d18 1
d146 2
a147 2
				final Map<String, Variable> vars = executionContext.getVisibleVariables();
				for (String varName : vars.keySet()) {
@

