head	1.1;
access;
symbols
	v20080813-1520:1.1
	v20080812-2100:1.1
	ocl_qvt:1.1.0.6
	Root_ocl_qvt:1.1
	v20080722-1827:1.1
	v20080716-1600:1.1
	v20080716-1642:1.1
	R2_1_maintenance:1.1.0.4
	Root_R2_1_maintenance:1.1
	R2_1_0:1.1
	v20080425-1959:1.1
	v20071108-0000:1.1
	v20070809-0000:1.1
	R2_0_maintenance:1.1.0.2
	R2_0:1.1
	R4_20:1.1
	RC3_20:1.1
	v20070601-1400:1.1
	v20070518-1300:1.1
	v20070330-1300:1.1
	v20070228-2000:1.1
	M4_20:1.1
	M3_20:1.1;
locks; strict;
comment	@# @;


1.1
date	2006.10.18.20.33.08;	author atikhomirov;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2008.07.24.16.21.37;	author ashatalin;	state Exp;
branches;
next	1.1.6.2;
commitid	7c594888ac104567;

1.1.6.2
date	2008.08.19.15.56.03;	author atikhomirov;	state Exp;
branches;
next	;
commitid	746548aaed124567;


desc
@@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@/*******************************************************************************
 * Copyright (c) 2005, 2006 committers of openArchitectureWare and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     committers of openArchitectureWare - initial API and implementation
 *******************************************************************************/
package org.eclipse.gmf.internal.xpand.codeassist;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EParameter;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.gmf.internal.xpand.BuiltinMetaModel;
import org.eclipse.gmf.internal.xpand.editor.EditorImages;
import org.eclipse.gmf.internal.xpand.expression.TypeNameUtil;
import org.eclipse.gmf.internal.xpand.expression.ast.DeclaredParameter;
import org.eclipse.gmf.internal.xpand.expression.codeassist.ProposalFactory;
import org.eclipse.gmf.internal.xpand.xtend.ast.Extension;
import org.eclipse.jface.text.contentassist.CompletionProposal;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.swt.graphics.Image;

public class ProposalFactoryImpl implements ProposalFactory {

    protected final int offset;

    public ProposalFactoryImpl(int offset) {
        this.offset = offset;
    }

    public ICompletionProposal createCollectionSpecificOperationProposal(String insertString, String displayString, String prefix, int cursor, int marked) {
        return new CompletionProposal(insertString, offset - prefix.length(), prefix.length(), cursor, getOperationImage(), displayString, null, null);
    }

    public ICompletionProposal createPropertyProposal(final EStructuralFeature p, final String prefix, final boolean onCollection) {
        final String returnType = computeReturnType(p.getEType(), onCollection);
        final String displayStr = p.getName() + " " + returnType + " - " + p.getEContainingClass().getName();
        final String insertStr = p.getName();
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), insertStr.length(), getPropertyImage(), displayStr, null, null);
    }

    private String computeReturnType(EClassifier returnType, final boolean onCollection) {
        if (returnType == null) {
			return BuiltinMetaModel.VOID.getName();
		}
        if (onCollection) {
            if (BuiltinMetaModel.isParameterizedType(returnType)) {
                returnType = BuiltinMetaModel.getInnerType(returnType);
            }
            return "List[" + TypeNameUtil.getLastSegment(returnType.getName()) + "]";
        }

        return TypeNameUtil.getSimpleName(returnType.getName());
    }

    public ICompletionProposal createOperationProposal(final EOperation p, final String prefix, final boolean onCollection) {
        final StringBuilder displayStr = new StringBuilder();
        displayStr.append(p.getName());
        displayStr.append(toParamString(p));
        displayStr.append(" ");
        displayStr.append(computeReturnType(p.getEType(), onCollection));
        if(p.getEContainingClass() != null) { // == null for EDataType operations
        	displayStr.append(" - ");
        	displayStr.append(TypeNameUtil.getSimpleName(p.getEContainingClass().getName()));
        }
        final String insertStr = p.getName() + "()";
        int x = insertStr.length();
        if (p.getEParameters().size() > 0) {
            x--;
        }
        final Image img = getOperationImage();
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), x, img, displayStr.toString(), null, null);
    }

    public ICompletionProposal createExtensionProposal(final Extension p, final String prefix) {
        final String displayStr = p.getName() + toParamString(p, false) + " - " + p.getFileName();
        final String insertStr = p.getName() + "()";
        int x = insertStr.length();
        if (p.getFormalParameters().size() > 0) {
            x--;
        }
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), x, getExtensionImage(), displayStr, null, null);
    }

    public ICompletionProposal createExtensionOnMemberPositionProposal(Extension p, String prefix, boolean onOperation) {
        final String displayStr = p.getName() + toParamString(p, true) + " - " + ((DeclaredParameter) p.getFormalParameters().get(0)).getType();
        final String insertStr = p.getName() + "()";
        int x = insertStr.length();
        if (p.getFormalParameters().size() > 1) {
            x--;
        }
        final Image img = getExtensionImage();
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), x, img, displayStr, null, null);
    }

    private static String toParamString(final EOperation op) {
        final StringBuilder b = new StringBuilder("(");
        EList/*<EParameter>*/ params = op.getEParameters();
        for (int i = 0, x = params.size(); i < x; i++) {
        	EParameter p = (EParameter) params.get(i);
            b.append(TypeNameUtil.getSimpleName(p.getEType().getName()));
            if (i + 1 < x) {
                b.append(",");
            }
        }
        b.append(")");
        return b.toString();
    }

    private static String toParamString(final Extension p, final boolean member) {
        final StringBuilder b = new StringBuilder("(");
        int i = member ? 1 : 0;
        for (final int x = p.getFormalParameters().size(); i < x; i++) {
            b.append(((DeclaredParameter) p.getFormalParameters().get(i)).toString());
            if (i + 1 < x) {
                b.append(",");
            }
        }
        b.append(")");
        return b.toString();
    }

    public ICompletionProposal createVariableProposal(final String name, final EClassifier t, final String prefix) {
        final String displayStr = name + " " + computeReturnType(t, false);
        final String insertStr = name;
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), insertStr.length(), getVariableImage(), displayStr, null, null);
    }

    public ICompletionProposal createTypeProposal(final String insertString, final EClassifier type, final String prefix) {
        StringBuilder displayStr = new StringBuilder(type.getName());
        final String packName = TypeNameUtil.getFullNamespace(type);
        if (packName.length() > 0) {
            displayStr.append(" - ");
            displayStr.append(packName);
        }

        final String insertStr = insertString;
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), insertStr.length(), getTypeImage(), displayStr.toString(), null, null);
    }

    public ICompletionProposal createStatementProposal(String insertString, String displayString, String prefix, int cursor, int marked) {
        return new CompletionProposal(insertString, offset, prefix.length(), cursor, getStatementImage(), displayString, null, null);
    }

    public ICompletionProposal createStatementProposal(String insertString, String displayString, String prefix) {
        return createStatementProposal(insertString, displayString, prefix, insertString.length(), 0);
    }

    public ICompletionProposal createKeywordProposal(String insertString, String displayString, String prefix) {
        return new CompletionProposal(insertString, offset - prefix.length(), prefix.length(), insertString.length());
    }

	protected Image getTypeImage() {
		return EditorImages.getImage(EditorImages.TYPE);
	}

	protected Image getStatementImage() {
		return EditorImages.getImage(EditorImages.STATEMENT);
	}

	protected Image getOperationImage() {
		return EditorImages.getImage(EditorImages.OPERATION);
	}

	protected Image getPropertyImage() {
		return EditorImages.getImage(EditorImages.PROPERTY);
	}

	protected Image getExtensionImage() {
		return EditorImages.getImage(EditorImages.EXTENSION);
	}

	private Image getVariableImage() {
		return EditorImages.getImage(EditorImages.VARIABLE);
	}
}
@


1.1.6.1
log
@Initial commit of extend->qvt migration in xpand.
@
text
@a12 2
import java.util.List;

a15 1
import org.eclipse.emf.ecore.EPackage;
d21 1
d23 1
a23 1
import org.eclipse.gmf.internal.xpand.xtend.ast.GenericExtension;
d80 1
a80 1
    public ICompletionProposal createExtensionProposal(final GenericExtension p, final String prefix) {
d84 1
a84 1
        if (p.getParameterNames().size() > 0) {
d90 2
a91 2
    public ICompletionProposal createExtensionOnMemberPositionProposal(GenericExtension p, String prefix, boolean onOperation) {
        final String displayStr = p.getName() + toParamString(p, true) + " - " + getTypeName(p.getParameterTypes().get(0));
d94 1
a94 1
        if (p.getParameterNames().size() > 1) {
d115 1
a115 1
    private static String toParamString(final GenericExtension p, final boolean member) {
d118 2
a119 7
        List<String> parameterNames = p.getParameterNames();
        // TODO: check if getParameterTypes() return proper collection in all situations
        List<EClassifier> parameterTypes = p.getParameterTypes();
        for (final int x = parameterNames.size(); i < x; i++) {
        	b.append(parameterTypes.size() < x ? getTypeName(parameterTypes.get(x)) : "?");
        	b.append(" ");
            b.append(parameterNames.get(x));
d128 1
a128 24
    // TODO: revisit this method and check correct type name processing for QVT types
    private static String getTypeName(EClassifier classifier) {
    	StringBuilder b = new StringBuilder();
    	getPackageFQName(classifier.getEPackage(), b);
    	b.append(classifier.getName());
    	if (BuiltinMetaModel.isParameterizedType(classifier)) {
    		b.append("[");
    		BuiltinMetaModel.getInnerType(classifier);
    		b.append("]");
    	}
		return b.toString();
	}
    
    private static void getPackageFQName(EPackage ePackage, StringBuilder b) {
    	if (ePackage != null) {
	    	if (ePackage.getESuperPackage() != null) {
	    		getPackageFQName(ePackage.getESuperPackage(), b);
	    	}
    		b.append(ePackage.getName());
    		b.append("::");
    	}
    }

	public ICompletionProposal createVariableProposal(final String name, final EClassifier t, final String prefix) {
@


1.1.6.2
log
@[243154] Use OCL instead of home-grown expression language - editor and its tests made compilable
@
text
@d1 2
a2 2
/*
 * Copyright (c) 2005, 2008 committers of openArchitectureWare and others.
d10 1
a10 1
 */
d18 1
d21 1
a21 1
import org.eclipse.emf.ecore.ETypedElement;
d23 1
a27 5
import org.eclipse.ocl.ecore.CollectionType;
import org.eclipse.ocl.ecore.internal.OCLFactoryImpl;
import org.eclipse.ocl.ecore.internal.UMLReflectionImpl;
import org.eclipse.ocl.lpg.AbstractFormattingHelper;
import org.eclipse.ocl.util.ObjectUtil;
a32 1
	private final EditorImages editorImages;
d34 1
a34 1
    public ProposalFactoryImpl(int offset, EditorImages images) {
a35 1
		editorImages = images;
d39 1
a39 1
        return new CompletionProposal(insertString, offset - prefix.length(), prefix.length(), cursor, editorImages.getOperation(), displayString, null, null);
d43 1
a43 1
        final String returnType = computeReturnType(p, onCollection);
d46 1
a46 1
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), insertStr.length(), editorImages.getProperty(), displayStr, null, null);
d49 12
a60 15
    private String computeReturnType(ETypedElement returnType, final boolean onCollection) {
    	EClassifier t = UMLReflectionImpl.INSTANCE.getOCLType(returnType);
    	if (onCollection) {
    		// FIXME [artem] not sure why for properties that return list but invoked on collection
    		// I need to use inner type - sort of implicit collect ("a.b.c", where all properties are lists still 
    		// gives a flat result list). Need to check if this holds true with OCL/QVT
	    	if (t instanceof CollectionType) {
	    		EClassifier temp = t;
	    		t = ((CollectionType) t).getElementType();
	    		// @@see EcoreEvaluationEnvironment#getCollectionKind()
	    		ObjectUtil.dispose(temp);
	    	}
	    	t = (EClassifier) OCLFactoryImpl.INSTANCE.createSequenceType(t);
    	}
        return getTypeName(t);
d68 1
a68 1
        displayStr.append(computeReturnType(p, onCollection));
d71 1
a71 1
        	displayStr.append(getTypeName(p.getEContainingClass()));
d78 1
a78 1
        final Image img = editorImages.getOperation();
d89 1
a89 1
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), x, editorImages.getExtension(), displayStr, null, null);
d99 1
a99 1
        final Image img = editorImages.getExtension();
d105 1
a105 1
        EList<EParameter> params = op.getEParameters();
d107 2
a108 1
        	b.append(getTypeName(params.get(i).getEType()));
d137 9
a145 1
    	return AbstractFormattingHelper.INSTANCE.formatType(classifier);
d148 8
a155 4
	public ICompletionProposal createVariableProposal(String varName, String typeName, String prefix) {
        final String displayStr = varName + " " + typeName;
        final String insertStr = varName;
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), insertStr.length(), editorImages.getVariable(), displayStr, null, null);
d158 16
a173 2
    public ICompletionProposal createTypeProposal(final String insertStr, String displayStr, final String prefix) {
        return new CompletionProposal(insertStr, offset - prefix.length(), prefix.length(), insertStr.length(), editorImages.getType(), displayStr, null, null);
d177 1
a177 1
        return new CompletionProposal(insertString, offset, prefix.length(), cursor, editorImages.getStatement(), displayString, null, null);
d187 24
@


