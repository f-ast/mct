head	1.5;
access;
symbols
	v20080813-1520:1.5
	v20080812-2100:1.5
	ocl_qvt:1.5.0.6
	Root_ocl_qvt:1.5
	v20080722-1827:1.5
	v20080716-1600:1.5
	v20080716-1642:1.5
	R2_1_maintenance:1.5.0.4
	Root_R2_1_maintenance:1.5
	R2_1_0:1.5
	v20080425-1959:1.5
	v20071108-0000:1.5
	v20070809-0000:1.5
	R2_0_maintenance:1.5.0.2
	R2_0:1.5
	R4_20:1.5
	RC3_20:1.5
	v20070601-1400:1.5
	v20070518-1300:1.5
	v20070330-1300:1.4
	v20070228-2000:1.4
	M4_20:1.4
	M3_20:1.4;
locks; strict;
comment	@# @;


1.5
date	2007.05.14.11.14.00;	author atikhomirov;	state Exp;
branches
	1.5.6.1;
next	1.4;
commitid	44cb464844784567;

1.4
date	2006.11.09.18.59.06;	author atikhomirov;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.23.16.48.47;	author atikhomirov;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.23.15.00.21;	author atikhomirov;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.20.33.08;	author atikhomirov;	state Exp;
branches;
next	;

1.5.6.1
date	2008.08.19.15.56.03;	author atikhomirov;	state Exp;
branches;
next	;
commitid	746548aaed124567;


desc
@@


1.5
log
@provide better ordering of proposals
@
text
@/*
 * <copyright>
 *
 * Copyright (c) 2005-2006 Sven Efftinge and others.
 * All rights reserved.   This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sven Efftinge - Initial API and implementation
 *
 * </copyright>
 */
package org.eclipse.gmf.internal.xpand.editor;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.eclipse.gmf.internal.xpand.codeassist.ExpandProposalComputer;
import org.eclipse.gmf.internal.xpand.codeassist.FastAnalyzer;
import org.eclipse.gmf.internal.xpand.codeassist.KeywordProposalComputer;
import org.eclipse.gmf.internal.xpand.codeassist.ProposalFactoryImpl;
import org.eclipse.gmf.internal.xpand.codeassist.StatementProposalComputer;
import org.eclipse.gmf.internal.xpand.codeassist.XpandPartition;
import org.eclipse.gmf.internal.xpand.codeassist.XpandTokens;
import org.eclipse.gmf.internal.xpand.expression.codeassist.ExpressionProposalComputer;
import org.eclipse.gmf.internal.xpand.expression.codeassist.ProposalFactory;
import org.eclipse.gmf.internal.xpand.expression.codeassist.TypeProposalComputer;
import org.eclipse.gmf.internal.xpand.model.XpandExecutionContext;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.ITextViewer;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.jface.text.contentassist.IContentAssistProcessor;
import org.eclipse.jface.text.contentassist.IContextInformation;
import org.eclipse.jface.text.contentassist.IContextInformationValidator;

/**
 * @@author Sven Efftinge
 * @@author artem
 */
public class XpandContentAssistProcessor implements IContentAssistProcessor {

    private final XpandEditor editor;
    private final ProposalComparator comparator;

    // FIXME AbstractOawContentAssistProcessor did a nature check - MOVE it Editor

    public XpandContentAssistProcessor(final XpandEditor editor) {
        this.editor = editor;
        this.comparator = new ProposalComparator();
    }

    public ICompletionProposal[] computeCompletionProposals(final ITextViewer viewer, final int documentOffset) {
        try {
            final IDocument doc = viewer.getDocument();
			final String txt = doc.get(0, documentOffset);
			final int additionalTextLen = Math.min(doc.getLength(), documentOffset + doc.getLineLength(doc.getLineOfOffset(documentOffset))) - documentOffset;
			final String textPastInsertionPoint = doc.get(documentOffset, additionalTextLen);

            XpandExecutionContext ctx = editor.getContext(); 

            final XpandPartition p = FastAnalyzer.computePartition(txt);

            if (p == XpandPartition.COMMENT) {
				return new ICompletionProposal[0];
			}
            List<ICompletionProposal> proposals = new ArrayList<ICompletionProposal>(20);
            final ProposalFactory f = new ProposalFactoryImpl(documentOffset);

            if (p == XpandPartition.TYPE_DECLARATION) {
                ctx = FastAnalyzer.computeExecutionContext(txt, ctx);
                proposals = new TypeProposalComputer().computeProposals(txt, ctx, f);
    			Collections.sort(proposals, comparator);
            } else if (p == XpandPartition.EXPRESSION) {
                ctx = FastAnalyzer.computeExecutionContext(txt, ctx);
                final String expression = txt.substring(txt.lastIndexOf(XpandTokens.LT_CHAR) + 1);
                List<ICompletionProposal> ep = new ExpressionProposalComputer().computeProposals(expression, ctx, f);
    			Collections.sort(ep, comparator);
				proposals.addAll(ep);
                List<ICompletionProposal> kp = new KeywordProposalComputer(textPastInsertionPoint).computeProposals(txt, ctx, f);
    			Collections.sort(kp, comparator);
				proposals.addAll(kp);
            } else if (p == XpandPartition.EXPAND_STATEMENT) {
                ctx = FastAnalyzer.computeExecutionContext(txt, ctx);
                List<ICompletionProposal> ep = new ExpandProposalComputer().computeProposals(txt, ctx, f);
    			Collections.sort(ep, comparator);
				proposals.addAll(ep);
                proposals.add(new org.eclipse.jface.text.contentassist.CompletionProposal(XpandTokens.LT + XpandTokens.RT, documentOffset, 0, 1));
            } else if (p == XpandPartition.DEFAULT) {
                ctx = FastAnalyzer.computeExecutionContext(txt, ctx);
                List<ICompletionProposal> sp = new StatementProposalComputer().computeProposals(txt, ctx, f);
    			Collections.sort(sp, comparator);
				proposals.addAll(sp);
                proposals.add(new org.eclipse.jface.text.contentassist.CompletionProposal(XpandTokens.LT + XpandTokens.RT, documentOffset, 0, 1));
            }
            return proposals.toArray(new ICompletionProposal[proposals.size()]);
        } catch (final Exception e) {
            Activator.logError(e);
        }
        return null;
    }

    public IContextInformation[] computeContextInformation(final ITextViewer viewer, final int documentOffset) {
        return null;
    }

    public char[] getCompletionProposalAutoActivationCharacters() {
        return null;
    }

    public char[] getContextInformationAutoActivationCharacters() {
        return null;
    }

    public String getErrorMessage() {
        return null;
    }

    public IContextInformationValidator getContextInformationValidator() {
    	// TODO Auto-generated method stub
    	return null;
    }

    private static class ProposalComparator implements Comparator<ICompletionProposal> {
        public int compare(final ICompletionProposal p1, final ICompletionProposal p2) {
        	// XXX better would be put most matching proposal first!!!
            return p1.getDisplayString().compareTo(p2.getDisplayString());
        }
    }
}
@


1.5.6.1
log
@[243154] Use OCL instead of home-grown expression language - editor and its tests made compilable
@
text
@d2 3
a4 1
 * Copyright (c) 2005, 2008 Sven Efftinge and others.
d12 2
d32 1
a32 1
import org.eclipse.gmf.internal.xpand.model.ExecutionContext;
d63 1
a63 1
            ExecutionContext ctx = editor.getContext(); 
d71 1
a71 1
            final ProposalFactory f = new ProposalFactoryImpl(documentOffset, EditorImages.get());
d75 1
a75 1
                proposals = new TypeProposalComputer(f).computeProposals(txt, ctx);
d80 1
a80 1
                List<ICompletionProposal> ep = new ExpressionProposalComputer(f).computeProposals(expression, ctx);
d83 1
a83 1
                List<ICompletionProposal> kp = new KeywordProposalComputer(textPastInsertionPoint, f).computeProposals(txt, ctx);
d88 1
a88 1
                List<ICompletionProposal> ep = new ExpandProposalComputer(f).computeProposals(txt, ctx);
d94 1
a94 1
                List<ICompletionProposal> sp = new StatementProposalComputer(f).computeProposals(txt, ctx);
@


1.4
log
@sort respecting case;
use chars past insertion point to decide whether RT should be added
@
text
@d47 1
d53 1
d70 1
a70 1
            List<ICompletionProposal> proposals = new ArrayList<ICompletionProposal>();
d76 1
d80 6
a85 2
                proposals.addAll(new ExpressionProposalComputer().computeProposals(expression, ctx, f));
                proposals.addAll(new KeywordProposalComputer(textPastInsertionPoint).computeProposals(txt, ctx, f));
d88 3
a90 1
                proposals.addAll(new ExpandProposalComputer().computeProposals(txt, ctx, f));
d94 3
a96 1
                proposals.addAll(new StatementProposalComputer().computeProposals(txt, ctx, f));
a98 6
            Collections.sort(proposals, new Comparator<ICompletionProposal>() {
                public int compare(final ICompletionProposal p1, final ICompletionProposal p2) {
                	// XXX better would be put most matching proposal first!!!
                    return p1.getDisplayString().compareTo(p2.getDisplayString());
                }
            });
d126 7
@


1.3
log
@expression parser can't handle LT char, hence need to avoid it in the char stream
@
text
@d33 1
d56 4
a59 1
            final String txt = viewer.getDocument().get(0, documentOffset);
d78 1
a78 1
                proposals.addAll(new KeywordProposalComputer().computeProposals(txt, ctx, f));
a89 2
                	// [artem] originally there was compareTo, but e.g. ExpressionProposalComputer
                	// ignores case when deciding what to take, so why should we
d91 1
a91 1
                    return p1.getDisplayString().compareToIgnoreCase(p2.getDisplayString());
@


1.2
log
@no reason for content assist to parse file and to care about context creation
@
text
@d72 1
a72 1
                final String expression = txt.substring(txt.lastIndexOf(XpandTokens.LT_CHAR));
@


1.1
log
@Initial contribution of the reworked XPand template engine from eclipse.org/gmt/oaw to be used until M2T deliveries are available.
The contribution (including LPG 1.1 runtime) was approved by Eclipse Legal at the very end of September, 2006.
@
text
@a21 2
import org.eclipse.core.resources.IFile;
import org.eclipse.gmf.internal.xpand.ResourceManager;
a31 1
import org.eclipse.gmf.internal.xpand.model.XpandDefinition;
a32 2
import org.eclipse.gmf.internal.xpand.model.XpandResource;
import org.eclipse.gmf.internal.xpand.util.ContextFactory;
a37 1
import org.eclipse.ui.IEditorPart;
d41 1
d45 1
a45 1
    private IEditorPart editor;
d49 1
a49 1
    public XpandContentAssistProcessor(final IEditorPart editor) {
a52 4
    protected IFile getFile() {
        return (IFile) editor.getEditorInput().getAdapter(IFile.class);
    }

d55 1
a55 2
            final String txt = viewer.getDocument().get().substring(0, documentOffset);
            XpandDefinition[] defs = new XpandDefinition[0];
d57 1
a57 1
            final ResourceManager resourceManager = org.eclipse.gmf.internal.xpand.Activator.getResourceManager(getFile().getProject());
a58 5
            final XpandResource tpl = resourceManager.loadXpandResource(getFile());
            if (tpl != null) {
                defs = tpl.getDefinitions();
            }
            XpandExecutionContext ctx = ContextFactory.createXpandContext(resourceManager);
d68 1
a68 1
                ctx = FastAnalyzer.computeExecutionContext(txt, ctx, defs);
d71 1
a71 1
                ctx = FastAnalyzer.computeExecutionContext(txt, ctx, defs);
d76 1
a76 1
                ctx = FastAnalyzer.computeExecutionContext(txt, ctx, defs);
d80 1
a80 1
                ctx = FastAnalyzer.computeExecutionContext(txt, ctx, defs);
@

