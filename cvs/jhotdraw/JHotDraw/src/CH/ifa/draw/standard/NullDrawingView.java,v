head	1.6;
access;
symbols
	jhotdraw54b2-release:1.6
	reorg_6x_split:1.6
	MVC_PHASE1:1.5.0.4
	NEW_ATTRIBUTES:1.5.0.2
	DNOYEB1_ALPHA-2:1.2.4.5
	release_JHD54b1:1.5
	BUGFIX_670992:1.4.0.2
	DNOYEB1_ALPHA-1:1.2.4.3
	dnoyeb1:1.2.0.4
	repack:1.2.0.2
	Root_repack:1.2
	Before_FigureVisitor:1.2
	JHotDraw_5-3:1.1;
locks; strict;
comment	@# @;


1.6
date	2003.05.08.15.41.23;	author ricardo_padilha;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.26.22.04.39;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.12.20.21.16;	author dnoyeb;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.03.00.55.32;	author dnoyeb;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.01.19.18.31.32;	author mrfloppy;	state Exp;
branches;
next	;

1.2.4.1
date	2003.01.03.16.03.59;	author dnoyeb;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.01.14.18.25.56;	author dnoyeb;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.01.21.00.04.38;	author dnoyeb;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.01.26.00.51.16;	author dnoyeb;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.01.29.04.41.13;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Refactoring of Cursor:
- java.awt.Cursor (class) has been sistematically replaced with CH.ifa.draw.contrib.framework.Cursor (interface)
- a new default implementation of Cursor (interface) has been added: CH.ifa.draw.contrib.standard.AWTCursor
@
text
@/*
 * @@(#)NullDrawingView.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.standard;

import java.awt.*;
import java.util.Collection;
import java.util.Hashtable;

import javax.swing.JPanel;

import CH.ifa.draw.framework.*;

/**
 * This DrawingView provides a very basic implementation. It does not perform any
 * functionality apart from keeping track of its state represented by some important
 * fields. It is a Null-value object and is used instead of a null reference to
 * avoid null pointer exception. This concept is known as the Null-value object
 * bug pattern.
 *
 * @@author  Wolfram Kaiser <mrfloppy@@users.sourceforge.net>
 * @@version <$CURRENT_VERSION$>
 */
public class NullDrawingView extends JPanel implements DrawingView {

	private DrawingEditor myDrawingEditor;
	private Drawing myDrawing;
	private Painter myUpdateStrategy;
	private Color myBackgroundColor;

	private static Hashtable drawingViewManager = new Hashtable();

	protected NullDrawingView(DrawingEditor editor) {
		setEditor(editor);
		setDrawing(new StandardDrawing());
	}

	/**
	 * Sets the view's editor.
	 */
	public void setEditor(DrawingEditor editor) {
		myDrawingEditor = editor;
	}

	/**
	 * Gets the current tool.
	 */
	public Tool tool() {
		return editor().tool();
	}

	/**
	 * Gets the drawing.
	 */
	public Drawing drawing() {
		return myDrawing;
	}

	/**
	 * Sets and installs another drawing in the view.
	 */
	public void setDrawing(Drawing d) {
		myDrawing = d;
	}

	/**
	 * Gets the editor.
	 */
	public DrawingEditor editor() {
		return myDrawingEditor;
	}

	/**
	 * Adds a figure to the drawing.
	 * @@return the added figure.
	 */
	public Figure add(Figure figure) {
		return figure;
	}

	/**
	 * Removes a figure from the drawing.
	 * @@return the removed figure
	 */
	public Figure remove(Figure figure) {
		return figure;
	}

	/**
	 * Adds a collection of figures to the drawing.
	 */
	public void addAll(Collection figures) {
		// ignore: do nothing
	}

	/**
	 * Gets the size of the drawing.
	 */
	public Dimension getSize() {
		return new Dimension();
	}

	/**
	 * Gets the minimum dimension of the drawing.
	 */
	public Dimension getMinimumSize() {
		return new Dimension();
	}

	/**
	 * Gets the preferred dimension of the drawing..
	 */
	public Dimension getPreferredSize() {
		return new Dimension();
	}

	/**
	 * Sets the current display update strategy.
	 * @@see Painter
	 */
	public void setDisplayUpdate(Painter newUpdateStrategy) {
		myUpdateStrategy = newUpdateStrategy;
	}

	/**
	 * Gets the current display update strategy.
	 * @@see Painter
	 */
	public Painter getDisplayUpdate() {
		return myUpdateStrategy;
	}

	/**
	 * Gets an enumeration over the currently selected figures.
	 * The selection is a snapshot of the current selection
	 * which does not get changed anymore
	 *
	 * @@return an enumeration with the currently selected figures.
	 */
	public FigureEnumeration selection() {
		return FigureEnumerator.getEmptyEnumeration();
	}

	/**
	 * Gets the currently seleced figures in Z order.
	 * @@see #selection
	 * @@return a FigureEnumeration with the selected figures. This enumeration
	 * represents a snapshot of the current selection.
	 */
	public FigureEnumeration selectionZOrdered() {
		return FigureEnumerator.getEmptyEnumeration();
	}

	/**
	 * Gets the number of selected figures.
	 */
	public int selectionCount() {
		return 0;
	}

	/**
	 * Test whether a given figure is selected.
	 */
	public boolean isFigureSelected(Figure checkFigure) {
		return false;
	}

	/**
	 * Adds a figure to the current selection.
	 */
	public void addToSelection(Figure figure) {
		// ignore: do nothing
	}

	/**
	 * Adds a Collection of figures to the current selection.
	 */
	public void addToSelectionAll(Collection figures) {
		// ignore: do nothing
	}

	/**
	 * Adds a FigureEnumeration to the current selection.
	 */
	public void addToSelectionAll(FigureEnumeration fe) {
		// ignore: do nothing
	}

	/**
	 * Removes a figure from the selection.
	 */
	public void removeFromSelection(Figure figure) {
		// ignore: do nothing
	}

	/**
	 * If a figure isn't selected it is added to the selection.
	 * Otherwise it is removed from the selection.
	 */
	public void toggleSelection(Figure figure) {
		// ignore: do nothing
	}

	/**
	 * Clears the current selection.
	 */
	public void clearSelection() {
		// ignore: do nothing
	}

	/**
	 * Gets the current selection as a FigureSelection. A FigureSelection
	 * can be cut, copied, pasted.
	 */
	public FigureSelection getFigureSelection() {
		return new StandardFigureSelection(selection(), 0);
	}

	/**
	 * Finds a handle at the given coordinates.
	 * @@return the hit handle, null if no handle is found.
	 */
	public Handle findHandle(int x, int y) {
		return null;
	}

	/**
	 * Gets the position of the last click inside the view.
	 */
	public Point lastClick() {
		return new Point();
	}

	/**
	 * Sets the current point constrainer.
	 */
	public void setConstrainer(PointConstrainer p) {
		// ignore: do nothing
	}

	/**
	 * Gets the current grid setting.
	 */
	public PointConstrainer getConstrainer() {
		return null;
	}

	/**
	 * Checks whether the drawing has some accumulated damage
	 */
	public void checkDamage() {
		// ignore: do nothing
	}

	/**
	 * Repair the damaged area
	 */
	public void repairDamage() {
		// ignore: do nothing
	}

	/**
	 * Paints the drawing view. The actual drawing is delegated to
	 * the current update strategy.
	 * @@see Painter
	 */
	public void paint(Graphics g) {
		// ignore: do nothing
	}

	/**
	 * Creates an image with the given dimensions
	 */
	public Image createImage(int width, int height) {
		return null;
	}

	/**
	 * Gets a graphic to draw into
	 */
	public Graphics getGraphics() {
		return null;
	}

	/**
	 * Gets the background color of the DrawingView
	 */
	public Color getBackground() {
		return myBackgroundColor;
	}

	/**
	 * Sets the background color of the DrawingView
	 */
	public void setBackground(Color c) {
		myBackgroundColor = c;
	}

	/**
	 * Draws the contents of the drawing view.
	 * The view has three layers: background, drawing, handles.
	 * The layers are drawn in back to front order.
	 */
	public void drawAll(Graphics g) {
		// ignore: do nothing
	}

	/**
	 * Draws the given figures.
	 * The view has three layers: background, drawing, handles.
	 * The layers are drawn in back to front order.
	 */
	public void draw(Graphics g, FigureEnumeration fe) {
		// ignore: do nothing
	}

	/**
	 * Draws the currently active handles.
	 */
	public void drawHandles(Graphics g) {
		// ignore: do nothing
	}

	/**
	 * Draws the drawing.
	 */
	public void drawDrawing(Graphics g) {
		// ignore: do nothing
	}

	/**
	 * Draws the background. If a background pattern is set it
	 * is used to fill the background. Otherwise the background
	 * is filled in the background color.
	 */
	public void drawBackground(Graphics g) {
		// ignore: do nothing
	}

	/**
	 * Sets the cursor of the DrawingView
	 */
	public void setCursor(CH.ifa.draw.framework.Cursor c) {
		// ignore: do nothing
	}

	/**
	 * Freezes the view by acquiring the drawing lock.
	 * @@see Drawing#lock
	 */
	public void freezeView() {
		// ignore: do nothing
	}

	/**
	 * Unfreezes the view by releasing the drawing lock.
	 * @@see Drawing#unlock
	 */
	public void unfreezeView() {
		// ignore: do nothing
	}

	/**
	 * Add a listener for selection changes in this DrawingView.
	 * @@param fsl jhotdraw.framework.FigureSelectionListener
	 */
	public void addFigureSelectionListener(FigureSelectionListener fsl) {
		// ignore: do nothing
	}

	/**
	 * Remove a listener for selection changes in this DrawingView.
	 * @@param fsl jhotdraw.framework.FigureSelectionListener
	 */
	public void removeFigureSelectionListener(FigureSelectionListener fsl) {
		// ignore: do nothing
	}

	/**
	 * Returns a FigureEnumeration of connection figures
	 */
	public FigureEnumeration getConnectionFigures(Figure inFigure) {
		return FigureEnumerator.getEmptyEnumeration();
	}

	/**
	 * Inserts figures in a drawing at given offset. Optional check for connection figures
	 *
	 *  @@return enumeration which has been added to the drawing. The figures in the enumeration
	 *          can have changed during adding them (e.g. they could have been decorated).
	 */
	public FigureEnumeration insertFigures(FigureEnumeration inFigures, int dx, int dy, boolean bCheck) {
		return FigureEnumerator.getEmptyEnumeration();
	}

	public void drawingInvalidated(DrawingChangeEvent e) {
		// ignore: do nothing
	}

	public void drawingRequestUpdate(DrawingChangeEvent e) {
		// ignore: do nothing
	}

	public void drawingTitleChanged(DrawingChangeEvent e) {
		// ignore: do nothing        
	}

	public boolean isInteractive() {
		return false;
	}

	public synchronized static DrawingView getManagedDrawingView(DrawingEditor editor) {
		if (drawingViewManager.containsKey(editor)) {
			return (DrawingView)drawingViewManager.get(editor);
		}
		else {
			DrawingView newDrawingView = new NullDrawingView(editor);
			drawingViewManager.put(editor, newDrawingView);
			return newDrawingView;
		}
	}
}
@


1.5
log
@merge conflict resolved
@
text
@a13 1
import CH.ifa.draw.framework.*;
d15 3
a17 1
import java.util.*;
d20 2
d351 1
a351 1
	public void setCursor(Cursor c) {
@


1.4
log
@Clean up head to be what it was before i mistakenly committed my changes to it.
My changes should have been committed to a branch, and let mrfloppy merge to the trunk.
This will happen from now on.
@
text
@d26 1
a26 1
 * @@author  Wolfram Kaiser <mrfloppy@@sourceforge.net>
d38 1
a38 1
	public NullDrawingView(DrawingEditor editor) {
d407 4
@


1.3
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d408 1
a408 3
    public void drawingTitleChanged(DrawingChangeEvent e) {
		// ignore: do nothing        
    }
@


1.2
log
@after variou merges... (before 5.4 release)
@
text
@d408 3
a410 1

@


1.2.4.1
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d408 1
a408 3
    public void drawingTitleChanged(DrawingChangeEvent e) {
		// ignore: do nothing        
    }
@


1.2.4.2
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d82 2
a83 2
	public void add(Figure figure) {

d90 2
a91 2
	public void remove(Figure figure) {

@


1.2.4.3
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d80 1
a80 1
	 * @@return the added figure. misleading.
d82 2
a83 2
	public Figure add(Figure figure) {
		return figure;
d90 2
a91 2
	public Figure remove(Figure figure) {
		return figure;
d97 2
a98 2
	public FigureEnumeration addAll(Collection figures) {
		return FigureEnumerator.getEmptyEnumeration();
@


1.2.4.4
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d82 2
a83 1
	public void add(Figure figure) {
d90 2
a91 1
	public void remove(Figure figure) {
d97 2
a98 2
	public void addAll(Collection figures) {
		FigureEnumerator.getEmptyEnumeration();
@


1.2.4.5
log
@Using List over ArrayList and Map over HashMap/WeakMap etc.
@
text
@d36 1
a36 1
	private static java.util.Map drawingViewManager = new Hashtable();
@


1.1
log
@no message
@
text
@d26 1
a26 1
 * @@author Wolfram Kaiser
a33 1
	private Tool myTool;
d37 1
a37 1
	
a39 1
		myTool = new SelectionTool(editor());
d42 1
a42 1
	
d54 1
a54 1
		return myTool;
d95 1
a95 1
	 * Adds a vector of figures to the drawing.
d97 1
a97 1
	public void addAll(Vector figures) {
a138 9
	 * Gets the currently selected figures.
	 * @@return a vector with the selected figures. The vector
	 * is a copy of the current selection.
	 */
	public Vector selection() {
		return new Vector(0);
	}

	/**
d140 4
d145 1
a145 1
	public FigureEnumeration selectionElements() {
d152 2
a153 2
	 * @@return a vector with the selected figures. The vector
	 * is a copy of the current selection.
d155 2
a156 2
	public Vector selectionZOrdered() {
		return new Vector(0);
d172 1
a172 1
	
d181 1
a181 1
	 * Adds a vector of figures to the current selection.
d183 1
a183 1
	public void addToSelectionAll(Vector figures) {
d221 1
a221 1
		return new StandardFigureSelection(selectionElements(), 0);
d385 1
a385 1
	 * Returns the vector of connection figures
d387 2
a388 2
	public Vector getConnectionFigures(Figure inFigure) {
		return new Vector(0);
d412 1
a412 1
	
@

