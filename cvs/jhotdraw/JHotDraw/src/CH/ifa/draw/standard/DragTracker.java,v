head	1.7;
access;
symbols
	jhotdraw54b2-release:1.7
	reorg_6x_split:1.7
	MVC_PHASE1:1.6.0.10
	NEW_ATTRIBUTES:1.6.0.8
	DNOYEB1_ALPHA-2:1.6.4.1
	release_JHD54b1:1.6
	BUGFIX_670992:1.6.0.6
	DNOYEB1_ALPHA-1:1.6.4.1
	dnoyeb1:1.6.0.4
	repack:1.6.0.2
	Root_repack:1.6
	Before_FigureVisitor:1.6
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2003.11.09.21.18.46;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.6.4.1
date	2003.01.10.04.54.45;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.7
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 * @@(#)DragTracker.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.standard;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.UndoableAdapter;
import CH.ifa.draw.util.Undoable;
import java.awt.*;
import java.awt.event.MouseEvent;

/**
 * DragTracker implements the dragging of the clicked
 * figure.
 *
 * @@see SelectionTool
 *
 * @@version <$CURRENT_VERSION$>
 */
public class DragTracker extends AbstractTool {

	private Figure  fAnchorFigure;
	private int     fLastX, fLastY;      // previous mouse position
	private boolean fMoved = false;

	public DragTracker(DrawingEditor newDrawingEditor, Figure anchor) {
		super(newDrawingEditor);
		setAnchorFigure(anchor);
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		super.mouseDown(e, x, y);
		setLastMouseX(x);
		setLastMouseY(y);

		if (e.isShiftDown()) {
		   getActiveView().toggleSelection(getAnchorFigure());
		   setAnchorFigure(null);
		}
		else if (!getActiveView().isFigureSelected(getAnchorFigure())) {
			getActiveView().clearSelection();
			getActiveView().addToSelection(getAnchorFigure());
		}
		setUndoActivity(createUndoActivity());
		getUndoActivity().setAffectedFigures(getActiveView().selection());
//		getUndoActivity().setAffectedFigures(view().selectionElements());
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
		super.mouseDrag(e, x, y);
		setHasMoved((Math.abs(x - getAnchorX()) > 4) || (Math.abs(y - getAnchorY()) > 4));

		if (hasMoved()) {
			FigureEnumeration figures = getUndoActivity().getAffectedFigures();
			while (figures.hasNextFigure()) {
				figures.nextFigure().moveBy(x - getLastMouseX(), y - getLastMouseY());
			}
		}
		setLastMouseX(x);
		setLastMouseY(y);
	}

	protected void setAnchorFigure(Figure newAnchorFigure) {
		fAnchorFigure = newAnchorFigure;
	}
	
	public Figure getAnchorFigure() {
		return fAnchorFigure;
	}

	protected void setLastMouseX(int newLastMouseX) {
		fLastX = newLastMouseX;
	}
	
	protected int getLastMouseX() {
		return fLastX;
	}

	protected void setLastMouseY(int newLastMouseY) {
		fLastY = newLastMouseY;
	}
	
	protected int getLastMouseY() {
		return fLastY;
	}

	/**
	 * Check whether the selected figure has been moved since
	 * the tool has been activated.
	 *
	 * @@return true if the selected figure has been moved
	 */
	public boolean hasMoved() {
		return fMoved;
	}
	
	protected void setHasMoved(boolean newMoved) {
		fMoved = newMoved;
	}
	
	public void activate() {
		// suppress clearSelection() and tool-activation-notification
		// in superclass
	}

	public void deactivate() {
		if (hasMoved()) {
			((DragTracker.UndoActivity)getUndoActivity()).setBackupPoint(new Point(getLastMouseX(), getLastMouseY()));
		}
		else {
			setUndoActivity(null);
		}
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new DragTracker.UndoActivity(getActiveView(), new Point(getLastMouseX(), getLastMouseY()));
	}

	public static class UndoActivity extends UndoableAdapter {
		private Point myOriginalPoint;
		private Point myBackupPoint;

		public UndoActivity(DrawingView newDrawingView, Point newOriginalPoint) {
			super(newDrawingView);
			setOriginalPoint(newOriginalPoint);
			setUndoable(true);
			setRedoable(true);
		}

		/*
		 * Undo the activity
		 * @@return true if the activity could be undone, false otherwise
		 */
		public boolean undo() {
			if (!super.undo()) {
				return false;
			}
			moveAffectedFigures(getBackupPoint(), getOriginalPoint());
			return true;
		}

		/*
		 * Redo the activity
		 * @@return true if the activity could be redone, false otherwise
		 */
		public boolean redo() {
			if (!super.redo()) {
				return false;
			}
			moveAffectedFigures(getOriginalPoint(), getBackupPoint());
			return true;
		}

		public void setBackupPoint(Point newBackupPoint) {
			myBackupPoint = newBackupPoint;
		}

		public Point getBackupPoint() {
			return myBackupPoint;
		}

		public void setOriginalPoint(Point newOriginalPoint) {
			myOriginalPoint = newOriginalPoint;
		}

		public Point getOriginalPoint() {
			return myOriginalPoint;
		}

		public void moveAffectedFigures(Point startPoint, Point endPoint) {
			FigureEnumeration figures = getAffectedFigures();
			while (figures.hasNextFigure()) {
				figures.nextFigure().moveBy(endPoint.x - startPoint.x,
					endPoint.y - startPoint.y);
			}
		}
	}
}
@


1.6
log
@after variou merges... (before 5.4 release)
@
text
@d36 1
a36 1
		fAnchorFigure = anchor;
d41 2
a42 2
		fLastX = x;
		fLastY = y;
d45 2
a46 2
		   getActiveView().toggleSelection(fAnchorFigure);
		   fAnchorFigure = null;
d48 1
a48 1
		else if (!getActiveView().isFigureSelected(fAnchorFigure)) {
d50 1
a50 1
			getActiveView().addToSelection(fAnchorFigure);
d59 1
a59 1
		fMoved = (Math.abs(x - getAnchorX()) > 4) || (Math.abs(y - getAnchorY()) > 4);
d61 1
a61 1
		if (fMoved) {
d64 1
a64 1
				figures.nextFigure().moveBy(x - fLastX, y - fLastY);
d67 2
a68 2
		fLastX = x;
		fLastY = y;
d71 38
d115 2
a116 2
		if (fMoved) {
			((DragTracker.UndoActivity)getUndoActivity()).setBackupPoint(new Point(fLastX, fLastY));
d127 1
a127 1
		return new DragTracker.UndoActivity(getActiveView(), new Point(fLastX, fLastY));
@


1.6.4.1
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d18 1
a18 1

d39 4
a42 7
	public void mouseDown(DrawingViewMouseEvent dvme) {
		super.mouseDown(dvme);
		setAnchorX( dvme.getMouseEvent().getX() );
		setAnchorY( dvme.getMouseEvent().getY() );

		fLastX = getAnchorX();
		fLastY = getAnchorY();
d44 1
a44 1
		if (dvme.getMouseEvent().isShiftDown()) {
d57 3
a59 3
	public void mouseDrag(DrawingViewMouseEvent dvme) {
		super.mouseDrag(dvme);
		fMoved = (Math.abs(dvme.getX() - getAnchorX()) > 4) || (Math.abs(dvme.getY() - getAnchorY()) > 4);
d64 1
a64 1
				figures.nextFigure().moveBy(dvme.getX() - fLastX, dvme.getY() - fLastY);
d67 2
a68 2
		fLastX = dvme.getX();
		fLastY = dvme.getY();
@


1.5
log
@no message
@
text
@a18 1
import java.util.*;
d45 1
a45 1
		   view().toggleSelection(fAnchorFigure);
d48 3
a50 3
		else if (!view().isFigureSelected(fAnchorFigure)) {
			view().clearSelection();
			view().addToSelection(fAnchorFigure);
d52 3
d63 1
a63 1
			while (figures.hasMoreElements()) {
a73 2
		setUndoActivity(createUndoActivity());
		getUndoActivity().setAffectedFigures(view().selectionElements());
d89 1
a89 1
		return new DragTracker.UndoActivity(view(), new Point(fLastX, fLastY));
d145 1
a145 1
			while (figures.hasMoreElements()) {
@


1.4
log
@merge dnd (before 5.3)
@
text
@d57 1
a57 1
		fMoved = (Math.abs(x - fAnchorX) > 4) || (Math.abs(y - fAnchorY) > 4);
d70 2
d95 1
a95 1
		
d126 1
d130 1
a130 1
		
d134 1
a134 1
		
d138 1
a138 1
		
d142 1
a142 1
		
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d31 50
a80 50
    private Figure  fAnchorFigure;
    private int     fLastX, fLastY;      // previous mouse position
    private boolean fMoved = false;

    public DragTracker(DrawingView view, Figure anchor) {
        super(view);
        fAnchorFigure = anchor;
    }

    public void mouseDown(MouseEvent e, int x, int y) {
        super.mouseDown(e, x, y);
        fLastX = x;
        fLastY = y;

        if (e.isShiftDown()) {
           view().toggleSelection(fAnchorFigure);
           fAnchorFigure = null;
        }
        else if (!view().isFigureSelected(fAnchorFigure)) {
            view().clearSelection();
            view().addToSelection(fAnchorFigure);
        }
    }

    public void mouseDrag(MouseEvent e, int x, int y) {
        super.mouseDrag(e, x, y);
        fMoved = (Math.abs(x - fAnchorX) > 4) || (Math.abs(y - fAnchorY) > 4);

        if (fMoved) {
            FigureEnumeration figures = getUndoActivity().getAffectedFigures();
            while (figures.hasMoreElements()) {
                figures.nextFigure().moveBy(x - fLastX, y - fLastY);
            }
        }
        fLastX = x;
        fLastY = y;
    }

    public void activate() {
   		setUndoActivity(createUndoActivity());
    	getUndoActivity().setAffectedFigures(view().selectionElements());
	}

    public void deactivate() {
    	if (fMoved) {
	   		((DragTracker.UndoActivity)getUndoActivity()).setBackupPoint(new Point(fLastX, fLastY));
    	}
    	else {
    		setUndoActivity(null);
   		}
d90 10
a99 10
    public static class UndoActivity extends UndoableAdapter {
    	private Point myOriginalPoint;
    	private Point myBackupPoint;
    	
    	public UndoActivity(DrawingView newDrawingView, Point newOriginalPoint) {
    		super(newDrawingView);
    		setOriginalPoint(newOriginalPoint);
    		setUndoable(true);
    		setRedoable(true);
    	}
d105 1
a105 1
    	public boolean undo() {
d107 1
a107 1
	        	return false;
d117 1
a117 1
    	public boolean redo() {
d119 1
a119 1
	        	return false;
d124 24
a147 24
    	public void setBackupPoint(Point newBackupPoint) {
    		myBackupPoint = newBackupPoint;
    	}
    	
    	public Point getBackupPoint() {
    		return myBackupPoint;
    	}
    	
    	public void setOriginalPoint(Point newOriginalPoint) {
    		myOriginalPoint = newOriginalPoint;
    	}
    	
    	public Point getOriginalPoint() {
    		return myOriginalPoint;
    	}
    	
    	public void moveAffectedFigures(Point startPoint, Point endPoint) {
            FigureEnumeration figures = getAffectedFigures();
            while (figures.hasMoreElements()) {
                figures.nextFigure().moveBy(endPoint.x - startPoint.x,
                	endPoint.y - startPoint.y);
            }
    	}
    }
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)DragTracker.java 5.2
d4 6
d14 3
a19 1
import CH.ifa.draw.framework.*;
d26 2
d48 2
a49 1
        } else if (!view().selection().contains(fAnchorFigure)) {
d60 2
a61 2
            FigureEnumeration figures = view().selectionElements();
            while (figures.hasMoreElements())
d63 1
d67 80
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)DragTracker.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
