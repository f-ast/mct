head	1.7;
access;
symbols
	jhotdraw54b2-release:1.7
	reorg_6x_split:1.7
	MVC_PHASE1:1.7.0.10
	NEW_ATTRIBUTES:1.7.0.8
	DNOYEB1_ALPHA-2:1.7
	release_JHD54b1:1.7
	BUGFIX_670992:1.7.0.6
	DNOYEB1_ALPHA-1:1.7
	dnoyeb1:1.7.0.4
	repack:1.7.0.2
	Root_repack:1.7
	Before_FigureVisitor:1.7
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1;
locks; strict;
comment	@# @;


1.7
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.20.19.57.59;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.44.33;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.15.48.47;	author jeckel;	state Exp;
branches;
next	;


desc
@@


1.7
log
@after variou merges... (before 5.4 release)
@
text
@/*
 * @@(#)QuadTree.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */


package CH.ifa.draw.standard;

import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.CollectionsFactory;

import java.awt.geom.Rectangle2D;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.io.Serializable;

/**
 * @@author WMG (INIT Copyright (C) 2000 All rights reserved)
 * @@version <$CURRENT_VERSION$>
 */
class QuadTree implements Serializable {

	//_________________________________________________________VARIABLES

	private Rectangle2D  _absoluteBoundingRectangle2D = new Rectangle2D.Double();
	private int          _nMaxTreeDepth;
	private Hashtable    _theHashtable = new Hashtable();
	private Hashtable    _outsideHashtable = new Hashtable();
	private QuadTree     _nwQuadTree;
	private QuadTree     _neQuadTree;
	private QuadTree     _swQuadTree;
	private QuadTree     _seQuadTree;

	//______________________________________________________CONSTRUCTORS

	public QuadTree(Rectangle2D absoluteBoundingRectangle2D) {
		this(2, absoluteBoundingRectangle2D);
	}

	public QuadTree(int nMaxTreeDepth, Rectangle2D
		absoluteBoundingRectangle2D) {
		_init(nMaxTreeDepth, absoluteBoundingRectangle2D);
	}

	//____________________________________________________PUBLIC METHODS

	public void add(Object anObject, Rectangle2D absoluteBoundingRectangle2D) {
		if (_nMaxTreeDepth == 1) {
			if (absoluteBoundingRectangle2D.intersects(_absoluteBoundingRectangle2D)) {
				_theHashtable.put(anObject, absoluteBoundingRectangle2D);
			}
			else {
				_outsideHashtable.put(anObject, absoluteBoundingRectangle2D);
			}
			return;
		}

		boolean bNW = absoluteBoundingRectangle2D.intersects(
			_nwQuadTree.getAbsoluteBoundingRectangle2D());

		boolean bNE = absoluteBoundingRectangle2D.intersects(
			_neQuadTree.getAbsoluteBoundingRectangle2D());

		boolean bSW = absoluteBoundingRectangle2D.intersects(
			_swQuadTree.getAbsoluteBoundingRectangle2D());

		boolean bSE = absoluteBoundingRectangle2D.intersects(
			_seQuadTree.getAbsoluteBoundingRectangle2D());

		int nCount = 0;

		if (bNW == true) {
			nCount++;
		}
		if (bNE == true) {
			nCount++;
		}
		if (bSW == true) {
			nCount++;
		}
		if (bSE == true) {
			nCount++;
		}

		if (nCount > 1) {
			_theHashtable.put(anObject, absoluteBoundingRectangle2D);
			return;
		}
		if (nCount == 0) {
			_outsideHashtable.put(anObject, absoluteBoundingRectangle2D);
			return;
		}

		if (bNW == true) {
			_nwQuadTree.add(anObject, absoluteBoundingRectangle2D);
		}
		if (bNE == true) {
			_neQuadTree.add(anObject, absoluteBoundingRectangle2D);
		}
		if (bSW == true) {
			_swQuadTree.add(anObject, absoluteBoundingRectangle2D);
		}
		if (bSE == true) {
			_seQuadTree.add(anObject, absoluteBoundingRectangle2D);
		}
	}

	public Object remove(Object anObject) {
		Object returnObject = _theHashtable.remove(anObject);
		if (returnObject != null) {
			return returnObject;
		}

		if (_nMaxTreeDepth > 1) {
			returnObject = _nwQuadTree.remove(anObject);
			if (returnObject != null) {
				return returnObject;
			}

			returnObject = _neQuadTree.remove(anObject);
			if (returnObject != null) {
				return returnObject;
			}

			returnObject = _swQuadTree.remove(anObject);
			if (returnObject != null) {
				return returnObject;
			}

			returnObject = _seQuadTree.remove(anObject);
			if (returnObject != null) {
				return returnObject;
			}
		}

		returnObject = _outsideHashtable.remove(anObject);
		if (returnObject != null) {
			return returnObject;
		}

		return null;
	}


	public void clear() {
		_theHashtable.clear();
		_outsideHashtable.clear();
		if (_nMaxTreeDepth > 1) {
			_nwQuadTree.clear();
			_neQuadTree.clear();
			_swQuadTree.clear();
			_seQuadTree.clear();
		}
	}

	public int getMaxTreeDepth() {
		return _nMaxTreeDepth;
	}
/*
	public FigureEnumeration getAll() {
		List l = CollectionsFactory.current().createList();
		l.add(_theHashtable.keySet());
		l.add(_outsideHashtable.keySet());

		if (_nMaxTreeDepth > 1) {
			l.add(_nwQuadTree.getAll().toList());
			l.add(_neQuadTree.getAll().toList());
			l.add(_swQuadTree.getAll().toList());
			l.add(_seQuadTree.getAll().toList());
		}

		return new FigureEnumerator(l);
	}
*/
	public FigureEnumeration getAllWithin(Rectangle2D r) {
		List l = CollectionsFactory.current().createList();
		for (Iterator ii = _outsideHashtable.keySet().iterator(); ii.hasNext(); ) {
			Object anObject = ii.next();
			Rectangle2D itsAbsoluteBoundingRectangle2D = (Rectangle2D)
			_outsideHashtable.get(anObject);

			if (itsAbsoluteBoundingRectangle2D.intersects(r)) {
				l.add(anObject);
			}
		}

		if (_absoluteBoundingRectangle2D.intersects(r)) {
			for(Iterator i = _theHashtable.keySet().iterator(); i.hasNext(); ) {
				Object anObject = i.next();
				Rectangle2D itsAbsoluteBoundingRectangle2D = (Rectangle2D)
				_theHashtable.get(anObject);

				if (itsAbsoluteBoundingRectangle2D.intersects(r)) {
					l.add(anObject);
				}
			}

			if (_nMaxTreeDepth > 1) {
				l.add(_nwQuadTree.getAllWithin(r));
				l.add(_neQuadTree.getAllWithin(r));
				l.add(_swQuadTree.getAllWithin(r));
				l.add(_seQuadTree.getAllWithin(r));
			}
		}

		return new FigureEnumerator(l);
	}

	public Rectangle2D getAbsoluteBoundingRectangle2D() {
		return _absoluteBoundingRectangle2D;
	}

	//___________________________________________________PRIVATE METHODS

	private void _init(int nMaxTreeDepth, Rectangle2D absoluteBoundingRectangle2D) {
		_absoluteBoundingRectangle2D.setRect(absoluteBoundingRectangle2D);
		_nMaxTreeDepth = nMaxTreeDepth;

		if (_nMaxTreeDepth > 1) {
			_nwQuadTree = new QuadTree(_nMaxTreeDepth-1,
			_makeNorthwest(absoluteBoundingRectangle2D));
			_neQuadTree = new QuadTree(_nMaxTreeDepth-1,
			_makeNortheast(absoluteBoundingRectangle2D));
			_swQuadTree = new QuadTree(_nMaxTreeDepth-1,
			_makeSouthwest(absoluteBoundingRectangle2D));
			_seQuadTree = new QuadTree(_nMaxTreeDepth-1,
			_makeSoutheast(absoluteBoundingRectangle2D));
		}
	}

	private Rectangle2D _makeNorthwest(Rectangle2D r) {
		return new Rectangle2D.Double(r.getX(), r.getY(), r.getWidth() / 2.0, r.getHeight() / 2.0);
	}

	private Rectangle2D _makeNortheast(Rectangle2D r) {
		return new Rectangle2D.Double(r.getX() + r.getWidth() / 2.0,
			r.getY(), r.getWidth() / 2.0, r.getHeight() / 2.0);
	}

	private Rectangle2D _makeSouthwest(Rectangle2D r) {
		return new Rectangle2D.Double(r.getX(), r.getY() + r.getHeight() / 2.0,
			r.getWidth() / 2.0, r.getHeight() / 2.0);
	}

	private Rectangle2D _makeSoutheast(Rectangle2D r) {
		return new Rectangle2D.Double(r.getX() + r.getWidth() / 2.0,
			r.getY() + r.getHeight() / 2.0, r.getWidth() / 2.0,
			r.getHeight() / 2.0);
	}

//_______________________________________________________________END

} //end of class QuadTree
@


1.6
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@d15 3
d21 1
a21 1
import java.util.Vector;
d25 1
a25 1
 * @@author: WMG (INIT Copyright (C) 2000 All rights reserved)
a51 3
	private QuadTree() {
	}

d166 5
a170 5

	public Vector getAll() {
		Vector v = new Vector();
		v.addAll(_theHashtable.keySet());
		v.addAll(_outsideHashtable.keySet());
d173 4
a176 4
			v.addAll(_nwQuadTree.getAll());
			v.addAll(_neQuadTree.getAll());
			v.addAll(_swQuadTree.getAll());
			v.addAll(_seQuadTree.getAll());
d179 1
a179 1
		return v;
d181 3
a183 3

	public Vector getAllWithin(Rectangle2D r) {
		Vector v = new Vector();
d190 1
a190 1
				v.addElement(anObject);
d201 1
a201 1
					v.addElement(anObject);
d206 4
a209 4
				v.addAll(_nwQuadTree.getAllWithin(r));
				v.addAll(_neQuadTree.getAllWithin(r));
				v.addAll(_swQuadTree.getAllWithin(r));
				v.addAll(_seQuadTree.getAllWithin(r));
d213 1
a213 1
		return v;
@


1.5
log
@no message
@
text
@d41 1
a41 1
		this(6, absoluteBoundingRectangle2D);
@


1.4
log
@merge dnd (before 5.3)
@
text
@d19 1
d25 1
a25 1
class QuadTree {
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@d61 1
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)QuadTree.java 5.2
d4 6
a9 6
 * INIT Copyright (C) 2000 All rights reserved
 *
 * File:            QuadTree.java
 * Description:     X
 * @@author          WMG
 * Created:         2000.03.27
d12 1
d20 4
a23 2


d26 1
d28 227
d256 1
a256 332
  //_________________________________________________________VARIABLES



  private Rectangle2D  _absoluteBoundingRectangle2D
                        = new Rectangle2D.Double();
  private int          _nMaxTreeDepth;
  private Hashtable    _theHashtable = new Hashtable();
  private Hashtable    _outsideHashtable = new Hashtable();
  private QuadTree     _nwQuadTree;
  private QuadTree     _neQuadTree;
  private QuadTree     _swQuadTree;
  private QuadTree     _seQuadTree;



  //______________________________________________________CONSTRUCTORS



  public QuadTree(Rectangle2D absoluteBoundingRectangle2D) {

    this(6, absoluteBoundingRectangle2D);

  }



  public QuadTree(int nMaxTreeDepth, Rectangle2D
   absoluteBoundingRectangle2D) {

    _init(nMaxTreeDepth, absoluteBoundingRectangle2D);

  }



  private QuadTree() {

  }



  //____________________________________________________PUBLIC METHODS



  public void add(Object anObject, Rectangle2D
   absoluteBoundingRectangle2D) {

    if (_nMaxTreeDepth == 1) {

      if (absoluteBoundingRectangle2D.intersects(
       _absoluteBoundingRectangle2D)) {
        _theHashtable.put(anObject, absoluteBoundingRectangle2D);
      }
      else {
        _outsideHashtable.put(anObject, absoluteBoundingRectangle2D);
      }

      return;

    }

    boolean bNW =
     absoluteBoundingRectangle2D.intersects(
     _nwQuadTree.getAbsoluteBoundingRectangle2D());

    boolean bNE =
     absoluteBoundingRectangle2D.intersects(
     _neQuadTree.getAbsoluteBoundingRectangle2D());

    boolean bSW =
     absoluteBoundingRectangle2D.intersects(
     _swQuadTree.getAbsoluteBoundingRectangle2D());

    boolean bSE =
     absoluteBoundingRectangle2D.intersects(
     _seQuadTree.getAbsoluteBoundingRectangle2D());

    int nCount = 0;

    if (bNW == true) {
      nCount++;
    }

    if (bNE == true) {
      nCount++;
    }

    if (bSW == true) {
      nCount++;
    }

    if (bSE == true) {
      nCount++;
    }

    if (nCount > 1) {
      _theHashtable.put(anObject, absoluteBoundingRectangle2D);
      return;
    }

    if (nCount == 0) {
      _outsideHashtable.put(anObject, absoluteBoundingRectangle2D);
      return;
    }

    if (bNW == true) {
      _nwQuadTree.add(anObject, absoluteBoundingRectangle2D);
    }

    if (bNE == true) {
      _neQuadTree.add(anObject, absoluteBoundingRectangle2D);
    }

    if (bSW == true) {
      _swQuadTree.add(anObject, absoluteBoundingRectangle2D);
    }

    if (bSE == true) {
      _seQuadTree.add(anObject, absoluteBoundingRectangle2D);
    }

  }



  public Object remove(Object anObject) {

    Object returnObject = _theHashtable.remove(anObject);
    if (returnObject != null) {
      return returnObject;
    }

    if (_nMaxTreeDepth > 1) {

      returnObject = _nwQuadTree.remove(anObject);
      if (returnObject != null) {
        return returnObject;
      }

      returnObject = _neQuadTree.remove(anObject);
      if (returnObject != null) {
        return returnObject;
      }

      returnObject = _swQuadTree.remove(anObject);
      if (returnObject != null) {
        return returnObject;
      }

      returnObject = _seQuadTree.remove(anObject);
      if (returnObject != null) {
        return returnObject;
      }

    }

    returnObject = _outsideHashtable.remove(anObject);
    if (returnObject != null) {
      return returnObject;
    }

    return null;

  }



  public void clear() {

    _theHashtable.clear();
    _outsideHashtable.clear();
    if (_nMaxTreeDepth > 1) {
      _nwQuadTree.clear();
      _neQuadTree.clear();
      _swQuadTree.clear();
      _seQuadTree.clear();
    }

  }



  public int getMaxTreeDepth() {

    return _nMaxTreeDepth;

  }



  public Vector getAll() {

    Vector v = new Vector();

    v.addAll(_theHashtable.keySet());
    v.addAll(_outsideHashtable.keySet());

    if (_nMaxTreeDepth > 1) {
      v.addAll(_nwQuadTree.getAll());
      v.addAll(_neQuadTree.getAll());
      v.addAll(_swQuadTree.getAll());
      v.addAll(_seQuadTree.getAll());
    }

    return v;

  }



  public Vector getAllWithin(Rectangle2D r) {

    Vector v = new Vector();

    for(Iterator ii = _outsideHashtable.keySet().iterator();
     ii.hasNext(); ) {

      Object anObject = ii.next();
      Rectangle2D itsAbsoluteBoundingRectangle2D = (Rectangle2D)
       _outsideHashtable.get(anObject);

      if (itsAbsoluteBoundingRectangle2D.intersects(r)) {
        v.addElement(anObject);
      }

    }

    if (_absoluteBoundingRectangle2D.intersects(r)) {

      for(Iterator i = _theHashtable.keySet().iterator();
       i.hasNext(); ) {

        Object anObject = i.next();
        Rectangle2D itsAbsoluteBoundingRectangle2D = (Rectangle2D)
         _theHashtable.get(anObject);

        if (itsAbsoluteBoundingRectangle2D.intersects(r)) {
          v.addElement(anObject);
        }

      }

      if (_nMaxTreeDepth > 1) {
        v.addAll(_nwQuadTree.getAllWithin(r));
        v.addAll(_neQuadTree.getAllWithin(r));
        v.addAll(_swQuadTree.getAllWithin(r));
        v.addAll(_seQuadTree.getAllWithin(r));
      }

    }

    return v;

  }



  public Rectangle2D getAbsoluteBoundingRectangle2D() {

    return _absoluteBoundingRectangle2D;

  }



  //___________________________________________________PRIVATE METHODS



  private void _init(int nMaxTreeDepth, Rectangle2D
   absoluteBoundingRectangle2D) {

    _absoluteBoundingRectangle2D.setRect(absoluteBoundingRectangle2D);
    _nMaxTreeDepth = nMaxTreeDepth;

    if (_nMaxTreeDepth > 1) {
      _nwQuadTree = new QuadTree(_nMaxTreeDepth-1,
       _makeNorthwest(absoluteBoundingRectangle2D));
      _neQuadTree = new QuadTree(_nMaxTreeDepth-1,
       _makeNortheast(absoluteBoundingRectangle2D));
      _swQuadTree = new QuadTree(_nMaxTreeDepth-1,
       _makeSouthwest(absoluteBoundingRectangle2D));
      _seQuadTree = new QuadTree(_nMaxTreeDepth-1,
       _makeSoutheast(absoluteBoundingRectangle2D));
    }

  }



  private Rectangle2D _makeNorthwest(Rectangle2D r) {

    return new Rectangle2D.Double(r.getX(), r.getY(),
     r.getWidth() / 2.0, r.getHeight() / 2.0);

  }



  private Rectangle2D _makeNortheast(Rectangle2D r) {

    return new Rectangle2D.Double(r.getX() + r.getWidth() / 2.0,
     r.getY(), r.getWidth() / 2.0, r.getHeight() / 2.0);

  }



  private Rectangle2D _makeSouthwest(Rectangle2D r) {

    return new Rectangle2D.Double(r.getX(),
     r.getY() + r.getHeight() / 2.0,
     r.getWidth() / 2.0, r.getHeight() / 2.0);

  }



  private Rectangle2D _makeSoutheast(Rectangle2D r) {

    return new Rectangle2D.Double(r.getX() + r.getWidth() / 2.0,
     r.getY() + r.getHeight() / 2.0, r.getWidth() / 2.0,
     r.getHeight() / 2.0);

  }



  //_______________________________________________________________END
@


1.1
log
@implements a QuadTree; used for a faster update strategy
@
text
@d1 10
a10 11
/*____________________________________________________________________
  INIT Copyright (C) 2000 All rights reserved
        
    File:            QuadTree.java
    Description:     X
    Author:          WMG
    Created:         2000.03.27
  ____________________________________________________________________
*/


@

