head	1.7;
access;
symbols
	jhotdraw54b2-release:1.7
	reorg_6x_split:1.7
	MVC_PHASE1:1.7.0.10
	NEW_ATTRIBUTES:1.7.0.8
	DNOYEB1_ALPHA-2:1.7.4.2
	release_JHD54b1:1.7
	BUGFIX_670992:1.7.0.6
	DNOYEB1_ALPHA-1:1.7.4.1
	dnoyeb1:1.7.0.4
	repack:1.7.0.2
	Root_repack:1.7
	Before_FigureVisitor:1.7
	JHotDraw_5-3:1.6
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.25.13;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.29.13.42.14;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches;
next	;

1.7.4.1
date	2003.01.16.15.58.50;	author dnoyeb;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.01.29.04.41.13;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.7
log
@after variou merges... (before 5.4 release)
@
text
@/*
 * @@(#)AlignCommand.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.standard;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.UndoableAdapter;
import CH.ifa.draw.util.Undoable;
import java.util.*;
import java.awt.*;

/**
 * Align a selection of figures relative to each other.
 *
 * @@version <$CURRENT_VERSION$>
 */
public class AlignCommand extends AbstractCommand {

	public static abstract class Alignment {
		/**
		 * align left sides
		 */
		public final static Alignment LEFTS = new Alignment("Lefts") {
			public void moveBy(Figure f, Rectangle anchor) {
				Rectangle rr = f.displayBox();
				f.moveBy(anchor.x-rr.x, 0);
			}
		};

		/**
		 * align centers (horizontally)
		 */
		public final static Alignment CENTERS = new Alignment("Centers") {
			public void moveBy(Figure f, Rectangle anchor) {
				Rectangle rr = f.displayBox();
				f.moveBy((anchor.x+anchor.width/2) - (rr.x+rr.width/2), 0);
			}
		};

		/**
		 * align right sides
		 */
		public final static Alignment RIGHTS = new Alignment("Rights") {
			public void moveBy(Figure f, Rectangle anchor) {
				Rectangle rr = f.displayBox();
				f.moveBy((anchor.x+anchor.width) - (rr.x+rr.width), 0);
			}
		};

		/**
		 * align tops
		 */
		public final static Alignment TOPS = new Alignment("Tops") {
			public void moveBy(Figure f, Rectangle anchor) {
				Rectangle rr = f.displayBox();
				f.moveBy(0, anchor.y-rr.y);
			}
		};

		/**
		 * align middles (vertically)
		 */
		public final static Alignment MIDDLES = new Alignment("Middles") {
			public void moveBy(Figure f, Rectangle anchor) {
				Rectangle rr = f.displayBox();
				f.moveBy(0, (anchor.y+anchor.height/2) - (rr.y+rr.height/2));
			}
		};

		/**
		 * align bottoms
		 */
		public final static Alignment BOTTOMS = new Alignment("Bottoms") {
			public void moveBy(Figure f, Rectangle anchor) {
				Rectangle rr = f.displayBox();
				f.moveBy(0, (anchor.y+anchor.height) - (rr.y+rr.height));
			}
		};

		private String myDescription;

		private Alignment(String newDescription) {
			setDescription(newDescription);
		}

		public String toString() {
			return getDescription();
		}

		public String getDescription() {
			return myDescription;
		}

		private void setDescription(String newDescription) {
			myDescription = newDescription;
		}

		public abstract void moveBy(Figure f, Rectangle anchor);
	}

	private Alignment myAlignment;

	/**
	 * Constructs an alignment command.
	 * @@param newAlignment the alignment operation (LEFTS, CENTERS, RIGHTS, etc.)
	 * @@param newDrawingEditor the DrawingEditor which manages the views
	 */
	public AlignCommand(Alignment newAlignment, DrawingEditor newDrawingEditor) {
		super(newAlignment.getDescription(), newDrawingEditor);
		setAlignment(newAlignment);
	}

	protected boolean isExecutableWithView() {
		return view().selectionCount() > 1;
	}

	public void execute() {
		super.execute();
		setUndoActivity(createUndoActivity());
		// get selected figures in the order the figures have been selected
		getUndoActivity().setAffectedFigures(view().selection());
		((AlignCommand.UndoActivity)getUndoActivity()).alignAffectedFigures(getAlignment());
		view().checkDamage();
	}

	protected void setAlignment(Alignment newAlignment) {
		myAlignment = newAlignment;
	}

	public Alignment getAlignment() {
		return myAlignment;
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new AlignCommand.UndoActivity(view(), getAlignment());
	}

	public static class UndoActivity extends UndoableAdapter {
		private Hashtable myOriginalPoints;
		private Alignment myAppliedAlignment;

		public UndoActivity(DrawingView newView, Alignment newAlignment) {
			super(newView);
			myOriginalPoints = new Hashtable();
			setAppliedAlignment(newAlignment);
			setUndoable(true);
			setRedoable(true);
		}

		public boolean undo() {
			if (!super.undo()) {
				return false;
			}

			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				Figure f = fe.nextFigure();
				Point originalPoint = getOriginalPoint(f);
				Point currentPoint = f.displayBox().getLocation();
				// substract current lcoation to get to 0,0 and then move to original location
				f.moveBy(-currentPoint.x + originalPoint.x,
						 -currentPoint.y + originalPoint.y);
			}

			return true;
		}

		public boolean redo() {
			if (!isRedoable()) {
				return false;
			}
			alignAffectedFigures(getAppliedAlignment());
			return true;
		}

		protected void setAppliedAlignment(Alignment newAlignment) {
			myAppliedAlignment = newAlignment;
		}

		public Alignment getAppliedAlignment() {
			return myAppliedAlignment;
		}

		protected void addOriginalPoint(Figure f) {
			myOriginalPoints.put(f, f.displayBox().getLocation());
		}

		public Point getOriginalPoint(Figure f) {
			return (Point)myOriginalPoints.get(f);
		}

		public void alignAffectedFigures(Alignment applyAlignment) {
			FigureEnumeration fe = getAffectedFigures();
			Figure anchorFigure = fe.nextFigure();
			Rectangle r = anchorFigure.displayBox();

			while (fe.hasNextFigure()) {
				Figure f = fe.nextFigure();
				applyAlignment.moveBy(f, r);
			}
		}

		public void setAffectedFigures(FigureEnumeration fe) {
			// first make copy of FigureEnumeration in superclass
			super.setAffectedFigures(fe);
			// then get new FigureEnumeration of copy to save aligment
			FigureEnumeration copyFe = getAffectedFigures();
			while (copyFe.hasNextFigure()) {
				addOriginalPoint(copyFe.nextFigure());
			}
		}
	}
}
@


1.7.4.1
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d131 1
a131 1
		view().drawing().update();
@


1.7.4.2
log
@Using List over ArrayList and Map over HashMap/WeakMap etc.
@
text
@d150 1
a150 1
		private java.util.Map myOriginalPoints;
@


1.6
log
@merge dnd (before 5.3)
@
text
@d37 1
a37 1
	
d47 1
a47 1
	
d57 1
a57 1
	
d67 1
a67 1
	
d77 1
a77 1
	
d87 1
a87 1
		
d89 1
a89 1
		
d97 1
a97 1
		
d101 1
a101 1
	
d105 1
a105 1
		
d129 1
a129 1
		getUndoActivity().setAffectedFigures(new FigureEnumerator(view().selection()));
d133 1
a133 1
	
d137 1
a137 1
	
d152 1
a152 1
		
d166 3
a168 3
			FigureEnumeration k = getAffectedFigures();
			while (k.hasMoreElements()) {
				Figure f = k.nextFigure();
d172 1
a172 1
				f.moveBy(-currentPoint.x + originalPoint.x, 
d175 1
a175 1
			
d185 1
a185 1
		}		
d190 1
a190 1
		
d198 1
a198 1
		
d202 1
a202 1
		
d207 2
a208 2
	
			while (fe.hasMoreElements()) {
d219 1
a219 1
			while (copyFe.hasMoreElements()) {
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d28 65
a92 65
	    /**
	     * align left sides
	     */
	    public final static Alignment LEFTS = new Alignment("Lefts") {
	    	public void moveBy(Figure f, Rectangle anchor) {
	            Rectangle rr = f.displayBox();
                f.moveBy(anchor.x-rr.x, 0);
	    	}
	    };
	
	    /**
	     * align centers (horizontally)
	     */
	    public final static Alignment CENTERS = new Alignment("Centers") {
	    	public void moveBy(Figure f, Rectangle anchor) {
	            Rectangle rr = f.displayBox();
                f.moveBy((anchor.x+anchor.width/2) - (rr.x+rr.width/2), 0);
	    	}
	    };
	
	    /**
	     * align right sides
	     */
	    public final static Alignment RIGHTS = new Alignment("Rights") {
	    	public void moveBy(Figure f, Rectangle anchor) {
	            Rectangle rr = f.displayBox();
                f.moveBy((anchor.x+anchor.width) - (rr.x+rr.width), 0);
	    	}
	    };
	
	    /**
	     * align tops
	     */
	    public final static Alignment TOPS = new Alignment("Tops") {
	    	public void moveBy(Figure f, Rectangle anchor) {
	            Rectangle rr = f.displayBox();
                f.moveBy(0, anchor.y-rr.y);
	    	}
	    };
	
	    /**
	     * align middles (vertically)
	     */
	    public final static Alignment MIDDLES = new Alignment("Middles") {
	    	public void moveBy(Figure f, Rectangle anchor) {
	            Rectangle rr = f.displayBox();
                f.moveBy(0, (anchor.y+anchor.height/2) - (rr.y+rr.height/2));
	    	}
	    };
	
	    /**
	     * align bottoms
	     */
	    public final static Alignment BOTTOMS = new Alignment("Bottoms") {
	    	public void moveBy(Figure f, Rectangle anchor) {
	            Rectangle rr = f.displayBox();
                f.moveBy(0, (anchor.y+anchor.height) - (rr.y+rr.height));
	    	}
	    };
	    
	    private String myDescription;
	    
	    private Alignment(String newDescription) {
	    	setDescription(newDescription);
	    }
d103 1
a103 1
	    	myDescription = newDescription;
d106 1
a106 1
	    public abstract void moveBy(Figure f, Rectangle anchor);
d109 1
a109 1
    private Alignment myAlignment;
d111 9
a119 9
    /**
     * Constructs an alignment command.
     * @@param newAlignment the alignment operation (LEFTS, CENTERS, RIGHTS, etc.)
     * @@param view the target view
     */
    public AlignCommand(Alignment newAlignment, DrawingView view) {
        super(newAlignment.getDescription(), view);
        setAlignment(newAlignment);
    }
d121 3
a123 3
    public boolean isExecutable() {
        return view().selectionCount() > 1;
    }
d125 5
a129 4
    public void execute() {
    	setUndoActivity(createUndoActivity());
    	// get selected figures in the order the figures have been selected
    	getUndoActivity().setAffectedFigures(new FigureEnumerator(view().selection()));
d131 10
a140 10
        view().checkDamage();
    }
    
    protected void setAlignment(Alignment newAlignment) {
        myAlignment = newAlignment;
    }
    
    public Alignment getAlignment() {
    	return myAlignment;
    }
d166 10
a175 10
	        FigureEnumeration k = getAffectedFigures();
	        while (k.hasMoreElements()) {
	            Figure f = k.nextFigure();
	            Point originalPoint = getOriginalPoint(f);
	            Point currentPoint = f.displayBox().getLocation();
	            // substract current lcoation to get to 0,0 and then move to original location
	            f.moveBy(-currentPoint.x + originalPoint.x, 
	            		 -currentPoint.y + originalPoint.y);
	        }
	        
d204 8
a211 8
	        FigureEnumeration fe = getAffectedFigures();
	        Figure anchorFigure = fe.nextFigure();
	        Rectangle r = anchorFigure.displayBox();
	
	        while (fe.hasMoreElements()) {
	            Figure f = fe.nextFigure();
	            applyAlignment.moveBy(f, r);
	        }
d218 4
a221 4
	        FigureEnumeration copyFe = getAffectedFigures();
	        while (copyFe.hasMoreElements()) {
            	addOriginalPoint(copyFe.nextFigure());
	        }
@


1.4
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)AlignCommand.java 5.2
d4 6
d14 3
a19 3
import CH.ifa.draw.util.Command;
import CH.ifa.draw.framework.*;

d22 2
d25 1
a25 4
public class AlignCommand extends Command {

    private DrawingView fView;
    private int fOp;
d27 92
a118 36
   /**
    * align left sides
    */
    public final static int LEFTS = 0;
   /**
    * align centers (horizontally)
    */
    public final static int CENTERS = 1;
   /**
    * align right sides
    */
    public final static int RIGHTS = 2;
   /**
    * align tops
    */
    public final static int TOPS = 3;
   /**
    * align middles (vertically)
    */
    public final static int MIDDLES = 4;
   /**
    * align bottoms
    */
    public final static int BOTTOMS = 5;


   /**
    * Constructs an alignment command.
    * @@param name the command name
    * @@param view the target view
    * @@param op the alignment operation (LEFTS, CENTERS, RIGHTS, etc.)
    */
    public AlignCommand(String name, DrawingView view, int op) {
        super(name);
        fView = view;
        fOp = op;
d122 1
a122 1
        return fView.selectionCount() > 1;
d126 5
a130 29
        FigureEnumeration selection = fView.selectionElements();
        Figure anchorFigure = selection.nextFigure();
        Rectangle r = anchorFigure.displayBox();

        while (selection.hasMoreElements()) {
            Figure f = selection.nextFigure();
            Rectangle rr = f.displayBox();
            switch (fOp) {
            case LEFTS:
                f.moveBy(r.x-rr.x, 0);
                break;
            case CENTERS:
                f.moveBy((r.x+r.width/2) - (rr.x+rr.width/2), 0);
                break;
            case RIGHTS:
                f.moveBy((r.x+r.width) - (rr.x+rr.width), 0);
                break;
            case TOPS:
                f.moveBy(0, r.y-rr.y);
                break;
            case MIDDLES:
                f.moveBy(0, (r.y+r.height/2) - (rr.y+rr.height/2));
                break;
            case BOTTOMS:
                f.moveBy(0, (r.y+r.height) - (rr.y+rr.height));
                break;
            }
        }
        fView.checkDamage();
d132 91
a223 2


@


1.3
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d11 1
d17 1
a17 1
public class AlignCommand extends AbstractCommand {
d19 1
d55 2
a56 1
        super(name, view);
d61 1
a61 1
        return view().selectionCount() > 1;
d65 1
a65 1
        FigureEnumeration selection = view().selectionElements();
d93 1
a93 1
        view().checkDamage();
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@a10 1
import CH.ifa.draw.util.Command;
d16 1
a16 1
public class AlignCommand extends Command {
a17 1
    private DrawingView fView;
d53 1
a53 2
        super(name);
        fView = view;
d58 1
a58 1
        return fView.selectionCount() > 1;
d62 1
a62 1
        FigureEnumeration selection = fView.selectionElements();
d90 1
a90 1
        fView.checkDamage();
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)AlignCommand.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
