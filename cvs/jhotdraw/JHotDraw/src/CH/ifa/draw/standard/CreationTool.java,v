head	1.13;
access;
symbols
	jhotdraw54b2-release:1.13
	reorg_6x_split:1.13
	MVC_PHASE1:1.10.0.4
	NEW_ATTRIBUTES:1.10.0.2
	DNOYEB1_ALPHA-2:1.9.4.10
	release_JHD54b1:1.10
	BUGFIX_670992:1.9.0.6
	DNOYEB1_ALPHA-1:1.9.4.8
	dnoyeb1:1.9.0.4
	repack:1.9.0.2
	Root_repack:1.9
	Before_FigureVisitor:1.9
	JHotDraw_5-3:1.5
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2003.11.09.21.18.46;	author mrfloppy;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.20.14.58.25;	author ricardo_padilha;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.08.15.41.23;	author ricardo_padilha;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.30.00.27.27;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.07.12.27.27;	author mrfloppy;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.20.19.57.59;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.19.18.31.32;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.9.4.1
date	2003.01.04.15.20.51;	author dnoyeb;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.01.10.04.54.45;	author dnoyeb;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2003.01.13.03.14.03;	author dnoyeb;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2003.01.14.18.25.07;	author dnoyeb;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2003.01.16.15.59.18;	author dnoyeb;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.01.16.17.13.56;	author dnoyeb;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2003.01.17.21.56.04;	author dnoyeb;	state Exp;
branches;
next	1.9.4.8;

1.9.4.8
date	2003.01.21.00.04.37;	author dnoyeb;	state Exp;
branches;
next	1.9.4.9;

1.9.4.9
date	2003.01.26.00.51.07;	author dnoyeb;	state Exp;
branches;
next	1.9.4.10;

1.9.4.10
date	2003.01.26.15.58.49;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.13
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 * @@(#)CreationTool.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.event.MouseEvent;
import java.util.List;

import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.JHotDrawRuntimeException;
import CH.ifa.draw.util.CollectionsFactory;
import CH.ifa.draw.util.Undoable;

/**
 * A tool to create new figures. The figure to be
 * created is specified by a prototype.
 *
 * <hr>
 * <b>Design Patterns</b><P>
 * <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
 * <b><a href=../pattlets/sld029.htm>Prototype</a></b><br>
 * CreationTool creates new figures by cloning a prototype.
 * <hr>
 *
 * @@see Figure
 * @@see Object#clone
 *
 * @@version <$CURRENT_VERSION$>
 */
public class CreationTool extends AbstractTool {

	/**
	 * the list of currently added figures
	 * by: ricardo_padilha.
	 * description: This has been added to provide support for creation tools that
	 *              insert more than one figure to the drawing, for example, by
	 *              maintaining SHIFT down and clicking. However, this class still
	 *              maintains its normal behavior of creating only one figure. 
	 */
	private List    fAddedFigures;

	/**
	 * the currently created figure
	 */
	private Figure  fCreatedFigure;

	/**
	 * the figure that was actually added
	 * Note, this can be a different figure from the one which has been created.
	 */
	private Figure myAddedFigure;

	/**
	 * the prototypical figure that is used to create new figuresthe prototypical figure that is used to create new figures.
	 */
	private Figure  myPrototypeFigure;


	/**
	 * Initializes a CreationTool with the given prototype.
	 */
	public CreationTool(DrawingEditor newDrawingEditor, Figure prototype) {
		super(newDrawingEditor);
		setPrototypeFigure(prototype);
	}

	/**
	 * Constructs a CreationTool without a prototype.
	 * This is for subclassers overriding createFigure.
	 */
	protected CreationTool(DrawingEditor newDrawingEditor) {
		this(newDrawingEditor, null);
	}

	/**
	 * Sets the cross hair cursor.
	 */
	public void activate() {
		super.activate();
		if (isUsable()) {
			getActiveView().setCursor(new AWTCursor(java.awt.Cursor.CROSSHAIR_CURSOR));
		}
		setAddedFigures(CollectionsFactory.current().createList());
	}

	/**
	 * @@see CH.ifa.draw.framework.Tool#deactivate()
	 */
	public void deactivate() {
		setCreatedFigure(null);
		setAddedFigure(null);
		setAddedFigures(null);
		super.deactivate();
	}

	/**
	 * Creates a new figure by cloning the prototype.
	 */
	public void mouseDown(MouseEvent e, int x, int y) {
		super.mouseDown(e, x, y);
		setCreatedFigure(createFigure());
		setAddedFigure(getActiveView().add(getCreatedFigure()));
		getAddedFigure().displayBox(new Point(getAnchorX(), getAnchorY()), new Point(getAnchorX(), getAnchorY()));
	}

	/**
	 * Creates a new figure by cloning the prototype.
	 */
	protected Figure createFigure() {
		if (getPrototypeFigure() == null) {
			throw new JHotDrawRuntimeException("No protoype defined");
		}
		return (Figure)getPrototypeFigure().clone();
	}

	/**
	 * Adjusts the extent of the created figure
	 */
	public void mouseDrag(MouseEvent e, int x, int y) {
		if (getAddedFigure() != null) {
			getAddedFigure().displayBox(new Point(getAnchorX(), getAnchorY()), new Point(x, y));
		}
	}

	/**
	 * Checks if the created figure is empty. If it is, the figure
	 * is removed from the drawing.
	 * @@see Figure#isEmpty
	 */
	public void mouseUp(MouseEvent e, int x, int y) {
		if (getAddedFigure() != null && !getCreatedFigure().isEmpty()) {
			getAddedFigures().add(getAddedFigure());
		}
		else {
			getActiveView().remove(getAddedFigure());
		}

		if (getAddedFigures().isEmpty()) {
			setUndoActivity(null);
		}
		else {
			// use undo activity from paste command...
			setUndoActivity(createUndoActivity());
			// put created figure into a figure enumeration
			getUndoActivity().setAffectedFigures(new FigureEnumerator(getAddedFigures()));
		}
		editor().toolDone();
	}

	/**
	 * As the name suggests this CreationTool uses the Prototype design pattern.
	 * Thus, the prototype figure which is used to create new figures of the same
	 * type by cloning the original prototype figure.
	 * @@param newPrototypeFigure figure to be cloned to create new figures
	 */
	protected void setPrototypeFigure(Figure newPrototypeFigure) {
		myPrototypeFigure = newPrototypeFigure;
	}

	/**
	 * As the name suggests this CreationTool uses the Prototype design pattern.
	 * Thus, the prototype figure which is used to create new figures of the same
	 * type by cloning the original prototype figure.
	 * @@return figure to be cloned to create new figures
	 */
	protected Figure getPrototypeFigure() {
		return myPrototypeFigure;
	}

	/**
	 * Gets the list of currently added figure
	 */
	protected List getAddedFigures() {
		return fAddedFigures;
	}

	/**
	 * Sets the addedFigures attribute of the CreationTool object
	 */
	protected void setAddedFigures(List newAddedFigures) {
		fAddedFigures = newAddedFigures;
	}

	/**
	 * Gets the currently created figure
	 */
	protected Figure getCreatedFigure() {
		return fCreatedFigure;
	}

	/**
	 * Sets the createdFigure attribute of the CreationTool object
	 */
	protected void setCreatedFigure(Figure newCreatedFigure) {
		fCreatedFigure = newCreatedFigure;
	}

	/**
	 * Gets the figure that was actually added
	 * Note, this can be a different figure from the one which has been created.
	 */
	protected Figure getAddedFigure() {
		return myAddedFigure;
	}

	/**
	 * Sets the addedFigure attribute of the CreationTool object
	 */
	protected void setAddedFigure(Figure newAddedFigure) {
		myAddedFigure = newAddedFigure;
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new PasteCommand.UndoActivity(getActiveView());
	}
}@


1.12
log
@Added support for "batch" creation
@
text
@d143 2
a144 1
		} else {
d150 2
a151 1
		} else {
@


1.11
log
@Refactoring of Cursor:
- java.awt.Cursor (class) has been sistematically replaced with CH.ifa.draw.contrib.framework.Cursor (interface)
- a new default implementation of Cursor (interface) has been added: CH.ifa.draw.contrib.standard.AWTCursor
@
text
@d16 1
d21 1
d43 10
d93 11
d112 1
a112 1
		setAddedFigure(view().add(getCreatedFigure()));
d141 13
a153 14
		if (getAddedFigure() != null) {
			if (getCreatedFigure().isEmpty()) {
				drawing().remove(getAddedFigure());
				// nothing to undo
				setUndoActivity(null);
			}
			else {
				// use undo activity from paste command...
				setUndoActivity(createUndoActivity());

				// put created figure into a figure enumeration
				getUndoActivity().setAffectedFigures(new SingleFigureEnumerator(getAddedFigure()));
			}
			setAddedFigure(null);
a154 1
		setCreatedFigure(null);
d179 14
d225 1
a225 1
		return new PasteCommand.UndoActivity(view());
@


1.10
log
@prepare for 5.4 release: various bug fixes
@
text
@d14 6
a19 1
import CH.ifa.draw.framework.*;
a20 2
import java.awt.*;
import java.awt.event.MouseEvent;
a37 2


d79 1
a79 1
			getActiveView().setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
@


1.9
log
@removed remains of FigureAttributeConstant.getName() and some code-clean up
@
text
@a39 5
	 * the anchor point of the interaction
	 */
	private Point   fAnchorPoint;

	/**
d51 1
a51 1
	 * the prototypical figure that is used to create new figures.
d53 1
a53 1
	private Figure  fPrototype;
d61 1
a61 1
		fPrototype = prototype;
d86 1
a86 2
		setView((DrawingView)e.getSource());
		setAnchorPoint(new Point(x, y));
d89 1
a89 1
		getAddedFigure().displayBox(getAnchorPoint(), getAnchorPoint());
d96 1
a96 1
		if (fPrototype == null) {
d99 1
a99 1
		return (Figure) fPrototype.clone();
d107 1
a107 1
			getAddedFigure().displayBox(getAnchorPoint(), new Point(x,y));
d137 20
d191 1
a191 22

	/**
	 * The anchor point is usually the first mouse click performed with this tool.
	 *
	 * @@return the anchor point for the interaction
	 * @@see #mouseDown
	 */
	protected Point getAnchorPoint() {
		// SF bug-report id: #490752
		return fAnchorPoint;
	}


	/**
	 * Sets the anchorPoint attribute of the CreationTool object
	 *
	 * @@param newAnchorPoint  The new anchorPoint value
	 */
	protected void setAnchorPoint(Point newAnchorPoint) {
		fAnchorPoint = newAnchorPoint;
	}
}
@


1.9.4.1
log
@improved functionality of CompositeFigureCreationTool
added comments to some files.(probably overdid it)
@
text
@d102 1
a102 1
		if (fPrototype == null) {	//should be ASSERT and not runtime exception because this is a condition that should never happen!!! dnoyeb
@


1.9.4.2
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d17 1
a17 1

a40 3
	 * This is redundant. AbstractTool already has AnchorX and AnchorY which all
	 * other tools are using.
	 * @@deprecated
d90 3
a92 3
	public void mouseDown(DrawingViewMouseEvent dvme) {
		setView( dvme.getDrawingView() );
		setAnchorPoint(new Point(dvme.getX(), dvme.getY()));
d111 1
a111 1
	public void mouseDrag(DrawingViewMouseEvent dvme) {
d113 1
a113 1
			getAddedFigure().displayBox(getAnchorPoint(), new Point(dvme.getX(),dvme.getY()));
d122 1
a122 1
	public void mouseUp(DrawingViewMouseEvent dvme) {
a182 4
	 * @@deprecated use {@@link AbstractTool#getAnchorX() 
	 *			   AbstractTool.getAnchorX()} and {@@link AbstractTool#getAnchorY()
	 *             AbstractTool.getAnchorY()} instead.
	 *
d192 1
a192 3
	 * @@deprecated use {@@link AbstractTool#setAnchorX() 
	 *			   AbstractTool.setAnchorX()} and {@@link AbstractTool#setAnchorY()
	 *             AbstractTool.setAnchorY()} instead.
@


1.9.4.3
log
@1. javadoc comments and corrections and clarifications
2. Drawing no longer exposes its drawing change listener, but has a method for those who want the drawing to request all views of it to be updated.
3. all removeAll() methods in CompositeFigure now have single consistent implementation.
4. standardDrawing unlock calls notify instead of notifyAll since only 1 can grab the lock anyway.
@
text
@d186 2
a187 2
	 * @@deprecated use {@@link AbstractTool#getAnchorX 
	 *			   AbstractTool.getAnchorX()} and {@@link AbstractTool#getAnchorY
d199 2
a200 2
	 * @@deprecated use {@@link AbstractTool#setAnchorX
	 *			   AbstractTool.setAnchorX()} and {@@link AbstractTool#setAnchorY
@


1.9.4.4
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d97 1
a97 2
		view().add(getCreatedFigure());
		setAddedFigure(getCreatedFigure());
@


1.9.4.5
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@a140 1
			view().drawing().update();//we made a change to the drawing, so update it.
@


1.9.4.6
log
@Debugging exceptions added / cleanedup
@
text
@d106 2
a107 4
		if (fPrototype == null) {
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.			
			throw new JHotDrawRuntimeException("No protoype defined.");
@


1.9.4.7
log
@view addToSelection used drawing.includes(figure) but selectionZOrdered uses figures()
these are 2 different sets of figures.  changed addToSelection to use containsFigure()
Added some experimental copy constructors that are not being used.
some trivial comments.
@
text
@a29 3
 * Note: CreatedFigure and AddedFigure are now the same.  No longer does a
 * CompositeFigure change the added figure and return a different figure.
 *
@


1.9.4.8
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d100 2
a101 1
		setAddedFigure(view().add(getCreatedFigure()));
@


1.9.4.9
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d100 1
a100 2
		view().add(getCreatedFigure());
		setAddedFigure(getCreatedFigure());
@


1.9.4.10
log
@hack for [ 674973 ] Context Sensitive menu updates
add used instead of restore since its easier for the CompositeFigure to decide wether to add or
to restore.
@
text
@d193 1
a193 1
	 * @@todo use {@@link AbstractTool#getAnchorX 
d206 1
a206 1
	 * @@todo use {@@link AbstractTool#setAnchorX
@


1.8
log
@after variou merges... (before 5.4 release)
@
text
@d92 1
a92 1
		fAnchorPoint = new Point(x,y);
d94 2
a95 2
		setAddedFigure((view().add(getCreatedFigure())));
		getAddedFigure().displayBox(fAnchorPoint, fAnchorPoint);
d113 1
a113 1
			getAddedFigure().displayBox(fAnchorPoint, new Point(x,y));
@


1.7
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@a14 1
import CH.ifa.draw.util.UndoableAdapter;
d83 1
a83 1
			view().setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
d91 1
@


1.6
log
@no message
@
text
@d93 1
a93 1
		fCreatedFigure = createFigure();
d138 1
a138 1
		fCreatedFigure = null;
@


1.5
log
@no message
@
text
@a18 1
import java.util.Vector;
d75 1
a75 2
		super(newDrawingEditor);
		fPrototype = null;
d112 3
a114 1
		getAddedFigure().displayBox(fAnchorPoint, new Point(x,y));
d123 14
a136 11
		if (getCreatedFigure().isEmpty()) {
			drawing().remove(getAddedFigure());
			// nothing to undo
			setUndoActivity(null);
		}
		else {
			// use undo activity from paste command...
			setUndoActivity(createUndoActivity());

			// put created figure into a figure enumeration
			getUndoActivity().setAffectedFigures(new SingleFigureEnumerator(getAddedFigure()));
a138 1
		setAddedFigure(null);
d149 4
a152 1
	private void setCreatedFigure(Figure newCreatedFigure) {
d164 4
a167 1
	private void setAddedFigure(Figure newAddedFigure) {
d187 10
@


1.4
log
@merge dnd (before 5.3)
@
text
@d56 1
a56 1
	
d131 1
a131 1
			
d150 1
a150 1
	
d168 11
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d66 2
a67 2
	public CreationTool(DrawingView view, Figure prototype) {
		super(view);
d75 2
a76 2
	protected CreationTool(DrawingView view) {
		super(view);
d84 4
a87 1
		view().setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
d162 1
a162 1
	
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)CreationTool.java 5.2
d4 6
d14 3
d19 1
a19 2

import CH.ifa.draw.framework.*;
d31 1
d34 2
d41 125
a165 84
    /**
     * the anchor point of the interaction
     */
    private Point   fAnchorPoint;

    /**
     * the currently created figure
     */
    private Figure  fCreatedFigure;

    /**
     * the prototypical figure that is used to create new figures.
     */
    private Figure  fPrototype;


    /**
     * Initializes a CreationTool with the given prototype.
     */
    public CreationTool(DrawingView view, Figure prototype) {
        super(view);
        fPrototype = prototype;
    }

    /**
     * Constructs a CreationTool without a prototype.
     * This is for subclassers overriding createFigure.
     */
    protected CreationTool(DrawingView view) {
        super(view);
        fPrototype = null;
    }

    /**
     * Sets the cross hair cursor.
     */
    public void activate() {
        view().setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
    }

    /**
     * Creates a new figure by cloning the prototype.
     */
    public void mouseDown(MouseEvent e, int x, int y) {
        fAnchorPoint = new Point(x,y);
        fCreatedFigure = createFigure();
        fCreatedFigure.displayBox(fAnchorPoint, fAnchorPoint);
        view().add(fCreatedFigure);
    }

    /**
     * Creates a new figure by cloning the prototype.
     */
    protected Figure createFigure() {
        if (fPrototype == null)
		    throw new HJDError("No protoype defined");
        return (Figure) fPrototype.clone();
    }

    /**
     * Adjusts the extent of the created figure
     */
    public void mouseDrag(MouseEvent e, int x, int y) {
        fCreatedFigure.displayBox(fAnchorPoint, new Point(x,y));
    }

    /**
     * Checks if the created figure is empty. If it is, the figure
     * is removed from the drawing.
     * @@see Figure#isEmpty
     */
    public void mouseUp(MouseEvent e, int x, int y) {
        if (fCreatedFigure.isEmpty())
            drawing().remove(fCreatedFigure);
        fCreatedFigure = null;
        editor().toolDone();
    }

    /**
     * Gets the currently created figure
     */
    protected Figure createdFigure() {
        return fCreatedFigure;
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)CreationTool.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
