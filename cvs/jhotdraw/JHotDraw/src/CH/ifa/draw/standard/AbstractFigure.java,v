head	1.11;
access;
symbols
	jhotdraw54b2-release:1.11
	reorg_6x_split:1.11
	MVC_PHASE1:1.11.0.4
	NEW_ATTRIBUTES:1.11.0.2
	DNOYEB1_ALPHA-2:1.9.4.15
	release_JHD54b1:1.10
	BUGFIX_670992:1.9.0.6
	DNOYEB1_ALPHA-1:1.9.4.14
	dnoyeb1:1.9.0.4
	repack:1.9.0.2
	Root_repack:1.9
	Before_FigureVisitor:1.8
	JHotDraw_5-3:1.6
	JHotDraw_5-2_merged:1.3
	JHotDraw_5-1_initial:1.2
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2003.02.04.05.06.06;	author ricardo_padilha;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.30.00.27.26;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.22.08.58.22;	author mrfloppy;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.30.20.40.07;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.44.33;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.12.16.13.31;	author jeckel;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches;
next	;

1.9.4.1
date	2003.01.08.22.12.57;	author dnoyeb;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.01.13.03.14.03;	author dnoyeb;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2003.01.14.18.24.25;	author dnoyeb;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2003.01.14.20.32.43;	author dnoyeb;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2003.01.15.21.04.21;	author dnoyeb;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.01.16.06.03.53;	author dnoyeb;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2003.01.16.15.58.50;	author dnoyeb;	state Exp;
branches;
next	1.9.4.8;

1.9.4.8
date	2003.01.16.17.13.56;	author dnoyeb;	state Exp;
branches;
next	1.9.4.9;

1.9.4.9
date	2003.01.16.22.38.46;	author dnoyeb;	state Exp;
branches;
next	1.9.4.10;

1.9.4.10
date	2003.01.17.01.53.00;	author dnoyeb;	state Exp;
branches;
next	1.9.4.11;

1.9.4.11
date	2003.01.17.17.40.44;	author dnoyeb;	state Exp;
branches;
next	1.9.4.12;

1.9.4.12
date	2003.01.17.21.56.03;	author dnoyeb;	state Exp;
branches;
next	1.9.4.13;

1.9.4.13
date	2003.01.18.04.49.04;	author dnoyeb;	state Exp;
branches;
next	1.9.4.14;

1.9.4.14
date	2003.01.21.00.04.34;	author dnoyeb;	state Exp;
branches;
next	1.9.4.15;

1.9.4.15
date	2003.01.26.00.51.06;	author dnoyeb;	state Exp;
branches;
next	1.9.4.16;

1.9.4.16
date	2003.02.02.16.54.09;	author dnoyeb;	state Exp;
branches;
next	1.9.4.17;

1.9.4.17
date	2003.02.03.19.21.17;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Removed an unused local variable from method "visit(FigureVisitor)".
@
text
@/*
 * @@(#)AbstractFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.standard;

import CH.ifa.draw.util.*;
import CH.ifa.draw.framework.*;

import java.awt.*;
import java.util.List;
import java.io.*;

/**
 * AbstractFigure provides default implementations for
 * the Figure interface.
 *
 * <hr>
 * <b>Design Patterns</b><P>
 * <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
 * <b><a href=../pattlets/sld036.htm>Template Method</a></b><br>
 * Template Methods implement default and invariant behavior for
 * figure subclasses.
 * <hr>
 *
 * @@see Figure
 * @@see Handle
 *
 * @@version <$CURRENT_VERSION$>
 */
public abstract class AbstractFigure implements Figure {

	/**
	 * The listeners for a figure's changes.
	 * It is only one listener but this one can be a (chained) MultiCastFigureChangeListener
	 * @@see #invalidate
	 * @@see #changed
	 * @@see #willChange
	 */
	private transient FigureChangeListener fListener;

	/**
	 * The dependend figures which have been added to this container.
	 */
	private List myDependendFigures;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = -10857585979273442L;
	private int abstractFigureSerializedDataVersion = 1;
	private int _nZ;

	protected AbstractFigure() {
		 myDependendFigures = CollectionsFactory.current().createList();
	}

	/**
	 * Moves the figure by the given offset.
	 */
	public void moveBy(int dx, int dy) {
		willChange();
		basicMoveBy(dx, dy);
		changed();
	}

	/**
	 * Moves the figure. This is the
	 * method that subclassers override. Clients usually
	 * call displayBox.
	 * @@see #moveBy
	 */
	protected abstract void basicMoveBy(int dx, int dy);

	/**
	 * Changes the display box of a figure. Clients usually
	 * call this method. It changes the display box
	 * and announces the corresponding change.
	 * @@param origin the new origin
	 * @@param corner the new corner
	 * @@see #displayBox
	 */
	public void displayBox(Point origin, Point corner) {
		willChange();
		basicDisplayBox(origin, corner);
		changed();
	}

	/**
	 * Sets the display box of a figure. This is the
	 * method that subclassers override. Clients usually
	 * call displayBox.
	 * @@see #displayBox
	 */
	public abstract void basicDisplayBox(Point origin, Point corner);

	/**
	 * Gets the display box of a figure.
	 */
	public abstract Rectangle displayBox();

	/**
	 * Returns the handles of a Figure that can be used
	 * to manipulate some of its attributes.
	 * @@return a type-safe iterator of handles
	 * @@see Handle
	 */
	public abstract HandleEnumeration handles();

	/**
	 * Returns an Enumeration of the figures contained in this figure.
	 * @@see CompositeFigure
	 */
	public FigureEnumeration figures() {
		return FigureEnumerator.getEmptyEnumeration();
	}

	/**
	 * Gets the size of the figure. A convenience method.
	 */
	public Dimension size() {
		return new Dimension(displayBox().width, displayBox().height);
	}

	/**
	 * Checks if the figure is empty. The default implementation returns
	 * true if the width or height of its display box is < 3
	 * @@see Figure#isEmpty
	 */
	public boolean isEmpty() {
		return (size().width < 3) || (size().height < 3);
	}

	/**
	 * Returns the figure that contains the given point.
	 * In contrast to containsPoint it returns its
	 * innermost figure that contains the point.
	 *
	 * @@see #containsPoint
	 */
	public Figure findFigureInside(int x, int y) {
		if (containsPoint(x, y)) {
			return this;
		}
		return null;
	}

	/**
	 * Checks if a point is inside the figure.
	 */
	public boolean containsPoint(int x, int y) {
		return displayBox().contains(x, y);
	}

	/**
	 * Changes the display box of a figure. This is a
	 * convenience method. Implementors should only
	 * have to override basicDisplayBox
	 * @@see #displayBox
	 */
	public void displayBox(Rectangle r) {
		displayBox(new Point(r.x, r.y), new Point(r.x+r.width, r.y+r.height));
	}

	/**
	 * Checks whether the given figure is contained in this figure.
	 */
	public boolean includes(Figure figure) {
		return figure == this;
	}

	/**
	 * Decomposes a figure into its parts. It returns a FigureEnumeration
	 * that contains itself.
	 * @@return an Enumeration with itself as the only element.
	 */
	public FigureEnumeration decompose() {
		List figures = CollectionsFactory.current().createList(1);
		figures.add(this);
		return new FigureEnumerator(figures);
	}

	/**
	 * Sets the Figure's container and registers the container
	 * as a figure change listener. A figure's container can be
	 * any kind of FigureChangeListener. A figure is not restricted
	 * to have a single container.
	 */
	public void addToContainer(FigureChangeListener c) {
		addFigureChangeListener(c);
		invalidate();
	}

	/**
	 * Removes a figure from the given container and unregisters
	 * it as a change listener.
	 */
	public void removeFromContainer(FigureChangeListener c) {
		invalidate();
		removeFigureChangeListener(c);
	}

	/**
	 * Adds a listener for this figure.
	 */
	public synchronized void addFigureChangeListener(FigureChangeListener l) {
		fListener = FigureChangeEventMulticaster.add(listener(), l);
	}

	/**
	 * Removes a listener for this figure.
	 */
	public synchronized void removeFigureChangeListener(FigureChangeListener l) {
		fListener = FigureChangeEventMulticaster.remove(listener(), l);
	}

	/**
	 * Gets the figure's listners.
	 */
	public synchronized FigureChangeListener listener() {
		return fListener;
	}

	/**
	 * A figure is released from the drawing. You never call this
	 * method directly. Release notifies its listeners.
	 * @@see Figure#release
	 */
	public void release() {
		if (listener() != null) {
			listener().figureRemoved(new FigureChangeEvent(this));
		}
	}

	/**
	 * Invalidates the figure. This method informs the listeners
	 * that the figure's current display box is invalid and should be
	 * refreshed.
	 */
	public void invalidate() {
		if (listener() != null) {
			Rectangle r = invalidateRectangle(displayBox());
			listener().figureInvalidated(new FigureChangeEvent(this, r));
		}
	}

	/**
	 * Hook method to change the rectangle that will be invalidated
	 */
	protected Rectangle invalidateRectangle(Rectangle r) {
		r.grow(Handle.HANDLESIZE, Handle.HANDLESIZE);
		return r;
	}

	/**
	 * Informes that a figure is about to change something that
	 * affects the contents of its display box.
	 *
	 * @@see Figure#willChange
	 */
	public void willChange() {
		// call invalidate before the change occurs to invalidate the old display area
		invalidate();
	}

	/**
	 * Informs that a figure changed the area of its display box.
	 *
	 * @@see FigureChangeEvent
	 * @@see Figure#changed
	 */
	public void changed() {
		invalidate();
		if (listener() != null) {
			listener().figureChanged(new FigureChangeEvent(this));
		}
	}

	/**
	 * Gets the center of a figure. A convenice
	 * method that is rarely overridden.
	 */
	public Point center() {
		return Geom.center(displayBox());
	}

	/**
	 * Checks if this figure can be connected. By default
	 * AbstractFigures can be connected.
	 */
	public boolean canConnect() {
		return true;
	}

	/**
	 * Returns the connection inset. The connection inset
	 * defines the area where the display box of a
	 * figure can't be connected. By default the entire
	 * display box can be connected.
	 *
	 */
	public Insets connectionInsets() {
		return new Insets(0, 0, 0, 0);
	}

	/**
	 * Returns the Figures connector for the specified location.
	 * By default a ChopBoxConnector is returned.
	 * @@see ChopBoxConnector
	 */
	public Connector connectorAt(int x, int y) {
		return new ChopBoxConnector(this);
	}

	/**
	 * Sets whether the connectors should be visible.
	 * By default they are not visible
	 */
	public void connectorVisibility(boolean isVisible, ConnectionFigure connector) {
	}

	/**
	 * Returns the locator used to located connected text.
	 */
	public Locator connectedTextLocator(Figure text) {
		return RelativeLocator.center();
	}

	/**
	 * Returns the named attribute or null if a
	 * a figure doesn't have an attribute.
	 * By default figures don't have any attributes so getAttribute
	 * returns null.
	 *
	 * @@deprecated use getAttribute(FigureAttributeConstant) instead
	 */
	public Object getAttribute(String name) {
		return null;
	}

	/**
	 * Returns the named attribute or null if a
	 * a figure doesn't have an attribute.
	 * By default figures don't have any attributes getAttribute
	 * returns null.
	 */
	public Object getAttribute(FigureAttributeConstant attributeConstant) {
		return null;
	}

	/**
	 * Sets the named attribute to the new value. By default
	 * figures don't have any attributes and the request is ignored.
	 *
	 * @@deprecated use setAttribute(FigureAttributeConstant, Object) instead
	 */
	public void setAttribute(String name, Object value) {
	}

	/**
	 * Sets the named attribute to the new value. By default
	 * figures don't have any attributes and the request is ignored.
	 */
	public void setAttribute(FigureAttributeConstant attributeConstant, Object value) {
	}

	/**
	 * Clones a figure. Creates a clone by using the storable
	 * mechanism to flatten the Figure to stream followed by
	 * resurrecting it from the same stream.
	 *
	 * @@see Figure#clone
	 */
	public Object clone() {
		Object clone = null;
		ByteArrayOutputStream output = new ByteArrayOutputStream(200);
		try {
			ObjectOutput writer = new ObjectOutputStream(output);
			writer.writeObject(this);
			writer.close();
		}
		catch (IOException e) {
			System.err.println("Class not found: " + e);
		}

		InputStream input = new ByteArrayInputStream(output.toByteArray());
		try {
			ObjectInput reader = new ObjectInputStream(input);
			clone = reader.readObject();
		}
		catch (IOException e) {
			System.err.println(e.toString());
		}
		catch (ClassNotFoundException e) {
			System.err.println("Class not found: " + e);
		}
		return clone;
	}

	/**
	 * Stores the Figure to a StorableOutput.
	 */
	public void write(StorableOutput dw) {
	}

	/**
	 * Reads the Figure from a StorableInput.
	 */
	public void read(StorableInput dr) throws IOException {
	}

	/**
	 * Gets the z value (back-to-front ordering) of this figure.
	 */
	public int getZValue() {
	  return _nZ;
	}

	/**
	 * Sets the z value (back-to-front ordering) of this figure.
	 */
	public void setZValue(int z) {
	  _nZ = z;
	}

	public void visit(FigureVisitor visitor) {
		// remember original listener as listeners might be changed by a visitor
		// (e.g. by calling addToContainer() or removeFromContainer())
		//FigureChangeListener originalListener = listener();
		FigureEnumeration fe = getDependendFigures();

		visitor.visitFigure(this);

		FigureEnumeration visitFigures = figures();
		while (visitFigures.hasNextFigure()) {
			visitFigures.nextFigure().visit(visitor);
		}

		HandleEnumeration visitHandles = handles();
		while (visitHandles.hasNextHandle()) {
			visitor.visitHandle(visitHandles.nextHandle());
		}
/*
		originalListener = listener();
		if (originalListener != null) {
			visitor.visitFigureChangeListener(originalListener);
		}
*/

		while (fe.hasNextFigure()) {
			fe.nextFigure().visit(visitor);
			// or visitor.visitDependendFigure(fe.nextFigure());
		}
	}

	public synchronized FigureEnumeration getDependendFigures() {
		return new FigureEnumerator(myDependendFigures);
	}

	public synchronized void addDependendFigure(Figure newDependendFigure) {
		myDependendFigures.add(newDependendFigure);
	}

	public synchronized void removeDependendFigure(Figure oldDependendFigure) {
		myDependendFigures.remove(oldDependendFigure);
	}

	public TextHolder getTextHolder() {
		return null;
	}

	public Figure getDecoratedFigure() {
		return this;
	}	
}
@


1.10
log
@prepare for 5.4 release: various bug fixes
@
text
@d436 1
a436 1
		FigureChangeListener originalListener = listener();
@


1.9
log
@introduce FigureVisitor for paste/delete commands
@
text
@d478 4
@


1.9.4.1
log
@1.  Encapsulated the useage of FigureChangeListener on ContainerFigure.  ContainerFigure does no longer implement
    FigureChangeListener, but has an inner class for that.  All of the FigureChangeListener methods on
    the CompositeFigure class are now protected.  Subclasses as well.

2.  Drawing no longer implements FigureChangeListener.  defers to implementatations to subclass or implement that.

3.  FindFigureInside fixed.  waiting on better fix with Strategy Pattern from mrfloppy.
@
text
@d269 1
a269 2
		// call invalidate before the change occurs to invalidate the old display area.
		//why? the old display area is not invalid until the move takes place.
@


1.9.4.2
log
@1. javadoc comments and corrections and clarifications
2. Drawing no longer exposes its drawing change listener, but has a method for those who want the drawing to request all views of it to be updated.
3. all removeAll() methods in CompositeFigure now have single consistent implementation.
4. standardDrawing unlock calls notify instead of notifyAll since only 1 can grab the lock anyway.
@
text
@a264 2
	 * Causes the current display box to be marked as dirty and in need of
	 * redraw.  The redraw does not occur as a result of this method call.
a266 1
	 * @@see Figure#invalidate
d269 2
a275 2
	 * Causes the current display box to be marked as dirty and in need of
	 * redraw.  The redraw does not occur as a result of this method call.
a277 1
	 * @@see FigureChangeListener
a278 1
	 * @@see Figure#invalidate
a325 5
	 * It was an error to add this.  If you need visible connectors, what you 
	 * really need is another Figure that contains a connector.  perhaps
	 * ConnectionFigures should not be real figures, but something else.  having
	 * them as figures misleads one into this path.
	 * Am I correct in this assesment? ???dnoyeb???
@


1.9.4.3
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d48 1
a48 4
	/**
	 * needs cloneing !!!dnoyeb!!!
	 */
	private FigureChangeListener container;
a50 1
	 * needs to be cloned too right ???dnoyeb???
a58 4
	/**
	 * needs cloning unless the z order is preserved in the context/order of
	 * the saved figures somehow.
	 */
d193 2
a194 3
	 * any kind of FigureChangeListener. A figure may have only a single container.
	 *
	 * @@see Figure
d197 2
a198 6
		if(getContainer() != null){
			throw new JHotDrawRuntimeException("This figure is already contained.");
		}
		setContainer( c );
		addFigureChangeListener(getContainer());
		invalidate();		
d202 2
a203 5
	 * A callback from the container in response to the event fired by {@@link
	 * #remove remove}.  This method does the actual removal from the container.
	 * Do not fire <code>figureRequestRemove</code> from this method.
	 *
	 * @@see Figure#removeFromContainer
a205 3
		if( getContainer() == null ) {
			throw new JHotDrawRuntimeException("This figure is not contained.");
		}
d207 1
a207 2
		removeFigureChangeListener( getContainer() );
		setContainer( null );
d227 1
a227 1
	protected synchronized FigureChangeListener listener() {
d232 2
d237 2
a238 15
//		if(still contained) {
//			throw new JHotDrawRuntimeException("Figure can note be released, it has not been removed yet.");
//		}
		if(listener() != null) {
			listener().figureRemoved( new FigureChangeEvent(this));
		}
	}
	
	/**
	 * Called to remove a figure from its container.
	 * @@see Figure#remove
	 */
	public void remove(){
		if(listener() != null) {
			listener().figureRequestRemove( new FigureChangeEvent(this));
a253 6
	public void update() {
		invalidate();
		if (listener() != null) {
			listener().figureRequestUpdate(new FigureChangeEvent(this));
		}		
	}
d447 1
a447 1
		//FigureChangeListener originalListener = listener();
a487 6
	}
	protected FigureChangeListener getContainer() {
		return container;
	}
	protected void setContainer(FigureChangeListener container){
		this.container = container;
@


1.9.4.4
log
@File IO corrections.
@
text
@a42 3
	 *
	 * Need to figure out who restores this connection when the figure is reloaded !!!dnoyeb!!!
	 *
a47 1
	
d49 1
a49 2
	 * The container of this figure.  Used to prevent a figure from being added
	 * to more than one container at a time.
d51 1
a51 2
	private transient FigureChangeListener container;
	
d53 2
a54 6
	 * The dependent figures which have been added to this container.
	 * This is an ordered collection.  The figures should be stored in the order
	 * in which they were added.  The figures should be loaded in the order in
	 * which they were stored.
	 * @@see #read
	 * @@see #write
d56 1
a56 1
	private transient List myDependentFigures;
d70 1
a70 1
		 myDependentFigures = CollectionsFactory.current().createList();
a458 12
		//store dependentFigures
		FigureEnumeration fe;
		//only way to make sure size matches is to synchronize on this object
		//a thread safe collection would not work. dnoyeb
		synchronized(myDependentFigures){
			dw.writeInt( myDependentFigures.size() );
			fe = getDependendFigures();
			//this while loop does not need to by synchronized if the enumeration is thread safe
			while (fe.hasNextFigure()) {
				dw.writeStorable(fe.nextFigure());
			}
		}
a464 22
		//load dependentFigures
		int size = dr.readInt();
		myDependentFigures = CollectionsFactory.current().createList(size);
		for (int i=0; i<size; i++) {
			myDependentFigures.add( (Figure)dr.readStorable()) ;
		}
	}
	/**
	 * @@todo implement this.
	 */
	private void writeObject(ObjectOutputStream s) throws IOException {
		//s.defaultWriteObject();
		throw new IOException("writeObject not implemented for AbstractFigure.");
	}
	/**
	 * Used for the cloning mechanism. !?!
	 * @@todo implement this.
	 */
	private void readObject(ObjectInputStream s) 
		throws ClassNotFoundException, IOException {
		//s.defaultReadObject();//Read the non-static and non-transient fields of the current class from this stream.
		throw new IOException("readObject not implemented for AbstractFigure.");	
d466 1
d511 2
a512 4
	public FigureEnumeration getDependendFigures() {
		synchronized(myDependentFigures){
			return new FigureEnumerator(myDependentFigures);
		}
d515 2
a516 4
	public void addDependendFigure(Figure newDependendFigure) {
		synchronized(myDependentFigures){
			myDependentFigures.add(newDependendFigure);
		}
d519 2
a520 4
	public synchronized void removeDependendFigure(Figure oldDependentFigure) {
		synchronized(myDependentFigures){
			myDependentFigures.remove(oldDependentFigure);
		}
@


1.9.4.5
log
@
Lets have a moment of silence for DecoratorFigure.....It was a good figure ;{

Anything which happens inside the drawing after figure add must be undone before figure orphan.  It must also not
be exposed to anyobject outside the drawing.
Decorator figure retired in favor of a figureManipulator and the other functions being implemented by a composite
figure(BorderDecorator).
AdnimationDecorator retired in favor of AnimationManipulator.
A figure can have only 1 container. This is making the border tool have a hard time.

Lots of comments added

next phase:
orphan will disappear.  only add and remove remain.  All figure related resources belong to the figures and no other
object should care about figure.release.
split the figureListener into a figureContainer listener and a figureChangeListener.
Fix BorderDecorator.
Fix ConnectedText.
view.checkDamage to call drawing.update()
@
text
@a18 1
import java.util.Iterator;
a62 1
	 * do dependent figures depend on us, or do we depend on them? ???dnoyeb???
d66 1
a66 3
	private List myDependentFigures;

	private List fFigureManipulators;
d80 1
a80 1
		 init();
a82 4
	protected void init(){
		myDependentFigures = CollectionsFactory.current().createList();
		fFigureManipulators = CollectionsFactory.current().createList();
	}
a261 1
	 * releases figure from all containers pending release.
d265 5
a269 2
		if( getContainer() != null ) {
			throw new JHotDrawRuntimeException("Figure can note be released, it has not been removed yet.");
d471 9
a479 8
		dw.writeInt( myDependentFigures.size() );
		fe = getDependendFigures();
		while (fe.hasNextFigure()) {
			dw.writeStorable(fe.nextFigure());
		}
		dw.writeInt( fFigureManipulators.size() );
		for(Iterator it= fFigureManipulators.iterator();it.hasNext();) {
			dw.writeStorable( (FigureManipulator)it.next() );
a492 7

		//load figureManipulators
		int stratSize = dr.readInt();
		fFigureManipulators = CollectionsFactory.current().createList(stratSize);
		for (int i=0; i<size; i++) {
			fFigureManipulators.add( (FigureManipulator)dr.readStorable()) ;
		}
d495 1
a495 1
	 * @@todo Verify implementation.
d498 2
a499 1
		s.defaultWriteObject();
a500 1

d503 1
a503 1
	 * @@todo Veify implementation, and specify what it should be.
d507 2
a508 3
		//since dependent figures are not transient, they get deserialized here
		//since FigureManipulators are not transient, they get deserialized here
		s.defaultReadObject();//Read the non-static and non-transient fields of the current class from this stream.
a579 14
	}
	
	public void addFigureManipulator(FigureManipulator fm) {
		synchronized(fFigureManipulators) {		
			fm.AttachFigure(this);
			fFigureManipulators.add( fm );
		}
	}
	
	public void removeFigureManipulator(FigureManipulator fm) {
		synchronized(fFigureManipulators) {
			fFigureManipulators.remove( fm );
			fm.DetachFigure(this);
		}
@


1.9.4.6
log
@New FigureDecorator using decorator pattern now installed.
A few other minor cleanups.
@
text
@a71 1
	private List fFigureDecorators;
a89 1
		fFigureDecorators = CollectionsFactory.current().createList();
a485 4
		dw.writeInt( fFigureDecorators.size() );
		for(Iterator it= fFigureDecorators.iterator();it.hasNext();) {
			dw.writeStorable( (Figure)it.next() );
		}		
d500 2
a501 2
		int manipSize = dr.readInt();
		fFigureManipulators = CollectionsFactory.current().createList(manipSize);
a504 6
		//load figureDecorators
		int decSize = dr.readInt();
		fFigureDecorators = CollectionsFactory.current().createList(decSize);
		for (int i=0; i<size; i++) {
			fFigureDecorators.add( (Figure)dr.readStorable()) ;
		}
a606 30
	}
	
	public void addFigureDecorator(FigureDecorator fd){
		synchronized(fFigureDecorators){
			fFigureDecorators.add( fd );
			fd.decorateFigure( this );
		}
		invalidate();
	}
	public void removeFigureDecorator(FigureDecorator fd){
		synchronized(fFigureDecorators){
			fd.undecorateFigure( this );
			fFigureDecorators.remove( fd );
		}
		invalidate();		
	}
	/**
	 * The returned iterator needs to be fail fast or something !?!dnoyeb!?!
	 */
	public java.util.Iterator figureDecorators(){
		return fFigureDecorators.iterator();
	}
	public void drawAll(Graphics g){
		draw(g);
		drawDecorators(g);
	}
	public void drawDecorators(Graphics g){
		for(Iterator it= fFigureDecorators.iterator();it.hasNext();) {
			((FigureDecorator)it.next()).draw(g);
		}		
@


1.9.4.7
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d285 1
a285 2
	public FigureChangeListener remove(){
		FigureChangeListener fcl =  getContainer();
a288 1
		return fcl;
@


1.9.4.8
log
@Debugging exceptions added / cleanedup
@
text
@a226 2
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.
a242 2
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.			
a276 2
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.			
@


1.9.4.9
log
@Various comments.
Fixed undo bug which always restored dependent figures, even if they were deleted in a
seperate operation.
@
text
@a291 5
		if( getContainer() == null ) {
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.			
			throw new JHotDrawRuntimeException("Figure can note be removed, it is not contained.");
		}			
d582 2
a583 2
			//fe.nextFigure().visit(visitor);
			visitor.visitDependendFigure(fe.nextFigure());
@


1.9.4.10
log
@Fix serialization error introduced lately by myself.
@
text
@d491 3
a493 3
		int size = myDependentFigures.size();
		FigureEnumeration fe = getDependendFigures();
		dw.writeInt( size );
a496 1
		//store figuremanipulators
a500 1
		//store figuredecorators
d521 1
a521 1
		for (int i=0; i<manipSize; i++) {
d527 1
a527 1
		for (int i=0; i<decSize; i++) {
@


1.9.4.11
log
@More containment state validation
CompositeFigure serilization fix for bug introduced by myself lately.
@
text
@a230 5
		if(c == null){
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.
			throw new JHotDrawRuntimeException("Container parameter can not be null.");
		}
a248 5
		if(c == null){
			//This will become ASSERT in JDK 1.4
			//This represents an avoidable error on the programmers part.
			throw new JHotDrawRuntimeException("Container parameter can not be null.");
		}
a489 1
		dw.writeInt( getZValue() );
a512 1
		setZValue( dr.readInt() );
@


1.9.4.12
log
@view addToSelection used drawing.includes(figure) but selectionZOrdered uses figures()
these are 2 different sets of figures.  changed addToSelection to use containsFigure()
Added some experimental copy constructors that are not being used.
some trivial comments.
@
text
@a576 4
		//FigHolder = new AbstractFigure(this);
		
		
		
a676 20

	/**
	 * Experimental.  Copies everything.
	 */
	protected AbstractFigure(AbstractFigure af){
		_nZ = af._nZ;
		
		myDependentFigures = CollectionsFactory.current().createList( af.myDependentFigures.size() );
		myDependentFigures.addAll( af.myDependentFigures );

		fFigureManipulators = CollectionsFactory.current().createList( af.fFigureManipulators.size() );
		fFigureManipulators.addAll( af.fFigureManipulators );
		
		fFigureDecorators = CollectionsFactory.current().createList( af.fFigureDecorators.size() );
		fFigureDecorators.addAll( af.fFigureDecorators );
		
		fListener = af.fListener;
		container = af.container;
	}

@


1.9.4.13
log
@Decorator Figure returns...To apease the brave hearted :-)
Its not very well integrated with the current state of affairs.  It works as well as it always
has though.
@
text
@d226 5
a230 6
//this blocks duplicate containment.  currently border tool requires duplicate containment...
//		if(getContainer() != null){
//			//This will become ASSERT in JDK 1.4
//			//This represents an avoidable error on the programmers part.
//			throw new JHotDrawRuntimeException("This figure is already contained.");
//		}
d305 1
a305 1
			throw new JHotDrawRuntimeException("Figure can not be removed, it is not contained.");
@


1.9.4.14
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d606 2
a607 1
			fe.nextFigure().visit(visitor);
@


1.9.4.15
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d243 3
d287 1
a287 6
	 * This method is called by the container when it is releasing the figure
	 * it just fires an event on the figures listeners. to instruct everyone that i
	 * the figure has been removed from the certain container.
	 * THIS IS ONLY CALLED BY THE CONTAINER, see CompositeFigure.remove(Figure f)
	 *
	 * so far this event seems needless.
d291 5
d299 17
d578 3
a580 6
		//if we are already deleted, do not allow visit.
		if(visitor instanceof DeleteFromDrawingVisitor){
			if(getContainer() == null){
				return;
			}
		}
a587 4
		//do not visit dependencies on insert
		if(visitor instanceof InsertIntoDrawingVisitor){
			return;
		}
a588 1
		
@


1.9.4.16
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d284 6
@


1.9.4.17
log
@dependent figures save a reference to the figure they are dependent upon.
their is no need for the dependee to also save the reference.
reverting back to not saving dependent figures in abstractFigure as the main branch
does not save them here either.
@
text
@d61 6
a66 2
	 * These figures depend on us.  these figures are not stored by AbstractFigure
	 * but the link to abstractFigure is stored within the dependent figures.
d476 7
d500 7
@


1.8
log
@after variou merges... (before 5.4 release)
@
text
@d42 1
d49 5
d61 3
a63 1
	protected AbstractFigure() { }
d122 1
a122 1
		return new SingleFigureEnumerator(this);
d213 1
a213 1
	public void addFigureChangeListener(FigureChangeListener l) {
d220 1
a220 1
	public void removeFigureChangeListener(FigureChangeListener l) {
d227 1
a227 1
	public FigureChangeListener listener() {
d269 1
d396 1
a396 1
			clone = (Object) reader.readObject();
d431 46
@


1.7
log
@no message
@
text
@d18 1
a18 1
import java.util.*;
d104 1
a104 1
	 * @@return a Vector of handles
d107 1
a107 1
	public abstract Vector handles();
d114 1
a114 3
		Vector figures = new Vector(1);
		figures.addElement(this);
		return new FigureEnumerator(figures);
d172 1
a172 1
	 * Decomposes a figure into its parts. It returns a Vector
d174 1
a174 2
	 * @@return an Enumeration for a Vector with itself as the
	 * only element.
d177 2
a178 2
		Vector figures = new Vector(1);
		figures.addElement(this);
d317 1
a317 1
	public void connectorVisibility(boolean isVisible) {
@


1.6
log
@merge dnd (before 5.3)
@
text
@d209 1
a209 1
		fListener = FigureChangeEventMulticaster.add(fListener, l);
d216 1
a216 1
		fListener = FigureChangeEventMulticaster.remove(fListener, l);
d232 2
a233 2
		if (fListener != null) {
			fListener.figureRemoved(new FigureChangeEvent(this));
d243 3
a245 4
		if (fListener != null) {
			Rectangle r = displayBox();
			r.grow(Handle.HANDLESIZE, Handle.HANDLESIZE);
			fListener.figureInvalidated(new FigureChangeEvent(this, r));
d250 8
d275 2
a276 2
		if (fListener != null) {
			fListener.figureChanged(new FigureChangeEvent(this));
d333 1
a333 2
	 * By default
	 * figures don't have any attributes getAttribute
d335 2
d343 10
d355 2
d359 7
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@d357 1
a357 1
			System.out.println("Class not found: " + e);
d366 1
a366 1
			System.out.println(e.toString());
d369 1
a369 1
			System.out.println("Class not found: " + e);
@


1.4
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d2 1
a2 1
 * @@(#)AbstractFigure.java 5.2
d38 157
d196 8
a203 1
public abstract class AbstractFigure implements Figure {
d205 52
a256 160
    /**
     * The listeners for a figure's changes.
     * @@see #invalidate
     * @@see #changed
     * @@see #willChange
     */
    private transient FigureChangeListener fListener;

    /*
     * Serialization support.
     */
    private static final long serialVersionUID = -10857585979273442L;
    private int abstractFigureSerializedDataVersion = 1;
    private int _nZ;

    protected AbstractFigure() { }

    /**
     * Moves the figure by the given offset.
     */
    public void moveBy(int dx, int dy) {
        willChange();
        basicMoveBy(dx, dy);
        changed();
    }

    /**
     * Moves the figure. This is the
     * method that subclassers override. Clients usually
     * call displayBox.
     * @@see #moveBy
     */
    protected abstract void basicMoveBy(int dx, int dy);

    /**
     * Changes the display box of a figure. Clients usually
     * call this method. It changes the display box
     * and announces the corresponding change.
     * @@param origin the new origin
     * @@param corner the new corner
     * @@see #displayBox
     */
    public void displayBox(Point origin, Point corner) {
        willChange();
        basicDisplayBox(origin, corner);
        changed();
    }

    /**
     * Sets the display box of a figure. This is the
     * method that subclassers override. Clients usually
     * call displayBox.
     * @@see #displayBox
     */
    public abstract void basicDisplayBox(Point origin, Point corner);

    /**
     * Gets the display box of a figure.
     */
    public abstract Rectangle displayBox();

    /**
     * Returns the handles of a Figure that can be used
     * to manipulate some of its attributes.
     * @@return a Vector of handles
     * @@see Handle
     */
    public abstract Vector handles();

    /**
     * Returns an Enumeration of the figures contained in this figure.
     * @@see CompositeFigure
     */
    public FigureEnumeration figures() {
        Vector figures = new Vector(1);
        figures.addElement(this);
        return new FigureEnumerator(figures);
    }

    /**
     * Gets the size of the figure. A convenience method.
     */
    public Dimension size() {
        return new Dimension(displayBox().width, displayBox().height);
    }

    /**
     * Checks if the figure is empty. The default implementation returns
     * true if the width or height of its display box is < 3
     * @@see Figure#isEmpty
     */
    public boolean isEmpty() {
        return (size().width < 3) || (size().height < 3);
    }

    /**
     * Returns the figure that contains the given point.
     * In contrast to containsPoint it returns its
     * innermost figure that contains the point.
     *
     * @@see #containsPoint
     */
    public Figure findFigureInside(int x, int y) {
        if (containsPoint(x, y))
            return this;
        return null;
    }

    /**
     * Checks if a point is inside the figure.
     */
    public boolean containsPoint(int x, int y) {
        return displayBox().contains(x, y);
    }

    /**
     * Changes the display box of a figure. This is a
     * convenience method. Implementors should only
     * have to override basicDisplayBox
     * @@see #displayBox
     */
    public void displayBox(Rectangle r) {
        displayBox(new Point(r.x, r.y), new Point(r.x+r.width, r.y+r.height));
    }

    /**
     * Checks whether the given figure is contained in this figure.
     */
    public boolean includes(Figure figure) {
        return figure == this;
    }

    /**
     * Decomposes a figure into its parts. It returns a Vector
     * that contains itself.
     * @@return an Enumeration for a Vector with itself as the
     * only element.
     */
    public FigureEnumeration decompose() {
        Vector figures = new Vector(1);
        figures.addElement(this);
        return new FigureEnumerator(figures);
    }

    /**
     * Sets the Figure's container and registers the container
     * as a figure change listener. A figure's container can be
     * any kind of FigureChangeListener. A figure is not restricted
     * to have a single container.
     */
    public void addToContainer(FigureChangeListener c) {
        addFigureChangeListener(c);
        invalidate();
    }

    /**
     * Removes a figure from the given container and unregisters
     * it as a change listener.
     */
    public void removeFromContainer(FigureChangeListener c) {
d258 1
a258 2
        removeFigureChangeListener(c);
    }
d260 139
a398 191
    /**
     * Adds a listener for this figure.
     */
    public void addFigureChangeListener(FigureChangeListener l) {
        fListener = FigureChangeEventMulticaster.add(fListener, l);
    }

    /**
     * Removes a listener for this figure.
     */
    public void removeFigureChangeListener(FigureChangeListener l) {
        fListener = FigureChangeEventMulticaster.remove(fListener, l);
    }

    /**
     * Gets the figure's listners.
     */
    public FigureChangeListener listener() {
        return fListener;
    }

    /**
     * A figure is released from the drawing. You never call this
     * method directly. Release notifies its listeners.
     * @@see Figure#release
     */
    public void release() {
        if (fListener != null)
            fListener.figureRemoved(new FigureChangeEvent(this));
    }

    /**
     * Invalidates the figure. This method informs the listeners
     * that the figure's current display box is invalid and should be
     * refreshed.
     */
    public void invalidate() {
        if (fListener != null) {
            Rectangle r = displayBox();
            r.grow(Handle.HANDLESIZE, Handle.HANDLESIZE);
            fListener.figureInvalidated(new FigureChangeEvent(this, r));
        }
    }

    /**
     * Informes that a figure is about to change something that
     * affects the contents of its display box.
     *
     * @@see Figure#willChange
     */
    public void willChange() {
        invalidate();
    }

    /**
     * Informs that a figure changed the area of its display box.
     *
     * @@see FigureChangeEvent
     * @@see Figure#changed
     */
    public void changed() {
        invalidate();
        if (fListener != null)
            fListener.figureChanged(new FigureChangeEvent(this));

    }

    /**
     * Gets the center of a figure. A convenice
     * method that is rarely overridden.
     */
    public Point center() {
        return Geom.center(displayBox());
    }

    /**
     * Checks if this figure can be connected. By default
     * AbstractFigures can be connected.
     */
    public boolean canConnect() {
        return true;
    }

    /**
     * Returns the connection inset. The connection inset
     * defines the area where the display box of a
     * figure can't be connected. By default the entire
     * display box can be connected.
     *
     */
    public Insets connectionInsets() {
        return new Insets(0, 0, 0, 0);
    }

    /**
     * Returns the Figures connector for the specified location.
     * By default a ChopBoxConnector is returned.
     * @@see ChopBoxConnector
     */
    public Connector connectorAt(int x, int y) {
        return new ChopBoxConnector(this);
    }

    /**
     * Sets whether the connectors should be visible.
     * By default they are not visible
     */
    public void connectorVisibility(boolean isVisible) {
    }

    /**
     * Returns the locator used to located connected text.
     */
    public Locator connectedTextLocator(Figure text) {
        return RelativeLocator.center();
    }

    /**
     * Returns the named attribute or null if a
     * a figure doesn't have an attribute.
     * By default
     * figures don't have any attributes getAttribute
     * returns null.
     */
    public Object getAttribute(String name) {
        return null;
    }

    /**
     * Sets the named attribute to the new value. By default
     * figures don't have any attributes and the request is ignored.
     */
    public void setAttribute(String name, Object value) {
    }

    /**
     * Clones a figure. Creates a clone by using the storable
     * mechanism to flatten the Figure to stream followed by
     * resurrecting it from the same stream.
     *
     * @@see Figure#clone
     */
    public Object clone() {
        Object clone = null;
        ByteArrayOutputStream output = new ByteArrayOutputStream(200);
        try {
            ObjectOutput writer = new ObjectOutputStream(output);
            writer.writeObject(this);
            writer.close();
        } catch (IOException e) {
            System.out.println("Class not found: " + e);
        }

        InputStream input = new ByteArrayInputStream(output.toByteArray());
        try {
            ObjectInput reader = new ObjectInputStream(input);
            clone = (Object) reader.readObject();
        } catch (IOException e) {
            System.out.println(e.toString());
        }
        catch (ClassNotFoundException e) {
            System.out.println("Class not found: " + e);
        }
        return clone;
    }

    /**
     * Stores the Figure to a StorableOutput.
     */
    public void write(StorableOutput dw) {
    }

    /**
     * Reads the Figure from a StorableInput.
     */
    public void read(StorableInput dr) throws IOException {
    }

    /**
     * Gets the z value (back-to-front ordering) of this figure.
     */
    public int getZValue() {
      return _nZ;
    }

    /**
     * Sets the z value (back-to-front ordering) of this figure.
     */
    public void setZValue(int z) {
      _nZ = z;
    }
@


1.3
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d4 6
d35 2
d201 1
a201 1
        invalidate();
a202 1
        changed();
d310 1
a310 1
     * By default they are not visible and
@


1.2
log
@implements the extended Figure interface
@
text
@d2 1
a2 1
 * @@(#)AbstractFigure.java 5.1
d63 1
a63 1
     * @@see moveBy
d73 1
a73 1
     * @@see displayBox
d85 1
a85 1
     * @@see displayBox
d152 1
a152 1
     * @@see displayBox
d262 1
a379 1

a380 1

a386 1

a387 1

a388 3



@


1.1
log
@Initial revision
@
text
@d46 1
a261 1

d374 20
@


1.1.1.1
log
@
Initial revision.
@
text
@@
