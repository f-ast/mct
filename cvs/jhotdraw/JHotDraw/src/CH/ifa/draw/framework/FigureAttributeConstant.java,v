head	1.4;
access;
symbols
	jhotdraw54b2-release:1.4
	reorg_6x_split:1.4
	MVC_PHASE1:1.3.0.4
	NEW_ATTRIBUTES:1.3.0.2
	DNOYEB1_ALPHA-2:1.2
	release_JHD54b1:1.2
	BUGFIX_670992:1.2.0.6
	DNOYEB1_ALPHA-1:1.2
	dnoyeb1:1.2.0.4
	repack:1.2.0.2
	Root_repack:1.2
	Before_FigureVisitor:1.2;
locks; strict;
comment	@# @;


1.4
date	2003.09.13.22.31.10;	author mtnygard;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.04.05.21.23;	author ricardo_padilha;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.08.04.22.45.17;	author mrfloppy;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	;

1.2.4.1
date	2003.03.12.15.16.44;	author dnoyeb;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.03.15.15.13.23;	author dnoyeb;	state Exp;
branches;
next	;

1.3.2.1
date	2003.02.23.16.00.43;	author dnoyeb;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.03.12.14.44.28;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Eliminate some deprecated method warnings.
Organize imports to remove Eclipse warnings about unused imports.
@
text
@/*
 * @@(#)FigureAttributeConstant.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.framework;

import java.io.Serializable;

/**
 * A FigureAttribute is a constant for accessing a special figure attribute. It
 * does not contain a value but just defines a unique attribute ID. Therefore,
 * they provide a type-safe way of defining attribute constants.
 * (SourceForge feature request ID: <>)
 *
 * @@author Wolfram Kaiser
 * @@version <$CURRENT_VERSION$>
 */
public class FigureAttributeConstant implements Serializable, Cloneable {

	public static final String FRAME_COLOR_STR = "FrameColor";
	public static final FigureAttributeConstant FRAME_COLOR = new FigureAttributeConstant(FRAME_COLOR_STR, 1);

	public static final String FILL_COLOR_STR = "FillColor";
	public static final FigureAttributeConstant FILL_COLOR = new FigureAttributeConstant(FILL_COLOR_STR, 2);

	public static final String TEXT_COLOR_STR = "TextColor";
	public static final FigureAttributeConstant TEXT_COLOR = new FigureAttributeConstant(TEXT_COLOR_STR, 3);

	public static final String ARROW_MODE_STR = "ArrowMode";
	public static final FigureAttributeConstant ARROW_MODE = new FigureAttributeConstant(ARROW_MODE_STR, 4);

	public static final String FONT_NAME_STR = "FontName";
	public static final FigureAttributeConstant FONT_NAME = new FigureAttributeConstant(FONT_NAME_STR, 5);

	public static final String FONT_SIZE_STR = "FontSize";
	public static final FigureAttributeConstant FONT_SIZE = new FigureAttributeConstant(FONT_SIZE_STR, 6);

	public static final String FONT_STYLE_STR = "FontStyle";
	public static final FigureAttributeConstant FONT_STYLE = new FigureAttributeConstant(FONT_STYLE_STR, 7);

	public static final String URL_STR = "URL";
	public static final FigureAttributeConstant URL = new FigureAttributeConstant(URL_STR, 8);

	public static final String LOCATION_STR = "Location";
	public static final FigureAttributeConstant LOCATION = new FigureAttributeConstant(LOCATION_STR, 9);
	
	public static final String XALIGNMENT_STR = "XAlignment";
	public static final FigureAttributeConstant XALIGNMENT = new FigureAttributeConstant(XALIGNMENT_STR, 10);
	
	public static final String YALIGNMENT_STR = "YAlignment";
	public static final FigureAttributeConstant YALIGNMENT = new FigureAttributeConstant(YALIGNMENT_STR, 11);
	
	public static final String TOP_MARGIN_STR = "TopMargin";
	public static final FigureAttributeConstant TOP_MARGIN = new FigureAttributeConstant(TOP_MARGIN_STR, 12);
	
	public static final String RIGHT_MARGIN_STR = "RightMargin";
	public static final FigureAttributeConstant RIGHT_MARGIN = new FigureAttributeConstant(RIGHT_MARGIN_STR, 13);
	
	public static final String BOTTOM_MARGIN_STR = "BottomMargin";
	public static final FigureAttributeConstant BOTTOM_MARGIN = new FigureAttributeConstant(BOTTOM_MARGIN_STR, 14);
	
	public static final String LEFT_MARGIN_STR = "LeftMargin";
	public static final FigureAttributeConstant LEFT_MARGIN = new FigureAttributeConstant(LEFT_MARGIN_STR, 15);
	
	public static final String POPUP_MENU_STR = "PopupMenu";
	public static final FigureAttributeConstant POPUP_MENU = new FigureAttributeConstant(POPUP_MENU_STR, 16);
	
	private static FigureAttributeConstant[] attributeConstants;

	private int myID;
	private String myName;

	private FigureAttributeConstant(String newName, int newID) {
		setName(newName);
		setID(newID);
		addConstant(this);
	}

	public FigureAttributeConstant(String newName) {
		this(newName, attributeConstants.length+1);
	}

	private void setName(String newName) {
		myName = newName;
	}

	public String getName() {
		return myName;
	}

	private void setID(int newID) {
		myID = newID;
	}

	public int getID() {
		return myID;
	}

	public boolean equals(Object compareObject) {
		if (compareObject == null) {
			return false;
		}
		if (!(compareObject instanceof FigureAttributeConstant)) {
			return false;
		}
		FigureAttributeConstant compareAttribute = (FigureAttributeConstant)compareObject;

		if (compareAttribute.getID() != getID()) {
			return false;
		}

		if ((compareAttribute.getName() == null) && (getName() == null)) {
			return true;
		}
		if ((compareAttribute.getName() != null) && (getName() != null)) {
			return getName().equals(compareAttribute.getName());
		}

		return false;
	}

	public int hashCode() {
		return getID();
	}

	/**
	 * Constants are put into the place according to their ID, thus, it is
	 * recommended to have subsequent attribute IDs.
	 */
	private static void addConstant(FigureAttributeConstant newConstant) {
		int idPos = newConstant.getID() - 1;
		// attribute IDs must be unique, thus no two attributes
		// with the same ID can be added
		if ((idPos < attributeConstants.length) && (attributeConstants[idPos] != null)) {
			throw new JHotDrawRuntimeException("No unique FigureAttribute ID: " + newConstant.getID());
		}
		// increase capacity if necessary
		if (idPos >= attributeConstants.length) {
			FigureAttributeConstant[] tempStrs = new FigureAttributeConstant[idPos + 1];
			System.arraycopy(attributeConstants, 0, tempStrs, 0, attributeConstants.length);
			attributeConstants = tempStrs;
		}
		attributeConstants[idPos] = newConstant;
	}

	/**
	 * @@return an existing constant for a given name or create a new one
	 */
	public static FigureAttributeConstant getConstant(String constantName) {
		for (int i = 0; i < attributeConstants.length; i++) {
			FigureAttributeConstant currentAttr = getConstant(i);
			if ((currentAttr != null) && (currentAttr.getName() != null) && (currentAttr.getName().equals(constantName))) {
				return currentAttr;
			}
		}
		return new FigureAttributeConstant(constantName);
	}

	public static FigureAttributeConstant getConstant(int constantId) {
		return attributeConstants[constantId];
	}

	{
		// use static initializer to create List before any constant is created
		// initialize List only for the first constant (during debugging it
		// appeared that the static initializer is invoked for any constant)
		if (attributeConstants == null) {
			attributeConstants = new FigureAttributeConstant[64];
		}
	}
}
@


1.3
log
@Removed unused imports.
@
text
@d51 24
@


1.3.2.1
log
@Adding new attributes system.
@
text
@a14 2
import java.util.Vector;
import java.util.Enumeration;
d22 1
a22 1
 * @@author Wolfram Kaiser, CL Gilbert(dnoyeb@@users.sourceforge.net)
d25 1
a25 1
public class FigureAttributeConstant extends JHDType implements Serializable, Cloneable {
a26 7
	//should these all be strings?
	//yes should all be strings or simple type
	//different types are really just different ID scopes.  this is only needed
	//when end users want their own attributes for whatever reason and can not
	//know for certain if JHD will ever add new attributes that encroach on their
	//IDs.  so the color and string and integer types are flawed.
	//attributes are generic types only determined at load or store time.
d51 56
a106 2
	public FigureAttributeConstant(java.lang.String newName, int newID) {
		super(newName,newID);
d110 2
a111 7
	 * This is overall flawed because it conflicts with getConstant which assumes
	 * that constants have unique Names.  While this method itself will create
	 * many constants all with the same name.
	 * 
	 * Warning, deserialization issues can occur when using this constructor.
	 * @@deprecated Does not work well with deserialization of end users own 
	 *             FigureAttributeConstants.
d113 14
a126 4
	public FigureAttributeConstant(java.lang.String newName) {
		super(newName);
		System.err.println("WARNING: FigureAttributeConstant(String) has been deprecated.");
		Thread.dumpStack();
d132 6
a137 4
	public static FigureAttributeConstant getConstant(java.lang.String constantName) {
		FigureAttributeConstant fac =(FigureAttributeConstant) JHDType.getConstant(FigureAttributeConstant.class, constantName);
		if( fac == null){
			fac = new FigureAttributeConstant(constantName, JHDType.getMaxValue(FigureAttributeConstant.class) +1);
d139 1
a139 1
	    return fac;
d141 1
d143 10
a152 1
		return (FigureAttributeConstant) JHDType.getConstant(FigureAttributeConstant.class, constantId);
@


1.3.2.2
log
@*** empty log message ***
@
text
@d15 2
d76 1
a76 1
		//Thread.dumpStack();
@


1.2
log
@after variou merges... (before 5.4 release)
@
text
@a13 2
import CH.ifa.draw.util.CollectionsFactory;

a14 2
import java.util.List;
import java.util.Arrays;
@


1.2.4.1
log
@New attributes system.
@
text
@d14 2
d17 2
d26 1
a26 1
 * @@author Wolfram Kaiser, CL Gilbert(dnoyeb@@users.sourceforge.net)
d29 1
a29 1
public class FigureAttributeConstant extends JHDType implements Serializable, Cloneable {
a30 7
	//should these all be strings?
	//yes should all be strings or simple type
	//different types are really just different ID scopes.  this is only needed
	//when end users want their own attributes for whatever reason and can not
	//know for certain if JHD will ever add new attributes that encroach on their
	//IDs.  so the color and string and integer types are flawed.
	//attributes are generic types only determined at load or store time.
d55 56
a110 2
	public FigureAttributeConstant(java.lang.String newName, int newID) {
		super(newName,newID);
d114 2
a115 7
	 * This is overall flawed because it conflicts with getConstant which assumes
	 * that constants have unique Names.  While this method itself will create
	 * many constants all with the same name.
	 * 
	 * Warning, deserialization issues can occur when using this constructor.
	 * @@deprecated Does not work well with deserialization of end users own 
	 *             FigureAttributeConstants.
d117 14
a130 4
	public FigureAttributeConstant(java.lang.String newName) {
		super(newName);
		System.err.println("WARNING: FigureAttributeConstant(String) has been deprecated.");
		//Thread.dumpStack();
d136 6
a141 4
	public static FigureAttributeConstant getConstant(java.lang.String constantName) {
		FigureAttributeConstant fac =(FigureAttributeConstant) JHDType.getConstant(FigureAttributeConstant.class, constantName);
		if( fac == null){
			fac = new FigureAttributeConstant(constantName, JHDType.getMaxValue(FigureAttributeConstant.class) +1);
d143 1
a143 1
	    return fac;
d145 1
d147 10
a156 1
		return (FigureAttributeConstant) JHDType.getConstant(FigureAttributeConstant.class, constantId);
@


1.2.4.2
log
@figure attributes fixes.
use getAttribute as opposed to creating own attributes for now.
later need enduser name space so endusers can instantiate their own
attributes!?
@
text
@a13 1

d22 1
a22 1
 * @@author Wolfram Kaiser
d25 1
a25 1
public class FigureAttributeConstant implements Cloneable, Serializable {
d27 7
d58 2
a59 58
	private static FigureAttributeConstant[] attributeConstants;
	/**
	 * ID is not stored.  It may not be consistent between sessions.
	 */
	private int myID;
	private String myName;

	private FigureAttributeConstant(String newName, int newID) {
		setName(newName);
		setID(newID);
		addConstant(this);
	}

	private FigureAttributeConstant(String newName) {
		this(newName, attributeConstants.length+1);
	}

	private void setName(String newName) {
		myName = newName;
	}

	public String getName() {
		return myName;
	}

	private void setID(int newID) {
		myID = newID;
	}

	public int getID() {
		return myID;
	}

	public boolean equals(Object compareObject) {
		if (compareObject == null) {
			return false;
		}
		if (!(compareObject instanceof FigureAttributeConstant)) {
			return false;
		}
		FigureAttributeConstant compareAttribute = (FigureAttributeConstant)compareObject;

		if (compareAttribute.getID() != getID()) {
			return false;
		}

		if ((compareAttribute.getName() == null) && (getName() == null)) {
			return true;
		}
		if ((compareAttribute.getName() != null) && (getName() != null)) {
			return getName().equals(compareAttribute.getName());
		}

		return false;
	}

	public int hashCode() {
		return getID();
d63 7
a69 2
	 * Constants are put into the place according to their ID, thus, it is
	 * recommended to have subsequent attribute IDs.
d71 4
a74 14
	private static void addConstant(FigureAttributeConstant newConstant) {
		int idPos = newConstant.getID() - 1;
		// attribute IDs must be unique, thus no two attributes
		// with the same ID can be added
		if ((idPos < attributeConstants.length) && (attributeConstants[idPos] != null)) {
			throw new JHotDrawRuntimeException("No unique FigureAttribute ID: " + newConstant.getID());
		}
		// increase capacity if necessary
		if (idPos >= attributeConstants.length) {
			FigureAttributeConstant[] tempStrs = new FigureAttributeConstant[idPos + 1];
			System.arraycopy(attributeConstants, 0, tempStrs, 0, attributeConstants.length);
			attributeConstants = tempStrs;
		}
		attributeConstants[idPos] = newConstant;
d80 4
a83 6
	public static FigureAttributeConstant getConstant(String constantName) {
		for (int i = 0; i < attributeConstants.length; i++) {
			FigureAttributeConstant currentAttr = getConstant(i);
			if ((currentAttr != null) && (currentAttr.getName().equals(constantName))) {
				return currentAttr;
			}
d85 1
a85 1
		return new FigureAttributeConstant(constantName);
a86 1

d88 1
a88 10
		return attributeConstants[constantId];
	}

	{
		// use static initializer to create List before any constant is created
		// initialize List only for the first constant (during debugging it
		// appeared that the static initializer is invoked for any constant)
		if (attributeConstants == null) {
			attributeConstants = new FigureAttributeConstant[64];
		}
@


1.1
log
@no message
@
text
@d14 2
d17 2
a18 2
import java.util.Vector;
import java.util.Enumeration;
d55 1
a55 1
	private static Vector attributeConstants;
d67 1
a67 1
		this(newName, attributeConstants.size()+1);
a118 4
		// increase capacity if necessary
		if (idPos >= attributeConstants.size()) {
			attributeConstants.setSize(idPos + 1);
		}
d121 1
a121 1
		if (attributeConstants.elementAt(idPos) != null) {
d124 7
a130 1
		attributeConstants.setElementAt(newConstant, idPos);
d137 1
a137 1
		for (int i = 0; i < attributeConstants.size(); i++) {
d147 1
a147 1
		return (FigureAttributeConstant)attributeConstants.elementAt(constantId);
d151 2
a152 2
		// use static initializer to create vector before any constant is created
		// initialize Vector only for the first constant (during debugging it
d155 1
a155 1
			attributeConstants = new Vector();
@

