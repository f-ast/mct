head	1.9;
access;
symbols
	jhotdraw54b2-release:1.8
	reorg_6x_split:1.8
	MVC_PHASE1:1.7.0.4
	NEW_ATTRIBUTES:1.7.0.2
	DNOYEB1_ALPHA-2:1.6
	release_JHD54b1:1.7
	BUGFIX_670992:1.6.0.4
	DNOYEB1_ALPHA-1:1.6
	dnoyeb1:1.6.0.2
	repack:1.5.0.2
	Root_repack:1.5
	Before_FigureVisitor:1.5
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2005.04.25.22.35.57;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.09.21.18.45;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.30.00.27.34;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.31.21.24.06;	author dnoyeb;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.04.23.01.49;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.44.33;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;


desc
@@


1.9
log
@work-around for JDK-bugs 4079180, 4146533 and 4638205
@
text
@/*
 * @@(#)StorableInput.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.util;

import java.io.*;
import java.awt.Color;
import java.util.List;

/**
 * An input stream that can be used to resurrect Storable objects.
 * StorableInput preserves the object identity of the stored objects.
 *
 * @@see Storable
 * @@see StorableOutput
 *
 * @@version <$CURRENT_VERSION$>s
 */
public class StorableInput {

	private StreamTokenizer fTokenizer;
	private List            fMap;

	/**
	 * Initializes a Storable input with the given input stream.
	 */
	public StorableInput(InputStream stream) {
		Reader r = new BufferedReader(new InputStreamReader(stream));
		fTokenizer = new StreamTokenizer(r);
		// include inner class separate in class names
		fTokenizer.wordChars('$', '$');
		fMap = CollectionsFactory.current().createList();
	}

	/**
	 * Reads and resurrects a Storable object from the input stream.
	 */
	public Storable readStorable() throws IOException {
		Storable storable;
		String s = readString();

		if (s.equals("NULL")) {
			return null;
		}

		if (s.equals("REF")) {
			int ref = readInt();
			return retrieve(ref);
		}

		storable = (Storable) makeInstance(s);
		map(storable);
		storable.read(this);
		return storable;
	}

	/**
	 * Reads a string from the input stream.
	 */
	public String readString() throws IOException {
		int token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_WORD || token == '"') {
			return fTokenizer.sval;
		}

		String msg = "String expected in line: " + fTokenizer.lineno();
		throw new IOException(msg);
	}

	/**
	 * Reads an int from the input stream.
	 */
	public int readInt() throws IOException {
		int token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_NUMBER) {
			return (int) fTokenizer.nval;
		}

		String msg = "Integer expected in line: " + fTokenizer.lineno();
		IOException exception =  new IOException(msg);
		exception.printStackTrace();
		throw new IOException(msg);
	}

	/**
	 * Reads an int from the input stream.
	 */
	public long readLong() throws IOException {
		long token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_NUMBER) {
			return (long)fTokenizer.nval;
		}
		String msg = "Long expected in line: " + fTokenizer.lineno();
		IOException exception =  new IOException(msg);
		//exception.printStackTrace();
		throw exception;
	}

	/**
	 * Reads a color from the input stream.
	 */
	public Color readColor() throws IOException {
		return new Color(readInt(), readInt(), readInt());
	}

	/**
	 * Reads a double from the input stream.
	 */
	public double readDouble() throws IOException {
		double value = 0.0; 
		int token = fTokenizer.nextToken(); 
		if (token == StreamTokenizer.TT_NUMBER) { 
			// Allow for a bug in StreamTokenizer, which causes the exponent 
			// to be ignored, then read in as a string as the next token. 
			// This is a nasty kludge and I think it could fail if a number 
			// without an exponent is followed by a string beginning with "E" or "e" 
			value = fTokenizer.nval; 
			int token2 = fTokenizer.nextToken(); 
			if (token2 == StreamTokenizer.TT_WORD && 
					(fTokenizer.sval.charAt(0) == 'E' || fTokenizer.sval.charAt(0) == 'e')) { 
				value = Double.valueOf(value+fTokenizer.sval).doubleValue(); 
			} 
			else { 
				fTokenizer.pushBack(); 
			} 
			return value; 
		}
		else {
			throw new IOException("Double expected in line: " + fTokenizer.lineno());
		}
	}

	/**
	 * Reads a boolean from the input stream.
	 */
	public boolean readBoolean() throws IOException {
		int token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_NUMBER) {
			return ((int) fTokenizer.nval) == 1;
		}

		String msg = "Integer expected in line: " + fTokenizer.lineno();
		throw new IOException(msg);
	}

	private Object makeInstance(String className) throws IOException {
		try {
			Class cl = Class.forName(className);
			return cl.newInstance();
		}
		catch (NoSuchMethodError e) {
			throw new IOException("Class " + className
				+ " does not seem to have a no-arg constructor");
		}
		catch (ClassNotFoundException e) {
			throw new IOException("No class: " + className);
		}
		catch (InstantiationException e) {
			throw new IOException("Cannot instantiate: " + className);
		}
		catch (IllegalAccessException e) {
			throw new IOException("Class (" + className + ") not accessible");
		}
	}

	private void map(Storable storable) {
		if (!fMap.contains(storable)) {
			fMap.add(storable);
		}
	}

	private Storable retrieve(int ref) {
		return (Storable)fMap.get(ref);
	}
}
@


1.8
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@d118 20
a137 3
		int token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_NUMBER) {
			return fTokenizer.nval;
a138 3

		String msg = "Double expected in line: " + fTokenizer.lineno();
		throw new IOException(msg);
@


1.7
log
@prepare for 5.4 release: various bug fixes
@
text
@d56 1
a56 1
			return (Storable) retrieve(ref);
@


1.6
log
@Add ability to read and write 'int.'
@
text
@d92 1
d99 1
a99 1
			return (long) fTokenizer.nval;
d103 2
a104 2
		exception.printStackTrace();
		throw new IOException(msg);
@


1.5
log
@after variou merges... (before 5.4 release)
@
text
@d92 13
@


1.4
log
@no message
@
text
@a13 1
import java.util.*;
d16 1
d30 1
a30 1
	private Vector          fMap;
d40 1
a40 1
		fMap = new Vector();
d148 1
a148 1
			fMap.addElement(storable);
d153 1
a153 1
		return (Storable) fMap.elementAt(ref);
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@d27 1
a27 1
public class StorableInput extends Object {
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)StorableInput.java 5.2
d4 6
d24 2
d27 1
d29 2
a30 5
public  class StorableInput
        extends Object {

    private StreamTokenizer fTokenizer;
    private Vector          fMap;
d32 123
a154 114
    /**
     * Initializes a Storable input with the given input stream.
     */
    public StorableInput(InputStream stream) {
        Reader r = new BufferedReader(new InputStreamReader(stream));
        fTokenizer = new StreamTokenizer(r);
        // include inner class separate in class names
        fTokenizer.wordChars('$', '$');
        fMap = new Vector();
    }

    /**
     * Reads and resurrects a Storable object from the input stream.
     */
    public Storable readStorable() throws IOException {
        Storable storable;
        String s = readString();

        if (s.equals("NULL"))
            return null;

        if (s.equals("REF")) {
            int ref = readInt();
            return (Storable) retrieve(ref);
        }

        storable = (Storable) makeInstance(s);
        map(storable);
        storable.read(this);
        return storable;
    }

    /**
     * Reads a string from the input stream.
     */
    public String readString() throws IOException {
        int token = fTokenizer.nextToken();
        if (token == StreamTokenizer.TT_WORD || token == '"') {
            return fTokenizer.sval;
        }

        String msg = "String expected in line: " + fTokenizer.lineno();
        throw new IOException(msg);
    }

    /**
     * Reads an int from the input stream.
     */
    public int readInt() throws IOException {
        int token = fTokenizer.nextToken();
        if (token == StreamTokenizer.TT_NUMBER)
            return (int) fTokenizer.nval;

        String msg = "Integer expected in line: " + fTokenizer.lineno();
        IOException exception =  new IOException(msg);
        exception.printStackTrace();
        throw new IOException(msg);
    }

    /**
     * Reads a color from the input stream.
     */
    public Color readColor() throws IOException {
        return new Color(readInt(), readInt(), readInt());
    }

    /**
     * Reads a double from the input stream.
     */
    public double readDouble() throws IOException {
        int token = fTokenizer.nextToken();
        if (token == StreamTokenizer.TT_NUMBER)
            return fTokenizer.nval;

        String msg = "Double expected in line: " + fTokenizer.lineno();
        throw new IOException(msg);
    }

    /**
     * Reads a boolean from the input stream.
     */
    public boolean readBoolean() throws IOException {
        int token = fTokenizer.nextToken();
        if (token == StreamTokenizer.TT_NUMBER)
            return ((int) fTokenizer.nval) == 1;

        String msg = "Integer expected in line: " + fTokenizer.lineno();
        throw new IOException(msg);
    }

    private Object makeInstance(String className) throws IOException {
        try {
            Class cl = Class.forName(className);
            return cl.newInstance();
        } catch (NoSuchMethodError e) {
            throw new IOException("Class " + className
                + " does not seem to have a no-arg constructor");
        } catch (ClassNotFoundException e) {
            throw new IOException("No class: " + className);
        } catch (InstantiationException e) {
            throw new IOException("Cannot instantiate: " + className);
        } catch (IllegalAccessException e) {
            throw new IOException("Class (" + className + ") not accessible");
        }
    }

    private void map(Storable storable) {
        if (!fMap.contains(storable))
            fMap.addElement(storable);
    }

    private Storable retrieve(int ref) {
        return (Storable) fMap.elementAt(ref);
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)StorableInput.java 5.1
d32 2
d80 2
@


1.1.1.1
log
@
Initial revision.
@
text
@@
