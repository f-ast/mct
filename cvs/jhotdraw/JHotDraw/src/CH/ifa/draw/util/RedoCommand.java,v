head	1.3;
access;
symbols
	jhotdraw54b2-release:1.3
	reorg_6x_split:1.3
	MVC_PHASE1:1.3.0.10
	NEW_ATTRIBUTES:1.3.0.8
	DNOYEB1_ALPHA-2:1.3.4.2
	release_JHD54b1:1.3
	BUGFIX_670992:1.3.0.6
	DNOYEB1_ALPHA-1:1.3.4.2
	dnoyeb1:1.3.0.4
	repack:1.3.0.2
	Root_repack:1.3
	Before_FigureVisitor:1.3
	JHotDraw_5-3:1.2;
locks; strict;
comment	@# @;


1.3
date	2002.08.04.23.01.49;	author mrfloppy;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.24.20.37.15;	author mrfloppy;	state Exp;
branches;
next	;

1.3.4.1
date	2003.01.15.21.04.21;	author dnoyeb;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.01.16.15.59.19;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.3
log
@after variou merges... (before 5.4 release)
@
text
@/*
 * @@(#)RedoCommand.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.util;

import CH.ifa.draw.standard.*;
import CH.ifa.draw.framework.*;

/**
 * Command to redo the latest undone change in the drawing.
 *
 * @@version <$CURRENT_VERSION$>
 */ 
public class RedoCommand extends AbstractCommand {

	/**
	 * Constructs a properties command.
	 * @@param name the command name
	 * @@param newDrawingEditor the DrawingEditor which manages the views
	 */
	public RedoCommand(String name, DrawingEditor newDrawingEditor) {
		super(name, newDrawingEditor);
	}

	public void execute() {
		super.execute();
		UndoManager um = getDrawingEditor().getUndoManager();
		if ((um == null) || !um.isRedoable()) {
			return;
		}
		
		Undoable lastRedoable = um.popRedo();
		// Execute redo
		boolean hasBeenUndone = lastRedoable.redo();
		// Add to undo stack
		if (hasBeenUndone && lastRedoable.isUndoable()) {
			um.pushUndo(lastRedoable);
		}
			
		lastRedoable.getDrawingView().checkDamage();

		getDrawingEditor().figureSelectionChanged(lastRedoable.getDrawingView());
	}
  
	/**
	 * Used in enabling the redo menu item.
	 * Redo menu item will be enabled only when there is at least one redoable
	 * activity in the UndoManager.
	 */
	public boolean isExecutableWithView() {
		UndoManager um = getDrawingEditor().getUndoManager();
		if ((um != null) && (um.getRedoSize() > 0)) {
			return true;
		}

	    return false;
	}
}
@


1.3.4.1
log
@
Lets have a moment of silence for DecoratorFigure.....It was a good figure ;{

Anything which happens inside the drawing after figure add must be undone before figure orphan.  It must also not
be exposed to anyobject outside the drawing.
Decorator figure retired in favor of a figureManipulator and the other functions being implemented by a composite
figure(BorderDecorator).
AdnimationDecorator retired in favor of AnimationManipulator.
A figure can have only 1 container. This is making the border tool have a hard time.

Lots of comments added

next phase:
orphan will disappear.  only add and remove remain.  All figure related resources belong to the figures and no other
object should care about figure.release.
split the figureListener into a figureContainer listener and a figureChangeListener.
Fix BorderDecorator.
Fix ConnectedText.
view.checkDamage to call drawing.update()
@
text
@d32 1
a32 3
	/**
	 * Need redo sets that automatically get done together.
	 */
@


1.3.4.2
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d50 1
a50 1
		lastRedoable.getDrawingView().drawing().update();
@


1.2
log
@merge dnd (before 5.3)
@
text
@a13 1
import java.util.*;
@


1.1
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d28 1
a28 1
	 * @@param view the target view
d30 2
a31 2
	public RedoCommand(String name, DrawingView inView) {
		super(name, inView);
d35 2
a36 2
		UndoManager um = view().getUndoManager();
System.out.println("UndoManager.isRedoable(): " + um.isRedoable() + " .. " + um.peekRedo());
a41 1

a45 1
System.out.println("hasBeenUndone: " + hasBeenUndone);
d49 1
a49 1
		view().checkDamage();
d51 1
a51 1
		view().editor().figureSelectionChanged(view());
d59 2
a60 2
	public boolean isExecutable() {
		UndoManager um = view().getUndoManager();
@

