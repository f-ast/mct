head	1.4;
access;
symbols
	jhotdraw54b2-release:1.4
	reorg_6x_split:1.4
	MVC_PHASE1:1.4.0.10
	NEW_ATTRIBUTES:1.4.0.8
	DNOYEB1_ALPHA-2:1.4.4.1
	release_JHD54b1:1.4
	BUGFIX_670992:1.4.0.6
	DNOYEB1_ALPHA-1:1.4.4.1
	dnoyeb1:1.4.0.4
	repack:1.4.0.2
	Root_repack:1.4
	Before_FigureVisitor:1.4
	JHotDraw_5-3:1.3;
locks; strict;
comment	@# @;


1.4
date	2002.08.04.23.01.49;	author mrfloppy;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2002.01.19.18.31.32;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.24.20.37.15;	author mrfloppy;	state Exp;
branches;
next	;

1.4.4.1
date	2003.01.10.04.54.45;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.4
log
@after variou merges... (before 5.4 release)
@
text
@/*
 * @@(#)UndoableTool.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.util;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.AbstractTool;
import java.awt.event.MouseEvent;
import java.awt.event.KeyEvent;
import java.util.EventObject;

/**
 * @@author  Wolfram Kaiser <mrfloppy@@sourceforge.net>
 * @@version <$CURRENT_VERSION$>
 */
public class UndoableTool implements Tool, ToolListener {

	private Tool myWrappedTool;
	private AbstractTool.EventDispatcher myEventDispatcher;

	public UndoableTool(Tool newWrappedTool) {
		setEventDispatcher(createEventDispatcher());
		setWrappedTool(newWrappedTool);
		getWrappedTool().addToolListener(this);
	}

	/**
	 * Activates the tool for the given view. This method is called
	 * whenever the user switches to this tool. Use this method to
	 * reinitialize a tool.
	 */
	public void activate() {
		getWrappedTool().activate();
	}

	/**
	 * Deactivates the tool. This method is called whenever the user
	 * switches to another tool. Use this method to do some clean-up
	 * when the tool is switched. Subclassers should always call
	 * super.deactivate.
	 */
	public void deactivate() {
		getWrappedTool().deactivate();
		Undoable undoActivity = getWrappedTool().getUndoActivity();
		if ((undoActivity != null) && (undoActivity.isUndoable())) {
			editor().getUndoManager().pushUndo(undoActivity);
			editor().getUndoManager().clearRedos();
			// update menus
			editor().figureSelectionChanged(getActiveView());
		}
	}

	/**
	 * Handles mouse down events in the drawing view.
	 */
	public void mouseDown(MouseEvent e, int x, int y) {
		getWrappedTool().mouseDown(e, x, y);
	}

	/**
	 * Handles mouse drag events in the drawing view.
	 */
	public void mouseDrag(MouseEvent e, int x, int y) {
		getWrappedTool().mouseDrag(e, x, y);
	}

	/**
	 * Handles mouse up in the drawing view. After the mouse button
	 * has been released, the associated tool activity can be undone
	 * if the associated tool supports the undo operation from the Undoable interface.
	 *
	 * @@see CH.ifa.draw.util.Undoable
	 */
	public void mouseUp(MouseEvent e, int x, int y) {
		getWrappedTool().mouseUp(e, x, y);
	}

	/**
	 * Handles mouse moves (if the mouse button is up).
	 */
	public void mouseMove(MouseEvent evt, int x, int y) {
		getWrappedTool().mouseMove(evt, x, y);
	}

	/**
	 * Handles key down events in the drawing view.
	 */
	public void keyDown(KeyEvent evt, int key) {
		getWrappedTool().keyDown(evt, key);
	}

	public boolean isUsable() {
		return getWrappedTool().isUsable();
	}

	public boolean isActive() {
		// do not delegate but test whether this undoable tool is active
		return editor().tool() == this;
	}

	public boolean isEnabled() {
		return getWrappedTool().isEnabled();
	}

	public void setUsable(boolean newIsUsable) {
		getWrappedTool().setUsable(newIsUsable);
	}

	public void setEnabled(boolean newIsEnabled) {
		getWrappedTool().setEnabled(newIsEnabled);
	}

	protected void setWrappedTool(Tool newWrappedTool) {
		myWrappedTool = newWrappedTool;
	}

	protected Tool getWrappedTool() {
		return myWrappedTool;
	}

	public DrawingEditor editor() {
		return getWrappedTool().editor();
	}

	public DrawingView view() {
		return editor().view();
	}

	public Undoable getUndoActivity() {
		return new UndoableAdapter(view());
	}

	public void setUndoActivity(Undoable newUndoableActivity) {
		// do nothing: always return default UndoableAdapter
	}

	public void toolUsable(EventObject toolEvent) {
		getEventDispatcher().fireToolUsableEvent();
	}

	public void toolUnusable(EventObject toolEvent) {
		getEventDispatcher().fireToolUnusableEvent();
	}

	public void toolActivated(EventObject toolEvent) {
		getEventDispatcher().fireToolActivatedEvent();
	}

	public void toolDeactivated(EventObject toolEvent) {
		getEventDispatcher().fireToolDeactivatedEvent();
	}

	public void toolEnabled(EventObject toolEvent) {
		getEventDispatcher().fireToolEnabledEvent();
	}

	public void toolDisabled(EventObject toolEvent) {
		getEventDispatcher().fireToolDisabledEvent();
	}

	public void addToolListener(ToolListener newToolListener) {
		getEventDispatcher().addToolListener(newToolListener);
	}

	public void removeToolListener(ToolListener oldToolListener) {
		getEventDispatcher().removeToolListener(oldToolListener);
	}

	private void setEventDispatcher(AbstractTool.EventDispatcher newEventDispatcher) {
		myEventDispatcher = newEventDispatcher;
	}

	protected AbstractTool.EventDispatcher getEventDispatcher() {
		return myEventDispatcher;
	}

	public AbstractTool.EventDispatcher createEventDispatcher() {
		return new AbstractTool.EventDispatcher(this);
	}

	public DrawingView getActiveView() {
		return editor().view();
	}
}
@


1.4.4.1
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d16 1
a16 1

d64 2
a65 2
	public void mouseDown(DrawingViewMouseEvent dvme) {
		getWrappedTool().mouseDown(dvme);
d71 2
a72 2
	public void mouseDrag(DrawingViewMouseEvent dvme) {
		getWrappedTool().mouseDrag(dvme);
d82 2
a83 2
	public void mouseUp(DrawingViewMouseEvent dvme) {
		getWrappedTool().mouseUp(dvme);
d89 2
a90 2
	public void mouseMove(DrawingViewMouseEvent dvme) {
		getWrappedTool().mouseMove(dvme);
@


1.3
log
@no message
@
text
@d21 1
a21 1
 * @@author Wolfram Kaiser
d57 1
a57 1
			editor().figureSelectionChanged(view());
d187 4
@


1.2
log
@merge dnd (before 5.3)
@
text
@d28 1
a28 1
	
d103 18
a120 1
	
d124 1
a124 1
	
d132 1
a132 1
	
d136 1
a136 1
	
d144 1
a144 1
	
d148 1
a148 1
	
d156 1
a156 1
	
d161 8
d172 1
a172 1
	
@


1.1
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d15 1
d18 1
d24 1
a24 1
public class UndoableTool implements Tool {
d27 1
d30 1
d32 1
d34 31
a64 32
	
    /**
     * Activates the tool for the given view. This method is called
     * whenever the user switches to this tool. Use this method to
     * reinitialize a tool.
     */
    public void activate() {
    	getWrappedTool().activate();
    }

    /**
     * Deactivates the tool. This method is called whenever the user
     * switches to another tool. Use this method to do some clean-up
     * when the tool is switched. Subclassers should always call
     * super.deactivate.
     */
    public void deactivate() {
    	getWrappedTool().deactivate();
    	Undoable undoActivity = getWrappedTool().getUndoActivity();
System.out.println("UndoActivity: " + undoActivity);
    	if ((undoActivity != null) && (undoActivity.isUndoable())) {
	    	view().getUndoManager().pushUndo(undoActivity);
			view().getUndoManager().clearRedos();
	    	// update menus
   			view().editor().figureSelectionChanged(view());
    	}
    }

    /**
     * Handles mouse down events in the drawing view.
     */
    public void mouseDown(MouseEvent e, int x, int y) {
d66 1
a66 1
    }
d68 17
a84 31
    /**
     * Handles mouse drag events in the drawing view.
     */
    public void mouseDrag(MouseEvent e, int x, int y) {
    	getWrappedTool().mouseDrag(e, x, y);
    }

    /**
     * Handles mouse up in the drawing view. After the mouse button
     * has been released, the associated tool activity can be undone
     * if the associated tool supports the undo operation from the Undoable interface.
     *
     * @@see CH.ifa.draw.util.Undoable
     */
    public void mouseUp(MouseEvent e, int x, int y) {
    	getWrappedTool().mouseUp(e, x, y);
    }

    /**
     * Handles mouse moves (if the mouse button is up).
     */
    public void mouseMove(MouseEvent evt, int x, int y) {
    	getWrappedTool().mouseMove(evt, x, y);
    }

    /**
     * Handles key down events in the drawing view.
     */
    public void keyDown(KeyEvent evt, int key) {
    	getWrappedTool().keyDown(evt, key);
    }
d86 18
d112 7
a118 3
    public DrawingView view() {
    	return getWrappedTool().view();
    }
d126 36
@

