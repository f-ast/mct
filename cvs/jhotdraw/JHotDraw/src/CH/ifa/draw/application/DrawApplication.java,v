head	1.31;
access;
symbols
	jhotdraw54b2-release:1.31
	reorg_6x_split:1.31
	MVC_PHASE1:1.30.0.2
	NEW_ATTRIBUTES:1.29.0.2
	DNOYEB1_ALPHA-2:1.17.4.9
	release_JHD54b1:1.23
	BUGFIX_670992:1.21.0.2
	DNOYEB1_ALPHA-1:1.17.4.4
	dnoyeb1:1.17.0.4
	repack:1.17.0.2
	Root_repack:1.17
	Before_FigureVisitor:1.14
	JHotDraw_5-3:1.7
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.31
date	2003.11.09.21.18.47;	author mrfloppy;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.22.23.58.42;	author mrfloppy;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.12.00.33.33;	author dnoyeb;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.07.17.49.19;	author ricardo_padilha;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.05.02.25.36;	author ricardo_padilha;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.04.05.38.03;	author ricardo_padilha;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.30.20.27.15;	author dnoyeb;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.30.18.52.37;	author dnoyeb;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.30.00.27.33;	author mrfloppy;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.24.01.25.49;	author dnoyeb;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.12.20.21.09;	author dnoyeb;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2003.01.03.00.55.30;	author dnoyeb;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.02.19.05.47;	author dnoyeb;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.02.17.37.20;	author dnoyeb;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.27.11.53.24;	author mrfloppy;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2002.10.16.23.00.17;	author mrfloppy;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.16.22.56.06;	author mrfloppy;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.22.08.20.30;	author mrfloppy;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.07.12.27.28;	author mrfloppy;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.14.09.01.57;	author mrfloppy;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.06.09.30.19;	author mrfloppy;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.04.22.33.54;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.19.18.31.31;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.25.12;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.29.13.42.13;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.17.4.1
date	2003.01.03.15.57.39;	author dnoyeb;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2003.01.03.16.03.54;	author dnoyeb;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2003.01.04.15.38.00;	author dnoyeb;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2003.01.07.21.22.27;	author dnoyeb;	state Exp;
branches;
next	1.17.4.5;

1.17.4.5
date	2003.01.22.02.49.30;	author dnoyeb;	state Exp;
branches;
next	1.17.4.6;

1.17.4.6
date	2003.01.24.03.05.31;	author dnoyeb;	state Exp;
branches;
next	1.17.4.7;

1.17.4.7
date	2003.01.26.15.58.48;	author dnoyeb;	state Exp;
branches;
next	1.17.4.8;

1.17.4.8
date	2003.01.29.04.22.31;	author dnoyeb;	state Exp;
branches;
next	1.17.4.9;

1.17.4.9
date	2003.01.30.19.22.15;	author dnoyeb;	state Exp;
branches;
next	1.17.4.10;

1.17.4.10
date	2003.02.02.16.49.44;	author dnoyeb;	state Exp;
branches;
next	;

1.21.2.1
date	2003.01.22.04.26.04;	author dnoyeb;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2003.01.22.18.31.22;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.31
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 * @@(#)DrawApplication.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.application;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.figures.*;
import CH.ifa.draw.util.*;
import CH.ifa.draw.contrib.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.ListIterator;

/**
 * DrawApplication defines a standard presentation for
 * standalone drawing editors. The presentation is
 * customized in subclasses.
 * The application is started as follows:
 * <pre>
 * public static void main(String[] args) {
 *     MayDrawApp window = new MyDrawApp();
 *     window.open();
 * }
 * </pre>
 *
 * @@version <$CURRENT_VERSION$>
 */
public	class DrawApplication
		extends JFrame
		implements DrawingEditor, PaletteListener, VersionRequester {

	private Tool					fTool;
	private Iconkit					fIconkit;

	private JTextField				fStatusLine;
	private DrawingView				fView;
	private ToolButton				fDefaultToolButton;
	private ToolButton				fSelectedToolButton;

	private String					fApplicationName;
	private StorageFormatManager	fStorageFormatManager;
	private UndoManager				myUndoManager;
	protected static String			fgUntitled = "untitled";
	/**
	 * List is not thread safe, but should not need to be.  If it does we can 
	 * safely synchronize the few methods that use this by synchronizing on 
	 * the List object itself.
	 */
	private java.util.List			listeners;
	private DesktopListener     fDesktopListener;

	/**
	 * This component acts as a desktop for the content.
	 */
	private Desktop              fDesktop;

	// the image resource path
	private static final String		fgDrawPath = "/CH/ifa/draw/";
	public static final String		IMAGES = fgDrawPath + "images/";
	protected static int 			winCount = 0;

	/**
	 * The index of the file menu in the menu bar.
	 */
	public static final int			FILE_MENU = 0;
	/**
	 * The index of the edit menu in the menu bar.
	 */
	public static final int			EDIT_MENU = 1;
	/**
	 * The index of the alignment menu in the menu bar.
	 */
	public static final int			ALIGNMENT_MENU = 2;
	/**
	 * The index of the attributes menu in the menu bar.
	 */
	public static final int			ATTRIBUTES_MENU = 3;

	/**
	 * Constructs a drawing window with a default title.
	 */
	public DrawApplication() {
		this("JHotDraw");
	}

	/**
	 * Constructs a drawing window with the given title.
	 */
	public DrawApplication(String title) {
		super(title);
		listeners = CollectionsFactory.current().createList();
		setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
		setApplicationName(title);
	}

	/**
	 * Factory method which can be overriden by subclasses to
	 * create an instance of their type.
	 *
	 * @@return	newly created application
	 */
	protected DrawApplication createApplication() {
		return new DrawApplication();
	}

	/**
	 * Open a new view for this application containing a
	 * view of the drawing of the currently activated window.
	 */
	public void newView() {
		if (view() == null) {
			return;
		}
		DrawApplication window = createApplication();
		window.open(view());
		if (view().drawing().getTitle() != null ) {
			window.setDrawingTitle(view().drawing().getTitle() + " (View)");
		}
		else {
			window.setDrawingTitle(getDefaultDrawingTitle() + " (View)");
		}
	}

	/**
	 * Open a new window for this application containing the passed in drawing,
	 * or a new drawing if the passed in drawing is null.
	 */
	public void newWindow(Drawing initialDrawing) {
		DrawApplication window = createApplication();
		if (initialDrawing == null) {
			window.open();
		}
		else {
			window.open(window.createDrawingView(initialDrawing));
		}
	}

	public final void newWindow() {
        newWindow(createDrawing());
	}

	/**
	 * Opens a new window
	 */
	public void open() {
		open(createInitialDrawingView());
	}

	/**
	 * Opens a new window with a drawing view.
	 */
	protected void open(final DrawingView newDrawingView) {
		getVersionControlStrategy().assertCompatibleVersion();
		setUndoManager(new UndoManager());
		setIconkit(createIconkit());
		getContentPane().setLayout(new BorderLayout());

		// status line must be created before a tool is set
		setStatusLine(createStatusLine());
		getContentPane().add(getStatusLine(), BorderLayout.SOUTH);

		// create dummy tool until the default tool is activated during toolDone()
		setTool(new NullTool(this), "");
		setView(newDrawingView);

		JToolBar tools = createToolPalette();
		createTools(tools);

		JPanel activePanel = new JPanel();
		activePanel.setAlignmentX(LEFT_ALIGNMENT);
		activePanel.setAlignmentY(TOP_ALIGNMENT);
		activePanel.setLayout(new BorderLayout());
		activePanel.add(tools, BorderLayout.NORTH);
		setDesktopListener(createDesktopListener());
		setDesktop(createDesktop());
		activePanel.add((Component)getDesktop(), BorderLayout.CENTER);
		getContentPane().add(activePanel, BorderLayout.CENTER);

		JMenuBar mb = new JMenuBar();
		createMenus(mb);
		setJMenuBar(mb);

		Dimension d = defaultSize();
		if (d.width > mb.getPreferredSize().width) {
			setSize(d.width, d.height);
		}
		else {
			setSize(mb.getPreferredSize().width, d.height);
		}
		addListeners();
		setStorageFormatManager(createStorageFormatManager());

		//no work allowed to be done on GUI outside of AWT thread once
		//setVislble(true) must be called before drawing added to desktop, else 
		//DND will fail. on drawing added before with a NPE.  note however that
		//a nulldrawingView will not fail because it is never really added to the desltop
		setVisible(true);
		Runnable r = new Runnable() {
			public void run() {
				if (newDrawingView.isInteractive()) {
					getDesktop().addToDesktop(newDrawingView , Desktop.PRIMARY);
				}
				toolDone();
			}
		};

		if (java.awt.EventQueue.isDispatchThread() == false) {
			try {
				java.awt.EventQueue.invokeAndWait(r);
			}
			catch(java.lang.InterruptedException ie) {
				System.err.println(ie.getMessage());
				exit();
			}
			catch(java.lang.reflect.InvocationTargetException ite) {
				System.err.println(ite.getMessage());
				exit();
			}
		}
		else {
			r.run();
		}

		toolDone();
	}

	/**
	 * Registers the listeners for this window
	 */
	protected void addListeners() {
		addWindowListener(
			new WindowAdapter() {
				public void windowClosing(WindowEvent event) {
					endApp();
				}

				public void windowOpened(WindowEvent event) {
					winCount++;
				}

				public void windowClosed(WindowEvent event) {
					if (--winCount == 0) {
						System.exit(0);
					}
				}
			}
		);
	}

	/**
	 * Creates the standard menus. Clients override this
	 * method to add additional menus.
	 */
	protected void createMenus(JMenuBar mb) {
		addMenuIfPossible(mb, createFileMenu());
		addMenuIfPossible(mb, createEditMenu());
		addMenuIfPossible(mb, createAlignmentMenu());
		addMenuIfPossible(mb, createAttributesMenu());
		addMenuIfPossible(mb, createDebugMenu());
	}

	protected void addMenuIfPossible(JMenuBar mb, JMenu newMenu) {
		if (newMenu != null) {
			mb.add(newMenu);
		}
	}

	/**
	 * Creates the file menu. Clients override this
	 * method to add additional menu items.
	 */
	protected JMenu createFileMenu() {
		CommandMenu menu = new CommandMenu("File");
		Command cmd = new AbstractCommand("New", this, false) {
			public void execute() {
				promptNew();
			}
		};
		menu.add(cmd, new MenuShortcut('n'));

		cmd = new AbstractCommand("Open...", this, false) {
			public void execute() {
				promptOpen();
			}
		};
		menu.add(cmd, new MenuShortcut('o'));

		cmd = new AbstractCommand("Save As...", this, true) {
			public void execute() {
				promptSaveAs();
			}
		};
		menu.add(cmd, new MenuShortcut('s'));
		menu.addSeparator();

		cmd = new AbstractCommand("Print...", this, true) {
			public void execute() {
				print();
			}
		};
		menu.add(cmd, new MenuShortcut('p'));
		menu.addSeparator();

		cmd = new AbstractCommand("Exit", this, true) {
			public void execute() {
				endApp();
			}
		};
		menu.add(cmd);
		return menu;
	}

	/**
	 * Creates the edit menu. Clients override this
	 * method to add additional menu items.
	 */
	protected JMenu createEditMenu() {
		CommandMenu menu = new CommandMenu("Edit");
		menu.add(new UndoableCommand(
			new SelectAllCommand("Select All", this)), new MenuShortcut('a'));
		menu.addSeparator();
		menu.add(new UndoableCommand(
			new CutCommand("Cut", this)), new MenuShortcut('x'));
		menu.add(new CopyCommand("Copy", this), new MenuShortcut('c'));
		menu.add(new UndoableCommand(
			new PasteCommand("Paste", this)), new MenuShortcut('v'));
		menu.addSeparator();
		menu.add(new UndoableCommand(
			new DuplicateCommand("Duplicate", this)), new MenuShortcut('d'));
		menu.add(new UndoableCommand(new DeleteCommand("Delete", this)));
		menu.addSeparator();
		menu.add(new UndoableCommand(new GroupCommand("Group", this)));
		menu.add(new UndoableCommand(new UngroupCommand("Ungroup", this)));
		menu.addSeparator();
		menu.add(new UndoableCommand(new SendToBackCommand("Send to Back", this)));
		menu.add(new UndoableCommand(new BringToFrontCommand("Bring to Front", this)));
		menu.addSeparator();
		menu.add(new UndoCommand("Undo Command", this));
		menu.add(new RedoCommand("Redo Command", this));
		return menu;
	}

	/**
	 * Creates the alignment menu. Clients override this
	 * method to add additional menu items.
	 */
	protected JMenu createAlignmentMenu() {
		CommandMenu menu = new CommandMenu("Align");
		menu.addCheckItem(new ToggleGridCommand("Toggle Snap to Grid", this, new Point(4,4)));
		menu.addSeparator();
		menu.add(new UndoableCommand(
			new AlignCommand(AlignCommand.Alignment.LEFTS, this)));
		menu.add(new UndoableCommand(
			new AlignCommand(AlignCommand.Alignment.CENTERS, this)));
		menu.add(new UndoableCommand(
			new AlignCommand(AlignCommand.Alignment.RIGHTS, this)));
		menu.addSeparator();
		menu.add(new UndoableCommand(
			new AlignCommand(AlignCommand.Alignment.TOPS, this)));
		menu.add(new UndoableCommand(
			new AlignCommand(AlignCommand.Alignment.MIDDLES, this)));
		menu.add(new UndoableCommand(
			new AlignCommand(AlignCommand.Alignment.BOTTOMS, this)));
		return menu;
	}

	/**
	 * Creates the debug menu. Clients override this
	 * method to add additional menu items.
	 */
	protected JMenu createDebugMenu() {
		CommandMenu menu = new CommandMenu("Debug");

		Command cmd = new AbstractCommand("Simple Update", this) {
			public void execute() {
				this.view().setDisplayUpdate(new SimpleUpdateStrategy());
			}
		};
		menu.add(cmd);

		cmd = new AbstractCommand("Buffered Update", this) {
			public void execute() {
				this.view().setDisplayUpdate(new BufferedUpdateStrategy());
			}
		};
		menu.add(cmd);
		return menu;
	}

	/**
	 * Creates the attributes menu and its submenus. Clients override this
	 * method to add additional menu items.
	 */
	protected JMenu createAttributesMenu() {
		JMenu menu = new JMenu("Attributes");
		menu.add(createColorMenu("Fill Color", FigureAttributeConstant.FILL_COLOR));
		menu.add(createColorMenu("Pen Color", FigureAttributeConstant.FRAME_COLOR));
		menu.add(createArrowMenu());
		menu.addSeparator();
		menu.add(createFontMenu());
		menu.add(createFontSizeMenu());
		menu.add(createFontStyleMenu());
		menu.add(createColorMenu("Text Color", FigureAttributeConstant.TEXT_COLOR));
		return menu;
	}

	/**
	 * Creates the color menu.
	 */
	protected JMenu createColorMenu(String title, FigureAttributeConstant attribute) {
		CommandMenu menu = new CommandMenu(title);
		for (int i=0; i<ColorMap.size(); i++)
			menu.add(
				new UndoableCommand(
					new ChangeAttributeCommand(
						ColorMap.name(i),
						attribute,
						ColorMap.color(i),
						this
					)
				)
			);
		return menu;
	}

	/**
	 * Creates the arrows menu.
	 */
	protected JMenu createArrowMenu() {
		FigureAttributeConstant arrowMode = FigureAttributeConstant.ARROW_MODE;
		CommandMenu menu = new CommandMenu("Arrow");
		menu.add(new UndoableCommand(
			new ChangeAttributeCommand("none", arrowMode, new Integer(PolyLineFigure.ARROW_TIP_NONE), this)));
		menu.add(new UndoableCommand(
			new ChangeAttributeCommand("at Start", arrowMode, new Integer(PolyLineFigure.ARROW_TIP_START), this)));
		menu.add(new UndoableCommand(
			new ChangeAttributeCommand("at End", arrowMode, new Integer(PolyLineFigure.ARROW_TIP_END), this)));
		menu.add(new UndoableCommand(
			new ChangeAttributeCommand("at Both", arrowMode, new Integer(PolyLineFigure.ARROW_TIP_BOTH), this)));
		return menu;
	}

	/**
	 * Creates the fonts menus. It installs all available fonts
	 * supported by the toolkit implementation.
	 */
	protected JMenu createFontMenu() {
		CommandMenu menu = new CommandMenu("Font");
		String fonts[] = Toolkit.getDefaultToolkit().getFontList();
		for (int i = 0; i < fonts.length; i++) {
			menu.add(new UndoableCommand(
				new ChangeAttributeCommand(fonts[i], FigureAttributeConstant.FONT_NAME, fonts[i],  this)));
		}
		return menu;
	}

	/**
	 * Creates the font style menu with entries (Plain, Italic, Bold).
	 */
	protected JMenu createFontStyleMenu() {
		FigureAttributeConstant fontStyle = FigureAttributeConstant.FONT_STYLE;
		CommandMenu menu = new CommandMenu("Font Style");
		menu.add(new UndoableCommand(
			new ChangeAttributeCommand("Plain", fontStyle, new Integer(Font.PLAIN), this)));
		menu.add(new UndoableCommand(
			new ChangeAttributeCommand("Italic", fontStyle, new Integer(Font.ITALIC), this)));
		menu.add(new UndoableCommand(
			new ChangeAttributeCommand("Bold", fontStyle, new Integer(Font.BOLD), this)));
		return menu;
	}

	/**
	 * Creates the font size menu.
	 */
	protected JMenu createFontSizeMenu() {
		CommandMenu menu = new CommandMenu("Font Size");
		int sizes[] = { 9, 10, 12, 14, 18, 24, 36, 48, 72 };
		for (int i = 0; i < sizes.length; i++) {
		   menu.add(
				new UndoableCommand(
					new ChangeAttributeCommand(
						Integer.toString(sizes[i]),
						FigureAttributeConstant.FONT_SIZE,
						new Integer(sizes[i]),
						this
					)
				)
			);
		}
		return menu;
	}

	/**
	 * Create a menu which allows the user to select a different look and feel at runtime.
	 */
	public JMenu createLookAndFeelMenu() {
		CommandMenu menu = new CommandMenu("Look'n'Feel");

		UIManager.LookAndFeelInfo[] lafs = UIManager.getInstalledLookAndFeels();

		for (int i = 0; i < lafs.length; i++) {
			final String lnfClassName = lafs[i].getClassName();
			Command cmd = new AbstractCommand(lafs[i].getName(), this) {
				public void execute() {
					newLookAndFeel(lnfClassName);
				}
			};
			menu.add(cmd);
		}
		return menu;
	}

	/**
	 * Creates the tool palette.
	 */
	protected JToolBar createToolPalette() {
		JToolBar palette = new JToolBar();
		palette.setBackground(Color.lightGray);
		// use standard FlowLayout for JToolBar
		// palette.setLayout(new PaletteLayout(2,new Point(2,2)));
		return palette;
	}

	/**
	 * Creates the tools. By default only the selection tool is added.
	 * Override this method to add additional tools.
	 * Call the inherited method to include the selection tool.
	 * @@param palette the palette where the tools are added.
	 */
	protected void createTools(JToolBar palette) {
		setDefaultTool(createDefaultTool());
		palette.add(fDefaultToolButton);
	}

	/**
	 * Creates the selection tool used in this editor. Override to use
	 * a custom selection tool.
	 */
	protected Tool createSelectionTool() {
		return new SelectionTool(this);
	}

	protected Tool createDefaultTool() {
		return createSelectionTool();
	}

	protected void setDefaultTool(Tool newDefaultTool) {
		if (newDefaultTool != null) {
			fDefaultToolButton = createToolButton(IMAGES+"SEL", "Selection Tool", newDefaultTool);
		}
		else {
			fDefaultToolButton = null;
		}
	}

	public Tool getDefaultTool() {
		if (fDefaultToolButton != null) {
			return fDefaultToolButton.tool();
		}
		else {
			return null;
		}
	}

	/**
	 * Creates a tool button with the given image, tool, and text
	 */
	protected ToolButton createToolButton(String iconName, String toolName, Tool tool) {
		return new ToolButton(this, iconName, toolName, tool);
	}

	/**
	 * Creates the drawing view used in this application.
	 * You need to override this method to use a DrawingView
	 * subclass in your application. By default a standard
	 * DrawingView is returned.
	 */
	protected DrawingView createDrawingView() {
		DrawingView createdDrawingView = createDrawingView(createDrawing());
		createdDrawingView.drawing().setTitle(getDefaultDrawingTitle());
		return createdDrawingView;
	}

	protected DrawingView createDrawingView(Drawing newDrawing) {
		Dimension d = getDrawingViewSize();
		DrawingView newDrawingView = new StandardDrawingView(this, d.width, d.height);
		newDrawingView.setDrawing(newDrawing);
		// notify listeners about created view when the view is added to the desktop
		//fireViewCreatedEvent(newDrawingView);
		return newDrawingView;
	}

	/**
	 * Create the DrawingView that is active when the application is started.
	 * This initial DrawingView might be different from DrawingView created
	 * by the application, so subclasses can override this method to provide
	 * a special drawing view for application startup time, e.g. a NullDrawingView
	 * which does not display an internal frame in a multiple document interface
	 * (MDI) application.
	 *
	 * @@return drawing view that is active at application startup time
	 */
	protected DrawingView createInitialDrawingView() {
		return createDrawingView();
	}

	/**
	 * Override to define the dimensions of the drawing view.
	 */
	protected Dimension getDrawingViewSize() {
		return new Dimension(800, 800);
	}

	/**
	 * Creates the drawing used in this application.
	 * You need to override this method to use a Drawing
	 * subclass in your application. By default a standard
	 * Drawing is returned.
	 */
	protected Drawing createDrawing() {
		return new StandardDrawing();
	}

	protected Desktop createDesktop() {
		return new JPanelDesktop(this);
//		return new JScrollPaneDesktop();
	}

	protected void setDesktop(Desktop newDesktop) {
		newDesktop.addDesktopListener(getDesktopListener());
		fDesktop = newDesktop;
	}

	/**
	* Get the component, in which the content is embedded. This component
	* acts as a desktop for the content.
	*/
	public Desktop getDesktop() {
		return fDesktop;
	}

	/**
	 * Factory method to create a StorageFormatManager for supported storage formats.
	 * Different applications might want to use different storage formats and can return
	 * their own format manager by overriding this method.
	 */
	public StorageFormatManager createStorageFormatManager() {
		StorageFormatManager storageFormatManager = new StorageFormatManager();
		storageFormatManager.setDefaultStorageFormat(new StandardStorageFormat());
		storageFormatManager.addStorageFormat(storageFormatManager.getDefaultStorageFormat());
		storageFormatManager.addStorageFormat(new SerializationStorageFormat());
//		storageFormatManager.addStorageFormat(new JDOStorageFormat());
		return storageFormatManager;
	}

	/**
	 * Set the StorageFormatManager. The StorageFormatManager is used when storing and
	 * restoring Drawing from the file system.
	 */
	protected final void setStorageFormatManager(StorageFormatManager newStorageFormatManager) {
		fStorageFormatManager = newStorageFormatManager;
	}

	/**
	 * Return the StorageFormatManager for this application.The StorageFormatManager is
	 * used when storing and restoring Drawing from the file system.
	 */
	public StorageFormatManager getStorageFormatManager() {
		return fStorageFormatManager;
	}

	/**
	 * Gets the default size of the window.
	 */
	protected Dimension defaultSize() {
		return new Dimension(600,450);
	}

	/**
	 * Creates the status line.
	 */
	protected JTextField createStatusLine() {
		JTextField field = new JTextField("No Tool", 40);
		field.setBackground(Color.white);
		field.setEditable(false);
		return field;
	}

	private void setStatusLine(JTextField newStatusLine) {
		fStatusLine = newStatusLine;
	}

	protected JTextField getStatusLine() {
		return fStatusLine;
	}

	/**
	 * Handles a user selection in the palette.
	 * @@see PaletteListener
	 */
	public void paletteUserSelected(PaletteButton paletteButton) {
		ToolButton toolButton = (ToolButton)paletteButton;
		setTool(toolButton.tool(), toolButton.name());
		setSelected(toolButton);
	}

	/**
	 * Handles when the mouse enters or leaves a palette button.
	 * @@see PaletteListener
	 */
	public void paletteUserOver(PaletteButton paletteButton, boolean inside) {
		ToolButton toolButton = (ToolButton)paletteButton;
		if (inside) {
			showStatus(toolButton.name());
		}
		else if (fSelectedToolButton != null) {
			showStatus(fSelectedToolButton.name());
		}
	}

	/**
	 * Gets the current tool.
	 * @@see DrawingEditor
	 */
	public Tool tool() {
		return fTool;
	}

	/**
	 * Retrieve the active view from the window
	 * Gets the current drawing view.
	 * @@see DrawingEditor
	 */
	public DrawingView view() {
		return fView;
	}

	protected void setView(DrawingView newView) {
		DrawingView oldView = fView;
		fView = newView;
		fireViewSelectionChangedEvent(oldView, view());
	}

	public DrawingView[] views() {
		return new DrawingView[] { view() };
	}

	/**
	 * Sets the default tool of the editor.
	 * @@see DrawingEditor
	 */
	public void toolDone() {
		System.out.println("ToolDone");
		if (fDefaultToolButton != null) {
			setTool(fDefaultToolButton.tool(), fDefaultToolButton.name());
			setSelected(fDefaultToolButton);
		}
	}

	/**
	 * Fired by a view when the figure selection changes.  Since Commands and
	 * Tools may depend on the figure selection they are registered to be notified
	 * about these events.
	 * Any selection sensitive GUI component should update its
	 * own state if the selection has changed, e.g. selection sensitive menuitems
	 * will update their own states.
	 * @@see DrawingEditor
	 */
	public void figureSelectionChanged(DrawingView view) {
		checkCommandMenus();
	}

	protected void checkCommandMenus() {
		JMenuBar mb = getJMenuBar();

		for (int x = 0; x < mb.getMenuCount(); x++) {
		    JMenu jm = mb.getMenu(x);
			if (CommandMenu.class.isInstance(jm)) {
				checkCommandMenu((CommandMenu)jm);
			}
		}
	}

	protected void checkCommandMenu(CommandMenu cm) {
		cm.checkEnabled();
		for (int y = 0; y < cm.getItemCount();y++) {
			JMenuItem jmi = cm.getItem(y);
			if (CommandMenu.class.isInstance(jmi)) {
				checkCommandMenu((CommandMenu)jmi);
			}
		}
	}

	/**
	 * Register to hear when the active view is changed.  For Single document
	 * interface, this will happen when a new drawing is created.
	 */
	public void addViewChangeListener(ViewChangeListener vsl) {
		listeners.add(vsl);
	}

	/**
	 * Remove listener
	 */
	public void removeViewChangeListener(ViewChangeListener vsl) {
		listeners.remove(vsl);
	}

	/**
	 * An appropriate event is triggered and all registered observers
	 * are notified if the drawing view has been changed, e.g. by
	 * switching between several internal frames.  This method is
	 * usually not needed in SDI environments.
	 */
	protected void fireViewSelectionChangedEvent(DrawingView oldView, DrawingView newView) {
		ListIterator li= listeners.listIterator(listeners.size());
		while (li.hasPrevious()) {
			ViewChangeListener vsl = (ViewChangeListener)li.previous();
			vsl.viewSelectionChanged(oldView, newView);
		}
	}

	protected void fireViewCreatedEvent(DrawingView view) {
		ListIterator li= listeners.listIterator(listeners.size());
		while (li.hasPrevious()) {
			ViewChangeListener vsl = (ViewChangeListener)li.previous();
			vsl.viewCreated(view);
		}
	}

	protected void fireViewDestroyingEvent(DrawingView view) {
		ListIterator li= listeners.listIterator(listeners.size());
		while (li.hasPrevious()) {
			ViewChangeListener vsl = (ViewChangeListener)li.previous();
			vsl.viewDestroying( view );
		}
	}

	/**
	 * Shows a status message.
	 * @@see DrawingEditor
	 */
	public void showStatus(String string) {
		getStatusLine().setText(string);
	}

	/**
	 * Note: it is inconsistent to directly assign a variable but when using it
	 * use it from a method.  (assignment:  fTool = t, usage: tool()) dnoyeB-4/8/02
	 * Note:  should we check that the tool is inactive before we activate it?
	 * this would be consistent with how we do deactivate.  I think we should do
	 * this now and not wait till a bug pops up. even if their is no bug, its
	 * consistent and adds understandability to the code.  dnoyeB-4/8/02
	 */
	public void setTool(Tool t, String name) {
		// SF bug-tracker id: #490665

		// deactivate only those tools that have been activated before
		if ((tool() != null) && (tool().isActive())) {
			tool().deactivate();
		}
		fTool = t;
		if (tool() != null) {
			showStatus(name);
			tool().activate();
		}
	}

	private void setSelected(ToolButton button) {
		if (fSelectedToolButton != null) {
			fSelectedToolButton.reset();
		}
		fSelectedToolButton = button;
		if (fSelectedToolButton != null) {
			fSelectedToolButton.select();
		}
	}

	/**
	 * Exits the application. You should never override this method
	 */
	public void exit() {
		destroy();
	   // tell windowing system to free resources
		dispose();	
	}

	protected boolean closeQuery(){
		return true;
	}

	protected void endApp(){
		if(closeQuery() == true) {
			exit();
		}
	}
	/**
	 * Handles additional clean up operations. Override to destroy
	 * or release drawing editor resources.
	 */
	protected void destroy() {
	}

	/**
	 * Resets the drawing to a new empty drawing.
	 */
	public void promptNew() {
		newWindow(createDrawing());
		//toolDone();
		//view().setDrawing(createDrawing());
	}

	/**
	 * Shows a file dialog and opens a drawing.
	 */
	public void promptOpen() {
		toolDone();
		JFileChooser openDialog = createOpenFileChooser();
		getStorageFormatManager().registerFileFilters(openDialog);
		if (openDialog.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
			StorageFormat foundFormat = getStorageFormatManager().findStorageFormat(openDialog.getFileFilter());
			// ricardo_padilha: if there is no format associated,
			// try to find one that supports the file
			if (foundFormat == null) {
				foundFormat = getStorageFormatManager().findStorageFormat(openDialog.getSelectedFile());
			}
			if (foundFormat != null) {
				loadDrawing(foundFormat, openDialog.getSelectedFile().getAbsolutePath());
			}
			else {
				showStatus("Not a valid file format: " + openDialog.getFileFilter().getDescription());
			}
		}
	}

	/**
	 * Shows a file dialog and saves drawing.
	 */
	public void promptSaveAs() {
		if (view() != null) {
			toolDone();
			JFileChooser saveDialog = createSaveFileChooser();
			getStorageFormatManager().registerFileFilters(saveDialog);

			if (saveDialog.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
				StorageFormat foundFormat = getStorageFormatManager().findStorageFormat(saveDialog.getFileFilter());
				// ricardo_padilha: if there is no format associated,
				// try to find one that supports the file
				if (foundFormat == null) {
					foundFormat = getStorageFormatManager().findStorageFormat(saveDialog.getSelectedFile());
				}
				if (foundFormat != null) {
					saveDrawing(foundFormat, saveDialog.getSelectedFile().getAbsolutePath());
				}
				else {
					showStatus("Not a valid file format: " + saveDialog.getFileFilter().getDescription());
				}
			}
		}
	}

	/**
	 * Create a file chooser for the open file dialog. Subclasses may override this
	 * method in order to customize the open file dialog.
	 */
	protected JFileChooser createOpenFileChooser() {
		JFileChooser openDialog = new JFileChooser();
		openDialog.setDialogType(JFileChooser.OPEN_DIALOG);
		openDialog.setDialogTitle("Open File...");
		return openDialog;
	}

	/**
	 * Create a file chooser for the save file dialog. Subclasses may override this
	 * method in order to customize the save file dialog.
	 */
	protected JFileChooser createSaveFileChooser() {
		JFileChooser saveDialog = new JFileChooser();
		saveDialog.setDialogType(JFileChooser.SAVE_DIALOG);
		saveDialog.setDialogTitle("Save File...");
		return saveDialog;
	}

	/**
	 * Prints the drawing.
	 */
	public void print() {
		tool().deactivate();
		PrintJob printJob = getToolkit().getPrintJob(this, "Print Drawing", null);

		if (printJob != null) {
			Graphics pg = printJob.getGraphics();

			if (pg != null) {
				((StandardDrawingView)view()).printAll(pg);
				pg.dispose(); // flush page
			}
			printJob.end();
		}
		tool().activate();
	}

	/**
	 * Save a Drawing in a file
	 */
	protected void saveDrawing(StorageFormat storeFormat, String file) {
		// Need a better alert than this.
		if (view() == null) {
			return;
		}
		try {
			String name = storeFormat.store(file, view().drawing());
			view().drawing().setTitle(name);
			setDrawingTitle(name);
		}
		catch (IOException e) {
			showStatus(e.toString());
		}
	}

	/**
	 * Load a Drawing from a file
	 */
	protected void loadDrawing(StorageFormat restoreFormat, String file) {
		try {
			Drawing restoredDrawing = restoreFormat.restore(file);
			if (restoredDrawing != null) {
				restoredDrawing.setTitle(file);
				newWindow(restoredDrawing);
			}
			else {
			   showStatus("Unknown file type: could not open file '" + file + "'");
			}
		}
		catch (IOException e) {
			showStatus("Error: " + e);
		}
	}

	/**
	 * Switch to a new Look&Feel
	 */
	private void newLookAndFeel(String landf) {
		try {
			UIManager.setLookAndFeel(landf);
			SwingUtilities.updateComponentTreeUI(this);
		}
		catch (Exception e) {
			System.err.println(e);
		}
	}

	/**
	 * Set the title of the currently selected drawing
	 */
	protected void setDrawingTitle(String drawingTitle) {
		if (getDefaultDrawingTitle().equals(drawingTitle)) {
			setTitle(getApplicationName());
		}
		else {
			setTitle(getApplicationName() + " - " + drawingTitle);
		}
	}

	/**
	 * Return the title of the currently selected drawing
	 */
	protected String getDrawingTitle() {
		return view().drawing().getTitle();
	}

	/**
	 * Set the name of the application build from this skeleton application
	 */
	public void setApplicationName(String applicationName) {
		fApplicationName = applicationName;
	}

	/**
	 * Return the name of the application build from this skeleton application
	 */
	public String getApplicationName() {
		return fApplicationName;
	}

	protected void setUndoManager(UndoManager newUndoManager) {
		myUndoManager = newUndoManager;
	}

	public UndoManager getUndoManager() {
		return myUndoManager;
	}

	protected VersionControlStrategy getVersionControlStrategy() {
		return new StandardVersionControlStrategy(this);
	}

	/**
	 * Subclasses should override this method to specify to which versions of
	 * JHotDraw they are compatible. A string array is returned so it is possible
	 * to specify several version numbers of JHotDraw to which the application
	 * is compatible with.
	 *
	 * @@return all versions number of JHotDraw the application is compatible with.
	 */
	public String[] getRequiredVersions() {
		String[] requiredVersions = new String[1];
		// return the version of the package we are in
		requiredVersions[0] = VersionManagement.getPackageVersion(DrawApplication.class.getPackage());
		return requiredVersions;
	}

	public String getDefaultDrawingTitle() {
		return fgUntitled;
	}

	protected DesktopListener getDesktopListener() {
		return fDesktopListener;
	}

	protected void setDesktopListener(DesktopListener desktopPaneListener) {
		fDesktopListener = desktopPaneListener;
	}

	protected DesktopListener createDesktopListener() {
	    return new DesktopListener() {
			public void drawingViewAdded(DesktopEvent dpe) {
				DrawingView dv = dpe.getDrawingView();
				fireViewCreatedEvent(dv);
			}
			public void drawingViewRemoved(DesktopEvent dpe) {
				DrawingView dv = dpe.getDrawingView();
				// remove undo/redo activities which operate on this DrawingView
				getUndoManager().clearUndos(dv);
				getUndoManager().clearRedos(dv);
				fireViewDestroyingEvent(dv);
				checkCommandMenus();
			}
			public void drawingViewSelected(DesktopEvent dpe) {
				DrawingView dv = dpe.getDrawingView();
				//get the current selection and freeze it.
				if (dv != null) {
					if (dv.drawing() != null)
						dv.unfreezeView();
				}
				setView(dv);
			}
	    };
	}

	protected Iconkit createIconkit() {
		return new Iconkit(this);
	}

	protected void setIconkit(Iconkit newIconkit) {
		fIconkit = newIconkit;
	}

	protected Iconkit getIconkit() {
		return fIconkit;
	}
}
@


1.30
log
@no message
@
text
@d153 1
@


1.29
log
@Remove EventListenerList in favor of simple List where possible.
EventListenerList duplicates the whole list for each additional add and is
quite heavy for instances where its not required since these lists are not
modified from events they fire.
@
text
@d24 1
d234 2
d247 1
d251 1
d255 1
a255 1
					}					
d827 2
a828 2
		java.util.ListIterator li= listeners.listIterator(listeners.size());
		while(li.hasPrevious()){
d835 2
a836 2
		java.util.ListIterator li= listeners.listIterator(listeners.size());
		while(li.hasPrevious()){
d843 2
a844 2
		java.util.ListIterator li= listeners.listIterator(listeners.size());
		while(li.hasPrevious()){
a891 1
	 *
d897 1
a898 1
	}
d902 1
d940 2
a941 1
			}	else {
@


1.28
log
@Updated StorageFormat interface. Now formats are added based on their ability to load/save.
@
text
@a20 1
import javax.swing.event.EventListenerList;
d55 6
a60 1
	private final EventListenerList listenerList = new EventListenerList();
d102 1
d805 1
a805 1
		listenerList.add(ViewChangeListener.class, vsl);
d812 1
a812 1
		listenerList.remove(ViewChangeListener.class, vsl);
d822 4
a825 7
		final Object[] listeners = listenerList.getListenerList();
		ViewChangeListener vsl = null;
		for (int i = listeners.length-2; i>=0 ; i-=2) {
			if (listeners[i] == ViewChangeListener.class) {
				vsl = (ViewChangeListener)listeners[i+1];
				vsl.viewSelectionChanged(oldView, newView);
			}
d830 4
a833 7
		final Object[] listeners = listenerList.getListenerList();
		ViewChangeListener vsl = null;
		for (int i = listeners.length-2; i>=0 ; i-=2) {
			if (listeners[i] == ViewChangeListener.class) {
				vsl = (ViewChangeListener)listeners[i+1];
				vsl.viewCreated(view);
			}
d838 4
a841 7
		final Object[] listeners = listenerList.getListenerList();
		ViewChangeListener vsl = null;
		for (int i = listeners.length-2; i>=0 ; i-=2) {
			if (listeners[i] == ViewChangeListener.class) {
				vsl = (ViewChangeListener)listeners[i+1];
				vsl.viewDestroying( view );
			}
@


1.27
log
@Extended the concept of file-based search for storage format also to the save dialog.
@
text
@d977 1
d988 1
@


1.26
log
@New feature: If no storage format matches the filter selected by the user, then try to find one format by looking at the file.
This feature depends on the update made previously in StorageFormatManager to accept the search based on files.
@
text
@d956 5
@


1.25
log
@Redaction:  Need to maintain the behavior of exit() so I added a new method
to handle this new behavior.  Plus JavaDrawApp has an example yes-no close
dialog added.  Requires Swing of course..
@
text
@d932 5
d939 1
a939 2
			}
			else {
@


1.24
log
@Smoother exiting.  currently file->exit and pushing 'x' were not the same.
'x' caused dispose to be called, which triggered window closing, which called
dispose() again...
Also setVislble(true) must be called before drawings added to desktop.
@
text
@d218 1
a218 1
				endApp();//would prefer a method that allowed cleanup
d222 1
a222 1
				endApp();//would prefer a method that allowed cleanup
d237 1
a237 1
					exit();
d307 1
a307 1
				exit();
d891 1
a893 11
//		int reply = JOptionPane.showConfirmDialog(this,
//													  "Do you really want to exit?",
//													  "JHotDraw - Exit" ,
//													  JOptionPane.YES_NO_OPTION,
//													  JOptionPane.QUESTION_MESSAGE);
		// If the confirmation was affirmative, handle exiting.
//		if (reply == JOptionPane.YES_OPTION) {
			endApp();
//		}
	}
	protected final void endApp(){
d896 10
a905 1
		dispose();
@


1.23
log
@prepare for 5.4 release: various bug fixes
@
text
@d98 1
a99 1
		winCount++;
d199 4
a202 1
		//setVisible(true) called.
d218 1
a218 1
				exit();
d222 1
a222 1
				exit();
a227 3

		setVisible(true);
		toolDone();
d239 8
d893 11
d905 2
a906 6
		setVisible(false);      // hide the JFrame
		dispose();   // tell windowing system to free resources
		winCount--;
		if (winCount == 0) {
			System.exit(0);
		}
a907 1

@


1.22
log
@Merge with BUGFIX_670992
Animator is just a multithreaded fix modification.
@
text
@d144 3
a195 1
		setVisible(true);
d197 1
d209 1
a209 1
		if(java.awt.EventQueue.isDispatchThread() == false) {
d211 1
a211 1
				java.awt.EventQueue.invokeAndWait( r );
d213 1
a213 1
			catch(java.lang.InterruptedException ie){
d217 1
a217 1
			catch(java.lang.reflect.InvocationTargetException ite){
d225 3
d763 4
d1118 3
d1122 1
@


1.21
log
@Clean up head to be what it was before i mistakenly committed my changes to it.
My changes should have been committed to a branch, and let mrfloppy merge to the trunk.
This will happen from now on.
@
text
@d154 1
a154 1
	protected synchronized void open(DrawingView newDrawingView) {
d195 26
a220 2
		if (newDrawingView.isInteractive()) {
	    	getDesktop().addToDesktop(newDrawingView , Desktop.PRIMARY);
a221 1
		toolDone();
@


1.21.2.1
log
@Proposed Fix - Bug [ 670992 ] AWT deadlock
@
text
@d154 1
a154 1
	protected synchronized void open(final DrawingView newDrawingView) {
d195 2
a196 13
		//no work allowed to be done on GUI outside of AWT thread once
		//setVisible(true) called.
		Runnable r = new Runnable() {
			public void run() {			
			if (newDrawingView.isInteractive()) {
		    	getDesktop().addToDesktop(newDrawingView , Desktop.PRIMARY);
			}
			toolDone();
			}
		};
		
		try {
			SwingUtilities.invokeAndWait( r );
d198 1
a198 8
		catch(java.lang.InterruptedException ie){
			System.err.println(ie.getMessage());
			exit();
		}
		catch(java.lang.reflect.InvocationTargetException ite){
			System.err.println(ite.getMessage());
			exit();
		}			
@


1.21.2.2
log
@Final fix.
@
text
@d154 1
a154 1
	protected void open(final DrawingView newDrawingView) {
d198 5
a202 5
			public void run() {
				if (newDrawingView.isInteractive()) {
					getDesktop().addToDesktop(newDrawingView , Desktop.PRIMARY);
				}
				toolDone();
d206 2
a207 12
		if(java.awt.EventQueue.isDispatchThread() == false) {
			try {
				java.awt.EventQueue.invokeAndWait( r );
			}
			catch(java.lang.InterruptedException ie){
				System.err.println(ie.getMessage());
				exit();
			}
			catch(java.lang.reflect.InvocationTargetException ite){
				System.err.println(ite.getMessage());
				exit();
			}
d209 3
a211 2
		else {
			r.run();
d213 4
@


1.20
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d48 1
d52 1
a52 1
	private static String			fApplicationName;
d55 1
a55 1
	private String                  fgUntitled = "untitled";
d117 1
a117 2
        DrawingView dv = getDesktop().getActiveDrawingView();
		if (dv == null || !dv.isInteractive()) {//this should be ASSERT and otherwise handled by context sensitive menus.
d121 3
a123 5
		window.open();
        window.newWindow( dv.drawing() );

/*		if (dv.drawing().getTitle() != null ) {
			window.setDrawingTitle(dv.drawing().getTitle() + " (View)");
d127 1
a127 1
		}*/
d134 8
a141 4
	public void newWindow(Drawing newDrawing) {
        getDesktop().removeAllFromDesktop(Desktop.PRIMARY);
		getDesktop().addToDesktop( createDrawingView( newDrawing ), Desktop.PRIMARY);
		toolDone();
d143 6
a148 2
	public final void newWindow() {
        newWindow( createDrawing() );
d150 1
d154 1
a154 1
	public synchronized void open() {
d164 3
a166 3
        //Initialize Desktop, must be done before tools
		setDesktopListener(createDesktopListener());
		setDesktop(createDesktop());
a167 4
        //Initialize Tools
        // create dummy tool until the default tool is activated during toolDone()
        //why do we need a dummy tool?
		setTool(new NullTool(this), "");
d170 2
a171 2
        
        JPanel activePanel = new JPanel();
d176 2
d181 1
a181 4

 
        //Initialize Menus
        JMenuBar mb = new JMenuBar();
a193 1
      
d195 4
d340 1
a340 1
				getDesktop().getActiveDrawingView().setDisplayUpdate(new SimpleUpdateStrategy());
d347 1
a347 1
				getDesktop().getActiveDrawingView().setDisplayUpdate(new BufferedUpdateStrategy());
a540 3
     * Made this final so no one indavertently overrides it.  If you need to
     * override, override createDrawingView(Drawing newDrawing) below.
     * dnoyeb@@users.sourceforge.net
d542 4
a545 2
	protected final DrawingView createDrawingView() {
		return createDrawingView( createDrawing() );
d550 2
a551 1
		DrawingView newDrawingView = new StandardDrawingView(newDrawing, this, d.width, d.height);
d585 1
a585 3
        Drawing dwg = new StandardDrawing();
        dwg.setTitle( getDefaultDrawingTitle() );
		return dwg;
d589 1
a589 1
		return new JPanelDesktop();
d699 1
a699 1
		return getDesktop().getActiveDrawingView();
d702 1
a702 1
/*	protected void setView(DrawingView newView) {
d706 1
a706 1
	}*/
d709 1
a709 1
		return new DrawingView[] { getDesktop().getActiveDrawingView() };
d872 3
a874 1
        newWindow( );
d899 1
a899 1
		if (getDesktop().getActiveDrawingView() != null) {
d947 1
a947 1
				((StandardDrawingView)getDesktop().getActiveDrawingView()).printAll(pg);
d960 11
a970 11
        DrawingView dv = getDesktop().getActiveDrawingView();
		if (dv != null && dv.isInteractive() ) {
            try {
                String name = storeFormat.store(file, dv.drawing());
                dv.drawing().setTitle(name);
                updateApplicationTitle();
            }
            catch (IOException e) {
                showStatus(e.toString());
            }
        }
d1008 14
a1021 11
	protected void updateApplicationTitle() {
        DrawingView dv = getDesktop().getActiveDrawingView();
        if(dv != null && dv.isInteractive()){ //mrfloppy, we can do away with null check and ASSERT once their is always at least a NullDrawingView
            String drawingTitle = dv.drawing().getTitle();
            if (!getDefaultDrawingTitle().equals(drawingTitle)) {
                setTitle(getApplicationName() + " - " + drawingTitle);
            }
        }
        else {
            setTitle(getApplicationName());
        }
d1034 1
a1034 1
	public static String getApplicationName() {
d1065 1
a1065 7
    /**
     *  I made this protected because it should only be used by the DrawApplication.
     *  This is because all created drawings will be created through createDrawing()
     *  which is a method of DrawApplication.
     *  dnoyeb@@users.sourceforge.net 12/31/02
     */
	protected String getDefaultDrawingTitle() {
d1087 1
a1087 1
			public void drawingViewSelected(DrawingView oldView, DesktopEvent dpe) {
d1094 1
a1094 2
                fireViewSelectionChangedEvent(oldView, getDesktop().getActiveDrawingView());
                updateApplicationTitle();
@


1.19
log
@bug 541524, 546628,547188
Improved Desktop functionality

This is an extra commit because NetBeans left off my comments
@
text
@d51 1
a51 1
	private String					fApplicationName;
d54 1
a54 1
	protected static String			fgUntitled = "untitled";
d116 2
a117 1
		if (view() == null) {
d122 1
a122 1
        window.newWindow( view().drawing() );
d124 2
a125 2
		if (view().drawing().getTitle() != null ) {
			window.setDrawingTitle(view().drawing().getTitle() + " (View)");
d129 1
a129 1
		}
d335 1
a335 1
				this.view().setDisplayUpdate(new SimpleUpdateStrategy());
d342 1
a342 1
				this.view().setDisplayUpdate(new BufferedUpdateStrategy());
d586 1
a586 1
		return new JPanelDesktop(this);
d706 1
a706 1
		return new DrawingView[] { view() };
a869 2
		//toolDone();
		//view().setDrawing(createDrawing());
d894 1
a894 1
		if (view() != null) {
d942 1
a942 1
				((StandardDrawingView)view()).printAll(pg);
d955 11
a965 11
		if (view() == null) {
			return;
		}
		try {
			String name = storeFormat.store(file, view().drawing());
			view().drawing().setTitle(name);
			setDrawingTitle(name);
		}
		catch (IOException e) {
			showStatus(e.toString());
		}
d1003 11
a1013 14
	protected void setDrawingTitle(String drawingTitle) {
		if (getDefaultDrawingTitle().equals(drawingTitle)) {
			setTitle(getApplicationName());
		}
		else {
			setTitle(getApplicationName() + " - " + drawingTitle);
		}
	}

	/**
	 * Return the title of the currently selected drawing
	 */
	protected String getDrawingTitle() {
		return view().drawing().getTitle();
d1026 1
a1026 1
	public String getApplicationName() {
d1057 7
a1063 1
	public String getDefaultDrawingTitle() {
d1092 2
a1093 1
                                fireViewSelectionChangedEvent(oldView, view());
@


1.18
log
@*** empty log message ***
@
text
@@


1.17
log
@bug fix for Sourceforge-bug-id 623257
@
text
@a47 1
	private DrawingView				fView;
d120 3
a122 1
		window.open(view());
d135 4
a138 8
	public void newWindow(Drawing initialDrawing) {
		DrawApplication window = createApplication();
		if (initialDrawing == null) {
			window.open();
		}
		else {
			window.open(window.createDrawingView(initialDrawing));
		}
d140 2
a141 6

	/**
	 * Opens a new window
	 */
	public void open() {
		open(createInitialDrawingView());
a142 1

d146 1
a146 1
	protected synchronized void open(DrawingView newDrawingView) {
d156 7
a162 1
		// create dummy tool until the default tool is activated during toolDone()
a163 2
		setView(newDrawingView);

d166 2
a167 2

		JPanel activePanel = new JPanel();
a171 2
		setDesktopListener(createDesktopListener());
		setDesktop(createDesktop());
d175 4
a178 1
		JMenuBar mb = new JMenuBar();
d191 1
a192 4
		if (newDrawingView.isInteractive()) {
	    	getDesktop().addToDesktop(newDrawingView , Desktop.PRIMARY);
		}
		toolDone();
d535 3
d539 2
a540 4
	protected DrawingView createDrawingView() {
		DrawingView createdDrawingView = createDrawingView(createDrawing());
		createdDrawingView.drawing().setTitle(getDefaultDrawingTitle());
		return createdDrawingView;
d545 1
a545 2
		DrawingView newDrawingView = new StandardDrawingView(this, d.width, d.height);
		newDrawingView.setDrawing(newDrawing);
d579 3
a581 1
		return new StandardDrawing();
d695 1
a695 1
		return fView;
d698 1
a698 1
	protected void setView(DrawingView newView) {
d702 1
a702 1
	}
d868 1
a868 1
		newWindow(createDrawing());
d1083 1
a1083 1
			public void drawingViewSelected(DesktopEvent dpe) {
d1090 1
a1090 1
				setView(dv);
@


1.17.4.1
log
@Changes for better Desktop handling.
DrawingView Always has a Drawing.
bug 541524, 546628,547188
@
text
@d48 1
d121 1
a121 3
		window.open();
        window.newWindow( view().drawing() );

d134 8
a141 4
	public void newWindow(Drawing newDrawing) {
        getDesktop().removeAllFromDesktop(Desktop.PRIMARY);
		getDesktop().addToDesktop( createDrawingView( newDrawing ), Desktop.PRIMARY);
		toolDone();
d143 6
a148 2
	public final void newWindow() {
        newWindow( createDrawing() );
d150 1
d154 1
a154 1
	public synchronized void open() {
d164 3
a166 3
        //Initialize Desktop, must be done before tools
		setDesktopListener(createDesktopListener());
		setDesktop(createDesktop());
a167 4
        //Initialize Tools
        // create dummy tool until the default tool is activated during toolDone()
        //why do we need a dummy tool?
		setTool(new NullTool(this), "");
d170 2
a171 2
        
        JPanel activePanel = new JPanel();
d176 2
d181 1
a181 4

 
        //Initialize Menus
        JMenuBar mb = new JMenuBar();
a193 1
      
d195 4
a540 3
     * Made this final so no one indavertently overrides it.  If you need to
     * override, override createDrawingView(Drawing newDrawing) below.
     * dnoyeb@@users.sourceforge.net
d542 4
a545 2
	protected final DrawingView createDrawingView() {
		return createDrawingView( createDrawing() );
d550 2
a551 1
		DrawingView newDrawingView = new StandardDrawingView(newDrawing, this, d.width, d.height);
d585 1
a585 3
        Drawing dwg = new StandardDrawing();
        dwg.setTitle( getDefaultDrawingTitle() );
		return dwg;
d699 1
a699 1
		return getDesktop().getActiveDrawingView();
d702 1
a702 1
/*	protected void setView(DrawingView newView) {
d706 1
a706 1
	}*/
d872 1
a872 1
        newWindow( );
d1087 1
a1087 1
			public void drawingViewSelected(DrawingView oldView, DesktopEvent dpe) {
d1094 1
a1094 1
                                fireViewSelectionChangedEvent(oldView, view());
@


1.17.4.2
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d51 1
a51 1
	private static String			fApplicationName;
d54 1
a54 1
	private String                  fgUntitled = "untitled";
d116 1
a116 2
        DrawingView dv = getDesktop().getActiveDrawingView();
		if (dv == null || !dv.isInteractive()) {//this should be ASSERT and otherwise handled by context sensitive menus.
d121 1
a121 1
        window.newWindow( dv.drawing() );
d123 2
a124 2
/*		if (dv.drawing().getTitle() != null ) {
			window.setDrawingTitle(dv.drawing().getTitle() + " (View)");
d128 1
a128 1
		}*/
d334 1
a334 1
				getDesktop().getActiveDrawingView().setDisplayUpdate(new SimpleUpdateStrategy());
d341 1
a341 1
				getDesktop().getActiveDrawingView().setDisplayUpdate(new BufferedUpdateStrategy());
d585 1
a585 1
		return new JPanelDesktop();
d705 1
a705 1
		return new DrawingView[] { getDesktop().getActiveDrawingView() };
d869 2
d895 1
a895 1
		if (getDesktop().getActiveDrawingView() != null) {
d943 1
a943 1
				((StandardDrawingView)getDesktop().getActiveDrawingView()).printAll(pg);
d956 11
a966 11
        DrawingView dv = getDesktop().getActiveDrawingView();
		if (dv != null && dv.isInteractive() ) {
            try {
                String name = storeFormat.store(file, dv.drawing());
                dv.drawing().setTitle(name);
                updateApplicationTitle();
            }
            catch (IOException e) {
                showStatus(e.toString());
            }
        }
d1004 14
a1017 11
	protected void updateApplicationTitle() {
        DrawingView dv = getDesktop().getActiveDrawingView();
        if(dv != null && dv.isInteractive()){ //mrfloppy, we can do away with null check and ASSERT once their is always at least a NullDrawingView
            String drawingTitle = dv.drawing().getTitle();
            if (!getDefaultDrawingTitle().equals(drawingTitle)) {
                setTitle(getApplicationName() + " - " + drawingTitle);
            }
        }
        else {
            setTitle(getApplicationName());
        }
d1030 1
a1030 1
	public static String getApplicationName() {
d1061 1
a1061 7
    /**
     *  I made this protected because it should only be used by the DrawApplication.
     *  This is because all created drawings will be created through createDrawing()
     *  which is a method of DrawApplication.
     *  dnoyeb@@users.sourceforge.net 12/31/02
     */
	protected String getDefaultDrawingTitle() {
d1090 1
a1090 2
                fireViewSelectionChangedEvent(oldView, getDesktop().getActiveDrawingView());
                updateApplicationTitle();
@


1.17.4.3
log
@Modified ViewChangeListener
ViewCreated -> ViewActivated
ViewDestroying -> ViewDeactivated
@
text
@d783 1
a783 1
	protected void fireViewActivatedEvent(DrawingView view) {
d789 1
a789 1
				vsl.viewActivated(view);
d794 1
a794 1
	protected void fireViewDeactivatedEvent(DrawingView view) {
d800 1
a800 1
				vsl.viewDeactivated( view );
d1079 1
a1079 1
				fireViewActivatedEvent(dv);
d1083 1
a1083 1
				fireViewDeactivatedEvent(dv);
@


1.17.4.4
log
@1. Added getDesktop to the DrawingEditor.  added null returns to all Classes that dont fully support
   the Desktop architecture yet, like the applets.

2. Added a figureSelection listener to the DrawingEditor so one can register with the DrawingEditor to
   hear figure selection events.  You can still register with the individual DrawingViews if you wish.
   The DrawingEditor will guarantee that it only fires this event on the active view, so it saves a listener
   from having to register and unregister with views to hear this event each time the activeView changes.
   All Commands were doing this register/unregister dance.

3. AbstractCommand now registers for figureSelectionEvents with the drawingEditor as opposed to the
   DrawingView.

4. Went back to viewCreated and viewDestroying naming.  flip flopping.  Its actually more accurate.  the
   real issue is that 2 events are missing, viewDestroyed and viewCreating.  dont need them yet, but
   they may materialize in the future.

5. Went back to Tool CompositeTool being enabled even when no figure is selected.

6. FigureSelectionListener now extends java.util.EventListener now because I am too lazy to write
   an event handler just yet.

7. implemented new findFigureInside() fix.  needs testing.

8. standardDrawingView selectionZordered now returns figures in the proper order(not reversed).
@
text
@d57 1
d721 9
a730 6
		fireFigureSelectionChanged(view);
		checkCommandMenu();//commands already know about this event, why do we need this?
		//maybe the menu should listen to the Command it contains.
	}
	
	protected void checkCommandMenu(){
d734 1
a734 1
			JMenu jm = mb.getMenu(x);
d740 1
d765 1
a765 18
	public void addFigureSelectionListener(FigureSelectionListener fsl){
		listenerList.add(FigureSelectionListener.class, fsl);
	}
	public void removeFigureSelectionListener(FigureSelectionListener fsl){
		listenerList.remove(FigureSelectionListener.class, fsl);
	}
	
	protected void fireFigureSelectionChanged(DrawingView view){
		final Object[] listeners = listenerList.getListenerList();
		FigureSelectionListener fsl = null;
		for (int i = listeners.length-2; i>=0 ; i-=2) {
			if (listeners[i] == FigureSelectionListener.class) {
				fsl = (FigureSelectionListener)listeners[i+1];
				fsl.figureSelectionChanged(view);
			}
		}		
	}
	
d770 1
a770 2
	 * usually invoked only when DrawingViews are created in SDI environments.
	 *
d783 1
a783 1
	protected void fireViewCreatedEvent(DrawingView view) {
d789 1
a789 1
				vsl.viewCreated(view);
d794 1
a794 1
	protected void fireViewDestroyingEvent(DrawingView view) {
d800 1
a800 1
				vsl.viewDestroying( view );
d1074 1
a1074 4
	/**
	 * @@todo We need to use DrawingEditor events instead of or in addition to
	 *       these.
	 */
d1078 2
a1079 1
				fireViewCreatedEvent( dpe.getDrawingView() );
d1082 2
a1083 1
				fireViewDestroyingEvent( dpe.getDrawingView() );
d1087 1
a1087 1
				//get the current selection and unfreeze it.
d1092 1
a1092 1
                fireViewSelectionChangedEvent(oldView, dv);
a1093 4
				if(oldView != null)
					oldView.removeFigureSelectionListener( DrawApplication.this );
				if(dv != null)
					dv.addFigureSelectionListener( DrawApplication.this );
@


1.17.4.5
log
@Fix [ 670992 ] AWT deadlock
Improvement to Animator
@
text
@d190 2
a192 1
		setVisible(true);
@


1.17.4.6
log
@Related to Proposed Fix - Bug [ 670992 ] AWT deadlock
In main branch the open method cant be synchronized, so I made the change here
to facilitate merging eventually.
@
text
@d146 1
a146 1
	public void open() {
@


1.17.4.7
log
@hack for [ 674973 ] Context Sensitive menu updates
add used instead of restore since its easier for the CompositeFigure to decide wether to add or
to restore.
@
text
@a191 24
		
		Runnable r = new Runnable() {
			public void run() {
				toolDone();
				checkCommandMenu();
			}
		};

		if(java.awt.EventQueue.isDispatchThread() == false) {
			try {
				java.awt.EventQueue.invokeAndWait( r );
			}
			catch(java.lang.InterruptedException ie){
				System.err.println(ie.getMessage());
				exit();
			}
			catch(java.lang.reflect.InvocationTargetException ite){
				System.err.println(ite.getMessage());
				exit();
			}
		}
		else {
			r.run();
		}
d352 1
a352 1
		CommandMenu menu = new CommandMenu("Attributes");
d694 1
a694 5
		DrawingView dv = getDesktop().getActiveDrawingView();
		if(dv == null) {
			dv = NullDrawingView.getManagedDrawingView(this);
		}
		return dv;
d704 1
a704 1
		return new DrawingView[] { view() };
d730 11
a740 2
			if (jm instanceof CommandMenu) {
				((CommandMenu)jm).checkEnabled();
a1110 3
				figureSelectionChanged(dv);//new view, new figure selection is active(this will cause extra events sometimes )
				//because when tools deactivate due to viewchange they will clear selection and fire event too
				//not hurting now, but need work.
@


1.17.4.8
log
@Undo clears when file saved.
@
text
@a930 2
				getUndoManager().clearRedos();//should actually be per drawing
				getUndoManager().clearUndos();//should actually have 1 manager per dwg.
d1036 1
a1036 1
        if(dv != null && dv.isInteractive()){
@


1.17.4.9
log
@clean up exiting a bit more.
use view() as opposed to getDesktop.getActiveView() in drawApplication
wherever possible.
@
text
@a95 1
		setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);	
d97 1
d115 1
a115 1
        DrawingView dv = view();
d206 1
a206 1
				endApp();//would prefer a method that allowed cleanup
d210 1
a210 1
				endApp();//would prefer a method that allowed cleanup
a226 8
				public void windowOpened(WindowEvent event) {
					winCount++;
				}
				public void windowClosed(WindowEvent event) {
					if (--winCount == 0) {
						System.exit(0);
					}					
				}
d357 1
a357 1
				this.view().setDisplayUpdate(new SimpleUpdateStrategy());
d364 1
a364 1
				this.view().setDisplayUpdate(new BufferedUpdateStrategy());
d877 1
a877 2
	 * Exits the application. You should never override this method unless you
	 * wish to verify the users intentions to exit the application.
a879 11
//		int reply = JOptionPane.showConfirmDialog(this,
//													  "Do you really want to exit?",
//													  "JHotDraw - Exit" ,
//													  JOptionPane.YES_NO_OPTION,
//													  JOptionPane.QUESTION_MESSAGE);
		// If the confirmation was affirmative, handle exiting.
//		if (reply == JOptionPane.YES_OPTION) {
			endApp();
//		}
	}
	protected final void endApp(){
d881 6
a886 2
	   // tell windowing system to free resources
		dispose();
d888 1
d925 1
a925 1
		if (view() != null) {
d975 1
a975 1
				((StandardDrawingView)view()).printAll(pg);
d988 1
a988 1
        DrawingView dv = view();
d1037 1
a1037 1
        DrawingView dv = view();
@


1.17.4.10
log
@changes to make sure exit maintained its existing(prior) behavior.
@
text
@d206 1
a206 1
				exit();
d210 1
a210 1
				exit();//would prefer a method that allowed cleanup
d225 1
a225 1
					endApp();
d295 1
a295 1
				endApp();
d889 11
d902 1
a902 10
		dispose();	

	}
	protected boolean closeQuery(){
		return true;
	}
	protected void endApp(){
		if(closeQuery() == true) {
			exit();
		}
@


1.16
log
@bug fix for Sourceforge-bug-id 623257
@
text
@d346 1
a346 1
			public void executable() {
@


1.15
log
@bug fix for Sourceforge-bug-id 617389
@
text
@d339 1
a339 1
			public void executable() {
@


1.14
log
@no message
@
text
@d140 1
a140 1
			window.open(createDrawingView(initialDrawing));
@


1.13
log
@removed remains of FigureAttributeConstant.getName() and some code-clean up
@
text
@d1103 1
a1103 1
	private void setIconkit(Iconkit newIconkit) {
@


1.12
log
@no message
@
text
@d360 2
a361 2
		menu.add(createColorMenu("Fill Color", FigureAttributeConstant.FILL_COLOR.getName()));
		menu.add(createColorMenu("Pen Color", FigureAttributeConstant.FRAME_COLOR.getName()));
d367 1
a367 1
		menu.add(createColorMenu("Text Color", FigureAttributeConstant.TEXT_COLOR.getName()));
d374 1
a374 1
	protected JMenu createColorMenu(String title, String attribute) {
d394 1
a394 1
		String arrowModeStr = FigureAttributeConstant.ARROW_MODE.getName();
d397 1
a397 1
			new ChangeAttributeCommand("none", arrowModeStr, new Integer(PolyLineFigure.ARROW_TIP_NONE), this)));
d399 1
a399 1
			new ChangeAttributeCommand("at Start", arrowModeStr, new Integer(PolyLineFigure.ARROW_TIP_START), this)));
d401 1
a401 1
			new ChangeAttributeCommand("at End", arrowModeStr, new Integer(PolyLineFigure.ARROW_TIP_END), this)));
d403 1
a403 1
			new ChangeAttributeCommand("at Both", arrowModeStr, new Integer(PolyLineFigure.ARROW_TIP_BOTH), this)));
d416 1
a416 1
				new ChangeAttributeCommand(fonts[i], FigureAttributeConstant.FONT_NAME.getName(), fonts[i],  this)));
d425 1
a425 1
		String fontStyleStr = FigureAttributeConstant.FONT_STYLE.getName();
d428 1
a428 1
			new ChangeAttributeCommand("Plain", fontStyleStr, new Integer(Font.PLAIN), this)));
d430 1
a430 1
			new ChangeAttributeCommand("Italic", fontStyleStr, new Integer(Font.ITALIC), this)));
d432 1
a432 1
			new ChangeAttributeCommand("Bold", fontStyleStr, new Integer(Font.BOLD), this)));
d447 1
a447 1
						FigureAttributeConstant.FONT_SIZE.getName(),
@


1.11
log
@after variou merges... (before 5.4 release)
@
text
@d161 2
a162 2
		fStatusLine = createStatusLine();
		getContentPane().add(fStatusLine, BorderLayout.SOUTH);
d194 1
a194 1
		fStorageFormatManager = createStorageFormatManager();
d624 2
a625 2
	protected final void setStorageFormatManager(StorageFormatManager storageFormatManager) {
		fStorageFormatManager = storageFormatManager;
d653 8
d813 1
a813 1
		fStatusLine.setText(string);
@


1.10
log
@after variou merges... (before 5.4 release)
@
text
@d728 1
a728 1
		for (int x=0; x < mb.getMenuCount(); x++) {
d738 1
a738 1
		for(int y=0;y < cm.getItemCount();y++){
d740 1
a740 1
			if(CommandMenu.class.isInstance(jmi)){
@


1.9
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@d18 2
a23 1
import java.util.*;
d57 6
d148 1
a148 4
		DrawingView initialDrawingView = createInitialDrawingView();
		initialDrawingView.setDrawing(createDrawing());
		initialDrawingView.drawing().setTitle(getDefaultDrawingTitle());
		open(initialDrawingView);
d157 1
a157 1
		fIconkit = new Iconkit(this);
a166 2
		JComponent contents = createContents(view());
		contents.setAlignmentX(LEFT_ALIGNMENT);
d176 3
a178 2
		activePanel.add(contents, BorderLayout.CENTER);

d195 3
a197 1

d495 1
a495 2
		Tool tool = createSelectionTool();
		setDefaultTool(createDefaultToo());
d507 1
a507 1
	protected Tool createDefaultToo() {
d552 2
a553 1
		fireViewCreatedEvent(newDrawingView);
d588 10
d599 5
a603 15
	 * Creates the contents component of the application
	 * frame. By default the DrawingView is returned in
	 * a JScrollPane.
	 */
	protected JComponent createContents(DrawingView view) {
		if (view instanceof Component) {
			JScrollPane sp = new JScrollPane((Component)view);
			sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
			sp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);

			return sp;
		}
		else {
			return new JPanel();
		}
d616 1
d709 1
d717 3
a719 2
	 * Fired by a view when the figure seleciton changes.  Since Commands and
	 * Tools are Actions they are registered to be notified about these events.
d721 2
a722 1
	 * own state if the selection has changed.
d727 15
a741 19
		CommandMenu editMenu = (CommandMenu)mb.getMenu(EDIT_MENU);
		// make sure it does exist
		if (editMenu != null) {
			editMenu.checkEnabled();
		}
		CommandMenu alignmentMenu = (CommandMenu)mb.getMenu(ALIGNMENT_MENU);
		// make sure it does exist
		if (alignmentMenu != null) {
			alignmentMenu.checkEnabled();
		}

		JMenu attributeMenu = mb.getMenu(ATTRIBUTES_MENU);
		// make sure it does exist
		if (attributeMenu != null) {
			for (int i = 0; i < attributeMenu.getItemCount(); i++) {
				JMenuItem currentMenu = attributeMenu.getItem(i);
				if (currentMenu instanceof CommandMenu) {
					((CommandMenu)currentMenu).checkEnabled();
				}
d808 8
d864 3
a866 3
		toolDone();
		view().setDrawing(createDrawing());
		view().drawing().setTitle(getDefaultDrawingTitle());
d891 13
a903 11
		toolDone();
		JFileChooser saveDialog = createSaveFileChooser();
		getStorageFormatManager().registerFileFilters(saveDialog);

		if (saveDialog.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
			StorageFormat foundFormat = getStorageFormatManager().findStorageFormat(saveDialog.getFileFilter());
			if (foundFormat != null) {
				saveDrawing(foundFormat, saveDialog.getSelectedFile().getAbsolutePath());
			}
			else {
				showStatus("Not a valid file format: " + saveDialog.getFileFilter().getDescription());
d978 2
a979 1
		} catch (IOException e) {
d1057 1
a1057 1
	protected String getDefaultDrawingTitle() {
d1059 42
@


1.8
log
@no message
@
text
@d491 1
a491 1
		fDefaultToolButton = createToolButton(IMAGES+"SEL", "Selection Tool", tool);
d503 22
d666 1
a666 1
		else {
@


1.7
log
@no message
@
text
@d141 4
a144 1
		open(createInitialDrawingView());
d150 1
a150 1
	protected void open(DrawingView newDrawingView) {
d355 2
a356 2
		menu.add(createColorMenu("Fill Color", "FillColor"));
		menu.add(createColorMenu("Pen Color", "FrameColor"));
d362 1
a362 1
		menu.add(createColorMenu("Text Color", "TextColor"));
d389 1
d392 1
a392 1
			new ChangeAttributeCommand("none", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE), this)));
d394 1
a394 1
			new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), this)));
d396 1
a396 1
			new ChangeAttributeCommand("at End", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END), this)));
d398 1
a398 1
			new ChangeAttributeCommand("at Both", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH), this)));
d411 1
a411 1
				new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  this)));
d420 1
d423 1
a423 1
			new ChangeAttributeCommand("Plain", "FontStyle", new Integer(Font.PLAIN), this)));
d425 1
a425 1
			new ChangeAttributeCommand("Italic","FontStyle", new Integer(Font.ITALIC), this)));
d427 1
a427 1
			new ChangeAttributeCommand("Bold",  "FontStyle", new Integer(Font.BOLD), this)));
d442 1
a442 1
						"FontSize",
a594 1
	 * Should we through IllegalArguementException if it is?
d629 2
a630 2
	public void paletteUserSelected(PaletteButton button) {
		ToolButton toolButton = (ToolButton) button;
d639 2
a640 2
	public void paletteUserOver(PaletteButton button, boolean inside) {
		ToolButton toolButton = (ToolButton) button;
d689 3
a691 3
	 * Tools are Actions and they are registered to hear these events, they will
	 * handle themselves.  So selection sensitive menuitems will update their
	 * own states.
d915 1
a915 1
		if(view() == null) {
@


1.6
log
@merge dnd (before 5.3)
@
text
@d104 1
a104 1
	
d136 1
a136 1
	
d141 1
a141 2
		open(NullDrawingView.getManagedDrawingView(this));
//		open(createDrawingView());
d145 1
a145 1
	 * Opens a new window with a drawing view. 
d153 6
a172 1
		fStatusLine = createStatusLine();
a173 1
		getContentPane().add(fStatusLine, BorderLayout.SOUTH);
d178 1
a178 1
		
d223 1
a223 1
	
d456 1
a456 1
			final String lnfClassName = lafs[i].getClassName(); 
d526 14
d566 1
a566 1
	
d599 1
a599 1
	 */        
d603 1
a603 1
	
d667 1
a667 1
	
d699 1
a699 1
		if (editMenu != null) {
d731 4
a734 2
	 * Convience method for switching views.  This is uneeded in SDI
	 * environments.
d777 5
a781 3
	private void setTool(Tool t, String name) {
		// We should not really deactivate a tool which was never activated.
		if (tool() != null) {
d880 1
a880 1
	 */	
d886 1
a886 1
	
d925 1
a925 1
	 * Load a Drawing from a file 
d976 1
a976 1
	 */	
d983 1
a983 1
	 */	
d991 1
a991 1
	
d995 1
a995 1
	
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d14 4
d19 1
a23 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.figures.*;
import CH.ifa.draw.util.*;
d26 3
a28 2
 * DrawApplication defines a standard presentation for standalone drawing 
 * editors. The presentation is customized in subclasses.
d39 1
a39 1
public  class DrawApplication
d41 1
a41 1
		implements DrawingEditor, PaletteListener {
d43 13
a55 13
	private Drawing              fDrawing;
	private Tool                 fTool;
	private Iconkit              fIconkit;

	private JTextField           fStatusLine;
	private DrawingView  fView;
	private ToolButton           fDefaultToolButton;
	private ToolButton           fSelectedToolButton;

	private String               fApplicationName;
	private String               fDrawingFilename;
	private StorageFormatManager fStorageFormatManager;
	static String                fgUntitled = "untitled";
d58 3
a60 2
	private static final String fgDrawPath = "/CH/ifa/draw/";
	public static final String IMAGES = fgDrawPath + "images/";
d65 1
a65 1
	public static final int    FILE_MENU = 0;
d69 1
a69 1
	public static final int    EDIT_MENU = 1;
d73 1
a73 1
	public static final int    ALIGNMENT_MENU = 2;
d77 1
a77 2
	public static final int    ATTRIBUTES_MENU = 3;

d92 1
d110 3
d114 7
a120 3
		window.open();
		window.setDrawing(drawing());
		window.setDrawingTitle(getDrawingTitle() + " (View)");
d124 2
a125 2
	 * Open a new window for this application containing
	 * an new (empty) drawing.
d127 1
a127 1
	public void newWindow() {
d129 6
a134 1
		window.open();
d138 1
a138 2
	 * Opens the window and initializes its contents.
	 * Clients usually only call but don't override it.
d141 10
d153 3
a155 2
		fView = createDrawingView();
		JComponent contents = createContents((StandardDrawingView)view());
a160 1

a175 2
		initDrawing();
		
d186 2
a202 7
	protected void initDrawing() {
		setDrawing(createDrawing());
		setDrawingTitle(fgUntitled);
		view().setDrawing(drawing());
		toolDone();
	}

d226 18
a243 7
		JMenu menu = new JMenu("File");
		JMenuItem mi = new JMenuItem("New", new MenuShortcut('n').getKey());
		mi.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					promptNew();
				}
d245 3
a247 2
		);
		menu.add(mi);
d249 3
a251 6
		mi = new JMenuItem("Open...", new MenuShortcut('o').getKey());
		mi.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					promptOpen();
				}
d253 3
a255 2
		);
		menu.add(mi);
d257 3
a259 6
		mi = new JMenuItem("Save As...", new MenuShortcut('s').getKey());
		mi.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					promptSaveAs();
				}
d261 2
a262 23
		);
		menu.add(mi);

		menu.addSeparator();
		mi = new JMenuItem("Print...", new MenuShortcut('p').getKey());
		mi.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					print();
				}
			}
		);
		menu.add(mi);
		menu.addSeparator();
		mi = new JMenuItem("Exit");
		mi.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					exit();
				}
			}
		);
		menu.add(mi);
d273 1
a273 1
			new SelectAllCommand("Select All", view())), new MenuShortcut('a'));
d276 2
a277 2
			new CutCommand("Cut", view())), new MenuShortcut('x'));
		menu.add(new CopyCommand("Copy", view()), new MenuShortcut('c'));
d279 1
a279 1
			new PasteCommand("Paste", view())), new MenuShortcut('v'));
d282 2
a283 2
			new DuplicateCommand("Duplicate", view())), new MenuShortcut('d'));
		menu.add(new UndoableCommand(new DeleteCommand("Delete", view())));
d285 2
a286 2
		menu.add(new UndoableCommand(new GroupCommand("Group", view())));
		menu.add(new UndoableCommand(new UngroupCommand("Ungroup", view())));
d288 2
a289 2
		menu.add(new UndoableCommand(new SendToBackCommand("Send to Back", view())));
		menu.add(new UndoableCommand(new BringToFrontCommand("Bring to Front", view())));
d291 2
a292 2
		menu.add(new UndoCommand("Undo Command", view()));
		menu.add(new RedoCommand("Redo Command", view()));
d302 1
a302 1
		menu.addCheckItem(new ToggleGridCommand("Toggle Snap to Grid", view(), new Point(4,4)));
d305 1
a305 1
			new AlignCommand(AlignCommand.Alignment.LEFTS, view())));
d307 1
a307 1
			new AlignCommand(AlignCommand.Alignment.CENTERS, view())));
d309 1
a309 1
			new AlignCommand(AlignCommand.Alignment.RIGHTS, view())));
d312 1
a312 1
			new AlignCommand(AlignCommand.Alignment.TOPS, view())));
d314 1
a314 1
			new AlignCommand(AlignCommand.Alignment.MIDDLES, view())));
d316 1
a316 1
			new AlignCommand(AlignCommand.Alignment.BOTTOMS, view())));
d325 1
a325 1
		JMenu menu = new JMenu("Debug");
d327 3
a329 6
		JMenuItem mi = new JMenuItem("Simple Update");
		mi.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					view().setDisplayUpdate(new SimpleUpdateStrategy());
				}
d331 2
a332 2
		);
		menu.add(mi);
d334 3
a336 6
		mi = new JMenuItem("Buffered Update");
		mi.addActionListener(
			new ActionListener() {
				public void actionPerformed(ActionEvent event) {
					view().setDisplayUpdate(new BufferedUpdateStrategy());
				}
d338 2
a339 2
		);
		menu.add(mi);
d372 1
a372 1
						view()
d385 1
a385 1
			new ChangeAttributeCommand("none", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE),  view())));
d387 1
a387 1
			new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), view())));
d389 1
a389 1
			new ChangeAttributeCommand("at End", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END),   view())));
d391 1
a391 1
			new ChangeAttributeCommand("at Both", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH),  view())));
d402 1
a402 1
		for (int i = 0; i < fonts.length; i++)
d404 2
a405 1
				new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  view())));
d415 1
a415 1
			new ChangeAttributeCommand("Plain", "FontStyle", new Integer(Font.PLAIN), view())));
d417 1
a417 1
			new ChangeAttributeCommand("Italic","FontStyle", new Integer(Font.ITALIC),view())));
d419 1
a419 1
			new ChangeAttributeCommand("Bold",  "FontStyle", new Integer(Font.BOLD),  view())));
d435 2
a436 1
						new Integer(sizes[i]),  view())
d438 2
a439 1
				);
d448 1
a448 1
		JMenu menu = new JMenu("Look'n'Feel");
a450 1
		JMenuItem mi = null;
a452 1
			mi = new JMenuItem(lafs[i].getName());
d454 3
a456 5
			mi.addActionListener(
				new ActionListener() {
					public void actionPerformed(ActionEvent event) {
						newLookAndFeel(lnfClassName);
					}
d458 2
a459 2
			);
			menu.add(mi);
d492 1
a492 1
		return new SelectionTool(view());
d509 6
d516 4
a519 1
		return new StandardDrawingView(this, d.width, d.height);
d545 10
a554 5
		JScrollPane sp = new JScrollPane((StandardDrawingView)view);
		sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
		sp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);

		return sp;
d573 1
d575 1
a575 1
	private void setStorageFormatManager(StorageFormatManager storageFormatManager) {
a587 8
	 * Sets the drawing to be edited.
	 */
	public void setDrawing(Drawing drawing) {
		view().setDrawing(drawing);
		fDrawing = drawing;
	}

	/**
a628 8
	 * Gets the current drawing.
	 * @@see DrawingEditor
	 */
	public Drawing drawing() {
		return fDrawing;
	}

	/**
d637 1
d645 10
d667 4
a670 2
	 * Handles a change of the current selection. Updates all
	 * menu items that are selection sensitive.
d699 52
d759 2
a760 1
		if (tool() != null)
d762 1
d787 4
a790 1
		System.exit(0);
d805 2
a806 1
		initDrawing();
d889 4
d894 3
a896 1
			setDrawingTitle(storeFormat.store(file, drawing()));
d910 2
a911 3
				newWindow();
				setDrawing(restoredDrawing);
				setDrawingTitle(file);
d938 1
a938 2
		fDrawingFilename = drawingTitle;
		if (fgUntitled.equals(drawingTitle)) {
d945 1
a945 1
	
d950 1
a950 1
		return fDrawingFilename;
d965 31
@


1.4
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)DrawApplication.java 5.2
d4 6
d25 2
a26 3
 * DrawApplication defines a standard presentation for
 * standalone drawing editors. The presentation is
 * customized in subclasses.
d34 2
d37 38
a75 3
public  class DrawApplication
        extends JFrame
        implements DrawingEditor, PaletteListener {
d77 21
a97 57
    private Drawing              fDrawing;
    private Tool                 fTool;
    private Iconkit              fIconkit;

    private JTextField           fStatusLine;
    private StandardDrawingView  fView;
    private ToolButton           fDefaultToolButton;
    private ToolButton           fSelectedToolButton;

    private String               fApplicationName;
    private String               fDrawingFilename;
    private StorageFormatManager fStorageFormatManager;
    static String                fgUntitled = "untitled";

    // the image resource path
    private static final String fgDrawPath = "/CH/ifa/draw/";
    public static final String IMAGES = fgDrawPath + "images/";

    /**
     * The index of the file menu in the menu bar.
     */
    public static final int    FILE_MENU = 0;
    /**
     * The index of the edit menu in the menu bar.
     */
    public static final int    EDIT_MENU = 1;
    /**
     * The index of the alignment menu in the menu bar.
     */
    public static final int    ALIGNMENT_MENU = 2;
    /**
     * The index of the attributes menu in the menu bar.
     */
    public static final int    ATTRIBUTES_MENU = 3;


    /**
     * Constructs a drawing window with a default title.
     */
    public DrawApplication() {
        super("JHotDraw");
    }

    /**
     * Constructs a drawing window with the given title.
     */
    public DrawApplication(String title) {
        super(title);
        setApplicationName(title);
    }

    /**
     * Factory method which can be overriden by subclasses to
     * create an instance of their type.
     *
     * @@return	newly created application
     */
d102 5
a106 5
    /**
     * Open a new view for this application containing a
     * view of the drawing of the currently activated window.
     */
    public void newView() {
d111 1
a111 1
    }
d113 5
a117 5
    /**
     * Open a new window for this application containing
     * an new (empty) drawing.
     */
    public void newWindow() {
d120 8
a127 8
    }
    
    /**
     * Opens the window and initializes its contents.
     * Clients usually only call but don't override it.
     */
    public void open() {
        fIconkit = new Iconkit(this);
d129 18
a146 22
		// Panel in which a JToolBar can be placed using a BoxLayout
        JPanel fullPanel = new JPanel();
        fullPanel.setLayout(new BoxLayout(fullPanel, BoxLayout.X_AXIS));
        fView = createDrawingView();
        JComponent contents = createContents((StandardDrawingView)view());
        contents.setAlignmentX(LEFT_ALIGNMENT);

        JToolBar tools = createToolPalette();
        createTools(tools);

        JPanel activePanel = new JPanel();
        activePanel.setAlignmentX(LEFT_ALIGNMENT);
	    activePanel.setAlignmentY(TOP_ALIGNMENT);
        activePanel.setLayout(new BorderLayout());
        activePanel.add(tools, BorderLayout.NORTH);
        activePanel.add(contents, BorderLayout.CENTER);

        fullPanel.add(activePanel);

        fStatusLine = createStatusLine();
        getContentPane().add(fullPanel, BorderLayout.CENTER);
        getContentPane().add(fStatusLine, BorderLayout.SOUTH);
d152 5
a156 5
        initDrawing();
        
        Dimension d = defaultSize();
        if (d.width > mb.getPreferredSize().width) {
    		setSize(d.width, d.height);
d159 1
a159 1
            setSize(mb.getPreferredSize().width, d.height);
d161 8
a168 8
        addListeners();
        setVisible(true);
        fStorageFormatManager = createStorageFormatManager();
    }

    /**
     * Registers the listeners for this window
     */
d170 39
a208 33
	    addWindowListener(
            new WindowAdapter() {
                public void windowClosing(WindowEvent event) {
                    exit();
                }
            }
        );
    }

    protected void initDrawing() {
        setDrawing(createDrawing());
        setDrawingTitle(fgUntitled);
        view().setDrawing(drawing());
        toolDone();
    }

    /**
     * Creates the standard menus. Clients override this
     * method to add additional menus.
     */
    protected void createMenus(JMenuBar mb) {
		mb.add(createFileMenu());
		mb.add(createEditMenu());
		mb.add(createAlignmentMenu());
		mb.add(createAttributesMenu());
		mb.add(createDebugMenu());
    }

    /**
     * Creates the file menu. Clients override this
     * method to add additional menu items.
     */
    protected JMenu createFileMenu() {
d212 5
a216 5
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            promptNew();
		        }
		    }
d222 5
a226 5
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            promptOpen();
		        }
		    }
d232 5
a236 5
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            promptSaveAs();
		        }
		    }
d243 5
a247 5
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            print();
		        }
		    }
d253 5
a257 5
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            exit();
		        }
		    }
d263 5
a267 5
    /**
     * Creates the edit menu. Clients override this
     * method to add additional menu items.
     */
    protected JMenu createEditMenu() {
d269 5
a273 1
		menu.add(new CutCommand("Cut", view()), new MenuShortcut('x'));
d275 6
a280 1
		menu.add(new PasteCommand("Paste", view()), new MenuShortcut('v'));
d282 2
a283 2
		menu.add(new DuplicateCommand("Duplicate", view()), new MenuShortcut('d'));
		menu.add(new DeleteCommand("Delete", view()));
d285 2
a286 2
		menu.add(new GroupCommand("Group", view()));
		menu.add(new UngroupCommand("Ungroup", view()));
d288 2
a289 2
		menu.add(new SendToBackCommand("Send to Back", view()));
		menu.add(new BringToFrontCommand("Bring to Front", view()));
d293 5
a297 5
    /**
     * Creates the alignment menu. Clients override this
     * method to add additional menu items.
     */
    protected JMenu createAlignmentMenu() {
d299 1
a299 1
		menu.add(new ToggleGridCommand("Toggle Snap to Grid", view(), new Point(4,4)));
d301 6
a306 3
		menu.add(new AlignCommand("Lefts", view(), AlignCommand.LEFTS));
		menu.add(new AlignCommand("Centers", view(), AlignCommand.CENTERS));
		menu.add(new AlignCommand("Rights", view(), AlignCommand.RIGHTS));
d308 6
a313 3
		menu.add(new AlignCommand("Tops", view(), AlignCommand.TOPS));
		menu.add(new AlignCommand("Middles", view(), AlignCommand.MIDDLES));
		menu.add(new AlignCommand("Bottoms", view(), AlignCommand.BOTTOMS));
d317 5
a321 5
    /**
     * Creates the debug menu. Clients override this
     * method to add additional menu items.
     */
    protected JMenu createDebugMenu() {
d326 5
a330 5
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            view().setDisplayUpdate(new SimpleUpdateStrategy());
		        }
		    }
d336 5
a340 5
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            view().setDisplayUpdate(new BufferedUpdateStrategy());
		        }
		    }
d346 9
a354 9
    /**
     * Creates the attributes menu and its submenus. Clients override this
     * method to add additional menu items.
     */
    protected JMenu createAttributesMenu() {
        JMenu menu = new JMenu("Attributes");
        menu.add(createColorMenu("Fill Color", "FillColor"));
        menu.add(createColorMenu("Pen Color", "FrameColor"));
        menu.add(createArrowMenu());
d356 87
a442 75
        menu.add(createFontMenu());
        menu.add(createFontSizeMenu());
        menu.add(createFontStyleMenu());
        menu.add(createColorMenu("Text Color", "TextColor"));
        return menu;
    }

    /**
     * Creates the color menu.
     */
    protected JMenu createColorMenu(String title, String attribute) {
        CommandMenu menu = new CommandMenu(title);
        for (int i=0; i<ColorMap.size(); i++)
            menu.add(
                new ChangeAttributeCommand(
                    ColorMap.name(i),
                    attribute,
                    ColorMap.color(i),
                    view()
                )
            );
        return menu;
    }

    /**
     * Creates the arrows menu.
     */
    protected JMenu createArrowMenu() {
        CommandMenu menu = new CommandMenu("Arrow");
        menu.add(new ChangeAttributeCommand("none",     "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE),  view()));
        menu.add(new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), view()));
        menu.add(new ChangeAttributeCommand("at End",   "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END),   view()));
        menu.add(new ChangeAttributeCommand("at Both",  "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH),  view()));
        return menu;
    }

    /**
     * Creates the fonts menus. It installs all available fonts
     * supported by the toolkit implementation.
     */
    protected JMenu createFontMenu() {
        CommandMenu menu = new CommandMenu("Font");
        String fonts[] = Toolkit.getDefaultToolkit().getFontList();
        for (int i = 0; i < fonts.length; i++)
            menu.add(new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  view()));
        return menu;
    }

    /**
     * Creates the font style menu with entries (Plain, Italic, Bold).
     */
    protected JMenu createFontStyleMenu() {
        CommandMenu menu = new CommandMenu("Font Style");
        menu.add(new ChangeAttributeCommand("Plain", "FontStyle", new Integer(Font.PLAIN), view()));
        menu.add(new ChangeAttributeCommand("Italic","FontStyle", new Integer(Font.ITALIC),view()));
        menu.add(new ChangeAttributeCommand("Bold",  "FontStyle", new Integer(Font.BOLD),  view()));
        return menu;
    }

    /**
     * Creates the font size menu.
     */
    protected JMenu createFontSizeMenu() {
        CommandMenu menu = new CommandMenu("Font Size");
        int sizes[] = { 9, 10, 12, 14, 18, 24, 36, 48, 72 };
        for (int i = 0; i < sizes.length; i++) {
            menu.add(
                new ChangeAttributeCommand(
                    Integer.toString(sizes[i]),
                    "FontSize",
                    new Integer(sizes[i]),  view())
                );
        }
        return menu;
    }
d447 2
a448 2
    public JMenu createLookAndFeelMenu() {
        JMenu menu = new JMenu("Look'n'Feel");
d450 2
a451 2
        UIManager.LookAndFeelInfo[] lafs = UIManager.getInstalledLookAndFeels();
        JMenuItem mi = null;
d454 105
a558 105
            mi = new JMenuItem(lafs[i].getName());
            final String lnfClassName = lafs[i].getClassName(); 
            mi.addActionListener(
                new ActionListener() {
	                public void actionPerformed(ActionEvent event) {
                        newLookAndFeel(lnfClassName);
		            }
		        }
		    );
		    menu.add(mi);
		}
        return menu;
    }

    /**
     * Creates the tool palette.
     */
    protected JToolBar createToolPalette() {
        JToolBar palette = new JToolBar();
        palette.setBackground(Color.lightGray);
        // use standard FlowLayout for JToolBar
        // palette.setLayout(new PaletteLayout(2,new Point(2,2)));
        return palette;
    }

    /**
     * Creates the tools. By default only the selection tool is added.
     * Override this method to add additional tools.
     * Call the inherited method to include the selection tool.
     * @@param palette the palette where the tools are added.
     */
    protected void createTools(JToolBar palette) {
        Tool tool = createSelectionTool();
        fDefaultToolButton = createToolButton(IMAGES+"SEL", "Selection Tool", tool);
        palette.add(fDefaultToolButton);
    }

    /**
     * Creates the selection tool used in this editor. Override to use
     * a custom selection tool.
     */
    protected Tool createSelectionTool() {
        return new SelectionTool(view());
    }

    /**
     * Creates a tool button with the given image, tool, and text
     */
    protected ToolButton createToolButton(String iconName, String toolName, Tool tool) {
        return new ToolButton(this, iconName, toolName, tool);
    }

    /**
     * Creates the drawing view used in this application.
     * You need to override this method to use a DrawingView
     * subclass in your application. By default a standard
     * DrawingView is returned.
     */
    protected StandardDrawingView createDrawingView() {
        Dimension d = getDrawingViewSize();
        return new StandardDrawingView(this, d.width, d.height);
    }

    /**
     * Override to define the dimensions of the drawing view.
     */
    protected Dimension getDrawingViewSize() {
        return new Dimension(800, 800);
    }

    /**
     * Creates the drawing used in this application.
     * You need to override this method to use a Drawing
     * subclass in your application. By default a standard
     * Drawing is returned.
     */
    protected Drawing createDrawing() {
        return new StandardDrawing();
    }

    /**
     * Creates the contents component of the application
     * frame. By default the DrawingView is returned in
     * a JScrollPane.
     */
    protected JComponent createContents(StandardDrawingView view) {
        JScrollPane sp = new JScrollPane(view);
        sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        sp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);

        return sp;
    }

    /**
     * Factory method to create a StorageFormatManager for supported storage formats.
     * Different applications might want to use different storage formats and can return
     * their own format manager by overriding this method.
     */
    public StorageFormatManager createStorageFormatManager() {
        StorageFormatManager storageFormatManager = new StorageFormatManager();
        storageFormatManager.setDefaultStorageFormat(new StandardStorageFormat());
        storageFormatManager.addStorageFormat(storageFormatManager.getDefaultStorageFormat());
        storageFormatManager.addStorageFormat(new SerializationStorageFormat());
        return storageFormatManager;
    }
d564 3
a566 3
    private void setStorageFormatManager(StorageFormatManager storageFormatManager) {
        fStorageFormatManager = storageFormatManager;
    }
d572 153
a724 132
    public StorageFormatManager getStorageFormatManager() {
        return fStorageFormatManager;
    }
    
    /**
     * Sets the drawing to be edited.
     */
    public void setDrawing(Drawing drawing) {
        view().setDrawing(drawing);
        fDrawing = drawing;
    }

    /**
     * Gets the default size of the window.
     */
    protected Dimension defaultSize() {
        return new Dimension(600,450);
    }

    /**
     * Creates the status line.
     */
    protected JTextField createStatusLine() {
        JTextField field = new JTextField("No Tool", 40);
        field.setBackground(Color.white);
        field.setEditable(false);
        return field;
    }

    /**
     * Handles a user selection in the palette.
     * @@see PaletteListener
     */
    public void paletteUserSelected(PaletteButton button) {
        ToolButton toolButton = (ToolButton) button;
        setTool(toolButton.tool(), toolButton.name());
        setSelected(toolButton);
    }

    /**
     * Handles when the mouse enters or leaves a palette button.
     * @@see PaletteListener
     */
    public void paletteUserOver(PaletteButton button, boolean inside) {
        ToolButton toolButton = (ToolButton) button;
        if (inside)
            showStatus(toolButton.name());
        else
            showStatus(fSelectedToolButton.name());
    }

    /**
     * Gets the current drawing.
     * @@see DrawingEditor
     */
    public Drawing drawing() {
        return fDrawing;
    }

    /**
     * Gets the current tool.
     * @@see DrawingEditor
     */
    public Tool tool() {
        return fTool;
    }

    /**
     * Gets the current drawing view.
     * @@see DrawingEditor
     */
    public DrawingView view() {
        return fView;
    }

    /**
     * Sets the default tool of the editor.
     * @@see DrawingEditor
     */
    public void toolDone() {
        if (fDefaultToolButton != null) {
            setTool(fDefaultToolButton.tool(), fDefaultToolButton.name());
            setSelected(fDefaultToolButton);
        }
    }

    /**
     * Handles a change of the current selection. Updates all
     * menu items that are selection sensitive.
     * @@see DrawingEditor
     */
    public void selectionChanged(DrawingView view) {
        JMenuBar mb = getJMenuBar();
        CommandMenu editMenu = (CommandMenu)mb.getMenu(EDIT_MENU);
        editMenu.checkEnabled();
        CommandMenu alignmentMenu = (CommandMenu)mb.getMenu(ALIGNMENT_MENU);
        alignmentMenu.checkEnabled();
    }

    /**
     * Shows a status message.
     * @@see DrawingEditor
     */
    public void showStatus(String string) {
        fStatusLine.setText(string);
    }

    private void setTool(Tool t, String name) {
        if (tool() != null)
            tool().deactivate();
        fTool = t;
        if (tool() != null) {
            fStatusLine.setText(name);
            tool().activate();
        }
    }

    private void setSelected(ToolButton button) {
        if (fSelectedToolButton != null)
            fSelectedToolButton.reset();
        fSelectedToolButton = button;
        if (fSelectedToolButton != null)
            fSelectedToolButton.select();
    }

    /**
     * Exits the application. You should never override this method
     */
    public void exit() {
        destroy();
        setVisible(false);      // hide the JFrame
        dispose();   // tell windowing system to free resources
d726 8
a733 1
    }
d735 50
a784 56
    /**
     * Handles additional clean up operations. Override to destroy
     * or release drawing editor resources.
     */
    protected void destroy() {
    }

    /**
     * Resets the drawing to a new empty drawing.
     */
    public void promptNew() {
        initDrawing();
    }

    /**
     * Shows a file dialog and opens a drawing.
     */
    public void promptOpen() {
    	toolDone();
        JFileChooser openDialog = createOpenFileChooser();
        getStorageFormatManager().registerFileFilters(openDialog);
        if (openDialog.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            StorageFormat foundFormat = getStorageFormatManager().findStorageFormat(openDialog.getFileFilter());
            if (foundFormat != null) {
                loadDrawing(foundFormat, openDialog.getSelectedFile().getAbsolutePath());
            }
            else {
                showStatus("Not a valid file format: " + openDialog.getFileFilter().getDescription());
            }
        }
    }

    /**
     * Shows a file dialog and saves drawing.
     */
    public void promptSaveAs() {
        toolDone();
        JFileChooser saveDialog = createSaveFileChooser();
        getStorageFormatManager().registerFileFilters(saveDialog);

        if (saveDialog.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            StorageFormat foundFormat = getStorageFormatManager().findStorageFormat(saveDialog.getFileFilter());
            if (foundFormat != null) {
                saveDrawing(foundFormat, saveDialog.getSelectedFile().getAbsolutePath());
            }
            else {
                showStatus("Not a valid file format: " + saveDialog.getFileFilter().getDescription());
            }
        }
    }

    /**
     * Create a file chooser for the open file dialog. Subclasses may override this
     * method in order to customize the open file dialog.
     */
    protected JFileChooser createOpenFileChooser() {
d788 1
a788 1
    }
d790 9
a798 9
    /**
     * Create a file chooser for the save file dialog. Subclasses may override this
     * method in order to customize the save file dialog.
     */	
    protected JFileChooser createSaveFileChooser() {
        JFileChooser saveDialog = new JFileChooser();
        saveDialog.setDialogTitle("Save File...");
        return saveDialog;
    }
d800 49
a848 49
    /**
     * Prints the drawing.
     */
    public void print() {
        tool().deactivate();
        PrintJob printJob = getToolkit().getPrintJob(this, "Print Drawing", null);

        if (printJob != null) {
            Graphics pg = printJob.getGraphics();

            if (pg != null) {
                ((StandardDrawingView)view()).printAll(pg);
                pg.dispose(); // flush page
            }
            printJob.end();
        }
        tool().activate();
    }

    /**
     * Save a Drawing in a file
     */
    protected void saveDrawing(StorageFormat storeFormat, String file) {
        try {
        	setDrawingTitle(storeFormat.store(file, drawing()));
        }
        catch (IOException e) {
            showStatus(e.toString());
        }
    }

    /**
     * Load a Drawing from a file 
     */
    protected void loadDrawing(StorageFormat restoreFormat, String file) {
        try {
            Drawing restoredDrawing = restoreFormat.restore(file);
            if (restoredDrawing != null) {
                newWindow();
                setDrawing(restoredDrawing);
                setDrawingTitle(file);
            }
            else {
               showStatus("Unknown file type: could not open file '" + file + "'");
            }
        } catch (IOException e) {
            showStatus("Error: " + e);
        }
    }
d853 29
a881 29
    private void newLookAndFeel(String landf) {
        try {
            UIManager.setLookAndFeel(landf);
            SwingUtilities.updateComponentTreeUI(this);
        }
        catch (Exception e) {
            System.err.println(e);
        }
    }

    /**
     * Set the title of the currently selected drawing
     */
    protected void setDrawingTitle(String drawingTitle) {
	    fDrawingFilename = drawingTitle;
	    if (fgUntitled.equals(drawingTitle)) {
	    	setTitle(getApplicationName());
	    }
	    else {
	    	setTitle(getApplicationName() + " - " + drawingTitle);
	    }
    }
    
    /**
     * Return the title of the currently selected drawing
     */
    protected String getDrawingTitle() {
    	return fDrawingFilename;
    }
@


1.3
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d40 1
a40 1
    private DrawingView  fView;
d75 1
a75 1
        this("JHotDraw");
d123 3
a132 1

d140 2
d143 1
a143 1
        getContentPane().add(activePanel, BorderLayout.CENTER);
d477 1
a477 1
    protected DrawingView createDrawingView() {
d504 2
a505 2
    protected JComponent createContents(DrawingView view) {
        JScrollPane sp = new JScrollPane((StandardDrawingView)view);
d582 1
a582 1
        if (inside) {
d584 1
a584 2
        }
        else {
a585 1
        }
d628 1
a628 1
    public void figureSelectionChanged(DrawingView view) {
d649 1
a649 1
            showStatus(name);
d655 1
a655 1
        if (fSelectedToolButton != null) {
a656 1
        }
d658 1
a658 1
        if (fSelectedToolButton != null) {
a659 1
        }
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d40 1
a40 1
    private StandardDrawingView  fView;
d75 1
a75 1
        super("JHotDraw");
a122 3
		// Panel in which a JToolBar can be placed using a BoxLayout
        JPanel fullPanel = new JPanel();
        fullPanel.setLayout(new BoxLayout(fullPanel, BoxLayout.X_AXIS));
d130 1
a137 2
        fullPanel.add(activePanel);

d139 1
a139 1
        getContentPane().add(fullPanel, BorderLayout.CENTER);
d473 1
a473 1
    protected StandardDrawingView createDrawingView() {
d500 2
a501 2
    protected JComponent createContents(StandardDrawingView view) {
        JScrollPane sp = new JScrollPane(view);
d578 1
a578 1
        if (inside)
d580 2
a581 1
        else
d583 1
d626 1
a626 1
    public void selectionChanged(DrawingView view) {
d647 1
a647 1
            fStatusLine.setText(name);
d653 1
a653 1
        if (fSelectedToolButton != null)
d655 1
d657 1
a657 1
        if (fSelectedToolButton != null)
d659 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)DrawApplication.java 5.1
d8 1
d32 1
a32 1
        extends Frame
d35 13
a47 11
    private Drawing             fDrawing;
    private Tool                fTool;
    private Iconkit             fIconkit;

    private TextField           fStatusLine;
    private StandardDrawingView fView;
    private ToolButton          fDefaultToolButton;
    private ToolButton          fSelectedToolButton;

    private String              fDrawingFilename;
    static String               fgUntitled = "untitled";
d51 1
a51 1
    public static final String IMAGES = fgDrawPath+"images/";
d83 22
d108 9
a119 1

d122 4
a125 2
		setLayout(new BorderLayout());

d127 2
a128 3
        Component contents = createContents(fView);
        add("Center", contents);
        //add("Center", fView);
d130 1
a130 1
        Panel tools = createToolPalette();
d132 9
a140 1
        add("West", tools);
d143 2
a144 1
        add("South", fStatusLine);
d146 1
a146 1
		MenuBar mb = new MenuBar();
d148 2
a149 2
		setMenuBar(mb);

d151 1
d153 6
a158 2
		setSize(d.width, d.height);

d160 2
a161 2

        show();
d177 4
a180 4
    private void initDrawing() {
        fDrawing = createDrawing();
        fDrawingFilename = fgUntitled;
        fView.setDrawing(fDrawing);
d188 1
a188 1
    protected void createMenus(MenuBar mb) {
d200 3
a202 3
    protected Menu createFileMenu() {
		Menu menu = new Menu("File");
		MenuItem mi = new MenuItem("New", new MenuShortcut('n'));
d212 1
a212 1
		mi = new MenuItem("Open...", new MenuShortcut('o'));
d222 1
a222 1
		mi = new MenuItem("Save As...", new MenuShortcut('s'));
a231 9
		mi = new MenuItem("Save As Serialized...");
		mi.addActionListener(
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            promptSaveAsSerialized();
		        }
		    }
		);
		menu.add(mi);
d233 1
a233 1
		mi = new MenuItem("Print...", new MenuShortcut('p'));
d243 1
a243 1
		mi = new MenuItem("Exit");
d259 1
a259 1
    protected Menu createEditMenu() {
d261 3
a263 3
		menu.add(new CutCommand("Cut", fView), new MenuShortcut('x'));
		menu.add(new CopyCommand("Copy", fView), new MenuShortcut('c'));
		menu.add(new PasteCommand("Paste", fView), new MenuShortcut('v'));
d265 2
a266 2
		menu.add(new DuplicateCommand("Duplicate", fView), new MenuShortcut('d'));
		menu.add(new DeleteCommand("Delete", fView));
d268 2
a269 2
		menu.add(new GroupCommand("Group", fView));
		menu.add(new UngroupCommand("Ungroup", fView));
d271 2
a272 2
		menu.add(new SendToBackCommand("Send to Back", fView));
		menu.add(new BringToFrontCommand("Bring to Front", fView));
d280 1
a280 1
    protected Menu createAlignmentMenu() {
d282 1
a282 1
		menu.add(new ToggleGridCommand("Toggle Snap to Grid", fView, new Point(4,4)));
d284 3
a286 3
		menu.add(new AlignCommand("Lefts", fView, AlignCommand.LEFTS));
		menu.add(new AlignCommand("Centers", fView, AlignCommand.CENTERS));
		menu.add(new AlignCommand("Rights", fView, AlignCommand.RIGHTS));
d288 3
a290 3
		menu.add(new AlignCommand("Tops", fView, AlignCommand.TOPS));
		menu.add(new AlignCommand("Middles", fView, AlignCommand.MIDDLES));
		menu.add(new AlignCommand("Bottoms", fView, AlignCommand.BOTTOMS));
d298 2
a299 2
    protected Menu createDebugMenu() {
		Menu menu = new Menu("Debug");
d301 1
a301 1
		MenuItem mi = new MenuItem("Simple Update");
d305 1
a305 1
		            fView.setDisplayUpdate(new SimpleUpdateStrategy());
d311 1
a311 1
		mi = new MenuItem("Buffered Update");
d315 1
a315 1
		            fView.setDisplayUpdate(new BufferedUpdateStrategy());
d327 2
a328 2
    protected Menu createAttributesMenu() {
        Menu menu = new Menu("Attributes");
d343 1
a343 1
    protected Menu createColorMenu(String title, String attribute) {
d351 1
a351 1
                    fView
d360 1
a360 1
    protected Menu createArrowMenu() {
d362 4
a365 4
        menu.add(new ChangeAttributeCommand("none",     "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_NONE),  fView));
        menu.add(new ChangeAttributeCommand("at Start", "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_START), fView));
        menu.add(new ChangeAttributeCommand("at End",   "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_END),   fView));
        menu.add(new ChangeAttributeCommand("at Both",  "ArrowMode", new Integer(PolyLineFigure.ARROW_TIP_BOTH),  fView));
d373 1
a373 1
    protected Menu createFontMenu() {
d377 1
a377 1
            menu.add(new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],  fView));
d384 1
a384 1
    protected Menu createFontStyleMenu() {
d386 3
a388 3
        menu.add(new ChangeAttributeCommand("Plain", "FontStyle", new Integer(Font.PLAIN), fView));
        menu.add(new ChangeAttributeCommand("Italic","FontStyle", new Integer(Font.ITALIC),fView));
        menu.add(new ChangeAttributeCommand("Bold",  "FontStyle", new Integer(Font.BOLD),  fView));
d395 1
a395 1
    protected Menu createFontSizeMenu() {
d403 1
a403 1
                    new Integer(sizes[i]),  fView)
d409 24
d436 2
a437 2
    protected Panel createToolPalette() {
        Panel palette = new Panel();
d439 2
a440 1
        palette.setLayout(new PaletteLayout(2,new Point(2,2)));
d450 1
a450 1
    protected void createTools(Panel palette) {
a451 1

d486 1
a486 1
        return new Dimension(400, 600);
d502 1
a502 1
     * a ScrollPane.
d504 4
a507 6
    protected Component createContents(StandardDrawingView view) {
        ScrollPane sp = new ScrollPane();
        Adjustable vadjust = sp.getVAdjustable();
        Adjustable hadjust = sp.getHAdjustable();
        hadjust.setUnitIncrement(16);
        vadjust.setUnitIncrement(16);
a508 1
        sp.add(view);
d513 29
d545 1
a545 1
        fView.setDrawing(drawing);
d553 1
a553 1
        return new Dimension(430,406);
d559 3
a561 2
    protected TextField createStatusLine() {
        TextField field = new TextField("No Tool", 40);
d629 1
a629 1
        MenuBar mb = getMenuBar();
d645 2
a646 2
        if (fTool != null)
            fTool.deactivate();
d648 1
a648 1
        if (fTool != null) {
d650 1
a650 1
            fTool.activate();
d667 1
a667 1
        setVisible(false);      // hide the Frame
d690 11
a700 7
        FileDialog dialog = new FileDialog(this, "Open File...", FileDialog.LOAD);
        dialog.show();
        String filename = dialog.getFile();
        if (filename != null) {
            filename = stripTrailingAsterisks(filename);
            String dirname = dialog.getDirectory();
            loadDrawing(dirname + filename);
a701 1
        dialog.dispose();
d709 11
a719 5
        String path = getSavePath("Save File...");
        if (path != null) {
            if (!path.endsWith(".draw"))
                path += ".draw";
            saveAsStorableOutput(path);
d724 2
a725 1
     * Shows a file dialog and saves drawing.
d727 4
a730 8
    public void promptSaveAsSerialized() {
        toolDone();
        String path = getSavePath("Save File...");
        if (path != null) {
            if (!path.endsWith(".ser"))
                path += ".ser";
            saveAsObjectOutput(path);
        }
d734 10
d747 1
a747 1
        fTool.deactivate();
d754 1
a754 1
                fView.printAll(pg);
d759 1
a759 1
        fTool.activate();
d762 4
a765 24
    private String getSavePath(String title) {
        String path = null;
        FileDialog dialog = new FileDialog(this, title, FileDialog.SAVE);
        dialog.show();
        String filename = dialog.getFile();
        if (filename != null) {
            filename = stripTrailingAsterisks(filename);
            String dirname = dialog.getDirectory();
            path = dirname + filename;
        }
        dialog.dispose();
        return path;
    }

    private String stripTrailingAsterisks(String filename) {
        // workaround for bug on NT
        if (filename.endsWith("*.*"))
            return filename.substring(0, filename.length() - 4);
        else
            return filename;
    }

    private void saveAsStorableOutput(String file) {
        // TBD: should write a MIME header
d767 1
a767 6
            FileOutputStream stream = new FileOutputStream(file);
            StorableOutput output = new StorableOutput(stream);
            output.writeStorable(fDrawing);
            output.close();
        } catch (IOException e) {
            showStatus(e.toString());
d769 1
a769 10
    }

    private void saveAsObjectOutput(String file) {
        // TBD: should write a MIME header
        try {
            FileOutputStream stream = new FileOutputStream(file);
            ObjectOutput output = new ObjectOutputStream(stream);
            output.writeObject(fDrawing);
            output.close();
        } catch (IOException e) {
d774 4
a777 12
    private void loadDrawing(String file) {
        toolDone();
        String type = guessType(file);
        if (type.equals("storable"))
            readFromStorableInput(file);
        else if (type.equals("serialized"))
            readFromObjectInput(file);
        else
            showStatus("Unknown file type");
    }

    private void readFromStorableInput(String file) {
d779 9
a787 5
            FileInputStream stream = new FileInputStream(file);
            StorableInput input = new StorableInput(stream);
            fDrawing.release();
            fDrawing = (Drawing)input.readStorable();
            fView.setDrawing(fDrawing);
a788 1
            initDrawing();
d793 4
a796 1
    private void readFromObjectInput(String file) {
d798 5
a802 11
            FileInputStream stream = new FileInputStream(file);
            ObjectInput input = new ObjectInputStream(stream);
            fDrawing.release();
            fDrawing = (Drawing)input.readObject();
            fView.setDrawing(fDrawing);
        } catch (IOException e) {
            initDrawing();
            showStatus("Error: " + e);
        } catch (ClassNotFoundException e) {
            initDrawing();
            showStatus("Class not found: " + e);
d806 18
a823 6
    private String guessType(String file) {
        if (file.endsWith(".draw"))
            return "storable";
        if (file.endsWith(".ser"))
            return "serialized";
        return "unknown";
d825 14
@


1.1.1.1
log
@
Initial revision.
@
text
@@
