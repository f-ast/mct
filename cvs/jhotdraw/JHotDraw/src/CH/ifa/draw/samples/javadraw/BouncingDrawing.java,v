head	1.6;
access;
symbols
	jhotdraw54b2-release:1.6
	reorg_6x_split:1.6
	MVC_PHASE1:1.6.0.10
	NEW_ATTRIBUTES:1.6.0.8
	DNOYEB1_ALPHA-2:1.6.4.6
	release_JHD54b1:1.6
	BUGFIX_670992:1.6.0.6
	DNOYEB1_ALPHA-1:1.6.4.5
	dnoyeb1:1.6.0.4
	repack:1.6.0.2
	Root_repack:1.6
	Before_FigureVisitor:1.6
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2002.09.07.12.27.25;	author mrfloppy;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.08.04.22.51.22;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches;
next	;

1.6.4.1
date	2003.01.14.18.24.20;	author dnoyeb;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.01.15.21.04.21;	author dnoyeb;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.01.18.04.49.04;	author dnoyeb;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.01.20.18.23.30;	author dnoyeb;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.01.21.00.04.34;	author dnoyeb;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2003.01.26.00.51.05;	author dnoyeb;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2003.02.02.16.54.09;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.6
log
@removed remains of FigureAttributeConstant.getName() and some code-clean up
@
text
@/*
 * @@(#)BouncingDrawing.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.samples.javadraw;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.Animatable;

/**
 * @@version <$CURRENT_VERSION$>
 */
public class BouncingDrawing extends StandardDrawing implements Animatable {
	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = -8566272817418441758L;
	private int bouncingDrawingSerializedDataVersion = 1;

	public synchronized Figure add(Figure figure) {
		if (!(figure instanceof AnimationDecorator) &&
			!(figure instanceof ConnectionFigure)) {
			figure = new AnimationDecorator(figure);
		}
		return super.add(figure);
	}

	public synchronized Figure remove(Figure figure) {
		Figure f = super.remove(figure);
		if (f instanceof AnimationDecorator) {
			return ((AnimationDecorator) f).peelDecoration();
		}
		return f;
	}

	/**
	 * @@param figure figure to be replaced
	 * @@param replacement figure that should replace the specified figure
	 * @@return the figure that has been inserted (might be different from the figure specified)
	 */
	public synchronized Figure replace(Figure figure, Figure replacement) {
		if (!(replacement instanceof AnimationDecorator) &&
			!(replacement instanceof ConnectionFigure)) {
			replacement = new AnimationDecorator(replacement);
		}
		return super.replace(figure, replacement);
	}

	public void animationStep() {
		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			Figure f = fe.nextFigure();
			
			if(!(f instanceof ConnectionFigure)) {
				((AnimationDecorator) f).animationStep();
			}
		}
	}
}
@


1.6.4.1
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@a16 3
import java.util.*;
import CH.ifa.draw.util.*;
import java.awt.Graphics;
d27 2
a28 11
	private HashMap decFigs = new HashMap();
	
	public void draw(Graphics g) {
		draw(g, getAnimatableFigures() );
	}
	public FigureEnumeration getAnimatableFigures() {
		return new FigureEnumerator(CollectionsFactory.current().createList(decFigs.values()));
	}
	
	public synchronized void add(Figure figure) {
		Figure decorFigure;
d31 1
a31 2
			decorFigure = new AnimationDecorator(figure);
			decFigs.put(figure, decorFigure);
d33 1
a33 4
		else {
			decFigs.put(figure, figure);
		}
		super.add(figure);			
d36 4
a39 11
//	public synchronized void remove(Figure figure) {
//		Figure f = super.remove(figure);
//		if (f instanceof AnimationDecorator) {
//			return ((AnimationDecorator) f).peelDecoration();
//		}
//		return f;
//	}
	protected void figureRequestRemove(FigureChangeEvent e) {
		Figure f = e.getFigure();
		if(decFigs.containsKey( f )) {
			decFigs.remove(f);
d41 1
a41 1
		super.figureRequestRemove(e);
d43 1
d58 1
a58 2
		//FigureEnumeration fe = figures();
		FigureEnumeration fe = getAnimatableFigures();
d63 1
a63 1
				((AnimationDecorator) f).animationStep(); // seems like a rather assuming cast !!!dnoyeb!!!
@


1.6.4.2
log
@
Lets have a moment of silence for DecoratorFigure.....It was a good figure ;{

Anything which happens inside the drawing after figure add must be undone before figure orphan.  It must also not
be exposed to anyobject outside the drawing.
Decorator figure retired in favor of a figureManipulator and the other functions being implemented by a composite
figure(BorderDecorator).
AdnimationDecorator retired in favor of AnimationManipulator.
A figure can have only 1 container. This is making the border tool have a hard time.

Lots of comments added

next phase:
orphan will disappear.  only add and remove remain.  All figure related resources belong to the figures and no other
object should care about figure.release.
split the figureListener into a figureContainer listener and a figureChangeListener.
Fix BorderDecorator.
Fix ConnectedText.
view.checkDamage to call drawing.update()
@
text
@d30 8
a37 2
	private HashMap animManips = new HashMap();
	private HashMap orphanedAnimManips = new HashMap();
a38 6
	/**
	 * NOTE: Everything added to a figure within the drawing must never be exposed
	 * outside of the drawing.  During remove this adornments must be stripped
	 * away!  Their states are not preservable.  For preservation you must add
	 * your modifications before the Figure is added to the drawing.
	 */
d40 2
a41 3
		super.add(figure);

		if (/*!(figure instanceof AnimationDecorator) && */  //if figurestrategy does not include AnimationStrategy?
d43 2
a44 3
			FigureManipulator fm = new AnimationManipulator();
			figure.addFigureManipulator( fm );
			animManips.put(figure, fm );
d46 4
d52 7
d61 2
a62 2
		if(animManips.containsKey( f )) {
			AnimationManipulator am = (AnimationManipulator)animManips.remove( f );
a65 1

d80 8
a87 3
		for(Iterator it= animManips.values().iterator();it.hasNext();){
			Animatable am = (Animatable)it.next();
			am.animationStep();
@


1.6.4.3
log
@Decorator Figure returns...To apease the brave hearted :-)
Its not very well integrated with the current state of affairs.  It works as well as it always
has though.
@
text
@d20 1
a20 2
import CH.ifa.draw.figures.TextFigure;
import java.io.IOException;
a21 3
 * @@todo Needs validation and testing.  The DecoratorFigure AnimationDecorator
 *       causes some problems with knowing what is and is not in the drawing.
 *
a22 1
 * 
d30 2
a31 3
//	private HashMap animManips;
//	private HashMap orphanedAnimManips;
	private HashMap decorations;
a32 5
	BouncingDrawing(){
		decorations = new HashMap();
//		animManips = new HashMap();
//		orphanedAnimManips = new HashMap();
	}
d40 3
a42 1
		if (!(figure instanceof AnimationDecorator) &&
d44 3
a46 3
			Figure ad = new AnimationDecorator(figure);
			decorations.put( figure,  ad);
			super.add(ad);
a47 13
		else {
			super.add(figure);
		}
		
//		super.add(figure);
//		if (
//			!(figure instanceof ConnectionFigure) &&
//			!(figure instanceof TextFigure) //Hack to keep Connected test from flying all over (stops unconnected text too though...)
//			) {
//			FigureManipulator fm = new AnimationManipulator();
//			figure.addFigureManipulator( fm );
//			animManips.put(figure, fm );
//		}
d50 4
a53 6
	protected void basicOrphan(Figure figure){
		if(figure instanceof AnimationDecorator){
			((AnimationDecorator)figure).peelDecoration();
		}
		if(decorations.containsKey( figure )){
			decorations.remove( figure );
d55 1
a55 1
		super.basicOrphan(figure);
a56 7
//	protected void figureRequestRemove(FigureChangeEvent e) {
//		Figure f = e.getFigure();
//		if(animManips.containsKey( f )) {
//			AnimationManipulator am = (AnimationManipulator)animManips.remove( f );
//		}
//		super.figureRequestRemove(e);
//	}
d72 3
a74 54
		FigureEnumeration fe = new FigureEnumerator(getFigures());
		while (fe.hasNextFigure()) {
			Figure f = fe.nextFigure();

			if(!(f instanceof ConnectionFigure)) {
				((AnimationDecorator) f).animationStep();
			}
		}
//		for(Iterator it= animManips.values().iterator();it.hasNext();){
//			Animatable am = (Animatable)it.next();
//			am.animationStep();
//		}
	}
	public void write(StorableOutput dw) {
		super.write(dw);
		//store mappings
		dw.writeInt( decorations.size() );
		Iterator it = decorations.keySet().iterator();
		while (it.hasNext()) {
			Figure key = (Figure) it.next();
			Figure value = (Figure) decorations.get( key );
			dw.writeStorable( key );
			dw.writeStorable( value );
		}
	}
	
	/**
	 * Reads the contained figures from StorableInput.
	 * The loading process is assumed to be serial and not in need of synchronization.
	 */
	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		//load mappings
		int size = dr.readInt();
		decorations = new HashMap( size );
		for (int i=0; i<size; i++) {
			Figure key = (Figure) dr.readStorable();
			Figure value = (Figure) dr.readStorable();
			decorations.put( key, value);
		}
	}
	/**
	 * Returns all the figures minus the decorations added in the add method
	 */
	public FigureEnumeration figures() {
		List figs = CollectionsFactory.current().createList(decorations.size());
		figs.addAll( decorations.keySet() );
		
		FigureEnumeration fe = new FigureEnumerator(CollectionsFactory.current().createList(getFigures()));
		while(fe.hasNextFigure()){
			Figure f = fe.nextFigure();
			if(!decorations.containsValue( f )){
				figs.add( f );
			}
a75 1
		return new FigureEnumerator(CollectionsFactory.current().createList(figs));
@


1.6.4.4
log
@More cleanups for DecoratorFigure.  Its going to cause problems till the architecture changes.
Added a few needed methods to expose private variables of StandardDrawingView to make it more
override friendly.
@
text
@a25 12
 * <b>NOTE: I attempted to hide the internal DecoratorFigures that bouncing
 * Drawing uses, but unfortunately the current lack of document-view seperation
 * causes problems with selection and other things.  Normally when you select a figure
 * with a tool, it will be a AnimationDecorator, but we are supposed to hide that.
 * so selections will be the the mapped figure.  Its a problem because  internally
 * the drawing needs to use the animation decorator to draw it.  Its difficuly
 * to decide which methods should expose the real figure, and which should expose the
 * decorator.  In the end I think the decision will lead to a form of 
 * document-view seperation anyway.  So I am not fixing these problems, and
 * will tend to them when the document view seperation occurs.
 * If you are having issues, try using <code>StandardDrawing</code> instead.
 *
d40 1
a40 1
//		decorations = new HashMap();
d45 4
a48 1
	 *
d54 1
a54 1
//			decorations.put( figure,  ad);
a71 4
	/**
	 * Peeling will make undo difficult.  The whole undo system cant handle the
	 * DecoratorFigures anyway so expect problems.
	 */
d73 6
a78 6
//		if(figure instanceof AnimationDecorator){
//			((AnimationDecorator)figure).peelDecoration();
//		}
//		if(decorations.containsKey( figure )){
//			decorations.remove( figure );
//		}
d136 23
a158 7
//		int size = dr.readInt();
//		decorations = new HashMap( size );
//		for (int i=0; i<size; i++) {
//			Figure key = (Figure) dr.readStorable();
//			Figure value = (Figure) dr.readStorable();
//			decorations.put( key, value);
//		}
a159 16
//	/**
//	 * Returns all the figures minus the decorations added in the add method
//	 */
//	public FigureEnumeration figures() {
//		List figs = CollectionsFactory.current().createList(decorations.size());
//		figs.addAll( decorations.keySet() );
//		
//		FigureEnumeration fe = new FigureEnumerator(CollectionsFactory.current().createList(getFigures()));
//		while(fe.hasNextFigure()){
//			Figure f = fe.nextFigure();
//			if(!decorations.containsValue( f )){
//				figs.add( f );
//			}
//		}
//		return new FigureEnumerator(CollectionsFactory.current().createList(figs));
//	}
@


1.6.4.5
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d17 5
d47 13
a59 2

	public synchronized Figure add(Figure figure) {
d62 3
a64 1
			figure = new AnimationDecorator(figure);
d66 13
a78 1
		return super.add(figure);
d81 12
a92 6
	public synchronized Figure remove(Figure figure) {
		Figure f = super.remove(figure);
		if (f instanceof AnimationDecorator) {
			return ((AnimationDecorator) f).peelDecoration();
		}
		return f;
d94 7
d116 1
a116 1
		FigureEnumeration fe = figures();
d119 1
a119 1
			
d124 4
d129 10
d140 34
@


1.6.4.6
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d34 1
a34 2
 *  @@deprecated Completely does not work in dnoyeb1  no way to hide the decorations
 *              which is required.  I have quite trying to fix it for now.
d43 1
a43 1
	public synchronized void add(Figure figure) {
d48 1
a48 1
		super.add(figure);
d51 7
a57 7
//	public synchronized void remove(Figure figure) {
//		Figure f = super.remove(figure);
//		if (f instanceof AnimationDecorator) {
//			return ((AnimationDecorator) f).peelDecoration();
//		}
//		return f;
//	}
@


1.6.4.7
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d35 1
a35 2
 *              which is required.  I have quit trying to fix it for now.  I think
 *              it can probably return with document-view seperation.
@


1.5
log
@after variou merges... (before 5.4 release)
@
text
@a13 1
import java.util.*;
d60 1
a60 1
			Figure f = (Figure)fe.nextFigure();
@


1.4
log
@merge dnd (before 5.3)
@
text
@a13 1
import java.awt.*;
d59 3
a61 3
		Enumeration k = figures();
		while (k.hasMoreElements()) {
			Figure f = (Figure) k.nextElement();
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d24 5
a28 5
    /*
     * Serialization support.
     */
    private static final long serialVersionUID = -8566272817418441758L;
    private int bouncingDrawingSerializedDataVersion = 1;
d30 7
a36 7
    public synchronized Figure add(Figure figure) {
        if (!(figure instanceof AnimationDecorator) &&
            !(figure instanceof ConnectionFigure)) {
            figure = new AnimationDecorator(figure);
        }
        return super.add(figure);
    }
d38 7
a44 3
    public synchronized Figure remove(Figure figure) {
        return super.remove(figure);
    }
d51 7
a57 7
    public synchronized Figure replace(Figure figure, Figure replacement) {
        if (!(replacement instanceof AnimationDecorator) &&
            !(replacement instanceof ConnectionFigure)) {
            replacement = new AnimationDecorator(replacement);
        }
        return super.replace(figure, replacement);
    }
d59 10
a68 10
    public void animationStep() {
        Enumeration k = figures();
        while (k.hasMoreElements()) {
            Figure f = (Figure) k.nextElement();
            
            if(!(f instanceof ConnectionFigure)) {
                ((AnimationDecorator) f).animationStep();
            }
        }
    }
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)BouncingDrawing.java 5.2
d4 6
d20 3
a22 1

d31 2
a32 1
        if (!(figure instanceof AnimationDecorator))
d34 1
d39 1
a39 4
        Figure f = super.remove(figure);
        if (f instanceof AnimationDecorator)
            return ((AnimationDecorator) f).peelDecoration();
        return f;
d42 8
a49 2
    public synchronized void replace(Figure figure, Figure replacement) {
        if (!(replacement instanceof AnimationDecorator))
d51 2
a52 1
        super.replace(figure, replacement);
d57 7
a63 2
        while (k.hasMoreElements())
            ((AnimationDecorator) k.nextElement()).animationStep();
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)BouncingDrawing.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
