head	1.6;
access;
symbols
	jhotdraw54b2-release:1.6
	reorg_6x_split:1.6
	MVC_PHASE1:1.5.0.10
	NEW_ATTRIBUTES:1.5.0.8
	DNOYEB1_ALPHA-2:1.5.4.1
	release_JHD54b1:1.5
	BUGFIX_670992:1.5.0.6
	DNOYEB1_ALPHA-1:1.5
	dnoyeb1:1.5.0.4
	repack:1.5.0.2
	Root_repack:1.5
	Before_FigureVisitor:1.5
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2003.11.09.21.18.46;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.04.22.53.45;	author mrfloppy;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.04.30.20.40.07;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.44.32;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches;
next	;

1.5.4.1
date	2003.01.26.00.51.06;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.6
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 * @@(#)PertFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.samples.pert;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.figures.*;
import CH.ifa.draw.util.*;

import java.awt.*;
import java.io.*;
import java.util.Iterator;
import java.util.List;

/**
 * @@version <$CURRENT_VERSION$>
 */
public class PertFigure extends CompositeFigure {
	private static final int BORDER = 3;
	private Rectangle fDisplayBox;
	private List fPreTasks;
	private List fPostTasks;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = -7877776240236946511L;
	private int pertFigureSerializedDataVersion = 1;

	public PertFigure() {
		initialize();
	}

	public int start() {
		int start = 0;
		Iterator iter = fPreTasks.iterator();
		while (iter.hasNext()) {
			PertFigure f = (PertFigure)iter.next();
			start = Math.max(start, f.end());
		}
		return start;
	}

	public int end() {
		return asInt(2);
	}

	public int duration() {
		return asInt(1);
	}

	public void setEnd(int value) {
		setInt(2, value);
	}

	public void addPreTask(PertFigure figure) {
		if (!fPreTasks.contains(figure)) {
			fPreTasks.add(figure);
		}
	}

	public void addPostTask(PertFigure figure) {
		if (!fPostTasks.contains(figure)) {
			fPostTasks.add(figure);
		}
	}

	public void removePreTask(PertFigure figure) {
		fPreTasks.remove(figure);
	}

	public void removePostTask(PertFigure figure) {
		fPostTasks.remove(figure);
	}

	private int asInt(int figureIndex) {
		NumberTextFigure t = (NumberTextFigure)figureAt(figureIndex);
		return t.getValue();
	}

	private String taskName() {
		TextFigure t = (TextFigure)figureAt(0);
		return t.getText();
	}

	private void setInt(int figureIndex, int value) {
		NumberTextFigure t = (NumberTextFigure)figureAt(figureIndex);
		t.setValue(value);
	}

	protected void basicMoveBy(int x, int y) {
		fDisplayBox.translate(x, y);
		super.basicMoveBy(x, y);
	}

	public Rectangle displayBox() {
		return new Rectangle(
			fDisplayBox.x,
			fDisplayBox.y,
			fDisplayBox.width,
			fDisplayBox.height);
	}

	public void basicDisplayBox(Point origin, Point corner) {
		fDisplayBox = new Rectangle(origin);
		fDisplayBox.add(corner);
		layout();
	}

	private void drawBorder(Graphics g) {
		super.draw(g);

		Rectangle r = displayBox();

		Figure f = figureAt(0);
		Rectangle rf = f.displayBox();
		g.setColor(Color.gray);
		g.drawLine(r.x, r.y+rf.height+2, r.x+r.width, r.y + rf.height+2);
		g.setColor(Color.white);
		g.drawLine(r.x, r.y+rf.height+3, r.x+r.width, r.y + rf.height+3);

		g.setColor(Color.white);
		g.drawLine(r.x, r.y, r.x, r.y + r.height);
		g.drawLine(r.x, r.y, r.x + r.width, r.y);
		g.setColor(Color.gray);
		g.drawLine(r.x + r.width, r.y, r.x + r.width, r.y + r.height);
		g.drawLine(r.x , r.y + r.height, r.x + r.width, r.y + r.height);
	}

	public void draw(Graphics g) {
		drawBorder(g);
		super.draw(g);
	}

	public HandleEnumeration handles() {
		List handles = CollectionsFactory.current().createList();
		handles.add(new NullHandle(this, RelativeLocator.northWest()));
		handles.add(new NullHandle(this, RelativeLocator.northEast()));
		handles.add(new NullHandle(this, RelativeLocator.southWest()));
		handles.add(new NullHandle(this, RelativeLocator.southEast()));
		handles.add(new ConnectionHandle(this, RelativeLocator.east(),
								new PertDependency())
						   );
		return new HandleEnumerator(handles);
	}

	private void initialize() {
		fPostTasks = CollectionsFactory.current().createList();
		fPreTasks = CollectionsFactory.current().createList();
		fDisplayBox = new Rectangle(0, 0, 0, 0);

		Font f = new Font("Helvetica", Font.PLAIN, 12);
		Font fb = new Font("Helvetica", Font.BOLD, 12);

		TextFigure name = new TextFigure();
		name.setFont(fb);
		name.setText("Task");
		//name.setAttribute(FigureAttributeConstant.TEXT_COLOR.getName(), Color.white);
		add(name);

		NumberTextFigure duration = new NumberTextFigure();
		duration.setValue(0);
		duration.setFont(fb);
		add(duration);

		NumberTextFigure end = new NumberTextFigure();
		end.setValue(0);
		end.setFont(f);
		end.setReadOnly(true);
		add(end);
	}

	private void layout() {
		Point partOrigin = new Point(fDisplayBox.x, fDisplayBox.y);
		partOrigin.translate(BORDER, BORDER);
		Dimension extent = new Dimension(0, 0);

		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			Figure f = fe.nextFigure();

			Dimension partExtent = f.size();
			Point corner = new Point(
								partOrigin.x+partExtent.width,
								partOrigin.y+partExtent.height);
			f.basicDisplayBox(partOrigin, corner);

			extent.width = Math.max(extent.width, partExtent.width);
			extent.height += partExtent.height;
			partOrigin.y += partExtent.height;
		}
		fDisplayBox.width = extent.width + 2*BORDER;
		fDisplayBox.height = extent.height + 2*BORDER;
	}

	private boolean needsLayout() {
		Dimension extent = new Dimension(0, 0);

		FigureEnumeration fe = figures();
		while (fe.hasNextFigure()) {
			Figure f = fe.nextFigure();
			extent.width = Math.max(extent.width, f.size().width);
		}
		int newExtent = extent.width + 2*BORDER;
		return newExtent != fDisplayBox.width;
	}

	public void update(FigureChangeEvent e) {
		if (e.getFigure() == figureAt(1)) {
			// duration has changed
			updateDurations();
		}
		if (needsLayout()) {
			layout();
			changed();
		}
	}

	public void figureChanged(FigureChangeEvent e) {
		update(e);
	}


	public void figureRemoved(FigureChangeEvent e) {
		update(e);
	}

	public void notifyPostTasks() {
		Iterator iter = fPostTasks.iterator();
		while (iter.hasNext()) {
			((PertFigure)iter.next()).updateDurations();
		}
	}

	public void updateDurations() {
		int newEnd = start()+duration();
		if (newEnd != end()) {
			setEnd(newEnd);
			notifyPostTasks();
		}
	}

	public boolean hasCycle(Figure start) {
		if (start == this) {
			return true;
		}
		Iterator iter = fPreTasks.iterator();
		while (iter.hasNext()) {
			if (((PertFigure)iter.next()).hasCycle(start)) {
				return true;
			}
		}
		return false;
	}

	//-- store / load ----------------------------------------------

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fDisplayBox.x);
		dw.writeInt(fDisplayBox.y);
		dw.writeInt(fDisplayBox.width);
		dw.writeInt(fDisplayBox.height);

		writeTasks(dw, fPreTasks);
		writeTasks(dw, fPostTasks);
	}

	public void writeTasks(StorableOutput dw, List l) {
		dw.writeInt(l.size());
		Iterator iter = l.iterator();
		while (iter.hasNext()) {
			dw.writeStorable((Storable)iter.next());
		}
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fDisplayBox = new Rectangle(
			dr.readInt(),
			dr.readInt(),
			dr.readInt(),
			dr.readInt());
		layout();
		fPreTasks = readTasks(dr);
		fPostTasks = readTasks(dr);
	}

	public Insets connectionInsets() {
		Rectangle r = fDisplayBox;
		int cx = r.width/2;
		int cy = r.height/2;
		return new Insets(cy, cx, cy, cx);
	}

	public List readTasks(StorableInput dr) throws IOException {
		int size = dr.readInt();
		List l = CollectionsFactory.current().createList(size);
		for (int i=0; i<size; i++) {
			l.add(dr.readStorable());
		}
		return l;
	}
}
@


1.5
log
@after variou merges... (before 5.4 release)
@
text
@d309 1
a309 1
			l.add((Figure)dr.readStorable());
@


1.5.4.1
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d232 5
@


1.4
log
@no message
@
text
@a13 3
import java.awt.*;
import java.util.*;
import java.io.*;
d19 5
d30 2
a31 2
	private Vector fPreTasks;
	private Vector fPostTasks;
d45 3
a47 3
		Enumeration i = fPreTasks.elements();
		while (i.hasMoreElements()) {
			PertFigure f = (PertFigure) i.nextElement();
d67 1
a67 1
			fPreTasks.addElement(figure);
d73 1
a73 1
			fPostTasks.addElement(figure);
d78 1
a78 1
		fPreTasks.removeElement(figure);
d82 1
a82 1
		fPostTasks.removeElement(figure);
d144 7
a150 7
	public Vector handles() {
		Vector handles = new Vector();
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		handles.addElement(new ConnectionHandle(this, RelativeLocator.east(),
d153 1
a153 1
		return handles;
d157 2
a158 2
		fPostTasks = new Vector();
		fPreTasks = new Vector();
d187 3
a189 3
		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();
d208 3
a210 3
		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();
d238 3
a240 3
		Enumeration i = fPostTasks.elements();
		while (i.hasMoreElements()) {
			((PertFigure) i.nextElement()).updateDurations();
d256 3
a258 3
		Enumeration i = fPreTasks.elements();
		while (i.hasMoreElements()) {
			if (((PertFigure) i.nextElement()).hasCycle(start)) {
d278 5
a282 5
	public void writeTasks(StorableOutput dw, Vector v) {
		dw.writeInt(v.size());
		Enumeration i = v.elements();
		while (i.hasMoreElements()) {
			dw.writeStorable((Storable) i.nextElement());
d305 1
a305 1
	public Vector readTasks(StorableInput dr) throws IOException {
d307 1
a307 1
		Vector v = new Vector(size);
d309 1
a309 1
			v.addElement((Figure)dr.readStorable());
d311 1
a311 1
		return v;
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@d165 1
a165 1
		//name.setAttribute("TextColor",Color.white);
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)PertFigure.java 5.2
d4 6
d22 114
d137 174
a310 279
public class PertFigure extends CompositeFigure {
    private static final int BORDER = 3;
    private Rectangle fDisplayBox;
    private Vector fPreTasks;
    private Vector fPostTasks;

    /*
     * Serialization support.
     */
    private static final long serialVersionUID = -7877776240236946511L;
    private int pertFigureSerializedDataVersion = 1;

    public PertFigure() {
        initialize();
    }

    public int start() {
        int start = 0;
        Enumeration i = fPreTasks.elements();
        while (i.hasMoreElements()) {
            PertFigure f = (PertFigure) i.nextElement();
            start = Math.max(start, f.end());
        }
        return start;
    }

    public int end() {
        return asInt(2);
    }

    public int duration() {
        return asInt(1);
    }

    public void setEnd(int value) {
        setInt(2, value);
    }

    public void addPreTask(PertFigure figure) {
        if (!fPreTasks.contains(figure)) {
            fPreTasks.addElement(figure);
        }
    }

    public void addPostTask(PertFigure figure) {
        if (!fPostTasks.contains(figure)) {
            fPostTasks.addElement(figure);
        }
    }

    public void removePreTask(PertFigure figure) {
        fPreTasks.removeElement(figure);
    }

    public void removePostTask(PertFigure figure) {
        fPostTasks.removeElement(figure);
    }

    private int asInt(int figureIndex) {
        NumberTextFigure t = (NumberTextFigure)figureAt(figureIndex);
        return t.getValue();
    }

    private String taskName() {
        TextFigure t = (TextFigure)figureAt(0);
        return t.getText();
    }

    private void setInt(int figureIndex, int value) {
        NumberTextFigure t = (NumberTextFigure)figureAt(figureIndex);
        t.setValue(value);
    }

    protected void basicMoveBy(int x, int y) {
	    fDisplayBox.translate(x, y);
	    super.basicMoveBy(x, y);
	}

    public Rectangle displayBox() {
        return new Rectangle(
            fDisplayBox.x,
            fDisplayBox.y,
            fDisplayBox.width,
            fDisplayBox.height);
    }

    public void basicDisplayBox(Point origin, Point corner) {
        fDisplayBox = new Rectangle(origin);
        fDisplayBox.add(corner);
        layout();
    }

    private void drawBorder(Graphics g) {
        super.draw(g);

        Rectangle r = displayBox();

        Figure f = figureAt(0);
        Rectangle rf = f.displayBox();
        g.setColor(Color.gray);
        g.drawLine(r.x, r.y+rf.height+2, r.x+r.width, r.y + rf.height+2);
        g.setColor(Color.white);
        g.drawLine(r.x, r.y+rf.height+3, r.x+r.width, r.y + rf.height+3);

        g.setColor(Color.white);
        g.drawLine(r.x, r.y, r.x, r.y + r.height);
        g.drawLine(r.x, r.y, r.x + r.width, r.y);
        g.setColor(Color.gray);
        g.drawLine(r.x + r.width, r.y, r.x + r.width, r.y + r.height);
        g.drawLine(r.x , r.y + r.height, r.x + r.width, r.y + r.height);
    }

    public void draw(Graphics g) {
        drawBorder(g);
        super.draw(g);
    }

    public Vector handles() {
        Vector handles = new Vector();
        handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
        handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
        handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
        handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
        handles.addElement(new ConnectionHandle(this, RelativeLocator.east(),
                                new PertDependency())
                           );
        return handles;
    }

    private void initialize() {
        fPostTasks = new Vector();
        fPreTasks = new Vector();
        fDisplayBox = new Rectangle(0, 0, 0, 0);

        Font f = new Font("Helvetica", Font.PLAIN, 12);
        Font fb = new Font("Helvetica", Font.BOLD, 12);

        TextFigure name = new TextFigure();
        name.setFont(fb);
        name.setText("Task");
        //name.setAttribute("TextColor",Color.white);
        add(name);

        NumberTextFigure duration = new NumberTextFigure();
        duration.setValue(0);
        duration.setFont(fb);
        add(duration);

        NumberTextFigure end = new NumberTextFigure();
        end.setValue(0);
        end.setFont(f);
        end.setReadOnly(true);
        add(end);
    }

    private void layout() {
	    Point partOrigin = new Point(fDisplayBox.x, fDisplayBox.y);
	    partOrigin.translate(BORDER, BORDER);
	    Dimension extent = new Dimension(0, 0);

        FigureEnumeration k = figures();
        while (k.hasMoreElements()) {
            Figure f = k.nextFigure();

		    Dimension partExtent = f.size();
		    Point corner = new Point(
		                        partOrigin.x+partExtent.width,
		                        partOrigin.y+partExtent.height);
    		f.basicDisplayBox(partOrigin, corner);

		    extent.width = Math.max(extent.width, partExtent.width);
		    extent.height += partExtent.height;
		    partOrigin.y += partExtent.height;
        }
	    fDisplayBox.width = extent.width + 2*BORDER;
	    fDisplayBox.height = extent.height + 2*BORDER;
    }

    private boolean needsLayout() {
	    Dimension extent = new Dimension(0, 0);

        FigureEnumeration k = figures();
        while (k.hasMoreElements()) {
            Figure f = k.nextFigure();
		    extent.width = Math.max(extent.width, f.size().width);
        }
        int newExtent = extent.width + 2*BORDER;
        return newExtent != fDisplayBox.width;
    }

    public void update(FigureChangeEvent e) {
        if (e.getFigure() == figureAt(1))  // duration has changed
            updateDurations();
        if (needsLayout()) {
            layout();
            changed();
        }
    }

    public void figureChanged(FigureChangeEvent e) {
        update(e);
    }


    public void figureRemoved(FigureChangeEvent e) {
        update(e);
    }

    public void notifyPostTasks() {
        Enumeration i = fPostTasks.elements();
        while (i.hasMoreElements())
            ((PertFigure) i.nextElement()).updateDurations();
    }

    public void updateDurations() {
        int newEnd = start()+duration();
        if (newEnd != end()) {
            setEnd(newEnd);
            notifyPostTasks();
        }
    }

    public boolean hasCycle(Figure start) {
        if (start == this)
            return true;
        Enumeration i = fPreTasks.elements();
        while (i.hasMoreElements()) {
            if (((PertFigure) i.nextElement()).hasCycle(start))
                return true;
        }
        return false;
    }

    //-- store / load ----------------------------------------------

    public void write(StorableOutput dw) {
        super.write(dw);
        dw.writeInt(fDisplayBox.x);
        dw.writeInt(fDisplayBox.y);
        dw.writeInt(fDisplayBox.width);
        dw.writeInt(fDisplayBox.height);

        writeTasks(dw, fPreTasks);
        writeTasks(dw, fPostTasks);
    }

    public void writeTasks(StorableOutput dw, Vector v) {
        dw.writeInt(v.size());
        Enumeration i = v.elements();
        while (i.hasMoreElements())
            dw.writeStorable((Storable) i.nextElement());
    }

    public void read(StorableInput dr) throws IOException {
        super.read(dr);
        fDisplayBox = new Rectangle(
            dr.readInt(),
            dr.readInt(),
            dr.readInt(),
            dr.readInt());
        layout();
        fPreTasks = readTasks(dr);
        fPostTasks = readTasks(dr);
    }

    public Insets connectionInsets() {
        Rectangle r = fDisplayBox;
        int cx = r.width/2;
        int cy = r.height/2;
        return new Insets(cy, cx, cy, cx);
    }

    public Vector readTasks(StorableInput dr) throws IOException {
        int size = dr.readInt();
        Vector v = new Vector(size);
        for (int i=0; i<size; i++)
            v.addElement((Figure)dr.readStorable());
        return v;
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)PertFigure.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
