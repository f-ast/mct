head	1.7;
access;
symbols
	jhotdraw54b2-release:1.7
	reorg_6x_split:1.7
	MVC_PHASE1:1.7.0.10
	NEW_ATTRIBUTES:1.7.0.8
	DNOYEB1_ALPHA-2:1.7.4.2
	release_JHD54b1:1.7
	BUGFIX_670992:1.7.0.6
	DNOYEB1_ALPHA-1:1.7.4.2
	dnoyeb1:1.7.0.4
	repack:1.7.0.2
	Root_repack:1.7
	Before_FigureVisitor:1.7
	JHotDraw_5-3:1.6
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.25.12;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.29.13.42.13;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.7.4.1
date	2003.01.14.18.21.47;	author dnoyeb;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.01.16.15.58.50;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.7
log
@after variou merges... (before 5.4 release)
@
text
@/*
 * @@(#)InsertImageCommand.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.figures;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.*;
import java.awt.*;
import java.lang.ref.WeakReference;

/**
 * Command to insert a named image.
 *
 * @@version <$CURRENT_VERSION$>
 */
public class InsertImageCommand extends AbstractCommand {

	private String  myImageName;

	/**
	 * Constructs an insert image command.
	 * @@param name the command name
	 * @@param newImageName the pathname of the image
	 * @@param newDrawingEditor the DrawingEditor which manages the views
	 */
	public InsertImageCommand(String name, String newImageName, DrawingEditor newDrawingEditor) {
		super(name, newDrawingEditor);
		myImageName = newImageName;
	}

	public void execute() {
		super.execute();
		setUndoActivity(createUndoActivity());
		((InsertImageCommand.UndoActivity)getUndoActivity()).insertImage();
		view().checkDamage();
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new InsertImageCommand.UndoActivity(view(), myImageName);
	}

	public class UndoActivity extends UndoableAdapter {

		/**
		 * Use weak reference so if the command is the last one which references
		 * the ImageFigure then it might be garbage collected. Usually, the ImageFigure
		 * is referenced from the drawing it is inserted and might be only garbage
		 * collected after an undo operation (which removes the ImageFigure from
		 * the drawing). If it has been garbage collected but is requested again
		 * (e.g. during a redo operation) it is restored if possible.
		 */
		WeakReference	myAffectedImageFigure;
		private String  myAffectedImageName;
		
		UndoActivity(DrawingView newDrawingView, String newAffectedImageName) {
			super(newDrawingView);
			myAffectedImageName = newAffectedImageName;
			setUndoable(true);
			setRedoable(true);			
		}
		
		protected void setImageFigure(ImageFigure newImageFigure) {
			myAffectedImageFigure = new WeakReference(newImageFigure);
		}
		
		protected ImageFigure getImageFigure() {
			// load image if it has not been loaded so far
			if ((myAffectedImageFigure == null) || (myAffectedImageFigure.get() == null)) {
				// ugly cast to component, but AWT wants a Component instead of an ImageObserver...
				Image image = Iconkit.instance().registerAndLoadImage(
					(Component)getDrawingView(), myAffectedImageName);
				setImageFigure(new ImageFigure(
					image, myAffectedImageName, getDrawingView().lastClick()));
			}
	
			return (ImageFigure)myAffectedImageFigure.get();
		}
	
		public boolean undo() {
			if (super.undo()) {
				getDrawingView().clearSelection();
	
				getDrawingView().drawing().orphan(getImageFigure());
	
				return true;
			}
			
			return false;
		}
	
		public boolean redo() {
			// do not call execute directly as the selection might has changed
			if (isRedoable()) {
				insertImage();
				return true;
			}
			
			return false;
		}

		protected void insertImage() {
			getDrawingView().add(getImageFigure());
			getDrawingView().clearSelection();
			getDrawingView().addToSelection(getImageFigure());
		}
	}
}
@


1.7.4.1
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d96 1
a96 2
				//this tool is now responsible for the release or readd of the figure it removed
				//!!!dnoyeb!!!
@


1.7.4.2
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d44 1
a44 1
		view().drawing().update();
@


1.6
log
@merge dnd (before 5.3)
@
text
@a17 1
import java.util.*;
d32 1
a32 1
	 * @@param image the pathname of the image
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d28 1
a28 1
    private String  myImageName;
d30 17
a46 16
   /**
    * Constructs an insert image command.
    * @@param name the command name
    * @@param image the pathname of the image
    * @@param view the target view
    */
    public InsertImageCommand(String name, String newImageName, DrawingView view) {
        super(name, view);
        myImageName = newImageName;
    }

    public void execute() {
    	setUndoActivity(createUndoActivity());
    	((InsertImageCommand.UndoActivity)getUndoActivity()).insertImage();
        view().checkDamage();
    }
d57 8
a64 8
	    /**
	     * Use weak reference so if the command is the last one which references
	     * the ImageFigure then it might be garbage collected. Usually, the ImageFigure
	     * is referenced from the drawing it is inserted and might be only garbage
	     * collected after an undo operation (which removes the ImageFigure from
	     * the drawing). If it has been garbage collected but is requested again
	     * (e.g. during a redo operation) it is restored if possible.
	     */
d66 2
a67 2
    	private String  myAffectedImageName;
    	
d71 2
a72 2
	        setUndoable(true);
	        setRedoable(true);			
d74 14
a87 14
	    
	    protected void setImageFigure(ImageFigure newImageFigure) {
	    	myAffectedImageFigure = new WeakReference(newImageFigure);
	    }
	    
	    protected ImageFigure getImageFigure() {
	    	// load image if it has not been loaded so far
	    	if ((myAffectedImageFigure == null) || (myAffectedImageFigure.get() == null)) {
		        // ugly cast to component, but AWT wants a Component instead of an ImageObserver...
		        Image image = Iconkit.instance().registerAndLoadImage(
		        	(Component)getDrawingView(), myAffectedImageName);
		        setImageFigure(new ImageFigure(
		        	image, myAffectedImageName, getDrawingView().lastClick()));
	    	}
d89 2
a90 2
	    	return (ImageFigure)myAffectedImageFigure.get();
	    }
d98 1
a98 1
			    return true;
d101 1
a101 1
	        return false;
d115 3
a117 3
		    getDrawingView().add(getImageFigure());
		    getDrawingView().clearSelection();
		    getDrawingView().addToSelection(getImageFigure());
@


1.4
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)InsertImageCommand.java 5.2
d4 6
a13 3
import java.util.*;
import java.awt.*;
import CH.ifa.draw.util.*;
d16 4
d23 2
d26 1
a26 1
public class InsertImageCommand extends Command {
d28 1
a28 2
    private DrawingView  fView;
    private String       fImage;
d36 3
a38 4
    public InsertImageCommand(String name, String image, DrawingView view) {
        super(name);
        fImage = image;
        fView = view;
d42 3
a44 7
        // ugly cast to component, but AWT wants and Component instead of an ImageObserver...
        Image image = Iconkit.instance().registerAndLoadImage((Component)fView, fImage);
        ImageFigure figure = new ImageFigure(image, fImage, fView.lastClick());
        fView.add(figure);
        fView.clearSelection();
        fView.addToSelection(figure);
        fView.checkDamage();
d46 73
a119 3



@


1.3
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d17 1
a17 1
public class InsertImageCommand extends AbstractCommand {
d19 1
d29 1
a29 1
        super(name, view);
d31 1
d36 6
a41 6
        Image image = Iconkit.instance().registerAndLoadImage((Component)view(), fImage);
        ImageFigure figure = new ImageFigure(image, fImage, view().lastClick());
        view().add(figure);
        view().clearSelection();
        view().addToSelection(figure);
        view().checkDamage();
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d17 1
a17 1
public class InsertImageCommand extends Command {
a18 1
    private DrawingView  fView;
d28 1
a28 1
        super(name);
a29 1
        fView = view;
d34 6
a39 6
        Image image = Iconkit.instance().registerAndLoadImage((Component)fView, fImage);
        ImageFigure figure = new ImageFigure(image, fImage, fView.lastClick());
        fView.add(figure);
        fView.clearSelection();
        fView.addToSelection(figure);
        fView.checkDamage();
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)InsertImageCommand.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
