head	1.7;
access;
symbols
	jhotdraw54b2-release:1.7
	reorg_6x_split:1.7
	MVC_PHASE1:1.7.0.4
	NEW_ATTRIBUTES:1.7.0.2
	DNOYEB1_ALPHA-2:1.6.4.5
	release_JHD54b1:1.7
	BUGFIX_670992:1.6.0.6
	DNOYEB1_ALPHA-1:1.6.4.4
	dnoyeb1:1.6.0.4
	repack:1.6.0.2
	Root_repack:1.6
	Before_FigureVisitor:1.6
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2003.01.30.00.27.32;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.6.4.1
date	2003.01.10.04.54.38;	author dnoyeb;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.01.16.06.03.52;	author dnoyeb;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.01.18.04.49.03;	author dnoyeb;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.01.21.00.33.34;	author dnoyeb;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.01.26.00.50.50;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.7
log
@prepare for 5.4 release: various bug fixes
@
text
@/*
 * @@(#)BorderTool.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.figures;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.*;

import java.awt.event.MouseEvent;
import java.awt.event.InputEvent;
import java.util.List;

/**
 * BorderTool decorates the clicked figure with a BorderDecorator.
 *
 * @@see BorderDecorator
 *
 * @@version <$CURRENT_VERSION$>
 */
public  class BorderTool extends ActionTool {

	public BorderTool(DrawingEditor editor) {
		super(editor);
	}

	/**
	 * Add the touched figure to the selection of an invoke action.
	 * Overrides ActionTool's mouseDown to allow for peeling the border
	 * if there is one already.
	 * This is done by CTRLing the click
	 * @@see #action
	 */
	public void mouseDown(MouseEvent e, int x, int y) {
		setView((DrawingView)e.getSource());
		// if not CTRLed then proceed normally
		if ((e.getModifiers() & InputEvent.CTRL_MASK) == 0) {
			super.mouseDown(e, x, y);
		}
		else {
			Figure target = drawing().findFigure(x, y);
			if ((target != null) && (target != target.getDecoratedFigure())) {
				view().addToSelection(target);
				reverseAction(target);
			}
		}
	}

	/**
	* Decorates the clicked figure with a border.
	*/
	public void action(Figure figure) {
//    	Figure replaceFigure = drawing().replace(figure, new BorderDecorator(figure));
		
		setUndoActivity(createUndoActivity());
		List l = CollectionsFactory.current().createList();
		l.add(figure);
		l.add(new BorderDecorator(figure));
		getUndoActivity().setAffectedFigures(new FigureEnumerator(l));
		((BorderTool.UndoActivity)getUndoActivity()).replaceAffectedFigures();
	}

	/**
	* Peels off the border from the clicked figure.
	*/
	public void reverseAction(Figure figure) {
		setUndoActivity(createUndoActivity());
		List l = CollectionsFactory.current().createList();
		l.add(figure);
		l.add(((DecoratorFigure)figure).peelDecoration());
		getUndoActivity().setAffectedFigures(new FigureEnumerator(l));
		((BorderTool.UndoActivity)getUndoActivity()).replaceAffectedFigures();
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new BorderTool.UndoActivity(view());
	}

	public static class UndoActivity extends UndoableAdapter {
		public UndoActivity(DrawingView newDrawingView) {
			super(newDrawingView);
			setUndoable(true);
			setRedoable(true);
		}

		public boolean undo() {
			if (!super.undo()) {
				return false;
			}
			getDrawingView().clearSelection();
			return replaceAffectedFigures();
		}

		public boolean redo() {
			if (!isRedoable()) {
				return false;
			}
			getDrawingView().clearSelection();
			return replaceAffectedFigures();
		}
		
		public boolean replaceAffectedFigures() {
			FigureEnumeration fe = getAffectedFigures();
			if (!fe.hasNextFigure()) {
				return false;
			}
			Figure oldFigure = fe.nextFigure();

			if (!fe.hasNextFigure()) {
				return false;
			}
			Figure replaceFigure = fe.nextFigure();
			
			replaceFigure = getDrawingView().drawing().replace(oldFigure, replaceFigure);
			List l = CollectionsFactory.current().createList();
			l.add(replaceFigure);
			l.add(oldFigure);
			setAffectedFigures(new FigureEnumerator(l));
			
			return true;
		}
	}
}
@


1.6
log
@after variou merges... (before 5.4 release)
@
text
@d50 1
a50 1
			if (target != null && target instanceof DecoratorFigure) {
@


1.6.4.1
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d18 1
a18 1

d42 2
a43 6
	public void mouseDown(DrawingViewMouseEvent dvme) {
		// use event coordinates to supress any kind of
		// transformations like constraining points to a grid
		setAnchorX( dvme.getX() );
		setAnchorY( dvme.getY() );		
		setView( dvme.getDrawingView() );
d45 2
a46 2
		if ((dvme.getMouseEvent().getModifiers() & InputEvent.CTRL_MASK) == 0) {
			super.mouseDown(dvme);
d49 1
a49 1
			Figure target = drawing().findFigure( getAnchorX(), getAnchorY());
@


1.6.4.2
log
@New FigureDecorator using decorator pattern now installed.
A few other minor cleanups.
@
text
@a25 1
 * @@deprecated see {@@link CH.ifa.draw.contrib.DecoratorTool DecoratorTool}.
a39 1
	 *
@


1.6.4.3
log
@Decorator Figure returns...To apease the brave hearted :-)
Its not very well integrated with the current state of affairs.  It works as well as it always
has though.
@
text
@d26 2
a27 1
 * @@see CH.ifa.draw.contrib.DecoratorTool
@


1.6.4.4
log
@As per usual the DecoratorFigures are disagreeable.  Nevertheless the border decorator is working once again.
'twas the container hopping I mentioned in my last update.  its working but on shaky ground...
Use as own risk ;)
@
text
@d21 1
a21 1
import CH.ifa.draw.samples.javadraw.AnimationDecorator;
d71 1
d73 1
a73 1
		((BorderTool.UndoActivity)getUndoActivity()).borderizeFigures();
d83 1
a83 1
		//l.add(((DecoratorFigure)figure).peelDecoration());
d85 1
a85 1
		((BorderTool.UndoActivity)getUndoActivity()).borderizeFigures();
d106 2
a107 16
			if(getAffectedFigures().hasNextFigure()){
				getDrawingView().clearSelection();
				Figure f = getAffectedFigures().nextFigure();
				getDrawingView().drawing().orphan(f);
				
				if(f instanceof AnimationDecorator){
					f = ((AnimationDecorator)f).peelDecoration();
				}
				Figure innerf = ((DecoratorFigure)f).peelDecoration();
				
				List l = CollectionsFactory.current().createList(1);
				l.add( getDrawingView().drawing().add( innerf ) );
				setAffectedFigures(new FigureEnumerator( l ));
				return true;
			}
			return false;
d114 2
a115 1
			return borderizeFigures();
d118 9
a126 32
//		public boolean replaceAffectedFigures() {
//			FigureEnumeration fe = getAffectedFigures();
//			if (!fe.hasNextFigure()) {
//				return false;
//			}
//			Figure oldFigure = fe.nextFigure();
//
//			if (!fe.hasNextFigure()) {
//				return false;
//			}
//			Figure replaceFigure = fe.nextFigure();
//			
//			replaceFigure = getDrawingView().drawing().replace(oldFigure, replaceFigure);
//			List l = CollectionsFactory.current().createList();
//			l.add(replaceFigure);
//			l.add(oldFigure);
//			setAffectedFigures(new FigureEnumerator(l));
//			
//			return true;
//		}
		public boolean borderizeFigures() {
			if(getAffectedFigures().hasNextFigure()){
				Figure f = getAffectedFigures().nextFigure();
				getDrawingView().drawing().orphan(f);
				getDrawingView().clearSelection();

				BorderDecorator bd = new BorderDecorator(f);
				Figure newf = getDrawingView().add( bd );
				List l = CollectionsFactory.current().createList(1);
				l.add(newf);
				setAffectedFigures( new FigureEnumerator(l));
				return true;
d128 9
a136 1
			return false;
@


1.6.4.5
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d116 1
a116 2
				getDrawingView().drawing().add( innerf );
				l.add( innerf );
d157 1
a157 1
				getDrawingView().add( bd );
d159 1
a159 1
				l.add(bd);
@


1.5
log
@no message
@
text
@d16 2
a17 3
import CH.ifa.draw.util.UndoableAdapter;
import CH.ifa.draw.util.Undoable;
import java.util.Vector;
d20 1
d43 1
d64 4
a67 4
		Vector v = new Vector();
		v.addElement(figure);
		v.addElement(new BorderDecorator(figure));
		getUndoActivity().setAffectedFigures(new FigureEnumerator(v));
d76 4
a79 5
		Vector v = new Vector();
		v.addElement(figure);

		v.addElement(((DecoratorFigure)figure).peelDecoration());
		getUndoActivity().setAffectedFigures(new FigureEnumerator(v));
d115 1
a115 1
			if (!fe.hasMoreElements()) {
d120 1
a120 1
			if (!fe.hasMoreElements()) {
d126 4
a129 4
			Vector v = new Vector();
			v.addElement(replaceFigure);
			v.addElement(oldFigure);
			setAffectedFigures(new FigureEnumerator(v));			
@


1.4
log
@merge dnd (before 5.3)
@
text
@d19 2
d36 21
d66 13
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d29 2
a30 2
	public BorderTool(DrawingView view) {
		super(view);
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)BorderTool.java 5.2
d4 6
d14 1
d16 3
a18 1
import CH.ifa.draw.framework.*;
d24 2
d29 69
a97 10
    public BorderTool(DrawingView view) {
        super(view);
    }

    /**
    * Decorates the clicked figure with a border.
    */
    public void action(Figure figure) {
        drawing().replace(figure, new BorderDecorator(figure));
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)BorderTool.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
