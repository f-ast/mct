head	1.19;
access;
symbols
	jhotdraw54b2-release:1.19
	reorg_6x_split:1.19
	MVC_PHASE1:1.17.0.2
	NEW_ATTRIBUTES:1.16.0.2
	DNOYEB1_ALPHA-2:1.9.4.1
	release_JHD54b1:1.10
	BUGFIX_670992:1.9.0.6
	DNOYEB1_ALPHA-1:1.9
	dnoyeb1:1.9.0.4
	repack:1.9.0.2
	Root_repack:1.9
	Before_FigureVisitor:1.7
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.19
date	2003.10.06.13.57.41;	author ricardo_padilha;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.23.06.38.57;	author mtnygard;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.22.23.58.43;	author mrfloppy;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.07.18.12.47;	author ricardo_padilha;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.06.17.43.57;	author ricardo_padilha;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.06.17.41.09;	author ricardo_padilha;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.06.15.56.50;	author ricardo_padilha;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.04.05.33.41;	author ricardo_padilha;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.04.05.30.12;	author ricardo_padilha;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.26.22.04.31;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.23.07.47.22;	author mrfloppy;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2002.09.22.08.58.23;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.22.08.20.30;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.9.4.1
date	2003.01.26.00.50.51;	author dnoyeb;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.02.02.16.54.06;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Small fix to remove deprecation warning.
@
text
@/*
 * @@(#)TextFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.figures;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.CollectionsFactory;
import CH.ifa.draw.util.ColorMap;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

import java.awt.*;
import java.io.*;
import java.util.List;

/**
 * A text figure.
 *
 * @@see TextTool
 *
 * @@version <$CURRENT_VERSION$>
 */
public class TextFigure
	extends AttributeFigure
	implements FigureChangeListener, TextHolder {

	private int fOriginX;
	private int fOriginY;

	// cache of the TextFigure's size
	transient private boolean fSizeIsDirty = true;
	transient private int fWidth;
	transient private int fHeight;

	private String fText;
	private Font fFont;
	private boolean fIsReadOnly;

	private Figure fObservedFigure = null;
	private OffsetLocator fLocator = null;

	private static String fgCurrentFontName = "Helvetica";
	private static int fgCurrentFontSize = 12;
	private static int fgCurrentFontStyle = Font.PLAIN;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = 4599820785949456124L;
	private int textFigureSerializedDataVersion = 1;

	public TextFigure() {
		fOriginX = 0;
		fOriginY = 0;
		fFont = createCurrentFont();
		setAttribute(FigureAttributeConstant.FILL_COLOR, ColorMap.color("None"));
		fText = "";
		fSizeIsDirty = true;
	}

	/**
	 * @@see CH.ifa.draw.framework.Figure#moveBy(int, int)
	 */
	public void moveBy(int x, int y) {
		willChange();
		basicMoveBy(x, y);
		if (getLocator() != null) {
			getLocator().moveBy(x, y);
		}
		changed();
	}

	protected void basicMoveBy(int x, int y) {
		fOriginX += x;
		fOriginY += y;
	}

	/**
	 * @@see CH.ifa.draw.framework.Figure#basicDisplayBox(java.awt.Point, java.awt.Point)
	 */
	public void basicDisplayBox(Point newOrigin, Point newCorner) {
		fOriginX = newOrigin.x;
		fOriginY = newOrigin.y;
	}

	/**
	 * @@see CH.ifa.draw.framework.Figure#displayBox()
	 */
	public Rectangle displayBox() {
		Dimension extent = textExtent();
		return new Rectangle(fOriginX, fOriginY, extent.width, extent.height);
	}

	/**
	 * @@see CH.ifa.draw.standard.TextHolder#textDisplayBox()
	 */
	public Rectangle textDisplayBox() {
		return displayBox();
	}

	/**
	 * Tests whether this figure is read only.
	 */
	public boolean readOnly() {
		return fIsReadOnly;
	}

	/**
	 * Sets the read only status of the text figure.
	 */
	public void setReadOnly(boolean isReadOnly) {
		fIsReadOnly = isReadOnly;
	}

	/**
	 * Gets the font.
	 * @@see CH.ifa.draw.standard.TextHolder#getFont()
	 */
	public Font getFont() {
		return fFont;
	}

	/**
	 * Usually, a TextHolders is implemented by a Figure subclass. To avoid casting
	 * a TextHolder to a Figure this method can be used for polymorphism (in this
	 * case, let the (same) object appear to be of another type).
	 * Note, that the figure returned is not the figure to which the TextHolder is
	 * (and its representing figure) connected.
	 * @@return figure responsible for representing the content of this TextHolder
	 * @@see CH.ifa.draw.standard.TextHolder#getRepresentingFigure()
	 */
	public Figure getRepresentingFigure() {
		return this;
	}

	/**
	 * Sets the font.
	 */
	public void setFont(Font newFont) {
		willChange();
		fFont = newFont;
		markDirty();
		changed();
	}

	/**
	 * Updates the location whenever the figure changes itself.
	 * @@see CH.ifa.draw.framework.Figure#changed()
	 */
	public void changed() {
		super.changed();
		//updateLocation();
	}

	/**
	 * A text figure understands the "FontSize", "FontStyle", and "FontName"
	 * attributes.
	 *
	 * @@see CH.ifa.draw.framework.Figure#getAttribute(java.lang.String)
	 * @@deprecated use getAttribute(FigureAttributeConstant) instead
	 */
	public Object getAttribute(String name) {
		return getAttribute(FigureAttributeConstant.getConstant(name));
	}

	/**
	 * A text figure understands the "FontSize", "FontStyle", and "FontName"
	 * attributes.
	 * @@see CH.ifa.draw.framework.Figure#getAttribute(CH.ifa.draw.framework.FigureAttributeConstant)
	 */
	public Object getAttribute(FigureAttributeConstant attributeConstant) {
		Font font = getFont();
		if (attributeConstant.equals(FigureAttributeConstant.FONT_SIZE)) {
			return new Integer(font.getSize());
		}
		if (attributeConstant.equals(FigureAttributeConstant.FONT_STYLE)) {
			return new Integer(font.getStyle());
		}
		if (attributeConstant.equals(FigureAttributeConstant.FONT_NAME)) {
			return font.getName();
		}
		return super.getAttribute(attributeConstant);
	}

	/**
	 * A text figure understands the "FontSize", "FontStyle", and "FontName"
	 * attributes.
	 *
	 * @@see CH.ifa.draw.framework.Figure#setAttribute(java.lang.String, java.lang.Object)
	 * @@deprecated use setAttribute(FigureAttributeConstant, Object) instead
	 */
	public void setAttribute(String name, Object value) {
		setAttribute(FigureAttributeConstant.getConstant(name), value);
	}

	/**
	 * A text figure understands the "FontSize", "FontStyle", and "FontName"
	 * attributes.
	 * @@see CH.ifa.draw.framework.Figure#setAttribute(CH.ifa.draw.framework.FigureAttributeConstant, java.lang.Object)
	 */
	public void setAttribute(FigureAttributeConstant attributeConstant, Object value) {
		Font font = getFont();
		if (attributeConstant.equals(FigureAttributeConstant.FONT_SIZE)) {
			Integer s = (Integer) value;
			setFont(new Font(font.getName(), font.getStyle(), s.intValue()));
		}
		else if (attributeConstant.equals(FigureAttributeConstant.FONT_STYLE)) {
			Integer s = (Integer) value;
			int style = font.getStyle();
			if (s.intValue() == Font.PLAIN) {
				style = Font.PLAIN;
			}
			else {
				style = style ^ s.intValue();
			}
			setFont(new Font(font.getName(), style, font.getSize()));
		}
		else if (attributeConstant.equals(FigureAttributeConstant.FONT_NAME)) {
			String n = (String) value;
			setFont(new Font(n, font.getStyle(), font.getSize()));
		}
		else {
			super.setAttribute(attributeConstant, value);
		}
	}

	/**
	 * Gets the text shown by the text figure.
	 * @@see CH.ifa.draw.standard.TextHolder#getText()
	 */
	public String getText() {
		return fText;
	}

	/**
	 * Sets the text shown by the text figure.
	 * @@see CH.ifa.draw.standard.TextHolder#setText(java.lang.String)
	 */
	public void setText(String newText) {
		if (newText == null || !newText.equals(fText)) {
			willChange();
			fText = newText;
			markDirty();
			changed();
		}
	}

	/**
	 * Tests whether the figure accepts typing.
	 * @@see CH.ifa.draw.standard.TextHolder#acceptsTyping()
	 */
	public boolean acceptsTyping() {
		return !fIsReadOnly;
	}

	/**
	 * @@see CH.ifa.draw.figures.AttributeFigure#drawBackground(java.awt.Graphics)
	 */
	public void drawBackground(Graphics g) {
		Rectangle r = displayBox();
		g.fillRect(r.x, r.y, r.width, r.height);
	}

	/**
	 * @@see CH.ifa.draw.figures.AttributeFigure#drawFrame(java.awt.Graphics)
	 */
	public void drawFrame(Graphics g) {
		g.setFont(fFont);
		g.setColor((Color) getAttribute(FigureAttributeConstant.TEXT_COLOR));
		FontMetrics metrics = Toolkit.getDefaultToolkit().getFontMetrics(fFont);
		Rectangle r = displayBox();
		g.drawString(getText(), r.x, r.y + metrics.getAscent());
	}

	protected Dimension textExtent() {
		if (!fSizeIsDirty) {
			return new Dimension(fWidth, fHeight);
		}
		FontMetrics metrics = Toolkit.getDefaultToolkit().getFontMetrics(fFont);
		fWidth = metrics.stringWidth(getText());
		fHeight = metrics.getHeight();
		fSizeIsDirty = false;
		return new Dimension(fWidth, fHeight);
	}

	protected void markDirty() {
		fSizeIsDirty = true;
	}

	/**
	 * Gets the number of columns to be overlaid when the figure is edited.
	 * @@see CH.ifa.draw.standard.TextHolder#overlayColumns()
	 */
	public int overlayColumns() {
		int length = getText().length();
		int columns = 20;
		if (length != 0) {
			columns = getText().length() + 3;
		}
		return columns;
	}

	/**
	 * @@see CH.ifa.draw.framework.Figure#handles()
	 */
	public HandleEnumeration handles() {
		List handles = CollectionsFactory.current().createList();
		handles.add(new NullHandle(this, RelativeLocator.northWest()));
		handles.add(new NullHandle(this, RelativeLocator.northEast()));
		handles.add(new NullHandle(this, RelativeLocator.southEast()));
		handles.add(new FontSizeHandle(this, RelativeLocator.southWest()));
		return new HandleEnumerator(handles);
	}

	/**
	 * @@see CH.ifa.draw.util.Storable#write(CH.ifa.draw.util.StorableOutput)
	 */
	public void write(StorableOutput dw) {
		super.write(dw);
		Rectangle r = displayBox();
		dw.writeInt(r.x);
		dw.writeInt(r.y);
		dw.writeString(getText());
		dw.writeString(fFont.getName());
		dw.writeInt(fFont.getStyle());
		dw.writeInt(fFont.getSize());
		dw.writeBoolean(fIsReadOnly);
		dw.writeStorable(getObservedFigure());
		dw.writeStorable(getLocator());
	}

	/**
	 * @@see CH.ifa.draw.util.Storable#read(CH.ifa.draw.util.StorableInput)
	 */
	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		markDirty();
		basicDisplayBox(new Point(dr.readInt(), dr.readInt()), null);
		setText(dr.readString());
		fFont = new Font(dr.readString(), dr.readInt(), dr.readInt());
		fIsReadOnly = dr.readBoolean();

		setObservedFigure((Figure) dr.readStorable());
		if (getObservedFigure() != null) {
			getObservedFigure().addFigureChangeListener(this);
		}
		setLocator((OffsetLocator) dr.readStorable());
	}

	private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {
		s.defaultReadObject();

		if (getObservedFigure() != null) {
			getObservedFigure().addFigureChangeListener(this);
		}
		markDirty();
	}

	/**
	 * @@see CH.ifa.draw.standard.TextHolder#connect(CH.ifa.draw.framework.Figure)
	 */
	public void connect(Figure figure) {
		if (getObservedFigure() != null) {
			getObservedFigure().removeFigureChangeListener(this);
		}

		setObservedFigure(figure);
		setLocator(new OffsetLocator(getObservedFigure().connectedTextLocator(this)));
		getObservedFigure().addFigureChangeListener(this);
		willChange();
		updateLocation();
		changed();
	}

	/**
	 * @@see CH.ifa.draw.framework.FigureChangeListener#figureChanged(CH.ifa.draw.framework.FigureChangeEvent)
	 */
	public void figureChanged(FigureChangeEvent e) {
		willChange();
		updateLocation();
		changed();
	}

	/**
	 * @@see CH.ifa.draw.framework.FigureChangeListener#figureRemoved(CH.ifa.draw.framework.FigureChangeEvent)
	 */
	public void figureRemoved(FigureChangeEvent e) {
		if (listener() != null) {
			Rectangle rect = invalidateRectangle(displayBox());
			listener().figureRemoved(new FigureChangeEvent(this, rect, e));
		}
	}

	/**
	 * @@see CH.ifa.draw.framework.FigureChangeListener#figureRequestRemove(CH.ifa.draw.framework.FigureChangeEvent)
	 */
	public void figureRequestRemove(FigureChangeEvent e) {
	}

	/**
	 * @@see CH.ifa.draw.framework.FigureChangeListener#figureInvalidated(CH.ifa.draw.framework.FigureChangeEvent)
	 */
	public void figureInvalidated(FigureChangeEvent e) {
	}

	/**
	 * @@see CH.ifa.draw.framework.FigureChangeListener#figureRequestUpdate(CH.ifa.draw.framework.FigureChangeEvent)
	 */
	public void figureRequestUpdate(FigureChangeEvent e) {
	}

	/**
	 * Updates the location relative to the connected figure.
	 * The TextFigure is centered around the located point.
	 */
	protected void updateLocation() {
		if (getLocator() != null) {
			Point p = getLocator().locate(getObservedFigure());

			p.x -= size().width / 2 + fOriginX;
			p.y -= size().height / 2 + fOriginY;
			if (p.x != 0 || p.y != 0) {
				//willChange();
				basicMoveBy(p.x, p.y);
				//changed();
			}
		}
	}

	/**
	 * @@see CH.ifa.draw.framework.Figure#release()
	 */
	public void release() {
		super.release();
		disconnect(getObservedFigure());
	}

	/**
	 * Disconnects a text holder from a connect figure.
	 * @@see CH.ifa.draw.standard.TextHolder#disconnect(CH.ifa.draw.framework.Figure)
	 */
	public void disconnect(Figure disconnectFigure) {
		if (disconnectFigure != null) {
			disconnectFigure.removeFigureChangeListener(this);
		}
		setLocator(null);
		setObservedFigure(null);
	}

	protected void setObservedFigure(Figure newObservedFigure) {
		fObservedFigure = newObservedFigure;
	}

	public Figure getObservedFigure() {
		return fObservedFigure;
	}

	protected void setLocator(OffsetLocator newLocator) {
		fLocator = newLocator;
	}

	protected OffsetLocator getLocator() {
		return fLocator;
	}

	/**
	 * @@see CH.ifa.draw.framework.Figure#getTextHolder()
	 */
	public TextHolder getTextHolder() {
		return this;
	}

	/**
	 * Creates the current font to be used for new text figures.
	 */
	static public Font createCurrentFont() {
		return new Font(fgCurrentFontName, fgCurrentFontStyle, fgCurrentFontSize);
	}

	/**
	 * Sets the current font name
	 */
	static public void setCurrentFontName(String name) {
		fgCurrentFontName = name;
	}

	/**
	 * Sets the current font size.
	 */
	static public void setCurrentFontSize(int size) {
		fgCurrentFontSize = size;
	}

	/**
	 * Sets the current font style.
	 */
	static public void setCurrentFontStyle(int style) {
		fgCurrentFontStyle = style;
	}
}
@


1.18
log
@All test cases now pass!
@
text
@d7 1
a7 1
 * Copyright:	? by the original author(s) and all contributors
d279 1
a279 1
		FontMetrics metrics = g.getFontMetrics(fFont);
@


1.17
log
@no message
@
text
@d7 1
a7 1
 * Copyright:	© by the original author(s) and all contributors
d249 1
a249 1
		if (!newText.equals(fText)) {
@


1.16
log
@Improved handling of events, mainly from "updateLocation()".
@
text
@a13 4
import java.awt.*;
import java.io.IOException;
import java.util.List;

d21 4
d215 2
a216 1
		} else if (attributeConstant.equals(FigureAttributeConstant.FONT_STYLE)) {
d221 2
a222 1
			} else {
d226 2
a227 1
		} else if (attributeConstant.equals(FigureAttributeConstant.FONT_NAME)) {
d230 2
a231 1
		} else {
d359 1
a359 2
	/*private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {
d366 1
a366 1
	}*/
@


1.15
log
@Self-encapsulation of the position through the method "displayBox()".
This provides a better support for subclassing.
@
text
@d14 2
d17 1
a17 2
import java.awt.*;
import java.io.*;
d20 4
a23 1
import CH.ifa.draw.util.*;
d32 3
a34 3
public  class TextFigure
		extends AttributeFigure
		implements FigureChangeListener, TextHolder {
d36 2
a37 2
	private int               fOriginX;
	private int               fOriginY;
d41 2
a42 2
	transient private int     fWidth;
	transient private int     fHeight;
d44 2
a45 2
	private String  fText;
	private Font    fFont;
d48 1
a48 1
	private Figure  fObservedFigure = null;
d51 3
a53 3
	private static String fgCurrentFontName  = "Helvetica";
	private static int    fgCurrentFontSize  = 12;
	private static int    fgCurrentFontStyle = Font.PLAIN;
d161 1
a161 1
		updateLocation();
d213 4
a216 5
			Integer s = (Integer)value;
			setFont(new Font(font.getName(), font.getStyle(), s.intValue()) );
		}
		else if (attributeConstant.equals(FigureAttributeConstant.FONT_STYLE)) {
			Integer s = (Integer)value;
d220 1
a220 2
			}
			else {
d223 5
a227 7
			setFont(new Font(font.getName(), style, font.getSize()) );
		}
		else if (attributeConstant.equals(FigureAttributeConstant.FONT_NAME)) {
			String n = (String)value;
			setFont(new Font(n, font.getStyle(), font.getSize()) );
		}
		else {
d303 1
a303 1
			columns = getText().length()+ 3;
d348 1
a348 1
		setObservedFigure((Figure)dr.readStorable());
d352 1
a352 1
		setLocator((OffsetLocator)dr.readStorable());
d355 2
a356 1
	private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {
d363 1
a363 1
	}
d376 1
d378 1
d385 1
d387 1
d403 2
a404 1
	public void figureRequestRemove(FigureChangeEvent e) {}
d409 2
a410 1
	public void figureInvalidated(FigureChangeEvent e) {}
d415 2
a416 1
	public void figureRequestUpdate(FigureChangeEvent e) {}
d426 2
a427 2
			p.x -= size().width/2 + fOriginX;
			p.y -= size().height/2 + fOriginY;
d429 1
a429 1
				willChange();
d431 1
a431 1
				changed();
@


1.14
log
@Self-encapsulation of the position through the method "displayBox()".
This provides a better support for subclassing.
@
text
@d343 1
a343 2
		fOriginX = dr.readInt();
		fOriginY = dr.readInt();
@


1.13
log
@Self-encapsulation of the attribute "fText".
This provides a better support for subclassing.
@
text
@d276 2
a277 1
		g.drawString(getText(), fOriginX, fOriginY + metrics.getAscent());
d288 1
a288 1
		return new Dimension(metrics.stringWidth(getText()), metrics.getHeight());
d325 3
a327 2
		dw.writeInt(fOriginX);
		dw.writeInt(fOriginY);
@


1.12
log
@Fixed access of static members through class declaration (not instance).
@
text
@d62 1
a62 1
		fText = new String("");
d66 3
d83 3
d91 3
d99 3
d122 1
d135 1
d153 1
d164 1
d174 1
d194 1
d204 1
d234 1
d242 1
d247 1
a247 1
			fText = new String(newText);
d255 1
d261 3
d269 3
d276 1
a276 1
		g.drawString(fText, fOriginX, fOriginY + metrics.getAscent());
d284 1
a284 1
		fWidth = metrics.stringWidth(fText);
d287 1
a287 1
		return new Dimension(metrics.stringWidth(fText), metrics.getHeight());
d296 1
d307 3
d319 3
d326 1
a326 1
		dw.writeString(fText);
d335 3
d343 1
a343 1
		fText = dr.readString();
d363 3
d377 3
d384 3
d394 3
d398 4
d403 4
d427 3
d437 1
d463 3
@


1.11
log
@Removed unused imports and local variables.
@
text
@d197 1
a197 1
				style = font.PLAIN;
@


1.10
log
@merge conflict resolved
@
text
@a13 1
import java.util.*;
@


1.9
log
@Fixed problem with TextArea figures + cascading FigureChangeEvent
@
text
@d70 2
a71 2
		if (fLocator != null) {
			fLocator.moveBy(x, y);
d117 12
d297 2
a298 2
		dw.writeStorable(fObservedFigure);
		dw.writeStorable(fLocator);
d310 3
a312 3
		fObservedFigure = (Figure)dr.readStorable();
		if (fObservedFigure != null) {
			fObservedFigure.addFigureChangeListener(this);
d314 1
a314 1
		fLocator = (OffsetLocator)dr.readStorable();
d320 2
a321 2
		if (fObservedFigure != null) {
			fObservedFigure.addFigureChangeListener(this);
d327 2
a328 2
		if (fObservedFigure != null) {
			fObservedFigure.removeFigureChangeListener(this);
d331 3
a333 3
		fObservedFigure = figure;
		fLocator = new OffsetLocator(figure.connectedTextLocator(this));
		fObservedFigure.addFigureChangeListener(this);
d357 2
a358 2
		if (fLocator != null) {
			Point p = fLocator.locate(fObservedFigure);
d372 1
a372 2
		disconnect(fObservedFigure);
		fObservedFigure = null;
d382 18
a399 1
		fLocator = null;
@


1.9.4.1
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d329 8
@


1.9.4.2
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d351 1
a353 1
		super.release();
@


1.8
log
@introduce FigureVisitor for paste/delete commands
@
text
@d331 2
a332 1
			listener().figureRequestRemove(new FigureChangeEvent(this));
@


1.7
log
@no message
@
text
@a305 1

d373 3
@


1.6
log
@after variou merges... (before 5.4 release)
@
text
@d62 1
a62 1
		setAttribute(FigureAttributeConstant.FILL_COLOR.getName(), ColorMap.color("None"));
@


1.5
log
@no message
@
text
@d15 1
d267 7
a273 7
	public Vector handles() {
		Vector handles = new Vector();
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		handles.addElement(new FontSizeHandle(this, RelativeLocator.southWest()));
		return handles;
@


1.4
log
@merge dnd (before 5.3)
@
text
@d61 1
a61 1
		setAttribute("FillColor", ColorMap.color("None"));
d136 2
d140 8
d149 1
a149 1
		if (name.equals("FontSize")) {
d152 1
a152 1
		if (name.equals("FontStyle")) {
d155 1
a155 1
		if (name.equals("FontName")) {
d158 1
a158 1
		return super.getAttribute(name);
d164 2
d168 8
d177 1
a177 1
		if (name.equals("FontSize")) {
d181 1
a181 1
		else if (name.equals("FontStyle")) {
d192 1
a192 1
		else if (name.equals("FontName")) {
d197 1
a197 1
			super.setAttribute(name, value);
d234 1
a234 1
		g.setColor((Color) getAttribute("TextColor"));
d239 1
a239 1
	private Dimension textExtent() {
d250 1
a250 1
	private void markDirty() {
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d29 2
a30 2
        extends AttributeFigure
        implements FigureChangeListener, TextHolder {
d32 2
a33 2
    private int               fOriginX;
    private int               fOriginY;
d35 301
a335 302
    // cache of the TextFigure's size
    transient private boolean fSizeIsDirty = true;
    transient private int     fWidth;
    transient private int     fHeight;

    private String  fText;
    private Font    fFont;
    private boolean fIsReadOnly;

    private Figure  fObservedFigure = null;
    private OffsetLocator fLocator = null;

    private static String fgCurrentFontName  = "Helvetica";
    private static int    fgCurrentFontSize  = 12;
    private static int    fgCurrentFontStyle = Font.PLAIN;

    /*
     * Serialization support.
     */
    private static final long serialVersionUID = 4599820785949456124L;
    private int textFigureSerializedDataVersion = 1;

    public TextFigure() {
        fOriginX = 0;
        fOriginY = 0;
        fFont = createCurrentFont();
        setAttribute("FillColor", ColorMap.color("None"));
        fText = new String("");
        fSizeIsDirty = true;
    }

    public void moveBy(int x, int y) {
        willChange();
        basicMoveBy(x, y);
        if (fLocator != null) {
            fLocator.moveBy(x, y);
        }
        changed();
    }

    protected void basicMoveBy(int x, int y) {
        fOriginX += x;
        fOriginY += y;
    }

    public void basicDisplayBox(Point newOrigin, Point newCorner) {
        fOriginX = newOrigin.x;
        fOriginY = newOrigin.y;
    }

    public Rectangle displayBox() {
        Dimension extent = textExtent();
        return new Rectangle(fOriginX, fOriginY, extent.width, extent.height);
    }

    public Rectangle textDisplayBox() {
        return displayBox();
    }

    /**
     * Tests whether this figure is read only.
     */
    public boolean readOnly() {
        return fIsReadOnly;
    }

    /**
     * Sets the read only status of the text figure.
     */
    public void setReadOnly(boolean isReadOnly) {
        fIsReadOnly = isReadOnly;
    }

    /**
     * Gets the font.
     */
    public Font getFont() {
        return fFont;
    }

    /**
     * Sets the font.
     */
    public void setFont(Font newFont) {
        willChange();
        fFont = newFont;
        markDirty();
        changed();
    }

    /**
     * Updates the location whenever the figure changes itself.
     */
    public void changed() {
        super.changed();
        updateLocation();
    }

    /**
     * A text figure understands the "FontSize", "FontStyle", and "FontName"
     * attributes.
     */
    public Object getAttribute(String name) {
        Font font = getFont();
        if (name.equals("FontSize")) {
            return new Integer(font.getSize());
        }
        if (name.equals("FontStyle")) {
            return new Integer(font.getStyle());
        }
        if (name.equals("FontName")) {
            return font.getName();
        }
        return super.getAttribute(name);
    }

    /**
     * A text figure understands the "FontSize", "FontStyle", and "FontName"
     * attributes.
     */
    public void setAttribute(String name, Object value) {
        Font font = getFont();
        if (name.equals("FontSize")) {
            Integer s = (Integer)value;
            setFont(new Font(font.getName(), font.getStyle(), s.intValue()) );
        }
        else if (name.equals("FontStyle")) {
            Integer s = (Integer)value;
            int style = font.getStyle();
            if (s.intValue() == Font.PLAIN) {
                style = font.PLAIN;
            }
            else {
                style = style ^ s.intValue();
            }
            setFont(new Font(font.getName(), style, font.getSize()) );
        }
        else if (name.equals("FontName")) {
            String n = (String)value;
            setFont(new Font(n, font.getStyle(), font.getSize()) );
        }
        else {
            super.setAttribute(name, value);
        }
    }

    /**
     * Gets the text shown by the text figure.
     */
    public String getText() {
        return fText;
    }

    /**
     * Sets the text shown by the text figure.
     */
    public void setText(String newText) {
        if (!newText.equals(fText)) {
            willChange();
            fText = new String(newText);
            markDirty();
            changed();
        }
    }

    /**
     * Tests whether the figure accepts typing.
     */
    public boolean acceptsTyping() {
        return !fIsReadOnly;
    }

    public void drawBackground(Graphics g) {
        Rectangle r = displayBox();
        g.fillRect(r.x, r.y, r.width, r.height);
    }

    public void drawFrame(Graphics g) {
        g.setFont(fFont);
        g.setColor((Color) getAttribute("TextColor"));
        FontMetrics metrics = g.getFontMetrics(fFont);
        g.drawString(fText, fOriginX, fOriginY + metrics.getAscent());
    }

    private Dimension textExtent() {
        if (!fSizeIsDirty) {
            return new Dimension(fWidth, fHeight);
        }
        FontMetrics metrics = Toolkit.getDefaultToolkit().getFontMetrics(fFont);
        fWidth = metrics.stringWidth(fText);
        fHeight = metrics.getHeight();
        fSizeIsDirty = false;
        return new Dimension(metrics.stringWidth(fText), metrics.getHeight());
    }

    private void markDirty() {
        fSizeIsDirty = true;
    }

    /**
     * Gets the number of columns to be overlaid when the figure is edited.
     */
    public int overlayColumns() {
        int length = getText().length();
        int columns = 20;
        if (length != 0) {
            columns = getText().length()+ 3;
        }
        return columns;
    }

    public Vector handles() {
        Vector handles = new Vector();
        handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
        handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
        handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
        handles.addElement(new FontSizeHandle(this, RelativeLocator.southWest()));
        return handles;
    }

    public void write(StorableOutput dw) {
        super.write(dw);
        dw.writeInt(fOriginX);
        dw.writeInt(fOriginY);
        dw.writeString(fText);
        dw.writeString(fFont.getName());
        dw.writeInt(fFont.getStyle());
        dw.writeInt(fFont.getSize());
        dw.writeBoolean(fIsReadOnly);
        dw.writeStorable(fObservedFigure);
        dw.writeStorable(fLocator);
    }

    public void read(StorableInput dr) throws IOException {
        super.read(dr);
        markDirty();
        fOriginX = dr.readInt();
        fOriginY = dr.readInt();
        fText = dr.readString();
        fFont = new Font(dr.readString(), dr.readInt(), dr.readInt());
        fIsReadOnly = dr.readBoolean();

        fObservedFigure = (Figure)dr.readStorable();
        if (fObservedFigure != null) {
            fObservedFigure.addFigureChangeListener(this);
        }
        fLocator = (OffsetLocator)dr.readStorable();
    }

    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException {

        s.defaultReadObject();

        if (fObservedFigure != null) {
            fObservedFigure.addFigureChangeListener(this);
        }
        markDirty();
    }

    public void connect(Figure figure) {
        if (fObservedFigure != null) {
            fObservedFigure.removeFigureChangeListener(this);
        }

        fObservedFigure = figure;
        fLocator = new OffsetLocator(figure.connectedTextLocator(this));
        fObservedFigure.addFigureChangeListener(this);
        updateLocation();
    }

    public void figureChanged(FigureChangeEvent e) {
        updateLocation();
    }

    public void figureRemoved(FigureChangeEvent e) {
        if (listener() != null) {
            listener().figureRequestRemove(new FigureChangeEvent(this));
        }
    }

    public void figureRequestRemove(FigureChangeEvent e) {}
    public void figureInvalidated(FigureChangeEvent e) {}
    public void figureRequestUpdate(FigureChangeEvent e) {}

    /**
     * Updates the location relative to the connected figure.
     * The TextFigure is centered around the located point.
     */
    protected void updateLocation() {
        if (fLocator != null) {
            Point p = fLocator.locate(fObservedFigure);

            p.x -= size().width/2 + fOriginX;
            p.y -= size().height/2 + fOriginY;
            if (p.x != 0 || p.y != 0) {
            	willChange();
                basicMoveBy(p.x, p.y);
                changed();
            }
        }
    }
d337 2
a338 2
    public void release() {
        super.release();
d340 2
a341 1
    }
d343 38
a380 39
    /**
     * Disconnects a text holder from a connect figure.
     */
    public void disconnect(Figure disconnectFigure) {
        if (disconnectFigure != null) {
    	    disconnectFigure.removeFigureChangeListener(this);
	        disconnectFigure = null;
        }
        fLocator = null;
    }


    /**
     * Creates the current font to be used for new text figures.
     */
    static public Font createCurrentFont() {
        return new Font(fgCurrentFontName, fgCurrentFontStyle, fgCurrentFontSize);
    }

    /**
     * Sets the current font name
     */
    static public void setCurrentFontName(String name) {
        fgCurrentFontName = name;
    }

    /**
     * Sets the current font size.
     */
    static public void setCurrentFontSize(int size) {
        fgCurrentFontSize = size;
    }

    /**
     * Sets the current font style.
     */
    static public void setCurrentFontStyle(int style) {
        fgCurrentFontStyle = style;
    }
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)TextFigure.java 5.2
d4 6
d25 2
d69 1
a69 1
        if (fLocator != null)
d71 1
d139 1
a139 1
        if (name.equals("FontSize"))
d141 2
a142 1
        if (name.equals("FontStyle"))
d144 2
a145 1
        if (name.equals("FontName"))
d147 1
d164 1
a164 1
            if (s.intValue() == Font.PLAIN)
d166 2
a167 1
            else
d169 1
d176 1
a176 1
        else
d178 1
d220 1
a220 1
        if (!fSizeIsDirty)
d222 1
d240 1
a240 1
        if (length != 0)
d242 1
d278 1
a278 1
        if (fObservedFigure != null)
d280 1
d289 1
a289 1
        if (fObservedFigure != null)
d291 1
d296 1
a296 1
        if (fObservedFigure != null)
d298 1
d311 1
a311 1
        if (listener() != null)
d313 1
d327 1
a329 1

d331 1
a331 1
                willChange();
d340 1
a340 2
        if (fObservedFigure != null)
            fObservedFigure.removeFigureChangeListener(this);
d344 1
a344 1
     * Disconnects the text figure.
d346 5
a350 3
    public void disconnect() {
        fObservedFigure.removeFigureChangeListener(this);
        fObservedFigure = null;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)TextFigure.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
