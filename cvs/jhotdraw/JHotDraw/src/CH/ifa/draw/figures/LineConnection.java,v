head	1.8;
access;
symbols
	jhotdraw54b2-release:1.8
	reorg_6x_split:1.8
	MVC_PHASE1:1.7.0.4
	NEW_ATTRIBUTES:1.7.0.2
	DNOYEB1_ALPHA-2:1.6.4.1
	release_JHD54b1:1.6
	BUGFIX_670992:1.6.0.6
	DNOYEB1_ALPHA-1:1.6
	dnoyeb1:1.6.0.4
	repack:1.6.0.2
	Root_repack:1.6
	Before_FigureVisitor:1.5
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2003.05.20.14.59.47;	author ricardo_padilha;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.04.05.30.12;	author ricardo_padilha;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.22.08.58.23;	author mrfloppy;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.6.4.1
date	2003.01.26.00.50.50;	author dnoyeb;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.02.02.16.54.06;	author dnoyeb;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.02.03.18.12.32;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Bug fix for undo/redo
@
text
@/*
 * @@(#)LineConnection.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.figures;

import java.awt.*;
import java.util.List;
import java.io.*;
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.*;

/**
 * A LineConnection is a standard implementation of the
 * ConnectionFigure interface. The interface is implemented with PolyLineFigure.
 *
 * @@see ConnectionFigure
 *
 * @@version <$CURRENT_VERSION$>
 */
public  class LineConnection extends PolyLineFigure implements ConnectionFigure {

	protected Connector    myStartConnector;
	protected Connector    myEndConnector;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = 6883731614578414801L;
	private int lineConnectionSerializedDataVersion = 1;

	/**
	 * Constructs a LineConnection. A connection figure has
	 * an arrow decoration at the start and end.
	 */
	public LineConnection() {
		super(4);
		setStartDecoration(new ArrowTip());
		setEndDecoration(new ArrowTip());
	}

	/**
	 * Tests whether a figure can be a connection target.
	 * ConnectionFigures cannot be connected and return false.
	 */
	public boolean canConnect() {
		return false;
	}

	/**
	 * Ensures that a connection is updated if the connection
	 * was moved.
	 */
	protected void basicMoveBy(int dx, int dy) {
		// don't move the start and end point since they are connected
		for (int i = 1; i < fPoints.size()-1; i++) {
			pointAt(i).translate(dx, dy);
		}

		updateConnection(); // make sure that we are still connected
	}

	/**
	 * Sets the start figure of the connection.
	 */
	public void connectStart(Connector newStartConnector) {
		setStartConnector(newStartConnector);
		if (newStartConnector != null) {
			startFigure().addDependendFigure(this);
			startFigure().addFigureChangeListener(this);
		}
	}

	/**
	 * Sets the end figure of the connection.
	 */
	public void connectEnd(Connector newEndConnector) {
		setEndConnector(newEndConnector);
		if (newEndConnector != null) {
			endFigure().addDependendFigure(this);
			endFigure().addFigureChangeListener(this);
			handleConnect(startFigure(), endFigure());
		}
	}

	/**
	 * Disconnects the start figure.
	 */
	public void disconnectStart() {
		startFigure().removeFigureChangeListener(this);
		startFigure().removeDependendFigure(this);
		setStartConnector(null);
	}

	/**
	 * Disconnects the end figure.
	 */
	public void disconnectEnd() {
		handleDisconnect(startFigure(), endFigure());
		endFigure().removeFigureChangeListener(this);
		endFigure().removeDependendFigure(this);
		setEndConnector(null);
	}

	/**
	 * Tests whether a connection connects the same figures
	 * as another ConnectionFigure.
	 */
	public boolean connectsSame(ConnectionFigure other) {
		return other.getStartConnector() == getStartConnector()
			&& other.getEndConnector() == getEndConnector();
	}

	/**
	 * Handles the disconnection of a connection.
	 * Override this method to handle this event.
	 */
	protected void handleDisconnect(Figure start, Figure end) {}

	/**
	 * Handles the connection of a connection.
	 * Override this method to handle this event.
	 */
	protected void handleConnect(Figure start, Figure end) {}

	/**
	 * Gets the start figure of the connection.
	 */
	public Figure startFigure() {
		if (getStartConnector() != null) {
			return getStartConnector().owner();
		}
		return null;
	}

	/**
	 * Gets the end figure of the connection.
	 */
	public Figure endFigure() {
		if (getEndConnector() != null) {
			return getEndConnector().owner();
		}
		return null;
	}

	protected void setStartConnector(Connector newStartConnector) {
		myStartConnector = newStartConnector;
	}

	/**
	 * Gets the start figure of the connection.
	 */
	public Connector getStartConnector() {
		return myStartConnector;
	}

	protected void setEndConnector(Connector newEndConnector) {
		myEndConnector = newEndConnector;
	}

	/**
	 * Gets the end figure of the connection.
	 */
	public Connector getEndConnector() {
		return myEndConnector;
	}

	/**
	 * Tests whether two figures can be connected.
	 */
	public boolean canConnect(Figure start, Figure end) {
		return true;
	}

	/**
	 * Sets the start point.
	 */
	public void startPoint(int x, int y) {
		willChange();
		if (fPoints.size() == 0) {
			fPoints.add(new Point(x, y));
		}
		else {
			fPoints.set(0, new Point(x, y));
		}
		changed();
	}

	/**
	 * Sets the end point.
	 */
	public void endPoint(int x, int y) {
		willChange();
		if (fPoints.size() < 2) {
			fPoints.add(new Point(x, y));
		}
		else {
			fPoints.set(fPoints.size()-1, new Point(x, y));
		}
		changed();
	}

	/**
	 * Gets the start point.
	 */
	public Point startPoint() {
		Point p = pointAt(0);
		return new Point(p.x, p.y);
	}

	/**
	 * Gets the end point.
	 */
	public Point endPoint() {
		if (fPoints.size() > 0) {
			Point p = pointAt(fPoints.size()-1);
			return new Point(p.x, p.y);
		}
		else {
			return null;
		}
	}

	/**
	 * Gets the handles of the figure. It returns the normal
	 * PolyLineHandles but adds ChangeConnectionHandles at the
	 * start and end.
	 */
	public HandleEnumeration handles() {
		List handles = CollectionsFactory.current().createList(fPoints.size());
		handles.add(new ChangeConnectionStartHandle(this));
		for (int i = 1; i < fPoints.size()-1; i++) {
			handles.add(new PolyLineHandle(this, locator(i), i));
		}
		handles.add(new ChangeConnectionEndHandle(this));
		return new HandleEnumerator(handles);
	}

	/**
	 * Sets the point and updates the connection.
	 */
	public void setPointAt(Point p, int i) {
		super.setPointAt(p, i);
		layoutConnection();
	}

	/**
	 * Inserts the point and updates the connection.
	 */
	public void insertPointAt(Point p, int i) {
		super.insertPointAt(p, i);
		layoutConnection();
	}

	/**
	 * Removes the point and updates the connection.
	 */
	public void removePointAt(int i) {
		super.removePointAt(i);
		layoutConnection();
	}

	/**
	 * Updates the connection.
	 */
	public void updateConnection() {
		if (getStartConnector() != null) {
			Point start = getStartConnector().findStart(this);

			if (start != null) {
				startPoint(start.x, start.y);
			}
		}
		if (getEndConnector() != null) {
			Point end = getEndConnector().findEnd(this);

			if (end != null) {
				endPoint(end.x, end.y);
			}
		}
	}

	/**
	 * Lays out the connection. This is called when the connection
	 * itself changes. By default the connection is recalculated
	 */
	public void layoutConnection() {
		updateConnection();
	}

	public void figureChanged(FigureChangeEvent e) {
		updateConnection();
	}

	public void figureRemoved(FigureChangeEvent e) {
	}

	public void figureRequestRemove(FigureChangeEvent e) {
	}

	public void figureInvalidated(FigureChangeEvent e) {
	}

	public void figureRequestUpdate(FigureChangeEvent e) {
	}

	public void release() {
		super.release();
		handleDisconnect(startFigure(), endFigure());
		if (getStartConnector() != null) {
			startFigure().removeFigureChangeListener(this);
			startFigure().removeDependendFigure(this);
		}
		if (getEndConnector() != null) {
			endFigure().removeFigureChangeListener(this);
			endFigure().removeDependendFigure(this);
		}
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeStorable(getStartConnector());
		dw.writeStorable(getEndConnector());
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		Connector start = (Connector)dr.readStorable();
		if (start != null) {
			connectStart(start);
		}
		Connector end = (Connector)dr.readStorable();
		if (end != null) {
			connectEnd(end);
		}
		if ((start != null) && (end != null)) {
			updateConnection();
		}
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		if (getStartConnector() != null) {
			connectStart(getStartConnector());
		}
		if (getEndConnector() != null) {
			connectEnd(getEndConnector());
		}
	}

	public void visit(FigureVisitor visitor) {
		visitor.visitFigure(this);
	}

	/**
	 * @@see CH.ifa.draw.framework.Figure#removeFromContainer(CH.ifa.draw.framework.FigureChangeListener)
	 */
	public void removeFromContainer(FigureChangeListener c) {
		super.removeFromContainer(c);
		release();
	}

}
@


1.7
log
@Removed unused imports and local variables.
@
text
@d320 1
d324 1
d365 9
@


1.6
log
@introduce FigureVisitor for paste/delete commands
@
text
@a14 1
import java.util.*;
@


1.6.4.1
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d304 6
@


1.6.4.2
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d311 1
a318 1
		super.release();
@


1.6.4.3
log
@pragmatic fix for [ 679266 ] Dependent figure calling non final methods during loading
it really requires an architecture change in some respects.
@
text
@d337 3
@


1.5
log
@after variou merges... (before 5.4 release)
@
text
@d78 1
d89 1
d100 1
d110 1
a304 3
		if (listener() != null) {
			listener().figureRequestRemove(new FigureChangeEvent(this));
		}
d307 8
a314 3
	public void figureRequestRemove(FigureChangeEvent e) {}
	public void figureInvalidated(FigureChangeEvent e) {}
	public void figureRequestUpdate(FigureChangeEvent e) {}
d359 4
@


1.4
log
@no message
@
text
@d16 1
d66 1
a66 1
			((Point) fPoints.elementAt(i)).translate(dx, dy);
d77 3
a79 1
		startFigure().addFigureChangeListener(this);
d87 4
a90 2
		endFigure().addFigureChangeListener(this);
		handleConnect(startFigure(), endFigure());
d154 1
a154 1
	
d165 1
a165 1
	
d186 1
a186 1
			fPoints.addElement(new Point(x, y));
d189 1
a189 1
			fPoints.setElementAt(new Point(x, y), 0);
d200 1
a200 1
			fPoints.addElement(new Point(x, y));
d203 1
a203 1
			fPoints.setElementAt(new Point(x, y), fPoints.size()-1);
d211 2
a212 2
	public Point startPoint(){
		Point p = (Point)fPoints.firstElement();
d220 7
a226 2
		Point p = (Point)fPoints.lastElement();
		return new Point(p.x, p.y);
d234 3
a236 3
	public Vector handles() {
		Vector handles = new Vector(fPoints.size());
		handles.addElement(new ChangeConnectionStartHandle(this));
d238 1
a238 1
			handles.addElement(new PolyLineHandle(this, locator(i), i));
d240 2
a241 2
		handles.addElement(new ChangeConnectionEndHandle(this));
		return handles;
d275 1
a275 1
			if(start != null) {
d281 2
a282 2
	  
			if(end != null) {
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d327 1
a327 1
		if (start != null && end != null) {
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)LineConnection.java 5.2
d4 6
d24 1
d26 2
d31 2
a32 2
    protected Connector    fStart = null;
    protected Connector    fEnd = null;
d34 310
a343 277
    /*
     * Serialization support.
     */
    private static final long serialVersionUID = 6883731614578414801L;
    private int lineConnectionSerializedDataVersion = 1;

    /**
     * Constructs a LineConnection. A connection figure has
     * an arrow decoration at the start and end.
     */
    public LineConnection() {
        super(4);
        setStartDecoration(new ArrowTip());
        setEndDecoration(new ArrowTip());
    }

    /**
     * Tests whether a figure can be a connection target.
     * ConnectionFigures cannot be connected and return false.
     */
    public boolean canConnect() {
        return false;
    }

    /**
     * Ensures that a connection is updated if the connection
     * was moved.
     */
    protected void basicMoveBy(int dx, int dy) {
        // don't move the start and end point since they are connected
        for (int i = 1; i < fPoints.size()-1; i++)
            ((Point) fPoints.elementAt(i)).translate(dx, dy);

        updateConnection(); // make sure that we are still connected
    }

    /**
     * Sets the start figure of the connection.
     */
    public void connectStart(Connector start) {
        fStart = start;
        startFigure().addFigureChangeListener(this);
    }

    /**
     * Sets the end figure of the connection.
     */
    public void connectEnd(Connector end) {
        fEnd = end;
        endFigure().addFigureChangeListener(this);
        handleConnect(startFigure(), endFigure());
    }

    /**
     * Disconnects the start figure.
     */
    public void disconnectStart() {
        startFigure().removeFigureChangeListener(this);
        fStart = null;
    }

    /**
     * Disconnects the end figure.
     */
    public void disconnectEnd() {
        handleDisconnect(startFigure(), endFigure());
        endFigure().removeFigureChangeListener(this);
        fEnd = null;
    }

    /**
     * Tests whether a connection connects the same figures
     * as another ConnectionFigure.
     */
    public boolean connectsSame(ConnectionFigure other) {
        return other.start() == start() && other.end() == end();
    }

    /**
     * Handles the disconnection of a connection.
     * Override this method to handle this event.
     */
    protected void handleDisconnect(Figure start, Figure end) {}

    /**
     * Handles the connection of a connection.
     * Override this method to handle this event.
     */
    protected void handleConnect(Figure start, Figure end) {}

    /**
     * Gets the start figure of the connection.
     */
    public Figure startFigure() {
        if (start() != null)
            return start().owner();
        return null;
    }

    /**
     * Gets the end figure of the connection.
     */
    public Figure endFigure() {
        if (end() != null)
            return end().owner();
        return null;
    }

    /**
     * Gets the start figure of the connection.
     */
    public Connector start() {
        return fStart;
    }

    /**
     * Gets the end figure of the connection.
     */
    public Connector end() {
        return fEnd;
    }

    /**
     * Tests whether two figures can be connected.
     */
    public boolean canConnect(Figure start, Figure end) {
        return true;
    }

    /**
     * Sets the start point.
     */
    public void startPoint(int x, int y) {
        willChange();
        if (fPoints.size() == 0)
            fPoints.addElement(new Point(x, y));
        else
            fPoints.setElementAt(new Point(x, y), 0);
        changed();
    }

    /**
     * Sets the end point.
     */
    public void endPoint(int x, int y) {
        willChange();
        if (fPoints.size() < 2)
            fPoints.addElement(new Point(x, y));
        else
            fPoints.setElementAt(new Point(x, y), fPoints.size()-1);
        changed();
    }

    /**
     * Gets the start point.
     */
    public Point startPoint(){
        Point p = (Point)fPoints.firstElement();
        return new Point(p.x, p.y);
    }

    /**
     * Gets the end point.
     */
    public Point endPoint() {
        Point p = (Point)fPoints.lastElement();
        return new Point(p.x, p.y);
    }

    /**
     * Gets the handles of the figure. It returns the normal
     * PolyLineHandles but adds ChangeConnectionHandles at the
     * start and end.
     */
    public Vector handles() {
        Vector handles = new Vector(fPoints.size());
        handles.addElement(new ChangeConnectionStartHandle(this));
        for (int i = 1; i < fPoints.size()-1; i++)
            handles.addElement(new PolyLineHandle(this, locator(i), i));
        handles.addElement(new ChangeConnectionEndHandle(this));
        return handles;
    }

    /**
     * Sets the point and updates the connection.
     */
    public void setPointAt(Point p, int i) {
        super.setPointAt(p, i);
        layoutConnection();
    }

    /**
     * Inserts the point and updates the connection.
     */
    public void insertPointAt(Point p, int i) {
        super.insertPointAt(p, i);
        layoutConnection();
    }

    /**
     * Removes the point and updates the connection.
     */
    public void removePointAt(int i) {
        super.removePointAt(i);
        layoutConnection();
    }

    /**
     * Updates the connection.
     */
    public void updateConnection() {
        if (fStart != null) {
            Point start = fStart.findStart(this);
            startPoint(start.x, start.y);
        }
        if (fEnd != null) {
            Point end = fEnd.findEnd(this);
            endPoint(end.x, end.y);
        }
    }

    /**
     * Lays out the connection. This is called when the connection
     * itself changes. By default the connection is recalculated
     */
    public void layoutConnection() {
        updateConnection();
    }

    public void figureChanged(FigureChangeEvent e) {
        updateConnection();
    }

    public void figureRemoved(FigureChangeEvent e) {
        if (listener() != null)
            listener().figureRequestRemove(new FigureChangeEvent(this));
    }

    public void figureRequestRemove(FigureChangeEvent e) {}
    public void figureInvalidated(FigureChangeEvent e) {}
    public void figureRequestUpdate(FigureChangeEvent e) {}

    public void release() {
        super.release();
        handleDisconnect(startFigure(), endFigure());
        if (fStart != null) startFigure().removeFigureChangeListener(this);
        if (fEnd   != null) endFigure().removeFigureChangeListener(this);
    }

    public void write(StorableOutput dw) {
        super.write(dw);
        dw.writeStorable(fStart);
        dw.writeStorable(fEnd);
    }

    public void read(StorableInput dr) throws IOException {
        super.read(dr);
        Connector start = (Connector)dr.readStorable();
        if (start != null)
            connectStart(start);
        Connector end = (Connector)dr.readStorable();
        if (end != null)
            connectEnd(end);
        if (start != null && end != null)
            updateConnection();
    }

    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException {

        s.defaultReadObject();

        if (fStart != null)
            connectStart(fStart);
        if (fEnd != null)
            connectEnd(fEnd);
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)LineConnection.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
