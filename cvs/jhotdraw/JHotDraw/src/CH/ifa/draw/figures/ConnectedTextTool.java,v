head	1.7;
access;
symbols
	jhotdraw54b2-release:1.7
	reorg_6x_split:1.7
	MVC_PHASE1:1.7.0.4
	NEW_ATTRIBUTES:1.7.0.2
	DNOYEB1_ALPHA-2:1.6.4.2
	release_JHD54b1:1.7
	BUGFIX_670992:1.6.0.6
	DNOYEB1_ALPHA-1:1.6.4.2
	dnoyeb1:1.6.0.4
	repack:1.6.0.2
	Root_repack:1.6
	Before_FigureVisitor:1.5
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2003.01.30.00.27.32;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.22.08.58.23;	author mrfloppy;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.6.4.1
date	2003.01.10.04.54.38;	author dnoyeb;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.01.16.14.18.23;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.7
log
@prepare for 5.4 release: various bug fixes
@
text
@/*
 * @@(#)ConnectedTextTool.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.figures;

import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.Undoable;
import java.awt.event.MouseEvent;

/**
 * Tool to create new or edit existing text figures.
 * A new text figure is connected with the clicked figure.
 *
 * @@see CH.ifa.draw.standard.TextHolder
 *
 * @@version <$CURRENT_VERSION$>
 */
public  class ConnectedTextTool extends TextTool {

	private Figure myConnectedFigure;

	public ConnectedTextTool(DrawingEditor editor, Figure prototype) {
		super(editor, prototype);
	}

	/**
	 * If the pressed figure is a TextHolder it can be edited otherwise
	 * a new text figure is created.
	 */
	public void mouseDown(MouseEvent e, int x, int y) {
		super.mouseDown(e, x, y);

		if (getTypingTarget() != null) {
			TextHolder textHolder = getTypingTarget();
			setConnectedFigure(drawing().findFigureInsideWithout(x, y, textHolder.getRepresentingFigure()));
			if ((getConnectedFigure() != null) && (textHolder != null) && (getConnectedFigure().getTextHolder() != textHolder)) {
				textHolder.connect(getConnectedFigure().getDecoratedFigure());
				getConnectedFigure().addDependendFigure(getAddedFigure());
			}
		}
	}

	protected void endEdit() {
		super.endEdit();
		if ((getUndoActivity() != null) && (getUndoActivity() instanceof ConnectedTextTool.UndoActivity)) {
			((ConnectedTextTool.UndoActivity)getUndoActivity()).setConnectedFigure(getConnectedFigure());
		}
		else if ((getConnectedFigure() != null) && isDeleteTextFigure()) {
			getConnectedFigure().removeDependendFigure(getAddedFigure());
		}
	}

	protected void setConnectedFigure(Figure pressedFigure) {
		myConnectedFigure = pressedFigure;
	}

	public Figure getConnectedFigure() {
		return myConnectedFigure;
	}

	/**
	 * If the pressed figure is a TextHolder it can be edited otherwise
	 * a new text figure is created.
	 */
	public void activate() {
		super.activate();
		setConnectedFigure(null);
	}

	protected Undoable createDeleteUndoActivity() {
		FigureTransferCommand cmd = new DeleteCommand("Delete", editor());
		return new DeleteUndoActivity(cmd, getConnectedFigure());
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new ConnectedTextTool.UndoActivity(view(), getTypingTarget().getText());
	}

	public static class UndoActivity extends TextTool.UndoActivity {
		private Figure myConnectedFigure;

		public UndoActivity(DrawingView newDrawingView, String newOriginalText) {
			super(newDrawingView, newOriginalText);
		}

		/*
		 * Undo the activity
		 * @@return true if the activity could be undone, false otherwise
		 */
		public boolean undo() {
			if (!super.undo()) {
				return false;
			}

			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				Figure currentFigure = fe.nextFigure();

				if (currentFigure.getTextHolder() != null) {
					// the text figure didn't exist before
					if (!isValidText(getOriginalText())) {
						currentFigure.getTextHolder().disconnect(getConnectedFigure());
					}
					// the text figure did exist but was remove
					else if (!isValidText(getBackupText())) {
						currentFigure.getTextHolder().connect(getConnectedFigure());
					}
				}
			}

			return true;
		}

		/*
		 * Redo the activity
		 * @@return true if the activity could be redone, false otherwise
		 */
		public boolean redo() {
			if (!super.redo()) {
				return false;
			}

			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				Figure currentFigure = fe.nextFigure();
				if (currentFigure.getTextHolder() != null) {
					// the text figure did exist but was remove
					if (!isValidText(getBackupText())) {
						currentFigure.getTextHolder().disconnect(getConnectedFigure());
					}
					// the text figure didn't exist before
					else if (!isValidText(getOriginalText())) {
						currentFigure.getTextHolder().connect(getConnectedFigure());
					}
				}
			}

			return true;
		}

		public void setConnectedFigure(Figure newConnectedFigure) {
			myConnectedFigure = newConnectedFigure;
		}

		public Figure getConnectedFigure() {
			return myConnectedFigure;
		}
	}

	/**
	 * This class
	 */
	public static class DeleteUndoActivity extends DeleteCommand.UndoActivity {
		private Figure myConnectedFigure;

		public DeleteUndoActivity(FigureTransferCommand cmd, Figure newConnectedFigure) {
			super(cmd);
			setConnectedFigure(newConnectedFigure);
		}

		public boolean undo() {
			if (!super.undo()) {
				return false;
			}

			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				Figure currentFigure = fe.nextFigure();
				if (currentFigure.getTextHolder() != null) {
					currentFigure.getTextHolder().connect(getConnectedFigure().getDecoratedFigure());
				}
			}

			return true;
		}

		public boolean redo() {
			if (!super.redo()) {
				return false;
			}

			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				Figure currentFigure = fe.nextFigure();
				if (currentFigure.getTextHolder() != null) {
					currentFigure.getTextHolder().disconnect(getConnectedFigure().getDecoratedFigure());
				}
			}

			return true;
		}

		public void setConnectedFigure(Figure newConnectedFigure) {
			myConnectedFigure = newConnectedFigure;
		}

		public Figure getConnectedFigure() {
			return myConnectedFigure;
		}
	}
}
@


1.6
log
@introduce FigureVisitor for paste/delete commands
@
text
@a28 1
	private boolean fConnected = false;
d42 7
a48 6
		setConnectedFigure(drawing().findFigureInside(x, y));
		TextHolder textHolder = getTypingTarget();
		if (!fConnected && (getConnectedFigure() != null) && (textHolder != null) && (getConnectedFigure() != textHolder)) {
			textHolder.connect(getConnectedFigure());
			getConnectedFigure().addDependendFigure(getAddedFigure());
			fConnected = true;
d54 1
a54 1
		if (getUndoActivity() != null) {
d57 1
a57 1
		else {
d76 6
a81 1
		fConnected = false;
d147 52
@


1.6.4.1
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d17 1
a17 1

d40 2
a41 2
	public void mouseDown(DrawingViewMouseEvent dvme) {
		super.mouseDown(dvme);
d43 1
a43 1
		setConnectedFigure(drawing().findFigureInside(getAnchorX(), getAnchorY()));
@


1.6.4.2
log
@Fix error introduced in 1.6.4.1.  Uses correct x and y positions now.
@
text
@d43 1
a43 1
		setConnectedFigure(drawing().findFigureInside(dvme.getX(), dvme.getY()));
@


1.5
log
@after variou merges... (before 5.4 release)
@
text
@d30 1
d43 1
a43 1
		Figure pressedFigure =  drawing().findFigureInside(x, y);
d45 3
a47 4
		if (!fConnected && pressedFigure != null &&
					 textHolder != null && pressedFigure != textHolder) {
			textHolder.connect(pressedFigure);
			((ConnectedTextTool.UndoActivity)getUndoActivity()).setConnectedFigure(pressedFigure);
d52 18
d88 1
a88 1
		
d105 2
a106 2
				if (currentFigure instanceof TextHolder) {
					TextHolder currentTextHolder = (TextHolder)currentFigure;
d109 1
a109 1
						currentTextHolder.disconnect(getConnectedFigure());
d113 1
a113 1
						currentTextHolder.connect(getConnectedFigure());
d117 1
a117 1
			
d133 1
a133 2
				if (currentFigure instanceof TextHolder) {
					TextHolder currentTextHolder = (TextHolder)currentFigure;
d136 1
a136 1
						currentTextHolder.disconnect(getConnectedFigure());
d140 1
a140 1
						currentTextHolder.connect(getConnectedFigure());
d147 1
a147 1
		
d151 1
a151 1
		
@


1.4
log
@merge dnd (before 5.3)
@
text
@a15 1
import CH.ifa.draw.util.UndoableAdapter;
d85 1
a85 1
			while (fe.hasMoreElements()) {
d113 1
a113 1
			while (fe.hasMoreElements()) {
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d30 1
a30 1
    private boolean fConnected = false;
d32 29
a60 29
    public ConnectedTextTool(DrawingView view, Figure prototype) {
        super(view, prototype);
    }

    /**
     * If the pressed figure is a TextHolder it can be edited otherwise
     * a new text figure is created.
     */
    public void mouseDown(MouseEvent e, int x, int y) {
        super.mouseDown(e, x, y);

	    Figure pressedFigure =  drawing().findFigureInside(x, y);
	    TextHolder textHolder = getTypingTarget();
System.out.println("pressedFigure: " + pressedFigure);
System.out.println("textHolder: " + textHolder);
        if (!fConnected && pressedFigure != null &&
                     textHolder != null && pressedFigure != textHolder) {
            textHolder.connect(pressedFigure);
            ((ConnectedTextTool.UndoActivity)getUndoActivity()).setConnectedFigure(pressedFigure);
            fConnected = true;
        }
    }

    /**
     * Activate this tool
     */
    public void activate() {
        fConnected = false;
    }
d69 6
a74 6
    public static class UndoActivity extends TextTool.UndoActivity {
    	private Figure myConnectedFigure;
    	
    	public UndoActivity(DrawingView newDrawingView, String newOriginalText) {
    		super(newDrawingView, newOriginalText);
    	}
d80 1
a80 1
    	public boolean undo() {
d82 1
a82 1
	        	return false;
d108 1
a108 1
    	public boolean redo() {
d110 1
a110 1
	        	return false;
d139 1
a139 1
    }
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)ConnectedTextTool.java 5.2
d4 6
a13 2
import java.awt.*;
import java.awt.event.MouseEvent;
d16 3
d25 2
d30 1
a30 1
    boolean     fConnected = false;
d45 2
d50 1
d56 1
a56 2
     * If the pressed figure is a TextHolder it can be edited otherwise
     * a new text figure is created.
d61 79
a140 1

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)ConnectedTextTool.java 5.1
d17 1
a17 1
 * @@see TextHolder
d35 1
a35 2

	    TextHolder textHolder = (TextHolder)createdFigure();
@


1.1.1.1
log
@
Initial revision.
@
text
@@
