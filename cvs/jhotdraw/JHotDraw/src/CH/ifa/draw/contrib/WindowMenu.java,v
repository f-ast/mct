head	1.5;
access;
symbols
	jhotdraw54b2-release:1.5
	reorg_6x_split:1.5
	MVC_PHASE1:1.3.0.10
	NEW_ATTRIBUTES:1.3.0.8
	DNOYEB1_ALPHA-2:1.3
	release_JHD54b1:1.3
	BUGFIX_670992:1.3.0.6
	DNOYEB1_ALPHA-1:1.3
	dnoyeb1:1.3.0.4
	repack:1.3.0.2
	Root_repack:1.3
	Before_FigureVisitor:1.3
	JHotDraw_5-3:1.2;
locks; strict;
comment	@# @;


1.5
date	2003.11.09.21.18.45;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.13.22.31.11;	author mtnygard;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.24.20.37.14;	author mrfloppy;	state Exp;
branches;
next	;

1.3.2.1
date	2002.12.17.20.28.54;	author birdscurrybeer;	state Exp;
branches;
next	;


desc
@@


1.5
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 * @@(#)WindowMenu.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.contrib;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyVetoException;

import javax.swing.JCheckBoxMenuItem;
import javax.swing.JInternalFrame;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;

import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.standard.AbstractCommand;
import CH.ifa.draw.util.Command;
import CH.ifa.draw.util.CommandMenu;

/**
 * Menu component that handles the functionality expected of a standard
 * "Windows" menu for MDI applications.
 *
 * @@author Wolfram Kaiser (adapted from an article in JavaWorld)
 * @@version <$CURRENT_VERSION$>
 */
public class WindowMenu extends CommandMenu {
	private MDIDesktopPane desktop;
	private Command cascadeCommand;
	private Command tileCommand;

	public WindowMenu(String newText, MDIDesktopPane newDesktop, DrawingEditor newEditor) {
		super(newText);
		this.desktop = newDesktop;
		cascadeCommand = new AbstractCommand("Cascade", newEditor) {
			public void execute() {
				WindowMenu.this.desktop.cascadeFrames();
			}
			public boolean isExecutable() {
				return super.isExecutable() && (WindowMenu.this.desktop.getAllFrames().length > 0);
			}
		};
		tileCommand = new AbstractCommand("Tile", newEditor) {
			public void execute() {
				WindowMenu.this.desktop.tileFramesHorizontally();
			}
			public boolean isExecutable() {
				return super.isExecutable() && (WindowMenu.this.desktop.getAllFrames().length > 0);
			}
		};
		addMenuListener(new MenuListener() {
			public void menuCanceled (MenuEvent e) {}

			public void menuDeselected (MenuEvent e) {
				removeAll();
			}

			public void menuSelected (MenuEvent e) {
				buildChildMenus();
			}
		});
	}

	/* Sets up the children menus depending on the current desktop state */
	private void buildChildMenus() {
		ChildMenuItem menu;
		JInternalFrame[] array = desktop.getAllFrames();

		add(new CommandMenuItem(cascadeCommand));
		add(new CommandMenuItem(tileCommand));
		if (array.length > 0) {
			addSeparator();
		}
//		cascade.setEnabled(array.length > 0);
//		tile.setEnabled(array.length > 0);

		for (int i = 0; i < array.length; i++) {
			menu = new ChildMenuItem(array[i]);
			menu.setState(i == 0);
			menu.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent ae) {
					JInternalFrame frame = ((ChildMenuItem)ae.getSource()).getFrame();
					frame.moveToFront();
					try {
						frame.setSelected(true);
					}
					catch (PropertyVetoException e) {
						e.printStackTrace();
					}
				}
			});
			menu.setIcon(array[i].getFrameIcon());
			add(menu);
		}
	}

	/* This JCheckBoxMenuItem descendant is used to track the child frame that corresponds
	   to a give menu. */
	class ChildMenuItem extends JCheckBoxMenuItem {
		private JInternalFrame frame;

		public ChildMenuItem(JInternalFrame newFrame) {
			super(newFrame.getTitle());
			frame=newFrame;
		}

		public JInternalFrame getFrame() {
			return frame;
		}
	}
}@


1.4
log
@Eliminate some deprecated method warnings.
Organize imports to remove Eclipse warnings about unused imports.
@
text
@d110 3
a112 3
		public ChildMenuItem(JInternalFrame frame) {
			super(frame.getTitle());
			this.frame=frame;
@


1.3
log
@after variou merges... (before 5.4 release)
@
text
@d14 12
a26 7
import CH.ifa.draw.util.Command;
import CH.ifa.draw.standard.AbstractCommand;
import CH.ifa.draw.framework.DrawingEditor;
import javax.swing.*;
import javax.swing.event.*;
import java.awt.event.*;
import java.beans.*;
d53 1
a53 1
				WindowMenu.this.desktop.tileFrames();
@


1.3.2.1
log
@Replaced tile with new tileHorizontally and tileVertically
@
text
@d33 2
a34 3
	private Command tileHorizontallyCommand;
	private Command tileVerticallyCommand;
	
d46 1
a46 9
		tileHorizontallyCommand = new AbstractCommand("Tile Horizontally", newEditor) {
			public void execute() {
				WindowMenu.this.desktop.tileFramesHorizontally();
			}
			public boolean isExecutable() {
				return super.isExecutable() && (WindowMenu.this.desktop.getAllFrames().length > 0);
			}
		};
		tileVerticallyCommand = new AbstractCommand("Tile Vertically", newEditor) {
d48 1
a48 1
				WindowMenu.this.desktop.tileFramesHorizontally();
d73 1
a73 2
		add(new CommandMenuItem(tileHorizontallyCommand));
		add(new CommandMenuItem(tileVerticallyCommand));
@


1.2
log
@merge dnd (before 5.3)
@
text
@d35 1
a35 1
	public WindowMenu(String newText, MDIDesktopPane desktop, DrawingEditor editor) {
d37 2
a38 2
		this.desktop=desktop;
		cascadeCommand = new AbstractCommand("Cascade", editor) {
d46 1
a46 1
		tileCommand = new AbstractCommand("Tile", editor) {
d72 2
a73 2
		add(cascadeCommand);
		add(tileCommand);
@


1.1
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d14 4
d30 84
a113 76
public class WindowMenu extends JMenu {
    private MDIDesktopPane desktop;
    private JMenuItem cascade=new JMenuItem("Cascade");
    private JMenuItem tile=new JMenuItem("Tile");

    public WindowMenu(String newText, MDIDesktopPane desktop) {
        this.desktop=desktop;
        setText(newText);
        cascade.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ae) {
                WindowMenu.this.desktop.cascadeFrames();
            }
        });
        tile.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ae) {
                WindowMenu.this.desktop.tileFrames();
            }
        });
        addMenuListener(new MenuListener() {
            public void menuCanceled (MenuEvent e) {}

            public void menuDeselected (MenuEvent e) {
                removeAll();
            }

            public void menuSelected (MenuEvent e) {
                buildChildMenus();
            }
        });
    }

    /* Sets up the children menus depending on the current desktop state */
    private void buildChildMenus() {
        int i;
        ChildMenuItem menu;
        JInternalFrame[] array = desktop.getAllFrames();

        add(cascade);
        add(tile);
        if (array.length > 0) addSeparator();
        cascade.setEnabled(array.length > 0);
        tile.setEnabled(array.length > 0);

        for (i = 0; i < array.length; i++) {
            menu = new ChildMenuItem(array[i]);
            menu.setState(i == 0);
            menu.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent ae) {
                    JInternalFrame frame = ((ChildMenuItem)ae.getSource()).getFrame();
                    frame.moveToFront();
                    try {
                        frame.setSelected(true);
                    } catch (PropertyVetoException e) {
                        e.printStackTrace();
                    }
                }
            });
            menu.setIcon(array[i].getFrameIcon());
            add(menu);
        }
    }

    /* This JCheckBoxMenuItem descendant is used to track the child frame that corresponds
       to a give menu. */
    class ChildMenuItem extends JCheckBoxMenuItem {
        private JInternalFrame frame;

        public ChildMenuItem(JInternalFrame frame) {
            super(frame.getTitle());
            this.frame=frame;
        }

        public JInternalFrame getFrame() {
            return frame;
        }
    }
@

