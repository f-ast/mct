head	1.6;
access;
symbols
	jhotdraw54b2-release:1.6
	reorg_6x_split:1.6
	MVC_PHASE1:1.6.0.10
	NEW_ATTRIBUTES:1.6.0.8
	DNOYEB1_ALPHA-2:1.6
	release_JHD54b1:1.6
	BUGFIX_670992:1.6.0.6
	DNOYEB1_ALPHA-1:1.6
	dnoyeb1:1.6.0.4
	repack:1.6.0.2
	Root_repack:1.6
	Before_FigureVisitor:1.6
	JHotDraw_5-3:1.5
	JHotDraw_5-2_merged:1.1;
locks; strict;
comment	@# @;


1.6
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.44.32;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.25.12;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.29.13.42.13;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	;


desc
@@


1.6
log
@after variou merges... (before 5.4 release)
@
text
@/*
 * @@(#)CustomToolBar.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.contrib;

import CH.ifa.draw.util.CollectionsFactory;

import javax.swing.JToolBar;
import javax.swing.JComponent;
import java.util.List;
import java.util.Iterator;
import java.awt.Component;

/**
 * This ToolBar allows to use several panels with tools. It manages each
 * panel and enables to swap between them. There can only one panel with
 * tools be activated at a time. Currently, only two panels are supported
 * (standard tools and edit tools).
 *
 * @@author  Wolfram Kaiser <mrfloppy@@sourceforge.net>
 * @@version <$CURRENT_VERSION$>
 */
public class CustomToolBar extends JToolBar {

	/**
	 * List containing all tools for the standard ToolBar
	 */
	private List standardTools;
	
	/**
	 * List containing all tools for the edit ToolBar
	 */
	private List editTools;
	
	/**
	 * List containing all tools, which are currently activated
	 */
	private List currentTools;
	
	/**
	 * Flag which determines whether the tool palette must be updated
	 */
	private boolean needsUpdate;
	
	/**
	 * Create a new ToolBar
	 */
	public CustomToolBar() {
		super();
		standardTools = CollectionsFactory.current().createList();
		editTools = CollectionsFactory.current().createList();
		currentTools = standardTools;
		needsUpdate = false;
	}

	/**
	 * Switch between the two available palettes with tools
	 */
	public void switchToolBar() {
		if (currentTools == standardTools) {
			switchToEditTools();
		}
		else {
			switchToStandardTools();
		}
	}
	
	/**
	 * Select the palette with the edit tools
	 */
	public void switchToEditTools() {
		if (currentTools != editTools) {
			currentTools = editTools;
			needsUpdate = true;
		}
	}

	/**
	 * Select the palette with the standard tools
	 */
	public void switchToStandardTools() {
		if (currentTools != standardTools) {
			currentTools = standardTools;
			needsUpdate = true;
		}
	}

	/**
	 * Activate a palette of the ToolBar by setting all Tools
	 */
	public void activateTools() {
		if (!needsUpdate) {
			return;
		}
		else {
			removeAll();

			JComponent currentTool = null;
			Iterator iter = currentTools.iterator();
			while (iter.hasNext()) {
				currentTool = (JComponent)iter.next();
				super.add(currentTool);
			}
			validate();
			needsUpdate = false;
		}
	}

	/**
	 * Add a new tool the the current palette of the ToolBar
	 */
	public Component add(Component newTool) {
		if (currentTools == editTools) {
			editTools.add(newTool);
		}
		else {
			standardTools.add(newTool);
		}
		needsUpdate = true;
		return super.add(newTool);
	}
}@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@d14 2
a15 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.figures.*;
import CH.ifa.draw.util.*;
d18 3
a20 3
import java.awt.*;
import java.awt.event.*;
import java.util.*;
d28 1
a28 1
 * @@author  Wolfram Kaiser
d34 1
a34 1
	 * Vector containing all tools for the standard ToolBar
d36 1
a36 1
	private Vector standardTools;
d39 1
a39 1
	 * Vector containing all tools for the edit ToolBar
d41 1
a41 1
	private Vector editTools;
d44 1
a44 1
	 * Vector containing all tools, which are currently activated
d46 1
a46 1
	private Vector currentTools;
d58 2
a59 2
		standardTools = new Vector();
		editTools = new Vector();
d107 3
a109 3
			Enumeration enum = currentTools.elements();
			while (enum.hasMoreElements()) {
				currentTool = (JComponent)enum.nextElement();
d122 1
a122 1
			editTools.addElement(newTool);
d125 1
a125 1
			standardTools.addElement(newTool);
@


1.4
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d1 11
d14 4
a22 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.figures.*;
import CH.ifa.draw.util.*;
d31 1
a31 1
 * @@version JHotDraw 5.2    31.08.1999
d38 27
a64 27
    private Vector standardTools;
    
    /**
     * Vector containing all tools for the edit ToolBar
     */
    private Vector editTools;
    
    /**
     * Vector containing all tools, which are currently activated
     */
    private Vector currentTools;
    
    /**
     * Flag which determines whether the tool palette must be updated
     */
    private boolean needsUpdate;
    
    /**
     * Create a new ToolBar
     */
    public CustomToolBar() {
        super();
        standardTools = new Vector();
        editTools = new Vector();
        currentTools = standardTools;
        needsUpdate = false;
    }
d69 63
a131 63
    public void switchToolBar() {
        if (currentTools == standardTools) {
            switchToEditTools();
        }
        else {
            switchToStandardTools();
        }
    }
    
    /**
     * Select the palette with the edit tools
     */
    public void switchToEditTools() {
        if (currentTools != editTools) {
            currentTools = editTools;
            needsUpdate = true;
        }
    }

    /**
     * Select the palette with the standard tools
     */
    public void switchToStandardTools() {
        if (currentTools != standardTools) {
            currentTools = standardTools;
            needsUpdate = true;
        }
    }

    /**
     * Activate a palette of the ToolBar by setting all Tools
     */
    public void activateTools() {
        if (!needsUpdate) {
            return;
        }
        else {
            removeAll();

            JComponent currentTool = null;
            Enumeration enum = currentTools.elements();
            while (enum.hasMoreElements()) {
                currentTool = (JComponent)enum.nextElement();
                super.add(currentTool);
            }
            validate();
            needsUpdate = false;
        }
    }

    /**
     * Add a new tool the the current palette of the ToolBar
     */
    public Component add(Component newTool) {
        if (currentTools == editTools) {
            editTools.addElement(newTool);
        }
        else {
            standardTools.addElement(newTool);
        }
        needsUpdate = true;
        return super.add(newTool);
    }
@


1.3
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d3 2
a4 1
import javax.swing.*;
@


1.2
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d3 1
a3 2
import javax.swing.JToolBar;
import javax.swing.JComponent;
@


1.1
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d3 2
a4 1
import javax.swing.*;
@

