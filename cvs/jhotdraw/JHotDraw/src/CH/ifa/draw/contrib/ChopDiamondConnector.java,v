head	1.3;
access;
symbols
	jhotdraw54b2-release:1.3
	reorg_6x_split:1.3
	MVC_PHASE1:1.3.0.10
	NEW_ATTRIBUTES:1.3.0.8
	DNOYEB1_ALPHA-2:1.3
	release_JHD54b1:1.3
	BUGFIX_670992:1.3.0.6
	DNOYEB1_ALPHA-1:1.3
	dnoyeb1:1.3.0.4
	repack:1.3.0.2
	Root_repack:1.3
	Before_FigureVisitor:1.3
	JHotDraw_5-3:1.2;
locks; strict;
comment	@# @;


1.3
date	2002.09.07.12.27.27;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.24.20.44.32;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.24.20.37.14;	author mrfloppy;	state Exp;
branches;
next	;


desc
@@


1.3
log
@removed remains of FigureAttributeConstant.getName() and some code-clean up
@
text
@/*
 * @@(#)ChopDiamondConnector.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.contrib;

import java.awt.*;
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.ChopBoxConnector;
import CH.ifa.draw.util.Geom;

/**
 * A ChopDiamondConnector locates connection points by choping the
 * connection between the centers of the two figures at the edge of
 * a diamond figure.
 *
 * @@see Connector
 *
 * @@author Erich Gamma
 * @@version <$CURRENT_VERSION$>
 */
public class ChopDiamondConnector extends ChopBoxConnector {
	/**
	 * Serialization support.
	 * Needs to be fixed.
	 */
	private static final long serialVersionUID = -1461450322512395462L;

	public ChopDiamondConnector() {
		// only used for Storable implementation
	}

  public ChopDiamondConnector(Figure owner) {
	  super(owner);
	}

	/**
	 * Return an appropriate connection point on the edge of a diamond figure
	 */
	protected Point chop(Figure target, Point from) {
		Rectangle r = target.displayBox();
		// Center point
		Point c1 = new Point(r.x + r.width/2, r.y + (r.height/2));
		Point p2 = new Point(r.x + r.width/2, r.y + r.height);
		Point p4 = new Point(r.x + r.width/2, r.y);

		// If overlapping, just return the opposite corners
		if (r.contains(from)) {
			if (from.y > r.y && from.y < (r.y +r.height/2)) {
				return p2;
			}
			else {
				return p4;
			}
		}

		// Calculate angle to determine quadrant
		double ang = Geom.pointToAngle(r, from);

		// Dermine line points
		Point p1 = new Point(r.x + r.width  , r.y + (r.height/2));
		Point p3 = new Point(r.x            , r.y + (r.height/2));
		Point rp = null; // This will be returned

		// Get the intersection with edges
		if (ang > 0 && ang < 1.57) {
			rp = Geom.intersect(p1.x, p1.y, p2.x, p2.y, c1.x, c1.y, from.x, from.y);
		}
		else if (ang > 1.575 && ang < 3.14) {
			rp = Geom.intersect(p2.x, p2.y, p3.x, p3.y, c1.x, c1.y, from.x, from.y);
		}
		else if (ang > -3.14 && ang < -1.575) {
		  rp = Geom.intersect(p3.x, p3.y, p4.x, p4.y, c1.x, c1.y, from.x, from.y);
		}
		else if (ang > -1.57 && ang < 0) {
			rp = Geom.intersect(p4.x, p4.y, p1.x, p1.y, c1.x, c1.y, from.x, from.y);
		}

		// No proper edge found, we should send one of four corners
		if (rp == null) {
			rp = Geom.angleToPoint(r, ang);
		}

		return rp;
	}
}
@


1.2
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@d63 1
a63 1
	
d66 1
a66 1
	
d71 1
a71 1
	
d82 1
a82 1
		else if(ang > -1.57 && ang < 0) {
d85 1
a85 1
	
d90 1
a90 1
	
@


1.1
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d2 8
a9 1
 * @@(#)ChopDiamondConnector.java 1.0
d23 1
d25 3
d30 9
a38 9
    /**
     * Serialization support.
     * Needs to be fixed.
     */
    private static final long serialVersionUID = -1461450322512395462L;

    public ChopDiamondConnector() {
        // only used for Storable implementation
    }
d41 2
a42 2
      super(owner);
    }
d44 49
a92 49
    /**
     * Return an appropriate connection point on the edge of a diamond figure
     */
    protected Point chop(Figure target, Point from) {
        Rectangle r = target.displayBox();
        // Center point
        Point c1 = new Point(r.x + r.width/2, r.y + (r.height/2));
        Point p2 = new Point(r.x + r.width/2, r.y + r.height);
        Point p4 = new Point(r.x + r.width/2, r.y);

        // If overlapping, just return the opposite corners
        if (r.contains(from)) {
            if (from.y > r.y && from.y < (r.y +r.height/2)) {
                return p2;
            }
            else {
                return p4;
            }
        }
    
        // Calculate angle to determine quadrant
        double ang = Geom.pointToAngle(r, from);
    
        // Dermine line points
        Point p1 = new Point(r.x + r.width  , r.y + (r.height/2));
        Point p3 = new Point(r.x            , r.y + (r.height/2));
        Point rp = null; // This will be returned
    
        // Get the intersection with edges
        if (ang > 0 && ang < 1.57) {
            rp = Geom.intersect(p1.x, p1.y, p2.x, p2.y, c1.x, c1.y, from.x, from.y);
        }
        else if (ang > 1.575 && ang < 3.14) {
            rp = Geom.intersect(p2.x, p2.y, p3.x, p3.y, c1.x, c1.y, from.x, from.y);
        }
        else if (ang > -3.14 && ang < -1.575) {
          rp = Geom.intersect(p3.x, p3.y, p4.x, p4.y, c1.x, c1.y, from.x, from.y);
        }
        else if(ang > -1.57 && ang < 0) {
            rp = Geom.intersect(p4.x, p4.y, p1.x, p1.y, c1.x, c1.y, from.x, from.y);
        }
    
        // No proper edge found, we should send one of four corners
        if (rp == null) {
            rp = Geom.angleToPoint(r, ang);
        }
    
        return rp;
    }
@

