head	1.7;
access;
symbols
	jhotdraw54b2-release:1.7
	reorg_6x_split:1.7
	MVC_PHASE1:1.6.0.4
	NEW_ATTRIBUTES:1.6.0.2
	DNOYEB1_ALPHA-2:1.5.4.6
	release_JHD54b1:1.6
	BUGFIX_670992:1.5.0.6
	DNOYEB1_ALPHA-1:1.5.4.6
	dnoyeb1:1.5.0.4
	repack:1.5.0.2
	Root_repack:1.5
	Before_FigureVisitor:1.3;
locks; strict;
comment	@# @;


1.7
date	2003.11.09.21.18.45;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.30.00.27.33;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.23.07.47.26;	author mrfloppy;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.09.22.08.58.23;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	;

1.5.4.1
date	2003.01.10.04.54.38;	author dnoyeb;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.01.14.18.21.04;	author dnoyeb;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.01.15.21.04.10;	author dnoyeb;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.01.16.15.58.49;	author dnoyeb;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.01.20.18.23.26;	author dnoyeb;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.01.21.00.04.07;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.7
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 *  @@(#)TextAreaTool.java
 *
 *  Project:     JHotdraw - a GUI framework for technical drawings
 *               http://www.jhotdraw.org
 *               http://jhotdraw.sourceforge.net
 *  Copyright:   © by the original author(s) and all contributors
 *  License:     Lesser GNU Public License (LGPL)
 *               http://www.opensource.org/licenses/lgpl-license.html
 */
package CH.ifa.draw.contrib;

import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.standard.CreationTool;
import CH.ifa.draw.standard.SingleFigureEnumerator;
import CH.ifa.draw.standard.TextHolder;
import CH.ifa.draw.util.Undoable;
import CH.ifa.draw.util.UndoableAdapter;

import java.awt.Container;
import java.awt.Font;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;

/**
 * A TextAreaTool creates TextAreaFigures.<br>
 * To create a new text area, the user drags a rectangle on the drawing on
 * a free spot.<br>
 * When releasing the mouse the tool calls the area's editor to enter the text.<br>
 * If the tool is clicked on an existing area the tool simply calls the
 * area's editor.<br>
 * When creating a new area, if the user leaves the text empty, the newly created
 * area figure is discarded.
 *
 * @@author    Eduardo Francos - InContext
 * @@created   29 april 2002
 * @@version   1.0
 */
public class TextAreaTool extends CreationTool {
	/** The field used for editing */
	protected FloatingTextArea fTextField;

	/** The typing target */
	protected TextHolder fTypingTarget;
	/** The edited figure */
	protected Figure fEditedFigure;

	/**
	 * Constructor for the TextAreaTool object
	 *
	 * @@param newDrawingEditor  the managing drawing editor
	 * @@param prototype         the prototype for the figure
	 */
	public TextAreaTool(DrawingEditor newDrawingEditor, Figure prototype) {
		super(newDrawingEditor, prototype);
	}

	/**
	 * If the pressed figure is a TextHolder and it accepts editing it can be edited.<br>
	 * If there is no pressed figure a new text figure is created.
	 *
	 * @@param e  Description of the Parameter
	 * @@param x  Description of the Parameter
	 * @@param y  Description of the Parameter
	 */
	public void mouseDown(MouseEvent e, int x, int y) {
		setView((DrawingView)e.getSource());
		Figure pressedFigure = drawing().findFigureInside(x, y);
		TextHolder textHolder = null;
		if (pressedFigure != null) {
			textHolder = pressedFigure.getTextHolder();
		}

		if ((textHolder != null) && (textHolder.acceptsTyping())) {
			beginEdit(textHolder, pressedFigure);
			return;
		}
		if (getTypingTarget() != null) {
			endEdit();

			if (getCreatedFigure() != null && getCreatedFigure().isEmpty()) {
				drawing().remove(getAddedFigure());
				// nothing to undo
				setUndoActivity(null);
			}
			else {
//				// use undo activity from paste command...
//				setUndoActivity(createUndoActivity());
//
//				// put created figure into a figure enumeration
//				getUndoActivity().setAffectedFigures(new SingleFigureEnumerator(getAddedFigure()));
			}
			setTypingTarget(null);
			setCreatedFigure(null);
			setEditedFigure(null);
			setAddedFigure(null);
			editor().toolDone();
		}
		else {
			super.mouseDown(e, x, y);
		}
	}

	/**
	 * Drags to set the initial text area display box
	 *
	 * @@param e  Description of the Parameter
	 * @@param x  Description of the Parameter
	 * @@param y  Description of the Parameter
	 */
	public void mouseDrag(MouseEvent e, int x, int y) {
		// if not creating just ignore
		if (getCreatedFigure() == null) {
			return;
		}
		super.mouseDrag(e, x, y);
	}

	/**
	 * If creating a figure it ends the creation process and calls the editor
	 *
	 * @@param e  Description of the Parameter
	 * @@param x  Description of the Parameter
	 * @@param y  Description of the Parameter
	 */
	public void mouseUp(MouseEvent e, int x, int y) {
		// if not creating just ignore
		if (getCreatedFigure() == null) {
			return;
		}

		// update view so the created figure is drawn before the floating text
		// figure is overlaid. (Note, fDamage should be null in StandardDrawingView
		// when the overlay figure is drawn because a JTextField cannot be scrolled)
		view().checkDamage();
		TextHolder textHolder = (TextHolder)getCreatedFigure();
		if (textHolder.acceptsTyping()) {
			beginEdit(textHolder, getCreatedFigure());
		}
		else {
			editor().toolDone();
		}
	}

	/**
	 * Terminates the editing of a text figure.
	 */
	public void deactivate() {
		endEdit();
		super.deactivate();
	}

	/**
	 * Activates the figure's editor
	 */
	public void activate() {
		super.activate();
		getActiveView().clearSelection();
	}

	/**
	 * Test whether the text tool is currently activated and is displaying
	 * a overlay TextFigure for accepting input.
	 *
	 * @@return   true, if the text tool has a accepting target TextFigure for its input, false otherwise
	 */
	public boolean isActivated() {
		return getTypingTarget() != null;
	}

	/**
	 * Begins editing the figure's text
	 *
	 * @@param figure          the typing target
	 * @@param selectedFigure  the edited figure
	 */
	protected void beginEdit(TextHolder figure, Figure selectedFigure) {
		if (fTextField == null) {
			fTextField = new FloatingTextArea();
		}

		if (figure != getTypingTarget() && getTypingTarget() != null) {
			endEdit();
		}

		fTextField.createOverlay((Container)view(), getFont(figure));
		fTextField.setBounds(fieldBounds(figure), figure.getText());

		setTypingTarget(figure);
		setEditedFigure(selectedFigure);
		setUndoActivity(createUndoActivity());
	}

	/**
	 * Gets the font to be used for editing the figure
	 *
	 * @@param figure  the figure
	 * @@return        The font
	 */
	protected Font getFont(TextHolder figure) {
		return figure.getFont();
	}

	/** Ends editing of the figure's text */
	protected void endEdit() {
		if ((getTypingTarget() != null) && (fTextField != null)) {
			if (fTextField.getText().length() > 0) {
				getTypingTarget().setText(fTextField.getText());
				// put created figure into a figure enumeration
				getUndoActivity().setAffectedFigures(
						new SingleFigureEnumerator(getEditedFigure()));
				((TextAreaTool.UndoActivity)getUndoActivity()).setBackupText(
						getTypingTarget().getText());
			}
			else {
				drawing().orphan(getAddedFigure());
				// nothing to undo
//	            setUndoActivity(null);
			}

			fTextField.endOverlay();
			fTextField = null;
//			view().checkDamage();
		}
	}

	/**
	 * Returns the bounds fo the figure
	 *
	 * @@param figure  the edited figure
	 * @@return        Description of the Return Value
	 */
	private Rectangle fieldBounds(TextHolder figure) {
		return figure.textDisplayBox();
	}

	/**
	 * Sets the typingTarget attribute of the TextAreaTool
	 *
	 * @@param newTypingTarget  The new typingTarget value
	 */
	protected void setTypingTarget(TextHolder newTypingTarget) {
		fTypingTarget = newTypingTarget;
	}

	/**
	 * Gets the editedFigure attribute of the TextAreaTool
	 *
	 * @@return   The editedFigure value
	 */
	protected Figure getEditedFigure() {
		return fEditedFigure;
	}

	/**
	 * Sets the editedFigure attribute of the TextAreaTool
	 *
	 * @@param figure  The new editedFigure value
	 */
	protected void setEditedFigure(Figure figure) {
		fEditedFigure = figure;
	}

	/**
	 * Gets the typingTarget attribute of the TextAreaTool
	 *
	 * @@return   The typingTarget value
	 */
	protected TextHolder getTypingTarget() {
		return fTypingTarget;
	}

	/**
	 * Factory method for undo activity
	 *
	 * @@return   Description of the Return Value
	 */
	protected Undoable createUndoActivity() {
		return new TextAreaTool.UndoActivity(view(), getTypingTarget().getText());
	}

	/**
	 * Handles undo/redo for text areas
	 *
	 * @@author    gualo
	 */
	public static class UndoActivity extends UndoableAdapter {
		/** The original text */
		private String myOriginalText;
		/** The backup text */
		private String myBackupText;

		/**
		 * Constructor for the UndoActivity object
		 *
		 * @@param newDrawingView   Description of the Parameter
		 * @@param newOriginalText  Description of the Parameter
		 */
		public UndoActivity(DrawingView newDrawingView, String newOriginalText) {
			super(newDrawingView);
			setOriginalText(newOriginalText);
			setUndoable(true);
			setRedoable(true);
		}

		/*
		 *  Undo the activity
		 *  @@return true if the activity could be undone, false otherwise
		 */
		/**
		 * Undo the activity
		 *
		 * @@return   Description of the Return Value
		 */
		public boolean undo() {
			if (!super.undo()) {
				return false;
			}

			getDrawingView().clearSelection();

			if (!isValidText(getOriginalText())) {
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					getDrawingView().drawing().orphan(fe.nextFigure());
				}
			}
			// add text figure if it has been removed (no backup text)
			else if (!isValidText(getBackupText())) {
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					getDrawingView().add(fe.nextFigure());
				}
				setText(getOriginalText());
			}
			else {
				setText(getOriginalText());
			}

			return true;
		}

		/*
		 *  Redo the activity
		 *  @@return true if the activity could be redone, false otherwise
		 */
		/**
		 * Redo the activity
		 *
		 * @@return   Description of the Return Value
		 */
		public boolean redo() {
			if (!super.redo()) {
				return false;
			}

			getDrawingView().clearSelection();

			// the text figure did exist but was remove
			if (!isValidText(getBackupText())) {
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					getDrawingView().drawing().orphan(fe.nextFigure());
				}
			}
			// the text figure didn't exist before
			else if (!isValidText(getOriginalText())) {
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					getDrawingView().drawing().add(fe.nextFigure());
					setText(getBackupText());
				}
			}
			else {
				setText(getBackupText());
			}

			return true;
		}

		/**
		 * Validates the text in the undo activity
		 *
		 * @@param toBeChecked  Description of the Parameter
		 * @@return             The validText value
		 */
		protected boolean isValidText(String toBeChecked) {
			return ((toBeChecked != null) && (toBeChecked.length() > 0));
		}

		/**
		 * Sets the text attribute of the UndoActivity
		 *
		 * @@param newText  The new text value
		 */
		protected void setText(String newText) {
			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				Figure currentFigure = fe.nextFigure();
				if (currentFigure.getTextHolder() != null) {
					currentFigure.getTextHolder().setText(newText);
				}
			}
		}

		/**
		 * Sets the backupText attribute of the UndoActivity
		 *
		 * @@param newBackupText  The new backupText value
		 */
		public void setBackupText(String newBackupText) {
			myBackupText = newBackupText;
		}

		/**
		 * Gets the backupText attribute of the UndoActivity
		 *
		 * @@return   The backupText value
		 */
		public String getBackupText() {
			return myBackupText;
		}

		/**
		 * Sets the originalText attribute of the UndoActivity
		 *
		 * @@param newOriginalText  The new originalText value
		 */
		public void setOriginalText(String newOriginalText) {
			myOriginalText = newOriginalText;
		}

		/**
		 * Gets the originalText attribute of the UndoActivity
		 *
		 * @@return   The originalText value
		 */
		public String getOriginalText() {
			return myOriginalText;
		}
	}
}
@


1.6
log
@prepare for 5.4 release: various bug fixes
@
text
@d4 6
a9 6
 *  Project:		JHotdraw - a GUI framework for technical drawings
 *  http://www.jhotdraw.org
 *  http://jhotdraw.sourceforge.net
 *  Copyright:	© by the original author(s) and all contributors
 *  License:		Lesser GNU Public License (LGPL)
 *  http://www.opensource.org/licenses/lgpl-license.html
d31 1
a31 1
 * a free spot.<BR>
a41 1

d45 1
d209 1
a209 1
		if (getTypingTarget() != null) {
a239 1

a248 1

a266 1

a294 1

@


1.5
log
@Fixed problem with TextArea figures + cascading FigureChangeEvent
@
text
@a17 1
import CH.ifa.draw.standard.DecoratorFigure;
a291 1
	 * @@created   26 avril 2002
@


1.5.4.1
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d27 1
a27 1
import CH.ifa.draw.framework.DrawingViewMouseEvent;
d70 3
a72 5
	public void mouseDown(DrawingViewMouseEvent dvme) {
		setView( dvme.getDrawingView() );
		setAnchorX( dvme.getX() );
		setAnchorY( dvme.getY() );
		Figure pressedFigure = drawing().findFigureInside( getAnchorX(), getAnchorY() );
d104 1
a104 1
			super.mouseDown(dvme);
d115 1
a115 1
	public void mouseDrag(DrawingViewMouseEvent dvme) {
d120 1
a120 1
		super.mouseDrag(dvme);
d130 1
a130 1
	public void mouseUp(DrawingViewMouseEvent dvme) {
@


1.5.4.2
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@a88 1
				//or getAddedFigure().remove(); getAddedFigure().release();
a222 2
				//this tool is now responsible for the release or readd of the figure
				//!!!dnoyeb!!!
d335 2
a336 2
				while(fe.hasNextFigure()){
					fe.nextFigure().remove();
a337 2
				//this tool is now responsible for the release or readd of the figures
				//!!!dnoyeb!!!
d373 2
a374 2
				while(fe.hasNextFigure()){
					fe.nextFigure().remove();
a375 1
				//this tool is now this tools responsibility to release these figures
@


1.5.4.3
log
@
Lets have a moment of silence for DecoratorFigure.....It was a good figure ;{

Anything which happens inside the drawing after figure add must be undone before figure orphan.  It must also not
be exposed to anyobject outside the drawing.
Decorator figure retired in favor of a figureManipulator and the other functions being implemented by a composite
figure(BorderDecorator).
AdnimationDecorator retired in favor of AnimationManipulator.
A figure can have only 1 container. This is making the border tool have a hard time.

Lots of comments added

next phase:
orphan will disappear.  only add and remove remain.  All figure related resources belong to the figures and no other
object should care about figure.release.
split the figureListener into a figureContainer listener and a figureChangeListener.
Fix BorderDecorator.
Fix ConnectedText.
view.checkDamage to call drawing.update()
@
text
@d18 1
a18 1

@


1.5.4.4
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d142 1
a142 1
		view().drawing().update();
d232 1
a232 1
//			view().drawing().update();
@


1.5.4.5
log
@More cleanups for DecoratorFigure.  Its going to cause problems till the architecture changes.
Added a few needed methods to expose private variables of StandardDrawingView to make it more
override friendly.
@
text
@d89 1
d378 3
a380 1
				getDrawingView().drawing().orphanAll( fe );
@


1.5.4.6
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d338 1
a338 1
					getDrawingView().drawing().orphan(fe.nextFigure());
@


1.4
log
@introduce FigureVisitor for paste/delete commands
@
text
@d71 1
d162 1
a162 1
		view().clearSelection();
@


1.3
log
@after variou merges... (before 5.4 release)
@
text
@a24 1
import java.awt.Dimension;
a25 1
import java.awt.Point;
a26 1
import java.awt.event.InputEvent;
d71 1
d73 2
a74 6
		Figure pressedFigure = drawing().findFigureInside(x, y);
		if (pressedFigure instanceof TextHolder) {
			textHolder = (TextHolder)pressedFigure;
			if (!textHolder.acceptsTyping()) {
				textHolder = null;
			}
d76 2
a77 1
		if (textHolder != null) {
d219 1
a219 1
				drawing().orphan((Figure)getAddedFigure());
d408 2
a409 5
				if (currentFigure instanceof DecoratorFigure) {
					currentFigure = ((DecoratorFigure)currentFigure).getDecoratedFigure();
				}
				if (currentFigure instanceof TextHolder) {
					((TextHolder)currentFigure).setText(newText);
@


1.2
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@d337 1
a337 1
				while (fe.hasMoreElements()) {
d344 1
a344 1
				while (fe.hasMoreElements()) {
d375 1
a375 1
				while (fe.hasMoreElements()) {
d382 1
a382 1
				while (fe.hasMoreElements()) {
d411 1
a411 1
			while (fe.hasMoreElements()) {
@


1.1
log
@no message
@
text
@d4 6
a9 6
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
a12 6
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.InputEvent;
import java.awt.event.MouseEvent;
a16 1

d24 8
a40 2
 * @@author Eduardo Francos - InContext
 * @@version 1.0
d42 3
d46 1
d48 1
a48 3
	/**
	 * The field used for editing
	 */
a54 1

d57 3
a59 2
	 * @@param newDrawingEditor the managing drawing editor
	 * @@param prototype the prototype for the figure
a64 1

d68 4
a71 3
	 * @@param e Description of the Parameter
	 * @@param x Description of the Parameter
	 * @@param y Description of the Parameter
a111 1

a126 1

d145 6
a150 1
		beginEdit(textHolder, getCreatedFigure());
a152 1

a160 1

a168 1

d172 2
a173 1
	 * @@return true, if the text tool has a accepting target TextFigure for its input, false otherwise
a178 1

d181 3
a183 2
	 * @@param figure the typing target
	 * @@param selectedFigure the edited figure
d194 1
a194 1
		fTextField.createOverlay((Container)view(), figure.getFont());
d202 9
a217 2
//				getUndoActivity().setAffectedFigures(
//						new SingleFigureEnumerator(getAddedFigure()));
a234 1

d237 3
a239 2
	 * @@param figure the edited figure
	 * @@return Description of the Return Value
d248 2
a249 1
	 * @@param newTypingTarget The new typingTarget value
a264 1

d267 2
a268 1
	 * @@param figure The new editedFigure value
a283 1

a292 1

a318 1

a355 1

d365 1
a365 2
		public boolean redo()
		{
a393 1

a403 1

a421 1

a430 1

a439 1

a447 1

@

