head	1.3;
access;
symbols
	jhotdraw54b2-release:1.3
	reorg_6x_split:1.3
	MVC_PHASE1:1.2.0.2
	NEW_ATTRIBUTES:1.1.0.8
	DNOYEB1_ALPHA-2:1.1
	release_JHD54b1:1.1
	BUGFIX_670992:1.1.0.6
	DNOYEB1_ALPHA-1:1.1
	dnoyeb1:1.1.0.4
	repack:1.1.0.2
	Root_repack:1.1
	Before_FigureVisitor:1.1;
locks; strict;
comment	@# @;


1.3
date	2003.11.09.21.18.47;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.22.23.58.33;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	;


desc
@@


1.3
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 * @@(#)ETSLADisposalStrategy.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */
package CH.ifa.draw.contrib.html;

import java.util.Iterator;

/**
 * ETSLADisposalStrategy implements an Ellapsed Time Since Last Access disposal
 * strategy.<bt>
 * It checks the last time a resource was accessed and if greater than
 * the resource's disposalDelay it disposes of the resource so that it can
 * be GCed.<br>
 * Disposal activity must be explicitely started using the startDisposing method
 *
 * @@author    Eduardo Francos - InContext
 * @@created   2 mai 2002
 * @@version   1.0
 */
public class ETSLADisposalStrategy implements ResourceDisposabilityStrategy {

	/** The associated resource manager */
	private DisposableResourceManager manager;

	/** The periodicity at wich disposal is checked */
	private long gcPeriodicity = 60000;

	/** the thread that calls this periodically */
	private DisposalThread disposalThread = null;

	/** True if disposal is active and running */
	private boolean disposingActive = false;


	/**
	 * Constructor for the ETSLADisposalStrategy object
	 */
	public ETSLADisposalStrategy() { }

	/**
	 *Constructor for the ETSLADisposalStrategy object
	 *
	 * @@param periodicity  the periodicity at which to check for disposable resources
	 */
	public ETSLADisposalStrategy(long periodicity) {
		this(null, periodicity);
	}

	/**
	 *Constructor for the ETSLADisposalStrategy object
	 *
	 * @@param manager      the manager
	 * @@param periodicity  the periodicity at which to check for disposable resources
	 */
	public ETSLADisposalStrategy(DisposableResourceManager newManager, long newPeriodicity) {
		setManager(newManager);
		setPeriodicity(newPeriodicity);
		initDisposalThread();
	}

	/**
	 * Sets the manager holding the resources for this strategy
	 *
	 * @@param manager  The new manager value
	 */
	public synchronized void setManager(DisposableResourceManager newManager) {
		// if new manager is null the stop disposing
		if (getManager() == null) {
			stopDisposing(Long.MAX_VALUE);
		}
		manager = newManager;
	}

	/**
	 * Gets the manager holding the resources for this strategy
	 *
	 * @@return   The manager value
	 */
	public DisposableResourceManager getManager() {
		return manager;
	}

	/**
	 * Activates the strategy which starts disposing of resources as fitted
	 *
	 * @@exception ResourceManagerNotSetException  thrown if the manager has not
	 * been set, so impossible to run
	 */
	public void startDisposing() throws ResourceManagerNotSetException {
		if (getManager() == null) {
			throw new ResourceManagerNotSetException();
		}

		// do nothing if already active
		if (disposingActive) {
			return;
		}

		disposingActive = true;
		disposalThread.start();
	}

	/**
	 * Deactivates the strategy that stops automatic disposal of resources.<br>
	 * The millis parameters specifies in milliseconds the time to wait for
	 * the disposal to stop. After this time the method returns, but the
	 * deactivation request remains active.
	 *
	 * @@param millis  time to wait for disposal to stop
	 */
	public void stopDisposing(long millis) {
		// do nothing if not disposing
		if (!disposingActive) {
			return;
		}
		// request the thread to stop and wait for it
		try {
			disposalThread.interruptDisposalPending = true;
			disposalThread.join(millis);
		}
		catch (InterruptedException ex) {
			// ignore
		}
		finally {
			disposingActive = false;
		}
	}

	/**
	 * Initializes the disposal thread if not alrady done.
	 */
	protected void initDisposalThread() {
		if (disposalThread != null) {
			return;
		}

		disposalThread = new DisposalThread(this, getPeriodicity());
	}

	/**
	 * Dispose of all the resources whose dispose delay has expired and
	 * are not locked
	 */
	protected synchronized void dispose() {
		synchronized (getManager()) {
			long currentTime = System.currentTimeMillis();
			Iterator resourceIter = getManager().getResources();
			DisposableResourceHolder resource;

			while (resourceIter.hasNext()) {
				resource = (DisposableResourceHolder)resourceIter.next();
				synchronized (resource) {
					if (!resource.isLocked() && (resource.getLastTimeAccessed() + resource.getDisposableDelay()) < currentTime) {
						resource.dispose();
					}
				}
			}
		}
	}

	/**
	 * Gets the periodicity attribute of the ETSLADisposalStrategy object
	 *
	 * @@return   The periodicity value
	 */
	public long getPeriodicity() {
		return gcPeriodicity;
	}

	/**
	 * Sets the periodicity attribute of the ETSLADisposalStrategy object
	 *
	 * @@param newPeriodicity  The new periodicity value
	 */
	public void setPeriodicity(long newPeriodicity) {
		gcPeriodicity = newPeriodicity;
		if (disposalThread != null) {
			disposalThread.setPeriodicity(newPeriodicity);
		}
	}
}

/**
 * Description of the Class
 *
 * @@author    Eduardo Francos - InContext
 * @@created   2 mai 2002
 */
class DisposalThread extends Thread {

	private ETSLADisposalStrategy strategy;

	/** The periodicity at wich disposal is checked */
	private long periodicity = 60000;

	/** Description of the Field */
	boolean interruptDisposalPending = false;

	/**
	 *Constructor for the DisposalThread object
	 *
	 * @@param strategy     the strategy
	 * @@param periodicity  the periodicity at which the strategy should be called
	 */
	DisposalThread(ETSLADisposalStrategy newStrategy, long newPeriodicity) {
		strategy = newStrategy;
		periodicity = newPeriodicity;
	}

	/**
	 * Main processing method for the DisposalThread object
	 */
	public void run() {
		interruptDisposalPending = false;
		while (!interruptDisposalPending) {
			try {
				sleep(periodicity);
			}
			catch (Exception ex) {
				// just exit
				break;
			}
			strategy.dispose();
		}
		interruptDisposalPending = false;
	}

	/**
	 * Gets the periodicity attribute of the ETSLADisposalStrategy object
	 *
	 * @@return   The periodicity value
	 */
	public long getPeriodicity() {
		return periodicity;
	}

	/**
	 * Sets the periodicity attribute of the ETSLADisposalStrategy object
	 *
	 * @@param newPeriodicity  The new periodicity value
	 */
	public void setPeriodicity(long newPeriodicity) {
		periodicity = newPeriodicity;
	}

	/** Description of the Method */
	public void interruptDisposal() {
		interruptDisposalPending = true;
	}
}
@


1.2
log
@no message
@
text
@d62 3
a64 3
	public ETSLADisposalStrategy(DisposableResourceManager manager, long periodicity) {
		setManager(manager);
		setPeriodicity(periodicity);
d73 1
a73 1
	public synchronized void setManager(DisposableResourceManager manager) {
d78 1
a78 1
		this.manager = manager;
d212 3
a214 3
	DisposalThread(ETSLADisposalStrategy strategy, long periodicity) {
		this.strategy = strategy;
		this.periodicity = periodicity;
@


1.1
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@d2 1
a2 1
 *  @@(#)TextAreaFigure.java
d4 6
a9 6
 *  Project:		JHotdraw - a GUI framework for technical drawings
 *  http://www.jhotdraw.org
 *  http://jhotdraw.sourceforge.net
 *  Copyright:	© by the original author(s) and all contributors
 *  License:		Lesser GNU Public License (LGPL)
 *  http://www.opensource.org/licenses/lgpl-license.html
d27 1
a28 1
public class ETSLADisposalStrategy implements ResourceDisposabilityStrategy {
d30 1
a30 1
	protected DisposableResourceManager manager;
d33 1
a33 1
	protected long gcPeriodicity = 60000;
d36 1
a36 1
	protected DisposalThread disposalThread = null;
d39 1
a39 1
	protected boolean disposingActive = false;
d42 3
a44 1
	/**Constructor for the ETSLADisposalStrategy object */
a46 1

d53 1
a53 2
		gcPeriodicity = periodicity;
		initDisposalThread();
a55 1

d62 3
a64 3
	public ETSLADisposalStrategy(DisposableResourceManager manager, int periodicity) {
		this.manager = manager;
		gcPeriodicity = periodicity;
a67 1

d75 1
a75 1
		if (manager == null) {
a80 1

a89 1

d96 2
a97 3
	public void startDisposing()
		throws ResourceManagerNotSetException {
		if (manager == null) {
a109 1

d136 3
a138 2

	/** Initializes the disposal thread if not alrady done. */
d144 1
a144 1
		disposalThread = new DisposalThread(this, gcPeriodicity);
a146 1

d152 1
a152 1
		synchronized (manager) {
d154 1
a154 1
			Iterator resourceIter = manager.getResources();
a167 1

a176 1

d182 1
a182 1
	public void setPeriodicity(int newPeriodicity) {
a187 1

d198 1
a199 1
	private ETSLADisposalStrategy strategy;
d201 2
a202 1
	protected long periodicity = 60000;
d204 1
a204 2
	protected boolean interruptDisposalPending = false;

d217 3
a219 2

	/** Main processing method for the DisposalThread object */
a234 1

a243 1

a251 1

@

