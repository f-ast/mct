head	1.4;
access;
symbols
	jhotdraw54b2-release:1.4
	reorg_6x_split:1.4
	MVC_PHASE1:1.4.0.4
	NEW_ATTRIBUTES:1.4.0.2
	DNOYEB1_ALPHA-2:1.3.4.10
	release_JHD54b1:1.4
	BUGFIX_670992:1.3.0.6
	DNOYEB1_ALPHA-1:1.3.4.9
	dnoyeb1:1.3.0.4
	repack:1.3.0.2
	Root_repack:1.3
	Before_FigureVisitor:1.3;
locks; strict;
comment	@# @;


1.4
date	2003.01.30.00.27.33;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.07.12.27.27;	author mrfloppy;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	;

1.3.4.1
date	2003.01.04.15.20.46;	author dnoyeb;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.01.04.15.38.01;	author dnoyeb;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.01.04.16.23.20;	author dnoyeb;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.01.07.21.22.29;	author dnoyeb;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.01.10.04.54.31;	author dnoyeb;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.01.14.18.20.30;	author dnoyeb;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2003.01.15.21.04.10;	author dnoyeb;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2003.01.17.17.32.51;	author dnoyeb;	state Exp;
branches;
next	1.3.4.9;

1.3.4.9
date	2003.01.21.00.04.07;	author dnoyeb;	state Exp;
branches;
next	1.3.4.10;

1.3.4.10
date	2003.01.26.00.50.48;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.4
log
@prepare for 5.4 release: various bug fixes
@
text
@/*
 * @@(#)CompositeFigureCreationTool.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.contrib;

import CH.ifa.draw.standard.CreationTool;
import CH.ifa.draw.standard.CompositeFigure;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.framework.DrawingView;

import java.awt.event.MouseEvent;
import java.awt.*;

/**
 * @@author	Wolfram Kaiser
 * @@version <$CURRENT_VERSION$>
 */
public class CompositeFigureCreationTool extends CreationTool {
	private CompositeFigure myContainerFigure;

	public CompositeFigureCreationTool(DrawingEditor newDrawingEditor, Figure prototype) {
		super(newDrawingEditor, prototype);
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		setView((DrawingView)e.getSource());
		Figure figure = drawing().findFigure(e.getX(), e.getY());
		if (figure != null) {
			figure = figure.getDecoratedFigure();
			if (figure instanceof CompositeFigure) {
				setContainerFigure((CompositeFigure)figure);
				setCreatedFigure(createFigure());
				setAddedFigure((getContainerFigure().add(getCreatedFigure())));
				getAddedFigure().displayBox(new Point(x, y), new Point(x, y));
			}
			else {
				toolDone();
			}
		}
		else {
			toolDone();
		}
	}

	public void mouseMove(MouseEvent e, int x, int y) {
		if ((getContainerFigure() != null) && !getContainerFigure().containsPoint(e.getX(), e.getY())) {
			// here you might want to constrain the mouse movements to the size of the
			// container figure: not sure whether this works...
			toolDone();
		}
		else {
			super.mouseMove(e, x, y);
		}
	}

	protected void setContainerFigure(CompositeFigure newContainerFigure) {
		myContainerFigure = newContainerFigure;
	}

	public CompositeFigure getContainerFigure() {
		return myContainerFigure;
	}

	protected void toolDone() {
		setCreatedFigure(null);
		setAddedFigure(null);
		setContainerFigure(null);
		editor().toolDone();
	}
}
@


1.3
log
@removed remains of FigureAttributeConstant.getName() and some code-clean up
@
text
@a15 1
import CH.ifa.draw.standard.DecoratorFigure;
d36 12
a47 8
		Figure figure = getFigureWithoutDecoration(drawing().findFigure(e.getX(), e.getY()));
		if ((figure != null) && (figure instanceof CompositeFigure)) {
			setContainerFigure((CompositeFigure)figure);
			setCreatedFigure(createFigure());
			setAddedFigure((getContainerFigure().add(getCreatedFigure())));

			setAnchorPoint(new Point(x, y));
			getAddedFigure().displayBox(getAnchorPoint(), getAnchorPoint());
a53 9
	private Figure getFigureWithoutDecoration(Figure peelFigure) {
		if (peelFigure instanceof DecoratorFigure) {
			return getFigureWithoutDecoration(((DecoratorFigure)peelFigure).getDecoratedFigure());
		}
		else {
			return peelFigure;
		}
	}

a62 8
	}

	public void mouseUp(MouseEvent e, int x, int y) {
		if ((getContainerFigure() != null) && (getCreatedFigure() != null)
				&& getContainerFigure().containsPoint(e.getX(), e.getY())) {
			getContainerFigure().add(getCreatedFigure());
		}
		toolDone();
@


1.3.4.1
log
@improved functionality of CompositeFigureCreationTool
added comments to some files.(probably overdid it)
@
text
@d11 1
d20 1
a20 2
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
a24 9
 *	Tool must be created before all views it will be used on.
 *  dnoyeb changed this tool to only be useable when a CompositeFigure is selected.
 *  Otherwise, one must try to work on every figure he/she sees without knowing which
 *	is a CompositeFigure until the tool fails to work.  This way at least when you click
 *	on one, the tool will become useable and you can see that because the button will
 *	no longer be greyed out.  I think it helps when you have several tools, to know
 *	which ones you can use when.
 *
 *
d30 1
a30 6
	private final FigureSelectionListener figureSelectionListener = new FigureSelectionListener() {
			public void figureSelectionChanged(DrawingView view){
				checkUsable();
			}
		};
	
a34 19
	public void activate() {
		if (getActiveView() != null) {
			//getActiveView().clearSelection(); //do not clear selection as it is needed. see class level comments 
			getActiveView().checkDamage();
			getEventDispatcher().fireToolActivatedEvent();
		}
		if (isUsable()) {
			getActiveView().setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
		}
	}
	
	public void viewCreated(DrawingView view){
		view.addFigureSelectionListener(figureSelectionListener);
	}
	
	public void viewDestroying(DrawingView view){
		view.removeFigureSelectionListener(figureSelectionListener);
	}
	
d59 1
a59 9
	/**
	 *	
	 *	No this does not work because their is no container figure until the mouseDown.
	 *	This container only lasts until mouseUp when toolDone() is called.  Mousemove
	 *	is never called between mouse down and mouse up.  mouseDrag is...dnoyeb.
	 *	Perhaps what you want to do here is alter the cursor when over the proper
	 *	figure type???
	 *
	 */
d61 4
a64 4
		DrawingView v = (DrawingView)e.getSource();
		Figure f = getFigureWithoutDecoration( v.drawing().findFigure(e.getX(), e.getY()) );
		if(f instanceof CompositeFigure) {
			getActiveView().setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
d67 1
a67 1
			getActiveView().setCursor(Cursor.getDefaultCursor());//need the NO cursor, but where do I find it?
d70 1
a70 15
	/**
	 * Adjusts the extent of the created figure
	 * 
	 * Limited size to size of {@@link CompositeFigure CompositeFigure}.  alternatly the container figure can
	 * stretch (if shift is down?)
	 *	Need better limiting system.  Like the one DrawingView uses so that x and y are
	 *	limited independently, and both dont stop operating the second one violates its
	 *	parameters.
	 */
	public void mouseDrag(MouseEvent e, int x, int y) {
		if ((getContainerFigure() != null) && getContainerFigure().containsPoint(e.getX(), e.getY())) {
			super.mouseDrag(e,x, y);
		}
	}
	
d78 1
a78 21
	/**
	 *	This generates the required context sensitivity for this tool.
	 *	This tool is only useable when exactly one (1) CompositeFigure is selected.
	 */
	protected void checkUsable() {
		if (isEnabled()) {
			DrawingView adv = getActiveView();
			if(adv != null && adv.isInteractive()){
				if(adv.selectionCount() == 1) {
					FigureSelection fs = adv.getFigureSelection();
					FigureEnumerator fe = (FigureEnumerator) fs.getData(StandardFigureSelection.TYPE);
					Figure f = getFigureWithoutDecoration( fe.nextFigure() );
					if(CompositeFigure.class.isInstance( f )){
						setUsable( true );
						return;
					}
				}
			}
			setUsable( false );
		}
	}
@


1.3.4.2
log
@Modified ViewChangeListener
ViewCreated -> ViewActivated
ViewDestroying -> ViewDeactivated
@
text
@d60 1
a60 1
	public void viewActivated(DrawingView view){
d64 1
a64 1
	public void viewDeactivated(DrawingView view){
@


1.3.4.3
log
@AbstractTool now contains as opposed to inherits ViewChangeListener
So the ViewChangeListener methods are not exposed as public from AbstractTool.
Methods of the same name exist, but they are now protected.
@
text
@d60 1
a60 2
	protected void viewActivated(DrawingView view){
		super.viewActivated(view);
d64 1
a64 1
	protected void viewDeactivated(DrawingView view){
a65 1
		super.viewDeactivated(view);
@


1.3.4.4
log
@1. Added getDesktop to the DrawingEditor.  added null returns to all Classes that dont fully support
   the Desktop architecture yet, like the applets.

2. Added a figureSelection listener to the DrawingEditor so one can register with the DrawingEditor to
   hear figure selection events.  You can still register with the individual DrawingViews if you wish.
   The DrawingEditor will guarantee that it only fires this event on the active view, so it saves a listener
   from having to register and unregister with views to hear this event each time the activeView changes.
   All Commands were doing this register/unregister dance.

3. AbstractCommand now registers for figureSelectionEvents with the drawingEditor as opposed to the
   DrawingView.

4. Went back to viewCreated and viewDestroying naming.  flip flopping.  Its actually more accurate.  the
   real issue is that 2 events are missing, viewDestroyed and viewCreating.  dont need them yet, but
   they may materialize in the future.

5. Went back to Tool CompositeTool being enabled even when no figure is selected.

6. FigureSelectionListener now extends java.util.EventListener now because I am too lazy to write
   an event handler just yet.

7. implemented new findFigureInside() fix.  needs testing.

8. standardDrawingView selectionZordered now returns figures in the proper order(not reversed).
@
text
@d60 2
a61 2
	protected void viewCreated(DrawingView view){
		super.viewCreated(view);
d65 1
a65 1
	protected void viewDestroying(DrawingView view){
d67 1
a67 1
		super.viewDestroying(view);
d86 1
a86 1
	protected Figure getFigureWithoutDecoration(Figure peelFigure) {
a137 4
	 *  I took this out because it requires an extra mouse push when you want to
	 * keep working with composite figures.  select figure, hit button, work.
	 * select figure, hit button work.  without this, you just hit button and work.
	 * i think its worth it to go back.
d140 1
a140 2
		super.checkUsable();
/*		if (isEnabled()) {
d154 1
a154 1
		}*/
@


1.3.4.5
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d21 1
a21 1

d69 4
a72 4

	public void mouseDown(DrawingViewMouseEvent dvme) {
		setView( dvme.getDrawingView() );
		Figure figure = getFigureWithoutDecoration(drawing().findFigure(dvme.getX(), dvme.getY()));
d77 2
a78 1
			setAnchorPoint(new Point(dvme.getX(), dvme.getY()));
d103 3
a105 3
	public void mouseMove(DrawingViewMouseEvent dvme) {
		DrawingView v = dvme.getDrawingView();
		Figure f = getFigureWithoutDecoration( v.drawing().findFigure(dvme.getX(), dvme.getY()) );
d122 3
a124 3
	public void mouseDrag(DrawingViewMouseEvent dvme) {
		if ((getContainerFigure() != null) && getContainerFigure().containsPoint(dvme.getX(), dvme.getY())) {
			super.mouseDrag(dvme);
d128 1
a128 1
	public void mouseUp(DrawingViewMouseEvent dvme) {
d130 1
a130 1
				&& getContainerFigure().containsPoint(dvme.getX(), dvme.getY())) {
@


1.3.4.6
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d76 1
a76 2
			getContainerFigure().add(getCreatedFigure());
			setAddedFigure(getCreatedFigure());
@


1.3.4.7
log
@
Lets have a moment of silence for DecoratorFigure.....It was a good figure ;{

Anything which happens inside the drawing after figure add must be undone before figure orphan.  It must also not
be exposed to anyobject outside the drawing.
Decorator figure retired in favor of a figureManipulator and the other functions being implemented by a composite
figure(BorderDecorator).
AdnimationDecorator retired in favor of AnimationManipulator.
A figure can have only 1 container. This is making the border tool have a hard time.

Lots of comments added

next phase:
orphan will disappear.  only add and remove remain.  All figure related resources belong to the figures and no other
object should care about figure.release.
split the figureListener into a figureContainer listener and a figureChangeListener.
Fix BorderDecorator.
Fix ConnectedText.
view.checkDamage to call drawing.update()
@
text
@d15 1
a15 1

d72 1
a72 1
		Figure figure = drawing().findFigure(dvme.getX(), dvme.getY());
d86 8
d96 3
d105 1
a105 2
		Figure f = v.drawing().findFigure(dvme.getX(), dvme.getY());
		
d151 1
a151 1
					Figure f = fe.nextFigure();
@


1.3.4.8
log
@Bugfix: [ 669831 ] CompositeFigureCreationTool adds figure twice
@
text
@d26 7
d117 1
a117 4
	/**
	 * When creation tool is modified to know of only ContainerFigures and is Drawing
	 * agnostic, we can call super.mouseUp here.
	 */
d119 4
a122 6
		//figure is already added, no need for this.
//		if ((getContainerFigure() != null) && (getCreatedFigure() != null)
//				&& getContainerFigure().containsPoint(dvme.getX(), dvme.getY())) {
//			getContainerFigure().add(getCreatedFigure());
//		}
		view().drawing().update();//we made a change to the drawing, so update it.
@


1.3.4.9
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d69 2
a70 1
			setAddedFigure(getContainerFigure().add(getCreatedFigure()));
a78 8
	private Figure getFigureWithoutDecoration(Figure peelFigure) {
		if (peelFigure instanceof DecoratorFigure) {
			return getFigureWithoutDecoration(((DecoratorFigure)peelFigure).getDecoratedFigure());
		}
		else {
			return peelFigure;
		}
	}
@


1.3.4.10
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d69 1
a69 2
			getContainerFigure().add(getCreatedFigure());
			setAddedFigure(getCreatedFigure());
@


1.2
log
@after variou merges... (before 5.4 release)
@
text
@d22 1
d40 5
a44 1
			super.mouseDown(e, x, y);
@


1.1
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@d19 1
d35 1
@

