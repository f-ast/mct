head	1.3;
access;
symbols
	jhotdraw54b2-release:1.3
	reorg_6x_split:1.3
	MVC_PHASE1:1.3.0.10
	NEW_ATTRIBUTES:1.3.0.8
	DNOYEB1_ALPHA-2:1.3
	release_JHD54b1:1.3
	BUGFIX_670992:1.3.0.6
	DNOYEB1_ALPHA-1:1.3
	dnoyeb1:1.3.0.4
	repack:1.3.0.2
	Root_repack:1.3
	Before_FigureVisitor:1.3;
locks; strict;
comment	@# @;


1.3
date	2002.08.04.22.48.03;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	;


desc
@@


1.3
log
@after variou merges... (before 5.4 release)
@
text
@/*
 * @@(#)ZoomUpdateStrategy.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.contrib.zoom;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Painter;

import java.awt.*;

/**
 * A variant of the BufferedUpdateStrategy that handles clipping
 * rectangles correctly in the presence of zooming.
 * @@see CH.ifa.draw.standard.BufferedUpdateStrategy
 *
 * @@author Andre Spiegel <spiegel@@gnu.org>
 * @@version <$CURRENT_VERSION$>
 */
public class ZoomUpdateStrategy implements Painter {

	/**
	 * The offscreen image
	 */
	transient private Image fOffscreen;
	private int fImagewidth = -1;
	private int fImageheight = -1;

	/**
	 * Draws the view contents.
	 */
	public void draw(Graphics g, DrawingView view) {
		// create the buffer if necessary
		Dimension d = view.getSize();
		if ((fOffscreen == null) || (d.width != fImagewidth)
				|| (d.height != fImageheight)) {
			fOffscreen = view.createImage(d.width, d.height);
			fImagewidth = d.width;
			fImageheight = d.height;
		}

		Graphics g2 = fOffscreen.getGraphics();
		Rectangle r = g.getClipBounds();

		if (g2 instanceof ScalingGraphics) {
			ScalingGraphics s2 = (ScalingGraphics) g2;

			// AWT sets clipping rectangles in screen coordinates, not user
			// coordinates.  Therefore, we scale the clipping rectangle to
			// user coordinates here, and then apply it to both buffers,
			// which scale it back to screen coordinates.
			if (r != null) {
				// Make the rectangle slightly larger, to compensate
				// for integer rounding errors.
				r = new Rectangle((int) ((r.x - 2) / s2.getScale()),
						(int) ((r.y - 2) / s2.getScale()),
						(int) ((r.width + 4) / s2.getScale()),
						(int) ((r.height + 4) / s2.getScale()));
				g.setClip(r);
			}
		}
		g2.setClip(r);

		view.drawAll(g2);
		g.drawImage(fOffscreen, 0, 0, view);
	}
}
@


1.2
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@d22 1
a22 1
 * @@see BufferedUpdateStrategy
d27 1
a27 2
public class ZoomUpdateStrategy
		implements Painter {
@


1.1
log
@no message
@
text
@d2 1
a2 2
 * File:   ZoomUpdateStrategy.java
 * Author: Andre Spiegel <spiegel@@inf.fu-berlin.de>
d4 6
a9 1
 * $Id: ZoomUpdateStrategy.java,v 1.4 1999/10/14 13:27:45 spiegel Exp $
d23 3
@

