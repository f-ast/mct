head	1.4;
access;
symbols
	jhotdraw54b2-release:1.4
	reorg_6x_split:1.4
	MVC_PHASE1:1.2.0.10
	NEW_ATTRIBUTES:1.2.0.8
	DNOYEB1_ALPHA-2:1.2
	release_JHD54b1:1.2
	BUGFIX_670992:1.2.0.6
	DNOYEB1_ALPHA-1:1.2
	dnoyeb1:1.2.0.4
	repack:1.2.0.2
	Root_repack:1.2
	Before_FigureVisitor:1.2;
locks; strict;
comment	@# @;


1.4
date	2003.11.09.21.18.45;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.08.15.41.25;	author ricardo_padilha;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	;


desc
@@


1.4
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 * @@(#)CommandMenu.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */
package CH.ifa.draw.contrib;

import java.awt.event.*;
import java.beans.*;
import javax.swing.*;
import javax.swing.event.*;

import CH.ifa.draw.contrib.CTXCommandMenu;
import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.standard.AbstractCommand;

/**
 * Menu component that handles the functionality expected of a standard
 * "Windows" menu for MDI applications.
 *
 * @@author    Eduardo Francos (adapted from original implementation by Wolfram Kaiser)
 * @@created   2 mai 2002
 * @@version   <$CURRENT_VERSION$>
 */
public class CTXWindowMenu extends CTXCommandMenu {

	MDIDesktopPane desktop; //increased visibility to avoid compilation errors
	private CommandMenuItem cascadeCommand;
	private CommandMenuItem tileHCommand;
	private CommandMenuItem tileVCommand;
	private CommandMenuItem arrangeHCommand;
	private CommandMenuItem arrangeVCommand;
	private int staticItems;

	/**
	 *Constructor for the CTXWindowsMenu object
	 *
	 * @@param newText  the menu's text
	 * @@param desktop  the MDI desktop
	 * @@param editor   the editor
	 */
	public CTXWindowMenu(String newText, MDIDesktopPane newDesktop, DrawingEditor newEditor) {
		super(newText);
		this.desktop = newDesktop;

		cascadeCommand = new CommandMenuItem(
			new AbstractCommand("Cascade", newEditor) {
				public void execute() {
					CTXWindowMenu.this.desktop.cascadeFrames();
				}

				public boolean isExecutable() {
					return super.isExecutable() && (CTXWindowMenu.this.desktop.getAllFrames().length > 0);
				}
			});

		tileHCommand = new CommandMenuItem(
			new AbstractCommand("Tile Horizontally", newEditor) {
				public void execute() {
					CTXWindowMenu.this.desktop.tileFramesHorizontally();
				}

				public boolean isExecutable() {
					return super.isExecutable() && (CTXWindowMenu.this.desktop.getAllFrames().length > 0);
				}
			});

		tileVCommand = new CommandMenuItem(
			new AbstractCommand("Tile Vertically", newEditor) {
				public void execute() {
					CTXWindowMenu.this.desktop.tileFramesVertically();
				}

				public boolean isExecutable() {
					return super.isExecutable() && (CTXWindowMenu.this.desktop.getAllFrames().length > 0);
				}
			});

		arrangeHCommand = new CommandMenuItem(
			new AbstractCommand("Arrange Horizontally", newEditor) {
				public void execute() {
					CTXWindowMenu.this.desktop.arrangeFramesHorizontally();
				}

				public boolean isExecutable() {
					return super.isExecutable() && (CTXWindowMenu.this.desktop.getAllFrames().length > 0);
				}
			});

		arrangeVCommand = new CommandMenuItem(
			new AbstractCommand("Arrange Vertically", newEditor) {
				public void execute() {
					CTXWindowMenu.this.desktop.arrangeFramesVertically();
				}

				public boolean isExecutable() {
					return super.isExecutable() && (CTXWindowMenu.this.desktop.getAllFrames().length > 0);
				}
			});

		addMenuListener(
			new MenuListener() {
				public void menuCanceled(MenuEvent e) { }

				public void menuDeselected(MenuEvent e) {
					removeWindowsList();
				}

				public void menuSelected(MenuEvent e) {
					buildChildMenus();
				}
			});

		add(cascadeCommand);
		add(tileHCommand);
		add(tileVCommand);
		add(arrangeHCommand);
		add(arrangeVCommand);
		staticItems = 5;
	}

	/** removes the windows names */
	protected void removeWindowsList() {
		// remove all items above static the items
		while (this.getItemCount() > staticItems) {
			remove(staticItems);
		}
	}

	/*
	 *  Sets up the children menus depending on the current desktop state
	 */
	/** Description of the Method */
	void buildChildMenus() { //increased visibility to avoid compilation errors
		JInternalFrame[] array = desktop.getAllFrames();

		// update window organization commands
		cascadeCommand.setEnabled(array.length > 0);
		tileHCommand.setEnabled(array.length > 0);
		tileVCommand.setEnabled(array.length > 0);
		arrangeHCommand.setEnabled(array.length > 0);
		arrangeVCommand.setEnabled(array.length > 0);

		if (array.length == 0) {
			return;
		}

		addSeparator();

		for (int i = 0; i < array.length; i++) {
			ChildMenuItem menu = new ChildMenuItem(array[i]);
			menu.setState(i == 0);
			menu.addActionListener(
				new ActionListener() {
					public void actionPerformed(ActionEvent ae) {
						JInternalFrame frame = ((ChildMenuItem)ae.getSource()).getFrame();
						frame.moveToFront();
						try {
							frame.setSelected(true);
						}
						catch (PropertyVetoException e) {
							e.printStackTrace();
						}
					}
				});
			menu.setIcon(array[i].getFrameIcon());
			add(menu);
		}
	}

	/*
	 *  This JCheckBoxMenuItem descendant is used to track the child frame that corresponds
	 *  to a give menu.
	 */
	class ChildMenuItem extends JCheckBoxMenuItem {
		private JInternalFrame frame;

		/**
		 *Constructor for the ChildMenuItem object
		 *
		 * @@param frame  Description of the Parameter
		 */
		public ChildMenuItem(JInternalFrame newFrame) {
			super(newFrame.getTitle());
			frame = newFrame;
		}

		/**
		 * Gets the frame attribute of the ChildMenuItem object
		 *
		 * @@return   The frame value
		 */
		public JInternalFrame getFrame() {
			return frame;
		}
	}
}
@


1.3
log
@Refactoring of Cursor:
- java.awt.Cursor (class) has been sistematically replaced with CH.ifa.draw.contrib.framework.Cursor (interface)
- a new default implementation of Cursor (interface) has been added: CH.ifa.draw.contrib.standard.AWTCursor
@
text
@d188 3
a190 3
		public ChildMenuItem(JInternalFrame frame) {
			super(frame.getTitle());
			this.frame = frame;
@


1.2
log
@after variou merges... (before 5.4 release)
@
text
@d31 2
a32 1
	private MDIDesktopPane desktop;
d139 1
a139 1
	private void buildChildMenus() {
@


1.1
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@a20 1
import CH.ifa.draw.util.Command;
a38 1

d46 1
a46 1
	public CTXWindowMenu(String newText, MDIDesktopPane desktop, DrawingEditor editor) {
d48 1
a48 1
		this.desktop = desktop;
d50 2
a51 3
		cascadeCommand =
				new CommandMenuItem(
			new AbstractCommand("Cascade", editor) {
a55 1

d61 2
a62 3
		tileHCommand =
				new CommandMenuItem(
			new AbstractCommand("Tile Horizontally", editor) {
a66 1

d72 2
a73 3
		tileVCommand =
				new CommandMenuItem(
			new AbstractCommand("Tile Vertically", editor) {
a77 1

d83 2
a84 3
		arrangeHCommand =
				new CommandMenuItem(
			new AbstractCommand("Arrange Horizontally", editor) {
a88 1

d94 2
a95 3
		arrangeVCommand =
				new CommandMenuItem(
			new AbstractCommand("Arrange Vertically", editor) {
a99 1

a108 1

a112 1

a125 1

a133 1

a138 1
		ChildMenuItem menu;
d155 1
a155 1
			menu = new ChildMenuItem(array[i]);
a174 1

a178 6
	/**
	 * Description of the Class
	 *
	 * @@author    gualo
	 * @@created   2 mai 2002
	 */
a181 1

a190 1

@

