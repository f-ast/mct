head	1.9;
access;
symbols
	jhotdraw60b1-release:1.9
	package_rename:1.9
	directory_rename:1.8
	reorg_6x_split_initial:1.8
	MVC_PHASE1:1.7.0.10
	NEW_ATTRIBUTES:1.7.0.8
	DNOYEB1_ALPHA-2:1.7
	release_JHD54b1:1.7
	BUGFIX_670992:1.7.0.6
	DNOYEB1_ALPHA-1:1.7
	dnoyeb1:1.7.0.4
	repack:1.7.0.2
	Root_repack:1.7
	Before_FigureVisitor:1.7
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.13.22.31.11;	author mtnygard;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.14.09.01.58;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.44.32;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;


desc
@@


1.9
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)PolyLineFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.figures;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;

// JUnitDoclet begin import
import org.jhotdraw.framework.Connector;
import org.jhotdraw.framework.FigureAttributeConstant;
import org.jhotdraw.framework.HandleEnumeration;
import org.jhotdraw.framework.Locator;
import org.jhotdraw.standard.AbstractFigure;
import org.jhotdraw.standard.HandleEnumerator;
import org.jhotdraw.util.CollectionsFactory;
import org.jhotdraw.util.Geom;
import org.jhotdraw.util.StorableInput;
import org.jhotdraw.util.StorableOutput;
// JUnitDoclet end import

/**
 * A poly line figure consists of a list of points.
 * It has an optional line decoration at the start and end.
 *
 * @@see LineDecoration
 *
 * @@version <$CURRENT_VERSION$>
 */
public  class PolyLineFigure extends AbstractFigure {

	public final static int ARROW_TIP_NONE  = 0;
	public final static int ARROW_TIP_START = 1;
	public final static int ARROW_TIP_END   = 2;
	public final static int ARROW_TIP_BOTH  = 3;

	protected List                fPoints;
	protected LineDecoration      fStartDecoration = null;
	protected LineDecoration      fEndDecoration = null;
	protected Color               fFrameColor = Color.black;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = -7951352179906577773L;
	private int polyLineFigureSerializedDataVersion = 1;

	public PolyLineFigure() {
		this(4);
	}

	public PolyLineFigure(int size) {
		fPoints = CollectionsFactory.current().createList(size);
	}

	public PolyLineFigure(int x, int y) {
		fPoints = CollectionsFactory.current().createList();
		fPoints.add(new Point(x, y));
	}

	public Rectangle displayBox() {
		Iterator iter = points();
		if (iter.hasNext()) {
			// avoid starting with origin 0,0 because that would lead to a too large rectangle
			Rectangle r = new Rectangle((Point)iter.next());

			while (iter.hasNext()) {
				r.add((Point)iter.next());
			}

			return r;
		}
		else {
			return new Rectangle();
		}
	}

	public boolean isEmpty() {
		return (size().width < 3) && (size().height < 3);
	}

	public HandleEnumeration handles() {
		List handles = CollectionsFactory.current().createList(fPoints.size());
		for (int i = 0; i < fPoints.size(); i++) {
			handles.add(new PolyLineHandle(this, locator(i), i));
		}
		return new HandleEnumerator(handles);
	}

	public void basicDisplayBox(Point origin, Point corner) {
	}

	/**
	 * Adds a node to the list of points.
	 */
	public void addPoint(int x, int y) {
		fPoints.add(new Point(x, y));
		changed();
	}

	public Iterator points() {
		return fPoints.iterator();
	}

	public int pointCount() {
		return fPoints.size();
	}

	protected void basicMoveBy(int dx, int dy) {
		Iterator iter = points();
		while (iter.hasNext()) {
			((Point)iter.next()).translate(dx, dy);
		}
	}

	/**
	 * Changes the position of a node.
	 */
	public void setPointAt(Point p, int i) {
		willChange();
		fPoints.set(i, p);
		changed();
	}

	/**
	 * Insert a node at the given point.
	 */
	public void insertPointAt(Point p, int i) {
		fPoints.add(i, p);
		changed();
	}

	public void removePointAt(int i) {
		willChange();
		fPoints.remove(i);
		changed();
	}

	/**
	 * Splits the segment at the given point if a segment was hit.
	 * @@return the index of the segment or -1 if no segment was hit.
	 */
	public int splitSegment(int x, int y) {
		int i = findSegment(x, y);
		if (i != -1) {
			insertPointAt(new Point(x, y), i+1);
		}
		return i+1;
	}

	public Point pointAt(int i) {
		return (Point)fPoints.get(i);
	}

	/**
	 * Joins to segments into one if the given point hits a node
	 * of the polyline.
	 * @@return true if the two segments were joined.
	 */
	public boolean joinSegments(int x, int y) {
		for (int i= 1; i < fPoints.size()-1; i++) {
			Point p = pointAt(i);
			if (Geom.length(x, y, p.x, p.y) < 3) {
				removePointAt(i);
				return true;
			}
		}
		return false;
	}

	public Connector connectorAt(int x, int y) {
		return new PolyLineConnector(this);
	}

	/**
	 * Sets the start decoration.
	 */
	public void setStartDecoration(LineDecoration l) {
		fStartDecoration = l;
	}

	/**
	 * Returns the start decoration.
	 */
	public LineDecoration getStartDecoration() {
		return fStartDecoration;
	}

	/**
	 * Sets the end decoration.
	 */
	public void setEndDecoration(LineDecoration l) {
		fEndDecoration = l;
	}

	/**
	 * Returns the end decoration.
	 */
	public LineDecoration getEndDecoration() {
		return fEndDecoration;
	}

	public void draw(Graphics g) {
		g.setColor(getFrameColor());
		Point p1, p2;
		for (int i = 0; i < fPoints.size()-1; i++) {
			p1 = pointAt(i);
			p2 = pointAt(i+1);
			drawLine(g, p1.x, p1.y, p2.x, p2.y);
		}
		decorate(g);
	}

	/**
	 * Can be overriden in subclasses to draw different types of lines
	 * (e.g. dotted lines)
	 */
	protected void drawLine(Graphics g, int x1, int y1, int x2, int y2) {
		g.drawLine(x1, y1, x2, y2);
	}

	public boolean containsPoint(int x, int y) {
		Rectangle bounds = displayBox();
		bounds.grow(4,4);
		if (!bounds.contains(x, y)) {
			return false;
		}

		for (int i = 0; i < fPoints.size()-1; i++) {
			Point p1 = pointAt(i);
			Point p2 = pointAt(i+1);
			if (Geom.lineContainsPoint(p1.x, p1.y, p2.x, p2.y, x, y)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Gets the segment of the polyline that is hit by
	 * the given point.
	 * @@return the index of the segment or -1 if no segment was hit.
	 */
	public int findSegment(int x, int y) {
		for (int i = 0; i < fPoints.size()-1; i++) {
			Point p1 = pointAt(i);
			Point p2 = pointAt(i+1);
			if (Geom.lineContainsPoint(p1.x, p1.y, p2.x, p2.y, x, y)) {
				return i;
			}
		}
		return -1;
	}

	private void decorate(Graphics g) {
		if (getStartDecoration() != null) {
			Point p1 = pointAt(0);
			Point p2 = pointAt(1);
			getStartDecoration().draw(g, p1.x, p1.y, p2.x, p2.y);
		}
		if (getEndDecoration() != null) {
			Point p3 = pointAt(fPoints.size()-2);
			Point p4 = pointAt(fPoints.size()-1);
			getEndDecoration().draw(g, p4.x, p4.y, p3.x, p3.y);
		}
	}

	/**
	 * Gets the attribute with the given name.
	 * PolyLineFigure maps "ArrowMode"to a
	 * line decoration.
	 *
	 * @@deprecated use getAttribute(FigureAttributeConstant) instead
	 */
	public Object getAttribute(String name) {
		return getAttribute(FigureAttributeConstant.getConstant(name));
	}

	/**
	 * Gets the attribute with the given name.
	 * PolyLineFigure maps "ArrowMode"to a
	 * line decoration.
	 */
	public Object getAttribute(FigureAttributeConstant attributeConstant) {
		if (attributeConstant.equals(FigureAttributeConstant.FRAME_COLOR)) {
			return getFrameColor();
		}
		else if (attributeConstant.equals(FigureAttributeConstant.ARROW_MODE)) {
			int value = 0;
			if (getStartDecoration() != null) {
				value |= ARROW_TIP_START;
			}
			if (getEndDecoration() != null) {
				value |= ARROW_TIP_END;
			}
			return new Integer(value);
		}
		return super.getAttribute(attributeConstant);
	}

	/**
	 * Sets the attribute with the given name.
	 * PolyLineFigure interprets "ArrowMode"to set
	 * the line decoration.
	 *
	 * @@deprecated use setAttribute(FigureAttributeConstant, Object) instead
	 */
	public void setAttribute(String name, Object value) {
		setAttribute(FigureAttributeConstant.getConstant(name), value);
	}

	/**
	 * Sets the attribute with the given name.
	 * PolyLineFigure interprets "ArrowMode"to set
	 * the line decoration.
	 */
	public void setAttribute(FigureAttributeConstant attributeConstant, Object value) {
		if (attributeConstant.equals(FigureAttributeConstant.FRAME_COLOR)) {
			setFrameColor((Color)value);
			changed();
		}
		else if (attributeConstant.equals(FigureAttributeConstant.ARROW_MODE)) {
			Integer intObj = (Integer)value;
			if (intObj != null) {
				int decoration = intObj.intValue();
				if ((decoration & ARROW_TIP_START) != 0) {
					setStartDecoration(new ArrowTip());
				}
				else {
					setStartDecoration(null);
				}
				if ((decoration & ARROW_TIP_END) != 0) {
					setEndDecoration(new ArrowTip());
				}
				else {
					setEndDecoration(null);
				}
			}
			changed();
		}
		else {
			super.setAttribute(attributeConstant, value);
		}
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fPoints.size());
		Iterator iter = points();
		while (iter.hasNext()) {
			Point p = (Point)iter.next();
			dw.writeInt(p.x);
			dw.writeInt(p.y);
		}
		dw.writeStorable(fStartDecoration);
		dw.writeStorable(fEndDecoration);
		dw.writeColor(fFrameColor);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		int size = dr.readInt();
		fPoints = CollectionsFactory.current().createList(size);
		for (int i=0; i<size; i++) {
			int x = dr.readInt();
			int y = dr.readInt();
			fPoints.add(new Point(x,y));
		}
		setStartDecoration((LineDecoration)dr.readStorable());
		setEndDecoration((LineDecoration)dr.readStorable());
		fFrameColor = dr.readColor();
	}

	/**
	 * Creates a locator for the point with the given index.
	 */
	public static Locator locator(int pointIndex) {
		return new PolyLineLocator(pointIndex);
	}

	protected Color getFrameColor() {
		return fFrameColor;
	}

	protected void setFrameColor(Color c) {
		fFrameColor = c;
	}

	/**
	 * Hook method to change the rectangle that will be invalidated
	 */
	protected Rectangle invalidateRectangle(Rectangle r) {
		// SF-bug id: 533953: provide this method to customize invalidated rectangle
		Rectangle parentR = super.invalidateRectangle(r);
		if (getStartDecoration() != null) {
			parentR.add(getStartDecoration().displayBox());
		}
		if (getEndDecoration() != null) {
			parentR.add(getEndDecoration().displayBox());
		}
		return parentR;
	}
}
@


1.8
log
@Eliminate some deprecated method warnings.
Organize imports to remove Eclipse warnings about unused imports.
@
text
@d12 1
a12 1
package CH.ifa.draw.figures;
d23 10
a32 10
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.FigureAttributeConstant;
import CH.ifa.draw.framework.HandleEnumeration;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.AbstractFigure;
import CH.ifa.draw.standard.HandleEnumerator;
import CH.ifa.draw.util.CollectionsFactory;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;
@


1.7
log
@no message
@
text
@d14 4
a17 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.*;
import java.awt.*;
d19 1
d21 13
a33 1
import java.util.Iterator;
@


1.6
log
@after variou merges... (before 5.4 release)
@
text
@d322 1
a322 1
		else if (attributeConstant.equals(FigureAttributeConstant.ARROW_MODE.getName())) {
@


1.5
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@a13 3
import java.awt.*;
import java.util.*;
import java.io.IOException;
d17 4
d37 1
a37 1
	protected Vector              fPoints;
d49 1
a49 1
		fPoints = new Vector(4);
d53 1
a53 1
		fPoints = new Vector(size);
d57 2
a58 2
		fPoints = new Vector();
		fPoints.addElement(new Point(x, y));
d62 4
a65 2
		Enumeration k = points();
		Rectangle r = new Rectangle();
d67 8
a74 2
		while (k.hasMoreElements()) {
			r.add((Point) k.nextElement());
a75 2

		return r;
d82 2
a83 2
	public Vector handles() {
		Vector handles = new Vector(fPoints.size());
d85 1
a85 1
			handles.addElement(new PolyLineHandle(this, locator(i), i));
d87 1
a87 1
		return handles;
d97 1
a97 1
		fPoints.addElement(new Point(x, y));
d101 2
a102 2
	public Enumeration points() {
		return fPoints.elements();
d110 3
a112 3
		Enumeration k = fPoints.elements();
		while (k.hasMoreElements()) {
			((Point) k.nextElement()).translate(dx, dy);
d121 1
a121 1
		fPoints.setElementAt(p, i);
d129 1
a129 1
		fPoints.insertElementAt(p, i);
d135 1
a135 1
		fPoints.removeElementAt(i);
d152 1
a152 1
		return (Point)fPoints.elementAt(i);
d207 2
a208 2
			p1 = (Point) fPoints.elementAt(i);
			p2 = (Point) fPoints.elementAt(i+1);
a228 1
		Point p1, p2;
d230 2
a231 2
			p1 = (Point) fPoints.elementAt(i);
			p2 = (Point) fPoints.elementAt(i+1);
a244 1
		Point p1, p2;
d246 2
a247 2
			p1 = (Point) fPoints.elementAt(i);
			p2 = (Point) fPoints.elementAt(i+1);
d257 2
a258 2
			Point p1 = (Point)fPoints.elementAt(0);
			Point p2 = (Point)fPoints.elementAt(1);
d262 2
a263 2
			Point p3 = (Point)fPoints.elementAt(fPoints.size()-2);
			Point p4 = (Point)fPoints.elementAt(fPoints.size()-1);
d349 3
a351 3
		Enumeration k = fPoints.elements();
		while (k.hasMoreElements()) {
			Point p = (Point) k.nextElement();
d363 1
a363 1
		fPoints = new Vector(size);
d367 1
a367 1
			fPoints.addElement(new Point(x,y));
d395 6
a400 2
		parentR.add(getStartDecoration().displayBox());
		parentR.add(getEndDecoration().displayBox());
@


1.4
log
@no message
@
text
@d62 1
a62 1
		Rectangle r = new Rectangle((Point) k.nextElement());
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@d181 1
a181 1
	
d195 1
a195 1
	
d207 1
a207 1
	/** 
d214 1
a214 1
	
d267 2
d271 10
a280 1
		if (name.equals("FrameColor")) {
d283 1
a283 1
		else if (name.equals("ArrowMode")) {
d293 1
a293 1
		return super.getAttribute(name);
d300 2
d304 10
a313 1
		if (name.equals("FrameColor")) {
d317 2
a318 2
		else if (name.equals("ArrowMode")) {
			Integer intObj = (Integer) value;
d337 1
a337 1
			super.setAttribute(name, value);
d382 11
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)PolyLineFigure.java 5.2
d4 6
d26 2
d31 23
a53 23
    public final static int ARROW_TIP_NONE  = 0;
    public final static int ARROW_TIP_START = 1;
    public final static int ARROW_TIP_END   = 2;
    public final static int ARROW_TIP_BOTH  = 3;

    protected Vector              fPoints;
    protected LineDecoration      fStartDecoration = null;
    protected LineDecoration      fEndDecoration = null;
    protected Color               fFrameColor = Color.black;

    /*
     * Serialization support.
     */
    private static final long serialVersionUID = -7951352179906577773L;
    private int polyLineFigureSerializedDataVersion = 1;

    public PolyLineFigure() {
        fPoints = new Vector(4);
    }

    public PolyLineFigure(int size) {
        fPoints = new Vector(size);
    }
d56 90
a145 2
	    fPoints = new Vector();
	    fPoints.addElement(new Point(x, y));
d148 26
a173 110
    public Rectangle displayBox() {
        Enumeration k = points();
        Rectangle r = new Rectangle((Point) k.nextElement());

        while (k.hasMoreElements())
            r.add((Point) k.nextElement());

        return r;
    }

    public boolean isEmpty() {
        return (size().width < 3) && (size().height < 3);
    }

    public Vector handles() {
        Vector handles = new Vector(fPoints.size());
        for (int i = 0; i < fPoints.size(); i++)
            handles.addElement(new PolyLineHandle(this, locator(i), i));
        return handles;
    }

    public void basicDisplayBox(Point origin, Point corner) {
    }

    /**
     * Adds a node to the list of points.
     */
    public void addPoint(int x, int y) {
        fPoints.addElement(new Point(x, y));
        changed();
    }

    public Enumeration points() {
        return fPoints.elements();
    }

    public int pointCount() {
        return fPoints.size();
    }

    protected void basicMoveBy(int dx, int dy) {
        Enumeration k = fPoints.elements();
        while (k.hasMoreElements())
            ((Point) k.nextElement()).translate(dx, dy);
    }

    /**
     * Changes the position of a node.
     */
    public void setPointAt(Point p, int i) {
        willChange();
        fPoints.setElementAt(p, i);
        changed();
    }

    /**
     * Insert a node at the given point.
     */
    public void insertPointAt(Point p, int i) {
        fPoints.insertElementAt(p, i);
        changed();
    }

    public void removePointAt(int i) {
        willChange();
        fPoints.removeElementAt(i);
        changed();
    }

    /**
     * Splits the segment at the given point if a segment was hit.
     * @@return the index of the segment or -1 if no segment was hit.
     */
    public int splitSegment(int x, int y) {
        int i = findSegment(x, y);
        if (i != -1)
            insertPointAt(new Point(x, y), i+1);
        return i+1;
    }

    public Point pointAt(int i) {
        return (Point)fPoints.elementAt(i);
    }

    /**
     * Joins to segments into one if the given point hits a node
     * of the polyline.
     * @@return true if the two segments were joined.
     */
    public boolean joinSegments(int x, int y) {
        for (int i= 1; i < fPoints.size()-1; i++) {
            Point p = pointAt(i);
            if (Geom.length(x, y, p.x, p.y) < 3) {
                removePointAt(i);
                return true;
            }
        }
        return false;
    }

    public Connector connectorAt(int x, int y) {
        return new PolyLineConnector(this);
    }

    /**
     * Sets the start decoration.
     */
    public void setStartDecoration(LineDecoration l) {
        fStartDecoration = l;
    }
d182 6
a187 6
    /**
     * Sets the end decoration.
     */
    public void setEndDecoration(LineDecoration l) {
        fEndDecoration = l;
    }
d196 6
a201 6
    public void draw(Graphics g) {
        g.setColor(getFrameColor());
        Point p1, p2;
        for (int i = 0; i < fPoints.size()-1; i++) {
            p1 = (Point) fPoints.elementAt(i);
            p2 = (Point) fPoints.elementAt(i+1);
d203 3
a205 3
        }
        decorate(g);
    }
d212 149
a360 139
        g.drawLine(x1, y1, x2, y2);
    }
    
    public boolean containsPoint(int x, int y) {
        Rectangle bounds = displayBox();
        bounds.grow(4,4);
        if (!bounds.contains(x, y))
            return false;

        Point p1, p2;
        for (int i = 0; i < fPoints.size()-1; i++) {
            p1 = (Point) fPoints.elementAt(i);
            p2 = (Point) fPoints.elementAt(i+1);
            if (Geom.lineContainsPoint(p1.x, p1.y, p2.x, p2.y, x, y))
                return true;
        }
        return false;
    }

    /**
     * Gets the segment of the polyline that is hit by
     * the given point.
     * @@return the index of the segment or -1 if no segment was hit.
     */
    public int findSegment(int x, int y) {
        Point p1, p2;
        for (int i = 0; i < fPoints.size()-1; i++) {
            p1 = (Point) fPoints.elementAt(i);
            p2 = (Point) fPoints.elementAt(i+1);
            if (Geom.lineContainsPoint(p1.x, p1.y, p2.x, p2.y, x, y))
                return i;
        }
        return -1;
    }

    private void decorate(Graphics g) {
        if (getStartDecoration() != null) {
            Point p1 = (Point)fPoints.elementAt(0);
            Point p2 = (Point)fPoints.elementAt(1);
            getStartDecoration().draw(g, p1.x, p1.y, p2.x, p2.y);
        }
        if (getEndDecoration() != null) {
            Point p3 = (Point)fPoints.elementAt(fPoints.size()-2);
            Point p4 = (Point)fPoints.elementAt(fPoints.size()-1);
            getEndDecoration().draw(g, p4.x, p4.y, p3.x, p3.y);
        }
    }

    /**
     * Gets the attribute with the given name.
     * PolyLineFigure maps "ArrowMode"to a
     * line decoration.
     */
    public Object getAttribute(String name) {
        if (name.equals("FrameColor")) {
            return getFrameColor();
        }
        else if (name.equals("ArrowMode")) {
            int value = 0;
            if (getStartDecoration() != null)
                value |= ARROW_TIP_START;
            if (getEndDecoration() != null)
                value |= ARROW_TIP_END;
            return new Integer(value);
        }
        return super.getAttribute(name);
    }

    /**
     * Sets the attribute with the given name.
     * PolyLineFigure interprets "ArrowMode"to set
     * the line decoration.
     */
    public void setAttribute(String name, Object value) {
        if (name.equals("FrameColor")) {
            setFrameColor((Color)value);
            changed();
        }
        else if (name.equals("ArrowMode")) {
            Integer intObj = (Integer) value;
            if (intObj != null) {
                int decoration = intObj.intValue();
                if ((decoration & ARROW_TIP_START) != 0)
                    setStartDecoration(new ArrowTip());
                else
                    setStartDecoration(null);
                if ((decoration & ARROW_TIP_END) != 0)
                    setEndDecoration(new ArrowTip());
                else
                    setEndDecoration(null);
            }
            changed();
        }
        else
            super.setAttribute(name, value);
    }

    public void write(StorableOutput dw) {
        super.write(dw);
        dw.writeInt(fPoints.size());
        Enumeration k = fPoints.elements();
        while (k.hasMoreElements()) {
            Point p = (Point) k.nextElement();
            dw.writeInt(p.x);
            dw.writeInt(p.y);
        }
        dw.writeStorable(fStartDecoration);
        dw.writeStorable(fEndDecoration);
        dw.writeColor(fFrameColor);
    }

    public void read(StorableInput dr) throws IOException {
        super.read(dr);
        int size = dr.readInt();
        fPoints = new Vector(size);
        for (int i=0; i<size; i++) {
            int x = dr.readInt();
            int y = dr.readInt();
            fPoints.addElement(new Point(x,y));
        }
        setStartDecoration((LineDecoration)dr.readStorable());
        setEndDecoration((LineDecoration)dr.readStorable());
        fFrameColor = dr.readColor();
    }

    /**
     * Creates a locator for the point with the given index.
     */
    public static Locator locator(int pointIndex) {
        return new PolyLineLocator(pointIndex);
    }

    protected Color getFrameColor() {
        return fFrameColor;
    }

    protected void setFrameColor(Color c) {
        fFrameColor = c;
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)PolyLineFigure.java 5.1
d163 7
d177 7
d190 1
a190 1
            g.drawLine(p1.x, p1.y, p2.x, p2.y);
d195 8
d236 1
a236 1
        if (fStartDecoration != null) {
d239 1
a239 1
            fStartDecoration.draw(g, p1.x, p1.y, p2.x, p2.y);
d241 1
a241 1
        if (fEndDecoration != null) {
d244 1
a244 1
            fEndDecoration.draw(g, p4.x, p4.y, p3.x, p3.y);
d259 1
a259 1
            if (fStartDecoration != null)
d261 1
a261 1
            if (fEndDecoration != null)
d283 1
a283 1
                    fStartDecoration = new ArrowTip();
d285 1
a285 1
                    fStartDecoration = null;
d287 1
a287 1
                    fEndDecoration = new ArrowTip();
d289 1
a289 1
                    fEndDecoration = null;
d320 2
a321 2
        fStartDecoration = (LineDecoration)dr.readStorable();
        fEndDecoration = (LineDecoration)dr.readStorable();
@


1.1.1.1
log
@
Initial revision.
@
text
@@
