head	1.9;
access;
symbols
	jhotdraw60b1-release:1.9
	package_rename:1.9
	directory_rename:1.8
	reorg_6x_split_initial:1.8
	MVC_PHASE1:1.8.0.4
	NEW_ATTRIBUTES:1.8.0.2
	DNOYEB1_ALPHA-2:1.7.4.7
	release_JHD54b1:1.8
	BUGFIX_670992:1.7.0.6
	DNOYEB1_ALPHA-1:1.7.4.4
	dnoyeb1:1.7.0.4
	repack:1.7.0.2
	Root_repack:1.7
	Before_FigureVisitor:1.7
	JHotDraw_5-3:1.6
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.30.00.27.32;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.25.12;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.29.13.42.13;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.7.4.1
date	2003.01.14.18.22.14;	author dnoyeb;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.01.15.21.04.11;	author dnoyeb;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2003.01.16.15.58.50;	author dnoyeb;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.01.21.00.04.09;	author dnoyeb;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2003.01.26.00.50.51;	author dnoyeb;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2003.01.26.15.58.49;	author dnoyeb;	state Exp;
branches;
next	1.7.4.7;

1.7.4.7
date	2003.01.27.17.56.51;	author dnoyeb;	state Exp;
branches;
next	1.7.4.8;

1.7.4.8
date	2003.02.02.16.54.06;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.9
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)UngroupCommand.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.figures;

import org.jhotdraw.framework.*;
import org.jhotdraw.standard.*;
import org.jhotdraw.util.UndoableAdapter;
import org.jhotdraw.util.Undoable;

/**
 * Command to ungroup the selected figures.
 *
 * @@see GroupCommand
 *
 * @@version <$CURRENT_VERSION$>
 */
public  class UngroupCommand extends AbstractCommand {

	/**
	 * Constructs a group command.
	 * @@param name the command name
	 * @@param newDrawingEditor the DrawingEditor which manages the views
	 */
	public UngroupCommand(String name, DrawingEditor newDrawingEditor) {
		super(name, newDrawingEditor);
	}

	public void execute() {
		super.execute();
		setUndoActivity(createUndoActivity());
		// selection of group figures
		getUndoActivity().setAffectedFigures(view().selection());
		view().clearSelection();

		((UngroupCommand.UndoActivity)getUndoActivity()).ungroupFigures();
		view().checkDamage();
	}

	public boolean isExecutableWithView() {
		FigureEnumeration fe = view().selection();
		while (fe.hasNextFigure()) {
			Figure currentFigure = fe.nextFigure();
			currentFigure = currentFigure.getDecoratedFigure();

			if (!(currentFigure instanceof GroupFigure)) {
				return false;
			}
		}

		return view().selectionCount() > 0;

	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new UngroupCommand.UndoActivity(view());
	}

	public static class UndoActivity extends UndoableAdapter {
		public UndoActivity(DrawingView newDrawingView) {
			super(newDrawingView);
			setUndoable(true);
			setRedoable(true);
		}

		public boolean undo() {
			if (!super.undo()) {
				return false;
			}
			getDrawingView().clearSelection();

			FigureEnumeration groupFigures = getAffectedFigures();
			while (groupFigures.hasNextFigure()) {
				Figure groupFigure = groupFigures.nextFigure();
				// orphan individual figures from the group
				getDrawingView().drawing().orphanAll(groupFigure.figures());

				Figure figure = getDrawingView().drawing().add(groupFigure);
				getDrawingView().addToSelection(figure);
			}

			return true;
		}

		public boolean redo() {
			// do not call execute directly as the selection might has changed
			if (isRedoable()) {
				getDrawingView().drawing().orphanAll(getAffectedFigures());
				getDrawingView().clearSelection();
				ungroupFigures();
				return true;
			}
			return false;
		}

		protected void ungroupFigures() {
			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				Figure selected = fe.nextFigure();
				Figure group = getDrawingView().drawing().orphan(selected);

				getDrawingView().drawing().addAll(group.figures());
				getDrawingView().addToSelectionAll(group.figures());
			}
		}
	}
}
@


1.8
log
@prepare for 5.4 release: various bug fixes
@
text
@d12 1
a12 1
package CH.ifa.draw.figures;
d14 4
a17 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.UndoableAdapter;
import CH.ifa.draw.util.Undoable;
@


1.7
log
@after variou merges... (before 5.4 release)
@
text
@d52 1
a52 3
			if (currentFigure instanceof DecoratorFigure) {
				currentFigure = ((DecoratorFigure)currentFigure).getDecoratedFigure();
			}
@


1.7.4.1
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d90 3
a92 4
				//This tool is now responsible for the release or readd of the figures it just removed
				//!!!dnoyeb!!!
				getDrawingView().drawing().add(groupFigure);
				getDrawingView().addToSelection(groupFigure);
a101 2
				//this tool is now responsible for the release or readd of the figures it removed
				//!!!dnoyeb!!!
d113 4
a116 5
				getDrawingView().drawing().orphan(selected);
				//this tool is now responsible for the release or readd of the figure it removed
				//!!!dnoyeb!!!
				getDrawingView().drawing().addAll(selected.figures());
				getDrawingView().addToSelectionAll(selected.figures());
@


1.7.4.2
log
@
Lets have a moment of silence for DecoratorFigure.....It was a good figure ;{

Anything which happens inside the drawing after figure add must be undone before figure orphan.  It must also not
be exposed to anyobject outside the drawing.
Decorator figure retired in favor of a figureManipulator and the other functions being implemented by a composite
figure(BorderDecorator).
AdnimationDecorator retired in favor of AnimationManipulator.
A figure can have only 1 container. This is making the border tool have a hard time.

Lots of comments added

next phase:
orphan will disappear.  only add and remove remain.  All figure related resources belong to the figures and no other
object should care about figure.release.
split the figureListener into a figureContainer listener and a figureChangeListener.
Fix BorderDecorator.
Fix ConnectedText.
view.checkDamage to call drawing.update()
@
text
@d52 4
@


1.7.4.3
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d45 1
a45 1
		view().drawing().update();
@


1.7.4.4
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@a51 3
			if (currentFigure instanceof DecoratorFigure) {
				currentFigure = ((DecoratorFigure)currentFigure).getDecoratedFigure();
			}
d86 1
a86 1
				//This tool is now responsible for the release or readd of the figures it just orphaned
d88 2
a89 2
				Figure figure = getDrawingView().drawing().add(groupFigure);
				getDrawingView().addToSelection(figure);
d99 1
a99 1
				//this tool is now responsible for the release or readd of the figures it orphaned
a107 3
		/**
		 * @@todo fix this because components can not belong to more than 1 figure.
		 */
d113 1
a113 1
				//this tool is now responsible for the release or readd of the figure it orphaned
d115 2
a116 8
				FigureEnumeration feToRemove = selected.figures();
				FigureEnumeration feToAdd = selected.figures();
				FigureEnumeration feToSelect = selected.figures();
				if(selected instanceof CompositeFigure){
					((CompositeFigure)selected).orphanAll( feToRemove );
				}
				getDrawingView().drawing().addAll(feToAdd);
				getDrawingView().addToSelectionAll(feToSelect);
@


1.7.4.5
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d18 1
a18 2
import java.util.*;
import CH.ifa.draw.util.CollectionsFactory;
a71 1
		private Map groupFigureMap = CollectionsFactory.current().createMap();
a81 1
			List affectedFigures = CollectionsFactory.current().createList();
d83 10
a92 20
			//get the figures to regroup from the Map
			Set keySet = groupFigureMap.keySet();
			for(Iterator it = keySet.iterator();it.hasNext();){
				//get the former group figure
				GroupFigure groupFigure = (GroupFigure)it.next();
				//get the figures it used to contain, and empty the map too
				FigureEnumeration fe = (FigureEnumeration)groupFigureMap.remove(groupFigure);
				while(fe.hasNextFigure()){
					Figure f2 = fe.nextFigure();
					//orphan the figure from the drawing
					getDrawingView().drawing().orphan(f2);
					//restore the figure to the group figure
					groupFigure.restore( f2 );
				}
				//restore the groupFigure to the drawing
				getDrawingView().drawing().restore(groupFigure);
				//add the group figure to the selection
				getDrawingView().addToSelection(groupFigure);
				//add the figure to the affected figures.
				affectedFigures.add( groupFigure );
d94 1
a94 2
			setAffectedFigures(new FigureEnumerator( affectedFigures ));
			//groupFigureMap should be empty, no need to manipulate it.
d101 3
d112 1
a112 1
		 *
a114 1
			//get the GroupFigures
d117 9
a125 15
				List affectedFigures = CollectionsFactory.current().createList();
				//remove the GroupFigure from the drawing
				GroupFigure groupFigure = (GroupFigure) fe.nextFigure(); //Note:  isExecutableWithView() guarantees this cast
				getDrawingView().drawing().orphan(groupFigure);
				//get a copy of the contained figures to add to the drawing
				FigureEnumeration feToAdd = groupFigure.figures();
				//add the freshly removed figures to the Drawing and select them, and add them to affected figures
				while(feToAdd.hasNextFigure()){
					Figure f2 = feToAdd.nextFigure();
					//remove f2 from current container.
					groupFigure.orphan( f2 );
					//add f2 to drawing
					getDrawingView().drawing().add(f2);
					getDrawingView().addToSelection(f2);
					affectedFigures.add(f2);
d127 2
a128 2
				//add the groupFigure, along with the figures it used to own to the map.
				groupFigureMap.put(groupFigure,new FigureEnumerator(affectedFigures));
a129 21
		}
		
		/**
		 * If undo was last their should be nothing to release, the keySet should be empty
		 */
		public void release() {
			//if we have group figures stored prepared for an undo/regroup type action, remove them
			Set keySet = groupFigureMap.keySet();
			for(Iterator it = keySet.iterator();it.hasNext();){
				//get the group figure
				GroupFigure gf = (GroupFigure) (GroupFigure) it.next();
				//get its former figures
				FigureEnumeration fe = (FigureEnumeration)groupFigureMap.remove( gf );
				//remove the figures it used to contain permanently from it
				gf.removeAll( fe );
				//Permanently remove the groupFigure from the drawing
				getDrawingView().drawing().remove( gf );
			}
			groupFigureMap = null; //so we throw NPE if this command is reexecuted after release (better would be JHDillegalstateException)
			setDrawingView(null);
			setAffectedFigures(null);
@


1.7.4.6
log
@hack for [ 674973 ] Context Sensitive menu updates
add used instead of restore since its easier for the CompositeFigure to decide wether to add or
to restore.
@
text
@d98 1
a98 1
					groupFigure.add( f2 );
d101 1
a101 1
				getDrawingView().drawing().add(groupFigure);
@


1.7.4.7
log
@Affected figures are not allowed to be null.  Use empty enumeration.
@
text
@d168 1
a168 1
			setAffectedFigures(FigureEnumerator.getEmptyEnumeration());
@


1.7.4.8
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@a73 1
		boolean undone = false;
a108 1
			undone = true;
a116 1
				undone = false;
d154 11
a164 16
			if(undone == false){
				//if we have group figures stored prepared for an undo/regroup type action, remove them
				Set keySet = groupFigureMap.keySet();
				for(Iterator it = keySet.iterator();it.hasNext();){
					//get the group figure
					GroupFigure gf = (GroupFigure) (GroupFigure) it.next();
					//get its former figures
					FigureEnumeration fe = (FigureEnumeration)groupFigureMap.remove( gf );
					//remove the figures it used to contain permanently from it
					gf.removeAll( fe );
					//Permanently remove the groupFigure from the drawing
					getDrawingView().drawing().remove( gf );
					//release the groupFigure
					gf.release();
					//we do not release the groupFigures old figures because they are in the drawing now.
				}
d167 2
a168 1
			super.release();
@


1.6
log
@merge dnd (before 5.3)
@
text
@a17 2
import java.awt.*;
import java.util.*;
d41 1
a41 1
		getUndoActivity().setAffectedFigures(view().selectionElements());
d49 2
a50 2
		FigureEnumeration fe = view().selectionElements();
		while (fe.hasMoreElements()) {
d55 1
a55 1
			
d60 1
a60 1
		
d84 1
a84 1
			
d86 1
a86 1
			while (groupFigures.hasMoreElements()) {
d90 1
a90 1
				
d94 1
a94 1
			
d97 1
a97 1
	
d111 6
a116 8
			if (fe.hasMoreElements()) {
				while (fe.hasMoreElements()) {
					Figure selected = fe.nextFigure();
					Figure group = getDrawingView().drawing().orphan(selected);
		
					getDrawingView().drawing().addAll(group.figures());
					getDrawingView().addToSelectionAll(group.figures());
				}            
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d30 15
a44 14
   /**
    * Constructs a group command.
    * @@param name the command name
    * @@param view the target view
    */
    public UngroupCommand(String name, DrawingView view) {
        super(name, view);
    }

    public void execute() {
    	setUndoActivity(createUndoActivity());
    	// selection of group figures
        getUndoActivity().setAffectedFigures(view().selectionElements());
        view().clearSelection();
d47 2
a48 2
        view().checkDamage();
    }
d50 14
a63 15
    public boolean isExecutable() {
    	FigureEnumeration fe = view().selectionElements();
    	while (fe.hasMoreElements()) {
    		Figure currentFigure = fe.nextFigure();
    		if (currentFigure instanceof DecoratorFigure) {
    			currentFigure = ((DecoratorFigure)currentFigure).getDecoratedFigure();
    		}
    		
    		if (!(currentFigure instanceof GroupFigure)) {
    			return false;
    		}
    	}
    	
    	return true;
//        return view().selectionCount() > 0;
d65 1
a65 1
    }
d85 10
a94 10
		    getDrawingView().clearSelection();
		    
		    FigureEnumeration groupFigures = getAffectedFigures();
		    while (groupFigures.hasMoreElements()) {
		    	Figure groupFigure = groupFigures.nextFigure();
		    	// orphan individual figures from the group
		    	getDrawingView().drawing().orphanAll(groupFigure.figures());
		    	
		        Figure figure = getDrawingView().drawing().add(groupFigure);
		        getDrawingView().addToSelection(figure);
d103 4
a106 4
	    	    getDrawingView().drawing().orphanAll(getAffectedFigures());
		        getDrawingView().clearSelection();
		        ungroupFigures();
		        return true;
d113 4
a116 4
	        if (fe.hasMoreElements()) {
		        while (fe.hasMoreElements()) {
		            Figure selected = fe.nextFigure();
		            Figure group = getDrawingView().drawing().orphan(selected);
d119 3
a121 3
		            getDrawingView().addToSelectionAll(group.figures());
		        }            
	        }
@


1.4
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)UngroupCommand.java 5.2
d4 6
d14 4
a19 2
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.Command;
d23 1
d25 2
d28 1
a28 3
public  class UngroupCommand extends Command {

    private DrawingView fView;
d36 1
a36 2
        super(name);
        fView = view;
d40 4
a43 2
        FigureEnumeration selection = fView.selectionElements();
        fView.clearSelection();
d45 2
a46 9
        Vector parts = new Vector();
        while (selection.hasMoreElements()) {
            Figure selected = selection.nextFigure();
            Figure group = fView.drawing().orphan(selected);
            FigureEnumeration k = group.decompose();
            while (k.hasMoreElements())
                fView.addToSelection(fView.add(k.nextFigure()));
        }
        fView.checkDamage();
d50 15
a64 1
        return fView.selectionCount() > 0;
d67 57
@


1.3
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d11 1
a11 1
import CH.ifa.draw.standard.AbstractCommand;
d17 3
a19 1
public  class UngroupCommand extends AbstractCommand {
d27 2
a28 1
        super(name, view);
d32 2
a33 2
        FigureEnumeration selection = view().selectionElements();
        view().clearSelection();
d38 1
a38 1
            Figure group = view().drawing().orphan(selected);
d41 1
a41 1
                view().addToSelection(view().add(k.nextFigure()));
d43 1
a43 1
        view().checkDamage();
d47 1
a47 1
        return view().selectionCount() > 0;
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d11 1
a11 1
import CH.ifa.draw.util.Command;
d17 1
a17 3
public  class UngroupCommand extends Command {

    private DrawingView fView;
d25 1
a25 2
        super(name);
        fView = view;
d29 2
a30 2
        FigureEnumeration selection = fView.selectionElements();
        fView.clearSelection();
d35 1
a35 1
            Figure group = fView.drawing().orphan(selected);
d38 1
a38 1
                fView.addToSelection(fView.add(k.nextFigure()));
d40 1
a40 1
        fView.checkDamage();
d44 1
a44 1
        return fView.selectionCount() > 0;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)UngroupCommand.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
