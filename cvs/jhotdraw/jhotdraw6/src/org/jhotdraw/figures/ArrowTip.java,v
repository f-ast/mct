head	1.5;
access;
symbols
	jhotdraw60b1-release:1.5
	package_rename:1.5
	directory_rename:1.4
	reorg_6x_split_initial:1.4
	MVC_PHASE1:1.4.0.10
	NEW_ATTRIBUTES:1.4.0.8
	DNOYEB1_ALPHA-2:1.4
	release_JHD54b1:1.4
	BUGFIX_670992:1.4.0.6
	DNOYEB1_ALPHA-1:1.4
	dnoyeb1:1.4.0.4
	repack:1.4.0.2
	Root_repack:1.4
	Before_FigureVisitor:1.4
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.44.32;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;


desc
@@


1.5
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)ArrowTip.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.figures;

import java.io.*;
import java.awt.*;

import org.jhotdraw.util.*;

/**
 * An arrow tip line decoration.
 *
 * @@see PolyLineFigure
 *
 * @@version <$CURRENT_VERSION$>
 */
public  class ArrowTip extends AbstractLineDecoration {

	private double  fAngle;         // pointiness of arrow
	private double  fOuterRadius;
	private double  fInnerRadius;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = -3459171428373823638L;
	private int arrowTipSerializedDataVersion = 1;

	public ArrowTip() {
		this(0.40, 8, 8);  // this(0.35, 15, 12);
	}

   /**
	* Constructs an arrow tip with the given angle and radius.
	*/
	public ArrowTip(double angle, double outerRadius, double innerRadius) {
		setAngle(angle);
		setOuterRadius(outerRadius);
		setInnerRadius(innerRadius);
	}
	
   /**
	* Calculates the outline of an arrow tip.
	*/
	public Polygon outline(int x1, int y1, int x2, int y2) {
		double dir = Math.PI/2 - Math.atan2(x2 - x1, y2 - y1);
		return outline(x1, y1, dir);
	}

	private Polygon outline(int x, int y, double direction) {
		Polygon shape = new Polygon();

		shape.addPoint(x, y);
		addPointRelative(shape, x, y, getOuterRadius(), direction - getAngle());
		addPointRelative(shape, x, y, getInnerRadius(), direction);
		addPointRelative(shape, x, y, getOuterRadius(), direction + getAngle());
		shape.addPoint(x,y); // Closing the polygon (TEG 97-04-23)
		return shape;
	}

	private void addPointRelative(Polygon shape, int x, int y, double radius, double angle) {
		shape.addPoint(
			x + (int) (radius * Math.cos(angle)),
			y + (int) (radius * Math.sin(angle)));
	}

	/**
	 * Stores the arrow tip to a StorableOutput.
	 */
	public void write(StorableOutput dw) {
		dw.writeDouble(getAngle());
		dw.writeDouble(getOuterRadius());
		dw.writeDouble(getInnerRadius());
		super.write(dw);
	}

	/**
	 * Reads the arrow tip from a StorableInput.
	 */
	public void read(StorableInput dr) throws IOException {
		setAngle(dr.readDouble());
		setOuterRadius(dr.readDouble());
		setInnerRadius(dr.readDouble());
		super.read(dr);
	}

	/**
	 * Sets point angle of arrow. A smaller angle leads to a pointier arrow.
	 * The angle is measured between the arrow line and one of the points
	 * at the side of the arrow. Thus, the total angle at the arrow tip
	 * is the double of the angle specified.
	 */
	protected void setAngle(double newAngle) {
		fAngle = newAngle;
	}
	
	/**
	 * Returns point angle of arrow. A smaller angle leads to a pointier arrow.
	 * The angle is measured between the arrow line and one of the points
	 * at the side of the arrow. Thus, the total angle at the arrow tip
	 * is the double of the angle specified.
	 */
	protected double getAngle() {
		return fAngle;
	}

	/**
	 * Sets the inner radius
	 */
	protected void setInnerRadius(double newInnerRadius) {
		fInnerRadius = newInnerRadius;
	}

	/**
	 * Returns the inner radius
	 */        
	protected double getInnerRadius() {
		return fInnerRadius;
	}

	/**
	 * Sets the outer radius
	 */
	protected void setOuterRadius(double newOuterRadius) {
		fOuterRadius = newOuterRadius;
	}

	/**
	 * Returns the outer radius
	 */
	protected double getOuterRadius() {
		return fOuterRadius;
	}
}
@


1.4
log
@after variou merges... (before 5.4 release)
@
text
@d12 1
a12 1
package CH.ifa.draw.figures;
d17 1
a17 1
import CH.ifa.draw.util.*;
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@a16 2
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)ArrowTip.java 5.2
d4 6
d23 1
d25 2
d30 9
a38 9
    private double  fAngle;         // pointiness of arrow
    private double  fOuterRadius;
    private double  fInnerRadius;

    /*
     * Serialization support.
     */
    private static final long serialVersionUID = -3459171428373823638L;
    private int arrowTipSerializedDataVersion = 1;
d41 1
a41 1
	    this(0.40, 8, 8);  // this(0.35, 15, 12);
d45 2
a46 2
    * Constructs an arrow tip with the given angle and radius.
    */
d48 3
a50 3
	    setAngle(angle);
	    setOuterRadius(outerRadius);
	    setInnerRadius(innerRadius);
d54 41
a94 41
    * Calculates the outline of an arrow tip.
    */
    public Polygon outline(int x1, int y1, int x2, int y2) {
        double dir = Math.PI/2 - Math.atan2(x2-x1, y2-y1);
        return outline(x1, y1, dir);
    }

    private Polygon outline(int x, int y, double direction) {
        Polygon shape = new Polygon();

        shape.addPoint(x, y);
        addPointRelative(shape, x, y, getOuterRadius(), direction - getAngle());
        addPointRelative(shape, x, y, getInnerRadius(), direction);
        addPointRelative(shape, x, y, getOuterRadius(), direction + getAngle());
        shape.addPoint(x,y); // Closing the polygon (TEG 97-04-23)
        return shape;
    }

    private void addPointRelative(Polygon shape, int x, int y, double radius, double angle) {
        shape.addPoint(
            x + (int) (radius * Math.cos(angle)),
            y + (int) (radius * Math.sin(angle)));
    }

    /**
     * Stores the arrow tip to a StorableOutput.
     */
    public void write(StorableOutput dw) {
        dw.writeDouble(getAngle());
        dw.writeDouble(getOuterRadius());
        dw.writeDouble(getInnerRadius());
        super.write(dw);
    }

    /**
     * Reads the arrow tip from a StorableInput.
     */
    public void read(StorableInput dr) throws IOException {
        setAngle(dr.readDouble());
        setOuterRadius(dr.readDouble());
        setInnerRadius(dr.readDouble());
d96 1
a96 1
    }
d103 5
a107 5
 	 */
    protected void setAngle(double newAngle) {
        fAngle = newAngle;
    }
    
d113 4
a116 4
 	 */
    protected double getAngle() {
    	return fAngle;
    }
d121 3
a123 3
    protected void setInnerRadius(double newInnerRadius) {
        fInnerRadius = newInnerRadius;
    }
d128 3
a130 3
    protected double getInnerRadius() {
    	return fInnerRadius;
    }
d135 3
a137 3
    protected void setOuterRadius(double newOuterRadius) {
        fOuterRadius = newOuterRadius;
    }
d142 3
a144 3
    protected double getOuterRadius() {
    	return fOuterRadius;
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)ArrowTip.java 5.1
d19 1
a19 1
public  class ArrowTip implements LineDecoration {
d32 1
a32 3
	    fAngle = 0.40;//0.35;
	    fOuterRadius = 8;//15;
	    fInnerRadius = 8;//12;
d39 3
a41 3
	    fAngle = angle;
	    fOuterRadius = outerRadius;
	    fInnerRadius = innerRadius;
d43 1
a43 11

   /**
    * Draws the arrow tip in the direction specified by the given two
    * points..
    */
    public void draw(Graphics g, int x1, int y1, int x2, int y2) {
        // TBD: reuse the Polygon object
        Polygon p = outline(x1, y1, x2, y2);
        g.fillPolygon(p.xpoints, p.ypoints, p.npoints);
    }

d48 1
a48 1
        double dir = Math.PI/2 - Math.atan2(x2-x1, y1-y2);
d56 3
a58 3
        addPointRelative(shape, x, y, fOuterRadius, direction - fAngle);
        addPointRelative(shape, x, y, fInnerRadius, direction);
        addPointRelative(shape, x, y, fOuterRadius, direction + fAngle);
d66 1
a66 1
            y - (int) (radius * Math.sin(angle)));
d73 4
d83 52
a135 1

@


1.1.1.1
log
@
Initial revision.
@
text
@@
