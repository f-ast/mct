head	1.9;
access;
symbols
	jhotdraw60b1-release:1.9
	package_rename:1.9
	directory_rename:1.8
	reorg_6x_split_initial:1.8
	MVC_PHASE1:1.8.0.4
	NEW_ATTRIBUTES:1.8.0.2
	DNOYEB1_ALPHA-2:1.7.4.4
	release_JHD54b1:1.8
	BUGFIX_670992:1.7.0.6
	DNOYEB1_ALPHA-1:1.7.4.4
	dnoyeb1:1.7.0.4
	repack:1.7.0.2
	Root_repack:1.7
	Before_FigureVisitor:1.6
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.30.00.27.32;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.22.08.58.23;	author mrfloppy;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.7.4.1
date	2003.01.10.04.54.38;	author dnoyeb;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.01.14.18.22.00;	author dnoyeb;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2003.01.16.15.58.50;	author dnoyeb;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.01.20.18.23.30;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.9
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)TextTool.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.figures;

import org.jhotdraw.framework.*;
import org.jhotdraw.standard.*;
import org.jhotdraw.util.FloatingTextField;
import org.jhotdraw.util.UndoableAdapter;
import org.jhotdraw.util.Undoable;
import java.awt.*;
import java.awt.event.*;

/**
 * Tool to create new or edit existing text figures.
 * The editing behavior is implemented by overlaying the
 * Figure providing the text with a FloatingTextField.<p>
 * A tool interaction is done once a Figure that is not
 * a TextHolder is clicked.
 *
 * @@see TextHolder
 * @@see FloatingTextField
 *
 * @@version <$CURRENT_VERSION$>
 */
public class TextTool extends CreationTool {

	private FloatingTextField   myTextField;
	private TextHolder  myTypingTarget;

	/**
	 * The selected figure is different from the TextHolder as the TextHolder
	 * may be included in a DecoratorFigure. Thus, the DecoratorFigure is selected
	 * while the TextFigure is edited.
	 */
	private Figure mySelectedFigure;

	public TextTool(DrawingEditor newDrawingEditor, Figure prototype) {
		super(newDrawingEditor, prototype);
	}

	/**
	 * If the pressed figure is a TextHolder it can be edited otherwise
	 * a new text figure is created.
	 */
	public void mouseDown(MouseEvent e, int x, int y)
	{
		setView((DrawingView)e.getSource());

		if (getTypingTarget() != null) {
			editor().toolDone();
			return;
		}

		TextHolder textHolder = null;
		Figure pressedFigure = drawing().findFigureInside(x, y);
		if (pressedFigure != null) {
			textHolder = pressedFigure.getTextHolder();
			setSelectedFigure(pressedFigure);
		}

		if ((textHolder != null) && textHolder.acceptsTyping()) {
			// do not create a new TextFigure but edit existing one
			beginEdit(textHolder);
		}
		else {
			super.mouseDown(e, x, y);
			// update view so the created figure is drawn before the floating text
			// figure is overlaid. (Note, fDamage should be null in StandardDrawingView
			// when the overlay figure is drawn because a JTextField cannot be scrolled)
			view().checkDamage();
			beginEdit(getCreatedFigure().getTextHolder());
		}
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
	}

	public void mouseUp(MouseEvent e, int x, int y) {
		if (!isActive()) {
			editor().toolDone();
		}
	}

	/**
	 * Terminates the editing of a text figure.
	 */
	public void deactivate() {
		endEdit();
        super.deactivate();
	}

	/**
	 * Sets the text cursor.
	 */
	public void activate() {
		super.activate();
		// JDK1.1 TEXT_CURSOR has an incorrect hot spot
		//view().setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
	}

	/**
	 * Test whether the text tool is currently activated and is displaying
	 * a overlay TextFigure for accepting input.
	 *
	 * @@return true, if the text tool has a accepting target TextFigure for its input, false otherwise
	 */
	public boolean isActive() {
		return (getTypingTarget() != null);
	}

	protected void beginEdit(TextHolder figure) {
		if (getFloatingTextField() == null) {
			setFloatingTextField(createFloatingTextField());
		}

		if (figure != getTypingTarget() && getTypingTarget() != null) {
			endEdit();
		}

		getFloatingTextField().createOverlay((Container)view(), figure.getFont());
		getFloatingTextField().setBounds(fieldBounds(figure), figure.getText());

		setTypingTarget(figure);
	}

	protected void endEdit() {
		if (getTypingTarget() != null) {
			if (getAddedFigure() != null) {
				if (!isDeleteTextFigure()) {
					// figure has been created and not immediately deleted
					setUndoActivity(createPasteUndoActivity());
					getUndoActivity().setAffectedFigures(
							new SingleFigureEnumerator(getAddedFigure())
					);
					getTypingTarget().setText(getFloatingTextField().getText());
				}
			}
			else if (isDeleteTextFigure()) {
				// delete action
				setUndoActivity(createDeleteUndoActivity());
				getUndoActivity().setAffectedFigures(
						new SingleFigureEnumerator(getSelectedFigure())
				);
				// perform delete operation of DeleteCommand.UndoActivity
				getUndoActivity().redo();
			}
			else {
				// put affected figure into a figure enumeration
				setUndoActivity(createUndoActivity());
				getUndoActivity().setAffectedFigures(
					new SingleFigureEnumerator(getTypingTarget().getRepresentingFigure()));
				getTypingTarget().setText(getFloatingTextField().getText());
				((TextTool.UndoActivity)getUndoActivity()).setBackupText(getTypingTarget().getText());
			}

			setTypingTarget(null);
			getFloatingTextField().endOverlay();
		}
		else {
			setUndoActivity(null);
		}
		setAddedFigure(null);
		setCreatedFigure(null);
		setSelectedFigure(null);
	}

	protected boolean isDeleteTextFigure() {
		return getFloatingTextField().getText().length() == 0;
	}

	private Rectangle fieldBounds(TextHolder figure) {
		Rectangle box = figure.textDisplayBox();
		int nChars = figure.overlayColumns();
		Dimension d = getFloatingTextField().getPreferredSize(nChars);
		return new Rectangle(box.x, box.y, d.width, d.height);
	}

	protected void setTypingTarget(TextHolder newTypingTarget) {
		myTypingTarget = newTypingTarget;
	}

	protected TextHolder getTypingTarget() {
		return myTypingTarget;
	}

	private void setSelectedFigure(Figure newSelectedFigure) {
		mySelectedFigure = newSelectedFigure;
	}

	protected Figure getSelectedFigure() {
		return mySelectedFigure;
	}

	private FloatingTextField createFloatingTextField() {
		return new FloatingTextField();
	}

	private void setFloatingTextField(FloatingTextField newFloatingTextField) {
		myTextField = newFloatingTextField;
	}

	protected FloatingTextField getFloatingTextField() {
		return myTextField;
	}

	protected Undoable createDeleteUndoActivity() {
		FigureTransferCommand cmd = new DeleteCommand("Delete", editor());
		return new DeleteCommand.UndoActivity(cmd);
	}

	protected Undoable createPasteUndoActivity() {
		return new PasteCommand.UndoActivity(view());
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new TextTool.UndoActivity(view(), getTypingTarget().getText());
	}

	public static class UndoActivity extends UndoableAdapter {
		private String myOriginalText;
		private String myBackupText;

		public UndoActivity(DrawingView newDrawingView, String newOriginalText) {
			super(newDrawingView);
			setOriginalText(newOriginalText);
			setUndoable(true);
			setRedoable(true);
		}

		/*
		 * Undo the activity
		 * @@return true if the activity could be undone, false otherwise
		 */
		public boolean undo() {
			if (!super.undo()) {
				return false;
			}

			getDrawingView().clearSelection();
			setText(getOriginalText());

			return true;
		}

		/*
		 * Redo the activity
		 * @@return true if the activity could be redone, false otherwise
		 */
		public boolean redo() {
			if (!super.redo()) {
				return false;
			}

			getDrawingView().clearSelection();
			setText(getBackupText());

			return true;
		}

		protected boolean isValidText(String toBeChecked) {
			return ((toBeChecked != null) && (toBeChecked.length() > 0));
		}

		protected void setText(String newText) {
			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				Figure currentFigure = fe.nextFigure();
				if (currentFigure.getTextHolder() != null) {
					currentFigure.getTextHolder().setText(newText);
				}
			}
		}

		public void setBackupText(String newBackupText) {
			myBackupText = newBackupText;
		}

		public String getBackupText() {
			return myBackupText;
		}

		public void setOriginalText(String newOriginalText) {
			myOriginalText = newOriginalText;
		}

		public String getOriginalText() {
			return myOriginalText;
		}
	}
}

@


1.8
log
@prepare for 5.4 release: various bug fixes
@
text
@d12 1
a12 1
package CH.ifa.draw.figures;
d14 5
a18 5
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.FloatingTextField;
import CH.ifa.draw.util.UndoableAdapter;
import CH.ifa.draw.util.Undoable;
@


1.7
log
@introduce FigureVisitor for paste/delete commands
@
text
@d39 7
d57 7
a64 1
		TextHolder textHolder = null;
d67 1
d71 1
a73 3
		else if (getTypingTarget() != null) {
			editor().toolDone();
		}
a132 2

		setUndoActivity(createUndoActivity());
d137 9
a145 2
			if (getFloatingTextField().getText().length() > 0) {
				getTypingTarget().setText(getFloatingTextField().getText());
d147 3
a149 7
			else {
				drawing().orphan(getAddedFigure());
			}

			TextTool.UndoActivity undoActivity = ((TextTool.UndoActivity)getUndoActivity());
			if ((undoActivity.getOriginalText() != null) || (getTypingTarget().getText() != null)) {
				// put created figure into a figure enumeration
d151 4
a154 2
					new SingleFigureEnumerator(getAddedFigure()));
				undoActivity.setBackupText(getTypingTarget().getText());
d157 6
a162 1
				setUndoActivity(null);
d168 10
d195 8
d215 9
d252 1
a252 18

			if (!isValidText(getOriginalText())) {
				FigureEnumeration fe  = getAffectedFigures();
				while (fe.hasNextFigure()) {
					getDrawingView().drawing().orphan(fe.nextFigure());
				}
			}
			// add text figure if it has been removed (no backup text)
			else if (!isValidText(getBackupText())) {
				FigureEnumeration fe  = getAffectedFigures();
				while (fe.hasNextFigure()) {
					getDrawingView().add(fe.nextFigure());
				}
				setText(getOriginalText());
			}
			else {
				setText(getOriginalText());
			}
d267 1
a267 19

			// the text figure did exist but was remove
			if (!isValidText(getBackupText())) {
				FigureEnumeration fe  = getAffectedFigures();
				while (fe.hasNextFigure()) {
					getDrawingView().drawing().orphan(fe.nextFigure());
				}
			}
			// the text figure didn't exist before
			else if (!isValidText(getOriginalText())) {
				FigureEnumeration fe  = getAffectedFigures();
				while (fe.hasNextFigure()) {
					getDrawingView().drawing().add(fe.nextFigure());
					setText(getBackupText());
				}
			}
			else {
				setText(getBackupText());
			}
@


1.7.4.1
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d20 1
a20 1

d47 1
a47 1
	public void mouseDown(DrawingViewMouseEvent dvme)
d49 2
a50 2
		setView( dvme.getDrawingView() );
		Figure pressedFigure = drawing().findFigureInside(dvme.getX(), dvme.getY());
d63 1
a63 1
			super.mouseDown(dvme);
d72 1
a72 1
	public void mouseDrag(DrawingViewMouseEvent dvme) {
d75 1
a75 1
	public void mouseUp(DrawingViewMouseEvent dvme) {
@


1.7.4.2
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@a131 2
				//this tool is now responsible for readding or releasing the figure it just removed.
				//if it does not support undo then it should release it now !!!dnoyeb!!!
d208 2
a209 2
				while(fe.hasNextFigure()){
					fe.nextFigure().remove();
a210 3
				//this tool is now responsible for the release or readd of the figures is just removed
				//!!!dnoyeb!!!
			
d241 2
a242 2
				while(fe.hasNextFigure()){
					fe.nextFigure().remove();
a243 3
				//this tool is now responsible for the release or readd of the figures it just removed
				//!!!dnoyeb!!!
			
@


1.7.4.3
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d67 1
a67 1
			view().checkDamage();//not truly necessary to update dwg yet, but it doesent hurt
@


1.7.4.4
log
@More cleanups for DecoratorFigure.  Its going to cause problems till the architecture changes.
Added a few needed methods to expose private variables of StandardDrawingView to make it more
override friendly.
@
text
@d210 3
a212 1
				getDrawingView().drawing().orphanAll( fe );
d246 3
a248 1
				getDrawingView().drawing().orphanAll( fe );
@


1.6
log
@after variou merges... (before 5.4 release)
@
text
@d50 1
d52 2
a53 6
		Figure pressedFigure = drawing().findFigureInside(x, y);
		if (pressedFigure instanceof TextHolder) {
			textHolder = (TextHolder)pressedFigure;
			if (!textHolder.acceptsTyping()) {
				textHolder = null;
			}
d55 2
a56 1
		if (textHolder != null) {
d60 1
a60 1
			deactivate();
d68 1
a68 2
			textHolder = (TextHolder)getCreatedFigure();
			beginEdit(textHolder);
d121 2
d131 2
a132 1
				drawing().orphan((Figure)getAddedFigure());
d134 9
a142 2
				// nothing to undo
//	            setUndoActivity(null);
a144 7
			// put created figure into a figure enumeration
			setUndoActivity(createUndoActivity());
			getUndoActivity().setAffectedFigures(
				new SingleFigureEnumerator(getAddedFigure()));
			((TextTool.UndoActivity)getUndoActivity()).setBackupText(
				getTypingTarget().getText());

a146 1
//	        view().checkDamage();
a223 1

d268 2
a269 5
				if (currentFigure instanceof DecoratorFigure) {
					currentFigure = ((DecoratorFigure)currentFigure).getDecoratedFigure();
				}
				if (currentFigure instanceof TextHolder) {
					((TextHolder)currentFigure).setText(newText);
@


1.5
log
@no message
@
text
@a20 1
import java.util.Vector;
d36 2
a37 2
	private FloatingTextField   fTextField;
	private TextHolder  fTypingTarget;
d49 1
d53 2
a54 2
			textHolder = (TextHolder) pressedFigure;
			if (!textHolder.acceptsTyping())
d56 1
a59 1
			return;
d61 4
a64 4
		if (getTypingTarget() != null) {
			endEdit();
			editor().toolDone();
		} else {
d79 3
d107 2
a108 2
	public boolean isActivated() {
		return getTypingTarget() != null;
d112 2
a113 2
		if (fTextField == null) {
			fTextField = new FloatingTextField();
d120 2
a121 2
		fTextField.createOverlay((Container)view(), figure.getFont());
		fTextField.setBounds(fieldBounds(figure), figure.getText());
a123 1
		setUndoActivity(createUndoActivity());
d128 2
a129 2
			if (fTextField.getText().length() > 0) {
				getTypingTarget().setText(fTextField.getText());
d139 1
d146 1
a146 1
			fTextField.endOverlay();
d154 1
a154 1
		Dimension d = fTextField.getPreferredSize(nChars);
d159 1
a159 1
		fTypingTarget = newTypingTarget;
d163 13
a175 1
		return fTypingTarget;
d209 1
a209 1
				while (fe.hasMoreElements()) {
d216 1
a216 1
				while (fe.hasMoreElements()) {
d243 1
a243 1
				while (fe.hasMoreElements()) {
d250 1
a250 1
				while (fe.hasMoreElements()) {
d268 1
a268 1
			while (fe.hasMoreElements()) {
@


1.4
log
@merge dnd (before 5.3)
@
text
@a93 1
		view().clearSelection();
d107 1
a107 1
	
d154 1
a154 1
	
d158 1
a158 1
	
d173 1
a173 1
		
d209 1
a209 1
			
d224 1
a224 1
				
d246 1
a246 1
		
d250 1
a250 1
		
d263 1
a263 1
		
d267 1
a267 1
		
d271 1
a271 1
		
d275 1
a275 1
		
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d40 2
a41 2
	public TextTool(DrawingView view, Figure prototype) {
		super(view, prototype);
a84 1
		super.deactivate();
d86 1
a122 1
System.out.println("UndoActivity (1): " + getUndoActivity());
a137 1
System.out.println("UndoActivity (2): " + getUndoActivity());
a152 1
//System.out.println("fieldBounds: " + box.x + " .. " + box.y + " -- " + d.width +" .. "+  d.height);
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)TextTool.java 5.2
d4 6
a13 2
import java.awt.*;
import java.awt.event.*;
d17 5
d32 2
d37 2
a38 2
    private FloatingTextField   fTextField;
    private TextHolder  fTypingTarget;
d40 58
a97 55
    public TextTool(DrawingView view, Figure prototype) {
        super(view, prototype);
    }

    /**
     * If the pressed figure is a TextHolder it can be edited otherwise
     * a new text figure is created.
     */
    public void mouseDown(MouseEvent e, int x, int y)
    {
	    TextHolder textHolder = null;

	    Figure pressedFigure = drawing().findFigureInside(x, y);
	    if (pressedFigure instanceof TextHolder) {
	        textHolder = (TextHolder) pressedFigure;
	        if (!textHolder.acceptsTyping())
	            textHolder = null;
        }
	    if (textHolder != null) {
	        beginEdit(textHolder);
	        return;
	    }
	    if (getTypingTarget() != null) {
	        editor().toolDone();
	        endEdit();
	    } else {
    	    super.mouseDown(e, x, y);
    	    textHolder = (TextHolder)createdFigure();
    	    beginEdit(textHolder);
        }
    }

    public void mouseDrag(MouseEvent e, int x, int y) {
    }

    public void mouseUp(MouseEvent e, int x, int y) {
    }

    /**
     * Terminates the editing of a text figure.
     */
    public void deactivate() {
        super.deactivate();
        endEdit();
    }

    /**
     * Sets the text cursor.
     */
    public void activate() {
        super.activate();
        view().clearSelection();
        // JDK1.1 TEXT_CURSOR has an incorrect hot spot
        //view().setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
    }
d109 175
a283 41
    protected void beginEdit(TextHolder figure) {
        if (fTextField == null)
            fTextField = new FloatingTextField();

	    if (figure != getTypingTarget() && getTypingTarget() != null)
	        endEdit();

        fTextField.createOverlay((Container)view(), figure.getFont());
	    fTextField.setBounds(fieldBounds(figure), figure.getText());
	    setTypingTarget(figure);

	    view().checkDamage();
    }

    protected void endEdit() {
	    if (getTypingTarget() != null) {
	        if (fTextField.getText().length() > 0)
	            getTypingTarget().setText(fTextField.getText());
	        else {
	            drawing().remove((Figure)getTypingTarget());
	        }
	        setTypingTarget(null);
	        fTextField.endOverlay();
	        view().checkDamage();
	    }
    }

    private Rectangle fieldBounds(TextHolder figure) {
    	Rectangle box = figure.textDisplayBox();
    	int nChars = figure.overlayColumns();
        Dimension d = fTextField.getPreferredSize(nChars);
        return new Rectangle(box.x, box.y, d.width, d.height);
    }
    
    protected void setTypingTarget(TextHolder newTypingTarget) {
        fTypingTarget = newTypingTarget;
    }
    
    protected TextHolder getTypingTarget() {
        return fTypingTarget;
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)TextTool.java 5.1
a38 1
	    Figure pressedFigure;
d41 1
a41 1
	    pressedFigure = drawing().findFigureInside(x, y);
d51 1
a51 1
	    if (fTypingTarget != null) {
d82 1
a82 1
        //view.setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
d85 10
d99 1
a99 1
	    if (figure != fTypingTarget && fTypingTarget != null)
d104 3
a106 1
	    fTypingTarget = figure;
d110 1
a110 1
	    if (fTypingTarget != null) {
d112 5
a116 4
	            fTypingTarget.setText(fTextField.getText());
	        else
	            drawing().remove((Figure)fTypingTarget);
	        fTypingTarget = null;
d127 8
@


1.1.1.1
log
@
Initial revision.
@
text
@@
