head	1.11;
access;
symbols
	jhotdraw60b1-release:1.9
	package_rename:1.9
	directory_rename:1.8
	reorg_6x_split_initial:1.8
	MVC_PHASE1:1.7.0.4
	NEW_ATTRIBUTES:1.7.0.2
	DNOYEB1_ALPHA-2:1.6.4.1
	release_JHD54b1:1.6
	BUGFIX_670992:1.6.0.6
	DNOYEB1_ALPHA-1:1.6
	dnoyeb1:1.6.0.4
	repack:1.6.0.2
	Root_repack:1.6
	Before_FigureVisitor:1.5
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2004.03.06.14.36.53;	author mrfloppy;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.23.05.05.43;	author cfm1;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.20.14.59.47;	author ricardo_padilha;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.04.05.30.12;	author ricardo_padilha;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.22.08.58.23;	author mrfloppy;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.08.04.22.43.22;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;

1.6.4.1
date	2003.01.26.00.50.50;	author dnoyeb;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.02.02.16.54.06;	author dnoyeb;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.02.03.18.12.32;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.11
log
@adjusted formatting
@
text
@/*
 * @@(#)LineConnection.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.figures;

import java.awt.*;
import java.util.List;
import java.io.*;
import org.jhotdraw.framework.*;
import org.jhotdraw.standard.*;
import org.jhotdraw.util.*;

/**
 * A LineConnection is a standard implementation of the
 * ConnectionFigure interface. The interface is implemented with PolyLineFigure.
 *
 * @@see ConnectionFigure
 *
 * @@version <$CURRENT_VERSION$>
 */
public  class LineConnection extends PolyLineFigure implements ConnectionFigure {

	protected Connector    myStartConnector;
	protected Connector    myEndConnector;

	/*
	 * Serialization support.
	 */
	private static final long serialVersionUID = 6883731614578414801L;
	private int lineConnectionSerializedDataVersion = 1;

	/**
	 * Constructs a LineConnection. A connection figure has
	 * an arrow decoration at the start and end.
	 */
	public LineConnection() {
		super(4);
		setStartDecoration(new ArrowTip());
		setEndDecoration(new ArrowTip());
	}

	/**
	 * Tests whether a figure can be a connection target.
	 * ConnectionFigures cannot be connected and return false.
	 */
	public boolean canConnect() {
		return false;
	}

	/**
	 * Ensures that a connection is updated if the connection
	 * was moved.
	 */
	protected void basicMoveBy(int dx, int dy) {
		// don't move the start and end point since they are connected
		for (int i = 1; i < fPoints.size()-1; i++) {
			pointAt(i).translate(dx, dy);
		}

		updateConnection(); // make sure that we are still connected
	}

	/**
	 * Sets the start figure of the connection.
	 */
	public void connectStart(Connector newStartConnector) {
		newStartConnector = newStartConnector.finalizeConnector(true);
		setStartConnector(newStartConnector);
		if (newStartConnector != null) {
			startFigure().addDependendFigure(this);
			startFigure().addFigureChangeListener(this);
		}
	}

	/**
	 * Sets the end figure of the connection.
	 */
	public void connectEnd(Connector newEndConnector) {
		newEndConnector = newEndConnector.finalizeConnector(false);
		setEndConnector(newEndConnector);
		if (newEndConnector != null) {
			endFigure().addDependendFigure(this);
			endFigure().addFigureChangeListener(this);
			handleConnect(startFigure(), endFigure());
		}
	}

	/**
	 * Disconnects the start figure.
	 */
	public void disconnectStart() {
		startFigure().removeFigureChangeListener(this);
		startFigure().removeDependendFigure(this);
		setStartConnector(null);
	}

	/**
	 * Disconnects the end figure.
	 */
	public void disconnectEnd() {
		handleDisconnect(startFigure(), endFigure());
		endFigure().removeFigureChangeListener(this);
		endFigure().removeDependendFigure(this);
		setEndConnector(null);
	}

	/**
	 * Tests whether a connection connects the same figures
	 * as another ConnectionFigure.
	 */
	public boolean connectsSame(ConnectionFigure other) {
		return other.getStartConnector() == getStartConnector()
			&& other.getEndConnector() == getEndConnector();
	}

	/**
	 * Handles the disconnection of a connection.
	 * Override this method to handle this event.
	 */
	protected void handleDisconnect(Figure start, Figure end) {}

	/**
	 * Handles the connection of a connection.
	 * Override this method to handle this event.
	 */
	protected void handleConnect(Figure start, Figure end) {}

	/**
	 * Gets the start figure of the connection.
	 */
	public Figure startFigure() {
		if (getStartConnector() != null) {
			return getStartConnector().owner();
		}
		return null;
	}

	/**
	 * Gets the end figure of the connection.
	 */
	public Figure endFigure() {
		if (getEndConnector() != null) {
			return getEndConnector().owner();
		}
		return null;
	}

	protected void setStartConnector(Connector newStartConnector) {
		myStartConnector = newStartConnector;
	}

	/**
	 * Gets the start figure of the connection.
	 */
	public Connector getStartConnector() {
		return myStartConnector;
	}

	protected void setEndConnector(Connector newEndConnector) {
		myEndConnector = newEndConnector;
	}

	/**
	 * Gets the end figure of the connection.
	 */
	public Connector getEndConnector() {
		return myEndConnector;
	}

	/**
	 * Tests whether two figures can be connected.
	 */
	public boolean canConnect(Figure start, Figure end) {
		return true;
	}

	/**
	 *                             
	 *                           p1.............p2
	 *                            .              .
	 *            ...............po......        .      
	 *            .                     .        .
	 *            .                     .        .
	 *            .                     .        .
	 *            .                     .p4.....p3
	 *            .                     .
	 *            .                     .
	 *            .                     .
	 *            .......................            
	 * 
	**/
	private void resetSelfConnections() {
		while (fPoints.size() > 5) {
			removePointAt(3);
		}
		while (fPoints.size() < 5) {
			insertPointAt(pointAt(1),1);
		}

		Rectangle r = myStartConnector.owner().displayBox();
		int westX   = Geom.west(r).x;
		int eastX   = Geom.east(r).x;
		int northY  = Geom.north(r).y;
		int southY  = Geom.south(r).y;       

		// delta is a heuristic to make the self-connecting edge more visually appealing
		int delta       = Math.min(24, r.width);
		if (r.width > 200) {
			delta       = Math.min(36, r.width);
		}
		if (r.width < 100) {
			delta       = Math.min(12, r.width);
		}

		Point p0 = pointAt(0);
		OffsetConnector start = (OffsetConnector) myStartConnector;
		start.calculateFigureConstrainedOffsets(p0.x, p0.y);
		p0.x = start.locateX();
		p0.y = start.locateY();       
        
		// Calculate the coordinates of p4 from p0 (the start connecting point!)      
		int p4X       = eastX;
		double ratio1 = ((double)p0.x - (double)westX) / (double)r.width;
		if (p0.x < (westX + r.width/2)) { 
			p4X    = westX;
			ratio1 = ((double)eastX - (double)p0.x) / (double)r.width;
		}
		int p4Y = northY + (int)(ratio1*r.height);
		if (p0.y > (northY + r.height/2)) {
			p4Y = southY - (int)(ratio1*r.height);
		}
		OffsetConnector end = (OffsetConnector) myEndConnector;
		end.calculateFigureConstrainedOffsets(p4X, p4Y);
		Point p4 = new Point(end.locateX(), end.locateY());
		fPoints.set(4, p4);         

		// Calculate the coordinates of p2 from p0 and p4
		int p2X = p4X  + delta + (int)(ratio1*delta);      
		if (p0.x < (westX + r.width/2)) { 
			p2X = p4X  - delta - (int)(ratio1*delta);
		}
		double ratio2 = 1 - ratio1;
		int p2Y = northY - delta - (int)(ratio2*delta);
		if (p0.y > (northY + r.height/2)) { 
			p2Y = southY + delta + (int)(ratio2*delta);
		}
		Point p2 = new Point(p2X, p2Y);
		fPoints.set(2, p2);

		// Calculate p1 and p3 from p0, p2, p4     
		Point p1        = new Point(p0.x, p2.y);
		Point p3        = new Point(p2.x, p4.y);      
		fPoints.set(1, p1);
		fPoints.set(3, p3);  
	}

	/**
	 * Sets the start point.
	 */
	public void startPoint(int x, int y) {
		willChange();
		if (fPoints.size() == 0) {
			fPoints.add(new Point(x, y));
		}
		else {
			fPoints.set(0, new Point(x, y));
		}
		changed();
	}

	/**
	 * Sets the end point.
	 */
	public void endPoint(int x, int y) {
		willChange();
		if (fPoints.size() < 2) {
			fPoints.add(new Point(x, y));
		}
		else {
			fPoints.set(fPoints.size()-1, new Point(x, y));
		}

		if ((myEndConnector != null) 
				&&  (myStartConnector.owner() == myEndConnector.owner()) 
				&&  (myEndConnector instanceof OffsetConnector)) { 
			resetSelfConnections();
		}

		changed();
	}

	/**
	 * Gets the start point.
	 */
	public Point startPoint() {
		Point p = pointAt(0);
		return new Point(p.x, p.y);
	}

	/**
	 * Gets the end point.
	 */
	public Point endPoint() {
		if (fPoints.size() > 0) {
			Point p = pointAt(fPoints.size()-1);
			return new Point(p.x, p.y);
		}
		else {
			return null;
		}
	}

	/**
	 * Gets the handles of the figure. It returns the normal
	 * PolyLineHandles but adds ChangeConnectionHandles at the
	 * start and end.
	 */
	public HandleEnumeration handles() {
		List handles = CollectionsFactory.current().createList(fPoints.size());
		handles.add(new ChangeConnectionStartHandle(this));
		for (int i = 1; i < fPoints.size()-1; i++) {
			handles.add(new PolyLineHandle(this, locator(i), i));
		}
		handles.add(new ChangeConnectionEndHandle(this));
		return new HandleEnumerator(handles);
	}

	/**
	 * Sets the point and updates the connection.
	 */
	public void setPointAt(Point p, int i) {
		super.setPointAt(p, i);
		layoutConnection();
	}

	/**
	 * Inserts the point and updates the connection.
	 */
	public void insertPointAt(Point p, int i) {
		super.insertPointAt(p, i);
		layoutConnection();
	}

	/**
	 * Removes the point and updates the connection.
	 */
	public void removePointAt(int i) {
		super.removePointAt(i);
		layoutConnection();
	}

	/**
	 * Updates the connection.
	 */
	public void updateConnection() {
		if (getStartConnector() != null) {
			Point start = getStartConnector().findStart(this);

			if (start != null) {
				startPoint(start.x, start.y);
			}
		}
		if (getEndConnector() != null) {
			Point end = getEndConnector().findEnd(this);

			if (end != null) {
				endPoint(end.x, end.y);
			}
		}
	}

	/**
	 * Lays out the connection. This is called when the connection
	 * itself changes. By default the connection is recalculated
	 */
	public void layoutConnection() {
		updateConnection();
	}

	public void figureChanged(FigureChangeEvent e) {
		updateConnection();
	}

	public void figureRemoved(FigureChangeEvent e) {
	}

	public void figureRequestRemove(FigureChangeEvent e) {
	}

	public void figureInvalidated(FigureChangeEvent e) {
	}

	public void figureRequestUpdate(FigureChangeEvent e) {
	}

	public void release() {
		super.release();
		handleDisconnect(startFigure(), endFigure());
		if (getStartConnector() != null) {
			startFigure().removeFigureChangeListener(this);
			startFigure().removeDependendFigure(this);
		}
		if (getEndConnector() != null) {
			endFigure().removeFigureChangeListener(this);
			endFigure().removeDependendFigure(this);
		}
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeStorable(getStartConnector());
		dw.writeStorable(getEndConnector());
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		Connector start = (Connector)dr.readStorable();
		if (start != null) {
			connectStart(start);
		}
		Connector end = (Connector)dr.readStorable();
		if (end != null) {
			connectEnd(end);
		}
		if ((start != null) && (end != null)) {
			updateConnection();
		}
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		if (getStartConnector() != null) {
			connectStart(getStartConnector());
		}
		if (getEndConnector() != null) {
			connectEnd(getEndConnector());
		}
	}

	public void visit(FigureVisitor visitor) {
		visitor.visitFigure(this);
	}

	/**
	 * @@see org.jhotdraw.framework.Figure#removeFromContainer(org.jhotdraw.framework.FigureChangeListener)
	 */
	public void removeFromContainer(FigureChangeListener c) {
		super.removeFromContainer(c);
		release();
	}

}
@


1.10
log
@OffsetConnectors added
@
text
@d75 1
a75 3
//      cfm1 *******************************************************************
		newStartConnector = newStartConnector.finalizeConnector(true);
//      cfm1 *******************************************************************  
d87 1
a87 3
//      cfm1 *******************************************************************
        newEndConnector = newEndConnector.finalizeConnector(false);
//      cfm1 *******************************************************************
d184 80
a263 88

//  cfm1 *******************************************************************   
  /**
   * 
   * 
   *                             
   *                           p1.............p2
   *                            .              .
   *            ...............po......        .      
   *            .                     .        .
   *            .                     .        .
   *            .                     .        .
   *            .                     .p4.....p3
   *            .                     .
   *            .                     .
   *            .                     .
   *            .......................            
   * 
   *
   *
   *
   *
   **/
  private void resetSelfConnections() {
      while (fPoints.size() > 5)
             removePointAt(3);
      while (fPoints.size() < 5)
             insertPointAt(pointAt(1),1);    
        
      Rectangle r = myStartConnector.owner().displayBox();
      int westX   = Geom.west(r).x;
      int eastX   = Geom.east(r).x;
      int northY  = Geom.north(r).y;
      int southY  = Geom.south(r).y;       
 
      // delta is a heuristic to make the self-connecting edge more visually appealing
      int delta       = Math.min(24, r.width);
      if (r.width > 200)
          delta       = Math.min(36, r.width);
      if (r.width < 100)
          delta       = Math.min(12, r.width); 
               
      Point p0 = pointAt(0);
      OffsetConnector start = (OffsetConnector) myStartConnector;
      start.calculateFigureConstrainedOffsets(p0.x, p0.y);
      p0.x = start.locateX();
      p0.y = start.locateY();       
        
      // Calculate the coordinates of p4 from p0 (the start connecting point!)      
      int p4X       = eastX;
      double ratio1 = ((double)p0.x - (double)westX) / (double)r.width;
      if (p0.x < westX + r.width/2) { 
          p4X    = westX;
          ratio1 = ((double)eastX - (double)p0.x) / (double)r.width;
      }       
      int p4Y = northY + (int)(ratio1*r.height);
      if (p0.y > northY + r.height/2)
          p4Y = southY - (int)(ratio1*r.height); 
      OffsetConnector end = (OffsetConnector) myEndConnector;
      end.calculateFigureConstrainedOffsets(p4X, p4Y);
      Point p4 = new Point(end.locateX(), end.locateY());
      fPoints.set(4, p4);         
        
//    Calculate the coordinates of p2 from p0 and p4
      int p2X = p4X  + delta + (int)(ratio1*delta);      
      if (p0.x < westX + r.width/2) 
          p2X = p4X  - delta - (int)(ratio1*delta);
      double ratio2 = 1 - ratio1;
      int p2Y = northY - delta - (int)(ratio2*delta);
      if (p0.y > northY + r.height/2) 
          p2Y = southY + delta + (int)(ratio2*delta); 
      Point p2 = new Point(p2X, p2Y);
      fPoints.set(2, p2);
        
      //Calculate p1 and p3 from p0, p2, p4     
      Point p1        = new Point(p0.x, p2.y);
      Point p3        = new Point(p2.x, p4.y);      
      fPoints.set(1, p1);
      fPoints.set(3, p3);  
  }

//cfm1 *******************************************************************






d290 7
a296 6
//      cfm1 *******************************************************************		
        if (myEndConnector != null 
        &&  myStartConnector.owner() == myEndConnector.owner() 
        &&  myEndConnector instanceof OffsetConnector) 
            resetSelfConnections();
//      cfm1 *******************************************************************
@


1.9
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@d75 3
d89 3
d188 88
d302 6
@


1.8
log
@Bug fix for undo/redo
@
text
@d12 1
a12 1
package CH.ifa.draw.figures;
d17 3
a19 3
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.util.*;
d367 1
a367 1
	 * @@see CH.ifa.draw.framework.Figure#removeFromContainer(CH.ifa.draw.framework.FigureChangeListener)
@


1.7
log
@Removed unused imports and local variables.
@
text
@d320 1
d324 1
d365 9
@


1.6
log
@introduce FigureVisitor for paste/delete commands
@
text
@a14 1
import java.util.*;
@


1.6.4.1
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d304 6
@


1.6.4.2
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d311 1
a318 1
		super.release();
@


1.6.4.3
log
@pragmatic fix for [ 679266 ] Dependent figure calling non final methods during loading
it really requires an architecture change in some respects.
@
text
@d337 3
@


1.5
log
@after variou merges... (before 5.4 release)
@
text
@d78 1
d89 1
d100 1
d110 1
a304 3
		if (listener() != null) {
			listener().figureRequestRemove(new FigureChangeEvent(this));
		}
d307 8
a314 3
	public void figureRequestRemove(FigureChangeEvent e) {}
	public void figureInvalidated(FigureChangeEvent e) {}
	public void figureRequestUpdate(FigureChangeEvent e) {}
d359 4
@


1.4
log
@no message
@
text
@d16 1
d66 1
a66 1
			((Point) fPoints.elementAt(i)).translate(dx, dy);
d77 3
a79 1
		startFigure().addFigureChangeListener(this);
d87 4
a90 2
		endFigure().addFigureChangeListener(this);
		handleConnect(startFigure(), endFigure());
d154 1
a154 1
	
d165 1
a165 1
	
d186 1
a186 1
			fPoints.addElement(new Point(x, y));
d189 1
a189 1
			fPoints.setElementAt(new Point(x, y), 0);
d200 1
a200 1
			fPoints.addElement(new Point(x, y));
d203 1
a203 1
			fPoints.setElementAt(new Point(x, y), fPoints.size()-1);
d211 2
a212 2
	public Point startPoint(){
		Point p = (Point)fPoints.firstElement();
d220 7
a226 2
		Point p = (Point)fPoints.lastElement();
		return new Point(p.x, p.y);
d234 3
a236 3
	public Vector handles() {
		Vector handles = new Vector(fPoints.size());
		handles.addElement(new ChangeConnectionStartHandle(this));
d238 1
a238 1
			handles.addElement(new PolyLineHandle(this, locator(i), i));
d240 2
a241 2
		handles.addElement(new ChangeConnectionEndHandle(this));
		return handles;
d275 1
a275 1
			if(start != null) {
d281 2
a282 2
	  
			if(end != null) {
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d327 1
a327 1
		if (start != null && end != null) {
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)LineConnection.java 5.2
d4 6
d24 1
d26 2
d31 2
a32 2
    protected Connector    fStart = null;
    protected Connector    fEnd = null;
d34 310
a343 277
    /*
     * Serialization support.
     */
    private static final long serialVersionUID = 6883731614578414801L;
    private int lineConnectionSerializedDataVersion = 1;

    /**
     * Constructs a LineConnection. A connection figure has
     * an arrow decoration at the start and end.
     */
    public LineConnection() {
        super(4);
        setStartDecoration(new ArrowTip());
        setEndDecoration(new ArrowTip());
    }

    /**
     * Tests whether a figure can be a connection target.
     * ConnectionFigures cannot be connected and return false.
     */
    public boolean canConnect() {
        return false;
    }

    /**
     * Ensures that a connection is updated if the connection
     * was moved.
     */
    protected void basicMoveBy(int dx, int dy) {
        // don't move the start and end point since they are connected
        for (int i = 1; i < fPoints.size()-1; i++)
            ((Point) fPoints.elementAt(i)).translate(dx, dy);

        updateConnection(); // make sure that we are still connected
    }

    /**
     * Sets the start figure of the connection.
     */
    public void connectStart(Connector start) {
        fStart = start;
        startFigure().addFigureChangeListener(this);
    }

    /**
     * Sets the end figure of the connection.
     */
    public void connectEnd(Connector end) {
        fEnd = end;
        endFigure().addFigureChangeListener(this);
        handleConnect(startFigure(), endFigure());
    }

    /**
     * Disconnects the start figure.
     */
    public void disconnectStart() {
        startFigure().removeFigureChangeListener(this);
        fStart = null;
    }

    /**
     * Disconnects the end figure.
     */
    public void disconnectEnd() {
        handleDisconnect(startFigure(), endFigure());
        endFigure().removeFigureChangeListener(this);
        fEnd = null;
    }

    /**
     * Tests whether a connection connects the same figures
     * as another ConnectionFigure.
     */
    public boolean connectsSame(ConnectionFigure other) {
        return other.start() == start() && other.end() == end();
    }

    /**
     * Handles the disconnection of a connection.
     * Override this method to handle this event.
     */
    protected void handleDisconnect(Figure start, Figure end) {}

    /**
     * Handles the connection of a connection.
     * Override this method to handle this event.
     */
    protected void handleConnect(Figure start, Figure end) {}

    /**
     * Gets the start figure of the connection.
     */
    public Figure startFigure() {
        if (start() != null)
            return start().owner();
        return null;
    }

    /**
     * Gets the end figure of the connection.
     */
    public Figure endFigure() {
        if (end() != null)
            return end().owner();
        return null;
    }

    /**
     * Gets the start figure of the connection.
     */
    public Connector start() {
        return fStart;
    }

    /**
     * Gets the end figure of the connection.
     */
    public Connector end() {
        return fEnd;
    }

    /**
     * Tests whether two figures can be connected.
     */
    public boolean canConnect(Figure start, Figure end) {
        return true;
    }

    /**
     * Sets the start point.
     */
    public void startPoint(int x, int y) {
        willChange();
        if (fPoints.size() == 0)
            fPoints.addElement(new Point(x, y));
        else
            fPoints.setElementAt(new Point(x, y), 0);
        changed();
    }

    /**
     * Sets the end point.
     */
    public void endPoint(int x, int y) {
        willChange();
        if (fPoints.size() < 2)
            fPoints.addElement(new Point(x, y));
        else
            fPoints.setElementAt(new Point(x, y), fPoints.size()-1);
        changed();
    }

    /**
     * Gets the start point.
     */
    public Point startPoint(){
        Point p = (Point)fPoints.firstElement();
        return new Point(p.x, p.y);
    }

    /**
     * Gets the end point.
     */
    public Point endPoint() {
        Point p = (Point)fPoints.lastElement();
        return new Point(p.x, p.y);
    }

    /**
     * Gets the handles of the figure. It returns the normal
     * PolyLineHandles but adds ChangeConnectionHandles at the
     * start and end.
     */
    public Vector handles() {
        Vector handles = new Vector(fPoints.size());
        handles.addElement(new ChangeConnectionStartHandle(this));
        for (int i = 1; i < fPoints.size()-1; i++)
            handles.addElement(new PolyLineHandle(this, locator(i), i));
        handles.addElement(new ChangeConnectionEndHandle(this));
        return handles;
    }

    /**
     * Sets the point and updates the connection.
     */
    public void setPointAt(Point p, int i) {
        super.setPointAt(p, i);
        layoutConnection();
    }

    /**
     * Inserts the point and updates the connection.
     */
    public void insertPointAt(Point p, int i) {
        super.insertPointAt(p, i);
        layoutConnection();
    }

    /**
     * Removes the point and updates the connection.
     */
    public void removePointAt(int i) {
        super.removePointAt(i);
        layoutConnection();
    }

    /**
     * Updates the connection.
     */
    public void updateConnection() {
        if (fStart != null) {
            Point start = fStart.findStart(this);
            startPoint(start.x, start.y);
        }
        if (fEnd != null) {
            Point end = fEnd.findEnd(this);
            endPoint(end.x, end.y);
        }
    }

    /**
     * Lays out the connection. This is called when the connection
     * itself changes. By default the connection is recalculated
     */
    public void layoutConnection() {
        updateConnection();
    }

    public void figureChanged(FigureChangeEvent e) {
        updateConnection();
    }

    public void figureRemoved(FigureChangeEvent e) {
        if (listener() != null)
            listener().figureRequestRemove(new FigureChangeEvent(this));
    }

    public void figureRequestRemove(FigureChangeEvent e) {}
    public void figureInvalidated(FigureChangeEvent e) {}
    public void figureRequestUpdate(FigureChangeEvent e) {}

    public void release() {
        super.release();
        handleDisconnect(startFigure(), endFigure());
        if (fStart != null) startFigure().removeFigureChangeListener(this);
        if (fEnd   != null) endFigure().removeFigureChangeListener(this);
    }

    public void write(StorableOutput dw) {
        super.write(dw);
        dw.writeStorable(fStart);
        dw.writeStorable(fEnd);
    }

    public void read(StorableInput dr) throws IOException {
        super.read(dr);
        Connector start = (Connector)dr.readStorable();
        if (start != null)
            connectStart(start);
        Connector end = (Connector)dr.readStorable();
        if (end != null)
            connectEnd(end);
        if (start != null && end != null)
            updateConnection();
    }

    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException {

        s.defaultReadObject();

        if (fStart != null)
            connectStart(fStart);
        if (fEnd != null)
            connectEnd(fEnd);
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)LineConnection.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
