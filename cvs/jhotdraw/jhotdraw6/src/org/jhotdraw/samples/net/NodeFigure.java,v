head	1.6;
access;
symbols
	jhotdraw60b1-release:1.6
	package_rename:1.6
	directory_rename:1.5
	reorg_6x_split_initial:1.5
	MVC_PHASE1:1.5.0.4
	NEW_ATTRIBUTES:1.5.0.2
	DNOYEB1_ALPHA-2:1.4
	release_JHD54b1:1.5
	BUGFIX_670992:1.4.0.6
	DNOYEB1_ALPHA-1:1.4
	dnoyeb1:1.4.0.4
	repack:1.4.0.2
	Root_repack:1.4
	Before_FigureVisitor:1.4
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2004.01.09.22.53.42;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.30.00.27.34;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.04.22.52.56;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.44.32;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.09;	author jeckel;	state Exp;
branches;
next	;


desc
@@


1.6
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)NodeFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.samples.net;

import org.jhotdraw.framework.*;
import org.jhotdraw.standard.*;
import org.jhotdraw.figures.*;
import org.jhotdraw.util.*;

import java.util.*;
import java.util.List;
import java.awt.*;

/**
 * @@version <$CURRENT_VERSION$>
 */
public class NodeFigure extends TextFigure {
	private static final int BORDER = 6;
	private List        fConnectors;
	private boolean     fConnectorsVisible;

	public NodeFigure() {
		initialize();
		fConnectors = null;
	}

	public Rectangle displayBox() {
		Rectangle box = super.displayBox();
		int d = BORDER;
		box.grow(d, d);
		return box;
	}

	public boolean containsPoint(int x, int y) {
		// add slop for connectors
		if (fConnectorsVisible) {
			Rectangle r = displayBox();
			int d = LocatorConnector.SIZE/2;
			r.grow(d, d);
			return r.contains(x, y);
		}
		return super.containsPoint(x, y);
	}

	private void drawBorder(Graphics g) {
		Rectangle r = displayBox();
		g.setColor(getFrameColor());
		g.drawRect(r.x, r.y, r.width-1, r.height-1);
	}

	public void draw(Graphics g) {
		super.draw(g);
		drawBorder(g);
		drawConnectors(g);
	}

	public HandleEnumeration handles() {
		ConnectionFigure prototype = new LineConnection();
		List handles = CollectionsFactory.current().createList();
		handles.add(new ConnectionHandle(this, RelativeLocator.east(), prototype));
		handles.add(new ConnectionHandle(this, RelativeLocator.west(), prototype));
		handles.add(new ConnectionHandle(this, RelativeLocator.south(), prototype));
		handles.add(new ConnectionHandle(this, RelativeLocator.north(), prototype));

		handles.add(new NullHandle(this, RelativeLocator.southEast()));
		handles.add(new NullHandle(this, RelativeLocator.southWest()));
		handles.add(new NullHandle(this, RelativeLocator.northEast()));
		handles.add(new NullHandle(this, RelativeLocator.northWest()));
		return new HandleEnumerator(handles);
	}

	private void drawConnectors(Graphics g) {
		if (fConnectorsVisible) {
			Iterator iter = connectors();
			while (iter.hasNext()) {
				((Connector)iter.next()).draw(g);
			}
		}
	}

	/**
	 */
	public void connectorVisibility(boolean isVisible, ConnectionFigure courtingConnection) {
		fConnectorsVisible = isVisible;
		invalidate();
	}

	/**
	 */
	public Connector connectorAt(int x, int y) {
		return findConnector(x, y);
	}

	/**
	 */
	private Iterator connectors() {
		if (fConnectors == null) {
			createConnectors();
		}
		return fConnectors.iterator();
	}

	private void createConnectors() {
		fConnectors = CollectionsFactory.current().createList(4);
		fConnectors.add(new LocatorConnector(this, RelativeLocator.north()) );
		fConnectors.add(new LocatorConnector(this, RelativeLocator.south()) );
		fConnectors.add(new LocatorConnector(this, RelativeLocator.west()) );
		fConnectors.add(new LocatorConnector(this, RelativeLocator.east()) );
	}

	private Connector findConnector(int x, int y) {
		// return closest connector
		long min = Long.MAX_VALUE;
		Connector closest = null;
		Iterator iter = connectors();
		while (iter.hasNext()) {
			Connector c = (Connector)iter.next();
			Point p2 = Geom.center(c.displayBox());
			long d = Geom.length2(x, y, p2.x, p2.y);
			if (d < min) {
				min = d;
				closest = c;
			}
		}
		return closest;
	}

	private void initialize() {
		setText("node");
		Font fb = new Font("Helvetica", Font.BOLD, 12);
		setFont(fb);
		createConnectors();
	}

	/**
	 * Usually, a TextHolders is implemented by a Figure subclass. To avoid casting
	 * a TextHolder to a Figure this method can be used for polymorphism (in this
	 * case, let the (same) object appear to be of another type).
	 * Note, that the figure returned is not the figure to which the TextHolder is
	 * (and its representing figure) connected.
	 * @@return figure responsible for representing the content of this TextHolder
	 */
	public Figure getRepresentingFigure() {
		return this;
	}
}
@


1.5
log
@prepare for 5.4 release: various bug fixes
@
text
@d12 1
a12 1
package CH.ifa.draw.samples.net;
d14 4
a17 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.*;
import CH.ifa.draw.figures.*;
import CH.ifa.draw.util.*;
@


1.4
log
@after variou merges... (before 5.4 release)
@
text
@d143 12
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@a13 3
import java.awt.*;
import java.util.*;
import java.io.IOException;
d19 4
d28 1
a28 1
	private Vector      fConnectors;
d66 1
a66 1
	public Vector handles() {
d68 11
a78 11
		Vector handles = new Vector();
		handles.addElement(new ConnectionHandle(this, RelativeLocator.east(), prototype));
		handles.addElement(new ConnectionHandle(this, RelativeLocator.west(), prototype));
		handles.addElement(new ConnectionHandle(this, RelativeLocator.south(), prototype));
		handles.addElement(new ConnectionHandle(this, RelativeLocator.north(), prototype));

		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		return handles;
d83 3
a85 3
			Enumeration e = connectors().elements();
			while (e.hasMoreElements()) {
				((Connector) e.nextElement()).draw(g);
d92 1
a92 1
	public void connectorVisibility(boolean isVisible) {
d105 1
a105 1
	private Vector connectors() {
d109 1
a109 1
		return fConnectors;
d113 5
a117 5
		fConnectors = new Vector(4);
		fConnectors.addElement(new LocatorConnector(this, RelativeLocator.north()) );
		fConnectors.addElement(new LocatorConnector(this, RelativeLocator.south()) );
		fConnectors.addElement(new LocatorConnector(this, RelativeLocator.west()) );
		fConnectors.addElement(new LocatorConnector(this, RelativeLocator.east()) );
d124 3
a126 3
		Enumeration e = connectors().elements();
		while (e.hasMoreElements()) {
			Connector c = (Connector)e.nextElement();
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)NodeFigure.java 5.2
d4 6
d22 3
a24 1

d26 116
a141 114
    private static final int BORDER = 6;
    private Vector      fConnectors;
    private boolean     fConnectorsVisible;

    public NodeFigure() {
        initialize();
        fConnectors = null;
    }

    public Rectangle displayBox() {
        Rectangle box = super.displayBox();
        int d = BORDER;
        box.grow(d, d);
        return box;
    }

    public boolean containsPoint(int x, int y) {
        // add slop for connectors
        if (fConnectorsVisible) {
            Rectangle r = displayBox();
            int d = LocatorConnector.SIZE/2;
            r.grow(d, d);
            return r.contains(x, y);
        }
        return super.containsPoint(x, y);
    }

    private void drawBorder(Graphics g) {
        Rectangle r = displayBox();
        g.setColor(getFrameColor());
        g.drawRect(r.x, r.y, r.width-1, r.height-1);
    }

    public void draw(Graphics g) {
        super.draw(g);
        drawBorder(g);
        drawConnectors(g);
    }

    public Vector handles() {
        ConnectionFigure prototype = new LineConnection();
        Vector handles = new Vector();
        handles.addElement(new ConnectionHandle(this, RelativeLocator.east(), prototype));
        handles.addElement(new ConnectionHandle(this, RelativeLocator.west(), prototype));
        handles.addElement(new ConnectionHandle(this, RelativeLocator.south(), prototype));
        handles.addElement(new ConnectionHandle(this, RelativeLocator.north(), prototype));

        handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
        handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
        handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
        handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
        return handles;
    }

    private void drawConnectors(Graphics g) {
        if (fConnectorsVisible) {
            Enumeration e = connectors().elements();
            while (e.hasMoreElements())
                ((Connector) e.nextElement()).draw(g);
        }
    }

    /**
     */
    public void connectorVisibility(boolean isVisible) {
        fConnectorsVisible = isVisible;
        invalidate();
    }

    /**
     */
    public Connector connectorAt(int x, int y) {
        return findConnector(x, y);
    }

    /**
     */
    private Vector connectors() {
        if (fConnectors == null)
            createConnectors();
        return fConnectors;
    }

    private void createConnectors() {
        fConnectors = new Vector(4);
        fConnectors.addElement(new LocatorConnector(this, RelativeLocator.north()) );
        fConnectors.addElement(new LocatorConnector(this, RelativeLocator.south()) );
        fConnectors.addElement(new LocatorConnector(this, RelativeLocator.west()) );
        fConnectors.addElement(new LocatorConnector(this, RelativeLocator.east()) );
    }

    private Connector findConnector(int x, int y) {
        // return closest connector
        long min = Long.MAX_VALUE;
        Connector closest = null;
        Enumeration e = connectors().elements();
        while (e.hasMoreElements()) {
            Connector c = (Connector)e.nextElement();
            Point p2 = Geom.center(c.displayBox());
            long d = Geom.length2(x, y, p2.x, p2.y);
            if (d < min) {
                min = d;
                closest = c;
            }
        }
        return closest;
    }

    private void initialize() {
        setText("node");
        Font fb = new Font("Helvetica", Font.BOLD, 12);
        setFont(fb);
        createConnectors();
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)NodeFigure.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
