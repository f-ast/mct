head	1.5;
access;
symbols
	jhotdraw60b1-release:1.5
	package_rename:1.5
	directory_rename:1.4
	reorg_6x_split_initial:1.4
	MVC_PHASE1:1.4.0.10
	NEW_ATTRIBUTES:1.4.0.8
	DNOYEB1_ALPHA-2:1.4
	release_JHD54b1:1.4
	BUGFIX_670992:1.4.0.6
	DNOYEB1_ALPHA-1:1.4
	dnoyeb1:1.4.0.4
	repack:1.4.0.2
	Root_repack:1.4
	Before_FigureVisitor:1.4;
locks; strict;
comment	@# @;


1.5
date	2004.01.09.22.53.40;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.22.08.20.27;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.07.13.13.45;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	;


desc
@@


1.5
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)ComponentFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.contrib;

import org.jhotdraw.figures.AttributeFigure;
import org.jhotdraw.standard.BoxHandleKit;
import org.jhotdraw.standard.HandleEnumerator;
import org.jhotdraw.framework.*;
import org.jhotdraw.util.CollectionsFactory;

import java.awt.Component;
import java.awt.Rectangle;
import java.awt.Point;
import java.awt.Graphics;
import java.util.List;

/**
 * @@author  Ming Fang
 * @@version <$CURRENT_VERSION$>
 */
public class ComponentFigure extends AttributeFigure {
	private Rectangle bounds;

	/** Holds value of property component. */
	private Component component;

	private ComponentFigure() {
		bounds = new Rectangle();
	}

	/**
	 * @@param newComponent a lightweight component
	 */
	public ComponentFigure(Component newComponent) {
		this();
		setComponent(newComponent);
	}

	/**
	 * Changes the display box of a figure. This method is
	 * always implemented in figure subclasses.
	 * It only changes
	 * the displaybox and does not announce any changes. It
	 * is usually not called by the client. Clients typically call
	 * displayBox to change the display box.
	 *
	 * @@param origin the new origin
	 * @@param corner the new corner
	 * @@see #displayBox
	 */
	public void basicDisplayBox(Point origin, Point corner) {
		bounds = new Rectangle(origin);
		bounds.add(corner);
	}

	/**
	 * Moves the figure. This is the
	 * method that subclassers override. Clients usually
	 * call displayBox.
	 * @@see #moveBy
	 */
	protected void basicMoveBy(int dx, int dy) {
		bounds.translate(dx, dy);
	}

	/**
	 * Gets the display box of a figure
	 * @@see #basicDisplayBox
	 */
	public Rectangle displayBox() {
		return new Rectangle(bounds);
	}

	/**
	 * Returns the handles used to manipulate
	 * the figure. Handles is a Factory Method for
	 * creating handle objects.
	 *
	 * @@return a type-safe iterator of handles
	 * @@see Handle
	 */
	public HandleEnumeration handles() {
		List handles = CollectionsFactory.current().createList();
		BoxHandleKit.addHandles(this, handles);
		return new HandleEnumerator(handles);
	}

	/**
	 * Getter for property component.
	 * @@return Value of property component.
	 */
	public Component getComponent() {
		return this.component;
	}

	/**
	 * Setter for property component.
	 *
	 * @@param newComponent New value of property component.
	 */
	protected void setComponent(Component newComponent) {
		this.component = newComponent;
	}

	/**
	 * Draws the figure.
	 * @@param g the Graphics to draw into
	 */
	public void draw(Graphics g) {
		// AWT code
		getComponent().setBounds(displayBox());
		//must create a new graphics with a different cordinate
		Graphics componentG = g.create(bounds.x, bounds.y, bounds.width, bounds.height);
		getComponent().paint(componentG);
	}
}
@


1.4
log
@no message
@
text
@d12 1
a12 1
package CH.ifa.draw.contrib;
d14 5
a18 5
import CH.ifa.draw.figures.AttributeFigure;
import CH.ifa.draw.standard.BoxHandleKit;
import CH.ifa.draw.standard.HandleEnumerator;
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.CollectionsFactory;
@


1.3
log
@changed draw() code to AWT-compatible code which does not require a reference to DrawingEditor
@
text
@d31 1
a31 1
	private Rectangle bounds = new Rectangle();
d37 1
a37 1
		// do nothing
d39 1
d44 1
@


1.2
log
@after variou merges... (before 5.4 release)
@
text
@a20 1
import java.awt.Container;
a24 1
import javax.swing.CellRendererPane;
a34 1
	private transient DrawingEditor myDrawingEditor;
d41 2
a42 4
	 * @@param container the container that provides the screen realestate for paint the component in
	 * you may use StandardDrawingView
	*/
	public ComponentFigure(Component newComponent, DrawingEditor newDrawingEditor) {
a43 1
		setEditor(newDrawingEditor);
d53 1
d105 1
a111 8
	protected DrawingEditor getEditor() {
		return myDrawingEditor;
	}

	protected void setEditor(DrawingEditor newDrawingEditor) {
		myDrawingEditor = newDrawingEditor;
	}

d118 1
a118 1
		//getComponent().setBounds(displayBox());
d120 2
a121 34
		//Graphics componentG = g.create(bounds.x, bounds.y, bounds.width, bounds.height);
		//getComponent().paint(componentG);

		Container container = (Container)getEditor().view();
		getCellRendererPane(component, container).paintComponent(g, component, null, bounds.x, bounds.y, bounds.width, bounds.height, true);
	}

	/* This was taken from SwingUtilities
	 *
	 * Ensures that cell renderer <code>c</code> has a
	 * <code>ComponentShell</code> parent and that
	 * the shell's parent is p.
	 */
	private static CellRendererPane getCellRendererPane(Component c, Container p) {
		Container shell = c.getParent();
		if (shell instanceof CellRendererPane) {
			if (shell.getParent() != p) {
				p.add(shell);
			}
		}
		else {
			shell = new CellRendererPane();
			shell.add(c);
			p.add(shell);
		}
		return (CellRendererPane)shell;
	}

	public Object clone() {
		ComponentFigure clonedFigure = (ComponentFigure)super.clone();
		// editor cannot be serialized (and should no be serialized
		// because that would mean a deep copy) so we set the reference now
		clonedFigure.setEditor(getEditor());
		return clonedFigure;
@


1.1
log
@no message
@
text
@d16 3
a18 1
import CH.ifa.draw.framework.DrawingEditor;
d25 1
a25 1
import java.util.Vector;
d39 3
d43 1
a43 1
	 * @@param component a lightweight component
d91 1
a91 1
	 * @@return a Vector of handles
d94 2
a95 2
	public Vector handles() {
		Vector handles = new Vector();
d97 1
a97 1
		return handles;
d110 1
a110 1
	 * @@param component New value of property component.
@

