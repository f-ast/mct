head	1.8;
access;
symbols
	jhotdraw60b1-release:1.8
	package_rename:1.8
	directory_rename:1.7
	reorg_6x_split_initial:1.7
	MVC_PHASE1:1.5.0.10
	NEW_ATTRIBUTES:1.5.0.8
	DNOYEB1_ALPHA-2:1.5
	release_JHD54b1:1.5
	BUGFIX_670992:1.5.0.6
	DNOYEB1_ALPHA-1:1.5
	dnoyeb1:1.5.0.4
	repack:1.5.0.2
	Root_repack:1.5
	Before_FigureVisitor:1.5
	JHotDraw_5-3:1.2
	JHotDraw_5-2_merged:1.1;
locks; strict;
comment	@# @;


1.8
date	2004.01.09.22.53.40;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.13.22.31.11;	author mtnygard;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.25.09.37.01;	author pmorch;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.30.20.40.06;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.24.20.44.32;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.09.15.31.46;	author mrfloppy;	state Exp;
branches;
next	;


desc
@@


1.8
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)StandardLayouter.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.contrib;

import java.awt.Point;
import java.awt.Rectangle;

// JUnitDoclet begin import
import org.jhotdraw.framework.Figure;
import org.jhotdraw.framework.FigureEnumeration;
// JUnitDoclet end import

/**
 * A StandardLayouter contains standard algorithm for
 * layouting a Layoutable. As a standard behaviour
 * all child components of a Layoutable are laid out
 * underneath each other starting from top to bottom while the
 * x position of all child components stays the same and the width
 * is forced to the width of the maximum width. At the end
 * the presentation figure of the Layoutable is
 * set to the maximum x and y size to encompass all contained
 * child components graphically as well.
 *
 * @@author	Wolfram Kaiser
 * @@version <$CURRENT_VERSION$>
 */
public class StandardLayouter extends SimpleLayouter {

	/**
	 * Default constructor which is needed for the Storable mechanism.
	 * Usually, the constructor which takes a Layoutable
	 * should be used as each StandardLayouter is associated
	 * with exactly one Layoutable.
	 */
	public StandardLayouter() {
		this(null);
	}

	/**
	 * Constructor which associates a StandardLayouter with
	 * a certain Layoutable.
	 *
	 * @@param	newLayoutable	Layoutable to be laid out
	 */
	public StandardLayouter(Layoutable newLayoutable) {
		super(newLayoutable);
	}

	/**
	 * Create a new instance of this type and sets the layoutable
	 */
	public Layouter create(Layoutable newLayoutable) {
		return new StandardLayouter(newLayoutable);
	}

	/**
	 * Calculate the layout for the figure and all its
	 * subelements. The layout is not actually performed but just
	 * its dimensions are calculated.  The insets for this figure
	 * are included in the return value.
	 *
	 * @@param origin start point for the layout
	 * @@param corner minimum corner point for the layout
	 */
	public Rectangle calculateLayout(Point origin, Point corner) {
		int maxWidth = Math.abs(corner.x - origin.x);
		int maxHeight = getInsets().top;

		// layout enclosed Layoutable and find maximum width
		FigureEnumeration fe = getLayoutable().figures();
		while (fe.hasNextFigure()) {
			Figure currentFigure = fe.nextFigure();
			Rectangle r = null;
			if (currentFigure instanceof Layoutable) {
				Layouter layoutStrategy = ((Layoutable)currentFigure).getLayouter();
				r = layoutStrategy.calculateLayout(
					new Point(0, 0), new Point(0, 0));
			}
			else {
				r = new Rectangle(currentFigure.displayBox().getBounds());
			}
			maxWidth = Math.max(maxWidth,
					    r.width + getInsets().left +
					    getInsets().right);
			maxHeight += r.height;
		}
		maxHeight += getInsets().bottom;

		return new Rectangle(origin.x, origin.y, maxWidth, maxHeight);
	}

	/**
	 * Method which lays out a figure. It is called by the figure
	 * if a layout task is to be performed. First, the layout dimension for
	 * the figure is calculated and then the figure is arranged newly.
	 * All child component are place beneath another. The figure and all
	 * its children are forced to the minimium width
	 *
	 * @@param origin start point for the layout
	 * @@param corner minimum corner point for the layout
	 */
	public Rectangle layout(Point origin, Point corner) {
		// calculate the layout of the figure and its sub-figures first
		Rectangle r = calculateLayout(origin, corner);

		int maxHeight = getInsets().top;
		FigureEnumeration fe = getLayoutable().figures();
		while (fe.hasNextFigure()) {
			Figure currentFigure = fe.nextFigure();

			Point partOrigin = new Point(r.x + getInsets().left, r.y + maxHeight);
			Point partCorner = new Point
				(r.x + r.width - getInsets().right,
				 r.y + maxHeight +
				 currentFigure.displayBox().height);
			currentFigure.displayBox(partOrigin, partCorner);

			maxHeight += currentFigure.displayBox().height;
		}

		return new Rectangle(r.x, r.y, r.width, maxHeight + getInsets().bottom);
	}
}
@


1.7
log
@Eliminate some deprecated method warnings.
Organize imports to remove Eclipse warnings about unused imports.
@
text
@d12 1
a12 1
package CH.ifa.draw.contrib;
d18 2
a19 2
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
@


1.6
log
@This is a fix as described in
"StandardLayouter.calculateLayout and insets"
in the Open Discussion forum.

The return value from StandardLayouter.calculateLayout(Point, Point) did not include the insets for itself, but did grow subfigures with their respective insets (it assumed that the subfigures also did't include the insets in their return values).

However, the fact that calculateLayout did not include inset dimensions was in contradiction to SimpleLayouter and how the Layouter is used in GraphicalCompositeFigure. There insets *are* assumed to be included in the return value from calculateLayout.

StandardLayouter now includes insets in calculateLayout() and the comment in the Layouter interface has been modified to directly specify that the inset dimensions must be included

This also deprecates my two earlier proposed fixes in these two postings:
"Pls approve fix for StandardLayouter.java"
"Patch for StandardLayouter.layout weirdness"
@
text
@d14 7
a20 3
import CH.ifa.draw.framework.*;
import CH.ifa.draw.contrib.*;
import java.awt.*;
@


1.5
log
@after variou merges... (before 5.4 release)
@
text
@d61 5
a65 4
	/*
	 * Calculate the layout for the figure and all its subelements. The
	 * layout is not actually performed but just its dimensions are calculated.
	 * Insets are added for all non-top-level figures.
d72 1
a72 1
		int maxHeight = 0;
a82 3
				// add insets to calculated rectangle
				r.grow(layoutStrategy.getInsets().left + layoutStrategy.getInsets().right,
						layoutStrategy.getInsets().top + layoutStrategy.getInsets().bottom);
d87 3
a89 1
			maxWidth = Math.max(maxWidth, r.width);
d92 1
d117 4
a120 6

			// Fix for bug request ID 548000
			// Previously was
			//      Point partCorner = new Point(r.x + getInsets().left + r.width, r.y + currentFigure.displayBox().height);
			// The right inset wasn't included in the calculation
			Point partCorner = new Point(r.x + getInsets().left - getInsets().right + r.width, r.y + currentFigure.displayBox().height);
a125 5
		// the maximum width has been already calculated
		// Fix for bug request ID 548000
		// Previously was
		//      Point partCorner = new Point(r.x + getInsets().left + r.width, r.y + currentFigure.displayBox().height);
		// The right inset wasn't included in the calculation
d128 1
a128 1
}@


1.4
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@a15 1
import CH.ifa.draw.util.*;
a16 1
import java.io.*;
d32 1
a32 13
public class StandardLayouter implements Layouter {

	/**
	 * The Layoutable which should be laid out.
	 */
	private Layoutable myLayoutable;

	/**
	 * Insets to calculate a border
	 */
	private Insets myInsets;

	static final long serialVersionUID = 2928651014089117493L;
d41 1
a41 1
		setInsets(new Insets(0, 0, 0, 0));
d51 1
a51 2
		this();
		setLayoutable(newLayoutable);
a60 18
	/**
	 * Get the figure upon which the layout strategy operates.
	 *
	 * @@return associated figure which should be laid out
	 */
	public Layoutable getLayoutable() {
		return myLayoutable;
	}

	/**
	 * Set the figure upon which the layout strategy operates.
	 *
	 * @@param	newLayoutable	Layoutable to be laid out
	 */
	public void setLayoutable(Layoutable newLayoutable) {
		myLayoutable = newLayoutable;
	}

d74 3
a76 3
		FigureEnumeration enum = getLayoutable().figures();
		while (enum.hasMoreElements()) {
			Figure currentFigure = enum.nextFigure();
d111 3
a113 3
		FigureEnumeration enum = getLayoutable().figures();
		while (enum.hasMoreElements()) {
			Figure currentFigure = enum.nextFigure();
a132 32
	}

	/**
	 * Reads the contained figures from StorableInput.
	 */
	public void read(StorableInput dr) throws IOException {
		setLayoutable((Layoutable)dr.readStorable());
	}

	/**
	 * Writes the contained figures to the StorableOutput.
	 */
	public void write(StorableOutput dw) {
		dw.writeStorable(getLayoutable());
	}

	/**
	 * Set the insets for spacing between the figure and its subfigures
	 *
	 * @@param newInsets new spacing dimensions
	 */
	public void setInsets(Insets newInsets) {
		myInsets = newInsets;
	}

	/**
	 * Get the insets for spacing between the figure and its subfigures
	 *
	 * @@return spacing dimensions
	 */
	public Insets getInsets() {
		return myInsets;
@


1.3
log
@no message
@
text
@d55 1
d65 1
a65 1
		setInsets(new Insets(0, 0, 0, 0));
d67 7
@


1.2
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@d21 1
a21 1
 * A StandardLayouter contains standard algorithm for 
d40 1
a40 1
	
d45 1
a45 1
	
d62 1
a62 1
	 */	
d67 1
a67 1
	
d72 1
a72 1
	 */ 
d93 1
a93 1
	 */	
d97 1
a97 1
		
d130 1
a130 1
	 */	
d141 6
a146 1
			Point partCorner = new Point(r.x + getInsets().left + r.width, r.y + currentFigure.displayBox().height);
d151 1
a151 1
		
d153 5
a157 1
		return new Rectangle(r.x, r.y, r.x + r.width, r.y + maxHeight + getInsets().bottom);
d166 1
a166 1
	
d187 1
a187 1
	 */	
@


1.1
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)StandardLayouter.java 5.2
d4 6
d32 1
@

