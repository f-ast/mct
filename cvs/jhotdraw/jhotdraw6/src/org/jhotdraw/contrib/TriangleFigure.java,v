head	1.6;
access;
symbols
	jhotdraw60b1-release:1.6
	package_rename:1.6
	directory_rename:1.5
	reorg_6x_split_initial:1.5
	MVC_PHASE1:1.5.0.4
	NEW_ATTRIBUTES:1.5.0.2
	DNOYEB1_ALPHA-2:1.4
	release_JHD54b1:1.4
	BUGFIX_670992:1.4.0.6
	DNOYEB1_ALPHA-1:1.4
	dnoyeb1:1.4.0.4
	repack:1.4.0.2
	Root_repack:1.4
	Before_FigureVisitor:1.4
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.1.1.1
	JHotDraw_5-1_initial:1.1.1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2004.01.09.22.53.40;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.04.05.30.12;	author ricardo_padilha;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.24.20.32.00;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.08;	author jeckel;	state Exp;
branches;
next	;


desc
@@


1.6
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)TriangleFigure.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.contrib;

import org.jhotdraw.util.*;
import org.jhotdraw.figures.*;
import org.jhotdraw.framework.HandleEnumeration;
import org.jhotdraw.standard.HandleEnumerator;

import java.awt.*;
import java.util.List;
import java.io.IOException;

/**
 * A triangle with same dimensions as its enclosing rectangle,
 * and apex at any of 8 places
 *
 * @@author Doug Lea  (dl at gee, Tue Feb 25 17:30:58 1997)
 * @@version <$CURRENT_VERSION$>
 */
public  class TriangleFigure extends RectangleFigure {

	static double[] rotations = {
		-Math.PI/2, -Math.PI/4,
		0.0, Math.PI/4,
		Math.PI/2, Math.PI * 3/4,
		Math.PI,  -Math.PI * 3/4
	};

	private int fRotation = 0;

	public TriangleFigure() {
		super(new Point(0,0), new Point(0,0));
	}

	public TriangleFigure(Point origin, Point corner) {
		super(origin, corner);
	}

	public HandleEnumeration handles() {
		List h = super.handles().toList();
		h.add(new TriangleRotationHandle(this));
		return new HandleEnumerator(h);
	}

	public void rotate(double angle) {
		willChange();
		double dist = Double.MAX_VALUE;
		int best = 0;
		for (int i = 0; i < rotations.length; ++i) {
			double d = Math.abs(angle - rotations[i]);
			if (d < dist) {
				dist = d;
				best = i;
			}
		}
		fRotation = best;
		changed();
	}

	/** Return the polygon describing the triangle **/
	public Polygon getPolygon() {
		Rectangle r = displayBox();
		Polygon p = new Polygon();
		switch (fRotation) {
		case 0:
			p.addPoint(r.x + r.width/2, r.y);
			p.addPoint(r.x + r.width, r.y + r.height);
			p.addPoint(r.x, r.y + r.height);
			break;
		case 1:
			p.addPoint(r.x + r.width, r.y);
			p.addPoint(r.x + r.width, r.y + r.height);
			p.addPoint(r.x, r.y);
			break;
		case 2:
			p.addPoint(r.x + r.width, r.y + r.height/2);
			p.addPoint(r.x, r.y + r.height);
			p.addPoint(r.x, r.y);
			break;
		case 3:
			p.addPoint(r.x + r.width, r.y + r.height);
			p.addPoint(r.x, r.y + r.height);
			p.addPoint(r.x + r.width, r.y);
			break;
		case 4:
			p.addPoint(r.x + r.width/2, r.y + r.height);
			p.addPoint(r.x, r.y);
			p.addPoint(r.x + r.width, r.y);
			break;
		case 5:
			p.addPoint(r.x, r.y + r.height);
			p.addPoint(r.x, r.y);
			p.addPoint(r.x + r.width, r.y + r.height);
			break;
		case 6:
			p.addPoint(r.x, r.y + r.height/2);
			p.addPoint(r.x + r.width, r.y);
			p.addPoint(r.x + r.width, r.y + r.height);
			break;
		case 7:
			p.addPoint(r.x, r.y);
			p.addPoint(r.x + r.width, r.y);
			p.addPoint(r.x, r.y + r.height);
			break;
		}
		return p;
	}


	public void draw(Graphics g) {
		Polygon p = getPolygon();
		g.setColor(getFillColor());
		g.fillPolygon(p);
		g.setColor(getFrameColor());
		g.drawPolygon(p);
	}

	public Insets connectionInsets() {
		Rectangle r = displayBox();
		switch(fRotation) {
		case 0:
			return new Insets(r.height, r.width/2, 0, r.width/2);
		case 1:
			return new Insets(0, r.width, r.height, 0);
		case 2:
			return new Insets(r.height/2, 0, r.height/2, r.width);
		case 3:
			return new Insets(r.height, r.width, 0, 0);
		case 4:
			return new Insets(0, r.width/2, r.height, r.width/2);
		case 5:
			return new Insets(r.height, 0, 0, r.width);
		case 6:
			return new Insets(r.height/2, r.width, r.height/2, 0);
		case 7:
			return new Insets(0, 0, r.height, r.width);
		default:
			return null;
		}
	}

	public boolean containsPoint(int x, int y) {
		return getPolygon().contains(x, y);
	}

	public Point center() {
		return PolygonFigure.center(getPolygon());
	}

	public Point chop(Point p) {
		return PolygonFigure.chop(getPolygon(), p);
	}

	public Object clone() {
		TriangleFigure figure = (TriangleFigure) super.clone();
		figure.fRotation = fRotation;
		return figure;
	}

	public double getRotationAngle() {
		return rotations[fRotation];
	}

	//-- store / load ----------------------------------------------

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fRotation);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fRotation = dr.readInt();
	}
}
@


1.5
log
@Removed unused imports and local variables.
@
text
@d12 1
a12 1
package CH.ifa.draw.contrib;
d14 4
a17 4
import CH.ifa.draw.util.*;
import CH.ifa.draw.figures.*;
import CH.ifa.draw.framework.HandleEnumeration;
import CH.ifa.draw.standard.HandleEnumerator;
@


1.4
log
@after variou merges... (before 5.4 release)
@
text
@a19 1
import java.util.*;
@


1.3
log
@merge dnd (before 5.3)
@
text
@a13 1
import CH.ifa.draw.framework.*;
a14 1
import CH.ifa.draw.standard.*;
d16 3
d21 1
d34 1
a34 1
		-Math.PI/2, -Math.PI/4, 
d36 1
a36 1
		Math.PI/2, Math.PI * 3/4, 
d50 4
a53 4
	public Vector handles() {
		Vector h = super.handles();
		h.addElement(new TriangleRotationHandle(this));
		return h;
d174 1
a174 1
	
@


1.2
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d38 1
a38 1
	protected int fRotation = 0;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2
 * Hacked together by Doug lea
 * Tue Feb 25 17:30:58 1997  Doug Lea  (dl at gee)
d4 6
a13 3
import java.awt.*;
import java.util.*;
import java.io.IOException;
d18 3
d25 3
d31 153
a183 151
  static double[] rotations = {
    -Math.PI/2, -Math.PI/4,
    0.0, Math.PI/4,
    Math.PI/2, Math.PI * 3/4,
    Math.PI,  -Math.PI * 3/4
  };

  protected int fRotation = 0;

  public TriangleFigure() {
    super(new Point(0,0), new Point(0,0));
  }

  public TriangleFigure(Point origin, Point corner) {
    super(origin, corner);
  }

  public Vector handles() {
    Vector h = super.handles();
    h.addElement(new TriangleRotationHandle(this));
    return h;
  }

  public void rotate(double angle) {
    willChange();
    //System.out.println("a:"+angle);
    double dist = Double.MAX_VALUE;
    int best = 0;
    for (int i = 0; i < rotations.length; ++i) {
      double d = Math.abs(angle - rotations[i]);
      if (d < dist) {
        dist = d;
        best = i;
      }
    }
    fRotation = best;
    changed();
  }

  /** Return the polygon describing the triangle **/
  public Polygon polygon() {
    Rectangle r = displayBox();
    Polygon p = new Polygon();
    switch (fRotation) {
    case 0:
      p.addPoint(r.x+r.width/2, r.y);
      p.addPoint(r.x+r.width, r.y+r.height);
      p.addPoint(r.x, r.y+r.height);
      break;
    case 1:
      p.addPoint(r.x + r.width, r.y);
      p.addPoint(r.x+r.width, r.y+r.height);
      p.addPoint(r.x, r.y);
      break;
    case 2:
      p.addPoint(r.x + r.width, r.y+r.height/2);
      p.addPoint(r.x, r.y+r.height);
      p.addPoint(r.x, r.y);
      break;
    case 3:
      p.addPoint(r.x+r.width, r.y+r.height);
      p.addPoint(r.x, r.y+r.height);
      p.addPoint(r.x + r.width, r.y);
      break;
    case 4:
      p.addPoint(r.x+r.width/2, r.y+r.height);
      p.addPoint(r.x, r.y);
      p.addPoint(r.x + r.width, r.y);
      break;
    case 5:
      p.addPoint(r.x, r.y+r.height);
      p.addPoint(r.x, r.y);
      p.addPoint(r.x+r.width, r.y+r.height);
      break;
    case 6:
      p.addPoint(r.x, r.y+r.height/2);
      p.addPoint(r.x + r.width, r.y);
      p.addPoint(r.x+r.width, r.y+r.height);
      break;
    case 7:
      p.addPoint(r.x, r.y);
      p.addPoint(r.x + r.width, r.y);
      p.addPoint(r.x, r.y+r.height);
      break;
    }
    return p;
  }


  public void draw(Graphics g) {
    Polygon p = polygon();
    g.setColor(getFillColor());
    g.fillPolygon(p);
    g.setColor(getFrameColor());
    g.drawPolygon(p);
  }


  public Insets connectionInsets() {
    Rectangle r = displayBox();
    switch(fRotation) {
    case 0:
      return new Insets(r.height, r.width/2, 0, r.width/2);
    case 1:
      return new Insets(0, r.width, r.height, 0);
    case 2:
      return new Insets(r.height/2, 0, r.height/2, r.width);
    case 3:
      return new Insets(r.height, r.width, 0, 0);
    case 4:
      return new Insets(0, r.width/2, r.height, r.width/2);
    case 5:
      return new Insets(r.height, 0, 0, r.width);
    case 6:
      return new Insets(r.height/2, r.width, r.height/2, 0);
    case 7:
      return new Insets(0, 0, r.height, r.width);
    default:
      return null;
    }
  }

  public boolean containsPoint(int x, int y) {
    return polygon().contains(x, y);
  }

  public Point center() {
    return PolygonFigure.center(polygon());
  }

  public Point chop(Point p) {
    return PolygonFigure.chop(polygon(), p);
  }

  public Object clone() {
    TriangleFigure figure = (TriangleFigure) super.clone();
    figure.fRotation = fRotation;
    return figure;
  }

    //-- store / load ----------------------------------------------

    public void write(StorableOutput dw) {
      super.write(dw);
      dw.writeInt(fRotation);
    }

    public void read(StorableInput dr) throws IOException {
      super.read(dr);
      fRotation = dr.readInt();
    }
@


1.1.1.1
log
@
Initial revision.
@
text
@@
