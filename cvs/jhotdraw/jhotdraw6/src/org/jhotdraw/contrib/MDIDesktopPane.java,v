head	1.17;
access;
symbols
	jhotdraw60b1-release:1.17
	package_rename:1.17
	directory_rename:1.16
	reorg_6x_split_initial:1.16
	MVC_PHASE1:1.14.0.2
	NEW_ATTRIBUTES:1.13.0.2
	DNOYEB1_ALPHA-2:1.5.4.4
	release_JHD54b1:1.10
	BUGFIX_670992:1.9.0.2
	DNOYEB1_ALPHA-1:1.5.4.3
	dnoyeb1:1.5.0.4
	repack:1.5.0.2
	Root_repack:1.5
	Before_FigureVisitor:1.5
	JHotDraw_5-3:1.2;
locks; strict;
comment	@# @;


1.17
date	2004.01.09.22.53.40;	author mrfloppy;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.09.21.18.45;	author mrfloppy;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.08.15.41.25;	author ricardo_padilha;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.22.23.58.41;	author mrfloppy;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.12.00.33.39;	author dnoyeb;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.04.03.32.59;	author ricardo_padilha;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.03.12.54.59;	author ricardo_padilha;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.30.00.27.33;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.12.20.21.16;	author dnoyeb;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.03.00.55.32;	author dnoyeb;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.02.19.05.46;	author dnoyeb;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.02.17.38.40;	author dnoyeb;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.07.15.55.41;	author mrfloppy;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.08.04.22.39.17;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.20.19.57.58;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.24.21.15.18;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.24.20.37.14;	author mrfloppy;	state Exp;
branches;
next	;

1.5.4.1
date	2003.01.03.15.57.42;	author dnoyeb;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.01.03.16.03.57;	author dnoyeb;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.01.07.21.22.29;	author dnoyeb;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.01.29.04.41.13;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.17
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)MDIDesktopPane.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.contrib;

import org.jhotdraw.framework.DrawingView;
import org.jhotdraw.standard.NullDrawingView;
import org.jhotdraw.application.DrawApplication;

import javax.swing.*;
import javax.swing.event.InternalFrameListener;
import javax.swing.event.InternalFrameAdapter;
import javax.swing.event.InternalFrameEvent;
import java.awt.*;
import java.beans.*;

/**
 * An extension of JDesktopPane that supports often used MDI functionality. This
 * class also handles setting scroll bars for when windows move too far to the left or
 * bottom, providing the MDIDesktopPane is in a ScrollPane.
 * Note by dnoyeb: I dont know why the container does not fire frame close events when the frames
 * are removed from the container with remove as opposed to simply closed with the
 * "x".  so if you say removeAll from container you wont be notified.  No biggie.
 *
 * @@author Wolfram Kaiser (adapted from an article in JavaWorld)
 * @@author  C.L.Gilbert <dnoyeb@@users.sourceforge.net>
 * @@version <$CURRENT_VERSION$>
 */
public class MDIDesktopPane extends JDesktopPane implements Desktop {
	private static int FRAME_OFFSET=20;
	private MDIDesktopManager manager;
	private DrawApplication myDrawApplication;
	private DesktopEventService myDesktopEventService;

	private DrawingView selectedView;

	public MDIDesktopPane(DrawApplication newDrawApplication) {
		setDesktopEventService(createDesktopEventService());
		setDrawApplication(newDrawApplication);
		manager=new MDIDesktopManager(this);
		setDesktopManager(manager);
		setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);
		setAlignmentX(JComponent.LEFT_ALIGNMENT);
	}

	protected InternalFrameListener internalFrameListener = new InternalFrameAdapter() {
	    /**
	     * Invoked when a internal frame has been opened.
         * @@see javax.swing.JInternalFrame#show
		 * if dv is null assert
         */
	    public void internalFrameOpened(InternalFrameEvent e) {
			DrawingView dv = Helper.getDrawingView(e.getInternalFrame());
			fireDrawingViewAddedEvent(dv);
	    }

		/**
		 * Invoked when an internal frame is in the process of being closed.
		 * The close operation can be overridden at this point.
		 * @@see javax.swing.JInternalFrame#setDefaultCloseOperation
		 */
		//public void internalFrameClosing(InternalFrameEvent e) {
		//}

		/**
		 * Invoked when an internal frame has been closed.
		 * if dv is null assert
		 * if this is the last view set it to null
		 * @@see javax.swing.JInternalFrame#setClosed
		 */
		public void internalFrameClosed(InternalFrameEvent e) {
			DrawingView dv = Helper.getDrawingView(e.getInternalFrame());
			if (getComponentCount() == 0){
				DrawingView oldView = getActiveDrawingView();
				setActiveDrawingView(NullDrawingView.getManagedDrawingView(oldView.editor()));
				fireDrawingViewSelectedEvent(oldView, getActiveDrawingView());
			}
			fireDrawingViewRemovedEvent(dv);
		}

		/**
		 * Invoked when an internal frame is iconified.
		 * @@see javax.swing.JInternalFrame#setIcon
		 */
		//public void internalFrameIconified(InternalFrameEvent e) {
		//}

		/**
		 * Invoked when an internal frame is de-iconified.
		 * @@see javax.swing.JInternalFrame#setIcon
		 */
		//public void internalFrameDeiconified(InternalFrameEvent e) {
		//}

		/**
		 * Invoked when an internal frame is activated.
		 * @@see javax.swing.JInternalFrame#setSelected
		 * if this frame has a null drawingView then assert
		 * because their should be no null frames being selected
		 * this does not include NullDrawingView which is acceptable
		 */
		public void internalFrameActivated(InternalFrameEvent e) {
			DrawingView dv = Helper.getDrawingView(e.getInternalFrame());
			DrawingView oldView = getActiveDrawingView();
			setActiveDrawingView(dv);
			fireDrawingViewSelectedEvent(oldView, getActiveDrawingView());
		}

		//public void internalFrameDeactivated(InternalFrameEvent e) {
		//}
	};


	protected void fireDrawingViewAddedEvent(final DrawingView dv) {
		getDesktopEventService().fireDrawingViewAddedEvent(dv);
	}

	protected void fireDrawingViewRemovedEvent(final DrawingView dv) {
		getDesktopEventService().fireDrawingViewRemovedEvent(dv);
	}

	protected void fireDrawingViewSelectedEvent(final DrawingView oldView, final DrawingView newView) {
		getDesktopEventService().fireDrawingViewSelectedEvent(oldView, newView);
	}

/*	public void setBounds(int x, int y, int w, int h) {
		super.setBounds(x,y,w,h);
		checkDesktopSize();
	}
*/

	protected Component createContents(DrawingView dv) {
		JScrollPane sp = new JScrollPane((Component) dv);
		sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
		sp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
		sp.setAlignmentX(LEFT_ALIGNMENT);

		String applicationTitle;
		if (dv.drawing().getTitle() == null) {
			applicationTitle = getDrawApplication().getApplicationName() + " - " + getDrawApplication().getDefaultDrawingTitle();
		}
		else {
			applicationTitle = getDrawApplication().getApplicationName() + " - " + dv.drawing().getTitle();
		}
		JInternalFrame internalFrame = new JInternalFrame(applicationTitle, true, true, true, true);
		internalFrame.setName(applicationTitle);
		internalFrame.getContentPane().add(sp);
		internalFrame.setSize(200,200);
		return internalFrame;
	}

	public DrawingView getActiveDrawingView() {
		return selectedView;
	}

	protected void setActiveDrawingView(DrawingView newSelectedView) {
		selectedView = newSelectedView;
	}

	public void updateTitle(String newDrawingTitle) {
		getSelectedFrame().setTitle(newDrawingTitle);
	}

	/**
	 * This must match the signature of the superclass it is overriding or the
	 * method invocation may not resolve to this method unless it is called on
	 * a reference of specifically MDIDesktopPane type.  So this must be
	 * Component add(Component comp) in order to override its super class and
	 * Component add(JInternalFrame frame) will not properly override the super-
	 * class, but instead overload it.
	 *
	 * Note be sure to call this method and not add() when you want to add to the
	 * desktop.  This allows complex desktops to be created.  For instance, you can
	 * add split panes and scroll panes and such as normal with the add() method
	 * but then to get to the actual desktop you would still call this method.
	 */
	public void addToDesktop(DrawingView dv, int location) {
		JInternalFrame frame = (JInternalFrame)createContents(dv);
		JInternalFrame[] array = getAllFrames();
		Point p = null;
		int w;
		int h;

		//should be done before added to desktop
		frame.addInternalFrameListener(internalFrameListener);
		super.add(frame);

		checkDesktopSize();
		if (array.length > 0) {
			p = array[0].getLocation();
			p.x = p.x + FRAME_OFFSET;
			p.y = p.y + FRAME_OFFSET;
		}
		else {
			p = new Point(0, 0);
		}
		frame.setLocation(p.x, p.y);
		if (frame.isResizable()) {
			w = getWidth() - (getWidth() / 3);
			h = getHeight() - (getHeight() / 3);
			if (w < frame.getMinimumSize().getWidth()) {
				w = (int)frame.getMinimumSize().getWidth();
			}
			if (h < frame.getMinimumSize().getHeight()) {
				h = (int)frame.getMinimumSize().getHeight();
			}
			frame.setSize(w, h);
		}
		moveToFront(frame);
		frame.setVisible(true);
		try {
			frame.setSelected(true);
		}
		catch (PropertyVetoException e) {
			frame.toBack();
		}
	}

	public void removeFromDesktop(DrawingView dv, int location) {
		Component[] comps = getComponents();
		for (int x=0; x<comps.length; x++) {
			if (dv == Helper.getDrawingView(comps[x])) {
				((JInternalFrame)comps[x]).dispose();
			    break;
			}
		}
		checkDesktopSize();
	}

	public void removeAllFromDesktop(int location) {
		JInternalFrame[] jifs = getAllFrames();
		for (int x=0; x < jifs.length; x++) {
			jifs[x].dispose();
		}
	}

	public DrawingView[] getAllFromDesktop(int location){
		Component[] comps = getComponents();
		java.util.ArrayList al = new java.util.ArrayList();
		for (int x=0; x<comps.length; x++) {
			DrawingView dv = Helper.getDrawingView(comps[x]);
			if (dv != null) {
				al.add(dv);
			}
		}
		DrawingView[] dvs = new DrawingView[al.size()];
		al.toArray(dvs);
		return dvs;
	}
/*
	public void setSelectedDrawingView(DrawingView dv) {
		Component[] comps = getComponents();
		for (int x=0; x < comps.length; x++) {
			DrawingView dv2 = Helper.getDrawingView(comps[x]);
		    if (dv == dv2) {
				JInternalFrame frame = (JInternalFrame)comps[x];
				try {
					//moveToFront(frame);
					frame.setSelected(true);
				}
				catch(java.beans.PropertyVetoException pve) {
				    System.out.println(pve);
				}
		    }
		}
	}
*/
	protected DesktopEventService getDesktopEventService() {
		return myDesktopEventService;
	}

	private void setDesktopEventService(DesktopEventService newDesktopEventService) {
		myDesktopEventService = newDesktopEventService;
	}

	protected DesktopEventService createDesktopEventService() {
		return new DesktopEventService(this, this);
	}

	public void addDesktopListener(DesktopListener dpl) {
		getDesktopEventService().addDesktopListener(dpl);
	}

	public void removeDesktopListener(DesktopListener dpl) {
		getDesktopEventService().removeDesktopListener(dpl);
	}

	/**
	 * Cascade all internal frames
	 */
	public void cascadeFrames() {
		int x = 0;
		int y = 0;
		JInternalFrame[] allFrames = getAllFrames();

		// do nothing if no frames to work with
		if (allFrames.length == 0) {
			return;
		}

		manager.setNormalSize();

		int frameHeight = (getBounds().height - 5) - allFrames.length * FRAME_OFFSET;
		int frameWidth = (getBounds().width - 5) - allFrames.length * FRAME_OFFSET;
		for (int i = allFrames.length - 1; i >= 0; i--) {
			try {
				allFrames[i].setMaximum(false);
			}
			catch (PropertyVetoException e) {
				e.printStackTrace();
			}

			allFrames[i].setBounds(x, y, frameWidth, frameHeight);
			x = x + FRAME_OFFSET;
			y = y + FRAME_OFFSET;
		}

		checkDesktopSize();
	}

	/**
	 * Tile all internal frames<br>
	 *
	 * @@deprecated use tileFramesHorizontally() instead
	 *
	 */
	public void tileFrames() {
		tileFramesHorizontally();
	}

	public void tileFramesHorizontally() {
		Component[] allFrames = getAllFrames();

		// do nothing if no frames to work with
		if (allFrames.length == 0) {
			return;
		}

		manager.setNormalSize();

		int frameHeight = getBounds().height/allFrames.length;
		int y = 0;
		for (int i = 0; i < allFrames.length; i++) {
			try {
				((JInternalFrame)allFrames[i]).setMaximum(false);
			}
			catch (PropertyVetoException e) {
				e.printStackTrace();
			}

			allFrames[i].setBounds(0, y, getBounds().width,frameHeight);
			y = y + frameHeight;
		}

		checkDesktopSize();
	}

	public void tileFramesVertically() {
		Component[] allFrames = getAllFrames();

		// do nothing if no frames to work with
		if (allFrames.length == 0) {
			return;
		}
		manager.setNormalSize();

		int frameWidth = getBounds().width/allFrames.length;
		int x = 0;
		for (int i = 0; i < allFrames.length; i++) {
			try {
				((JInternalFrame)allFrames[i]).setMaximum(false);
			}
			catch (PropertyVetoException e) {
				e.printStackTrace();
			}

			allFrames[i].setBounds(x, 0, frameWidth, getBounds().height);
			x = x + frameWidth;
		}

		checkDesktopSize();
	}

	/**
	 * Arranges the frames as efficiently as possibly with preference for
	 * keeping vertical size maximal.<br>
	 *
	 */
	public void arrangeFramesVertically() {
		Component[] allFrames = getAllFrames();
		// do nothing if no frames to work with
		if (allFrames.length == 0) {
			return;
		}

		manager.setNormalSize();

		int vertFrames = (int)Math.floor(Math.sqrt(allFrames.length));
		int horFrames = (int)Math.ceil(Math.sqrt(allFrames.length));

		// first arrange the windows that have equal size
		int frameWidth = getBounds().width / horFrames;
		int frameHeight = getBounds().height / vertFrames;
		int x = 0;
		int y = 0;
		int frameIdx = 0;
		for (int horCnt = 0; horCnt < horFrames-1; horCnt++) {
			y = 0;
			for (int vertCnt = 0; vertCnt < vertFrames; vertCnt++) {
				try {
					((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
				}
				catch (PropertyVetoException e) {
					e.printStackTrace();
				}

				allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
				frameIdx++;
				y = y + frameHeight;
			}
			x = x + frameWidth;
		}

		// the rest of the frames are tiled down on the last column with equal
		// height
		frameHeight = getBounds().height / (allFrames.length - frameIdx);
		y = 0;
		for (; frameIdx < allFrames.length; frameIdx++)
		{
			try {
				((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
			}
			catch (PropertyVetoException e) {
				e.printStackTrace();
			}

			allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
			y = y + frameHeight;
		}

		checkDesktopSize();
	}

	/**
	 * Arranges the frames as efficiently as possibly with preference for
	 * keeping horizontal size maximal.<br>
	 *
	 */
	public void arrangeFramesHorizontally() {
		Component[] allFrames = getAllFrames();
		// do nothing if no frames to work with
		if (allFrames.length == 0) {
			return;
		}

		manager.setNormalSize();

		int vertFrames = (int)Math.ceil(Math.sqrt(allFrames.length));
		int horFrames = (int)Math.floor(Math.sqrt(allFrames.length));

		// first arrange the windows that have equal size
		int frameWidth = getBounds().width / horFrames;
		int frameHeight = getBounds().height / vertFrames;
		int x = 0;
		int y = 0;
		int frameIdx = 0;
		for (int vertCnt = 0; vertCnt < vertFrames-1; vertCnt++) {
			x = 0;
			for (int horCnt = 0; horCnt < horFrames; horCnt++) {
				try {
					((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
				}
				catch (PropertyVetoException e) {
					e.printStackTrace();
				}

				allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
				frameIdx++;
				x = x + frameWidth;
			}
			y = y + frameHeight;
		}

		// the rest of the frames are tiled down on the last column with equal
		// height
		frameWidth = getBounds().width / (allFrames.length - frameIdx);
		x = 0;
		for (; frameIdx < allFrames.length; frameIdx++) {
			try {
				((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
			}
			catch (PropertyVetoException e) {
				e.printStackTrace();
			}

			allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
			x = x + frameWidth;
		}

		checkDesktopSize();
	}

	/**
	 * Sets all component size properties ( maximum, minimum, preferred)
	 * to the given dimension.
	 */
	public void setAllSize(Dimension d) {
		setMinimumSize(d);
		setMaximumSize(d);
		setPreferredSize(d);
		setBounds(0, 0, d.width, d.height);
	}

	/**
	 * Sets all component size properties ( maximum, minimum, preferred)
	 * to the given width and height.
	 */
	public void setAllSize(int width, int height) {
		setAllSize(new Dimension(width,height));
	}

	private void checkDesktopSize() {
		if ((getParent() != null) && isVisible()) {
			manager.resizeDesktop();
		}
	}

	private void setDrawApplication(DrawApplication newDrawApplication) {
		myDrawApplication = newDrawApplication;
	}

	protected DrawApplication getDrawApplication() {
		return myDrawApplication;
	}
}

/**
 * Private class used to replace the standard DesktopManager for JDesktopPane.
 * Used to provide scrollbar functionality.
 */
class MDIDesktopManager extends DefaultDesktopManager {
	private MDIDesktopPane desktop;

	public MDIDesktopManager(MDIDesktopPane newDesktop) {
		this.desktop = newDesktop;
	}

	public void endResizingFrame(JComponent f) {
		super.endResizingFrame(f);
		resizeDesktop();
	}

	public void endDraggingFrame(JComponent f) {
		super.endDraggingFrame(f);
		resizeDesktop();
	}

	public void setNormalSize() {
		JScrollPane scrollPane = getScrollPane();
		Insets scrollInsets = getScrollPaneInsets();

		if (scrollPane != null) {
			Dimension d = scrollPane.getVisibleRect().getSize();
			if (scrollPane.getBorder() != null) {
			   d.setSize(d.getWidth() - scrollInsets.left - scrollInsets.right,
						 d.getHeight() - scrollInsets.top - scrollInsets.bottom);
			}

			d.setSize(d.getWidth() - 20, d.getHeight() - 20);
			desktop.setAllSize(d);
			scrollPane.invalidate();
			scrollPane.validate();
		}
	}

	private Insets getScrollPaneInsets() {
		JScrollPane scrollPane = getScrollPane();
		if ((scrollPane == null) || (getScrollPane().getBorder() == null)) {
			return new Insets(0, 0, 0, 0);
		}
		else {
			return getScrollPane().getBorder().getBorderInsets(scrollPane);
		}
	}

	public JScrollPane getScrollPane() {
		if (desktop.getParent() instanceof JViewport) {
			JViewport viewPort = (JViewport)desktop.getParent();
			if (viewPort.getParent() instanceof JScrollPane)
				return (JScrollPane)viewPort.getParent();
		}
		return null;
	}

	protected void resizeDesktop() {
		int x = 0;
		int y = 0;
		JScrollPane scrollPane = getScrollPane();
		Insets scrollInsets = getScrollPaneInsets();

		if (scrollPane != null) {
			JInternalFrame allFrames[] = desktop.getAllFrames();
			for (int i = 0; i < allFrames.length; i++) {
				if (allFrames[i].getX() + allFrames[i].getWidth() > x) {
					x = allFrames[i].getX() + allFrames[i].getWidth();
				}
				if (allFrames[i].getY() + allFrames[i].getHeight() > y) {
					y = allFrames[i].getY() + allFrames[i].getHeight();
				}
			}
			Dimension d=scrollPane.getVisibleRect().getSize();
			if (scrollPane.getBorder() != null) {
			   d.setSize(d.getWidth() - scrollInsets.left - scrollInsets.right,
						 d.getHeight() - scrollInsets.top - scrollInsets.bottom);
			}

			if (x <= d.getWidth()) {
				x = ((int)d.getWidth()) - 20;
			}
			if (y <= d.getHeight()) {
				y = ((int)d.getHeight()) - 20;
			}
			desktop.setAllSize(x,y);
			scrollPane.invalidate();
			scrollPane.validate();
		}
	}
}
@


1.16
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@d12 1
a12 1
package CH.ifa.draw.contrib;
d14 3
a16 3
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.standard.NullDrawingView;
import CH.ifa.draw.application.DrawApplication;
@


1.15
log
@Refactoring of Cursor:
- java.awt.Cursor (class) has been sistematically replaced with CH.ifa.draw.contrib.framework.Cursor (interface)
- a new default implementation of Cursor (interface) has been added: CH.ifa.draw.contrib.standard.AWTCursor
@
text
@d531 3
a533 1
		if ((getParent() != null) && isVisible()) manager.resizeDesktop();
@


1.14
log
@no message
@
text
@a16 1
import CH.ifa.draw.util.CollectionsFactory;
a23 1
import java.util.ListIterator;
d531 1
a531 1
		if (getParent()!=null&&isVisible()) manager.resizeDesktop();
@


1.13
log
@Remove EventListenerList in favor of simple List where possible.
EventListenerList duplicates the whole list for each additional add and is
quite heavy for instances where its not required since these lists are not
modified from events they fire.
@
text
@d15 1
d17 1
d25 1
d43 1
d46 1
a46 6
	/**
	 * The usage of this List for listeners is not thread safe, but should not
	 * need to be.
	 */
	private java.util.List listeners;
	
d48 1
a48 1
		listeners = CH.ifa.draw.util.CollectionsFactory.current().createList();
d84 3
a86 2
				setActiveDrawingView(null);
				fireDrawingViewSelectedEvent(getActiveDrawingView());
d114 1
d116 1
a116 1
			fireDrawingViewSelectedEvent(getActiveDrawingView());
d125 1
a125 9
		java.util.ListIterator li= listeners.listIterator(listeners.size());
		DesktopEvent dpe = null;
		while(li.hasPrevious()){
			if (dpe == null) {
				dpe = new DesktopEvent(MDIDesktopPane.this, dv);
			}
			DesktopListener dpl = (DesktopListener)li.previous();
			dpl.drawingViewAdded(dpe);
		}
d129 1
a129 9
		java.util.ListIterator li= listeners.listIterator(listeners.size());
		DesktopEvent dpe = null;
		while(li.hasPrevious()){
			if (dpe == null) {
				dpe = new DesktopEvent(MDIDesktopPane.this, dv);
			}
			DesktopListener dpl = (DesktopListener)li.previous();
			dpl.drawingViewRemoved(dpe);
		}
d132 2
a133 10
	protected void fireDrawingViewSelectedEvent(final DrawingView dv) {
		java.util.ListIterator li= listeners.listIterator(listeners.size());
		DesktopEvent dpe = null;
		while(li.hasPrevious()){
			if (dpe == null) {
				dpe = new DesktopEvent(MDIDesktopPane.this, dv);
			}
			DesktopListener dpl = (DesktopListener)li.previous();
			dpl.drawingViewSelected(dpe);
		}
a195 3
		// ricardo_padilha: since retval is never used,
		// there is no point in creating it
		//Component retval = super.add(frame);
d278 14
a291 2
	public void addDesktopListener(DesktopListener dpl){
		listeners.add(dpl);
d294 2
a295 2
	public void removeDesktopListener(DesktopListener dpl){
		listeners.remove(dpl);
@


1.12
log
@All "fire*()" methods (related to event dispatching) are tagged as protected. This is a required change, if we want to enable the subclassing of MDIDesktopPane.
@
text
@d41 1
d43 2
a44 2
	 * You need this if you are not using a component that inherits from
	 * JComponent
d46 2
a47 3
	//private final EventListenerList listenerList = new EventListenerList();
	private DrawingView selectedView;

d49 1
d124 1
a124 2
		final Object[] listeners = listenerList.getListenerList();
		DesktopListener dpl;
d126 3
a128 7
		for (int i = listeners.length-2; i >= 0; i -= 2) {
			if (listeners[i] == DesktopListener.class) {
				if (dpe == null) {
					dpe = new DesktopEvent(MDIDesktopPane.this, dv);
				}
				dpl = (DesktopListener)listeners[i+1];
				dpl.drawingViewAdded(dpe);
d130 2
d136 5
a140 10
		final Object[] listeners = listenerList.getListenerList();
		DesktopListener dpl;
		DesktopEvent dpe= null;
		for (int i = listeners.length-2; i >= 0; i -= 2) {
			if (listeners[i] == DesktopListener.class) {
				if (dpe == null) {
					dpe = new DesktopEvent(MDIDesktopPane.this, dv);
				}
				dpl = (DesktopListener)listeners[i+1];
				dpl.drawingViewRemoved(dpe);
d142 2
d148 1
a148 2
		final Object[] listeners = listenerList.getListenerList();
		DesktopListener dpl;
d150 3
a152 7
		for (int i = listeners.length-2; i >= 0; i -= 2) {
			if (listeners[i] == DesktopListener.class) {
				if (dpe == null) {
					dpe = new DesktopEvent(MDIDesktopPane.this, dv);
				}
				dpl = (DesktopListener)listeners[i+1];
				dpl.drawingViewSelected(dpe);
d154 2
d305 1
a305 1
		listenerList.add(DesktopListener.class, dpl);
d309 1
a309 1
	    listenerList.remove(DesktopListener.class, dpl);
@


1.11
log
@Removed an unused local variable in method "addToDesktop".
@
text
@d85 1
a85 1
				fireDrawingViewSelectedEvent(selectedView);
d114 1
a114 1
			fireDrawingViewSelectedEvent(selectedView);
d122 1
a122 1
	private void fireDrawingViewAddedEvent(final DrawingView dv) {
d137 1
a137 1
	private void fireDrawingViewRemovedEvent(final DrawingView dv) {
d152 1
a152 1
	private void fireDrawingViewSelectedEvent(final DrawingView dv) {
@


1.10
log
@prepare for 5.4 release: various bug fixes
@
text
@d225 6
a230 2
		frame.addInternalFrameListener(internalFrameListener);//should be done before added to desktop
		Component retval = super.add(frame);
@


1.9
log
@Clean up head to be what it was before i mistakenly committed my changes to it.
My changes should have been committed to a branch, and let mrfloppy merge to the trunk.
This will happen from now on.
@
text
@d33 1
a33 1
 * @@author  C.L.Gilbert <dnoyeb@@sourceforge.net>
d46 1
a46 1
	protected DrawingView selectedView;
@


1.8
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d14 1
a14 1
import CH.ifa.draw.framework.*;
d39 1
a40 26
    private DrawingChangeListener dcl = new DrawingChangeListener() {
        /**  Sent when an area is invalid
         *
         */
        public void drawingInvalidated(DrawingChangeEvent e) {
        }    
        /**  Sent when the drawing wants to be refreshed
         *
         */
        public void drawingRequestUpdate(DrawingChangeEvent e) {
        }
        /**
         *  Change all frames that contain this drawing.
         */
        public void drawingTitleChanged(DrawingChangeEvent e) {
            Drawing dwg = e.getDrawing();
            JInternalFrame[] jifs = getAllFrames();
            
            for (int x=0; x<jifs.length; x++) {
                if (dwg == Helper.getDrawingView(jifs[x]).drawing()) {
                    jifs[x].setTitle(dwg.getTitle());
                }
            }            
        }
    };
    
d46 1
a46 1
	private DrawingView selectedView;
d48 2
a49 1
	public MDIDesktopPane() {
a53 12
        addDesktopListener( new DesktopListener() {
            public void drawingViewAdded(DesktopEvent dpe){
                DrawingView dv = dpe.getDrawingView();
                dv.drawing().addDrawingChangeListener(dcl);                
            }
            public void drawingViewRemoved(DesktopEvent dpe){
                DrawingView dv = dpe.getDrawingView();
                dv.drawing().removeDrawingChangeListener(dcl);
            }
            public void drawingViewSelected(DrawingView oldView, DesktopEvent dpe){
            }
        });
d78 1
a78 1
                 *
d83 4
d114 1
d117 2
a118 6
		public void internalFrameDeactivated(InternalFrameEvent e) {
            int x = getComponentCount();
			if (getComponentCount() == 1){ //could be a component without a DrawingView.  should use helper here.
				setActiveDrawingView(null); //mrfloppy, investigate using NullDrawingView here please.( i will assist)
			}                
		}
d152 1
a152 1
	private void fireDrawingViewSelectedEvent(final DrawingView oldView, final DrawingView newView) {
d159 1
a159 1
					dpe = new DesktopEvent(MDIDesktopPane.this, newView);
d162 1
a162 1
				dpl.drawingViewSelected(oldView,dpe);
d178 10
a187 1
		JInternalFrame internalFrame = new JInternalFrame(dv.drawing().getTitle(), true, true, true, true);
d198 3
a200 7
            DrawingView oldSelectedView = selectedView;
            selectedView = newSelectedView;
            fireDrawingViewSelectedEvent(oldSelectedView, newSelectedView);
	}
    /**
     *  @@deprecated desktop will use drawing name change listener
     */
a552 1
}
d554 3
d558 4
@


1.7
log
@bug 541524, 546628,547188
Improved Desktop functionality

This is an extra commit because NetBeans left off my comments
@
text
@d14 1
a14 1
import CH.ifa.draw.framework.DrawingView;
a38 1
	private DrawApplication myDrawApplication;
d40 26
d73 1
a73 2
	public MDIDesktopPane(DrawApplication newDrawApplication) {
		setDrawApplication(newDrawApplication);
d78 12
d149 2
a150 1
			if (getComponentCount() == 0){ //could be a component without a DrawingView.  should use helper here.
d213 1
a213 10

		String applicationTitle;
		if (dv.drawing().getTitle() == null) {
			applicationTitle = getDrawApplication().getApplicationName() + " - " + getDrawApplication().getDefaultDrawingTitle();
		}
		else {
			applicationTitle = getDrawApplication().getApplicationName() + " - " + dv.drawing().getTitle();
		}
		JInternalFrame internalFrame = new JInternalFrame(applicationTitle, true, true, true, true);
		internalFrame.setName(applicationTitle);
d228 3
a230 1

d583 1
a584 3
	private void setDrawApplication(DrawApplication newDrawApplication) {
		myDrawApplication = newDrawApplication;
	}
a585 4
	protected DrawApplication getDrawApplication() {
		return myDrawApplication;
	}
}
@


1.6
log
@
Changes for better Desktop handling.
@
text
@@


1.5
log
@bug fix 597631
@
text
@d46 1
a46 1
	protected DrawingView selectedView;
d78 1
a78 1
		 * if this is the last view set it to null
a82 4
			if (getComponentCount() == 0){
				setActiveDrawingView(null);
				fireDrawingViewSelectedEvent(selectedView);
			}
a109 1
			fireDrawingViewSelectedEvent(selectedView);
d112 5
a116 2
		//public void internalFrameDeactivated(InternalFrameEvent e) {
		//}
d150 1
a150 1
	private void fireDrawingViewSelectedEvent(final DrawingView dv) {
d157 1
a157 1
					dpe = new DesktopEvent(MDIDesktopPane.this, dv);
d160 1
a160 1
				dpl.drawingViewSelected(dpe);
d196 3
a198 1
		selectedView = newSelectedView;
@


1.5.4.1
log
@Changes for better Desktop handling.
DrawingView Always has a Drawing.
bug 541524, 546628,547188
@
text
@d46 1
a46 1
	private DrawingView selectedView;
d78 1
a78 1
                 *
d83 4
d114 1
d117 2
a118 5
		public void internalFrameDeactivated(InternalFrameEvent e) {
			if (getComponentCount() == 0){ //could be a component without a DrawingView.  should use helper here.
				setActiveDrawingView(null); //mrfloppy, investigate using NullDrawingView here please.( i will assist)
			}                
		}
d152 1
a152 1
	private void fireDrawingViewSelectedEvent(final DrawingView oldView, final DrawingView newView) {
d159 1
a159 1
					dpe = new DesktopEvent(MDIDesktopPane.this, newView);
d162 1
a162 1
				dpl.drawingViewSelected(oldView,dpe);
d198 1
a198 3
            DrawingView oldSelectedView = selectedView;
            selectedView = newSelectedView;
            fireDrawingViewSelectedEvent(oldSelectedView, newSelectedView);
@


1.5.4.2
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d14 1
a14 1
import CH.ifa.draw.framework.*;
d39 1
a40 26
    private DrawingChangeListener dcl = new DrawingChangeListener() {
        /**  Sent when an area is invalid
         *
         */
        public void drawingInvalidated(DrawingChangeEvent e) {
        }    
        /**  Sent when the drawing wants to be refreshed
         *
         */
        public void drawingRequestUpdate(DrawingChangeEvent e) {
        }
        /**
         *  Change all frames that contain this drawing.
         */
        public void drawingTitleChanged(DrawingChangeEvent e) {
            Drawing dwg = e.getDrawing();
            JInternalFrame[] jifs = getAllFrames();
            
            for (int x=0; x<jifs.length; x++) {
                if (dwg == Helper.getDrawingView(jifs[x]).drawing()) {
                    jifs[x].setTitle(dwg.getTitle());
                }
            }            
        }
    };
    
d48 2
a49 1
	public MDIDesktopPane() {
a53 12
        addDesktopListener( new DesktopListener() {
            public void drawingViewAdded(DesktopEvent dpe){
                DrawingView dv = dpe.getDrawingView();
                dv.drawing().addDrawingChangeListener(dcl);                
            }
            public void drawingViewRemoved(DesktopEvent dpe){
                DrawingView dv = dpe.getDrawingView();
                dv.drawing().removeDrawingChangeListener(dcl);
            }
            public void drawingViewSelected(DrawingView oldView, DesktopEvent dpe){
            }
        });
d113 1
a113 2
            int x = getComponentCount();
			if (getComponentCount() == 1){ //could be a component without a DrawingView.  should use helper here.
d176 10
a185 1
		JInternalFrame internalFrame = new JInternalFrame(dv.drawing().getTitle(), true, true, true, true);
d200 1
a200 3
    /**
     *  @@deprecated desktop will use drawing name change listener
     */
a552 1
}
d554 3
d558 4
@


1.5.4.3
log
@1. Added getDesktop to the DrawingEditor.  added null returns to all Classes that dont fully support
   the Desktop architecture yet, like the applets.

2. Added a figureSelection listener to the DrawingEditor so one can register with the DrawingEditor to
   hear figure selection events.  You can still register with the individual DrawingViews if you wish.
   The DrawingEditor will guarantee that it only fires this event on the active view, so it saves a listener
   from having to register and unregister with views to hear this event each time the activeView changes.
   All Commands were doing this register/unregister dance.

3. AbstractCommand now registers for figureSelectionEvents with the drawingEditor as opposed to the
   DrawingView.

4. Went back to viewCreated and viewDestroying naming.  flip flopping.  Its actually more accurate.  the
   real issue is that 2 events are missing, viewDestroyed and viewCreating.  dont need them yet, but
   they may materialize in the future.

5. Went back to Tool CompositeTool being enabled even when no figure is selected.

6. FigureSelectionListener now extends java.util.EventListener now because I am too lazy to write
   an event handler just yet.

7. implemented new findFigureInside() fix.  needs testing.

8. standardDrawingView selectionZordered now returns figures in the proper order(not reversed).
@
text
@d33 1
a33 1
 * @@author C.L.Gilbert <dnoyeb@@users.sourceforge.net>
d40 4
a43 1
    private final DrawingChangeListener dcl = new DrawingChangeListener() {
d46 3
d52 1
a52 2
         * Update the title of the JInternalFrame containing the changed
		 * drawing.
@


1.5.4.4
log
@Using List over ArrayList and Map over HashMap/WeakMap etc.
@
text
@d304 1
a304 1
		java.util.List al = CH.ifa.draw.util.CollectionsFactory.current().createList(comps.length);
@


1.4
log
@after variou merges... (before 5.4 release)
@
text
@d62 1
a62 1
	    public void internalFrameOpened(InternalFrameEvent e){
d72 1
a72 1
		//public void internalFrameClosing(InternalFrameEvent e){
d81 1
a81 1
		public void internalFrameClosed(InternalFrameEvent e){
d84 1
a84 1
				selectedView = null;
d94 1
a94 1
		//public void internalFrameIconified(InternalFrameEvent e){
d101 1
a101 1
		//public void internalFrameDeiconified(InternalFrameEvent e){
d111 1
a111 1
		public void internalFrameActivated(InternalFrameEvent e){
d113 1
a113 1
			selectedView = dv;
d117 1
a117 1
		//public void internalFrameDeactivated(InternalFrameEvent e){
d126 1
a126 1
		for (int i = listeners.length-2; i>=0 ; i-=2)	{
d141 1
a141 1
		for (int i = listeners.length-2; i>=0 ; i-=2)	{
d156 1
a156 1
		for (int i = listeners.length-2; i>=0 ; i-=2)	{
d166 1
d193 1
a193 1
	public DrawingView getActiveDrawingView(){
d197 8
d290 1
a290 1

d293 1
a293 1
		for (int x=0;x<comps.length;x++) {
d296 1
a296 1
				JInternalFrame frame = (JInternalFrame) comps[x];
d307 1
a307 1

d335 1
a335 1
				((JInternalFrame)allFrames[i]).setMaximum(false);
d604 1
a604 1
		if (scrollPane == null) {
d607 3
a609 1
		else return getScrollPane().getBorder().getBorderInsets(scrollPane);
@


1.3
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@d14 3
d18 3
a21 1
import java.awt.event.*;
d25 1
a25 1
 * An extension of WDesktopPane that supports often used MDI functionality. This
d28 3
d33 1
d36 1
a36 1
public class MDIDesktopPane extends JDesktopPane {
d39 8
d48 2
a49 1
	public MDIDesktopPane() {
d53 1
d56 110
d171 40
a210 1
	public Component add(JInternalFrame frame) {
d212 1
a212 1
		Point p;
d216 1
d218 1
a247 1
		return retval;
d250 8
a257 2
	public void remove(Component c) {
		super.remove(c);
d261 46
d313 1
a313 1
		JInternalFrame allFrames[] = getAllFrames();
d351 1
a351 1
		java.awt.Component allFrames[] = getAllFrames();
d378 1
a378 1
		java.awt.Component allFrames[] = getAllFrames();
d409 1
a409 1
		java.awt.Component allFrames[] = getAllFrames();
d417 2
a418 5
		int horFrames;
		int vertFrames;

		vertFrames = (int)Math.floor(Math.sqrt(allFrames.length));
		horFrames = (int)Math.ceil(Math.sqrt(allFrames.length));
d469 1
a469 1
		java.awt.Component allFrames[] = getAllFrames();
d477 2
a478 5
		int horFrames;
		int vertFrames;

		vertFrames = (int)Math.ceil(Math.sqrt(allFrames.length));
		horFrames = (int)Math.floor(Math.sqrt(allFrames.length));
d507 1
a507 2
		for (; frameIdx < allFrames.length; frameIdx++)
		{
d526 1
a526 1
	public void setAllSize(Dimension d){
d537 1
a537 1
	public void setAllSize(int width, int height){
d544 8
d561 2
a562 2
	public MDIDesktopManager(MDIDesktopPane desktop) {
		this.desktop = desktop;
a576 2
		int x = 0;
		int y = 0;
@


1.2
log
@merge dnd (before 5.3)
@
text
@d94 5
d100 1
d120 4
a123 1
	 * Tile all internal frames
d126 4
d131 6
d138 1
a139 1

d151 152
@


1.1
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d28 2
a29 2
    private static int FRAME_OFFSET=20;
    private MDIDesktopManager manager;
d31 10
a40 10
    public MDIDesktopPane() {
        manager=new MDIDesktopManager(this);
        setDesktopManager(manager);
        setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);
    }

/*    public void setBounds(int x, int y, int w, int h) {
        super.setBounds(x,y,w,h);
        checkDesktopSize();
    }
d42 56
a97 56
    public Component add(JInternalFrame frame) {
        JInternalFrame[] array = getAllFrames();
        Point p;
        int w;
        int h;

        Component retval = super.add(frame);
        checkDesktopSize();
        if (array.length > 0) {
            p = array[0].getLocation();
            p.x = p.x + FRAME_OFFSET;
            p.y = p.y + FRAME_OFFSET;
        }
        else {
            p = new Point(0, 0);
        }
        frame.setLocation(p.x, p.y);
        if (frame.isResizable()) {
            w = getWidth() - (getWidth() / 3);
            h = getHeight() - (getHeight() / 3);
            if (w < frame.getMinimumSize().getWidth()) {
            	w = (int)frame.getMinimumSize().getWidth();
            }
            if (h < frame.getMinimumSize().getHeight()) {
            	h = (int)frame.getMinimumSize().getHeight();
            }
            frame.setSize(w, h);
        }
        moveToFront(frame);
        frame.setVisible(true);
        try {
            frame.setSelected(true);
        }
        catch (PropertyVetoException e) {
            frame.toBack();
        }
        return retval;
    }

    public void remove(Component c) {
        super.remove(c);
        checkDesktopSize();
    }

    /**
     * Cascade all internal frames
     */
    public void cascadeFrames() {
        int x = 0;
        int y = 0;
        JInternalFrame allFrames[] = getAllFrames();

        manager.setNormalSize();
        int frameHeight = (getBounds().height - 5) - allFrames.length * FRAME_OFFSET;
        int frameWidth = (getBounds().width - 5) - allFrames.length * FRAME_OFFSET;
        for (int i = allFrames.length - 1; i >= 0; i--) {
d99 1
a99 1
            	((JInternalFrame)allFrames[i]).setMaximum(false);
d105 15
a119 15
            allFrames[i].setBounds(x, y, frameWidth, frameHeight);
            x = x + FRAME_OFFSET;
            y = y + FRAME_OFFSET;
        }

        checkDesktopSize();
    }

    /**
     * Tile all internal frames
     */
    public void tileFrames() {
        java.awt.Component allFrames[] = getAllFrames();
        manager.setNormalSize();
        int frameHeight = getBounds().height/allFrames.length;
d121 2
a122 2
        int y = 0;
        for (int i = 0; i < allFrames.length; i++) {
d124 1
a124 1
            	((JInternalFrame)allFrames[i]).setMaximum(false);
d130 29
a158 29
            allFrames[i].setBounds(0, y, getBounds().width,frameHeight);
            y = y + frameHeight;
        }

        checkDesktopSize();
    }

    /**
     * Sets all component size properties ( maximum, minimum, preferred)
     * to the given dimension.
     */
    public void setAllSize(Dimension d){
        setMinimumSize(d);
        setMaximumSize(d);
        setPreferredSize(d);
        setBounds(0, 0, d.width, d.height);
    }

    /**
     * Sets all component size properties ( maximum, minimum, preferred)
     * to the given width and height.
     */
    public void setAllSize(int width, int height){
        setAllSize(new Dimension(width,height));
    }

    private void checkDesktopSize() {
        if (getParent()!=null&&isVisible()) manager.resizeDesktop();
    }
d166 1
a166 1
    private MDIDesktopPane desktop;
d168 84
a251 84
    public MDIDesktopManager(MDIDesktopPane desktop) {
        this.desktop = desktop;
    }

    public void endResizingFrame(JComponent f) {
        super.endResizingFrame(f);
        resizeDesktop();
    }

    public void endDraggingFrame(JComponent f) {
        super.endDraggingFrame(f);
        resizeDesktop();
    }

    public void setNormalSize() {
        JScrollPane scrollPane = getScrollPane();
        int x = 0;
        int y = 0;
        Insets scrollInsets = getScrollPaneInsets();

        if (scrollPane != null) {
            Dimension d = scrollPane.getVisibleRect().getSize();
            if (scrollPane.getBorder() != null) {
               d.setSize(d.getWidth() - scrollInsets.left - scrollInsets.right,
                         d.getHeight() - scrollInsets.top - scrollInsets.bottom);
            }

            d.setSize(d.getWidth() - 20, d.getHeight() - 20);
            desktop.setAllSize(d);
            scrollPane.invalidate();
            scrollPane.validate();
        }
    }

    private Insets getScrollPaneInsets() {
        JScrollPane scrollPane = getScrollPane();
        if (scrollPane == null) {
        	return new Insets(0, 0, 0, 0);
        }
        else return getScrollPane().getBorder().getBorderInsets(scrollPane);
    }

    public JScrollPane getScrollPane() {
        if (desktop.getParent() instanceof JViewport) {
            JViewport viewPort = (JViewport)desktop.getParent();
            if (viewPort.getParent() instanceof JScrollPane)
                return (JScrollPane)viewPort.getParent();
        }
        return null;
    }

    protected void resizeDesktop() {
        int x = 0;
        int y = 0;
        JScrollPane scrollPane = getScrollPane();
        Insets scrollInsets = getScrollPaneInsets();

        if (scrollPane != null) {
            JInternalFrame allFrames[] = desktop.getAllFrames();
            for (int i = 0; i < allFrames.length; i++) {
                if (allFrames[i].getX() + allFrames[i].getWidth() > x) {
                    x = allFrames[i].getX() + allFrames[i].getWidth();
                }
                if (allFrames[i].getY() + allFrames[i].getHeight() > y) {
                    y = allFrames[i].getY() + allFrames[i].getHeight();
                }
            }
            Dimension d=scrollPane.getVisibleRect().getSize();
            if (scrollPane.getBorder() != null) {
               d.setSize(d.getWidth() - scrollInsets.left - scrollInsets.right,
                         d.getHeight() - scrollInsets.top - scrollInsets.bottom);
            }

            if (x <= d.getWidth()) {
            	x = ((int)d.getWidth()) - 20;
            }
            if (y <= d.getHeight()) {
            	y = ((int)d.getHeight()) - 20;
            }
            desktop.setAllSize(x,y);
            scrollPane.invalidate();
            scrollPane.validate();
        }
    }
@

