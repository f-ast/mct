head	1.6;
access;
symbols
	jhotdraw60b1-release:1.6
	package_rename:1.6
	directory_rename:1.5
	reorg_6x_split_initial:1.5
	MVC_PHASE1:1.4.0.2
	NEW_ATTRIBUTES:1.3.0.2
	DNOYEB1_ALPHA-2:1.1.4.7
	release_JHD54b1:1.1
	BUGFIX_670992:1.1.0.6
	DNOYEB1_ALPHA-1:1.1.4.4
	dnoyeb1:1.1.0.4
	repack:1.1.0.2
	Root_repack:1.1
	Before_FigureVisitor:1.1;
locks; strict;
comment	@# @;


1.6
date	2004.01.09.22.53.43;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.09.21.18.46;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.22.23.58.42;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.11.21.10.27;	author dnoyeb;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.04.05.15.12;	author ricardo_padilha;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.04.22.48.51;	author mrfloppy;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.10.04.54.38;	author dnoyeb;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.01.10.20.10.38;	author dnoyeb;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.01.16.15.58.50;	author dnoyeb;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.01.17.02.33.39;	author dnoyeb;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.01.29.04.19.52;	author dnoyeb;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2003.01.29.23.31.51;	author dnoyeb;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2003.01.30.19.27.26;	author dnoyeb;	state Exp;
branches;
next	1.1.4.8;

1.1.4.8
date	2003.02.02.16.51.24;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.6
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)DNDHelper.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.contrib.dnd;

import org.jhotdraw.framework.*;

import java.awt.Component;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.datatransfer.Transferable;
import java.awt.dnd.*;
import java.io.*;
import java.util.List;

/**
 * Changes made in hopes of eventually cleaning up the functionality and 
 * distributing it sensibly. 1/10/02
 * @@author  C.L.Gilbert <dnoyeb@@users.sourceforge.net>
 * @@version <$CURRENT_VERSION$>
 */
public abstract class DNDHelper {
	public static DataFlavor ASCIIFlavor = new DataFlavor("text/plain; charset=ascii", "ASCII text");
	private DragGestureRecognizer dgr;
	private DragGestureListener dragGestureListener;
	private DropTarget dropTarget;
	private DragSourceListener dragSourceListener;
	private DropTargetListener dropTargetListener;
	private boolean isDragSource = false;
	private boolean isDropTarget = false;

	public DNDHelper(boolean newIsDragSource, boolean newIsDropTarget){
		isDragSource = newIsDragSource;
		isDropTarget = newIsDropTarget;
	}
	/**
	 * Do not call this from the constructor.  its methods are overridable.
	 */
	public void initialize(DragGestureListener dgl) {
		if (isDragSource) {
			setDragGestureListener(dgl);
			setDragSourceListener(createDragSourceListener());
			setDragGestureRecognizer(createDragGestureRecognizer(getDragGestureListener()));
		}
		if (isDropTarget) {
			setDropTargetListener(createDropTargetListener());
			setDropTarget(createDropTarget());
		}
	}

	public void deinitialize(){
		if (getDragSourceListener() != null) {
			destroyDragGestreRecognizer();
			setDragSourceListener(null);
		}
		if (getDropTargetListener() != null) {
			setDropTarget(null);
			setDropTargetListener(null);
		}
	}
//	public void setDragSourceState(boolean state) {
//		if(state == false){
//			getDragGestureRecognizer().setSourceActions(DnDConstants.ACTION_NONE);
//		}
//		else {
//			getDragGestureRecognizer().setSourceActions(getDragSourceActions());
//		}
//	}
	protected abstract DrawingView view();
	protected abstract DrawingEditor editor();
	
	protected static Object processReceivedData(DataFlavor flavor, Transferable transferable) {
		Object receivedData = null;
		if (transferable == null) {
			return null;
		}

		try {
		    if (flavor.equals(DataFlavor.stringFlavor)) {
				receivedData = transferable.getTransferData(DataFlavor.stringFlavor);
			}
			else if (flavor.equals(DataFlavor.javaFileListFlavor)) {
				List aList = (List)transferable.getTransferData(DataFlavor.javaFileListFlavor);
				File fList [] = new File[aList.size()];
				aList.toArray(fList);
				receivedData = fList;
			}
			else if (flavor.equals(ASCIIFlavor)) {
				/* this may be too much work for locally received data */
				InputStream is = (InputStream)transferable.getTransferData(ASCIIFlavor);
				int length = is.available();
				byte[] bytes = new byte[length];
				int n = is.read(bytes);
				if (n > 0) {
					/* seems to be a 0 tacked on the end of Windows strings.  I
					 * havent checked other platforms.  This does not happen
					 * with windows socket io.  strange?
					 */
					//for (int i = 0; i < length; i++) {
					//    if (bytes[i] == 0) {
					//        length = i;
					//        break;
					//    }
					//}
					receivedData = new String(bytes, 0, n);
				}
			}
			else if (flavor.equals(DNDFiguresTransferable.DNDFiguresFlavor)) {
				receivedData = transferable.getTransferData(DNDFiguresTransferable.DNDFiguresFlavor);
			}
		}
		catch (java.io.IOException ioe) {
			System.err.println(ioe);
		}
		catch (UnsupportedFlavorException ufe) {
			System.err.println(ufe);
		}
		catch (ClassCastException cce) {
			System.err.println(cce);
		}

		return receivedData;
	}

	/**
	 * This must reflect the capabilities of the dragSsource, not your desired
	 * actions.  If you desire limited drag actions, then I suppose you need to
	 * make a new drag gesture recognizer?  I do know that if you put for instance
	 * ACTION_COPY but your device supports ACTION_COPY_OR_MOVE, then the receiving
	 * target may show the rejected icon, but will still be forced improperly to
	 * accept your MOVE since the system is not properly calling your MOVE a MOVE
	 * because you claimed incorrectly that you were incapable of MOVE.
	 */
	protected int getDragSourceActions() {
		return DnDConstants.ACTION_COPY_OR_MOVE;
	}

	protected int getDropTargetActions(){
		return DnDConstants.ACTION_COPY_OR_MOVE;
	}

	protected void setDragGestureListener(DragGestureListener dragGestureListener){
		this.dragGestureListener = dragGestureListener;
	}

	protected DragGestureListener getDragGestureListener(){
		return dragGestureListener;
	}

	protected void setDragGestureRecognizer(DragGestureRecognizer dragGestureRecognizer){
		dgr = dragGestureRecognizer;
	}

	protected DragGestureRecognizer getDragGestureRecognizer(){
		return dgr;
	}

	protected void setDropTarget(DropTarget newDropTarget){
		if ((newDropTarget == null) && (dropTarget != null)) {
			dropTarget.setComponent(null);
			dropTarget.removeDropTargetListener(getDropTargetListener());
		}
		dropTarget = newDropTarget;
	}

	protected DropTarget createDropTarget() {
		DropTarget dt = null;
		if (Component.class.isInstance(view())) {
			try {
				dt = new DropTarget((Component)view(), getDropTargetActions(), getDropTargetListener());
				//System.out.println(view().toString() + " Initialized to DND.");
			}
			catch (NullPointerException npe) {
				System.err.println("View Failed to initialize to DND.");
				System.err.println("Container likely did not have peer before the DropTarget was added");
				System.err.println(npe);
				npe.printStackTrace();
			}
		}
		return dt;
	}

	/**
	 * Used to create the gesture recognizer which in effect turns on draggability.
	 */
	protected DragGestureRecognizer createDragGestureRecognizer(DragGestureListener dgl) {
		DragGestureRecognizer aDgr = null;
		if (Component.class.isInstance(view())) {
			Component c = (Component)view();
			aDgr =	java.awt.dnd.DragSource.getDefaultDragSource().createDefaultDragGestureRecognizer(
					c,
					getDragSourceActions(),
					dgl);
			//System.out.println("DragGestureRecognizer created: " + view());
		}
		return aDgr;
	}

	/**
	 * Used to destroy the gesture listener which ineffect turns off dragability.
	 */
	protected void destroyDragGestreRecognizer() {
		//System.out.println("Destroying DGR " + view());
		if (getDragGestureRecognizer() != null) {
			getDragGestureRecognizer().removeDragGestureListener(getDragGestureListener());
	    	getDragGestureRecognizer().setComponent(null);
			setDragGestureRecognizer(null);
		}
	}

	protected void setDropTargetListener(DropTargetListener dropTargetListener){
		this.dropTargetListener = dropTargetListener;
	}

	protected DropTargetListener getDropTargetListener(){
		return dropTargetListener;
		}

	protected DropTargetListener createDropTargetListener(){
		return new JHDDropTargetListener(editor(),view());
	}

	public DragSourceListener getDragSourceListener(){
		return dragSourceListener;
	}

	protected void setDragSourceListener(DragSourceListener dragSourceListener){
		this.dragSourceListener = dragSourceListener;
	}

	protected DragSourceListener createDragSourceListener(){
		return new JHDDragSourceListener(editor(),view());
	}
}
	/**
	 * These transferable objects are used to package your data when you want
	 * to initiate a transfer.  They are not used when you only want to receive
	 * data.  Formating the data is the responsibility of the sender primarily.
	 * Untested.  Used for dragging ASCII text out of JHotDraw
	 */
/*	public class ASCIIText implements Transferable
	{
		String s = new String("This is ASCII text");
		byte[] bytes;

		public DataFlavor[] getTransferDataFlavors() {
			return new DataFlavor[] { ASCIIFlavor };
		}

		public boolean isDataFlavorSupported(DataFlavor dataFlavor) {
			return dataFlavor.equals(ASCIIFlavor);
		}

		public Object getTransferData(DataFlavor dataFlavor)
			throws UnsupportedFlavorException, IOException  {
			if (!isDataFlavorSupported(dataFlavor))
						throw new UnsupportedFlavorException(dataFlavor);

			bytes = new byte[s.length() + 1];
			for (int i = 0; i < s.length(); i++)
				bytes = s.getBytes();
			bytes[s.length()] = 0;
			return new ByteArrayInputStream(bytes);
		}
	}*/@


1.5
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@d12 1
a12 1
package CH.ifa.draw.contrib.dnd;
d14 1
a14 1
import CH.ifa.draw.framework.*;
@


1.4
log
@no message
@
text
@d40 3
a42 3
	public DNDHelper(boolean isDragSource, boolean isDropTarget){
		this.isDragSource = isDragSource;
		this.isDropTarget = isDropTarget;
d166 4
a169 4
	protected void setDropTarget(DropTarget dropTarget){
		if ((dropTarget == null) && (this.dropTarget != null)) {
			this.dropTarget.setComponent(null);
			this.dropTarget.removeDropTargetListener(getDropTargetListener());
d171 1
a171 1
		this.dropTarget = dropTarget;
@


1.3
log
@DND Update.  Hopefully this allows easier DND manipulation with the added
function seperation.
@
text
@d14 2
d18 2
d39 1
a39 2
	
	
d48 3
a50 3
		if(isDragSource) {
			setDragGestureListener( dgl );
			setDragSourceListener( createDragSourceListener() );
d53 2
a54 2
		if(isDropTarget) {
			setDropTargetListener( createDropTargetListener() );
d58 1
d60 1
a60 1
		if(getDragSourceListener() != null){
d62 1
a62 1
			setDragSourceListener( null );
d64 3
a66 3
		if(getDropTargetListener() != null){
			setDropTarget( null );
			setDropTargetListener( null );
d77 2
a78 3
	protected abstract CH.ifa.draw.framework.DrawingView view();
	protected abstract CH.ifa.draw.framework.DrawingEditor editor();
	
d80 2
a81 2
	
	protected static Object ProcessReceivedData(DataFlavor flavor, java.awt.datatransfer.Transferable transferable) {
d85 1
d88 1
a88 2
				String str = (String) transferable.getTransferData(DataFlavor.stringFlavor);
				return str;
d94 1
a94 1
				return fList;
a96 1
				String txt = null;
d113 1
a113 1
					txt = new String(bytes, 0, n);
a114 1
				return txt;
d117 1
a117 5
				DNDFigures ff = (DNDFigures) transferable.getTransferData(DNDFiguresTransferable.DNDFiguresFlavor);
				return ff;
			}
			else {
				return null;
a121 1
			return null;
d123 1
a123 1
		catch (java.awt.datatransfer.UnsupportedFlavorException ufe) {
a124 1
			return null;
a127 1
			return null;
d129 2
d132 1
d145 1
d149 1
d153 1
d157 1
d161 1
d165 1
d167 1
a167 1
		if((dropTarget == null) && (this.dropTarget != null)){
d169 1
a169 1
			this.dropTarget.removeDropTargetListener( getDropTargetListener() );
d173 1
d176 1
a176 1
		if (view() instanceof Component) {
d181 1
a181 1
			catch (java.lang.NullPointerException npe) {
d196 1
a196 1
		if (view() instanceof Component) {
d208 1
a208 1
	 * Used to destroy the gesture listener which in effect turns off dragability.
a218 1
	
d222 1
d225 2
a226 1
	}
d230 1
d234 1
d238 1
@


1.2
log
@Removed unused import.
@
text
@d14 2
a16 3
import java.awt.*;
import CH.ifa.draw.framework.*;
import java.awt.datatransfer.*;
d18 1
a18 1
import javax.swing.JComponent;
d21 3
a23 1
 * @@author  C.L.Gilbert <dnoyeb@@sourceforge.net>
d26 1
a26 1
public abstract class DNDHelper implements DropTargetListener,DragSourceListener,DragGestureListener {
d28 51
a78 7
	protected DragGestureRecognizer dgr;
	protected DropTarget dt;
	protected Boolean autoscrollState;

	abstract protected DrawingView view();

	protected static Object ProcessReceivedData(DataFlavor flavor, Transferable transferable) {
d88 1
a88 1
				java.util.List aList = (java.util.List)transferable.getTransferData(DataFlavor.javaFileListFlavor);
d127 1
a127 1
		catch (UnsupportedFlavorException ufe) {
d136 37
a172 23

	public boolean setDropTargetActive(boolean state) {
		if (state == true) {
		    return createDropTarget();
		}
		else {
			destroyDropTarget();
			return false;
		}
	}

	public boolean setDragSourceActive(boolean state) {
		if (state == true) {
			return createDragGestureRecognizer();
		}
		else {
			destroyDragGestreRecognizer();
			return false;
		}
	}

	protected boolean createDropTarget() {
		if (Component.class.isInstance(view())) {
d174 2
a175 3
				dt = new DropTarget((Component)view(), DnDConstants.ACTION_COPY_OR_MOVE, this);
				System.out.println( "" + view() + " Initialized to DND.");
				return true;
d184 1
a184 8
		return false;
	}
	protected void destroyDropTarget() {
		if (dt!= null) {
			dt.setComponent(null);
			dt.removeDropTargetListener(this);
			dt = null;
		}
a186 1

d190 3
a192 2
	protected boolean createDragGestureRecognizer() {
		if (Component.class.isInstance(view())) {
d194 1
a194 1
			dgr =	DragSource.getDefaultDragSource().createDefaultDragGestureRecognizer(
d196 3
a198 4
					DnDConstants.ACTION_COPY_OR_MOVE,
					this);
			//System.out.println("DragGestureRecognizer created: " + dgl);
			return true;
d200 1
a200 2
		else
			return false;
d204 1
a204 1
	 * Used to destroy the gesture listener which ineffect turns off dragability.
d207 5
a211 5
		System.out.println("Destroying DGR");
		if (dgr != null) {
			dgr.removeDragGestureListener(this);
	    	dgr.setComponent(null);
			dgr = null;
d215 3
a217 76
	/*******************************************DragGestureListener*****************/

	/**
	 * This function is called when the drag action is detected.  If it agrees
	 * with the attempt to drag it calls startDrag(), if not it does nothing.
	 */
	public void dragGestureRecognized(DragGestureEvent dge) {
		Component c = dge.getComponent();
		//System.out.println("recognized for " + c);

		if (DrawingView.class.isInstance(c)) {
			boolean found = false;
			DrawingView dv = (DrawingView)c;
			/* Send the drawing view which inspired the action a mouseUp to clean
			up its current tool.  THis is because mouse up will otherwise never
			be send and the tool will be stuck with only mouse down which means
			it will likely stay activated.  solve later for not just make
			but report. */
			/* this is a list of cloned figures */
			FigureEnumeration selectedElements = dv.selection();

			if (selectedElements.hasNextFigure() == false) {
				return;
			}

			Point p = dge.getDragOrigin();
//				System.out.println("origin at " + p);
			while (selectedElements.hasNextFigure()) {
				Figure f = selectedElements.nextFigure();
				if (f.containsPoint(p.x, p.y)) {
/*              Rectangle r = figgy.displayBox();
					sx = r.width;
					sy = r.height;*/
					//System.out.println("figure is " + figgy);
					found = true;
					break;
				}
			}
			if (found == true) {
				DNDFigures dndff = new DNDFigures(dv.selection(), p);
				DNDFiguresTransferable trans = new DNDFiguresTransferable(dndff);

				/* SAVE FOR FUTURE DRAG IMAGE SUPPORT */
				/* drag image support that I need to test on some supporting platform.
				windows is not supporting this on NT so far. Ill test 98 and 2K next

				boolean support = dragSource.isDragImageSupported();
				java.awt.image.BufferedImage  bi = new BufferedImage(sx,sy,BufferedImage.TYPE_INT_RGB);
				Graphics2D g = bi.createGraphics();
				Iterator itr2 = selectedElements.iterator();
				while ( itr2.hasNext() ) {
					Figure fig = (Figure) itr2.next();
					fig = (Figure)fig.clone();
					Rectangle rold = fig.displayBox();
					fig.moveBy(-rold.x,-rold.y);
					fig.draw(g);
				}
				g.setBackground(Color.red);
				dge.getDragSource().startDrag(
								dge,
								DragSource.DefaultMoveDrop,
								bi,
								new Point(0,0),
								trans,
								this);
				*/
				if (JComponent.class.isInstance( c )) {
				    ((JComponent)c).setAutoscrolls(false);
				}
				dge.getDragSource().startDrag(
								dge,
								null,
								trans,
								this);
			}
		}
d219 2
a220 17
	/***************************************End DragGestureListener*****************/

	/*******************************************DropTargetListener*****************/
	private int     fLastX=0, fLastY=0;      // previous mouse position

	/**
	 * Called when a drag operation has encountered the DropTarget.
	 */
	public void dragEnter(DropTargetDragEvent dtde) {
		//System.out.println("DropTargetDragEvent-dragEnter");
		supportDropTargetDragEvent(dtde);
		if (fLastX == 0) {
			fLastX = dtde.getLocation().x;
		}
		if (fLastY == 0) {
			fLastY = dtde.getLocation().y;
		}
d222 2
a223 6

	/**
	 * The drag operation has departed the DropTarget without dropping.
	 */
	public void dragExit(DropTargetEvent dte) {
		//System.out.println("DropTargetEvent-dragExit");
d225 2
a226 164

	/**
	 * Called when a drag operation is ongoing on the DropTarget.
	 */
	 public void dragOver(DropTargetDragEvent dtde) {
		//System.out.println("DropTargetDragEvent-dragOver");
		if (supportDropTargetDragEvent(dtde)==true) {
			int x=dtde.getLocation().x;
			int y=dtde.getLocation().y;
			if ((Math.abs(x - fLastX) > 0) || (Math.abs(y - fLastY) > 0) ) {
				//FigureEnumeration fe = view().selectionElements();
				//while (fe.hasNextFigure()) {
				//	fe.nextFigure().moveBy(x - fLastX, y - fLastY);
				//	System.out.println("moving Figures " + view());
				//}
				//view().checkDamage();
				fLastX = x;
				fLastY = y;
			}
		}
	 }

	/**
	 * The drag operation has terminated with a drop on this DropTarget.
	 */
	public void drop(DropTargetDropEvent dtde) {
		System.out.println("DropTargetDropEvent-drop");

		if (dtde.isDataFlavorSupported(DNDFiguresTransferable.DNDFiguresFlavor) == true) {
			System.out.println("DNDFiguresFlavor");
			if ((dtde.getDropAction() & DnDConstants.ACTION_COPY_OR_MOVE) != 0 ) {
				System.out.println("copy or move");
				if (dtde.isLocalTransfer() == false) {
					System.err.println("Intra-JVM Transfers not implemented for figures yet.");
					return;
				}
				dtde.acceptDrop(dtde.getDropAction());
				try { /* protection from a malicious dropped object */
					DNDFigures ff = (DNDFigures)ProcessReceivedData(DNDFiguresTransferable.DNDFiguresFlavor, dtde.getTransferable());
					FigureEnumeration fe = ff.getFigures();
					Point theO = ff.getOrigin();
					view().clearSelection();
					Point newP = dtde.getLocation();
					/** origin is where the figure thinks it is now
					  * newP is where the mouse is now.
					  * we move the figure to where the mouse is with this equation
					  */
					int dx = newP.x - theO.x;  /* distance the mouse has moved */
					int dy = newP.y - theO.y;  /* distance the mouse has moved */
					//System.out.println("mouse at " + newP);
					while (fe.hasNextFigure()) {
						Figure f = fe.nextFigure();
						//System.out.println("figure location = " + f.displayBox());

						//    f.moveBy(newP.x - fLastX , newP.y - fLastY);

						f.moveBy(dx , dy);
						//System.out.println("figure new location = " + f.displayBox());
						view().add(f);
						if (dtde.getDropAction() == DnDConstants.ACTION_MOVE)
							view().addToSelection(f);
						System.out.println("added to view");
					}
					view().checkDamage();
					dtde.getDropTargetContext().dropComplete(true);
				}
				catch (NullPointerException npe) {
					npe.printStackTrace();
					dtde.getDropTargetContext().dropComplete(false);
				}
			}
			else {
				dtde.rejectDrop();
			}
		}
		else if (dtde.isDataFlavorSupported(DataFlavor.stringFlavor)) {
			//System.out.println("String flavor dropped.");
			dtde.acceptDrop(dtde.getDropAction());
			Object o = ProcessReceivedData(DataFlavor.stringFlavor, dtde.getTransferable());
			if (o != null) {
				//System.out.println("Received string flavored data.");
				dtde.getDropTargetContext().dropComplete(true);
			}
			else {
				dtde.getDropTargetContext().dropComplete(false);
			}
		}
		else if (dtde.isDataFlavorSupported(ASCIIFlavor) == true) {
			//System.out.println("ASCII Flavor dropped.");
			dtde.acceptDrop(DnDConstants.ACTION_COPY);
			Object o = ProcessReceivedData(ASCIIFlavor, dtde.getTransferable());
			if (o!= null) {
				//System.out.println("Received ASCII Flavored data.");
				dtde.getDropTargetContext().dropComplete(true);
				//System.out.println(o);
			}
			else {
				dtde.getDropTargetContext().dropComplete(false);
			}
		}
		else if (dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
			//System.out.println("Java File List Flavor dropped.");
			dtde.acceptDrop(DnDConstants.ACTION_COPY);
			java.io.File [] fList = (java.io.File[]) ProcessReceivedData(DataFlavor.javaFileListFlavor, dtde.getTransferable());
			if (fList != null) {
				//System.out.println("Got list of files.");
				for (int x=0; x< fList.length; x++ ) {
					System.out.println(fList[x].getAbsolutePath());
				}
				dtde.getDropTargetContext().dropComplete(true);
			}
			else {
				dtde.getDropTargetContext().dropComplete(false);
			}
		}
		fLastX = 0;
		fLastY = 0;
	}

	/**
	 * Called if the user has modified the current drop gesture.
	 */
	public void dropActionChanged(DropTargetDragEvent dtde) {
		//System.out.println("DropTargetDragEvent-dropActionChanged");
		supportDropTargetDragEvent(dtde);
	}

	/**
	 * Tests wether the Drag event is of a type that we support handling
	 * Check the DND interface and support the events it says it supports
	 * if not a dnd interface comp, then dont support! because we dont even
	 * really know what kind of view it is.
	 */
	protected boolean supportDropTargetDragEvent(DropTargetDragEvent dtde) {
		if (dtde.isDataFlavorSupported(DNDFiguresTransferable.DNDFiguresFlavor) == true) {
			if (dtde.getDropAction() == DnDConstants.ACTION_COPY) {
				dtde.acceptDrag(DnDConstants.ACTION_COPY);
				return true;
			}
			else if (dtde.getDropAction() == DnDConstants.ACTION_MOVE) {
				dtde.acceptDrag(DnDConstants.ACTION_MOVE);
				return true;
			}
			else {
				dtde.rejectDrag();
				return false;
			}
		}
		else if (dtde.isDataFlavorSupported(ASCIIFlavor) == true) {
			dtde.acceptDrag(dtde.getDropAction());
			return true;
		}
		else if (dtde.isDataFlavorSupported(DataFlavor.stringFlavor) == true) {
			dtde.acceptDrag(dtde.getDropAction());
			return true;
		}
		else if (dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor) == true) {
			dtde.acceptDrag(dtde.getDropAction());
			return true;
		}
		else {
			dtde.rejectDrag();
			return false;
		}
d228 2
a229 43
	/***************************************End DropTargetListener*****************/

	/************************************ Begin DragSourceListener*****************/

	/**
	 * This method is invoked to signify that the Drag and Drop operation is complete.
	 * This is the last method called in the process.
	 */
	public void dragDropEnd(DragSourceDropEvent dsde) {
		DrawingView view = (DrawingView) dsde.getDragSourceContext().getComponent();
		System.out.println("DragSourceDropEvent-dragDropEnd");
		if (dsde.getDropSuccess() == true) {
			if (dsde.getDropAction() == DnDConstants.ACTION_MOVE) {
//                System.out.println("DragSourceDropEvent-ACTION_MOVE");
				//get the flavor in order of ease of use here.
				DNDFigures df = (DNDFigures)ProcessReceivedData(DNDFiguresTransferable.DNDFiguresFlavor, dsde.getDragSourceContext().getTransferable());
				FigureEnumeration fe = df.getFigures();

				//how can fe be null?
				if (fe != null) {
					while (fe.hasNextFigure()) {
						//how can this work on cloned fe?
						Figure f = fe.nextFigure();
						view.remove(f);
						System.out.println("removing " + f);
					}
					view.clearSelection();
					view.checkDamage();
				}
			}
			else if (dsde.getDropAction() == DnDConstants.ACTION_COPY) {
//                System.out.println("DragSourceDropEvent-ACTION_COPY");
			}
		}

		if (autoscrollState != null) {
			Component c = dsde.getDragSourceContext().getComponent();
			if (JComponent.class.isInstance( c )) {
				JComponent jc = (JComponent)c;
				jc.setAutoscrolls(autoscrollState.booleanValue());
				autoscrollState= null;
			}
		}
d231 2
a232 31
	/**
	 * Called as the hotspot enters a platform dependent drop site.
	 */
	public void dragEnter(DragSourceDragEvent dsde) {
		if (autoscrollState == null) {
			Component c = dsde.getDragSourceContext().getComponent();
			if (JComponent.class.isInstance( c )) {
				JComponent jc = (JComponent)c;
				autoscrollState= new Boolean(jc.getAutoscrolls());
				jc.setAutoscrolls(false);
			}
		}

		//System.out.println("DragSourceDragEvent-dragEnter");
//		dsde.getDragSourceContext().
	}
	/**
	 * Called as the hotspot exits a platform dependent drop site.
	 */
	public void dragExit(DragSourceEvent dse) {
	}
	/**
	 * Called as the hotspot moves over a platform dependent drop site.
	 */
	public void dragOver(DragSourceDragEvent dsde) {
		//System.out.println("DragSourceDragEvent-dragOver");
	}
	/**
	 * Called when the user has modified the drop gesture.
	 */
	public void dropActionChanged(DragSourceDragEvent dsde) {
@


1.1
log
@after variou merges... (before 5.4 release)
@
text
@a15 1
import java.util.*;
@


1.1.4.1
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d23 1
a23 1
 * @@author  C.L.Gilbert <dnoyeb@@users.sourceforge.net>
@


1.1.4.2
log
@DND now 'almost' implements Undo/Redo.
It works but its 2 seperate actions, so it takes 2 actions to undo
and 2 actions to redo.  havent found out how to remedy this yet.
Since the Drag gesture may be different on different platforms one must
either implement a JHD drag gesture recognizer, which is not the correct approach.
Or one must make the tool sufficietly generic to handle and undo drags from all platforms.

shooting for the latter.  DND needs some work.  But its still working.
@
text
@a20 1
import CH.ifa.draw.standard.DeleteFromDrawingVisitor;
a21 1
import CH.ifa.draw.util.*;
a22 2
 * Changes made in hopes of eventually cleaning up the functionality and 
 * distributing it sensibly. 1/10/02
d26 1
a26 1
public abstract class DNDHelper implements DragGestureListener {
d28 4
a31 6
	private DragGestureRecognizer dgr;
	private DropTarget dt;
	private Boolean autoscrollState;
	private DragSourceListener dragSourceListener;
	private DropTargetListener dropTargetListener;
	
a32 6
	abstract protected DrawingEditor editor();

	public DNDHelper(){
		setDragSourceListener( createDragSourceListener() );
		setDropTargetListener( createDropTargetListener() );
	}
d116 2
a117 2
				dt = new DropTarget((Component)view(), DnDConstants.ACTION_COPY_OR_MOVE, getDropTargetListener());
				//System.out.println( "" + view() + " Initialized to DND.");
d132 1
a132 1
			dt.removeDropTargetListener( getDropTargetListener() );
d156 1
a156 1
	 * Used to destroy the gesture listener which in effect turns off dragability.
d159 1
a159 1
		//System.out.println("Destroying DGR");
d240 1
a240 1
								getDragSourceListener());
d246 2
a247 29
	
	
	
	
	
	
	
	
	private Undoable targetUndoable;
	/**
	 * Factory method for undo activity
	 */
	protected Undoable createTargetUndoActivity(DrawingView view) {
		return new AddUndoActivity( view );
	}
	protected void setTargetUndoActivity(Undoable undoable){
		targetUndoable = undoable;
	}
	protected Undoable getTargetUndoActivity(){
		return targetUndoable;
	}
	public static class AddUndoActivity extends UndoableAdapter {

		public AddUndoActivity(DrawingView newDrawingView) {
			super(newDrawingView);
			//System.out.println("AddUndoActivity created " + newDrawingView);			
			setUndoable(true);
			setRedoable(true);
		}
d249 8
a256 13
		public boolean undo() {
			if (!super.undo()) {
				return false;
			}
			//System.out.println("AddUndoActivity AddUndoActivity undo");
			DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor(getDrawingView().drawing());
			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
	    		Figure f = fe.nextFigure();
				f.visit(deleteVisitor);
			}
			getDrawingView().clearSelection();
			return true;
d258 2
a259 12

		public boolean redo() {
			// do not call execute directly as the selection might has changed
			if (!isRedoable()) {
				return false;
			}
			//System.out.println("AddUndoActivity redo");
			getDrawingView().clearSelection();
			setAffectedFigures(getDrawingView().insertFigures(
				getAffectedFigures(), 0, 0, false));

			return true;
d263 6
a268 3
	/*******************************************DropTargetListener*****************/
	
	
d270 17
a286 24

	private void setDropTargetListener(DropTargetListener dropTargetListener){
		this.dropTargetListener = dropTargetListener;
	}
	private DropTargetListener getDropTargetListener(){
		return dropTargetListener;
	}
	private DropTargetListener createDropTargetListener(){
		return new innerDropTargetListener();
	}

	private class innerDropTargetListener implements DropTargetListener {
		private int     fLastX=0, fLastY=0;      // previous mouse position
		/**
		 * Called when a drag operation has encountered the DropTarget.
		 */
		public void dragEnter(DropTargetDragEvent dtde) {
			//System.out.println("DropTargetDragEvent-dragEnter");
			supportDropTargetDragEvent(dtde);
			if (fLastX == 0) {
				fLastX = dtde.getLocation().x;
			}
			if (fLastY == 0) {
				fLastY = dtde.getLocation().y;
d289 7
d297 7
a303 24
		/**
		 * The drag operation has departed the DropTarget without dropping.
		 */
		public void dragExit(DropTargetEvent dte) {
			//System.out.println("DropTargetEvent-dragExit");
		}

		/**
		 * Called when a drag operation is ongoing on the DropTarget.
		 */
		 public void dragOver(DropTargetDragEvent dtde) {
			//System.out.println("DropTargetDragEvent-dragOver");
			if (supportDropTargetDragEvent(dtde)==true) {
				int x=dtde.getLocation().x;
				int y=dtde.getLocation().y;
				if ((Math.abs(x - fLastX) > 0) || (Math.abs(y - fLastY) > 0) ) {
					//FigureEnumeration fe = view().selectionElements();
					//while (fe.hasNextFigure()) {
					//	fe.nextFigure().moveBy(x - fLastX, y - fLastY);
					//	System.out.println("moving Figures " + view());
					//}
					//view().checkDamage();
					fLastX = x;
					fLastY = y;
d305 17
a321 2
			}
		 }
d323 1
a323 32
		/**
		 * The drag operation has terminated with a drop on this DropTarget.
		 * Be nice to somehow incorporate FigureTransferCommand here.
		 */
		public void drop(DropTargetDropEvent dtde) {
			//System.out.println("DropTargetDropEvent-drop");

			if (dtde.isDataFlavorSupported(DNDFiguresTransferable.DNDFiguresFlavor) == true) {
				//System.out.println("DNDFiguresFlavor");
				if ((dtde.getDropAction() & DnDConstants.ACTION_COPY_OR_MOVE) != 0 ) {
					//System.out.println("copy or move");
					if (dtde.isLocalTransfer() == false) {
						System.err.println("Intra-JVM Transfers not implemented for figures yet.");
						return;
					}
					dtde.acceptDrop(dtde.getDropAction());
					try { /* protection from a malicious dropped object */
						setTargetUndoActivity( createTargetUndoActivity( view() ) );
						DNDFigures ff = (DNDFigures)ProcessReceivedData(DNDFiguresTransferable.DNDFiguresFlavor, dtde.getTransferable());
						getTargetUndoActivity().setAffectedFigures( ff.getFigures() );
						Point theO = ff.getOrigin();
						view().clearSelection();
						Point newP = dtde.getLocation();
						/** origin is where the figure thinks it is now
						  * newP is where the mouse is now.
						  * we move the figure to where the mouse is with this equation
						  */
						int dx = newP.x - theO.x;  /* distance the mouse has moved */
						int dy = newP.y - theO.y;  /* distance the mouse has moved */
						//System.out.println("mouse at " + newP);
						FigureEnumeration fe = view().insertFigures( getTargetUndoActivity().getAffectedFigures() ,  dx, dy, false );
						getTargetUndoActivity().setAffectedFigures( fe );
d325 3
d329 2
a330 12
							view().addToSelectionAll( getTargetUndoActivity().getAffectedFigures() );

						view().checkDamage();
						editor().getUndoManager().pushUndo( getTargetUndoActivity() );
						editor().getUndoManager().clearRedos();
						// update menus
						editor().figureSelectionChanged( view() );
						dtde.getDropTargetContext().dropComplete(true);
					}
					catch (NullPointerException npe) {
						npe.printStackTrace();
						dtde.getDropTargetContext().dropComplete(false);
d332 1
a332 11
				}
				else {
					dtde.rejectDrop();
				}
			}
			else if (dtde.isDataFlavorSupported(DataFlavor.stringFlavor)) {
				//System.out.println("String flavor dropped.");
				dtde.acceptDrop(dtde.getDropAction());
				Object o = ProcessReceivedData(DataFlavor.stringFlavor, dtde.getTransferable());
				if (o != null) {
					//System.out.println("Received string flavored data.");
d335 2
a336 1
				else {
d340 37
a376 11
			else if (dtde.isDataFlavorSupported(ASCIIFlavor) == true) {
				//System.out.println("ASCII Flavor dropped.");
				dtde.acceptDrop(DnDConstants.ACTION_COPY);
				Object o = ProcessReceivedData(ASCIIFlavor, dtde.getTransferable());
				if (o!= null) {
					//System.out.println("Received ASCII Flavored data.");
					dtde.getDropTargetContext().dropComplete(true);
					//System.out.println(o);
				}
				else {
					dtde.getDropTargetContext().dropComplete(false);
d378 1
d380 2
a381 14
			else if (dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
				//System.out.println("Java File List Flavor dropped.");
				dtde.acceptDrop(DnDConstants.ACTION_COPY);
				java.io.File [] fList = (java.io.File[]) ProcessReceivedData(DataFlavor.javaFileListFlavor, dtde.getTransferable());
				if (fList != null) {
					//System.out.println("Got list of files.");
					for (int x=0; x< fList.length; x++ ) {
						System.out.println(fList[x].getAbsolutePath());
					}
					dtde.getDropTargetContext().dropComplete(true);
				}
				else {
					dtde.getDropTargetContext().dropComplete(false);
				}
a382 2
			fLastX = 0;
			fLastY = 0;
d384 3
d388 6
a393 7
		/**
		 * Called if the user has modified the current drop gesture.
		 */
		public void dropActionChanged(DropTargetDragEvent dtde) {
			//System.out.println("DropTargetDragEvent-dropActionChanged");
			supportDropTargetDragEvent(dtde);
		}
d395 1
d436 15
a450 44
	
	
	
	
	
	
	
	
	
	
	
	
	
	private Undoable sourceUndoable;
	/**
	 * Factory method for undo activity
	 */
	protected Undoable createSourceUndoActivity(DrawingView drawingView) {
		return new RemoveUndoActivity( drawingView );
	}
	protected void setSourceUndoActivity(Undoable undoable){
		sourceUndoable = undoable;
	}
	protected Undoable getSourceUndoActivity(){
		return sourceUndoable;
	}
	public static class RemoveUndoActivity extends UndoableAdapter {
		public RemoveUndoActivity(DrawingView view) {
			super( view );
			//System.out.println("RemoveUndoActivity created " + view);
			setUndoable(true);
			setRedoable(true);
		}

		public boolean undo() {
			if (super.undo() && getAffectedFigures().hasNextFigure()) {
				//System.out.println("RemoveUndoActivity undo");
				getDrawingView().clearSelection();
				setAffectedFigures( getDrawingView().insertFigures(
											getAffectedFigures(), 0, 0,false));
				return true;
			}
			return false;
		}
d452 2
a453 48
		public boolean redo() {
			// do not call execute directly as the selection might has changed
			if (isRedoable()) {
				//System.out.println("RemoveUndoActivity redo");
				DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor( getDrawingView().drawing());
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					fe.nextFigure().visit(deleteVisitor);
				}
				getDrawingView().clearSelection();
				return true;
			}
			return false;
		}
	}
	
	
	
	
	/************************************ Begin DragSourceListener*****************/
	private DragSourceListener getDragSourceListener(){
		return dragSourceListener;
	}
	private void setDragSourceListener(DragSourceListener dragSourceListener){
		this.dragSourceListener = dragSourceListener;
	}
	private DragSourceListener createDragSourceListener(){
		return new innerDragSourceListener();
	}
	private class innerDragSourceListener implements DragSourceListener {
		/**
		 * This method is invoked to signify that the Drag and Drop operation is complete.
		 * This is the last method called in the process.
		 */
		public void dragDropEnd(DragSourceDropEvent dsde) {
			DrawingView view = (DrawingView) dsde.getDragSourceContext().getComponent();
			//System.out.println("DragSourceDropEvent-dragDropEnd");
			if (dsde.getDropSuccess() == true) {
				if (dsde.getDropAction() == DnDConstants.ACTION_MOVE) {
	//                System.out.println("DragSourceDropEvent-ACTION_MOVE");
					//get the flavor in order of ease of use here.
					setSourceUndoActivity(  createSourceUndoActivity( view ) );
					DNDFigures df = (DNDFigures)ProcessReceivedData(DNDFiguresTransferable.DNDFiguresFlavor, dsde.getDragSourceContext().getTransferable());
					getSourceUndoActivity().setAffectedFigures( df.getFigures() );

					//all this visitation needs to be hidden in a view method.
					DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor(view.drawing());
					FigureEnumeration fe = getSourceUndoActivity().getAffectedFigures();
d455 4
a458 1
						fe.nextFigure().visit(deleteVisitor);
a461 8

					editor().getUndoManager().pushUndo( getSourceUndoActivity() );
					editor().getUndoManager().clearRedos();
					// update menus
					editor().figureSelectionChanged( view );
				}
				else if (dsde.getDropAction() == DnDConstants.ACTION_COPY) {
					//System.out.println("DragSourceDropEvent-ACTION_COPY not implemented?");
d464 4
d469 6
a474 7
			if (autoscrollState != null) {
				Component c = dsde.getDragSourceContext().getComponent();
				if (JComponent.class.isInstance( c )) {
					JComponent jc = (JComponent)c;
					jc.setAutoscrolls(autoscrollState.booleanValue());
					autoscrollState= null;
				}
d477 11
a487 11
		/**
		 * Called as the hotspot enters a platform dependent drop site.
		 */
		public void dragEnter(DragSourceDragEvent dsde) {
			if (autoscrollState == null) {
				Component c = dsde.getDragSourceContext().getComponent();
				if (JComponent.class.isInstance( c )) {
					JComponent jc = (JComponent)c;
					autoscrollState= new Boolean(jc.getAutoscrolls());
					jc.setAutoscrolls(false);
				}
d489 1
d491 18
a508 19
			//System.out.println("DragSourceDragEvent-dragEnter");
	//		dsde.getDragSourceContext().
		}
		/**
		 * Called as the hotspot exits a platform dependent drop site.
		 */
		public void dragExit(DragSourceEvent dse) {
		}
		/**
		 * Called as the hotspot moves over a platform dependent drop site.
		 */
		public void dragOver(DragSourceDragEvent dsde) {
			//System.out.println("DragSourceDragEvent-dragOver");
		}
		/**
		 * Called when the user has modified the drop gesture.
		 */
		public void dropActionChanged(DragSourceDragEvent dsde) {
		}
@


1.1.4.3
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d369 1
a369 1
					//view().drawing().update();
d412 1
a412 1
						view().drawing().update();
d617 1
a617 1
					view.drawing().update();//we made a change to the drawing, so update it.
@


1.1.4.4
log
@Fix: [ 622363 ] UndoableAdapter.release() is broken
Only deleting-type undoable actions release figures.
+ DND grabs figures from the visitor now. others need to do the same.
@
text
@a291 1
			//undo of add really shouldnt need visitor !?!dnoyeb!?!
a298 1
			setAffectedFigures( deleteVisitor.getDeletedFigures() );
a574 1
				setAffectedFigures( deleteVisitor.getDeletedFigures() );
a578 10
		/**
		 * Releases all resources related to an undoable activity
		 */
		public void release() {
			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				fe.nextFigure().release();
			}
			setAffectedFigures(CH.ifa.draw.standard.FigureEnumerator.getEmptyEnumeration());
		}		
@


1.1.4.5
log
@DND Improvements in OO and Efficiency
@
text
@d30 1
a30 1
public abstract class DNDHelper {
d33 2
a34 2
	private DragGestureListener dragGestureListener;
	private DropTarget dropTarget;
d38 3
d42 2
a44 36
	/**
	 * Do not call this from the constructor.  its methods are overridable.
	 */
	public void initialize(DragGestureListener dgl) {
		if(isDragSource()) {
			setDragGestureListener( dgl );
			setDragSourceListener( createDragSourceListener() );
			setDragGestureRecognizer(createDragGestureRecognizer(getDragGestureListener()));
		}
		if(isDropTarget()) {
			setDropTargetListener( createDropTargetListener() );
			setDropTarget(createDropTarget());
		}
	}
	public void deinitialize(){
		if(getDragSourceListener() != null){
			destroyDragGestreRecognizer();
			setDragSourceListener( null );
		}
		if(getDropTargetListener() != null){
			setDropTarget( null );
			setDropTargetListener( null );
		}
	}
	public void setDragSourceState(boolean state) {
		if(state == false){
			getDragGestureRecognizer().setSourceActions(DnDConstants.ACTION_NONE);
		}
		else {
			getDragGestureRecognizer().setSourceActions(getDragSourceActions());
		}
	}
	abstract protected DrawingView view();
	abstract protected DrawingEditor editor();
	abstract protected boolean isDragSource();
	abstract protected boolean isDropTarget();
a45 3
	
	
	
d104 9
a112 2
	protected int getDragSourceActions() {
		return DnDConstants.ACTION_COPY_OR_MOVE;
d114 8
a121 16
	protected void setDragGestureListener(DragGestureListener dragGestureListener){
		this.dragGestureListener = dragGestureListener;
	}
	protected DragGestureListener getDragGestureListener(){
		return dragGestureListener;
	}
	protected void setDragGestureRecognizer(DragGestureRecognizer dragGestureRecognizer){
		dgr = dragGestureRecognizer;
	}
	protected DragGestureRecognizer getDragGestureRecognizer(){
		return dgr;
	}
	protected void setDropTarget(DropTarget dropTarget){
		if((dropTarget == null) && (this.dropTarget != null)){
			this.dropTarget.setComponent(null);
			this.dropTarget.removeDropTargetListener( getDropTargetListener() );
a122 1
		this.dropTarget = dropTarget;
d124 3
a126 3
	protected DropTarget createDropTarget() {
		DropTarget dt = null;
		if (view() instanceof Component) {
d129 2
a130 1
				System.out.println(view().toString() + " Initialized to DND.");
d139 8
a146 1
		return dt;
d149 1
d153 2
a154 3
	protected DragGestureRecognizer createDragGestureRecognizer(DragGestureListener dgl) {
		DragGestureRecognizer aDgr = null;
		if (view() instanceof Component) {
d156 1
a156 1
			aDgr =	DragSource.getDefaultDragSource().createDefaultDragGestureRecognizer(
d158 4
a161 3
					getDragSourceActions(),
					dgl);
			System.out.println("DragGestureRecognizer created: " + view());
d163 2
a164 1
		return aDgr;
d171 83
a253 5
		System.out.println("Destroying DGR " + view());
		if (getDragGestureRecognizer() != null) {
			getDragGestureRecognizer().removeDragGestureListener(getDragGestureListener());
	    	getDragGestureRecognizer().setComponent(null);
			setDragGestureRecognizer(null);
d256 1
d259 66
a324 1
	protected void setDropTargetListener(DropTargetListener dropTargetListener){
d327 1
a327 1
	protected DropTargetListener getDropTargetListener(){
d330 2
a331 2
	protected DropTargetListener createDropTargetListener(){
		return new JHDDropTargetListener(editor(),view());
d333 266
a598 1
	public DragSourceListener getDragSourceListener(){
d601 1
a601 1
	protected void setDragSourceListener(DragSourceListener dragSourceListener){
d604 79
a682 2
	protected DragSourceListener createDragSourceListener(){
		return new JHDDragSourceListener(editor(),view());
@


1.1.4.6
log
@Dnd rework
@
text
@a36 2
	private boolean isDragSource = false;
	private boolean isDropTarget = false;
d38 1
a38 4
	
	public DNDHelper(boolean isDragSource, boolean isDropTarget){
		this.isDragSource = isDragSource;
		this.isDropTarget = isDropTarget;
d44 1
a44 1
		if(isDragSource) {
d49 1
a49 1
		if(isDropTarget) {
d74 3
@


1.1.4.7
log
@less verbosity
@
text
@a13 2
import java.awt.Component;
import java.awt.datatransfer.DataFlavor;
d15 4
d20 2
a21 1
import java.util.List;
d23 1
d77 2
a78 2
	protected abstract CH.ifa.draw.framework.DrawingView view();
	protected abstract CH.ifa.draw.framework.DrawingEditor editor();
d82 1
a82 1
	protected static Object ProcessReceivedData(DataFlavor flavor, java.awt.datatransfer.Transferable transferable) {
d92 1
a92 1
				List aList = (List)transferable.getTransferData(DataFlavor.javaFileListFlavor);
d131 1
a131 1
		catch (java.awt.datatransfer.UnsupportedFlavorException ufe) {
d167 1
a167 1
				//System.out.println(view().toString() + " Initialized to DND.");
d186 1
a186 1
			aDgr =	java.awt.dnd.DragSource.getDefaultDragSource().createDefaultDragGestureRecognizer(
d190 1
a190 1
			//System.out.println("DragGestureRecognizer created: " + view());
d199 1
a199 1
		//System.out.println("Destroying DGR " + view());
@


1.1.4.8
log
@OO improvements and a few bug fixes.
@
text
@a135 9
	/**
	 * This must reflect the capabilities of the dragSsource, not your desired
	 * actions.  If you desire limited drag actions, then I suppose you need to
	 * make a new drag gesture recognizer?  I do know that if you put for instance
	 * ACTION_COPY but your device supports ACTION_COPY_OR_MOVE, then the receiving
	 * target may show the rejected icon, but will still be forced improperly to
	 * accept your MOVE since the system is not properly calling your MOVE a MOVE
	 * because you claimed incorrectly that you were incapable of MOVE.
	 */
a138 3
	protected int getDropTargetActions(){
		return DnDConstants.ACTION_COPY_OR_MOVE;
	}
d162 1
a162 1
				dt = new DropTarget((Component)view(), getDropTargetActions(), getDropTargetListener());
@


