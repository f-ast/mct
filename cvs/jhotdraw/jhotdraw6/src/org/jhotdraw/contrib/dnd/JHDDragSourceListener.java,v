head	1.5;
access;
symbols
	jhotdraw60b1-release:1.5
	package_rename:1.5
	directory_rename:1.4
	reorg_6x_split_initial:1.4
	MVC_PHASE1:1.3.0.2
	NEW_ATTRIBUTES:1.2.0.2
	DNOYEB1_ALPHA-2:1.1.2.1
	dnoyeb1:1.1.0.2;
locks; strict;
comment	@# @;


1.5
date	2004.01.09.22.53.43;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.09.21.18.46;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.22.23.58.42;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.11.21.10.29;	author dnoyeb;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.29.04.19.52;	author dnoyeb;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.29.04.19.53;	author dnoyeb;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.02.02.16.51.24;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.5
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * JHDDragSource.java
 *
 * Created on January 28, 2003, 4:49 PM
 */

package org.jhotdraw.contrib.dnd;

import org.jhotdraw.framework.*;
import org.jhotdraw.standard.DeleteFromDrawingVisitor;
import org.jhotdraw.util.Undoable;
import java.awt.Component;
import java.awt.dnd.*;
import javax.swing.JComponent;

/**
 *
 * @@author  Administrator
 */
public class JHDDragSourceListener implements java.awt.dnd.DragSourceListener {
	private Undoable sourceUndoable;
	private Boolean autoscrollState;
	private DrawingEditor editor;
	
	/** Creates a new instance of JHDDragSource */
	public JHDDragSourceListener(DrawingEditor newEditor, DrawingView newView) {
		this.editor = newEditor;
	}
//	protected DrawingView view(){
//		return dv;
//	}
	protected DrawingEditor editor(){
		return editor;
	}
	/**
	 * This method is invoked to signify that the Drag and Drop operation is complete.
	 * This is the last method called in the process.
	 */
	public void dragDropEnd(java.awt.dnd.DragSourceDropEvent dsde) {
		DrawingView view = (DrawingView) dsde.getDragSourceContext().getComponent();
		log("DragSourceDropEvent-dragDropEnd");
		if (dsde.getDropSuccess() == true) {
			if (dsde.getDropAction() == DnDConstants.ACTION_MOVE) {
                log("DragSourceDropEvent-ACTION_MOVE");
				//get the flavor in order of ease of use here.
				setSourceUndoActivity(  createSourceUndoActivity( view ) );
				DNDFigures df = (DNDFigures)DNDHelper.processReceivedData(DNDFiguresTransferable.DNDFiguresFlavor, dsde.getDragSourceContext().getTransferable());
				getSourceUndoActivity().setAffectedFigures( df.getFigures() );

				//all this visitation needs to be hidden in a view method.
				DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor(view.drawing());
				FigureEnumeration fe = getSourceUndoActivity().getAffectedFigures();
				while (fe.hasNextFigure()) {
					fe.nextFigure().visit(deleteVisitor);
				}
				view.clearSelection();
				view.checkDamage();

				editor().getUndoManager().pushUndo( getSourceUndoActivity() );
				editor().getUndoManager().clearRedos();
				// update menus
				editor().figureSelectionChanged( view );
			}
			else if (dsde.getDropAction() == DnDConstants.ACTION_COPY) {
				log("DragSourceDropEvent-ACTION_COPY");
			}
		}

		if (autoscrollState != null) {
			Component c = dsde.getDragSourceContext().getComponent();
			if (JComponent.class.isInstance( c )) {
				JComponent jc = (JComponent)c;
				jc.setAutoscrolls(autoscrollState.booleanValue());
				autoscrollState= null;
			}
		}
	}
	/**
	 * Called as the hotspot enters a platform dependent drop site.
	 */
	public void dragEnter(DragSourceDragEvent dsde) {
		log("DragSourceDragEvent-dragEnter");
		if (autoscrollState == null) {
			Component c = dsde.getDragSourceContext().getComponent();
			if (JComponent.class.isInstance( c )) {
				JComponent jc = (JComponent)c;
				autoscrollState= new Boolean(jc.getAutoscrolls());
				jc.setAutoscrolls(false);//why turn it off???
			}
		}
	}
	/**
	 * Called as the hotspot exits a platform dependent drop site.
	 */
	public void dragExit(java.awt.dnd.DragSourceEvent dse) {
	}
	/**
	 * Called as the hotspot moves over a platform dependent drop site.
	 */
	public void dragOver(DragSourceDragEvent dsde) {
		//log("DragSourceDragEvent-dragOver");
	}
	/**
	 * Called when the user has modified the drop gesture.
	 */
	public void dropActionChanged(DragSourceDragEvent dsde) {
		log("DragSourceDragEvent-dropActionChanged");
	}
	
	
	
	
	
	
	
	
	
	
	
	/**
	 * Factory method for undo activity
	 */
	protected Undoable createSourceUndoActivity(DrawingView drawingView) {
		return new RemoveUndoActivity( drawingView );
	}
	protected void setSourceUndoActivity(Undoable undoable){
		sourceUndoable = undoable;
	}
	protected Undoable getSourceUndoActivity(){
		return sourceUndoable;
	}
	public static class RemoveUndoActivity extends org.jhotdraw.util.UndoableAdapter {
		private boolean undone = false;
		public RemoveUndoActivity(DrawingView view) {
			super( view );
			log("RemoveUndoActivity created " + view);
			setUndoable(true);
			setRedoable(true);
		}

		public boolean undo() {
			if (isUndoable()) {
				if(getAffectedFigures().hasNextFigure()) {
					log("RemoveUndoActivity undo");
					getDrawingView().clearSelection();
					setAffectedFigures( getDrawingView().insertFigures(getAffectedFigures(), 0, 0,false));
					undone = true;
					return true;
				}
			}
			return false;
		}

		public boolean redo() {
			// do not call execute directly as the selection might has changed
			if (isRedoable()) {
				log("RemoveUndoActivity redo");
				DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor( getDrawingView().drawing());
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					fe.nextFigure().visit(deleteVisitor); //orphans figures
				}
				getDrawingView().clearSelection();
				setAffectedFigures( deleteVisitor.getDeletedFigures() );
				undone = false;
				return true;
			}
			return false;
		}
		/**
		 * Since this is a delete activity, figures can only be released if the
		 * action has not been undone.
		 */
		public void release() {
			if(undone == false){//we have figures that used to be in the drawing, but were not adding back
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					Figure f = fe.nextFigure();
					getDrawingView().drawing().remove(f);
					f.release();
				}
			}
			setAffectedFigures(org.jhotdraw.standard.FigureEnumerator.getEmptyEnumeration());
		}		
	}
	
	
	
	
	
	
	
	private static void log(String message){
		//System.out.println("JHDDragSourceListener: " + message);
	}
	
	
	
	
	
	
	
}
@


1.4
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@d7 1
a7 1
package CH.ifa.draw.contrib.dnd;
d9 3
a11 3
import CH.ifa.draw.framework.*;
import CH.ifa.draw.standard.DeleteFromDrawingVisitor;
import CH.ifa.draw.util.Undoable;
d132 1
a132 1
	public static class RemoveUndoActivity extends CH.ifa.draw.util.UndoableAdapter {
d183 1
a183 1
			setAffectedFigures(CH.ifa.draw.standard.FigureEnumerator.getEmptyEnumeration());
@


1.3
log
@no message
@
text
@d26 2
a27 2
	public JHDDragSourceListener(DrawingEditor editor, DrawingView view) {
		this.editor = editor;
@


1.2
log
@DND Update.  Hopefully this allows easier DND manipulation with the added
function seperation.
@
text
@d47 1
a47 1
				DNDFigures df = (DNDFigures)DNDHelper.ProcessReceivedData(DNDFiguresTransferable.DNDFiguresFlavor, dsde.getDragSourceContext().getTransferable());
@


1.1
log
@file JHDDragSourceListener.java was initially added on branch dnoyeb1.
@
text
@d1 203
@


1.1.2.1
log
@DND Improvements in OO and Efficiency
@
text
@a0 198
/*
 * JHDDragSource.java
 *
 * Created on January 28, 2003, 4:49 PM
 */

package CH.ifa.draw.contrib.dnd;
import java.awt.dnd.*;
import java.awt.*;
import java.util.*;
import CH.ifa.draw.framework.*;
import java.awt.datatransfer.*;
import java.io.*;
import javax.swing.JComponent;
import CH.ifa.draw.standard.DeleteFromDrawingVisitor;

import CH.ifa.draw.util.*;
/**
 *
 * @@author  Administrator
 */
public class JHDDragSourceListener implements DragSourceListener {
	private Undoable sourceUndoable;
	private Boolean autoscrollState;
//	private DrawingView dv;
	private DrawingEditor editor;
	
	/** Creates a new instance of JHDDragSource */
	public JHDDragSourceListener(DrawingEditor editor, DrawingView view) {
		this.editor = editor;
	}
//	protected DrawingView view(){
//		return dv;
//	}
	protected DrawingEditor editor(){
		return editor;
	}
	/**
	 * This method is invoked to signify that the Drag and Drop operation is complete.
	 * This is the last method called in the process.
	 */
	public void dragDropEnd(DragSourceDropEvent dsde) {
		DrawingView view = (DrawingView) dsde.getDragSourceContext().getComponent();
		log("DragSourceDropEvent-dragDropEnd");
		if (dsde.getDropSuccess() == true) {
			if (dsde.getDropAction() == DnDConstants.ACTION_MOVE) {
                log("DragSourceDropEvent-ACTION_MOVE");
				//get the flavor in order of ease of use here.
				setSourceUndoActivity(  createSourceUndoActivity( view ) );
				DNDFigures df = (DNDFigures)DNDHelper.ProcessReceivedData(DNDFiguresTransferable.DNDFiguresFlavor, dsde.getDragSourceContext().getTransferable());
				getSourceUndoActivity().setAffectedFigures( df.getFigures() );

				//all this visitation needs to be hidden in a view method.
				DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor(view.drawing());
				FigureEnumeration fe = getSourceUndoActivity().getAffectedFigures();
				while (fe.hasNextFigure()) {
					fe.nextFigure().visit(deleteVisitor);
				}
				view.clearSelection();
				view.drawing().update();//we made a change to the drawing, so update it.

				editor().getUndoManager().pushUndo( getSourceUndoActivity() );
				editor().getUndoManager().clearRedos();
				// update menus
				editor().figureSelectionChanged( view );
			}
			else if (dsde.getDropAction() == DnDConstants.ACTION_COPY) {
				log("DragSourceDropEvent-ACTION_COPY not implemented?");
			}
		}

		if (autoscrollState != null) {
			Component c = dsde.getDragSourceContext().getComponent();
			if (JComponent.class.isInstance( c )) {
				JComponent jc = (JComponent)c;
				jc.setAutoscrolls(autoscrollState.booleanValue());
				autoscrollState= null;
			}
		}
	}
	/**
	 * Called as the hotspot enters a platform dependent drop site.
	 */
	public void dragEnter(DragSourceDragEvent dsde) {
		log("DragSourceDragEvent-dragEnter");
		if (autoscrollState == null) {
			Component c = dsde.getDragSourceContext().getComponent();
			if (JComponent.class.isInstance( c )) {
				JComponent jc = (JComponent)c;
				autoscrollState= new Boolean(jc.getAutoscrolls());
				jc.setAutoscrolls(false);
			}
		}

//		dsde.getDragSourceContext().
	}
	/**
	 * Called as the hotspot exits a platform dependent drop site.
	 */
	public void dragExit(DragSourceEvent dse) {
	}
	/**
	 * Called as the hotspot moves over a platform dependent drop site.
	 */
	public void dragOver(DragSourceDragEvent dsde) {
		log("DragSourceDragEvent-dragOver");
	}
	/**
	 * Called when the user has modified the drop gesture.
	 */
	public void dropActionChanged(DragSourceDragEvent dsde) {
	}
	
	
	
	
	
	
	
	
	
	
	
	/**
	 * Factory method for undo activity
	 */
	protected Undoable createSourceUndoActivity(DrawingView drawingView) {
		return new RemoveUndoActivity( drawingView );
	}
	protected void setSourceUndoActivity(Undoable undoable){
		sourceUndoable = undoable;
	}
	protected Undoable getSourceUndoActivity(){
		return sourceUndoable;
	}
	public static class RemoveUndoActivity extends UndoableAdapter {
		public RemoveUndoActivity(DrawingView view) {
			super( view );
			log("RemoveUndoActivity created " + view);
			setUndoable(true);
			setRedoable(true);
		}

		public boolean undo() {
			if (super.undo() && getAffectedFigures().hasNextFigure()) {
				log("RemoveUndoActivity undo");
				getDrawingView().clearSelection();
				setAffectedFigures( getDrawingView().insertFigures(getAffectedFigures(), 0, 0,false));
				return true;
			}
			return false;
		}

		public boolean redo() {
			// do not call execute directly as the selection might has changed
			if (isRedoable()) {
				log("RemoveUndoActivity redo");
				DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor( getDrawingView().drawing());
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					fe.nextFigure().visit(deleteVisitor);
				}
				getDrawingView().clearSelection();
				setAffectedFigures( deleteVisitor.getDeletedFigures() );
				return true;
			}
			return false;
		}
		/**
		 * Releases all resources related to an undoable activity
		 * @@todo investigate if this release is proper.
		 */
		public void release() {
			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				fe.nextFigure().release();
			}
			setAffectedFigures(CH.ifa.draw.standard.FigureEnumerator.getEmptyEnumeration());
		}		
	}
	
	
	
	
	
	
	
	private static void log(String message){
		//System.out.println("JHDDragSourceListener: " + message);
	}
	
	
	
	
	
	
	
}
@


1.1.2.2
log
@OO improvements and a few bug fixes.
@
text
@d8 3
a10 1

d12 3
a15 4
import CH.ifa.draw.util.Undoable;
import java.awt.Component;
import java.awt.dnd.*;
import javax.swing.JComponent;
d17 1
d22 1
a22 1
public class JHDDragSourceListener implements java.awt.dnd.DragSourceListener {
d25 1
d42 1
a42 1
	public void dragDropEnd(java.awt.dnd.DragSourceDropEvent dsde) {
d68 1
a68 1
				log("DragSourceDropEvent-ACTION_COPY");
d91 1
a91 1
				jc.setAutoscrolls(false);//why turn it off???
d94 2
d100 1
a100 1
	public void dragExit(java.awt.dnd.DragSourceEvent dse) {
d106 1
a106 1
		//log("DragSourceDragEvent-dragOver");
a111 1
		log("DragSourceDragEvent-dropActionChanged");
d136 1
a136 2
	public static class RemoveUndoActivity extends CH.ifa.draw.util.UndoableAdapter {
		private boolean undone = false;
d145 5
a149 8
			if (isUndoable()) {
				if(getAffectedFigures().hasNextFigure()) {
					log("RemoveUndoActivity undo");
					getDrawingView().clearSelection();
					setAffectedFigures( getDrawingView().insertFigures(getAffectedFigures(), 0, 0,false));
					undone = true;
					return true;
				}
d161 1
a161 1
					fe.nextFigure().visit(deleteVisitor); //orphans figures
a164 1
				undone = false;
d170 2
a171 2
		 * Since this is a delete activity, figures can only be released if the
		 * action has not been undone.
d174 3
a176 7
			if(undone == false){//we have figures that used to be in the drawing, but were not adding back
				FigureEnumeration fe = getAffectedFigures();
				while (fe.hasNextFigure()) {
					Figure f = fe.nextFigure();
					getDrawingView().drawing().remove(f);
					f.release();
				}
@


