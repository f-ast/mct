head	1.11;
access;
symbols
	jhotdraw60b1-release:1.11
	package_rename:1.11
	directory_rename:1.10
	reorg_6x_split_initial:1.10
	MVC_PHASE1:1.10.0.10
	NEW_ATTRIBUTES:1.10.0.8
	DNOYEB1_ALPHA-2:1.10.4.2
	release_JHD54b1:1.10
	BUGFIX_670992:1.10.0.6
	DNOYEB1_ALPHA-1:1.10.4.2
	dnoyeb1:1.10.0.4
	repack:1.10.0.2
	Root_repack:1.10
	Before_FigureVisitor:1.9
	JHotDraw_5-3:1.7
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.22.08.58.22;	author mrfloppy;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.19.18.31.32;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.20.25.13;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.29.13.42.14;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.10.4.1
date	2003.01.16.15.59.18;	author dnoyeb;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2003.01.17.21.56.05;	author dnoyeb;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2003.02.02.16.54.10;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.11
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)PasteCommand.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import org.jhotdraw.framework.*;
import org.jhotdraw.util.*;
import java.awt.*;

/**
 * Command to insert the clipboard into the drawing.
 *
 * @@see Clipboard
 *
 * @@version <$CURRENT_VERSION$>
 */
public class PasteCommand extends FigureTransferCommand {

	/**
	 * Constructs a paste command.
	 * @@param name the command name
	 * @@param newDrawingEditor the DrawingEditor which manages the views
	 */
	public PasteCommand(String name, DrawingEditor newDrawingEditor) {
		super(name, newDrawingEditor);
	}

	public void execute() {
		super.execute();
		Point lastClick = view().lastClick();
		FigureSelection selection = (FigureSelection)Clipboard.getClipboard().getContents();
		if (selection != null) {
			setUndoActivity(createUndoActivity());
			getUndoActivity().setAffectedFigures(
				(FigureEnumerator)selection.getData(StandardFigureSelection.TYPE));

			if (!getUndoActivity().getAffectedFigures().hasNextFigure()) {
				setUndoActivity(null);
				return;
			}

			Rectangle r = getBounds(getUndoActivity().getAffectedFigures());
			view().clearSelection();

			// get an enumeration of inserted figures
			FigureEnumeration fe = insertFigures(getUndoActivity().getAffectedFigures(), lastClick.x-r.x, lastClick.y-r.y);
			getUndoActivity().setAffectedFigures(fe);

			view().checkDamage();
		}
	}

	public boolean isExecutableWithView() {
		return Clipboard.getClipboard().getContents() != null;
	}

	private Rectangle getBounds(FigureEnumeration fe) {
		Rectangle r = fe.nextFigure().displayBox();
		while (fe.hasNextFigure()) {
			r.add(fe.nextFigure().displayBox());
		}
		return r;
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new PasteCommand.UndoActivity(view());
	}

	public static class UndoActivity extends UndoableAdapter {

		public UndoActivity(DrawingView newDrawingView) {
			super(newDrawingView);
			setUndoable(true);
			setRedoable(true);
		}

		public boolean undo() {
			if (!super.undo()) {
				return false;
			}

			DeleteFromDrawingVisitor deleteVisitor = new DeleteFromDrawingVisitor(getDrawingView().drawing());
			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
	    		fe.nextFigure().visit(deleteVisitor);
			}

			getDrawingView().clearSelection();

			return true;
		}

		public boolean redo() {
			// do not call execute directly as the selection might has changed
			if (!isRedoable()) {
				return false;
			}

			getDrawingView().clearSelection();
			setAffectedFigures(getDrawingView().insertFigures(
				getAffectedFigures(), 0, 0, false));

			return true;
		}
	}
}
@


1.10
log
@introduce FigureVisitor for paste/delete commands
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d14 2
a15 2
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.*;
@


1.10.4.1
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d57 1
a57 1
			view().drawing().update();
@


1.10.4.2
log
@view addToSelection used drawing.includes(figure) but selectionZOrdered uses figures()
these are 2 different sets of figures.  changed addToSelection to use containsFigure()
Added some experimental copy constructors that are not being used.
some trivial comments.
@
text
@d92 1
a92 1
			//why does undo visit the drawing when we already know the figures we need? ???dnoyeb???
@


1.10.4.3
log
@figure.release() cleanup.  trying to make release work properly.
@
text
@d81 1
a81 1
		private boolean undone = false;
a92 2
			//well it deletes them but we are not using the returned figures so we are still
			//assuming we know the figures that will be deleted.
d100 1
a100 1
			undone = true;
d113 1
a113 1
			undone = false;
a115 18
		/**
		 * Releases all resources related to an undoable activity
		 * Since cut duplicates the figures, it is ok to release the originals
		 * because the pasted figures are completely new objects.
		 * But we can only release if the action has not been undone.
		 */
		public void release() {
			if(undone == true){ //creation type commands destroy in their undo, so nothing to release
				//destroy the removed figures
				FigureEnumeration fe2 = getAffectedFigures();
				while (fe2.hasNextFigure()) {
					Figure f= fe2.nextFigure();
					getDrawingView().drawing().remove(f);
					f.release();
				}
			}
			super.release();
		}	
@


1.9
log
@after variou merges... (before 5.4 release)
@
text
@d93 1
d96 1
a96 1
				getDrawingView().drawing().orphan(fe.nextFigure());
@


1.8
log
@no message
@
text
@a15 1
import java.util.Enumeration;
d45 1
a45 1
			if (!getUndoActivity().getAffectedFigures().hasMoreElements()) {
d67 1
a67 1
		while (fe.hasMoreElements()) {
d94 1
a94 1
			while (fe.hasMoreElements()) {
@


1.7
log
@no message
@
text
@d45 1
a45 1
			
d51 1
a51 1
			Rectangle r = bounds(getUndoActivity().getAffectedFigures());
d57 1
a57 1
			
d66 4
a69 4
	Rectangle bounds(Enumeration k) {
		Rectangle r = ((Figure) k.nextElement()).displayBox();
		while (k.hasMoreElements()) {
			r.add(((Figure) k.nextElement()).displayBox());
d82 1
a82 1
		
d88 1
a88 1
		
d94 1
a94 1
			FigureEnumeration fe = getAffectedFigures();			
d98 1
a98 1
	
d103 1
a103 1
	
@


1.6
log
@merge dnd (before 5.3)
@
text
@d43 5
a47 2

			if (view().selectionCount() <= 0) {
a50 1
			getUndoActivity().setAffectedFigures(view().selectionElements());
d54 1
a54 1
			// get a new enumeration
@


1.5
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d28 7
a34 8
   /**
	* Constructs a paste command.
	* @@param name the command name
	* @@param image the pathname of the image
	* @@param view the target view
	*/
	public PasteCommand(String name, DrawingView view) {
		super(name, view);
d38 1
d58 4
@


1.4
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)PasteCommand.java 5.2
d4 6
d14 3
a16 1
import java.util.*;
a17 2
import CH.ifa.draw.util.*;
import CH.ifa.draw.framework.*;
d21 1
d23 2
d29 82
a110 31
    * Constructs a paste command.
    * @@param name the command name
    * @@param image the pathname of the image
    * @@param view the target view
    */
    public PasteCommand(String name, DrawingView view) {
        super(name, view);
    }

    public void execute() {
        Point lastClick = fView.lastClick();
        FigureSelection selection = (FigureSelection)Clipboard.getClipboard().getContents();
        if (selection != null) {
            Vector figures = (Vector)selection.getData(FigureSelection.TYPE);
            if (figures.size() == 0)
                return;

            Rectangle r = bounds(figures.elements());
            fView.clearSelection();

            insertFigures(figures, lastClick.x-r.x, lastClick.y-r.y);
            fView.checkDamage();
        }
    }

    Rectangle bounds(Enumeration k) {
        Rectangle r = ((Figure) k.nextElement()).displayBox();
        while (k.hasMoreElements())
            r.add(((Figure) k.nextElement()).displayBox());
        return r;
    }
a111 2


@


1.3
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@d30 1
a30 1
        Point lastClick = view().lastClick();
d33 1
a33 1
            Vector figures = (Vector)selection.getData(StandardFigureSelection.TYPE);
d38 1
a38 1
            view().clearSelection();
d41 1
a41 1
            view().checkDamage();
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d30 1
a30 1
        Point lastClick = fView.lastClick();
d33 1
a33 1
            Vector figures = (Vector)selection.getData(FigureSelection.TYPE);
d38 1
a38 1
            fView.clearSelection();
d41 1
a41 1
            fView.checkDamage();
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)PasteCommand.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
