head	1.6;
access;
symbols
	jhotdraw60b1-release:1.6
	package_rename:1.6
	directory_rename:1.5
	reorg_6x_split_initial:1.5
	MVC_PHASE1:1.4.0.10
	NEW_ATTRIBUTES:1.4.0.8
	DNOYEB1_ALPHA-2:1.4.4.1
	release_JHD54b1:1.4
	BUGFIX_670992:1.4.0.6
	DNOYEB1_ALPHA-1:1.4
	dnoyeb1:1.4.0.4
	repack:1.4.0.2
	Root_repack:1.4
	Before_FigureVisitor:1.4
	JHotDraw_5-3:1.3
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.09.21.18.46;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.10.24.20.44.33;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.4.4.1
date	2003.01.26.00.51.16;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.6
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)FigureChangeEventMulticaster.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import org.jhotdraw.framework.*;
import java.awt.*;
import java.util.*;

/**
 * Manages a list of FigureChangeListeners to be notified of
 * specific FigureChangeEvents.
 *
 * @@version <$CURRENT_VERSION$>
 */
public class FigureChangeEventMulticaster extends
	AWTEventMulticaster implements FigureChangeListener {

	public FigureChangeEventMulticaster(EventListener newListenerA, EventListener newListenerB) {
		super(newListenerA, newListenerB);
	}

	public void figureInvalidated(FigureChangeEvent e) {
		((FigureChangeListener)a).figureInvalidated(e);
		((FigureChangeListener)b).figureInvalidated(e);
	}

	public void figureRequestRemove(FigureChangeEvent e) {
		((FigureChangeListener)a).figureRequestRemove(e);
		((FigureChangeListener)b).figureRequestRemove(e);
	}

	public void figureRequestUpdate(FigureChangeEvent e) {
		((FigureChangeListener)a).figureRequestUpdate(e);
		((FigureChangeListener)b).figureRequestUpdate(e);
	}

	public void figureChanged(FigureChangeEvent e) {
		((FigureChangeListener)a).figureChanged(e);
		((FigureChangeListener)b).figureChanged(e);
	}

	public void figureRemoved(FigureChangeEvent e) {
		((FigureChangeListener)a).figureRemoved(e);
		((FigureChangeListener)b).figureRemoved(e);
	}

	public static FigureChangeListener add(FigureChangeListener a, FigureChangeListener b) {
		return (FigureChangeListener)addInternal(a, b);
	}


	public static FigureChangeListener remove(FigureChangeListener l, FigureChangeListener oldl) {
		return (FigureChangeListener) removeInternal(l, oldl);
	}

	protected EventListener remove(EventListener oldl)
	{
		if (oldl == a) {
			return b;
		}
		if (oldl == b) {
			return a;
		}
		EventListener a2 = removeInternal(a, oldl);
		EventListener b2 = removeInternal(b, oldl);
		if (a2 == a && b2 == b) {
			return this;
		}
		else {
			return addInternal((FigureChangeListener)a2, (FigureChangeListener)b2);
		}
	}

	protected static EventListener addInternal(FigureChangeListener a, FigureChangeListener b) {
		if (a == null) {
			return b;
		}
		if (b == null) {
			return a;
		}
		return new FigureChangeEventMulticaster(a, b);
	}

	protected static EventListener removeInternal(EventListener l, EventListener oldl) {
		if (l == oldl || l == null) {
			return null;
		}
		else if (l instanceof FigureChangeEventMulticaster) {
			return ((FigureChangeEventMulticaster)l).remove(oldl);
		}
		else {
			return l;		// it's not here
		}
	}

}
@


1.5
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d14 1
a14 1
import CH.ifa.draw.framework.*;
@


1.4
log
@after variou merges... (before 5.4 release)
@
text
@d27 2
a28 2
	public FigureChangeEventMulticaster(EventListener a, EventListener b) {
		super(a, b);
d73 2
a74 2
		EventListener a2 = removeInternal((FigureChangeListener)a, oldl);
		EventListener b2 = removeInternal((FigureChangeListener)b, oldl);
@


1.4.4.1
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d36 5
d49 5
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 3
@
text
@a13 1
import CH.ifa.draw.util.*;
a15 1
import java.awt.event.*;
a16 1
import java.io.*;
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)FigureChangeEventMulticaster.java 5.2
d4 6
d24 2
a26 2


d28 1
a28 1
    AWTEventMulticaster implements FigureChangeListener {
d30 77
a106 67
    public FigureChangeEventMulticaster(EventListener a, EventListener b) {
    	super(a, b);
    }

    public void figureInvalidated(FigureChangeEvent e) {
        ((FigureChangeListener)a).figureInvalidated(e);
        ((FigureChangeListener)b).figureInvalidated(e);
    }

    public void figureRequestRemove(FigureChangeEvent e) {
        ((FigureChangeListener)a).figureRequestRemove(e);
        ((FigureChangeListener)b).figureRequestRemove(e);
    }

    public void figureRequestUpdate(FigureChangeEvent e) {
        ((FigureChangeListener)a).figureRequestUpdate(e);
        ((FigureChangeListener)b).figureRequestUpdate(e);
    }

    public void figureChanged(FigureChangeEvent e) {
        ((FigureChangeListener)a).figureChanged(e);
        ((FigureChangeListener)b).figureChanged(e);
    }

    public void figureRemoved(FigureChangeEvent e) {
        ((FigureChangeListener)a).figureRemoved(e);
        ((FigureChangeListener)b).figureRemoved(e);
    }

    public static FigureChangeListener add(FigureChangeListener a, FigureChangeListener b) {
        return (FigureChangeListener)addInternal(a, b);
    }


    public static FigureChangeListener remove(FigureChangeListener l, FigureChangeListener oldl) {
	    return (FigureChangeListener) removeInternal(l, oldl);
    }

    protected EventListener remove(EventListener oldl)
    {
        if (oldl == a)
            return b;
        if (oldl == b)
            return a;
        EventListener a2 = removeInternal((FigureChangeListener)a, oldl);
        EventListener b2 = removeInternal((FigureChangeListener)b, oldl);
        if (a2 == a && b2 == b)
            return this;
        else
            return addInternal((FigureChangeListener)a2, (FigureChangeListener)b2);
    }

    protected static EventListener addInternal(FigureChangeListener a, FigureChangeListener b) {
	    if (a == null)  return b;
	    if (b == null)  return a;
	    return new FigureChangeEventMulticaster(a, b);
    }

    protected static EventListener removeInternal(EventListener l, EventListener oldl) {
    	if (l == oldl || l == null) {
    	    return null;
    	} else if (l instanceof FigureChangeEventMulticaster) {
    	    return ((FigureChangeEventMulticaster)l).remove(oldl);
    	} else {
    	    return l;		// it's not here
    	}
    }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)FigureChangeEventMulticaster.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
