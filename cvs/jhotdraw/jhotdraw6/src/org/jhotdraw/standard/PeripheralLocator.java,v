head	1.5;
access;
symbols
	jhotdraw60b1-release:1.5
	package_rename:1.5
	directory_rename:1.4
	reorg_6x_split_initial:1.4
	MVC_PHASE1:1.4.0.2
	NEW_ATTRIBUTES:1.3.0.2
	DNOYEB1_ALPHA-2:1.1
	release_JHD54b1:1.2
	BUGFIX_670992:1.1.0.6
	DNOYEB1_ALPHA-1:1.1
	dnoyeb1:1.1.0.4
	repack:1.1.0.2
	Root_repack:1.1
	Before_FigureVisitor:1.1;
locks; strict;
comment	@# @;


1.5
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.22.23.58.41;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.04.05.26.58;	author ricardo_padilha;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.30.00.27.27;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	;


desc
@@


1.5
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@/*
 * @@(#)PeripheralLocator.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import java.awt.Point;
import org.jhotdraw.framework.Figure;
import java.awt.*;
import java.lang.Math;

/**
 * @@author  C.L.Gilbert <dnoyeb@@users.sourceforge.net>
 * @@version <$CURRENT_VERSION$>
 */
public class PeripheralLocator extends AbstractLocator {
	private static int CORNERSPACE = 1;
	private Figure fOwner;
	private int fPPS;
	private int fIndex;

	private PeripheralLocator() {
		// do nothing: for JDO-compliance only
	}

	public PeripheralLocator(int pointsPerSide, int index) {
		fPPS = pointsPerSide;
		fIndex = index;
		if (index >= pointsPerSide *4) {
			throw new IllegalArgumentException("Index must be within the range of points starting with index = 0.");
		}
	}

    public Point locate(Figure parm1) {
		Rectangle r = parm1.displayBox();
		/* calculate total length for spacing */
		//int circumference = r.width*2 + r.height*2;
		/* subtrace corners spacing */
		//int insets = 2 * 4 * CORNERSPACE;

		//int spacing = circumference/(fPPS*4 +4);
		float hSpacing = (float)r.width / (fPPS +1);
		float vSpacing = (float)r.height / (fPPS +1);

		int x = 0;
		int y = 0;
		if (fIndex < fPPS) {
			//north
			x = Math.round((fIndex + 1.0f ) * hSpacing);
			y = 0;
		}
		else if (fIndex < (fPPS*2)) {
			//east
			x = Math.round((fPPS + 1 ) * hSpacing) ;//r.width;
			y = Math.round((fIndex +1 - fPPS) * vSpacing);  //should be negative?
		}
		else if (fIndex < (fPPS*3)) {
			//south
			x = Math.round(((fPPS + 1 ) - (fIndex +1 - fPPS*2))* hSpacing);
			y = Math.round((fPPS + 1 )* vSpacing) /*r.height*/;
		}
		else {
			//west
			x = 0;
			y = Math.round(((fPPS +1) - (fIndex +1 - fPPS*3))*vSpacing);
		}
		x = x+r.x;
		y = y+r.y;
		return new Point((int)x, (int)y);
    }
}@


1.4
log
@no message
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d15 1
a15 1
import CH.ifa.draw.framework.Figure;
@


1.3
log
@Removed unused local variables.
@
text
@d48 1
a48 1
	  //int spacing = circumference/(fPPS*4 +4);
d52 4
a55 2
		int x,y;
		if (fIndex < fPPS) { //north
d59 3
a61 2
		else if (fIndex < fPPS*2) { //east
			x = Math.round((fPPS + 1 )* hSpacing) ;//r.width;
d64 2
a65 1
		else if (fIndex < fPPS*3) { //south
d69 3
a71 2
		else {    //west
		    x = 0;
d74 3
a76 3
		x=x+r.x;
		y=y+r.y;
		return new Point((int)x,(int)y);
@


1.2
log
@prepare for 5.4 release: various bug fixes
@
text
@d44 1
a44 1
		int circumference = r.width*2 + r.height*2;
d46 1
a46 1
		int insets = 2 * 4 * CORNERSPACE;
d48 1
a48 1
	    int spacing = circumference/(fPPS*4 +4);
@


1.1
log
@after variou merges... (before 5.4 release)
@
text
@d20 1
a20 1
 * @@author  C.L.Gilbert <dnoyeb@@sourceforge.net>
@

