head	1.10;
access;
symbols
	jhotdraw60b1-release:1.8
	package_rename:1.8
	directory_rename:1.7
	reorg_6x_split_initial:1.7
	MVC_PHASE1:1.6.0.4
	NEW_ATTRIBUTES:1.6.0.2
	DNOYEB1_ALPHA-2:1.5.4.5
	release_JHD54b1:1.5
	BUGFIX_670992:1.5.0.6
	DNOYEB1_ALPHA-1:1.5.4.4
	dnoyeb1:1.5.0.4
	repack:1.5.0.2
	Root_repack:1.5
	Before_FigureVisitor:1.5
	JHotDraw_5-3:1.4
	JHotDraw_5-2_merged:1.2
	JHotDraw_5-1_initial:1.1
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2004.03.06.14.36.53;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.23.05.06.57;	author cfm1;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.09.22.53.41;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.25.10.35.43;	author pleumann;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.04.05.11.49;	author ricardo_padilha;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.5.4.1
date	2003.01.10.04.54.45;	author dnoyeb;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.01.14.18.24.46;	author dnoyeb;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.01.16.15.59.18;	author dnoyeb;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.01.21.00.04.36;	author dnoyeb;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.01.26.00.51.07;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.10
log
@adjusted formatting
@
text
@/*
 * @@(#)ConnectionTool.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	© by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package org.jhotdraw.standard;

import org.jhotdraw.framework.*;
import org.jhotdraw.util.Geom;
import org.jhotdraw.util.UndoableAdapter;
import org.jhotdraw.util.Undoable;
import java.awt.*;
import java.awt.event.MouseEvent;

/**
 * A tool that can be used to connect figures, to split
 * connections, and to join two segments of a connection.
 * ConnectionTools turns the visibility of the Connectors
 * on when it enters a figure.
 * The connection object to be created is specified by a prototype.
 * <hr>
 * <b>Design Patterns</b><P>
 * <img src="images/red-ball-small.gif" width=6 height=6 alt=" o ">
 * <b><a href=../pattlets/sld029.htm>Prototype</a></b><br>
 * ConnectionTools creates the connection by cloning a prototype.
 * <hr>
 *
 * @@see ConnectionFigure
 * @@see Object#clone
 *
 * @@version <$CURRENT_VERSION$>
 */
public  class ConnectionTool extends AbstractTool {

	/**
	 * the anchor point of the interaction
	 */
	private Connector   myStartConnector;
	private Connector   myEndConnector;
	private Connector   myTargetConnector;

	private Figure myTarget;

	/**
	 * the currently created figure
	 */
	private ConnectionFigure  myConnection;

	/**
	 * the currently manipulated connection point
	 */
	private int  fSplitPoint;

	/**
	 * the currently edited connection
	 */
	private ConnectionFigure  fEditedConnection;

	/**
	 * the figure that was actually added
	 * Note, this can be a different figure from the one which has been created.
	 */
	private Figure myAddedFigure;

	/**
	 * the prototypical figure that is used to create new
	 * connections.
	 */
	private ConnectionFigure  fPrototype;


	public ConnectionTool(DrawingEditor newDrawingEditor, ConnectionFigure newPrototype) {
		super(newDrawingEditor);
		fPrototype = newPrototype;
	}

	/**
	 * Handles mouse move events in the drawing view.
	 */
	public void mouseMove(MouseEvent e, int x, int y) {
		trackConnectors(e, x, y);
	}

	/**
	 * Manipulates connections in a context dependent way. If the
	 * mouse down hits a figure start a new connection. If the mousedown
	 * hits a connection split a segment or join two segments.
	 */
	public void mouseDown(MouseEvent e, int x, int y) {
		super.mouseDown(e,x,y);
		int ex = e.getX();
		int ey = e.getY();

		OffsetConnector.trackingConnector1.reset(getActiveView());

        /*
         * JP, 25-May-03: Swapped checking for underlying figure and
         * existing connection. If figure is checked first (old version),
         * it is not possible to insert new points into a connection that
         * crosses or otherwise goes through an existing figure. New
         * version checks for connection first.
         */
		ConnectionFigure connection = findConnection(ex, ey, drawing());
		if (connection != null) {
			if (!connection.joinSegments(ex, ey)) {
				fSplitPoint = connection.splitSegment(ex, ey);
				fEditedConnection = connection;
			}
			else {
				fEditedConnection = null;
			}
		}
		else {
			setTargetFigure(findConnectionStart(ex, ey, drawing()));
			if (getTargetFigure() != null) {
				setStartConnector(findConnector(ex, ey, getTargetFigure()));
				if (getStartConnector() != null) {
					setConnection(createConnection());
					getConnection().startPoint(ex, ey);
					getConnection().endPoint(ex, ey);
					setAddedFigure(view().add(getConnection()));
				}
			}
		}
	}

	/**
	 * Adjust the created connection or split segment.
	 */
	public void mouseDrag(MouseEvent e, int x, int y) {
		Point p = new Point(e.getX(), e.getY());
		if (getConnection() != null) {
			trackConnectors(e, x, y);
			if (getTargetConnector() != null) {
				p = Geom.center(getTargetConnector().displayBox());
			}
			getConnection().endPoint(p.x, p.y);
		}
		else if (fEditedConnection != null) {
			Point pp = new Point(x, y);
			fEditedConnection.setPointAt(pp, fSplitPoint);
		}
	}

	/**
	 * Connects the figures if the mouse is released over another
	 * figure.
	 */
	public void mouseUp(MouseEvent e, int x, int y) {
		Figure c = null;
		if (getStartConnector() != null) {
			c = findTarget(e.getX(), e.getY(), drawing());
		}

		if (c != null) {
			setEndConnector(findConnector(e.getX(), e.getY(), c));
			if (getEndConnector() != null) {
				getConnection().connectStart(getStartConnector());
				getConnection().connectEnd(getEndConnector());
				getConnection().updateConnection();

				setUndoActivity(createUndoActivity());
				getUndoActivity().setAffectedFigures(
					new SingleFigureEnumerator(getAddedFigure()));
			}
		}
		else if (getConnection() != null) {
			view().remove(getConnection());
		}

		setConnection(null);
		setStartConnector(null);
		setEndConnector(null);
		setAddedFigure(null);
		editor().toolDone();
	}

	public void deactivate() {
		super.deactivate();
		if (getTargetFigure() != null) {
			getTargetFigure().connectorVisibility(false, null);
		}
	}

	/**
	 * Creates the ConnectionFigure. By default the figure prototype is
	 * cloned.
	 */
	protected ConnectionFigure createConnection() {
		return (ConnectionFigure)fPrototype.clone();
	}

	/**
	 * Finds a connectable figure target.
	 */
	protected Figure findSource(int x, int y, Drawing drawing) {
		return findConnectableFigure(x, y, drawing);
	}

	/**
	 * Finds a connectable figure target at the current mouse location that can
	 * 1.  Connect to things
	 * 2.  Is not already connected to the current Connection (no self connection)
	 * 3.  The current Connection can make a connection between it and the start
	 *     figure.
	 */
	protected Figure findTarget(int x, int y, Drawing drawing) {
		Figure target = findConnectableFigure(x, y, drawing);
		Figure start = getStartConnector().owner();
		boolean includesStart = (target != null && target.includes(start));
		if ((myStartConnector == OffsetConnector.trackingConnector1)
			 || (myStartConnector == OffsetConnector.trackingConnector2)) {
			includesStart = false;
		}

		if (target != null
			 && getConnection() != null
			 && target.canConnect()
			 && !includesStart
			 && getConnection().canConnect(start, target)) {
			return target;
		}
		return null;
	}

	/**
	 * Finds an existing connection figure.
	 */
	protected ConnectionFigure findConnection(int x, int y, Drawing drawing) {
		FigureEnumeration fe = drawing.figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			figure = figure.findFigureInside(x, y);
			if (figure != null && (figure instanceof ConnectionFigure)) {
				return (ConnectionFigure)figure;
			}
		}
		return null;
	}

	protected void setConnection(ConnectionFigure newConnection) {
		myConnection = newConnection;
	}

	/**
	 * Gets the connection which is created by this tool
	 */
	protected ConnectionFigure getConnection() {
		return myConnection;
	}

	/**
	 * Attempts to set the Connector to be connected to based on the current
	 * location of the mouse.
	 */
	protected void trackConnectors(MouseEvent e, int x, int y) {
		Figure c = null;

		// If tool is not actively looking for a target for our current
		// Connection, see if there are any connectable figures at at the
		// current location(findSource).
		if (getStartConnector() == null) {
			c = findSource(x, y, getActiveDrawing());
		}
		else {
			c = findTarget(x, y, getActiveDrawing());
		}

		// track the figure containing the mouse
		/**
		 * If the current target is not the stored target then turn off the
		 * stored targets connectors visibility and turn on the current targets
		 * connectors visibility. Then set the stored target to the current target.
		 * If the targets match then don't do anything.
		 * Note:  the target may have more than one connector.
		 */
		if (c != getTargetFigure()) {
			if (getTargetFigure() != null) {
				getTargetFigure().connectorVisibility(false, null);
			}
			setTargetFigure(c);
			if (getTargetFigure() != null) {
				getTargetFigure().connectorVisibility(true, getConnection());
			}
		}

		// Since you have a legitimate target, grab its connector and set it as
		// the new target connector.
		Connector cc = null;
		if (c != null) {
			cc = findConnector(e.getX(), e.getY(), c);
		}
		if (cc != getTargetConnector()) {
			setTargetConnector(cc);
		}

		// Clean up the view.
		getActiveView().checkDamage();
	}

	protected Connector findConnector(int x, int y, Figure f) {
		return f.connectorAt(x, y);
	}

	/**
	 * Finds a connection start figure.
	 */
	protected Figure findConnectionStart(int x, int y, Drawing drawing) {
		Figure target = findConnectableFigure(x, y, drawing);
		if ((target != null) && target.canConnect()) {
			return target;
		}
		return null;
	}

	/**
	 * Returns the topmost? figure that can connect and is at the current mouse
	 * location.
	 */
	protected Figure findConnectableFigure(int x, int y, Drawing drawing) {
		FigureEnumeration fe = drawing.figuresReverse();
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			if (!figure.includes(getConnection()) && figure.canConnect()
				&& figure.containsPoint(x, y)) {
				return figure;
			}
		}
		return null;
	}

	protected void setStartConnector(Connector newStartConnector) {
		myStartConnector = newStartConnector;
	}

	protected Connector getStartConnector() {
		return myStartConnector;
	}

	protected void setEndConnector(Connector newEndConnector) {
		myEndConnector = newEndConnector;
	}

	protected Connector getEndConnector() {
		return myEndConnector;
	}

	protected void setTargetConnector(Connector newTargetConnector) {
		myTargetConnector = newTargetConnector;
	}

	protected Connector getTargetConnector() {
		return myTargetConnector;
	}

	protected void setTargetFigure(Figure newTarget) {
		myTarget = newTarget;
	}

	protected Figure getTargetFigure() {
		return myTarget;
	}

	/**
	 * Gets the figure that was actually added
	 * Note, this can be a different figure from the one which has been created.
	 */
	protected Figure getAddedFigure() {
		return myAddedFigure;
	}

	protected void setAddedFigure(Figure newAddedFigure) {
		myAddedFigure = newAddedFigure;
	}

	/**
	 * Factory method for undo activity
	 */
	protected Undoable createUndoActivity() {
		return new ConnectionTool.UndoActivity(view(), getConnection());
	}

	public static class UndoActivity extends UndoableAdapter {

		private ConnectionFigure  myConnection;
		private Connector   myStartConnector;
		private Connector   myEndConnector;

		public UndoActivity(DrawingView newDrawingView, ConnectionFigure newConnection) {
			super(newDrawingView);
			setConnection(newConnection);
			myStartConnector = getConnection().getStartConnector();
			myEndConnector = getConnection().getEndConnector();
	        setUndoable(true);
			setRedoable(true);
		}

		/*
		 * Undo the activity
		 * @@return true if the activity could be undone, false otherwise
		 */
		public boolean undo() {
			if (!super.undo()) {
				return false;
			}

			getConnection().disconnectStart();
			getConnection().disconnectEnd();

			FigureEnumeration fe = getAffectedFigures();
			while (fe.hasNextFigure()) {
				getDrawingView().drawing().orphan(fe.nextFigure());
			}

			getDrawingView().clearSelection();

			return true;
		}

		/*
		 * Redo the activity
		 * @@return true if the activity could be redone, false otherwise
		 */
		public boolean redo() {
			if (!super.redo()) {
				return false;
			}

			getConnection().connectStart(myStartConnector);
			getConnection().connectEnd(myEndConnector);
			getConnection().updateConnection();

			getDrawingView().insertFigures(getAffectedFigures(), 0, 0, false);

			return true;
		}

		protected void setConnection(ConnectionFigure newConnection) {
			myConnection = newConnection;
		}

		/**
		 * Gets the currently created figure
		 */
		protected ConnectionFigure getConnection() {
			return myConnection;
		}
	}
}
@


1.9
log
@OffsetConnectors added
@
text
@d99 2
a100 3
//      cfm1 *******************************************************************       
        OffsetConnector.trackingConnector1.reset(getActiveView());
//      cfm1 *******************************************************************        
d216 5
a220 6
//      cfm1 *******************************************************************
        boolean includesStart = (target != null && target.includes(start));
        if (myStartConnector == OffsetConnector.trackingConnector1 || 
            myStartConnector == OffsetConnector.trackingConnector2)
            includesStart = false;
//      cfm1 *******************************************************************
d225 1
a225 4
//      cfm1 *******************************************************************
			 && !includesStart
//      cfm1 *******************************************************************             
            // && !target.includes(start)
@


1.8
log
@After renaming the CH.ifa.draw to org.jhotdraw
@
text
@d99 3
d217 6
d227 4
a230 1
			 && !target.includes(start)
@


1.7
log
@Swapped checking for underlying figure and existing connection. If figure is checked first (old version), it is not possible to insert new points into a connection that crosses or otherwise goes through an existing figure. New version checks for connection first.
@
text
@d12 1
a12 1
package CH.ifa.draw.standard;
d14 4
a17 4
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.UndoableAdapter;
import CH.ifa.draw.util.Undoable;
@


1.6
log
@Removed unused import.
@
text
@d99 16
a114 8
		setTargetFigure(findConnectionStart(ex, ey, drawing()));
		if (getTargetFigure() != null) {
			setStartConnector(findConnector(ex, ey, getTargetFigure()));
			if (getStartConnector() != null) {
				setConnection(createConnection());
				getConnection().startPoint(ex, ey);
				getConnection().endPoint(ex, ey);
				setAddedFigure(view().add(getConnection()));
d118 8
a125 10
			// Since we can't connect to the figure, see if its a Connection
			// object we can modify the appearance of.
			ConnectionFigure connection = findConnection(ex, ey, drawing());
			if (connection != null) {
				if (!connection.joinSegments(ex, ey)) {
					fSplitPoint = connection.splitSegment(ex, ey);
					fEditedConnection = connection;
				}
				else {
					fEditedConnection = null;
@


1.5
log
@after variou merges... (before 5.4 release)
@
text
@a19 1
import java.util.*;
@


1.5.4.1
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d19 1
a19 1

d87 2
a88 2
	public void mouseMove(DrawingViewMouseEvent dvme) {
		trackConnectors(dvme);
d96 5
a100 7
	public void mouseDown(DrawingViewMouseEvent dvme) {
		super.mouseDown(dvme);
		// use event coordinates to supress any kind of
		// transformations like constraining points to a grid
		setAnchorX( dvme.getMouseEvent().getX() );
		setAnchorY( dvme.getMouseEvent().getY() );
		setTargetFigure(findConnectionStart(getAnchorX(), getAnchorY(), drawing()));
d102 1
a102 1
			setStartConnector(findConnector(getAnchorX(), getAnchorY(), getTargetFigure()));
d105 2
a106 2
				getConnection().startPoint(getAnchorX(), getAnchorY());
				getConnection().endPoint(getAnchorX(), getAnchorY());
d113 1
a113 1
			ConnectionFigure connection = findConnection(getAnchorX(), getAnchorY(), drawing());
d115 2
a116 2
				if (!connection.joinSegments(getAnchorX(), getAnchorY())) {
					fSplitPoint = connection.splitSegment(getAnchorX(), getAnchorY());
d129 2
a130 2
	public void mouseDrag(DrawingViewMouseEvent dvme) {
		Point p = new Point(dvme.getMouseEvent().getX(), dvme.getMouseEvent().getY());
d132 1
a132 1
			trackConnectors(dvme);
d139 1
a139 1
			Point pp = new Point(dvme.getX(), dvme.getY());
d148 1
a148 1
	public void mouseUp(DrawingViewMouseEvent dvme) {
d151 1
a151 1
			c = findTarget(dvme.getMouseEvent().getX(), dvme.getMouseEvent().getY(), drawing());
d155 1
a155 1
			setEndConnector(findConnector(dvme.getMouseEvent().getX(), dvme.getMouseEvent().getY(), c));
d250 1
a250 1
	protected void trackConnectors(DrawingViewMouseEvent dvme) {
d257 1
a257 1
			c = findSource(dvme.getX(), dvme.getY(), getActiveDrawing());
d260 1
a260 1
			c = findTarget(dvme.getX(), dvme.getY(), getActiveDrawing());
d285 1
a285 1
			cc = findConnector(dvme.getMouseEvent().getX(), dvme.getMouseEvent().getY(), c);
@


1.5.4.2
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d109 1
a109 2
				view().add(getConnection());
				setAddedFigure(getConnection());
d408 1
a408 3
				fe.nextFigure().remove();
				//This tool must now release these figures when it is ready
				//getDrawingView().drawing().orphan(fe.nextFigure());
@


1.5.4.3
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d294 2
a295 2
		// Clean up the views.
		getActiveView().drawing().update();
@


1.5.4.4
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d109 2
a110 1
				setAddedFigure(view().add(getConnection()));
d409 1
d411 1
a411 1
				getDrawingView().drawing().orphan(fe.nextFigure());
@


1.5.4.5
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d109 1
a109 2
				view().add(getConnection());
				setAddedFigure(getConnection());
@


1.4
log
@merge dnd (before 5.3)
@
text
@d96 2
a97 2
	public void mouseDown(MouseEvent e, int x, int y)
	{
a103 1
				Point p = new Point(ex, ey);
d105 2
a106 2
				getConnection().startPoint(p.x, p.y);
				getConnection().endPoint(p.x, p.y);
d111 2
d180 1
a180 1
			getTargetFigure().connectorVisibility(false);
d200 5
a204 1
	 * Finds a connectable figure target.
d224 3
a226 3
		Enumeration k = drawing.figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = (Figure) k.nextElement();
d235 1
a235 1
	private void setConnection(ConnectionFigure newConnection) {
d238 1
a238 1
	
d246 4
d253 3
d257 1
a257 1
			c = findSource(x, y, drawing());
d260 1
a260 1
			c = findTarget(x, y, drawing());
d264 7
d273 1
a273 1
				getTargetFigure().connectorVisibility(false);
d277 1
a277 1
				getTargetFigure().connectorVisibility(true);
d281 2
d291 2
a292 1
		view().checkDamage();
d295 1
a295 1
	private Connector findConnector(int x, int y, Figure f) {
d310 8
a317 4
	private Figure findConnectableFigure(int x, int y, Drawing drawing) {
		FigureEnumeration k = drawing.figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
d326 1
a326 1
	private void setStartConnector(Connector newStartConnector) {
d329 1
a329 1
	
d334 1
a334 1
	private void setEndConnector(Connector newEndConnector) {
d337 1
a337 1
	
d342 1
a342 1
	private void setTargetConnector(Connector newTargetConnector) {
d345 1
a345 1
	
d349 2
a350 2
	
	private void setTargetFigure(Figure newTarget) {
d353 1
a353 1
	
d366 1
a366 1
	private void setAddedFigure(Figure newAddedFigure) {
d403 1
a403 1
			
d405 1
a405 1
			while (fe.hasMoreElements()) {
d432 1
a432 1
		private void setConnection(ConnectionFigure newConnection) {
d435 1
a435 1
		
@


1.3
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d79 3
a81 3
	public ConnectionTool(DrawingView view, ConnectionFigure prototype) {
		super(view);
		fPrototype = prototype;
d100 3
a102 3
		setTarget(findConnectionStart(ex, ey, drawing()));
		if (getTarget() != null) {
			setStartConnector(findConnector(ex, ey, getTarget()));
d172 1
d178 2
a179 2
		if (getTarget() != null) {
			getTarget().connectorVisibility(false);
d235 1
a235 1
	 * Gets the currently created figure
d252 7
a258 7
		if (c != getTarget()) {
			if (getTarget() != null) {
				getTarget().connectorVisibility(false);
			}
			setTarget(c);
			if (getTarget() != null) {
				getTarget().connectorVisibility(true);
d324 1
a324 1
	private void setTarget(Figure newTarget) {
d328 1
a328 1
	protected Figure getTarget() {
@


1.2
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d2 1
a2 1
 * @@(#)ConnectionTool.java 5.2
d4 6
d14 4
a21 3
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.Geom;

d37 2
a39 1

d42 374
a415 239
    /**
     * the anchor point of the interaction
     */
    private Connector   fStartConnector;
    private Connector   fEndConnector;
    private Connector   fConnectorTarget = null;

    private Figure fTarget = null;

    /**
     * the currently created figure
     */
    private ConnectionFigure  fConnection;

    /**
     * the currently manipulated connection point
     */
    private int  fSplitPoint;

    /**
     * the currently edited connection
     */
    private ConnectionFigure  fEditedConnection = null;

    /**
     * the prototypical figure that is used to create new
     * connections.
     */
    private ConnectionFigure  fPrototype;


    public ConnectionTool(DrawingView view, ConnectionFigure prototype) {
        super(view);
        fPrototype = prototype;
    }

    /**
     * Handles mouse move events in the drawing view.
     */
    public void mouseMove(MouseEvent e, int x, int y) {
        trackConnectors(e, x, y);
    }

    /**
     * Manipulates connections in a context dependent way. If the
     * mouse down hits a figure start a new connection. If the mousedown
     * hits a connection split a segment or join two segments.
     */
    public void mouseDown(MouseEvent e, int x, int y)
    {
        int ex = e.getX();
        int ey = e.getY();
        fTarget = findConnectionStart(ex, ey, drawing());
        if (fTarget != null) {
            fStartConnector = findConnector(ex, ey, fTarget);
            if (fStartConnector != null) {
                Point p = new Point(ex, ey);
                fConnection = createConnection();
                fConnection.startPoint(p.x, p.y);
                fConnection.endPoint(p.x, p.y);
                view().add(fConnection);
            }
        }
        else {
            ConnectionFigure connection = findConnection(ex, ey, drawing());
            if (connection != null) {
                if (!connection.joinSegments(ex, ey)) {
                    fSplitPoint = connection.splitSegment(ex, ey);
                    fEditedConnection = connection;
                } else {
                    fEditedConnection = null;
                }
            }
        }
    }

    /**
     * Adjust the created connection or split segment.
     */
    public void mouseDrag(MouseEvent e, int x, int y) {
        Point p = new Point(e.getX(), e.getY());
        if (fConnection != null) {
            trackConnectors(e, x, y);
            if (fConnectorTarget != null)
                p = Geom.center(fConnectorTarget.displayBox());
            fConnection.endPoint(p.x, p.y);
        }
        else if (fEditedConnection != null) {
            Point pp = new Point(x, y);
            fEditedConnection.setPointAt(pp, fSplitPoint);
        }
    }

    /**
     * Connects the figures if the mouse is released over another
     * figure.
     */
    public void mouseUp(MouseEvent e, int x, int y) {
        Figure c = null;
        if (fStartConnector != null)
            c = findTarget(e.getX(), e.getY(), drawing());

        if (c != null) {
            fEndConnector = findConnector(e.getX(), e.getY(), c);
            if (fEndConnector != null) {
                fConnection.connectStart(fStartConnector);
                fConnection.connectEnd(fEndConnector);
                fConnection.updateConnection();
            }
        } else if (fConnection != null)
            view().remove(fConnection);

        fConnection = null;
        fStartConnector = fEndConnector = null;
        editor().toolDone();
    }

    public void deactivate() {
        super.deactivate();
        if (fTarget != null)
            fTarget.connectorVisibility(false);
    }

    /**
     * Creates the ConnectionFigure. By default the figure prototype is
     * cloned.
     */
    protected ConnectionFigure createConnection() {
        return (ConnectionFigure)fPrototype.clone();
    }

    /**
     * Finds a connectable figure target.
     */
    protected Figure findSource(int x, int y, Drawing drawing) {
        return findConnectableFigure(x, y, drawing);
    }

    /**
     * Finds a connectable figure target.
     */
    protected Figure findTarget(int x, int y, Drawing drawing) {
        Figure target = findConnectableFigure(x, y, drawing);
        Figure start = fStartConnector.owner();

        if (target != null
             && fConnection != null
             && target.canConnect()
             && !target.includes(start)
             && fConnection.canConnect(start, target))
            return target;
        return null;
    }

    /**
     * Finds an existing connection figure.
     */
    protected ConnectionFigure findConnection(int x, int y, Drawing drawing) {
        Enumeration k = drawing.figuresReverse();
        while (k.hasMoreElements()) {
            Figure figure = (Figure) k.nextElement();
            figure = figure.findFigureInside(x, y);
            if (figure != null && (figure instanceof ConnectionFigure))
                return (ConnectionFigure)figure;
        }
        return null;
    }

    /**
     * Gets the currently created figure
     */
    protected ConnectionFigure createdFigure() {
        return fConnection;
    }

    protected void trackConnectors(MouseEvent e, int x, int y) {
        Figure c = null;

        if (fStartConnector == null)
            c = findSource(x, y, drawing());
        else
            c = findTarget(x, y, drawing());

        // track the figure containing the mouse
        if (c != fTarget) {
            if (fTarget != null)
                fTarget.connectorVisibility(false);
            fTarget = c;
            if (fTarget != null)
                fTarget.connectorVisibility(true);
        }

        Connector cc = null;
        if (c != null)
            cc = findConnector(e.getX(), e.getY(), c);
        if (cc != fConnectorTarget)
            fConnectorTarget = cc;

        view().checkDamage();
    }

    private Connector findConnector(int x, int y, Figure f) {
        return f.connectorAt(x, y);
    }

    /**
     * Finds a connection start figure.
     */
    protected Figure findConnectionStart(int x, int y, Drawing drawing) {
        Figure target = findConnectableFigure(x, y, drawing);
        if ((target != null) && target.canConnect())
            return target;
        return null;
    }

    private Figure findConnectableFigure(int x, int y, Drawing drawing) {
        FigureEnumeration k = drawing.figuresReverse();
        while (k.hasMoreElements()) {
            Figure figure = k.nextFigure();
            if (!figure.includes(fConnection) && figure.canConnect()) {
                if (figure.containsPoint(x, y))
                    return figure;
            }
        }
        return null;
    }

    protected Connector getStartConnector() {
        return fStartConnector;
    }

    protected Connector getEndConnector() {
        return fEndConnector;
    }

    protected Connector getTarget() {
        return fConnectorTarget;
    }

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * @@(#)ConnectionTool.java 5.1
@


1.1.1.1
log
@
Initial revision.
@
text
@@
